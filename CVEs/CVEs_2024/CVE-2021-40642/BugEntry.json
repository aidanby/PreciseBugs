{"buggy_code": ["<?php\n\n/*\n * Textpattern Content Management System\n * https://textpattern.com/\n *\n * Copyright (C) 2021 The Textpattern Development Team\n *\n * This file is part of Textpattern.\n *\n * Textpattern is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation, version 2.\n *\n * Textpattern is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Textpattern. If not, see <https://www.gnu.org/licenses/>.\n */\n\n/**\n * Collection of miscellaneous tools.\n *\n * @package Misc\n */\n\n/**\n * Strips NULL bytes.\n *\n * @param  string|array $in The input value\n * @return mixed\n */\n\nfunction deNull($in)\n{\n    return is_array($in) ? doArray($in, 'deNull') : strtr($in, array(\"\\0\" => ''));\n}\n\n/**\n * Strips carriage returns and linefeeds.\n *\n * @param  string|array $in The input value\n * @return mixed\n */\n\nfunction deCRLF($in)\n{\n    return is_array($in) ? doArray($in, 'deCRLF') : strtr($in, array(\n        \"\\n\" => '',\n        \"\\r\" => '',\n    ));\n}\n\n/**\n * Applies a callback to a given string or an array.\n *\n * @param  string|array $in       An array or a string to run through the callback function\n * @param  callback     $function The callback function\n * @return mixed\n * @example\n * echo doArray(array('value1', 'value2'), 'intval');\n */\n\nfunction doArray($in, $function)\n{\n    if (is_array($in)) {\n        return array_map($function, $in);\n    }\n\n    if (is_array($function)) {\n        return call_user_func($function, $in);\n    }\n\n    return $function($in);\n}\n\n/**\n * Un-quotes a quoted string or an array of values.\n *\n * @param  string|array $in The input value\n * @return mixed\n */\n\nfunction doStrip($in)\n{\n    return is_array($in) ? doArray($in, 'doStrip') : doArray($in, 'stripslashes');\n}\n\n/**\n * Strips HTML and PHP tags from a string or an array.\n *\n * @param  string|array $in The input value\n * @return mixed\n * @example\n * echo doStripTags('<p>Hello world!</p>');\n */\n\nfunction doStripTags($in)\n{\n    return is_array($in) ? doArray($in, 'doStripTags') : doArray($in, 'strip_tags');\n}\n\n/**\n * Converts entity escaped brackets back to characters.\n *\n * @param  string|array $in The input value\n * @return mixed\n */\n\nfunction doDeEnt($in)\n{\n    return doArray($in, 'deEntBrackets');\n}\n\n/**\n * Converts entity escaped brackets back to characters.\n *\n * @param  string $in The input value\n * @return string\n */\n\nfunction deEntBrackets($in)\n{\n    $array = array(\n        '&#60;'  => '<',\n        '&lt;'   => '<',\n        '&#x3C;' => '<',\n        '&#62;'  => '>',\n        '&gt;'   => '>',\n        '&#x3E;' => '>',\n    );\n\n    foreach ($array as $k => $v) {\n        $in = preg_replace(\"/\".preg_quote($k).\"/i\", $v, $in);\n    }\n\n    return $in;\n}\n\n/**\n * Escapes special characters for use in an SQL statement.\n *\n * Always use this function when dealing with user-defined values in SQL\n * statements. If this function is not used to escape user-defined data in a\n * statement, the query is vulnerable to SQL injection attacks.\n *\n * @param   string|array $in The input value\n * @return  mixed An array of escaped values or a string depending on $in\n * @package DB\n * @example\n * echo safe_field('column', 'table', \"color = '\" . doSlash(gps('color')) . \"'\");\n */\n\nfunction doSlash($in)\n{\n    return doArray($in, 'safe_escape');\n}\n\n/**\n * Escape SQL LIKE pattern's wildcards for use in an SQL statement.\n *\n * @param   string|array $in The input value\n * @return  mixed An array of escaped values or a string depending on $in\n * @since   4.6.0\n * @package DB\n * @example\n * echo safe_field('column', 'table', \"color LIKE '\" . doLike(gps('color')) . \"'\");\n */\n\nfunction doLike($in)\n{\n    return doArray($in, 'safe_escape_like');\n}\n\n/**\n * A shell for htmlspecialchars() with $flags defaulting to ENT_QUOTES.\n *\n * @param   string $string The string being converted\n * @param   int    $flags A bitmask of one or more flags. The default is ENT_QUOTES\n * @param   string $encoding Defines encoding used in conversion. The default is UTF-8\n * @param   bool   $double_encode When double_encode is turned off PHP will not encode existing HTML entities, the default is to convert everything\n * @return  string\n * @see     https://www.php.net/manual/en/function.htmlspecialchars.php\n * @since   4.5.0\n * @package Filter\n */\n\nfunction txpspecialchars($string, $flags = ENT_QUOTES, $encoding = 'UTF-8', $double_encode = true)\n{\n    //    Ignore ENT_HTML5 and ENT_XHTML for now.\n    //    ENT_HTML5 and ENT_XHTML are defined in PHP 5.4+ but we consistently encode single quotes as &#039; in any doctype.\n    //    global $prefs;\n    //    static $h5 = null;\n    //\n    //    if (defined(ENT_HTML5)) {\n    //        if ($h5 === null) {\n    //            $h5 = ($prefs['doctype'] == 'html5' && txpinterface == 'public');\n    //        }\n    //\n    //        if ($h5) {\n    //            $flags = ($flags | ENT_HTML5) & ~ENT_HTML401;\n    //        }\n    //    }\n    //\n    return htmlspecialchars((string)$string, $flags, $encoding, $double_encode);\n}\n\n/**\n * Converts special characters to HTML entities.\n *\n * @param   array|string $in The input value\n * @return  mixed The array or string with HTML syntax characters escaped\n * @package Filter\n */\n\nfunction doSpecial($in)\n{\n    return doArray($in, 'txpspecialchars');\n}\n\n/**\n * Converts the given value to NULL.\n *\n * @param   mixed $a The input value\n * @return  null\n * @package Filter\n * @access  private\n */\n\nfunction _null($a)\n{\n    return null;\n}\n\n/**\n * Converts an array of values to NULL.\n *\n * @param   array $in The array\n * @return  array\n * @package Filter\n */\n\nfunction array_null($in)\n{\n    return array_map('_null', $in);\n}\n\n/**\n * Escapes a page title. Converts &lt;, &gt;, ', \" characters to HTML entities.\n *\n * @param   string $title The input string\n * @return  string The string escaped\n * @package Filter\n */\n\nfunction escape_title($title)\n{\n    return strtr($title, array(\n        '<' => '&#60;',\n        '>' => '&#62;',\n        \"'\" => '&#39;',\n        '\"' => '&#34;',\n    ));\n}\n\n/**\n * Sanitises a string for use in a JavaScript string.\n *\n * Escapes \\, \\n, \\r, \" and ' characters. It removes 'PARAGRAPH SEPARATOR'\n * (U+2029) and 'LINE SEPARATOR' (U+2028). When you need to pass a string\n * from PHP to JavaScript, use this function to sanitise the value to avoid\n * XSS attempts.\n *\n * @param   string $js JavaScript input\n * @return  string Escaped JavaScript\n * @since   4.4.0\n * @package Filter\n */\n\nfunction escape_js($js)\n{\n    $js = preg_replace('/[\\x{2028}\\x{2029}]/u', '', $js);\n\n    return addcslashes($js, \"\\\\\\'\\\"\\n\\r\");\n}\n\n/**\n * Escapes CDATA section for an XML document.\n *\n * @param   string $str The string\n * @return  string XML representation wrapped in CDATA tags\n * @package XML\n */\n\nfunction escape_cdata($str)\n{\n    return '<![CDATA['.str_replace(']]>', ']]]><![CDATA[]>', $str).']]>';\n}\n\n/**\n * Returns a localisation string.\n *\n * @param   string $var    String name\n * @param   array  $atts   Replacement pairs\n * @param   string $escape Convert special characters to HTML entities. Either \"html\" or \"\"\n * @return  string A localisation string\n * @package L10n\n */\n\nfunction gTxt($var, $atts = array(), $escape = 'html')\n{\n    global $event, $plugin, $txp_current_plugin;\n    static $txpLang = null;\n\n    if ($txpLang === null) {\n        $txpLang = Txp::get('\\Textpattern\\L10n\\Lang');\n        $lang = txpinterface == 'admin' ? get_pref('language_ui', gps('lang', LANG)) : LANG;\n        $loaded = $txpLang->load($lang, true);\n        $evt = isset($event) ? trim($event) : '';\n\n        if (empty($loaded) || !in_array($evt, $loaded)) {\n            load_lang($lang, $evt);\n        }\n    }\n\n    // Hackish\n    if (isset($txp_current_plugin) && isset($plugin['textpack'])) {\n        $txpLang->loadTextpack($plugin['textpack']);\n        unset($plugin['textpack']);\n    }\n\n    return $txpLang->txt($var, $atts, $escape);\n}\n\n/**\n * Returns given timestamp in a format of 01 Jan 2001 15:19:16.\n *\n * @param   int $timestamp The UNIX timestamp\n * @return  string A formatted date\n * @access  private\n * @see     safe_stftime()\n * @package DateTime\n * @example\n * echo gTime();\n */\n\nfunction gTime($timestamp = 0)\n{\n    return safe_strftime('%d&#160;%b&#160;%Y %X', $timestamp);\n}\n\n/**\n * Creates a dumpfile from a backtrace and outputs given parameters.\n *\n * @package Debug\n */\n\nfunction dmp()\n{\n    static $f = false;\n\n    if (defined('txpdmpfile')) {\n        global $prefs;\n\n        if (!$f) {\n            $f = fopen($prefs['tempdir'].'/'.txpdmpfile, 'a');\n        }\n\n        $stack = get_caller();\n        fwrite($f, \"\\n[\".$stack[0].t.safe_strftime('iso8601').\"]\\n\");\n    }\n\n    $a = func_get_args();\n\n    if (!$f) {\n        echo \"<pre dir=\\\"auto\\\">\".n;\n    }\n\n    foreach ($a as $thing) {\n        $out = is_scalar($thing) ? strval($thing) : var_export($thing, true);\n\n        if ($f) {\n            fwrite($f, $out.n);\n        } else {\n            echo txpspecialchars($out).n;\n        }\n    }\n\n    if (!$f) {\n        echo \"</pre>\".n;\n    }\n}\n\n/**\n * Gets the given language's strings from the database.\n *\n * Fetches the given language from the database and returns the strings\n * as an array.\n *\n * If no $events is specified, only appropriate strings for the current context\n * are returned. If 'txpinterface' constant equals 'admin' all strings are\n * returned. Otherwise, only strings from events 'common' and 'public'.\n *\n * If $events is FALSE, returns all strings.\n *\n * @param   string            $lang   The language code\n * @param   array|string|bool $events An array of loaded events\n * @return  array\n * @package L10n\n * @example\n * print_r(\n *     load_lang('en-gb', false)\n * );\n */\n\nfunction load_lang($lang, $events = null)\n{\n    global $production_status, $event, $textarray;\n\n    isset($textarray) or $textarray = array();\n    $textarray = array_merge($textarray, Txp::get('\\Textpattern\\L10n\\Lang')->load($lang, $events));\n\n    if (($production_status !== 'live' || $event === 'diag')\n        && @$debug = parse_ini_file(txpath.DS.'mode.ini')\n    ) {\n        $textarray += (array)$debug;\n        Txp::get('\\Textpattern\\L10n\\Lang')->setPack($textarray);\n    }\n\n    return $textarray;\n}\n\n/**\n * Gets a list of user groups.\n *\n * @return  array\n * @package User\n * @example\n * print_r(\n *     get_groups()\n * );\n */\n\nfunction get_groups()\n{\n    global $txp_groups;\n\n    return doArray($txp_groups, 'gTxt');\n}\n\n/**\n * Checks if a user has privileges to the given resource.\n *\n * @param   string $res  The resource\n * @param   mixed  $user The user. If no user name is supplied, assume the current logged in user\n * @return  bool\n * @package User\n * @example\n * add_privs('my_privilege_resource', '1,2,3');\n * if (has_privs('my_privilege_resource', 'username'))\n * {\n *     echo \"'username' has privileges to 'my_privilege_resource'.\";\n * }\n */\n\nfunction has_privs($res = null, $user = '')\n{\n    global $txp_user, $txp_permissions;\n    static $privs;\n\n    if (is_array($user)) {\n        $level = isset($user['privs']) ? $user['privs'] : null;\n        $user = isset($user['name']) ? $user['name'] : '';\n    }\n\n    $user = (string) $user;\n\n    if ($user === '') {\n        $user = (string) $txp_user;\n    }\n\n    if ($user !== '') {\n        if (!isset($privs[$user])) {\n            $privs[$user] = isset($level) ?\n                $level :\n                safe_field(\"privs\", 'txp_users', \"name = '\".doSlash($user).\"'\");\n        }\n\n        if (!isset($res)) {\n            return $privs[$user];\n        } elseif (isset($txp_permissions[$res]) && $privs[$user] && $txp_permissions[$res]) {\n            return in_list($privs[$user], $txp_permissions[$res]);\n        }\n    }\n\n    return false;\n}\n\n/**\n * Adds dynamic privileges.\n *\n * @param   array $pluggable The array, see global $txp_options\n * @since   4.7.2\n * @package User\n */\n\nfunction plug_privs($pluggable = null, $user = null)\n{\n    global $txp_options;\n\n    isset($pluggable) or $pluggable = $txp_options;\n    $level = isset($user['privs']) ? $user['privs'] : has_privs();\n\n    foreach ((array)$pluggable as $pref => $pane) {\n        if (is_array($pane)) {\n            if (isset($pane[0])) {\n                if (!in_list($level, $pane[0])) {\n                    break;\n                }\n\n                unset($pane[0]);\n            }\n        } else {\n            $pane = array('prefs.'.$pref => $pane);\n        }\n\n        if (get_pref($pref)) {\n            array_walk($pane, function (&$item) use ($level) {\n                if ($item === true) {\n                    $item = $level;\n                }\n            });\n            add_privs($pane);\n        } else {\n            add_privs(array_fill_keys(array_keys($pane), null));\n        }\n    }\n}\n\n/**\n * Grants privileges to user-groups.\n *\n * Will not let you override existing privs.\n *\n * @param   mixed  $res  The resource\n * @param   string $perm List of user-groups, e.g. '1,2,3'\n * @package User\n * @example\n * add_privs('my_admin_side_panel_event', '1,2,3,4,5');\n */\n\nfunction add_privs($res, $perm = '1')\n{\n    global $txp_permissions;\n\n    if (!is_array($res)) {\n        $res = array($res => $perm);\n    }\n\n    foreach ($res as $priv => $group) {\n        if ($group === null) {\n            $txp_permissions[$priv] = null;\n        } else {\n            $group .= (empty($txp_permissions[$priv]) ? '' : ','.$txp_permissions[$priv]);\n            $group = join(',', do_list_unique($group));\n            $txp_permissions[$priv] = $group;\n        }\n    }\n}\n\n/**\n * Require privileges from a user to the given resource.\n *\n * Terminates the script if user doesn't have required privileges.\n *\n * @param   string|null $res  The resource, or NULL\n * @param   string      $user The user. If no user name is supplied, assume the current logged in user\n * @package User\n * @example\n * require_privs('article.edit');\n */\n\nfunction require_privs($res = null, $user = '')\n{\n    if ($res === null || !has_privs($res, $user)) {\n        pagetop(gTxt('restricted_area'));\n        echo graf(gTxt('restricted_area'), array('class' => 'restricted-area'));\n        end_page();\n        exit;\n    }\n}\n\n/**\n * Gets a list of users having access to a resource.\n *\n * @param   string $res The resource, e.g. 'article.edit.published'\n * @return  array  A list of usernames\n * @since   4.5.0\n * @package User\n */\n\nfunction the_privileged($res, $real = false)\n{\n    global $txp_permissions;\n\n    $out = array();\n\n    if (isset($txp_permissions[$res])) {\n        foreach (safe_rows(\"name, RealName\", 'txp_users', \"FIND_IN_SET(privs, '\".$txp_permissions[$res].\"') ORDER BY \".($real ? \"RealName\" : \"name\").\" ASC\") as $user) {\n            extract($user);\n            $out[$name] = $real ? $RealName : $name;\n        }\n    }\n\n    return $out;\n}\n\n/**\n * Lists image types that can be safely uploaded.\n *\n * Returns different results based on the logged in user's privileges.\n *\n * @param   int         $type If set, validates the given value\n * @return  mixed\n * @package Image\n * @since   4.6.0\n * @example\n * list($width, $height, $extension) = getimagesize('image');\n * if ($type = get_safe_image_types($extension))\n * {\n *     echo \"Valid image of {$type}.\";\n * }\n */\n\nfunction get_safe_image_types($type = null)\n{\n    $extensions = array(IMAGETYPE_GIF => '.gif', 0 => '.jpeg', IMAGETYPE_JPEG => '.jpg', IMAGETYPE_PNG => '.png') +\n        (defined('IMAGETYPE_WEBP') ? array(IMAGETYPE_WEBP => '.webp') : array());\n\n    if (has_privs('image.create.trusted')) {\n        $extensions += array(IMAGETYPE_SWF => '.swf', IMAGETYPE_SWC => '.swf');\n    }\n\n    callback_event_ref('txp.image', 'types', 0, $extensions);\n\n    if (isset($type)) {\n        return !empty($extensions[$type]) ? $extensions[$type] : false;\n    }\n\n    return $extensions;\n}\n\n\n/**\n * Gets the dimensions of an image for a HTML &lt;img&gt; tag.\n *\n * @param   string      $name The filename\n * @return  string|bool height=\"100\" width=\"40\", or FALSE on failure\n * @package Image\n * @example\n * if ($size = sizeImage('/path/to/image.png'))\n * {\n *     echo \"&lt;img src='image.png' {$size} /&gt;\";\n * }\n */\n\nfunction sizeImage($name)\n{\n    $size = @getimagesize($name);\n\n    return is_array($size) ? $size[3] : false;\n}\n\n/**\n * Gets an image as an array.\n *\n * @param   int $id image ID\n * @param   string $name image name\n * @return  array|bool An image data array, or FALSE on failure\n * @package Image\n * @example\n * if ($image = imageFetchInfo($id))\n * {\n *     print_r($image);\n * }\n */\n\nfunction imageFetchInfo($id = \"\", $name = \"\")\n{\n    global $thisimage, $p;\n    static $cache = array();\n\n    if ($id) {\n        if (isset($cache['i'][$id])) {\n            return $cache['i'][$id];\n        } else {\n            $where = 'id = '.intval($id).' LIMIT 1';\n        }\n    } elseif ($name) {\n        if (isset($cache['n'][$name])) {\n            return $cache['n'][$name];\n        } else {\n            $where = \"name = '\".doSlash($name).\"' LIMIT 1\";\n        }\n    } elseif ($thisimage) {\n        $id = (int) $thisimage['id'];\n        return $cache['i'][$id] = $thisimage;\n    } elseif ($p) {\n        if (isset($cache['i'][$p])) {\n            return $cache['i'][$p];\n        } else {\n            $where = 'id = '.intval($p).' LIMIT 1';\n        }\n    } else {\n        assert_image();\n        return false;\n    }\n\n    $rs = safe_row(\"*\", 'txp_image', $where);\n\n    if ($rs) {\n        $id = (int) $rs['id'];\n        return $cache['i'][$id] = image_format_info($rs);\n    } else {\n        trigger_error(gTxt('unknown_image'));\n    }\n\n    return false;\n}\n\n/**\n * Formats image info.\n *\n * Takes an image data array generated by imageFetchInfo() and formats the contents.\n *\n * @param   array $image The image\n * @return  array\n * @see     imageFetchInfo()\n * @access  private\n * @package Image\n */\n\nfunction image_format_info($image)\n{\n    static $mimetypes;\n\n    if (($unix_ts = @strtotime($image['date'])) > 0) {\n        $image['date'] = $unix_ts;\n    }\n\n    if (!isset($mimetypes)) {\n        $mimetypes = get_safe_image_types();\n    }\n\n    $image['mime'] = ($mime = array_search($image['ext'], $mimetypes)) !== false ? image_type_to_mime_type($mime) : '';\n\n    return $image;\n}\n\n/**\n * Formats link info.\n *\n * @param   array $link The link to format\n * @return  array Formatted link data\n * @access  private\n * @package Link\n */\n\nfunction link_format_info($link)\n{\n    if (($unix_ts = @strtotime($link['date'])) > 0) {\n        $link['date'] = $unix_ts;\n    }\n\n    return $link;\n}\n\n/**\n * Gets a HTTP GET or POST parameter.\n *\n * Internally strips CRLF from GET parameters and removes NULL bytes.\n *\n * @param   string $thing The parameter to get\n * @return  string|array The value of $thing, or an empty string\n * @package Network\n * @example\n * if (gps('sky') == 'blue' && gps('roses') == 'red')\n * {\n *     echo 'Roses are red, sky is blue.';\n * }\n */\n\nfunction gps($thing, $default = '')\n{\n    global $pretext;\n\n    if (isset($_GET[$thing])) {\n        $out = $_GET[$thing];\n        $out = doArray($out, 'deCRLF');\n    } elseif (isset($_POST[$thing])) {\n        $out = $_POST[$thing];\n    } elseif (is_numeric($thing) && isset($pretext[abs($thing)])) {\n        $thing >= 0 or $thing += $pretext[0] + 1;\n        $out = $pretext[$thing];\n    } else {\n        return $default;\n    }\n\n    $out = doArray($out, 'deNull');\n\n    return $out;\n}\n\n/**\n * Gets an array of HTTP GET or POST parameters.\n *\n * @param   array $array The parameters to extract\n * @return  array\n * @package Network\n * @example\n * extract(gpsa(array('sky', 'roses'));\n * if ($sky == 'blue' && $roses == 'red')\n * {\n *     echo 'Roses are red, sky is blue.';\n * }\n */\n\nfunction gpsa($array)\n{\n    if (is_array($array)) {\n        $out = array();\n\n        foreach ($array as $a) {\n            $out[$a] = gps($a);\n        }\n\n        return $out;\n    }\n\n    return false;\n}\n\n/**\n * Gets a HTTP POST parameter.\n *\n * Internally removes NULL bytes.\n *\n * @param   string $thing The parameter to get\n * @return  string|array The value of $thing, or an empty string\n * @package Network\n * @example\n * if (ps('sky') == 'blue' && ps('roses') == 'red')\n * {\n *     echo 'Roses are red, sky is blue.';\n * }\n */\n\nfunction ps($thing)\n{\n    $out = '';\n\n    if (isset($_POST[$thing])) {\n        $out = $_POST[$thing];\n    }\n\n    $out = doArray($out, 'deNull');\n\n    return $out;\n}\n\n/**\n * Gets an array of HTTP POST parameters.\n *\n * @param   array $array The parameters to extract\n * @return  array\n * @package Network\n * @example\n * extract(psa(array('sky', 'roses'));\n * if ($sky == 'blue' && $roses == 'red')\n * {\n *     echo 'Roses are red, sky is blue.';\n * }\n */\n\nfunction psa($array)\n{\n    foreach ($array as $a) {\n        $out[$a] = ps($a);\n    }\n\n    return $out;\n}\n\n/**\n * Gets an array of HTTP POST parameters and strips HTML and PHP tags\n * from values.\n *\n * @param   array $array The parameters to extract\n * @return  array\n * @package Network\n */\n\nfunction psas($array)\n{\n    foreach ($array as $a) {\n        $out[$a] = doStripTags(ps($a));\n    }\n\n    return $out;\n}\n\n/**\n * Gets all received HTTP POST parameters.\n *\n * @return  array\n * @package Network\n */\n\nfunction stripPost()\n{\n    if (isset($_POST)) {\n        return $_POST;\n    }\n\n    return '';\n}\n\n/**\n * Gets a variable from $_SERVER global array.\n *\n * @param   mixed $thing The variable\n * @return  mixed The variable, or an empty string on error\n * @package System\n * @example\n * echo serverSet('HTTP_USER_AGENT');\n */\n\nfunction serverSet($thing)\n{\n    return (isset($_SERVER[$thing])) ? $_SERVER[$thing] : '';\n}\n\n/**\n * Gets the client's IP address.\n *\n * Supports proxies and uses 'X_FORWARDED_FOR' HTTP header if deemed necessary.\n *\n * @return  string\n * @package Network\n * @example\n * if ($ip = remote_addr())\n * {\n *     echo \"Your IP address is: {$ip}.\";\n * }\n */\n\nfunction remote_addr()\n{\n    $ip = serverSet('REMOTE_ADDR');\n\n    if (($ip == '127.0.0.1' || $ip == '::1' || $ip == '::ffff:127.0.0.1' || $ip == serverSet('SERVER_ADDR')) && serverSet('HTTP_X_FORWARDED_FOR')) {\n        $ips = explode(', ', serverSet('HTTP_X_FORWARDED_FOR'));\n        $ip = $ips[0];\n    }\n\n    return $ip;\n}\n\n/**\n * Gets a variable from HTTP POST or a prefixed cookie.\n *\n * Fetches either a HTTP cookie of the given name prefixed with\n * 'txp_', or a HTTP POST parameter without a prefix.\n *\n * @param   string $thing The variable\n * @return  array|string The variable or an empty string\n * @package Network\n * @example\n * if ($cs = psc('myVariable'))\n * {\n *     echo \"'txp_myVariable' cookie or 'myVariable' POST parameter contained: '{$cs}'.\";\n * }\n */\n\nfunction pcs($thing)\n{\n    if (isset($_COOKIE[\"txp_\".$thing])) {\n        return $_COOKIE[\"txp_\".$thing];\n    } elseif (isset($_POST[$thing])) {\n        return $_POST[$thing];\n    }\n\n    return '';\n}\n\n/**\n * Gets a HTTP cookie.\n *\n * @param   string $thing The cookie\n * @return  string The cookie or an empty string\n * @package Network\n * @example\n * if ($cs = cs('myVariable'))\n * {\n *     echo \"'myVariable' cookie contained: '{$cs}'.\";\n * }\n */\n\nfunction cs($thing)\n{\n    if (isset($_COOKIE[$thing])) {\n        return $_COOKIE[$thing];\n    }\n\n    return '';\n}\n\n/**\n * Sets a HTTP cookie (polyfill).\n *\n * @param   string $name The cookie name\n * @param   string $value The cookie value\n * @param   array  $options The cookie options\n * @package Network\n */\n\nfunction set_cookie($name, $value = '', $options = array())\n{\n    $options += array (\n        'expires' => time() - 3600,\n        'path' => '',\n        'domain' => '',\n        'secure' => false,\n        'httponly' => false,\n        'samesite' => 'Lax' // None || Lax  || Strict\n    );\n\n    if (version_compare(phpversion(), '7.3.0') >= 0) {\n        return setcookie($name, $value, $options);\n    }\n\n    extract($options);\n\n    return setcookie($name, $value, $expires, $path.'; samesite='.$samesite, $domain, $secure, $httponly);\n}\n\n/**\n * Converts a boolean to a localised \"Yes\" or \"No\" string.\n *\n * @param   bool $status The boolean. Ignores type and as such can also take a string or an integer\n * @return  string No if FALSE, Yes otherwise\n * @package L10n\n * @example\n * echo yes_no(3 * 3 === 2);\n */\n\nfunction yes_no($status)\n{\n    return ($status) ? gTxt('yes') : gTxt('no');\n}\n\n/**\n * Gets UNIX timestamp with microseconds.\n *\n * @return  float\n * @package DateTime\n * @example\n * echo getmicrotime();\n */\n\nfunction getmicrotime()\n{\n    list($usec, $sec) = explode(\" \", microtime());\n\n    return ((float) $usec + (float) $sec);\n}\n\n/**\n * Loads the given plugin or checks if it was loaded.\n *\n * @param  string $name  The plugin\n * @param  bool   $force If TRUE loads the plugin even if it's disabled\n * @return bool TRUE if the plugin is loaded\n * @example\n * if (load_plugin('abc_plugin'))\n * {\n *     echo \"'abc_plugin' is active.\";\n * }\n */\n\nfunction load_plugin($name, $force = false)\n{\n    global $plugin, $plugins, $plugins_ver, $prefs, $txp_current_plugin, $textarray;\n\n    if (is_array($plugins) && in_array($name, $plugins)) {\n        return true;\n    }\n\n    if (!empty($prefs['plugin_cache_dir'])) {\n        $dir = rtrim($prefs['plugin_cache_dir'], '/').'/';\n\n        // In case it's a relative path.\n        if (!is_dir($dir)) {\n            $dir = rtrim(realpath(txpath.'/'.$dir), '/').'/';\n        }\n\n        if (is_file($dir.$name.'.php')) {\n            $plugins[] = $name;\n            $old_plugin = isset($plugin) ? $plugin : null;\n            set_error_handler(\"pluginErrorHandler\");\n\n            if (isset($txp_current_plugin)) {\n                $txp_parent_plugin = $txp_current_plugin;\n            }\n\n            $txp_current_plugin = $name;\n            include $dir.$name.'.php';\n            $txp_current_plugin = isset($txp_parent_plugin) ? $txp_parent_plugin : null;\n            $plugins_ver[$name] = isset($plugin['version']) ? $plugin['version'] : 0;\n\n            if (isset($plugin['textpack'])) {\n                Txp::get('\\Textpattern\\L10n\\Lang')->loadTextpack($plugin['textpack']);\n            }\n\n            restore_error_handler();\n            $plugin = $old_plugin;\n\n            return true;\n        }\n    }\n\n    $version = safe_field(\"version\", 'txp_plugin', ($force ? '' : \"status = 1 AND \").\"name = '\".doSlash($name).\"'\");\n\n    if ($version !== false) {\n        $plugins[] = $name;\n        $plugins_ver[$name] = $version;\n        set_error_handler(\"pluginErrorHandler\");\n\n        if (isset($txp_current_plugin)) {\n            $txp_parent_plugin = $txp_current_plugin;\n        }\n\n        $txp_current_plugin = $name;\n        $dir = sanitizeForFile($name);\n        $filename = PLUGINPATH.DS.$dir.DS.$dir.'.php';\n\n        if (!is_file($filename)) {\n            $code = safe_field(\"code\", 'txp_plugin', \"name = '\".doSlash($name).\"'\");\n            \\Txp::get('\\Textpattern\\Plugin\\Plugin')->updateFile($txp_current_plugin, $code);\n        }\n\n        $ok = is_readable($filename) ? include_once($filename) : false;\n        $txp_current_plugin = isset($txp_parent_plugin) ? $txp_parent_plugin : null;\n        restore_error_handler();\n\n        return $ok;\n    }\n\n    return false;\n}\n\n/**\n * Loads a plugin.\n *\n * Identical to load_plugin() except upon failure it issues an E_USER_ERROR.\n *\n * @param  string $name The plugin\n * @return bool\n * @see    load_plugin()\n */\n\nfunction require_plugin($name)\n{\n    if (!load_plugin($name)) {\n        trigger_error(gTxt('plugin_include_error', array('{name}' => $name)), E_USER_ERROR);\n\n        return false;\n    }\n\n    return true;\n}\n\n/**\n * Loads a plugin.\n *\n * Identical to load_plugin() except upon failure it issues an E_USER_WARNING.\n *\n * @param  string $name The plugin\n * @return bool\n * @see    load_plugin()\n */\n\nfunction include_plugin($name)\n{\n    if (!load_plugin($name)) {\n        trigger_error(gTxt('plugin_include_error', array('{name}' => $name)), E_USER_WARNING);\n\n        return false;\n    }\n\n    return true;\n}\n\n/**\n * Error handler for plugins.\n *\n * @param   int    $errno\n * @param   string $errstr\n * @param   string $errfile\n * @param   int    $errline\n * @access  private\n * @package Debug\n */\n\nfunction pluginErrorHandler($errno, $errstr, $errfile, $errline)\n{\n    global $production_status, $txp_current_plugin, $plugins_ver;\n\n    $error = array();\n\n    if ($production_status == 'testing') {\n        $error = array(\n            E_WARNING           => 'Warning',\n            E_RECOVERABLE_ERROR => 'Catchable fatal error',\n            E_USER_ERROR        => 'User_Error',\n            E_USER_WARNING      => 'User_Warning',\n        );\n    } elseif ($production_status == 'debug') {\n        $error = array(\n            E_WARNING           => 'Warning',\n            E_NOTICE            => 'Notice',\n            E_RECOVERABLE_ERROR => 'Catchable fatal error',\n            E_USER_ERROR        => 'User_Error',\n            E_USER_WARNING      => 'User_Warning',\n            E_USER_NOTICE       => 'User_Notice',\n        );\n\n        if (!isset($error[$errno])) {\n            $error[$errno] = $errno;\n        }\n    }\n\n    if (!isset($error[$errno]) || !error_reporting()) {\n        return;\n    }\n\n    $version = empty($plugins_ver[$txp_current_plugin]) ? '' : ' ('.$plugins_ver[$txp_current_plugin].')';\n\n    printf(\n        '<pre dir=\"auto\">'.gTxt('plugin_load_error').' <b>%s%s</b> -> <b>%s: %s on line %s</b></pre>',\n        $txp_current_plugin,\n        $version,\n        $error[$errno],\n        $errstr,\n        $errline\n    );\n\n    if ($production_status == 'debug') {\n        print \"\\n<pre class=\\\"backtrace\\\" dir=\\\"ltr\\\"><code>\".txpspecialchars(join(\"\\n\", get_caller(10))).\"</code></pre>\";\n    }\n}\n\n/**\n * Error handler for page templates.\n *\n * @param   int    $errno\n * @param   string $errstr\n * @param   string $errfile\n * @param   int    $errline\n * @access  private\n * @package Debug\n */\n\nfunction tagErrorHandler($errno, $errstr, $errfile, $errline)\n{\n    global $production_status, $txp_current_tag, $txp_current_form, $pretext, $trace;\n\n    $error = array();\n\n    if ($production_status == 'testing') {\n        $error = array(\n            E_WARNING           => 'Warning',\n            E_RECOVERABLE_ERROR => 'Textpattern Catchable fatal error',\n            E_USER_ERROR        => 'Textpattern Error',\n            E_USER_WARNING      => 'Textpattern Warning',\n        );\n    } elseif ($production_status == 'debug') {\n        $error = array(\n            E_WARNING           => 'Warning',\n            E_NOTICE            => 'Notice',\n            E_RECOVERABLE_ERROR => 'Textpattern Catchable fatal error',\n            E_USER_ERROR        => 'Textpattern Error',\n            E_USER_WARNING      => 'Textpattern Warning',\n            E_USER_NOTICE       => 'Textpattern Notice',\n        );\n\n        if (!isset($error[$errno])) {\n            $error[$errno] = $errno;\n        }\n    }\n\n    if (!isset($error[$errno]) || !error_reporting()) {\n        return;\n    }\n\n    if (empty($pretext['page'])) {\n        $page = gTxt('none');\n    } else {\n        $page = $pretext['page'];\n    }\n\n    if (!isset($txp_current_form)) {\n        $txp_current_form = gTxt('none');\n    }\n\n    $locus = gTxt('while_parsing_page_form', array(\n        '{page}' => $page,\n        '{form}' => $txp_current_form,\n    ));\n\n    printf(\n        \"<pre dir=\\\"auto\\\">\".gTxt('tag_error').' <b>%s</b> -> <b> %s: %s %s</b></pre>',\n        txpspecialchars($txp_current_tag),\n        $error[$errno],\n        $errstr,\n        $locus\n    );\n\n    if ($production_status == 'debug') {\n        print \"\\n<pre class=\\\"backtrace\\\" dir=\\\"ltr\\\"><code>\".txpspecialchars(join(\"\\n\", get_caller(10))).\"</code></pre>\";\n\n        $trace->log(gTxt('tag_error').' '.$txp_current_tag.' -> '.$error[$errno].': '.$errstr.' '.$locus);\n    }\n}\n\n/**\n * Error handler for XML feeds.\n *\n * @param   int    $errno\n * @param   string $errstr\n * @param   string $errfile\n * @param   int    $errline\n * @access  private\n * @package Debug\n */\n\nfunction feedErrorHandler($errno, $errstr, $errfile, $errline)\n{\n    global $production_status;\n\n    if ($production_status != 'debug') {\n        return;\n    }\n\n    return tagErrorHandler($errno, $errstr, $errfile, $errline);\n}\n\n/**\n * Error handler for public-side.\n *\n * @param   int    $errno\n * @param   string $errstr\n * @param   string $errfile\n * @param   int    $errline\n * @access  private\n * @package Debug\n */\n\nfunction publicErrorHandler($errno, $errstr, $errfile, $errline)\n{\n    global $production_status;\n\n    $error = array();\n\n    if ($production_status == 'testing') {\n        $error = array(\n            E_WARNING      => 'Warning',\n            E_USER_ERROR   => 'Textpattern Error',\n            E_USER_WARNING => 'Textpattern Warning',\n        );\n    } elseif ($production_status == 'debug') {\n        $error = array(\n            E_WARNING      => 'Warning',\n            E_NOTICE       => 'Notice',\n            E_USER_ERROR   => 'Textpattern Error',\n            E_USER_WARNING => 'Textpattern Warning',\n            E_USER_NOTICE  => 'Textpattern Notice',\n        );\n\n        if (!isset($error[$errno])) {\n            $error[$errno] = $errno;\n        }\n    }\n\n    if (!isset($error[$errno]) || !error_reporting()) {\n        return;\n    }\n\n    printf(\n        \"<pre dir=\\\"auto\\\">\".gTxt('general_error').' <b>%s: %s on line %s</b></pre>',\n        $error[$errno],\n        $errstr,\n        $errline\n    );\n\n    if ($production_status == 'debug') {\n        print \"\\n<pre class=\\\"backtrace\\\" dir=\\\"ltr\\\"><code>\".txpspecialchars(join(\"\\n\", get_caller(10))).\"</code></pre>\";\n    }\n}\n\n/**\n * Loads plugins.\n *\n * @param bool $type If TRUE loads admin-side plugins, otherwise public\n */\n\nfunction load_plugins($type = false, $pre = null)\n{\n    global $prefs, $plugins, $plugins_ver, $app_mode, $trace;\n    static $rs = null;\n\n    $trace->start('[Loading plugins]');\n    is_array($plugins) or $plugins = array();\n\n    if (!isset($rs)) {\n        if (!empty($prefs['plugin_cache_dir'])) {\n            $dir = rtrim($prefs['plugin_cache_dir'], DS).DS;\n\n            // In case it's a relative path.\n            if (!is_dir($dir)) {\n                $dir = rtrim(realpath(txpath.DS.$dir), DS).DS;\n            }\n\n            $files = glob($dir.'*.php');\n\n            if ($files) {\n                natsort($files);\n\n                foreach ($files as $f) {\n                    $trace->start(\"[Loading plugin from cache dir: '$f']\");\n                    load_plugin(basename($f, '.php'));\n                    $trace->stop();\n                }\n            }\n        }\n\n        $admin = ($app_mode == 'async' ? '4,5' : '1,3,4,5');\n        $where = 'status = 1 AND type IN ('.($type ? $admin : '0,1,5').')'.\n            ($plugins ? ' AND name NOT IN ('.join(',', quote_list($plugins)).')' : '');\n\n        $rs = safe_rows(\"name, version, load_order\", 'txp_plugin', $where.\" ORDER BY load_order ASC, name ASC\");\n    }\n\n    if ($rs) {\n        $old_error_handler = set_error_handler(\"pluginErrorHandler\");\n        $pre = intval($pre);\n\n        $writable = is_dir(PLUGINPATH) && is_writable(PLUGINPATH);\n\n        foreach ($rs as $a) {\n            if (!isset($plugins_ver[$a['name']]) && (!$pre || $a['load_order'] < $pre)) {\n                $plugins[] = $a['name'];\n                $plugins_ver[$a['name']] = $a['version'];\n                $GLOBALS['txp_current_plugin'] = $a['name'];\n                $trace->start(\"[Loading plugin: '{$a['name']}' version '{$a['version']}']\");\n\n                $dir = $a['name'];\n                $filename = PLUGINPATH.DS.$dir.DS.$dir.'.php';\n\n                if ($writable && !is_file($filename)) {\n                    $code = safe_field('code', 'txp_plugin', \"name='\".doSlash($a['name']).\"'\");\n                    \\Txp::get('\\Textpattern\\Plugin\\Plugin')->updateFile($a['name'], $code);\n                }\n\n                $eval_ok = is_readable($filename) ? include($filename) : false;\n                $trace->stop();\n\n                if ($eval_ok === false) {\n                    trigger_error(gTxt('plugin_include_error', array('{name}' => $a['name'])), E_USER_WARNING);\n                }\n\n                unset($GLOBALS['txp_current_plugin']);\n            }\n        }\n\n        restore_error_handler();\n    }\n\n    $trace->stop();\n}\n\n/**\n * Attaches a handler to a callback event.\n *\n * @param   callback $func  The callback function\n * @param   string   $event The callback event\n * @param   string   $step  The callback step\n * @param   bool     $pre   Before or after. Works only with selected callback events\n * @package Callback\n * @example\n * register_callback('my_callback_function', 'article.updated');\n * function my_callback_function($event)\n * {\n *     return \"'$event' fired.\";\n * }\n */\n\nfunction register_callback($func, $event, $step = '', $pre = 0)\n{\n    global $plugin_callback;\n\n    $pre or $pre = 0;\n\n    isset($plugin_callback[$event]) or $plugin_callback[$event] = array();\n    isset($plugin_callback[$event][$pre]) or $plugin_callback[$event][$pre] = array();\n    isset($plugin_callback[$event][$pre][$step]) or $plugin_callback[$event][$pre][$step] =\n        isset($plugin_callback[$event][$pre]['']) ? $plugin_callback[$event][$pre][''] : array();\n\n    if ($step === '') {\n        foreach($plugin_callback[$event][$pre] as $key => $val) {\n            $plugin_callback[$event][$pre][$key][] = $func;\n        }\n    } else {\n        $plugin_callback[$event][$pre][$step][] = $func;\n    }\n}\n\n/**\n * Call an event's callback.\n *\n * Executes all callback handlers attached to the matched event and step.\n *\n * When called, any event handlers attached with register_callback() to the\n * matching event, step and pre will be called. The handlers, callback\n * functions, will be executed in the same order they were registered.\n *\n * Any extra arguments will be passed to the callback handlers in the same\n * argument position. This allows passing any type of data to the attached\n * handlers. Callback handlers will also receive the event and the step.\n *\n * Returns a combined value of all values returned by the callback handlers.\n *\n * @param   string         $event The callback event\n * @param   string         $step  Additional callback step\n * @param   bool|int|array $pre   Allows two callbacks, a prepending and an appending, with same event and step. Array allows return values chaining\n * @return  mixed  The value returned by the attached callback functions, or an empty string\n * @package Callback\n * @see     register_callback()\n * @example\n * register_callback('my_callback_function', 'my_custom_event');\n * function my_callback_function($event, $step, $extra)\n * {\n *     return \"Passed '$extra' on '$event'.\";\n * }\n * echo callback_event('my_custom_event', '', 0, 'myExtraValue');\n */\n\nfunction callback_event($event, $step = '', $pre = 0)\n{\n    global $production_status, $trace;\n\n    list($pre, $renew) = (array)$pre + array(0, null);\n    $callbacks = callback_handlers($event, $step, $pre, false);\n\n    if (empty($callbacks)) {\n        return '';\n    }\n\n    $trace->start(\"[Callback_event: '$event', step='$step', pre='$pre']\");\n\n    // Any payload parameters?\n    $argv = func_get_args();\n    $argv = (count($argv) > 3) ? array_slice($argv, 3) : array();\n\n    foreach ($callbacks as $c) {\n        if (is_callable($c)) {\n            if ($production_status !== 'live') {\n                $trace->start(\"\\t[Call function: '\".Txp::get('\\Textpattern\\Type\\TypeCallable', $c)->toString().\"'\".\n                    (empty($argv) ? '' : \", argv='\".serialize($argv).\"'\").\"]\");\n            }\n\n            $return_value = call_user_func_array($c, array_merge(array(\n                $event,\n                $step\n            ), $argv));\n\n            if (isset($renew)) {\n                $argv[$renew] = $return_value;\n            }\n\n            if (isset($out) && !isset($renew)) {\n                if (is_array($return_value) && is_array($out)) {\n                    $out = array_merge($out, $return_value);\n                } elseif (is_bool($return_value) && is_bool($out)) {\n                    $out = $return_value && $out;\n                } else {\n                    $out .= $return_value;\n                }\n            } else {\n                $out = $return_value;\n            }\n\n            if ($production_status !== 'live') {\n                $trace->stop();\n            }\n        } elseif ($production_status === 'debug') {\n            trigger_error(gTxt('unknown_callback_function', array('{function}' => Txp::get('\\Textpattern\\Type\\TypeCallable', $c)->toString())), E_USER_WARNING);\n        }\n    }\n\n    $trace->stop();\n\n    if (isset($out)) {\n        return $out;\n    }\n\n    return '';\n}\n\n/**\n * Call an event's callback with two optional byref parameters.\n *\n * @param   string $event   The callback event\n * @param   string $step    Optional callback step\n * @param   bool   $pre     Allows two callbacks, a prepending and an appending, with same event and step\n * @param   mixed  $data    Optional arguments for event handlers\n * @param   mixed  $options Optional arguments for event handlers\n * @return  array Collection of return values from event handlers\n * @since   4.5.0\n * @package Callback\n */\n\nfunction callback_event_ref($event, $step = '', $pre = 0, &$data = null, &$options = null)\n{\n    global $production_status;\n\n    $callbacks = callback_handlers($event, $step, $pre, false);\n\n    if (empty($callbacks)) {\n        return array();\n    }\n\n    $return_value = array();\n\n    foreach ($callbacks as $c) {\n        if (is_callable($c)) {\n            // Cannot call event handler via call_user_func() as this would\n            // dereference all arguments. Side effect: callback handler\n            // *must* be ordinary function, *must not* be class method in\n            // PHP <5.4. See https://bugs.php.net/bug.php?id=47160.\n            $return_value[] = $c($event, $step, $data, $options);\n        } elseif ($production_status == 'debug') {\n            trigger_error(gTxt('unknown_callback_function', array('{function}' => Txp::get('\\Textpattern\\Type\\TypeCallable', $c)->toString())), E_USER_WARNING);\n        }\n    }\n\n    return $return_value;\n}\n\n/**\n * Checks if a callback event has active handlers.\n *\n * @param   string $event The callback event\n * @param   string $step  The callback step\n * @param   bool   $pre   The position\n * @return  bool TRUE if the event is active, FALSE otherwise\n * @since   4.6.0\n * @package Callback\n * @example\n * if (has_handler('article_saved'))\n * {\n *     echo \"There are active handlers for 'article_saved' event.\";\n * }\n */\n\nfunction has_handler($event, $step = '', $pre = 0)\n{\n    return (bool) callback_handlers($event, $step, $pre, false);\n}\n\n/**\n * Lists handlers attached to an event.\n *\n * @param   string $event The callback event\n * @param   string $step  The callback step\n * @param   bool   $pre   The position\n * @param   bool   $as_string Return callables in string representation\n * @return  array|bool An array of handlers, or FALSE\n * @since   4.6.0\n * @package Callback\n * @example\n * if ($handlers = callback_handlers('article_saved'))\n * {\n *     print_r($handlers);\n * }\n */\n\nfunction callback_handlers($event, $step = '', $pre = 0, $as_string = true)\n{\n    global $plugin_callback;\n\n    $pre or $pre = 0;\n    $step or $step = 0;\n\n    $callbacks = isset($plugin_callback[$event][$pre][$step]) ? $plugin_callback[$event][$pre][$step] :\n        (isset($plugin_callback[$event][$pre]['']) ? $plugin_callback[$event][$pre][''] : array());\n\n    if (!$as_string) {\n        return $callbacks;\n    }\n\n    $out = array();\n\n    foreach ($callbacks as $c) {\n        $out[] = Txp::get('\\Textpattern\\Type\\TypeCallable', $c)->toString();\n    }\n\n    return $out;\n}\n\n/**\n * Merge the second array into the first array.\n *\n * @param   array $pairs The first array\n * @param   array $atts  The second array\n * @param   bool  $warn  If TRUE triggers errors if second array contains values that are not in the first\n * @return  array The two arrays merged\n * @package TagParser\n */\n\nfunction lAtts($pairs, $atts, $warn = true)\n{\n    global $pretext, $production_status, $txp_atts;\n    static $globals = null, $global_atts, $partial;\n\n    if ($globals === null) {\n        $global_atts = Txp::get('\\Textpattern\\Tag\\Registry')->getRegistered(true);\n        $globals = array_filter($global_atts);\n    }\n\n    if (isset($atts['yield']) && !isset($pairs['yield'])) {\n        isset($partial) or $partial = Txp::get('\\Textpattern\\Tag\\Registry')->getTag('yield');\n\n        foreach (parse_qs($atts['yield']) as $name => $alias) {\n            $value = call_user_func($partial, array('name' => $alias === false ? $name : $alias));\n\n            if (isset($value)) {\n                $atts[$name] = $value;\n            }\n        }\n\n        unset($atts['yield']);\n    }\n\n    if (empty($pretext['_txp_atts'])) {\n        foreach ($atts as $name => $value) {\n            if (array_key_exists($name, $pairs)) {\n                if ($pairs[$name] !== null) {\n                    unset($txp_atts[$name]);\n                }\n\n                $pairs[$name] = $value;\n            } elseif ($warn && $production_status !== 'live' && !array_key_exists($name, $global_atts)) {\n                trigger_error(gTxt('unknown_attribute', array('{att}' => $name)));\n            }\n        }\n    } else { // don't import unset globals\n        foreach ($atts as $name => $value) {\n            if (array_key_exists($name, $pairs) && (!isset($globals[$name]) || isset($txp_atts[$name]))) {\n                $pairs[$name] = $value;\n                unset($txp_atts[$name]);\n            }\n        }\n    }\n\n    return $pairs ? $pairs : false;\n}\n\n/**\n * Sanitises a string for use in an article's URL title.\n *\n * @param   string $text  The title or an URL\n * @param   bool   $force Force sanitisation\n * @return  string|null\n * @package URL\n */\n\nfunction stripSpace($text, $force = false)\n{\n    if ($force || get_pref('attach_titles_to_permalinks')) {\n        $text = trim(sanitizeForUrl($text, '/[^\\p{L}\\p{N}\\-_\\s\\/\\\\\\\\\\x{1F300}-\\x{1F64F}\\x{1F680}-\\x{1F6FF}\\x{2600}-\\x{27BF}]/u'), '-');\n\n        if (get_pref('permlink_format')) {\n            return (function_exists('mb_strtolower') ? mb_strtolower($text, 'UTF-8') : strtolower($text));\n        } else {\n            return str_replace('-', '', $text);\n        }\n    }\n}\n\n/**\n * Sanitises a string for use in a URL.\n *\n * Be aware that you still have to urlencode the string when appropriate.\n * This function just makes the string look prettier and excludes some\n * unwanted characters, but leaves UTF-8 letters and digits intact.\n *\n * @param  string $text  The string\n * @param  string $strip The regex of the characters to strip\n * @return string\n * @package URL\n */\n\nfunction sanitizeForUrl($text, $strip = '/[^\\p{L}\\p{N}\\-_\\s\\/\\\\\\\\]/u')\n{\n    $out = callback_event('sanitize_for_url', '', 0, $text);\n\n    if ($out !== '') {\n        return $out;\n    }\n\n    // Remove named entities and tags.\n    $text = preg_replace(\"/(^|&\\S+;)|(<[^>]*>)/U\", \"\", dumbDown($text));\n    // Remove all characters except letter, number, dash, space and backslash\n    $text = preg_replace($strip, '', $text);\n    // Collapse spaces, minuses, (back-)slashes.\n    $text = trim(preg_replace('/[\\s\\-\\/\\\\\\\\]+/', '-', $text), '-');\n\n    return $text;\n}\n\n/**\n * Sanitises a string for use in a filename.\n *\n * @param   string $text The string\n * @return  string\n * @package File\n */\n\nfunction sanitizeForFile($text)\n{\n    $out = callback_event('sanitize_for_file', '', 0, $text);\n\n    if ($out !== '') {\n        return $out;\n    }\n\n    // Remove control characters and \" * \\ : < > ? / |\n    $text = preg_replace('/[\\x00-\\x1f\\x22\\x2a\\x2f\\x3a\\x3c\\x3e\\x3f\\x5c\\x7c\\x7f]+/', '', $text);\n    // Remove duplicate dots and any leading or trailing dots/spaces.\n    $text = preg_replace('/[.]{2,}/', '.', trim($text, '. '));\n\n    return $text;\n}\n\n/**\n * Sanitises a string for use in a page template's name.\n *\n * @param   string $text The string\n * @return  string\n * @package Filter\n * @access  private\n */\n\nfunction sanitizeForPage($text)\n{\n    $out = callback_event('sanitize_for_page', '', 0, $text);\n\n    if ($out !== '') {\n        return $out;\n    }\n\n    return trim(preg_replace('/[<>&\"\\']/', '', $text));\n}\n\n/**\n * Sanitizes a string for use in a ORDER BY clause.\n *\n * @param   string $text The string\n * @return  string\n * @package Filter\n * @access  private\n */\n\nfunction sanitizeForSort($text)\n{\n    return trim(strtr($text, array('#' => ' ', '--' => ' ')));\n}\n\n/**\n * Transliterates a string to ASCII.\n *\n * Used to generate RFC 3986 compliant and pretty ASCII-only URLs.\n *\n * @param   string $str  The string to convert\n * @param   string $lang The language which translation table is used\n * @see     sanitizeForUrl()\n * @package L10n\n */\n\nfunction dumbDown($str, $lang = null)\n{\n    static $array;\n\n    if ($lang === null) {\n        $lang = get_pref('language_ui', LANG);\n    }\n\n    if (empty($array[$lang])) {\n        $array[$lang] = array( // Nasty, huh?\n            '&#192;' => 'A', '&Agrave;' => 'A', '&#193;' => 'A', '&Aacute;' => 'A', '&#194;' => 'A', '&Acirc;' => 'A',\n            '&#195;' => 'A', '&Atilde;' => 'A', '&#196;' => 'Ae', '&Auml;' => 'A', '&#197;' => 'A', '&Aring;' => 'A',\n            '&#198;' => 'Ae', '&AElig;' => 'AE',\n            '&#256;' => 'A', '&#260;' => 'A', '&#258;' => 'A',\n            '&#199;' => 'C', '&Ccedil;' => 'C', '&#262;' => 'C', '&#268;' => 'C', '&#264;' => 'C', '&#266;' => 'C',\n            '&#270;' => 'D', '&#272;' => 'D', '&#208;' => 'D', '&ETH;' => 'D',\n            '&#200;' => 'E', '&Egrave;' => 'E', '&#201;' => 'E', '&Eacute;' => 'E', '&#202;' => 'E', '&Ecirc;' => 'E', '&#203;' => 'E', '&Euml;' => 'E',\n            '&#274;' => 'E', '&#280;' => 'E', '&#282;' => 'E', '&#276;' => 'E', '&#278;' => 'E',\n            '&#284;' => 'G', '&#286;' => 'G', '&#288;' => 'G', '&#290;' => 'G',\n            '&#292;' => 'H', '&#294;' => 'H',\n            '&#204;' => 'I', '&Igrave;' => 'I', '&#205;' => 'I', '&Iacute;' => 'I', '&#206;' => 'I', '&Icirc;' => 'I', '&#207;' => 'I', '&Iuml;' => 'I',\n            '&#298;' => 'I', '&#296;' => 'I', '&#300;' => 'I', '&#302;' => 'I', '&#304;' => 'I',\n            '&#306;' => 'IJ',\n            '&#308;' => 'J',\n            '&#310;' => 'K',\n            '&#321;' => 'K', '&#317;' => 'K', '&#313;' => 'K', '&#315;' => 'K', '&#319;' => 'K',\n            '&#209;' => 'N', '&Ntilde;' => 'N', '&#323;' => 'N', '&#327;' => 'N', '&#325;' => 'N', '&#330;' => 'N',\n            '&#210;' => 'O', '&Ograve;' => 'O', '&#211;' => 'O', '&Oacute;' => 'O', '&#212;' => 'O', '&Ocirc;' => 'O', '&#213;' => 'O', '&Otilde;' => 'O',\n            '&#214;' => 'Oe', '&Ouml;' => 'Oe',\n            '&#216;' => 'O', '&Oslash;' => 'O', '&#332;' => 'O', '&#336;' => 'O', '&#334;' => 'O',\n            '&#338;' => 'OE',\n            '&#340;' => 'R', '&#344;' => 'R', '&#342;' => 'R',\n            '&#346;' => 'S', '&#352;' => 'S', '&#350;' => 'S', '&#348;' => 'S', '&#536;' => 'S',\n            '&#356;' => 'T', '&#354;' => 'T', '&#358;' => 'T', '&#538;' => 'T',\n            '&#217;' => 'U', '&Ugrave;' => 'U', '&#218;' => 'U', '&Uacute;' => 'U', '&#219;' => 'U', '&Ucirc;' => 'U',\n            '&#220;' => 'Ue', '&#362;' => 'U', '&Uuml;' => 'Ue',\n            '&#366;' => 'U', '&#368;' => 'U', '&#364;' => 'U', '&#360;' => 'U', '&#370;' => 'U',\n            '&#372;' => 'W',\n            '&#221;' => 'Y', '&Yacute;' => 'Y', '&#374;' => 'Y', '&#376;' => 'Y',\n            '&#377;' => 'Z', '&#381;' => 'Z', '&#379;' => 'Z',\n            '&#222;' => 'T', '&THORN;' => 'T',\n            '&#224;' => 'a', '&#225;' => 'a', '&#226;' => 'a', '&#227;' => 'a', '&#228;' => 'ae',\n            '&auml;' => 'ae',\n            '&#229;' => 'a', '&#257;' => 'a', '&#261;' => 'a', '&#259;' => 'a', '&aring;' => 'a',\n            '&#230;' => 'ae',\n            '&#231;' => 'c', '&#263;' => 'c', '&#269;' => 'c', '&#265;' => 'c', '&#267;' => 'c',\n            '&#271;' => 'd', '&#273;' => 'd', '&#240;' => 'd',\n            '&#232;' => 'e', '&#233;' => 'e', '&#234;' => 'e', '&#235;' => 'e', '&#275;' => 'e',\n            '&#281;' => 'e', '&#283;' => 'e', '&#277;' => 'e', '&#279;' => 'e',\n            '&#402;' => 'f',\n            '&#285;' => 'g', '&#287;' => 'g', '&#289;' => 'g', '&#291;' => 'g',\n            '&#293;' => 'h', '&#295;' => 'h',\n            '&#236;' => 'i', '&#237;' => 'i', '&#238;' => 'i', '&#239;' => 'i', '&#299;' => 'i',\n            '&#297;' => 'i', '&#301;' => 'i', '&#303;' => 'i', '&#305;' => 'i',\n            '&#307;' => 'ij',\n            '&#309;' => 'j',\n            '&#311;' => 'k', '&#312;' => 'k',\n            '&#322;' => 'l', '&#318;' => 'l', '&#314;' => 'l', '&#316;' => 'l', '&#320;' => 'l',\n            '&#241;' => 'n', '&#324;' => 'n', '&#328;' => 'n', '&#326;' => 'n', '&#329;' => 'n',\n            '&#331;' => 'n',\n            '&#242;' => 'o', '&#243;' => 'o', '&#244;' => 'o', '&#245;' => 'o', '&#246;' => 'oe',\n            '&ouml;' => 'oe',\n            '&#248;' => 'o', '&#333;' => 'o', '&#337;' => 'o', '&#335;' => 'o',\n            '&#339;' => 'oe',\n            '&#341;' => 'r', '&#345;' => 'r', '&#343;' => 'r',\n            '&#353;' => 's',\n            '&#249;' => 'u', '&#250;' => 'u', '&#251;' => 'u', '&#252;' => 'ue', '&#363;' => 'u',\n            '&uuml;' => 'ue',\n            '&#367;' => 'u', '&#369;' => 'u', '&#365;' => 'u', '&#361;' => 'u', '&#371;' => 'u',\n            '&#373;' => 'w',\n            '&#253;' => 'y', '&#255;' => 'y', '&#375;' => 'y',\n            '&#382;' => 'z', '&#380;' => 'z', '&#378;' => 'z',\n            '&#254;' => 't',\n            '&#223;' => 'ss',\n            '&#383;' => 'ss',\n            '&agrave;' => 'a', '&aacute;' => 'a', '&acirc;' => 'a', '&atilde;' => 'a', '&auml;' => 'ae',\n            '&aring;' => 'a', '&aelig;' => 'ae', '&ccedil;' => 'c', '&eth;' => 'd',\n            '&egrave;' => 'e', '&eacute;' => 'e', '&ecirc;' => 'e', '&euml;' => 'e',\n            '&igrave;' => 'i', '&iacute;' => 'i', '&icirc;' => 'i', '&iuml;' => 'i',\n            '&ntilde;' => 'n',\n            '&ograve;' => 'o', '&oacute;' => 'o', '&ocirc;' => 'o', '&otilde;' => 'o', '&ouml;' => 'oe',\n            '&oslash;' => 'o',\n            '&ugrave;' => 'u', '&uacute;' => 'u', '&ucirc;' => 'u', '&uuml;' => 'ue',\n            '&yacute;' => 'y', '&yuml;' => 'y',\n            '&thorn;' => 't',\n            '&szlig;' => 'ss',\n        );\n\n        if (is_file(txpath.'/lib/i18n-ascii.txt')) {\n            $i18n = parse_ini_file(txpath.'/lib/i18n-ascii.txt', true);\n\n            // Load the global map.\n            if (isset($i18n['default']) && is_array($i18n['default'])) {\n                $array[$lang] = array_merge($array[$lang], $i18n['default']);\n\n                // Base language overrides: 'de-AT' applies the 'de' section.\n                if (preg_match('/([a-zA-Z]+)-.+/', $lang, $m)) {\n                    if (isset($i18n[$m[1]]) && is_array($i18n[$m[1]])) {\n                        $array[$lang] = array_merge($array[$lang], $i18n[$m[1]]);\n                    }\n                }\n\n                // Regional language overrides: 'de-AT' applies the 'de-AT' section.\n                if (isset($i18n[$lang]) && is_array($i18n[$lang])) {\n                    $array[$lang] = array_merge($array[$lang], $i18n[$lang]);\n                }\n            }\n            // Load an old file (no sections) just in case.\n            else {\n                $array[$lang] = array_merge($array[$lang], $i18n);\n            }\n        }\n    }\n\n    return strtr($str, $array[$lang]);\n}\n\n/**\n * Cleans a URL.\n *\n * @param   string $url The URL\n * @return  string\n * @access  private\n * @package URL\n */\n\nfunction clean_url($url)\n{\n    return preg_replace(\"/\\\"|'|(?:\\s.*$)/\", '', $url);\n}\n\n/**\n * Replace the last space with a &#160; non-breaking space.\n *\n * @param   string $str The string\n * @return  string\n */\n\nfunction noWidow($str)\n{\n    if (REGEXP_UTF8 == 1) {\n        return preg_replace('@[ ]+([[:punct:]]?[\\p{L}\\p{N}\\p{Pc}]+[[:punct:]]?)$@u', '&#160;$1', rtrim($str));\n    }\n\n    return preg_replace('@[ ]+([[:punct:]]?\\w+[[:punct:]]?)$@', '&#160;$1', rtrim($str));\n}\n\n/**\n * Checks if an IP is on a spam blocklist.\n *\n * @param   string       $ip     The IP address\n * @param   string|array $checks The checked lists. Defaults to 'spam_blacklists' preferences string\n * @return  string|bool The lists the IP is on or FALSE\n * @package Comment\n * @example\n * if (is_blacklisted('192.0.2.1'))\n * {\n *     echo \"'192.0.2.1' is on the blocklist.\";\n * }\n */\n\nfunction is_blacklisted($ip, $checks = '')\n{\n    if (!$checks) {\n        $checks = do_list_unique(get_pref('spam_blacklists'));\n    }\n\n    $rip = join('.', array_reverse(explode('.', $ip)));\n\n    foreach ((array) $checks as $a) {\n        $parts = explode(':', $a, 2);\n        $rbl   = $parts[0];\n\n        if (isset($parts[1])) {\n            foreach (explode(':', $parts[1]) as $code) {\n                $codes[] = strpos($code, '.') ? $code : '127.0.0.'.$code;\n            }\n        }\n\n        $hosts = $rbl ? @gethostbynamel($rip.'.'.trim($rbl, '. ').'.') : false;\n\n        if ($hosts and (!isset($codes) or array_intersect($hosts, $codes))) {\n            $listed[] = $rbl;\n        }\n    }\n\n    return (!empty($listed)) ? join(', ', $listed) : false;\n}\n\n/**\n * Checks if the user is authenticated on the public-side.\n *\n * @param   string $user The checked username. If not provided, any user is accepted\n * @return  array|bool An array containing details about the user; name, RealName, email, privs. FALSE when the user hasn't authenticated.\n * @package User\n * @example\n * if ($user = is_logged_in())\n * {\n *     echo \"Logged in as {$user['RealName']}\";\n * }\n */\n\nfunction is_logged_in($user = '')\n{\n    static $users = array();\n\n    $name = substr(cs('txp_login_public'), 10);\n\n    if (!strlen($name) || strlen($user) && $user !== $name) {\n        return false;\n    }\n\n    if (!isset($users[$name])) {\n        $users[$name] = safe_row(\"nonce, name, RealName, email, privs\", 'txp_users', \"name = '\".doSlash($name).\"'\");\n    }\n\n    $rs = $users[$name];\n\n    if ($rs && substr(md5($rs['nonce']), -10) === substr(cs('txp_login_public'), 0, 10)) {\n        unset($rs['nonce']);\n\n        return $rs;\n    } else {\n        return false;\n    }\n}\n\n/**\n * Updates the path to the site.\n *\n * @param   string $here The path\n * @access  private\n * @package Pref\n */\n\nfunction updateSitePath($here)\n{\n    set_pref('path_to_site', $here, 'publish', PREF_HIDDEN);\n}\n\n/**\n * Converts Textpattern tag's attribute list to an array.\n *\n * @param   array|string $text The attribute list, e.g. foobar=\"1\" barfoo=\"0\"\n * @return  array Array of attributes\n * @access  private\n * @package TagParser\n */\n\nfunction splat($text)\n{\n    static $stack = array(), $parse = array(), $global_atts = array(), $globals = null;\n    global $production_status, $trace, $txp_atts;\n\n    if ($globals === null) {\n        $globals = array_filter(Txp::get('\\Textpattern\\Tag\\Registry')->getRegistered(true));\n    }\n\n    if (is_array($text)) {\n        $txp_atts = array_intersect_key($text, $globals);\n        return $text;\n    }\n\n    $sha = txp_hash($text);\n\n    if (!isset($stack[$sha])) {\n        $stack[$sha] = $parse[$sha] = array();\n\n        if (preg_match_all('@([\\w\\-]+)(?:\\s*=\\s*(?:\"((?:[^\"]|\"\")*)\"|\\'((?:[^\\']|\\'\\')*)\\'|([^\\s\\'\"/>]+)))?@s', $text, $match, PREG_SET_ORDER)) {\n            foreach ($match as $m) {\n                $name = strtolower($m[1]);\n\n                switch (count($m)) {\n                    case 2:\n                        $val = true;\n                        break;\n                    case 3:\n                        $val = str_replace('\"\"', '\"', $m[2]);\n                        break;\n                    case 4:\n                        $val = str_replace(\"''\", \"'\", $m[3]);\n\n                        if (strpos($m[3], ':') !== false) {\n                            $parse[$sha][] = $name;\n                        }\n\n                        break;\n                    case 5:\n                        $val = $m[4];\n                        trigger_error(gTxt('attribute_values_must_be_quoted'), E_USER_WARNING);\n                        break;\n                }\n\n                $stack[$sha][$name] = $val;\n            }\n        }\n\n        $global_atts[$sha] = array_intersect_key($stack[$sha], $globals) or $global_atts[$sha] = null;\n    }\n\n    $txp_atts = $global_atts[$sha];\n\n    if (empty($parse[$sha])) {\n        return $stack[$sha];\n    }\n\n    $atts = $stack[$sha];\n\n    if ($production_status !== 'live') {\n        foreach ($parse[$sha] as $p) {\n            $trace->start(\"[attribute '\".$p.\"']\");\n            $atts[$p] = parse($atts[$p], true, false);\n            isset($txp_atts[$p]) and $txp_atts[$p] = $atts[$p];\n            $trace->stop('[/attribute]');\n        }\n    } else {\n        foreach ($parse[$sha] as $p) {\n            $atts[$p] = parse($atts[$p], true, false);\n            isset($txp_atts[$p]) and $txp_atts[$p] = $atts[$p];\n        }\n    }\n\n    return $atts;\n}\n\n/**\n * Replaces CR and LF with spaces, and drops NULL bytes.\n *\n * Used for sanitising email headers.\n *\n * @param      string $str The string\n * @return     string\n * @package    Mail\n * @deprecated in 4.6.0\n * @see        \\Textpattern\\Mail\\Encode::escapeHeader()\n */\n\nfunction strip_rn($str)\n{\n    return Txp::get('\\Textpattern\\Mail\\Encode')->escapeHeader($str);\n}\n\n/**\n * Validates a string as an email address.\n *\n * <code>\n * if (is_valid_email('john.doe@example.com'))\n * {\n *     echo \"'john.doe@example.com' validates.\";\n * }\n * </code>\n *\n * @param      string $address The email address\n * @return     bool\n * @package    Mail\n * @deprecated in 4.6.0\n * @see        filter_var()\n */\n\nfunction is_valid_email($address)\n{\n    return (bool) filter_var($address, FILTER_VALIDATE_EMAIL);\n}\n\n/**\n * Sends an email message as the currently logged in user.\n *\n * <code>\n * if (txpMail('john.doe@example.com', 'Subject', 'Some message'))\n * {\n *     echo \"Email sent to 'john.doe@example.com'.\";\n * }\n * </code>\n *\n * @param   string $to_address The receiver\n * @param   string $subject    The subject\n * @param   string $body       The message\n * @param   string $reply_to The reply to address\n * @return  bool   Returns FALSE when sending failed\n * @see     \\Textpattern\\Mail\\Compose\n * @package Mail\n */\n\nfunction txpMail($to_address, $subject, $body, $reply_to = null)\n{\n    global $txp_user;\n\n    // Send the email as the currently logged in user.\n    if ($txp_user) {\n        $sender = safe_row(\n            \"RealName, email\",\n            'txp_users',\n            \"name = '\".doSlash($txp_user).\"'\"\n        );\n\n        if ($sender && is_valid_email(get_pref('publisher_email'))) {\n            $sender['email'] = get_pref('publisher_email');\n        }\n    }\n    // If not logged in, the receiver is the sender.\n    else {\n        $sender = safe_row(\n            \"RealName, email\",\n            'txp_users',\n            \"email = '\".doSlash($to_address).\"'\"\n        );\n    }\n\n    if ($sender) {\n        extract($sender);\n\n        try {\n            $message = Txp::get('\\Textpattern\\Mail\\Compose')\n                ->from($email, $RealName)\n                ->to($to_address)\n                ->subject($subject)\n                ->body($body);\n\n            if ($reply_to) {\n                $message->replyTo($reply_to);\n            }\n\n            $message->send();\n        } catch (\\Textpattern\\Mail\\Exception $e) {\n            return false;\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Encodes a string for use in an email header.\n *\n * @param      string $string The string\n * @param      string $type   The type of header, either \"text\" or \"phrase\"\n * @return     string\n * @package    Mail\n * @deprecated in 4.6.0\n * @see        \\Textpattern\\Mail\\Encode::header()\n */\n\nfunction encode_mailheader($string, $type)\n{\n    try {\n        return Txp::get('\\Textpattern\\Mail\\Encode')->header($string, $type);\n    } catch (\\Textpattern\\Mail\\Exception $e) {\n        trigger_error($e->getMessage(), E_USER_WARNING);\n    }\n}\n\n/**\n * Converts an email address into unicode entities.\n *\n * @param      string $txt The email address\n * @return     string Encoded email address\n * @package    Mail\n * @deprecated in 4.6.0\n * @see        \\Textpattern\\Mail\\Encode::entityObfuscateAddress()\n */\n\nfunction eE($txt)\n{\n    return Txp::get('\\Textpattern\\Mail\\Encode')->entityObfuscateAddress($txt);\n}\n\n/**\n * Strips PHP tags from a string.\n *\n * @param  string $in The input\n * @return string\n */\n\nfunction stripPHP($in)\n{\n    return preg_replace(\"/\".chr(60).\"\\?(?:php)?|\\?\".chr(62).\"/i\", '', $in);\n}\n\n/**\n * Creates a form template.\n *\n * On a successful run, will trigger a 'form.create > done' callback event.\n *\n * @param      string $name The name\n * @param      string $type The type\n * @param      string $Form The template\n * @return     bool FALSE on error\n * @since      4.6.0\n * @deprecated 4.8.6 (not skin-aware)\n * @see        Textpattern\\Skin\\Skin\n * @package    Template\n */\n\nfunction create_form($name, $type, $Form)\n{\n    $types = get_form_types();\n\n    if (form_exists($name) || !is_valid_form($name) || !in_array($type, array_keys($types))) {\n        return false;\n    }\n\n    if (\n        safe_insert(\n            'txp_form',\n            \"name = '\".doSlash($name).\"',\n            type = '\".doSlash($type).\"',\n            Form = '\".doSlash($Form).\"'\"\n        ) === false\n    ) {\n        return false;\n    }\n\n    callback_event('form.create', 'done', 0, compact('name', 'type', 'Form'));\n\n    return true;\n}\n\n/**\n * Checks if a form template exists.\n *\n * @param      string $name The form\n * @return     bool TRUE if the form exists\n * @since      4.6.0\n * @deprecated 4.8.6 (not skin-aware)\n * @see        Textpattern\\Skin\\CommonBase\n * @package    Template\n */\n\nfunction form_exists($name)\n{\n    return (bool) safe_row(\"name\", 'txp_form', \"name = '\".doSlash($name).\"'\");\n}\n\n/**\n * Validates a string as a form template name.\n *\n * @param      string $name The form name\n * @return     bool TRUE if the string validates\n * @since      4.6.0\n * @deprecated 4.8.6\n * @see        Textpattern\\Skin\\CommonBase\n * @package    Template\n */\n\nfunction is_valid_form($name)\n{\n    if (function_exists('mb_strlen')) {\n        $length = mb_strlen($name, '8bit');\n    } else {\n        $length = strlen($name);\n    }\n\n    return $name && !preg_match('/^\\s|[<>&\"\\']|\\s$/u', $name) && $length <= 64;\n}\n\n/**\n * Validates a string as a date% query.\n *\n * @param   string $date The partial date\n * @return  bool|string FALSE if the string does not validate\n * @since   4.8.5\n * @package Template\n */\n\nfunction is_date($month)\n{\n    if (!preg_match('/^\\d{1,4}(?:\\-\\d{1,2}){0,2}$/', $month)) {\n        return false;\n    }\n\n    $month = explode('-', $month, 3);\n    $result = true;\n\n    switch (count($month)) {\n        case 3:\n            $result = checkdate($month[1], $month[2], $month[0]) and\n            $month[2] = str_pad($month[2], 2, '0', STR_PAD_LEFT);\n        case 2:\n            $result = $result && $month[1] > 0 && $month[1] < 13;\n            !$result or $month[1] = str_pad($month[1], 2, '0', STR_PAD_LEFT);\n        case 1:\n            $result = $result && $month[0] > 0;\n            !$result or $month[0] = str_pad($month[0], 4, '0', STR_PAD_LEFT);\n    }\n\n    return $result ? implode('-', $month) : false;\n}\n\n/**\n * Gets a \"since days ago\" date format from a given UNIX timestamp.\n *\n * @param   int $stamp UNIX timestamp\n * @return  string \"n days ago\"\n * @package DateTime\n */\n\nfunction since($stamp)\n{\n    $diff = (time() - $stamp);\n\n    if ($diff <= 3600) {\n        $qty = round($diff / 60);\n\n        if ($qty < 1) {\n            $qty = '';\n            $period = gTxt('a_few_seconds');\n        } elseif ($qty == 1) {\n            $period = gTxt('minute');\n        } else {\n            $period = gTxt('minutes');\n        }\n    } elseif (($diff <= 86400) && ($diff > 3600)) {\n        $qty = round($diff / 3600);\n\n        if ($qty <= 1) {\n            $qty = 1;\n            $period = gTxt('hour');\n        } else {\n            $period = gTxt('hours');\n        }\n    } elseif ($diff >= 86400) {\n        $qty = round($diff / 86400);\n\n        if ($qty <= 1) {\n            $qty = 1;\n            $period = gTxt('day');\n        } else {\n            $period = gTxt('days');\n        }\n    }\n\n    return gTxt('ago', array('{qty}' => $qty, '{period}' => $period));\n}\n\n/**\n * Calculates a timezone offset.\n *\n * Calculates the offset between the server local time and the\n * user's selected timezone at a given point in time.\n *\n * @param   int $timestamp The timestamp. Defaults to time()\n * @return  int The offset in seconds\n * @package DateTime\n */\n\nfunction tz_offset($timestamp = null)\n{\n    global $gmtoffset, $timezone_key;\n    static $dtz = array(), $timezone_server = null;\n\n    if ($timezone_server === null) {\n        $timezone_server = date_default_timezone_get();\n    }\n\n    if ($timezone_server === $timezone_key) {\n        return 0;\n    }\n\n    if ($timestamp === null) {\n        $timestamp = time();\n    }\n\n    try {\n        if (!isset($dtz[$timezone_server])) {\n            $dtz[$timezone_server] = new \\DateTimeZone($timezone_server);\n        }\n\n        $transition = $dtz[$timezone_server]->getTransitions($timestamp, $timestamp);\n        $serveroffset = $transition[0]['offset'];\n    } catch (\\Exception $e) {\n        extract(getdate($timestamp));\n        $serveroffset = gmmktime($hours, $minutes, 0, $mon, $mday, $year) - mktime($hours, $minutes, 0, $mon, $mday, $year);\n    }\n\n    try {\n        if (!isset($dtz[$timezone_key])) {\n            $dtz[$timezone_key] = new \\DateTimeZone($timezone_key);\n        }\n\n        $transition = $dtz[$timezone_key]->getTransitions($timestamp, $timestamp);\n        $siteoffset = $transition[0]['offset'];\n    } catch (\\Exception $e) {\n        $siteoffset = $gmtoffset;\n    }\n\n    return $siteoffset - $serveroffset;\n}\n\n/**\n * Formats a time.\n *\n * Respects the locale and local timezone, and makes sure the\n * output string is encoded in UTF-8.\n *\n * @param   string $format          The date format\n * @param   int    $time            UNIX timestamp. Defaults to time()\n * @param   bool   $gmt             Return GMT time\n * @param   string $override_locale Override the locale\n * @return  string Formatted date\n * @package DateTime\n * @example\n * echo intl_strftime('w3cdtf');\n */\n\nfunction intl_strftime($format, $time = null, $gmt = false, $override_locale = '')\n{\n    global $lang_ui;\n    static $DateTime = null, $IntlDateFormatter = array(), $default = array(), $formats = array(\n        '%a' => 'eee',\n        '%A' => 'eeee',\n        '%d' => 'dd',\n        '%e' => 'd',\n        '%Oe' => 'd',\n        '%j' => 'D',\n        '%u' => 'c',\n        '%w' => 'e',\n        '%U' => 'w',\n        '%V' => 'ww',\n        '%W' => 'ww',\n        '%b' => 'MMM',\n        '%B' => 'MMMM',\n        '%h' => 'MMM',\n        '%m' => 'MM',\n        '%g' => 'yy',\n        '%G' => 'Y',\n        '%Y' => 'y',\n        '%y' => 'yy',\n        '%H' => 'HH',\n        '%k' => 'H',\n        '%I' => 'hh',\n        '%l' => 'h',\n        '%M' => 'mm',\n        '%S' => 'ss',\n        '%p' => 'a',\n        '%P' => 'a',\n        '%r' => 'h:mm:ss a',\n        '%R' => 'HH:mm',\n        '%T' => 'HH:mm:ss',\n        '%z' => 'Z',\n        '%Z' => 'z',\n        '%D' => 'MM/dd/yy',\n        '%F' => 'yy-MM-dd',\n        '%n' => n,\n        '%t' => t,\n        '%%' => '%',\n    );\n\n    if ($DateTime === null) {\n        $DateTime = new DateTime();\n    }\n\n    $override_locale or $override_locale = txpinterface == 'admin' ? $lang_ui : LANG;\n\n    if (!isset($IntlDateFormatter[$override_locale])) {\n        $IntlDateFormatter[$override_locale] = new IntlDateFormatter(\n            $override_locale,\n            IntlDateFormatter::LONG,\n            IntlDateFormatter::SHORT,\n            null,\n            /*strpos($override_locale, 'calendar') === false ? null :*/ IntlDateFormatter::TRADITIONAL\n        );\n        $pattern = $IntlDateFormatter[$override_locale]->getPattern();\n        $xt = datefmt_create($override_locale, IntlDateFormatter::NONE, IntlDateFormatter::SHORT,\n        null, IntlDateFormatter::TRADITIONAL)->getPattern();//trim(preg_replace('/[^aHhmps:\\s]/', '', $pattern));\n        $xd = datefmt_create($override_locale, IntlDateFormatter::LONG, IntlDateFormatter::NONE,\n        null, IntlDateFormatter::TRADITIONAL)->getPattern();//trim(str_replace($xt, '', $pattern), ' ,');\n        $default[$override_locale] = array('%c' => $pattern, '%x' => $xd, '%X' => $xt);\n    }\n\n    $DateTime->setTimestamp($time);\n\n    $formats['%s'] = $time;\n    $format = strtr($format, $formats + $default[$override_locale]);\n    !$gmt or $IntlDateFormatter[$override_locale]->setTimeZone('GMT+0');\n    $IntlDateFormatter[$override_locale]->setPattern($format);\n    $str = $IntlDateFormatter[$override_locale]->format($DateTime);\n    !$gmt or $IntlDateFormatter[$override_locale]->setTimeZone(null);\n\n    return $str;\n}\n\n/**\n * Formats a time.\n *\n * Respects the locale and local timezone, and makes sure the\n * output string is encoded in UTF-8.\n *\n * @param   string $format          The date format\n * @param   int    $time            UNIX timestamp. Defaults to time()\n * @param   bool   $gmt             Return GMT time\n * @param   string $override_locale Override the locale\n * @return  string Formatted date\n * @package DateTime\n * @example\n * echo safe_strftime('w3cdtf');\n */\n\nfunction safe_strftime($format, $time = null, $gmt = false, $override_locale = '')\n{\n    static $charsets = array(), $txpLocale = null, $intl = null, $formats = array( //'rfc850', 'rfc1036', 'rfc1123', 'rfc2822' ?\n        'atom' => DATE_ATOM, 'w3cdtf' => DATE_ATOM, 'rss' => DATE_RSS, 'cookie' => DATE_COOKIE, 'w3c' => DATE_W3C, 'iso8601' => DATE_ISO8601, 'rfc822' => DATE_RFC822,\n    ), $translate = array(\n        '%a' => 'D',\n        '%A' => 'l',\n        '%d' => 'd',\n        '%e' => 'j',\n        '%Oe' => 'jS',\n        '%j' => 'z',\n        '%u' => 'N',\n        '%w' => 'w',\n        '%U' => 'W',\n        '%V' => 'W',\n        '%W' => 'W',\n        '%b' => 'M',\n        '%B' => 'F',\n        '%h' => 'M',\n        '%m' => 'm',\n        '%g' => 'y',\n        '%G' => 'o',\n        '%Y' => 'Y',\n        '%y' => 'y',\n        '%H' => 'H',\n        '%k' => 'G',\n        '%I' => 'h',\n        '%l' => 'g',\n        '%M' => 'i',\n        '%S' => 's',\n        '%p' => 'A',\n        '%P' => 'a',\n        '%r' => 'g:i:s A',\n        '%R' => 'H:i',\n        '%T' => 'H:i:s',\n        '%z' => 'O',\n        '%Z' => 'T',\n        '%D' => 'm/d/y',\n        '%F' => 'Y-m-d',\n        '%s' => 'U',\n        '%n' => n,\n        '%t' => t,\n        '%%' => '%',\n    );\n\n    $time = isset($time) ? (int)$time : time();\n\n    if ($intl === null) {\n        $intl = class_exists('IntlDateFormatter');\n    }\n\n    if ($format == 'since') {\n        return since($time);\n    } elseif (isset($formats[$format])) {\n        // We could add some other formats here.\n        return gmdate($formats[$format], $time);\n    } elseif (strpos($format, '%') === false) {\n        return $intl ? intl_strftime($format, $time, $gmt, $override_locale) : ($gmt ? gmdate($format, $time) : date($format, $time));\n    } elseif (!preg_match('/\\%[aAbBchOxX]/', $format) && strpos($override_locale, 'calendar') === false) {\n        return $gmt ? gmdate(strtr($format, $translate), $time) : date(strtr($format, $translate), $time);\n    } elseif ($intl) {\n        return intl_strftime($format, $time, $gmt, $override_locale);\n    }\n\n    if ($txpLocale === null) {\n        $txpLocale = Txp::get('\\Textpattern\\L10n\\Locale');\n    }\n\n    if ($override_locale) {\n        $oldLocale = $txpLocale->getLocale(LC_TIME);\n\n        if ($oldLocale != $override_locale) {\n            $txpLocale->setLocale(LC_TIME, $override_locale);\n        } else {\n            $oldLocale = null;\n        }\n    }\n\n    if ($gmt) {\n        $str = gmstrftime($format, $time);\n    } else {\n        $tztime = $time + tz_offset($time);\n        $format = str_replace('%s', $tztime, $format);\n        $str = strftime($format, $tztime);\n    }\n\n    if (!isset($charsets[$override_locale])) {\n        $charsets[$override_locale] = strtoupper($txpLocale->getCharset(LC_TIME, IS_WIN ? 'Windows-1252' : 'ISO-8859-1'));\n    }\n\n    $charset = $charsets[$override_locale];\n\n    if ($charset != 'UTF-8' && $charset != 'UTF8') {\n        if (is_callable('iconv') && $new = iconv($charset, 'UTF-8', $str)) {\n            $str = $new;\n        } elseif (is_callable('utf8_encode')) {\n            $str = utf8_encode($str);\n        }\n    }\n\n    // Revert to the old locale.\n    if (isset($oldLocale)) {\n        $txpLocale->setLocale(LC_TIME, $oldLocale);\n    }\n\n    return $str;\n}\n\n/**\n * Converts a time string from the Textpattern timezone to GMT.\n *\n * @param   string $time_str The time string\n * @return  int UNIX timestamp\n * @package DateTime\n */\n\nfunction safe_strtotime($time_str)\n{\n    $ts = strtotime($time_str);\n\n    // tz_offset calculations are expensive\n    $tz_offset = tz_offset($ts);\n\n    return strtotime($time_str, time() + $tz_offset) - $tz_offset;\n}\n\n/**\n * Generic error handler.\n *\n * @param   int    $errno\n * @param   string $errstr\n * @param   string $errfile\n * @param   int    $errline\n * @access  private\n * @package Debug\n */\n\nfunction myErrorHandler($errno, $errstr, $errfile, $errline)\n{\n    if (!error_reporting()) {\n        return;\n    }\n\n    echo '<pre dir=\"auto\">'.n.n.\"$errno: $errstr in $errfile at line $errline\\n\";\n\n    if (is_callable('debug_backtrace')) {\n        echo \"Backtrace:\\n\";\n        $trace = debug_backtrace();\n\n        foreach ($trace as $ent) {\n            if (isset($ent['file'])) {\n                echo $ent['file'].':';\n            }\n\n            if (isset($ent['function'])) {\n                echo $ent['function'].'(';\n\n                if (isset($ent['args'])) {\n                    $args = '';\n\n                    foreach ($ent['args'] as $arg) {\n                        $args .= $arg.',';\n                    }\n\n                    echo rtrim($args, ',');\n                }\n\n                echo ') ';\n            }\n\n            if (isset($ent['line'])) {\n                echo 'at line '.$ent['line'].' ';\n            }\n\n            if (isset($ent['file'])) {\n                echo 'in '.$ent['file'];\n            }\n\n            echo \"\\n\";\n        }\n    }\n\n    echo \"</pre>\";\n}\n\n/**\n * Renders a download link.\n *\n * @param   int    $id       The file ID\n * @param   string $label    The label\n * @param   string $filename The filename\n * @return  string HTML\n * @package File\n */\n\nfunction make_download_link($id, $label = '', $filename = '')\n{\n    if ((string) $label === '') {\n        $label = gTxt('download');\n    }\n\n    $url = filedownloadurl($id, $filename);\n\n    // Do not use the array() form of passing $atts to href().\n    // Doing so breaks download links on the admin side due to\n    // double-encoding of the ampersands.\n    return href($label, $url, ' title = \"'.gTxt('download').'\"');\n}\n\n/**\n * Sets error reporting level.\n *\n * @param   string $level The level. Either \"debug\", \"live\" or \"testing\"\n * @package Debug\n */\n\nfunction set_error_level($level)\n{\n    if ($level == 'debug') {\n        error_reporting(E_ALL | E_STRICT);\n    } elseif ($level == 'live') {\n        // Don't show errors on screen.\n        $suppress = E_NOTICE | E_USER_NOTICE | E_WARNING | E_STRICT | E_DEPRECATED;\n        error_reporting(E_ALL ^ $suppress);\n        @ini_set(\"display_errors\", \"1\");\n    } else {\n        // Default is 'testing': display everything except notices.\n        error_reporting((E_ALL | E_STRICT) ^ (E_NOTICE | E_USER_NOTICE));\n    }\n}\n\n/**\n * Translates upload error code to a localised error message.\n *\n * @param   int $err_code The error code\n * @return  string The $err_code as a message\n * @package File\n */\n\nfunction upload_get_errormsg($err_code)\n{\n    $msg = '';\n\n    switch ($err_code) {\n        // Value: 0; There is no error, the file uploaded with success.\n        case UPLOAD_ERR_OK:\n            $msg = '';\n            break;\n        // Value: 1; The uploaded file exceeds the upload_max_filesize directive in php.ini.\n        case UPLOAD_ERR_INI_SIZE:\n            $msg = gTxt('upload_err_ini_size');\n            break;\n        // Value: 2; The uploaded file exceeds the MAX_FILE_SIZE directive that was specified in the HTML form.\n        case UPLOAD_ERR_FORM_SIZE:\n            $msg = gTxt('upload_err_form_size');\n            break;\n        // Value: 3; The uploaded file was only partially uploaded.\n        case UPLOAD_ERR_PARTIAL:\n            $msg = gTxt('upload_err_partial');\n            break;\n        // Value: 4; No file was uploaded.\n        case UPLOAD_ERR_NO_FILE:\n            $msg = gTxt('upload_err_no_file');\n            break;\n        // Value: 6; Missing a temporary folder. Introduced in PHP 4.3.10 and PHP 5.0.3.\n        case UPLOAD_ERR_NO_TMP_DIR:\n            $msg = gTxt('upload_err_tmp_dir');\n            break;\n        // Value: 7; Failed to write file to disk. Introduced in PHP 5.1.0.\n        case UPLOAD_ERR_CANT_WRITE:\n            $msg = gTxt('upload_err_cant_write');\n            break;\n        // Value: 8; File upload stopped by extension. Introduced in PHP 5.2.0.\n        case UPLOAD_ERR_EXTENSION:\n            $msg = gTxt('upload_err_extension');\n            break;\n    }\n\n    return $msg;\n}\n\n/**\n * Formats a file size.\n *\n * @param   int    $bytes    Size in bytes\n * @param   int    $decimals Number of decimals\n * @param   string $format   The format the size is represented\n * @return  string Formatted file size\n * @package File\n * @example\n * echo format_filesize(168642);\n */\n\nfunction format_filesize($bytes, $decimals = 2, $format = '')\n{\n    $units = array('b', 'k', 'm', 'g', 't', 'p', 'e', 'z', 'y');\n\n    if (in_array($format, $units)) {\n        $pow = array_search($format, $units);\n    } else {\n        $pow = floor(($bytes ? log($bytes) : 0) / log(1024));\n        $pow = min($pow, count($units) - 1);\n    }\n\n    $bytes /= pow(1024, $pow);\n\n    $separators = localeconv();\n    $sep_dec = isset($separators['decimal_point']) ? $separators['decimal_point'] : '.';\n    $sep_thous = isset($separators['thousands_sep']) ? $separators['thousands_sep'] : ',';\n\n    return number_format($bytes, $decimals, $sep_dec, $sep_thous).sp.gTxt('units_'.$units[$pow]);\n}\n\n/**\n * Gets a file download as an array.\n *\n * @param   string $where SQL where clause\n * @return  array|bool An array of files, or FALSE on failure\n * @package File\n * @example\n * if ($file = fileDownloadFetchInfo('id = 1'))\n * {\n *     print_r($file);\n * }\n */\n\nfunction fileDownloadFetchInfo($where)\n{\n    $rs = safe_row(\"*\", 'txp_file', $where);\n\n    if ($rs) {\n        return file_download_format_info($rs);\n    }\n\n    return false;\n}\n\n/**\n * Formats file download info.\n *\n * Takes a data array generated by fileDownloadFetchInfo()\n * and formats the contents.\n *\n * @param   array $file The file info to format\n * @return  array Formatted file info\n * @access  private\n * @package File\n */\n\nfunction file_download_format_info($file)\n{\n    if (($unix_ts = @strtotime($file['created'])) > 0) {\n        $file['created'] = $unix_ts;\n    }\n\n    if (($unix_ts = @strtotime($file['modified'])) > 0) {\n        $file['modified'] = $unix_ts;\n    }\n\n    return $file;\n}\n\n/**\n * Formats file download's modification and creation timestamps.\n *\n * Used by file_download tags.\n *\n * @param   array $params\n * @return  string\n * @access  private\n * @package File\n */\n\nfunction fileDownloadFormatTime($params)\n{\n    extract(lAtts(array(\n        'ftime'  => '',\n        'format' => '',\n    ), $params));\n\n    if (!empty($ftime)) {\n        if ($format) {\n            return safe_strftime($format, $ftime);\n        }\n\n        return safe_strftime(get_pref('archive_dateformat'), $ftime);\n    }\n\n    return '';\n}\n\n/**\n * file_get_contents wrapper.\n *\n */\n\nfunction txp_get_contents($file)\n{\n    return is_readable($file) ? file_get_contents($file) : '';\n}\n\n/**\n * Returns the contents of the found files as an array.\n *\n */\n\nfunction get_files_content($dir, $ext)\n{\n    $result = array();\n\n    if (is_readable($dir)) {\n        foreach ((array)scandir($dir) as $file) {\n            if (preg_match('/^(.+)\\.'.$ext.'$/', $file, $match)) {\n                $result[$match[1]] = file_get_contents(\"$dir/$file\");\n            }\n        }\n    }\n\n    return $result;\n}\n\n/**\n * Checks if a function is disabled.\n *\n * @param   string $function The function name\n * @return  bool TRUE if the function is disabled\n * @package System\n * @example\n * if (is_disabled('mail'))\n * {\n *     echo \"'mail' function is disabled.\";\n * }\n */\n\nfunction is_disabled($function)\n{\n    static $disabled;\n\n    if (!isset($disabled)) {\n        $disabled = do_list(ini_get('disable_functions'));\n    }\n\n    return in_array($function, $disabled);\n}\n\n/**\n * Joins two strings to form a single filesystem path.\n *\n * @param   string $base The base directory\n * @param   string $path The second path, a relative filename\n * @return  string A path to a file\n * @package File\n */\n\nfunction build_file_path($base, $path)\n{\n    $base = rtrim($base, '/\\\\');\n    $path = ltrim($path, '/\\\\');\n\n    return $base.DS.$path;\n}\n\n/**\n * Gets a user's real name.\n *\n * @param   string $name The username\n * @return  string A real name, or username if empty\n * @package User\n */\n\nfunction get_author_name($name)\n{\n    static $authors = array();\n\n    if (isset($authors[$name])) {\n        return $authors[$name];\n    }\n\n    $realname = fetch('RealName', 'txp_users', 'name', $name);\n    $authors[$name] = $realname;\n\n    return ($realname) ? $realname : $name;\n}\n\n/**\n * Gets a user's email address.\n *\n * @param   string $name The username\n * @return  string\n * @package User\n */\n\nfunction get_author_email($name)\n{\n    static $authors = array();\n\n    if (isset($authors[$name])) {\n        return $authors[$name];\n    }\n\n    $email = fetch('email', 'txp_users', 'name', $name);\n    $authors[$name] = $email;\n\n    return $email;\n}\n\n/**\n * Checks if a database table contains items just from one user.\n *\n * @param   string $table The database table\n * @param   string $col   The column\n * @return  bool\n * @package User\n * @example\n * if (has_single_author('textpattern', 'AuthorID'))\n * {\n *     echo \"'textpattern' table has only content from one author.\";\n * }\n */\n\nfunction has_single_author($table, $col = 'author')\n{\n    static $cache = array();\n\n    if (!isset($cache[$table][$col])) {\n        $cache[$table][$col] = (safe_field(\"COUNT(name)\", 'txp_users', \"1 = 1\") <= 1) &&\n            (safe_field(\"COUNT(DISTINCT(\".doSlash($col).\"))\", doSlash($table), \"1 = 1\") <= 1);\n    }\n\n    return $cache[$table][$col];\n}\n\n/**\n * Parse a string and store the result.\n *\n * @param   string        $thing        The raw string\n * @param   null|string   $hash         The string SHA1 hash\n * @param   bool|callable $transform    The function applied to txp tags\n * @package TagParser\n */\n\nfunction txp_tokenize($thing, $hash = null, $transform = null)\n{\n    global $txp_parsed, $txp_else;\n    static $short_tags = null;\n\n    isset($short_tags) or $short_tags = get_pref('enable_short_tags', false);\n\n    $f = '@(</?(?:'.TXP_PATTERN.'):\\w+(?:\\[-?\\d+\\])?(?:\\s+[\\w\\-]+(?:\\s*=\\s*(?:\"(?:[^\"]|\"\")*\"|\\'(?:[^\\']|\\'\\')*\\'|[^\\s\\'\"/>]+))?)*\\s*/?\\>)@s';\n    $t = '@^</?('.TXP_PATTERN.'):(\\w+)(?:\\[(-?\\d+)\\])?(.*)\\>$@s';\n\n    $parsed = preg_split($f, $thing, -1, PREG_SPLIT_DELIM_CAPTURE);\n    $last = count($parsed);\n\n    if (isset($transform) && (is_bool($transform) || is_callable($transform))) {\n        $transform !== true or $transform = 'txpspecialchars';\n\n        for ($i = 1; $i < $last; $i+=2) {\n            $parsed[$i] = $transform === false ? null : call_user_func($transform, $parsed[$i]);\n        }\n    }\n\n    if ($hash === false) {\n        return $parsed;\n    } elseif ($last === 1) {\n        return false;\n    } elseif (!is_string($hash)) {\n        $hash = txp_hash($thing);\n    }\n\n    $inside  = array($parsed[0]);\n    $tags    = array($inside);\n    $tag     = array();\n    $outside = array();\n    $order = array(array());\n    $else    = array(-1);\n    $count   = array(-1);\n    $level   = 0;\n\n    for ($i = 1; $i < $last || $level > 0; $i++) {\n        $chunk = $i < $last ? $parsed[$i] : '</txp:'.$tag[$level-1][2].'>';\n        preg_match($t, $chunk, $tag[$level]);\n        $count[$level] += 2;\n\n        if ($tag[$level][2] === 'else') {\n            $else[$level] = $count[$level];\n        } elseif ($tag[$level][1] === 'txp:') {\n            // Handle <txp::shortcode />.\n            $tag[$level][4] .= ' form=\"'.$tag[$level][2].'\"';\n            $tag[$level][2] = 'output_form';\n        } elseif ($short_tags && $tag[$level][1] !== 'txp') {\n            // Handle <short::tags />.\n            $tag[$level][2] = rtrim($tag[$level][1], ':').'_'.$tag[$level][2];\n        }\n\n        if ($chunk[strlen($chunk) - 2] === '/') {\n            // Self closed tag.\n            if ($chunk[1] === '/') {\n                trigger_error(gTxt('ambiguous_tag_format', array('{chunk}' => $chunk)), E_USER_WARNING);\n            }\n\n            $tags[$level][] = array($chunk, $tag[$level][2], trim(rtrim($tag[$level][4], '/')), null, null);\n            $inside[$level] .= $chunk;\n            empty($tag[$level][3]) or $order[$level][count($tags[$level])/2] = $tag[$level][3];\n        } elseif ($chunk[1] !== '/') {\n            // Opening tag.\n            $inside[$level] .= $chunk;\n            empty($tag[$level][3]) or $order[$level][(count($tags[$level])+1)/2] = $tag[$level][3];\n            $level++;\n            $outside[$level] = $chunk;\n            $inside[$level] = '';\n            $else[$level] = $count[$level] = -1;\n            $tags[$level] = array();\n            $order[$level] = array();\n        } else {\n            // Closing tag.\n            if ($level < 1) {\n                trigger_error(gTxt('missing_open_tag', array('{chunk}' => $chunk)), E_USER_WARNING);\n                $tags[$level][] = array($chunk, null, '', null, null);\n                $inside[$level] .= $chunk;\n            } else {\n                if ($i >= $last) {\n                    trigger_error(gTxt('missing_close_tag', array('{chunk}' => $outside[$level])), E_USER_WARNING);\n                } elseif ($tag[$level-1][2] != $tag[$level][2]) {\n                    trigger_error(gTxt('mismatch_open_close_tag', array(\n                        '{from}' => $outside[$level],\n                        '{to}'   => $chunk,\n                    )), E_USER_WARNING);\n                }\n\n                if ($count[$level] > 2) {\n                    $sha = txp_hash($inside[$level]);\n                    txp_fill_parsed($sha, $tags[$level], $order[$level], $count[$level], $else[$level]);\n                }\n    \n                $level--;\n                $tags[$level][] = array($outside[$level+1], $tag[$level][2], trim($tag[$level][4]), $inside[$level+1], $chunk);\n                $inside[$level] .= $inside[$level+1].$chunk;\n            }\n        }\n\n        $chunk = ++$i < $last ? $parsed[$i] : '';\n        $tags[$level][] = $chunk;\n        $inside[$level] .= $chunk;\n    }\n\n    txp_fill_parsed($hash, $tags[0], $order[0], $count[0] + 2, $else[0]);\n\n    return true;\n}\n\n/** Auxiliary **/\n\nfunction txp_fill_parsed($sha, $tags, $order, $count, $else) {\n    global $txp_parsed, $txp_else;\n\n    $txp_parsed[$sha] = $tags;\n    $txp_else[$sha] = array($else > 0 ? $else : $count, $count - 2);\n\n    if (!empty($order)) {\n        $pre = array_filter($order, function ($v) {return $v > 0;});\n        $post = array_filter($order, function ($v) {return $v < 0;});\n\n        if  ($pre) {\n            asort($pre);\n        }\n\n        if  ($post) {\n            asort($post);\n        }\n\n        $txp_else[$sha]['test'] = $post ? array_merge(array_keys($pre), array(0), array_keys($post)) : ($pre ? array_keys($pre) : null);\n    }\n}\n\n\n/**\n * Extracts a statement from a if/else condition.\n *\n * @param   string  $thing     Statement in Textpattern tag markup presentation\n * @param   bool    $condition TRUE to return if statement, FALSE to else\n * @return  string             Either if or else statement\n * @since   4.8.2\n * @see     parse\n * @package TagParser\n * @example\n * echo getIfElse('true &lt;txp:else /&gt; false', 1 === 1);\n */\n\nfunction getIfElse($thing, $condition = true)\n{\n    global $txp_parsed, $txp_else;\n\n    if (!$thing || strpos($thing, ':else') === false) {\n        return $condition ? $thing : null;\n    }\n\n    $hash = txp_hash($thing);\n\n    if (!isset($txp_parsed[$hash]) && !txp_tokenize($thing, $hash)) {\n        return $condition ? $thing : null;\n    }\n\n    $tag = $txp_parsed[$hash];\n    list($first, $last) = $txp_else[$hash];\n\n    if ($condition) {\n        $last = $first - 2;\n        $first   = 1;\n    } elseif ($first <= $last) {\n        $first  += 2;\n    } else {\n        return null;\n    }\n\n    for ($out = $tag[$first - 1]; $first <= $last; $first++) {\n        $out .= $tag[$first][0].$tag[$first][3].$tag[$first][4].$tag[++$first];\n    }\n\n    return $out;\n}\n\n/**\n * Extracts a statement from a if/else condition to parse.\n *\n * @param   string  $thing     Statement in Textpattern tag markup presentation\n * @param   bool    $condition TRUE to return if statement, FALSE to else\n * @return  string             Either if or else statement\n * @deprecated in 4.6.0\n * @see     parse\n * @package TagParser\n * @example\n * echo parse(EvalElse('true &lt;txp:else /&gt; false', 1 === 1));\n */\n\nfunction EvalElse($thing, $condition)\n{\n    global $txp_atts;\n\n    if (!empty($txp_atts['not'])) {\n        $condition = empty($condition);\n        unset($txp_atts['not']);\n    }\n\n    if (empty($condition)) {\n        $txp_atts = null;\n    }\n\n    return (string)getIfElse($thing, $condition);\n}\n\n/**\n * Gets a form template's contents.\n *\n * The form template's reading method can be modified by registering a handler\n * to a 'form.fetch' callback event. Any value returned by the callback function\n * will be used as the form template markup.\n *\n * @param   array|string $name The form\n * @return  string\n * @package TagParser\n */\n\nfunction fetch_form($name, $theme = null)\n{\n    global $skin;\n    static $forms = array();\n\n    isset($theme) or $theme = $skin;\n    isset($forms[$theme]) or $forms[$theme] = array();\n    $fetch = is_array($name);\n\n    if ($fetch || !isset($forms[$theme][$name])) {\n        $names = $fetch ? array_diff($name, array_keys($forms[$theme])) : array($name);\n\n        if (has_handler('form.fetch')) {\n            foreach ($names as $name) {\n                $forms[$theme][$name] = callback_event('form.fetch', '', false, compact('name', 'skin', 'theme'));\n            }\n        } elseif ($fetch) {\n            $forms[$theme] += array_fill_keys($names, false);\n            $nameset = implode(',', quote_list($names));\n\n            if ($nameset and $rs = safe_rows_start('name, Form', 'txp_form', \"name IN (\".$nameset.\") AND skin = '\".doSlash($theme).\"'\")) {\n                while ($row = nextRow($rs)) {\n                    $forms[$theme][$row['name']] = $row['Form'];\n                }\n            }\n        } else {\n            $forms[$theme][$name] = safe_field('Form', 'txp_form', \"name ='\".doSlash($name).\"' AND skin = '\".doSlash($theme).\"'\");\n        }\n\n        foreach ($names as $form) {\n            if ($forms[$theme][$form] === false) {\n                trigger_error(gTxt('form_not_found', array('{list}' => $theme.'.'.$form)));\n            }\n        }\n    }\n\n    if (!$fetch) {\n        return $forms[$theme][$name];\n    }\n}\n\n/**\n * Parses a form template.\n *\n * @param   string $name The form\n * @return  string The parsed contents\n * @package TagParser\n */\n\nfunction parse_form($name, $theme = null)\n{\n    global $production_status, $skin, $txp_current_form, $trace;\n    static $stack = array(), $depth = null;\n\n    if ($depth === null) {\n        $depth = get_pref('form_circular_depth', 15);\n    }\n\n    isset($theme) or $theme = $skin;\n    $name = (string) $name;\n    $f = fetch_form($name, $theme);\n\n    if ($f === false) {\n        return false;\n    }\n\n    if (!isset($stack[$name])) {\n        $stack[$name] = 1;\n    } elseif ($stack[$name] >= $depth) {\n        trigger_error(gTxt('form_circular_reference', array('{name}' => $name)));\n\n        return '';\n    } else {\n        $stack[$name]++;\n    }\n\n    $old_form = $txp_current_form;\n    $txp_current_form = $name;\n\n    if ($production_status === 'debug') {\n        $trace->log(\"[Form: '$theme.$name']\");\n        $trace->log(\"[Nesting forms: '\".join(\"' / '\", array_keys(array_filter($stack))).\"'\".($stack[$name] > 1 ? '('.$stack[$name].')' : '').\"]\");\n    }\n\n    $out = parse($f);\n\n    $txp_current_form = $old_form;\n    $stack[$name]--;\n\n    return $out;\n}\n\n/**\n * Gets a page template's contents.\n *\n * The page template's reading method can be modified by registering a handler\n * to a 'page.fetch' callback event. Any value returned by the callback function\n * will be used as the template markup.\n *\n * @param   string      $name The template\n * @param   string      $theme The public theme\n * @return  string|bool The page template, or FALSE on error\n * @package TagParser\n * @since   4.6.0\n * @example\n * echo fetch_page('default');\n */\n\nfunction fetch_page($name, $theme)\n{\n    global $pretext, $trace;\n\n    if (empty($theme)) {\n        if (empty($pretext['skin'])) {\n            $pretext = safe_row(\"skin, page, css\", \"txp_section\", \"name='default'\") + $pretext;\n        }\n\n        $theme = $pretext['skin'];\n    }\n\n    if (has_handler('page.fetch')) {\n        $page = callback_event('page.fetch', '', false, compact('name', 'theme'));\n    } else {\n        $page = safe_field('user_html', 'txp_page', \"name = '\".doSlash($name).\"' AND skin = '\".doSlash($theme).\"'\");\n    }\n\n    if ($page === false) {\n        return false;\n    }\n\n    $trace->log(\"[Page: '$theme.$name']\");\n\n    return $page;\n}\n\n/**\n * Parses a page template.\n *\n * @param   string      $name  The template to parse\n * @param   string      $theme The public theme\n * @param   string      $page  Default content to parse\n * @return  string|bool The parsed page template, or FALSE on error\n * @since   4.6.0\n * @package TagParser\n * @example\n * echo parse_page('default');\n */\n\nfunction parse_page($name, $theme, $page = '')\n{\n    global $pretext, $trace, $is_form;\n\n    if (!$page) {\n        $page = fetch_page($name, $theme);\n    }\n\n    if ($page !== false) {\n        while ($pretext['secondpass'] <= (int)get_pref('secondpass', 1) && preg_match('@<(?:'.TXP_PATTERN.'):@', $page)) {\n            $is_form = 1;\n            $page = parse($page);\n            // the function so nice, he ran it twice\n            $pretext['secondpass']++;\n            $trace->log('[ ~~~ end of pass '.$pretext['secondpass'].' ~~~ ]');\n        }\n    }\n\n    return $page;\n}\n\n/**\n * Gets a HTML select field containing all categories, or sub-categories.\n *\n * @param   string $name Return specified parent category's sub-categories\n * @param   string $cat  The selected category option\n * @param   string $id   The HTML ID\n * @return  string|bool HTML select field or FALSE on error\n * @package Form\n */\n\nfunction event_category_popup($name, $cat = '', $id = '', $atts = array())\n{\n    $rs = getTree('root', $name);\n\n    if ($rs) {\n        return treeSelectInput('category', $rs, $cat, $id, 0, $atts);\n    }\n\n    return false;\n}\n\n/**\n * Gets a category's title.\n *\n * @param  string $name The category\n * @param  string $type Category's type. Either \"article\", \"file\", \"image\" or \"link\"\n * @return string|bool The title or FALSE on error\n */\n\nfunction fetch_category_title($name, $type = 'article')\n{\n    static $cattitles = array();\n    global $thiscategory;\n\n    if (isset($cattitles[$type][$name])) {\n        return $cattitles[$type][$name];\n    }\n\n    if (!empty($thiscategory['title']) && $thiscategory['name'] == $name && $thiscategory['type'] == $type) {\n        $cattitles[$type][$name] = $thiscategory['title'];\n\n        return $thiscategory['title'];\n    }\n\n    $f = safe_field(\"title\", 'txp_category', \"name = '\".doSlash($name).\"' AND type = '\".doSlash($type).\"'\");\n    $cattitles[$type][$name] = $f;\n\n    return $f;\n}\n\n/**\n * Gets a section's title.\n *\n * @param  string $name The section\n * @return string|bool The title or FALSE on error\n */\n\nfunction fetch_section_title($name)\n{\n    static $sectitles = array();\n    global $thissection, $txp_sections;\n\n    // Try cache.\n    if (isset($sectitles[$name])) {\n        return $sectitles[$name];\n    }\n\n    if (!empty($thissection) && $thissection['name'] == $name) {\n        return $thissection['title'];\n    } elseif ($name == 'default' or empty($name)) {\n        return '';\n    } elseif (isset($txp_sections[$name])) {\n        return $sectitles[$name] = $txp_sections[$name]['title'];\n    }\n\n    $f = safe_field(\"title\", 'txp_section', \"name = '\".doSlash($name).\"'\");\n\n    return $sectitles[$name] = $f;\n}\n\n/**\n * Updates an article's comment count.\n *\n * @param   int $id The article\n * @return  bool\n * @package Comment\n */\n\nfunction update_comments_count($id)\n{\n    $id = assert_int($id);\n    $thecount = safe_field(\"COUNT(*)\", 'txp_discuss', \"parentid = '\".$id.\"' AND visible = \".VISIBLE);\n    $thecount = assert_int($thecount);\n    $updated = safe_update('textpattern', \"comments_count = \".$thecount, \"ID = '\".$id.\"'\");\n\n    return ($updated) ? true : false;\n}\n\n/**\n * Recalculates and updates comment counts.\n *\n * @param   array $parentids List of articles to update\n * @package Comment\n */\n\nfunction clean_comment_counts($parentids)\n{\n    $parentids = array_map('assert_int', $parentids);\n    $parentids = array_filter($parentids);\n\n    if ($parentids) {\n        $rs = safe_rows_start(\"parentid, COUNT(*) AS thecount\", 'txp_discuss', \"parentid IN (\".implode(',', $parentids).\") AND visible = \".VISIBLE.\" GROUP BY parentid\");\n\n        if (!$rs) {\n            return;\n        }\n\n        $updated = array();\n\n        while ($a = nextRow($rs)) {\n            safe_update('textpattern', \"comments_count = \".$a['thecount'], \"ID = \".$a['parentid']);\n            $updated[] = $a['parentid'];\n        }\n\n        // We still need to update all those, that have zero comments left.\n        $leftover = array_diff($parentids, $updated);\n\n        if ($leftover) {\n            safe_update('textpattern', \"comments_count = 0\", \"ID IN (\".implode(',', $leftover).\")\");\n        }\n    }\n}\n\n/**\n * Parses and formats comment message using Textile.\n *\n * @param   string $msg The comment message\n * @return  string HTML markup\n * @package Comment\n */\n\nfunction markup_comment($msg)\n{\n    $textile = new \\Textpattern\\Textile\\RestrictedParser();\n\n    return $textile->parse($msg);\n}\n\n/**\n * Updates site's last modification date.\n *\n * When this action is performed, it will trigger a\n * 'site.update > {event}' callback event and pass\n * any record set that triggered the update, along\n * with the exact time the update was triggered.\n *\n * @param   $trigger Textpattern event or step that triggered the update\n * @param   $rs      Record set data at the time of update\n * @package Pref\n * @example\n * update_lastmod();\n */\n\nfunction update_lastmod($trigger = '', $rs = array())\n{\n    $whenStamp = time();\n    $whenDate = date('Y-m-d H:i:s', $whenStamp);\n\n    safe_upsert('txp_prefs', \"val = '$whenDate'\", \"name = 'lastmod'\");\n    callback_event('site.update', $trigger, 0, $rs, compact('whenStamp', 'whenDate'));\n}\n\n/**\n * Gets the site's last modification date.\n *\n * @param   int $unix_ts UNIX timestamp\n * @return  int UNIX timestamp\n * @package Pref\n */\n\nfunction get_lastmod($unix_ts = null)\n{\n    if ($unix_ts === null) {\n        $unix_ts = @strtotime(get_pref('lastmod'));\n    }\n\n    // Check for future articles that are now visible.\n    if (txpinterface === 'public' && $max_article = safe_field(\"UNIX_TIMESTAMP(Posted)\", 'textpattern', \"Posted <= \".now('posted').\" AND Status >= 4 ORDER BY Posted DESC LIMIT 1\")) {\n        $unix_ts = max($unix_ts, $max_article);\n    }\n\n    return $unix_ts;\n}\n\n/**\n * Sets headers.\n *\n * @param   array $headers    'name' => 'value'\n * @param   bool  $rewrite    If TRUE, rewrites existing headers\n */\n\nfunction set_headers($headers = array('Content-Type' => 'text/html; charset=utf-8'), $rewrite = false)\n{\n    if (headers_sent()) {\n        return;\n    }\n\n    $rewrite = (int)$rewrite;\n    $out = $headers_low = array();\n\n    if (($rewrite != 1 || in_array(true, $headers, true)) && $headers_list = headers_list()) {\n        foreach ($headers_list as $header) {\n            list($name, $value) = explode(':', $header, 2) + array(null, null);\n            $headers_low[strtolower(trim($name))] = $value;\n        }\n    }\n\n    foreach ($headers as $name => $header) {\n        $name_low = strtolower(trim($name));\n\n        if ((string)$header === '') {\n            !$rewrite or header_remove($name && $name != 1 ? $name : null);\n        } elseif ($header === true) {\n            if ($name == '' || $name == 1) {\n                $out = array_merge($out, $headers_low);\n            } elseif (isset($headers_low[$name_low])) {\n                $out[$name_low] = $headers_low[$name_low];\n            }\n        } elseif ($name == 1) {\n            txp_status_header($header);\n        } elseif ($rewrite == 1 || !isset($headers_low[$name_low])) {\n            header($name ? $name.': '.$header : $header);\n        } elseif ($rewrite) {\n            $header = implode(', ', do_list_unique($headers_low[$name_low].','.$header));\n            header($name ? $name.': '.$header : $header);\n        }\n    }\n\n    return $out ? $out : null;\n}\n\n/**\n * Sends and handles a lastmod header.\n *\n * @param   int|null $unix_ts The last modification date as a UNIX timestamp\n * @param   bool     $exit    If TRUE, terminates the script\n * @return  array|null Array of sent HTTP status and the lastmod header, or NULL\n * @package Pref\n */\n\nfunction handle_lastmod($unix_ts = null, $exit = true)\n{\n    // Disable caching when not in production\n    if (get_pref('production_status') != 'live') {\n        header('Cache-Control: no-cache, no-store, max-age=0');\n    } elseif (get_pref('send_lastmod')) {\n        $unix_ts = get_lastmod($unix_ts);\n\n        // Make sure lastmod isn't in the future.\n        $unix_ts = min($unix_ts, time());\n\n        $last = safe_strftime('rfc822', $unix_ts, 1);\n        header(\"Last-Modified: $last\");\n\n        $etag = base_convert($unix_ts, 10, 32);\n        header('ETag: \"' . $etag . '\"');\n\n        // Get timestamp from request caching headers\n        if (isset($_SERVER['HTTP_IF_MODIFIED_SINCE'])) {\n            $hims = $_SERVER['HTTP_IF_MODIFIED_SINCE'];\n            $imsd = ($hims) ? strtotime($hims) : 0;\n        } elseif (isset($_SERVER['HTTP_IF_NONE_MATCH'])) {\n            $hinm = trim(trim($_SERVER['HTTP_IF_NONE_MATCH']), '\"');\n            $hinm_apache_gzip_workaround = explode('-gzip', $hinm);\n            $hinm_apache_gzip_workaround = $hinm_apache_gzip_workaround[0];\n            $inmd = ($hinm) ? base_convert($hinm_apache_gzip_workaround, 32, 10) : 0;\n        }\n\n        // Check request timestamps against the current timestamp\n        if ((isset($imsd) && $imsd >= $unix_ts) ||\n            (isset($inmd) && $inmd >= $unix_ts)) {\n            log_hit('304');\n\n            header('Content-Length: 0');\n\n            txp_status_header('304 Not Modified');\n\n            if ($exit) {\n                exit();\n            }\n\n            return array('304', $last);\n        }\n\n        return array('200', $last);\n    }\n}\n\n/**\n * Gets preferences as an array.\n *\n * Returns preference values from the database as an array. Shouldn't be used to\n * retrieve selected preferences, see get_pref() instead.\n *\n * By default only the global preferences are returned.\n * If the optional user name parameter is supplied, the private preferences\n * for that user are returned.\n *\n * @param   string $user User name.\n * @return  array\n * @package Pref\n * @access  private\n * @see     get_pref()\n */\n\nfunction get_prefs($user = '')\n{\n    $out = array();\n    $user = implode(',', (array) quote_list($user));\n\n    $r = safe_rows_start(\"name, val\", 'txp_prefs', \"user_name IN (\".$user.\") ORDER BY FIELD(user_name, \".$user.\")\");\n\n    if ($r) {\n        while ($a = nextRow($r)) {\n            $out[$a['name']] = $a['val'];\n        }\n    }\n\n    return $out;\n}\n\n/**\n * Creates or updates a preference.\n *\n * @param   string $name       The name\n * @param   string $val        The value\n * @param   string $event      The section the preference appears in\n * @param   int    $type       Either PREF_CORE, PREF_PLUGIN, PREF_HIDDEN\n * @param   string $html       The HTML control type the field uses. Can take a custom function name\n * @param   int    $position   Used to sort the field on the Preferences panel\n * @param   bool   $is_private If PREF_PRIVATE, is created as a user pref\n * @return  bool FALSE on error\n * @package Pref\n * @example\n * if (set_pref('myPref', 'value'))\n * {\n *     echo \"'myPref' created or updated.\";\n * }\n */\n\nfunction set_pref($name, $val, $event = 'publish', $type = PREF_CORE, $html = 'text_input', $position = 0, $is_private = PREF_GLOBAL)\n{\n    global $prefs;\n\n    $prefs[$name] = $val;\n    $user_name = null;\n\n    if ($is_private == PREF_PRIVATE) {\n        $user_name = PREF_PRIVATE;\n    }\n\n    if (pref_exists($name, $user_name)) {\n        return update_pref($name, $val, null, null, null, null, $user_name);\n    }\n\n    return create_pref($name, $val, $event, $type, $html, $position, $user_name);\n}\n\n/**\n * Gets a preference string.\n *\n * Prefers global system-wide preferences over a user's private preferences.\n *\n * @param   string $thing   The named variable\n * @param   mixed  $default Used as a replacement if named pref isn't found\n * @param   bool   $from_db If TRUE checks database opposed $prefs variable in memory\n * @return  string Preference value or $default\n * @package Pref\n * @example\n * if (get_pref('enable_xmlrpc_server'))\n * {\n *     echo \"XML-RPC server is enabled.\";\n * }\n */\n\nfunction get_pref($thing, $default = '', $from_db = false)\n{\n    global $prefs, $txp_user;\n\n    if ($from_db) {\n        $name = doSlash($thing);\n        $user_name = doSlash($txp_user);\n\n        $field = safe_field(\n            \"val\",\n            'txp_prefs',\n            \"name = '$name' AND (user_name = '' OR user_name = '$user_name') ORDER BY user_name LIMIT 1\"\n        );\n\n        if ($field !== false) {\n            $prefs[$thing] = $field;\n        }\n    }\n\n    if (isset($prefs[$thing])) {\n        return $prefs[$thing];\n    }\n\n    return $default;\n}\n\n/**\n * Removes a preference string.\n *\n * Removes preference strings based on the given arguments. Use NULL to omit an argument.\n *\n * @param   string|null      $name      The preference string name\n * @param   string|null      $event     The preference event\n * @param   string|null|bool $user_name The owner. If PREF_PRIVATE, the current user\n * @return  bool TRUE on success\n * @since   4.6.0\n * @package Pref\n * @example\n * if (remove_pref(null, 'myEvent'))\n * {\n *     echo \"Removed all preferences from 'myEvent'.\";\n * }\n */\n\nfunction remove_pref($name = null, $event = null, $user_name = null)\n{\n    global $txp_user;\n\n    $sql = array();\n\n    if ($user_name === PREF_PRIVATE) {\n        if (!$txp_user) {\n            return false;\n        }\n\n        $user_name = $txp_user;\n    }\n\n    if ($user_name !== null) {\n        $sql[] = \"user_name = '\".doSlash((string) $user_name).\"'\";\n    }\n\n    if ($event !== null) {\n        $sql[] = \"event = '\".doSlash($event).\"'\";\n    }\n\n    if ($name !== null) {\n        $sql[] = \"name = '\".doSlash($name).\"'\";\n    }\n\n    if ($sql) {\n        return safe_delete('txp_prefs', join(\" AND \", $sql));\n    }\n\n    return false;\n}\n\n/**\n * Checks if a preference string exists.\n *\n * Searches for matching preference strings based on the given arguments.\n *\n * The $user_name argument can be used to limit the search to a specific user,\n * or to global and private strings. If NULL, matches are searched from both\n * private and global strings.\n *\n * @param   string           $name      The preference string name\n * @param   string|null|bool $user_name Either the username, NULL, PREF_PRIVATE or PREF_GLOBAL\n * @return  bool TRUE if the string exists, or FALSE on error\n * @since   4.6.0\n * @package Pref\n * @example\n * if (pref_exists('myPref'))\n * {\n *     echo \"'myPref' exists.\";\n * }\n */\n\nfunction pref_exists($name, $user_name = null)\n{\n    global $txp_user;\n\n    $sql = array();\n    $sql[] = \"name = '\".doSlash($name).\"'\";\n\n    if ($user_name === PREF_PRIVATE) {\n        if (!$txp_user) {\n            return false;\n        }\n\n        $user_name = $txp_user;\n    }\n\n    if ($user_name !== null) {\n        $sql[] = \"user_name = '\".doSlash((string) $user_name).\"'\";\n    }\n\n    if (safe_row(\"name\", 'txp_prefs', join(\" AND \", $sql))) {\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Creates a preference string.\n *\n * When a string is created, will trigger a 'preference.create > done' callback event.\n *\n * @param   string      $name       The name\n * @param   string      $val        The value\n * @param   string      $event      The section the preference appears in\n * @param   int         $type       Either PREF_CORE, PREF_PLUGIN, PREF_HIDDEN\n * @param   string      $html       The HTML control type the field uses. Can take a custom function name\n * @param   int         $position   Used to sort the field on the Preferences panel\n * @param   string|bool $user_name  The user name, PREF_GLOBAL or PREF_PRIVATE\n * @return  bool TRUE if the string exists, FALSE on error\n * @since   4.6.0\n * @package Pref\n * @example\n * if (create_pref('myPref', 'value', 'site', PREF_PLUGIN, 'text_input', 25))\n * {\n *     echo \"'myPref' created.\";\n * }\n */\n\nfunction create_pref($name, $val, $event = 'publish', $type = PREF_CORE, $html = 'text_input', $position = 0, $user_name = PREF_GLOBAL)\n{\n    global $txp_user;\n\n    if ($user_name === PREF_PRIVATE) {\n        if (!$txp_user) {\n            return false;\n        }\n\n        $user_name = $txp_user;\n    }\n\n    if (pref_exists($name, $user_name)) {\n        return true;\n    }\n\n    $val = is_scalar($val) ? (string)$val : json_encode($val, TEXTPATTERN_JSON);\n\n    if (\n        safe_insert(\n            'txp_prefs',\n            \"name = '\".doSlash($name).\"',\n            val = '\".doSlash($val).\"',\n            event = '\".doSlash($event).\"',\n            html = '\".doSlash($html).\"',\n            type = \".intval($type).\",\n            position = \".intval($position).\",\n            user_name = '\".doSlash((string) $user_name).\"'\"\n        ) === false\n    ) {\n        return false;\n    }\n\n    callback_event('preference.create', 'done', 0, compact('name', 'val', 'event', 'type', 'html', 'position', 'user_name'));\n\n    return true;\n}\n\n/**\n * Updates a preference string.\n *\n * Updates a preference string's properties. The $name and $user_name\n * arguments are used for selecting the updated string, and rest of the\n * arguments take the new values. Use NULL to omit an argument.\n *\n * When a string is updated, will trigger a 'preference.update > done' callback event.\n *\n * @param   string           $name       The update preference string's name\n * @param   string|null      $val        The value\n * @param   string|null      $event      The section the preference appears in\n * @param   int|null         $type       Either PREF_CORE, PREF_PLUGIN, PREF_HIDDEN\n * @param   string|null      $html       The HTML control type the field uses. Can take a custom function name\n * @param   int|null         $position   Used to sort the field on the Preferences panel\n * @param   string|bool|null $user_name  The updated string's owner, PREF_GLOBAL or PREF_PRIVATE\n * @return  bool             FALSE on error\n * @since   4.6.0\n * @package Pref\n * @example\n * if (update_pref('myPref', 'New value.'))\n * {\n *     echo \"Updated 'myPref' value.\";\n * }\n */\n\nfunction update_pref($name, $val = null, $event = null, $type = null, $html = null, $position = null, $user_name = PREF_GLOBAL)\n{\n    global $txp_user;\n\n    $where = $set = array();\n    $where[] = \"name = '\".doSlash($name).\"'\";\n\n    if ($user_name === PREF_PRIVATE) {\n        if (!$txp_user) {\n            return false;\n        }\n\n        $user_name = $txp_user;\n    }\n\n    if ($user_name !== null) {\n        $where[] = \"user_name = '\".doSlash((string) $user_name).\"'\";\n    }\n\n    if (isset($val)) {\n        $val = is_scalar($val) ? (string)$val : json_encode($val, TEXTPATTERN_JSON);\n    }\n\n    foreach (array('val', 'event', 'type', 'html', 'position') as $field) {\n        if ($$field !== null) {\n            $set[] = $field.\" = '\".doSlash($$field).\"'\";\n        }\n    }\n\n    if ($set && safe_update('txp_prefs', join(', ', $set), join(\" AND \", $where))) {\n        callback_event('preference.update', 'done', 0, compact('name', 'val', 'event', 'type', 'html', 'position', 'user_name'));\n\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Renames a preference string.\n *\n * When a string is renamed, will trigger a 'preference.rename > done' callback event.\n *\n * @param   string $newname   The new name\n * @param   string $name      The current name\n * @param   string $user_name Either the username, PREF_GLOBAL or PREF_PRIVATE\n * @return  bool FALSE on error\n * @since   4.6.0\n * @package Pref\n * @example\n * if (rename_pref('mynewPref', 'myPref'))\n * {\n *     echo \"Renamed 'myPref' to 'mynewPref'.\";\n * }\n */\n\nfunction rename_pref($newname, $name, $user_name = null)\n{\n    global $txp_user;\n\n    $where = array();\n    $where[] = \"name = '\".doSlash($name).\"'\";\n\n    if ($user_name === PREF_PRIVATE) {\n        if (!$txp_user) {\n            return false;\n        }\n\n        $user_name = $txp_user;\n    }\n\n    if ($user_name !== null) {\n        $where[] = \"user_name = '\".doSlash((string) $user_name).\"'\";\n    }\n\n    if (safe_update('txp_prefs', \"name = '\".doSlash($newname).\"'\", join(\" AND \", $where))) {\n        callback_event('preference.rename', 'done', 0, compact('newname', 'name', 'user_name'));\n\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Gets a list of custom fields.\n *\n * @return  array\n * @package CustomField\n */\n\nfunction getCustomFields()\n{\n    global $prefs;\n    static $out = null;\n\n    // Have cache?\n    if (!is_array($out)) {\n        $cfs = preg_grep('/^custom_\\d+_set/', array_keys($prefs));\n        $out = array();\n\n        foreach ($cfs as $name) {\n            preg_match('/(\\d+)/', $name, $match);\n\n            if ($prefs[$name] !== '') {\n                $out[$match[1]] = strtolower($prefs[$name]);\n            }\n        }\n\n        ksort($out, SORT_NUMERIC);\n    }\n\n    return $out;\n}\n\n/**\n * Build a query qualifier to filter non-matching custom fields from the\n * result set.\n *\n * @param   array $custom An array of 'custom_field_name' => field_number tuples\n * @param   array $pairs  Filter criteria: An array of 'name' => value tuples\n * @return  bool|string An SQL qualifier for a query's 'WHERE' part\n * @package CustomField\n */\n\nfunction buildCustomSql($custom, $pairs, $exclude = array())\n{\n    if ($pairs) {\n        foreach ($pairs as $k => $val) {\n            $no = array_search($k, $custom);\n\n            if ($no !== false) {\n                $not = ($exclude === true || isset($exclude[$k])) ? 'NOT ' : '';\n                $field = is_numeric($no) ? \"custom_{$no}\" : $no;\n\n                if ($val === true) {\n                    $out[] = \"({$not}{$field} != '')\";\n                } else {\n                    $val = doSlash($val);\n                    $parts = array();\n\n                    foreach ((array)$val as $v) {\n                        list($from, $to) = explode('%%', $v, 2) + array(null, null);\n\n                        if (!isset($to)) {\n                            $parts[] = \"{$not}{$field} LIKE '$from'\";\n                        } elseif ($from !== '') {\n                            $parts[] = $to === '' ? \"{$not}{$field} >= '$from'\" :  \"{$not}{$field} BETWEEN '$from' AND '$to'\";\n                        } elseif ($to !== '') {\n                            $parts[] = \"{$not}{$field} <= '$to'\";\n                        }\n                    }\n\n                    if ($parts) {\n                        $out[] = '('.join($not ? ' AND ' : ' OR ', $parts).')';\n                    }\n                }\n            }\n        }\n    }\n\n    return !empty($out) ? ' AND '.join(' AND ', $out).' ' : false;\n}\n\n/**\n * Build a query qualifier to filter time fields from the\n * result set.\n *\n * @param   string $month A starting time point\n * @param   string $time  A time offset\n * @param   string $field The field to filter\n * @return  string An SQL qualifier for a query's 'WHERE' part\n */\n\nfunction buildTimeSql($month, $time, $field = 'Posted')\n{\n    $safe_field = '`'.doSlash($field).'`';\n    $timeq = '1';\n\n    if ($month === 'past' || $month === 'any' || $month === 'future') {\n        if ($month === 'past') {\n            $timeq = \"$safe_field <= \".now($field);\n        } elseif ($month === 'future') {\n            $timeq = \"$safe_field > \".now($field);\n        }\n    } elseif ($time === 'past' || $time === 'any' || $time === 'future') {\n        if ($time === 'past') {\n            $timeq = \"$safe_field <= \".now($field);\n        } elseif ($time === 'future') {\n            $timeq = \"$safe_field > \".now($field);\n        }\n\n        if ($month) {\n            $offset = date('P', strtotime($month));\n            $dateClause = ($offset ? \"CONVERT_TZ($safe_field, @@session.time_zone, '$offset')\" : $safe_field).\" LIKE '\".doSlash($month).\"%'\";\n            $timeq .= \" AND $dateClause\";\n        }\n    } elseif (strpos($time, '%') !== false) {\n        $start = $month ? strtotime($month) : time() or $start = time();\n        $offset = date('P', $start);\n        $timeq = ($offset ? \"CONVERT_TZ($safe_field, @@session.time_zone, '$offset')\" : $safe_field).\" LIKE '\".doSlash(safe_strftime($time, $start)).\"%'\";\n    } else {\n        $start = $month ? strtotime($month) : false;\n\n        if ($start === false) {\n            $from = $month ? \"'\".doSlash($month).\"'\" : now($field);\n            $start = time();\n        } else {\n            $from = \"FROM_UNIXTIME($start)\";\n        }\n\n        if ($time === 'since') {\n            $timeq = \"$safe_field > $from\";\n        } elseif ($time === 'until') {\n            $timeq = \"$safe_field <= $from\";\n        } else {\n            $stop = strtotime($time, $start) or $stop = time();\n\n            if ($start > $stop) {\n                list($start, $stop) = array($stop, $start);\n            }\n\n            $timeq = ($start == $stop ?\n                \"$safe_field = FROM_UNIXTIME($start)\" :\n                \"$safe_field BETWEEN FROM_UNIXTIME($start) AND FROM_UNIXTIME($stop)\"\n            );\n        }\n    }\n\n    return $timeq;\n}\n\n/**\n * Sends a HTTP status header.\n *\n * @param   string $status The HTTP status code\n * @package Network\n * @example\n * txp_status_header('403 Forbidden');\n */\n\nfunction txp_status_header($status = '200 OK')\n{\n    if (IS_FASTCGI) {\n        header(\"Status: $status\");\n    } elseif (serverSet('SERVER_PROTOCOL') == 'HTTP/1.0') {\n        header(\"HTTP/1.0 $status\");\n    } else {\n        header(\"HTTP/1.1 $status\");\n    }\n}\n\n/**\n * Terminates normal page rendition and outputs an error page.\n *\n * @param   string|array $msg    The error message\n * @param   string       $status HTTP status code\n * @param   string       $url    Redirects to the specified URL. Can be used with $status of 301, 302 and 307\n * @package Tag\n */\n\nfunction txp_die($msg, $status = '503', $url = '')\n{\n    global $connected, $txp_error_message, $txp_error_status, $txp_error_code, $pretext, $production_status, $trace;\n\n    // Make it possible to call this function as a tag, e.g. in an article\n    // <txp:txp_die status=\"410\" />.\n    if (is_array($msg)) {\n        extract(lAtts(array(\n            'msg'    => '',\n            'status' => '503',\n            'url'    => '',\n        ), $msg));\n    }\n\n    // Intentionally incomplete - just the ones we're likely to use.\n    $codes = array(\n        '200' => 'OK',\n        '301' => 'Moved Permanently',\n        '302' => 'Found',\n        '303' => 'See Other',\n        '304' => 'Not Modified',\n        '307' => 'Temporary Redirect',\n        '308' => 'Permanent Redirect',\n        '401' => 'Unauthorized',\n        '403' => 'Forbidden',\n        '404' => 'Not Found',\n        '410' => 'Gone',\n        '414' => 'Request-URI Too Long',\n        '451' => 'Unavailable For Legal Reasons',\n        '500' => 'Internal Server Error',\n        '501' => 'Not Implemented',\n        '503' => 'Service Unavailable'\n    );\n\n    if ($status) {\n        if (isset($codes[strval($status)])) {\n            $status = strval($status).' '.$codes[$status];\n        }\n\n        txp_status_header($status);\n    }\n\n    $code = (int) $status;\n\n    callback_event('txp_die', $code, 0, $url);\n\n    // Redirect with status.\n    if ($url && in_array($code, array(301, 302, 303, 307, 308))) {\n        ob_end_clean();\n        header(\"Location: $url\", true, $code);\n        die('<html><head><meta http-equiv=\"refresh\" content=\"0;URL='.txpspecialchars($url).'\"></head><body><p>Document has <a href=\"'.txpspecialchars($url).'\">moved here</a>.</p></body></html>');\n    }\n\n    $out = false;\n    $skin = empty($pretext['skin']) ? null : $pretext['skin'];\n\n    if ($connected && @txpinterface == 'public') {\n        $out = fetch_page(\"error_{$code}\", $skin) or $out = fetch_page('error_default', $skin);\n    }\n\n    if ($out === false) {\n        $out = <<<eod\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n   <meta charset=\"utf-8\">\n   <meta name=\"robots\" content=\"noindex\">\n   <title>Textpattern Error: <txp:error_status /></title>\n</head>\n<body>\n    <p><txp:error_message /></p>\n</body>\n</html>\neod;\n    }\n\n    header(\"Content-Type: text/html; charset=utf-8\");\n    $debug = $production_status === 'live' ?\n        '' :\n        $trace->summary().($production_status === 'debug' ? $trace->result() : '');\n\n    if (is_callable('parse')) {\n        $txp_error_message = $msg;\n        $txp_error_status = $status;\n        $txp_error_code = $code;\n        set_error_handler(\"tagErrorHandler\");\n        die(parse($out).$debug);\n    } else {\n        $out = preg_replace(\n            array('@<txp:error_status[^>]*/>@', '@<txp:error_message[^>]*/>@'),\n            array($status, $msg),\n            $out\n        );\n\n        die($out.$debug);\n    }\n}\n\n/**\n * Get field => alias array.\n *\n * @param   string $match\n * @return  array()\n * @since   4.8.0\n * @package TagParser\n */\n\nfunction parse_qs($match, $sep='=')\n{\n    $pairs = array();\n\n    foreach (do_list_unique($match) as $chunk) {\n        $name = strtok($chunk, $sep);\n        $alias = strtok($sep);\n        $pairs[strtolower($name)] = $alias;\n    };\n\n    return $pairs;\n}\n\n/**\n * Gets a URL-encoded and HTML entity-escaped query string for a URL.\n *\n * Builds a HTTP query string from an associative array.\n *\n * @param   array $q The parameters for the query\n * @return  string The query, including starting \"?\".\n * @package URL\n * @example\n * echo join_qs(array('param1' => 'value1', 'param2' => 'value2'));\n */\n\nfunction join_qs($q, $sep = '&amp;')\n{\n    $qs = array();\n    $sql = $sep !== '&amp;';\n\n    foreach ($q as $k => $v) {\n        if (is_array($v)) {\n            $v = join(',', $v);\n        }\n\n        if ($k && (string) $v !== '') {\n            $qs[$k] = $sql ? \"$k = $v\" : urlencode($k).'='.urlencode($v);\n        }\n    }\n\n    if (!isset($sep)) {\n        return $qs;\n    }\n\n    $str = join($sep, $qs);\n\n    return  $str ? ($sql ? '' : '?').$str : '';\n}\n\n/**\n * Builds a HTML attribute list from an array.\n *\n * Takes an array of raw HTML attributes, and returns a properly\n * sanitised HTML attribute string for use in a HTML tag.\n *\n * Internally handles HTML boolean attributes, array lists and query strings.\n * If an attributes value is set as a boolean, the attribute is considered\n * as one too. If a value is NULL, it's omitted and the attribute is added\n * without a value. An array value is converted to a space-separated list,\n * or for 'href' and 'src' to a URL encoded query string.\n *\n * @param   array|string  $atts  HTML attributes\n * @param   int           $flags TEXTPATTERN_STRIP_EMPTY_STRING\n * @return  string HTML attribute list\n * @since   4.6.0\n * @package HTML\n * @example\n * echo join_atts(array('class' => 'myClass', 'disabled' => true));\n */\n\nfunction join_atts($atts, $flags = TEXTPATTERN_STRIP_EMPTY_STRING, $glue = ' ')\n{\n    if (!is_array($atts)) {\n        return $atts ? ' '.trim($atts) : '';\n    }\n\n    $list = '';\n    $txp = $flags & TEXTPATTERN_STRIP_TXP;\n\n    foreach ($atts as $name => $value) {\n        if (($flags & TEXTPATTERN_STRIP_EMPTY && !$value) || ($value === false) || ($txp && $value === null)) {\n            continue;\n        } elseif ($value === null || $txp && $value === true) {\n            $list .= ' '.$name;\n            continue;\n        } elseif (is_array($value)) {\n            if ($name == 'href' || $name == 'src') {\n                $value = join_qs($value);\n            } else {\n                $value = txpspecialchars(join($glue, $value));\n            }\n        } elseif ($name != 'href' && $name != 'src') {\n            $value = txpspecialchars($value === true ? $name : $value);\n        } else {\n            $value = txpspecialchars(str_replace('&amp;', '&', $value));\n        }\n\n        if (!($flags & TEXTPATTERN_STRIP_EMPTY_STRING && $value === '')) {\n            $list .= ' '.$name.'=\"'.$value.'\"';\n        }\n    }\n\n    return $list;\n}\n\n/**\n * Builds a page URL from an array of parameters.\n *\n * The $inherit can be used to add parameters to an existing url, e.g:\n * pagelinkurl(array('pg' => 2), $pretext).\n *\n * Cannot be used to link to an article. See permlinkurl() and permlinkurl_id() instead.\n *\n * @param   array $parts   The parts used to construct the URL\n * @param   array $inherit Can be used to add parameters to an existing url\n * @return  string\n * @see     permlinkurl()\n * @see     permlinkurl_id()\n * @package URL\n */\n\nfunction pagelinkurl($parts, $inherit = array(), $url_mode = null)\n{\n    global $permlink_mode, $prefs, $txp_context, $txp_sections;\n\n    // Link to an article.\n    if (!empty($parts['id'])) {\n        return permlinkurl_id($parts['id']);\n    }\n\n    $hu = isset($prefs['url_base']) ? $prefs['url_base'] : hu;\n    $keys = $parts;\n    !is_array($inherit) or $keys += $inherit;\n    empty($txp_context) or $keys += $txp_context;\n    unset($keys['id']);\n\n    if (isset($prefs['custom_url_func'])\n        && is_callable($prefs['custom_url_func'])\n        && ($url = call_user_func($prefs['custom_url_func'], $keys, PAGELINKURL)) !== false) {\n        return $url;\n    }\n\n    if (isset($keys['s'])) {\n        if (!isset($url_mode) && isset($txp_sections[$keys['s']])) {\n            $url_mode = $txp_sections[$keys['s']]['permlink_mode'];\n        }\n\n        if ($keys['s'] == 'default') {\n            unset($keys['s']);\n        }\n    }\n\n    if (empty($url_mode)) {\n        $url_mode = $permlink_mode;\n    }\n\n    // 'article' context is implicit, no need to add it to the page URL.\n    if (isset($keys['context']) && $keys['context'] == 'article') {\n        unset($keys['context']);\n    }\n\n    $numkeys = array();\n\n    foreach ($keys as $key => $v) {\n        if (is_numeric($key)) {\n            $numkeys[$key] = urlencode($v).'/';\n            unset($keys[$key]);\n        }\n    }\n\n    if ($url_mode == 'messy') {\n        $url = 'index.php';\n    } else {\n        // All clean URL modes use the same schemes for list pages.\n        $url = '';\n\n        if (!empty($keys['rss'])) {\n            $url = 'rss/';\n            unset($keys['rss']);\n        } elseif (!empty($keys['atom'])) {\n            $url = 'atom/';\n            unset($keys['atom']);\n        } elseif (!empty($keys['s'])) {\n            $url = urlencode($keys['s']).'/';\n            unset($keys['s']);\n            if (!empty($keys['c']) && ($url_mode == 'section_category_title' || $url_mode == 'breadcrumb_title')) {\n                $catpath = $url_mode == 'breadcrumb_title' ?\n                    array_column(getRootPath($keys['c'], empty($keys['context']) ? 'article' : $keys['context']), 'name') :\n                    array($keys['c']);\n                $url .= implode('/', array_map('urlencode', array_reverse($catpath))).'/';\n                unset($keys['c']);\n            } elseif (!empty($keys['month']) && $url_mode == 'year_month_day_title' && is_date($keys['month'])) {\n                $url .= implode('/', explode('-', urlencode($keys['month']))).'/';\n                unset($keys['month']);\n            }\n        } elseif (!empty($keys['author']) && $url_mode != 'year_month_day_title') {\n            $ct = empty($keys['context']) ? '' : strtolower(urlencode(gTxt($keys['context'].'_context'))).'/';\n            $url = strtolower(urlencode(gTxt('author'))).'/'.$ct.urlencode($keys['author']).'/';\n            unset($keys['author'], $keys['context']);\n        } elseif (!empty($keys['c']) && $url_mode != 'year_month_day_title') {\n            $ct = empty($keys['context']) ? '' : strtolower(urlencode(gTxt($keys['context'].'_context'))).'/';\n            $url = strtolower(urlencode(gTxt('category'))).'/'.$ct;\n            $catpath = $url_mode == 'breadcrumb_title' ?\n                array_column(getRootPath($keys['c'], empty($keys['context']) ? 'article' : $keys['context']), 'name') :\n                array($keys['c']);\n            $url .= implode('/', array_map('urlencode', array_reverse($catpath))).'/';\n            unset($keys['c'], $keys['context']);\n        } elseif (!empty($keys['month']) && is_date($keys['month'])) {\n            $url = implode('/', explode('-', urlencode($keys['month']))).'/';\n            unset($keys['month']);\n        }\n    }\n\n    if (!empty($keys['context'])) {\n        $keys['context'] = gTxt($keys['context'].'_context');\n    }\n\n    return $hu.(empty($prefs['no_trailing_slash']) ? $url : rtrim($url, '/')).join_qs($keys);\n}\n\n/**\n * Gets a URL for the given article.\n *\n * If you need to generate a list of article URLs from already fetched table\n * rows, consider using permlinkurl() over this due to performance benefits.\n *\n * @param   int $id The article ID\n * @return  string The URL\n * @see     permlinkurl()\n * @package URL\n * @example\n * echo permlinkurl_id(12);\n */\n\nfunction permlinkurl_id($id)\n{\n    global $permlinks, $thisarticle;\n\n    $id = (int) $id;\n\n    if (isset($permlinks[$id])) {\n        return permlinkurl(array('id' => $id));\n    }\n\n    if (isset($thisarticle['thisid']) && $thisarticle['thisid'] == $id) {\n        return permlinkurl($thisarticle);\n    }\n\n    $rs = empty($id) ? array() : safe_row(\n        \"ID AS thisid, Section, Title, url_title, Category1, Category2, UNIX_TIMESTAMP(Posted) AS posted, UNIX_TIMESTAMP(Expires) AS expires\",\n        'textpattern',\n        \"ID = $id\"\n    );\n\n    return permlinkurl($rs);\n}\n\n/**\n * Generates an article URL from the given data array.\n *\n * @param   array $article_array An array consisting of keys 'thisid', 'section', 'title', 'url_title', 'posted', 'expires'\n * @return  string The URL\n * @package URL\n * @see     permlinkurl_id()\n * @example\n * echo permlinkurl_id(array(\n *     'thisid'    => 12,\n *     'section'   => 'blog',\n *     'url_title' => 'my-title',\n *     'posted'    => 1345414041,\n *     'expires'   => 1345444077\n * ));\n */\n\nfunction permlinkurl($article_array, $hu = null)\n{\n    global $permlink_mode, $prefs, $permlinks, $txp_sections;\n    static $internals = array('id', 's', 'context', 'pg', 'p'), $now = null,\n        $fields = array(\n            'thisid'    => null,\n            'id'        => null,\n            'title'     => null,\n            'url_title' => null,\n            'section'   => null,\n            'category1' => null,\n            'category2' => null,\n            'posted'    => null,\n            'uposted'   => null,\n            'expires'   => null,\n            'uexpires'  => null,\n        );\n\n    if (isset($prefs['custom_url_func'])\n        and is_callable($prefs['custom_url_func'])\n        and ($url = call_user_func($prefs['custom_url_func'], $article_array, PERMLINKURL)) !== false) {\n        return $url;\n    }\n\n    if (empty($article_array)) {\n        return false;\n    }\n\n    extract(array_intersect_key(array_change_key_case($article_array, CASE_LOWER), $fields) + $fields);\n    isset($hu) or $hu = isset($prefs['url_base']) ? $prefs['url_base'] : hu;\n\n    if (empty($thisid)) {\n        $thisid = $id;\n    }\n\n    $thisid = (int) $thisid;\n    $keys = get_context(null);\n\n    foreach ($internals as $key) {\n        unset($keys[$key]);\n    }\n\n    if (isset($permlinks[$thisid])) {\n        return $hu.($permlinks[$thisid] === true ?\n            'index.php'.join_qs(array('id' => $thisid) + $keys) :\n            $permlinks[$thisid].join_qs($keys)\n        );\n    }\n\n    if (!isset($now)) {\n        $now = date('Y-m-d H:i:s');\n    }\n\n    if (empty($prefs['publish_expired_articles']) &&\n        !empty($expires) &&\n        $prefs['production_status'] != 'live' &&\n        txpinterface == 'public' &&\n        (is_numeric($expires) ? $expires < time()\n            : (isset($uexpires) ? $uexpires < time()\n            : $expires < $now)\n        )\n    ) {\n        trigger_error(gTxt('permlink_to_expired_article', array('{id}' => $thisid)), E_USER_NOTICE);\n    }\n\n    if (empty($section)) {\n        $url_mode = 'messy';\n    } elseif (isset($txp_sections[$section])) {\n        $url_mode = empty($txp_sections[$section]['permlink_mode']) ? $permlink_mode : $txp_sections[$section]['permlink_mode'];\n    } else {\n        $url_mode = $permlink_mode;\n    }\n\n    if (empty($url_title) && !in_array($url_mode, array('section_id_title', 'id_title'))) {\n        $url_mode = 'messy';\n    }\n\n    $section = urlencode($section);\n    $url_title = urlencode($url_title);\n\n    switch ($url_mode) {\n        case 'section_id_title':\n            if ($url_title && $prefs['attach_titles_to_permalinks']) {\n                $out = \"$section/$thisid/$url_title\";\n            } else {\n                $out = \"$section/$thisid\";\n            }\n            break;\n        case 'year_month_day_title':\n            list($y, $m, $d) = explode(\"-\", date(\"Y-m-d\", isset($uposted) ? $uposted : $posted));\n            $out =  \"$y/$m/$d/$url_title\";\n            break;\n        case 'id_title':\n            if ($url_title && $prefs['attach_titles_to_permalinks']) {\n                $out = \"$thisid/$url_title\";\n            } else {\n                $out = \"$thisid\";\n            }\n            break;\n        case 'section_title':\n            $out = \"$section/$url_title\";\n            break;\n        case 'section_category_title':\n            $out = $section.'/'.\n                (empty($category1) ? '' : urlencode($category1).'/').\n                (empty($category2) ? '' : urlencode($category2).'/').$url_title;\n            break;\n        case 'breadcrumb_title':\n            $out = $section.'/';\n            if (empty($category1)) {\n                if (!empty($category2)) {\n                    $path = array_reverse(array_column(getRootPath($category2), 'name'));\n                    $out .= implode('/', array_map('urlencode', $path)).'/';\n                }\n            } elseif (empty($category2)) {\n                $path = array_reverse(array_column(getRootPath($category1), 'name'));\n                $out .= implode('/', array_map('urlencode', $path)).'/';\n            } else {\n                $c2_path = array_reverse(array_column(getRootPath($category2), 'name'));\n                if (in_array($category1, $c2_path)) {\n                    $out .= implode('/', array_map('urlencode', $c2_path)).'/';\n                } else {\n                    $c1_path = array_reverse(array_column(getRootPath($category1), 'name'));\n                    if (in_array($category2, $c1_path)) {\n                        $out .= implode('/', array_map('urlencode', $c1_path)).'/';\n                    } else {\n                        $c0_path = array_intersect($c1_path, $c2_path);\n                        $out .= ($c0_path ? implode('/', array_map('urlencode', $c0_path)).'/' : '').\n                            urlencode($category1).'/'.urlencode($category2).'/';\n                    }\n                }\n            }\n            $out .= $url_title;\n            break;\n        case 'title_only':\n            $out = $url_title;\n            break;\n        case 'messy':\n            $out = \"index.php\";\n            $keys['id'] = $thisid;\n            break;\n    }\n\n    $permlinks[$thisid] = $url_mode == 'messy' ? true : $out;\n\n    return $hu.$out.join_qs($keys);\n}\n\n/**\n * Gets a file download URL.\n *\n * @param   int    $id       The ID\n * @param   string $filename The filename\n * @return  string\n * @package File\n */\n\nfunction filedownloadurl($id, $filename = '')\n{\n    global $permlink_mode;\n\n    if ($permlink_mode == 'messy') {\n        return hu.'index.php'.join_qs(array(\n            's'  => 'file_download',\n            'id' => (int) $id,\n        ));\n    }\n\n    if ($filename) {\n        $filename = '/'.urlencode($filename);\n\n        // FIXME: work around yet another mod_deflate problem (double compression)\n        // https://blogs.msdn.microsoft.com/wndp/2006/08/21/content-encoding-content-type/\n        if (preg_match('/gz$/i', $filename)) {\n            $filename .= a;\n        }\n    }\n\n    return hu.'file_download/'.intval($id).$filename;\n}\n\n/**\n * Gets an image's absolute URL.\n *\n * @param   int    $id        The image\n * @param   string $ext       The file extension\n * @param   bool   $thumbnail If TRUE returns a URL to the thumbnail\n * @return  string\n * @package Image\n */\n\nfunction imagesrcurl($id, $ext, $thumbnail = false)\n{\n    global $img_dir;\n    $thumbnail = $thumbnail ? 't' : '';\n\n    return ihu.$img_dir.'/'.$id.$thumbnail.$ext;\n}\n\n/**\n * Checks if a value exists in a list.\n *\n * @param  string $val   The searched value\n * @param  string $list  The value list\n * @param  string $delim The list boundary\n * @return bool Returns TRUE if $val is found, FALSE otherwise\n * @example\n * if (in_list('red', 'blue, green, red, yellow'))\n * {\n *     echo \"'red' found from the list.\";\n * }\n */\n\nfunction in_list($val, $list, $delim = ',')\n{\n    return in_array((string) $val, do_list($list, $delim), true);\n}\n\n/**\n * Split a string by string.\n *\n * Trims the created values of whitespace.\n *\n * @param  array|string $list  The string\n * @param  string       $delim The boundary\n * @return array\n * @example\n * print_r(\n *     do_list('value1, value2, value3')\n * );\n */\n\nfunction do_list($list, $delim = ',')\n{\n    if (!isset($list)) {\n        return array();\n    } elseif (is_array($list)) {\n        return array_map('trim', $list);\n    }\n\n    if (is_array($delim)) {\n        list($delim, $range) = $delim + array(null, null);\n    }\n\n    $array = explode($delim, $list);\n\n    if (isset($range) && strpos($list, $range) !== false) {\n        $pattern = '/^\\s*(\\w|[-+]?\\d+)\\s*'.preg_quote($range, '/').'\\s*(\\w|[-+]?\\d+)\\s*$/';\n        $out = array();\n\n        foreach ($array as $item) {\n            if (!preg_match($pattern, $item, $match)) {\n                $out[] = trim($item);\n            } else {\n                list($m, $start, $end) = $match;\n                foreach(range($start, $end) as $v) {\n                    $out[] = $v;\n                }\n            }\n        }\n    }\n\n    return isset($out) ? $out : array_map('trim', $array);\n}\n\n/**\n * Split a string by string, returning only unique results.\n *\n * Trims unique values of whitespace. Flags permit exclusion of empty strings.\n *\n * @param  string $list  The string\n * @param  string $delim The boundary\n * @param  int    $flags TEXTPATTERN_STRIP_NONE | TEXTPATTERN_STRIP_EMPTY | TEXTPATTERN_STRIP_EMPTY_STRING\n * @return array\n * @example\n * print_r(\n *     do_list_unique('value1, value2, value3')\n * );\n */\n\nfunction do_list_unique($list, $delim = ',', $flags = TEXTPATTERN_STRIP_EMPTY_STRING)\n{\n    $out = array_unique(do_list($list, $delim));\n\n    if ($flags & TEXTPATTERN_STRIP_EMPTY) {\n        $out = array_filter($out);\n    } elseif ($flags & TEXTPATTERN_STRIP_EMPTY_STRING) {\n        $out = array_filter($out, function ($v) {return $v !== '';});\n    }\n\n    return $out;\n}\n\n/**\n * Wraps a string in single quotes.\n *\n * @param  string $val The input string\n * @return string\n */\n\nfunction doQuote($val)\n{\n    return \"'$val'\";\n}\n\n/**\n * Escapes special characters for use in an SQL statement and wraps the value\n * in quote.\n *\n * Useful for creating an array/string of values for use in an SQL statement.\n *\n * @param   string|array $in The input value\n * @param   string|null  $separator The separator\n * @return  mixed\n * @package DB\n * @example\n * if ($r = safe_row('name', 'myTable', 'type in(' . quote_list(array('value1', 'value2'), ',') . ')')\n * {\n *     echo \"Found '{$r['name']}'.\";\n * }\n */\n\nfunction quote_list($in, $separator = null)\n{\n    $out = doArray(doSlash($in), 'doQuote');\n\n    return isset($separator) ? implode($separator, $out) : $out;\n}\n\n/**\n * Adds a line to the tag trace.\n *\n * @param   string $msg             The message\n * @param   int    $tracelevel_diff Change trace level\n * @deprecated in 4.6.0\n * @package Debug\n */\n\nfunction trace_add($msg, $level = 0, $dummy = null)\n{\n    global $trace;\n\n    if ((int) $level > 0) {\n        $trace->start($msg);\n    } elseif ((int) $level < 0) {\n        $trace->stop();\n    } else {\n        $trace->log($msg);\n    }\n\n    // TODO: Uncomment this to trigger deprecated warning in a version (or two).\n    // Due to the radical changes under the hood, plugin authors will probably\n    // support dual 4.5/4.6 plugins for the short term. Deprecating this\n    // immediately causes unnecessary pain for developers.\n//    trigger_error(gTxt('deprecated_function_with', array('{name}' => __FUNCTION__, '{with}' => 'class Trace')), E_USER_NOTICE);\n}\n\n/**\n * Push current article on the end of data stack.\n *\n * Populates $stack_article global with the current $thisarticle.\n */\n\nfunction article_push()\n{\n    global $thisarticle, $stack_article;\n    $stack_article[] = $thisarticle;\n}\n\n/**\n * Advance to the next article in the current data stack.\n *\n * Populates $thisarticle global with the last article from the\n * stack stored in $stack_article.\n */\n\nfunction article_pop()\n{\n    global $thisarticle, $stack_article;\n    $thisarticle = array_pop($stack_article);\n}\n\n/**\n * Gets a path relative to the site's root directory.\n *\n * @param   string $path The filename to parse\n * @param   string $pfx  The root directory\n * @return  string The absolute $path converted to relative\n * @package File\n */\n\nfunction relative_path($path, $pfx = null)\n{\n    if ($pfx === null) {\n        $pfx = dirname(txpath);\n    }\n\n    return preg_replace('@^/'.preg_quote(ltrim($pfx, '/'), '@').'/?@', '', $path);\n}\n\n/**\n * Gets a backtrace.\n *\n * @param   int $num   The limit\n * @param   int $start The offset\n * @return  array A backtrace\n * @package Debug\n */\n\nfunction get_caller($num = 1, $start = 2)\n{\n    $out = array();\n\n    if (!is_callable('debug_backtrace')) {\n        return $out;\n    }\n\n    $bt = debug_backtrace();\n\n    for ($i = $start; $i < $num+$start; $i++) {\n        if (!empty($bt[$i])) {\n            $t = '';\n\n            if (!empty($bt[$i]['file'])) {\n                $t .= relative_path($bt[$i]['file']);\n            }\n\n            if (!empty($bt[$i]['line'])) {\n                $t .= ':'.$bt[$i]['line'];\n            }\n\n            if ($t) {\n                $t .= ' ';\n            }\n\n            if (!empty($bt[$i]['class'])) {\n                $t .= $bt[$i]['class'];\n            }\n\n            if (!empty($bt[$i]['type'])) {\n                $t .= $bt[$i]['type'];\n            }\n\n            if (!empty($bt[$i]['function'])) {\n                $t .= $bt[$i]['function'];\n                $t .= '()';\n            }\n\n            $out[] = $t;\n        }\n    }\n\n    return $out;\n}\n\n/**\n * Sets a locale.\n *\n * The function name is misleading but remains for legacy reasons.\n *\n * @param      string $lang\n * @return     string Current locale\n * @package    L10n\n * @deprecated in 4.6.0\n * @see        \\Textpattern\\L10n\\Locale::setLocale()\n */\n\nfunction getlocale($lang)\n{\n    global $locale;\n\n    Txp::get('\\Textpattern\\L10n\\Locale')->setLocale(LC_TIME, array($lang, $locale));\n\n    return Txp::get('\\Textpattern\\L10n\\Locale')->getLocale(LC_TIME);\n}\n\n/**\n * Fetch meta description from the given (or automatic) context.\n *\n * Category context may be refined by specifying the content type as well\n * after a dot. e.g. category.image to check image context category.\n *\n * @param string $type Flavour of meta content to fetch (section, category, article)\n */\n\nfunction getMetaDescription($type = null)\n{\n    global $thisarticle, $thiscategory, $thissection, $c, $s, $context, $txp_sections;\n\n    $content = '';\n\n    if ($type === null) {\n        if ($thiscategory) {\n            $content = $thiscategory['description'];\n        } elseif ($thissection) {\n            $content = $thissection['description'];\n        } elseif ($thisarticle) {\n            $content = $thisarticle['description'];\n        } elseif ($c) {\n            $content = safe_field(\"description\", 'txp_category', \"name = '\".doSlash($c).\"' AND type = '\".doSlash($context).\"'\");\n        } elseif ($s) {\n            $content = isset($txp_sections[$s]) ? $txp_sections[$s]['description'] : '';\n        }\n    } else {\n        if (strpos($type, 'category') === 0) {\n            // Category context.\n            if ($thiscategory) {\n                $content = $thiscategory['description'];\n            } else {\n                $thisContext = $context;\n                $catParts = do_list($type, '.');\n\n                if (isset($catParts[1])) {\n                    $thisContext = $catParts[1];\n                }\n\n                $clause = \" AND type = '\".$thisContext.\"'\";\n                $content = safe_field(\"description\", 'txp_category', \"name = '\".doSlash($c).\"'\".$clause);\n            }\n        } elseif ($type === 'section') {\n            $theSection = ($thissection) ? $thissection['name'] : $s;\n            $content = isset($txp_sections[$theSection]) ? $txp_sections[$theSection]['description'] : '';\n        } elseif ($type === 'article') {\n            assert_article();\n            $content = ($thisarticle? $thisarticle['description'] : '');\n        }\n    }\n\n    return $content;\n}\n\n/**\n * Get some URL data.\n * @param mixed $context The data to retrieve\n * @param array $internals Data restrictions\n * @return array The retrieved data\n */\n\nfunction get_context($context = true, $internals = array('id', 's', 'c', 'context', 'q', 'm', 'pg', 'p', 'month', 'author', 'f'))\n{\n    global $pretext, $txp_context;\n\n    if (!isset($context)) {\n        return empty($txp_context) ? array() : $txp_context;\n    } elseif (empty($context)) {\n        return array();\n    } elseif (!is_array($context)) {\n        $context = array_fill_keys($context === true ? $internals : do_list_unique($context), null);\n    }\n\n    $out = array();\n\n    foreach ($context as $q => $v) {\n        if (isset($v)) {\n            $out[$q] = $v;\n        } elseif (isset($pretext[$q]) && in_array($q, $internals)) {\n            $out[$q] = $q === 'author' ? $pretext['realname'] : $pretext[$q];\n        } else {\n            $out[$q] = gps($q, $v);\n        }\n    }\n\n    return $out;\n}\n\n/**\n * Assert context error.\n */\n\nfunction assert_context($type = 'article', $throw = true)\n{\n    global ${'this'.$type};\n\n    if (empty(${'this'.$type})) {\n        if ($throw) {\n            throw new \\Exception(gTxt(\"error_{$type}_context\"));\n        } else {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n/**\n * Assert article context error.\n */\n\nfunction assert_article($throw = true)\n{\n    return assert_context('article', $throw);\n}\n\n/**\n * Assert comment context error.\n */\n\nfunction assert_comment($throw = true)\n{\n    return assert_context('comment', $throw);\n}\n\n/**\n * Assert file context error.\n */\n\nfunction assert_file($throw = true)\n{\n    return assert_context('file', $throw);\n}\n\n/**\n * Assert image context error.\n */\n\nfunction assert_image($throw = true)\n{\n    return assert_context('image', $throw);\n}\n\n/**\n * Assert link context error.\n */\n\nfunction assert_link($throw = true)\n{\n    return assert_context('link', $throw);\n}\n\n/**\n * Assert section context error.\n */\n\nfunction assert_section($throw = true)\n{\n    return assert_context('section', $throw);\n}\n\n/**\n * Assert category context error.\n */\n\nfunction assert_category($throw = true)\n{\n    return assert_context('category', $throw);\n}\n\n/**\n * Validate a variable as an integer.\n *\n * @param  mixed $myvar The variable\n * @return int|bool The variable or FALSE on error\n */\n\nfunction assert_int($myvar)\n{\n    if (is_numeric($myvar) && $myvar == intval($myvar)) {\n        return (int) $myvar;\n    }\n\n    trigger_error(gTxt('assert_int_value', array('{name}' => (string) $myvar)), E_USER_ERROR);\n\n    return false;\n}\n\n/**\n * Validate a variable as a string.\n *\n * @param  mixed $myvar The variable\n * @return string|bool The variable or FALSE on error\n */\n\nfunction assert_string($myvar)\n{\n    if (is_string($myvar)) {\n        return $myvar;\n    }\n\n    trigger_error(gTxt('assert_string_value', array('{name}' => (string) $myvar)), E_USER_ERROR);\n\n    return false;\n}\n\n/**\n * Validate a variable as an array.\n *\n * @param  mixed $myvar The variable\n * @return array|bool The variable or FALSE on error\n */\n\nfunction assert_array($myvar)\n{\n    if (is_array($myvar)) {\n        return $myvar;\n    }\n\n    trigger_error(gTxt('assert_array_value', array('{name}' => (string) $myvar)), E_USER_ERROR);\n\n    return false;\n}\n\n/**\n * Converts relative links in HTML markup to absolute.\n *\n * @param   string $html      The HTML to check\n * @param   string $permalink Optional URL part appended to the links\n * @return  string HTML\n * @package URL\n */\n\nfunction replace_relative_urls($html, $permalink = '')\n{\n    global $siteurl;\n\n    // URLs like \"/foo/bar\" - relative to the domain.\n    if (serverSet('HTTP_HOST')) {\n        $html = preg_replace('@(<a[^>]+href=\")/(?!/)@', '$1'.PROTOCOL.serverSet('HTTP_HOST').'/', $html);\n        $html = preg_replace('@(<img[^>]+src=\")/(?!/)@', '$1'.PROTOCOL.serverSet('HTTP_HOST').'/', $html);\n    }\n\n    // \"foo/bar\" - relative to the textpattern root,\n    // leave \"http:\", \"mailto:\" et al. as absolute URLs.\n    $html = preg_replace('@(<a[^>]+href=\")(?!\\w+:|//)@', '$1'.PROTOCOL.$siteurl.'/$2', $html);\n    $html = preg_replace('@(<img[^>]+src=\")(?!\\w+:|//)@', '$1'.PROTOCOL.$siteurl.'/$2', $html);\n\n    if ($permalink) {\n        $html = preg_replace(\"/href=\\\\\\\"#(.*)\\\"/\", \"href=\\\"\".$permalink.\"#\\\\1\\\"\", $html);\n    }\n\n    return ($html);\n}\n\n/**\n * Used for clean URL test.\n *\n * @param  array $pretext\n * @access private\n */\n\nfunction show_clean_test($pretext)\n{\n    ob_clean();\n    if (is_array($pretext) && isset($pretext['req'])) {\n        echo md5($pretext['req']).n;\n    }\n\n    if (serverSet('SERVER_ADDR') === serverSet('REMOTE_ADDR')) {\n        var_export($pretext);\n    }\n}\n\n/**\n * Calculates paging.\n *\n * Takes a total number of items, a per page limit and the current page number,\n * and in return returns the page number, an offset and a number of pages.\n *\n * @param  int $total The number of items in total\n * @param  int $limit The number of items per page\n * @param  int $page  The page number\n * @return array Array of page, offset and number of pages.\n * @example\n * list($page, $offset, $num_pages) = pager(150, 10, 1);\n * echo \"Page {$page} of {$num_pages}. Offset is {$offset}.\";\n */\n\nfunction pager($total, $limit, $page)\n{\n    $total = (int) $total;\n    $limit = (int) $limit;\n    $page = (int) $page;\n\n    $num_pages = ceil($total / $limit);\n\n    $page = min(max($page, 1), $num_pages);\n\n    $offset = max(($page - 1) * $limit, 0);\n\n    return array($page, $offset, $num_pages);\n}\n\n/**\n * Word-wrap a string using a zero width space.\n *\n * @param  string $text  The input string\n * @param  int    $width Target line length\n * @param  string $break Is not used\n * @return string\n */\n\nfunction soft_wrap($text, $width, $break = '&#8203;')\n{\n    $wbr = chr(226).chr(128).chr(139);\n    $words = explode(' ', $text);\n\n    foreach ($words as $wordnr => $word) {\n        $word = preg_replace('|([,./\\\\>?!:;@-]+)(?=.)|', '$1 ', $word);\n        $parts = explode(' ', $word);\n\n        foreach ($parts as $partnr => $part) {\n            $len = strlen(utf8_decode($part));\n\n            if (!$len) {\n                continue;\n            }\n\n            $parts[$partnr] = preg_replace('/(.{'.ceil($len/ceil($len/$width)).'})(?=.)/u', '$1'.$wbr, $part);\n        }\n\n        $words[$wordnr] = join($wbr, $parts);\n    }\n\n    return join(' ', $words);\n}\n\n/**\n * Removes prefix from a string.\n *\n * @param  string $str The string\n * @param  string $pfx The prefix\n * @return string\n */\n\nfunction strip_prefix($str, $pfx)\n{\n    return preg_replace('/^'.preg_quote($pfx, '/').'/', '', $str);\n}\n\n/**\n * Sends an XML envelope.\n *\n * Wraps an array of name => value tuples into an XML envelope, supports one\n * level of nested arrays at most.\n *\n * @param   array $response\n * @return  string XML envelope\n * @package XML\n */\n\nfunction send_xml_response($response = array())\n{\n    static $headers_sent = false;\n\n    if (!$headers_sent) {\n        ob_clean();\n        header('Content-Type: text/xml; charset=utf-8');\n        $out[] = '<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>';\n        $headers_sent = true;\n    }\n\n    $default_response = array('http-status' => '200 OK');\n\n    // Backfill default response properties.\n    $response = $response + $default_response;\n\n    txp_status_header($response['http-status']);\n    $out[] = '<textpattern>';\n\n    foreach ($response as $element => $value) {\n        if (is_array($value)) {\n            $out[] = t.\"<$element>\".n;\n\n            foreach ($value as $e => $v) {\n                // Character escaping in values;\n                // @see https://www.w3.org/TR/REC-xml/#sec-references.\n                $v = str_replace(array(\"\\t\", \"\\n\", \"\\r\"), array(\"&#x9;\", \"&#xA;\", \"&#xD;\"), htmlentities($v, ENT_QUOTES, 'UTF-8'));\n                $out[] = t.t.\"<$e value='$v' />\".n;\n            }\n\n            $out[] = t.\"</$element>\".n;\n        } else {\n            $value = str_replace(array(\"\\t\", \"\\n\", \"\\r\"), array(\"&#x9;\", \"&#xA;\", \"&#xD;\"), htmlentities($value, ENT_QUOTES, 'UTF-8'));\n            $out[] = t.\"<$element value='$value' />\".n;\n        }\n    }\n\n    $out[] = '</textpattern>';\n    echo join(n, $out);\n}\n\n/**\n * Sends a text/javascript response.\n *\n * @param   string $out The JavaScript\n * @since   4.4.0\n * @package Ajax\n */\n\nfunction send_script_response($out = '')\n{\n    static $headers_sent = false;\n\n    if (!$headers_sent) {\n        ob_clean();\n        header('Content-Type: text/javascript; charset=utf-8');\n        txp_status_header('200 OK');\n        $headers_sent = true;\n    }\n\n    echo \";\\n\".$out.\";\\n\";\n}\n\n/**\n * Sends an application/json response.\n *\n * If the provided $out is not a string, its encoded as JSON. Any string is\n * treated as it were valid JSON.\n *\n * @param   mixed $out The JSON\n * @since   4.6.0\n * @package Ajax\n */\n\nfunction send_json_response($out = '')\n{\n    static $headers_sent = false;\n\n    if (!$headers_sent) {\n        ob_clean();\n        header('Content-Type: application/json; charset=utf-8');\n        txp_status_header('200 OK');\n        $headers_sent = true;\n    }\n\n    if (!is_string($out)) {\n        $out = json_encode($out, TEXTPATTERN_JSON);\n    }\n\n    echo $out;\n}\n\n/**\n * Performs regular housekeeping.\n *\n * @access private\n */\n\nfunction janitor()\n{\n    global $prefs, $auto_dst, $timezone_key, $is_dst;\n\n    // Update DST setting.\n    if ($auto_dst && $timezone_key) {\n        $is_dst = Txp::get('\\Textpattern\\Date\\Timezone')->isDst(null, $timezone_key);\n\n        if ($is_dst != $prefs['is_dst']) {\n            $prefs['is_dst'] = $is_dst;\n            set_pref('is_dst', $is_dst, 'publish', PREF_HIDDEN);\n        }\n    }\n}\n\n/**\n * Protection from those who'd bomb the site by GET.\n *\n * Origin of the infamous 'Nice try' message and an even more useful '503'\n * HTTP status.\n */\n\nfunction bombShelter()\n{\n    global $prefs;\n    $in = serverSet('REQUEST_URI');\n\n    if (!empty($prefs['max_url_len']) and strlen($in) > $prefs['max_url_len'] + (!empty($_GET['txpcleantest']) ? 48 : 0)) {\n        txp_status_header('503 Service Unavailable');\n        exit('Nice try.');\n    }\n}\n\n/**\n * Test whether the client accepts a certain response format.\n *\n * Discards formats with a quality factor below 0.1\n *\n * @param   string  $format One of 'html', 'txt', 'js', 'css', 'json', 'xml', 'rdf', 'atom', 'rss'\n * @return  boolean $format TRUE if accepted\n * @since   4.5.0\n * @package Network\n */\n\nfunction http_accept_format($format)\n{\n    static $formats = array(\n        'html' => array('text/html', 'application/xhtml+xml', '*/*'),\n        'txt'  => array('text/plain', '*/*'),\n        'js'   => array('application/javascript', 'application/x-javascript', 'text/javascript', 'application/ecmascript', 'application/x-ecmascript', '*/*'),\n        'css'  => array('text/css', '*/*'),\n        'json' => array('application/json', 'application/x-json', '*/*'),\n        'xml'  => array('text/xml', 'application/xml', 'application/x-xml', '*/*'),\n        'rdf'  => array('application/rdf+xml', '*/*'),\n        'atom' => array('application/atom+xml', '*/*'),\n        'rss'  => array('application/rss+xml', '*/*'),\n    );\n    static $accepts = array();\n    static $q = array();\n\n    if (empty($accepts)) {\n        // Build cache of accepted formats.\n        $accepts = preg_split('/\\s*,\\s*/', serverSet('HTTP_ACCEPT'), -1, PREG_SPLIT_NO_EMPTY);\n\n        foreach ($accepts as $i => &$a) {\n            // Sniff out quality factors if present.\n            if (preg_match('/(.*)\\s*;\\s*q=([.0-9]*)/', $a, $m)) {\n                $a = $m[1];\n                $q[$a] = floatval($m[2]);\n            } else {\n                $q[$a] = 1.0;\n            }\n\n            // Discard formats with quality factors below an arbitrary threshold\n            // as jQuery adds a wildcard '*/*; q=0.01' to the 'Accepts' header\n            // for XHR requests.\n            if ($q[$a] < 0.1) {\n                unset($q[$a]);\n                unset($accepts[$i]);\n            }\n        }\n    }\n\n    return isset($formats[$format]) && count(array_intersect($formats[$format], $accepts)) > 0;\n}\n\n/**\n * Return a list of status codes and their associated names.\n *\n * The list can be extended with a 'status.types > types' callback event.\n * Callback functions get passed three arguments: '$event', '$step' and\n * '$status_list'. The third parameter contains a reference to an array of\n * 'status_code => label' pairs.\n *\n * @param   bool  Return the list with L10n labels (for UI purposes) or raw values (for comparisons)\n * @param   array List of status keys (numbers) to exclude\n * @return  array A status array\n * @since   4.6.0\n */\n\nfunction status_list($labels = true, $exclude = array())\n{\n    $status_list = array(\n        STATUS_DRAFT   => 'draft',\n        STATUS_HIDDEN  => 'hidden',\n        STATUS_PENDING => 'pending',\n        STATUS_LIVE    => 'live',\n        STATUS_STICKY  => 'sticky',\n    );\n\n    if (!is_array($exclude)) {\n        $exclude = array();\n    }\n\n    foreach ($exclude as $remove) {\n        unset($status_list[(int) $remove]);\n    }\n\n    callback_event_ref('status.types', 'types', 0, $status_list);\n\n    if ($labels) {\n        $status_list = array_map('gTxt', $status_list);\n    }\n\n    return $status_list;\n}\n\n/**\n * Translates article status names into numerical status codes.\n *\n * @param  string $name    Status name\n * @param  int    $default Status code to return if $name is not a defined status name\n * @return int Matching numerical status\n */\n\nfunction getStatusNum($name, $default = STATUS_LIVE)\n{\n    $statuses = status_list(false);\n    $status = strtolower($name);\n    $num = array_search($status, $statuses);\n\n    if ($num === false) {\n        $num = $default;\n    }\n\n    return (int) $num;\n}\n\n/**\n * Gets the maximum allowed file upload size.\n *\n * Computes the maximum acceptable file size to the application if the\n * user-selected value is larger than the maximum allowed by the current PHP\n * configuration.\n *\n * @param  int $user_max Desired upload size supplied by the administrator\n * @return int Actual value; the lower of user-supplied value or system-defined value\n */\n\nfunction real_max_upload_size($user_max, $php = true)\n{\n    // The minimum of the candidates, is the real max. possible size\n    $candidates = $php ? array($user_max,\n        ini_get('post_max_size'),\n        ini_get('upload_max_filesize')\n    ) : array($user_max);\n    $real_max = null;\n\n    foreach ($candidates as $item) {\n        $val = floatval($item);\n        $modifier = strtolower(substr(trim($item), -1));\n\n        switch ($modifier) {\n            // The 'G' modifier is available since PHP 5.1.0\n            case 'g':\n                $val *= 1024;\n                // no break\n            case 'm':\n                $val *= 1024;\n                // no break\n            case 'k':\n                $val *= 1024;\n        }\n\n        if ($val >= 1) {\n            if (is_null($real_max) || $val < $real_max) {\n                $real_max = floor($val);\n            }\n        }\n    }\n\n    // 2^53 - 1 is max safe JavaScript integer, let 8192Tb\n    return number_format(min($real_max, pow(2, 53) - 1), 0, '.', '');\n}\n\n// -------------------------------------------------------------\n\nfunction txp_match($atts, $what)\n{\n    static $dlmPool = array('/', '@', '#', '~', '`', '|', '!', '%');\n\n    extract($atts + array(\n        'value'     => null,\n        'match'     => 'exact',\n        'separator' => '',\n    ));\n\n\n    if ($value !== null) {\n        switch ($match) {\n            case '<':\n            case 'less':\n                $cond = (is_array($what) ? $what < do_list($value, $separator ? $separator : ',') : $what < $value);\n                break;\n            case '<=':\n                $cond = (is_array($what) ? $what <= do_list($value, $separator ? $separator : ',') : $what <= $value);\n                break;\n            case '>':\n            case 'greater':\n                $cond = (is_array($what) ? $what > do_list($value, $separator ? $separator : ',') : $what > $value);\n                break;\n            case '>=':\n                $cond = (is_array($what) ? $what >= do_list($value, $separator ? $separator : ',') : $what >= $value);\n                break;\n            case '':\n            case 'exact':\n                $cond = (is_array($what) ? $what == do_list($value, $separator ? $separator : ',') : $what == $value);\n                break;\n            case 'any':\n                $values = do_list_unique($value);\n                $cond = false;\n                $cf_contents = $separator && !is_array($what) ? do_list_unique($what, $separator) : $what;\n\n                foreach ($values as $term) {\n                    if (is_array($cf_contents) ? in_array($term, $cf_contents) : strpos($cf_contents, $term) !== false) {\n                        $cond = true;\n                        break;\n                    }\n                }\n                break;\n            case 'all':\n                $values = do_list_unique($value);\n                $cond = true;\n                $cf_contents = $separator && !is_array($what) ? do_list_unique($what, $separator) : $what;\n\n                foreach ($values as $term) {\n                    if (is_array($cf_contents) ? !in_array($term, $cf_contents) : strpos($cf_contents, $term) === false) {\n                        $cond = false;\n                        break;\n                    }\n                }\n                break;\n            case 'pattern':\n                // Cannot guarantee that a fixed delimiter won't break preg_match\n                // (and preg_quote doesn't help) so dynamically assign the delimiter\n                // based on the first entry in $dlmPool that is NOT in the value\n                // attribute. This minimises (does not eliminate) the possibility\n                // of a TXP-initiated preg_match error, while still preserving\n                // errors outside TXP's control (e.g. mangled user-submitted\n                // PCRE pattern).\n                if ($separator === true) {\n                    $dlm = $value;\n                } elseif ($separator && in_array($separator, $dlmPool)) {\n                    $dlm = strpos($value, $separator) === 0 ? $value : $separator.$value.$separator;\n                } else {\n                    $dlm = array_diff($dlmPool, preg_split('//', $value));\n                    $dlm = reset($dlm);\n                    $dlm = $dlm.$value.$dlm;\n                }\n\n                $cond = preg_match($dlm, is_array($what) ? implode('', $what) : $what);\n                break;\n            default:\n                trigger_error(gTxt('invalid_attribute_value', array('{name}' => 'match')), E_USER_NOTICE);\n                $cond = false;\n        }\n    } else {\n        $cond = ($what !== null);\n    }\n\n    return !empty($cond);\n}\n\n// -------------------------------------------------------------\n\nfunction txp_break($wraptag)\n{\n    switch (strtolower($wraptag)) {\n        case 'ul':\n        case 'ol':\n            return 'li';\n        case 'p':\n            return 'br';\n        case 'table':\n        case 'tbody':\n        case 'thead':\n        case 'tfoot':\n            return 'tr';\n        case 'tr':\n            return 'td';\n        default:\n            return ',';\n    }\n}\n\n// -------------------------------------------------------------\n\nfunction txp_hash($thing)\n{\n    return strlen($thing) < TEXTPATTERN_HASH_LENGTH ? $thing : hash(TEXTPATTERN_HASH_ALGO, $thing);\n}\n\n/*** Polyfills ***/\n\nif (!function_exists('array_column')) {\n    include txpath.'/lib/array_column.php';\n}\n"], "fixing_code": ["<?php\n\n/*\n * Textpattern Content Management System\n * https://textpattern.com/\n *\n * Copyright (C) 2021 The Textpattern Development Team\n *\n * This file is part of Textpattern.\n *\n * Textpattern is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation, version 2.\n *\n * Textpattern is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Textpattern. If not, see <https://www.gnu.org/licenses/>.\n */\n\n/**\n * Collection of miscellaneous tools.\n *\n * @package Misc\n */\n\n/**\n * Strips NULL bytes.\n *\n * @param  string|array $in The input value\n * @return mixed\n */\n\nfunction deNull($in)\n{\n    return is_array($in) ? doArray($in, 'deNull') : strtr($in, array(\"\\0\" => ''));\n}\n\n/**\n * Strips carriage returns and linefeeds.\n *\n * @param  string|array $in The input value\n * @return mixed\n */\n\nfunction deCRLF($in)\n{\n    return is_array($in) ? doArray($in, 'deCRLF') : strtr($in, array(\n        \"\\n\" => '',\n        \"\\r\" => '',\n    ));\n}\n\n/**\n * Applies a callback to a given string or an array.\n *\n * @param  string|array $in       An array or a string to run through the callback function\n * @param  callback     $function The callback function\n * @return mixed\n * @example\n * echo doArray(array('value1', 'value2'), 'intval');\n */\n\nfunction doArray($in, $function)\n{\n    if (is_array($in)) {\n        return array_map($function, $in);\n    }\n\n    if (is_array($function)) {\n        return call_user_func($function, $in);\n    }\n\n    return $function($in);\n}\n\n/**\n * Un-quotes a quoted string or an array of values.\n *\n * @param  string|array $in The input value\n * @return mixed\n */\n\nfunction doStrip($in)\n{\n    return is_array($in) ? doArray($in, 'doStrip') : doArray($in, 'stripslashes');\n}\n\n/**\n * Strips HTML and PHP tags from a string or an array.\n *\n * @param  string|array $in The input value\n * @return mixed\n * @example\n * echo doStripTags('<p>Hello world!</p>');\n */\n\nfunction doStripTags($in)\n{\n    return is_array($in) ? doArray($in, 'doStripTags') : doArray($in, 'strip_tags');\n}\n\n/**\n * Converts entity escaped brackets back to characters.\n *\n * @param  string|array $in The input value\n * @return mixed\n */\n\nfunction doDeEnt($in)\n{\n    return doArray($in, 'deEntBrackets');\n}\n\n/**\n * Converts entity escaped brackets back to characters.\n *\n * @param  string $in The input value\n * @return string\n */\n\nfunction deEntBrackets($in)\n{\n    $array = array(\n        '&#60;'  => '<',\n        '&lt;'   => '<',\n        '&#x3C;' => '<',\n        '&#62;'  => '>',\n        '&gt;'   => '>',\n        '&#x3E;' => '>',\n    );\n\n    foreach ($array as $k => $v) {\n        $in = preg_replace(\"/\".preg_quote($k).\"/i\", $v, $in);\n    }\n\n    return $in;\n}\n\n/**\n * Escapes special characters for use in an SQL statement.\n *\n * Always use this function when dealing with user-defined values in SQL\n * statements. If this function is not used to escape user-defined data in a\n * statement, the query is vulnerable to SQL injection attacks.\n *\n * @param   string|array $in The input value\n * @return  mixed An array of escaped values or a string depending on $in\n * @package DB\n * @example\n * echo safe_field('column', 'table', \"color = '\" . doSlash(gps('color')) . \"'\");\n */\n\nfunction doSlash($in)\n{\n    return doArray($in, 'safe_escape');\n}\n\n/**\n * Escape SQL LIKE pattern's wildcards for use in an SQL statement.\n *\n * @param   string|array $in The input value\n * @return  mixed An array of escaped values or a string depending on $in\n * @since   4.6.0\n * @package DB\n * @example\n * echo safe_field('column', 'table', \"color LIKE '\" . doLike(gps('color')) . \"'\");\n */\n\nfunction doLike($in)\n{\n    return doArray($in, 'safe_escape_like');\n}\n\n/**\n * A shell for htmlspecialchars() with $flags defaulting to ENT_QUOTES.\n *\n * @param   string $string The string being converted\n * @param   int    $flags A bitmask of one or more flags. The default is ENT_QUOTES\n * @param   string $encoding Defines encoding used in conversion. The default is UTF-8\n * @param   bool   $double_encode When double_encode is turned off PHP will not encode existing HTML entities, the default is to convert everything\n * @return  string\n * @see     https://www.php.net/manual/en/function.htmlspecialchars.php\n * @since   4.5.0\n * @package Filter\n */\n\nfunction txpspecialchars($string, $flags = ENT_QUOTES, $encoding = 'UTF-8', $double_encode = true)\n{\n    //    Ignore ENT_HTML5 and ENT_XHTML for now.\n    //    ENT_HTML5 and ENT_XHTML are defined in PHP 5.4+ but we consistently encode single quotes as &#039; in any doctype.\n    //    global $prefs;\n    //    static $h5 = null;\n    //\n    //    if (defined(ENT_HTML5)) {\n    //        if ($h5 === null) {\n    //            $h5 = ($prefs['doctype'] == 'html5' && txpinterface == 'public');\n    //        }\n    //\n    //        if ($h5) {\n    //            $flags = ($flags | ENT_HTML5) & ~ENT_HTML401;\n    //        }\n    //    }\n    //\n    return htmlspecialchars((string)$string, $flags, $encoding, $double_encode);\n}\n\n/**\n * Converts special characters to HTML entities.\n *\n * @param   array|string $in The input value\n * @return  mixed The array or string with HTML syntax characters escaped\n * @package Filter\n */\n\nfunction doSpecial($in)\n{\n    return doArray($in, 'txpspecialchars');\n}\n\n/**\n * Converts the given value to NULL.\n *\n * @param   mixed $a The input value\n * @return  null\n * @package Filter\n * @access  private\n */\n\nfunction _null($a)\n{\n    return null;\n}\n\n/**\n * Converts an array of values to NULL.\n *\n * @param   array $in The array\n * @return  array\n * @package Filter\n */\n\nfunction array_null($in)\n{\n    return array_map('_null', $in);\n}\n\n/**\n * Escapes a page title. Converts &lt;, &gt;, ', \" characters to HTML entities.\n *\n * @param   string $title The input string\n * @return  string The string escaped\n * @package Filter\n */\n\nfunction escape_title($title)\n{\n    return strtr($title, array(\n        '<' => '&#60;',\n        '>' => '&#62;',\n        \"'\" => '&#39;',\n        '\"' => '&#34;',\n    ));\n}\n\n/**\n * Sanitises a string for use in a JavaScript string.\n *\n * Escapes \\, \\n, \\r, \" and ' characters. It removes 'PARAGRAPH SEPARATOR'\n * (U+2029) and 'LINE SEPARATOR' (U+2028). When you need to pass a string\n * from PHP to JavaScript, use this function to sanitise the value to avoid\n * XSS attempts.\n *\n * @param   string $js JavaScript input\n * @return  string Escaped JavaScript\n * @since   4.4.0\n * @package Filter\n */\n\nfunction escape_js($js)\n{\n    $js = preg_replace('/[\\x{2028}\\x{2029}]/u', '', $js);\n\n    return addcslashes($js, \"\\\\\\'\\\"\\n\\r\");\n}\n\n/**\n * Escapes CDATA section for an XML document.\n *\n * @param   string $str The string\n * @return  string XML representation wrapped in CDATA tags\n * @package XML\n */\n\nfunction escape_cdata($str)\n{\n    return '<![CDATA['.str_replace(']]>', ']]]><![CDATA[]>', $str).']]>';\n}\n\n/**\n * Returns a localisation string.\n *\n * @param   string $var    String name\n * @param   array  $atts   Replacement pairs\n * @param   string $escape Convert special characters to HTML entities. Either \"html\" or \"\"\n * @return  string A localisation string\n * @package L10n\n */\n\nfunction gTxt($var, $atts = array(), $escape = 'html')\n{\n    global $event, $plugin, $txp_current_plugin;\n    static $txpLang = null;\n\n    if ($txpLang === null) {\n        $txpLang = Txp::get('\\Textpattern\\L10n\\Lang');\n        $lang = txpinterface == 'admin' ? get_pref('language_ui', gps('lang', LANG)) : LANG;\n        $loaded = $txpLang->load($lang, true);\n        $evt = isset($event) ? trim($event) : '';\n\n        if (empty($loaded) || !in_array($evt, $loaded)) {\n            load_lang($lang, $evt);\n        }\n    }\n\n    // Hackish\n    if (isset($txp_current_plugin) && isset($plugin['textpack'])) {\n        $txpLang->loadTextpack($plugin['textpack']);\n        unset($plugin['textpack']);\n    }\n\n    return $txpLang->txt($var, $atts, $escape);\n}\n\n/**\n * Returns given timestamp in a format of 01 Jan 2001 15:19:16.\n *\n * @param   int $timestamp The UNIX timestamp\n * @return  string A formatted date\n * @access  private\n * @see     safe_stftime()\n * @package DateTime\n * @example\n * echo gTime();\n */\n\nfunction gTime($timestamp = 0)\n{\n    return safe_strftime('%d&#160;%b&#160;%Y %X', $timestamp);\n}\n\n/**\n * Creates a dumpfile from a backtrace and outputs given parameters.\n *\n * @package Debug\n */\n\nfunction dmp()\n{\n    static $f = false;\n\n    if (defined('txpdmpfile')) {\n        global $prefs;\n\n        if (!$f) {\n            $f = fopen($prefs['tempdir'].'/'.txpdmpfile, 'a');\n        }\n\n        $stack = get_caller();\n        fwrite($f, \"\\n[\".$stack[0].t.safe_strftime('iso8601').\"]\\n\");\n    }\n\n    $a = func_get_args();\n\n    if (!$f) {\n        echo \"<pre dir=\\\"auto\\\">\".n;\n    }\n\n    foreach ($a as $thing) {\n        $out = is_scalar($thing) ? strval($thing) : var_export($thing, true);\n\n        if ($f) {\n            fwrite($f, $out.n);\n        } else {\n            echo txpspecialchars($out).n;\n        }\n    }\n\n    if (!$f) {\n        echo \"</pre>\".n;\n    }\n}\n\n/**\n * Gets the given language's strings from the database.\n *\n * Fetches the given language from the database and returns the strings\n * as an array.\n *\n * If no $events is specified, only appropriate strings for the current context\n * are returned. If 'txpinterface' constant equals 'admin' all strings are\n * returned. Otherwise, only strings from events 'common' and 'public'.\n *\n * If $events is FALSE, returns all strings.\n *\n * @param   string            $lang   The language code\n * @param   array|string|bool $events An array of loaded events\n * @return  array\n * @package L10n\n * @example\n * print_r(\n *     load_lang('en-gb', false)\n * );\n */\n\nfunction load_lang($lang, $events = null)\n{\n    global $production_status, $event, $textarray;\n\n    isset($textarray) or $textarray = array();\n    $textarray = array_merge($textarray, Txp::get('\\Textpattern\\L10n\\Lang')->load($lang, $events));\n\n    if (($production_status !== 'live' || $event === 'diag')\n        && @$debug = parse_ini_file(txpath.DS.'mode.ini')\n    ) {\n        $textarray += (array)$debug;\n        Txp::get('\\Textpattern\\L10n\\Lang')->setPack($textarray);\n    }\n\n    return $textarray;\n}\n\n/**\n * Gets a list of user groups.\n *\n * @return  array\n * @package User\n * @example\n * print_r(\n *     get_groups()\n * );\n */\n\nfunction get_groups()\n{\n    global $txp_groups;\n\n    return doArray($txp_groups, 'gTxt');\n}\n\n/**\n * Checks if a user has privileges to the given resource.\n *\n * @param   string $res  The resource\n * @param   mixed  $user The user. If no user name is supplied, assume the current logged in user\n * @return  bool\n * @package User\n * @example\n * add_privs('my_privilege_resource', '1,2,3');\n * if (has_privs('my_privilege_resource', 'username'))\n * {\n *     echo \"'username' has privileges to 'my_privilege_resource'.\";\n * }\n */\n\nfunction has_privs($res = null, $user = '')\n{\n    global $txp_user, $txp_permissions;\n    static $privs;\n\n    if (is_array($user)) {\n        $level = isset($user['privs']) ? $user['privs'] : null;\n        $user = isset($user['name']) ? $user['name'] : '';\n    }\n\n    $user = (string) $user;\n\n    if ($user === '') {\n        $user = (string) $txp_user;\n    }\n\n    if ($user !== '') {\n        if (!isset($privs[$user])) {\n            $privs[$user] = isset($level) ?\n                $level :\n                safe_field(\"privs\", 'txp_users', \"name = '\".doSlash($user).\"'\");\n        }\n\n        if (!isset($res)) {\n            return $privs[$user];\n        } elseif (isset($txp_permissions[$res]) && $privs[$user] && $txp_permissions[$res]) {\n            return in_list($privs[$user], $txp_permissions[$res]);\n        }\n    }\n\n    return false;\n}\n\n/**\n * Adds dynamic privileges.\n *\n * @param   array $pluggable The array, see global $txp_options\n * @since   4.7.2\n * @package User\n */\n\nfunction plug_privs($pluggable = null, $user = null)\n{\n    global $txp_options;\n\n    isset($pluggable) or $pluggable = $txp_options;\n    $level = isset($user['privs']) ? $user['privs'] : has_privs();\n\n    foreach ((array)$pluggable as $pref => $pane) {\n        if (is_array($pane)) {\n            if (isset($pane[0])) {\n                if (!in_list($level, $pane[0])) {\n                    break;\n                }\n\n                unset($pane[0]);\n            }\n        } else {\n            $pane = array('prefs.'.$pref => $pane);\n        }\n\n        if (get_pref($pref)) {\n            array_walk($pane, function (&$item) use ($level) {\n                if ($item === true) {\n                    $item = $level;\n                }\n            });\n            add_privs($pane);\n        } else {\n            add_privs(array_fill_keys(array_keys($pane), null));\n        }\n    }\n}\n\n/**\n * Grants privileges to user-groups.\n *\n * Will not let you override existing privs.\n *\n * @param   mixed  $res  The resource\n * @param   string $perm List of user-groups, e.g. '1,2,3'\n * @package User\n * @example\n * add_privs('my_admin_side_panel_event', '1,2,3,4,5');\n */\n\nfunction add_privs($res, $perm = '1')\n{\n    global $txp_permissions;\n\n    if (!is_array($res)) {\n        $res = array($res => $perm);\n    }\n\n    foreach ($res as $priv => $group) {\n        if ($group === null) {\n            $txp_permissions[$priv] = null;\n        } else {\n            $group .= (empty($txp_permissions[$priv]) ? '' : ','.$txp_permissions[$priv]);\n            $group = join(',', do_list_unique($group));\n            $txp_permissions[$priv] = $group;\n        }\n    }\n}\n\n/**\n * Require privileges from a user to the given resource.\n *\n * Terminates the script if user doesn't have required privileges.\n *\n * @param   string|null $res  The resource, or NULL\n * @param   string      $user The user. If no user name is supplied, assume the current logged in user\n * @package User\n * @example\n * require_privs('article.edit');\n */\n\nfunction require_privs($res = null, $user = '')\n{\n    if ($res === null || !has_privs($res, $user)) {\n        pagetop(gTxt('restricted_area'));\n        echo graf(gTxt('restricted_area'), array('class' => 'restricted-area'));\n        end_page();\n        exit;\n    }\n}\n\n/**\n * Gets a list of users having access to a resource.\n *\n * @param   string $res The resource, e.g. 'article.edit.published'\n * @return  array  A list of usernames\n * @since   4.5.0\n * @package User\n */\n\nfunction the_privileged($res, $real = false)\n{\n    global $txp_permissions;\n\n    $out = array();\n\n    if (isset($txp_permissions[$res])) {\n        foreach (safe_rows(\"name, RealName\", 'txp_users', \"FIND_IN_SET(privs, '\".$txp_permissions[$res].\"') ORDER BY \".($real ? \"RealName\" : \"name\").\" ASC\") as $user) {\n            extract($user);\n            $out[$name] = $real ? $RealName : $name;\n        }\n    }\n\n    return $out;\n}\n\n/**\n * Lists image types that can be safely uploaded.\n *\n * Returns different results based on the logged in user's privileges.\n *\n * @param   int         $type If set, validates the given value\n * @return  mixed\n * @package Image\n * @since   4.6.0\n * @example\n * list($width, $height, $extension) = getimagesize('image');\n * if ($type = get_safe_image_types($extension))\n * {\n *     echo \"Valid image of {$type}.\";\n * }\n */\n\nfunction get_safe_image_types($type = null)\n{\n    $extensions = array(IMAGETYPE_GIF => '.gif', 0 => '.jpeg', IMAGETYPE_JPEG => '.jpg', IMAGETYPE_PNG => '.png') +\n        (defined('IMAGETYPE_WEBP') ? array(IMAGETYPE_WEBP => '.webp') : array());\n\n    if (has_privs('image.create.trusted')) {\n        $extensions += array(IMAGETYPE_SWF => '.swf', IMAGETYPE_SWC => '.swf');\n    }\n\n    callback_event_ref('txp.image', 'types', 0, $extensions);\n\n    if (isset($type)) {\n        return !empty($extensions[$type]) ? $extensions[$type] : false;\n    }\n\n    return $extensions;\n}\n\n\n/**\n * Gets the dimensions of an image for a HTML &lt;img&gt; tag.\n *\n * @param   string      $name The filename\n * @return  string|bool height=\"100\" width=\"40\", or FALSE on failure\n * @package Image\n * @example\n * if ($size = sizeImage('/path/to/image.png'))\n * {\n *     echo \"&lt;img src='image.png' {$size} /&gt;\";\n * }\n */\n\nfunction sizeImage($name)\n{\n    $size = @getimagesize($name);\n\n    return is_array($size) ? $size[3] : false;\n}\n\n/**\n * Gets an image as an array.\n *\n * @param   int $id image ID\n * @param   string $name image name\n * @return  array|bool An image data array, or FALSE on failure\n * @package Image\n * @example\n * if ($image = imageFetchInfo($id))\n * {\n *     print_r($image);\n * }\n */\n\nfunction imageFetchInfo($id = \"\", $name = \"\")\n{\n    global $thisimage, $p;\n    static $cache = array();\n\n    if ($id) {\n        if (isset($cache['i'][$id])) {\n            return $cache['i'][$id];\n        } else {\n            $where = 'id = '.intval($id).' LIMIT 1';\n        }\n    } elseif ($name) {\n        if (isset($cache['n'][$name])) {\n            return $cache['n'][$name];\n        } else {\n            $where = \"name = '\".doSlash($name).\"' LIMIT 1\";\n        }\n    } elseif ($thisimage) {\n        $id = (int) $thisimage['id'];\n        return $cache['i'][$id] = $thisimage;\n    } elseif ($p) {\n        if (isset($cache['i'][$p])) {\n            return $cache['i'][$p];\n        } else {\n            $where = 'id = '.intval($p).' LIMIT 1';\n        }\n    } else {\n        assert_image();\n        return false;\n    }\n\n    $rs = safe_row(\"*\", 'txp_image', $where);\n\n    if ($rs) {\n        $id = (int) $rs['id'];\n        return $cache['i'][$id] = image_format_info($rs);\n    } else {\n        trigger_error(gTxt('unknown_image'));\n    }\n\n    return false;\n}\n\n/**\n * Formats image info.\n *\n * Takes an image data array generated by imageFetchInfo() and formats the contents.\n *\n * @param   array $image The image\n * @return  array\n * @see     imageFetchInfo()\n * @access  private\n * @package Image\n */\n\nfunction image_format_info($image)\n{\n    static $mimetypes;\n\n    if (($unix_ts = @strtotime($image['date'])) > 0) {\n        $image['date'] = $unix_ts;\n    }\n\n    if (!isset($mimetypes)) {\n        $mimetypes = get_safe_image_types();\n    }\n\n    $image['mime'] = ($mime = array_search($image['ext'], $mimetypes)) !== false ? image_type_to_mime_type($mime) : '';\n\n    return $image;\n}\n\n/**\n * Formats link info.\n *\n * @param   array $link The link to format\n * @return  array Formatted link data\n * @access  private\n * @package Link\n */\n\nfunction link_format_info($link)\n{\n    if (($unix_ts = @strtotime($link['date'])) > 0) {\n        $link['date'] = $unix_ts;\n    }\n\n    return $link;\n}\n\n/**\n * Gets a HTTP GET or POST parameter.\n *\n * Internally strips CRLF from GET parameters and removes NULL bytes.\n *\n * @param   string $thing The parameter to get\n * @return  string|array The value of $thing, or an empty string\n * @package Network\n * @example\n * if (gps('sky') == 'blue' && gps('roses') == 'red')\n * {\n *     echo 'Roses are red, sky is blue.';\n * }\n */\n\nfunction gps($thing, $default = '')\n{\n    global $pretext;\n\n    if (isset($_GET[$thing])) {\n        $out = $_GET[$thing];\n        $out = doArray($out, 'deCRLF');\n    } elseif (isset($_POST[$thing])) {\n        $out = $_POST[$thing];\n    } elseif (is_numeric($thing) && isset($pretext[abs($thing)])) {\n        $thing >= 0 or $thing += $pretext[0] + 1;\n        $out = $pretext[$thing];\n    } else {\n        return $default;\n    }\n\n    $out = doArray($out, 'deNull');\n\n    return $out;\n}\n\n/**\n * Gets an array of HTTP GET or POST parameters.\n *\n * @param   array $array The parameters to extract\n * @return  array\n * @package Network\n * @example\n * extract(gpsa(array('sky', 'roses'));\n * if ($sky == 'blue' && $roses == 'red')\n * {\n *     echo 'Roses are red, sky is blue.';\n * }\n */\n\nfunction gpsa($array)\n{\n    if (is_array($array)) {\n        $out = array();\n\n        foreach ($array as $a) {\n            $out[$a] = gps($a);\n        }\n\n        return $out;\n    }\n\n    return false;\n}\n\n/**\n * Gets a HTTP POST parameter.\n *\n * Internally removes NULL bytes.\n *\n * @param   string $thing The parameter to get\n * @return  string|array The value of $thing, or an empty string\n * @package Network\n * @example\n * if (ps('sky') == 'blue' && ps('roses') == 'red')\n * {\n *     echo 'Roses are red, sky is blue.';\n * }\n */\n\nfunction ps($thing)\n{\n    $out = '';\n\n    if (isset($_POST[$thing])) {\n        $out = $_POST[$thing];\n    }\n\n    $out = doArray($out, 'deNull');\n\n    return $out;\n}\n\n/**\n * Gets an array of HTTP POST parameters.\n *\n * @param   array $array The parameters to extract\n * @return  array\n * @package Network\n * @example\n * extract(psa(array('sky', 'roses'));\n * if ($sky == 'blue' && $roses == 'red')\n * {\n *     echo 'Roses are red, sky is blue.';\n * }\n */\n\nfunction psa($array)\n{\n    foreach ($array as $a) {\n        $out[$a] = ps($a);\n    }\n\n    return $out;\n}\n\n/**\n * Gets an array of HTTP POST parameters and strips HTML and PHP tags\n * from values.\n *\n * @param   array $array The parameters to extract\n * @return  array\n * @package Network\n */\n\nfunction psas($array)\n{\n    foreach ($array as $a) {\n        $out[$a] = doStripTags(ps($a));\n    }\n\n    return $out;\n}\n\n/**\n * Gets all received HTTP POST parameters.\n *\n * @return  array\n * @package Network\n */\n\nfunction stripPost()\n{\n    if (isset($_POST)) {\n        return $_POST;\n    }\n\n    return '';\n}\n\n/**\n * Gets a variable from $_SERVER global array.\n *\n * @param   mixed $thing The variable\n * @return  mixed The variable, or an empty string on error\n * @package System\n * @example\n * echo serverSet('HTTP_USER_AGENT');\n */\n\nfunction serverSet($thing)\n{\n    return (isset($_SERVER[$thing])) ? $_SERVER[$thing] : '';\n}\n\n/**\n * Gets the client's IP address.\n *\n * Supports proxies and uses 'X_FORWARDED_FOR' HTTP header if deemed necessary.\n *\n * @return  string\n * @package Network\n * @example\n * if ($ip = remote_addr())\n * {\n *     echo \"Your IP address is: {$ip}.\";\n * }\n */\n\nfunction remote_addr()\n{\n    $ip = serverSet('REMOTE_ADDR');\n\n    if (($ip == '127.0.0.1' || $ip == '::1' || $ip == '::ffff:127.0.0.1' || $ip == serverSet('SERVER_ADDR')) && serverSet('HTTP_X_FORWARDED_FOR')) {\n        $ips = explode(', ', serverSet('HTTP_X_FORWARDED_FOR'));\n        $ip = $ips[0];\n    }\n\n    return $ip;\n}\n\n/**\n * Gets a variable from HTTP POST or a prefixed cookie.\n *\n * Fetches either a HTTP cookie of the given name prefixed with\n * 'txp_', or a HTTP POST parameter without a prefix.\n *\n * @param   string $thing The variable\n * @return  array|string The variable or an empty string\n * @package Network\n * @example\n * if ($cs = psc('myVariable'))\n * {\n *     echo \"'txp_myVariable' cookie or 'myVariable' POST parameter contained: '{$cs}'.\";\n * }\n */\n\nfunction pcs($thing)\n{\n    if (isset($_COOKIE[\"txp_\".$thing])) {\n        return $_COOKIE[\"txp_\".$thing];\n    } elseif (isset($_POST[$thing])) {\n        return $_POST[$thing];\n    }\n\n    return '';\n}\n\n/**\n * Gets a HTTP cookie.\n *\n * @param   string $thing The cookie\n * @return  string The cookie or an empty string\n * @package Network\n * @example\n * if ($cs = cs('myVariable'))\n * {\n *     echo \"'myVariable' cookie contained: '{$cs}'.\";\n * }\n */\n\nfunction cs($thing)\n{\n    if (isset($_COOKIE[$thing])) {\n        return $_COOKIE[$thing];\n    }\n\n    return '';\n}\n\n/**\n * Sets a HTTP cookie (polyfill).\n *\n * @param   string $name The cookie name\n * @param   string $value The cookie value\n * @param   array  $options The cookie options\n * @package Network\n */\n\nfunction set_cookie($name, $value = '', $options = array())\n{\n    $options += array (\n        'expires' => time() - 3600,\n        'path' => '',\n        'domain' => '',\n        'secure' => strtolower(PROTOCOL) == 'https://',\n        'httponly' => false,\n        'samesite' => 'Lax' // None || Lax  || Strict\n    );\n\n    if (version_compare(phpversion(), '7.3.0') >= 0) {\n        return setcookie($name, $value, $options);\n    }\n\n    extract($options);\n\n    return setcookie($name, $value, $expires, $path.'; samesite='.$samesite, $domain, $secure, $httponly);\n}\n\n/**\n * Converts a boolean to a localised \"Yes\" or \"No\" string.\n *\n * @param   bool $status The boolean. Ignores type and as such can also take a string or an integer\n * @return  string No if FALSE, Yes otherwise\n * @package L10n\n * @example\n * echo yes_no(3 * 3 === 2);\n */\n\nfunction yes_no($status)\n{\n    return ($status) ? gTxt('yes') : gTxt('no');\n}\n\n/**\n * Gets UNIX timestamp with microseconds.\n *\n * @return  float\n * @package DateTime\n * @example\n * echo getmicrotime();\n */\n\nfunction getmicrotime()\n{\n    list($usec, $sec) = explode(\" \", microtime());\n\n    return ((float) $usec + (float) $sec);\n}\n\n/**\n * Loads the given plugin or checks if it was loaded.\n *\n * @param  string $name  The plugin\n * @param  bool   $force If TRUE loads the plugin even if it's disabled\n * @return bool TRUE if the plugin is loaded\n * @example\n * if (load_plugin('abc_plugin'))\n * {\n *     echo \"'abc_plugin' is active.\";\n * }\n */\n\nfunction load_plugin($name, $force = false)\n{\n    global $plugin, $plugins, $plugins_ver, $prefs, $txp_current_plugin, $textarray;\n\n    if (is_array($plugins) && in_array($name, $plugins)) {\n        return true;\n    }\n\n    if (!empty($prefs['plugin_cache_dir'])) {\n        $dir = rtrim($prefs['plugin_cache_dir'], '/').'/';\n\n        // In case it's a relative path.\n        if (!is_dir($dir)) {\n            $dir = rtrim(realpath(txpath.'/'.$dir), '/').'/';\n        }\n\n        if (is_file($dir.$name.'.php')) {\n            $plugins[] = $name;\n            $old_plugin = isset($plugin) ? $plugin : null;\n            set_error_handler(\"pluginErrorHandler\");\n\n            if (isset($txp_current_plugin)) {\n                $txp_parent_plugin = $txp_current_plugin;\n            }\n\n            $txp_current_plugin = $name;\n            include $dir.$name.'.php';\n            $txp_current_plugin = isset($txp_parent_plugin) ? $txp_parent_plugin : null;\n            $plugins_ver[$name] = isset($plugin['version']) ? $plugin['version'] : 0;\n\n            if (isset($plugin['textpack'])) {\n                Txp::get('\\Textpattern\\L10n\\Lang')->loadTextpack($plugin['textpack']);\n            }\n\n            restore_error_handler();\n            $plugin = $old_plugin;\n\n            return true;\n        }\n    }\n\n    $version = safe_field(\"version\", 'txp_plugin', ($force ? '' : \"status = 1 AND \").\"name = '\".doSlash($name).\"'\");\n\n    if ($version !== false) {\n        $plugins[] = $name;\n        $plugins_ver[$name] = $version;\n        set_error_handler(\"pluginErrorHandler\");\n\n        if (isset($txp_current_plugin)) {\n            $txp_parent_plugin = $txp_current_plugin;\n        }\n\n        $txp_current_plugin = $name;\n        $dir = sanitizeForFile($name);\n        $filename = PLUGINPATH.DS.$dir.DS.$dir.'.php';\n\n        if (!is_file($filename)) {\n            $code = safe_field(\"code\", 'txp_plugin', \"name = '\".doSlash($name).\"'\");\n            \\Txp::get('\\Textpattern\\Plugin\\Plugin')->updateFile($txp_current_plugin, $code);\n        }\n\n        $ok = is_readable($filename) ? include_once($filename) : false;\n        $txp_current_plugin = isset($txp_parent_plugin) ? $txp_parent_plugin : null;\n        restore_error_handler();\n\n        return $ok;\n    }\n\n    return false;\n}\n\n/**\n * Loads a plugin.\n *\n * Identical to load_plugin() except upon failure it issues an E_USER_ERROR.\n *\n * @param  string $name The plugin\n * @return bool\n * @see    load_plugin()\n */\n\nfunction require_plugin($name)\n{\n    if (!load_plugin($name)) {\n        trigger_error(gTxt('plugin_include_error', array('{name}' => $name)), E_USER_ERROR);\n\n        return false;\n    }\n\n    return true;\n}\n\n/**\n * Loads a plugin.\n *\n * Identical to load_plugin() except upon failure it issues an E_USER_WARNING.\n *\n * @param  string $name The plugin\n * @return bool\n * @see    load_plugin()\n */\n\nfunction include_plugin($name)\n{\n    if (!load_plugin($name)) {\n        trigger_error(gTxt('plugin_include_error', array('{name}' => $name)), E_USER_WARNING);\n\n        return false;\n    }\n\n    return true;\n}\n\n/**\n * Error handler for plugins.\n *\n * @param   int    $errno\n * @param   string $errstr\n * @param   string $errfile\n * @param   int    $errline\n * @access  private\n * @package Debug\n */\n\nfunction pluginErrorHandler($errno, $errstr, $errfile, $errline)\n{\n    global $production_status, $txp_current_plugin, $plugins_ver;\n\n    $error = array();\n\n    if ($production_status == 'testing') {\n        $error = array(\n            E_WARNING           => 'Warning',\n            E_RECOVERABLE_ERROR => 'Catchable fatal error',\n            E_USER_ERROR        => 'User_Error',\n            E_USER_WARNING      => 'User_Warning',\n        );\n    } elseif ($production_status == 'debug') {\n        $error = array(\n            E_WARNING           => 'Warning',\n            E_NOTICE            => 'Notice',\n            E_RECOVERABLE_ERROR => 'Catchable fatal error',\n            E_USER_ERROR        => 'User_Error',\n            E_USER_WARNING      => 'User_Warning',\n            E_USER_NOTICE       => 'User_Notice',\n        );\n\n        if (!isset($error[$errno])) {\n            $error[$errno] = $errno;\n        }\n    }\n\n    if (!isset($error[$errno]) || !error_reporting()) {\n        return;\n    }\n\n    $version = empty($plugins_ver[$txp_current_plugin]) ? '' : ' ('.$plugins_ver[$txp_current_plugin].')';\n\n    printf(\n        '<pre dir=\"auto\">'.gTxt('plugin_load_error').' <b>%s%s</b> -> <b>%s: %s on line %s</b></pre>',\n        $txp_current_plugin,\n        $version,\n        $error[$errno],\n        $errstr,\n        $errline\n    );\n\n    if ($production_status == 'debug') {\n        print \"\\n<pre class=\\\"backtrace\\\" dir=\\\"ltr\\\"><code>\".txpspecialchars(join(\"\\n\", get_caller(10))).\"</code></pre>\";\n    }\n}\n\n/**\n * Error handler for page templates.\n *\n * @param   int    $errno\n * @param   string $errstr\n * @param   string $errfile\n * @param   int    $errline\n * @access  private\n * @package Debug\n */\n\nfunction tagErrorHandler($errno, $errstr, $errfile, $errline)\n{\n    global $production_status, $txp_current_tag, $txp_current_form, $pretext, $trace;\n\n    $error = array();\n\n    if ($production_status == 'testing') {\n        $error = array(\n            E_WARNING           => 'Warning',\n            E_RECOVERABLE_ERROR => 'Textpattern Catchable fatal error',\n            E_USER_ERROR        => 'Textpattern Error',\n            E_USER_WARNING      => 'Textpattern Warning',\n        );\n    } elseif ($production_status == 'debug') {\n        $error = array(\n            E_WARNING           => 'Warning',\n            E_NOTICE            => 'Notice',\n            E_RECOVERABLE_ERROR => 'Textpattern Catchable fatal error',\n            E_USER_ERROR        => 'Textpattern Error',\n            E_USER_WARNING      => 'Textpattern Warning',\n            E_USER_NOTICE       => 'Textpattern Notice',\n        );\n\n        if (!isset($error[$errno])) {\n            $error[$errno] = $errno;\n        }\n    }\n\n    if (!isset($error[$errno]) || !error_reporting()) {\n        return;\n    }\n\n    if (empty($pretext['page'])) {\n        $page = gTxt('none');\n    } else {\n        $page = $pretext['page'];\n    }\n\n    if (!isset($txp_current_form)) {\n        $txp_current_form = gTxt('none');\n    }\n\n    $locus = gTxt('while_parsing_page_form', array(\n        '{page}' => $page,\n        '{form}' => $txp_current_form,\n    ));\n\n    printf(\n        \"<pre dir=\\\"auto\\\">\".gTxt('tag_error').' <b>%s</b> -> <b> %s: %s %s</b></pre>',\n        txpspecialchars($txp_current_tag),\n        $error[$errno],\n        $errstr,\n        $locus\n    );\n\n    if ($production_status == 'debug') {\n        print \"\\n<pre class=\\\"backtrace\\\" dir=\\\"ltr\\\"><code>\".txpspecialchars(join(\"\\n\", get_caller(10))).\"</code></pre>\";\n\n        $trace->log(gTxt('tag_error').' '.$txp_current_tag.' -> '.$error[$errno].': '.$errstr.' '.$locus);\n    }\n}\n\n/**\n * Error handler for XML feeds.\n *\n * @param   int    $errno\n * @param   string $errstr\n * @param   string $errfile\n * @param   int    $errline\n * @access  private\n * @package Debug\n */\n\nfunction feedErrorHandler($errno, $errstr, $errfile, $errline)\n{\n    global $production_status;\n\n    if ($production_status != 'debug') {\n        return;\n    }\n\n    return tagErrorHandler($errno, $errstr, $errfile, $errline);\n}\n\n/**\n * Error handler for public-side.\n *\n * @param   int    $errno\n * @param   string $errstr\n * @param   string $errfile\n * @param   int    $errline\n * @access  private\n * @package Debug\n */\n\nfunction publicErrorHandler($errno, $errstr, $errfile, $errline)\n{\n    global $production_status;\n\n    $error = array();\n\n    if ($production_status == 'testing') {\n        $error = array(\n            E_WARNING      => 'Warning',\n            E_USER_ERROR   => 'Textpattern Error',\n            E_USER_WARNING => 'Textpattern Warning',\n        );\n    } elseif ($production_status == 'debug') {\n        $error = array(\n            E_WARNING      => 'Warning',\n            E_NOTICE       => 'Notice',\n            E_USER_ERROR   => 'Textpattern Error',\n            E_USER_WARNING => 'Textpattern Warning',\n            E_USER_NOTICE  => 'Textpattern Notice',\n        );\n\n        if (!isset($error[$errno])) {\n            $error[$errno] = $errno;\n        }\n    }\n\n    if (!isset($error[$errno]) || !error_reporting()) {\n        return;\n    }\n\n    printf(\n        \"<pre dir=\\\"auto\\\">\".gTxt('general_error').' <b>%s: %s on line %s</b></pre>',\n        $error[$errno],\n        $errstr,\n        $errline\n    );\n\n    if ($production_status == 'debug') {\n        print \"\\n<pre class=\\\"backtrace\\\" dir=\\\"ltr\\\"><code>\".txpspecialchars(join(\"\\n\", get_caller(10))).\"</code></pre>\";\n    }\n}\n\n/**\n * Loads plugins.\n *\n * @param bool $type If TRUE loads admin-side plugins, otherwise public\n */\n\nfunction load_plugins($type = false, $pre = null)\n{\n    global $prefs, $plugins, $plugins_ver, $app_mode, $trace;\n    static $rs = null;\n\n    $trace->start('[Loading plugins]');\n    is_array($plugins) or $plugins = array();\n\n    if (!isset($rs)) {\n        if (!empty($prefs['plugin_cache_dir'])) {\n            $dir = rtrim($prefs['plugin_cache_dir'], DS).DS;\n\n            // In case it's a relative path.\n            if (!is_dir($dir)) {\n                $dir = rtrim(realpath(txpath.DS.$dir), DS).DS;\n            }\n\n            $files = glob($dir.'*.php');\n\n            if ($files) {\n                natsort($files);\n\n                foreach ($files as $f) {\n                    $trace->start(\"[Loading plugin from cache dir: '$f']\");\n                    load_plugin(basename($f, '.php'));\n                    $trace->stop();\n                }\n            }\n        }\n\n        $admin = ($app_mode == 'async' ? '4,5' : '1,3,4,5');\n        $where = 'status = 1 AND type IN ('.($type ? $admin : '0,1,5').')'.\n            ($plugins ? ' AND name NOT IN ('.join(',', quote_list($plugins)).')' : '');\n\n        $rs = safe_rows(\"name, version, load_order\", 'txp_plugin', $where.\" ORDER BY load_order ASC, name ASC\");\n    }\n\n    if ($rs) {\n        $old_error_handler = set_error_handler(\"pluginErrorHandler\");\n        $pre = intval($pre);\n\n        $writable = is_dir(PLUGINPATH) && is_writable(PLUGINPATH);\n\n        foreach ($rs as $a) {\n            if (!isset($plugins_ver[$a['name']]) && (!$pre || $a['load_order'] < $pre)) {\n                $plugins[] = $a['name'];\n                $plugins_ver[$a['name']] = $a['version'];\n                $GLOBALS['txp_current_plugin'] = $a['name'];\n                $trace->start(\"[Loading plugin: '{$a['name']}' version '{$a['version']}']\");\n\n                $dir = $a['name'];\n                $filename = PLUGINPATH.DS.$dir.DS.$dir.'.php';\n\n                if ($writable && !is_file($filename)) {\n                    $code = safe_field('code', 'txp_plugin', \"name='\".doSlash($a['name']).\"'\");\n                    \\Txp::get('\\Textpattern\\Plugin\\Plugin')->updateFile($a['name'], $code);\n                }\n\n                $eval_ok = is_readable($filename) ? include($filename) : false;\n                $trace->stop();\n\n                if ($eval_ok === false) {\n                    trigger_error(gTxt('plugin_include_error', array('{name}' => $a['name'])), E_USER_WARNING);\n                }\n\n                unset($GLOBALS['txp_current_plugin']);\n            }\n        }\n\n        restore_error_handler();\n    }\n\n    $trace->stop();\n}\n\n/**\n * Attaches a handler to a callback event.\n *\n * @param   callback $func  The callback function\n * @param   string   $event The callback event\n * @param   string   $step  The callback step\n * @param   bool     $pre   Before or after. Works only with selected callback events\n * @package Callback\n * @example\n * register_callback('my_callback_function', 'article.updated');\n * function my_callback_function($event)\n * {\n *     return \"'$event' fired.\";\n * }\n */\n\nfunction register_callback($func, $event, $step = '', $pre = 0)\n{\n    global $plugin_callback;\n\n    $pre or $pre = 0;\n\n    isset($plugin_callback[$event]) or $plugin_callback[$event] = array();\n    isset($plugin_callback[$event][$pre]) or $plugin_callback[$event][$pre] = array();\n    isset($plugin_callback[$event][$pre][$step]) or $plugin_callback[$event][$pre][$step] =\n        isset($plugin_callback[$event][$pre]['']) ? $plugin_callback[$event][$pre][''] : array();\n\n    if ($step === '') {\n        foreach($plugin_callback[$event][$pre] as $key => $val) {\n            $plugin_callback[$event][$pre][$key][] = $func;\n        }\n    } else {\n        $plugin_callback[$event][$pre][$step][] = $func;\n    }\n}\n\n/**\n * Call an event's callback.\n *\n * Executes all callback handlers attached to the matched event and step.\n *\n * When called, any event handlers attached with register_callback() to the\n * matching event, step and pre will be called. The handlers, callback\n * functions, will be executed in the same order they were registered.\n *\n * Any extra arguments will be passed to the callback handlers in the same\n * argument position. This allows passing any type of data to the attached\n * handlers. Callback handlers will also receive the event and the step.\n *\n * Returns a combined value of all values returned by the callback handlers.\n *\n * @param   string         $event The callback event\n * @param   string         $step  Additional callback step\n * @param   bool|int|array $pre   Allows two callbacks, a prepending and an appending, with same event and step. Array allows return values chaining\n * @return  mixed  The value returned by the attached callback functions, or an empty string\n * @package Callback\n * @see     register_callback()\n * @example\n * register_callback('my_callback_function', 'my_custom_event');\n * function my_callback_function($event, $step, $extra)\n * {\n *     return \"Passed '$extra' on '$event'.\";\n * }\n * echo callback_event('my_custom_event', '', 0, 'myExtraValue');\n */\n\nfunction callback_event($event, $step = '', $pre = 0)\n{\n    global $production_status, $trace;\n\n    list($pre, $renew) = (array)$pre + array(0, null);\n    $callbacks = callback_handlers($event, $step, $pre, false);\n\n    if (empty($callbacks)) {\n        return '';\n    }\n\n    $trace->start(\"[Callback_event: '$event', step='$step', pre='$pre']\");\n\n    // Any payload parameters?\n    $argv = func_get_args();\n    $argv = (count($argv) > 3) ? array_slice($argv, 3) : array();\n\n    foreach ($callbacks as $c) {\n        if (is_callable($c)) {\n            if ($production_status !== 'live') {\n                $trace->start(\"\\t[Call function: '\".Txp::get('\\Textpattern\\Type\\TypeCallable', $c)->toString().\"'\".\n                    (empty($argv) ? '' : \", argv='\".serialize($argv).\"'\").\"]\");\n            }\n\n            $return_value = call_user_func_array($c, array_merge(array(\n                $event,\n                $step\n            ), $argv));\n\n            if (isset($renew)) {\n                $argv[$renew] = $return_value;\n            }\n\n            if (isset($out) && !isset($renew)) {\n                if (is_array($return_value) && is_array($out)) {\n                    $out = array_merge($out, $return_value);\n                } elseif (is_bool($return_value) && is_bool($out)) {\n                    $out = $return_value && $out;\n                } else {\n                    $out .= $return_value;\n                }\n            } else {\n                $out = $return_value;\n            }\n\n            if ($production_status !== 'live') {\n                $trace->stop();\n            }\n        } elseif ($production_status === 'debug') {\n            trigger_error(gTxt('unknown_callback_function', array('{function}' => Txp::get('\\Textpattern\\Type\\TypeCallable', $c)->toString())), E_USER_WARNING);\n        }\n    }\n\n    $trace->stop();\n\n    if (isset($out)) {\n        return $out;\n    }\n\n    return '';\n}\n\n/**\n * Call an event's callback with two optional byref parameters.\n *\n * @param   string $event   The callback event\n * @param   string $step    Optional callback step\n * @param   bool   $pre     Allows two callbacks, a prepending and an appending, with same event and step\n * @param   mixed  $data    Optional arguments for event handlers\n * @param   mixed  $options Optional arguments for event handlers\n * @return  array Collection of return values from event handlers\n * @since   4.5.0\n * @package Callback\n */\n\nfunction callback_event_ref($event, $step = '', $pre = 0, &$data = null, &$options = null)\n{\n    global $production_status;\n\n    $callbacks = callback_handlers($event, $step, $pre, false);\n\n    if (empty($callbacks)) {\n        return array();\n    }\n\n    $return_value = array();\n\n    foreach ($callbacks as $c) {\n        if (is_callable($c)) {\n            // Cannot call event handler via call_user_func() as this would\n            // dereference all arguments. Side effect: callback handler\n            // *must* be ordinary function, *must not* be class method in\n            // PHP <5.4. See https://bugs.php.net/bug.php?id=47160.\n            $return_value[] = $c($event, $step, $data, $options);\n        } elseif ($production_status == 'debug') {\n            trigger_error(gTxt('unknown_callback_function', array('{function}' => Txp::get('\\Textpattern\\Type\\TypeCallable', $c)->toString())), E_USER_WARNING);\n        }\n    }\n\n    return $return_value;\n}\n\n/**\n * Checks if a callback event has active handlers.\n *\n * @param   string $event The callback event\n * @param   string $step  The callback step\n * @param   bool   $pre   The position\n * @return  bool TRUE if the event is active, FALSE otherwise\n * @since   4.6.0\n * @package Callback\n * @example\n * if (has_handler('article_saved'))\n * {\n *     echo \"There are active handlers for 'article_saved' event.\";\n * }\n */\n\nfunction has_handler($event, $step = '', $pre = 0)\n{\n    return (bool) callback_handlers($event, $step, $pre, false);\n}\n\n/**\n * Lists handlers attached to an event.\n *\n * @param   string $event The callback event\n * @param   string $step  The callback step\n * @param   bool   $pre   The position\n * @param   bool   $as_string Return callables in string representation\n * @return  array|bool An array of handlers, or FALSE\n * @since   4.6.0\n * @package Callback\n * @example\n * if ($handlers = callback_handlers('article_saved'))\n * {\n *     print_r($handlers);\n * }\n */\n\nfunction callback_handlers($event, $step = '', $pre = 0, $as_string = true)\n{\n    global $plugin_callback;\n\n    $pre or $pre = 0;\n    $step or $step = 0;\n\n    $callbacks = isset($plugin_callback[$event][$pre][$step]) ? $plugin_callback[$event][$pre][$step] :\n        (isset($plugin_callback[$event][$pre]['']) ? $plugin_callback[$event][$pre][''] : array());\n\n    if (!$as_string) {\n        return $callbacks;\n    }\n\n    $out = array();\n\n    foreach ($callbacks as $c) {\n        $out[] = Txp::get('\\Textpattern\\Type\\TypeCallable', $c)->toString();\n    }\n\n    return $out;\n}\n\n/**\n * Merge the second array into the first array.\n *\n * @param   array $pairs The first array\n * @param   array $atts  The second array\n * @param   bool  $warn  If TRUE triggers errors if second array contains values that are not in the first\n * @return  array The two arrays merged\n * @package TagParser\n */\n\nfunction lAtts($pairs, $atts, $warn = true)\n{\n    global $pretext, $production_status, $txp_atts;\n    static $globals = null, $global_atts, $partial;\n\n    if ($globals === null) {\n        $global_atts = Txp::get('\\Textpattern\\Tag\\Registry')->getRegistered(true);\n        $globals = array_filter($global_atts);\n    }\n\n    if (isset($atts['yield']) && !isset($pairs['yield'])) {\n        isset($partial) or $partial = Txp::get('\\Textpattern\\Tag\\Registry')->getTag('yield');\n\n        foreach (parse_qs($atts['yield']) as $name => $alias) {\n            $value = call_user_func($partial, array('name' => $alias === false ? $name : $alias));\n\n            if (isset($value)) {\n                $atts[$name] = $value;\n            }\n        }\n\n        unset($atts['yield']);\n    }\n\n    if (empty($pretext['_txp_atts'])) {\n        foreach ($atts as $name => $value) {\n            if (array_key_exists($name, $pairs)) {\n                if ($pairs[$name] !== null) {\n                    unset($txp_atts[$name]);\n                }\n\n                $pairs[$name] = $value;\n            } elseif ($warn && $production_status !== 'live' && !array_key_exists($name, $global_atts)) {\n                trigger_error(gTxt('unknown_attribute', array('{att}' => $name)));\n            }\n        }\n    } else { // don't import unset globals\n        foreach ($atts as $name => $value) {\n            if (array_key_exists($name, $pairs) && (!isset($globals[$name]) || isset($txp_atts[$name]))) {\n                $pairs[$name] = $value;\n                unset($txp_atts[$name]);\n            }\n        }\n    }\n\n    return $pairs ? $pairs : false;\n}\n\n/**\n * Sanitises a string for use in an article's URL title.\n *\n * @param   string $text  The title or an URL\n * @param   bool   $force Force sanitisation\n * @return  string|null\n * @package URL\n */\n\nfunction stripSpace($text, $force = false)\n{\n    if ($force || get_pref('attach_titles_to_permalinks')) {\n        $text = trim(sanitizeForUrl($text, '/[^\\p{L}\\p{N}\\-_\\s\\/\\\\\\\\\\x{1F300}-\\x{1F64F}\\x{1F680}-\\x{1F6FF}\\x{2600}-\\x{27BF}]/u'), '-');\n\n        if (get_pref('permlink_format')) {\n            return (function_exists('mb_strtolower') ? mb_strtolower($text, 'UTF-8') : strtolower($text));\n        } else {\n            return str_replace('-', '', $text);\n        }\n    }\n}\n\n/**\n * Sanitises a string for use in a URL.\n *\n * Be aware that you still have to urlencode the string when appropriate.\n * This function just makes the string look prettier and excludes some\n * unwanted characters, but leaves UTF-8 letters and digits intact.\n *\n * @param  string $text  The string\n * @param  string $strip The regex of the characters to strip\n * @return string\n * @package URL\n */\n\nfunction sanitizeForUrl($text, $strip = '/[^\\p{L}\\p{N}\\-_\\s\\/\\\\\\\\]/u')\n{\n    $out = callback_event('sanitize_for_url', '', 0, $text);\n\n    if ($out !== '') {\n        return $out;\n    }\n\n    // Remove named entities and tags.\n    $text = preg_replace(\"/(^|&\\S+;)|(<[^>]*>)/U\", \"\", dumbDown($text));\n    // Remove all characters except letter, number, dash, space and backslash\n    $text = preg_replace($strip, '', $text);\n    // Collapse spaces, minuses, (back-)slashes.\n    $text = trim(preg_replace('/[\\s\\-\\/\\\\\\\\]+/', '-', $text), '-');\n\n    return $text;\n}\n\n/**\n * Sanitises a string for use in a filename.\n *\n * @param   string $text The string\n * @return  string\n * @package File\n */\n\nfunction sanitizeForFile($text)\n{\n    $out = callback_event('sanitize_for_file', '', 0, $text);\n\n    if ($out !== '') {\n        return $out;\n    }\n\n    // Remove control characters and \" * \\ : < > ? / |\n    $text = preg_replace('/[\\x00-\\x1f\\x22\\x2a\\x2f\\x3a\\x3c\\x3e\\x3f\\x5c\\x7c\\x7f]+/', '', $text);\n    // Remove duplicate dots and any leading or trailing dots/spaces.\n    $text = preg_replace('/[.]{2,}/', '.', trim($text, '. '));\n\n    return $text;\n}\n\n/**\n * Sanitises a string for use in a page template's name.\n *\n * @param   string $text The string\n * @return  string\n * @package Filter\n * @access  private\n */\n\nfunction sanitizeForPage($text)\n{\n    $out = callback_event('sanitize_for_page', '', 0, $text);\n\n    if ($out !== '') {\n        return $out;\n    }\n\n    return trim(preg_replace('/[<>&\"\\']/', '', $text));\n}\n\n/**\n * Sanitizes a string for use in a ORDER BY clause.\n *\n * @param   string $text The string\n * @return  string\n * @package Filter\n * @access  private\n */\n\nfunction sanitizeForSort($text)\n{\n    return trim(strtr($text, array('#' => ' ', '--' => ' ')));\n}\n\n/**\n * Transliterates a string to ASCII.\n *\n * Used to generate RFC 3986 compliant and pretty ASCII-only URLs.\n *\n * @param   string $str  The string to convert\n * @param   string $lang The language which translation table is used\n * @see     sanitizeForUrl()\n * @package L10n\n */\n\nfunction dumbDown($str, $lang = null)\n{\n    static $array;\n\n    if ($lang === null) {\n        $lang = get_pref('language_ui', LANG);\n    }\n\n    if (empty($array[$lang])) {\n        $array[$lang] = array( // Nasty, huh?\n            '&#192;' => 'A', '&Agrave;' => 'A', '&#193;' => 'A', '&Aacute;' => 'A', '&#194;' => 'A', '&Acirc;' => 'A',\n            '&#195;' => 'A', '&Atilde;' => 'A', '&#196;' => 'Ae', '&Auml;' => 'A', '&#197;' => 'A', '&Aring;' => 'A',\n            '&#198;' => 'Ae', '&AElig;' => 'AE',\n            '&#256;' => 'A', '&#260;' => 'A', '&#258;' => 'A',\n            '&#199;' => 'C', '&Ccedil;' => 'C', '&#262;' => 'C', '&#268;' => 'C', '&#264;' => 'C', '&#266;' => 'C',\n            '&#270;' => 'D', '&#272;' => 'D', '&#208;' => 'D', '&ETH;' => 'D',\n            '&#200;' => 'E', '&Egrave;' => 'E', '&#201;' => 'E', '&Eacute;' => 'E', '&#202;' => 'E', '&Ecirc;' => 'E', '&#203;' => 'E', '&Euml;' => 'E',\n            '&#274;' => 'E', '&#280;' => 'E', '&#282;' => 'E', '&#276;' => 'E', '&#278;' => 'E',\n            '&#284;' => 'G', '&#286;' => 'G', '&#288;' => 'G', '&#290;' => 'G',\n            '&#292;' => 'H', '&#294;' => 'H',\n            '&#204;' => 'I', '&Igrave;' => 'I', '&#205;' => 'I', '&Iacute;' => 'I', '&#206;' => 'I', '&Icirc;' => 'I', '&#207;' => 'I', '&Iuml;' => 'I',\n            '&#298;' => 'I', '&#296;' => 'I', '&#300;' => 'I', '&#302;' => 'I', '&#304;' => 'I',\n            '&#306;' => 'IJ',\n            '&#308;' => 'J',\n            '&#310;' => 'K',\n            '&#321;' => 'K', '&#317;' => 'K', '&#313;' => 'K', '&#315;' => 'K', '&#319;' => 'K',\n            '&#209;' => 'N', '&Ntilde;' => 'N', '&#323;' => 'N', '&#327;' => 'N', '&#325;' => 'N', '&#330;' => 'N',\n            '&#210;' => 'O', '&Ograve;' => 'O', '&#211;' => 'O', '&Oacute;' => 'O', '&#212;' => 'O', '&Ocirc;' => 'O', '&#213;' => 'O', '&Otilde;' => 'O',\n            '&#214;' => 'Oe', '&Ouml;' => 'Oe',\n            '&#216;' => 'O', '&Oslash;' => 'O', '&#332;' => 'O', '&#336;' => 'O', '&#334;' => 'O',\n            '&#338;' => 'OE',\n            '&#340;' => 'R', '&#344;' => 'R', '&#342;' => 'R',\n            '&#346;' => 'S', '&#352;' => 'S', '&#350;' => 'S', '&#348;' => 'S', '&#536;' => 'S',\n            '&#356;' => 'T', '&#354;' => 'T', '&#358;' => 'T', '&#538;' => 'T',\n            '&#217;' => 'U', '&Ugrave;' => 'U', '&#218;' => 'U', '&Uacute;' => 'U', '&#219;' => 'U', '&Ucirc;' => 'U',\n            '&#220;' => 'Ue', '&#362;' => 'U', '&Uuml;' => 'Ue',\n            '&#366;' => 'U', '&#368;' => 'U', '&#364;' => 'U', '&#360;' => 'U', '&#370;' => 'U',\n            '&#372;' => 'W',\n            '&#221;' => 'Y', '&Yacute;' => 'Y', '&#374;' => 'Y', '&#376;' => 'Y',\n            '&#377;' => 'Z', '&#381;' => 'Z', '&#379;' => 'Z',\n            '&#222;' => 'T', '&THORN;' => 'T',\n            '&#224;' => 'a', '&#225;' => 'a', '&#226;' => 'a', '&#227;' => 'a', '&#228;' => 'ae',\n            '&auml;' => 'ae',\n            '&#229;' => 'a', '&#257;' => 'a', '&#261;' => 'a', '&#259;' => 'a', '&aring;' => 'a',\n            '&#230;' => 'ae',\n            '&#231;' => 'c', '&#263;' => 'c', '&#269;' => 'c', '&#265;' => 'c', '&#267;' => 'c',\n            '&#271;' => 'd', '&#273;' => 'd', '&#240;' => 'd',\n            '&#232;' => 'e', '&#233;' => 'e', '&#234;' => 'e', '&#235;' => 'e', '&#275;' => 'e',\n            '&#281;' => 'e', '&#283;' => 'e', '&#277;' => 'e', '&#279;' => 'e',\n            '&#402;' => 'f',\n            '&#285;' => 'g', '&#287;' => 'g', '&#289;' => 'g', '&#291;' => 'g',\n            '&#293;' => 'h', '&#295;' => 'h',\n            '&#236;' => 'i', '&#237;' => 'i', '&#238;' => 'i', '&#239;' => 'i', '&#299;' => 'i',\n            '&#297;' => 'i', '&#301;' => 'i', '&#303;' => 'i', '&#305;' => 'i',\n            '&#307;' => 'ij',\n            '&#309;' => 'j',\n            '&#311;' => 'k', '&#312;' => 'k',\n            '&#322;' => 'l', '&#318;' => 'l', '&#314;' => 'l', '&#316;' => 'l', '&#320;' => 'l',\n            '&#241;' => 'n', '&#324;' => 'n', '&#328;' => 'n', '&#326;' => 'n', '&#329;' => 'n',\n            '&#331;' => 'n',\n            '&#242;' => 'o', '&#243;' => 'o', '&#244;' => 'o', '&#245;' => 'o', '&#246;' => 'oe',\n            '&ouml;' => 'oe',\n            '&#248;' => 'o', '&#333;' => 'o', '&#337;' => 'o', '&#335;' => 'o',\n            '&#339;' => 'oe',\n            '&#341;' => 'r', '&#345;' => 'r', '&#343;' => 'r',\n            '&#353;' => 's',\n            '&#249;' => 'u', '&#250;' => 'u', '&#251;' => 'u', '&#252;' => 'ue', '&#363;' => 'u',\n            '&uuml;' => 'ue',\n            '&#367;' => 'u', '&#369;' => 'u', '&#365;' => 'u', '&#361;' => 'u', '&#371;' => 'u',\n            '&#373;' => 'w',\n            '&#253;' => 'y', '&#255;' => 'y', '&#375;' => 'y',\n            '&#382;' => 'z', '&#380;' => 'z', '&#378;' => 'z',\n            '&#254;' => 't',\n            '&#223;' => 'ss',\n            '&#383;' => 'ss',\n            '&agrave;' => 'a', '&aacute;' => 'a', '&acirc;' => 'a', '&atilde;' => 'a', '&auml;' => 'ae',\n            '&aring;' => 'a', '&aelig;' => 'ae', '&ccedil;' => 'c', '&eth;' => 'd',\n            '&egrave;' => 'e', '&eacute;' => 'e', '&ecirc;' => 'e', '&euml;' => 'e',\n            '&igrave;' => 'i', '&iacute;' => 'i', '&icirc;' => 'i', '&iuml;' => 'i',\n            '&ntilde;' => 'n',\n            '&ograve;' => 'o', '&oacute;' => 'o', '&ocirc;' => 'o', '&otilde;' => 'o', '&ouml;' => 'oe',\n            '&oslash;' => 'o',\n            '&ugrave;' => 'u', '&uacute;' => 'u', '&ucirc;' => 'u', '&uuml;' => 'ue',\n            '&yacute;' => 'y', '&yuml;' => 'y',\n            '&thorn;' => 't',\n            '&szlig;' => 'ss',\n        );\n\n        if (is_file(txpath.'/lib/i18n-ascii.txt')) {\n            $i18n = parse_ini_file(txpath.'/lib/i18n-ascii.txt', true);\n\n            // Load the global map.\n            if (isset($i18n['default']) && is_array($i18n['default'])) {\n                $array[$lang] = array_merge($array[$lang], $i18n['default']);\n\n                // Base language overrides: 'de-AT' applies the 'de' section.\n                if (preg_match('/([a-zA-Z]+)-.+/', $lang, $m)) {\n                    if (isset($i18n[$m[1]]) && is_array($i18n[$m[1]])) {\n                        $array[$lang] = array_merge($array[$lang], $i18n[$m[1]]);\n                    }\n                }\n\n                // Regional language overrides: 'de-AT' applies the 'de-AT' section.\n                if (isset($i18n[$lang]) && is_array($i18n[$lang])) {\n                    $array[$lang] = array_merge($array[$lang], $i18n[$lang]);\n                }\n            }\n            // Load an old file (no sections) just in case.\n            else {\n                $array[$lang] = array_merge($array[$lang], $i18n);\n            }\n        }\n    }\n\n    return strtr($str, $array[$lang]);\n}\n\n/**\n * Cleans a URL.\n *\n * @param   string $url The URL\n * @return  string\n * @access  private\n * @package URL\n */\n\nfunction clean_url($url)\n{\n    return preg_replace(\"/\\\"|'|(?:\\s.*$)/\", '', $url);\n}\n\n/**\n * Replace the last space with a &#160; non-breaking space.\n *\n * @param   string $str The string\n * @return  string\n */\n\nfunction noWidow($str)\n{\n    if (REGEXP_UTF8 == 1) {\n        return preg_replace('@[ ]+([[:punct:]]?[\\p{L}\\p{N}\\p{Pc}]+[[:punct:]]?)$@u', '&#160;$1', rtrim($str));\n    }\n\n    return preg_replace('@[ ]+([[:punct:]]?\\w+[[:punct:]]?)$@', '&#160;$1', rtrim($str));\n}\n\n/**\n * Checks if an IP is on a spam blocklist.\n *\n * @param   string       $ip     The IP address\n * @param   string|array $checks The checked lists. Defaults to 'spam_blacklists' preferences string\n * @return  string|bool The lists the IP is on or FALSE\n * @package Comment\n * @example\n * if (is_blacklisted('192.0.2.1'))\n * {\n *     echo \"'192.0.2.1' is on the blocklist.\";\n * }\n */\n\nfunction is_blacklisted($ip, $checks = '')\n{\n    if (!$checks) {\n        $checks = do_list_unique(get_pref('spam_blacklists'));\n    }\n\n    $rip = join('.', array_reverse(explode('.', $ip)));\n\n    foreach ((array) $checks as $a) {\n        $parts = explode(':', $a, 2);\n        $rbl   = $parts[0];\n\n        if (isset($parts[1])) {\n            foreach (explode(':', $parts[1]) as $code) {\n                $codes[] = strpos($code, '.') ? $code : '127.0.0.'.$code;\n            }\n        }\n\n        $hosts = $rbl ? @gethostbynamel($rip.'.'.trim($rbl, '. ').'.') : false;\n\n        if ($hosts and (!isset($codes) or array_intersect($hosts, $codes))) {\n            $listed[] = $rbl;\n        }\n    }\n\n    return (!empty($listed)) ? join(', ', $listed) : false;\n}\n\n/**\n * Checks if the user is authenticated on the public-side.\n *\n * @param   string $user The checked username. If not provided, any user is accepted\n * @return  array|bool An array containing details about the user; name, RealName, email, privs. FALSE when the user hasn't authenticated.\n * @package User\n * @example\n * if ($user = is_logged_in())\n * {\n *     echo \"Logged in as {$user['RealName']}\";\n * }\n */\n\nfunction is_logged_in($user = '')\n{\n    static $users = array();\n\n    $name = substr(cs('txp_login_public'), 10);\n\n    if (!strlen($name) || strlen($user) && $user !== $name) {\n        return false;\n    }\n\n    if (!isset($users[$name])) {\n        $users[$name] = safe_row(\"nonce, name, RealName, email, privs\", 'txp_users', \"name = '\".doSlash($name).\"'\");\n    }\n\n    $rs = $users[$name];\n\n    if ($rs && substr(md5($rs['nonce']), -10) === substr(cs('txp_login_public'), 0, 10)) {\n        unset($rs['nonce']);\n\n        return $rs;\n    } else {\n        return false;\n    }\n}\n\n/**\n * Updates the path to the site.\n *\n * @param   string $here The path\n * @access  private\n * @package Pref\n */\n\nfunction updateSitePath($here)\n{\n    set_pref('path_to_site', $here, 'publish', PREF_HIDDEN);\n}\n\n/**\n * Converts Textpattern tag's attribute list to an array.\n *\n * @param   array|string $text The attribute list, e.g. foobar=\"1\" barfoo=\"0\"\n * @return  array Array of attributes\n * @access  private\n * @package TagParser\n */\n\nfunction splat($text)\n{\n    static $stack = array(), $parse = array(), $global_atts = array(), $globals = null;\n    global $production_status, $trace, $txp_atts;\n\n    if ($globals === null) {\n        $globals = array_filter(Txp::get('\\Textpattern\\Tag\\Registry')->getRegistered(true));\n    }\n\n    if (is_array($text)) {\n        $txp_atts = array_intersect_key($text, $globals);\n        return $text;\n    }\n\n    $sha = txp_hash($text);\n\n    if (!isset($stack[$sha])) {\n        $stack[$sha] = $parse[$sha] = array();\n\n        if (preg_match_all('@([\\w\\-]+)(?:\\s*=\\s*(?:\"((?:[^\"]|\"\")*)\"|\\'((?:[^\\']|\\'\\')*)\\'|([^\\s\\'\"/>]+)))?@s', $text, $match, PREG_SET_ORDER)) {\n            foreach ($match as $m) {\n                $name = strtolower($m[1]);\n\n                switch (count($m)) {\n                    case 2:\n                        $val = true;\n                        break;\n                    case 3:\n                        $val = str_replace('\"\"', '\"', $m[2]);\n                        break;\n                    case 4:\n                        $val = str_replace(\"''\", \"'\", $m[3]);\n\n                        if (strpos($m[3], ':') !== false) {\n                            $parse[$sha][] = $name;\n                        }\n\n                        break;\n                    case 5:\n                        $val = $m[4];\n                        trigger_error(gTxt('attribute_values_must_be_quoted'), E_USER_WARNING);\n                        break;\n                }\n\n                $stack[$sha][$name] = $val;\n            }\n        }\n\n        $global_atts[$sha] = array_intersect_key($stack[$sha], $globals) or $global_atts[$sha] = null;\n    }\n\n    $txp_atts = $global_atts[$sha];\n\n    if (empty($parse[$sha])) {\n        return $stack[$sha];\n    }\n\n    $atts = $stack[$sha];\n\n    if ($production_status !== 'live') {\n        foreach ($parse[$sha] as $p) {\n            $trace->start(\"[attribute '\".$p.\"']\");\n            $atts[$p] = parse($atts[$p], true, false);\n            isset($txp_atts[$p]) and $txp_atts[$p] = $atts[$p];\n            $trace->stop('[/attribute]');\n        }\n    } else {\n        foreach ($parse[$sha] as $p) {\n            $atts[$p] = parse($atts[$p], true, false);\n            isset($txp_atts[$p]) and $txp_atts[$p] = $atts[$p];\n        }\n    }\n\n    return $atts;\n}\n\n/**\n * Replaces CR and LF with spaces, and drops NULL bytes.\n *\n * Used for sanitising email headers.\n *\n * @param      string $str The string\n * @return     string\n * @package    Mail\n * @deprecated in 4.6.0\n * @see        \\Textpattern\\Mail\\Encode::escapeHeader()\n */\n\nfunction strip_rn($str)\n{\n    return Txp::get('\\Textpattern\\Mail\\Encode')->escapeHeader($str);\n}\n\n/**\n * Validates a string as an email address.\n *\n * <code>\n * if (is_valid_email('john.doe@example.com'))\n * {\n *     echo \"'john.doe@example.com' validates.\";\n * }\n * </code>\n *\n * @param      string $address The email address\n * @return     bool\n * @package    Mail\n * @deprecated in 4.6.0\n * @see        filter_var()\n */\n\nfunction is_valid_email($address)\n{\n    return (bool) filter_var($address, FILTER_VALIDATE_EMAIL);\n}\n\n/**\n * Sends an email message as the currently logged in user.\n *\n * <code>\n * if (txpMail('john.doe@example.com', 'Subject', 'Some message'))\n * {\n *     echo \"Email sent to 'john.doe@example.com'.\";\n * }\n * </code>\n *\n * @param   string $to_address The receiver\n * @param   string $subject    The subject\n * @param   string $body       The message\n * @param   string $reply_to The reply to address\n * @return  bool   Returns FALSE when sending failed\n * @see     \\Textpattern\\Mail\\Compose\n * @package Mail\n */\n\nfunction txpMail($to_address, $subject, $body, $reply_to = null)\n{\n    global $txp_user;\n\n    // Send the email as the currently logged in user.\n    if ($txp_user) {\n        $sender = safe_row(\n            \"RealName, email\",\n            'txp_users',\n            \"name = '\".doSlash($txp_user).\"'\"\n        );\n\n        if ($sender && is_valid_email(get_pref('publisher_email'))) {\n            $sender['email'] = get_pref('publisher_email');\n        }\n    }\n    // If not logged in, the receiver is the sender.\n    else {\n        $sender = safe_row(\n            \"RealName, email\",\n            'txp_users',\n            \"email = '\".doSlash($to_address).\"'\"\n        );\n    }\n\n    if ($sender) {\n        extract($sender);\n\n        try {\n            $message = Txp::get('\\Textpattern\\Mail\\Compose')\n                ->from($email, $RealName)\n                ->to($to_address)\n                ->subject($subject)\n                ->body($body);\n\n            if ($reply_to) {\n                $message->replyTo($reply_to);\n            }\n\n            $message->send();\n        } catch (\\Textpattern\\Mail\\Exception $e) {\n            return false;\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Encodes a string for use in an email header.\n *\n * @param      string $string The string\n * @param      string $type   The type of header, either \"text\" or \"phrase\"\n * @return     string\n * @package    Mail\n * @deprecated in 4.6.0\n * @see        \\Textpattern\\Mail\\Encode::header()\n */\n\nfunction encode_mailheader($string, $type)\n{\n    try {\n        return Txp::get('\\Textpattern\\Mail\\Encode')->header($string, $type);\n    } catch (\\Textpattern\\Mail\\Exception $e) {\n        trigger_error($e->getMessage(), E_USER_WARNING);\n    }\n}\n\n/**\n * Converts an email address into unicode entities.\n *\n * @param      string $txt The email address\n * @return     string Encoded email address\n * @package    Mail\n * @deprecated in 4.6.0\n * @see        \\Textpattern\\Mail\\Encode::entityObfuscateAddress()\n */\n\nfunction eE($txt)\n{\n    return Txp::get('\\Textpattern\\Mail\\Encode')->entityObfuscateAddress($txt);\n}\n\n/**\n * Strips PHP tags from a string.\n *\n * @param  string $in The input\n * @return string\n */\n\nfunction stripPHP($in)\n{\n    return preg_replace(\"/\".chr(60).\"\\?(?:php)?|\\?\".chr(62).\"/i\", '', $in);\n}\n\n/**\n * Creates a form template.\n *\n * On a successful run, will trigger a 'form.create > done' callback event.\n *\n * @param      string $name The name\n * @param      string $type The type\n * @param      string $Form The template\n * @return     bool FALSE on error\n * @since      4.6.0\n * @deprecated 4.8.6 (not skin-aware)\n * @see        Textpattern\\Skin\\Skin\n * @package    Template\n */\n\nfunction create_form($name, $type, $Form)\n{\n    $types = get_form_types();\n\n    if (form_exists($name) || !is_valid_form($name) || !in_array($type, array_keys($types))) {\n        return false;\n    }\n\n    if (\n        safe_insert(\n            'txp_form',\n            \"name = '\".doSlash($name).\"',\n            type = '\".doSlash($type).\"',\n            Form = '\".doSlash($Form).\"'\"\n        ) === false\n    ) {\n        return false;\n    }\n\n    callback_event('form.create', 'done', 0, compact('name', 'type', 'Form'));\n\n    return true;\n}\n\n/**\n * Checks if a form template exists.\n *\n * @param      string $name The form\n * @return     bool TRUE if the form exists\n * @since      4.6.0\n * @deprecated 4.8.6 (not skin-aware)\n * @see        Textpattern\\Skin\\CommonBase\n * @package    Template\n */\n\nfunction form_exists($name)\n{\n    return (bool) safe_row(\"name\", 'txp_form', \"name = '\".doSlash($name).\"'\");\n}\n\n/**\n * Validates a string as a form template name.\n *\n * @param      string $name The form name\n * @return     bool TRUE if the string validates\n * @since      4.6.0\n * @deprecated 4.8.6\n * @see        Textpattern\\Skin\\CommonBase\n * @package    Template\n */\n\nfunction is_valid_form($name)\n{\n    if (function_exists('mb_strlen')) {\n        $length = mb_strlen($name, '8bit');\n    } else {\n        $length = strlen($name);\n    }\n\n    return $name && !preg_match('/^\\s|[<>&\"\\']|\\s$/u', $name) && $length <= 64;\n}\n\n/**\n * Validates a string as a date% query.\n *\n * @param   string $date The partial date\n * @return  bool|string FALSE if the string does not validate\n * @since   4.8.5\n * @package Template\n */\n\nfunction is_date($month)\n{\n    if (!preg_match('/^\\d{1,4}(?:\\-\\d{1,2}){0,2}$/', $month)) {\n        return false;\n    }\n\n    $month = explode('-', $month, 3);\n    $result = true;\n\n    switch (count($month)) {\n        case 3:\n            $result = checkdate($month[1], $month[2], $month[0]) and\n            $month[2] = str_pad($month[2], 2, '0', STR_PAD_LEFT);\n        case 2:\n            $result = $result && $month[1] > 0 && $month[1] < 13;\n            !$result or $month[1] = str_pad($month[1], 2, '0', STR_PAD_LEFT);\n        case 1:\n            $result = $result && $month[0] > 0;\n            !$result or $month[0] = str_pad($month[0], 4, '0', STR_PAD_LEFT);\n    }\n\n    return $result ? implode('-', $month) : false;\n}\n\n/**\n * Gets a \"since days ago\" date format from a given UNIX timestamp.\n *\n * @param   int $stamp UNIX timestamp\n * @return  string \"n days ago\"\n * @package DateTime\n */\n\nfunction since($stamp)\n{\n    $diff = (time() - $stamp);\n\n    if ($diff <= 3600) {\n        $qty = round($diff / 60);\n\n        if ($qty < 1) {\n            $qty = '';\n            $period = gTxt('a_few_seconds');\n        } elseif ($qty == 1) {\n            $period = gTxt('minute');\n        } else {\n            $period = gTxt('minutes');\n        }\n    } elseif (($diff <= 86400) && ($diff > 3600)) {\n        $qty = round($diff / 3600);\n\n        if ($qty <= 1) {\n            $qty = 1;\n            $period = gTxt('hour');\n        } else {\n            $period = gTxt('hours');\n        }\n    } elseif ($diff >= 86400) {\n        $qty = round($diff / 86400);\n\n        if ($qty <= 1) {\n            $qty = 1;\n            $period = gTxt('day');\n        } else {\n            $period = gTxt('days');\n        }\n    }\n\n    return gTxt('ago', array('{qty}' => $qty, '{period}' => $period));\n}\n\n/**\n * Calculates a timezone offset.\n *\n * Calculates the offset between the server local time and the\n * user's selected timezone at a given point in time.\n *\n * @param   int $timestamp The timestamp. Defaults to time()\n * @return  int The offset in seconds\n * @package DateTime\n */\n\nfunction tz_offset($timestamp = null)\n{\n    global $gmtoffset, $timezone_key;\n    static $dtz = array(), $timezone_server = null;\n\n    if ($timezone_server === null) {\n        $timezone_server = date_default_timezone_get();\n    }\n\n    if ($timezone_server === $timezone_key) {\n        return 0;\n    }\n\n    if ($timestamp === null) {\n        $timestamp = time();\n    }\n\n    try {\n        if (!isset($dtz[$timezone_server])) {\n            $dtz[$timezone_server] = new \\DateTimeZone($timezone_server);\n        }\n\n        $transition = $dtz[$timezone_server]->getTransitions($timestamp, $timestamp);\n        $serveroffset = $transition[0]['offset'];\n    } catch (\\Exception $e) {\n        extract(getdate($timestamp));\n        $serveroffset = gmmktime($hours, $minutes, 0, $mon, $mday, $year) - mktime($hours, $minutes, 0, $mon, $mday, $year);\n    }\n\n    try {\n        if (!isset($dtz[$timezone_key])) {\n            $dtz[$timezone_key] = new \\DateTimeZone($timezone_key);\n        }\n\n        $transition = $dtz[$timezone_key]->getTransitions($timestamp, $timestamp);\n        $siteoffset = $transition[0]['offset'];\n    } catch (\\Exception $e) {\n        $siteoffset = $gmtoffset;\n    }\n\n    return $siteoffset - $serveroffset;\n}\n\n/**\n * Formats a time.\n *\n * Respects the locale and local timezone, and makes sure the\n * output string is encoded in UTF-8.\n *\n * @param   string $format          The date format\n * @param   int    $time            UNIX timestamp. Defaults to time()\n * @param   bool   $gmt             Return GMT time\n * @param   string $override_locale Override the locale\n * @return  string Formatted date\n * @package DateTime\n * @example\n * echo intl_strftime('w3cdtf');\n */\n\nfunction intl_strftime($format, $time = null, $gmt = false, $override_locale = '')\n{\n    global $lang_ui;\n    static $DateTime = null, $IntlDateFormatter = array(), $default = array(), $formats = array(\n        '%a' => 'eee',\n        '%A' => 'eeee',\n        '%d' => 'dd',\n        '%e' => 'd',\n        '%Oe' => 'd',\n        '%j' => 'D',\n        '%u' => 'c',\n        '%w' => 'e',\n        '%U' => 'w',\n        '%V' => 'ww',\n        '%W' => 'ww',\n        '%b' => 'MMM',\n        '%B' => 'MMMM',\n        '%h' => 'MMM',\n        '%m' => 'MM',\n        '%g' => 'yy',\n        '%G' => 'Y',\n        '%Y' => 'y',\n        '%y' => 'yy',\n        '%H' => 'HH',\n        '%k' => 'H',\n        '%I' => 'hh',\n        '%l' => 'h',\n        '%M' => 'mm',\n        '%S' => 'ss',\n        '%p' => 'a',\n        '%P' => 'a',\n        '%r' => 'h:mm:ss a',\n        '%R' => 'HH:mm',\n        '%T' => 'HH:mm:ss',\n        '%z' => 'Z',\n        '%Z' => 'z',\n        '%D' => 'MM/dd/yy',\n        '%F' => 'yy-MM-dd',\n        '%n' => n,\n        '%t' => t,\n        '%%' => '%',\n    );\n\n    if ($DateTime === null) {\n        $DateTime = new DateTime();\n    }\n\n    $override_locale or $override_locale = txpinterface == 'admin' ? $lang_ui : LANG;\n\n    if (!isset($IntlDateFormatter[$override_locale])) {\n        $IntlDateFormatter[$override_locale] = new IntlDateFormatter(\n            $override_locale,\n            IntlDateFormatter::LONG,\n            IntlDateFormatter::SHORT,\n            null,\n            /*strpos($override_locale, 'calendar') === false ? null :*/ IntlDateFormatter::TRADITIONAL\n        );\n        $pattern = $IntlDateFormatter[$override_locale]->getPattern();\n        $xt = datefmt_create($override_locale, IntlDateFormatter::NONE, IntlDateFormatter::SHORT,\n        null, IntlDateFormatter::TRADITIONAL)->getPattern();//trim(preg_replace('/[^aHhmps:\\s]/', '', $pattern));\n        $xd = datefmt_create($override_locale, IntlDateFormatter::LONG, IntlDateFormatter::NONE,\n        null, IntlDateFormatter::TRADITIONAL)->getPattern();//trim(str_replace($xt, '', $pattern), ' ,');\n        $default[$override_locale] = array('%c' => $pattern, '%x' => $xd, '%X' => $xt);\n    }\n\n    $DateTime->setTimestamp($time);\n\n    $formats['%s'] = $time;\n    $format = strtr($format, $formats + $default[$override_locale]);\n    !$gmt or $IntlDateFormatter[$override_locale]->setTimeZone('GMT+0');\n    $IntlDateFormatter[$override_locale]->setPattern($format);\n    $str = $IntlDateFormatter[$override_locale]->format($DateTime);\n    !$gmt or $IntlDateFormatter[$override_locale]->setTimeZone(null);\n\n    return $str;\n}\n\n/**\n * Formats a time.\n *\n * Respects the locale and local timezone, and makes sure the\n * output string is encoded in UTF-8.\n *\n * @param   string $format          The date format\n * @param   int    $time            UNIX timestamp. Defaults to time()\n * @param   bool   $gmt             Return GMT time\n * @param   string $override_locale Override the locale\n * @return  string Formatted date\n * @package DateTime\n * @example\n * echo safe_strftime('w3cdtf');\n */\n\nfunction safe_strftime($format, $time = null, $gmt = false, $override_locale = '')\n{\n    static $charsets = array(), $txpLocale = null, $intl = null, $formats = array( //'rfc850', 'rfc1036', 'rfc1123', 'rfc2822' ?\n        'atom' => DATE_ATOM, 'w3cdtf' => DATE_ATOM, 'rss' => DATE_RSS, 'cookie' => DATE_COOKIE, 'w3c' => DATE_W3C, 'iso8601' => DATE_ISO8601, 'rfc822' => DATE_RFC822,\n    ), $translate = array(\n        '%a' => 'D',\n        '%A' => 'l',\n        '%d' => 'd',\n        '%e' => 'j',\n        '%Oe' => 'jS',\n        '%j' => 'z',\n        '%u' => 'N',\n        '%w' => 'w',\n        '%U' => 'W',\n        '%V' => 'W',\n        '%W' => 'W',\n        '%b' => 'M',\n        '%B' => 'F',\n        '%h' => 'M',\n        '%m' => 'm',\n        '%g' => 'y',\n        '%G' => 'o',\n        '%Y' => 'Y',\n        '%y' => 'y',\n        '%H' => 'H',\n        '%k' => 'G',\n        '%I' => 'h',\n        '%l' => 'g',\n        '%M' => 'i',\n        '%S' => 's',\n        '%p' => 'A',\n        '%P' => 'a',\n        '%r' => 'g:i:s A',\n        '%R' => 'H:i',\n        '%T' => 'H:i:s',\n        '%z' => 'O',\n        '%Z' => 'T',\n        '%D' => 'm/d/y',\n        '%F' => 'Y-m-d',\n        '%s' => 'U',\n        '%n' => n,\n        '%t' => t,\n        '%%' => '%',\n    );\n\n    $time = isset($time) ? (int)$time : time();\n\n    if ($intl === null) {\n        $intl = class_exists('IntlDateFormatter');\n    }\n\n    if ($format == 'since') {\n        return since($time);\n    } elseif (isset($formats[$format])) {\n        // We could add some other formats here.\n        return gmdate($formats[$format], $time);\n    } elseif (strpos($format, '%') === false) {\n        return $intl ? intl_strftime($format, $time, $gmt, $override_locale) : ($gmt ? gmdate($format, $time) : date($format, $time));\n    } elseif (!preg_match('/\\%[aAbBchOxX]/', $format) && strpos($override_locale, 'calendar') === false) {\n        return $gmt ? gmdate(strtr($format, $translate), $time) : date(strtr($format, $translate), $time);\n    } elseif ($intl) {\n        return intl_strftime($format, $time, $gmt, $override_locale);\n    }\n\n    if ($txpLocale === null) {\n        $txpLocale = Txp::get('\\Textpattern\\L10n\\Locale');\n    }\n\n    if ($override_locale) {\n        $oldLocale = $txpLocale->getLocale(LC_TIME);\n\n        if ($oldLocale != $override_locale) {\n            $txpLocale->setLocale(LC_TIME, $override_locale);\n        } else {\n            $oldLocale = null;\n        }\n    }\n\n    if ($gmt) {\n        $str = gmstrftime($format, $time);\n    } else {\n        $tztime = $time + tz_offset($time);\n        $format = str_replace('%s', $tztime, $format);\n        $str = strftime($format, $tztime);\n    }\n\n    if (!isset($charsets[$override_locale])) {\n        $charsets[$override_locale] = strtoupper($txpLocale->getCharset(LC_TIME, IS_WIN ? 'Windows-1252' : 'ISO-8859-1'));\n    }\n\n    $charset = $charsets[$override_locale];\n\n    if ($charset != 'UTF-8' && $charset != 'UTF8') {\n        if (is_callable('iconv') && $new = iconv($charset, 'UTF-8', $str)) {\n            $str = $new;\n        } elseif (is_callable('utf8_encode')) {\n            $str = utf8_encode($str);\n        }\n    }\n\n    // Revert to the old locale.\n    if (isset($oldLocale)) {\n        $txpLocale->setLocale(LC_TIME, $oldLocale);\n    }\n\n    return $str;\n}\n\n/**\n * Converts a time string from the Textpattern timezone to GMT.\n *\n * @param   string $time_str The time string\n * @return  int UNIX timestamp\n * @package DateTime\n */\n\nfunction safe_strtotime($time_str)\n{\n    $ts = strtotime($time_str);\n\n    // tz_offset calculations are expensive\n    $tz_offset = tz_offset($ts);\n\n    return strtotime($time_str, time() + $tz_offset) - $tz_offset;\n}\n\n/**\n * Generic error handler.\n *\n * @param   int    $errno\n * @param   string $errstr\n * @param   string $errfile\n * @param   int    $errline\n * @access  private\n * @package Debug\n */\n\nfunction myErrorHandler($errno, $errstr, $errfile, $errline)\n{\n    if (!error_reporting()) {\n        return;\n    }\n\n    echo '<pre dir=\"auto\">'.n.n.\"$errno: $errstr in $errfile at line $errline\\n\";\n\n    if (is_callable('debug_backtrace')) {\n        echo \"Backtrace:\\n\";\n        $trace = debug_backtrace();\n\n        foreach ($trace as $ent) {\n            if (isset($ent['file'])) {\n                echo $ent['file'].':';\n            }\n\n            if (isset($ent['function'])) {\n                echo $ent['function'].'(';\n\n                if (isset($ent['args'])) {\n                    $args = '';\n\n                    foreach ($ent['args'] as $arg) {\n                        $args .= $arg.',';\n                    }\n\n                    echo rtrim($args, ',');\n                }\n\n                echo ') ';\n            }\n\n            if (isset($ent['line'])) {\n                echo 'at line '.$ent['line'].' ';\n            }\n\n            if (isset($ent['file'])) {\n                echo 'in '.$ent['file'];\n            }\n\n            echo \"\\n\";\n        }\n    }\n\n    echo \"</pre>\";\n}\n\n/**\n * Renders a download link.\n *\n * @param   int    $id       The file ID\n * @param   string $label    The label\n * @param   string $filename The filename\n * @return  string HTML\n * @package File\n */\n\nfunction make_download_link($id, $label = '', $filename = '')\n{\n    if ((string) $label === '') {\n        $label = gTxt('download');\n    }\n\n    $url = filedownloadurl($id, $filename);\n\n    // Do not use the array() form of passing $atts to href().\n    // Doing so breaks download links on the admin side due to\n    // double-encoding of the ampersands.\n    return href($label, $url, ' title = \"'.gTxt('download').'\"');\n}\n\n/**\n * Sets error reporting level.\n *\n * @param   string $level The level. Either \"debug\", \"live\" or \"testing\"\n * @package Debug\n */\n\nfunction set_error_level($level)\n{\n    if ($level == 'debug') {\n        error_reporting(E_ALL | E_STRICT);\n    } elseif ($level == 'live') {\n        // Don't show errors on screen.\n        $suppress = E_NOTICE | E_USER_NOTICE | E_WARNING | E_STRICT | E_DEPRECATED;\n        error_reporting(E_ALL ^ $suppress);\n        @ini_set(\"display_errors\", \"1\");\n    } else {\n        // Default is 'testing': display everything except notices.\n        error_reporting((E_ALL | E_STRICT) ^ (E_NOTICE | E_USER_NOTICE));\n    }\n}\n\n/**\n * Translates upload error code to a localised error message.\n *\n * @param   int $err_code The error code\n * @return  string The $err_code as a message\n * @package File\n */\n\nfunction upload_get_errormsg($err_code)\n{\n    $msg = '';\n\n    switch ($err_code) {\n        // Value: 0; There is no error, the file uploaded with success.\n        case UPLOAD_ERR_OK:\n            $msg = '';\n            break;\n        // Value: 1; The uploaded file exceeds the upload_max_filesize directive in php.ini.\n        case UPLOAD_ERR_INI_SIZE:\n            $msg = gTxt('upload_err_ini_size');\n            break;\n        // Value: 2; The uploaded file exceeds the MAX_FILE_SIZE directive that was specified in the HTML form.\n        case UPLOAD_ERR_FORM_SIZE:\n            $msg = gTxt('upload_err_form_size');\n            break;\n        // Value: 3; The uploaded file was only partially uploaded.\n        case UPLOAD_ERR_PARTIAL:\n            $msg = gTxt('upload_err_partial');\n            break;\n        // Value: 4; No file was uploaded.\n        case UPLOAD_ERR_NO_FILE:\n            $msg = gTxt('upload_err_no_file');\n            break;\n        // Value: 6; Missing a temporary folder. Introduced in PHP 4.3.10 and PHP 5.0.3.\n        case UPLOAD_ERR_NO_TMP_DIR:\n            $msg = gTxt('upload_err_tmp_dir');\n            break;\n        // Value: 7; Failed to write file to disk. Introduced in PHP 5.1.0.\n        case UPLOAD_ERR_CANT_WRITE:\n            $msg = gTxt('upload_err_cant_write');\n            break;\n        // Value: 8; File upload stopped by extension. Introduced in PHP 5.2.0.\n        case UPLOAD_ERR_EXTENSION:\n            $msg = gTxt('upload_err_extension');\n            break;\n    }\n\n    return $msg;\n}\n\n/**\n * Formats a file size.\n *\n * @param   int    $bytes    Size in bytes\n * @param   int    $decimals Number of decimals\n * @param   string $format   The format the size is represented\n * @return  string Formatted file size\n * @package File\n * @example\n * echo format_filesize(168642);\n */\n\nfunction format_filesize($bytes, $decimals = 2, $format = '')\n{\n    $units = array('b', 'k', 'm', 'g', 't', 'p', 'e', 'z', 'y');\n\n    if (in_array($format, $units)) {\n        $pow = array_search($format, $units);\n    } else {\n        $pow = floor(($bytes ? log($bytes) : 0) / log(1024));\n        $pow = min($pow, count($units) - 1);\n    }\n\n    $bytes /= pow(1024, $pow);\n\n    $separators = localeconv();\n    $sep_dec = isset($separators['decimal_point']) ? $separators['decimal_point'] : '.';\n    $sep_thous = isset($separators['thousands_sep']) ? $separators['thousands_sep'] : ',';\n\n    return number_format($bytes, $decimals, $sep_dec, $sep_thous).sp.gTxt('units_'.$units[$pow]);\n}\n\n/**\n * Gets a file download as an array.\n *\n * @param   string $where SQL where clause\n * @return  array|bool An array of files, or FALSE on failure\n * @package File\n * @example\n * if ($file = fileDownloadFetchInfo('id = 1'))\n * {\n *     print_r($file);\n * }\n */\n\nfunction fileDownloadFetchInfo($where)\n{\n    $rs = safe_row(\"*\", 'txp_file', $where);\n\n    if ($rs) {\n        return file_download_format_info($rs);\n    }\n\n    return false;\n}\n\n/**\n * Formats file download info.\n *\n * Takes a data array generated by fileDownloadFetchInfo()\n * and formats the contents.\n *\n * @param   array $file The file info to format\n * @return  array Formatted file info\n * @access  private\n * @package File\n */\n\nfunction file_download_format_info($file)\n{\n    if (($unix_ts = @strtotime($file['created'])) > 0) {\n        $file['created'] = $unix_ts;\n    }\n\n    if (($unix_ts = @strtotime($file['modified'])) > 0) {\n        $file['modified'] = $unix_ts;\n    }\n\n    return $file;\n}\n\n/**\n * Formats file download's modification and creation timestamps.\n *\n * Used by file_download tags.\n *\n * @param   array $params\n * @return  string\n * @access  private\n * @package File\n */\n\nfunction fileDownloadFormatTime($params)\n{\n    extract(lAtts(array(\n        'ftime'  => '',\n        'format' => '',\n    ), $params));\n\n    if (!empty($ftime)) {\n        if ($format) {\n            return safe_strftime($format, $ftime);\n        }\n\n        return safe_strftime(get_pref('archive_dateformat'), $ftime);\n    }\n\n    return '';\n}\n\n/**\n * file_get_contents wrapper.\n *\n */\n\nfunction txp_get_contents($file)\n{\n    return is_readable($file) ? file_get_contents($file) : '';\n}\n\n/**\n * Returns the contents of the found files as an array.\n *\n */\n\nfunction get_files_content($dir, $ext)\n{\n    $result = array();\n\n    if (is_readable($dir)) {\n        foreach ((array)scandir($dir) as $file) {\n            if (preg_match('/^(.+)\\.'.$ext.'$/', $file, $match)) {\n                $result[$match[1]] = file_get_contents(\"$dir/$file\");\n            }\n        }\n    }\n\n    return $result;\n}\n\n/**\n * Checks if a function is disabled.\n *\n * @param   string $function The function name\n * @return  bool TRUE if the function is disabled\n * @package System\n * @example\n * if (is_disabled('mail'))\n * {\n *     echo \"'mail' function is disabled.\";\n * }\n */\n\nfunction is_disabled($function)\n{\n    static $disabled;\n\n    if (!isset($disabled)) {\n        $disabled = do_list(ini_get('disable_functions'));\n    }\n\n    return in_array($function, $disabled);\n}\n\n/**\n * Joins two strings to form a single filesystem path.\n *\n * @param   string $base The base directory\n * @param   string $path The second path, a relative filename\n * @return  string A path to a file\n * @package File\n */\n\nfunction build_file_path($base, $path)\n{\n    $base = rtrim($base, '/\\\\');\n    $path = ltrim($path, '/\\\\');\n\n    return $base.DS.$path;\n}\n\n/**\n * Gets a user's real name.\n *\n * @param   string $name The username\n * @return  string A real name, or username if empty\n * @package User\n */\n\nfunction get_author_name($name)\n{\n    static $authors = array();\n\n    if (isset($authors[$name])) {\n        return $authors[$name];\n    }\n\n    $realname = fetch('RealName', 'txp_users', 'name', $name);\n    $authors[$name] = $realname;\n\n    return ($realname) ? $realname : $name;\n}\n\n/**\n * Gets a user's email address.\n *\n * @param   string $name The username\n * @return  string\n * @package User\n */\n\nfunction get_author_email($name)\n{\n    static $authors = array();\n\n    if (isset($authors[$name])) {\n        return $authors[$name];\n    }\n\n    $email = fetch('email', 'txp_users', 'name', $name);\n    $authors[$name] = $email;\n\n    return $email;\n}\n\n/**\n * Checks if a database table contains items just from one user.\n *\n * @param   string $table The database table\n * @param   string $col   The column\n * @return  bool\n * @package User\n * @example\n * if (has_single_author('textpattern', 'AuthorID'))\n * {\n *     echo \"'textpattern' table has only content from one author.\";\n * }\n */\n\nfunction has_single_author($table, $col = 'author')\n{\n    static $cache = array();\n\n    if (!isset($cache[$table][$col])) {\n        $cache[$table][$col] = (safe_field(\"COUNT(name)\", 'txp_users', \"1 = 1\") <= 1) &&\n            (safe_field(\"COUNT(DISTINCT(\".doSlash($col).\"))\", doSlash($table), \"1 = 1\") <= 1);\n    }\n\n    return $cache[$table][$col];\n}\n\n/**\n * Parse a string and store the result.\n *\n * @param   string        $thing        The raw string\n * @param   null|string   $hash         The string SHA1 hash\n * @param   bool|callable $transform    The function applied to txp tags\n * @package TagParser\n */\n\nfunction txp_tokenize($thing, $hash = null, $transform = null)\n{\n    global $txp_parsed, $txp_else;\n    static $short_tags = null;\n\n    isset($short_tags) or $short_tags = get_pref('enable_short_tags', false);\n\n    $f = '@(</?(?:'.TXP_PATTERN.'):\\w+(?:\\[-?\\d+\\])?(?:\\s+[\\w\\-]+(?:\\s*=\\s*(?:\"(?:[^\"]|\"\")*\"|\\'(?:[^\\']|\\'\\')*\\'|[^\\s\\'\"/>]+))?)*\\s*/?\\>)@s';\n    $t = '@^</?('.TXP_PATTERN.'):(\\w+)(?:\\[(-?\\d+)\\])?(.*)\\>$@s';\n\n    $parsed = preg_split($f, $thing, -1, PREG_SPLIT_DELIM_CAPTURE);\n    $last = count($parsed);\n\n    if (isset($transform) && (is_bool($transform) || is_callable($transform))) {\n        $transform !== true or $transform = 'txpspecialchars';\n\n        for ($i = 1; $i < $last; $i+=2) {\n            $parsed[$i] = $transform === false ? null : call_user_func($transform, $parsed[$i]);\n        }\n    }\n\n    if ($hash === false) {\n        return $parsed;\n    } elseif ($last === 1) {\n        return false;\n    } elseif (!is_string($hash)) {\n        $hash = txp_hash($thing);\n    }\n\n    $inside  = array($parsed[0]);\n    $tags    = array($inside);\n    $tag     = array();\n    $outside = array();\n    $order = array(array());\n    $else    = array(-1);\n    $count   = array(-1);\n    $level   = 0;\n\n    for ($i = 1; $i < $last || $level > 0; $i++) {\n        $chunk = $i < $last ? $parsed[$i] : '</txp:'.$tag[$level-1][2].'>';\n        preg_match($t, $chunk, $tag[$level]);\n        $count[$level] += 2;\n\n        if ($tag[$level][2] === 'else') {\n            $else[$level] = $count[$level];\n        } elseif ($tag[$level][1] === 'txp:') {\n            // Handle <txp::shortcode />.\n            $tag[$level][4] .= ' form=\"'.$tag[$level][2].'\"';\n            $tag[$level][2] = 'output_form';\n        } elseif ($short_tags && $tag[$level][1] !== 'txp') {\n            // Handle <short::tags />.\n            $tag[$level][2] = rtrim($tag[$level][1], ':').'_'.$tag[$level][2];\n        }\n\n        if ($chunk[strlen($chunk) - 2] === '/') {\n            // Self closed tag.\n            if ($chunk[1] === '/') {\n                trigger_error(gTxt('ambiguous_tag_format', array('{chunk}' => $chunk)), E_USER_WARNING);\n            }\n\n            $tags[$level][] = array($chunk, $tag[$level][2], trim(rtrim($tag[$level][4], '/')), null, null);\n            $inside[$level] .= $chunk;\n            empty($tag[$level][3]) or $order[$level][count($tags[$level])/2] = $tag[$level][3];\n        } elseif ($chunk[1] !== '/') {\n            // Opening tag.\n            $inside[$level] .= $chunk;\n            empty($tag[$level][3]) or $order[$level][(count($tags[$level])+1)/2] = $tag[$level][3];\n            $level++;\n            $outside[$level] = $chunk;\n            $inside[$level] = '';\n            $else[$level] = $count[$level] = -1;\n            $tags[$level] = array();\n            $order[$level] = array();\n        } else {\n            // Closing tag.\n            if ($level < 1) {\n                trigger_error(gTxt('missing_open_tag', array('{chunk}' => $chunk)), E_USER_WARNING);\n                $tags[$level][] = array($chunk, null, '', null, null);\n                $inside[$level] .= $chunk;\n            } else {\n                if ($i >= $last) {\n                    trigger_error(gTxt('missing_close_tag', array('{chunk}' => $outside[$level])), E_USER_WARNING);\n                } elseif ($tag[$level-1][2] != $tag[$level][2]) {\n                    trigger_error(gTxt('mismatch_open_close_tag', array(\n                        '{from}' => $outside[$level],\n                        '{to}'   => $chunk,\n                    )), E_USER_WARNING);\n                }\n\n                if ($count[$level] > 2) {\n                    $sha = txp_hash($inside[$level]);\n                    txp_fill_parsed($sha, $tags[$level], $order[$level], $count[$level], $else[$level]);\n                }\n    \n                $level--;\n                $tags[$level][] = array($outside[$level+1], $tag[$level][2], trim($tag[$level][4]), $inside[$level+1], $chunk);\n                $inside[$level] .= $inside[$level+1].$chunk;\n            }\n        }\n\n        $chunk = ++$i < $last ? $parsed[$i] : '';\n        $tags[$level][] = $chunk;\n        $inside[$level] .= $chunk;\n    }\n\n    txp_fill_parsed($hash, $tags[0], $order[0], $count[0] + 2, $else[0]);\n\n    return true;\n}\n\n/** Auxiliary **/\n\nfunction txp_fill_parsed($sha, $tags, $order, $count, $else) {\n    global $txp_parsed, $txp_else;\n\n    $txp_parsed[$sha] = $tags;\n    $txp_else[$sha] = array($else > 0 ? $else : $count, $count - 2);\n\n    if (!empty($order)) {\n        $pre = array_filter($order, function ($v) {return $v > 0;});\n        $post = array_filter($order, function ($v) {return $v < 0;});\n\n        if  ($pre) {\n            asort($pre);\n        }\n\n        if  ($post) {\n            asort($post);\n        }\n\n        $txp_else[$sha]['test'] = $post ? array_merge(array_keys($pre), array(0), array_keys($post)) : ($pre ? array_keys($pre) : null);\n    }\n}\n\n\n/**\n * Extracts a statement from a if/else condition.\n *\n * @param   string  $thing     Statement in Textpattern tag markup presentation\n * @param   bool    $condition TRUE to return if statement, FALSE to else\n * @return  string             Either if or else statement\n * @since   4.8.2\n * @see     parse\n * @package TagParser\n * @example\n * echo getIfElse('true &lt;txp:else /&gt; false', 1 === 1);\n */\n\nfunction getIfElse($thing, $condition = true)\n{\n    global $txp_parsed, $txp_else;\n\n    if (!$thing || strpos($thing, ':else') === false) {\n        return $condition ? $thing : null;\n    }\n\n    $hash = txp_hash($thing);\n\n    if (!isset($txp_parsed[$hash]) && !txp_tokenize($thing, $hash)) {\n        return $condition ? $thing : null;\n    }\n\n    $tag = $txp_parsed[$hash];\n    list($first, $last) = $txp_else[$hash];\n\n    if ($condition) {\n        $last = $first - 2;\n        $first   = 1;\n    } elseif ($first <= $last) {\n        $first  += 2;\n    } else {\n        return null;\n    }\n\n    for ($out = $tag[$first - 1]; $first <= $last; $first++) {\n        $out .= $tag[$first][0].$tag[$first][3].$tag[$first][4].$tag[++$first];\n    }\n\n    return $out;\n}\n\n/**\n * Extracts a statement from a if/else condition to parse.\n *\n * @param   string  $thing     Statement in Textpattern tag markup presentation\n * @param   bool    $condition TRUE to return if statement, FALSE to else\n * @return  string             Either if or else statement\n * @deprecated in 4.6.0\n * @see     parse\n * @package TagParser\n * @example\n * echo parse(EvalElse('true &lt;txp:else /&gt; false', 1 === 1));\n */\n\nfunction EvalElse($thing, $condition)\n{\n    global $txp_atts;\n\n    if (!empty($txp_atts['not'])) {\n        $condition = empty($condition);\n        unset($txp_atts['not']);\n    }\n\n    if (empty($condition)) {\n        $txp_atts = null;\n    }\n\n    return (string)getIfElse($thing, $condition);\n}\n\n/**\n * Gets a form template's contents.\n *\n * The form template's reading method can be modified by registering a handler\n * to a 'form.fetch' callback event. Any value returned by the callback function\n * will be used as the form template markup.\n *\n * @param   array|string $name The form\n * @return  string\n * @package TagParser\n */\n\nfunction fetch_form($name, $theme = null)\n{\n    global $skin;\n    static $forms = array();\n\n    isset($theme) or $theme = $skin;\n    isset($forms[$theme]) or $forms[$theme] = array();\n    $fetch = is_array($name);\n\n    if ($fetch || !isset($forms[$theme][$name])) {\n        $names = $fetch ? array_diff($name, array_keys($forms[$theme])) : array($name);\n\n        if (has_handler('form.fetch')) {\n            foreach ($names as $name) {\n                $forms[$theme][$name] = callback_event('form.fetch', '', false, compact('name', 'skin', 'theme'));\n            }\n        } elseif ($fetch) {\n            $forms[$theme] += array_fill_keys($names, false);\n            $nameset = implode(',', quote_list($names));\n\n            if ($nameset and $rs = safe_rows_start('name, Form', 'txp_form', \"name IN (\".$nameset.\") AND skin = '\".doSlash($theme).\"'\")) {\n                while ($row = nextRow($rs)) {\n                    $forms[$theme][$row['name']] = $row['Form'];\n                }\n            }\n        } else {\n            $forms[$theme][$name] = safe_field('Form', 'txp_form', \"name ='\".doSlash($name).\"' AND skin = '\".doSlash($theme).\"'\");\n        }\n\n        foreach ($names as $form) {\n            if ($forms[$theme][$form] === false) {\n                trigger_error(gTxt('form_not_found', array('{list}' => $theme.'.'.$form)));\n            }\n        }\n    }\n\n    if (!$fetch) {\n        return $forms[$theme][$name];\n    }\n}\n\n/**\n * Parses a form template.\n *\n * @param   string $name The form\n * @return  string The parsed contents\n * @package TagParser\n */\n\nfunction parse_form($name, $theme = null)\n{\n    global $production_status, $skin, $txp_current_form, $trace;\n    static $stack = array(), $depth = null;\n\n    if ($depth === null) {\n        $depth = get_pref('form_circular_depth', 15);\n    }\n\n    isset($theme) or $theme = $skin;\n    $name = (string) $name;\n    $f = fetch_form($name, $theme);\n\n    if ($f === false) {\n        return false;\n    }\n\n    if (!isset($stack[$name])) {\n        $stack[$name] = 1;\n    } elseif ($stack[$name] >= $depth) {\n        trigger_error(gTxt('form_circular_reference', array('{name}' => $name)));\n\n        return '';\n    } else {\n        $stack[$name]++;\n    }\n\n    $old_form = $txp_current_form;\n    $txp_current_form = $name;\n\n    if ($production_status === 'debug') {\n        $trace->log(\"[Form: '$theme.$name']\");\n        $trace->log(\"[Nesting forms: '\".join(\"' / '\", array_keys(array_filter($stack))).\"'\".($stack[$name] > 1 ? '('.$stack[$name].')' : '').\"]\");\n    }\n\n    $out = parse($f);\n\n    $txp_current_form = $old_form;\n    $stack[$name]--;\n\n    return $out;\n}\n\n/**\n * Gets a page template's contents.\n *\n * The page template's reading method can be modified by registering a handler\n * to a 'page.fetch' callback event. Any value returned by the callback function\n * will be used as the template markup.\n *\n * @param   string      $name The template\n * @param   string      $theme The public theme\n * @return  string|bool The page template, or FALSE on error\n * @package TagParser\n * @since   4.6.0\n * @example\n * echo fetch_page('default');\n */\n\nfunction fetch_page($name, $theme)\n{\n    global $pretext, $trace;\n\n    if (empty($theme)) {\n        if (empty($pretext['skin'])) {\n            $pretext = safe_row(\"skin, page, css\", \"txp_section\", \"name='default'\") + $pretext;\n        }\n\n        $theme = $pretext['skin'];\n    }\n\n    if (has_handler('page.fetch')) {\n        $page = callback_event('page.fetch', '', false, compact('name', 'theme'));\n    } else {\n        $page = safe_field('user_html', 'txp_page', \"name = '\".doSlash($name).\"' AND skin = '\".doSlash($theme).\"'\");\n    }\n\n    if ($page === false) {\n        return false;\n    }\n\n    $trace->log(\"[Page: '$theme.$name']\");\n\n    return $page;\n}\n\n/**\n * Parses a page template.\n *\n * @param   string      $name  The template to parse\n * @param   string      $theme The public theme\n * @param   string      $page  Default content to parse\n * @return  string|bool The parsed page template, or FALSE on error\n * @since   4.6.0\n * @package TagParser\n * @example\n * echo parse_page('default');\n */\n\nfunction parse_page($name, $theme, $page = '')\n{\n    global $pretext, $trace, $is_form;\n\n    if (!$page) {\n        $page = fetch_page($name, $theme);\n    }\n\n    if ($page !== false) {\n        while ($pretext['secondpass'] <= (int)get_pref('secondpass', 1) && preg_match('@<(?:'.TXP_PATTERN.'):@', $page)) {\n            $is_form = 1;\n            $page = parse($page);\n            // the function so nice, he ran it twice\n            $pretext['secondpass']++;\n            $trace->log('[ ~~~ end of pass '.$pretext['secondpass'].' ~~~ ]');\n        }\n    }\n\n    return $page;\n}\n\n/**\n * Gets a HTML select field containing all categories, or sub-categories.\n *\n * @param   string $name Return specified parent category's sub-categories\n * @param   string $cat  The selected category option\n * @param   string $id   The HTML ID\n * @return  string|bool HTML select field or FALSE on error\n * @package Form\n */\n\nfunction event_category_popup($name, $cat = '', $id = '', $atts = array())\n{\n    $rs = getTree('root', $name);\n\n    if ($rs) {\n        return treeSelectInput('category', $rs, $cat, $id, 0, $atts);\n    }\n\n    return false;\n}\n\n/**\n * Gets a category's title.\n *\n * @param  string $name The category\n * @param  string $type Category's type. Either \"article\", \"file\", \"image\" or \"link\"\n * @return string|bool The title or FALSE on error\n */\n\nfunction fetch_category_title($name, $type = 'article')\n{\n    static $cattitles = array();\n    global $thiscategory;\n\n    if (isset($cattitles[$type][$name])) {\n        return $cattitles[$type][$name];\n    }\n\n    if (!empty($thiscategory['title']) && $thiscategory['name'] == $name && $thiscategory['type'] == $type) {\n        $cattitles[$type][$name] = $thiscategory['title'];\n\n        return $thiscategory['title'];\n    }\n\n    $f = safe_field(\"title\", 'txp_category', \"name = '\".doSlash($name).\"' AND type = '\".doSlash($type).\"'\");\n    $cattitles[$type][$name] = $f;\n\n    return $f;\n}\n\n/**\n * Gets a section's title.\n *\n * @param  string $name The section\n * @return string|bool The title or FALSE on error\n */\n\nfunction fetch_section_title($name)\n{\n    static $sectitles = array();\n    global $thissection, $txp_sections;\n\n    // Try cache.\n    if (isset($sectitles[$name])) {\n        return $sectitles[$name];\n    }\n\n    if (!empty($thissection) && $thissection['name'] == $name) {\n        return $thissection['title'];\n    } elseif ($name == 'default' or empty($name)) {\n        return '';\n    } elseif (isset($txp_sections[$name])) {\n        return $sectitles[$name] = $txp_sections[$name]['title'];\n    }\n\n    $f = safe_field(\"title\", 'txp_section', \"name = '\".doSlash($name).\"'\");\n\n    return $sectitles[$name] = $f;\n}\n\n/**\n * Updates an article's comment count.\n *\n * @param   int $id The article\n * @return  bool\n * @package Comment\n */\n\nfunction update_comments_count($id)\n{\n    $id = assert_int($id);\n    $thecount = safe_field(\"COUNT(*)\", 'txp_discuss', \"parentid = '\".$id.\"' AND visible = \".VISIBLE);\n    $thecount = assert_int($thecount);\n    $updated = safe_update('textpattern', \"comments_count = \".$thecount, \"ID = '\".$id.\"'\");\n\n    return ($updated) ? true : false;\n}\n\n/**\n * Recalculates and updates comment counts.\n *\n * @param   array $parentids List of articles to update\n * @package Comment\n */\n\nfunction clean_comment_counts($parentids)\n{\n    $parentids = array_map('assert_int', $parentids);\n    $parentids = array_filter($parentids);\n\n    if ($parentids) {\n        $rs = safe_rows_start(\"parentid, COUNT(*) AS thecount\", 'txp_discuss', \"parentid IN (\".implode(',', $parentids).\") AND visible = \".VISIBLE.\" GROUP BY parentid\");\n\n        if (!$rs) {\n            return;\n        }\n\n        $updated = array();\n\n        while ($a = nextRow($rs)) {\n            safe_update('textpattern', \"comments_count = \".$a['thecount'], \"ID = \".$a['parentid']);\n            $updated[] = $a['parentid'];\n        }\n\n        // We still need to update all those, that have zero comments left.\n        $leftover = array_diff($parentids, $updated);\n\n        if ($leftover) {\n            safe_update('textpattern', \"comments_count = 0\", \"ID IN (\".implode(',', $leftover).\")\");\n        }\n    }\n}\n\n/**\n * Parses and formats comment message using Textile.\n *\n * @param   string $msg The comment message\n * @return  string HTML markup\n * @package Comment\n */\n\nfunction markup_comment($msg)\n{\n    $textile = new \\Textpattern\\Textile\\RestrictedParser();\n\n    return $textile->parse($msg);\n}\n\n/**\n * Updates site's last modification date.\n *\n * When this action is performed, it will trigger a\n * 'site.update > {event}' callback event and pass\n * any record set that triggered the update, along\n * with the exact time the update was triggered.\n *\n * @param   $trigger Textpattern event or step that triggered the update\n * @param   $rs      Record set data at the time of update\n * @package Pref\n * @example\n * update_lastmod();\n */\n\nfunction update_lastmod($trigger = '', $rs = array())\n{\n    $whenStamp = time();\n    $whenDate = date('Y-m-d H:i:s', $whenStamp);\n\n    safe_upsert('txp_prefs', \"val = '$whenDate'\", \"name = 'lastmod'\");\n    callback_event('site.update', $trigger, 0, $rs, compact('whenStamp', 'whenDate'));\n}\n\n/**\n * Gets the site's last modification date.\n *\n * @param   int $unix_ts UNIX timestamp\n * @return  int UNIX timestamp\n * @package Pref\n */\n\nfunction get_lastmod($unix_ts = null)\n{\n    if ($unix_ts === null) {\n        $unix_ts = @strtotime(get_pref('lastmod'));\n    }\n\n    // Check for future articles that are now visible.\n    if (txpinterface === 'public' && $max_article = safe_field(\"UNIX_TIMESTAMP(Posted)\", 'textpattern', \"Posted <= \".now('posted').\" AND Status >= 4 ORDER BY Posted DESC LIMIT 1\")) {\n        $unix_ts = max($unix_ts, $max_article);\n    }\n\n    return $unix_ts;\n}\n\n/**\n * Sets headers.\n *\n * @param   array $headers    'name' => 'value'\n * @param   bool  $rewrite    If TRUE, rewrites existing headers\n */\n\nfunction set_headers($headers = array('Content-Type' => 'text/html; charset=utf-8'), $rewrite = false)\n{\n    if (headers_sent()) {\n        return;\n    }\n\n    $rewrite = (int)$rewrite;\n    $out = $headers_low = array();\n\n    if (($rewrite != 1 || in_array(true, $headers, true)) && $headers_list = headers_list()) {\n        foreach ($headers_list as $header) {\n            list($name, $value) = explode(':', $header, 2) + array(null, null);\n            $headers_low[strtolower(trim($name))] = $value;\n        }\n    }\n\n    foreach ($headers as $name => $header) {\n        $name_low = strtolower(trim($name));\n\n        if ((string)$header === '') {\n            !$rewrite or header_remove($name && $name != 1 ? $name : null);\n        } elseif ($header === true) {\n            if ($name == '' || $name == 1) {\n                $out = array_merge($out, $headers_low);\n            } elseif (isset($headers_low[$name_low])) {\n                $out[$name_low] = $headers_low[$name_low];\n            }\n        } elseif ($name == 1) {\n            txp_status_header($header);\n        } elseif ($rewrite == 1 || !isset($headers_low[$name_low])) {\n            header($name ? $name.': '.$header : $header);\n        } elseif ($rewrite) {\n            $header = implode(', ', do_list_unique($headers_low[$name_low].','.$header));\n            header($name ? $name.': '.$header : $header);\n        }\n    }\n\n    return $out ? $out : null;\n}\n\n/**\n * Sends and handles a lastmod header.\n *\n * @param   int|null $unix_ts The last modification date as a UNIX timestamp\n * @param   bool     $exit    If TRUE, terminates the script\n * @return  array|null Array of sent HTTP status and the lastmod header, or NULL\n * @package Pref\n */\n\nfunction handle_lastmod($unix_ts = null, $exit = true)\n{\n    // Disable caching when not in production\n    if (get_pref('production_status') != 'live') {\n        header('Cache-Control: no-cache, no-store, max-age=0');\n    } elseif (get_pref('send_lastmod')) {\n        $unix_ts = get_lastmod($unix_ts);\n\n        // Make sure lastmod isn't in the future.\n        $unix_ts = min($unix_ts, time());\n\n        $last = safe_strftime('rfc822', $unix_ts, 1);\n        header(\"Last-Modified: $last\");\n\n        $etag = base_convert($unix_ts, 10, 32);\n        header('ETag: \"' . $etag . '\"');\n\n        // Get timestamp from request caching headers\n        if (isset($_SERVER['HTTP_IF_MODIFIED_SINCE'])) {\n            $hims = $_SERVER['HTTP_IF_MODIFIED_SINCE'];\n            $imsd = ($hims) ? strtotime($hims) : 0;\n        } elseif (isset($_SERVER['HTTP_IF_NONE_MATCH'])) {\n            $hinm = trim(trim($_SERVER['HTTP_IF_NONE_MATCH']), '\"');\n            $hinm_apache_gzip_workaround = explode('-gzip', $hinm);\n            $hinm_apache_gzip_workaround = $hinm_apache_gzip_workaround[0];\n            $inmd = ($hinm) ? base_convert($hinm_apache_gzip_workaround, 32, 10) : 0;\n        }\n\n        // Check request timestamps against the current timestamp\n        if ((isset($imsd) && $imsd >= $unix_ts) ||\n            (isset($inmd) && $inmd >= $unix_ts)) {\n            log_hit('304');\n\n            header('Content-Length: 0');\n\n            txp_status_header('304 Not Modified');\n\n            if ($exit) {\n                exit();\n            }\n\n            return array('304', $last);\n        }\n\n        return array('200', $last);\n    }\n}\n\n/**\n * Gets preferences as an array.\n *\n * Returns preference values from the database as an array. Shouldn't be used to\n * retrieve selected preferences, see get_pref() instead.\n *\n * By default only the global preferences are returned.\n * If the optional user name parameter is supplied, the private preferences\n * for that user are returned.\n *\n * @param   string $user User name.\n * @return  array\n * @package Pref\n * @access  private\n * @see     get_pref()\n */\n\nfunction get_prefs($user = '')\n{\n    $out = array();\n    $user = implode(',', (array) quote_list($user));\n\n    $r = safe_rows_start(\"name, val\", 'txp_prefs', \"user_name IN (\".$user.\") ORDER BY FIELD(user_name, \".$user.\")\");\n\n    if ($r) {\n        while ($a = nextRow($r)) {\n            $out[$a['name']] = $a['val'];\n        }\n    }\n\n    return $out;\n}\n\n/**\n * Creates or updates a preference.\n *\n * @param   string $name       The name\n * @param   string $val        The value\n * @param   string $event      The section the preference appears in\n * @param   int    $type       Either PREF_CORE, PREF_PLUGIN, PREF_HIDDEN\n * @param   string $html       The HTML control type the field uses. Can take a custom function name\n * @param   int    $position   Used to sort the field on the Preferences panel\n * @param   bool   $is_private If PREF_PRIVATE, is created as a user pref\n * @return  bool FALSE on error\n * @package Pref\n * @example\n * if (set_pref('myPref', 'value'))\n * {\n *     echo \"'myPref' created or updated.\";\n * }\n */\n\nfunction set_pref($name, $val, $event = 'publish', $type = PREF_CORE, $html = 'text_input', $position = 0, $is_private = PREF_GLOBAL)\n{\n    global $prefs;\n\n    $prefs[$name] = $val;\n    $user_name = null;\n\n    if ($is_private == PREF_PRIVATE) {\n        $user_name = PREF_PRIVATE;\n    }\n\n    if (pref_exists($name, $user_name)) {\n        return update_pref($name, $val, null, null, null, null, $user_name);\n    }\n\n    return create_pref($name, $val, $event, $type, $html, $position, $user_name);\n}\n\n/**\n * Gets a preference string.\n *\n * Prefers global system-wide preferences over a user's private preferences.\n *\n * @param   string $thing   The named variable\n * @param   mixed  $default Used as a replacement if named pref isn't found\n * @param   bool   $from_db If TRUE checks database opposed $prefs variable in memory\n * @return  string Preference value or $default\n * @package Pref\n * @example\n * if (get_pref('enable_xmlrpc_server'))\n * {\n *     echo \"XML-RPC server is enabled.\";\n * }\n */\n\nfunction get_pref($thing, $default = '', $from_db = false)\n{\n    global $prefs, $txp_user;\n\n    if ($from_db) {\n        $name = doSlash($thing);\n        $user_name = doSlash($txp_user);\n\n        $field = safe_field(\n            \"val\",\n            'txp_prefs',\n            \"name = '$name' AND (user_name = '' OR user_name = '$user_name') ORDER BY user_name LIMIT 1\"\n        );\n\n        if ($field !== false) {\n            $prefs[$thing] = $field;\n        }\n    }\n\n    if (isset($prefs[$thing])) {\n        return $prefs[$thing];\n    }\n\n    return $default;\n}\n\n/**\n * Removes a preference string.\n *\n * Removes preference strings based on the given arguments. Use NULL to omit an argument.\n *\n * @param   string|null      $name      The preference string name\n * @param   string|null      $event     The preference event\n * @param   string|null|bool $user_name The owner. If PREF_PRIVATE, the current user\n * @return  bool TRUE on success\n * @since   4.6.0\n * @package Pref\n * @example\n * if (remove_pref(null, 'myEvent'))\n * {\n *     echo \"Removed all preferences from 'myEvent'.\";\n * }\n */\n\nfunction remove_pref($name = null, $event = null, $user_name = null)\n{\n    global $txp_user;\n\n    $sql = array();\n\n    if ($user_name === PREF_PRIVATE) {\n        if (!$txp_user) {\n            return false;\n        }\n\n        $user_name = $txp_user;\n    }\n\n    if ($user_name !== null) {\n        $sql[] = \"user_name = '\".doSlash((string) $user_name).\"'\";\n    }\n\n    if ($event !== null) {\n        $sql[] = \"event = '\".doSlash($event).\"'\";\n    }\n\n    if ($name !== null) {\n        $sql[] = \"name = '\".doSlash($name).\"'\";\n    }\n\n    if ($sql) {\n        return safe_delete('txp_prefs', join(\" AND \", $sql));\n    }\n\n    return false;\n}\n\n/**\n * Checks if a preference string exists.\n *\n * Searches for matching preference strings based on the given arguments.\n *\n * The $user_name argument can be used to limit the search to a specific user,\n * or to global and private strings. If NULL, matches are searched from both\n * private and global strings.\n *\n * @param   string           $name      The preference string name\n * @param   string|null|bool $user_name Either the username, NULL, PREF_PRIVATE or PREF_GLOBAL\n * @return  bool TRUE if the string exists, or FALSE on error\n * @since   4.6.0\n * @package Pref\n * @example\n * if (pref_exists('myPref'))\n * {\n *     echo \"'myPref' exists.\";\n * }\n */\n\nfunction pref_exists($name, $user_name = null)\n{\n    global $txp_user;\n\n    $sql = array();\n    $sql[] = \"name = '\".doSlash($name).\"'\";\n\n    if ($user_name === PREF_PRIVATE) {\n        if (!$txp_user) {\n            return false;\n        }\n\n        $user_name = $txp_user;\n    }\n\n    if ($user_name !== null) {\n        $sql[] = \"user_name = '\".doSlash((string) $user_name).\"'\";\n    }\n\n    if (safe_row(\"name\", 'txp_prefs', join(\" AND \", $sql))) {\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Creates a preference string.\n *\n * When a string is created, will trigger a 'preference.create > done' callback event.\n *\n * @param   string      $name       The name\n * @param   string      $val        The value\n * @param   string      $event      The section the preference appears in\n * @param   int         $type       Either PREF_CORE, PREF_PLUGIN, PREF_HIDDEN\n * @param   string      $html       The HTML control type the field uses. Can take a custom function name\n * @param   int         $position   Used to sort the field on the Preferences panel\n * @param   string|bool $user_name  The user name, PREF_GLOBAL or PREF_PRIVATE\n * @return  bool TRUE if the string exists, FALSE on error\n * @since   4.6.0\n * @package Pref\n * @example\n * if (create_pref('myPref', 'value', 'site', PREF_PLUGIN, 'text_input', 25))\n * {\n *     echo \"'myPref' created.\";\n * }\n */\n\nfunction create_pref($name, $val, $event = 'publish', $type = PREF_CORE, $html = 'text_input', $position = 0, $user_name = PREF_GLOBAL)\n{\n    global $txp_user;\n\n    if ($user_name === PREF_PRIVATE) {\n        if (!$txp_user) {\n            return false;\n        }\n\n        $user_name = $txp_user;\n    }\n\n    if (pref_exists($name, $user_name)) {\n        return true;\n    }\n\n    $val = is_scalar($val) ? (string)$val : json_encode($val, TEXTPATTERN_JSON);\n\n    if (\n        safe_insert(\n            'txp_prefs',\n            \"name = '\".doSlash($name).\"',\n            val = '\".doSlash($val).\"',\n            event = '\".doSlash($event).\"',\n            html = '\".doSlash($html).\"',\n            type = \".intval($type).\",\n            position = \".intval($position).\",\n            user_name = '\".doSlash((string) $user_name).\"'\"\n        ) === false\n    ) {\n        return false;\n    }\n\n    callback_event('preference.create', 'done', 0, compact('name', 'val', 'event', 'type', 'html', 'position', 'user_name'));\n\n    return true;\n}\n\n/**\n * Updates a preference string.\n *\n * Updates a preference string's properties. The $name and $user_name\n * arguments are used for selecting the updated string, and rest of the\n * arguments take the new values. Use NULL to omit an argument.\n *\n * When a string is updated, will trigger a 'preference.update > done' callback event.\n *\n * @param   string           $name       The update preference string's name\n * @param   string|null      $val        The value\n * @param   string|null      $event      The section the preference appears in\n * @param   int|null         $type       Either PREF_CORE, PREF_PLUGIN, PREF_HIDDEN\n * @param   string|null      $html       The HTML control type the field uses. Can take a custom function name\n * @param   int|null         $position   Used to sort the field on the Preferences panel\n * @param   string|bool|null $user_name  The updated string's owner, PREF_GLOBAL or PREF_PRIVATE\n * @return  bool             FALSE on error\n * @since   4.6.0\n * @package Pref\n * @example\n * if (update_pref('myPref', 'New value.'))\n * {\n *     echo \"Updated 'myPref' value.\";\n * }\n */\n\nfunction update_pref($name, $val = null, $event = null, $type = null, $html = null, $position = null, $user_name = PREF_GLOBAL)\n{\n    global $txp_user;\n\n    $where = $set = array();\n    $where[] = \"name = '\".doSlash($name).\"'\";\n\n    if ($user_name === PREF_PRIVATE) {\n        if (!$txp_user) {\n            return false;\n        }\n\n        $user_name = $txp_user;\n    }\n\n    if ($user_name !== null) {\n        $where[] = \"user_name = '\".doSlash((string) $user_name).\"'\";\n    }\n\n    if (isset($val)) {\n        $val = is_scalar($val) ? (string)$val : json_encode($val, TEXTPATTERN_JSON);\n    }\n\n    foreach (array('val', 'event', 'type', 'html', 'position') as $field) {\n        if ($$field !== null) {\n            $set[] = $field.\" = '\".doSlash($$field).\"'\";\n        }\n    }\n\n    if ($set && safe_update('txp_prefs', join(', ', $set), join(\" AND \", $where))) {\n        callback_event('preference.update', 'done', 0, compact('name', 'val', 'event', 'type', 'html', 'position', 'user_name'));\n\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Renames a preference string.\n *\n * When a string is renamed, will trigger a 'preference.rename > done' callback event.\n *\n * @param   string $newname   The new name\n * @param   string $name      The current name\n * @param   string $user_name Either the username, PREF_GLOBAL or PREF_PRIVATE\n * @return  bool FALSE on error\n * @since   4.6.0\n * @package Pref\n * @example\n * if (rename_pref('mynewPref', 'myPref'))\n * {\n *     echo \"Renamed 'myPref' to 'mynewPref'.\";\n * }\n */\n\nfunction rename_pref($newname, $name, $user_name = null)\n{\n    global $txp_user;\n\n    $where = array();\n    $where[] = \"name = '\".doSlash($name).\"'\";\n\n    if ($user_name === PREF_PRIVATE) {\n        if (!$txp_user) {\n            return false;\n        }\n\n        $user_name = $txp_user;\n    }\n\n    if ($user_name !== null) {\n        $where[] = \"user_name = '\".doSlash((string) $user_name).\"'\";\n    }\n\n    if (safe_update('txp_prefs', \"name = '\".doSlash($newname).\"'\", join(\" AND \", $where))) {\n        callback_event('preference.rename', 'done', 0, compact('newname', 'name', 'user_name'));\n\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Gets a list of custom fields.\n *\n * @return  array\n * @package CustomField\n */\n\nfunction getCustomFields()\n{\n    global $prefs;\n    static $out = null;\n\n    // Have cache?\n    if (!is_array($out)) {\n        $cfs = preg_grep('/^custom_\\d+_set/', array_keys($prefs));\n        $out = array();\n\n        foreach ($cfs as $name) {\n            preg_match('/(\\d+)/', $name, $match);\n\n            if ($prefs[$name] !== '') {\n                $out[$match[1]] = strtolower($prefs[$name]);\n            }\n        }\n\n        ksort($out, SORT_NUMERIC);\n    }\n\n    return $out;\n}\n\n/**\n * Build a query qualifier to filter non-matching custom fields from the\n * result set.\n *\n * @param   array $custom An array of 'custom_field_name' => field_number tuples\n * @param   array $pairs  Filter criteria: An array of 'name' => value tuples\n * @return  bool|string An SQL qualifier for a query's 'WHERE' part\n * @package CustomField\n */\n\nfunction buildCustomSql($custom, $pairs, $exclude = array())\n{\n    if ($pairs) {\n        foreach ($pairs as $k => $val) {\n            $no = array_search($k, $custom);\n\n            if ($no !== false) {\n                $not = ($exclude === true || isset($exclude[$k])) ? 'NOT ' : '';\n                $field = is_numeric($no) ? \"custom_{$no}\" : $no;\n\n                if ($val === true) {\n                    $out[] = \"({$not}{$field} != '')\";\n                } else {\n                    $val = doSlash($val);\n                    $parts = array();\n\n                    foreach ((array)$val as $v) {\n                        list($from, $to) = explode('%%', $v, 2) + array(null, null);\n\n                        if (!isset($to)) {\n                            $parts[] = \"{$not}{$field} LIKE '$from'\";\n                        } elseif ($from !== '') {\n                            $parts[] = $to === '' ? \"{$not}{$field} >= '$from'\" :  \"{$not}{$field} BETWEEN '$from' AND '$to'\";\n                        } elseif ($to !== '') {\n                            $parts[] = \"{$not}{$field} <= '$to'\";\n                        }\n                    }\n\n                    if ($parts) {\n                        $out[] = '('.join($not ? ' AND ' : ' OR ', $parts).')';\n                    }\n                }\n            }\n        }\n    }\n\n    return !empty($out) ? ' AND '.join(' AND ', $out).' ' : false;\n}\n\n/**\n * Build a query qualifier to filter time fields from the\n * result set.\n *\n * @param   string $month A starting time point\n * @param   string $time  A time offset\n * @param   string $field The field to filter\n * @return  string An SQL qualifier for a query's 'WHERE' part\n */\n\nfunction buildTimeSql($month, $time, $field = 'Posted')\n{\n    $safe_field = '`'.doSlash($field).'`';\n    $timeq = '1';\n\n    if ($month === 'past' || $month === 'any' || $month === 'future') {\n        if ($month === 'past') {\n            $timeq = \"$safe_field <= \".now($field);\n        } elseif ($month === 'future') {\n            $timeq = \"$safe_field > \".now($field);\n        }\n    } elseif ($time === 'past' || $time === 'any' || $time === 'future') {\n        if ($time === 'past') {\n            $timeq = \"$safe_field <= \".now($field);\n        } elseif ($time === 'future') {\n            $timeq = \"$safe_field > \".now($field);\n        }\n\n        if ($month) {\n            $offset = date('P', strtotime($month));\n            $dateClause = ($offset ? \"CONVERT_TZ($safe_field, @@session.time_zone, '$offset')\" : $safe_field).\" LIKE '\".doSlash($month).\"%'\";\n            $timeq .= \" AND $dateClause\";\n        }\n    } elseif (strpos($time, '%') !== false) {\n        $start = $month ? strtotime($month) : time() or $start = time();\n        $offset = date('P', $start);\n        $timeq = ($offset ? \"CONVERT_TZ($safe_field, @@session.time_zone, '$offset')\" : $safe_field).\" LIKE '\".doSlash(safe_strftime($time, $start)).\"%'\";\n    } else {\n        $start = $month ? strtotime($month) : false;\n\n        if ($start === false) {\n            $from = $month ? \"'\".doSlash($month).\"'\" : now($field);\n            $start = time();\n        } else {\n            $from = \"FROM_UNIXTIME($start)\";\n        }\n\n        if ($time === 'since') {\n            $timeq = \"$safe_field > $from\";\n        } elseif ($time === 'until') {\n            $timeq = \"$safe_field <= $from\";\n        } else {\n            $stop = strtotime($time, $start) or $stop = time();\n\n            if ($start > $stop) {\n                list($start, $stop) = array($stop, $start);\n            }\n\n            $timeq = ($start == $stop ?\n                \"$safe_field = FROM_UNIXTIME($start)\" :\n                \"$safe_field BETWEEN FROM_UNIXTIME($start) AND FROM_UNIXTIME($stop)\"\n            );\n        }\n    }\n\n    return $timeq;\n}\n\n/**\n * Sends a HTTP status header.\n *\n * @param   string $status The HTTP status code\n * @package Network\n * @example\n * txp_status_header('403 Forbidden');\n */\n\nfunction txp_status_header($status = '200 OK')\n{\n    if (IS_FASTCGI) {\n        header(\"Status: $status\");\n    } elseif (serverSet('SERVER_PROTOCOL') == 'HTTP/1.0') {\n        header(\"HTTP/1.0 $status\");\n    } else {\n        header(\"HTTP/1.1 $status\");\n    }\n}\n\n/**\n * Terminates normal page rendition and outputs an error page.\n *\n * @param   string|array $msg    The error message\n * @param   string       $status HTTP status code\n * @param   string       $url    Redirects to the specified URL. Can be used with $status of 301, 302 and 307\n * @package Tag\n */\n\nfunction txp_die($msg, $status = '503', $url = '')\n{\n    global $connected, $txp_error_message, $txp_error_status, $txp_error_code, $pretext, $production_status, $trace;\n\n    // Make it possible to call this function as a tag, e.g. in an article\n    // <txp:txp_die status=\"410\" />.\n    if (is_array($msg)) {\n        extract(lAtts(array(\n            'msg'    => '',\n            'status' => '503',\n            'url'    => '',\n        ), $msg));\n    }\n\n    // Intentionally incomplete - just the ones we're likely to use.\n    $codes = array(\n        '200' => 'OK',\n        '301' => 'Moved Permanently',\n        '302' => 'Found',\n        '303' => 'See Other',\n        '304' => 'Not Modified',\n        '307' => 'Temporary Redirect',\n        '308' => 'Permanent Redirect',\n        '401' => 'Unauthorized',\n        '403' => 'Forbidden',\n        '404' => 'Not Found',\n        '410' => 'Gone',\n        '414' => 'Request-URI Too Long',\n        '451' => 'Unavailable For Legal Reasons',\n        '500' => 'Internal Server Error',\n        '501' => 'Not Implemented',\n        '503' => 'Service Unavailable'\n    );\n\n    if ($status) {\n        if (isset($codes[strval($status)])) {\n            $status = strval($status).' '.$codes[$status];\n        }\n\n        txp_status_header($status);\n    }\n\n    $code = (int) $status;\n\n    callback_event('txp_die', $code, 0, $url);\n\n    // Redirect with status.\n    if ($url && in_array($code, array(301, 302, 303, 307, 308))) {\n        ob_end_clean();\n        header(\"Location: $url\", true, $code);\n        die('<html><head><meta http-equiv=\"refresh\" content=\"0;URL='.txpspecialchars($url).'\"></head><body><p>Document has <a href=\"'.txpspecialchars($url).'\">moved here</a>.</p></body></html>');\n    }\n\n    $out = false;\n    $skin = empty($pretext['skin']) ? null : $pretext['skin'];\n\n    if ($connected && @txpinterface == 'public') {\n        $out = fetch_page(\"error_{$code}\", $skin) or $out = fetch_page('error_default', $skin);\n    }\n\n    if ($out === false) {\n        $out = <<<eod\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n   <meta charset=\"utf-8\">\n   <meta name=\"robots\" content=\"noindex\">\n   <title>Textpattern Error: <txp:error_status /></title>\n</head>\n<body>\n    <p><txp:error_message /></p>\n</body>\n</html>\neod;\n    }\n\n    header(\"Content-Type: text/html; charset=utf-8\");\n    $debug = $production_status === 'live' ?\n        '' :\n        $trace->summary().($production_status === 'debug' ? $trace->result() : '');\n\n    if (is_callable('parse')) {\n        $txp_error_message = $msg;\n        $txp_error_status = $status;\n        $txp_error_code = $code;\n        set_error_handler(\"tagErrorHandler\");\n        die(parse($out).$debug);\n    } else {\n        $out = preg_replace(\n            array('@<txp:error_status[^>]*/>@', '@<txp:error_message[^>]*/>@'),\n            array($status, $msg),\n            $out\n        );\n\n        die($out.$debug);\n    }\n}\n\n/**\n * Get field => alias array.\n *\n * @param   string $match\n * @return  array()\n * @since   4.8.0\n * @package TagParser\n */\n\nfunction parse_qs($match, $sep='=')\n{\n    $pairs = array();\n\n    foreach (do_list_unique($match) as $chunk) {\n        $name = strtok($chunk, $sep);\n        $alias = strtok($sep);\n        $pairs[strtolower($name)] = $alias;\n    };\n\n    return $pairs;\n}\n\n/**\n * Gets a URL-encoded and HTML entity-escaped query string for a URL.\n *\n * Builds a HTTP query string from an associative array.\n *\n * @param   array $q The parameters for the query\n * @return  string The query, including starting \"?\".\n * @package URL\n * @example\n * echo join_qs(array('param1' => 'value1', 'param2' => 'value2'));\n */\n\nfunction join_qs($q, $sep = '&amp;')\n{\n    $qs = array();\n    $sql = $sep !== '&amp;';\n\n    foreach ($q as $k => $v) {\n        if (is_array($v)) {\n            $v = join(',', $v);\n        }\n\n        if ($k && (string) $v !== '') {\n            $qs[$k] = $sql ? \"$k = $v\" : urlencode($k).'='.urlencode($v);\n        }\n    }\n\n    if (!isset($sep)) {\n        return $qs;\n    }\n\n    $str = join($sep, $qs);\n\n    return  $str ? ($sql ? '' : '?').$str : '';\n}\n\n/**\n * Builds a HTML attribute list from an array.\n *\n * Takes an array of raw HTML attributes, and returns a properly\n * sanitised HTML attribute string for use in a HTML tag.\n *\n * Internally handles HTML boolean attributes, array lists and query strings.\n * If an attributes value is set as a boolean, the attribute is considered\n * as one too. If a value is NULL, it's omitted and the attribute is added\n * without a value. An array value is converted to a space-separated list,\n * or for 'href' and 'src' to a URL encoded query string.\n *\n * @param   array|string  $atts  HTML attributes\n * @param   int           $flags TEXTPATTERN_STRIP_EMPTY_STRING\n * @return  string HTML attribute list\n * @since   4.6.0\n * @package HTML\n * @example\n * echo join_atts(array('class' => 'myClass', 'disabled' => true));\n */\n\nfunction join_atts($atts, $flags = TEXTPATTERN_STRIP_EMPTY_STRING, $glue = ' ')\n{\n    if (!is_array($atts)) {\n        return $atts ? ' '.trim($atts) : '';\n    }\n\n    $list = '';\n    $txp = $flags & TEXTPATTERN_STRIP_TXP;\n\n    foreach ($atts as $name => $value) {\n        if (($flags & TEXTPATTERN_STRIP_EMPTY && !$value) || ($value === false) || ($txp && $value === null)) {\n            continue;\n        } elseif ($value === null || $txp && $value === true) {\n            $list .= ' '.$name;\n            continue;\n        } elseif (is_array($value)) {\n            if ($name == 'href' || $name == 'src') {\n                $value = join_qs($value);\n            } else {\n                $value = txpspecialchars(join($glue, $value));\n            }\n        } elseif ($name != 'href' && $name != 'src') {\n            $value = txpspecialchars($value === true ? $name : $value);\n        } else {\n            $value = txpspecialchars(str_replace('&amp;', '&', $value));\n        }\n\n        if (!($flags & TEXTPATTERN_STRIP_EMPTY_STRING && $value === '')) {\n            $list .= ' '.$name.'=\"'.$value.'\"';\n        }\n    }\n\n    return $list;\n}\n\n/**\n * Builds a page URL from an array of parameters.\n *\n * The $inherit can be used to add parameters to an existing url, e.g:\n * pagelinkurl(array('pg' => 2), $pretext).\n *\n * Cannot be used to link to an article. See permlinkurl() and permlinkurl_id() instead.\n *\n * @param   array $parts   The parts used to construct the URL\n * @param   array $inherit Can be used to add parameters to an existing url\n * @return  string\n * @see     permlinkurl()\n * @see     permlinkurl_id()\n * @package URL\n */\n\nfunction pagelinkurl($parts, $inherit = array(), $url_mode = null)\n{\n    global $permlink_mode, $prefs, $txp_context, $txp_sections;\n\n    // Link to an article.\n    if (!empty($parts['id'])) {\n        return permlinkurl_id($parts['id']);\n    }\n\n    $hu = isset($prefs['url_base']) ? $prefs['url_base'] : hu;\n    $keys = $parts;\n    !is_array($inherit) or $keys += $inherit;\n    empty($txp_context) or $keys += $txp_context;\n    unset($keys['id']);\n\n    if (isset($prefs['custom_url_func'])\n        && is_callable($prefs['custom_url_func'])\n        && ($url = call_user_func($prefs['custom_url_func'], $keys, PAGELINKURL)) !== false) {\n        return $url;\n    }\n\n    if (isset($keys['s'])) {\n        if (!isset($url_mode) && isset($txp_sections[$keys['s']])) {\n            $url_mode = $txp_sections[$keys['s']]['permlink_mode'];\n        }\n\n        if ($keys['s'] == 'default') {\n            unset($keys['s']);\n        }\n    }\n\n    if (empty($url_mode)) {\n        $url_mode = $permlink_mode;\n    }\n\n    // 'article' context is implicit, no need to add it to the page URL.\n    if (isset($keys['context']) && $keys['context'] == 'article') {\n        unset($keys['context']);\n    }\n\n    $numkeys = array();\n\n    foreach ($keys as $key => $v) {\n        if (is_numeric($key)) {\n            $numkeys[$key] = urlencode($v).'/';\n            unset($keys[$key]);\n        }\n    }\n\n    if ($url_mode == 'messy') {\n        $url = 'index.php';\n    } else {\n        // All clean URL modes use the same schemes for list pages.\n        $url = '';\n\n        if (!empty($keys['rss'])) {\n            $url = 'rss/';\n            unset($keys['rss']);\n        } elseif (!empty($keys['atom'])) {\n            $url = 'atom/';\n            unset($keys['atom']);\n        } elseif (!empty($keys['s'])) {\n            $url = urlencode($keys['s']).'/';\n            unset($keys['s']);\n            if (!empty($keys['c']) && ($url_mode == 'section_category_title' || $url_mode == 'breadcrumb_title')) {\n                $catpath = $url_mode == 'breadcrumb_title' ?\n                    array_column(getRootPath($keys['c'], empty($keys['context']) ? 'article' : $keys['context']), 'name') :\n                    array($keys['c']);\n                $url .= implode('/', array_map('urlencode', array_reverse($catpath))).'/';\n                unset($keys['c']);\n            } elseif (!empty($keys['month']) && $url_mode == 'year_month_day_title' && is_date($keys['month'])) {\n                $url .= implode('/', explode('-', urlencode($keys['month']))).'/';\n                unset($keys['month']);\n            }\n        } elseif (!empty($keys['author']) && $url_mode != 'year_month_day_title') {\n            $ct = empty($keys['context']) ? '' : strtolower(urlencode(gTxt($keys['context'].'_context'))).'/';\n            $url = strtolower(urlencode(gTxt('author'))).'/'.$ct.urlencode($keys['author']).'/';\n            unset($keys['author'], $keys['context']);\n        } elseif (!empty($keys['c']) && $url_mode != 'year_month_day_title') {\n            $ct = empty($keys['context']) ? '' : strtolower(urlencode(gTxt($keys['context'].'_context'))).'/';\n            $url = strtolower(urlencode(gTxt('category'))).'/'.$ct;\n            $catpath = $url_mode == 'breadcrumb_title' ?\n                array_column(getRootPath($keys['c'], empty($keys['context']) ? 'article' : $keys['context']), 'name') :\n                array($keys['c']);\n            $url .= implode('/', array_map('urlencode', array_reverse($catpath))).'/';\n            unset($keys['c'], $keys['context']);\n        } elseif (!empty($keys['month']) && is_date($keys['month'])) {\n            $url = implode('/', explode('-', urlencode($keys['month']))).'/';\n            unset($keys['month']);\n        }\n    }\n\n    if (!empty($keys['context'])) {\n        $keys['context'] = gTxt($keys['context'].'_context');\n    }\n\n    return $hu.(empty($prefs['no_trailing_slash']) ? $url : rtrim($url, '/')).join_qs($keys);\n}\n\n/**\n * Gets a URL for the given article.\n *\n * If you need to generate a list of article URLs from already fetched table\n * rows, consider using permlinkurl() over this due to performance benefits.\n *\n * @param   int $id The article ID\n * @return  string The URL\n * @see     permlinkurl()\n * @package URL\n * @example\n * echo permlinkurl_id(12);\n */\n\nfunction permlinkurl_id($id)\n{\n    global $permlinks, $thisarticle;\n\n    $id = (int) $id;\n\n    if (isset($permlinks[$id])) {\n        return permlinkurl(array('id' => $id));\n    }\n\n    if (isset($thisarticle['thisid']) && $thisarticle['thisid'] == $id) {\n        return permlinkurl($thisarticle);\n    }\n\n    $rs = empty($id) ? array() : safe_row(\n        \"ID AS thisid, Section, Title, url_title, Category1, Category2, UNIX_TIMESTAMP(Posted) AS posted, UNIX_TIMESTAMP(Expires) AS expires\",\n        'textpattern',\n        \"ID = $id\"\n    );\n\n    return permlinkurl($rs);\n}\n\n/**\n * Generates an article URL from the given data array.\n *\n * @param   array $article_array An array consisting of keys 'thisid', 'section', 'title', 'url_title', 'posted', 'expires'\n * @return  string The URL\n * @package URL\n * @see     permlinkurl_id()\n * @example\n * echo permlinkurl_id(array(\n *     'thisid'    => 12,\n *     'section'   => 'blog',\n *     'url_title' => 'my-title',\n *     'posted'    => 1345414041,\n *     'expires'   => 1345444077\n * ));\n */\n\nfunction permlinkurl($article_array, $hu = null)\n{\n    global $permlink_mode, $prefs, $permlinks, $txp_sections;\n    static $internals = array('id', 's', 'context', 'pg', 'p'), $now = null,\n        $fields = array(\n            'thisid'    => null,\n            'id'        => null,\n            'title'     => null,\n            'url_title' => null,\n            'section'   => null,\n            'category1' => null,\n            'category2' => null,\n            'posted'    => null,\n            'uposted'   => null,\n            'expires'   => null,\n            'uexpires'  => null,\n        );\n\n    if (isset($prefs['custom_url_func'])\n        and is_callable($prefs['custom_url_func'])\n        and ($url = call_user_func($prefs['custom_url_func'], $article_array, PERMLINKURL)) !== false) {\n        return $url;\n    }\n\n    if (empty($article_array)) {\n        return false;\n    }\n\n    extract(array_intersect_key(array_change_key_case($article_array, CASE_LOWER), $fields) + $fields);\n    isset($hu) or $hu = isset($prefs['url_base']) ? $prefs['url_base'] : hu;\n\n    if (empty($thisid)) {\n        $thisid = $id;\n    }\n\n    $thisid = (int) $thisid;\n    $keys = get_context(null);\n\n    foreach ($internals as $key) {\n        unset($keys[$key]);\n    }\n\n    if (isset($permlinks[$thisid])) {\n        return $hu.($permlinks[$thisid] === true ?\n            'index.php'.join_qs(array('id' => $thisid) + $keys) :\n            $permlinks[$thisid].join_qs($keys)\n        );\n    }\n\n    if (!isset($now)) {\n        $now = date('Y-m-d H:i:s');\n    }\n\n    if (empty($prefs['publish_expired_articles']) &&\n        !empty($expires) &&\n        $prefs['production_status'] != 'live' &&\n        txpinterface == 'public' &&\n        (is_numeric($expires) ? $expires < time()\n            : (isset($uexpires) ? $uexpires < time()\n            : $expires < $now)\n        )\n    ) {\n        trigger_error(gTxt('permlink_to_expired_article', array('{id}' => $thisid)), E_USER_NOTICE);\n    }\n\n    if (empty($section)) {\n        $url_mode = 'messy';\n    } elseif (isset($txp_sections[$section])) {\n        $url_mode = empty($txp_sections[$section]['permlink_mode']) ? $permlink_mode : $txp_sections[$section]['permlink_mode'];\n    } else {\n        $url_mode = $permlink_mode;\n    }\n\n    if (empty($url_title) && !in_array($url_mode, array('section_id_title', 'id_title'))) {\n        $url_mode = 'messy';\n    }\n\n    $section = urlencode($section);\n    $url_title = urlencode($url_title);\n\n    switch ($url_mode) {\n        case 'section_id_title':\n            if ($url_title && $prefs['attach_titles_to_permalinks']) {\n                $out = \"$section/$thisid/$url_title\";\n            } else {\n                $out = \"$section/$thisid\";\n            }\n            break;\n        case 'year_month_day_title':\n            list($y, $m, $d) = explode(\"-\", date(\"Y-m-d\", isset($uposted) ? $uposted : $posted));\n            $out =  \"$y/$m/$d/$url_title\";\n            break;\n        case 'id_title':\n            if ($url_title && $prefs['attach_titles_to_permalinks']) {\n                $out = \"$thisid/$url_title\";\n            } else {\n                $out = \"$thisid\";\n            }\n            break;\n        case 'section_title':\n            $out = \"$section/$url_title\";\n            break;\n        case 'section_category_title':\n            $out = $section.'/'.\n                (empty($category1) ? '' : urlencode($category1).'/').\n                (empty($category2) ? '' : urlencode($category2).'/').$url_title;\n            break;\n        case 'breadcrumb_title':\n            $out = $section.'/';\n            if (empty($category1)) {\n                if (!empty($category2)) {\n                    $path = array_reverse(array_column(getRootPath($category2), 'name'));\n                    $out .= implode('/', array_map('urlencode', $path)).'/';\n                }\n            } elseif (empty($category2)) {\n                $path = array_reverse(array_column(getRootPath($category1), 'name'));\n                $out .= implode('/', array_map('urlencode', $path)).'/';\n            } else {\n                $c2_path = array_reverse(array_column(getRootPath($category2), 'name'));\n                if (in_array($category1, $c2_path)) {\n                    $out .= implode('/', array_map('urlencode', $c2_path)).'/';\n                } else {\n                    $c1_path = array_reverse(array_column(getRootPath($category1), 'name'));\n                    if (in_array($category2, $c1_path)) {\n                        $out .= implode('/', array_map('urlencode', $c1_path)).'/';\n                    } else {\n                        $c0_path = array_intersect($c1_path, $c2_path);\n                        $out .= ($c0_path ? implode('/', array_map('urlencode', $c0_path)).'/' : '').\n                            urlencode($category1).'/'.urlencode($category2).'/';\n                    }\n                }\n            }\n            $out .= $url_title;\n            break;\n        case 'title_only':\n            $out = $url_title;\n            break;\n        case 'messy':\n            $out = \"index.php\";\n            $keys['id'] = $thisid;\n            break;\n    }\n\n    $permlinks[$thisid] = $url_mode == 'messy' ? true : $out;\n\n    return $hu.$out.join_qs($keys);\n}\n\n/**\n * Gets a file download URL.\n *\n * @param   int    $id       The ID\n * @param   string $filename The filename\n * @return  string\n * @package File\n */\n\nfunction filedownloadurl($id, $filename = '')\n{\n    global $permlink_mode;\n\n    if ($permlink_mode == 'messy') {\n        return hu.'index.php'.join_qs(array(\n            's'  => 'file_download',\n            'id' => (int) $id,\n        ));\n    }\n\n    if ($filename) {\n        $filename = '/'.urlencode($filename);\n\n        // FIXME: work around yet another mod_deflate problem (double compression)\n        // https://blogs.msdn.microsoft.com/wndp/2006/08/21/content-encoding-content-type/\n        if (preg_match('/gz$/i', $filename)) {\n            $filename .= a;\n        }\n    }\n\n    return hu.'file_download/'.intval($id).$filename;\n}\n\n/**\n * Gets an image's absolute URL.\n *\n * @param   int    $id        The image\n * @param   string $ext       The file extension\n * @param   bool   $thumbnail If TRUE returns a URL to the thumbnail\n * @return  string\n * @package Image\n */\n\nfunction imagesrcurl($id, $ext, $thumbnail = false)\n{\n    global $img_dir;\n    $thumbnail = $thumbnail ? 't' : '';\n\n    return ihu.$img_dir.'/'.$id.$thumbnail.$ext;\n}\n\n/**\n * Checks if a value exists in a list.\n *\n * @param  string $val   The searched value\n * @param  string $list  The value list\n * @param  string $delim The list boundary\n * @return bool Returns TRUE if $val is found, FALSE otherwise\n * @example\n * if (in_list('red', 'blue, green, red, yellow'))\n * {\n *     echo \"'red' found from the list.\";\n * }\n */\n\nfunction in_list($val, $list, $delim = ',')\n{\n    return in_array((string) $val, do_list($list, $delim), true);\n}\n\n/**\n * Split a string by string.\n *\n * Trims the created values of whitespace.\n *\n * @param  array|string $list  The string\n * @param  string       $delim The boundary\n * @return array\n * @example\n * print_r(\n *     do_list('value1, value2, value3')\n * );\n */\n\nfunction do_list($list, $delim = ',')\n{\n    if (!isset($list)) {\n        return array();\n    } elseif (is_array($list)) {\n        return array_map('trim', $list);\n    }\n\n    if (is_array($delim)) {\n        list($delim, $range) = $delim + array(null, null);\n    }\n\n    $array = explode($delim, $list);\n\n    if (isset($range) && strpos($list, $range) !== false) {\n        $pattern = '/^\\s*(\\w|[-+]?\\d+)\\s*'.preg_quote($range, '/').'\\s*(\\w|[-+]?\\d+)\\s*$/';\n        $out = array();\n\n        foreach ($array as $item) {\n            if (!preg_match($pattern, $item, $match)) {\n                $out[] = trim($item);\n            } else {\n                list($m, $start, $end) = $match;\n                foreach(range($start, $end) as $v) {\n                    $out[] = $v;\n                }\n            }\n        }\n    }\n\n    return isset($out) ? $out : array_map('trim', $array);\n}\n\n/**\n * Split a string by string, returning only unique results.\n *\n * Trims unique values of whitespace. Flags permit exclusion of empty strings.\n *\n * @param  string $list  The string\n * @param  string $delim The boundary\n * @param  int    $flags TEXTPATTERN_STRIP_NONE | TEXTPATTERN_STRIP_EMPTY | TEXTPATTERN_STRIP_EMPTY_STRING\n * @return array\n * @example\n * print_r(\n *     do_list_unique('value1, value2, value3')\n * );\n */\n\nfunction do_list_unique($list, $delim = ',', $flags = TEXTPATTERN_STRIP_EMPTY_STRING)\n{\n    $out = array_unique(do_list($list, $delim));\n\n    if ($flags & TEXTPATTERN_STRIP_EMPTY) {\n        $out = array_filter($out);\n    } elseif ($flags & TEXTPATTERN_STRIP_EMPTY_STRING) {\n        $out = array_filter($out, function ($v) {return $v !== '';});\n    }\n\n    return $out;\n}\n\n/**\n * Wraps a string in single quotes.\n *\n * @param  string $val The input string\n * @return string\n */\n\nfunction doQuote($val)\n{\n    return \"'$val'\";\n}\n\n/**\n * Escapes special characters for use in an SQL statement and wraps the value\n * in quote.\n *\n * Useful for creating an array/string of values for use in an SQL statement.\n *\n * @param   string|array $in The input value\n * @param   string|null  $separator The separator\n * @return  mixed\n * @package DB\n * @example\n * if ($r = safe_row('name', 'myTable', 'type in(' . quote_list(array('value1', 'value2'), ',') . ')')\n * {\n *     echo \"Found '{$r['name']}'.\";\n * }\n */\n\nfunction quote_list($in, $separator = null)\n{\n    $out = doArray(doSlash($in), 'doQuote');\n\n    return isset($separator) ? implode($separator, $out) : $out;\n}\n\n/**\n * Adds a line to the tag trace.\n *\n * @param   string $msg             The message\n * @param   int    $tracelevel_diff Change trace level\n * @deprecated in 4.6.0\n * @package Debug\n */\n\nfunction trace_add($msg, $level = 0, $dummy = null)\n{\n    global $trace;\n\n    if ((int) $level > 0) {\n        $trace->start($msg);\n    } elseif ((int) $level < 0) {\n        $trace->stop();\n    } else {\n        $trace->log($msg);\n    }\n\n    // TODO: Uncomment this to trigger deprecated warning in a version (or two).\n    // Due to the radical changes under the hood, plugin authors will probably\n    // support dual 4.5/4.6 plugins for the short term. Deprecating this\n    // immediately causes unnecessary pain for developers.\n//    trigger_error(gTxt('deprecated_function_with', array('{name}' => __FUNCTION__, '{with}' => 'class Trace')), E_USER_NOTICE);\n}\n\n/**\n * Push current article on the end of data stack.\n *\n * Populates $stack_article global with the current $thisarticle.\n */\n\nfunction article_push()\n{\n    global $thisarticle, $stack_article;\n    $stack_article[] = $thisarticle;\n}\n\n/**\n * Advance to the next article in the current data stack.\n *\n * Populates $thisarticle global with the last article from the\n * stack stored in $stack_article.\n */\n\nfunction article_pop()\n{\n    global $thisarticle, $stack_article;\n    $thisarticle = array_pop($stack_article);\n}\n\n/**\n * Gets a path relative to the site's root directory.\n *\n * @param   string $path The filename to parse\n * @param   string $pfx  The root directory\n * @return  string The absolute $path converted to relative\n * @package File\n */\n\nfunction relative_path($path, $pfx = null)\n{\n    if ($pfx === null) {\n        $pfx = dirname(txpath);\n    }\n\n    return preg_replace('@^/'.preg_quote(ltrim($pfx, '/'), '@').'/?@', '', $path);\n}\n\n/**\n * Gets a backtrace.\n *\n * @param   int $num   The limit\n * @param   int $start The offset\n * @return  array A backtrace\n * @package Debug\n */\n\nfunction get_caller($num = 1, $start = 2)\n{\n    $out = array();\n\n    if (!is_callable('debug_backtrace')) {\n        return $out;\n    }\n\n    $bt = debug_backtrace();\n\n    for ($i = $start; $i < $num+$start; $i++) {\n        if (!empty($bt[$i])) {\n            $t = '';\n\n            if (!empty($bt[$i]['file'])) {\n                $t .= relative_path($bt[$i]['file']);\n            }\n\n            if (!empty($bt[$i]['line'])) {\n                $t .= ':'.$bt[$i]['line'];\n            }\n\n            if ($t) {\n                $t .= ' ';\n            }\n\n            if (!empty($bt[$i]['class'])) {\n                $t .= $bt[$i]['class'];\n            }\n\n            if (!empty($bt[$i]['type'])) {\n                $t .= $bt[$i]['type'];\n            }\n\n            if (!empty($bt[$i]['function'])) {\n                $t .= $bt[$i]['function'];\n                $t .= '()';\n            }\n\n            $out[] = $t;\n        }\n    }\n\n    return $out;\n}\n\n/**\n * Sets a locale.\n *\n * The function name is misleading but remains for legacy reasons.\n *\n * @param      string $lang\n * @return     string Current locale\n * @package    L10n\n * @deprecated in 4.6.0\n * @see        \\Textpattern\\L10n\\Locale::setLocale()\n */\n\nfunction getlocale($lang)\n{\n    global $locale;\n\n    Txp::get('\\Textpattern\\L10n\\Locale')->setLocale(LC_TIME, array($lang, $locale));\n\n    return Txp::get('\\Textpattern\\L10n\\Locale')->getLocale(LC_TIME);\n}\n\n/**\n * Fetch meta description from the given (or automatic) context.\n *\n * Category context may be refined by specifying the content type as well\n * after a dot. e.g. category.image to check image context category.\n *\n * @param string $type Flavour of meta content to fetch (section, category, article)\n */\n\nfunction getMetaDescription($type = null)\n{\n    global $thisarticle, $thiscategory, $thissection, $c, $s, $context, $txp_sections;\n\n    $content = '';\n\n    if ($type === null) {\n        if ($thiscategory) {\n            $content = $thiscategory['description'];\n        } elseif ($thissection) {\n            $content = $thissection['description'];\n        } elseif ($thisarticle) {\n            $content = $thisarticle['description'];\n        } elseif ($c) {\n            $content = safe_field(\"description\", 'txp_category', \"name = '\".doSlash($c).\"' AND type = '\".doSlash($context).\"'\");\n        } elseif ($s) {\n            $content = isset($txp_sections[$s]) ? $txp_sections[$s]['description'] : '';\n        }\n    } else {\n        if (strpos($type, 'category') === 0) {\n            // Category context.\n            if ($thiscategory) {\n                $content = $thiscategory['description'];\n            } else {\n                $thisContext = $context;\n                $catParts = do_list($type, '.');\n\n                if (isset($catParts[1])) {\n                    $thisContext = $catParts[1];\n                }\n\n                $clause = \" AND type = '\".$thisContext.\"'\";\n                $content = safe_field(\"description\", 'txp_category', \"name = '\".doSlash($c).\"'\".$clause);\n            }\n        } elseif ($type === 'section') {\n            $theSection = ($thissection) ? $thissection['name'] : $s;\n            $content = isset($txp_sections[$theSection]) ? $txp_sections[$theSection]['description'] : '';\n        } elseif ($type === 'article') {\n            assert_article();\n            $content = ($thisarticle? $thisarticle['description'] : '');\n        }\n    }\n\n    return $content;\n}\n\n/**\n * Get some URL data.\n * @param mixed $context The data to retrieve\n * @param array $internals Data restrictions\n * @return array The retrieved data\n */\n\nfunction get_context($context = true, $internals = array('id', 's', 'c', 'context', 'q', 'm', 'pg', 'p', 'month', 'author', 'f'))\n{\n    global $pretext, $txp_context;\n\n    if (!isset($context)) {\n        return empty($txp_context) ? array() : $txp_context;\n    } elseif (empty($context)) {\n        return array();\n    } elseif (!is_array($context)) {\n        $context = array_fill_keys($context === true ? $internals : do_list_unique($context), null);\n    }\n\n    $out = array();\n\n    foreach ($context as $q => $v) {\n        if (isset($v)) {\n            $out[$q] = $v;\n        } elseif (isset($pretext[$q]) && in_array($q, $internals)) {\n            $out[$q] = $q === 'author' ? $pretext['realname'] : $pretext[$q];\n        } else {\n            $out[$q] = gps($q, $v);\n        }\n    }\n\n    return $out;\n}\n\n/**\n * Assert context error.\n */\n\nfunction assert_context($type = 'article', $throw = true)\n{\n    global ${'this'.$type};\n\n    if (empty(${'this'.$type})) {\n        if ($throw) {\n            throw new \\Exception(gTxt(\"error_{$type}_context\"));\n        } else {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n/**\n * Assert article context error.\n */\n\nfunction assert_article($throw = true)\n{\n    return assert_context('article', $throw);\n}\n\n/**\n * Assert comment context error.\n */\n\nfunction assert_comment($throw = true)\n{\n    return assert_context('comment', $throw);\n}\n\n/**\n * Assert file context error.\n */\n\nfunction assert_file($throw = true)\n{\n    return assert_context('file', $throw);\n}\n\n/**\n * Assert image context error.\n */\n\nfunction assert_image($throw = true)\n{\n    return assert_context('image', $throw);\n}\n\n/**\n * Assert link context error.\n */\n\nfunction assert_link($throw = true)\n{\n    return assert_context('link', $throw);\n}\n\n/**\n * Assert section context error.\n */\n\nfunction assert_section($throw = true)\n{\n    return assert_context('section', $throw);\n}\n\n/**\n * Assert category context error.\n */\n\nfunction assert_category($throw = true)\n{\n    return assert_context('category', $throw);\n}\n\n/**\n * Validate a variable as an integer.\n *\n * @param  mixed $myvar The variable\n * @return int|bool The variable or FALSE on error\n */\n\nfunction assert_int($myvar)\n{\n    if (is_numeric($myvar) && $myvar == intval($myvar)) {\n        return (int) $myvar;\n    }\n\n    trigger_error(gTxt('assert_int_value', array('{name}' => (string) $myvar)), E_USER_ERROR);\n\n    return false;\n}\n\n/**\n * Validate a variable as a string.\n *\n * @param  mixed $myvar The variable\n * @return string|bool The variable or FALSE on error\n */\n\nfunction assert_string($myvar)\n{\n    if (is_string($myvar)) {\n        return $myvar;\n    }\n\n    trigger_error(gTxt('assert_string_value', array('{name}' => (string) $myvar)), E_USER_ERROR);\n\n    return false;\n}\n\n/**\n * Validate a variable as an array.\n *\n * @param  mixed $myvar The variable\n * @return array|bool The variable or FALSE on error\n */\n\nfunction assert_array($myvar)\n{\n    if (is_array($myvar)) {\n        return $myvar;\n    }\n\n    trigger_error(gTxt('assert_array_value', array('{name}' => (string) $myvar)), E_USER_ERROR);\n\n    return false;\n}\n\n/**\n * Converts relative links in HTML markup to absolute.\n *\n * @param   string $html      The HTML to check\n * @param   string $permalink Optional URL part appended to the links\n * @return  string HTML\n * @package URL\n */\n\nfunction replace_relative_urls($html, $permalink = '')\n{\n    global $siteurl;\n\n    // URLs like \"/foo/bar\" - relative to the domain.\n    if (serverSet('HTTP_HOST')) {\n        $html = preg_replace('@(<a[^>]+href=\")/(?!/)@', '$1'.PROTOCOL.serverSet('HTTP_HOST').'/', $html);\n        $html = preg_replace('@(<img[^>]+src=\")/(?!/)@', '$1'.PROTOCOL.serverSet('HTTP_HOST').'/', $html);\n    }\n\n    // \"foo/bar\" - relative to the textpattern root,\n    // leave \"http:\", \"mailto:\" et al. as absolute URLs.\n    $html = preg_replace('@(<a[^>]+href=\")(?!\\w+:|//)@', '$1'.PROTOCOL.$siteurl.'/$2', $html);\n    $html = preg_replace('@(<img[^>]+src=\")(?!\\w+:|//)@', '$1'.PROTOCOL.$siteurl.'/$2', $html);\n\n    if ($permalink) {\n        $html = preg_replace(\"/href=\\\\\\\"#(.*)\\\"/\", \"href=\\\"\".$permalink.\"#\\\\1\\\"\", $html);\n    }\n\n    return ($html);\n}\n\n/**\n * Used for clean URL test.\n *\n * @param  array $pretext\n * @access private\n */\n\nfunction show_clean_test($pretext)\n{\n    ob_clean();\n    if (is_array($pretext) && isset($pretext['req'])) {\n        echo md5($pretext['req']).n;\n    }\n\n    if (serverSet('SERVER_ADDR') === serverSet('REMOTE_ADDR')) {\n        var_export($pretext);\n    }\n}\n\n/**\n * Calculates paging.\n *\n * Takes a total number of items, a per page limit and the current page number,\n * and in return returns the page number, an offset and a number of pages.\n *\n * @param  int $total The number of items in total\n * @param  int $limit The number of items per page\n * @param  int $page  The page number\n * @return array Array of page, offset and number of pages.\n * @example\n * list($page, $offset, $num_pages) = pager(150, 10, 1);\n * echo \"Page {$page} of {$num_pages}. Offset is {$offset}.\";\n */\n\nfunction pager($total, $limit, $page)\n{\n    $total = (int) $total;\n    $limit = (int) $limit;\n    $page = (int) $page;\n\n    $num_pages = ceil($total / $limit);\n\n    $page = min(max($page, 1), $num_pages);\n\n    $offset = max(($page - 1) * $limit, 0);\n\n    return array($page, $offset, $num_pages);\n}\n\n/**\n * Word-wrap a string using a zero width space.\n *\n * @param  string $text  The input string\n * @param  int    $width Target line length\n * @param  string $break Is not used\n * @return string\n */\n\nfunction soft_wrap($text, $width, $break = '&#8203;')\n{\n    $wbr = chr(226).chr(128).chr(139);\n    $words = explode(' ', $text);\n\n    foreach ($words as $wordnr => $word) {\n        $word = preg_replace('|([,./\\\\>?!:;@-]+)(?=.)|', '$1 ', $word);\n        $parts = explode(' ', $word);\n\n        foreach ($parts as $partnr => $part) {\n            $len = strlen(utf8_decode($part));\n\n            if (!$len) {\n                continue;\n            }\n\n            $parts[$partnr] = preg_replace('/(.{'.ceil($len/ceil($len/$width)).'})(?=.)/u', '$1'.$wbr, $part);\n        }\n\n        $words[$wordnr] = join($wbr, $parts);\n    }\n\n    return join(' ', $words);\n}\n\n/**\n * Removes prefix from a string.\n *\n * @param  string $str The string\n * @param  string $pfx The prefix\n * @return string\n */\n\nfunction strip_prefix($str, $pfx)\n{\n    return preg_replace('/^'.preg_quote($pfx, '/').'/', '', $str);\n}\n\n/**\n * Sends an XML envelope.\n *\n * Wraps an array of name => value tuples into an XML envelope, supports one\n * level of nested arrays at most.\n *\n * @param   array $response\n * @return  string XML envelope\n * @package XML\n */\n\nfunction send_xml_response($response = array())\n{\n    static $headers_sent = false;\n\n    if (!$headers_sent) {\n        ob_clean();\n        header('Content-Type: text/xml; charset=utf-8');\n        $out[] = '<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>';\n        $headers_sent = true;\n    }\n\n    $default_response = array('http-status' => '200 OK');\n\n    // Backfill default response properties.\n    $response = $response + $default_response;\n\n    txp_status_header($response['http-status']);\n    $out[] = '<textpattern>';\n\n    foreach ($response as $element => $value) {\n        if (is_array($value)) {\n            $out[] = t.\"<$element>\".n;\n\n            foreach ($value as $e => $v) {\n                // Character escaping in values;\n                // @see https://www.w3.org/TR/REC-xml/#sec-references.\n                $v = str_replace(array(\"\\t\", \"\\n\", \"\\r\"), array(\"&#x9;\", \"&#xA;\", \"&#xD;\"), htmlentities($v, ENT_QUOTES, 'UTF-8'));\n                $out[] = t.t.\"<$e value='$v' />\".n;\n            }\n\n            $out[] = t.\"</$element>\".n;\n        } else {\n            $value = str_replace(array(\"\\t\", \"\\n\", \"\\r\"), array(\"&#x9;\", \"&#xA;\", \"&#xD;\"), htmlentities($value, ENT_QUOTES, 'UTF-8'));\n            $out[] = t.\"<$element value='$value' />\".n;\n        }\n    }\n\n    $out[] = '</textpattern>';\n    echo join(n, $out);\n}\n\n/**\n * Sends a text/javascript response.\n *\n * @param   string $out The JavaScript\n * @since   4.4.0\n * @package Ajax\n */\n\nfunction send_script_response($out = '')\n{\n    static $headers_sent = false;\n\n    if (!$headers_sent) {\n        ob_clean();\n        header('Content-Type: text/javascript; charset=utf-8');\n        txp_status_header('200 OK');\n        $headers_sent = true;\n    }\n\n    echo \";\\n\".$out.\";\\n\";\n}\n\n/**\n * Sends an application/json response.\n *\n * If the provided $out is not a string, its encoded as JSON. Any string is\n * treated as it were valid JSON.\n *\n * @param   mixed $out The JSON\n * @since   4.6.0\n * @package Ajax\n */\n\nfunction send_json_response($out = '')\n{\n    static $headers_sent = false;\n\n    if (!$headers_sent) {\n        ob_clean();\n        header('Content-Type: application/json; charset=utf-8');\n        txp_status_header('200 OK');\n        $headers_sent = true;\n    }\n\n    if (!is_string($out)) {\n        $out = json_encode($out, TEXTPATTERN_JSON);\n    }\n\n    echo $out;\n}\n\n/**\n * Performs regular housekeeping.\n *\n * @access private\n */\n\nfunction janitor()\n{\n    global $prefs, $auto_dst, $timezone_key, $is_dst;\n\n    // Update DST setting.\n    if ($auto_dst && $timezone_key) {\n        $is_dst = Txp::get('\\Textpattern\\Date\\Timezone')->isDst(null, $timezone_key);\n\n        if ($is_dst != $prefs['is_dst']) {\n            $prefs['is_dst'] = $is_dst;\n            set_pref('is_dst', $is_dst, 'publish', PREF_HIDDEN);\n        }\n    }\n}\n\n/**\n * Protection from those who'd bomb the site by GET.\n *\n * Origin of the infamous 'Nice try' message and an even more useful '503'\n * HTTP status.\n */\n\nfunction bombShelter()\n{\n    global $prefs;\n    $in = serverSet('REQUEST_URI');\n\n    if (!empty($prefs['max_url_len']) and strlen($in) > $prefs['max_url_len'] + (!empty($_GET['txpcleantest']) ? 48 : 0)) {\n        txp_status_header('503 Service Unavailable');\n        exit('Nice try.');\n    }\n}\n\n/**\n * Test whether the client accepts a certain response format.\n *\n * Discards formats with a quality factor below 0.1\n *\n * @param   string  $format One of 'html', 'txt', 'js', 'css', 'json', 'xml', 'rdf', 'atom', 'rss'\n * @return  boolean $format TRUE if accepted\n * @since   4.5.0\n * @package Network\n */\n\nfunction http_accept_format($format)\n{\n    static $formats = array(\n        'html' => array('text/html', 'application/xhtml+xml', '*/*'),\n        'txt'  => array('text/plain', '*/*'),\n        'js'   => array('application/javascript', 'application/x-javascript', 'text/javascript', 'application/ecmascript', 'application/x-ecmascript', '*/*'),\n        'css'  => array('text/css', '*/*'),\n        'json' => array('application/json', 'application/x-json', '*/*'),\n        'xml'  => array('text/xml', 'application/xml', 'application/x-xml', '*/*'),\n        'rdf'  => array('application/rdf+xml', '*/*'),\n        'atom' => array('application/atom+xml', '*/*'),\n        'rss'  => array('application/rss+xml', '*/*'),\n    );\n    static $accepts = array();\n    static $q = array();\n\n    if (empty($accepts)) {\n        // Build cache of accepted formats.\n        $accepts = preg_split('/\\s*,\\s*/', serverSet('HTTP_ACCEPT'), -1, PREG_SPLIT_NO_EMPTY);\n\n        foreach ($accepts as $i => &$a) {\n            // Sniff out quality factors if present.\n            if (preg_match('/(.*)\\s*;\\s*q=([.0-9]*)/', $a, $m)) {\n                $a = $m[1];\n                $q[$a] = floatval($m[2]);\n            } else {\n                $q[$a] = 1.0;\n            }\n\n            // Discard formats with quality factors below an arbitrary threshold\n            // as jQuery adds a wildcard '*/*; q=0.01' to the 'Accepts' header\n            // for XHR requests.\n            if ($q[$a] < 0.1) {\n                unset($q[$a]);\n                unset($accepts[$i]);\n            }\n        }\n    }\n\n    return isset($formats[$format]) && count(array_intersect($formats[$format], $accepts)) > 0;\n}\n\n/**\n * Return a list of status codes and their associated names.\n *\n * The list can be extended with a 'status.types > types' callback event.\n * Callback functions get passed three arguments: '$event', '$step' and\n * '$status_list'. The third parameter contains a reference to an array of\n * 'status_code => label' pairs.\n *\n * @param   bool  Return the list with L10n labels (for UI purposes) or raw values (for comparisons)\n * @param   array List of status keys (numbers) to exclude\n * @return  array A status array\n * @since   4.6.0\n */\n\nfunction status_list($labels = true, $exclude = array())\n{\n    $status_list = array(\n        STATUS_DRAFT   => 'draft',\n        STATUS_HIDDEN  => 'hidden',\n        STATUS_PENDING => 'pending',\n        STATUS_LIVE    => 'live',\n        STATUS_STICKY  => 'sticky',\n    );\n\n    if (!is_array($exclude)) {\n        $exclude = array();\n    }\n\n    foreach ($exclude as $remove) {\n        unset($status_list[(int) $remove]);\n    }\n\n    callback_event_ref('status.types', 'types', 0, $status_list);\n\n    if ($labels) {\n        $status_list = array_map('gTxt', $status_list);\n    }\n\n    return $status_list;\n}\n\n/**\n * Translates article status names into numerical status codes.\n *\n * @param  string $name    Status name\n * @param  int    $default Status code to return if $name is not a defined status name\n * @return int Matching numerical status\n */\n\nfunction getStatusNum($name, $default = STATUS_LIVE)\n{\n    $statuses = status_list(false);\n    $status = strtolower($name);\n    $num = array_search($status, $statuses);\n\n    if ($num === false) {\n        $num = $default;\n    }\n\n    return (int) $num;\n}\n\n/**\n * Gets the maximum allowed file upload size.\n *\n * Computes the maximum acceptable file size to the application if the\n * user-selected value is larger than the maximum allowed by the current PHP\n * configuration.\n *\n * @param  int $user_max Desired upload size supplied by the administrator\n * @return int Actual value; the lower of user-supplied value or system-defined value\n */\n\nfunction real_max_upload_size($user_max, $php = true)\n{\n    // The minimum of the candidates, is the real max. possible size\n    $candidates = $php ? array($user_max,\n        ini_get('post_max_size'),\n        ini_get('upload_max_filesize')\n    ) : array($user_max);\n    $real_max = null;\n\n    foreach ($candidates as $item) {\n        $val = floatval($item);\n        $modifier = strtolower(substr(trim($item), -1));\n\n        switch ($modifier) {\n            // The 'G' modifier is available since PHP 5.1.0\n            case 'g':\n                $val *= 1024;\n                // no break\n            case 'm':\n                $val *= 1024;\n                // no break\n            case 'k':\n                $val *= 1024;\n        }\n\n        if ($val >= 1) {\n            if (is_null($real_max) || $val < $real_max) {\n                $real_max = floor($val);\n            }\n        }\n    }\n\n    // 2^53 - 1 is max safe JavaScript integer, let 8192Tb\n    return number_format(min($real_max, pow(2, 53) - 1), 0, '.', '');\n}\n\n// -------------------------------------------------------------\n\nfunction txp_match($atts, $what)\n{\n    static $dlmPool = array('/', '@', '#', '~', '`', '|', '!', '%');\n\n    extract($atts + array(\n        'value'     => null,\n        'match'     => 'exact',\n        'separator' => '',\n    ));\n\n\n    if ($value !== null) {\n        switch ($match) {\n            case '<':\n            case 'less':\n                $cond = (is_array($what) ? $what < do_list($value, $separator ? $separator : ',') : $what < $value);\n                break;\n            case '<=':\n                $cond = (is_array($what) ? $what <= do_list($value, $separator ? $separator : ',') : $what <= $value);\n                break;\n            case '>':\n            case 'greater':\n                $cond = (is_array($what) ? $what > do_list($value, $separator ? $separator : ',') : $what > $value);\n                break;\n            case '>=':\n                $cond = (is_array($what) ? $what >= do_list($value, $separator ? $separator : ',') : $what >= $value);\n                break;\n            case '':\n            case 'exact':\n                $cond = (is_array($what) ? $what == do_list($value, $separator ? $separator : ',') : $what == $value);\n                break;\n            case 'any':\n                $values = do_list_unique($value);\n                $cond = false;\n                $cf_contents = $separator && !is_array($what) ? do_list_unique($what, $separator) : $what;\n\n                foreach ($values as $term) {\n                    if (is_array($cf_contents) ? in_array($term, $cf_contents) : strpos($cf_contents, $term) !== false) {\n                        $cond = true;\n                        break;\n                    }\n                }\n                break;\n            case 'all':\n                $values = do_list_unique($value);\n                $cond = true;\n                $cf_contents = $separator && !is_array($what) ? do_list_unique($what, $separator) : $what;\n\n                foreach ($values as $term) {\n                    if (is_array($cf_contents) ? !in_array($term, $cf_contents) : strpos($cf_contents, $term) === false) {\n                        $cond = false;\n                        break;\n                    }\n                }\n                break;\n            case 'pattern':\n                // Cannot guarantee that a fixed delimiter won't break preg_match\n                // (and preg_quote doesn't help) so dynamically assign the delimiter\n                // based on the first entry in $dlmPool that is NOT in the value\n                // attribute. This minimises (does not eliminate) the possibility\n                // of a TXP-initiated preg_match error, while still preserving\n                // errors outside TXP's control (e.g. mangled user-submitted\n                // PCRE pattern).\n                if ($separator === true) {\n                    $dlm = $value;\n                } elseif ($separator && in_array($separator, $dlmPool)) {\n                    $dlm = strpos($value, $separator) === 0 ? $value : $separator.$value.$separator;\n                } else {\n                    $dlm = array_diff($dlmPool, preg_split('//', $value));\n                    $dlm = reset($dlm);\n                    $dlm = $dlm.$value.$dlm;\n                }\n\n                $cond = preg_match($dlm, is_array($what) ? implode('', $what) : $what);\n                break;\n            default:\n                trigger_error(gTxt('invalid_attribute_value', array('{name}' => 'match')), E_USER_NOTICE);\n                $cond = false;\n        }\n    } else {\n        $cond = ($what !== null);\n    }\n\n    return !empty($cond);\n}\n\n// -------------------------------------------------------------\n\nfunction txp_break($wraptag)\n{\n    switch (strtolower($wraptag)) {\n        case 'ul':\n        case 'ol':\n            return 'li';\n        case 'p':\n            return 'br';\n        case 'table':\n        case 'tbody':\n        case 'thead':\n        case 'tfoot':\n            return 'tr';\n        case 'tr':\n            return 'td';\n        default:\n            return ',';\n    }\n}\n\n// -------------------------------------------------------------\n\nfunction txp_hash($thing)\n{\n    return strlen($thing) < TEXTPATTERN_HASH_LENGTH ? $thing : hash(TEXTPATTERN_HASH_ALGO, $thing);\n}\n\n/*** Polyfills ***/\n\nif (!function_exists('array_column')) {\n    include txpath.'/lib/array_column.php';\n}\n"], "filenames": ["textpattern/lib/txplib_misc.php"], "buggy_code_start_loc": [1036], "buggy_code_end_loc": [1037], "fixing_code_start_loc": [1036], "fixing_code_end_loc": [1037], "type": "CWE-565", "message": "Textpattern CMS v4.8.7 and older vulnerability exists through Sensitive Cookie in HTTPS Session Without 'Secure' Attribute via textpattern/lib/txplib_misc.php. The secure flag is not set for txp_login session cookie in the application. If the secure flag is not set, then the cookie will be transmitted in clear-text if the user visits any HTTP URLs within the cookie's scope. An attacker may be able to induce this event by feeding a user suitable links, either directly or via another web site.", "other": {"cve": {"id": "CVE-2021-40642", "sourceIdentifier": "cve@mitre.org", "published": "2022-06-29T11:15:16.533", "lastModified": "2022-07-07T19:52:10.537", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Textpattern CMS v4.8.7 and older vulnerability exists through Sensitive Cookie in HTTPS Session Without 'Secure' Attribute via textpattern/lib/txplib_misc.php. The secure flag is not set for txp_login session cookie in the application. If the secure flag is not set, then the cookie will be transmitted in clear-text if the user visits any HTTP URLs within the cookie's scope. An attacker may be able to induce this event by feeding a user suitable links, either directly or via another web site."}, {"lang": "es", "value": "Una vulnerabilidad en Textpattern CMS versiones v4.8.7 y anteriores, se presenta mediante la cookie confidencial en la sesi\u00f3n HTTPS sin el atributo \"Secure\" por medio del archivo textpattern/lib/txplib_misc.php. El flag seguro no est\u00e1 establecida para la cookie de sesi\u00f3n txp_login en la aplicaci\u00f3n. Si el flag seguro no est\u00e1 establecido, entonces la cookie ser\u00e1 transmitida en texto sin cifrar si el usuario visita cualquier URL HTTP dentro del \u00e1mbito de la cookie. Un atacante puede ser capaz de inducir este evento al alimentar al usuario con enlaces apropiados, ya sea directamente o por medio de otro sitio web"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-565"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:textpattern:textpattern:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.8.7", "matchCriteriaId": "B0025781-915E-4449-AB85-6689A54AF9AF"}]}]}], "references": [{"url": "https://github.com/textpattern/textpattern/commit/211fab0093999f59b0b61682aa988ac7d8337aa9", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.huntr.dev/bounties/aadbe434-a376-443b-876f-2a1cbab7847b/", "source": "cve@mitre.org", "tags": ["Permissions Required", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/textpattern/textpattern/commit/211fab0093999f59b0b61682aa988ac7d8337aa9"}}