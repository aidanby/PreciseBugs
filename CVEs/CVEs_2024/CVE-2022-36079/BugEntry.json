{"buggy_code": ["name: ci\non:\n  push:\n    branches:\n      - master\n  pull_request:\n    branches:\n      - '**'\nenv:\n  COVERAGE_OPTION: ./node_modules/.bin/nyc\n  NODE_VERSION: 10\n  PARSE_SERVER_TEST_TIMEOUT: 20000\njobs:\n  check-mongo:\n    strategy:\n      matrix:\n        include:\n          - name: Mongo 4.0.4, ReplicaSet, WiredTiger\n            MONGODB_VERSION: 4.0.4\n            MONGODB_TOPOLOGY: replicaset\n            MONGODB_STORAGE_ENGINE: wiredTiger\n            NODE_VERSION: 10\n          - name: Mongo 3.6.21\n            MONGODB_VERSION: 3.6.21\n            NODE_VERSION: 10\n          - name: Redis Cache\n            PARSE_SERVER_TEST_CACHE: redis\n            NODE_VERSION: 10\n          - name: Node 12.12.0\n            NODE_VERSION: 12.12.0\n    name: ${{ matrix.name }}\n    timeout-minutes: 30\n    runs-on: ubuntu-18.04\n    services:\n      redis:\n        image: redis\n        ports:\n            - 6379:6379\n    env:      \n      MONGODB_VERSION: ${{ matrix.MONGODB_VERSION }}\n      MONGODB_TOPOLOGY: ${{ matrix.MONGODB_TOPOLOGY }}\n      MONGODB_STORAGE_ENGINE: ${{ matrix.MONGODB_STORAGE_ENGINE }}\n      PARSE_SERVER_TEST_CACHE: ${{ matrix.PARSE_SERVER_TEST_CACHE }}\n      NODE_VERSION: ${{ matrix.NODE_VERSION }}\n    steps:\n      - name: Fix usage of insecure GitHub protocol\n        run: sudo git config --system url.\"https://github\".insteadOf \"git://github\"\n      - uses: actions/checkout@v2\n      - name: Use Node.js ${{ matrix.NODE_VERSION }}\n        uses: actions/setup-node@v1\n        with:\n          node-version: ${{ matrix.NODE_VERSION }}\n      - name: Cache Node.js modules\n        uses: actions/cache@v2\n        with:\n          path: ~/.npm\n          key: ${{ runner.os }}-node-${{ matrix.NODE_VERSION }}-${{ hashFiles('**/package-lock.json') }}\n          restore-keys: |\n            ${{ runner.os }}-node-${{ matrix.NODE_VERSION }}-\n      - name: Install dependencies\n        run: npm ci\n      - if: ${{ matrix.name == 'Mongo 3.6.21' }}\n        run: npm run lint\n      - run: npm run pretest\n      - run: npm run coverage\n        env:\n          CI: true\n      - run: bash <(curl -s https://codecov.io/bash)\n  check-postgres:\n    name: Postgresql\n    timeout-minutes: 30\n    runs-on: ubuntu-18.04\n    services:\n      redis:\n        image: redis\n        ports:\n          - 6379:6379\n      postgres:\n        image: postgis/postgis:11-3.0\n        env:\n          POSTGRES_PASSWORD: postgres\n        ports:\n          - 5432:5432\n        options: >-\n          --health-cmd pg_isready\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n    env:\n      PARSE_SERVER_TEST_DB: postgres\n      POSTGRES_MAJOR_VERSION: 11\n      PARSE_SERVER_TEST_DATABASE_URI: postgres://postgres:postgres@localhost:5432/parse_server_postgres_adapter_test_database\n    steps:\n      - name: Fix usage of insecure GitHub protocol\n        run: sudo git config --system url.\"https://github\".insteadOf \"git://github\"\n      - uses: actions/checkout@v2\n      - name: Use Node.js 10\n        uses: actions/setup-node@v1\n        with:\n          node-version: 10\n      - name: Cache Node.js modules\n        uses: actions/cache@v2\n        with:\n          path: ~/.npm\n          key: ${{ runner.os }}-node-${{ matrix.NODE_VERSION }}-${{ hashFiles('**/package-lock.json') }}\n          restore-keys: |\n            ${{ runner.os }}-node-${{ matrix.NODE_VERSION }}-\n      - name: Install dependencies\n        run: npm ci\n      - run: bash scripts/before_script_postgres.sh\n      - run: npm run coverage\n        env:\n          CI: true\n      - run: bash <(curl -s https://codecov.io/bash)", "const RedisCacheAdapter = require('../lib/Adapters/Cache/RedisCacheAdapter').default;\nconst Config = require('../lib/Config');\n\n/*\nTo run this test part of the complete suite\nset PARSE_SERVER_TEST_CACHE='redis'\nand make sure a redis server is available on the default port\n */\ndescribe_only(() => {\n  return process.env.PARSE_SERVER_TEST_CACHE === 'redis';\n})('RedisCacheAdapter', function () {\n  const KEY = 'hello';\n  const VALUE = 'world';\n\n  function wait(sleep) {\n    return new Promise(function (resolve) {\n      setTimeout(resolve, sleep);\n    });\n  }\n\n  it('should get/set/clear', done => {\n    const cache = new RedisCacheAdapter({\n      ttl: NaN,\n    });\n\n    cache\n      .put(KEY, VALUE)\n      .then(() => cache.get(KEY))\n      .then(value => expect(value).toEqual(VALUE))\n      .then(() => cache.clear())\n      .then(() => cache.get(KEY))\n      .then(value => expect(value).toEqual(null))\n      .then(done);\n  });\n\n  it('should expire after ttl', done => {\n    const cache = new RedisCacheAdapter(null, 50);\n\n    cache\n      .put(KEY, VALUE)\n      .then(() => cache.get(KEY))\n      .then(value => expect(value).toEqual(VALUE))\n      .then(wait.bind(null, 52))\n      .then(() => cache.get(KEY))\n      .then(value => expect(value).toEqual(null))\n      .then(done);\n  });\n\n  it('should not store value for ttl=0', done => {\n    const cache = new RedisCacheAdapter(null, 5);\n\n    cache\n      .put(KEY, VALUE, 0)\n      .then(() => cache.get(KEY))\n      .then(value => expect(value).toEqual(null))\n      .then(done);\n  });\n\n  it('should not expire when ttl=Infinity', done => {\n    const cache = new RedisCacheAdapter(null, 1);\n\n    cache\n      .put(KEY, VALUE, Infinity)\n      .then(() => cache.get(KEY))\n      .then(value => expect(value).toEqual(VALUE))\n      .then(wait.bind(null, 5))\n      .then(() => cache.get(KEY))\n      .then(value => expect(value).toEqual(VALUE))\n      .then(done);\n  });\n\n  it('should fallback to default ttl', done => {\n    const cache = new RedisCacheAdapter(null, 1);\n    let promise = Promise.resolve();\n\n    [-100, null, undefined, 'not number', true].forEach(ttl => {\n      promise = promise.then(() =>\n        cache\n          .put(KEY, VALUE, ttl)\n          .then(() => cache.get(KEY))\n          .then(value => expect(value).toEqual(VALUE))\n          .then(wait.bind(null, 5))\n          .then(() => cache.get(KEY))\n          .then(value => expect(value).toEqual(null))\n      );\n    });\n\n    promise.then(done);\n  });\n\n  it('should find un-expired records', done => {\n    const cache = new RedisCacheAdapter(null, 5);\n\n    cache\n      .put(KEY, VALUE)\n      .then(() => cache.get(KEY))\n      .then(value => expect(value).toEqual(VALUE))\n      .then(wait.bind(null, 1))\n      .then(() => cache.get(KEY))\n      .then(value => expect(value).not.toEqual(null))\n      .then(done);\n  });\n\n  it('handleShutdown, close connection', async () => {\n    const cache = new RedisCacheAdapter(null, 5);\n\n    await cache.handleShutdown();\n    setTimeout(() => {\n      expect(cache.client.connected).toBe(false);\n    }, 0);\n  });\n});\n\ndescribe_only(() => {\n  return process.env.PARSE_SERVER_TEST_CACHE === 'redis';\n})('RedisCacheAdapter/KeyPromiseQueue', function () {\n  const KEY1 = 'key1';\n  const KEY2 = 'key2';\n  const VALUE = 'hello';\n\n  // number of chained ops on a single key\n  function getQueueCountForKey(cache, key) {\n    return cache.queue.queue[key][0];\n  }\n\n  // total number of queued keys\n  function getQueueCount(cache) {\n    return Object.keys(cache.queue.queue).length;\n  }\n\n  it('it should clear completed operations from queue', done => {\n    const cache = new RedisCacheAdapter({ ttl: NaN });\n\n    // execute a bunch of operations in sequence\n    let promise = Promise.resolve();\n    for (let index = 1; index < 100; index++) {\n      promise = promise.then(() => {\n        const key = `${index}`;\n        return cache\n          .put(key, VALUE)\n          .then(() => expect(getQueueCount(cache)).toEqual(0))\n          .then(() => cache.get(key))\n          .then(() => expect(getQueueCount(cache)).toEqual(0))\n          .then(() => cache.clear())\n          .then(() => expect(getQueueCount(cache)).toEqual(0));\n      });\n    }\n\n    // at the end the queue should be empty\n    promise.then(() => expect(getQueueCount(cache)).toEqual(0)).then(done);\n  });\n\n  it('it should count per key chained operations correctly', done => {\n    const cache = new RedisCacheAdapter({ ttl: NaN });\n\n    let key1Promise = Promise.resolve();\n    let key2Promise = Promise.resolve();\n    for (let index = 1; index < 100; index++) {\n      key1Promise = cache.put(KEY1, VALUE);\n      key2Promise = cache.put(KEY2, VALUE);\n      // per key chain should be equal to index, which is the\n      // total number of operations on that key\n      expect(getQueueCountForKey(cache, KEY1)).toEqual(index);\n      expect(getQueueCountForKey(cache, KEY2)).toEqual(index);\n      // the total keys counts should be equal to the different keys\n      // we have currently being processed.\n      expect(getQueueCount(cache)).toEqual(2);\n    }\n\n    // at the end the queue should be empty\n    Promise.all([key1Promise, key2Promise])\n      .then(() => expect(getQueueCount(cache)).toEqual(0))\n      .then(done);\n  });\n});\n\ndescribe_only(() => {\n  return process.env.PARSE_SERVER_TEST_CACHE === 'redis';\n})('Redis Performance', function () {\n  let cacheAdapter;\n  let getSpy;\n  let putSpy;\n  let delSpy;\n\n  beforeEach(async () => {\n    cacheAdapter = new RedisCacheAdapter();\n    await reconfigureServer({\n      cacheAdapter,\n    });\n    await cacheAdapter.clear();\n\n    getSpy = spyOn(cacheAdapter, 'get').and.callThrough();\n    putSpy = spyOn(cacheAdapter, 'put').and.callThrough();\n    delSpy = spyOn(cacheAdapter, 'del').and.callThrough();\n  });\n\n  it('test new object', async () => {\n    const object = new TestObject();\n    object.set('foo', 'bar');\n    await object.save();\n    expect(getSpy.calls.count()).toBe(3);\n    expect(putSpy.calls.count()).toBe(3);\n    expect(delSpy.calls.count()).toBe(1);\n\n    const keys = await cacheAdapter.getAllKeys();\n    expect(keys.length).toBe(0);\n  });\n\n  it('test new object multiple fields', async () => {\n    const container = new Container({\n      dateField: new Date(),\n      arrayField: [],\n      numberField: 1,\n      stringField: 'hello',\n      booleanField: true,\n    });\n    await container.save();\n    expect(getSpy.calls.count()).toBe(3);\n    expect(putSpy.calls.count()).toBe(3);\n    expect(delSpy.calls.count()).toBe(1);\n\n    const keys = await cacheAdapter.getAllKeys();\n    expect(keys.length).toBe(0);\n  });\n\n  it('test update existing fields', async () => {\n    const object = new TestObject();\n    object.set('foo', 'bar');\n    await object.save();\n\n    getSpy.calls.reset();\n    putSpy.calls.reset();\n\n    object.set('foo', 'barz');\n    await object.save();\n    expect(getSpy.calls.count()).toBe(3);\n    expect(putSpy.calls.count()).toBe(1);\n    expect(delSpy.calls.count()).toBe(2);\n\n    const keys = await cacheAdapter.getAllKeys();\n    expect(keys.length).toBe(0);\n  });\n\n  it('test saveAll / destroyAll', async () => {\n    const object = new TestObject();\n    await object.save();\n\n    getSpy.calls.reset();\n    putSpy.calls.reset();\n\n    const objects = [];\n    for (let i = 0; i < 10; i++) {\n      const object = new TestObject();\n      object.set('number', i);\n      objects.push(object);\n    }\n    await Parse.Object.saveAll(objects);\n    expect(getSpy.calls.count()).toBe(21);\n    expect(putSpy.calls.count()).toBe(11);\n\n    getSpy.calls.reset();\n    putSpy.calls.reset();\n\n    await Parse.Object.destroyAll(objects);\n    expect(getSpy.calls.count()).toBe(11);\n    expect(putSpy.calls.count()).toBe(1);\n    expect(delSpy.calls.count()).toBe(3);\n\n    const keys = await cacheAdapter.getAllKeys();\n    expect(keys.length).toBe(0);\n  });\n\n  it('test saveAll / destroyAll batch', async () => {\n    const object = new TestObject();\n    await object.save();\n\n    getSpy.calls.reset();\n    putSpy.calls.reset();\n\n    const objects = [];\n    for (let i = 0; i < 10; i++) {\n      const object = new TestObject();\n      object.set('number', i);\n      objects.push(object);\n    }\n    await Parse.Object.saveAll(objects, { batchSize: 5 });\n    expect(getSpy.calls.count()).toBe(22);\n    expect(putSpy.calls.count()).toBe(7);\n\n    getSpy.calls.reset();\n    putSpy.calls.reset();\n\n    await Parse.Object.destroyAll(objects, { batchSize: 5 });\n    expect(getSpy.calls.count()).toBe(12);\n    expect(putSpy.calls.count()).toBe(2);\n    expect(delSpy.calls.count()).toBe(5);\n\n    const keys = await cacheAdapter.getAllKeys();\n    expect(keys.length).toBe(0);\n  });\n\n  it('test add new field to existing object', async () => {\n    const object = new TestObject();\n    object.set('foo', 'bar');\n    await object.save();\n\n    getSpy.calls.reset();\n    putSpy.calls.reset();\n\n    object.set('new', 'barz');\n    await object.save();\n    expect(getSpy.calls.count()).toBe(3);\n    expect(putSpy.calls.count()).toBe(2);\n    expect(delSpy.calls.count()).toBe(2);\n\n    const keys = await cacheAdapter.getAllKeys();\n    expect(keys.length).toBe(0);\n  });\n\n  it('test add multiple fields to existing object', async () => {\n    const object = new TestObject();\n    object.set('foo', 'bar');\n    await object.save();\n\n    getSpy.calls.reset();\n    putSpy.calls.reset();\n\n    object.set({\n      dateField: new Date(),\n      arrayField: [],\n      numberField: 1,\n      stringField: 'hello',\n      booleanField: true,\n    });\n    await object.save();\n    expect(getSpy.calls.count()).toBe(3);\n    expect(putSpy.calls.count()).toBe(2);\n    expect(delSpy.calls.count()).toBe(2);\n\n    const keys = await cacheAdapter.getAllKeys();\n    expect(keys.length).toBe(0);\n  });\n\n  it('test user', async () => {\n    const user = new Parse.User();\n    user.setUsername('testing');\n    user.setPassword('testing');\n    await user.signUp();\n\n    expect(getSpy.calls.count()).toBe(8);\n    expect(putSpy.calls.count()).toBe(2);\n    expect(delSpy.calls.count()).toBe(1);\n\n    const keys = await cacheAdapter.getAllKeys();\n    expect(keys.length).toBe(0);\n  });\n\n  it('test allowClientCreation false', async () => {\n    const object = new TestObject();\n    await object.save();\n    await reconfigureServer({\n      cacheAdapter,\n      allowClientClassCreation: false,\n    });\n    await cacheAdapter.clear();\n\n    getSpy.calls.reset();\n    putSpy.calls.reset();\n    delSpy.calls.reset();\n\n    object.set('foo', 'bar');\n    await object.save();\n    expect(getSpy.calls.count()).toBe(4);\n    expect(putSpy.calls.count()).toBe(2);\n\n    getSpy.calls.reset();\n    putSpy.calls.reset();\n\n    const query = new Parse.Query(TestObject);\n    await query.get(object.id);\n    expect(getSpy.calls.count()).toBe(3);\n    expect(putSpy.calls.count()).toBe(1);\n    expect(delSpy.calls.count()).toBe(2);\n\n    const keys = await cacheAdapter.getAllKeys();\n    expect(keys.length).toBe(0);\n  });\n\n  it('test query', async () => {\n    const object = new TestObject();\n    object.set('foo', 'bar');\n    await object.save();\n\n    getSpy.calls.reset();\n    putSpy.calls.reset();\n    delSpy.calls.reset();\n\n    const query = new Parse.Query(TestObject);\n    await query.get(object.id);\n    expect(getSpy.calls.count()).toBe(2);\n    expect(putSpy.calls.count()).toBe(1);\n    expect(delSpy.calls.count()).toBe(1);\n\n    const keys = await cacheAdapter.getAllKeys();\n    expect(keys.length).toBe(0);\n  });\n\n  it('test query include', async () => {\n    const child = new TestObject();\n    await child.save();\n\n    const object = new TestObject();\n    object.set('child', child);\n    await object.save();\n\n    getSpy.calls.reset();\n    putSpy.calls.reset();\n\n    const query = new Parse.Query(TestObject);\n    query.include('child');\n    await query.get(object.id);\n\n    expect(getSpy.calls.count()).toBe(4);\n    expect(putSpy.calls.count()).toBe(1);\n    expect(delSpy.calls.count()).toBe(3);\n\n    const keys = await cacheAdapter.getAllKeys();\n    expect(keys.length).toBe(0);\n  });\n\n  it('query relation without schema', async () => {\n    const child = new Parse.Object('ChildObject');\n    await child.save();\n\n    const parent = new Parse.Object('ParentObject');\n    const relation = parent.relation('child');\n    relation.add(child);\n    await parent.save();\n\n    getSpy.calls.reset();\n    putSpy.calls.reset();\n\n    const objects = await relation.query().find();\n    expect(objects.length).toBe(1);\n    expect(objects[0].id).toBe(child.id);\n\n    expect(getSpy.calls.count()).toBe(2);\n    expect(putSpy.calls.count()).toBe(1);\n    expect(delSpy.calls.count()).toBe(3);\n\n    const keys = await cacheAdapter.getAllKeys();\n    expect(keys.length).toBe(0);\n  });\n\n  it('test delete object', async () => {\n    const object = new TestObject();\n    object.set('foo', 'bar');\n    await object.save();\n\n    getSpy.calls.reset();\n    putSpy.calls.reset();\n    delSpy.calls.reset();\n\n    await object.destroy();\n    expect(getSpy.calls.count()).toBe(2);\n    expect(putSpy.calls.count()).toBe(1);\n    expect(delSpy.calls.count()).toBe(1);\n\n    const keys = await cacheAdapter.getAllKeys();\n    expect(keys.length).toBe(0);\n  });\n\n  it('test schema update class', async () => {\n    const container = new Container();\n    await container.save();\n\n    getSpy.calls.reset();\n    putSpy.calls.reset();\n    delSpy.calls.reset();\n\n    const config = Config.get('test');\n    const schema = await config.database.loadSchema();\n    await schema.reloadData();\n\n    const levelPermissions = {\n      find: { '*': true },\n      get: { '*': true },\n      create: { '*': true },\n      update: { '*': true },\n      delete: { '*': true },\n      addField: { '*': true },\n      protectedFields: { '*': [] },\n    };\n\n    await schema.updateClass(\n      'Container',\n      {\n        fooOne: { type: 'Number' },\n        fooTwo: { type: 'Array' },\n        fooThree: { type: 'Date' },\n        fooFour: { type: 'Object' },\n        fooFive: { type: 'Relation', targetClass: '_User' },\n        fooSix: { type: 'String' },\n        fooSeven: { type: 'Object' },\n        fooEight: { type: 'String' },\n        fooNine: { type: 'String' },\n        fooTeen: { type: 'Number' },\n        fooEleven: { type: 'String' },\n        fooTwelve: { type: 'String' },\n        fooThirteen: { type: 'String' },\n        fooFourteen: { type: 'String' },\n        fooFifteen: { type: 'String' },\n        fooSixteen: { type: 'String' },\n        fooEighteen: { type: 'String' },\n        fooNineteen: { type: 'String' },\n      },\n      levelPermissions,\n      {},\n      config.database\n    );\n    expect(getSpy.calls.count()).toBe(3);\n    expect(putSpy.calls.count()).toBe(3);\n    expect(delSpy.calls.count()).toBe(0);\n\n    const keys = await cacheAdapter.getAllKeys();\n    expect(keys.length).toBe(1);\n  });\n});\n", "'use strict';\n// These tests check the \"find\" functionality of the REST API.\nconst auth = require('../lib/Auth');\nconst Config = require('../lib/Config');\nconst rest = require('../lib/rest');\nconst RestQuery = require('../lib/RestQuery');\nconst request = require('../lib/request');\n\nconst querystring = require('querystring');\n\nlet config;\nlet database;\nconst nobody = auth.nobody(config);\n\ndescribe('rest query', () => {\n  beforeEach(() => {\n    config = Config.get('test');\n    database = config.database;\n  });\n\n  it('basic query', done => {\n    rest\n      .create(config, nobody, 'TestObject', {})\n      .then(() => {\n        return rest.find(config, nobody, 'TestObject', {});\n      })\n      .then(response => {\n        expect(response.results.length).toEqual(1);\n        done();\n      });\n  });\n\n  it('query with limit', done => {\n    rest\n      .create(config, nobody, 'TestObject', { foo: 'baz' })\n      .then(() => {\n        return rest.create(config, nobody, 'TestObject', { foo: 'qux' });\n      })\n      .then(() => {\n        return rest.find(config, nobody, 'TestObject', {}, { limit: 1 });\n      })\n      .then(response => {\n        expect(response.results.length).toEqual(1);\n        expect(response.results[0].foo).toBeTruthy();\n        done();\n      });\n  });\n\n  const data = {\n    username: 'blah',\n    password: 'pass',\n    sessionToken: 'abc123',\n  };\n\n  it_exclude_dbs(['postgres'])(\n    'query for user w/ legacy credentials without masterKey has them stripped from results',\n    done => {\n      database\n        .create('_User', data)\n        .then(() => {\n          return rest.find(config, nobody, '_User');\n        })\n        .then(result => {\n          const user = result.results[0];\n          expect(user.username).toEqual('blah');\n          expect(user.sessionToken).toBeUndefined();\n          expect(user.password).toBeUndefined();\n          done();\n        });\n    }\n  );\n\n  it_exclude_dbs(['postgres'])(\n    'query for user w/ legacy credentials with masterKey has them stripped from results',\n    done => {\n      database\n        .create('_User', data)\n        .then(() => {\n          return rest.find(config, { isMaster: true }, '_User');\n        })\n        .then(result => {\n          const user = result.results[0];\n          expect(user.username).toEqual('blah');\n          expect(user.sessionToken).toBeUndefined();\n          expect(user.password).toBeUndefined();\n          done();\n        });\n    }\n  );\n\n  // Created to test a scenario in AnyPic\n  it_exclude_dbs(['postgres'])('query with include', done => {\n    let photo = {\n      foo: 'bar',\n    };\n    let user = {\n      username: 'aUsername',\n      password: 'aPassword',\n    };\n    const activity = {\n      type: 'comment',\n      photo: {\n        __type: 'Pointer',\n        className: 'TestPhoto',\n        objectId: '',\n      },\n      fromUser: {\n        __type: 'Pointer',\n        className: '_User',\n        objectId: '',\n      },\n    };\n    const queryWhere = {\n      photo: {\n        __type: 'Pointer',\n        className: 'TestPhoto',\n        objectId: '',\n      },\n      type: 'comment',\n    };\n    const queryOptions = {\n      include: 'fromUser',\n      order: 'createdAt',\n      limit: 30,\n    };\n    rest\n      .create(config, nobody, 'TestPhoto', photo)\n      .then(p => {\n        photo = p;\n        return rest.create(config, nobody, '_User', user);\n      })\n      .then(u => {\n        user = u.response;\n        activity.photo.objectId = photo.objectId;\n        activity.fromUser.objectId = user.objectId;\n        return rest.create(config, nobody, 'TestActivity', activity);\n      })\n      .then(() => {\n        queryWhere.photo.objectId = photo.objectId;\n        return rest.find(config, nobody, 'TestActivity', queryWhere, queryOptions);\n      })\n      .then(response => {\n        const results = response.results;\n        expect(results.length).toEqual(1);\n        expect(typeof results[0].objectId).toEqual('string');\n        expect(typeof results[0].photo).toEqual('object');\n        expect(typeof results[0].fromUser).toEqual('object');\n        expect(typeof results[0].fromUser.username).toEqual('string');\n        done();\n      })\n      .catch(error => {\n        console.log(error);\n      });\n  });\n\n  it('query non-existent class when disabled client class creation', done => {\n    const customConfig = Object.assign({}, config, {\n      allowClientClassCreation: false,\n    });\n    rest.find(customConfig, auth.nobody(customConfig), 'ClientClassCreation', {}).then(\n      () => {\n        fail('Should throw an error');\n        done();\n      },\n      err => {\n        expect(err.code).toEqual(Parse.Error.OPERATION_FORBIDDEN);\n        expect(err.message).toEqual(\n          'This user is not allowed to access ' + 'non-existent class: ClientClassCreation'\n        );\n        done();\n      }\n    );\n  });\n\n  it('query existent class when disabled client class creation', async () => {\n    const customConfig = Object.assign({}, config, {\n      allowClientClassCreation: false,\n    });\n    const schema = await config.database.loadSchema();\n    const actualSchema = await schema.addClassIfNotExists('ClientClassCreation', {});\n    expect(actualSchema.className).toEqual('ClientClassCreation');\n\n    await schema.reloadData({ clearCache: true });\n    // Should not throw\n    const result = await rest.find(\n      customConfig,\n      auth.nobody(customConfig),\n      'ClientClassCreation',\n      {}\n    );\n    expect(result.results.length).toEqual(0);\n  });\n\n  it('query with wrongly encoded parameter', done => {\n    rest\n      .create(config, nobody, 'TestParameterEncode', { foo: 'bar' })\n      .then(() => {\n        return rest.create(config, nobody, 'TestParameterEncode', {\n          foo: 'baz',\n        });\n      })\n      .then(() => {\n        const headers = {\n          'X-Parse-Application-Id': 'test',\n          'X-Parse-REST-API-Key': 'rest',\n        };\n\n        const p0 = request({\n          headers: headers,\n          url:\n            'http://localhost:8378/1/classes/TestParameterEncode?' +\n            querystring\n              .stringify({\n                where: '{\"foo\":{\"$ne\": \"baz\"}}',\n                limit: 1,\n              })\n              .replace('=', '%3D'),\n        }).then(fail, response => {\n          const error = response.data;\n          expect(error.code).toEqual(Parse.Error.INVALID_QUERY);\n        });\n\n        const p1 = request({\n          headers: headers,\n          url:\n            'http://localhost:8378/1/classes/TestParameterEncode?' +\n            querystring\n              .stringify({\n                limit: 1,\n              })\n              .replace('=', '%3D'),\n        }).then(fail, response => {\n          const error = response.data;\n          expect(error.code).toEqual(Parse.Error.INVALID_QUERY);\n        });\n        return Promise.all([p0, p1]);\n      })\n      .then(done)\n      .catch(err => {\n        jfail(err);\n        fail('should not fail');\n        done();\n      });\n  });\n\n  it('query with limit = 0', done => {\n    rest\n      .create(config, nobody, 'TestObject', { foo: 'baz' })\n      .then(() => {\n        return rest.create(config, nobody, 'TestObject', { foo: 'qux' });\n      })\n      .then(() => {\n        return rest.find(config, nobody, 'TestObject', {}, { limit: 0 });\n      })\n      .then(response => {\n        expect(response.results.length).toEqual(0);\n        done();\n      });\n  });\n\n  it('query with limit = 0 and count = 1', done => {\n    rest\n      .create(config, nobody, 'TestObject', { foo: 'baz' })\n      .then(() => {\n        return rest.create(config, nobody, 'TestObject', { foo: 'qux' });\n      })\n      .then(() => {\n        return rest.find(config, nobody, 'TestObject', {}, { limit: 0, count: 1 });\n      })\n      .then(response => {\n        expect(response.results.length).toEqual(0);\n        expect(response.count).toEqual(2);\n        done();\n      });\n  });\n\n  it('makes sure null pointers are handed correctly #2189', done => {\n    const object = new Parse.Object('AnObject');\n    const anotherObject = new Parse.Object('AnotherObject');\n    anotherObject\n      .save()\n      .then(() => {\n        object.set('values', [null, null, anotherObject]);\n        return object.save();\n      })\n      .then(() => {\n        const query = new Parse.Query('AnObject');\n        query.include('values');\n        return query.first();\n      })\n      .then(\n        result => {\n          const values = result.get('values');\n          expect(values.length).toBe(3);\n          let anotherObjectFound = false;\n          let nullCounts = 0;\n          for (const value of values) {\n            if (value === null) {\n              nullCounts++;\n            } else if (value instanceof Parse.Object) {\n              anotherObjectFound = true;\n            }\n          }\n          expect(nullCounts).toBe(2);\n          expect(anotherObjectFound).toBeTruthy();\n          done();\n        },\n        err => {\n          console.error(err);\n          fail(err);\n          done();\n        }\n      );\n  });\n});\n\ndescribe('RestQuery.each', () => {\n  it('should run each', async () => {\n    const objects = [];\n    while (objects.length != 10) {\n      objects.push(new Parse.Object('Object', { value: objects.length }));\n    }\n    const config = Config.get('test');\n    await Parse.Object.saveAll(objects);\n    const query = new RestQuery(\n      config,\n      auth.master(config),\n      'Object',\n      { value: { $gt: 2 } },\n      { limit: 2 }\n    );\n    const spy = spyOn(query, 'execute').and.callThrough();\n    const classSpy = spyOn(RestQuery.prototype, 'execute').and.callThrough();\n    const results = [];\n    await query.each(result => {\n      expect(result.value).toBeGreaterThan(2);\n      results.push(result);\n    });\n    expect(spy.calls.count()).toBe(0);\n    expect(classSpy.calls.count()).toBe(4);\n    expect(results.length).toBe(7);\n  });\n\n  it('should work with query on relations', async () => {\n    const objectA = new Parse.Object('Letter', { value: 'A' });\n    const objectB = new Parse.Object('Letter', { value: 'B' });\n\n    const object1 = new Parse.Object('Number', { value: '1' });\n    const object2 = new Parse.Object('Number', { value: '2' });\n    const object3 = new Parse.Object('Number', { value: '3' });\n    const object4 = new Parse.Object('Number', { value: '4' });\n    await Parse.Object.saveAll([object1, object2, object3, object4]);\n\n    objectA.relation('numbers').add(object1);\n    objectB.relation('numbers').add(object2);\n    await Parse.Object.saveAll([objectA, objectB]);\n\n    const config = Config.get('test');\n\n    /**\n     * Two queries needed since objectId are sorted and we can't know which one\n     * going to be the first and then skip by the $gt added by each\n     */\n    const queryOne = new RestQuery(\n      config,\n      auth.master(config),\n      'Letter',\n      {\n        numbers: {\n          __type: 'Pointer',\n          className: 'Number',\n          objectId: object1.id,\n        },\n      },\n      { limit: 1 }\n    );\n    const queryTwo = new RestQuery(\n      config,\n      auth.master(config),\n      'Letter',\n      {\n        numbers: {\n          __type: 'Pointer',\n          className: 'Number',\n          objectId: object2.id,\n        },\n      },\n      { limit: 1 }\n    );\n\n    const classSpy = spyOn(RestQuery.prototype, 'execute').and.callThrough();\n    const resultsOne = [];\n    const resultsTwo = [];\n    await queryOne.each(result => {\n      resultsOne.push(result);\n    });\n    await queryTwo.each(result => {\n      resultsTwo.push(result);\n    });\n    expect(classSpy.calls.count()).toBe(4);\n    expect(resultsOne.length).toBe(1);\n    expect(resultsTwo.length).toBe(1);\n  });\n\n  it('test afterSave response object is return', done => {\n    Parse.Cloud.beforeSave('TestObject2', function (req) {\n      req.object.set('tobeaddbefore', true);\n      req.object.set('tobeaddbeforeandremoveafter', true);\n    });\n\n    Parse.Cloud.afterSave('TestObject2', function (req) {\n      const jsonObject = req.object.toJSON();\n      delete jsonObject.todelete;\n      delete jsonObject.tobeaddbeforeandremoveafter;\n      jsonObject.toadd = true;\n\n      return jsonObject;\n    });\n\n    rest.create(config, nobody, 'TestObject2', { todelete: true, tokeep: true }).then(response => {\n      expect(response.response.toadd).toBeTruthy();\n      expect(response.response.tokeep).toBeTruthy();\n      expect(response.response.tobeaddbefore).toBeTruthy();\n      expect(response.response.tobeaddbeforeandremoveafter).toBeUndefined();\n      expect(response.response.todelete).toBeUndefined();\n      done();\n    });\n  });\n});\n", "\ufeff// @flow\n// A database adapter that works with data exported from the hosted\n// Parse database.\n\n// @flow-disable-next\nimport { Parse } from 'parse/node';\n// @flow-disable-next\nimport _ from 'lodash';\n// @flow-disable-next\nimport intersect from 'intersect';\n// @flow-disable-next\nimport deepcopy from 'deepcopy';\nimport logger from '../logger';\nimport Utils from '../Utils';\nimport * as SchemaController from './SchemaController';\nimport { StorageAdapter } from '../Adapters/Storage/StorageAdapter';\nimport type { ParseServerOptions } from '../Options';\nimport type { QueryOptions, FullQueryOptions } from '../Adapters/Storage/StorageAdapter';\n\nfunction addWriteACL(query, acl) {\n  const newQuery = _.cloneDeep(query);\n  //Can't be any existing '_wperm' query, we don't allow client queries on that, no need to $and\n  newQuery._wperm = { $in: [null, ...acl] };\n  return newQuery;\n}\n\nfunction addReadACL(query, acl) {\n  const newQuery = _.cloneDeep(query);\n  //Can't be any existing '_rperm' query, we don't allow client queries on that, no need to $and\n  newQuery._rperm = { $in: [null, '*', ...acl] };\n  return newQuery;\n}\n\n// Transforms a REST API formatted ACL object to our two-field mongo format.\nconst transformObjectACL = ({ ACL, ...result }) => {\n  if (!ACL) {\n    return result;\n  }\n\n  result._wperm = [];\n  result._rperm = [];\n\n  for (const entry in ACL) {\n    if (ACL[entry].read) {\n      result._rperm.push(entry);\n    }\n    if (ACL[entry].write) {\n      result._wperm.push(entry);\n    }\n  }\n  return result;\n};\n\nconst specialQuerykeys = [\n  '$and',\n  '$or',\n  '$nor',\n  '_rperm',\n  '_wperm',\n  '_perishable_token',\n  '_email_verify_token',\n  '_email_verify_token_expires_at',\n  '_account_lockout_expires_at',\n  '_failed_login_count',\n];\n\nconst isSpecialQueryKey = key => {\n  return specialQuerykeys.indexOf(key) >= 0;\n};\n\nconst validateQuery = (query: any): void => {\n  if (query.ACL) {\n    throw new Parse.Error(Parse.Error.INVALID_QUERY, 'Cannot query on ACL.');\n  }\n\n  if (query.$or) {\n    if (query.$or instanceof Array) {\n      query.$or.forEach(validateQuery);\n    } else {\n      throw new Parse.Error(Parse.Error.INVALID_QUERY, 'Bad $or format - use an array value.');\n    }\n  }\n\n  if (query.$and) {\n    if (query.$and instanceof Array) {\n      query.$and.forEach(validateQuery);\n    } else {\n      throw new Parse.Error(Parse.Error.INVALID_QUERY, 'Bad $and format - use an array value.');\n    }\n  }\n\n  if (query.$nor) {\n    if (query.$nor instanceof Array && query.$nor.length > 0) {\n      query.$nor.forEach(validateQuery);\n    } else {\n      throw new Parse.Error(\n        Parse.Error.INVALID_QUERY,\n        'Bad $nor format - use an array of at least 1 value.'\n      );\n    }\n  }\n\n  Object.keys(query).forEach(key => {\n    if (query && query[key] && query[key].$regex) {\n      if (typeof query[key].$options === 'string') {\n        if (!query[key].$options.match(/^[imxs]+$/)) {\n          throw new Parse.Error(\n            Parse.Error.INVALID_QUERY,\n            `Bad $options value for query: ${query[key].$options}`\n          );\n        }\n      }\n    }\n    if (!isSpecialQueryKey(key) && !key.match(/^[a-zA-Z][a-zA-Z0-9_\\.]*$/)) {\n      throw new Parse.Error(Parse.Error.INVALID_KEY_NAME, `Invalid key name: ${key}`);\n    }\n  });\n};\n\n// Filters out any data that shouldn't be on this REST-formatted object.\nconst filterSensitiveData = (\n  isMaster: boolean,\n  aclGroup: any[],\n  auth: any,\n  operation: any,\n  schema: SchemaController.SchemaController | any,\n  className: string,\n  protectedFields: null | Array<any>,\n  object: any\n) => {\n  let userId = null;\n  if (auth && auth.user) userId = auth.user.id;\n\n  // replace protectedFields when using pointer-permissions\n  const perms =\n    schema && schema.getClassLevelPermissions ? schema.getClassLevelPermissions(className) : {};\n  if (perms) {\n    const isReadOperation = ['get', 'find'].indexOf(operation) > -1;\n\n    if (isReadOperation && perms.protectedFields) {\n      // extract protectedFields added with the pointer-permission prefix\n      const protectedFieldsPointerPerm = Object.keys(perms.protectedFields)\n        .filter(key => key.startsWith('userField:'))\n        .map(key => {\n          return { key: key.substring(10), value: perms.protectedFields[key] };\n        });\n\n      const newProtectedFields: Array<string>[] = [];\n      let overrideProtectedFields = false;\n\n      // check if the object grants the current user access based on the extracted fields\n      protectedFieldsPointerPerm.forEach(pointerPerm => {\n        let pointerPermIncludesUser = false;\n        const readUserFieldValue = object[pointerPerm.key];\n        if (readUserFieldValue) {\n          if (Array.isArray(readUserFieldValue)) {\n            pointerPermIncludesUser = readUserFieldValue.some(\n              user => user.objectId && user.objectId === userId\n            );\n          } else {\n            pointerPermIncludesUser =\n              readUserFieldValue.objectId && readUserFieldValue.objectId === userId;\n          }\n        }\n\n        if (pointerPermIncludesUser) {\n          overrideProtectedFields = true;\n          newProtectedFields.push(pointerPerm.value);\n        }\n      });\n\n      // if at least one pointer-permission affected the current user\n      // intersect vs protectedFields from previous stage (@see addProtectedFields)\n      // Sets theory (intersections): A x (B x C) == (A x B) x C\n      if (overrideProtectedFields && protectedFields) {\n        newProtectedFields.push(protectedFields);\n      }\n      // intersect all sets of protectedFields\n      newProtectedFields.forEach(fields => {\n        if (fields) {\n          // if there're no protctedFields by other criteria ( id / role / auth)\n          // then we must intersect each set (per userField)\n          if (!protectedFields) {\n            protectedFields = fields;\n          } else {\n            protectedFields = protectedFields.filter(v => fields.includes(v));\n          }\n        }\n      });\n    }\n  }\n\n  const isUserClass = className === '_User';\n\n  /* special treat for the user class: don't filter protectedFields if currently loggedin user is\n  the retrieved user */\n  if (!(isUserClass && userId && object.objectId === userId)) {\n    protectedFields && protectedFields.forEach(k => delete object[k]);\n\n    // fields not requested by client (excluded),\n    //but were needed to apply protecttedFields\n    perms.protectedFields &&\n      perms.protectedFields.temporaryKeys &&\n      perms.protectedFields.temporaryKeys.forEach(k => delete object[k]);\n  }\n\n  if (!isUserClass) {\n    return object;\n  }\n\n  object.password = object._hashed_password;\n  delete object._hashed_password;\n\n  delete object.sessionToken;\n\n  if (isMaster) {\n    return object;\n  }\n  delete object._email_verify_token;\n  delete object._perishable_token;\n  delete object._perishable_token_expires_at;\n  delete object._tombstone;\n  delete object._email_verify_token_expires_at;\n  delete object._failed_login_count;\n  delete object._account_lockout_expires_at;\n  delete object._password_changed_at;\n  delete object._password_history;\n\n  if (aclGroup.indexOf(object.objectId) > -1) {\n    return object;\n  }\n  delete object.authData;\n  return object;\n};\n\nimport type { LoadSchemaOptions } from './types';\nimport MongoStorageAdapter from '../Adapters/Storage/Mongo/MongoStorageAdapter';\n\n// Runs an update on the database.\n// Returns a promise for an object with the new values for field\n// modifications that don't know their results ahead of time, like\n// 'increment'.\n// Options:\n//   acl:  a list of strings. If the object to be updated has an ACL,\n//         one of the provided strings must provide the caller with\n//         write permissions.\nconst specialKeysForUpdate = [\n  '_hashed_password',\n  '_perishable_token',\n  '_email_verify_token',\n  '_email_verify_token_expires_at',\n  '_account_lockout_expires_at',\n  '_failed_login_count',\n  '_perishable_token_expires_at',\n  '_password_changed_at',\n  '_password_history',\n];\n\nconst isSpecialUpdateKey = key => {\n  return specialKeysForUpdate.indexOf(key) >= 0;\n};\n\nfunction joinTableName(className, key) {\n  return `_Join:${key}:${className}`;\n}\n\nconst flattenUpdateOperatorsForCreate = object => {\n  for (const key in object) {\n    if (object[key] && object[key].__op) {\n      switch (object[key].__op) {\n        case 'Increment':\n          if (typeof object[key].amount !== 'number') {\n            throw new Parse.Error(Parse.Error.INVALID_JSON, 'objects to add must be an array');\n          }\n          object[key] = object[key].amount;\n          break;\n        case 'Add':\n          if (!(object[key].objects instanceof Array)) {\n            throw new Parse.Error(Parse.Error.INVALID_JSON, 'objects to add must be an array');\n          }\n          object[key] = object[key].objects;\n          break;\n        case 'AddUnique':\n          if (!(object[key].objects instanceof Array)) {\n            throw new Parse.Error(Parse.Error.INVALID_JSON, 'objects to add must be an array');\n          }\n          object[key] = object[key].objects;\n          break;\n        case 'Remove':\n          if (!(object[key].objects instanceof Array)) {\n            throw new Parse.Error(Parse.Error.INVALID_JSON, 'objects to add must be an array');\n          }\n          object[key] = [];\n          break;\n        case 'Delete':\n          delete object[key];\n          break;\n        default:\n          throw new Parse.Error(\n            Parse.Error.COMMAND_UNAVAILABLE,\n            `The ${object[key].__op} operator is not supported yet.`\n          );\n      }\n    }\n  }\n};\n\nconst transformAuthData = (className, object, schema) => {\n  if (object.authData && className === '_User') {\n    Object.keys(object.authData).forEach(provider => {\n      const providerData = object.authData[provider];\n      const fieldName = `_auth_data_${provider}`;\n      if (providerData == null) {\n        object[fieldName] = {\n          __op: 'Delete',\n        };\n      } else {\n        object[fieldName] = providerData;\n        schema.fields[fieldName] = { type: 'Object' };\n      }\n    });\n    delete object.authData;\n  }\n};\n// Transforms a Database format ACL to a REST API format ACL\nconst untransformObjectACL = ({ _rperm, _wperm, ...output }) => {\n  if (_rperm || _wperm) {\n    output.ACL = {};\n\n    (_rperm || []).forEach(entry => {\n      if (!output.ACL[entry]) {\n        output.ACL[entry] = { read: true };\n      } else {\n        output.ACL[entry]['read'] = true;\n      }\n    });\n\n    (_wperm || []).forEach(entry => {\n      if (!output.ACL[entry]) {\n        output.ACL[entry] = { write: true };\n      } else {\n        output.ACL[entry]['write'] = true;\n      }\n    });\n  }\n  return output;\n};\n\n/**\n * When querying, the fieldName may be compound, extract the root fieldName\n *     `temperature.celsius` becomes `temperature`\n * @param {string} fieldName that may be a compound field name\n * @returns {string} the root name of the field\n */\nconst getRootFieldName = (fieldName: string): string => {\n  return fieldName.split('.')[0];\n};\n\nconst relationSchema = {\n  fields: { relatedId: { type: 'String' }, owningId: { type: 'String' } },\n};\n\nclass DatabaseController {\n  adapter: StorageAdapter;\n  schemaCache: any;\n  schemaPromise: ?Promise<SchemaController.SchemaController>;\n  _transactionalSession: ?any;\n  options: ParseServerOptions;\n\n  constructor(adapter: StorageAdapter, schemaCache: any, options: ParseServerOptions) {\n    this.adapter = adapter;\n    this.schemaCache = schemaCache;\n    // We don't want a mutable this.schema, because then you could have\n    // one request that uses different schemas for different parts of\n    // it. Instead, use loadSchema to get a schema.\n    this.schemaPromise = null;\n    this._transactionalSession = null;\n    this.options = options;\n  }\n\n  collectionExists(className: string): Promise<boolean> {\n    return this.adapter.classExists(className);\n  }\n\n  purgeCollection(className: string): Promise<void> {\n    return this.loadSchema()\n      .then(schemaController => schemaController.getOneSchema(className))\n      .then(schema => this.adapter.deleteObjectsByQuery(className, schema, {}));\n  }\n\n  validateClassName(className: string): Promise<void> {\n    if (!SchemaController.classNameIsValid(className)) {\n      return Promise.reject(\n        new Parse.Error(Parse.Error.INVALID_CLASS_NAME, 'invalid className: ' + className)\n      );\n    }\n    return Promise.resolve();\n  }\n\n  // Returns a promise for a schemaController.\n  loadSchema(\n    options: LoadSchemaOptions = { clearCache: false }\n  ): Promise<SchemaController.SchemaController> {\n    if (this.schemaPromise != null) {\n      return this.schemaPromise;\n    }\n    this.schemaPromise = SchemaController.load(this.adapter, this.schemaCache, options);\n    this.schemaPromise.then(\n      () => delete this.schemaPromise,\n      () => delete this.schemaPromise\n    );\n    return this.loadSchema(options);\n  }\n\n  loadSchemaIfNeeded(\n    schemaController: SchemaController.SchemaController,\n    options: LoadSchemaOptions = { clearCache: false }\n  ): Promise<SchemaController.SchemaController> {\n    return schemaController ? Promise.resolve(schemaController) : this.loadSchema(options);\n  }\n\n  // Returns a promise for the classname that is related to the given\n  // classname through the key.\n  // TODO: make this not in the DatabaseController interface\n  redirectClassNameForKey(className: string, key: string): Promise<?string> {\n    return this.loadSchema().then(schema => {\n      var t = schema.getExpectedType(className, key);\n      if (t != null && typeof t !== 'string' && t.type === 'Relation') {\n        return t.targetClass;\n      }\n      return className;\n    });\n  }\n\n  // Uses the schema to validate the object (REST API format).\n  // Returns a promise that resolves to the new schema.\n  // This does not update this.schema, because in a situation like a\n  // batch request, that could confuse other users of the schema.\n  validateObject(\n    className: string,\n    object: any,\n    query: any,\n    runOptions: QueryOptions\n  ): Promise<boolean> {\n    let schema;\n    const acl = runOptions.acl;\n    const isMaster = acl === undefined;\n    var aclGroup: string[] = acl || [];\n    return this.loadSchema()\n      .then(s => {\n        schema = s;\n        if (isMaster) {\n          return Promise.resolve();\n        }\n        return this.canAddField(schema, className, object, aclGroup, runOptions);\n      })\n      .then(() => {\n        return schema.validateObject(className, object, query);\n      });\n  }\n\n  update(\n    className: string,\n    query: any,\n    update: any,\n    { acl, many, upsert, addsField }: FullQueryOptions = {},\n    skipSanitization: boolean = false,\n    validateOnly: boolean = false,\n    validSchemaController: SchemaController.SchemaController\n  ): Promise<any> {\n    const originalQuery = query;\n    const originalUpdate = update;\n    // Make a copy of the object, so we don't mutate the incoming data.\n    update = deepcopy(update);\n    var relationUpdates = [];\n    var isMaster = acl === undefined;\n    var aclGroup = acl || [];\n\n    return this.loadSchemaIfNeeded(validSchemaController).then(schemaController => {\n      return (isMaster\n        ? Promise.resolve()\n        : schemaController.validatePermission(className, aclGroup, 'update')\n      )\n        .then(() => {\n          relationUpdates = this.collectRelationUpdates(className, originalQuery.objectId, update);\n          if (!isMaster) {\n            query = this.addPointerPermissions(\n              schemaController,\n              className,\n              'update',\n              query,\n              aclGroup\n            );\n\n            if (addsField) {\n              query = {\n                $and: [\n                  query,\n                  this.addPointerPermissions(\n                    schemaController,\n                    className,\n                    'addField',\n                    query,\n                    aclGroup\n                  ),\n                ],\n              };\n            }\n          }\n          if (!query) {\n            return Promise.resolve();\n          }\n          if (acl) {\n            query = addWriteACL(query, acl);\n          }\n          validateQuery(query);\n          return schemaController\n            .getOneSchema(className, true)\n            .catch(error => {\n              // If the schema doesn't exist, pretend it exists with no fields. This behavior\n              // will likely need revisiting.\n              if (error === undefined) {\n                return { fields: {} };\n              }\n              throw error;\n            })\n            .then(schema => {\n              Object.keys(update).forEach(fieldName => {\n                if (fieldName.match(/^authData\\.([a-zA-Z0-9_]+)\\.id$/)) {\n                  throw new Parse.Error(\n                    Parse.Error.INVALID_KEY_NAME,\n                    `Invalid field name for update: ${fieldName}`\n                  );\n                }\n                const rootFieldName = getRootFieldName(fieldName);\n                if (\n                  !SchemaController.fieldNameIsValid(rootFieldName, className) &&\n                  !isSpecialUpdateKey(rootFieldName)\n                ) {\n                  throw new Parse.Error(\n                    Parse.Error.INVALID_KEY_NAME,\n                    `Invalid field name for update: ${fieldName}`\n                  );\n                }\n              });\n              for (const updateOperation in update) {\n                if (\n                  update[updateOperation] &&\n                  typeof update[updateOperation] === 'object' &&\n                  Object.keys(update[updateOperation]).some(\n                    innerKey => innerKey.includes('$') || innerKey.includes('.')\n                  )\n                ) {\n                  throw new Parse.Error(\n                    Parse.Error.INVALID_NESTED_KEY,\n                    \"Nested keys should not contain the '$' or '.' characters\"\n                  );\n                }\n              }\n              update = transformObjectACL(update);\n              transformAuthData(className, update, schema);\n              if (validateOnly) {\n                return this.adapter.find(className, schema, query, {}).then(result => {\n                  if (!result || !result.length) {\n                    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Object not found.');\n                  }\n                  return {};\n                });\n              }\n              if (many) {\n                return this.adapter.updateObjectsByQuery(\n                  className,\n                  schema,\n                  query,\n                  update,\n                  this._transactionalSession\n                );\n              } else if (upsert) {\n                return this.adapter.upsertOneObject(\n                  className,\n                  schema,\n                  query,\n                  update,\n                  this._transactionalSession\n                );\n              } else {\n                return this.adapter.findOneAndUpdate(\n                  className,\n                  schema,\n                  query,\n                  update,\n                  this._transactionalSession\n                );\n              }\n            });\n        })\n        .then((result: any) => {\n          if (!result) {\n            throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Object not found.');\n          }\n          if (validateOnly) {\n            return result;\n          }\n          return this.handleRelationUpdates(\n            className,\n            originalQuery.objectId,\n            update,\n            relationUpdates\n          ).then(() => {\n            return result;\n          });\n        })\n        .then(result => {\n          if (skipSanitization) {\n            return Promise.resolve(result);\n          }\n          return this._sanitizeDatabaseResult(originalUpdate, result);\n        });\n    });\n  }\n\n  // Collect all relation-updating operations from a REST-format update.\n  // Returns a list of all relation updates to perform\n  // This mutates update.\n  collectRelationUpdates(className: string, objectId: ?string, update: any) {\n    var ops = [];\n    var deleteMe = [];\n    objectId = update.objectId || objectId;\n\n    var process = (op, key) => {\n      if (!op) {\n        return;\n      }\n      if (op.__op == 'AddRelation') {\n        ops.push({ key, op });\n        deleteMe.push(key);\n      }\n\n      if (op.__op == 'RemoveRelation') {\n        ops.push({ key, op });\n        deleteMe.push(key);\n      }\n\n      if (op.__op == 'Batch') {\n        for (var x of op.ops) {\n          process(x, key);\n        }\n      }\n    };\n\n    for (const key in update) {\n      process(update[key], key);\n    }\n    for (const key of deleteMe) {\n      delete update[key];\n    }\n    return ops;\n  }\n\n  // Processes relation-updating operations from a REST-format update.\n  // Returns a promise that resolves when all updates have been performed\n  handleRelationUpdates(className: string, objectId: string, update: any, ops: any) {\n    var pending = [];\n    objectId = update.objectId || objectId;\n    ops.forEach(({ key, op }) => {\n      if (!op) {\n        return;\n      }\n      if (op.__op == 'AddRelation') {\n        for (const object of op.objects) {\n          pending.push(this.addRelation(key, className, objectId, object.objectId));\n        }\n      }\n\n      if (op.__op == 'RemoveRelation') {\n        for (const object of op.objects) {\n          pending.push(this.removeRelation(key, className, objectId, object.objectId));\n        }\n      }\n    });\n\n    return Promise.all(pending);\n  }\n\n  // Adds a relation.\n  // Returns a promise that resolves successfully iff the add was successful.\n  addRelation(key: string, fromClassName: string, fromId: string, toId: string) {\n    const doc = {\n      relatedId: toId,\n      owningId: fromId,\n    };\n    return this.adapter.upsertOneObject(\n      `_Join:${key}:${fromClassName}`,\n      relationSchema,\n      doc,\n      doc,\n      this._transactionalSession\n    );\n  }\n\n  // Removes a relation.\n  // Returns a promise that resolves successfully iff the remove was\n  // successful.\n  removeRelation(key: string, fromClassName: string, fromId: string, toId: string) {\n    var doc = {\n      relatedId: toId,\n      owningId: fromId,\n    };\n    return this.adapter\n      .deleteObjectsByQuery(\n        `_Join:${key}:${fromClassName}`,\n        relationSchema,\n        doc,\n        this._transactionalSession\n      )\n      .catch(error => {\n        // We don't care if they try to delete a non-existent relation.\n        if (error.code == Parse.Error.OBJECT_NOT_FOUND) {\n          return;\n        }\n        throw error;\n      });\n  }\n\n  // Removes objects matches this query from the database.\n  // Returns a promise that resolves successfully iff the object was\n  // deleted.\n  // Options:\n  //   acl:  a list of strings. If the object to be updated has an ACL,\n  //         one of the provided strings must provide the caller with\n  //         write permissions.\n  destroy(\n    className: string,\n    query: any,\n    { acl }: QueryOptions = {},\n    validSchemaController: SchemaController.SchemaController\n  ): Promise<any> {\n    const isMaster = acl === undefined;\n    const aclGroup = acl || [];\n\n    return this.loadSchemaIfNeeded(validSchemaController).then(schemaController => {\n      return (isMaster\n        ? Promise.resolve()\n        : schemaController.validatePermission(className, aclGroup, 'delete')\n      ).then(() => {\n        if (!isMaster) {\n          query = this.addPointerPermissions(\n            schemaController,\n            className,\n            'delete',\n            query,\n            aclGroup\n          );\n          if (!query) {\n            throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Object not found.');\n          }\n        }\n        // delete by query\n        if (acl) {\n          query = addWriteACL(query, acl);\n        }\n        validateQuery(query);\n        return schemaController\n          .getOneSchema(className)\n          .catch(error => {\n            // If the schema doesn't exist, pretend it exists with no fields. This behavior\n            // will likely need revisiting.\n            if (error === undefined) {\n              return { fields: {} };\n            }\n            throw error;\n          })\n          .then(parseFormatSchema =>\n            this.adapter.deleteObjectsByQuery(\n              className,\n              parseFormatSchema,\n              query,\n              this._transactionalSession\n            )\n          )\n          .catch(error => {\n            // When deleting sessions while changing passwords, don't throw an error if they don't have any sessions.\n            if (className === '_Session' && error.code === Parse.Error.OBJECT_NOT_FOUND) {\n              return Promise.resolve({});\n            }\n            throw error;\n          });\n      });\n    });\n  }\n\n  // Inserts an object into the database.\n  // Returns a promise that resolves successfully iff the object saved.\n  create(\n    className: string,\n    object: any,\n    { acl }: QueryOptions = {},\n    validateOnly: boolean = false,\n    validSchemaController: SchemaController.SchemaController\n  ): Promise<any> {\n    // Make a copy of the object, so we don't mutate the incoming data.\n    const originalObject = object;\n    object = transformObjectACL(object);\n\n    object.createdAt = { iso: object.createdAt, __type: 'Date' };\n    object.updatedAt = { iso: object.updatedAt, __type: 'Date' };\n\n    var isMaster = acl === undefined;\n    var aclGroup = acl || [];\n    const relationUpdates = this.collectRelationUpdates(className, null, object);\n\n    return this.validateClassName(className)\n      .then(() => this.loadSchemaIfNeeded(validSchemaController))\n      .then(schemaController => {\n        return (isMaster\n          ? Promise.resolve()\n          : schemaController.validatePermission(className, aclGroup, 'create')\n        )\n          .then(() => schemaController.enforceClassExists(className))\n          .then(() => schemaController.getOneSchema(className, true))\n          .then(schema => {\n            transformAuthData(className, object, schema);\n            flattenUpdateOperatorsForCreate(object);\n            if (validateOnly) {\n              return {};\n            }\n            return this.adapter.createObject(\n              className,\n              SchemaController.convertSchemaToAdapterSchema(schema),\n              object,\n              this._transactionalSession\n            );\n          })\n          .then(result => {\n            if (validateOnly) {\n              return originalObject;\n            }\n            return this.handleRelationUpdates(\n              className,\n              object.objectId,\n              object,\n              relationUpdates\n            ).then(() => {\n              return this._sanitizeDatabaseResult(originalObject, result.ops[0]);\n            });\n          });\n      });\n  }\n\n  canAddField(\n    schema: SchemaController.SchemaController,\n    className: string,\n    object: any,\n    aclGroup: string[],\n    runOptions: QueryOptions\n  ): Promise<void> {\n    const classSchema = schema.schemaData[className];\n    if (!classSchema) {\n      return Promise.resolve();\n    }\n    const fields = Object.keys(object);\n    const schemaFields = Object.keys(classSchema.fields);\n    const newKeys = fields.filter(field => {\n      // Skip fields that are unset\n      if (object[field] && object[field].__op && object[field].__op === 'Delete') {\n        return false;\n      }\n      return schemaFields.indexOf(field) < 0;\n    });\n    if (newKeys.length > 0) {\n      // adds a marker that new field is being adding during update\n      runOptions.addsField = true;\n\n      const action = runOptions.action;\n      return schema.validatePermission(className, aclGroup, 'addField', action);\n    }\n    return Promise.resolve();\n  }\n\n  // Won't delete collections in the system namespace\n  /**\n   * Delete all classes and clears the schema cache\n   *\n   * @param {boolean} fast set to true if it's ok to just delete rows and not indexes\n   * @returns {Promise<void>} when the deletions completes\n   */\n  deleteEverything(fast: boolean = false): Promise<any> {\n    this.schemaPromise = null;\n    return Promise.all([this.adapter.deleteAllClasses(fast), this.schemaCache.clear()]);\n  }\n\n  // Returns a promise for a list of related ids given an owning id.\n  // className here is the owning className.\n  relatedIds(\n    className: string,\n    key: string,\n    owningId: string,\n    queryOptions: QueryOptions\n  ): Promise<Array<string>> {\n    const { skip, limit, sort } = queryOptions;\n    const findOptions = {};\n    if (sort && sort.createdAt && this.adapter.canSortOnJoinTables) {\n      findOptions.sort = { _id: sort.createdAt };\n      findOptions.limit = limit;\n      findOptions.skip = skip;\n      queryOptions.skip = 0;\n    }\n    return this.adapter\n      .find(joinTableName(className, key), relationSchema, { owningId }, findOptions)\n      .then(results => results.map(result => result.relatedId));\n  }\n\n  // Returns a promise for a list of owning ids given some related ids.\n  // className here is the owning className.\n  owningIds(className: string, key: string, relatedIds: string[]): Promise<string[]> {\n    return this.adapter\n      .find(\n        joinTableName(className, key),\n        relationSchema,\n        { relatedId: { $in: relatedIds } },\n        { keys: ['owningId'] }\n      )\n      .then(results => results.map(result => result.owningId));\n  }\n\n  // Modifies query so that it no longer has $in on relation fields, or\n  // equal-to-pointer constraints on relation fields.\n  // Returns a promise that resolves when query is mutated\n  reduceInRelation(className: string, query: any, schema: any): Promise<any> {\n    // Search for an in-relation or equal-to-relation\n    // Make it sequential for now, not sure of paralleization side effects\n    if (query['$or']) {\n      const ors = query['$or'];\n      return Promise.all(\n        ors.map((aQuery, index) => {\n          return this.reduceInRelation(className, aQuery, schema).then(aQuery => {\n            query['$or'][index] = aQuery;\n          });\n        })\n      ).then(() => {\n        return Promise.resolve(query);\n      });\n    }\n\n    const promises = Object.keys(query).map(key => {\n      const t = schema.getExpectedType(className, key);\n      if (!t || t.type !== 'Relation') {\n        return Promise.resolve(query);\n      }\n      let queries: ?(any[]) = null;\n      if (\n        query[key] &&\n        (query[key]['$in'] ||\n          query[key]['$ne'] ||\n          query[key]['$nin'] ||\n          query[key].__type == 'Pointer')\n      ) {\n        // Build the list of queries\n        queries = Object.keys(query[key]).map(constraintKey => {\n          let relatedIds;\n          let isNegation = false;\n          if (constraintKey === 'objectId') {\n            relatedIds = [query[key].objectId];\n          } else if (constraintKey == '$in') {\n            relatedIds = query[key]['$in'].map(r => r.objectId);\n          } else if (constraintKey == '$nin') {\n            isNegation = true;\n            relatedIds = query[key]['$nin'].map(r => r.objectId);\n          } else if (constraintKey == '$ne') {\n            isNegation = true;\n            relatedIds = [query[key]['$ne'].objectId];\n          } else {\n            return;\n          }\n          return {\n            isNegation,\n            relatedIds,\n          };\n        });\n      } else {\n        queries = [{ isNegation: false, relatedIds: [] }];\n      }\n\n      // remove the current queryKey as we don,t need it anymore\n      delete query[key];\n      // execute each query independently to build the list of\n      // $in / $nin\n      const promises = queries.map(q => {\n        if (!q) {\n          return Promise.resolve();\n        }\n        return this.owningIds(className, key, q.relatedIds).then(ids => {\n          if (q.isNegation) {\n            this.addNotInObjectIdsIds(ids, query);\n          } else {\n            this.addInObjectIdsIds(ids, query);\n          }\n          return Promise.resolve();\n        });\n      });\n\n      return Promise.all(promises).then(() => {\n        return Promise.resolve();\n      });\n    });\n\n    return Promise.all(promises).then(() => {\n      return Promise.resolve(query);\n    });\n  }\n\n  // Modifies query so that it no longer has $relatedTo\n  // Returns a promise that resolves when query is mutated\n  reduceRelationKeys(className: string, query: any, queryOptions: any): ?Promise<void> {\n    if (query['$or']) {\n      return Promise.all(\n        query['$or'].map(aQuery => {\n          return this.reduceRelationKeys(className, aQuery, queryOptions);\n        })\n      );\n    }\n\n    var relatedTo = query['$relatedTo'];\n    if (relatedTo) {\n      return this.relatedIds(\n        relatedTo.object.className,\n        relatedTo.key,\n        relatedTo.object.objectId,\n        queryOptions\n      )\n        .then(ids => {\n          delete query['$relatedTo'];\n          this.addInObjectIdsIds(ids, query);\n          return this.reduceRelationKeys(className, query, queryOptions);\n        })\n        .then(() => {});\n    }\n  }\n\n  addInObjectIdsIds(ids: ?Array<string> = null, query: any) {\n    const idsFromString: ?Array<string> =\n      typeof query.objectId === 'string' ? [query.objectId] : null;\n    const idsFromEq: ?Array<string> =\n      query.objectId && query.objectId['$eq'] ? [query.objectId['$eq']] : null;\n    const idsFromIn: ?Array<string> =\n      query.objectId && query.objectId['$in'] ? query.objectId['$in'] : null;\n\n    // @flow-disable-next\n    const allIds: Array<Array<string>> = [idsFromString, idsFromEq, idsFromIn, ids].filter(\n      list => list !== null\n    );\n    const totalLength = allIds.reduce((memo, list) => memo + list.length, 0);\n\n    let idsIntersection = [];\n    if (totalLength > 125) {\n      idsIntersection = intersect.big(allIds);\n    } else {\n      idsIntersection = intersect(allIds);\n    }\n\n    // Need to make sure we don't clobber existing shorthand $eq constraints on objectId.\n    if (!('objectId' in query)) {\n      query.objectId = {\n        $in: undefined,\n      };\n    } else if (typeof query.objectId === 'string') {\n      query.objectId = {\n        $in: undefined,\n        $eq: query.objectId,\n      };\n    }\n    query.objectId['$in'] = idsIntersection;\n\n    return query;\n  }\n\n  addNotInObjectIdsIds(ids: string[] = [], query: any) {\n    const idsFromNin = query.objectId && query.objectId['$nin'] ? query.objectId['$nin'] : [];\n    let allIds = [...idsFromNin, ...ids].filter(list => list !== null);\n\n    // make a set and spread to remove duplicates\n    allIds = [...new Set(allIds)];\n\n    // Need to make sure we don't clobber existing shorthand $eq constraints on objectId.\n    if (!('objectId' in query)) {\n      query.objectId = {\n        $nin: undefined,\n      };\n    } else if (typeof query.objectId === 'string') {\n      query.objectId = {\n        $nin: undefined,\n        $eq: query.objectId,\n      };\n    }\n\n    query.objectId['$nin'] = allIds;\n    return query;\n  }\n\n  // Runs a query on the database.\n  // Returns a promise that resolves to a list of items.\n  // Options:\n  //   skip    number of results to skip.\n  //   limit   limit to this number of results.\n  //   sort    an object where keys are the fields to sort by.\n  //           the value is +1 for ascending, -1 for descending.\n  //   count   run a count instead of returning results.\n  //   acl     restrict this operation with an ACL for the provided array\n  //           of user objectIds and roles. acl: null means no user.\n  //           when this field is not present, don't do anything regarding ACLs.\n  //  caseInsensitive make string comparisons case insensitive\n  // TODO: make userIds not needed here. The db adapter shouldn't know\n  // anything about users, ideally. Then, improve the format of the ACL\n  // arg to work like the others.\n  find(\n    className: string,\n    query: any,\n    {\n      skip,\n      limit,\n      acl,\n      sort = {},\n      count,\n      keys,\n      op,\n      distinct,\n      pipeline,\n      readPreference,\n      hint,\n      caseInsensitive = false,\n      explain,\n    }: any = {},\n    auth: any = {},\n    validSchemaController: SchemaController.SchemaController\n  ): Promise<any> {\n    const isMaster = acl === undefined;\n    const aclGroup = acl || [];\n    op =\n      op || (typeof query.objectId == 'string' && Object.keys(query).length === 1 ? 'get' : 'find');\n    // Count operation if counting\n    op = count === true ? 'count' : op;\n\n    let classExists = true;\n    return this.loadSchemaIfNeeded(validSchemaController).then(schemaController => {\n      //Allow volatile classes if querying with Master (for _PushStatus)\n      //TODO: Move volatile classes concept into mongo adapter, postgres adapter shouldn't care\n      //that api.parse.com breaks when _PushStatus exists in mongo.\n      return schemaController\n        .getOneSchema(className, isMaster)\n        .catch(error => {\n          // Behavior for non-existent classes is kinda weird on Parse.com. Probably doesn't matter too much.\n          // For now, pretend the class exists but has no objects,\n          if (error === undefined) {\n            classExists = false;\n            return { fields: {} };\n          }\n          throw error;\n        })\n        .then(schema => {\n          // Parse.com treats queries on _created_at and _updated_at as if they were queries on createdAt and updatedAt,\n          // so duplicate that behavior here. If both are specified, the correct behavior to match Parse.com is to\n          // use the one that appears first in the sort list.\n          if (sort._created_at) {\n            sort.createdAt = sort._created_at;\n            delete sort._created_at;\n          }\n          if (sort._updated_at) {\n            sort.updatedAt = sort._updated_at;\n            delete sort._updated_at;\n          }\n          const queryOptions = {\n            skip,\n            limit,\n            sort,\n            keys,\n            readPreference,\n            hint,\n            caseInsensitive,\n            explain,\n          };\n          Object.keys(sort).forEach(fieldName => {\n            if (fieldName.match(/^authData\\.([a-zA-Z0-9_]+)\\.id$/)) {\n              throw new Parse.Error(Parse.Error.INVALID_KEY_NAME, `Cannot sort by ${fieldName}`);\n            }\n            const rootFieldName = getRootFieldName(fieldName);\n            if (!SchemaController.fieldNameIsValid(rootFieldName, className)) {\n              throw new Parse.Error(\n                Parse.Error.INVALID_KEY_NAME,\n                `Invalid field name: ${fieldName}.`\n              );\n            }\n          });\n          return (isMaster\n            ? Promise.resolve()\n            : schemaController.validatePermission(className, aclGroup, op)\n          )\n            .then(() => this.reduceRelationKeys(className, query, queryOptions))\n            .then(() => this.reduceInRelation(className, query, schemaController))\n            .then(() => {\n              let protectedFields;\n              if (!isMaster) {\n                query = this.addPointerPermissions(\n                  schemaController,\n                  className,\n                  op,\n                  query,\n                  aclGroup\n                );\n                /* Don't use projections to optimize the protectedFields since the protectedFields\n                  based on pointer-permissions are determined after querying. The filtering can\n                  overwrite the protected fields. */\n                protectedFields = this.addProtectedFields(\n                  schemaController,\n                  className,\n                  query,\n                  aclGroup,\n                  auth,\n                  queryOptions\n                );\n              }\n              if (!query) {\n                if (op === 'get') {\n                  throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Object not found.');\n                } else {\n                  return [];\n                }\n              }\n              if (!isMaster) {\n                if (op === 'update' || op === 'delete') {\n                  query = addWriteACL(query, aclGroup);\n                } else {\n                  query = addReadACL(query, aclGroup);\n                }\n              }\n              validateQuery(query);\n              if (count) {\n                if (!classExists) {\n                  return 0;\n                } else {\n                  return this.adapter.count(\n                    className,\n                    schema,\n                    query,\n                    readPreference,\n                    undefined,\n                    hint\n                  );\n                }\n              } else if (distinct) {\n                if (!classExists) {\n                  return [];\n                } else {\n                  return this.adapter.distinct(className, schema, query, distinct);\n                }\n              } else if (pipeline) {\n                if (!classExists) {\n                  return [];\n                } else {\n                  return this.adapter.aggregate(\n                    className,\n                    schema,\n                    pipeline,\n                    readPreference,\n                    hint,\n                    explain\n                  );\n                }\n              } else if (explain) {\n                return this.adapter.find(className, schema, query, queryOptions);\n              } else {\n                return this.adapter\n                  .find(className, schema, query, queryOptions)\n                  .then(objects =>\n                    objects.map(object => {\n                      object = untransformObjectACL(object);\n                      return filterSensitiveData(\n                        isMaster,\n                        aclGroup,\n                        auth,\n                        op,\n                        schemaController,\n                        className,\n                        protectedFields,\n                        object\n                      );\n                    })\n                  )\n                  .catch(error => {\n                    throw new Parse.Error(Parse.Error.INTERNAL_SERVER_ERROR, error);\n                  });\n              }\n            });\n        });\n    });\n  }\n\n  deleteSchema(className: string): Promise<void> {\n    return this.loadSchema({ clearCache: true })\n      .then(schemaController => schemaController.getOneSchema(className, true))\n      .catch(error => {\n        if (error === undefined) {\n          return { fields: {} };\n        } else {\n          throw error;\n        }\n      })\n      .then((schema: any) => {\n        return this.collectionExists(className)\n          .then(() => this.adapter.count(className, { fields: {} }, null, '', false))\n          .then(count => {\n            if (count > 0) {\n              throw new Parse.Error(\n                255,\n                `Class ${className} is not empty, contains ${count} objects, cannot drop schema.`\n              );\n            }\n            return this.adapter.deleteClass(className);\n          })\n          .then(wasParseCollection => {\n            if (wasParseCollection) {\n              const relationFieldNames = Object.keys(schema.fields).filter(\n                fieldName => schema.fields[fieldName].type === 'Relation'\n              );\n              return Promise.all(\n                relationFieldNames.map(name =>\n                  this.adapter.deleteClass(joinTableName(className, name))\n                )\n              ).then(() => {\n                return;\n              });\n            } else {\n              return Promise.resolve();\n            }\n          });\n      });\n  }\n\n  // Constraints query using CLP's pointer permissions (PP) if any.\n  // 1. Etract the user id from caller's ACLgroup;\n  // 2. Exctract a list of field names that are PP for target collection and operation;\n  // 3. Constraint the original query so that each PP field must\n  // point to caller's id (or contain it in case of PP field being an array)\n  addPointerPermissions(\n    schema: SchemaController.SchemaController,\n    className: string,\n    operation: string,\n    query: any,\n    aclGroup: any[] = []\n  ): any {\n    // Check if class has public permission for operation\n    // If the BaseCLP pass, let go through\n    if (schema.testPermissionsForClassName(className, aclGroup, operation)) {\n      return query;\n    }\n    const perms = schema.getClassLevelPermissions(className);\n\n    const userACL = aclGroup.filter(acl => {\n      return acl.indexOf('role:') != 0 && acl != '*';\n    });\n\n    const groupKey =\n      ['get', 'find', 'count'].indexOf(operation) > -1 ? 'readUserFields' : 'writeUserFields';\n\n    const permFields = [];\n\n    if (perms[operation] && perms[operation].pointerFields) {\n      permFields.push(...perms[operation].pointerFields);\n    }\n\n    if (perms[groupKey]) {\n      for (const field of perms[groupKey]) {\n        if (!permFields.includes(field)) {\n          permFields.push(field);\n        }\n      }\n    }\n    // the ACL should have exactly 1 user\n    if (permFields.length > 0) {\n      // the ACL should have exactly 1 user\n      // No user set return undefined\n      // If the length is > 1, that means we didn't de-dupe users correctly\n      if (userACL.length != 1) {\n        return;\n      }\n      const userId = userACL[0];\n      const userPointer = {\n        __type: 'Pointer',\n        className: '_User',\n        objectId: userId,\n      };\n\n      const queries = permFields.map(key => {\n        const fieldDescriptor = schema.getExpectedType(className, key);\n        const fieldType =\n          fieldDescriptor &&\n          typeof fieldDescriptor === 'object' &&\n          Object.prototype.hasOwnProperty.call(fieldDescriptor, 'type')\n            ? fieldDescriptor.type\n            : null;\n\n        let queryClause;\n\n        if (fieldType === 'Pointer') {\n          // constraint for single pointer setup\n          queryClause = { [key]: userPointer };\n        } else if (fieldType === 'Array') {\n          // constraint for users-array setup\n          queryClause = { [key]: { $all: [userPointer] } };\n        } else if (fieldType === 'Object') {\n          // constraint for object setup\n          queryClause = { [key]: userPointer };\n        } else {\n          // This means that there is a CLP field of an unexpected type. This condition should not happen, which is\n          // why is being treated as an error.\n          throw Error(\n            `An unexpected condition occurred when resolving pointer permissions: ${className} ${key}`\n          );\n        }\n        // if we already have a constraint on the key, use the $and\n        if (Object.prototype.hasOwnProperty.call(query, key)) {\n          return { $and: [queryClause, query] };\n        }\n        // otherwise just add the constaint\n        return Object.assign({}, query, queryClause);\n      });\n\n      return queries.length === 1 ? queries[0] : { $or: queries };\n    } else {\n      return query;\n    }\n  }\n\n  addProtectedFields(\n    schema: SchemaController.SchemaController | any,\n    className: string,\n    query: any = {},\n    aclGroup: any[] = [],\n    auth: any = {},\n    queryOptions: FullQueryOptions = {}\n  ): null | string[] {\n    const perms =\n      schema && schema.getClassLevelPermissions\n        ? schema.getClassLevelPermissions(className)\n        : schema;\n    if (!perms) return null;\n\n    const protectedFields = perms.protectedFields;\n    if (!protectedFields) return null;\n\n    if (aclGroup.indexOf(query.objectId) > -1) return null;\n\n    // for queries where \"keys\" are set and do not include all 'userField':{field},\n    // we have to transparently include it, and then remove before returning to client\n    // Because if such key not projected the permission won't be enforced properly\n    // PS this is called when 'excludeKeys' already reduced to 'keys'\n    const preserveKeys = queryOptions.keys;\n\n    // these are keys that need to be included only\n    // to be able to apply protectedFields by pointer\n    // and then unset before returning to client (later in  filterSensitiveFields)\n    const serverOnlyKeys = [];\n\n    const authenticated = auth.user;\n\n    // map to allow check without array search\n    const roles = (auth.userRoles || []).reduce((acc, r) => {\n      acc[r] = protectedFields[r];\n      return acc;\n    }, {});\n\n    // array of sets of protected fields. separate item for each applicable criteria\n    const protectedKeysSets = [];\n\n    for (const key in protectedFields) {\n      // skip userFields\n      if (key.startsWith('userField:')) {\n        if (preserveKeys) {\n          const fieldName = key.substring(10);\n          if (!preserveKeys.includes(fieldName)) {\n            // 1. put it there temporarily\n            queryOptions.keys && queryOptions.keys.push(fieldName);\n            // 2. preserve it delete later\n            serverOnlyKeys.push(fieldName);\n          }\n        }\n        continue;\n      }\n\n      // add public tier\n      if (key === '*') {\n        protectedKeysSets.push(protectedFields[key]);\n        continue;\n      }\n\n      if (authenticated) {\n        if (key === 'authenticated') {\n          // for logged in users\n          protectedKeysSets.push(protectedFields[key]);\n          continue;\n        }\n\n        if (roles[key] && key.startsWith('role:')) {\n          // add applicable roles\n          protectedKeysSets.push(roles[key]);\n        }\n      }\n    }\n\n    // check if there's a rule for current user's id\n    if (authenticated) {\n      const userId = auth.user.id;\n      if (perms.protectedFields[userId]) {\n        protectedKeysSets.push(perms.protectedFields[userId]);\n      }\n    }\n\n    // preserve fields to be removed before sending response to client\n    if (serverOnlyKeys.length > 0) {\n      perms.protectedFields.temporaryKeys = serverOnlyKeys;\n    }\n\n    let protectedKeys = protectedKeysSets.reduce((acc, next) => {\n      if (next) {\n        acc.push(...next);\n      }\n      return acc;\n    }, []);\n\n    // intersect all sets of protectedFields\n    protectedKeysSets.forEach(fields => {\n      if (fields) {\n        protectedKeys = protectedKeys.filter(v => fields.includes(v));\n      }\n    });\n\n    return protectedKeys;\n  }\n\n  createTransactionalSession() {\n    return this.adapter.createTransactionalSession().then(transactionalSession => {\n      this._transactionalSession = transactionalSession;\n    });\n  }\n\n  commitTransactionalSession() {\n    if (!this._transactionalSession) {\n      throw new Error('There is no transactional session to commit');\n    }\n    return this.adapter.commitTransactionalSession(this._transactionalSession).then(() => {\n      this._transactionalSession = null;\n    });\n  }\n\n  abortTransactionalSession() {\n    if (!this._transactionalSession) {\n      throw new Error('There is no transactional session to abort');\n    }\n    return this.adapter.abortTransactionalSession(this._transactionalSession).then(() => {\n      this._transactionalSession = null;\n    });\n  }\n\n  // TODO: create indexes on first creation of a _User object. Otherwise it's impossible to\n  // have a Parse app without it having a _User collection.\n  performInitialization() {\n    const requiredUserFields = {\n      fields: {\n        ...SchemaController.defaultColumns._Default,\n        ...SchemaController.defaultColumns._User,\n      },\n    };\n    const requiredRoleFields = {\n      fields: {\n        ...SchemaController.defaultColumns._Default,\n        ...SchemaController.defaultColumns._Role,\n      },\n    };\n    const requiredIdempotencyFields = {\n      fields: {\n        ...SchemaController.defaultColumns._Default,\n        ...SchemaController.defaultColumns._Idempotency,\n      },\n    };\n\n    const userClassPromise = this.loadSchema().then(schema => schema.enforceClassExists('_User'));\n    const roleClassPromise = this.loadSchema().then(schema => schema.enforceClassExists('_Role'));\n    const idempotencyClassPromise =\n      this.adapter instanceof MongoStorageAdapter\n        ? this.loadSchema().then(schema => schema.enforceClassExists('_Idempotency'))\n        : Promise.resolve();\n\n    const usernameUniqueness = userClassPromise\n      .then(() => this.adapter.ensureUniqueness('_User', requiredUserFields, ['username']))\n      .catch(error => {\n        logger.warn('Unable to ensure uniqueness for usernames: ', error);\n        throw error;\n      });\n\n    const usernameCaseInsensitiveIndex = userClassPromise\n      .then(() =>\n        this.adapter.ensureIndex(\n          '_User',\n          requiredUserFields,\n          ['username'],\n          'case_insensitive_username',\n          true\n        )\n      )\n      .catch(error => {\n        logger.warn('Unable to create case insensitive username index: ', error);\n        throw error;\n      });\n\n    const emailUniqueness = userClassPromise\n      .then(() => this.adapter.ensureUniqueness('_User', requiredUserFields, ['email']))\n      .catch(error => {\n        logger.warn('Unable to ensure uniqueness for user email addresses: ', error);\n        throw error;\n      });\n\n    const emailCaseInsensitiveIndex = userClassPromise\n      .then(() =>\n        this.adapter.ensureIndex(\n          '_User',\n          requiredUserFields,\n          ['email'],\n          'case_insensitive_email',\n          true\n        )\n      )\n      .catch(error => {\n        logger.warn('Unable to create case insensitive email index: ', error);\n        throw error;\n      });\n\n    const roleUniqueness = roleClassPromise\n      .then(() => this.adapter.ensureUniqueness('_Role', requiredRoleFields, ['name']))\n      .catch(error => {\n        logger.warn('Unable to ensure uniqueness for role name: ', error);\n        throw error;\n      });\n\n    const idempotencyRequestIdIndex =\n      this.adapter instanceof MongoStorageAdapter\n        ? idempotencyClassPromise\n          .then(() =>\n            this.adapter.ensureUniqueness('_Idempotency', requiredIdempotencyFields, ['reqId'])\n          )\n          .catch(error => {\n            logger.warn('Unable to ensure uniqueness for idempotency request ID: ', error);\n            throw error;\n          })\n        : Promise.resolve();\n\n    const idempotencyExpireIndex =\n      this.adapter instanceof MongoStorageAdapter\n        ? idempotencyClassPromise\n          .then(() =>\n            this.adapter.ensureIndex(\n              '_Idempotency',\n              requiredIdempotencyFields,\n              ['expire'],\n              'ttl',\n              false,\n              { ttl: 0 }\n            )\n          )\n          .catch(error => {\n            logger.warn('Unable to create TTL index for idempotency expire date: ', error);\n            throw error;\n          })\n        : Promise.resolve();\n\n    const indexPromise = this.adapter.updateSchemaWithIndexes();\n\n    // Create tables for volatile classes\n    const adapterInit = this.adapter.performInitialization({\n      VolatileClassesSchemas: SchemaController.VolatileClassesSchemas,\n    });\n    return Promise.all([\n      usernameUniqueness,\n      usernameCaseInsensitiveIndex,\n      emailUniqueness,\n      emailCaseInsensitiveIndex,\n      roleUniqueness,\n      idempotencyRequestIdIndex,\n      idempotencyExpireIndex,\n      adapterInit,\n      indexPromise,\n    ]);\n  }\n\n  _expandResultOnKeyPath(object: any, key: string, value: any): any {\n    if (key.indexOf('.') < 0) {\n      object[key] = value[key];\n      return object;\n    }\n    const path = key.split('.');\n    const firstKey = path[0];\n    const nextPath = path.slice(1).join('.');\n\n    // Scan request data for denied keywords\n    if (this.options && this.options.requestKeywordDenylist) {\n      // Scan request data for denied keywords\n      for (const keyword of this.options.requestKeywordDenylist) {\n        const match = Utils.objectContainsKeyValue({ firstKey: undefined }, keyword.key, undefined);\n        if (match) {\n          throw new Parse.Error(\n            Parse.Error.INVALID_KEY_NAME,\n            `Prohibited keyword in request data: ${JSON.stringify(keyword)}.`\n          );\n        }\n      }\n    }\n\n    object[firstKey] = this._expandResultOnKeyPath(\n      object[firstKey] || {},\n      nextPath,\n      value[firstKey]\n    );\n    delete object[key];\n    return object;\n  }\n\n  _sanitizeDatabaseResult(originalObject: any, result: any): Promise<any> {\n    const response = {};\n    if (!result) {\n      return Promise.resolve(response);\n    }\n    Object.keys(originalObject).forEach(key => {\n      const keyUpdate = originalObject[key];\n      // determine if that was an op\n      if (\n        keyUpdate &&\n        typeof keyUpdate === 'object' &&\n        keyUpdate.__op &&\n        ['Add', 'AddUnique', 'Remove', 'Increment'].indexOf(keyUpdate.__op) > -1\n      ) {\n        // only valid ops that produce an actionable result\n        // the op may have happened on a keypath\n        this._expandResultOnKeyPath(response, key, result);\n      }\n    });\n    return Promise.resolve(response);\n  }\n\n  static _validateQuery: any => void;\n  static filterSensitiveData: (boolean, any[], any, any, any, string, any[], any) => void;\n}\n\nmodule.exports = DatabaseController;\n// Expose validateQuery for tests\nmodule.exports._validateQuery = validateQuery;\nmodule.exports.filterSensitiveData = filterSensitiveData;\n", "// An object that encapsulates everything we need to run a 'find'\n// operation, encoded in the REST API format.\n\nvar SchemaController = require('./Controllers/SchemaController');\nvar Parse = require('parse/node').Parse;\nconst triggers = require('./triggers');\nconst { continueWhile } = require('parse/lib/node/promiseUtils');\nconst AlwaysSelectedKeys = ['objectId', 'createdAt', 'updatedAt', 'ACL'];\n// restOptions can include:\n//   skip\n//   limit\n//   order\n//   count\n//   include\n//   keys\n//   excludeKeys\n//   redirectClassNameForKey\n//   readPreference\n//   includeReadPreference\n//   subqueryReadPreference\nfunction RestQuery(\n  config,\n  auth,\n  className,\n  restWhere = {},\n  restOptions = {},\n  clientSDK,\n  runAfterFind = true\n) {\n  this.config = config;\n  this.auth = auth;\n  this.className = className;\n  this.restWhere = restWhere;\n  this.restOptions = restOptions;\n  this.clientSDK = clientSDK;\n  this.runAfterFind = runAfterFind;\n  this.response = null;\n  this.findOptions = {};\n\n  if (!this.auth.isMaster) {\n    if (this.className == '_Session') {\n      if (!this.auth.user) {\n        throw new Parse.Error(Parse.Error.INVALID_SESSION_TOKEN, 'Invalid session token');\n      }\n      this.restWhere = {\n        $and: [\n          this.restWhere,\n          {\n            user: {\n              __type: 'Pointer',\n              className: '_User',\n              objectId: this.auth.user.id,\n            },\n          },\n        ],\n      };\n    }\n  }\n\n  this.doCount = false;\n  this.includeAll = false;\n\n  // The format for this.include is not the same as the format for the\n  // include option - it's the paths we should include, in order,\n  // stored as arrays, taking into account that we need to include foo\n  // before including foo.bar. Also it should dedupe.\n  // For example, passing an arg of include=foo.bar,foo.baz could lead to\n  // this.include = [['foo'], ['foo', 'baz'], ['foo', 'bar']]\n  this.include = [];\n\n  // If we have keys, we probably want to force some includes (n-1 level)\n  // See issue: https://github.com/parse-community/parse-server/issues/3185\n  if (Object.prototype.hasOwnProperty.call(restOptions, 'keys')) {\n    const keysForInclude = restOptions.keys\n      .split(',')\n      .filter(key => {\n        // At least 2 components\n        return key.split('.').length > 1;\n      })\n      .map(key => {\n        // Slice the last component (a.b.c -> a.b)\n        // Otherwise we'll include one level too much.\n        return key.slice(0, key.lastIndexOf('.'));\n      })\n      .join(',');\n\n    // Concat the possibly present include string with the one from the keys\n    // Dedup / sorting is handle in 'include' case.\n    if (keysForInclude.length > 0) {\n      if (!restOptions.include || restOptions.include.length == 0) {\n        restOptions.include = keysForInclude;\n      } else {\n        restOptions.include += ',' + keysForInclude;\n      }\n    }\n  }\n\n  for (var option in restOptions) {\n    switch (option) {\n      case 'keys': {\n        const keys = restOptions.keys.split(',').concat(AlwaysSelectedKeys);\n        this.keys = Array.from(new Set(keys));\n        break;\n      }\n      case 'excludeKeys': {\n        const exclude = restOptions.excludeKeys\n          .split(',')\n          .filter(k => AlwaysSelectedKeys.indexOf(k) < 0);\n        this.excludeKeys = Array.from(new Set(exclude));\n        break;\n      }\n      case 'count':\n        this.doCount = true;\n        break;\n      case 'includeAll':\n        this.includeAll = true;\n        break;\n      case 'explain':\n      case 'hint':\n      case 'distinct':\n      case 'pipeline':\n      case 'skip':\n      case 'limit':\n      case 'readPreference':\n        this.findOptions[option] = restOptions[option];\n        break;\n      case 'order':\n        var fields = restOptions.order.split(',');\n        this.findOptions.sort = fields.reduce((sortMap, field) => {\n          field = field.trim();\n          if (field === '$score') {\n            sortMap.score = { $meta: 'textScore' };\n          } else if (field[0] == '-') {\n            sortMap[field.slice(1)] = -1;\n          } else {\n            sortMap[field] = 1;\n          }\n          return sortMap;\n        }, {});\n        break;\n      case 'include': {\n        const paths = restOptions.include.split(',');\n        if (paths.includes('*')) {\n          this.includeAll = true;\n          break;\n        }\n        // Load the existing includes (from keys)\n        const pathSet = paths.reduce((memo, path) => {\n          // Split each paths on . (a.b.c -> [a,b,c])\n          // reduce to create all paths\n          // ([a,b,c] -> {a: true, 'a.b': true, 'a.b.c': true})\n          return path.split('.').reduce((memo, path, index, parts) => {\n            memo[parts.slice(0, index + 1).join('.')] = true;\n            return memo;\n          }, memo);\n        }, {});\n\n        this.include = Object.keys(pathSet)\n          .map(s => {\n            return s.split('.');\n          })\n          .sort((a, b) => {\n            return a.length - b.length; // Sort by number of components\n          });\n        break;\n      }\n      case 'redirectClassNameForKey':\n        this.redirectKey = restOptions.redirectClassNameForKey;\n        this.redirectClassName = null;\n        break;\n      case 'includeReadPreference':\n      case 'subqueryReadPreference':\n        break;\n      default:\n        throw new Parse.Error(Parse.Error.INVALID_JSON, 'bad option: ' + option);\n    }\n  }\n}\n\n// A convenient method to perform all the steps of processing a query\n// in order.\n// Returns a promise for the response - an object with optional keys\n// 'results' and 'count'.\n// TODO: consolidate the replaceX functions\nRestQuery.prototype.execute = function (executeOptions) {\n  return Promise.resolve()\n    .then(() => {\n      return this.buildRestWhere();\n    })\n    .then(() => {\n      return this.handleIncludeAll();\n    })\n    .then(() => {\n      return this.handleExcludeKeys();\n    })\n    .then(() => {\n      return this.runFind(executeOptions);\n    })\n    .then(() => {\n      return this.runCount();\n    })\n    .then(() => {\n      return this.handleInclude();\n    })\n    .then(() => {\n      return this.runAfterFindTrigger();\n    })\n    .then(() => {\n      return this.response;\n    });\n};\n\nRestQuery.prototype.each = function (callback) {\n  const { config, auth, className, restWhere, restOptions, clientSDK } = this;\n  // if the limit is set, use it\n  restOptions.limit = restOptions.limit || 100;\n  restOptions.order = 'objectId';\n  let finished = false;\n\n  return continueWhile(\n    () => {\n      return !finished;\n    },\n    async () => {\n      const query = new RestQuery(config, auth, className, restWhere, restOptions, clientSDK);\n      const { results } = await query.execute();\n      results.forEach(callback);\n      finished = results.length < restOptions.limit;\n      if (!finished) {\n        restWhere.objectId = Object.assign({}, restWhere.objectId, {\n          $gt: results[results.length - 1].objectId,\n        });\n      }\n    }\n  );\n};\n\nRestQuery.prototype.buildRestWhere = function () {\n  return Promise.resolve()\n    .then(() => {\n      return this.getUserAndRoleACL();\n    })\n    .then(() => {\n      return this.redirectClassNameForKey();\n    })\n    .then(() => {\n      return this.validateClientClassCreation();\n    })\n    .then(() => {\n      return this.replaceSelect();\n    })\n    .then(() => {\n      return this.replaceDontSelect();\n    })\n    .then(() => {\n      return this.replaceInQuery();\n    })\n    .then(() => {\n      return this.replaceNotInQuery();\n    })\n    .then(() => {\n      return this.replaceEquality();\n    });\n};\n\n// Uses the Auth object to get the list of roles, adds the user id\nRestQuery.prototype.getUserAndRoleACL = function () {\n  if (this.auth.isMaster) {\n    return Promise.resolve();\n  }\n\n  this.findOptions.acl = ['*'];\n\n  if (this.auth.user) {\n    return this.auth.getUserRoles().then(roles => {\n      this.findOptions.acl = this.findOptions.acl.concat(roles, [this.auth.user.id]);\n      return;\n    });\n  } else {\n    return Promise.resolve();\n  }\n};\n\n// Changes the className if redirectClassNameForKey is set.\n// Returns a promise.\nRestQuery.prototype.redirectClassNameForKey = function () {\n  if (!this.redirectKey) {\n    return Promise.resolve();\n  }\n\n  // We need to change the class name based on the schema\n  return this.config.database\n    .redirectClassNameForKey(this.className, this.redirectKey)\n    .then(newClassName => {\n      this.className = newClassName;\n      this.redirectClassName = newClassName;\n    });\n};\n\n// Validates this operation against the allowClientClassCreation config.\nRestQuery.prototype.validateClientClassCreation = function () {\n  if (\n    this.config.allowClientClassCreation === false &&\n    !this.auth.isMaster &&\n    SchemaController.systemClasses.indexOf(this.className) === -1\n  ) {\n    return this.config.database\n      .loadSchema()\n      .then(schemaController => schemaController.hasClass(this.className))\n      .then(hasClass => {\n        if (hasClass !== true) {\n          throw new Parse.Error(\n            Parse.Error.OPERATION_FORBIDDEN,\n            'This user is not allowed to access ' + 'non-existent class: ' + this.className\n          );\n        }\n      });\n  } else {\n    return Promise.resolve();\n  }\n};\n\nfunction transformInQuery(inQueryObject, className, results) {\n  var values = [];\n  for (var result of results) {\n    values.push({\n      __type: 'Pointer',\n      className: className,\n      objectId: result.objectId,\n    });\n  }\n  delete inQueryObject['$inQuery'];\n  if (Array.isArray(inQueryObject['$in'])) {\n    inQueryObject['$in'] = inQueryObject['$in'].concat(values);\n  } else {\n    inQueryObject['$in'] = values;\n  }\n}\n\n// Replaces a $inQuery clause by running the subquery, if there is an\n// $inQuery clause.\n// The $inQuery clause turns into an $in with values that are just\n// pointers to the objects returned in the subquery.\nRestQuery.prototype.replaceInQuery = function () {\n  var inQueryObject = findObjectWithKey(this.restWhere, '$inQuery');\n  if (!inQueryObject) {\n    return;\n  }\n\n  // The inQuery value must have precisely two keys - where and className\n  var inQueryValue = inQueryObject['$inQuery'];\n  if (!inQueryValue.where || !inQueryValue.className) {\n    throw new Parse.Error(Parse.Error.INVALID_QUERY, 'improper usage of $inQuery');\n  }\n\n  const additionalOptions = {\n    redirectClassNameForKey: inQueryValue.redirectClassNameForKey,\n  };\n\n  if (this.restOptions.subqueryReadPreference) {\n    additionalOptions.readPreference = this.restOptions.subqueryReadPreference;\n    additionalOptions.subqueryReadPreference = this.restOptions.subqueryReadPreference;\n  } else if (this.restOptions.readPreference) {\n    additionalOptions.readPreference = this.restOptions.readPreference;\n  }\n\n  var subquery = new RestQuery(\n    this.config,\n    this.auth,\n    inQueryValue.className,\n    inQueryValue.where,\n    additionalOptions\n  );\n  return subquery.execute().then(response => {\n    transformInQuery(inQueryObject, subquery.className, response.results);\n    // Recurse to repeat\n    return this.replaceInQuery();\n  });\n};\n\nfunction transformNotInQuery(notInQueryObject, className, results) {\n  var values = [];\n  for (var result of results) {\n    values.push({\n      __type: 'Pointer',\n      className: className,\n      objectId: result.objectId,\n    });\n  }\n  delete notInQueryObject['$notInQuery'];\n  if (Array.isArray(notInQueryObject['$nin'])) {\n    notInQueryObject['$nin'] = notInQueryObject['$nin'].concat(values);\n  } else {\n    notInQueryObject['$nin'] = values;\n  }\n}\n\n// Replaces a $notInQuery clause by running the subquery, if there is an\n// $notInQuery clause.\n// The $notInQuery clause turns into a $nin with values that are just\n// pointers to the objects returned in the subquery.\nRestQuery.prototype.replaceNotInQuery = function () {\n  var notInQueryObject = findObjectWithKey(this.restWhere, '$notInQuery');\n  if (!notInQueryObject) {\n    return;\n  }\n\n  // The notInQuery value must have precisely two keys - where and className\n  var notInQueryValue = notInQueryObject['$notInQuery'];\n  if (!notInQueryValue.where || !notInQueryValue.className) {\n    throw new Parse.Error(Parse.Error.INVALID_QUERY, 'improper usage of $notInQuery');\n  }\n\n  const additionalOptions = {\n    redirectClassNameForKey: notInQueryValue.redirectClassNameForKey,\n  };\n\n  if (this.restOptions.subqueryReadPreference) {\n    additionalOptions.readPreference = this.restOptions.subqueryReadPreference;\n    additionalOptions.subqueryReadPreference = this.restOptions.subqueryReadPreference;\n  } else if (this.restOptions.readPreference) {\n    additionalOptions.readPreference = this.restOptions.readPreference;\n  }\n\n  var subquery = new RestQuery(\n    this.config,\n    this.auth,\n    notInQueryValue.className,\n    notInQueryValue.where,\n    additionalOptions\n  );\n  return subquery.execute().then(response => {\n    transformNotInQuery(notInQueryObject, subquery.className, response.results);\n    // Recurse to repeat\n    return this.replaceNotInQuery();\n  });\n};\n\n// Used to get the deepest object from json using dot notation.\nconst getDeepestObjectFromKey = (json, key, idx, src) => {\n  if (key in json) {\n    return json[key];\n  }\n  src.splice(1); // Exit Early\n};\n\nconst transformSelect = (selectObject, key, objects) => {\n  var values = [];\n  for (var result of objects) {\n    values.push(key.split('.').reduce(getDeepestObjectFromKey, result));\n  }\n  delete selectObject['$select'];\n  if (Array.isArray(selectObject['$in'])) {\n    selectObject['$in'] = selectObject['$in'].concat(values);\n  } else {\n    selectObject['$in'] = values;\n  }\n};\n\n// Replaces a $select clause by running the subquery, if there is a\n// $select clause.\n// The $select clause turns into an $in with values selected out of\n// the subquery.\n// Returns a possible-promise.\nRestQuery.prototype.replaceSelect = function () {\n  var selectObject = findObjectWithKey(this.restWhere, '$select');\n  if (!selectObject) {\n    return;\n  }\n\n  // The select value must have precisely two keys - query and key\n  var selectValue = selectObject['$select'];\n  // iOS SDK don't send where if not set, let it pass\n  if (\n    !selectValue.query ||\n    !selectValue.key ||\n    typeof selectValue.query !== 'object' ||\n    !selectValue.query.className ||\n    Object.keys(selectValue).length !== 2\n  ) {\n    throw new Parse.Error(Parse.Error.INVALID_QUERY, 'improper usage of $select');\n  }\n\n  const additionalOptions = {\n    redirectClassNameForKey: selectValue.query.redirectClassNameForKey,\n  };\n\n  if (this.restOptions.subqueryReadPreference) {\n    additionalOptions.readPreference = this.restOptions.subqueryReadPreference;\n    additionalOptions.subqueryReadPreference = this.restOptions.subqueryReadPreference;\n  } else if (this.restOptions.readPreference) {\n    additionalOptions.readPreference = this.restOptions.readPreference;\n  }\n\n  var subquery = new RestQuery(\n    this.config,\n    this.auth,\n    selectValue.query.className,\n    selectValue.query.where,\n    additionalOptions\n  );\n  return subquery.execute().then(response => {\n    transformSelect(selectObject, selectValue.key, response.results);\n    // Keep replacing $select clauses\n    return this.replaceSelect();\n  });\n};\n\nconst transformDontSelect = (dontSelectObject, key, objects) => {\n  var values = [];\n  for (var result of objects) {\n    values.push(key.split('.').reduce(getDeepestObjectFromKey, result));\n  }\n  delete dontSelectObject['$dontSelect'];\n  if (Array.isArray(dontSelectObject['$nin'])) {\n    dontSelectObject['$nin'] = dontSelectObject['$nin'].concat(values);\n  } else {\n    dontSelectObject['$nin'] = values;\n  }\n};\n\n// Replaces a $dontSelect clause by running the subquery, if there is a\n// $dontSelect clause.\n// The $dontSelect clause turns into an $nin with values selected out of\n// the subquery.\n// Returns a possible-promise.\nRestQuery.prototype.replaceDontSelect = function () {\n  var dontSelectObject = findObjectWithKey(this.restWhere, '$dontSelect');\n  if (!dontSelectObject) {\n    return;\n  }\n\n  // The dontSelect value must have precisely two keys - query and key\n  var dontSelectValue = dontSelectObject['$dontSelect'];\n  if (\n    !dontSelectValue.query ||\n    !dontSelectValue.key ||\n    typeof dontSelectValue.query !== 'object' ||\n    !dontSelectValue.query.className ||\n    Object.keys(dontSelectValue).length !== 2\n  ) {\n    throw new Parse.Error(Parse.Error.INVALID_QUERY, 'improper usage of $dontSelect');\n  }\n  const additionalOptions = {\n    redirectClassNameForKey: dontSelectValue.query.redirectClassNameForKey,\n  };\n\n  if (this.restOptions.subqueryReadPreference) {\n    additionalOptions.readPreference = this.restOptions.subqueryReadPreference;\n    additionalOptions.subqueryReadPreference = this.restOptions.subqueryReadPreference;\n  } else if (this.restOptions.readPreference) {\n    additionalOptions.readPreference = this.restOptions.readPreference;\n  }\n\n  var subquery = new RestQuery(\n    this.config,\n    this.auth,\n    dontSelectValue.query.className,\n    dontSelectValue.query.where,\n    additionalOptions\n  );\n  return subquery.execute().then(response => {\n    transformDontSelect(dontSelectObject, dontSelectValue.key, response.results);\n    // Keep replacing $dontSelect clauses\n    return this.replaceDontSelect();\n  });\n};\n\nconst cleanResultAuthData = function (result) {\n  delete result.password;\n  if (result.authData) {\n    Object.keys(result.authData).forEach(provider => {\n      if (result.authData[provider] === null) {\n        delete result.authData[provider];\n      }\n    });\n\n    if (Object.keys(result.authData).length == 0) {\n      delete result.authData;\n    }\n  }\n};\n\nconst replaceEqualityConstraint = constraint => {\n  if (typeof constraint !== 'object') {\n    return constraint;\n  }\n  const equalToObject = {};\n  let hasDirectConstraint = false;\n  let hasOperatorConstraint = false;\n  for (const key in constraint) {\n    if (key.indexOf('$') !== 0) {\n      hasDirectConstraint = true;\n      equalToObject[key] = constraint[key];\n    } else {\n      hasOperatorConstraint = true;\n    }\n  }\n  if (hasDirectConstraint && hasOperatorConstraint) {\n    constraint['$eq'] = equalToObject;\n    Object.keys(equalToObject).forEach(key => {\n      delete constraint[key];\n    });\n  }\n  return constraint;\n};\n\nRestQuery.prototype.replaceEquality = function () {\n  if (typeof this.restWhere !== 'object') {\n    return;\n  }\n  for (const key in this.restWhere) {\n    this.restWhere[key] = replaceEqualityConstraint(this.restWhere[key]);\n  }\n};\n\n// Returns a promise for whether it was successful.\n// Populates this.response with an object that only has 'results'.\nRestQuery.prototype.runFind = function (options = {}) {\n  if (this.findOptions.limit === 0) {\n    this.response = { results: [] };\n    return Promise.resolve();\n  }\n  const findOptions = Object.assign({}, this.findOptions);\n  if (this.keys) {\n    findOptions.keys = this.keys.map(key => {\n      return key.split('.')[0];\n    });\n  }\n  if (options.op) {\n    findOptions.op = options.op;\n  }\n  return this.config.database\n    .find(this.className, this.restWhere, findOptions, this.auth)\n    .then(results => {\n      if (this.className === '_User' && !findOptions.explain) {\n        for (var result of results) {\n          cleanResultAuthData(result);\n        }\n      }\n\n      this.config.filesController.expandFilesInObject(this.config, results);\n\n      if (this.redirectClassName) {\n        for (var r of results) {\n          r.className = this.redirectClassName;\n        }\n      }\n      this.response = { results: results };\n    });\n};\n\n// Returns a promise for whether it was successful.\n// Populates this.response.count with the count\nRestQuery.prototype.runCount = function () {\n  if (!this.doCount) {\n    return;\n  }\n  this.findOptions.count = true;\n  delete this.findOptions.skip;\n  delete this.findOptions.limit;\n  return this.config.database.find(this.className, this.restWhere, this.findOptions).then(c => {\n    this.response.count = c;\n  });\n};\n\n// Augments this.response with all pointers on an object\nRestQuery.prototype.handleIncludeAll = function () {\n  if (!this.includeAll) {\n    return;\n  }\n  return this.config.database\n    .loadSchema()\n    .then(schemaController => schemaController.getOneSchema(this.className))\n    .then(schema => {\n      const includeFields = [];\n      const keyFields = [];\n      for (const field in schema.fields) {\n        if (\n          (schema.fields[field].type && schema.fields[field].type === 'Pointer') ||\n          (schema.fields[field].type && schema.fields[field].type === 'Array')\n        ) {\n          includeFields.push([field]);\n          keyFields.push(field);\n        }\n      }\n      // Add fields to include, keys, remove dups\n      this.include = [...new Set([...this.include, ...includeFields])];\n      // if this.keys not set, then all keys are already included\n      if (this.keys) {\n        this.keys = [...new Set([...this.keys, ...keyFields])];\n      }\n    });\n};\n\n// Updates property `this.keys` to contain all keys but the ones unselected.\nRestQuery.prototype.handleExcludeKeys = function () {\n  if (!this.excludeKeys) {\n    return;\n  }\n  if (this.keys) {\n    this.keys = this.keys.filter(k => !this.excludeKeys.includes(k));\n    return;\n  }\n  return this.config.database\n    .loadSchema()\n    .then(schemaController => schemaController.getOneSchema(this.className))\n    .then(schema => {\n      const fields = Object.keys(schema.fields);\n      this.keys = fields.filter(k => !this.excludeKeys.includes(k));\n    });\n};\n\n// Augments this.response with data at the paths provided in this.include.\nRestQuery.prototype.handleInclude = function () {\n  if (this.include.length == 0) {\n    return;\n  }\n\n  var pathResponse = includePath(\n    this.config,\n    this.auth,\n    this.response,\n    this.include[0],\n    this.restOptions\n  );\n  if (pathResponse.then) {\n    return pathResponse.then(newResponse => {\n      this.response = newResponse;\n      this.include = this.include.slice(1);\n      return this.handleInclude();\n    });\n  } else if (this.include.length > 0) {\n    this.include = this.include.slice(1);\n    return this.handleInclude();\n  }\n\n  return pathResponse;\n};\n\n//Returns a promise of a processed set of results\nRestQuery.prototype.runAfterFindTrigger = function () {\n  if (!this.response) {\n    return;\n  }\n  if (!this.runAfterFind) {\n    return;\n  }\n  // Avoid doing any setup for triggers if there is no 'afterFind' trigger for this class.\n  const hasAfterFindHook = triggers.triggerExists(\n    this.className,\n    triggers.Types.afterFind,\n    this.config.applicationId\n  );\n  if (!hasAfterFindHook) {\n    return Promise.resolve();\n  }\n  // Skip Aggregate and Distinct Queries\n  if (this.findOptions.pipeline || this.findOptions.distinct) {\n    return Promise.resolve();\n  }\n\n  const json = Object.assign({}, this.restOptions);\n  json.where = this.restWhere;\n  const parseQuery = new Parse.Query(this.className);\n  parseQuery.withJSON(json);\n  // Run afterFind trigger and set the new results\n  return triggers\n    .maybeRunAfterFindTrigger(\n      triggers.Types.afterFind,\n      this.auth,\n      this.className,\n      this.response.results,\n      this.config,\n      parseQuery\n    )\n    .then(results => {\n      // Ensure we properly set the className back\n      if (this.redirectClassName) {\n        this.response.results = results.map(object => {\n          if (object instanceof Parse.Object) {\n            object = object.toJSON();\n          }\n          object.className = this.redirectClassName;\n          return object;\n        });\n      } else {\n        this.response.results = results;\n      }\n    });\n};\n\n// Adds included values to the response.\n// Path is a list of field names.\n// Returns a promise for an augmented response.\nfunction includePath(config, auth, response, path, restOptions = {}) {\n  var pointers = findPointers(response.results, path);\n  if (pointers.length == 0) {\n    return response;\n  }\n  const pointersHash = {};\n  for (var pointer of pointers) {\n    if (!pointer) {\n      continue;\n    }\n    const className = pointer.className;\n    // only include the good pointers\n    if (className) {\n      pointersHash[className] = pointersHash[className] || new Set();\n      pointersHash[className].add(pointer.objectId);\n    }\n  }\n  const includeRestOptions = {};\n  if (restOptions.keys) {\n    const keys = new Set(restOptions.keys.split(','));\n    const keySet = Array.from(keys).reduce((set, key) => {\n      const keyPath = key.split('.');\n      let i = 0;\n      for (i; i < path.length; i++) {\n        if (path[i] != keyPath[i]) {\n          return set;\n        }\n      }\n      if (i < keyPath.length) {\n        set.add(keyPath[i]);\n      }\n      return set;\n    }, new Set());\n    if (keySet.size > 0) {\n      includeRestOptions.keys = Array.from(keySet).join(',');\n    }\n  }\n\n  if (restOptions.includeReadPreference) {\n    includeRestOptions.readPreference = restOptions.includeReadPreference;\n    includeRestOptions.includeReadPreference = restOptions.includeReadPreference;\n  } else if (restOptions.readPreference) {\n    includeRestOptions.readPreference = restOptions.readPreference;\n  }\n\n  const queryPromises = Object.keys(pointersHash).map(className => {\n    const objectIds = Array.from(pointersHash[className]);\n    let where;\n    if (objectIds.length === 1) {\n      where = { objectId: objectIds[0] };\n    } else {\n      where = { objectId: { $in: objectIds } };\n    }\n    var query = new RestQuery(config, auth, className, where, includeRestOptions);\n    return query.execute({ op: 'get' }).then(results => {\n      results.className = className;\n      return Promise.resolve(results);\n    });\n  });\n\n  // Get the objects for all these object ids\n  return Promise.all(queryPromises).then(responses => {\n    var replace = responses.reduce((replace, includeResponse) => {\n      for (var obj of includeResponse.results) {\n        obj.__type = 'Object';\n        obj.className = includeResponse.className;\n\n        if (obj.className == '_User' && !auth.isMaster) {\n          delete obj.sessionToken;\n          delete obj.authData;\n        }\n        replace[obj.objectId] = obj;\n      }\n      return replace;\n    }, {});\n\n    var resp = {\n      results: replacePointers(response.results, path, replace),\n    };\n    if (response.count) {\n      resp.count = response.count;\n    }\n    return resp;\n  });\n}\n\n// Object may be a list of REST-format object to find pointers in, or\n// it may be a single object.\n// If the path yields things that aren't pointers, this throws an error.\n// Path is a list of fields to search into.\n// Returns a list of pointers in REST format.\nfunction findPointers(object, path) {\n  if (object instanceof Array) {\n    var answer = [];\n    for (var x of object) {\n      answer = answer.concat(findPointers(x, path));\n    }\n    return answer;\n  }\n\n  if (typeof object !== 'object' || !object) {\n    return [];\n  }\n\n  if (path.length == 0) {\n    if (object === null || object.__type == 'Pointer') {\n      return [object];\n    }\n    return [];\n  }\n\n  var subobject = object[path[0]];\n  if (!subobject) {\n    return [];\n  }\n  return findPointers(subobject, path.slice(1));\n}\n\n// Object may be a list of REST-format objects to replace pointers\n// in, or it may be a single object.\n// Path is a list of fields to search into.\n// replace is a map from object id -> object.\n// Returns something analogous to object, but with the appropriate\n// pointers inflated.\nfunction replacePointers(object, path, replace) {\n  if (object instanceof Array) {\n    return object\n      .map(obj => replacePointers(obj, path, replace))\n      .filter(obj => typeof obj !== 'undefined');\n  }\n\n  if (typeof object !== 'object' || !object) {\n    return object;\n  }\n\n  if (path.length === 0) {\n    if (object && object.__type === 'Pointer') {\n      return replace[object.objectId];\n    }\n    return object;\n  }\n\n  var subobject = object[path[0]];\n  if (!subobject) {\n    return object;\n  }\n  var newsub = replacePointers(subobject, path.slice(1), replace);\n  var answer = {};\n  for (var key in object) {\n    if (key == path[0]) {\n      answer[key] = newsub;\n    } else {\n      answer[key] = object[key];\n    }\n  }\n  return answer;\n}\n\n// Finds a subobject that has the given key, if there is one.\n// Returns undefined otherwise.\nfunction findObjectWithKey(root, key) {\n  if (typeof root !== 'object') {\n    return;\n  }\n  if (root instanceof Array) {\n    for (var item of root) {\n      const answer = findObjectWithKey(item, key);\n      if (answer) {\n        return answer;\n      }\n    }\n  }\n  if (root && root[key]) {\n    return root;\n  }\n  for (var subkey in root) {\n    const answer = findObjectWithKey(root[subkey], key);\n    if (answer) {\n      return answer;\n    }\n  }\n}\n\nmodule.exports = RestQuery;\n"], "fixing_code": ["name: ci\non:\n  push:\n    branches:\n      - master\n  pull_request:\n    branches:\n      - '**'\nenv:\n  COVERAGE_OPTION: ./node_modules/.bin/nyc\n  NODE_VERSION: 10\n  PARSE_SERVER_TEST_TIMEOUT: 20000\njobs:\n  check-mongo:\n    strategy:\n      fail-fast: false\n      matrix:\n        include:\n          - name: Mongo 4.0.4, ReplicaSet, WiredTiger\n            MONGODB_VERSION: 4.0.4\n            MONGODB_TOPOLOGY: replicaset\n            MONGODB_STORAGE_ENGINE: wiredTiger\n            NODE_VERSION: 10\n          - name: Mongo 3.6.21\n            MONGODB_VERSION: 3.6.21\n            NODE_VERSION: 10\n          - name: Redis Cache\n            PARSE_SERVER_TEST_CACHE: redis\n            NODE_VERSION: 10\n          - name: Node 12.12.0\n            NODE_VERSION: 12.12.0\n    name: ${{ matrix.name }}\n    timeout-minutes: 30\n    runs-on: ubuntu-18.04\n    services:\n      redis:\n        image: redis\n        ports:\n            - 6379:6379\n    env:      \n      MONGODB_VERSION: ${{ matrix.MONGODB_VERSION }}\n      MONGODB_TOPOLOGY: ${{ matrix.MONGODB_TOPOLOGY }}\n      MONGODB_STORAGE_ENGINE: ${{ matrix.MONGODB_STORAGE_ENGINE }}\n      PARSE_SERVER_TEST_CACHE: ${{ matrix.PARSE_SERVER_TEST_CACHE }}\n      NODE_VERSION: ${{ matrix.NODE_VERSION }}\n    steps:\n      - name: Fix usage of insecure GitHub protocol\n        run: sudo git config --system url.\"https://github\".insteadOf \"git://github\"\n      - uses: actions/checkout@v2\n      - name: Use Node.js ${{ matrix.NODE_VERSION }}\n        uses: actions/setup-node@v1\n        with:\n          node-version: ${{ matrix.NODE_VERSION }}\n      - name: Cache Node.js modules\n        uses: actions/cache@v2\n        with:\n          path: ~/.npm\n          key: ${{ runner.os }}-node-${{ matrix.NODE_VERSION }}-${{ hashFiles('**/package-lock.json') }}\n          restore-keys: |\n            ${{ runner.os }}-node-${{ matrix.NODE_VERSION }}-\n      - name: Install dependencies\n        run: npm ci\n      - if: ${{ matrix.name == 'Mongo 3.6.21' }}\n        run: npm run lint\n      - run: npm run pretest\n      - run: npm run coverage\n        env:\n          CI: true\n      - run: bash <(curl -s https://codecov.io/bash)\n  check-postgres:\n    name: Postgresql\n    timeout-minutes: 30\n    runs-on: ubuntu-18.04\n    services:\n      redis:\n        image: redis\n        ports:\n          - 6379:6379\n      postgres:\n        image: postgis/postgis:11-3.0\n        env:\n          POSTGRES_PASSWORD: postgres\n        ports:\n          - 5432:5432\n        options: >-\n          --health-cmd pg_isready\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n    env:\n      PARSE_SERVER_TEST_DB: postgres\n      POSTGRES_MAJOR_VERSION: 11\n      PARSE_SERVER_TEST_DATABASE_URI: postgres://postgres:postgres@localhost:5432/parse_server_postgres_adapter_test_database\n    steps:\n      - name: Fix usage of insecure GitHub protocol\n        run: sudo git config --system url.\"https://github\".insteadOf \"git://github\"\n      - uses: actions/checkout@v2\n      - name: Use Node.js 10\n        uses: actions/setup-node@v1\n        with:\n          node-version: 10\n      - name: Cache Node.js modules\n        uses: actions/cache@v2\n        with:\n          path: ~/.npm\n          key: ${{ runner.os }}-node-${{ matrix.NODE_VERSION }}-${{ hashFiles('**/package-lock.json') }}\n          restore-keys: |\n            ${{ runner.os }}-node-${{ matrix.NODE_VERSION }}-\n      - name: Install dependencies\n        run: npm ci\n      - run: bash scripts/before_script_postgres.sh\n      - run: npm run coverage\n        env:\n          CI: true\n      - run: bash <(curl -s https://codecov.io/bash)", "const RedisCacheAdapter = require('../lib/Adapters/Cache/RedisCacheAdapter').default;\nconst Config = require('../lib/Config');\n\n/*\nTo run this test part of the complete suite\nset PARSE_SERVER_TEST_CACHE='redis'\nand make sure a redis server is available on the default port\n */\ndescribe_only(() => {\n  return process.env.PARSE_SERVER_TEST_CACHE === 'redis';\n})('RedisCacheAdapter', function () {\n  const KEY = 'hello';\n  const VALUE = 'world';\n\n  function wait(sleep) {\n    return new Promise(function (resolve) {\n      setTimeout(resolve, sleep);\n    });\n  }\n\n  it('should get/set/clear', done => {\n    const cache = new RedisCacheAdapter({\n      ttl: NaN,\n    });\n\n    cache\n      .put(KEY, VALUE)\n      .then(() => cache.get(KEY))\n      .then(value => expect(value).toEqual(VALUE))\n      .then(() => cache.clear())\n      .then(() => cache.get(KEY))\n      .then(value => expect(value).toEqual(null))\n      .then(done);\n  });\n\n  it('should expire after ttl', done => {\n    const cache = new RedisCacheAdapter(null, 50);\n\n    cache\n      .put(KEY, VALUE)\n      .then(() => cache.get(KEY))\n      .then(value => expect(value).toEqual(VALUE))\n      .then(wait.bind(null, 52))\n      .then(() => cache.get(KEY))\n      .then(value => expect(value).toEqual(null))\n      .then(done);\n  });\n\n  it('should not store value for ttl=0', done => {\n    const cache = new RedisCacheAdapter(null, 5);\n\n    cache\n      .put(KEY, VALUE, 0)\n      .then(() => cache.get(KEY))\n      .then(value => expect(value).toEqual(null))\n      .then(done);\n  });\n\n  it('should not expire when ttl=Infinity', done => {\n    const cache = new RedisCacheAdapter(null, 1);\n\n    cache\n      .put(KEY, VALUE, Infinity)\n      .then(() => cache.get(KEY))\n      .then(value => expect(value).toEqual(VALUE))\n      .then(wait.bind(null, 5))\n      .then(() => cache.get(KEY))\n      .then(value => expect(value).toEqual(VALUE))\n      .then(done);\n  });\n\n  it('should fallback to default ttl', done => {\n    const cache = new RedisCacheAdapter(null, 1);\n    let promise = Promise.resolve();\n\n    [-100, null, undefined, 'not number', true].forEach(ttl => {\n      promise = promise.then(() =>\n        cache\n          .put(KEY, VALUE, ttl)\n          .then(() => cache.get(KEY))\n          .then(value => expect(value).toEqual(VALUE))\n          .then(wait.bind(null, 5))\n          .then(() => cache.get(KEY))\n          .then(value => expect(value).toEqual(null))\n      );\n    });\n\n    promise.then(done);\n  });\n\n  it('should find un-expired records', done => {\n    const cache = new RedisCacheAdapter(null, 5);\n\n    cache\n      .put(KEY, VALUE)\n      .then(() => cache.get(KEY))\n      .then(value => expect(value).toEqual(VALUE))\n      .then(wait.bind(null, 1))\n      .then(() => cache.get(KEY))\n      .then(value => expect(value).not.toEqual(null))\n      .then(done);\n  });\n\n  it('handleShutdown, close connection', async () => {\n    const cache = new RedisCacheAdapter(null, 5);\n\n    await cache.handleShutdown();\n    setTimeout(() => {\n      expect(cache.client.connected).toBe(false);\n    }, 0);\n  });\n});\n\ndescribe_only(() => {\n  return process.env.PARSE_SERVER_TEST_CACHE === 'redis';\n})('RedisCacheAdapter/KeyPromiseQueue', function () {\n  const KEY1 = 'key1';\n  const KEY2 = 'key2';\n  const VALUE = 'hello';\n\n  // number of chained ops on a single key\n  function getQueueCountForKey(cache, key) {\n    return cache.queue.queue[key][0];\n  }\n\n  // total number of queued keys\n  function getQueueCount(cache) {\n    return Object.keys(cache.queue.queue).length;\n  }\n\n  it('it should clear completed operations from queue', done => {\n    const cache = new RedisCacheAdapter({ ttl: NaN });\n\n    // execute a bunch of operations in sequence\n    let promise = Promise.resolve();\n    for (let index = 1; index < 100; index++) {\n      promise = promise.then(() => {\n        const key = `${index}`;\n        return cache\n          .put(key, VALUE)\n          .then(() => expect(getQueueCount(cache)).toEqual(0))\n          .then(() => cache.get(key))\n          .then(() => expect(getQueueCount(cache)).toEqual(0))\n          .then(() => cache.clear())\n          .then(() => expect(getQueueCount(cache)).toEqual(0));\n      });\n    }\n\n    // at the end the queue should be empty\n    promise.then(() => expect(getQueueCount(cache)).toEqual(0)).then(done);\n  });\n\n  it('it should count per key chained operations correctly', done => {\n    const cache = new RedisCacheAdapter({ ttl: NaN });\n\n    let key1Promise = Promise.resolve();\n    let key2Promise = Promise.resolve();\n    for (let index = 1; index < 100; index++) {\n      key1Promise = cache.put(KEY1, VALUE);\n      key2Promise = cache.put(KEY2, VALUE);\n      // per key chain should be equal to index, which is the\n      // total number of operations on that key\n      expect(getQueueCountForKey(cache, KEY1)).toEqual(index);\n      expect(getQueueCountForKey(cache, KEY2)).toEqual(index);\n      // the total keys counts should be equal to the different keys\n      // we have currently being processed.\n      expect(getQueueCount(cache)).toEqual(2);\n    }\n\n    // at the end the queue should be empty\n    Promise.all([key1Promise, key2Promise])\n      .then(() => expect(getQueueCount(cache)).toEqual(0))\n      .then(done);\n  });\n});\n\ndescribe_only(() => {\n  return process.env.PARSE_SERVER_TEST_CACHE === 'redis';\n})('Redis Performance', function () {\n  let cacheAdapter;\n  let getSpy;\n  let putSpy;\n  let delSpy;\n\n  beforeEach(async () => {\n    cacheAdapter = new RedisCacheAdapter();\n    await reconfigureServer({\n      cacheAdapter,\n    });\n    await cacheAdapter.clear();\n\n    getSpy = spyOn(cacheAdapter, 'get').and.callThrough();\n    putSpy = spyOn(cacheAdapter, 'put').and.callThrough();\n    delSpy = spyOn(cacheAdapter, 'del').and.callThrough();\n  });\n\n  it('test new object', async () => {\n    const object = new TestObject();\n    object.set('foo', 'bar');\n    await object.save();\n    expect(getSpy.calls.count()).toBe(3);\n    expect(putSpy.calls.count()).toBe(3);\n    expect(delSpy.calls.count()).toBe(1);\n\n    const keys = await cacheAdapter.getAllKeys();\n    expect(keys.length).toBe(0);\n  });\n\n  it('test new object multiple fields', async () => {\n    const container = new Container({\n      dateField: new Date(),\n      arrayField: [],\n      numberField: 1,\n      stringField: 'hello',\n      booleanField: true,\n    });\n    await container.save();\n    expect(getSpy.calls.count()).toBe(3);\n    expect(putSpy.calls.count()).toBe(3);\n    expect(delSpy.calls.count()).toBe(1);\n\n    const keys = await cacheAdapter.getAllKeys();\n    expect(keys.length).toBe(0);\n  });\n\n  it('test update existing fields', async () => {\n    const object = new TestObject();\n    object.set('foo', 'bar');\n    await object.save();\n\n    getSpy.calls.reset();\n    putSpy.calls.reset();\n\n    object.set('foo', 'barz');\n    await object.save();\n    expect(getSpy.calls.count()).toBe(3);\n    expect(putSpy.calls.count()).toBe(1);\n    expect(delSpy.calls.count()).toBe(2);\n\n    const keys = await cacheAdapter.getAllKeys();\n    expect(keys.length).toBe(0);\n  });\n\n  it('test saveAll / destroyAll', async () => {\n    const object = new TestObject();\n    await object.save();\n\n    getSpy.calls.reset();\n    putSpy.calls.reset();\n\n    const objects = [];\n    for (let i = 0; i < 10; i++) {\n      const object = new TestObject();\n      object.set('number', i);\n      objects.push(object);\n    }\n    await Parse.Object.saveAll(objects);\n    expect(getSpy.calls.count()).toBe(21);\n    expect(putSpy.calls.count()).toBe(11);\n\n    getSpy.calls.reset();\n    putSpy.calls.reset();\n\n    await Parse.Object.destroyAll(objects);\n    expect(getSpy.calls.count()).toBe(11);\n    expect(putSpy.calls.count()).toBe(1);\n    expect(delSpy.calls.count()).toBe(3);\n\n    const keys = await cacheAdapter.getAllKeys();\n    expect(keys.length).toBe(0);\n  });\n\n  it('test saveAll / destroyAll batch', async () => {\n    const object = new TestObject();\n    await object.save();\n\n    getSpy.calls.reset();\n    putSpy.calls.reset();\n\n    const objects = [];\n    for (let i = 0; i < 10; i++) {\n      const object = new TestObject();\n      object.set('number', i);\n      objects.push(object);\n    }\n    await Parse.Object.saveAll(objects, { batchSize: 5 });\n    expect(getSpy.calls.count()).toBe(22);\n    expect(putSpy.calls.count()).toBe(7);\n\n    getSpy.calls.reset();\n    putSpy.calls.reset();\n\n    await Parse.Object.destroyAll(objects, { batchSize: 5 });\n    expect(getSpy.calls.count()).toBe(12);\n    expect(putSpy.calls.count()).toBe(2);\n    expect(delSpy.calls.count()).toBe(5);\n\n    const keys = await cacheAdapter.getAllKeys();\n    expect(keys.length).toBe(0);\n  });\n\n  it('test add new field to existing object', async () => {\n    const object = new TestObject();\n    object.set('foo', 'bar');\n    await object.save();\n\n    getSpy.calls.reset();\n    putSpy.calls.reset();\n\n    object.set('new', 'barz');\n    await object.save();\n    expect(getSpy.calls.count()).toBe(3);\n    expect(putSpy.calls.count()).toBe(2);\n    expect(delSpy.calls.count()).toBe(2);\n\n    const keys = await cacheAdapter.getAllKeys();\n    expect(keys.length).toBe(0);\n  });\n\n  it('test add multiple fields to existing object', async () => {\n    const object = new TestObject();\n    object.set('foo', 'bar');\n    await object.save();\n\n    getSpy.calls.reset();\n    putSpy.calls.reset();\n\n    object.set({\n      dateField: new Date(),\n      arrayField: [],\n      numberField: 1,\n      stringField: 'hello',\n      booleanField: true,\n    });\n    await object.save();\n    expect(getSpy.calls.count()).toBe(3);\n    expect(putSpy.calls.count()).toBe(2);\n    expect(delSpy.calls.count()).toBe(2);\n\n    const keys = await cacheAdapter.getAllKeys();\n    expect(keys.length).toBe(0);\n  });\n\n  it('test user', async () => {\n    const user = new Parse.User();\n    user.setUsername('testing');\n    user.setPassword('testing');\n    await user.signUp();\n\n    expect(getSpy.calls.count()).toBe(8);\n    expect(putSpy.calls.count()).toBe(2);\n    expect(delSpy.calls.count()).toBe(1);\n\n    const keys = await cacheAdapter.getAllKeys();\n    expect(keys.length).toBe(0);\n  });\n\n  it('test allowClientCreation false', async () => {\n    const object = new TestObject();\n    await object.save();\n    await reconfigureServer({\n      cacheAdapter,\n      allowClientClassCreation: false,\n    });\n    await cacheAdapter.clear();\n\n    getSpy.calls.reset();\n    putSpy.calls.reset();\n    delSpy.calls.reset();\n\n    object.set('foo', 'bar');\n    await object.save();\n    expect(getSpy.calls.count()).toBe(4);\n    expect(putSpy.calls.count()).toBe(2);\n\n    getSpy.calls.reset();\n    putSpy.calls.reset();\n\n    const query = new Parse.Query(TestObject);\n    await query.get(object.id);\n    expect(getSpy.calls.count()).toBe(4);\n    expect(putSpy.calls.count()).toBe(1);\n    expect(delSpy.calls.count()).toBe(2);\n\n    const keys = await cacheAdapter.getAllKeys();\n    expect(keys.length).toBe(0);\n  });\n\n  it('test query', async () => {\n    const object = new TestObject();\n    object.set('foo', 'bar');\n    await object.save();\n\n    getSpy.calls.reset();\n    putSpy.calls.reset();\n    delSpy.calls.reset();\n\n    const query = new Parse.Query(TestObject);\n    await query.get(object.id);\n    expect(getSpy.calls.count()).toBe(3);\n    expect(putSpy.calls.count()).toBe(1);\n    expect(delSpy.calls.count()).toBe(1);\n\n    const keys = await cacheAdapter.getAllKeys();\n    expect(keys.length).toBe(0);\n  });\n\n  it('test query include', async () => {\n    const child = new TestObject();\n    await child.save();\n\n    const object = new TestObject();\n    object.set('child', child);\n    await object.save();\n\n    getSpy.calls.reset();\n    putSpy.calls.reset();\n\n    const query = new Parse.Query(TestObject);\n    query.include('child');\n    await query.get(object.id);\n\n    expect(getSpy.calls.count()).toBe(6);\n    expect(putSpy.calls.count()).toBe(1);\n    expect(delSpy.calls.count()).toBe(3);\n\n    const keys = await cacheAdapter.getAllKeys();\n    expect(keys.length).toBe(0);\n  });\n\n  it('query relation without schema', async () => {\n    const child = new Parse.Object('ChildObject');\n    await child.save();\n\n    const parent = new Parse.Object('ParentObject');\n    const relation = parent.relation('child');\n    relation.add(child);\n    await parent.save();\n\n    getSpy.calls.reset();\n    putSpy.calls.reset();\n\n    const objects = await relation.query().find();\n    expect(objects.length).toBe(1);\n    expect(objects[0].id).toBe(child.id);\n\n    expect(getSpy.calls.count()).toBe(3);\n    expect(putSpy.calls.count()).toBe(1);\n    expect(delSpy.calls.count()).toBe(3);\n\n    const keys = await cacheAdapter.getAllKeys();\n    expect(keys.length).toBe(0);\n  });\n\n  it('test delete object', async () => {\n    const object = new TestObject();\n    object.set('foo', 'bar');\n    await object.save();\n\n    getSpy.calls.reset();\n    putSpy.calls.reset();\n    delSpy.calls.reset();\n\n    await object.destroy();\n    expect(getSpy.calls.count()).toBe(2);\n    expect(putSpy.calls.count()).toBe(1);\n    expect(delSpy.calls.count()).toBe(1);\n\n    const keys = await cacheAdapter.getAllKeys();\n    expect(keys.length).toBe(0);\n  });\n\n  it('test schema update class', async () => {\n    const container = new Container();\n    await container.save();\n\n    getSpy.calls.reset();\n    putSpy.calls.reset();\n    delSpy.calls.reset();\n\n    const config = Config.get('test');\n    const schema = await config.database.loadSchema();\n    await schema.reloadData();\n\n    const levelPermissions = {\n      find: { '*': true },\n      get: { '*': true },\n      create: { '*': true },\n      update: { '*': true },\n      delete: { '*': true },\n      addField: { '*': true },\n      protectedFields: { '*': [] },\n    };\n\n    await schema.updateClass(\n      'Container',\n      {\n        fooOne: { type: 'Number' },\n        fooTwo: { type: 'Array' },\n        fooThree: { type: 'Date' },\n        fooFour: { type: 'Object' },\n        fooFive: { type: 'Relation', targetClass: '_User' },\n        fooSix: { type: 'String' },\n        fooSeven: { type: 'Object' },\n        fooEight: { type: 'String' },\n        fooNine: { type: 'String' },\n        fooTeen: { type: 'Number' },\n        fooEleven: { type: 'String' },\n        fooTwelve: { type: 'String' },\n        fooThirteen: { type: 'String' },\n        fooFourteen: { type: 'String' },\n        fooFifteen: { type: 'String' },\n        fooSixteen: { type: 'String' },\n        fooEighteen: { type: 'String' },\n        fooNineteen: { type: 'String' },\n      },\n      levelPermissions,\n      {},\n      config.database\n    );\n    expect(getSpy.calls.count()).toBe(3);\n    expect(putSpy.calls.count()).toBe(3);\n    expect(delSpy.calls.count()).toBe(0);\n\n    const keys = await cacheAdapter.getAllKeys();\n    expect(keys.length).toBe(1);\n  });\n});\n", "'use strict';\n// These tests check the \"find\" functionality of the REST API.\nconst auth = require('../lib/Auth');\nconst Config = require('../lib/Config');\nconst rest = require('../lib/rest');\nconst RestQuery = require('../lib/RestQuery');\nconst request = require('../lib/request');\n\nconst querystring = require('querystring');\n\nlet config;\nlet database;\nconst nobody = auth.nobody(config);\n\ndescribe('rest query', () => {\n  beforeEach(() => {\n    config = Config.get('test');\n    database = config.database;\n  });\n\n  it('basic query', done => {\n    rest\n      .create(config, nobody, 'TestObject', {})\n      .then(() => {\n        return rest.find(config, nobody, 'TestObject', {});\n      })\n      .then(response => {\n        expect(response.results.length).toEqual(1);\n        done();\n      });\n  });\n\n  it('query with limit', done => {\n    rest\n      .create(config, nobody, 'TestObject', { foo: 'baz' })\n      .then(() => {\n        return rest.create(config, nobody, 'TestObject', { foo: 'qux' });\n      })\n      .then(() => {\n        return rest.find(config, nobody, 'TestObject', {}, { limit: 1 });\n      })\n      .then(response => {\n        expect(response.results.length).toEqual(1);\n        expect(response.results[0].foo).toBeTruthy();\n        done();\n      });\n  });\n\n  const data = {\n    username: 'blah',\n    password: 'pass',\n    sessionToken: 'abc123',\n  };\n\n  it_exclude_dbs(['postgres'])(\n    'query for user w/ legacy credentials without masterKey has them stripped from results',\n    done => {\n      database\n        .create('_User', data)\n        .then(() => {\n          return rest.find(config, nobody, '_User');\n        })\n        .then(result => {\n          const user = result.results[0];\n          expect(user.username).toEqual('blah');\n          expect(user.sessionToken).toBeUndefined();\n          expect(user.password).toBeUndefined();\n          done();\n        });\n    }\n  );\n\n  it_exclude_dbs(['postgres'])(\n    'query for user w/ legacy credentials with masterKey has them stripped from results',\n    done => {\n      database\n        .create('_User', data)\n        .then(() => {\n          return rest.find(config, { isMaster: true }, '_User');\n        })\n        .then(result => {\n          const user = result.results[0];\n          expect(user.username).toEqual('blah');\n          expect(user.sessionToken).toBeUndefined();\n          expect(user.password).toBeUndefined();\n          done();\n        });\n    }\n  );\n\n  // Created to test a scenario in AnyPic\n  it_exclude_dbs(['postgres'])('query with include', done => {\n    let photo = {\n      foo: 'bar',\n    };\n    let user = {\n      username: 'aUsername',\n      password: 'aPassword',\n    };\n    const activity = {\n      type: 'comment',\n      photo: {\n        __type: 'Pointer',\n        className: 'TestPhoto',\n        objectId: '',\n      },\n      fromUser: {\n        __type: 'Pointer',\n        className: '_User',\n        objectId: '',\n      },\n    };\n    const queryWhere = {\n      photo: {\n        __type: 'Pointer',\n        className: 'TestPhoto',\n        objectId: '',\n      },\n      type: 'comment',\n    };\n    const queryOptions = {\n      include: 'fromUser',\n      order: 'createdAt',\n      limit: 30,\n    };\n    rest\n      .create(config, nobody, 'TestPhoto', photo)\n      .then(p => {\n        photo = p;\n        return rest.create(config, nobody, '_User', user);\n      })\n      .then(u => {\n        user = u.response;\n        activity.photo.objectId = photo.objectId;\n        activity.fromUser.objectId = user.objectId;\n        return rest.create(config, nobody, 'TestActivity', activity);\n      })\n      .then(() => {\n        queryWhere.photo.objectId = photo.objectId;\n        return rest.find(config, nobody, 'TestActivity', queryWhere, queryOptions);\n      })\n      .then(response => {\n        const results = response.results;\n        expect(results.length).toEqual(1);\n        expect(typeof results[0].objectId).toEqual('string');\n        expect(typeof results[0].photo).toEqual('object');\n        expect(typeof results[0].fromUser).toEqual('object');\n        expect(typeof results[0].fromUser.username).toEqual('string');\n        done();\n      })\n      .catch(error => {\n        console.log(error);\n      });\n  });\n\n  it('query non-existent class when disabled client class creation', done => {\n    const customConfig = Object.assign({}, config, {\n      allowClientClassCreation: false,\n    });\n    rest.find(customConfig, auth.nobody(customConfig), 'ClientClassCreation', {}).then(\n      () => {\n        fail('Should throw an error');\n        done();\n      },\n      err => {\n        expect(err.code).toEqual(Parse.Error.OPERATION_FORBIDDEN);\n        expect(err.message).toEqual(\n          'This user is not allowed to access ' + 'non-existent class: ClientClassCreation'\n        );\n        done();\n      }\n    );\n  });\n\n  it('query existent class when disabled client class creation', async () => {\n    const customConfig = Object.assign({}, config, {\n      allowClientClassCreation: false,\n    });\n    const schema = await config.database.loadSchema();\n    const actualSchema = await schema.addClassIfNotExists('ClientClassCreation', {});\n    expect(actualSchema.className).toEqual('ClientClassCreation');\n\n    await schema.reloadData({ clearCache: true });\n    // Should not throw\n    const result = await rest.find(\n      customConfig,\n      auth.nobody(customConfig),\n      'ClientClassCreation',\n      {}\n    );\n    expect(result.results.length).toEqual(0);\n  });\n\n  it('query internal field', async () => {\n    const internalFields = [\n      '_email_verify_token',\n      '_perishable_token',\n      '_tombstone',\n      '_email_verify_token_expires_at',\n      '_failed_login_count',\n      '_account_lockout_expires_at',\n      '_password_changed_at',\n      '_password_history',\n    ];\n    await Promise.all([\n      ...internalFields.map(field =>\n        expectAsync(new Parse.Query(Parse.User).exists(field).find()).toBeRejectedWith(\n          new Parse.Error(Parse.Error.INVALID_KEY_NAME, `Invalid key name: ${field}`)\n        )\n      ),\n      ...internalFields.map(field =>\n        new Parse.Query(Parse.User).exists(field).find({ useMasterKey: true })\n      ),\n    ]);\n  });\n\n  it('query protected field', async () => {\n    const user = new Parse.User();\n    user.setUsername('username1');\n    user.setPassword('password');\n    await user.signUp();\n    const config = Config.get(Parse.applicationId);\n    const obj = new Parse.Object('Test');\n\n    obj.set('owner', user);\n    obj.set('test', 'test');\n    obj.set('zip', 1234);\n    await obj.save();\n\n    const schema = await config.database.loadSchema();\n    await schema.updateClass(\n      'Test',\n      {},\n      {\n        get: { '*': true },\n        find: { '*': true },\n        protectedFields: { [user.id]: ['zip'] },\n      }\n    );\n    await Promise.all([\n      new Parse.Query('Test').exists('test').find(),\n      expectAsync(new Parse.Query('Test').exists('zip').find()).toBeRejectedWith(\n        new Parse.Error(\n          Parse.Error.OPERATION_FORBIDDEN,\n          'This user is not allowed to query zip on class Test'\n        )\n      ),\n    ]);\n  });\n\n  it('query protected field with matchesQuery', async () => {\n    const user = new Parse.User();\n    user.setUsername('username1');\n    user.setPassword('password');\n    await user.signUp();\n    const test = new Parse.Object('TestObject', { user });\n    await test.save();\n    const subQuery = new Parse.Query(Parse.User);\n    subQuery.exists('_perishable_token');\n    await expectAsync(\n      new Parse.Query('TestObject').matchesQuery('user', subQuery).find()\n    ).toBeRejectedWith(\n      new Parse.Error(Parse.Error.INVALID_KEY_NAME, 'Invalid key name: _perishable_token')\n    );\n  });\n\n  it('query with wrongly encoded parameter', done => {\n    rest\n      .create(config, nobody, 'TestParameterEncode', { foo: 'bar' })\n      .then(() => {\n        return rest.create(config, nobody, 'TestParameterEncode', {\n          foo: 'baz',\n        });\n      })\n      .then(() => {\n        const headers = {\n          'X-Parse-Application-Id': 'test',\n          'X-Parse-REST-API-Key': 'rest',\n        };\n\n        const p0 = request({\n          headers: headers,\n          url:\n            'http://localhost:8378/1/classes/TestParameterEncode?' +\n            querystring\n              .stringify({\n                where: '{\"foo\":{\"$ne\": \"baz\"}}',\n                limit: 1,\n              })\n              .replace('=', '%3D'),\n        }).then(fail, response => {\n          const error = response.data;\n          expect(error.code).toEqual(Parse.Error.INVALID_QUERY);\n        });\n\n        const p1 = request({\n          headers: headers,\n          url:\n            'http://localhost:8378/1/classes/TestParameterEncode?' +\n            querystring\n              .stringify({\n                limit: 1,\n              })\n              .replace('=', '%3D'),\n        }).then(fail, response => {\n          const error = response.data;\n          expect(error.code).toEqual(Parse.Error.INVALID_QUERY);\n        });\n        return Promise.all([p0, p1]);\n      })\n      .then(done)\n      .catch(err => {\n        jfail(err);\n        fail('should not fail');\n        done();\n      });\n  });\n\n  it('query with limit = 0', done => {\n    rest\n      .create(config, nobody, 'TestObject', { foo: 'baz' })\n      .then(() => {\n        return rest.create(config, nobody, 'TestObject', { foo: 'qux' });\n      })\n      .then(() => {\n        return rest.find(config, nobody, 'TestObject', {}, { limit: 0 });\n      })\n      .then(response => {\n        expect(response.results.length).toEqual(0);\n        done();\n      });\n  });\n\n  it('query with limit = 0 and count = 1', done => {\n    rest\n      .create(config, nobody, 'TestObject', { foo: 'baz' })\n      .then(() => {\n        return rest.create(config, nobody, 'TestObject', { foo: 'qux' });\n      })\n      .then(() => {\n        return rest.find(config, nobody, 'TestObject', {}, { limit: 0, count: 1 });\n      })\n      .then(response => {\n        expect(response.results.length).toEqual(0);\n        expect(response.count).toEqual(2);\n        done();\n      });\n  });\n\n  it('makes sure null pointers are handed correctly #2189', done => {\n    const object = new Parse.Object('AnObject');\n    const anotherObject = new Parse.Object('AnotherObject');\n    anotherObject\n      .save()\n      .then(() => {\n        object.set('values', [null, null, anotherObject]);\n        return object.save();\n      })\n      .then(() => {\n        const query = new Parse.Query('AnObject');\n        query.include('values');\n        return query.first();\n      })\n      .then(\n        result => {\n          const values = result.get('values');\n          expect(values.length).toBe(3);\n          let anotherObjectFound = false;\n          let nullCounts = 0;\n          for (const value of values) {\n            if (value === null) {\n              nullCounts++;\n            } else if (value instanceof Parse.Object) {\n              anotherObjectFound = true;\n            }\n          }\n          expect(nullCounts).toBe(2);\n          expect(anotherObjectFound).toBeTruthy();\n          done();\n        },\n        err => {\n          console.error(err);\n          fail(err);\n          done();\n        }\n      );\n  });\n});\n\ndescribe('RestQuery.each', () => {\n  it('should run each', async () => {\n    const objects = [];\n    while (objects.length != 10) {\n      objects.push(new Parse.Object('Object', { value: objects.length }));\n    }\n    const config = Config.get('test');\n    await Parse.Object.saveAll(objects);\n    const query = new RestQuery(\n      config,\n      auth.master(config),\n      'Object',\n      { value: { $gt: 2 } },\n      { limit: 2 }\n    );\n    const spy = spyOn(query, 'execute').and.callThrough();\n    const classSpy = spyOn(RestQuery.prototype, 'execute').and.callThrough();\n    const results = [];\n    await query.each(result => {\n      expect(result.value).toBeGreaterThan(2);\n      results.push(result);\n    });\n    expect(spy.calls.count()).toBe(0);\n    expect(classSpy.calls.count()).toBe(4);\n    expect(results.length).toBe(7);\n  });\n\n  it('should work with query on relations', async () => {\n    const objectA = new Parse.Object('Letter', { value: 'A' });\n    const objectB = new Parse.Object('Letter', { value: 'B' });\n\n    const object1 = new Parse.Object('Number', { value: '1' });\n    const object2 = new Parse.Object('Number', { value: '2' });\n    const object3 = new Parse.Object('Number', { value: '3' });\n    const object4 = new Parse.Object('Number', { value: '4' });\n    await Parse.Object.saveAll([object1, object2, object3, object4]);\n\n    objectA.relation('numbers').add(object1);\n    objectB.relation('numbers').add(object2);\n    await Parse.Object.saveAll([objectA, objectB]);\n\n    const config = Config.get('test');\n\n    /**\n     * Two queries needed since objectId are sorted and we can't know which one\n     * going to be the first and then skip by the $gt added by each\n     */\n    const queryOne = new RestQuery(\n      config,\n      auth.master(config),\n      'Letter',\n      {\n        numbers: {\n          __type: 'Pointer',\n          className: 'Number',\n          objectId: object1.id,\n        },\n      },\n      { limit: 1 }\n    );\n    const queryTwo = new RestQuery(\n      config,\n      auth.master(config),\n      'Letter',\n      {\n        numbers: {\n          __type: 'Pointer',\n          className: 'Number',\n          objectId: object2.id,\n        },\n      },\n      { limit: 1 }\n    );\n\n    const classSpy = spyOn(RestQuery.prototype, 'execute').and.callThrough();\n    const resultsOne = [];\n    const resultsTwo = [];\n    await queryOne.each(result => {\n      resultsOne.push(result);\n    });\n    await queryTwo.each(result => {\n      resultsTwo.push(result);\n    });\n    expect(classSpy.calls.count()).toBe(4);\n    expect(resultsOne.length).toBe(1);\n    expect(resultsTwo.length).toBe(1);\n  });\n\n  it('test afterSave response object is return', done => {\n    Parse.Cloud.beforeSave('TestObject2', function (req) {\n      req.object.set('tobeaddbefore', true);\n      req.object.set('tobeaddbeforeandremoveafter', true);\n    });\n\n    Parse.Cloud.afterSave('TestObject2', function (req) {\n      const jsonObject = req.object.toJSON();\n      delete jsonObject.todelete;\n      delete jsonObject.tobeaddbeforeandremoveafter;\n      jsonObject.toadd = true;\n\n      return jsonObject;\n    });\n\n    rest.create(config, nobody, 'TestObject2', { todelete: true, tokeep: true }).then(response => {\n      expect(response.response.toadd).toBeTruthy();\n      expect(response.response.tokeep).toBeTruthy();\n      expect(response.response.tobeaddbefore).toBeTruthy();\n      expect(response.response.tobeaddbeforeandremoveafter).toBeUndefined();\n      expect(response.response.todelete).toBeUndefined();\n      done();\n    });\n  });\n});\n", "\ufeff// @flow\n// A database adapter that works with data exported from the hosted\n// Parse database.\n\n// @flow-disable-next\nimport { Parse } from 'parse/node';\n// @flow-disable-next\nimport _ from 'lodash';\n// @flow-disable-next\nimport intersect from 'intersect';\n// @flow-disable-next\nimport deepcopy from 'deepcopy';\nimport logger from '../logger';\nimport Utils from '../Utils';\nimport * as SchemaController from './SchemaController';\nimport { StorageAdapter } from '../Adapters/Storage/StorageAdapter';\nimport type { ParseServerOptions } from '../Options';\nimport type { QueryOptions, FullQueryOptions } from '../Adapters/Storage/StorageAdapter';\n\nfunction addWriteACL(query, acl) {\n  const newQuery = _.cloneDeep(query);\n  //Can't be any existing '_wperm' query, we don't allow client queries on that, no need to $and\n  newQuery._wperm = { $in: [null, ...acl] };\n  return newQuery;\n}\n\nfunction addReadACL(query, acl) {\n  const newQuery = _.cloneDeep(query);\n  //Can't be any existing '_rperm' query, we don't allow client queries on that, no need to $and\n  newQuery._rperm = { $in: [null, '*', ...acl] };\n  return newQuery;\n}\n\n// Transforms a REST API formatted ACL object to our two-field mongo format.\nconst transformObjectACL = ({ ACL, ...result }) => {\n  if (!ACL) {\n    return result;\n  }\n\n  result._wperm = [];\n  result._rperm = [];\n\n  for (const entry in ACL) {\n    if (ACL[entry].read) {\n      result._rperm.push(entry);\n    }\n    if (ACL[entry].write) {\n      result._wperm.push(entry);\n    }\n  }\n  return result;\n};\n\nconst specialQueryKeys = ['$and', '$or', '$nor', '_rperm', '_wperm'];\nconst specialMasterQueryKeys = [\n  ...specialQueryKeys,\n  '_email_verify_token',\n  '_perishable_token',\n  '_tombstone',\n  '_email_verify_token_expires_at',\n  '_failed_login_count',\n  '_account_lockout_expires_at',\n  '_password_changed_at',\n  '_password_history',\n];\n\nconst validateQuery = (query: any, isMaster: boolean, update: boolean): void => {\n  if (query.ACL) {\n    throw new Parse.Error(Parse.Error.INVALID_QUERY, 'Cannot query on ACL.');\n  }\n\n  if (query.$or) {\n    if (query.$or instanceof Array) {\n      query.$or.forEach(value => validateQuery(value, isMaster, update));\n    } else {\n      throw new Parse.Error(Parse.Error.INVALID_QUERY, 'Bad $or format - use an array value.');\n    }\n  }\n\n  if (query.$and) {\n    if (query.$and instanceof Array) {\n      query.$and.forEach(value => validateQuery(value, isMaster, update));\n    } else {\n      throw new Parse.Error(Parse.Error.INVALID_QUERY, 'Bad $and format - use an array value.');\n    }\n  }\n\n  if (query.$nor) {\n    if (query.$nor instanceof Array && query.$nor.length > 0) {\n      query.$nor.forEach(value => validateQuery(value, isMaster, update));\n    } else {\n      throw new Parse.Error(\n        Parse.Error.INVALID_QUERY,\n        'Bad $nor format - use an array of at least 1 value.'\n      );\n    }\n  }\n\n  Object.keys(query).forEach(key => {\n    if (query && query[key] && query[key].$regex) {\n      if (typeof query[key].$options === 'string') {\n        if (!query[key].$options.match(/^[imxs]+$/)) {\n          throw new Parse.Error(\n            Parse.Error.INVALID_QUERY,\n            `Bad $options value for query: ${query[key].$options}`\n          );\n        }\n      }\n    }\n    if (\n      !key.match(/^[a-zA-Z][a-zA-Z0-9_\\.]*$/) &&\n      ((!specialQueryKeys.includes(key) && !isMaster && !update) ||\n        (update && isMaster && !specialMasterQueryKeys.includes(key)))\n    ) {\n      throw new Parse.Error(Parse.Error.INVALID_KEY_NAME, `Invalid key name: ${key}`);\n    }\n  });\n};\n\n// Filters out any data that shouldn't be on this REST-formatted object.\nconst filterSensitiveData = (\n  isMaster: boolean,\n  aclGroup: any[],\n  auth: any,\n  operation: any,\n  schema: SchemaController.SchemaController | any,\n  className: string,\n  protectedFields: null | Array<any>,\n  object: any\n) => {\n  let userId = null;\n  if (auth && auth.user) userId = auth.user.id;\n\n  // replace protectedFields when using pointer-permissions\n  const perms =\n    schema && schema.getClassLevelPermissions ? schema.getClassLevelPermissions(className) : {};\n  if (perms) {\n    const isReadOperation = ['get', 'find'].indexOf(operation) > -1;\n\n    if (isReadOperation && perms.protectedFields) {\n      // extract protectedFields added with the pointer-permission prefix\n      const protectedFieldsPointerPerm = Object.keys(perms.protectedFields)\n        .filter(key => key.startsWith('userField:'))\n        .map(key => {\n          return { key: key.substring(10), value: perms.protectedFields[key] };\n        });\n\n      const newProtectedFields: Array<string>[] = [];\n      let overrideProtectedFields = false;\n\n      // check if the object grants the current user access based on the extracted fields\n      protectedFieldsPointerPerm.forEach(pointerPerm => {\n        let pointerPermIncludesUser = false;\n        const readUserFieldValue = object[pointerPerm.key];\n        if (readUserFieldValue) {\n          if (Array.isArray(readUserFieldValue)) {\n            pointerPermIncludesUser = readUserFieldValue.some(\n              user => user.objectId && user.objectId === userId\n            );\n          } else {\n            pointerPermIncludesUser =\n              readUserFieldValue.objectId && readUserFieldValue.objectId === userId;\n          }\n        }\n\n        if (pointerPermIncludesUser) {\n          overrideProtectedFields = true;\n          newProtectedFields.push(pointerPerm.value);\n        }\n      });\n\n      // if at least one pointer-permission affected the current user\n      // intersect vs protectedFields from previous stage (@see addProtectedFields)\n      // Sets theory (intersections): A x (B x C) == (A x B) x C\n      if (overrideProtectedFields && protectedFields) {\n        newProtectedFields.push(protectedFields);\n      }\n      // intersect all sets of protectedFields\n      newProtectedFields.forEach(fields => {\n        if (fields) {\n          // if there're no protctedFields by other criteria ( id / role / auth)\n          // then we must intersect each set (per userField)\n          if (!protectedFields) {\n            protectedFields = fields;\n          } else {\n            protectedFields = protectedFields.filter(v => fields.includes(v));\n          }\n        }\n      });\n    }\n  }\n\n  const isUserClass = className === '_User';\n\n  /* special treat for the user class: don't filter protectedFields if currently loggedin user is\n  the retrieved user */\n  if (!(isUserClass && userId && object.objectId === userId)) {\n    protectedFields && protectedFields.forEach(k => delete object[k]);\n\n    // fields not requested by client (excluded),\n    //but were needed to apply protecttedFields\n    perms.protectedFields &&\n      perms.protectedFields.temporaryKeys &&\n      perms.protectedFields.temporaryKeys.forEach(k => delete object[k]);\n  }\n\n  if (isUserClass) {\n    object.password = object._hashed_password;\n    delete object._hashed_password;\n    delete object.sessionToken;\n  }\n\n  if (isMaster) {\n    return object;\n  }\n\n  for (const key in object) {\n    if (key.charAt(0) === '_') {\n      delete object[key];\n    }\n  }\n\n  if (!isUserClass) {\n    return object;\n  }\n\n  if (aclGroup.indexOf(object.objectId) > -1) {\n    return object;\n  }\n  delete object.authData;\n  return object;\n};\n\nimport type { LoadSchemaOptions } from './types';\nimport MongoStorageAdapter from '../Adapters/Storage/Mongo/MongoStorageAdapter';\n\n// Runs an update on the database.\n// Returns a promise for an object with the new values for field\n// modifications that don't know their results ahead of time, like\n// 'increment'.\n// Options:\n//   acl:  a list of strings. If the object to be updated has an ACL,\n//         one of the provided strings must provide the caller with\n//         write permissions.\nconst specialKeysForUpdate = [\n  '_hashed_password',\n  '_perishable_token',\n  '_email_verify_token',\n  '_email_verify_token_expires_at',\n  '_account_lockout_expires_at',\n  '_failed_login_count',\n  '_perishable_token_expires_at',\n  '_password_changed_at',\n  '_password_history',\n];\n\nconst isSpecialUpdateKey = key => {\n  return specialKeysForUpdate.indexOf(key) >= 0;\n};\n\nfunction joinTableName(className, key) {\n  return `_Join:${key}:${className}`;\n}\n\nconst flattenUpdateOperatorsForCreate = object => {\n  for (const key in object) {\n    if (object[key] && object[key].__op) {\n      switch (object[key].__op) {\n        case 'Increment':\n          if (typeof object[key].amount !== 'number') {\n            throw new Parse.Error(Parse.Error.INVALID_JSON, 'objects to add must be an array');\n          }\n          object[key] = object[key].amount;\n          break;\n        case 'Add':\n          if (!(object[key].objects instanceof Array)) {\n            throw new Parse.Error(Parse.Error.INVALID_JSON, 'objects to add must be an array');\n          }\n          object[key] = object[key].objects;\n          break;\n        case 'AddUnique':\n          if (!(object[key].objects instanceof Array)) {\n            throw new Parse.Error(Parse.Error.INVALID_JSON, 'objects to add must be an array');\n          }\n          object[key] = object[key].objects;\n          break;\n        case 'Remove':\n          if (!(object[key].objects instanceof Array)) {\n            throw new Parse.Error(Parse.Error.INVALID_JSON, 'objects to add must be an array');\n          }\n          object[key] = [];\n          break;\n        case 'Delete':\n          delete object[key];\n          break;\n        default:\n          throw new Parse.Error(\n            Parse.Error.COMMAND_UNAVAILABLE,\n            `The ${object[key].__op} operator is not supported yet.`\n          );\n      }\n    }\n  }\n};\n\nconst transformAuthData = (className, object, schema) => {\n  if (object.authData && className === '_User') {\n    Object.keys(object.authData).forEach(provider => {\n      const providerData = object.authData[provider];\n      const fieldName = `_auth_data_${provider}`;\n      if (providerData == null) {\n        object[fieldName] = {\n          __op: 'Delete',\n        };\n      } else {\n        object[fieldName] = providerData;\n        schema.fields[fieldName] = { type: 'Object' };\n      }\n    });\n    delete object.authData;\n  }\n};\n// Transforms a Database format ACL to a REST API format ACL\nconst untransformObjectACL = ({ _rperm, _wperm, ...output }) => {\n  if (_rperm || _wperm) {\n    output.ACL = {};\n\n    (_rperm || []).forEach(entry => {\n      if (!output.ACL[entry]) {\n        output.ACL[entry] = { read: true };\n      } else {\n        output.ACL[entry]['read'] = true;\n      }\n    });\n\n    (_wperm || []).forEach(entry => {\n      if (!output.ACL[entry]) {\n        output.ACL[entry] = { write: true };\n      } else {\n        output.ACL[entry]['write'] = true;\n      }\n    });\n  }\n  return output;\n};\n\n/**\n * When querying, the fieldName may be compound, extract the root fieldName\n *     `temperature.celsius` becomes `temperature`\n * @param {string} fieldName that may be a compound field name\n * @returns {string} the root name of the field\n */\nconst getRootFieldName = (fieldName: string): string => {\n  return fieldName.split('.')[0];\n};\n\nconst relationSchema = {\n  fields: { relatedId: { type: 'String' }, owningId: { type: 'String' } },\n};\n\nclass DatabaseController {\n  adapter: StorageAdapter;\n  schemaCache: any;\n  schemaPromise: ?Promise<SchemaController.SchemaController>;\n  _transactionalSession: ?any;\n  options: ParseServerOptions;\n\n  constructor(adapter: StorageAdapter, schemaCache: any, options: ParseServerOptions) {\n    this.adapter = adapter;\n    this.schemaCache = schemaCache;\n    // We don't want a mutable this.schema, because then you could have\n    // one request that uses different schemas for different parts of\n    // it. Instead, use loadSchema to get a schema.\n    this.schemaPromise = null;\n    this._transactionalSession = null;\n    this.options = options;\n  }\n\n  collectionExists(className: string): Promise<boolean> {\n    return this.adapter.classExists(className);\n  }\n\n  purgeCollection(className: string): Promise<void> {\n    return this.loadSchema()\n      .then(schemaController => schemaController.getOneSchema(className))\n      .then(schema => this.adapter.deleteObjectsByQuery(className, schema, {}));\n  }\n\n  validateClassName(className: string): Promise<void> {\n    if (!SchemaController.classNameIsValid(className)) {\n      return Promise.reject(\n        new Parse.Error(Parse.Error.INVALID_CLASS_NAME, 'invalid className: ' + className)\n      );\n    }\n    return Promise.resolve();\n  }\n\n  // Returns a promise for a schemaController.\n  loadSchema(\n    options: LoadSchemaOptions = { clearCache: false }\n  ): Promise<SchemaController.SchemaController> {\n    if (this.schemaPromise != null) {\n      return this.schemaPromise;\n    }\n    this.schemaPromise = SchemaController.load(this.adapter, this.schemaCache, options);\n    this.schemaPromise.then(\n      () => delete this.schemaPromise,\n      () => delete this.schemaPromise\n    );\n    return this.loadSchema(options);\n  }\n\n  loadSchemaIfNeeded(\n    schemaController: SchemaController.SchemaController,\n    options: LoadSchemaOptions = { clearCache: false }\n  ): Promise<SchemaController.SchemaController> {\n    return schemaController ? Promise.resolve(schemaController) : this.loadSchema(options);\n  }\n\n  // Returns a promise for the classname that is related to the given\n  // classname through the key.\n  // TODO: make this not in the DatabaseController interface\n  redirectClassNameForKey(className: string, key: string): Promise<?string> {\n    return this.loadSchema().then(schema => {\n      var t = schema.getExpectedType(className, key);\n      if (t != null && typeof t !== 'string' && t.type === 'Relation') {\n        return t.targetClass;\n      }\n      return className;\n    });\n  }\n\n  // Uses the schema to validate the object (REST API format).\n  // Returns a promise that resolves to the new schema.\n  // This does not update this.schema, because in a situation like a\n  // batch request, that could confuse other users of the schema.\n  validateObject(\n    className: string,\n    object: any,\n    query: any,\n    runOptions: QueryOptions\n  ): Promise<boolean> {\n    let schema;\n    const acl = runOptions.acl;\n    const isMaster = acl === undefined;\n    var aclGroup: string[] = acl || [];\n    return this.loadSchema()\n      .then(s => {\n        schema = s;\n        if (isMaster) {\n          return Promise.resolve();\n        }\n        return this.canAddField(schema, className, object, aclGroup, runOptions);\n      })\n      .then(() => {\n        return schema.validateObject(className, object, query);\n      });\n  }\n\n  update(\n    className: string,\n    query: any,\n    update: any,\n    { acl, many, upsert, addsField }: FullQueryOptions = {},\n    skipSanitization: boolean = false,\n    validateOnly: boolean = false,\n    validSchemaController: SchemaController.SchemaController\n  ): Promise<any> {\n    const originalQuery = query;\n    const originalUpdate = update;\n    // Make a copy of the object, so we don't mutate the incoming data.\n    update = deepcopy(update);\n    var relationUpdates = [];\n    var isMaster = acl === undefined;\n    var aclGroup = acl || [];\n\n    return this.loadSchemaIfNeeded(validSchemaController).then(schemaController => {\n      return (isMaster\n        ? Promise.resolve()\n        : schemaController.validatePermission(className, aclGroup, 'update')\n      )\n        .then(() => {\n          relationUpdates = this.collectRelationUpdates(className, originalQuery.objectId, update);\n          if (!isMaster) {\n            query = this.addPointerPermissions(\n              schemaController,\n              className,\n              'update',\n              query,\n              aclGroup\n            );\n\n            if (addsField) {\n              query = {\n                $and: [\n                  query,\n                  this.addPointerPermissions(\n                    schemaController,\n                    className,\n                    'addField',\n                    query,\n                    aclGroup\n                  ),\n                ],\n              };\n            }\n          }\n          if (!query) {\n            return Promise.resolve();\n          }\n          if (acl) {\n            query = addWriteACL(query, acl);\n          }\n          validateQuery(query, isMaster, true);\n          return schemaController\n            .getOneSchema(className, true)\n            .catch(error => {\n              // If the schema doesn't exist, pretend it exists with no fields. This behavior\n              // will likely need revisiting.\n              if (error === undefined) {\n                return { fields: {} };\n              }\n              throw error;\n            })\n            .then(schema => {\n              Object.keys(update).forEach(fieldName => {\n                if (fieldName.match(/^authData\\.([a-zA-Z0-9_]+)\\.id$/)) {\n                  throw new Parse.Error(\n                    Parse.Error.INVALID_KEY_NAME,\n                    `Invalid field name for update: ${fieldName}`\n                  );\n                }\n                const rootFieldName = getRootFieldName(fieldName);\n                if (\n                  !SchemaController.fieldNameIsValid(rootFieldName, className) &&\n                  !isSpecialUpdateKey(rootFieldName)\n                ) {\n                  throw new Parse.Error(\n                    Parse.Error.INVALID_KEY_NAME,\n                    `Invalid field name for update: ${fieldName}`\n                  );\n                }\n              });\n              for (const updateOperation in update) {\n                if (\n                  update[updateOperation] &&\n                  typeof update[updateOperation] === 'object' &&\n                  Object.keys(update[updateOperation]).some(\n                    innerKey => innerKey.includes('$') || innerKey.includes('.')\n                  )\n                ) {\n                  throw new Parse.Error(\n                    Parse.Error.INVALID_NESTED_KEY,\n                    \"Nested keys should not contain the '$' or '.' characters\"\n                  );\n                }\n              }\n              update = transformObjectACL(update);\n              transformAuthData(className, update, schema);\n              if (validateOnly) {\n                return this.adapter.find(className, schema, query, {}).then(result => {\n                  if (!result || !result.length) {\n                    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Object not found.');\n                  }\n                  return {};\n                });\n              }\n              if (many) {\n                return this.adapter.updateObjectsByQuery(\n                  className,\n                  schema,\n                  query,\n                  update,\n                  this._transactionalSession\n                );\n              } else if (upsert) {\n                return this.adapter.upsertOneObject(\n                  className,\n                  schema,\n                  query,\n                  update,\n                  this._transactionalSession\n                );\n              } else {\n                return this.adapter.findOneAndUpdate(\n                  className,\n                  schema,\n                  query,\n                  update,\n                  this._transactionalSession\n                );\n              }\n            });\n        })\n        .then((result: any) => {\n          if (!result) {\n            throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Object not found.');\n          }\n          if (validateOnly) {\n            return result;\n          }\n          return this.handleRelationUpdates(\n            className,\n            originalQuery.objectId,\n            update,\n            relationUpdates\n          ).then(() => {\n            return result;\n          });\n        })\n        .then(result => {\n          if (skipSanitization) {\n            return Promise.resolve(result);\n          }\n          return this._sanitizeDatabaseResult(originalUpdate, result);\n        });\n    });\n  }\n\n  // Collect all relation-updating operations from a REST-format update.\n  // Returns a list of all relation updates to perform\n  // This mutates update.\n  collectRelationUpdates(className: string, objectId: ?string, update: any) {\n    var ops = [];\n    var deleteMe = [];\n    objectId = update.objectId || objectId;\n\n    var process = (op, key) => {\n      if (!op) {\n        return;\n      }\n      if (op.__op == 'AddRelation') {\n        ops.push({ key, op });\n        deleteMe.push(key);\n      }\n\n      if (op.__op == 'RemoveRelation') {\n        ops.push({ key, op });\n        deleteMe.push(key);\n      }\n\n      if (op.__op == 'Batch') {\n        for (var x of op.ops) {\n          process(x, key);\n        }\n      }\n    };\n\n    for (const key in update) {\n      process(update[key], key);\n    }\n    for (const key of deleteMe) {\n      delete update[key];\n    }\n    return ops;\n  }\n\n  // Processes relation-updating operations from a REST-format update.\n  // Returns a promise that resolves when all updates have been performed\n  handleRelationUpdates(className: string, objectId: string, update: any, ops: any) {\n    var pending = [];\n    objectId = update.objectId || objectId;\n    ops.forEach(({ key, op }) => {\n      if (!op) {\n        return;\n      }\n      if (op.__op == 'AddRelation') {\n        for (const object of op.objects) {\n          pending.push(this.addRelation(key, className, objectId, object.objectId));\n        }\n      }\n\n      if (op.__op == 'RemoveRelation') {\n        for (const object of op.objects) {\n          pending.push(this.removeRelation(key, className, objectId, object.objectId));\n        }\n      }\n    });\n\n    return Promise.all(pending);\n  }\n\n  // Adds a relation.\n  // Returns a promise that resolves successfully iff the add was successful.\n  addRelation(key: string, fromClassName: string, fromId: string, toId: string) {\n    const doc = {\n      relatedId: toId,\n      owningId: fromId,\n    };\n    return this.adapter.upsertOneObject(\n      `_Join:${key}:${fromClassName}`,\n      relationSchema,\n      doc,\n      doc,\n      this._transactionalSession\n    );\n  }\n\n  // Removes a relation.\n  // Returns a promise that resolves successfully iff the remove was\n  // successful.\n  removeRelation(key: string, fromClassName: string, fromId: string, toId: string) {\n    var doc = {\n      relatedId: toId,\n      owningId: fromId,\n    };\n    return this.adapter\n      .deleteObjectsByQuery(\n        `_Join:${key}:${fromClassName}`,\n        relationSchema,\n        doc,\n        this._transactionalSession\n      )\n      .catch(error => {\n        // We don't care if they try to delete a non-existent relation.\n        if (error.code == Parse.Error.OBJECT_NOT_FOUND) {\n          return;\n        }\n        throw error;\n      });\n  }\n\n  // Removes objects matches this query from the database.\n  // Returns a promise that resolves successfully iff the object was\n  // deleted.\n  // Options:\n  //   acl:  a list of strings. If the object to be updated has an ACL,\n  //         one of the provided strings must provide the caller with\n  //         write permissions.\n  destroy(\n    className: string,\n    query: any,\n    { acl }: QueryOptions = {},\n    validSchemaController: SchemaController.SchemaController\n  ): Promise<any> {\n    const isMaster = acl === undefined;\n    const aclGroup = acl || [];\n\n    return this.loadSchemaIfNeeded(validSchemaController).then(schemaController => {\n      return (isMaster\n        ? Promise.resolve()\n        : schemaController.validatePermission(className, aclGroup, 'delete')\n      ).then(() => {\n        if (!isMaster) {\n          query = this.addPointerPermissions(\n            schemaController,\n            className,\n            'delete',\n            query,\n            aclGroup\n          );\n          if (!query) {\n            throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Object not found.');\n          }\n        }\n        // delete by query\n        if (acl) {\n          query = addWriteACL(query, acl);\n        }\n        validateQuery(query, isMaster, false);\n        return schemaController\n          .getOneSchema(className)\n          .catch(error => {\n            // If the schema doesn't exist, pretend it exists with no fields. This behavior\n            // will likely need revisiting.\n            if (error === undefined) {\n              return { fields: {} };\n            }\n            throw error;\n          })\n          .then(parseFormatSchema =>\n            this.adapter.deleteObjectsByQuery(\n              className,\n              parseFormatSchema,\n              query,\n              this._transactionalSession\n            )\n          )\n          .catch(error => {\n            // When deleting sessions while changing passwords, don't throw an error if they don't have any sessions.\n            if (className === '_Session' && error.code === Parse.Error.OBJECT_NOT_FOUND) {\n              return Promise.resolve({});\n            }\n            throw error;\n          });\n      });\n    });\n  }\n\n  // Inserts an object into the database.\n  // Returns a promise that resolves successfully iff the object saved.\n  create(\n    className: string,\n    object: any,\n    { acl }: QueryOptions = {},\n    validateOnly: boolean = false,\n    validSchemaController: SchemaController.SchemaController\n  ): Promise<any> {\n    // Make a copy of the object, so we don't mutate the incoming data.\n    const originalObject = object;\n    object = transformObjectACL(object);\n\n    object.createdAt = { iso: object.createdAt, __type: 'Date' };\n    object.updatedAt = { iso: object.updatedAt, __type: 'Date' };\n\n    var isMaster = acl === undefined;\n    var aclGroup = acl || [];\n    const relationUpdates = this.collectRelationUpdates(className, null, object);\n\n    return this.validateClassName(className)\n      .then(() => this.loadSchemaIfNeeded(validSchemaController))\n      .then(schemaController => {\n        return (isMaster\n          ? Promise.resolve()\n          : schemaController.validatePermission(className, aclGroup, 'create')\n        )\n          .then(() => schemaController.enforceClassExists(className))\n          .then(() => schemaController.getOneSchema(className, true))\n          .then(schema => {\n            transformAuthData(className, object, schema);\n            flattenUpdateOperatorsForCreate(object);\n            if (validateOnly) {\n              return {};\n            }\n            return this.adapter.createObject(\n              className,\n              SchemaController.convertSchemaToAdapterSchema(schema),\n              object,\n              this._transactionalSession\n            );\n          })\n          .then(result => {\n            if (validateOnly) {\n              return originalObject;\n            }\n            return this.handleRelationUpdates(\n              className,\n              object.objectId,\n              object,\n              relationUpdates\n            ).then(() => {\n              return this._sanitizeDatabaseResult(originalObject, result.ops[0]);\n            });\n          });\n      });\n  }\n\n  canAddField(\n    schema: SchemaController.SchemaController,\n    className: string,\n    object: any,\n    aclGroup: string[],\n    runOptions: QueryOptions\n  ): Promise<void> {\n    const classSchema = schema.schemaData[className];\n    if (!classSchema) {\n      return Promise.resolve();\n    }\n    const fields = Object.keys(object);\n    const schemaFields = Object.keys(classSchema.fields);\n    const newKeys = fields.filter(field => {\n      // Skip fields that are unset\n      if (object[field] && object[field].__op && object[field].__op === 'Delete') {\n        return false;\n      }\n      return schemaFields.indexOf(field) < 0;\n    });\n    if (newKeys.length > 0) {\n      // adds a marker that new field is being adding during update\n      runOptions.addsField = true;\n\n      const action = runOptions.action;\n      return schema.validatePermission(className, aclGroup, 'addField', action);\n    }\n    return Promise.resolve();\n  }\n\n  // Won't delete collections in the system namespace\n  /**\n   * Delete all classes and clears the schema cache\n   *\n   * @param {boolean} fast set to true if it's ok to just delete rows and not indexes\n   * @returns {Promise<void>} when the deletions completes\n   */\n  deleteEverything(fast: boolean = false): Promise<any> {\n    this.schemaPromise = null;\n    return Promise.all([this.adapter.deleteAllClasses(fast), this.schemaCache.clear()]);\n  }\n\n  // Returns a promise for a list of related ids given an owning id.\n  // className here is the owning className.\n  relatedIds(\n    className: string,\n    key: string,\n    owningId: string,\n    queryOptions: QueryOptions\n  ): Promise<Array<string>> {\n    const { skip, limit, sort } = queryOptions;\n    const findOptions = {};\n    if (sort && sort.createdAt && this.adapter.canSortOnJoinTables) {\n      findOptions.sort = { _id: sort.createdAt };\n      findOptions.limit = limit;\n      findOptions.skip = skip;\n      queryOptions.skip = 0;\n    }\n    return this.adapter\n      .find(joinTableName(className, key), relationSchema, { owningId }, findOptions)\n      .then(results => results.map(result => result.relatedId));\n  }\n\n  // Returns a promise for a list of owning ids given some related ids.\n  // className here is the owning className.\n  owningIds(className: string, key: string, relatedIds: string[]): Promise<string[]> {\n    return this.adapter\n      .find(\n        joinTableName(className, key),\n        relationSchema,\n        { relatedId: { $in: relatedIds } },\n        { keys: ['owningId'] }\n      )\n      .then(results => results.map(result => result.owningId));\n  }\n\n  // Modifies query so that it no longer has $in on relation fields, or\n  // equal-to-pointer constraints on relation fields.\n  // Returns a promise that resolves when query is mutated\n  reduceInRelation(className: string, query: any, schema: any): Promise<any> {\n    // Search for an in-relation or equal-to-relation\n    // Make it sequential for now, not sure of paralleization side effects\n    if (query['$or']) {\n      const ors = query['$or'];\n      return Promise.all(\n        ors.map((aQuery, index) => {\n          return this.reduceInRelation(className, aQuery, schema).then(aQuery => {\n            query['$or'][index] = aQuery;\n          });\n        })\n      ).then(() => {\n        return Promise.resolve(query);\n      });\n    }\n\n    const promises = Object.keys(query).map(key => {\n      const t = schema.getExpectedType(className, key);\n      if (!t || t.type !== 'Relation') {\n        return Promise.resolve(query);\n      }\n      let queries: ?(any[]) = null;\n      if (\n        query[key] &&\n        (query[key]['$in'] ||\n          query[key]['$ne'] ||\n          query[key]['$nin'] ||\n          query[key].__type == 'Pointer')\n      ) {\n        // Build the list of queries\n        queries = Object.keys(query[key]).map(constraintKey => {\n          let relatedIds;\n          let isNegation = false;\n          if (constraintKey === 'objectId') {\n            relatedIds = [query[key].objectId];\n          } else if (constraintKey == '$in') {\n            relatedIds = query[key]['$in'].map(r => r.objectId);\n          } else if (constraintKey == '$nin') {\n            isNegation = true;\n            relatedIds = query[key]['$nin'].map(r => r.objectId);\n          } else if (constraintKey == '$ne') {\n            isNegation = true;\n            relatedIds = [query[key]['$ne'].objectId];\n          } else {\n            return;\n          }\n          return {\n            isNegation,\n            relatedIds,\n          };\n        });\n      } else {\n        queries = [{ isNegation: false, relatedIds: [] }];\n      }\n\n      // remove the current queryKey as we don,t need it anymore\n      delete query[key];\n      // execute each query independently to build the list of\n      // $in / $nin\n      const promises = queries.map(q => {\n        if (!q) {\n          return Promise.resolve();\n        }\n        return this.owningIds(className, key, q.relatedIds).then(ids => {\n          if (q.isNegation) {\n            this.addNotInObjectIdsIds(ids, query);\n          } else {\n            this.addInObjectIdsIds(ids, query);\n          }\n          return Promise.resolve();\n        });\n      });\n\n      return Promise.all(promises).then(() => {\n        return Promise.resolve();\n      });\n    });\n\n    return Promise.all(promises).then(() => {\n      return Promise.resolve(query);\n    });\n  }\n\n  // Modifies query so that it no longer has $relatedTo\n  // Returns a promise that resolves when query is mutated\n  reduceRelationKeys(className: string, query: any, queryOptions: any): ?Promise<void> {\n    if (query['$or']) {\n      return Promise.all(\n        query['$or'].map(aQuery => {\n          return this.reduceRelationKeys(className, aQuery, queryOptions);\n        })\n      );\n    }\n\n    var relatedTo = query['$relatedTo'];\n    if (relatedTo) {\n      return this.relatedIds(\n        relatedTo.object.className,\n        relatedTo.key,\n        relatedTo.object.objectId,\n        queryOptions\n      )\n        .then(ids => {\n          delete query['$relatedTo'];\n          this.addInObjectIdsIds(ids, query);\n          return this.reduceRelationKeys(className, query, queryOptions);\n        })\n        .then(() => {});\n    }\n  }\n\n  addInObjectIdsIds(ids: ?Array<string> = null, query: any) {\n    const idsFromString: ?Array<string> =\n      typeof query.objectId === 'string' ? [query.objectId] : null;\n    const idsFromEq: ?Array<string> =\n      query.objectId && query.objectId['$eq'] ? [query.objectId['$eq']] : null;\n    const idsFromIn: ?Array<string> =\n      query.objectId && query.objectId['$in'] ? query.objectId['$in'] : null;\n\n    // @flow-disable-next\n    const allIds: Array<Array<string>> = [idsFromString, idsFromEq, idsFromIn, ids].filter(\n      list => list !== null\n    );\n    const totalLength = allIds.reduce((memo, list) => memo + list.length, 0);\n\n    let idsIntersection = [];\n    if (totalLength > 125) {\n      idsIntersection = intersect.big(allIds);\n    } else {\n      idsIntersection = intersect(allIds);\n    }\n\n    // Need to make sure we don't clobber existing shorthand $eq constraints on objectId.\n    if (!('objectId' in query)) {\n      query.objectId = {\n        $in: undefined,\n      };\n    } else if (typeof query.objectId === 'string') {\n      query.objectId = {\n        $in: undefined,\n        $eq: query.objectId,\n      };\n    }\n    query.objectId['$in'] = idsIntersection;\n\n    return query;\n  }\n\n  addNotInObjectIdsIds(ids: string[] = [], query: any) {\n    const idsFromNin = query.objectId && query.objectId['$nin'] ? query.objectId['$nin'] : [];\n    let allIds = [...idsFromNin, ...ids].filter(list => list !== null);\n\n    // make a set and spread to remove duplicates\n    allIds = [...new Set(allIds)];\n\n    // Need to make sure we don't clobber existing shorthand $eq constraints on objectId.\n    if (!('objectId' in query)) {\n      query.objectId = {\n        $nin: undefined,\n      };\n    } else if (typeof query.objectId === 'string') {\n      query.objectId = {\n        $nin: undefined,\n        $eq: query.objectId,\n      };\n    }\n\n    query.objectId['$nin'] = allIds;\n    return query;\n  }\n\n  // Runs a query on the database.\n  // Returns a promise that resolves to a list of items.\n  // Options:\n  //   skip    number of results to skip.\n  //   limit   limit to this number of results.\n  //   sort    an object where keys are the fields to sort by.\n  //           the value is +1 for ascending, -1 for descending.\n  //   count   run a count instead of returning results.\n  //   acl     restrict this operation with an ACL for the provided array\n  //           of user objectIds and roles. acl: null means no user.\n  //           when this field is not present, don't do anything regarding ACLs.\n  //  caseInsensitive make string comparisons case insensitive\n  // TODO: make userIds not needed here. The db adapter shouldn't know\n  // anything about users, ideally. Then, improve the format of the ACL\n  // arg to work like the others.\n  find(\n    className: string,\n    query: any,\n    {\n      skip,\n      limit,\n      acl,\n      sort = {},\n      count,\n      keys,\n      op,\n      distinct,\n      pipeline,\n      readPreference,\n      hint,\n      caseInsensitive = false,\n      explain,\n    }: any = {},\n    auth: any = {},\n    validSchemaController: SchemaController.SchemaController\n  ): Promise<any> {\n    const isMaster = acl === undefined;\n    const aclGroup = acl || [];\n    op =\n      op || (typeof query.objectId == 'string' && Object.keys(query).length === 1 ? 'get' : 'find');\n    // Count operation if counting\n    op = count === true ? 'count' : op;\n\n    let classExists = true;\n    return this.loadSchemaIfNeeded(validSchemaController).then(schemaController => {\n      //Allow volatile classes if querying with Master (for _PushStatus)\n      //TODO: Move volatile classes concept into mongo adapter, postgres adapter shouldn't care\n      //that api.parse.com breaks when _PushStatus exists in mongo.\n      return schemaController\n        .getOneSchema(className, isMaster)\n        .catch(error => {\n          // Behavior for non-existent classes is kinda weird on Parse.com. Probably doesn't matter too much.\n          // For now, pretend the class exists but has no objects,\n          if (error === undefined) {\n            classExists = false;\n            return { fields: {} };\n          }\n          throw error;\n        })\n        .then(schema => {\n          // Parse.com treats queries on _created_at and _updated_at as if they were queries on createdAt and updatedAt,\n          // so duplicate that behavior here. If both are specified, the correct behavior to match Parse.com is to\n          // use the one that appears first in the sort list.\n          if (sort._created_at) {\n            sort.createdAt = sort._created_at;\n            delete sort._created_at;\n          }\n          if (sort._updated_at) {\n            sort.updatedAt = sort._updated_at;\n            delete sort._updated_at;\n          }\n          const queryOptions = {\n            skip,\n            limit,\n            sort,\n            keys,\n            readPreference,\n            hint,\n            caseInsensitive,\n            explain,\n          };\n          Object.keys(sort).forEach(fieldName => {\n            if (fieldName.match(/^authData\\.([a-zA-Z0-9_]+)\\.id$/)) {\n              throw new Parse.Error(Parse.Error.INVALID_KEY_NAME, `Cannot sort by ${fieldName}`);\n            }\n            const rootFieldName = getRootFieldName(fieldName);\n            if (!SchemaController.fieldNameIsValid(rootFieldName, className)) {\n              throw new Parse.Error(\n                Parse.Error.INVALID_KEY_NAME,\n                `Invalid field name: ${fieldName}.`\n              );\n            }\n          });\n          return (isMaster\n            ? Promise.resolve()\n            : schemaController.validatePermission(className, aclGroup, op)\n          )\n            .then(() => this.reduceRelationKeys(className, query, queryOptions))\n            .then(() => this.reduceInRelation(className, query, schemaController))\n            .then(() => {\n              let protectedFields;\n              if (!isMaster) {\n                query = this.addPointerPermissions(\n                  schemaController,\n                  className,\n                  op,\n                  query,\n                  aclGroup\n                );\n                /* Don't use projections to optimize the protectedFields since the protectedFields\n                  based on pointer-permissions are determined after querying. The filtering can\n                  overwrite the protected fields. */\n                protectedFields = this.addProtectedFields(\n                  schemaController,\n                  className,\n                  query,\n                  aclGroup,\n                  auth,\n                  queryOptions\n                );\n              }\n              if (!query) {\n                if (op === 'get') {\n                  throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Object not found.');\n                } else {\n                  return [];\n                }\n              }\n              if (!isMaster) {\n                if (op === 'update' || op === 'delete') {\n                  query = addWriteACL(query, aclGroup);\n                } else {\n                  query = addReadACL(query, aclGroup);\n                }\n              }\n              validateQuery(query, isMaster, false);\n              if (count) {\n                if (!classExists) {\n                  return 0;\n                } else {\n                  return this.adapter.count(\n                    className,\n                    schema,\n                    query,\n                    readPreference,\n                    undefined,\n                    hint\n                  );\n                }\n              } else if (distinct) {\n                if (!classExists) {\n                  return [];\n                } else {\n                  return this.adapter.distinct(className, schema, query, distinct);\n                }\n              } else if (pipeline) {\n                if (!classExists) {\n                  return [];\n                } else {\n                  return this.adapter.aggregate(\n                    className,\n                    schema,\n                    pipeline,\n                    readPreference,\n                    hint,\n                    explain\n                  );\n                }\n              } else if (explain) {\n                return this.adapter.find(className, schema, query, queryOptions);\n              } else {\n                return this.adapter\n                  .find(className, schema, query, queryOptions)\n                  .then(objects =>\n                    objects.map(object => {\n                      object = untransformObjectACL(object);\n                      return filterSensitiveData(\n                        isMaster,\n                        aclGroup,\n                        auth,\n                        op,\n                        schemaController,\n                        className,\n                        protectedFields,\n                        object\n                      );\n                    })\n                  )\n                  .catch(error => {\n                    throw new Parse.Error(Parse.Error.INTERNAL_SERVER_ERROR, error);\n                  });\n              }\n            });\n        });\n    });\n  }\n\n  deleteSchema(className: string): Promise<void> {\n    return this.loadSchema({ clearCache: true })\n      .then(schemaController => schemaController.getOneSchema(className, true))\n      .catch(error => {\n        if (error === undefined) {\n          return { fields: {} };\n        } else {\n          throw error;\n        }\n      })\n      .then((schema: any) => {\n        return this.collectionExists(className)\n          .then(() => this.adapter.count(className, { fields: {} }, null, '', false))\n          .then(count => {\n            if (count > 0) {\n              throw new Parse.Error(\n                255,\n                `Class ${className} is not empty, contains ${count} objects, cannot drop schema.`\n              );\n            }\n            return this.adapter.deleteClass(className);\n          })\n          .then(wasParseCollection => {\n            if (wasParseCollection) {\n              const relationFieldNames = Object.keys(schema.fields).filter(\n                fieldName => schema.fields[fieldName].type === 'Relation'\n              );\n              return Promise.all(\n                relationFieldNames.map(name =>\n                  this.adapter.deleteClass(joinTableName(className, name))\n                )\n              ).then(() => {\n                return;\n              });\n            } else {\n              return Promise.resolve();\n            }\n          });\n      });\n  }\n\n  // Constraints query using CLP's pointer permissions (PP) if any.\n  // 1. Etract the user id from caller's ACLgroup;\n  // 2. Exctract a list of field names that are PP for target collection and operation;\n  // 3. Constraint the original query so that each PP field must\n  // point to caller's id (or contain it in case of PP field being an array)\n  addPointerPermissions(\n    schema: SchemaController.SchemaController,\n    className: string,\n    operation: string,\n    query: any,\n    aclGroup: any[] = []\n  ): any {\n    // Check if class has public permission for operation\n    // If the BaseCLP pass, let go through\n    if (schema.testPermissionsForClassName(className, aclGroup, operation)) {\n      return query;\n    }\n    const perms = schema.getClassLevelPermissions(className);\n\n    const userACL = aclGroup.filter(acl => {\n      return acl.indexOf('role:') != 0 && acl != '*';\n    });\n\n    const groupKey =\n      ['get', 'find', 'count'].indexOf(operation) > -1 ? 'readUserFields' : 'writeUserFields';\n\n    const permFields = [];\n\n    if (perms[operation] && perms[operation].pointerFields) {\n      permFields.push(...perms[operation].pointerFields);\n    }\n\n    if (perms[groupKey]) {\n      for (const field of perms[groupKey]) {\n        if (!permFields.includes(field)) {\n          permFields.push(field);\n        }\n      }\n    }\n    // the ACL should have exactly 1 user\n    if (permFields.length > 0) {\n      // the ACL should have exactly 1 user\n      // No user set return undefined\n      // If the length is > 1, that means we didn't de-dupe users correctly\n      if (userACL.length != 1) {\n        return;\n      }\n      const userId = userACL[0];\n      const userPointer = {\n        __type: 'Pointer',\n        className: '_User',\n        objectId: userId,\n      };\n\n      const queries = permFields.map(key => {\n        const fieldDescriptor = schema.getExpectedType(className, key);\n        const fieldType =\n          fieldDescriptor &&\n          typeof fieldDescriptor === 'object' &&\n          Object.prototype.hasOwnProperty.call(fieldDescriptor, 'type')\n            ? fieldDescriptor.type\n            : null;\n\n        let queryClause;\n\n        if (fieldType === 'Pointer') {\n          // constraint for single pointer setup\n          queryClause = { [key]: userPointer };\n        } else if (fieldType === 'Array') {\n          // constraint for users-array setup\n          queryClause = { [key]: { $all: [userPointer] } };\n        } else if (fieldType === 'Object') {\n          // constraint for object setup\n          queryClause = { [key]: userPointer };\n        } else {\n          // This means that there is a CLP field of an unexpected type. This condition should not happen, which is\n          // why is being treated as an error.\n          throw Error(\n            `An unexpected condition occurred when resolving pointer permissions: ${className} ${key}`\n          );\n        }\n        // if we already have a constraint on the key, use the $and\n        if (Object.prototype.hasOwnProperty.call(query, key)) {\n          return { $and: [queryClause, query] };\n        }\n        // otherwise just add the constaint\n        return Object.assign({}, query, queryClause);\n      });\n\n      return queries.length === 1 ? queries[0] : { $or: queries };\n    } else {\n      return query;\n    }\n  }\n\n  addProtectedFields(\n    schema: SchemaController.SchemaController | any,\n    className: string,\n    query: any = {},\n    aclGroup: any[] = [],\n    auth: any = {},\n    queryOptions: FullQueryOptions = {}\n  ): null | string[] {\n    const perms =\n      schema && schema.getClassLevelPermissions\n        ? schema.getClassLevelPermissions(className)\n        : schema;\n    if (!perms) return null;\n\n    const protectedFields = perms.protectedFields;\n    if (!protectedFields) return null;\n\n    if (aclGroup.indexOf(query.objectId) > -1) return null;\n\n    // for queries where \"keys\" are set and do not include all 'userField':{field},\n    // we have to transparently include it, and then remove before returning to client\n    // Because if such key not projected the permission won't be enforced properly\n    // PS this is called when 'excludeKeys' already reduced to 'keys'\n    const preserveKeys = queryOptions.keys;\n\n    // these are keys that need to be included only\n    // to be able to apply protectedFields by pointer\n    // and then unset before returning to client (later in  filterSensitiveFields)\n    const serverOnlyKeys = [];\n\n    const authenticated = auth.user;\n\n    // map to allow check without array search\n    const roles = (auth.userRoles || []).reduce((acc, r) => {\n      acc[r] = protectedFields[r];\n      return acc;\n    }, {});\n\n    // array of sets of protected fields. separate item for each applicable criteria\n    const protectedKeysSets = [];\n\n    for (const key in protectedFields) {\n      // skip userFields\n      if (key.startsWith('userField:')) {\n        if (preserveKeys) {\n          const fieldName = key.substring(10);\n          if (!preserveKeys.includes(fieldName)) {\n            // 1. put it there temporarily\n            queryOptions.keys && queryOptions.keys.push(fieldName);\n            // 2. preserve it delete later\n            serverOnlyKeys.push(fieldName);\n          }\n        }\n        continue;\n      }\n\n      // add public tier\n      if (key === '*') {\n        protectedKeysSets.push(protectedFields[key]);\n        continue;\n      }\n\n      if (authenticated) {\n        if (key === 'authenticated') {\n          // for logged in users\n          protectedKeysSets.push(protectedFields[key]);\n          continue;\n        }\n\n        if (roles[key] && key.startsWith('role:')) {\n          // add applicable roles\n          protectedKeysSets.push(roles[key]);\n        }\n      }\n    }\n\n    // check if there's a rule for current user's id\n    if (authenticated) {\n      const userId = auth.user.id;\n      if (perms.protectedFields[userId]) {\n        protectedKeysSets.push(perms.protectedFields[userId]);\n      }\n    }\n\n    // preserve fields to be removed before sending response to client\n    if (serverOnlyKeys.length > 0) {\n      perms.protectedFields.temporaryKeys = serverOnlyKeys;\n    }\n\n    let protectedKeys = protectedKeysSets.reduce((acc, next) => {\n      if (next) {\n        acc.push(...next);\n      }\n      return acc;\n    }, []);\n\n    // intersect all sets of protectedFields\n    protectedKeysSets.forEach(fields => {\n      if (fields) {\n        protectedKeys = protectedKeys.filter(v => fields.includes(v));\n      }\n    });\n\n    return protectedKeys;\n  }\n\n  createTransactionalSession() {\n    return this.adapter.createTransactionalSession().then(transactionalSession => {\n      this._transactionalSession = transactionalSession;\n    });\n  }\n\n  commitTransactionalSession() {\n    if (!this._transactionalSession) {\n      throw new Error('There is no transactional session to commit');\n    }\n    return this.adapter.commitTransactionalSession(this._transactionalSession).then(() => {\n      this._transactionalSession = null;\n    });\n  }\n\n  abortTransactionalSession() {\n    if (!this._transactionalSession) {\n      throw new Error('There is no transactional session to abort');\n    }\n    return this.adapter.abortTransactionalSession(this._transactionalSession).then(() => {\n      this._transactionalSession = null;\n    });\n  }\n\n  // TODO: create indexes on first creation of a _User object. Otherwise it's impossible to\n  // have a Parse app without it having a _User collection.\n  performInitialization() {\n    const requiredUserFields = {\n      fields: {\n        ...SchemaController.defaultColumns._Default,\n        ...SchemaController.defaultColumns._User,\n      },\n    };\n    const requiredRoleFields = {\n      fields: {\n        ...SchemaController.defaultColumns._Default,\n        ...SchemaController.defaultColumns._Role,\n      },\n    };\n    const requiredIdempotencyFields = {\n      fields: {\n        ...SchemaController.defaultColumns._Default,\n        ...SchemaController.defaultColumns._Idempotency,\n      },\n    };\n\n    const userClassPromise = this.loadSchema().then(schema => schema.enforceClassExists('_User'));\n    const roleClassPromise = this.loadSchema().then(schema => schema.enforceClassExists('_Role'));\n    const idempotencyClassPromise =\n      this.adapter instanceof MongoStorageAdapter\n        ? this.loadSchema().then(schema => schema.enforceClassExists('_Idempotency'))\n        : Promise.resolve();\n\n    const usernameUniqueness = userClassPromise\n      .then(() => this.adapter.ensureUniqueness('_User', requiredUserFields, ['username']))\n      .catch(error => {\n        logger.warn('Unable to ensure uniqueness for usernames: ', error);\n        throw error;\n      });\n\n    const usernameCaseInsensitiveIndex = userClassPromise\n      .then(() =>\n        this.adapter.ensureIndex(\n          '_User',\n          requiredUserFields,\n          ['username'],\n          'case_insensitive_username',\n          true\n        )\n      )\n      .catch(error => {\n        logger.warn('Unable to create case insensitive username index: ', error);\n        throw error;\n      });\n\n    const emailUniqueness = userClassPromise\n      .then(() => this.adapter.ensureUniqueness('_User', requiredUserFields, ['email']))\n      .catch(error => {\n        logger.warn('Unable to ensure uniqueness for user email addresses: ', error);\n        throw error;\n      });\n\n    const emailCaseInsensitiveIndex = userClassPromise\n      .then(() =>\n        this.adapter.ensureIndex(\n          '_User',\n          requiredUserFields,\n          ['email'],\n          'case_insensitive_email',\n          true\n        )\n      )\n      .catch(error => {\n        logger.warn('Unable to create case insensitive email index: ', error);\n        throw error;\n      });\n\n    const roleUniqueness = roleClassPromise\n      .then(() => this.adapter.ensureUniqueness('_Role', requiredRoleFields, ['name']))\n      .catch(error => {\n        logger.warn('Unable to ensure uniqueness for role name: ', error);\n        throw error;\n      });\n\n    const idempotencyRequestIdIndex =\n      this.adapter instanceof MongoStorageAdapter\n        ? idempotencyClassPromise\n          .then(() =>\n            this.adapter.ensureUniqueness('_Idempotency', requiredIdempotencyFields, ['reqId'])\n          )\n          .catch(error => {\n            logger.warn('Unable to ensure uniqueness for idempotency request ID: ', error);\n            throw error;\n          })\n        : Promise.resolve();\n\n    const idempotencyExpireIndex =\n      this.adapter instanceof MongoStorageAdapter\n        ? idempotencyClassPromise\n          .then(() =>\n            this.adapter.ensureIndex(\n              '_Idempotency',\n              requiredIdempotencyFields,\n              ['expire'],\n              'ttl',\n              false,\n              { ttl: 0 }\n            )\n          )\n          .catch(error => {\n            logger.warn('Unable to create TTL index for idempotency expire date: ', error);\n            throw error;\n          })\n        : Promise.resolve();\n\n    const indexPromise = this.adapter.updateSchemaWithIndexes();\n\n    // Create tables for volatile classes\n    const adapterInit = this.adapter.performInitialization({\n      VolatileClassesSchemas: SchemaController.VolatileClassesSchemas,\n    });\n    return Promise.all([\n      usernameUniqueness,\n      usernameCaseInsensitiveIndex,\n      emailUniqueness,\n      emailCaseInsensitiveIndex,\n      roleUniqueness,\n      idempotencyRequestIdIndex,\n      idempotencyExpireIndex,\n      adapterInit,\n      indexPromise,\n    ]);\n  }\n\n  _expandResultOnKeyPath(object: any, key: string, value: any): any {\n    if (key.indexOf('.') < 0) {\n      object[key] = value[key];\n      return object;\n    }\n    const path = key.split('.');\n    const firstKey = path[0];\n    const nextPath = path.slice(1).join('.');\n\n    // Scan request data for denied keywords\n    if (this.options && this.options.requestKeywordDenylist) {\n      // Scan request data for denied keywords\n      for (const keyword of this.options.requestKeywordDenylist) {\n        const match = Utils.objectContainsKeyValue({ firstKey: undefined }, keyword.key, undefined);\n        if (match) {\n          throw new Parse.Error(\n            Parse.Error.INVALID_KEY_NAME,\n            `Prohibited keyword in request data: ${JSON.stringify(keyword)}.`\n          );\n        }\n      }\n    }\n\n    object[firstKey] = this._expandResultOnKeyPath(\n      object[firstKey] || {},\n      nextPath,\n      value[firstKey]\n    );\n    delete object[key];\n    return object;\n  }\n\n  _sanitizeDatabaseResult(originalObject: any, result: any): Promise<any> {\n    const response = {};\n    if (!result) {\n      return Promise.resolve(response);\n    }\n    Object.keys(originalObject).forEach(key => {\n      const keyUpdate = originalObject[key];\n      // determine if that was an op\n      if (\n        keyUpdate &&\n        typeof keyUpdate === 'object' &&\n        keyUpdate.__op &&\n        ['Add', 'AddUnique', 'Remove', 'Increment'].indexOf(keyUpdate.__op) > -1\n      ) {\n        // only valid ops that produce an actionable result\n        // the op may have happened on a keypath\n        this._expandResultOnKeyPath(response, key, result);\n      }\n    });\n    return Promise.resolve(response);\n  }\n\n  static _validateQuery: (any, boolean, boolean) => void;\n  static filterSensitiveData: (boolean, any[], any, any, any, string, any[], any) => void;\n}\n\nmodule.exports = DatabaseController;\n// Expose validateQuery for tests\nmodule.exports._validateQuery = validateQuery;\nmodule.exports.filterSensitiveData = filterSensitiveData;\n", "// An object that encapsulates everything we need to run a 'find'\n// operation, encoded in the REST API format.\n\nvar SchemaController = require('./Controllers/SchemaController');\nvar Parse = require('parse/node').Parse;\nconst triggers = require('./triggers');\nconst { continueWhile } = require('parse/lib/node/promiseUtils');\nconst AlwaysSelectedKeys = ['objectId', 'createdAt', 'updatedAt', 'ACL'];\n// restOptions can include:\n//   skip\n//   limit\n//   order\n//   count\n//   include\n//   keys\n//   excludeKeys\n//   redirectClassNameForKey\n//   readPreference\n//   includeReadPreference\n//   subqueryReadPreference\nfunction RestQuery(\n  config,\n  auth,\n  className,\n  restWhere = {},\n  restOptions = {},\n  clientSDK,\n  runAfterFind = true\n) {\n  this.config = config;\n  this.auth = auth;\n  this.className = className;\n  this.restWhere = restWhere;\n  this.restOptions = restOptions;\n  this.clientSDK = clientSDK;\n  this.runAfterFind = runAfterFind;\n  this.response = null;\n  this.findOptions = {};\n\n  if (!this.auth.isMaster) {\n    if (this.className == '_Session') {\n      if (!this.auth.user) {\n        throw new Parse.Error(Parse.Error.INVALID_SESSION_TOKEN, 'Invalid session token');\n      }\n      this.restWhere = {\n        $and: [\n          this.restWhere,\n          {\n            user: {\n              __type: 'Pointer',\n              className: '_User',\n              objectId: this.auth.user.id,\n            },\n          },\n        ],\n      };\n    }\n  }\n\n  this.doCount = false;\n  this.includeAll = false;\n\n  // The format for this.include is not the same as the format for the\n  // include option - it's the paths we should include, in order,\n  // stored as arrays, taking into account that we need to include foo\n  // before including foo.bar. Also it should dedupe.\n  // For example, passing an arg of include=foo.bar,foo.baz could lead to\n  // this.include = [['foo'], ['foo', 'baz'], ['foo', 'bar']]\n  this.include = [];\n\n  // If we have keys, we probably want to force some includes (n-1 level)\n  // See issue: https://github.com/parse-community/parse-server/issues/3185\n  if (Object.prototype.hasOwnProperty.call(restOptions, 'keys')) {\n    const keysForInclude = restOptions.keys\n      .split(',')\n      .filter(key => {\n        // At least 2 components\n        return key.split('.').length > 1;\n      })\n      .map(key => {\n        // Slice the last component (a.b.c -> a.b)\n        // Otherwise we'll include one level too much.\n        return key.slice(0, key.lastIndexOf('.'));\n      })\n      .join(',');\n\n    // Concat the possibly present include string with the one from the keys\n    // Dedup / sorting is handle in 'include' case.\n    if (keysForInclude.length > 0) {\n      if (!restOptions.include || restOptions.include.length == 0) {\n        restOptions.include = keysForInclude;\n      } else {\n        restOptions.include += ',' + keysForInclude;\n      }\n    }\n  }\n\n  for (var option in restOptions) {\n    switch (option) {\n      case 'keys': {\n        const keys = restOptions.keys.split(',').concat(AlwaysSelectedKeys);\n        this.keys = Array.from(new Set(keys));\n        break;\n      }\n      case 'excludeKeys': {\n        const exclude = restOptions.excludeKeys\n          .split(',')\n          .filter(k => AlwaysSelectedKeys.indexOf(k) < 0);\n        this.excludeKeys = Array.from(new Set(exclude));\n        break;\n      }\n      case 'count':\n        this.doCount = true;\n        break;\n      case 'includeAll':\n        this.includeAll = true;\n        break;\n      case 'explain':\n      case 'hint':\n      case 'distinct':\n      case 'pipeline':\n      case 'skip':\n      case 'limit':\n      case 'readPreference':\n        this.findOptions[option] = restOptions[option];\n        break;\n      case 'order':\n        var fields = restOptions.order.split(',');\n        this.findOptions.sort = fields.reduce((sortMap, field) => {\n          field = field.trim();\n          if (field === '$score') {\n            sortMap.score = { $meta: 'textScore' };\n          } else if (field[0] == '-') {\n            sortMap[field.slice(1)] = -1;\n          } else {\n            sortMap[field] = 1;\n          }\n          return sortMap;\n        }, {});\n        break;\n      case 'include': {\n        const paths = restOptions.include.split(',');\n        if (paths.includes('*')) {\n          this.includeAll = true;\n          break;\n        }\n        // Load the existing includes (from keys)\n        const pathSet = paths.reduce((memo, path) => {\n          // Split each paths on . (a.b.c -> [a,b,c])\n          // reduce to create all paths\n          // ([a,b,c] -> {a: true, 'a.b': true, 'a.b.c': true})\n          return path.split('.').reduce((memo, path, index, parts) => {\n            memo[parts.slice(0, index + 1).join('.')] = true;\n            return memo;\n          }, memo);\n        }, {});\n\n        this.include = Object.keys(pathSet)\n          .map(s => {\n            return s.split('.');\n          })\n          .sort((a, b) => {\n            return a.length - b.length; // Sort by number of components\n          });\n        break;\n      }\n      case 'redirectClassNameForKey':\n        this.redirectKey = restOptions.redirectClassNameForKey;\n        this.redirectClassName = null;\n        break;\n      case 'includeReadPreference':\n      case 'subqueryReadPreference':\n        break;\n      default:\n        throw new Parse.Error(Parse.Error.INVALID_JSON, 'bad option: ' + option);\n    }\n  }\n}\n\n// A convenient method to perform all the steps of processing a query\n// in order.\n// Returns a promise for the response - an object with optional keys\n// 'results' and 'count'.\n// TODO: consolidate the replaceX functions\nRestQuery.prototype.execute = function (executeOptions) {\n  return Promise.resolve()\n    .then(() => {\n      return this.buildRestWhere();\n    })\n    .then(() => {\n      return this.denyProtectedFields();\n    })\n    .then(() => {\n      return this.handleIncludeAll();\n    })\n    .then(() => {\n      return this.handleExcludeKeys();\n    })\n    .then(() => {\n      return this.runFind(executeOptions);\n    })\n    .then(() => {\n      return this.runCount();\n    })\n    .then(() => {\n      return this.handleInclude();\n    })\n    .then(() => {\n      return this.runAfterFindTrigger();\n    })\n    .then(() => {\n      return this.response;\n    });\n};\n\nRestQuery.prototype.each = function (callback) {\n  const { config, auth, className, restWhere, restOptions, clientSDK } = this;\n  // if the limit is set, use it\n  restOptions.limit = restOptions.limit || 100;\n  restOptions.order = 'objectId';\n  let finished = false;\n\n  return continueWhile(\n    () => {\n      return !finished;\n    },\n    async () => {\n      const query = new RestQuery(config, auth, className, restWhere, restOptions, clientSDK);\n      const { results } = await query.execute();\n      results.forEach(callback);\n      finished = results.length < restOptions.limit;\n      if (!finished) {\n        restWhere.objectId = Object.assign({}, restWhere.objectId, {\n          $gt: results[results.length - 1].objectId,\n        });\n      }\n    }\n  );\n};\n\nRestQuery.prototype.buildRestWhere = function () {\n  return Promise.resolve()\n    .then(() => {\n      return this.getUserAndRoleACL();\n    })\n    .then(() => {\n      return this.redirectClassNameForKey();\n    })\n    .then(() => {\n      return this.validateClientClassCreation();\n    })\n    .then(() => {\n      return this.replaceSelect();\n    })\n    .then(() => {\n      return this.replaceDontSelect();\n    })\n    .then(() => {\n      return this.replaceInQuery();\n    })\n    .then(() => {\n      return this.replaceNotInQuery();\n    })\n    .then(() => {\n      return this.replaceEquality();\n    });\n};\n\n// Uses the Auth object to get the list of roles, adds the user id\nRestQuery.prototype.getUserAndRoleACL = function () {\n  if (this.auth.isMaster) {\n    return Promise.resolve();\n  }\n\n  this.findOptions.acl = ['*'];\n\n  if (this.auth.user) {\n    return this.auth.getUserRoles().then(roles => {\n      this.findOptions.acl = this.findOptions.acl.concat(roles, [this.auth.user.id]);\n      return;\n    });\n  } else {\n    return Promise.resolve();\n  }\n};\n\n// Changes the className if redirectClassNameForKey is set.\n// Returns a promise.\nRestQuery.prototype.redirectClassNameForKey = function () {\n  if (!this.redirectKey) {\n    return Promise.resolve();\n  }\n\n  // We need to change the class name based on the schema\n  return this.config.database\n    .redirectClassNameForKey(this.className, this.redirectKey)\n    .then(newClassName => {\n      this.className = newClassName;\n      this.redirectClassName = newClassName;\n    });\n};\n\n// Validates this operation against the allowClientClassCreation config.\nRestQuery.prototype.validateClientClassCreation = function () {\n  if (\n    this.config.allowClientClassCreation === false &&\n    !this.auth.isMaster &&\n    SchemaController.systemClasses.indexOf(this.className) === -1\n  ) {\n    return this.config.database\n      .loadSchema()\n      .then(schemaController => schemaController.hasClass(this.className))\n      .then(hasClass => {\n        if (hasClass !== true) {\n          throw new Parse.Error(\n            Parse.Error.OPERATION_FORBIDDEN,\n            'This user is not allowed to access ' + 'non-existent class: ' + this.className\n          );\n        }\n      });\n  } else {\n    return Promise.resolve();\n  }\n};\n\nfunction transformInQuery(inQueryObject, className, results) {\n  var values = [];\n  for (var result of results) {\n    values.push({\n      __type: 'Pointer',\n      className: className,\n      objectId: result.objectId,\n    });\n  }\n  delete inQueryObject['$inQuery'];\n  if (Array.isArray(inQueryObject['$in'])) {\n    inQueryObject['$in'] = inQueryObject['$in'].concat(values);\n  } else {\n    inQueryObject['$in'] = values;\n  }\n}\n\n// Replaces a $inQuery clause by running the subquery, if there is an\n// $inQuery clause.\n// The $inQuery clause turns into an $in with values that are just\n// pointers to the objects returned in the subquery.\nRestQuery.prototype.replaceInQuery = function () {\n  var inQueryObject = findObjectWithKey(this.restWhere, '$inQuery');\n  if (!inQueryObject) {\n    return;\n  }\n\n  // The inQuery value must have precisely two keys - where and className\n  var inQueryValue = inQueryObject['$inQuery'];\n  if (!inQueryValue.where || !inQueryValue.className) {\n    throw new Parse.Error(Parse.Error.INVALID_QUERY, 'improper usage of $inQuery');\n  }\n\n  const additionalOptions = {\n    redirectClassNameForKey: inQueryValue.redirectClassNameForKey,\n  };\n\n  if (this.restOptions.subqueryReadPreference) {\n    additionalOptions.readPreference = this.restOptions.subqueryReadPreference;\n    additionalOptions.subqueryReadPreference = this.restOptions.subqueryReadPreference;\n  } else if (this.restOptions.readPreference) {\n    additionalOptions.readPreference = this.restOptions.readPreference;\n  }\n\n  var subquery = new RestQuery(\n    this.config,\n    this.auth,\n    inQueryValue.className,\n    inQueryValue.where,\n    additionalOptions\n  );\n  return subquery.execute().then(response => {\n    transformInQuery(inQueryObject, subquery.className, response.results);\n    // Recurse to repeat\n    return this.replaceInQuery();\n  });\n};\n\nfunction transformNotInQuery(notInQueryObject, className, results) {\n  var values = [];\n  for (var result of results) {\n    values.push({\n      __type: 'Pointer',\n      className: className,\n      objectId: result.objectId,\n    });\n  }\n  delete notInQueryObject['$notInQuery'];\n  if (Array.isArray(notInQueryObject['$nin'])) {\n    notInQueryObject['$nin'] = notInQueryObject['$nin'].concat(values);\n  } else {\n    notInQueryObject['$nin'] = values;\n  }\n}\n\n// Replaces a $notInQuery clause by running the subquery, if there is an\n// $notInQuery clause.\n// The $notInQuery clause turns into a $nin with values that are just\n// pointers to the objects returned in the subquery.\nRestQuery.prototype.replaceNotInQuery = function () {\n  var notInQueryObject = findObjectWithKey(this.restWhere, '$notInQuery');\n  if (!notInQueryObject) {\n    return;\n  }\n\n  // The notInQuery value must have precisely two keys - where and className\n  var notInQueryValue = notInQueryObject['$notInQuery'];\n  if (!notInQueryValue.where || !notInQueryValue.className) {\n    throw new Parse.Error(Parse.Error.INVALID_QUERY, 'improper usage of $notInQuery');\n  }\n\n  const additionalOptions = {\n    redirectClassNameForKey: notInQueryValue.redirectClassNameForKey,\n  };\n\n  if (this.restOptions.subqueryReadPreference) {\n    additionalOptions.readPreference = this.restOptions.subqueryReadPreference;\n    additionalOptions.subqueryReadPreference = this.restOptions.subqueryReadPreference;\n  } else if (this.restOptions.readPreference) {\n    additionalOptions.readPreference = this.restOptions.readPreference;\n  }\n\n  var subquery = new RestQuery(\n    this.config,\n    this.auth,\n    notInQueryValue.className,\n    notInQueryValue.where,\n    additionalOptions\n  );\n  return subquery.execute().then(response => {\n    transformNotInQuery(notInQueryObject, subquery.className, response.results);\n    // Recurse to repeat\n    return this.replaceNotInQuery();\n  });\n};\n\n// Used to get the deepest object from json using dot notation.\nconst getDeepestObjectFromKey = (json, key, idx, src) => {\n  if (key in json) {\n    return json[key];\n  }\n  src.splice(1); // Exit Early\n};\n\nconst transformSelect = (selectObject, key, objects) => {\n  var values = [];\n  for (var result of objects) {\n    values.push(key.split('.').reduce(getDeepestObjectFromKey, result));\n  }\n  delete selectObject['$select'];\n  if (Array.isArray(selectObject['$in'])) {\n    selectObject['$in'] = selectObject['$in'].concat(values);\n  } else {\n    selectObject['$in'] = values;\n  }\n};\n\n// Replaces a $select clause by running the subquery, if there is a\n// $select clause.\n// The $select clause turns into an $in with values selected out of\n// the subquery.\n// Returns a possible-promise.\nRestQuery.prototype.replaceSelect = function () {\n  var selectObject = findObjectWithKey(this.restWhere, '$select');\n  if (!selectObject) {\n    return;\n  }\n\n  // The select value must have precisely two keys - query and key\n  var selectValue = selectObject['$select'];\n  // iOS SDK don't send where if not set, let it pass\n  if (\n    !selectValue.query ||\n    !selectValue.key ||\n    typeof selectValue.query !== 'object' ||\n    !selectValue.query.className ||\n    Object.keys(selectValue).length !== 2\n  ) {\n    throw new Parse.Error(Parse.Error.INVALID_QUERY, 'improper usage of $select');\n  }\n\n  const additionalOptions = {\n    redirectClassNameForKey: selectValue.query.redirectClassNameForKey,\n  };\n\n  if (this.restOptions.subqueryReadPreference) {\n    additionalOptions.readPreference = this.restOptions.subqueryReadPreference;\n    additionalOptions.subqueryReadPreference = this.restOptions.subqueryReadPreference;\n  } else if (this.restOptions.readPreference) {\n    additionalOptions.readPreference = this.restOptions.readPreference;\n  }\n\n  var subquery = new RestQuery(\n    this.config,\n    this.auth,\n    selectValue.query.className,\n    selectValue.query.where,\n    additionalOptions\n  );\n  return subquery.execute().then(response => {\n    transformSelect(selectObject, selectValue.key, response.results);\n    // Keep replacing $select clauses\n    return this.replaceSelect();\n  });\n};\n\nconst transformDontSelect = (dontSelectObject, key, objects) => {\n  var values = [];\n  for (var result of objects) {\n    values.push(key.split('.').reduce(getDeepestObjectFromKey, result));\n  }\n  delete dontSelectObject['$dontSelect'];\n  if (Array.isArray(dontSelectObject['$nin'])) {\n    dontSelectObject['$nin'] = dontSelectObject['$nin'].concat(values);\n  } else {\n    dontSelectObject['$nin'] = values;\n  }\n};\n\n// Replaces a $dontSelect clause by running the subquery, if there is a\n// $dontSelect clause.\n// The $dontSelect clause turns into an $nin with values selected out of\n// the subquery.\n// Returns a possible-promise.\nRestQuery.prototype.replaceDontSelect = function () {\n  var dontSelectObject = findObjectWithKey(this.restWhere, '$dontSelect');\n  if (!dontSelectObject) {\n    return;\n  }\n\n  // The dontSelect value must have precisely two keys - query and key\n  var dontSelectValue = dontSelectObject['$dontSelect'];\n  if (\n    !dontSelectValue.query ||\n    !dontSelectValue.key ||\n    typeof dontSelectValue.query !== 'object' ||\n    !dontSelectValue.query.className ||\n    Object.keys(dontSelectValue).length !== 2\n  ) {\n    throw new Parse.Error(Parse.Error.INVALID_QUERY, 'improper usage of $dontSelect');\n  }\n  const additionalOptions = {\n    redirectClassNameForKey: dontSelectValue.query.redirectClassNameForKey,\n  };\n\n  if (this.restOptions.subqueryReadPreference) {\n    additionalOptions.readPreference = this.restOptions.subqueryReadPreference;\n    additionalOptions.subqueryReadPreference = this.restOptions.subqueryReadPreference;\n  } else if (this.restOptions.readPreference) {\n    additionalOptions.readPreference = this.restOptions.readPreference;\n  }\n\n  var subquery = new RestQuery(\n    this.config,\n    this.auth,\n    dontSelectValue.query.className,\n    dontSelectValue.query.where,\n    additionalOptions\n  );\n  return subquery.execute().then(response => {\n    transformDontSelect(dontSelectObject, dontSelectValue.key, response.results);\n    // Keep replacing $dontSelect clauses\n    return this.replaceDontSelect();\n  });\n};\n\nconst cleanResultAuthData = function (result) {\n  delete result.password;\n  if (result.authData) {\n    Object.keys(result.authData).forEach(provider => {\n      if (result.authData[provider] === null) {\n        delete result.authData[provider];\n      }\n    });\n\n    if (Object.keys(result.authData).length == 0) {\n      delete result.authData;\n    }\n  }\n};\n\nconst replaceEqualityConstraint = constraint => {\n  if (typeof constraint !== 'object') {\n    return constraint;\n  }\n  const equalToObject = {};\n  let hasDirectConstraint = false;\n  let hasOperatorConstraint = false;\n  for (const key in constraint) {\n    if (key.indexOf('$') !== 0) {\n      hasDirectConstraint = true;\n      equalToObject[key] = constraint[key];\n    } else {\n      hasOperatorConstraint = true;\n    }\n  }\n  if (hasDirectConstraint && hasOperatorConstraint) {\n    constraint['$eq'] = equalToObject;\n    Object.keys(equalToObject).forEach(key => {\n      delete constraint[key];\n    });\n  }\n  return constraint;\n};\n\nRestQuery.prototype.replaceEquality = function () {\n  if (typeof this.restWhere !== 'object') {\n    return;\n  }\n  for (const key in this.restWhere) {\n    this.restWhere[key] = replaceEqualityConstraint(this.restWhere[key]);\n  }\n};\n\n// Returns a promise for whether it was successful.\n// Populates this.response with an object that only has 'results'.\nRestQuery.prototype.runFind = function (options = {}) {\n  if (this.findOptions.limit === 0) {\n    this.response = { results: [] };\n    return Promise.resolve();\n  }\n  const findOptions = Object.assign({}, this.findOptions);\n  if (this.keys) {\n    findOptions.keys = this.keys.map(key => {\n      return key.split('.')[0];\n    });\n  }\n  if (options.op) {\n    findOptions.op = options.op;\n  }\n  return this.config.database\n    .find(this.className, this.restWhere, findOptions, this.auth)\n    .then(results => {\n      if (this.className === '_User' && !findOptions.explain) {\n        for (var result of results) {\n          cleanResultAuthData(result);\n        }\n      }\n\n      this.config.filesController.expandFilesInObject(this.config, results);\n\n      if (this.redirectClassName) {\n        for (var r of results) {\n          r.className = this.redirectClassName;\n        }\n      }\n      this.response = { results: results };\n    });\n};\n\n// Returns a promise for whether it was successful.\n// Populates this.response.count with the count\nRestQuery.prototype.runCount = function () {\n  if (!this.doCount) {\n    return;\n  }\n  this.findOptions.count = true;\n  delete this.findOptions.skip;\n  delete this.findOptions.limit;\n  return this.config.database.find(this.className, this.restWhere, this.findOptions).then(c => {\n    this.response.count = c;\n  });\n};\n\nRestQuery.prototype.denyProtectedFields = async function () {\n  if (this.auth.isMaster) {\n    return;\n  }\n  const schemaController = await this.config.database.loadSchema();\n  const protectedFields =\n    this.config.database.addProtectedFields(\n      schemaController,\n      this.className,\n      this.restWhere,\n      this.findOptions.acl,\n      this.auth,\n      this.findOptions\n    ) || [];\n  for (const key of protectedFields) {\n    if (this.restWhere[key]) {\n      throw new Parse.Error(\n        Parse.Error.OPERATION_FORBIDDEN,\n        `This user is not allowed to query ${key} on class ${this.className}`\n      );\n    }\n  }\n};\n\n// Augments this.response with all pointers on an object\nRestQuery.prototype.handleIncludeAll = function () {\n  if (!this.includeAll) {\n    return;\n  }\n  return this.config.database\n    .loadSchema()\n    .then(schemaController => schemaController.getOneSchema(this.className))\n    .then(schema => {\n      const includeFields = [];\n      const keyFields = [];\n      for (const field in schema.fields) {\n        if (\n          (schema.fields[field].type && schema.fields[field].type === 'Pointer') ||\n          (schema.fields[field].type && schema.fields[field].type === 'Array')\n        ) {\n          includeFields.push([field]);\n          keyFields.push(field);\n        }\n      }\n      // Add fields to include, keys, remove dups\n      this.include = [...new Set([...this.include, ...includeFields])];\n      // if this.keys not set, then all keys are already included\n      if (this.keys) {\n        this.keys = [...new Set([...this.keys, ...keyFields])];\n      }\n    });\n};\n\n// Updates property `this.keys` to contain all keys but the ones unselected.\nRestQuery.prototype.handleExcludeKeys = function () {\n  if (!this.excludeKeys) {\n    return;\n  }\n  if (this.keys) {\n    this.keys = this.keys.filter(k => !this.excludeKeys.includes(k));\n    return;\n  }\n  return this.config.database\n    .loadSchema()\n    .then(schemaController => schemaController.getOneSchema(this.className))\n    .then(schema => {\n      const fields = Object.keys(schema.fields);\n      this.keys = fields.filter(k => !this.excludeKeys.includes(k));\n    });\n};\n\n// Augments this.response with data at the paths provided in this.include.\nRestQuery.prototype.handleInclude = function () {\n  if (this.include.length == 0) {\n    return;\n  }\n\n  var pathResponse = includePath(\n    this.config,\n    this.auth,\n    this.response,\n    this.include[0],\n    this.restOptions\n  );\n  if (pathResponse.then) {\n    return pathResponse.then(newResponse => {\n      this.response = newResponse;\n      this.include = this.include.slice(1);\n      return this.handleInclude();\n    });\n  } else if (this.include.length > 0) {\n    this.include = this.include.slice(1);\n    return this.handleInclude();\n  }\n\n  return pathResponse;\n};\n\n//Returns a promise of a processed set of results\nRestQuery.prototype.runAfterFindTrigger = function () {\n  if (!this.response) {\n    return;\n  }\n  if (!this.runAfterFind) {\n    return;\n  }\n  // Avoid doing any setup for triggers if there is no 'afterFind' trigger for this class.\n  const hasAfterFindHook = triggers.triggerExists(\n    this.className,\n    triggers.Types.afterFind,\n    this.config.applicationId\n  );\n  if (!hasAfterFindHook) {\n    return Promise.resolve();\n  }\n  // Skip Aggregate and Distinct Queries\n  if (this.findOptions.pipeline || this.findOptions.distinct) {\n    return Promise.resolve();\n  }\n\n  const json = Object.assign({}, this.restOptions);\n  json.where = this.restWhere;\n  const parseQuery = new Parse.Query(this.className);\n  parseQuery.withJSON(json);\n  // Run afterFind trigger and set the new results\n  return triggers\n    .maybeRunAfterFindTrigger(\n      triggers.Types.afterFind,\n      this.auth,\n      this.className,\n      this.response.results,\n      this.config,\n      parseQuery\n    )\n    .then(results => {\n      // Ensure we properly set the className back\n      if (this.redirectClassName) {\n        this.response.results = results.map(object => {\n          if (object instanceof Parse.Object) {\n            object = object.toJSON();\n          }\n          object.className = this.redirectClassName;\n          return object;\n        });\n      } else {\n        this.response.results = results;\n      }\n    });\n};\n\n// Adds included values to the response.\n// Path is a list of field names.\n// Returns a promise for an augmented response.\nfunction includePath(config, auth, response, path, restOptions = {}) {\n  var pointers = findPointers(response.results, path);\n  if (pointers.length == 0) {\n    return response;\n  }\n  const pointersHash = {};\n  for (var pointer of pointers) {\n    if (!pointer) {\n      continue;\n    }\n    const className = pointer.className;\n    // only include the good pointers\n    if (className) {\n      pointersHash[className] = pointersHash[className] || new Set();\n      pointersHash[className].add(pointer.objectId);\n    }\n  }\n  const includeRestOptions = {};\n  if (restOptions.keys) {\n    const keys = new Set(restOptions.keys.split(','));\n    const keySet = Array.from(keys).reduce((set, key) => {\n      const keyPath = key.split('.');\n      let i = 0;\n      for (i; i < path.length; i++) {\n        if (path[i] != keyPath[i]) {\n          return set;\n        }\n      }\n      if (i < keyPath.length) {\n        set.add(keyPath[i]);\n      }\n      return set;\n    }, new Set());\n    if (keySet.size > 0) {\n      includeRestOptions.keys = Array.from(keySet).join(',');\n    }\n  }\n\n  if (restOptions.includeReadPreference) {\n    includeRestOptions.readPreference = restOptions.includeReadPreference;\n    includeRestOptions.includeReadPreference = restOptions.includeReadPreference;\n  } else if (restOptions.readPreference) {\n    includeRestOptions.readPreference = restOptions.readPreference;\n  }\n\n  const queryPromises = Object.keys(pointersHash).map(className => {\n    const objectIds = Array.from(pointersHash[className]);\n    let where;\n    if (objectIds.length === 1) {\n      where = { objectId: objectIds[0] };\n    } else {\n      where = { objectId: { $in: objectIds } };\n    }\n    var query = new RestQuery(config, auth, className, where, includeRestOptions);\n    return query.execute({ op: 'get' }).then(results => {\n      results.className = className;\n      return Promise.resolve(results);\n    });\n  });\n\n  // Get the objects for all these object ids\n  return Promise.all(queryPromises).then(responses => {\n    var replace = responses.reduce((replace, includeResponse) => {\n      for (var obj of includeResponse.results) {\n        obj.__type = 'Object';\n        obj.className = includeResponse.className;\n\n        if (obj.className == '_User' && !auth.isMaster) {\n          delete obj.sessionToken;\n          delete obj.authData;\n        }\n        replace[obj.objectId] = obj;\n      }\n      return replace;\n    }, {});\n\n    var resp = {\n      results: replacePointers(response.results, path, replace),\n    };\n    if (response.count) {\n      resp.count = response.count;\n    }\n    return resp;\n  });\n}\n\n// Object may be a list of REST-format object to find pointers in, or\n// it may be a single object.\n// If the path yields things that aren't pointers, this throws an error.\n// Path is a list of fields to search into.\n// Returns a list of pointers in REST format.\nfunction findPointers(object, path) {\n  if (object instanceof Array) {\n    var answer = [];\n    for (var x of object) {\n      answer = answer.concat(findPointers(x, path));\n    }\n    return answer;\n  }\n\n  if (typeof object !== 'object' || !object) {\n    return [];\n  }\n\n  if (path.length == 0) {\n    if (object === null || object.__type == 'Pointer') {\n      return [object];\n    }\n    return [];\n  }\n\n  var subobject = object[path[0]];\n  if (!subobject) {\n    return [];\n  }\n  return findPointers(subobject, path.slice(1));\n}\n\n// Object may be a list of REST-format objects to replace pointers\n// in, or it may be a single object.\n// Path is a list of fields to search into.\n// replace is a map from object id -> object.\n// Returns something analogous to object, but with the appropriate\n// pointers inflated.\nfunction replacePointers(object, path, replace) {\n  if (object instanceof Array) {\n    return object\n      .map(obj => replacePointers(obj, path, replace))\n      .filter(obj => typeof obj !== 'undefined');\n  }\n\n  if (typeof object !== 'object' || !object) {\n    return object;\n  }\n\n  if (path.length === 0) {\n    if (object && object.__type === 'Pointer') {\n      return replace[object.objectId];\n    }\n    return object;\n  }\n\n  var subobject = object[path[0]];\n  if (!subobject) {\n    return object;\n  }\n  var newsub = replacePointers(subobject, path.slice(1), replace);\n  var answer = {};\n  for (var key in object) {\n    if (key == path[0]) {\n      answer[key] = newsub;\n    } else {\n      answer[key] = object[key];\n    }\n  }\n  return answer;\n}\n\n// Finds a subobject that has the given key, if there is one.\n// Returns undefined otherwise.\nfunction findObjectWithKey(root, key) {\n  if (typeof root !== 'object') {\n    return;\n  }\n  if (root instanceof Array) {\n    for (var item of root) {\n      const answer = findObjectWithKey(item, key);\n      if (answer) {\n        return answer;\n      }\n    }\n  }\n  if (root && root[key]) {\n    return root;\n  }\n  for (var subkey in root) {\n    const answer = findObjectWithKey(root[subkey], key);\n    if (answer) {\n      return answer;\n    }\n  }\n}\n\nmodule.exports = RestQuery;\n"], "filenames": [".github/workflows/ci.yml", "spec/RedisCacheAdapter.spec.js", "spec/RestQuery.spec.js", "src/Controllers/DatabaseController.js", "src/RestQuery.js"], "buggy_code_start_loc": [15, 381, 193, 54, 190], "buggy_code_end_loc": [15, 448, 193, 1748, 664], "fixing_code_start_loc": [16, 381, 194, 54, 191], "fixing_code_end_loc": [17, 448, 267, 1746, 692], "type": "NVD-CWE-noinfo", "message": "Parse Server is an open source backend that can be deployed to any infrastructure that can run Node.js. Internal fields (keys used internally by Parse Server, prefixed by `_`) and protected fields (user defined) can be used as query constraints. Internal and protected fields are removed by Parse Server and are only returned to the client using a valid master key. However, using query constraints, these fields can be guessed by enumerating until Parse Server, prior to versions 4.10.14 or 5.2.5, returns a response object. The patch available in versions 4.10.14 and 5.2.5 requires the maser key to use internal and protected fields as query constraints. As a workaround, implement a Parse Cloud Trigger `beforeFind` and manually remove the query constraints.", "other": {"cve": {"id": "CVE-2022-36079", "sourceIdentifier": "security-advisories@github.com", "published": "2022-09-07T21:15:08.560", "lastModified": "2022-09-12T18:26:02.063", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Parse Server is an open source backend that can be deployed to any infrastructure that can run Node.js. Internal fields (keys used internally by Parse Server, prefixed by `_`) and protected fields (user defined) can be used as query constraints. Internal and protected fields are removed by Parse Server and are only returned to the client using a valid master key. However, using query constraints, these fields can be guessed by enumerating until Parse Server, prior to versions 4.10.14 or 5.2.5, returns a response object. The patch available in versions 4.10.14 and 5.2.5 requires the maser key to use internal and protected fields as query constraints. As a workaround, implement a Parse Cloud Trigger `beforeFind` and manually remove the query constraints."}, {"lang": "es", "value": "Parse Server es un backend de c\u00f3digo abierto que puede ser desplegado en cualquier infraestructura que pueda ejecutar Node.js. Los campos internos (claves usadas internamente por Parse Server, prefijadas por \"_\") y los campos protegidos (definidos por el usuario) pueden usarse como restricciones de consulta. Los campos internos y protegidos son eliminados por Parse Server y s\u00f3lo se devuelven al cliente usando una llave maestra v\u00e1lida. Sin embargo, usando las restricciones de consulta, estos campos pueden ser adivinados al enumerar hasta que Parse Server, versiones anteriores a 4.10.14 o 5.2.5, devuelva un objeto de respuesta. El parche disponible en versiones 4.10.14 y 5.2.5, requiere que la llave m\u00e1ser use campos internos y protegidos como restricciones de consulta. Como mitigaci\u00f3n, implemente un Parse Cloud Trigger \"beforeFind\" y elimine manualmente las restricciones de consulta"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 8.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 4.0}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:parseplatform:parse-server:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "4.10.14", "matchCriteriaId": "55B47674-02C1-4BE5-B962-AF328A4F99B5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:parseplatform:parse-server:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "5.0.0", "versionEndExcluding": "5.2.5", "matchCriteriaId": "65395D8C-9056-4F74-B1C4-8CB4723CE12A"}]}]}], "references": [{"url": "https://github.com/parse-community/parse-server/commit/634c44acd18f6ee6ec60fac89a2b602d92799bec", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/parse-community/parse-server/commit/e39d51bd329cd978589983bd659db46e1d45aad4", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/parse-community/parse-server/issues/8143", "source": "security-advisories@github.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/parse-community/parse-server/issues/8144", "source": "security-advisories@github.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/parse-community/parse-server/releases/tag/4.10.14", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/parse-community/parse-server/releases/tag/5.2.5", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/parse-community/parse-server/security/advisories/GHSA-2m6g-crv8-p3c6", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/parse-community/parse-server/commit/634c44acd18f6ee6ec60fac89a2b602d92799bec"}}