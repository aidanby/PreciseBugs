{"buggy_code": ["/*-\n * Copyright (c) 2016 Varnish Software AS\n * All rights reserved.\n *\n * Author: Poul-Henning Kamp <phk@phk.freebsd.dk>\n *\n * SPDX-License-Identifier: BSD-2-Clause\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n *\n */\n\nstruct h2_sess;\nstruct h2_req;\nstruct h2h_decode;\nstruct h2_frame_s;\n\n#include \"hpack/vhp.h\"\n\n/**********************************************************************/\n\nstruct h2_error_s {\n\tconst char\t\t\t*name;\n\tconst char\t\t\t*txt;\n\tuint32_t\t\t\tval;\n\tint\t\t\t\tstream;\n\tint\t\t\t\tconnection;\n};\n\ntypedef const struct h2_error_s *h2_error;\n\n#define H2EC0(U,v,d)\n#define H2EC1(U,v,d) extern const struct h2_error_s H2CE_##U[1];\n#define H2EC2(U,v,d) extern const struct h2_error_s H2SE_##U[1];\n#define H2EC3(U,v,d) H2EC1(U,v,d) H2EC2(U,v,d)\n#define H2_ERROR(NAME, val, sc, desc) H2EC##sc(NAME, val, desc)\n#include \"tbl/h2_error.h\"\n#undef H2EC1\n#undef H2EC2\n#undef H2EC3\n\n/**********************************************************************/\n\ntypedef h2_error h2_rxframe_f(struct worker *, struct h2_sess *,\n    struct h2_req *);\n\ntypedef const struct h2_frame_s *h2_frame;\n\nstruct h2_frame_s {\n\tconst char\t*name;\n\th2_rxframe_f\t*rxfunc;\n\tuint8_t\t\ttype;\n\tuint8_t\t\tflags;\n\th2_error\tact_szero;\n\th2_error\tact_snonzero;\n\th2_error\tact_sidle;\n\tint\t\trespect_window;\n\th2_frame\tcontinuation;\n\tuint8_t\t\tfinal_flags;\n\tint\t\toverhead;\n};\n\n#define H2_FRAME(l,U,...) extern const struct h2_frame_s H2_F_##U[1];\n#include \"tbl/h2_frames.h\"\n\n/**********************************************************************/\n\nstruct h2_settings {\n#define H2_SETTING(U,l,...) uint32_t l;\n#include \"tbl/h2_settings.h\"\n};\n\ntypedef void h2_setsetting_f(struct h2_settings*, uint32_t);\n\nstruct h2_setting_s {\n\tconst char\t*name;\n\th2_setsetting_f\t*setfunc;\n\tuint16_t\tident;\n\tuint32_t\tdefval;\n\tuint32_t\tminval;\n\tuint32_t\tmaxval;\n\th2_error\trange_error;\n};\n\n#define H2_SETTING(U,...) extern const struct h2_setting_s H2_SET_##U[1];\n#include \"tbl/h2_settings.h\"\n\n/**********************************************************************/\n\nenum h2_stream_e {\n\tH2_STREAM__DUMMY = -1,\n#define H2_STREAM(U,s,d) H2_S_##U,\n#include \"tbl/h2_stream.h\"\n};\n\n#define H2_FRAME_FLAGS(l,u,v)   extern const uint8_t H2FF_##u;\n#include \"tbl/h2_frames.h\"\n\nstruct h2_req {\n\tunsigned\t\t\tmagic;\n#define H2_REQ_MAGIC\t\t\t0x03411584\n\tuint32_t\t\t\tstream;\n\tint\t\t\t\tscheduled;\n\tenum h2_stream_e\t\tstate;\n\tint\t\t\t\tcounted;\n\tstruct h2_sess\t\t\t*h2sess;\n\tstruct req\t\t\t*req;\n\tdouble\t\t\t\tt_send;\n\tdouble\t\t\t\tt_winupd;\n\tpthread_cond_t\t\t\t*cond;\n\tVTAILQ_ENTRY(h2_req)\t\tlist;\n\tint64_t\t\t\t\tt_window;\n\tint64_t\t\t\t\tr_window;\n\n\t/* Where to wake this stream up */\n\tstruct worker\t\t\t*wrk;\n\n\tVTAILQ_ENTRY(h2_req)\t\ttx_list;\n\th2_error\t\t\terror;\n};\n\nVTAILQ_HEAD(h2_req_s, h2_req);\n\nstruct h2_sess {\n\tunsigned\t\t\tmagic;\n#define H2_SESS_MAGIC\t\t\t0xa16f7e4b\n\n\tpthread_t\t\t\trxthr;\n\tstruct h2_req\t\t\t*mailcall;\n\tpthread_cond_t\t\t\t*cond;\n\tpthread_cond_t\t\t\twinupd_cond[1];\n\n\tstruct sess\t\t\t*sess;\n\tint\t\t\t\trefcnt;\n\tunsigned\t\t\topen_streams;\n\tuint32_t\t\t\thighest_stream;\n\tint\t\t\t\tbogosity;\n\tint\t\t\t\tdo_sweep;\n\n\tstruct h2_req\t\t\t*req0;\n\n\tstruct h2_req_s\t\t\tstreams;\n\n\tstruct req\t\t\t*srq;\n\tstruct ws\t\t\t*ws;\n\tstruct http_conn\t\t*htc;\n\tstruct vsl_log\t\t\t*vsl;\n\tstruct h2h_decode\t\t*decode;\n\tstruct vht_table\t\tdectbl[1];\n\n\tunsigned\t\t\trxf_len;\n\tunsigned\t\t\trxf_type;\n\tunsigned\t\t\trxf_flags;\n\tunsigned\t\t\trxf_stream;\n\tuint8_t\t\t\t\t*rxf_data;\n\n\tstruct h2_settings\t\tremote_settings;\n\tstruct h2_settings\t\tlocal_settings;\n\n\tstruct req\t\t\t*new_req;\n\tuint32_t\t\t\tgoaway_last_stream;\n\n\tVTAILQ_HEAD(,h2_req)\t\ttxqueue;\n\n\th2_error\t\t\terror;\n};\n\n#define ASSERT_RXTHR(h2) do {assert(h2->rxthr == pthread_self());} while(0)\n\n/* http2/cache_http2_panic.c */\n#ifdef TRANSPORT_MAGIC\nvtr_sess_panic_f h2_sess_panic;\n#endif\n\n/* http2/cache_http2_deliver.c */\n#ifdef TRANSPORT_MAGIC\nvtr_deliver_f h2_deliver;\nvtr_minimal_response_f h2_minimal_response;\n#endif /* TRANSPORT_MAGIC */\n\n/* http2/cache_http2_hpack.c */\nstruct h2h_decode {\n\tunsigned\t\t\tmagic;\n#define H2H_DECODE_MAGIC\t\t0xd092bde4\n\n\th2_error\t\t\terror;\n\tenum vhd_ret_e\t\t\tvhd_ret;\n\tchar\t\t\t\t*out;\n\tchar\t\t\t\t*reset;\n\tsize_t\t\t\t\tout_l;\n\tsize_t\t\t\t\tout_u;\n\tsize_t\t\t\t\tnamelen;\n\tstruct vhd_decode\t\tvhd[1];\n};\n\nvoid h2h_decode_init(const struct h2_sess *h2);\nh2_error h2h_decode_fini(const struct h2_sess *h2);\nh2_error h2h_decode_bytes(struct h2_sess *h2, const uint8_t *ptr,\n    size_t len);\n\n/* cache_http2_send.c */\nvoid H2_Send_Get(struct worker *, struct h2_sess *, struct h2_req *);\nvoid H2_Send_Rel(struct h2_sess *, const struct h2_req *);\n\nvoid H2_Send_Frame(struct worker *, struct h2_sess *,\n    h2_frame type, uint8_t flags, uint32_t len, uint32_t stream,\n    const void *);\n\nvoid H2_Send_RST(struct worker *wrk, struct h2_sess *h2,\n    const struct h2_req *r2, uint32_t stream, h2_error h2e);\n\nvoid H2_Send(struct worker *, struct h2_req *, h2_frame type, uint8_t flags,\n    uint32_t len, const void *, uint64_t *acct);\n\n/* cache_http2_proto.c */\nstruct h2_req * h2_new_req(const struct worker *, struct h2_sess *,\n    unsigned stream, struct req *);\nint h2_stream_tmo(struct h2_sess *, const struct h2_req *, vtim_real);\nvoid h2_del_req(struct worker *, const struct h2_req *);\nvoid h2_kill_req(struct worker *, struct h2_sess *, struct h2_req *, h2_error);\nint h2_rxframe(struct worker *, struct h2_sess *);\nh2_error h2_set_setting(struct h2_sess *, const uint8_t *);\nvoid h2_req_body(struct req*);\ntask_func_t h2_do_req;\n#ifdef TRANSPORT_MAGIC\nvtr_req_fail_f h2_req_fail;\n#endif\n", "/*-\n * Copyright (c) 2016-2019 Varnish Software AS\n * All rights reserved.\n *\n * Author: Poul-Henning Kamp <phk@phk.freebsd.dk>\n *\n * SPDX-License-Identifier: BSD-2-Clause\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n *\n */\n\n#include \"config.h\"\n\n#include \"cache/cache_varnishd.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"cache/cache_transport.h\"\n#include \"cache/cache_filter.h\"\n#include \"http2/cache_http2.h\"\n#include \"cache/cache_objhead.h\"\n\n#include \"vend.h\"\n#include \"vtcp.h\"\n#include \"vtim.h\"\n\n#define H2EC1(U,v,d) const struct h2_error_s H2CE_##U[1] = {{#U,d,v,0,1}};\n#define H2EC2(U,v,d) const struct h2_error_s H2SE_##U[1] = {{#U,d,v,1,0}};\n#define H2EC3(U,v,d) H2EC1(U,v,d) H2EC2(U,v,d)\n#define H2_ERROR(NAME, val, sc, desc) H2EC##sc(NAME, val, desc)\n#include \"tbl/h2_error.h\"\n#undef H2EC1\n#undef H2EC2\n#undef H2EC3\n\nstatic const struct h2_error_s H2NN_ERROR[1] = {{\n\t\"UNKNOWN_ERROR\",\n\t\"Unknown error number\",\n\t0xffffffff,\n\t1,\n\t1\n}};\n\nenum h2frame {\n#define H2_FRAME(l,u,t,f,...)\tH2F_##u = t,\n#include \"tbl/h2_frames.h\"\n};\n\nstatic const char *\nh2_framename(enum h2frame h2f)\n{\n\n\tswitch (h2f) {\n#define H2_FRAME(l,u,t,f,...)\tcase H2F_##u: return #u;\n#include \"tbl/h2_frames.h\"\n\tdefault:\n\t\treturn (NULL);\n\t}\n}\n\n#define H2_FRAME_FLAGS(l,u,v)\tconst uint8_t H2FF_##u = v;\n#include \"tbl/h2_frames.h\"\n\n/**********************************************************************\n */\n\nstatic const h2_error stream_errors[] = {\n#define H2EC1(U,v,d)\n#define H2EC2(U,v,d) [v] = H2SE_##U,\n#define H2EC3(U,v,d) H2EC1(U,v,d) H2EC2(U,v,d)\n#define H2_ERROR(NAME, val, sc, desc) H2EC##sc(NAME, val, desc)\n#include \"tbl/h2_error.h\"\n#undef H2EC1\n#undef H2EC2\n#undef H2EC3\n};\n\n#define NSTREAMERRORS (sizeof(stream_errors)/sizeof(stream_errors[0]))\n\nstatic h2_error\nh2_streamerror(uint32_t u)\n{\n\tif (u < NSTREAMERRORS && stream_errors[u] != NULL)\n\t\treturn (stream_errors[u]);\n\telse\n\t\treturn (H2NN_ERROR);\n}\n\n/**********************************************************************\n */\n\nstatic const h2_error conn_errors[] = {\n#define H2EC1(U,v,d) [v] = H2CE_##U,\n#define H2EC2(U,v,d)\n#define H2EC3(U,v,d) H2EC1(U,v,d) H2EC2(U,v,d)\n#define H2_ERROR(NAME, val, sc, desc) H2EC##sc(NAME, val, desc)\n#include \"tbl/h2_error.h\"\n#undef H2EC1\n#undef H2EC2\n#undef H2EC3\n};\n\n#define NCONNERRORS (sizeof(conn_errors)/sizeof(conn_errors[0]))\n\nstatic h2_error\nh2_connectionerror(uint32_t u)\n{\n\tif (u < NCONNERRORS && conn_errors[u] != NULL)\n\t\treturn (conn_errors[u]);\n\telse\n\t\treturn (H2NN_ERROR);\n}\n\n/**********************************************************************/\n\nstruct h2_req *\nh2_new_req(const struct worker *wrk, struct h2_sess *h2,\n    unsigned stream, struct req *req)\n{\n\tstruct h2_req *r2;\n\n\tASSERT_RXTHR(h2);\n\tif (req == NULL)\n\t\treq = Req_New(wrk, h2->sess);\n\tCHECK_OBJ_NOTNULL(req, REQ_MAGIC);\n\n\tr2 = WS_Alloc(req->ws, sizeof *r2);\n\tAN(r2);\n\tINIT_OBJ(r2, H2_REQ_MAGIC);\n\tr2->state = H2_S_IDLE;\n\tr2->h2sess = h2;\n\tr2->stream = stream;\n\tr2->req = req;\n\tif (stream)\n\t\tr2->counted = 1;\n\tr2->r_window = h2->local_settings.initial_window_size;\n\tr2->t_window = h2->remote_settings.initial_window_size;\n\treq->transport_priv = r2;\n\tLck_Lock(&h2->sess->mtx);\n\tif (stream)\n\t\th2->open_streams++;\n\tVTAILQ_INSERT_TAIL(&h2->streams, r2, list);\n\tLck_Unlock(&h2->sess->mtx);\n\th2->refcnt++;\n\treturn (r2);\n}\n\nvoid\nh2_del_req(struct worker *wrk, const struct h2_req *r2)\n{\n\tstruct h2_sess *h2;\n\tstruct sess *sp;\n\n\tCHECK_OBJ_NOTNULL(r2, H2_REQ_MAGIC);\n\tAZ(r2->scheduled);\n\th2 = r2->h2sess;\n\tCHECK_OBJ_NOTNULL(h2, H2_SESS_MAGIC);\n\tASSERT_RXTHR(h2);\n\tsp = h2->sess;\n\tLck_Lock(&sp->mtx);\n\tassert(h2->refcnt > 0);\n\t--h2->refcnt;\n\t/* XXX: PRIORITY reshuffle */\n\tVTAILQ_REMOVE(&h2->streams, r2, list);\n\tLck_Unlock(&sp->mtx);\n\tassert(!WS_IsReserved(r2->req->ws));\n\tReq_Cleanup(sp, wrk, r2->req);\n\tReq_Release(r2->req);\n}\n\nvoid\nh2_kill_req(struct worker *wrk, struct h2_sess *h2,\n    struct h2_req *r2, h2_error h2e)\n{\n\n\tASSERT_RXTHR(h2);\n\tAN(h2e);\n\tLck_Lock(&h2->sess->mtx);\n\tVSLb(h2->vsl, SLT_Debug, \"KILL st=%u state=%d sched=%d\",\n\t    r2->stream, r2->state, r2->scheduled);\n\tif (r2->counted) {\n\t\tassert(h2->open_streams > 0);\n\t\th2->open_streams--;\n\t\tr2->counted = 0;\n\t}\n\tif (r2->error == NULL)\n\t\tr2->error = h2e;\n\tif (r2->scheduled) {\n\t\tif (r2->cond != NULL)\n\t\t\tAZ(pthread_cond_signal(r2->cond));\n\t\tr2 = NULL;\n\t} else {\n\t\tif (r2->state == H2_S_OPEN && h2->new_req == r2->req)\n\t\t\t(void)h2h_decode_fini(h2);\n\t}\n\tLck_Unlock(&h2->sess->mtx);\n\tif (r2 != NULL)\n\t\th2_del_req(wrk, r2);\n}\n\n/**********************************************************************/\n\nstatic void\nh2_vsl_frame(const struct h2_sess *h2, const void *ptr, size_t len)\n{\n\tconst uint8_t *b;\n\tstruct vsb *vsb;\n\tconst char *p;\n\tunsigned u;\n\n\tAN(ptr);\n\tassert(len >= 9);\n\tb = ptr;\n\n\tvsb = VSB_new_auto();\n\tAN(vsb);\n\tp = h2_framename((enum h2frame)b[3]);\n\tif (p != NULL)\n\t\tVSB_cat(vsb, p);\n\telse\n\t\tVSB_quote(vsb, b + 3, 1, VSB_QUOTE_HEX);\n\n\tu = vbe32dec(b) >> 8;\n\tVSB_printf(vsb, \"[%u] \", u);\n\tVSB_quote(vsb, b + 4, 1, VSB_QUOTE_HEX);\n\tVSB_putc(vsb, ' ');\n\tVSB_quote(vsb, b + 5, 4, VSB_QUOTE_HEX);\n\tif (u > 0) {\n\t\tVSB_putc(vsb, ' ');\n\t\tVSB_quote(vsb, b + 9, len - 9, VSB_QUOTE_HEX);\n\t}\n\tAZ(VSB_finish(vsb));\n\tLck_Lock(&h2->sess->mtx);\n\tVSLb_bin(h2->vsl, SLT_H2RxHdr, 9, b);\n\tif (len > 9)\n\t\tVSLb_bin(h2->vsl, SLT_H2RxBody, len - 9, b + 9);\n\n\tVSLb(h2->vsl, SLT_Debug, \"H2RXF %s\", VSB_data(vsb));\n\tLck_Unlock(&h2->sess->mtx);\n\tVSB_destroy(&vsb);\n}\n\n\n/**********************************************************************\n */\n\nstatic h2_error v_matchproto_(h2_rxframe_f)\nh2_rx_ping(struct worker *wrk, struct h2_sess *h2, struct h2_req *r2)\n{\n\n\tCHECK_OBJ_NOTNULL(wrk, WORKER_MAGIC);\n\tASSERT_RXTHR(h2);\n\tCHECK_OBJ_NOTNULL(r2, H2_REQ_MAGIC);\n\tassert(r2 == h2->req0);\n\n\tif (h2->rxf_len != 8)\t\t\t\t// rfc7540,l,2364,2366\n\t\treturn (H2CE_FRAME_SIZE_ERROR);\n\tAZ(h2->rxf_stream);\t\t\t\t// rfc7540,l,2359,2362\n\tif (h2->rxf_flags != 0)\t\t\t\t// We never send pings\n\t\treturn (H2SE_PROTOCOL_ERROR);\n\tH2_Send_Get(wrk, h2, r2);\n\tH2_Send_Frame(wrk, h2,\n\t    H2_F_PING, H2FF_PING_ACK, 8, 0, h2->rxf_data);\n\tH2_Send_Rel(h2, r2);\n\treturn (0);\n}\n\n/**********************************************************************\n */\n\nstatic h2_error v_matchproto_(h2_rxframe_f)\nh2_rx_push_promise(struct worker *wrk, struct h2_sess *h2, struct h2_req *r2)\n{\n\n\tCHECK_OBJ_NOTNULL(wrk, WORKER_MAGIC);\n\tASSERT_RXTHR(h2);\n\tCHECK_OBJ_ORNULL(r2, H2_REQ_MAGIC);\n\t// rfc7540,l,2262,2267\n\treturn (H2CE_PROTOCOL_ERROR);\n}\n\n/**********************************************************************\n */\n\nstatic h2_error v_matchproto_(h2_rxframe_f)\nh2_rx_rst_stream(struct worker *wrk, struct h2_sess *h2, struct h2_req *r2)\n{\n\n\tCHECK_OBJ_NOTNULL(wrk, WORKER_MAGIC);\n\tASSERT_RXTHR(h2);\n\tCHECK_OBJ_ORNULL(r2, H2_REQ_MAGIC);\n\n\tif (h2->rxf_len != 4)\t\t\t// rfc7540,l,2003,2004\n\t\treturn (H2CE_FRAME_SIZE_ERROR);\n\tif (r2 == NULL)\n\t\treturn (0);\n\th2_kill_req(wrk, h2, r2, h2_streamerror(vbe32dec(h2->rxf_data)));\n\treturn (0);\n}\n\n/**********************************************************************\n */\n\nstatic h2_error v_matchproto_(h2_rxframe_f)\nh2_rx_goaway(struct worker *wrk, struct h2_sess *h2, struct h2_req *r2)\n{\n\n\tCHECK_OBJ_NOTNULL(wrk, WORKER_MAGIC);\n\tASSERT_RXTHR(h2);\n\tCHECK_OBJ_NOTNULL(r2, H2_REQ_MAGIC);\n\tassert(r2 == h2->req0);\n\n\th2->goaway_last_stream = vbe32dec(h2->rxf_data);\n\th2->error = h2_connectionerror(vbe32dec(h2->rxf_data + 4));\n\tLck_Lock(&h2->sess->mtx);\n\tVSLb(h2->vsl, SLT_Debug, \"GOAWAY %s\", h2->error->name);\n\tLck_Unlock(&h2->sess->mtx);\n\treturn (h2->error);\n}\n\n/**********************************************************************\n */\n\nstatic h2_error v_matchproto_(h2_rxframe_f)\nh2_rx_window_update(struct worker *wrk, struct h2_sess *h2, struct h2_req *r2)\n{\n\tuint32_t wu;\n\n\tCHECK_OBJ_NOTNULL(wrk, WORKER_MAGIC);\n\tASSERT_RXTHR(h2);\n\tCHECK_OBJ_ORNULL(r2, H2_REQ_MAGIC);\n\n\tif (h2->rxf_len != 4)\n\t\treturn (H2CE_FRAME_SIZE_ERROR);\n\twu = vbe32dec(h2->rxf_data) & ~(1LU<<31);\n\tif (wu == 0)\n\t\treturn (H2SE_PROTOCOL_ERROR);\n\tif (r2 == NULL)\n\t\treturn (0);\n\tLck_Lock(&h2->sess->mtx);\n\tr2->t_window += wu;\n\tif (r2 == h2->req0)\n\t\tAZ(pthread_cond_broadcast(h2->winupd_cond));\n\telse if (r2->cond != NULL)\n\t\tAZ(pthread_cond_signal(r2->cond));\n\tLck_Unlock(&h2->sess->mtx);\n\tif (r2->t_window >= (1LL << 31))\n\t\treturn (H2SE_FLOW_CONTROL_ERROR);\n\treturn (0);\n}\n\n/**********************************************************************\n * Incoming PRIORITY, possibly an ACK of one we sent.\n */\n\nstatic h2_error v_matchproto_(h2_rxframe_f)\nh2_rx_priority(struct worker *wrk, struct h2_sess *h2, struct h2_req *r2)\n{\n\n\tCHECK_OBJ_NOTNULL(wrk, WORKER_MAGIC);\n\tASSERT_RXTHR(h2);\n\tCHECK_OBJ_ORNULL(r2, H2_REQ_MAGIC);\n\treturn (0);\n}\n\n/**********************************************************************\n * Incoming SETTINGS, possibly an ACK of one we sent.\n */\n\n#define H2_SETTING(U,l, ...)\t\t\t\t\t\\\nstatic void v_matchproto_(h2_setsetting_f)\t\t\t\\\nh2_setting_##l(struct h2_settings* s, uint32_t v)\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\ts -> l = v;\t\t\t\t\t\t\\\n}\n#include <tbl/h2_settings.h>\n\n#define H2_SETTING(U, l, ...)\t\t\t\t\t\\\nconst struct h2_setting_s H2_SET_##U[1] = {{\t\t\t\\\n\t#l,\t\t\t\t\t\t\t\\\n\th2_setting_##l,\t\t\t\t\t\t\\\n\t__VA_ARGS__\t\t\t\t\t\t\\\n}};\n#include <tbl/h2_settings.h>\n\nstatic const struct h2_setting_s * const h2_setting_tbl[] = {\n#define H2_SETTING(U,l,v, ...) [v] = H2_SET_##U,\n#include <tbl/h2_settings.h>\n};\n\n#define H2_SETTING_TBL_LEN (sizeof(h2_setting_tbl)/sizeof(h2_setting_tbl[0]))\n\nstatic void\nh2_win_adjust(const struct h2_sess *h2, uint32_t oldval, uint32_t newval)\n{\n\tstruct h2_req *r2;\n\n\tLck_AssertHeld(&h2->sess->mtx);\n\t// rfc7540,l,2668,2674\n\tVTAILQ_FOREACH(r2, &h2->streams, list) {\n\t\tCHECK_OBJ_NOTNULL(r2, H2_REQ_MAGIC);\n\t\tif (r2 == h2->req0)\n\t\t\tcontinue; // rfc7540,l,2699,2699\n\t\tswitch (r2->state) {\n\t\tcase H2_S_IDLE:\n\t\tcase H2_S_OPEN:\n\t\tcase H2_S_CLOS_REM:\n\t\t\t/*\n\t\t\t * We allow a window to go negative, as per\n\t\t\t * rfc7540,l,2676,2680\n\t\t\t */\n\t\t\tr2->t_window += (int64_t)newval - oldval;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nh2_error\nh2_set_setting(struct h2_sess *h2, const uint8_t *d)\n{\n\tconst struct h2_setting_s *s;\n\tuint16_t x;\n\tuint32_t y;\n\n\tx = vbe16dec(d);\n\ty = vbe32dec(d + 2);\n\tif (x >= H2_SETTING_TBL_LEN || h2_setting_tbl[x] == NULL) {\n\t\t// rfc7540,l,2181,2182\n\t\tLck_Lock(&h2->sess->mtx);\n\t\tVSLb(h2->vsl, SLT_Debug,\n\t\t    \"H2SETTING unknown setting 0x%04x=%08x (ignored)\", x, y);\n\t\tLck_Unlock(&h2->sess->mtx);\n\t\treturn (0);\n\t}\n\ts = h2_setting_tbl[x];\n\tAN(s);\n\tif (y < s->minval || y > s->maxval) {\n\t\tLck_Lock(&h2->sess->mtx);\n\t\tVSLb(h2->vsl, SLT_Debug, \"H2SETTING invalid %s=0x%08x\",\n\t\t    s->name, y);\n\t\tLck_Unlock(&h2->sess->mtx);\n\t\tAN(s->range_error);\n\t\tif (!DO_DEBUG(DBG_H2_NOCHECK))\n\t\t\treturn (s->range_error);\n\t}\n\tLck_Lock(&h2->sess->mtx);\n\tif (s == H2_SET_INITIAL_WINDOW_SIZE)\n\t\th2_win_adjust(h2, h2->remote_settings.initial_window_size, y);\n\tVSLb(h2->vsl, SLT_Debug, \"H2SETTING %s=0x%08x\", s->name, y);\n\tLck_Unlock(&h2->sess->mtx);\n\tAN(s->setfunc);\n\ts->setfunc(&h2->remote_settings, y);\n\treturn (0);\n}\n\nstatic h2_error v_matchproto_(h2_rxframe_f)\nh2_rx_settings(struct worker *wrk, struct h2_sess *h2, struct h2_req *r2)\n{\n\tconst uint8_t *p;\n\tunsigned l;\n\th2_error retval = 0;\n\n\tCHECK_OBJ_NOTNULL(wrk, WORKER_MAGIC);\n\tASSERT_RXTHR(h2);\n\tCHECK_OBJ_NOTNULL(r2, H2_REQ_MAGIC);\n\tassert(r2 == h2->req0);\n\tAZ(h2->rxf_stream);\n\n\tif (h2->rxf_flags == H2FF_SETTINGS_ACK) {\n\t\tif (h2->rxf_len > 0)\t\t\t// rfc7540,l,2047,2049\n\t\t\treturn (H2CE_FRAME_SIZE_ERROR);\n\t\treturn (0);\n\t} else {\n\t\tif (h2->rxf_len % 6)\t\t\t// rfc7540,l,2062,2064\n\t\t\treturn (H2CE_PROTOCOL_ERROR);\n\t\tp = h2->rxf_data;\n\t\tfor (l = h2->rxf_len; l >= 6; l -= 6, p += 6) {\n\t\t\tretval = h2_set_setting(h2, p);\n\t\t\tif (retval)\n\t\t\t\treturn (retval);\n\t\t}\n\t\tH2_Send_Get(wrk, h2, r2);\n\t\tH2_Send_Frame(wrk, h2,\n\t\t    H2_F_SETTINGS, H2FF_SETTINGS_ACK, 0, 0, NULL);\n\t\tH2_Send_Rel(h2, r2);\n\t}\n\treturn (0);\n}\n\n/**********************************************************************\n * Incoming HEADERS, this is where the partys at...\n */\n\nvoid v_matchproto_(task_func_t)\nh2_do_req(struct worker *wrk, void *priv)\n{\n\tstruct req *req;\n\tstruct h2_req *r2;\n\tstruct h2_sess *h2;\n\n\tCAST_OBJ_NOTNULL(req, priv, REQ_MAGIC);\n\tCAST_OBJ_NOTNULL(r2, req->transport_priv, H2_REQ_MAGIC);\n\tTHR_SetRequest(req);\n\tCNT_Embark(wrk, req);\n\tif (req->req_step == R_STP_TRANSPORT) {\n\t\tVCL_TaskEnter(req->privs);\n\t\tVCL_TaskEnter(req->top->privs);\n\t}\n\n\twrk->stats->client_req++;\n\tif (CNT_Request(req) != REQ_FSM_DISEMBARK) {\n\t\tassert(!WS_IsReserved(req->ws));\n\t\tAZ(req->top->vcl0);\n\t\th2 = r2->h2sess;\n\t\tCHECK_OBJ_NOTNULL(h2, H2_SESS_MAGIC);\n\t\tLck_Lock(&h2->sess->mtx);\n\t\tr2->scheduled = 0;\n\t\tr2->state = H2_S_CLOSED;\n\t\tr2->h2sess->do_sweep = 1;\n\t\tif (h2->mailcall == r2) {\n\t\t\th2->mailcall = NULL;\n\t\t\tAZ(pthread_cond_signal(h2->cond));\n\t\t}\n\t\tLck_Unlock(&h2->sess->mtx);\n\t}\n\tTHR_SetRequest(NULL);\n}\n\nstatic h2_error\nh2_end_headers(struct worker *wrk, struct h2_sess *h2,\n    struct req *req, struct h2_req *r2)\n{\n\th2_error h2e;\n\n\tASSERT_RXTHR(h2);\n\tassert(r2->state == H2_S_OPEN);\n\th2e = h2h_decode_fini(h2);\n\th2->new_req = NULL;\n\tif (h2e != NULL) {\n\t\tLck_Lock(&h2->sess->mtx);\n\t\tVSLb(h2->vsl, SLT_Debug, \"HPACK/FINI %s\", h2e->name);\n\t\tLck_Unlock(&h2->sess->mtx);\n\t\tassert(!WS_IsReserved(r2->req->ws));\n\t\th2_del_req(wrk, r2);\n\t\treturn (h2e);\n\t}\n\tVSLb_ts_req(req, \"Req\", req->t_req);\n\n\t// XXX: Smarter to do this already at HPACK time into tail end of\n\t// XXX: WS, then copy back once all headers received.\n\t// XXX: Have I mentioned H/2 Is hodge-podge ?\n\thttp_CollectHdrSep(req->http, H_Cookie, \"; \");\t// rfc7540,l,3114,3120\n\n\tif (req->req_body_status == NULL) {\n\t\tif (!http_GetHdr(req->http, H_Content_Length, NULL))\n\t\t\treq->req_body_status = BS_EOF;\n\t\telse\n\t\t\treq->req_body_status = BS_LENGTH;\n\t} else {\n\t\t/* A HEADER frame contained END_STREAM */\n\t\tassert (req->req_body_status == BS_NONE);\n\t\tr2->state = H2_S_CLOS_REM;\n\t\tif (http_GetContentLength(req->http) > 0)\n\t\t\treturn (H2CE_PROTOCOL_ERROR); //rfc7540,l,1838,1840\n\t}\n\n\tif (req->http->hd[HTTP_HDR_METHOD].b == NULL) {\n\t\tVSLb(h2->vsl, SLT_Debug, \"Missing :method\");\n\t\treturn (H2SE_PROTOCOL_ERROR); //rfc7540,l,3087,3090\n\t}\n\tif (req->http->hd[HTTP_HDR_URL].b == NULL) {\n\t\tVSLb(h2->vsl, SLT_Debug, \"Missing :path\");\n\t\treturn (H2SE_PROTOCOL_ERROR); //rfc7540,l,3087,3090\n\t}\n\tAN(req->http->hd[HTTP_HDR_PROTO].b);\n\n\treq->req_step = R_STP_TRANSPORT;\n\treq->task->func = h2_do_req;\n\treq->task->priv = req;\n\tr2->scheduled = 1;\n\tif (Pool_Task(wrk->pool, req->task, TASK_QUEUE_STR) != 0) {\n\t\tr2->scheduled = 0;\n\t\tr2->state = H2_S_CLOSED;\n\t\treturn (H2SE_REFUSED_STREAM); //rfc7540,l,3326,3329\n\t}\n\treturn (0);\n}\n\nstatic h2_error v_matchproto_(h2_rxframe_f)\nh2_rx_headers(struct worker *wrk, struct h2_sess *h2, struct h2_req *r2)\n{\n\tstruct req *req;\n\th2_error h2e;\n\tconst uint8_t *p;\n\tsize_t l;\n\n\tCHECK_OBJ_NOTNULL(wrk, WORKER_MAGIC);\n\tASSERT_RXTHR(h2);\n\n\tif (r2 == NULL) {\n\t\tif (h2->rxf_stream <= h2->highest_stream)\n\t\t\treturn (H2CE_PROTOCOL_ERROR);\t// rfc7540,l,1153,1158\n\t\t/* NB: we don't need to guard the read of h2->open_streams\n\t\t * because headers are handled sequentially so it cannot\n\t\t * increase under our feet.\n\t\t */\n\t\tif (h2->open_streams >=\n\t\t    h2->local_settings.max_concurrent_streams) {\n\t\t\tVSLb(h2->vsl, SLT_Debug,\n\t\t\t     \"H2: stream %u: Hit maximum number of \"\n\t\t\t     \"concurrent streams\", h2->rxf_stream);\n\t\t\treturn (H2SE_REFUSED_STREAM);\t// rfc7540,l,1200,1205\n\t\t}\n\t\th2->highest_stream = h2->rxf_stream;\n\t\tr2 = h2_new_req(wrk, h2, h2->rxf_stream, NULL);\n\t}\n\tCHECK_OBJ_NOTNULL(r2, H2_REQ_MAGIC);\n\n\tif (r2->state != H2_S_IDLE)\n\t\treturn (H2CE_PROTOCOL_ERROR);\t// XXX spec ?\n\tr2->state = H2_S_OPEN;\n\n\treq = r2->req;\n\tCHECK_OBJ_NOTNULL(req, REQ_MAGIC);\n\n\treq->vsl->wid = VXID_Get(wrk, VSL_CLIENTMARKER);\n\tVSLb(req->vsl, SLT_Begin, \"req %u rxreq\", VXID(req->sp->vxid));\n\tVSL(SLT_Link, req->sp->vxid, \"req %u rxreq\", VXID(req->vsl->wid));\n\n\th2->new_req = req;\n\treq->sp = h2->sess;\n\treq->transport = &H2_transport;\n\n\treq->t_first = VTIM_real();\n\treq->t_req = VTIM_real();\n\treq->t_prev = req->t_first;\n\tVSLb_ts_req(req, \"Start\", req->t_first);\n\treq->acct.req_hdrbytes += h2->rxf_len;\n\n\tHTTP_Setup(req->http, req->ws, req->vsl, SLT_ReqMethod);\n\thttp_SetH(req->http, HTTP_HDR_PROTO, \"HTTP/2.0\");\n\n\th2h_decode_init(h2);\n\n\tp = h2->rxf_data;\n\tl = h2->rxf_len;\n\tif (h2->rxf_flags & H2FF_HEADERS_PADDED) {\n\t\tif (*p + 1 > l)\n\t\t\treturn (H2CE_PROTOCOL_ERROR);\t// rfc7540,l,1884,1887\n\t\tl -= 1 + *p;\n\t\tp += 1;\n\t}\n\tif (h2->rxf_flags & H2FF_HEADERS_PRIORITY) {\n\t\tif (l < 5)\n\t\t\treturn (H2CE_PROTOCOL_ERROR);\n\t\tl -= 5;\n\t\tp += 5;\n\t}\n\th2e = h2h_decode_bytes(h2, p, l);\n\tif (h2e != NULL) {\n\t\tLck_Lock(&h2->sess->mtx);\n\t\tVSLb(h2->vsl, SLT_Debug, \"HPACK(hdr) %s\", h2e->name);\n\t\tLck_Unlock(&h2->sess->mtx);\n\t\t(void)h2h_decode_fini(h2);\n\t\tassert(!WS_IsReserved(r2->req->ws));\n\t\th2_del_req(wrk, r2);\n\t\treturn (h2e);\n\t}\n\n\tif (h2->rxf_flags & H2FF_HEADERS_END_STREAM)\n\t\treq->req_body_status = BS_NONE;\n\n\tif (h2->rxf_flags & H2FF_HEADERS_END_HEADERS)\n\t\treturn (h2_end_headers(wrk, h2, req, r2));\n\treturn (0);\n}\n\n/**********************************************************************/\n\nstatic h2_error v_matchproto_(h2_rxframe_f)\nh2_rx_continuation(struct worker *wrk, struct h2_sess *h2, struct h2_req *r2)\n{\n\tstruct req *req;\n\th2_error h2e;\n\n\tCHECK_OBJ_NOTNULL(wrk, WORKER_MAGIC);\n\tASSERT_RXTHR(h2);\n\tCHECK_OBJ_ORNULL(r2, H2_REQ_MAGIC);\n\n\tif (r2 == NULL || r2->state != H2_S_OPEN || r2->req != h2->new_req)\n\t\treturn (H2CE_PROTOCOL_ERROR);\t// XXX spec ?\n\treq = r2->req;\n\th2e = h2h_decode_bytes(h2, h2->rxf_data, h2->rxf_len);\n\tr2->req->acct.req_hdrbytes += h2->rxf_len;\n\tif (h2e != NULL) {\n\t\tLck_Lock(&h2->sess->mtx);\n\t\tVSLb(h2->vsl, SLT_Debug, \"HPACK(cont) %s\", h2e->name);\n\t\tLck_Unlock(&h2->sess->mtx);\n\t\t(void)h2h_decode_fini(h2);\n\t\tassert(!WS_IsReserved(r2->req->ws));\n\t\th2_del_req(wrk, r2);\n\t\treturn (h2e);\n\t}\n\tif (h2->rxf_flags & H2FF_HEADERS_END_HEADERS)\n\t\treturn (h2_end_headers(wrk, h2, req, r2));\n\treturn (0);\n}\n\n/**********************************************************************/\n\nstatic h2_error v_matchproto_(h2_rxframe_f)\nh2_rx_data(struct worker *wrk, struct h2_sess *h2, struct h2_req *r2)\n{\n\tint w1 = 0, w2 = 0;\n\tchar buf[4];\n\tunsigned wi;\n\n\tCHECK_OBJ_NOTNULL(wrk, WORKER_MAGIC);\n\tASSERT_RXTHR(h2);\n\tCHECK_OBJ_ORNULL(r2, H2_REQ_MAGIC);\n\n\tif (r2 == NULL || !r2->scheduled)\n\t\treturn (0);\n\tif (r2->state >= H2_S_CLOS_REM) {\n\t\tr2->error = H2SE_STREAM_CLOSED;\n\t\treturn (H2SE_STREAM_CLOSED); // rfc7540,l,1766,1769\n\t}\n\tLck_Lock(&h2->sess->mtx);\n\twhile (h2->mailcall != NULL && h2->error == 0 && r2->error == 0)\n\t\tAZ(Lck_CondWait(h2->cond, &h2->sess->mtx, 0));\n\tif (h2->error || r2->error) {\n\t\tLck_Unlock(&h2->sess->mtx);\n\t\treturn (h2->error ? h2->error : r2->error);\n\t}\n\tAZ(h2->mailcall);\n\th2->mailcall = r2;\n\th2->req0->r_window -= h2->rxf_len;\n\tr2->r_window -= h2->rxf_len;\n\t// req_bodybytes accounted in CNT code.\n\tif (r2->cond)\n\t\tAZ(pthread_cond_signal(r2->cond));\n\twhile (h2->mailcall != NULL && h2->error == 0 && r2->error == 0)\n\t\tAZ(Lck_CondWait(h2->cond, &h2->sess->mtx, 0));\n\twi = cache_param->h2_rx_window_increment;\n\tif (h2->req0->r_window < cache_param->h2_rx_window_low_water) {\n\t\th2->req0->r_window += wi;\n\t\tw1 = 1;\n\t}\n\tif (r2->r_window < cache_param->h2_rx_window_low_water) {\n\t\tr2->r_window += wi;\n\t\tw2 = 1;\n\t}\n\tLck_Unlock(&h2->sess->mtx);\n\n\tif (w1 || w2) {\n\t\tvbe32enc(buf, wi);\n\t\tH2_Send_Get(wrk, h2, h2->req0);\n\t\tif (w1)\n\t\t\tH2_Send_Frame(wrk, h2, H2_F_WINDOW_UPDATE, 0,\n\t\t\t    4, 0, buf);\n\t\tif (w2)\n\t\t\tH2_Send_Frame(wrk, h2, H2_F_WINDOW_UPDATE, 0,\n\t\t\t    4, r2->stream, buf);\n\t\tH2_Send_Rel(h2, h2->req0);\n\t}\n\treturn (0);\n}\n\nstatic enum vfp_status v_matchproto_(vfp_pull_f)\nh2_vfp_body(struct vfp_ctx *vc, struct vfp_entry *vfe, void *ptr, ssize_t *lp)\n{\n\tstruct h2_req *r2;\n\tstruct h2_sess *h2;\n\tunsigned l;\n\tenum vfp_status retval = VFP_OK;\n\n\tCHECK_OBJ_NOTNULL(vc, VFP_CTX_MAGIC);\n\tCHECK_OBJ_NOTNULL(vfe, VFP_ENTRY_MAGIC);\n\tCAST_OBJ_NOTNULL(r2, vfe->priv1, H2_REQ_MAGIC);\n\th2 = r2->h2sess;\n\n\tAN(ptr);\n\tAN(lp);\n\tl = *lp;\n\t*lp = 0;\n\n\tLck_Lock(&h2->sess->mtx);\n\tassert (r2->state == H2_S_OPEN);\n\tr2->cond = &vc->wrk->cond;\n\twhile (h2->mailcall != r2 && h2->error == 0 && r2->error == 0)\n\t\tAZ(Lck_CondWait(r2->cond, &h2->sess->mtx, 0));\n\tr2->cond = NULL;\n\tif (h2->error || r2->error) {\n\t\tretval = VFP_ERROR;\n\t} else {\n\t\tassert(h2->mailcall == r2);\n\t\tif (l > h2->rxf_len)\n\t\t\tl = h2->rxf_len;\n\t\tif (l > 0) {\n\t\t\tmemcpy(ptr, h2->rxf_data, l);\n\t\t\th2->rxf_data += l;\n\t\t\th2->rxf_len -= l;\n\t\t}\n\t\t*lp = l;\n\t\tif (h2->rxf_len > 0) {\n\t\t\t/* We ran out of storage: Have VFP call us\n\t\t\t * again with a fresh buffer */\n\t\t\tLck_Unlock(&h2->sess->mtx);\n\t\t\treturn (VFP_OK);\n\t\t}\n\t\tif (h2->rxf_len == 0) {\n\t\t\tif (h2->rxf_flags & H2FF_DATA_END_STREAM) {\n\t\t\t\tretval = VFP_END;\n\t\t\t\tr2->state = H2_S_CLOS_REM;\n\t\t\t}\n\t\t}\n\t\th2->mailcall = NULL;\n\t\tAZ(pthread_cond_signal(h2->cond));\n\t}\n\tLck_Unlock(&h2->sess->mtx);\n\treturn (retval);\n}\n\nstatic void\nh2_vfp_body_fini(struct vfp_ctx *vc, struct vfp_entry *vfe)\n{\n\tstruct h2_req *r2;\n\tstruct h2_sess *h2;\n\n\tCHECK_OBJ_NOTNULL(vc, VFP_CTX_MAGIC);\n\tCHECK_OBJ_NOTNULL(vfe, VFP_ENTRY_MAGIC);\n\tCAST_OBJ_NOTNULL(r2, vfe->priv1, H2_REQ_MAGIC);\n\tCHECK_OBJ_NOTNULL(r2->req, REQ_MAGIC);\n\th2 = r2->h2sess;\n\n\tif (vc->failed) {\n\t\tCHECK_OBJ_NOTNULL(r2->req->wrk, WORKER_MAGIC);\n\t\tH2_Send_Get(r2->req->wrk, h2, r2);\n\t\tH2_Send_RST(r2->req->wrk, h2, r2, r2->stream,\n\t\t    H2SE_REFUSED_STREAM);\n\t\tH2_Send_Rel(h2, r2);\n\t\tLck_Lock(&h2->sess->mtx);\n\t\tr2->error = H2SE_REFUSED_STREAM;\n\t\tif (h2->mailcall == r2) {\n\t\t\th2->mailcall = NULL;\n\t\t\tAZ(pthread_cond_signal(h2->cond));\n\t\t}\n\t\tLck_Unlock(&h2->sess->mtx);\n\t}\n}\n\nstatic const struct vfp h2_body = {\n\t.name = \"H2_BODY\",\n\t.pull = h2_vfp_body,\n\t.fini = h2_vfp_body_fini\n};\n\nvoid v_matchproto_(vtr_req_body_t)\nh2_req_body(struct req *req)\n{\n\tstruct h2_req *r2;\n\tstruct vfp_entry *vfe;\n\n\tCHECK_OBJ(req, REQ_MAGIC);\n\tCAST_OBJ_NOTNULL(r2, req->transport_priv, H2_REQ_MAGIC);\n\tvfe = VFP_Push(req->vfc, &h2_body);\n\tAN(vfe);\n\tvfe->priv1 = r2;\n}\n\n/**********************************************************************/\n\nvoid v_matchproto_(vtr_req_fail_f)\nh2_req_fail(struct req *req, enum sess_close reason)\n{\n\tassert(reason > 0);\n\tassert(req->sp->fd != 0);\n\tVSLb(req->vsl, SLT_Debug, \"H2FAILREQ\");\n}\n\n/**********************************************************************/\n\nstatic enum htc_status_e v_matchproto_(htc_complete_f)\nh2_frame_complete(struct http_conn *htc)\n{\n\tstruct h2_sess *h2;\n\n\tCHECK_OBJ_NOTNULL(htc, HTTP_CONN_MAGIC);\n\tCAST_OBJ_NOTNULL(h2, htc->priv, H2_SESS_MAGIC);\n\tif (htc->rxbuf_b + 9 > htc->rxbuf_e ||\n\t    htc->rxbuf_b + 9 + (vbe32dec(htc->rxbuf_b) >> 8) > htc->rxbuf_e)\n\t\treturn (HTC_S_MORE);\n\treturn (HTC_S_COMPLETE);\n}\n\n/**********************************************************************/\n\nstatic h2_error\nh2_procframe(struct worker *wrk, struct h2_sess *h2, h2_frame h2f)\n{\n\tstruct h2_req *r2;\n\th2_error h2e;\n\n\tASSERT_RXTHR(h2);\n\tif (h2->rxf_stream == 0 && h2f->act_szero != 0)\n\t\treturn (h2f->act_szero);\n\n\tif (h2->rxf_stream != 0 && h2f->act_snonzero != 0)\n\t\treturn (h2f->act_snonzero);\n\n\tif (h2->rxf_stream > h2->highest_stream && h2f->act_sidle != 0)\n\t\treturn (h2f->act_sidle);\n\n\tif (h2->rxf_stream != 0 && !(h2->rxf_stream & 1)) {\n\t\t// rfc7540,l,1140,1145\n\t\t// rfc7540,l,1153,1158\n\t\t/* No even streams, we don't do PUSH_PROMISE */\n\t\tLck_Lock(&h2->sess->mtx);\n\t\tVSLb(h2->vsl, SLT_Debug, \"H2: illegal stream (=%u)\",\n\t\t    h2->rxf_stream);\n\t\tLck_Unlock(&h2->sess->mtx);\n\t\treturn (H2CE_PROTOCOL_ERROR);\n\t}\n\n\tVTAILQ_FOREACH(r2, &h2->streams, list)\n\t\tif (r2->stream == h2->rxf_stream)\n\t\t\tbreak;\n\n\tif (h2->new_req != NULL &&\n\t    !(r2 && h2->new_req == r2->req && h2f == H2_F_CONTINUATION))\n\t\treturn (H2CE_PROTOCOL_ERROR);\t// rfc7540,l,1859,1863\n\n\th2e = h2f->rxfunc(wrk, h2, r2);\n\tif (h2e == 0)\n\t\treturn (0);\n\tif (h2->rxf_stream == 0 || h2e->connection)\n\t\treturn (h2e);\t// Connection errors one level up\n\n\tH2_Send_Get(wrk, h2, h2->req0);\n\tH2_Send_RST(wrk, h2, h2->req0, h2->rxf_stream, h2e);\n\tH2_Send_Rel(h2, h2->req0);\n\treturn (0);\n}\n\nint\nh2_stream_tmo(struct h2_sess *h2, const struct h2_req *r2, vtim_real now)\n{\n\tint r = 0;\n\n\tCHECK_OBJ_NOTNULL(h2, H2_SESS_MAGIC);\n\tCHECK_OBJ_NOTNULL(r2, H2_REQ_MAGIC);\n\tLck_AssertHeld(&h2->sess->mtx);\n\n\t/* NB: when now is NAN, it means that idle_send_timeout was hit\n\t * on a lock condwait operation.\n\t */\n\tif (isnan(now))\n\t\tAN(r2->t_winupd);\n\n\tif (r2->t_winupd == 0 && r2->t_send == 0)\n\t\treturn (0);\n\n\tif (isnan(now) || (r2->t_winupd != 0 &&\n\t    now - r2->t_winupd > SESS_TMO(h2->sess, idle_send_timeout))) {\n\t\tVSLb(h2->vsl, SLT_Debug,\n\t\t     \"H2: stream %u: Hit idle_send_timeout waiting for\"\n\t\t     \" WINDOW_UPDATE\", r2->stream);\n\t\tr = 1;\n\t}\n\n\tif (r == 0 && r2->t_send != 0 &&\n\t    now - r2->t_send > SESS_TMO(h2->sess, send_timeout)) {\n\t\tVSLb(h2->vsl, SLT_Debug,\n\t\t     \"H2: stream %u: Hit send_timeout\", r2->stream);\n\t\tr = 1;\n\t}\n\n\treturn (r);\n}\n\nstatic int\nh2_stream_tmo_unlocked(struct h2_sess *h2, const struct h2_req *r2)\n{\n\tint r;\n\n\tLck_Lock(&h2->sess->mtx);\n\tr = h2_stream_tmo(h2, r2, h2->sess->t_idle);\n\tLck_Unlock(&h2->sess->mtx);\n\n\treturn (r);\n}\n\n/*\n * This is the janitorial task of cleaning up any closed & refused\n * streams, and checking if the session is timed out.\n */\nstatic int\nh2_sweep(struct worker *wrk, struct h2_sess *h2)\n{\n\tint tmo = 0;\n\tstruct h2_req *r2, *r22;\n\n\tASSERT_RXTHR(h2);\n\n\th2->do_sweep = 0;\n\tVTAILQ_FOREACH_SAFE(r2, &h2->streams, list, r22) {\n\t\tif (r2 == h2->req0) {\n\t\t\tassert (r2->state == H2_S_IDLE);\n\t\t\tcontinue;\n\t\t}\n\t\tswitch (r2->state) {\n\t\tcase H2_S_CLOSED:\n\t\t\tif (!r2->scheduled)\n\t\t\t\th2_del_req(wrk, r2);\n\t\t\tbreak;\n\t\tcase H2_S_CLOS_REM:\n\t\t\tif (!r2->scheduled) {\n\t\t\t\tH2_Send_Get(wrk, h2, h2->req0);\n\t\t\t\tH2_Send_RST(wrk, h2, h2->req0, r2->stream,\n\t\t\t\t    H2SE_REFUSED_STREAM);\n\t\t\t\tH2_Send_Rel(h2, h2->req0);\n\t\t\t\th2_del_req(wrk, r2);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* FALLTHROUGH */\n\t\tcase H2_S_CLOS_LOC:\n\t\tcase H2_S_OPEN:\n\t\t\tif (h2_stream_tmo_unlocked(h2, r2)) {\n\t\t\t\ttmo = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase H2_S_IDLE:\n\t\t\t/* Current code make this unreachable: h2_new_req is\n\t\t\t * only called inside h2_rx_headers, which immediately\n\t\t\t * sets the new stream state to H2_S_OPEN */\n\t\t\t/* FALLTHROUGH */\n\t\tdefault:\n\t\t\tWRONG(\"Wrong h2 stream state\");\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (tmo)\n\t\treturn (0);\n\treturn (h2->refcnt > 1);\n}\n\n\n/***********************************************************************\n * Called in loop from h2_new_session()\n */\n\n#define H2_FRAME(l,U,...) const struct h2_frame_s H2_F_##U[1] = \\\n    {{ #U, h2_rx_##l, __VA_ARGS__ }};\n#include \"tbl/h2_frames.h\"\n\nstatic const h2_frame h2flist[] = {\n#define H2_FRAME(l,U,t,...) [t] = H2_F_##U,\n#include \"tbl/h2_frames.h\"\n};\n\n#define H2FMAX (sizeof(h2flist) / sizeof(h2flist[0]))\n\nint\nh2_rxframe(struct worker *wrk, struct h2_sess *h2)\n{\n\tenum htc_status_e hs;\n\th2_frame h2f;\n\th2_error h2e;\n\tchar b[8];\n\n\tASSERT_RXTHR(h2);\n\tVTCP_blocking(*h2->htc->rfd);\n\th2->sess->t_idle = VTIM_real();\n\ths = HTC_RxStuff(h2->htc, h2_frame_complete,\n\t    NULL, NULL, NAN,\n\t    h2->sess->t_idle + SESS_TMO(h2->sess, timeout_idle),\n\t    NAN, h2->local_settings.max_frame_size + 9);\n\tswitch (hs) {\n\tcase HTC_S_COMPLETE:\n\t\tbreak;\n\tcase HTC_S_TIMEOUT:\n\t\tif (h2_sweep(wrk, h2))\n\t\t\treturn (1);\n\n\t\t/* FALLTHROUGH */\n\tdefault:\n\t\t/* XXX: HTC_S_OVERFLOW / FRAME_SIZE_ERROR handling */\n\t\tLck_Lock(&h2->sess->mtx);\n\t\tVSLb(h2->vsl, SLT_Debug, \"H2: No frame (hs=%d)\", hs);\n\t\th2->error = H2CE_NO_ERROR;\n\t\tLck_Unlock(&h2->sess->mtx);\n\t\treturn (0);\n\t}\n\n\tif (h2->do_sweep)\n\t\t(void)h2_sweep(wrk, h2);\n\n\th2->rxf_len =  vbe32dec(h2->htc->rxbuf_b) >> 8;\n\th2->rxf_type =  h2->htc->rxbuf_b[3];\n\th2->rxf_flags = h2->htc->rxbuf_b[4];\n\th2->rxf_stream = vbe32dec(h2->htc->rxbuf_b + 5);\n\th2->rxf_stream &= ~(1LU<<31);\t\t\t// rfc7540,l,690,692\n\th2->rxf_data = (void*)(h2->htc->rxbuf_b + 9);\n\t/* XXX: later full DATA will not be rx'ed yet. */\n\tHTC_RxPipeline(h2->htc, h2->htc->rxbuf_b + h2->rxf_len + 9);\n\n\th2_vsl_frame(h2, h2->htc->rxbuf_b, 9L + h2->rxf_len);\n\th2->srq->acct.req_hdrbytes += 9;\n\n\tif (h2->rxf_type >= H2FMAX) {\n\t\t// rfc7540,l,679,681\n\t\t// XXX: later, drain rest of frame\n\t\th2->bogosity++;\n\t\tLck_Lock(&h2->sess->mtx);\n\t\tVSLb(h2->vsl, SLT_Debug,\n\t\t    \"H2: Unknown frame type 0x%02x (ignored)\",\n\t\t    (uint8_t)h2->rxf_type);\n\t\tLck_Unlock(&h2->sess->mtx);\n\t\th2->srq->acct.req_bodybytes += h2->rxf_len;\n\t\treturn (1);\n\t}\n\th2f = h2flist[h2->rxf_type];\n\n\tAN(h2f->name);\n\tAN(h2f->rxfunc);\n\tif (h2f->overhead)\n\t\th2->srq->acct.req_bodybytes += h2->rxf_len;\n\n\tif (h2->rxf_flags & ~h2f->flags) {\n\t\t// rfc7540,l,687,688\n\t\th2->bogosity++;\n\t\tLck_Lock(&h2->sess->mtx);\n\t\tVSLb(h2->vsl, SLT_Debug,\n\t\t    \"H2: Unknown flags 0x%02x on %s (ignored)\",\n\t\t    (uint8_t)h2->rxf_flags & ~h2f->flags, h2f->name);\n\t\tLck_Unlock(&h2->sess->mtx);\n\t\th2->rxf_flags &= h2f->flags;\n\t}\n\n\th2e = h2_procframe(wrk, h2, h2f);\n\tif (h2->error == 0 && h2e) {\n\t\th2->error = h2e;\n\t\tvbe32enc(b, h2->highest_stream);\n\t\tvbe32enc(b + 4, h2e->val);\n\t\tH2_Send_Get(wrk, h2, h2->req0);\n\t\tH2_Send_Frame(wrk, h2, H2_F_GOAWAY, 0, 8, 0, b);\n\t\tH2_Send_Rel(h2, h2->req0);\n\t}\n\treturn (h2->error ? 0 : 1);\n}\n"], "fixing_code": ["/*-\n * Copyright (c) 2016 Varnish Software AS\n * All rights reserved.\n *\n * Author: Poul-Henning Kamp <phk@phk.freebsd.dk>\n *\n * SPDX-License-Identifier: BSD-2-Clause\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n *\n */\n\nstruct h2_sess;\nstruct h2_req;\nstruct h2h_decode;\nstruct h2_frame_s;\n\n#include \"hpack/vhp.h\"\n\n/**********************************************************************/\n\nstruct h2_error_s {\n\tconst char\t\t\t*name;\n\tconst char\t\t\t*txt;\n\tuint32_t\t\t\tval;\n\tint\t\t\t\tstream;\n\tint\t\t\t\tconnection;\n};\n\ntypedef const struct h2_error_s *h2_error;\n\n#define H2EC0(U,v,d)\n#define H2EC1(U,v,d) extern const struct h2_error_s H2CE_##U[1];\n#define H2EC2(U,v,d) extern const struct h2_error_s H2SE_##U[1];\n#define H2EC3(U,v,d) H2EC1(U,v,d) H2EC2(U,v,d)\n#define H2_ERROR(NAME, val, sc, desc) H2EC##sc(NAME, val, desc)\n#include \"tbl/h2_error.h\"\n#undef H2EC1\n#undef H2EC2\n#undef H2EC3\n\n/**********************************************************************/\n\ntypedef h2_error h2_rxframe_f(struct worker *, struct h2_sess *,\n    struct h2_req *);\n\ntypedef const struct h2_frame_s *h2_frame;\n\nstruct h2_frame_s {\n\tconst char\t*name;\n\th2_rxframe_f\t*rxfunc;\n\tuint8_t\t\ttype;\n\tuint8_t\t\tflags;\n\th2_error\tact_szero;\n\th2_error\tact_snonzero;\n\th2_error\tact_sidle;\n\tint\t\trespect_window;\n\th2_frame\tcontinuation;\n\tuint8_t\t\tfinal_flags;\n\tint\t\toverhead;\n};\n\n#define H2_FRAME(l,U,...) extern const struct h2_frame_s H2_F_##U[1];\n#include \"tbl/h2_frames.h\"\n\n/**********************************************************************/\n\nstruct h2_settings {\n#define H2_SETTING(U,l,...) uint32_t l;\n#include \"tbl/h2_settings.h\"\n};\n\ntypedef void h2_setsetting_f(struct h2_settings*, uint32_t);\n\nstruct h2_setting_s {\n\tconst char\t*name;\n\th2_setsetting_f\t*setfunc;\n\tuint16_t\tident;\n\tuint32_t\tdefval;\n\tuint32_t\tminval;\n\tuint32_t\tmaxval;\n\th2_error\trange_error;\n};\n\n#define H2_SETTING(U,...) extern const struct h2_setting_s H2_SET_##U[1];\n#include \"tbl/h2_settings.h\"\n\n/**********************************************************************/\n\nenum h2_stream_e {\n\tH2_STREAM__DUMMY = -1,\n#define H2_STREAM(U,s,d) H2_S_##U,\n#include \"tbl/h2_stream.h\"\n};\n\n#define H2_FRAME_FLAGS(l,u,v)   extern const uint8_t H2FF_##u;\n#include \"tbl/h2_frames.h\"\n\nstruct h2_req {\n\tunsigned\t\t\tmagic;\n#define H2_REQ_MAGIC\t\t\t0x03411584\n\tuint32_t\t\t\tstream;\n\tint\t\t\t\tscheduled;\n\tenum h2_stream_e\t\tstate;\n\tint\t\t\t\tcounted;\n\tstruct h2_sess\t\t\t*h2sess;\n\tstruct req\t\t\t*req;\n\tdouble\t\t\t\tt_send;\n\tdouble\t\t\t\tt_winupd;\n\tpthread_cond_t\t\t\t*cond;\n\tVTAILQ_ENTRY(h2_req)\t\tlist;\n\tint64_t\t\t\t\tt_window;\n\tint64_t\t\t\t\tr_window;\n\n\t/* Where to wake this stream up */\n\tstruct worker\t\t\t*wrk;\n\n\tssize_t\t\t\t\treqbody_bytes;\n\n\tVTAILQ_ENTRY(h2_req)\t\ttx_list;\n\th2_error\t\t\terror;\n};\n\nVTAILQ_HEAD(h2_req_s, h2_req);\n\nstruct h2_sess {\n\tunsigned\t\t\tmagic;\n#define H2_SESS_MAGIC\t\t\t0xa16f7e4b\n\n\tpthread_t\t\t\trxthr;\n\tstruct h2_req\t\t\t*mailcall;\n\tpthread_cond_t\t\t\t*cond;\n\tpthread_cond_t\t\t\twinupd_cond[1];\n\n\tstruct sess\t\t\t*sess;\n\tint\t\t\t\trefcnt;\n\tunsigned\t\t\topen_streams;\n\tuint32_t\t\t\thighest_stream;\n\tint\t\t\t\tbogosity;\n\tint\t\t\t\tdo_sweep;\n\n\tstruct h2_req\t\t\t*req0;\n\n\tstruct h2_req_s\t\t\tstreams;\n\n\tstruct req\t\t\t*srq;\n\tstruct ws\t\t\t*ws;\n\tstruct http_conn\t\t*htc;\n\tstruct vsl_log\t\t\t*vsl;\n\tstruct h2h_decode\t\t*decode;\n\tstruct vht_table\t\tdectbl[1];\n\n\tunsigned\t\t\trxf_len;\n\tunsigned\t\t\trxf_type;\n\tunsigned\t\t\trxf_flags;\n\tunsigned\t\t\trxf_stream;\n\tuint8_t\t\t\t\t*rxf_data;\n\n\tstruct h2_settings\t\tremote_settings;\n\tstruct h2_settings\t\tlocal_settings;\n\n\tstruct req\t\t\t*new_req;\n\tuint32_t\t\t\tgoaway_last_stream;\n\n\tVTAILQ_HEAD(,h2_req)\t\ttxqueue;\n\n\th2_error\t\t\terror;\n};\n\n#define ASSERT_RXTHR(h2) do {assert(h2->rxthr == pthread_self());} while(0)\n\n/* http2/cache_http2_panic.c */\n#ifdef TRANSPORT_MAGIC\nvtr_sess_panic_f h2_sess_panic;\n#endif\n\n/* http2/cache_http2_deliver.c */\n#ifdef TRANSPORT_MAGIC\nvtr_deliver_f h2_deliver;\nvtr_minimal_response_f h2_minimal_response;\n#endif /* TRANSPORT_MAGIC */\n\n/* http2/cache_http2_hpack.c */\nstruct h2h_decode {\n\tunsigned\t\t\tmagic;\n#define H2H_DECODE_MAGIC\t\t0xd092bde4\n\n\th2_error\t\t\terror;\n\tenum vhd_ret_e\t\t\tvhd_ret;\n\tchar\t\t\t\t*out;\n\tchar\t\t\t\t*reset;\n\tsize_t\t\t\t\tout_l;\n\tsize_t\t\t\t\tout_u;\n\tsize_t\t\t\t\tnamelen;\n\tstruct vhd_decode\t\tvhd[1];\n};\n\nvoid h2h_decode_init(const struct h2_sess *h2);\nh2_error h2h_decode_fini(const struct h2_sess *h2);\nh2_error h2h_decode_bytes(struct h2_sess *h2, const uint8_t *ptr,\n    size_t len);\n\n/* cache_http2_send.c */\nvoid H2_Send_Get(struct worker *, struct h2_sess *, struct h2_req *);\nvoid H2_Send_Rel(struct h2_sess *, const struct h2_req *);\n\nvoid H2_Send_Frame(struct worker *, struct h2_sess *,\n    h2_frame type, uint8_t flags, uint32_t len, uint32_t stream,\n    const void *);\n\nvoid H2_Send_RST(struct worker *wrk, struct h2_sess *h2,\n    const struct h2_req *r2, uint32_t stream, h2_error h2e);\n\nvoid H2_Send(struct worker *, struct h2_req *, h2_frame type, uint8_t flags,\n    uint32_t len, const void *, uint64_t *acct);\n\n/* cache_http2_proto.c */\nstruct h2_req * h2_new_req(const struct worker *, struct h2_sess *,\n    unsigned stream, struct req *);\nint h2_stream_tmo(struct h2_sess *, const struct h2_req *, vtim_real);\nvoid h2_del_req(struct worker *, const struct h2_req *);\nvoid h2_kill_req(struct worker *, struct h2_sess *, struct h2_req *, h2_error);\nint h2_rxframe(struct worker *, struct h2_sess *);\nh2_error h2_set_setting(struct h2_sess *, const uint8_t *);\nvoid h2_req_body(struct req*);\ntask_func_t h2_do_req;\n#ifdef TRANSPORT_MAGIC\nvtr_req_fail_f h2_req_fail;\n#endif\n", "/*-\n * Copyright (c) 2016-2019 Varnish Software AS\n * All rights reserved.\n *\n * Author: Poul-Henning Kamp <phk@phk.freebsd.dk>\n *\n * SPDX-License-Identifier: BSD-2-Clause\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n *\n */\n\n#include \"config.h\"\n\n#include \"cache/cache_varnishd.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"cache/cache_transport.h\"\n#include \"cache/cache_filter.h\"\n#include \"http2/cache_http2.h\"\n#include \"cache/cache_objhead.h\"\n\n#include \"vend.h\"\n#include \"vtcp.h\"\n#include \"vtim.h\"\n\n#define H2EC1(U,v,d) const struct h2_error_s H2CE_##U[1] = {{#U,d,v,0,1}};\n#define H2EC2(U,v,d) const struct h2_error_s H2SE_##U[1] = {{#U,d,v,1,0}};\n#define H2EC3(U,v,d) H2EC1(U,v,d) H2EC2(U,v,d)\n#define H2_ERROR(NAME, val, sc, desc) H2EC##sc(NAME, val, desc)\n#include \"tbl/h2_error.h\"\n#undef H2EC1\n#undef H2EC2\n#undef H2EC3\n\nstatic const struct h2_error_s H2NN_ERROR[1] = {{\n\t\"UNKNOWN_ERROR\",\n\t\"Unknown error number\",\n\t0xffffffff,\n\t1,\n\t1\n}};\n\nenum h2frame {\n#define H2_FRAME(l,u,t,f,...)\tH2F_##u = t,\n#include \"tbl/h2_frames.h\"\n};\n\nstatic const char *\nh2_framename(enum h2frame h2f)\n{\n\n\tswitch (h2f) {\n#define H2_FRAME(l,u,t,f,...)\tcase H2F_##u: return #u;\n#include \"tbl/h2_frames.h\"\n\tdefault:\n\t\treturn (NULL);\n\t}\n}\n\n#define H2_FRAME_FLAGS(l,u,v)\tconst uint8_t H2FF_##u = v;\n#include \"tbl/h2_frames.h\"\n\n/**********************************************************************\n */\n\nstatic const h2_error stream_errors[] = {\n#define H2EC1(U,v,d)\n#define H2EC2(U,v,d) [v] = H2SE_##U,\n#define H2EC3(U,v,d) H2EC1(U,v,d) H2EC2(U,v,d)\n#define H2_ERROR(NAME, val, sc, desc) H2EC##sc(NAME, val, desc)\n#include \"tbl/h2_error.h\"\n#undef H2EC1\n#undef H2EC2\n#undef H2EC3\n};\n\n#define NSTREAMERRORS (sizeof(stream_errors)/sizeof(stream_errors[0]))\n\nstatic h2_error\nh2_streamerror(uint32_t u)\n{\n\tif (u < NSTREAMERRORS && stream_errors[u] != NULL)\n\t\treturn (stream_errors[u]);\n\telse\n\t\treturn (H2NN_ERROR);\n}\n\n/**********************************************************************\n */\n\nstatic const h2_error conn_errors[] = {\n#define H2EC1(U,v,d) [v] = H2CE_##U,\n#define H2EC2(U,v,d)\n#define H2EC3(U,v,d) H2EC1(U,v,d) H2EC2(U,v,d)\n#define H2_ERROR(NAME, val, sc, desc) H2EC##sc(NAME, val, desc)\n#include \"tbl/h2_error.h\"\n#undef H2EC1\n#undef H2EC2\n#undef H2EC3\n};\n\n#define NCONNERRORS (sizeof(conn_errors)/sizeof(conn_errors[0]))\n\nstatic h2_error\nh2_connectionerror(uint32_t u)\n{\n\tif (u < NCONNERRORS && conn_errors[u] != NULL)\n\t\treturn (conn_errors[u]);\n\telse\n\t\treturn (H2NN_ERROR);\n}\n\n/**********************************************************************/\n\nstruct h2_req *\nh2_new_req(const struct worker *wrk, struct h2_sess *h2,\n    unsigned stream, struct req *req)\n{\n\tstruct h2_req *r2;\n\n\tASSERT_RXTHR(h2);\n\tif (req == NULL)\n\t\treq = Req_New(wrk, h2->sess);\n\tCHECK_OBJ_NOTNULL(req, REQ_MAGIC);\n\n\tr2 = WS_Alloc(req->ws, sizeof *r2);\n\tAN(r2);\n\tINIT_OBJ(r2, H2_REQ_MAGIC);\n\tr2->state = H2_S_IDLE;\n\tr2->h2sess = h2;\n\tr2->stream = stream;\n\tr2->req = req;\n\tif (stream)\n\t\tr2->counted = 1;\n\tr2->r_window = h2->local_settings.initial_window_size;\n\tr2->t_window = h2->remote_settings.initial_window_size;\n\treq->transport_priv = r2;\n\tLck_Lock(&h2->sess->mtx);\n\tif (stream)\n\t\th2->open_streams++;\n\tVTAILQ_INSERT_TAIL(&h2->streams, r2, list);\n\tLck_Unlock(&h2->sess->mtx);\n\th2->refcnt++;\n\treturn (r2);\n}\n\nvoid\nh2_del_req(struct worker *wrk, const struct h2_req *r2)\n{\n\tstruct h2_sess *h2;\n\tstruct sess *sp;\n\n\tCHECK_OBJ_NOTNULL(r2, H2_REQ_MAGIC);\n\tAZ(r2->scheduled);\n\th2 = r2->h2sess;\n\tCHECK_OBJ_NOTNULL(h2, H2_SESS_MAGIC);\n\tASSERT_RXTHR(h2);\n\tsp = h2->sess;\n\tLck_Lock(&sp->mtx);\n\tassert(h2->refcnt > 0);\n\t--h2->refcnt;\n\t/* XXX: PRIORITY reshuffle */\n\tVTAILQ_REMOVE(&h2->streams, r2, list);\n\tLck_Unlock(&sp->mtx);\n\tassert(!WS_IsReserved(r2->req->ws));\n\tReq_Cleanup(sp, wrk, r2->req);\n\tReq_Release(r2->req);\n}\n\nvoid\nh2_kill_req(struct worker *wrk, struct h2_sess *h2,\n    struct h2_req *r2, h2_error h2e)\n{\n\n\tASSERT_RXTHR(h2);\n\tAN(h2e);\n\tLck_Lock(&h2->sess->mtx);\n\tVSLb(h2->vsl, SLT_Debug, \"KILL st=%u state=%d sched=%d\",\n\t    r2->stream, r2->state, r2->scheduled);\n\tif (r2->counted) {\n\t\tassert(h2->open_streams > 0);\n\t\th2->open_streams--;\n\t\tr2->counted = 0;\n\t}\n\tif (r2->error == NULL)\n\t\tr2->error = h2e;\n\tif (r2->scheduled) {\n\t\tif (r2->cond != NULL)\n\t\t\tAZ(pthread_cond_signal(r2->cond));\n\t\tr2 = NULL;\n\t} else {\n\t\tif (r2->state == H2_S_OPEN && h2->new_req == r2->req)\n\t\t\t(void)h2h_decode_fini(h2);\n\t}\n\tLck_Unlock(&h2->sess->mtx);\n\tif (r2 != NULL)\n\t\th2_del_req(wrk, r2);\n}\n\n/**********************************************************************/\n\nstatic void\nh2_vsl_frame(const struct h2_sess *h2, const void *ptr, size_t len)\n{\n\tconst uint8_t *b;\n\tstruct vsb *vsb;\n\tconst char *p;\n\tunsigned u;\n\n\tAN(ptr);\n\tassert(len >= 9);\n\tb = ptr;\n\n\tvsb = VSB_new_auto();\n\tAN(vsb);\n\tp = h2_framename((enum h2frame)b[3]);\n\tif (p != NULL)\n\t\tVSB_cat(vsb, p);\n\telse\n\t\tVSB_quote(vsb, b + 3, 1, VSB_QUOTE_HEX);\n\n\tu = vbe32dec(b) >> 8;\n\tVSB_printf(vsb, \"[%u] \", u);\n\tVSB_quote(vsb, b + 4, 1, VSB_QUOTE_HEX);\n\tVSB_putc(vsb, ' ');\n\tVSB_quote(vsb, b + 5, 4, VSB_QUOTE_HEX);\n\tif (u > 0) {\n\t\tVSB_putc(vsb, ' ');\n\t\tVSB_quote(vsb, b + 9, len - 9, VSB_QUOTE_HEX);\n\t}\n\tAZ(VSB_finish(vsb));\n\tLck_Lock(&h2->sess->mtx);\n\tVSLb_bin(h2->vsl, SLT_H2RxHdr, 9, b);\n\tif (len > 9)\n\t\tVSLb_bin(h2->vsl, SLT_H2RxBody, len - 9, b + 9);\n\n\tVSLb(h2->vsl, SLT_Debug, \"H2RXF %s\", VSB_data(vsb));\n\tLck_Unlock(&h2->sess->mtx);\n\tVSB_destroy(&vsb);\n}\n\n\n/**********************************************************************\n */\n\nstatic h2_error v_matchproto_(h2_rxframe_f)\nh2_rx_ping(struct worker *wrk, struct h2_sess *h2, struct h2_req *r2)\n{\n\n\tCHECK_OBJ_NOTNULL(wrk, WORKER_MAGIC);\n\tASSERT_RXTHR(h2);\n\tCHECK_OBJ_NOTNULL(r2, H2_REQ_MAGIC);\n\tassert(r2 == h2->req0);\n\n\tif (h2->rxf_len != 8)\t\t\t\t// rfc7540,l,2364,2366\n\t\treturn (H2CE_FRAME_SIZE_ERROR);\n\tAZ(h2->rxf_stream);\t\t\t\t// rfc7540,l,2359,2362\n\tif (h2->rxf_flags != 0)\t\t\t\t// We never send pings\n\t\treturn (H2SE_PROTOCOL_ERROR);\n\tH2_Send_Get(wrk, h2, r2);\n\tH2_Send_Frame(wrk, h2,\n\t    H2_F_PING, H2FF_PING_ACK, 8, 0, h2->rxf_data);\n\tH2_Send_Rel(h2, r2);\n\treturn (0);\n}\n\n/**********************************************************************\n */\n\nstatic h2_error v_matchproto_(h2_rxframe_f)\nh2_rx_push_promise(struct worker *wrk, struct h2_sess *h2, struct h2_req *r2)\n{\n\n\tCHECK_OBJ_NOTNULL(wrk, WORKER_MAGIC);\n\tASSERT_RXTHR(h2);\n\tCHECK_OBJ_ORNULL(r2, H2_REQ_MAGIC);\n\t// rfc7540,l,2262,2267\n\treturn (H2CE_PROTOCOL_ERROR);\n}\n\n/**********************************************************************\n */\n\nstatic h2_error v_matchproto_(h2_rxframe_f)\nh2_rx_rst_stream(struct worker *wrk, struct h2_sess *h2, struct h2_req *r2)\n{\n\n\tCHECK_OBJ_NOTNULL(wrk, WORKER_MAGIC);\n\tASSERT_RXTHR(h2);\n\tCHECK_OBJ_ORNULL(r2, H2_REQ_MAGIC);\n\n\tif (h2->rxf_len != 4)\t\t\t// rfc7540,l,2003,2004\n\t\treturn (H2CE_FRAME_SIZE_ERROR);\n\tif (r2 == NULL)\n\t\treturn (0);\n\th2_kill_req(wrk, h2, r2, h2_streamerror(vbe32dec(h2->rxf_data)));\n\treturn (0);\n}\n\n/**********************************************************************\n */\n\nstatic h2_error v_matchproto_(h2_rxframe_f)\nh2_rx_goaway(struct worker *wrk, struct h2_sess *h2, struct h2_req *r2)\n{\n\n\tCHECK_OBJ_NOTNULL(wrk, WORKER_MAGIC);\n\tASSERT_RXTHR(h2);\n\tCHECK_OBJ_NOTNULL(r2, H2_REQ_MAGIC);\n\tassert(r2 == h2->req0);\n\n\th2->goaway_last_stream = vbe32dec(h2->rxf_data);\n\th2->error = h2_connectionerror(vbe32dec(h2->rxf_data + 4));\n\tLck_Lock(&h2->sess->mtx);\n\tVSLb(h2->vsl, SLT_Debug, \"GOAWAY %s\", h2->error->name);\n\tLck_Unlock(&h2->sess->mtx);\n\treturn (h2->error);\n}\n\n/**********************************************************************\n */\n\nstatic h2_error v_matchproto_(h2_rxframe_f)\nh2_rx_window_update(struct worker *wrk, struct h2_sess *h2, struct h2_req *r2)\n{\n\tuint32_t wu;\n\n\tCHECK_OBJ_NOTNULL(wrk, WORKER_MAGIC);\n\tASSERT_RXTHR(h2);\n\tCHECK_OBJ_ORNULL(r2, H2_REQ_MAGIC);\n\n\tif (h2->rxf_len != 4)\n\t\treturn (H2CE_FRAME_SIZE_ERROR);\n\twu = vbe32dec(h2->rxf_data) & ~(1LU<<31);\n\tif (wu == 0)\n\t\treturn (H2SE_PROTOCOL_ERROR);\n\tif (r2 == NULL)\n\t\treturn (0);\n\tLck_Lock(&h2->sess->mtx);\n\tr2->t_window += wu;\n\tif (r2 == h2->req0)\n\t\tAZ(pthread_cond_broadcast(h2->winupd_cond));\n\telse if (r2->cond != NULL)\n\t\tAZ(pthread_cond_signal(r2->cond));\n\tLck_Unlock(&h2->sess->mtx);\n\tif (r2->t_window >= (1LL << 31))\n\t\treturn (H2SE_FLOW_CONTROL_ERROR);\n\treturn (0);\n}\n\n/**********************************************************************\n * Incoming PRIORITY, possibly an ACK of one we sent.\n */\n\nstatic h2_error v_matchproto_(h2_rxframe_f)\nh2_rx_priority(struct worker *wrk, struct h2_sess *h2, struct h2_req *r2)\n{\n\n\tCHECK_OBJ_NOTNULL(wrk, WORKER_MAGIC);\n\tASSERT_RXTHR(h2);\n\tCHECK_OBJ_ORNULL(r2, H2_REQ_MAGIC);\n\treturn (0);\n}\n\n/**********************************************************************\n * Incoming SETTINGS, possibly an ACK of one we sent.\n */\n\n#define H2_SETTING(U,l, ...)\t\t\t\t\t\\\nstatic void v_matchproto_(h2_setsetting_f)\t\t\t\\\nh2_setting_##l(struct h2_settings* s, uint32_t v)\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\ts -> l = v;\t\t\t\t\t\t\\\n}\n#include <tbl/h2_settings.h>\n\n#define H2_SETTING(U, l, ...)\t\t\t\t\t\\\nconst struct h2_setting_s H2_SET_##U[1] = {{\t\t\t\\\n\t#l,\t\t\t\t\t\t\t\\\n\th2_setting_##l,\t\t\t\t\t\t\\\n\t__VA_ARGS__\t\t\t\t\t\t\\\n}};\n#include <tbl/h2_settings.h>\n\nstatic const struct h2_setting_s * const h2_setting_tbl[] = {\n#define H2_SETTING(U,l,v, ...) [v] = H2_SET_##U,\n#include <tbl/h2_settings.h>\n};\n\n#define H2_SETTING_TBL_LEN (sizeof(h2_setting_tbl)/sizeof(h2_setting_tbl[0]))\n\nstatic void\nh2_win_adjust(const struct h2_sess *h2, uint32_t oldval, uint32_t newval)\n{\n\tstruct h2_req *r2;\n\n\tLck_AssertHeld(&h2->sess->mtx);\n\t// rfc7540,l,2668,2674\n\tVTAILQ_FOREACH(r2, &h2->streams, list) {\n\t\tCHECK_OBJ_NOTNULL(r2, H2_REQ_MAGIC);\n\t\tif (r2 == h2->req0)\n\t\t\tcontinue; // rfc7540,l,2699,2699\n\t\tswitch (r2->state) {\n\t\tcase H2_S_IDLE:\n\t\tcase H2_S_OPEN:\n\t\tcase H2_S_CLOS_REM:\n\t\t\t/*\n\t\t\t * We allow a window to go negative, as per\n\t\t\t * rfc7540,l,2676,2680\n\t\t\t */\n\t\t\tr2->t_window += (int64_t)newval - oldval;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nh2_error\nh2_set_setting(struct h2_sess *h2, const uint8_t *d)\n{\n\tconst struct h2_setting_s *s;\n\tuint16_t x;\n\tuint32_t y;\n\n\tx = vbe16dec(d);\n\ty = vbe32dec(d + 2);\n\tif (x >= H2_SETTING_TBL_LEN || h2_setting_tbl[x] == NULL) {\n\t\t// rfc7540,l,2181,2182\n\t\tLck_Lock(&h2->sess->mtx);\n\t\tVSLb(h2->vsl, SLT_Debug,\n\t\t    \"H2SETTING unknown setting 0x%04x=%08x (ignored)\", x, y);\n\t\tLck_Unlock(&h2->sess->mtx);\n\t\treturn (0);\n\t}\n\ts = h2_setting_tbl[x];\n\tAN(s);\n\tif (y < s->minval || y > s->maxval) {\n\t\tLck_Lock(&h2->sess->mtx);\n\t\tVSLb(h2->vsl, SLT_Debug, \"H2SETTING invalid %s=0x%08x\",\n\t\t    s->name, y);\n\t\tLck_Unlock(&h2->sess->mtx);\n\t\tAN(s->range_error);\n\t\tif (!DO_DEBUG(DBG_H2_NOCHECK))\n\t\t\treturn (s->range_error);\n\t}\n\tLck_Lock(&h2->sess->mtx);\n\tif (s == H2_SET_INITIAL_WINDOW_SIZE)\n\t\th2_win_adjust(h2, h2->remote_settings.initial_window_size, y);\n\tVSLb(h2->vsl, SLT_Debug, \"H2SETTING %s=0x%08x\", s->name, y);\n\tLck_Unlock(&h2->sess->mtx);\n\tAN(s->setfunc);\n\ts->setfunc(&h2->remote_settings, y);\n\treturn (0);\n}\n\nstatic h2_error v_matchproto_(h2_rxframe_f)\nh2_rx_settings(struct worker *wrk, struct h2_sess *h2, struct h2_req *r2)\n{\n\tconst uint8_t *p;\n\tunsigned l;\n\th2_error retval = 0;\n\n\tCHECK_OBJ_NOTNULL(wrk, WORKER_MAGIC);\n\tASSERT_RXTHR(h2);\n\tCHECK_OBJ_NOTNULL(r2, H2_REQ_MAGIC);\n\tassert(r2 == h2->req0);\n\tAZ(h2->rxf_stream);\n\n\tif (h2->rxf_flags == H2FF_SETTINGS_ACK) {\n\t\tif (h2->rxf_len > 0)\t\t\t// rfc7540,l,2047,2049\n\t\t\treturn (H2CE_FRAME_SIZE_ERROR);\n\t\treturn (0);\n\t} else {\n\t\tif (h2->rxf_len % 6)\t\t\t// rfc7540,l,2062,2064\n\t\t\treturn (H2CE_PROTOCOL_ERROR);\n\t\tp = h2->rxf_data;\n\t\tfor (l = h2->rxf_len; l >= 6; l -= 6, p += 6) {\n\t\t\tretval = h2_set_setting(h2, p);\n\t\t\tif (retval)\n\t\t\t\treturn (retval);\n\t\t}\n\t\tH2_Send_Get(wrk, h2, r2);\n\t\tH2_Send_Frame(wrk, h2,\n\t\t    H2_F_SETTINGS, H2FF_SETTINGS_ACK, 0, 0, NULL);\n\t\tH2_Send_Rel(h2, r2);\n\t}\n\treturn (0);\n}\n\n/**********************************************************************\n * Incoming HEADERS, this is where the partys at...\n */\n\nvoid v_matchproto_(task_func_t)\nh2_do_req(struct worker *wrk, void *priv)\n{\n\tstruct req *req;\n\tstruct h2_req *r2;\n\tstruct h2_sess *h2;\n\n\tCAST_OBJ_NOTNULL(req, priv, REQ_MAGIC);\n\tCAST_OBJ_NOTNULL(r2, req->transport_priv, H2_REQ_MAGIC);\n\tTHR_SetRequest(req);\n\tCNT_Embark(wrk, req);\n\tif (req->req_step == R_STP_TRANSPORT) {\n\t\tVCL_TaskEnter(req->privs);\n\t\tVCL_TaskEnter(req->top->privs);\n\t}\n\n\twrk->stats->client_req++;\n\tif (CNT_Request(req) != REQ_FSM_DISEMBARK) {\n\t\tassert(!WS_IsReserved(req->ws));\n\t\tAZ(req->top->vcl0);\n\t\th2 = r2->h2sess;\n\t\tCHECK_OBJ_NOTNULL(h2, H2_SESS_MAGIC);\n\t\tLck_Lock(&h2->sess->mtx);\n\t\tr2->scheduled = 0;\n\t\tr2->state = H2_S_CLOSED;\n\t\tr2->h2sess->do_sweep = 1;\n\t\tif (h2->mailcall == r2) {\n\t\t\th2->mailcall = NULL;\n\t\t\tAZ(pthread_cond_signal(h2->cond));\n\t\t}\n\t\tLck_Unlock(&h2->sess->mtx);\n\t}\n\tTHR_SetRequest(NULL);\n}\n\nstatic h2_error\nh2_end_headers(struct worker *wrk, struct h2_sess *h2,\n    struct req *req, struct h2_req *r2)\n{\n\th2_error h2e;\n\tssize_t cl;\n\n\tASSERT_RXTHR(h2);\n\tassert(r2->state == H2_S_OPEN);\n\th2e = h2h_decode_fini(h2);\n\th2->new_req = NULL;\n\tif (h2e != NULL) {\n\t\tLck_Lock(&h2->sess->mtx);\n\t\tVSLb(h2->vsl, SLT_Debug, \"HPACK/FINI %s\", h2e->name);\n\t\tLck_Unlock(&h2->sess->mtx);\n\t\tassert(!WS_IsReserved(r2->req->ws));\n\t\th2_del_req(wrk, r2);\n\t\treturn (h2e);\n\t}\n\tVSLb_ts_req(req, \"Req\", req->t_req);\n\n\t// XXX: Smarter to do this already at HPACK time into tail end of\n\t// XXX: WS, then copy back once all headers received.\n\t// XXX: Have I mentioned H/2 Is hodge-podge ?\n\thttp_CollectHdrSep(req->http, H_Cookie, \"; \");\t// rfc7540,l,3114,3120\n\n\tcl = http_GetContentLength(req->http);\n\tassert(cl >= -2);\n\tif (cl == -2) {\n\t\tVSLb(h2->vsl, SLT_Debug, \"Non-parseable Content-Length\");\n\t\treturn (H2SE_PROTOCOL_ERROR);\n\t}\n\n\tif (req->req_body_status == NULL) {\n\t\tif (cl == -1)\n\t\t\treq->req_body_status = BS_EOF;\n\t\telse\n\t\t\treq->req_body_status = BS_LENGTH;\n\t\treq->htc->content_length = cl;\n\t} else {\n\t\t/* A HEADER frame contained END_STREAM */\n\t\tassert (req->req_body_status == BS_NONE);\n\t\tr2->state = H2_S_CLOS_REM;\n\t\tif (cl > 0)\n\t\t\treturn (H2CE_PROTOCOL_ERROR); //rfc7540,l,1838,1840\n\t}\n\n\tif (req->http->hd[HTTP_HDR_METHOD].b == NULL) {\n\t\tVSLb(h2->vsl, SLT_Debug, \"Missing :method\");\n\t\treturn (H2SE_PROTOCOL_ERROR); //rfc7540,l,3087,3090\n\t}\n\tif (req->http->hd[HTTP_HDR_URL].b == NULL) {\n\t\tVSLb(h2->vsl, SLT_Debug, \"Missing :path\");\n\t\treturn (H2SE_PROTOCOL_ERROR); //rfc7540,l,3087,3090\n\t}\n\tAN(req->http->hd[HTTP_HDR_PROTO].b);\n\n\treq->req_step = R_STP_TRANSPORT;\n\treq->task->func = h2_do_req;\n\treq->task->priv = req;\n\tr2->scheduled = 1;\n\tif (Pool_Task(wrk->pool, req->task, TASK_QUEUE_STR) != 0) {\n\t\tr2->scheduled = 0;\n\t\tr2->state = H2_S_CLOSED;\n\t\treturn (H2SE_REFUSED_STREAM); //rfc7540,l,3326,3329\n\t}\n\treturn (0);\n}\n\nstatic h2_error v_matchproto_(h2_rxframe_f)\nh2_rx_headers(struct worker *wrk, struct h2_sess *h2, struct h2_req *r2)\n{\n\tstruct req *req;\n\th2_error h2e;\n\tconst uint8_t *p;\n\tsize_t l;\n\n\tCHECK_OBJ_NOTNULL(wrk, WORKER_MAGIC);\n\tASSERT_RXTHR(h2);\n\n\tif (r2 == NULL) {\n\t\tif (h2->rxf_stream <= h2->highest_stream)\n\t\t\treturn (H2CE_PROTOCOL_ERROR);\t// rfc7540,l,1153,1158\n\t\t/* NB: we don't need to guard the read of h2->open_streams\n\t\t * because headers are handled sequentially so it cannot\n\t\t * increase under our feet.\n\t\t */\n\t\tif (h2->open_streams >=\n\t\t    h2->local_settings.max_concurrent_streams) {\n\t\t\tVSLb(h2->vsl, SLT_Debug,\n\t\t\t     \"H2: stream %u: Hit maximum number of \"\n\t\t\t     \"concurrent streams\", h2->rxf_stream);\n\t\t\treturn (H2SE_REFUSED_STREAM);\t// rfc7540,l,1200,1205\n\t\t}\n\t\th2->highest_stream = h2->rxf_stream;\n\t\tr2 = h2_new_req(wrk, h2, h2->rxf_stream, NULL);\n\t}\n\tCHECK_OBJ_NOTNULL(r2, H2_REQ_MAGIC);\n\n\tif (r2->state != H2_S_IDLE)\n\t\treturn (H2CE_PROTOCOL_ERROR);\t// XXX spec ?\n\tr2->state = H2_S_OPEN;\n\n\treq = r2->req;\n\tCHECK_OBJ_NOTNULL(req, REQ_MAGIC);\n\n\treq->vsl->wid = VXID_Get(wrk, VSL_CLIENTMARKER);\n\tVSLb(req->vsl, SLT_Begin, \"req %u rxreq\", VXID(req->sp->vxid));\n\tVSL(SLT_Link, req->sp->vxid, \"req %u rxreq\", VXID(req->vsl->wid));\n\n\th2->new_req = req;\n\treq->sp = h2->sess;\n\treq->transport = &H2_transport;\n\n\treq->t_first = VTIM_real();\n\treq->t_req = VTIM_real();\n\treq->t_prev = req->t_first;\n\tVSLb_ts_req(req, \"Start\", req->t_first);\n\treq->acct.req_hdrbytes += h2->rxf_len;\n\n\tHTTP_Setup(req->http, req->ws, req->vsl, SLT_ReqMethod);\n\thttp_SetH(req->http, HTTP_HDR_PROTO, \"HTTP/2.0\");\n\n\th2h_decode_init(h2);\n\n\tp = h2->rxf_data;\n\tl = h2->rxf_len;\n\tif (h2->rxf_flags & H2FF_HEADERS_PADDED) {\n\t\tif (*p + 1 > l)\n\t\t\treturn (H2CE_PROTOCOL_ERROR);\t// rfc7540,l,1884,1887\n\t\tl -= 1 + *p;\n\t\tp += 1;\n\t}\n\tif (h2->rxf_flags & H2FF_HEADERS_PRIORITY) {\n\t\tif (l < 5)\n\t\t\treturn (H2CE_PROTOCOL_ERROR);\n\t\tl -= 5;\n\t\tp += 5;\n\t}\n\th2e = h2h_decode_bytes(h2, p, l);\n\tif (h2e != NULL) {\n\t\tLck_Lock(&h2->sess->mtx);\n\t\tVSLb(h2->vsl, SLT_Debug, \"HPACK(hdr) %s\", h2e->name);\n\t\tLck_Unlock(&h2->sess->mtx);\n\t\t(void)h2h_decode_fini(h2);\n\t\tassert(!WS_IsReserved(r2->req->ws));\n\t\th2_del_req(wrk, r2);\n\t\treturn (h2e);\n\t}\n\n\tif (h2->rxf_flags & H2FF_HEADERS_END_STREAM)\n\t\treq->req_body_status = BS_NONE;\n\n\tif (h2->rxf_flags & H2FF_HEADERS_END_HEADERS)\n\t\treturn (h2_end_headers(wrk, h2, req, r2));\n\treturn (0);\n}\n\n/**********************************************************************/\n\nstatic h2_error v_matchproto_(h2_rxframe_f)\nh2_rx_continuation(struct worker *wrk, struct h2_sess *h2, struct h2_req *r2)\n{\n\tstruct req *req;\n\th2_error h2e;\n\n\tCHECK_OBJ_NOTNULL(wrk, WORKER_MAGIC);\n\tASSERT_RXTHR(h2);\n\tCHECK_OBJ_ORNULL(r2, H2_REQ_MAGIC);\n\n\tif (r2 == NULL || r2->state != H2_S_OPEN || r2->req != h2->new_req)\n\t\treturn (H2CE_PROTOCOL_ERROR);\t// XXX spec ?\n\treq = r2->req;\n\th2e = h2h_decode_bytes(h2, h2->rxf_data, h2->rxf_len);\n\tr2->req->acct.req_hdrbytes += h2->rxf_len;\n\tif (h2e != NULL) {\n\t\tLck_Lock(&h2->sess->mtx);\n\t\tVSLb(h2->vsl, SLT_Debug, \"HPACK(cont) %s\", h2e->name);\n\t\tLck_Unlock(&h2->sess->mtx);\n\t\t(void)h2h_decode_fini(h2);\n\t\tassert(!WS_IsReserved(r2->req->ws));\n\t\th2_del_req(wrk, r2);\n\t\treturn (h2e);\n\t}\n\tif (h2->rxf_flags & H2FF_HEADERS_END_HEADERS)\n\t\treturn (h2_end_headers(wrk, h2, req, r2));\n\treturn (0);\n}\n\n/**********************************************************************/\n\nstatic h2_error v_matchproto_(h2_rxframe_f)\nh2_rx_data(struct worker *wrk, struct h2_sess *h2, struct h2_req *r2)\n{\n\tint w1 = 0, w2 = 0;\n\tchar buf[4];\n\tunsigned wi;\n\tssize_t cl;\n\n\tCHECK_OBJ_NOTNULL(wrk, WORKER_MAGIC);\n\tASSERT_RXTHR(h2);\n\tCHECK_OBJ_ORNULL(r2, H2_REQ_MAGIC);\n\n\tif (r2 == NULL || !r2->scheduled)\n\t\treturn (0);\n\tif (r2->state >= H2_S_CLOS_REM) {\n\t\tr2->error = H2SE_STREAM_CLOSED;\n\t\treturn (H2SE_STREAM_CLOSED); // rfc7540,l,1766,1769\n\t}\n\tLck_Lock(&h2->sess->mtx);\n\twhile (h2->mailcall != NULL && h2->error == 0 && r2->error == 0)\n\t\tAZ(Lck_CondWait(h2->cond, &h2->sess->mtx, 0));\n\tif (h2->error || r2->error) {\n\t\tLck_Unlock(&h2->sess->mtx);\n\t\treturn (h2->error ? h2->error : r2->error);\n\t}\n\n\tr2->reqbody_bytes += h2->rxf_len;\n\tif (h2->rxf_flags & H2FF_DATA_END_STREAM)\n\t\tr2->state = H2_S_CLOS_REM;\n\tcl = r2->req->htc->content_length;\n\tif (cl >= 0 && (r2->reqbody_bytes > cl ||\n\t      (r2->state >= H2_S_CLOS_REM && r2->reqbody_bytes != cl))) {\n\t\tVSLb(h2->vsl, SLT_Debug,\n\t\t    \"H2: stream %u: Received data and Content-Length\"\n\t\t    \" mismatch\", h2->rxf_stream);\n\t\tr2->error = H2SE_PROTOCOL_ERROR; // rfc7540,l,3150,3163\n\t\tif (r2->cond)\n\t\t\tAZ(pthread_cond_signal(r2->cond));\n\t\tLck_Unlock(&h2->sess->mtx);\n\t\treturn (H2SE_PROTOCOL_ERROR);\n\t}\n\n\tAZ(h2->mailcall);\n\th2->mailcall = r2;\n\th2->req0->r_window -= h2->rxf_len;\n\tr2->r_window -= h2->rxf_len;\n\t// req_bodybytes accounted in CNT code.\n\tif (r2->cond)\n\t\tAZ(pthread_cond_signal(r2->cond));\n\twhile (h2->mailcall != NULL && h2->error == 0 && r2->error == 0)\n\t\tAZ(Lck_CondWait(h2->cond, &h2->sess->mtx, 0));\n\twi = cache_param->h2_rx_window_increment;\n\tif (h2->req0->r_window < cache_param->h2_rx_window_low_water) {\n\t\th2->req0->r_window += wi;\n\t\tw1 = 1;\n\t}\n\tif (r2->r_window < cache_param->h2_rx_window_low_water) {\n\t\tr2->r_window += wi;\n\t\tw2 = 1;\n\t}\n\n\n\tLck_Unlock(&h2->sess->mtx);\n\n\tif (w1 || w2) {\n\t\tvbe32enc(buf, wi);\n\t\tH2_Send_Get(wrk, h2, h2->req0);\n\t\tif (w1)\n\t\t\tH2_Send_Frame(wrk, h2, H2_F_WINDOW_UPDATE, 0,\n\t\t\t    4, 0, buf);\n\t\tif (w2)\n\t\t\tH2_Send_Frame(wrk, h2, H2_F_WINDOW_UPDATE, 0,\n\t\t\t    4, r2->stream, buf);\n\t\tH2_Send_Rel(h2, h2->req0);\n\t}\n\treturn (0);\n}\n\nstatic enum vfp_status v_matchproto_(vfp_pull_f)\nh2_vfp_body(struct vfp_ctx *vc, struct vfp_entry *vfe, void *ptr, ssize_t *lp)\n{\n\tstruct h2_req *r2;\n\tstruct h2_sess *h2;\n\tunsigned l;\n\tenum vfp_status retval;\n\n\tCHECK_OBJ_NOTNULL(vc, VFP_CTX_MAGIC);\n\tCHECK_OBJ_NOTNULL(vfe, VFP_ENTRY_MAGIC);\n\tCAST_OBJ_NOTNULL(r2, vfe->priv1, H2_REQ_MAGIC);\n\th2 = r2->h2sess;\n\n\tAN(ptr);\n\tAN(lp);\n\tl = *lp;\n\t*lp = 0;\n\n\tLck_Lock(&h2->sess->mtx);\n\tr2->cond = &vc->wrk->cond;\n\twhile (h2->mailcall != r2 && h2->error == 0 && r2->error == 0)\n\t\tAZ(Lck_CondWait(r2->cond, &h2->sess->mtx, 0));\n\tr2->cond = NULL;\n\tif (h2->error || r2->error) {\n\t\tretval = VFP_ERROR;\n\t} else {\n\t\tassert(h2->mailcall == r2);\n\t\tif (l > h2->rxf_len)\n\t\t\tl = h2->rxf_len;\n\t\tif (l > 0) {\n\t\t\tmemcpy(ptr, h2->rxf_data, l);\n\t\t\th2->rxf_data += l;\n\t\t\th2->rxf_len -= l;\n\t\t}\n\t\t*lp = l;\n\t\tif (h2->rxf_len > 0) {\n\t\t\t/* We ran out of storage: Have VFP call us\n\t\t\t * again with a fresh buffer */\n\t\t\tLck_Unlock(&h2->sess->mtx);\n\t\t\treturn (VFP_OK);\n\t\t}\n\t\tif (h2->rxf_len == 0 && r2->state >= H2_S_CLOS_REM)\n\t\t\tretval = VFP_END;\n\t\telse\n\t\t\tretval = VFP_OK;\n\t\th2->mailcall = NULL;\n\t\tAZ(pthread_cond_signal(h2->cond));\n\t}\n\tLck_Unlock(&h2->sess->mtx);\n\treturn (retval);\n}\n\nstatic void\nh2_vfp_body_fini(struct vfp_ctx *vc, struct vfp_entry *vfe)\n{\n\tstruct h2_req *r2;\n\tstruct h2_sess *h2;\n\n\tCHECK_OBJ_NOTNULL(vc, VFP_CTX_MAGIC);\n\tCHECK_OBJ_NOTNULL(vfe, VFP_ENTRY_MAGIC);\n\tCAST_OBJ_NOTNULL(r2, vfe->priv1, H2_REQ_MAGIC);\n\tCHECK_OBJ_NOTNULL(r2->req, REQ_MAGIC);\n\th2 = r2->h2sess;\n\n\tif (vc->failed) {\n\t\tCHECK_OBJ_NOTNULL(r2->req->wrk, WORKER_MAGIC);\n\t\tH2_Send_Get(r2->req->wrk, h2, r2);\n\t\tH2_Send_RST(r2->req->wrk, h2, r2, r2->stream,\n\t\t    H2SE_REFUSED_STREAM);\n\t\tH2_Send_Rel(h2, r2);\n\t\tLck_Lock(&h2->sess->mtx);\n\t\tr2->error = H2SE_REFUSED_STREAM;\n\t\tif (h2->mailcall == r2) {\n\t\t\th2->mailcall = NULL;\n\t\t\tAZ(pthread_cond_signal(h2->cond));\n\t\t}\n\t\tLck_Unlock(&h2->sess->mtx);\n\t}\n}\n\nstatic const struct vfp h2_body = {\n\t.name = \"H2_BODY\",\n\t.pull = h2_vfp_body,\n\t.fini = h2_vfp_body_fini\n};\n\nvoid v_matchproto_(vtr_req_body_t)\nh2_req_body(struct req *req)\n{\n\tstruct h2_req *r2;\n\tstruct vfp_entry *vfe;\n\n\tCHECK_OBJ(req, REQ_MAGIC);\n\tCAST_OBJ_NOTNULL(r2, req->transport_priv, H2_REQ_MAGIC);\n\tvfe = VFP_Push(req->vfc, &h2_body);\n\tAN(vfe);\n\tvfe->priv1 = r2;\n}\n\n/**********************************************************************/\n\nvoid v_matchproto_(vtr_req_fail_f)\nh2_req_fail(struct req *req, enum sess_close reason)\n{\n\tassert(reason > 0);\n\tassert(req->sp->fd != 0);\n\tVSLb(req->vsl, SLT_Debug, \"H2FAILREQ\");\n}\n\n/**********************************************************************/\n\nstatic enum htc_status_e v_matchproto_(htc_complete_f)\nh2_frame_complete(struct http_conn *htc)\n{\n\tstruct h2_sess *h2;\n\n\tCHECK_OBJ_NOTNULL(htc, HTTP_CONN_MAGIC);\n\tCAST_OBJ_NOTNULL(h2, htc->priv, H2_SESS_MAGIC);\n\tif (htc->rxbuf_b + 9 > htc->rxbuf_e ||\n\t    htc->rxbuf_b + 9 + (vbe32dec(htc->rxbuf_b) >> 8) > htc->rxbuf_e)\n\t\treturn (HTC_S_MORE);\n\treturn (HTC_S_COMPLETE);\n}\n\n/**********************************************************************/\n\nstatic h2_error\nh2_procframe(struct worker *wrk, struct h2_sess *h2, h2_frame h2f)\n{\n\tstruct h2_req *r2;\n\th2_error h2e;\n\n\tASSERT_RXTHR(h2);\n\tif (h2->rxf_stream == 0 && h2f->act_szero != 0)\n\t\treturn (h2f->act_szero);\n\n\tif (h2->rxf_stream != 0 && h2f->act_snonzero != 0)\n\t\treturn (h2f->act_snonzero);\n\n\tif (h2->rxf_stream > h2->highest_stream && h2f->act_sidle != 0)\n\t\treturn (h2f->act_sidle);\n\n\tif (h2->rxf_stream != 0 && !(h2->rxf_stream & 1)) {\n\t\t// rfc7540,l,1140,1145\n\t\t// rfc7540,l,1153,1158\n\t\t/* No even streams, we don't do PUSH_PROMISE */\n\t\tLck_Lock(&h2->sess->mtx);\n\t\tVSLb(h2->vsl, SLT_Debug, \"H2: illegal stream (=%u)\",\n\t\t    h2->rxf_stream);\n\t\tLck_Unlock(&h2->sess->mtx);\n\t\treturn (H2CE_PROTOCOL_ERROR);\n\t}\n\n\tVTAILQ_FOREACH(r2, &h2->streams, list)\n\t\tif (r2->stream == h2->rxf_stream)\n\t\t\tbreak;\n\n\tif (h2->new_req != NULL &&\n\t    !(r2 && h2->new_req == r2->req && h2f == H2_F_CONTINUATION))\n\t\treturn (H2CE_PROTOCOL_ERROR);\t// rfc7540,l,1859,1863\n\n\th2e = h2f->rxfunc(wrk, h2, r2);\n\tif (h2e == 0)\n\t\treturn (0);\n\tif (h2->rxf_stream == 0 || h2e->connection)\n\t\treturn (h2e);\t// Connection errors one level up\n\n\tH2_Send_Get(wrk, h2, h2->req0);\n\tH2_Send_RST(wrk, h2, h2->req0, h2->rxf_stream, h2e);\n\tH2_Send_Rel(h2, h2->req0);\n\treturn (0);\n}\n\nint\nh2_stream_tmo(struct h2_sess *h2, const struct h2_req *r2, vtim_real now)\n{\n\tint r = 0;\n\n\tCHECK_OBJ_NOTNULL(h2, H2_SESS_MAGIC);\n\tCHECK_OBJ_NOTNULL(r2, H2_REQ_MAGIC);\n\tLck_AssertHeld(&h2->sess->mtx);\n\n\t/* NB: when now is NAN, it means that idle_send_timeout was hit\n\t * on a lock condwait operation.\n\t */\n\tif (isnan(now))\n\t\tAN(r2->t_winupd);\n\n\tif (r2->t_winupd == 0 && r2->t_send == 0)\n\t\treturn (0);\n\n\tif (isnan(now) || (r2->t_winupd != 0 &&\n\t    now - r2->t_winupd > SESS_TMO(h2->sess, idle_send_timeout))) {\n\t\tVSLb(h2->vsl, SLT_Debug,\n\t\t     \"H2: stream %u: Hit idle_send_timeout waiting for\"\n\t\t     \" WINDOW_UPDATE\", r2->stream);\n\t\tr = 1;\n\t}\n\n\tif (r == 0 && r2->t_send != 0 &&\n\t    now - r2->t_send > SESS_TMO(h2->sess, send_timeout)) {\n\t\tVSLb(h2->vsl, SLT_Debug,\n\t\t     \"H2: stream %u: Hit send_timeout\", r2->stream);\n\t\tr = 1;\n\t}\n\n\treturn (r);\n}\n\nstatic int\nh2_stream_tmo_unlocked(struct h2_sess *h2, const struct h2_req *r2)\n{\n\tint r;\n\n\tLck_Lock(&h2->sess->mtx);\n\tr = h2_stream_tmo(h2, r2, h2->sess->t_idle);\n\tLck_Unlock(&h2->sess->mtx);\n\n\treturn (r);\n}\n\n/*\n * This is the janitorial task of cleaning up any closed & refused\n * streams, and checking if the session is timed out.\n */\nstatic int\nh2_sweep(struct worker *wrk, struct h2_sess *h2)\n{\n\tint tmo = 0;\n\tstruct h2_req *r2, *r22;\n\n\tASSERT_RXTHR(h2);\n\n\th2->do_sweep = 0;\n\tVTAILQ_FOREACH_SAFE(r2, &h2->streams, list, r22) {\n\t\tif (r2 == h2->req0) {\n\t\t\tassert (r2->state == H2_S_IDLE);\n\t\t\tcontinue;\n\t\t}\n\t\tswitch (r2->state) {\n\t\tcase H2_S_CLOSED:\n\t\t\tif (!r2->scheduled)\n\t\t\t\th2_del_req(wrk, r2);\n\t\t\tbreak;\n\t\tcase H2_S_CLOS_REM:\n\t\t\tif (!r2->scheduled) {\n\t\t\t\tH2_Send_Get(wrk, h2, h2->req0);\n\t\t\t\tH2_Send_RST(wrk, h2, h2->req0, r2->stream,\n\t\t\t\t    H2SE_REFUSED_STREAM);\n\t\t\t\tH2_Send_Rel(h2, h2->req0);\n\t\t\t\th2_del_req(wrk, r2);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* FALLTHROUGH */\n\t\tcase H2_S_CLOS_LOC:\n\t\tcase H2_S_OPEN:\n\t\t\tif (h2_stream_tmo_unlocked(h2, r2)) {\n\t\t\t\ttmo = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase H2_S_IDLE:\n\t\t\t/* Current code make this unreachable: h2_new_req is\n\t\t\t * only called inside h2_rx_headers, which immediately\n\t\t\t * sets the new stream state to H2_S_OPEN */\n\t\t\t/* FALLTHROUGH */\n\t\tdefault:\n\t\t\tWRONG(\"Wrong h2 stream state\");\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (tmo)\n\t\treturn (0);\n\treturn (h2->refcnt > 1);\n}\n\n\n/***********************************************************************\n * Called in loop from h2_new_session()\n */\n\n#define H2_FRAME(l,U,...) const struct h2_frame_s H2_F_##U[1] = \\\n    {{ #U, h2_rx_##l, __VA_ARGS__ }};\n#include \"tbl/h2_frames.h\"\n\nstatic const h2_frame h2flist[] = {\n#define H2_FRAME(l,U,t,...) [t] = H2_F_##U,\n#include \"tbl/h2_frames.h\"\n};\n\n#define H2FMAX (sizeof(h2flist) / sizeof(h2flist[0]))\n\nint\nh2_rxframe(struct worker *wrk, struct h2_sess *h2)\n{\n\tenum htc_status_e hs;\n\th2_frame h2f;\n\th2_error h2e;\n\tchar b[8];\n\n\tASSERT_RXTHR(h2);\n\tVTCP_blocking(*h2->htc->rfd);\n\th2->sess->t_idle = VTIM_real();\n\ths = HTC_RxStuff(h2->htc, h2_frame_complete,\n\t    NULL, NULL, NAN,\n\t    h2->sess->t_idle + SESS_TMO(h2->sess, timeout_idle),\n\t    NAN, h2->local_settings.max_frame_size + 9);\n\tswitch (hs) {\n\tcase HTC_S_COMPLETE:\n\t\tbreak;\n\tcase HTC_S_TIMEOUT:\n\t\tif (h2_sweep(wrk, h2))\n\t\t\treturn (1);\n\n\t\t/* FALLTHROUGH */\n\tdefault:\n\t\t/* XXX: HTC_S_OVERFLOW / FRAME_SIZE_ERROR handling */\n\t\tLck_Lock(&h2->sess->mtx);\n\t\tVSLb(h2->vsl, SLT_Debug, \"H2: No frame (hs=%d)\", hs);\n\t\th2->error = H2CE_NO_ERROR;\n\t\tLck_Unlock(&h2->sess->mtx);\n\t\treturn (0);\n\t}\n\n\tif (h2->do_sweep)\n\t\t(void)h2_sweep(wrk, h2);\n\n\th2->rxf_len =  vbe32dec(h2->htc->rxbuf_b) >> 8;\n\th2->rxf_type =  h2->htc->rxbuf_b[3];\n\th2->rxf_flags = h2->htc->rxbuf_b[4];\n\th2->rxf_stream = vbe32dec(h2->htc->rxbuf_b + 5);\n\th2->rxf_stream &= ~(1LU<<31);\t\t\t// rfc7540,l,690,692\n\th2->rxf_data = (void*)(h2->htc->rxbuf_b + 9);\n\t/* XXX: later full DATA will not be rx'ed yet. */\n\tHTC_RxPipeline(h2->htc, h2->htc->rxbuf_b + h2->rxf_len + 9);\n\n\th2_vsl_frame(h2, h2->htc->rxbuf_b, 9L + h2->rxf_len);\n\th2->srq->acct.req_hdrbytes += 9;\n\n\tif (h2->rxf_type >= H2FMAX) {\n\t\t// rfc7540,l,679,681\n\t\t// XXX: later, drain rest of frame\n\t\th2->bogosity++;\n\t\tLck_Lock(&h2->sess->mtx);\n\t\tVSLb(h2->vsl, SLT_Debug,\n\t\t    \"H2: Unknown frame type 0x%02x (ignored)\",\n\t\t    (uint8_t)h2->rxf_type);\n\t\tLck_Unlock(&h2->sess->mtx);\n\t\th2->srq->acct.req_bodybytes += h2->rxf_len;\n\t\treturn (1);\n\t}\n\th2f = h2flist[h2->rxf_type];\n\n\tAN(h2f->name);\n\tAN(h2f->rxfunc);\n\tif (h2f->overhead)\n\t\th2->srq->acct.req_bodybytes += h2->rxf_len;\n\n\tif (h2->rxf_flags & ~h2f->flags) {\n\t\t// rfc7540,l,687,688\n\t\th2->bogosity++;\n\t\tLck_Lock(&h2->sess->mtx);\n\t\tVSLb(h2->vsl, SLT_Debug,\n\t\t    \"H2: Unknown flags 0x%02x on %s (ignored)\",\n\t\t    (uint8_t)h2->rxf_flags & ~h2f->flags, h2f->name);\n\t\tLck_Unlock(&h2->sess->mtx);\n\t\th2->rxf_flags &= h2f->flags;\n\t}\n\n\th2e = h2_procframe(wrk, h2, h2f);\n\tif (h2->error == 0 && h2e) {\n\t\th2->error = h2e;\n\t\tvbe32enc(b, h2->highest_stream);\n\t\tvbe32enc(b + 4, h2e->val);\n\t\tH2_Send_Get(wrk, h2, h2->req0);\n\t\tH2_Send_Frame(wrk, h2, H2_F_GOAWAY, 0, 8, 0, b);\n\t\tH2_Send_Rel(h2, h2->req0);\n\t}\n\treturn (h2->error ? 0 : 1);\n}\n"], "filenames": ["bin/varnishd/http2/cache_http2.h", "bin/varnishd/http2/cache_http2_proto.c"], "buggy_code_start_loc": [136, 556], "buggy_code_end_loc": [136, 840], "fixing_code_start_loc": [137, 557], "fixing_code_end_loc": [139, 866], "type": "CWE-444", "message": "Varnish Cache, with HTTP/2 enabled, allows request smuggling and VCL authorization bypass via a large Content-Length header for a POST request. This affects Varnish Enterprise 6.0.x before 6.0.8r3, and Varnish Cache 5.x and 6.x before 6.5.2, 6.6.x before 6.6.1, and 6.0 LTS before 6.0.8.", "other": {"cve": {"id": "CVE-2021-36740", "sourceIdentifier": "cve@mitre.org", "published": "2021-07-14T17:15:08.253", "lastModified": "2022-08-02T19:12:02.710", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Varnish Cache, with HTTP/2 enabled, allows request smuggling and VCL authorization bypass via a large Content-Length header for a POST request. This affects Varnish Enterprise 6.0.x before 6.0.8r3, and Varnish Cache 5.x and 6.x before 6.5.2, 6.6.x before 6.6.1, and 6.0 LTS before 6.0.8."}, {"lang": "es", "value": "Varnish Cache, con HTTP/2 habilitado, permite el contrabando de peticiones y la omisi\u00f3n de autorizaci\u00f3n de VCL por medio de un encabezado Content-Length grande para una petici\u00f3n POST. Esto afecta a Varnish Enterprise versiones 6.0.x anteriores a 6.0.8r3, y Varnish Cache versiones 5.xy 6.x anteriores a 6.5.2, versiones 6.6.x anteriores a 6.6.1 y versiones 6.0 LTS anteriores a 6.0.8"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 2.5}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-444"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:varnish-cache:varnish_cache:*:*:*:*:plus:*:*:*", "versionStartIncluding": "6.0.0", "versionEndExcluding": "6.0.8", "matchCriteriaId": "F094729F-7EA5-4AD5-B0C1-65F9A401838A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:varnish-cache:varnish_cache:6.0.8:r1:*:*:plus:*:*:*", "matchCriteriaId": "B32A2391-A59E-45F3-8A65-3AF018F3F08F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:varnish-cache:varnish_cache:6.0.8:r2:*:*:plus:*:*:*", "matchCriteriaId": "26C18D9B-9561-49FB-A9E4-9A8F37635F86"}, {"vulnerable": true, "criteria": "cpe:2.3:a:varnish-software:varnish_cache:*:*:*:*:*:*:*:*", "versionStartIncluding": "6.0.0", "versionEndIncluding": "6.0.5", "matchCriteriaId": "48EB8B3B-152D-46EF-B868-9EAA640EE11B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:varnish-software:varnish_cache:*:*:*:*:lts:*:*:*", "versionStartIncluding": "6.0.0", "versionEndIncluding": "6.0.7", "matchCriteriaId": "3C9C515C-1514-4E52-98D5-850D6ACB60B0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:varnish_cache_project:varnish_cache:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.0.0", "versionEndIncluding": "5.2.1", "matchCriteriaId": "80E7D421-3E84-4185-9FC4-ACF2C5A8E8EA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:varnish_cache_project:varnish_cache:*:*:*:*:*:*:*:*", "versionStartIncluding": "6.1.0", "versionEndIncluding": "6.6.0", "matchCriteriaId": "A30F7732-D4C3-4D6E-8651-BC77A336AAEE"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:33:*:*:*:*:*:*:*", "matchCriteriaId": "E460AA51-FCDA-46B9-AE97-E6676AA5E194"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA6FEEC2-9F11-4643-8827-749718254FED"}]}]}], "references": [{"url": "https://docs.varnish-software.com/security/VSV00007/", "source": "cve@mitre.org", "tags": ["Mitigation", "Vendor Advisory"]}, {"url": "https://github.com/varnishcache/varnish-cache/commit/82b0a629f60136e76112c6f2c6372cce77b683be", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/varnishcache/varnish-cache/commit/9be22198e258d0e7a5c41f4291792214a29405cf", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/THV2DQA2GS65HUCKK4KSD2XLN3AAQ2V5/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ZHBNLDEOTGYRIEQZBWV7F6VPYS4O2AAK/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://varnish-cache.org/security/VSV00007.html", "source": "cve@mitre.org", "tags": ["Mitigation", "Vendor Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5088", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/varnishcache/varnish-cache/commit/82b0a629f60136e76112c6f2c6372cce77b683be"}}