{"buggy_code": ["/*\n *  Copyright (C) 2015 Adrien Verg\u00e9\n *\n *  This program is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  In addition, as a special exception, the copyright holders give permission\n *  to link the code of portions of this program with the OpenSSL library under\n *  certain conditions as described in each individual source file, and\n *  distribute linked combinations including the two.\n *  You must obey the GNU General Public License in all respects for all of the\n *  code used other than OpenSSL.  If you modify file(s) with this exception,\n *  you may extend this exception to your version of the file(s), but you are\n *  not obligated to do so.  If you do not wish to do so, delete this exception\n *  statement from your version.  If you delete this exception statement from\n *  all source files in the program, then also delete it here.\n */\n\n#include \"tunnel.h\"\n#include \"http.h\"\n#include \"log.h\"\n\n#include <unistd.h>\n#include <fcntl.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <errno.h>\n#include <string.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <openssl/err.h>\n#include <openssl/x509v3.h>\n#include <openssl/engine.h>\n#if HAVE_PTY_H\n#include <pty.h>\n#elif HAVE_UTIL_H\n#include <util.h>\n#endif\n#include <termios.h>\n#include <signal.h>\n#include <sys/wait.h>\n#if HAVE_SYSTEMD\n#include <systemd/sd-daemon.h>\n#endif\n\n// we use this constant in the source, so define a fallback if not defined\n#ifndef OPENSSL_API_COMPAT\n#define OPENSSL_API_COMPAT 0x0908000L\n#endif\n\nstruct ofv_varr {\n\tunsigned int cap;\t// current capacity\n\tunsigned int off;\t// next slot to write, always < max(cap - 1, 1)\n\tconst char **data;\t// NULL terminated\n};\n\nstatic int ofv_append_varr(struct ofv_varr *p, const char *x)\n{\n\tif (p->off + 1 >= p->cap) {\n\t\tconst char **ndata;\n\t\tunsigned int ncap = (p->off + 1) * 2;\n\t\tif (p->off + 1 >= ncap) {\n\t\t\tlog_error(\"%s: ncap exceeded\\n\", __func__);\n\t\t\treturn 1;\n\t\t};\n\t\tndata = realloc(p->data, ncap * sizeof(const char *));\n\t\tif (ndata) {\n\t\t\tp->data = ndata;\n\t\t\tp->cap = ncap;\n\t\t} else {\n\t\t\tlog_error(\"realloc: %s\\n\", strerror(errno));\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif (p->data == NULL) {\n\t\tlog_error(\"%s: NULL data\\n\", __func__);\n\t\treturn 1;\n\t}\n\tif (p->off + 1 >= p->cap) {\n\t\tlog_error(\"%s: cap exceeded in p\\n\", __func__);\n\t\treturn 1;\n\t}\n\tp->data[p->off] = x;\n\tp->data[++p->off] = NULL;\n\treturn 0;\n}\n\nstatic int on_ppp_if_up(struct tunnel *tunnel)\n{\n\tlog_info(\"Interface %s is UP.\\n\", tunnel->ppp_iface);\n\n\tif (tunnel->config->set_routes) {\n\t\tint ret;\n\n\t\tlog_info(\"Setting new routes...\\n\");\n\n\t\tret = ipv4_set_tunnel_routes(tunnel);\n\n\t\tif (ret != 0)\n\t\t\tlog_warn(\"Adding route table is incomplete. Please check route table.\\n\");\n\t}\n\n\tif (tunnel->config->set_dns) {\n\t\tlog_info(\"Adding VPN nameservers...\\n\");\n\t\tipv4_add_nameservers_to_resolv_conf(tunnel);\n\t}\n\n\tlog_info(\"Tunnel is up and running.\\n\");\n\n#if HAVE_SYSTEMD\n\tsd_notify(0, \"READY=1\");\n#endif\n\n\treturn 0;\n}\n\nstatic int on_ppp_if_down(struct tunnel *tunnel)\n{\n\tlog_info(\"Setting ppp interface down.\\n\");\n\n\tif (tunnel->config->set_routes) {\n\t\tlog_info(\"Restoring routes...\\n\");\n\t\tipv4_restore_routes(tunnel);\n\t}\n\n\tif (tunnel->config->set_dns) {\n\t\tlog_info(\"Removing VPN nameservers...\\n\");\n\t\tipv4_del_nameservers_from_resolv_conf(tunnel);\n\t}\n\n\treturn 0;\n}\n\nstatic int pppd_run(struct tunnel *tunnel)\n{\n\tpid_t pid;\n\tint amaster;\n\tint slave_stderr;\n\n#ifdef HAVE_STRUCT_TERMIOS\n\tstruct termios termp = {\n\t\t.c_cflag = B9600,\n\t\t.c_cc[VTIME] = 0,\n\t\t.c_cc[VMIN] = 1\n\t};\n#endif\n\n\tstatic const char ppp_path[] = PPP_PATH;\n\tif (access(ppp_path, F_OK) != 0) {\n\t\tlog_error(\"%s: %s.\\n\", ppp_path, strerror(errno));\n\t\treturn 1;\n\t}\n\tlog_debug(\"ppp_path: %s\\n\", ppp_path);\n\n\tslave_stderr = dup(STDERR_FILENO);\n\n\tif (slave_stderr < 0) {\n\t\tlog_error(\"slave stderr %s\\n\", strerror(errno));\n\t\treturn 1;\n\t}\n\n#ifdef HAVE_STRUCT_TERMIOS\n\tpid = forkpty(&amaster, NULL, &termp, NULL);\n#else\n\tpid = forkpty(&amaster, NULL, NULL, NULL);\n#endif\n\n\tif (pid == 0) { // child process\n\n\t\tstruct ofv_varr pppd_args = { 0, 0, NULL };\n\n\t\tdup2(slave_stderr, STDERR_FILENO);\n\t\tclose(slave_stderr);\n\n#if HAVE_USR_SBIN_PPP\n\t\t/*\n\t\t * assume there is a default configuration to start.\n\t\t * Support for taking options from the command line\n\t\t * e.g. the name of the configuration or options\n\t\t * to send interactively to ppp will be added later\n\t\t */\n\t\tstatic const char *const v[] = {\n\t\t\tppp_path,\n\t\t\t\"-direct\"\n\t\t};\n\t\tfor (unsigned int i = 0; i < ARRAY_SIZE(v); i++)\n\t\t\tif (ofv_append_varr(&pppd_args, v[i]))\n\t\t\t\treturn 1;\n#endif\n#if HAVE_USR_SBIN_PPPD\n\t\tif (tunnel->config->pppd_call) {\n\t\t\tif (ofv_append_varr(&pppd_args, ppp_path))\n\t\t\t\treturn 1;\n\t\t\tif (ofv_append_varr(&pppd_args, \"call\"))\n\t\t\t\treturn 1;\n\t\t\tif (ofv_append_varr(&pppd_args, tunnel->config->pppd_call))\n\t\t\t\treturn 1;\n\t\t} else {\n\t\t\tstatic const char *const v[] = {\n\t\t\t\tppp_path,\n\t\t\t\t\"115200\", // speed\n\t\t\t\t\":192.0.2.1\", // <local_IP_address>:<remote_IP_address>\n\t\t\t\t\"noipdefault\",\n\t\t\t\t\"noaccomp\",\n\t\t\t\t\"noauth\",\n\t\t\t\t\"default-asyncmap\",\n\t\t\t\t\"nopcomp\",\n\t\t\t\t\"receive-all\",\n\t\t\t\t\"nodefaultroute\",\n\t\t\t\t\"nodetach\",\n\t\t\t\t\"lcp-max-configure\", \"40\",\n\t\t\t\t\"mru\", \"1354\"\n\t\t\t};\n\t\t\tfor (unsigned int i = 0; i < ARRAY_SIZE(v); i++)\n\t\t\t\tif (ofv_append_varr(&pppd_args, v[i]))\n\t\t\t\t\treturn 1;\n\t\t}\n\t\tif (tunnel->config->pppd_use_peerdns)\n\t\t\tif (ofv_append_varr(&pppd_args, \"usepeerdns\"))\n\t\t\t\treturn 1;\n\t\tif (tunnel->config->pppd_log) {\n\t\t\tif (ofv_append_varr(&pppd_args, \"debug\"))\n\t\t\t\treturn 1;\n\t\t\tif (ofv_append_varr(&pppd_args, \"logfile\"))\n\t\t\t\treturn 1;\n\t\t\tif (ofv_append_varr(&pppd_args, tunnel->config->pppd_log))\n\t\t\t\treturn 1;\n\t\t} else {\n\t\t\t/*\n\t\t\t * pppd defaults to logging to fd=1, clobbering the\n\t\t\t * actual PPP data\n\t\t\t */\n\t\t\tif (ofv_append_varr(&pppd_args, \"logfd\"))\n\t\t\t\treturn 1;\n\t\t\tif (ofv_append_varr(&pppd_args, \"2\"))\n\t\t\t\treturn 1;\n\t\t}\n\t\tif (tunnel->config->pppd_plugin) {\n\t\t\tif (ofv_append_varr(&pppd_args, \"plugin\"))\n\t\t\t\treturn 1;\n\t\t\tif (ofv_append_varr(&pppd_args, tunnel->config->pppd_plugin))\n\t\t\t\treturn 1;\n\t\t}\n\t\tif (tunnel->config->pppd_ipparam) {\n\t\t\tif (ofv_append_varr(&pppd_args, \"ipparam\"))\n\t\t\t\treturn 1;\n\t\t\tif (ofv_append_varr(&pppd_args, tunnel->config->pppd_ipparam))\n\t\t\t\treturn 1;\n\t\t}\n\t\tif (tunnel->config->pppd_ifname) {\n\t\t\tif (ofv_append_varr(&pppd_args, \"ifname\"))\n\t\t\t\treturn 1;\n\t\t\tif (ofv_append_varr(&pppd_args, tunnel->config->pppd_ifname))\n\t\t\t\treturn 1;\n\t\t}\n#endif\n#if HAVE_USR_SBIN_PPP\n\t\tif (tunnel->config->ppp_system) {\n\t\t\tif (ofv_append_varr(&pppd_args, tunnel->config->ppp_system))\n\t\t\t\treturn 1;\n\t\t}\n#endif\n\n\t\tclose(tunnel->ssl_socket);\n\t\texecv(pppd_args.data[0], (char *const *)pppd_args.data);\n\t\tfree(pppd_args.data);\n\n\t\tfprintf(stderr, \"execvp: %s\\n\", strerror(errno));\n\t\t_exit(EXIT_FAILURE);\n\t} else {\n\t\tclose(slave_stderr);\n\t\tif (pid == -1) {\n\t\t\tlog_error(\"forkpty: %s\\n\", strerror(errno));\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t// Set non-blocking\n\tint flags = fcntl(amaster, F_GETFL, 0);\n\tif (flags == -1)\n\t\tflags = 0;\n\tif (fcntl(amaster, F_SETFL, flags | O_NONBLOCK) == -1) {\n\t\tlog_error(\"fcntl: %s\\n\", strerror(errno));\n\t\treturn 1;\n\t}\n\n\ttunnel->pppd_pid = pid;\n\ttunnel->pppd_pty = amaster;\n\n\treturn 0;\n}\n\nstatic const char * const pppd_message[] = {\n\t\"Has detached, or otherwise the connection was successfully established and terminated at the peer's request.\",\n\t\"An immediately fatal error of some kind occurred, such as an essential system call failing, or running out of virtual memory.\",\n\t\"An error was detected in processing the options given, such as two mutually exclusive options being used.\",\n\t\"Is not setuid-root and the invoking user is not root.\",\n\t\"The kernel does not support PPP, for example, the PPP kernel driver is not included or cannot be loaded.\",\n\t\"Terminated because it was sent a SIGINT, SIGTERM or SIGHUP signal.\",\n\t\"The serial port could not be locked.\",\n\t\"The serial port could not be opened.\",\n\t\"The connect script failed (returned a non-zero exit status).\",\n\t\"The command specified as the argument to the pty option could not be run.\",\n\t\"The PPP negotiation failed, that is, it didn't reach the point where at least one network protocol (e.g. IP) was running.\",\n\t\"The peer system failed (or refused) to authenticate itself.\",\n\t\"The link was established successfully and terminated because it was idle.\",\n\t\"The link was established successfully and terminated because the connect time limit was reached.\",\n\t\"Callback was negotiated and an incoming call should arrive shortly.\",\n\t\"The link was terminated because the peer is not responding to echo requests.\",\n\t\"The link was terminated by the modem hanging up.\",\n\t\"The PPP negotiation failed because serial loopback was detected.\",\n\t\"The init script failed (returned a non-zero exit status).\",\n\t\"We failed to authenticate ourselves to the peer.\"\n};\n\nstatic int pppd_terminate(struct tunnel *tunnel)\n{\n\tclose(tunnel->pppd_pty);\n\n\tlog_debug(\"Waiting for %s to exit...\\n\", PPP_DAEMON);\n\n\tint status;\n\tif (waitpid(tunnel->pppd_pid, &status, 0) == -1) {\n\t\tlog_error(\"waitpid: %s\\n\", strerror(errno));\n\t\treturn 1;\n\t}\n\tif (WIFEXITED(status)) {\n\t\tint exit_status = WEXITSTATUS(status);\n\t\tlog_debug(\"waitpid: %s exit status code %d\\n\",\n\t\t          PPP_DAEMON, exit_status);\n#if HAVE_USR_SBIN_PPPD\n\t\tif (exit_status >= ARRAY_SIZE(pppd_message) || exit_status < 0) {\n\t\t\tlog_error(\"%s: Returned an unknown exit status: %d\\n\",\n\t\t\t          PPP_DAEMON, exit_status);\n\t\t} else {\n\t\t\tswitch (exit_status) {\n\t\t\tcase 0: // success\n\t\t\t\tlog_debug(\"%s: %s\\n\",\n\t\t\t\t          PPP_DAEMON, pppd_message[exit_status]);\n\t\t\t\tbreak;\n\t\t\tcase 16: // emitted when exiting normally\n\t\t\t\tlog_info(\"%s: %s\\n\",\n\t\t\t\t         PPP_DAEMON, pppd_message[exit_status]);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tlog_error(\"%s: %s\\n\",\n\t\t\t\t          PPP_DAEMON, pppd_message[exit_status]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n#else\n\t\t// ppp exit codes in the FreeBSD case\n\t\tswitch (exit_status) {\n\t\tcase 0: // success and EX_NORMAL as defined in ppp source directly\n\t\t\tlog_debug(\"%s: %s\\n\", PPP_DAEMON, pppd_message[exit_status]);\n\t\t\tbreak;\n\t\tcase 1:\n\t\tcase 127:\n\t\tcase 255: // abnormal exit with hard-coded error codes in ppp\n\t\t\tlog_error(\"%s: exited with return value of %d\\n\",\n\t\t\t          PPP_DAEMON, exit_status);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_error(\"%s: %s (%d)\\n\", PPP_DAEMON, strerror(exit_status),\n\t\t\t          exit_status);\n\t\t\tbreak;\n\t\t}\n#endif\n\t} else if (WIFSIGNALED(status)) {\n\t\tint signal_number = WTERMSIG(status);\n\t\tlog_debug(\"waitpid: %s terminated by signal %d\\n\",\n\t\t          PPP_DAEMON, signal_number);\n\t\tlog_error(\"%s: terminated by signal: %s\\n\",\n\t\t          PPP_DAEMON, strsignal(signal_number));\n\t}\n\n\treturn 0;\n}\n\nint ppp_interface_is_up(struct tunnel *tunnel)\n{\n\tstruct ifaddrs *ifap, *ifa;\n\n\tlog_debug(\"Got Address: %s\\n\", inet_ntoa(tunnel->ipv4.ip_addr));\n\n\tif (getifaddrs(&ifap)) {\n\t\tlog_error(\"getifaddrs: %s\\n\", strerror(errno));\n\t\treturn 0;\n\t}\n\n\tfor (ifa = ifap; ifa != NULL; ifa = ifa->ifa_next) {\n\t\tif ((\n#if HAVE_USR_SBIN_PPPD\n\t\t            (tunnel->config->pppd_ifname\n\t\t             && strstr(ifa->ifa_name, tunnel->config->pppd_ifname)\n\t\t             != NULL)\n\t\t            || strstr(ifa->ifa_name, \"ppp\") != NULL\n#endif\n#if HAVE_USR_SBIN_PPP\n\t\t            strstr(ifa->ifa_name, \"tun\") != NULL\n#endif\n\t\t    ) && ifa->ifa_flags & IFF_UP) {\n\t\t\tif (&(ifa->ifa_addr->sa_family) != NULL\n\t\t\t    && ifa->ifa_addr->sa_family == AF_INET) {\n\t\t\t\tstruct in_addr if_ip_addr =\n\t\t\t\t        cast_addr(ifa->ifa_addr)->sin_addr;\n\n\t\t\t\tlog_debug(\"Interface Name: %s\\n\", ifa->ifa_name);\n\t\t\t\tlog_debug(\"Interface Addr: %s\\n\", inet_ntoa(if_ip_addr));\n\n\t\t\t\tif (tunnel->ipv4.ip_addr.s_addr == if_ip_addr.s_addr) {\n\t\t\t\t\tstrncpy(tunnel->ppp_iface, ifa->ifa_name,\n\t\t\t\t\t        ROUTE_IFACE_LEN - 1);\n\t\t\t\t\tfreeifaddrs(ifap);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfreeifaddrs(ifap);\n\n\treturn 0;\n}\n\nstatic int get_gateway_host_ip(struct tunnel *tunnel)\n{\n\tconst struct addrinfo hints = { .ai_family = AF_INET };\n\tstruct addrinfo *result = NULL;\n\n\tint ret = getaddrinfo(tunnel->config->gateway_host, NULL, &hints, &result);\n\n\tif (ret) {\n\t\tif (ret == EAI_SYSTEM)\n\t\t\tlog_error(\"getaddrinfo: %s\\n\", strerror(errno));\n\t\telse\n\t\t\tlog_error(\"getaddrinfo: %s\\n\", gai_strerror(ret));\n\t\treturn 1;\n\t}\n\n\ttunnel->config->gateway_ip = ((struct sockaddr_in *)\n\t                              result->ai_addr)->sin_addr;\n\tfreeaddrinfo(result);\n\n\tsetenv(\"VPN_GATEWAY\", inet_ntoa(tunnel->config->gateway_ip), 0);\n\n\treturn 0;\n}\n\n/*\n * Establish a regular TCP connection.\n */\nstatic int tcp_connect(struct tunnel *tunnel)\n{\n\tint ret, handle;\n\tstruct sockaddr_in server;\n\tchar *env_proxy;\n\n\thandle = socket(AF_INET, SOCK_STREAM, 0);\n\tif (handle == -1) {\n\t\tlog_error(\"socket: %s\\n\", strerror(errno));\n\t\tgoto err_socket;\n\t}\n\tenv_proxy = getenv(\"https_proxy\");\n\tif (env_proxy == NULL)\n\t\tenv_proxy = getenv(\"HTTPS_PROXY\");\n\tif (env_proxy == NULL)\n\t\tenv_proxy = getenv(\"all_proxy\");\n\tif (env_proxy == NULL)\n\t\tenv_proxy = getenv(\"ALL_PROXY\");\n\tif (env_proxy != NULL) {\n\t\tchar *proxy_host, *proxy_port;\n\t\t// protect the original environment from modifications\n\t\tenv_proxy = strdup(env_proxy);\n\t\tif (env_proxy == NULL) {\n\t\t\tlog_error(\"strdup: %s\\n\", strerror(errno));\n\t\t\tgoto err_strdup;\n\t\t}\n\t\t// get rid of a trailing slash\n\t\tif (*env_proxy && env_proxy[strlen(env_proxy) - 1] == '/')\n\t\t\tenv_proxy[strlen(env_proxy) - 1] = '\\0';\n\t\t// get rid of a http(s):// prefix in env_proxy\n\t\tproxy_host = strstr(env_proxy, \"://\");\n\t\tif (proxy_host == NULL)\n\t\t\tproxy_host = env_proxy;\n\t\telse\n\t\t\tproxy_host += 3;\n\t\t// split host and port\n\t\tproxy_port = index(proxy_host, ':');\n\t\tif (proxy_port != NULL) {\n\t\t\tproxy_port[0] = '\\0';\n\t\t\tproxy_port++;\n\t\t\tserver.sin_port = htons(strtoul(proxy_port, NULL, 10));\n\t\t} else {\n\t\t\tserver.sin_port = htons(tunnel->config->gateway_port);\n\t\t}\n\t\t// get rid of a trailing slash\n\t\tif (*proxy_host && proxy_host[strlen(proxy_host) - 1] == '/')\n\t\t\tproxy_host[strlen(proxy_host) - 1] = '\\0';\n\t\tlog_debug(\"proxy_host: %s\\n\", proxy_host);\n\t\tlog_debug(\"proxy_port: %s\\n\", proxy_port);\n\t\tserver.sin_addr.s_addr = inet_addr(proxy_host);\n\t\t// if host is given as a FQDN we have to do a DNS lookup\n\t\tif (server.sin_addr.s_addr == INADDR_NONE) {\n\t\t\tconst struct addrinfo hints = { .ai_family = AF_INET };\n\t\t\tstruct addrinfo *result = NULL;\n\n\t\t\tret = getaddrinfo(proxy_host, NULL, &hints, &result);\n\t\t\tif (ret) {\n\t\t\t\tif (ret == EAI_SYSTEM)\n\t\t\t\t\tlog_error(\"getaddrinfo: %s\\n\", strerror(errno));\n\t\t\t\telse\n\t\t\t\t\tlog_error(\"getaddrinfo: %s\\n\", gai_strerror(ret));\n\t\t\t\tgoto err_connect;\n\t\t\t}\n\n\t\t\tserver.sin_addr = ((struct sockaddr_in *)\n\t\t\t                   result->ai_addr)->sin_addr;\n\t\t\tfreeaddrinfo(result);\n\t\t}\n\t} else {\n\t\tserver.sin_port = htons(tunnel->config->gateway_port);\n\t\tserver.sin_addr = tunnel->config->gateway_ip;\n\t}\n\n\tlog_debug(\"server_addr: %s\\n\", inet_ntoa(server.sin_addr));\n\tlog_debug(\"server_port: %u\\n\", ntohs(server.sin_port));\n\tserver.sin_family = AF_INET;\n\tmemset(&(server.sin_zero), '\\0', 8);\n\tlog_debug(\"gateway_addr: %s\\n\", inet_ntoa(tunnel->config->gateway_ip));\n\tlog_debug(\"gateway_port: %u\\n\", tunnel->config->gateway_port);\n\n\tret = connect(handle, (struct sockaddr *) &server, sizeof(server));\n\tif (ret) {\n\t\tlog_error(\"connect: %s\\n\", strerror(errno));\n\t\tgoto err_connect;\n\t}\n\n\tif (env_proxy != NULL) {\n\t\tchar request[128];\n\n\t\t// https://tools.ietf.org/html/rfc7231#section-4.3.6\n\t\tsprintf(request, \"CONNECT %s:%u HTTP/1.1\\r\\nHost: %s:%u\\r\\n\\r\\n\",\n\t\t        inet_ntoa(tunnel->config->gateway_ip),\n\t\t        tunnel->config->gateway_port,\n\t\t        inet_ntoa(tunnel->config->gateway_ip),\n\t\t        tunnel->config->gateway_port);\n\t\tssize_t bytes_written = write(handle, request, strlen(request));\n\t\tif (bytes_written != strlen(request)) {\n\t\t\tlog_error(\"write error while talking to proxy: %s\\n\",\n\t\t\t          strerror(errno));\n\t\t\tgoto err_connect;\n\t\t}\n\n\t\t// wait for a \"200 OK\" reply from the proxy,\n\t\t// be careful not to fetch too many bytes at once\n\t\tconst char *response = NULL;\n\n\t\tmemset(&(request), '\\0', sizeof(request));\n\t\tfor (int j = 0; response == NULL; j++) {\n\t\t\t/*\n\t\t\t * Coverity detected a defect:\n\t\t\t *  CID 200508: String not null terminated (STRING_NULL)\n\t\t\t *\n\t\t\t * It is actually a false positive:\n\t\t\t * \u2022 Function memset() initializes 'request' with '\\0'\n\t\t\t * \u2022 Function read() gets a single char into: request[j]\n\t\t\t * \u2022 The final '\\0' cannot be overwritten because:\n\t\t\t *   \tj < ARRAY_SIZE(request) - 1\n\t\t\t */\n\t\t\tssize_t bytes_read = read(handle, &(request[j]), 1);\n\t\t\tif (bytes_read < 1) {\n\t\t\t\tlog_error(\"Proxy response is unexpectedly large and cannot fit in the %lu-bytes buffer.\\n\",\n\t\t\t\t          ARRAY_SIZE(request));\n\t\t\t\tgoto err_proxy_response;\n\t\t\t}\n\n\t\t\t// detect \"200\"\n\t\t\tstatic const char HTTP_STATUS_200[] = \"200\";\n\t\t\tresponse = strstr(request, HTTP_STATUS_200);\n\n\t\t\t// detect end-of-line after \"200\"\n\t\t\tif (response != NULL) {\n\t\t\t\t/*\n\t\t\t\t * RFC2616 states in section 2.2 Basic Rules:\n\t\t\t\t * \tCR     = <US-ASCII CR, carriage return (13)>\n\t\t\t\t * \tLF     = <US-ASCII LF, linefeed (10)>\n\t\t\t\t * \tHTTP/1.1 defines the sequence CR LF as the\n\t\t\t\t * \tend-of-line marker for all protocol elements\n\t\t\t\t * \texcept the entity-body (see appendix 19.3\n\t\t\t\t * \tfor tolerant applications).\n\t\t\t\t * \t\tCRLF   = CR LF\n\t\t\t\t *\n\t\t\t\t * RFC2616 states in section 19.3 Tolerant Applications:\n\t\t\t\t * \tThe line terminator for message-header fields\n\t\t\t\t * \tis the sequence CRLF. However, we recommend\n\t\t\t\t * \tthat applications, when parsing such headers,\n\t\t\t\t * \trecognize a single LF as a line terminator\n\t\t\t\t * \tand ignore the leading CR.\n\t\t\t\t */\n\t\t\t\tstatic const char *const HTTP_EOL[] = {\n\t\t\t\t\t\"\\r\\n\\r\\n\",\n\t\t\t\t\t\"\\n\\n\"\n\t\t\t\t};\n\t\t\t\tconst char *eol = NULL;\n\t\t\t\tfor (int i = 0; (i < ARRAY_SIZE(HTTP_EOL)) &&\n\t\t\t\t     (eol == NULL); i++)\n\t\t\t\t\teol = strstr(response, HTTP_EOL[i]);\n\t\t\t\tresponse = eol;\n\t\t\t}\n\n\t\t\tif (j > ARRAY_SIZE(request) - 2) {\n\t\t\t\tlog_error(\"Proxy response does not contain \\\"%s\\\" as expected.\\n\",\n\t\t\t\t          HTTP_STATUS_200);\n\t\t\t\tgoto err_proxy_response;\n\t\t\t}\n\t\t}\n\n\t\tfree(env_proxy); // release memory allocated by strdup()\n\t}\n\n\treturn handle;\n\nerr_proxy_response:\nerr_connect:\n\tfree(env_proxy); // release memory allocated by strdup()\nerr_strdup:\n\tclose(handle);\nerr_socket:\n\treturn -1;\n}\n\nstatic int ssl_verify_cert(struct tunnel *tunnel)\n{\n\tint ret = -1;\n\tint cert_valid = 0;\n\tunsigned char digest[SHA256LEN];\n\tunsigned int len;\n\tstruct x509_digest *elem;\n\tchar digest_str[SHA256STRLEN], *subject, *issuer;\n\tchar *line;\n\tint i;\n\tX509_NAME *subj;\n\tchar common_name[FIELD_SIZE + 1];\n\n\tSSL_set_verify(tunnel->ssl_handle, SSL_VERIFY_PEER, NULL);\n\n\tX509 *cert = SSL_get_peer_certificate(tunnel->ssl_handle);\n\tif (cert == NULL) {\n\t\tlog_error(\"Unable to get gateway certificate.\\n\");\n\t\treturn 1;\n\t}\n\n\tsubj = X509_get_subject_name(cert);\n\n#ifdef HAVE_X509_CHECK_HOST\n\t// Use OpenSSL native host validation if v >= 1.0.2.\n\t// correctly check return value of X509_check_host\n\tif (X509_check_host(cert, common_name, FIELD_SIZE, 0, NULL) == 1)\n\t\tcert_valid = 1;\n#else\n\t// Use explicit Common Name check if native validation not available.\n\t// Note: this will ignore Subject Alternative Name fields.\n\tif (subj\n\t    && X509_NAME_get_text_by_NID(subj, NID_commonName, common_name,\n\t                                 FIELD_SIZE) > 0\n\t    && strncasecmp(common_name, tunnel->config->gateway_host,\n\t                   FIELD_SIZE) == 0)\n\t\tcert_valid = 1;\n#endif\n\n\t// Try to validate certificate using local PKI\n\tif (cert_valid\n\t    && SSL_get_verify_result(tunnel->ssl_handle) == X509_V_OK) {\n\t\tlog_debug(\"Gateway certificate validation succeeded.\\n\");\n\t\tret = 0;\n\t\tgoto free_cert;\n\t}\n\tlog_debug(\"Gateway certificate validation failed.\\n\");\n\n\t// If validation failed, check if cert is in the white list\n\tif (X509_digest(cert, EVP_sha256(), digest, &len) <= 0\n\t    || len != SHA256LEN) {\n\t\tlog_error(\"Could not compute certificate sha256 digest.\\n\");\n\t\tgoto free_cert;\n\t}\n\t// Encode digest in base16\n\tfor (i = 0; i < SHA256LEN; i++)\n\t\tsprintf(&digest_str[2 * i], \"%02x\", digest[i]);\n\tdigest_str[SHA256STRLEN - 1] = '\\0';\n\t// Is it in whitelist?\n\tfor (elem = tunnel->config->cert_whitelist; elem != NULL;\n\t     elem = elem->next)\n\t\tif (memcmp(digest_str, elem->data, SHA256STRLEN - 1) == 0)\n\t\t\tbreak;\n\tif (elem != NULL) { // break before end of loop\n\t\tlog_debug(\"Gateway certificate digest found in white list.\\n\");\n\t\tret = 0;\n\t\tgoto free_cert;\n\t}\n\n\tsubject = X509_NAME_oneline(subj, NULL, 0);\n\tissuer = X509_NAME_oneline(X509_get_issuer_name(cert), NULL, 0);\n\n\tlog_error(\"Gateway certificate validation failed, and the certificate digest in not in the local whitelist. If you trust it, rerun with:\\n\");\n\tlog_error(\"    --trusted-cert %s\\n\", digest_str);\n\tlog_error(\"or add this line to your config file:\\n\");\n\tlog_error(\"    trusted-cert = %s\\n\", digest_str);\n\tlog_error(\"Gateway certificate:\\n\");\n\tlog_error(\"    subject:\\n\");\n\tfor (line = strtok(subject, \"/\"); line != NULL;\n\t     line = strtok(NULL, \"/\"))\n\t\tlog_error(\"        %s\\n\", line);\n\tlog_error(\"    issuer:\\n\");\n\tfor (line = strtok(issuer, \"/\"); line != NULL;\n\t     line = strtok(NULL, \"/\"))\n\t\tlog_error(\"        %s\\n\", line);\n\tlog_error(\"    sha256 digest:\\n\");\n\tlog_error(\"        %s\\n\", digest_str);\n\nfree_cert:\n\tX509_free(cert);\n\treturn ret;\n}\n\n/*\n * Destroy and free the SSL connection to the gateway.\n */\nstatic void ssl_disconnect(struct tunnel *tunnel)\n{\n\tif (!tunnel->ssl_handle)\n\t\treturn;\n\n\tSSL_shutdown(tunnel->ssl_handle);\n\tSSL_free(tunnel->ssl_handle);\n\tSSL_CTX_free(tunnel->ssl_context);\n\tclose(tunnel->ssl_socket);\n\n\ttunnel->ssl_handle = NULL;\n\ttunnel->ssl_context = NULL;\n}\n\n/*\n * Connects to the gateway and initiate an SSL session.\n */\nint ssl_connect(struct tunnel *tunnel)\n{\n\tssl_disconnect(tunnel);\n\n\ttunnel->ssl_socket = tcp_connect(tunnel);\n\tif (tunnel->ssl_socket == -1)\n\t\treturn 1;\n\n\t// registration is deprecated from OpenSSL 1.1.0 onward\n#if OPENSSL_API_COMPAT < 0x10100000L\n\t// Register the error strings for libcrypto & libssl\n\tSSL_load_error_strings();\n\t// Register the available ciphers and digests\n\tSSL_library_init();\n#endif\n\n\ttunnel->ssl_context = SSL_CTX_new(SSLv23_client_method());\n\tif (tunnel->ssl_context == NULL) {\n\t\tlog_error(\"SSL_CTX_new: %s\\n\",\n\t\t          ERR_error_string(ERR_peek_last_error(), NULL));\n\t\treturn 1;\n\t}\n\n\t// Load the OS default CA files\n\tif (!SSL_CTX_set_default_verify_paths(tunnel->ssl_context))\n\t\tlog_error(\"Could not load OS OpenSSL files.\\n\");\n\n\tif (tunnel->config->ca_file) {\n\t\tif (!SSL_CTX_load_verify_locations(\n\t\t            tunnel->ssl_context,\n\t\t            tunnel->config->ca_file, NULL)) {\n\t\t\tlog_error(\"SSL_CTX_load_verify_locations: %s\\n\",\n\t\t\t          ERR_error_string(ERR_peek_last_error(), NULL));\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/* Use engine for PIV if user-cert config starts with pkcs11 URI: */\n\tif (tunnel->config->use_engine > 0) {\n\n\t\tENGINE *e;\n\t\tENGINE_load_builtin_engines();\n\t\te = ENGINE_by_id(\"pkcs11\");\n\t\tif (!e) {\n\t\t\tlog_error(\"Could not load pkcs11 Engine: %s\\n\",\n\t\t\t          ERR_error_string(ERR_peek_last_error(), NULL));\n\t\t\treturn 1;\n\t\t}\n\t\tif (!ENGINE_init(e)) {\n\t\t\tlog_error(\"Could not init pkcs11 Engine: %s\\n\",\n\t\t\t          ERR_error_string(ERR_peek_last_error(), NULL));\n\t\t\tENGINE_free(e);\n\t\t\treturn 1;\n\t\t}\n\t\tif (!ENGINE_set_default_RSA(e))\n\t\t\tabort();\n\n\t\tENGINE_finish(e);\n\t\tENGINE_free(e);\n\n\t\tstruct token parms;\n\t\tparms.uri = tunnel->config->user_cert;\n\t\tparms.cert = NULL;\n\n\t\tif (!ENGINE_ctrl_cmd(e, \"LOAD_CERT_CTRL\", 0, &parms, NULL, 1)) {\n\t\t\tlog_error(\"PKCS11 ENGINE_ctrl_cmd: %s\\n\",\n\t\t\t          ERR_error_string(ERR_peek_last_error(), NULL));\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (!SSL_CTX_use_certificate(tunnel->ssl_context, parms.cert)) {\n\t\t\tlog_error(\"PKCS11 SSL_CTX_use_certificate: %s\\n\",\n\t\t\t          ERR_error_string(ERR_peek_last_error(), NULL));\n\t\t\treturn 1;\n\t\t}\n\n\t\tEVP_PKEY * privkey = ENGINE_load_private_key(\n\t\t                             e, parms.uri, UI_OpenSSL(), NULL);\n\t\tif (!privkey) {\n\t\t\tlog_error(\"PKCS11 ENGINE_load_private_key: %s\\n\",\n\t\t\t          ERR_error_string(ERR_peek_last_error(), NULL));\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (!SSL_CTX_use_PrivateKey(tunnel->ssl_context, privkey)) {\n\t\t\tlog_error(\"PKCS11 SSL_CTX_use_PrivateKey_file: %s\\n\",\n\t\t\t          ERR_error_string(ERR_peek_last_error(), NULL));\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (!SSL_CTX_check_private_key(tunnel->ssl_context)) {\n\t\t\tlog_error(\"PKCS11 SSL_CTX_check_private_key: %s\\n\",\n\t\t\t          ERR_error_string(ERR_peek_last_error(), NULL));\n\t\t\treturn 1;\n\t\t}\n\n\t} else {        /* end PKCS11-engine */\n\n\t\tif (tunnel->config->user_cert) {\n\t\t\tif (!SSL_CTX_use_certificate_file(\n\t\t\t            tunnel->ssl_context, tunnel->config->user_cert,\n\t\t\t            SSL_FILETYPE_PEM)) {\n\t\t\t\tlog_error(\"SSL_CTX_use_certificate_file: %s\\n\",\n\t\t\t\t          ERR_error_string(ERR_peek_last_error(), NULL));\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\n\t\tif (tunnel->config->user_key) {\n\t\t\tif (!SSL_CTX_use_PrivateKey_file(\n\t\t\t            tunnel->ssl_context, tunnel->config->user_key,\n\t\t\t            SSL_FILETYPE_PEM)) {\n\t\t\t\tlog_error(\"SSL_CTX_use_PrivateKey_file: %s\\n\",\n\t\t\t\t          ERR_error_string(ERR_peek_last_error(), NULL));\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\n\t\tif (tunnel->config->user_cert && tunnel->config->user_key) {\n\t\t\tif (!SSL_CTX_check_private_key(tunnel->ssl_context)) {\n\t\t\t\tlog_error(\"SSL_CTX_check_private_key: %s\\n\",\n\t\t\t\t          ERR_error_string(ERR_peek_last_error(), NULL));\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!tunnel->config->insecure_ssl) {\n\t\tlong sslctxopt = SSL_OP_NO_SSLv3 | SSL_OP_NO_COMPRESSION;\n\t\tlong checkopt;\n\n\t\tcheckopt = SSL_CTX_set_options(tunnel->ssl_context, sslctxopt);\n\t\tif ((checkopt & sslctxopt) != sslctxopt) {\n\t\t\tlog_error(\"SSL_CTX_set_options didn't set opt: %s\\n\",\n\t\t\t          ERR_error_string(ERR_peek_last_error(), NULL));\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\ttunnel->ssl_handle = SSL_new(tunnel->ssl_context);\n\tif (tunnel->ssl_handle == NULL) {\n\t\tlog_error(\"SSL_new: %s\\n\",\n\t\t          ERR_error_string(ERR_peek_last_error(), NULL));\n\t\treturn 1;\n\t}\n\n\tif (!tunnel->config->insecure_ssl) {\n\t\tif (!tunnel->config->cipher_list) {\n\t\t\tconst char *cipher_list;\n\t\t\tif (tunnel->config->seclevel_1)\n\t\t\t\tcipher_list = \"HIGH:!aNULL:!kRSA:!PSK:!SRP:!MD5:!RC4@SECLEVEL=1\";\n\t\t\telse\n\t\t\t\tcipher_list = \"HIGH:!aNULL:!kRSA:!PSK:!SRP:!MD5:!RC4\";\n\t\t\ttunnel->config->cipher_list = strdup(cipher_list);\n\t\t}\n\t} else {\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\t\tif (tunnel->config->min_tls <= 0)\n\t\t\ttunnel->config->min_tls = TLS1_VERSION;\n#endif\n\t\tif (!tunnel->config->cipher_list && tunnel->config->seclevel_1) {\n\t\t\tconst char *cipher_list = \"DEFAULT@SECLEVEL=1\";\n\t\t\ttunnel->config->cipher_list = strdup(cipher_list);\n\t\t}\n\t}\n\n\tif (tunnel->config->cipher_list) {\n\t\tlog_debug(\"Setting cipher list to: %s\\n\", tunnel->config->cipher_list);\n\t\tif (!SSL_set_cipher_list(tunnel->ssl_handle,\n\t\t                         tunnel->config->cipher_list)) {\n\t\t\tlog_error(\"SSL_set_cipher_list failed: %s\\n\",\n\t\t\t          ERR_error_string(ERR_peek_last_error(), NULL));\n\t\t\treturn 1;\n\t\t}\n\t}\n\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\tif (tunnel->config->min_tls > 0) {\n\t\tlog_debug(\"Setting min proto version to: 0x%x\\n\",\n\t\t          tunnel->config->min_tls);\n\t\tif (!SSL_set_min_proto_version(tunnel->ssl_handle,\n\t\t                               tunnel->config->min_tls)) {\n\t\t\tlog_error(\"SSL_set_min_proto_version failed: %s\\n\",\n\t\t\t          ERR_error_string(ERR_peek_last_error(), NULL));\n\t\t\treturn 1;\n\t\t}\n\t}\n#endif\n\n\tif (!SSL_set_fd(tunnel->ssl_handle, tunnel->ssl_socket)) {\n\t\tlog_error(\"SSL_set_fd: %s\\n\",\n\t\t          ERR_error_string(ERR_peek_last_error(), NULL));\n\t\treturn 1;\n\t}\n\tSSL_set_mode(tunnel->ssl_handle, SSL_MODE_AUTO_RETRY);\n\n\t// Initiate SSL handshake\n\tif (SSL_connect(tunnel->ssl_handle) != 1) {\n\t\tlog_error(\"SSL_connect: %s\\n\"\n\t\t          \"You might want to try --insecure-ssl or specify a different --cipher-list\\n\",\n\t\t          ERR_error_string(ERR_peek_last_error(), NULL));\n\t\treturn 1;\n\t}\n\tSSL_set_mode(tunnel->ssl_handle, SSL_MODE_AUTO_RETRY);\n\n\tif (ssl_verify_cert(tunnel))\n\t\treturn 1;\n\n\t// Disable SIGPIPE (occurs when trying to write to an already-closed\n\t// socket).\n\tsignal(SIGPIPE, SIG_IGN);\n\n\treturn 0;\n}\n\nint run_tunnel(struct vpn_config *config)\n{\n\tint ret;\n\tstruct tunnel tunnel = {\n\t\t.config = config,\n\t\t.state = STATE_DOWN,\n\t\t.ssl_context = NULL,\n\t\t.ssl_handle = NULL,\n\t\t.ipv4.ns1_addr.s_addr = 0,\n\t\t.ipv4.ns2_addr.s_addr = 0,\n\t\t.ipv4.dns_suffix = NULL,\n\t\t.on_ppp_if_up = on_ppp_if_up,\n\t\t.on_ppp_if_down = on_ppp_if_down\n\t};\n\n\t// Step 0: get gateway host IP\n\tlog_debug(\"Resolving gateway host ip\\n\");\n\tret = get_gateway_host_ip(&tunnel);\n\tif (ret)\n\t\tgoto err_tunnel;\n\n\t// Step 1: open a SSL connection to the gateway\n\tlog_debug(\"Establishing ssl connection\\n\");\n\tret = ssl_connect(&tunnel);\n\tif (ret)\n\t\tgoto err_tunnel;\n\tlog_info(\"Connected to gateway.\\n\");\n\n\t// Step 2: connect to the HTTP interface and authenticate to get a\n\t// cookie\n\tret = auth_log_in(&tunnel);\n\tif (ret != 1) {\n\t\tlog_error(\"Could not authenticate to gateway. Please check the password, client certificate, etc.\\n\");\n\t\tlog_debug(\"%s %d\\n\", err_http_str(ret), ret);\n\t\tret = 1;\n\t\tgoto err_tunnel;\n\t}\n\tlog_info(\"Authenticated.\\n\");\n\tlog_debug(\"Cookie: %s\\n\", tunnel.cookie);\n\n\tret = auth_request_vpn_allocation(&tunnel);\n\tif (ret != 1) {\n\t\tlog_error(\"VPN allocation request failed (%s).\\n\",\n\t\t          err_http_str(ret));\n\t\tret = 1;\n\t\tgoto err_tunnel;\n\t}\n\tlog_info(\"Remote gateway has allocated a VPN.\\n\");\n\n\tret = ssl_connect(&tunnel);\n\tif (ret)\n\t\tgoto err_tunnel;\n\n\t// Step 3: get configuration\n\tlog_debug(\"Retrieving configuration\\n\");\n\tret = auth_get_config(&tunnel);\n\tif (ret != 1) {\n\t\tlog_error(\"Could not get VPN configuration (%s).\\n\",\n\t\t          err_http_str(ret));\n\t\tret = 1;\n\t\tgoto err_tunnel;\n\t}\n\n\t// Step 4: run a pppd process\n\tlog_debug(\"Establishing the tunnel\\n\");\n\tret = pppd_run(&tunnel);\n\tif (ret)\n\t\tgoto err_tunnel;\n\n\t// Step 5: ask gateway to start tunneling\n\tlog_debug(\"Switch to tunneling mode\\n\");\n\tret = http_send(&tunnel,\n\t                \"GET /remote/sslvpn-tunnel HTTP/1.1\\r\\n\"\n\t                \"Host: sslvpn\\r\\n\"\n\t                \"Cookie: %s\\r\\n\\r\\n\",\n\t                tunnel.cookie);\n\tif (ret != 1) {\n\t\tlog_error(\"Could not start tunnel (%s).\\n\", err_http_str(ret));\n\t\tret = 1;\n\t\tgoto err_start_tunnel;\n\t}\n\n\ttunnel.state = STATE_CONNECTING;\n\tret = 0;\n\n\t// Step 6: perform io between pppd and the gateway, while tunnel is up\n\tlog_debug(\"Starting IO through the tunnel\\n\");\n\tio_loop(&tunnel);\n\n\tlog_debug(\"disconnecting\\n\");\n\tif (tunnel.state == STATE_UP)\n\t\tif (tunnel.on_ppp_if_down != NULL)\n\t\t\ttunnel.on_ppp_if_down(&tunnel);\n\n\ttunnel.state = STATE_DISCONNECTING;\n\nerr_start_tunnel:\n\tpppd_terminate(&tunnel);\n\tlog_info(\"Terminated %s.\\n\", PPP_DAEMON);\nerr_tunnel:\n\tlog_info(\"Closed connection to gateway.\\n\");\n\ttunnel.state = STATE_DOWN;\n\n\tif (ssl_connect(&tunnel)) {\n\t\tlog_info(\"Could not log out.\\n\");\n\t} else {\n\t\tauth_log_out(&tunnel);\n\t\tlog_info(\"Logged out.\\n\");\n\t}\n\n\t// explicitly free the buffer allocated for split routes of the ipv4 config\n\tif (tunnel.ipv4.split_rt != NULL) {\n\t\tfree(tunnel.ipv4.split_rt);\n\t\ttunnel.ipv4.split_rt = NULL;\n\t}\n\treturn ret;\n}\n"], "fixing_code": ["/*\n *  Copyright (C) 2015 Adrien Verg\u00e9\n *\n *  This program is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  In addition, as a special exception, the copyright holders give permission\n *  to link the code of portions of this program with the OpenSSL library under\n *  certain conditions as described in each individual source file, and\n *  distribute linked combinations including the two.\n *  You must obey the GNU General Public License in all respects for all of the\n *  code used other than OpenSSL.  If you modify file(s) with this exception,\n *  you may extend this exception to your version of the file(s), but you are\n *  not obligated to do so.  If you do not wish to do so, delete this exception\n *  statement from your version.  If you delete this exception statement from\n *  all source files in the program, then also delete it here.\n */\n\n#include \"tunnel.h\"\n#include \"http.h\"\n#include \"log.h\"\n\n#include <unistd.h>\n#include <fcntl.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <errno.h>\n#include <string.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <openssl/err.h>\n#include <openssl/x509v3.h>\n#include <openssl/engine.h>\n#if HAVE_PTY_H\n#include <pty.h>\n#elif HAVE_UTIL_H\n#include <util.h>\n#endif\n#include <termios.h>\n#include <signal.h>\n#include <sys/wait.h>\n#if HAVE_SYSTEMD\n#include <systemd/sd-daemon.h>\n#endif\n\n// we use this constant in the source, so define a fallback if not defined\n#ifndef OPENSSL_API_COMPAT\n#define OPENSSL_API_COMPAT 0x0908000L\n#endif\n\nstruct ofv_varr {\n\tunsigned int cap;\t// current capacity\n\tunsigned int off;\t// next slot to write, always < max(cap - 1, 1)\n\tconst char **data;\t// NULL terminated\n};\n\nstatic int ofv_append_varr(struct ofv_varr *p, const char *x)\n{\n\tif (p->off + 1 >= p->cap) {\n\t\tconst char **ndata;\n\t\tunsigned int ncap = (p->off + 1) * 2;\n\t\tif (p->off + 1 >= ncap) {\n\t\t\tlog_error(\"%s: ncap exceeded\\n\", __func__);\n\t\t\treturn 1;\n\t\t};\n\t\tndata = realloc(p->data, ncap * sizeof(const char *));\n\t\tif (ndata) {\n\t\t\tp->data = ndata;\n\t\t\tp->cap = ncap;\n\t\t} else {\n\t\t\tlog_error(\"realloc: %s\\n\", strerror(errno));\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif (p->data == NULL) {\n\t\tlog_error(\"%s: NULL data\\n\", __func__);\n\t\treturn 1;\n\t}\n\tif (p->off + 1 >= p->cap) {\n\t\tlog_error(\"%s: cap exceeded in p\\n\", __func__);\n\t\treturn 1;\n\t}\n\tp->data[p->off] = x;\n\tp->data[++p->off] = NULL;\n\treturn 0;\n}\n\nstatic int on_ppp_if_up(struct tunnel *tunnel)\n{\n\tlog_info(\"Interface %s is UP.\\n\", tunnel->ppp_iface);\n\n\tif (tunnel->config->set_routes) {\n\t\tint ret;\n\n\t\tlog_info(\"Setting new routes...\\n\");\n\n\t\tret = ipv4_set_tunnel_routes(tunnel);\n\n\t\tif (ret != 0)\n\t\t\tlog_warn(\"Adding route table is incomplete. Please check route table.\\n\");\n\t}\n\n\tif (tunnel->config->set_dns) {\n\t\tlog_info(\"Adding VPN nameservers...\\n\");\n\t\tipv4_add_nameservers_to_resolv_conf(tunnel);\n\t}\n\n\tlog_info(\"Tunnel is up and running.\\n\");\n\n#if HAVE_SYSTEMD\n\tsd_notify(0, \"READY=1\");\n#endif\n\n\treturn 0;\n}\n\nstatic int on_ppp_if_down(struct tunnel *tunnel)\n{\n\tlog_info(\"Setting ppp interface down.\\n\");\n\n\tif (tunnel->config->set_routes) {\n\t\tlog_info(\"Restoring routes...\\n\");\n\t\tipv4_restore_routes(tunnel);\n\t}\n\n\tif (tunnel->config->set_dns) {\n\t\tlog_info(\"Removing VPN nameservers...\\n\");\n\t\tipv4_del_nameservers_from_resolv_conf(tunnel);\n\t}\n\n\treturn 0;\n}\n\nstatic int pppd_run(struct tunnel *tunnel)\n{\n\tpid_t pid;\n\tint amaster;\n\tint slave_stderr;\n\n#ifdef HAVE_STRUCT_TERMIOS\n\tstruct termios termp = {\n\t\t.c_cflag = B9600,\n\t\t.c_cc[VTIME] = 0,\n\t\t.c_cc[VMIN] = 1\n\t};\n#endif\n\n\tstatic const char ppp_path[] = PPP_PATH;\n\tif (access(ppp_path, F_OK) != 0) {\n\t\tlog_error(\"%s: %s.\\n\", ppp_path, strerror(errno));\n\t\treturn 1;\n\t}\n\tlog_debug(\"ppp_path: %s\\n\", ppp_path);\n\n\tslave_stderr = dup(STDERR_FILENO);\n\n\tif (slave_stderr < 0) {\n\t\tlog_error(\"slave stderr %s\\n\", strerror(errno));\n\t\treturn 1;\n\t}\n\n#ifdef HAVE_STRUCT_TERMIOS\n\tpid = forkpty(&amaster, NULL, &termp, NULL);\n#else\n\tpid = forkpty(&amaster, NULL, NULL, NULL);\n#endif\n\n\tif (pid == 0) { // child process\n\n\t\tstruct ofv_varr pppd_args = { 0, 0, NULL };\n\n\t\tdup2(slave_stderr, STDERR_FILENO);\n\t\tclose(slave_stderr);\n\n#if HAVE_USR_SBIN_PPP\n\t\t/*\n\t\t * assume there is a default configuration to start.\n\t\t * Support for taking options from the command line\n\t\t * e.g. the name of the configuration or options\n\t\t * to send interactively to ppp will be added later\n\t\t */\n\t\tstatic const char *const v[] = {\n\t\t\tppp_path,\n\t\t\t\"-direct\"\n\t\t};\n\t\tfor (unsigned int i = 0; i < ARRAY_SIZE(v); i++)\n\t\t\tif (ofv_append_varr(&pppd_args, v[i]))\n\t\t\t\treturn 1;\n#endif\n#if HAVE_USR_SBIN_PPPD\n\t\tif (tunnel->config->pppd_call) {\n\t\t\tif (ofv_append_varr(&pppd_args, ppp_path))\n\t\t\t\treturn 1;\n\t\t\tif (ofv_append_varr(&pppd_args, \"call\"))\n\t\t\t\treturn 1;\n\t\t\tif (ofv_append_varr(&pppd_args, tunnel->config->pppd_call))\n\t\t\t\treturn 1;\n\t\t} else {\n\t\t\tstatic const char *const v[] = {\n\t\t\t\tppp_path,\n\t\t\t\t\"115200\", // speed\n\t\t\t\t\":192.0.2.1\", // <local_IP_address>:<remote_IP_address>\n\t\t\t\t\"noipdefault\",\n\t\t\t\t\"noaccomp\",\n\t\t\t\t\"noauth\",\n\t\t\t\t\"default-asyncmap\",\n\t\t\t\t\"nopcomp\",\n\t\t\t\t\"receive-all\",\n\t\t\t\t\"nodefaultroute\",\n\t\t\t\t\"nodetach\",\n\t\t\t\t\"lcp-max-configure\", \"40\",\n\t\t\t\t\"mru\", \"1354\"\n\t\t\t};\n\t\t\tfor (unsigned int i = 0; i < ARRAY_SIZE(v); i++)\n\t\t\t\tif (ofv_append_varr(&pppd_args, v[i]))\n\t\t\t\t\treturn 1;\n\t\t}\n\t\tif (tunnel->config->pppd_use_peerdns)\n\t\t\tif (ofv_append_varr(&pppd_args, \"usepeerdns\"))\n\t\t\t\treturn 1;\n\t\tif (tunnel->config->pppd_log) {\n\t\t\tif (ofv_append_varr(&pppd_args, \"debug\"))\n\t\t\t\treturn 1;\n\t\t\tif (ofv_append_varr(&pppd_args, \"logfile\"))\n\t\t\t\treturn 1;\n\t\t\tif (ofv_append_varr(&pppd_args, tunnel->config->pppd_log))\n\t\t\t\treturn 1;\n\t\t} else {\n\t\t\t/*\n\t\t\t * pppd defaults to logging to fd=1, clobbering the\n\t\t\t * actual PPP data\n\t\t\t */\n\t\t\tif (ofv_append_varr(&pppd_args, \"logfd\"))\n\t\t\t\treturn 1;\n\t\t\tif (ofv_append_varr(&pppd_args, \"2\"))\n\t\t\t\treturn 1;\n\t\t}\n\t\tif (tunnel->config->pppd_plugin) {\n\t\t\tif (ofv_append_varr(&pppd_args, \"plugin\"))\n\t\t\t\treturn 1;\n\t\t\tif (ofv_append_varr(&pppd_args, tunnel->config->pppd_plugin))\n\t\t\t\treturn 1;\n\t\t}\n\t\tif (tunnel->config->pppd_ipparam) {\n\t\t\tif (ofv_append_varr(&pppd_args, \"ipparam\"))\n\t\t\t\treturn 1;\n\t\t\tif (ofv_append_varr(&pppd_args, tunnel->config->pppd_ipparam))\n\t\t\t\treturn 1;\n\t\t}\n\t\tif (tunnel->config->pppd_ifname) {\n\t\t\tif (ofv_append_varr(&pppd_args, \"ifname\"))\n\t\t\t\treturn 1;\n\t\t\tif (ofv_append_varr(&pppd_args, tunnel->config->pppd_ifname))\n\t\t\t\treturn 1;\n\t\t}\n#endif\n#if HAVE_USR_SBIN_PPP\n\t\tif (tunnel->config->ppp_system) {\n\t\t\tif (ofv_append_varr(&pppd_args, tunnel->config->ppp_system))\n\t\t\t\treturn 1;\n\t\t}\n#endif\n\n\t\tclose(tunnel->ssl_socket);\n\t\texecv(pppd_args.data[0], (char *const *)pppd_args.data);\n\t\tfree(pppd_args.data);\n\n\t\tfprintf(stderr, \"execvp: %s\\n\", strerror(errno));\n\t\t_exit(EXIT_FAILURE);\n\t} else {\n\t\tclose(slave_stderr);\n\t\tif (pid == -1) {\n\t\t\tlog_error(\"forkpty: %s\\n\", strerror(errno));\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t// Set non-blocking\n\tint flags = fcntl(amaster, F_GETFL, 0);\n\tif (flags == -1)\n\t\tflags = 0;\n\tif (fcntl(amaster, F_SETFL, flags | O_NONBLOCK) == -1) {\n\t\tlog_error(\"fcntl: %s\\n\", strerror(errno));\n\t\treturn 1;\n\t}\n\n\ttunnel->pppd_pid = pid;\n\ttunnel->pppd_pty = amaster;\n\n\treturn 0;\n}\n\nstatic const char * const pppd_message[] = {\n\t\"Has detached, or otherwise the connection was successfully established and terminated at the peer's request.\",\n\t\"An immediately fatal error of some kind occurred, such as an essential system call failing, or running out of virtual memory.\",\n\t\"An error was detected in processing the options given, such as two mutually exclusive options being used.\",\n\t\"Is not setuid-root and the invoking user is not root.\",\n\t\"The kernel does not support PPP, for example, the PPP kernel driver is not included or cannot be loaded.\",\n\t\"Terminated because it was sent a SIGINT, SIGTERM or SIGHUP signal.\",\n\t\"The serial port could not be locked.\",\n\t\"The serial port could not be opened.\",\n\t\"The connect script failed (returned a non-zero exit status).\",\n\t\"The command specified as the argument to the pty option could not be run.\",\n\t\"The PPP negotiation failed, that is, it didn't reach the point where at least one network protocol (e.g. IP) was running.\",\n\t\"The peer system failed (or refused) to authenticate itself.\",\n\t\"The link was established successfully and terminated because it was idle.\",\n\t\"The link was established successfully and terminated because the connect time limit was reached.\",\n\t\"Callback was negotiated and an incoming call should arrive shortly.\",\n\t\"The link was terminated because the peer is not responding to echo requests.\",\n\t\"The link was terminated by the modem hanging up.\",\n\t\"The PPP negotiation failed because serial loopback was detected.\",\n\t\"The init script failed (returned a non-zero exit status).\",\n\t\"We failed to authenticate ourselves to the peer.\"\n};\n\nstatic int pppd_terminate(struct tunnel *tunnel)\n{\n\tclose(tunnel->pppd_pty);\n\n\tlog_debug(\"Waiting for %s to exit...\\n\", PPP_DAEMON);\n\n\tint status;\n\tif (waitpid(tunnel->pppd_pid, &status, 0) == -1) {\n\t\tlog_error(\"waitpid: %s\\n\", strerror(errno));\n\t\treturn 1;\n\t}\n\tif (WIFEXITED(status)) {\n\t\tint exit_status = WEXITSTATUS(status);\n\t\tlog_debug(\"waitpid: %s exit status code %d\\n\",\n\t\t          PPP_DAEMON, exit_status);\n#if HAVE_USR_SBIN_PPPD\n\t\tif (exit_status >= ARRAY_SIZE(pppd_message) || exit_status < 0) {\n\t\t\tlog_error(\"%s: Returned an unknown exit status: %d\\n\",\n\t\t\t          PPP_DAEMON, exit_status);\n\t\t} else {\n\t\t\tswitch (exit_status) {\n\t\t\tcase 0: // success\n\t\t\t\tlog_debug(\"%s: %s\\n\",\n\t\t\t\t          PPP_DAEMON, pppd_message[exit_status]);\n\t\t\t\tbreak;\n\t\t\tcase 16: // emitted when exiting normally\n\t\t\t\tlog_info(\"%s: %s\\n\",\n\t\t\t\t         PPP_DAEMON, pppd_message[exit_status]);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tlog_error(\"%s: %s\\n\",\n\t\t\t\t          PPP_DAEMON, pppd_message[exit_status]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n#else\n\t\t// ppp exit codes in the FreeBSD case\n\t\tswitch (exit_status) {\n\t\tcase 0: // success and EX_NORMAL as defined in ppp source directly\n\t\t\tlog_debug(\"%s: %s\\n\", PPP_DAEMON, pppd_message[exit_status]);\n\t\t\tbreak;\n\t\tcase 1:\n\t\tcase 127:\n\t\tcase 255: // abnormal exit with hard-coded error codes in ppp\n\t\t\tlog_error(\"%s: exited with return value of %d\\n\",\n\t\t\t          PPP_DAEMON, exit_status);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_error(\"%s: %s (%d)\\n\", PPP_DAEMON, strerror(exit_status),\n\t\t\t          exit_status);\n\t\t\tbreak;\n\t\t}\n#endif\n\t} else if (WIFSIGNALED(status)) {\n\t\tint signal_number = WTERMSIG(status);\n\t\tlog_debug(\"waitpid: %s terminated by signal %d\\n\",\n\t\t          PPP_DAEMON, signal_number);\n\t\tlog_error(\"%s: terminated by signal: %s\\n\",\n\t\t          PPP_DAEMON, strsignal(signal_number));\n\t}\n\n\treturn 0;\n}\n\nint ppp_interface_is_up(struct tunnel *tunnel)\n{\n\tstruct ifaddrs *ifap, *ifa;\n\n\tlog_debug(\"Got Address: %s\\n\", inet_ntoa(tunnel->ipv4.ip_addr));\n\n\tif (getifaddrs(&ifap)) {\n\t\tlog_error(\"getifaddrs: %s\\n\", strerror(errno));\n\t\treturn 0;\n\t}\n\n\tfor (ifa = ifap; ifa != NULL; ifa = ifa->ifa_next) {\n\t\tif ((\n#if HAVE_USR_SBIN_PPPD\n\t\t            (tunnel->config->pppd_ifname\n\t\t             && strstr(ifa->ifa_name, tunnel->config->pppd_ifname)\n\t\t             != NULL)\n\t\t            || strstr(ifa->ifa_name, \"ppp\") != NULL\n#endif\n#if HAVE_USR_SBIN_PPP\n\t\t            strstr(ifa->ifa_name, \"tun\") != NULL\n#endif\n\t\t    ) && ifa->ifa_flags & IFF_UP) {\n\t\t\tif (&(ifa->ifa_addr->sa_family) != NULL\n\t\t\t    && ifa->ifa_addr->sa_family == AF_INET) {\n\t\t\t\tstruct in_addr if_ip_addr =\n\t\t\t\t        cast_addr(ifa->ifa_addr)->sin_addr;\n\n\t\t\t\tlog_debug(\"Interface Name: %s\\n\", ifa->ifa_name);\n\t\t\t\tlog_debug(\"Interface Addr: %s\\n\", inet_ntoa(if_ip_addr));\n\n\t\t\t\tif (tunnel->ipv4.ip_addr.s_addr == if_ip_addr.s_addr) {\n\t\t\t\t\tstrncpy(tunnel->ppp_iface, ifa->ifa_name,\n\t\t\t\t\t        ROUTE_IFACE_LEN - 1);\n\t\t\t\t\tfreeifaddrs(ifap);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfreeifaddrs(ifap);\n\n\treturn 0;\n}\n\nstatic int get_gateway_host_ip(struct tunnel *tunnel)\n{\n\tconst struct addrinfo hints = { .ai_family = AF_INET };\n\tstruct addrinfo *result = NULL;\n\n\tint ret = getaddrinfo(tunnel->config->gateway_host, NULL, &hints, &result);\n\n\tif (ret) {\n\t\tif (ret == EAI_SYSTEM)\n\t\t\tlog_error(\"getaddrinfo: %s\\n\", strerror(errno));\n\t\telse\n\t\t\tlog_error(\"getaddrinfo: %s\\n\", gai_strerror(ret));\n\t\treturn 1;\n\t}\n\n\ttunnel->config->gateway_ip = ((struct sockaddr_in *)\n\t                              result->ai_addr)->sin_addr;\n\tfreeaddrinfo(result);\n\n\tsetenv(\"VPN_GATEWAY\", inet_ntoa(tunnel->config->gateway_ip), 0);\n\n\treturn 0;\n}\n\n/*\n * Establish a regular TCP connection.\n */\nstatic int tcp_connect(struct tunnel *tunnel)\n{\n\tint ret, handle;\n\tstruct sockaddr_in server;\n\tchar *env_proxy;\n\n\thandle = socket(AF_INET, SOCK_STREAM, 0);\n\tif (handle == -1) {\n\t\tlog_error(\"socket: %s\\n\", strerror(errno));\n\t\tgoto err_socket;\n\t}\n\tenv_proxy = getenv(\"https_proxy\");\n\tif (env_proxy == NULL)\n\t\tenv_proxy = getenv(\"HTTPS_PROXY\");\n\tif (env_proxy == NULL)\n\t\tenv_proxy = getenv(\"all_proxy\");\n\tif (env_proxy == NULL)\n\t\tenv_proxy = getenv(\"ALL_PROXY\");\n\tif (env_proxy != NULL) {\n\t\tchar *proxy_host, *proxy_port;\n\t\t// protect the original environment from modifications\n\t\tenv_proxy = strdup(env_proxy);\n\t\tif (env_proxy == NULL) {\n\t\t\tlog_error(\"strdup: %s\\n\", strerror(errno));\n\t\t\tgoto err_strdup;\n\t\t}\n\t\t// get rid of a trailing slash\n\t\tif (*env_proxy && env_proxy[strlen(env_proxy) - 1] == '/')\n\t\t\tenv_proxy[strlen(env_proxy) - 1] = '\\0';\n\t\t// get rid of a http(s):// prefix in env_proxy\n\t\tproxy_host = strstr(env_proxy, \"://\");\n\t\tif (proxy_host == NULL)\n\t\t\tproxy_host = env_proxy;\n\t\telse\n\t\t\tproxy_host += 3;\n\t\t// split host and port\n\t\tproxy_port = index(proxy_host, ':');\n\t\tif (proxy_port != NULL) {\n\t\t\tproxy_port[0] = '\\0';\n\t\t\tproxy_port++;\n\t\t\tserver.sin_port = htons(strtoul(proxy_port, NULL, 10));\n\t\t} else {\n\t\t\tserver.sin_port = htons(tunnel->config->gateway_port);\n\t\t}\n\t\t// get rid of a trailing slash\n\t\tif (*proxy_host && proxy_host[strlen(proxy_host) - 1] == '/')\n\t\t\tproxy_host[strlen(proxy_host) - 1] = '\\0';\n\t\tlog_debug(\"proxy_host: %s\\n\", proxy_host);\n\t\tlog_debug(\"proxy_port: %s\\n\", proxy_port);\n\t\tserver.sin_addr.s_addr = inet_addr(proxy_host);\n\t\t// if host is given as a FQDN we have to do a DNS lookup\n\t\tif (server.sin_addr.s_addr == INADDR_NONE) {\n\t\t\tconst struct addrinfo hints = { .ai_family = AF_INET };\n\t\t\tstruct addrinfo *result = NULL;\n\n\t\t\tret = getaddrinfo(proxy_host, NULL, &hints, &result);\n\t\t\tif (ret) {\n\t\t\t\tif (ret == EAI_SYSTEM)\n\t\t\t\t\tlog_error(\"getaddrinfo: %s\\n\", strerror(errno));\n\t\t\t\telse\n\t\t\t\t\tlog_error(\"getaddrinfo: %s\\n\", gai_strerror(ret));\n\t\t\t\tgoto err_connect;\n\t\t\t}\n\n\t\t\tserver.sin_addr = ((struct sockaddr_in *)\n\t\t\t                   result->ai_addr)->sin_addr;\n\t\t\tfreeaddrinfo(result);\n\t\t}\n\t} else {\n\t\tserver.sin_port = htons(tunnel->config->gateway_port);\n\t\tserver.sin_addr = tunnel->config->gateway_ip;\n\t}\n\n\tlog_debug(\"server_addr: %s\\n\", inet_ntoa(server.sin_addr));\n\tlog_debug(\"server_port: %u\\n\", ntohs(server.sin_port));\n\tserver.sin_family = AF_INET;\n\tmemset(&(server.sin_zero), '\\0', 8);\n\tlog_debug(\"gateway_addr: %s\\n\", inet_ntoa(tunnel->config->gateway_ip));\n\tlog_debug(\"gateway_port: %u\\n\", tunnel->config->gateway_port);\n\n\tret = connect(handle, (struct sockaddr *) &server, sizeof(server));\n\tif (ret) {\n\t\tlog_error(\"connect: %s\\n\", strerror(errno));\n\t\tgoto err_connect;\n\t}\n\n\tif (env_proxy != NULL) {\n\t\tchar request[128];\n\n\t\t// https://tools.ietf.org/html/rfc7231#section-4.3.6\n\t\tsprintf(request, \"CONNECT %s:%u HTTP/1.1\\r\\nHost: %s:%u\\r\\n\\r\\n\",\n\t\t        inet_ntoa(tunnel->config->gateway_ip),\n\t\t        tunnel->config->gateway_port,\n\t\t        inet_ntoa(tunnel->config->gateway_ip),\n\t\t        tunnel->config->gateway_port);\n\t\tssize_t bytes_written = write(handle, request, strlen(request));\n\t\tif (bytes_written != strlen(request)) {\n\t\t\tlog_error(\"write error while talking to proxy: %s\\n\",\n\t\t\t          strerror(errno));\n\t\t\tgoto err_connect;\n\t\t}\n\n\t\t// wait for a \"200 OK\" reply from the proxy,\n\t\t// be careful not to fetch too many bytes at once\n\t\tconst char *response = NULL;\n\n\t\tmemset(&(request), '\\0', sizeof(request));\n\t\tfor (int j = 0; response == NULL; j++) {\n\t\t\t/*\n\t\t\t * Coverity detected a defect:\n\t\t\t *  CID 200508: String not null terminated (STRING_NULL)\n\t\t\t *\n\t\t\t * It is actually a false positive:\n\t\t\t * \u2022 Function memset() initializes 'request' with '\\0'\n\t\t\t * \u2022 Function read() gets a single char into: request[j]\n\t\t\t * \u2022 The final '\\0' cannot be overwritten because:\n\t\t\t *   \tj < ARRAY_SIZE(request) - 1\n\t\t\t */\n\t\t\tssize_t bytes_read = read(handle, &(request[j]), 1);\n\t\t\tif (bytes_read < 1) {\n\t\t\t\tlog_error(\"Proxy response is unexpectedly large and cannot fit in the %lu-bytes buffer.\\n\",\n\t\t\t\t          ARRAY_SIZE(request));\n\t\t\t\tgoto err_proxy_response;\n\t\t\t}\n\n\t\t\t// detect \"200\"\n\t\t\tstatic const char HTTP_STATUS_200[] = \"200\";\n\t\t\tresponse = strstr(request, HTTP_STATUS_200);\n\n\t\t\t// detect end-of-line after \"200\"\n\t\t\tif (response != NULL) {\n\t\t\t\t/*\n\t\t\t\t * RFC2616 states in section 2.2 Basic Rules:\n\t\t\t\t * \tCR     = <US-ASCII CR, carriage return (13)>\n\t\t\t\t * \tLF     = <US-ASCII LF, linefeed (10)>\n\t\t\t\t * \tHTTP/1.1 defines the sequence CR LF as the\n\t\t\t\t * \tend-of-line marker for all protocol elements\n\t\t\t\t * \texcept the entity-body (see appendix 19.3\n\t\t\t\t * \tfor tolerant applications).\n\t\t\t\t * \t\tCRLF   = CR LF\n\t\t\t\t *\n\t\t\t\t * RFC2616 states in section 19.3 Tolerant Applications:\n\t\t\t\t * \tThe line terminator for message-header fields\n\t\t\t\t * \tis the sequence CRLF. However, we recommend\n\t\t\t\t * \tthat applications, when parsing such headers,\n\t\t\t\t * \trecognize a single LF as a line terminator\n\t\t\t\t * \tand ignore the leading CR.\n\t\t\t\t */\n\t\t\t\tstatic const char *const HTTP_EOL[] = {\n\t\t\t\t\t\"\\r\\n\\r\\n\",\n\t\t\t\t\t\"\\n\\n\"\n\t\t\t\t};\n\t\t\t\tconst char *eol = NULL;\n\t\t\t\tfor (int i = 0; (i < ARRAY_SIZE(HTTP_EOL)) &&\n\t\t\t\t     (eol == NULL); i++)\n\t\t\t\t\teol = strstr(response, HTTP_EOL[i]);\n\t\t\t\tresponse = eol;\n\t\t\t}\n\n\t\t\tif (j > ARRAY_SIZE(request) - 2) {\n\t\t\t\tlog_error(\"Proxy response does not contain \\\"%s\\\" as expected.\\n\",\n\t\t\t\t          HTTP_STATUS_200);\n\t\t\t\tgoto err_proxy_response;\n\t\t\t}\n\t\t}\n\n\t\tfree(env_proxy); // release memory allocated by strdup()\n\t}\n\n\treturn handle;\n\nerr_proxy_response:\nerr_connect:\n\tfree(env_proxy); // release memory allocated by strdup()\nerr_strdup:\n\tclose(handle);\nerr_socket:\n\treturn -1;\n}\n\nstatic int ssl_verify_cert(struct tunnel *tunnel)\n{\n\tint ret = -1;\n\tint cert_valid = 0;\n\tunsigned char digest[SHA256LEN];\n\tunsigned int len;\n\tstruct x509_digest *elem;\n\tchar digest_str[SHA256STRLEN], *subject, *issuer;\n\tchar *line;\n\tint i;\n\tX509_NAME *subj;\n\n\tSSL_set_verify(tunnel->ssl_handle, SSL_VERIFY_PEER, NULL);\n\n\tX509 *cert = SSL_get_peer_certificate(tunnel->ssl_handle);\n\tif (cert == NULL) {\n\t\tlog_error(\"Unable to get gateway certificate.\\n\");\n\t\treturn 1;\n\t}\n\n\tsubj = X509_get_subject_name(cert);\n\n#ifdef HAVE_X509_CHECK_HOST\n\t// Use OpenSSL native host validation if v >= 1.0.2.\n\t// compare against gateway_host and correctly check return value\n\t// to fix piror Incorrect use of X509_check_host\n\tif (X509_check_host(cert, tunnel->config->gateway_host,\n\t                    0, 0, NULL) == 1)\n\t\tcert_valid = 1;\n#else\n\tchar common_name[FIELD_SIZE + 1];\n\t// Use explicit Common Name check if native validation not available.\n\t// Note: this will ignore Subject Alternative Name fields.\n\tif (subj\n\t    && X509_NAME_get_text_by_NID(subj, NID_commonName, common_name,\n\t                                 FIELD_SIZE) > 0\n\t    && strncasecmp(common_name, tunnel->config->gateway_host,\n\t                   FIELD_SIZE) == 0)\n\t\tcert_valid = 1;\n#endif\n\n\t// Try to validate certificate using local PKI\n\tif (cert_valid\n\t    && SSL_get_verify_result(tunnel->ssl_handle) == X509_V_OK) {\n\t\tlog_debug(\"Gateway certificate validation succeeded.\\n\");\n\t\tret = 0;\n\t\tgoto free_cert;\n\t}\n\tlog_debug(\"Gateway certificate validation failed.\\n\");\n\n\t// If validation failed, check if cert is in the white list\n\tif (X509_digest(cert, EVP_sha256(), digest, &len) <= 0\n\t    || len != SHA256LEN) {\n\t\tlog_error(\"Could not compute certificate sha256 digest.\\n\");\n\t\tgoto free_cert;\n\t}\n\t// Encode digest in base16\n\tfor (i = 0; i < SHA256LEN; i++)\n\t\tsprintf(&digest_str[2 * i], \"%02x\", digest[i]);\n\tdigest_str[SHA256STRLEN - 1] = '\\0';\n\t// Is it in whitelist?\n\tfor (elem = tunnel->config->cert_whitelist; elem != NULL;\n\t     elem = elem->next)\n\t\tif (memcmp(digest_str, elem->data, SHA256STRLEN - 1) == 0)\n\t\t\tbreak;\n\tif (elem != NULL) { // break before end of loop\n\t\tlog_debug(\"Gateway certificate digest found in white list.\\n\");\n\t\tret = 0;\n\t\tgoto free_cert;\n\t}\n\n\tsubject = X509_NAME_oneline(subj, NULL, 0);\n\tissuer = X509_NAME_oneline(X509_get_issuer_name(cert), NULL, 0);\n\n\tlog_error(\"Gateway certificate validation failed, and the certificate digest in not in the local whitelist. If you trust it, rerun with:\\n\");\n\tlog_error(\"    --trusted-cert %s\\n\", digest_str);\n\tlog_error(\"or add this line to your config file:\\n\");\n\tlog_error(\"    trusted-cert = %s\\n\", digest_str);\n\tlog_error(\"Gateway certificate:\\n\");\n\tlog_error(\"    subject:\\n\");\n\tfor (line = strtok(subject, \"/\"); line != NULL;\n\t     line = strtok(NULL, \"/\"))\n\t\tlog_error(\"        %s\\n\", line);\n\tlog_error(\"    issuer:\\n\");\n\tfor (line = strtok(issuer, \"/\"); line != NULL;\n\t     line = strtok(NULL, \"/\"))\n\t\tlog_error(\"        %s\\n\", line);\n\tlog_error(\"    sha256 digest:\\n\");\n\tlog_error(\"        %s\\n\", digest_str);\n\nfree_cert:\n\tX509_free(cert);\n\treturn ret;\n}\n\n/*\n * Destroy and free the SSL connection to the gateway.\n */\nstatic void ssl_disconnect(struct tunnel *tunnel)\n{\n\tif (!tunnel->ssl_handle)\n\t\treturn;\n\n\tSSL_shutdown(tunnel->ssl_handle);\n\tSSL_free(tunnel->ssl_handle);\n\tSSL_CTX_free(tunnel->ssl_context);\n\tclose(tunnel->ssl_socket);\n\n\ttunnel->ssl_handle = NULL;\n\ttunnel->ssl_context = NULL;\n}\n\n/*\n * Connects to the gateway and initiate an SSL session.\n */\nint ssl_connect(struct tunnel *tunnel)\n{\n\tssl_disconnect(tunnel);\n\n\ttunnel->ssl_socket = tcp_connect(tunnel);\n\tif (tunnel->ssl_socket == -1)\n\t\treturn 1;\n\n\t// registration is deprecated from OpenSSL 1.1.0 onward\n#if OPENSSL_API_COMPAT < 0x10100000L\n\t// Register the error strings for libcrypto & libssl\n\tSSL_load_error_strings();\n\t// Register the available ciphers and digests\n\tSSL_library_init();\n#endif\n\n\ttunnel->ssl_context = SSL_CTX_new(SSLv23_client_method());\n\tif (tunnel->ssl_context == NULL) {\n\t\tlog_error(\"SSL_CTX_new: %s\\n\",\n\t\t          ERR_error_string(ERR_peek_last_error(), NULL));\n\t\treturn 1;\n\t}\n\n\t// Load the OS default CA files\n\tif (!SSL_CTX_set_default_verify_paths(tunnel->ssl_context))\n\t\tlog_error(\"Could not load OS OpenSSL files.\\n\");\n\n\tif (tunnel->config->ca_file) {\n\t\tif (!SSL_CTX_load_verify_locations(\n\t\t            tunnel->ssl_context,\n\t\t            tunnel->config->ca_file, NULL)) {\n\t\t\tlog_error(\"SSL_CTX_load_verify_locations: %s\\n\",\n\t\t\t          ERR_error_string(ERR_peek_last_error(), NULL));\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/* Use engine for PIV if user-cert config starts with pkcs11 URI: */\n\tif (tunnel->config->use_engine > 0) {\n\n\t\tENGINE *e;\n\t\tENGINE_load_builtin_engines();\n\t\te = ENGINE_by_id(\"pkcs11\");\n\t\tif (!e) {\n\t\t\tlog_error(\"Could not load pkcs11 Engine: %s\\n\",\n\t\t\t          ERR_error_string(ERR_peek_last_error(), NULL));\n\t\t\treturn 1;\n\t\t}\n\t\tif (!ENGINE_init(e)) {\n\t\t\tlog_error(\"Could not init pkcs11 Engine: %s\\n\",\n\t\t\t          ERR_error_string(ERR_peek_last_error(), NULL));\n\t\t\tENGINE_free(e);\n\t\t\treturn 1;\n\t\t}\n\t\tif (!ENGINE_set_default_RSA(e))\n\t\t\tabort();\n\n\t\tENGINE_finish(e);\n\t\tENGINE_free(e);\n\n\t\tstruct token parms;\n\t\tparms.uri = tunnel->config->user_cert;\n\t\tparms.cert = NULL;\n\n\t\tif (!ENGINE_ctrl_cmd(e, \"LOAD_CERT_CTRL\", 0, &parms, NULL, 1)) {\n\t\t\tlog_error(\"PKCS11 ENGINE_ctrl_cmd: %s\\n\",\n\t\t\t          ERR_error_string(ERR_peek_last_error(), NULL));\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (!SSL_CTX_use_certificate(tunnel->ssl_context, parms.cert)) {\n\t\t\tlog_error(\"PKCS11 SSL_CTX_use_certificate: %s\\n\",\n\t\t\t          ERR_error_string(ERR_peek_last_error(), NULL));\n\t\t\treturn 1;\n\t\t}\n\n\t\tEVP_PKEY * privkey = ENGINE_load_private_key(\n\t\t                             e, parms.uri, UI_OpenSSL(), NULL);\n\t\tif (!privkey) {\n\t\t\tlog_error(\"PKCS11 ENGINE_load_private_key: %s\\n\",\n\t\t\t          ERR_error_string(ERR_peek_last_error(), NULL));\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (!SSL_CTX_use_PrivateKey(tunnel->ssl_context, privkey)) {\n\t\t\tlog_error(\"PKCS11 SSL_CTX_use_PrivateKey_file: %s\\n\",\n\t\t\t          ERR_error_string(ERR_peek_last_error(), NULL));\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (!SSL_CTX_check_private_key(tunnel->ssl_context)) {\n\t\t\tlog_error(\"PKCS11 SSL_CTX_check_private_key: %s\\n\",\n\t\t\t          ERR_error_string(ERR_peek_last_error(), NULL));\n\t\t\treturn 1;\n\t\t}\n\n\t} else {        /* end PKCS11-engine */\n\n\t\tif (tunnel->config->user_cert) {\n\t\t\tif (!SSL_CTX_use_certificate_file(\n\t\t\t            tunnel->ssl_context, tunnel->config->user_cert,\n\t\t\t            SSL_FILETYPE_PEM)) {\n\t\t\t\tlog_error(\"SSL_CTX_use_certificate_file: %s\\n\",\n\t\t\t\t          ERR_error_string(ERR_peek_last_error(), NULL));\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\n\t\tif (tunnel->config->user_key) {\n\t\t\tif (!SSL_CTX_use_PrivateKey_file(\n\t\t\t            tunnel->ssl_context, tunnel->config->user_key,\n\t\t\t            SSL_FILETYPE_PEM)) {\n\t\t\t\tlog_error(\"SSL_CTX_use_PrivateKey_file: %s\\n\",\n\t\t\t\t          ERR_error_string(ERR_peek_last_error(), NULL));\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\n\t\tif (tunnel->config->user_cert && tunnel->config->user_key) {\n\t\t\tif (!SSL_CTX_check_private_key(tunnel->ssl_context)) {\n\t\t\t\tlog_error(\"SSL_CTX_check_private_key: %s\\n\",\n\t\t\t\t          ERR_error_string(ERR_peek_last_error(), NULL));\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!tunnel->config->insecure_ssl) {\n\t\tlong sslctxopt = SSL_OP_NO_SSLv3 | SSL_OP_NO_COMPRESSION;\n\t\tlong checkopt;\n\n\t\tcheckopt = SSL_CTX_set_options(tunnel->ssl_context, sslctxopt);\n\t\tif ((checkopt & sslctxopt) != sslctxopt) {\n\t\t\tlog_error(\"SSL_CTX_set_options didn't set opt: %s\\n\",\n\t\t\t          ERR_error_string(ERR_peek_last_error(), NULL));\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\ttunnel->ssl_handle = SSL_new(tunnel->ssl_context);\n\tif (tunnel->ssl_handle == NULL) {\n\t\tlog_error(\"SSL_new: %s\\n\",\n\t\t          ERR_error_string(ERR_peek_last_error(), NULL));\n\t\treturn 1;\n\t}\n\n\tif (!tunnel->config->insecure_ssl) {\n\t\tif (!tunnel->config->cipher_list) {\n\t\t\tconst char *cipher_list;\n\t\t\tif (tunnel->config->seclevel_1)\n\t\t\t\tcipher_list = \"HIGH:!aNULL:!kRSA:!PSK:!SRP:!MD5:!RC4@SECLEVEL=1\";\n\t\t\telse\n\t\t\t\tcipher_list = \"HIGH:!aNULL:!kRSA:!PSK:!SRP:!MD5:!RC4\";\n\t\t\ttunnel->config->cipher_list = strdup(cipher_list);\n\t\t}\n\t} else {\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\t\tif (tunnel->config->min_tls <= 0)\n\t\t\ttunnel->config->min_tls = TLS1_VERSION;\n#endif\n\t\tif (!tunnel->config->cipher_list && tunnel->config->seclevel_1) {\n\t\t\tconst char *cipher_list = \"DEFAULT@SECLEVEL=1\";\n\t\t\ttunnel->config->cipher_list = strdup(cipher_list);\n\t\t}\n\t}\n\n\tif (tunnel->config->cipher_list) {\n\t\tlog_debug(\"Setting cipher list to: %s\\n\", tunnel->config->cipher_list);\n\t\tif (!SSL_set_cipher_list(tunnel->ssl_handle,\n\t\t                         tunnel->config->cipher_list)) {\n\t\t\tlog_error(\"SSL_set_cipher_list failed: %s\\n\",\n\t\t\t          ERR_error_string(ERR_peek_last_error(), NULL));\n\t\t\treturn 1;\n\t\t}\n\t}\n\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\tif (tunnel->config->min_tls > 0) {\n\t\tlog_debug(\"Setting min proto version to: 0x%x\\n\",\n\t\t          tunnel->config->min_tls);\n\t\tif (!SSL_set_min_proto_version(tunnel->ssl_handle,\n\t\t                               tunnel->config->min_tls)) {\n\t\t\tlog_error(\"SSL_set_min_proto_version failed: %s\\n\",\n\t\t\t          ERR_error_string(ERR_peek_last_error(), NULL));\n\t\t\treturn 1;\n\t\t}\n\t}\n#endif\n\n\tif (!SSL_set_fd(tunnel->ssl_handle, tunnel->ssl_socket)) {\n\t\tlog_error(\"SSL_set_fd: %s\\n\",\n\t\t          ERR_error_string(ERR_peek_last_error(), NULL));\n\t\treturn 1;\n\t}\n\tSSL_set_mode(tunnel->ssl_handle, SSL_MODE_AUTO_RETRY);\n\n\t// Initiate SSL handshake\n\tif (SSL_connect(tunnel->ssl_handle) != 1) {\n\t\tlog_error(\"SSL_connect: %s\\n\"\n\t\t          \"You might want to try --insecure-ssl or specify a different --cipher-list\\n\",\n\t\t          ERR_error_string(ERR_peek_last_error(), NULL));\n\t\treturn 1;\n\t}\n\tSSL_set_mode(tunnel->ssl_handle, SSL_MODE_AUTO_RETRY);\n\n\tif (ssl_verify_cert(tunnel))\n\t\treturn 1;\n\n\t// Disable SIGPIPE (occurs when trying to write to an already-closed\n\t// socket).\n\tsignal(SIGPIPE, SIG_IGN);\n\n\treturn 0;\n}\n\nint run_tunnel(struct vpn_config *config)\n{\n\tint ret;\n\tstruct tunnel tunnel = {\n\t\t.config = config,\n\t\t.state = STATE_DOWN,\n\t\t.ssl_context = NULL,\n\t\t.ssl_handle = NULL,\n\t\t.ipv4.ns1_addr.s_addr = 0,\n\t\t.ipv4.ns2_addr.s_addr = 0,\n\t\t.ipv4.dns_suffix = NULL,\n\t\t.on_ppp_if_up = on_ppp_if_up,\n\t\t.on_ppp_if_down = on_ppp_if_down\n\t};\n\n\t// Step 0: get gateway host IP\n\tlog_debug(\"Resolving gateway host ip\\n\");\n\tret = get_gateway_host_ip(&tunnel);\n\tif (ret)\n\t\tgoto err_tunnel;\n\n\t// Step 1: open a SSL connection to the gateway\n\tlog_debug(\"Establishing ssl connection\\n\");\n\tret = ssl_connect(&tunnel);\n\tif (ret)\n\t\tgoto err_tunnel;\n\tlog_info(\"Connected to gateway.\\n\");\n\n\t// Step 2: connect to the HTTP interface and authenticate to get a\n\t// cookie\n\tret = auth_log_in(&tunnel);\n\tif (ret != 1) {\n\t\tlog_error(\"Could not authenticate to gateway. Please check the password, client certificate, etc.\\n\");\n\t\tlog_debug(\"%s %d\\n\", err_http_str(ret), ret);\n\t\tret = 1;\n\t\tgoto err_tunnel;\n\t}\n\tlog_info(\"Authenticated.\\n\");\n\tlog_debug(\"Cookie: %s\\n\", tunnel.cookie);\n\n\tret = auth_request_vpn_allocation(&tunnel);\n\tif (ret != 1) {\n\t\tlog_error(\"VPN allocation request failed (%s).\\n\",\n\t\t          err_http_str(ret));\n\t\tret = 1;\n\t\tgoto err_tunnel;\n\t}\n\tlog_info(\"Remote gateway has allocated a VPN.\\n\");\n\n\tret = ssl_connect(&tunnel);\n\tif (ret)\n\t\tgoto err_tunnel;\n\n\t// Step 3: get configuration\n\tlog_debug(\"Retrieving configuration\\n\");\n\tret = auth_get_config(&tunnel);\n\tif (ret != 1) {\n\t\tlog_error(\"Could not get VPN configuration (%s).\\n\",\n\t\t          err_http_str(ret));\n\t\tret = 1;\n\t\tgoto err_tunnel;\n\t}\n\n\t// Step 4: run a pppd process\n\tlog_debug(\"Establishing the tunnel\\n\");\n\tret = pppd_run(&tunnel);\n\tif (ret)\n\t\tgoto err_tunnel;\n\n\t// Step 5: ask gateway to start tunneling\n\tlog_debug(\"Switch to tunneling mode\\n\");\n\tret = http_send(&tunnel,\n\t                \"GET /remote/sslvpn-tunnel HTTP/1.1\\r\\n\"\n\t                \"Host: sslvpn\\r\\n\"\n\t                \"Cookie: %s\\r\\n\\r\\n\",\n\t                tunnel.cookie);\n\tif (ret != 1) {\n\t\tlog_error(\"Could not start tunnel (%s).\\n\", err_http_str(ret));\n\t\tret = 1;\n\t\tgoto err_start_tunnel;\n\t}\n\n\ttunnel.state = STATE_CONNECTING;\n\tret = 0;\n\n\t// Step 6: perform io between pppd and the gateway, while tunnel is up\n\tlog_debug(\"Starting IO through the tunnel\\n\");\n\tio_loop(&tunnel);\n\n\tlog_debug(\"disconnecting\\n\");\n\tif (tunnel.state == STATE_UP)\n\t\tif (tunnel.on_ppp_if_down != NULL)\n\t\t\ttunnel.on_ppp_if_down(&tunnel);\n\n\ttunnel.state = STATE_DISCONNECTING;\n\nerr_start_tunnel:\n\tpppd_terminate(&tunnel);\n\tlog_info(\"Terminated %s.\\n\", PPP_DAEMON);\nerr_tunnel:\n\tlog_info(\"Closed connection to gateway.\\n\");\n\ttunnel.state = STATE_DOWN;\n\n\tif (ssl_connect(&tunnel)) {\n\t\tlog_info(\"Could not log out.\\n\");\n\t} else {\n\t\tauth_log_out(&tunnel);\n\t\tlog_info(\"Logged out.\\n\");\n\t}\n\n\t// explicitly free the buffer allocated for split routes of the ipv4 config\n\tif (tunnel.ipv4.split_rt != NULL) {\n\t\tfree(tunnel.ipv4.split_rt);\n\t\ttunnel.ipv4.split_rt = NULL;\n\t}\n\treturn ret;\n}\n"], "filenames": ["src/tunnel.c"], "buggy_code_start_loc": [655], "buggy_code_end_loc": [672], "fixing_code_start_loc": [654], "fixing_code_end_loc": [675], "type": "CWE-295", "message": "An issue was discovered in openfortivpn 1.11.0 when used with OpenSSL 1.0.2 or later. tunnel.c mishandles certificate validation because the hostname check operates on uninitialized memory. The outcome is that a valid certificate is never accepted (only a malformed certificate may be accepted).", "other": {"cve": {"id": "CVE-2020-7042", "sourceIdentifier": "cve@mitre.org", "published": "2020-02-27T18:15:11.547", "lastModified": "2021-07-21T11:39:23.747", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in openfortivpn 1.11.0 when used with OpenSSL 1.0.2 or later. tunnel.c mishandles certificate validation because the hostname check operates on uninitialized memory. The outcome is that a valid certificate is never accepted (only a malformed certificate may be accepted)."}, {"lang": "es", "value": "Se detect\u00f3 un problema en openfortivpn versi\u00f3n 1.11.0, cuando se usaba con OpenSSL versiones 1.0.2 o posteriores, en el archivo tunnel.c, maneja inapropiadamente la comprobaci\u00f3n del certificado porque la verificaci\u00f3n del nombre de host funciona en la memoria no inicializada. El resultado es que un certificado v\u00e1lido nunca es aceptado (solo puede ser aceptado un certificado malformado)."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-295"}, {"lang": "en", "value": "CWE-908"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openfortivpn_project:openfortivpn:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.12.0", "matchCriteriaId": "9676ABA1-E073-4E5E-A583-9661F9220F98"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:a:openssl:openssl:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.0.2", "matchCriteriaId": "D105A942-579A-465F-A1D4-76DDF33440E6"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:30:*:*:*:*:*:*:*", "matchCriteriaId": "97A4B8DF-58DA-4AB6-A1F9-331B36409BA3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:32:*:*:*:*:*:*:*", "matchCriteriaId": "36D96259-24BD-44E2-96D9-78CE1D41F956"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:opensuse:backports_sle:15.0:sp1:*:*:*:*:*:*", "matchCriteriaId": "40513095-7E6E-46B3-B604-C926F1BA3568"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-03/msg00009.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2020-03/msg00011.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/adrienverge/openfortivpn/commit/9eee997d599a89492281fc7ffdd79d88cd61afc3", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/adrienverge/openfortivpn/commit/cd9368c6a1b4ef91d77bb3fdbe2e5bc34aa6f4c4", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/adrienverge/openfortivpn/issues/536", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/CKNKSGBVYGRRVRLFEFBEKUEJYJR5LWOF/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/FF6HYIBREQGATRM5COF57MRQWKOKCWZ3/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/SRVVNXCNTNMPCIAZIVR4FAGYCSU53FNA/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/adrienverge/openfortivpn/commit/9eee997d599a89492281fc7ffdd79d88cd61afc3"}}