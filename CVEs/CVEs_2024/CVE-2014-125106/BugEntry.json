{"buggy_code": ["/* pb_decode.c -- decode a protobuf using minimal resources\n *\n * 2011 Petteri Aimonen <jpa@kapsi.fi>\n */\n\n/* Use the GCC warn_unused_result attribute to check that all return values\n * are propagated correctly. On other compilers and gcc before 3.4.0 just\n * ignore the annotation.\n */\n#if !defined(__GNUC__) || ( __GNUC__ < 3) || (__GNUC__ == 3 && __GNUC_MINOR__ < 4)\n    #define checkreturn\n#else\n    #define checkreturn __attribute__((warn_unused_result))\n#endif\n\n#include \"pb.h\"\n#include \"pb_decode.h\"\n#include \"pb_common.h\"\n\n/**************************************\n * Declarations internal to this file *\n **************************************/\n\ntypedef bool (*pb_decoder_t)(pb_istream_t *stream, const pb_field_t *field, void *dest) checkreturn;\n\nstatic bool checkreturn buf_read(pb_istream_t *stream, uint8_t *buf, size_t count);\nstatic bool checkreturn pb_decode_varint32(pb_istream_t *stream, uint32_t *dest);\nstatic bool checkreturn read_raw_value(pb_istream_t *stream, pb_wire_type_t wire_type, uint8_t *buf, size_t *size);\nstatic bool checkreturn decode_static_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter);\nstatic bool checkreturn decode_callback_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter);\nstatic bool checkreturn decode_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter);\nstatic bool checkreturn default_extension_decoder(pb_istream_t *stream, pb_extension_t *extension, uint32_t tag, pb_wire_type_t wire_type);\nstatic bool checkreturn decode_extension(pb_istream_t *stream, uint32_t tag, pb_wire_type_t wire_type, pb_field_iter_t *iter);\nstatic bool checkreturn find_extension_field(pb_field_iter_t *iter);\nstatic void pb_message_set_to_defaults(const pb_field_t fields[], void *dest_struct);\nstatic bool checkreturn pb_dec_varint(pb_istream_t *stream, const pb_field_t *field, void *dest);\nstatic bool checkreturn pb_dec_uvarint(pb_istream_t *stream, const pb_field_t *field, void *dest);\nstatic bool checkreturn pb_dec_svarint(pb_istream_t *stream, const pb_field_t *field, void *dest);\nstatic bool checkreturn pb_dec_fixed32(pb_istream_t *stream, const pb_field_t *field, void *dest);\nstatic bool checkreturn pb_dec_fixed64(pb_istream_t *stream, const pb_field_t *field, void *dest);\nstatic bool checkreturn pb_dec_bytes(pb_istream_t *stream, const pb_field_t *field, void *dest);\nstatic bool checkreturn pb_dec_string(pb_istream_t *stream, const pb_field_t *field, void *dest);\nstatic bool checkreturn pb_dec_submessage(pb_istream_t *stream, const pb_field_t *field, void *dest);\nstatic bool checkreturn pb_skip_varint(pb_istream_t *stream);\nstatic bool checkreturn pb_skip_string(pb_istream_t *stream);\n\n#ifdef PB_ENABLE_MALLOC\nstatic bool checkreturn allocate_field(pb_istream_t *stream, void *pData, size_t data_size, size_t array_size);\nstatic void pb_release_single_field(const pb_field_iter_t *iter);\n#endif\n\n/* --- Function pointers to field decoders ---\n * Order in the array must match pb_action_t LTYPE numbering.\n */\nstatic const pb_decoder_t PB_DECODERS[PB_LTYPES_COUNT] = {\n    &pb_dec_varint,\n    &pb_dec_uvarint,\n    &pb_dec_svarint,\n    &pb_dec_fixed32,\n    &pb_dec_fixed64,\n    \n    &pb_dec_bytes,\n    &pb_dec_string,\n    &pb_dec_submessage,\n    NULL /* extensions */\n};\n\n/*******************************\n * pb_istream_t implementation *\n *******************************/\n\nstatic bool checkreturn buf_read(pb_istream_t *stream, uint8_t *buf, size_t count)\n{\n    uint8_t *source = (uint8_t*)stream->state;\n    stream->state = source + count;\n    \n    if (buf != NULL)\n    {\n        while (count--)\n            *buf++ = *source++;\n    }\n    \n    return true;\n}\n\nbool checkreturn pb_read(pb_istream_t *stream, uint8_t *buf, size_t count)\n{\n#ifndef PB_BUFFER_ONLY\n\tif (buf == NULL && stream->callback != buf_read)\n\t{\n\t\t/* Skip input bytes */\n\t\tuint8_t tmp[16];\n\t\twhile (count > 16)\n\t\t{\n\t\t\tif (!pb_read(stream, tmp, 16))\n\t\t\t\treturn false;\n\t\t\t\n\t\t\tcount -= 16;\n\t\t}\n\t\t\n\t\treturn pb_read(stream, tmp, count);\n\t}\n#endif\n\n    if (stream->bytes_left < count)\n        PB_RETURN_ERROR(stream, \"end-of-stream\");\n    \n#ifndef PB_BUFFER_ONLY\n    if (!stream->callback(stream, buf, count))\n        PB_RETURN_ERROR(stream, \"io error\");\n#else\n    if (!buf_read(stream, buf, count))\n        return false;\n#endif\n    \n    stream->bytes_left -= count;\n    return true;\n}\n\n/* Read a single byte from input stream. buf may not be NULL.\n * This is an optimization for the varint decoding. */\nstatic bool checkreturn pb_readbyte(pb_istream_t *stream, uint8_t *buf)\n{\n    if (stream->bytes_left == 0)\n        PB_RETURN_ERROR(stream, \"end-of-stream\");\n\n#ifndef PB_BUFFER_ONLY\n    if (!stream->callback(stream, buf, 1))\n        PB_RETURN_ERROR(stream, \"io error\");\n#else\n    *buf = *(uint8_t*)stream->state;\n    stream->state = (uint8_t*)stream->state + 1;\n#endif\n\n    stream->bytes_left--;\n    \n    return true;    \n}\n\npb_istream_t pb_istream_from_buffer(uint8_t *buf, size_t bufsize)\n{\n    pb_istream_t stream;\n#ifdef PB_BUFFER_ONLY\n    stream.callback = NULL;\n#else\n    stream.callback = &buf_read;\n#endif\n    stream.state = buf;\n    stream.bytes_left = bufsize;\n#ifndef PB_NO_ERRMSG\n    stream.errmsg = NULL;\n#endif\n    return stream;\n}\n\n/********************\n * Helper functions *\n ********************/\n\nstatic bool checkreturn pb_decode_varint32(pb_istream_t *stream, uint32_t *dest)\n{\n    uint8_t byte;\n    uint32_t result;\n    \n    if (!pb_readbyte(stream, &byte))\n        return false;\n    \n    if ((byte & 0x80) == 0)\n    {\n        /* Quick case, 1 byte value */\n        result = byte;\n    }\n    else\n    {\n        /* Multibyte case */\n        uint8_t bitpos = 7;\n        result = byte & 0x7F;\n        \n        do\n        {\n            if (bitpos >= 32)\n                PB_RETURN_ERROR(stream, \"varint overflow\");\n            \n            if (!pb_readbyte(stream, &byte))\n                return false;\n            \n            result |= (uint32_t)(byte & 0x7F) << bitpos;\n            bitpos = (uint8_t)(bitpos + 7);\n        } while (byte & 0x80);\n   }\n   \n   *dest = result;\n   return true;\n}\n\nbool checkreturn pb_decode_varint(pb_istream_t *stream, uint64_t *dest)\n{\n    uint8_t byte;\n    uint8_t bitpos = 0;\n    uint64_t result = 0;\n    \n    do\n    {\n        if (bitpos >= 64)\n            PB_RETURN_ERROR(stream, \"varint overflow\");\n        \n        if (!pb_readbyte(stream, &byte))\n            return false;\n\n        result |= (uint64_t)(byte & 0x7F) << bitpos;\n        bitpos = (uint8_t)(bitpos + 7);\n    } while (byte & 0x80);\n    \n    *dest = result;\n    return true;\n}\n\nbool checkreturn pb_skip_varint(pb_istream_t *stream)\n{\n    uint8_t byte;\n    do\n    {\n        if (!pb_read(stream, &byte, 1))\n            return false;\n    } while (byte & 0x80);\n    return true;\n}\n\nbool checkreturn pb_skip_string(pb_istream_t *stream)\n{\n    uint32_t length;\n    if (!pb_decode_varint32(stream, &length))\n        return false;\n    \n    return pb_read(stream, NULL, length);\n}\n\nbool checkreturn pb_decode_tag(pb_istream_t *stream, pb_wire_type_t *wire_type, uint32_t *tag, bool *eof)\n{\n    uint32_t temp;\n    *eof = false;\n    *wire_type = (pb_wire_type_t) 0;\n    *tag = 0;\n    \n    if (!pb_decode_varint32(stream, &temp))\n    {\n        if (stream->bytes_left == 0)\n            *eof = true;\n\n        return false;\n    }\n    \n    if (temp == 0)\n    {\n        *eof = true; /* Special feature: allow 0-terminated messages. */\n        return false;\n    }\n    \n    *tag = temp >> 3;\n    *wire_type = (pb_wire_type_t)(temp & 7);\n    return true;\n}\n\nbool checkreturn pb_skip_field(pb_istream_t *stream, pb_wire_type_t wire_type)\n{\n    switch (wire_type)\n    {\n        case PB_WT_VARINT: return pb_skip_varint(stream);\n        case PB_WT_64BIT: return pb_read(stream, NULL, 8);\n        case PB_WT_STRING: return pb_skip_string(stream);\n        case PB_WT_32BIT: return pb_read(stream, NULL, 4);\n        default: PB_RETURN_ERROR(stream, \"invalid wire_type\");\n    }\n}\n\n/* Read a raw value to buffer, for the purpose of passing it to callback as\n * a substream. Size is maximum size on call, and actual size on return.\n */\nstatic bool checkreturn read_raw_value(pb_istream_t *stream, pb_wire_type_t wire_type, uint8_t *buf, size_t *size)\n{\n    size_t max_size = *size;\n    switch (wire_type)\n    {\n        case PB_WT_VARINT:\n            *size = 0;\n            do\n            {\n                (*size)++;\n                if (*size > max_size) return false;\n                if (!pb_read(stream, buf, 1)) return false;\n            } while (*buf++ & 0x80);\n            return true;\n            \n        case PB_WT_64BIT:\n            *size = 8;\n            return pb_read(stream, buf, 8);\n        \n        case PB_WT_32BIT:\n            *size = 4;\n            return pb_read(stream, buf, 4);\n        \n        default: PB_RETURN_ERROR(stream, \"invalid wire_type\");\n    }\n}\n\n/* Decode string length from stream and return a substream with limited length.\n * Remember to close the substream using pb_close_string_substream().\n */\nbool checkreturn pb_make_string_substream(pb_istream_t *stream, pb_istream_t *substream)\n{\n    uint32_t size;\n    if (!pb_decode_varint32(stream, &size))\n        return false;\n    \n    *substream = *stream;\n    if (substream->bytes_left < size)\n        PB_RETURN_ERROR(stream, \"parent stream too short\");\n    \n    substream->bytes_left = size;\n    stream->bytes_left -= size;\n    return true;\n}\n\nvoid pb_close_string_substream(pb_istream_t *stream, pb_istream_t *substream)\n{\n    stream->state = substream->state;\n\n#ifndef PB_NO_ERRMSG\n    stream->errmsg = substream->errmsg;\n#endif\n}\n\n/*************************\n * Decode a single field *\n *************************/\n\nstatic bool checkreturn decode_static_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter)\n{\n    pb_type_t type;\n    pb_decoder_t func;\n    \n    type = iter->pos->type;\n    func = PB_DECODERS[PB_LTYPE(type)];\n\n    switch (PB_HTYPE(type))\n    {\n        case PB_HTYPE_REQUIRED:\n            return func(stream, iter->pos, iter->pData);\n            \n        case PB_HTYPE_OPTIONAL:\n            *(bool*)iter->pSize = true;\n            return func(stream, iter->pos, iter->pData);\n    \n        case PB_HTYPE_REPEATED:\n            if (wire_type == PB_WT_STRING\n                && PB_LTYPE(type) <= PB_LTYPE_LAST_PACKABLE)\n            {\n                /* Packed array */\n                bool status = true;\n                pb_size_t *size = (pb_size_t*)iter->pSize;\n                pb_istream_t substream;\n                if (!pb_make_string_substream(stream, &substream))\n                    return false;\n                \n                while (substream.bytes_left > 0 && *size < iter->pos->array_size)\n                {\n                    void *pItem = (uint8_t*)iter->pData + iter->pos->data_size * (*size);\n                    if (!func(&substream, iter->pos, pItem))\n                    {\n                        status = false;\n                        break;\n                    }\n                    (*size)++;\n                }\n                pb_close_string_substream(stream, &substream);\n                \n                if (substream.bytes_left != 0)\n                    PB_RETURN_ERROR(stream, \"array overflow\");\n                \n                return status;\n            }\n            else\n            {\n                /* Repeated field */\n                pb_size_t *size = (pb_size_t*)iter->pSize;\n                void *pItem = (uint8_t*)iter->pData + iter->pos->data_size * (*size);\n                if (*size >= iter->pos->array_size)\n                    PB_RETURN_ERROR(stream, \"array overflow\");\n                \n                (*size)++;\n                return func(stream, iter->pos, pItem);\n            }\n\n        default:\n            PB_RETURN_ERROR(stream, \"invalid field type\");\n    }\n}\n\n#ifdef PB_ENABLE_MALLOC\n/* Allocate storage for the field and store the pointer at iter->pData.\n * array_size is the number of entries to reserve in an array.\n * Zero size is not allowed, use pb_free() for releasing.\n */\nstatic bool checkreturn allocate_field(pb_istream_t *stream, void *pData, size_t data_size, size_t array_size)\n{    \n    void *ptr = *(void**)pData;\n    \n    if (data_size == 0 || array_size == 0)\n        PB_RETURN_ERROR(stream, \"invalid size\");\n    \n    /* Check for multiplication overflows.\n     * This code avoids the costly division if the sizes are small enough.\n     * Multiplication is safe as long as only half of bits are set\n     * in either multiplicand.\n     */\n    {\n        const size_t check_limit = (size_t)1 << (sizeof(size_t) * 4);\n        if (data_size >= check_limit || array_size >= check_limit)\n        {\n            const size_t size_max = (size_t)-1;\n            if (size_max / array_size < data_size)\n            {\n                PB_RETURN_ERROR(stream, \"size too large\");\n            }\n        }\n    }\n    \n    /* Allocate new or expand previous allocation */\n    /* Note: on failure the old pointer will remain in the structure,\n     * the message must be freed by caller also on error return. */\n    ptr = pb_realloc(ptr, array_size * data_size);\n    if (ptr == NULL)\n        PB_RETURN_ERROR(stream, \"realloc failed\");\n    \n    *(void**)pData = ptr;\n    return true;\n}\n\n/* Clear a newly allocated item in case it contains a pointer, or is a submessage. */\nstatic void initialize_pointer_field(void *pItem, pb_field_iter_t *iter)\n{\n    if (PB_LTYPE(iter->pos->type) == PB_LTYPE_STRING ||\n        PB_LTYPE(iter->pos->type) == PB_LTYPE_BYTES)\n    {\n        *(void**)pItem = NULL;\n    }\n    else if (PB_LTYPE(iter->pos->type) == PB_LTYPE_SUBMESSAGE)\n    {\n        pb_message_set_to_defaults((const pb_field_t *) iter->pos->ptr, pItem);\n    }\n}\n#endif\n\nstatic bool checkreturn decode_pointer_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter)\n{\n#ifndef PB_ENABLE_MALLOC\n    PB_UNUSED(wire_type);\n    PB_UNUSED(iter);\n    PB_RETURN_ERROR(stream, \"no malloc support\");\n#else\n    pb_type_t type;\n    pb_decoder_t func;\n    \n    type = iter->pos->type;\n    func = PB_DECODERS[PB_LTYPE(type)];\n    \n    switch (PB_HTYPE(type))\n    {\n        case PB_HTYPE_REQUIRED:\n        case PB_HTYPE_OPTIONAL:\n            if (PB_LTYPE(type) == PB_LTYPE_SUBMESSAGE &&\n                *(void**)iter->pData != NULL)\n            {\n                /* Duplicate field, have to release the old allocation first. */\n                pb_release_single_field(iter);\n            }\n        \n            if (PB_LTYPE(type) == PB_LTYPE_STRING ||\n                PB_LTYPE(type) == PB_LTYPE_BYTES)\n            {\n                return func(stream, iter->pos, iter->pData);\n            }\n            else\n            {\n                if (!allocate_field(stream, iter->pData, iter->pos->data_size, 1))\n                    return false;\n                \n                initialize_pointer_field(*(void**)iter->pData, iter);\n                return func(stream, iter->pos, *(void**)iter->pData);\n            }\n    \n        case PB_HTYPE_REPEATED:\n            if (wire_type == PB_WT_STRING\n                && PB_LTYPE(type) <= PB_LTYPE_LAST_PACKABLE)\n            {\n                /* Packed array, multiple items come in at once. */\n                bool status = true;\n                pb_size_t *size = (pb_size_t*)iter->pSize;\n                size_t allocated_size = *size;\n                void *pItem;\n                pb_istream_t substream;\n                \n                if (!pb_make_string_substream(stream, &substream))\n                    return false;\n                \n                while (substream.bytes_left)\n                {\n                    if ((size_t)*size + 1 > allocated_size)\n                    {\n                        /* Allocate more storage. This tries to guess the\n                         * number of remaining entries. Round the division\n                         * upwards. */\n                        allocated_size += (substream.bytes_left - 1) / iter->pos->data_size + 1;\n                        \n                        if (!allocate_field(&substream, iter->pData, iter->pos->data_size, allocated_size))\n                        {\n                            status = false;\n                            break;\n                        }\n                    }\n\n                    /* Decode the array entry */\n                    pItem = *(uint8_t**)iter->pData + iter->pos->data_size * (*size);\n                    initialize_pointer_field(pItem, iter);\n                    if (!func(&substream, iter->pos, pItem))\n                    {\n                        status = false;\n                        break;\n                    }\n                    \n                    if (*size == PB_SIZE_MAX)\n                    {\n#ifndef PB_NO_ERRMSG\n                        stream->errmsg = \"too many array entries\";\n#endif\n                        status = false;\n                        break;\n                    }\n                    \n                    (*size)++;\n                }\n                pb_close_string_substream(stream, &substream);\n                \n                return status;\n            }\n            else\n            {\n                /* Normal repeated field, i.e. only one item at a time. */\n                pb_size_t *size = (pb_size_t*)iter->pSize;\n                void *pItem;\n                \n                if (*size == PB_SIZE_MAX)\n                    PB_RETURN_ERROR(stream, \"too many array entries\");\n                \n                (*size)++;\n                if (!allocate_field(stream, iter->pData, iter->pos->data_size, *size))\n                    return false;\n            \n                pItem = *(uint8_t**)iter->pData + iter->pos->data_size * (*size - 1);\n                initialize_pointer_field(pItem, iter);\n                return func(stream, iter->pos, pItem);\n            }\n            \n        default:\n            PB_RETURN_ERROR(stream, \"invalid field type\");\n    }\n#endif\n}\n\nstatic bool checkreturn decode_callback_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter)\n{\n    pb_callback_t *pCallback = (pb_callback_t*)iter->pData;\n    \n#ifdef PB_OLD_CALLBACK_STYLE\n    void *arg = pCallback->arg;\n#else\n    void **arg = &(pCallback->arg);\n#endif\n    \n    if (pCallback->funcs.decode == NULL)\n        return pb_skip_field(stream, wire_type);\n    \n    if (wire_type == PB_WT_STRING)\n    {\n        pb_istream_t substream;\n        \n        if (!pb_make_string_substream(stream, &substream))\n            return false;\n        \n        do\n        {\n            if (!pCallback->funcs.decode(&substream, iter->pos, arg))\n                PB_RETURN_ERROR(stream, \"callback failed\");\n        } while (substream.bytes_left);\n        \n        pb_close_string_substream(stream, &substream);\n        return true;\n    }\n    else\n    {\n        /* Copy the single scalar value to stack.\n         * This is required so that we can limit the stream length,\n         * which in turn allows to use same callback for packed and\n         * not-packed fields. */\n        pb_istream_t substream;\n        uint8_t buffer[10];\n        size_t size = sizeof(buffer);\n        \n        if (!read_raw_value(stream, wire_type, buffer, &size))\n            return false;\n        substream = pb_istream_from_buffer(buffer, size);\n        \n        return pCallback->funcs.decode(&substream, iter->pos, arg);\n    }\n}\n\nstatic bool checkreturn decode_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter)\n{\n    switch (PB_ATYPE(iter->pos->type))\n    {\n        case PB_ATYPE_STATIC:\n            return decode_static_field(stream, wire_type, iter);\n        \n        case PB_ATYPE_POINTER:\n            return decode_pointer_field(stream, wire_type, iter);\n        \n        case PB_ATYPE_CALLBACK:\n            return decode_callback_field(stream, wire_type, iter);\n        \n        default:\n            PB_RETURN_ERROR(stream, \"invalid field type\");\n    }\n}\n\n/* Default handler for extension fields. Expects a pb_field_t structure\n * in extension->type->arg. */\nstatic bool checkreturn default_extension_decoder(pb_istream_t *stream,\n    pb_extension_t *extension, uint32_t tag, pb_wire_type_t wire_type)\n{\n    const pb_field_t *field = (const pb_field_t*)extension->type->arg;\n    pb_field_iter_t iter;\n    \n    if (field->tag != tag)\n        return true;\n    \n    /* Fake a field iterator for the extension field.\n     * It is not actually safe to advance this iterator, but decode_field\n     * will not even try to. */\n    (void)pb_field_iter_begin(&iter, field, extension->dest);\n    iter.pData = extension->dest;\n    iter.pSize = &extension->found;\n    \n    return decode_field(stream, wire_type, &iter);\n}\n\n/* Try to decode an unknown field as an extension field. Tries each extension\n * decoder in turn, until one of them handles the field or loop ends. */\nstatic bool checkreturn decode_extension(pb_istream_t *stream,\n    uint32_t tag, pb_wire_type_t wire_type, pb_field_iter_t *iter)\n{\n    pb_extension_t *extension = *(pb_extension_t* const *)iter->pData;\n    size_t pos = stream->bytes_left;\n    \n    while (extension != NULL && pos == stream->bytes_left)\n    {\n        bool status;\n        if (extension->type->decode)\n            status = extension->type->decode(stream, extension, tag, wire_type);\n        else\n            status = default_extension_decoder(stream, extension, tag, wire_type);\n\n        if (!status)\n            return false;\n        \n        extension = extension->next;\n    }\n    \n    return true;\n}\n\n/* Step through the iterator until an extension field is found or until all\n * entries have been checked. There can be only one extension field per\n * message. Returns false if no extension field is found. */\nstatic bool checkreturn find_extension_field(pb_field_iter_t *iter)\n{\n    const pb_field_t *start = iter->pos;\n    \n    do {\n        if (PB_LTYPE(iter->pos->type) == PB_LTYPE_EXTENSION)\n            return true;\n        (void)pb_field_iter_next(iter);\n    } while (iter->pos != start);\n    \n    return false;\n}\n\n/* Initialize message fields to default values, recursively */\nstatic void pb_message_set_to_defaults(const pb_field_t fields[], void *dest_struct)\n{\n    pb_field_iter_t iter;\n\n    if (!pb_field_iter_begin(&iter, fields, dest_struct))\n        return; /* Empty message type */\n    \n    do\n    {\n        pb_type_t type;\n        type = iter.pos->type;\n        \n        if (PB_ATYPE(type) == PB_ATYPE_STATIC)\n        {\n            if (PB_HTYPE(type) == PB_HTYPE_OPTIONAL)\n            {\n                /* Set has_field to false. Still initialize the optional field\n                 * itself also. */\n                *(bool*)iter.pSize = false;\n            }\n            else if (PB_HTYPE(type) == PB_HTYPE_REPEATED)\n            {\n                /* Set array count to 0, no need to initialize contents. */\n                *(pb_size_t*)iter.pSize = 0;\n                continue;\n            }\n            \n            if (PB_LTYPE(iter.pos->type) == PB_LTYPE_SUBMESSAGE)\n            {\n                /* Initialize submessage to defaults */\n                pb_message_set_to_defaults((const pb_field_t *) iter.pos->ptr, iter.pData);\n            }\n            else if (iter.pos->ptr != NULL)\n            {\n                /* Initialize to default value */\n                memcpy(iter.pData, iter.pos->ptr, iter.pos->data_size);\n            }\n            else\n            {\n                /* Initialize to zeros */\n                memset(iter.pData, 0, iter.pos->data_size);\n            }\n        }\n        else if (PB_ATYPE(type) == PB_ATYPE_POINTER)\n        {\n            /* Initialize the pointer to NULL. */\n            *(void**)iter.pData = NULL;\n            \n            /* Initialize array count to 0. */\n            if (PB_HTYPE(type) == PB_HTYPE_REPEATED)\n            {\n                *(pb_size_t*)iter.pSize = 0;\n            }\n        }\n        else if (PB_ATYPE(type) == PB_ATYPE_CALLBACK)\n        {\n            /* Don't overwrite callback */\n        }\n    } while (pb_field_iter_next(&iter));\n}\n\n/*********************\n * Decode all fields *\n *********************/\n\nbool checkreturn pb_decode_noinit(pb_istream_t *stream, const pb_field_t fields[], void *dest_struct)\n{\n    uint8_t fields_seen[(PB_MAX_REQUIRED_FIELDS + 7) / 8] = {0, 0, 0, 0, 0, 0, 0, 0};\n    uint32_t extension_range_start = 0;\n    pb_field_iter_t iter;\n    \n    /* Return value ignored, as empty message types will be correctly handled by\n     * pb_field_iter_find() anyway. */\n    (void)pb_field_iter_begin(&iter, fields, dest_struct);\n    \n    while (stream->bytes_left)\n    {\n        uint32_t tag;\n        pb_wire_type_t wire_type;\n        bool eof;\n        \n        if (!pb_decode_tag(stream, &wire_type, &tag, &eof))\n        {\n            if (eof)\n                break;\n            else\n                return false;\n        }\n        \n        if (!pb_field_iter_find(&iter, tag))\n        {\n            /* No match found, check if it matches an extension. */\n            if (tag >= extension_range_start)\n            {\n                if (!find_extension_field(&iter))\n                    extension_range_start = (uint32_t)-1;\n                else\n                    extension_range_start = iter.pos->tag;\n                \n                if (tag >= extension_range_start)\n                {\n                    size_t pos = stream->bytes_left;\n                \n                    if (!decode_extension(stream, tag, wire_type, &iter))\n                        return false;\n                    \n                    if (pos != stream->bytes_left)\n                    {\n                        /* The field was handled */\n                        continue;                    \n                    }\n                }\n            }\n        \n            /* No match found, skip data */\n            if (!pb_skip_field(stream, wire_type))\n                return false;\n            continue;\n        }\n        \n        if (PB_HTYPE(iter.pos->type) == PB_HTYPE_REQUIRED\n            && iter.required_field_index < PB_MAX_REQUIRED_FIELDS)\n        {\n            fields_seen[iter.required_field_index >> 3] |= (uint8_t)(1 << (iter.required_field_index & 7));\n        }\n            \n        if (!decode_field(stream, wire_type, &iter))\n            return false;\n    }\n    \n    /* Check that all required fields were present. */\n    {\n        /* First figure out the number of required fields by\n         * seeking to the end of the field array. Usually we\n         * are already close to end after decoding.\n         */\n        unsigned req_field_count;\n        pb_type_t last_type;\n        unsigned i;\n        do {\n            req_field_count = iter.required_field_index;\n            last_type = iter.pos->type;\n        } while (pb_field_iter_next(&iter));\n        \n        /* Fixup if last field was also required. */\n        if (PB_HTYPE(last_type) == PB_HTYPE_REQUIRED && iter.pos->tag != 0)\n            req_field_count++;\n        \n        /* Check the whole bytes */\n        for (i = 0; i < (req_field_count >> 3); i++)\n        {\n            if (fields_seen[i] != 0xFF)\n                PB_RETURN_ERROR(stream, \"missing required field\");\n        }\n        \n        /* Check the remaining bits */\n        if (fields_seen[req_field_count >> 3] != (0xFF >> (8 - (req_field_count & 7))))\n            PB_RETURN_ERROR(stream, \"missing required field\");\n    }\n    \n    return true;\n}\n\nbool checkreturn pb_decode(pb_istream_t *stream, const pb_field_t fields[], void *dest_struct)\n{\n    bool status;\n    pb_message_set_to_defaults(fields, dest_struct);\n    status = pb_decode_noinit(stream, fields, dest_struct);\n    \n#ifdef PB_ENABLE_MALLOC\n    if (!status)\n        pb_release(fields, dest_struct);\n#endif\n    \n    return status;\n}\n\nbool pb_decode_delimited(pb_istream_t *stream, const pb_field_t fields[], void *dest_struct)\n{\n    pb_istream_t substream;\n    bool status;\n    \n    if (!pb_make_string_substream(stream, &substream))\n        return false;\n    \n    status = pb_decode(&substream, fields, dest_struct);\n    pb_close_string_substream(stream, &substream);\n    return status;\n}\n\n#ifdef PB_ENABLE_MALLOC\nstatic void pb_release_single_field(const pb_field_iter_t *iter)\n{\n    pb_type_t type;\n    type = iter->pos->type;\n\n    if (PB_ATYPE(type) == PB_ATYPE_POINTER)\n    {\n        if (PB_HTYPE(type) == PB_HTYPE_REPEATED &&\n            (PB_LTYPE(type) == PB_LTYPE_STRING ||\n             PB_LTYPE(type) == PB_LTYPE_BYTES))\n        {\n            /* Release entries in repeated string or bytes array */\n            void **pItem = *(void***)iter->pData;\n            pb_size_t count = *(pb_size_t*)iter->pSize;\n            while (count--)\n            {\n                pb_free(*pItem);\n                *pItem++ = NULL;\n            }\n            *(pb_size_t*)iter->pSize = 0;\n        }\n        else if (PB_LTYPE(type) == PB_LTYPE_SUBMESSAGE)\n        {\n            /* Release fields in submessages */\n            void *pItem = *(void**)iter->pData;\n            if (pItem)\n            {\n                pb_size_t count = 1;\n                \n                if (PB_HTYPE(type) == PB_HTYPE_REPEATED)\n                {\n                    count = *(pb_size_t*)iter->pSize;\n                    *(pb_size_t*)iter->pSize = 0;\n                }\n                \n                while (count--)\n                {\n                    pb_release((const pb_field_t*)iter->pos->ptr, pItem);\n                    pItem = (uint8_t*)pItem + iter->pos->data_size;\n                }\n            }\n        }\n        \n        /* Release main item */\n        pb_free(*(void**)iter->pData);\n        *(void**)iter->pData = NULL;\n    }\n}\n\nvoid pb_release(const pb_field_t fields[], void *dest_struct)\n{\n    pb_field_iter_t iter;\n    \n    if (!pb_field_iter_begin(&iter, fields, dest_struct))\n        return; /* Empty message type */\n    \n    do\n    {\n        pb_release_single_field(&iter);\n    } while (pb_field_iter_next(&iter));\n}\n#endif\n\n/* Field decoders */\n\nbool pb_decode_svarint(pb_istream_t *stream, int64_t *dest)\n{\n    uint64_t value;\n    if (!pb_decode_varint(stream, &value))\n        return false;\n    \n    if (value & 1)\n        *dest = (int64_t)(~(value >> 1));\n    else\n        *dest = (int64_t)(value >> 1);\n    \n    return true;\n}\n\nbool pb_decode_fixed32(pb_istream_t *stream, void *dest)\n{\n    #ifdef __BIG_ENDIAN__\n    uint8_t *bytes = (uint8_t*)dest;\n    uint8_t lebytes[4];\n    \n    if (!pb_read(stream, lebytes, 4))\n        return false;\n    \n    bytes[0] = lebytes[3];\n    bytes[1] = lebytes[2];\n    bytes[2] = lebytes[1];\n    bytes[3] = lebytes[0];\n    return true;\n    #else\n    return pb_read(stream, (uint8_t*)dest, 4);\n    #endif   \n}\n\nbool pb_decode_fixed64(pb_istream_t *stream, void *dest)\n{\n    #ifdef __BIG_ENDIAN__\n    uint8_t *bytes = (uint8_t*)dest;\n    uint8_t lebytes[8];\n    \n    if (!pb_read(stream, lebytes, 8))\n        return false;\n    \n    bytes[0] = lebytes[7];\n    bytes[1] = lebytes[6];\n    bytes[2] = lebytes[5];\n    bytes[3] = lebytes[4];\n    bytes[4] = lebytes[3];\n    bytes[5] = lebytes[2];\n    bytes[6] = lebytes[1];\n    bytes[7] = lebytes[0];\n    return true;\n    #else\n    return pb_read(stream, (uint8_t*)dest, 8);\n    #endif   \n}\n\nstatic bool checkreturn pb_dec_varint(pb_istream_t *stream, const pb_field_t *field, void *dest)\n{\n    uint64_t value;\n    if (!pb_decode_varint(stream, &value))\n        return false;\n    \n    switch (field->data_size)\n    {\n        case 1: *(int8_t*)dest = (int8_t)value; break;\n        case 2: *(int16_t*)dest = (int16_t)value; break;\n        case 4: *(int32_t*)dest = (int32_t)value; break;\n        case 8: *(int64_t*)dest = (int64_t)value; break;\n        default: PB_RETURN_ERROR(stream, \"invalid data_size\");\n    }\n    \n    return true;\n}\n\nstatic bool checkreturn pb_dec_uvarint(pb_istream_t *stream, const pb_field_t *field, void *dest)\n{\n    uint64_t value;\n    if (!pb_decode_varint(stream, &value))\n        return false;\n    \n    switch (field->data_size)\n    {\n        case 4: *(uint32_t*)dest = (uint32_t)value; break;\n        case 8: *(uint64_t*)dest = value; break;\n        default: PB_RETURN_ERROR(stream, \"invalid data_size\");\n    }\n    \n    return true;\n}\n\nstatic bool checkreturn pb_dec_svarint(pb_istream_t *stream, const pb_field_t *field, void *dest)\n{\n    int64_t value;\n    if (!pb_decode_svarint(stream, &value))\n        return false;\n    \n    switch (field->data_size)\n    {\n        case 4: *(int32_t*)dest = (int32_t)value; break;\n        case 8: *(int64_t*)dest = value; break;\n        default: PB_RETURN_ERROR(stream, \"invalid data_size\");\n    }\n    \n    return true;\n}\n\nstatic bool checkreturn pb_dec_fixed32(pb_istream_t *stream, const pb_field_t *field, void *dest)\n{\n    PB_UNUSED(field);\n    return pb_decode_fixed32(stream, dest);\n}\n\nstatic bool checkreturn pb_dec_fixed64(pb_istream_t *stream, const pb_field_t *field, void *dest)\n{\n    PB_UNUSED(field);\n    return pb_decode_fixed64(stream, dest);\n}\n\nstatic bool checkreturn pb_dec_bytes(pb_istream_t *stream, const pb_field_t *field, void *dest)\n{\n    uint32_t size;\n    pb_bytes_array_t *bdest;\n    \n    if (!pb_decode_varint32(stream, &size))\n        return false;\n    \n    if (PB_ATYPE(field->type) == PB_ATYPE_POINTER)\n    {\n#ifndef PB_ENABLE_MALLOC\n        PB_RETURN_ERROR(stream, \"no malloc support\");\n#else\n        if (!allocate_field(stream, dest, PB_BYTES_ARRAY_T_ALLOCSIZE(size), 1))\n            return false;\n        bdest = *(pb_bytes_array_t**)dest;\n#endif\n    }\n    else\n    {\n        if (PB_BYTES_ARRAY_T_ALLOCSIZE(size) > field->data_size)\n            PB_RETURN_ERROR(stream, \"bytes overflow\");\n        bdest = (pb_bytes_array_t*)dest;\n    }\n    \n    if (size > PB_SIZE_MAX)\n    {\n        PB_RETURN_ERROR(stream, \"bytes overflow\");\n    }\n\n    bdest->size = (pb_size_t)size;\n    return pb_read(stream, bdest->bytes, size);\n}\n\nstatic bool checkreturn pb_dec_string(pb_istream_t *stream, const pb_field_t *field, void *dest)\n{\n    uint32_t size;\n    size_t alloc_size;\n    bool status;\n    if (!pb_decode_varint32(stream, &size))\n        return false;\n    \n    /* Space for null terminator */\n    alloc_size = size + 1;\n    \n    if (PB_ATYPE(field->type) == PB_ATYPE_POINTER)\n    {\n#ifndef PB_ENABLE_MALLOC\n        PB_RETURN_ERROR(stream, \"no malloc support\");\n#else\n        if (!allocate_field(stream, dest, alloc_size, 1))\n            return false;\n        dest = *(void**)dest;\n#endif\n    }\n    else\n    {\n        if (alloc_size > field->data_size)\n            PB_RETURN_ERROR(stream, \"string overflow\");\n    }\n    \n    status = pb_read(stream, (uint8_t*)dest, size);\n    *((uint8_t*)dest + size) = 0;\n    return status;\n}\n\nstatic bool checkreturn pb_dec_submessage(pb_istream_t *stream, const pb_field_t *field, void *dest)\n{\n    bool status;\n    pb_istream_t substream;\n    const pb_field_t* submsg_fields = (const pb_field_t*)field->ptr;\n    \n    if (!pb_make_string_substream(stream, &substream))\n        return false;\n    \n    if (field->ptr == NULL)\n        PB_RETURN_ERROR(stream, \"invalid field descriptor\");\n    \n    /* New array entries need to be initialized, while required and optional\n     * submessages have already been initialized in the top-level pb_decode. */\n    if (PB_HTYPE(field->type) == PB_HTYPE_REPEATED)\n        status = pb_decode(&substream, submsg_fields, dest);\n    else\n        status = pb_decode_noinit(&substream, submsg_fields, dest);\n    \n    pb_close_string_substream(stream, &substream);\n    return status;\n}\n"], "fixing_code": ["/* pb_decode.c -- decode a protobuf using minimal resources\n *\n * 2011 Petteri Aimonen <jpa@kapsi.fi>\n */\n\n/* Use the GCC warn_unused_result attribute to check that all return values\n * are propagated correctly. On other compilers and gcc before 3.4.0 just\n * ignore the annotation.\n */\n#if !defined(__GNUC__) || ( __GNUC__ < 3) || (__GNUC__ == 3 && __GNUC_MINOR__ < 4)\n    #define checkreturn\n#else\n    #define checkreturn __attribute__((warn_unused_result))\n#endif\n\n#include \"pb.h\"\n#include \"pb_decode.h\"\n#include \"pb_common.h\"\n\n/**************************************\n * Declarations internal to this file *\n **************************************/\n\ntypedef bool (*pb_decoder_t)(pb_istream_t *stream, const pb_field_t *field, void *dest) checkreturn;\n\nstatic bool checkreturn buf_read(pb_istream_t *stream, uint8_t *buf, size_t count);\nstatic bool checkreturn pb_decode_varint32(pb_istream_t *stream, uint32_t *dest);\nstatic bool checkreturn read_raw_value(pb_istream_t *stream, pb_wire_type_t wire_type, uint8_t *buf, size_t *size);\nstatic bool checkreturn decode_static_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter);\nstatic bool checkreturn decode_callback_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter);\nstatic bool checkreturn decode_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter);\nstatic bool checkreturn default_extension_decoder(pb_istream_t *stream, pb_extension_t *extension, uint32_t tag, pb_wire_type_t wire_type);\nstatic bool checkreturn decode_extension(pb_istream_t *stream, uint32_t tag, pb_wire_type_t wire_type, pb_field_iter_t *iter);\nstatic bool checkreturn find_extension_field(pb_field_iter_t *iter);\nstatic void pb_message_set_to_defaults(const pb_field_t fields[], void *dest_struct);\nstatic bool checkreturn pb_dec_varint(pb_istream_t *stream, const pb_field_t *field, void *dest);\nstatic bool checkreturn pb_dec_uvarint(pb_istream_t *stream, const pb_field_t *field, void *dest);\nstatic bool checkreturn pb_dec_svarint(pb_istream_t *stream, const pb_field_t *field, void *dest);\nstatic bool checkreturn pb_dec_fixed32(pb_istream_t *stream, const pb_field_t *field, void *dest);\nstatic bool checkreturn pb_dec_fixed64(pb_istream_t *stream, const pb_field_t *field, void *dest);\nstatic bool checkreturn pb_dec_bytes(pb_istream_t *stream, const pb_field_t *field, void *dest);\nstatic bool checkreturn pb_dec_string(pb_istream_t *stream, const pb_field_t *field, void *dest);\nstatic bool checkreturn pb_dec_submessage(pb_istream_t *stream, const pb_field_t *field, void *dest);\nstatic bool checkreturn pb_skip_varint(pb_istream_t *stream);\nstatic bool checkreturn pb_skip_string(pb_istream_t *stream);\n\n#ifdef PB_ENABLE_MALLOC\nstatic bool checkreturn allocate_field(pb_istream_t *stream, void *pData, size_t data_size, size_t array_size);\nstatic void pb_release_single_field(const pb_field_iter_t *iter);\n#endif\n\n/* --- Function pointers to field decoders ---\n * Order in the array must match pb_action_t LTYPE numbering.\n */\nstatic const pb_decoder_t PB_DECODERS[PB_LTYPES_COUNT] = {\n    &pb_dec_varint,\n    &pb_dec_uvarint,\n    &pb_dec_svarint,\n    &pb_dec_fixed32,\n    &pb_dec_fixed64,\n    \n    &pb_dec_bytes,\n    &pb_dec_string,\n    &pb_dec_submessage,\n    NULL /* extensions */\n};\n\n/*******************************\n * pb_istream_t implementation *\n *******************************/\n\nstatic bool checkreturn buf_read(pb_istream_t *stream, uint8_t *buf, size_t count)\n{\n    uint8_t *source = (uint8_t*)stream->state;\n    stream->state = source + count;\n    \n    if (buf != NULL)\n    {\n        while (count--)\n            *buf++ = *source++;\n    }\n    \n    return true;\n}\n\nbool checkreturn pb_read(pb_istream_t *stream, uint8_t *buf, size_t count)\n{\n#ifndef PB_BUFFER_ONLY\n\tif (buf == NULL && stream->callback != buf_read)\n\t{\n\t\t/* Skip input bytes */\n\t\tuint8_t tmp[16];\n\t\twhile (count > 16)\n\t\t{\n\t\t\tif (!pb_read(stream, tmp, 16))\n\t\t\t\treturn false;\n\t\t\t\n\t\t\tcount -= 16;\n\t\t}\n\t\t\n\t\treturn pb_read(stream, tmp, count);\n\t}\n#endif\n\n    if (stream->bytes_left < count)\n        PB_RETURN_ERROR(stream, \"end-of-stream\");\n    \n#ifndef PB_BUFFER_ONLY\n    if (!stream->callback(stream, buf, count))\n        PB_RETURN_ERROR(stream, \"io error\");\n#else\n    if (!buf_read(stream, buf, count))\n        return false;\n#endif\n    \n    stream->bytes_left -= count;\n    return true;\n}\n\n/* Read a single byte from input stream. buf may not be NULL.\n * This is an optimization for the varint decoding. */\nstatic bool checkreturn pb_readbyte(pb_istream_t *stream, uint8_t *buf)\n{\n    if (stream->bytes_left == 0)\n        PB_RETURN_ERROR(stream, \"end-of-stream\");\n\n#ifndef PB_BUFFER_ONLY\n    if (!stream->callback(stream, buf, 1))\n        PB_RETURN_ERROR(stream, \"io error\");\n#else\n    *buf = *(uint8_t*)stream->state;\n    stream->state = (uint8_t*)stream->state + 1;\n#endif\n\n    stream->bytes_left--;\n    \n    return true;    \n}\n\npb_istream_t pb_istream_from_buffer(uint8_t *buf, size_t bufsize)\n{\n    pb_istream_t stream;\n#ifdef PB_BUFFER_ONLY\n    stream.callback = NULL;\n#else\n    stream.callback = &buf_read;\n#endif\n    stream.state = buf;\n    stream.bytes_left = bufsize;\n#ifndef PB_NO_ERRMSG\n    stream.errmsg = NULL;\n#endif\n    return stream;\n}\n\n/********************\n * Helper functions *\n ********************/\n\nstatic bool checkreturn pb_decode_varint32(pb_istream_t *stream, uint32_t *dest)\n{\n    uint8_t byte;\n    uint32_t result;\n    \n    if (!pb_readbyte(stream, &byte))\n        return false;\n    \n    if ((byte & 0x80) == 0)\n    {\n        /* Quick case, 1 byte value */\n        result = byte;\n    }\n    else\n    {\n        /* Multibyte case */\n        uint8_t bitpos = 7;\n        result = byte & 0x7F;\n        \n        do\n        {\n            if (bitpos >= 32)\n                PB_RETURN_ERROR(stream, \"varint overflow\");\n            \n            if (!pb_readbyte(stream, &byte))\n                return false;\n            \n            result |= (uint32_t)(byte & 0x7F) << bitpos;\n            bitpos = (uint8_t)(bitpos + 7);\n        } while (byte & 0x80);\n   }\n   \n   *dest = result;\n   return true;\n}\n\nbool checkreturn pb_decode_varint(pb_istream_t *stream, uint64_t *dest)\n{\n    uint8_t byte;\n    uint8_t bitpos = 0;\n    uint64_t result = 0;\n    \n    do\n    {\n        if (bitpos >= 64)\n            PB_RETURN_ERROR(stream, \"varint overflow\");\n        \n        if (!pb_readbyte(stream, &byte))\n            return false;\n\n        result |= (uint64_t)(byte & 0x7F) << bitpos;\n        bitpos = (uint8_t)(bitpos + 7);\n    } while (byte & 0x80);\n    \n    *dest = result;\n    return true;\n}\n\nbool checkreturn pb_skip_varint(pb_istream_t *stream)\n{\n    uint8_t byte;\n    do\n    {\n        if (!pb_read(stream, &byte, 1))\n            return false;\n    } while (byte & 0x80);\n    return true;\n}\n\nbool checkreturn pb_skip_string(pb_istream_t *stream)\n{\n    uint32_t length;\n    if (!pb_decode_varint32(stream, &length))\n        return false;\n    \n    return pb_read(stream, NULL, length);\n}\n\nbool checkreturn pb_decode_tag(pb_istream_t *stream, pb_wire_type_t *wire_type, uint32_t *tag, bool *eof)\n{\n    uint32_t temp;\n    *eof = false;\n    *wire_type = (pb_wire_type_t) 0;\n    *tag = 0;\n    \n    if (!pb_decode_varint32(stream, &temp))\n    {\n        if (stream->bytes_left == 0)\n            *eof = true;\n\n        return false;\n    }\n    \n    if (temp == 0)\n    {\n        *eof = true; /* Special feature: allow 0-terminated messages. */\n        return false;\n    }\n    \n    *tag = temp >> 3;\n    *wire_type = (pb_wire_type_t)(temp & 7);\n    return true;\n}\n\nbool checkreturn pb_skip_field(pb_istream_t *stream, pb_wire_type_t wire_type)\n{\n    switch (wire_type)\n    {\n        case PB_WT_VARINT: return pb_skip_varint(stream);\n        case PB_WT_64BIT: return pb_read(stream, NULL, 8);\n        case PB_WT_STRING: return pb_skip_string(stream);\n        case PB_WT_32BIT: return pb_read(stream, NULL, 4);\n        default: PB_RETURN_ERROR(stream, \"invalid wire_type\");\n    }\n}\n\n/* Read a raw value to buffer, for the purpose of passing it to callback as\n * a substream. Size is maximum size on call, and actual size on return.\n */\nstatic bool checkreturn read_raw_value(pb_istream_t *stream, pb_wire_type_t wire_type, uint8_t *buf, size_t *size)\n{\n    size_t max_size = *size;\n    switch (wire_type)\n    {\n        case PB_WT_VARINT:\n            *size = 0;\n            do\n            {\n                (*size)++;\n                if (*size > max_size) return false;\n                if (!pb_read(stream, buf, 1)) return false;\n            } while (*buf++ & 0x80);\n            return true;\n            \n        case PB_WT_64BIT:\n            *size = 8;\n            return pb_read(stream, buf, 8);\n        \n        case PB_WT_32BIT:\n            *size = 4;\n            return pb_read(stream, buf, 4);\n        \n        default: PB_RETURN_ERROR(stream, \"invalid wire_type\");\n    }\n}\n\n/* Decode string length from stream and return a substream with limited length.\n * Remember to close the substream using pb_close_string_substream().\n */\nbool checkreturn pb_make_string_substream(pb_istream_t *stream, pb_istream_t *substream)\n{\n    uint32_t size;\n    if (!pb_decode_varint32(stream, &size))\n        return false;\n    \n    *substream = *stream;\n    if (substream->bytes_left < size)\n        PB_RETURN_ERROR(stream, \"parent stream too short\");\n    \n    substream->bytes_left = size;\n    stream->bytes_left -= size;\n    return true;\n}\n\nvoid pb_close_string_substream(pb_istream_t *stream, pb_istream_t *substream)\n{\n    stream->state = substream->state;\n\n#ifndef PB_NO_ERRMSG\n    stream->errmsg = substream->errmsg;\n#endif\n}\n\n/*************************\n * Decode a single field *\n *************************/\n\nstatic bool checkreturn decode_static_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter)\n{\n    pb_type_t type;\n    pb_decoder_t func;\n    \n    type = iter->pos->type;\n    func = PB_DECODERS[PB_LTYPE(type)];\n\n    switch (PB_HTYPE(type))\n    {\n        case PB_HTYPE_REQUIRED:\n            return func(stream, iter->pos, iter->pData);\n            \n        case PB_HTYPE_OPTIONAL:\n            *(bool*)iter->pSize = true;\n            return func(stream, iter->pos, iter->pData);\n    \n        case PB_HTYPE_REPEATED:\n            if (wire_type == PB_WT_STRING\n                && PB_LTYPE(type) <= PB_LTYPE_LAST_PACKABLE)\n            {\n                /* Packed array */\n                bool status = true;\n                pb_size_t *size = (pb_size_t*)iter->pSize;\n                pb_istream_t substream;\n                if (!pb_make_string_substream(stream, &substream))\n                    return false;\n                \n                while (substream.bytes_left > 0 && *size < iter->pos->array_size)\n                {\n                    void *pItem = (uint8_t*)iter->pData + iter->pos->data_size * (*size);\n                    if (!func(&substream, iter->pos, pItem))\n                    {\n                        status = false;\n                        break;\n                    }\n                    (*size)++;\n                }\n                pb_close_string_substream(stream, &substream);\n                \n                if (substream.bytes_left != 0)\n                    PB_RETURN_ERROR(stream, \"array overflow\");\n                \n                return status;\n            }\n            else\n            {\n                /* Repeated field */\n                pb_size_t *size = (pb_size_t*)iter->pSize;\n                void *pItem = (uint8_t*)iter->pData + iter->pos->data_size * (*size);\n                if (*size >= iter->pos->array_size)\n                    PB_RETURN_ERROR(stream, \"array overflow\");\n                \n                (*size)++;\n                return func(stream, iter->pos, pItem);\n            }\n\n        default:\n            PB_RETURN_ERROR(stream, \"invalid field type\");\n    }\n}\n\n#ifdef PB_ENABLE_MALLOC\n/* Allocate storage for the field and store the pointer at iter->pData.\n * array_size is the number of entries to reserve in an array.\n * Zero size is not allowed, use pb_free() for releasing.\n */\nstatic bool checkreturn allocate_field(pb_istream_t *stream, void *pData, size_t data_size, size_t array_size)\n{    \n    void *ptr = *(void**)pData;\n    \n    if (data_size == 0 || array_size == 0)\n        PB_RETURN_ERROR(stream, \"invalid size\");\n    \n    /* Check for multiplication overflows.\n     * This code avoids the costly division if the sizes are small enough.\n     * Multiplication is safe as long as only half of bits are set\n     * in either multiplicand.\n     */\n    {\n        const size_t check_limit = (size_t)1 << (sizeof(size_t) * 4);\n        if (data_size >= check_limit || array_size >= check_limit)\n        {\n            const size_t size_max = (size_t)-1;\n            if (size_max / array_size < data_size)\n            {\n                PB_RETURN_ERROR(stream, \"size too large\");\n            }\n        }\n    }\n    \n    /* Allocate new or expand previous allocation */\n    /* Note: on failure the old pointer will remain in the structure,\n     * the message must be freed by caller also on error return. */\n    ptr = pb_realloc(ptr, array_size * data_size);\n    if (ptr == NULL)\n        PB_RETURN_ERROR(stream, \"realloc failed\");\n    \n    *(void**)pData = ptr;\n    return true;\n}\n\n/* Clear a newly allocated item in case it contains a pointer, or is a submessage. */\nstatic void initialize_pointer_field(void *pItem, pb_field_iter_t *iter)\n{\n    if (PB_LTYPE(iter->pos->type) == PB_LTYPE_STRING ||\n        PB_LTYPE(iter->pos->type) == PB_LTYPE_BYTES)\n    {\n        *(void**)pItem = NULL;\n    }\n    else if (PB_LTYPE(iter->pos->type) == PB_LTYPE_SUBMESSAGE)\n    {\n        pb_message_set_to_defaults((const pb_field_t *) iter->pos->ptr, pItem);\n    }\n}\n#endif\n\nstatic bool checkreturn decode_pointer_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter)\n{\n#ifndef PB_ENABLE_MALLOC\n    PB_UNUSED(wire_type);\n    PB_UNUSED(iter);\n    PB_RETURN_ERROR(stream, \"no malloc support\");\n#else\n    pb_type_t type;\n    pb_decoder_t func;\n    \n    type = iter->pos->type;\n    func = PB_DECODERS[PB_LTYPE(type)];\n    \n    switch (PB_HTYPE(type))\n    {\n        case PB_HTYPE_REQUIRED:\n        case PB_HTYPE_OPTIONAL:\n            if (PB_LTYPE(type) == PB_LTYPE_SUBMESSAGE &&\n                *(void**)iter->pData != NULL)\n            {\n                /* Duplicate field, have to release the old allocation first. */\n                pb_release_single_field(iter);\n            }\n        \n            if (PB_LTYPE(type) == PB_LTYPE_STRING ||\n                PB_LTYPE(type) == PB_LTYPE_BYTES)\n            {\n                return func(stream, iter->pos, iter->pData);\n            }\n            else\n            {\n                if (!allocate_field(stream, iter->pData, iter->pos->data_size, 1))\n                    return false;\n                \n                initialize_pointer_field(*(void**)iter->pData, iter);\n                return func(stream, iter->pos, *(void**)iter->pData);\n            }\n    \n        case PB_HTYPE_REPEATED:\n            if (wire_type == PB_WT_STRING\n                && PB_LTYPE(type) <= PB_LTYPE_LAST_PACKABLE)\n            {\n                /* Packed array, multiple items come in at once. */\n                bool status = true;\n                pb_size_t *size = (pb_size_t*)iter->pSize;\n                size_t allocated_size = *size;\n                void *pItem;\n                pb_istream_t substream;\n                \n                if (!pb_make_string_substream(stream, &substream))\n                    return false;\n                \n                while (substream.bytes_left)\n                {\n                    if ((size_t)*size + 1 > allocated_size)\n                    {\n                        /* Allocate more storage. This tries to guess the\n                         * number of remaining entries. Round the division\n                         * upwards. */\n                        allocated_size += (substream.bytes_left - 1) / iter->pos->data_size + 1;\n                        \n                        if (!allocate_field(&substream, iter->pData, iter->pos->data_size, allocated_size))\n                        {\n                            status = false;\n                            break;\n                        }\n                    }\n\n                    /* Decode the array entry */\n                    pItem = *(uint8_t**)iter->pData + iter->pos->data_size * (*size);\n                    initialize_pointer_field(pItem, iter);\n                    if (!func(&substream, iter->pos, pItem))\n                    {\n                        status = false;\n                        break;\n                    }\n                    \n                    if (*size == PB_SIZE_MAX)\n                    {\n#ifndef PB_NO_ERRMSG\n                        stream->errmsg = \"too many array entries\";\n#endif\n                        status = false;\n                        break;\n                    }\n                    \n                    (*size)++;\n                }\n                pb_close_string_substream(stream, &substream);\n                \n                return status;\n            }\n            else\n            {\n                /* Normal repeated field, i.e. only one item at a time. */\n                pb_size_t *size = (pb_size_t*)iter->pSize;\n                void *pItem;\n                \n                if (*size == PB_SIZE_MAX)\n                    PB_RETURN_ERROR(stream, \"too many array entries\");\n                \n                (*size)++;\n                if (!allocate_field(stream, iter->pData, iter->pos->data_size, *size))\n                    return false;\n            \n                pItem = *(uint8_t**)iter->pData + iter->pos->data_size * (*size - 1);\n                initialize_pointer_field(pItem, iter);\n                return func(stream, iter->pos, pItem);\n            }\n            \n        default:\n            PB_RETURN_ERROR(stream, \"invalid field type\");\n    }\n#endif\n}\n\nstatic bool checkreturn decode_callback_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter)\n{\n    pb_callback_t *pCallback = (pb_callback_t*)iter->pData;\n    \n#ifdef PB_OLD_CALLBACK_STYLE\n    void *arg = pCallback->arg;\n#else\n    void **arg = &(pCallback->arg);\n#endif\n    \n    if (pCallback->funcs.decode == NULL)\n        return pb_skip_field(stream, wire_type);\n    \n    if (wire_type == PB_WT_STRING)\n    {\n        pb_istream_t substream;\n        \n        if (!pb_make_string_substream(stream, &substream))\n            return false;\n        \n        do\n        {\n            if (!pCallback->funcs.decode(&substream, iter->pos, arg))\n                PB_RETURN_ERROR(stream, \"callback failed\");\n        } while (substream.bytes_left);\n        \n        pb_close_string_substream(stream, &substream);\n        return true;\n    }\n    else\n    {\n        /* Copy the single scalar value to stack.\n         * This is required so that we can limit the stream length,\n         * which in turn allows to use same callback for packed and\n         * not-packed fields. */\n        pb_istream_t substream;\n        uint8_t buffer[10];\n        size_t size = sizeof(buffer);\n        \n        if (!read_raw_value(stream, wire_type, buffer, &size))\n            return false;\n        substream = pb_istream_from_buffer(buffer, size);\n        \n        return pCallback->funcs.decode(&substream, iter->pos, arg);\n    }\n}\n\nstatic bool checkreturn decode_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter)\n{\n    switch (PB_ATYPE(iter->pos->type))\n    {\n        case PB_ATYPE_STATIC:\n            return decode_static_field(stream, wire_type, iter);\n        \n        case PB_ATYPE_POINTER:\n            return decode_pointer_field(stream, wire_type, iter);\n        \n        case PB_ATYPE_CALLBACK:\n            return decode_callback_field(stream, wire_type, iter);\n        \n        default:\n            PB_RETURN_ERROR(stream, \"invalid field type\");\n    }\n}\n\n/* Default handler for extension fields. Expects a pb_field_t structure\n * in extension->type->arg. */\nstatic bool checkreturn default_extension_decoder(pb_istream_t *stream,\n    pb_extension_t *extension, uint32_t tag, pb_wire_type_t wire_type)\n{\n    const pb_field_t *field = (const pb_field_t*)extension->type->arg;\n    pb_field_iter_t iter;\n    \n    if (field->tag != tag)\n        return true;\n    \n    /* Fake a field iterator for the extension field.\n     * It is not actually safe to advance this iterator, but decode_field\n     * will not even try to. */\n    (void)pb_field_iter_begin(&iter, field, extension->dest);\n    iter.pData = extension->dest;\n    iter.pSize = &extension->found;\n    \n    return decode_field(stream, wire_type, &iter);\n}\n\n/* Try to decode an unknown field as an extension field. Tries each extension\n * decoder in turn, until one of them handles the field or loop ends. */\nstatic bool checkreturn decode_extension(pb_istream_t *stream,\n    uint32_t tag, pb_wire_type_t wire_type, pb_field_iter_t *iter)\n{\n    pb_extension_t *extension = *(pb_extension_t* const *)iter->pData;\n    size_t pos = stream->bytes_left;\n    \n    while (extension != NULL && pos == stream->bytes_left)\n    {\n        bool status;\n        if (extension->type->decode)\n            status = extension->type->decode(stream, extension, tag, wire_type);\n        else\n            status = default_extension_decoder(stream, extension, tag, wire_type);\n\n        if (!status)\n            return false;\n        \n        extension = extension->next;\n    }\n    \n    return true;\n}\n\n/* Step through the iterator until an extension field is found or until all\n * entries have been checked. There can be only one extension field per\n * message. Returns false if no extension field is found. */\nstatic bool checkreturn find_extension_field(pb_field_iter_t *iter)\n{\n    const pb_field_t *start = iter->pos;\n    \n    do {\n        if (PB_LTYPE(iter->pos->type) == PB_LTYPE_EXTENSION)\n            return true;\n        (void)pb_field_iter_next(iter);\n    } while (iter->pos != start);\n    \n    return false;\n}\n\n/* Initialize message fields to default values, recursively */\nstatic void pb_message_set_to_defaults(const pb_field_t fields[], void *dest_struct)\n{\n    pb_field_iter_t iter;\n\n    if (!pb_field_iter_begin(&iter, fields, dest_struct))\n        return; /* Empty message type */\n    \n    do\n    {\n        pb_type_t type;\n        type = iter.pos->type;\n        \n        if (PB_ATYPE(type) == PB_ATYPE_STATIC)\n        {\n            if (PB_HTYPE(type) == PB_HTYPE_OPTIONAL)\n            {\n                /* Set has_field to false. Still initialize the optional field\n                 * itself also. */\n                *(bool*)iter.pSize = false;\n            }\n            else if (PB_HTYPE(type) == PB_HTYPE_REPEATED)\n            {\n                /* Set array count to 0, no need to initialize contents. */\n                *(pb_size_t*)iter.pSize = 0;\n                continue;\n            }\n            \n            if (PB_LTYPE(iter.pos->type) == PB_LTYPE_SUBMESSAGE)\n            {\n                /* Initialize submessage to defaults */\n                pb_message_set_to_defaults((const pb_field_t *) iter.pos->ptr, iter.pData);\n            }\n            else if (iter.pos->ptr != NULL)\n            {\n                /* Initialize to default value */\n                memcpy(iter.pData, iter.pos->ptr, iter.pos->data_size);\n            }\n            else\n            {\n                /* Initialize to zeros */\n                memset(iter.pData, 0, iter.pos->data_size);\n            }\n        }\n        else if (PB_ATYPE(type) == PB_ATYPE_POINTER)\n        {\n            /* Initialize the pointer to NULL. */\n            *(void**)iter.pData = NULL;\n            \n            /* Initialize array count to 0. */\n            if (PB_HTYPE(type) == PB_HTYPE_REPEATED)\n            {\n                *(pb_size_t*)iter.pSize = 0;\n            }\n        }\n        else if (PB_ATYPE(type) == PB_ATYPE_CALLBACK)\n        {\n            /* Don't overwrite callback */\n        }\n    } while (pb_field_iter_next(&iter));\n}\n\n/*********************\n * Decode all fields *\n *********************/\n\nbool checkreturn pb_decode_noinit(pb_istream_t *stream, const pb_field_t fields[], void *dest_struct)\n{\n    uint8_t fields_seen[(PB_MAX_REQUIRED_FIELDS + 7) / 8] = {0, 0, 0, 0, 0, 0, 0, 0};\n    uint32_t extension_range_start = 0;\n    pb_field_iter_t iter;\n    \n    /* Return value ignored, as empty message types will be correctly handled by\n     * pb_field_iter_find() anyway. */\n    (void)pb_field_iter_begin(&iter, fields, dest_struct);\n    \n    while (stream->bytes_left)\n    {\n        uint32_t tag;\n        pb_wire_type_t wire_type;\n        bool eof;\n        \n        if (!pb_decode_tag(stream, &wire_type, &tag, &eof))\n        {\n            if (eof)\n                break;\n            else\n                return false;\n        }\n        \n        if (!pb_field_iter_find(&iter, tag))\n        {\n            /* No match found, check if it matches an extension. */\n            if (tag >= extension_range_start)\n            {\n                if (!find_extension_field(&iter))\n                    extension_range_start = (uint32_t)-1;\n                else\n                    extension_range_start = iter.pos->tag;\n                \n                if (tag >= extension_range_start)\n                {\n                    size_t pos = stream->bytes_left;\n                \n                    if (!decode_extension(stream, tag, wire_type, &iter))\n                        return false;\n                    \n                    if (pos != stream->bytes_left)\n                    {\n                        /* The field was handled */\n                        continue;                    \n                    }\n                }\n            }\n        \n            /* No match found, skip data */\n            if (!pb_skip_field(stream, wire_type))\n                return false;\n            continue;\n        }\n        \n        if (PB_HTYPE(iter.pos->type) == PB_HTYPE_REQUIRED\n            && iter.required_field_index < PB_MAX_REQUIRED_FIELDS)\n        {\n            fields_seen[iter.required_field_index >> 3] |= (uint8_t)(1 << (iter.required_field_index & 7));\n        }\n            \n        if (!decode_field(stream, wire_type, &iter))\n            return false;\n    }\n    \n    /* Check that all required fields were present. */\n    {\n        /* First figure out the number of required fields by\n         * seeking to the end of the field array. Usually we\n         * are already close to end after decoding.\n         */\n        unsigned req_field_count;\n        pb_type_t last_type;\n        unsigned i;\n        do {\n            req_field_count = iter.required_field_index;\n            last_type = iter.pos->type;\n        } while (pb_field_iter_next(&iter));\n        \n        /* Fixup if last field was also required. */\n        if (PB_HTYPE(last_type) == PB_HTYPE_REQUIRED && iter.pos->tag != 0)\n            req_field_count++;\n        \n        /* Check the whole bytes */\n        for (i = 0; i < (req_field_count >> 3); i++)\n        {\n            if (fields_seen[i] != 0xFF)\n                PB_RETURN_ERROR(stream, \"missing required field\");\n        }\n        \n        /* Check the remaining bits */\n        if (fields_seen[req_field_count >> 3] != (0xFF >> (8 - (req_field_count & 7))))\n            PB_RETURN_ERROR(stream, \"missing required field\");\n    }\n    \n    return true;\n}\n\nbool checkreturn pb_decode(pb_istream_t *stream, const pb_field_t fields[], void *dest_struct)\n{\n    bool status;\n    pb_message_set_to_defaults(fields, dest_struct);\n    status = pb_decode_noinit(stream, fields, dest_struct);\n    \n#ifdef PB_ENABLE_MALLOC\n    if (!status)\n        pb_release(fields, dest_struct);\n#endif\n    \n    return status;\n}\n\nbool pb_decode_delimited(pb_istream_t *stream, const pb_field_t fields[], void *dest_struct)\n{\n    pb_istream_t substream;\n    bool status;\n    \n    if (!pb_make_string_substream(stream, &substream))\n        return false;\n    \n    status = pb_decode(&substream, fields, dest_struct);\n    pb_close_string_substream(stream, &substream);\n    return status;\n}\n\n#ifdef PB_ENABLE_MALLOC\nstatic void pb_release_single_field(const pb_field_iter_t *iter)\n{\n    pb_type_t type;\n    type = iter->pos->type;\n\n    if (PB_ATYPE(type) == PB_ATYPE_POINTER)\n    {\n        if (PB_HTYPE(type) == PB_HTYPE_REPEATED &&\n            (PB_LTYPE(type) == PB_LTYPE_STRING ||\n             PB_LTYPE(type) == PB_LTYPE_BYTES))\n        {\n            /* Release entries in repeated string or bytes array */\n            void **pItem = *(void***)iter->pData;\n            pb_size_t count = *(pb_size_t*)iter->pSize;\n            while (count--)\n            {\n                pb_free(*pItem);\n                *pItem++ = NULL;\n            }\n            *(pb_size_t*)iter->pSize = 0;\n        }\n        else if (PB_LTYPE(type) == PB_LTYPE_SUBMESSAGE)\n        {\n            /* Release fields in submessages */\n            void *pItem = *(void**)iter->pData;\n            if (pItem)\n            {\n                pb_size_t count = 1;\n                \n                if (PB_HTYPE(type) == PB_HTYPE_REPEATED)\n                {\n                    count = *(pb_size_t*)iter->pSize;\n                    *(pb_size_t*)iter->pSize = 0;\n                }\n                \n                while (count--)\n                {\n                    pb_release((const pb_field_t*)iter->pos->ptr, pItem);\n                    pItem = (uint8_t*)pItem + iter->pos->data_size;\n                }\n            }\n        }\n        \n        /* Release main item */\n        pb_free(*(void**)iter->pData);\n        *(void**)iter->pData = NULL;\n    }\n}\n\nvoid pb_release(const pb_field_t fields[], void *dest_struct)\n{\n    pb_field_iter_t iter;\n    \n    if (!pb_field_iter_begin(&iter, fields, dest_struct))\n        return; /* Empty message type */\n    \n    do\n    {\n        pb_release_single_field(&iter);\n    } while (pb_field_iter_next(&iter));\n}\n#endif\n\n/* Field decoders */\n\nbool pb_decode_svarint(pb_istream_t *stream, int64_t *dest)\n{\n    uint64_t value;\n    if (!pb_decode_varint(stream, &value))\n        return false;\n    \n    if (value & 1)\n        *dest = (int64_t)(~(value >> 1));\n    else\n        *dest = (int64_t)(value >> 1);\n    \n    return true;\n}\n\nbool pb_decode_fixed32(pb_istream_t *stream, void *dest)\n{\n    #ifdef __BIG_ENDIAN__\n    uint8_t *bytes = (uint8_t*)dest;\n    uint8_t lebytes[4];\n    \n    if (!pb_read(stream, lebytes, 4))\n        return false;\n    \n    bytes[0] = lebytes[3];\n    bytes[1] = lebytes[2];\n    bytes[2] = lebytes[1];\n    bytes[3] = lebytes[0];\n    return true;\n    #else\n    return pb_read(stream, (uint8_t*)dest, 4);\n    #endif   \n}\n\nbool pb_decode_fixed64(pb_istream_t *stream, void *dest)\n{\n    #ifdef __BIG_ENDIAN__\n    uint8_t *bytes = (uint8_t*)dest;\n    uint8_t lebytes[8];\n    \n    if (!pb_read(stream, lebytes, 8))\n        return false;\n    \n    bytes[0] = lebytes[7];\n    bytes[1] = lebytes[6];\n    bytes[2] = lebytes[5];\n    bytes[3] = lebytes[4];\n    bytes[4] = lebytes[3];\n    bytes[5] = lebytes[2];\n    bytes[6] = lebytes[1];\n    bytes[7] = lebytes[0];\n    return true;\n    #else\n    return pb_read(stream, (uint8_t*)dest, 8);\n    #endif   \n}\n\nstatic bool checkreturn pb_dec_varint(pb_istream_t *stream, const pb_field_t *field, void *dest)\n{\n    uint64_t value;\n    if (!pb_decode_varint(stream, &value))\n        return false;\n    \n    switch (field->data_size)\n    {\n        case 1: *(int8_t*)dest = (int8_t)value; break;\n        case 2: *(int16_t*)dest = (int16_t)value; break;\n        case 4: *(int32_t*)dest = (int32_t)value; break;\n        case 8: *(int64_t*)dest = (int64_t)value; break;\n        default: PB_RETURN_ERROR(stream, \"invalid data_size\");\n    }\n    \n    return true;\n}\n\nstatic bool checkreturn pb_dec_uvarint(pb_istream_t *stream, const pb_field_t *field, void *dest)\n{\n    uint64_t value;\n    if (!pb_decode_varint(stream, &value))\n        return false;\n    \n    switch (field->data_size)\n    {\n        case 4: *(uint32_t*)dest = (uint32_t)value; break;\n        case 8: *(uint64_t*)dest = value; break;\n        default: PB_RETURN_ERROR(stream, \"invalid data_size\");\n    }\n    \n    return true;\n}\n\nstatic bool checkreturn pb_dec_svarint(pb_istream_t *stream, const pb_field_t *field, void *dest)\n{\n    int64_t value;\n    if (!pb_decode_svarint(stream, &value))\n        return false;\n    \n    switch (field->data_size)\n    {\n        case 4: *(int32_t*)dest = (int32_t)value; break;\n        case 8: *(int64_t*)dest = value; break;\n        default: PB_RETURN_ERROR(stream, \"invalid data_size\");\n    }\n    \n    return true;\n}\n\nstatic bool checkreturn pb_dec_fixed32(pb_istream_t *stream, const pb_field_t *field, void *dest)\n{\n    PB_UNUSED(field);\n    return pb_decode_fixed32(stream, dest);\n}\n\nstatic bool checkreturn pb_dec_fixed64(pb_istream_t *stream, const pb_field_t *field, void *dest)\n{\n    PB_UNUSED(field);\n    return pb_decode_fixed64(stream, dest);\n}\n\nstatic bool checkreturn pb_dec_bytes(pb_istream_t *stream, const pb_field_t *field, void *dest)\n{\n    uint32_t size;\n    size_t alloc_size;\n    pb_bytes_array_t *bdest;\n    \n    if (!pb_decode_varint32(stream, &size))\n        return false;\n    \n    if (size > PB_SIZE_MAX)\n        PB_RETURN_ERROR(stream, \"bytes overflow\");\n    \n    alloc_size = PB_BYTES_ARRAY_T_ALLOCSIZE(size);\n    if (size > alloc_size)\n        PB_RETURN_ERROR(stream, \"size too large\");\n    \n    if (PB_ATYPE(field->type) == PB_ATYPE_POINTER)\n    {\n#ifndef PB_ENABLE_MALLOC\n        PB_RETURN_ERROR(stream, \"no malloc support\");\n#else\n        if (!allocate_field(stream, dest, alloc_size, 1))\n            return false;\n        bdest = *(pb_bytes_array_t**)dest;\n#endif\n    }\n    else\n    {\n        if (alloc_size > field->data_size)\n            PB_RETURN_ERROR(stream, \"bytes overflow\");\n        bdest = (pb_bytes_array_t*)dest;\n    }\n\n    bdest->size = (pb_size_t)size;\n    return pb_read(stream, bdest->bytes, size);\n}\n\nstatic bool checkreturn pb_dec_string(pb_istream_t *stream, const pb_field_t *field, void *dest)\n{\n    uint32_t size;\n    size_t alloc_size;\n    bool status;\n    if (!pb_decode_varint32(stream, &size))\n        return false;\n    \n    /* Space for null terminator */\n    alloc_size = size + 1;\n    \n    if (alloc_size < size)\n        PB_RETURN_ERROR(stream, \"size too large\");\n    \n    if (PB_ATYPE(field->type) == PB_ATYPE_POINTER)\n    {\n#ifndef PB_ENABLE_MALLOC\n        PB_RETURN_ERROR(stream, \"no malloc support\");\n#else\n        if (!allocate_field(stream, dest, alloc_size, 1))\n            return false;\n        dest = *(void**)dest;\n#endif\n    }\n    else\n    {\n        if (alloc_size > field->data_size)\n            PB_RETURN_ERROR(stream, \"string overflow\");\n    }\n    \n    status = pb_read(stream, (uint8_t*)dest, size);\n    *((uint8_t*)dest + size) = 0;\n    return status;\n}\n\nstatic bool checkreturn pb_dec_submessage(pb_istream_t *stream, const pb_field_t *field, void *dest)\n{\n    bool status;\n    pb_istream_t substream;\n    const pb_field_t* submsg_fields = (const pb_field_t*)field->ptr;\n    \n    if (!pb_make_string_substream(stream, &substream))\n        return false;\n    \n    if (field->ptr == NULL)\n        PB_RETURN_ERROR(stream, \"invalid field descriptor\");\n    \n    /* New array entries need to be initialized, while required and optional\n     * submessages have already been initialized in the top-level pb_decode. */\n    if (PB_HTYPE(field->type) == PB_HTYPE_REPEATED)\n        status = pb_decode(&substream, submsg_fields, dest);\n    else\n        status = pb_decode_noinit(&substream, submsg_fields, dest);\n    \n    pb_close_string_substream(stream, &substream);\n    return status;\n}\n"], "filenames": ["pb_decode.c"], "buggy_code_start_loc": [1074], "buggy_code_end_loc": [1115], "fixing_code_start_loc": [1075], "fixing_code_end_loc": [1122], "type": "CWE-787", "message": "Nanopb before 0.3.1 allows size_t overflows in pb_dec_bytes and pb_dec_string.", "other": {"cve": {"id": "CVE-2014-125106", "sourceIdentifier": "cve@mitre.org", "published": "2023-06-17T22:15:09.267", "lastModified": "2023-06-26T18:39:57.423", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Nanopb before 0.3.1 allows size_t overflows in pb_dec_bytes and pb_dec_string."}, {"lang": "es", "value": "Nanopb antes de v0.3.1 permite desbordamientos \"size_t\" en \"pb_dec_bytes\" y \"pb_dec_string\". "}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nanopb_project:nanopb:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.3.1", "matchCriteriaId": "0BCAADE6-030F-4B6B-912D-CC29109045CB"}]}]}], "references": [{"url": "https://github.com/nanopb/nanopb/blob/master/CHANGELOG.txt", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://github.com/nanopb/nanopb/commit/d2099cc8f1adb33d427a44a5e32ed27b647c7168", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/nanopb/nanopb/compare/nanopb-0.3.0...nanopb-0.3.1", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/nanopb/nanopb/commit/d2099cc8f1adb33d427a44a5e32ed27b647c7168"}}