{"buggy_code": ["/*       +------------------------------------+\n *       | Inspire Internet Relay Chat Daemon |\n *       +------------------------------------+\n *\n *  InspIRCd: (C) 2002-2010 InspIRCd Development Team\n * See: http://wiki.inspircd.org/Credits\n *\n * This program is free but copyrighted software; see\n *            the file COPYING for details.\n *\n * ---------------------------------------------------\n */\n\n/* $Core */\n\n/*\ndns.cpp - Nonblocking DNS functions.\nVery very loosely based on the firedns library,\nCopyright (C) 2002 Ian Gulliver. This file is no\nlonger anything like firedns, there are many major\ndifferences between this code and the original.\nPlease do not assume that firedns works like this,\nlooks like this, walks like this or tastes like this.\n*/\n\n#ifndef WIN32\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#else\n#include \"inspircd_win32wrapper.h\"\n#endif\n\n#include \"inspircd.h\"\n#include \"socketengine.h\"\n#include \"configreader.h\"\n#include \"socket.h\"\n\n/** Masks to mask off the responses we get from the DNSRequest methods\n */\nenum QueryInfo\n{\n\tERROR_MASK\t= 0x10000\t/* Result is an error */\n};\n\n/** Flags which can be ORed into a request or reply for different meanings\n */\nenum QueryFlags\n{\n\tFLAGS_MASK_RD\t\t= 0x01,\t/* Recursive */\n\tFLAGS_MASK_TC\t\t= 0x02,\n\tFLAGS_MASK_AA\t\t= 0x04,\t/* Authoritative */\n\tFLAGS_MASK_OPCODE\t= 0x78,\n\tFLAGS_MASK_QR\t\t= 0x80,\n\tFLAGS_MASK_RCODE\t= 0x0F,\t/* Request */\n\tFLAGS_MASK_Z\t\t= 0x70,\n\tFLAGS_MASK_RA \t\t= 0x80\n};\n\n\n/** Represents a dns resource record (rr)\n */\nstruct ResourceRecord\n{\n\tQueryType\ttype;\t\t/* Record type */\n\tunsigned int\trr_class;\t/* Record class */\n\tunsigned long\tttl;\t\t/* Time to live */\n\tunsigned int\trdlength;\t/* Record length */\n};\n\n/** Represents a dns request/reply header, and its payload as opaque data.\n */\nclass DNSHeader\n{\n public:\n\tunsigned char\tid[2];\t\t/* Request id */\n\tunsigned int\tflags1;\t\t/* Flags */\n\tunsigned int\tflags2;\t\t/* Flags */\n\tunsigned int\tqdcount;\n\tunsigned int\tancount;\t/* Answer count */\n\tunsigned int\tnscount;\t/* Nameserver count */\n\tunsigned int\tarcount;\n\tunsigned char\tpayload[512];\t/* Packet payload */\n};\n\nclass DNSRequest\n{\n public:\n\tunsigned char   id[2];\t\t/* Request id */\n\tunsigned char*  res;\t\t/* Result processing buffer */\n\tunsigned int    rr_class;       /* Request class */\n\tQueryType       type;\t\t/* Request type */\n\tDNS*            dnsobj;\t\t/* DNS caller (where we get our FD from) */\n\tunsigned long\tttl;\t\t/* Time to live */\n\tstd::string     orig;\t\t/* Original requested name/ip */\n\n\tDNSRequest(DNS* dns, int id, const std::string &original);\n\t~DNSRequest();\n\tDNSInfo ResultIsReady(DNSHeader &h, int length);\n\tint SendRequests(const DNSHeader *header, const int length, QueryType qt);\n};\n\nclass CacheTimer : public Timer\n{\n private:\n\tDNS* dns;\n public:\n\tCacheTimer(DNS* thisdns)\n\t\t: Timer(3600, ServerInstance->Time(), true), dns(thisdns) { }\n\n\tvirtual void Tick(time_t)\n\t{\n\t\tdns->PruneCache();\n\t}\n};\n\nclass RequestTimeout : public Timer\n{\n\tDNSRequest* watch;\n\tint watchid;\n public:\n\tRequestTimeout(unsigned long n, DNSRequest* watching, int id) : Timer(n, ServerInstance->Time()), watch(watching), watchid(id)\n\t{\n\t}\n\t~RequestTimeout()\n\t{\n\t\tif (ServerInstance->Res)\n\t\t\tTick(0);\n\t}\n\n\tvoid Tick(time_t)\n\t{\n\t\tif (ServerInstance->Res->requests[watchid] == watch)\n\t\t{\n\t\t\t/* Still exists, whack it */\n\t\t\tif (ServerInstance->Res->Classes[watchid])\n\t\t\t{\n\t\t\t\tServerInstance->Res->Classes[watchid]->OnError(RESOLVER_TIMEOUT, \"Request timed out\");\n\t\t\t\tdelete ServerInstance->Res->Classes[watchid];\n\t\t\t\tServerInstance->Res->Classes[watchid] = NULL;\n\t\t\t}\n\t\t\tServerInstance->Res->requests[watchid] = NULL;\n\t\t\tdelete watch;\n\t\t}\n\t}\n};\n\nCachedQuery::CachedQuery(const std::string &res, unsigned int ttl) : data(res)\n{\n\texpires = ServerInstance->Time() + ttl;\n}\n\nint CachedQuery::CalcTTLRemaining()\n{\n\tint n = expires - ServerInstance->Time();\n\treturn (n < 0 ? 0 : n);\n}\n\n/* Allocate the processing buffer */\nDNSRequest::DNSRequest(DNS* dns, int rid, const std::string &original) : dnsobj(dns)\n{\n\tres = new unsigned char[512];\n\t*res = 0;\n\torig = original;\n\tRequestTimeout* RT = new RequestTimeout(ServerInstance->Config->dns_timeout ? ServerInstance->Config->dns_timeout : 5, this, rid);\n\tServerInstance->Timers->AddTimer(RT); /* The timer manager frees this */\n}\n\n/* Deallocate the processing buffer */\nDNSRequest::~DNSRequest()\n{\n\tdelete[] res;\n}\n\n/** Fill a ResourceRecord class based on raw data input */\ninline void DNS::FillResourceRecord(ResourceRecord* rr, const unsigned char *input)\n{\n\trr->type = (QueryType)((input[0] << 8) + input[1]);\n\trr->rr_class = (input[2] << 8) + input[3];\n\trr->ttl = (input[4] << 24) + (input[5] << 16) + (input[6] << 8) + input[7];\n\trr->rdlength = (input[8] << 8) + input[9];\n}\n\n/** Fill a DNSHeader class based on raw data input of a given length */\ninline void DNS::FillHeader(DNSHeader *header, const unsigned char *input, const int length)\n{\n\theader->id[0] = input[0];\n\theader->id[1] = input[1];\n\theader->flags1 = input[2];\n\theader->flags2 = input[3];\n\theader->qdcount = (input[4] << 8) + input[5];\n\theader->ancount = (input[6] << 8) + input[7];\n\theader->nscount = (input[8] << 8) + input[9];\n\theader->arcount = (input[10] << 8) + input[11];\n\tmemcpy(header->payload,&input[12],length);\n}\n\n/** Empty a DNSHeader class out into raw data, ready for transmission */\ninline void DNS::EmptyHeader(unsigned char *output, const DNSHeader *header, const int length)\n{\n\toutput[0] = header->id[0];\n\toutput[1] = header->id[1];\n\toutput[2] = header->flags1;\n\toutput[3] = header->flags2;\n\toutput[4] = header->qdcount >> 8;\n\toutput[5] = header->qdcount & 0xFF;\n\toutput[6] = header->ancount >> 8;\n\toutput[7] = header->ancount & 0xFF;\n\toutput[8] = header->nscount >> 8;\n\toutput[9] = header->nscount & 0xFF;\n\toutput[10] = header->arcount >> 8;\n\toutput[11] = header->arcount & 0xFF;\n\tmemcpy(&output[12],header->payload,length);\n}\n\n/** Send requests we have previously built down the UDP socket */\nint DNSRequest::SendRequests(const DNSHeader *header, const int length, QueryType qt)\n{\n\tServerInstance->Logs->Log(\"RESOLVER\", DEBUG,\"DNSRequest::SendRequests\");\n\n\tunsigned char payload[sizeof(DNSHeader)];\n\n\tthis->rr_class = 1;\n\tthis->type = qt;\n\n\tDNS::EmptyHeader(payload,header,length);\n\n\tif (ServerInstance->SE->SendTo(dnsobj, payload, length + 12, 0, &(dnsobj->myserver.sa), sa_size(dnsobj->myserver)) != length+12)\n\t\treturn -1;\n\n\tServerInstance->Logs->Log(\"RESOLVER\",DEBUG,\"Sent OK\");\n\treturn 0;\n}\n\n/** Add a query with a predefined header, and allocate an ID for it. */\nDNSRequest* DNS::AddQuery(DNSHeader *header, int &id, const char* original)\n{\n\t/* Is the DNS connection down? */\n\tif (this->GetFd() == -1)\n\t\treturn NULL;\n\n\t/* Create an id */\n\tdo {\n\t\tid = ServerInstance->GenRandomInt(DNS::MAX_REQUEST_ID);\n\t} while (requests[id]);\n\n\tDNSRequest* req = new DNSRequest(this, id, original);\n\n\theader->id[0] = req->id[0] = id >> 8;\n\theader->id[1] = req->id[1] = id & 0xFF;\n\theader->flags1 = FLAGS_MASK_RD;\n\theader->flags2 = 0;\n\theader->qdcount = 1;\n\theader->ancount = 0;\n\theader->nscount = 0;\n\theader->arcount = 0;\n\n\t/* At this point we already know the id doesnt exist,\n\t * so there needs to be no second check for the ::end()\n\t */\n\trequests[id] = req;\n\n\t/* According to the C++ spec, new never returns NULL. */\n\treturn req;\n}\n\nint DNS::ClearCache()\n{\n\t/* This ensures the buckets are reset to sane levels */\n\tint rv = this->cache->size();\n\tdelete this->cache;\n\tthis->cache = new dnscache();\n\treturn rv;\n}\n\nint DNS::PruneCache()\n{\n\tint n = 0;\n\tdnscache* newcache = new dnscache();\n\tfor (dnscache::iterator i = this->cache->begin(); i != this->cache->end(); i++)\n\t\t/* Dont include expired items (theres no point) */\n\t\tif (i->second.CalcTTLRemaining())\n\t\t\tnewcache->insert(*i);\n\t\telse\n\t\t\tn++;\n\n\tdelete this->cache;\n\tthis->cache = newcache;\n\treturn n;\n}\n\nvoid DNS::Rehash()\n{\n\tif (this->GetFd() > -1)\n\t{\n\t\tServerInstance->SE->DelFd(this);\n\t\tServerInstance->SE->Shutdown(this, 2);\n\t\tServerInstance->SE->Close(this);\n\t\tthis->SetFd(-1);\n\n\t\t/* Rehash the cache */\n\t\tthis->PruneCache();\n\t}\n\telse\n\t{\n\t\t/* Create initial dns cache */\n\t\tthis->cache = new dnscache();\n\t}\n\n\tirc::sockets::aptosa(ServerInstance->Config->DNSServer, DNS::QUERY_PORT, myserver);\n\n\t/* Initialize mastersocket */\n\tint s = socket(myserver.sa.sa_family, SOCK_DGRAM, 0);\n\tthis->SetFd(s);\n\n\t/* Have we got a socket and is it nonblocking? */\n\tif (this->GetFd() != -1)\n\t{\n\t\tServerInstance->SE->SetReuse(s);\n\t\tServerInstance->SE->NonBlocking(s);\n\t\tirc::sockets::sockaddrs bindto;\n\t\tmemset(&bindto, 0, sizeof(bindto));\n\t\tbindto.sa.sa_family = myserver.sa.sa_family;\n\t\tif (ServerInstance->SE->Bind(this->GetFd(), bindto) < 0)\n\t\t{\n\t\t\t/* Failed to bind */\n\t\t\tServerInstance->Logs->Log(\"RESOLVER\",SPARSE,\"Error binding dns socket - hostnames will NOT resolve\");\n\t\t\tServerInstance->SE->Shutdown(this, 2);\n\t\t\tServerInstance->SE->Close(this);\n\t\t\tthis->SetFd(-1);\n\t\t}\n\t\telse if (!ServerInstance->SE->AddFd(this, FD_WANT_POLL_READ | FD_WANT_NO_WRITE))\n\t\t{\n\t\t\tServerInstance->Logs->Log(\"RESOLVER\",SPARSE,\"Internal error starting DNS - hostnames will NOT resolve.\");\n\t\t\tServerInstance->SE->Shutdown(this, 2);\n\t\t\tServerInstance->SE->Close(this);\n\t\t\tthis->SetFd(-1);\n\t\t}\n\t}\n\telse\n\t{\n\t\tServerInstance->Logs->Log(\"RESOLVER\",SPARSE,\"Error creating DNS socket - hostnames will NOT resolve\");\n\t}\n}\n\n/** Initialise the DNS UDP socket so that we can send requests */\nDNS::DNS()\n{\n\tServerInstance->Logs->Log(\"RESOLVER\",DEBUG,\"DNS::DNS\");\n\t/* Clear the Resolver class table */\n\tmemset(Classes,0,sizeof(Classes));\n\n\t/* Clear the requests class table */\n\tmemset(requests,0,sizeof(requests));\n\n\t/* Set the id of the next request to 0\n\t */\n\tcurrid = 0;\n\n\t/* DNS::Rehash() sets this to a valid ptr\n\t */\n\tthis->cache = NULL;\n\n\t/* Again, DNS::Rehash() sets this to a\n\t * valid value\n\t */\n\tthis->SetFd(-1);\n\n\t/* Actually read the settings\n\t */\n\tthis->Rehash();\n\n\tthis->PruneTimer = new CacheTimer(this);\n\n\tServerInstance->Timers->AddTimer(this->PruneTimer);\n}\n\n/** Build a payload to be placed after the header, based upon input data, a resource type, a class and a pointer to a buffer */\nint DNS::MakePayload(const char * const name, const QueryType rr, const unsigned short rr_class, unsigned char * const payload)\n{\n\tshort payloadpos = 0;\n\tconst char* tempchr, *tempchr2 = name;\n\tunsigned short length;\n\n\t/* split name up into labels, create query */\n\twhile ((tempchr = strchr(tempchr2,'.')) != NULL)\n\t{\n\t\tlength = tempchr - tempchr2;\n\t\tif (payloadpos + length + 1 > 507)\n\t\t\treturn -1;\n\t\tpayload[payloadpos++] = length;\n\t\tmemcpy(&payload[payloadpos],tempchr2,length);\n\t\tpayloadpos += length;\n\t\ttempchr2 = &tempchr[1];\n\t}\n\tlength = strlen(tempchr2);\n\tif (length)\n\t{\n\t\tif (payloadpos + length + 2 > 507)\n\t\t\treturn -1;\n\t\tpayload[payloadpos++] = length;\n\t\tmemcpy(&payload[payloadpos],tempchr2,length);\n\t\tpayloadpos += length;\n\t\tpayload[payloadpos++] = 0;\n\t}\n\tif (payloadpos > 508)\n\t\treturn -1;\n\tlength = htons(rr);\n\tmemcpy(&payload[payloadpos],&length,2);\n\tlength = htons(rr_class);\n\tmemcpy(&payload[payloadpos + 2],&length,2);\n\treturn payloadpos + 4;\n}\n\n/** Start lookup of an hostname to an IP address */\nint DNS::GetIP(const char *name)\n{\n\tDNSHeader h;\n\tint id;\n\tint length;\n\n\tif ((length = this->MakePayload(name, DNS_QUERY_A, 1, (unsigned char*)&h.payload)) == -1)\n\t\treturn -1;\n\n\tDNSRequest* req = this->AddQuery(&h, id, name);\n\n\tif ((!req) || (req->SendRequests(&h, length, DNS_QUERY_A) == -1))\n\t\treturn -1;\n\n\treturn id;\n}\n\n/** Start lookup of an hostname to an IPv6 address */\nint DNS::GetIP6(const char *name)\n{\n\tDNSHeader h;\n\tint id;\n\tint length;\n\n\tif ((length = this->MakePayload(name, DNS_QUERY_AAAA, 1, (unsigned char*)&h.payload)) == -1)\n\t\treturn -1;\n\n\tDNSRequest* req = this->AddQuery(&h, id, name);\n\n\tif ((!req) || (req->SendRequests(&h, length, DNS_QUERY_AAAA) == -1))\n\t\treturn -1;\n\n\treturn id;\n}\n\n/** Start lookup of a cname to another name */\nint DNS::GetCName(const char *alias)\n{\n\tDNSHeader h;\n\tint id;\n\tint length;\n\n\tif ((length = this->MakePayload(alias, DNS_QUERY_CNAME, 1, (unsigned char*)&h.payload)) == -1)\n\t\treturn -1;\n\n\tDNSRequest* req = this->AddQuery(&h, id, alias);\n\n\tif ((!req) || (req->SendRequests(&h, length, DNS_QUERY_CNAME) == -1))\n\t\treturn -1;\n\n\treturn id;\n}\n\n/** Start lookup of an IP address to a hostname */\nint DNS::GetNameForce(const char *ip, ForceProtocol fp)\n{\n\tchar query[128];\n\tDNSHeader h;\n\tint id;\n\tint length;\n\n\tif (fp == PROTOCOL_IPV6)\n\t{\n\t\tin6_addr i;\n\t\tif (inet_pton(AF_INET6, ip, &i) > 0)\n\t\t{\n\t\t\tDNS::MakeIP6Int(query, &i);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tServerInstance->Logs->Log(\"RESOLVER\",DEBUG,\"DNS::GetNameForce IPv6 bad format for '%s'\", ip);\n\t\t\t/* Invalid IP address */\n\t\t\treturn -1;\n\t\t}\n\t}\n\telse\n\t{\n\t\tin_addr i;\n\t\tif (inet_aton(ip, &i))\n\t\t{\n\t\t\tunsigned char* c = (unsigned char*)&i.s_addr;\n\t\t\tsprintf(query,\"%d.%d.%d.%d.in-addr.arpa\",c[3],c[2],c[1],c[0]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tServerInstance->Logs->Log(\"RESOLVER\",DEBUG,\"DNS::GetNameForce IPv4 bad format for '%s'\", ip);\n\t\t\t/* Invalid IP address */\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tlength = this->MakePayload(query, DNS_QUERY_PTR, 1, (unsigned char*)&h.payload);\n\tif (length == -1)\n\t{\n\t\tServerInstance->Logs->Log(\"RESOLVER\",DEBUG,\"DNS::GetNameForce can't query '%s' using '%s' because it's too long\", ip, query);\n\t\treturn -1;\n\t}\n\n\tDNSRequest* req = this->AddQuery(&h, id, ip);\n\n\tif (!req)\n\t{\n\t\tServerInstance->Logs->Log(\"RESOLVER\",DEBUG,\"DNS::GetNameForce can't add query (resolver down?)\");\n\t\treturn -1;\n\t}\n\n\tif (req->SendRequests(&h, length, DNS_QUERY_PTR) == -1)\n\t{\n\t\tServerInstance->Logs->Log(\"RESOLVER\",DEBUG,\"DNS::GetNameForce can't send (firewall?)\");\n\t\treturn -1;\n\t}\n\n\treturn id;\n}\n\n/** Build an ipv6 reverse domain from an in6_addr\n */\nvoid DNS::MakeIP6Int(char* query, const in6_addr *ip)\n{\n\tconst char* hex = \"0123456789abcdef\";\n\tfor (int index = 31; index >= 0; index--) /* for() loop steps twice per byte */\n\t{\n\t\tif (index % 2)\n\t\t\t/* low nibble */\n\t\t\t*query++ = hex[ip->s6_addr[index / 2] & 0x0F];\n\t\telse\n\t\t\t/* high nibble */\n\t\t\t*query++ = hex[(ip->s6_addr[index / 2] & 0xF0) >> 4];\n\t\t*query++ = '.'; /* Seperator */\n\t}\n\tstrcpy(query,\"ip6.arpa\"); /* Suffix the string */\n}\n\n/** Return the next id which is ready, and the result attached to it */\nDNSResult DNS::GetResult()\n{\n\t/* Fetch dns query response and decide where it belongs */\n\tDNSHeader header;\n\tDNSRequest *req;\n\tunsigned char buffer[sizeof(DNSHeader)];\n\tirc::sockets::sockaddrs from;\n\tmemset(&from, 0, sizeof(from));\n\tsocklen_t x = sizeof(from);\n\n\tint length = ServerInstance->SE->RecvFrom(this, (char*)buffer, sizeof(DNSHeader), 0, &from.sa, &x);\n\n\t/* Did we get the whole header? */\n\tif (length < 12)\n\t{\n\t\tServerInstance->Logs->Log(\"RESOLVER\",DEBUG,\"GetResult didn't get a full packet (len=%d)\", length);\n\t\t/* Nope - something screwed up. */\n\t\treturn DNSResult(-1,\"\",0,\"\");\n\t}\n\n\t/* Check wether the reply came from a different DNS\n\t * server to the one we sent it to, or the source-port\n\t * is not 53.\n\t * A user could in theory still spoof dns packets anyway\n\t * but this is less trivial than just sending garbage\n\t * to the server, which is possible without this check.\n\t *\n\t * -- Thanks jilles for pointing this one out.\n\t */\n\tif (from != myserver)\n\t{\n\t\tServerInstance->Logs->Log(\"RESOLVER\",DEBUG,\"Got a result from the wrong server! Bad NAT or DNS forging attempt? '%s' != '%s'\",\n\t\t\tfrom.str().c_str(), myserver.str().c_str());\n\t\treturn DNSResult(-1,\"\",0,\"\");\n\t}\n\n\t/* Put the read header info into a header class */\n\tDNS::FillHeader(&header,buffer,length - 12);\n\n\t/* Get the id of this request.\n\t * Its a 16 bit value stored in two char's,\n\t * so we use logic shifts to create the value.\n\t */\n\tunsigned long this_id = header.id[1] + (header.id[0] << 8);\n\n\t/* Do we have a pending request matching this id? */\n\tif (!requests[this_id])\n\t{\n\t\t/* Somehow we got a DNS response for a request we never made... */\n\t\tServerInstance->Logs->Log(\"RESOLVER\",DEBUG,\"Hmm, got a result that we didn't ask for (id=%lx). Ignoring.\", this_id);\n\t\treturn DNSResult(-1,\"\",0,\"\");\n\t}\n\telse\n\t{\n\t\t/* Remove the query from the list of pending queries */\n\t\treq = requests[this_id];\n\t\trequests[this_id] = NULL;\n\t}\n\n\t/* Inform the DNSRequest class that it has a result to be read.\n\t * When its finished it will return a DNSInfo which is a pair of\n\t * unsigned char* resource record data, and an error message.\n\t */\n\tDNSInfo data = req->ResultIsReady(header, length);\n\tstd::string resultstr;\n\n\t/* Check if we got a result, if we didnt, its an error */\n\tif (data.first == NULL)\n\t{\n\t\t/* An error.\n\t\t * Mask the ID with the value of ERROR_MASK, so that\n\t\t * the dns_deal_with_classes() function knows that its\n\t\t * an error response and needs to be treated uniquely.\n\t\t * Put the error message in the second field.\n\t\t */\n\t\tstd::string ro = req->orig;\n\t\tdelete req;\n\t\treturn DNSResult(this_id | ERROR_MASK, data.second, 0, ro);\n\t}\n\telse\n\t{\n\t\tunsigned long ttl = req->ttl;\n\t\tchar formatted[128];\n\n\t\t/* Forward lookups come back as binary data. We must format them into ascii */\n\t\tswitch (req->type)\n\t\t{\n\t\t\tcase DNS_QUERY_A:\n\t\t\t\tsnprintf(formatted,16,\"%u.%u.%u.%u\",data.first[0],data.first[1],data.first[2],data.first[3]);\n\t\t\t\tresultstr = formatted;\n\t\t\tbreak;\n\n\t\t\tcase DNS_QUERY_AAAA:\n\t\t\t{\n\t\t\t\tinet_ntop(AF_INET6, data.first, formatted, sizeof(formatted));\n\t\t\t\tchar* c = strstr(formatted,\":0:\");\n\t\t\t\tif (c != NULL)\n\t\t\t\t{\n\t\t\t\t\tmemmove(c+1,c+2,strlen(c+2) + 1);\n\t\t\t\t\tc += 2;\n\t\t\t\t\twhile (memcmp(c,\"0:\",2) == 0)\n\t\t\t\t\t\tmemmove(c,c+2,strlen(c+2) + 1);\n\t\t\t\t\tif (memcmp(c,\"0\",2) == 0)\n\t\t\t\t\t\t*c = 0;\n\t\t\t\t\tif (memcmp(formatted,\"0::\",3) == 0)\n\t\t\t\t\t\tmemmove(formatted,formatted + 1, strlen(formatted + 1) + 1);\n\t\t\t\t}\n\t\t\t\tresultstr = formatted;\n\n\t\t\t\t/* Special case. Sending ::1 around between servers\n\t\t\t\t * and to clients is dangerous, because the : on the\n\t\t\t\t * start makes the client or server interpret the IP\n\t\t\t\t * as the last parameter on the line with a value \":1\".\n\t\t\t\t */\n\t\t\t\tif (*formatted == ':')\n\t\t\t\t\tresultstr.insert(0, \"0\");\n\t\t\t}\n\t\t\tbreak;\n\n\t\t\tcase DNS_QUERY_CNAME:\n\t\t\t\t/* Identical handling to PTR */\n\n\t\t\tcase DNS_QUERY_PTR:\n\t\t\t\t/* Reverse lookups just come back as char* */\n\t\t\t\tresultstr = std::string((const char*)data.first);\n\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Build the reply with the id and hostname/ip in it */\n\t\tstd::string ro = req->orig;\n\t\tdelete req;\n\t\treturn DNSResult(this_id,resultstr,ttl,ro);\n\t}\n}\n\n/** A result is ready, process it */\nDNSInfo DNSRequest::ResultIsReady(DNSHeader &header, int length)\n{\n\tint i = 0;\n\tint q = 0;\n\tint curanswer, o;\n\tResourceRecord rr;\n \tunsigned short ptr;\n\n\t/* This is just to keep _FORTIFY_SOURCE happy */\n\trr.type = DNS_QUERY_NONE;\n\trr.rdlength = 0;\n\trr.ttl = 1;\t/* GCC is a whiney bastard -- see the XXX below. */\n\trr.rr_class = 0; /* Same for VC++ */\n\n\tif (!(header.flags1 & FLAGS_MASK_QR))\n\t\treturn std::make_pair((unsigned char*)NULL,\"Not a query result\");\n\n\tif (header.flags1 & FLAGS_MASK_OPCODE)\n\t\treturn std::make_pair((unsigned char*)NULL,\"Unexpected value in DNS reply packet\");\n\n\tif (header.flags2 & FLAGS_MASK_RCODE)\n\t\treturn std::make_pair((unsigned char*)NULL,\"Domain name not found\");\n\n\tif (header.ancount < 1)\n\t\treturn std::make_pair((unsigned char*)NULL,\"No resource records returned\");\n\n\t/* Subtract the length of the header from the length of the packet */\n\tlength -= 12;\n\n\twhile ((unsigned int)q < header.qdcount && i < length)\n\t{\n\t\tif (header.payload[i] > 63)\n\t\t{\n\t\t\ti += 6;\n\t\t\tq++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (header.payload[i] == 0)\n\t\t\t{\n\t\t\t\tq++;\n\t\t\t\ti += 5;\n\t\t\t}\n\t\t\telse i += header.payload[i] + 1;\n\t\t}\n\t}\n\tcuranswer = 0;\n\twhile ((unsigned)curanswer < header.ancount)\n\t{\n\t\tq = 0;\n\t\twhile (q == 0 && i < length)\n\t\t{\n\t\t\tif (header.payload[i] > 63)\n\t\t\t{\n\t\t\t\ti += 2;\n\t\t\t\tq = 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (header.payload[i] == 0)\n\t\t\t\t{\n\t\t\t\t\ti++;\n\t\t\t\t\tq = 1;\n\t\t\t\t}\n\t\t\t\telse i += header.payload[i] + 1; /* skip length and label */\n\t\t\t}\n\t\t}\n\t\tif (length - i < 10)\n\t\t\treturn std::make_pair((unsigned char*)NULL,\"Incorrectly sized DNS reply\");\n\n\t\t/* XXX: We actually initialise 'rr' here including its ttl field */\n\t\tDNS::FillResourceRecord(&rr,&header.payload[i]);\n\n\t\ti += 10;\n\t\tServerInstance->Logs->Log(\"RESOLVER\",DEBUG,\"Resolver: rr.type is %d and this.type is %d rr.class %d this.class %d\", rr.type, this->type, rr.rr_class, this->rr_class);\n\t\tif (rr.type != this->type)\n\t\t{\n\t\t\tcuranswer++;\n\t\t\ti += rr.rdlength;\n\t\t\tcontinue;\n\t\t}\n\t\tif (rr.rr_class != this->rr_class)\n\t\t{\n\t\t\tcuranswer++;\n\t\t\ti += rr.rdlength;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\tif ((unsigned int)curanswer == header.ancount)\n\t\treturn std::make_pair((unsigned char*)NULL,\"No A, AAAA or PTR type answers (\" + ConvToStr(header.ancount) + \" answers)\");\n\n\tif (i + rr.rdlength > (unsigned int)length)\n\t\treturn std::make_pair((unsigned char*)NULL,\"Resource record larger than stated\");\n\n\tif (rr.rdlength > 1023)\n\t\treturn std::make_pair((unsigned char*)NULL,\"Resource record too large\");\n\n\tthis->ttl = rr.ttl;\n\n\tswitch (rr.type)\n\t{\n\t\tcase DNS_QUERY_CNAME:\n\t\t\t/* CNAME and PTR have the same processing code */\n\t\tcase DNS_QUERY_PTR:\n\t\t\to = 0;\n\t\t\tq = 0;\n\t\t\twhile (q == 0 && i < length && o + 256 < 1023)\n\t\t\t{\n\t\t\t\tif (header.payload[i] > 63)\n\t\t\t\t{\n\t\t\t\t\tmemcpy(&ptr,&header.payload[i],2);\n\t\t\t\t\ti = ntohs(ptr) - 0xC000 - 12;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (header.payload[i] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tq = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tres[o] = 0;\n\t\t\t\t\t\tif (o != 0)\n\t\t\t\t\t\t\tres[o++] = '.';\n\t\t\t\t\t\tmemcpy(&res[o],&header.payload[i + 1],header.payload[i]);\n\t\t\t\t\t\to += header.payload[i];\n\t\t\t\t\t\ti += header.payload[i] + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres[o] = 0;\n\t\tbreak;\n\t\tcase DNS_QUERY_AAAA:\n\t\t\tmemcpy(res,&header.payload[i],rr.rdlength);\n\t\t\tres[rr.rdlength] = 0;\n\t\tbreak;\n\t\tcase DNS_QUERY_A:\n\t\t\tmemcpy(res,&header.payload[i],rr.rdlength);\n\t\t\tres[rr.rdlength] = 0;\n\t\tbreak;\n\t\tdefault:\n\t\t\tmemcpy(res,&header.payload[i],rr.rdlength);\n\t\t\tres[rr.rdlength] = 0;\n\t\tbreak;\n\t}\n\treturn std::make_pair(res,\"No error\");\n}\n\n/** Close the master socket */\nDNS::~DNS()\n{\n\tServerInstance->SE->Shutdown(this, 2);\n\tServerInstance->SE->Close(this);\n\tServerInstance->Timers->DelTimer(this->PruneTimer);\n\tif (cache)\n\t\tdelete cache;\n}\n\nCachedQuery* DNS::GetCache(const std::string &source)\n{\n\tdnscache::iterator x = cache->find(source.c_str());\n\tif (x != cache->end())\n\t\treturn &(x->second);\n\telse\n\t\treturn NULL;\n}\n\nvoid DNS::DelCache(const std::string &source)\n{\n\tcache->erase(source.c_str());\n}\n\nvoid Resolver::TriggerCachedResult()\n{\n\tif (CQ)\n\t\tOnLookupComplete(CQ->data, time_left, true);\n}\n\n/** High level abstraction of dns used by application at large */\nResolver::Resolver(const std::string &source, QueryType qt, bool &cached, Module* creator) : Creator(creator), input(source), querytype(qt)\n{\n\tServerInstance->Logs->Log(\"RESOLVER\",DEBUG,\"Resolver::Resolver\");\n\tcached = false;\n\n\tCQ = ServerInstance->Res->GetCache(source);\n\tif (CQ)\n\t{\n\t\ttime_left = CQ->CalcTTLRemaining();\n\t\tif (!time_left)\n\t\t{\n\t\t\tServerInstance->Res->DelCache(source);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcached = true;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tswitch (querytype)\n\t{\n\t\tcase DNS_QUERY_A:\n\t\t\tthis->myid = ServerInstance->Res->GetIP(source.c_str());\n\t\tbreak;\n\n\t\tcase DNS_QUERY_PTR4:\n\t\t\tquerytype = DNS_QUERY_PTR;\n\t\t\tthis->myid = ServerInstance->Res->GetNameForce(source.c_str(), PROTOCOL_IPV4);\n\t\tbreak;\n\n\t\tcase DNS_QUERY_PTR6:\n\t\t\tquerytype = DNS_QUERY_PTR;\n\t\t\tthis->myid = ServerInstance->Res->GetNameForce(source.c_str(), PROTOCOL_IPV6);\n\t\tbreak;\n\n\t\tcase DNS_QUERY_AAAA:\n\t\t\tthis->myid = ServerInstance->Res->GetIP6(source.c_str());\n\t\tbreak;\n\n\t\tcase DNS_QUERY_CNAME:\n\t\t\tthis->myid = ServerInstance->Res->GetCName(source.c_str());\n\t\tbreak;\n\n\t\tdefault:\n\t\t\tServerInstance->Logs->Log(\"RESOLVER\",DEBUG,\"DNS request with unknown query type %d\", querytype);\n\t\t\tthis->myid = -1;\n\t\tbreak;\n\t}\n\tif (this->myid == -1)\n\t{\n\t\tthrow ModuleException(\"Resolver: Couldn't get an id to make a request\");\n\t}\n\telse\n\t{\n\t\tServerInstance->Logs->Log(\"RESOLVER\",DEBUG,\"DNS request id %d\", this->myid);\n\t}\n}\n\n/** Called when an error occurs */\nvoid Resolver::OnError(ResolverError, const std::string&)\n{\n\t/* Nothing in here */\n}\n\n/** Destroy a resolver */\nResolver::~Resolver()\n{\n\t/* Nothing here (yet) either */\n}\n\n/** Get the request id associated with this class */\nint Resolver::GetId()\n{\n\treturn this->myid;\n}\n\nModule* Resolver::GetCreator()\n{\n\treturn this->Creator;\n}\n\n/** Process a socket read event */\nvoid DNS::HandleEvent(EventType, int)\n{\n\t/* Fetch the id and result of the next available packet */\n\tDNSResult res(0,\"\",0,\"\");\n\tres.id = 0;\n\tServerInstance->Logs->Log(\"RESOLVER\",DEBUG,\"Handle DNS event\");\n\n\tres = this->GetResult();\n\n\tServerInstance->Logs->Log(\"RESOLVER\",DEBUG,\"Result id %d\", res.id);\n\n\t/* Is there a usable request id? */\n\tif (res.id != -1)\n\t{\n\t\t/* Its an error reply */\n\t\tif (res.id & ERROR_MASK)\n\t\t{\n\t\t\t/* Mask off the error bit */\n\t\t\tres.id -= ERROR_MASK;\n\t\t\t/* Marshall the error to the correct class */\n\t\t\tif (Classes[res.id])\n\t\t\t{\n\t\t\t\tif (ServerInstance && ServerInstance->stats)\n\t\t\t\t\tServerInstance->stats->statsDnsBad++;\n\t\t\t\tClasses[res.id]->OnError(RESOLVER_NXDOMAIN, res.result);\n\t\t\t\tdelete Classes[res.id];\n\t\t\t\tClasses[res.id] = NULL;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* It is a non-error result, marshall the result to the correct class */\n\t\t\tif (Classes[res.id])\n\t\t\t{\n\t\t\t\tif (ServerInstance && ServerInstance->stats)\n\t\t\t\t\tServerInstance->stats->statsDnsGood++;\n\n\t\t\t\tif (!this->GetCache(res.original.c_str()))\n\t\t\t\t\tthis->cache->insert(std::make_pair(res.original.c_str(), CachedQuery(res.result, res.ttl)));\n\n\t\t\t\tClasses[res.id]->OnLookupComplete(res.result, res.ttl, false);\n\t\t\t\tdelete Classes[res.id];\n\t\t\t\tClasses[res.id] = NULL;\n\t\t\t}\n\t\t}\n\n\t\tif (ServerInstance && ServerInstance->stats)\n\t\t\tServerInstance->stats->statsDns++;\n\t}\n}\n\n/** Add a derived Resolver to the working set */\nbool DNS::AddResolverClass(Resolver* r)\n{\n\tServerInstance->Logs->Log(\"RESOLVER\",DEBUG,\"AddResolverClass 0x%08lx\", (unsigned long)r);\n\t/* Check the pointers validity and the id's validity */\n\tif ((r) && (r->GetId() > -1))\n\t{\n\t\t/* Check the slot isnt already occupied -\n\t\t * This should NEVER happen unless we have\n\t\t * a severely broken DNS server somewhere\n\t\t */\n\t\tif (!Classes[r->GetId()])\n\t\t{\n\t\t\t/* Set up the pointer to the class */\n\t\t\tClasses[r->GetId()] = r;\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t\t/* Duplicate id */\n\t\t\treturn false;\n\t}\n\telse\n\t{\n\t\t/* Pointer or id not valid.\n\t\t * Free the item and return\n\t\t */\n\t\tif (r)\n\t\t\tdelete r;\n\n\t\treturn false;\n\t}\n}\n\nvoid DNS::CleanResolvers(Module* module)\n{\n\tfor (int i = 0; i < MAX_REQUEST_ID; i++)\n\t{\n\t\tif (Classes[i])\n\t\t{\n\t\t\tif (Classes[i]->GetCreator() == module)\n\t\t\t{\n\t\t\t\tClasses[i]->OnError(RESOLVER_FORCEUNLOAD, \"Parent module is unloading\");\n\t\t\t\tdelete Classes[i];\n\t\t\t\tClasses[i] = NULL;\n\t\t\t}\n\t\t}\n\t}\n}\n"], "fixing_code": ["/*       +------------------------------------+\n *       | Inspire Internet Relay Chat Daemon |\n *       +------------------------------------+\n *\n *  InspIRCd: (C) 2002-2010 InspIRCd Development Team\n * See: http://wiki.inspircd.org/Credits\n *\n * This program is free but copyrighted software; see\n *            the file COPYING for details.\n *\n * ---------------------------------------------------\n */\n\n/* $Core */\n\n/*\ndns.cpp - Nonblocking DNS functions.\nVery very loosely based on the firedns library,\nCopyright (C) 2002 Ian Gulliver. This file is no\nlonger anything like firedns, there are many major\ndifferences between this code and the original.\nPlease do not assume that firedns works like this,\nlooks like this, walks like this or tastes like this.\n*/\n\n#ifndef WIN32\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#else\n#include \"inspircd_win32wrapper.h\"\n#endif\n\n#include \"inspircd.h\"\n#include \"socketengine.h\"\n#include \"configreader.h\"\n#include \"socket.h\"\n\n#define DN_COMP_BITMASK\t0xC000\t\t/* highest 6 bits in a DN label header */\n\n/** Masks to mask off the responses we get from the DNSRequest methods\n */\nenum QueryInfo\n{\n\tERROR_MASK\t= 0x10000\t/* Result is an error */\n};\n\n/** Flags which can be ORed into a request or reply for different meanings\n */\nenum QueryFlags\n{\n\tFLAGS_MASK_RD\t\t= 0x01,\t/* Recursive */\n\tFLAGS_MASK_TC\t\t= 0x02,\n\tFLAGS_MASK_AA\t\t= 0x04,\t/* Authoritative */\n\tFLAGS_MASK_OPCODE\t= 0x78,\n\tFLAGS_MASK_QR\t\t= 0x80,\n\tFLAGS_MASK_RCODE\t= 0x0F,\t/* Request */\n\tFLAGS_MASK_Z\t\t= 0x70,\n\tFLAGS_MASK_RA \t\t= 0x80\n};\n\n\n/** Represents a dns resource record (rr)\n */\nstruct ResourceRecord\n{\n\tQueryType\ttype;\t\t/* Record type */\n\tunsigned int\trr_class;\t/* Record class */\n\tunsigned long\tttl;\t\t/* Time to live */\n\tunsigned int\trdlength;\t/* Record length */\n};\n\n/** Represents a dns request/reply header, and its payload as opaque data.\n */\nclass DNSHeader\n{\n public:\n\tunsigned char\tid[2];\t\t/* Request id */\n\tunsigned int\tflags1;\t\t/* Flags */\n\tunsigned int\tflags2;\t\t/* Flags */\n\tunsigned int\tqdcount;\n\tunsigned int\tancount;\t/* Answer count */\n\tunsigned int\tnscount;\t/* Nameserver count */\n\tunsigned int\tarcount;\n\tunsigned char\tpayload[512];\t/* Packet payload */\n};\n\nclass DNSRequest\n{\n public:\n\tunsigned char   id[2];\t\t/* Request id */\n\tunsigned char*  res;\t\t/* Result processing buffer */\n\tunsigned int    rr_class;       /* Request class */\n\tQueryType       type;\t\t/* Request type */\n\tDNS*            dnsobj;\t\t/* DNS caller (where we get our FD from) */\n\tunsigned long\tttl;\t\t/* Time to live */\n\tstd::string     orig;\t\t/* Original requested name/ip */\n\n\tDNSRequest(DNS* dns, int id, const std::string &original);\n\t~DNSRequest();\n\tDNSInfo ResultIsReady(DNSHeader &h, unsigned length);\n\tint SendRequests(const DNSHeader *header, const int length, QueryType qt);\n};\n\nclass CacheTimer : public Timer\n{\n private:\n\tDNS* dns;\n public:\n\tCacheTimer(DNS* thisdns)\n\t\t: Timer(3600, ServerInstance->Time(), true), dns(thisdns) { }\n\n\tvirtual void Tick(time_t)\n\t{\n\t\tdns->PruneCache();\n\t}\n};\n\nclass RequestTimeout : public Timer\n{\n\tDNSRequest* watch;\n\tint watchid;\n public:\n\tRequestTimeout(unsigned long n, DNSRequest* watching, int id) : Timer(n, ServerInstance->Time()), watch(watching), watchid(id)\n\t{\n\t}\n\t~RequestTimeout()\n\t{\n\t\tif (ServerInstance->Res)\n\t\t\tTick(0);\n\t}\n\n\tvoid Tick(time_t)\n\t{\n\t\tif (ServerInstance->Res->requests[watchid] == watch)\n\t\t{\n\t\t\t/* Still exists, whack it */\n\t\t\tif (ServerInstance->Res->Classes[watchid])\n\t\t\t{\n\t\t\t\tServerInstance->Res->Classes[watchid]->OnError(RESOLVER_TIMEOUT, \"Request timed out\");\n\t\t\t\tdelete ServerInstance->Res->Classes[watchid];\n\t\t\t\tServerInstance->Res->Classes[watchid] = NULL;\n\t\t\t}\n\t\t\tServerInstance->Res->requests[watchid] = NULL;\n\t\t\tdelete watch;\n\t\t}\n\t}\n};\n\nCachedQuery::CachedQuery(const std::string &res, unsigned int ttl) : data(res)\n{\n\texpires = ServerInstance->Time() + ttl;\n}\n\nint CachedQuery::CalcTTLRemaining()\n{\n\tint n = expires - ServerInstance->Time();\n\treturn (n < 0 ? 0 : n);\n}\n\n/* Allocate the processing buffer */\nDNSRequest::DNSRequest(DNS* dns, int rid, const std::string &original) : dnsobj(dns)\n{\n\t/* hardening against overflow here:  make our work buffer twice the theoretical\n\t * maximum size so that hostile input doesn't screw us over.\n\t */\n\tres = new unsigned char[sizeof(DNSHeader) * 2];\n\t*res = 0;\n\torig = original;\n\tRequestTimeout* RT = new RequestTimeout(ServerInstance->Config->dns_timeout ? ServerInstance->Config->dns_timeout : 5, this, rid);\n\tServerInstance->Timers->AddTimer(RT); /* The timer manager frees this */\n}\n\n/* Deallocate the processing buffer */\nDNSRequest::~DNSRequest()\n{\n\tdelete[] res;\n}\n\n/** Fill a ResourceRecord class based on raw data input */\ninline void DNS::FillResourceRecord(ResourceRecord* rr, const unsigned char *input)\n{\n\trr->type = (QueryType)((input[0] << 8) + input[1]);\n\trr->rr_class = (input[2] << 8) + input[3];\n\trr->ttl = (input[4] << 24) + (input[5] << 16) + (input[6] << 8) + input[7];\n\trr->rdlength = (input[8] << 8) + input[9];\n}\n\n/** Fill a DNSHeader class based on raw data input of a given length */\ninline void DNS::FillHeader(DNSHeader *header, const unsigned char *input, const int length)\n{\n\theader->id[0] = input[0];\n\theader->id[1] = input[1];\n\theader->flags1 = input[2];\n\theader->flags2 = input[3];\n\theader->qdcount = (input[4] << 8) + input[5];\n\theader->ancount = (input[6] << 8) + input[7];\n\theader->nscount = (input[8] << 8) + input[9];\n\theader->arcount = (input[10] << 8) + input[11];\n\tmemcpy(header->payload,&input[12],length);\n}\n\n/** Empty a DNSHeader class out into raw data, ready for transmission */\ninline void DNS::EmptyHeader(unsigned char *output, const DNSHeader *header, const int length)\n{\n\toutput[0] = header->id[0];\n\toutput[1] = header->id[1];\n\toutput[2] = header->flags1;\n\toutput[3] = header->flags2;\n\toutput[4] = header->qdcount >> 8;\n\toutput[5] = header->qdcount & 0xFF;\n\toutput[6] = header->ancount >> 8;\n\toutput[7] = header->ancount & 0xFF;\n\toutput[8] = header->nscount >> 8;\n\toutput[9] = header->nscount & 0xFF;\n\toutput[10] = header->arcount >> 8;\n\toutput[11] = header->arcount & 0xFF;\n\tmemcpy(&output[12],header->payload,length);\n}\n\n/** Send requests we have previously built down the UDP socket */\nint DNSRequest::SendRequests(const DNSHeader *header, const int length, QueryType qt)\n{\n\tServerInstance->Logs->Log(\"RESOLVER\", DEBUG,\"DNSRequest::SendRequests\");\n\n\tunsigned char payload[sizeof(DNSHeader)];\n\n\tthis->rr_class = 1;\n\tthis->type = qt;\n\n\tDNS::EmptyHeader(payload,header,length);\n\n\tif (ServerInstance->SE->SendTo(dnsobj, payload, length + 12, 0, &(dnsobj->myserver.sa), sa_size(dnsobj->myserver)) != length+12)\n\t\treturn -1;\n\n\tServerInstance->Logs->Log(\"RESOLVER\",DEBUG,\"Sent OK\");\n\treturn 0;\n}\n\n/** Add a query with a predefined header, and allocate an ID for it. */\nDNSRequest* DNS::AddQuery(DNSHeader *header, int &id, const char* original)\n{\n\t/* Is the DNS connection down? */\n\tif (this->GetFd() == -1)\n\t\treturn NULL;\n\n\t/* Create an id */\n\tdo {\n\t\tid = ServerInstance->GenRandomInt(DNS::MAX_REQUEST_ID);\n\t} while (requests[id]);\n\n\tDNSRequest* req = new DNSRequest(this, id, original);\n\n\theader->id[0] = req->id[0] = id >> 8;\n\theader->id[1] = req->id[1] = id & 0xFF;\n\theader->flags1 = FLAGS_MASK_RD;\n\theader->flags2 = 0;\n\theader->qdcount = 1;\n\theader->ancount = 0;\n\theader->nscount = 0;\n\theader->arcount = 0;\n\n\t/* At this point we already know the id doesnt exist,\n\t * so there needs to be no second check for the ::end()\n\t */\n\trequests[id] = req;\n\n\t/* According to the C++ spec, new never returns NULL. */\n\treturn req;\n}\n\nint DNS::ClearCache()\n{\n\t/* This ensures the buckets are reset to sane levels */\n\tint rv = this->cache->size();\n\tdelete this->cache;\n\tthis->cache = new dnscache();\n\treturn rv;\n}\n\nint DNS::PruneCache()\n{\n\tint n = 0;\n\tdnscache* newcache = new dnscache();\n\tfor (dnscache::iterator i = this->cache->begin(); i != this->cache->end(); i++)\n\t\t/* Dont include expired items (theres no point) */\n\t\tif (i->second.CalcTTLRemaining())\n\t\t\tnewcache->insert(*i);\n\t\telse\n\t\t\tn++;\n\n\tdelete this->cache;\n\tthis->cache = newcache;\n\treturn n;\n}\n\nvoid DNS::Rehash()\n{\n\tif (this->GetFd() > -1)\n\t{\n\t\tServerInstance->SE->DelFd(this);\n\t\tServerInstance->SE->Shutdown(this, 2);\n\t\tServerInstance->SE->Close(this);\n\t\tthis->SetFd(-1);\n\n\t\t/* Rehash the cache */\n\t\tthis->PruneCache();\n\t}\n\telse\n\t{\n\t\t/* Create initial dns cache */\n\t\tthis->cache = new dnscache();\n\t}\n\n\tirc::sockets::aptosa(ServerInstance->Config->DNSServer, DNS::QUERY_PORT, myserver);\n\n\t/* Initialize mastersocket */\n\tint s = socket(myserver.sa.sa_family, SOCK_DGRAM, 0);\n\tthis->SetFd(s);\n\n\t/* Have we got a socket and is it nonblocking? */\n\tif (this->GetFd() != -1)\n\t{\n\t\tServerInstance->SE->SetReuse(s);\n\t\tServerInstance->SE->NonBlocking(s);\n\t\tirc::sockets::sockaddrs bindto;\n\t\tmemset(&bindto, 0, sizeof(bindto));\n\t\tbindto.sa.sa_family = myserver.sa.sa_family;\n\t\tif (ServerInstance->SE->Bind(this->GetFd(), bindto) < 0)\n\t\t{\n\t\t\t/* Failed to bind */\n\t\t\tServerInstance->Logs->Log(\"RESOLVER\",SPARSE,\"Error binding dns socket - hostnames will NOT resolve\");\n\t\t\tServerInstance->SE->Shutdown(this, 2);\n\t\t\tServerInstance->SE->Close(this);\n\t\t\tthis->SetFd(-1);\n\t\t}\n\t\telse if (!ServerInstance->SE->AddFd(this, FD_WANT_POLL_READ | FD_WANT_NO_WRITE))\n\t\t{\n\t\t\tServerInstance->Logs->Log(\"RESOLVER\",SPARSE,\"Internal error starting DNS - hostnames will NOT resolve.\");\n\t\t\tServerInstance->SE->Shutdown(this, 2);\n\t\t\tServerInstance->SE->Close(this);\n\t\t\tthis->SetFd(-1);\n\t\t}\n\t}\n\telse\n\t{\n\t\tServerInstance->Logs->Log(\"RESOLVER\",SPARSE,\"Error creating DNS socket - hostnames will NOT resolve\");\n\t}\n}\n\n/** Initialise the DNS UDP socket so that we can send requests */\nDNS::DNS()\n{\n\tServerInstance->Logs->Log(\"RESOLVER\",DEBUG,\"DNS::DNS\");\n\t/* Clear the Resolver class table */\n\tmemset(Classes,0,sizeof(Classes));\n\n\t/* Clear the requests class table */\n\tmemset(requests,0,sizeof(requests));\n\n\t/* Set the id of the next request to 0\n\t */\n\tcurrid = 0;\n\n\t/* DNS::Rehash() sets this to a valid ptr\n\t */\n\tthis->cache = NULL;\n\n\t/* Again, DNS::Rehash() sets this to a\n\t * valid value\n\t */\n\tthis->SetFd(-1);\n\n\t/* Actually read the settings\n\t */\n\tthis->Rehash();\n\n\tthis->PruneTimer = new CacheTimer(this);\n\n\tServerInstance->Timers->AddTimer(this->PruneTimer);\n}\n\n/** Build a payload to be placed after the header, based upon input data, a resource type, a class and a pointer to a buffer */\nint DNS::MakePayload(const char * const name, const QueryType rr, const unsigned short rr_class, unsigned char * const payload)\n{\n\tshort payloadpos = 0;\n\tconst char* tempchr, *tempchr2 = name;\n\tunsigned short length;\n\n\t/* split name up into labels, create query */\n\twhile ((tempchr = strchr(tempchr2,'.')) != NULL)\n\t{\n\t\tlength = tempchr - tempchr2;\n\t\tif (payloadpos + length + 1 > 507)\n\t\t\treturn -1;\n\t\tpayload[payloadpos++] = length;\n\t\tmemcpy(&payload[payloadpos],tempchr2,length);\n\t\tpayloadpos += length;\n\t\ttempchr2 = &tempchr[1];\n\t}\n\tlength = strlen(tempchr2);\n\tif (length)\n\t{\n\t\tif (payloadpos + length + 2 > 507)\n\t\t\treturn -1;\n\t\tpayload[payloadpos++] = length;\n\t\tmemcpy(&payload[payloadpos],tempchr2,length);\n\t\tpayloadpos += length;\n\t\tpayload[payloadpos++] = 0;\n\t}\n\tif (payloadpos > 508)\n\t\treturn -1;\n\tlength = htons(rr);\n\tmemcpy(&payload[payloadpos],&length,2);\n\tlength = htons(rr_class);\n\tmemcpy(&payload[payloadpos + 2],&length,2);\n\treturn payloadpos + 4;\n}\n\n/** Start lookup of an hostname to an IP address */\nint DNS::GetIP(const char *name)\n{\n\tDNSHeader h;\n\tint id;\n\tint length;\n\n\tif ((length = this->MakePayload(name, DNS_QUERY_A, 1, (unsigned char*)&h.payload)) == -1)\n\t\treturn -1;\n\n\tDNSRequest* req = this->AddQuery(&h, id, name);\n\n\tif ((!req) || (req->SendRequests(&h, length, DNS_QUERY_A) == -1))\n\t\treturn -1;\n\n\treturn id;\n}\n\n/** Start lookup of an hostname to an IPv6 address */\nint DNS::GetIP6(const char *name)\n{\n\tDNSHeader h;\n\tint id;\n\tint length;\n\n\tif ((length = this->MakePayload(name, DNS_QUERY_AAAA, 1, (unsigned char*)&h.payload)) == -1)\n\t\treturn -1;\n\n\tDNSRequest* req = this->AddQuery(&h, id, name);\n\n\tif ((!req) || (req->SendRequests(&h, length, DNS_QUERY_AAAA) == -1))\n\t\treturn -1;\n\n\treturn id;\n}\n\n/** Start lookup of a cname to another name */\nint DNS::GetCName(const char *alias)\n{\n\tDNSHeader h;\n\tint id;\n\tint length;\n\n\tif ((length = this->MakePayload(alias, DNS_QUERY_CNAME, 1, (unsigned char*)&h.payload)) == -1)\n\t\treturn -1;\n\n\tDNSRequest* req = this->AddQuery(&h, id, alias);\n\n\tif ((!req) || (req->SendRequests(&h, length, DNS_QUERY_CNAME) == -1))\n\t\treturn -1;\n\n\treturn id;\n}\n\n/** Start lookup of an IP address to a hostname */\nint DNS::GetNameForce(const char *ip, ForceProtocol fp)\n{\n\tchar query[128];\n\tDNSHeader h;\n\tint id;\n\tint length;\n\n\tif (fp == PROTOCOL_IPV6)\n\t{\n\t\tin6_addr i;\n\t\tif (inet_pton(AF_INET6, ip, &i) > 0)\n\t\t{\n\t\t\tDNS::MakeIP6Int(query, &i);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tServerInstance->Logs->Log(\"RESOLVER\",DEBUG,\"DNS::GetNameForce IPv6 bad format for '%s'\", ip);\n\t\t\t/* Invalid IP address */\n\t\t\treturn -1;\n\t\t}\n\t}\n\telse\n\t{\n\t\tin_addr i;\n\t\tif (inet_aton(ip, &i))\n\t\t{\n\t\t\tunsigned char* c = (unsigned char*)&i.s_addr;\n\t\t\tsprintf(query,\"%d.%d.%d.%d.in-addr.arpa\",c[3],c[2],c[1],c[0]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tServerInstance->Logs->Log(\"RESOLVER\",DEBUG,\"DNS::GetNameForce IPv4 bad format for '%s'\", ip);\n\t\t\t/* Invalid IP address */\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tlength = this->MakePayload(query, DNS_QUERY_PTR, 1, (unsigned char*)&h.payload);\n\tif (length == -1)\n\t{\n\t\tServerInstance->Logs->Log(\"RESOLVER\",DEBUG,\"DNS::GetNameForce can't query '%s' using '%s' because it's too long\", ip, query);\n\t\treturn -1;\n\t}\n\n\tDNSRequest* req = this->AddQuery(&h, id, ip);\n\n\tif (!req)\n\t{\n\t\tServerInstance->Logs->Log(\"RESOLVER\",DEBUG,\"DNS::GetNameForce can't add query (resolver down?)\");\n\t\treturn -1;\n\t}\n\n\tif (req->SendRequests(&h, length, DNS_QUERY_PTR) == -1)\n\t{\n\t\tServerInstance->Logs->Log(\"RESOLVER\",DEBUG,\"DNS::GetNameForce can't send (firewall?)\");\n\t\treturn -1;\n\t}\n\n\treturn id;\n}\n\n/** Build an ipv6 reverse domain from an in6_addr\n */\nvoid DNS::MakeIP6Int(char* query, const in6_addr *ip)\n{\n\tconst char* hex = \"0123456789abcdef\";\n\tfor (int index = 31; index >= 0; index--) /* for() loop steps twice per byte */\n\t{\n\t\tif (index % 2)\n\t\t\t/* low nibble */\n\t\t\t*query++ = hex[ip->s6_addr[index / 2] & 0x0F];\n\t\telse\n\t\t\t/* high nibble */\n\t\t\t*query++ = hex[(ip->s6_addr[index / 2] & 0xF0) >> 4];\n\t\t*query++ = '.'; /* Seperator */\n\t}\n\tstrcpy(query,\"ip6.arpa\"); /* Suffix the string */\n}\n\n/** Return the next id which is ready, and the result attached to it */\nDNSResult DNS::GetResult()\n{\n\t/* Fetch dns query response and decide where it belongs */\n\tDNSHeader header;\n\tDNSRequest *req;\n\tunsigned char buffer[sizeof(DNSHeader)];\n\tirc::sockets::sockaddrs from;\n\tmemset(&from, 0, sizeof(from));\n\tsocklen_t x = sizeof(from);\n\n\tint length = ServerInstance->SE->RecvFrom(this, (char*)buffer, sizeof(DNSHeader), 0, &from.sa, &x);\n\n\t/* Did we get the whole header? */\n\tif (length < 12)\n\t{\n\t\tServerInstance->Logs->Log(\"RESOLVER\",DEBUG,\"GetResult didn't get a full packet (len=%d)\", length);\n\t\t/* Nope - something screwed up. */\n\t\treturn DNSResult(-1,\"\",0,\"\");\n\t}\n\n\t/* Check wether the reply came from a different DNS\n\t * server to the one we sent it to, or the source-port\n\t * is not 53.\n\t * A user could in theory still spoof dns packets anyway\n\t * but this is less trivial than just sending garbage\n\t * to the server, which is possible without this check.\n\t *\n\t * -- Thanks jilles for pointing this one out.\n\t */\n\tif (from != myserver)\n\t{\n\t\tServerInstance->Logs->Log(\"RESOLVER\",DEBUG,\"Got a result from the wrong server! Bad NAT or DNS forging attempt? '%s' != '%s'\",\n\t\t\tfrom.str().c_str(), myserver.str().c_str());\n\t\treturn DNSResult(-1,\"\",0,\"\");\n\t}\n\n\t/* Put the read header info into a header class */\n\tDNS::FillHeader(&header,buffer,length - 12);\n\n\t/* Get the id of this request.\n\t * Its a 16 bit value stored in two char's,\n\t * so we use logic shifts to create the value.\n\t */\n\tunsigned long this_id = header.id[1] + (header.id[0] << 8);\n\n\t/* Do we have a pending request matching this id? */\n\tif (!requests[this_id])\n\t{\n\t\t/* Somehow we got a DNS response for a request we never made... */\n\t\tServerInstance->Logs->Log(\"RESOLVER\",DEBUG,\"Hmm, got a result that we didn't ask for (id=%lx). Ignoring.\", this_id);\n\t\treturn DNSResult(-1,\"\",0,\"\");\n\t}\n\telse\n\t{\n\t\t/* Remove the query from the list of pending queries */\n\t\treq = requests[this_id];\n\t\trequests[this_id] = NULL;\n\t}\n\n\t/* Inform the DNSRequest class that it has a result to be read.\n\t * When its finished it will return a DNSInfo which is a pair of\n\t * unsigned char* resource record data, and an error message.\n\t */\n\tDNSInfo data = req->ResultIsReady(header, length);\n\tstd::string resultstr;\n\n\t/* Check if we got a result, if we didnt, its an error */\n\tif (data.first == NULL)\n\t{\n\t\t/* An error.\n\t\t * Mask the ID with the value of ERROR_MASK, so that\n\t\t * the dns_deal_with_classes() function knows that its\n\t\t * an error response and needs to be treated uniquely.\n\t\t * Put the error message in the second field.\n\t\t */\n\t\tstd::string ro = req->orig;\n\t\tdelete req;\n\t\treturn DNSResult(this_id | ERROR_MASK, data.second, 0, ro);\n\t}\n\telse\n\t{\n\t\tunsigned long ttl = req->ttl;\n\t\tchar formatted[128];\n\n\t\t/* Forward lookups come back as binary data. We must format them into ascii */\n\t\tswitch (req->type)\n\t\t{\n\t\t\tcase DNS_QUERY_A:\n\t\t\t\tsnprintf(formatted,16,\"%u.%u.%u.%u\",data.first[0],data.first[1],data.first[2],data.first[3]);\n\t\t\t\tresultstr = formatted;\n\t\t\tbreak;\n\n\t\t\tcase DNS_QUERY_AAAA:\n\t\t\t{\n\t\t\t\tinet_ntop(AF_INET6, data.first, formatted, sizeof(formatted));\n\t\t\t\tchar* c = strstr(formatted,\":0:\");\n\t\t\t\tif (c != NULL)\n\t\t\t\t{\n\t\t\t\t\tmemmove(c+1,c+2,strlen(c+2) + 1);\n\t\t\t\t\tc += 2;\n\t\t\t\t\twhile (memcmp(c,\"0:\",2) == 0)\n\t\t\t\t\t\tmemmove(c,c+2,strlen(c+2) + 1);\n\t\t\t\t\tif (memcmp(c,\"0\",2) == 0)\n\t\t\t\t\t\t*c = 0;\n\t\t\t\t\tif (memcmp(formatted,\"0::\",3) == 0)\n\t\t\t\t\t\tmemmove(formatted,formatted + 1, strlen(formatted + 1) + 1);\n\t\t\t\t}\n\t\t\t\tresultstr = formatted;\n\n\t\t\t\t/* Special case. Sending ::1 around between servers\n\t\t\t\t * and to clients is dangerous, because the : on the\n\t\t\t\t * start makes the client or server interpret the IP\n\t\t\t\t * as the last parameter on the line with a value \":1\".\n\t\t\t\t */\n\t\t\t\tif (*formatted == ':')\n\t\t\t\t\tresultstr.insert(0, \"0\");\n\t\t\t}\n\t\t\tbreak;\n\n\t\t\tcase DNS_QUERY_CNAME:\n\t\t\t\t/* Identical handling to PTR */\n\n\t\t\tcase DNS_QUERY_PTR:\n\t\t\t\t/* Reverse lookups just come back as char* */\n\t\t\t\tresultstr = std::string((const char*)data.first);\n\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Build the reply with the id and hostname/ip in it */\n\t\tstd::string ro = req->orig;\n\t\tdelete req;\n\t\treturn DNSResult(this_id,resultstr,ttl,ro);\n\t}\n}\n\n/** A result is ready, process it */\nDNSInfo DNSRequest::ResultIsReady(DNSHeader &header, unsigned length)\n{\n\tunsigned i = 0, o;\n\tint q = 0;\n\tint curanswer;\n\tResourceRecord rr;\n \tunsigned short ptr;\n\n\t/* This is just to keep _FORTIFY_SOURCE happy */\n\trr.type = DNS_QUERY_NONE;\n\trr.rdlength = 0;\n\trr.ttl = 1;\t/* GCC is a whiney bastard -- see the XXX below. */\n\trr.rr_class = 0; /* Same for VC++ */\n\n\tif (!(header.flags1 & FLAGS_MASK_QR))\n\t\treturn std::make_pair((unsigned char*)NULL,\"Not a query result\");\n\n\tif (header.flags1 & FLAGS_MASK_OPCODE)\n\t\treturn std::make_pair((unsigned char*)NULL,\"Unexpected value in DNS reply packet\");\n\n\tif (header.flags2 & FLAGS_MASK_RCODE)\n\t\treturn std::make_pair((unsigned char*)NULL,\"Domain name not found\");\n\n\tif (header.ancount < 1)\n\t\treturn std::make_pair((unsigned char*)NULL,\"No resource records returned\");\n\n\t/* Subtract the length of the header from the length of the packet */\n\tlength -= 12;\n\n\twhile ((unsigned int)q < header.qdcount && i < length)\n\t{\n\t\tif (header.payload[i] > 63)\n\t\t{\n\t\t\ti += 6;\n\t\t\tq++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (header.payload[i] == 0)\n\t\t\t{\n\t\t\t\tq++;\n\t\t\t\ti += 5;\n\t\t\t}\n\t\t\telse i += header.payload[i] + 1;\n\t\t}\n\t}\n\tcuranswer = 0;\n\twhile ((unsigned)curanswer < header.ancount)\n\t{\n\t\tq = 0;\n\t\twhile (q == 0 && i < length)\n\t\t{\n\t\t\tif (header.payload[i] > 63)\n\t\t\t{\n\t\t\t\ti += 2;\n\t\t\t\tq = 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (header.payload[i] == 0)\n\t\t\t\t{\n\t\t\t\t\ti++;\n\t\t\t\t\tq = 1;\n\t\t\t\t}\n\t\t\t\telse i += header.payload[i] + 1; /* skip length and label */\n\t\t\t}\n\t\t}\n\t\tif (length - i < 10)\n\t\t\treturn std::make_pair((unsigned char*)NULL,\"Incorrectly sized DNS reply\");\n\n\t\t/* XXX: We actually initialise 'rr' here including its ttl field */\n\t\tDNS::FillResourceRecord(&rr,&header.payload[i]);\n\n\t\ti += 10;\n\t\tServerInstance->Logs->Log(\"RESOLVER\",DEBUG,\"Resolver: rr.type is %d and this.type is %d rr.class %d this.class %d\", rr.type, this->type, rr.rr_class, this->rr_class);\n\t\tif (rr.type != this->type)\n\t\t{\n\t\t\tcuranswer++;\n\t\t\ti += rr.rdlength;\n\t\t\tcontinue;\n\t\t}\n\t\tif (rr.rr_class != this->rr_class)\n\t\t{\n\t\t\tcuranswer++;\n\t\t\ti += rr.rdlength;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\tif ((unsigned int)curanswer == header.ancount)\n\t\treturn std::make_pair((unsigned char*)NULL,\"No A, AAAA or PTR type answers (\" + ConvToStr(header.ancount) + \" answers)\");\n\n\tif (i + rr.rdlength > (unsigned int)length)\n\t\treturn std::make_pair((unsigned char*)NULL,\"Resource record larger than stated\");\n\n\tif (rr.rdlength > 1023)\n\t\treturn std::make_pair((unsigned char*)NULL,\"Resource record too large\");\n\n\tthis->ttl = rr.ttl;\n\n\tswitch (rr.type)\n\t{\n\t\t/*\n\t\t * CNAME and PTR are compressed.  We need to decompress them.\n\t\t */\n\t\tcase DNS_QUERY_CNAME:\n\t\tcase DNS_QUERY_PTR:\n\t\t\to = 0;\n\t\t\tq = 0;\n\t\t\twhile (q == 0 && i < length && o + 256 < 1023)\n\t\t\t{\n\t\t\t\t/* DN label found (byte over 63) */\n\t\t\t\tif (header.payload[i] > 63)\n\t\t\t\t{\n\t\t\t\t\tmemcpy(&ptr,&header.payload[i],2);\n\n\t\t\t\t\ti = ntohs(ptr);\n\n\t\t\t\t\t/* check that highest two bits are set. if not, we've been had */\n\t\t\t\t\tif (!(i & DN_COMP_BITMASK))\n\t\t\t\t\t\treturn std::make_pair((unsigned char *) NULL, \"DN label decompression header is bogus\");\n\n\t\t\t\t\t/* mask away the two highest bits. */\n\t\t\t\t\ti &= ~DN_COMP_BITMASK;\n\n\t\t\t\t\t/* and decrease length by 12 bytes. */\n\t\t\t\t\ti =- 12;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (header.payload[i] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tq = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tres[o] = 0;\n\t\t\t\t\t\tif (o != 0)\n\t\t\t\t\t\t\tres[o++] = '.';\n\n\t\t\t\t\t\tif (o + header.payload[i] > sizeof(DNSHeader))\n\t\t\t\t\t\t\treturn std::make_pair((unsigned char *) NULL, \"DN label decompression is impossible -- malformed/hostile packet?\");\n\n\t\t\t\t\t\tmemcpy(&res[o], &header.payload[i + 1], header.payload[i]);\n\t\t\t\t\t\to += header.payload[i];\n\t\t\t\t\t\ti += header.payload[i] + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres[o] = 0;\n\t\tbreak;\n\t\tcase DNS_QUERY_AAAA:\n\t\t\tif (rr.rdlength != sizeof(struct in6_addr))\n\t\t\t\treturn std::make_pair((unsigned char *) NULL, \"rr.rdlength is larger than 16 bytes for an ipv6 entry -- malformed/hostile packet?\");\n\n\t\t\tmemcpy(res,&header.payload[i],rr.rdlength);\n\t\t\tres[rr.rdlength] = 0;\n\t\tbreak;\n\t\tcase DNS_QUERY_A:\n\t\t\tif (rr.rdlength != sizeof(struct in_addr))\n\t\t\t\treturn std::make_pair((unsigned char *) NULL, \"rr.rdlength is larger than 4 bytes for an ipv4 entry -- malformed/hostile packet?\");\n\n\t\t\tmemcpy(res,&header.payload[i],rr.rdlength);\n\t\t\tres[rr.rdlength] = 0;\n\t\tbreak;\n\t\tdefault:\n\t\t\treturn std::make_pair((unsigned char *) NULL, \"don't know how to handle undefined type (\" + ConvToStr(rr.type) + \") -- rejecting\");\n\t\tbreak;\n\t}\n\treturn std::make_pair(res,\"No error\");\n}\n\n/** Close the master socket */\nDNS::~DNS()\n{\n\tServerInstance->SE->Shutdown(this, 2);\n\tServerInstance->SE->Close(this);\n\tServerInstance->Timers->DelTimer(this->PruneTimer);\n\tif (cache)\n\t\tdelete cache;\n}\n\nCachedQuery* DNS::GetCache(const std::string &source)\n{\n\tdnscache::iterator x = cache->find(source.c_str());\n\tif (x != cache->end())\n\t\treturn &(x->second);\n\telse\n\t\treturn NULL;\n}\n\nvoid DNS::DelCache(const std::string &source)\n{\n\tcache->erase(source.c_str());\n}\n\nvoid Resolver::TriggerCachedResult()\n{\n\tif (CQ)\n\t\tOnLookupComplete(CQ->data, time_left, true);\n}\n\n/** High level abstraction of dns used by application at large */\nResolver::Resolver(const std::string &source, QueryType qt, bool &cached, Module* creator) : Creator(creator), input(source), querytype(qt)\n{\n\tServerInstance->Logs->Log(\"RESOLVER\",DEBUG,\"Resolver::Resolver\");\n\tcached = false;\n\n\tCQ = ServerInstance->Res->GetCache(source);\n\tif (CQ)\n\t{\n\t\ttime_left = CQ->CalcTTLRemaining();\n\t\tif (!time_left)\n\t\t{\n\t\t\tServerInstance->Res->DelCache(source);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcached = true;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tswitch (querytype)\n\t{\n\t\tcase DNS_QUERY_A:\n\t\t\tthis->myid = ServerInstance->Res->GetIP(source.c_str());\n\t\tbreak;\n\n\t\tcase DNS_QUERY_PTR4:\n\t\t\tquerytype = DNS_QUERY_PTR;\n\t\t\tthis->myid = ServerInstance->Res->GetNameForce(source.c_str(), PROTOCOL_IPV4);\n\t\tbreak;\n\n\t\tcase DNS_QUERY_PTR6:\n\t\t\tquerytype = DNS_QUERY_PTR;\n\t\t\tthis->myid = ServerInstance->Res->GetNameForce(source.c_str(), PROTOCOL_IPV6);\n\t\tbreak;\n\n\t\tcase DNS_QUERY_AAAA:\n\t\t\tthis->myid = ServerInstance->Res->GetIP6(source.c_str());\n\t\tbreak;\n\n\t\tcase DNS_QUERY_CNAME:\n\t\t\tthis->myid = ServerInstance->Res->GetCName(source.c_str());\n\t\tbreak;\n\n\t\tdefault:\n\t\t\tServerInstance->Logs->Log(\"RESOLVER\",DEBUG,\"DNS request with unknown query type %d\", querytype);\n\t\t\tthis->myid = -1;\n\t\tbreak;\n\t}\n\tif (this->myid == -1)\n\t{\n\t\tthrow ModuleException(\"Resolver: Couldn't get an id to make a request\");\n\t}\n\telse\n\t{\n\t\tServerInstance->Logs->Log(\"RESOLVER\",DEBUG,\"DNS request id %d\", this->myid);\n\t}\n}\n\n/** Called when an error occurs */\nvoid Resolver::OnError(ResolverError, const std::string&)\n{\n\t/* Nothing in here */\n}\n\n/** Destroy a resolver */\nResolver::~Resolver()\n{\n\t/* Nothing here (yet) either */\n}\n\n/** Get the request id associated with this class */\nint Resolver::GetId()\n{\n\treturn this->myid;\n}\n\nModule* Resolver::GetCreator()\n{\n\treturn this->Creator;\n}\n\n/** Process a socket read event */\nvoid DNS::HandleEvent(EventType, int)\n{\n\t/* Fetch the id and result of the next available packet */\n\tDNSResult res(0,\"\",0,\"\");\n\tres.id = 0;\n\tServerInstance->Logs->Log(\"RESOLVER\",DEBUG,\"Handle DNS event\");\n\n\tres = this->GetResult();\n\n\tServerInstance->Logs->Log(\"RESOLVER\",DEBUG,\"Result id %d\", res.id);\n\n\t/* Is there a usable request id? */\n\tif (res.id != -1)\n\t{\n\t\t/* Its an error reply */\n\t\tif (res.id & ERROR_MASK)\n\t\t{\n\t\t\t/* Mask off the error bit */\n\t\t\tres.id -= ERROR_MASK;\n\t\t\t/* Marshall the error to the correct class */\n\t\t\tif (Classes[res.id])\n\t\t\t{\n\t\t\t\tif (ServerInstance && ServerInstance->stats)\n\t\t\t\t\tServerInstance->stats->statsDnsBad++;\n\t\t\t\tClasses[res.id]->OnError(RESOLVER_NXDOMAIN, res.result);\n\t\t\t\tdelete Classes[res.id];\n\t\t\t\tClasses[res.id] = NULL;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* It is a non-error result, marshall the result to the correct class */\n\t\t\tif (Classes[res.id])\n\t\t\t{\n\t\t\t\tif (ServerInstance && ServerInstance->stats)\n\t\t\t\t\tServerInstance->stats->statsDnsGood++;\n\n\t\t\t\tif (!this->GetCache(res.original.c_str()))\n\t\t\t\t\tthis->cache->insert(std::make_pair(res.original.c_str(), CachedQuery(res.result, res.ttl)));\n\n\t\t\t\tClasses[res.id]->OnLookupComplete(res.result, res.ttl, false);\n\t\t\t\tdelete Classes[res.id];\n\t\t\t\tClasses[res.id] = NULL;\n\t\t\t}\n\t\t}\n\n\t\tif (ServerInstance && ServerInstance->stats)\n\t\t\tServerInstance->stats->statsDns++;\n\t}\n}\n\n/** Add a derived Resolver to the working set */\nbool DNS::AddResolverClass(Resolver* r)\n{\n\tServerInstance->Logs->Log(\"RESOLVER\",DEBUG,\"AddResolverClass 0x%08lx\", (unsigned long)r);\n\t/* Check the pointers validity and the id's validity */\n\tif ((r) && (r->GetId() > -1))\n\t{\n\t\t/* Check the slot isnt already occupied -\n\t\t * This should NEVER happen unless we have\n\t\t * a severely broken DNS server somewhere\n\t\t */\n\t\tif (!Classes[r->GetId()])\n\t\t{\n\t\t\t/* Set up the pointer to the class */\n\t\t\tClasses[r->GetId()] = r;\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t\t/* Duplicate id */\n\t\t\treturn false;\n\t}\n\telse\n\t{\n\t\t/* Pointer or id not valid.\n\t\t * Free the item and return\n\t\t */\n\t\tif (r)\n\t\t\tdelete r;\n\n\t\treturn false;\n\t}\n}\n\nvoid DNS::CleanResolvers(Module* module)\n{\n\tfor (int i = 0; i < MAX_REQUEST_ID; i++)\n\t{\n\t\tif (Classes[i])\n\t\t{\n\t\t\tif (Classes[i]->GetCreator() == module)\n\t\t\t{\n\t\t\t\tClasses[i]->OnError(RESOLVER_FORCEUNLOAD, \"Parent module is unloading\");\n\t\t\t\tdelete Classes[i];\n\t\t\t\tClasses[i] = NULL;\n\t\t\t}\n\t\t}\n\t}\n}\n"], "filenames": ["src/dns.cpp"], "buggy_code_start_loc": [40], "buggy_code_end_loc": [835], "fixing_code_start_loc": [41], "fixing_code_end_loc": [863], "type": "CWE-119", "message": "Heap-based buffer overflow in dns.cpp in InspIRCd 2.0.5 might allow remote attackers to execute arbitrary code via a crafted DNS query that uses compression.", "other": {"cve": {"id": "CVE-2012-1836", "sourceIdentifier": "cve@mitre.org", "published": "2012-03-22T03:28:04.470", "lastModified": "2020-09-14T12:33:22.683", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Heap-based buffer overflow in dns.cpp in InspIRCd 2.0.5 might allow remote attackers to execute arbitrary code via a crafted DNS query that uses compression."}, {"lang": "es", "value": "Desbordamiento de b\u00fafer basado en memoria din\u00e1mica en dns.cpp en InspIRCd v2.0.5 podr\u00eda permitir a atacantes remotos ejecutar c\u00f3digo arbitrario a trav\u00e9s de una consulta DNS modificada que utiliza compresi\u00f3n."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:inspircd:inspircd:2.0.5:*:*:*:*:*:*:*", "matchCriteriaId": "73E76324-E234-4066-9545-AB9BCF2FF780"}]}]}], "references": [{"url": "http://osvdb.org/80263", "source": "cve@mitre.org"}, {"url": "http://secunia.com/advisories/48474", "source": "cve@mitre.org"}, {"url": "http://www.debian.org/security/2012/dsa-2448", "source": "cve@mitre.org"}, {"url": "http://www.kb.cert.org/vuls/id/212651", "source": "cve@mitre.org", "tags": ["Patch", "US Government Resource"]}, {"url": "http://www.securityfocus.com/bid/52561", "source": "cve@mitre.org"}, {"url": "https://exchange.xforce.ibmcloud.com/vulnerabilities/74157", "source": "cve@mitre.org"}, {"url": "https://github.com/inspircd/inspircd/commit/fe7dbd2c104c37f6f3af7d9f1646a3c332aea4a4", "source": "cve@mitre.org", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/inspircd/inspircd/commit/fe7dbd2c104c37f6f3af7d9f1646a3c332aea4a4"}}