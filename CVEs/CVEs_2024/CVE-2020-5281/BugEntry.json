{"buggy_code": ["package cz.metacentrum.perun.core.impl;\n\nimport cz.metacentrum.perun.core.api.ExtSource;\nimport cz.metacentrum.perun.core.api.GroupsManager;\nimport cz.metacentrum.perun.core.api.exceptions.ExtSourceUnsupportedOperationException;\nimport cz.metacentrum.perun.core.api.exceptions.InternalErrorException;\nimport cz.metacentrum.perun.core.api.exceptions.SubjectNotExistsException;\nimport cz.metacentrum.perun.core.blImpl.PerunBlImpl;\nimport cz.metacentrum.perun.core.implApi.ExtSourceApi;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.naming.Context;\nimport javax.naming.NamingEnumeration;\nimport javax.naming.NamingException;\nimport javax.naming.directory.Attribute;\nimport javax.naming.directory.Attributes;\nimport javax.naming.directory.DirContext;\nimport javax.naming.directory.InitialDirContext;\nimport javax.naming.directory.SearchControls;\nimport javax.naming.directory.SearchResult;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Hashtable;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * Ext source implementation for LDAP.\n *\n * @author Michal Prochazka michalp@ics.muni.cz\n * @author Pavel Zl\u00e1mal <zlamal@cesnet.cz>\n */\npublic class ExtSourceLdap extends ExtSource implements ExtSourceApi {\n\n\tprotected Map<String, String> mapping;\n\n\tprotected final static Logger log = LoggerFactory.getLogger(ExtSourceLdap.class);\n\n\tprotected DirContext dirContext = null;\n\tprotected String filteredQuery = null;\n\n\tprotected DirContext getContext() throws InternalErrorException {\n\t\tif (dirContext == null) {\n\t\t\tinitContext();\n\t\t}\n\t\treturn dirContext;\n\t}\n\n\tprivate static PerunBlImpl perunBl;\n\n\t// filled by spring (perun-core.xml)\n\tpublic static PerunBlImpl setPerunBlImpl(PerunBlImpl perun) {\n\t\tperunBl = perun;\n\t\treturn perun;\n\t}\n\n\t@Override\n\tpublic List<Map<String,String>> findSubjectsLogins(String searchString) throws InternalErrorException {\n\t\treturn findSubjectsLogins(searchString, 0);\n\t}\n\n\t@Override\n\tpublic List<Map<String,String>> findSubjectsLogins(String searchString, int maxResults) throws InternalErrorException {\n\t\t// Prepare searchQuery\n\t\t// attributes.get(\"query\") contains query template, e.g. (uid=?), ? will be replaced by the searchString\n\t\tString query = getAttributes().get(\"query\");\n\t\tif (query == null) {\n\t\t\tthrow new InternalErrorException(\"query attributes is required\");\n\t\t}\n\t\tquery = query.replaceAll(\"\\\\?\", searchString);\n\n\t\tString base = getAttributes().get(\"base\");\n\t\tif (base == null) {\n\t\t\tthrow new InternalErrorException(\"base attributes is required\");\n\t\t}\n\t\treturn this.querySource(query, base, maxResults);\n\t}\n\n\t@Override\n\tpublic Map<String, String> getSubjectByLogin(String login) throws InternalErrorException, SubjectNotExistsException {\n\t\t// Prepare searchQuery\n\t\t// attributes.get(\"loginQuery\") contains query template, e.g. (uid=?), ? will be replaced by the login\n\t\tString query = getAttributes().get(\"loginQuery\");\n\t\tif (query == null) {\n\t\t\tthrow new InternalErrorException(\"loginQuery attributes is required\");\n\t\t}\n\t\tquery = query.replaceAll(\"\\\\?\", login);\n\n\t\tString base = getAttributes().get(\"base\");\n\t\tif (base == null) {\n\t\t\tthrow new InternalErrorException(\"base attributes is required\");\n\t\t}\n\n\t\tList<Map<String, String>> subjects = this.querySource(query, base, 0);\n\n\t\tif (subjects.size() > 1) {\n\t\t\tthrow new SubjectNotExistsException(\"There are more than one results for the login: \" + login);\n\t\t}\n\n\t\tif (subjects.size() == 0) {\n\t\t\tthrow new SubjectNotExistsException(login);\n\t\t}\n\n\t\treturn subjects.get(0);\n\t}\n\n\t@Override\n\tpublic List<Map<String, String>> getGroupSubjects(Map<String, String> attributes) throws InternalErrorException {\n\n\t\tList<String> ldapGroupSubjects = new ArrayList<>();\n\n\t\t// Get the LDAP group name\n\t\tString ldapGroupName = attributes.get(GroupsManager.GROUPMEMBERSQUERY_ATTRNAME);\n\t\t// Get optional filter for members filtering\n\t\tString filter = attributes.get(GroupsManager.GROUPMEMBERSFILTER_ATTRNAME);\n\n\t\ttry {\n\t\t\tlog.trace(\"LDAP External Source: searching for group subjects [{}]\", ldapGroupName);\n\n\t\t\tString attrName;\n\t\t\t// Default value\n\t\t\tattrName = getAttributes().getOrDefault(\"memberAttribute\", \"uniqueMember\");\n\t\t\tList<String> retAttrs = new ArrayList<>();\n\t\t\tretAttrs.add(attrName);\n\n\t\t\tString[] retAttrsArray = retAttrs.toArray(new String[0]);\n\t\t\tAttributes attrs = getContext().getAttributes(ldapGroupName, retAttrsArray);\n\n\t\t\tAttribute ldapAttribute = null;\n\t\t\t// Get the list of returned groups, should be only one\n\t\t\tif (attrs.get(attrName) != null) {\n\t\t\t\t// Get the attribute which holds group subjects\n\t\t\t\tldapAttribute = attrs.get(attrName);\n\t\t\t}\n\n\t\t\tif (ldapAttribute != null) {\n\t\t\t\t// Get the DNs of the subjects\n\t\t\t\tfor (int i=0; i < ldapAttribute.size(); i++) {\n\t\t\t\t\tString ldapSubjectDN = (String) ldapAttribute.get(i);\n\t\t\t\t\tldapGroupSubjects.add(ldapSubjectDN);\n\t\t\t\t\tlog.trace(\"LDAP External Source: found group subject [{}].\", ldapSubjectDN);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tList<Map<String, String>> subjects = new ArrayList<>();\n\n\t\t\t// If attribute filter not exists, use optional default filter from extSource definition\n\t\t\tif(filter == null) filter = filteredQuery;\n\n\t\t\t// Now query LDAP again and search for each subject\n\t\t\tfor (String ldapSubjectName : ldapGroupSubjects) {\n\t\t\t\tsubjects.addAll(this.querySource(filter, ldapSubjectName, 0));\n\t\t\t}\n\n\t\t\treturn subjects;\n\n\t\t} catch (NamingException e) {\n\t\t\tlog.error(\"LDAP exception during running query '{}'\", ldapGroupName);\n\t\t\tthrow new InternalErrorException(\"Entry '\"+ldapGroupName+\"' was not found in LDAP.\" , e);\n\t\t}\n\t}\n\n\t@Override\n\tpublic List<Map<String, String>> getUsersSubjects() throws ExtSourceUnsupportedOperationException {\n\t\tthrow new ExtSourceUnsupportedOperationException();\n\t}\n\n\tprotected void initContext() throws InternalErrorException {\n\t\t// Load mapping between LDAP attributes and Perun attributes\n\t\tHashtable<String,String> env = new Hashtable<>();\n\n\t\tenv.put(Context.INITIAL_CONTEXT_FACTORY,\"com.sun.jndi.ldap.LdapCtxFactory\");\n\t\tenv.put(Context.SECURITY_AUTHENTICATION, \"simple\");\n\t\tif (getAttributes().containsKey(\"referral\")) {\n\t\t\tenv.put(Context.REFERRAL, getAttributes().get(\"referral\"));\n\t\t}\n\t\tif (getAttributes().containsKey(\"url\")) {\n\t\t\tenv.put(Context.PROVIDER_URL, getAttributes().get(\"url\"));\n\t\t} else {\n\t\t\tthrow new InternalErrorException(\"url attributes is required\");\n\t\t}\n\t\tif (getAttributes().containsKey(\"user\")) {\n\t\t\tenv.put(Context.SECURITY_PRINCIPAL, getAttributes().get(\"user\"));\n\t\t}\n\t\tif (getAttributes().containsKey(\"password\")) {\n\t\t\tenv.put(Context.SECURITY_CREDENTIALS, getAttributes().get(\"password\"));\n\t\t}\n\n\t\tif (getAttributes().containsKey(\"filteredQuery\")) {\n\t\t\tfilteredQuery = getAttributes().get(\"filteredQuery\");\n\t\t}\n\n\t\ttry {\n\t\t\t// ldapMapping contains entries like: firstName={givenName},lastName={sn},email={mail}\n\t\t\tif (getAttributes().get(\"ldapMapping\") == null) {\n\t\t\t\tthrow new InternalErrorException(\"ldapMapping attributes is required\");\n\t\t\t}\n\t\t\tString[] ldapMapping = getAttributes().get(\"ldapMapping\").trim().split(\",\\n\");\n\t\t\tmapping = new HashMap<>();\n\t\t\tfor (String entry: ldapMapping) {\n\t\t\t\tString[] values = entry.trim().split(\"=\", 2);\n\t\t\t\tmapping.put(values[0].trim(), values[1].trim());\n\t\t\t}\n\n\t\t\tthis.dirContext = new InitialDirContext(env);\n\t\t} catch (NamingException e) {\n\t\t\tlog.error(\"LDAP exception during creating the context.\");\n\t\t\tthrow new InternalErrorException(e);\n\t\t}\n\t}\n\n\tprotected Map<String,String> getSubjectAttributes(Attributes attributes) throws InternalErrorException {\n\t\tPattern pattern = Pattern.compile(\"\\\\{([^}])*}\");\n\t\tMap<String, String> map = new HashMap<>();\n\n\t\tfor (String key: mapping.keySet()) {\n\t\t\t// Get attribute value and substitute all {} in the string\n\t\t\tMatcher matcher = pattern.matcher(mapping.get(key));\n\t\t\tString value = mapping.get(key);\n\n\t\t\t// Find all matches\n\t\t\twhile (matcher.find()) {\n\t\t\t\t// Get the matching string\n\t\t\t\tString ldapAttributeNameRaw = matcher.group();\n\t\t\t\tString ldapAttributeName = ldapAttributeNameRaw.replaceAll(\"\\\\{([^}]*)}\", \"$1\"); // ldapAttributeNameRaw is encapsulate with {}, so remove it\n\t\t\t\t// Replace {ldapAttrName} with the value\n\t\t\t\tvalue = value.replace(ldapAttributeNameRaw, getLdapAttributeValue(attributes, ldapAttributeName));\n\t\t\t\tlog.trace(\"ExtSourceLDAP: Retrieved value {} of attribute {} for {} and storing into the key {}.\", value, ldapAttributeName, ldapAttributeNameRaw, key);\n\t\t\t}\n\n\t\t\tmap.put(key, value);\n\t\t}\n\n\t\treturn map;\n\t}\n\n\tprotected String getLdapAttributeValue(Attributes attributes, String ldapAttrNameRaw)  throws InternalErrorException {\n\t\tString ldapAttrName;\n\t\tString rule = null;\n\t\tMatcher matcher;\n\t\tString attrValue = \"\";\n\n\t\t// Check if the ldapAttrName contains regex\n\t\tif (ldapAttrNameRaw.contains(\"|\")) {\n\t\t\tint splitter = ldapAttrNameRaw.indexOf('|');\n\t\t\tldapAttrName = ldapAttrNameRaw.substring(0,splitter);\n\t\t\trule = ldapAttrNameRaw.substring(splitter+1);\n\t\t} else {\n\t\t\tldapAttrName = ldapAttrNameRaw;\n\t\t}\n\n\t\t// Check if the ldapAttrName contains specification of the value index\n\t\tint attributeValueIndex = -1;\n\t\tif (ldapAttrNameRaw.contains(\"[\")) {\n\t\t\tPattern indexPattern = Pattern.compile(\"^(.*)\\\\[([0-9]+)]$\");\n\t\t\tMatcher indexMatcher = indexPattern.matcher(ldapAttrNameRaw);\n\t\t\tif (indexMatcher.find()) {\n\t\t\t\tldapAttrName = indexMatcher.group(1);\n\t\t\t\tattributeValueIndex = Integer.parseInt(indexMatcher.group(2));\n\t\t\t} else {\n\t\t\t\tthrow new InternalErrorException(\"Wrong attribute name format for attribute: \" + ldapAttrNameRaw + \", it should be name[0-9+]\");\n\t\t\t}\n\t\t}\n\n\t\t// Mapping to the LDAP attribute\n\t\tAttribute attr = attributes.get(ldapAttrName);\n\t\tif (attr != null) {\n\t\t\t// There could be more than one value in the attribute. Separator is defined in the AttributesManagerImpl\n\t\t\tfor (int i = 0; i < attr.size(); i++) {\n\t\t\t\tif (attributeValueIndex != -1 && attributeValueIndex != i) {\n\t\t\t\t\t// We want only value on concrete index, so skip the other ones\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tString tmpAttrValue;\n\t\t\t\ttry {\n\t\t\t\t\tif(attr.get() instanceof byte[]) {\n\t\t\t\t\t\t// It can be byte array with cert or binary file\n\t\t\t\t\t\tchar[] encodedValue = Base64Coder.encode((byte[]) attr.get());\n\t\t\t\t\t\ttmpAttrValue = new String(encodedValue);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttmpAttrValue = (String) attr.get(i);\n\t\t\t\t\t}\n\t\t\t\t} catch (NamingException e) {\n\t\t\t\t\tthrow new InternalErrorException(e);\n\t\t\t\t}\n\n\t\t\t\tif (rule != null) {\n\t\t\t\t\tif(rule.contains(\"#\")) {\n\t\t\t\t\t\t// Rules are in place, so apply them\n\t\t\t\t\t\tString regex = rule.substring(0, rule.indexOf('#'));\n\t\t\t\t\t\tString replacement = rule.substring(rule.indexOf('#')+1);\n\t\t\t\t\t\ttmpAttrValue = tmpAttrValue.replaceAll(regex, replacement);\n\t\t\t\t\t//DEPRECATED way\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Rules are in place, so apply them\n\t\t\t\t\t\tPattern pattern = Pattern.compile(rule);\n\t\t\t\t\t\tmatcher = pattern.matcher(tmpAttrValue);\n\t\t\t\t\t\t// Get the first group which matched\n\t\t\t\t\t\tif (matcher.matches()) {\n\t\t\t\t\t\t\ttmpAttrValue = matcher.group(1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (i == 0 || attributeValueIndex != -1) {\n\t\t\t\t\t// Do not add delimiter before first entry or if the particular index has been requested\n\t\t\t\t\tattrValue += tmpAttrValue;\n\t\t\t\t} else {\n\t\t\t\t\tattrValue += AttributesManagerImpl.LIST_DELIMITER + tmpAttrValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (attrValue.isEmpty()) {\n\t\t\t\treturn \"\";\n\t\t\t} else {\n\t\t\t\treturn attrValue;\n\t\t\t}\n\t\t} else {\n\t\t\treturn \"\";\n\t\t}\n\t}\n\n\t/**\n\t * Query LDAP using query in defined base. Results can be limited to the maxResults.\n\t *\n\t * @param query\n\t * @param base\n\t * @param maxResults\n\t * @return List of Map of the LDAP attribute names and theirs values\n\t * @throws InternalErrorException\n\t */\n\tprotected List<Map<String,String>> querySource(String query, String base, int maxResults) throws InternalErrorException {\n\n\t\tNamingEnumeration<SearchResult> results = null;\n\t\tList<Map<String, String>> subjects = new ArrayList<>();\n\n\t\ttry {\n\t\t\t// If query is null, then we are finding object by the base\n\t\t\tif (query == null) {\n\t\t\t\tlog.trace(\"search base [{}]\", base);\n\t\t\t\t// TODO jmena atributu spise prijimiat pres vstupni parametr metody\n\t\t\t\tAttributes ldapAttributes = getContext().getAttributes(base);\n\t\t\t\tif (ldapAttributes.size() > 0) {\n\t\t\t\t\tMap<String, String> attributes = this.getSubjectAttributes(ldapAttributes);\n\t\t\t\t\tif (!attributes.isEmpty()) {\n\t\t\t\t\t\tsubjects.add(attributes);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlog.trace(\"search string [{}]\", query);\n\n\t\t\t\tSearchControls controls = new SearchControls();\n\t\t\t\tcontrols.setSearchScope(SearchControls.SUBTREE_SCOPE);\n\t\t\t\t// Set timeout to 5s\n\t\t\t\tcontrols.setTimeLimit(5000);\n\t\t\t\tif (maxResults > 0) {\n\t\t\t\t\tcontrols.setCountLimit(maxResults);\n\t\t\t\t}\n\n\t\t\t\tif (base == null) base = \"\";\n\n\t\t\t\tresults = getContext().search(base, query, controls);\n\t\t\t\twhile (results.hasMore()) {\n\t\t\t\t\tSearchResult searchResult = results.next();\n\t\t\t\t\tAttributes attributes = searchResult.getAttributes();\n\t\t\t\t\tMap<String,String> subjectAttributes = this.getSubjectAttributes(attributes);\n\t\t\t\t\tif (!subjectAttributes.isEmpty()) {\n\t\t\t\t\t\tsubjects.add(subjectAttributes);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlog.trace(\"Returning [{}] subjects\", subjects.size());\n\t\t\treturn subjects;\n\n\t\t} catch (NamingException e) {\n\t\t\tlog.error(\"LDAP exception during running query '{}'\", query);\n\t\t\tthrow new InternalErrorException(\"LDAP exception during running query: \"+query+\".\", e);\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (results != null) { results.close(); }\n\t\t\t} catch (Exception e) {\n\t\t\t\tlog.error(\"LDAP exception during closing result, while running query '{}'\", query);\n\t\t\t\tthrow new InternalErrorException(e);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void close() throws InternalErrorException {\n\t\tif (this.dirContext != null) {\n\t\t\ttry {\n\t\t\t\tthis.dirContext.close();\n\t\t\t\tthis.dirContext = null;\n\t\t\t} catch (NamingException e) {\n\t\t\t\tthrow new InternalErrorException(e);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic List<Map<String, String>> getSubjectGroups(Map<String, String> attributes) throws ExtSourceUnsupportedOperationException {\n\t\tthrow new ExtSourceUnsupportedOperationException();\n\t}\n\n\t@Override\n\tpublic List<Map<String, String>> findSubjects(String searchString) throws InternalErrorException {\n\t\treturn findSubjects(searchString, 0);\n\t}\n\n\t@Override\n\tpublic List<Map<String, String>> findSubjects(String searchString, int maxResults) throws InternalErrorException {\n\t\t// We can call original implementation, since LDAP always return whole entry and not just login\n\t\treturn findSubjectsLogins(searchString, maxResults);\n\t}\n\n\tprotected Map<String,String> getAttributes() throws InternalErrorException {\n\t\treturn perunBl.getExtSourcesManagerBl().getAttributes(this);\n\t}\n\n}\n", "package cz.metacentrum.perun.core.impl;\n\nimport com.zaxxer.hikari.HikariDataSource;\nimport cz.metacentrum.perun.core.api.Attribute;\nimport cz.metacentrum.perun.core.api.AttributeDefinition;\nimport cz.metacentrum.perun.core.api.BeansUtils;\nimport cz.metacentrum.perun.core.api.Destination;\nimport cz.metacentrum.perun.core.api.ExtSource;\nimport cz.metacentrum.perun.core.api.Member;\nimport cz.metacentrum.perun.core.api.Pair;\nimport cz.metacentrum.perun.core.api.PerunSession;\nimport cz.metacentrum.perun.core.api.User;\nimport cz.metacentrum.perun.core.api.UserExtSource;\nimport cz.metacentrum.perun.core.api.exceptions.AttributeNotExistsException;\nimport cz.metacentrum.perun.core.api.exceptions.ConsistencyErrorException;\nimport cz.metacentrum.perun.core.api.exceptions.DiacriticNotAllowedException;\nimport cz.metacentrum.perun.core.api.exceptions.ExtSourceExistsException;\nimport cz.metacentrum.perun.core.api.exceptions.ExtSourceNotExistsException;\nimport cz.metacentrum.perun.core.api.exceptions.IllegalArgumentException;\nimport cz.metacentrum.perun.core.api.exceptions.InternalErrorException;\nimport cz.metacentrum.perun.core.api.exceptions.MaxSizeExceededException;\nimport cz.metacentrum.perun.core.api.exceptions.MemberNotExistsException;\nimport cz.metacentrum.perun.core.api.exceptions.MinSizeExceededException;\nimport cz.metacentrum.perun.core.api.exceptions.NumberNotInRangeException;\nimport cz.metacentrum.perun.core.api.exceptions.NumbersNotAllowedException;\nimport cz.metacentrum.perun.core.api.exceptions.ParseUserNameException;\nimport cz.metacentrum.perun.core.api.exceptions.ParserException;\nimport cz.metacentrum.perun.core.api.exceptions.PrivilegeException;\nimport cz.metacentrum.perun.core.api.exceptions.SpaceNotAllowedException;\nimport cz.metacentrum.perun.core.api.exceptions.SpecialCharsNotAllowedException;\nimport cz.metacentrum.perun.core.api.exceptions.UserNotExistsException;\nimport cz.metacentrum.perun.core.api.exceptions.WrongAttributeAssignmentException;\nimport cz.metacentrum.perun.core.api.exceptions.WrongPatternException;\nimport cz.metacentrum.perun.core.bl.PerunBl;\nimport cz.metacentrum.perun.core.blImpl.ModulesUtilsBlImpl;\nimport org.apache.commons.codec.binary.Base64;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.jdbc.core.RowMapper;\nimport org.springframework.mail.MailException;\nimport org.springframework.mail.SimpleMailMessage;\nimport org.springframework.mail.javamail.JavaMailSender;\nimport org.springframework.mail.javamail.JavaMailSenderImpl;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.Mac;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\nimport javax.sql.DataSource;\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.UnsupportedEncodingException;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.text.Normalizer;\nimport java.text.Normalizer.Form;\nimport java.text.StringCharacterIterator;\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.time.format.DateTimeFormatter;\nimport java.time.temporal.ChronoUnit;\nimport java.time.temporal.TemporalUnit;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.StringJoiner;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * Utilities.\n */\npublic class Utils {\n\n\tprivate final static Logger log = LoggerFactory.getLogger(Utils.class);\n\tpublic final static String configurationsLocations = \"/etc/perun/\";\n\tpublic static final String TITLE_BEFORE = \"titleBefore\";\n\tpublic static final String FIRST_NAME = \"firstName\";\n\tpublic static final String LAST_NAME = \"lastName\";\n\tpublic static final String TITLE_AFTER = \"titleAfter\";\n\tprivate static Properties properties;\n\tpublic static final Pattern emailPattern = Pattern.compile(\"^[-_A-Za-z0-9+']+(\\\\.[-_A-Za-z0-9+']+)*@[-A-Za-z0-9]+(\\\\.[-A-Za-z0-9]+)*(\\\\.[A-Za-z]{2,})$\");\n\n\tprivate static final Pattern titleBeforePattern = Pattern.compile(\"^(([\\\\p{L}]+[.])|(et))$\");\n\tprivate static final Pattern firstNamePattern = Pattern.compile(\"^[\\\\p{L}-']+$\");\n\tprivate static final Pattern lastNamePattern = Pattern.compile(\"^(([\\\\p{L}-']+)|([\\\\p{L}][.]))$\");\n\n\tprivate static final String userPhoneAttribute = \"urn:perun:user:attribute-def:def:phone\";\n\tprivate static final String memberPhoneAttribute = \"urn:perun:member:attribute-def:def:phone\";\n\n\t/**\n\t * Replaces dangerous characters.\n\t * Replaces : with - and spaces with _.\n\t *\n\t * @param str string to be normalized\n\t * @return normalized string\n\t */\n\tpublic static String normalizeString(String str) {\n\t\tlog.trace(\"Entering normalizeString: str='{}'\", str);\n\t\treturn str.replace(':', '-').replace(' ', '_');\n\t}\n\n\tpublic static <T> boolean hasDuplicate(List<T> all) {\n\t\tSet<T> set = new HashSet<>(all.size());\n\t\t// Set#add returns false if the set does not change, which\n\t\t// indicates that a duplicate element has been added.\n\t\tfor (T each: all) if (!set.add(each)) return true;\n\t\treturn false;\n\t}\n\n\t/**\n\t * Joins Strings or any objects into a String. Use as\n\t * <pre>\n\t *  List<?> list = Arrays.asList(\"a\", 1, 2.0);\n\t *  String s = join(list,\",\");\n\t * </pre>\n\t * @param collection anything Iterable, like a {@link java.util.List} or {@link java.util.Collection}\n\t * @param separator any separator, like a comma\n\t * @return string with string representations of objects joined by separators\n\t */\n\tpublic static String join(Iterable<?> collection, String separator) {\n\t\tIterator<?> oIter;\n\t\tif (collection == null || (!(oIter = collection.iterator()).hasNext()))\n\t\t\treturn \"\";\n\t\tStringBuilder oBuilder = new StringBuilder(String.valueOf(oIter.next()));\n\t\twhile (oIter.hasNext())\n\t\t\toBuilder.append(separator).append(oIter.next());\n\t\treturn oBuilder.toString();\n\t}\n\n\t/**\n\t * Returns additionalUserExtSources from the subject. It's used for synchronization from different ExtSources. subjectFromExtSource was obtained from the ExtSource.\n\t *\n\t * @param sess perun session\n\t * @param subjectFromExtSource map with the subject\n\t * @return List<UserExtSource> all additional ExtSources from the subject, returned list will never contain null value\n\t * @throws InternalErrorException\n\t */\n\tpublic static List<UserExtSource> extractAdditionalUserExtSources(PerunSession sess, Map<String, String> subjectFromExtSource) throws InternalErrorException {\n\t\tList<UserExtSource> additionalUserExtSources = new ArrayList<>();\n\t\tfor (String attrName : subjectFromExtSource.keySet()) {\n\t\t\tif(attrName != null &&\n\t\t\t\tsubjectFromExtSource.get(attrName) != null &&\n\t\t\t\tattrName.startsWith(ExtSourcesManagerImpl.USEREXTSOURCEMAPPING)) {\n\t\t\t\tString login = subjectFromExtSource.get(\"login\");\n\n\t\t\t\tString[] userExtSourceRaw =  subjectFromExtSource.get(attrName).split(\"\\\\|\"); // Entry contains extSourceName|extSourceType|extLogin[|LoA]\n\t\t\t\tlog.debug(\"Processing additionalUserExtSource {}\",  subjectFromExtSource.get(attrName));\n\n\t\t\t\t//Check if the array has at least 3 parts, this is protection against outOfBoundException\n\t\t\t\tif(userExtSourceRaw.length < 3) {\n\t\t\t\t\tthrow new InternalErrorException(\"There is a missing mandatory part of additional user extSource value when processing it - '\" + attrName + \"'\");\n\t\t\t\t}\n\n\t\t\t\tString additionalExtSourceName = userExtSourceRaw[0];\n\t\t\t\tString additionalExtSourceType = userExtSourceRaw[1];\n\t\t\t\tString additionalExtLogin = userExtSourceRaw[2];\n\t\t\t\tint additionalExtLoa = 0;\n\t\t\t\t// Loa is not mandatory argument\n\t\t\t\tif (userExtSourceRaw.length>3 && userExtSourceRaw[3] != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tadditionalExtLoa = Integer.parseInt(userExtSourceRaw[3]);\n\t\t\t\t\t} catch (NumberFormatException e) {\n\t\t\t\t\t\tthrow new ParserException(\"Subject with login [\" + login + \"] has wrong LoA '\" + userExtSourceRaw[3] + \"'.\", e, \"LoA\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tExtSource additionalExtSource;\n\n\t\t\t\tif (additionalExtSourceName == null || additionalExtSourceName.isEmpty() ||\n\t\t\t\t\tadditionalExtSourceType == null || additionalExtSourceType.isEmpty() ||\n\t\t\t\t\tadditionalExtLogin == null || additionalExtLogin.isEmpty()) {\n\t\t\t\t\tlog.error(\"User with login {} has invalid additional userExtSource defined {}.\", login, userExtSourceRaw);\n\t\t\t\t} else {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Try to get extSource, with full extSource object (containg ID)\n\t\t\t\t\t\tadditionalExtSource = ((PerunBl) sess.getPerun()).getExtSourcesManagerBl().getExtSourceByName(sess, additionalExtSourceName);\n\t\t\t\t\t} catch (ExtSourceNotExistsException e) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t// Create new one if not exists\n\t\t\t\t\t\t\tadditionalExtSource = new ExtSource(additionalExtSourceName, additionalExtSourceType);\n\t\t\t\t\t\t\tadditionalExtSource = ((PerunBl) sess.getPerun()).getExtSourcesManagerBl().createExtSource(sess, additionalExtSource, null);\n\t\t\t\t\t\t} catch (ExtSourceExistsException e1) {\n\t\t\t\t\t\t\tthrow new ConsistencyErrorException(\"Creating existing extSource: \" + additionalExtSourceName);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Add additional user extSource\n\t\t\t\t\tadditionalUserExtSources.add(new UserExtSource(additionalExtSource, additionalExtLoa, additionalExtLogin));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn additionalUserExtSources;\n\t}\n\n\t/**\n\t * Joins Strings or any objects into a String. Use as\n\t * <pre>\n\t *  String[] sa = { \"a\", \"b\", \"c\"};\n\t *  String s = join(list,\",\");\n\t * </pre>\n\t * @param objs array of objects\n\t * @param separator any separator, like a comma\n\t * @return string with string representations of objects joined by separators\n\t */\n\tpublic static String join(Object[] objs, String separator) {\n\t\tlog.trace(\"Entering join: objs='{}', separator='{}'\", objs, separator);\n\t\treturn join(Arrays.asList(objs),separator);\n\t}\n\n\t/**\n\t * Integer row mapper\n\t */\n\tpublic static final RowMapper<Integer> ID_MAPPER = (resultSet, i) -> resultSet.getInt(\"id\");\n\n\t/**\n\t * String row mapper\n\t */\n\tpublic static final RowMapper<String> STRING_MAPPER = (resultSet, i) -> resultSet.getString(\"value\");\n\n\t// FIXME prijde odstranit\n\tpublic static void checkPerunSession(PerunSession sess) throws InternalErrorException {\n\t\tnotNull(sess, \"sess\");\n\t}\n\n\t/**\n\t * Creates copy of given Map with Sets as values. The returned object contains a new Map\n\t * and new Sets, the {@link T} objects remain the same.\n\t *\n\t * @param original original Map\n\t * @param <T> parameter\n\t * @return new Map with new Sets as values\n\t */\n\tpublic static <T> Map<T, Set<T>> createDeepCopyOfMapWithSets(Map<T, Set<T>> original) {\n\t\tMap<T, Set<T>> copy = new HashMap<>();\n\t\tfor (T key : original.keySet()) {\n\t\t\tSet<T> setCopy = original.get(key) == null ? null : new HashSet<>(original.get(key));\n\t\t\tcopy.put(key, setCopy);\n\t\t}\n\t\treturn copy;\n\t}\n\n\t/**\n\t * Checks whether the object is null or not.\n\t *\n\t * @param e\n\t * @param name\n\t * @throws InternalErrorException which wraps NullPointerException\n\t */\n\tpublic static void notNull(Object e, String name) throws InternalErrorException {\n\t\tif(e == null){\n\t\t\tthrow new InternalErrorException(new NullPointerException(\"'\" + name + \"' is null\"));\n\t\t}\n\t}\n\n\t/**\n\t * Throws a MinSizeExceededException if the given value does not specified minLength.\n\t * If the value is null then MinSizeExceededException is thrown as well.\n\t *\n\t * @param propertyName name of checked property\n\t * @param minLength minimal length\n\t * @throws MinSizeExceededException when length of actualValue is lower than minLength or null\n\t */\n\tpublic static void checkMinLength(String propertyName, String actualValue, int minLength) throws MinSizeExceededException {\n\t\tif (actualValue == null) {\n\t\t\tthrow new MinSizeExceededException(\"The property '\" + propertyName + \"' does not have a minimal length equal to '\" + minLength + \"' because it is null.\");\n\t\t}\n\t\tif (actualValue.length() < minLength) {\n\t\t\tthrow new MinSizeExceededException(\"Length of '\" + propertyName + \"' is too short! MinLength=\" + minLength + \", ActualLength=\" + actualValue.length());\n\t\t}\n\t}\n\n\t/**\n\t * Throws a MaxSizeExceededException if the given value is longer than maxLength.\n\t * If the value is null then nothing happens.\n\t *\n\t * @param propertyName name of checked property\n\t * @param maxLength max length\n\t * @throws MaxSizeExceededException when length of actualValue is higher than maxLength\n\t */\n\tpublic static void checkMaxLength(String propertyName, String actualValue, int maxLength) throws MaxSizeExceededException {\n\t\tif (actualValue == null) {\n\t\t\treturn;\n\t\t}\n\t\tif (actualValue.length() > maxLength) {\n\t\t\tthrow new MaxSizeExceededException(\"Length of '\" + propertyName + \"' is too long! MaxLength=\" + maxLength + \", ActualLength=\" + actualValue.length());\n\t\t}\n\t}\n\n\t/**\n\t * Define, if some entity contain a diacritic symbol.\n\t *\n\t * @param name name of entity\n\t * @throws DiacriticNotAllowedException\n\t */\n\tpublic static void checkWithoutDiacritic(String name) throws DiacriticNotAllowedException{\n\n\t\tif(!Normalizer.isNormalized(name, Form.NFKD))throw new DiacriticNotAllowedException(\"Name of the entity is not in the normalized form NFKD (diacritic not allowed)!\");\n\n\t}\n\n\t/**\n\t * Define, if some entity contain a special symbol\n\t * Special symbol is everything except - numbers, letters and space\n\t *\n\t * @param name name of entity\n\t * @throws SpecialCharsNotAllowedException\n\t */\n\tpublic static void checkWithoutSpecialChars(String name) throws SpecialCharsNotAllowedException{\n\n\t\tif(!name.matches(\"^[0-9 \\\\p{L}]*$\")) throw new SpecialCharsNotAllowedException(\"The special chars in the name of entity are not allowed!\");\n\t}\n\n\t/**\n\t * Define, if some entity contain a special symbol\n\t * Special symbol is everything except - numbers, letters and space (and allowedSpecialChars)\n\t * The allowedSpecialChars are on the end of regular expresion, so the same rule must be observed.\n\t * (example, symbol - must be on the end of string) rules are the same like in regular expresion\n\t *\n\t * @param name name of entity\n\t * @param allowedSpecialChars this String must contain only special chars which are allowed\n\t * @throws SpecialCharsNotAllowedException\n\t */\n\tpublic static void checkWithoutSpecialChars(String name, String allowedSpecialChars) throws SpecialCharsNotAllowedException{\n\n\t\tif(!name.matches(\"^([0-9 \\\\p{L}\" + allowedSpecialChars + \"])*$\")) throw new SpecialCharsNotAllowedException(\"The special chars (except \" + allowedSpecialChars + \") in the name of entity are not allowed!\");\n\t}\n\n\t/**\n\t * Define, if some entity contain a number\n\t *\n\t * @param name\n\t * @throws NumbersNotAllowedException\n\t */\n\tpublic static void checkWithoutNumbers(String name) throws NumbersNotAllowedException{\n\n\t\tif(!name.matches(\"^([^0-9])*$\")) throw new NumbersNotAllowedException(\"The numbers in the name of entity are not allowed!\");\n\t}\n\n\t/**\n\t * Define, if some entity contain a space\n\t *\n\t * @param name\n\t * @throws SpaceNotAllowedException\n\t */\n\tpublic static void checkWithoutSpaces(String name)throws SpaceNotAllowedException{\n\n\t\tif(name.contains(\" \")) throw new SpaceNotAllowedException(\"The spaces in the name of entity are not allowed!\");\n\t}\n\n\t/**\n\t * Define, if some number is in range.\n\t * Example: number 4 is in range 4 - 12, number 3 is not\n\t *\n\t * @param number\n\t * @param lowestValue\n\t * @param highestValue\n\t * @throws NumberNotInRangeException\n\t */\n\tpublic static void checkRangeOfNumbers(int number, int lowestValue, int highestValue) throws NumberNotInRangeException {\n\n\t\tif(number<lowestValue || number>highestValue) throw new NumberNotInRangeException(\"Number is not in range, Lowest=\"+lowestValue+\" < Number=\"+number+\" < Highest=\"+highestValue);\n\t}\n\n\t/**\n\t * Gets the next number from the sequence. This function hides differences in the databases engines.\n\t *\n\t * @param jdbc\n\t * @param sequenceName\n\t * @return new ID\n\t * @throws InternalErrorException\n\t */\n\tpublic static int getNewId(JdbcTemplate jdbc, String sequenceName) throws InternalErrorException {\n\t\tString dbType;\n\t\tString url = \"\";\n\t\tString query;\n\t\t// try to deduce database type from jdbc connection metadata\n\t\ttry {\n\t\t\tDataSource ds = jdbc.getDataSource();\n\t\t\tif (ds instanceof HikariDataSource) {\n\t\t\t\turl = ((HikariDataSource) ds).getJdbcUrl();\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tlog.error(\"cannot get JDBC url\", e);\n\t\t}\n\n\t\tif (url.contains(\"hsqldb\")) {\n\t\t\tdbType = \"hsqldb\";\n\t\t} else if (url.contains(\"oracle\")) {\n\t\t\tdbType = \"oracle\";\n\t\t} else if (url.contains(\"postgresql\")) {\n\t\t\tdbType = \"postgresql\";\n\t\t} else {\n\t\t\tdbType = BeansUtils.getCoreConfig().getDbType();\n\t\t}\n\n\t\tswitch (dbType) {\n\t\t\tcase \"oracle\":\n\t\t\t\tquery = \"select \" + sequenceName + \".nextval from dual\";\n\t\t\t\tbreak;\n\t\t\tcase \"postgresql\":\n\t\t\t\tquery = \"select nextval('\" + sequenceName + \"')\";\n\t\t\t\tbreak;\n\t\t\tcase \"hsqldb\":\n\t\t\t\tquery = \"call next value for \" + sequenceName + \";\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new InternalErrorException(\"Unsupported DB type\");\n\t\t}\n\n\t\t// Decide which type of the JdbcTemplate is provided\n\t\ttry {\n\t\t\tInteger i = jdbc.queryForObject(query, Integer.class);\n\t\t\tif (i == null) {\n\t\t\t\tthrow new InternalErrorException(\"New ID should not be null.\");\n\t\t\t}\n\t\t\treturn i;\n\t\t} catch (RuntimeException e) {\n\t\t\tthrow new InternalErrorException(e);\n\t\t}\n\t}\n\n\t/**\n\t * Returns current time in millis. Result of this call can then be used by function getRunningTime().\n\t *\n\t * @return current time in millis.\n\t */\n\tpublic static long startTimer() {\n\t\treturn System.currentTimeMillis();\n\t}\n\n\t/**\n\t * Returns difference between startTime and current time in millis.\n\t *\n\t * @param startTime\n\t * @return difference between current time in millis and startTime.\n\t */\n\tpublic static long getRunningTime(long startTime) {\n\t\treturn System.currentTimeMillis()-startTime;\n\t}\n\n\n\t/**\n\t * Scans all classes accessible from the context class loader which belong to the given package and subpackages.\n\t *\n\t * @param packageName The base package\n\t * @return The classes\n\t * @throws ClassNotFoundException\n\t * @throws IOException\n\t */\n\tpublic static List<Class<?>> getClasses(String packageName) throws ClassNotFoundException, IOException {\n\t\tClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n\t\tassert classLoader != null;\n\t\tString path = packageName.replace('.', '/');\n\t\tEnumeration<URL> resources = classLoader.getResources(path);\n\t\tList<File> dirs = new ArrayList<>();\n\t\twhile (resources.hasMoreElements()) {\n\t\t\tURL resource = resources.nextElement();\n\t\t\tdirs.add(new File(resource.getFile()));\n\t\t}\n\t\tArrayList<Class<?>> classes = new ArrayList<>();\n\t\tfor (File directory : dirs) {\n\t\t\tclasses.addAll(findClasses(directory, packageName));\n\t\t}\n\t\treturn classes;\n\t}\n\n\tprivate static String limit(String s,int limit) {\n\t\tif(s==null) return null;\n\t\treturn s.length() > limit ? s.substring(0, limit) : s;\n\t}\n\n\tpublic static User createUserFromNameMap(Map<String, String> name) throws InternalErrorException {\n\t\tUser user = new User();\n\t\tif (name.get(FIRST_NAME) == null || name.get(LAST_NAME) == null || name.get(FIRST_NAME).isEmpty() || name.get(LAST_NAME).isEmpty()) {\n\t\t\tthrow new InternalErrorException(\"First name/last name is either empty or null when creating user\");\n\t\t}\n\t\tuser.setTitleBefore(limit(name.get(TITLE_BEFORE),40));\n\t\tuser.setFirstName(limit(name.get(FIRST_NAME),64));\n\t\tuser.setLastName(limit(name.get(LAST_NAME),64));\n\t\tuser.setTitleAfter(limit(name.get(TITLE_AFTER),40));\n\t\treturn user;\n\t}\n\n\t/**\n\t * Creates a new instance of User with names initialized from parsed rawName.\n\t * Imposes limit on leghts of fields.\n\t * @see #parseCommonName(String)\n\t * @param rawName raw name\n\t * @param fullNameRequired if true, throw exception if firstName or lastName is missing, do not throw exception otherwise\n\t * @return user\n\t */\n\tpublic static User parseUserFromCommonName(String rawName, boolean fullNameRequired) throws ParseUserNameException {\n\t\tMap<String, String> m = parseCommonName(rawName, fullNameRequired);\n\t\treturn createUserFromNameMap(m);\n\t}\n\n\t/**\n\t * @see Utils.parseCommonName(String rawName, boolean fullNameRequired) - where fullNameRequired is false\n\t */\n\tpublic static Map<String, String> parseCommonName(String rawName) {\n\t\ttry {\n\t\t\treturn Utils.parseCommonName(rawName, false);\n\t\t} catch (ParseUserNameException ex) {\n\t\t\tthrow new InternalErrorException(\"Unexpected behavior while parsing user name without full name requirement.\");\n\t\t}\n\t}\n\n\t/**\n\t * Try to parse rawName to keys: \"titleBefore\" \"firstName\" \"lastName\" \"titleAfter\"\n\t *\n\t * If rawName is null or empty, return map with empty values of all keys.\n\t *\n\t * Parsing procedure:\n\t * 1] prepare list of parts by replacing all characters \",\" and \"_\" by spaces\n\t * 2] change all sequence of invisible characters (space, tabulator etc.) to one space\n\t * 3] one by one try to parsing parts from the list\n\t *  - A] try to find all titleBefore parts\n\t *  - B] try to find one firstName part\n\t *  - C] try to find all lastName parts\n\t *  - D] if the rest is not lastName so save it to the title after\n\t *\n\t * Example of parsing rawName:\n\t * 1] rawName = \"Mgr. et Mgr.    Petr_Jiri R. Sojka, Ph.D., CSc.\"\n\t * 2] convert all ',' and '_' to spaces: rawName = \"Mgr. et Mgr.    Petr Jiri R. Sojka  Ph.D.  CSc.\"\n\t * 3] convert more than 1 invisible char to 1 space: rawName = \"Mgr. et Mgr. Petr Jiri R. Sojka Ph.D. CSc.\"\n\t * 4] parse string to list of parts by space: ListOfParts= [\"Mgr.\",\"et\",\"Mgr.\",\"Petr\",\"Jiri\",\"R.\",\"Sojka\",\"Ph.D.\",\"CSc.\"]\n\t * 5] first fill everything what can be in title before: titleBefore=\"Mgr. et Mgr.\"\n\t * 6] then fill everything what can be in first name (maximum 1 part): firstName=\"Petr\"\n\t * 7] then fill everything what can be in last name: lastName=\"Jiri R. Sojka\"\n\t * 8] everything else put to the title after: titleAfter=\"Ph.D. CSc.\"\n\t * 9] put these variables to map like key=value, for ex.: Map[titleBefore=\"Mgr. et Mgr.\",firstName=\"Petr\", ... ] and return this map\n\t *\n\t * @param rawName name to parse\n\t * @param fullNameRequired if true, throw exception if firstName or lastName is missing, do not throw exception otherwise\n\t * @return map string to string where are 4 keys (titleBefore,titleAfter,firstName and lastName) with their values (value can be null)\n\t * @throws ParseUserNameException when method was unable to parse both first name and last name from the rawName\n\t */\n\tpublic static Map<String, String> parseCommonName(String rawName, boolean fullNameRequired) throws ParseUserNameException {\n\t\t// prepare variables and result map\n\t\tMap<String, String> parsedName = new HashMap<>();\n\t\tString titleBefore = \"\";\n\t\tString firstName = \"\";\n\t\tString lastName = \"\";\n\t\tString titleAfter = \"\";\n\n\t\tif (rawName != null && !rawName.isEmpty()) {\n\t\t\t// replace all ',' and '_' characters for ' ' for rawName\n\t\t\trawName = rawName.replaceAll(\"[,_]\", \" \");\n\t\t\t// replace all invisible chars in row for ' '\n\t\t\trawName = rawName.replaceAll(\"\\\\s+\", \" \").trim();\n\n\t\t\t// split parts by space\n\t\t\tList<String> nameParts = new ArrayList<>(Arrays.asList(rawName.split(\" \")));\n\n\t\t\t// if length of nameParts is 1, save it to the lastName\n\t\t\tif(nameParts.size() == 1) {\n\t\t\t\tlastName = nameParts.get(0);\n\t\t\t\t// if length of nameParts is more than 1, try to choose which part belong to which value\n\t\t\t} else {\n\t\t\t\t// join title before name to single string with ' ' as delimiter\n\t\t\t\ttitleBefore = parsePartOfName(nameParts, new StringJoiner(\" \"), titleBeforePattern);\n\n\t\t\t\t// get first name as a next name part if pattern matches and nameParts are not empty\n\t\t\t\tif (!nameParts.isEmpty()) firstName = parsePartOfName(nameParts, new StringJoiner(\" \"), firstNamePattern);\n\n\t\t\t\t// join last names to single string with ' ' as delimiter\n\t\t\t\tif (!nameParts.isEmpty()) lastName = parsePartOfName(nameParts, new StringJoiner(\" \"), lastNamePattern);\n\n\t\t\t\t// if any nameParts are left join them to one string with ' ' as delimiter and assume they are titles after name\n\t\t\t\tif (!nameParts.isEmpty()) {\n\t\t\t\t\tStringJoiner titleAfterBuilder = new StringJoiner(\" \");\n\t\t\t\t\tfor (String namePart : nameParts) {\n\t\t\t\t\t\ttitleAfterBuilder.add(namePart);\n\t\t\t\t\t}\n\t\t\t\t\ttitleAfter = titleAfterBuilder.toString();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// add variables to map, empty string means null\n\t\tif (titleBefore.isEmpty()) titleBefore = null;\n\t\tparsedName.put(TITLE_BEFORE, titleBefore);\n\t\tif (firstName.isEmpty()) firstName = null;\n\t\tparsedName.put(FIRST_NAME, firstName);\n\t\tif (lastName.isEmpty()) lastName = null;\n\t\tparsedName.put(LAST_NAME, lastName);\n\t\tif (titleAfter.isEmpty()) titleAfter = null;\n\t\tparsedName.put(TITLE_AFTER, titleAfter);\n\n\t\tif(fullNameRequired) {\n\t\t\tif (parsedName.get(FIRST_NAME) == null)\n\t\t\t\tthrow new ParseUserNameException(\"Unable to parse first name from text.\", rawName);\n\t\t\tif (parsedName.get(LAST_NAME) == null)\n\t\t\t\tthrow new ParseUserNameException(\"Unable to parse last name from text.\", rawName);\n\t\t}\n\n\t\treturn parsedName;\n\t}\n\n\tprivate static String parsePartOfName(List<String> nameParts, StringJoiner result, Pattern pattern) {\n\t\tMatcher matcher = pattern.matcher(nameParts.get(0));\n\n\t\t// if the matcher does not match continue to the next part of the name\n\t\tif (!matcher.matches()) return result.toString();\n\n\t\tresult.add(nameParts.get(0));\n\t\tnameParts.remove(0);\n\t\t// when nameParts are depleted or firstName was found there is no reason to continue the recursion\n\t\tif (nameParts.isEmpty() || pattern.equals(firstNamePattern)) return result.toString();\n\n\t\t// continue the recursion to find the next part\n\t\treturn parsePartOfName(nameParts, result, pattern);\n\t}\n\n\t/**\n\t * Recursive method used to find all classes in a given directory and subdirs.\n\t *\n\t * @param directory   The base directory\n\t * @param packageName The package name for classes found inside the base directory\n\t * @return The classes\n\t * @throws ClassNotFoundException\n\t */\n\tprivate static List<Class<?>> findClasses(File directory, String packageName) throws ClassNotFoundException {\n\t\tList<Class<?>> classes = new ArrayList<>();\n\t\tif (!directory.exists()) {\n\t\t\treturn classes;\n\t\t}\n\t\tFile[] files = directory.listFiles();\n\t\tif (files != null) {\n\t\t\tfor (File file : files) {\n\t\t\t\tif (file.isDirectory()) {\n\t\t\t\t\tassert !file.getName().contains(\".\");\n\t\t\t\t\tclasses.addAll(findClasses(file, packageName + \".\" + file.getName()));\n\t\t\t\t} else if (file.getName().endsWith(\".class\")) {\n\t\t\t\t\tclasses.add(Class.forName(packageName + '.' + file.getName().substring(0, file.getName().length() - 6)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn classes;\n\t}\n\t/**\n\t * Return true, if char on position in text is escaped by '\\' Return false,\n\t * if not.\n\t *\n\t * @param text text in which will be searching\n\t * @param position position in text <0-text.length>\n\t * @return true if char is escaped, false if not\n\t */\n\tpublic static boolean isEscaped(String text, int position) {\n\t\tboolean escaped = false;\n\t\twhile (text.charAt(position) == '\\\\') {\n\t\t\tescaped = !escaped;\n\t\t\tposition--;\n\t\t\tif (position < 0) {\n\t\t\t\treturn escaped;\n\t\t\t}\n\t\t}\n\t\treturn escaped;\n\t}\n\n\t/**\n\t * Serialize map to string\n\t *\n\t * @param map\n\t * @return string of escaped map\n\t */\n\tpublic static String serializeMapToString(Map<String, String> map) {\n\t\tif(map == null) return \"\\\\0\";\n\t\tMap<String, String> attrNew = new HashMap<>(map);\n\t\tSet<String> keys = new HashSet<>(attrNew.keySet());\n\t\tfor(String s: keys) {\n\t\t\tattrNew.put(\"<\" + BeansUtils.createEscaping(s) + \">\", \"<\" + BeansUtils.createEscaping(attrNew.get(s)) + \">\");\n\t\t\tattrNew.remove(s);\n\t\t}\n\t\treturn attrNew.toString();\n\t}\n\n\tpublic static Attribute copyAttributeToViAttributeWithoutValue(Attribute copyFrom, Attribute copyTo) {\n\t\tcopyTo.setValueCreatedAt(copyFrom.getValueCreatedAt());\n\t\tcopyTo.setValueCreatedBy(copyFrom.getValueCreatedBy());\n\t\tcopyTo.setValueModifiedAt(copyFrom.getValueModifiedAt());\n\t\tcopyTo.setValueModifiedBy(copyFrom.getValueModifiedBy());\n\t\treturn copyTo;\n\t}\n\n\tpublic static Attribute copyAttributeToVirtualAttributeWithValue(Attribute copyFrom, Attribute copyTo) {\n\t\tcopyTo.setValue(copyFrom.getValue());\n\t\tcopyTo.setValueCreatedAt(copyFrom.getValueCreatedAt());\n\t\tcopyTo.setValueCreatedBy(copyFrom.getValueCreatedBy());\n\t\tcopyTo.setValueModifiedAt(copyFrom.getValueModifiedAt());\n\t\tcopyTo.setValueModifiedBy(copyFrom.getValueModifiedBy());\n\t\treturn copyTo;\n\t}\n\n\t/**\n\t * Method generates strings by pattern.\n\t * The pattern is string with square brackets, e.g. \"a[1-3]b\". Then the content of the brackets\n\t * is distributed, so the list is [a1b, a2b, a3c].\n\t * Multibrackets are aslo allowed. For example \"a[00-01]b[90-91]c\" generates [a00b90c, a00b91c, a01b90c, a01b91c].\n\t *\n\t * @param pattern\n\t * @return list of all generated strings\n\t */\n\tpublic static List<String> generateStringsByPattern(String pattern) throws WrongPatternException {\n\t\tList<String> result = new ArrayList<>();\n\n\t\t// get chars between the brackets\n\t\tList<String> values = new ArrayList<>(Arrays.asList(pattern.split(\"\\\\[[^]]*]\")));\n\t\t// get content of the brackets\n\t\tList<String> generators = new ArrayList<>();\n\t\tPattern generatorPattern = Pattern.compile(\"\\\\[([^]]*)]\");\n\t\tMatcher m = generatorPattern.matcher(pattern);\n\t\twhile (m.find()) {\n\t\t\tgenerators.add(m.group(1));\n\t\t}\n\n\t\t// if values strings contain square brackets, wrong syntax, abort\n\t\tfor (String value: values) {\n\t\t\tif (value.contains(\"]\") || (value.contains(\"[\"))) {\n\t\t\t\tthrow new WrongPatternException(\"The pattern \\\"\" + pattern + \"\\\" has a wrong syntax. Too much closing brackets.\");\n\t\t\t}\n\t\t}\n\n\t\t// if generators strings contain square brackets, wrong syntax, abort\n\t\tfor (String generator: generators) {\n\t\t\tif (generator.contains(\"]\") || (generator.contains(\"[\"))) {\n\t\t\t\tthrow new WrongPatternException(\"The pattern \\\"\" + pattern + \"\\\" has a wrong syntax. Too much opening brackets.\");\n\t\t\t}\n\t\t}\n\n\t\t// list, that contains list for each generator, with already generated numbers\n\t\tList<List<String>> listOfGenerated = new ArrayList<>();\n\n\t\tPattern rangePattern = Pattern.compile(\"^(\\\\d+)-(\\\\d+)$\");\n\t\tfor (String range: generators) {\n\t\t\tm = rangePattern.matcher(range);\n\t\t\tif (m.find()) {\n\t\t\t\tString start = m.group(1);\n\t\t\t\tString end = m.group(2);\n\t\t\t\tint startNumber;\n\t\t\t\tint endNumber;\n\t\t\t\ttry {\n\t\t\t\t\tstartNumber = Integer.parseInt(start);\n\t\t\t\t\tendNumber = Integer.parseInt(end);\n\t\t\t\t} catch (NumberFormatException ex) {\n\t\t\t\t\tthrow new WrongPatternException(\"The pattern \\\"\" + pattern + \"\\\" has a wrong syntax. Wrong format of the range.\");\n\t\t\t\t}\n\n\t\t\t\t// if end is before start -> abort\n\t\t\t\tif (startNumber > endNumber) {\n\t\t\t\t\tthrow new WrongPatternException(\"The pattern \\\"\" + pattern + \"\\\" has a wrong syntax. Start number has to be lower than end number.\");\n\n\t\t\t\t}\n\n\t\t\t\t// find out, how many zeros are before start number\n\t\t\t\tint zerosInStart = 0;\n\t\t\t\tint counter = 0;\n\t\t\t\twhile ( (start.charAt(counter) == '0') && (counter < start.length()-1) ) {\n\t\t\t\t\tzerosInStart++;\n\t\t\t\t\tcounter++;\n\t\t\t\t}\n\n\t\t\t\tString zeros = start.substring(0, zerosInStart);\n\t\t\t\tint oldNumberOfDigits = String.valueOf(startNumber).length();\n\n\t\t\t\t// list of already generated numbers\n\t\t\t\tList<String> generated = new ArrayList<>();\n\t\t\t\twhile (endNumber >= startNumber) {\n\t\t\t\t\t// keep right number of zeros before number\n\t\t\t\t\tif (String.valueOf(startNumber).length() == oldNumberOfDigits +1) {\n\t\t\t\t\t\tif (!zeros.isEmpty()) zeros = zeros.substring(1);\n\t\t\t\t\t}\n\t\t\t\t\tgenerated.add(zeros + startNumber);\n\t\t\t\t\toldNumberOfDigits = String.valueOf(startNumber).length();\n\t\t\t\t\tstartNumber++;\n\t\t\t\t}\n\n\t\t\t\tlistOfGenerated.add(generated);\n\n\t\t\t} else {\n\t\t\t\t// range is not in the format number-number -> abort\n\t\t\t\tthrow new WrongPatternException(\"The pattern \\\"\" + pattern + \"\\\" has a wrong syntax. The format numer-number not found.\");\n\t\t\t}\n\t\t}\n\n\t\t// add values among the generated numbers as one item lists\n\t\tList<List<String>> listOfGeneratorsAndValues = new ArrayList<>();\n\t\tint index = 0;\n\n\t\tfor (List<String> list : listOfGenerated) {\n\t\t\tif (index < values.size()) {\n\t\t\t\tList<String> listWithValue = new ArrayList<>();\n\t\t\t\tlistWithValue.add(values.get(index));\n\t\t\t\tlistOfGeneratorsAndValues.add(listWithValue);\n\t\t\t\tindex++;\n\t\t\t}\n\t\t\tlistOfGeneratorsAndValues.add(list);\n\t\t}\n\n\t\t// complete list with remaining values\n\t\tfor (int i = index; i < values.size(); i++) {\n\t\t\tList<String> listWithValue = new ArrayList<>();\n\t\t\tlistWithValue.add(values.get(i));\n\t\t\tlistOfGeneratorsAndValues.add(listWithValue);\n\t\t}\n\n\t\t// generate all posibilities\n\t\treturn getCombinationsOfLists(listOfGeneratorsAndValues);\n\t}\n\n\t/**\n\t * Method generates all combinations of joining of strings.\n\t * It respects given order of lists.\n\t * Example: input: [[a,b],[c,d]], output: [ac,ad,bc,bd]\n\t * @param lists list of lists, which will be joined\n\t * @return all joined strings\n\t */\n\tprivate static List<String> getCombinationsOfLists(List<List<String>> lists) {\n\t\tif (lists.isEmpty()) {\n\t\t\t// this should not happen\n\t\t\treturn new ArrayList<>();\n\t\t}\n\t\tif (lists.size() == 1) {\n\t\t\treturn lists.get(0);\n\t\t}\n\t\tList<String> result = new ArrayList<>();\n\n\t\tList<String> list = lists.remove(0);\n\t\t// get recursively all posibilities without first list\n\t\tList<String> posibilities = getCombinationsOfLists(lists);\n\n\t\t// join all strings from first list with the others\n\t\tfor (String item: list) {\n\t\t\tif (posibilities.isEmpty()) {\n\t\t\t\tresult.add(item);\n\t\t\t} else {\n\t\t\t\tfor (String itemToConcat : posibilities) {\n\t\t\t\t\tresult.add(item + itemToConcat);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Return encrypted version of input in UTF-8 by HmacSHA256\n\t *\n\t * @param input input to encrypt\n\t * @return encrypted value\n\t */\n\tpublic static String getMessageAuthenticationCode(String input) {\n\n\t\tif (input == null)\n\t\t\tthrow new NullPointerException(\"input must not be null\");\n\t\ttry {\n\t\t\tMac mac = Mac.getInstance(\"HmacSHA256\");\n\t\t\tmac.init(new SecretKeySpec(BeansUtils.getCoreConfig().getMailchangeSecretKey().getBytes(StandardCharsets.UTF_8),\"HmacSHA256\"));\n\t\t\tbyte[] macbytes = mac.doFinal(input.getBytes(StandardCharsets.UTF_8));\n\t\t\treturn new BigInteger(macbytes).toString(Character.MAX_RADIX);\n\t\t} catch (Exception e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\n\t}\n\n\t/**\n\t * Send validation email related to requested change of users preferred email.\n\t *\n\t * @param user user to change preferred email for\n\t * @param url base URL of running perun instance passed from RPC\n\t * @param email new email address to send notification to\n\t * @param changeId ID of change request in DB\n\t * @param subject Template subject or null\n\t * @param content Template message or null\n\t * @throws InternalErrorException\n\t */\n\tpublic static void sendValidationEmail(User user, String url, String email, int changeId, String subject, String content) throws InternalErrorException {\n\n\t\t// create mail sender\n\t\tJavaMailSenderImpl mailSender = new JavaMailSenderImpl();\n\t\tmailSender.setHost(\"localhost\");\n\n\t\t// create message\n\t\tSimpleMailMessage message = new SimpleMailMessage();\n\t\tmessage.setTo(email);\n\t\tmessage.setFrom(BeansUtils.getCoreConfig().getMailchangeBackupFrom());\n\n\t\tString instanceName = BeansUtils.getCoreConfig().getInstanceName();\n\n\t\tif (subject == null ||subject.isEmpty()) {\n\t\t\tmessage.setSubject(\"[\"+instanceName+\"] New email address verification\");\n\t\t} else {\n\t\t\tsubject = subject.replace(\"{instanceName}\", instanceName);\n\t\t\tmessage.setSubject(subject);\n\t\t}\n\n\t\t// get validation link params\n\t\tString i = Integer.toString(changeId, Character.MAX_RADIX);\n\t\tString m = Utils.getMessageAuthenticationCode(i);\n\n\t\ttry {\n\n\t\t\t// !! There is a hard-requirement for Perun instance\n\t\t\t// to host GUI on same server as RPC like: \"serverUrl/gui/\"\n\n\t\t\tURL urlObject = new URL(url);\n\n\t\t\t// use default if unknown rpc path\n\t\t\tString path = \"/gui/\";\n\n\t\t\tif (urlObject.getPath().contains(\"/krb/\")) {\n\t\t\t\tpath = \"/krb/gui/\";\n\t\t\t} else if (urlObject.getPath().contains(\"/fed/\")) {\n\t\t\t\tpath = \"/fed/gui/\";\n\t\t\t} else if (urlObject.getPath().contains(\"/cert/\")) {\n\t\t\t\tpath = \"/cert/gui/\";\n\t\t\t}\n\n\t\t\tStringBuilder link = new StringBuilder();\n\n\t\t\tlink.append(urlObject.getProtocol());\n\t\t\tlink.append(\"://\");\n\t\t\tlink.append(urlObject.getHost());\n\t\t\tlink.append(path);\n\t\t\tlink.append(\"?i=\");\n\t\t\tlink.append(URLEncoder.encode(i, \"UTF-8\"));\n\t\t\tlink.append(\"&m=\");\n\t\t\tlink.append(URLEncoder.encode(m, \"UTF-8\"));\n\t\t\tlink.append(\"&u=\" + user.getId());\n\n\t\t\t// Build message\n\t\t\tString text = \"Dear \"+user.getDisplayName()+\",\\n\\nWe've received request to change your preferred email address to: \"+email+\".\"+\n\t\t\t\t\t\"\\n\\nTo confirm this change please use link below:\\n\\n\"+link+\"\\n\\n\" +\n\t\t\t\t\t\"Message is automatically generated.\" +\n\t\t\t\t\t\"\\n----------------------------------------------------------------\" +\n\t\t\t\t\t\"\\nPerun - Identity & Access Management System\";\n\n\t\t\tif (content == null || content.isEmpty()) {\n\t\t\t\tmessage.setText(text);\n\t\t\t} else {\n\t\t\t\tcontent = content.replace(\"{link}\",link);\n\t\t\t\tmessage.setText(content);\n\t\t\t}\n\n\t\t\tmailSender.send(message);\n\n\t\t} catch (UnsupportedEncodingException ex) {\n\t\t\tthrow new InternalErrorException(\"Unable to encode validation URL for mail change.\", ex);\n\t\t} catch (MalformedURLException ex) {\n\t\t\tthrow new InternalErrorException(\"Not valid URL of running Perun instance.\", ex);\n\t\t}\n\n\t}\n\n\t/**\n\t * Sends email with link to non-authz password reset GUI where user\n\t * can reset forgotten password\n\t *\n\t * @param user user to send notification for\n\t * @param email user's email to send notification to\n\t * @param namespace namespace to reset password in\n\t * @param url base URL of Perun instance\n\t * @param id ID of pwd reset request\n\t * @param messageTemplate message of the email\n\t * @param subject subject of the email\n\t * @throws InternalErrorException\n\t */\n\tpublic static void sendPasswordResetEmail(User user, String email, String namespace, String url, int id, String messageTemplate, String subject) throws InternalErrorException {\n\n\t\t// create mail sender\n\t\tJavaMailSender mailSender = BeansUtils.getDefaultMailSender();\n\n\t\t// create message\n\t\tSimpleMailMessage message = new SimpleMailMessage();\n\t\tmessage.setTo(email);\n\t\tmessage.setFrom(BeansUtils.getCoreConfig().getMailchangeBackupFrom());\n\n\t\tString instanceName = BeansUtils.getCoreConfig().getInstanceName();\n\n\t\tif (subject == null) {\n\t\t\tmessage.setSubject(\"[\" + instanceName + \"] Password reset in namespace: \" + namespace);\n\t\t} else {\n\t\t\tsubject = subject.replace(\"{namespace}\", namespace);\n\t\t\tsubject = subject.replace(\"{instanceName}\", instanceName);\n\t\t\tmessage.setSubject(subject);\n\t\t}\n\n\t\t// get validation link params\n\t\tString i = cipherInput(String.valueOf(user.getId()), false);\n\t\tString m = cipherInput(String.valueOf(id), false);\n\n\t\ttry {\n\n\t\t\tURL urlObject = new URL(url);\n\n\t\t\tStringBuilder link = new StringBuilder();\n\n\t\t\tlink.append(urlObject.getProtocol());\n\t\t\tlink.append(\"://\");\n\t\t\tlink.append(urlObject.getHost());\n\t\t\t// reset link uses non-authz\n\t\t\tlink.append(\"/non/pwd-reset/\");\n\t\t\tlink.append(\"?i=\");\n\t\t\tlink.append(URLEncoder.encode(i, \"UTF-8\"));\n\t\t\tlink.append(\"&m=\");\n\t\t\tlink.append(URLEncoder.encode(m, \"UTF-8\"));\n\t\t\t// append login-namespace so GUI is themes and password checked by namespace rules\n\t\t\tlink.append(\"&login-namespace=\");\n\t\t\tlink.append(URLEncoder.encode(namespace, \"UTF-8\"));\n\n\t\t\t//validity formatting\n\t\t\tString validity = Integer.toString(BeansUtils.getCoreConfig().getPwdresetValidationWindow());\n\t\t\tDateTimeFormatter dtf = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\");\n\t\t\tLocalDateTime localDateTime = LocalDateTime.now().plusHours(Integer.parseInt(validity));\n\t\t\tString validityFormatted = dtf.format(localDateTime);\n\n\t\t\t// Build message en\n\t\t\tString textEn = \"Dear \" + user.getDisplayName() + \",\\n\\nWe've received request to reset your password in namespace \\\"\" + namespace + \"\\\".\" +\n\t\t\t\t\t\"\\n\\nPlease visit the link below, where you can set new password:\\n\\n\" + link + \"\\n\\n\" +\n\t\t\t\t\t\"Link is valid till \" + validityFormatted + \"\\n\\n\" +\n\t\t\t\t\t\"Message is automatically generated.\" +\n\t\t\t\t\t\"\\n----------------------------------------------------------------\" +\n\t\t\t\t\t\"\\nPerun - Identity & Access Management System\";\n\n\n\t\t\tif (messageTemplate == null) {\n\t\t\t\tmessage.setText(textEn);\n\t\t\t} else {\n\n\t\t\t\t// allow enforcing per-language links\n\t\t\t\tif (messageTemplate.contains(\"{link-\")) {\n\t\t\t\t\tPattern pattern = Pattern.compile(\"\\\\{link-[^}]+}\");\n\t\t\t\t\tMatcher matcher = pattern.matcher(messageTemplate);\n\t\t\t\t\twhile (matcher.find()) {\n\n\t\t\t\t\t\t// whole \"{link-something}\"\n\t\t\t\t\t\tString toSubstitute = matcher.group(0);\n\t\t\t\t\t\tString langLink = link.toString();\n\n\t\t\t\t\t\tPattern namespacePattern = Pattern.compile(\"-(.*?)}\");\n\t\t\t\t\t\tMatcher m2 = namespacePattern.matcher(toSubstitute);\n\t\t\t\t\t\tif (m2.find()) {\n\t\t\t\t\t\t\t// only language \"cs\", \"en\",...\n\t\t\t\t\t\t\tString lang = m2.group(1);\n\t\t\t\t\t\t\tlangLink = langLink + \"&locale=\" + lang;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmessageTemplate = messageTemplate.replace(toSubstitute, langLink);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmessageTemplate = messageTemplate.replace(\"{link}\", link);\n\t\t\t\t}\n\t\t\t\tmessageTemplate = messageTemplate.replace(\"{displayName}\", user.getDisplayName());\n\t\t\t\tmessageTemplate = messageTemplate.replace(\"{namespace}\", namespace);\n\t\t\t\tmessageTemplate = messageTemplate.replace(\"{validity}\", validityFormatted);\n\t\t\t\tmessage.setText(messageTemplate);\n\t\t\t}\n\n\t\t\tmailSender.send(message);\n\n\t\t} catch (MailException ex) {\n\t\t\tthrow new InternalErrorException(\"Unable to send mail for password reset.\", ex);\n\t\t} catch (UnsupportedEncodingException ex) {\n\t\t\tthrow new InternalErrorException(\"Unable to encode URL for password reset.\", ex);\n\t\t} catch (MalformedURLException ex) {\n\t\t\tthrow new InternalErrorException(\"Not valid URL of running Perun instance.\", ex);\n\t\t}\n\n\t}\n\n\t/**\n\t * Sends email to user confirming his password was changed.\n\t *\n\t * @param user user to send notification for\n\t * @param email user's email to send notification to\n\t * @param namespace namespace the password was re-set\n\t * @param login login of user\n\t * @param subject Subject from template or null\n\t * @param content Message from template or null\n\t */\n\tpublic static void sendPasswordResetConfirmationEmail(User user, String email, String namespace, String login, String subject, String content) {\n\n\t\t// create mail sender\n\t\tJavaMailSender mailSender = BeansUtils.getDefaultMailSender();\n\n\t\t// create message\n\t\tSimpleMailMessage message = new SimpleMailMessage();\n\t\tmessage.setTo(email);\n\t\tmessage.setFrom(BeansUtils.getCoreConfig().getMailchangeBackupFrom());\n\n\t\tString instanceName = BeansUtils.getCoreConfig().getInstanceName();\n\n\t\tif (subject == null || subject.isEmpty()) {\n\t\t\tmessage.setSubject(\"[\"+instanceName+\"] Password reset in namespace: \"+namespace);\n\t\t} else {\n\t\t\tsubject = subject.replace(\"{namespace}\", namespace);\n\t\t\tsubject = subject.replace(\"{instanceName}\", instanceName);\n\t\t\tmessage.setSubject(subject);\n\t\t}\n\n\t\t// Build message\n\t\tString text = \"Dear \"+user.getDisplayName()+\",\\n\\nyour password in namespace \\\"\"+namespace+\"\\\" was successfully reset.\"+\n\t\t\t\t\"\\n\\nThis message is automatically sent to all your email addresses registered in \"+instanceName+\" in order to prevent malicious password reset without your knowledge.\\n\\n\" +\n\t\t\t\t\"If you didn't request / perform password reset, please notify your administrators and support at \"+BeansUtils.getCoreConfig().getMailchangeBackupFrom()+\" to resolve this security issue.\\n\\n\" +\n\t\t\t\t\"Message is automatically generated.\" +\n\t\t\t\t\"\\n----------------------------------------------------------------\" +\n\t\t\t\t\"\\nPerun - Identity & Access Management System\";\n\n\t\tif (content == null || content.isEmpty()) {\n\t\t\tmessage.setText(text);\n\t\t} else {\n\t\t\tcontent = content.replace(\"{displayName}\", user.getDisplayName());\n\t\t\tcontent = content.replace(\"{namespace}\", namespace);\n\t\t\tcontent = content.replace(\"{login}\", login);\n\t\t\tcontent = content.replace(\"{instanceName}\", instanceName);\n\t\t\tmessage.setText(content);\n\t\t}\n\n\t\tmailSender.send(message);\n\n\t}\n\n\t/**\n\t * Return en/decrypted version of input using AES/CBC/PKCS5PADDING cipher.\n\t * Perun's internal secretKey and initVector are used (you can configure them in\n\t * perun.properties file).\n\t *\n\t * @param plainText text to en/decrypt\n\t * @param decrypt TRUE = decrypt input / FALSE = encrypt input\n\t * @return en/decrypted text\n\t * @throws cz.metacentrum.perun.core.api.exceptions.InternalErrorException if anything fails\n\t */\n\tpublic static String cipherInput(String plainText, boolean decrypt) throws InternalErrorException {\n\n\t\ttry {\n\n\t\t\tString encryptionKey = BeansUtils.getCoreConfig().getPwdresetSecretKey();\n\t\t\tString initVector = BeansUtils.getCoreConfig().getPwdresetInitVector();\n\n\t\t\tCipher c = Cipher.getInstance(\"AES/CBC/PKCS5PADDING\");\n\t\t\tSecretKeySpec k = new SecretKeySpec(encryptionKey.getBytes(StandardCharsets.UTF_8), \"AES\");\n\t\t\tc.init((decrypt) ? Cipher.DECRYPT_MODE : Cipher.ENCRYPT_MODE, k, new IvParameterSpec(initVector.getBytes(StandardCharsets.UTF_8)));\n\n\t\t\tif (decrypt) {\n\n\t\t\t\tbyte[] bytes = Base64.decodeBase64(plainText.getBytes(StandardCharsets.UTF_8));\n\t\t\t\treturn new String(c.doFinal(bytes), StandardCharsets.UTF_8);\n\n\t\t\t} else {\n\n\t\t\t\tbyte[] bytes = Base64.encodeBase64(c.doFinal(plainText.getBytes(StandardCharsets.UTF_8)));\n\t\t\t\treturn new String(bytes, StandardCharsets.UTF_8);\n\n\t\t\t}\n\n\t\t} catch (Exception ex) {\n\n\t\t\tthrow new InternalErrorException(\"Error when encrypting message\", ex);\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Checks whether the destination is not null and is of the right type.\n\t *\n\t * @param destination destination to check\n\t * @throws cz.metacentrum.perun.core.api.exceptions.InternalErrorException if destination is null\n\t * @throws cz.metacentrum.perun.core.api.exceptions.WrongPatternException if destination is not of the right type\n\t */\n\tpublic static void checkDestinationType(Destination destination) throws InternalErrorException, WrongPatternException  {\n\t\tif (destination == null) {\n\t\t\tthrow new InternalErrorException(\"Destination is null.\");\n\t\t}\n\t\tString destinationType = destination.getType();\n\t\tif ((!Objects.equals(destinationType, Destination.DESTINATIONHOSTTYPE)\n\t\t\t\t&& (!Objects.equals(destinationType, Destination.DESTINATIONEMAILTYPE))\n\t\t\t\t&& (!Objects.equals(destinationType, Destination.DESTINATIONSEMAILTYPE))\n\t\t\t\t&& (!Objects.equals(destinationType, Destination.DESTINATIONURLTYPE))\n\t\t\t\t&& (!Objects.equals(destinationType, Destination.DESTINATIONUSERHOSTTYPE))\n\t\t\t\t&& (!Objects.equals(destinationType, Destination.DESTINATIONUSERHOSTPORTTYPE))\n\t\t\t\t&& (!Objects.equals(destinationType, Destination.DESTINATIONSERVICESPECIFICTYPE))\n\t\t\t\t&& (!Objects.equals(destinationType, Destination.DESTINATIONWINDOWS))\n\t\t\t\t&& (!Objects.equals(destinationType, Destination.DESTINATIONWINDOWSPROXY)))) {\n\t\t\tthrow new WrongPatternException(\"Destination type \" + destinationType + \" is not supported.\");\n\t\t}\n\t}\n\n\t/**\n\t * Sends SMS to the phone number of a user with the given message.\n\t * The phone number is taken from the user attribute urn:perun:user:attribute-def:def:phone.\n\t *\n\t * @param sess session\n\t * @param user receiver of the message\n\t * @param message sms message to send\n\t * @throws InternalErrorException when the attribute value cannot be found or is broken\n\t * @throws cz.metacentrum.perun.core.api.exceptions.PrivilegeException when the actor has not right to get the attribute\n\t * @throws cz.metacentrum.perun.core.api.exceptions.UserNotExistsException when given user does not exist\n\t */\n\tpublic static void sendSMS(PerunSession sess, User user, String message) throws InternalErrorException, PrivilegeException, UserNotExistsException {\n\t\tif (user == null) {\n\t\t\tthrow new cz.metacentrum.perun.core.api.exceptions.IllegalArgumentException(\"user is null\");\n\t\t}\n\t\tif (message == null) {\n\t\t\tthrow new cz.metacentrum.perun.core.api.exceptions.IllegalArgumentException(\"message is null\");\n\t\t}\n\t\tString telNumber;\n\t\ttry {\n\t\t\ttelNumber = (String) sess.getPerun().getAttributesManager().getAttribute(sess, user, userPhoneAttribute).getValue();\n\t\t} catch (AttributeNotExistsException ex ) {\n\t\t\tlog.error(\"Sendig SMS with text \\\"{}\\\" to user {} failed: cannot get tel. number.\", message, user );\n\t\t\tthrow new InternalErrorException(\"The attribute \" + userPhoneAttribute + \" has not been found.\", ex);\n\t\t} catch (WrongAttributeAssignmentException ex) {\n\t\t\tlog.error(\"Sendig SMS with text \\\"{}\\\" to user {} failed: cannot get tel. number.\", message, user );\n\t\t\tthrow new InternalErrorException(\"The attribute \" + userPhoneAttribute + \" has not been found in user attributes.\", ex);\n\t\t}\n\t\tsendSMS(telNumber, message);\n\t}\n\n\t/**\n\t * Sends SMS to the phone number of a member with the given message.\n\t * The phone number is taken from the user attribute urn:perun:member:attribute-def:def:phone.\n\t *\n\t * @param sess session\n\t * @param member receiver of the message\n\t * @param message sms message to send\n\t * @throws InternalErrorException when the attribute value cannot be found or is broken\n\t * @throws cz.metacentrum.perun.core.api.exceptions.PrivilegeException when the actor has not right to get the attribute\n\t * @throws cz.metacentrum.perun.core.api.exceptions.MemberNotExistsException when given member does not exist\n\t */\n\tpublic static void sendSMS(PerunSession sess, Member member, String message) throws InternalErrorException, PrivilegeException, MemberNotExistsException {\n\t\tString telNumber;\n\t\ttry {\n\t\t\ttelNumber = (String) sess.getPerun().getAttributesManager().getAttribute(sess, member, memberPhoneAttribute).getValue();\n\t\t} catch (AttributeNotExistsException ex) {\n\t\t\tlog.error(\"Sendig SMS with text \\\"{}\\\" to member {} failed: cannot get tel. number.\", message, member );\n\t\t\tthrow new InternalErrorException(\"The attribute \" + memberPhoneAttribute + \" has not been found.\", ex);\n\t\t} catch (WrongAttributeAssignmentException ex) {\n\t\t\tlog.error(\"Sendig SMS with text \\\"{}\\\" to member {} failed: cannot get tel. number.\", message, member );\n\t\t\tthrow new InternalErrorException(\"The attribute \" + memberPhoneAttribute + \" has not been found in user attributes.\", ex);\n\t\t}\n\t\tsendSMS(telNumber, message);\n\t}\n\n\t/**\n\t * Sends SMS to the phone number with the given message.\n\t * The sending provides external program for sending sms.\n\t * Its path is saved in the perun property perun.sms.program.\n\t *\n\t * @param telNumber phone number of the receiver\n\t * @param message sms message to send\n\t * @throws InternalErrorException when there is something wrong with external program\n\t * @throws IllegalArgumentException when the phone or message has a wrong format\n\t */\n\tpublic static void sendSMS(String telNumber, String message) throws InternalErrorException {\n\t\tlog.debug(\"Sending SMS with text \\\"{}\\\" to tel. number {}.\", message, telNumber);\n\n\t\ttry {\n\t\t\t// create properties list\n\t\t\tList<String> processProperties = new ArrayList<>();\n\t\t\t// pass the location of external program for sending sms\n\t\t\tprocessProperties.add(BeansUtils.getCoreConfig().getSmsProgram());\n\t\t\t// pass program options\n\t\t\tprocessProperties.add(\"-p\");\n\t\t\tprocessProperties.add(telNumber);\n\t\t\tprocessProperties.add(\"-m\");\n\t\t\tprocessProperties.add(message);\n\t\t\t// execute\n\t\t\tProcessBuilder pb = new ProcessBuilder(processProperties);\n\t\t\tProcess process;\n\t\t\tprocess = pb.start();\n\t\t\tint exitValue;\n\t\t\ttry {\n\t\t\t\texitValue = process.waitFor();\n\t\t\t} catch (InterruptedException ex) {\n\t\t\t\tString errMsg = \"The external process for sending sms was interrupted.\";\n\t\t\t\tlog.error(\"Sending SMS with text \\\"{}\\\" to tel. number {} failed.\", message, telNumber);\n\t\t\t\tthrow new InternalErrorException(errMsg, ex);\n\t\t\t}\n\n\t\t\t// handle response\n\t\t\tif (exitValue == 0) {\n\t\t\t\t// successful\n\t\t\t\tlog.debug(\"SMS with text \\\"{}\\\" to tel. number {} successfully sent.\", message, telNumber);\n\t\t\t} else if ((exitValue == 1) || (exitValue == 2)) {\n\t\t\t\t// users fault\n\t\t\t\tString errMsg = getStringFromInputStream(process.getErrorStream());\n\t\t\t\tlog.error(\"Sending SMS with text \\\"{}\\\" to tel. number {} failed.\", message, telNumber);\n\t\t\t\tthrow new cz.metacentrum.perun.core.api.exceptions.IllegalArgumentException(errMsg);\n\t\t\t} else if (exitValue > 2) {\n\t\t\t\t// internal fault\n\t\t\t\tString errMsg = getStringFromInputStream(process.getErrorStream());\n\t\t\t\tlog.error(\"Sending SMS with text \\\"{}\\\" to tel. number {} failed.\", message, telNumber);\n\t\t\t\tthrow new InternalErrorException(errMsg);\n\t\t\t}\n\n\t\t} catch (IOException ex) {\n\t\t\tlog.warn(\"Sending SMS with text \\\"{}\\\" to tel. number {} failed.\", message, telNumber);\n\t\t\tthrow new InternalErrorException(\"Cannot access the sms external application.\", ex);\n\t\t}\n\n\t}\n\n\t/**\n\t * Get BigDecimal number like '1024' in Bytes and create better readable\n\t * String with metric value like '1K' where K means KiloBytes.\n\t *\n\t * Use M,G,T,P,E like multipliers of 1024.\n\t *\n\t * If quota is not dividable by 1024 use B (Bytes) without dividing.\n\t *\n\t * @param quota in big natural number\n\t * @return string with number and metric\n\t */\n\tpublic static String bigDecimalBytesToReadableStringWithMetric(BigDecimal quota) throws InternalErrorException {\n\t\tif(quota == null) throw new InternalErrorException(\"Quota in BigDecimal can't be null if we want to convert it to number with metric.\");\n\t\t//Prepare variable for result\n\t\tString stringWithMetric;\n\t\t//Try to divide quota to get result module 1024^x = 0 where X is in [K-0,M-1,G-2,T-3,P-4,E-5]\n\t\t//If module is bigger than 0, try x-1\n\t\tif(!quota.divide(BigDecimal.valueOf(ModulesUtilsBlImpl.E)).stripTrailingZeros().toPlainString().contains(\".\")) {\n\t\t\t//divide by 1024^5\n\t\t\tstringWithMetric = quota.divide(BigDecimal.valueOf(ModulesUtilsBlImpl.E)).stripTrailingZeros().toPlainString() + \"E\";\n\t\t} else if(!quota.divide(BigDecimal.valueOf(ModulesUtilsBlImpl.P)).stripTrailingZeros().toPlainString().contains(\".\")) {\n\t\t\t//divide by 1024^4\n\t\t\tstringWithMetric = quota.divide(BigDecimal.valueOf(ModulesUtilsBlImpl.P)).stripTrailingZeros().toPlainString() + \"P\";\n\t\t} else if(!quota.divide(BigDecimal.valueOf(ModulesUtilsBlImpl.T)).stripTrailingZeros().toPlainString().contains(\".\")) {\n\t\t\t//divide by 1024^3\n\t\t\tstringWithMetric = quota.divide(BigDecimal.valueOf(ModulesUtilsBlImpl.T)).stripTrailingZeros().toPlainString() + \"T\";\n\t\t} else if(!quota.divide(BigDecimal.valueOf(ModulesUtilsBlImpl.G)).stripTrailingZeros().toPlainString().contains(\".\")) {\n\t\t\t//divide by 1024^2\n\t\t\tstringWithMetric = quota.divide(BigDecimal.valueOf(ModulesUtilsBlImpl.G)).stripTrailingZeros().toPlainString() + \"G\";\n\t\t} else if(!quota.divide(BigDecimal.valueOf(ModulesUtilsBlImpl.M)).stripTrailingZeros().toPlainString().contains(\".\")) {\n\t\t\t//divide by 1024^1\n\t\t\tstringWithMetric = quota.divide(BigDecimal.valueOf(ModulesUtilsBlImpl.M)).stripTrailingZeros().toPlainString() + \"M\";\n\t\t} else {\n\t\t\t//can't be diveded by 1024^x where x>0 so let it be in the format like it already is, convert it to BigInteger without fractional part\n\t\t\tstringWithMetric = quota.toBigInteger().toString() + \"K\";\n\t\t}\n\t\t//return result format with metric\n\t\treturn stringWithMetric;\n\t}\n\n\tprivate static String getStringFromInputStream(InputStream is) throws IOException {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(is));\n\t\tStringBuilder out = new StringBuilder();\n\t\tString line;\n\t\twhile ((line = reader.readLine()) != null) {\n\t\t\tout.append(line);\n\t\t}\n\t\treturn out.toString();\n\t}\n\n\t/**\n\t * IMPORTANT: this method not convert utf to ascii, just try to convert some problematic\n\t * chars to UTF and others change to '?'!!!\n\t *\n\t * @param s\n\t * @return converted string from ascii to something near utf\n\t */\n\tpublic synchronized static String utftoasci(String s){\n\t\tfinal StringBuilder sb = new StringBuilder( s.length() * 2 );\n\n\t\tfinal StringCharacterIterator iterator = new StringCharacterIterator( s );\n\n\t\tchar ch = iterator.current();\n\n\t\twhile( ch != StringCharacterIterator.DONE ){\n\t\t\tif(Character.getNumericValue(ch)>=0){\n\t\t\t\tsb.append( ch );\n\t\t\t}else{\n\t\t\t\tboolean f=false;\n\t\t\t\tif(Character.toString(ch).equals(\"\u00ca\")){sb.append(\"E\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u00c8\")){sb.append(\"E\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u00eb\")){sb.append(\"e\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u00e9\")){sb.append(\"e\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u00e8\")){sb.append(\"e\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u00c2\")){sb.append(\"A\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u00e4\")){sb.append(\"a\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u00df\")){sb.append(\"ss\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u00c7\")){sb.append(\"C\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u00d6\")){sb.append(\"O\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u00ba\")){sb.append(\"\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u00aa\")){sb.append(\"\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u00ba\")){sb.append(\"\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u00d1\")){sb.append(\"N\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u00c9\")){sb.append(\"E\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u00c4\")){sb.append(\"A\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u00c5\")){sb.append(\"A\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u00dc\")){sb.append(\"U\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u00f6\")){sb.append(\"o\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u00fc\")){sb.append(\"u\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u00e1\")){sb.append(\"a\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u00d3\")){sb.append(\"O\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u011b\")){sb.append(\"e\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u011a\")){sb.append(\"E\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u0161\")){sb.append(\"s\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u0160\")){sb.append(\"S\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u010d\")){sb.append(\"c\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u010c\")){sb.append(\"C\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u0159\")){sb.append(\"r\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u0158\")){sb.append(\"R\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u017e\")){sb.append(\"z\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u017d\")){sb.append(\"Z\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u00fd\")){sb.append(\"y\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u00dd\")){sb.append(\"Y\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u00ed\")){sb.append(\"i\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u00cd\")){sb.append(\"I\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u00f3\")){sb.append(\"o\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u00fa\")){sb.append(\"u\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u00da\")){sb.append(\"u\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u016f\")){sb.append(\"u\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u016e\")){sb.append(\"U\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u0147\")){sb.append(\"N\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u0148\")){sb.append(\"n\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u0164\")){sb.append(\"T\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u0165\")){sb.append(\"t\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\" \")){sb.append(\" \");f=true;}\n\n\t\t\t\tif(!f){\n\t\t\t\t\tsb.append(\"?\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tch = iterator.next();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\t/**\n\t * Convert input string (expected UTF-8) to ASCII if possible.\n\t * Any non-ASCII character is replaced by replacement parameter.\n\t *\n\t * @param input String to convert from UTF-8 to ASCII.\n\t * @param replacement Replacement character used for all non-ASCII chars in input.\n\t * @return converted string from ascii to something near utf\n\t */\n\tpublic synchronized static String toASCII(String input, Character replacement) {\n\n\t\tString normalizedOutput = \"\";\n\n\t\t// take unicode characters one by one and normalize them\n\t\tfor ( int i=0; i<input.length(); i++ ) {\n\t\t\tchar c = input.charAt(i);\n\t\t\t// normalize a single unicode character, then remove every non-ascii symbol (like accents)\n\t\t\tString normalizedChar = Normalizer.normalize(String.valueOf(c) , Normalizer.Form.NFD).replaceAll(\"[^\\\\p{ASCII}]\", \"\");\n\n\t\t\tif ( ! normalizedChar.isEmpty() ) {\n\t\t\t\t// if there is a valid ascii representation, use it\n\t\t\t\tnormalizedOutput += normalizedChar;\n\t\t\t} else {\n\t\t\t\t// otherwise replace character with an \"replacement\"\n\t\t\t\tnormalizedOutput += replacement;\n\t\t\t}\n\t\t}\n\t\treturn normalizedOutput;\n\n\t}\n\n\t/**\n\t * Determine if attribute is large (can contain value over 4kb).\n\t *\n\t * @param sess perun session\n\t * @param attribute attribute to be checked\n\t * @return true if the attribute is large\n\t */\n\tpublic static boolean isLargeAttribute(PerunSession sess, AttributeDefinition attribute) {\n\t\treturn (attribute.getType().equals(LinkedHashMap.class.getName()) ||\n\t\t\t\tattribute.getType().equals(BeansUtils.largeStringClassName) ||\n\t\t\t\tattribute.getType().equals(BeansUtils.largeArrayListClassName));\n\t}\n\n\t/**\n\t * Extends given date by given period.\n\t *\n\t * @param localDate date to be extended\n\t * @param period period used to extend date\n\t * @throws InternalErrorException when the period has wrong format,\n\t * allowed format is given by regex \"\\\\+([0-9]+)([dmy]?)\"\n\t */\n\tpublic static LocalDate extendDateByPeriod(LocalDate localDate, String period) throws InternalErrorException {\n\t\t// We will add days/months/years\n\t\tPattern p = Pattern.compile(\"\\\\+([0-9]+)([dmy]?)\");\n\t\tMatcher m = p.matcher(period);\n\t\tif (m.matches()) {\n\t\t\tString countString = m.group(1);\n\t\t\tint amount = Integer.valueOf(countString);\n\n\t\t\tString dmyString = m.group(2);\n\t\t\tswitch (dmyString) {\n\t\t\t\tcase \"d\":\n\t\t\t\t\treturn localDate.plusDays(amount);\n\t\t\t\tcase \"m\":\n\t\t\t\t\treturn localDate.plusMonths(amount);\n\t\t\t\tcase \"y\":\n\t\t\t\t\treturn localDate.plusYears(amount);\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new InternalErrorException(\"Wrong format of period. Period: \" + period);\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new InternalErrorException(\"Wrong format of period. Period: \" + period);\n\t\t}\n\t}\n\n\t/**\n\t * Returns closest future LocalDate based on values given by matcher.\n\t * If returned value should fall to 29. 2. of non-leap year, the date is extended to 28. 2. instead.\n\t *\n\t * @param matcher matcher with day and month values\n\t * @return Extended date.\n\t */\n\tpublic static LocalDate getClosestExpirationFromStaticDate(Matcher matcher) {\n\t\tint day = Integer.parseInt(matcher.group(1));\n\t\tint month = Integer.parseInt(matcher.group(2));\n\n\t\t// We must detect if the extension date is in current year or in a next year (we use year 2000 in comparison because it is a leap year)\n\t\tLocalDate extensionDate = LocalDate.of(2000, month, day);\n\n\t\t// check if extension is next year\n\t\t// in case of static date being today's date, we want to extend to next year (that's why we use the negation later)\n\t\tboolean extensionInThisYear = LocalDate.of(2000, LocalDate.now().getMonth(), LocalDate.now().getDayOfMonth()).isBefore(extensionDate);\n\n\t\t// Get current year\n\t\tint year = LocalDate.now().getYear();\n\t\tif (!extensionInThisYear) {\n\t\t\t// Add year to get next year\n\t\t\tyear++;\n\t\t}\n\n\t\t// Set the date to which the membership should be extended, can be changed if there was grace period, see next part of the code\n\t\tif (day == 29 && month == 2 && !LocalDate.of(year, 1,1).isLeapYear()) {\n\t\t\t// If extended date is 29. 2. of non-leap year, the date is set to 28. 2.\n\t\t\textensionDate = LocalDate.of(year, 2, 28);\n\t\t} else {\n\t\t\textensionDate = LocalDate.of(year, month, day);\n\t\t}\n\n\t\treturn extensionDate;\n\t}\n\n\t/**\n\t * Prepares grace period date by values from given matcher.\n\t * @param matcher matcher\n\t * @return pair of field(ChronoUnit.YEARS, ChronoUnit.MONTHS, ChronoUnit.DAYS) and amount\n\t * @throws InternalErrorException when given matcher contains invalid data\n\t * @throws IllegalArgumentException when matcher does not match gracePeriod format\n\t */\n\tpublic static Pair<Integer, TemporalUnit> prepareGracePeriodDate(Matcher matcher) throws InternalErrorException {\n\t\tif (!matcher.matches()) {\n\t\t\tthrow new IllegalArgumentException(\"Wrong format of gracePeriod.\");\n\t\t}\n\t\tString countString = matcher.group(1);\n\t\tint amount = Integer.valueOf(countString);\n\n\t\tTemporalUnit field;\n\t\tString dmyString = matcher.group(2);\n\t\tswitch (dmyString) {\n\t\t\tcase \"d\":\n\t\t\t\tfield = ChronoUnit.DAYS;\n\t\t\t\tbreak;\n\t\t\tcase \"m\":\n\t\t\t\tfield = ChronoUnit.MONTHS;\n\t\t\t\tbreak;\n\t\t\tcase \"y\":\n\t\t\t\tfield = ChronoUnit.YEARS;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new InternalErrorException(\"Wrong format of gracePeriod.\");\n\t\t}\n\n\t\treturn new Pair<>(amount, field);\n\t}\n}\n"], "fixing_code": ["package cz.metacentrum.perun.core.impl;\n\nimport cz.metacentrum.perun.core.api.ExtSource;\nimport cz.metacentrum.perun.core.api.GroupsManager;\nimport cz.metacentrum.perun.core.api.exceptions.ExtSourceUnsupportedOperationException;\nimport cz.metacentrum.perun.core.api.exceptions.InternalErrorException;\nimport cz.metacentrum.perun.core.api.exceptions.SubjectNotExistsException;\nimport cz.metacentrum.perun.core.blImpl.PerunBlImpl;\nimport cz.metacentrum.perun.core.implApi.ExtSourceApi;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.naming.Context;\nimport javax.naming.NamingEnumeration;\nimport javax.naming.NamingException;\nimport javax.naming.directory.Attribute;\nimport javax.naming.directory.Attributes;\nimport javax.naming.directory.DirContext;\nimport javax.naming.directory.InitialDirContext;\nimport javax.naming.directory.SearchControls;\nimport javax.naming.directory.SearchResult;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Hashtable;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * Ext source implementation for LDAP.\n *\n * @author Michal Prochazka michalp@ics.muni.cz\n * @author Pavel Zl\u00e1mal <zlamal@cesnet.cz>\n */\npublic class ExtSourceLdap extends ExtSource implements ExtSourceApi {\n\n\tprotected Map<String, String> mapping;\n\n\tprotected final static Logger log = LoggerFactory.getLogger(ExtSourceLdap.class);\n\n\tprotected DirContext dirContext = null;\n\tprotected String filteredQuery = null;\n\n\tprotected DirContext getContext() throws InternalErrorException {\n\t\tif (dirContext == null) {\n\t\t\tinitContext();\n\t\t}\n\t\treturn dirContext;\n\t}\n\n\tprivate static PerunBlImpl perunBl;\n\n\t// filled by spring (perun-core.xml)\n\tpublic static PerunBlImpl setPerunBlImpl(PerunBlImpl perun) {\n\t\tperunBl = perun;\n\t\treturn perun;\n\t}\n\n\t@Override\n\tpublic List<Map<String,String>> findSubjectsLogins(String searchString) throws InternalErrorException {\n\t\treturn findSubjectsLogins(searchString, 0);\n\t}\n\n\t@Override\n\tpublic List<Map<String,String>> findSubjectsLogins(String searchString, int maxResults) throws InternalErrorException {\n\t\t// Prepare searchQuery\n\t\t// attributes.get(\"query\") contains query template, e.g. (uid=?), ? will be replaced by the searchString\n\t\tString query = getAttributes().get(\"query\");\n\t\tif (query == null) {\n\t\t\tthrow new InternalErrorException(\"query attributes is required\");\n\t\t}\n\t\tquery = query.replace(\"?\", Utils.escapeStringForLDAP(searchString));\n\n\t\tString base = getAttributes().get(\"base\");\n\t\tif (base == null) {\n\t\t\tthrow new InternalErrorException(\"base attributes is required\");\n\t\t}\n\t\treturn this.querySource(query, base, maxResults);\n\t}\n\n\t@Override\n\tpublic Map<String, String> getSubjectByLogin(String login) throws InternalErrorException, SubjectNotExistsException {\n\t\t// Prepare searchQuery\n\t\t// attributes.get(\"loginQuery\") contains query template, e.g. (uid=?), ? will be replaced by the login\n\t\tString query = getAttributes().get(\"loginQuery\");\n\t\tif (query == null) {\n\t\t\tthrow new InternalErrorException(\"loginQuery attributes is required\");\n\t\t}\n\t\tquery = query.replace(\"?\", Utils.escapeStringForLDAP(login));\n\n\t\tString base = getAttributes().get(\"base\");\n\t\tif (base == null) {\n\t\t\tthrow new InternalErrorException(\"base attributes is required\");\n\t\t}\n\n\t\tList<Map<String, String>> subjects = this.querySource(query, base, 0);\n\n\t\tif (subjects.size() > 1) {\n\t\t\tthrow new SubjectNotExistsException(\"There are more than one results for the login: \" + login);\n\t\t}\n\n\t\tif (subjects.size() == 0) {\n\t\t\tthrow new SubjectNotExistsException(login);\n\t\t}\n\n\t\treturn subjects.get(0);\n\t}\n\n\t@Override\n\tpublic List<Map<String, String>> getGroupSubjects(Map<String, String> attributes) throws InternalErrorException {\n\n\t\tList<String> ldapGroupSubjects = new ArrayList<>();\n\n\t\t// Get the LDAP group name\n\t\tString ldapGroupName = attributes.get(GroupsManager.GROUPMEMBERSQUERY_ATTRNAME);\n\t\t// Get optional filter for members filtering\n\t\tString filter = attributes.get(GroupsManager.GROUPMEMBERSFILTER_ATTRNAME);\n\n\t\ttry {\n\t\t\tlog.trace(\"LDAP External Source: searching for group subjects [{}]\", ldapGroupName);\n\n\t\t\tString attrName;\n\t\t\t// Default value\n\t\t\tattrName = getAttributes().getOrDefault(\"memberAttribute\", \"uniqueMember\");\n\t\t\tList<String> retAttrs = new ArrayList<>();\n\t\t\tretAttrs.add(attrName);\n\n\t\t\tString[] retAttrsArray = retAttrs.toArray(new String[0]);\n\t\t\tAttributes attrs = getContext().getAttributes(ldapGroupName, retAttrsArray);\n\n\t\t\tAttribute ldapAttribute = null;\n\t\t\t// Get the list of returned groups, should be only one\n\t\t\tif (attrs.get(attrName) != null) {\n\t\t\t\t// Get the attribute which holds group subjects\n\t\t\t\tldapAttribute = attrs.get(attrName);\n\t\t\t}\n\n\t\t\tif (ldapAttribute != null) {\n\t\t\t\t// Get the DNs of the subjects\n\t\t\t\tfor (int i=0; i < ldapAttribute.size(); i++) {\n\t\t\t\t\tString ldapSubjectDN = (String) ldapAttribute.get(i);\n\t\t\t\t\tldapGroupSubjects.add(ldapSubjectDN);\n\t\t\t\t\tlog.trace(\"LDAP External Source: found group subject [{}].\", ldapSubjectDN);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tList<Map<String, String>> subjects = new ArrayList<>();\n\n\t\t\t// If attribute filter not exists, use optional default filter from extSource definition\n\t\t\tif(filter == null) filter = filteredQuery;\n\n\t\t\t// Now query LDAP again and search for each subject\n\t\t\tfor (String ldapSubjectName : ldapGroupSubjects) {\n\t\t\t\tsubjects.addAll(this.querySource(filter, ldapSubjectName, 0));\n\t\t\t}\n\n\t\t\treturn subjects;\n\n\t\t} catch (NamingException e) {\n\t\t\tlog.error(\"LDAP exception during running query '{}'\", ldapGroupName);\n\t\t\tthrow new InternalErrorException(\"Entry '\"+ldapGroupName+\"' was not found in LDAP.\" , e);\n\t\t}\n\t}\n\n\t@Override\n\tpublic List<Map<String, String>> getUsersSubjects() throws ExtSourceUnsupportedOperationException {\n\t\tthrow new ExtSourceUnsupportedOperationException();\n\t}\n\n\tprotected void initContext() throws InternalErrorException {\n\t\t// Load mapping between LDAP attributes and Perun attributes\n\t\tHashtable<String,String> env = new Hashtable<>();\n\n\t\tenv.put(Context.INITIAL_CONTEXT_FACTORY,\"com.sun.jndi.ldap.LdapCtxFactory\");\n\t\tenv.put(Context.SECURITY_AUTHENTICATION, \"simple\");\n\t\tif (getAttributes().containsKey(\"referral\")) {\n\t\t\tenv.put(Context.REFERRAL, getAttributes().get(\"referral\"));\n\t\t}\n\t\tif (getAttributes().containsKey(\"url\")) {\n\t\t\tenv.put(Context.PROVIDER_URL, getAttributes().get(\"url\"));\n\t\t} else {\n\t\t\tthrow new InternalErrorException(\"url attributes is required\");\n\t\t}\n\t\tif (getAttributes().containsKey(\"user\")) {\n\t\t\tenv.put(Context.SECURITY_PRINCIPAL, getAttributes().get(\"user\"));\n\t\t}\n\t\tif (getAttributes().containsKey(\"password\")) {\n\t\t\tenv.put(Context.SECURITY_CREDENTIALS, getAttributes().get(\"password\"));\n\t\t}\n\n\t\tif (getAttributes().containsKey(\"filteredQuery\")) {\n\t\t\tfilteredQuery = getAttributes().get(\"filteredQuery\");\n\t\t}\n\n\t\ttry {\n\t\t\t// ldapMapping contains entries like: firstName={givenName},lastName={sn},email={mail}\n\t\t\tif (getAttributes().get(\"ldapMapping\") == null) {\n\t\t\t\tthrow new InternalErrorException(\"ldapMapping attributes is required\");\n\t\t\t}\n\t\t\tString[] ldapMapping = getAttributes().get(\"ldapMapping\").trim().split(\",\\n\");\n\t\t\tmapping = new HashMap<>();\n\t\t\tfor (String entry: ldapMapping) {\n\t\t\t\tString[] values = entry.trim().split(\"=\", 2);\n\t\t\t\tmapping.put(values[0].trim(), values[1].trim());\n\t\t\t}\n\n\t\t\tthis.dirContext = new InitialDirContext(env);\n\t\t} catch (NamingException e) {\n\t\t\tlog.error(\"LDAP exception during creating the context.\");\n\t\t\tthrow new InternalErrorException(e);\n\t\t}\n\t}\n\n\tprotected Map<String,String> getSubjectAttributes(Attributes attributes) throws InternalErrorException {\n\t\tPattern pattern = Pattern.compile(\"\\\\{([^}])*}\");\n\t\tMap<String, String> map = new HashMap<>();\n\n\t\tfor (String key: mapping.keySet()) {\n\t\t\t// Get attribute value and substitute all {} in the string\n\t\t\tMatcher matcher = pattern.matcher(mapping.get(key));\n\t\t\tString value = mapping.get(key);\n\n\t\t\t// Find all matches\n\t\t\twhile (matcher.find()) {\n\t\t\t\t// Get the matching string\n\t\t\t\tString ldapAttributeNameRaw = matcher.group();\n\t\t\t\tString ldapAttributeName = ldapAttributeNameRaw.replaceAll(\"\\\\{([^}]*)}\", \"$1\"); // ldapAttributeNameRaw is encapsulate with {}, so remove it\n\t\t\t\t// Replace {ldapAttrName} with the value\n\t\t\t\tvalue = value.replace(ldapAttributeNameRaw, getLdapAttributeValue(attributes, ldapAttributeName));\n\t\t\t\tlog.trace(\"ExtSourceLDAP: Retrieved value {} of attribute {} for {} and storing into the key {}.\", value, ldapAttributeName, ldapAttributeNameRaw, key);\n\t\t\t}\n\n\t\t\tmap.put(key, value);\n\t\t}\n\n\t\treturn map;\n\t}\n\n\tprotected String getLdapAttributeValue(Attributes attributes, String ldapAttrNameRaw)  throws InternalErrorException {\n\t\tString ldapAttrName;\n\t\tString rule = null;\n\t\tMatcher matcher;\n\t\tString attrValue = \"\";\n\n\t\t// Check if the ldapAttrName contains regex\n\t\tif (ldapAttrNameRaw.contains(\"|\")) {\n\t\t\tint splitter = ldapAttrNameRaw.indexOf('|');\n\t\t\tldapAttrName = ldapAttrNameRaw.substring(0,splitter);\n\t\t\trule = ldapAttrNameRaw.substring(splitter+1);\n\t\t} else {\n\t\t\tldapAttrName = ldapAttrNameRaw;\n\t\t}\n\n\t\t// Check if the ldapAttrName contains specification of the value index\n\t\tint attributeValueIndex = -1;\n\t\tif (ldapAttrNameRaw.contains(\"[\")) {\n\t\t\tPattern indexPattern = Pattern.compile(\"^(.*)\\\\[([0-9]+)]$\");\n\t\t\tMatcher indexMatcher = indexPattern.matcher(ldapAttrNameRaw);\n\t\t\tif (indexMatcher.find()) {\n\t\t\t\tldapAttrName = indexMatcher.group(1);\n\t\t\t\tattributeValueIndex = Integer.parseInt(indexMatcher.group(2));\n\t\t\t} else {\n\t\t\t\tthrow new InternalErrorException(\"Wrong attribute name format for attribute: \" + ldapAttrNameRaw + \", it should be name[0-9+]\");\n\t\t\t}\n\t\t}\n\n\t\t// Mapping to the LDAP attribute\n\t\tAttribute attr = attributes.get(ldapAttrName);\n\t\tif (attr != null) {\n\t\t\t// There could be more than one value in the attribute. Separator is defined in the AttributesManagerImpl\n\t\t\tfor (int i = 0; i < attr.size(); i++) {\n\t\t\t\tif (attributeValueIndex != -1 && attributeValueIndex != i) {\n\t\t\t\t\t// We want only value on concrete index, so skip the other ones\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tString tmpAttrValue;\n\t\t\t\ttry {\n\t\t\t\t\tif(attr.get() instanceof byte[]) {\n\t\t\t\t\t\t// It can be byte array with cert or binary file\n\t\t\t\t\t\tchar[] encodedValue = Base64Coder.encode((byte[]) attr.get());\n\t\t\t\t\t\ttmpAttrValue = new String(encodedValue);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttmpAttrValue = (String) attr.get(i);\n\t\t\t\t\t}\n\t\t\t\t} catch (NamingException e) {\n\t\t\t\t\tthrow new InternalErrorException(e);\n\t\t\t\t}\n\n\t\t\t\tif (rule != null) {\n\t\t\t\t\tif(rule.contains(\"#\")) {\n\t\t\t\t\t\t// Rules are in place, so apply them\n\t\t\t\t\t\tString regex = rule.substring(0, rule.indexOf('#'));\n\t\t\t\t\t\tString replacement = rule.substring(rule.indexOf('#')+1);\n\t\t\t\t\t\ttmpAttrValue = tmpAttrValue.replaceAll(regex, replacement);\n\t\t\t\t\t//DEPRECATED way\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Rules are in place, so apply them\n\t\t\t\t\t\tPattern pattern = Pattern.compile(rule);\n\t\t\t\t\t\tmatcher = pattern.matcher(tmpAttrValue);\n\t\t\t\t\t\t// Get the first group which matched\n\t\t\t\t\t\tif (matcher.matches()) {\n\t\t\t\t\t\t\ttmpAttrValue = matcher.group(1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (i == 0 || attributeValueIndex != -1) {\n\t\t\t\t\t// Do not add delimiter before first entry or if the particular index has been requested\n\t\t\t\t\tattrValue += tmpAttrValue;\n\t\t\t\t} else {\n\t\t\t\t\tattrValue += AttributesManagerImpl.LIST_DELIMITER + tmpAttrValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (attrValue.isEmpty()) {\n\t\t\t\treturn \"\";\n\t\t\t} else {\n\t\t\t\treturn attrValue;\n\t\t\t}\n\t\t} else {\n\t\t\treturn \"\";\n\t\t}\n\t}\n\n\t/**\n\t * Query LDAP using query in defined base. Results can be limited to the maxResults.\n\t *\n\t * @param query\n\t * @param base\n\t * @param maxResults\n\t * @return List of Map of the LDAP attribute names and theirs values\n\t * @throws InternalErrorException\n\t */\n\tprotected List<Map<String,String>> querySource(String query, String base, int maxResults) throws InternalErrorException {\n\n\t\tNamingEnumeration<SearchResult> results = null;\n\t\tList<Map<String, String>> subjects = new ArrayList<>();\n\n\t\ttry {\n\t\t\t// If query is null, then we are finding object by the base\n\t\t\tif (query == null) {\n\t\t\t\tlog.trace(\"search base [{}]\", base);\n\t\t\t\t// TODO jmena atributu spise prijimiat pres vstupni parametr metody\n\t\t\t\tAttributes ldapAttributes = getContext().getAttributes(base);\n\t\t\t\tif (ldapAttributes.size() > 0) {\n\t\t\t\t\tMap<String, String> attributes = this.getSubjectAttributes(ldapAttributes);\n\t\t\t\t\tif (!attributes.isEmpty()) {\n\t\t\t\t\t\tsubjects.add(attributes);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlog.trace(\"search string [{}]\", query);\n\n\t\t\t\tSearchControls controls = new SearchControls();\n\t\t\t\tcontrols.setSearchScope(SearchControls.SUBTREE_SCOPE);\n\t\t\t\t// Set timeout to 5s\n\t\t\t\tcontrols.setTimeLimit(5000);\n\t\t\t\tif (maxResults > 0) {\n\t\t\t\t\tcontrols.setCountLimit(maxResults);\n\t\t\t\t}\n\n\t\t\t\tif (base == null) base = \"\";\n\n\t\t\t\tresults = getContext().search(base, query, controls);\n\t\t\t\twhile (results.hasMore()) {\n\t\t\t\t\tSearchResult searchResult = results.next();\n\t\t\t\t\tAttributes attributes = searchResult.getAttributes();\n\t\t\t\t\tMap<String,String> subjectAttributes = this.getSubjectAttributes(attributes);\n\t\t\t\t\tif (!subjectAttributes.isEmpty()) {\n\t\t\t\t\t\tsubjects.add(subjectAttributes);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlog.trace(\"Returning [{}] subjects\", subjects.size());\n\t\t\treturn subjects;\n\n\t\t} catch (NamingException e) {\n\t\t\tlog.error(\"LDAP exception during running query '{}'\", query);\n\t\t\tthrow new InternalErrorException(\"LDAP exception during running query: \"+query+\".\", e);\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (results != null) { results.close(); }\n\t\t\t} catch (Exception e) {\n\t\t\t\tlog.error(\"LDAP exception during closing result, while running query '{}'\", query);\n\t\t\t\tthrow new InternalErrorException(e);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void close() throws InternalErrorException {\n\t\tif (this.dirContext != null) {\n\t\t\ttry {\n\t\t\t\tthis.dirContext.close();\n\t\t\t\tthis.dirContext = null;\n\t\t\t} catch (NamingException e) {\n\t\t\t\tthrow new InternalErrorException(e);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic List<Map<String, String>> getSubjectGroups(Map<String, String> attributes) throws ExtSourceUnsupportedOperationException {\n\t\tthrow new ExtSourceUnsupportedOperationException();\n\t}\n\n\t@Override\n\tpublic List<Map<String, String>> findSubjects(String searchString) throws InternalErrorException {\n\t\treturn findSubjects(searchString, 0);\n\t}\n\n\t@Override\n\tpublic List<Map<String, String>> findSubjects(String searchString, int maxResults) throws InternalErrorException {\n\t\t// We can call original implementation, since LDAP always return whole entry and not just login\n\t\treturn findSubjectsLogins(searchString, maxResults);\n\t}\n\n\tprotected Map<String,String> getAttributes() throws InternalErrorException {\n\t\treturn perunBl.getExtSourcesManagerBl().getAttributes(this);\n\t}\n\n}\n", "package cz.metacentrum.perun.core.impl;\n\nimport com.zaxxer.hikari.HikariDataSource;\nimport cz.metacentrum.perun.core.api.Attribute;\nimport cz.metacentrum.perun.core.api.AttributeDefinition;\nimport cz.metacentrum.perun.core.api.BeansUtils;\nimport cz.metacentrum.perun.core.api.Destination;\nimport cz.metacentrum.perun.core.api.ExtSource;\nimport cz.metacentrum.perun.core.api.Member;\nimport cz.metacentrum.perun.core.api.Pair;\nimport cz.metacentrum.perun.core.api.PerunSession;\nimport cz.metacentrum.perun.core.api.User;\nimport cz.metacentrum.perun.core.api.UserExtSource;\nimport cz.metacentrum.perun.core.api.exceptions.AttributeNotExistsException;\nimport cz.metacentrum.perun.core.api.exceptions.ConsistencyErrorException;\nimport cz.metacentrum.perun.core.api.exceptions.DiacriticNotAllowedException;\nimport cz.metacentrum.perun.core.api.exceptions.ExtSourceExistsException;\nimport cz.metacentrum.perun.core.api.exceptions.ExtSourceNotExistsException;\nimport cz.metacentrum.perun.core.api.exceptions.IllegalArgumentException;\nimport cz.metacentrum.perun.core.api.exceptions.InternalErrorException;\nimport cz.metacentrum.perun.core.api.exceptions.MaxSizeExceededException;\nimport cz.metacentrum.perun.core.api.exceptions.MemberNotExistsException;\nimport cz.metacentrum.perun.core.api.exceptions.MinSizeExceededException;\nimport cz.metacentrum.perun.core.api.exceptions.NumberNotInRangeException;\nimport cz.metacentrum.perun.core.api.exceptions.NumbersNotAllowedException;\nimport cz.metacentrum.perun.core.api.exceptions.ParseUserNameException;\nimport cz.metacentrum.perun.core.api.exceptions.ParserException;\nimport cz.metacentrum.perun.core.api.exceptions.PrivilegeException;\nimport cz.metacentrum.perun.core.api.exceptions.SpaceNotAllowedException;\nimport cz.metacentrum.perun.core.api.exceptions.SpecialCharsNotAllowedException;\nimport cz.metacentrum.perun.core.api.exceptions.UserNotExistsException;\nimport cz.metacentrum.perun.core.api.exceptions.WrongAttributeAssignmentException;\nimport cz.metacentrum.perun.core.api.exceptions.WrongPatternException;\nimport cz.metacentrum.perun.core.bl.PerunBl;\nimport cz.metacentrum.perun.core.blImpl.ModulesUtilsBlImpl;\nimport org.apache.commons.codec.binary.Base64;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.jdbc.core.RowMapper;\nimport org.springframework.mail.MailException;\nimport org.springframework.mail.SimpleMailMessage;\nimport org.springframework.mail.javamail.JavaMailSender;\nimport org.springframework.mail.javamail.JavaMailSenderImpl;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.Mac;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\nimport javax.sql.DataSource;\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.UnsupportedEncodingException;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.text.Normalizer;\nimport java.text.Normalizer.Form;\nimport java.text.StringCharacterIterator;\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.time.format.DateTimeFormatter;\nimport java.time.temporal.ChronoUnit;\nimport java.time.temporal.TemporalUnit;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.StringJoiner;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * Utilities.\n */\npublic class Utils {\n\n\tprivate final static Logger log = LoggerFactory.getLogger(Utils.class);\n\tpublic final static String configurationsLocations = \"/etc/perun/\";\n\tpublic static final String TITLE_BEFORE = \"titleBefore\";\n\tpublic static final String FIRST_NAME = \"firstName\";\n\tpublic static final String LAST_NAME = \"lastName\";\n\tpublic static final String TITLE_AFTER = \"titleAfter\";\n\tprivate static Properties properties;\n\tpublic static final Pattern emailPattern = Pattern.compile(\"^[-_A-Za-z0-9+']+(\\\\.[-_A-Za-z0-9+']+)*@[-A-Za-z0-9]+(\\\\.[-A-Za-z0-9]+)*(\\\\.[A-Za-z]{2,})$\");\n\n\tprivate static final Pattern titleBeforePattern = Pattern.compile(\"^(([\\\\p{L}]+[.])|(et))$\");\n\tprivate static final Pattern firstNamePattern = Pattern.compile(\"^[\\\\p{L}-']+$\");\n\tprivate static final Pattern lastNamePattern = Pattern.compile(\"^(([\\\\p{L}-']+)|([\\\\p{L}][.]))$\");\n\n\tprivate static final String userPhoneAttribute = \"urn:perun:user:attribute-def:def:phone\";\n\tprivate static final String memberPhoneAttribute = \"urn:perun:member:attribute-def:def:phone\";\n\n\t/**\n\t * Replaces dangerous characters.\n\t * Replaces : with - and spaces with _.\n\t *\n\t * @param str string to be normalized\n\t * @return normalized string\n\t */\n\tpublic static String normalizeString(String str) {\n\t\tlog.trace(\"Entering normalizeString: str='{}'\", str);\n\t\treturn str.replace(':', '-').replace(' ', '_');\n\t}\n\n\tpublic static <T> boolean hasDuplicate(List<T> all) {\n\t\tSet<T> set = new HashSet<>(all.size());\n\t\t// Set#add returns false if the set does not change, which\n\t\t// indicates that a duplicate element has been added.\n\t\tfor (T each: all) if (!set.add(each)) return true;\n\t\treturn false;\n\t}\n\n\t/**\n\t * Joins Strings or any objects into a String. Use as\n\t * <pre>\n\t *  List<?> list = Arrays.asList(\"a\", 1, 2.0);\n\t *  String s = join(list,\",\");\n\t * </pre>\n\t * @param collection anything Iterable, like a {@link java.util.List} or {@link java.util.Collection}\n\t * @param separator any separator, like a comma\n\t * @return string with string representations of objects joined by separators\n\t */\n\tpublic static String join(Iterable<?> collection, String separator) {\n\t\tIterator<?> oIter;\n\t\tif (collection == null || (!(oIter = collection.iterator()).hasNext()))\n\t\t\treturn \"\";\n\t\tStringBuilder oBuilder = new StringBuilder(String.valueOf(oIter.next()));\n\t\twhile (oIter.hasNext())\n\t\t\toBuilder.append(separator).append(oIter.next());\n\t\treturn oBuilder.toString();\n\t}\n\n\t/**\n\t * Returns additionalUserExtSources from the subject. It's used for synchronization from different ExtSources. subjectFromExtSource was obtained from the ExtSource.\n\t *\n\t * @param sess perun session\n\t * @param subjectFromExtSource map with the subject\n\t * @return List<UserExtSource> all additional ExtSources from the subject, returned list will never contain null value\n\t * @throws InternalErrorException\n\t */\n\tpublic static List<UserExtSource> extractAdditionalUserExtSources(PerunSession sess, Map<String, String> subjectFromExtSource) throws InternalErrorException {\n\t\tList<UserExtSource> additionalUserExtSources = new ArrayList<>();\n\t\tfor (String attrName : subjectFromExtSource.keySet()) {\n\t\t\tif(attrName != null &&\n\t\t\t\tsubjectFromExtSource.get(attrName) != null &&\n\t\t\t\tattrName.startsWith(ExtSourcesManagerImpl.USEREXTSOURCEMAPPING)) {\n\t\t\t\tString login = subjectFromExtSource.get(\"login\");\n\n\t\t\t\tString[] userExtSourceRaw =  subjectFromExtSource.get(attrName).split(\"\\\\|\"); // Entry contains extSourceName|extSourceType|extLogin[|LoA]\n\t\t\t\tlog.debug(\"Processing additionalUserExtSource {}\",  subjectFromExtSource.get(attrName));\n\n\t\t\t\t//Check if the array has at least 3 parts, this is protection against outOfBoundException\n\t\t\t\tif(userExtSourceRaw.length < 3) {\n\t\t\t\t\tthrow new InternalErrorException(\"There is a missing mandatory part of additional user extSource value when processing it - '\" + attrName + \"'\");\n\t\t\t\t}\n\n\t\t\t\tString additionalExtSourceName = userExtSourceRaw[0];\n\t\t\t\tString additionalExtSourceType = userExtSourceRaw[1];\n\t\t\t\tString additionalExtLogin = userExtSourceRaw[2];\n\t\t\t\tint additionalExtLoa = 0;\n\t\t\t\t// Loa is not mandatory argument\n\t\t\t\tif (userExtSourceRaw.length>3 && userExtSourceRaw[3] != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tadditionalExtLoa = Integer.parseInt(userExtSourceRaw[3]);\n\t\t\t\t\t} catch (NumberFormatException e) {\n\t\t\t\t\t\tthrow new ParserException(\"Subject with login [\" + login + \"] has wrong LoA '\" + userExtSourceRaw[3] + \"'.\", e, \"LoA\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tExtSource additionalExtSource;\n\n\t\t\t\tif (additionalExtSourceName == null || additionalExtSourceName.isEmpty() ||\n\t\t\t\t\tadditionalExtSourceType == null || additionalExtSourceType.isEmpty() ||\n\t\t\t\t\tadditionalExtLogin == null || additionalExtLogin.isEmpty()) {\n\t\t\t\t\tlog.error(\"User with login {} has invalid additional userExtSource defined {}.\", login, userExtSourceRaw);\n\t\t\t\t} else {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Try to get extSource, with full extSource object (containg ID)\n\t\t\t\t\t\tadditionalExtSource = ((PerunBl) sess.getPerun()).getExtSourcesManagerBl().getExtSourceByName(sess, additionalExtSourceName);\n\t\t\t\t\t} catch (ExtSourceNotExistsException e) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t// Create new one if not exists\n\t\t\t\t\t\t\tadditionalExtSource = new ExtSource(additionalExtSourceName, additionalExtSourceType);\n\t\t\t\t\t\t\tadditionalExtSource = ((PerunBl) sess.getPerun()).getExtSourcesManagerBl().createExtSource(sess, additionalExtSource, null);\n\t\t\t\t\t\t} catch (ExtSourceExistsException e1) {\n\t\t\t\t\t\t\tthrow new ConsistencyErrorException(\"Creating existing extSource: \" + additionalExtSourceName);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Add additional user extSource\n\t\t\t\t\tadditionalUserExtSources.add(new UserExtSource(additionalExtSource, additionalExtLoa, additionalExtLogin));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn additionalUserExtSources;\n\t}\n\n\t/**\n\t * Joins Strings or any objects into a String. Use as\n\t * <pre>\n\t *  String[] sa = { \"a\", \"b\", \"c\"};\n\t *  String s = join(list,\",\");\n\t * </pre>\n\t * @param objs array of objects\n\t * @param separator any separator, like a comma\n\t * @return string with string representations of objects joined by separators\n\t */\n\tpublic static String join(Object[] objs, String separator) {\n\t\tlog.trace(\"Entering join: objs='{}', separator='{}'\", objs, separator);\n\t\treturn join(Arrays.asList(objs),separator);\n\t}\n\n\t/**\n\t * Integer row mapper\n\t */\n\tpublic static final RowMapper<Integer> ID_MAPPER = (resultSet, i) -> resultSet.getInt(\"id\");\n\n\t/**\n\t * String row mapper\n\t */\n\tpublic static final RowMapper<String> STRING_MAPPER = (resultSet, i) -> resultSet.getString(\"value\");\n\n\t// FIXME prijde odstranit\n\tpublic static void checkPerunSession(PerunSession sess) throws InternalErrorException {\n\t\tnotNull(sess, \"sess\");\n\t}\n\n\t/**\n\t * Creates copy of given Map with Sets as values. The returned object contains a new Map\n\t * and new Sets, the {@link T} objects remain the same.\n\t *\n\t * @param original original Map\n\t * @param <T> parameter\n\t * @return new Map with new Sets as values\n\t */\n\tpublic static <T> Map<T, Set<T>> createDeepCopyOfMapWithSets(Map<T, Set<T>> original) {\n\t\tMap<T, Set<T>> copy = new HashMap<>();\n\t\tfor (T key : original.keySet()) {\n\t\t\tSet<T> setCopy = original.get(key) == null ? null : new HashSet<>(original.get(key));\n\t\t\tcopy.put(key, setCopy);\n\t\t}\n\t\treturn copy;\n\t}\n\n\t/**\n\t * Checks whether the object is null or not.\n\t *\n\t * @param e\n\t * @param name\n\t * @throws InternalErrorException which wraps NullPointerException\n\t */\n\tpublic static void notNull(Object e, String name) throws InternalErrorException {\n\t\tif(e == null){\n\t\t\tthrow new InternalErrorException(new NullPointerException(\"'\" + name + \"' is null\"));\n\t\t}\n\t}\n\n\t/**\n\t * Throws a MinSizeExceededException if the given value does not specified minLength.\n\t * If the value is null then MinSizeExceededException is thrown as well.\n\t *\n\t * @param propertyName name of checked property\n\t * @param minLength minimal length\n\t * @throws MinSizeExceededException when length of actualValue is lower than minLength or null\n\t */\n\tpublic static void checkMinLength(String propertyName, String actualValue, int minLength) throws MinSizeExceededException {\n\t\tif (actualValue == null) {\n\t\t\tthrow new MinSizeExceededException(\"The property '\" + propertyName + \"' does not have a minimal length equal to '\" + minLength + \"' because it is null.\");\n\t\t}\n\t\tif (actualValue.length() < minLength) {\n\t\t\tthrow new MinSizeExceededException(\"Length of '\" + propertyName + \"' is too short! MinLength=\" + minLength + \", ActualLength=\" + actualValue.length());\n\t\t}\n\t}\n\n\t/**\n\t * Throws a MaxSizeExceededException if the given value is longer than maxLength.\n\t * If the value is null then nothing happens.\n\t *\n\t * @param propertyName name of checked property\n\t * @param maxLength max length\n\t * @throws MaxSizeExceededException when length of actualValue is higher than maxLength\n\t */\n\tpublic static void checkMaxLength(String propertyName, String actualValue, int maxLength) throws MaxSizeExceededException {\n\t\tif (actualValue == null) {\n\t\t\treturn;\n\t\t}\n\t\tif (actualValue.length() > maxLength) {\n\t\t\tthrow new MaxSizeExceededException(\"Length of '\" + propertyName + \"' is too long! MaxLength=\" + maxLength + \", ActualLength=\" + actualValue.length());\n\t\t}\n\t}\n\n\t/**\n\t * Define, if some entity contain a diacritic symbol.\n\t *\n\t * @param name name of entity\n\t * @throws DiacriticNotAllowedException\n\t */\n\tpublic static void checkWithoutDiacritic(String name) throws DiacriticNotAllowedException{\n\n\t\tif(!Normalizer.isNormalized(name, Form.NFKD))throw new DiacriticNotAllowedException(\"Name of the entity is not in the normalized form NFKD (diacritic not allowed)!\");\n\n\t}\n\n\t/**\n\t * Define, if some entity contain a special symbol\n\t * Special symbol is everything except - numbers, letters and space\n\t *\n\t * @param name name of entity\n\t * @throws SpecialCharsNotAllowedException\n\t */\n\tpublic static void checkWithoutSpecialChars(String name) throws SpecialCharsNotAllowedException{\n\n\t\tif(!name.matches(\"^[0-9 \\\\p{L}]*$\")) throw new SpecialCharsNotAllowedException(\"The special chars in the name of entity are not allowed!\");\n\t}\n\n\t/**\n\t * Define, if some entity contain a special symbol\n\t * Special symbol is everything except - numbers, letters and space (and allowedSpecialChars)\n\t * The allowedSpecialChars are on the end of regular expresion, so the same rule must be observed.\n\t * (example, symbol - must be on the end of string) rules are the same like in regular expresion\n\t *\n\t * @param name name of entity\n\t * @param allowedSpecialChars this String must contain only special chars which are allowed\n\t * @throws SpecialCharsNotAllowedException\n\t */\n\tpublic static void checkWithoutSpecialChars(String name, String allowedSpecialChars) throws SpecialCharsNotAllowedException{\n\n\t\tif(!name.matches(\"^([0-9 \\\\p{L}\" + allowedSpecialChars + \"])*$\")) throw new SpecialCharsNotAllowedException(\"The special chars (except \" + allowedSpecialChars + \") in the name of entity are not allowed!\");\n\t}\n\n\t/**\n\t * Define, if some entity contain a number\n\t *\n\t * @param name\n\t * @throws NumbersNotAllowedException\n\t */\n\tpublic static void checkWithoutNumbers(String name) throws NumbersNotAllowedException{\n\n\t\tif(!name.matches(\"^([^0-9])*$\")) throw new NumbersNotAllowedException(\"The numbers in the name of entity are not allowed!\");\n\t}\n\n\t/**\n\t * Define, if some entity contain a space\n\t *\n\t * @param name\n\t * @throws SpaceNotAllowedException\n\t */\n\tpublic static void checkWithoutSpaces(String name)throws SpaceNotAllowedException{\n\n\t\tif(name.contains(\" \")) throw new SpaceNotAllowedException(\"The spaces in the name of entity are not allowed!\");\n\t}\n\n\t/**\n\t * Define, if some number is in range.\n\t * Example: number 4 is in range 4 - 12, number 3 is not\n\t *\n\t * @param number\n\t * @param lowestValue\n\t * @param highestValue\n\t * @throws NumberNotInRangeException\n\t */\n\tpublic static void checkRangeOfNumbers(int number, int lowestValue, int highestValue) throws NumberNotInRangeException {\n\n\t\tif(number<lowestValue || number>highestValue) throw new NumberNotInRangeException(\"Number is not in range, Lowest=\"+lowestValue+\" < Number=\"+number+\" < Highest=\"+highestValue);\n\t}\n\n\t/**\n\t * Gets the next number from the sequence. This function hides differences in the databases engines.\n\t *\n\t * @param jdbc\n\t * @param sequenceName\n\t * @return new ID\n\t * @throws InternalErrorException\n\t */\n\tpublic static int getNewId(JdbcTemplate jdbc, String sequenceName) throws InternalErrorException {\n\t\tString dbType;\n\t\tString url = \"\";\n\t\tString query;\n\t\t// try to deduce database type from jdbc connection metadata\n\t\ttry {\n\t\t\tDataSource ds = jdbc.getDataSource();\n\t\t\tif (ds instanceof HikariDataSource) {\n\t\t\t\turl = ((HikariDataSource) ds).getJdbcUrl();\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tlog.error(\"cannot get JDBC url\", e);\n\t\t}\n\n\t\tif (url.contains(\"hsqldb\")) {\n\t\t\tdbType = \"hsqldb\";\n\t\t} else if (url.contains(\"oracle\")) {\n\t\t\tdbType = \"oracle\";\n\t\t} else if (url.contains(\"postgresql\")) {\n\t\t\tdbType = \"postgresql\";\n\t\t} else {\n\t\t\tdbType = BeansUtils.getCoreConfig().getDbType();\n\t\t}\n\n\t\tswitch (dbType) {\n\t\t\tcase \"oracle\":\n\t\t\t\tquery = \"select \" + sequenceName + \".nextval from dual\";\n\t\t\t\tbreak;\n\t\t\tcase \"postgresql\":\n\t\t\t\tquery = \"select nextval('\" + sequenceName + \"')\";\n\t\t\t\tbreak;\n\t\t\tcase \"hsqldb\":\n\t\t\t\tquery = \"call next value for \" + sequenceName + \";\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new InternalErrorException(\"Unsupported DB type\");\n\t\t}\n\n\t\t// Decide which type of the JdbcTemplate is provided\n\t\ttry {\n\t\t\tInteger i = jdbc.queryForObject(query, Integer.class);\n\t\t\tif (i == null) {\n\t\t\t\tthrow new InternalErrorException(\"New ID should not be null.\");\n\t\t\t}\n\t\t\treturn i;\n\t\t} catch (RuntimeException e) {\n\t\t\tthrow new InternalErrorException(e);\n\t\t}\n\t}\n\n\t/**\n\t * Returns current time in millis. Result of this call can then be used by function getRunningTime().\n\t *\n\t * @return current time in millis.\n\t */\n\tpublic static long startTimer() {\n\t\treturn System.currentTimeMillis();\n\t}\n\n\t/**\n\t * Returns difference between startTime and current time in millis.\n\t *\n\t * @param startTime\n\t * @return difference between current time in millis and startTime.\n\t */\n\tpublic static long getRunningTime(long startTime) {\n\t\treturn System.currentTimeMillis()-startTime;\n\t}\n\n\n\t/**\n\t * Scans all classes accessible from the context class loader which belong to the given package and subpackages.\n\t *\n\t * @param packageName The base package\n\t * @return The classes\n\t * @throws ClassNotFoundException\n\t * @throws IOException\n\t */\n\tpublic static List<Class<?>> getClasses(String packageName) throws ClassNotFoundException, IOException {\n\t\tClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n\t\tassert classLoader != null;\n\t\tString path = packageName.replace('.', '/');\n\t\tEnumeration<URL> resources = classLoader.getResources(path);\n\t\tList<File> dirs = new ArrayList<>();\n\t\twhile (resources.hasMoreElements()) {\n\t\t\tURL resource = resources.nextElement();\n\t\t\tdirs.add(new File(resource.getFile()));\n\t\t}\n\t\tArrayList<Class<?>> classes = new ArrayList<>();\n\t\tfor (File directory : dirs) {\n\t\t\tclasses.addAll(findClasses(directory, packageName));\n\t\t}\n\t\treturn classes;\n\t}\n\n\tprivate static String limit(String s,int limit) {\n\t\tif(s==null) return null;\n\t\treturn s.length() > limit ? s.substring(0, limit) : s;\n\t}\n\n\tpublic static User createUserFromNameMap(Map<String, String> name) throws InternalErrorException {\n\t\tUser user = new User();\n\t\tif (name.get(FIRST_NAME) == null || name.get(LAST_NAME) == null || name.get(FIRST_NAME).isEmpty() || name.get(LAST_NAME).isEmpty()) {\n\t\t\tthrow new InternalErrorException(\"First name/last name is either empty or null when creating user\");\n\t\t}\n\t\tuser.setTitleBefore(limit(name.get(TITLE_BEFORE),40));\n\t\tuser.setFirstName(limit(name.get(FIRST_NAME),64));\n\t\tuser.setLastName(limit(name.get(LAST_NAME),64));\n\t\tuser.setTitleAfter(limit(name.get(TITLE_AFTER),40));\n\t\treturn user;\n\t}\n\n\t/**\n\t * Creates a new instance of User with names initialized from parsed rawName.\n\t * Imposes limit on leghts of fields.\n\t * @see #parseCommonName(String)\n\t * @param rawName raw name\n\t * @param fullNameRequired if true, throw exception if firstName or lastName is missing, do not throw exception otherwise\n\t * @return user\n\t */\n\tpublic static User parseUserFromCommonName(String rawName, boolean fullNameRequired) throws ParseUserNameException {\n\t\tMap<String, String> m = parseCommonName(rawName, fullNameRequired);\n\t\treturn createUserFromNameMap(m);\n\t}\n\n\t/**\n\t * @see Utils.parseCommonName(String rawName, boolean fullNameRequired) - where fullNameRequired is false\n\t */\n\tpublic static Map<String, String> parseCommonName(String rawName) {\n\t\ttry {\n\t\t\treturn Utils.parseCommonName(rawName, false);\n\t\t} catch (ParseUserNameException ex) {\n\t\t\tthrow new InternalErrorException(\"Unexpected behavior while parsing user name without full name requirement.\");\n\t\t}\n\t}\n\n\t/**\n\t * Try to parse rawName to keys: \"titleBefore\" \"firstName\" \"lastName\" \"titleAfter\"\n\t *\n\t * If rawName is null or empty, return map with empty values of all keys.\n\t *\n\t * Parsing procedure:\n\t * 1] prepare list of parts by replacing all characters \",\" and \"_\" by spaces\n\t * 2] change all sequence of invisible characters (space, tabulator etc.) to one space\n\t * 3] one by one try to parsing parts from the list\n\t *  - A] try to find all titleBefore parts\n\t *  - B] try to find one firstName part\n\t *  - C] try to find all lastName parts\n\t *  - D] if the rest is not lastName so save it to the title after\n\t *\n\t * Example of parsing rawName:\n\t * 1] rawName = \"Mgr. et Mgr.    Petr_Jiri R. Sojka, Ph.D., CSc.\"\n\t * 2] convert all ',' and '_' to spaces: rawName = \"Mgr. et Mgr.    Petr Jiri R. Sojka  Ph.D.  CSc.\"\n\t * 3] convert more than 1 invisible char to 1 space: rawName = \"Mgr. et Mgr. Petr Jiri R. Sojka Ph.D. CSc.\"\n\t * 4] parse string to list of parts by space: ListOfParts= [\"Mgr.\",\"et\",\"Mgr.\",\"Petr\",\"Jiri\",\"R.\",\"Sojka\",\"Ph.D.\",\"CSc.\"]\n\t * 5] first fill everything what can be in title before: titleBefore=\"Mgr. et Mgr.\"\n\t * 6] then fill everything what can be in first name (maximum 1 part): firstName=\"Petr\"\n\t * 7] then fill everything what can be in last name: lastName=\"Jiri R. Sojka\"\n\t * 8] everything else put to the title after: titleAfter=\"Ph.D. CSc.\"\n\t * 9] put these variables to map like key=value, for ex.: Map[titleBefore=\"Mgr. et Mgr.\",firstName=\"Petr\", ... ] and return this map\n\t *\n\t * @param rawName name to parse\n\t * @param fullNameRequired if true, throw exception if firstName or lastName is missing, do not throw exception otherwise\n\t * @return map string to string where are 4 keys (titleBefore,titleAfter,firstName and lastName) with their values (value can be null)\n\t * @throws ParseUserNameException when method was unable to parse both first name and last name from the rawName\n\t */\n\tpublic static Map<String, String> parseCommonName(String rawName, boolean fullNameRequired) throws ParseUserNameException {\n\t\t// prepare variables and result map\n\t\tMap<String, String> parsedName = new HashMap<>();\n\t\tString titleBefore = \"\";\n\t\tString firstName = \"\";\n\t\tString lastName = \"\";\n\t\tString titleAfter = \"\";\n\n\t\tif (rawName != null && !rawName.isEmpty()) {\n\t\t\t// replace all ',' and '_' characters for ' ' for rawName\n\t\t\trawName = rawName.replaceAll(\"[,_]\", \" \");\n\t\t\t// replace all invisible chars in row for ' '\n\t\t\trawName = rawName.replaceAll(\"\\\\s+\", \" \").trim();\n\n\t\t\t// split parts by space\n\t\t\tList<String> nameParts = new ArrayList<>(Arrays.asList(rawName.split(\" \")));\n\n\t\t\t// if length of nameParts is 1, save it to the lastName\n\t\t\tif(nameParts.size() == 1) {\n\t\t\t\tlastName = nameParts.get(0);\n\t\t\t\t// if length of nameParts is more than 1, try to choose which part belong to which value\n\t\t\t} else {\n\t\t\t\t// join title before name to single string with ' ' as delimiter\n\t\t\t\ttitleBefore = parsePartOfName(nameParts, new StringJoiner(\" \"), titleBeforePattern);\n\n\t\t\t\t// get first name as a next name part if pattern matches and nameParts are not empty\n\t\t\t\tif (!nameParts.isEmpty()) firstName = parsePartOfName(nameParts, new StringJoiner(\" \"), firstNamePattern);\n\n\t\t\t\t// join last names to single string with ' ' as delimiter\n\t\t\t\tif (!nameParts.isEmpty()) lastName = parsePartOfName(nameParts, new StringJoiner(\" \"), lastNamePattern);\n\n\t\t\t\t// if any nameParts are left join them to one string with ' ' as delimiter and assume they are titles after name\n\t\t\t\tif (!nameParts.isEmpty()) {\n\t\t\t\t\tStringJoiner titleAfterBuilder = new StringJoiner(\" \");\n\t\t\t\t\tfor (String namePart : nameParts) {\n\t\t\t\t\t\ttitleAfterBuilder.add(namePart);\n\t\t\t\t\t}\n\t\t\t\t\ttitleAfter = titleAfterBuilder.toString();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// add variables to map, empty string means null\n\t\tif (titleBefore.isEmpty()) titleBefore = null;\n\t\tparsedName.put(TITLE_BEFORE, titleBefore);\n\t\tif (firstName.isEmpty()) firstName = null;\n\t\tparsedName.put(FIRST_NAME, firstName);\n\t\tif (lastName.isEmpty()) lastName = null;\n\t\tparsedName.put(LAST_NAME, lastName);\n\t\tif (titleAfter.isEmpty()) titleAfter = null;\n\t\tparsedName.put(TITLE_AFTER, titleAfter);\n\n\t\tif(fullNameRequired) {\n\t\t\tif (parsedName.get(FIRST_NAME) == null)\n\t\t\t\tthrow new ParseUserNameException(\"Unable to parse first name from text.\", rawName);\n\t\t\tif (parsedName.get(LAST_NAME) == null)\n\t\t\t\tthrow new ParseUserNameException(\"Unable to parse last name from text.\", rawName);\n\t\t}\n\n\t\treturn parsedName;\n\t}\n\n\tprivate static String parsePartOfName(List<String> nameParts, StringJoiner result, Pattern pattern) {\n\t\tMatcher matcher = pattern.matcher(nameParts.get(0));\n\n\t\t// if the matcher does not match continue to the next part of the name\n\t\tif (!matcher.matches()) return result.toString();\n\n\t\tresult.add(nameParts.get(0));\n\t\tnameParts.remove(0);\n\t\t// when nameParts are depleted or firstName was found there is no reason to continue the recursion\n\t\tif (nameParts.isEmpty() || pattern.equals(firstNamePattern)) return result.toString();\n\n\t\t// continue the recursion to find the next part\n\t\treturn parsePartOfName(nameParts, result, pattern);\n\t}\n\n\t/**\n\t * Recursive method used to find all classes in a given directory and subdirs.\n\t *\n\t * @param directory   The base directory\n\t * @param packageName The package name for classes found inside the base directory\n\t * @return The classes\n\t * @throws ClassNotFoundException\n\t */\n\tprivate static List<Class<?>> findClasses(File directory, String packageName) throws ClassNotFoundException {\n\t\tList<Class<?>> classes = new ArrayList<>();\n\t\tif (!directory.exists()) {\n\t\t\treturn classes;\n\t\t}\n\t\tFile[] files = directory.listFiles();\n\t\tif (files != null) {\n\t\t\tfor (File file : files) {\n\t\t\t\tif (file.isDirectory()) {\n\t\t\t\t\tassert !file.getName().contains(\".\");\n\t\t\t\t\tclasses.addAll(findClasses(file, packageName + \".\" + file.getName()));\n\t\t\t\t} else if (file.getName().endsWith(\".class\")) {\n\t\t\t\t\tclasses.add(Class.forName(packageName + '.' + file.getName().substring(0, file.getName().length() - 6)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn classes;\n\t}\n\t/**\n\t * Return true, if char on position in text is escaped by '\\' Return false,\n\t * if not.\n\t *\n\t * @param text text in which will be searching\n\t * @param position position in text <0-text.length>\n\t * @return true if char is escaped, false if not\n\t */\n\tpublic static boolean isEscaped(String text, int position) {\n\t\tboolean escaped = false;\n\t\twhile (text.charAt(position) == '\\\\') {\n\t\t\tescaped = !escaped;\n\t\t\tposition--;\n\t\t\tif (position < 0) {\n\t\t\t\treturn escaped;\n\t\t\t}\n\t\t}\n\t\treturn escaped;\n\t}\n\n\t/**\n\t * Serialize map to string\n\t *\n\t * @param map\n\t * @return string of escaped map\n\t */\n\tpublic static String serializeMapToString(Map<String, String> map) {\n\t\tif(map == null) return \"\\\\0\";\n\t\tMap<String, String> attrNew = new HashMap<>(map);\n\t\tSet<String> keys = new HashSet<>(attrNew.keySet());\n\t\tfor(String s: keys) {\n\t\t\tattrNew.put(\"<\" + BeansUtils.createEscaping(s) + \">\", \"<\" + BeansUtils.createEscaping(attrNew.get(s)) + \">\");\n\t\t\tattrNew.remove(s);\n\t\t}\n\t\treturn attrNew.toString();\n\t}\n\n\tpublic static Attribute copyAttributeToViAttributeWithoutValue(Attribute copyFrom, Attribute copyTo) {\n\t\tcopyTo.setValueCreatedAt(copyFrom.getValueCreatedAt());\n\t\tcopyTo.setValueCreatedBy(copyFrom.getValueCreatedBy());\n\t\tcopyTo.setValueModifiedAt(copyFrom.getValueModifiedAt());\n\t\tcopyTo.setValueModifiedBy(copyFrom.getValueModifiedBy());\n\t\treturn copyTo;\n\t}\n\n\tpublic static Attribute copyAttributeToVirtualAttributeWithValue(Attribute copyFrom, Attribute copyTo) {\n\t\tcopyTo.setValue(copyFrom.getValue());\n\t\tcopyTo.setValueCreatedAt(copyFrom.getValueCreatedAt());\n\t\tcopyTo.setValueCreatedBy(copyFrom.getValueCreatedBy());\n\t\tcopyTo.setValueModifiedAt(copyFrom.getValueModifiedAt());\n\t\tcopyTo.setValueModifiedBy(copyFrom.getValueModifiedBy());\n\t\treturn copyTo;\n\t}\n\n\t/**\n\t * Method generates strings by pattern.\n\t * The pattern is string with square brackets, e.g. \"a[1-3]b\". Then the content of the brackets\n\t * is distributed, so the list is [a1b, a2b, a3c].\n\t * Multibrackets are aslo allowed. For example \"a[00-01]b[90-91]c\" generates [a00b90c, a00b91c, a01b90c, a01b91c].\n\t *\n\t * @param pattern\n\t * @return list of all generated strings\n\t */\n\tpublic static List<String> generateStringsByPattern(String pattern) throws WrongPatternException {\n\t\tList<String> result = new ArrayList<>();\n\n\t\t// get chars between the brackets\n\t\tList<String> values = new ArrayList<>(Arrays.asList(pattern.split(\"\\\\[[^]]*]\")));\n\t\t// get content of the brackets\n\t\tList<String> generators = new ArrayList<>();\n\t\tPattern generatorPattern = Pattern.compile(\"\\\\[([^]]*)]\");\n\t\tMatcher m = generatorPattern.matcher(pattern);\n\t\twhile (m.find()) {\n\t\t\tgenerators.add(m.group(1));\n\t\t}\n\n\t\t// if values strings contain square brackets, wrong syntax, abort\n\t\tfor (String value: values) {\n\t\t\tif (value.contains(\"]\") || (value.contains(\"[\"))) {\n\t\t\t\tthrow new WrongPatternException(\"The pattern \\\"\" + pattern + \"\\\" has a wrong syntax. Too much closing brackets.\");\n\t\t\t}\n\t\t}\n\n\t\t// if generators strings contain square brackets, wrong syntax, abort\n\t\tfor (String generator: generators) {\n\t\t\tif (generator.contains(\"]\") || (generator.contains(\"[\"))) {\n\t\t\t\tthrow new WrongPatternException(\"The pattern \\\"\" + pattern + \"\\\" has a wrong syntax. Too much opening brackets.\");\n\t\t\t}\n\t\t}\n\n\t\t// list, that contains list for each generator, with already generated numbers\n\t\tList<List<String>> listOfGenerated = new ArrayList<>();\n\n\t\tPattern rangePattern = Pattern.compile(\"^(\\\\d+)-(\\\\d+)$\");\n\t\tfor (String range: generators) {\n\t\t\tm = rangePattern.matcher(range);\n\t\t\tif (m.find()) {\n\t\t\t\tString start = m.group(1);\n\t\t\t\tString end = m.group(2);\n\t\t\t\tint startNumber;\n\t\t\t\tint endNumber;\n\t\t\t\ttry {\n\t\t\t\t\tstartNumber = Integer.parseInt(start);\n\t\t\t\t\tendNumber = Integer.parseInt(end);\n\t\t\t\t} catch (NumberFormatException ex) {\n\t\t\t\t\tthrow new WrongPatternException(\"The pattern \\\"\" + pattern + \"\\\" has a wrong syntax. Wrong format of the range.\");\n\t\t\t\t}\n\n\t\t\t\t// if end is before start -> abort\n\t\t\t\tif (startNumber > endNumber) {\n\t\t\t\t\tthrow new WrongPatternException(\"The pattern \\\"\" + pattern + \"\\\" has a wrong syntax. Start number has to be lower than end number.\");\n\n\t\t\t\t}\n\n\t\t\t\t// find out, how many zeros are before start number\n\t\t\t\tint zerosInStart = 0;\n\t\t\t\tint counter = 0;\n\t\t\t\twhile ( (start.charAt(counter) == '0') && (counter < start.length()-1) ) {\n\t\t\t\t\tzerosInStart++;\n\t\t\t\t\tcounter++;\n\t\t\t\t}\n\n\t\t\t\tString zeros = start.substring(0, zerosInStart);\n\t\t\t\tint oldNumberOfDigits = String.valueOf(startNumber).length();\n\n\t\t\t\t// list of already generated numbers\n\t\t\t\tList<String> generated = new ArrayList<>();\n\t\t\t\twhile (endNumber >= startNumber) {\n\t\t\t\t\t// keep right number of zeros before number\n\t\t\t\t\tif (String.valueOf(startNumber).length() == oldNumberOfDigits +1) {\n\t\t\t\t\t\tif (!zeros.isEmpty()) zeros = zeros.substring(1);\n\t\t\t\t\t}\n\t\t\t\t\tgenerated.add(zeros + startNumber);\n\t\t\t\t\toldNumberOfDigits = String.valueOf(startNumber).length();\n\t\t\t\t\tstartNumber++;\n\t\t\t\t}\n\n\t\t\t\tlistOfGenerated.add(generated);\n\n\t\t\t} else {\n\t\t\t\t// range is not in the format number-number -> abort\n\t\t\t\tthrow new WrongPatternException(\"The pattern \\\"\" + pattern + \"\\\" has a wrong syntax. The format numer-number not found.\");\n\t\t\t}\n\t\t}\n\n\t\t// add values among the generated numbers as one item lists\n\t\tList<List<String>> listOfGeneratorsAndValues = new ArrayList<>();\n\t\tint index = 0;\n\n\t\tfor (List<String> list : listOfGenerated) {\n\t\t\tif (index < values.size()) {\n\t\t\t\tList<String> listWithValue = new ArrayList<>();\n\t\t\t\tlistWithValue.add(values.get(index));\n\t\t\t\tlistOfGeneratorsAndValues.add(listWithValue);\n\t\t\t\tindex++;\n\t\t\t}\n\t\t\tlistOfGeneratorsAndValues.add(list);\n\t\t}\n\n\t\t// complete list with remaining values\n\t\tfor (int i = index; i < values.size(); i++) {\n\t\t\tList<String> listWithValue = new ArrayList<>();\n\t\t\tlistWithValue.add(values.get(i));\n\t\t\tlistOfGeneratorsAndValues.add(listWithValue);\n\t\t}\n\n\t\t// generate all posibilities\n\t\treturn getCombinationsOfLists(listOfGeneratorsAndValues);\n\t}\n\n\t/**\n\t * Method generates all combinations of joining of strings.\n\t * It respects given order of lists.\n\t * Example: input: [[a,b],[c,d]], output: [ac,ad,bc,bd]\n\t * @param lists list of lists, which will be joined\n\t * @return all joined strings\n\t */\n\tprivate static List<String> getCombinationsOfLists(List<List<String>> lists) {\n\t\tif (lists.isEmpty()) {\n\t\t\t// this should not happen\n\t\t\treturn new ArrayList<>();\n\t\t}\n\t\tif (lists.size() == 1) {\n\t\t\treturn lists.get(0);\n\t\t}\n\t\tList<String> result = new ArrayList<>();\n\n\t\tList<String> list = lists.remove(0);\n\t\t// get recursively all posibilities without first list\n\t\tList<String> posibilities = getCombinationsOfLists(lists);\n\n\t\t// join all strings from first list with the others\n\t\tfor (String item: list) {\n\t\t\tif (posibilities.isEmpty()) {\n\t\t\t\tresult.add(item);\n\t\t\t} else {\n\t\t\t\tfor (String itemToConcat : posibilities) {\n\t\t\t\t\tresult.add(item + itemToConcat);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Return encrypted version of input in UTF-8 by HmacSHA256\n\t *\n\t * @param input input to encrypt\n\t * @return encrypted value\n\t */\n\tpublic static String getMessageAuthenticationCode(String input) {\n\n\t\tif (input == null)\n\t\t\tthrow new NullPointerException(\"input must not be null\");\n\t\ttry {\n\t\t\tMac mac = Mac.getInstance(\"HmacSHA256\");\n\t\t\tmac.init(new SecretKeySpec(BeansUtils.getCoreConfig().getMailchangeSecretKey().getBytes(StandardCharsets.UTF_8),\"HmacSHA256\"));\n\t\t\tbyte[] macbytes = mac.doFinal(input.getBytes(StandardCharsets.UTF_8));\n\t\t\treturn new BigInteger(macbytes).toString(Character.MAX_RADIX);\n\t\t} catch (Exception e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\n\t}\n\n\t/**\n\t * Send validation email related to requested change of users preferred email.\n\t *\n\t * @param user user to change preferred email for\n\t * @param url base URL of running perun instance passed from RPC\n\t * @param email new email address to send notification to\n\t * @param changeId ID of change request in DB\n\t * @param subject Template subject or null\n\t * @param content Template message or null\n\t * @throws InternalErrorException\n\t */\n\tpublic static void sendValidationEmail(User user, String url, String email, int changeId, String subject, String content) throws InternalErrorException {\n\n\t\t// create mail sender\n\t\tJavaMailSenderImpl mailSender = new JavaMailSenderImpl();\n\t\tmailSender.setHost(\"localhost\");\n\n\t\t// create message\n\t\tSimpleMailMessage message = new SimpleMailMessage();\n\t\tmessage.setTo(email);\n\t\tmessage.setFrom(BeansUtils.getCoreConfig().getMailchangeBackupFrom());\n\n\t\tString instanceName = BeansUtils.getCoreConfig().getInstanceName();\n\n\t\tif (subject == null ||subject.isEmpty()) {\n\t\t\tmessage.setSubject(\"[\"+instanceName+\"] New email address verification\");\n\t\t} else {\n\t\t\tsubject = subject.replace(\"{instanceName}\", instanceName);\n\t\t\tmessage.setSubject(subject);\n\t\t}\n\n\t\t// get validation link params\n\t\tString i = Integer.toString(changeId, Character.MAX_RADIX);\n\t\tString m = Utils.getMessageAuthenticationCode(i);\n\n\t\ttry {\n\n\t\t\t// !! There is a hard-requirement for Perun instance\n\t\t\t// to host GUI on same server as RPC like: \"serverUrl/gui/\"\n\n\t\t\tURL urlObject = new URL(url);\n\n\t\t\t// use default if unknown rpc path\n\t\t\tString path = \"/gui/\";\n\n\t\t\tif (urlObject.getPath().contains(\"/krb/\")) {\n\t\t\t\tpath = \"/krb/gui/\";\n\t\t\t} else if (urlObject.getPath().contains(\"/fed/\")) {\n\t\t\t\tpath = \"/fed/gui/\";\n\t\t\t} else if (urlObject.getPath().contains(\"/cert/\")) {\n\t\t\t\tpath = \"/cert/gui/\";\n\t\t\t}\n\n\t\t\tStringBuilder link = new StringBuilder();\n\n\t\t\tlink.append(urlObject.getProtocol());\n\t\t\tlink.append(\"://\");\n\t\t\tlink.append(urlObject.getHost());\n\t\t\tlink.append(path);\n\t\t\tlink.append(\"?i=\");\n\t\t\tlink.append(URLEncoder.encode(i, \"UTF-8\"));\n\t\t\tlink.append(\"&m=\");\n\t\t\tlink.append(URLEncoder.encode(m, \"UTF-8\"));\n\t\t\tlink.append(\"&u=\" + user.getId());\n\n\t\t\t// Build message\n\t\t\tString text = \"Dear \"+user.getDisplayName()+\",\\n\\nWe've received request to change your preferred email address to: \"+email+\".\"+\n\t\t\t\t\t\"\\n\\nTo confirm this change please use link below:\\n\\n\"+link+\"\\n\\n\" +\n\t\t\t\t\t\"Message is automatically generated.\" +\n\t\t\t\t\t\"\\n----------------------------------------------------------------\" +\n\t\t\t\t\t\"\\nPerun - Identity & Access Management System\";\n\n\t\t\tif (content == null || content.isEmpty()) {\n\t\t\t\tmessage.setText(text);\n\t\t\t} else {\n\t\t\t\tcontent = content.replace(\"{link}\",link);\n\t\t\t\tmessage.setText(content);\n\t\t\t}\n\n\t\t\tmailSender.send(message);\n\n\t\t} catch (UnsupportedEncodingException ex) {\n\t\t\tthrow new InternalErrorException(\"Unable to encode validation URL for mail change.\", ex);\n\t\t} catch (MalformedURLException ex) {\n\t\t\tthrow new InternalErrorException(\"Not valid URL of running Perun instance.\", ex);\n\t\t}\n\n\t}\n\n\t/**\n\t * Sends email with link to non-authz password reset GUI where user\n\t * can reset forgotten password\n\t *\n\t * @param user user to send notification for\n\t * @param email user's email to send notification to\n\t * @param namespace namespace to reset password in\n\t * @param url base URL of Perun instance\n\t * @param id ID of pwd reset request\n\t * @param messageTemplate message of the email\n\t * @param subject subject of the email\n\t * @throws InternalErrorException\n\t */\n\tpublic static void sendPasswordResetEmail(User user, String email, String namespace, String url, int id, String messageTemplate, String subject) throws InternalErrorException {\n\n\t\t// create mail sender\n\t\tJavaMailSender mailSender = BeansUtils.getDefaultMailSender();\n\n\t\t// create message\n\t\tSimpleMailMessage message = new SimpleMailMessage();\n\t\tmessage.setTo(email);\n\t\tmessage.setFrom(BeansUtils.getCoreConfig().getMailchangeBackupFrom());\n\n\t\tString instanceName = BeansUtils.getCoreConfig().getInstanceName();\n\n\t\tif (subject == null) {\n\t\t\tmessage.setSubject(\"[\" + instanceName + \"] Password reset in namespace: \" + namespace);\n\t\t} else {\n\t\t\tsubject = subject.replace(\"{namespace}\", namespace);\n\t\t\tsubject = subject.replace(\"{instanceName}\", instanceName);\n\t\t\tmessage.setSubject(subject);\n\t\t}\n\n\t\t// get validation link params\n\t\tString i = cipherInput(String.valueOf(user.getId()), false);\n\t\tString m = cipherInput(String.valueOf(id), false);\n\n\t\ttry {\n\n\t\t\tURL urlObject = new URL(url);\n\n\t\t\tStringBuilder link = new StringBuilder();\n\n\t\t\tlink.append(urlObject.getProtocol());\n\t\t\tlink.append(\"://\");\n\t\t\tlink.append(urlObject.getHost());\n\t\t\t// reset link uses non-authz\n\t\t\tlink.append(\"/non/pwd-reset/\");\n\t\t\tlink.append(\"?i=\");\n\t\t\tlink.append(URLEncoder.encode(i, \"UTF-8\"));\n\t\t\tlink.append(\"&m=\");\n\t\t\tlink.append(URLEncoder.encode(m, \"UTF-8\"));\n\t\t\t// append login-namespace so GUI is themes and password checked by namespace rules\n\t\t\tlink.append(\"&login-namespace=\");\n\t\t\tlink.append(URLEncoder.encode(namespace, \"UTF-8\"));\n\n\t\t\t//validity formatting\n\t\t\tString validity = Integer.toString(BeansUtils.getCoreConfig().getPwdresetValidationWindow());\n\t\t\tDateTimeFormatter dtf = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\");\n\t\t\tLocalDateTime localDateTime = LocalDateTime.now().plusHours(Integer.parseInt(validity));\n\t\t\tString validityFormatted = dtf.format(localDateTime);\n\n\t\t\t// Build message en\n\t\t\tString textEn = \"Dear \" + user.getDisplayName() + \",\\n\\nWe've received request to reset your password in namespace \\\"\" + namespace + \"\\\".\" +\n\t\t\t\t\t\"\\n\\nPlease visit the link below, where you can set new password:\\n\\n\" + link + \"\\n\\n\" +\n\t\t\t\t\t\"Link is valid till \" + validityFormatted + \"\\n\\n\" +\n\t\t\t\t\t\"Message is automatically generated.\" +\n\t\t\t\t\t\"\\n----------------------------------------------------------------\" +\n\t\t\t\t\t\"\\nPerun - Identity & Access Management System\";\n\n\n\t\t\tif (messageTemplate == null) {\n\t\t\t\tmessage.setText(textEn);\n\t\t\t} else {\n\n\t\t\t\t// allow enforcing per-language links\n\t\t\t\tif (messageTemplate.contains(\"{link-\")) {\n\t\t\t\t\tPattern pattern = Pattern.compile(\"\\\\{link-[^}]+}\");\n\t\t\t\t\tMatcher matcher = pattern.matcher(messageTemplate);\n\t\t\t\t\twhile (matcher.find()) {\n\n\t\t\t\t\t\t// whole \"{link-something}\"\n\t\t\t\t\t\tString toSubstitute = matcher.group(0);\n\t\t\t\t\t\tString langLink = link.toString();\n\n\t\t\t\t\t\tPattern namespacePattern = Pattern.compile(\"-(.*?)}\");\n\t\t\t\t\t\tMatcher m2 = namespacePattern.matcher(toSubstitute);\n\t\t\t\t\t\tif (m2.find()) {\n\t\t\t\t\t\t\t// only language \"cs\", \"en\",...\n\t\t\t\t\t\t\tString lang = m2.group(1);\n\t\t\t\t\t\t\tlangLink = langLink + \"&locale=\" + lang;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmessageTemplate = messageTemplate.replace(toSubstitute, langLink);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmessageTemplate = messageTemplate.replace(\"{link}\", link);\n\t\t\t\t}\n\t\t\t\tmessageTemplate = messageTemplate.replace(\"{displayName}\", user.getDisplayName());\n\t\t\t\tmessageTemplate = messageTemplate.replace(\"{namespace}\", namespace);\n\t\t\t\tmessageTemplate = messageTemplate.replace(\"{validity}\", validityFormatted);\n\t\t\t\tmessage.setText(messageTemplate);\n\t\t\t}\n\n\t\t\tmailSender.send(message);\n\n\t\t} catch (MailException ex) {\n\t\t\tthrow new InternalErrorException(\"Unable to send mail for password reset.\", ex);\n\t\t} catch (UnsupportedEncodingException ex) {\n\t\t\tthrow new InternalErrorException(\"Unable to encode URL for password reset.\", ex);\n\t\t} catch (MalformedURLException ex) {\n\t\t\tthrow new InternalErrorException(\"Not valid URL of running Perun instance.\", ex);\n\t\t}\n\n\t}\n\n\t/**\n\t * Sends email to user confirming his password was changed.\n\t *\n\t * @param user user to send notification for\n\t * @param email user's email to send notification to\n\t * @param namespace namespace the password was re-set\n\t * @param login login of user\n\t * @param subject Subject from template or null\n\t * @param content Message from template or null\n\t */\n\tpublic static void sendPasswordResetConfirmationEmail(User user, String email, String namespace, String login, String subject, String content) {\n\n\t\t// create mail sender\n\t\tJavaMailSender mailSender = BeansUtils.getDefaultMailSender();\n\n\t\t// create message\n\t\tSimpleMailMessage message = new SimpleMailMessage();\n\t\tmessage.setTo(email);\n\t\tmessage.setFrom(BeansUtils.getCoreConfig().getMailchangeBackupFrom());\n\n\t\tString instanceName = BeansUtils.getCoreConfig().getInstanceName();\n\n\t\tif (subject == null || subject.isEmpty()) {\n\t\t\tmessage.setSubject(\"[\"+instanceName+\"] Password reset in namespace: \"+namespace);\n\t\t} else {\n\t\t\tsubject = subject.replace(\"{namespace}\", namespace);\n\t\t\tsubject = subject.replace(\"{instanceName}\", instanceName);\n\t\t\tmessage.setSubject(subject);\n\t\t}\n\n\t\t// Build message\n\t\tString text = \"Dear \"+user.getDisplayName()+\",\\n\\nyour password in namespace \\\"\"+namespace+\"\\\" was successfully reset.\"+\n\t\t\t\t\"\\n\\nThis message is automatically sent to all your email addresses registered in \"+instanceName+\" in order to prevent malicious password reset without your knowledge.\\n\\n\" +\n\t\t\t\t\"If you didn't request / perform password reset, please notify your administrators and support at \"+BeansUtils.getCoreConfig().getMailchangeBackupFrom()+\" to resolve this security issue.\\n\\n\" +\n\t\t\t\t\"Message is automatically generated.\" +\n\t\t\t\t\"\\n----------------------------------------------------------------\" +\n\t\t\t\t\"\\nPerun - Identity & Access Management System\";\n\n\t\tif (content == null || content.isEmpty()) {\n\t\t\tmessage.setText(text);\n\t\t} else {\n\t\t\tcontent = content.replace(\"{displayName}\", user.getDisplayName());\n\t\t\tcontent = content.replace(\"{namespace}\", namespace);\n\t\t\tcontent = content.replace(\"{login}\", login);\n\t\t\tcontent = content.replace(\"{instanceName}\", instanceName);\n\t\t\tmessage.setText(content);\n\t\t}\n\n\t\tmailSender.send(message);\n\n\t}\n\n\t/**\n\t * Return en/decrypted version of input using AES/CBC/PKCS5PADDING cipher.\n\t * Perun's internal secretKey and initVector are used (you can configure them in\n\t * perun.properties file).\n\t *\n\t * @param plainText text to en/decrypt\n\t * @param decrypt TRUE = decrypt input / FALSE = encrypt input\n\t * @return en/decrypted text\n\t * @throws cz.metacentrum.perun.core.api.exceptions.InternalErrorException if anything fails\n\t */\n\tpublic static String cipherInput(String plainText, boolean decrypt) throws InternalErrorException {\n\n\t\ttry {\n\n\t\t\tString encryptionKey = BeansUtils.getCoreConfig().getPwdresetSecretKey();\n\t\t\tString initVector = BeansUtils.getCoreConfig().getPwdresetInitVector();\n\n\t\t\tCipher c = Cipher.getInstance(\"AES/CBC/PKCS5PADDING\");\n\t\t\tSecretKeySpec k = new SecretKeySpec(encryptionKey.getBytes(StandardCharsets.UTF_8), \"AES\");\n\t\t\tc.init((decrypt) ? Cipher.DECRYPT_MODE : Cipher.ENCRYPT_MODE, k, new IvParameterSpec(initVector.getBytes(StandardCharsets.UTF_8)));\n\n\t\t\tif (decrypt) {\n\n\t\t\t\tbyte[] bytes = Base64.decodeBase64(plainText.getBytes(StandardCharsets.UTF_8));\n\t\t\t\treturn new String(c.doFinal(bytes), StandardCharsets.UTF_8);\n\n\t\t\t} else {\n\n\t\t\t\tbyte[] bytes = Base64.encodeBase64(c.doFinal(plainText.getBytes(StandardCharsets.UTF_8)));\n\t\t\t\treturn new String(bytes, StandardCharsets.UTF_8);\n\n\t\t\t}\n\n\t\t} catch (Exception ex) {\n\n\t\t\tthrow new InternalErrorException(\"Error when encrypting message\", ex);\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Checks whether the destination is not null and is of the right type.\n\t *\n\t * @param destination destination to check\n\t * @throws cz.metacentrum.perun.core.api.exceptions.InternalErrorException if destination is null\n\t * @throws cz.metacentrum.perun.core.api.exceptions.WrongPatternException if destination is not of the right type\n\t */\n\tpublic static void checkDestinationType(Destination destination) throws InternalErrorException, WrongPatternException  {\n\t\tif (destination == null) {\n\t\t\tthrow new InternalErrorException(\"Destination is null.\");\n\t\t}\n\t\tString destinationType = destination.getType();\n\t\tif ((!Objects.equals(destinationType, Destination.DESTINATIONHOSTTYPE)\n\t\t\t\t&& (!Objects.equals(destinationType, Destination.DESTINATIONEMAILTYPE))\n\t\t\t\t&& (!Objects.equals(destinationType, Destination.DESTINATIONSEMAILTYPE))\n\t\t\t\t&& (!Objects.equals(destinationType, Destination.DESTINATIONURLTYPE))\n\t\t\t\t&& (!Objects.equals(destinationType, Destination.DESTINATIONUSERHOSTTYPE))\n\t\t\t\t&& (!Objects.equals(destinationType, Destination.DESTINATIONUSERHOSTPORTTYPE))\n\t\t\t\t&& (!Objects.equals(destinationType, Destination.DESTINATIONSERVICESPECIFICTYPE))\n\t\t\t\t&& (!Objects.equals(destinationType, Destination.DESTINATIONWINDOWS))\n\t\t\t\t&& (!Objects.equals(destinationType, Destination.DESTINATIONWINDOWSPROXY)))) {\n\t\t\tthrow new WrongPatternException(\"Destination type \" + destinationType + \" is not supported.\");\n\t\t}\n\t}\n\n\t/**\n\t * Sends SMS to the phone number of a user with the given message.\n\t * The phone number is taken from the user attribute urn:perun:user:attribute-def:def:phone.\n\t *\n\t * @param sess session\n\t * @param user receiver of the message\n\t * @param message sms message to send\n\t * @throws InternalErrorException when the attribute value cannot be found or is broken\n\t * @throws cz.metacentrum.perun.core.api.exceptions.PrivilegeException when the actor has not right to get the attribute\n\t * @throws cz.metacentrum.perun.core.api.exceptions.UserNotExistsException when given user does not exist\n\t */\n\tpublic static void sendSMS(PerunSession sess, User user, String message) throws InternalErrorException, PrivilegeException, UserNotExistsException {\n\t\tif (user == null) {\n\t\t\tthrow new cz.metacentrum.perun.core.api.exceptions.IllegalArgumentException(\"user is null\");\n\t\t}\n\t\tif (message == null) {\n\t\t\tthrow new cz.metacentrum.perun.core.api.exceptions.IllegalArgumentException(\"message is null\");\n\t\t}\n\t\tString telNumber;\n\t\ttry {\n\t\t\ttelNumber = (String) sess.getPerun().getAttributesManager().getAttribute(sess, user, userPhoneAttribute).getValue();\n\t\t} catch (AttributeNotExistsException ex ) {\n\t\t\tlog.error(\"Sendig SMS with text \\\"{}\\\" to user {} failed: cannot get tel. number.\", message, user );\n\t\t\tthrow new InternalErrorException(\"The attribute \" + userPhoneAttribute + \" has not been found.\", ex);\n\t\t} catch (WrongAttributeAssignmentException ex) {\n\t\t\tlog.error(\"Sendig SMS with text \\\"{}\\\" to user {} failed: cannot get tel. number.\", message, user );\n\t\t\tthrow new InternalErrorException(\"The attribute \" + userPhoneAttribute + \" has not been found in user attributes.\", ex);\n\t\t}\n\t\tsendSMS(telNumber, message);\n\t}\n\n\t/**\n\t * Sends SMS to the phone number of a member with the given message.\n\t * The phone number is taken from the user attribute urn:perun:member:attribute-def:def:phone.\n\t *\n\t * @param sess session\n\t * @param member receiver of the message\n\t * @param message sms message to send\n\t * @throws InternalErrorException when the attribute value cannot be found or is broken\n\t * @throws cz.metacentrum.perun.core.api.exceptions.PrivilegeException when the actor has not right to get the attribute\n\t * @throws cz.metacentrum.perun.core.api.exceptions.MemberNotExistsException when given member does not exist\n\t */\n\tpublic static void sendSMS(PerunSession sess, Member member, String message) throws InternalErrorException, PrivilegeException, MemberNotExistsException {\n\t\tString telNumber;\n\t\ttry {\n\t\t\ttelNumber = (String) sess.getPerun().getAttributesManager().getAttribute(sess, member, memberPhoneAttribute).getValue();\n\t\t} catch (AttributeNotExistsException ex) {\n\t\t\tlog.error(\"Sendig SMS with text \\\"{}\\\" to member {} failed: cannot get tel. number.\", message, member );\n\t\t\tthrow new InternalErrorException(\"The attribute \" + memberPhoneAttribute + \" has not been found.\", ex);\n\t\t} catch (WrongAttributeAssignmentException ex) {\n\t\t\tlog.error(\"Sendig SMS with text \\\"{}\\\" to member {} failed: cannot get tel. number.\", message, member );\n\t\t\tthrow new InternalErrorException(\"The attribute \" + memberPhoneAttribute + \" has not been found in user attributes.\", ex);\n\t\t}\n\t\tsendSMS(telNumber, message);\n\t}\n\n\t/**\n\t * Sends SMS to the phone number with the given message.\n\t * The sending provides external program for sending sms.\n\t * Its path is saved in the perun property perun.sms.program.\n\t *\n\t * @param telNumber phone number of the receiver\n\t * @param message sms message to send\n\t * @throws InternalErrorException when there is something wrong with external program\n\t * @throws IllegalArgumentException when the phone or message has a wrong format\n\t */\n\tpublic static void sendSMS(String telNumber, String message) throws InternalErrorException {\n\t\tlog.debug(\"Sending SMS with text \\\"{}\\\" to tel. number {}.\", message, telNumber);\n\n\t\ttry {\n\t\t\t// create properties list\n\t\t\tList<String> processProperties = new ArrayList<>();\n\t\t\t// pass the location of external program for sending sms\n\t\t\tprocessProperties.add(BeansUtils.getCoreConfig().getSmsProgram());\n\t\t\t// pass program options\n\t\t\tprocessProperties.add(\"-p\");\n\t\t\tprocessProperties.add(telNumber);\n\t\t\tprocessProperties.add(\"-m\");\n\t\t\tprocessProperties.add(message);\n\t\t\t// execute\n\t\t\tProcessBuilder pb = new ProcessBuilder(processProperties);\n\t\t\tProcess process;\n\t\t\tprocess = pb.start();\n\t\t\tint exitValue;\n\t\t\ttry {\n\t\t\t\texitValue = process.waitFor();\n\t\t\t} catch (InterruptedException ex) {\n\t\t\t\tString errMsg = \"The external process for sending sms was interrupted.\";\n\t\t\t\tlog.error(\"Sending SMS with text \\\"{}\\\" to tel. number {} failed.\", message, telNumber);\n\t\t\t\tthrow new InternalErrorException(errMsg, ex);\n\t\t\t}\n\n\t\t\t// handle response\n\t\t\tif (exitValue == 0) {\n\t\t\t\t// successful\n\t\t\t\tlog.debug(\"SMS with text \\\"{}\\\" to tel. number {} successfully sent.\", message, telNumber);\n\t\t\t} else if ((exitValue == 1) || (exitValue == 2)) {\n\t\t\t\t// users fault\n\t\t\t\tString errMsg = getStringFromInputStream(process.getErrorStream());\n\t\t\t\tlog.error(\"Sending SMS with text \\\"{}\\\" to tel. number {} failed.\", message, telNumber);\n\t\t\t\tthrow new cz.metacentrum.perun.core.api.exceptions.IllegalArgumentException(errMsg);\n\t\t\t} else if (exitValue > 2) {\n\t\t\t\t// internal fault\n\t\t\t\tString errMsg = getStringFromInputStream(process.getErrorStream());\n\t\t\t\tlog.error(\"Sending SMS with text \\\"{}\\\" to tel. number {} failed.\", message, telNumber);\n\t\t\t\tthrow new InternalErrorException(errMsg);\n\t\t\t}\n\n\t\t} catch (IOException ex) {\n\t\t\tlog.warn(\"Sending SMS with text \\\"{}\\\" to tel. number {} failed.\", message, telNumber);\n\t\t\tthrow new InternalErrorException(\"Cannot access the sms external application.\", ex);\n\t\t}\n\n\t}\n\n\t/**\n\t * Get BigDecimal number like '1024' in Bytes and create better readable\n\t * String with metric value like '1K' where K means KiloBytes.\n\t *\n\t * Use M,G,T,P,E like multipliers of 1024.\n\t *\n\t * If quota is not dividable by 1024 use B (Bytes) without dividing.\n\t *\n\t * @param quota in big natural number\n\t * @return string with number and metric\n\t */\n\tpublic static String bigDecimalBytesToReadableStringWithMetric(BigDecimal quota) throws InternalErrorException {\n\t\tif(quota == null) throw new InternalErrorException(\"Quota in BigDecimal can't be null if we want to convert it to number with metric.\");\n\t\t//Prepare variable for result\n\t\tString stringWithMetric;\n\t\t//Try to divide quota to get result module 1024^x = 0 where X is in [K-0,M-1,G-2,T-3,P-4,E-5]\n\t\t//If module is bigger than 0, try x-1\n\t\tif(!quota.divide(BigDecimal.valueOf(ModulesUtilsBlImpl.E)).stripTrailingZeros().toPlainString().contains(\".\")) {\n\t\t\t//divide by 1024^5\n\t\t\tstringWithMetric = quota.divide(BigDecimal.valueOf(ModulesUtilsBlImpl.E)).stripTrailingZeros().toPlainString() + \"E\";\n\t\t} else if(!quota.divide(BigDecimal.valueOf(ModulesUtilsBlImpl.P)).stripTrailingZeros().toPlainString().contains(\".\")) {\n\t\t\t//divide by 1024^4\n\t\t\tstringWithMetric = quota.divide(BigDecimal.valueOf(ModulesUtilsBlImpl.P)).stripTrailingZeros().toPlainString() + \"P\";\n\t\t} else if(!quota.divide(BigDecimal.valueOf(ModulesUtilsBlImpl.T)).stripTrailingZeros().toPlainString().contains(\".\")) {\n\t\t\t//divide by 1024^3\n\t\t\tstringWithMetric = quota.divide(BigDecimal.valueOf(ModulesUtilsBlImpl.T)).stripTrailingZeros().toPlainString() + \"T\";\n\t\t} else if(!quota.divide(BigDecimal.valueOf(ModulesUtilsBlImpl.G)).stripTrailingZeros().toPlainString().contains(\".\")) {\n\t\t\t//divide by 1024^2\n\t\t\tstringWithMetric = quota.divide(BigDecimal.valueOf(ModulesUtilsBlImpl.G)).stripTrailingZeros().toPlainString() + \"G\";\n\t\t} else if(!quota.divide(BigDecimal.valueOf(ModulesUtilsBlImpl.M)).stripTrailingZeros().toPlainString().contains(\".\")) {\n\t\t\t//divide by 1024^1\n\t\t\tstringWithMetric = quota.divide(BigDecimal.valueOf(ModulesUtilsBlImpl.M)).stripTrailingZeros().toPlainString() + \"M\";\n\t\t} else {\n\t\t\t//can't be diveded by 1024^x where x>0 so let it be in the format like it already is, convert it to BigInteger without fractional part\n\t\t\tstringWithMetric = quota.toBigInteger().toString() + \"K\";\n\t\t}\n\t\t//return result format with metric\n\t\treturn stringWithMetric;\n\t}\n\n\tprivate static String getStringFromInputStream(InputStream is) throws IOException {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(is));\n\t\tStringBuilder out = new StringBuilder();\n\t\tString line;\n\t\twhile ((line = reader.readLine()) != null) {\n\t\t\tout.append(line);\n\t\t}\n\t\treturn out.toString();\n\t}\n\n\t/**\n\t * IMPORTANT: this method not convert utf to ascii, just try to convert some problematic\n\t * chars to UTF and others change to '?'!!!\n\t *\n\t * @param s\n\t * @return converted string from ascii to something near utf\n\t */\n\tpublic synchronized static String utftoasci(String s){\n\t\tfinal StringBuilder sb = new StringBuilder( s.length() * 2 );\n\n\t\tfinal StringCharacterIterator iterator = new StringCharacterIterator( s );\n\n\t\tchar ch = iterator.current();\n\n\t\twhile( ch != StringCharacterIterator.DONE ){\n\t\t\tif(Character.getNumericValue(ch)>=0){\n\t\t\t\tsb.append( ch );\n\t\t\t}else{\n\t\t\t\tboolean f=false;\n\t\t\t\tif(Character.toString(ch).equals(\"\u00ca\")){sb.append(\"E\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u00c8\")){sb.append(\"E\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u00eb\")){sb.append(\"e\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u00e9\")){sb.append(\"e\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u00e8\")){sb.append(\"e\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u00c2\")){sb.append(\"A\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u00e4\")){sb.append(\"a\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u00df\")){sb.append(\"ss\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u00c7\")){sb.append(\"C\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u00d6\")){sb.append(\"O\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u00ba\")){sb.append(\"\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u00aa\")){sb.append(\"\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u00ba\")){sb.append(\"\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u00d1\")){sb.append(\"N\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u00c9\")){sb.append(\"E\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u00c4\")){sb.append(\"A\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u00c5\")){sb.append(\"A\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u00dc\")){sb.append(\"U\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u00f6\")){sb.append(\"o\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u00fc\")){sb.append(\"u\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u00e1\")){sb.append(\"a\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u00d3\")){sb.append(\"O\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u011b\")){sb.append(\"e\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u011a\")){sb.append(\"E\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u0161\")){sb.append(\"s\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u0160\")){sb.append(\"S\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u010d\")){sb.append(\"c\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u010c\")){sb.append(\"C\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u0159\")){sb.append(\"r\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u0158\")){sb.append(\"R\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u017e\")){sb.append(\"z\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u017d\")){sb.append(\"Z\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u00fd\")){sb.append(\"y\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u00dd\")){sb.append(\"Y\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u00ed\")){sb.append(\"i\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u00cd\")){sb.append(\"I\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u00f3\")){sb.append(\"o\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u00fa\")){sb.append(\"u\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u00da\")){sb.append(\"u\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u016f\")){sb.append(\"u\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u016e\")){sb.append(\"U\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u0147\")){sb.append(\"N\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u0148\")){sb.append(\"n\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u0164\")){sb.append(\"T\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"\u0165\")){sb.append(\"t\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\" \")){sb.append(\" \");f=true;}\n\n\t\t\t\tif(!f){\n\t\t\t\t\tsb.append(\"?\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tch = iterator.next();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\t/**\n\t * Convert input string (expected UTF-8) to ASCII if possible.\n\t * Any non-ASCII character is replaced by replacement parameter.\n\t *\n\t * @param input String to convert from UTF-8 to ASCII.\n\t * @param replacement Replacement character used for all non-ASCII chars in input.\n\t * @return converted string from ascii to something near utf\n\t */\n\tpublic synchronized static String toASCII(String input, Character replacement) {\n\n\t\tString normalizedOutput = \"\";\n\n\t\t// take unicode characters one by one and normalize them\n\t\tfor ( int i=0; i<input.length(); i++ ) {\n\t\t\tchar c = input.charAt(i);\n\t\t\t// normalize a single unicode character, then remove every non-ascii symbol (like accents)\n\t\t\tString normalizedChar = Normalizer.normalize(String.valueOf(c) , Normalizer.Form.NFD).replaceAll(\"[^\\\\p{ASCII}]\", \"\");\n\n\t\t\tif ( ! normalizedChar.isEmpty() ) {\n\t\t\t\t// if there is a valid ascii representation, use it\n\t\t\t\tnormalizedOutput += normalizedChar;\n\t\t\t} else {\n\t\t\t\t// otherwise replace character with an \"replacement\"\n\t\t\t\tnormalizedOutput += replacement;\n\t\t\t}\n\t\t}\n\t\treturn normalizedOutput;\n\n\t}\n\n\t/**\n\t * Determine if attribute is large (can contain value over 4kb).\n\t *\n\t * @param sess perun session\n\t * @param attribute attribute to be checked\n\t * @return true if the attribute is large\n\t */\n\tpublic static boolean isLargeAttribute(PerunSession sess, AttributeDefinition attribute) {\n\t\treturn (attribute.getType().equals(LinkedHashMap.class.getName()) ||\n\t\t\t\tattribute.getType().equals(BeansUtils.largeStringClassName) ||\n\t\t\t\tattribute.getType().equals(BeansUtils.largeArrayListClassName));\n\t}\n\n\t/**\n\t * Extends given date by given period.\n\t *\n\t * @param localDate date to be extended\n\t * @param period period used to extend date\n\t * @throws InternalErrorException when the period has wrong format,\n\t * allowed format is given by regex \"\\\\+([0-9]+)([dmy]?)\"\n\t */\n\tpublic static LocalDate extendDateByPeriod(LocalDate localDate, String period) throws InternalErrorException {\n\t\t// We will add days/months/years\n\t\tPattern p = Pattern.compile(\"\\\\+([0-9]+)([dmy]?)\");\n\t\tMatcher m = p.matcher(period);\n\t\tif (m.matches()) {\n\t\t\tString countString = m.group(1);\n\t\t\tint amount = Integer.valueOf(countString);\n\n\t\t\tString dmyString = m.group(2);\n\t\t\tswitch (dmyString) {\n\t\t\t\tcase \"d\":\n\t\t\t\t\treturn localDate.plusDays(amount);\n\t\t\t\tcase \"m\":\n\t\t\t\t\treturn localDate.plusMonths(amount);\n\t\t\t\tcase \"y\":\n\t\t\t\t\treturn localDate.plusYears(amount);\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new InternalErrorException(\"Wrong format of period. Period: \" + period);\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new InternalErrorException(\"Wrong format of period. Period: \" + period);\n\t\t}\n\t}\n\n\t/**\n\t * Returns closest future LocalDate based on values given by matcher.\n\t * If returned value should fall to 29. 2. of non-leap year, the date is extended to 28. 2. instead.\n\t *\n\t * @param matcher matcher with day and month values\n\t * @return Extended date.\n\t */\n\tpublic static LocalDate getClosestExpirationFromStaticDate(Matcher matcher) {\n\t\tint day = Integer.parseInt(matcher.group(1));\n\t\tint month = Integer.parseInt(matcher.group(2));\n\n\t\t// We must detect if the extension date is in current year or in a next year (we use year 2000 in comparison because it is a leap year)\n\t\tLocalDate extensionDate = LocalDate.of(2000, month, day);\n\n\t\t// check if extension is next year\n\t\t// in case of static date being today's date, we want to extend to next year (that's why we use the negation later)\n\t\tboolean extensionInThisYear = LocalDate.of(2000, LocalDate.now().getMonth(), LocalDate.now().getDayOfMonth()).isBefore(extensionDate);\n\n\t\t// Get current year\n\t\tint year = LocalDate.now().getYear();\n\t\tif (!extensionInThisYear) {\n\t\t\t// Add year to get next year\n\t\t\tyear++;\n\t\t}\n\n\t\t// Set the date to which the membership should be extended, can be changed if there was grace period, see next part of the code\n\t\tif (day == 29 && month == 2 && !LocalDate.of(year, 1,1).isLeapYear()) {\n\t\t\t// If extended date is 29. 2. of non-leap year, the date is set to 28. 2.\n\t\t\textensionDate = LocalDate.of(year, 2, 28);\n\t\t} else {\n\t\t\textensionDate = LocalDate.of(year, month, day);\n\t\t}\n\n\t\treturn extensionDate;\n\t}\n\n\t/**\n\t * Prepares grace period date by values from given matcher.\n\t * @param matcher matcher\n\t * @return pair of field(ChronoUnit.YEARS, ChronoUnit.MONTHS, ChronoUnit.DAYS) and amount\n\t * @throws InternalErrorException when given matcher contains invalid data\n\t * @throws IllegalArgumentException when matcher does not match gracePeriod format\n\t */\n\tpublic static Pair<Integer, TemporalUnit> prepareGracePeriodDate(Matcher matcher) throws InternalErrorException {\n\t\tif (!matcher.matches()) {\n\t\t\tthrow new IllegalArgumentException(\"Wrong format of gracePeriod.\");\n\t\t}\n\t\tString countString = matcher.group(1);\n\t\tint amount = Integer.valueOf(countString);\n\n\t\tTemporalUnit field;\n\t\tString dmyString = matcher.group(2);\n\t\tswitch (dmyString) {\n\t\t\tcase \"d\":\n\t\t\t\tfield = ChronoUnit.DAYS;\n\t\t\t\tbreak;\n\t\t\tcase \"m\":\n\t\t\t\tfield = ChronoUnit.MONTHS;\n\t\t\t\tbreak;\n\t\t\tcase \"y\":\n\t\t\t\tfield = ChronoUnit.YEARS;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new InternalErrorException(\"Wrong format of gracePeriod.\");\n\t\t}\n\n\t\treturn new Pair<>(amount, field);\n\t}\n\n\t/**\n\t * We need to escape some special characters for LDAP filtering.\n\t * We need to escape these characters: '\\\\', '*', '(', ')', '\\000'\n\t *\n\t * @param searchString search string which need to be escaped properly\n\t * @return properly escaped search string\n\t */\n\tpublic static String escapeStringForLDAP(String searchString) {\n\t\tif(searchString == null) return \"\";\n\t\treturn searchString.replace(\"\\\\\", \"\\\\5C\").replace(\"*\", \"\\\\2A\").replace(\"(\", \"\\\\28\").replace(\")\", \"\\\\29\").replace(\"\\000\", \"\\\\00\");\n\t}\n}\n"], "filenames": ["perun-core/src/main/java/cz/metacentrum/perun/core/impl/ExtSourceLdap.java", "perun-core/src/main/java/cz/metacentrum/perun/core/impl/Utils.java"], "buggy_code_start_loc": [73, 1587], "buggy_code_end_loc": [91, 1587], "fixing_code_start_loc": [73, 1588], "fixing_code_end_loc": [91, 1600], "type": "CWE-732", "message": "In Perun before version 3.9.1, VO or group manager can modify configuration of the LDAP extSource to retrieve all from Perun LDAP. Issue is fixed in version 3.9.1 by sanitisation of the input.", "other": {"cve": {"id": "CVE-2020-5281", "sourceIdentifier": "security-advisories@github.com", "published": "2020-03-25T18:15:14.343", "lastModified": "2020-03-30T18:33:06.197", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Perun before version 3.9.1, VO or group manager can modify configuration of the LDAP extSource to retrieve all from Perun LDAP. Issue is fixed in version 3.9.1 by sanitisation of the input."}, {"lang": "es", "value": "En Perun versiones anteriores a 3.9.1, VO o el administrador de grupo pueden modificar la configuraci\u00f3n de LDAP extSource para recuperar todo desde Perun LDAP. El problema es corregido en la versi\u00f3n 3.9.1, mediante el saneamiento de la entrada."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:H/UI:R/S:C/C:H/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.2, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.0, "impactScore": 4.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-732"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-90"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:perun:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.9.1", "matchCriteriaId": "C41BD02A-99DF-4490-B354-9E883FF818DB"}]}]}], "references": [{"url": "https://github.com/CESNET/perun/commit/ac527bc3225a64208ee5cee59e5918ee360ca039", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/CESNET/perun/pull/2635", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/CESNET/perun/security/advisories/GHSA-gj88-9q3f-72m3", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/CESNET/perun/commit/ac527bc3225a64208ee5cee59e5918ee360ca039"}}