{"buggy_code": ["//---------------------------------------------------------------------------\r\n#include <vcl.h>\r\n#pragma hdrstop\r\n\r\n#include \"ScpFileSystem.h\"\r\n\r\n#include \"Terminal.h\"\r\n#include \"Common.h\"\r\n#include \"Exceptions.h\"\r\n#include \"Interface.h\"\r\n#include \"TextsCore.h\"\r\n#include \"HelpCore.h\"\r\n#include \"SecureShell.h\"\r\n#include <StrUtils.hpp>\r\n\r\n#include <stdio.h>\r\n//---------------------------------------------------------------------------\r\n#pragma package(smart_init)\r\n//---------------------------------------------------------------------------\r\n#define FILE_OPERATION_LOOP_TERMINAL FTerminal\r\n//---------------------------------------------------------------------------\r\nconst int coRaiseExcept = 1;\r\nconst int coExpectNoOutput = 2;\r\nconst int coWaitForLastLine = 4;\r\nconst int coOnlyReturnCode = 8;\r\nconst int coIgnoreWarnings = 16;\r\nconst int coReadProgress = 32;\r\n\r\nconst int ecRaiseExcept = 1;\r\nconst int ecIgnoreWarnings = 2;\r\nconst int ecReadProgress = 4;\r\nconst int ecDefault = ecRaiseExcept;\r\n//---------------------------------------------------------------------------\r\nDERIVE_EXT_EXCEPTION(EScpFileSkipped, ESkipFile);\r\n//===========================================================================\r\n#define MaxShellCommand fsLang\r\n#define ShellCommandCount MaxShellCommand + 1\r\n#define MaxCommandLen 40\r\nstruct TCommandType\r\n{\r\n  int MinLines;\r\n  int MaxLines;\r\n  bool ModifiesFiles;\r\n  bool ChangesDirectory;\r\n  bool InteractiveCommand;\r\n  wchar_t Command[MaxCommandLen];\r\n};\r\n\r\n// Only one character! See TSCPFileSystem::ReadCommandOutput()\r\n#define LastLineSeparator L\":\"\r\n#define LAST_LINE L\"WinSCP: this is end-of-file\"\r\n#define FIRST_LINE L\"WinSCP: this is begin-of-file\"\r\nextern const TCommandType DefaultCommandSet[];\r\n\r\n#define NationalVarCount 10\r\nextern const wchar_t NationalVars[NationalVarCount][15];\r\n\r\n#define CHECK_CMD DebugAssert((Cmd >=0) && (Cmd <= MaxShellCommand))\r\n\r\nclass TSessionData;\r\n//---------------------------------------------------------------------------\r\nclass TCommandSet\r\n{\r\nprivate:\r\n  TCommandType CommandSet[ShellCommandCount];\r\n  TSessionData * FSessionData;\r\n  UnicodeString FReturnVar;\r\n  int __fastcall GetMaxLines(TFSCommand Cmd);\r\n  int __fastcall GetMinLines(TFSCommand Cmd);\r\n  bool __fastcall GetModifiesFiles(TFSCommand Cmd);\r\n  bool __fastcall GetChangesDirectory(TFSCommand Cmd);\r\n  bool __fastcall GetOneLineCommand(TFSCommand Cmd);\r\n  void __fastcall SetCommands(TFSCommand Cmd, UnicodeString value);\r\n  UnicodeString __fastcall GetCommands(TFSCommand Cmd);\r\n  UnicodeString __fastcall GetFirstLine();\r\n  bool __fastcall GetInteractiveCommand(TFSCommand Cmd);\r\n  UnicodeString __fastcall GetLastLine();\r\n  UnicodeString __fastcall GetReturnVar();\r\npublic:\r\n  __fastcall TCommandSet(TSessionData *aSessionData);\r\n  void __fastcall Default();\r\n  void __fastcall CopyFrom(TCommandSet * Source);\r\n  UnicodeString __fastcall Command(TFSCommand Cmd, const TVarRec * args, int size);\r\n  TStrings * __fastcall CreateCommandList();\r\n  UnicodeString __fastcall FullCommand(TFSCommand Cmd, const TVarRec * args, int size);\r\n  static UnicodeString __fastcall ExtractCommand(UnicodeString Command);\r\n  __property int MaxLines[TFSCommand Cmd]  = { read=GetMaxLines};\r\n  __property int MinLines[TFSCommand Cmd]  = { read=GetMinLines };\r\n  __property bool ModifiesFiles[TFSCommand Cmd]  = { read=GetModifiesFiles };\r\n  __property bool ChangesDirectory[TFSCommand Cmd]  = { read=GetChangesDirectory };\r\n  __property bool OneLineCommand[TFSCommand Cmd]  = { read=GetOneLineCommand };\r\n  __property UnicodeString Commands[TFSCommand Cmd]  = { read=GetCommands, write=SetCommands };\r\n  __property UnicodeString FirstLine = { read = GetFirstLine };\r\n  __property bool InteractiveCommand[TFSCommand Cmd] = { read = GetInteractiveCommand };\r\n  __property UnicodeString LastLine  = { read=GetLastLine };\r\n  __property TSessionData * SessionData  = { read=FSessionData, write=FSessionData };\r\n  __property UnicodeString ReturnVar  = { read=GetReturnVar, write=FReturnVar };\r\n};\r\n//===========================================================================\r\nconst wchar_t NationalVars[NationalVarCount][15] =\r\n  {L\"LANG\", L\"LANGUAGE\", L\"LC_CTYPE\", L\"LC_COLLATE\", L\"LC_MONETARY\", L\"LC_NUMERIC\",\r\n   L\"LC_TIME\", L\"LC_MESSAGES\", L\"LC_ALL\", L\"HUMAN_BLOCKS\" };\r\nconst wchar_t FullTimeOption[] = L\"--full-time\";\r\n//---------------------------------------------------------------------------\r\n#define F false\r\n#define T true\r\n// TODO: remove \"mf\" and \"cd\", it is implemented in TTerminal already\r\nconst TCommandType DefaultCommandSet[ShellCommandCount] = {\r\n//                       min max mf cd ia  command\r\n/*Null*/                { -1, -1, F, F, F, L\"\" },\r\n/*VarValue*/            { -1, -1, F, F, F, L\"echo \\\"$%s\\\"\" /* variable */ },\r\n/*LastLine*/            { -1, -1, F, F, F, L\"echo \\\"%s\" LastLineSeparator \"%s\\\"\" /* last line, return var */ },\r\n/*FirstLine*/           { -1, -1, F, F, F, L\"echo \\\"%s\\\"\" /* first line */ },\r\n/*CurrentDirectory*/    {  1,  1, F, F, F, L\"pwd\" },\r\n/*ChangeDirectory*/     {  0,  0, F, T, F, L\"cd %s\" /* directory */ },\r\n// list directory can be empty on permission denied, this is handled in ReadDirectory\r\n/*ListDirectory*/       { -1, -1, F, F, F, L\"%s %s \\\"%s\\\"\" /* listing command, options, directory */ },\r\n/*ListCurrentDirectory*/{ -1, -1, F, F, F, L\"%s %s\" /* listing command, options */ },\r\n/*ListFile*/            {  1,  1, F, F, F, L\"%s -d %s \\\"%s\\\"\" /* listing command, options, file/directory */ },\r\n/*LookupUserGroups*/    {  0,  1, F, F, F, L\"groups\" },\r\n/*CopyToRemote*/        { -1, -1, T, F, T, L\"scp -r %s -d -t \\\"%s\\\"\" /* options, directory */ },\r\n/*CopyToLocal*/         { -1, -1, F, F, T, L\"scp -r %s -d -f \\\"%s\\\"\" /* options, file */ },\r\n/*DeleteFile*/          {  0,  0, T, F, F, L\"rm -f -r \\\"%s\\\"\" /* file/directory */},\r\n/*RenameFile*/          {  0,  0, T, F, F, L\"mv -f \\\"%s\\\" \\\"%s\\\"\" /* file/directory, new name*/},\r\n/*CreateDirectory*/     {  0,  0, T, F, F, L\"mkdir \\\"%s\\\"\" /* new directory */},\r\n/*ChangeMode*/          {  0,  0, T, F, F, L\"chmod %s %s \\\"%s\\\"\" /* options, mode, filename */},\r\n/*ChangeGroup*/         {  0,  0, T, F, F, L\"chgrp %s \\\"%s\\\" \\\"%s\\\"\" /* options, group, filename */},\r\n/*ChangeOwner*/         {  0,  0, T, F, F, L\"chown %s \\\"%s\\\" \\\"%s\\\"\" /* options, owner, filename */},\r\n/*HomeDirectory*/       {  0,  0, F, T, F, L\"cd\" },\r\n/*Unset*/               {  0,  0, F, F, F, L\"unset \\\"%s\\\"\" /* variable */ },\r\n/*Unalias*/             {  0,  0, F, F, F, L\"unalias \\\"%s\\\"\" /* alias */ },\r\n/*CreateLink*/          {  0,  0, T, F, F, L\"ln %s \\\"%s\\\" \\\"%s\\\"\" /*symbolic (-s), filename, point to*/},\r\n/*CopyFile*/            {  0,  0, T, F, F, L\"cp -p -r -f %s \\\"%s\\\" \\\"%s\\\"\" /* file/directory, target name*/},\r\n/*AnyCommand*/          {  0, -1, T, T, F, L\"%s\" },\r\n/*Lang*/                {  0,  1, F, F, F, L\"printenv LANG\"}\r\n};\r\n#undef F\r\n#undef T\r\n//---------------------------------------------------------------------------\r\n__fastcall TCommandSet::TCommandSet(TSessionData *aSessionData):\r\n  FSessionData(aSessionData), FReturnVar(L\"\")\r\n{\r\n  DebugAssert(FSessionData);\r\n  Default();\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TCommandSet::CopyFrom(TCommandSet * Source)\r\n{\r\n  memmove(&CommandSet, Source->CommandSet, sizeof(CommandSet));\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TCommandSet::Default()\r\n{\r\n  DebugAssert(sizeof(CommandSet) == sizeof(DefaultCommandSet));\r\n  memmove(&CommandSet, &DefaultCommandSet, sizeof(CommandSet));\r\n}\r\n//---------------------------------------------------------------------------\r\nint __fastcall TCommandSet::GetMaxLines(TFSCommand Cmd)\r\n{\r\n  CHECK_CMD;\r\n  return CommandSet[Cmd].MaxLines;\r\n}\r\n//---------------------------------------------------------------------------\r\nint __fastcall TCommandSet::GetMinLines(TFSCommand Cmd)\r\n{\r\n  CHECK_CMD;\r\n  return CommandSet[Cmd].MinLines;\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TCommandSet::GetModifiesFiles(TFSCommand Cmd)\r\n{\r\n  CHECK_CMD;\r\n  return CommandSet[Cmd].ModifiesFiles;\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TCommandSet::GetChangesDirectory(TFSCommand Cmd)\r\n{\r\n  CHECK_CMD;\r\n  return CommandSet[Cmd].ChangesDirectory;\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TCommandSet::GetInteractiveCommand(TFSCommand Cmd)\r\n{\r\n  CHECK_CMD;\r\n  return CommandSet[Cmd].InteractiveCommand;\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TCommandSet::GetOneLineCommand(TFSCommand /*Cmd*/)\r\n{\r\n  //CHECK_CMD;\r\n  // #56: we send \"echo last line\" from all commands on same line\r\n  // just as it was in 1.0\r\n  return True; //CommandSet[Cmd].OneLineCommand;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TCommandSet::SetCommands(TFSCommand Cmd, UnicodeString value)\r\n{\r\n  CHECK_CMD;\r\n  wcscpy(CommandSet[Cmd].Command, value.SubString(1, MaxCommandLen - 1).c_str());\r\n}\r\n//---------------------------------------------------------------------------\r\nUnicodeString __fastcall TCommandSet::GetCommands(TFSCommand Cmd)\r\n{\r\n  CHECK_CMD;\r\n  return CommandSet[Cmd].Command;\r\n}\r\n//---------------------------------------------------------------------------\r\nUnicodeString __fastcall TCommandSet::Command(TFSCommand Cmd, const TVarRec * args, int size)\r\n{\r\n  if (args) return Format(Commands[Cmd], args, size);\r\n    else return Commands[Cmd];\r\n}\r\n//---------------------------------------------------------------------------\r\nUnicodeString __fastcall TCommandSet::FullCommand(TFSCommand Cmd, const TVarRec * args, int size)\r\n{\r\n  UnicodeString Separator;\r\n  if (OneLineCommand[Cmd]) Separator = L\" ; \";\r\n    else Separator = L\"\\n\";\r\n  UnicodeString Line = Command(Cmd, args, size);\r\n  UnicodeString LastLineCmd =\r\n    Command(fsLastLine, ARRAYOFCONST((LastLine, ReturnVar)));\r\n  UnicodeString FirstLineCmd;\r\n  if (InteractiveCommand[Cmd])\r\n    FirstLineCmd = Command(fsFirstLine, ARRAYOFCONST((FirstLine))) + Separator;\r\n\r\n  UnicodeString Result;\r\n  if (!Line.IsEmpty())\r\n    Result = FORMAT(L\"%s%s%s%s\", (FirstLineCmd, Line, Separator, LastLineCmd));\r\n  else\r\n    Result = FORMAT(L\"%s%s\", (FirstLineCmd, LastLineCmd));\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nUnicodeString __fastcall TCommandSet::GetFirstLine()\r\n{\r\n  return FIRST_LINE;\r\n}\r\n//---------------------------------------------------------------------------\r\nUnicodeString __fastcall TCommandSet::GetLastLine()\r\n{\r\n  return LAST_LINE;\r\n}\r\n//---------------------------------------------------------------------------\r\nUnicodeString __fastcall TCommandSet::GetReturnVar()\r\n{\r\n  DebugAssert(SessionData);\r\n  if (!FReturnVar.IsEmpty())\r\n  {\r\n    return UnicodeString(L'$') + FReturnVar;\r\n  }\r\n  else if (SessionData->DetectReturnVar)\r\n  {\r\n    return L'0';\r\n  }\r\n  else\r\n  {\r\n    return UnicodeString(L'$') + SessionData->ReturnVar;\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nUnicodeString __fastcall TCommandSet::ExtractCommand(UnicodeString Command)\r\n{\r\n  int P = Command.Pos(L\" \");\r\n  if (P > 0)\r\n  {\r\n    Command.SetLength(P-1);\r\n  }\r\n  return Command;\r\n}\r\n//---------------------------------------------------------------------------\r\nTStrings * __fastcall TCommandSet::CreateCommandList()\r\n{\r\n  TStrings * CommandList = new TStringList();\r\n  for (Integer Index = 0; Index < ShellCommandCount; Index++)\r\n  {\r\n    UnicodeString Cmd = Commands[(TFSCommand)Index];\r\n    if (!Cmd.IsEmpty())\r\n    {\r\n      Cmd = ExtractCommand(Cmd);\r\n      if ((Cmd != L\"%s\") && (CommandList->IndexOf(Cmd) < 0))\r\n        CommandList->Add(Cmd);\r\n    }\r\n  }\r\n  return CommandList;\r\n}\r\n//===========================================================================\r\n__fastcall TSCPFileSystem::TSCPFileSystem(TTerminal * ATerminal, TSecureShell * SecureShell):\r\n  TCustomFileSystem(ATerminal)\r\n{\r\n  FSecureShell = SecureShell;\r\n  FCommandSet = new TCommandSet(FTerminal->SessionData);\r\n  FLsFullTime = FTerminal->SessionData->SCPLsFullTime;\r\n  FOutput = new TStringList();\r\n  FProcessingCommand = false;\r\n  FOnCaptureOutput = NULL;\r\n\r\n  FFileSystemInfo.ProtocolBaseName = L\"SCP\";\r\n  FFileSystemInfo.ProtocolName = FFileSystemInfo.ProtocolBaseName;\r\n}\r\n//---------------------------------------------------------------------------\r\n__fastcall TSCPFileSystem::~TSCPFileSystem()\r\n{\r\n  delete FCommandSet;\r\n  delete FOutput;\r\n  delete FSecureShell;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::Open()\r\n{\r\n  // this is used for reconnects only\r\n  FSecureShell->Open();\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::Close()\r\n{\r\n  FSecureShell->Close();\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TSCPFileSystem::GetActive()\r\n{\r\n  return FSecureShell->Active;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::CollectUsage()\r\n{\r\n  FSecureShell->CollectUsage();\r\n}\r\n//---------------------------------------------------------------------------\r\nconst TSessionInfo & __fastcall TSCPFileSystem::GetSessionInfo()\r\n{\r\n  return FSecureShell->GetSessionInfo();\r\n}\r\n//---------------------------------------------------------------------------\r\nconst TFileSystemInfo & __fastcall TSCPFileSystem::GetFileSystemInfo(bool Retrieve)\r\n{\r\n  if (FFileSystemInfo.AdditionalInfo.IsEmpty() && Retrieve)\r\n  {\r\n    UnicodeString UName;\r\n    FTerminal->ExceptionOnFail = true;\r\n    try\r\n    {\r\n      try\r\n      {\r\n        AnyCommand(L\"uname -a\", NULL);\r\n        for (int Index = 0; Index < Output->Count; Index++)\r\n        {\r\n          if (Index > 0)\r\n          {\r\n            UName += L\"; \";\r\n          }\r\n          UName += Output->Strings[Index];\r\n        }\r\n      }\r\n      catch(...)\r\n      {\r\n        if (!FTerminal->Active)\r\n        {\r\n          throw;\r\n        }\r\n      }\r\n    }\r\n    __finally\r\n    {\r\n      FTerminal->ExceptionOnFail = false;\r\n    }\r\n\r\n    FFileSystemInfo.RemoteSystem = UName;\r\n  }\r\n\r\n  return FFileSystemInfo;\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TSCPFileSystem::TemporaryTransferFile(const UnicodeString & /*FileName*/)\r\n{\r\n  return false;\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TSCPFileSystem::GetStoredCredentialsTried()\r\n{\r\n  return FSecureShell->GetStoredCredentialsTried();\r\n}\r\n//---------------------------------------------------------------------------\r\nUnicodeString __fastcall TSCPFileSystem::GetUserName()\r\n{\r\n  return FSecureShell->UserName;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::Idle()\r\n{\r\n  // Keep session alive\r\n  if ((FTerminal->SessionData->PingType != ptOff) &&\r\n      (Now() - FSecureShell->LastDataSent > FTerminal->SessionData->PingIntervalDT))\r\n  {\r\n    if ((FTerminal->SessionData->PingType == ptDummyCommand) &&\r\n        FSecureShell->Ready)\r\n    {\r\n      if (!FProcessingCommand)\r\n      {\r\n        ExecCommand(fsNull, NULL, 0, 0);\r\n      }\r\n      else\r\n      {\r\n        FTerminal->LogEvent(L\"Cannot send keepalive, command is being executed\");\r\n        // send at least SSH-level keepalive, if nothing else, it at least updates\r\n        // LastDataSent, no the next keepalive attempt is postponed\r\n        FSecureShell->KeepAlive();\r\n      }\r\n    }\r\n    else\r\n    {\r\n      FSecureShell->KeepAlive();\r\n    }\r\n  }\r\n\r\n  FSecureShell->Idle();\r\n}\r\n//---------------------------------------------------------------------------\r\nUnicodeString __fastcall TSCPFileSystem::AbsolutePath(UnicodeString Path, bool /*Local*/)\r\n{\r\n  return ::AbsolutePath(CurrentDirectory, Path);\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TSCPFileSystem::IsCapable(int Capability) const\r\n{\r\n  DebugAssert(FTerminal);\r\n  switch (Capability) {\r\n    case fcUserGroupListing:\r\n    case fcModeChanging:\r\n    case fcModeChangingUpload:\r\n    case fcPreservingTimestampUpload:\r\n    case fcGroupChanging:\r\n    case fcOwnerChanging:\r\n    case fcAnyCommand:\r\n    case fcShellAnyCommand:\r\n    case fcHardLink:\r\n    case fcSymbolicLink:\r\n    case fcResolveSymlink:\r\n    case fcRename:\r\n    case fcRemoteMove:\r\n    case fcRemoteCopy:\r\n    case fcRemoveCtrlZUpload:\r\n    case fcRemoveBOMUpload:\r\n      return true;\r\n\r\n    case fcTextMode:\r\n      return FTerminal->SessionData->EOLType != FTerminal->Configuration->LocalEOLType;\r\n\r\n    case fcNativeTextMode:\r\n    case fcNewerOnlyUpload:\r\n    case fcTimestampChanging:\r\n    case fcLoadingAdditionalProperties:\r\n    case fcCheckingSpaceAvailable:\r\n    case fcIgnorePermErrors:\r\n    case fcCalculatingChecksum:\r\n    case fcSecondaryShell: // has fcShellAnyCommand\r\n    case fcGroupOwnerChangingByID: // by name\r\n    case fcMoveToQueue:\r\n    case fcLocking:\r\n    case fcPreservingTimestampDirs:\r\n    case fcResumeSupport:\r\n    case fsSkipTransfer:\r\n    case fsParallelTransfers: // does not implement cpNoRecurse\r\n      return false;\r\n\r\n    case fcChangePassword:\r\n      return FSecureShell->CanChangePassword();\r\n\r\n    default:\r\n      DebugFail();\r\n      return false;\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nUnicodeString __fastcall TSCPFileSystem::DelimitStr(UnicodeString Str)\r\n{\r\n  if (!Str.IsEmpty())\r\n  {\r\n    Str = ::DelimitStr(Str, L\"\\\\`$\\\"\");\r\n    if (Str[1] == L'-') Str = L\"./\"+Str;\r\n  }\r\n  return Str;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::EnsureLocation()\r\n{\r\n  if (!FCachedDirectoryChange.IsEmpty())\r\n  {\r\n    FTerminal->LogEvent(FORMAT(L\"Locating to cached directory \\\"%s\\\".\",\r\n      (FCachedDirectoryChange)));\r\n    UnicodeString Directory = FCachedDirectoryChange;\r\n    FCachedDirectoryChange = L\"\";\r\n    try\r\n    {\r\n      ChangeDirectory(Directory);\r\n    }\r\n    catch(...)\r\n    {\r\n      // when location to cached directory fails, pretend again\r\n      // location in cached directory\r\n      // here used to be check (CurrentDirectory != Directory), but it is\r\n      // false always (current directory is already set to cached directory),\r\n      // making the condition below useless. check removed.\r\n      if (FTerminal->Active)\r\n      {\r\n        FCachedDirectoryChange = Directory;\r\n      }\r\n      throw;\r\n    }\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::SendCommand(const UnicodeString Cmd)\r\n{\r\n  EnsureLocation();\r\n\r\n  UnicodeString Line;\r\n  FSecureShell->ClearStdError();\r\n  FReturnCode = 0;\r\n  FOutput->Clear();\r\n  // We suppose, that 'Cmd' already contains command that ensures,\r\n  // that 'LastLine' will be printed\r\n  FSecureShell->SendLine(Cmd);\r\n  FProcessingCommand = true;\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TSCPFileSystem::IsTotalListingLine(const UnicodeString Line)\r\n{\r\n  // On some hosts there is not \"total\" but \"totalt\". What's the reason??\r\n  // see mail from \"Jan Wiklund (SysOp)\" <jan@park.se>\r\n  return !Line.SubString(1, 5).CompareIC(L\"total\");\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TSCPFileSystem::RemoveLastLine(UnicodeString & Line,\r\n    int & ReturnCode, UnicodeString LastLine)\r\n{\r\n  bool IsLastLine = false;\r\n  if (LastLine.IsEmpty()) LastLine = LAST_LINE;\r\n  // #55: fixed so, even when last line of command output does not\r\n  // contain CR/LF, we can recognize last line\r\n  int Pos = Line.Pos(LastLine);\r\n  if (Pos)\r\n  {\r\n    // 2003-07-14: There must be nothing after return code number to\r\n    // consider string as last line. This fixes bug with 'set' command\r\n    // in console window\r\n    UnicodeString ReturnCodeStr = Line.SubString(Pos + LastLine.Length() + 1,\r\n      Line.Length() - Pos + LastLine.Length());\r\n    if (TryStrToInt(ReturnCodeStr, ReturnCode))\r\n    {\r\n      IsLastLine = true;\r\n      Line.SetLength(Pos - 1);\r\n    }\r\n  }\r\n  return IsLastLine;\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TSCPFileSystem::IsLastLine(UnicodeString & Line)\r\n{\r\n  bool Result = false;\r\n  try\r\n  {\r\n    Result = RemoveLastLine(Line, FReturnCode, FCommandSet->LastLine);\r\n  }\r\n  catch (Exception &E)\r\n  {\r\n    FTerminal->TerminalError(&E, LoadStr(CANT_DETECT_RETURN_CODE));\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::SkipFirstLine()\r\n{\r\n  UnicodeString Line = FSecureShell->ReceiveLine();\r\n  if (Line != FCommandSet->FirstLine)\r\n  {\r\n    FTerminal->TerminalError(NULL, FMTLOAD(FIRST_LINE_EXPECTED, (Line)));\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::ReadCommandOutput(int Params, const UnicodeString * Cmd)\r\n{\r\n  try\r\n  {\r\n    if (Params & coWaitForLastLine)\r\n    {\r\n      UnicodeString Line;\r\n      bool IsLast;\r\n      unsigned int Total = 0;\r\n      // #55: fixed so, even when last line of command output does not\r\n      // contain CR/LF, we can recognize last line\r\n      do\r\n      {\r\n        Line = FSecureShell->ReceiveLine();\r\n        IsLast = IsLastLine(Line);\r\n        if (!IsLast || !Line.IsEmpty())\r\n        {\r\n          FOutput->Add(Line);\r\n          if (FLAGSET(Params, coReadProgress))\r\n          {\r\n            Total++;\r\n\r\n            if (Total % 10 == 0)\r\n            {\r\n              bool Cancel; //dummy\r\n              FTerminal->DoReadDirectoryProgress(Total, 0, Cancel);\r\n            }\r\n          }\r\n        }\r\n      }\r\n      while (!IsLast);\r\n    }\r\n    if (Params & coRaiseExcept)\r\n    {\r\n      UnicodeString Message = FSecureShell->GetStdError();\r\n      if ((Params & coExpectNoOutput) && FOutput->Count)\r\n      {\r\n        if (!Message.IsEmpty()) Message += L\"\\n\";\r\n        Message += FOutput->Text;\r\n      }\r\n      while (!Message.IsEmpty() && (Message.LastDelimiter(L\"\\n\\r\") == Message.Length()))\r\n      {\r\n        Message.SetLength(Message.Length() - 1);\r\n      }\r\n\r\n      bool WrongReturnCode =\r\n        (ReturnCode > 1) || (ReturnCode == 1 && !(Params & coIgnoreWarnings));\r\n\r\n      if (FOnCaptureOutput != NULL)\r\n      {\r\n        FOnCaptureOutput(IntToStr(ReturnCode), cotExitCode);\r\n      }\r\n\r\n      if (Params & coOnlyReturnCode && WrongReturnCode)\r\n      {\r\n        FTerminal->TerminalError(FMTLOAD(COMMAND_FAILED_CODEONLY, (ReturnCode)));\r\n      }\r\n      else if (!(Params & coOnlyReturnCode) &&\r\n          ((!Message.IsEmpty() && ((FOutput->Count == 0) || !(Params & coIgnoreWarnings))) ||\r\n           WrongReturnCode))\r\n      {\r\n        DebugAssert(Cmd != NULL);\r\n        FTerminal->TerminalError(FMTLOAD(COMMAND_FAILED, (*Cmd, ReturnCode, Message)));\r\n      }\r\n    }\r\n  }\r\n  __finally\r\n  {\r\n    FProcessingCommand = false;\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::ExecCommand(const UnicodeString & Cmd, int Params,\r\n  const UnicodeString & CmdString)\r\n{\r\n  if (Params < 0)\r\n  {\r\n    Params = ecDefault;\r\n  }\r\n\r\n  TOperationVisualizer Visualizer(FTerminal->UseBusyCursor);\r\n\r\n  SendCommand(Cmd);\r\n\r\n  int COParams = coWaitForLastLine;\r\n  if (Params & ecRaiseExcept) COParams |= coRaiseExcept;\r\n  if (Params & ecIgnoreWarnings) COParams |= coIgnoreWarnings;\r\n  if (Params & ecReadProgress) COParams |= coReadProgress;\r\n  ReadCommandOutput(COParams, &CmdString);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::ExecCommand(TFSCommand Cmd, const TVarRec * args,\r\n  int size, int Params)\r\n{\r\n  if (Params < 0) Params = ecDefault;\r\n  UnicodeString FullCommand = FCommandSet->FullCommand(Cmd, args, size);\r\n  UnicodeString Command = FCommandSet->Command(Cmd, args, size);\r\n  ExecCommand(FullCommand, Params, Command);\r\n  if (Params & ecRaiseExcept)\r\n  {\r\n    Integer MinL = FCommandSet->MinLines[Cmd];\r\n    Integer MaxL = FCommandSet->MaxLines[Cmd];\r\n    if (((MinL >= 0) && (MinL > FOutput->Count)) ||\r\n        ((MaxL >= 0) && (MaxL > FOutput->Count)))\r\n    {\r\n      FTerminal->TerminalError(FmtLoadStr(INVALID_OUTPUT_ERROR,\r\n        ARRAYOFCONST((FullCommand, Output->Text))));\r\n    }\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nUnicodeString __fastcall TSCPFileSystem::GetCurrentDirectory()\r\n{\r\n  return FCurrentDirectory;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::DoStartup()\r\n{\r\n  // Capabilities of SCP protocol are fixed\r\n  FTerminal->SaveCapabilities(FFileSystemInfo);\r\n\r\n  // SkipStartupMessage and DetectReturnVar must succeed,\r\n  // otherwise session is to be closed.\r\n  try\r\n  {\r\n    FTerminal->ExceptionOnFail = true;\r\n    SkipStartupMessage();\r\n    if (FTerminal->SessionData->DetectReturnVar) DetectReturnVar();\r\n    FTerminal->ExceptionOnFail = false;\r\n  }\r\n  catch (Exception & E)\r\n  {\r\n    FTerminal->FatalError(&E, L\"\");\r\n  }\r\n\r\n  // Needs to be done before UnsetNationalVars()\r\n  DetectUtf();\r\n\r\n  #define COND_OPER(OPER) if (FTerminal->SessionData->OPER) OPER()\r\n  COND_OPER(ClearAliases);\r\n  COND_OPER(UnsetNationalVars);\r\n  #undef COND_OPER\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::DetectUtf()\r\n{\r\n  switch (FTerminal->SessionData->NotUtf)\r\n  {\r\n    case asOn:\r\n      FSecureShell->UtfStrings = false; // noop\r\n      break;\r\n\r\n    case asOff:\r\n      FSecureShell->UtfStrings = true;\r\n      break;\r\n\r\n    default:\r\n      DebugFail();\r\n    case asAuto:\r\n      FSecureShell->UtfStrings = false; // noop\r\n      try\r\n      {\r\n        ExecCommand(fsLang, NULL, 0, false);\r\n\r\n        if ((FOutput->Count >= 1) &&\r\n            ContainsText(FOutput->Strings[0], L\"UTF-8\"))\r\n        {\r\n          FSecureShell->UtfStrings = true;\r\n        }\r\n      }\r\n      catch (Exception & E)\r\n      {\r\n        // ignore non-fatal errors\r\n        if (!FTerminal->Active)\r\n        {\r\n          throw;\r\n        }\r\n      }\r\n      break;\r\n  }\r\n\r\n  if (FSecureShell->UtfStrings)\r\n  {\r\n    FTerminal->LogEvent(L\"We will use UTF-8\");\r\n  }\r\n  else\r\n  {\r\n    FTerminal->LogEvent(L\"We will not use UTF-8\");\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::SkipStartupMessage()\r\n{\r\n  try\r\n  {\r\n    FTerminal->LogEvent(L\"Skipping host startup message (if any).\");\r\n    ExecCommand(fsNull, NULL, 0, 0);\r\n  }\r\n  catch (Exception & E)\r\n  {\r\n    FTerminal->CommandError(&E, LoadStr(SKIP_STARTUP_MESSAGE_ERROR), 0, HELP_SKIP_STARTUP_MESSAGE_ERROR);\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::LookupUsersGroups()\r\n{\r\n  ExecCommand(fsLookupUsersGroups);\r\n  FTerminal->FUsers.Clear();\r\n  FTerminal->FGroups.Clear();\r\n  if (FOutput->Count > 0)\r\n  {\r\n    UnicodeString Groups = FOutput->Strings[0];\r\n    while (!Groups.IsEmpty())\r\n    {\r\n      UnicodeString NewGroup = CutToChar(Groups, L' ', false);\r\n      FTerminal->FGroups.Add(TRemoteToken(NewGroup));\r\n      FTerminal->FMembership.Add(TRemoteToken(NewGroup));\r\n    }\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::DetectReturnVar()\r\n{\r\n  // This suppose that something was already executed (probably SkipStartupMessage())\r\n  // or return code variable is already set on start up.\r\n\r\n  try\r\n  {\r\n    // #60 17.10.01: \"status\" and \"?\" switched\r\n    UnicodeString ReturnVars[2] = { L\"status\", L\"?\" };\r\n    UnicodeString NewReturnVar = L\"\";\r\n    FTerminal->LogEvent(L\"Detecting variable containing return code of last command.\");\r\n    for (int Index = 0; Index < 2; Index++)\r\n    {\r\n      bool Success = true;\r\n\r\n      try\r\n      {\r\n        FTerminal->LogEvent(FORMAT(L\"Trying \\\"$%s\\\".\", (ReturnVars[Index])));\r\n        ExecCommand(fsVarValue, ARRAYOFCONST((ReturnVars[Index])));\r\n        if ((Output->Count != 1) || (StrToIntDef(Output->Strings[0], 256) > 255))\r\n        {\r\n          FTerminal->LogEvent(L\"The response is not numerical exit code\");\r\n          Abort();\r\n        }\r\n      }\r\n      catch (EFatal &E)\r\n      {\r\n        // if fatal error occurs, we need to exit ...\r\n        throw;\r\n      }\r\n      catch (Exception &E)\r\n      {\r\n        // ...otherwise, we will try next variable (if any)\r\n        Success = false;\r\n      }\r\n\r\n      if (Success)\r\n      {\r\n        NewReturnVar = ReturnVars[Index];\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (NewReturnVar.IsEmpty())\r\n    {\r\n      EXCEPTION;\r\n    }\r\n    else\r\n    {\r\n      FCommandSet->ReturnVar = NewReturnVar;\r\n      FTerminal->LogEvent(FORMAT(L\"Return code variable \\\"%s\\\" selected.\",\r\n        (FCommandSet->ReturnVar)));\r\n    }\r\n  }\r\n  catch (Exception &E)\r\n  {\r\n    FTerminal->CommandError(&E, LoadStr(DETECT_RETURNVAR_ERROR));\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::ClearAlias(UnicodeString Alias)\r\n{\r\n  if (!Alias.IsEmpty())\r\n  {\r\n    // this command usually fails, because there will never be\r\n    // aliases on all commands -> see last False parameter\r\n    ExecCommand(fsUnalias, ARRAYOFCONST((Alias)), false);\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::ClearAliases()\r\n{\r\n  try\r\n  {\r\n    FTerminal->LogEvent(L\"Clearing all aliases.\");\r\n    ClearAlias(TCommandSet::ExtractCommand(FTerminal->SessionData->ListingCommand));\r\n    TStrings * CommandList = FCommandSet->CreateCommandList();\r\n    try\r\n    {\r\n      for (int Index = 0; Index < CommandList->Count; Index++)\r\n      {\r\n        ClearAlias(CommandList->Strings[Index]);\r\n      }\r\n    }\r\n    __finally\r\n    {\r\n      delete CommandList;\r\n    }\r\n  }\r\n  catch (Exception &E)\r\n  {\r\n    FTerminal->CommandError(&E, LoadStr(UNALIAS_ALL_ERROR));\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::UnsetNationalVars()\r\n{\r\n  try\r\n  {\r\n    FTerminal->LogEvent(L\"Clearing national user variables.\");\r\n    for (int Index = 0; Index < NationalVarCount; Index++)\r\n    {\r\n      ExecCommand(fsUnset, ARRAYOFCONST((NationalVars[Index])), false);\r\n    }\r\n  }\r\n  catch (Exception &E)\r\n  {\r\n    FTerminal->CommandError(&E, LoadStr(UNSET_NATIONAL_ERROR));\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::ReadCurrentDirectory()\r\n{\r\n  if (FCachedDirectoryChange.IsEmpty())\r\n  {\r\n    ExecCommand(fsCurrentDirectory);\r\n    FCurrentDirectory = UnixExcludeTrailingBackslash(FOutput->Strings[0]);\r\n  }\r\n  else\r\n  {\r\n    FCurrentDirectory = FCachedDirectoryChange;\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::HomeDirectory()\r\n{\r\n  ExecCommand(fsHomeDirectory);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::AnnounceFileListOperation()\r\n{\r\n  // noop\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::ChangeDirectory(const UnicodeString Directory)\r\n{\r\n  UnicodeString ToDir;\r\n  if (!Directory.IsEmpty() &&\r\n      ((Directory[1] != L'~') || (Directory.SubString(1, 2) == L\"~ \")))\r\n  {\r\n    ToDir = L\"\\\"\" + DelimitStr(Directory) + L\"\\\"\";\r\n  }\r\n  else\r\n  {\r\n    ToDir = DelimitStr(Directory);\r\n  }\r\n  ExecCommand(fsChangeDirectory, ARRAYOFCONST((ToDir)));\r\n  FCachedDirectoryChange = L\"\";\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::CachedChangeDirectory(const UnicodeString Directory)\r\n{\r\n  FCachedDirectoryChange = UnixExcludeTrailingBackslash(Directory);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::ReadDirectory(TRemoteFileList * FileList)\r\n{\r\n  DebugAssert(FileList);\r\n  // emptying file list moved before command execution\r\n  FileList->Reset();\r\n\r\n  bool Again;\r\n\r\n  do\r\n  {\r\n    Again = false;\r\n    try\r\n    {\r\n      int Params = ecDefault | ecReadProgress |\r\n        FLAGMASK(FTerminal->SessionData->IgnoreLsWarnings, ecIgnoreWarnings);\r\n      const wchar_t * Options =\r\n        ((FLsFullTime == asAuto) || (FLsFullTime == asOn)) ? FullTimeOption : L\"\";\r\n      bool ListCurrentDirectory = (FileList->Directory == FTerminal->CurrentDirectory);\r\n      if (ListCurrentDirectory)\r\n      {\r\n        FTerminal->LogEvent(L\"Listing current directory.\");\r\n        ExecCommand(fsListCurrentDirectory,\r\n          ARRAYOFCONST((FTerminal->SessionData->ListingCommand, Options)), Params);\r\n      }\r\n      else\r\n      {\r\n        FTerminal->LogEvent(FORMAT(L\"Listing directory \\\"%s\\\".\",\r\n          (FileList->Directory)));\r\n        ExecCommand(fsListDirectory,\r\n          ARRAYOFCONST((FTerminal->SessionData->ListingCommand, Options,\r\n            DelimitStr(FileList->Directory))),\r\n          Params);\r\n      }\r\n\r\n      TRemoteFile * File;\r\n\r\n      // If output is not empty, we have successfully got file listing,\r\n      // otherwise there was an error, in case it was \"permission denied\"\r\n      // we try to get at least parent directory (see \"else\" statement below)\r\n      if (FOutput->Count > 0)\r\n      {\r\n        // Copy LS command output, because eventual symlink analysis would\r\n        // modify FTerminal->Output\r\n        TStringList * OutputCopy = new TStringList();\r\n        try\r\n        {\r\n          OutputCopy->Assign(FOutput);\r\n\r\n          // delete leading \"total xxx\" line\r\n          // On some hosts there is not \"total\" but \"totalt\". What's the reason??\r\n          // see mail from \"Jan Wiklund (SysOp)\" <jan@park.se>\r\n          if (IsTotalListingLine(OutputCopy->Strings[0]))\r\n          {\r\n            OutputCopy->Delete(0);\r\n          }\r\n\r\n          for (int Index = 0; Index < OutputCopy->Count; Index++)\r\n          {\r\n            UnicodeString OutputLine = OutputCopy->Strings[Index];\r\n            if (!OutputLine.IsEmpty())\r\n            {\r\n              File = CreateRemoteFile(OutputCopy->Strings[Index]);\r\n              FileList->AddFile(File);\r\n            }\r\n          }\r\n        }\r\n        __finally\r\n        {\r\n          delete OutputCopy;\r\n        }\r\n      }\r\n      else\r\n      {\r\n        bool Empty;\r\n        if (ListCurrentDirectory)\r\n        {\r\n          // Empty file list -> probably \"permission denied\", we\r\n          // at least get link to parent directory (\"..\")\r\n          FTerminal->ReadFile(\r\n            UnixIncludeTrailingBackslash(FTerminal->FFiles->Directory) +\r\n              PARENTDIRECTORY, File);\r\n          Empty = (File == NULL);\r\n          if (!Empty)\r\n          {\r\n            DebugAssert(File->IsParentDirectory);\r\n            FileList->AddFile(File);\r\n          }\r\n        }\r\n        else\r\n        {\r\n          Empty = true;\r\n        }\r\n\r\n        if (Empty)\r\n        {\r\n          throw ExtException(\r\n            NULL, FMTLOAD(EMPTY_DIRECTORY, (FileList->Directory)),\r\n            HELP_EMPTY_DIRECTORY);\r\n        }\r\n      }\r\n\r\n      if (FLsFullTime == asAuto)\r\n      {\r\n          FTerminal->LogEvent(\r\n            FORMAT(L\"Directory listing with %s succeed, next time all errors during \"\r\n              \"directory listing will be displayed immediately.\",\r\n              (FullTimeOption)));\r\n          FLsFullTime = asOn;\r\n      }\r\n    }\r\n    catch(Exception & E)\r\n    {\r\n      if (FTerminal->Active)\r\n      {\r\n        if (FLsFullTime == asAuto)\r\n        {\r\n          FTerminal->Log->AddException(&E);\r\n          FLsFullTime = asOff;\r\n          Again = true;\r\n          FTerminal->LogEvent(\r\n            FORMAT(L\"Directory listing with %s failed, try again regular listing.\",\r\n            (FullTimeOption)));\r\n        }\r\n        else\r\n        {\r\n          throw;\r\n        }\r\n      }\r\n      else\r\n      {\r\n        throw;\r\n      }\r\n    }\r\n  }\r\n  while (Again);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::ReadSymlink(TRemoteFile * SymlinkFile,\r\n  TRemoteFile *& File)\r\n{\r\n  CustomReadFile(SymlinkFile->LinkTo, File, SymlinkFile);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::ReadFile(const UnicodeString FileName,\r\n  TRemoteFile *& File)\r\n{\r\n  CustomReadFile(FileName, File, NULL);\r\n}\r\n//---------------------------------------------------------------------------\r\nTRemoteFile * __fastcall TSCPFileSystem::CreateRemoteFile(\r\n  const UnicodeString & ListingStr, TRemoteFile * LinkedByFile)\r\n{\r\n  TRemoteFile * File = new TRemoteFile(LinkedByFile);\r\n  try\r\n  {\r\n    File->Terminal = FTerminal;\r\n    File->ListingStr = ListingStr;\r\n    File->ShiftTimeInSeconds(TimeToSeconds(FTerminal->SessionData->TimeDifference));\r\n    File->Complete();\r\n  }\r\n  catch(...)\r\n  {\r\n    delete File;\r\n    throw;\r\n  }\r\n\r\n  return File;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::CustomReadFile(const UnicodeString FileName,\r\n  TRemoteFile *& File, TRemoteFile * ALinkedByFile)\r\n{\r\n  File = NULL;\r\n  int Params = ecDefault |\r\n    FLAGMASK(FTerminal->SessionData->IgnoreLsWarnings, ecIgnoreWarnings);\r\n  // the auto-detection of --full-time support is not implemented for fsListFile,\r\n  // so we use it only if we already know that it is supported (asOn).\r\n  const wchar_t * Options = (FLsFullTime == asOn) ? FullTimeOption : L\"\";\r\n  ExecCommand(fsListFile,\r\n    ARRAYOFCONST((FTerminal->SessionData->ListingCommand, Options, DelimitStr(FileName))),\r\n    Params);\r\n  if (FOutput->Count)\r\n  {\r\n    int LineIndex = 0;\r\n    if (IsTotalListingLine(FOutput->Strings[LineIndex]) && FOutput->Count > 1)\r\n    {\r\n      LineIndex++;\r\n    }\r\n\r\n    File = CreateRemoteFile(FOutput->Strings[LineIndex], ALinkedByFile);\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::DeleteFile(const UnicodeString FileName,\r\n  const TRemoteFile * File, int Params, TRmSessionAction & Action)\r\n{\r\n  DebugUsedParam(File);\r\n  DebugUsedParam(Params);\r\n  Action.Recursive();\r\n  DebugAssert(FLAGCLEAR(Params, dfNoRecursive) || (File && File->IsSymLink));\r\n  ExecCommand(fsDeleteFile, ARRAYOFCONST((DelimitStr(FileName))));\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::RenameFile(const UnicodeString FileName, const TRemoteFile * /*File*/,\r\n  const UnicodeString NewName)\r\n{\r\n  ExecCommand(fsRenameFile, ARRAYOFCONST((DelimitStr(FileName), DelimitStr(NewName))));\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::CopyFile(const UnicodeString FileName, const TRemoteFile * /*File*/,\r\n  const UnicodeString NewName)\r\n{\r\n  UnicodeString DelimitedFileName = DelimitStr(FileName);\r\n  UnicodeString DelimitedNewName = DelimitStr(NewName);\r\n  const UnicodeString AdditionalSwitches = L\"-T\";\r\n  try\r\n  {\r\n    ExecCommand(fsCopyFile, ARRAYOFCONST((AdditionalSwitches, DelimitedFileName, DelimitedNewName)));\r\n  }\r\n  catch (Exception & E)\r\n  {\r\n    if (FTerminal->Active)\r\n    {\r\n      // The -T is GNU switch and may not be available on all platforms.\r\n      // https://lists.gnu.org/archive/html/bug-coreutils/2004-07/msg00000.html\r\n      FTerminal->LogEvent(FORMAT(L\"Attempt with %s failed, trying without\", (AdditionalSwitches)));\r\n      ExecCommand(fsCopyFile, ARRAYOFCONST((L\"\", DelimitedFileName, DelimitedNewName)));\r\n    }\r\n    else\r\n    {\r\n      throw;\r\n    }\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::CreateDirectory(const UnicodeString & DirName, bool /*Encrypt*/)\r\n{\r\n  ExecCommand(fsCreateDirectory, ARRAYOFCONST((DelimitStr(DirName))));\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::CreateLink(const UnicodeString FileName,\r\n  const UnicodeString PointTo, bool Symbolic)\r\n{\r\n  ExecCommand(fsCreateLink,\r\n    ARRAYOFCONST((Symbolic ? L\"-s\" : L\"\", DelimitStr(PointTo), DelimitStr(FileName))));\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::ChangeFileToken(const UnicodeString & DelimitedName,\r\n  const TRemoteToken & Token, TFSCommand Cmd, const UnicodeString & RecursiveStr)\r\n{\r\n  UnicodeString Str;\r\n  if (Token.IDValid)\r\n  {\r\n    Str = IntToStr(int(Token.ID));\r\n  }\r\n  else if (Token.NameValid)\r\n  {\r\n    Str = Token.Name;\r\n  }\r\n\r\n  if (!Str.IsEmpty())\r\n  {\r\n    ExecCommand(Cmd, ARRAYOFCONST((RecursiveStr, Str, DelimitedName)));\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::ChangeFileProperties(const UnicodeString FileName,\r\n  const TRemoteFile * File, const TRemoteProperties * Properties,\r\n  TChmodSessionAction & Action)\r\n{\r\n  DebugAssert(Properties);\r\n  bool IsDirectory = File && File->IsDirectory;\r\n  bool Recursive = Properties->Recursive && IsDirectory;\r\n  UnicodeString RecursiveStr = Recursive ? L\"-R\" : L\"\";\r\n\r\n  UnicodeString DelimitedName = DelimitStr(FileName);\r\n  // change group before permissions as chgrp change permissions\r\n  if (Properties->Valid.Contains(vpGroup))\r\n  {\r\n    ChangeFileToken(DelimitedName, Properties->Group, fsChangeGroup, RecursiveStr);\r\n  }\r\n  if (Properties->Valid.Contains(vpOwner))\r\n  {\r\n    ChangeFileToken(DelimitedName, Properties->Owner, fsChangeOwner, RecursiveStr);\r\n  }\r\n  if (Properties->Valid.Contains(vpRights))\r\n  {\r\n    TRights Rights = Properties->Rights;\r\n\r\n    // if we don't set modes recursively, we may add X at once with other\r\n    // options. Otherwise we have to add X after recursive command\r\n    if (!Recursive && IsDirectory && Properties->AddXToDirectories)\r\n      Rights.AddExecute();\r\n\r\n    Action.Rights(Rights);\r\n    if (Recursive)\r\n    {\r\n      Action.Recursive();\r\n    }\r\n\r\n    if ((Rights.NumberSet | Rights.NumberUnset) != TRights::rfNo)\r\n    {\r\n      ExecCommand(fsChangeMode,\r\n        ARRAYOFCONST((RecursiveStr, Rights.SimplestStr, DelimitedName)));\r\n    }\r\n\r\n    // if file is directory and we do recursive mode settings with\r\n    // add-x-to-directories option on, add those X\r\n    if (Recursive && IsDirectory && Properties->AddXToDirectories)\r\n    {\r\n      Rights.AddExecute();\r\n      ExecCommand(fsChangeMode,\r\n        ARRAYOFCONST((L\"\", Rights.SimplestStr, DelimitedName)));\r\n    }\r\n  }\r\n  else\r\n  {\r\n    Action.Cancel();\r\n  }\r\n  DebugAssert(!Properties->Valid.Contains(vpLastAccess));\r\n  DebugAssert(!Properties->Valid.Contains(vpModification));\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TSCPFileSystem::LoadFilesProperties(TStrings * /*FileList*/ )\r\n{\r\n  DebugFail();\r\n  return false;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::CalculateFilesChecksum(const UnicodeString & /*Alg*/,\r\n  TStrings * /*FileList*/, TStrings * /*Checksums*/,\r\n  TCalculatedChecksumEvent /*OnCalculatedChecksum*/)\r\n{\r\n  DebugFail();\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::CustomCommandOnFile(const UnicodeString FileName,\r\n    const TRemoteFile * File, UnicodeString Command, int Params,\r\n    TCaptureOutputEvent OutputEvent)\r\n{\r\n  DebugAssert(File);\r\n  bool Dir = File->IsDirectory && FTerminal->CanRecurseToDirectory(File);\r\n  if (Dir && (Params & ccRecursive))\r\n  {\r\n    TCustomCommandParams AParams;\r\n    AParams.Command = Command;\r\n    AParams.Params = Params;\r\n    AParams.OutputEvent = OutputEvent;\r\n    FTerminal->ProcessDirectory(FileName, FTerminal->CustomCommandOnFile,\r\n      &AParams);\r\n  }\r\n\r\n  if (!Dir || (Params & ccApplyToDirectories))\r\n  {\r\n    TCustomCommandData Data(FTerminal);\r\n    UnicodeString Cmd = TRemoteCustomCommand(\r\n      Data, FTerminal->CurrentDirectory, FileName, L\"\").\r\n      Complete(Command, true);\r\n\r\n    if (!FTerminal->DoOnCustomCommand(Cmd))\r\n    {\r\n      AnyCommand(Cmd, OutputEvent);\r\n    }\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::CaptureOutput(const UnicodeString & AddedLine, TCaptureOutputType OutputType)\r\n{\r\n  int ReturnCode;\r\n  UnicodeString Line = AddedLine;\r\n  // TSecureShell never uses cotExitCode\r\n  DebugAssert((OutputType == cotOutput) || (OutputType == cotError));\r\n  if ((OutputType == cotError) || DebugAlwaysFalse(OutputType == cotExitCode) ||\r\n      !RemoveLastLine(Line, ReturnCode) ||\r\n      !Line.IsEmpty())\r\n  {\r\n    DebugAssert(FOnCaptureOutput != NULL);\r\n    FOnCaptureOutput(Line, OutputType);\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::AnyCommand(const UnicodeString Command,\r\n  TCaptureOutputEvent OutputEvent)\r\n{\r\n  DebugAssert(FSecureShell->OnCaptureOutput == NULL);\r\n  if (OutputEvent != NULL)\r\n  {\r\n    FSecureShell->OnCaptureOutput = CaptureOutput;\r\n    FOnCaptureOutput = OutputEvent;\r\n  }\r\n\r\n  try\r\n  {\r\n    ExecCommand(fsAnyCommand, ARRAYOFCONST((Command)),\r\n      ecDefault | ecIgnoreWarnings);\r\n  }\r\n  __finally\r\n  {\r\n    FOnCaptureOutput = NULL;\r\n    FSecureShell->OnCaptureOutput = NULL;\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nTStrings * __fastcall TSCPFileSystem::GetFixedPaths()\r\n{\r\n  return NULL;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::SpaceAvailable(const UnicodeString Path,\r\n  TSpaceAvailable & /*ASpaceAvailable*/)\r\n{\r\n  DebugFail();\r\n}\r\n//---------------------------------------------------------------------------\r\n// transfer protocol\r\n//---------------------------------------------------------------------------\r\nunsigned int __fastcall TSCPFileSystem::ConfirmOverwrite(\r\n  const UnicodeString & SourceFullFileName, const UnicodeString & TargetFileName, TOperationSide Side,\r\n  const TOverwriteFileParams * FileParams, const TCopyParamType * CopyParam,\r\n  int Params, TFileOperationProgressType * OperationProgress)\r\n{\r\n  TSuspendFileOperationProgress Suspend(OperationProgress);\r\n\r\n  TQueryButtonAlias Aliases[3];\r\n  Aliases[0] = TQueryButtonAlias::CreateAllAsYesToNewerGrouppedWithYes();\r\n  Aliases[1] = TQueryButtonAlias::CreateYesToAllGrouppedWithYes();\r\n  Aliases[2] = TQueryButtonAlias::CreateNoToAllGrouppedWithNo();\r\n  TQueryParams QueryParams(qpNeverAskAgainCheck);\r\n  QueryParams.Aliases = Aliases;\r\n  QueryParams.AliasesCount = LENOF(Aliases);\r\n  unsigned int Answer =\r\n    FTerminal->ConfirmFileOverwrite(\r\n      SourceFullFileName, TargetFileName, FileParams,\r\n      qaYes | qaNo | qaCancel | qaYesToAll | qaNoToAll | qaAll,\r\n      &QueryParams, Side, CopyParam, Params, OperationProgress);\r\n  return Answer;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::SCPResponse(bool * GotLastLine)\r\n{\r\n  // Taken from scp.c response() and modified\r\n\r\n  unsigned char Resp;\r\n  FSecureShell->Receive(&Resp, 1);\r\n\r\n  switch (Resp)\r\n  {\r\n    case 0:     /* ok */\r\n      FTerminal->LogEvent(L\"SCP remote side confirmation (0)\");\r\n      return;\r\n\r\n    default:\r\n    case 1:     /* error */\r\n    case 2:     /* fatal error */\r\n      // pscp adds 'Resp' to 'Msg', why?\r\n      UnicodeString Msg = FSecureShell->ReceiveLine();\r\n      UnicodeString Line = UnicodeString(static_cast<char>(Resp)) + Msg;\r\n      if (IsLastLine(Line))\r\n      {\r\n        if (GotLastLine != NULL)\r\n        {\r\n          *GotLastLine = true;\r\n        }\r\n\r\n        /* TODO 1 : Show stderror to user? */\r\n        FSecureShell->ClearStdError();\r\n\r\n        try\r\n        {\r\n          ReadCommandOutput(coExpectNoOutput | coRaiseExcept | coOnlyReturnCode);\r\n        }\r\n        catch(...)\r\n        {\r\n          // when ReadCommandOutput() fails than remote SCP is terminated already\r\n          if (GotLastLine != NULL)\r\n          {\r\n            *GotLastLine = true;\r\n          }\r\n          throw;\r\n        }\r\n      }\r\n      else if (Resp == 1)\r\n      {\r\n        // While the OpenSSH scp client distinguishes the 1 for error and 2 for fatal errors,\r\n        // the OpenSSH scp server always sends 1 even for fatal errors. Using the error message to tell\r\n        // which errors are fatal and which are not.\r\n        // This error list is valid for OpenSSH 5.3p1 and 7.2p2\r\n        if (SameText(Msg, L\"scp: ambiguous target\") ||\r\n            StartsText(L\"scp: error: unexpected filename: \", Msg) ||\r\n            StartsText(L\"scp: protocol error: \", Msg))\r\n        {\r\n          FTerminal->LogEvent(L\"SCP remote side error (1), fatal error detected from error message\");\r\n          Resp = 2;\r\n          FScpFatalError = true;\r\n        }\r\n        else\r\n        {\r\n          FTerminal->LogEvent(L\"SCP remote side error (1)\");\r\n        }\r\n      }\r\n      else\r\n      {\r\n        FTerminal->LogEvent(L\"SCP remote side fatal error (2)\");\r\n        FScpFatalError = true;\r\n      }\r\n\r\n      if (Resp == 1)\r\n      {\r\n        throw EScpFileSkipped(NULL, Msg);\r\n      }\r\n      else\r\n      {\r\n        throw EScp(NULL, Msg);\r\n      }\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::CopyToRemote(TStrings * FilesToCopy,\r\n  const UnicodeString TargetDir, const TCopyParamType * CopyParam,\r\n  int Params, TFileOperationProgressType * OperationProgress,\r\n  TOnceDoneOperation & OnceDoneOperation)\r\n{\r\n  // scp.c: source(), toremote()\r\n  DebugAssert(FilesToCopy && OperationProgress);\r\n\r\n  Params &= ~(cpAppend | cpResume);\r\n  UnicodeString Options = L\"\";\r\n  bool CheckExistence = UnixSamePath(TargetDir, FTerminal->CurrentDirectory) &&\r\n    (FTerminal->FFiles != NULL) && FTerminal->FFiles->Loaded;\r\n  bool CopyBatchStarted = false;\r\n  bool Failed = true;\r\n  bool GotLastLine = false;\r\n\r\n  UnicodeString TargetDirFull = UnixIncludeTrailingBackslash(TargetDir);\r\n\r\n  if (CopyParam->PreserveRights) Options = L\"-p\";\r\n  if (FTerminal->SessionData->Scp1Compatibility) Options += L\" -1\";\r\n\r\n  FScpFatalError = false;\r\n  SendCommand(FCommandSet->FullCommand(fsCopyToRemote,\r\n    ARRAYOFCONST((Options, DelimitStr(UnixExcludeTrailingBackslash(TargetDir))))));\r\n  SkipFirstLine();\r\n\r\n  try\r\n  {\r\n    try\r\n    {\r\n      SCPResponse(&GotLastLine);\r\n\r\n      // This can happen only if SCP command is not executed and return code is 0\r\n      // It has never happened to me (return code is usually 127)\r\n      if (GotLastLine)\r\n      {\r\n        throw Exception(L\"\");\r\n      }\r\n    }\r\n    catch(Exception & E)\r\n    {\r\n      if (GotLastLine && FTerminal->Active)\r\n      {\r\n        FTerminal->TerminalError(&E, LoadStr(SCP_INIT_ERROR));\r\n      }\r\n      else\r\n      {\r\n        throw;\r\n      }\r\n    }\r\n    CopyBatchStarted = true;\r\n\r\n    for (int IFile = 0; (IFile < FilesToCopy->Count) &&\r\n      !OperationProgress->Cancel; IFile++)\r\n    {\r\n      UnicodeString FileName = FilesToCopy->Strings[IFile];\r\n      bool CanProceed;\r\n\r\n      UnicodeString FileNameOnly =\r\n        FTerminal->ChangeFileName(\r\n          CopyParam, ExtractFileName(FileName), osLocal, true);\r\n\r\n      if (CheckExistence)\r\n      {\r\n        // previously there was assertion on FTerminal->FFiles->Loaded, but it\r\n        // fails for scripting, if 'ls' is not issued before.\r\n        // formally we should call CheckRemoteFile here but as checking is for\r\n        // free here (almost) ...\r\n        TRemoteFile * File = FTerminal->FFiles->FindFile(FileNameOnly);\r\n        if (File != NULL)\r\n        {\r\n          unsigned int Answer;\r\n          if (File->IsDirectory)\r\n          {\r\n            UnicodeString Message = FMTLOAD(DIRECTORY_OVERWRITE, (FileNameOnly));\r\n            TQueryParams QueryParams(qpNeverAskAgainCheck);\r\n\r\n            TSuspendFileOperationProgress Suspend(OperationProgress);\r\n            Answer = FTerminal->ConfirmFileOverwrite(\r\n              FileName, FileNameOnly, NULL,\r\n              qaYes | qaNo | qaCancel | qaYesToAll | qaNoToAll,\r\n              &QueryParams, osRemote, CopyParam, Params, OperationProgress, Message);\r\n          }\r\n          else\r\n          {\r\n            __int64 MTime;\r\n            TOverwriteFileParams FileParams;\r\n            FTerminal->OpenLocalFile(FileName, GENERIC_READ,\r\n              NULL, NULL, NULL, &MTime, NULL,\r\n              &FileParams.SourceSize);\r\n            FileParams.SourceTimestamp = UnixToDateTime(MTime,\r\n              FTerminal->SessionData->DSTMode);\r\n            FileParams.DestSize = File->Size;\r\n            FileParams.DestTimestamp = File->Modification;\r\n\r\n            Answer = ConfirmOverwrite(FileName, FileNameOnly, osRemote,\r\n              &FileParams, CopyParam, Params, OperationProgress);\r\n          }\r\n\r\n          switch (Answer)\r\n          {\r\n            case qaYes:\r\n              CanProceed = true;\r\n              break;\r\n\r\n            case qaCancel:\r\n              OperationProgress->SetCancelAtLeast(csCancel);\r\n            case qaNo:\r\n              CanProceed = false;\r\n              break;\r\n\r\n            default:\r\n              DebugFail();\r\n              break;\r\n          }\r\n        }\r\n        else\r\n        {\r\n          CanProceed = true;\r\n        }\r\n      }\r\n      else\r\n      {\r\n        CanProceed = true;\r\n      }\r\n\r\n      if (CanProceed)\r\n      {\r\n        if (FTerminal->SessionData->CacheDirectories)\r\n        {\r\n          FTerminal->DirectoryModified(TargetDir, false);\r\n\r\n          if (DirectoryExists(ApiPath(FileName)))\r\n          {\r\n            FTerminal->DirectoryModified(UnixIncludeTrailingBackslash(TargetDir)+\r\n              FileNameOnly, true);\r\n          }\r\n        }\r\n\r\n        void * Item = static_cast<void *>(FilesToCopy->Objects[IFile]);\r\n\r\n        try\r\n        {\r\n          SCPSource(FileName, TargetDirFull,\r\n            CopyParam, Params, OperationProgress, 0);\r\n          FTerminal->OperationFinish(OperationProgress, Item, FileName, true, OnceDoneOperation);\r\n        }\r\n        catch (EScpFileSkipped &E)\r\n        {\r\n          TQueryParams Params(qpAllowContinueOnError);\r\n\r\n          TSuspendFileOperationProgress Suspend(OperationProgress);\r\n\r\n          if (FTerminal->QueryUserException(FMTLOAD(COPY_ERROR, (FileName)), &E,\r\n            qaOK | qaAbort, &Params, qtError) == qaAbort)\r\n          {\r\n            OperationProgress->SetCancel(csCancel);\r\n          }\r\n          FTerminal->OperationFinish(OperationProgress, Item, FileName, false, OnceDoneOperation);\r\n          if (!FTerminal->HandleException(&E))\r\n          {\r\n            throw;\r\n          }\r\n        }\r\n        catch (ESkipFile &E)\r\n        {\r\n          FTerminal->OperationFinish(OperationProgress, Item, FileName, false, OnceDoneOperation);\r\n\r\n          {\r\n            TSuspendFileOperationProgress Suspend(OperationProgress);\r\n            // If ESkipFile occurs, just log it and continue with next file\r\n            if (!FTerminal->HandleException(&E))\r\n            {\r\n              throw;\r\n            }\r\n          }\r\n        }\r\n        catch (...)\r\n        {\r\n          FTerminal->OperationFinish(OperationProgress, Item, FileName, false, OnceDoneOperation);\r\n          throw;\r\n        }\r\n      }\r\n    }\r\n    Failed = false;\r\n  }\r\n  __finally\r\n  {\r\n    // Tell remote side, that we're done.\r\n    if (FTerminal->Active)\r\n    {\r\n      try\r\n      {\r\n        if (!GotLastLine)\r\n        {\r\n          if (CopyBatchStarted && !FScpFatalError)\r\n          {\r\n            // What about case, remote side sends fatal error ???\r\n            // (Not sure, if it causes remote side to terminate scp)\r\n            FSecureShell->SendLine(L\"E\");\r\n            SCPResponse();\r\n          }\r\n          /* TODO 1 : Show stderror to user? */\r\n          FSecureShell->ClearStdError();\r\n\r\n          ReadCommandOutput(coExpectNoOutput | coWaitForLastLine | coOnlyReturnCode |\r\n            (Failed ? 0 : coRaiseExcept));\r\n        }\r\n      }\r\n      catch (Exception &E)\r\n      {\r\n        // Only log error message (it should always succeed, but\r\n        // some pending error maybe in queue) }\r\n        FTerminal->Log->AddException(&E);\r\n      }\r\n    }\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::Source(\r\n  TLocalFileHandle & /*Handle*/, const UnicodeString & /*TargetDir*/, UnicodeString & /*DestFileName*/,\r\n  const TCopyParamType * /*CopyParam*/, int /*Params*/,\r\n  TFileOperationProgressType * /*OperationProgress*/, unsigned int /*Flags*/,\r\n  TUploadSessionAction & /*Action*/, bool & /*ChildError*/)\r\n{\r\n  DebugFail();\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::SCPSource(const UnicodeString FileName,\r\n  const UnicodeString TargetDir, const TCopyParamType * CopyParam, int Params,\r\n  TFileOperationProgressType * OperationProgress, int Level)\r\n{\r\n  UnicodeString DestFileName =\r\n    FTerminal->ChangeFileName(\r\n      CopyParam, ExtractFileName(FileName), osLocal, Level == 0);\r\n\r\n  FTerminal->LogEvent(FORMAT(L\"File: \\\"%s\\\"\", (FileName)));\r\n\r\n  OperationProgress->SetFile(FileName, false);\r\n\r\n  if (!FTerminal->AllowLocalFileTransfer(FileName, CopyParam, OperationProgress))\r\n  {\r\n    throw ESkipFile();\r\n  }\r\n\r\n  TLocalFileHandle Handle;\r\n  FTerminal->OpenLocalFile(FileName, GENERIC_READ, Handle);\r\n\r\n  OperationProgress->SetFileInProgress();\r\n\r\n  if (Handle.Directory)\r\n  {\r\n    SCPDirectorySource(FileName, TargetDir, CopyParam, Params, OperationProgress, Level);\r\n  }\r\n  else\r\n  {\r\n    UnicodeString AbsoluteFileName = FTerminal->AbsolutePath(TargetDir + DestFileName, false);\r\n\r\n    DebugAssert(Handle.Handle);\r\n    std::unique_ptr<TStream> Stream(new TSafeHandleStream((THandle)Handle.Handle));\r\n\r\n    // File is regular file (not directory)\r\n    FTerminal->LogEvent(FORMAT(L\"Copying \\\"%s\\\" to remote directory started.\", (FileName)));\r\n\r\n    OperationProgress->SetLocalSize(Handle.Size);\r\n\r\n    // Suppose same data size to transfer as to read\r\n    // (not true with ASCII transfer)\r\n    OperationProgress->SetTransferSize(OperationProgress->LocalSize);\r\n    OperationProgress->SetTransferringFile(false);\r\n\r\n    FTerminal->SelectSourceTransferMode(Handle, CopyParam);\r\n\r\n    TUploadSessionAction Action(FTerminal->ActionLog);\r\n    Action.FileName(ExpandUNCFileName(FileName));\r\n    Action.Destination(AbsoluteFileName);\r\n\r\n    TRights Rights = CopyParam->RemoteFileRights(Handle.Attrs);\r\n\r\n    try\r\n    {\r\n      // During ASCII transfer we will load whole file to this buffer\r\n      // than convert EOL and send it at once, because before converting EOL\r\n      // we can't know its size\r\n      TFileBuffer AsciiBuf;\r\n      bool ConvertToken = false;\r\n      do\r\n      {\r\n        // Buffer for one block of data\r\n        TFileBuffer BlockBuf;\r\n\r\n        // This is crucial, if it fails during file transfer, it's fatal error\r\n        FILE_OPERATION_LOOP_BEGIN\r\n        {\r\n          BlockBuf.LoadStream(Stream.get(), OperationProgress->LocalBlockSize(), true);\r\n        }\r\n        FILE_OPERATION_LOOP_END_EX(\r\n          FMTLOAD(READ_ERROR, (FileName)),\r\n          FLAGMASK(!OperationProgress->TransferringFile, folAllowSkip));\r\n\r\n        OperationProgress->AddLocallyUsed(BlockBuf.Size);\r\n\r\n        // We do ASCII transfer: convert EOL of current block\r\n        // (we don't convert whole buffer, cause it would produce\r\n        // huge memory-transfers while inserting/deleting EOL characters)\r\n        // Than we add current block to file buffer\r\n        if (OperationProgress->AsciiTransfer)\r\n        {\r\n          int ConvertParams =\r\n            FLAGMASK(CopyParam->RemoveCtrlZ, cpRemoveCtrlZ) |\r\n            FLAGMASK(CopyParam->RemoveBOM, cpRemoveBOM);\r\n          BlockBuf.Convert(FTerminal->Configuration->LocalEOLType,\r\n            FTerminal->SessionData->EOLType,\r\n            ConvertParams, ConvertToken);\r\n          BlockBuf.Memory->Seek(0, soFromBeginning);\r\n          AsciiBuf.ReadStream(BlockBuf.Memory, BlockBuf.Size, true);\r\n          // We don't need it any more\r\n          BlockBuf.Memory->Clear();\r\n          // Calculate total size to sent (assume that ratio between\r\n          // size of source and size of EOL-transformed data would remain same)\r\n          // First check if file contains anything (div by zero!)\r\n          if (OperationProgress->LocallyUsed)\r\n          {\r\n            __int64 X = OperationProgress->LocalSize;\r\n            X *= AsciiBuf.Size;\r\n            X /= OperationProgress->LocallyUsed;\r\n            OperationProgress->ChangeTransferSize(X);\r\n          }\r\n            else\r\n          {\r\n            OperationProgress->ChangeTransferSize(0);\r\n          }\r\n        }\r\n\r\n        // We send file information on first pass during BINARY transfer\r\n        // and on last pass during ASCII transfer\r\n        // BINARY: We succeeded reading first buffer from file, hopefully\r\n        // we will be able to read whole, so we send file info to remote side\r\n        // This is done, because when reading fails we can't interrupt sending\r\n        // (don't know how to tell other side that it failed)\r\n        if (!OperationProgress->TransferringFile &&\r\n            (!OperationProgress->AsciiTransfer || OperationProgress->IsLocallyDone()))\r\n        {\r\n          UnicodeString Buf;\r\n\r\n          if (CopyParam->PreserveTime)\r\n          {\r\n            // Send last file access and modification time\r\n            // TVarRec don't understand 'unsigned int' -> we use sprintf()\r\n            Buf.sprintf(L\"T%lu 0 %lu 0\", static_cast<unsigned long>(Handle.MTime),\r\n              static_cast<unsigned long>(Handle.ATime));\r\n            FSecureShell->SendLine(Buf);\r\n            SCPResponse();\r\n          }\r\n\r\n          // Send file modes (rights), filesize and file name\r\n          // TVarRec don't understand 'unsigned int' -> we use sprintf()\r\n          Buf.sprintf(L\"C%s %Ld %s\",\r\n            Rights.Octal.data(),\r\n            (OperationProgress->AsciiTransfer ? (__int64)AsciiBuf.Size :\r\n              OperationProgress->LocalSize),\r\n            DestFileName.data());\r\n          FSecureShell->SendLine(Buf);\r\n          SCPResponse();\r\n          // Indicate we started transferring file, we need to finish it\r\n          // If not, it's fatal error\r\n          OperationProgress->SetTransferringFile(true);\r\n\r\n          // If we're doing ASCII transfer, this is last pass\r\n          // so we send whole file\r\n          /* TODO : We can't send file above 32bit size in ASCII mode! */\r\n          if (OperationProgress->AsciiTransfer)\r\n          {\r\n            FTerminal->LogEvent(FORMAT(L\"Sending ASCII data (%u bytes)\",\r\n              (AsciiBuf.Size)));\r\n            // Should be equal, just in case it's rounded (see above)\r\n            OperationProgress->ChangeTransferSize(AsciiBuf.Size);\r\n            while (!OperationProgress->IsTransferDone())\r\n            {\r\n              unsigned long BlockSize = OperationProgress->TransferBlockSize();\r\n              FSecureShell->Send(\r\n                reinterpret_cast<unsigned char *>(AsciiBuf.Data + (unsigned int)OperationProgress->TransferredSize),\r\n                BlockSize);\r\n              OperationProgress->AddTransferred(BlockSize);\r\n              if (OperationProgress->Cancel == csCancelTransfer)\r\n              {\r\n                throw Exception(MainInstructions(LoadStr(USER_TERMINATED)));\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        // At end of BINARY transfer pass, send current block\r\n        if (!OperationProgress->AsciiTransfer)\r\n        {\r\n          if (!OperationProgress->TransferredSize)\r\n          {\r\n            FTerminal->LogEvent(FORMAT(L\"Sending BINARY data (first block, %u bytes)\",\r\n              (BlockBuf.Size)));\r\n          }\r\n          else if (FTerminal->Configuration->ActualLogProtocol >= 1)\r\n          {\r\n            FTerminal->LogEvent(FORMAT(L\"Sending BINARY data (%u bytes)\",\r\n              (BlockBuf.Size)));\r\n          }\r\n          FSecureShell->Send(reinterpret_cast<const unsigned char *>(BlockBuf.Data), BlockBuf.Size);\r\n          OperationProgress->AddTransferred(BlockBuf.Size);\r\n        }\r\n\r\n        if ((OperationProgress->Cancel == csCancelTransfer) ||\r\n            (OperationProgress->Cancel == csCancel && !OperationProgress->TransferringFile))\r\n        {\r\n          throw Exception(MainInstructions(LoadStr(USER_TERMINATED)));\r\n        }\r\n      }\r\n      while (!OperationProgress->IsLocallyDone() || !OperationProgress->IsTransferDone());\r\n\r\n      FSecureShell->SendNull();\r\n      try\r\n      {\r\n        SCPResponse();\r\n        // If one of two following exceptions occurs, it means, that remote\r\n        // side already know, that file transfer finished, even if it failed\r\n        // so we don't have to throw EFatal\r\n      }\r\n      catch (EScp &E)\r\n      {\r\n        // SCP protocol fatal error\r\n        OperationProgress->SetTransferringFile(false);\r\n        throw;\r\n      }\r\n      catch (EScpFileSkipped &E)\r\n      {\r\n        // SCP protocol non-fatal error\r\n        OperationProgress->SetTransferringFile(false);\r\n        throw;\r\n      }\r\n\r\n      // We succeeded transferring file, from now we can handle exceptions\r\n      // normally -> no fatal error\r\n      OperationProgress->SetTransferringFile(false);\r\n    }\r\n    catch (Exception &E)\r\n    {\r\n      // EScpFileSkipped is derived from ESkipFile,\r\n      // but is does not indicate file skipped by user here\r\n      if (dynamic_cast<EScpFileSkipped *>(&E) != NULL)\r\n      {\r\n        Action.Rollback(&E);\r\n      }\r\n      else\r\n      {\r\n        FTerminal->RollbackAction(Action, OperationProgress, &E);\r\n      }\r\n\r\n      // Every exception during file transfer is fatal\r\n      if (OperationProgress->TransferringFile)\r\n      {\r\n        FTerminal->FatalError(&E, FMTLOAD(COPY_FATAL, (FileName)));\r\n      }\r\n      else\r\n      {\r\n        throw;\r\n      }\r\n    }\r\n\r\n    // With SCP we are not able to distinguish reason for failure\r\n    // (upload itself, touch or chmod).\r\n    // So we always report error with upload action and\r\n    // log touch and chmod actions only if upload succeeds.\r\n    if (CopyParam->PreserveTime)\r\n    {\r\n      TTouchSessionAction(FTerminal->ActionLog, AbsoluteFileName, Handle.Modification);\r\n    }\r\n    if (CopyParam->PreserveRights)\r\n    {\r\n      TChmodSessionAction(FTerminal->ActionLog, AbsoluteFileName,\r\n        Rights);\r\n    }\r\n\r\n    FTerminal->LogFileDone(OperationProgress, AbsoluteFileName);\r\n    // Stream is disposed here\r\n  }\r\n\r\n  Handle.Release();\r\n\r\n  FTerminal->UpdateSource(Handle, CopyParam, Params);\r\n\r\n  FTerminal->LogEvent(FORMAT(L\"Copying \\\"%s\\\" to remote directory finished.\", (FileName)));\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::SCPDirectorySource(const UnicodeString DirectoryName,\r\n  const UnicodeString TargetDir, const TCopyParamType * CopyParam, int Params,\r\n  TFileOperationProgressType * OperationProgress, int Level)\r\n{\r\n  int Attrs;\r\n\r\n  FTerminal->LogEvent(FORMAT(L\"Entering directory \\\"%s\\\".\", (DirectoryName)));\r\n\r\n  OperationProgress->SetFile(DirectoryName);\r\n  UnicodeString DestFileName =\r\n    FTerminal->ChangeFileName(\r\n      CopyParam, ExtractFileName(DirectoryName), osLocal, Level == 0);\r\n\r\n  // Get directory attributes\r\n  FILE_OPERATION_LOOP_BEGIN\r\n  {\r\n    Attrs = FileGetAttrFix(ApiPath(DirectoryName));\r\n    if (Attrs < 0) RaiseLastOSError();\r\n  }\r\n  FILE_OPERATION_LOOP_END(FMTLOAD(CANT_GET_ATTRS, (DirectoryName)));\r\n\r\n  UnicodeString TargetDirFull = UnixIncludeTrailingBackslash(TargetDir + DestFileName);\r\n\r\n  UnicodeString Buf;\r\n\r\n  /* TODO 1: maybe send filetime */\r\n\r\n  // Send directory modes (rights), filesize and file name\r\n  Buf = FORMAT(L\"D%s 0 %s\",\r\n    (CopyParam->RemoteFileRights(Attrs).Octal, DestFileName));\r\n  FSecureShell->SendLine(Buf);\r\n  SCPResponse();\r\n\r\n  try\r\n  {\r\n    TSearchRecOwned SearchRec;\r\n    bool FindOK = FTerminal->LocalFindFirstLoop(IncludeTrailingBackslash(DirectoryName) + L\"*.*\", SearchRec);\r\n\r\n    while (FindOK && !OperationProgress->Cancel)\r\n    {\r\n      UnicodeString FileName = IncludeTrailingBackslash(DirectoryName) + SearchRec.Name;\r\n      try\r\n      {\r\n        if (SearchRec.IsRealFile())\r\n        {\r\n          SCPSource(FileName, TargetDirFull, CopyParam, Params, OperationProgress, Level + 1);\r\n        }\r\n      }\r\n      // Previously we caught ESkipFile, making error being displayed\r\n      // even when file was excluded by mask. Now the ESkipFile is special\r\n      // case without error message.\r\n      catch (EScpFileSkipped &E)\r\n      {\r\n        TQueryParams Params(qpAllowContinueOnError);\r\n        TSuspendFileOperationProgress Suspend(OperationProgress);\r\n\r\n        if (FTerminal->QueryUserException(FMTLOAD(COPY_ERROR, (FileName)), &E,\r\n              qaOK | qaAbort, &Params, qtError) == qaAbort)\r\n        {\r\n          OperationProgress->SetCancel(csCancel);\r\n        }\r\n        if (!FTerminal->HandleException(&E))\r\n        {\r\n          throw;\r\n        }\r\n      }\r\n      catch (ESkipFile &E)\r\n      {\r\n        // If ESkipFile occurs, just log it and continue with next file\r\n        TSuspendFileOperationProgress Suspend(OperationProgress);\r\n        if (!FTerminal->HandleException(&E))\r\n        {\r\n          throw;\r\n        }\r\n      }\r\n\r\n      FindOK = FTerminal->LocalFindNextLoop(SearchRec);\r\n    }\r\n\r\n    SearchRec.Close();\r\n\r\n    /* TODO : Delete also read-only directories. */\r\n    /* TODO : Show error message on failure. */\r\n    if (!OperationProgress->Cancel)\r\n    {\r\n      if (FLAGSET(Params, cpDelete))\r\n      {\r\n        RemoveDir(ApiPath(DirectoryName));\r\n      }\r\n      else if (CopyParam->ClearArchive && FLAGSET(Attrs, faArchive))\r\n      {\r\n        FILE_OPERATION_LOOP_BEGIN\r\n        {\r\n          THROWOSIFFALSE(FileSetAttr(ApiPath(DirectoryName), Attrs & ~faArchive) == 0);\r\n        }\r\n        FILE_OPERATION_LOOP_END(FMTLOAD(CANT_SET_ATTRS, (DirectoryName)));\r\n      }\r\n    }\r\n  }\r\n  __finally\r\n  {\r\n    if (FTerminal->Active)\r\n    {\r\n      // Tell remote side, that we're done.\r\n      FTerminal->LogEvent(FORMAT(L\"Leaving directory \\\"%s\\\".\", (DirectoryName)));\r\n      FSecureShell->SendLine(L\"E\");\r\n      SCPResponse();\r\n    }\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::CopyToLocal(TStrings * FilesToCopy,\r\n  const UnicodeString TargetDir, const TCopyParamType * CopyParam,\r\n  int Params, TFileOperationProgressType * OperationProgress,\r\n  TOnceDoneOperation & OnceDoneOperation)\r\n{\r\n  bool CloseSCP = False;\r\n  Params &= ~(cpAppend | cpResume);\r\n  UnicodeString Options = L\"\";\r\n  if (CopyParam->PreserveRights || CopyParam->PreserveTime) Options = L\"-p\";\r\n  if (FTerminal->SessionData->Scp1Compatibility) Options += L\" -1\";\r\n\r\n  FTerminal->LogEvent(FORMAT(L\"Copying %d files/directories to local directory \"\r\n    \"\\\"%s\\\"\", (FilesToCopy->Count, TargetDir)));\r\n  if (FTerminal->Configuration->ActualLogProtocol >= 0)\r\n  {\r\n    FTerminal->LogEvent(CopyParam->LogStr);\r\n  }\r\n\r\n  try\r\n  {\r\n    for (int IFile = 0; (IFile < FilesToCopy->Count) &&\r\n      !OperationProgress->Cancel; IFile++)\r\n    {\r\n      UnicodeString FileName = FilesToCopy->Strings[IFile];\r\n      TRemoteFile * File = (TRemoteFile *)FilesToCopy->Objects[IFile];\r\n      DebugAssert(File);\r\n\r\n      try\r\n      {\r\n        bool Success = true; // Have to be set to True (see ::SCPSink)\r\n        SendCommand(FCommandSet->FullCommand(fsCopyToLocal,\r\n          ARRAYOFCONST((Options, DelimitStr(FileName)))));\r\n        SkipFirstLine();\r\n\r\n        // Filename is used for error messaging and excluding files only\r\n        // Send in full path to allow path-based excluding\r\n        UnicodeString FullFileName = UnixExcludeTrailingBackslash(File->FullFileName);\r\n        SCPSink(TargetDir, FullFileName, UnixExtractFilePath(FullFileName),\r\n          CopyParam, Success, OperationProgress, Params, 0);\r\n        // operation succeeded (no exception), so it's ok that\r\n        // remote side closed SCP, but we continue with next file\r\n        if (OperationProgress->Cancel == csRemoteAbort)\r\n        {\r\n          OperationProgress->SetCancel(csContinue);\r\n        }\r\n\r\n        // Move operation -> delete file/directory afterwards\r\n        // but only if copying succeeded\r\n        if ((Params & cpDelete) && Success && !OperationProgress->Cancel)\r\n        {\r\n          try\r\n          {\r\n            FTerminal->ExceptionOnFail = true;\r\n            try\r\n            {\r\n              FILE_OPERATION_LOOP_BEGIN\r\n              {\r\n                // pass full file name in FileName, in case we are not moving\r\n                // from current directory\r\n                FTerminal->DeleteFile(FileName, File);\r\n              }\r\n              FILE_OPERATION_LOOP_END(FMTLOAD(DELETE_FILE_ERROR, (FileName)));\r\n            }\r\n            __finally\r\n            {\r\n              FTerminal->ExceptionOnFail = false;\r\n            }\r\n          }\r\n          catch (EFatal &E)\r\n          {\r\n            throw;\r\n          }\r\n          catch (...)\r\n          {\r\n            // If user selects skip (or abort), nothing special actually occurs\r\n            // we just run DoFinished with Success = False, so file won't\r\n            // be deselected in panel (depends on assigned event handler)\r\n\r\n            // On csCancel we would later try to close remote SCP, but it\r\n            // is closed already\r\n            if (OperationProgress->Cancel == csCancel)\r\n            {\r\n              OperationProgress->SetCancel(csRemoteAbort);\r\n            }\r\n            Success = false;\r\n          }\r\n        }\r\n\r\n        FTerminal->OperationFinish(\r\n          OperationProgress, File, FileName, (!OperationProgress->Cancel && Success), OnceDoneOperation);\r\n      }\r\n      catch (...)\r\n      {\r\n        FTerminal->OperationFinish(OperationProgress, File, FileName, false, OnceDoneOperation);\r\n        CloseSCP = (OperationProgress->Cancel != csRemoteAbort);\r\n        throw;\r\n      }\r\n    }\r\n  }\r\n  __finally\r\n  {\r\n    // In case that copying doesn't cause fatal error (ie. connection is\r\n    // still active) but wasn't successful (exception or user termination)\r\n    // we need to ensure, that SCP on remote side is closed\r\n    if (FTerminal->Active && (CloseSCP ||\r\n        (OperationProgress->Cancel == csCancel) ||\r\n        (OperationProgress->Cancel == csCancelTransfer)))\r\n    {\r\n      bool LastLineRead;\r\n\r\n      // If we get LastLine, it means that remote side 'scp' is already\r\n      // terminated, so we need not to terminate it. There is also\r\n      // possibility that remote side waits for confirmation, so it will hang.\r\n      // This should not happen (hope)\r\n      UnicodeString Line = FSecureShell->ReceiveLine();\r\n      LastLineRead = IsLastLine(Line);\r\n      if (!LastLineRead)\r\n      {\r\n        SCPSendError((OperationProgress->Cancel ? L\"Terminated by user.\" : L\"Exception\"), true);\r\n      }\r\n      // Just in case, remote side already sent some more data (it's probable)\r\n      // but we don't want to raise exception (user asked to terminate, it's not error)\r\n      int ECParams = coOnlyReturnCode;\r\n      if (!LastLineRead) ECParams |= coWaitForLastLine;\r\n      ReadCommandOutput(ECParams);\r\n    }\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::Sink(\r\n  const UnicodeString & /*FileName*/, const TRemoteFile * /*File*/,\r\n  const UnicodeString & /*TargetDir*/, UnicodeString & /*DestFileName*/, int /*Attrs*/,\r\n  const TCopyParamType * /*CopyParam*/, int /*Params*/, TFileOperationProgressType * /*OperationProgress*/,\r\n  unsigned int /*Flags*/, TDownloadSessionAction & /*Action*/)\r\n{\r\n  DebugFail();\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::SCPError(const UnicodeString Message, bool Fatal)\r\n{\r\n  SCPSendError(Message, Fatal);\r\n  throw EScpFileSkipped(NULL, Message);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::SCPSendError(const UnicodeString Message, bool Fatal)\r\n{\r\n  unsigned char ErrorLevel = (char)(Fatal ? 2 : 1);\r\n  FTerminal->LogEvent(FORMAT(L\"Sending SCP error (%d) to remote side:\",\r\n    ((int)ErrorLevel)));\r\n  FSecureShell->Send(&ErrorLevel, 1);\r\n  // We don't send exact error message, because some unspecified\r\n  // characters can terminate remote scp\r\n  FSecureShell->SendLine(L\"scp: error\");\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::SCPSink(const UnicodeString TargetDir,\r\n  const UnicodeString FileName, const UnicodeString SourceDir,\r\n  const TCopyParamType * CopyParam, bool & Success,\r\n  TFileOperationProgressType * OperationProgress, int Params,\r\n  int Level)\r\n{\r\n  struct\r\n  {\r\n    int SetTime;\r\n    TDateTime Modification;\r\n    TRights RemoteRights;\r\n    int Attrs;\r\n    bool Exists;\r\n  } FileData;\r\n\r\n  bool SkipConfirmed = false;\r\n  bool Initialized = (Level > 0);\r\n\r\n  FileData.SetTime = 0;\r\n\r\n  FSecureShell->SendNull();\r\n\r\n  while (!OperationProgress->Cancel)\r\n  {\r\n    // See (switch ... case 'T':)\r\n    if (FileData.SetTime) FileData.SetTime--;\r\n\r\n    // In case of error occurred before control record arrived.\r\n    // We can finally use full path here, as we get current path in FileName param\r\n    // (we used to set the file into OperationProgress->FileName, but it collided\r\n    // with progress outputting, particularly for scripting)\r\n    UnicodeString FullFileName = FileName;\r\n\r\n    try\r\n    {\r\n      // Receive control record\r\n      UnicodeString Line = FSecureShell->ReceiveLine();\r\n\r\n      if (Line.Length() == 0) FTerminal->FatalError(NULL, LoadStr(SCP_EMPTY_LINE));\r\n\r\n      if (IsLastLine(Line))\r\n      {\r\n        // Remote side finished copying, so remote SCP was closed\r\n        // and we don't need to terminate it manually, see CopyToLocal()\r\n        OperationProgress->SetCancel(csRemoteAbort);\r\n        /* TODO 1 : Show stderror to user? */\r\n        FSecureShell->ClearStdError();\r\n        try\r\n        {\r\n          // coIgnoreWarnings should allow batch transfer to continue when\r\n          // download of one the files fails (user denies overwriting\r\n          // of target local file, no read permissions...)\r\n          ReadCommandOutput(coExpectNoOutput | coRaiseExcept |\r\n            coOnlyReturnCode | coIgnoreWarnings);\r\n          if (!Initialized)\r\n          {\r\n            throw Exception(L\"\");\r\n          }\r\n        }\r\n        catch(Exception & E)\r\n        {\r\n          if (!Initialized && FTerminal->Active)\r\n          {\r\n            FTerminal->TerminalError(&E, LoadStr(SCP_INIT_ERROR));\r\n          }\r\n          else\r\n          {\r\n            throw;\r\n          }\r\n        }\r\n        return;\r\n      }\r\n      else\r\n      {\r\n        Initialized = true;\r\n\r\n        // First character distinguish type of control record\r\n        wchar_t Ctrl = Line[1];\r\n        Line.Delete(1, 1);\r\n\r\n        switch (Ctrl) {\r\n          case 1:\r\n            // Error (already logged by ReceiveLine())\r\n            throw EScpFileSkipped(NULL, FMTLOAD(REMOTE_ERROR, (Line)));\r\n\r\n          case 2:\r\n            // Fatal error, terminate copying\r\n            FTerminal->TerminalError(Line);\r\n            return; // Unreachable\r\n\r\n          case L'E': // Exit\r\n            FSecureShell->SendNull();\r\n            return;\r\n\r\n          case L'T':\r\n            unsigned long MTime, ATime;\r\n            if (swscanf(Line.c_str(), L\"%ld %*d %ld %*d\",  &MTime, &ATime) == 2)\r\n            {\r\n              FileData.Modification = UnixToDateTime(MTime, FTerminal->SessionData->DSTMode);\r\n              FSecureShell->SendNull();\r\n              // File time is only valid until next pass\r\n              FileData.SetTime = 2;\r\n              continue;\r\n            }\r\n              else\r\n            {\r\n              SCPError(LoadStr(SCP_ILLEGAL_TIME_FORMAT), False);\r\n            }\r\n\r\n          case L'C':\r\n          case L'D':\r\n            break; // continue pass switch{}\r\n\r\n          default:\r\n            FTerminal->FatalError(NULL, FMTLOAD(SCP_INVALID_CONTROL_RECORD, (Ctrl, Line)));\r\n        }\r\n\r\n        TFileMasks::TParams MaskParams;\r\n        MaskParams.Modification = FileData.Modification;\r\n\r\n        // We reach this point only if control record was 'C' or 'D'\r\n        try\r\n        {\r\n          FileData.RemoteRights.Octal = CutToChar(Line, L' ', True);\r\n          // do not trim leading spaces of the filename\r\n          __int64 TSize = StrToInt64(CutToChar(Line, L' ', False).TrimRight());\r\n          MaskParams.Size = TSize;\r\n          // Security fix: ensure the file ends up where we asked for it.\r\n          // (accept only filename, not path)\r\n          UnicodeString OnlyFileName = UnixExtractFileName(Line);\r\n          if (Line != OnlyFileName)\r\n          {\r\n            FTerminal->LogEvent(FORMAT(L\"Warning: Remote host set a compound pathname '%s'\", (Line)));\r\n          }\r\n\r\n          FullFileName = SourceDir + OnlyFileName;\r\n          OperationProgress->SetFile(FullFileName);\r\n          OperationProgress->SetTransferSize(TSize);\r\n        }\r\n        catch (Exception &E)\r\n        {\r\n          {\r\n            TSuspendFileOperationProgress Suspend(OperationProgress);\r\n            FTerminal->Log->AddException(&E);\r\n          }\r\n          SCPError(LoadStr(SCP_ILLEGAL_FILE_DESCRIPTOR), false);\r\n        }\r\n\r\n        // last possibility to cancel transfer before it starts\r\n        if (OperationProgress->Cancel)\r\n        {\r\n          throw ESkipFile(NULL, MainInstructions(LoadStr(USER_TERMINATED)));\r\n        }\r\n\r\n        bool Dir = (Ctrl == L'D');\r\n        UnicodeString BaseFileName = FTerminal->GetBaseFileName(FullFileName);\r\n        if (!CopyParam->AllowTransfer(BaseFileName, osRemote, Dir, MaskParams, IsUnixHiddenFile(BaseFileName)))\r\n        {\r\n          FTerminal->LogEvent(FORMAT(L\"File \\\"%s\\\" excluded from transfer\",\r\n            (FullFileName)));\r\n          SkipConfirmed = true;\r\n          SCPError(L\"\", false);\r\n        }\r\n\r\n        if (CopyParam->SkipTransfer(FullFileName, Dir))\r\n        {\r\n          SkipConfirmed = true;\r\n          SCPError(L\"\", false);\r\n          OperationProgress->AddSkippedFileSize(MaskParams.Size);\r\n        }\r\n\r\n        FTerminal->LogFileDetails(FileName, FileData.Modification, MaskParams.Size);\r\n\r\n        UnicodeString DestFileNameOnly =\r\n          FTerminal->ChangeFileName(\r\n            CopyParam, OperationProgress->FileName, osRemote,\r\n            Level == 0);\r\n        UnicodeString DestFileName =\r\n          IncludeTrailingBackslash(TargetDir) + DestFileNameOnly;\r\n\r\n        FileData.Attrs = FileGetAttrFix(ApiPath(DestFileName));\r\n        // If getting attrs fails, we suppose, that file/folder doesn't exists\r\n        FileData.Exists = (FileData.Attrs != -1);\r\n        if (Dir)\r\n        {\r\n          if (FileData.Exists && !(FileData.Attrs & faDirectory))\r\n          {\r\n            SCPError(FMTLOAD(NOT_DIRECTORY_ERROR, (DestFileName)), false);\r\n          }\r\n\r\n          if (!FileData.Exists)\r\n          {\r\n            FILE_OPERATION_LOOP_BEGIN\r\n            {\r\n              THROWOSIFFALSE(ForceDirectories(ApiPath(DestFileName)));\r\n            }\r\n            FILE_OPERATION_LOOP_END(FMTLOAD(CREATE_DIR_ERROR, (DestFileName)));\r\n            /* SCP: can we set the timestamp for directories ? */\r\n          }\r\n          UnicodeString FullFileName = SourceDir + OperationProgress->FileName;\r\n          SCPSink(DestFileName, FullFileName, UnixIncludeTrailingBackslash(FullFileName),\r\n            CopyParam, Success, OperationProgress, Params, Level + 1);\r\n          continue;\r\n        }\r\n        else if (Ctrl == L'C')\r\n        {\r\n          TDownloadSessionAction Action(FTerminal->ActionLog);\r\n          Action.FileName(FTerminal->AbsolutePath(FullFileName, true));\r\n\r\n          try\r\n          {\r\n            HANDLE File = NULL;\r\n            TStream * FileStream = NULL;\r\n\r\n            /* TODO 1 : Turn off read-only attr */\r\n\r\n            try\r\n            {\r\n              try\r\n              {\r\n                if (FileExists(ApiPath(DestFileName)))\r\n                {\r\n                  __int64 MTime;\r\n                  TOverwriteFileParams FileParams;\r\n                  FileParams.SourceSize = OperationProgress->TransferSize;\r\n                  FileParams.SourceTimestamp = FileData.Modification;\r\n                  FTerminal->OpenLocalFile(DestFileName, GENERIC_READ,\r\n                    NULL, NULL, NULL, &MTime, NULL,\r\n                    &FileParams.DestSize);\r\n                  FileParams.DestTimestamp = UnixToDateTime(MTime,\r\n                    FTerminal->SessionData->DSTMode);\r\n\r\n                  unsigned int Answer =\r\n                    ConfirmOverwrite(OperationProgress->FileName, DestFileNameOnly, osLocal,\r\n                      &FileParams, CopyParam, Params, OperationProgress);\r\n\r\n                  switch (Answer)\r\n                  {\r\n                    case qaCancel:\r\n                      OperationProgress->SetCancel(csCancel); // continue on next case\r\n                    case qaNo:\r\n                      SkipConfirmed = true;\r\n                      EXCEPTION;\r\n                  }\r\n                }\r\n\r\n                Action.Destination(DestFileName);\r\n\r\n                if (!FTerminal->CreateLocalFile(DestFileName, OperationProgress,\r\n                       &File, FLAGSET(Params, cpNoConfirmation)))\r\n                {\r\n                  SkipConfirmed = true;\r\n                  EXCEPTION;\r\n                }\r\n\r\n                FileStream = new TSafeHandleStream((THandle)File);\r\n              }\r\n              catch (Exception &E)\r\n              {\r\n                // In this step we can still cancel transfer, so we do it\r\n                SCPError(E.Message, false);\r\n                throw;\r\n              }\r\n\r\n              // We succeeded, so we confirm transfer to remote side\r\n              FSecureShell->SendNull();\r\n              // From now we need to finish file transfer, if not it's fatal error\r\n              OperationProgress->SetTransferringFile(true);\r\n\r\n              // Suppose same data size to transfer as to write\r\n              // (not true with ASCII transfer)\r\n              OperationProgress->SetLocalSize(OperationProgress->TransferSize);\r\n\r\n              // Will we use ASCII of BINARY file transfer?\r\n              OperationProgress->SetAsciiTransfer(\r\n                CopyParam->UseAsciiTransfer(BaseFileName, osRemote, MaskParams));\r\n              if (FTerminal->Configuration->ActualLogProtocol >= 0)\r\n              {\r\n                FTerminal->LogEvent(UnicodeString((OperationProgress->AsciiTransfer ? L\"Ascii\" : L\"Binary\")) +\r\n                  L\" transfer mode selected.\");\r\n              }\r\n\r\n              try\r\n              {\r\n                // Buffer for one block of data\r\n                TFileBuffer BlockBuf;\r\n                bool ConvertToken = false;\r\n\r\n                do\r\n                {\r\n                  BlockBuf.Size = OperationProgress->TransferBlockSize();\r\n                  BlockBuf.Position = 0;\r\n\r\n                  FSecureShell->Receive(reinterpret_cast<unsigned char *>(BlockBuf.Data), BlockBuf.Size);\r\n                  OperationProgress->AddTransferred(BlockBuf.Size);\r\n\r\n                  if (OperationProgress->AsciiTransfer)\r\n                  {\r\n                    unsigned int PrevBlockSize = BlockBuf.Size;\r\n                    BlockBuf.Convert(FTerminal->SessionData->EOLType,\r\n                      FTerminal->Configuration->LocalEOLType, 0, ConvertToken);\r\n                    OperationProgress->SetLocalSize(\r\n                      OperationProgress->LocalSize - PrevBlockSize + BlockBuf.Size);\r\n                  }\r\n\r\n                  // This is crucial, if it fails during file transfer, it's fatal error\r\n                  FILE_OPERATION_LOOP_BEGIN\r\n                  {\r\n                    BlockBuf.WriteToStream(FileStream, BlockBuf.Size);\r\n                  }\r\n                  FILE_OPERATION_LOOP_END_EX(FMTLOAD(WRITE_ERROR, (DestFileName)), folNone);\r\n\r\n                  OperationProgress->AddLocallyUsed(BlockBuf.Size);\r\n\r\n                  if (OperationProgress->Cancel == csCancelTransfer)\r\n                  {\r\n                    throw Exception(MainInstructions(LoadStr(USER_TERMINATED)));\r\n                  }\r\n                }\r\n                while (!OperationProgress->IsLocallyDone() || !\r\n                    OperationProgress->IsTransferDone());\r\n              }\r\n              catch (Exception &E)\r\n              {\r\n                // Every exception during file transfer is fatal\r\n                FTerminal->FatalError(&E,\r\n                  FMTLOAD(COPY_FATAL, (OperationProgress->FileName)));\r\n              }\r\n\r\n              OperationProgress->SetTransferringFile(false);\r\n\r\n              try\r\n              {\r\n                SCPResponse();\r\n                // If one of following exception occurs, we still need\r\n                // to send confirmation to other side\r\n              }\r\n              catch (EScp &E)\r\n              {\r\n                FSecureShell->SendNull();\r\n                throw;\r\n              }\r\n              catch (EScpFileSkipped &E)\r\n              {\r\n                FSecureShell->SendNull();\r\n                throw;\r\n              }\r\n\r\n              FSecureShell->SendNull();\r\n\r\n              if (FileData.SetTime && CopyParam->PreserveTime)\r\n              {\r\n                FTerminal->UpdateTargetTime(File, FileData.Modification, FTerminal->SessionData->DSTMode);\r\n              }\r\n            }\r\n            __finally\r\n            {\r\n              if (File) CloseHandle(File);\r\n              if (FileStream) delete FileStream;\r\n            }\r\n          }\r\n          catch(Exception & E)\r\n          {\r\n            if (SkipConfirmed)\r\n            {\r\n              Action.Cancel();\r\n            }\r\n            else\r\n            {\r\n              FTerminal->RollbackAction(Action, OperationProgress, &E);\r\n            }\r\n            throw;\r\n          }\r\n\r\n          if (FileData.Attrs == -1) FileData.Attrs = faArchive;\r\n          int NewAttrs = CopyParam->LocalFileAttrs(FileData.RemoteRights);\r\n          if ((NewAttrs & FileData.Attrs) != NewAttrs)\r\n          {\r\n            FILE_OPERATION_LOOP_BEGIN\r\n            {\r\n              THROWOSIFFALSE(FileSetAttr(ApiPath(DestFileName), FileData.Attrs | NewAttrs) == 0);\r\n            }\r\n            FILE_OPERATION_LOOP_END(FMTLOAD(CANT_SET_ATTRS, (DestFileName)));\r\n          }\r\n\r\n          FTerminal->LogFileDone(OperationProgress, DestFileName);\r\n        }\r\n      }\r\n    }\r\n    catch (EScpFileSkipped &E)\r\n    {\r\n      if (!SkipConfirmed)\r\n      {\r\n        TSuspendFileOperationProgress Suspend(OperationProgress);\r\n        TQueryParams Params(qpAllowContinueOnError);\r\n        if (FTerminal->QueryUserException(FMTLOAD(COPY_ERROR, (FullFileName)),\r\n              &E, qaOK | qaAbort, &Params, qtError) == qaAbort)\r\n        {\r\n          OperationProgress->SetCancel(csCancel);\r\n        }\r\n        FTerminal->Log->AddException(&E);\r\n      }\r\n      // this was inside above condition, but then transfer was considered\r\n      // successful, even when for example user refused to overwrite file\r\n      Success = false;\r\n    }\r\n    catch (ESkipFile &E)\r\n    {\r\n      SCPSendError(E.Message, false);\r\n      Success = false;\r\n      if (!FTerminal->HandleException(&E)) throw;\r\n    }\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::GetSupportedChecksumAlgs(TStrings * /*Algs*/)\r\n{\r\n  // NOOP\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::LockFile(const UnicodeString & /*FileName*/, const TRemoteFile * /*File*/)\r\n{\r\n  DebugFail();\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::UnlockFile(const UnicodeString & /*FileName*/, const TRemoteFile * /*File*/)\r\n{\r\n  DebugFail();\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::UpdateFromMain(TCustomFileSystem * /*MainFileSystem*/)\r\n{\r\n  // noop\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::ClearCaches()\r\n{\r\n  // noop\r\n}\r\n", "#ifndef TextsCoreH\r\n#define TextsCoreH\r\n\r\n#define UNKNOWN_KEY4    1\r\n#define DIFFERENT_KEY5  2\r\n#define OLD_KEY         3\r\n\r\n#define SCRIPT_HELP_HELP        4\r\n#define SCRIPT_EXIT_HELP        5\r\n#define SCRIPT_OPEN_HELP10      6\r\n#define SCRIPT_CLOSE_HELP       7\r\n#define SCRIPT_SESSION_HELP     8\r\n#define SCRIPT_PWD_HELP         9\r\n#define SCRIPT_CD_HELP          10\r\n#define SCRIPT_LS_HELP2         11\r\n#define SCRIPT_LPWD_HELP        12\r\n#define SCRIPT_LCD_HELP         13\r\n#define SCRIPT_LLS_HELP2        14\r\n#define SCRIPT_RM_HELP2         15\r\n#define SCRIPT_RMDIR_HELP       16\r\n#define SCRIPT_MV_HELP2         17\r\n#define SCRIPT_CHMOD_HELP2      18\r\n#define SCRIPT_LN_HELP          19\r\n#define SCRIPT_MKDIR_HELP       20\r\n#define SCRIPT_GET_HELP8        21\r\n#define SCRIPT_PUT_HELP8        22\r\n#define SCRIPT_OPTION_HELP7     23\r\n#define SCRIPT_SYNCHRONIZE_HELP7 24\r\n#define SCRIPT_KEEPUPTODATE_HELP5 25\r\n#define SCRIPT_CALL_HELP2       26\r\n#define SCRIPT_ECHO_HELP        27\r\n#define SCRIPT_STAT_HELP        28\r\n#define SCRIPT_CHECKSUM_HELP    29\r\n#define SCRIPT_CP_HELP          30\r\n\r\n#define CORE_ERROR_STRINGS      100\r\n#define KEY_NOT_VERIFIED        101\r\n#define CONNECTION_FAILED       102\r\n#define USER_TERMINATED         103\r\n#define LOST_CONNECTION         104\r\n#define CANT_DETECT_RETURN_CODE 105\r\n#define COMMAND_FAILED          106\r\n#define COMMAND_FAILED_CODEONLY 107\r\n#define INVALID_OUTPUT_ERROR    108\r\n#define READ_CURRENT_DIR_ERROR  109\r\n#define SKIP_STARTUP_MESSAGE_ERROR 110\r\n#define CHANGE_DIR_ERROR        111\r\n#define LIST_DIR_ERROR          113\r\n#define LIST_LINE_ERROR         114\r\n#define RIGHTS_ERROR            115\r\n#define CLEANUP_CONFIG_ERROR    116\r\n#define CLEANUP_HOSTKEYS_ERROR  117\r\n#define CLEANUP_SEEDFILE_ERROR  118\r\n#define CLEANUP_SESSIONS_ERROR  119\r\n#define DETECT_RETURNVAR_ERROR  120\r\n#define LOOKUP_GROUPS_ERROR     121\r\n#define FILE_NOT_EXISTS         122\r\n#define CANT_GET_ATTRS          123\r\n#define OPENFILE_ERROR          124\r\n#define READ_ERROR              125\r\n#define COPY_FATAL              126\r\n#define TOREMOTE_COPY_ERROR     127\r\n#define TOLOCAL_COPY_ERROR      128\r\n#define SCP_EMPTY_LINE          129\r\n#define SCP_ILLEGAL_TIME_FORMAT 130\r\n#define SCP_INVALID_CONTROL_RECORD 131\r\n#define COPY_ERROR              132\r\n#define SCP_ILLEGAL_FILE_DESCRIPTOR 133\r\n#define NOT_DIRECTORY_ERROR     134\r\n#define CREATE_DIR_ERROR        135\r\n#define CREATE_FILE_ERROR       136\r\n#define WRITE_ERROR             137\r\n#define CANT_SET_ATTRS          138\r\n#define REMOTE_ERROR            139\r\n#define DELETE_FILE_ERROR       140\r\n#define LOG_GEN_ERROR           141\r\n#define LOG_OPENERROR           142\r\n#define RENAME_FILE_ERROR       143\r\n#define RENAME_CREATE_FILE_EXISTS 144\r\n#define RENAME_CREATE_DIR_EXISTS 145\r\n#define CHANGE_HOMEDIR_ERROR    146\r\n#define UNALIAS_ALL_ERROR       147\r\n#define UNSET_NATIONAL_ERROR    149\r\n#define FIRST_LINE_EXPECTED     150\r\n#define CLEANUP_INIFILE_ERROR   151\r\n#define AUTHENTICATION_LOG      153\r\n#define AUTHENTICATION_FAILED   154\r\n#define NOT_CONNECTED           155\r\n#define SAVE_KEY_ERROR          156\r\n#define SSH_EXITCODE            158\r\n#define SFTP_INVALID_TYPE       159\r\n#define SFTP_VERSION_NOT_SUPPORTED 160\r\n#define SFTP_MESSAGE_NUMBER     161\r\n#define SFTP_STATUS_OK          162\r\n#define SFTP_STATUS_EOF         163\r\n#define SFTP_STATUS_NO_SUCH_FILE 164\r\n#define SFTP_STATUS_PERMISSION_DENIED 165\r\n#define SFTP_STATUS_FAILURE     166\r\n#define SFTP_STATUS_BAD_MESSAGE 167\r\n#define SFTP_STATUS_NO_CONNECTION 168\r\n#define SFTP_STATUS_CONNECTION_LOST 169\r\n#define SFTP_STATUS_OP_UNSUPPORTED 170\r\n#define SFTP_ERROR_FORMAT3      171\r\n#define SFTP_STATUS_UNKNOWN     172\r\n#define READ_SYMLINK_ERROR      173\r\n#define EMPTY_DIRECTORY         174\r\n#define SFTP_NON_ONE_FXP_NAME_PACKET 175\r\n#define SFTP_REALPATH_ERROR     176\r\n#define CHANGE_PROPERTIES_ERROR 177\r\n#define SFTP_INITIALIZE_ERROR   178\r\n#define TIMEZONE_ERROR          179\r\n#define SFTP_CREATE_FILE_ERROR  180\r\n#define SFTP_OPEN_FILE_ERROR    181\r\n#define SFTP_CLOSE_FILE_ERROR   182\r\n#define NOT_FILE_ERROR          183\r\n#define RENAME_AFTER_RESUME_ERROR 184\r\n#define CREATE_LINK_ERROR       185\r\n#define INVALID_SHELL_COMMAND   186\r\n#define SFTP_SERVER_MESSAGE_UNSUPPORTED 187\r\n#define INVALID_OCTAL_PERMISSIONS 188\r\n#define SFTP_INVALID_EOL        189\r\n#define SFTP_UNKNOWN_FILE_TYPE  190\r\n#define SFTP_STATUS_INVALID_HANDLE 191\r\n#define SFTP_STATUS_NO_SUCH_PATH 192\r\n#define SFTP_STATUS_FILE_ALREADY_EXISTS 193\r\n#define SFTP_STATUS_WRITE_PROTECT 194\r\n#define SFTP_STATUS_NO_MEDIA    195\r\n#define DECODE_UTF_ERROR        196\r\n#define CUSTOM_COMMAND_ERROR    197\r\n#define LOCALE_LOAD_ERROR       198\r\n#define SFTP_INCOMPLETE_BEFORE_EOF 199\r\n#define CALCULATE_SIZE_ERROR    200\r\n#define SFTP_PACKET_TOO_BIG     201\r\n#define SCP_INIT_ERROR          202\r\n#define DUPLICATE_BOOKMARK      203\r\n#define MOVE_FILE_ERROR         204\r\n#define SFTP_PACKET_TOO_BIG_INIT_EXPLAIN 205\r\n#define PRESERVE_TIME_PERM_ERROR3 206\r\n#define ACCESS_VIOLATION_ERROR3 207\r\n#define SFTP_STATUS_NO_SPACE_ON_FILESYSTEM 208\r\n#define SFTP_STATUS_QUOTA_EXCEEDED 209\r\n#define SFTP_STATUS_UNKNOWN_PRINCIPAL 210\r\n#define COPY_FILE_ERROR         211\r\n#define CUSTOM_COMMAND_UNTERMINATED 212\r\n#define CUSTOM_COMMAND_UNKNOWN  213\r\n#define CUSTOM_COMMAND_FILELIST_ERROR 214\r\n#define SCRIPT_COMMAND_UNKNOWN  215\r\n#define SCRIPT_COMMAND_AMBIGUOUS 216\r\n#define SCRIPT_MISSING_PARAMS   217\r\n#define SCRIPT_TOO_MANY_PARAMS  218\r\n#define SCRIPT_NO_SESSION       223\r\n#define SCRIPT_SESSION_INDEX_INVALID 224\r\n#define SCRIPT_OPTION_UNKNOWN   225\r\n#define SCRIPT_VALUE_UNKNOWN    226\r\n#define UNKNOWN_SOCKET_STATUS   227\r\n#define DELETE_ON_RESUME_ERROR  228\r\n#define SFTP_PACKET_ERROR       229\r\n#define ITEM_NAME_INVALID       230\r\n#define SFTP_STATUS_LOCK_CONFLICT 231\r\n#define SFTP_STATUS_DIR_NOT_EMPTY 232\r\n#define SFTP_STATUS_NOT_A_DIRECTORY 233\r\n#define SFTP_STATUS_INVALID_FILENAME 234\r\n#define SFTP_STATUS_LINK_LOOP   235\r\n#define SFTP_STATUS_CANNOT_DELETE 236\r\n#define SFTP_STATUS_INVALID_PARAMETER 237\r\n#define SFTP_STATUS_FILE_IS_A_DIRECTORY 238\r\n#define SFTP_STATUS_BYTE_RANGE_LOCK_CONFLICT 239\r\n#define SFTP_STATUS_BYTE_RANGE_LOCK_REFUSED 240\r\n#define SFTP_STATUS_DELETE_PENDING 241\r\n#define SFTP_STATUS_FILE_CORRUPT 242\r\n#define KEY_TYPE_UNKNOWN2       243\r\n#define KEY_TYPE_UNSUPPORTED2   244\r\n#define KEY_TYPE_DIFFERENT_SSH  245\r\n#define SFTP_OVERWRITE_FILE_ERROR2 246\r\n#define SFTP_OVERWRITE_DELETE_BUTTON 247\r\n#define SPACE_AVAILABLE_ERROR   248\r\n#define TUNNEL_NO_FREE_PORT     249\r\n#define EVENT_SELECT_ERROR      250\r\n#define UNEXPECTED_CLOSE_ERROR  251\r\n#define TUNNEL_ERROR            252\r\n#define CHECKSUM_ERROR          253\r\n#define INTERNAL_ERROR          254\r\n#define NOTSUPPORTED            255\r\n#define FTP_ACCESS_DENIED       256\r\n#define FTP_CREDENTIAL_PROMPT   257\r\n#define FTP_RESPONSE_ERROR      258\r\n#define SCRIPT_UNKNOWN_SWITCH   260\r\n#define TRANSFER_ERROR          261\r\n#define EXECUTE_APP_ERROR       262\r\n#define FILE_NOT_FOUND          263\r\n#define DOCUMENT_WAIT_ERROR     264\r\n#define SPEED_INVALID           265\r\n#define CERT_ERR_CERT_CHAIN_TOO_LONG 266\r\n#define CERT_ERR_CERT_HAS_EXPIRED 267\r\n#define CERT_ERR_CERT_NOT_YET_VALID 268\r\n#define CERT_ERR_CERT_REJECTED  269\r\n#define CERT_ERR_CERT_SIGNATURE_FAILURE 270\r\n#define CERT_ERR_CERT_UNTRUSTED 271\r\n#define CERT_ERR_DEPTH_ZERO_SELF_SIGNED_CERT 272\r\n#define CERT_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD 273\r\n#define CERT_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD 274\r\n#define CERT_ERR_INVALID_CA     275\r\n#define CERT_ERR_INVALID_PURPOSE 276\r\n#define CERT_ERR_KEYUSAGE_NO_CERTSIGN 277\r\n#define CERT_ERR_PATH_LENGTH_EXCEEDED 278\r\n#define CERT_ERR_SELF_SIGNED_CERT_IN_CHAIN 279\r\n#define CERT_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY 280\r\n#define CERT_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE 281\r\n#define CERT_ERR_UNABLE_TO_GET_ISSUER_CERT 282\r\n#define CERT_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY 283\r\n#define CERT_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE 284\r\n#define CERT_ERR_UNKNOWN        285\r\n#define CERT_ERRDEPTH           286\r\n#define MASK_ERROR              288\r\n#define FTP_CANNOT_OPEN_ACTIVE_CONNECTION2 289\r\n#define DELETE_LOCAL_FILE_ERROR 290\r\n#define URL_OPTION_BOOL_VALUE_ERROR 291\r\n#define CANNOT_OPEN_SESSION_FOLDER 293\r\n#define NET_TRANSL_NO_ROUTE2    294\r\n#define NET_TRANSL_CONN_ABORTED 295\r\n#define NET_TRANSL_HOST_NOT_EXIST2 296\r\n#define NET_TRANSL_PACKET_GARBLED 297\r\n#define REPORT_ERROR            298\r\n#define TLS_CERT_DECODE_ERROR   299\r\n#define FIND_FILE_ERROR         700\r\n#define CERT_NAME_MISMATCH      701\r\n#define SCRIPT_MATCH_NO_MATCH   702\r\n#define CERT_ERR_BAD_CHAIN      703\r\n#define CERT_OK                 704\r\n#define REQUEST_REDIRECTED      705\r\n#define TOO_MANY_REDIRECTS      706\r\n#define REDIRECT_LOOP           707\r\n#define INVALID_URL             708\r\n#define PROXY_AUTHENTICATION_FAILED 709\r\n#define CONFIGURED_KEY_NOT_MATCH 710\r\n#define SFTP_STATUS_OWNER_INVALID 711\r\n#define SFTP_STATUS_GROUP_INVALID 712\r\n#define SFTP_STATUS_NO_MATCHING_BYTE_RANGE_LOCK 713\r\n#define KEY_TYPE_UNOPENABLE     714\r\n#define UNKNOWN_CHECKSUM        715\r\n#define ALG_NOT_VERIFIED        716\r\n#define SFTP_STATUS_4           718\r\n#define CERTIFICATE_OPEN_ERROR  719\r\n#define CERTIFICATE_READ_ERROR  720\r\n#define CERTIFICATE_DECODE_ERROR_INFO 721\r\n#define CERTIFICATE_DECODE_ERROR 722\r\n#define CERTIFICATE_PUBLIC_KEY_NOT_FOUND 723\r\n#define LOCK_FILE_ERROR         724\r\n#define UNLOCK_FILE_ERROR       725\r\n#define NOT_LOCKED              726\r\n#define KEY_SAVE_ERROR          727\r\n#define NEON_INIT_FAILED2       728\r\n#define SCRIPT_AMBIGUOUS_SLASH_IN_PATH 729\r\n#define CERT_IP_CANNOT_VERIFY   730\r\n#define HOSTKEY_NOT_CONFIGURED  731\r\n#define UNENCRYPTED_REDIRECT    732\r\n#define HTTP_ERROR2             733\r\n#define FILEZILLA_SITE_MANAGER_NOT_FOUND 734\r\n#define FILEZILLA_NO_SITES      735\r\n#define FILEZILLA_SITE_NOT_EXIST 736\r\n#define SFTP_AS_FTP_ERROR       737\r\n#define LOG_FATAL_ERROR         738\r\n#define SIZE_INVALID            739\r\n#define KNOWN_HOSTS_NOT_FOUND   740\r\n#define KNOWN_HOSTS_NO_SITES    741\r\n#define HOSTKEY_NOT_MATCH_CLIPBOARD 742\r\n#define S3_ERROR_RESOURCE       743\r\n#define S3_ERROR_FURTHER_DETAILS 744\r\n#define S3_ERROR_EXTRA_DETAILS  745\r\n#define S3_STATUS_ACCESS_DENIED 746\r\n#define UNKNOWN_FILE_ENCRYPTION 747\r\n#define INVALID_ENCRYPT_KEY     748\r\n\r\n#define CORE_CONFIRMATION_STRINGS 300\r\n#define CONFIRM_PROLONG_TIMEOUT3 301\r\n#define PROMPT_KEY_PASSPHRASE   303\r\n#define FILE_OVERWRITE          304\r\n#define DIRECTORY_OVERWRITE     305\r\n#define ALG_BELOW_TRESHOLD      306\r\n#define CIPHER_TYPE_BOTH2       307\r\n#define CIPHER_TYPE_CS2         308\r\n#define CIPHER_TYPE_SC2         309\r\n#define RESUME_TRANSFER2        310\r\n#define PARTIAL_BIGGER_THAN_SOURCE 311\r\n#define APPEND_OR_RESUME2       312\r\n#define FILE_OVERWRITE_DETAILS  313\r\n#define READ_ONLY_OVERWRITE     314\r\n#define LOCAL_FILE_OVERWRITE2   315\r\n#define REMOTE_FILE_OVERWRITE2  316\r\n#define TIMEOUT_STILL_WAITING3  321\r\n#define RECONNECT_BUTTON        323\r\n#define RENAME_BUTTON           324\r\n#define TUNNEL_SESSION_NAME     327\r\n#define PASSWORD_TITLE          328\r\n#define PASSPHRASE_TITLE        329\r\n#define SERVER_PROMPT_TITLE     330\r\n#define USERNAME_TITLE          331\r\n#define USERNAME_PROMPT2        332\r\n#define SERVER_PROMPT_TITLE2    333\r\n#define NEW_PASSWORD_TITLE      334\r\n#define PROMPT_PROMPT           335\r\n#define TIS_INSTRUCTION         336\r\n#define CRYPTOCARD_INSTRUCTION  337\r\n#define PASSWORD_PROMPT         338\r\n#define KEYBINTER_INSTRUCTION   339\r\n#define NEW_PASSWORD_CURRENT_PROMPT 340\r\n#define NEW_PASSWORD_NEW_PROMPT 341\r\n#define NEW_PASSWORD_CONFIRM_PROMPT 342\r\n#define TUNNEL_INSTRUCTION2     343\r\n#define RENAME_TITLE            344\r\n#define RENAME_PROMPT2          345\r\n#define VERIFY_CERT_PROMPT3     346\r\n#define VERIFY_CERT_CONTACT     347\r\n#define VERIFY_CERT_CONTACT_LIST 348\r\n#define CERT_TEXT               349\r\n#define CERTIFICATE_PASSPHRASE_PROMPT 350\r\n#define CERTIFICATE_PASSPHRASE_TITLE 351\r\n#define KEY_TYPE_CONVERT3       352\r\n#define MULTI_FILES_TO_ONE      353\r\n#define KEY_EXCHANGE_ALG        354\r\n#define KEYKEY_TYPE             355\r\n#define S3_ACCESS_KEY_ID_TITLE  356\r\n#define S3_ACCESS_KEY_ID_PROMPT 357\r\n#define S3_SECRET_ACCESS_KEY_TITLE 358\r\n#define S3_SECRET_ACCESS_KEY_PROMPT 359\r\n#define DUPLICATE_FOLDER_NOT_SUPPORTED 360\r\n#define MISSING_TARGET_BUCKET   361\r\n\r\n#define CORE_INFORMATION_STRINGS 400\r\n#define YES_STR                 401\r\n#define NO_STR                  402\r\n#define SESSION_INFO_TIP2       403\r\n#define VERSION2                404\r\n#define CLOSED_ON_COMPLETION    405\r\n#define SFTP_PROTOCOL_NAME2     406\r\n#define FS_RENAME_NOT_SUPPORTED 407\r\n#define SFTP_NO_EXTENSION_INFO  408\r\n#define SFTP_EXTENSION_INFO     409\r\n#define APPEND_BUTTON           412\r\n#define YES_TO_NEWER_BUTTON     413\r\n#define SCRIPT_HELP_DESC        414\r\n#define SCRIPT_EXIT_DESC        415\r\n#define SCRIPT_OPEN_DESC        416\r\n#define SCRIPT_CLOSE_DESC       417\r\n#define SCRIPT_SESSION_DESC     418\r\n#define SCRIPT_PWD_DESC         419\r\n#define SCRIPT_CD_DESC          420\r\n#define SCRIPT_LS_DESC          421\r\n#define SCRIPT_LPWD_DESC        422\r\n#define SCRIPT_LCD_DESC         423\r\n#define SCRIPT_LLS_DESC         424\r\n#define SCRIPT_RM_DESC          425\r\n#define SCRIPT_RMDIR_DESC       426\r\n#define SCRIPT_MV_DESC          427\r\n#define SCRIPT_CHMOD_DESC       428\r\n#define SCRIPT_LN_DESC          429\r\n#define SCRIPT_MKDIR_DESC       430\r\n#define SCRIPT_GET_DESC         431\r\n#define SCRIPT_PUT_DESC         432\r\n#define SCRIPT_OPTION_DESC      433\r\n#define SCRIPT_SYNCHRONIZE_DESC 434\r\n#define SCRIPT_KEEPUPTODATE_DESC 435\r\n#define SCRIPT_HOST_PROMPT      436\r\n#define SCRIPT_ACTIVE_SESSION   438\r\n#define SCRIPT_SESSION_CLOSED   439\r\n#define SCRIPT_SYNCHRONIZE      440\r\n#define SCRIPT_SYNCHRONIZE_DELETED 441\r\n#define SCRIPT_KEEPING_UP_TO_DATE 442\r\n#define SKIP_ALL_BUTTON         443\r\n#define SCRIPT_CALL_DESC2       444\r\n#define COPY_PARAM_PRESET_ASCII 445\r\n#define COPY_PARAM_PRESET_BINARY 446\r\n#define COPY_INFO_TRANSFER_TYPE2 448\r\n#define COPY_INFO_FILENAME      449\r\n#define COPY_INFO_PERMISSIONS   450\r\n#define COPY_INFO_ADD_X_TO_DIRS 451\r\n#define COPY_INFO_TIMESTAMP     452\r\n#define COPY_INFO_FILE_MASK     454\r\n#define COPY_INFO_CLEAR_ARCHIVE 455\r\n#define COPY_INFO_DONT_REPLACE_INV_CHARS 456\r\n#define COPY_INFO_DONT_PRESERVE_TIME 458\r\n#define COPY_INFO_DONT_CALCULATE_SIZE 459\r\n#define COPY_INFO_DEFAULT       460\r\n#define COPY_RULE_HOSTNAME      461\r\n#define COPY_RULE_USERNAME      462\r\n#define COPY_RULE_REMOTE_DIR    463\r\n#define COPY_RULE_LOCAL_DIR     464\r\n#define SYNCHRONIZE_SCAN        465\r\n#define SYNCHRONIZE_START       466\r\n#define SYNCHRONIZE_CHANGE      467\r\n#define SYNCHRONIZE_UPLOADED    468\r\n#define SYNCHRONIZE_DELETED     469\r\n#define COPY_INFO_NOT_USABLE    470\r\n#define COPY_INFO_IGNORE_PERM_ERRORS 472\r\n#define AUTH_TRANSL_USERNAME    473\r\n#define AUTH_TRANSL_KEYB_INTER  474\r\n#define AUTH_TRANSL_PUBLIC_KEY  475\r\n#define AUTH_TRANSL_WRONG_PASSPHRASE 476\r\n#define AUTH_TRANSL_ACCESS_DENIED 477\r\n#define AUTH_TRANSL_PUBLIC_KEY_AGENT 478\r\n#define AUTH_TRANSL_TRY_PUBLIC_KEY 479\r\n#define AUTH_PASSWORD           480\r\n#define OPEN_TUNNEL             481\r\n#define STATUS_CLOSED           482\r\n#define STATUS_LOOKUPHOST       484\r\n#define STATUS_CONNECT          485\r\n#define STATUS_AUTHENTICATE     486\r\n#define STATUS_AUTHENTICATED    487\r\n#define STATUS_STARTUP          488\r\n#define STATUS_OPEN_DIRECTORY   489\r\n#define STATUS_READY            490\r\n#define USING_TUNNEL            491\r\n#define AUTH_TRANSL_KEY_REFUSED 492\r\n#define PFWD_TRANSL_ADMIN       493\r\n#define PFWD_TRANSL_CONNECT     494\r\n#define NET_TRANSL_REFUSED2     495\r\n#define NET_TRANSL_RESET        496\r\n#define NET_TRANSL_TIMEOUT2     497\r\n#define SESSION_INFO_TIP_NO_SSH 498\r\n#define RESUME_BUTTON           499\r\n#define FTP_NO_FEATURE_INFO     500\r\n#define FTP_FEATURE_INFO        501\r\n#define COPY_INFO_CPS_LIMIT2    502\r\n#define COPY_KEY_BUTTON         503\r\n#define UPDATE_KEY_BUTTON       504\r\n#define ADD_KEY_BUTTON          505\r\n#define COPY_INFO_PRESERVE_READONLY 506\r\n#define SCRIPT_SYNCHRONIZE_COLLECTING 507\r\n#define SCRIPT_SYNCHRONIZE_SYNCHRONIZING 508\r\n#define SCRIPT_SYNCHRONIZE_NODIFFERENCE 509\r\n#define SPEED_UNLIMITED         510\r\n#define FTPS_IMPLICIT           511\r\n#define FTPS_EXPLICIT           513\r\n#define SCRIPT_ECHO_DESC        514\r\n#define SCRIPT_STAT_DESC        515\r\n#define HOSTKEY                 516\r\n#define SCRIPT_FILEMASK_INCLUDE_EXCLUDE 517\r\n#define COPY_PARAM_NEWER_ONLY    518\r\n#define FTP_SUGGESTION          519\r\n#define SCRIPT_CMDLINE_SESSION  520\r\n#define ANY_HOSTKEY      521\r\n#define ANY_CERTIFICATE  522\r\n#define SCRIPT_SYNC_UPLOAD_NEW  523\r\n#define SCRIPT_SYNC_DOWNLOAD_NEW 524\r\n#define SCRIPT_SYNC_UPLOAD_UPDATE 525\r\n#define SCRIPT_SYNC_DOWNLOAD_UPDATE 526\r\n#define SCRIPT_SYNC_DELETE_REMOTE 527\r\n#define SCRIPT_SYNC_DELETE_LOCAL 528\r\n#define SCRIPT_SYNCHRONIZE_CHECKLIST 529\r\n#define COPY_INFO_REMOVE_CTRLZ  530\r\n#define COPY_INFO_REMOVE_BOM    531\r\n#define SCRIPT_NON_DEFAULT_COPY_PARAM 532\r\n#define SCRIPT_NON_DEFAULT_SYNC_PARAM 533\r\n#define VERSION_BUILD           535\r\n#define VERSION_DEV_BUILD       536\r\n#define VERSION_DEBUG_BUILD     537\r\n#define VERSION_DONT_DISTRIBUTE 538\r\n#define WEBDAV_EXTENSION_INFO   539\r\n#define COPY_PARAM_PRESET_EXCLUDE_ALL_DIR 540\r\n#define SCRIPT_CHECKSUM_DESC    541\r\n#define CLIENT_CERTIFICATE_LOADING 543\r\n#define NEED_CLIENT_CERTIFICATE 544\r\n#define LOCKED                  545\r\n#define EXECUTABLE              546\r\n#define SCRIPT_CMDLINE_PARAMETERS 547\r\n#define SCRIPTING_USE_HOSTKEY   548\r\n#define SCRIPT_SITE_WARNING     549\r\n#define CODE_SESSION_OPTIONS    550\r\n#define CODE_CONNECT            551\r\n#define CODE_PS_ADD_TYPE        553\r\n#define COPY_INFO_PRESERVE_TIME_DIRS 554\r\n#define TEXT_FILE_ENCODING      555\r\n#define AND_STR                 556\r\n#define AUTH_CHANGING_PASSWORD  557\r\n#define PASTE_KEY_BUTTON        558\r\n#define SCRIPT_CP_DESC          559\r\n#define TIME_UNKNOWN            560\r\n#define KEY_DETAILS             561\r\n#define COPY_KEY_ACTION         562\r\n#define COPY_CERTIFICATE_ACTION 563\r\n#define COPY_INFO_DONT_ENCRYPT_NEW_FILES 564\r\n#define COPY_INFO_EXCLUDE_HIDDEN_FILES 565\r\n#define COPY_INFO_EXCLUDE_EMPTY_DIRS 566\r\n\r\n#define CORE_VARIABLE_STRINGS   600\r\n#define PUTTY_BASED_ON          601\r\n#define PUTTY_COPYRIGHT         603\r\n#define PUTTY_URL               604\r\n#define FILEZILLA_BASED_ON2     605\r\n#define FILEZILLA_COPYRIGHT2    607\r\n#define FILEZILLA_URL           608\r\n#define OPENSSL_BASED_ON        609\r\n#define OPENSSL_COPYRIGHT2      610\r\n#define OPENSSL_URL             612\r\n#define NEON_BASED_ON2          613\r\n#define NEON_COPYRIGHT          614\r\n#define EXPAT_BASED_ON          616\r\n#define EXPAT_URL               618\r\n#define PUTTY_LICENSE_URL       625\r\n#define MAIN_MSG_TAG            631\r\n#define INTERACTIVE_MSG_TAG     632\r\n#define S3_BASED_ON             633\r\n#define S3_COPYRIGHT            634\r\n#define S3_URL                  635\r\n#define S3_LICENSE_URL          636\r\n\r\n// 7xxx used by errors as secondary sequence\r\n\r\n#endif // TextsCore\r\n", "#include \"TextsCore.h\"\r\n\r\nSTRINGTABLE\r\nBEGIN\r\n  CORE_ERROR_STRINGS, \"CORE_ERROR\"\r\n  KEY_NOT_VERIFIED, \"Host key wasn't verified!\"\r\n  CONNECTION_FAILED, \"Connection failed.\"\r\n  USER_TERMINATED, \"Terminated by user.\"\r\n  LOST_CONNECTION, \"Lost connection.\"\r\n  CANT_DETECT_RETURN_CODE, \"Can't detect command return code.\"\r\n  COMMAND_FAILED, \"Command '%s'\\nfailed with return code %d and error message\\n%s.\"\r\n  COMMAND_FAILED_CODEONLY, \"Command failed with return code %d.\"\r\n  INVALID_OUTPUT_ERROR, \"Command '%s' failed with invalid output '%s'.\"\r\n  READ_CURRENT_DIR_ERROR, \"Error getting name of current remote directory.\"\r\n  SKIP_STARTUP_MESSAGE_ERROR, \"Error skipping startup message. Your shell is probably incompatible with the application (BASH is recommended).\"\r\n  CHANGE_DIR_ERROR, \"Error changing directory to '%s'.\"\r\n  LIST_DIR_ERROR, \"Error listing directory '%s'.\"\r\n  LIST_LINE_ERROR, \"Unexpected directory listing line '%s'.\"\r\n  RIGHTS_ERROR, \"Invalid rights description '%s'\"\r\n  CLEANUP_CONFIG_ERROR, \"Error cleaning up general configuration.\"\r\n  CLEANUP_HOSTKEYS_ERROR, \"Error cleaning up sites.\"\r\n  CLEANUP_SEEDFILE_ERROR, \"Error cleaning up random seed file.\"\r\n  CLEANUP_SESSIONS_ERROR, \"Error cleaning up cached host keys.\"\r\n  DETECT_RETURNVAR_ERROR, \"Error detecting variable containing return code of last command.\"\r\n  LOOKUP_GROUPS_ERROR, \"Error looking up user groups.\"\r\n  FILE_NOT_EXISTS, \"File or folder '%s' does not exist.\"\r\n  CANT_GET_ATTRS, \"Can't get attributes of file '%s'.\"\r\n  OPENFILE_ERROR, \"Can't open file '%s'.\"\r\n  READ_ERROR, \"Error reading file '%s'.\"\r\n  COPY_FATAL, \"Copying file '%s' fatally failed.\"\r\n  TOREMOTE_COPY_ERROR, \"Copying files to remote side failed.\"\r\n  TOLOCAL_COPY_ERROR, \"Copying files from remote side failed.\"\r\n  SCP_EMPTY_LINE, \"SCP protocol error: Unexpected newline\"\r\n  SCP_ILLEGAL_TIME_FORMAT, \"SCP protocol error: Illegal time format\"\r\n  SCP_INVALID_CONTROL_RECORD, \"SCP protocol error: Invalid control record (%s; %s)\"\r\n  COPY_ERROR, \"Copying file '%s' failed.\"\r\n  SCP_ILLEGAL_FILE_DESCRIPTOR, \"SCP protocol error: Illegal file descriptor format\"\r\n  NOT_DIRECTORY_ERROR, \"'%s' is not folder!\"\r\n  CREATE_DIR_ERROR, \"Error creating folder '%s'.\"\r\n  CREATE_FILE_ERROR, \"Can't create file '%s'.\"\r\n  WRITE_ERROR, \"Error writing to file '%s'\"\r\n  CANT_SET_ATTRS, \"Can't set attributes of file '%s'.\"\r\n  REMOTE_ERROR, \"Received error message from remote side: '%s'\"\r\n  DELETE_FILE_ERROR, \"Error deleting file '%s'.\"\r\n  LOG_GEN_ERROR, \"Error occurred during logging. It's been turned off.\"\r\n  LOG_OPENERROR, \"Can't open log file '%s'.\"\r\n  RENAME_FILE_ERROR, \"Error renaming file '%s' to '%s'.\"\r\n  RENAME_CREATE_FILE_EXISTS, \"File with name '%s' already exists.\"\r\n  RENAME_CREATE_DIR_EXISTS, \"Directory with name '%s' already exists.\"\r\n  CHANGE_HOMEDIR_ERROR, \"Error changing directory to home directory.\"\r\n  UNALIAS_ALL_ERROR, \"Error clearing all aliases.\"\r\n  UNSET_NATIONAL_ERROR, \"Error clearing national user variables.\"\r\n  FIRST_LINE_EXPECTED, \"Unexpected input from server: %s\"\r\n  CLEANUP_INIFILE_ERROR, \"Error cleaning up INI file.\"\r\n  AUTHENTICATION_LOG, \"Authentication log (see session log for details):\\n%s\\n\"\r\n  AUTHENTICATION_FAILED, \"Authentication failed.\"\r\n  NOT_CONNECTED, \"Connection has been unexpectedly closed.\"\r\n  SAVE_KEY_ERROR, \"Error saving key to file '%s'.\"\r\n  SSH_EXITCODE, \"Server sent command exit status %d.\"\r\n  SFTP_INVALID_TYPE, \"SFTP protocol violation: Invalid response message type (%d).\"\r\n  SFTP_VERSION_NOT_SUPPORTED, \"Version of SFTP server (%d) is not supported. Supported versions are %d to %d.\"\r\n  SFTP_MESSAGE_NUMBER, \"SFTP protocol violation: Invalid message number %d (expected %d).\"\r\n  SFTP_STATUS_OK, \"Unexpected OK response.\"\r\n  SFTP_STATUS_EOF, \"Unexpected EOF response.\"\r\n  SFTP_STATUS_NO_SUCH_FILE, \"No such file or directory.\"\r\n  SFTP_STATUS_PERMISSION_DENIED, \"Permission denied.\"\r\n  SFTP_STATUS_FAILURE, \"General failure (server should provide error description).\"\r\n  SFTP_STATUS_BAD_MESSAGE, \"Bad message (badly formatted packet or protocol incompatibility).\"\r\n  SFTP_STATUS_NO_CONNECTION, \"No connection.\"\r\n  SFTP_STATUS_CONNECTION_LOST, \"Connection lost.\"\r\n  SFTP_STATUS_OP_UNSUPPORTED, \"The server does not support the operation.\"\r\n  SFTP_ERROR_FORMAT3, \"%s\\nError code: %d\\nError message from server%s: %s\"\r\n  SFTP_STATUS_UNKNOWN, \"Unknown status code.\"\r\n  READ_SYMLINK_ERROR, \"Error reading symbolic link '%s'.\"\r\n  EMPTY_DIRECTORY, \"Server returned empty listing for directory '%s'.\"\r\n  SFTP_NON_ONE_FXP_NAME_PACKET, \"Received SSH_FXP_NAME packet with zero or multiple records.\"\r\n  SFTP_REALPATH_ERROR, \"Cannot get real path for '%s'.\"\r\n  CHANGE_PROPERTIES_ERROR, \"Cannot change properties of file '%s'.\"\r\n  SFTP_INITIALIZE_ERROR, \"Cannot initialize SFTP protocol. Is the host running an SFTP server?\"\r\n  TIMEZONE_ERROR, \"Cannot read time zone information\"\r\n  SFTP_CREATE_FILE_ERROR, \"Cannot create remote file '%s'.\"\r\n  SFTP_OPEN_FILE_ERROR, \"Cannot open remote file '%s'.\"\r\n  SFTP_CLOSE_FILE_ERROR, \"Cannot close remote file '%s'.\"\r\n  NOT_FILE_ERROR, \"'%s' is not file!\"\r\n  RENAME_AFTER_RESUME_ERROR, \"Transfer was successfully finished, but temporary transfer file '%s' could not be renamed to target file name '%s'. If the problem persists, you may try to turn off transfer resume support.\"\r\n  CREATE_LINK_ERROR, \"Cannot create link '%s'.\"\r\n  INVALID_SHELL_COMMAND, \"Invalid command '%s'.\"\r\n  SFTP_SERVER_MESSAGE_UNSUPPORTED, \"None\"\r\n  INVALID_OCTAL_PERMISSIONS, \"'%s' is not valid permission in octal format.\"\r\n  SFTP_INVALID_EOL, \"Server requires unsupported end-of-line sequence (%s).\"\r\n  SFTP_UNKNOWN_FILE_TYPE, \"Unknown file type (%d)\"\r\n  SFTP_STATUS_INVALID_HANDLE, \"Invalid handle.\"\r\n  SFTP_STATUS_NO_SUCH_PATH, \"The file path does not exist or is invalid.\"\r\n  SFTP_STATUS_FILE_ALREADY_EXISTS, \"File already exists.\"\r\n  SFTP_STATUS_WRITE_PROTECT, \"The file is on read-only media, or the media is write protected.\"\r\n  SFTP_STATUS_NO_MEDIA, \"There is no media available in the drive.\"\r\n  DECODE_UTF_ERROR, \"Error decoding UTF-8 string.\"\r\n  CUSTOM_COMMAND_ERROR, \"Error executing custom command '%s' on file '%s'.\"\r\n  LOCALE_LOAD_ERROR, \"Cannot load locale %d.\"\r\n  SFTP_INCOMPLETE_BEFORE_EOF, \"Received incomplete data packet before end of file.\"\r\n  CALCULATE_SIZE_ERROR, \"Error calculating size of directory '%s'.\"\r\n  SFTP_PACKET_TOO_BIG, \"Received too large (%d B) SFTP packet. Max supported packet size is %d B.\"\r\n  SCP_INIT_ERROR, \"Cannot execute SCP to start transfer. Please make sure that SCP is installed on the server and path to it is included in PATH. You may also try SFTP instead of SCP.\"\r\n  DUPLICATE_BOOKMARK, \"Location Profile with name '%s' already exists.\"\r\n  MOVE_FILE_ERROR, \"Error moving file '%s' to '%s'.\"\r\n  SFTP_PACKET_TOO_BIG_INIT_EXPLAIN, \"%s\\n \\nThe error is typically caused by message printed from startup script (like .profile). The message may start with %s.\"\r\n  PRESERVE_TIME_PERM_ERROR3, \"**Upload of file '%s' was successful, but error occurred while setting the permissions and/or timestamp.**\\n\\nIf the problem persists, turn off setting permissions or preserving timestamp. Alternatively you can turn on 'Ignore permission errors' option.\"\r\n  ACCESS_VIOLATION_ERROR3, \"Invalid access to memory.\"\r\n  SFTP_STATUS_NO_SPACE_ON_FILESYSTEM, \"There is insufficient free space on the filesystem.\"\r\n  SFTP_STATUS_QUOTA_EXCEEDED, \"Operation cannot be completed because it would exceed the user's storage quota.\"\r\n  SFTP_STATUS_UNKNOWN_PRINCIPAL, \"Principal (%s) is unknown to the server.\"\r\n  COPY_FILE_ERROR, \"Error copying file '%s' to '%s'.\"\r\n  CUSTOM_COMMAND_UNTERMINATED, \"Unterminated pattern '%s' starting at %d.\"\r\n  CUSTOM_COMMAND_UNKNOWN, \"Unknown pattern '%s' starting at %d.\"\r\n  CUSTOM_COMMAND_FILELIST_ERROR, \"Cannot combine file name pattern (starting at %d) with file list pattern (starting at %d).\"\r\n  SCRIPT_COMMAND_UNKNOWN, \"Unknown command '%s'.\"\r\n  SCRIPT_COMMAND_AMBIGUOUS, \"Ambiguous command '%s'. Possible matches are: %s\"\r\n  SCRIPT_MISSING_PARAMS, \"Missing parameter for command '%s'.\"\r\n  SCRIPT_TOO_MANY_PARAMS, \"Too many parameters for command '%s'.\"\r\n  SCRIPT_NO_SESSION, \"No session.\"\r\n  SCRIPT_SESSION_INDEX_INVALID, \"Invalid session number '%s'.\"\r\n  SCRIPT_OPTION_UNKNOWN, \"Unknown option '%s'.\"\r\n  SCRIPT_VALUE_UNKNOWN, \"Unknown value '%s' of option '%s'.\"\r\n  UNKNOWN_SOCKET_STATUS, \"Cannot determine status of socket (%d).\"\r\n  DELETE_ON_RESUME_ERROR, \"Error deleting file '%s'. After resumable file upload the existing destination file must be deleted. If you do not have permissions to delete file destination file, you need to disable resumable file transfers.\"\r\n  SFTP_PACKET_ERROR, \"Error decoding SFTP packet (%d, %d, %d).\"\r\n  ITEM_NAME_INVALID, \"Invalid name '%s'. Name cannot contain '%s'.\"\r\n  SFTP_STATUS_LOCK_CONFLICT, \"The file could not be opened because it is locked by another process.\"\r\n  SFTP_STATUS_DIR_NOT_EMPTY, \"The directory is not empty.\"\r\n  SFTP_STATUS_NOT_A_DIRECTORY, \"The specified file is not a directory.\"\r\n  SFTP_STATUS_INVALID_FILENAME, \"The filename is not valid.\"\r\n  SFTP_STATUS_LINK_LOOP, \"Too many symbolic links encountered.\"\r\n  SFTP_STATUS_CANNOT_DELETE, \"The file cannot be deleted.\"\r\n  SFTP_STATUS_INVALID_PARAMETER, \"One of the parameters was out of range, or the parameters specified cannot be used together.\"\r\n  SFTP_STATUS_FILE_IS_A_DIRECTORY, \"The specified file was a directory in a context where a directory cannot be used.\"\r\n  SFTP_STATUS_BYTE_RANGE_LOCK_CONFLICT, \"Byte range lock conflict.\"\r\n  SFTP_STATUS_BYTE_RANGE_LOCK_REFUSED, \"Byte range lock refused.\"\r\n  SFTP_STATUS_DELETE_PENDING, \"An operation was attempted on a file for which a delete operation is pending.\"\r\n  SFTP_STATUS_FILE_CORRUPT, \"The file is corrupt; an filesystem integrity check should be run.\"\r\n  KEY_TYPE_UNKNOWN2, \"File '%s' does not contain private key in known format.\"\r\n  KEY_TYPE_UNSUPPORTED2, \"**Private key file '%s' contains key in %s format. WinSCP supports only PuTTY format.**\"\r\n  KEY_TYPE_DIFFERENT_SSH, \"Private key file '%s' contains key in %s format. It does not follow your preferred SSH protocol version.\"\r\n  SFTP_OVERWRITE_FILE_ERROR2, \"Cannot overwrite remote file '%s'.$$\\n \\nPress 'Delete' to delete the file and create new one instead of overwriting it.$$\"\r\n  SFTP_OVERWRITE_DELETE_BUTTON, \"&Delete\"\r\n  SPACE_AVAILABLE_ERROR, \"Error checking space available for path '%s'.\"\r\n  TUNNEL_NO_FREE_PORT, \"Cannot find free local listening port number for tunnel in range %d to %d.\"\r\n  EVENT_SELECT_ERROR, \"Cannot setup network event (error %d).\"\r\n  UNEXPECTED_CLOSE_ERROR, \"Server unexpectedly closed network connection.\"\r\n  TUNNEL_ERROR, \"Error while tunneling the connection.\\n \\n%s\"\r\n  CHECKSUM_ERROR, \"Error calculating checksum for file '%s'.\"\r\n  INTERNAL_ERROR, \"Internal error %s (%s).\"\r\n  NOTSUPPORTED, \"Operation not supported.\"\r\n  FTP_ACCESS_DENIED, \"Access denied.\"\r\n  FTP_CREDENTIAL_PROMPT, \"Prompting for credentials...\"\r\n  FTP_RESPONSE_ERROR, \"Invalid response to %s command '%s'.\"\r\n  SCRIPT_UNKNOWN_SWITCH, \"Unknown switch '%s'.\"\r\n  TRANSFER_ERROR, \"Error transferring file '%s'.\"\r\n  EXECUTE_APP_ERROR, \"Cannot execute '%s'.\"\r\n  FILE_NOT_FOUND, \"File '%s' not found.\"\r\n  DOCUMENT_WAIT_ERROR, \"Error waiting for document to close.\"\r\n  SPEED_INVALID, \"'%s' is not a valid speed limit.\"\r\n  CERT_ERR_DEPTH_ZERO_SELF_SIGNED_CERT, \"Self-signed certificate.\"\r\n  CERT_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD, \"Format error in certificate's valid until field.\"\r\n  CERT_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD, \"Format error in certificate's valid from field.\"\r\n  CERT_ERR_INVALID_CA, \"Invalid CA certificate.\"\r\n  CERT_ERR_INVALID_PURPOSE, \"Unsupported certificate purpose.\"\r\n  CERT_ERR_KEYUSAGE_NO_CERTSIGN, \"Key usage does not include certificate signing.\"\r\n  CERT_ERR_PATH_LENGTH_EXCEEDED, \"Path length constraint exceeded.\"\r\n  CERT_ERR_SELF_SIGNED_CERT_IN_CHAIN, \"Self-signed certificate in certificate chain.\"\r\n  CERT_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY, \"Unable to decode issuer public key.\"\r\n  CERT_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE, \"Unable to decrypt certificate signature.\"\r\n  CERT_ERR_UNABLE_TO_GET_ISSUER_CERT, \"Unable to get issuer certificate.\"\r\n  CERT_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY, \"Unable to get local issuer certificate.\"\r\n  CERT_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE, \"Unable to verify the first certificate.\"\r\n  CERT_ERR_UNKNOWN, \"Unknown certificate verification error.\"\r\n  CERT_ERRDEPTH, \"The error occurred at a depth of %d in the certificate chain.\"\r\n  MASK_ERROR, \"Mask is invalid near '%s'.\"\r\n  FTP_CANNOT_OPEN_ACTIVE_CONNECTION2, \"The server cannot open connection in active mode. If you are behind a NAT router, you may need to specify an external IP address. Alternatively, consider switching to passive mode.\"\r\n  DELETE_LOCAL_FILE_ERROR, \"Error deleting file '%s'.\"\r\n  URL_OPTION_BOOL_VALUE_ERROR, \"Invalid switch value '%s'. Valid values are 'on' and 'off'.\"\r\n  CANNOT_OPEN_SESSION_FOLDER, \"Cannot open site folder or workspace.\"\r\n  NET_TRANSL_NO_ROUTE2, \"Network error: No route to host \\\"%HOST%\\\".\"\r\n  NET_TRANSL_CONN_ABORTED, \"Network error: Software caused connection abort\"\r\n  NET_TRANSL_HOST_NOT_EXIST2, \"Host \\\"%HOST%\\\" does not exist.\"\r\n  NET_TRANSL_PACKET_GARBLED, \"Incoming packet was garbled on decryption\"\r\n  REPORT_ERROR, \"%s\\n\\nPlease help us improving WinSCP by reporting the error on WinSCP support forum.\"\r\n  TLS_CERT_DECODE_ERROR, \"Error decoding TLS/SSL certificate (%s).\"\r\n  FIND_FILE_ERROR, \"Error retrieving file list for \\\"%s\\\".\"\r\n  CERT_NAME_MISMATCH, \"Certificate was not issued for this server. You might be connecting to a server that is pretending to be \\\"%s\\\".\"\r\n  SCRIPT_MATCH_NO_MATCH, \"No file matching '%s' found.\"\r\n  CERT_ERR_BAD_CHAIN, \"Some certificates in certificate chain are invalid.\"\r\n  CERT_OK, \"Certificate is valid.\"\r\n  CERT_ERR_CERT_CHAIN_TOO_LONG, \"Certificate chain too long.\"\r\n  CERT_ERR_CERT_HAS_EXPIRED, \"Certificate has expired.\"\r\n  CERT_ERR_CERT_NOT_YET_VALID, \"Certificate is not yet valid.\"\r\n  CERT_ERR_CERT_REJECTED, \"Certificate rejected.\"\r\n  CERT_ERR_CERT_SIGNATURE_FAILURE, \"Certificate signature failure.\"\r\n  CERT_ERR_CERT_UNTRUSTED, \"Certificate not trusted.\"\r\n  REQUEST_REDIRECTED, \"WebDAV resource moved to '%s'.\"\r\n  TOO_MANY_REDIRECTS, \"Too many redirects.\"\r\n  REDIRECT_LOOP, \"Redirect loop detected.\"\r\n  INVALID_URL, \"Invalid URL \\\"%s\\\".\"\r\n  PROXY_AUTHENTICATION_FAILED, \"Proxy authentication failed.\"\r\n  CONFIGURED_KEY_NOT_MATCH, \"Host key does not match configured key \\\"%s\\\"!\"\r\n  SFTP_STATUS_OWNER_INVALID, \"The name specified can not be assigned as an owner of a file.\"\r\n  SFTP_STATUS_GROUP_INVALID, \"The name specified can not be assigned as the primary group of a file.\"\r\n  SFTP_STATUS_NO_MATCHING_BYTE_RANGE_LOCK, \"The requested operation could not be completed because the specifed byte range lock has not been granted.\"\r\n  KEY_TYPE_UNOPENABLE, \"Private key file '%s' does not exist or cannot be opened.\"\r\n  UNKNOWN_CHECKSUM, \"Checksum algorithm '%s' is not supported.\"\r\n  ALG_NOT_VERIFIED, \"The %s %s was not verified!\"\r\n  SFTP_STATUS_4, \"Common reasons for the Error code 4 are:\\n- Renaming a file to a name of already existing file.\\n- Creating a directory that already exists.\\n- Moving a remote file to a different filesystem (HDD).\\n- Uploading a file to a full filesystem (HDD).\\n- Exceeding a user disk quota.\"\r\n  CERTIFICATE_OPEN_ERROR, \"Cannot open certificate \\\"%s\\\".\"\r\n  CERTIFICATE_READ_ERROR, \"Cannot read certificate \\\"%s\\\".\"\r\n  CERTIFICATE_DECODE_ERROR_INFO, \"Error decoding certificate.\"\r\n  CERTIFICATE_DECODE_ERROR, \"Error decoding certificate \\\"%s\\\".\"\r\n  CERTIFICATE_PUBLIC_KEY_NOT_FOUND, \"Certificate file \\\"%s\\\" does not contain a public key and no corresponding .crt/.cer file was found.\"\r\n  LOCK_FILE_ERROR, \"Error locking file '%s'.\"\r\n  UNLOCK_FILE_ERROR, \"Error unlocking file '%s'.\"\r\n  NOT_LOCKED, \"File '%s' is not locked.\"\r\n  KEY_SAVE_ERROR, \"Error saving key to file \\\"%s\\\".\"\r\n  NEON_INIT_FAILED2, \"Neon HTTP library initialization failed, cannot open session.\"\r\n  SCRIPT_AMBIGUOUS_SLASH_IN_PATH, \"Selecting files using a path ending with slash is ambiguous. Remove the slash to select the folder. Append * mask to select all files in the folder.\"\r\n  CERT_IP_CANNOT_VERIFY, \"When connecting using an IP address, it is not possible to verify if the certificate was issued for the server. Use a hostname instead of the IP address.\"\r\n  HOSTKEY_NOT_CONFIGURED, \"Expected host key was not configured, use -hostkey switch.\"\r\n  UNENCRYPTED_REDIRECT, \"Redirected to an unencrypted URL.\"\r\n  HTTP_ERROR2, \"Received response %d \\\"%s\\\" from %s.\"\r\n  FILEZILLA_SITE_MANAGER_NOT_FOUND, \"FileZilla site manager file not found (%s).\"\r\n  FILEZILLA_NO_SITES, \"No sites found in FileZilla site manager file (%s).\"\r\n  FILEZILLA_SITE_NOT_EXIST, \"FileZilla site \\\"%s\\\" was not found.\"\r\n  SFTP_AS_FTP_ERROR, \"You cannot connect to an SFTP server using an FTP protocol. Please select the correct protocol.\"\r\n  LOG_FATAL_ERROR, \"Error occurred during logging. Cannot continue.\"\r\n  SIZE_INVALID, \"'%s' is not a valid size.\"\r\n  KNOWN_HOSTS_NOT_FOUND, \"OpenSSH known_hosts file not found.\"\r\n  KNOWN_HOSTS_NO_SITES, \"No host keys found in known_hosts.\"\r\n  HOSTKEY_NOT_MATCH_CLIPBOARD, \"Contents of the clipboard does not match the host key nor its fingerprint.\"\r\n  S3_ERROR_RESOURCE, \"Resource: %s\"\r\n  S3_ERROR_FURTHER_DETAILS, \"Further details: %s\"\r\n  S3_ERROR_EXTRA_DETAILS, \"Extra Details: \"\r\n  S3_STATUS_ACCESS_DENIED, \"Access denied.\"\r\n  DUPLICATE_FOLDER_NOT_SUPPORTED, \"Direct duplication of folders is not supported. Use a duplication via a local temporary copy.\"\r\n  MISSING_TARGET_BUCKET, \"Specify target bucket.\"\r\n  UNKNOWN_FILE_ENCRYPTION, \"File is not encrypted using a known encryption.\"\r\n  INVALID_ENCRYPT_KEY, \"**Invalid encryption key.**\\n\\nEncryption key for %s encryption must have %d bytes. It must be entered in hexadecimal representation (i.e. %d characters).\"\r\n\r\n  CORE_CONFIRMATION_STRINGS, \"CORE_CONFIRMATION\"\r\n  CONFIRM_PROLONG_TIMEOUT3, \"Host is not communicating for %d seconds.\\n\\nWait for another %0:d seconds?\"\r\n  PROMPT_KEY_PASSPHRASE, \"&Passphrase for key '%s':\"\r\n  FILE_OVERWRITE, \"File '%s' already exists. Overwrite?\"\r\n  DIRECTORY_OVERWRITE, \"Directory '%s' already exists. Overwrite?\"\r\n  ALG_BELOW_TRESHOLD, \"The first %s supported by the server is %s, which is below the configured warning threshold.\\n\\nDo you want to continue with this connection?\"\r\n  CIPHER_TYPE_BOTH2, \"cipher\"\r\n  CIPHER_TYPE_CS2, \"client-to-server cipher\"\r\n  CIPHER_TYPE_SC2, \"server-to-client cipher\"\r\n  RESUME_TRANSFER2, \"**Do you want to resume file transfer?**\\n\\nTarget directory contains partially transferred file '%s'.\\n\\nNote: Answering 'No' would delete partially transferred file and restart transfer.\"\r\n  PARTIAL_BIGGER_THAN_SOURCE, \"Target directory contains partially transferred file '%s', which is bigger than a source file. The file will be deleted.\"\r\n  APPEND_OR_RESUME2, \"**Do you want to append file '%s' at the end of existing file?**\\n\\nPress 'No' to resume file transfer instead.\"\r\n  FILE_OVERWRITE_DETAILS, \"%s\\n \\nNew:      \\t%s bytes, %s\\nExisting: \\t%s bytes, %s\"\r\n  READ_ONLY_OVERWRITE, \"File '%s' is read-only. Overwrite?\"\r\n  LOCAL_FILE_OVERWRITE2, \"**Overwrite local file '%s'?**\\n\\nDestination directory already contains file '%s'.\\nChoose, if you want to overwrite the file or skip this transfer and keep existing file.\"\r\n  REMOTE_FILE_OVERWRITE2, \"**Overwrite remote file '%s'?**\\n\\nDestination directory already contains file '%s'.\\nChoose, if you want to overwrite the file or skip this transfer and keep existing file.\"\r\n  TIMEOUT_STILL_WAITING3, \"Host is not communicating for more than %d seconds.\\nStill waiting...\\n\\nNote: If the problem repeats, try turning off 'Optimize connection buffer size'.\"\r\n  RECONNECT_BUTTON, \"&Reconnect\"\r\n  RENAME_BUTTON, \"New na&me\"\r\n  TUNNEL_SESSION_NAME, \"Tunnel for %s\"\r\n  PASSWORD_TITLE, \"Password\"\r\n  PASSPHRASE_TITLE, \"Key passphrase\"\r\n  SERVER_PROMPT_TITLE, \"Server prompt\"\r\n  USERNAME_TITLE, \"Username\"\r\n  USERNAME_PROMPT2, \"&Username:\"\r\n  SERVER_PROMPT_TITLE2, \"Server prompt: %s\"\r\n  NEW_PASSWORD_TITLE, \"New password\"\r\n  PROMPT_PROMPT, \"&Response:\"\r\n  TIS_INSTRUCTION, \"Using TIS authentication.%s\"\r\n  CRYPTOCARD_INSTRUCTION, \"Using CryptoCard authentication.%s\"\r\n  PASSWORD_PROMPT, \"&Password: \"\r\n  KEYBINTER_INSTRUCTION, \"Using keyboard-interactive authentication.%s\"\r\n  NEW_PASSWORD_CURRENT_PROMPT, \"&Current password:\"\r\n  NEW_PASSWORD_NEW_PROMPT, \"&New password:\"\r\n  NEW_PASSWORD_CONFIRM_PROMPT, \"Confirm new &password:\"\r\n  TUNNEL_INSTRUCTION2, \"Authenticating tunnel through %s\"\r\n  RENAME_TITLE, \"Transfer under different name\"\r\n  RENAME_PROMPT2, \"&New name:\"\r\n  VERIFY_CERT_PROMPT3, \"**The server's certificate is not known. You have no guarantee that the server is the computer you think it is.**\\n\\nServer's certificate details follow:\\n\\n%s\\n\\nIf you trust this certificate, press Yes. To connect without storing certificate, press No. To abandon the connection press Cancel.\\n\\nContinue connecting and store the certificate?\"\r\n  VERIFY_CERT_CONTACT, \"- Organization: %s\\n|- Location: %s\\n|- Other: %s\\n\"\r\n  VERIFY_CERT_CONTACT_LIST, \"%s, %s\"\r\n  CERT_TEXT, \"Issuer:\\n%s\\nSubject:\\n%s\\nValid: %s - %s\\n\\nFingerprint (SHA-1): %s\\n\\nSummary: %s\"\r\n  CERTIFICATE_PASSPHRASE_PROMPT, \"&Passphrase for client certificate:\"\r\n  CERTIFICATE_PASSPHRASE_TITLE, \"Client certificate passphrase\"\r\n  KEY_TYPE_CONVERT3, \"**Do you want to convert this %s private key to PuTTY format?**\\n\\n%s\"\r\n  MULTI_FILES_TO_ONE, \"**Are you sure you want to transfer multiple files to a single file '%s' in a directory '%s'?**\\n\\nThe files will overwrite one another.\\n\\nIf you actually want to transfer all files to a directory '%s', keeping their name, make sure you terminate the path with a slash.\"\r\n  KEY_EXCHANGE_ALG, \"key-exchange algorithm\"\r\n  KEYKEY_TYPE, \"host key type\"\r\n  S3_ACCESS_KEY_ID_TITLE, \"Access key ID\"\r\n  S3_ACCESS_KEY_ID_PROMPT, \"A&ccess key ID:\"\r\n  S3_SECRET_ACCESS_KEY_TITLE, \"Secret access key\"\r\n  S3_SECRET_ACCESS_KEY_PROMPT, \"Secret access &key:\"\r\n\r\n  CORE_INFORMATION_STRINGS, \"CORE_INFORMATION\"\r\n  YES_STR, \"Yes\"\r\n  NO_STR, \"No\"\r\n  SESSION_INFO_TIP2, \"Host: %s\\nUser name: %s\\nPrivate key file: %s\\nTransfer protocol: %s\"\r\n  VERSION2, \"Version %s (%s)\"\r\n  CLOSED_ON_COMPLETION, \"Operation was successfully completed. Connection was closed.\"\r\n  SFTP_PROTOCOL_NAME2, \"SFTP-%d\"\r\n  FS_RENAME_NOT_SUPPORTED, \"The version of SFTP protocol does not allow file renaming.\"\r\n  SFTP_NO_EXTENSION_INFO, \"The server does not support any SFTP extension.\"\r\n  SFTP_EXTENSION_INFO, \"The server supports these SFTP extensions:\"\r\n  APPEND_BUTTON, \"A&ppend\"\r\n  YES_TO_NEWER_BUTTON, \"Ne&wer only\"\r\n  SCRIPT_HELP_DESC, \"Displays help\"\r\n  SCRIPT_EXIT_DESC, \"Closes all sessions and terminates the program\"\r\n  SCRIPT_OPEN_DESC, \"Connects to server\"\r\n  SCRIPT_CLOSE_DESC, \"Closes session\"\r\n  SCRIPT_SESSION_DESC, \"Lists connected sessions or selects active session\"\r\n  SCRIPT_PWD_DESC, \"Prints remote working directory\"\r\n  SCRIPT_CD_DESC, \"Changes remote working directory\"\r\n  SCRIPT_LS_DESC, \"Lists the contents of remote directory\"\r\n  SCRIPT_LPWD_DESC, \"Prints local working directory\"\r\n  SCRIPT_LCD_DESC, \"Changes local working directory\"\r\n  SCRIPT_LLS_DESC, \"Lists the contents of local directory\"\r\n  SCRIPT_RM_DESC, \"Removes remote file\"\r\n  SCRIPT_RMDIR_DESC, \"Removes remote directory\"\r\n  SCRIPT_MV_DESC, \"Moves or renames remote file\"\r\n  SCRIPT_CHMOD_DESC, \"Changes permissions of remote file\"\r\n  SCRIPT_LN_DESC, \"Creates remote symbolic link\"\r\n  SCRIPT_MKDIR_DESC, \"Creates remote directory\"\r\n  SCRIPT_GET_DESC, \"Downloads file from remote directory to local directory\"\r\n  SCRIPT_PUT_DESC, \"Uploads file from local directory to remote directory\"\r\n  SCRIPT_OPTION_DESC, \"Sets or shows value of script options\"\r\n  SCRIPT_SYNCHRONIZE_DESC, \"Synchronizes remote directory with local one\"\r\n  SCRIPT_KEEPUPTODATE_DESC, \"Continuously reflects changes in local directory on remote one\"\r\n  SCRIPT_HOST_PROMPT, \"Host: \"\r\n  SCRIPT_ACTIVE_SESSION, \"Active session: [%d] %s\"\r\n  SCRIPT_SESSION_CLOSED, \"Session '%s' closed.\"\r\n  SCRIPT_SYNCHRONIZE, \"Local '%s' %s Remote '%s'\"\r\n  SCRIPT_SYNCHRONIZE_DELETED, \"'%s' deleted\"\r\n  SCRIPT_KEEPING_UP_TO_DATE, \"Watching for changes, press Ctrl-C to abort...\"\r\n  SKIP_ALL_BUTTON, \"Ski&p all\"\r\n  SCRIPT_CALL_DESC2, \"Executes arbitrary remote command\"\r\n  COPY_PARAM_PRESET_ASCII, \"&Text\"\r\n  COPY_PARAM_PRESET_BINARY, \"&Binary\"\r\n  COPY_INFO_TRANSFER_TYPE2, \"Transfer type: %s|Binary|Text|Automatic (%s)|Automatic\"\r\n  COPY_INFO_FILENAME, \"Filename modification: %s|No change|Upper case|Lower case|First upper case|Lower case 8.3\"\r\n  COPY_INFO_PERMISSIONS, \"Set permissions: %s\"\r\n  COPY_INFO_ADD_X_TO_DIRS, \"Add X to directories\"\r\n  COPY_INFO_TIMESTAMP, \"Preserve timestamp\"\r\n  COPY_INFO_FILE_MASK, \"File mask: %s\"\r\n  COPY_INFO_CLEAR_ARCHIVE, \"Clear 'Archive' attribute\"\r\n  COPY_INFO_DONT_REPLACE_INV_CHARS, \"Do not replace invalid characters\"\r\n  COPY_INFO_DONT_PRESERVE_TIME, \"Do not preserve timestamp\"\r\n  COPY_INFO_DONT_CALCULATE_SIZE, \"Do not calculate transfer size\"\r\n  COPY_INFO_DEFAULT, \"Default transfer settings\"\r\n  COPY_RULE_HOSTNAME, \"Hostname: %s\"\r\n  COPY_RULE_USERNAME, \"Username: %s\"\r\n  COPY_RULE_REMOTE_DIR, \"Remote directory: %s\"\r\n  COPY_RULE_LOCAL_DIR, \"Local directory: %s\"\r\n  SYNCHRONIZE_SCAN, \"Scanning '%s' for subdirectories...\"\r\n  SYNCHRONIZE_START, \"Watching for changes in %d directories...\"\r\n  SYNCHRONIZE_CHANGE, \"Change in '%s' detected.\"\r\n  SYNCHRONIZE_UPLOADED, \"File '%s' uploaded.\"\r\n  SYNCHRONIZE_DELETED, \"File '%s' deleted.\"\r\n  COPY_INFO_NOT_USABLE, \"%s configured transfer settings cannot be used in current context|Some|All\"\r\n  COPY_INFO_IGNORE_PERM_ERRORS, \"Ignore permission errors\"\r\n  AUTH_TRANSL_USERNAME, \"Using username \\\"%s\\\".\"\r\n  AUTH_TRANSL_KEYB_INTER, \"Using keyboard-interactive authentication.\"\r\n  AUTH_TRANSL_PUBLIC_KEY, \"Authenticating with public key \\\"%s\\\".\"\r\n  AUTH_TRANSL_WRONG_PASSPHRASE, \"Wrong passphrase.\"\r\n  AUTH_TRANSL_ACCESS_DENIED, \"Access denied.\"\r\n  AUTH_TRANSL_PUBLIC_KEY_AGENT, \"Authenticating with public key \\\"%s\\\" from agent.\"\r\n  AUTH_TRANSL_TRY_PUBLIC_KEY, \"Trying public key authentication.\"\r\n  AUTH_PASSWORD, \"Authenticating with pre-entered password.\"\r\n  OPEN_TUNNEL, \"Opening tunnel...\"\r\n  STATUS_CLOSED, \"Connection terminated.\"\r\n  STATUS_LOOKUPHOST, \"Searching for host...\"\r\n  STATUS_CONNECT, \"Connecting to host...\"\r\n  STATUS_AUTHENTICATE, \"Authenticating...\"\r\n  STATUS_AUTHENTICATED, \"Authenticated.\"\r\n  STATUS_STARTUP, \"Starting the session...\"\r\n  STATUS_READY, \"Session started.\"\r\n  STATUS_OPEN_DIRECTORY, \"Reading remote directory...\"\r\n  USING_TUNNEL, \"Connecting through tunnel...\"\r\n  AUTH_TRANSL_KEY_REFUSED, \"Server refused our key.\"\r\n  PFWD_TRANSL_ADMIN, \"Administratively prohibited (%s).\"\r\n  PFWD_TRANSL_CONNECT, \"Connect failed (%s).\"\r\n  NET_TRANSL_REFUSED2, \"Network error: Connection to \\\"%HOST%\\\" refused.\"\r\n  NET_TRANSL_RESET, \"Network error: Connection reset by peer.\"\r\n  NET_TRANSL_TIMEOUT2, \"Network error: Connection to \\\"%HOST%\\\" timed out.\"\r\n  SESSION_INFO_TIP_NO_SSH, \"Host: %s\\nUser name: %s\\nTransfer protocol: %s\"\r\n  RESUME_BUTTON, \"&Resume\"\r\n  FTP_NO_FEATURE_INFO, \"The server does not support any additional FTP feature.\"\r\n  FTP_FEATURE_INFO, \"The server supports these FTP additional features:\"\r\n  COPY_INFO_CPS_LIMIT2, \"Transfer speed limit: %u KB/s\"\r\n  COPY_KEY_BUTTON, \"&Copy Key\"\r\n  UPDATE_KEY_BUTTON, \"&Update\"\r\n  ADD_KEY_BUTTON, \"&Add\"\r\n  COPY_INFO_PRESERVE_READONLY, \"Preserve read-only\"\r\n  SCRIPT_SYNCHRONIZE_COLLECTING, \"Comparing...\"\r\n  SCRIPT_SYNCHRONIZE_SYNCHRONIZING, \"Synchronizing...\"\r\n  SCRIPT_SYNCHRONIZE_NODIFFERENCE, \"Nothing to synchronize.\"\r\n  SPEED_UNLIMITED, \"Unlimited\"\r\n  FTPS_IMPLICIT, \"TLS/SSL Implicit encryption\"\r\n  FTPS_EXPLICIT, \"TLS/SSL Explicit encryption\"\r\n  SCRIPT_ECHO_DESC, \"Displays its arguments as message\"\r\n  SCRIPT_STAT_DESC, \"Retrieves attributes of remote file\"\r\n  HOSTKEY, \"Host key fingerprint is %s.\"\r\n  SCRIPT_FILEMASK_INCLUDE_EXCLUDE, \"Switch -filemask overrides obsolete options include/exclude.\"\r\n  COPY_PARAM_NEWER_ONLY, \"&New and updated files only\"\r\n  FTP_SUGGESTION, \"The server rejected SFTP connection, but it listens for FTP connections.\\n\\nDid you want to use FTP protocol instead of SFTP? Prefer using encryption.\"\r\n  SCRIPT_CMDLINE_SESSION, \"Opening session using command-line parameter in scripting is deprecated. Use 'open' command instead.\"\r\n  ANY_HOSTKEY, \"WARNING! Giving up security and accepting any host key as configured!\"\r\n  ANY_CERTIFICATE, \"WARNING! Giving up security and accepting any certificate as configured!\"\r\n  SCRIPT_SYNC_UPLOAD_NEW, \"New local file %s\"\r\n  SCRIPT_SYNC_DOWNLOAD_NEW, \"New remote file %s\"\r\n  SCRIPT_SYNC_UPLOAD_UPDATE, \"Local file %s newer than remote file %s\"\r\n  SCRIPT_SYNC_DOWNLOAD_UPDATE, \"Remote file %s newer than local file %s\"\r\n  SCRIPT_SYNC_DELETE_REMOTE, \"Orphan remote file %s\"\r\n  SCRIPT_SYNC_DELETE_LOCAL, \"Orphan local file %s\"\r\n  SCRIPT_SYNCHRONIZE_CHECKLIST, \"Differences found:\"\r\n  COPY_INFO_REMOVE_CTRLZ, \"Remove EOF mark\"\r\n  COPY_INFO_REMOVE_BOM, \"Remove BOM\"\r\n  SCRIPT_NON_DEFAULT_COPY_PARAM, \"Using configured transfer settings different from factory defaults.\"\r\n  SCRIPT_NON_DEFAULT_SYNC_PARAM, \"Using configured synchronization options different from factory defaults.\"\r\n  VERSION_BUILD, \"Build\"\r\n  VERSION_DEV_BUILD, \"Dev Build\"\r\n  VERSION_DEBUG_BUILD, \"Debug Build\"\r\n  VERSION_DONT_DISTRIBUTE, \"- Do NOT distribute\"\r\n  WEBDAV_EXTENSION_INFO, \"The server supports these WebDAV extensions:\"\r\n  COPY_PARAM_PRESET_EXCLUDE_ALL_DIR, \"Exclude &directories\"\r\n  SCRIPT_CHECKSUM_DESC, \"Calculates checksum of remote file\"\r\n  CLIENT_CERTIFICATE_LOADING, \"Loading client certificate...\"\r\n  NEED_CLIENT_CERTIFICATE, \"Server asks for authentication with a client certificate.\"\r\n  LOCKED, \"Locked\"\r\n  EXECUTABLE, \"Executable\"\r\n  SCRIPT_CMDLINE_PARAMETERS, \"Scripting does not use standalone parameters. The parameters you have specified on command-line will not be used. Your command-line syntax is probably wrong.\"\r\n  SCRIPTING_USE_HOSTKEY, \"In scripting, you should use a -hostkey switch to configure the expected host key.\"\r\n  SCRIPT_SITE_WARNING, \"In scripting you should not rely on saved sites, use this command instead:\"\r\n  CODE_SESSION_OPTIONS, \"Set up session options\"\r\n  CODE_CONNECT, \"Connect\"\r\n  CODE_PS_ADD_TYPE, \"Load WinSCP .NET assembly\"\r\n  COPY_INFO_PRESERVE_TIME_DIRS, \"%s (including directories)\"\r\n  TEXT_FILE_ENCODING, \"The file must be in UTF-8 or UTF-16 encoding.\"\r\n  AND_STR, \"%s and %s\"\r\n  AUTH_CHANGING_PASSWORD, \"Changing password.\"\r\n  PASTE_KEY_BUTTON, \"&Paste key\"\r\n  SCRIPT_CP_DESC, \"Duplicates remote file\"\r\n  TIME_UNKNOWN, \"Unknown\"\r\n  KEY_DETAILS, \"    Algorithm:\\t%s\\n    SHA-256:\\t%s\\n    MD5:\\t%s\"\r\n  COPY_KEY_ACTION, \"&Copy key fingerprints to clipboard\"\r\n  COPY_CERTIFICATE_ACTION, \"&Copy certificate fingerprint to clipboard\"\r\n  COPY_INFO_DONT_ENCRYPT_NEW_FILES, \"Do not encrypt new files\"\r\n  COPY_INFO_EXCLUDE_HIDDEN_FILES, \"Exclude hidden files\"\r\n  COPY_INFO_EXCLUDE_EMPTY_DIRS, \"Exclude empty directories\"\r\n\r\n  CORE_VARIABLE_STRINGS, \"CORE_VARIABLE\"\r\n  PUTTY_BASED_ON, \"SSH and SCP code based on PuTTY %s\"\r\n  PUTTY_COPYRIGHT, \"Copyright \u00a9 1997-2017 Simon Tatham\"\r\n  PUTTY_URL, \"https://www.chiark.greenend.org.uk/~sgtatham/putty/\"\r\n  FILEZILLA_BASED_ON2, \"FTP code based on FileZilla\"\r\n  FILEZILLA_COPYRIGHT2, \"Copyright \u00a9 Tim Kosse\"\r\n  FILEZILLA_URL, \"https://filezilla-project.org/\"\r\n  OPENSSL_BASED_ON, \"This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit %s.\"\r\n  OPENSSL_COPYRIGHT2, \"Copyright \u00a9 1998-%s The OpenSSL Project\"\r\n  OPENSSL_URL, \"https://www.openssl.org/\"\r\n  NEON_BASED_ON2, \"WebDAV/HTTP code based on neon library %s\"\r\n  NEON_COPYRIGHT, \"Copyright \u00a9 1999-2016 Joe Orton\"\r\n  EXPAT_BASED_ON, \"eXpat library %s\"\r\n  EXPAT_URL, \"http://www.libexpat.org/\"\r\n  PUTTY_LICENSE_URL, \"https://www.chiark.greenend.org.uk/~sgtatham/putty/licence.html\"\r\n  MAIN_MSG_TAG, \"**\"\r\n  INTERACTIVE_MSG_TAG, \"$$\"\r\n  S3_BASED_ON, \"S3 code based on libs3 library %s\"\r\n  S3_COPYRIGHT, \"Copyright \u00a9 Bryan Ischo\"\r\n  S3_URL, \"https://github.com/bji/libs3\"\r\n  S3_LICENSE_URL, \"https://github.com/bji/libs3/blob/master/LICENSE\"\r\nEND\r\n"], "fixing_code": ["//---------------------------------------------------------------------------\r\n#include <vcl.h>\r\n#pragma hdrstop\r\n\r\n#include \"ScpFileSystem.h\"\r\n\r\n#include \"Terminal.h\"\r\n#include \"Common.h\"\r\n#include \"Exceptions.h\"\r\n#include \"Interface.h\"\r\n#include \"TextsCore.h\"\r\n#include \"HelpCore.h\"\r\n#include \"SecureShell.h\"\r\n#include <StrUtils.hpp>\r\n\r\n#include <stdio.h>\r\n//---------------------------------------------------------------------------\r\n#pragma package(smart_init)\r\n//---------------------------------------------------------------------------\r\n#define FILE_OPERATION_LOOP_TERMINAL FTerminal\r\n//---------------------------------------------------------------------------\r\nconst int coRaiseExcept = 1;\r\nconst int coExpectNoOutput = 2;\r\nconst int coWaitForLastLine = 4;\r\nconst int coOnlyReturnCode = 8;\r\nconst int coIgnoreWarnings = 16;\r\nconst int coReadProgress = 32;\r\n\r\nconst int ecRaiseExcept = 1;\r\nconst int ecIgnoreWarnings = 2;\r\nconst int ecReadProgress = 4;\r\nconst int ecDefault = ecRaiseExcept;\r\n//---------------------------------------------------------------------------\r\nDERIVE_EXT_EXCEPTION(EScpFileSkipped, ESkipFile);\r\n//===========================================================================\r\n#define MaxShellCommand fsLang\r\n#define ShellCommandCount MaxShellCommand + 1\r\n#define MaxCommandLen 40\r\nstruct TCommandType\r\n{\r\n  int MinLines;\r\n  int MaxLines;\r\n  bool ModifiesFiles;\r\n  bool ChangesDirectory;\r\n  bool InteractiveCommand;\r\n  wchar_t Command[MaxCommandLen];\r\n};\r\n\r\n// Only one character! See TSCPFileSystem::ReadCommandOutput()\r\n#define LastLineSeparator L\":\"\r\n#define LAST_LINE L\"WinSCP: this is end-of-file\"\r\n#define FIRST_LINE L\"WinSCP: this is begin-of-file\"\r\nextern const TCommandType DefaultCommandSet[];\r\n\r\n#define NationalVarCount 10\r\nextern const wchar_t NationalVars[NationalVarCount][15];\r\n\r\n#define CHECK_CMD DebugAssert((Cmd >=0) && (Cmd <= MaxShellCommand))\r\n\r\nclass TSessionData;\r\n//---------------------------------------------------------------------------\r\nclass TCommandSet\r\n{\r\nprivate:\r\n  TCommandType CommandSet[ShellCommandCount];\r\n  TSessionData * FSessionData;\r\n  UnicodeString FReturnVar;\r\n  int __fastcall GetMaxLines(TFSCommand Cmd);\r\n  int __fastcall GetMinLines(TFSCommand Cmd);\r\n  bool __fastcall GetModifiesFiles(TFSCommand Cmd);\r\n  bool __fastcall GetChangesDirectory(TFSCommand Cmd);\r\n  bool __fastcall GetOneLineCommand(TFSCommand Cmd);\r\n  void __fastcall SetCommands(TFSCommand Cmd, UnicodeString value);\r\n  UnicodeString __fastcall GetCommands(TFSCommand Cmd);\r\n  UnicodeString __fastcall GetFirstLine();\r\n  bool __fastcall GetInteractiveCommand(TFSCommand Cmd);\r\n  UnicodeString __fastcall GetLastLine();\r\n  UnicodeString __fastcall GetReturnVar();\r\npublic:\r\n  __fastcall TCommandSet(TSessionData *aSessionData);\r\n  void __fastcall Default();\r\n  void __fastcall CopyFrom(TCommandSet * Source);\r\n  UnicodeString __fastcall Command(TFSCommand Cmd, const TVarRec * args, int size);\r\n  TStrings * __fastcall CreateCommandList();\r\n  UnicodeString __fastcall FullCommand(TFSCommand Cmd, const TVarRec * args, int size);\r\n  static UnicodeString __fastcall ExtractCommand(UnicodeString Command);\r\n  __property int MaxLines[TFSCommand Cmd]  = { read=GetMaxLines};\r\n  __property int MinLines[TFSCommand Cmd]  = { read=GetMinLines };\r\n  __property bool ModifiesFiles[TFSCommand Cmd]  = { read=GetModifiesFiles };\r\n  __property bool ChangesDirectory[TFSCommand Cmd]  = { read=GetChangesDirectory };\r\n  __property bool OneLineCommand[TFSCommand Cmd]  = { read=GetOneLineCommand };\r\n  __property UnicodeString Commands[TFSCommand Cmd]  = { read=GetCommands, write=SetCommands };\r\n  __property UnicodeString FirstLine = { read = GetFirstLine };\r\n  __property bool InteractiveCommand[TFSCommand Cmd] = { read = GetInteractiveCommand };\r\n  __property UnicodeString LastLine  = { read=GetLastLine };\r\n  __property TSessionData * SessionData  = { read=FSessionData, write=FSessionData };\r\n  __property UnicodeString ReturnVar  = { read=GetReturnVar, write=FReturnVar };\r\n};\r\n//===========================================================================\r\nconst wchar_t NationalVars[NationalVarCount][15] =\r\n  {L\"LANG\", L\"LANGUAGE\", L\"LC_CTYPE\", L\"LC_COLLATE\", L\"LC_MONETARY\", L\"LC_NUMERIC\",\r\n   L\"LC_TIME\", L\"LC_MESSAGES\", L\"LC_ALL\", L\"HUMAN_BLOCKS\" };\r\nconst wchar_t FullTimeOption[] = L\"--full-time\";\r\n//---------------------------------------------------------------------------\r\n#define F false\r\n#define T true\r\n// TODO: remove \"mf\" and \"cd\", it is implemented in TTerminal already\r\nconst TCommandType DefaultCommandSet[ShellCommandCount] = {\r\n//                       min max mf cd ia  command\r\n/*Null*/                { -1, -1, F, F, F, L\"\" },\r\n/*VarValue*/            { -1, -1, F, F, F, L\"echo \\\"$%s\\\"\" /* variable */ },\r\n/*LastLine*/            { -1, -1, F, F, F, L\"echo \\\"%s\" LastLineSeparator \"%s\\\"\" /* last line, return var */ },\r\n/*FirstLine*/           { -1, -1, F, F, F, L\"echo \\\"%s\\\"\" /* first line */ },\r\n/*CurrentDirectory*/    {  1,  1, F, F, F, L\"pwd\" },\r\n/*ChangeDirectory*/     {  0,  0, F, T, F, L\"cd %s\" /* directory */ },\r\n// list directory can be empty on permission denied, this is handled in ReadDirectory\r\n/*ListDirectory*/       { -1, -1, F, F, F, L\"%s %s \\\"%s\\\"\" /* listing command, options, directory */ },\r\n/*ListCurrentDirectory*/{ -1, -1, F, F, F, L\"%s %s\" /* listing command, options */ },\r\n/*ListFile*/            {  1,  1, F, F, F, L\"%s -d %s \\\"%s\\\"\" /* listing command, options, file/directory */ },\r\n/*LookupUserGroups*/    {  0,  1, F, F, F, L\"groups\" },\r\n/*CopyToRemote*/        { -1, -1, T, F, T, L\"scp -r %s -d -t \\\"%s\\\"\" /* options, directory */ },\r\n/*CopyToLocal*/         { -1, -1, F, F, T, L\"scp -r %s -d -f \\\"%s\\\"\" /* options, file */ },\r\n/*DeleteFile*/          {  0,  0, T, F, F, L\"rm -f -r \\\"%s\\\"\" /* file/directory */},\r\n/*RenameFile*/          {  0,  0, T, F, F, L\"mv -f \\\"%s\\\" \\\"%s\\\"\" /* file/directory, new name*/},\r\n/*CreateDirectory*/     {  0,  0, T, F, F, L\"mkdir \\\"%s\\\"\" /* new directory */},\r\n/*ChangeMode*/          {  0,  0, T, F, F, L\"chmod %s %s \\\"%s\\\"\" /* options, mode, filename */},\r\n/*ChangeGroup*/         {  0,  0, T, F, F, L\"chgrp %s \\\"%s\\\" \\\"%s\\\"\" /* options, group, filename */},\r\n/*ChangeOwner*/         {  0,  0, T, F, F, L\"chown %s \\\"%s\\\" \\\"%s\\\"\" /* options, owner, filename */},\r\n/*HomeDirectory*/       {  0,  0, F, T, F, L\"cd\" },\r\n/*Unset*/               {  0,  0, F, F, F, L\"unset \\\"%s\\\"\" /* variable */ },\r\n/*Unalias*/             {  0,  0, F, F, F, L\"unalias \\\"%s\\\"\" /* alias */ },\r\n/*CreateLink*/          {  0,  0, T, F, F, L\"ln %s \\\"%s\\\" \\\"%s\\\"\" /*symbolic (-s), filename, point to*/},\r\n/*CopyFile*/            {  0,  0, T, F, F, L\"cp -p -r -f %s \\\"%s\\\" \\\"%s\\\"\" /* file/directory, target name*/},\r\n/*AnyCommand*/          {  0, -1, T, T, F, L\"%s\" },\r\n/*Lang*/                {  0,  1, F, F, F, L\"printenv LANG\"}\r\n};\r\n#undef F\r\n#undef T\r\n//---------------------------------------------------------------------------\r\n__fastcall TCommandSet::TCommandSet(TSessionData *aSessionData):\r\n  FSessionData(aSessionData), FReturnVar(L\"\")\r\n{\r\n  DebugAssert(FSessionData);\r\n  Default();\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TCommandSet::CopyFrom(TCommandSet * Source)\r\n{\r\n  memmove(&CommandSet, Source->CommandSet, sizeof(CommandSet));\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TCommandSet::Default()\r\n{\r\n  DebugAssert(sizeof(CommandSet) == sizeof(DefaultCommandSet));\r\n  memmove(&CommandSet, &DefaultCommandSet, sizeof(CommandSet));\r\n}\r\n//---------------------------------------------------------------------------\r\nint __fastcall TCommandSet::GetMaxLines(TFSCommand Cmd)\r\n{\r\n  CHECK_CMD;\r\n  return CommandSet[Cmd].MaxLines;\r\n}\r\n//---------------------------------------------------------------------------\r\nint __fastcall TCommandSet::GetMinLines(TFSCommand Cmd)\r\n{\r\n  CHECK_CMD;\r\n  return CommandSet[Cmd].MinLines;\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TCommandSet::GetModifiesFiles(TFSCommand Cmd)\r\n{\r\n  CHECK_CMD;\r\n  return CommandSet[Cmd].ModifiesFiles;\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TCommandSet::GetChangesDirectory(TFSCommand Cmd)\r\n{\r\n  CHECK_CMD;\r\n  return CommandSet[Cmd].ChangesDirectory;\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TCommandSet::GetInteractiveCommand(TFSCommand Cmd)\r\n{\r\n  CHECK_CMD;\r\n  return CommandSet[Cmd].InteractiveCommand;\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TCommandSet::GetOneLineCommand(TFSCommand /*Cmd*/)\r\n{\r\n  //CHECK_CMD;\r\n  // #56: we send \"echo last line\" from all commands on same line\r\n  // just as it was in 1.0\r\n  return True; //CommandSet[Cmd].OneLineCommand;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TCommandSet::SetCommands(TFSCommand Cmd, UnicodeString value)\r\n{\r\n  CHECK_CMD;\r\n  wcscpy(CommandSet[Cmd].Command, value.SubString(1, MaxCommandLen - 1).c_str());\r\n}\r\n//---------------------------------------------------------------------------\r\nUnicodeString __fastcall TCommandSet::GetCommands(TFSCommand Cmd)\r\n{\r\n  CHECK_CMD;\r\n  return CommandSet[Cmd].Command;\r\n}\r\n//---------------------------------------------------------------------------\r\nUnicodeString __fastcall TCommandSet::Command(TFSCommand Cmd, const TVarRec * args, int size)\r\n{\r\n  if (args) return Format(Commands[Cmd], args, size);\r\n    else return Commands[Cmd];\r\n}\r\n//---------------------------------------------------------------------------\r\nUnicodeString __fastcall TCommandSet::FullCommand(TFSCommand Cmd, const TVarRec * args, int size)\r\n{\r\n  UnicodeString Separator;\r\n  if (OneLineCommand[Cmd]) Separator = L\" ; \";\r\n    else Separator = L\"\\n\";\r\n  UnicodeString Line = Command(Cmd, args, size);\r\n  UnicodeString LastLineCmd =\r\n    Command(fsLastLine, ARRAYOFCONST((LastLine, ReturnVar)));\r\n  UnicodeString FirstLineCmd;\r\n  if (InteractiveCommand[Cmd])\r\n    FirstLineCmd = Command(fsFirstLine, ARRAYOFCONST((FirstLine))) + Separator;\r\n\r\n  UnicodeString Result;\r\n  if (!Line.IsEmpty())\r\n    Result = FORMAT(L\"%s%s%s%s\", (FirstLineCmd, Line, Separator, LastLineCmd));\r\n  else\r\n    Result = FORMAT(L\"%s%s\", (FirstLineCmd, LastLineCmd));\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nUnicodeString __fastcall TCommandSet::GetFirstLine()\r\n{\r\n  return FIRST_LINE;\r\n}\r\n//---------------------------------------------------------------------------\r\nUnicodeString __fastcall TCommandSet::GetLastLine()\r\n{\r\n  return LAST_LINE;\r\n}\r\n//---------------------------------------------------------------------------\r\nUnicodeString __fastcall TCommandSet::GetReturnVar()\r\n{\r\n  DebugAssert(SessionData);\r\n  if (!FReturnVar.IsEmpty())\r\n  {\r\n    return UnicodeString(L'$') + FReturnVar;\r\n  }\r\n  else if (SessionData->DetectReturnVar)\r\n  {\r\n    return L'0';\r\n  }\r\n  else\r\n  {\r\n    return UnicodeString(L'$') + SessionData->ReturnVar;\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nUnicodeString __fastcall TCommandSet::ExtractCommand(UnicodeString Command)\r\n{\r\n  int P = Command.Pos(L\" \");\r\n  if (P > 0)\r\n  {\r\n    Command.SetLength(P-1);\r\n  }\r\n  return Command;\r\n}\r\n//---------------------------------------------------------------------------\r\nTStrings * __fastcall TCommandSet::CreateCommandList()\r\n{\r\n  TStrings * CommandList = new TStringList();\r\n  for (Integer Index = 0; Index < ShellCommandCount; Index++)\r\n  {\r\n    UnicodeString Cmd = Commands[(TFSCommand)Index];\r\n    if (!Cmd.IsEmpty())\r\n    {\r\n      Cmd = ExtractCommand(Cmd);\r\n      if ((Cmd != L\"%s\") && (CommandList->IndexOf(Cmd) < 0))\r\n        CommandList->Add(Cmd);\r\n    }\r\n  }\r\n  return CommandList;\r\n}\r\n//===========================================================================\r\n__fastcall TSCPFileSystem::TSCPFileSystem(TTerminal * ATerminal, TSecureShell * SecureShell):\r\n  TCustomFileSystem(ATerminal)\r\n{\r\n  FSecureShell = SecureShell;\r\n  FCommandSet = new TCommandSet(FTerminal->SessionData);\r\n  FLsFullTime = FTerminal->SessionData->SCPLsFullTime;\r\n  FOutput = new TStringList();\r\n  FProcessingCommand = false;\r\n  FOnCaptureOutput = NULL;\r\n\r\n  FFileSystemInfo.ProtocolBaseName = L\"SCP\";\r\n  FFileSystemInfo.ProtocolName = FFileSystemInfo.ProtocolBaseName;\r\n}\r\n//---------------------------------------------------------------------------\r\n__fastcall TSCPFileSystem::~TSCPFileSystem()\r\n{\r\n  delete FCommandSet;\r\n  delete FOutput;\r\n  delete FSecureShell;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::Open()\r\n{\r\n  // this is used for reconnects only\r\n  FSecureShell->Open();\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::Close()\r\n{\r\n  FSecureShell->Close();\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TSCPFileSystem::GetActive()\r\n{\r\n  return FSecureShell->Active;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::CollectUsage()\r\n{\r\n  FSecureShell->CollectUsage();\r\n}\r\n//---------------------------------------------------------------------------\r\nconst TSessionInfo & __fastcall TSCPFileSystem::GetSessionInfo()\r\n{\r\n  return FSecureShell->GetSessionInfo();\r\n}\r\n//---------------------------------------------------------------------------\r\nconst TFileSystemInfo & __fastcall TSCPFileSystem::GetFileSystemInfo(bool Retrieve)\r\n{\r\n  if (FFileSystemInfo.AdditionalInfo.IsEmpty() && Retrieve)\r\n  {\r\n    UnicodeString UName;\r\n    FTerminal->ExceptionOnFail = true;\r\n    try\r\n    {\r\n      try\r\n      {\r\n        AnyCommand(L\"uname -a\", NULL);\r\n        for (int Index = 0; Index < Output->Count; Index++)\r\n        {\r\n          if (Index > 0)\r\n          {\r\n            UName += L\"; \";\r\n          }\r\n          UName += Output->Strings[Index];\r\n        }\r\n      }\r\n      catch(...)\r\n      {\r\n        if (!FTerminal->Active)\r\n        {\r\n          throw;\r\n        }\r\n      }\r\n    }\r\n    __finally\r\n    {\r\n      FTerminal->ExceptionOnFail = false;\r\n    }\r\n\r\n    FFileSystemInfo.RemoteSystem = UName;\r\n  }\r\n\r\n  return FFileSystemInfo;\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TSCPFileSystem::TemporaryTransferFile(const UnicodeString & /*FileName*/)\r\n{\r\n  return false;\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TSCPFileSystem::GetStoredCredentialsTried()\r\n{\r\n  return FSecureShell->GetStoredCredentialsTried();\r\n}\r\n//---------------------------------------------------------------------------\r\nUnicodeString __fastcall TSCPFileSystem::GetUserName()\r\n{\r\n  return FSecureShell->UserName;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::Idle()\r\n{\r\n  // Keep session alive\r\n  if ((FTerminal->SessionData->PingType != ptOff) &&\r\n      (Now() - FSecureShell->LastDataSent > FTerminal->SessionData->PingIntervalDT))\r\n  {\r\n    if ((FTerminal->SessionData->PingType == ptDummyCommand) &&\r\n        FSecureShell->Ready)\r\n    {\r\n      if (!FProcessingCommand)\r\n      {\r\n        ExecCommand(fsNull, NULL, 0, 0);\r\n      }\r\n      else\r\n      {\r\n        FTerminal->LogEvent(L\"Cannot send keepalive, command is being executed\");\r\n        // send at least SSH-level keepalive, if nothing else, it at least updates\r\n        // LastDataSent, no the next keepalive attempt is postponed\r\n        FSecureShell->KeepAlive();\r\n      }\r\n    }\r\n    else\r\n    {\r\n      FSecureShell->KeepAlive();\r\n    }\r\n  }\r\n\r\n  FSecureShell->Idle();\r\n}\r\n//---------------------------------------------------------------------------\r\nUnicodeString __fastcall TSCPFileSystem::AbsolutePath(UnicodeString Path, bool /*Local*/)\r\n{\r\n  return ::AbsolutePath(CurrentDirectory, Path);\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TSCPFileSystem::IsCapable(int Capability) const\r\n{\r\n  DebugAssert(FTerminal);\r\n  switch (Capability) {\r\n    case fcUserGroupListing:\r\n    case fcModeChanging:\r\n    case fcModeChangingUpload:\r\n    case fcPreservingTimestampUpload:\r\n    case fcGroupChanging:\r\n    case fcOwnerChanging:\r\n    case fcAnyCommand:\r\n    case fcShellAnyCommand:\r\n    case fcHardLink:\r\n    case fcSymbolicLink:\r\n    case fcResolveSymlink:\r\n    case fcRename:\r\n    case fcRemoteMove:\r\n    case fcRemoteCopy:\r\n    case fcRemoveCtrlZUpload:\r\n    case fcRemoveBOMUpload:\r\n      return true;\r\n\r\n    case fcTextMode:\r\n      return FTerminal->SessionData->EOLType != FTerminal->Configuration->LocalEOLType;\r\n\r\n    case fcNativeTextMode:\r\n    case fcNewerOnlyUpload:\r\n    case fcTimestampChanging:\r\n    case fcLoadingAdditionalProperties:\r\n    case fcCheckingSpaceAvailable:\r\n    case fcIgnorePermErrors:\r\n    case fcCalculatingChecksum:\r\n    case fcSecondaryShell: // has fcShellAnyCommand\r\n    case fcGroupOwnerChangingByID: // by name\r\n    case fcMoveToQueue:\r\n    case fcLocking:\r\n    case fcPreservingTimestampDirs:\r\n    case fcResumeSupport:\r\n    case fsSkipTransfer:\r\n    case fsParallelTransfers: // does not implement cpNoRecurse\r\n      return false;\r\n\r\n    case fcChangePassword:\r\n      return FSecureShell->CanChangePassword();\r\n\r\n    default:\r\n      DebugFail();\r\n      return false;\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nUnicodeString __fastcall TSCPFileSystem::DelimitStr(UnicodeString Str)\r\n{\r\n  if (!Str.IsEmpty())\r\n  {\r\n    Str = ::DelimitStr(Str, L\"\\\\`$\\\"\");\r\n    if (Str[1] == L'-') Str = L\"./\"+Str;\r\n  }\r\n  return Str;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::EnsureLocation()\r\n{\r\n  if (!FCachedDirectoryChange.IsEmpty())\r\n  {\r\n    FTerminal->LogEvent(FORMAT(L\"Locating to cached directory \\\"%s\\\".\",\r\n      (FCachedDirectoryChange)));\r\n    UnicodeString Directory = FCachedDirectoryChange;\r\n    FCachedDirectoryChange = L\"\";\r\n    try\r\n    {\r\n      ChangeDirectory(Directory);\r\n    }\r\n    catch(...)\r\n    {\r\n      // when location to cached directory fails, pretend again\r\n      // location in cached directory\r\n      // here used to be check (CurrentDirectory != Directory), but it is\r\n      // false always (current directory is already set to cached directory),\r\n      // making the condition below useless. check removed.\r\n      if (FTerminal->Active)\r\n      {\r\n        FCachedDirectoryChange = Directory;\r\n      }\r\n      throw;\r\n    }\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::SendCommand(const UnicodeString Cmd)\r\n{\r\n  EnsureLocation();\r\n\r\n  UnicodeString Line;\r\n  FSecureShell->ClearStdError();\r\n  FReturnCode = 0;\r\n  FOutput->Clear();\r\n  // We suppose, that 'Cmd' already contains command that ensures,\r\n  // that 'LastLine' will be printed\r\n  FSecureShell->SendLine(Cmd);\r\n  FProcessingCommand = true;\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TSCPFileSystem::IsTotalListingLine(const UnicodeString Line)\r\n{\r\n  // On some hosts there is not \"total\" but \"totalt\". What's the reason??\r\n  // see mail from \"Jan Wiklund (SysOp)\" <jan@park.se>\r\n  return !Line.SubString(1, 5).CompareIC(L\"total\");\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TSCPFileSystem::RemoveLastLine(UnicodeString & Line,\r\n    int & ReturnCode, UnicodeString LastLine)\r\n{\r\n  bool IsLastLine = false;\r\n  if (LastLine.IsEmpty()) LastLine = LAST_LINE;\r\n  // #55: fixed so, even when last line of command output does not\r\n  // contain CR/LF, we can recognize last line\r\n  int Pos = Line.Pos(LastLine);\r\n  if (Pos)\r\n  {\r\n    // 2003-07-14: There must be nothing after return code number to\r\n    // consider string as last line. This fixes bug with 'set' command\r\n    // in console window\r\n    UnicodeString ReturnCodeStr = Line.SubString(Pos + LastLine.Length() + 1,\r\n      Line.Length() - Pos + LastLine.Length());\r\n    if (TryStrToInt(ReturnCodeStr, ReturnCode))\r\n    {\r\n      IsLastLine = true;\r\n      Line.SetLength(Pos - 1);\r\n    }\r\n  }\r\n  return IsLastLine;\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TSCPFileSystem::IsLastLine(UnicodeString & Line)\r\n{\r\n  bool Result = false;\r\n  try\r\n  {\r\n    Result = RemoveLastLine(Line, FReturnCode, FCommandSet->LastLine);\r\n  }\r\n  catch (Exception &E)\r\n  {\r\n    FTerminal->TerminalError(&E, LoadStr(CANT_DETECT_RETURN_CODE));\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::SkipFirstLine()\r\n{\r\n  UnicodeString Line = FSecureShell->ReceiveLine();\r\n  if (Line != FCommandSet->FirstLine)\r\n  {\r\n    FTerminal->TerminalError(NULL, FMTLOAD(FIRST_LINE_EXPECTED, (Line)));\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::ReadCommandOutput(int Params, const UnicodeString * Cmd)\r\n{\r\n  try\r\n  {\r\n    if (Params & coWaitForLastLine)\r\n    {\r\n      UnicodeString Line;\r\n      bool IsLast;\r\n      unsigned int Total = 0;\r\n      // #55: fixed so, even when last line of command output does not\r\n      // contain CR/LF, we can recognize last line\r\n      do\r\n      {\r\n        Line = FSecureShell->ReceiveLine();\r\n        IsLast = IsLastLine(Line);\r\n        if (!IsLast || !Line.IsEmpty())\r\n        {\r\n          FOutput->Add(Line);\r\n          if (FLAGSET(Params, coReadProgress))\r\n          {\r\n            Total++;\r\n\r\n            if (Total % 10 == 0)\r\n            {\r\n              bool Cancel; //dummy\r\n              FTerminal->DoReadDirectoryProgress(Total, 0, Cancel);\r\n            }\r\n          }\r\n        }\r\n      }\r\n      while (!IsLast);\r\n    }\r\n    if (Params & coRaiseExcept)\r\n    {\r\n      UnicodeString Message = FSecureShell->GetStdError();\r\n      if ((Params & coExpectNoOutput) && FOutput->Count)\r\n      {\r\n        if (!Message.IsEmpty()) Message += L\"\\n\";\r\n        Message += FOutput->Text;\r\n      }\r\n      while (!Message.IsEmpty() && (Message.LastDelimiter(L\"\\n\\r\") == Message.Length()))\r\n      {\r\n        Message.SetLength(Message.Length() - 1);\r\n      }\r\n\r\n      bool WrongReturnCode =\r\n        (ReturnCode > 1) || (ReturnCode == 1 && !(Params & coIgnoreWarnings));\r\n\r\n      if (FOnCaptureOutput != NULL)\r\n      {\r\n        FOnCaptureOutput(IntToStr(ReturnCode), cotExitCode);\r\n      }\r\n\r\n      if (Params & coOnlyReturnCode && WrongReturnCode)\r\n      {\r\n        FTerminal->TerminalError(FMTLOAD(COMMAND_FAILED_CODEONLY, (ReturnCode)));\r\n      }\r\n      else if (!(Params & coOnlyReturnCode) &&\r\n          ((!Message.IsEmpty() && ((FOutput->Count == 0) || !(Params & coIgnoreWarnings))) ||\r\n           WrongReturnCode))\r\n      {\r\n        DebugAssert(Cmd != NULL);\r\n        FTerminal->TerminalError(FMTLOAD(COMMAND_FAILED, (*Cmd, ReturnCode, Message)));\r\n      }\r\n    }\r\n  }\r\n  __finally\r\n  {\r\n    FProcessingCommand = false;\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::ExecCommand(const UnicodeString & Cmd, int Params,\r\n  const UnicodeString & CmdString)\r\n{\r\n  if (Params < 0)\r\n  {\r\n    Params = ecDefault;\r\n  }\r\n\r\n  TOperationVisualizer Visualizer(FTerminal->UseBusyCursor);\r\n\r\n  SendCommand(Cmd);\r\n\r\n  int COParams = coWaitForLastLine;\r\n  if (Params & ecRaiseExcept) COParams |= coRaiseExcept;\r\n  if (Params & ecIgnoreWarnings) COParams |= coIgnoreWarnings;\r\n  if (Params & ecReadProgress) COParams |= coReadProgress;\r\n  ReadCommandOutput(COParams, &CmdString);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::ExecCommand(TFSCommand Cmd, const TVarRec * args,\r\n  int size, int Params)\r\n{\r\n  if (Params < 0) Params = ecDefault;\r\n  UnicodeString FullCommand = FCommandSet->FullCommand(Cmd, args, size);\r\n  UnicodeString Command = FCommandSet->Command(Cmd, args, size);\r\n  ExecCommand(FullCommand, Params, Command);\r\n  if (Params & ecRaiseExcept)\r\n  {\r\n    Integer MinL = FCommandSet->MinLines[Cmd];\r\n    Integer MaxL = FCommandSet->MaxLines[Cmd];\r\n    if (((MinL >= 0) && (MinL > FOutput->Count)) ||\r\n        ((MaxL >= 0) && (MaxL > FOutput->Count)))\r\n    {\r\n      FTerminal->TerminalError(FmtLoadStr(INVALID_OUTPUT_ERROR,\r\n        ARRAYOFCONST((FullCommand, Output->Text))));\r\n    }\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nUnicodeString __fastcall TSCPFileSystem::GetCurrentDirectory()\r\n{\r\n  return FCurrentDirectory;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::DoStartup()\r\n{\r\n  // Capabilities of SCP protocol are fixed\r\n  FTerminal->SaveCapabilities(FFileSystemInfo);\r\n\r\n  // SkipStartupMessage and DetectReturnVar must succeed,\r\n  // otherwise session is to be closed.\r\n  try\r\n  {\r\n    FTerminal->ExceptionOnFail = true;\r\n    SkipStartupMessage();\r\n    if (FTerminal->SessionData->DetectReturnVar) DetectReturnVar();\r\n    FTerminal->ExceptionOnFail = false;\r\n  }\r\n  catch (Exception & E)\r\n  {\r\n    FTerminal->FatalError(&E, L\"\");\r\n  }\r\n\r\n  // Needs to be done before UnsetNationalVars()\r\n  DetectUtf();\r\n\r\n  #define COND_OPER(OPER) if (FTerminal->SessionData->OPER) OPER()\r\n  COND_OPER(ClearAliases);\r\n  COND_OPER(UnsetNationalVars);\r\n  #undef COND_OPER\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::DetectUtf()\r\n{\r\n  switch (FTerminal->SessionData->NotUtf)\r\n  {\r\n    case asOn:\r\n      FSecureShell->UtfStrings = false; // noop\r\n      break;\r\n\r\n    case asOff:\r\n      FSecureShell->UtfStrings = true;\r\n      break;\r\n\r\n    default:\r\n      DebugFail();\r\n    case asAuto:\r\n      FSecureShell->UtfStrings = false; // noop\r\n      try\r\n      {\r\n        ExecCommand(fsLang, NULL, 0, false);\r\n\r\n        if ((FOutput->Count >= 1) &&\r\n            ContainsText(FOutput->Strings[0], L\"UTF-8\"))\r\n        {\r\n          FSecureShell->UtfStrings = true;\r\n        }\r\n      }\r\n      catch (Exception & E)\r\n      {\r\n        // ignore non-fatal errors\r\n        if (!FTerminal->Active)\r\n        {\r\n          throw;\r\n        }\r\n      }\r\n      break;\r\n  }\r\n\r\n  if (FSecureShell->UtfStrings)\r\n  {\r\n    FTerminal->LogEvent(L\"We will use UTF-8\");\r\n  }\r\n  else\r\n  {\r\n    FTerminal->LogEvent(L\"We will not use UTF-8\");\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::SkipStartupMessage()\r\n{\r\n  try\r\n  {\r\n    FTerminal->LogEvent(L\"Skipping host startup message (if any).\");\r\n    ExecCommand(fsNull, NULL, 0, 0);\r\n  }\r\n  catch (Exception & E)\r\n  {\r\n    FTerminal->CommandError(&E, LoadStr(SKIP_STARTUP_MESSAGE_ERROR), 0, HELP_SKIP_STARTUP_MESSAGE_ERROR);\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::LookupUsersGroups()\r\n{\r\n  ExecCommand(fsLookupUsersGroups);\r\n  FTerminal->FUsers.Clear();\r\n  FTerminal->FGroups.Clear();\r\n  if (FOutput->Count > 0)\r\n  {\r\n    UnicodeString Groups = FOutput->Strings[0];\r\n    while (!Groups.IsEmpty())\r\n    {\r\n      UnicodeString NewGroup = CutToChar(Groups, L' ', false);\r\n      FTerminal->FGroups.Add(TRemoteToken(NewGroup));\r\n      FTerminal->FMembership.Add(TRemoteToken(NewGroup));\r\n    }\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::DetectReturnVar()\r\n{\r\n  // This suppose that something was already executed (probably SkipStartupMessage())\r\n  // or return code variable is already set on start up.\r\n\r\n  try\r\n  {\r\n    // #60 17.10.01: \"status\" and \"?\" switched\r\n    UnicodeString ReturnVars[2] = { L\"status\", L\"?\" };\r\n    UnicodeString NewReturnVar = L\"\";\r\n    FTerminal->LogEvent(L\"Detecting variable containing return code of last command.\");\r\n    for (int Index = 0; Index < 2; Index++)\r\n    {\r\n      bool Success = true;\r\n\r\n      try\r\n      {\r\n        FTerminal->LogEvent(FORMAT(L\"Trying \\\"$%s\\\".\", (ReturnVars[Index])));\r\n        ExecCommand(fsVarValue, ARRAYOFCONST((ReturnVars[Index])));\r\n        if ((Output->Count != 1) || (StrToIntDef(Output->Strings[0], 256) > 255))\r\n        {\r\n          FTerminal->LogEvent(L\"The response is not numerical exit code\");\r\n          Abort();\r\n        }\r\n      }\r\n      catch (EFatal &E)\r\n      {\r\n        // if fatal error occurs, we need to exit ...\r\n        throw;\r\n      }\r\n      catch (Exception &E)\r\n      {\r\n        // ...otherwise, we will try next variable (if any)\r\n        Success = false;\r\n      }\r\n\r\n      if (Success)\r\n      {\r\n        NewReturnVar = ReturnVars[Index];\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (NewReturnVar.IsEmpty())\r\n    {\r\n      EXCEPTION;\r\n    }\r\n    else\r\n    {\r\n      FCommandSet->ReturnVar = NewReturnVar;\r\n      FTerminal->LogEvent(FORMAT(L\"Return code variable \\\"%s\\\" selected.\",\r\n        (FCommandSet->ReturnVar)));\r\n    }\r\n  }\r\n  catch (Exception &E)\r\n  {\r\n    FTerminal->CommandError(&E, LoadStr(DETECT_RETURNVAR_ERROR));\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::ClearAlias(UnicodeString Alias)\r\n{\r\n  if (!Alias.IsEmpty())\r\n  {\r\n    // this command usually fails, because there will never be\r\n    // aliases on all commands -> see last False parameter\r\n    ExecCommand(fsUnalias, ARRAYOFCONST((Alias)), false);\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::ClearAliases()\r\n{\r\n  try\r\n  {\r\n    FTerminal->LogEvent(L\"Clearing all aliases.\");\r\n    ClearAlias(TCommandSet::ExtractCommand(FTerminal->SessionData->ListingCommand));\r\n    TStrings * CommandList = FCommandSet->CreateCommandList();\r\n    try\r\n    {\r\n      for (int Index = 0; Index < CommandList->Count; Index++)\r\n      {\r\n        ClearAlias(CommandList->Strings[Index]);\r\n      }\r\n    }\r\n    __finally\r\n    {\r\n      delete CommandList;\r\n    }\r\n  }\r\n  catch (Exception &E)\r\n  {\r\n    FTerminal->CommandError(&E, LoadStr(UNALIAS_ALL_ERROR));\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::UnsetNationalVars()\r\n{\r\n  try\r\n  {\r\n    FTerminal->LogEvent(L\"Clearing national user variables.\");\r\n    for (int Index = 0; Index < NationalVarCount; Index++)\r\n    {\r\n      ExecCommand(fsUnset, ARRAYOFCONST((NationalVars[Index])), false);\r\n    }\r\n  }\r\n  catch (Exception &E)\r\n  {\r\n    FTerminal->CommandError(&E, LoadStr(UNSET_NATIONAL_ERROR));\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::ReadCurrentDirectory()\r\n{\r\n  if (FCachedDirectoryChange.IsEmpty())\r\n  {\r\n    ExecCommand(fsCurrentDirectory);\r\n    FCurrentDirectory = UnixExcludeTrailingBackslash(FOutput->Strings[0]);\r\n  }\r\n  else\r\n  {\r\n    FCurrentDirectory = FCachedDirectoryChange;\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::HomeDirectory()\r\n{\r\n  ExecCommand(fsHomeDirectory);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::AnnounceFileListOperation()\r\n{\r\n  // noop\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::ChangeDirectory(const UnicodeString Directory)\r\n{\r\n  UnicodeString ToDir;\r\n  if (!Directory.IsEmpty() &&\r\n      ((Directory[1] != L'~') || (Directory.SubString(1, 2) == L\"~ \")))\r\n  {\r\n    ToDir = L\"\\\"\" + DelimitStr(Directory) + L\"\\\"\";\r\n  }\r\n  else\r\n  {\r\n    ToDir = DelimitStr(Directory);\r\n  }\r\n  ExecCommand(fsChangeDirectory, ARRAYOFCONST((ToDir)));\r\n  FCachedDirectoryChange = L\"\";\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::CachedChangeDirectory(const UnicodeString Directory)\r\n{\r\n  FCachedDirectoryChange = UnixExcludeTrailingBackslash(Directory);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::ReadDirectory(TRemoteFileList * FileList)\r\n{\r\n  DebugAssert(FileList);\r\n  // emptying file list moved before command execution\r\n  FileList->Reset();\r\n\r\n  bool Again;\r\n\r\n  do\r\n  {\r\n    Again = false;\r\n    try\r\n    {\r\n      int Params = ecDefault | ecReadProgress |\r\n        FLAGMASK(FTerminal->SessionData->IgnoreLsWarnings, ecIgnoreWarnings);\r\n      const wchar_t * Options =\r\n        ((FLsFullTime == asAuto) || (FLsFullTime == asOn)) ? FullTimeOption : L\"\";\r\n      bool ListCurrentDirectory = (FileList->Directory == FTerminal->CurrentDirectory);\r\n      if (ListCurrentDirectory)\r\n      {\r\n        FTerminal->LogEvent(L\"Listing current directory.\");\r\n        ExecCommand(fsListCurrentDirectory,\r\n          ARRAYOFCONST((FTerminal->SessionData->ListingCommand, Options)), Params);\r\n      }\r\n      else\r\n      {\r\n        FTerminal->LogEvent(FORMAT(L\"Listing directory \\\"%s\\\".\",\r\n          (FileList->Directory)));\r\n        ExecCommand(fsListDirectory,\r\n          ARRAYOFCONST((FTerminal->SessionData->ListingCommand, Options,\r\n            DelimitStr(FileList->Directory))),\r\n          Params);\r\n      }\r\n\r\n      TRemoteFile * File;\r\n\r\n      // If output is not empty, we have successfully got file listing,\r\n      // otherwise there was an error, in case it was \"permission denied\"\r\n      // we try to get at least parent directory (see \"else\" statement below)\r\n      if (FOutput->Count > 0)\r\n      {\r\n        // Copy LS command output, because eventual symlink analysis would\r\n        // modify FTerminal->Output\r\n        TStringList * OutputCopy = new TStringList();\r\n        try\r\n        {\r\n          OutputCopy->Assign(FOutput);\r\n\r\n          // delete leading \"total xxx\" line\r\n          // On some hosts there is not \"total\" but \"totalt\". What's the reason??\r\n          // see mail from \"Jan Wiklund (SysOp)\" <jan@park.se>\r\n          if (IsTotalListingLine(OutputCopy->Strings[0]))\r\n          {\r\n            OutputCopy->Delete(0);\r\n          }\r\n\r\n          for (int Index = 0; Index < OutputCopy->Count; Index++)\r\n          {\r\n            UnicodeString OutputLine = OutputCopy->Strings[Index];\r\n            if (!OutputLine.IsEmpty())\r\n            {\r\n              File = CreateRemoteFile(OutputCopy->Strings[Index]);\r\n              FileList->AddFile(File);\r\n            }\r\n          }\r\n        }\r\n        __finally\r\n        {\r\n          delete OutputCopy;\r\n        }\r\n      }\r\n      else\r\n      {\r\n        bool Empty;\r\n        if (ListCurrentDirectory)\r\n        {\r\n          // Empty file list -> probably \"permission denied\", we\r\n          // at least get link to parent directory (\"..\")\r\n          FTerminal->ReadFile(\r\n            UnixIncludeTrailingBackslash(FTerminal->FFiles->Directory) +\r\n              PARENTDIRECTORY, File);\r\n          Empty = (File == NULL);\r\n          if (!Empty)\r\n          {\r\n            DebugAssert(File->IsParentDirectory);\r\n            FileList->AddFile(File);\r\n          }\r\n        }\r\n        else\r\n        {\r\n          Empty = true;\r\n        }\r\n\r\n        if (Empty)\r\n        {\r\n          throw ExtException(\r\n            NULL, FMTLOAD(EMPTY_DIRECTORY, (FileList->Directory)),\r\n            HELP_EMPTY_DIRECTORY);\r\n        }\r\n      }\r\n\r\n      if (FLsFullTime == asAuto)\r\n      {\r\n          FTerminal->LogEvent(\r\n            FORMAT(L\"Directory listing with %s succeed, next time all errors during \"\r\n              \"directory listing will be displayed immediately.\",\r\n              (FullTimeOption)));\r\n          FLsFullTime = asOn;\r\n      }\r\n    }\r\n    catch(Exception & E)\r\n    {\r\n      if (FTerminal->Active)\r\n      {\r\n        if (FLsFullTime == asAuto)\r\n        {\r\n          FTerminal->Log->AddException(&E);\r\n          FLsFullTime = asOff;\r\n          Again = true;\r\n          FTerminal->LogEvent(\r\n            FORMAT(L\"Directory listing with %s failed, try again regular listing.\",\r\n            (FullTimeOption)));\r\n        }\r\n        else\r\n        {\r\n          throw;\r\n        }\r\n      }\r\n      else\r\n      {\r\n        throw;\r\n      }\r\n    }\r\n  }\r\n  while (Again);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::ReadSymlink(TRemoteFile * SymlinkFile,\r\n  TRemoteFile *& File)\r\n{\r\n  CustomReadFile(SymlinkFile->LinkTo, File, SymlinkFile);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::ReadFile(const UnicodeString FileName,\r\n  TRemoteFile *& File)\r\n{\r\n  CustomReadFile(FileName, File, NULL);\r\n}\r\n//---------------------------------------------------------------------------\r\nTRemoteFile * __fastcall TSCPFileSystem::CreateRemoteFile(\r\n  const UnicodeString & ListingStr, TRemoteFile * LinkedByFile)\r\n{\r\n  TRemoteFile * File = new TRemoteFile(LinkedByFile);\r\n  try\r\n  {\r\n    File->Terminal = FTerminal;\r\n    File->ListingStr = ListingStr;\r\n    File->ShiftTimeInSeconds(TimeToSeconds(FTerminal->SessionData->TimeDifference));\r\n    File->Complete();\r\n  }\r\n  catch(...)\r\n  {\r\n    delete File;\r\n    throw;\r\n  }\r\n\r\n  return File;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::CustomReadFile(const UnicodeString FileName,\r\n  TRemoteFile *& File, TRemoteFile * ALinkedByFile)\r\n{\r\n  File = NULL;\r\n  int Params = ecDefault |\r\n    FLAGMASK(FTerminal->SessionData->IgnoreLsWarnings, ecIgnoreWarnings);\r\n  // the auto-detection of --full-time support is not implemented for fsListFile,\r\n  // so we use it only if we already know that it is supported (asOn).\r\n  const wchar_t * Options = (FLsFullTime == asOn) ? FullTimeOption : L\"\";\r\n  ExecCommand(fsListFile,\r\n    ARRAYOFCONST((FTerminal->SessionData->ListingCommand, Options, DelimitStr(FileName))),\r\n    Params);\r\n  if (FOutput->Count)\r\n  {\r\n    int LineIndex = 0;\r\n    if (IsTotalListingLine(FOutput->Strings[LineIndex]) && FOutput->Count > 1)\r\n    {\r\n      LineIndex++;\r\n    }\r\n\r\n    File = CreateRemoteFile(FOutput->Strings[LineIndex], ALinkedByFile);\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::DeleteFile(const UnicodeString FileName,\r\n  const TRemoteFile * File, int Params, TRmSessionAction & Action)\r\n{\r\n  DebugUsedParam(File);\r\n  DebugUsedParam(Params);\r\n  Action.Recursive();\r\n  DebugAssert(FLAGCLEAR(Params, dfNoRecursive) || (File && File->IsSymLink));\r\n  ExecCommand(fsDeleteFile, ARRAYOFCONST((DelimitStr(FileName))));\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::RenameFile(const UnicodeString FileName, const TRemoteFile * /*File*/,\r\n  const UnicodeString NewName)\r\n{\r\n  ExecCommand(fsRenameFile, ARRAYOFCONST((DelimitStr(FileName), DelimitStr(NewName))));\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::CopyFile(const UnicodeString FileName, const TRemoteFile * /*File*/,\r\n  const UnicodeString NewName)\r\n{\r\n  UnicodeString DelimitedFileName = DelimitStr(FileName);\r\n  UnicodeString DelimitedNewName = DelimitStr(NewName);\r\n  const UnicodeString AdditionalSwitches = L\"-T\";\r\n  try\r\n  {\r\n    ExecCommand(fsCopyFile, ARRAYOFCONST((AdditionalSwitches, DelimitedFileName, DelimitedNewName)));\r\n  }\r\n  catch (Exception & E)\r\n  {\r\n    if (FTerminal->Active)\r\n    {\r\n      // The -T is GNU switch and may not be available on all platforms.\r\n      // https://lists.gnu.org/archive/html/bug-coreutils/2004-07/msg00000.html\r\n      FTerminal->LogEvent(FORMAT(L\"Attempt with %s failed, trying without\", (AdditionalSwitches)));\r\n      ExecCommand(fsCopyFile, ARRAYOFCONST((L\"\", DelimitedFileName, DelimitedNewName)));\r\n    }\r\n    else\r\n    {\r\n      throw;\r\n    }\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::CreateDirectory(const UnicodeString & DirName, bool /*Encrypt*/)\r\n{\r\n  ExecCommand(fsCreateDirectory, ARRAYOFCONST((DelimitStr(DirName))));\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::CreateLink(const UnicodeString FileName,\r\n  const UnicodeString PointTo, bool Symbolic)\r\n{\r\n  ExecCommand(fsCreateLink,\r\n    ARRAYOFCONST((Symbolic ? L\"-s\" : L\"\", DelimitStr(PointTo), DelimitStr(FileName))));\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::ChangeFileToken(const UnicodeString & DelimitedName,\r\n  const TRemoteToken & Token, TFSCommand Cmd, const UnicodeString & RecursiveStr)\r\n{\r\n  UnicodeString Str;\r\n  if (Token.IDValid)\r\n  {\r\n    Str = IntToStr(int(Token.ID));\r\n  }\r\n  else if (Token.NameValid)\r\n  {\r\n    Str = Token.Name;\r\n  }\r\n\r\n  if (!Str.IsEmpty())\r\n  {\r\n    ExecCommand(Cmd, ARRAYOFCONST((RecursiveStr, Str, DelimitedName)));\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::ChangeFileProperties(const UnicodeString FileName,\r\n  const TRemoteFile * File, const TRemoteProperties * Properties,\r\n  TChmodSessionAction & Action)\r\n{\r\n  DebugAssert(Properties);\r\n  bool IsDirectory = File && File->IsDirectory;\r\n  bool Recursive = Properties->Recursive && IsDirectory;\r\n  UnicodeString RecursiveStr = Recursive ? L\"-R\" : L\"\";\r\n\r\n  UnicodeString DelimitedName = DelimitStr(FileName);\r\n  // change group before permissions as chgrp change permissions\r\n  if (Properties->Valid.Contains(vpGroup))\r\n  {\r\n    ChangeFileToken(DelimitedName, Properties->Group, fsChangeGroup, RecursiveStr);\r\n  }\r\n  if (Properties->Valid.Contains(vpOwner))\r\n  {\r\n    ChangeFileToken(DelimitedName, Properties->Owner, fsChangeOwner, RecursiveStr);\r\n  }\r\n  if (Properties->Valid.Contains(vpRights))\r\n  {\r\n    TRights Rights = Properties->Rights;\r\n\r\n    // if we don't set modes recursively, we may add X at once with other\r\n    // options. Otherwise we have to add X after recursive command\r\n    if (!Recursive && IsDirectory && Properties->AddXToDirectories)\r\n      Rights.AddExecute();\r\n\r\n    Action.Rights(Rights);\r\n    if (Recursive)\r\n    {\r\n      Action.Recursive();\r\n    }\r\n\r\n    if ((Rights.NumberSet | Rights.NumberUnset) != TRights::rfNo)\r\n    {\r\n      ExecCommand(fsChangeMode,\r\n        ARRAYOFCONST((RecursiveStr, Rights.SimplestStr, DelimitedName)));\r\n    }\r\n\r\n    // if file is directory and we do recursive mode settings with\r\n    // add-x-to-directories option on, add those X\r\n    if (Recursive && IsDirectory && Properties->AddXToDirectories)\r\n    {\r\n      Rights.AddExecute();\r\n      ExecCommand(fsChangeMode,\r\n        ARRAYOFCONST((L\"\", Rights.SimplestStr, DelimitedName)));\r\n    }\r\n  }\r\n  else\r\n  {\r\n    Action.Cancel();\r\n  }\r\n  DebugAssert(!Properties->Valid.Contains(vpLastAccess));\r\n  DebugAssert(!Properties->Valid.Contains(vpModification));\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TSCPFileSystem::LoadFilesProperties(TStrings * /*FileList*/ )\r\n{\r\n  DebugFail();\r\n  return false;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::CalculateFilesChecksum(const UnicodeString & /*Alg*/,\r\n  TStrings * /*FileList*/, TStrings * /*Checksums*/,\r\n  TCalculatedChecksumEvent /*OnCalculatedChecksum*/)\r\n{\r\n  DebugFail();\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::CustomCommandOnFile(const UnicodeString FileName,\r\n    const TRemoteFile * File, UnicodeString Command, int Params,\r\n    TCaptureOutputEvent OutputEvent)\r\n{\r\n  DebugAssert(File);\r\n  bool Dir = File->IsDirectory && FTerminal->CanRecurseToDirectory(File);\r\n  if (Dir && (Params & ccRecursive))\r\n  {\r\n    TCustomCommandParams AParams;\r\n    AParams.Command = Command;\r\n    AParams.Params = Params;\r\n    AParams.OutputEvent = OutputEvent;\r\n    FTerminal->ProcessDirectory(FileName, FTerminal->CustomCommandOnFile,\r\n      &AParams);\r\n  }\r\n\r\n  if (!Dir || (Params & ccApplyToDirectories))\r\n  {\r\n    TCustomCommandData Data(FTerminal);\r\n    UnicodeString Cmd = TRemoteCustomCommand(\r\n      Data, FTerminal->CurrentDirectory, FileName, L\"\").\r\n      Complete(Command, true);\r\n\r\n    if (!FTerminal->DoOnCustomCommand(Cmd))\r\n    {\r\n      AnyCommand(Cmd, OutputEvent);\r\n    }\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::CaptureOutput(const UnicodeString & AddedLine, TCaptureOutputType OutputType)\r\n{\r\n  int ReturnCode;\r\n  UnicodeString Line = AddedLine;\r\n  // TSecureShell never uses cotExitCode\r\n  DebugAssert((OutputType == cotOutput) || (OutputType == cotError));\r\n  if ((OutputType == cotError) || DebugAlwaysFalse(OutputType == cotExitCode) ||\r\n      !RemoveLastLine(Line, ReturnCode) ||\r\n      !Line.IsEmpty())\r\n  {\r\n    DebugAssert(FOnCaptureOutput != NULL);\r\n    FOnCaptureOutput(Line, OutputType);\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::AnyCommand(const UnicodeString Command,\r\n  TCaptureOutputEvent OutputEvent)\r\n{\r\n  DebugAssert(FSecureShell->OnCaptureOutput == NULL);\r\n  if (OutputEvent != NULL)\r\n  {\r\n    FSecureShell->OnCaptureOutput = CaptureOutput;\r\n    FOnCaptureOutput = OutputEvent;\r\n  }\r\n\r\n  try\r\n  {\r\n    ExecCommand(fsAnyCommand, ARRAYOFCONST((Command)),\r\n      ecDefault | ecIgnoreWarnings);\r\n  }\r\n  __finally\r\n  {\r\n    FOnCaptureOutput = NULL;\r\n    FSecureShell->OnCaptureOutput = NULL;\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nTStrings * __fastcall TSCPFileSystem::GetFixedPaths()\r\n{\r\n  return NULL;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::SpaceAvailable(const UnicodeString Path,\r\n  TSpaceAvailable & /*ASpaceAvailable*/)\r\n{\r\n  DebugFail();\r\n}\r\n//---------------------------------------------------------------------------\r\n// transfer protocol\r\n//---------------------------------------------------------------------------\r\nunsigned int __fastcall TSCPFileSystem::ConfirmOverwrite(\r\n  const UnicodeString & SourceFullFileName, const UnicodeString & TargetFileName, TOperationSide Side,\r\n  const TOverwriteFileParams * FileParams, const TCopyParamType * CopyParam,\r\n  int Params, TFileOperationProgressType * OperationProgress)\r\n{\r\n  TSuspendFileOperationProgress Suspend(OperationProgress);\r\n\r\n  TQueryButtonAlias Aliases[3];\r\n  Aliases[0] = TQueryButtonAlias::CreateAllAsYesToNewerGrouppedWithYes();\r\n  Aliases[1] = TQueryButtonAlias::CreateYesToAllGrouppedWithYes();\r\n  Aliases[2] = TQueryButtonAlias::CreateNoToAllGrouppedWithNo();\r\n  TQueryParams QueryParams(qpNeverAskAgainCheck);\r\n  QueryParams.Aliases = Aliases;\r\n  QueryParams.AliasesCount = LENOF(Aliases);\r\n  unsigned int Answer =\r\n    FTerminal->ConfirmFileOverwrite(\r\n      SourceFullFileName, TargetFileName, FileParams,\r\n      qaYes | qaNo | qaCancel | qaYesToAll | qaNoToAll | qaAll,\r\n      &QueryParams, Side, CopyParam, Params, OperationProgress);\r\n  return Answer;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::SCPResponse(bool * GotLastLine)\r\n{\r\n  // Taken from scp.c response() and modified\r\n\r\n  unsigned char Resp;\r\n  FSecureShell->Receive(&Resp, 1);\r\n\r\n  switch (Resp)\r\n  {\r\n    case 0:     /* ok */\r\n      FTerminal->LogEvent(L\"SCP remote side confirmation (0)\");\r\n      return;\r\n\r\n    default:\r\n    case 1:     /* error */\r\n    case 2:     /* fatal error */\r\n      // pscp adds 'Resp' to 'Msg', why?\r\n      UnicodeString Msg = FSecureShell->ReceiveLine();\r\n      UnicodeString Line = UnicodeString(static_cast<char>(Resp)) + Msg;\r\n      if (IsLastLine(Line))\r\n      {\r\n        if (GotLastLine != NULL)\r\n        {\r\n          *GotLastLine = true;\r\n        }\r\n\r\n        /* TODO 1 : Show stderror to user? */\r\n        FSecureShell->ClearStdError();\r\n\r\n        try\r\n        {\r\n          ReadCommandOutput(coExpectNoOutput | coRaiseExcept | coOnlyReturnCode);\r\n        }\r\n        catch(...)\r\n        {\r\n          // when ReadCommandOutput() fails than remote SCP is terminated already\r\n          if (GotLastLine != NULL)\r\n          {\r\n            *GotLastLine = true;\r\n          }\r\n          throw;\r\n        }\r\n      }\r\n      else if (Resp == 1)\r\n      {\r\n        // While the OpenSSH scp client distinguishes the 1 for error and 2 for fatal errors,\r\n        // the OpenSSH scp server always sends 1 even for fatal errors. Using the error message to tell\r\n        // which errors are fatal and which are not.\r\n        // This error list is valid for OpenSSH 5.3p1 and 7.2p2\r\n        if (SameText(Msg, L\"scp: ambiguous target\") ||\r\n            StartsText(L\"scp: error: unexpected filename: \", Msg) ||\r\n            StartsText(L\"scp: protocol error: \", Msg))\r\n        {\r\n          FTerminal->LogEvent(L\"SCP remote side error (1), fatal error detected from error message\");\r\n          Resp = 2;\r\n          FScpFatalError = true;\r\n        }\r\n        else\r\n        {\r\n          FTerminal->LogEvent(L\"SCP remote side error (1)\");\r\n        }\r\n      }\r\n      else\r\n      {\r\n        FTerminal->LogEvent(L\"SCP remote side fatal error (2)\");\r\n        FScpFatalError = true;\r\n      }\r\n\r\n      if (Resp == 1)\r\n      {\r\n        throw EScpFileSkipped(NULL, Msg);\r\n      }\r\n      else\r\n      {\r\n        throw EScp(NULL, Msg);\r\n      }\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::CopyToRemote(TStrings * FilesToCopy,\r\n  const UnicodeString TargetDir, const TCopyParamType * CopyParam,\r\n  int Params, TFileOperationProgressType * OperationProgress,\r\n  TOnceDoneOperation & OnceDoneOperation)\r\n{\r\n  // scp.c: source(), toremote()\r\n  DebugAssert(FilesToCopy && OperationProgress);\r\n\r\n  Params &= ~(cpAppend | cpResume);\r\n  UnicodeString Options = L\"\";\r\n  bool CheckExistence = UnixSamePath(TargetDir, FTerminal->CurrentDirectory) &&\r\n    (FTerminal->FFiles != NULL) && FTerminal->FFiles->Loaded;\r\n  bool CopyBatchStarted = false;\r\n  bool Failed = true;\r\n  bool GotLastLine = false;\r\n\r\n  UnicodeString TargetDirFull = UnixIncludeTrailingBackslash(TargetDir);\r\n\r\n  if (CopyParam->PreserveRights) Options = L\"-p\";\r\n  if (FTerminal->SessionData->Scp1Compatibility) Options += L\" -1\";\r\n\r\n  FScpFatalError = false;\r\n  SendCommand(FCommandSet->FullCommand(fsCopyToRemote,\r\n    ARRAYOFCONST((Options, DelimitStr(UnixExcludeTrailingBackslash(TargetDir))))));\r\n  SkipFirstLine();\r\n\r\n  try\r\n  {\r\n    try\r\n    {\r\n      SCPResponse(&GotLastLine);\r\n\r\n      // This can happen only if SCP command is not executed and return code is 0\r\n      // It has never happened to me (return code is usually 127)\r\n      if (GotLastLine)\r\n      {\r\n        throw Exception(L\"\");\r\n      }\r\n    }\r\n    catch(Exception & E)\r\n    {\r\n      if (GotLastLine && FTerminal->Active)\r\n      {\r\n        FTerminal->TerminalError(&E, LoadStr(SCP_INIT_ERROR));\r\n      }\r\n      else\r\n      {\r\n        throw;\r\n      }\r\n    }\r\n    CopyBatchStarted = true;\r\n\r\n    for (int IFile = 0; (IFile < FilesToCopy->Count) &&\r\n      !OperationProgress->Cancel; IFile++)\r\n    {\r\n      UnicodeString FileName = FilesToCopy->Strings[IFile];\r\n      bool CanProceed;\r\n\r\n      UnicodeString FileNameOnly =\r\n        FTerminal->ChangeFileName(\r\n          CopyParam, ExtractFileName(FileName), osLocal, true);\r\n\r\n      if (CheckExistence)\r\n      {\r\n        // previously there was assertion on FTerminal->FFiles->Loaded, but it\r\n        // fails for scripting, if 'ls' is not issued before.\r\n        // formally we should call CheckRemoteFile here but as checking is for\r\n        // free here (almost) ...\r\n        TRemoteFile * File = FTerminal->FFiles->FindFile(FileNameOnly);\r\n        if (File != NULL)\r\n        {\r\n          unsigned int Answer;\r\n          if (File->IsDirectory)\r\n          {\r\n            UnicodeString Message = FMTLOAD(DIRECTORY_OVERWRITE, (FileNameOnly));\r\n            TQueryParams QueryParams(qpNeverAskAgainCheck);\r\n\r\n            TSuspendFileOperationProgress Suspend(OperationProgress);\r\n            Answer = FTerminal->ConfirmFileOverwrite(\r\n              FileName, FileNameOnly, NULL,\r\n              qaYes | qaNo | qaCancel | qaYesToAll | qaNoToAll,\r\n              &QueryParams, osRemote, CopyParam, Params, OperationProgress, Message);\r\n          }\r\n          else\r\n          {\r\n            __int64 MTime;\r\n            TOverwriteFileParams FileParams;\r\n            FTerminal->OpenLocalFile(FileName, GENERIC_READ,\r\n              NULL, NULL, NULL, &MTime, NULL,\r\n              &FileParams.SourceSize);\r\n            FileParams.SourceTimestamp = UnixToDateTime(MTime,\r\n              FTerminal->SessionData->DSTMode);\r\n            FileParams.DestSize = File->Size;\r\n            FileParams.DestTimestamp = File->Modification;\r\n\r\n            Answer = ConfirmOverwrite(FileName, FileNameOnly, osRemote,\r\n              &FileParams, CopyParam, Params, OperationProgress);\r\n          }\r\n\r\n          switch (Answer)\r\n          {\r\n            case qaYes:\r\n              CanProceed = true;\r\n              break;\r\n\r\n            case qaCancel:\r\n              OperationProgress->SetCancelAtLeast(csCancel);\r\n            case qaNo:\r\n              CanProceed = false;\r\n              break;\r\n\r\n            default:\r\n              DebugFail();\r\n              break;\r\n          }\r\n        }\r\n        else\r\n        {\r\n          CanProceed = true;\r\n        }\r\n      }\r\n      else\r\n      {\r\n        CanProceed = true;\r\n      }\r\n\r\n      if (CanProceed)\r\n      {\r\n        if (FTerminal->SessionData->CacheDirectories)\r\n        {\r\n          FTerminal->DirectoryModified(TargetDir, false);\r\n\r\n          if (DirectoryExists(ApiPath(FileName)))\r\n          {\r\n            FTerminal->DirectoryModified(UnixIncludeTrailingBackslash(TargetDir)+\r\n              FileNameOnly, true);\r\n          }\r\n        }\r\n\r\n        void * Item = static_cast<void *>(FilesToCopy->Objects[IFile]);\r\n\r\n        try\r\n        {\r\n          SCPSource(FileName, TargetDirFull,\r\n            CopyParam, Params, OperationProgress, 0);\r\n          FTerminal->OperationFinish(OperationProgress, Item, FileName, true, OnceDoneOperation);\r\n        }\r\n        catch (EScpFileSkipped &E)\r\n        {\r\n          TQueryParams Params(qpAllowContinueOnError);\r\n\r\n          TSuspendFileOperationProgress Suspend(OperationProgress);\r\n\r\n          if (FTerminal->QueryUserException(FMTLOAD(COPY_ERROR, (FileName)), &E,\r\n            qaOK | qaAbort, &Params, qtError) == qaAbort)\r\n          {\r\n            OperationProgress->SetCancel(csCancel);\r\n          }\r\n          FTerminal->OperationFinish(OperationProgress, Item, FileName, false, OnceDoneOperation);\r\n          if (!FTerminal->HandleException(&E))\r\n          {\r\n            throw;\r\n          }\r\n        }\r\n        catch (ESkipFile &E)\r\n        {\r\n          FTerminal->OperationFinish(OperationProgress, Item, FileName, false, OnceDoneOperation);\r\n\r\n          {\r\n            TSuspendFileOperationProgress Suspend(OperationProgress);\r\n            // If ESkipFile occurs, just log it and continue with next file\r\n            if (!FTerminal->HandleException(&E))\r\n            {\r\n              throw;\r\n            }\r\n          }\r\n        }\r\n        catch (...)\r\n        {\r\n          FTerminal->OperationFinish(OperationProgress, Item, FileName, false, OnceDoneOperation);\r\n          throw;\r\n        }\r\n      }\r\n    }\r\n    Failed = false;\r\n  }\r\n  __finally\r\n  {\r\n    // Tell remote side, that we're done.\r\n    if (FTerminal->Active)\r\n    {\r\n      try\r\n      {\r\n        if (!GotLastLine)\r\n        {\r\n          if (CopyBatchStarted && !FScpFatalError)\r\n          {\r\n            // What about case, remote side sends fatal error ???\r\n            // (Not sure, if it causes remote side to terminate scp)\r\n            FSecureShell->SendLine(L\"E\");\r\n            SCPResponse();\r\n          }\r\n          /* TODO 1 : Show stderror to user? */\r\n          FSecureShell->ClearStdError();\r\n\r\n          ReadCommandOutput(coExpectNoOutput | coWaitForLastLine | coOnlyReturnCode |\r\n            (Failed ? 0 : coRaiseExcept));\r\n        }\r\n      }\r\n      catch (Exception &E)\r\n      {\r\n        // Only log error message (it should always succeed, but\r\n        // some pending error maybe in queue) }\r\n        FTerminal->Log->AddException(&E);\r\n      }\r\n    }\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::Source(\r\n  TLocalFileHandle & /*Handle*/, const UnicodeString & /*TargetDir*/, UnicodeString & /*DestFileName*/,\r\n  const TCopyParamType * /*CopyParam*/, int /*Params*/,\r\n  TFileOperationProgressType * /*OperationProgress*/, unsigned int /*Flags*/,\r\n  TUploadSessionAction & /*Action*/, bool & /*ChildError*/)\r\n{\r\n  DebugFail();\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::SCPSource(const UnicodeString FileName,\r\n  const UnicodeString TargetDir, const TCopyParamType * CopyParam, int Params,\r\n  TFileOperationProgressType * OperationProgress, int Level)\r\n{\r\n  UnicodeString DestFileName =\r\n    FTerminal->ChangeFileName(\r\n      CopyParam, ExtractFileName(FileName), osLocal, Level == 0);\r\n\r\n  FTerminal->LogEvent(FORMAT(L\"File: \\\"%s\\\"\", (FileName)));\r\n\r\n  OperationProgress->SetFile(FileName, false);\r\n\r\n  if (!FTerminal->AllowLocalFileTransfer(FileName, CopyParam, OperationProgress))\r\n  {\r\n    throw ESkipFile();\r\n  }\r\n\r\n  TLocalFileHandle Handle;\r\n  FTerminal->OpenLocalFile(FileName, GENERIC_READ, Handle);\r\n\r\n  OperationProgress->SetFileInProgress();\r\n\r\n  if (Handle.Directory)\r\n  {\r\n    SCPDirectorySource(FileName, TargetDir, CopyParam, Params, OperationProgress, Level);\r\n  }\r\n  else\r\n  {\r\n    UnicodeString AbsoluteFileName = FTerminal->AbsolutePath(TargetDir + DestFileName, false);\r\n\r\n    DebugAssert(Handle.Handle);\r\n    std::unique_ptr<TStream> Stream(new TSafeHandleStream((THandle)Handle.Handle));\r\n\r\n    // File is regular file (not directory)\r\n    FTerminal->LogEvent(FORMAT(L\"Copying \\\"%s\\\" to remote directory started.\", (FileName)));\r\n\r\n    OperationProgress->SetLocalSize(Handle.Size);\r\n\r\n    // Suppose same data size to transfer as to read\r\n    // (not true with ASCII transfer)\r\n    OperationProgress->SetTransferSize(OperationProgress->LocalSize);\r\n    OperationProgress->SetTransferringFile(false);\r\n\r\n    FTerminal->SelectSourceTransferMode(Handle, CopyParam);\r\n\r\n    TUploadSessionAction Action(FTerminal->ActionLog);\r\n    Action.FileName(ExpandUNCFileName(FileName));\r\n    Action.Destination(AbsoluteFileName);\r\n\r\n    TRights Rights = CopyParam->RemoteFileRights(Handle.Attrs);\r\n\r\n    try\r\n    {\r\n      // During ASCII transfer we will load whole file to this buffer\r\n      // than convert EOL and send it at once, because before converting EOL\r\n      // we can't know its size\r\n      TFileBuffer AsciiBuf;\r\n      bool ConvertToken = false;\r\n      do\r\n      {\r\n        // Buffer for one block of data\r\n        TFileBuffer BlockBuf;\r\n\r\n        // This is crucial, if it fails during file transfer, it's fatal error\r\n        FILE_OPERATION_LOOP_BEGIN\r\n        {\r\n          BlockBuf.LoadStream(Stream.get(), OperationProgress->LocalBlockSize(), true);\r\n        }\r\n        FILE_OPERATION_LOOP_END_EX(\r\n          FMTLOAD(READ_ERROR, (FileName)),\r\n          FLAGMASK(!OperationProgress->TransferringFile, folAllowSkip));\r\n\r\n        OperationProgress->AddLocallyUsed(BlockBuf.Size);\r\n\r\n        // We do ASCII transfer: convert EOL of current block\r\n        // (we don't convert whole buffer, cause it would produce\r\n        // huge memory-transfers while inserting/deleting EOL characters)\r\n        // Than we add current block to file buffer\r\n        if (OperationProgress->AsciiTransfer)\r\n        {\r\n          int ConvertParams =\r\n            FLAGMASK(CopyParam->RemoveCtrlZ, cpRemoveCtrlZ) |\r\n            FLAGMASK(CopyParam->RemoveBOM, cpRemoveBOM);\r\n          BlockBuf.Convert(FTerminal->Configuration->LocalEOLType,\r\n            FTerminal->SessionData->EOLType,\r\n            ConvertParams, ConvertToken);\r\n          BlockBuf.Memory->Seek(0, soFromBeginning);\r\n          AsciiBuf.ReadStream(BlockBuf.Memory, BlockBuf.Size, true);\r\n          // We don't need it any more\r\n          BlockBuf.Memory->Clear();\r\n          // Calculate total size to sent (assume that ratio between\r\n          // size of source and size of EOL-transformed data would remain same)\r\n          // First check if file contains anything (div by zero!)\r\n          if (OperationProgress->LocallyUsed)\r\n          {\r\n            __int64 X = OperationProgress->LocalSize;\r\n            X *= AsciiBuf.Size;\r\n            X /= OperationProgress->LocallyUsed;\r\n            OperationProgress->ChangeTransferSize(X);\r\n          }\r\n            else\r\n          {\r\n            OperationProgress->ChangeTransferSize(0);\r\n          }\r\n        }\r\n\r\n        // We send file information on first pass during BINARY transfer\r\n        // and on last pass during ASCII transfer\r\n        // BINARY: We succeeded reading first buffer from file, hopefully\r\n        // we will be able to read whole, so we send file info to remote side\r\n        // This is done, because when reading fails we can't interrupt sending\r\n        // (don't know how to tell other side that it failed)\r\n        if (!OperationProgress->TransferringFile &&\r\n            (!OperationProgress->AsciiTransfer || OperationProgress->IsLocallyDone()))\r\n        {\r\n          UnicodeString Buf;\r\n\r\n          if (CopyParam->PreserveTime)\r\n          {\r\n            // Send last file access and modification time\r\n            // TVarRec don't understand 'unsigned int' -> we use sprintf()\r\n            Buf.sprintf(L\"T%lu 0 %lu 0\", static_cast<unsigned long>(Handle.MTime),\r\n              static_cast<unsigned long>(Handle.ATime));\r\n            FSecureShell->SendLine(Buf);\r\n            SCPResponse();\r\n          }\r\n\r\n          // Send file modes (rights), filesize and file name\r\n          // TVarRec don't understand 'unsigned int' -> we use sprintf()\r\n          Buf.sprintf(L\"C%s %Ld %s\",\r\n            Rights.Octal.data(),\r\n            (OperationProgress->AsciiTransfer ? (__int64)AsciiBuf.Size :\r\n              OperationProgress->LocalSize),\r\n            DestFileName.data());\r\n          FSecureShell->SendLine(Buf);\r\n          SCPResponse();\r\n          // Indicate we started transferring file, we need to finish it\r\n          // If not, it's fatal error\r\n          OperationProgress->SetTransferringFile(true);\r\n\r\n          // If we're doing ASCII transfer, this is last pass\r\n          // so we send whole file\r\n          /* TODO : We can't send file above 32bit size in ASCII mode! */\r\n          if (OperationProgress->AsciiTransfer)\r\n          {\r\n            FTerminal->LogEvent(FORMAT(L\"Sending ASCII data (%u bytes)\",\r\n              (AsciiBuf.Size)));\r\n            // Should be equal, just in case it's rounded (see above)\r\n            OperationProgress->ChangeTransferSize(AsciiBuf.Size);\r\n            while (!OperationProgress->IsTransferDone())\r\n            {\r\n              unsigned long BlockSize = OperationProgress->TransferBlockSize();\r\n              FSecureShell->Send(\r\n                reinterpret_cast<unsigned char *>(AsciiBuf.Data + (unsigned int)OperationProgress->TransferredSize),\r\n                BlockSize);\r\n              OperationProgress->AddTransferred(BlockSize);\r\n              if (OperationProgress->Cancel == csCancelTransfer)\r\n              {\r\n                throw Exception(MainInstructions(LoadStr(USER_TERMINATED)));\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        // At end of BINARY transfer pass, send current block\r\n        if (!OperationProgress->AsciiTransfer)\r\n        {\r\n          if (!OperationProgress->TransferredSize)\r\n          {\r\n            FTerminal->LogEvent(FORMAT(L\"Sending BINARY data (first block, %u bytes)\",\r\n              (BlockBuf.Size)));\r\n          }\r\n          else if (FTerminal->Configuration->ActualLogProtocol >= 1)\r\n          {\r\n            FTerminal->LogEvent(FORMAT(L\"Sending BINARY data (%u bytes)\",\r\n              (BlockBuf.Size)));\r\n          }\r\n          FSecureShell->Send(reinterpret_cast<const unsigned char *>(BlockBuf.Data), BlockBuf.Size);\r\n          OperationProgress->AddTransferred(BlockBuf.Size);\r\n        }\r\n\r\n        if ((OperationProgress->Cancel == csCancelTransfer) ||\r\n            (OperationProgress->Cancel == csCancel && !OperationProgress->TransferringFile))\r\n        {\r\n          throw Exception(MainInstructions(LoadStr(USER_TERMINATED)));\r\n        }\r\n      }\r\n      while (!OperationProgress->IsLocallyDone() || !OperationProgress->IsTransferDone());\r\n\r\n      FSecureShell->SendNull();\r\n      try\r\n      {\r\n        SCPResponse();\r\n        // If one of two following exceptions occurs, it means, that remote\r\n        // side already know, that file transfer finished, even if it failed\r\n        // so we don't have to throw EFatal\r\n      }\r\n      catch (EScp &E)\r\n      {\r\n        // SCP protocol fatal error\r\n        OperationProgress->SetTransferringFile(false);\r\n        throw;\r\n      }\r\n      catch (EScpFileSkipped &E)\r\n      {\r\n        // SCP protocol non-fatal error\r\n        OperationProgress->SetTransferringFile(false);\r\n        throw;\r\n      }\r\n\r\n      // We succeeded transferring file, from now we can handle exceptions\r\n      // normally -> no fatal error\r\n      OperationProgress->SetTransferringFile(false);\r\n    }\r\n    catch (Exception &E)\r\n    {\r\n      // EScpFileSkipped is derived from ESkipFile,\r\n      // but is does not indicate file skipped by user here\r\n      if (dynamic_cast<EScpFileSkipped *>(&E) != NULL)\r\n      {\r\n        Action.Rollback(&E);\r\n      }\r\n      else\r\n      {\r\n        FTerminal->RollbackAction(Action, OperationProgress, &E);\r\n      }\r\n\r\n      // Every exception during file transfer is fatal\r\n      if (OperationProgress->TransferringFile)\r\n      {\r\n        FTerminal->FatalError(&E, FMTLOAD(COPY_FATAL, (FileName)));\r\n      }\r\n      else\r\n      {\r\n        throw;\r\n      }\r\n    }\r\n\r\n    // With SCP we are not able to distinguish reason for failure\r\n    // (upload itself, touch or chmod).\r\n    // So we always report error with upload action and\r\n    // log touch and chmod actions only if upload succeeds.\r\n    if (CopyParam->PreserveTime)\r\n    {\r\n      TTouchSessionAction(FTerminal->ActionLog, AbsoluteFileName, Handle.Modification);\r\n    }\r\n    if (CopyParam->PreserveRights)\r\n    {\r\n      TChmodSessionAction(FTerminal->ActionLog, AbsoluteFileName,\r\n        Rights);\r\n    }\r\n\r\n    FTerminal->LogFileDone(OperationProgress, AbsoluteFileName);\r\n    // Stream is disposed here\r\n  }\r\n\r\n  Handle.Release();\r\n\r\n  FTerminal->UpdateSource(Handle, CopyParam, Params);\r\n\r\n  FTerminal->LogEvent(FORMAT(L\"Copying \\\"%s\\\" to remote directory finished.\", (FileName)));\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::SCPDirectorySource(const UnicodeString DirectoryName,\r\n  const UnicodeString TargetDir, const TCopyParamType * CopyParam, int Params,\r\n  TFileOperationProgressType * OperationProgress, int Level)\r\n{\r\n  int Attrs;\r\n\r\n  FTerminal->LogEvent(FORMAT(L\"Entering directory \\\"%s\\\".\", (DirectoryName)));\r\n\r\n  OperationProgress->SetFile(DirectoryName);\r\n  UnicodeString DestFileName =\r\n    FTerminal->ChangeFileName(\r\n      CopyParam, ExtractFileName(DirectoryName), osLocal, Level == 0);\r\n\r\n  // Get directory attributes\r\n  FILE_OPERATION_LOOP_BEGIN\r\n  {\r\n    Attrs = FileGetAttrFix(ApiPath(DirectoryName));\r\n    if (Attrs < 0) RaiseLastOSError();\r\n  }\r\n  FILE_OPERATION_LOOP_END(FMTLOAD(CANT_GET_ATTRS, (DirectoryName)));\r\n\r\n  UnicodeString TargetDirFull = UnixIncludeTrailingBackslash(TargetDir + DestFileName);\r\n\r\n  UnicodeString Buf;\r\n\r\n  /* TODO 1: maybe send filetime */\r\n\r\n  // Send directory modes (rights), filesize and file name\r\n  Buf = FORMAT(L\"D%s 0 %s\",\r\n    (CopyParam->RemoteFileRights(Attrs).Octal, DestFileName));\r\n  FSecureShell->SendLine(Buf);\r\n  SCPResponse();\r\n\r\n  try\r\n  {\r\n    TSearchRecOwned SearchRec;\r\n    bool FindOK = FTerminal->LocalFindFirstLoop(IncludeTrailingBackslash(DirectoryName) + L\"*.*\", SearchRec);\r\n\r\n    while (FindOK && !OperationProgress->Cancel)\r\n    {\r\n      UnicodeString FileName = IncludeTrailingBackslash(DirectoryName) + SearchRec.Name;\r\n      try\r\n      {\r\n        if (SearchRec.IsRealFile())\r\n        {\r\n          SCPSource(FileName, TargetDirFull, CopyParam, Params, OperationProgress, Level + 1);\r\n        }\r\n      }\r\n      // Previously we caught ESkipFile, making error being displayed\r\n      // even when file was excluded by mask. Now the ESkipFile is special\r\n      // case without error message.\r\n      catch (EScpFileSkipped &E)\r\n      {\r\n        TQueryParams Params(qpAllowContinueOnError);\r\n        TSuspendFileOperationProgress Suspend(OperationProgress);\r\n\r\n        if (FTerminal->QueryUserException(FMTLOAD(COPY_ERROR, (FileName)), &E,\r\n              qaOK | qaAbort, &Params, qtError) == qaAbort)\r\n        {\r\n          OperationProgress->SetCancel(csCancel);\r\n        }\r\n        if (!FTerminal->HandleException(&E))\r\n        {\r\n          throw;\r\n        }\r\n      }\r\n      catch (ESkipFile &E)\r\n      {\r\n        // If ESkipFile occurs, just log it and continue with next file\r\n        TSuspendFileOperationProgress Suspend(OperationProgress);\r\n        if (!FTerminal->HandleException(&E))\r\n        {\r\n          throw;\r\n        }\r\n      }\r\n\r\n      FindOK = FTerminal->LocalFindNextLoop(SearchRec);\r\n    }\r\n\r\n    SearchRec.Close();\r\n\r\n    /* TODO : Delete also read-only directories. */\r\n    /* TODO : Show error message on failure. */\r\n    if (!OperationProgress->Cancel)\r\n    {\r\n      if (FLAGSET(Params, cpDelete))\r\n      {\r\n        RemoveDir(ApiPath(DirectoryName));\r\n      }\r\n      else if (CopyParam->ClearArchive && FLAGSET(Attrs, faArchive))\r\n      {\r\n        FILE_OPERATION_LOOP_BEGIN\r\n        {\r\n          THROWOSIFFALSE(FileSetAttr(ApiPath(DirectoryName), Attrs & ~faArchive) == 0);\r\n        }\r\n        FILE_OPERATION_LOOP_END(FMTLOAD(CANT_SET_ATTRS, (DirectoryName)));\r\n      }\r\n    }\r\n  }\r\n  __finally\r\n  {\r\n    if (FTerminal->Active)\r\n    {\r\n      // Tell remote side, that we're done.\r\n      FTerminal->LogEvent(FORMAT(L\"Leaving directory \\\"%s\\\".\", (DirectoryName)));\r\n      FSecureShell->SendLine(L\"E\");\r\n      SCPResponse();\r\n    }\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::CopyToLocal(TStrings * FilesToCopy,\r\n  const UnicodeString TargetDir, const TCopyParamType * CopyParam,\r\n  int Params, TFileOperationProgressType * OperationProgress,\r\n  TOnceDoneOperation & OnceDoneOperation)\r\n{\r\n  bool CloseSCP = False;\r\n  Params &= ~(cpAppend | cpResume);\r\n  UnicodeString Options = L\"\";\r\n  if (CopyParam->PreserveRights || CopyParam->PreserveTime) Options = L\"-p\";\r\n  if (FTerminal->SessionData->Scp1Compatibility) Options += L\" -1\";\r\n\r\n  FTerminal->LogEvent(FORMAT(L\"Copying %d files/directories to local directory \"\r\n    \"\\\"%s\\\"\", (FilesToCopy->Count, TargetDir)));\r\n  if (FTerminal->Configuration->ActualLogProtocol >= 0)\r\n  {\r\n    FTerminal->LogEvent(CopyParam->LogStr);\r\n  }\r\n\r\n  try\r\n  {\r\n    for (int IFile = 0; (IFile < FilesToCopy->Count) &&\r\n      !OperationProgress->Cancel; IFile++)\r\n    {\r\n      UnicodeString FileName = FilesToCopy->Strings[IFile];\r\n      TRemoteFile * File = (TRemoteFile *)FilesToCopy->Objects[IFile];\r\n      DebugAssert(File);\r\n\r\n      try\r\n      {\r\n        bool Success = true; // Have to be set to True (see ::SCPSink)\r\n        SendCommand(FCommandSet->FullCommand(fsCopyToLocal,\r\n          ARRAYOFCONST((Options, DelimitStr(FileName)))));\r\n        SkipFirstLine();\r\n\r\n        // Filename is used for error messaging and excluding files only\r\n        // Send in full path to allow path-based excluding\r\n        UnicodeString FullFileName = UnixExcludeTrailingBackslash(File->FullFileName);\r\n        SCPSink(TargetDir, FullFileName, UnixExtractFilePath(FullFileName),\r\n          CopyParam, Success, OperationProgress, Params, 0);\r\n        // operation succeeded (no exception), so it's ok that\r\n        // remote side closed SCP, but we continue with next file\r\n        if (OperationProgress->Cancel == csRemoteAbort)\r\n        {\r\n          OperationProgress->SetCancel(csContinue);\r\n        }\r\n\r\n        // Move operation -> delete file/directory afterwards\r\n        // but only if copying succeeded\r\n        if ((Params & cpDelete) && Success && !OperationProgress->Cancel)\r\n        {\r\n          try\r\n          {\r\n            FTerminal->ExceptionOnFail = true;\r\n            try\r\n            {\r\n              FILE_OPERATION_LOOP_BEGIN\r\n              {\r\n                // pass full file name in FileName, in case we are not moving\r\n                // from current directory\r\n                FTerminal->DeleteFile(FileName, File);\r\n              }\r\n              FILE_OPERATION_LOOP_END(FMTLOAD(DELETE_FILE_ERROR, (FileName)));\r\n            }\r\n            __finally\r\n            {\r\n              FTerminal->ExceptionOnFail = false;\r\n            }\r\n          }\r\n          catch (EFatal &E)\r\n          {\r\n            throw;\r\n          }\r\n          catch (...)\r\n          {\r\n            // If user selects skip (or abort), nothing special actually occurs\r\n            // we just run DoFinished with Success = False, so file won't\r\n            // be deselected in panel (depends on assigned event handler)\r\n\r\n            // On csCancel we would later try to close remote SCP, but it\r\n            // is closed already\r\n            if (OperationProgress->Cancel == csCancel)\r\n            {\r\n              OperationProgress->SetCancel(csRemoteAbort);\r\n            }\r\n            Success = false;\r\n          }\r\n        }\r\n\r\n        FTerminal->OperationFinish(\r\n          OperationProgress, File, FileName, (!OperationProgress->Cancel && Success), OnceDoneOperation);\r\n      }\r\n      catch (...)\r\n      {\r\n        FTerminal->OperationFinish(OperationProgress, File, FileName, false, OnceDoneOperation);\r\n        CloseSCP = (OperationProgress->Cancel != csRemoteAbort);\r\n        throw;\r\n      }\r\n    }\r\n  }\r\n  __finally\r\n  {\r\n    // In case that copying doesn't cause fatal error (ie. connection is\r\n    // still active) but wasn't successful (exception or user termination)\r\n    // we need to ensure, that SCP on remote side is closed\r\n    if (FTerminal->Active && (CloseSCP ||\r\n        (OperationProgress->Cancel == csCancel) ||\r\n        (OperationProgress->Cancel == csCancelTransfer)))\r\n    {\r\n      bool LastLineRead;\r\n\r\n      // If we get LastLine, it means that remote side 'scp' is already\r\n      // terminated, so we need not to terminate it. There is also\r\n      // possibility that remote side waits for confirmation, so it will hang.\r\n      // This should not happen (hope)\r\n      UnicodeString Line = FSecureShell->ReceiveLine();\r\n      LastLineRead = IsLastLine(Line);\r\n      if (!LastLineRead)\r\n      {\r\n        SCPSendError((OperationProgress->Cancel ? L\"Terminated by user.\" : L\"Exception\"), true);\r\n      }\r\n      // Just in case, remote side already sent some more data (it's probable)\r\n      // but we don't want to raise exception (user asked to terminate, it's not error)\r\n      int ECParams = coOnlyReturnCode;\r\n      if (!LastLineRead) ECParams |= coWaitForLastLine;\r\n      ReadCommandOutput(ECParams);\r\n    }\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::Sink(\r\n  const UnicodeString & /*FileName*/, const TRemoteFile * /*File*/,\r\n  const UnicodeString & /*TargetDir*/, UnicodeString & /*DestFileName*/, int /*Attrs*/,\r\n  const TCopyParamType * /*CopyParam*/, int /*Params*/, TFileOperationProgressType * /*OperationProgress*/,\r\n  unsigned int /*Flags*/, TDownloadSessionAction & /*Action*/)\r\n{\r\n  DebugFail();\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::SCPError(const UnicodeString Message, bool Fatal)\r\n{\r\n  SCPSendError(Message, Fatal);\r\n  throw EScpFileSkipped(NULL, Message);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::SCPSendError(const UnicodeString Message, bool Fatal)\r\n{\r\n  unsigned char ErrorLevel = (char)(Fatal ? 2 : 1);\r\n  FTerminal->LogEvent(FORMAT(L\"Sending SCP error (%d) to remote side:\",\r\n    ((int)ErrorLevel)));\r\n  FSecureShell->Send(&ErrorLevel, 1);\r\n  // We don't send exact error message, because some unspecified\r\n  // characters can terminate remote scp\r\n  FSecureShell->SendLine(L\"scp: error\");\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::SCPSink(const UnicodeString TargetDir,\r\n  const UnicodeString FileName, const UnicodeString SourceDir,\r\n  const TCopyParamType * CopyParam, bool & Success,\r\n  TFileOperationProgressType * OperationProgress, int Params,\r\n  int Level)\r\n{\r\n  struct\r\n  {\r\n    int SetTime;\r\n    TDateTime Modification;\r\n    TRights RemoteRights;\r\n    int Attrs;\r\n    bool Exists;\r\n  } FileData;\r\n\r\n  bool SkipConfirmed = false;\r\n  bool Initialized = (Level > 0);\r\n\r\n  FileData.SetTime = 0;\r\n\r\n  FSecureShell->SendNull();\r\n\r\n  while (!OperationProgress->Cancel)\r\n  {\r\n    // See (switch ... case 'T':)\r\n    if (FileData.SetTime) FileData.SetTime--;\r\n\r\n    // In case of error occurred before control record arrived.\r\n    // We can finally use full path here, as we get current path in FileName param\r\n    // (we used to set the file into OperationProgress->FileName, but it collided\r\n    // with progress outputting, particularly for scripting)\r\n    UnicodeString FullFileName = FileName;\r\n\r\n    try\r\n    {\r\n      // Receive control record\r\n      UnicodeString Line = FSecureShell->ReceiveLine();\r\n\r\n      if (Line.Length() == 0) FTerminal->FatalError(NULL, LoadStr(SCP_EMPTY_LINE));\r\n\r\n      if (IsLastLine(Line))\r\n      {\r\n        // Remote side finished copying, so remote SCP was closed\r\n        // and we don't need to terminate it manually, see CopyToLocal()\r\n        OperationProgress->SetCancel(csRemoteAbort);\r\n        /* TODO 1 : Show stderror to user? */\r\n        FSecureShell->ClearStdError();\r\n        try\r\n        {\r\n          // coIgnoreWarnings should allow batch transfer to continue when\r\n          // download of one the files fails (user denies overwriting\r\n          // of target local file, no read permissions...)\r\n          ReadCommandOutput(coExpectNoOutput | coRaiseExcept |\r\n            coOnlyReturnCode | coIgnoreWarnings);\r\n          if (!Initialized)\r\n          {\r\n            throw Exception(L\"\");\r\n          }\r\n        }\r\n        catch(Exception & E)\r\n        {\r\n          if (!Initialized && FTerminal->Active)\r\n          {\r\n            FTerminal->TerminalError(&E, LoadStr(SCP_INIT_ERROR));\r\n          }\r\n          else\r\n          {\r\n            throw;\r\n          }\r\n        }\r\n        return;\r\n      }\r\n      else\r\n      {\r\n        Initialized = true;\r\n\r\n        // First character distinguish type of control record\r\n        wchar_t Ctrl = Line[1];\r\n        Line.Delete(1, 1);\r\n\r\n        switch (Ctrl) {\r\n          case 1:\r\n            // Error (already logged by ReceiveLine())\r\n            throw EScpFileSkipped(NULL, FMTLOAD(REMOTE_ERROR, (Line)));\r\n\r\n          case 2:\r\n            // Fatal error, terminate copying\r\n            FTerminal->TerminalError(Line);\r\n            return; // Unreachable\r\n\r\n          case L'E': // Exit\r\n            FSecureShell->SendNull();\r\n            return;\r\n\r\n          case L'T':\r\n            unsigned long MTime, ATime;\r\n            if (swscanf(Line.c_str(), L\"%ld %*d %ld %*d\",  &MTime, &ATime) == 2)\r\n            {\r\n              FileData.Modification = UnixToDateTime(MTime, FTerminal->SessionData->DSTMode);\r\n              FSecureShell->SendNull();\r\n              // File time is only valid until next pass\r\n              FileData.SetTime = 2;\r\n              continue;\r\n            }\r\n              else\r\n            {\r\n              SCPError(LoadStr(SCP_ILLEGAL_TIME_FORMAT), False);\r\n            }\r\n\r\n          case L'C':\r\n          case L'D':\r\n            break; // continue pass switch{}\r\n\r\n          default:\r\n            FTerminal->FatalError(NULL, FMTLOAD(SCP_INVALID_CONTROL_RECORD, (Ctrl, Line)));\r\n        }\r\n\r\n        TFileMasks::TParams MaskParams;\r\n        MaskParams.Modification = FileData.Modification;\r\n\r\n        // We reach this point only if control record was 'C' or 'D'\r\n        try\r\n        {\r\n          FileData.RemoteRights.Octal = CutToChar(Line, L' ', True);\r\n          // do not trim leading spaces of the filename\r\n          __int64 TSize = StrToInt64(CutToChar(Line, L' ', False).TrimRight());\r\n          MaskParams.Size = TSize;\r\n          // Security fix: ensure the file ends up where we asked for it.\r\n          // (accept only filename, not path)\r\n          UnicodeString OnlyFileName = UnixExtractFileName(Line);\r\n          if (Line != OnlyFileName)\r\n          {\r\n            FTerminal->LogEvent(FORMAT(L\"Warning: Remote host set a compound pathname '%s'\", (Line)));\r\n          }\r\n          if ((Level == 0) && (OnlyFileName != UnixExtractFileName(FileName)))\r\n          {\r\n            SCPError(LoadStr(UNREQUESTED_FILE), False);\r\n          }\r\n\r\n          FullFileName = SourceDir + OnlyFileName;\r\n          OperationProgress->SetFile(FullFileName);\r\n          OperationProgress->SetTransferSize(TSize);\r\n        }\r\n        catch (Exception &E)\r\n        {\r\n          {\r\n            TSuspendFileOperationProgress Suspend(OperationProgress);\r\n            FTerminal->Log->AddException(&E);\r\n          }\r\n          SCPError(LoadStr(SCP_ILLEGAL_FILE_DESCRIPTOR), false);\r\n        }\r\n\r\n        // last possibility to cancel transfer before it starts\r\n        if (OperationProgress->Cancel)\r\n        {\r\n          throw ESkipFile(NULL, MainInstructions(LoadStr(USER_TERMINATED)));\r\n        }\r\n\r\n        bool Dir = (Ctrl == L'D');\r\n        UnicodeString BaseFileName = FTerminal->GetBaseFileName(FullFileName);\r\n        if (!CopyParam->AllowTransfer(BaseFileName, osRemote, Dir, MaskParams, IsUnixHiddenFile(BaseFileName)))\r\n        {\r\n          FTerminal->LogEvent(FORMAT(L\"File \\\"%s\\\" excluded from transfer\",\r\n            (FullFileName)));\r\n          SkipConfirmed = true;\r\n          SCPError(L\"\", false);\r\n        }\r\n\r\n        if (CopyParam->SkipTransfer(FullFileName, Dir))\r\n        {\r\n          SkipConfirmed = true;\r\n          SCPError(L\"\", false);\r\n          OperationProgress->AddSkippedFileSize(MaskParams.Size);\r\n        }\r\n\r\n        FTerminal->LogFileDetails(FileName, FileData.Modification, MaskParams.Size);\r\n\r\n        UnicodeString DestFileNameOnly =\r\n          FTerminal->ChangeFileName(\r\n            CopyParam, OperationProgress->FileName, osRemote,\r\n            Level == 0);\r\n        UnicodeString DestFileName =\r\n          IncludeTrailingBackslash(TargetDir) + DestFileNameOnly;\r\n\r\n        FileData.Attrs = FileGetAttrFix(ApiPath(DestFileName));\r\n        // If getting attrs fails, we suppose, that file/folder doesn't exists\r\n        FileData.Exists = (FileData.Attrs != -1);\r\n        if (Dir)\r\n        {\r\n          if (FileData.Exists && !(FileData.Attrs & faDirectory))\r\n          {\r\n            SCPError(FMTLOAD(NOT_DIRECTORY_ERROR, (DestFileName)), false);\r\n          }\r\n\r\n          if (!FileData.Exists)\r\n          {\r\n            FILE_OPERATION_LOOP_BEGIN\r\n            {\r\n              THROWOSIFFALSE(ForceDirectories(ApiPath(DestFileName)));\r\n            }\r\n            FILE_OPERATION_LOOP_END(FMTLOAD(CREATE_DIR_ERROR, (DestFileName)));\r\n            /* SCP: can we set the timestamp for directories ? */\r\n          }\r\n          UnicodeString FullFileName = SourceDir + OperationProgress->FileName;\r\n          SCPSink(DestFileName, FullFileName, UnixIncludeTrailingBackslash(FullFileName),\r\n            CopyParam, Success, OperationProgress, Params, Level + 1);\r\n          continue;\r\n        }\r\n        else if (Ctrl == L'C')\r\n        {\r\n          TDownloadSessionAction Action(FTerminal->ActionLog);\r\n          Action.FileName(FTerminal->AbsolutePath(FullFileName, true));\r\n\r\n          try\r\n          {\r\n            HANDLE File = NULL;\r\n            TStream * FileStream = NULL;\r\n\r\n            /* TODO 1 : Turn off read-only attr */\r\n\r\n            try\r\n            {\r\n              try\r\n              {\r\n                if (FileExists(ApiPath(DestFileName)))\r\n                {\r\n                  __int64 MTime;\r\n                  TOverwriteFileParams FileParams;\r\n                  FileParams.SourceSize = OperationProgress->TransferSize;\r\n                  FileParams.SourceTimestamp = FileData.Modification;\r\n                  FTerminal->OpenLocalFile(DestFileName, GENERIC_READ,\r\n                    NULL, NULL, NULL, &MTime, NULL,\r\n                    &FileParams.DestSize);\r\n                  FileParams.DestTimestamp = UnixToDateTime(MTime,\r\n                    FTerminal->SessionData->DSTMode);\r\n\r\n                  unsigned int Answer =\r\n                    ConfirmOverwrite(OperationProgress->FileName, DestFileNameOnly, osLocal,\r\n                      &FileParams, CopyParam, Params, OperationProgress);\r\n\r\n                  switch (Answer)\r\n                  {\r\n                    case qaCancel:\r\n                      OperationProgress->SetCancel(csCancel); // continue on next case\r\n                    case qaNo:\r\n                      SkipConfirmed = true;\r\n                      EXCEPTION;\r\n                  }\r\n                }\r\n\r\n                Action.Destination(DestFileName);\r\n\r\n                if (!FTerminal->CreateLocalFile(DestFileName, OperationProgress,\r\n                       &File, FLAGSET(Params, cpNoConfirmation)))\r\n                {\r\n                  SkipConfirmed = true;\r\n                  EXCEPTION;\r\n                }\r\n\r\n                FileStream = new TSafeHandleStream((THandle)File);\r\n              }\r\n              catch (Exception &E)\r\n              {\r\n                // In this step we can still cancel transfer, so we do it\r\n                SCPError(E.Message, false);\r\n                throw;\r\n              }\r\n\r\n              // We succeeded, so we confirm transfer to remote side\r\n              FSecureShell->SendNull();\r\n              // From now we need to finish file transfer, if not it's fatal error\r\n              OperationProgress->SetTransferringFile(true);\r\n\r\n              // Suppose same data size to transfer as to write\r\n              // (not true with ASCII transfer)\r\n              OperationProgress->SetLocalSize(OperationProgress->TransferSize);\r\n\r\n              // Will we use ASCII of BINARY file transfer?\r\n              OperationProgress->SetAsciiTransfer(\r\n                CopyParam->UseAsciiTransfer(BaseFileName, osRemote, MaskParams));\r\n              if (FTerminal->Configuration->ActualLogProtocol >= 0)\r\n              {\r\n                FTerminal->LogEvent(UnicodeString((OperationProgress->AsciiTransfer ? L\"Ascii\" : L\"Binary\")) +\r\n                  L\" transfer mode selected.\");\r\n              }\r\n\r\n              try\r\n              {\r\n                // Buffer for one block of data\r\n                TFileBuffer BlockBuf;\r\n                bool ConvertToken = false;\r\n\r\n                do\r\n                {\r\n                  BlockBuf.Size = OperationProgress->TransferBlockSize();\r\n                  BlockBuf.Position = 0;\r\n\r\n                  FSecureShell->Receive(reinterpret_cast<unsigned char *>(BlockBuf.Data), BlockBuf.Size);\r\n                  OperationProgress->AddTransferred(BlockBuf.Size);\r\n\r\n                  if (OperationProgress->AsciiTransfer)\r\n                  {\r\n                    unsigned int PrevBlockSize = BlockBuf.Size;\r\n                    BlockBuf.Convert(FTerminal->SessionData->EOLType,\r\n                      FTerminal->Configuration->LocalEOLType, 0, ConvertToken);\r\n                    OperationProgress->SetLocalSize(\r\n                      OperationProgress->LocalSize - PrevBlockSize + BlockBuf.Size);\r\n                  }\r\n\r\n                  // This is crucial, if it fails during file transfer, it's fatal error\r\n                  FILE_OPERATION_LOOP_BEGIN\r\n                  {\r\n                    BlockBuf.WriteToStream(FileStream, BlockBuf.Size);\r\n                  }\r\n                  FILE_OPERATION_LOOP_END_EX(FMTLOAD(WRITE_ERROR, (DestFileName)), folNone);\r\n\r\n                  OperationProgress->AddLocallyUsed(BlockBuf.Size);\r\n\r\n                  if (OperationProgress->Cancel == csCancelTransfer)\r\n                  {\r\n                    throw Exception(MainInstructions(LoadStr(USER_TERMINATED)));\r\n                  }\r\n                }\r\n                while (!OperationProgress->IsLocallyDone() || !\r\n                    OperationProgress->IsTransferDone());\r\n              }\r\n              catch (Exception &E)\r\n              {\r\n                // Every exception during file transfer is fatal\r\n                FTerminal->FatalError(&E,\r\n                  FMTLOAD(COPY_FATAL, (OperationProgress->FileName)));\r\n              }\r\n\r\n              OperationProgress->SetTransferringFile(false);\r\n\r\n              try\r\n              {\r\n                SCPResponse();\r\n                // If one of following exception occurs, we still need\r\n                // to send confirmation to other side\r\n              }\r\n              catch (EScp &E)\r\n              {\r\n                FSecureShell->SendNull();\r\n                throw;\r\n              }\r\n              catch (EScpFileSkipped &E)\r\n              {\r\n                FSecureShell->SendNull();\r\n                throw;\r\n              }\r\n\r\n              FSecureShell->SendNull();\r\n\r\n              if (FileData.SetTime && CopyParam->PreserveTime)\r\n              {\r\n                FTerminal->UpdateTargetTime(File, FileData.Modification, FTerminal->SessionData->DSTMode);\r\n              }\r\n            }\r\n            __finally\r\n            {\r\n              if (File) CloseHandle(File);\r\n              if (FileStream) delete FileStream;\r\n            }\r\n          }\r\n          catch(Exception & E)\r\n          {\r\n            if (SkipConfirmed)\r\n            {\r\n              Action.Cancel();\r\n            }\r\n            else\r\n            {\r\n              FTerminal->RollbackAction(Action, OperationProgress, &E);\r\n            }\r\n            throw;\r\n          }\r\n\r\n          if (FileData.Attrs == -1) FileData.Attrs = faArchive;\r\n          int NewAttrs = CopyParam->LocalFileAttrs(FileData.RemoteRights);\r\n          if ((NewAttrs & FileData.Attrs) != NewAttrs)\r\n          {\r\n            FILE_OPERATION_LOOP_BEGIN\r\n            {\r\n              THROWOSIFFALSE(FileSetAttr(ApiPath(DestFileName), FileData.Attrs | NewAttrs) == 0);\r\n            }\r\n            FILE_OPERATION_LOOP_END(FMTLOAD(CANT_SET_ATTRS, (DestFileName)));\r\n          }\r\n\r\n          FTerminal->LogFileDone(OperationProgress, DestFileName);\r\n        }\r\n      }\r\n    }\r\n    catch (EScpFileSkipped &E)\r\n    {\r\n      if (!SkipConfirmed)\r\n      {\r\n        TSuspendFileOperationProgress Suspend(OperationProgress);\r\n        TQueryParams Params(qpAllowContinueOnError);\r\n        if (FTerminal->QueryUserException(FMTLOAD(COPY_ERROR, (FullFileName)),\r\n              &E, qaOK | qaAbort, &Params, qtError) == qaAbort)\r\n        {\r\n          OperationProgress->SetCancel(csCancel);\r\n        }\r\n        FTerminal->Log->AddException(&E);\r\n      }\r\n      // this was inside above condition, but then transfer was considered\r\n      // successful, even when for example user refused to overwrite file\r\n      Success = false;\r\n    }\r\n    catch (ESkipFile &E)\r\n    {\r\n      SCPSendError(E.Message, false);\r\n      Success = false;\r\n      if (!FTerminal->HandleException(&E)) throw;\r\n    }\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::GetSupportedChecksumAlgs(TStrings * /*Algs*/)\r\n{\r\n  // NOOP\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::LockFile(const UnicodeString & /*FileName*/, const TRemoteFile * /*File*/)\r\n{\r\n  DebugFail();\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::UnlockFile(const UnicodeString & /*FileName*/, const TRemoteFile * /*File*/)\r\n{\r\n  DebugFail();\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::UpdateFromMain(TCustomFileSystem * /*MainFileSystem*/)\r\n{\r\n  // noop\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSCPFileSystem::ClearCaches()\r\n{\r\n  // noop\r\n}\r\n", "#ifndef TextsCoreH\r\n#define TextsCoreH\r\n\r\n#define UNKNOWN_KEY4    1\r\n#define DIFFERENT_KEY5  2\r\n#define OLD_KEY         3\r\n\r\n#define SCRIPT_HELP_HELP        4\r\n#define SCRIPT_EXIT_HELP        5\r\n#define SCRIPT_OPEN_HELP10      6\r\n#define SCRIPT_CLOSE_HELP       7\r\n#define SCRIPT_SESSION_HELP     8\r\n#define SCRIPT_PWD_HELP         9\r\n#define SCRIPT_CD_HELP          10\r\n#define SCRIPT_LS_HELP2         11\r\n#define SCRIPT_LPWD_HELP        12\r\n#define SCRIPT_LCD_HELP         13\r\n#define SCRIPT_LLS_HELP2        14\r\n#define SCRIPT_RM_HELP2         15\r\n#define SCRIPT_RMDIR_HELP       16\r\n#define SCRIPT_MV_HELP2         17\r\n#define SCRIPT_CHMOD_HELP2      18\r\n#define SCRIPT_LN_HELP          19\r\n#define SCRIPT_MKDIR_HELP       20\r\n#define SCRIPT_GET_HELP8        21\r\n#define SCRIPT_PUT_HELP8        22\r\n#define SCRIPT_OPTION_HELP7     23\r\n#define SCRIPT_SYNCHRONIZE_HELP7 24\r\n#define SCRIPT_KEEPUPTODATE_HELP5 25\r\n#define SCRIPT_CALL_HELP2       26\r\n#define SCRIPT_ECHO_HELP        27\r\n#define SCRIPT_STAT_HELP        28\r\n#define SCRIPT_CHECKSUM_HELP    29\r\n#define SCRIPT_CP_HELP          30\r\n\r\n#define CORE_ERROR_STRINGS      100\r\n#define KEY_NOT_VERIFIED        101\r\n#define CONNECTION_FAILED       102\r\n#define USER_TERMINATED         103\r\n#define LOST_CONNECTION         104\r\n#define CANT_DETECT_RETURN_CODE 105\r\n#define COMMAND_FAILED          106\r\n#define COMMAND_FAILED_CODEONLY 107\r\n#define INVALID_OUTPUT_ERROR    108\r\n#define READ_CURRENT_DIR_ERROR  109\r\n#define SKIP_STARTUP_MESSAGE_ERROR 110\r\n#define CHANGE_DIR_ERROR        111\r\n#define LIST_DIR_ERROR          113\r\n#define LIST_LINE_ERROR         114\r\n#define RIGHTS_ERROR            115\r\n#define CLEANUP_CONFIG_ERROR    116\r\n#define CLEANUP_HOSTKEYS_ERROR  117\r\n#define CLEANUP_SEEDFILE_ERROR  118\r\n#define CLEANUP_SESSIONS_ERROR  119\r\n#define DETECT_RETURNVAR_ERROR  120\r\n#define LOOKUP_GROUPS_ERROR     121\r\n#define FILE_NOT_EXISTS         122\r\n#define CANT_GET_ATTRS          123\r\n#define OPENFILE_ERROR          124\r\n#define READ_ERROR              125\r\n#define COPY_FATAL              126\r\n#define TOREMOTE_COPY_ERROR     127\r\n#define TOLOCAL_COPY_ERROR      128\r\n#define SCP_EMPTY_LINE          129\r\n#define SCP_ILLEGAL_TIME_FORMAT 130\r\n#define SCP_INVALID_CONTROL_RECORD 131\r\n#define COPY_ERROR              132\r\n#define SCP_ILLEGAL_FILE_DESCRIPTOR 133\r\n#define NOT_DIRECTORY_ERROR     134\r\n#define CREATE_DIR_ERROR        135\r\n#define CREATE_FILE_ERROR       136\r\n#define WRITE_ERROR             137\r\n#define CANT_SET_ATTRS          138\r\n#define REMOTE_ERROR            139\r\n#define DELETE_FILE_ERROR       140\r\n#define LOG_GEN_ERROR           141\r\n#define LOG_OPENERROR           142\r\n#define RENAME_FILE_ERROR       143\r\n#define RENAME_CREATE_FILE_EXISTS 144\r\n#define RENAME_CREATE_DIR_EXISTS 145\r\n#define CHANGE_HOMEDIR_ERROR    146\r\n#define UNALIAS_ALL_ERROR       147\r\n#define UNSET_NATIONAL_ERROR    149\r\n#define FIRST_LINE_EXPECTED     150\r\n#define CLEANUP_INIFILE_ERROR   151\r\n#define AUTHENTICATION_LOG      153\r\n#define AUTHENTICATION_FAILED   154\r\n#define NOT_CONNECTED           155\r\n#define SAVE_KEY_ERROR          156\r\n#define SSH_EXITCODE            158\r\n#define SFTP_INVALID_TYPE       159\r\n#define SFTP_VERSION_NOT_SUPPORTED 160\r\n#define SFTP_MESSAGE_NUMBER     161\r\n#define SFTP_STATUS_OK          162\r\n#define SFTP_STATUS_EOF         163\r\n#define SFTP_STATUS_NO_SUCH_FILE 164\r\n#define SFTP_STATUS_PERMISSION_DENIED 165\r\n#define SFTP_STATUS_FAILURE     166\r\n#define SFTP_STATUS_BAD_MESSAGE 167\r\n#define SFTP_STATUS_NO_CONNECTION 168\r\n#define SFTP_STATUS_CONNECTION_LOST 169\r\n#define SFTP_STATUS_OP_UNSUPPORTED 170\r\n#define SFTP_ERROR_FORMAT3      171\r\n#define SFTP_STATUS_UNKNOWN     172\r\n#define READ_SYMLINK_ERROR      173\r\n#define EMPTY_DIRECTORY         174\r\n#define SFTP_NON_ONE_FXP_NAME_PACKET 175\r\n#define SFTP_REALPATH_ERROR     176\r\n#define CHANGE_PROPERTIES_ERROR 177\r\n#define SFTP_INITIALIZE_ERROR   178\r\n#define TIMEZONE_ERROR          179\r\n#define SFTP_CREATE_FILE_ERROR  180\r\n#define SFTP_OPEN_FILE_ERROR    181\r\n#define SFTP_CLOSE_FILE_ERROR   182\r\n#define NOT_FILE_ERROR          183\r\n#define RENAME_AFTER_RESUME_ERROR 184\r\n#define CREATE_LINK_ERROR       185\r\n#define INVALID_SHELL_COMMAND   186\r\n#define SFTP_SERVER_MESSAGE_UNSUPPORTED 187\r\n#define INVALID_OCTAL_PERMISSIONS 188\r\n#define SFTP_INVALID_EOL        189\r\n#define SFTP_UNKNOWN_FILE_TYPE  190\r\n#define SFTP_STATUS_INVALID_HANDLE 191\r\n#define SFTP_STATUS_NO_SUCH_PATH 192\r\n#define SFTP_STATUS_FILE_ALREADY_EXISTS 193\r\n#define SFTP_STATUS_WRITE_PROTECT 194\r\n#define SFTP_STATUS_NO_MEDIA    195\r\n#define DECODE_UTF_ERROR        196\r\n#define CUSTOM_COMMAND_ERROR    197\r\n#define LOCALE_LOAD_ERROR       198\r\n#define SFTP_INCOMPLETE_BEFORE_EOF 199\r\n#define CALCULATE_SIZE_ERROR    200\r\n#define SFTP_PACKET_TOO_BIG     201\r\n#define SCP_INIT_ERROR          202\r\n#define DUPLICATE_BOOKMARK      203\r\n#define MOVE_FILE_ERROR         204\r\n#define SFTP_PACKET_TOO_BIG_INIT_EXPLAIN 205\r\n#define PRESERVE_TIME_PERM_ERROR3 206\r\n#define ACCESS_VIOLATION_ERROR3 207\r\n#define SFTP_STATUS_NO_SPACE_ON_FILESYSTEM 208\r\n#define SFTP_STATUS_QUOTA_EXCEEDED 209\r\n#define SFTP_STATUS_UNKNOWN_PRINCIPAL 210\r\n#define COPY_FILE_ERROR         211\r\n#define CUSTOM_COMMAND_UNTERMINATED 212\r\n#define CUSTOM_COMMAND_UNKNOWN  213\r\n#define CUSTOM_COMMAND_FILELIST_ERROR 214\r\n#define SCRIPT_COMMAND_UNKNOWN  215\r\n#define SCRIPT_COMMAND_AMBIGUOUS 216\r\n#define SCRIPT_MISSING_PARAMS   217\r\n#define SCRIPT_TOO_MANY_PARAMS  218\r\n#define SCRIPT_NO_SESSION       223\r\n#define SCRIPT_SESSION_INDEX_INVALID 224\r\n#define SCRIPT_OPTION_UNKNOWN   225\r\n#define SCRIPT_VALUE_UNKNOWN    226\r\n#define UNKNOWN_SOCKET_STATUS   227\r\n#define DELETE_ON_RESUME_ERROR  228\r\n#define SFTP_PACKET_ERROR       229\r\n#define ITEM_NAME_INVALID       230\r\n#define SFTP_STATUS_LOCK_CONFLICT 231\r\n#define SFTP_STATUS_DIR_NOT_EMPTY 232\r\n#define SFTP_STATUS_NOT_A_DIRECTORY 233\r\n#define SFTP_STATUS_INVALID_FILENAME 234\r\n#define SFTP_STATUS_LINK_LOOP   235\r\n#define SFTP_STATUS_CANNOT_DELETE 236\r\n#define SFTP_STATUS_INVALID_PARAMETER 237\r\n#define SFTP_STATUS_FILE_IS_A_DIRECTORY 238\r\n#define SFTP_STATUS_BYTE_RANGE_LOCK_CONFLICT 239\r\n#define SFTP_STATUS_BYTE_RANGE_LOCK_REFUSED 240\r\n#define SFTP_STATUS_DELETE_PENDING 241\r\n#define SFTP_STATUS_FILE_CORRUPT 242\r\n#define KEY_TYPE_UNKNOWN2       243\r\n#define KEY_TYPE_UNSUPPORTED2   244\r\n#define KEY_TYPE_DIFFERENT_SSH  245\r\n#define SFTP_OVERWRITE_FILE_ERROR2 246\r\n#define SFTP_OVERWRITE_DELETE_BUTTON 247\r\n#define SPACE_AVAILABLE_ERROR   248\r\n#define TUNNEL_NO_FREE_PORT     249\r\n#define EVENT_SELECT_ERROR      250\r\n#define UNEXPECTED_CLOSE_ERROR  251\r\n#define TUNNEL_ERROR            252\r\n#define CHECKSUM_ERROR          253\r\n#define INTERNAL_ERROR          254\r\n#define NOTSUPPORTED            255\r\n#define FTP_ACCESS_DENIED       256\r\n#define FTP_CREDENTIAL_PROMPT   257\r\n#define FTP_RESPONSE_ERROR      258\r\n#define SCRIPT_UNKNOWN_SWITCH   260\r\n#define TRANSFER_ERROR          261\r\n#define EXECUTE_APP_ERROR       262\r\n#define FILE_NOT_FOUND          263\r\n#define DOCUMENT_WAIT_ERROR     264\r\n#define SPEED_INVALID           265\r\n#define CERT_ERR_CERT_CHAIN_TOO_LONG 266\r\n#define CERT_ERR_CERT_HAS_EXPIRED 267\r\n#define CERT_ERR_CERT_NOT_YET_VALID 268\r\n#define CERT_ERR_CERT_REJECTED  269\r\n#define CERT_ERR_CERT_SIGNATURE_FAILURE 270\r\n#define CERT_ERR_CERT_UNTRUSTED 271\r\n#define CERT_ERR_DEPTH_ZERO_SELF_SIGNED_CERT 272\r\n#define CERT_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD 273\r\n#define CERT_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD 274\r\n#define CERT_ERR_INVALID_CA     275\r\n#define CERT_ERR_INVALID_PURPOSE 276\r\n#define CERT_ERR_KEYUSAGE_NO_CERTSIGN 277\r\n#define CERT_ERR_PATH_LENGTH_EXCEEDED 278\r\n#define CERT_ERR_SELF_SIGNED_CERT_IN_CHAIN 279\r\n#define CERT_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY 280\r\n#define CERT_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE 281\r\n#define CERT_ERR_UNABLE_TO_GET_ISSUER_CERT 282\r\n#define CERT_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY 283\r\n#define CERT_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE 284\r\n#define CERT_ERR_UNKNOWN        285\r\n#define CERT_ERRDEPTH           286\r\n#define MASK_ERROR              288\r\n#define FTP_CANNOT_OPEN_ACTIVE_CONNECTION2 289\r\n#define DELETE_LOCAL_FILE_ERROR 290\r\n#define URL_OPTION_BOOL_VALUE_ERROR 291\r\n#define CANNOT_OPEN_SESSION_FOLDER 293\r\n#define NET_TRANSL_NO_ROUTE2    294\r\n#define NET_TRANSL_CONN_ABORTED 295\r\n#define NET_TRANSL_HOST_NOT_EXIST2 296\r\n#define NET_TRANSL_PACKET_GARBLED 297\r\n#define REPORT_ERROR            298\r\n#define TLS_CERT_DECODE_ERROR   299\r\n#define FIND_FILE_ERROR         700\r\n#define CERT_NAME_MISMATCH      701\r\n#define SCRIPT_MATCH_NO_MATCH   702\r\n#define CERT_ERR_BAD_CHAIN      703\r\n#define CERT_OK                 704\r\n#define REQUEST_REDIRECTED      705\r\n#define TOO_MANY_REDIRECTS      706\r\n#define REDIRECT_LOOP           707\r\n#define INVALID_URL             708\r\n#define PROXY_AUTHENTICATION_FAILED 709\r\n#define CONFIGURED_KEY_NOT_MATCH 710\r\n#define SFTP_STATUS_OWNER_INVALID 711\r\n#define SFTP_STATUS_GROUP_INVALID 712\r\n#define SFTP_STATUS_NO_MATCHING_BYTE_RANGE_LOCK 713\r\n#define KEY_TYPE_UNOPENABLE     714\r\n#define UNKNOWN_CHECKSUM        715\r\n#define ALG_NOT_VERIFIED        716\r\n#define SFTP_STATUS_4           718\r\n#define CERTIFICATE_OPEN_ERROR  719\r\n#define CERTIFICATE_READ_ERROR  720\r\n#define CERTIFICATE_DECODE_ERROR_INFO 721\r\n#define CERTIFICATE_DECODE_ERROR 722\r\n#define CERTIFICATE_PUBLIC_KEY_NOT_FOUND 723\r\n#define LOCK_FILE_ERROR         724\r\n#define UNLOCK_FILE_ERROR       725\r\n#define NOT_LOCKED              726\r\n#define KEY_SAVE_ERROR          727\r\n#define NEON_INIT_FAILED2       728\r\n#define SCRIPT_AMBIGUOUS_SLASH_IN_PATH 729\r\n#define CERT_IP_CANNOT_VERIFY   730\r\n#define HOSTKEY_NOT_CONFIGURED  731\r\n#define UNENCRYPTED_REDIRECT    732\r\n#define HTTP_ERROR2             733\r\n#define FILEZILLA_SITE_MANAGER_NOT_FOUND 734\r\n#define FILEZILLA_NO_SITES      735\r\n#define FILEZILLA_SITE_NOT_EXIST 736\r\n#define SFTP_AS_FTP_ERROR       737\r\n#define LOG_FATAL_ERROR         738\r\n#define SIZE_INVALID            739\r\n#define KNOWN_HOSTS_NOT_FOUND   740\r\n#define KNOWN_HOSTS_NO_SITES    741\r\n#define HOSTKEY_NOT_MATCH_CLIPBOARD 742\r\n#define S3_ERROR_RESOURCE       743\r\n#define S3_ERROR_FURTHER_DETAILS 744\r\n#define S3_ERROR_EXTRA_DETAILS  745\r\n#define S3_STATUS_ACCESS_DENIED 746\r\n#define UNKNOWN_FILE_ENCRYPTION 747\r\n#define INVALID_ENCRYPT_KEY     748\r\n#define UNREQUESTED_FILE        749\r\n\r\n#define CORE_CONFIRMATION_STRINGS 300\r\n#define CONFIRM_PROLONG_TIMEOUT3 301\r\n#define PROMPT_KEY_PASSPHRASE   303\r\n#define FILE_OVERWRITE          304\r\n#define DIRECTORY_OVERWRITE     305\r\n#define ALG_BELOW_TRESHOLD      306\r\n#define CIPHER_TYPE_BOTH2       307\r\n#define CIPHER_TYPE_CS2         308\r\n#define CIPHER_TYPE_SC2         309\r\n#define RESUME_TRANSFER2        310\r\n#define PARTIAL_BIGGER_THAN_SOURCE 311\r\n#define APPEND_OR_RESUME2       312\r\n#define FILE_OVERWRITE_DETAILS  313\r\n#define READ_ONLY_OVERWRITE     314\r\n#define LOCAL_FILE_OVERWRITE2   315\r\n#define REMOTE_FILE_OVERWRITE2  316\r\n#define TIMEOUT_STILL_WAITING3  321\r\n#define RECONNECT_BUTTON        323\r\n#define RENAME_BUTTON           324\r\n#define TUNNEL_SESSION_NAME     327\r\n#define PASSWORD_TITLE          328\r\n#define PASSPHRASE_TITLE        329\r\n#define SERVER_PROMPT_TITLE     330\r\n#define USERNAME_TITLE          331\r\n#define USERNAME_PROMPT2        332\r\n#define SERVER_PROMPT_TITLE2    333\r\n#define NEW_PASSWORD_TITLE      334\r\n#define PROMPT_PROMPT           335\r\n#define TIS_INSTRUCTION         336\r\n#define CRYPTOCARD_INSTRUCTION  337\r\n#define PASSWORD_PROMPT         338\r\n#define KEYBINTER_INSTRUCTION   339\r\n#define NEW_PASSWORD_CURRENT_PROMPT 340\r\n#define NEW_PASSWORD_NEW_PROMPT 341\r\n#define NEW_PASSWORD_CONFIRM_PROMPT 342\r\n#define TUNNEL_INSTRUCTION2     343\r\n#define RENAME_TITLE            344\r\n#define RENAME_PROMPT2          345\r\n#define VERIFY_CERT_PROMPT3     346\r\n#define VERIFY_CERT_CONTACT     347\r\n#define VERIFY_CERT_CONTACT_LIST 348\r\n#define CERT_TEXT               349\r\n#define CERTIFICATE_PASSPHRASE_PROMPT 350\r\n#define CERTIFICATE_PASSPHRASE_TITLE 351\r\n#define KEY_TYPE_CONVERT3       352\r\n#define MULTI_FILES_TO_ONE      353\r\n#define KEY_EXCHANGE_ALG        354\r\n#define KEYKEY_TYPE             355\r\n#define S3_ACCESS_KEY_ID_TITLE  356\r\n#define S3_ACCESS_KEY_ID_PROMPT 357\r\n#define S3_SECRET_ACCESS_KEY_TITLE 358\r\n#define S3_SECRET_ACCESS_KEY_PROMPT 359\r\n#define DUPLICATE_FOLDER_NOT_SUPPORTED 360\r\n#define MISSING_TARGET_BUCKET   361\r\n\r\n#define CORE_INFORMATION_STRINGS 400\r\n#define YES_STR                 401\r\n#define NO_STR                  402\r\n#define SESSION_INFO_TIP2       403\r\n#define VERSION2                404\r\n#define CLOSED_ON_COMPLETION    405\r\n#define SFTP_PROTOCOL_NAME2     406\r\n#define FS_RENAME_NOT_SUPPORTED 407\r\n#define SFTP_NO_EXTENSION_INFO  408\r\n#define SFTP_EXTENSION_INFO     409\r\n#define APPEND_BUTTON           412\r\n#define YES_TO_NEWER_BUTTON     413\r\n#define SCRIPT_HELP_DESC        414\r\n#define SCRIPT_EXIT_DESC        415\r\n#define SCRIPT_OPEN_DESC        416\r\n#define SCRIPT_CLOSE_DESC       417\r\n#define SCRIPT_SESSION_DESC     418\r\n#define SCRIPT_PWD_DESC         419\r\n#define SCRIPT_CD_DESC          420\r\n#define SCRIPT_LS_DESC          421\r\n#define SCRIPT_LPWD_DESC        422\r\n#define SCRIPT_LCD_DESC         423\r\n#define SCRIPT_LLS_DESC         424\r\n#define SCRIPT_RM_DESC          425\r\n#define SCRIPT_RMDIR_DESC       426\r\n#define SCRIPT_MV_DESC          427\r\n#define SCRIPT_CHMOD_DESC       428\r\n#define SCRIPT_LN_DESC          429\r\n#define SCRIPT_MKDIR_DESC       430\r\n#define SCRIPT_GET_DESC         431\r\n#define SCRIPT_PUT_DESC         432\r\n#define SCRIPT_OPTION_DESC      433\r\n#define SCRIPT_SYNCHRONIZE_DESC 434\r\n#define SCRIPT_KEEPUPTODATE_DESC 435\r\n#define SCRIPT_HOST_PROMPT      436\r\n#define SCRIPT_ACTIVE_SESSION   438\r\n#define SCRIPT_SESSION_CLOSED   439\r\n#define SCRIPT_SYNCHRONIZE      440\r\n#define SCRIPT_SYNCHRONIZE_DELETED 441\r\n#define SCRIPT_KEEPING_UP_TO_DATE 442\r\n#define SKIP_ALL_BUTTON         443\r\n#define SCRIPT_CALL_DESC2       444\r\n#define COPY_PARAM_PRESET_ASCII 445\r\n#define COPY_PARAM_PRESET_BINARY 446\r\n#define COPY_INFO_TRANSFER_TYPE2 448\r\n#define COPY_INFO_FILENAME      449\r\n#define COPY_INFO_PERMISSIONS   450\r\n#define COPY_INFO_ADD_X_TO_DIRS 451\r\n#define COPY_INFO_TIMESTAMP     452\r\n#define COPY_INFO_FILE_MASK     454\r\n#define COPY_INFO_CLEAR_ARCHIVE 455\r\n#define COPY_INFO_DONT_REPLACE_INV_CHARS 456\r\n#define COPY_INFO_DONT_PRESERVE_TIME 458\r\n#define COPY_INFO_DONT_CALCULATE_SIZE 459\r\n#define COPY_INFO_DEFAULT       460\r\n#define COPY_RULE_HOSTNAME      461\r\n#define COPY_RULE_USERNAME      462\r\n#define COPY_RULE_REMOTE_DIR    463\r\n#define COPY_RULE_LOCAL_DIR     464\r\n#define SYNCHRONIZE_SCAN        465\r\n#define SYNCHRONIZE_START       466\r\n#define SYNCHRONIZE_CHANGE      467\r\n#define SYNCHRONIZE_UPLOADED    468\r\n#define SYNCHRONIZE_DELETED     469\r\n#define COPY_INFO_NOT_USABLE    470\r\n#define COPY_INFO_IGNORE_PERM_ERRORS 472\r\n#define AUTH_TRANSL_USERNAME    473\r\n#define AUTH_TRANSL_KEYB_INTER  474\r\n#define AUTH_TRANSL_PUBLIC_KEY  475\r\n#define AUTH_TRANSL_WRONG_PASSPHRASE 476\r\n#define AUTH_TRANSL_ACCESS_DENIED 477\r\n#define AUTH_TRANSL_PUBLIC_KEY_AGENT 478\r\n#define AUTH_TRANSL_TRY_PUBLIC_KEY 479\r\n#define AUTH_PASSWORD           480\r\n#define OPEN_TUNNEL             481\r\n#define STATUS_CLOSED           482\r\n#define STATUS_LOOKUPHOST       484\r\n#define STATUS_CONNECT          485\r\n#define STATUS_AUTHENTICATE     486\r\n#define STATUS_AUTHENTICATED    487\r\n#define STATUS_STARTUP          488\r\n#define STATUS_OPEN_DIRECTORY   489\r\n#define STATUS_READY            490\r\n#define USING_TUNNEL            491\r\n#define AUTH_TRANSL_KEY_REFUSED 492\r\n#define PFWD_TRANSL_ADMIN       493\r\n#define PFWD_TRANSL_CONNECT     494\r\n#define NET_TRANSL_REFUSED2     495\r\n#define NET_TRANSL_RESET        496\r\n#define NET_TRANSL_TIMEOUT2     497\r\n#define SESSION_INFO_TIP_NO_SSH 498\r\n#define RESUME_BUTTON           499\r\n#define FTP_NO_FEATURE_INFO     500\r\n#define FTP_FEATURE_INFO        501\r\n#define COPY_INFO_CPS_LIMIT2    502\r\n#define COPY_KEY_BUTTON         503\r\n#define UPDATE_KEY_BUTTON       504\r\n#define ADD_KEY_BUTTON          505\r\n#define COPY_INFO_PRESERVE_READONLY 506\r\n#define SCRIPT_SYNCHRONIZE_COLLECTING 507\r\n#define SCRIPT_SYNCHRONIZE_SYNCHRONIZING 508\r\n#define SCRIPT_SYNCHRONIZE_NODIFFERENCE 509\r\n#define SPEED_UNLIMITED         510\r\n#define FTPS_IMPLICIT           511\r\n#define FTPS_EXPLICIT           513\r\n#define SCRIPT_ECHO_DESC        514\r\n#define SCRIPT_STAT_DESC        515\r\n#define HOSTKEY                 516\r\n#define SCRIPT_FILEMASK_INCLUDE_EXCLUDE 517\r\n#define COPY_PARAM_NEWER_ONLY    518\r\n#define FTP_SUGGESTION          519\r\n#define SCRIPT_CMDLINE_SESSION  520\r\n#define ANY_HOSTKEY      521\r\n#define ANY_CERTIFICATE  522\r\n#define SCRIPT_SYNC_UPLOAD_NEW  523\r\n#define SCRIPT_SYNC_DOWNLOAD_NEW 524\r\n#define SCRIPT_SYNC_UPLOAD_UPDATE 525\r\n#define SCRIPT_SYNC_DOWNLOAD_UPDATE 526\r\n#define SCRIPT_SYNC_DELETE_REMOTE 527\r\n#define SCRIPT_SYNC_DELETE_LOCAL 528\r\n#define SCRIPT_SYNCHRONIZE_CHECKLIST 529\r\n#define COPY_INFO_REMOVE_CTRLZ  530\r\n#define COPY_INFO_REMOVE_BOM    531\r\n#define SCRIPT_NON_DEFAULT_COPY_PARAM 532\r\n#define SCRIPT_NON_DEFAULT_SYNC_PARAM 533\r\n#define VERSION_BUILD           535\r\n#define VERSION_DEV_BUILD       536\r\n#define VERSION_DEBUG_BUILD     537\r\n#define VERSION_DONT_DISTRIBUTE 538\r\n#define WEBDAV_EXTENSION_INFO   539\r\n#define COPY_PARAM_PRESET_EXCLUDE_ALL_DIR 540\r\n#define SCRIPT_CHECKSUM_DESC    541\r\n#define CLIENT_CERTIFICATE_LOADING 543\r\n#define NEED_CLIENT_CERTIFICATE 544\r\n#define LOCKED                  545\r\n#define EXECUTABLE              546\r\n#define SCRIPT_CMDLINE_PARAMETERS 547\r\n#define SCRIPTING_USE_HOSTKEY   548\r\n#define SCRIPT_SITE_WARNING     549\r\n#define CODE_SESSION_OPTIONS    550\r\n#define CODE_CONNECT            551\r\n#define CODE_PS_ADD_TYPE        553\r\n#define COPY_INFO_PRESERVE_TIME_DIRS 554\r\n#define TEXT_FILE_ENCODING      555\r\n#define AND_STR                 556\r\n#define AUTH_CHANGING_PASSWORD  557\r\n#define PASTE_KEY_BUTTON        558\r\n#define SCRIPT_CP_DESC          559\r\n#define TIME_UNKNOWN            560\r\n#define KEY_DETAILS             561\r\n#define COPY_KEY_ACTION         562\r\n#define COPY_CERTIFICATE_ACTION 563\r\n#define COPY_INFO_DONT_ENCRYPT_NEW_FILES 564\r\n#define COPY_INFO_EXCLUDE_HIDDEN_FILES 565\r\n#define COPY_INFO_EXCLUDE_EMPTY_DIRS 566\r\n\r\n#define CORE_VARIABLE_STRINGS   600\r\n#define PUTTY_BASED_ON          601\r\n#define PUTTY_COPYRIGHT         603\r\n#define PUTTY_URL               604\r\n#define FILEZILLA_BASED_ON2     605\r\n#define FILEZILLA_COPYRIGHT2    607\r\n#define FILEZILLA_URL           608\r\n#define OPENSSL_BASED_ON        609\r\n#define OPENSSL_COPYRIGHT2      610\r\n#define OPENSSL_URL             612\r\n#define NEON_BASED_ON2          613\r\n#define NEON_COPYRIGHT          614\r\n#define EXPAT_BASED_ON          616\r\n#define EXPAT_URL               618\r\n#define PUTTY_LICENSE_URL       625\r\n#define MAIN_MSG_TAG            631\r\n#define INTERACTIVE_MSG_TAG     632\r\n#define S3_BASED_ON             633\r\n#define S3_COPYRIGHT            634\r\n#define S3_URL                  635\r\n#define S3_LICENSE_URL          636\r\n\r\n// 7xxx used by errors as secondary sequence\r\n\r\n#endif // TextsCore\r\n", "#include \"TextsCore.h\"\r\n\r\nSTRINGTABLE\r\nBEGIN\r\n  CORE_ERROR_STRINGS, \"CORE_ERROR\"\r\n  KEY_NOT_VERIFIED, \"Host key wasn't verified!\"\r\n  CONNECTION_FAILED, \"Connection failed.\"\r\n  USER_TERMINATED, \"Terminated by user.\"\r\n  LOST_CONNECTION, \"Lost connection.\"\r\n  CANT_DETECT_RETURN_CODE, \"Can't detect command return code.\"\r\n  COMMAND_FAILED, \"Command '%s'\\nfailed with return code %d and error message\\n%s.\"\r\n  COMMAND_FAILED_CODEONLY, \"Command failed with return code %d.\"\r\n  INVALID_OUTPUT_ERROR, \"Command '%s' failed with invalid output '%s'.\"\r\n  READ_CURRENT_DIR_ERROR, \"Error getting name of current remote directory.\"\r\n  SKIP_STARTUP_MESSAGE_ERROR, \"Error skipping startup message. Your shell is probably incompatible with the application (BASH is recommended).\"\r\n  CHANGE_DIR_ERROR, \"Error changing directory to '%s'.\"\r\n  LIST_DIR_ERROR, \"Error listing directory '%s'.\"\r\n  LIST_LINE_ERROR, \"Unexpected directory listing line '%s'.\"\r\n  RIGHTS_ERROR, \"Invalid rights description '%s'\"\r\n  CLEANUP_CONFIG_ERROR, \"Error cleaning up general configuration.\"\r\n  CLEANUP_HOSTKEYS_ERROR, \"Error cleaning up sites.\"\r\n  CLEANUP_SEEDFILE_ERROR, \"Error cleaning up random seed file.\"\r\n  CLEANUP_SESSIONS_ERROR, \"Error cleaning up cached host keys.\"\r\n  DETECT_RETURNVAR_ERROR, \"Error detecting variable containing return code of last command.\"\r\n  LOOKUP_GROUPS_ERROR, \"Error looking up user groups.\"\r\n  FILE_NOT_EXISTS, \"File or folder '%s' does not exist.\"\r\n  CANT_GET_ATTRS, \"Can't get attributes of file '%s'.\"\r\n  OPENFILE_ERROR, \"Can't open file '%s'.\"\r\n  READ_ERROR, \"Error reading file '%s'.\"\r\n  COPY_FATAL, \"Copying file '%s' fatally failed.\"\r\n  TOREMOTE_COPY_ERROR, \"Copying files to remote side failed.\"\r\n  TOLOCAL_COPY_ERROR, \"Copying files from remote side failed.\"\r\n  SCP_EMPTY_LINE, \"SCP protocol error: Unexpected newline\"\r\n  SCP_ILLEGAL_TIME_FORMAT, \"SCP protocol error: Illegal time format\"\r\n  SCP_INVALID_CONTROL_RECORD, \"SCP protocol error: Invalid control record (%s; %s)\"\r\n  COPY_ERROR, \"Copying file '%s' failed.\"\r\n  SCP_ILLEGAL_FILE_DESCRIPTOR, \"SCP protocol error: Illegal file descriptor format\"\r\n  NOT_DIRECTORY_ERROR, \"'%s' is not folder!\"\r\n  CREATE_DIR_ERROR, \"Error creating folder '%s'.\"\r\n  CREATE_FILE_ERROR, \"Can't create file '%s'.\"\r\n  WRITE_ERROR, \"Error writing to file '%s'\"\r\n  CANT_SET_ATTRS, \"Can't set attributes of file '%s'.\"\r\n  REMOTE_ERROR, \"Received error message from remote side: '%s'\"\r\n  DELETE_FILE_ERROR, \"Error deleting file '%s'.\"\r\n  LOG_GEN_ERROR, \"Error occurred during logging. It's been turned off.\"\r\n  LOG_OPENERROR, \"Can't open log file '%s'.\"\r\n  RENAME_FILE_ERROR, \"Error renaming file '%s' to '%s'.\"\r\n  RENAME_CREATE_FILE_EXISTS, \"File with name '%s' already exists.\"\r\n  RENAME_CREATE_DIR_EXISTS, \"Directory with name '%s' already exists.\"\r\n  CHANGE_HOMEDIR_ERROR, \"Error changing directory to home directory.\"\r\n  UNALIAS_ALL_ERROR, \"Error clearing all aliases.\"\r\n  UNSET_NATIONAL_ERROR, \"Error clearing national user variables.\"\r\n  FIRST_LINE_EXPECTED, \"Unexpected input from server: %s\"\r\n  CLEANUP_INIFILE_ERROR, \"Error cleaning up INI file.\"\r\n  AUTHENTICATION_LOG, \"Authentication log (see session log for details):\\n%s\\n\"\r\n  AUTHENTICATION_FAILED, \"Authentication failed.\"\r\n  NOT_CONNECTED, \"Connection has been unexpectedly closed.\"\r\n  SAVE_KEY_ERROR, \"Error saving key to file '%s'.\"\r\n  SSH_EXITCODE, \"Server sent command exit status %d.\"\r\n  SFTP_INVALID_TYPE, \"SFTP protocol violation: Invalid response message type (%d).\"\r\n  SFTP_VERSION_NOT_SUPPORTED, \"Version of SFTP server (%d) is not supported. Supported versions are %d to %d.\"\r\n  SFTP_MESSAGE_NUMBER, \"SFTP protocol violation: Invalid message number %d (expected %d).\"\r\n  SFTP_STATUS_OK, \"Unexpected OK response.\"\r\n  SFTP_STATUS_EOF, \"Unexpected EOF response.\"\r\n  SFTP_STATUS_NO_SUCH_FILE, \"No such file or directory.\"\r\n  SFTP_STATUS_PERMISSION_DENIED, \"Permission denied.\"\r\n  SFTP_STATUS_FAILURE, \"General failure (server should provide error description).\"\r\n  SFTP_STATUS_BAD_MESSAGE, \"Bad message (badly formatted packet or protocol incompatibility).\"\r\n  SFTP_STATUS_NO_CONNECTION, \"No connection.\"\r\n  SFTP_STATUS_CONNECTION_LOST, \"Connection lost.\"\r\n  SFTP_STATUS_OP_UNSUPPORTED, \"The server does not support the operation.\"\r\n  SFTP_ERROR_FORMAT3, \"%s\\nError code: %d\\nError message from server%s: %s\"\r\n  SFTP_STATUS_UNKNOWN, \"Unknown status code.\"\r\n  READ_SYMLINK_ERROR, \"Error reading symbolic link '%s'.\"\r\n  EMPTY_DIRECTORY, \"Server returned empty listing for directory '%s'.\"\r\n  SFTP_NON_ONE_FXP_NAME_PACKET, \"Received SSH_FXP_NAME packet with zero or multiple records.\"\r\n  SFTP_REALPATH_ERROR, \"Cannot get real path for '%s'.\"\r\n  CHANGE_PROPERTIES_ERROR, \"Cannot change properties of file '%s'.\"\r\n  SFTP_INITIALIZE_ERROR, \"Cannot initialize SFTP protocol. Is the host running an SFTP server?\"\r\n  TIMEZONE_ERROR, \"Cannot read time zone information\"\r\n  SFTP_CREATE_FILE_ERROR, \"Cannot create remote file '%s'.\"\r\n  SFTP_OPEN_FILE_ERROR, \"Cannot open remote file '%s'.\"\r\n  SFTP_CLOSE_FILE_ERROR, \"Cannot close remote file '%s'.\"\r\n  NOT_FILE_ERROR, \"'%s' is not file!\"\r\n  RENAME_AFTER_RESUME_ERROR, \"Transfer was successfully finished, but temporary transfer file '%s' could not be renamed to target file name '%s'. If the problem persists, you may try to turn off transfer resume support.\"\r\n  CREATE_LINK_ERROR, \"Cannot create link '%s'.\"\r\n  INVALID_SHELL_COMMAND, \"Invalid command '%s'.\"\r\n  SFTP_SERVER_MESSAGE_UNSUPPORTED, \"None\"\r\n  INVALID_OCTAL_PERMISSIONS, \"'%s' is not valid permission in octal format.\"\r\n  SFTP_INVALID_EOL, \"Server requires unsupported end-of-line sequence (%s).\"\r\n  SFTP_UNKNOWN_FILE_TYPE, \"Unknown file type (%d)\"\r\n  SFTP_STATUS_INVALID_HANDLE, \"Invalid handle.\"\r\n  SFTP_STATUS_NO_SUCH_PATH, \"The file path does not exist or is invalid.\"\r\n  SFTP_STATUS_FILE_ALREADY_EXISTS, \"File already exists.\"\r\n  SFTP_STATUS_WRITE_PROTECT, \"The file is on read-only media, or the media is write protected.\"\r\n  SFTP_STATUS_NO_MEDIA, \"There is no media available in the drive.\"\r\n  DECODE_UTF_ERROR, \"Error decoding UTF-8 string.\"\r\n  CUSTOM_COMMAND_ERROR, \"Error executing custom command '%s' on file '%s'.\"\r\n  LOCALE_LOAD_ERROR, \"Cannot load locale %d.\"\r\n  SFTP_INCOMPLETE_BEFORE_EOF, \"Received incomplete data packet before end of file.\"\r\n  CALCULATE_SIZE_ERROR, \"Error calculating size of directory '%s'.\"\r\n  SFTP_PACKET_TOO_BIG, \"Received too large (%d B) SFTP packet. Max supported packet size is %d B.\"\r\n  SCP_INIT_ERROR, \"Cannot execute SCP to start transfer. Please make sure that SCP is installed on the server and path to it is included in PATH. You may also try SFTP instead of SCP.\"\r\n  DUPLICATE_BOOKMARK, \"Location Profile with name '%s' already exists.\"\r\n  MOVE_FILE_ERROR, \"Error moving file '%s' to '%s'.\"\r\n  SFTP_PACKET_TOO_BIG_INIT_EXPLAIN, \"%s\\n \\nThe error is typically caused by message printed from startup script (like .profile). The message may start with %s.\"\r\n  PRESERVE_TIME_PERM_ERROR3, \"**Upload of file '%s' was successful, but error occurred while setting the permissions and/or timestamp.**\\n\\nIf the problem persists, turn off setting permissions or preserving timestamp. Alternatively you can turn on 'Ignore permission errors' option.\"\r\n  ACCESS_VIOLATION_ERROR3, \"Invalid access to memory.\"\r\n  SFTP_STATUS_NO_SPACE_ON_FILESYSTEM, \"There is insufficient free space on the filesystem.\"\r\n  SFTP_STATUS_QUOTA_EXCEEDED, \"Operation cannot be completed because it would exceed the user's storage quota.\"\r\n  SFTP_STATUS_UNKNOWN_PRINCIPAL, \"Principal (%s) is unknown to the server.\"\r\n  COPY_FILE_ERROR, \"Error copying file '%s' to '%s'.\"\r\n  CUSTOM_COMMAND_UNTERMINATED, \"Unterminated pattern '%s' starting at %d.\"\r\n  CUSTOM_COMMAND_UNKNOWN, \"Unknown pattern '%s' starting at %d.\"\r\n  CUSTOM_COMMAND_FILELIST_ERROR, \"Cannot combine file name pattern (starting at %d) with file list pattern (starting at %d).\"\r\n  SCRIPT_COMMAND_UNKNOWN, \"Unknown command '%s'.\"\r\n  SCRIPT_COMMAND_AMBIGUOUS, \"Ambiguous command '%s'. Possible matches are: %s\"\r\n  SCRIPT_MISSING_PARAMS, \"Missing parameter for command '%s'.\"\r\n  SCRIPT_TOO_MANY_PARAMS, \"Too many parameters for command '%s'.\"\r\n  SCRIPT_NO_SESSION, \"No session.\"\r\n  SCRIPT_SESSION_INDEX_INVALID, \"Invalid session number '%s'.\"\r\n  SCRIPT_OPTION_UNKNOWN, \"Unknown option '%s'.\"\r\n  SCRIPT_VALUE_UNKNOWN, \"Unknown value '%s' of option '%s'.\"\r\n  UNKNOWN_SOCKET_STATUS, \"Cannot determine status of socket (%d).\"\r\n  DELETE_ON_RESUME_ERROR, \"Error deleting file '%s'. After resumable file upload the existing destination file must be deleted. If you do not have permissions to delete file destination file, you need to disable resumable file transfers.\"\r\n  SFTP_PACKET_ERROR, \"Error decoding SFTP packet (%d, %d, %d).\"\r\n  ITEM_NAME_INVALID, \"Invalid name '%s'. Name cannot contain '%s'.\"\r\n  SFTP_STATUS_LOCK_CONFLICT, \"The file could not be opened because it is locked by another process.\"\r\n  SFTP_STATUS_DIR_NOT_EMPTY, \"The directory is not empty.\"\r\n  SFTP_STATUS_NOT_A_DIRECTORY, \"The specified file is not a directory.\"\r\n  SFTP_STATUS_INVALID_FILENAME, \"The filename is not valid.\"\r\n  SFTP_STATUS_LINK_LOOP, \"Too many symbolic links encountered.\"\r\n  SFTP_STATUS_CANNOT_DELETE, \"The file cannot be deleted.\"\r\n  SFTP_STATUS_INVALID_PARAMETER, \"One of the parameters was out of range, or the parameters specified cannot be used together.\"\r\n  SFTP_STATUS_FILE_IS_A_DIRECTORY, \"The specified file was a directory in a context where a directory cannot be used.\"\r\n  SFTP_STATUS_BYTE_RANGE_LOCK_CONFLICT, \"Byte range lock conflict.\"\r\n  SFTP_STATUS_BYTE_RANGE_LOCK_REFUSED, \"Byte range lock refused.\"\r\n  SFTP_STATUS_DELETE_PENDING, \"An operation was attempted on a file for which a delete operation is pending.\"\r\n  SFTP_STATUS_FILE_CORRUPT, \"The file is corrupt; an filesystem integrity check should be run.\"\r\n  KEY_TYPE_UNKNOWN2, \"File '%s' does not contain private key in known format.\"\r\n  KEY_TYPE_UNSUPPORTED2, \"**Private key file '%s' contains key in %s format. WinSCP supports only PuTTY format.**\"\r\n  KEY_TYPE_DIFFERENT_SSH, \"Private key file '%s' contains key in %s format. It does not follow your preferred SSH protocol version.\"\r\n  SFTP_OVERWRITE_FILE_ERROR2, \"Cannot overwrite remote file '%s'.$$\\n \\nPress 'Delete' to delete the file and create new one instead of overwriting it.$$\"\r\n  SFTP_OVERWRITE_DELETE_BUTTON, \"&Delete\"\r\n  SPACE_AVAILABLE_ERROR, \"Error checking space available for path '%s'.\"\r\n  TUNNEL_NO_FREE_PORT, \"Cannot find free local listening port number for tunnel in range %d to %d.\"\r\n  EVENT_SELECT_ERROR, \"Cannot setup network event (error %d).\"\r\n  UNEXPECTED_CLOSE_ERROR, \"Server unexpectedly closed network connection.\"\r\n  TUNNEL_ERROR, \"Error while tunneling the connection.\\n \\n%s\"\r\n  CHECKSUM_ERROR, \"Error calculating checksum for file '%s'.\"\r\n  INTERNAL_ERROR, \"Internal error %s (%s).\"\r\n  NOTSUPPORTED, \"Operation not supported.\"\r\n  FTP_ACCESS_DENIED, \"Access denied.\"\r\n  FTP_CREDENTIAL_PROMPT, \"Prompting for credentials...\"\r\n  FTP_RESPONSE_ERROR, \"Invalid response to %s command '%s'.\"\r\n  SCRIPT_UNKNOWN_SWITCH, \"Unknown switch '%s'.\"\r\n  TRANSFER_ERROR, \"Error transferring file '%s'.\"\r\n  EXECUTE_APP_ERROR, \"Cannot execute '%s'.\"\r\n  FILE_NOT_FOUND, \"File '%s' not found.\"\r\n  DOCUMENT_WAIT_ERROR, \"Error waiting for document to close.\"\r\n  SPEED_INVALID, \"'%s' is not a valid speed limit.\"\r\n  CERT_ERR_DEPTH_ZERO_SELF_SIGNED_CERT, \"Self-signed certificate.\"\r\n  CERT_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD, \"Format error in certificate's valid until field.\"\r\n  CERT_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD, \"Format error in certificate's valid from field.\"\r\n  CERT_ERR_INVALID_CA, \"Invalid CA certificate.\"\r\n  CERT_ERR_INVALID_PURPOSE, \"Unsupported certificate purpose.\"\r\n  CERT_ERR_KEYUSAGE_NO_CERTSIGN, \"Key usage does not include certificate signing.\"\r\n  CERT_ERR_PATH_LENGTH_EXCEEDED, \"Path length constraint exceeded.\"\r\n  CERT_ERR_SELF_SIGNED_CERT_IN_CHAIN, \"Self-signed certificate in certificate chain.\"\r\n  CERT_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY, \"Unable to decode issuer public key.\"\r\n  CERT_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE, \"Unable to decrypt certificate signature.\"\r\n  CERT_ERR_UNABLE_TO_GET_ISSUER_CERT, \"Unable to get issuer certificate.\"\r\n  CERT_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY, \"Unable to get local issuer certificate.\"\r\n  CERT_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE, \"Unable to verify the first certificate.\"\r\n  CERT_ERR_UNKNOWN, \"Unknown certificate verification error.\"\r\n  CERT_ERRDEPTH, \"The error occurred at a depth of %d in the certificate chain.\"\r\n  MASK_ERROR, \"Mask is invalid near '%s'.\"\r\n  FTP_CANNOT_OPEN_ACTIVE_CONNECTION2, \"The server cannot open connection in active mode. If you are behind a NAT router, you may need to specify an external IP address. Alternatively, consider switching to passive mode.\"\r\n  DELETE_LOCAL_FILE_ERROR, \"Error deleting file '%s'.\"\r\n  URL_OPTION_BOOL_VALUE_ERROR, \"Invalid switch value '%s'. Valid values are 'on' and 'off'.\"\r\n  CANNOT_OPEN_SESSION_FOLDER, \"Cannot open site folder or workspace.\"\r\n  NET_TRANSL_NO_ROUTE2, \"Network error: No route to host \\\"%HOST%\\\".\"\r\n  NET_TRANSL_CONN_ABORTED, \"Network error: Software caused connection abort\"\r\n  NET_TRANSL_HOST_NOT_EXIST2, \"Host \\\"%HOST%\\\" does not exist.\"\r\n  NET_TRANSL_PACKET_GARBLED, \"Incoming packet was garbled on decryption\"\r\n  REPORT_ERROR, \"%s\\n\\nPlease help us improving WinSCP by reporting the error on WinSCP support forum.\"\r\n  TLS_CERT_DECODE_ERROR, \"Error decoding TLS/SSL certificate (%s).\"\r\n  FIND_FILE_ERROR, \"Error retrieving file list for \\\"%s\\\".\"\r\n  CERT_NAME_MISMATCH, \"Certificate was not issued for this server. You might be connecting to a server that is pretending to be \\\"%s\\\".\"\r\n  SCRIPT_MATCH_NO_MATCH, \"No file matching '%s' found.\"\r\n  CERT_ERR_BAD_CHAIN, \"Some certificates in certificate chain are invalid.\"\r\n  CERT_OK, \"Certificate is valid.\"\r\n  CERT_ERR_CERT_CHAIN_TOO_LONG, \"Certificate chain too long.\"\r\n  CERT_ERR_CERT_HAS_EXPIRED, \"Certificate has expired.\"\r\n  CERT_ERR_CERT_NOT_YET_VALID, \"Certificate is not yet valid.\"\r\n  CERT_ERR_CERT_REJECTED, \"Certificate rejected.\"\r\n  CERT_ERR_CERT_SIGNATURE_FAILURE, \"Certificate signature failure.\"\r\n  CERT_ERR_CERT_UNTRUSTED, \"Certificate not trusted.\"\r\n  REQUEST_REDIRECTED, \"WebDAV resource moved to '%s'.\"\r\n  TOO_MANY_REDIRECTS, \"Too many redirects.\"\r\n  REDIRECT_LOOP, \"Redirect loop detected.\"\r\n  INVALID_URL, \"Invalid URL \\\"%s\\\".\"\r\n  PROXY_AUTHENTICATION_FAILED, \"Proxy authentication failed.\"\r\n  CONFIGURED_KEY_NOT_MATCH, \"Host key does not match configured key \\\"%s\\\"!\"\r\n  SFTP_STATUS_OWNER_INVALID, \"The name specified can not be assigned as an owner of a file.\"\r\n  SFTP_STATUS_GROUP_INVALID, \"The name specified can not be assigned as the primary group of a file.\"\r\n  SFTP_STATUS_NO_MATCHING_BYTE_RANGE_LOCK, \"The requested operation could not be completed because the specifed byte range lock has not been granted.\"\r\n  KEY_TYPE_UNOPENABLE, \"Private key file '%s' does not exist or cannot be opened.\"\r\n  UNKNOWN_CHECKSUM, \"Checksum algorithm '%s' is not supported.\"\r\n  ALG_NOT_VERIFIED, \"The %s %s was not verified!\"\r\n  SFTP_STATUS_4, \"Common reasons for the Error code 4 are:\\n- Renaming a file to a name of already existing file.\\n- Creating a directory that already exists.\\n- Moving a remote file to a different filesystem (HDD).\\n- Uploading a file to a full filesystem (HDD).\\n- Exceeding a user disk quota.\"\r\n  CERTIFICATE_OPEN_ERROR, \"Cannot open certificate \\\"%s\\\".\"\r\n  CERTIFICATE_READ_ERROR, \"Cannot read certificate \\\"%s\\\".\"\r\n  CERTIFICATE_DECODE_ERROR_INFO, \"Error decoding certificate.\"\r\n  CERTIFICATE_DECODE_ERROR, \"Error decoding certificate \\\"%s\\\".\"\r\n  CERTIFICATE_PUBLIC_KEY_NOT_FOUND, \"Certificate file \\\"%s\\\" does not contain a public key and no corresponding .crt/.cer file was found.\"\r\n  LOCK_FILE_ERROR, \"Error locking file '%s'.\"\r\n  UNLOCK_FILE_ERROR, \"Error unlocking file '%s'.\"\r\n  NOT_LOCKED, \"File '%s' is not locked.\"\r\n  KEY_SAVE_ERROR, \"Error saving key to file \\\"%s\\\".\"\r\n  NEON_INIT_FAILED2, \"Neon HTTP library initialization failed, cannot open session.\"\r\n  SCRIPT_AMBIGUOUS_SLASH_IN_PATH, \"Selecting files using a path ending with slash is ambiguous. Remove the slash to select the folder. Append * mask to select all files in the folder.\"\r\n  CERT_IP_CANNOT_VERIFY, \"When connecting using an IP address, it is not possible to verify if the certificate was issued for the server. Use a hostname instead of the IP address.\"\r\n  HOSTKEY_NOT_CONFIGURED, \"Expected host key was not configured, use -hostkey switch.\"\r\n  UNENCRYPTED_REDIRECT, \"Redirected to an unencrypted URL.\"\r\n  HTTP_ERROR2, \"Received response %d \\\"%s\\\" from %s.\"\r\n  FILEZILLA_SITE_MANAGER_NOT_FOUND, \"FileZilla site manager file not found (%s).\"\r\n  FILEZILLA_NO_SITES, \"No sites found in FileZilla site manager file (%s).\"\r\n  FILEZILLA_SITE_NOT_EXIST, \"FileZilla site \\\"%s\\\" was not found.\"\r\n  SFTP_AS_FTP_ERROR, \"You cannot connect to an SFTP server using an FTP protocol. Please select the correct protocol.\"\r\n  LOG_FATAL_ERROR, \"Error occurred during logging. Cannot continue.\"\r\n  SIZE_INVALID, \"'%s' is not a valid size.\"\r\n  KNOWN_HOSTS_NOT_FOUND, \"OpenSSH known_hosts file not found.\"\r\n  KNOWN_HOSTS_NO_SITES, \"No host keys found in known_hosts.\"\r\n  HOSTKEY_NOT_MATCH_CLIPBOARD, \"Contents of the clipboard does not match the host key nor its fingerprint.\"\r\n  S3_ERROR_RESOURCE, \"Resource: %s\"\r\n  S3_ERROR_FURTHER_DETAILS, \"Further details: %s\"\r\n  S3_ERROR_EXTRA_DETAILS, \"Extra Details: \"\r\n  S3_STATUS_ACCESS_DENIED, \"Access denied.\"\r\n  DUPLICATE_FOLDER_NOT_SUPPORTED, \"Direct duplication of folders is not supported. Use a duplication via a local temporary copy.\"\r\n  MISSING_TARGET_BUCKET, \"Specify target bucket.\"\r\n  UNKNOWN_FILE_ENCRYPTION, \"File is not encrypted using a known encryption.\"\r\n  INVALID_ENCRYPT_KEY, \"**Invalid encryption key.**\\n\\nEncryption key for %s encryption must have %d bytes. It must be entered in hexadecimal representation (i.e. %d characters).\"\r\n  UNREQUESTED_FILE, \"Server sent a file that was not requested.\"\r\n\r\n  CORE_CONFIRMATION_STRINGS, \"CORE_CONFIRMATION\"\r\n  CONFIRM_PROLONG_TIMEOUT3, \"Host is not communicating for %d seconds.\\n\\nWait for another %0:d seconds?\"\r\n  PROMPT_KEY_PASSPHRASE, \"&Passphrase for key '%s':\"\r\n  FILE_OVERWRITE, \"File '%s' already exists. Overwrite?\"\r\n  DIRECTORY_OVERWRITE, \"Directory '%s' already exists. Overwrite?\"\r\n  ALG_BELOW_TRESHOLD, \"The first %s supported by the server is %s, which is below the configured warning threshold.\\n\\nDo you want to continue with this connection?\"\r\n  CIPHER_TYPE_BOTH2, \"cipher\"\r\n  CIPHER_TYPE_CS2, \"client-to-server cipher\"\r\n  CIPHER_TYPE_SC2, \"server-to-client cipher\"\r\n  RESUME_TRANSFER2, \"**Do you want to resume file transfer?**\\n\\nTarget directory contains partially transferred file '%s'.\\n\\nNote: Answering 'No' would delete partially transferred file and restart transfer.\"\r\n  PARTIAL_BIGGER_THAN_SOURCE, \"Target directory contains partially transferred file '%s', which is bigger than a source file. The file will be deleted.\"\r\n  APPEND_OR_RESUME2, \"**Do you want to append file '%s' at the end of existing file?**\\n\\nPress 'No' to resume file transfer instead.\"\r\n  FILE_OVERWRITE_DETAILS, \"%s\\n \\nNew:      \\t%s bytes, %s\\nExisting: \\t%s bytes, %s\"\r\n  READ_ONLY_OVERWRITE, \"File '%s' is read-only. Overwrite?\"\r\n  LOCAL_FILE_OVERWRITE2, \"**Overwrite local file '%s'?**\\n\\nDestination directory already contains file '%s'.\\nChoose, if you want to overwrite the file or skip this transfer and keep existing file.\"\r\n  REMOTE_FILE_OVERWRITE2, \"**Overwrite remote file '%s'?**\\n\\nDestination directory already contains file '%s'.\\nChoose, if you want to overwrite the file or skip this transfer and keep existing file.\"\r\n  TIMEOUT_STILL_WAITING3, \"Host is not communicating for more than %d seconds.\\nStill waiting...\\n\\nNote: If the problem repeats, try turning off 'Optimize connection buffer size'.\"\r\n  RECONNECT_BUTTON, \"&Reconnect\"\r\n  RENAME_BUTTON, \"New na&me\"\r\n  TUNNEL_SESSION_NAME, \"Tunnel for %s\"\r\n  PASSWORD_TITLE, \"Password\"\r\n  PASSPHRASE_TITLE, \"Key passphrase\"\r\n  SERVER_PROMPT_TITLE, \"Server prompt\"\r\n  USERNAME_TITLE, \"Username\"\r\n  USERNAME_PROMPT2, \"&Username:\"\r\n  SERVER_PROMPT_TITLE2, \"Server prompt: %s\"\r\n  NEW_PASSWORD_TITLE, \"New password\"\r\n  PROMPT_PROMPT, \"&Response:\"\r\n  TIS_INSTRUCTION, \"Using TIS authentication.%s\"\r\n  CRYPTOCARD_INSTRUCTION, \"Using CryptoCard authentication.%s\"\r\n  PASSWORD_PROMPT, \"&Password: \"\r\n  KEYBINTER_INSTRUCTION, \"Using keyboard-interactive authentication.%s\"\r\n  NEW_PASSWORD_CURRENT_PROMPT, \"&Current password:\"\r\n  NEW_PASSWORD_NEW_PROMPT, \"&New password:\"\r\n  NEW_PASSWORD_CONFIRM_PROMPT, \"Confirm new &password:\"\r\n  TUNNEL_INSTRUCTION2, \"Authenticating tunnel through %s\"\r\n  RENAME_TITLE, \"Transfer under different name\"\r\n  RENAME_PROMPT2, \"&New name:\"\r\n  VERIFY_CERT_PROMPT3, \"**The server's certificate is not known. You have no guarantee that the server is the computer you think it is.**\\n\\nServer's certificate details follow:\\n\\n%s\\n\\nIf you trust this certificate, press Yes. To connect without storing certificate, press No. To abandon the connection press Cancel.\\n\\nContinue connecting and store the certificate?\"\r\n  VERIFY_CERT_CONTACT, \"- Organization: %s\\n|- Location: %s\\n|- Other: %s\\n\"\r\n  VERIFY_CERT_CONTACT_LIST, \"%s, %s\"\r\n  CERT_TEXT, \"Issuer:\\n%s\\nSubject:\\n%s\\nValid: %s - %s\\n\\nFingerprint (SHA-1): %s\\n\\nSummary: %s\"\r\n  CERTIFICATE_PASSPHRASE_PROMPT, \"&Passphrase for client certificate:\"\r\n  CERTIFICATE_PASSPHRASE_TITLE, \"Client certificate passphrase\"\r\n  KEY_TYPE_CONVERT3, \"**Do you want to convert this %s private key to PuTTY format?**\\n\\n%s\"\r\n  MULTI_FILES_TO_ONE, \"**Are you sure you want to transfer multiple files to a single file '%s' in a directory '%s'?**\\n\\nThe files will overwrite one another.\\n\\nIf you actually want to transfer all files to a directory '%s', keeping their name, make sure you terminate the path with a slash.\"\r\n  KEY_EXCHANGE_ALG, \"key-exchange algorithm\"\r\n  KEYKEY_TYPE, \"host key type\"\r\n  S3_ACCESS_KEY_ID_TITLE, \"Access key ID\"\r\n  S3_ACCESS_KEY_ID_PROMPT, \"A&ccess key ID:\"\r\n  S3_SECRET_ACCESS_KEY_TITLE, \"Secret access key\"\r\n  S3_SECRET_ACCESS_KEY_PROMPT, \"Secret access &key:\"\r\n\r\n  CORE_INFORMATION_STRINGS, \"CORE_INFORMATION\"\r\n  YES_STR, \"Yes\"\r\n  NO_STR, \"No\"\r\n  SESSION_INFO_TIP2, \"Host: %s\\nUser name: %s\\nPrivate key file: %s\\nTransfer protocol: %s\"\r\n  VERSION2, \"Version %s (%s)\"\r\n  CLOSED_ON_COMPLETION, \"Operation was successfully completed. Connection was closed.\"\r\n  SFTP_PROTOCOL_NAME2, \"SFTP-%d\"\r\n  FS_RENAME_NOT_SUPPORTED, \"The version of SFTP protocol does not allow file renaming.\"\r\n  SFTP_NO_EXTENSION_INFO, \"The server does not support any SFTP extension.\"\r\n  SFTP_EXTENSION_INFO, \"The server supports these SFTP extensions:\"\r\n  APPEND_BUTTON, \"A&ppend\"\r\n  YES_TO_NEWER_BUTTON, \"Ne&wer only\"\r\n  SCRIPT_HELP_DESC, \"Displays help\"\r\n  SCRIPT_EXIT_DESC, \"Closes all sessions and terminates the program\"\r\n  SCRIPT_OPEN_DESC, \"Connects to server\"\r\n  SCRIPT_CLOSE_DESC, \"Closes session\"\r\n  SCRIPT_SESSION_DESC, \"Lists connected sessions or selects active session\"\r\n  SCRIPT_PWD_DESC, \"Prints remote working directory\"\r\n  SCRIPT_CD_DESC, \"Changes remote working directory\"\r\n  SCRIPT_LS_DESC, \"Lists the contents of remote directory\"\r\n  SCRIPT_LPWD_DESC, \"Prints local working directory\"\r\n  SCRIPT_LCD_DESC, \"Changes local working directory\"\r\n  SCRIPT_LLS_DESC, \"Lists the contents of local directory\"\r\n  SCRIPT_RM_DESC, \"Removes remote file\"\r\n  SCRIPT_RMDIR_DESC, \"Removes remote directory\"\r\n  SCRIPT_MV_DESC, \"Moves or renames remote file\"\r\n  SCRIPT_CHMOD_DESC, \"Changes permissions of remote file\"\r\n  SCRIPT_LN_DESC, \"Creates remote symbolic link\"\r\n  SCRIPT_MKDIR_DESC, \"Creates remote directory\"\r\n  SCRIPT_GET_DESC, \"Downloads file from remote directory to local directory\"\r\n  SCRIPT_PUT_DESC, \"Uploads file from local directory to remote directory\"\r\n  SCRIPT_OPTION_DESC, \"Sets or shows value of script options\"\r\n  SCRIPT_SYNCHRONIZE_DESC, \"Synchronizes remote directory with local one\"\r\n  SCRIPT_KEEPUPTODATE_DESC, \"Continuously reflects changes in local directory on remote one\"\r\n  SCRIPT_HOST_PROMPT, \"Host: \"\r\n  SCRIPT_ACTIVE_SESSION, \"Active session: [%d] %s\"\r\n  SCRIPT_SESSION_CLOSED, \"Session '%s' closed.\"\r\n  SCRIPT_SYNCHRONIZE, \"Local '%s' %s Remote '%s'\"\r\n  SCRIPT_SYNCHRONIZE_DELETED, \"'%s' deleted\"\r\n  SCRIPT_KEEPING_UP_TO_DATE, \"Watching for changes, press Ctrl-C to abort...\"\r\n  SKIP_ALL_BUTTON, \"Ski&p all\"\r\n  SCRIPT_CALL_DESC2, \"Executes arbitrary remote command\"\r\n  COPY_PARAM_PRESET_ASCII, \"&Text\"\r\n  COPY_PARAM_PRESET_BINARY, \"&Binary\"\r\n  COPY_INFO_TRANSFER_TYPE2, \"Transfer type: %s|Binary|Text|Automatic (%s)|Automatic\"\r\n  COPY_INFO_FILENAME, \"Filename modification: %s|No change|Upper case|Lower case|First upper case|Lower case 8.3\"\r\n  COPY_INFO_PERMISSIONS, \"Set permissions: %s\"\r\n  COPY_INFO_ADD_X_TO_DIRS, \"Add X to directories\"\r\n  COPY_INFO_TIMESTAMP, \"Preserve timestamp\"\r\n  COPY_INFO_FILE_MASK, \"File mask: %s\"\r\n  COPY_INFO_CLEAR_ARCHIVE, \"Clear 'Archive' attribute\"\r\n  COPY_INFO_DONT_REPLACE_INV_CHARS, \"Do not replace invalid characters\"\r\n  COPY_INFO_DONT_PRESERVE_TIME, \"Do not preserve timestamp\"\r\n  COPY_INFO_DONT_CALCULATE_SIZE, \"Do not calculate transfer size\"\r\n  COPY_INFO_DEFAULT, \"Default transfer settings\"\r\n  COPY_RULE_HOSTNAME, \"Hostname: %s\"\r\n  COPY_RULE_USERNAME, \"Username: %s\"\r\n  COPY_RULE_REMOTE_DIR, \"Remote directory: %s\"\r\n  COPY_RULE_LOCAL_DIR, \"Local directory: %s\"\r\n  SYNCHRONIZE_SCAN, \"Scanning '%s' for subdirectories...\"\r\n  SYNCHRONIZE_START, \"Watching for changes in %d directories...\"\r\n  SYNCHRONIZE_CHANGE, \"Change in '%s' detected.\"\r\n  SYNCHRONIZE_UPLOADED, \"File '%s' uploaded.\"\r\n  SYNCHRONIZE_DELETED, \"File '%s' deleted.\"\r\n  COPY_INFO_NOT_USABLE, \"%s configured transfer settings cannot be used in current context|Some|All\"\r\n  COPY_INFO_IGNORE_PERM_ERRORS, \"Ignore permission errors\"\r\n  AUTH_TRANSL_USERNAME, \"Using username \\\"%s\\\".\"\r\n  AUTH_TRANSL_KEYB_INTER, \"Using keyboard-interactive authentication.\"\r\n  AUTH_TRANSL_PUBLIC_KEY, \"Authenticating with public key \\\"%s\\\".\"\r\n  AUTH_TRANSL_WRONG_PASSPHRASE, \"Wrong passphrase.\"\r\n  AUTH_TRANSL_ACCESS_DENIED, \"Access denied.\"\r\n  AUTH_TRANSL_PUBLIC_KEY_AGENT, \"Authenticating with public key \\\"%s\\\" from agent.\"\r\n  AUTH_TRANSL_TRY_PUBLIC_KEY, \"Trying public key authentication.\"\r\n  AUTH_PASSWORD, \"Authenticating with pre-entered password.\"\r\n  OPEN_TUNNEL, \"Opening tunnel...\"\r\n  STATUS_CLOSED, \"Connection terminated.\"\r\n  STATUS_LOOKUPHOST, \"Searching for host...\"\r\n  STATUS_CONNECT, \"Connecting to host...\"\r\n  STATUS_AUTHENTICATE, \"Authenticating...\"\r\n  STATUS_AUTHENTICATED, \"Authenticated.\"\r\n  STATUS_STARTUP, \"Starting the session...\"\r\n  STATUS_READY, \"Session started.\"\r\n  STATUS_OPEN_DIRECTORY, \"Reading remote directory...\"\r\n  USING_TUNNEL, \"Connecting through tunnel...\"\r\n  AUTH_TRANSL_KEY_REFUSED, \"Server refused our key.\"\r\n  PFWD_TRANSL_ADMIN, \"Administratively prohibited (%s).\"\r\n  PFWD_TRANSL_CONNECT, \"Connect failed (%s).\"\r\n  NET_TRANSL_REFUSED2, \"Network error: Connection to \\\"%HOST%\\\" refused.\"\r\n  NET_TRANSL_RESET, \"Network error: Connection reset by peer.\"\r\n  NET_TRANSL_TIMEOUT2, \"Network error: Connection to \\\"%HOST%\\\" timed out.\"\r\n  SESSION_INFO_TIP_NO_SSH, \"Host: %s\\nUser name: %s\\nTransfer protocol: %s\"\r\n  RESUME_BUTTON, \"&Resume\"\r\n  FTP_NO_FEATURE_INFO, \"The server does not support any additional FTP feature.\"\r\n  FTP_FEATURE_INFO, \"The server supports these FTP additional features:\"\r\n  COPY_INFO_CPS_LIMIT2, \"Transfer speed limit: %u KB/s\"\r\n  COPY_KEY_BUTTON, \"&Copy Key\"\r\n  UPDATE_KEY_BUTTON, \"&Update\"\r\n  ADD_KEY_BUTTON, \"&Add\"\r\n  COPY_INFO_PRESERVE_READONLY, \"Preserve read-only\"\r\n  SCRIPT_SYNCHRONIZE_COLLECTING, \"Comparing...\"\r\n  SCRIPT_SYNCHRONIZE_SYNCHRONIZING, \"Synchronizing...\"\r\n  SCRIPT_SYNCHRONIZE_NODIFFERENCE, \"Nothing to synchronize.\"\r\n  SPEED_UNLIMITED, \"Unlimited\"\r\n  FTPS_IMPLICIT, \"TLS/SSL Implicit encryption\"\r\n  FTPS_EXPLICIT, \"TLS/SSL Explicit encryption\"\r\n  SCRIPT_ECHO_DESC, \"Displays its arguments as message\"\r\n  SCRIPT_STAT_DESC, \"Retrieves attributes of remote file\"\r\n  HOSTKEY, \"Host key fingerprint is %s.\"\r\n  SCRIPT_FILEMASK_INCLUDE_EXCLUDE, \"Switch -filemask overrides obsolete options include/exclude.\"\r\n  COPY_PARAM_NEWER_ONLY, \"&New and updated files only\"\r\n  FTP_SUGGESTION, \"The server rejected SFTP connection, but it listens for FTP connections.\\n\\nDid you want to use FTP protocol instead of SFTP? Prefer using encryption.\"\r\n  SCRIPT_CMDLINE_SESSION, \"Opening session using command-line parameter in scripting is deprecated. Use 'open' command instead.\"\r\n  ANY_HOSTKEY, \"WARNING! Giving up security and accepting any host key as configured!\"\r\n  ANY_CERTIFICATE, \"WARNING! Giving up security and accepting any certificate as configured!\"\r\n  SCRIPT_SYNC_UPLOAD_NEW, \"New local file %s\"\r\n  SCRIPT_SYNC_DOWNLOAD_NEW, \"New remote file %s\"\r\n  SCRIPT_SYNC_UPLOAD_UPDATE, \"Local file %s newer than remote file %s\"\r\n  SCRIPT_SYNC_DOWNLOAD_UPDATE, \"Remote file %s newer than local file %s\"\r\n  SCRIPT_SYNC_DELETE_REMOTE, \"Orphan remote file %s\"\r\n  SCRIPT_SYNC_DELETE_LOCAL, \"Orphan local file %s\"\r\n  SCRIPT_SYNCHRONIZE_CHECKLIST, \"Differences found:\"\r\n  COPY_INFO_REMOVE_CTRLZ, \"Remove EOF mark\"\r\n  COPY_INFO_REMOVE_BOM, \"Remove BOM\"\r\n  SCRIPT_NON_DEFAULT_COPY_PARAM, \"Using configured transfer settings different from factory defaults.\"\r\n  SCRIPT_NON_DEFAULT_SYNC_PARAM, \"Using configured synchronization options different from factory defaults.\"\r\n  VERSION_BUILD, \"Build\"\r\n  VERSION_DEV_BUILD, \"Dev Build\"\r\n  VERSION_DEBUG_BUILD, \"Debug Build\"\r\n  VERSION_DONT_DISTRIBUTE, \"- Do NOT distribute\"\r\n  WEBDAV_EXTENSION_INFO, \"The server supports these WebDAV extensions:\"\r\n  COPY_PARAM_PRESET_EXCLUDE_ALL_DIR, \"Exclude &directories\"\r\n  SCRIPT_CHECKSUM_DESC, \"Calculates checksum of remote file\"\r\n  CLIENT_CERTIFICATE_LOADING, \"Loading client certificate...\"\r\n  NEED_CLIENT_CERTIFICATE, \"Server asks for authentication with a client certificate.\"\r\n  LOCKED, \"Locked\"\r\n  EXECUTABLE, \"Executable\"\r\n  SCRIPT_CMDLINE_PARAMETERS, \"Scripting does not use standalone parameters. The parameters you have specified on command-line will not be used. Your command-line syntax is probably wrong.\"\r\n  SCRIPTING_USE_HOSTKEY, \"In scripting, you should use a -hostkey switch to configure the expected host key.\"\r\n  SCRIPT_SITE_WARNING, \"In scripting you should not rely on saved sites, use this command instead:\"\r\n  CODE_SESSION_OPTIONS, \"Set up session options\"\r\n  CODE_CONNECT, \"Connect\"\r\n  CODE_PS_ADD_TYPE, \"Load WinSCP .NET assembly\"\r\n  COPY_INFO_PRESERVE_TIME_DIRS, \"%s (including directories)\"\r\n  TEXT_FILE_ENCODING, \"The file must be in UTF-8 or UTF-16 encoding.\"\r\n  AND_STR, \"%s and %s\"\r\n  AUTH_CHANGING_PASSWORD, \"Changing password.\"\r\n  PASTE_KEY_BUTTON, \"&Paste key\"\r\n  SCRIPT_CP_DESC, \"Duplicates remote file\"\r\n  TIME_UNKNOWN, \"Unknown\"\r\n  KEY_DETAILS, \"    Algorithm:\\t%s\\n    SHA-256:\\t%s\\n    MD5:\\t%s\"\r\n  COPY_KEY_ACTION, \"&Copy key fingerprints to clipboard\"\r\n  COPY_CERTIFICATE_ACTION, \"&Copy certificate fingerprint to clipboard\"\r\n  COPY_INFO_DONT_ENCRYPT_NEW_FILES, \"Do not encrypt new files\"\r\n  COPY_INFO_EXCLUDE_HIDDEN_FILES, \"Exclude hidden files\"\r\n  COPY_INFO_EXCLUDE_EMPTY_DIRS, \"Exclude empty directories\"\r\n\r\n  CORE_VARIABLE_STRINGS, \"CORE_VARIABLE\"\r\n  PUTTY_BASED_ON, \"SSH and SCP code based on PuTTY %s\"\r\n  PUTTY_COPYRIGHT, \"Copyright \u00a9 1997-2017 Simon Tatham\"\r\n  PUTTY_URL, \"https://www.chiark.greenend.org.uk/~sgtatham/putty/\"\r\n  FILEZILLA_BASED_ON2, \"FTP code based on FileZilla\"\r\n  FILEZILLA_COPYRIGHT2, \"Copyright \u00a9 Tim Kosse\"\r\n  FILEZILLA_URL, \"https://filezilla-project.org/\"\r\n  OPENSSL_BASED_ON, \"This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit %s.\"\r\n  OPENSSL_COPYRIGHT2, \"Copyright \u00a9 1998-%s The OpenSSL Project\"\r\n  OPENSSL_URL, \"https://www.openssl.org/\"\r\n  NEON_BASED_ON2, \"WebDAV/HTTP code based on neon library %s\"\r\n  NEON_COPYRIGHT, \"Copyright \u00a9 1999-2016 Joe Orton\"\r\n  EXPAT_BASED_ON, \"eXpat library %s\"\r\n  EXPAT_URL, \"http://www.libexpat.org/\"\r\n  PUTTY_LICENSE_URL, \"https://www.chiark.greenend.org.uk/~sgtatham/putty/licence.html\"\r\n  MAIN_MSG_TAG, \"**\"\r\n  INTERACTIVE_MSG_TAG, \"$$\"\r\n  S3_BASED_ON, \"S3 code based on libs3 library %s\"\r\n  S3_COPYRIGHT, \"Copyright \u00a9 Bryan Ischo\"\r\n  S3_URL, \"https://github.com/bji/libs3\"\r\n  S3_LICENSE_URL, \"https://github.com/bji/libs3/blob/master/LICENSE\"\r\nEND\r\n"], "filenames": ["source/core/ScpFileSystem.cpp", "source/resource/TextsCore.h", "source/resource/TextsCore1.rc"], "buggy_code_start_loc": [2363, 272, 243], "buggy_code_end_loc": [2363, 272, 243], "fixing_code_start_loc": [2364, 273, 244], "fixing_code_end_loc": [2368, 274, 245], "type": "CWE-20", "message": "In WinSCP before 5.14 beta, due to missing validation, the scp implementation would accept arbitrary files sent by the server, potentially overwriting unrelated files. This affects TSCPFileSystem::SCPSink in core/ScpFileSystem.cpp.", "other": {"cve": {"id": "CVE-2018-20684", "sourceIdentifier": "cve@mitre.org", "published": "2019-01-10T21:29:00.297", "lastModified": "2020-01-15T20:15:18.150", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In WinSCP before 5.14 beta, due to missing validation, the scp implementation would accept arbitrary files sent by the server, potentially overwriting unrelated files. This affects TSCPFileSystem::SCPSink in core/ScpFileSystem.cpp."}, {"lang": "es", "value": "En WinSCP, en versiones anteriores a la 5.14 beta, debido a la falta de validaci\u00f3n, la implementaci\u00f3n de scp aceptar\u00eda archivos arbitrarios enviados por el servidor, lo que podr\u00eda sobrescribir archivos no relacionados. Esto afecta a TSCPFileSystem::SCPSink en core/ScpFileSystem.cpp."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:winscp:winscp:*:*:*:*:*:*:*:*", "versionEndIncluding": "5.13.7", "matchCriteriaId": "C13D4EFE-E54E-4E74-998E-590660C121CF"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/106526", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/winscp/winscp/commit/49d876f2c5fc00bcedaa986a7cf6dedd6bf16f54", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://sintonen.fi/advisories/scp-client-multiple-vulnerabilities.txt", "source": "cve@mitre.org", "tags": ["Mitigation", "Third Party Advisory"]}, {"url": "https://winscp.net/eng/docs/history", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://winscp.net/tracker/1675", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpujan2020.html", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/winscp/winscp/commit/49d876f2c5fc00bcedaa986a7cf6dedd6bf16f54"}}