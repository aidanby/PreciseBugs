{"buggy_code": ["# encoding: utf-8\n#\n# Redmine - project management software\n# Copyright (C) 2006-2017  Jean-Philippe Lang\n#\n# This program is free software; you can redistribute it and/or\n# modify it under the terms of the GNU General Public License\n# as published by the Free Software Foundation; either version 2\n# of the License, or (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n\nrequire 'forwardable'\nrequire 'cgi'\n\nmodule ApplicationHelper\n  include Redmine::WikiFormatting::Macros::Definitions\n  include Redmine::I18n\n  include GravatarHelper::PublicMethods\n  include Redmine::Pagination::Helper\n  include Redmine::SudoMode::Helper\n  include Redmine::Themes::Helper\n  include Redmine::Hook::Helper\n  include Redmine::Helpers::URL\n\n  extend Forwardable\n  def_delegators :wiki_helper, :wikitoolbar_for, :heads_for_wiki_formatter\n\n  # Return true if user is authorized for controller/action, otherwise false\n  def authorize_for(controller, action)\n    User.current.allowed_to?({:controller => controller, :action => action}, @project)\n  end\n\n  # Display a link if user is authorized\n  #\n  # @param [String] name Anchor text (passed to link_to)\n  # @param [Hash] options Hash params. This will checked by authorize_for to see if the user is authorized\n  # @param [optional, Hash] html_options Options passed to link_to\n  # @param [optional, Hash] parameters_for_method_reference Extra parameters for link_to\n  def link_to_if_authorized(name, options = {}, html_options = nil, *parameters_for_method_reference)\n    link_to(name, options, html_options, *parameters_for_method_reference) if authorize_for(options[:controller] || params[:controller], options[:action])\n  end\n\n  # Displays a link to user's account page if active\n  def link_to_user(user, options={})\n    if user.is_a?(User)\n      name = h(user.name(options[:format]))\n      if user.active? || (User.current.admin? && user.logged?)\n        only_path = options[:only_path].nil? ? true : options[:only_path]\n        link_to name, user_url(user, :only_path => only_path), :class => user.css_classes\n      else\n        name\n      end\n    else\n      h(user.to_s)\n    end\n  end\n\n  # Displays a link to +issue+ with its subject.\n  # Examples:\n  #\n  #   link_to_issue(issue)                        # => Defect #6: This is the subject\n  #   link_to_issue(issue, :truncate => 6)        # => Defect #6: This i...\n  #   link_to_issue(issue, :subject => false)     # => Defect #6\n  #   link_to_issue(issue, :project => true)      # => Foo - Defect #6\n  #   link_to_issue(issue, :subject => false, :tracker => false)     # => #6\n  #\n  def link_to_issue(issue, options={})\n    title = nil\n    subject = nil\n    text = options[:tracker] == false ? \"##{issue.id}\" : \"#{issue.tracker} ##{issue.id}\"\n    if options[:subject] == false\n      title = issue.subject.truncate(60)\n    else\n      subject = issue.subject\n      if truncate_length = options[:truncate]\n        subject = subject.truncate(truncate_length)\n      end\n    end\n    only_path = options[:only_path].nil? ? true : options[:only_path]\n    s = link_to(text, issue_url(issue, :only_path => only_path),\n                :class => issue.css_classes, :title => title)\n    s << h(\": #{subject}\") if subject\n    s = h(\"#{issue.project} - \") + s if options[:project]\n    s\n  end\n\n  # Generates a link to an attachment.\n  # Options:\n  # * :text - Link text (default to attachment filename)\n  # * :download - Force download (default: false)\n  def link_to_attachment(attachment, options={})\n    text = options.delete(:text) || attachment.filename\n    route_method = options.delete(:download) ? :download_named_attachment_url : :named_attachment_url\n    html_options = options.slice!(:only_path)\n    options[:only_path] = true unless options.key?(:only_path)\n    url = send(route_method, attachment, attachment.filename, options)\n    link_to text, url, html_options\n  end\n\n  # Generates a link to a SCM revision\n  # Options:\n  # * :text - Link text (default to the formatted revision)\n  def link_to_revision(revision, repository, options={})\n    if repository.is_a?(Project)\n      repository = repository.repository\n    end\n    text = options.delete(:text) || format_revision(revision)\n    rev = revision.respond_to?(:identifier) ? revision.identifier : revision\n    link_to(\n        h(text),\n        {:controller => 'repositories', :action => 'revision', :id => repository.project, :repository_id => repository.identifier_param, :rev => rev},\n        :title => l(:label_revision_id, format_revision(revision)),\n        :accesskey => options[:accesskey]\n      )\n  end\n\n  # Generates a link to a message\n  def link_to_message(message, options={}, html_options = nil)\n    link_to(\n      message.subject.truncate(60),\n      board_message_url(message.board_id, message.parent_id || message.id, {\n        :r => (message.parent_id && message.id),\n        :anchor => (message.parent_id ? \"message-#{message.id}\" : nil),\n        :only_path => true\n      }.merge(options)),\n      html_options\n    )\n  end\n\n  # Generates a link to a project if active\n  # Examples:\n  #\n  #   link_to_project(project)                          # => link to the specified project overview\n  #   link_to_project(project, {:only_path => false}, :class => \"project\") # => 3rd arg adds html options\n  #   link_to_project(project, {}, :class => \"project\") # => html options with default url (project overview)\n  #\n  def link_to_project(project, options={}, html_options = nil)\n    if project.archived?\n      h(project.name)\n    else\n      link_to project.name,\n        project_url(project, {:only_path => true}.merge(options)),\n        html_options\n    end\n  end\n\n  # Generates a link to a project settings if active\n  def link_to_project_settings(project, options={}, html_options=nil)\n    if project.active?\n      link_to project.name, settings_project_path(project, options), html_options\n    elsif project.archived?\n      h(project.name)\n    else\n      link_to project.name, project_path(project, options), html_options\n    end\n  end\n\n  # Generates a link to a version\n  def link_to_version(version, options = {})\n    return '' unless version && version.is_a?(Version)\n    options = {:title => format_date(version.effective_date)}.merge(options)\n    link_to_if version.visible?, format_version_name(version), version_path(version), options\n  end\n\n  # Helper that formats object for html or text rendering\n  def format_object(object, html=true, &block)\n    if block_given?\n      object = yield object\n    end\n    case object.class.name\n    when 'Array'\n      object.map {|o| format_object(o, html)}.join(', ').html_safe\n    when 'Time'\n      format_time(object)\n    when 'Date'\n      format_date(object)\n    when 'Fixnum'\n      object.to_s\n    when 'Float'\n      sprintf \"%.2f\", object\n    when 'User'\n      html ? link_to_user(object) : object.to_s\n    when 'Project'\n      html ? link_to_project(object) : object.to_s\n    when 'Version'\n      html ? link_to_version(object) : object.to_s\n    when 'TrueClass'\n      l(:general_text_Yes)\n    when 'FalseClass'\n      l(:general_text_No)\n    when 'Issue'\n      object.visible? && html ? link_to_issue(object) : \"##{object.id}\"\n    when 'Attachment'\n      html ? link_to_attachment(object) : object.filename\n    when 'CustomValue', 'CustomFieldValue'\n      if object.custom_field\n        f = object.custom_field.format.formatted_custom_value(self, object, html)\n        if f.nil? || f.is_a?(String)\n          f\n        else\n          format_object(f, html, &block)\n        end\n      else\n        object.value.to_s\n      end\n    else\n      html ? h(object) : object.to_s\n    end\n  end\n\n  def wiki_page_path(page, options={})\n    url_for({:controller => 'wiki', :action => 'show', :project_id => page.project, :id => page.title}.merge(options))\n  end\n\n  def thumbnail_tag(attachment)\n    thumbnail_size = Setting.thumbnails_size.to_i\n    link_to(\n      image_tag(\n        thumbnail_path(attachment),\n        :srcset => \"#{thumbnail_path(attachment, :size => thumbnail_size * 2)} 2x\",\n        :style => \"max-width: #{thumbnail_size}px; max-height: #{thumbnail_size}px;\"\n      ),\n      named_attachment_path(\n        attachment,\n        attachment.filename\n      ),\n      :title => attachment.filename\n    )\n  end\n\n  def toggle_link(name, id, options={})\n    onclick = \"$('##{id}').toggle(); \"\n    onclick << (options[:focus] ? \"$('##{options[:focus]}').focus(); \" : \"this.blur(); \")\n    onclick << \"$(window).scrollTop($('##{options[:focus]}').position().top); \" if options[:scroll]\n    onclick << \"return false;\"\n    link_to(name, \"#\", :onclick => onclick)\n  end\n\n  # Used to format item titles on the activity view\n  def format_activity_title(text)\n    text\n  end\n\n  def format_activity_day(date)\n    date == User.current.today ? l(:label_today).titleize : format_date(date)\n  end\n\n  def format_activity_description(text)\n    h(text.to_s.truncate(120).gsub(%r{[\\r\\n]*<(pre|code)>.*$}m, '...')\n       ).gsub(/[\\r\\n]+/, \"<br />\").html_safe\n  end\n\n  def format_version_name(version)\n    if version.project == @project\n      h(version)\n    else\n      h(\"#{version.project} - #{version}\")\n    end\n  end\n\n  def format_changeset_comments(changeset, options={})\n    method = options[:short] ? :short_comments : :comments\n    textilizable changeset, method, :formatting => Setting.commit_logs_formatting?\n  end\n\n  def due_date_distance_in_words(date)\n    if date\n      l((date < User.current.today ? :label_roadmap_overdue : :label_roadmap_due_in), distance_of_date_in_words(User.current.today, date))\n    end\n  end\n\n  # Renders a tree of projects as a nested set of unordered lists\n  # The given collection may be a subset of the whole project tree\n  # (eg. some intermediate nodes are private and can not be seen)\n  def render_project_nested_lists(projects, &block)\n    s = ''\n    if projects.any?\n      ancestors = []\n      original_project = @project\n      projects.sort_by(&:lft).each do |project|\n        # set the project environment to please macros.\n        @project = project\n        if (ancestors.empty? || project.is_descendant_of?(ancestors.last))\n          s << \"<ul class='projects #{ ancestors.empty? ? 'root' : nil}'>\\n\"\n        else\n          ancestors.pop\n          s << \"</li>\"\n          while (ancestors.any? && !project.is_descendant_of?(ancestors.last))\n            ancestors.pop\n            s << \"</ul></li>\\n\"\n          end\n        end\n        classes = (ancestors.empty? ? 'root' : 'child')\n        s << \"<li class='#{classes}'><div class='#{classes}'>\"\n        s << h(block_given? ? capture(project, &block) : project.name)\n        s << \"</div>\\n\"\n        ancestors << project\n      end\n      s << (\"</li></ul>\\n\" * ancestors.size)\n      @project = original_project\n    end\n    s.html_safe\n  end\n\n  def render_page_hierarchy(pages, node=nil, options={})\n    content = ''\n    if pages[node]\n      content << \"<ul class=\\\"pages-hierarchy\\\">\\n\"\n      pages[node].each do |page|\n        content << \"<li>\"\n        content << link_to(h(page.pretty_title), {:controller => 'wiki', :action => 'show', :project_id => page.project, :id => page.title, :version => nil},\n                           :title => (options[:timestamp] && page.updated_on ? l(:label_updated_time, distance_of_time_in_words(Time.now, page.updated_on)) : nil))\n        content << \"\\n\" + render_page_hierarchy(pages, page.id, options) if pages[page.id]\n        content << \"</li>\\n\"\n      end\n      content << \"</ul>\\n\"\n    end\n    content.html_safe\n  end\n\n  # Renders flash messages\n  def render_flash_messages\n    s = ''\n    flash.each do |k,v|\n      s << content_tag('div', v.html_safe, :class => \"flash #{k}\", :id => \"flash_#{k}\")\n    end\n    s.html_safe\n  end\n\n  # Renders tabs and their content\n  def render_tabs(tabs, selected=params[:tab])\n    if tabs.any?\n      unless tabs.detect {|tab| tab[:name] == selected}\n        selected = nil\n      end\n      selected ||= tabs.first[:name]\n      render :partial => 'common/tabs', :locals => {:tabs => tabs, :selected_tab => selected}\n    else\n      content_tag 'p', l(:label_no_data), :class => \"nodata\"\n    end\n  end\n\n  # Returns the default scope for the quick search form\n  # Could be 'all', 'my_projects', 'subprojects' or nil (current project)\n  def default_search_project_scope\n    if @project && !@project.leaf?\n      'subprojects'\n    end\n  end\n\n  # Returns an array of projects that are displayed in the quick-jump box\n  def projects_for_jump_box(user=User.current)\n    if user.logged?\n      user.projects.active.select(:id, :name, :identifier, :lft, :rgt).to_a\n    else\n      []\n    end\n  end\n\n  def render_projects_for_jump_box(projects, selected=nil)\n    jump = params[:jump].presence || current_menu_item\n    s = ''.html_safe\n    project_tree(projects) do |project, level|\n      padding = level * 16\n      text = content_tag('span', project.name, :style => \"padding-left:#{padding}px;\")\n      s << link_to(text, project_path(project, :jump => jump), :title => project.name, :class => (project == selected ? 'selected' : nil))\n    end\n    s\n  end\n\n  # Renders the project quick-jump box\n  def render_project_jump_box\n    projects = projects_for_jump_box(User.current)\n    if @project && @project.persisted?\n      text = @project.name_was\n    end\n    text ||= l(:label_jump_to_a_project)\n    url = autocomplete_projects_path(:format => 'js', :jump => current_menu_item)\n\n    trigger = content_tag('span', text, :class => 'drdn-trigger')\n    q = text_field_tag('q', '', :id => 'projects-quick-search', :class => 'autocomplete', :data => {:automcomplete_url => url}, :autocomplete => 'off')\n    all = link_to(l(:label_project_all), projects_path(:jump => current_menu_item), :class => (@project.nil? && controller.class.main_menu ? 'selected' : nil))\n    content = content_tag('div',\n          content_tag('div', q, :class => 'quick-search') +\n          content_tag('div', render_projects_for_jump_box(projects, @project), :class => 'drdn-items projects selection') +\n          content_tag('div', all, :class => 'drdn-items all-projects selection'),\n        :class => 'drdn-content'\n      )\n\n    content_tag('div', trigger + content, :id => \"project-jump\", :class => \"drdn\")\n  end\n\n  def project_tree_options_for_select(projects, options = {})\n    s = ''.html_safe\n    if blank_text = options[:include_blank]\n      if blank_text == true\n        blank_text = '&nbsp;'.html_safe\n      end\n      s << content_tag('option', blank_text, :value => '')\n    end\n    project_tree(projects) do |project, level|\n      name_prefix = (level > 0 ? '&nbsp;' * 2 * level + '&#187; ' : '').html_safe\n      tag_options = {:value => project.id}\n      if project == options[:selected] || (options[:selected].respond_to?(:include?) && options[:selected].include?(project))\n        tag_options[:selected] = 'selected'\n      else\n        tag_options[:selected] = nil\n      end\n      tag_options.merge!(yield(project)) if block_given?\n      s << content_tag('option', name_prefix + h(project), tag_options)\n    end\n    s.html_safe\n  end\n\n  # Yields the given block for each project with its level in the tree\n  #\n  # Wrapper for Project#project_tree\n  def project_tree(projects, options={}, &block)\n    Project.project_tree(projects, options, &block)\n  end\n\n  def principals_check_box_tags(name, principals)\n    s = ''\n    principals.each do |principal|\n      s << \"<label>#{ check_box_tag name, principal.id, false, :id => nil } #{h principal}</label>\\n\"\n    end\n    s.html_safe\n  end\n\n  # Returns a string for users/groups option tags\n  def principals_options_for_select(collection, selected=nil)\n    s = ''\n    if collection.include?(User.current)\n      s << content_tag('option', \"<< #{l(:label_me)} >>\", :value => User.current.id)\n    end\n    groups = ''\n    collection.sort.each do |element|\n      selected_attribute = ' selected=\"selected\"' if option_value_selected?(element, selected) || element.id.to_s == selected\n      (element.is_a?(Group) ? groups : s) << %(<option value=\"#{element.id}\"#{selected_attribute}>#{h element.name}</option>)\n    end\n    unless groups.empty?\n      s << %(<optgroup label=\"#{h(l(:label_group_plural))}\">#{groups}</optgroup>)\n    end\n    s.html_safe\n  end\n\n  def option_tag(name, text, value, selected=nil, options={})\n    content_tag 'option', value, options.merge(:value => value, :selected => (value == selected))\n  end\n\n  def truncate_single_line_raw(string, length)\n    string.to_s.truncate(length).gsub(%r{[\\r\\n]+}m, ' ')\n  end\n\n  # Truncates at line break after 250 characters or options[:length]\n  def truncate_lines(string, options={})\n    length = options[:length] || 250\n    if string.to_s =~ /\\A(.{#{length}}.*?)$/m\n      \"#{$1}...\"\n    else\n      string\n    end\n  end\n\n  def anchor(text)\n    text.to_s.gsub(' ', '_')\n  end\n\n  def html_hours(text)\n    text.gsub(%r{(\\d+)([\\.:])(\\d+)}, '<span class=\"hours hours-int\">\\1</span><span class=\"hours hours-dec\">\\2\\3</span>').html_safe\n  end\n\n  def authoring(created, author, options={})\n    l(options[:label] || :label_added_time_by, :author => link_to_user(author), :age => time_tag(created)).html_safe\n  end\n\n  def time_tag(time)\n    text = distance_of_time_in_words(Time.now, time)\n    if @project\n      link_to(text, project_activity_path(@project, :from => User.current.time_to_date(time)), :title => format_time(time))\n    else\n      content_tag('abbr', text, :title => format_time(time))\n    end\n  end\n\n  def syntax_highlight_lines(name, content)\n    syntax_highlight(name, content).each_line.to_a\n  end\n\n  def syntax_highlight(name, content)\n    Redmine::SyntaxHighlighting.highlight_by_filename(content, name)\n  end\n\n  def to_path_param(path)\n    str = path.to_s.split(%r{[/\\\\]}).select{|p| !p.blank?}.join(\"/\")\n    str.blank? ? nil : str\n  end\n\n  def reorder_handle(object, options={})\n    data = {\n      :reorder_url => options[:url] || url_for(object),\n      :reorder_param => options[:param] || object.class.name.underscore\n    }\n    content_tag('span', '',\n      :class => \"sort-handle\",\n      :data => data,\n      :title => l(:button_sort))\n  end\n\n  def breadcrumb(*args)\n    elements = args.flatten\n    elements.any? ? content_tag('p', (args.join(\" \\xc2\\xbb \") + \" \\xc2\\xbb \").html_safe, :class => 'breadcrumb') : nil\n  end\n\n  def other_formats_links(&block)\n    concat('<p class=\"other-formats\">'.html_safe + l(:label_export_to))\n    yield Redmine::Views::OtherFormatsBuilder.new(self)\n    concat('</p>'.html_safe)\n  end\n\n  def page_header_title\n    if @project.nil? || @project.new_record?\n      h(Setting.app_title)\n    else\n      b = []\n      ancestors = (@project.root? ? [] : @project.ancestors.visible.to_a)\n      if ancestors.any?\n        root = ancestors.shift\n        b << link_to_project(root, {:jump => current_menu_item}, :class => 'root')\n        if ancestors.size > 2\n          b << \"\\xe2\\x80\\xa6\"\n          ancestors = ancestors[-2, 2]\n        end\n        b += ancestors.collect {|p| link_to_project(p, {:jump => current_menu_item}, :class => 'ancestor') }\n      end\n      b << content_tag(:span, h(@project), class: 'current-project')\n      if b.size > 1\n        separator = content_tag(:span, ' &raquo; '.html_safe, class: 'separator')\n        path = safe_join(b[0..-2], separator) + separator\n        b = [content_tag(:span, path.html_safe, class: 'breadcrumbs'), b[-1]]\n      end\n      safe_join b\n    end\n  end\n\n  # Returns a h2 tag and sets the html title with the given arguments\n  def title(*args)\n    strings = args.map do |arg|\n      if arg.is_a?(Array) && arg.size >= 2\n        link_to(*arg)\n      else\n        h(arg.to_s)\n      end\n    end\n    html_title args.reverse.map {|s| (s.is_a?(Array) ? s.first : s).to_s}\n    content_tag('h2', strings.join(' &#187; ').html_safe)\n  end\n\n  # Sets the html title\n  # Returns the html title when called without arguments\n  # Current project name and app_title and automatically appended\n  # Exemples:\n  #   html_title 'Foo', 'Bar'\n  #   html_title # => 'Foo - Bar - My Project - Redmine'\n  def html_title(*args)\n    if args.empty?\n      title = @html_title || []\n      title << @project.name if @project\n      title << Setting.app_title unless Setting.app_title == title.last\n      title.reject(&:blank?).join(' - ')\n    else\n      @html_title ||= []\n      @html_title += args\n    end\n  end\n\n  # Returns the theme, controller name, and action as css classes for the\n  # HTML body.\n  def body_css_classes\n    css = []\n    if theme = Redmine::Themes.theme(Setting.ui_theme)\n      css << 'theme-' + theme.name\n    end\n\n    css << 'project-' + @project.identifier if @project && @project.identifier.present?\n    css << 'controller-' + controller_name\n    css << 'action-' + action_name\n    css << 'avatars-' + (Setting.gravatar_enabled? ? 'on' : 'off')\n    if UserPreference::TEXTAREA_FONT_OPTIONS.include?(User.current.pref.textarea_font)\n      css << \"textarea-#{User.current.pref.textarea_font}\"\n    end\n    css.join(' ')\n  end\n\n  def accesskey(s)\n    @used_accesskeys ||= []\n    key = Redmine::AccessKeys.key_for(s)\n    return nil if @used_accesskeys.include?(key)\n    @used_accesskeys << key\n    key\n  end\n\n  # Formats text according to system settings.\n  # 2 ways to call this method:\n  # * with a String: textilizable(text, options)\n  # * with an object and one of its attribute: textilizable(issue, :description, options)\n  def textilizable(*args)\n    options = args.last.is_a?(Hash) ? args.pop : {}\n    case args.size\n    when 1\n      obj = options[:object]\n      text = args.shift\n    when 2\n      obj = args.shift\n      attr = args.shift\n      text = obj.send(attr).to_s\n    else\n      raise ArgumentError, 'invalid arguments to textilizable'\n    end\n    return '' if text.blank?\n    project = options[:project] || @project || (obj && obj.respond_to?(:project) ? obj.project : nil)\n    @only_path = only_path = options.delete(:only_path) == false ? false : true\n\n    text = text.dup\n    macros = catch_macros(text)\n\n    if options[:formatting] == false\n      text = h(text)\n    else\n      formatting = Setting.text_formatting\n      text = Redmine::WikiFormatting.to_html(formatting, text, :object => obj, :attribute => attr)\n    end\n\n    @parsed_headings = []\n    @heading_anchors = {}\n    @current_section = 0 if options[:edit_section_links]\n\n    parse_sections(text, project, obj, attr, only_path, options)\n    text = parse_non_pre_blocks(text, obj, macros) do |text|\n      [:parse_inline_attachments, :parse_hires_images, :parse_wiki_links, :parse_redmine_links].each do |method_name|\n        send method_name, text, project, obj, attr, only_path, options\n      end\n    end\n    parse_headings(text, project, obj, attr, only_path, options)\n\n    if @parsed_headings.any?\n      replace_toc(text, @parsed_headings)\n    end\n\n    text.html_safe\n  end\n\n  def parse_non_pre_blocks(text, obj, macros)\n    s = StringScanner.new(text)\n    tags = []\n    parsed = ''\n    while !s.eos?\n      s.scan(/(.*?)(<(\\/)?(pre|code)(.*?)>|\\z)/im)\n      text, full_tag, closing, tag = s[1], s[2], s[3], s[4]\n      if tags.empty?\n        yield text\n        inject_macros(text, obj, macros) if macros.any?\n      else\n        inject_macros(text, obj, macros, false) if macros.any?\n      end\n      parsed << text\n      if tag\n        if closing\n          if tags.last && tags.last.casecmp(tag) == 0\n            tags.pop\n          end\n        else\n          tags << tag.downcase\n        end\n        parsed << full_tag\n      end\n    end\n    # Close any non closing tags\n    while tag = tags.pop\n      parsed << \"</#{tag}>\"\n    end\n    parsed\n  end\n\n  # add srcset attribute to img tags if filename includes @2x, @3x, etc.\n  # to support hires displays\n  def parse_hires_images(text, project, obj, attr, only_path, options)\n    text.gsub!(/src=\"([^\"]+@(\\dx)\\.(bmp|gif|jpg|jpe|jpeg|png))\"/i) do |m|\n      filename, dpr = $1, $2\n      m + \" srcset=\\\"#{filename} #{dpr}\\\"\"\n    end\n  end\n\n  def parse_inline_attachments(text, project, obj, attr, only_path, options)\n    return if options[:inline_attachments] == false\n\n    # when using an image link, try to use an attachment, if possible\n    attachments = options[:attachments] || []\n    attachments += obj.attachments if obj.respond_to?(:attachments)\n    if attachments.present?\n      text.gsub!(/src=\"([^\\/\"]+\\.(bmp|gif|jpg|jpe|jpeg|png))\"(\\s+alt=\"([^\"]*)\")?/i) do |m|\n        filename, ext, alt, alttext = $1.downcase, $2, $3, $4\n        # search for the picture in attachments\n        if found = Attachment.latest_attach(attachments, CGI.unescape(filename))\n          image_url = download_named_attachment_url(found, found.filename, :only_path => only_path)\n          desc = found.description.to_s.gsub('\"', '')\n          if !desc.blank? && alttext.blank?\n            alt = \" title=\\\"#{desc}\\\" alt=\\\"#{desc}\\\"\"\n          end\n          \"src=\\\"#{image_url}\\\"#{alt}\"\n        else\n          m\n        end\n      end\n    end\n  end\n\n  # Wiki links\n  #\n  # Examples:\n  #   [[mypage]]\n  #   [[mypage|mytext]]\n  # wiki links can refer other project wikis, using project name or identifier:\n  #   [[project:]] -> wiki starting page\n  #   [[project:|mytext]]\n  #   [[project:mypage]]\n  #   [[project:mypage|mytext]]\n  def parse_wiki_links(text, project, obj, attr, only_path, options)\n    text.gsub!(/(!)?(\\[\\[([^\\]\\n\\|]+)(\\|([^\\]\\n\\|]+))?\\]\\])/) do |m|\n      link_project = project\n      esc, all, page, title = $1, $2, $3, $5\n      if esc.nil?\n        if page =~ /^([^\\:]+)\\:(.*)$/\n          identifier, page = $1, $2\n          link_project = Project.find_by_identifier(identifier) || Project.find_by_name(identifier)\n          title ||= identifier if page.blank?\n        end\n\n        if link_project && link_project.wiki && User.current.allowed_to?(:view_wiki_pages, link_project)\n          # extract anchor\n          anchor = nil\n          if page =~ /^(.+?)\\#(.+)$/\n            page, anchor = $1, $2\n          end\n          anchor = sanitize_anchor_name(anchor) if anchor.present?\n          # check if page exists\n          wiki_page = link_project.wiki.find_page(page)\n          url = if anchor.present? && wiki_page.present? && (obj.is_a?(WikiContent) || obj.is_a?(WikiContent::Version)) && obj.page == wiki_page\n            \"##{anchor}\"\n          else\n            case options[:wiki_links]\n            when :local; \"#{page.present? ? Wiki.titleize(page) : ''}.html\" + (anchor.present? ? \"##{anchor}\" : '')\n            when :anchor; \"##{page.present? ? Wiki.titleize(page) : title}\" + (anchor.present? ? \"_#{anchor}\" : '') # used for single-file wiki export\n            else\n              wiki_page_id = page.present? ? Wiki.titleize(page) : nil\n              parent = wiki_page.nil? && obj.is_a?(WikiContent) && obj.page && project == link_project ? obj.page.title : nil\n              url_for(:only_path => only_path, :controller => 'wiki', :action => 'show', :project_id => link_project,\n               :id => wiki_page_id, :version => nil, :anchor => anchor, :parent => parent)\n            end\n          end\n          link_to(title.present? ? title.html_safe : h(page), url, :class => ('wiki-page' + (wiki_page ? '' : ' new')))\n        else\n          # project or wiki doesn't exist\n          all\n        end\n      else\n        all\n      end\n    end\n  end\n\n  # Redmine links\n  #\n  # Examples:\n  #   Issues:\n  #     #52 -> Link to issue #52\n  #   Changesets:\n  #     r52 -> Link to revision 52\n  #     commit:a85130f -> Link to scmid starting with a85130f\n  #   Documents:\n  #     document#17 -> Link to document with id 17\n  #     document:Greetings -> Link to the document with title \"Greetings\"\n  #     document:\"Some document\" -> Link to the document with title \"Some document\"\n  #   Versions:\n  #     version#3 -> Link to version with id 3\n  #     version:1.0.0 -> Link to version named \"1.0.0\"\n  #     version:\"1.0 beta 2\" -> Link to version named \"1.0 beta 2\"\n  #   Attachments:\n  #     attachment:file.zip -> Link to the attachment of the current object named file.zip\n  #   Source files:\n  #     source:some/file -> Link to the file located at /some/file in the project's repository\n  #     source:some/file@52 -> Link to the file's revision 52\n  #     source:some/file#L120 -> Link to line 120 of the file\n  #     source:some/file@52#L120 -> Link to line 120 of the file's revision 52\n  #     export:some/file -> Force the download of the file\n  #   Forums:\n  #     forum#1 -> Link to forum with id 1\n  #     forum:Support -> Link to forum named \"Support\"\n  #     forum:\"Technical Support\" -> Link to forum named \"Technical Support\"\n  #   Forum messages:\n  #     message#1218 -> Link to message with id 1218\n  #   Projects:\n  #     project:someproject -> Link to project named \"someproject\"\n  #     project#3 -> Link to project with id 3\n  #   News:\n  #     news#2 -> Link to news item with id 1\n  #     news:Greetings -> Link to news item named \"Greetings\"\n  #     news:\"First Release\" -> Link to news item named \"First Release\"\n  #   Users:\n  #     user:jsmith -> Link to user with login jsmith\n  #     @jsmith -> Link to user with login jsmith\n  #     user#2 -> Link to user with id 2\n  #\n  #   Links can refer other objects from other projects, using project identifier:\n  #     identifier:r52\n  #     identifier:document:\"Some document\"\n  #     identifier:version:1.0.0\n  #     identifier:source:some/file\n  def parse_redmine_links(text, default_project, obj, attr, only_path, options)\n    text.gsub!(LINKS_RE) do |_|\n      tag_content = $~[:tag_content]\n      leading = $~[:leading]\n      esc = $~[:esc]\n      project_prefix = $~[:project_prefix]\n      project_identifier = $~[:project_identifier]\n      prefix = $~[:prefix]\n      repo_prefix = $~[:repo_prefix]\n      repo_identifier = $~[:repo_identifier]\n      sep = $~[:sep1] || $~[:sep2] || $~[:sep3] || $~[:sep4]\n      identifier = $~[:identifier1] || $~[:identifier2] || $~[:identifier3]\n      comment_suffix = $~[:comment_suffix]\n      comment_id = $~[:comment_id]\n\n      if tag_content\n        $&\n      else\n        link = nil\n        project = default_project\n        if project_identifier\n          project = Project.visible.find_by_identifier(project_identifier)\n        end\n        if esc.nil?\n          if prefix.nil? && sep == 'r'\n            if project\n              repository = nil\n              if repo_identifier\n                repository = project.repositories.detect {|repo| repo.identifier == repo_identifier}\n              else\n                repository = project.repository\n              end\n              # project.changesets.visible raises an SQL error because of a double join on repositories\n              if repository &&\n                   (changeset = Changeset.visible.\n                                    find_by_repository_id_and_revision(repository.id, identifier))\n                link = link_to(h(\"#{project_prefix}#{repo_prefix}r#{identifier}\"),\n                               {:only_path => only_path, :controller => 'repositories',\n                                :action => 'revision', :id => project,\n                                :repository_id => repository.identifier_param,\n                                :rev => changeset.revision},\n                               :class => 'changeset',\n                               :title => truncate_single_line_raw(changeset.comments, 100))\n              end\n            end\n          elsif sep == '#'\n            oid = identifier.to_i\n            case prefix\n            when nil\n              if oid.to_s == identifier &&\n                issue = Issue.visible.find_by_id(oid)\n                anchor = comment_id ? \"note-#{comment_id}\" : nil\n                link = link_to(\"##{oid}#{comment_suffix}\",\n                               issue_url(issue, :only_path => only_path, :anchor => anchor),\n                               :class => issue.css_classes,\n                               :title => \"#{issue.tracker.name}: #{issue.subject.truncate(100)} (#{issue.status.name})\")\n              end\n            when 'document'\n              if document = Document.visible.find_by_id(oid)\n                link = link_to(document.title, document_url(document, :only_path => only_path), :class => 'document')\n              end\n            when 'version'\n              if version = Version.visible.find_by_id(oid)\n                link = link_to(version.name, version_url(version, :only_path => only_path), :class => 'version')\n              end\n            when 'message'\n              if message = Message.visible.find_by_id(oid)\n                link = link_to_message(message, {:only_path => only_path}, :class => 'message')\n              end\n            when 'forum'\n              if board = Board.visible.find_by_id(oid)\n                link = link_to(board.name, project_board_url(board.project, board, :only_path => only_path), :class => 'board')\n              end\n            when 'news'\n              if news = News.visible.find_by_id(oid)\n                link = link_to(news.title, news_url(news, :only_path => only_path), :class => 'news')\n              end\n            when 'project'\n              if p = Project.visible.find_by_id(oid)\n                link = link_to_project(p, {:only_path => only_path}, :class => 'project')\n              end\n            when 'user'\n              u = User.visible.where(:id => oid, :type => 'User').first\n              link = link_to_user(u, :only_path => only_path) if u\n            end\n          elsif sep == ':'\n            name = remove_double_quotes(identifier)\n            case prefix\n            when 'document'\n              if project && document = project.documents.visible.find_by_title(name)\n                link = link_to(document.title, document_url(document, :only_path => only_path), :class => 'document')\n              end\n            when 'version'\n              if project && version = project.versions.visible.find_by_name(name)\n                link = link_to(version.name, version_url(version, :only_path => only_path), :class => 'version')\n              end\n            when 'forum'\n              if project && board = project.boards.visible.find_by_name(name)\n                link = link_to(board.name, project_board_url(board.project, board, :only_path => only_path), :class => 'board')\n              end\n            when 'news'\n              if project && news = project.news.visible.find_by_title(name)\n                link = link_to(news.title, news_url(news, :only_path => only_path), :class => 'news')\n              end\n            when 'commit', 'source', 'export'\n              if project\n                repository = nil\n                if name =~ %r{^(([a-z0-9\\-_]+)\\|)(.+)$}\n                  repo_prefix, repo_identifier, name = $1, $2, $3\n                  repository = project.repositories.detect {|repo| repo.identifier == repo_identifier}\n                else\n                  repository = project.repository\n                end\n                if prefix == 'commit'\n                  if repository && (changeset = Changeset.visible.where(\"repository_id = ? AND scmid LIKE ?\", repository.id, \"#{name}%\").first)\n                    link = link_to h(\"#{project_prefix}#{repo_prefix}#{name}\"), {:only_path => only_path, :controller => 'repositories', :action => 'revision', :id => project, :repository_id => repository.identifier_param, :rev => changeset.identifier},\n                                                 :class => 'changeset',\n                                                 :title => truncate_single_line_raw(changeset.comments, 100)\n                  end\n                else\n                  if repository && User.current.allowed_to?(:browse_repository, project)\n                    name =~ %r{^[/\\\\]*(.*?)(@([^/\\\\@]+?))?(#(L\\d+))?$}\n                    path, rev, anchor = $1, $3, $5\n                    link = link_to h(\"#{project_prefix}#{prefix}:#{repo_prefix}#{name}\"), {:only_path => only_path, :controller => 'repositories', :action => (prefix == 'export' ? 'raw' : 'entry'), :id => project, :repository_id => repository.identifier_param,\n                                                            :path => to_path_param(path),\n                                                            :rev => rev,\n                                                            :anchor => anchor},\n                                                           :class => (prefix == 'export' ? 'source download' : 'source')\n                  end\n                end\n                repo_prefix = nil\n              end\n            when 'attachment'\n              attachments = options[:attachments] || []\n              attachments += obj.attachments if obj.respond_to?(:attachments)\n              if attachments && attachment = Attachment.latest_attach(attachments, name)\n                link = link_to_attachment(attachment, :only_path => only_path, :class => 'attachment')\n              end\n            when 'project'\n              if p = Project.visible.where(\"identifier = :s OR LOWER(name) = :s\", :s => name.downcase).first\n                link = link_to_project(p, {:only_path => only_path}, :class => 'project')\n              end\n            when 'user'\n              u = User.visible.where(:login => name, :type => 'User').first\n              link = link_to_user(u, :only_path => only_path) if u\n            end\n          elsif sep == \"@\"\n            name = remove_double_quotes(identifier)\n            u = User.visible.where(:login => name, :type => 'User').first\n            link = link_to_user(u, :only_path => only_path) if u\n          end\n        end\n        (leading + (link || \"#{project_prefix}#{prefix}#{repo_prefix}#{sep}#{identifier}#{comment_suffix}\"))\n      end\n    end\n  end\n\n  LINKS_RE =\n      %r{\n            <a( [^>]+?)?>(?<tag_content>.*?)</a>|\n            (?<leading>[\\s\\(,\\-\\[\\>]|^)\n            (?<esc>!)?\n            (?<project_prefix>(?<project_identifier>[a-z0-9\\-_]+):)?\n            (?<prefix>attachment|document|version|forum|news|message|project|commit|source|export|user)?\n            (\n              (\n                (?<sep1>\\#)|\n                (\n                  (?<repo_prefix>(?<repo_identifier>[a-z0-9\\-_]+)\\|)?\n                  (?<sep2>r)\n                )\n              )\n              (\n                (?<identifier1>\\d+)\n                (?<comment_suffix>\n                  (\\#note)?\n                  -(?<comment_id>\\d+)\n                )?\n              )|\n              (\n              (?<sep3>:)\n              (?<identifier2>[^\"\\s<>][^\\s<>]*?|\"[^\"]+?\")\n              )|\n              (\n              (?<sep4>@)\n              (?<identifier3>[a-z0-9_\\-@\\.]*)\n              )\n            )\n            (?=\n              (?=[[:punct:]][^A-Za-z0-9_/])|\n              ,|\n              \\s|\n              \\]|\n              <|\n              $)\n      }x\n  HEADING_RE = /(<h(\\d)( [^>]+)?>(.+?)<\\/h(\\d)>)/i unless const_defined?(:HEADING_RE)\n\n  def parse_sections(text, project, obj, attr, only_path, options)\n    return unless options[:edit_section_links]\n    text.gsub!(HEADING_RE) do\n      heading, level = $1, $2\n      @current_section += 1\n      if @current_section > 1\n        content_tag('div',\n          link_to(l(:button_edit_section), options[:edit_section_links].merge(:section => @current_section),\n                  :class => 'icon-only icon-edit'),\n          :class => \"contextual heading-#{level}\",\n          :title => l(:button_edit_section),\n          :id => \"section-#{@current_section}\") + heading.html_safe\n      else\n        heading\n      end\n    end\n  end\n\n  # Headings and TOC\n  # Adds ids and links to headings unless options[:headings] is set to false\n  def parse_headings(text, project, obj, attr, only_path, options)\n    return if options[:headings] == false\n\n    text.gsub!(HEADING_RE) do\n      level, attrs, content = $2.to_i, $3, $4\n      item = strip_tags(content).strip\n      anchor = sanitize_anchor_name(item)\n      # used for single-file wiki export\n      anchor = \"#{obj.page.title}_#{anchor}\" if options[:wiki_links] == :anchor && (obj.is_a?(WikiContent) || obj.is_a?(WikiContent::Version))\n      @heading_anchors[anchor] ||= 0\n      idx = (@heading_anchors[anchor] += 1)\n      if idx > 1\n        anchor = \"#{anchor}-#{idx}\"\n      end\n      @parsed_headings << [level, anchor, item]\n      \"<a name=\\\"#{anchor}\\\"></a>\\n<h#{level} #{attrs}>#{content}<a href=\\\"##{anchor}\\\" class=\\\"wiki-anchor\\\">&para;</a></h#{level}>\"\n    end\n  end\n\n  MACROS_RE = /(\n                (!)?                        # escaping\n                (\n                \\{\\{                        # opening tag\n                ([\\w]+)                     # macro name\n                (\\(([^\\n\\r]*?)\\))?          # optional arguments\n                ([\\n\\r].*?[\\n\\r])?          # optional block of text\n                \\}\\}                        # closing tag\n                )\n               )/mx unless const_defined?(:MACROS_RE)\n\n  MACRO_SUB_RE = /(\n                  \\{\\{\n                  macro\\((\\d+)\\)\n                  \\}\\}\n                  )/x unless const_defined?(:MACRO_SUB_RE)\n\n  # Extracts macros from text\n  def catch_macros(text)\n    macros = {}\n    text.gsub!(MACROS_RE) do\n      all, macro = $1, $4.downcase\n      if macro_exists?(macro) || all =~ MACRO_SUB_RE\n        index = macros.size\n        macros[index] = all\n        \"{{macro(#{index})}}\"\n      else\n        all\n      end\n    end\n    macros\n  end\n\n  # Executes and replaces macros in text\n  def inject_macros(text, obj, macros, execute=true)\n    text.gsub!(MACRO_SUB_RE) do\n      all, index = $1, $2.to_i\n      orig = macros.delete(index)\n      if execute && orig && orig =~ MACROS_RE\n        esc, all, macro, args, block = $2, $3, $4.downcase, $6.to_s, $7.try(:strip)\n        if esc.nil?\n          h(exec_macro(macro, obj, args, block) || all)\n        else\n          h(all)\n        end\n      elsif orig\n        h(orig)\n      else\n        h(all)\n      end\n    end\n  end\n\n  TOC_RE = /<p>\\{\\{((<|&lt;)|(>|&gt;))?toc\\}\\}<\\/p>/i unless const_defined?(:TOC_RE)\n\n  # Renders the TOC with given headings\n  def replace_toc(text, headings)\n    text.gsub!(TOC_RE) do\n      left_align, right_align = $2, $3\n      # Keep only the 4 first levels\n      headings = headings.select{|level, anchor, item| level <= 4}\n      if headings.empty?\n        ''\n      else\n        div_class = 'toc'\n        div_class << ' right' if right_align\n        div_class << ' left' if left_align\n        out = \"<ul class=\\\"#{div_class}\\\"><li><strong>#{l :label_table_of_contents}</strong></li><li>\"\n        root = headings.map(&:first).min\n        current = root\n        started = false\n        headings.each do |level, anchor, item|\n          if level > current\n            out << '<ul><li>' * (level - current)\n          elsif level < current\n            out << \"</li></ul>\\n\" * (current - level) + \"</li><li>\"\n          elsif started\n            out << '</li><li>'\n          end\n          out << \"<a href=\\\"##{anchor}\\\">#{item}</a>\"\n          current = level\n          started = true\n        end\n        out << '</li></ul>' * (current - root)\n        out << '</li></ul>'\n      end\n    end\n  end\n\n  # Same as Rails' simple_format helper without using paragraphs\n  def simple_format_without_paragraph(text)\n    text.to_s.\n      gsub(/\\r\\n?/, \"\\n\").                    # \\r\\n and \\r -> \\n\n      gsub(/\\n\\n+/, \"<br /><br />\").          # 2+ newline  -> 2 br\n      gsub(/([^\\n]\\n)(?=[^\\n])/, '\\1<br />'). # 1 newline   -> br\n      html_safe\n  end\n\n  def lang_options_for_select(blank=true)\n    (blank ? [[\"(auto)\", \"\"]] : []) + languages_options\n  end\n\n  def labelled_form_for(*args, &proc)\n    args << {} unless args.last.is_a?(Hash)\n    options = args.last\n    if args.first.is_a?(Symbol)\n      options.merge!(:as => args.shift)\n    end\n    options.merge!({:builder => Redmine::Views::LabelledFormBuilder})\n    form_for(*args, &proc)\n  end\n\n  def labelled_fields_for(*args, &proc)\n    args << {} unless args.last.is_a?(Hash)\n    options = args.last\n    options.merge!({:builder => Redmine::Views::LabelledFormBuilder})\n    fields_for(*args, &proc)\n  end\n\n  # Render the error messages for the given objects\n  def error_messages_for(*objects)\n    objects = objects.map {|o| o.is_a?(String) ? instance_variable_get(\"@#{o}\") : o}.compact\n    errors = objects.map {|o| o.errors.full_messages}.flatten\n    render_error_messages(errors)\n  end\n\n  # Renders a list of error messages\n  def render_error_messages(errors)\n    html = \"\"\n    if errors.present?\n      html << \"<div id='errorExplanation'><ul>\\n\"\n      errors.each do |error|\n        html << \"<li>#{h error}</li>\\n\"\n      end\n      html << \"</ul></div>\\n\"\n    end\n    html.html_safe\n  end\n\n  def delete_link(url, options={})\n    options = {\n      :method => :delete,\n      :data => {:confirm => l(:text_are_you_sure)},\n      :class => 'icon icon-del'\n    }.merge(options)\n\n    link_to l(:button_delete), url, options\n  end\n\n  def preview_link(url, form, target='preview', options={})\n    content_tag 'a', l(:label_preview), {\n        :href => \"#\",\n        :onclick => %|submitPreview(\"#{escape_javascript url_for(url)}\", \"#{escape_javascript form}\", \"#{escape_javascript target}\"); return false;|,\n        :accesskey => accesskey(:preview)\n      }.merge(options)\n  end\n\n  def link_to_function(name, function, html_options={})\n    content_tag(:a, name, {:href => '#', :onclick => \"#{function}; return false;\"}.merge(html_options))\n  end\n\n  # Helper to render JSON in views\n  def raw_json(arg)\n    arg.to_json.to_s.gsub('/', '\\/').html_safe\n  end\n\n  def back_url\n    url = params[:back_url]\n    if url.nil? && referer = request.env['HTTP_REFERER']\n      url = CGI.unescape(referer.to_s)\n      # URLs that contains the utf8=[checkmark] parameter added by Rails are\n      # parsed as invalid by URI.parse so the redirect to the back URL would\n      # not be accepted (ApplicationController#validate_back_url would return\n      # false)\n      url.gsub!(/(\\?|&)utf8=\\u2713&?/, '\\1')\n    end\n    url\n  end\n\n  def back_url_hidden_field_tag\n    url = back_url\n    hidden_field_tag('back_url', url, :id => nil) unless url.blank?\n  end\n\n  def check_all_links(form_name)\n    link_to_function(l(:button_check_all), \"checkAll('#{form_name}', true)\") +\n    \" | \".html_safe +\n    link_to_function(l(:button_uncheck_all), \"checkAll('#{form_name}', false)\")\n  end\n\n  def toggle_checkboxes_link(selector)\n    link_to_function '',\n      \"toggleCheckboxesBySelector('#{selector}')\",\n      :title => \"#{l(:button_check_all)} / #{l(:button_uncheck_all)}\",\n      :class => 'toggle-checkboxes'\n  end\n\n  def progress_bar(pcts, options={})\n    pcts = [pcts, pcts] unless pcts.is_a?(Array)\n    pcts = pcts.collect(&:round)\n    pcts[1] = pcts[1] - pcts[0]\n    pcts << (100 - pcts[1] - pcts[0])\n    titles = options[:titles].to_a\n    titles[0] = \"#{pcts[0]}%\" if titles[0].blank?\n    legend = options[:legend] || ''\n    content_tag('table',\n      content_tag('tr',\n        (pcts[0] > 0 ? content_tag('td', '', :style => \"width: #{pcts[0]}%;\", :class => 'closed', :title => titles[0]) : ''.html_safe) +\n        (pcts[1] > 0 ? content_tag('td', '', :style => \"width: #{pcts[1]}%;\", :class => 'done', :title => titles[1]) : ''.html_safe) +\n        (pcts[2] > 0 ? content_tag('td', '', :style => \"width: #{pcts[2]}%;\", :class => 'todo', :title => titles[2]) : ''.html_safe)\n      ), :class => \"progress progress-#{pcts[0]}\").html_safe +\n      content_tag('p', legend, :class => 'percent').html_safe\n  end\n\n  def checked_image(checked=true)\n    if checked\n      @checked_image_tag ||= content_tag(:span, nil, :class => 'icon-only icon-checked')\n    end\n  end\n\n  def context_menu\n    unless @context_menu_included\n      content_for :header_tags do\n        javascript_include_tag('context_menu') +\n          stylesheet_link_tag('context_menu')\n      end\n      if l(:direction) == 'rtl'\n        content_for :header_tags do\n          stylesheet_link_tag('context_menu_rtl')\n        end\n      end\n      @context_menu_included = true\n    end\n    nil\n  end\n\n  def calendar_for(field_id)\n    include_calendar_headers_tags\n    javascript_tag(\"$(function() { $('##{field_id}').addClass('date').datepickerFallback(datepickerOptions); });\")\n  end\n\n  def include_calendar_headers_tags\n    unless @calendar_headers_tags_included\n      tags = ''.html_safe\n      @calendar_headers_tags_included = true\n      content_for :header_tags do\n        start_of_week = Setting.start_of_week\n        start_of_week = l(:general_first_day_of_week, :default => '1') if start_of_week.blank?\n        # Redmine uses 1..7 (monday..sunday) in settings and locales\n        # JQuery uses 0..6 (sunday..saturday), 7 needs to be changed to 0\n        start_of_week = start_of_week.to_i % 7\n        tags << javascript_tag(\n                   \"var datepickerOptions={dateFormat: 'yy-mm-dd', firstDay: #{start_of_week}, \" +\n                     \"showOn: 'button', buttonImageOnly: true, buttonImage: '\" +\n                     path_to_image('/images/calendar.png') +\n                     \"', showButtonPanel: true, showWeek: true, showOtherMonths: true, \" +\n                     \"selectOtherMonths: true, changeMonth: true, changeYear: true, \" +\n                     \"beforeShow: beforeShowDatePicker};\")\n        jquery_locale = l('jquery.locale', :default => current_language.to_s)\n        unless jquery_locale == 'en'\n          tags << javascript_include_tag(\"i18n/datepicker-#{jquery_locale}.js\")\n        end\n        tags\n      end\n    end\n  end\n\n  # Overrides Rails' stylesheet_link_tag with themes and plugins support.\n  # Examples:\n  #   stylesheet_link_tag('styles') # => picks styles.css from the current theme or defaults\n  #   stylesheet_link_tag('styles', :plugin => 'foo) # => picks styles.css from plugin's assets\n  #\n  def stylesheet_link_tag(*sources)\n    options = sources.last.is_a?(Hash) ? sources.pop : {}\n    plugin = options.delete(:plugin)\n    sources = sources.map do |source|\n      if plugin\n        \"/plugin_assets/#{plugin}/stylesheets/#{source}\"\n      elsif current_theme && current_theme.stylesheets.include?(source)\n        current_theme.stylesheet_path(source)\n      else\n        source\n      end\n    end\n    super *sources, options\n  end\n\n  # Overrides Rails' image_tag with themes and plugins support.\n  # Examples:\n  #   image_tag('image.png') # => picks image.png from the current theme or defaults\n  #   image_tag('image.png', :plugin => 'foo) # => picks image.png from plugin's assets\n  #\n  def image_tag(source, options={})\n    if plugin = options.delete(:plugin)\n      source = \"/plugin_assets/#{plugin}/images/#{source}\"\n    elsif current_theme && current_theme.images.include?(source)\n      source = current_theme.image_path(source)\n    end\n    super source, options\n  end\n\n  # Overrides Rails' javascript_include_tag with plugins support\n  # Examples:\n  #   javascript_include_tag('scripts') # => picks scripts.js from defaults\n  #   javascript_include_tag('scripts', :plugin => 'foo) # => picks scripts.js from plugin's assets\n  #\n  def javascript_include_tag(*sources)\n    options = sources.last.is_a?(Hash) ? sources.pop : {}\n    if plugin = options.delete(:plugin)\n      sources = sources.map do |source|\n        if plugin\n          \"/plugin_assets/#{plugin}/javascripts/#{source}\"\n        else\n          source\n        end\n      end\n    end\n    super *sources, options\n  end\n\n  def sidebar_content?\n    content_for?(:sidebar) || view_layouts_base_sidebar_hook_response.present?\n  end\n\n  def view_layouts_base_sidebar_hook_response\n    @view_layouts_base_sidebar_hook_response ||= call_hook(:view_layouts_base_sidebar)\n  end\n\n  def email_delivery_enabled?\n    !!ActionMailer::Base.perform_deliveries\n  end\n\n  # Returns the avatar image tag for the given +user+ if avatars are enabled\n  # +user+ can be a User or a string that will be scanned for an email address (eg. 'joe <joe@foo.bar>')\n  def avatar(user, options = { })\n    if Setting.gravatar_enabled?\n      options.merge!(:default => Setting.gravatar_default)\n      email = nil\n      if user.respond_to?(:mail)\n        email = user.mail\n      elsif user.to_s =~ %r{<(.+?)>}\n        email = $1\n      end\n      return gravatar(email.to_s.downcase, options) unless email.blank? rescue nil\n    else\n      ''\n    end\n  end\n\n  # Returns a link to edit user's avatar if avatars are enabled\n  def avatar_edit_link(user, options={})\n    if Setting.gravatar_enabled?\n      url = \"https://gravatar.com\"\n      link_to avatar(user, {:title => l(:button_edit)}.merge(options)), url, :target => '_blank'\n    end\n  end\n\n  def sanitize_anchor_name(anchor)\n    anchor.gsub(%r{[^\\s\\-\\p{Word}]}, '').gsub(%r{\\s+(\\-+\\s*)?}, '-')\n  end\n\n  # Returns the javascript tags that are included in the html layout head\n  def javascript_heads\n    tags = javascript_include_tag('jquery-1.11.1-ui-1.11.0-ujs-4.3.1', 'application', 'responsive')\n    unless User.current.pref.warn_on_leaving_unsaved == '0'\n      tags << \"\\n\".html_safe + javascript_tag(\"$(window).load(function(){ warnLeavingUnsaved('#{escape_javascript l(:text_warn_on_leaving_unsaved)}'); });\")\n    end\n    tags\n  end\n\n  def favicon\n    \"<link rel='shortcut icon' href='#{favicon_path}' />\".html_safe\n  end\n\n  # Returns the path to the favicon\n  def favicon_path\n    icon = (current_theme && current_theme.favicon?) ? current_theme.favicon_path : '/favicon.ico'\n    image_path(icon)\n  end\n\n  # Returns the full URL to the favicon\n  def favicon_url\n    # TODO: use #image_url introduced in Rails4\n    path = favicon_path\n    base = url_for(:controller => 'welcome', :action => 'index', :only_path => false)\n    base.sub(%r{/+$},'') + '/' + path.sub(%r{^/+},'')\n  end\n\n  def robot_exclusion_tag\n    '<meta name=\"robots\" content=\"noindex,follow,noarchive\" />'.html_safe\n  end\n\n  # Returns true if arg is expected in the API response\n  def include_in_api_response?(arg)\n    unless @included_in_api_response\n      param = params[:include]\n      @included_in_api_response = param.is_a?(Array) ? param.collect(&:to_s) : param.to_s.split(',')\n      @included_in_api_response.collect!(&:strip)\n    end\n    @included_in_api_response.include?(arg.to_s)\n  end\n\n  # Returns options or nil if nometa param or X-Redmine-Nometa header\n  # was set in the request\n  def api_meta(options)\n    if params[:nometa].present? || request.headers['X-Redmine-Nometa']\n      # compatibility mode for activeresource clients that raise\n      # an error when deserializing an array with attributes\n      nil\n    else\n      options\n    end\n  end\n\n  def generate_csv(&block)\n    decimal_separator = l(:general_csv_decimal_separator)\n    encoding = l(:general_csv_encoding)\n  end\n\n  private\n\n  def wiki_helper\n    helper = Redmine::WikiFormatting.helper_for(Setting.text_formatting)\n    extend helper\n    return self\n  end\n\n  # remove double quotes if any\n  def remove_double_quotes(identifier)\n    name = identifier.gsub(%r{^\"(.*)\"$}, \"\\\\1\")\n    return CGI.unescapeHTML(name)\n  end\nend\n"], "fixing_code": ["# encoding: utf-8\n#\n# Redmine - project management software\n# Copyright (C) 2006-2017  Jean-Philippe Lang\n#\n# This program is free software; you can redistribute it and/or\n# modify it under the terms of the GNU General Public License\n# as published by the Free Software Foundation; either version 2\n# of the License, or (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n\nrequire 'forwardable'\nrequire 'cgi'\n\nmodule ApplicationHelper\n  include Redmine::WikiFormatting::Macros::Definitions\n  include Redmine::I18n\n  include GravatarHelper::PublicMethods\n  include Redmine::Pagination::Helper\n  include Redmine::SudoMode::Helper\n  include Redmine::Themes::Helper\n  include Redmine::Hook::Helper\n  include Redmine::Helpers::URL\n\n  extend Forwardable\n  def_delegators :wiki_helper, :wikitoolbar_for, :heads_for_wiki_formatter\n\n  # Return true if user is authorized for controller/action, otherwise false\n  def authorize_for(controller, action)\n    User.current.allowed_to?({:controller => controller, :action => action}, @project)\n  end\n\n  # Display a link if user is authorized\n  #\n  # @param [String] name Anchor text (passed to link_to)\n  # @param [Hash] options Hash params. This will checked by authorize_for to see if the user is authorized\n  # @param [optional, Hash] html_options Options passed to link_to\n  # @param [optional, Hash] parameters_for_method_reference Extra parameters for link_to\n  def link_to_if_authorized(name, options = {}, html_options = nil, *parameters_for_method_reference)\n    link_to(name, options, html_options, *parameters_for_method_reference) if authorize_for(options[:controller] || params[:controller], options[:action])\n  end\n\n  # Displays a link to user's account page if active\n  def link_to_user(user, options={})\n    if user.is_a?(User)\n      name = h(user.name(options[:format]))\n      if user.active? || (User.current.admin? && user.logged?)\n        only_path = options[:only_path].nil? ? true : options[:only_path]\n        link_to name, user_url(user, :only_path => only_path), :class => user.css_classes\n      else\n        name\n      end\n    else\n      h(user.to_s)\n    end\n  end\n\n  # Displays a link to +issue+ with its subject.\n  # Examples:\n  #\n  #   link_to_issue(issue)                        # => Defect #6: This is the subject\n  #   link_to_issue(issue, :truncate => 6)        # => Defect #6: This i...\n  #   link_to_issue(issue, :subject => false)     # => Defect #6\n  #   link_to_issue(issue, :project => true)      # => Foo - Defect #6\n  #   link_to_issue(issue, :subject => false, :tracker => false)     # => #6\n  #\n  def link_to_issue(issue, options={})\n    title = nil\n    subject = nil\n    text = options[:tracker] == false ? \"##{issue.id}\" : \"#{issue.tracker} ##{issue.id}\"\n    if options[:subject] == false\n      title = issue.subject.truncate(60)\n    else\n      subject = issue.subject\n      if truncate_length = options[:truncate]\n        subject = subject.truncate(truncate_length)\n      end\n    end\n    only_path = options[:only_path].nil? ? true : options[:only_path]\n    s = link_to(text, issue_url(issue, :only_path => only_path),\n                :class => issue.css_classes, :title => title)\n    s << h(\": #{subject}\") if subject\n    s = h(\"#{issue.project} - \") + s if options[:project]\n    s\n  end\n\n  # Generates a link to an attachment.\n  # Options:\n  # * :text - Link text (default to attachment filename)\n  # * :download - Force download (default: false)\n  def link_to_attachment(attachment, options={})\n    text = options.delete(:text) || attachment.filename\n    route_method = options.delete(:download) ? :download_named_attachment_url : :named_attachment_url\n    html_options = options.slice!(:only_path)\n    options[:only_path] = true unless options.key?(:only_path)\n    url = send(route_method, attachment, attachment.filename, options)\n    link_to text, url, html_options\n  end\n\n  # Generates a link to a SCM revision\n  # Options:\n  # * :text - Link text (default to the formatted revision)\n  def link_to_revision(revision, repository, options={})\n    if repository.is_a?(Project)\n      repository = repository.repository\n    end\n    text = options.delete(:text) || format_revision(revision)\n    rev = revision.respond_to?(:identifier) ? revision.identifier : revision\n    link_to(\n        h(text),\n        {:controller => 'repositories', :action => 'revision', :id => repository.project, :repository_id => repository.identifier_param, :rev => rev},\n        :title => l(:label_revision_id, format_revision(revision)),\n        :accesskey => options[:accesskey]\n      )\n  end\n\n  # Generates a link to a message\n  def link_to_message(message, options={}, html_options = nil)\n    link_to(\n      message.subject.truncate(60),\n      board_message_url(message.board_id, message.parent_id || message.id, {\n        :r => (message.parent_id && message.id),\n        :anchor => (message.parent_id ? \"message-#{message.id}\" : nil),\n        :only_path => true\n      }.merge(options)),\n      html_options\n    )\n  end\n\n  # Generates a link to a project if active\n  # Examples:\n  #\n  #   link_to_project(project)                          # => link to the specified project overview\n  #   link_to_project(project, {:only_path => false}, :class => \"project\") # => 3rd arg adds html options\n  #   link_to_project(project, {}, :class => \"project\") # => html options with default url (project overview)\n  #\n  def link_to_project(project, options={}, html_options = nil)\n    if project.archived?\n      h(project.name)\n    else\n      link_to project.name,\n        project_url(project, {:only_path => true}.merge(options)),\n        html_options\n    end\n  end\n\n  # Generates a link to a project settings if active\n  def link_to_project_settings(project, options={}, html_options=nil)\n    if project.active?\n      link_to project.name, settings_project_path(project, options), html_options\n    elsif project.archived?\n      h(project.name)\n    else\n      link_to project.name, project_path(project, options), html_options\n    end\n  end\n\n  # Generates a link to a version\n  def link_to_version(version, options = {})\n    return '' unless version && version.is_a?(Version)\n    options = {:title => format_date(version.effective_date)}.merge(options)\n    link_to_if version.visible?, format_version_name(version), version_path(version), options\n  end\n\n  # Helper that formats object for html or text rendering\n  def format_object(object, html=true, &block)\n    if block_given?\n      object = yield object\n    end\n    case object.class.name\n    when 'Array'\n      formatted_objects = object.map {|o| format_object(o, html)}\n      html ? safe_join(formatted_objects, ', ') : formatted_objects.join(', ')\n    when 'Time'\n      format_time(object)\n    when 'Date'\n      format_date(object)\n    when 'Fixnum'\n      object.to_s\n    when 'Float'\n      sprintf \"%.2f\", object\n    when 'User'\n      html ? link_to_user(object) : object.to_s\n    when 'Project'\n      html ? link_to_project(object) : object.to_s\n    when 'Version'\n      html ? link_to_version(object) : object.to_s\n    when 'TrueClass'\n      l(:general_text_Yes)\n    when 'FalseClass'\n      l(:general_text_No)\n    when 'Issue'\n      object.visible? && html ? link_to_issue(object) : \"##{object.id}\"\n    when 'Attachment'\n      html ? link_to_attachment(object) : object.filename\n    when 'CustomValue', 'CustomFieldValue'\n      if object.custom_field\n        f = object.custom_field.format.formatted_custom_value(self, object, html)\n        if f.nil? || f.is_a?(String)\n          f\n        else\n          format_object(f, html, &block)\n        end\n      else\n        object.value.to_s\n      end\n    else\n      html ? h(object) : object.to_s\n    end\n  end\n\n  def wiki_page_path(page, options={})\n    url_for({:controller => 'wiki', :action => 'show', :project_id => page.project, :id => page.title}.merge(options))\n  end\n\n  def thumbnail_tag(attachment)\n    thumbnail_size = Setting.thumbnails_size.to_i\n    link_to(\n      image_tag(\n        thumbnail_path(attachment),\n        :srcset => \"#{thumbnail_path(attachment, :size => thumbnail_size * 2)} 2x\",\n        :style => \"max-width: #{thumbnail_size}px; max-height: #{thumbnail_size}px;\"\n      ),\n      named_attachment_path(\n        attachment,\n        attachment.filename\n      ),\n      :title => attachment.filename\n    )\n  end\n\n  def toggle_link(name, id, options={})\n    onclick = \"$('##{id}').toggle(); \"\n    onclick << (options[:focus] ? \"$('##{options[:focus]}').focus(); \" : \"this.blur(); \")\n    onclick << \"$(window).scrollTop($('##{options[:focus]}').position().top); \" if options[:scroll]\n    onclick << \"return false;\"\n    link_to(name, \"#\", :onclick => onclick)\n  end\n\n  # Used to format item titles on the activity view\n  def format_activity_title(text)\n    text\n  end\n\n  def format_activity_day(date)\n    date == User.current.today ? l(:label_today).titleize : format_date(date)\n  end\n\n  def format_activity_description(text)\n    h(text.to_s.truncate(120).gsub(%r{[\\r\\n]*<(pre|code)>.*$}m, '...')\n       ).gsub(/[\\r\\n]+/, \"<br />\").html_safe\n  end\n\n  def format_version_name(version)\n    if version.project == @project\n      h(version)\n    else\n      h(\"#{version.project} - #{version}\")\n    end\n  end\n\n  def format_changeset_comments(changeset, options={})\n    method = options[:short] ? :short_comments : :comments\n    textilizable changeset, method, :formatting => Setting.commit_logs_formatting?\n  end\n\n  def due_date_distance_in_words(date)\n    if date\n      l((date < User.current.today ? :label_roadmap_overdue : :label_roadmap_due_in), distance_of_date_in_words(User.current.today, date))\n    end\n  end\n\n  # Renders a tree of projects as a nested set of unordered lists\n  # The given collection may be a subset of the whole project tree\n  # (eg. some intermediate nodes are private and can not be seen)\n  def render_project_nested_lists(projects, &block)\n    s = ''\n    if projects.any?\n      ancestors = []\n      original_project = @project\n      projects.sort_by(&:lft).each do |project|\n        # set the project environment to please macros.\n        @project = project\n        if (ancestors.empty? || project.is_descendant_of?(ancestors.last))\n          s << \"<ul class='projects #{ ancestors.empty? ? 'root' : nil}'>\\n\"\n        else\n          ancestors.pop\n          s << \"</li>\"\n          while (ancestors.any? && !project.is_descendant_of?(ancestors.last))\n            ancestors.pop\n            s << \"</ul></li>\\n\"\n          end\n        end\n        classes = (ancestors.empty? ? 'root' : 'child')\n        s << \"<li class='#{classes}'><div class='#{classes}'>\"\n        s << h(block_given? ? capture(project, &block) : project.name)\n        s << \"</div>\\n\"\n        ancestors << project\n      end\n      s << (\"</li></ul>\\n\" * ancestors.size)\n      @project = original_project\n    end\n    s.html_safe\n  end\n\n  def render_page_hierarchy(pages, node=nil, options={})\n    content = ''\n    if pages[node]\n      content << \"<ul class=\\\"pages-hierarchy\\\">\\n\"\n      pages[node].each do |page|\n        content << \"<li>\"\n        content << link_to(h(page.pretty_title), {:controller => 'wiki', :action => 'show', :project_id => page.project, :id => page.title, :version => nil},\n                           :title => (options[:timestamp] && page.updated_on ? l(:label_updated_time, distance_of_time_in_words(Time.now, page.updated_on)) : nil))\n        content << \"\\n\" + render_page_hierarchy(pages, page.id, options) if pages[page.id]\n        content << \"</li>\\n\"\n      end\n      content << \"</ul>\\n\"\n    end\n    content.html_safe\n  end\n\n  # Renders flash messages\n  def render_flash_messages\n    s = ''\n    flash.each do |k,v|\n      s << content_tag('div', v.html_safe, :class => \"flash #{k}\", :id => \"flash_#{k}\")\n    end\n    s.html_safe\n  end\n\n  # Renders tabs and their content\n  def render_tabs(tabs, selected=params[:tab])\n    if tabs.any?\n      unless tabs.detect {|tab| tab[:name] == selected}\n        selected = nil\n      end\n      selected ||= tabs.first[:name]\n      render :partial => 'common/tabs', :locals => {:tabs => tabs, :selected_tab => selected}\n    else\n      content_tag 'p', l(:label_no_data), :class => \"nodata\"\n    end\n  end\n\n  # Returns the default scope for the quick search form\n  # Could be 'all', 'my_projects', 'subprojects' or nil (current project)\n  def default_search_project_scope\n    if @project && !@project.leaf?\n      'subprojects'\n    end\n  end\n\n  # Returns an array of projects that are displayed in the quick-jump box\n  def projects_for_jump_box(user=User.current)\n    if user.logged?\n      user.projects.active.select(:id, :name, :identifier, :lft, :rgt).to_a\n    else\n      []\n    end\n  end\n\n  def render_projects_for_jump_box(projects, selected=nil)\n    jump = params[:jump].presence || current_menu_item\n    s = ''.html_safe\n    project_tree(projects) do |project, level|\n      padding = level * 16\n      text = content_tag('span', project.name, :style => \"padding-left:#{padding}px;\")\n      s << link_to(text, project_path(project, :jump => jump), :title => project.name, :class => (project == selected ? 'selected' : nil))\n    end\n    s\n  end\n\n  # Renders the project quick-jump box\n  def render_project_jump_box\n    projects = projects_for_jump_box(User.current)\n    if @project && @project.persisted?\n      text = @project.name_was\n    end\n    text ||= l(:label_jump_to_a_project)\n    url = autocomplete_projects_path(:format => 'js', :jump => current_menu_item)\n\n    trigger = content_tag('span', text, :class => 'drdn-trigger')\n    q = text_field_tag('q', '', :id => 'projects-quick-search', :class => 'autocomplete', :data => {:automcomplete_url => url}, :autocomplete => 'off')\n    all = link_to(l(:label_project_all), projects_path(:jump => current_menu_item), :class => (@project.nil? && controller.class.main_menu ? 'selected' : nil))\n    content = content_tag('div',\n          content_tag('div', q, :class => 'quick-search') +\n          content_tag('div', render_projects_for_jump_box(projects, @project), :class => 'drdn-items projects selection') +\n          content_tag('div', all, :class => 'drdn-items all-projects selection'),\n        :class => 'drdn-content'\n      )\n\n    content_tag('div', trigger + content, :id => \"project-jump\", :class => \"drdn\")\n  end\n\n  def project_tree_options_for_select(projects, options = {})\n    s = ''.html_safe\n    if blank_text = options[:include_blank]\n      if blank_text == true\n        blank_text = '&nbsp;'.html_safe\n      end\n      s << content_tag('option', blank_text, :value => '')\n    end\n    project_tree(projects) do |project, level|\n      name_prefix = (level > 0 ? '&nbsp;' * 2 * level + '&#187; ' : '').html_safe\n      tag_options = {:value => project.id}\n      if project == options[:selected] || (options[:selected].respond_to?(:include?) && options[:selected].include?(project))\n        tag_options[:selected] = 'selected'\n      else\n        tag_options[:selected] = nil\n      end\n      tag_options.merge!(yield(project)) if block_given?\n      s << content_tag('option', name_prefix + h(project), tag_options)\n    end\n    s.html_safe\n  end\n\n  # Yields the given block for each project with its level in the tree\n  #\n  # Wrapper for Project#project_tree\n  def project_tree(projects, options={}, &block)\n    Project.project_tree(projects, options, &block)\n  end\n\n  def principals_check_box_tags(name, principals)\n    s = ''\n    principals.each do |principal|\n      s << \"<label>#{ check_box_tag name, principal.id, false, :id => nil } #{h principal}</label>\\n\"\n    end\n    s.html_safe\n  end\n\n  # Returns a string for users/groups option tags\n  def principals_options_for_select(collection, selected=nil)\n    s = ''\n    if collection.include?(User.current)\n      s << content_tag('option', \"<< #{l(:label_me)} >>\", :value => User.current.id)\n    end\n    groups = ''\n    collection.sort.each do |element|\n      selected_attribute = ' selected=\"selected\"' if option_value_selected?(element, selected) || element.id.to_s == selected\n      (element.is_a?(Group) ? groups : s) << %(<option value=\"#{element.id}\"#{selected_attribute}>#{h element.name}</option>)\n    end\n    unless groups.empty?\n      s << %(<optgroup label=\"#{h(l(:label_group_plural))}\">#{groups}</optgroup>)\n    end\n    s.html_safe\n  end\n\n  def option_tag(name, text, value, selected=nil, options={})\n    content_tag 'option', value, options.merge(:value => value, :selected => (value == selected))\n  end\n\n  def truncate_single_line_raw(string, length)\n    string.to_s.truncate(length).gsub(%r{[\\r\\n]+}m, ' ')\n  end\n\n  # Truncates at line break after 250 characters or options[:length]\n  def truncate_lines(string, options={})\n    length = options[:length] || 250\n    if string.to_s =~ /\\A(.{#{length}}.*?)$/m\n      \"#{$1}...\"\n    else\n      string\n    end\n  end\n\n  def anchor(text)\n    text.to_s.gsub(' ', '_')\n  end\n\n  def html_hours(text)\n    text.gsub(%r{(\\d+)([\\.:])(\\d+)}, '<span class=\"hours hours-int\">\\1</span><span class=\"hours hours-dec\">\\2\\3</span>').html_safe\n  end\n\n  def authoring(created, author, options={})\n    l(options[:label] || :label_added_time_by, :author => link_to_user(author), :age => time_tag(created)).html_safe\n  end\n\n  def time_tag(time)\n    text = distance_of_time_in_words(Time.now, time)\n    if @project\n      link_to(text, project_activity_path(@project, :from => User.current.time_to_date(time)), :title => format_time(time))\n    else\n      content_tag('abbr', text, :title => format_time(time))\n    end\n  end\n\n  def syntax_highlight_lines(name, content)\n    syntax_highlight(name, content).each_line.to_a\n  end\n\n  def syntax_highlight(name, content)\n    Redmine::SyntaxHighlighting.highlight_by_filename(content, name)\n  end\n\n  def to_path_param(path)\n    str = path.to_s.split(%r{[/\\\\]}).select{|p| !p.blank?}.join(\"/\")\n    str.blank? ? nil : str\n  end\n\n  def reorder_handle(object, options={})\n    data = {\n      :reorder_url => options[:url] || url_for(object),\n      :reorder_param => options[:param] || object.class.name.underscore\n    }\n    content_tag('span', '',\n      :class => \"sort-handle\",\n      :data => data,\n      :title => l(:button_sort))\n  end\n\n  def breadcrumb(*args)\n    elements = args.flatten\n    elements.any? ? content_tag('p', (args.join(\" \\xc2\\xbb \") + \" \\xc2\\xbb \").html_safe, :class => 'breadcrumb') : nil\n  end\n\n  def other_formats_links(&block)\n    concat('<p class=\"other-formats\">'.html_safe + l(:label_export_to))\n    yield Redmine::Views::OtherFormatsBuilder.new(self)\n    concat('</p>'.html_safe)\n  end\n\n  def page_header_title\n    if @project.nil? || @project.new_record?\n      h(Setting.app_title)\n    else\n      b = []\n      ancestors = (@project.root? ? [] : @project.ancestors.visible.to_a)\n      if ancestors.any?\n        root = ancestors.shift\n        b << link_to_project(root, {:jump => current_menu_item}, :class => 'root')\n        if ancestors.size > 2\n          b << \"\\xe2\\x80\\xa6\"\n          ancestors = ancestors[-2, 2]\n        end\n        b += ancestors.collect {|p| link_to_project(p, {:jump => current_menu_item}, :class => 'ancestor') }\n      end\n      b << content_tag(:span, h(@project), class: 'current-project')\n      if b.size > 1\n        separator = content_tag(:span, ' &raquo; '.html_safe, class: 'separator')\n        path = safe_join(b[0..-2], separator) + separator\n        b = [content_tag(:span, path.html_safe, class: 'breadcrumbs'), b[-1]]\n      end\n      safe_join b\n    end\n  end\n\n  # Returns a h2 tag and sets the html title with the given arguments\n  def title(*args)\n    strings = args.map do |arg|\n      if arg.is_a?(Array) && arg.size >= 2\n        link_to(*arg)\n      else\n        h(arg.to_s)\n      end\n    end\n    html_title args.reverse.map {|s| (s.is_a?(Array) ? s.first : s).to_s}\n    content_tag('h2', strings.join(' &#187; ').html_safe)\n  end\n\n  # Sets the html title\n  # Returns the html title when called without arguments\n  # Current project name and app_title and automatically appended\n  # Exemples:\n  #   html_title 'Foo', 'Bar'\n  #   html_title # => 'Foo - Bar - My Project - Redmine'\n  def html_title(*args)\n    if args.empty?\n      title = @html_title || []\n      title << @project.name if @project\n      title << Setting.app_title unless Setting.app_title == title.last\n      title.reject(&:blank?).join(' - ')\n    else\n      @html_title ||= []\n      @html_title += args\n    end\n  end\n\n  # Returns the theme, controller name, and action as css classes for the\n  # HTML body.\n  def body_css_classes\n    css = []\n    if theme = Redmine::Themes.theme(Setting.ui_theme)\n      css << 'theme-' + theme.name\n    end\n\n    css << 'project-' + @project.identifier if @project && @project.identifier.present?\n    css << 'controller-' + controller_name\n    css << 'action-' + action_name\n    css << 'avatars-' + (Setting.gravatar_enabled? ? 'on' : 'off')\n    if UserPreference::TEXTAREA_FONT_OPTIONS.include?(User.current.pref.textarea_font)\n      css << \"textarea-#{User.current.pref.textarea_font}\"\n    end\n    css.join(' ')\n  end\n\n  def accesskey(s)\n    @used_accesskeys ||= []\n    key = Redmine::AccessKeys.key_for(s)\n    return nil if @used_accesskeys.include?(key)\n    @used_accesskeys << key\n    key\n  end\n\n  # Formats text according to system settings.\n  # 2 ways to call this method:\n  # * with a String: textilizable(text, options)\n  # * with an object and one of its attribute: textilizable(issue, :description, options)\n  def textilizable(*args)\n    options = args.last.is_a?(Hash) ? args.pop : {}\n    case args.size\n    when 1\n      obj = options[:object]\n      text = args.shift\n    when 2\n      obj = args.shift\n      attr = args.shift\n      text = obj.send(attr).to_s\n    else\n      raise ArgumentError, 'invalid arguments to textilizable'\n    end\n    return '' if text.blank?\n    project = options[:project] || @project || (obj && obj.respond_to?(:project) ? obj.project : nil)\n    @only_path = only_path = options.delete(:only_path) == false ? false : true\n\n    text = text.dup\n    macros = catch_macros(text)\n\n    if options[:formatting] == false\n      text = h(text)\n    else\n      formatting = Setting.text_formatting\n      text = Redmine::WikiFormatting.to_html(formatting, text, :object => obj, :attribute => attr)\n    end\n\n    @parsed_headings = []\n    @heading_anchors = {}\n    @current_section = 0 if options[:edit_section_links]\n\n    parse_sections(text, project, obj, attr, only_path, options)\n    text = parse_non_pre_blocks(text, obj, macros) do |text|\n      [:parse_inline_attachments, :parse_hires_images, :parse_wiki_links, :parse_redmine_links].each do |method_name|\n        send method_name, text, project, obj, attr, only_path, options\n      end\n    end\n    parse_headings(text, project, obj, attr, only_path, options)\n\n    if @parsed_headings.any?\n      replace_toc(text, @parsed_headings)\n    end\n\n    text.html_safe\n  end\n\n  def parse_non_pre_blocks(text, obj, macros)\n    s = StringScanner.new(text)\n    tags = []\n    parsed = ''\n    while !s.eos?\n      s.scan(/(.*?)(<(\\/)?(pre|code)(.*?)>|\\z)/im)\n      text, full_tag, closing, tag = s[1], s[2], s[3], s[4]\n      if tags.empty?\n        yield text\n        inject_macros(text, obj, macros) if macros.any?\n      else\n        inject_macros(text, obj, macros, false) if macros.any?\n      end\n      parsed << text\n      if tag\n        if closing\n          if tags.last && tags.last.casecmp(tag) == 0\n            tags.pop\n          end\n        else\n          tags << tag.downcase\n        end\n        parsed << full_tag\n      end\n    end\n    # Close any non closing tags\n    while tag = tags.pop\n      parsed << \"</#{tag}>\"\n    end\n    parsed\n  end\n\n  # add srcset attribute to img tags if filename includes @2x, @3x, etc.\n  # to support hires displays\n  def parse_hires_images(text, project, obj, attr, only_path, options)\n    text.gsub!(/src=\"([^\"]+@(\\dx)\\.(bmp|gif|jpg|jpe|jpeg|png))\"/i) do |m|\n      filename, dpr = $1, $2\n      m + \" srcset=\\\"#{filename} #{dpr}\\\"\"\n    end\n  end\n\n  def parse_inline_attachments(text, project, obj, attr, only_path, options)\n    return if options[:inline_attachments] == false\n\n    # when using an image link, try to use an attachment, if possible\n    attachments = options[:attachments] || []\n    attachments += obj.attachments if obj.respond_to?(:attachments)\n    if attachments.present?\n      text.gsub!(/src=\"([^\\/\"]+\\.(bmp|gif|jpg|jpe|jpeg|png))\"(\\s+alt=\"([^\"]*)\")?/i) do |m|\n        filename, ext, alt, alttext = $1.downcase, $2, $3, $4\n        # search for the picture in attachments\n        if found = Attachment.latest_attach(attachments, CGI.unescape(filename))\n          image_url = download_named_attachment_url(found, found.filename, :only_path => only_path)\n          desc = found.description.to_s.gsub('\"', '')\n          if !desc.blank? && alttext.blank?\n            alt = \" title=\\\"#{desc}\\\" alt=\\\"#{desc}\\\"\"\n          end\n          \"src=\\\"#{image_url}\\\"#{alt}\"\n        else\n          m\n        end\n      end\n    end\n  end\n\n  # Wiki links\n  #\n  # Examples:\n  #   [[mypage]]\n  #   [[mypage|mytext]]\n  # wiki links can refer other project wikis, using project name or identifier:\n  #   [[project:]] -> wiki starting page\n  #   [[project:|mytext]]\n  #   [[project:mypage]]\n  #   [[project:mypage|mytext]]\n  def parse_wiki_links(text, project, obj, attr, only_path, options)\n    text.gsub!(/(!)?(\\[\\[([^\\]\\n\\|]+)(\\|([^\\]\\n\\|]+))?\\]\\])/) do |m|\n      link_project = project\n      esc, all, page, title = $1, $2, $3, $5\n      if esc.nil?\n        if page =~ /^([^\\:]+)\\:(.*)$/\n          identifier, page = $1, $2\n          link_project = Project.find_by_identifier(identifier) || Project.find_by_name(identifier)\n          title ||= identifier if page.blank?\n        end\n\n        if link_project && link_project.wiki && User.current.allowed_to?(:view_wiki_pages, link_project)\n          # extract anchor\n          anchor = nil\n          if page =~ /^(.+?)\\#(.+)$/\n            page, anchor = $1, $2\n          end\n          anchor = sanitize_anchor_name(anchor) if anchor.present?\n          # check if page exists\n          wiki_page = link_project.wiki.find_page(page)\n          url = if anchor.present? && wiki_page.present? && (obj.is_a?(WikiContent) || obj.is_a?(WikiContent::Version)) && obj.page == wiki_page\n            \"##{anchor}\"\n          else\n            case options[:wiki_links]\n            when :local; \"#{page.present? ? Wiki.titleize(page) : ''}.html\" + (anchor.present? ? \"##{anchor}\" : '')\n            when :anchor; \"##{page.present? ? Wiki.titleize(page) : title}\" + (anchor.present? ? \"_#{anchor}\" : '') # used for single-file wiki export\n            else\n              wiki_page_id = page.present? ? Wiki.titleize(page) : nil\n              parent = wiki_page.nil? && obj.is_a?(WikiContent) && obj.page && project == link_project ? obj.page.title : nil\n              url_for(:only_path => only_path, :controller => 'wiki', :action => 'show', :project_id => link_project,\n               :id => wiki_page_id, :version => nil, :anchor => anchor, :parent => parent)\n            end\n          end\n          link_to(title.present? ? title.html_safe : h(page), url, :class => ('wiki-page' + (wiki_page ? '' : ' new')))\n        else\n          # project or wiki doesn't exist\n          all\n        end\n      else\n        all\n      end\n    end\n  end\n\n  # Redmine links\n  #\n  # Examples:\n  #   Issues:\n  #     #52 -> Link to issue #52\n  #   Changesets:\n  #     r52 -> Link to revision 52\n  #     commit:a85130f -> Link to scmid starting with a85130f\n  #   Documents:\n  #     document#17 -> Link to document with id 17\n  #     document:Greetings -> Link to the document with title \"Greetings\"\n  #     document:\"Some document\" -> Link to the document with title \"Some document\"\n  #   Versions:\n  #     version#3 -> Link to version with id 3\n  #     version:1.0.0 -> Link to version named \"1.0.0\"\n  #     version:\"1.0 beta 2\" -> Link to version named \"1.0 beta 2\"\n  #   Attachments:\n  #     attachment:file.zip -> Link to the attachment of the current object named file.zip\n  #   Source files:\n  #     source:some/file -> Link to the file located at /some/file in the project's repository\n  #     source:some/file@52 -> Link to the file's revision 52\n  #     source:some/file#L120 -> Link to line 120 of the file\n  #     source:some/file@52#L120 -> Link to line 120 of the file's revision 52\n  #     export:some/file -> Force the download of the file\n  #   Forums:\n  #     forum#1 -> Link to forum with id 1\n  #     forum:Support -> Link to forum named \"Support\"\n  #     forum:\"Technical Support\" -> Link to forum named \"Technical Support\"\n  #   Forum messages:\n  #     message#1218 -> Link to message with id 1218\n  #   Projects:\n  #     project:someproject -> Link to project named \"someproject\"\n  #     project#3 -> Link to project with id 3\n  #   News:\n  #     news#2 -> Link to news item with id 1\n  #     news:Greetings -> Link to news item named \"Greetings\"\n  #     news:\"First Release\" -> Link to news item named \"First Release\"\n  #   Users:\n  #     user:jsmith -> Link to user with login jsmith\n  #     @jsmith -> Link to user with login jsmith\n  #     user#2 -> Link to user with id 2\n  #\n  #   Links can refer other objects from other projects, using project identifier:\n  #     identifier:r52\n  #     identifier:document:\"Some document\"\n  #     identifier:version:1.0.0\n  #     identifier:source:some/file\n  def parse_redmine_links(text, default_project, obj, attr, only_path, options)\n    text.gsub!(LINKS_RE) do |_|\n      tag_content = $~[:tag_content]\n      leading = $~[:leading]\n      esc = $~[:esc]\n      project_prefix = $~[:project_prefix]\n      project_identifier = $~[:project_identifier]\n      prefix = $~[:prefix]\n      repo_prefix = $~[:repo_prefix]\n      repo_identifier = $~[:repo_identifier]\n      sep = $~[:sep1] || $~[:sep2] || $~[:sep3] || $~[:sep4]\n      identifier = $~[:identifier1] || $~[:identifier2] || $~[:identifier3]\n      comment_suffix = $~[:comment_suffix]\n      comment_id = $~[:comment_id]\n\n      if tag_content\n        $&\n      else\n        link = nil\n        project = default_project\n        if project_identifier\n          project = Project.visible.find_by_identifier(project_identifier)\n        end\n        if esc.nil?\n          if prefix.nil? && sep == 'r'\n            if project\n              repository = nil\n              if repo_identifier\n                repository = project.repositories.detect {|repo| repo.identifier == repo_identifier}\n              else\n                repository = project.repository\n              end\n              # project.changesets.visible raises an SQL error because of a double join on repositories\n              if repository &&\n                   (changeset = Changeset.visible.\n                                    find_by_repository_id_and_revision(repository.id, identifier))\n                link = link_to(h(\"#{project_prefix}#{repo_prefix}r#{identifier}\"),\n                               {:only_path => only_path, :controller => 'repositories',\n                                :action => 'revision', :id => project,\n                                :repository_id => repository.identifier_param,\n                                :rev => changeset.revision},\n                               :class => 'changeset',\n                               :title => truncate_single_line_raw(changeset.comments, 100))\n              end\n            end\n          elsif sep == '#'\n            oid = identifier.to_i\n            case prefix\n            when nil\n              if oid.to_s == identifier &&\n                issue = Issue.visible.find_by_id(oid)\n                anchor = comment_id ? \"note-#{comment_id}\" : nil\n                link = link_to(\"##{oid}#{comment_suffix}\",\n                               issue_url(issue, :only_path => only_path, :anchor => anchor),\n                               :class => issue.css_classes,\n                               :title => \"#{issue.tracker.name}: #{issue.subject.truncate(100)} (#{issue.status.name})\")\n              end\n            when 'document'\n              if document = Document.visible.find_by_id(oid)\n                link = link_to(document.title, document_url(document, :only_path => only_path), :class => 'document')\n              end\n            when 'version'\n              if version = Version.visible.find_by_id(oid)\n                link = link_to(version.name, version_url(version, :only_path => only_path), :class => 'version')\n              end\n            when 'message'\n              if message = Message.visible.find_by_id(oid)\n                link = link_to_message(message, {:only_path => only_path}, :class => 'message')\n              end\n            when 'forum'\n              if board = Board.visible.find_by_id(oid)\n                link = link_to(board.name, project_board_url(board.project, board, :only_path => only_path), :class => 'board')\n              end\n            when 'news'\n              if news = News.visible.find_by_id(oid)\n                link = link_to(news.title, news_url(news, :only_path => only_path), :class => 'news')\n              end\n            when 'project'\n              if p = Project.visible.find_by_id(oid)\n                link = link_to_project(p, {:only_path => only_path}, :class => 'project')\n              end\n            when 'user'\n              u = User.visible.where(:id => oid, :type => 'User').first\n              link = link_to_user(u, :only_path => only_path) if u\n            end\n          elsif sep == ':'\n            name = remove_double_quotes(identifier)\n            case prefix\n            when 'document'\n              if project && document = project.documents.visible.find_by_title(name)\n                link = link_to(document.title, document_url(document, :only_path => only_path), :class => 'document')\n              end\n            when 'version'\n              if project && version = project.versions.visible.find_by_name(name)\n                link = link_to(version.name, version_url(version, :only_path => only_path), :class => 'version')\n              end\n            when 'forum'\n              if project && board = project.boards.visible.find_by_name(name)\n                link = link_to(board.name, project_board_url(board.project, board, :only_path => only_path), :class => 'board')\n              end\n            when 'news'\n              if project && news = project.news.visible.find_by_title(name)\n                link = link_to(news.title, news_url(news, :only_path => only_path), :class => 'news')\n              end\n            when 'commit', 'source', 'export'\n              if project\n                repository = nil\n                if name =~ %r{^(([a-z0-9\\-_]+)\\|)(.+)$}\n                  repo_prefix, repo_identifier, name = $1, $2, $3\n                  repository = project.repositories.detect {|repo| repo.identifier == repo_identifier}\n                else\n                  repository = project.repository\n                end\n                if prefix == 'commit'\n                  if repository && (changeset = Changeset.visible.where(\"repository_id = ? AND scmid LIKE ?\", repository.id, \"#{name}%\").first)\n                    link = link_to h(\"#{project_prefix}#{repo_prefix}#{name}\"), {:only_path => only_path, :controller => 'repositories', :action => 'revision', :id => project, :repository_id => repository.identifier_param, :rev => changeset.identifier},\n                                                 :class => 'changeset',\n                                                 :title => truncate_single_line_raw(changeset.comments, 100)\n                  end\n                else\n                  if repository && User.current.allowed_to?(:browse_repository, project)\n                    name =~ %r{^[/\\\\]*(.*?)(@([^/\\\\@]+?))?(#(L\\d+))?$}\n                    path, rev, anchor = $1, $3, $5\n                    link = link_to h(\"#{project_prefix}#{prefix}:#{repo_prefix}#{name}\"), {:only_path => only_path, :controller => 'repositories', :action => (prefix == 'export' ? 'raw' : 'entry'), :id => project, :repository_id => repository.identifier_param,\n                                                            :path => to_path_param(path),\n                                                            :rev => rev,\n                                                            :anchor => anchor},\n                                                           :class => (prefix == 'export' ? 'source download' : 'source')\n                  end\n                end\n                repo_prefix = nil\n              end\n            when 'attachment'\n              attachments = options[:attachments] || []\n              attachments += obj.attachments if obj.respond_to?(:attachments)\n              if attachments && attachment = Attachment.latest_attach(attachments, name)\n                link = link_to_attachment(attachment, :only_path => only_path, :class => 'attachment')\n              end\n            when 'project'\n              if p = Project.visible.where(\"identifier = :s OR LOWER(name) = :s\", :s => name.downcase).first\n                link = link_to_project(p, {:only_path => only_path}, :class => 'project')\n              end\n            when 'user'\n              u = User.visible.where(:login => name, :type => 'User').first\n              link = link_to_user(u, :only_path => only_path) if u\n            end\n          elsif sep == \"@\"\n            name = remove_double_quotes(identifier)\n            u = User.visible.where(:login => name, :type => 'User').first\n            link = link_to_user(u, :only_path => only_path) if u\n          end\n        end\n        (leading + (link || \"#{project_prefix}#{prefix}#{repo_prefix}#{sep}#{identifier}#{comment_suffix}\"))\n      end\n    end\n  end\n\n  LINKS_RE =\n      %r{\n            <a( [^>]+?)?>(?<tag_content>.*?)</a>|\n            (?<leading>[\\s\\(,\\-\\[\\>]|^)\n            (?<esc>!)?\n            (?<project_prefix>(?<project_identifier>[a-z0-9\\-_]+):)?\n            (?<prefix>attachment|document|version|forum|news|message|project|commit|source|export|user)?\n            (\n              (\n                (?<sep1>\\#)|\n                (\n                  (?<repo_prefix>(?<repo_identifier>[a-z0-9\\-_]+)\\|)?\n                  (?<sep2>r)\n                )\n              )\n              (\n                (?<identifier1>\\d+)\n                (?<comment_suffix>\n                  (\\#note)?\n                  -(?<comment_id>\\d+)\n                )?\n              )|\n              (\n              (?<sep3>:)\n              (?<identifier2>[^\"\\s<>][^\\s<>]*?|\"[^\"]+?\")\n              )|\n              (\n              (?<sep4>@)\n              (?<identifier3>[a-z0-9_\\-@\\.]*)\n              )\n            )\n            (?=\n              (?=[[:punct:]][^A-Za-z0-9_/])|\n              ,|\n              \\s|\n              \\]|\n              <|\n              $)\n      }x\n  HEADING_RE = /(<h(\\d)( [^>]+)?>(.+?)<\\/h(\\d)>)/i unless const_defined?(:HEADING_RE)\n\n  def parse_sections(text, project, obj, attr, only_path, options)\n    return unless options[:edit_section_links]\n    text.gsub!(HEADING_RE) do\n      heading, level = $1, $2\n      @current_section += 1\n      if @current_section > 1\n        content_tag('div',\n          link_to(l(:button_edit_section), options[:edit_section_links].merge(:section => @current_section),\n                  :class => 'icon-only icon-edit'),\n          :class => \"contextual heading-#{level}\",\n          :title => l(:button_edit_section),\n          :id => \"section-#{@current_section}\") + heading.html_safe\n      else\n        heading\n      end\n    end\n  end\n\n  # Headings and TOC\n  # Adds ids and links to headings unless options[:headings] is set to false\n  def parse_headings(text, project, obj, attr, only_path, options)\n    return if options[:headings] == false\n\n    text.gsub!(HEADING_RE) do\n      level, attrs, content = $2.to_i, $3, $4\n      item = strip_tags(content).strip\n      anchor = sanitize_anchor_name(item)\n      # used for single-file wiki export\n      anchor = \"#{obj.page.title}_#{anchor}\" if options[:wiki_links] == :anchor && (obj.is_a?(WikiContent) || obj.is_a?(WikiContent::Version))\n      @heading_anchors[anchor] ||= 0\n      idx = (@heading_anchors[anchor] += 1)\n      if idx > 1\n        anchor = \"#{anchor}-#{idx}\"\n      end\n      @parsed_headings << [level, anchor, item]\n      \"<a name=\\\"#{anchor}\\\"></a>\\n<h#{level} #{attrs}>#{content}<a href=\\\"##{anchor}\\\" class=\\\"wiki-anchor\\\">&para;</a></h#{level}>\"\n    end\n  end\n\n  MACROS_RE = /(\n                (!)?                        # escaping\n                (\n                \\{\\{                        # opening tag\n                ([\\w]+)                     # macro name\n                (\\(([^\\n\\r]*?)\\))?          # optional arguments\n                ([\\n\\r].*?[\\n\\r])?          # optional block of text\n                \\}\\}                        # closing tag\n                )\n               )/mx unless const_defined?(:MACROS_RE)\n\n  MACRO_SUB_RE = /(\n                  \\{\\{\n                  macro\\((\\d+)\\)\n                  \\}\\}\n                  )/x unless const_defined?(:MACRO_SUB_RE)\n\n  # Extracts macros from text\n  def catch_macros(text)\n    macros = {}\n    text.gsub!(MACROS_RE) do\n      all, macro = $1, $4.downcase\n      if macro_exists?(macro) || all =~ MACRO_SUB_RE\n        index = macros.size\n        macros[index] = all\n        \"{{macro(#{index})}}\"\n      else\n        all\n      end\n    end\n    macros\n  end\n\n  # Executes and replaces macros in text\n  def inject_macros(text, obj, macros, execute=true)\n    text.gsub!(MACRO_SUB_RE) do\n      all, index = $1, $2.to_i\n      orig = macros.delete(index)\n      if execute && orig && orig =~ MACROS_RE\n        esc, all, macro, args, block = $2, $3, $4.downcase, $6.to_s, $7.try(:strip)\n        if esc.nil?\n          h(exec_macro(macro, obj, args, block) || all)\n        else\n          h(all)\n        end\n      elsif orig\n        h(orig)\n      else\n        h(all)\n      end\n    end\n  end\n\n  TOC_RE = /<p>\\{\\{((<|&lt;)|(>|&gt;))?toc\\}\\}<\\/p>/i unless const_defined?(:TOC_RE)\n\n  # Renders the TOC with given headings\n  def replace_toc(text, headings)\n    text.gsub!(TOC_RE) do\n      left_align, right_align = $2, $3\n      # Keep only the 4 first levels\n      headings = headings.select{|level, anchor, item| level <= 4}\n      if headings.empty?\n        ''\n      else\n        div_class = 'toc'\n        div_class << ' right' if right_align\n        div_class << ' left' if left_align\n        out = \"<ul class=\\\"#{div_class}\\\"><li><strong>#{l :label_table_of_contents}</strong></li><li>\"\n        root = headings.map(&:first).min\n        current = root\n        started = false\n        headings.each do |level, anchor, item|\n          if level > current\n            out << '<ul><li>' * (level - current)\n          elsif level < current\n            out << \"</li></ul>\\n\" * (current - level) + \"</li><li>\"\n          elsif started\n            out << '</li><li>'\n          end\n          out << \"<a href=\\\"##{anchor}\\\">#{item}</a>\"\n          current = level\n          started = true\n        end\n        out << '</li></ul>' * (current - root)\n        out << '</li></ul>'\n      end\n    end\n  end\n\n  # Same as Rails' simple_format helper without using paragraphs\n  def simple_format_without_paragraph(text)\n    text.to_s.\n      gsub(/\\r\\n?/, \"\\n\").                    # \\r\\n and \\r -> \\n\n      gsub(/\\n\\n+/, \"<br /><br />\").          # 2+ newline  -> 2 br\n      gsub(/([^\\n]\\n)(?=[^\\n])/, '\\1<br />'). # 1 newline   -> br\n      html_safe\n  end\n\n  def lang_options_for_select(blank=true)\n    (blank ? [[\"(auto)\", \"\"]] : []) + languages_options\n  end\n\n  def labelled_form_for(*args, &proc)\n    args << {} unless args.last.is_a?(Hash)\n    options = args.last\n    if args.first.is_a?(Symbol)\n      options.merge!(:as => args.shift)\n    end\n    options.merge!({:builder => Redmine::Views::LabelledFormBuilder})\n    form_for(*args, &proc)\n  end\n\n  def labelled_fields_for(*args, &proc)\n    args << {} unless args.last.is_a?(Hash)\n    options = args.last\n    options.merge!({:builder => Redmine::Views::LabelledFormBuilder})\n    fields_for(*args, &proc)\n  end\n\n  # Render the error messages for the given objects\n  def error_messages_for(*objects)\n    objects = objects.map {|o| o.is_a?(String) ? instance_variable_get(\"@#{o}\") : o}.compact\n    errors = objects.map {|o| o.errors.full_messages}.flatten\n    render_error_messages(errors)\n  end\n\n  # Renders a list of error messages\n  def render_error_messages(errors)\n    html = \"\"\n    if errors.present?\n      html << \"<div id='errorExplanation'><ul>\\n\"\n      errors.each do |error|\n        html << \"<li>#{h error}</li>\\n\"\n      end\n      html << \"</ul></div>\\n\"\n    end\n    html.html_safe\n  end\n\n  def delete_link(url, options={})\n    options = {\n      :method => :delete,\n      :data => {:confirm => l(:text_are_you_sure)},\n      :class => 'icon icon-del'\n    }.merge(options)\n\n    link_to l(:button_delete), url, options\n  end\n\n  def preview_link(url, form, target='preview', options={})\n    content_tag 'a', l(:label_preview), {\n        :href => \"#\",\n        :onclick => %|submitPreview(\"#{escape_javascript url_for(url)}\", \"#{escape_javascript form}\", \"#{escape_javascript target}\"); return false;|,\n        :accesskey => accesskey(:preview)\n      }.merge(options)\n  end\n\n  def link_to_function(name, function, html_options={})\n    content_tag(:a, name, {:href => '#', :onclick => \"#{function}; return false;\"}.merge(html_options))\n  end\n\n  # Helper to render JSON in views\n  def raw_json(arg)\n    arg.to_json.to_s.gsub('/', '\\/').html_safe\n  end\n\n  def back_url\n    url = params[:back_url]\n    if url.nil? && referer = request.env['HTTP_REFERER']\n      url = CGI.unescape(referer.to_s)\n      # URLs that contains the utf8=[checkmark] parameter added by Rails are\n      # parsed as invalid by URI.parse so the redirect to the back URL would\n      # not be accepted (ApplicationController#validate_back_url would return\n      # false)\n      url.gsub!(/(\\?|&)utf8=\\u2713&?/, '\\1')\n    end\n    url\n  end\n\n  def back_url_hidden_field_tag\n    url = back_url\n    hidden_field_tag('back_url', url, :id => nil) unless url.blank?\n  end\n\n  def check_all_links(form_name)\n    link_to_function(l(:button_check_all), \"checkAll('#{form_name}', true)\") +\n    \" | \".html_safe +\n    link_to_function(l(:button_uncheck_all), \"checkAll('#{form_name}', false)\")\n  end\n\n  def toggle_checkboxes_link(selector)\n    link_to_function '',\n      \"toggleCheckboxesBySelector('#{selector}')\",\n      :title => \"#{l(:button_check_all)} / #{l(:button_uncheck_all)}\",\n      :class => 'toggle-checkboxes'\n  end\n\n  def progress_bar(pcts, options={})\n    pcts = [pcts, pcts] unless pcts.is_a?(Array)\n    pcts = pcts.collect(&:round)\n    pcts[1] = pcts[1] - pcts[0]\n    pcts << (100 - pcts[1] - pcts[0])\n    titles = options[:titles].to_a\n    titles[0] = \"#{pcts[0]}%\" if titles[0].blank?\n    legend = options[:legend] || ''\n    content_tag('table',\n      content_tag('tr',\n        (pcts[0] > 0 ? content_tag('td', '', :style => \"width: #{pcts[0]}%;\", :class => 'closed', :title => titles[0]) : ''.html_safe) +\n        (pcts[1] > 0 ? content_tag('td', '', :style => \"width: #{pcts[1]}%;\", :class => 'done', :title => titles[1]) : ''.html_safe) +\n        (pcts[2] > 0 ? content_tag('td', '', :style => \"width: #{pcts[2]}%;\", :class => 'todo', :title => titles[2]) : ''.html_safe)\n      ), :class => \"progress progress-#{pcts[0]}\").html_safe +\n      content_tag('p', legend, :class => 'percent').html_safe\n  end\n\n  def checked_image(checked=true)\n    if checked\n      @checked_image_tag ||= content_tag(:span, nil, :class => 'icon-only icon-checked')\n    end\n  end\n\n  def context_menu\n    unless @context_menu_included\n      content_for :header_tags do\n        javascript_include_tag('context_menu') +\n          stylesheet_link_tag('context_menu')\n      end\n      if l(:direction) == 'rtl'\n        content_for :header_tags do\n          stylesheet_link_tag('context_menu_rtl')\n        end\n      end\n      @context_menu_included = true\n    end\n    nil\n  end\n\n  def calendar_for(field_id)\n    include_calendar_headers_tags\n    javascript_tag(\"$(function() { $('##{field_id}').addClass('date').datepickerFallback(datepickerOptions); });\")\n  end\n\n  def include_calendar_headers_tags\n    unless @calendar_headers_tags_included\n      tags = ''.html_safe\n      @calendar_headers_tags_included = true\n      content_for :header_tags do\n        start_of_week = Setting.start_of_week\n        start_of_week = l(:general_first_day_of_week, :default => '1') if start_of_week.blank?\n        # Redmine uses 1..7 (monday..sunday) in settings and locales\n        # JQuery uses 0..6 (sunday..saturday), 7 needs to be changed to 0\n        start_of_week = start_of_week.to_i % 7\n        tags << javascript_tag(\n                   \"var datepickerOptions={dateFormat: 'yy-mm-dd', firstDay: #{start_of_week}, \" +\n                     \"showOn: 'button', buttonImageOnly: true, buttonImage: '\" +\n                     path_to_image('/images/calendar.png') +\n                     \"', showButtonPanel: true, showWeek: true, showOtherMonths: true, \" +\n                     \"selectOtherMonths: true, changeMonth: true, changeYear: true, \" +\n                     \"beforeShow: beforeShowDatePicker};\")\n        jquery_locale = l('jquery.locale', :default => current_language.to_s)\n        unless jquery_locale == 'en'\n          tags << javascript_include_tag(\"i18n/datepicker-#{jquery_locale}.js\")\n        end\n        tags\n      end\n    end\n  end\n\n  # Overrides Rails' stylesheet_link_tag with themes and plugins support.\n  # Examples:\n  #   stylesheet_link_tag('styles') # => picks styles.css from the current theme or defaults\n  #   stylesheet_link_tag('styles', :plugin => 'foo) # => picks styles.css from plugin's assets\n  #\n  def stylesheet_link_tag(*sources)\n    options = sources.last.is_a?(Hash) ? sources.pop : {}\n    plugin = options.delete(:plugin)\n    sources = sources.map do |source|\n      if plugin\n        \"/plugin_assets/#{plugin}/stylesheets/#{source}\"\n      elsif current_theme && current_theme.stylesheets.include?(source)\n        current_theme.stylesheet_path(source)\n      else\n        source\n      end\n    end\n    super *sources, options\n  end\n\n  # Overrides Rails' image_tag with themes and plugins support.\n  # Examples:\n  #   image_tag('image.png') # => picks image.png from the current theme or defaults\n  #   image_tag('image.png', :plugin => 'foo) # => picks image.png from plugin's assets\n  #\n  def image_tag(source, options={})\n    if plugin = options.delete(:plugin)\n      source = \"/plugin_assets/#{plugin}/images/#{source}\"\n    elsif current_theme && current_theme.images.include?(source)\n      source = current_theme.image_path(source)\n    end\n    super source, options\n  end\n\n  # Overrides Rails' javascript_include_tag with plugins support\n  # Examples:\n  #   javascript_include_tag('scripts') # => picks scripts.js from defaults\n  #   javascript_include_tag('scripts', :plugin => 'foo) # => picks scripts.js from plugin's assets\n  #\n  def javascript_include_tag(*sources)\n    options = sources.last.is_a?(Hash) ? sources.pop : {}\n    if plugin = options.delete(:plugin)\n      sources = sources.map do |source|\n        if plugin\n          \"/plugin_assets/#{plugin}/javascripts/#{source}\"\n        else\n          source\n        end\n      end\n    end\n    super *sources, options\n  end\n\n  def sidebar_content?\n    content_for?(:sidebar) || view_layouts_base_sidebar_hook_response.present?\n  end\n\n  def view_layouts_base_sidebar_hook_response\n    @view_layouts_base_sidebar_hook_response ||= call_hook(:view_layouts_base_sidebar)\n  end\n\n  def email_delivery_enabled?\n    !!ActionMailer::Base.perform_deliveries\n  end\n\n  # Returns the avatar image tag for the given +user+ if avatars are enabled\n  # +user+ can be a User or a string that will be scanned for an email address (eg. 'joe <joe@foo.bar>')\n  def avatar(user, options = { })\n    if Setting.gravatar_enabled?\n      options.merge!(:default => Setting.gravatar_default)\n      email = nil\n      if user.respond_to?(:mail)\n        email = user.mail\n      elsif user.to_s =~ %r{<(.+?)>}\n        email = $1\n      end\n      return gravatar(email.to_s.downcase, options) unless email.blank? rescue nil\n    else\n      ''\n    end\n  end\n\n  # Returns a link to edit user's avatar if avatars are enabled\n  def avatar_edit_link(user, options={})\n    if Setting.gravatar_enabled?\n      url = \"https://gravatar.com\"\n      link_to avatar(user, {:title => l(:button_edit)}.merge(options)), url, :target => '_blank'\n    end\n  end\n\n  def sanitize_anchor_name(anchor)\n    anchor.gsub(%r{[^\\s\\-\\p{Word}]}, '').gsub(%r{\\s+(\\-+\\s*)?}, '-')\n  end\n\n  # Returns the javascript tags that are included in the html layout head\n  def javascript_heads\n    tags = javascript_include_tag('jquery-1.11.1-ui-1.11.0-ujs-4.3.1', 'application', 'responsive')\n    unless User.current.pref.warn_on_leaving_unsaved == '0'\n      tags << \"\\n\".html_safe + javascript_tag(\"$(window).load(function(){ warnLeavingUnsaved('#{escape_javascript l(:text_warn_on_leaving_unsaved)}'); });\")\n    end\n    tags\n  end\n\n  def favicon\n    \"<link rel='shortcut icon' href='#{favicon_path}' />\".html_safe\n  end\n\n  # Returns the path to the favicon\n  def favicon_path\n    icon = (current_theme && current_theme.favicon?) ? current_theme.favicon_path : '/favicon.ico'\n    image_path(icon)\n  end\n\n  # Returns the full URL to the favicon\n  def favicon_url\n    # TODO: use #image_url introduced in Rails4\n    path = favicon_path\n    base = url_for(:controller => 'welcome', :action => 'index', :only_path => false)\n    base.sub(%r{/+$},'') + '/' + path.sub(%r{^/+},'')\n  end\n\n  def robot_exclusion_tag\n    '<meta name=\"robots\" content=\"noindex,follow,noarchive\" />'.html_safe\n  end\n\n  # Returns true if arg is expected in the API response\n  def include_in_api_response?(arg)\n    unless @included_in_api_response\n      param = params[:include]\n      @included_in_api_response = param.is_a?(Array) ? param.collect(&:to_s) : param.to_s.split(',')\n      @included_in_api_response.collect!(&:strip)\n    end\n    @included_in_api_response.include?(arg.to_s)\n  end\n\n  # Returns options or nil if nometa param or X-Redmine-Nometa header\n  # was set in the request\n  def api_meta(options)\n    if params[:nometa].present? || request.headers['X-Redmine-Nometa']\n      # compatibility mode for activeresource clients that raise\n      # an error when deserializing an array with attributes\n      nil\n    else\n      options\n    end\n  end\n\n  def generate_csv(&block)\n    decimal_separator = l(:general_csv_decimal_separator)\n    encoding = l(:general_csv_encoding)\n  end\n\n  private\n\n  def wiki_helper\n    helper = Redmine::WikiFormatting.helper_for(Setting.text_formatting)\n    extend helper\n    return self\n  end\n\n  # remove double quotes if any\n  def remove_double_quotes(identifier)\n    name = identifier.gsub(%r{^\"(.*)\"$}, \"\\\\1\")\n    return CGI.unescapeHTML(name)\n  end\nend\n"], "filenames": ["app/helpers/application_helper.rb"], "buggy_code_start_loc": [180], "buggy_code_end_loc": [181], "fixing_code_start_loc": [180], "fixing_code_end_loc": [182], "type": "CWE-79", "message": "In Redmine before 3.2.8, 3.3.x before 3.3.5, and 3.4.x before 3.4.3, XSS exists in app/helpers/application_helper.rb via a multi-value field with a crafted value that is mishandled during rendering of issue history.", "other": {"cve": {"id": "CVE-2017-15568", "sourceIdentifier": "cve@mitre.org", "published": "2017-10-18T02:29:00.280", "lastModified": "2019-03-14T15:00:52.700", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Redmine before 3.2.8, 3.3.x before 3.3.5, and 3.4.x before 3.4.3, XSS exists in app/helpers/application_helper.rb via a multi-value field with a crafted value that is mishandled during rendering of issue history."}, {"lang": "es", "value": "En Redmine en versiones anteriores a la 3.2.8, 3.3.x en versiones anteriores a la 3.3.5 y 3.4.x en versiones anteriores a la 3.4.3, existe XSS en app/helpers/application_helper.rb mediante un campo de m\u00faltiples valores con un valor manipulado que se gestiona de manera incorrecta durante la representaci\u00f3n del historial de problemas."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redmine:redmine:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.2.7", "matchCriteriaId": "506353CE-8310-44AC-B47C-4F3752DB7D0E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redmine:redmine:3.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "196CF994-54D8-4E36-B37E-EAF1CC108F61"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redmine:redmine:3.3.1:*:*:*:*:*:*:*", "matchCriteriaId": "5AE4FC9C-3291-4344-81D5-83BA91D52FA7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redmine:redmine:3.3.2:*:*:*:*:*:*:*", "matchCriteriaId": "67E1F17B-7B25-48B3-8953-18C47D99B443"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redmine:redmine:3.3.3:*:*:*:*:*:*:*", "matchCriteriaId": "9ADF69D6-449E-4845-811D-D588B4D05665"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redmine:redmine:3.3.4:*:*:*:*:*:*:*", "matchCriteriaId": "DEAD6AFD-E3DE-4E0F-A2C8-78A1CD316A6D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redmine:redmine:3.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "22FD314E-A7E6-4073-BC98-452B9C5826E1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redmine:redmine:3.4.1:*:*:*:*:*:*:*", "matchCriteriaId": "6982CC59-BE97-400C-A653-47AD6802C3F4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redmine:redmine:3.4.2:*:*:*:*:*:*:*", "matchCriteriaId": "4D6A2E76-528B-48FA-89A4-B6BEE20E901A"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "https://github.com/redmine/redmine/commit/94f7cfbf990028348b9262578acbc53a94fce448", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2018/dsa-4191", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.redmine.org/issues/27186", "source": "cve@mitre.org", "tags": ["Permissions Required", "Vendor Advisory"]}, {"url": "https://www.redmine.org/projects/redmine/wiki/Security_Advisories", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/redmine/redmine/commit/94f7cfbf990028348b9262578acbc53a94fce448"}}