{"buggy_code": ["/****************************************************************************\n * RRDtool 1.4.3  Copyright by Tobi Oetiker, 1997-2010\n ****************************************************************************\n * rrd__graph.c  produce graphs from data in rrdfiles\n ****************************************************************************/\n\n\n#include <sys/stat.h>\n\n#ifdef WIN32\n#include \"strftime.h\"\n#endif\n\n#include \"rrd_strtod.h\"\n\n#include \"rrd_tool.h\"\n#include \"unused.h\"\n\n/* for basename */\n#ifdef HAVE_LIBGEN_H\n#  include <libgen.h>\n#else\n#include \"plbasename.h\"\n#endif\n\n#if defined(WIN32) && !defined(__CYGWIN__) && !defined(__CYGWIN32__)\n#include <io.h>\n#include <fcntl.h>\n#endif\n\n#include <time.h>\n\n#include <locale.h>\n\n#ifdef HAVE_LANGINFO_H\n#include <langinfo.h>\n#endif\n\n#include \"rrd_graph.h\"\n#include \"rrd_client.h\"\n\n/* some constant definitions */\n\n\n\n#ifndef RRD_DEFAULT_FONT\n/* there is special code later to pick Cour.ttf when running on windows */\n#define RRD_DEFAULT_FONT \"DejaVu Sans Mono,Bitstream Vera Sans Mono,monospace,Courier\"\n#endif\n\ntext_prop_t text_prop[] = {\n    {8.0, RRD_DEFAULT_FONT,NULL}\n    ,                   /* default */\n    {9.0, RRD_DEFAULT_FONT,NULL}\n    ,                   /* title */\n    {7.0, RRD_DEFAULT_FONT,NULL}\n    ,                   /* axis */\n    {8.0, RRD_DEFAULT_FONT,NULL}\n    ,                   /* unit */\n    {8.0, RRD_DEFAULT_FONT,NULL} /* legend */\n    ,\n    {5.5, RRD_DEFAULT_FONT,NULL} /* watermark */\n};\n\nchar week_fmt[128] = \"Week %V\";\n\nxlab_t    xlab[] = {\n    {0, 0, TMT_SECOND, 30, TMT_MINUTE, 5, TMT_MINUTE, 5, 0, \"%H:%M\"}\n    ,\n    {2, 0, TMT_MINUTE, 1, TMT_MINUTE, 5, TMT_MINUTE, 5, 0, \"%H:%M\"}\n    ,\n    {5, 0, TMT_MINUTE, 2, TMT_MINUTE, 10, TMT_MINUTE, 10, 0, \"%H:%M\"}\n    ,\n    {10, 0, TMT_MINUTE, 5, TMT_MINUTE, 20, TMT_MINUTE, 20, 0, \"%H:%M\"}\n    ,\n    {30, 0, TMT_MINUTE, 10, TMT_HOUR, 1, TMT_HOUR, 1, 0, \"%H:%M\"}\n    ,\n    {60, 0, TMT_MINUTE, 30, TMT_HOUR, 2, TMT_HOUR, 2, 0, \"%H:%M\"}\n    ,\n    {60, 24 * 3600, TMT_MINUTE, 30, TMT_HOUR, 2, TMT_HOUR, 6, 0, \"%a %H:%M\"}\n    ,\n    {180, 0, TMT_HOUR, 1, TMT_HOUR, 6, TMT_HOUR, 6, 0, \"%H:%M\"}\n    ,\n    {180, 24 * 3600, TMT_HOUR, 1, TMT_HOUR, 6, TMT_HOUR, 12, 0, \"%a %H:%M\"}\n    ,\n    /*{300,             0,   TMT_HOUR,3,    TMT_HOUR,12,   TMT_HOUR,12,    12*3600,\"%a %p\"},  this looks silly */\n    {600, 0, TMT_HOUR, 6, TMT_DAY, 1, TMT_DAY, 1, 24 * 3600, \"%a\"}\n    ,\n    {1200, 0, TMT_HOUR, 6, TMT_DAY, 1, TMT_DAY, 1, 24 * 3600, \"%d\"}\n    ,\n    {1800, 0, TMT_HOUR, 12, TMT_DAY, 1, TMT_DAY, 2, 24 * 3600, \"%a %d\"}\n    ,\n    {2400, 0, TMT_HOUR, 12, TMT_DAY, 1, TMT_DAY, 2, 24 * 3600, \"%a\"}\n    ,\n    {3600, 0, TMT_DAY, 1, TMT_WEEK, 1, TMT_WEEK, 1, 7 * 24 * 3600, week_fmt}\n    ,\n    {3 * 3600, 0, TMT_WEEK, 1, TMT_MONTH, 1, TMT_WEEK, 2, 7 * 24 * 3600, week_fmt}\n    ,\n    {6 * 3600, 0, TMT_MONTH, 1, TMT_MONTH, 1, TMT_MONTH, 1, 30 * 24 * 3600,\n     \"%b\"}\n    ,\n    {48 * 3600, 0, TMT_MONTH, 1, TMT_MONTH, 3, TMT_MONTH, 3, 30 * 24 * 3600,\n     \"%b\"}\n    ,\n    {315360, 0, TMT_MONTH, 3, TMT_YEAR, 1, TMT_YEAR, 1, 365 * 24 * 3600, \"%Y\"}\n    ,\n    {10 * 24 * 3600, 0, TMT_YEAR, 1, TMT_YEAR, 1, TMT_YEAR, 1,\n     365 * 24 * 3600, \"%y\"}\n    ,\n    {-1, 0, TMT_MONTH, 0, TMT_MONTH, 0, TMT_MONTH, 0, 0, \"\"}\n};\n\n/* sensible y label intervals ...*/\n\nylab_t    ylab[] = {\n    {0.1, {1, 2, 5, 10}\n     }\n    ,\n    {0.2, {1, 5, 10, 20}\n     }\n    ,\n    {0.5, {1, 2, 4, 10}\n     }\n    ,\n    {1.0, {1, 2, 5, 10}\n     }\n    ,\n    {2.0, {1, 5, 10, 20}\n     }\n    ,\n    {5.0, {1, 2, 4, 10}\n     }\n    ,\n    {10.0, {1, 2, 5, 10}\n     }\n    ,\n    {20.0, {1, 5, 10, 20}\n     }\n    ,\n    {50.0, {1, 2, 4, 10}\n     }\n    ,\n    {100.0, {1, 2, 5, 10}\n     }\n    ,\n    {200.0, {1, 5, 10, 20}\n     }\n    ,\n    {500.0, {1, 2, 4, 10}\n     }\n    ,\n    {0.0, {0, 0, 0, 0}\n     }\n};\n\n\ngfx_color_t graph_col[] =   /* default colors */\n{\n    {1.00, 1.00, 1.00, 1.00},   /* canvas     */\n    {0.95, 0.95, 0.95, 1.00},   /* background */\n    {0.81, 0.81, 0.81, 1.00},   /* shade A    */\n    {0.62, 0.62, 0.62, 1.00},   /* shade B    */\n    {0.56, 0.56, 0.56, 0.75},   /* grid       */\n    {0.87, 0.31, 0.31, 0.60},   /* major grid */\n    {0.00, 0.00, 0.00, 1.00},   /* font       */\n    {0.50, 0.12, 0.12, 1.00},   /* arrow      */\n    {0.12, 0.12, 0.12, 1.00},   /* axis       */\n    {0.00, 0.00, 0.00, 1.00}    /* frame      */\n};\n\n\n/* #define DEBUG */\n\n#ifdef DEBUG\n# define DPRINT(x)    (void)(printf x, printf(\"\\n\"))\n#else\n# define DPRINT(x)\n#endif\n\n\n/* initialize with xtr(im,0); */\nint xtr(\n    image_desc_t *im,\n    time_t mytime)\n{\n    static double pixie;\n\n    if (mytime == 0) {\n        pixie = (double) im->xsize / (double) (im->end - im->start);\n        return im->xorigin;\n    }\n    return (int) ((double) im->xorigin + pixie * (mytime - im->start));\n}\n\n/* translate data values into y coordinates */\ndouble ytr(\n    image_desc_t *im,\n    double value)\n{\n    static double pixie;\n    double    yval;\n\n    if (isnan(value)) {\n        if (!im->logarithmic)\n            pixie = (double) im->ysize / (im->maxval - im->minval);\n        else\n            pixie =\n                (double) im->ysize / (log10(im->maxval) - log10(im->minval));\n        yval = im->yorigin;\n    } else if (!im->logarithmic) {\n        yval = im->yorigin - pixie * (value - im->minval);\n    } else {\n        if (value < im->minval) {\n            yval = im->yorigin;\n        } else {\n            yval = im->yorigin - pixie * (log10(value) - log10(im->minval));\n        }\n    }\n    return yval;\n}\n\n\n\n/* conversion function for symbolic entry names */\n\n\n#define conv_if(VV,VVV) \\\n   if (strcmp(#VV, string) == 0) return VVV ;\n\nenum gf_en gf_conv(\n    char *string)\n{\n\n    conv_if(PRINT, GF_PRINT);\n    conv_if(GPRINT, GF_GPRINT);\n    conv_if(COMMENT, GF_COMMENT);\n    conv_if(HRULE, GF_HRULE);\n    conv_if(VRULE, GF_VRULE);\n    conv_if(LINE, GF_LINE);\n    conv_if(AREA, GF_AREA);\n\tconv_if(GRAD, GF_GRAD);\n    conv_if(STACK, GF_STACK);\n    conv_if(TICK, GF_TICK);\n    conv_if(TEXTALIGN, GF_TEXTALIGN);\n    conv_if(DEF, GF_DEF);\n    conv_if(CDEF, GF_CDEF);\n    conv_if(VDEF, GF_VDEF);\n    conv_if(XPORT, GF_XPORT);\n    conv_if(SHIFT, GF_SHIFT);\n\n    return (enum gf_en)(-1);\n}\n\nenum gfx_if_en if_conv(\n    char *string)\n{\n\n    conv_if(PNG, IF_PNG);\n    conv_if(SVG, IF_SVG);\n    conv_if(EPS, IF_EPS);\n    conv_if(PDF, IF_PDF);\n    conv_if(XML, IF_XML);\n    conv_if(XMLENUM, IF_XMLENUM);\n    conv_if(CSV, IF_CSV);\n    conv_if(TSV, IF_TSV);\n    conv_if(SSV, IF_SSV);\n    conv_if(JSON, IF_JSON);\n    conv_if(JSONTIME, IF_JSONTIME);\n\n    return (enum gfx_if_en)(-1);\n}\n\nenum gfx_type_en type_conv(\n    char *string)\n{\n    conv_if(TIME , GTYPE_TIME);\n    conv_if(XY, GTYPE_XY);\n    return (enum gfx_type_en)(-1);\n}\n\nenum tmt_en tmt_conv(\n    char *string)\n{\n\n    conv_if(SECOND, TMT_SECOND);\n    conv_if(MINUTE, TMT_MINUTE);\n    conv_if(HOUR, TMT_HOUR);\n    conv_if(DAY, TMT_DAY);\n    conv_if(WEEK, TMT_WEEK);\n    conv_if(MONTH, TMT_MONTH);\n    conv_if(YEAR, TMT_YEAR);\n    return (enum tmt_en)(-1);\n}\n\nenum grc_en grc_conv(\n    char *string)\n{\n\n    conv_if(BACK, GRC_BACK);\n    conv_if(CANVAS, GRC_CANVAS);\n    conv_if(SHADEA, GRC_SHADEA);\n    conv_if(SHADEB, GRC_SHADEB);\n    conv_if(GRID, GRC_GRID);\n    conv_if(MGRID, GRC_MGRID);\n    conv_if(FONT, GRC_FONT);\n    conv_if(ARROW, GRC_ARROW);\n    conv_if(AXIS, GRC_AXIS);\n    conv_if(FRAME, GRC_FRAME);\n\n    return (enum grc_en)(-1);\n}\n\nenum text_prop_en text_prop_conv(\n    char *string)\n{\n\n    conv_if(DEFAULT, TEXT_PROP_DEFAULT);\n    conv_if(TITLE, TEXT_PROP_TITLE);\n    conv_if(AXIS, TEXT_PROP_AXIS);\n    conv_if(UNIT, TEXT_PROP_UNIT);\n    conv_if(LEGEND, TEXT_PROP_LEGEND);\n    conv_if(WATERMARK, TEXT_PROP_WATERMARK);\n    return (enum text_prop_en)(-1);\n}\n\n\n#undef conv_if\n\nint im_free(\n    image_desc_t *im)\n{\n    unsigned long i, ii;\n    cairo_status_t status = (cairo_status_t) 0;\n\n    if (im == NULL)\n        return 0;\n\n    if (im->daemon_addr != NULL)\n      free(im->daemon_addr);\n\n    if (im->gdef_map){\n        g_hash_table_destroy(im->gdef_map);        \n\t}\n\n\tif (im->rrd_map){\n\t\tg_hash_table_destroy(im->rrd_map);\n\t}\n\t\n\n    for (i = 0; i < (unsigned) im->gdes_c; i++) {\n        if (im->gdes[i].data_first) {\n            /* careful here, because a single pointer can occur several times */\n            free(im->gdes[i].data);\n            if (im->gdes[i].ds_namv) {\n                for (ii = 0; ii < im->gdes[i].ds_cnt; ii++)\n                    free(im->gdes[i].ds_namv[ii]);\n                free(im->gdes[i].ds_namv);\n            }\n        }\n        /* free allocated memory used for dashed lines */\n        if (im->gdes[i].p_dashes != NULL)\n            free(im->gdes[i].p_dashes);\n\n        free(im->gdes[i].p_data);\n        free(im->gdes[i].rpnp);\n    }\n    free(im->gdes);\n\n    for (i = 0; i < DIM(text_prop);i++){\n        pango_font_description_free(im->text_prop[i].font_desc);\n        im->text_prop[i].font_desc = NULL;\n    }\n\n    if (im->font_options)\n        cairo_font_options_destroy(im->font_options);\n\n    if (im->surface)\n        cairo_surface_destroy(im->surface);\n\n    if (im->cr) {\n        status = cairo_status(im->cr);\n        cairo_destroy(im->cr);\n    }\n\n    if (status)\n        fprintf(stderr, \"OOPS: Cairo has issues it can't even die: %s\\n\",\n                cairo_status_to_string(status));\n\n\n    if (im->rendered_image) {\n        free(im->rendered_image);\n    }\n\n    if (im->layout) {\n        g_object_unref(im->layout);\n    }\n\n\tif (im->ylegend)\n\t\tfree(im->ylegend);\n\tif (im->title)\n\t\tfree(im->title);\n\tif (im->watermark)\n\t\tfree(im->watermark);\n\tif (im->xlab_form)\n\t\tfree(im->xlab_form);\n\tif (im->second_axis_legend)\n\t\tfree(im->second_axis_legend);\n\tif (im->second_axis_format)\n\t\tfree(im->second_axis_format);\n\tif (im->primary_axis_format)\n\t\tfree(im->primary_axis_format);\n\n    return 0;\n}\n\n/* find SI magnitude symbol for the given number*/\nvoid auto_scale(\n    image_desc_t *im,   /* image description */\n    double *value,\n    char **symb_ptr,\n    double *magfact)\n{\n\n    char     *symbol[] = { \"a\", /* 10e-18 Atto */\n        \"f\",            /* 10e-15 Femto */\n        \"p\",            /* 10e-12 Pico */\n        \"n\",            /* 10e-9  Nano */\n        \"u\",            /* 10e-6  Micro */\n        \"m\",            /* 10e-3  Milli */\n        \" \",            /* Base */\n        \"k\",            /* 10e3   Kilo */\n        \"M\",            /* 10e6   Mega */\n        \"G\",            /* 10e9   Giga */\n        \"T\",            /* 10e12  Tera */\n        \"P\",            /* 10e15  Peta */\n        \"E\"\n    };                  /* 10e18  Exa */\n\n    int       symbcenter = 6;\n    int       sindex;\n\n    if (*value == 0.0 || isnan(*value)) {\n        sindex = 0;\n        *magfact = 1.0;\n    } else {\n        sindex = floor(log(fabs(*value)) / log((double) im->base));\n        *magfact = pow((double) im->base, (double) sindex);\n        (*value) /= (*magfact);\n    }\n    if (sindex <= symbcenter && sindex >= -symbcenter) {\n        (*symb_ptr) = symbol[sindex + symbcenter];\n    } else {\n        (*symb_ptr) = \"?\";\n    }\n}\n\n/* power prefixes */\n\nstatic char si_symbol[] = {\n    'y',                /* 10e-24 Yocto */\n    'z',                /* 10e-21 Zepto */\n    'a',                /* 10e-18 Atto */\n    'f',                /* 10e-15 Femto */\n    'p',                /* 10e-12 Pico */\n    'n',                /* 10e-9  Nano */\n    'u',                /* 10e-6  Micro */\n    'm',                /* 10e-3  Milli */\n    ' ',                /* Base */\n    'k',                /* 10e3   Kilo */\n    'M',                /* 10e6   Mega */\n    'G',                /* 10e9   Giga */\n    'T',                /* 10e12  Tera */\n    'P',                /* 10e15  Peta */\n    'E',                /* 10e18  Exa */\n    'Z',                /* 10e21  Zeta */\n    'Y'                 /* 10e24  Yotta */\n};\nstatic const int si_symbcenter = 8;\n\n/* find SI magnitude symbol for the numbers on the y-axis*/\nvoid si_unit(\n    image_desc_t *im    /* image description */\n    )\n{\n\n    double    digits, viewdigits = 0;\n\n    digits =\n        floor(log(max(fabs(im->minval), fabs(im->maxval))) /\n              log((double) im->base));\n\n    if (im->unitsexponent != 9999) {\n        /* unitsexponent = 9, 6, 3, 0, -3, -6, -9, etc */\n        viewdigits = floor((double)(im->unitsexponent / 3));\n    } else {\n        viewdigits = digits;\n    }\n\n    im->magfact = pow((double) im->base, digits);\n\n#ifdef DEBUG\n    printf(\"digits %6.3f  im->magfact %6.3f\\n\", digits, im->magfact);\n#endif\n\n    im->viewfactor = im->magfact / pow((double) im->base, viewdigits);\n\n    if (((viewdigits + si_symbcenter) < sizeof(si_symbol)) &&\n        ((viewdigits + si_symbcenter) >= 0))\n        im->symbol = si_symbol[(int) viewdigits + si_symbcenter];\n    else\n        im->symbol = '?';\n}\n\n/*  move min and max values around to become sensible */\n\nvoid expand_range(\n    image_desc_t *im)\n{\n    double    sensiblevalues[] = { 1000.0, 900.0, 800.0, 750.0, 700.0,\n        600.0, 500.0, 400.0, 300.0, 250.0,\n        200.0, 125.0, 100.0, 90.0, 80.0,\n        75.0, 70.0, 60.0, 50.0, 40.0, 30.0,\n        25.0, 20.0, 10.0, 9.0, 8.0,\n        7.0, 6.0, 5.0, 4.0, 3.5, 3.0,\n        2.5, 2.0, 1.8, 1.5, 1.2, 1.0,\n        0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1, 0.0, -1\n    };\n\n    double    scaled_min, scaled_max;\n    double    adj;\n    int       i;\n\n\n\n#ifdef DEBUG\n    printf(\"Min: %6.2f Max: %6.2f MagFactor: %6.2f\\n\",\n           im->minval, im->maxval, im->magfact);\n#endif\n\n    if (isnan(im->ygridstep)) {\n        if (im->extra_flags & ALTAUTOSCALE) {\n            /* measure the amplitude of the function. Make sure that\n               graph boundaries are slightly higher then max/min vals\n               so we can see amplitude on the graph */\n            double    delt, fact;\n\n            delt = im->maxval - im->minval;\n            adj = delt * 0.1;\n            fact = 2.0 * pow(10.0,\n                             floor(log10\n                                   (max(fabs(im->minval), fabs(im->maxval)) /\n                                    im->magfact)) - 2);\n            if (delt < fact) {\n                adj = (fact - delt) * 0.55;\n#ifdef DEBUG\n                printf\n                    (\"Min: %6.2f Max: %6.2f delt: %6.2f fact: %6.2f adj: %6.2f\\n\",\n                     im->minval, im->maxval, delt, fact, adj);\n#endif\n            }\n            im->minval -= adj;\n            im->maxval += adj;\n        } else if (im->extra_flags & ALTAUTOSCALE_MIN) {\n            /* measure the amplitude of the function. Make sure that\n               graph boundaries are slightly lower than min vals\n               so we can see amplitude on the graph */\n            adj = (im->maxval - im->minval) * 0.1;\n            im->minval -= adj;\n        } else if (im->extra_flags & ALTAUTOSCALE_MAX) {\n            /* measure the amplitude of the function. Make sure that\n               graph boundaries are slightly higher than max vals\n               so we can see amplitude on the graph */\n            adj = (im->maxval - im->minval) * 0.1;\n            im->maxval += adj;\n        } else {\n            scaled_min = im->minval / im->magfact;\n            scaled_max = im->maxval / im->magfact;\n\n            for (i = 1; sensiblevalues[i] > 0; i++) {\n                if (sensiblevalues[i - 1] >= scaled_min &&\n                    sensiblevalues[i] <= scaled_min)\n                    im->minval = sensiblevalues[i] * (im->magfact);\n\n                if (-sensiblevalues[i - 1] <= scaled_min &&\n                    -sensiblevalues[i] >= scaled_min)\n                    im->minval = -sensiblevalues[i - 1] * (im->magfact);\n\n                if (sensiblevalues[i - 1] >= scaled_max &&\n                    sensiblevalues[i] <= scaled_max)\n                    im->maxval = sensiblevalues[i - 1] * (im->magfact);\n\n                if (-sensiblevalues[i - 1] <= scaled_max &&\n                    -sensiblevalues[i] >= scaled_max)\n                    im->maxval = -sensiblevalues[i] * (im->magfact);\n            }\n        }\n    } else {\n        /* adjust min and max to the grid definition if there is one */\n        im->minval = (double) im->ylabfact * im->ygridstep *\n            floor(im->minval / ((double) im->ylabfact * im->ygridstep));\n        im->maxval = (double) im->ylabfact * im->ygridstep *\n            ceil(im->maxval / ((double) im->ylabfact * im->ygridstep));\n    }\n\n#ifdef DEBUG\n    fprintf(stderr, \"SCALED Min: %6.2f Max: %6.2f Factor: %6.2f\\n\",\n            im->minval, im->maxval, im->magfact);\n#endif\n}\n\n\nvoid apply_gridfit(\n    image_desc_t *im)\n{\n    if (isnan(im->minval) || isnan(im->maxval))\n        return;\n    ytr(im, DNAN);\n    if (im->logarithmic) {\n        double    ya, yb, ypix, ypixfrac;\n        double    log10_range = log10(im->maxval) - log10(im->minval);\n\n        ya = pow((double) 10, floor(log10(im->minval)));\n        while (ya < im->minval)\n            ya *= 10;\n        if (ya > im->maxval)\n            return;     /* don't have y=10^x gridline */\n        yb = ya * 10;\n        if (yb <= im->maxval) {\n            /* we have at least 2 y=10^x gridlines.\n               Make sure distance between them in pixels\n               are an integer by expanding im->maxval */\n            double    y_pixel_delta = ytr(im, ya) - ytr(im, yb);\n            double    factor = y_pixel_delta / floor(y_pixel_delta);\n            double    new_log10_range = factor * log10_range;\n            double    new_ymax_log10 = log10(im->minval) + new_log10_range;\n\n            im->maxval = pow(10, new_ymax_log10);\n            ytr(im, DNAN);  /* reset precalc */\n            log10_range = log10(im->maxval) - log10(im->minval);\n        }\n        /* make sure first y=10^x gridline is located on\n           integer pixel position by moving scale slightly\n           downwards (sub-pixel movement) */\n        ypix = ytr(im, ya) + im->ysize; /* add im->ysize so it always is positive */\n        ypixfrac = ypix - floor(ypix);\n        if (ypixfrac > 0 && ypixfrac < 1) {\n            double    yfrac = ypixfrac / im->ysize;\n\n            im->minval = pow(10, log10(im->minval) - yfrac * log10_range);\n            im->maxval = pow(10, log10(im->maxval) - yfrac * log10_range);\n            ytr(im, DNAN);  /* reset precalc */\n        }\n    } else {\n        /* Make sure we have an integer pixel distance between\n           each minor gridline */\n        double    ypos1 = ytr(im, im->minval);\n        double    ypos2 = ytr(im, im->minval + im->ygrid_scale.gridstep);\n        double    y_pixel_delta = ypos1 - ypos2;\n        double    factor = y_pixel_delta / floor(y_pixel_delta);\n        double    new_range = factor * (im->maxval - im->minval);\n        double    gridstep = im->ygrid_scale.gridstep;\n        double    minor_y, minor_y_px, minor_y_px_frac;\n\n        if (im->maxval > 0.0)\n            im->maxval = im->minval + new_range;\n        else\n            im->minval = im->maxval - new_range;\n        ytr(im, DNAN);  /* reset precalc */\n        /* make sure first minor gridline is on integer pixel y coord */\n        minor_y = gridstep * floor(im->minval / gridstep);\n        while (minor_y < im->minval)\n            minor_y += gridstep;\n        minor_y_px = ytr(im, minor_y) + im->ysize;  /* ensure > 0 by adding ysize */\n        minor_y_px_frac = minor_y_px - floor(minor_y_px);\n        if (minor_y_px_frac > 0 && minor_y_px_frac < 1) {\n            double    yfrac = minor_y_px_frac / im->ysize;\n            double    range = im->maxval - im->minval;\n\n            im->minval = im->minval - yfrac * range;\n            im->maxval = im->maxval - yfrac * range;\n            ytr(im, DNAN);  /* reset precalc */\n        }\n        calc_horizontal_grid(im);   /* recalc with changed im->maxval */\n    }\n}\n\n/* reduce data reimplementation by Alex */\n\nvoid reduce_data(\n    enum cf_en cf,      /* which consolidation function ? */\n    unsigned long cur_step, /* step the data currently is in */\n    time_t *start,      /* start, end and step as requested ... */\n    time_t *end,        /* ... by the application will be   ... */\n    unsigned long *step,    /* ... adjusted to represent reality    */\n    unsigned long *ds_cnt,  /* number of data sources in file */\n    rrd_value_t **data)\n{                       /* two dimensional array containing the data */\n    int       i, reduce_factor = ceil((double) (*step) / (double) cur_step);\n    unsigned long col, dst_row, row_cnt, start_offset, end_offset, skiprows =\n        0;\n    rrd_value_t *srcptr, *dstptr;\n\n    (*step) = cur_step * reduce_factor; /* set new step size for reduced data */\n    dstptr = *data;\n    srcptr = *data;\n    row_cnt = ((*end) - (*start)) / cur_step;\n\n#ifdef DEBUG\n#define DEBUG_REDUCE\n#endif\n#ifdef DEBUG_REDUCE\n    printf(\"Reducing %lu rows with factor %i time %lu to %lu, step %lu\\n\",\n           row_cnt, reduce_factor, *start, *end, cur_step);\n    for (col = 0; col < row_cnt; col++) {\n        printf(\"time %10lu: \", *start + (col + 1) * cur_step);\n        for (i = 0; i < *ds_cnt; i++)\n            printf(\" %8.2e\", srcptr[*ds_cnt * col + i]);\n        printf(\"\\n\");\n    }\n#endif\n\n    /* We have to combine [reduce_factor] rows of the source\n     ** into one row for the destination.  Doing this we also\n     ** need to take care to combine the correct rows.  First\n     ** alter the start and end time so that they are multiples\n     ** of the new step time.  We cannot reduce the amount of\n     ** time so we have to move the end towards the future and\n     ** the start towards the past.\n     */\n    end_offset = (*end) % (*step);\n    start_offset = (*start) % (*step);\n\n    /* If there is a start offset (which cannot be more than\n     ** one destination row), skip the appropriate number of\n     ** source rows and one destination row.  The appropriate\n     ** number is what we do know (start_offset/cur_step) of\n     ** the new interval (*step/cur_step aka reduce_factor).\n     */\n#ifdef DEBUG_REDUCE\n    printf(\"start_offset: %lu  end_offset: %lu\\n\", start_offset, end_offset);\n    printf(\"row_cnt before:  %lu\\n\", row_cnt);\n#endif\n    if (start_offset) {\n        (*start) = (*start) - start_offset;\n        skiprows = reduce_factor - start_offset / cur_step;\n        srcptr += skiprows * *ds_cnt;\n        for (col = 0; col < (*ds_cnt); col++)\n            *dstptr++ = DNAN;\n        row_cnt -= skiprows;\n    }\n#ifdef DEBUG_REDUCE\n    printf(\"row_cnt between: %lu\\n\", row_cnt);\n#endif\n\n    /* At the end we have some rows that are not going to be\n     ** used, the amount is end_offset/cur_step\n     */\n    if (end_offset) {\n        (*end) = (*end) - end_offset + (*step);\n        skiprows = end_offset / cur_step;\n        row_cnt -= skiprows;\n    }\n#ifdef DEBUG_REDUCE\n    printf(\"row_cnt after:   %lu\\n\", row_cnt);\n#endif\n\n/* Sanity check: row_cnt should be multiple of reduce_factor */\n/* if this gets triggered, something is REALLY WRONG ... we die immediately */\n\n    if (row_cnt % reduce_factor) {\n        printf(\"SANITY CHECK: %lu rows cannot be reduced by %i \\n\",\n               row_cnt, reduce_factor);\n        printf(\"BUG in reduce_data()\\n\");\n        exit(1);\n    }\n\n    /* Now combine reduce_factor intervals at a time\n     ** into one interval for the destination.\n     */\n\n    for (dst_row = 0; (long int) row_cnt >= reduce_factor; dst_row++) {\n        for (col = 0; col < (*ds_cnt); col++) {\n            rrd_value_t newval = DNAN;\n            unsigned long validval = 0;\n\n            for (i = 0; i < reduce_factor; i++) {\n                if (isnan(srcptr[i * (*ds_cnt) + col])) {\n                    continue;\n                }\n                validval++;\n                if (isnan(newval))\n                    newval = srcptr[i * (*ds_cnt) + col];\n                else {\n                    switch (cf) {\n                    case CF_HWPREDICT:\n                    case CF_MHWPREDICT:\n                    case CF_DEVSEASONAL:\n                    case CF_DEVPREDICT:\n                    case CF_SEASONAL:\n                    case CF_AVERAGE:\n                        newval += srcptr[i * (*ds_cnt) + col];\n                        break;\n                    case CF_MINIMUM:\n                        newval = min(newval, srcptr[i * (*ds_cnt) + col]);\n                        break;\n                    case CF_FAILURES:\n                        /* an interval contains a failure if any subintervals contained a failure */\n                    case CF_MAXIMUM:\n                        newval = max(newval, srcptr[i * (*ds_cnt) + col]);\n                        break;\n                    case CF_LAST:\n                        newval = srcptr[i * (*ds_cnt) + col];\n                        break;\n                    }\n                }\n            }\n            if (validval == 0) {\n                newval = DNAN;\n            } else {\n                switch (cf) {\n                case CF_HWPREDICT:\n                case CF_MHWPREDICT:\n                case CF_DEVSEASONAL:\n                case CF_DEVPREDICT:\n                case CF_SEASONAL:\n                case CF_AVERAGE:\n                    newval /= validval;\n                    break;\n                case CF_MINIMUM:\n                case CF_FAILURES:\n                case CF_MAXIMUM:\n                case CF_LAST:\n                    break;\n                }\n            }\n            *dstptr++ = newval;\n        }\n        srcptr += (*ds_cnt) * reduce_factor;\n        row_cnt -= reduce_factor;\n    }\n    /* If we had to alter the endtime, we didn't have enough\n     ** source rows to fill the last row. Fill it with NaN.\n     */\n    if (end_offset)\n        for (col = 0; col < (*ds_cnt); col++)\n            *dstptr++ = DNAN;\n#ifdef DEBUG_REDUCE\n    row_cnt = ((*end) - (*start)) / *step;\n    srcptr = *data;\n    printf(\"Done reducing. Currently %lu rows, time %lu to %lu, step %lu\\n\",\n           row_cnt, *start, *end, *step);\n    for (col = 0; col < row_cnt; col++) {\n        printf(\"time %10lu: \", *start + (col + 1) * (*step));\n        for (i = 0; i < *ds_cnt; i++)\n            printf(\" %8.2e\", srcptr[*ds_cnt * col + i]);\n        printf(\"\\n\");\n    }\n#endif\n}\n\n\n/* get the data required for the graphs from the\n   relevant rrds ... */\n\nint data_fetch(\n    image_desc_t *im)\n{\n    int       i, ii;\n    /* pull the data from the rrd files ... */\n    for (i = 0; i < (int) im->gdes_c; i++) {\n        /* only GF_DEF elements fetch data */\n        if (im->gdes[i].gf != GF_DEF)\n            continue;\n\n        /* do we have it already ? */\n        gpointer value;\n        char *key = gdes_fetch_key(im->gdes[i]);\n        gboolean ok = g_hash_table_lookup_extended(im->rrd_map,key,NULL,&value);\n        free(key);\n        if (ok){\n            ii = GPOINTER_TO_INT(value);\n            im->gdes[i].start = im->gdes[ii].start;\n            im->gdes[i].end = im->gdes[ii].end;\n            im->gdes[i].step = im->gdes[ii].step;\n            im->gdes[i].ds_cnt = im->gdes[ii].ds_cnt;\n            im->gdes[i].ds_namv = im->gdes[ii].ds_namv;\n            im->gdes[i].data = im->gdes[ii].data;\n            im->gdes[i].data_first = 0;\n        } else {\n            unsigned long ft_step = im->gdes[i].step;   /* ft_step will record what we got from fetch */\n            const char *rrd_daemon;\n            int status;\n\n            if (im->gdes[i].daemon[0] != 0)\n                rrd_daemon = im->gdes[i].daemon;\n            else\n                rrd_daemon = im->daemon_addr;\n\n            /* \"daemon\" may be NULL. ENV_RRDCACHED_ADDRESS is evaluated in that\n             * case. If \"daemon\" holds the same value as in the previous\n             * iteration, no actual new connection is established - the\n             * existing connection is re-used. */\n            rrdc_connect (rrd_daemon);\n\n            /* If connecting was successfull, use the daemon to query the data.\n             * If there is no connection, for example because no daemon address\n             * was specified, (try to) use the local file directly. */\n            if (rrdc_is_connected (rrd_daemon))\n            {\n                status = rrdc_fetch (im->gdes[i].rrd,\n                        cf_to_string (im->gdes[i].cf),\n                        &im->gdes[i].start,\n                        &im->gdes[i].end,\n                        &ft_step,\n                        &im->gdes[i].ds_cnt,\n                        &im->gdes[i].ds_namv,\n                        &im->gdes[i].data);\n                if (status != 0) {\n                    if (im->extra_flags & ALLOW_MISSING_DS) {\n                        rrd_clear_error();\n                        if (rrd_fetch_empty(&im->gdes[i].start,\n                                            &im->gdes[i].end,\n                                            &ft_step,\n                                            &im->gdes[i].ds_cnt,\n                                            im->gdes[i].ds_nam,\n                                            &im->gdes[i].ds_namv,\n                                            &im->gdes[i].data) == -1)\n                            return -1;\n                    } else return (status);\n                }\n            }\n            else\n            {\n                if ((rrd_fetch_fn(im->gdes[i].rrd,\n                                im->gdes[i].cf,\n                                &im->gdes[i].start,\n                                &im->gdes[i].end,\n                                &ft_step,\n                                &im->gdes[i].ds_cnt,\n                                &im->gdes[i].ds_namv,\n                                &im->gdes[i].data)) == -1) {\n                    if (im->extra_flags & ALLOW_MISSING_DS) {\n                        /* Unable to fetch data, assume fake data */\n                        rrd_clear_error();\n                        if (rrd_fetch_empty(&im->gdes[i].start,\n                                            &im->gdes[i].end,\n                                            &ft_step,\n                                            &im->gdes[i].ds_cnt,\n                                            im->gdes[i].ds_nam,\n                                            &im->gdes[i].ds_namv,\n                                            &im->gdes[i].data) == -1)\n                            return -1;\n                    } else return -1;\n                }\n            }\n            im->gdes[i].data_first = 1;\n\n            /* must reduce to at least im->step\n               otherwhise we end up with more data than we can handle in the \n               chart and visibility of data will be random */            \n            im->gdes[i].step = max(im->gdes[i].step,im->step);\n            if (ft_step < im->gdes[i].step) {\n                \n                reduce_data(im->gdes[i].cf_reduce_set ? im->gdes[i].cf_reduce : im->gdes[i].cf,\n                            ft_step,\n                            &im->gdes[i].start,\n                            &im->gdes[i].end,\n                            &im->gdes[i].step,\n                            &im->gdes[i].ds_cnt, &im->gdes[i].data);\n            } else {\n                im->gdes[i].step = ft_step;\n            }\n        }\n\n        /* lets see if the required data source is really there */\n        for (ii = 0; ii < (int) im->gdes[i].ds_cnt; ii++) {\n            if (strcmp(im->gdes[i].ds_namv[ii], im->gdes[i].ds_nam) == 0) {\n                im->gdes[i].ds = ii;\n            }\n        }\n        if (im->gdes[i].ds == -1) {\n            rrd_set_error(\"No DS called '%s' in '%s'\",\n                          im->gdes[i].ds_nam, im->gdes[i].rrd);\n            return -1;\n        }\n        // remember that we already got this one\n        g_hash_table_insert(im->rrd_map,gdes_fetch_key(im->gdes[i]),GINT_TO_POINTER(i));\n    }\n    return 0;\n}\n\n/* evaluate the expressions in the CDEF functions */\n\n/*************************************************************\n * CDEF stuff\n *************************************************************/\n\n\n/* find the greatest common divisor for all the numbers\n   in the 0 terminated num array */\nlong lcd(\n    long *num)\n{\n    long      rest;\n    int       i;\n\n    for (i = 0; num[i + 1] != 0; i++) {\n        do {\n            rest = num[i] % num[i + 1];\n            num[i] = num[i + 1];\n            num[i + 1] = rest;\n        } while (rest != 0);\n        num[i + 1] = num[i];\n    }\n/*    return i==0?num[i]:num[i-1]; */\n    return num[i];\n}\n\n\n/* run the rpn calculator on all the VDEF and CDEF arguments */\nint data_calc(\n    image_desc_t *im)\n{\n\n    int       gdi;\n    int       dataidx;\n    long     *steparray, rpi;\n    int       stepcnt;\n    time_t    now;\n    rpnstack_t rpnstack;\n    rpnp_t   *rpnp;\n\n    rpnstack_init(&rpnstack);\n\n    for (gdi = 0; gdi < im->gdes_c; gdi++) {\n        /* Look for GF_VDEF and GF_CDEF in the same loop,\n         * so CDEFs can use VDEFs and vice versa\n         */\n        switch (im->gdes[gdi].gf) {\n        case GF_XPORT:\n            break;\n        case GF_SHIFT:{\n            graph_desc_t *vdp = &im->gdes[im->gdes[gdi].vidx];\n\n            /* remove current shift */\n            vdp->start -= vdp->shift;\n            vdp->end -= vdp->shift;\n\n            /* vdef */\n            if (im->gdes[gdi].shidx >= 0)\n                vdp->shift = im->gdes[im->gdes[gdi].shidx].vf.val;\n            /* constant */\n            else\n                vdp->shift = im->gdes[gdi].shval;\n\n            /* normalize shift to multiple of consolidated step */\n            vdp->shift = (vdp->shift / (long) vdp->step) * (long) vdp->step;\n\n            /* apply shift */\n            vdp->start += vdp->shift;\n            vdp->end += vdp->shift;\n            break;\n        }\n        case GF_VDEF:\n            /* A VDEF has no DS.  This also signals other parts\n             * of rrdtool that this is a VDEF value, not a CDEF.\n             */\n            im->gdes[gdi].ds_cnt = 0;\n            if (vdef_calc(im, gdi)) {\n                rrd_set_error(\"Error processing VDEF '%s'\",\n                              im->gdes[gdi].vname);\n                rpnstack_free(&rpnstack);\n                return -1;\n            }\n            break;\n        case GF_CDEF:\n            im->gdes[gdi].ds_cnt = 1;\n            im->gdes[gdi].ds = 0;\n            im->gdes[gdi].data_first = 1;\n            im->gdes[gdi].start = 0;\n            im->gdes[gdi].end = 0;\n            steparray = NULL;\n            stepcnt = 0;\n            dataidx = -1;\n\t    rpnp = im->gdes[gdi].rpnp;\n\n            /* Find the variables in the expression.\n             * - VDEF variables are substituted by their values\n             *   and the opcode is changed into OP_NUMBER.\n             * - CDEF variables are analized for their step size,\n             *   the lowest common denominator of all the step\n             *   sizes of the data sources involved is calculated\n             *   and the resulting number is the step size for the\n             *   resulting data source.\n             */\n            for (rpi = 0; im->gdes[gdi].rpnp[rpi].op != OP_END; rpi++) {\n                if (im->gdes[gdi].rpnp[rpi].op == OP_VARIABLE ||\n                    im->gdes[gdi].rpnp[rpi].op == OP_PREV_OTHER) {\n                    long      ptr = im->gdes[gdi].rpnp[rpi].ptr;\n\n                    if (im->gdes[ptr].ds_cnt == 0) {    /* this is a VDEF data source */\n#if 0\n                        printf\n                            (\"DEBUG: inside CDEF '%s' processing VDEF '%s'\\n\",\n                             im->gdes[gdi].vname, im->gdes[ptr].vname);\n                        printf(\"DEBUG: value from vdef is %f\\n\",\n                               im->gdes[ptr].vf.val);\n#endif\n                        im->gdes[gdi].rpnp[rpi].val = im->gdes[ptr].vf.val;\n                        im->gdes[gdi].rpnp[rpi].op = OP_NUMBER;\n                    } else {    /* normal variables and PREF(variables) */\n\n                        /* add one entry to the array that keeps track of the step sizes of the\n                         * data sources going into the CDEF. */\n                        if ((steparray =\n                             (long*)rrd_realloc(steparray,\n                                         (++stepcnt +\n                                          1) * sizeof(*steparray))) == NULL) {\n                            rrd_set_error(\"realloc steparray\");\n                            rpnstack_free(&rpnstack);\n                            return -1;\n                        };\n\n                        steparray[stepcnt - 1] = im->gdes[ptr].step;\n\n                        /* adjust start and end of cdef (gdi) so\n                         * that it runs from the latest start point\n                         * to the earliest endpoint of any of the\n                         * rras involved (ptr)\n                         */\n\n                        if (im->gdes[gdi].start < im->gdes[ptr].start)\n                            im->gdes[gdi].start = im->gdes[ptr].start;\n\n                        if (im->gdes[gdi].end == 0 ||\n                            im->gdes[gdi].end > im->gdes[ptr].end)\n                            im->gdes[gdi].end = im->gdes[ptr].end;\n\n                        /* store pointer to the first element of\n                         * the rra providing data for variable,\n                         * further save step size and data source\n                         * count of this rra\n                         */\n                        im->gdes[gdi].rpnp[rpi].data =\n                            im->gdes[ptr].data + im->gdes[ptr].ds;\n                        im->gdes[gdi].rpnp[rpi].step = im->gdes[ptr].step;\n                        im->gdes[gdi].rpnp[rpi].ds_cnt = im->gdes[ptr].ds_cnt;\n\n                        /* backoff the *.data ptr; this is done so\n                         * rpncalc() function doesn't have to treat\n                         * the first case differently\n                         */\n                    }   /* if ds_cnt != 0 */\n                }       /* if OP_VARIABLE */\n            }           /* loop through all rpi */\n\n            /* move the data pointers to the correct period */\n            for (rpi = 0; im->gdes[gdi].rpnp[rpi].op != OP_END; rpi++) {\n                if (im->gdes[gdi].rpnp[rpi].op == OP_VARIABLE ||\n                    im->gdes[gdi].rpnp[rpi].op == OP_PREV_OTHER) {\n                    long      ptr = im->gdes[gdi].rpnp[rpi].ptr;\n                    long      diff =\n                        im->gdes[gdi].start - im->gdes[ptr].start;\n\n                    if (diff > 0)\n                        im->gdes[gdi].rpnp[rpi].data +=\n                            (diff / im->gdes[ptr].step) *\n                            im->gdes[ptr].ds_cnt;\n                }\n            }\n\n            if (steparray == NULL) {\n                rrd_set_error(\"rpn expressions without DEF\"\n                              \" or CDEF variables are not supported\");\n                rpnstack_free(&rpnstack);\n                return -1;\n            }\n            steparray[stepcnt] = 0;\n            /* Now find the resulting step.  All steps in all\n             * used RRAs have to be visited\n             */\n            im->gdes[gdi].step = lcd(steparray);\n            free(steparray);\n            if ((im->gdes[gdi].data = (rrd_value_t*)malloc(((im->gdes[gdi].end -\n                                               im->gdes[gdi].start)\n                                              / im->gdes[gdi].step)\n                                             * sizeof(double))) == NULL) {\n                rrd_set_error(\"malloc im->gdes[gdi].data\");\n                rpnstack_free(&rpnstack);\n                return -1;\n            }\n\n            /* Step through the new cdef results array and\n             * calculate the values\n             */\n            for (now = im->gdes[gdi].start + im->gdes[gdi].step;\n                 now <= im->gdes[gdi].end; now += im->gdes[gdi].step) {\n\n                /* 3rd arg of rpn_calc is for OP_VARIABLE lookups;\n                 * in this case we are advancing by timesteps;\n                 * we use the fact that time_t is a synonym for long\n                 */\n                if (rpn_calc(rpnp, &rpnstack, (long) now,\n                             im->gdes[gdi].data, ++dataidx) == -1) {\n                    /* rpn_calc sets the error string */\n                    rpnstack_free(&rpnstack);\n\t\t    rpnp_freeextra(rpnp);\n                    return -1;\n                }\n            }           /* enumerate over time steps within a CDEF */\n\t    rpnp_freeextra(rpnp);\n\t    \n            break;\n        default:\n            continue;\n        }\n    }                   /* enumerate over CDEFs */\n    rpnstack_free(&rpnstack);\n    return 0;\n}\n\n/* from http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm */\n/* yes we are loosing precision by doing tos with floats instead of doubles\n   but it seems more stable this way. */\n\nstatic int AlmostEqual2sComplement(\n    float A,\n    float B,\n    int maxUlps)\n{\n\n    int       aInt = *(int *) &A;\n    int       bInt = *(int *) &B;\n    int       intDiff;\n\n    /* Make sure maxUlps is non-negative and small enough that the\n       default NAN won't compare as equal to anything.  */\n\n    /* assert(maxUlps > 0 && maxUlps < 4 * 1024 * 1024); */\n\n    /* Make aInt lexicographically ordered as a twos-complement int */\n\n    if (aInt < 0)\n        aInt = 0x80000000l - aInt;\n\n    /* Make bInt lexicographically ordered as a twos-complement int */\n\n    if (bInt < 0)\n        bInt = 0x80000000l - bInt;\n\n    intDiff = abs(aInt - bInt);\n\n    if (intDiff <= maxUlps)\n        return 1;\n\n    return 0;\n}\n\n/* massage data so, that we get one value for each x coordinate in the graph */\nint data_proc(\n    image_desc_t *im)\n{\n    long      i, ii;\n    double    pixstep = (double) (im->end - im->start)\n        / (double) im->xsize;   /* how much time\n                                   passes in one pixel */\n    double    paintval;\n    double    minval = DNAN, maxval = DNAN;\n\n    unsigned long gr_time;\n\n    /* memory for the processed data */\n    for (i = 0; i < im->gdes_c; i++) {\n        if ((im->gdes[i].gf == GF_LINE)\n         || (im->gdes[i].gf == GF_AREA) \n         || (im->gdes[i].gf == GF_TICK)\n         || (im->gdes[i].gf == GF_GRAD)\n        ) {\n            if ((im->gdes[i].p_data = (rrd_value_t*)malloc((im->xsize + 1)\n                                             * sizeof(rrd_value_t))) == NULL) {\n                rrd_set_error(\"malloc data_proc\");\n                return -1;\n            }\n        }\n    }\n\n    for (i = 0; i < im->xsize; i++) {   /* for each pixel */\n        long      vidx;\n\n        gr_time = im->start + pixstep * i;  /* time of the current step */\n        paintval = 0.0;\n\n        for (ii = 0; ii < im->gdes_c; ii++) {\n            double    value;\n\n            switch (im->gdes[ii].gf) {\n            case GF_LINE:\n            case GF_AREA:\n\t\t\tcase GF_GRAD:\n            case GF_TICK:\n                if (!im->gdes[ii].stack)\n                    paintval = 0.0;\n                value = im->gdes[ii].yrule;\n                if (isnan(value) || (im->gdes[ii].gf == GF_TICK)) {\n                    /* The time of the data doesn't necessarily match\n                     ** the time of the graph. Beware.\n                     */\n                    vidx = im->gdes[ii].vidx;\n                    if (im->gdes[vidx].gf == GF_VDEF) {\n                        value = im->gdes[vidx].vf.val;\n                    } else\n                        if (((long int) gr_time >=\n                             (long int) im->gdes[vidx].start)\n                            && ((long int) gr_time <\n                                (long int) im->gdes[vidx].end)) {\n                        value = im->gdes[vidx].data[(unsigned long)\n                                                    floor((double)\n                                                          (gr_time -\n                                                           im->gdes[vidx].\n                                                           start)\n                                                          /\n                                                          im->gdes[vidx].step)\n                                                    * im->gdes[vidx].ds_cnt +\n                                                    im->gdes[vidx].ds];\n                    } else {\n                        value = DNAN;\n                    }\n                };\n\n                if (!isnan(value)) {\n                    paintval += value;\n                    im->gdes[ii].p_data[i] = paintval;\n                    /* GF_TICK: the data values are not\n                     ** relevant for min and max\n                     */\n                    if (finite(paintval) && im->gdes[ii].gf != GF_TICK && !im->gdes[ii].skipscale) {\n                        if ((isnan(minval) || paintval < minval) &&\n                            !(im->logarithmic && paintval <= 0.0))\n                            minval = paintval;\n                        if (isnan(maxval) || paintval > maxval)\n                            maxval = paintval;\n                    }\n                } else {\n                    im->gdes[ii].p_data[i] = DNAN;\n                }\n                break;\n            case GF_STACK:\n                rrd_set_error\n                    (\"STACK should already be turned into LINE or AREA here\");\n                return -1;\n                break;\n            default:\n                break;\n            }\n        }\n    }\n\n    /* if min or max have not been asigned a value this is because\n       there was no data in the graph ... this is not good ...\n       lets set these to dummy values then ... */\n\n    if (im->logarithmic) {\n        if (isnan(minval) || isnan(maxval) || maxval <= 0) {\n            minval = 0.0;   /* catching this right away below */\n            maxval = 5.1;\n        }\n        /* in logarithm mode, where minval is smaller or equal\n           to 0 make the beast just way smaller than maxval */\n        if (minval <= 0) {\n            minval = maxval / 10e8;\n        }\n    } else {\n        if (isnan(minval) || isnan(maxval)) {\n            minval = 0.0;\n            maxval = 1.0;\n        }\n    }\n\n    /* adjust min and max values given by the user */\n    /* for logscale we add something on top */\n    if (isnan(im->minval)\n        || ((!im->rigid) && im->minval > minval)\n        ) {\n        if (im->logarithmic)\n            im->minval = minval / 2.0;\n        else\n            im->minval = minval;\n    }\n    if (isnan(im->maxval)\n        || (!im->rigid && im->maxval < maxval)\n        ) {\n        if (im->logarithmic)\n            im->maxval = maxval * 2.0;\n        else\n            im->maxval = maxval;\n    }\n\n    /* make sure min is smaller than max */\n    if (im->minval > im->maxval) {\n        if (im->minval > 0)\n            im->minval = 0.99 * im->maxval;\n        else\n            im->minval = 1.01 * im->maxval;\n    }\n\n    /* make sure min and max are not equal */\n    if (AlmostEqual2sComplement(im->minval, im->maxval, 4)) {\n        if (im->maxval > 0)\n            im->maxval *= 1.01;\n        else\n            im->maxval *= 0.99;\n\n        /* make sure min and max are not both zero */\n        if (AlmostEqual2sComplement(im->maxval, 0, 4)) {\n            im->maxval = 1.0;\n        }\n    }\n    return 0;\n}\n\nstatic int find_first_weekday(void){\n    static int first_weekday = -1;\n    if (first_weekday == -1){\n#ifdef HAVE__NL_TIME_WEEK_1STDAY\n        /* according to http://sourceware.org/ml/libc-locales/2009-q1/msg00011.html */\n        /* See correct way here http://pasky.or.cz/dev/glibc/first_weekday.c */\n        first_weekday = nl_langinfo (_NL_TIME_FIRST_WEEKDAY)[0];\n        int week_1stday;\n        long week_1stday_l = (long) nl_langinfo (_NL_TIME_WEEK_1STDAY);\n        if (week_1stday_l == 19971130) week_1stday = 0; /* Sun */\n        else if (week_1stday_l == 19971201) week_1stday = 1; /* Mon */\n        else\n        {\n            first_weekday = 1;\n            return first_weekday; /* we go for a monday default */\n        }\n        first_weekday=(week_1stday + first_weekday - 1) % 7;\n#else\n        first_weekday = 1;\n#endif\n    }\n    return first_weekday;\n}\n\n/* identify the point where the first gridline, label ... gets placed */\n\ntime_t find_first_time(\n    time_t start,       /* what is the initial time */\n    enum tmt_en baseint,    /* what is the basic interval */\n    long basestep       /* how many if these do we jump a time */\n    )\n{\n    struct tm tm;\n\n    localtime_r(&start, &tm);\n    /* let mktime figure this dst on its own */\n    tm.tm_isdst = -1;\n\n    switch (baseint) {\n    case TMT_SECOND:\n        tm.       tm_sec -= tm.tm_sec % basestep;\n\n        break;\n    case TMT_MINUTE:\n        tm.       tm_sec = 0;\n        tm.       tm_min -= tm.tm_min % basestep;\n\n        break;\n    case TMT_HOUR:\n        tm.       tm_sec = 0;\n        tm.       tm_min = 0;\n        tm.       tm_hour -= tm.tm_hour % basestep;\n\n        break;\n    case TMT_DAY:\n        /* we do NOT look at the basestep for this ... */\n        tm.       tm_sec = 0;\n        tm.       tm_min = 0;\n        tm.       tm_hour = 0;\n\n        break;\n    case TMT_WEEK:\n        /* we do NOT look at the basestep for this ... */\n        tm.       tm_sec = 0;\n        tm.       tm_min = 0;\n        tm.       tm_hour = 0;\n        tm.       tm_mday -= tm.tm_wday - find_first_weekday();\n\n        if (tm.tm_wday == 0 && find_first_weekday() > 0)\n            tm.       tm_mday -= 7; /* we want the *previous* week */\n\n        break;\n    case TMT_MONTH:\n        tm.       tm_sec = 0;\n        tm.       tm_min = 0;\n        tm.       tm_hour = 0;\n        tm.       tm_mday = 1;\n        tm.       tm_mon -= tm.tm_mon % basestep;\n\n        break;\n\n    case TMT_YEAR:\n        tm.       tm_sec = 0;\n        tm.       tm_min = 0;\n        tm.       tm_hour = 0;\n        tm.       tm_mday = 1;\n        tm.       tm_mon = 0;\n        tm.       tm_year -= (\n    tm.tm_year + 1900) %basestep;\n\n    }\n    return mktime(&tm);\n}\n\n/* identify the point where the next gridline, label ... gets placed */\ntime_t find_next_time(\n    time_t current,     /* what is the initial time */\n    enum tmt_en baseint,    /* what is the basic interval */\n    long basestep       /* how many if these do we jump a time */\n    )\n{\n    struct tm tm;\n    time_t    madetime;\n\n    localtime_r(&current, &tm);\n    /* let mktime figure this dst on its own */\n    tm.tm_isdst = -1;\n\n    int limit = 2;\n    switch (baseint) {\n    case TMT_SECOND: limit = 7200; break;\n    case TMT_MINUTE: limit = 120; break;\n    case TMT_HOUR: limit = 2; break;\n    default: limit = 2; break;\n    }\n    do {\n        switch (baseint) {\n        case TMT_SECOND:\n            tm.       tm_sec += basestep;\n\n            break;\n        case TMT_MINUTE:\n            tm.       tm_min += basestep;\n\n            break;\n        case TMT_HOUR:\n            tm.       tm_hour += basestep;\n\n            break;\n        case TMT_DAY:\n            tm.       tm_mday += basestep;\n\n            break;\n        case TMT_WEEK:\n            tm.       tm_mday += 7 * basestep;\n\n            break;\n        case TMT_MONTH:\n            tm.       tm_mon += basestep;\n\n            break;\n        case TMT_YEAR:\n            tm.       tm_year += basestep;\n        }\n        madetime = mktime(&tm);\n    } while (madetime == -1 && limit-- >= 0);   /* this is necessary to skip impossible times\n                                   like the daylight saving time skips */\n    return madetime;\n\n}\n\n\n/* calculate values required for PRINT and GPRINT functions */\n\nint print_calc(\n    image_desc_t *im)\n{\n    long      i, ii, validsteps;\n    double    printval;\n    struct tm tmvdef;\n    int       graphelement = 0;\n    long      vidx;\n    int       max_ii;\n    double    magfact = -1;\n    char     *si_symb = \"\";\n    char     *percent_s;\n    int       prline_cnt = 0;\n\n    /* wow initializing tmvdef is quite a task :-) */\n    time_t    now = time(NULL);\n\n    localtime_r(&now, &tmvdef);\n    for (i = 0; i < im->gdes_c; i++) {\n        vidx = im->gdes[i].vidx;\n        switch (im->gdes[i].gf) {\n        case GF_PRINT:\n        case GF_GPRINT:\n            /* PRINT and GPRINT can now print VDEF generated values.\n             * There's no need to do any calculations on them as these\n             * calculations were already made.\n             */\n            if (im->gdes[vidx].gf == GF_VDEF) { /* simply use vals */\n                printval = im->gdes[vidx].vf.val;\n                localtime_r(&im->gdes[vidx].vf.when, &tmvdef);\n            } else {    /* need to calculate max,min,avg etcetera */\n                max_ii = ((im->gdes[vidx].end - im->gdes[vidx].start)\n                          / im->gdes[vidx].step * im->gdes[vidx].ds_cnt);\n                printval = DNAN;\n                validsteps = 0;\n                for (ii = im->gdes[vidx].ds;\n                     ii < max_ii; ii += im->gdes[vidx].ds_cnt) {\n                    if (!finite(im->gdes[vidx].data[ii]))\n                        continue;\n                    if (isnan(printval)) {\n                        printval = im->gdes[vidx].data[ii];\n                        validsteps++;\n                        continue;\n                    }\n\n                    switch (im->gdes[i].cf) {\n                    case CF_HWPREDICT:\n                    case CF_MHWPREDICT:\n                    case CF_DEVPREDICT:\n                    case CF_DEVSEASONAL:\n                    case CF_SEASONAL:\n                    case CF_AVERAGE:\n                        validsteps++;\n                        printval += im->gdes[vidx].data[ii];\n                        break;\n                    case CF_MINIMUM:\n                        printval = min(printval, im->gdes[vidx].data[ii]);\n                        break;\n                    case CF_FAILURES:\n                    case CF_MAXIMUM:\n                        printval = max(printval, im->gdes[vidx].data[ii]);\n                        break;\n                    case CF_LAST:\n                        printval = im->gdes[vidx].data[ii];\n                    }\n                }\n                if (im->gdes[i].cf == CF_AVERAGE || im->gdes[i].cf > CF_LAST) {\n                    if (validsteps > 1) {\n                        printval = (printval / validsteps);\n                    }\n                }\n            }           /* prepare printval */\n\n            if (!im->gdes[i].strftm && (percent_s = strstr(im->gdes[i].format, \"%S\")) != NULL) {\n                /* Magfact is set to -1 upon entry to print_calc.  If it\n                 * is still less than 0, then we need to run auto_scale.\n                 * Otherwise, put the value into the correct units.  If\n                 * the value is 0, then do not set the symbol or magnification\n                 * so next the calculation will be performed again. */\n                if (magfact < 0.0) {\n                    auto_scale(im, &printval, &si_symb, &magfact);\n                    if (printval == 0.0)\n                        magfact = -1.0;\n                } else {\n                    printval /= magfact;\n                }\n                *(++percent_s) = 's';\n            } else if (!im->gdes[i].strftm && strstr(im->gdes[i].format, \"%s\") != NULL) {\n                auto_scale(im, &printval, &si_symb, &magfact);\n            }\n\n            if (im->gdes[i].gf == GF_PRINT) {\n                rrd_infoval_t prline;\n\n                if (im->gdes[i].strftm) {\n                    prline.u_str = (char*)malloc((FMT_LEG_LEN + 2) * sizeof(char));\n                    if (im->gdes[vidx].vf.never == 1) {\n                       time_clean(prline.u_str, im->gdes[i].format);\n                    } else {\n                        strftime(prline.u_str,\n                                 FMT_LEG_LEN, im->gdes[i].format, &tmvdef);\n                    }\n                } else if (bad_format(im->gdes[i].format)) {\n                    rrd_set_error\n                        (\"bad format for PRINT in '%s'\", im->gdes[i].format);\n                    return -1;\n                } else {\n                    prline.u_str =\n                        sprintf_alloc(im->gdes[i].format, printval, si_symb);\n                }\n                grinfo_push(im,\n                            sprintf_alloc\n                            (\"print[%ld]\", prline_cnt++), RD_I_STR, prline);\n                free(prline.u_str);\n            } else {\n                /* GF_GPRINT */\n\n                if (im->gdes[i].strftm) {\n                    if (im->gdes[vidx].vf.never == 1) {\n                       time_clean(im->gdes[i].legend, im->gdes[i].format);\n                    } else {\n                        strftime(im->gdes[i].legend,\n                                 FMT_LEG_LEN, im->gdes[i].format, &tmvdef);\n                    }\n                } else {\n                    if (bad_format(im->gdes[i].format)) {\n                        rrd_set_error\n                            (\"bad format for GPRINT in '%s'\",\n                             im->gdes[i].format);\n                        return -1;\n                    }\n                    snprintf(im->gdes[i].legend,\n                             FMT_LEG_LEN - 2,\n                             im->gdes[i].format, printval, si_symb);\n                }\n                graphelement = 1;\n            }\n            break;\n        case GF_LINE:\n        case GF_AREA:\n\t\tcase GF_GRAD:\n        case GF_TICK:\n            graphelement = 1;\n            break;\n        case GF_HRULE:\n            if (isnan(im->gdes[i].yrule)) { /* we must set this here or the legend printer can not decide to print the legend */\n                im->gdes[i].yrule = im->gdes[vidx].vf.val;\n            };\n            graphelement = 1;\n            break;\n        case GF_VRULE:\n            if (im->gdes[i].xrule == 0) {   /* again ... the legend printer needs it */\n                im->gdes[i].xrule = im->gdes[vidx].vf.when;\n            };\n            graphelement = 1;\n            break;\n        case GF_COMMENT:\n        case GF_TEXTALIGN:\n        case GF_DEF:\n        case GF_CDEF:\n        case GF_VDEF:\n#ifdef WITH_PIECHART\n        case GF_PART:\n#endif\n        case GF_SHIFT:\n        case GF_XPORT:\n            break;\n        case GF_STACK:\n            rrd_set_error\n                (\"STACK should already be turned into LINE or AREA here\");\n            return -1;\n            break;\n        case GF_XAXIS:\n        case GF_YAXIS:\n\t    break;\n        }\n    }\n    return graphelement;\n}\n\n\n\n/* place legends with color spots */\nint leg_place(\n    image_desc_t *im,\n    int calc_width)\n{\n    /* graph labels */\n    int       interleg = im->text_prop[TEXT_PROP_LEGEND].size * 2.0;\n    int       border = im->text_prop[TEXT_PROP_LEGEND].size * 2.0;\n    int       fill = 0, fill_last;\n    double    legendwidth; // = im->ximg - 2 * border;\n    int       leg_c = 0;\n    double    leg_x = border;\n    int       leg_y = 0; //im->yimg;\n    int       leg_cc;\n    double    glue = 0;\n    int       i, ii, mark = 0;\n    char      default_txtalign = TXA_JUSTIFIED; /*default line orientation */\n    int      *legspace;\n    char     *tab;\n    char      saved_legend[FMT_LEG_LEN + 5];\n\n    if(calc_width){\n        legendwidth = 0;\n    }\n    else{\n        legendwidth = im->legendwidth - 2 * border;\n    }\n\n\n    if (!(im->extra_flags & NOLEGEND) && !(im->extra_flags & ONLY_GRAPH)) {\n        if ((legspace = (int*)malloc(im->gdes_c * sizeof(int))) == NULL) {\n            rrd_set_error(\"malloc for legspace\");\n            return -1;\n        }\n\n        for (i = 0; i < im->gdes_c; i++) {\n            char      prt_fctn; /*special printfunctions */\n            if(calc_width){\n                strncpy(saved_legend, im->gdes[i].legend, sizeof saved_legend);\n            }\n\n            fill_last = fill;\n            /* hide legends for rules which are not displayed */\n            if (im->gdes[i].gf == GF_TEXTALIGN) {\n                default_txtalign = im->gdes[i].txtalign;\n            }\n\n            if (!(im->extra_flags & FORCE_RULES_LEGEND)) {\n                if (im->gdes[i].gf == GF_HRULE\n                    && (im->gdes[i].yrule <\n                        im->minval || im->gdes[i].yrule > im->maxval))\n                    im->gdes[i].legend[0] = '\\0';\n                if (im->gdes[i].gf == GF_VRULE\n                    && (im->gdes[i].xrule <\n                        im->start || im->gdes[i].xrule > im->end))\n                    im->gdes[i].legend[0] = '\\0';\n            }\n\n            /* turn \\\\t into tab */\n            while ((tab = strstr(im->gdes[i].legend, \"\\\\t\"))) {\n                memmove(tab, tab + 1, strlen(tab));\n                tab[0] = (char) 9;\n            }\n\n            leg_cc = strlen(im->gdes[i].legend);\n            /* is there a controle code at the end of the legend string ? */\n            if (leg_cc >= 2 && im->gdes[i].legend[leg_cc - 2] == '\\\\') {\n                prt_fctn = im->gdes[i].legend[leg_cc - 1];\n                leg_cc -= 2;\n                im->gdes[i].legend[leg_cc] = '\\0';\n            } else {\n                prt_fctn = '\\0';\n            }\n            /* only valid control codes */\n            if (prt_fctn != 'l' && prt_fctn != 'n' &&   /* a synonym for l */\n                prt_fctn != 'r' &&\n                prt_fctn != 'j' &&\n                prt_fctn != 'c' &&\n                prt_fctn != 'u' &&\n                prt_fctn != '.' &&\n                prt_fctn != 's' && prt_fctn != '\\0' && prt_fctn != 'g') {\n                free(legspace);\n                rrd_set_error\n                    (\"Unknown control code at the end of '%s\\\\%c'\",\n                     im->gdes[i].legend, prt_fctn);\n                return -1;\n            }\n            /* \\n -> \\l */\n            if (prt_fctn == 'n') {\n                prt_fctn = 'l';\n            }\n            /* \\. is a null operation to allow strings ending in \\x */\n            if (prt_fctn == '.') {\n                prt_fctn = '\\0';\n            }\n\n            /* remove exess space from the end of the legend for \\g */\n            while (prt_fctn == 'g' &&\n                   leg_cc > 0 && im->gdes[i].legend[leg_cc - 1] == ' ') {\n                leg_cc--;\n                im->gdes[i].legend[leg_cc] = '\\0';\n            }\n\n            if (leg_cc != 0) {\n\n                /* no interleg space if string ends in \\g */\n                legspace[i] = (prt_fctn == 'g' ? 0 : interleg);\n                if (fill > 0) {\n                    fill += legspace[i];\n                }\n                fill +=\n                    gfx_get_text_width(im,\n                                       fill + border,\n                                       im->\n                                       text_prop\n                                       [TEXT_PROP_LEGEND].\n                                       font_desc,\n                                       im->tabwidth, im->gdes[i].legend);\n                leg_c++;\n            } else {\n                legspace[i] = 0;\n            }\n            /* who said there was a special tag ... ? */\n            if (prt_fctn == 'g') {\n                prt_fctn = '\\0';\n            }\n\n            if (prt_fctn == '\\0') {\n                if(calc_width && (fill > legendwidth)){\n                    legendwidth = fill;\n                }\n                if (i == im->gdes_c - 1 || fill > legendwidth) {\n                    /* just one legend item is left right or center */\n                    switch (default_txtalign) {\n                    case TXA_RIGHT:\n                        prt_fctn = 'r';\n                        break;\n                    case TXA_CENTER:\n                        prt_fctn = 'c';\n                        break;\n                    case TXA_JUSTIFIED:\n                        prt_fctn = 'j';\n                        break;\n                    default:\n                        prt_fctn = 'l';\n                        break;\n                    }\n                }\n                /* is it time to place the legends ? */\n                if (fill > legendwidth) {\n                    if (leg_c > 1) {\n                        /* go back one */\n                        i--;\n                        fill = fill_last;\n                        leg_c--;\n                    }\n                }\n                if (leg_c == 1 && prt_fctn == 'j') {\n                    prt_fctn = 'l';\n                }\n            }\n\n            if (prt_fctn != '\\0') {\n                leg_x = border;\n                if (leg_c >= 2 && prt_fctn == 'j') {\n                    glue = (double)(legendwidth - fill) / (double)(leg_c - 1);\n                } else {\n                    glue = 0;\n                }\n                if (prt_fctn == 'c')\n                    leg_x = border + (double)(legendwidth - fill) / 2.0;\n                if (prt_fctn == 'r')\n                    leg_x = legendwidth - fill + border;\n                for (ii = mark; ii <= i; ii++) {\n                    if (im->gdes[ii].legend[0] == '\\0')\n                        continue;   /* skip empty legends */\n                    im->gdes[ii].leg_x = leg_x;\n                    im->gdes[ii].leg_y = leg_y + border;\n                    leg_x +=\n                        (double)gfx_get_text_width(im, leg_x,\n                                           im->\n                                           text_prop\n                                           [TEXT_PROP_LEGEND].\n                                           font_desc,\n                                           im->tabwidth, im->gdes[ii].legend)\n                        +(double)legspace[ii]\n                        + glue;\n                }\n                if (leg_x > border || prt_fctn == 's')\n                    leg_y += im->text_prop[TEXT_PROP_LEGEND].size * 1.8;\n                if (prt_fctn == 's')\n                    leg_y -= im->text_prop[TEXT_PROP_LEGEND].size;\n                if (prt_fctn == 'u')\n                    leg_y -= im->text_prop[TEXT_PROP_LEGEND].size *1.8;\n\n                if(calc_width && (fill > legendwidth)){\n                    legendwidth = fill;\n                }\n                fill = 0;\n                leg_c = 0;\n                mark = ii;\n            }\n\n            if(calc_width){\n                strncpy(im->gdes[i].legend, saved_legend, sizeof im->gdes[0].legend);\n            }\n        }\n\n        if(calc_width){\n            im->legendwidth = legendwidth + 2 * border;\n        }\n        else{\n            im->legendheight = leg_y + border * 0.6;\n        }\n        free(legspace);\n    }\n    return 0;\n}\n\n/* create a grid on the graph. it determines what to do\n   from the values of xsize, start and end */\n\n/* the xaxis labels are determined from the number of seconds per pixel\n   in the requested graph */\n\nint calc_horizontal_grid(\n    image_desc_t\n    *im)\n{\n    double    range;\n    double    scaledrange;\n    int       pixel, i;\n    int       gridind = 0;\n    int       decimals, fractionals;\n\n    im->ygrid_scale.labfact = 2;\n    range = im->maxval - im->minval;\n    scaledrange = range / im->magfact;\n    /* does the scale of this graph make it impossible to put lines\n       on it? If so, give up. */\n    if (isnan(scaledrange)) {\n        return 0;\n    }\n\n    /* find grid spaceing */\n    pixel = 1;\n    if (isnan(im->ygridstep)) {\n        if (im->extra_flags & ALTYGRID) {\n            /* find the value with max number of digits. Get number of digits */\n            decimals =\n                ceil(log10\n                     (max(fabs(im->maxval), fabs(im->minval)) *\n                      im->viewfactor / im->magfact));\n            if (decimals <= 0)  /* everything is small. make place for zero */\n                decimals = 1;\n            im->ygrid_scale.gridstep =\n                pow((double) 10,\n                    floor(log10(range * im->viewfactor / im->magfact))) /\n                im->viewfactor * im->magfact;\n            if (im->ygrid_scale.gridstep == 0)  /* range is one -> 0.1 is reasonable scale */\n                im->ygrid_scale.gridstep = 0.1;\n            /* should have at least 5 lines but no more then 15 */\n            if (range / im->ygrid_scale.gridstep < 5\n                && im->ygrid_scale.gridstep >= 30)\n                im->ygrid_scale.gridstep /= 10;\n            if (range / im->ygrid_scale.gridstep > 15)\n                im->ygrid_scale.gridstep *= 10;\n            if (range / im->ygrid_scale.gridstep > 5) {\n                im->ygrid_scale.labfact = 1;\n                if (range / im->ygrid_scale.gridstep > 8\n                    || im->ygrid_scale.gridstep <\n                    1.8 * im->text_prop[TEXT_PROP_AXIS].size)\n                    im->ygrid_scale.labfact = 2;\n            } else {\n                im->ygrid_scale.gridstep /= 5;\n                im->ygrid_scale.labfact = 5;\n            }\n            fractionals =\n                floor(log10\n                      (im->ygrid_scale.gridstep *\n                       (double) im->ygrid_scale.labfact * im->viewfactor /\n                       im->magfact));\n            if (fractionals < 0) {  /* small amplitude. */\n                int       len = decimals - fractionals + 1;\n\n                if (im->unitslength < len + 2)\n                    im->unitslength = len + 2;\n                snprintf(im->ygrid_scale.labfmt, sizeof im->ygrid_scale.labfmt, \n                        \"%%%d.%df%s\", len,\n                        -fractionals, (im->symbol != ' ' ? \" %c\" : \"\"));\n            } else {\n                int       len = decimals + 1;\n\n                if (im->unitslength < len + 2)\n                    im->unitslength = len + 2;\n                snprintf(im->ygrid_scale.labfmt, sizeof im->ygrid_scale.labfmt,\n                        \"%%%d.0f%s\", len, (im->symbol != ' ' ? \" %c\" : \"\"));\n            }\n        } else {        /* classic rrd grid */\n            for (i = 0; ylab[i].grid > 0; i++) {\n                pixel = im->ysize / (scaledrange / ylab[i].grid);\n                gridind = i;\n                if (pixel >= 5)\n                    break;\n            }\n\n            for (i = 0; i < 4; i++) {\n                if (pixel * ylab[gridind].lfac[i] >=\n                    1.8 * im->text_prop[TEXT_PROP_AXIS].size) {\n                    im->ygrid_scale.labfact = ylab[gridind].lfac[i];\n                    break;\n                }\n            }\n\n            im->ygrid_scale.gridstep = ylab[gridind].grid * im->magfact;\n        }\n    } else {\n        im->ygrid_scale.gridstep = im->ygridstep;\n        im->ygrid_scale.labfact = im->ylabfact;\n    }\n    return 1;\n}\n\nint draw_horizontal_grid(\n    image_desc_t\n    *im)\n{\n    int       i;\n    double    scaledstep;\n    char      graph_label[100];\n    int       nlabels = 0;\n    double    X0 = im->xorigin;\n    double    X1 = im->xorigin + im->xsize;\n    int       sgrid = (int) (im->minval / im->ygrid_scale.gridstep - 1);\n    int       egrid = (int) (im->maxval / im->ygrid_scale.gridstep + 1);\n    double    MaxY;\n    double second_axis_magfact = 0;\n    char *second_axis_symb = \"\";\n\n    scaledstep =\n        im->ygrid_scale.gridstep /\n        (double) im->magfact * (double) im->viewfactor;\n    MaxY = scaledstep * (double) egrid;\n    for (i = sgrid; i <= egrid; i++) {\n        double    Y0 = ytr(im,\n                           im->ygrid_scale.gridstep * i);\n        double    YN = ytr(im,\n                           im->ygrid_scale.gridstep * (i + 1));\n\n        if (floor(Y0 + 0.5) >=\n            im->yorigin - im->ysize && floor(Y0 + 0.5) <= im->yorigin) {\n            /* Make sure at least 2 grid labels are shown, even if it doesn't agree\n               with the chosen settings. Add a label if required by settings, or if\n               there is only one label so far and the next grid line is out of bounds. */\n            if (i % im->ygrid_scale.labfact == 0\n                || (nlabels == 1\n                    && (YN < im->yorigin - im->ysize || YN > im->yorigin))) {\n                if (im->symbol == ' ') {\n                    if (im->primary_axis_format == NULL || im->primary_axis_format[0] == '\\0') {\n                        if (im->extra_flags & ALTYGRID) {\n                            snprintf(graph_label, sizeof graph_label,\n                                    im->ygrid_scale.labfmt,\n                                    scaledstep * (double) i);\n                        } else {\n                            if (MaxY < 10) {\n                                snprintf(graph_label, sizeof graph_label, \"%4.1f\",\n                                        scaledstep * (double) i);\n                            } else {\n                                snprintf(graph_label, sizeof graph_label,\"%4.0f\",\n                                        scaledstep * (double) i);\n                            }\n                        }\n                    } else {\n                        snprintf(graph_label, sizeof graph_label, im->primary_axis_format,\n                                scaledstep * (double) i);\n                    }\n                } else {\n                    char      sisym = (i == 0 ? ' ' : im->symbol);                   \n                    if (im->primary_axis_format == NULL || im->primary_axis_format[0] == '\\0') {\n                        if (im->extra_flags & ALTYGRID) {\n                            snprintf(graph_label,sizeof graph_label,\n                                    im->ygrid_scale.labfmt,\n                                    scaledstep * (double) i, sisym);\n                        } else {\n                            if (MaxY < 10) {\n                                snprintf(graph_label, sizeof graph_label,\"%4.1f %c\",\n                                        scaledstep * (double) i, sisym);\n                            } else {\n                                snprintf(graph_label, sizeof graph_label, \"%4.0f %c\",\n                                        scaledstep * (double) i, sisym);\n                            }\n                        }\n                    } else {\n                        sprintf(graph_label, im->primary_axis_format,\n                                scaledstep * (double) i, sisym);\n                    }\n                }\n                nlabels++;\n                if (im->second_axis_scale != 0){\n                        char graph_label_right[100];\n                        double sval = im->ygrid_scale.gridstep*(double)i*im->second_axis_scale+im->second_axis_shift;\n                        if (im->second_axis_format == NULL || im->second_axis_format[0] == '\\0') {\n                            if (!second_axis_magfact){\n                                double dummy = im->ygrid_scale.gridstep*(double)(sgrid+egrid)/2.0*im->second_axis_scale+im->second_axis_shift;\n                                auto_scale(im,&dummy,&second_axis_symb,&second_axis_magfact);\n                            }\n                            sval /= second_axis_magfact;\n\n                            if(MaxY < 10) {\n                                snprintf(graph_label_right, sizeof graph_label_right, \"%5.1f %s\",sval,second_axis_symb);\n                            } else {\n                                snprintf(graph_label_right, sizeof graph_label_right, \"%5.0f %s\",sval,second_axis_symb);\n                            }\n                        }\n                        else {\n                           snprintf(graph_label_right, sizeof graph_label_right, im->second_axis_format,sval,\"\");\n                        }\n                        gfx_text ( im,\n                               X1+7, Y0,\n                               im->graph_col[GRC_FONT],\n                               im->text_prop[TEXT_PROP_AXIS].font_desc,\n                               im->tabwidth,0.0, GFX_H_LEFT, GFX_V_CENTER,\n                               graph_label_right );\n                }\n\n                gfx_text(im,\n                         X0 -\n                         im->\n                         text_prop[TEXT_PROP_AXIS].\n                         size, Y0,\n                         im->graph_col[GRC_FONT],\n                         im->\n                         text_prop[TEXT_PROP_AXIS].\n                         font_desc,\n                         im->tabwidth, 0.0,\n                         GFX_H_RIGHT, GFX_V_CENTER, graph_label);\n                gfx_line(im, X0 - 2, Y0, X0, Y0,\n                         MGRIDWIDTH, im->graph_col[GRC_MGRID]);\n                gfx_line(im, X1, Y0, X1 + 2, Y0,\n                         MGRIDWIDTH, im->graph_col[GRC_MGRID]);\n                gfx_dashed_line(im, X0 - 2, Y0,\n                                X1 + 2, Y0,\n                                MGRIDWIDTH,\n                                im->\n                                graph_col\n                                [GRC_MGRID],\n                                im->grid_dash_on, im->grid_dash_off);\n            } else if (!(im->extra_flags & NOMINOR)) {\n                gfx_line(im,\n                         X0 - 2, Y0,\n                         X0, Y0, GRIDWIDTH, im->graph_col[GRC_GRID]);\n                gfx_line(im, X1, Y0, X1 + 2, Y0,\n                         GRIDWIDTH, im->graph_col[GRC_GRID]);\n                gfx_dashed_line(im, X0 - 1, Y0,\n                                X1 + 1, Y0,\n                                GRIDWIDTH,\n                                im->\n                                graph_col[GRC_GRID],\n                                im->grid_dash_on, im->grid_dash_off);\n            }\n        }\n    }\n    return 1;\n}\n\n/* this is frexp for base 10 */\ndouble    frexp10(\n    double,\n    double *);\ndouble frexp10(\n    double x,\n    double *e)\n{\n    double    mnt;\n    int       iexp;\n\n    iexp = floor(log((double)fabs(x)) / log((double)10));\n    mnt = x / pow(10.0, iexp);\n    if (mnt >= 10.0) {\n        iexp++;\n        mnt = x / pow(10.0, iexp);\n    }\n    *e = iexp;\n    return mnt;\n}\n\n\n/* logaritmic horizontal grid */\nint horizontal_log_grid(\n    image_desc_t\n    *im)\n{\n    double    yloglab[][10] = {\n        {\n         1.0, 10., 0.0, 0.0, 0.0, 0.0, 0.0,\n         0.0, 0.0, 0.0}, {\n                          1.0, 5.0, 10., 0.0, 0.0, 0.0, 0.0,\n                          0.0, 0.0, 0.0}, {\n                                           1.0, 2.0, 5.0, 7.0, 10., 0.0, 0.0,\n                                           0.0, 0.0, 0.0}, {\n                                                            1.0, 2.0, 4.0,\n                                                            6.0, 8.0, 10.,\n                                                            0.0,\n                                                            0.0, 0.0, 0.0}, {\n                                                                             1.0,\n                                                                             2.0,\n                                                                             3.0,\n                                                                             4.0,\n                                                                             5.0,\n                                                                             6.0,\n                                                                             7.0,\n                                                                             8.0,\n                                                                             9.0,\n                                                                             10.},\n        {\n         0, 0, 0, 0, 0, 0, 0, 0, 0, 0}  /* last line */\n    };\n    int       i, j, val_exp, min_exp;\n    double    nex;      /* number of decades in data */\n    double    logscale; /* scale in logarithmic space */\n    int       exfrac = 1;   /* decade spacing */\n    int       mid = -1; /* row in yloglab for major grid */\n    double    mspac;    /* smallest major grid spacing (pixels) */\n    int       flab;     /* first value in yloglab to use */\n    double    value, tmp, pre_value;\n    double    X0, X1, Y0;\n    char      graph_label[100];\n\n    nex = log10(im->maxval / im->minval);\n    logscale = im->ysize / nex;\n    /* major spacing for data with high dynamic range */\n    while (logscale * exfrac < 3 * im->text_prop[TEXT_PROP_LEGEND].size) {\n        if (exfrac == 1)\n            exfrac = 3;\n        else\n            exfrac += 3;\n    }\n\n    /* major spacing for less dynamic data */\n    do {\n        /* search best row in yloglab */\n        mid++;\n        for (i = 0; yloglab[mid][i + 1] < 10.0; i++);\n        mspac = logscale * log10(10.0 / yloglab[mid][i]);\n    }\n    while (mspac >\n           2 * im->text_prop[TEXT_PROP_LEGEND].size && yloglab[mid][0] > 0);\n    if (mid)\n        mid--;\n    /* find first value in yloglab */\n    for (flab = 0;\n         yloglab[mid][flab] < 10\n         && frexp10(im->minval, &tmp) > yloglab[mid][flab]; flab++);\n    if (yloglab[mid][flab] == 10.0) {\n        tmp += 1.0;\n        flab = 0;\n    }\n    val_exp = tmp;\n    if (val_exp % exfrac)\n        val_exp += abs(-val_exp % exfrac);\n    X0 = im->xorigin;\n    X1 = im->xorigin + im->xsize;\n    /* draw grid */\n    pre_value = DNAN;\n    while (1) {\n\n        value = yloglab[mid][flab] * pow(10.0, val_exp);\n        if (AlmostEqual2sComplement(value, pre_value, 4))\n            break;      /* it seems we are not converging */\n        pre_value = value;\n        Y0 = ytr(im, value);\n        if (floor(Y0 + 0.5) <= im->yorigin - im->ysize)\n            break;\n        /* major grid line */\n        gfx_line(im,\n                 X0 - 2, Y0, X0, Y0, MGRIDWIDTH, im->graph_col[GRC_MGRID]);\n        gfx_line(im, X1, Y0, X1 + 2, Y0,\n                 MGRIDWIDTH, im->graph_col[GRC_MGRID]);\n        gfx_dashed_line(im, X0 - 2, Y0,\n                        X1 + 2, Y0,\n                        MGRIDWIDTH,\n                        im->\n                        graph_col\n                        [GRC_MGRID], im->grid_dash_on, im->grid_dash_off);\n        /* label */\n        if (im->extra_flags & FORCE_UNITS_SI) {\n            int       scale;\n            double    pvalue;\n            char      symbol;\n\n            scale = floor(val_exp / 3.0);\n            if (value >= 1.0)\n                pvalue = pow(10.0, val_exp % 3);\n            else\n                pvalue = pow(10.0, ((val_exp + 1) % 3) + 2);\n            pvalue *= yloglab[mid][flab];\n            if (((scale + si_symbcenter) < (int) sizeof(si_symbol))\n                && ((scale + si_symbcenter) >= 0))\n                symbol = si_symbol[scale + si_symbcenter];\n            else\n                symbol = '?';\n            snprintf(graph_label, sizeof graph_label, \"%3.0f %c\", pvalue, symbol);\n        } else {\n            snprintf(graph_label, sizeof graph_label, \"%3.0e\", value);\n        }\n        if (im->second_axis_scale != 0){\n                char graph_label_right[100];\n                double sval = value*im->second_axis_scale+im->second_axis_shift;\n                if (im->second_axis_format == NULL || im->second_axis_format[0] == '\\0') {\n                        if (im->extra_flags & FORCE_UNITS_SI) {\n                                double mfac = 1;\n                                char   *symb = \"\";\n                                auto_scale(im,&sval,&symb,&mfac);\n                                snprintf(graph_label_right, sizeof graph_label_right, \"%4.0f %s\", sval,symb);\n                        }\n                        else {\n                                snprintf(graph_label_right, sizeof graph_label_right, \"%3.0e\", sval);\n                        }\n                }\n                else {\n                      snprintf(graph_label_right, sizeof graph_label_right, im->second_axis_format,sval,\"\");\n                }\n\n                gfx_text ( im,\n                               X1+7, Y0,\n                               im->graph_col[GRC_FONT],\n                               im->text_prop[TEXT_PROP_AXIS].font_desc,\n                               im->tabwidth,0.0, GFX_H_LEFT, GFX_V_CENTER,\n                               graph_label_right );\n        }\n\n        gfx_text(im,\n                 X0 -\n                 im->\n                 text_prop[TEXT_PROP_AXIS].\n                 size, Y0,\n                 im->graph_col[GRC_FONT],\n                 im->\n                 text_prop[TEXT_PROP_AXIS].\n                 font_desc,\n                 im->tabwidth, 0.0,\n                 GFX_H_RIGHT, GFX_V_CENTER, graph_label);\n        /* minor grid */\n        if (mid < 4 && exfrac == 1) {\n            /* find first and last minor line behind current major line\n             * i is the first line and j tha last */\n            if (flab == 0) {\n                min_exp = val_exp - 1;\n                for (i = 1; yloglab[mid][i] < 10.0; i++);\n                i = yloglab[mid][i - 1] + 1;\n                j = 10;\n            } else {\n                min_exp = val_exp;\n                i = yloglab[mid][flab - 1] + 1;\n                j = yloglab[mid][flab];\n            }\n\n            /* draw minor lines below current major line */\n            for (; i < j; i++) {\n\n                value = i * pow(10.0, min_exp);\n                if (value < im->minval)\n                    continue;\n                Y0 = ytr(im, value);\n                if (floor(Y0 + 0.5) <= im->yorigin - im->ysize)\n                    break;\n                /* draw lines */\n                gfx_line(im,\n                         X0 - 2, Y0,\n                         X0, Y0, GRIDWIDTH, im->graph_col[GRC_GRID]);\n                gfx_line(im, X1, Y0, X1 + 2, Y0,\n                         GRIDWIDTH, im->graph_col[GRC_GRID]);\n                gfx_dashed_line(im, X0 - 1, Y0,\n                                X1 + 1, Y0,\n                                GRIDWIDTH,\n                                im->\n                                graph_col[GRC_GRID],\n                                im->grid_dash_on, im->grid_dash_off);\n            }\n        } else if (exfrac > 1) {\n            for (i = val_exp - exfrac / 3 * 2; i < val_exp; i += exfrac / 3) {\n                value = pow(10.0, i);\n                if (value < im->minval)\n                    continue;\n                Y0 = ytr(im, value);\n                if (floor(Y0 + 0.5) <= im->yorigin - im->ysize)\n                    break;\n                /* draw lines */\n                gfx_line(im,\n                         X0 - 2, Y0,\n                         X0, Y0, GRIDWIDTH, im->graph_col[GRC_GRID]);\n                gfx_line(im, X1, Y0, X1 + 2, Y0,\n                         GRIDWIDTH, im->graph_col[GRC_GRID]);\n                gfx_dashed_line(im, X0 - 1, Y0,\n                                X1 + 1, Y0,\n                                GRIDWIDTH,\n                                im->\n                                graph_col[GRC_GRID],\n                                im->grid_dash_on, im->grid_dash_off);\n            }\n        }\n\n        /* next decade */\n        if (yloglab[mid][++flab] == 10.0) {\n            flab = 0;\n            val_exp += exfrac;\n        }\n    }\n\n    /* draw minor lines after highest major line */\n    if (mid < 4 && exfrac == 1) {\n        /* find first and last minor line below current major line\n         * i is the first line and j tha last */\n        if (flab == 0) {\n            min_exp = val_exp - 1;\n            for (i = 1; yloglab[mid][i] < 10.0; i++);\n            i = yloglab[mid][i - 1] + 1;\n            j = 10;\n        } else {\n            min_exp = val_exp;\n            i = yloglab[mid][flab - 1] + 1;\n            j = yloglab[mid][flab];\n        }\n\n        /* draw minor lines below current major line */\n        for (; i < j; i++) {\n\n            value = i * pow(10.0, min_exp);\n            if (value < im->minval)\n                continue;\n            Y0 = ytr(im, value);\n            if (floor(Y0 + 0.5) <= im->yorigin - im->ysize)\n                break;\n            /* draw lines */\n            gfx_line(im,\n                     X0 - 2, Y0, X0, Y0, GRIDWIDTH, im->graph_col[GRC_GRID]);\n            gfx_line(im, X1, Y0, X1 + 2, Y0,\n                     GRIDWIDTH, im->graph_col[GRC_GRID]);\n            gfx_dashed_line(im, X0 - 1, Y0,\n                            X1 + 1, Y0,\n                            GRIDWIDTH,\n                            im->\n                            graph_col[GRC_GRID],\n                            im->grid_dash_on, im->grid_dash_off);\n        }\n    }\n    /* fancy minor gridlines */\n    else if (exfrac > 1) {\n        for (i = val_exp - exfrac / 3 * 2; i < val_exp; i += exfrac / 3) {\n            value = pow(10.0, i);\n            if (value < im->minval)\n                continue;\n            Y0 = ytr(im, value);\n            if (floor(Y0 + 0.5) <= im->yorigin - im->ysize)\n                break;\n            /* draw lines */\n            gfx_line(im,\n                     X0 - 2, Y0, X0, Y0, GRIDWIDTH, im->graph_col[GRC_GRID]);\n            gfx_line(im, X1, Y0, X1 + 2, Y0,\n                     GRIDWIDTH, im->graph_col[GRC_GRID]);\n            gfx_dashed_line(im, X0 - 1, Y0,\n                            X1 + 1, Y0,\n                            GRIDWIDTH,\n                            im->\n                            graph_col[GRC_GRID],\n                            im->grid_dash_on, im->grid_dash_off);\n        }\n    }\n\n    return 1;\n}\n\n\nvoid vertical_grid(\n    image_desc_t *im)\n{\n    int       xlab_sel; /* which sort of label and grid ? */\n    time_t    ti, tilab, timajor;\n    long      factor;\n    char      graph_label[100];\n    double    X0, Y0, Y1;   /* points for filled graph and more */\n    struct tm tm;\n\n    /* the type of time grid is determined by finding\n       the number of seconds per pixel in the graph */\n    if (im->xlab_user.minsec == -1) {\n        factor = (im->end - im->start) / im->xsize;\n        xlab_sel = 0;\n        while (xlab[xlab_sel + 1].minsec !=\n               -1 && xlab[xlab_sel + 1].minsec <= factor) {\n            xlab_sel++;\n        }               /* pick the last one */\n        while (xlab[xlab_sel - 1].minsec ==\n               xlab[xlab_sel].minsec\n               && xlab[xlab_sel].length > (im->end - im->start)) {\n            xlab_sel--;\n        }               /* go back to the smallest size */\n        im->xlab_user.gridtm = xlab[xlab_sel].gridtm;\n        im->xlab_user.gridst = xlab[xlab_sel].gridst;\n        im->xlab_user.mgridtm = xlab[xlab_sel].mgridtm;\n        im->xlab_user.mgridst = xlab[xlab_sel].mgridst;\n        im->xlab_user.labtm = xlab[xlab_sel].labtm;\n        im->xlab_user.labst = xlab[xlab_sel].labst;\n        im->xlab_user.precis = xlab[xlab_sel].precis;\n        im->xlab_user.stst = xlab[xlab_sel].stst;\n    }\n\n    /* y coords are the same for every line ... */\n    Y0 = im->yorigin;\n    Y1 = im->yorigin - im->ysize;\n    /* paint the minor grid */\n    if (!(im->extra_flags & NOMINOR)) {\n        for (ti = find_first_time(im->start,\n                                  im->\n                                  xlab_user.\n                                  gridtm,\n                                  im->\n                                  xlab_user.\n                                  gridst),\n             timajor =\n             find_first_time(im->start,\n                             im->xlab_user.\n                             mgridtm,\n                             im->xlab_user.\n                             mgridst);\n             ti < im->end && ti != -1;\n             ti =\n             find_next_time(ti, im->xlab_user.gridtm, im->xlab_user.gridst)\n            ) {\n            /* are we inside the graph ? */\n            if (ti < im->start || ti > im->end)\n                continue;\n            while (timajor < ti && timajor != -1) {\n                timajor = find_next_time(timajor,\n                                         im->\n                                         xlab_user.\n                                         mgridtm, im->xlab_user.mgridst);\n            }\n            if (timajor == -1) break; /* fail in case of problems with time increments */\n            if (ti == timajor)\n                continue;   /* skip as falls on major grid line */\n            X0 = xtr(im, ti);\n            gfx_line(im, X0, Y1 - 2, X0, Y1,\n                     GRIDWIDTH, im->graph_col[GRC_GRID]);\n            gfx_line(im, X0, Y0, X0, Y0 + 2,\n                     GRIDWIDTH, im->graph_col[GRC_GRID]);\n            gfx_dashed_line(im, X0, Y0 + 1, X0,\n                            Y1 - 1, GRIDWIDTH,\n                            im->\n                            graph_col[GRC_GRID],\n                            im->grid_dash_on, im->grid_dash_off);\n        }\n    }\n\n    /* paint the major grid */\n    for (ti = find_first_time(im->start,\n                              im->\n                              xlab_user.\n                              mgridtm,\n                              im->\n                              xlab_user.\n                              mgridst);\n         ti < im->end && ti != -1;\n         ti = find_next_time(ti, im->xlab_user.mgridtm, im->xlab_user.mgridst)\n        ) {\n        /* are we inside the graph ? */\n        if (ti < im->start || ti > im->end)\n            continue;\n        X0 = xtr(im, ti);\n        gfx_line(im, X0, Y1 - 2, X0, Y1,\n                 MGRIDWIDTH, im->graph_col[GRC_MGRID]);\n        gfx_line(im, X0, Y0, X0, Y0 + 3,\n                 MGRIDWIDTH, im->graph_col[GRC_MGRID]);\n        gfx_dashed_line(im, X0, Y0 + 3, X0,\n                        Y1 - 2, MGRIDWIDTH,\n                        im->\n                        graph_col\n                        [GRC_MGRID], im->grid_dash_on, im->grid_dash_off);\n    }\n    /* paint the labels below the graph */\n    for (ti =\n         find_first_time(im->start -\n                         im->xlab_user.\n                         precis / 2,\n                         im->xlab_user.\n                         labtm,\n                         im->xlab_user.\n                         labst);\n         (ti <=\n         im->end -\n         im->xlab_user.precis / 2) && ti != -1;\n         ti = find_next_time(ti, im->xlab_user.labtm, im->xlab_user.labst)\n        ) {\n        tilab = ti + im->xlab_user.precis / 2;  /* correct time for the label */\n        /* are we inside the graph ? */\n        if (tilab < im->start || tilab > im->end)\n            continue;\n#if HAVE_STRFTIME\n        localtime_r(&tilab, &tm);\n        strftime(graph_label, 99, im->xlab_user.stst, &tm);\n#else\n# error \"your libc has no strftime I guess we'll abort the exercise here.\"\n#endif\n        gfx_text(im,\n                 xtr(im, tilab),\n                 Y0 + 3,\n                 im->graph_col[GRC_FONT],\n                 im->\n                 text_prop[TEXT_PROP_AXIS].\n                 font_desc,\n                 im->tabwidth, 0.0,\n                 GFX_H_CENTER, GFX_V_TOP, graph_label);\n    }\n\n}\n\n\nvoid axis_paint(\n    image_desc_t *im)\n{\n    /* draw x and y axis */\n    /* gfx_line ( im->canvas, im->xorigin+im->xsize,im->yorigin,\n       im->xorigin+im->xsize,im->yorigin-im->ysize,\n       GRIDWIDTH, im->graph_col[GRC_AXIS]);\n\n       gfx_line ( im->canvas, im->xorigin,im->yorigin-im->ysize,\n       im->xorigin+im->xsize,im->yorigin-im->ysize,\n       GRIDWIDTH, im->graph_col[GRC_AXIS]); */\n\n    gfx_line(im, im->xorigin - 4,\n             im->yorigin,\n             im->xorigin + im->xsize +\n             4, im->yorigin, MGRIDWIDTH, im->graph_col[GRC_AXIS]);\n    gfx_line(im, im->xorigin,\n             im->yorigin + 4,\n             im->xorigin,\n             im->yorigin - im->ysize -\n             4, MGRIDWIDTH, im->graph_col[GRC_AXIS]);\n    /* arrow for X and Y axis direction */\n    gfx_new_area(im, im->xorigin + im->xsize + 2, im->yorigin - 3, im->xorigin + im->xsize + 2, im->yorigin + 3, im->xorigin + im->xsize + 7, im->yorigin,  /* horyzontal */\n                 im->graph_col[GRC_ARROW]);\n    gfx_close_path(im);\n    gfx_new_area(im, im->xorigin - 3, im->yorigin - im->ysize - 2, im->xorigin + 3, im->yorigin - im->ysize - 2, im->xorigin, im->yorigin - im->ysize - 7,  /* vertical */\n                 im->graph_col[GRC_ARROW]);\n    gfx_close_path(im);\n    if (im->second_axis_scale != 0){\n       gfx_line ( im, im->xorigin+im->xsize,im->yorigin+4,\n                         im->xorigin+im->xsize,im->yorigin-im->ysize-4,\n                         MGRIDWIDTH, im->graph_col[GRC_AXIS]);\n       gfx_new_area ( im,\n                   im->xorigin+im->xsize-2,  im->yorigin-im->ysize-2,\n                   im->xorigin+im->xsize+3,  im->yorigin-im->ysize-2,\n                   im->xorigin+im->xsize,    im->yorigin-im->ysize-7, /* LINEOFFSET */\n                   im->graph_col[GRC_ARROW]);\n       gfx_close_path(im);\n    }\n\n}\n\nvoid grid_paint(\n    image_desc_t *im)\n{\n    long      i;\n    int       res = 0;\n    double    X0, Y0;   /* points for filled graph and more */\n    struct gfx_color_t water_color;\n\n    if (im->draw_3d_border > 0) {\n\t    /* draw 3d border */\n\t    i = im->draw_3d_border;\n\t    gfx_new_area(im, 0, im->yimg,\n\t\t\t i, im->yimg - i, i, i, im->graph_col[GRC_SHADEA]);\n\t    gfx_add_point(im, im->ximg - i, i);\n\t    gfx_add_point(im, im->ximg, 0);\n\t    gfx_add_point(im, 0, 0);\n\t    gfx_close_path(im);\n\t    gfx_new_area(im, i, im->yimg - i,\n\t\t\t im->ximg - i,\n\t\t\t im->yimg - i, im->ximg - i, i, im->graph_col[GRC_SHADEB]);\n\t    gfx_add_point(im, im->ximg, 0);\n\t    gfx_add_point(im, im->ximg, im->yimg);\n\t    gfx_add_point(im, 0, im->yimg);\n\t    gfx_close_path(im);\n    }\n    if (im->draw_x_grid == 1)\n        vertical_grid(im);\n    if (im->draw_y_grid == 1) {\n        if (im->logarithmic) {\n            res = horizontal_log_grid(im);\n        } else {\n            res = draw_horizontal_grid(im);\n        }\n\n        /* dont draw horizontal grid if there is no min and max val */\n        if (!res) {\n            char     *nodata = \"No Data found\";\n\n            gfx_text(im, im->ximg / 2,\n                     (2 * im->yorigin -\n                      im->ysize) / 2,\n                     im->graph_col[GRC_FONT],\n                     im->\n                     text_prop[TEXT_PROP_AXIS].\n                     font_desc,\n                     im->tabwidth, 0.0,\n                     GFX_H_CENTER, GFX_V_CENTER, nodata);\n        }\n    }\n\n    /* yaxis unit description */\n    if (im->ylegend && im->ylegend[0] != '\\0') {\n        gfx_text(im,\n                 im->xOriginLegendY+10,\n                 im->yOriginLegendY,\n                 im->graph_col[GRC_FONT],\n                 im->\n                 text_prop[TEXT_PROP_UNIT].\n                 font_desc,\n                 im->tabwidth,\n                 RRDGRAPH_YLEGEND_ANGLE, GFX_H_CENTER, GFX_V_CENTER, im->ylegend);\n\n    }\n    if (im->second_axis_legend && im->second_axis_legend[0] != '\\0') {\n            gfx_text( im,\n                  im->xOriginLegendY2+10,\n                  im->yOriginLegendY2,\n                  im->graph_col[GRC_FONT],\n                  im->text_prop[TEXT_PROP_UNIT].font_desc,\n                  im->tabwidth,\n                  RRDGRAPH_YLEGEND_ANGLE,\n                  GFX_H_CENTER, GFX_V_CENTER,\n                  im->second_axis_legend);\n    }\n\n    /* graph title */\n    gfx_text(im,\n             im->xOriginTitle, im->yOriginTitle+6,\n             im->graph_col[GRC_FONT],\n             im->\n             text_prop[TEXT_PROP_TITLE].\n             font_desc,\n             im->tabwidth, 0.0, GFX_H_CENTER, GFX_V_TOP, im->title?im->title:\"\");\n    /* rrdtool 'logo' */\n    if (!(im->extra_flags & NO_RRDTOOL_TAG)){\n        water_color = im->graph_col[GRC_FONT];\n        water_color.alpha = 0.3;\n        double xpos = im->legendposition == EAST ? im->xOriginLegendY : im->ximg - 4;\n        gfx_text(im, xpos, 5,\n                 water_color,\n                 im->\n                 text_prop[TEXT_PROP_WATERMARK].\n                 font_desc, im->tabwidth,\n                 -90, GFX_H_LEFT, GFX_V_TOP, \"RRDTOOL / TOBI OETIKER\");\n    }\n    /* graph watermark */\n    if (im->watermark && im->watermark[0] != '\\0') {\n        water_color = im->graph_col[GRC_FONT];\n        water_color.alpha = 0.3;\n        gfx_text(im,\n                 im->ximg / 2, im->yimg - 6,\n                 water_color,\n                 im->\n                 text_prop[TEXT_PROP_WATERMARK].\n                 font_desc, im->tabwidth, 0,\n                 GFX_H_CENTER, GFX_V_BOTTOM, im->watermark);\n    }\n\n    /* graph labels */\n    if (!(im->extra_flags & NOLEGEND) && !(im->extra_flags & ONLY_GRAPH)) {\n        long first_noncomment = im->gdes_c, last_noncomment = 0;\n        /* get smallest and biggest leg_y values. Assumes\n         * im->gdes[i].leg_y is in order. */\n        double min = 0, max = 0;\n        int gotcha = 0;\n        for (i = 0; i < im->gdes_c; i++) {\n            if (im->gdes[i].legend[0] == '\\0')\n                continue;\n            if (!gotcha) {\n                min = im->gdes[i].leg_y;\n                gotcha = 1;\n            }\n            if (im->gdes[i].gf != GF_COMMENT) {\n                if (im->legenddirection == BOTTOM_UP2)\n                    min = im->gdes[i].leg_y;\n                first_noncomment = i;\n                break;\n            }\n        }\n        gotcha = 0;\n        for (i = im->gdes_c - 1; i >= 0; i--) {\n            if (im->gdes[i].legend[0] == '\\0')\n                continue;\n            if (!gotcha) {\n                max = im->gdes[i].leg_y;\n                gotcha = 1;\n            }\n            if (im->gdes[i].gf != GF_COMMENT) {\n                if (im->legenddirection == BOTTOM_UP2)\n                    max = im->gdes[i].leg_y;\n                last_noncomment = i;\n                break;\n            }\n        }\n        for (i = 0; i < im->gdes_c; i++) {\n            if (im->gdes[i].legend[0] == '\\0')\n                continue;\n            /* im->gdes[i].leg_y is the bottom of the legend */\n            X0 = im->xOriginLegend + im->gdes[i].leg_x;\n            int reverse = 0;\n            switch (im->legenddirection) {\n                case TOP_DOWN:\n                    reverse = 0;\n                    break;\n                case BOTTOM_UP:\n                    reverse = 1;\n                    break;\n                case BOTTOM_UP2:\n                    reverse = i >= first_noncomment && i <= last_noncomment;\n                    break;\n            }\n            Y0 = reverse ?\n                im->yOriginLegend + max + min - im->gdes[i].leg_y :\n                im->yOriginLegend + im->gdes[i].leg_y;\n            gfx_text(im, X0, Y0,\n                     im->graph_col[GRC_FONT],\n                     im->\n                     text_prop\n                     [TEXT_PROP_LEGEND].font_desc,\n                     im->tabwidth, 0.0,\n                     GFX_H_LEFT, GFX_V_BOTTOM, im->gdes[i].legend);\n            /* The legend for GRAPH items starts with \"M \" to have\n               enough space for the box */\n            if (im->gdes[i].gf != GF_PRINT &&\n                im->gdes[i].gf != GF_GPRINT && im->gdes[i].gf != GF_COMMENT) {\n                double    boxH, boxV;\n                double    X1, Y1;\n\n                boxH = gfx_get_text_width(im, 0,\n                                          im->\n                                          text_prop\n                                          [TEXT_PROP_LEGEND].\n                                          font_desc,\n                                          im->tabwidth, \"o\") * 1.2;\n                boxV = boxH;\n                /* shift the box up a bit */\n                Y0 -= boxV * 0.4;\n\n        if (im->dynamic_labels && im->gdes[i].gf == GF_HRULE) { /* [-] */ \n\t\t\tcairo_save(im->cr);\n\t\t\tcairo_new_path(im->cr);\n\t\t\tcairo_set_line_width(im->cr, 1.0);\n\t\t\tgfx_line(im,\n\t\t\t\tX0, Y0 - boxV / 2,\n\t\t\t\tX0 + boxH, Y0 - boxV / 2,\n\t\t\t\t1.0, im->gdes[i].col);\n            \t\tgfx_close_path(im);\n\t\t} else if (im->dynamic_labels && im->gdes[i].gf == GF_VRULE) { /* [|] */\n\t\t\tcairo_save(im->cr);\n\t\t\tcairo_new_path(im->cr);\n\t\t\tcairo_set_line_width(im->cr, 1.0);\n\t\t\tgfx_line(im,\n\t\t\t\tX0 + boxH / 2, Y0,\n\t\t\t\tX0 + boxH / 2, Y0 - boxV,\n\t\t\t\t1.0, im->gdes[i].col);\n            \t\tgfx_close_path(im);\n\t\t} else if (im->dynamic_labels && im->gdes[i].gf == GF_LINE) { /* [/] */\n\t\t\tcairo_save(im->cr);\n\t\t\tcairo_new_path(im->cr);\n\t\t\tcairo_set_line_width(im->cr, im->gdes[i].linewidth);\n\t\t\tgfx_line(im,\n\t\t\t\tX0, Y0,\n\t\t\t\tX0 + boxH, Y0 - boxV,\n\t\t\t\tim->gdes[i].linewidth, im->gdes[i].col);\n            \t\tgfx_close_path(im);\n\t\t} else {\n\t\t/* make sure transparent colors show up the same way as in the graph */\n\t\t\tgfx_new_area(im,\n\t\t\t\t     X0, Y0 - boxV,\n\t\t\t\t     X0, Y0, X0 + boxH, Y0, im->graph_col[GRC_BACK]);\n\t\t\tgfx_add_point(im, X0 + boxH, Y0 - boxV);\n\t\t\tgfx_close_path(im);\n\t\t\tgfx_new_area(im, X0, Y0 - boxV, X0,\n\t\t\t\t     Y0, X0 + boxH, Y0, im->gdes[i].col);\n\t\t\tgfx_add_point(im, X0 + boxH, Y0 - boxV);\n\t\t\tgfx_close_path(im);\n\t\t\tcairo_save(im->cr);\n\t\t\tcairo_new_path(im->cr);\n\t\t\tcairo_set_line_width(im->cr, 1.0);\n\t\t\tX1 = X0 + boxH;\n\t\t\tY1 = Y0 - boxV;\n\t\t\tgfx_line_fit(im, &X0, &Y0);\n\t\t\tgfx_line_fit(im, &X1, &Y1);\n\t\t\tcairo_move_to(im->cr, X0, Y0);\n\t\t\tcairo_line_to(im->cr, X1, Y0);\n\t\t\tcairo_line_to(im->cr, X1, Y1);\n\t\t\tcairo_line_to(im->cr, X0, Y1);\n\t\t\tcairo_close_path(im->cr);\n\t\t\tcairo_set_source_rgba(im->cr,\n\t\t\t\t\t      im->graph_col[GRC_FRAME].red,\n\t\t\t\t\t      im->graph_col[GRC_FRAME].green,\n\t\t\t\t\t      im->graph_col[GRC_FRAME].blue,\n\t\t\t\t\t      im->graph_col[GRC_FRAME].alpha);\n\t\t}\n                if (im->gdes[i].dash) {\n                    /* make box borders in legend dashed if the graph is dashed */\n                    double    dashes[] = {\n                        3.0\n                    };\n                    cairo_set_dash(im->cr, dashes, 1, 0.0);\n                }\n                cairo_stroke(im->cr);\n                cairo_restore(im->cr);\n            }\n        }\n    }\n}\n\n\n/*****************************************************\n * lazy check make sure we rely need to create this graph\n *****************************************************/\n\nint lazy_check(\n    image_desc_t *im)\n{\n    FILE     *fd = NULL;\n    int       size = 1;\n    struct stat imgstat;\n\n    if (im->lazy == 0)\n        return 0;       /* no lazy option */\n    if (strlen(im->graphfile) == 0)\n        return 0;       /* inmemory option */\n    if (stat(im->graphfile, &imgstat) != 0)\n        return 0;       /* can't stat */\n    /* one pixel in the existing graph is more then what we would\n       change here ... */\n    if (time(NULL) - imgstat.st_mtime > (im->end - im->start) / im->xsize)\n        return 0;\n    if ((fd = fopen(im->graphfile, \"rb\")) == NULL)\n        return 0;       /* the file does not exist */\n    switch (im->imgformat) {\n    case IF_PNG:\n        size = PngSize(fd, &(im->ximg), &(im->yimg));\n        break;\n    default:\n        size = 1;\n    }\n    fclose(fd);\n    return size;\n}\n\n\nint graph_size_location(\n    image_desc_t\n    *im,\n    int elements)\n{\n    /* The actual size of the image to draw is determined from\n     ** several sources.  The size given on the command line is\n     ** the graph area but we need more as we have to draw labels\n     ** and other things outside the graph area. If the option\n     ** --full-size-mode is selected the size defines the total\n     ** image size and the size available for the graph is\n     ** calculated.\n     */\n\n    /** +---+-----------------------------------+\n     ** | y |...............graph title.........|\n     ** |   +---+-------------------------------+\n     ** | a | y |                               |\n     ** | x |   |                               |\n     ** | i | a |                               |\n     ** | s | x |       main graph area         |\n     ** |   | i |                               |\n     ** | t | s |                               |\n     ** | i |   |                               |\n     ** | t | l |                               |\n     ** | l | b +-------------------------------+\n     ** | e | l |       x axis labels           |\n     ** +---+---+-------------------------------+\n     ** |....................legends............|\n     ** +---------------------------------------+\n     ** |                   watermark           |\n     ** +---------------------------------------+\n     */\n\n    int       Xvertical = 0, Xvertical2 = 0, Ytitle =\n        0, Xylabel = 0, Xmain = 0, Ymain =\n        0, Yxlabel = 0, Xspacing = 15, Yspacing = 15, Ywatermark = 4;\n\n    // no legends and no the shall be plotted it's easy\n    if (im->extra_flags & ONLY_GRAPH) {\n        im->xorigin = 0;\n        im->ximg = im->xsize;\n        im->yimg = im->ysize;\n        im->yorigin = im->ysize;\n        xtr(im, 0);\n        ytr(im, DNAN);\n        return 0;\n    }\n\n    if (im->watermark && im->watermark[0] != '\\0') {\n        Ywatermark = im->text_prop[TEXT_PROP_WATERMARK].size * 2;\n    }\n\n    // calculate the width of the left vertical legend\n    if (im->ylegend && im->ylegend[0] != '\\0') {\n        Xvertical = im->text_prop[TEXT_PROP_UNIT].size * 2;\n    }\n\n    // calculate the width of the right vertical legend\n    if (im->second_axis_legend && im->second_axis_legend[0] != '\\0') {\n        Xvertical2 = im->text_prop[TEXT_PROP_UNIT].size * 2;\n    }\n    else{\n        Xvertical2 = Xspacing;\n    }\n\n    if (im->title && im->title[0] != '\\0') {\n        /* The title is placed \"inbetween\" two text lines so it\n         ** automatically has some vertical spacing.  The horizontal\n         ** spacing is added here, on each side.\n         */\n        /* if necessary, reduce the font size of the title until it fits the image width */\n        Ytitle = im->text_prop[TEXT_PROP_TITLE].size * 2.6 + 10;\n    }\n    else{\n        // we have no title; get a little clearing from the top\n        Ytitle = Yspacing;\n    }\n\n    if (elements) {\n        if (im->draw_x_grid) {\n            // calculate the height of the horizontal labelling\n            Yxlabel = im->text_prop[TEXT_PROP_AXIS].size * 2.5;\n        }\n        if (im->draw_y_grid || im->forceleftspace) {\n            // calculate the width of the vertical labelling\n            Xylabel =\n                gfx_get_text_width(im, 0,\n                                   im->text_prop[TEXT_PROP_AXIS].font_desc,\n                                   im->tabwidth, \"0\") * im->unitslength;\n        }\n    }\n\n    // add some space to the labelling\n    Xylabel += Xspacing;\n\n    /* If the legend is printed besides the graph the width has to be\n     ** calculated first. Placing the legend north or south of the\n     ** graph requires the width calculation first, so the legend is\n     ** skipped for the moment.\n     */\n    im->legendheight = 0;\n    im->legendwidth = 0;\n    if (!(im->extra_flags & NOLEGEND)) {\n        if(im->legendposition == WEST || im->legendposition == EAST){\n            if (leg_place(im, 1) == -1){\n                return -1;\n            }\n        }\n    }\n\n    if (im->extra_flags & FULL_SIZE_MODE) {\n\n        /* The actual size of the image to draw has been determined by the user.\n         ** The graph area is the space remaining after accounting for the legend,\n         ** the watermark, the axis labels, and the title.\n         */\n        im->ximg = im->xsize;\n        im->yimg = im->ysize;\n        Xmain = im->ximg;\n        Ymain = im->yimg;\n\n        /* Now calculate the total size.  Insert some spacing where\n           desired.  im->xorigin and im->yorigin need to correspond\n           with the lower left corner of the main graph area or, if\n           this one is not set, the imaginary box surrounding the\n           pie chart area. */\n        /* Initial size calculation for the main graph area */\n\n        Xmain -= Xylabel;// + Xspacing;\n        if((im->legendposition == WEST || im->legendposition == EAST) && !(im->extra_flags & NOLEGEND) ){\n            Xmain -= im->legendwidth;// + Xspacing;\n        }\n        if (im->second_axis_scale != 0){\n            Xmain -= Xylabel;\n        }\n        if (!(im->extra_flags & NO_RRDTOOL_TAG)){\n            Xmain -= Xspacing;\n        }\n\n        Xmain -= Xvertical + Xvertical2;\n\n        /* limit the remaining space to 0 */\n        if(Xmain < 1){\n            Xmain = 1;\n        }\n        im->xsize = Xmain;\n\n        /* Putting the legend north or south, the height can now be calculated */\n        if (!(im->extra_flags & NOLEGEND)) {\n            if(im->legendposition == NORTH || im->legendposition == SOUTH){\n                im->legendwidth = im->ximg;\n                if (leg_place(im, 0) == -1){\n                    return -1;\n                }\n            }\n        }\n\n        if( (im->legendposition == NORTH || im->legendposition == SOUTH)  && !(im->extra_flags & NOLEGEND) ){\n            Ymain -=  Yxlabel + im->legendheight;\n        }\n        else{\n            Ymain -= Yxlabel;\n        }\n\n        /* reserve space for the title *or* some padding above the graph */\n        Ymain -= Ytitle;\n\n            /* reserve space for padding below the graph */\n        if (im->extra_flags & NOLEGEND) {\n            Ymain -= 0.5*Yspacing;\n        }\n\n        if (im->watermark && im->watermark[0] != '\\0') {\n            Ymain -= Ywatermark;\n        }\n        /* limit the remaining height to 0 */\n        if(Ymain < 1){\n            Ymain = 1;\n        }\n        im->ysize = Ymain;\n    } else {            /* dimension options -width and -height refer to the dimensions of the main graph area */\n\n        /* The actual size of the image to draw is determined from\n         ** several sources.  The size given on the command line is\n         ** the graph area but we need more as we have to draw labels\n         ** and other things outside the graph area.\n         */\n\n        if (elements) {\n            Xmain = im->xsize; // + Xspacing;\n            Ymain = im->ysize;\n        }\n\n        im->ximg = Xmain + Xylabel;\n        if (!(im->extra_flags & NO_RRDTOOL_TAG)){\n            im->ximg += Xspacing;\n        }\n\n        if( (im->legendposition == WEST || im->legendposition == EAST) && !(im->extra_flags & NOLEGEND) ){\n            im->ximg += im->legendwidth;// + Xspacing;\n        }\n        if (im->second_axis_scale != 0){\n            im->ximg += Xylabel;\n        }\n\n        im->ximg += Xvertical + Xvertical2;\n\n        if (!(im->extra_flags & NOLEGEND)) {\n            if(im->legendposition == NORTH || im->legendposition == SOUTH){\n                im->legendwidth = im->ximg;\n                if (leg_place(im, 0) == -1){\n                    return -1;\n                }\n            }\n        }\n\n        im->yimg = Ymain + Yxlabel;\n        if( (im->legendposition == NORTH || im->legendposition == SOUTH)  && !(im->extra_flags & NOLEGEND) ){\n             im->yimg += im->legendheight;\n        }\n\n        /* reserve space for the title *or* some padding above the graph */\n        if (Ytitle) {\n            im->yimg += Ytitle;\n        } else {\n            im->yimg += 1.5 * Yspacing;\n        }\n        /* reserve space for padding below the graph */\n        if (im->extra_flags & NOLEGEND) {\n            im->yimg += 0.5*Yspacing;\n        }\n\n        if (im->watermark && im->watermark[0] != '\\0') {\n            im->yimg += Ywatermark;\n        }\n    }\n\n\n    /* In case of putting the legend in west or east position the first\n     ** legend calculation might lead to wrong positions if some items\n     ** are not aligned on the left hand side (e.g. centered) as the\n     ** legendwidth wight have been increased after the item was placed.\n     ** In this case the positions have to be recalculated.\n     */\n    if (!(im->extra_flags & NOLEGEND)) {\n        if(im->legendposition == WEST || im->legendposition == EAST){\n            if (leg_place(im, 0) == -1){\n                return -1;\n            }\n        }\n    }\n\n    /* After calculating all dimensions\n     ** it is now possible to calculate\n     ** all offsets.\n     */\n    switch(im->legendposition){\n        case NORTH:\n            im->xOriginTitle   = (im->ximg / 2);\n            im->yOriginTitle   = 0;\n\n            im->xOriginLegend  = 0;\n            im->yOriginLegend  = Ytitle;\n\n            im->xOriginLegendY = 0;\n            im->yOriginLegendY = Ytitle + im->legendheight + (Ymain / 2) + Yxlabel;\n\n            im->xorigin        = Xvertical + Xylabel;\n            im->yorigin        = Ytitle + im->legendheight + Ymain;\n\n            im->xOriginLegendY2 = Xvertical + Xylabel + Xmain;\n            if (im->second_axis_scale != 0){\n                im->xOriginLegendY2 += Xylabel;\n            }\n            im->yOriginLegendY2 = Ytitle + im->legendheight + (Ymain / 2) + Yxlabel;\n\n            break;\n\n        case WEST:\n            im->xOriginTitle   = im->legendwidth + im->xsize / 2;\n            im->yOriginTitle   = 0;\n\n            im->xOriginLegend  = 0;\n            im->yOriginLegend  = Ytitle;\n\n            im->xOriginLegendY = im->legendwidth;\n            im->yOriginLegendY = Ytitle + (Ymain / 2);\n\n            im->xorigin        = im->legendwidth + Xvertical + Xylabel;\n            im->yorigin        = Ytitle + Ymain;\n\n            im->xOriginLegendY2 = im->legendwidth + Xvertical + Xylabel + Xmain;\n            if (im->second_axis_scale != 0){\n                im->xOriginLegendY2 += Xylabel;\n            }\n            im->yOriginLegendY2 = Ytitle + (Ymain / 2);\n\n            break;\n\n        case SOUTH:\n            im->xOriginTitle   = im->ximg / 2;\n            im->yOriginTitle   = 0;\n\n            im->xOriginLegend  = 0;\n            im->yOriginLegend  = Ytitle + Ymain + Yxlabel;\n\n            im->xOriginLegendY = 0;\n            im->yOriginLegendY = Ytitle + (Ymain / 2);\n\n            im->xorigin        = Xvertical + Xylabel;\n            im->yorigin        = Ytitle + Ymain;\n\n            im->xOriginLegendY2 = Xvertical + Xylabel + Xmain;\n            if (im->second_axis_scale != 0){\n                im->xOriginLegendY2 += Xylabel;\n            }\n            im->yOriginLegendY2 = Ytitle + (Ymain / 2);\n\n            break;\n\n        case EAST:\n            im->xOriginTitle   = im->xsize / 2;\n            im->yOriginTitle   = 0;\n\n            im->xOriginLegend  = Xvertical + Xylabel + Xmain + Xvertical2;\n            if (im->second_axis_scale != 0){\n                im->xOriginLegend += Xylabel;\n            }\n            im->yOriginLegend  = Ytitle;\n\n            im->xOriginLegendY = 0;\n            im->yOriginLegendY = Ytitle + (Ymain / 2);\n\n            im->xorigin        = Xvertical + Xylabel;\n            im->yorigin        = Ytitle + Ymain;\n\n            im->xOriginLegendY2 = Xvertical + Xylabel + Xmain;\n            if (im->second_axis_scale != 0){\n                im->xOriginLegendY2 += Xylabel;\n            }\n            im->yOriginLegendY2 = Ytitle + (Ymain / 2);\n\n            if (!(im->extra_flags & NO_RRDTOOL_TAG)){\n                im->xOriginTitle    += Xspacing;\n                im->xOriginLegend   += Xspacing;\n                im->xOriginLegendY  += Xspacing;\n                im->xorigin         += Xspacing;\n                im->xOriginLegendY2 += Xspacing;\n            }\n            break;\n    }\n\n    xtr(im, 0);\n    ytr(im, DNAN);\n    return 0;\n}\n\nstatic cairo_status_t cairo_output(\n    void *closure,\n    const unsigned char\n    *data,\n    unsigned int length)\n{\n    image_desc_t *im = (image_desc_t*)closure;\n\n    im->rendered_image =\n        (unsigned char*)realloc(im->rendered_image, im->rendered_image_size + length);\n    if (im->rendered_image == NULL)\n        return CAIRO_STATUS_WRITE_ERROR;\n    memcpy(im->rendered_image + im->rendered_image_size, data, length);\n    im->rendered_image_size += length;\n    return CAIRO_STATUS_SUCCESS;\n}\n\n/* draw that picture thing ... */\nint graph_paint(\n    image_desc_t *im)\n{\n    int       lazy = lazy_check(im);\n    int       cnt;      \n\n    /* imgformat XML or higher dispatch to xport \n     * output format there is selected via graph_type \n     */\n    if (im->imgformat >= IF_XML) {\n      return rrd_graph_xport(im);\n    }\n\n    /* pull the data from the rrd files ... */\n    if (data_fetch(im) == -1)\n        return -1;\n    /* evaluate VDEF and CDEF operations ... */\n    if (data_calc(im) == -1)\n        return -1;\n    /* calculate and PRINT and GPRINT definitions. We have to do it at\n     * this point because it will affect the length of the legends\n     * if there are no graph elements (i==0) we stop here ...\n     * if we are lazy, try to quit ...\n     */\n    cnt = print_calc(im);\n    if (cnt < 0)\n        return -1;\n\n    /* if we want and can be lazy ... quit now */\n    if (cnt == 0)\n        return 0;\n\n    /* otherwise call graph_paint_timestring */\n    switch (im->graph_type) {\n    case GTYPE_TIME:\n      return graph_paint_timestring(im,lazy,cnt);\n      break;\n    case GTYPE_XY:\n      return graph_paint_xy(im,lazy,cnt);\n      break;      \n    }\n    /* final return with error*/\n    rrd_set_error(\"Graph type %i is not implemented\",im->graph_type);\n    return -1;\n}\n\nint graph_paint_timestring(\n                          image_desc_t *im, int lazy, int cnt)\n{\n    int       i,ii;\n    double    areazero = 0.0;\n    graph_desc_t *lastgdes = NULL;\n    rrd_infoval_t info;\n\n/**************************************************************\n *** Calculating sizes and locations became a bit confusing ***\n *** so I moved this into a separate function.              ***\n **************************************************************/\n    if (graph_size_location(im, cnt) == -1)\n        return -1;\n\n    info.u_cnt = im->xorigin;\n    grinfo_push(im, sprintf_alloc(\"graph_left\"), RD_I_CNT, info);\n    info.u_cnt = im->yorigin - im->ysize;\n    grinfo_push(im, sprintf_alloc(\"graph_top\"), RD_I_CNT, info);\n    info.u_cnt = im->xsize;\n    grinfo_push(im, sprintf_alloc(\"graph_width\"), RD_I_CNT, info);\n    info.u_cnt = im->ysize;\n    grinfo_push(im, sprintf_alloc(\"graph_height\"), RD_I_CNT, info);\n    info.u_cnt = im->ximg;\n    grinfo_push(im, sprintf_alloc(\"image_width\"), RD_I_CNT, info);\n    info.u_cnt = im->yimg;\n    grinfo_push(im, sprintf_alloc(\"image_height\"), RD_I_CNT, info);\n    info.u_cnt = im->start;\n    grinfo_push(im, sprintf_alloc(\"graph_start\"), RD_I_CNT, info);\n    info.u_cnt = im->end;\n    grinfo_push(im, sprintf_alloc(\"graph_end\"), RD_I_CNT, info);\n\n    /* if we want and can be lazy ... quit now */\n    if (lazy)\n        return 0;\n\n    /* get actual drawing data and find min and max values */\n    if (data_proc(im) == -1)\n        return -1;\n    if (!im->logarithmic) {\n        si_unit(im);\n    }\n\n    /* identify si magnitude Kilo, Mega Giga ? */\n    if (!im->rigid && !im->logarithmic)\n        expand_range(im);   /* make sure the upper and lower limit are\n                               sensible values */\n\n    info.u_val = im->minval;\n    grinfo_push(im, sprintf_alloc(\"value_min\"), RD_I_VAL, info);\n    info.u_val = im->maxval;\n    grinfo_push(im, sprintf_alloc(\"value_max\"), RD_I_VAL, info);\n\n\n    if (!calc_horizontal_grid(im))\n        return -1;\n    /* reset precalc */\n    ytr(im, DNAN);\n/*   if (im->gridfit)\n     apply_gridfit(im); */\n\n    /* set up cairo */\n    if (graph_cairo_setup(im)) { return -1; }\n\n    /* other stuff */\n    if (im->minval > 0.0)\n        areazero = im->minval;\n    if (im->maxval < 0.0)\n        areazero = im->maxval;\n    for (i = 0; i < im->gdes_c; i++) {\n        switch (im->gdes[i].gf) {\n        case GF_CDEF:\n        case GF_VDEF:\n        case GF_DEF:\n        case GF_PRINT:\n        case GF_GPRINT:\n        case GF_COMMENT:\n        case GF_TEXTALIGN:\n        case GF_HRULE:\n        case GF_VRULE:\n        case GF_XPORT:\n        case GF_SHIFT:\n        case GF_XAXIS:\n        case GF_YAXIS:\n            break;\n        case GF_TICK:\n            for (ii = 0; ii < im->xsize; ii++) {\n                if (!isnan(im->gdes[i].p_data[ii])\n                    && im->gdes[i].p_data[ii] != 0.0) {\n                    if (im->gdes[i].yrule > 0) {\n                        gfx_line(im,\n                                 im->xorigin + ii,\n                                 im->yorigin + 1.0,\n                                 im->xorigin + ii,\n                                 im->yorigin -\n                                 im->gdes[i].yrule *\n                                 im->ysize, 1.0, im->gdes[i].col);\n                    } else if (im->gdes[i].yrule < 0) {\n                        gfx_line(im,\n                                 im->xorigin + ii,\n                                 im->yorigin - im->ysize - 1.0,\n                                 im->xorigin + ii,\n                                 im->yorigin - im->ysize -\n                                                im->gdes[i].\n                                                yrule *\n                                 im->ysize, 1.0, im->gdes[i].col);\n                    }\n                }\n            }\n            break;\n        case GF_LINE:\n        case GF_AREA:\n        case GF_GRAD: {\n            rrd_value_t diffval = im->maxval - im->minval;\n            rrd_value_t maxlimit = im->maxval + 9 * diffval;\n            rrd_value_t minlimit = im->minval - 9 * diffval;        \n            for (ii = 0; ii < im->xsize; ii++) {\n                /* fix data points at oo and -oo */\n                if (isinf(im->gdes[i].p_data[ii])) {\n                    if (im->gdes[i].p_data[ii] > 0) {\n                        im->gdes[i].p_data[ii] = im->maxval;\n                    } else {\n                        im->gdes[i].p_data[ii] = im->minval;\n                    }\n                }\n                /* some versions of cairo go unstable when trying\n                   to draw way out of the canvas ... lets not even try */\n               if (im->gdes[i].p_data[ii] > maxlimit) {\n                   im->gdes[i].p_data[ii] = maxlimit;\n               }\n               if (im->gdes[i].p_data[ii] < minlimit) {\n                   im->gdes[i].p_data[ii] = minlimit;\n               }\n            }           /* for */\n\n            /* *******************************************************\n               a           ___. (a,t)\n               |   |    ___\n               ____|   |   |   |\n               |       |___|\n               -------|--t-1--t--------------------------------\n\n               if we know the value at time t was a then\n               we draw a square from t-1 to t with the value a.\n\n               ********************************************************* */\n            if (im->gdes[i].col.alpha != 0.0) {\n                /* GF_LINE and friend */\n                if (im->gdes[i].gf == GF_LINE) {\n                    double    last_y = 0.0;\n                    int       draw_on = 0;\n\n                    cairo_save(im->cr);\n                    cairo_new_path(im->cr);\n                    cairo_set_line_width(im->cr, im->gdes[i].linewidth);\n                    if (im->gdes[i].dash) {\n                        cairo_set_dash(im->cr,\n                                       im->gdes[i].p_dashes,\n                                       im->gdes[i].ndash, im->gdes[i].offset);\n                    }\n\n                    for (ii = 1; ii < im->xsize; ii++) {\n                        if (isnan(im->gdes[i].p_data[ii])\n                            || (im->slopemode == 1\n                                && isnan(im->gdes[i].p_data[ii - 1]))) {\n                            draw_on = 0;\n                            continue;\n                        }\n                        if (draw_on == 0) {\n                            last_y = ytr(im, im->gdes[i].p_data[ii]);\n                            if (im->slopemode == 0) {\n                                double    x = ii - 1 + im->xorigin;\n                                double    y = last_y;\n\n                                gfx_line_fit(im, &x, &y);\n                                cairo_move_to(im->cr, x, y);\n                                x = ii + im->xorigin;\n                                y = last_y;\n                                gfx_line_fit(im, &x, &y);\n                                cairo_line_to(im->cr, x, y);\n                            } else {\n                                double    x = ii - 1 + im->xorigin;\n                                double    y =\n                                    ytr(im, im->gdes[i].p_data[ii - 1]);\n                                gfx_line_fit(im, &x, &y);\n                                cairo_move_to(im->cr, x, y);\n                                x = ii + im->xorigin;\n                                y = last_y;\n                                gfx_line_fit(im, &x, &y);\n                                cairo_line_to(im->cr, x, y);\n                            }\n                            draw_on = 1;\n                        } else {\n                            double    x1 = ii + im->xorigin;\n                            double    y1 = ytr(im, im->gdes[i].p_data[ii]);\n\n                            if (im->slopemode == 0\n                                && !AlmostEqual2sComplement(y1, last_y, 4)) {\n                                double    x = ii - 1 + im->xorigin;\n                                double    y = y1;\n\n                                gfx_line_fit(im, &x, &y);\n                                cairo_line_to(im->cr, x, y);\n                            };\n                            last_y = y1;\n                            gfx_line_fit(im, &x1, &y1);\n                            cairo_line_to(im->cr, x1, y1);\n                        };\n                    }\n                    cairo_set_source_rgba(im->cr,\n                                          im->gdes[i].\n                                          col.red,\n                                          im->gdes[i].\n                                          col.green,\n                                          im->gdes[i].\n                                          col.blue, im->gdes[i].col.alpha);\n                    cairo_set_line_cap(im->cr, CAIRO_LINE_CAP_ROUND);\n                    cairo_set_line_join(im->cr, CAIRO_LINE_JOIN_ROUND);\n                    cairo_stroke(im->cr);\n                    cairo_restore(im->cr);\n                } else {\n\t\t\t\t\tdouble lastx=0;\n\t\t\t\t\tdouble lasty=0;\n                    int       idxI = -1;\n                    double   *foreY =\n                        (double *) malloc(sizeof(double) * im->xsize * 2);\n                    double   *foreX =\n                        (double *) malloc(sizeof(double) * im->xsize * 2);\n                    double   *backY =\n                        (double *) malloc(sizeof(double) * im->xsize * 2);\n                    double   *backX =\n                        (double *) malloc(sizeof(double) * im->xsize * 2);\n                    int       drawem = 0;\n\n                    for (ii = 0; ii <= im->xsize; ii++) {\n                        double    ybase, ytop;\n\n                        if (idxI > 0 && (drawem != 0 || ii == im->xsize)) {\n                            int       cntI = 1;\n                            int       lastI = 0;\n\n                            while (cntI < idxI\n                                   &&\n                                   AlmostEqual2sComplement(foreY\n                                                           [lastI],\n                                                           foreY[cntI], 4)\n                                   &&\n                                   AlmostEqual2sComplement(foreY\n                                                           [lastI],\n                                                           foreY\n                                                           [cntI + 1], 4)) {\n                                cntI++;\n                            }\n\t\t\t\t\t\t\tif (im->gdes[i].gf != GF_GRAD) {\n                            \tgfx_new_area(im,\n                            \t             backX[0], backY[0],\n                            \t             foreX[0], foreY[0],\n                            \t             foreX[cntI],\n                            \t             foreY[cntI], im->gdes[i].col);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlastx = foreX[cntI];\n\t\t\t\t\t\t\t\tlasty = foreY[cntI];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\twhile (cntI < idxI) {\n                                lastI = cntI;\n                                cntI++;\n                                while (cntI < idxI\n                                       &&\n                                       AlmostEqual2sComplement(foreY\n                                                               [lastI],\n                                                               foreY[cntI], 4)\n                                       &&\n                                       AlmostEqual2sComplement(foreY\n                                                               [lastI],\n                                                               foreY\n                                                               [cntI\n                                                                + 1], 4)) {\n                                    cntI++;\n                                }\n\t\t\t\t\t\t\t\tif (im->gdes[i].gf != GF_GRAD) {\n\t                                gfx_add_point(im, foreX[cntI], foreY[cntI]);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tgfx_add_rect_fadey(im, \n\t\t\t\t\t\t\t\t\t\tlastx, foreY[0],\n\t\t\t\t\t\t\t\t\t\tforeX[cntI], foreY[cntI], lasty, \n\t\t\t\t\t\t\t\t\t\tim->gdes[i].col,\n\t\t\t\t\t\t\t\t\t\tim->gdes[i].col2,\n\t\t\t\t\t\t\t\t\t\tim->gdes[i].gradheight\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tlastx = foreX[cntI];\n\t\t\t\t\t\t\t\t\tlasty = foreY[cntI];\n\t\t\t\t\t\t\t\t}\n                            }\n\t\t\t\t\t\t\tif (im->gdes[i].gf != GF_GRAD) {\n                            \tgfx_add_point(im, backX[idxI], backY[idxI]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tgfx_add_rect_fadey(im,\n\t\t\t\t\t\t\t\t\tlastx, foreY[0],\n\t\t\t\t\t\t\t\t\tbackX[idxI], backY[idxI], lasty,\n\t\t\t\t\t\t\t\t\tim->gdes[i].col,\n\t\t\t\t\t\t\t\t\tim->gdes[i].col2,\n\t\t\t\t\t\t\t\t\tim->gdes[i].gradheight);\n\t\t\t\t\t\t\t\tlastx = backX[idxI];\n\t\t\t\t\t\t\t\tlasty = backY[idxI];\n\t\t\t\t\t\t\t}\n                            while (idxI > 1) {\n                                lastI = idxI;\n                                idxI--;\n                                while (idxI > 1\n                                       &&\n                                       AlmostEqual2sComplement(backY\n                                                               [lastI],\n                                                               backY[idxI], 4)\n                                       &&\n                                       AlmostEqual2sComplement(backY\n                                                               [lastI],\n                                                               backY\n                                                               [idxI\n                                                                - 1], 4)) {\n                                    idxI--;\n                                }\n\t\t\t\t\t\t\t\tif (im->gdes[i].gf != GF_GRAD) {\n\t                                gfx_add_point(im, backX[idxI], backY[idxI]);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tgfx_add_rect_fadey(im,\n\t\t\t\t\t\t\t\t\t\tlastx, foreY[0],\n\t\t\t\t\t\t\t\t\t\tbackX[idxI], backY[idxI], lasty,\n\t\t\t\t\t\t\t\t\t\tim->gdes[i].col,\n\t\t\t\t\t\t\t\t\t\tim->gdes[i].col2,\n\t\t\t\t\t\t\t\t\t\tim->gdes[i].gradheight);\n\t\t\t\t\t\t\t\t\tlastx = backX[idxI];\n\t\t\t\t\t\t\t\t\tlasty = backY[idxI];\n\t\t\t\t\t\t\t\t}\n                            }\n                            idxI = -1;\n                            drawem = 0;\n\t\t\t\t\t\t\tif (im->gdes[i].gf != GF_GRAD) \n\t                            gfx_close_path(im);\n                        }\n                        if (drawem != 0) {\n                            drawem = 0;\n                            idxI = -1;\n                        }\n                        if (ii == im->xsize)\n                            break;\n                        if (im->slopemode == 0 && ii == 0) {\n                            continue;\n                        }\n                        if (isnan(im->gdes[i].p_data[ii])) {\n                            drawem = 1;\n                            continue;\n                        }\n                        ytop = ytr(im, im->gdes[i].p_data[ii]);\n                        if (lastgdes && im->gdes[i].stack) {\n                            ybase = ytr(im, lastgdes->p_data[ii]);\n                        } else {\n                            ybase = ytr(im, areazero);\n                        }\n                        if (ybase == ytop) {\n                            drawem = 1;\n                            continue;\n                        }\n\n                        if (ybase > ytop) {\n                            double    extra = ytop;\n\n                            ytop = ybase;\n                            ybase = extra;\n                        }\n                        if (im->slopemode == 0) {\n                            backY[++idxI] = ybase - 0.2;\n                            backX[idxI] = ii + im->xorigin - 1;\n                            foreY[idxI] = ytop + 0.2;\n                            foreX[idxI] = ii + im->xorigin - 1;\n                        }\n                        backY[++idxI] = ybase - 0.2;\n                        backX[idxI] = ii + im->xorigin;\n                        foreY[idxI] = ytop + 0.2;\n                        foreX[idxI] = ii + im->xorigin;\n                    }\n                    /* close up any remaining area */\n                    free(foreY);\n                    free(foreX);\n                    free(backY);\n                    free(backX);\n                }       /* else GF_LINE */\n            }\n            /* if color != 0x0 */\n            /* make sure we do not run into trouble when stacking on NaN */\n            for (ii = 0; ii < im->xsize; ii++) {\n                if (isnan(im->gdes[i].p_data[ii])) {\n                    if (lastgdes && (im->gdes[i].stack)) {\n                        im->gdes[i].p_data[ii] = lastgdes->p_data[ii];\n                    } else {\n                        im->gdes[i].p_data[ii] = areazero;\n                    }\n                }\n            }\n            lastgdes = &(im->gdes[i]);\n            break;\n        } /* GF_AREA, GF_LINE, GF_GRAD */\n        case GF_STACK:\n            rrd_set_error\n                (\"STACK should already be turned into LINE or AREA here\");\n            return -1;\n            break;\n        }               /* switch */\n    }\n    cairo_reset_clip(im->cr);\n\n    /* grid_paint also does the text */\n    if (!(im->extra_flags & ONLY_GRAPH))\n        grid_paint(im);\n    if (!(im->extra_flags & ONLY_GRAPH))\n        axis_paint(im);\n    /* the RULES are the last thing to paint ... */\n    for (i = 0; i < im->gdes_c; i++) {\n\n        switch (im->gdes[i].gf) {\n        case GF_HRULE:\n            if (im->gdes[i].yrule >= im->minval\n                && im->gdes[i].yrule <= im->maxval) {\n                cairo_save(im->cr);\n                if (im->gdes[i].dash) {\n                    cairo_set_dash(im->cr,\n                                   im->gdes[i].p_dashes,\n                                   im->gdes[i].ndash, im->gdes[i].offset);\n                }\n                gfx_line(im, im->xorigin,\n                         ytr(im, im->gdes[i].yrule),\n                         im->xorigin + im->xsize,\n                         ytr(im, im->gdes[i].yrule), 1.0, im->gdes[i].col);\n                cairo_stroke(im->cr);\n                cairo_restore(im->cr);\n            }\n            break;\n        case GF_VRULE:\n            if (im->gdes[i].xrule >= im->start\n                && im->gdes[i].xrule <= im->end) {\n                cairo_save(im->cr);\n                if (im->gdes[i].dash) {\n                    cairo_set_dash(im->cr,\n                                   im->gdes[i].p_dashes,\n                                   im->gdes[i].ndash, im->gdes[i].offset);\n                }\n                gfx_line(im,\n                         xtr(im, im->gdes[i].xrule),\n                         im->yorigin, xtr(im,\n                                          im->\n                                          gdes[i].\n                                          xrule),\n                         im->yorigin - im->ysize, 1.0, im->gdes[i].col);\n                cairo_stroke(im->cr);\n                cairo_restore(im->cr);\n            }\n            break;\n        default:\n            break;\n        }\n    }\n    /* close the graph via cairo*/\n    return graph_cairo_finish(im);\n}\n\nint graph_cairo_setup (image_desc_t *im)\n{\n    /* the actual graph is created by going through the individual\n       graph elements and then drawing them */\n    cairo_surface_destroy(im->surface);\n    switch (im->imgformat) {\n    case IF_PNG:\n        im->surface =\n            cairo_image_surface_create(CAIRO_FORMAT_ARGB32,\n                                       im->ximg * im->zoom,\n                                       im->yimg * im->zoom);\n        break;\n    case IF_PDF:\n        im->gridfit = 0;\n        im->surface = strlen(im->graphfile)\n            ? cairo_pdf_surface_create(im->graphfile, im->ximg * im->zoom,\n                                       im->yimg * im->zoom)\n            : cairo_pdf_surface_create_for_stream\n            (&cairo_output, im, im->ximg * im->zoom, im->yimg * im->zoom);\n        break;\n    case IF_EPS:\n        im->gridfit = 0;\n        im->surface = strlen(im->graphfile)\n            ?\n            cairo_ps_surface_create(im->graphfile, im->ximg * im->zoom,\n                                    im->yimg * im->zoom)\n            : cairo_ps_surface_create_for_stream\n            (&cairo_output, im, im->ximg * im->zoom, im->yimg * im->zoom);\n        break;\n    case IF_SVG:\n        im->gridfit = 0;\n        im->surface = strlen(im->graphfile)\n            ?\n            cairo_svg_surface_create(im->\n                                     graphfile,\n                                     im->ximg * im->zoom, im->yimg * im->zoom)\n            : cairo_svg_surface_create_for_stream\n            (&cairo_output, im, im->ximg * im->zoom, im->yimg * im->zoom);\n        cairo_svg_surface_restrict_to_version\n            (im->surface, CAIRO_SVG_VERSION_1_1);\n        break;\n    case IF_XML:\n    case IF_XMLENUM:\n    case IF_CSV:\n    case IF_TSV:\n    case IF_SSV:\n    case IF_JSON:\n    case IF_JSONTIME:\n        break;\n    };\n    cairo_destroy(im->cr);\n    im->cr = cairo_create(im->surface);\n    cairo_set_antialias(im->cr, im->graph_antialias);\n    cairo_scale(im->cr, im->zoom, im->zoom);\n//    pango_cairo_font_map_set_resolution(PANGO_CAIRO_FONT_MAP(font_map), 100);\n    gfx_new_area(im, 0, 0, 0, im->yimg,\n                 im->ximg, im->yimg, im->graph_col[GRC_BACK]);\n    gfx_add_point(im, im->ximg, 0);\n    gfx_close_path(im);\n    gfx_new_area(im, im->xorigin,\n                 im->yorigin,\n                 im->xorigin +\n                 im->xsize, im->yorigin,\n                 im->xorigin +\n                 im->xsize,\n                 im->yorigin - im->ysize, im->graph_col[GRC_CANVAS]);\n    gfx_add_point(im, im->xorigin, im->yorigin - im->ysize);\n    gfx_close_path(im);\n    cairo_rectangle(im->cr, im->xorigin, im->yorigin - im->ysize - 1.0,\n                    im->xsize, im->ysize + 2.0);\n    cairo_clip(im->cr);\n    return 0;\n}\n\nint graph_cairo_finish (image_desc_t *im)\n{\n\n    switch (im->imgformat) {\n    case IF_PNG:\n    {\n        cairo_status_t status;\n\n        status = strlen(im->graphfile) ?\n            cairo_surface_write_to_png(im->surface, im->graphfile)\n            : cairo_surface_write_to_png_stream(im->surface, &cairo_output,\n                                                im);\n\n        if (status != CAIRO_STATUS_SUCCESS) {\n            rrd_set_error(\"Could not save png to '%s'\", im->graphfile);\n            return 1;\n        }\n        break;\n    }\n    case IF_XML:\n    case IF_XMLENUM:\n    case IF_CSV:\n    case IF_TSV:\n    case IF_SSV:\n    case IF_JSON:\n    case IF_JSONTIME:\n      break;\n    default:\n        if (strlen(im->graphfile)) {\n            cairo_show_page(im->cr);\n        } else {\n            cairo_surface_finish(im->surface);\n        }\n        break;\n    }\n\n    return 0;\n}\n\nint graph_paint_xy(\n                  image_desc_t UNUSED(*im), int UNUSED(lazy), int UNUSED(cnt))\n{\n  rrd_set_error(\"XY diagramm not implemented\");  \n  return -1;\n}\n\n/*****************************************************\n * graph stuff\n *****************************************************/\n\nint gdes_alloc(\n    image_desc_t *im)\n{\n\n    im->gdes_c++;\n    if ((im->gdes = (graph_desc_t *)\n         rrd_realloc(im->gdes, (im->gdes_c)\n                     * sizeof(graph_desc_t))) == NULL) {\n        rrd_set_error(\"realloc graph_descs\");\n        return -1;\n    }\n\n    /* set to zero */\n    memset(&(im->gdes[im->gdes_c - 1]),0,sizeof(graph_desc_t));\n\n    im->gdes[im->gdes_c - 1].step = im->step;\n    im->gdes[im->gdes_c - 1].step_orig = im->step;\n    im->gdes[im->gdes_c - 1].stack = 0;\n    im->gdes[im->gdes_c - 1].skipscale = 0;\n    im->gdes[im->gdes_c - 1].linewidth = 0;\n    im->gdes[im->gdes_c - 1].debug = 0;\n    im->gdes[im->gdes_c - 1].start = im->start;\n    im->gdes[im->gdes_c - 1].start_orig = im->start;\n    im->gdes[im->gdes_c - 1].end = im->end;\n    im->gdes[im->gdes_c - 1].end_orig = im->end;\n    im->gdes[im->gdes_c - 1].vname[0] = '\\0';\n    im->gdes[im->gdes_c - 1].data = NULL;\n    im->gdes[im->gdes_c - 1].ds_namv = NULL;\n    im->gdes[im->gdes_c - 1].data_first = 0;\n    im->gdes[im->gdes_c - 1].p_data = NULL;\n    im->gdes[im->gdes_c - 1].rpnp = NULL;\n    im->gdes[im->gdes_c - 1].p_dashes = NULL;\n    im->gdes[im->gdes_c - 1].shift = 0.0;\n    im->gdes[im->gdes_c - 1].dash = 0;\n    im->gdes[im->gdes_c - 1].ndash = 0;\n    im->gdes[im->gdes_c - 1].offset = 0;\n    im->gdes[im->gdes_c - 1].col.red = 0.0;\n    im->gdes[im->gdes_c - 1].col.green = 0.0;\n    im->gdes[im->gdes_c - 1].col.blue = 0.0;\n    im->gdes[im->gdes_c - 1].col.alpha = 0.0;\n    im->gdes[im->gdes_c - 1].col2.red = 0.0;\n    im->gdes[im->gdes_c - 1].col2.green = 0.0;\n    im->gdes[im->gdes_c - 1].col2.blue = 0.0;\n    im->gdes[im->gdes_c - 1].col2.alpha = 0.0;\n    im->gdes[im->gdes_c - 1].gradheight = 50.0;\n    im->gdes[im->gdes_c - 1].legend[0] = '\\0';\n    im->gdes[im->gdes_c - 1].format[0] = '\\0';\n    im->gdes[im->gdes_c - 1].strftm = 0;\n    im->gdes[im->gdes_c - 1].rrd[0] = '\\0';\n    im->gdes[im->gdes_c - 1].ds = -1;\n    im->gdes[im->gdes_c - 1].cf_reduce = CF_AVERAGE;\n    im->gdes[im->gdes_c - 1].cf_reduce_set = 0;    \n    im->gdes[im->gdes_c - 1].cf = CF_AVERAGE;\n    im->gdes[im->gdes_c - 1].yrule = DNAN;\n    im->gdes[im->gdes_c - 1].xrule = 0;\n    im->gdes[im->gdes_c - 1].daemon[0] = 0;\n    return 0;\n}\n\n/* copies input untill the first unescaped colon is found\n   or until input ends. backslashes have to be escaped as well */\nint scan_for_col(\n    const char *const input,\n    int len,\n    char *const output)\n{\n    int       inp, outp = 0;\n\n    for (inp = 0; inp < len && input[inp] != ':' && input[inp] != '\\0'; inp++) {\n        if (input[inp] == '\\\\'\n            && input[inp + 1] != '\\0'\n            && (input[inp + 1] == '\\\\' || input[inp + 1] == ':')) {\n            output[outp++] = input[++inp];\n        } else {\n            output[outp++] = input[inp];\n        }\n    }\n    output[outp] = '\\0';\n    return inp;\n}\n\n/* Now just a wrapper around rrd_graph_v */\nint rrd_graph(\n    int argc,\n    char **argv,\n    char ***prdata,\n    int *xsize,\n    int *ysize,\n    FILE * stream,\n    double *ymin,\n    double *ymax)\n{\n    int       prlines = 0;\n    rrd_info_t *grinfo = NULL;\n    rrd_info_t *walker;\n\n    grinfo = rrd_graph_v(argc, argv);\n    if (grinfo == NULL)\n        return -1;\n    walker = grinfo;\n    (*prdata) = NULL;\n    while (walker) {\n        if (strcmp(walker->key, \"image_info\") == 0) {\n            prlines++;\n            if (((*prdata) =\n                 (char**)rrd_realloc((*prdata),\n                             (prlines + 1) * sizeof(char *))) == NULL) {\n                rrd_set_error(\"realloc prdata\");\n                return 0;\n            }\n            /* imginfo goes to position 0 in the prdata array */\n            (*prdata)[prlines - 1] = strdup(walker->value.u_str);\n            (*prdata)[prlines] = NULL;\n        }\n        /* skip anything else */\n        walker = walker->next;\n    }\n    walker = grinfo;\n    *xsize = 0;\n    *ysize = 0;\n    *ymin = 0;\n    *ymax = 0;\n    while (walker) {\n        if (strcmp(walker->key, \"image_width\") == 0) {\n            *xsize = walker->value.u_cnt;\n        } else if (strcmp(walker->key, \"image_height\") == 0) {\n            *ysize = walker->value.u_cnt;\n        } else if (strcmp(walker->key, \"value_min\") == 0) {\n            *ymin = walker->value.u_val;\n        } else if (strcmp(walker->key, \"value_max\") == 0) {\n            *ymax = walker->value.u_val;\n        } else if (strncmp(walker->key, \"print\", 5) == 0) { /* keys are prdate[0..] */\n            prlines++;\n            if (((*prdata) =\n                 (char**)rrd_realloc((*prdata),\n                             (prlines + 1) * sizeof(char *))) == NULL) {\n                rrd_set_error(\"realloc prdata\");\n                return 0;\n            }\n            (*prdata)[prlines - 1] = strdup(walker->value.u_str);\n            (*prdata)[prlines] = NULL;\n        } else if (strcmp(walker->key, \"image\") == 0) {\n            if ( fwrite(walker->value.u_blo.ptr, walker->value.u_blo.size, 1,\n                   (stream ? stream : stdout)) == 0 && ferror(stream ? stream : stdout)){\n                rrd_set_error(\"writing image\");\n                return 0;\n            }\n        }\n        /* skip anything else */\n        walker = walker->next;\n    }\n    rrd_info_free(grinfo);\n    return 0;\n}\n\n\n/* Some surgery done on this function, it became ridiculously big.\n** Things moved:\n** - initializing     now in rrd_graph_init()\n** - options parsing  now in rrd_graph_options()\n** - script parsing   now in rrd_graph_script()\n*/\n\nrrd_info_t *rrd_graph_v(\n    int argc,\n    char **argv)\n{\n    image_desc_t im;\n    rrd_info_t *grinfo;\n    rrd_graph_init(&im);\n    /* a dummy surface so that we can measure text sizes for placements */\n    rrd_graph_options(argc, argv, &im);\n    if (rrd_test_error()) {\n        rrd_info_free(im.grinfo);\n        im_free(&im);\n        return NULL;\n    }\n\n    if (optind >= argc) {\n        rrd_info_free(im.grinfo);\n        im_free(&im);\n        rrd_set_error(\"missing filename\");\n        return NULL;\n    }\n\n    if (strlen(argv[optind]) >= MAXPATH) {\n        rrd_set_error(\"filename (including path) too long\");\n        rrd_info_free(im.grinfo);\n        im_free(&im);\n        return NULL;\n    }\n\n    strncpy(im.graphfile, argv[optind], MAXPATH - 1);\n    im.graphfile[MAXPATH - 1] = '\\0';\n\n    if (strcmp(im.graphfile, \"-\") == 0) {\n        im.graphfile[0] = '\\0';\n    }\n\n    rrd_graph_script(argc, argv, &im, 1);\n\n    if (rrd_test_error()) {\n        rrd_info_free(im.grinfo);\n        im_free(&im);\n        return NULL;\n    }\n    \n    /* Everything is now read and the actual work can start */\n    if (graph_paint(&im) == -1) {\n      rrd_info_free(im.grinfo);\n      im_free(&im);\n      return NULL;\n    }\n\n    /* The image is generated and needs to be output.\n     ** Also, if needed, print a line with information about the image.\n     */\n\n    if (im.imginfo && *im.imginfo) {\n        rrd_infoval_t info;\n        char     *path;\n        char     *filename;\n\n        if (bad_format_imginfo(im.imginfo)) {\n            rrd_info_free(im.grinfo);\n            im_free(&im);\n            rrd_set_error(\"bad format for imginfo\");\n            return NULL;\n        }\n        path = strdup(im.graphfile);\n        filename = basename(path);\n        info.u_str =\n            sprintf_alloc(im.imginfo,\n                          filename,\n                          (long) (im.zoom *\n                                  im.ximg), (long) (im.zoom * im.yimg));\n        grinfo_push(&im, sprintf_alloc(\"image_info\"), RD_I_STR, info);\n        free(info.u_str);\n        free(path);\n    }\n    if (im.rendered_image) {\n        rrd_infoval_t img;\n\n        img.u_blo.size = im.rendered_image_size;\n        img.u_blo.ptr = im.rendered_image;\n        grinfo_push(&im, sprintf_alloc(\"image\"), RD_I_BLO, img);\n    }\n    grinfo = im.grinfo;\n    im_free(&im);\n    return grinfo;\n}\n\nstatic void\nrrd_set_font_desc (\n    image_desc_t *im,int prop,char *font, double size ){\n    if (font){\n        strncpy(im->text_prop[prop].font, font, sizeof(text_prop[prop].font) - 1);\n        im->text_prop[prop].font[sizeof(text_prop[prop].font) - 1] = '\\0';\n        /* if we already got one, drop it first */\n        pango_font_description_free(im->text_prop[prop].font_desc);\n        im->text_prop[prop].font_desc = pango_font_description_from_string( font );\n    };\n    if (size > 0){\n        im->text_prop[prop].size = size;\n    };\n    if (im->text_prop[prop].font_desc && im->text_prop[prop].size ){\n        pango_font_description_set_size(im->text_prop[prop].font_desc, im->text_prop[prop].size * PANGO_SCALE);\n    };\n}\n\nvoid rrd_graph_init(\n    image_desc_t\n    *im)\n{\n    unsigned int i;\n    char     *deffont = getenv(\"RRD_DEFAULT_FONT\");\n    static PangoFontMap *fontmap = NULL;\n    PangoContext *context;\n\n    /* zero the whole structure first */\n    memset(im,0,sizeof(image_desc_t));\n\n#ifdef HAVE_TZSET\n    tzset();\n#endif\n    im->gdef_map = g_hash_table_new_full(g_str_hash, g_str_equal,g_free,NULL);\n\t//use of g_free() cause heap damage on windows. Key is allocated by malloc() in sprintf_alloc(), so free() must use\n    im->rrd_map = g_hash_table_new_full(g_str_hash, g_str_equal,free,NULL); \n    im->graph_type = GTYPE_TIME;\n    im->base = 1000;\n    im->daemon_addr = NULL;\n    im->draw_x_grid = 1;\n    im->draw_y_grid = 1;\n    im->draw_3d_border = 2;\n    im->dynamic_labels = 0;\n    im->extra_flags = 0;\n    im->font_options = cairo_font_options_create();\n    im->forceleftspace = 0;\n    im->gdes_c = 0;\n    im->gdes = NULL;\n    im->graph_antialias = CAIRO_ANTIALIAS_GRAY;\n    im->grid_dash_off = 1;\n    im->grid_dash_on = 1;\n    im->gridfit = 1;\n    im->grinfo = (rrd_info_t *) NULL;\n    im->grinfo_current = (rrd_info_t *) NULL;\n    im->imgformat = IF_PNG;\n    im->imginfo = NULL;\n    im->lazy = 0;\n    im->legenddirection = TOP_DOWN;\n    im->legendheight = 0;\n    im->legendposition = SOUTH;\n    im->legendwidth = 0;\n    im->logarithmic = 0;\n    im->maxval = DNAN;\n    im->minval = 0;\n    im->minval = DNAN;\n    im->magfact = 1;\n    im->prt_c = 0;\n    im->rigid = 0;\n    im->rendered_image_size = 0;\n    im->rendered_image = NULL;\n    im->slopemode = 0;\n    im->step = 0;\n    im->symbol = ' ';\n    im->tabwidth = 40.0;\n    im->title = NULL;\n    im->unitsexponent = 9999;\n    im->unitslength = 6;\n    im->viewfactor = 1.0;\n    im->watermark = NULL;\n    im->xlab_form = NULL;\n    im->with_markup = 0;\n    im->ximg = 0;\n    im->xlab_user.minsec = -1;\n    im->xorigin = 0;\n    im->xOriginLegend = 0;\n    im->xOriginLegendY = 0;\n    im->xOriginLegendY2 = 0;\n    im->xOriginTitle = 0;\n    im->xsize = 400;\n    im->ygridstep = DNAN;\n    im->yimg = 0;\n    im->ylegend = NULL;\n    im->second_axis_scale = 0; /* 0 disables it */\n    im->second_axis_shift = 0; /* no shift by default */\n    im->second_axis_legend = NULL;\n    im->second_axis_format = NULL;\n    im->primary_axis_format = NULL;\n    im->yorigin = 0;\n    im->yOriginLegend = 0;\n    im->yOriginLegendY = 0;\n    im->yOriginLegendY2 = 0;\n    im->yOriginTitle = 0;\n    im->ysize = 100;\n    im->zoom = 1;\n\n    im->surface = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, 10, 10);\n    im->cr = cairo_create(im->surface);\n\n    for (i = 0; i < DIM(text_prop); i++) {\n        im->text_prop[i].size = -1;\n        im->text_prop[i].font_desc = NULL;\n        rrd_set_font_desc(im,i, deffont ? deffont : text_prop[i].font,text_prop[i].size);\n    }\n\n    if (fontmap == NULL){\n        fontmap = pango_cairo_font_map_get_default();\n    }\n\n    context =  pango_font_map_create_context(fontmap);\n\n    pango_cairo_context_set_resolution(context, 100);\n\n    pango_cairo_update_context(im->cr,context);\n\n    im->layout = pango_layout_new(context);\n    g_object_unref (context);\n\n//  im->layout = pango_cairo_create_layout(im->cr);\n\n\n    cairo_font_options_set_hint_style\n        (im->font_options, CAIRO_HINT_STYLE_FULL);\n    cairo_font_options_set_hint_metrics\n        (im->font_options, CAIRO_HINT_METRICS_ON);\n    cairo_font_options_set_antialias(im->font_options, CAIRO_ANTIALIAS_GRAY);\n\n\n\n    for (i = 0; i < DIM(graph_col); i++)\n        im->graph_col[i] = graph_col[i];\n\n\n}\n\n\nvoid rrd_graph_options(\n    int argc,\n    char *argv[],\n    image_desc_t\n    *im)\n{\n    int       stroff;\n    char     *parsetime_error = NULL;\n    char      scan_gtm[12], scan_mtm[12], scan_ltm[12], col_nam[12];\n    char      double_str[20], double_str2[20];\n    time_t    start_tmp = 0, end_tmp = 0;\n    long      long_tmp;\n    rrd_time_value_t start_tv, end_tv;\n    long unsigned int color;\n\n    /* defines for long options without a short equivalent. should be bytes,\n       and may not collide with (the ASCII value of) short options */\n#define LONGOPT_UNITS_SI 255\n\n/* *INDENT-OFF* */\n    struct option long_options[] = {\n        { \"alt-autoscale\",      no_argument,       0, 'A'},\n        { \"imgformat\",          required_argument, 0, 'a'},\n        { \"font-smoothing-threshold\", required_argument, 0, 'B'},\n        { \"base\",               required_argument, 0, 'b'},\n        { \"color\",              required_argument, 0, 'c'},\n        { \"full-size-mode\",     no_argument,       0, 'D'},\n        { \"daemon\",             required_argument, 0, 'd'},\n        { \"slope-mode\",         no_argument,       0, 'E'},\n        { \"end\",                required_argument, 0, 'e'},\n        { \"force-rules-legend\", no_argument,       0, 'F'},\n        { \"imginfo\",            required_argument, 0, 'f'},\n        { \"graph-render-mode\",  required_argument, 0, 'G'},\n        { \"no-legend\",          no_argument,       0, 'g'},\n        { \"height\",             required_argument, 0, 'h'},\n        { \"no-minor\",           no_argument,       0, 'I'},\n        { \"interlaced\",         no_argument,       0, 'i'},\n        { \"alt-autoscale-min\",  no_argument,       0, 'J'},\n        { \"only-graph\",         no_argument,       0, 'j'},\n        { \"units-length\",       required_argument, 0, 'L'},\n        { \"lower-limit\",        required_argument, 0, 'l'},\n        { \"alt-autoscale-max\",  no_argument,       0, 'M'},\n        { \"zoom\",               required_argument, 0, 'm'},\n        { \"no-gridfit\",         no_argument,       0, 'N'},\n        { \"font\",               required_argument, 0, 'n'},\n        { \"logarithmic\",        no_argument,       0, 'o'},\n        { \"pango-markup\",       no_argument,       0, 'P'},\n        { \"font-render-mode\",   required_argument, 0, 'R'},\n        { \"rigid\",              no_argument,       0, 'r'},\n        { \"step\",               required_argument, 0, 'S'},\n        { \"start\",              required_argument, 0, 's'},\n        { \"tabwidth\",           required_argument, 0, 'T'},\n        { \"title\",              required_argument, 0, 't'},\n        { \"upper-limit\",        required_argument, 0, 'u'},\n        { \"vertical-label\",     required_argument, 0, 'v'},\n        { \"watermark\",          required_argument, 0, 'W'},\n        { \"width\",              required_argument, 0, 'w'},\n        { \"units-exponent\",     required_argument, 0, 'X'},\n        { \"x-grid\",             required_argument, 0, 'x'},\n        { \"alt-y-grid\",         no_argument,       0, 'Y'},\n        { \"y-grid\",             required_argument, 0, 'y'},\n        { \"lazy\",               no_argument,       0, 'z'},\n        { \"use-nan-for-all-missing-data\", no_argument,       0, 'Z'},\n        { \"units\",              required_argument, 0, LONGOPT_UNITS_SI},\n        { \"alt-y-mrtg\",         no_argument,       0, 1000},    /* this has no effect it is just here to save old apps from crashing when they use it */\n        { \"disable-rrdtool-tag\",no_argument,       0, 1001},\n        { \"right-axis\",         required_argument, 0, 1002},\n        { \"right-axis-label\",   required_argument, 0, 1003},\n        { \"right-axis-format\",  required_argument, 0, 1004},\n        { \"legend-position\",    required_argument, 0, 1005},\n        { \"legend-direction\",   required_argument, 0, 1006},\n        { \"border\",             required_argument, 0, 1007},\n        { \"grid-dash\",          required_argument, 0, 1008},\n        { \"dynamic-labels\",     no_argument,       0, 1009},\n        { \"week-fmt\",           required_argument, 0, 1010},\n        { \"graph-type\",         required_argument, 0, 1011},\n        { \"left-axis-format\",   required_argument, 0, 1012},\n        {  0, 0, 0, 0}\n};\n/* *INDENT-ON* */\n\n    optind = 0;\n    opterr = 0;         /* initialize getopt */\n    rrd_parsetime(\"end-24h\", &start_tv);\n    rrd_parsetime(\"now\", &end_tv);\n    while (1) {\n        int       option_index = 0;\n        int       opt;\n        int       col_start, col_end;\n\n        opt = getopt_long(argc, argv,\n                          \"Aa:B:b:c:Dd:Ee:Ff:G:gh:IiJjL:l:Mm:Nn:oPR:rS:s:T:t:u:v:W:w:X:x:Yy:Zz\",\n                          long_options, &option_index);\n        if (opt == EOF)\n            break;\n        switch (opt) {\n        case 'I':\n            im->extra_flags |= NOMINOR;\n            break;\n        case 'Y':\n            im->extra_flags |= ALTYGRID;\n            break;\n        case 'A':\n            im->extra_flags |= ALTAUTOSCALE;\n            break;\n        case 'J':\n            im->extra_flags |= ALTAUTOSCALE_MIN;\n            break;\n        case 'M':\n            im->extra_flags |= ALTAUTOSCALE_MAX;\n            break;\n        case 'j':\n            im->extra_flags |= ONLY_GRAPH;\n            break;\n        case 'g':\n            im->extra_flags |= NOLEGEND;\n            break;\n        case 'Z':\n            im->extra_flags |= ALLOW_MISSING_DS;\n            break;\n        case 1005:\n            if (strcmp(optarg, \"north\") == 0) {\n                im->legendposition = NORTH;\n            } else if (strcmp(optarg, \"west\") == 0) {\n                im->legendposition = WEST;\n            } else if (strcmp(optarg, \"south\") == 0) {\n                im->legendposition = SOUTH;\n            } else if (strcmp(optarg, \"east\") == 0) {\n                im->legendposition = EAST;\n            } else {\n                rrd_set_error(\"unknown legend-position '%s'\", optarg);\n                return;\n            }\n            break;\n        case 1006:\n            if (strcmp(optarg, \"topdown\") == 0) {\n                im->legenddirection = TOP_DOWN;\n            } else if (strcmp(optarg, \"bottomup\") == 0) {\n                im->legenddirection = BOTTOM_UP;\n            } else if (strcmp(optarg, \"bottomup2\") == 0) {\n                im->legenddirection = BOTTOM_UP2;\n            } else {\n                rrd_set_error(\"unknown legend-position '%s'\", optarg);\n                return;\n            }\n            break;\n        case 'F':\n            im->extra_flags |= FORCE_RULES_LEGEND;\n            break;\n        case 1001:\n            im->extra_flags |= NO_RRDTOOL_TAG;\n            break;\n        case LONGOPT_UNITS_SI:\n            if (im->extra_flags & FORCE_UNITS) {\n                rrd_set_error(\"--units can only be used once!\");\n                return;\n            }\n            if (strcmp(optarg, \"si\") == 0)\n                im->extra_flags |= FORCE_UNITS_SI;\n            else {\n                rrd_set_error(\"invalid argument for --units: %s\", optarg);\n                return;\n            }\n            break;\n        case 'X':\n            im->unitsexponent = atoi(optarg);\n            break;\n        case 'L':\n            im->unitslength = atoi(optarg);\n            im->forceleftspace = 1;\n            break;\n        case 'T':\n            if (rrd_strtodbl(optarg, 0, &(im->tabwidth), \"option -T\") != 2)\n                return;\n            break;\n        case 'S':\n            im->step = atoi(optarg);\n            break;\n        case 'N':\n            im->gridfit = 0;\n            break;\n        case 'P':\n            im->with_markup = 1;\n            break;\n        case 's':\n            if ((parsetime_error = rrd_parsetime(optarg, &start_tv))) {\n                rrd_set_error(\"start time: %s\", parsetime_error);\n                return;\n            }\n            break;\n        case 'e':\n            if ((parsetime_error = rrd_parsetime(optarg, &end_tv))) {\n                rrd_set_error(\"end time: %s\", parsetime_error);\n                return;\n            }\n            break;\n        case 'x':\n            if (strcmp(optarg, \"none\") == 0) {\n                im->draw_x_grid = 0;\n                break;\n            };\n            if (sscanf(optarg,\n                       \"%10[A-Z]:%ld:%10[A-Z]:%ld:%10[A-Z]:%ld:%ld:%n\",\n                       scan_gtm,\n                       &im->xlab_user.gridst,\n                       scan_mtm,\n                       &im->xlab_user.mgridst,\n                       scan_ltm,\n                       &im->xlab_user.labst,\n                       &im->xlab_user.precis, &stroff) == 7 && stroff != 0) {\n\t\t\t\tim->xlab_form=strdup(optarg + stroff);\n\t\t\t\tif (!im->xlab_form) {\n                    rrd_set_error(\"cannot allocate memory for xlab_form\");\n                    return;\n\t\t\t\t}\n                if ((int)\n                    (im->xlab_user.gridtm = tmt_conv(scan_gtm)) == -1) {\n                    rrd_set_error(\"unknown keyword %s\", scan_gtm);\n                    return;\n                } else if ((int)\n                           (im->xlab_user.mgridtm = tmt_conv(scan_mtm))\n                           == -1) {\n                    rrd_set_error(\"unknown keyword %s\", scan_mtm);\n                    return;\n                } else if ((int)\n                           (im->xlab_user.labtm = tmt_conv(scan_ltm)) == -1) {\n                    rrd_set_error(\"unknown keyword %s\", scan_ltm);\n                    return;\n                }\n                im->xlab_user.minsec = 1;\n                im->xlab_user.stst = im->xlab_form ? im->xlab_form : \"\";\n            } else {\n                rrd_set_error(\"invalid x-grid format\");\n                return;\n            }\n            break;\n        case 'y':\n            if (strcmp(optarg, \"none\") == 0) {\n                im->draw_y_grid = 0;\n                break;\n            };\n            if (sscanf(optarg, \"%[-0-9.e+]:%d\", double_str , &im->ylabfact) == 2) {\n                if (rrd_strtodbl( double_str, 0, &(im->ygridstep), \"option -y\") != 2){\n                    return;\n                }\n                if (im->ygridstep <= 0) {\n                    rrd_set_error(\"grid step must be > 0\");\n                    return;\n                } else if (im->ylabfact < 1) {\n                    rrd_set_error(\"label factor must be > 0\");\n                    return;\n                }\n            } else {\n                rrd_set_error(\"invalid y-grid format\");\n                return;\n            }\n            break;\n        case 1007:\n            im->draw_3d_border = atoi(optarg);\n            break;\n        case 1008: /* grid-dash */\n            if(sscanf(optarg,\n                      \"%[-0-9.e+]:%[-0-9.e+]\",\n                      double_str,\n                      double_str2 ) != 2) {\n                if ( rrd_strtodbl( double_str, 0, &(im->grid_dash_on),NULL) !=2 \n                     || rrd_strtodbl( double_str2, 0, &(im->grid_dash_off), NULL) != 2 ){\n                    rrd_set_error(\"expected grid-dash format float:float\");\n                    return;\n                }\n            }\n            break;   \n        case 1009: /* enable dynamic labels */\n            im->dynamic_labels = 1;\n            break;         \n        case 1010:\n            strncpy(week_fmt,optarg,sizeof week_fmt);\n            week_fmt[(sizeof week_fmt)-1]='\\0';\n            break;\n        case 1002: /* right y axis */\n            if(sscanf(optarg,\n                      \"%[-0-9.e+]:%[-0-9.e+]\",\n                      double_str,\n                      double_str2 ) == 2\n                && rrd_strtodbl( double_str, 0, &(im->second_axis_scale),NULL) == 2\n                && rrd_strtodbl( double_str2, 0, &(im->second_axis_shift),NULL) == 2){\n                if(im->second_axis_scale==0){\n                    rrd_set_error(\"the second_axis_scale  must not be 0\");\n                    return;\n                }\n            } else {\n                rrd_set_error(\"invalid right-axis format expected scale:shift\");\n                return;\n            }\n            break;\n        case 1003:\n            im->second_axis_legend=strdup(optarg);\n            if (!im->second_axis_legend) {\n                rrd_set_error(\"cannot allocate memory for second_axis_legend\");\n                return;\n            }\n            break;\n        case 1004:\n            if (bad_format(optarg)){\n                rrd_set_error(\"use either %le or %lf formats\");\n                return;\n            }\n            im->second_axis_format=strdup(optarg);\n            if (!im->second_axis_format) {\n                rrd_set_error(\"cannot allocate memory for second_axis_format\");\n                return;\n            }\n            break;\n        case 1012:\n            if (bad_format(optarg)){\n                rrd_set_error(\"use either %le or %lf formats\");\n                return;\n            }\n            im->primary_axis_format=strdup(optarg);\n            if (!im->primary_axis_format) {\n                rrd_set_error(\"cannot allocate memory for primary_axis_format\");\n                return;\n            }\n            break;\n        case 'v':\n            im->ylegend=strdup(optarg);\n            if (!im->ylegend) {\n                rrd_set_error(\"cannot allocate memory for ylegend\");\n                return;\n            }\n            break;\n        case 'u':\n            if (rrd_strtodbl(optarg, 0, &(im->maxval), \"option -u\") != 2){\n                return;\n            }\n            break;\n        case 'l':\n            if (rrd_strtodbl(optarg, 0, &(im->minval), \"option -l\") != 2){\n                return;\n            }\n            break;\n        case 'b':\n            im->base = atol(optarg);\n            if (im->base != 1024 && im->base != 1000) {\n                rrd_set_error\n                    (\"the only sensible value for base apart from 1000 is 1024\");\n                return;\n            }\n            break;\n        case 'w':\n            long_tmp = atol(optarg);\n            if (long_tmp < 10) {\n                rrd_set_error(\"width below 10 pixels\");\n                return;\n            }\n            im->xsize = long_tmp;\n            break;\n        case 'h':\n            long_tmp = atol(optarg);\n            if (long_tmp < 10) {\n                rrd_set_error(\"height below 10 pixels\");\n                return;\n            }\n            im->ysize = long_tmp;\n            break;\n        case 'D':\n            im->extra_flags |= FULL_SIZE_MODE;\n            break;\n        case 'i':\n            /* interlaced png not supported at the moment */\n            break;\n        case 'r':\n            im->rigid = 1;\n            break;\n        case 'f':\n            im->imginfo = optarg;\n            break;\n        case 'a':\n            if ((int)\n                (im->imgformat = if_conv(optarg)) == -1) {\n                rrd_set_error(\"unsupported graphics format '%s'\", optarg);\n                return;\n            }\n            break;\n        case 1011:\n            if ((int)\n                (im->graph_type = type_conv(optarg)) == -1) {\n                rrd_set_error(\"unsupported graphics type '%s'\", optarg);\n                return;\n            }\n            break;\n        case 'z':\n            im->lazy = 1;\n            break;\n        case 'E':\n            im->slopemode = 1;\n            break;\n        case 'o':\n            im->logarithmic = 1;\n            break;\n        case 'c':\n            if (sscanf(optarg,\n                       \"%10[A-Z]#%n%8lx%n\",\n                       col_nam, &col_start, &color, &col_end) == 2) {\n                int       ci;\n                int       col_len = col_end - col_start;\n\n                switch (col_len) {\n                case 3:\n                    color =\n                        (((color & 0xF00) * 0x110000) | ((color & 0x0F0) *\n                                                         0x011000) |\n                         ((color & 0x00F)\n                          * 0x001100)\n                         | 0x000000FF);\n                    break;\n                case 4:\n                    color =\n                        (((color & 0xF000) *\n                          0x11000) | ((color & 0x0F00) *\n                                      0x01100) | ((color &\n                                                   0x00F0) *\n                                                  0x00110) |\n                         ((color & 0x000F) * 0x00011)\n                        );\n                    break;\n                case 6:\n                    color = (color << 8) + 0xff /* shift left by 8 */ ;\n                    break;\n                case 8:\n                    break;\n                default:\n                    rrd_set_error(\"the color format is #RRGGBB[AA]\");\n                    return;\n                }\n                if ((ci = grc_conv(col_nam)) != -1) {\n                    im->graph_col[ci] = gfx_hex_to_col(color);\n                } else {\n                    rrd_set_error(\"invalid color name '%s'\", col_nam);\n                    return;\n                }\n            } else {\n                rrd_set_error(\"invalid color def format\");\n                return;\n            }\n            break;\n        case 'n':{\n            char      prop[15];\n            double    size = 1;\n            int       end;\n\n            if (sscanf(optarg, \"%10[A-Z]:%[-0-9.e+]%n\", prop, double_str, &end) >= 2\n                && rrd_strtodbl( double_str, 0, &size, NULL) == 2) {\n                int       sindex, propidx;\n\n                if ((sindex = text_prop_conv(prop)) != -1) {\n                    for (propidx = sindex;\n                         propidx < TEXT_PROP_LAST; propidx++) {\n                        if (size > 0) {\n                            rrd_set_font_desc(im,propidx,NULL,size);\n                        }\n                        if ((int) strlen(optarg) > end+2) {\n                            if (optarg[end] == ':') {\n                                rrd_set_font_desc(im,propidx,optarg + end + 1,0);\n                            } else {\n                                rrd_set_error\n                                    (\"expected : after font size in '%s'\",\n                                     optarg);\n                                return;\n                            }\n                        }\n                        /* only run the for loop for DEFAULT (0) for\n                           all others, we break here. woodo programming */\n                        if (propidx == sindex && sindex != 0)\n                            break;\n                    }\n                } else {\n                    rrd_set_error(\"invalid fonttag '%s'\", prop);\n                    return;\n                }\n            } else {\n                rrd_set_error(\"invalid text property format\");\n                return;\n            }\n            break;\n        }\n        case 'm':\n            if (rrd_strtodbl(optarg, 0, &(im->zoom), \"option -m\") != 2){\n                return;\n            }\n            if (im->zoom <= 0.0) {\n                rrd_set_error(\"zoom factor must be > 0\");\n                return;\n            }\n            break;\n        case 't':\n            im->title=strdup(optarg);\n            if (!im->title) {\n                rrd_set_error(\"cannot allocate memory for title\");\n                return;\n            }\n            break;\n        case 'R':\n            if (strcmp(optarg, \"normal\") == 0) {\n                cairo_font_options_set_antialias\n                    (im->font_options, CAIRO_ANTIALIAS_GRAY);\n                cairo_font_options_set_hint_style\n                    (im->font_options, CAIRO_HINT_STYLE_FULL);\n            } else if (strcmp(optarg, \"light\") == 0) {\n                cairo_font_options_set_antialias\n                    (im->font_options, CAIRO_ANTIALIAS_GRAY);\n                cairo_font_options_set_hint_style\n                    (im->font_options, CAIRO_HINT_STYLE_SLIGHT);\n            } else if (strcmp(optarg, \"mono\") == 0) {\n                cairo_font_options_set_antialias\n                    (im->font_options, CAIRO_ANTIALIAS_NONE);\n                cairo_font_options_set_hint_style\n                    (im->font_options, CAIRO_HINT_STYLE_FULL);\n            } else {\n                rrd_set_error(\"unknown font-render-mode '%s'\", optarg);\n                return;\n            }\n            break;\n        case 'G':\n            if (strcmp(optarg, \"normal\") == 0)\n                im->graph_antialias = CAIRO_ANTIALIAS_GRAY;\n            else if (strcmp(optarg, \"mono\") == 0)\n                im->graph_antialias = CAIRO_ANTIALIAS_NONE;\n            else {\n                rrd_set_error(\"unknown graph-render-mode '%s'\", optarg);\n                return;\n            }\n            break;\n        case 'B':\n            /* not supported curently */\n            break;\n        case 'W':\n            im->watermark=strdup(optarg);\n            if (!im->watermark) {\n                rrd_set_error(\"cannot allocate memory for watermark\");\n                return;\n            }\n            break;\n        case 'd':\n        {\n            if (im->daemon_addr != NULL)\n            {\n                rrd_set_error (\"You cannot specify --daemon \"\n                        \"more than once.\");\n                return;\n            }\n\n            im->daemon_addr = strdup(optarg);\n            if (im->daemon_addr == NULL)\n            {\n              rrd_set_error(\"strdup failed\");\n              return;\n            }\n\n            break;\n        }\n        case '?':\n            if (optopt != 0)\n                rrd_set_error(\"unknown option '%c'\", optopt);\n            else\n                rrd_set_error(\"unknown option '%s'\", argv[optind - 1]);\n            return;\n        }\n    } /* while (1) */\n\n    pango_cairo_context_set_font_options(pango_layout_get_context(im->layout), im->font_options);\n    pango_layout_context_changed(im->layout);\n\n\n\n    if (im->logarithmic && im->minval <= 0) {\n        rrd_set_error\n            (\"for a logarithmic yaxis you must specify a lower-limit > 0\");\n        return;\n    }\n\n    if (rrd_proc_start_end(&start_tv, &end_tv, &start_tmp, &end_tmp) == -1) {\n        /* error string is set in rrd_parsetime.c */\n        return;\n    }\n\n    if (start_tmp < 3600 * 24 * 365 * 10) {\n        rrd_set_error\n            (\"the first entry to fetch should be after 1980 (%ld)\",\n             start_tmp);\n        return;\n    }\n\n    if (end_tmp < start_tmp) {\n        rrd_set_error\n            (\"start (%ld) should be less than end (%ld)\", start_tmp, end_tmp);\n        return;\n    }\n\n    im->start = start_tmp;\n    im->end = end_tmp;\n    im->step = max((long) im->step, (im->end - im->start) / im->xsize);\n}\n\nint rrd_graph_color(\n    image_desc_t\n    *im,\n    char *var,\n    char *err,\n    int optional)\n{\n    char     *color;\n    graph_desc_t *gdp = &im->gdes[im->gdes_c - 1];\n\n    color = strstr(var, \"#\");\n    if (color == NULL) {\n        if (optional == 0) {\n            rrd_set_error(\"Found no color in %s\", err);\n            return 0;\n        }\n        return 0;\n    } else {\n        int       n = 0;\n        char     *rest;\n        long unsigned int col;\n\n        rest = strstr(color, \":\");\n        if (rest != NULL)\n            n = rest - color;\n        else\n            n = strlen(color);\n        switch (n) {\n        case 7:\n            sscanf(color, \"#%6lx%n\", &col, &n);\n            col = (col << 8) + 0xff /* shift left by 8 */ ;\n            if (n != 7)\n                rrd_set_error(\"Color problem in %s\", err);\n            break;\n        case 9:\n            sscanf(color, \"#%8lx%n\", &col, &n);\n            if (n == 9)\n                break;\n        default:\n            rrd_set_error(\"Color problem in %s\", err);\n        }\n        if (rrd_test_error())\n            return 0;\n        gdp->col = gfx_hex_to_col(col);\n        return n;\n    }\n}\n\n\nint bad_format(\n    char *fmt)\n{\n    char     *ptr;\n    int       n = 0;\n\n    ptr = fmt;\n    while (*ptr != '\\0')\n        if (*ptr++ == '%') {\n\n            /* line cannot end with percent char */\n            if (*ptr == '\\0')\n                return 1;\n            /* '%s', '%S' and '%%' are allowed */\n            if (*ptr == 's' || *ptr == 'S' || *ptr == '%')\n                ptr++;\n            /* %c is allowed (but use only with vdef!) */\n            else if (*ptr == 'c') {\n                ptr++;\n                n = 1;\n            }\n\n            /* or else '% 6.2lf' and such are allowed */\n            else {\n                /* optional padding character */\n                if (*ptr == ' ' || *ptr == '+' || *ptr == '-')\n                    ptr++;\n                /* This should take care of 'm.n' with all three optional */\n                while (*ptr >= '0' && *ptr <= '9')\n                    ptr++;\n                if (*ptr == '.')\n                    ptr++;\n                while (*ptr >= '0' && *ptr <= '9')\n                    ptr++;\n                /* Either 'le', 'lf' or 'lg' must follow here */\n                if (*ptr++ != 'l')\n                    return 1;\n                if (*ptr == 'e' || *ptr == 'f' || *ptr == 'g')\n                    ptr++;\n                else\n                    return 1;\n                n++;\n            }\n        }\n\n    return (n != 1);\n}\n\n\nint bad_format_imginfo(\n    char *fmt)\n{\n    char     *ptr;\n    int       n = 0;\n\n    ptr = fmt;\n    while (*ptr != '\\0')\n        if (*ptr++ == '%') {\n\n            /* line cannot end with percent char */\n            if (*ptr == '\\0')\n                return 1;\n            /* '%%' is allowed */\n            if (*ptr == '%')\n                ptr++;\n            /* '%s', '%S' are allowed */\n            else if (*ptr == 's' || *ptr == 'S') {\n                n = 1;\n                ptr++;\n            }\n\n            /* or else '% 4lu' and such are allowed */\n            else {\n                /* optional padding character */\n                if (*ptr == ' ')\n                    ptr++;\n                /* This should take care of 'm' */\n                while (*ptr >= '0' && *ptr <= '9')\n                    ptr++;\n                /* 'lu' must follow here */\n                if (*ptr++ != 'l')\n                    return 1;\n                if (*ptr == 'u')\n                    ptr++;\n                else\n                    return 1;\n                n++;\n            }\n        }\n\n    return (n != 3);\n}\n\n\nint vdef_parse(\n    struct graph_desc_t\n    *gdes,\n    const char *const str)\n{\n    /* A VDEF currently is either \"func\" or \"param,func\"\n     * so the parsing is rather simple.  Change if needed.\n     */\n    double    param;\n    char      func[30], double_str[21];\n    int       n;\n\n    n = 0;\n    sscanf(str, \"%20[-0-9.e+],%29[A-Z]%n\", double_str, func, &n);\n    if ( rrd_strtodbl( double_str, NULL, &param, NULL) != 2 ){\n        n = 0;\n        sscanf(str, \"%29[A-Z]%n\", func, &n);\n        if (n == (int) strlen(str)) {   /* matched */\n            param = DNAN;\n        } else {\n            rrd_set_error\n                (\"Unknown function string '%s' in VDEF '%s'\",\n                 str, gdes->vname);\n            return -1;\n        }\n    }\n    if (!strcmp(\"PERCENT\", func))\n        gdes->vf.op = VDEF_PERCENT;\n    else if (!strcmp(\"PERCENTNAN\", func))\n        gdes->vf.op = VDEF_PERCENTNAN;\n    else if (!strcmp(\"MAXIMUM\", func))\n        gdes->vf.op = VDEF_MAXIMUM;\n    else if (!strcmp(\"AVERAGE\", func))\n        gdes->vf.op = VDEF_AVERAGE;\n    else if (!strcmp(\"STDEV\", func))\n        gdes->vf.op = VDEF_STDEV;\n    else if (!strcmp(\"MINIMUM\", func))\n        gdes->vf.op = VDEF_MINIMUM;\n    else if (!strcmp(\"TOTAL\", func))\n        gdes->vf.op = VDEF_TOTAL;\n    else if (!strcmp(\"FIRST\", func))\n        gdes->vf.op = VDEF_FIRST;\n    else if (!strcmp(\"LAST\", func))\n        gdes->vf.op = VDEF_LAST;\n    else if (!strcmp(\"LSLSLOPE\", func))\n        gdes->vf.op = VDEF_LSLSLOPE;\n    else if (!strcmp(\"LSLINT\", func))\n        gdes->vf.op = VDEF_LSLINT;\n    else if (!strcmp(\"LSLCORREL\", func))\n        gdes->vf.op = VDEF_LSLCORREL;\n    else {\n        rrd_set_error\n            (\"Unknown function '%s' in VDEF '%s'\\n\", func, gdes->vname);\n        return -1;\n    };\n    switch (gdes->vf.op) {\n    case VDEF_PERCENT:\n    case VDEF_PERCENTNAN:\n        if (isnan(param)) { /* no parameter given */\n            rrd_set_error\n                (\"Function '%s' needs parameter in VDEF '%s'\\n\",\n                 func, gdes->vname);\n            return -1;\n        };\n        if (param >= 0.0 && param <= 100.0) {\n            gdes->vf.param = param;\n            gdes->vf.val = DNAN;    /* undefined */\n            gdes->vf.when = 0;  /* undefined */\n            gdes->vf.never = 1;\n        } else {\n            rrd_set_error\n                (\"Parameter '%f' out of range in VDEF '%s'\\n\",\n                 param, gdes->vname);\n            return -1;\n        };\n        break;\n    case VDEF_MAXIMUM:\n    case VDEF_AVERAGE:\n    case VDEF_STDEV:\n    case VDEF_MINIMUM:\n    case VDEF_TOTAL:\n    case VDEF_FIRST:\n    case VDEF_LAST:\n    case VDEF_LSLSLOPE:\n    case VDEF_LSLINT:\n    case VDEF_LSLCORREL:\n        if (isnan(param)) {\n            gdes->vf.param = DNAN;\n            gdes->vf.val = DNAN;\n            gdes->vf.when = 0;\n            gdes->vf.never = 1;\n        } else {\n            rrd_set_error\n                (\"Function '%s' needs no parameter in VDEF '%s'\\n\",\n                 func, gdes->vname);\n            return -1;\n        };\n        break;\n    };\n    return 0;\n}\n\n\nint vdef_calc(\n    image_desc_t *im,\n    int gdi)\n{\n    graph_desc_t *src, *dst;\n    rrd_value_t *data;\n    long      step, steps;\n\n    dst = &im->gdes[gdi];\n    src = &im->gdes[dst->vidx];\n    data = src->data + src->ds;\n\n    steps = (src->end - src->start) / src->step;\n#if 0\n    printf\n        (\"DEBUG: start == %lu, end == %lu, %lu steps\\n\",\n         src->start, src->end, steps);\n#endif\n    switch (dst->vf.op) {\n    case VDEF_PERCENT:{\n        rrd_value_t *array;\n        int       field;\n        if ((array = (rrd_value_t*)malloc(steps * sizeof(double))) == NULL) {\n            rrd_set_error(\"malloc VDEV_PERCENT\");\n            return -1;\n        }\n        for (step = 0; step < steps; step++) {\n            array[step] = data[step * src->ds_cnt];\n        }\n        qsort(array, step, sizeof(double), vdef_percent_compar);\n        field = round((dst->vf.param * (double)(steps - 1)) / 100.0);\n        dst->vf.val = array[field];\n        dst->vf.when = 0;   /* no time component */\n        dst->vf.never = 1;\n        free(array);\n#if 0\n        for (step = 0; step < steps; step++)\n            printf(\"DEBUG: %3li:%10.2f %c\\n\",\n                   step, array[step], step == field ? '*' : ' ');\n#endif\n    }\n        break;\n    case VDEF_PERCENTNAN:{\n        rrd_value_t *array;\n        int       field;\n       /* count number of \"valid\" values */\n       int nancount=0;\n       for (step = 0; step < steps; step++) {\n         if (!isnan(data[step * src->ds_cnt])) { nancount++; }\n       }\n       /* and allocate it */\n        if ((array = (rrd_value_t*)malloc(nancount * sizeof(double))) == NULL) {\n            rrd_set_error(\"malloc VDEV_PERCENT\");\n            return -1;\n        }\n       /* and fill it in */\n       field=0;\n        for (step = 0; step < steps; step++) {\n           if (!isnan(data[step * src->ds_cnt])) {\n                array[field] = data[step * src->ds_cnt];\n               field++;\n            }\n        }\n        qsort(array, nancount, sizeof(double), vdef_percent_compar);\n        field = round( dst->vf.param * (double)(nancount - 1) / 100.0);\n        dst->vf.val = array[field];\n        dst->vf.when = 0;   /* no time component */\n        dst->vf.never = 1;\n        free(array);\n    }\n        break;\n    case VDEF_MAXIMUM:\n        step = 0;\n        while (step != steps && isnan(data[step * src->ds_cnt]))\n            step++;\n        if (step == steps) {\n            dst->vf.val = DNAN;\n            dst->vf.when = 0;\n            dst->vf.never = 1;\n        } else {\n            dst->vf.val = data[step * src->ds_cnt];\n            dst->vf.when = src->start + (step + 1) * src->step;\n            dst->vf.never = 0;\n        }\n        while (step != steps) {\n            if (finite(data[step * src->ds_cnt])) {\n                if (data[step * src->ds_cnt] > dst->vf.val) {\n                    dst->vf.val = data[step * src->ds_cnt];\n                    dst->vf.when = src->start + (step + 1) * src->step;\n                    dst->vf.never = 0;\n                }\n            }\n            step++;\n        }\n        break;\n    case VDEF_TOTAL:\n    case VDEF_STDEV:\n    case VDEF_AVERAGE:{\n        int       cnt = 0;\n        double    sum = 0.0;\n        double    average = 0.0;\n\n        for (step = 0; step < steps; step++) {\n            if (finite(data[step * src->ds_cnt])) {\n                sum += data[step * src->ds_cnt];\n                cnt++;\n            };\n        }\n        if (cnt) {\n            if (dst->vf.op == VDEF_TOTAL) {\n                dst->vf.val = sum * src->step;\n                dst->vf.when = 0;   /* no time component */\n                dst->vf.never = 1;\n            } else if (dst->vf.op == VDEF_AVERAGE) {\n                dst->vf.val = sum / cnt;\n                dst->vf.when = 0;   /* no time component */\n                dst->vf.never = 1;\n            } else {\n                average = sum / cnt;\n                sum = 0.0;\n                for (step = 0; step < steps; step++) {\n                    if (finite(data[step * src->ds_cnt])) {\n                        sum += pow((data[step * src->ds_cnt] - average), 2.0);\n                    };\n                }\n                dst->vf.val = pow(sum / cnt, 0.5);\n                dst->vf.when = 0;   /* no time component */\n                dst->vf.never = 1;\n            };\n        } else {\n            dst->vf.val = DNAN;\n            dst->vf.when = 0;\n            dst->vf.never = 1;\n        }\n    }\n        break;\n    case VDEF_MINIMUM:\n        step = 0;\n        while (step != steps && isnan(data[step * src->ds_cnt]))\n            step++;\n        if (step == steps) {\n            dst->vf.val = DNAN;\n            dst->vf.when = 0;\n            dst->vf.never = 1;\n        } else {\n            dst->vf.val = data[step * src->ds_cnt];\n            dst->vf.when = src->start + (step + 1) * src->step;\n            dst->vf.never = 0;\n        }\n        while (step != steps) {\n            if (finite(data[step * src->ds_cnt])) {\n                if (data[step * src->ds_cnt] < dst->vf.val) {\n                    dst->vf.val = data[step * src->ds_cnt];\n                    dst->vf.when = src->start + (step + 1) * src->step;\n                    dst->vf.never = 0;\n                }\n            }\n            step++;\n        }\n        break;\n    case VDEF_FIRST:\n        /* The time value returned here is one step before the\n         * actual time value.  This is the start of the first\n         * non-NaN interval.\n         */\n        step = 0;\n        while (step != steps && isnan(data[step * src->ds_cnt]))\n            step++;\n        if (step == steps) {    /* all entries were NaN */\n            dst->vf.val = DNAN;\n            dst->vf.when = 0;\n            dst->vf.never = 1;\n        } else {\n            dst->vf.val = data[step * src->ds_cnt];\n            dst->vf.when = src->start + step * src->step;\n            dst->vf.never = 0;\n        }\n        break;\n    case VDEF_LAST:\n        /* The time value returned here is the\n         * actual time value.  This is the end of the last\n         * non-NaN interval.\n         */\n        step = steps - 1;\n        while (step >= 0 && isnan(data[step * src->ds_cnt]))\n            step--;\n        if (step < 0) { /* all entries were NaN */\n            dst->vf.val = DNAN;\n            dst->vf.when = 0;\n            dst->vf.never = 1;\n        } else {\n            dst->vf.val = data[step * src->ds_cnt];\n            dst->vf.when = src->start + (step + 1) * src->step;\n            dst->vf.never = 0;\n        }\n        break;\n    case VDEF_LSLSLOPE:\n    case VDEF_LSLINT:\n    case VDEF_LSLCORREL:{\n        /* Bestfit line by linear least squares method */\n\n        int       cnt = 0;\n        double    SUMx, SUMy, SUMxy, SUMxx, SUMyy, slope, y_intercept, correl;\n\n        SUMx = 0;\n        SUMy = 0;\n        SUMxy = 0;\n        SUMxx = 0;\n        SUMyy = 0;\n        for (step = 0; step < steps; step++) {\n            if (finite(data[step * src->ds_cnt])) {\n                cnt++;\n                SUMx += step;\n                SUMxx += step * step;\n                SUMxy += step * data[step * src->ds_cnt];\n                SUMy += data[step * src->ds_cnt];\n                SUMyy += data[step * src->ds_cnt] * data[step * src->ds_cnt];\n            };\n        }\n\n        slope = (SUMx * SUMy - cnt * SUMxy) / (SUMx * SUMx - cnt * SUMxx);\n        y_intercept = (SUMy - slope * SUMx) / cnt;\n        correl =\n            (SUMxy -\n             (SUMx * SUMy) / cnt) /\n            sqrt((SUMxx -\n                  (SUMx * SUMx) / cnt) * (SUMyy - (SUMy * SUMy) / cnt));\n        if (cnt) {\n            if (dst->vf.op == VDEF_LSLSLOPE) {\n                dst->vf.val = slope;\n                dst->vf.when = 0;\n                dst->vf.never = 1;\n            } else if (dst->vf.op == VDEF_LSLINT) {\n                dst->vf.val = y_intercept;\n                dst->vf.when = 0;\n                dst->vf.never = 1;\n            } else if (dst->vf.op == VDEF_LSLCORREL) {\n                dst->vf.val = correl;\n                dst->vf.when = 0;\n                dst->vf.never = 1;\n            };\n        } else {\n            dst->vf.val = DNAN;\n            dst->vf.when = 0;\n            dst->vf.never = 1;\n        }\n    }\n        break;\n    }\n    return 0;\n}\n\n/* NaN < -INF < finite_values < INF */\nint vdef_percent_compar(\n    const void\n    *a,\n    const void\n    *b)\n{\n    /* Equality is not returned; this doesn't hurt except\n     * (maybe) for a little performance.\n     */\n\n    /* First catch NaN values. They are smallest */\n    if (isnan(*(double *) a))\n        return -1;\n    if (isnan(*(double *) b))\n        return 1;\n    /* NaN doesn't reach this part so INF and -INF are extremes.\n     * The sign from isinf() is compatible with the sign we return\n     */\n    if (isinf(*(double *) a))\n        return isinf(*(double *) a);\n    if (isinf(*(double *) b))\n        return isinf(*(double *) b);\n    /* If we reach this, both values must be finite */\n    if (*(double *) a < *(double *) b)\n        return -1;\n    else\n        return 1;\n}\n\nvoid grinfo_push(\n    image_desc_t *im,\n    char *key,\n    rrd_info_type_t type,\n    rrd_infoval_t value)\n{\n    im->grinfo_current = rrd_info_push(im->grinfo_current, key, type, value);\n    if (im->grinfo == NULL) {\n        im->grinfo = im->grinfo_current;\n    }\n}\n\n\nvoid time_clean(\n    char *result,\n    char *format)\n{\n    int       j, jj;\n    \n/*     Handling based on\n       - ANSI C99 Specifications                         http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf\n       - Single UNIX Specification version 2             http://www.opengroup.org/onlinepubs/007908799/xsh/strftime.html \n       - POSIX:2001/Single UNIX Specification version 3  http://www.opengroup.org/onlinepubs/009695399/functions/strftime.html\n       - POSIX:2008 Specifications                       http://www.opengroup.org/onlinepubs/9699919799/functions/strftime.html\n       Specifications tells \n       \"If a conversion specifier is not one of the above, the behavior is undefined.\"\n\n      C99 tells\n       \"A conversion specifier consists of a % character, possibly followed by an E or O modifier character (described below), followed by a character that determines the behavior of the conversion specifier.\n\n      POSIX:2001 tells\n      \"A conversion specification consists of a '%' character, possibly followed by an E or O modifier, and a terminating conversion specifier character that determines the conversion specification's behavior.\"\n\n      POSIX:2008 introduce more complexe behavior that are not handled here.\n\n      According to this, this code will replace:\n      - % followed by @ by a %@\n      - % followed by   by a %SPACE\n      - % followed by . by a %.\n      - % followed by % by a %\n      - % followed by t by a TAB\n      - % followed by E then anything by '-'\n      - % followed by O then anything by '-'\n      - % followed by anything else by at least one '-'. More characters may be added to better fit expected output length\n*/\n\n    jj = 0;\n    for(j = 0; (j < FMT_LEG_LEN - 1) && (jj < FMT_LEG_LEN); j++) { /* we don't need to parse the last char */\n        if (format[j] == '%') {\n            if ((format[j+1] == 'E') || (format[j+1] == 'O')) {\n                result[jj++] = '-';\n                j+=2; /* We skip next 2 following char */\n            } else if ((format[j+1] == 'C') || (format[j+1] == 'd') ||\n                       (format[j+1] == 'g') || (format[j+1] == 'H') ||\n                       (format[j+1] == 'I') || (format[j+1] == 'm') ||\n                       (format[j+1] == 'M') || (format[j+1] == 'S') ||\n                       (format[j+1] == 'U') || (format[j+1] == 'V') ||\n                       (format[j+1] == 'W') || (format[j+1] == 'y')) {\n                result[jj++] = '-';\n                if (jj < FMT_LEG_LEN) {\n                    result[jj++] = '-';\n                }\n                j++; /* We skip the following char */\n            } else if (format[j+1] == 'j') {\n                result[jj++] = '-';\n                if (jj < FMT_LEG_LEN - 1) {\n                    result[jj++] = '-';\n                    result[jj++] = '-';\n               }\n                j++; /* We skip the following char */\n            } else if ((format[j+1] == 'G') || (format[j+1] == 'Y')) {\n                /* Assuming Year on 4 digit */\n                result[jj++] = '-';\n                if (jj < FMT_LEG_LEN - 2) {\n                    result[jj++] = '-';\n                    result[jj++] = '-';\n                    result[jj++] = '-';\n                }\n                j++; /* We skip the following char */\n            } else if (format[j+1] == 'R') {\n                result[jj++] = '-';\n                if (jj < FMT_LEG_LEN - 3) {\n                    result[jj++] = '-';\n                    result[jj++] = ':';\n                    result[jj++] = '-';\n                    result[jj++] = '-';\n                }\n                j++; /* We skip the following char */\n            } else if (format[j+1] == 'T') {\n                result[jj++] = '-';\n                if (jj < FMT_LEG_LEN - 6) {\n                    result[jj++] = '-';\n                    result[jj++] = ':';\n                    result[jj++] = '-';\n                    result[jj++] = '-';\n                    result[jj++] = ':';\n                    result[jj++] = '-';\n                    result[jj++] = '-';\n                }\n                j++; /* We skip the following char */\n            } else if (format[j+1] == 'F') {\n                result[jj++] = '-';\n                if (jj < FMT_LEG_LEN - 8) {\n                    result[jj++] = '-';\n                    result[jj++] = '-';\n                    result[jj++] = '-';\n                    result[jj++] = '-';\n                    result[jj++] = '-';\n                    result[jj++] = '-';\n                    result[jj++] = '-';\n                    result[jj++] = '-';\n                    result[jj++] = '-';\n                }\n                j++; /* We skip the following char */\n            } else if (format[j+1] == 'D') {\n                result[jj++] = '-';\n                if (jj < FMT_LEG_LEN - 6) {\n                    result[jj++] = '-';\n                    result[jj++] = '/';\n                    result[jj++] = '-';\n                    result[jj++] = '-';\n                    result[jj++] = '/';\n                    result[jj++] = '-';\n                    result[jj++] = '-';\n                }\n                j++; /* We skip the following char */\n            } else if (format[j+1] == 'n') {\n                result[jj++] = '\\r';\n                result[jj++] = '\\n';\n                j++; /* We skip the following char */\n            } else if (format[j+1] == 't') {\n                result[jj++] = '\\t';\n                j++; /* We skip the following char */\n            } else if (format[j+1] == '%') {\n                result[jj++] = '%';\n                j++; /* We skip the following char */\n            } else if (format[j+1] == ' ') {\n                if (jj < FMT_LEG_LEN - 1) {\n                    result[jj++] = '%';\n                    result[jj++] = ' ';\n                }\n                j++; /* We skip the following char */\n            } else if (format[j+1] == '.') {\n                if (jj < FMT_LEG_LEN - 1) {\n                    result[jj++] = '%';\n                    result[jj++] = '.';\n                }\n                j++; /* We skip the following char */\n            } else if (format[j+1] == '@') {\n                if (jj < FMT_LEG_LEN - 1) {\n                    result[jj++] = '%';\n                    result[jj++] = '@';\n                }\n                j++; /* We skip the following char */\n            } else {\n                result[jj++] = '-';\n                j++; /* We skip the following char */\n            }\n        } else {\n                result[jj++] = format[j];\n        }\n    }\n    result[jj] = '\\0'; /* We must force the end of the string */\n}\n", "#ifndef RRD_GRAPH_H_DBEDBFB6C5844ED9BEA6242F879CA284\n#define RRD_GRAPH_H_DBEDBFB6C5844ED9BEA6242F879CA284\n\n#define y0 cairo_y0\n#define y1 cairo_y1\n#define index cairo_index\n\n/* this may configure __EXTENSIONS__ without which pango will fail to compile\n   so load this early */\n#include \"rrd_config.h\"\n\n#include <cairo.h>\n#include <cairo-pdf.h>\n#include <cairo-svg.h>\n#include <cairo-ps.h>\n\n#include <pango/pangocairo.h>\n\n\n#include \"rrd_tool.h\"\n#include \"rrd_rpncalc.h\"\n\n#include <glib.h>\n\n\n#ifdef WIN32\n#  include <windows.h>\n#  define MAXPATH MAX_PATH\n#endif\n\n#define ALTYGRID  \t 0x01   /* use alternative y grid algorithm */\n#define ALTAUTOSCALE\t 0x02   /* use alternative algorithm to find lower and upper bounds */\n#define ALTAUTOSCALE_MIN 0x04   /* use alternative algorithm to find lower bounds */\n#define ALTAUTOSCALE_MAX 0x08   /* use alternative algorithm to find upper bounds */\n#define NOLEGEND\t 0x10   /* use no legend */\n#define NOMINOR          0x20   /* Turn off minor gridlines */\n#define ONLY_GRAPH       0x40   /* use only graph */\n#define FORCE_RULES_LEGEND 0x80 /* force printing of HRULE and VRULE legend */\n\n#define FORCE_UNITS 0x100   /* mask for all FORCE_UNITS_* flags */\n#define FORCE_UNITS_SI 0x100    /* force use of SI units in Y axis (no effect in linear graph, SI instead of E in log graph) */\n\n#define FULL_SIZE_MODE     0x200    /* -width and -height indicate the total size of the image */\n#define NO_RRDTOOL_TAG 0x400  /* disable the rrdtool tag */\n#define ALLOW_MISSING_DS 0x800  /* missing DS is not fatal */\n\n#define gdes_fetch_key(x)  sprintf_alloc(\"%s:%d:%d:%d:%d\",x.rrd,x.cf,x.cf_reduce,x.start_orig,x.end_orig,x.step_orig)\n\nenum tmt_en { TMT_SECOND = 0, TMT_MINUTE, TMT_HOUR, TMT_DAY,\n    TMT_WEEK, TMT_MONTH, TMT_YEAR\n};\n\nenum grc_en { GRC_CANVAS = 0, GRC_BACK, GRC_SHADEA, GRC_SHADEB,\n    GRC_GRID, GRC_MGRID, GRC_FONT, GRC_ARROW, GRC_AXIS, GRC_FRAME, __GRC_END__\n};\n\n#define MGRIDWIDTH 0.6\n#define GRIDWIDTH  0.4\n\nenum gf_en { GF_PRINT = 0, GF_GPRINT, GF_COMMENT, GF_HRULE, GF_VRULE, GF_LINE,\n    GF_AREA,GF_GRAD, GF_STACK, GF_TICK, GF_TEXTALIGN,\n    GF_DEF, GF_CDEF, GF_VDEF, GF_SHIFT,\n    GF_XPORT, GF_XAXIS, GF_YAXIS\n};\n\nenum txa_en { TXA_LEFT = 0, TXA_RIGHT, TXA_CENTER, TXA_JUSTIFIED };\n\nenum vdef_op_en {\n    VDEF_MAXIMUM = 0    /* like the MAX in (G)PRINT */\n        , VDEF_MINIMUM  /* like the MIN in (G)PRINT */\n        , VDEF_AVERAGE  /* like the AVERAGE in (G)PRINT */\n        , VDEF_STDEV    /* the standard deviation */\n        , VDEF_PERCENT  /* Nth percentile */\n        , VDEF_TOTAL    /* average multiplied by time */\n        , VDEF_FIRST    /* first non-unknown value and time */\n        , VDEF_LAST     /* last  non-unknown value and time */\n        , VDEF_LSLSLOPE /* least squares line slope */\n        , VDEF_LSLINT   /* least squares line y_intercept */\n        , VDEF_LSLCORREL    /* least squares line correlation coefficient */\n        , VDEF_PERCENTNAN  /* Nth percentile ignoring NAN*/\n};\nenum text_prop_en { \n    TEXT_PROP_DEFAULT = 0,  /* default settings */\n    TEXT_PROP_TITLE,    /* properties for the title */\n    TEXT_PROP_AXIS,     /* for the numbers next to the axis */\n    TEXT_PROP_UNIT,     /* for the vertical unit description */\n    TEXT_PROP_LEGEND,   /* for the legend below the graph */\n    TEXT_PROP_WATERMARK, /* for the little text to the side of the graph */\n    TEXT_PROP_LAST\n};\n\nenum legend_pos{ NORTH = 0, WEST, SOUTH, EAST };\nenum legend_direction { TOP_DOWN = 0, BOTTOM_UP, BOTTOM_UP2 };\n\nenum gfx_if_en { IF_PNG = 0, IF_SVG, IF_EPS, IF_PDF, \n\t\t IF_XML=128, IF_CSV=129, IF_TSV=130, IF_SSV=131, IF_JSON=132,\n\t\t IF_XMLENUM=133, IF_JSONTIME=134\n};\nenum gfx_en { GFX_LINE = 0, GFX_AREA, GFX_TEXT };\nenum gfx_h_align_en { GFX_H_NULL = 0, GFX_H_LEFT, GFX_H_RIGHT, GFX_H_CENTER };\nenum gfx_v_align_en { GFX_V_NULL = 0, GFX_V_TOP, GFX_V_BOTTOM, GFX_V_CENTER };\n\nenum gfx_type_en {GTYPE_TIME=0,GTYPE_XY=1};\n\n/* cairo color components */\ntypedef struct gfx_color_t {\n    double    red;\n    double    green;\n    double    blue;\n    double    alpha;\n} gfx_color_t;\n\ntypedef struct keyvalue_t {\n  char* key;\n  char* value;\n  char* keyvalue;\n  int pos;\n  int flag;\n} keyvalue_t;\n\ntypedef struct keyint_t {\n  char*key;\n  int value;\n} keyint_t;\n\ntypedef struct parsedargs_t {\n  char *arg; /* copy of the parsed string - rewritten*/\n  const char *arg_orig; /* original argument */\n  int kv_cnt; /* number of key/value arguments */\n  keyvalue_t *kv_args; /* key value arguments */\n} parsedargs_t;\nvoid initParsedArguments(parsedargs_t*);\nvoid freeParsedArguments(parsedargs_t*);\nint addToArguments(parsedargs_t*, char*, char*, char*, int);\nint parseArguments(const char*, parsedargs_t*);\nvoid dumpKeyValue(char* ,keyvalue_t*);\nvoid dumpArguments(parsedargs_t*);\nchar* getKeyValueArgument(const char*, int, parsedargs_t*);\nint getMappedKeyValueArgument(const char*,int, parsedargs_t*,\n\t\t\t      int*,keyint_t**);\nint getLong(const char*,long *,char**,int);\nint getDouble(const char*,double *,char**);\nkeyvalue_t* getFirstUnusedArgument(int, parsedargs_t*);\nchar* checkUnusedValues(parsedargs_t*);\n\ntypedef struct text_prop_t {\n    double    size;\n    char      font[1024];\n    PangoFontDescription *font_desc;\n} text_prop_t;\n\n\ntypedef struct vdef_t {\n    enum vdef_op_en op;\n    double    param;    /* parameter for function, if applicable */\n    double    val;      /* resulting value */\n    time_t    when;     /* timestamp, if applicable */\n    int       never;    /* boolean, indicate that when value mean never */\n} vdef_t;\n\ntypedef struct xlab_t {\n    long      minsec;   /* minimum sec per pix */\n    long      length;   /* number of secs on the image */\n    enum tmt_en gridtm; /* grid interval in what ? */\n    long      gridst;   /* how many whats per grid */\n    enum tmt_en mgridtm;    /* label interval in what ? */\n    long      mgridst;  /* how many whats per label */\n    enum tmt_en labtm;  /* label interval in what ? */\n    long      labst;    /* how many whats per label */\n    long      precis;   /* label precision -> label placement */\n    char     *stst;     /* strftime string */\n} xlab_t;\n\ntypedef struct ygrid_scale_t {  /* y axis grid scaling info */\n    double    gridstep;\n    int       labfact;\n    char      labfmt[64];\n} ygrid_scale_t;\n\n/* sensible y label intervals ...*/\n\ntypedef struct ylab_t {\n    double    grid;     /* grid spacing */\n    int       lfac[4];  /* associated label spacing */\n} ylab_t;\n\n/* this structure describes the elements which can make up a graph.\n   because they are quite diverse, not all elements will use all the\n   possible parts of the structure. */\n#ifdef HAVE_SNPRINTF\n#define FMT_LEG_LEN 200\n#else\n#define FMT_LEG_LEN 2000\n#endif\n\n# define MAX_AXIS 4\n\ntypedef struct graph_desc_t {\n    enum gf_en gf;       /* graphing function */\n    int       stack;     /* boolean */\n    int       debug;     /* boolean */\n    int       skipscale; /* boolean */\n    char      vname[MAX_VNAME_LEN + 1]; /* name of the variable */\n    long      vidx;      /* gdes reference */\n    char      rrd[1024];    /* name of the rrd_file containing data */\n    char      ds_nam[DS_NAM_SIZE];  /* data source name */\n    long      ds;       /* data source number */\n    char      daemon[256];\n    enum cf_en cf;      /* consolidation function */\n    enum cf_en cf_reduce;   /* consolidation function for reduce_data() */\n    int        cf_reduce_set; /* is the cf_reduce option set */\n    struct gfx_color_t col, col2; /* graph color */\n\tdouble    gradheight;\n    char      format[FMT_LEG_LEN + 5];  /* format for PRINT AND GPRINT */\n    char      legend[FMT_LEG_LEN + 5];  /* legend */\n    int       strftm;   /* should the VDEF legend be formated with strftime */\n    double    leg_x, leg_y; /* location of legend */\n    double    yrule;    /* value for y rule line and for VDEF */\n    time_t    xrule;    /* time for x rule line and for VDEF */\n    vdef_t    vf;       /* instruction for VDEF function */\n    rpnp_t   *rpnp;     /* instructions for CDEF function */\n    char     *rpn;      /* string representation of rpn */\n\n    /* SHIFT implementation */\n    int       shidx;    /* gdes reference for offset (-1 --> constant) */\n    time_t    shval;    /* offset if shidx is -1 */\n    time_t    shift;    /* current shift applied */\n\n    /* description of data fetched for the graph element */\n    time_t    start, end;   /* timestaps for first and last data element */\n    time_t    start_orig, end_orig; /* timestaps for first and last data element */\n    unsigned long step; /* time between samples */\n    unsigned long step_orig;    /* time between samples */\n    unsigned long ds_cnt;   /* how many data sources are there in the fetch */\n    long      data_first;   /* first pointer to this data */\n    char    **ds_namv;  /* name of datasources  in the fetch. */\n    rrd_value_t *data;  /* the raw data drawn from the rrd */\n    rrd_value_t *p_data;    /* processed data, xsize elments */\n    double    linewidth;    /* linewideth */\n\n    /* dashed line stuff */\n    int       dash;     /* boolean, draw dashed line? */\n    double   *p_dashes; /* pointer do dash array which keeps the lengths of dashes */\n    int       ndash;    /* number of dash segments */\n    double    offset;   /* dash offset along the line */\n\n\n    enum txa_en txtalign;   /* change default alignment strategy for text */\n\n    /* the axis to use for this graph in x and y*/\n    int xaxisidx;\n    int yaxisidx;\n} graph_desc_t;\n\ntypedef struct image_desc_t {\n\n    /* configuration of graph */\n    char      graphfile[MAXPATH];   /* filename for graphic */\n    enum      gfx_type_en graph_type; /* type of the graph */\n    long      xsize, ysize; /* graph area size in pixels */\n    struct gfx_color_t graph_col[__GRC_END__];  /* real colors for the graph */\n    text_prop_t text_prop[TEXT_PROP_LAST];  /* text properties */\n    char      *ylegend; /* legend along the yaxis */\n    char      *title;   /* title for graph */\n    char      *watermark;   /* watermark for graph */\n    int       draw_x_grid;  /* no x-grid at all */\n    int       draw_y_grid;  /* no y-grid at all */\n    unsigned int draw_3d_border; /* size of border in pixels, 0 for off */\n    unsigned int dynamic_labels; /* pick the label shape according to the line drawn */\n    double    grid_dash_on, grid_dash_off;\n    xlab_t    xlab_user;    /* user defined labeling for xaxis */\n    char      *xlab_form;   /* format for the label on the xaxis */\n    double    second_axis_scale; /* relative to the first axis (0 to disable) */\n    double    second_axis_shift; /* how much is it shifted vs the first axis */\n    char      *second_axis_legend; /* label to put on the seond axis */\n    char      *second_axis_format; /* format for the numbers on the scond axis */    \n    char      *primary_axis_format; /* format for the numbers on the primary axis */\n    double    ygridstep;    /* user defined step for y grid */\n    int       ylabfact; /* every how many y grid shall a label be written ? */\n    double    tabwidth; /* tabwdith */\n    time_t    start, end;   /* what time does the graph cover */\n    unsigned long step; /* any preference for the default step ? */\n    rrd_value_t minval, maxval; /* extreme values in the data */\n    int       rigid;    /* do not expand range even with \n                           values outside */\n    ygrid_scale_t ygrid_scale;  /* calculated y axis grid info */\n    int       gridfit;  /* adjust y-axis range etc so all\n                           grindlines falls in integer pixel values */\n    char     *imginfo;  /* construct an <IMG ... tag and return \n                           as first retval */\n    enum gfx_if_en imgformat;   /* image format */\n    char     *daemon_addr;  /* rrdcached connection string */\n    int       lazy;     /* only update the image if there is\n                           reasonable probablility that the\n                           existing one is out of date */\n    int       slopemode;    /* connect the dots of the curve directly, not using a stair */\n    enum legend_pos legendposition; /* the position of the legend: north, west, south or east */\n    enum legend_direction legenddirection; /* The direction of the legend topdown or bottomup */\n    int       logarithmic;  /* scale the yaxis logarithmic */\n    double    force_scale_min;  /* Force a scale--min */\n    double    force_scale_max;  /* Force a scale--max */\n\n    /* status information */\n    int       with_markup;\n    long      xorigin, yorigin; /* where is (0,0) of the graph */\n    long      xOriginTitle, yOriginTitle; /* where is the origin of the title */\n    long      xOriginLegendY, yOriginLegendY; /* where is the origin of the y legend */\n    long      xOriginLegendY2, yOriginLegendY2; /* where is the origin of the second y legend */\n    long      xOriginLegend, yOriginLegend; /* where is the origin of the legend */\n    long      ximg, yimg;   /* total size of the image */\n    long      legendwidth, legendheight; /* the calculated height and width of the legend */\n    size_t    rendered_image_size;\n    double    zoom;\n    double    magfact;  /* numerical magnitude */\n    long      base;     /* 1000 or 1024 depending on what we graph */\n    char      symbol;   /* magnitude symbol for y-axis */\n    float     viewfactor;   /* how should the numbers on the y-axis be scaled for viewing ? */\n    int       unitsexponent;    /* 10*exponent for units on y-asis */\n    int       unitslength;  /* width of the yaxis labels */\n    int       forceleftspace;   /* do not kill the space to the left of the y-axis if there is no grid */\n\n    int       extra_flags;  /* flags for boolean options */\n    /* data elements */\n\n    unsigned char *rendered_image;\n    long      prt_c;    /* number of print elements */\n    long      gdes_c;   /* number of graphics elements */\n    graph_desc_t *gdes; /* points to an array of graph elements */\n    cairo_surface_t *surface;   /* graphics library */\n    cairo_t  *cr;       /* drawin context */\n    cairo_font_options_t *font_options; /* cairo font options */\n    cairo_antialias_t graph_antialias;  /* antialiasing for the graph */\n    PangoLayout *layout; /* the pango layout we use for writing fonts */\n    rrd_info_t *grinfo; /* root pointer to extra graph info */\n    rrd_info_t *grinfo_current; /* pointing to current entry */\n    GHashTable* gdef_map;  /* a map of all *def gdef entries for quick access */\n    GHashTable* rrd_map;  /* a map of all rrd files in use for gdef entries */\n} image_desc_t;\n\n/* Prototypes */\nint       xtr(\n    image_desc_t *,\n    time_t);\ndouble    ytr(\n    image_desc_t *,\n    double);\nenum gf_en gf_conv(\n    char *);\nenum gfx_if_en if_conv(\n    char *);\nenum gfx_type_en type_conv(\n    char *);\nenum tmt_en tmt_conv(\n    char *);\nenum grc_en grc_conv(\n    char *);\nenum text_prop_en text_prop_conv(\n    char *);\nint       im_free(\n    image_desc_t *);\nvoid      auto_scale(\n    image_desc_t *,\n    double *,\n    char **,\n    double *);\nvoid      si_unit(\n    image_desc_t *);\nvoid      expand_range(\n    image_desc_t *);\nvoid      apply_gridfit(\n    image_desc_t *);\nvoid      reduce_data(\n    enum cf_en,\n    unsigned long,\n    time_t *,\n    time_t *,\n    unsigned long *,\n    unsigned long *,\n    rrd_value_t **);\nint       data_fetch(\n    image_desc_t *);\nlong      lcd(\n    long *);\nint       data_calc(\n    image_desc_t *);\nint       data_proc(\n    image_desc_t *);\ntime_t    find_first_time(\n    time_t,\n    enum tmt_en,\n    long);\ntime_t    find_next_time(\n    time_t,\n    enum tmt_en,\n    long);\nint       print_calc(\n    image_desc_t *);\nint       leg_place(\n    image_desc_t *,\n    int);\nint       calc_horizontal_grid(\n    image_desc_t *);\nint       draw_horizontal_grid(\n    image_desc_t *);\nint       horizontal_log_grid(\n    image_desc_t *);\nvoid      vertical_grid(\n    image_desc_t *);\nvoid      axis_paint(\n    image_desc_t *);\nvoid      grid_paint(\n    image_desc_t *);\nint       lazy_check(\n    image_desc_t *);\nint       graph_paint(\n    image_desc_t *);\nint       graph_paint_timestring(\n                                image_desc_t *,int,int);\nint       graph_paint_xy(\n                        image_desc_t *,int,int);\nint       rrd_graph_xport(\n    image_desc_t *);\n\nint       graph_cairo_setup(\n    image_desc_t *);\nint       graph_cairo_finish(\n    image_desc_t *);\n\nint       gdes_alloc(\n    image_desc_t *);\nint       scan_for_col(\n    const char *const,\n    int,\n    char *const);\nvoid      rrd_graph_init(\n    image_desc_t *);\n\nvoid      time_clean(\n    char *result,\n    char *format);\n\nvoid      rrd_graph_options(\n    int,\n    char **,\n    image_desc_t *);\nvoid      rrd_graph_script(\n    int,\n    char **,\n    image_desc_t *,\n    int);\nint       rrd_graph_color(\n    image_desc_t *,\n    char *,\n    char *,\n    int);\nint       bad_format(\n    char *);\nint       bad_format_imginfo(\n    char *);\nint       vdef_parse(\n    struct graph_desc_t *,\n    const char *const);\nint       vdef_calc(\n    image_desc_t *,\n    int);\nint       vdef_percent_compar(\n    const void *,\n    const void *);\nint       graph_size_location(\n    image_desc_t *,\n    int);\n\n\n/* create a new line */\nvoid      gfx_line(\n    image_desc_t *im,\n    double X0,\n    double Y0,\n    double X1,\n    double Y1,\n    double width,\n    gfx_color_t color);\n\nvoid      gfx_dashed_line(\n    image_desc_t *im,\n    double X0,\n    double Y0,\n    double X1,\n    double Y1,\n    double width,\n    gfx_color_t color,\n    double dash_on,\n    double dash_off);\n\n/* create a new area */\nvoid      gfx_new_area(\n    image_desc_t *im,\n    double X0,\n    double Y0,\n    double X1,\n    double Y1,\n    double X2,\n    double Y2,\n    gfx_color_t color);\n\n/* add a point to a line or to an area */\nvoid      gfx_add_point(\n    image_desc_t *im,\n    double x,\n    double y);\n\n/* create a rect that has a gradient from color1 to color2 in height pixels \n * height > 0:\n * \t\tgradient starts at top and goes down a fixed number of pixels (fire style)\n * height < 0:\n * \t\tgradient starts at bottom and goes up a fixed number of pixels (constant style)\n * height == 0:\n * \t\tgradient is stretched between two points\n */\nvoid gfx_add_rect_fadey(\n    image_desc_t *im,\n    double x1,double y1,\n    double x2,double y2,\n\tdouble py,\n    gfx_color_t color1,\n\tgfx_color_t color2,\n\tdouble height);\n\t\t\t\t\n\n\n/* close current path so it ends at the same point as it started */\nvoid      gfx_close_path(\n    image_desc_t *im);\n\n\n/* create a text node */\nvoid      gfx_text(\n    image_desc_t *im,\n    double x,\n    double y,\n    gfx_color_t color,\n    PangoFontDescription *font_desc,\n    double tabwidth,\n    double angle,\n    enum gfx_h_align_en h_align,\n    enum gfx_v_align_en v_align,\n    const char *text);\n\n/* measure width of a text string */\ndouble    gfx_get_text_width(\n    image_desc_t *im,\n    double start,\n    PangoFontDescription *font_desc,\n    double tabwidth,\n    char *text);\n\n\n/* convert color */\ngfx_color_t gfx_hex_to_col(\n    long unsigned int);\n\nvoid      gfx_line_fit(\n    image_desc_t *im,\n    double *x,\n    double *y);\n\nvoid      gfx_area_fit(\n    image_desc_t *im,\n    double *x,\n    double *y);\n\n#endif\n\nvoid      grinfo_push(\n    image_desc_t *im,\n    char *key,\n    rrd_info_type_t type,    rrd_infoval_t value);\n\n\n"], "fixing_code": ["/****************************************************************************\n * RRDtool 1.4.3  Copyright by Tobi Oetiker, 1997-2010\n ****************************************************************************\n * rrd__graph.c  produce graphs from data in rrdfiles\n ****************************************************************************/\n\n\n#include <sys/stat.h>\n#include <glib.h>   // will use regex\n\n#ifdef WIN32\n#include \"strftime.h\"\n#endif\n\n#include \"rrd_strtod.h\"\n\n#include \"rrd_tool.h\"\n#include \"unused.h\"\n\n/* for basename */\n#ifdef HAVE_LIBGEN_H\n#  include <libgen.h>\n#else\n#include \"plbasename.h\"\n#endif\n\n#if defined(WIN32) && !defined(__CYGWIN__) && !defined(__CYGWIN32__)\n#include <io.h>\n#include <fcntl.h>\n#endif\n\n#include <time.h>\n\n#include <locale.h>\n\n#ifdef HAVE_LANGINFO_H\n#include <langinfo.h>\n#endif\n\n#include \"rrd_graph.h\"\n#include \"rrd_client.h\"\n\n/* some constant definitions */\n\n\n\n#ifndef RRD_DEFAULT_FONT\n/* there is special code later to pick Cour.ttf when running on windows */\n#define RRD_DEFAULT_FONT \"DejaVu Sans Mono,Bitstream Vera Sans Mono,monospace,Courier\"\n#endif\n\ntext_prop_t text_prop[] = {\n    {8.0, RRD_DEFAULT_FONT,NULL}\n    ,                   /* default */\n    {9.0, RRD_DEFAULT_FONT,NULL}\n    ,                   /* title */\n    {7.0, RRD_DEFAULT_FONT,NULL}\n    ,                   /* axis */\n    {8.0, RRD_DEFAULT_FONT,NULL}\n    ,                   /* unit */\n    {8.0, RRD_DEFAULT_FONT,NULL} /* legend */\n    ,\n    {5.5, RRD_DEFAULT_FONT,NULL} /* watermark */\n};\n\nchar week_fmt[128] = \"Week %V\";\n\nxlab_t    xlab[] = {\n    {0, 0, TMT_SECOND, 30, TMT_MINUTE, 5, TMT_MINUTE, 5, 0, \"%H:%M\"}\n    ,\n    {2, 0, TMT_MINUTE, 1, TMT_MINUTE, 5, TMT_MINUTE, 5, 0, \"%H:%M\"}\n    ,\n    {5, 0, TMT_MINUTE, 2, TMT_MINUTE, 10, TMT_MINUTE, 10, 0, \"%H:%M\"}\n    ,\n    {10, 0, TMT_MINUTE, 5, TMT_MINUTE, 20, TMT_MINUTE, 20, 0, \"%H:%M\"}\n    ,\n    {30, 0, TMT_MINUTE, 10, TMT_HOUR, 1, TMT_HOUR, 1, 0, \"%H:%M\"}\n    ,\n    {60, 0, TMT_MINUTE, 30, TMT_HOUR, 2, TMT_HOUR, 2, 0, \"%H:%M\"}\n    ,\n    {60, 24 * 3600, TMT_MINUTE, 30, TMT_HOUR, 2, TMT_HOUR, 6, 0, \"%a %H:%M\"}\n    ,\n    {180, 0, TMT_HOUR, 1, TMT_HOUR, 6, TMT_HOUR, 6, 0, \"%H:%M\"}\n    ,\n    {180, 24 * 3600, TMT_HOUR, 1, TMT_HOUR, 6, TMT_HOUR, 12, 0, \"%a %H:%M\"}\n    ,\n    /*{300,             0,   TMT_HOUR,3,    TMT_HOUR,12,   TMT_HOUR,12,    12*3600,\"%a %p\"},  this looks silly */\n    {600, 0, TMT_HOUR, 6, TMT_DAY, 1, TMT_DAY, 1, 24 * 3600, \"%a\"}\n    ,\n    {1200, 0, TMT_HOUR, 6, TMT_DAY, 1, TMT_DAY, 1, 24 * 3600, \"%d\"}\n    ,\n    {1800, 0, TMT_HOUR, 12, TMT_DAY, 1, TMT_DAY, 2, 24 * 3600, \"%a %d\"}\n    ,\n    {2400, 0, TMT_HOUR, 12, TMT_DAY, 1, TMT_DAY, 2, 24 * 3600, \"%a\"}\n    ,\n    {3600, 0, TMT_DAY, 1, TMT_WEEK, 1, TMT_WEEK, 1, 7 * 24 * 3600, week_fmt}\n    ,\n    {3 * 3600, 0, TMT_WEEK, 1, TMT_MONTH, 1, TMT_WEEK, 2, 7 * 24 * 3600, week_fmt}\n    ,\n    {6 * 3600, 0, TMT_MONTH, 1, TMT_MONTH, 1, TMT_MONTH, 1, 30 * 24 * 3600,\n     \"%b\"}\n    ,\n    {48 * 3600, 0, TMT_MONTH, 1, TMT_MONTH, 3, TMT_MONTH, 3, 30 * 24 * 3600,\n     \"%b\"}\n    ,\n    {315360, 0, TMT_MONTH, 3, TMT_YEAR, 1, TMT_YEAR, 1, 365 * 24 * 3600, \"%Y\"}\n    ,\n    {10 * 24 * 3600, 0, TMT_YEAR, 1, TMT_YEAR, 1, TMT_YEAR, 1,\n     365 * 24 * 3600, \"%y\"}\n    ,\n    {-1, 0, TMT_MONTH, 0, TMT_MONTH, 0, TMT_MONTH, 0, 0, \"\"}\n};\n\n/* sensible y label intervals ...*/\n\nylab_t    ylab[] = {\n    {0.1, {1, 2, 5, 10}\n     }\n    ,\n    {0.2, {1, 5, 10, 20}\n     }\n    ,\n    {0.5, {1, 2, 4, 10}\n     }\n    ,\n    {1.0, {1, 2, 5, 10}\n     }\n    ,\n    {2.0, {1, 5, 10, 20}\n     }\n    ,\n    {5.0, {1, 2, 4, 10}\n     }\n    ,\n    {10.0, {1, 2, 5, 10}\n     }\n    ,\n    {20.0, {1, 5, 10, 20}\n     }\n    ,\n    {50.0, {1, 2, 4, 10}\n     }\n    ,\n    {100.0, {1, 2, 5, 10}\n     }\n    ,\n    {200.0, {1, 5, 10, 20}\n     }\n    ,\n    {500.0, {1, 2, 4, 10}\n     }\n    ,\n    {0.0, {0, 0, 0, 0}\n     }\n};\n\n\ngfx_color_t graph_col[] =   /* default colors */\n{\n    {1.00, 1.00, 1.00, 1.00},   /* canvas     */\n    {0.95, 0.95, 0.95, 1.00},   /* background */\n    {0.81, 0.81, 0.81, 1.00},   /* shade A    */\n    {0.62, 0.62, 0.62, 1.00},   /* shade B    */\n    {0.56, 0.56, 0.56, 0.75},   /* grid       */\n    {0.87, 0.31, 0.31, 0.60},   /* major grid */\n    {0.00, 0.00, 0.00, 1.00},   /* font       */\n    {0.50, 0.12, 0.12, 1.00},   /* arrow      */\n    {0.12, 0.12, 0.12, 1.00},   /* axis       */\n    {0.00, 0.00, 0.00, 1.00}    /* frame      */\n};\n\n\n/* #define DEBUG */\n\n#ifdef DEBUG\n# define DPRINT(x)    (void)(printf x, printf(\"\\n\"))\n#else\n# define DPRINT(x)\n#endif\n\n\n/* initialize with xtr(im,0); */\nint xtr(\n    image_desc_t *im,\n    time_t mytime)\n{\n    static double pixie;\n\n    if (mytime == 0) {\n        pixie = (double) im->xsize / (double) (im->end - im->start);\n        return im->xorigin;\n    }\n    return (int) ((double) im->xorigin + pixie * (mytime - im->start));\n}\n\n/* translate data values into y coordinates */\ndouble ytr(\n    image_desc_t *im,\n    double value)\n{\n    static double pixie;\n    double    yval;\n\n    if (isnan(value)) {\n        if (!im->logarithmic)\n            pixie = (double) im->ysize / (im->maxval - im->minval);\n        else\n            pixie =\n                (double) im->ysize / (log10(im->maxval) - log10(im->minval));\n        yval = im->yorigin;\n    } else if (!im->logarithmic) {\n        yval = im->yorigin - pixie * (value - im->minval);\n    } else {\n        if (value < im->minval) {\n            yval = im->yorigin;\n        } else {\n            yval = im->yorigin - pixie * (log10(value) - log10(im->minval));\n        }\n    }\n    return yval;\n}\n\n\n\n/* conversion function for symbolic entry names */\n\n\n#define conv_if(VV,VVV) \\\n   if (strcmp(#VV, string) == 0) return VVV ;\n\nenum gf_en gf_conv(\n    char *string)\n{\n\n    conv_if(PRINT, GF_PRINT);\n    conv_if(GPRINT, GF_GPRINT);\n    conv_if(COMMENT, GF_COMMENT);\n    conv_if(HRULE, GF_HRULE);\n    conv_if(VRULE, GF_VRULE);\n    conv_if(LINE, GF_LINE);\n    conv_if(AREA, GF_AREA);\n\tconv_if(GRAD, GF_GRAD);\n    conv_if(STACK, GF_STACK);\n    conv_if(TICK, GF_TICK);\n    conv_if(TEXTALIGN, GF_TEXTALIGN);\n    conv_if(DEF, GF_DEF);\n    conv_if(CDEF, GF_CDEF);\n    conv_if(VDEF, GF_VDEF);\n    conv_if(XPORT, GF_XPORT);\n    conv_if(SHIFT, GF_SHIFT);\n\n    return (enum gf_en)(-1);\n}\n\nenum gfx_if_en if_conv(\n    char *string)\n{\n\n    conv_if(PNG, IF_PNG);\n    conv_if(SVG, IF_SVG);\n    conv_if(EPS, IF_EPS);\n    conv_if(PDF, IF_PDF);\n    conv_if(XML, IF_XML);\n    conv_if(XMLENUM, IF_XMLENUM);\n    conv_if(CSV, IF_CSV);\n    conv_if(TSV, IF_TSV);\n    conv_if(SSV, IF_SSV);\n    conv_if(JSON, IF_JSON);\n    conv_if(JSONTIME, IF_JSONTIME);\n\n    return (enum gfx_if_en)(-1);\n}\n\nenum gfx_type_en type_conv(\n    char *string)\n{\n    conv_if(TIME , GTYPE_TIME);\n    conv_if(XY, GTYPE_XY);\n    return (enum gfx_type_en)(-1);\n}\n\nenum tmt_en tmt_conv(\n    char *string)\n{\n\n    conv_if(SECOND, TMT_SECOND);\n    conv_if(MINUTE, TMT_MINUTE);\n    conv_if(HOUR, TMT_HOUR);\n    conv_if(DAY, TMT_DAY);\n    conv_if(WEEK, TMT_WEEK);\n    conv_if(MONTH, TMT_MONTH);\n    conv_if(YEAR, TMT_YEAR);\n    return (enum tmt_en)(-1);\n}\n\nenum grc_en grc_conv(\n    char *string)\n{\n\n    conv_if(BACK, GRC_BACK);\n    conv_if(CANVAS, GRC_CANVAS);\n    conv_if(SHADEA, GRC_SHADEA);\n    conv_if(SHADEB, GRC_SHADEB);\n    conv_if(GRID, GRC_GRID);\n    conv_if(MGRID, GRC_MGRID);\n    conv_if(FONT, GRC_FONT);\n    conv_if(ARROW, GRC_ARROW);\n    conv_if(AXIS, GRC_AXIS);\n    conv_if(FRAME, GRC_FRAME);\n\n    return (enum grc_en)(-1);\n}\n\nenum text_prop_en text_prop_conv(\n    char *string)\n{\n\n    conv_if(DEFAULT, TEXT_PROP_DEFAULT);\n    conv_if(TITLE, TEXT_PROP_TITLE);\n    conv_if(AXIS, TEXT_PROP_AXIS);\n    conv_if(UNIT, TEXT_PROP_UNIT);\n    conv_if(LEGEND, TEXT_PROP_LEGEND);\n    conv_if(WATERMARK, TEXT_PROP_WATERMARK);\n    return (enum text_prop_en)(-1);\n}\n\n\n#undef conv_if\n\nint im_free(\n    image_desc_t *im)\n{\n    unsigned long i, ii;\n    cairo_status_t status = (cairo_status_t) 0;\n\n    if (im == NULL)\n        return 0;\n\n    if (im->daemon_addr != NULL)\n      free(im->daemon_addr);\n\n    if (im->gdef_map){\n        g_hash_table_destroy(im->gdef_map);        \n\t}\n\n\tif (im->rrd_map){\n\t\tg_hash_table_destroy(im->rrd_map);\n\t}\n\t\n\n    for (i = 0; i < (unsigned) im->gdes_c; i++) {\n        if (im->gdes[i].data_first) {\n            /* careful here, because a single pointer can occur several times */\n            free(im->gdes[i].data);\n            if (im->gdes[i].ds_namv) {\n                for (ii = 0; ii < im->gdes[i].ds_cnt; ii++)\n                    free(im->gdes[i].ds_namv[ii]);\n                free(im->gdes[i].ds_namv);\n            }\n        }\n        /* free allocated memory used for dashed lines */\n        if (im->gdes[i].p_dashes != NULL)\n            free(im->gdes[i].p_dashes);\n\n        free(im->gdes[i].p_data);\n        free(im->gdes[i].rpnp);\n    }\n    free(im->gdes);\n\n    for (i = 0; i < DIM(text_prop);i++){\n        pango_font_description_free(im->text_prop[i].font_desc);\n        im->text_prop[i].font_desc = NULL;\n    }\n\n    if (im->font_options)\n        cairo_font_options_destroy(im->font_options);\n\n    if (im->surface)\n        cairo_surface_destroy(im->surface);\n\n    if (im->cr) {\n        status = cairo_status(im->cr);\n        cairo_destroy(im->cr);\n    }\n\n    if (status)\n        fprintf(stderr, \"OOPS: Cairo has issues it can't even die: %s\\n\",\n                cairo_status_to_string(status));\n\n\n    if (im->rendered_image) {\n        free(im->rendered_image);\n    }\n\n    if (im->layout) {\n        g_object_unref(im->layout);\n    }\n\n\tif (im->ylegend)\n\t\tfree(im->ylegend);\n\tif (im->title)\n\t\tfree(im->title);\n\tif (im->watermark)\n\t\tfree(im->watermark);\n\tif (im->xlab_form)\n\t\tfree(im->xlab_form);\n\tif (im->second_axis_legend)\n\t\tfree(im->second_axis_legend);\n\tif (im->second_axis_format)\n\t\tfree(im->second_axis_format);\n\tif (im->primary_axis_format)\n\t\tfree(im->primary_axis_format);\n\n    return 0;\n}\n\n/* find SI magnitude symbol for the given number*/\nvoid auto_scale(\n    image_desc_t *im,   /* image description */\n    double *value,\n    char **symb_ptr,\n    double *magfact)\n{\n\n    char     *symbol[] = { \"a\", /* 10e-18 Atto */\n        \"f\",            /* 10e-15 Femto */\n        \"p\",            /* 10e-12 Pico */\n        \"n\",            /* 10e-9  Nano */\n        \"u\",            /* 10e-6  Micro */\n        \"m\",            /* 10e-3  Milli */\n        \" \",            /* Base */\n        \"k\",            /* 10e3   Kilo */\n        \"M\",            /* 10e6   Mega */\n        \"G\",            /* 10e9   Giga */\n        \"T\",            /* 10e12  Tera */\n        \"P\",            /* 10e15  Peta */\n        \"E\"\n    };                  /* 10e18  Exa */\n\n    int       symbcenter = 6;\n    int       sindex;\n\n    if (*value == 0.0 || isnan(*value)) {\n        sindex = 0;\n        *magfact = 1.0;\n    } else {\n        sindex = floor(log(fabs(*value)) / log((double) im->base));\n        *magfact = pow((double) im->base, (double) sindex);\n        (*value) /= (*magfact);\n    }\n    if (sindex <= symbcenter && sindex >= -symbcenter) {\n        (*symb_ptr) = symbol[sindex + symbcenter];\n    } else {\n        (*symb_ptr) = \"?\";\n    }\n}\n\n/* power prefixes */\n\nstatic char si_symbol[] = {\n    'y',                /* 10e-24 Yocto */\n    'z',                /* 10e-21 Zepto */\n    'a',                /* 10e-18 Atto */\n    'f',                /* 10e-15 Femto */\n    'p',                /* 10e-12 Pico */\n    'n',                /* 10e-9  Nano */\n    'u',                /* 10e-6  Micro */\n    'm',                /* 10e-3  Milli */\n    ' ',                /* Base */\n    'k',                /* 10e3   Kilo */\n    'M',                /* 10e6   Mega */\n    'G',                /* 10e9   Giga */\n    'T',                /* 10e12  Tera */\n    'P',                /* 10e15  Peta */\n    'E',                /* 10e18  Exa */\n    'Z',                /* 10e21  Zeta */\n    'Y'                 /* 10e24  Yotta */\n};\nstatic const int si_symbcenter = 8;\n\n/* find SI magnitude symbol for the numbers on the y-axis*/\nvoid si_unit(\n    image_desc_t *im    /* image description */\n    )\n{\n\n    double    digits, viewdigits = 0;\n\n    digits =\n        floor(log(max(fabs(im->minval), fabs(im->maxval))) /\n              log((double) im->base));\n\n    if (im->unitsexponent != 9999) {\n        /* unitsexponent = 9, 6, 3, 0, -3, -6, -9, etc */\n        viewdigits = floor((double)(im->unitsexponent / 3));\n    } else {\n        viewdigits = digits;\n    }\n\n    im->magfact = pow((double) im->base, digits);\n\n#ifdef DEBUG\n    printf(\"digits %6.3f  im->magfact %6.3f\\n\", digits, im->magfact);\n#endif\n\n    im->viewfactor = im->magfact / pow((double) im->base, viewdigits);\n\n    if (((viewdigits + si_symbcenter) < sizeof(si_symbol)) &&\n        ((viewdigits + si_symbcenter) >= 0))\n        im->symbol = si_symbol[(int) viewdigits + si_symbcenter];\n    else\n        im->symbol = '?';\n}\n\n/*  move min and max values around to become sensible */\n\nvoid expand_range(\n    image_desc_t *im)\n{\n    double    sensiblevalues[] = { 1000.0, 900.0, 800.0, 750.0, 700.0,\n        600.0, 500.0, 400.0, 300.0, 250.0,\n        200.0, 125.0, 100.0, 90.0, 80.0,\n        75.0, 70.0, 60.0, 50.0, 40.0, 30.0,\n        25.0, 20.0, 10.0, 9.0, 8.0,\n        7.0, 6.0, 5.0, 4.0, 3.5, 3.0,\n        2.5, 2.0, 1.8, 1.5, 1.2, 1.0,\n        0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1, 0.0, -1\n    };\n\n    double    scaled_min, scaled_max;\n    double    adj;\n    int       i;\n\n\n\n#ifdef DEBUG\n    printf(\"Min: %6.2f Max: %6.2f MagFactor: %6.2f\\n\",\n           im->minval, im->maxval, im->magfact);\n#endif\n\n    if (isnan(im->ygridstep)) {\n        if (im->extra_flags & ALTAUTOSCALE) {\n            /* measure the amplitude of the function. Make sure that\n               graph boundaries are slightly higher then max/min vals\n               so we can see amplitude on the graph */\n            double    delt, fact;\n\n            delt = im->maxval - im->minval;\n            adj = delt * 0.1;\n            fact = 2.0 * pow(10.0,\n                             floor(log10\n                                   (max(fabs(im->minval), fabs(im->maxval)) /\n                                    im->magfact)) - 2);\n            if (delt < fact) {\n                adj = (fact - delt) * 0.55;\n#ifdef DEBUG\n                printf\n                    (\"Min: %6.2f Max: %6.2f delt: %6.2f fact: %6.2f adj: %6.2f\\n\",\n                     im->minval, im->maxval, delt, fact, adj);\n#endif\n            }\n            im->minval -= adj;\n            im->maxval += adj;\n        } else if (im->extra_flags & ALTAUTOSCALE_MIN) {\n            /* measure the amplitude of the function. Make sure that\n               graph boundaries are slightly lower than min vals\n               so we can see amplitude on the graph */\n            adj = (im->maxval - im->minval) * 0.1;\n            im->minval -= adj;\n        } else if (im->extra_flags & ALTAUTOSCALE_MAX) {\n            /* measure the amplitude of the function. Make sure that\n               graph boundaries are slightly higher than max vals\n               so we can see amplitude on the graph */\n            adj = (im->maxval - im->minval) * 0.1;\n            im->maxval += adj;\n        } else {\n            scaled_min = im->minval / im->magfact;\n            scaled_max = im->maxval / im->magfact;\n\n            for (i = 1; sensiblevalues[i] > 0; i++) {\n                if (sensiblevalues[i - 1] >= scaled_min &&\n                    sensiblevalues[i] <= scaled_min)\n                    im->minval = sensiblevalues[i] * (im->magfact);\n\n                if (-sensiblevalues[i - 1] <= scaled_min &&\n                    -sensiblevalues[i] >= scaled_min)\n                    im->minval = -sensiblevalues[i - 1] * (im->magfact);\n\n                if (sensiblevalues[i - 1] >= scaled_max &&\n                    sensiblevalues[i] <= scaled_max)\n                    im->maxval = sensiblevalues[i - 1] * (im->magfact);\n\n                if (-sensiblevalues[i - 1] <= scaled_max &&\n                    -sensiblevalues[i] >= scaled_max)\n                    im->maxval = -sensiblevalues[i] * (im->magfact);\n            }\n        }\n    } else {\n        /* adjust min and max to the grid definition if there is one */\n        im->minval = (double) im->ylabfact * im->ygridstep *\n            floor(im->minval / ((double) im->ylabfact * im->ygridstep));\n        im->maxval = (double) im->ylabfact * im->ygridstep *\n            ceil(im->maxval / ((double) im->ylabfact * im->ygridstep));\n    }\n\n#ifdef DEBUG\n    fprintf(stderr, \"SCALED Min: %6.2f Max: %6.2f Factor: %6.2f\\n\",\n            im->minval, im->maxval, im->magfact);\n#endif\n}\n\n\nvoid apply_gridfit(\n    image_desc_t *im)\n{\n    if (isnan(im->minval) || isnan(im->maxval))\n        return;\n    ytr(im, DNAN);\n    if (im->logarithmic) {\n        double    ya, yb, ypix, ypixfrac;\n        double    log10_range = log10(im->maxval) - log10(im->minval);\n\n        ya = pow((double) 10, floor(log10(im->minval)));\n        while (ya < im->minval)\n            ya *= 10;\n        if (ya > im->maxval)\n            return;     /* don't have y=10^x gridline */\n        yb = ya * 10;\n        if (yb <= im->maxval) {\n            /* we have at least 2 y=10^x gridlines.\n               Make sure distance between them in pixels\n               are an integer by expanding im->maxval */\n            double    y_pixel_delta = ytr(im, ya) - ytr(im, yb);\n            double    factor = y_pixel_delta / floor(y_pixel_delta);\n            double    new_log10_range = factor * log10_range;\n            double    new_ymax_log10 = log10(im->minval) + new_log10_range;\n\n            im->maxval = pow(10, new_ymax_log10);\n            ytr(im, DNAN);  /* reset precalc */\n            log10_range = log10(im->maxval) - log10(im->minval);\n        }\n        /* make sure first y=10^x gridline is located on\n           integer pixel position by moving scale slightly\n           downwards (sub-pixel movement) */\n        ypix = ytr(im, ya) + im->ysize; /* add im->ysize so it always is positive */\n        ypixfrac = ypix - floor(ypix);\n        if (ypixfrac > 0 && ypixfrac < 1) {\n            double    yfrac = ypixfrac / im->ysize;\n\n            im->minval = pow(10, log10(im->minval) - yfrac * log10_range);\n            im->maxval = pow(10, log10(im->maxval) - yfrac * log10_range);\n            ytr(im, DNAN);  /* reset precalc */\n        }\n    } else {\n        /* Make sure we have an integer pixel distance between\n           each minor gridline */\n        double    ypos1 = ytr(im, im->minval);\n        double    ypos2 = ytr(im, im->minval + im->ygrid_scale.gridstep);\n        double    y_pixel_delta = ypos1 - ypos2;\n        double    factor = y_pixel_delta / floor(y_pixel_delta);\n        double    new_range = factor * (im->maxval - im->minval);\n        double    gridstep = im->ygrid_scale.gridstep;\n        double    minor_y, minor_y_px, minor_y_px_frac;\n\n        if (im->maxval > 0.0)\n            im->maxval = im->minval + new_range;\n        else\n            im->minval = im->maxval - new_range;\n        ytr(im, DNAN);  /* reset precalc */\n        /* make sure first minor gridline is on integer pixel y coord */\n        minor_y = gridstep * floor(im->minval / gridstep);\n        while (minor_y < im->minval)\n            minor_y += gridstep;\n        minor_y_px = ytr(im, minor_y) + im->ysize;  /* ensure > 0 by adding ysize */\n        minor_y_px_frac = minor_y_px - floor(minor_y_px);\n        if (minor_y_px_frac > 0 && minor_y_px_frac < 1) {\n            double    yfrac = minor_y_px_frac / im->ysize;\n            double    range = im->maxval - im->minval;\n\n            im->minval = im->minval - yfrac * range;\n            im->maxval = im->maxval - yfrac * range;\n            ytr(im, DNAN);  /* reset precalc */\n        }\n        calc_horizontal_grid(im);   /* recalc with changed im->maxval */\n    }\n}\n\n/* reduce data reimplementation by Alex */\n\nvoid reduce_data(\n    enum cf_en cf,      /* which consolidation function ? */\n    unsigned long cur_step, /* step the data currently is in */\n    time_t *start,      /* start, end and step as requested ... */\n    time_t *end,        /* ... by the application will be   ... */\n    unsigned long *step,    /* ... adjusted to represent reality    */\n    unsigned long *ds_cnt,  /* number of data sources in file */\n    rrd_value_t **data)\n{                       /* two dimensional array containing the data */\n    int       i, reduce_factor = ceil((double) (*step) / (double) cur_step);\n    unsigned long col, dst_row, row_cnt, start_offset, end_offset, skiprows =\n        0;\n    rrd_value_t *srcptr, *dstptr;\n\n    (*step) = cur_step * reduce_factor; /* set new step size for reduced data */\n    dstptr = *data;\n    srcptr = *data;\n    row_cnt = ((*end) - (*start)) / cur_step;\n\n#ifdef DEBUG\n#define DEBUG_REDUCE\n#endif\n#ifdef DEBUG_REDUCE\n    printf(\"Reducing %lu rows with factor %i time %lu to %lu, step %lu\\n\",\n           row_cnt, reduce_factor, *start, *end, cur_step);\n    for (col = 0; col < row_cnt; col++) {\n        printf(\"time %10lu: \", *start + (col + 1) * cur_step);\n        for (i = 0; i < *ds_cnt; i++)\n            printf(\" %8.2e\", srcptr[*ds_cnt * col + i]);\n        printf(\"\\n\");\n    }\n#endif\n\n    /* We have to combine [reduce_factor] rows of the source\n     ** into one row for the destination.  Doing this we also\n     ** need to take care to combine the correct rows.  First\n     ** alter the start and end time so that they are multiples\n     ** of the new step time.  We cannot reduce the amount of\n     ** time so we have to move the end towards the future and\n     ** the start towards the past.\n     */\n    end_offset = (*end) % (*step);\n    start_offset = (*start) % (*step);\n\n    /* If there is a start offset (which cannot be more than\n     ** one destination row), skip the appropriate number of\n     ** source rows and one destination row.  The appropriate\n     ** number is what we do know (start_offset/cur_step) of\n     ** the new interval (*step/cur_step aka reduce_factor).\n     */\n#ifdef DEBUG_REDUCE\n    printf(\"start_offset: %lu  end_offset: %lu\\n\", start_offset, end_offset);\n    printf(\"row_cnt before:  %lu\\n\", row_cnt);\n#endif\n    if (start_offset) {\n        (*start) = (*start) - start_offset;\n        skiprows = reduce_factor - start_offset / cur_step;\n        srcptr += skiprows * *ds_cnt;\n        for (col = 0; col < (*ds_cnt); col++)\n            *dstptr++ = DNAN;\n        row_cnt -= skiprows;\n    }\n#ifdef DEBUG_REDUCE\n    printf(\"row_cnt between: %lu\\n\", row_cnt);\n#endif\n\n    /* At the end we have some rows that are not going to be\n     ** used, the amount is end_offset/cur_step\n     */\n    if (end_offset) {\n        (*end) = (*end) - end_offset + (*step);\n        skiprows = end_offset / cur_step;\n        row_cnt -= skiprows;\n    }\n#ifdef DEBUG_REDUCE\n    printf(\"row_cnt after:   %lu\\n\", row_cnt);\n#endif\n\n/* Sanity check: row_cnt should be multiple of reduce_factor */\n/* if this gets triggered, something is REALLY WRONG ... we die immediately */\n\n    if (row_cnt % reduce_factor) {\n        printf(\"SANITY CHECK: %lu rows cannot be reduced by %i \\n\",\n               row_cnt, reduce_factor);\n        printf(\"BUG in reduce_data()\\n\");\n        exit(1);\n    }\n\n    /* Now combine reduce_factor intervals at a time\n     ** into one interval for the destination.\n     */\n\n    for (dst_row = 0; (long int) row_cnt >= reduce_factor; dst_row++) {\n        for (col = 0; col < (*ds_cnt); col++) {\n            rrd_value_t newval = DNAN;\n            unsigned long validval = 0;\n\n            for (i = 0; i < reduce_factor; i++) {\n                if (isnan(srcptr[i * (*ds_cnt) + col])) {\n                    continue;\n                }\n                validval++;\n                if (isnan(newval))\n                    newval = srcptr[i * (*ds_cnt) + col];\n                else {\n                    switch (cf) {\n                    case CF_HWPREDICT:\n                    case CF_MHWPREDICT:\n                    case CF_DEVSEASONAL:\n                    case CF_DEVPREDICT:\n                    case CF_SEASONAL:\n                    case CF_AVERAGE:\n                        newval += srcptr[i * (*ds_cnt) + col];\n                        break;\n                    case CF_MINIMUM:\n                        newval = min(newval, srcptr[i * (*ds_cnt) + col]);\n                        break;\n                    case CF_FAILURES:\n                        /* an interval contains a failure if any subintervals contained a failure */\n                    case CF_MAXIMUM:\n                        newval = max(newval, srcptr[i * (*ds_cnt) + col]);\n                        break;\n                    case CF_LAST:\n                        newval = srcptr[i * (*ds_cnt) + col];\n                        break;\n                    }\n                }\n            }\n            if (validval == 0) {\n                newval = DNAN;\n            } else {\n                switch (cf) {\n                case CF_HWPREDICT:\n                case CF_MHWPREDICT:\n                case CF_DEVSEASONAL:\n                case CF_DEVPREDICT:\n                case CF_SEASONAL:\n                case CF_AVERAGE:\n                    newval /= validval;\n                    break;\n                case CF_MINIMUM:\n                case CF_FAILURES:\n                case CF_MAXIMUM:\n                case CF_LAST:\n                    break;\n                }\n            }\n            *dstptr++ = newval;\n        }\n        srcptr += (*ds_cnt) * reduce_factor;\n        row_cnt -= reduce_factor;\n    }\n    /* If we had to alter the endtime, we didn't have enough\n     ** source rows to fill the last row. Fill it with NaN.\n     */\n    if (end_offset)\n        for (col = 0; col < (*ds_cnt); col++)\n            *dstptr++ = DNAN;\n#ifdef DEBUG_REDUCE\n    row_cnt = ((*end) - (*start)) / *step;\n    srcptr = *data;\n    printf(\"Done reducing. Currently %lu rows, time %lu to %lu, step %lu\\n\",\n           row_cnt, *start, *end, *step);\n    for (col = 0; col < row_cnt; col++) {\n        printf(\"time %10lu: \", *start + (col + 1) * (*step));\n        for (i = 0; i < *ds_cnt; i++)\n            printf(\" %8.2e\", srcptr[*ds_cnt * col + i]);\n        printf(\"\\n\");\n    }\n#endif\n}\n\n\n/* get the data required for the graphs from the\n   relevant rrds ... */\n\nint data_fetch(\n    image_desc_t *im)\n{\n    int       i, ii;\n    /* pull the data from the rrd files ... */\n    for (i = 0; i < (int) im->gdes_c; i++) {\n        /* only GF_DEF elements fetch data */\n        if (im->gdes[i].gf != GF_DEF)\n            continue;\n\n        /* do we have it already ? */\n        gpointer value;\n        char *key = gdes_fetch_key(im->gdes[i]);\n        gboolean ok = g_hash_table_lookup_extended(im->rrd_map,key,NULL,&value);\n        free(key);\n        if (ok){\n            ii = GPOINTER_TO_INT(value);\n            im->gdes[i].start = im->gdes[ii].start;\n            im->gdes[i].end = im->gdes[ii].end;\n            im->gdes[i].step = im->gdes[ii].step;\n            im->gdes[i].ds_cnt = im->gdes[ii].ds_cnt;\n            im->gdes[i].ds_namv = im->gdes[ii].ds_namv;\n            im->gdes[i].data = im->gdes[ii].data;\n            im->gdes[i].data_first = 0;\n        } else {\n            unsigned long ft_step = im->gdes[i].step;   /* ft_step will record what we got from fetch */\n            const char *rrd_daemon;\n            int status;\n\n            if (im->gdes[i].daemon[0] != 0)\n                rrd_daemon = im->gdes[i].daemon;\n            else\n                rrd_daemon = im->daemon_addr;\n\n            /* \"daemon\" may be NULL. ENV_RRDCACHED_ADDRESS is evaluated in that\n             * case. If \"daemon\" holds the same value as in the previous\n             * iteration, no actual new connection is established - the\n             * existing connection is re-used. */\n            rrdc_connect (rrd_daemon);\n\n            /* If connecting was successfull, use the daemon to query the data.\n             * If there is no connection, for example because no daemon address\n             * was specified, (try to) use the local file directly. */\n            if (rrdc_is_connected (rrd_daemon))\n            {\n                status = rrdc_fetch (im->gdes[i].rrd,\n                        cf_to_string (im->gdes[i].cf),\n                        &im->gdes[i].start,\n                        &im->gdes[i].end,\n                        &ft_step,\n                        &im->gdes[i].ds_cnt,\n                        &im->gdes[i].ds_namv,\n                        &im->gdes[i].data);\n                if (status != 0) {\n                    if (im->extra_flags & ALLOW_MISSING_DS) {\n                        rrd_clear_error();\n                        if (rrd_fetch_empty(&im->gdes[i].start,\n                                            &im->gdes[i].end,\n                                            &ft_step,\n                                            &im->gdes[i].ds_cnt,\n                                            im->gdes[i].ds_nam,\n                                            &im->gdes[i].ds_namv,\n                                            &im->gdes[i].data) == -1)\n                            return -1;\n                    } else return (status);\n                }\n            }\n            else\n            {\n                if ((rrd_fetch_fn(im->gdes[i].rrd,\n                                im->gdes[i].cf,\n                                &im->gdes[i].start,\n                                &im->gdes[i].end,\n                                &ft_step,\n                                &im->gdes[i].ds_cnt,\n                                &im->gdes[i].ds_namv,\n                                &im->gdes[i].data)) == -1) {\n                    if (im->extra_flags & ALLOW_MISSING_DS) {\n                        /* Unable to fetch data, assume fake data */\n                        rrd_clear_error();\n                        if (rrd_fetch_empty(&im->gdes[i].start,\n                                            &im->gdes[i].end,\n                                            &ft_step,\n                                            &im->gdes[i].ds_cnt,\n                                            im->gdes[i].ds_nam,\n                                            &im->gdes[i].ds_namv,\n                                            &im->gdes[i].data) == -1)\n                            return -1;\n                    } else return -1;\n                }\n            }\n            im->gdes[i].data_first = 1;\n\n            /* must reduce to at least im->step\n               otherwhise we end up with more data than we can handle in the \n               chart and visibility of data will be random */            \n            im->gdes[i].step = max(im->gdes[i].step,im->step);\n            if (ft_step < im->gdes[i].step) {\n                \n                reduce_data(im->gdes[i].cf_reduce_set ? im->gdes[i].cf_reduce : im->gdes[i].cf,\n                            ft_step,\n                            &im->gdes[i].start,\n                            &im->gdes[i].end,\n                            &im->gdes[i].step,\n                            &im->gdes[i].ds_cnt, &im->gdes[i].data);\n            } else {\n                im->gdes[i].step = ft_step;\n            }\n        }\n\n        /* lets see if the required data source is really there */\n        for (ii = 0; ii < (int) im->gdes[i].ds_cnt; ii++) {\n            if (strcmp(im->gdes[i].ds_namv[ii], im->gdes[i].ds_nam) == 0) {\n                im->gdes[i].ds = ii;\n            }\n        }\n        if (im->gdes[i].ds == -1) {\n            rrd_set_error(\"No DS called '%s' in '%s'\",\n                          im->gdes[i].ds_nam, im->gdes[i].rrd);\n            return -1;\n        }\n        // remember that we already got this one\n        g_hash_table_insert(im->rrd_map,gdes_fetch_key(im->gdes[i]),GINT_TO_POINTER(i));\n    }\n    return 0;\n}\n\n/* evaluate the expressions in the CDEF functions */\n\n/*************************************************************\n * CDEF stuff\n *************************************************************/\n\n\n/* find the greatest common divisor for all the numbers\n   in the 0 terminated num array */\nlong lcd(\n    long *num)\n{\n    long      rest;\n    int       i;\n\n    for (i = 0; num[i + 1] != 0; i++) {\n        do {\n            rest = num[i] % num[i + 1];\n            num[i] = num[i + 1];\n            num[i + 1] = rest;\n        } while (rest != 0);\n        num[i + 1] = num[i];\n    }\n/*    return i==0?num[i]:num[i-1]; */\n    return num[i];\n}\n\n\n/* run the rpn calculator on all the VDEF and CDEF arguments */\nint data_calc(\n    image_desc_t *im)\n{\n\n    int       gdi;\n    int       dataidx;\n    long     *steparray, rpi;\n    int       stepcnt;\n    time_t    now;\n    rpnstack_t rpnstack;\n    rpnp_t   *rpnp;\n\n    rpnstack_init(&rpnstack);\n\n    for (gdi = 0; gdi < im->gdes_c; gdi++) {\n        /* Look for GF_VDEF and GF_CDEF in the same loop,\n         * so CDEFs can use VDEFs and vice versa\n         */\n        switch (im->gdes[gdi].gf) {\n        case GF_XPORT:\n            break;\n        case GF_SHIFT:{\n            graph_desc_t *vdp = &im->gdes[im->gdes[gdi].vidx];\n\n            /* remove current shift */\n            vdp->start -= vdp->shift;\n            vdp->end -= vdp->shift;\n\n            /* vdef */\n            if (im->gdes[gdi].shidx >= 0)\n                vdp->shift = im->gdes[im->gdes[gdi].shidx].vf.val;\n            /* constant */\n            else\n                vdp->shift = im->gdes[gdi].shval;\n\n            /* normalize shift to multiple of consolidated step */\n            vdp->shift = (vdp->shift / (long) vdp->step) * (long) vdp->step;\n\n            /* apply shift */\n            vdp->start += vdp->shift;\n            vdp->end += vdp->shift;\n            break;\n        }\n        case GF_VDEF:\n            /* A VDEF has no DS.  This also signals other parts\n             * of rrdtool that this is a VDEF value, not a CDEF.\n             */\n            im->gdes[gdi].ds_cnt = 0;\n            if (vdef_calc(im, gdi)) {\n                rrd_set_error(\"Error processing VDEF '%s'\",\n                              im->gdes[gdi].vname);\n                rpnstack_free(&rpnstack);\n                return -1;\n            }\n            break;\n        case GF_CDEF:\n            im->gdes[gdi].ds_cnt = 1;\n            im->gdes[gdi].ds = 0;\n            im->gdes[gdi].data_first = 1;\n            im->gdes[gdi].start = 0;\n            im->gdes[gdi].end = 0;\n            steparray = NULL;\n            stepcnt = 0;\n            dataidx = -1;\n\t    rpnp = im->gdes[gdi].rpnp;\n\n            /* Find the variables in the expression.\n             * - VDEF variables are substituted by their values\n             *   and the opcode is changed into OP_NUMBER.\n             * - CDEF variables are analized for their step size,\n             *   the lowest common denominator of all the step\n             *   sizes of the data sources involved is calculated\n             *   and the resulting number is the step size for the\n             *   resulting data source.\n             */\n            for (rpi = 0; im->gdes[gdi].rpnp[rpi].op != OP_END; rpi++) {\n                if (im->gdes[gdi].rpnp[rpi].op == OP_VARIABLE ||\n                    im->gdes[gdi].rpnp[rpi].op == OP_PREV_OTHER) {\n                    long      ptr = im->gdes[gdi].rpnp[rpi].ptr;\n\n                    if (im->gdes[ptr].ds_cnt == 0) {    /* this is a VDEF data source */\n#if 0\n                        printf\n                            (\"DEBUG: inside CDEF '%s' processing VDEF '%s'\\n\",\n                             im->gdes[gdi].vname, im->gdes[ptr].vname);\n                        printf(\"DEBUG: value from vdef is %f\\n\",\n                               im->gdes[ptr].vf.val);\n#endif\n                        im->gdes[gdi].rpnp[rpi].val = im->gdes[ptr].vf.val;\n                        im->gdes[gdi].rpnp[rpi].op = OP_NUMBER;\n                    } else {    /* normal variables and PREF(variables) */\n\n                        /* add one entry to the array that keeps track of the step sizes of the\n                         * data sources going into the CDEF. */\n                        if ((steparray =\n                             (long*)rrd_realloc(steparray,\n                                         (++stepcnt +\n                                          1) * sizeof(*steparray))) == NULL) {\n                            rrd_set_error(\"realloc steparray\");\n                            rpnstack_free(&rpnstack);\n                            return -1;\n                        };\n\n                        steparray[stepcnt - 1] = im->gdes[ptr].step;\n\n                        /* adjust start and end of cdef (gdi) so\n                         * that it runs from the latest start point\n                         * to the earliest endpoint of any of the\n                         * rras involved (ptr)\n                         */\n\n                        if (im->gdes[gdi].start < im->gdes[ptr].start)\n                            im->gdes[gdi].start = im->gdes[ptr].start;\n\n                        if (im->gdes[gdi].end == 0 ||\n                            im->gdes[gdi].end > im->gdes[ptr].end)\n                            im->gdes[gdi].end = im->gdes[ptr].end;\n\n                        /* store pointer to the first element of\n                         * the rra providing data for variable,\n                         * further save step size and data source\n                         * count of this rra\n                         */\n                        im->gdes[gdi].rpnp[rpi].data =\n                            im->gdes[ptr].data + im->gdes[ptr].ds;\n                        im->gdes[gdi].rpnp[rpi].step = im->gdes[ptr].step;\n                        im->gdes[gdi].rpnp[rpi].ds_cnt = im->gdes[ptr].ds_cnt;\n\n                        /* backoff the *.data ptr; this is done so\n                         * rpncalc() function doesn't have to treat\n                         * the first case differently\n                         */\n                    }   /* if ds_cnt != 0 */\n                }       /* if OP_VARIABLE */\n            }           /* loop through all rpi */\n\n            /* move the data pointers to the correct period */\n            for (rpi = 0; im->gdes[gdi].rpnp[rpi].op != OP_END; rpi++) {\n                if (im->gdes[gdi].rpnp[rpi].op == OP_VARIABLE ||\n                    im->gdes[gdi].rpnp[rpi].op == OP_PREV_OTHER) {\n                    long      ptr = im->gdes[gdi].rpnp[rpi].ptr;\n                    long      diff =\n                        im->gdes[gdi].start - im->gdes[ptr].start;\n\n                    if (diff > 0)\n                        im->gdes[gdi].rpnp[rpi].data +=\n                            (diff / im->gdes[ptr].step) *\n                            im->gdes[ptr].ds_cnt;\n                }\n            }\n\n            if (steparray == NULL) {\n                rrd_set_error(\"rpn expressions without DEF\"\n                              \" or CDEF variables are not supported\");\n                rpnstack_free(&rpnstack);\n                return -1;\n            }\n            steparray[stepcnt] = 0;\n            /* Now find the resulting step.  All steps in all\n             * used RRAs have to be visited\n             */\n            im->gdes[gdi].step = lcd(steparray);\n            free(steparray);\n            if ((im->gdes[gdi].data = (rrd_value_t*)malloc(((im->gdes[gdi].end -\n                                               im->gdes[gdi].start)\n                                              / im->gdes[gdi].step)\n                                             * sizeof(double))) == NULL) {\n                rrd_set_error(\"malloc im->gdes[gdi].data\");\n                rpnstack_free(&rpnstack);\n                return -1;\n            }\n\n            /* Step through the new cdef results array and\n             * calculate the values\n             */\n            for (now = im->gdes[gdi].start + im->gdes[gdi].step;\n                 now <= im->gdes[gdi].end; now += im->gdes[gdi].step) {\n\n                /* 3rd arg of rpn_calc is for OP_VARIABLE lookups;\n                 * in this case we are advancing by timesteps;\n                 * we use the fact that time_t is a synonym for long\n                 */\n                if (rpn_calc(rpnp, &rpnstack, (long) now,\n                             im->gdes[gdi].data, ++dataidx) == -1) {\n                    /* rpn_calc sets the error string */\n                    rpnstack_free(&rpnstack);\n\t\t    rpnp_freeextra(rpnp);\n                    return -1;\n                }\n            }           /* enumerate over time steps within a CDEF */\n\t    rpnp_freeextra(rpnp);\n\t    \n            break;\n        default:\n            continue;\n        }\n    }                   /* enumerate over CDEFs */\n    rpnstack_free(&rpnstack);\n    return 0;\n}\n\n/* from http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm */\n/* yes we are loosing precision by doing tos with floats instead of doubles\n   but it seems more stable this way. */\n\nstatic int AlmostEqual2sComplement(\n    float A,\n    float B,\n    int maxUlps)\n{\n\n    int       aInt = *(int *) &A;\n    int       bInt = *(int *) &B;\n    int       intDiff;\n\n    /* Make sure maxUlps is non-negative and small enough that the\n       default NAN won't compare as equal to anything.  */\n\n    /* assert(maxUlps > 0 && maxUlps < 4 * 1024 * 1024); */\n\n    /* Make aInt lexicographically ordered as a twos-complement int */\n\n    if (aInt < 0)\n        aInt = 0x80000000l - aInt;\n\n    /* Make bInt lexicographically ordered as a twos-complement int */\n\n    if (bInt < 0)\n        bInt = 0x80000000l - bInt;\n\n    intDiff = abs(aInt - bInt);\n\n    if (intDiff <= maxUlps)\n        return 1;\n\n    return 0;\n}\n\n/* massage data so, that we get one value for each x coordinate in the graph */\nint data_proc(\n    image_desc_t *im)\n{\n    long      i, ii;\n    double    pixstep = (double) (im->end - im->start)\n        / (double) im->xsize;   /* how much time\n                                   passes in one pixel */\n    double    paintval;\n    double    minval = DNAN, maxval = DNAN;\n\n    unsigned long gr_time;\n\n    /* memory for the processed data */\n    for (i = 0; i < im->gdes_c; i++) {\n        if ((im->gdes[i].gf == GF_LINE)\n         || (im->gdes[i].gf == GF_AREA) \n         || (im->gdes[i].gf == GF_TICK)\n         || (im->gdes[i].gf == GF_GRAD)\n        ) {\n            if ((im->gdes[i].p_data = (rrd_value_t*)malloc((im->xsize + 1)\n                                             * sizeof(rrd_value_t))) == NULL) {\n                rrd_set_error(\"malloc data_proc\");\n                return -1;\n            }\n        }\n    }\n\n    for (i = 0; i < im->xsize; i++) {   /* for each pixel */\n        long      vidx;\n\n        gr_time = im->start + pixstep * i;  /* time of the current step */\n        paintval = 0.0;\n\n        for (ii = 0; ii < im->gdes_c; ii++) {\n            double    value;\n\n            switch (im->gdes[ii].gf) {\n            case GF_LINE:\n            case GF_AREA:\n\t\t\tcase GF_GRAD:\n            case GF_TICK:\n                if (!im->gdes[ii].stack)\n                    paintval = 0.0;\n                value = im->gdes[ii].yrule;\n                if (isnan(value) || (im->gdes[ii].gf == GF_TICK)) {\n                    /* The time of the data doesn't necessarily match\n                     ** the time of the graph. Beware.\n                     */\n                    vidx = im->gdes[ii].vidx;\n                    if (im->gdes[vidx].gf == GF_VDEF) {\n                        value = im->gdes[vidx].vf.val;\n                    } else\n                        if (((long int) gr_time >=\n                             (long int) im->gdes[vidx].start)\n                            && ((long int) gr_time <\n                                (long int) im->gdes[vidx].end)) {\n                        value = im->gdes[vidx].data[(unsigned long)\n                                                    floor((double)\n                                                          (gr_time -\n                                                           im->gdes[vidx].\n                                                           start)\n                                                          /\n                                                          im->gdes[vidx].step)\n                                                    * im->gdes[vidx].ds_cnt +\n                                                    im->gdes[vidx].ds];\n                    } else {\n                        value = DNAN;\n                    }\n                };\n\n                if (!isnan(value)) {\n                    paintval += value;\n                    im->gdes[ii].p_data[i] = paintval;\n                    /* GF_TICK: the data values are not\n                     ** relevant for min and max\n                     */\n                    if (finite(paintval) && im->gdes[ii].gf != GF_TICK && !im->gdes[ii].skipscale) {\n                        if ((isnan(minval) || paintval < minval) &&\n                            !(im->logarithmic && paintval <= 0.0))\n                            minval = paintval;\n                        if (isnan(maxval) || paintval > maxval)\n                            maxval = paintval;\n                    }\n                } else {\n                    im->gdes[ii].p_data[i] = DNAN;\n                }\n                break;\n            case GF_STACK:\n                rrd_set_error\n                    (\"STACK should already be turned into LINE or AREA here\");\n                return -1;\n                break;\n            default:\n                break;\n            }\n        }\n    }\n\n    /* if min or max have not been asigned a value this is because\n       there was no data in the graph ... this is not good ...\n       lets set these to dummy values then ... */\n\n    if (im->logarithmic) {\n        if (isnan(minval) || isnan(maxval) || maxval <= 0) {\n            minval = 0.0;   /* catching this right away below */\n            maxval = 5.1;\n        }\n        /* in logarithm mode, where minval is smaller or equal\n           to 0 make the beast just way smaller than maxval */\n        if (minval <= 0) {\n            minval = maxval / 10e8;\n        }\n    } else {\n        if (isnan(minval) || isnan(maxval)) {\n            minval = 0.0;\n            maxval = 1.0;\n        }\n    }\n\n    /* adjust min and max values given by the user */\n    /* for logscale we add something on top */\n    if (isnan(im->minval)\n        || ((!im->rigid) && im->minval > minval)\n        ) {\n        if (im->logarithmic)\n            im->minval = minval / 2.0;\n        else\n            im->minval = minval;\n    }\n    if (isnan(im->maxval)\n        || (!im->rigid && im->maxval < maxval)\n        ) {\n        if (im->logarithmic)\n            im->maxval = maxval * 2.0;\n        else\n            im->maxval = maxval;\n    }\n\n    /* make sure min is smaller than max */\n    if (im->minval > im->maxval) {\n        if (im->minval > 0)\n            im->minval = 0.99 * im->maxval;\n        else\n            im->minval = 1.01 * im->maxval;\n    }\n\n    /* make sure min and max are not equal */\n    if (AlmostEqual2sComplement(im->minval, im->maxval, 4)) {\n        if (im->maxval > 0)\n            im->maxval *= 1.01;\n        else\n            im->maxval *= 0.99;\n\n        /* make sure min and max are not both zero */\n        if (AlmostEqual2sComplement(im->maxval, 0, 4)) {\n            im->maxval = 1.0;\n        }\n    }\n    return 0;\n}\n\nstatic int find_first_weekday(void){\n    static int first_weekday = -1;\n    if (first_weekday == -1){\n#ifdef HAVE__NL_TIME_WEEK_1STDAY\n        /* according to http://sourceware.org/ml/libc-locales/2009-q1/msg00011.html */\n        /* See correct way here http://pasky.or.cz/dev/glibc/first_weekday.c */\n        first_weekday = nl_langinfo (_NL_TIME_FIRST_WEEKDAY)[0];\n        int week_1stday;\n        long week_1stday_l = (long) nl_langinfo (_NL_TIME_WEEK_1STDAY);\n        if (week_1stday_l == 19971130) week_1stday = 0; /* Sun */\n        else if (week_1stday_l == 19971201) week_1stday = 1; /* Mon */\n        else\n        {\n            first_weekday = 1;\n            return first_weekday; /* we go for a monday default */\n        }\n        first_weekday=(week_1stday + first_weekday - 1) % 7;\n#else\n        first_weekday = 1;\n#endif\n    }\n    return first_weekday;\n}\n\n/* identify the point where the first gridline, label ... gets placed */\n\ntime_t find_first_time(\n    time_t start,       /* what is the initial time */\n    enum tmt_en baseint,    /* what is the basic interval */\n    long basestep       /* how many if these do we jump a time */\n    )\n{\n    struct tm tm;\n\n    localtime_r(&start, &tm);\n    /* let mktime figure this dst on its own */\n    tm.tm_isdst = -1;\n\n    switch (baseint) {\n    case TMT_SECOND:\n        tm.       tm_sec -= tm.tm_sec % basestep;\n\n        break;\n    case TMT_MINUTE:\n        tm.       tm_sec = 0;\n        tm.       tm_min -= tm.tm_min % basestep;\n\n        break;\n    case TMT_HOUR:\n        tm.       tm_sec = 0;\n        tm.       tm_min = 0;\n        tm.       tm_hour -= tm.tm_hour % basestep;\n\n        break;\n    case TMT_DAY:\n        /* we do NOT look at the basestep for this ... */\n        tm.       tm_sec = 0;\n        tm.       tm_min = 0;\n        tm.       tm_hour = 0;\n\n        break;\n    case TMT_WEEK:\n        /* we do NOT look at the basestep for this ... */\n        tm.       tm_sec = 0;\n        tm.       tm_min = 0;\n        tm.       tm_hour = 0;\n        tm.       tm_mday -= tm.tm_wday - find_first_weekday();\n\n        if (tm.tm_wday == 0 && find_first_weekday() > 0)\n            tm.       tm_mday -= 7; /* we want the *previous* week */\n\n        break;\n    case TMT_MONTH:\n        tm.       tm_sec = 0;\n        tm.       tm_min = 0;\n        tm.       tm_hour = 0;\n        tm.       tm_mday = 1;\n        tm.       tm_mon -= tm.tm_mon % basestep;\n\n        break;\n\n    case TMT_YEAR:\n        tm.       tm_sec = 0;\n        tm.       tm_min = 0;\n        tm.       tm_hour = 0;\n        tm.       tm_mday = 1;\n        tm.       tm_mon = 0;\n        tm.       tm_year -= (\n    tm.tm_year + 1900) %basestep;\n\n    }\n    return mktime(&tm);\n}\n\n/* identify the point where the next gridline, label ... gets placed */\ntime_t find_next_time(\n    time_t current,     /* what is the initial time */\n    enum tmt_en baseint,    /* what is the basic interval */\n    long basestep       /* how many if these do we jump a time */\n    )\n{\n    struct tm tm;\n    time_t    madetime;\n\n    localtime_r(&current, &tm);\n    /* let mktime figure this dst on its own */\n    tm.tm_isdst = -1;\n\n    int limit = 2;\n    switch (baseint) {\n    case TMT_SECOND: limit = 7200; break;\n    case TMT_MINUTE: limit = 120; break;\n    case TMT_HOUR: limit = 2; break;\n    default: limit = 2; break;\n    }\n    do {\n        switch (baseint) {\n        case TMT_SECOND:\n            tm.       tm_sec += basestep;\n\n            break;\n        case TMT_MINUTE:\n            tm.       tm_min += basestep;\n\n            break;\n        case TMT_HOUR:\n            tm.       tm_hour += basestep;\n\n            break;\n        case TMT_DAY:\n            tm.       tm_mday += basestep;\n\n            break;\n        case TMT_WEEK:\n            tm.       tm_mday += 7 * basestep;\n\n            break;\n        case TMT_MONTH:\n            tm.       tm_mon += basestep;\n\n            break;\n        case TMT_YEAR:\n            tm.       tm_year += basestep;\n        }\n        madetime = mktime(&tm);\n    } while (madetime == -1 && limit-- >= 0);   /* this is necessary to skip impossible times\n                                   like the daylight saving time skips */\n    return madetime;\n\n}\n\n\n/* calculate values required for PRINT and GPRINT functions */\n\nint print_calc(\n    image_desc_t *im)\n{\n    long      i, ii, validsteps;\n    double    printval;\n    struct tm tmvdef;\n    int       graphelement = 0;\n    long      vidx;\n    int       max_ii;\n    double    magfact = -1;\n    char     *si_symb = \"\";\n    char     *percent_s;\n    int       prline_cnt = 0;\n\n    /* wow initializing tmvdef is quite a task :-) */\n    time_t    now = time(NULL);\n\n    localtime_r(&now, &tmvdef);\n    for (i = 0; i < im->gdes_c; i++) {\n        vidx = im->gdes[i].vidx;\n        switch (im->gdes[i].gf) {\n        case GF_PRINT:\n        case GF_GPRINT:\n            /* PRINT and GPRINT can now print VDEF generated values.\n             * There's no need to do any calculations on them as these\n             * calculations were already made.\n             */\n            if (im->gdes[vidx].gf == GF_VDEF) { /* simply use vals */\n                printval = im->gdes[vidx].vf.val;\n                localtime_r(&im->gdes[vidx].vf.when, &tmvdef);\n            } else {    /* need to calculate max,min,avg etcetera */\n                max_ii = ((im->gdes[vidx].end - im->gdes[vidx].start)\n                          / im->gdes[vidx].step * im->gdes[vidx].ds_cnt);\n                printval = DNAN;\n                validsteps = 0;\n                for (ii = im->gdes[vidx].ds;\n                     ii < max_ii; ii += im->gdes[vidx].ds_cnt) {\n                    if (!finite(im->gdes[vidx].data[ii]))\n                        continue;\n                    if (isnan(printval)) {\n                        printval = im->gdes[vidx].data[ii];\n                        validsteps++;\n                        continue;\n                    }\n\n                    switch (im->gdes[i].cf) {\n                    case CF_HWPREDICT:\n                    case CF_MHWPREDICT:\n                    case CF_DEVPREDICT:\n                    case CF_DEVSEASONAL:\n                    case CF_SEASONAL:\n                    case CF_AVERAGE:\n                        validsteps++;\n                        printval += im->gdes[vidx].data[ii];\n                        break;\n                    case CF_MINIMUM:\n                        printval = min(printval, im->gdes[vidx].data[ii]);\n                        break;\n                    case CF_FAILURES:\n                    case CF_MAXIMUM:\n                        printval = max(printval, im->gdes[vidx].data[ii]);\n                        break;\n                    case CF_LAST:\n                        printval = im->gdes[vidx].data[ii];\n                    }\n                }\n                if (im->gdes[i].cf == CF_AVERAGE || im->gdes[i].cf > CF_LAST) {\n                    if (validsteps > 1) {\n                        printval = (printval / validsteps);\n                    }\n                }\n            }           /* prepare printval */\n\n            if (!im->gdes[i].strftm && (percent_s = strstr(im->gdes[i].format, \"%S\")) != NULL) {\n                /* Magfact is set to -1 upon entry to print_calc.  If it\n                 * is still less than 0, then we need to run auto_scale.\n                 * Otherwise, put the value into the correct units.  If\n                 * the value is 0, then do not set the symbol or magnification\n                 * so next the calculation will be performed again. */\n                if (magfact < 0.0) {\n                    auto_scale(im, &printval, &si_symb, &magfact);\n                    if (printval == 0.0)\n                        magfact = -1.0;\n                } else {\n                    printval /= magfact;\n                }\n                *(++percent_s) = 's';\n            } else if (!im->gdes[i].strftm && strstr(im->gdes[i].format, \"%s\") != NULL) {\n                auto_scale(im, &printval, &si_symb, &magfact);\n            }\n\n            if (im->gdes[i].gf == GF_PRINT) {\n                rrd_infoval_t prline;\n\n                if (im->gdes[i].strftm) {\n                    prline.u_str = (char*)malloc((FMT_LEG_LEN + 2) * sizeof(char));\n                    if (im->gdes[vidx].vf.never == 1) {\n                       time_clean(prline.u_str, im->gdes[i].format);\n                    } else {\n                        strftime(prline.u_str,\n                                 FMT_LEG_LEN, im->gdes[i].format, &tmvdef);\n                    }\n                } else if (bad_format_print(im->gdes[i].format)) {\n                    return -1;\n                } else {\n                    prline.u_str =\n                        sprintf_alloc(im->gdes[i].format, printval, si_symb);\n                }\n                grinfo_push(im,\n                            sprintf_alloc\n                            (\"print[%ld]\", prline_cnt++), RD_I_STR, prline);\n                free(prline.u_str);\n            } else {\n                /* GF_GPRINT */\n\n                if (im->gdes[i].strftm) {\n                    if (im->gdes[vidx].vf.never == 1) {\n                       time_clean(im->gdes[i].legend, im->gdes[i].format);\n                    } else {\n                        strftime(im->gdes[i].legend,\n                                 FMT_LEG_LEN, im->gdes[i].format, &tmvdef);\n                    }\n                } else {\n                    if (bad_format_print(im->gdes[i].format)) {\n                       return -1;\n                    }\n                    snprintf(im->gdes[i].legend,\n                             FMT_LEG_LEN - 2,\n                             im->gdes[i].format, printval, si_symb);\n                }\n                graphelement = 1;\n            }\n            break;\n        case GF_LINE:\n        case GF_AREA:\n\t\tcase GF_GRAD:\n        case GF_TICK:\n            graphelement = 1;\n            break;\n        case GF_HRULE:\n            if (isnan(im->gdes[i].yrule)) { /* we must set this here or the legend printer can not decide to print the legend */\n                im->gdes[i].yrule = im->gdes[vidx].vf.val;\n            };\n            graphelement = 1;\n            break;\n        case GF_VRULE:\n            if (im->gdes[i].xrule == 0) {   /* again ... the legend printer needs it */\n                im->gdes[i].xrule = im->gdes[vidx].vf.when;\n            };\n            graphelement = 1;\n            break;\n        case GF_COMMENT:\n        case GF_TEXTALIGN:\n        case GF_DEF:\n        case GF_CDEF:\n        case GF_VDEF:\n#ifdef WITH_PIECHART\n        case GF_PART:\n#endif\n        case GF_SHIFT:\n        case GF_XPORT:\n            break;\n        case GF_STACK:\n            rrd_set_error\n                (\"STACK should already be turned into LINE or AREA here\");\n            return -1;\n            break;\n        case GF_XAXIS:\n        case GF_YAXIS:\n\t    break;\n        }\n    }\n    return graphelement;\n}\n\n\n\n/* place legends with color spots */\nint leg_place(\n    image_desc_t *im,\n    int calc_width)\n{\n    /* graph labels */\n    int       interleg = im->text_prop[TEXT_PROP_LEGEND].size * 2.0;\n    int       border = im->text_prop[TEXT_PROP_LEGEND].size * 2.0;\n    int       fill = 0, fill_last;\n    double    legendwidth; // = im->ximg - 2 * border;\n    int       leg_c = 0;\n    double    leg_x = border;\n    int       leg_y = 0; //im->yimg;\n    int       leg_cc;\n    double    glue = 0;\n    int       i, ii, mark = 0;\n    char      default_txtalign = TXA_JUSTIFIED; /*default line orientation */\n    int      *legspace;\n    char     *tab;\n    char      saved_legend[FMT_LEG_LEN + 5];\n\n    if(calc_width){\n        legendwidth = 0;\n    }\n    else{\n        legendwidth = im->legendwidth - 2 * border;\n    }\n\n\n    if (!(im->extra_flags & NOLEGEND) && !(im->extra_flags & ONLY_GRAPH)) {\n        if ((legspace = (int*)malloc(im->gdes_c * sizeof(int))) == NULL) {\n            rrd_set_error(\"malloc for legspace\");\n            return -1;\n        }\n\n        for (i = 0; i < im->gdes_c; i++) {\n            char      prt_fctn; /*special printfunctions */\n            if(calc_width){\n                strncpy(saved_legend, im->gdes[i].legend, sizeof saved_legend);\n            }\n\n            fill_last = fill;\n            /* hide legends for rules which are not displayed */\n            if (im->gdes[i].gf == GF_TEXTALIGN) {\n                default_txtalign = im->gdes[i].txtalign;\n            }\n\n            if (!(im->extra_flags & FORCE_RULES_LEGEND)) {\n                if (im->gdes[i].gf == GF_HRULE\n                    && (im->gdes[i].yrule <\n                        im->minval || im->gdes[i].yrule > im->maxval))\n                    im->gdes[i].legend[0] = '\\0';\n                if (im->gdes[i].gf == GF_VRULE\n                    && (im->gdes[i].xrule <\n                        im->start || im->gdes[i].xrule > im->end))\n                    im->gdes[i].legend[0] = '\\0';\n            }\n\n            /* turn \\\\t into tab */\n            while ((tab = strstr(im->gdes[i].legend, \"\\\\t\"))) {\n                memmove(tab, tab + 1, strlen(tab));\n                tab[0] = (char) 9;\n            }\n\n            leg_cc = strlen(im->gdes[i].legend);\n            /* is there a controle code at the end of the legend string ? */\n            if (leg_cc >= 2 && im->gdes[i].legend[leg_cc - 2] == '\\\\') {\n                prt_fctn = im->gdes[i].legend[leg_cc - 1];\n                leg_cc -= 2;\n                im->gdes[i].legend[leg_cc] = '\\0';\n            } else {\n                prt_fctn = '\\0';\n            }\n            /* only valid control codes */\n            if (prt_fctn != 'l' && prt_fctn != 'n' &&   /* a synonym for l */\n                prt_fctn != 'r' &&\n                prt_fctn != 'j' &&\n                prt_fctn != 'c' &&\n                prt_fctn != 'u' &&\n                prt_fctn != '.' &&\n                prt_fctn != 's' && prt_fctn != '\\0' && prt_fctn != 'g') {\n                free(legspace);\n                rrd_set_error\n                    (\"Unknown control code at the end of '%s\\\\%c'\",\n                     im->gdes[i].legend, prt_fctn);\n                return -1;\n            }\n            /* \\n -> \\l */\n            if (prt_fctn == 'n') {\n                prt_fctn = 'l';\n            }\n            /* \\. is a null operation to allow strings ending in \\x */\n            if (prt_fctn == '.') {\n                prt_fctn = '\\0';\n            }\n\n            /* remove exess space from the end of the legend for \\g */\n            while (prt_fctn == 'g' &&\n                   leg_cc > 0 && im->gdes[i].legend[leg_cc - 1] == ' ') {\n                leg_cc--;\n                im->gdes[i].legend[leg_cc] = '\\0';\n            }\n\n            if (leg_cc != 0) {\n\n                /* no interleg space if string ends in \\g */\n                legspace[i] = (prt_fctn == 'g' ? 0 : interleg);\n                if (fill > 0) {\n                    fill += legspace[i];\n                }\n                fill +=\n                    gfx_get_text_width(im,\n                                       fill + border,\n                                       im->\n                                       text_prop\n                                       [TEXT_PROP_LEGEND].\n                                       font_desc,\n                                       im->tabwidth, im->gdes[i].legend);\n                leg_c++;\n            } else {\n                legspace[i] = 0;\n            }\n            /* who said there was a special tag ... ? */\n            if (prt_fctn == 'g') {\n                prt_fctn = '\\0';\n            }\n\n            if (prt_fctn == '\\0') {\n                if(calc_width && (fill > legendwidth)){\n                    legendwidth = fill;\n                }\n                if (i == im->gdes_c - 1 || fill > legendwidth) {\n                    /* just one legend item is left right or center */\n                    switch (default_txtalign) {\n                    case TXA_RIGHT:\n                        prt_fctn = 'r';\n                        break;\n                    case TXA_CENTER:\n                        prt_fctn = 'c';\n                        break;\n                    case TXA_JUSTIFIED:\n                        prt_fctn = 'j';\n                        break;\n                    default:\n                        prt_fctn = 'l';\n                        break;\n                    }\n                }\n                /* is it time to place the legends ? */\n                if (fill > legendwidth) {\n                    if (leg_c > 1) {\n                        /* go back one */\n                        i--;\n                        fill = fill_last;\n                        leg_c--;\n                    }\n                }\n                if (leg_c == 1 && prt_fctn == 'j') {\n                    prt_fctn = 'l';\n                }\n            }\n\n            if (prt_fctn != '\\0') {\n                leg_x = border;\n                if (leg_c >= 2 && prt_fctn == 'j') {\n                    glue = (double)(legendwidth - fill) / (double)(leg_c - 1);\n                } else {\n                    glue = 0;\n                }\n                if (prt_fctn == 'c')\n                    leg_x = border + (double)(legendwidth - fill) / 2.0;\n                if (prt_fctn == 'r')\n                    leg_x = legendwidth - fill + border;\n                for (ii = mark; ii <= i; ii++) {\n                    if (im->gdes[ii].legend[0] == '\\0')\n                        continue;   /* skip empty legends */\n                    im->gdes[ii].leg_x = leg_x;\n                    im->gdes[ii].leg_y = leg_y + border;\n                    leg_x +=\n                        (double)gfx_get_text_width(im, leg_x,\n                                           im->\n                                           text_prop\n                                           [TEXT_PROP_LEGEND].\n                                           font_desc,\n                                           im->tabwidth, im->gdes[ii].legend)\n                        +(double)legspace[ii]\n                        + glue;\n                }\n                if (leg_x > border || prt_fctn == 's')\n                    leg_y += im->text_prop[TEXT_PROP_LEGEND].size * 1.8;\n                if (prt_fctn == 's')\n                    leg_y -= im->text_prop[TEXT_PROP_LEGEND].size;\n                if (prt_fctn == 'u')\n                    leg_y -= im->text_prop[TEXT_PROP_LEGEND].size *1.8;\n\n                if(calc_width && (fill > legendwidth)){\n                    legendwidth = fill;\n                }\n                fill = 0;\n                leg_c = 0;\n                mark = ii;\n            }\n\n            if(calc_width){\n                strncpy(im->gdes[i].legend, saved_legend, sizeof im->gdes[0].legend);\n            }\n        }\n\n        if(calc_width){\n            im->legendwidth = legendwidth + 2 * border;\n        }\n        else{\n            im->legendheight = leg_y + border * 0.6;\n        }\n        free(legspace);\n    }\n    return 0;\n}\n\n/* create a grid on the graph. it determines what to do\n   from the values of xsize, start and end */\n\n/* the xaxis labels are determined from the number of seconds per pixel\n   in the requested graph */\n\nint calc_horizontal_grid(\n    image_desc_t\n    *im)\n{\n    double    range;\n    double    scaledrange;\n    int       pixel, i;\n    int       gridind = 0;\n    int       decimals, fractionals;\n\n    im->ygrid_scale.labfact = 2;\n    range = im->maxval - im->minval;\n    scaledrange = range / im->magfact;\n    /* does the scale of this graph make it impossible to put lines\n       on it? If so, give up. */\n    if (isnan(scaledrange)) {\n        return 0;\n    }\n\n    /* find grid spaceing */\n    pixel = 1;\n    if (isnan(im->ygridstep)) {\n        if (im->extra_flags & ALTYGRID) {\n            /* find the value with max number of digits. Get number of digits */\n            decimals =\n                ceil(log10\n                     (max(fabs(im->maxval), fabs(im->minval)) *\n                      im->viewfactor / im->magfact));\n            if (decimals <= 0)  /* everything is small. make place for zero */\n                decimals = 1;\n            im->ygrid_scale.gridstep =\n                pow((double) 10,\n                    floor(log10(range * im->viewfactor / im->magfact))) /\n                im->viewfactor * im->magfact;\n            if (im->ygrid_scale.gridstep == 0)  /* range is one -> 0.1 is reasonable scale */\n                im->ygrid_scale.gridstep = 0.1;\n            /* should have at least 5 lines but no more then 15 */\n            if (range / im->ygrid_scale.gridstep < 5\n                && im->ygrid_scale.gridstep >= 30)\n                im->ygrid_scale.gridstep /= 10;\n            if (range / im->ygrid_scale.gridstep > 15)\n                im->ygrid_scale.gridstep *= 10;\n            if (range / im->ygrid_scale.gridstep > 5) {\n                im->ygrid_scale.labfact = 1;\n                if (range / im->ygrid_scale.gridstep > 8\n                    || im->ygrid_scale.gridstep <\n                    1.8 * im->text_prop[TEXT_PROP_AXIS].size)\n                    im->ygrid_scale.labfact = 2;\n            } else {\n                im->ygrid_scale.gridstep /= 5;\n                im->ygrid_scale.labfact = 5;\n            }\n            fractionals =\n                floor(log10\n                      (im->ygrid_scale.gridstep *\n                       (double) im->ygrid_scale.labfact * im->viewfactor /\n                       im->magfact));\n            if (fractionals < 0) {  /* small amplitude. */\n                int       len = decimals - fractionals + 1;\n\n                if (im->unitslength < len + 2)\n                    im->unitslength = len + 2;\n                snprintf(im->ygrid_scale.labfmt, sizeof im->ygrid_scale.labfmt, \n                        \"%%%d.%df%s\", len,\n                        -fractionals, (im->symbol != ' ' ? \" %c\" : \"\"));\n            } else {\n                int       len = decimals + 1;\n\n                if (im->unitslength < len + 2)\n                    im->unitslength = len + 2;\n                snprintf(im->ygrid_scale.labfmt, sizeof im->ygrid_scale.labfmt,\n                        \"%%%d.0f%s\", len, (im->symbol != ' ' ? \" %c\" : \"\"));\n            }\n        } else {        /* classic rrd grid */\n            for (i = 0; ylab[i].grid > 0; i++) {\n                pixel = im->ysize / (scaledrange / ylab[i].grid);\n                gridind = i;\n                if (pixel >= 5)\n                    break;\n            }\n\n            for (i = 0; i < 4; i++) {\n                if (pixel * ylab[gridind].lfac[i] >=\n                    1.8 * im->text_prop[TEXT_PROP_AXIS].size) {\n                    im->ygrid_scale.labfact = ylab[gridind].lfac[i];\n                    break;\n                }\n            }\n\n            im->ygrid_scale.gridstep = ylab[gridind].grid * im->magfact;\n        }\n    } else {\n        im->ygrid_scale.gridstep = im->ygridstep;\n        im->ygrid_scale.labfact = im->ylabfact;\n    }\n    return 1;\n}\n\nint draw_horizontal_grid(\n    image_desc_t\n    *im)\n{\n    int       i;\n    double    scaledstep;\n    char      graph_label[100];\n    int       nlabels = 0;\n    double    X0 = im->xorigin;\n    double    X1 = im->xorigin + im->xsize;\n    int       sgrid = (int) (im->minval / im->ygrid_scale.gridstep - 1);\n    int       egrid = (int) (im->maxval / im->ygrid_scale.gridstep + 1);\n    double    MaxY;\n    double second_axis_magfact = 0;\n    char *second_axis_symb = \"\";\n\n    scaledstep =\n        im->ygrid_scale.gridstep /\n        (double) im->magfact * (double) im->viewfactor;\n    MaxY = scaledstep * (double) egrid;\n    for (i = sgrid; i <= egrid; i++) {\n        double    Y0 = ytr(im,\n                           im->ygrid_scale.gridstep * i);\n        double    YN = ytr(im,\n                           im->ygrid_scale.gridstep * (i + 1));\n\n        if (floor(Y0 + 0.5) >=\n            im->yorigin - im->ysize && floor(Y0 + 0.5) <= im->yorigin) {\n            /* Make sure at least 2 grid labels are shown, even if it doesn't agree\n               with the chosen settings. Add a label if required by settings, or if\n               there is only one label so far and the next grid line is out of bounds. */\n            if (i % im->ygrid_scale.labfact == 0\n                || (nlabels == 1\n                    && (YN < im->yorigin - im->ysize || YN > im->yorigin))) {\n                if (im->symbol == ' ') {\n                    if (im->primary_axis_format == NULL || im->primary_axis_format[0] == '\\0') {\n                        if (im->extra_flags & ALTYGRID) {\n                            snprintf(graph_label, sizeof graph_label,\n                                    im->ygrid_scale.labfmt,\n                                    scaledstep * (double) i);\n                        } else {\n                            if (MaxY < 10) {\n                                snprintf(graph_label, sizeof graph_label, \"%4.1f\",\n                                        scaledstep * (double) i);\n                            } else {\n                                snprintf(graph_label, sizeof graph_label,\"%4.0f\",\n                                        scaledstep * (double) i);\n                            }\n                        }\n                    } else {\n                        snprintf(graph_label, sizeof graph_label, im->primary_axis_format,\n                                scaledstep * (double) i);\n                    }\n                } else {\n                    char      sisym = (i == 0 ? ' ' : im->symbol);                   \n                    if (im->primary_axis_format == NULL || im->primary_axis_format[0] == '\\0') {\n                        if (im->extra_flags & ALTYGRID) {\n                            snprintf(graph_label,sizeof graph_label,\n                                    im->ygrid_scale.labfmt,\n                                    scaledstep * (double) i, sisym);\n                        } else {\n                            if (MaxY < 10) {\n                                snprintf(graph_label, sizeof graph_label,\"%4.1f %c\",\n                                        scaledstep * (double) i, sisym);\n                            } else {\n                                snprintf(graph_label, sizeof graph_label, \"%4.0f %c\",\n                                        scaledstep * (double) i, sisym);\n                            }\n                        }\n                    } else {\n                        sprintf(graph_label, im->primary_axis_format,\n                                scaledstep * (double) i, sisym);\n                    }\n                }\n                nlabels++;\n                if (im->second_axis_scale != 0){\n                        char graph_label_right[100];\n                        double sval = im->ygrid_scale.gridstep*(double)i*im->second_axis_scale+im->second_axis_shift;\n                        if (im->second_axis_format == NULL || im->second_axis_format[0] == '\\0') {\n                            if (!second_axis_magfact){\n                                double dummy = im->ygrid_scale.gridstep*(double)(sgrid+egrid)/2.0*im->second_axis_scale+im->second_axis_shift;\n                                auto_scale(im,&dummy,&second_axis_symb,&second_axis_magfact);\n                            }\n                            sval /= second_axis_magfact;\n\n                            if(MaxY < 10) {\n                                snprintf(graph_label_right, sizeof graph_label_right, \"%5.1f %s\",sval,second_axis_symb);\n                            } else {\n                                snprintf(graph_label_right, sizeof graph_label_right, \"%5.0f %s\",sval,second_axis_symb);\n                            }\n                        }\n                        else {\n                           snprintf(graph_label_right, sizeof graph_label_right, im->second_axis_format,sval,\"\");\n                        }\n                        gfx_text ( im,\n                               X1+7, Y0,\n                               im->graph_col[GRC_FONT],\n                               im->text_prop[TEXT_PROP_AXIS].font_desc,\n                               im->tabwidth,0.0, GFX_H_LEFT, GFX_V_CENTER,\n                               graph_label_right );\n                }\n\n                gfx_text(im,\n                         X0 -\n                         im->\n                         text_prop[TEXT_PROP_AXIS].\n                         size, Y0,\n                         im->graph_col[GRC_FONT],\n                         im->\n                         text_prop[TEXT_PROP_AXIS].\n                         font_desc,\n                         im->tabwidth, 0.0,\n                         GFX_H_RIGHT, GFX_V_CENTER, graph_label);\n                gfx_line(im, X0 - 2, Y0, X0, Y0,\n                         MGRIDWIDTH, im->graph_col[GRC_MGRID]);\n                gfx_line(im, X1, Y0, X1 + 2, Y0,\n                         MGRIDWIDTH, im->graph_col[GRC_MGRID]);\n                gfx_dashed_line(im, X0 - 2, Y0,\n                                X1 + 2, Y0,\n                                MGRIDWIDTH,\n                                im->\n                                graph_col\n                                [GRC_MGRID],\n                                im->grid_dash_on, im->grid_dash_off);\n            } else if (!(im->extra_flags & NOMINOR)) {\n                gfx_line(im,\n                         X0 - 2, Y0,\n                         X0, Y0, GRIDWIDTH, im->graph_col[GRC_GRID]);\n                gfx_line(im, X1, Y0, X1 + 2, Y0,\n                         GRIDWIDTH, im->graph_col[GRC_GRID]);\n                gfx_dashed_line(im, X0 - 1, Y0,\n                                X1 + 1, Y0,\n                                GRIDWIDTH,\n                                im->\n                                graph_col[GRC_GRID],\n                                im->grid_dash_on, im->grid_dash_off);\n            }\n        }\n    }\n    return 1;\n}\n\n/* this is frexp for base 10 */\ndouble    frexp10(\n    double,\n    double *);\ndouble frexp10(\n    double x,\n    double *e)\n{\n    double    mnt;\n    int       iexp;\n\n    iexp = floor(log((double)fabs(x)) / log((double)10));\n    mnt = x / pow(10.0, iexp);\n    if (mnt >= 10.0) {\n        iexp++;\n        mnt = x / pow(10.0, iexp);\n    }\n    *e = iexp;\n    return mnt;\n}\n\n\n/* logaritmic horizontal grid */\nint horizontal_log_grid(\n    image_desc_t\n    *im)\n{\n    double    yloglab[][10] = {\n        {\n         1.0, 10., 0.0, 0.0, 0.0, 0.0, 0.0,\n         0.0, 0.0, 0.0}, {\n                          1.0, 5.0, 10., 0.0, 0.0, 0.0, 0.0,\n                          0.0, 0.0, 0.0}, {\n                                           1.0, 2.0, 5.0, 7.0, 10., 0.0, 0.0,\n                                           0.0, 0.0, 0.0}, {\n                                                            1.0, 2.0, 4.0,\n                                                            6.0, 8.0, 10.,\n                                                            0.0,\n                                                            0.0, 0.0, 0.0}, {\n                                                                             1.0,\n                                                                             2.0,\n                                                                             3.0,\n                                                                             4.0,\n                                                                             5.0,\n                                                                             6.0,\n                                                                             7.0,\n                                                                             8.0,\n                                                                             9.0,\n                                                                             10.},\n        {\n         0, 0, 0, 0, 0, 0, 0, 0, 0, 0}  /* last line */\n    };\n    int       i, j, val_exp, min_exp;\n    double    nex;      /* number of decades in data */\n    double    logscale; /* scale in logarithmic space */\n    int       exfrac = 1;   /* decade spacing */\n    int       mid = -1; /* row in yloglab for major grid */\n    double    mspac;    /* smallest major grid spacing (pixels) */\n    int       flab;     /* first value in yloglab to use */\n    double    value, tmp, pre_value;\n    double    X0, X1, Y0;\n    char      graph_label[100];\n\n    nex = log10(im->maxval / im->minval);\n    logscale = im->ysize / nex;\n    /* major spacing for data with high dynamic range */\n    while (logscale * exfrac < 3 * im->text_prop[TEXT_PROP_LEGEND].size) {\n        if (exfrac == 1)\n            exfrac = 3;\n        else\n            exfrac += 3;\n    }\n\n    /* major spacing for less dynamic data */\n    do {\n        /* search best row in yloglab */\n        mid++;\n        for (i = 0; yloglab[mid][i + 1] < 10.0; i++);\n        mspac = logscale * log10(10.0 / yloglab[mid][i]);\n    }\n    while (mspac >\n           2 * im->text_prop[TEXT_PROP_LEGEND].size && yloglab[mid][0] > 0);\n    if (mid)\n        mid--;\n    /* find first value in yloglab */\n    for (flab = 0;\n         yloglab[mid][flab] < 10\n         && frexp10(im->minval, &tmp) > yloglab[mid][flab]; flab++);\n    if (yloglab[mid][flab] == 10.0) {\n        tmp += 1.0;\n        flab = 0;\n    }\n    val_exp = tmp;\n    if (val_exp % exfrac)\n        val_exp += abs(-val_exp % exfrac);\n    X0 = im->xorigin;\n    X1 = im->xorigin + im->xsize;\n    /* draw grid */\n    pre_value = DNAN;\n    while (1) {\n\n        value = yloglab[mid][flab] * pow(10.0, val_exp);\n        if (AlmostEqual2sComplement(value, pre_value, 4))\n            break;      /* it seems we are not converging */\n        pre_value = value;\n        Y0 = ytr(im, value);\n        if (floor(Y0 + 0.5) <= im->yorigin - im->ysize)\n            break;\n        /* major grid line */\n        gfx_line(im,\n                 X0 - 2, Y0, X0, Y0, MGRIDWIDTH, im->graph_col[GRC_MGRID]);\n        gfx_line(im, X1, Y0, X1 + 2, Y0,\n                 MGRIDWIDTH, im->graph_col[GRC_MGRID]);\n        gfx_dashed_line(im, X0 - 2, Y0,\n                        X1 + 2, Y0,\n                        MGRIDWIDTH,\n                        im->\n                        graph_col\n                        [GRC_MGRID], im->grid_dash_on, im->grid_dash_off);\n        /* label */\n        if (im->extra_flags & FORCE_UNITS_SI) {\n            int       scale;\n            double    pvalue;\n            char      symbol;\n\n            scale = floor(val_exp / 3.0);\n            if (value >= 1.0)\n                pvalue = pow(10.0, val_exp % 3);\n            else\n                pvalue = pow(10.0, ((val_exp + 1) % 3) + 2);\n            pvalue *= yloglab[mid][flab];\n            if (((scale + si_symbcenter) < (int) sizeof(si_symbol))\n                && ((scale + si_symbcenter) >= 0))\n                symbol = si_symbol[scale + si_symbcenter];\n            else\n                symbol = '?';\n            snprintf(graph_label, sizeof graph_label, \"%3.0f %c\", pvalue, symbol);\n        } else {\n            snprintf(graph_label, sizeof graph_label, \"%3.0e\", value);\n        }\n        if (im->second_axis_scale != 0){\n                char graph_label_right[100];\n                double sval = value*im->second_axis_scale+im->second_axis_shift;\n                if (im->second_axis_format == NULL || im->second_axis_format[0] == '\\0') {\n                        if (im->extra_flags & FORCE_UNITS_SI) {\n                                double mfac = 1;\n                                char   *symb = \"\";\n                                auto_scale(im,&sval,&symb,&mfac);\n                                snprintf(graph_label_right, sizeof graph_label_right, \"%4.0f %s\", sval,symb);\n                        }\n                        else {\n                                snprintf(graph_label_right, sizeof graph_label_right, \"%3.0e\", sval);\n                        }\n                }\n                else {\n                      snprintf(graph_label_right, sizeof graph_label_right, im->second_axis_format,sval,\"\");\n                }\n\n                gfx_text ( im,\n                               X1+7, Y0,\n                               im->graph_col[GRC_FONT],\n                               im->text_prop[TEXT_PROP_AXIS].font_desc,\n                               im->tabwidth,0.0, GFX_H_LEFT, GFX_V_CENTER,\n                               graph_label_right );\n        }\n\n        gfx_text(im,\n                 X0 -\n                 im->\n                 text_prop[TEXT_PROP_AXIS].\n                 size, Y0,\n                 im->graph_col[GRC_FONT],\n                 im->\n                 text_prop[TEXT_PROP_AXIS].\n                 font_desc,\n                 im->tabwidth, 0.0,\n                 GFX_H_RIGHT, GFX_V_CENTER, graph_label);\n        /* minor grid */\n        if (mid < 4 && exfrac == 1) {\n            /* find first and last minor line behind current major line\n             * i is the first line and j tha last */\n            if (flab == 0) {\n                min_exp = val_exp - 1;\n                for (i = 1; yloglab[mid][i] < 10.0; i++);\n                i = yloglab[mid][i - 1] + 1;\n                j = 10;\n            } else {\n                min_exp = val_exp;\n                i = yloglab[mid][flab - 1] + 1;\n                j = yloglab[mid][flab];\n            }\n\n            /* draw minor lines below current major line */\n            for (; i < j; i++) {\n\n                value = i * pow(10.0, min_exp);\n                if (value < im->minval)\n                    continue;\n                Y0 = ytr(im, value);\n                if (floor(Y0 + 0.5) <= im->yorigin - im->ysize)\n                    break;\n                /* draw lines */\n                gfx_line(im,\n                         X0 - 2, Y0,\n                         X0, Y0, GRIDWIDTH, im->graph_col[GRC_GRID]);\n                gfx_line(im, X1, Y0, X1 + 2, Y0,\n                         GRIDWIDTH, im->graph_col[GRC_GRID]);\n                gfx_dashed_line(im, X0 - 1, Y0,\n                                X1 + 1, Y0,\n                                GRIDWIDTH,\n                                im->\n                                graph_col[GRC_GRID],\n                                im->grid_dash_on, im->grid_dash_off);\n            }\n        } else if (exfrac > 1) {\n            for (i = val_exp - exfrac / 3 * 2; i < val_exp; i += exfrac / 3) {\n                value = pow(10.0, i);\n                if (value < im->minval)\n                    continue;\n                Y0 = ytr(im, value);\n                if (floor(Y0 + 0.5) <= im->yorigin - im->ysize)\n                    break;\n                /* draw lines */\n                gfx_line(im,\n                         X0 - 2, Y0,\n                         X0, Y0, GRIDWIDTH, im->graph_col[GRC_GRID]);\n                gfx_line(im, X1, Y0, X1 + 2, Y0,\n                         GRIDWIDTH, im->graph_col[GRC_GRID]);\n                gfx_dashed_line(im, X0 - 1, Y0,\n                                X1 + 1, Y0,\n                                GRIDWIDTH,\n                                im->\n                                graph_col[GRC_GRID],\n                                im->grid_dash_on, im->grid_dash_off);\n            }\n        }\n\n        /* next decade */\n        if (yloglab[mid][++flab] == 10.0) {\n            flab = 0;\n            val_exp += exfrac;\n        }\n    }\n\n    /* draw minor lines after highest major line */\n    if (mid < 4 && exfrac == 1) {\n        /* find first and last minor line below current major line\n         * i is the first line and j tha last */\n        if (flab == 0) {\n            min_exp = val_exp - 1;\n            for (i = 1; yloglab[mid][i] < 10.0; i++);\n            i = yloglab[mid][i - 1] + 1;\n            j = 10;\n        } else {\n            min_exp = val_exp;\n            i = yloglab[mid][flab - 1] + 1;\n            j = yloglab[mid][flab];\n        }\n\n        /* draw minor lines below current major line */\n        for (; i < j; i++) {\n\n            value = i * pow(10.0, min_exp);\n            if (value < im->minval)\n                continue;\n            Y0 = ytr(im, value);\n            if (floor(Y0 + 0.5) <= im->yorigin - im->ysize)\n                break;\n            /* draw lines */\n            gfx_line(im,\n                     X0 - 2, Y0, X0, Y0, GRIDWIDTH, im->graph_col[GRC_GRID]);\n            gfx_line(im, X1, Y0, X1 + 2, Y0,\n                     GRIDWIDTH, im->graph_col[GRC_GRID]);\n            gfx_dashed_line(im, X0 - 1, Y0,\n                            X1 + 1, Y0,\n                            GRIDWIDTH,\n                            im->\n                            graph_col[GRC_GRID],\n                            im->grid_dash_on, im->grid_dash_off);\n        }\n    }\n    /* fancy minor gridlines */\n    else if (exfrac > 1) {\n        for (i = val_exp - exfrac / 3 * 2; i < val_exp; i += exfrac / 3) {\n            value = pow(10.0, i);\n            if (value < im->minval)\n                continue;\n            Y0 = ytr(im, value);\n            if (floor(Y0 + 0.5) <= im->yorigin - im->ysize)\n                break;\n            /* draw lines */\n            gfx_line(im,\n                     X0 - 2, Y0, X0, Y0, GRIDWIDTH, im->graph_col[GRC_GRID]);\n            gfx_line(im, X1, Y0, X1 + 2, Y0,\n                     GRIDWIDTH, im->graph_col[GRC_GRID]);\n            gfx_dashed_line(im, X0 - 1, Y0,\n                            X1 + 1, Y0,\n                            GRIDWIDTH,\n                            im->\n                            graph_col[GRC_GRID],\n                            im->grid_dash_on, im->grid_dash_off);\n        }\n    }\n\n    return 1;\n}\n\n\nvoid vertical_grid(\n    image_desc_t *im)\n{\n    int       xlab_sel; /* which sort of label and grid ? */\n    time_t    ti, tilab, timajor;\n    long      factor;\n    char      graph_label[100];\n    double    X0, Y0, Y1;   /* points for filled graph and more */\n    struct tm tm;\n\n    /* the type of time grid is determined by finding\n       the number of seconds per pixel in the graph */\n    if (im->xlab_user.minsec == -1) {\n        factor = (im->end - im->start) / im->xsize;\n        xlab_sel = 0;\n        while (xlab[xlab_sel + 1].minsec !=\n               -1 && xlab[xlab_sel + 1].minsec <= factor) {\n            xlab_sel++;\n        }               /* pick the last one */\n        while (xlab[xlab_sel - 1].minsec ==\n               xlab[xlab_sel].minsec\n               && xlab[xlab_sel].length > (im->end - im->start)) {\n            xlab_sel--;\n        }               /* go back to the smallest size */\n        im->xlab_user.gridtm = xlab[xlab_sel].gridtm;\n        im->xlab_user.gridst = xlab[xlab_sel].gridst;\n        im->xlab_user.mgridtm = xlab[xlab_sel].mgridtm;\n        im->xlab_user.mgridst = xlab[xlab_sel].mgridst;\n        im->xlab_user.labtm = xlab[xlab_sel].labtm;\n        im->xlab_user.labst = xlab[xlab_sel].labst;\n        im->xlab_user.precis = xlab[xlab_sel].precis;\n        im->xlab_user.stst = xlab[xlab_sel].stst;\n    }\n\n    /* y coords are the same for every line ... */\n    Y0 = im->yorigin;\n    Y1 = im->yorigin - im->ysize;\n    /* paint the minor grid */\n    if (!(im->extra_flags & NOMINOR)) {\n        for (ti = find_first_time(im->start,\n                                  im->\n                                  xlab_user.\n                                  gridtm,\n                                  im->\n                                  xlab_user.\n                                  gridst),\n             timajor =\n             find_first_time(im->start,\n                             im->xlab_user.\n                             mgridtm,\n                             im->xlab_user.\n                             mgridst);\n             ti < im->end && ti != -1;\n             ti =\n             find_next_time(ti, im->xlab_user.gridtm, im->xlab_user.gridst)\n            ) {\n            /* are we inside the graph ? */\n            if (ti < im->start || ti > im->end)\n                continue;\n            while (timajor < ti && timajor != -1) {\n                timajor = find_next_time(timajor,\n                                         im->\n                                         xlab_user.\n                                         mgridtm, im->xlab_user.mgridst);\n            }\n            if (timajor == -1) break; /* fail in case of problems with time increments */\n            if (ti == timajor)\n                continue;   /* skip as falls on major grid line */\n            X0 = xtr(im, ti);\n            gfx_line(im, X0, Y1 - 2, X0, Y1,\n                     GRIDWIDTH, im->graph_col[GRC_GRID]);\n            gfx_line(im, X0, Y0, X0, Y0 + 2,\n                     GRIDWIDTH, im->graph_col[GRC_GRID]);\n            gfx_dashed_line(im, X0, Y0 + 1, X0,\n                            Y1 - 1, GRIDWIDTH,\n                            im->\n                            graph_col[GRC_GRID],\n                            im->grid_dash_on, im->grid_dash_off);\n        }\n    }\n\n    /* paint the major grid */\n    for (ti = find_first_time(im->start,\n                              im->\n                              xlab_user.\n                              mgridtm,\n                              im->\n                              xlab_user.\n                              mgridst);\n         ti < im->end && ti != -1;\n         ti = find_next_time(ti, im->xlab_user.mgridtm, im->xlab_user.mgridst)\n        ) {\n        /* are we inside the graph ? */\n        if (ti < im->start || ti > im->end)\n            continue;\n        X0 = xtr(im, ti);\n        gfx_line(im, X0, Y1 - 2, X0, Y1,\n                 MGRIDWIDTH, im->graph_col[GRC_MGRID]);\n        gfx_line(im, X0, Y0, X0, Y0 + 3,\n                 MGRIDWIDTH, im->graph_col[GRC_MGRID]);\n        gfx_dashed_line(im, X0, Y0 + 3, X0,\n                        Y1 - 2, MGRIDWIDTH,\n                        im->\n                        graph_col\n                        [GRC_MGRID], im->grid_dash_on, im->grid_dash_off);\n    }\n    /* paint the labels below the graph */\n    for (ti =\n         find_first_time(im->start -\n                         im->xlab_user.\n                         precis / 2,\n                         im->xlab_user.\n                         labtm,\n                         im->xlab_user.\n                         labst);\n         (ti <=\n         im->end -\n         im->xlab_user.precis / 2) && ti != -1;\n         ti = find_next_time(ti, im->xlab_user.labtm, im->xlab_user.labst)\n        ) {\n        tilab = ti + im->xlab_user.precis / 2;  /* correct time for the label */\n        /* are we inside the graph ? */\n        if (tilab < im->start || tilab > im->end)\n            continue;\n#if HAVE_STRFTIME\n        localtime_r(&tilab, &tm);\n        strftime(graph_label, 99, im->xlab_user.stst, &tm);\n#else\n# error \"your libc has no strftime I guess we'll abort the exercise here.\"\n#endif\n        gfx_text(im,\n                 xtr(im, tilab),\n                 Y0 + 3,\n                 im->graph_col[GRC_FONT],\n                 im->\n                 text_prop[TEXT_PROP_AXIS].\n                 font_desc,\n                 im->tabwidth, 0.0,\n                 GFX_H_CENTER, GFX_V_TOP, graph_label);\n    }\n\n}\n\n\nvoid axis_paint(\n    image_desc_t *im)\n{\n    /* draw x and y axis */\n    /* gfx_line ( im->canvas, im->xorigin+im->xsize,im->yorigin,\n       im->xorigin+im->xsize,im->yorigin-im->ysize,\n       GRIDWIDTH, im->graph_col[GRC_AXIS]);\n\n       gfx_line ( im->canvas, im->xorigin,im->yorigin-im->ysize,\n       im->xorigin+im->xsize,im->yorigin-im->ysize,\n       GRIDWIDTH, im->graph_col[GRC_AXIS]); */\n\n    gfx_line(im, im->xorigin - 4,\n             im->yorigin,\n             im->xorigin + im->xsize +\n             4, im->yorigin, MGRIDWIDTH, im->graph_col[GRC_AXIS]);\n    gfx_line(im, im->xorigin,\n             im->yorigin + 4,\n             im->xorigin,\n             im->yorigin - im->ysize -\n             4, MGRIDWIDTH, im->graph_col[GRC_AXIS]);\n    /* arrow for X and Y axis direction */\n    gfx_new_area(im, im->xorigin + im->xsize + 2, im->yorigin - 3, im->xorigin + im->xsize + 2, im->yorigin + 3, im->xorigin + im->xsize + 7, im->yorigin,  /* horyzontal */\n                 im->graph_col[GRC_ARROW]);\n    gfx_close_path(im);\n    gfx_new_area(im, im->xorigin - 3, im->yorigin - im->ysize - 2, im->xorigin + 3, im->yorigin - im->ysize - 2, im->xorigin, im->yorigin - im->ysize - 7,  /* vertical */\n                 im->graph_col[GRC_ARROW]);\n    gfx_close_path(im);\n    if (im->second_axis_scale != 0){\n       gfx_line ( im, im->xorigin+im->xsize,im->yorigin+4,\n                         im->xorigin+im->xsize,im->yorigin-im->ysize-4,\n                         MGRIDWIDTH, im->graph_col[GRC_AXIS]);\n       gfx_new_area ( im,\n                   im->xorigin+im->xsize-2,  im->yorigin-im->ysize-2,\n                   im->xorigin+im->xsize+3,  im->yorigin-im->ysize-2,\n                   im->xorigin+im->xsize,    im->yorigin-im->ysize-7, /* LINEOFFSET */\n                   im->graph_col[GRC_ARROW]);\n       gfx_close_path(im);\n    }\n\n}\n\nvoid grid_paint(\n    image_desc_t *im)\n{\n    long      i;\n    int       res = 0;\n    double    X0, Y0;   /* points for filled graph and more */\n    struct gfx_color_t water_color;\n\n    if (im->draw_3d_border > 0) {\n\t    /* draw 3d border */\n\t    i = im->draw_3d_border;\n\t    gfx_new_area(im, 0, im->yimg,\n\t\t\t i, im->yimg - i, i, i, im->graph_col[GRC_SHADEA]);\n\t    gfx_add_point(im, im->ximg - i, i);\n\t    gfx_add_point(im, im->ximg, 0);\n\t    gfx_add_point(im, 0, 0);\n\t    gfx_close_path(im);\n\t    gfx_new_area(im, i, im->yimg - i,\n\t\t\t im->ximg - i,\n\t\t\t im->yimg - i, im->ximg - i, i, im->graph_col[GRC_SHADEB]);\n\t    gfx_add_point(im, im->ximg, 0);\n\t    gfx_add_point(im, im->ximg, im->yimg);\n\t    gfx_add_point(im, 0, im->yimg);\n\t    gfx_close_path(im);\n    }\n    if (im->draw_x_grid == 1)\n        vertical_grid(im);\n    if (im->draw_y_grid == 1) {\n        if (im->logarithmic) {\n            res = horizontal_log_grid(im);\n        } else {\n            res = draw_horizontal_grid(im);\n        }\n\n        /* dont draw horizontal grid if there is no min and max val */\n        if (!res) {\n            char     *nodata = \"No Data found\";\n\n            gfx_text(im, im->ximg / 2,\n                     (2 * im->yorigin -\n                      im->ysize) / 2,\n                     im->graph_col[GRC_FONT],\n                     im->\n                     text_prop[TEXT_PROP_AXIS].\n                     font_desc,\n                     im->tabwidth, 0.0,\n                     GFX_H_CENTER, GFX_V_CENTER, nodata);\n        }\n    }\n\n    /* yaxis unit description */\n    if (im->ylegend && im->ylegend[0] != '\\0') {\n        gfx_text(im,\n                 im->xOriginLegendY+10,\n                 im->yOriginLegendY,\n                 im->graph_col[GRC_FONT],\n                 im->\n                 text_prop[TEXT_PROP_UNIT].\n                 font_desc,\n                 im->tabwidth,\n                 RRDGRAPH_YLEGEND_ANGLE, GFX_H_CENTER, GFX_V_CENTER, im->ylegend);\n\n    }\n    if (im->second_axis_legend && im->second_axis_legend[0] != '\\0') {\n            gfx_text( im,\n                  im->xOriginLegendY2+10,\n                  im->yOriginLegendY2,\n                  im->graph_col[GRC_FONT],\n                  im->text_prop[TEXT_PROP_UNIT].font_desc,\n                  im->tabwidth,\n                  RRDGRAPH_YLEGEND_ANGLE,\n                  GFX_H_CENTER, GFX_V_CENTER,\n                  im->second_axis_legend);\n    }\n\n    /* graph title */\n    gfx_text(im,\n             im->xOriginTitle, im->yOriginTitle+6,\n             im->graph_col[GRC_FONT],\n             im->\n             text_prop[TEXT_PROP_TITLE].\n             font_desc,\n             im->tabwidth, 0.0, GFX_H_CENTER, GFX_V_TOP, im->title?im->title:\"\");\n    /* rrdtool 'logo' */\n    if (!(im->extra_flags & NO_RRDTOOL_TAG)){\n        water_color = im->graph_col[GRC_FONT];\n        water_color.alpha = 0.3;\n        double xpos = im->legendposition == EAST ? im->xOriginLegendY : im->ximg - 4;\n        gfx_text(im, xpos, 5,\n                 water_color,\n                 im->\n                 text_prop[TEXT_PROP_WATERMARK].\n                 font_desc, im->tabwidth,\n                 -90, GFX_H_LEFT, GFX_V_TOP, \"RRDTOOL / TOBI OETIKER\");\n    }\n    /* graph watermark */\n    if (im->watermark && im->watermark[0] != '\\0') {\n        water_color = im->graph_col[GRC_FONT];\n        water_color.alpha = 0.3;\n        gfx_text(im,\n                 im->ximg / 2, im->yimg - 6,\n                 water_color,\n                 im->\n                 text_prop[TEXT_PROP_WATERMARK].\n                 font_desc, im->tabwidth, 0,\n                 GFX_H_CENTER, GFX_V_BOTTOM, im->watermark);\n    }\n\n    /* graph labels */\n    if (!(im->extra_flags & NOLEGEND) && !(im->extra_flags & ONLY_GRAPH)) {\n        long first_noncomment = im->gdes_c, last_noncomment = 0;\n        /* get smallest and biggest leg_y values. Assumes\n         * im->gdes[i].leg_y is in order. */\n        double min = 0, max = 0;\n        int gotcha = 0;\n        for (i = 0; i < im->gdes_c; i++) {\n            if (im->gdes[i].legend[0] == '\\0')\n                continue;\n            if (!gotcha) {\n                min = im->gdes[i].leg_y;\n                gotcha = 1;\n            }\n            if (im->gdes[i].gf != GF_COMMENT) {\n                if (im->legenddirection == BOTTOM_UP2)\n                    min = im->gdes[i].leg_y;\n                first_noncomment = i;\n                break;\n            }\n        }\n        gotcha = 0;\n        for (i = im->gdes_c - 1; i >= 0; i--) {\n            if (im->gdes[i].legend[0] == '\\0')\n                continue;\n            if (!gotcha) {\n                max = im->gdes[i].leg_y;\n                gotcha = 1;\n            }\n            if (im->gdes[i].gf != GF_COMMENT) {\n                if (im->legenddirection == BOTTOM_UP2)\n                    max = im->gdes[i].leg_y;\n                last_noncomment = i;\n                break;\n            }\n        }\n        for (i = 0; i < im->gdes_c; i++) {\n            if (im->gdes[i].legend[0] == '\\0')\n                continue;\n            /* im->gdes[i].leg_y is the bottom of the legend */\n            X0 = im->xOriginLegend + im->gdes[i].leg_x;\n            int reverse = 0;\n            switch (im->legenddirection) {\n                case TOP_DOWN:\n                    reverse = 0;\n                    break;\n                case BOTTOM_UP:\n                    reverse = 1;\n                    break;\n                case BOTTOM_UP2:\n                    reverse = i >= first_noncomment && i <= last_noncomment;\n                    break;\n            }\n            Y0 = reverse ?\n                im->yOriginLegend + max + min - im->gdes[i].leg_y :\n                im->yOriginLegend + im->gdes[i].leg_y;\n            gfx_text(im, X0, Y0,\n                     im->graph_col[GRC_FONT],\n                     im->\n                     text_prop\n                     [TEXT_PROP_LEGEND].font_desc,\n                     im->tabwidth, 0.0,\n                     GFX_H_LEFT, GFX_V_BOTTOM, im->gdes[i].legend);\n            /* The legend for GRAPH items starts with \"M \" to have\n               enough space for the box */\n            if (im->gdes[i].gf != GF_PRINT &&\n                im->gdes[i].gf != GF_GPRINT && im->gdes[i].gf != GF_COMMENT) {\n                double    boxH, boxV;\n                double    X1, Y1;\n\n                boxH = gfx_get_text_width(im, 0,\n                                          im->\n                                          text_prop\n                                          [TEXT_PROP_LEGEND].\n                                          font_desc,\n                                          im->tabwidth, \"o\") * 1.2;\n                boxV = boxH;\n                /* shift the box up a bit */\n                Y0 -= boxV * 0.4;\n\n        if (im->dynamic_labels && im->gdes[i].gf == GF_HRULE) { /* [-] */ \n\t\t\tcairo_save(im->cr);\n\t\t\tcairo_new_path(im->cr);\n\t\t\tcairo_set_line_width(im->cr, 1.0);\n\t\t\tgfx_line(im,\n\t\t\t\tX0, Y0 - boxV / 2,\n\t\t\t\tX0 + boxH, Y0 - boxV / 2,\n\t\t\t\t1.0, im->gdes[i].col);\n            \t\tgfx_close_path(im);\n\t\t} else if (im->dynamic_labels && im->gdes[i].gf == GF_VRULE) { /* [|] */\n\t\t\tcairo_save(im->cr);\n\t\t\tcairo_new_path(im->cr);\n\t\t\tcairo_set_line_width(im->cr, 1.0);\n\t\t\tgfx_line(im,\n\t\t\t\tX0 + boxH / 2, Y0,\n\t\t\t\tX0 + boxH / 2, Y0 - boxV,\n\t\t\t\t1.0, im->gdes[i].col);\n            \t\tgfx_close_path(im);\n\t\t} else if (im->dynamic_labels && im->gdes[i].gf == GF_LINE) { /* [/] */\n\t\t\tcairo_save(im->cr);\n\t\t\tcairo_new_path(im->cr);\n\t\t\tcairo_set_line_width(im->cr, im->gdes[i].linewidth);\n\t\t\tgfx_line(im,\n\t\t\t\tX0, Y0,\n\t\t\t\tX0 + boxH, Y0 - boxV,\n\t\t\t\tim->gdes[i].linewidth, im->gdes[i].col);\n            \t\tgfx_close_path(im);\n\t\t} else {\n\t\t/* make sure transparent colors show up the same way as in the graph */\n\t\t\tgfx_new_area(im,\n\t\t\t\t     X0, Y0 - boxV,\n\t\t\t\t     X0, Y0, X0 + boxH, Y0, im->graph_col[GRC_BACK]);\n\t\t\tgfx_add_point(im, X0 + boxH, Y0 - boxV);\n\t\t\tgfx_close_path(im);\n\t\t\tgfx_new_area(im, X0, Y0 - boxV, X0,\n\t\t\t\t     Y0, X0 + boxH, Y0, im->gdes[i].col);\n\t\t\tgfx_add_point(im, X0 + boxH, Y0 - boxV);\n\t\t\tgfx_close_path(im);\n\t\t\tcairo_save(im->cr);\n\t\t\tcairo_new_path(im->cr);\n\t\t\tcairo_set_line_width(im->cr, 1.0);\n\t\t\tX1 = X0 + boxH;\n\t\t\tY1 = Y0 - boxV;\n\t\t\tgfx_line_fit(im, &X0, &Y0);\n\t\t\tgfx_line_fit(im, &X1, &Y1);\n\t\t\tcairo_move_to(im->cr, X0, Y0);\n\t\t\tcairo_line_to(im->cr, X1, Y0);\n\t\t\tcairo_line_to(im->cr, X1, Y1);\n\t\t\tcairo_line_to(im->cr, X0, Y1);\n\t\t\tcairo_close_path(im->cr);\n\t\t\tcairo_set_source_rgba(im->cr,\n\t\t\t\t\t      im->graph_col[GRC_FRAME].red,\n\t\t\t\t\t      im->graph_col[GRC_FRAME].green,\n\t\t\t\t\t      im->graph_col[GRC_FRAME].blue,\n\t\t\t\t\t      im->graph_col[GRC_FRAME].alpha);\n\t\t}\n                if (im->gdes[i].dash) {\n                    /* make box borders in legend dashed if the graph is dashed */\n                    double    dashes[] = {\n                        3.0\n                    };\n                    cairo_set_dash(im->cr, dashes, 1, 0.0);\n                }\n                cairo_stroke(im->cr);\n                cairo_restore(im->cr);\n            }\n        }\n    }\n}\n\n\n/*****************************************************\n * lazy check make sure we rely need to create this graph\n *****************************************************/\n\nint lazy_check(\n    image_desc_t *im)\n{\n    FILE     *fd = NULL;\n    int       size = 1;\n    struct stat imgstat;\n\n    if (im->lazy == 0)\n        return 0;       /* no lazy option */\n    if (strlen(im->graphfile) == 0)\n        return 0;       /* inmemory option */\n    if (stat(im->graphfile, &imgstat) != 0)\n        return 0;       /* can't stat */\n    /* one pixel in the existing graph is more then what we would\n       change here ... */\n    if (time(NULL) - imgstat.st_mtime > (im->end - im->start) / im->xsize)\n        return 0;\n    if ((fd = fopen(im->graphfile, \"rb\")) == NULL)\n        return 0;       /* the file does not exist */\n    switch (im->imgformat) {\n    case IF_PNG:\n        size = PngSize(fd, &(im->ximg), &(im->yimg));\n        break;\n    default:\n        size = 1;\n    }\n    fclose(fd);\n    return size;\n}\n\n\nint graph_size_location(\n    image_desc_t\n    *im,\n    int elements)\n{\n    /* The actual size of the image to draw is determined from\n     ** several sources.  The size given on the command line is\n     ** the graph area but we need more as we have to draw labels\n     ** and other things outside the graph area. If the option\n     ** --full-size-mode is selected the size defines the total\n     ** image size and the size available for the graph is\n     ** calculated.\n     */\n\n    /** +---+-----------------------------------+\n     ** | y |...............graph title.........|\n     ** |   +---+-------------------------------+\n     ** | a | y |                               |\n     ** | x |   |                               |\n     ** | i | a |                               |\n     ** | s | x |       main graph area         |\n     ** |   | i |                               |\n     ** | t | s |                               |\n     ** | i |   |                               |\n     ** | t | l |                               |\n     ** | l | b +-------------------------------+\n     ** | e | l |       x axis labels           |\n     ** +---+---+-------------------------------+\n     ** |....................legends............|\n     ** +---------------------------------------+\n     ** |                   watermark           |\n     ** +---------------------------------------+\n     */\n\n    int       Xvertical = 0, Xvertical2 = 0, Ytitle =\n        0, Xylabel = 0, Xmain = 0, Ymain =\n        0, Yxlabel = 0, Xspacing = 15, Yspacing = 15, Ywatermark = 4;\n\n    // no legends and no the shall be plotted it's easy\n    if (im->extra_flags & ONLY_GRAPH) {\n        im->xorigin = 0;\n        im->ximg = im->xsize;\n        im->yimg = im->ysize;\n        im->yorigin = im->ysize;\n        xtr(im, 0);\n        ytr(im, DNAN);\n        return 0;\n    }\n\n    if (im->watermark && im->watermark[0] != '\\0') {\n        Ywatermark = im->text_prop[TEXT_PROP_WATERMARK].size * 2;\n    }\n\n    // calculate the width of the left vertical legend\n    if (im->ylegend && im->ylegend[0] != '\\0') {\n        Xvertical = im->text_prop[TEXT_PROP_UNIT].size * 2;\n    }\n\n    // calculate the width of the right vertical legend\n    if (im->second_axis_legend && im->second_axis_legend[0] != '\\0') {\n        Xvertical2 = im->text_prop[TEXT_PROP_UNIT].size * 2;\n    }\n    else{\n        Xvertical2 = Xspacing;\n    }\n\n    if (im->title && im->title[0] != '\\0') {\n        /* The title is placed \"inbetween\" two text lines so it\n         ** automatically has some vertical spacing.  The horizontal\n         ** spacing is added here, on each side.\n         */\n        /* if necessary, reduce the font size of the title until it fits the image width */\n        Ytitle = im->text_prop[TEXT_PROP_TITLE].size * 2.6 + 10;\n    }\n    else{\n        // we have no title; get a little clearing from the top\n        Ytitle = Yspacing;\n    }\n\n    if (elements) {\n        if (im->draw_x_grid) {\n            // calculate the height of the horizontal labelling\n            Yxlabel = im->text_prop[TEXT_PROP_AXIS].size * 2.5;\n        }\n        if (im->draw_y_grid || im->forceleftspace) {\n            // calculate the width of the vertical labelling\n            Xylabel =\n                gfx_get_text_width(im, 0,\n                                   im->text_prop[TEXT_PROP_AXIS].font_desc,\n                                   im->tabwidth, \"0\") * im->unitslength;\n        }\n    }\n\n    // add some space to the labelling\n    Xylabel += Xspacing;\n\n    /* If the legend is printed besides the graph the width has to be\n     ** calculated first. Placing the legend north or south of the\n     ** graph requires the width calculation first, so the legend is\n     ** skipped for the moment.\n     */\n    im->legendheight = 0;\n    im->legendwidth = 0;\n    if (!(im->extra_flags & NOLEGEND)) {\n        if(im->legendposition == WEST || im->legendposition == EAST){\n            if (leg_place(im, 1) == -1){\n                return -1;\n            }\n        }\n    }\n\n    if (im->extra_flags & FULL_SIZE_MODE) {\n\n        /* The actual size of the image to draw has been determined by the user.\n         ** The graph area is the space remaining after accounting for the legend,\n         ** the watermark, the axis labels, and the title.\n         */\n        im->ximg = im->xsize;\n        im->yimg = im->ysize;\n        Xmain = im->ximg;\n        Ymain = im->yimg;\n\n        /* Now calculate the total size.  Insert some spacing where\n           desired.  im->xorigin and im->yorigin need to correspond\n           with the lower left corner of the main graph area or, if\n           this one is not set, the imaginary box surrounding the\n           pie chart area. */\n        /* Initial size calculation for the main graph area */\n\n        Xmain -= Xylabel;// + Xspacing;\n        if((im->legendposition == WEST || im->legendposition == EAST) && !(im->extra_flags & NOLEGEND) ){\n            Xmain -= im->legendwidth;// + Xspacing;\n        }\n        if (im->second_axis_scale != 0){\n            Xmain -= Xylabel;\n        }\n        if (!(im->extra_flags & NO_RRDTOOL_TAG)){\n            Xmain -= Xspacing;\n        }\n\n        Xmain -= Xvertical + Xvertical2;\n\n        /* limit the remaining space to 0 */\n        if(Xmain < 1){\n            Xmain = 1;\n        }\n        im->xsize = Xmain;\n\n        /* Putting the legend north or south, the height can now be calculated */\n        if (!(im->extra_flags & NOLEGEND)) {\n            if(im->legendposition == NORTH || im->legendposition == SOUTH){\n                im->legendwidth = im->ximg;\n                if (leg_place(im, 0) == -1){\n                    return -1;\n                }\n            }\n        }\n\n        if( (im->legendposition == NORTH || im->legendposition == SOUTH)  && !(im->extra_flags & NOLEGEND) ){\n            Ymain -=  Yxlabel + im->legendheight;\n        }\n        else{\n            Ymain -= Yxlabel;\n        }\n\n        /* reserve space for the title *or* some padding above the graph */\n        Ymain -= Ytitle;\n\n            /* reserve space for padding below the graph */\n        if (im->extra_flags & NOLEGEND) {\n            Ymain -= 0.5*Yspacing;\n        }\n\n        if (im->watermark && im->watermark[0] != '\\0') {\n            Ymain -= Ywatermark;\n        }\n        /* limit the remaining height to 0 */\n        if(Ymain < 1){\n            Ymain = 1;\n        }\n        im->ysize = Ymain;\n    } else {            /* dimension options -width and -height refer to the dimensions of the main graph area */\n\n        /* The actual size of the image to draw is determined from\n         ** several sources.  The size given on the command line is\n         ** the graph area but we need more as we have to draw labels\n         ** and other things outside the graph area.\n         */\n\n        if (elements) {\n            Xmain = im->xsize; // + Xspacing;\n            Ymain = im->ysize;\n        }\n\n        im->ximg = Xmain + Xylabel;\n        if (!(im->extra_flags & NO_RRDTOOL_TAG)){\n            im->ximg += Xspacing;\n        }\n\n        if( (im->legendposition == WEST || im->legendposition == EAST) && !(im->extra_flags & NOLEGEND) ){\n            im->ximg += im->legendwidth;// + Xspacing;\n        }\n        if (im->second_axis_scale != 0){\n            im->ximg += Xylabel;\n        }\n\n        im->ximg += Xvertical + Xvertical2;\n\n        if (!(im->extra_flags & NOLEGEND)) {\n            if(im->legendposition == NORTH || im->legendposition == SOUTH){\n                im->legendwidth = im->ximg;\n                if (leg_place(im, 0) == -1){\n                    return -1;\n                }\n            }\n        }\n\n        im->yimg = Ymain + Yxlabel;\n        if( (im->legendposition == NORTH || im->legendposition == SOUTH)  && !(im->extra_flags & NOLEGEND) ){\n             im->yimg += im->legendheight;\n        }\n\n        /* reserve space for the title *or* some padding above the graph */\n        if (Ytitle) {\n            im->yimg += Ytitle;\n        } else {\n            im->yimg += 1.5 * Yspacing;\n        }\n        /* reserve space for padding below the graph */\n        if (im->extra_flags & NOLEGEND) {\n            im->yimg += 0.5*Yspacing;\n        }\n\n        if (im->watermark && im->watermark[0] != '\\0') {\n            im->yimg += Ywatermark;\n        }\n    }\n\n\n    /* In case of putting the legend in west or east position the first\n     ** legend calculation might lead to wrong positions if some items\n     ** are not aligned on the left hand side (e.g. centered) as the\n     ** legendwidth wight have been increased after the item was placed.\n     ** In this case the positions have to be recalculated.\n     */\n    if (!(im->extra_flags & NOLEGEND)) {\n        if(im->legendposition == WEST || im->legendposition == EAST){\n            if (leg_place(im, 0) == -1){\n                return -1;\n            }\n        }\n    }\n\n    /* After calculating all dimensions\n     ** it is now possible to calculate\n     ** all offsets.\n     */\n    switch(im->legendposition){\n        case NORTH:\n            im->xOriginTitle   = (im->ximg / 2);\n            im->yOriginTitle   = 0;\n\n            im->xOriginLegend  = 0;\n            im->yOriginLegend  = Ytitle;\n\n            im->xOriginLegendY = 0;\n            im->yOriginLegendY = Ytitle + im->legendheight + (Ymain / 2) + Yxlabel;\n\n            im->xorigin        = Xvertical + Xylabel;\n            im->yorigin        = Ytitle + im->legendheight + Ymain;\n\n            im->xOriginLegendY2 = Xvertical + Xylabel + Xmain;\n            if (im->second_axis_scale != 0){\n                im->xOriginLegendY2 += Xylabel;\n            }\n            im->yOriginLegendY2 = Ytitle + im->legendheight + (Ymain / 2) + Yxlabel;\n\n            break;\n\n        case WEST:\n            im->xOriginTitle   = im->legendwidth + im->xsize / 2;\n            im->yOriginTitle   = 0;\n\n            im->xOriginLegend  = 0;\n            im->yOriginLegend  = Ytitle;\n\n            im->xOriginLegendY = im->legendwidth;\n            im->yOriginLegendY = Ytitle + (Ymain / 2);\n\n            im->xorigin        = im->legendwidth + Xvertical + Xylabel;\n            im->yorigin        = Ytitle + Ymain;\n\n            im->xOriginLegendY2 = im->legendwidth + Xvertical + Xylabel + Xmain;\n            if (im->second_axis_scale != 0){\n                im->xOriginLegendY2 += Xylabel;\n            }\n            im->yOriginLegendY2 = Ytitle + (Ymain / 2);\n\n            break;\n\n        case SOUTH:\n            im->xOriginTitle   = im->ximg / 2;\n            im->yOriginTitle   = 0;\n\n            im->xOriginLegend  = 0;\n            im->yOriginLegend  = Ytitle + Ymain + Yxlabel;\n\n            im->xOriginLegendY = 0;\n            im->yOriginLegendY = Ytitle + (Ymain / 2);\n\n            im->xorigin        = Xvertical + Xylabel;\n            im->yorigin        = Ytitle + Ymain;\n\n            im->xOriginLegendY2 = Xvertical + Xylabel + Xmain;\n            if (im->second_axis_scale != 0){\n                im->xOriginLegendY2 += Xylabel;\n            }\n            im->yOriginLegendY2 = Ytitle + (Ymain / 2);\n\n            break;\n\n        case EAST:\n            im->xOriginTitle   = im->xsize / 2;\n            im->yOriginTitle   = 0;\n\n            im->xOriginLegend  = Xvertical + Xylabel + Xmain + Xvertical2;\n            if (im->second_axis_scale != 0){\n                im->xOriginLegend += Xylabel;\n            }\n            im->yOriginLegend  = Ytitle;\n\n            im->xOriginLegendY = 0;\n            im->yOriginLegendY = Ytitle + (Ymain / 2);\n\n            im->xorigin        = Xvertical + Xylabel;\n            im->yorigin        = Ytitle + Ymain;\n\n            im->xOriginLegendY2 = Xvertical + Xylabel + Xmain;\n            if (im->second_axis_scale != 0){\n                im->xOriginLegendY2 += Xylabel;\n            }\n            im->yOriginLegendY2 = Ytitle + (Ymain / 2);\n\n            if (!(im->extra_flags & NO_RRDTOOL_TAG)){\n                im->xOriginTitle    += Xspacing;\n                im->xOriginLegend   += Xspacing;\n                im->xOriginLegendY  += Xspacing;\n                im->xorigin         += Xspacing;\n                im->xOriginLegendY2 += Xspacing;\n            }\n            break;\n    }\n\n    xtr(im, 0);\n    ytr(im, DNAN);\n    return 0;\n}\n\nstatic cairo_status_t cairo_output(\n    void *closure,\n    const unsigned char\n    *data,\n    unsigned int length)\n{\n    image_desc_t *im = (image_desc_t*)closure;\n\n    im->rendered_image =\n        (unsigned char*)realloc(im->rendered_image, im->rendered_image_size + length);\n    if (im->rendered_image == NULL)\n        return CAIRO_STATUS_WRITE_ERROR;\n    memcpy(im->rendered_image + im->rendered_image_size, data, length);\n    im->rendered_image_size += length;\n    return CAIRO_STATUS_SUCCESS;\n}\n\n/* draw that picture thing ... */\nint graph_paint(\n    image_desc_t *im)\n{\n    int       lazy = lazy_check(im);\n    int       cnt;      \n\n    /* imgformat XML or higher dispatch to xport \n     * output format there is selected via graph_type \n     */\n    if (im->imgformat >= IF_XML) {\n      return rrd_graph_xport(im);\n    }\n\n    /* pull the data from the rrd files ... */\n    if (data_fetch(im) == -1)\n        return -1;\n    /* evaluate VDEF and CDEF operations ... */\n    if (data_calc(im) == -1)\n        return -1;\n    /* calculate and PRINT and GPRINT definitions. We have to do it at\n     * this point because it will affect the length of the legends\n     * if there are no graph elements (i==0) we stop here ...\n     * if we are lazy, try to quit ...\n     */\n    cnt = print_calc(im);\n    if (cnt < 0)\n        return -1;\n\n    /* if we want and can be lazy ... quit now */\n    if (cnt == 0)\n        return 0;\n\n    /* otherwise call graph_paint_timestring */\n    switch (im->graph_type) {\n    case GTYPE_TIME:\n      return graph_paint_timestring(im,lazy,cnt);\n      break;\n    case GTYPE_XY:\n      return graph_paint_xy(im,lazy,cnt);\n      break;      \n    }\n    /* final return with error*/\n    rrd_set_error(\"Graph type %i is not implemented\",im->graph_type);\n    return -1;\n}\n\nint graph_paint_timestring(\n                          image_desc_t *im, int lazy, int cnt)\n{\n    int       i,ii;\n    double    areazero = 0.0;\n    graph_desc_t *lastgdes = NULL;\n    rrd_infoval_t info;\n\n/**************************************************************\n *** Calculating sizes and locations became a bit confusing ***\n *** so I moved this into a separate function.              ***\n **************************************************************/\n    if (graph_size_location(im, cnt) == -1)\n        return -1;\n\n    info.u_cnt = im->xorigin;\n    grinfo_push(im, sprintf_alloc(\"graph_left\"), RD_I_CNT, info);\n    info.u_cnt = im->yorigin - im->ysize;\n    grinfo_push(im, sprintf_alloc(\"graph_top\"), RD_I_CNT, info);\n    info.u_cnt = im->xsize;\n    grinfo_push(im, sprintf_alloc(\"graph_width\"), RD_I_CNT, info);\n    info.u_cnt = im->ysize;\n    grinfo_push(im, sprintf_alloc(\"graph_height\"), RD_I_CNT, info);\n    info.u_cnt = im->ximg;\n    grinfo_push(im, sprintf_alloc(\"image_width\"), RD_I_CNT, info);\n    info.u_cnt = im->yimg;\n    grinfo_push(im, sprintf_alloc(\"image_height\"), RD_I_CNT, info);\n    info.u_cnt = im->start;\n    grinfo_push(im, sprintf_alloc(\"graph_start\"), RD_I_CNT, info);\n    info.u_cnt = im->end;\n    grinfo_push(im, sprintf_alloc(\"graph_end\"), RD_I_CNT, info);\n\n    /* if we want and can be lazy ... quit now */\n    if (lazy)\n        return 0;\n\n    /* get actual drawing data and find min and max values */\n    if (data_proc(im) == -1)\n        return -1;\n    if (!im->logarithmic) {\n        si_unit(im);\n    }\n\n    /* identify si magnitude Kilo, Mega Giga ? */\n    if (!im->rigid && !im->logarithmic)\n        expand_range(im);   /* make sure the upper and lower limit are\n                               sensible values */\n\n    info.u_val = im->minval;\n    grinfo_push(im, sprintf_alloc(\"value_min\"), RD_I_VAL, info);\n    info.u_val = im->maxval;\n    grinfo_push(im, sprintf_alloc(\"value_max\"), RD_I_VAL, info);\n\n\n    if (!calc_horizontal_grid(im))\n        return -1;\n    /* reset precalc */\n    ytr(im, DNAN);\n/*   if (im->gridfit)\n     apply_gridfit(im); */\n\n    /* set up cairo */\n    if (graph_cairo_setup(im)) { return -1; }\n\n    /* other stuff */\n    if (im->minval > 0.0)\n        areazero = im->minval;\n    if (im->maxval < 0.0)\n        areazero = im->maxval;\n    for (i = 0; i < im->gdes_c; i++) {\n        switch (im->gdes[i].gf) {\n        case GF_CDEF:\n        case GF_VDEF:\n        case GF_DEF:\n        case GF_PRINT:\n        case GF_GPRINT:\n        case GF_COMMENT:\n        case GF_TEXTALIGN:\n        case GF_HRULE:\n        case GF_VRULE:\n        case GF_XPORT:\n        case GF_SHIFT:\n        case GF_XAXIS:\n        case GF_YAXIS:\n            break;\n        case GF_TICK:\n            for (ii = 0; ii < im->xsize; ii++) {\n                if (!isnan(im->gdes[i].p_data[ii])\n                    && im->gdes[i].p_data[ii] != 0.0) {\n                    if (im->gdes[i].yrule > 0) {\n                        gfx_line(im,\n                                 im->xorigin + ii,\n                                 im->yorigin + 1.0,\n                                 im->xorigin + ii,\n                                 im->yorigin -\n                                 im->gdes[i].yrule *\n                                 im->ysize, 1.0, im->gdes[i].col);\n                    } else if (im->gdes[i].yrule < 0) {\n                        gfx_line(im,\n                                 im->xorigin + ii,\n                                 im->yorigin - im->ysize - 1.0,\n                                 im->xorigin + ii,\n                                 im->yorigin - im->ysize -\n                                                im->gdes[i].\n                                                yrule *\n                                 im->ysize, 1.0, im->gdes[i].col);\n                    }\n                }\n            }\n            break;\n        case GF_LINE:\n        case GF_AREA:\n        case GF_GRAD: {\n            rrd_value_t diffval = im->maxval - im->minval;\n            rrd_value_t maxlimit = im->maxval + 9 * diffval;\n            rrd_value_t minlimit = im->minval - 9 * diffval;        \n            for (ii = 0; ii < im->xsize; ii++) {\n                /* fix data points at oo and -oo */\n                if (isinf(im->gdes[i].p_data[ii])) {\n                    if (im->gdes[i].p_data[ii] > 0) {\n                        im->gdes[i].p_data[ii] = im->maxval;\n                    } else {\n                        im->gdes[i].p_data[ii] = im->minval;\n                    }\n                }\n                /* some versions of cairo go unstable when trying\n                   to draw way out of the canvas ... lets not even try */\n               if (im->gdes[i].p_data[ii] > maxlimit) {\n                   im->gdes[i].p_data[ii] = maxlimit;\n               }\n               if (im->gdes[i].p_data[ii] < minlimit) {\n                   im->gdes[i].p_data[ii] = minlimit;\n               }\n            }           /* for */\n\n            /* *******************************************************\n               a           ___. (a,t)\n               |   |    ___\n               ____|   |   |   |\n               |       |___|\n               -------|--t-1--t--------------------------------\n\n               if we know the value at time t was a then\n               we draw a square from t-1 to t with the value a.\n\n               ********************************************************* */\n            if (im->gdes[i].col.alpha != 0.0) {\n                /* GF_LINE and friend */\n                if (im->gdes[i].gf == GF_LINE) {\n                    double    last_y = 0.0;\n                    int       draw_on = 0;\n\n                    cairo_save(im->cr);\n                    cairo_new_path(im->cr);\n                    cairo_set_line_width(im->cr, im->gdes[i].linewidth);\n                    if (im->gdes[i].dash) {\n                        cairo_set_dash(im->cr,\n                                       im->gdes[i].p_dashes,\n                                       im->gdes[i].ndash, im->gdes[i].offset);\n                    }\n\n                    for (ii = 1; ii < im->xsize; ii++) {\n                        if (isnan(im->gdes[i].p_data[ii])\n                            || (im->slopemode == 1\n                                && isnan(im->gdes[i].p_data[ii - 1]))) {\n                            draw_on = 0;\n                            continue;\n                        }\n                        if (draw_on == 0) {\n                            last_y = ytr(im, im->gdes[i].p_data[ii]);\n                            if (im->slopemode == 0) {\n                                double    x = ii - 1 + im->xorigin;\n                                double    y = last_y;\n\n                                gfx_line_fit(im, &x, &y);\n                                cairo_move_to(im->cr, x, y);\n                                x = ii + im->xorigin;\n                                y = last_y;\n                                gfx_line_fit(im, &x, &y);\n                                cairo_line_to(im->cr, x, y);\n                            } else {\n                                double    x = ii - 1 + im->xorigin;\n                                double    y =\n                                    ytr(im, im->gdes[i].p_data[ii - 1]);\n                                gfx_line_fit(im, &x, &y);\n                                cairo_move_to(im->cr, x, y);\n                                x = ii + im->xorigin;\n                                y = last_y;\n                                gfx_line_fit(im, &x, &y);\n                                cairo_line_to(im->cr, x, y);\n                            }\n                            draw_on = 1;\n                        } else {\n                            double    x1 = ii + im->xorigin;\n                            double    y1 = ytr(im, im->gdes[i].p_data[ii]);\n\n                            if (im->slopemode == 0\n                                && !AlmostEqual2sComplement(y1, last_y, 4)) {\n                                double    x = ii - 1 + im->xorigin;\n                                double    y = y1;\n\n                                gfx_line_fit(im, &x, &y);\n                                cairo_line_to(im->cr, x, y);\n                            };\n                            last_y = y1;\n                            gfx_line_fit(im, &x1, &y1);\n                            cairo_line_to(im->cr, x1, y1);\n                        };\n                    }\n                    cairo_set_source_rgba(im->cr,\n                                          im->gdes[i].\n                                          col.red,\n                                          im->gdes[i].\n                                          col.green,\n                                          im->gdes[i].\n                                          col.blue, im->gdes[i].col.alpha);\n                    cairo_set_line_cap(im->cr, CAIRO_LINE_CAP_ROUND);\n                    cairo_set_line_join(im->cr, CAIRO_LINE_JOIN_ROUND);\n                    cairo_stroke(im->cr);\n                    cairo_restore(im->cr);\n                } else {\n\t\t\t\t\tdouble lastx=0;\n\t\t\t\t\tdouble lasty=0;\n                    int       idxI = -1;\n                    double   *foreY =\n                        (double *) malloc(sizeof(double) * im->xsize * 2);\n                    double   *foreX =\n                        (double *) malloc(sizeof(double) * im->xsize * 2);\n                    double   *backY =\n                        (double *) malloc(sizeof(double) * im->xsize * 2);\n                    double   *backX =\n                        (double *) malloc(sizeof(double) * im->xsize * 2);\n                    int       drawem = 0;\n\n                    for (ii = 0; ii <= im->xsize; ii++) {\n                        double    ybase, ytop;\n\n                        if (idxI > 0 && (drawem != 0 || ii == im->xsize)) {\n                            int       cntI = 1;\n                            int       lastI = 0;\n\n                            while (cntI < idxI\n                                   &&\n                                   AlmostEqual2sComplement(foreY\n                                                           [lastI],\n                                                           foreY[cntI], 4)\n                                   &&\n                                   AlmostEqual2sComplement(foreY\n                                                           [lastI],\n                                                           foreY\n                                                           [cntI + 1], 4)) {\n                                cntI++;\n                            }\n\t\t\t\t\t\t\tif (im->gdes[i].gf != GF_GRAD) {\n                            \tgfx_new_area(im,\n                            \t             backX[0], backY[0],\n                            \t             foreX[0], foreY[0],\n                            \t             foreX[cntI],\n                            \t             foreY[cntI], im->gdes[i].col);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlastx = foreX[cntI];\n\t\t\t\t\t\t\t\tlasty = foreY[cntI];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\twhile (cntI < idxI) {\n                                lastI = cntI;\n                                cntI++;\n                                while (cntI < idxI\n                                       &&\n                                       AlmostEqual2sComplement(foreY\n                                                               [lastI],\n                                                               foreY[cntI], 4)\n                                       &&\n                                       AlmostEqual2sComplement(foreY\n                                                               [lastI],\n                                                               foreY\n                                                               [cntI\n                                                                + 1], 4)) {\n                                    cntI++;\n                                }\n\t\t\t\t\t\t\t\tif (im->gdes[i].gf != GF_GRAD) {\n\t                                gfx_add_point(im, foreX[cntI], foreY[cntI]);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tgfx_add_rect_fadey(im, \n\t\t\t\t\t\t\t\t\t\tlastx, foreY[0],\n\t\t\t\t\t\t\t\t\t\tforeX[cntI], foreY[cntI], lasty, \n\t\t\t\t\t\t\t\t\t\tim->gdes[i].col,\n\t\t\t\t\t\t\t\t\t\tim->gdes[i].col2,\n\t\t\t\t\t\t\t\t\t\tim->gdes[i].gradheight\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tlastx = foreX[cntI];\n\t\t\t\t\t\t\t\t\tlasty = foreY[cntI];\n\t\t\t\t\t\t\t\t}\n                            }\n\t\t\t\t\t\t\tif (im->gdes[i].gf != GF_GRAD) {\n                            \tgfx_add_point(im, backX[idxI], backY[idxI]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tgfx_add_rect_fadey(im,\n\t\t\t\t\t\t\t\t\tlastx, foreY[0],\n\t\t\t\t\t\t\t\t\tbackX[idxI], backY[idxI], lasty,\n\t\t\t\t\t\t\t\t\tim->gdes[i].col,\n\t\t\t\t\t\t\t\t\tim->gdes[i].col2,\n\t\t\t\t\t\t\t\t\tim->gdes[i].gradheight);\n\t\t\t\t\t\t\t\tlastx = backX[idxI];\n\t\t\t\t\t\t\t\tlasty = backY[idxI];\n\t\t\t\t\t\t\t}\n                            while (idxI > 1) {\n                                lastI = idxI;\n                                idxI--;\n                                while (idxI > 1\n                                       &&\n                                       AlmostEqual2sComplement(backY\n                                                               [lastI],\n                                                               backY[idxI], 4)\n                                       &&\n                                       AlmostEqual2sComplement(backY\n                                                               [lastI],\n                                                               backY\n                                                               [idxI\n                                                                - 1], 4)) {\n                                    idxI--;\n                                }\n\t\t\t\t\t\t\t\tif (im->gdes[i].gf != GF_GRAD) {\n\t                                gfx_add_point(im, backX[idxI], backY[idxI]);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tgfx_add_rect_fadey(im,\n\t\t\t\t\t\t\t\t\t\tlastx, foreY[0],\n\t\t\t\t\t\t\t\t\t\tbackX[idxI], backY[idxI], lasty,\n\t\t\t\t\t\t\t\t\t\tim->gdes[i].col,\n\t\t\t\t\t\t\t\t\t\tim->gdes[i].col2,\n\t\t\t\t\t\t\t\t\t\tim->gdes[i].gradheight);\n\t\t\t\t\t\t\t\t\tlastx = backX[idxI];\n\t\t\t\t\t\t\t\t\tlasty = backY[idxI];\n\t\t\t\t\t\t\t\t}\n                            }\n                            idxI = -1;\n                            drawem = 0;\n\t\t\t\t\t\t\tif (im->gdes[i].gf != GF_GRAD) \n\t                            gfx_close_path(im);\n                        }\n                        if (drawem != 0) {\n                            drawem = 0;\n                            idxI = -1;\n                        }\n                        if (ii == im->xsize)\n                            break;\n                        if (im->slopemode == 0 && ii == 0) {\n                            continue;\n                        }\n                        if (isnan(im->gdes[i].p_data[ii])) {\n                            drawem = 1;\n                            continue;\n                        }\n                        ytop = ytr(im, im->gdes[i].p_data[ii]);\n                        if (lastgdes && im->gdes[i].stack) {\n                            ybase = ytr(im, lastgdes->p_data[ii]);\n                        } else {\n                            ybase = ytr(im, areazero);\n                        }\n                        if (ybase == ytop) {\n                            drawem = 1;\n                            continue;\n                        }\n\n                        if (ybase > ytop) {\n                            double    extra = ytop;\n\n                            ytop = ybase;\n                            ybase = extra;\n                        }\n                        if (im->slopemode == 0) {\n                            backY[++idxI] = ybase - 0.2;\n                            backX[idxI] = ii + im->xorigin - 1;\n                            foreY[idxI] = ytop + 0.2;\n                            foreX[idxI] = ii + im->xorigin - 1;\n                        }\n                        backY[++idxI] = ybase - 0.2;\n                        backX[idxI] = ii + im->xorigin;\n                        foreY[idxI] = ytop + 0.2;\n                        foreX[idxI] = ii + im->xorigin;\n                    }\n                    /* close up any remaining area */\n                    free(foreY);\n                    free(foreX);\n                    free(backY);\n                    free(backX);\n                }       /* else GF_LINE */\n            }\n            /* if color != 0x0 */\n            /* make sure we do not run into trouble when stacking on NaN */\n            for (ii = 0; ii < im->xsize; ii++) {\n                if (isnan(im->gdes[i].p_data[ii])) {\n                    if (lastgdes && (im->gdes[i].stack)) {\n                        im->gdes[i].p_data[ii] = lastgdes->p_data[ii];\n                    } else {\n                        im->gdes[i].p_data[ii] = areazero;\n                    }\n                }\n            }\n            lastgdes = &(im->gdes[i]);\n            break;\n        } /* GF_AREA, GF_LINE, GF_GRAD */\n        case GF_STACK:\n            rrd_set_error\n                (\"STACK should already be turned into LINE or AREA here\");\n            return -1;\n            break;\n        }               /* switch */\n    }\n    cairo_reset_clip(im->cr);\n\n    /* grid_paint also does the text */\n    if (!(im->extra_flags & ONLY_GRAPH))\n        grid_paint(im);\n    if (!(im->extra_flags & ONLY_GRAPH))\n        axis_paint(im);\n    /* the RULES are the last thing to paint ... */\n    for (i = 0; i < im->gdes_c; i++) {\n\n        switch (im->gdes[i].gf) {\n        case GF_HRULE:\n            if (im->gdes[i].yrule >= im->minval\n                && im->gdes[i].yrule <= im->maxval) {\n                cairo_save(im->cr);\n                if (im->gdes[i].dash) {\n                    cairo_set_dash(im->cr,\n                                   im->gdes[i].p_dashes,\n                                   im->gdes[i].ndash, im->gdes[i].offset);\n                }\n                gfx_line(im, im->xorigin,\n                         ytr(im, im->gdes[i].yrule),\n                         im->xorigin + im->xsize,\n                         ytr(im, im->gdes[i].yrule), 1.0, im->gdes[i].col);\n                cairo_stroke(im->cr);\n                cairo_restore(im->cr);\n            }\n            break;\n        case GF_VRULE:\n            if (im->gdes[i].xrule >= im->start\n                && im->gdes[i].xrule <= im->end) {\n                cairo_save(im->cr);\n                if (im->gdes[i].dash) {\n                    cairo_set_dash(im->cr,\n                                   im->gdes[i].p_dashes,\n                                   im->gdes[i].ndash, im->gdes[i].offset);\n                }\n                gfx_line(im,\n                         xtr(im, im->gdes[i].xrule),\n                         im->yorigin, xtr(im,\n                                          im->\n                                          gdes[i].\n                                          xrule),\n                         im->yorigin - im->ysize, 1.0, im->gdes[i].col);\n                cairo_stroke(im->cr);\n                cairo_restore(im->cr);\n            }\n            break;\n        default:\n            break;\n        }\n    }\n    /* close the graph via cairo*/\n    return graph_cairo_finish(im);\n}\n\nint graph_cairo_setup (image_desc_t *im)\n{\n    /* the actual graph is created by going through the individual\n       graph elements and then drawing them */\n    cairo_surface_destroy(im->surface);\n    switch (im->imgformat) {\n    case IF_PNG:\n        im->surface =\n            cairo_image_surface_create(CAIRO_FORMAT_ARGB32,\n                                       im->ximg * im->zoom,\n                                       im->yimg * im->zoom);\n        break;\n    case IF_PDF:\n        im->gridfit = 0;\n        im->surface = strlen(im->graphfile)\n            ? cairo_pdf_surface_create(im->graphfile, im->ximg * im->zoom,\n                                       im->yimg * im->zoom)\n            : cairo_pdf_surface_create_for_stream\n            (&cairo_output, im, im->ximg * im->zoom, im->yimg * im->zoom);\n        break;\n    case IF_EPS:\n        im->gridfit = 0;\n        im->surface = strlen(im->graphfile)\n            ?\n            cairo_ps_surface_create(im->graphfile, im->ximg * im->zoom,\n                                    im->yimg * im->zoom)\n            : cairo_ps_surface_create_for_stream\n            (&cairo_output, im, im->ximg * im->zoom, im->yimg * im->zoom);\n        break;\n    case IF_SVG:\n        im->gridfit = 0;\n        im->surface = strlen(im->graphfile)\n            ?\n            cairo_svg_surface_create(im->\n                                     graphfile,\n                                     im->ximg * im->zoom, im->yimg * im->zoom)\n            : cairo_svg_surface_create_for_stream\n            (&cairo_output, im, im->ximg * im->zoom, im->yimg * im->zoom);\n        cairo_svg_surface_restrict_to_version\n            (im->surface, CAIRO_SVG_VERSION_1_1);\n        break;\n    case IF_XML:\n    case IF_XMLENUM:\n    case IF_CSV:\n    case IF_TSV:\n    case IF_SSV:\n    case IF_JSON:\n    case IF_JSONTIME:\n        break;\n    };\n    cairo_destroy(im->cr);\n    im->cr = cairo_create(im->surface);\n    cairo_set_antialias(im->cr, im->graph_antialias);\n    cairo_scale(im->cr, im->zoom, im->zoom);\n//    pango_cairo_font_map_set_resolution(PANGO_CAIRO_FONT_MAP(font_map), 100);\n    gfx_new_area(im, 0, 0, 0, im->yimg,\n                 im->ximg, im->yimg, im->graph_col[GRC_BACK]);\n    gfx_add_point(im, im->ximg, 0);\n    gfx_close_path(im);\n    gfx_new_area(im, im->xorigin,\n                 im->yorigin,\n                 im->xorigin +\n                 im->xsize, im->yorigin,\n                 im->xorigin +\n                 im->xsize,\n                 im->yorigin - im->ysize, im->graph_col[GRC_CANVAS]);\n    gfx_add_point(im, im->xorigin, im->yorigin - im->ysize);\n    gfx_close_path(im);\n    cairo_rectangle(im->cr, im->xorigin, im->yorigin - im->ysize - 1.0,\n                    im->xsize, im->ysize + 2.0);\n    cairo_clip(im->cr);\n    return 0;\n}\n\nint graph_cairo_finish (image_desc_t *im)\n{\n\n    switch (im->imgformat) {\n    case IF_PNG:\n    {\n        cairo_status_t status;\n\n        status = strlen(im->graphfile) ?\n            cairo_surface_write_to_png(im->surface, im->graphfile)\n            : cairo_surface_write_to_png_stream(im->surface, &cairo_output,\n                                                im);\n\n        if (status != CAIRO_STATUS_SUCCESS) {\n            rrd_set_error(\"Could not save png to '%s'\", im->graphfile);\n            return 1;\n        }\n        break;\n    }\n    case IF_XML:\n    case IF_XMLENUM:\n    case IF_CSV:\n    case IF_TSV:\n    case IF_SSV:\n    case IF_JSON:\n    case IF_JSONTIME:\n      break;\n    default:\n        if (strlen(im->graphfile)) {\n            cairo_show_page(im->cr);\n        } else {\n            cairo_surface_finish(im->surface);\n        }\n        break;\n    }\n\n    return 0;\n}\n\nint graph_paint_xy(\n                  image_desc_t UNUSED(*im), int UNUSED(lazy), int UNUSED(cnt))\n{\n  rrd_set_error(\"XY diagramm not implemented\");  \n  return -1;\n}\n\n/*****************************************************\n * graph stuff\n *****************************************************/\n\nint gdes_alloc(\n    image_desc_t *im)\n{\n\n    im->gdes_c++;\n    if ((im->gdes = (graph_desc_t *)\n         rrd_realloc(im->gdes, (im->gdes_c)\n                     * sizeof(graph_desc_t))) == NULL) {\n        rrd_set_error(\"realloc graph_descs\");\n        return -1;\n    }\n\n    /* set to zero */\n    memset(&(im->gdes[im->gdes_c - 1]),0,sizeof(graph_desc_t));\n\n    im->gdes[im->gdes_c - 1].step = im->step;\n    im->gdes[im->gdes_c - 1].step_orig = im->step;\n    im->gdes[im->gdes_c - 1].stack = 0;\n    im->gdes[im->gdes_c - 1].skipscale = 0;\n    im->gdes[im->gdes_c - 1].linewidth = 0;\n    im->gdes[im->gdes_c - 1].debug = 0;\n    im->gdes[im->gdes_c - 1].start = im->start;\n    im->gdes[im->gdes_c - 1].start_orig = im->start;\n    im->gdes[im->gdes_c - 1].end = im->end;\n    im->gdes[im->gdes_c - 1].end_orig = im->end;\n    im->gdes[im->gdes_c - 1].vname[0] = '\\0';\n    im->gdes[im->gdes_c - 1].data = NULL;\n    im->gdes[im->gdes_c - 1].ds_namv = NULL;\n    im->gdes[im->gdes_c - 1].data_first = 0;\n    im->gdes[im->gdes_c - 1].p_data = NULL;\n    im->gdes[im->gdes_c - 1].rpnp = NULL;\n    im->gdes[im->gdes_c - 1].p_dashes = NULL;\n    im->gdes[im->gdes_c - 1].shift = 0.0;\n    im->gdes[im->gdes_c - 1].dash = 0;\n    im->gdes[im->gdes_c - 1].ndash = 0;\n    im->gdes[im->gdes_c - 1].offset = 0;\n    im->gdes[im->gdes_c - 1].col.red = 0.0;\n    im->gdes[im->gdes_c - 1].col.green = 0.0;\n    im->gdes[im->gdes_c - 1].col.blue = 0.0;\n    im->gdes[im->gdes_c - 1].col.alpha = 0.0;\n    im->gdes[im->gdes_c - 1].col2.red = 0.0;\n    im->gdes[im->gdes_c - 1].col2.green = 0.0;\n    im->gdes[im->gdes_c - 1].col2.blue = 0.0;\n    im->gdes[im->gdes_c - 1].col2.alpha = 0.0;\n    im->gdes[im->gdes_c - 1].gradheight = 50.0;\n    im->gdes[im->gdes_c - 1].legend[0] = '\\0';\n    im->gdes[im->gdes_c - 1].format[0] = '\\0';\n    im->gdes[im->gdes_c - 1].strftm = 0;\n    im->gdes[im->gdes_c - 1].rrd[0] = '\\0';\n    im->gdes[im->gdes_c - 1].ds = -1;\n    im->gdes[im->gdes_c - 1].cf_reduce = CF_AVERAGE;\n    im->gdes[im->gdes_c - 1].cf_reduce_set = 0;    \n    im->gdes[im->gdes_c - 1].cf = CF_AVERAGE;\n    im->gdes[im->gdes_c - 1].yrule = DNAN;\n    im->gdes[im->gdes_c - 1].xrule = 0;\n    im->gdes[im->gdes_c - 1].daemon[0] = 0;\n    return 0;\n}\n\n/* copies input untill the first unescaped colon is found\n   or until input ends. backslashes have to be escaped as well */\nint scan_for_col(\n    const char *const input,\n    int len,\n    char *const output)\n{\n    int       inp, outp = 0;\n\n    for (inp = 0; inp < len && input[inp] != ':' && input[inp] != '\\0'; inp++) {\n        if (input[inp] == '\\\\'\n            && input[inp + 1] != '\\0'\n            && (input[inp + 1] == '\\\\' || input[inp + 1] == ':')) {\n            output[outp++] = input[++inp];\n        } else {\n            output[outp++] = input[inp];\n        }\n    }\n    output[outp] = '\\0';\n    return inp;\n}\n\n/* Now just a wrapper around rrd_graph_v */\nint rrd_graph(\n    int argc,\n    char **argv,\n    char ***prdata,\n    int *xsize,\n    int *ysize,\n    FILE * stream,\n    double *ymin,\n    double *ymax)\n{\n    int       prlines = 0;\n    rrd_info_t *grinfo = NULL;\n    rrd_info_t *walker;\n\n    grinfo = rrd_graph_v(argc, argv);\n    if (grinfo == NULL)\n        return -1;\n    walker = grinfo;\n    (*prdata) = NULL;\n    while (walker) {\n        if (strcmp(walker->key, \"image_info\") == 0) {\n            prlines++;\n            if (((*prdata) =\n                 (char**)rrd_realloc((*prdata),\n                             (prlines + 1) * sizeof(char *))) == NULL) {\n                rrd_set_error(\"realloc prdata\");\n                return 0;\n            }\n            /* imginfo goes to position 0 in the prdata array */\n            (*prdata)[prlines - 1] = strdup(walker->value.u_str);\n            (*prdata)[prlines] = NULL;\n        }\n        /* skip anything else */\n        walker = walker->next;\n    }\n    walker = grinfo;\n    *xsize = 0;\n    *ysize = 0;\n    *ymin = 0;\n    *ymax = 0;\n    while (walker) {\n        if (strcmp(walker->key, \"image_width\") == 0) {\n            *xsize = walker->value.u_cnt;\n        } else if (strcmp(walker->key, \"image_height\") == 0) {\n            *ysize = walker->value.u_cnt;\n        } else if (strcmp(walker->key, \"value_min\") == 0) {\n            *ymin = walker->value.u_val;\n        } else if (strcmp(walker->key, \"value_max\") == 0) {\n            *ymax = walker->value.u_val;\n        } else if (strncmp(walker->key, \"print\", 5) == 0) { /* keys are prdate[0..] */\n            prlines++;\n            if (((*prdata) =\n                 (char**)rrd_realloc((*prdata),\n                             (prlines + 1) * sizeof(char *))) == NULL) {\n                rrd_set_error(\"realloc prdata\");\n                return 0;\n            }\n            (*prdata)[prlines - 1] = strdup(walker->value.u_str);\n            (*prdata)[prlines] = NULL;\n        } else if (strcmp(walker->key, \"image\") == 0) {\n            if ( fwrite(walker->value.u_blo.ptr, walker->value.u_blo.size, 1,\n                   (stream ? stream : stdout)) == 0 && ferror(stream ? stream : stdout)){\n                rrd_set_error(\"writing image\");\n                return 0;\n            }\n        }\n        /* skip anything else */\n        walker = walker->next;\n    }\n    rrd_info_free(grinfo);\n    return 0;\n}\n\n/* Some surgery done on this function, it became ridiculously big.\n** Things moved:\n** - initializing     now in rrd_graph_init()\n** - options parsing  now in rrd_graph_options()\n** - script parsing   now in rrd_graph_script()\n*/\n\nrrd_info_t *rrd_graph_v(\n    int argc,\n    char **argv)\n{\n    image_desc_t im;\n    rrd_info_t *grinfo;\n    rrd_graph_init(&im);\n    /* a dummy surface so that we can measure text sizes for placements */\n    rrd_graph_options(argc, argv, &im);\n    if (rrd_test_error()) {\n        rrd_info_free(im.grinfo);\n        im_free(&im);\n        return NULL;\n    }\n\n    if (optind >= argc) {\n        rrd_info_free(im.grinfo);\n        im_free(&im);\n        rrd_set_error(\"missing filename\");\n        return NULL;\n    }\n\n    if (strlen(argv[optind]) >= MAXPATH) {\n        rrd_set_error(\"filename (including path) too long\");\n        rrd_info_free(im.grinfo);\n        im_free(&im);\n        return NULL;\n    }\n\n    strncpy(im.graphfile, argv[optind], MAXPATH - 1);\n    im.graphfile[MAXPATH - 1] = '\\0';\n\n    if (strcmp(im.graphfile, \"-\") == 0) {\n        im.graphfile[0] = '\\0';\n    }\n\n    rrd_graph_script(argc, argv, &im, 1);\n\n    if (rrd_test_error()) {\n        rrd_info_free(im.grinfo);\n        im_free(&im);\n        return NULL;\n    }\n    \n    /* Everything is now read and the actual work can start */\n    if (graph_paint(&im) == -1) {\n      rrd_info_free(im.grinfo);\n      im_free(&im);\n      return NULL;\n    }\n\n    /* The image is generated and needs to be output.\n     ** Also, if needed, print a line with information about the image.\n     */\n\n    if (im.imginfo && *im.imginfo) {\n        rrd_infoval_t info;\n        char     *path;\n        char     *filename;\n\n        if (bad_format_imginfo(im.imginfo)) {\n            rrd_info_free(im.grinfo);\n            im_free(&im);\n            return NULL;\n        }\n        path = strdup(im.graphfile);\n        filename = basename(path);\n        info.u_str =\n            sprintf_alloc(im.imginfo,\n                          filename,\n                          (long) (im.zoom *\n                                  im.ximg), (long) (im.zoom * im.yimg));\n        grinfo_push(&im, sprintf_alloc(\"image_info\"), RD_I_STR, info);\n        free(info.u_str);\n        free(path);\n    }\n    if (im.rendered_image) {\n        rrd_infoval_t img;\n\n        img.u_blo.size = im.rendered_image_size;\n        img.u_blo.ptr = im.rendered_image;\n        grinfo_push(&im, sprintf_alloc(\"image\"), RD_I_BLO, img);\n    }\n    grinfo = im.grinfo;\n    im_free(&im);\n    return grinfo;\n}\n\nstatic void\nrrd_set_font_desc (\n    image_desc_t *im,int prop,char *font, double size ){\n    if (font){\n        strncpy(im->text_prop[prop].font, font, sizeof(text_prop[prop].font) - 1);\n        im->text_prop[prop].font[sizeof(text_prop[prop].font) - 1] = '\\0';\n        /* if we already got one, drop it first */\n        pango_font_description_free(im->text_prop[prop].font_desc);\n        im->text_prop[prop].font_desc = pango_font_description_from_string( font );\n    };\n    if (size > 0){\n        im->text_prop[prop].size = size;\n    };\n    if (im->text_prop[prop].font_desc && im->text_prop[prop].size ){\n        pango_font_description_set_size(im->text_prop[prop].font_desc, im->text_prop[prop].size * PANGO_SCALE);\n    };\n}\n\nvoid rrd_graph_init(\n    image_desc_t\n    *im)\n{\n    unsigned int i;\n    char     *deffont = getenv(\"RRD_DEFAULT_FONT\");\n    static PangoFontMap *fontmap = NULL;\n    PangoContext *context;\n\n    /* zero the whole structure first */\n    memset(im,0,sizeof(image_desc_t));\n\n#ifdef HAVE_TZSET\n    tzset();\n#endif\n    im->gdef_map = g_hash_table_new_full(g_str_hash, g_str_equal,g_free,NULL);\n\t//use of g_free() cause heap damage on windows. Key is allocated by malloc() in sprintf_alloc(), so free() must use\n    im->rrd_map = g_hash_table_new_full(g_str_hash, g_str_equal,free,NULL); \n    im->graph_type = GTYPE_TIME;\n    im->base = 1000;\n    im->daemon_addr = NULL;\n    im->draw_x_grid = 1;\n    im->draw_y_grid = 1;\n    im->draw_3d_border = 2;\n    im->dynamic_labels = 0;\n    im->extra_flags = 0;\n    im->font_options = cairo_font_options_create();\n    im->forceleftspace = 0;\n    im->gdes_c = 0;\n    im->gdes = NULL;\n    im->graph_antialias = CAIRO_ANTIALIAS_GRAY;\n    im->grid_dash_off = 1;\n    im->grid_dash_on = 1;\n    im->gridfit = 1;\n    im->grinfo = (rrd_info_t *) NULL;\n    im->grinfo_current = (rrd_info_t *) NULL;\n    im->imgformat = IF_PNG;\n    im->imginfo = NULL;\n    im->lazy = 0;\n    im->legenddirection = TOP_DOWN;\n    im->legendheight = 0;\n    im->legendposition = SOUTH;\n    im->legendwidth = 0;\n    im->logarithmic = 0;\n    im->maxval = DNAN;\n    im->minval = 0;\n    im->minval = DNAN;\n    im->magfact = 1;\n    im->prt_c = 0;\n    im->rigid = 0;\n    im->rendered_image_size = 0;\n    im->rendered_image = NULL;\n    im->slopemode = 0;\n    im->step = 0;\n    im->symbol = ' ';\n    im->tabwidth = 40.0;\n    im->title = NULL;\n    im->unitsexponent = 9999;\n    im->unitslength = 6;\n    im->viewfactor = 1.0;\n    im->watermark = NULL;\n    im->xlab_form = NULL;\n    im->with_markup = 0;\n    im->ximg = 0;\n    im->xlab_user.minsec = -1;\n    im->xorigin = 0;\n    im->xOriginLegend = 0;\n    im->xOriginLegendY = 0;\n    im->xOriginLegendY2 = 0;\n    im->xOriginTitle = 0;\n    im->xsize = 400;\n    im->ygridstep = DNAN;\n    im->yimg = 0;\n    im->ylegend = NULL;\n    im->second_axis_scale = 0; /* 0 disables it */\n    im->second_axis_shift = 0; /* no shift by default */\n    im->second_axis_legend = NULL;\n    im->second_axis_format = NULL;\n    im->primary_axis_format = NULL;\n    im->yorigin = 0;\n    im->yOriginLegend = 0;\n    im->yOriginLegendY = 0;\n    im->yOriginLegendY2 = 0;\n    im->yOriginTitle = 0;\n    im->ysize = 100;\n    im->zoom = 1;\n\n    im->surface = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, 10, 10);\n    im->cr = cairo_create(im->surface);\n\n    for (i = 0; i < DIM(text_prop); i++) {\n        im->text_prop[i].size = -1;\n        im->text_prop[i].font_desc = NULL;\n        rrd_set_font_desc(im,i, deffont ? deffont : text_prop[i].font,text_prop[i].size);\n    }\n\n    if (fontmap == NULL){\n        fontmap = pango_cairo_font_map_get_default();\n    }\n\n    context =  pango_font_map_create_context(fontmap);\n\n    pango_cairo_context_set_resolution(context, 100);\n\n    pango_cairo_update_context(im->cr,context);\n\n    im->layout = pango_layout_new(context);\n    g_object_unref (context);\n\n//  im->layout = pango_cairo_create_layout(im->cr);\n\n\n    cairo_font_options_set_hint_style\n        (im->font_options, CAIRO_HINT_STYLE_FULL);\n    cairo_font_options_set_hint_metrics\n        (im->font_options, CAIRO_HINT_METRICS_ON);\n    cairo_font_options_set_antialias(im->font_options, CAIRO_ANTIALIAS_GRAY);\n\n\n\n    for (i = 0; i < DIM(graph_col); i++)\n        im->graph_col[i] = graph_col[i];\n\n\n}\n\n\nvoid rrd_graph_options(\n    int argc,\n    char *argv[],\n    image_desc_t\n    *im)\n{\n    int       stroff;\n    char     *parsetime_error = NULL;\n    char      scan_gtm[12], scan_mtm[12], scan_ltm[12], col_nam[12];\n    char      double_str[20], double_str2[20];\n    time_t    start_tmp = 0, end_tmp = 0;\n    long      long_tmp;\n    rrd_time_value_t start_tv, end_tv;\n    long unsigned int color;\n\n    /* defines for long options without a short equivalent. should be bytes,\n       and may not collide with (the ASCII value of) short options */\n#define LONGOPT_UNITS_SI 255\n\n/* *INDENT-OFF* */\n    struct option long_options[] = {\n        { \"alt-autoscale\",      no_argument,       0, 'A'},\n        { \"imgformat\",          required_argument, 0, 'a'},\n        { \"font-smoothing-threshold\", required_argument, 0, 'B'},\n        { \"base\",               required_argument, 0, 'b'},\n        { \"color\",              required_argument, 0, 'c'},\n        { \"full-size-mode\",     no_argument,       0, 'D'},\n        { \"daemon\",             required_argument, 0, 'd'},\n        { \"slope-mode\",         no_argument,       0, 'E'},\n        { \"end\",                required_argument, 0, 'e'},\n        { \"force-rules-legend\", no_argument,       0, 'F'},\n        { \"imginfo\",            required_argument, 0, 'f'},\n        { \"graph-render-mode\",  required_argument, 0, 'G'},\n        { \"no-legend\",          no_argument,       0, 'g'},\n        { \"height\",             required_argument, 0, 'h'},\n        { \"no-minor\",           no_argument,       0, 'I'},\n        { \"interlaced\",         no_argument,       0, 'i'},\n        { \"alt-autoscale-min\",  no_argument,       0, 'J'},\n        { \"only-graph\",         no_argument,       0, 'j'},\n        { \"units-length\",       required_argument, 0, 'L'},\n        { \"lower-limit\",        required_argument, 0, 'l'},\n        { \"alt-autoscale-max\",  no_argument,       0, 'M'},\n        { \"zoom\",               required_argument, 0, 'm'},\n        { \"no-gridfit\",         no_argument,       0, 'N'},\n        { \"font\",               required_argument, 0, 'n'},\n        { \"logarithmic\",        no_argument,       0, 'o'},\n        { \"pango-markup\",       no_argument,       0, 'P'},\n        { \"font-render-mode\",   required_argument, 0, 'R'},\n        { \"rigid\",              no_argument,       0, 'r'},\n        { \"step\",               required_argument, 0, 'S'},\n        { \"start\",              required_argument, 0, 's'},\n        { \"tabwidth\",           required_argument, 0, 'T'},\n        { \"title\",              required_argument, 0, 't'},\n        { \"upper-limit\",        required_argument, 0, 'u'},\n        { \"vertical-label\",     required_argument, 0, 'v'},\n        { \"watermark\",          required_argument, 0, 'W'},\n        { \"width\",              required_argument, 0, 'w'},\n        { \"units-exponent\",     required_argument, 0, 'X'},\n        { \"x-grid\",             required_argument, 0, 'x'},\n        { \"alt-y-grid\",         no_argument,       0, 'Y'},\n        { \"y-grid\",             required_argument, 0, 'y'},\n        { \"lazy\",               no_argument,       0, 'z'},\n        { \"use-nan-for-all-missing-data\", no_argument,       0, 'Z'},\n        { \"units\",              required_argument, 0, LONGOPT_UNITS_SI},\n        { \"alt-y-mrtg\",         no_argument,       0, 1000},    /* this has no effect it is just here to save old apps from crashing when they use it */\n        { \"disable-rrdtool-tag\",no_argument,       0, 1001},\n        { \"right-axis\",         required_argument, 0, 1002},\n        { \"right-axis-label\",   required_argument, 0, 1003},\n        { \"right-axis-format\",  required_argument, 0, 1004},\n        { \"legend-position\",    required_argument, 0, 1005},\n        { \"legend-direction\",   required_argument, 0, 1006},\n        { \"border\",             required_argument, 0, 1007},\n        { \"grid-dash\",          required_argument, 0, 1008},\n        { \"dynamic-labels\",     no_argument,       0, 1009},\n        { \"week-fmt\",           required_argument, 0, 1010},\n        { \"graph-type\",         required_argument, 0, 1011},\n        { \"left-axis-format\",   required_argument, 0, 1012},\n        {  0, 0, 0, 0}\n};\n/* *INDENT-ON* */\n\n    optind = 0;\n    opterr = 0;         /* initialize getopt */\n    rrd_parsetime(\"end-24h\", &start_tv);\n    rrd_parsetime(\"now\", &end_tv);\n    while (1) {\n        int       option_index = 0;\n        int       opt;\n        int       col_start, col_end;\n\n        opt = getopt_long(argc, argv,\n                          \"Aa:B:b:c:Dd:Ee:Ff:G:gh:IiJjL:l:Mm:Nn:oPR:rS:s:T:t:u:v:W:w:X:x:Yy:Zz\",\n                          long_options, &option_index);\n        if (opt == EOF)\n            break;\n        switch (opt) {\n        case 'I':\n            im->extra_flags |= NOMINOR;\n            break;\n        case 'Y':\n            im->extra_flags |= ALTYGRID;\n            break;\n        case 'A':\n            im->extra_flags |= ALTAUTOSCALE;\n            break;\n        case 'J':\n            im->extra_flags |= ALTAUTOSCALE_MIN;\n            break;\n        case 'M':\n            im->extra_flags |= ALTAUTOSCALE_MAX;\n            break;\n        case 'j':\n            im->extra_flags |= ONLY_GRAPH;\n            break;\n        case 'g':\n            im->extra_flags |= NOLEGEND;\n            break;\n        case 'Z':\n            im->extra_flags |= ALLOW_MISSING_DS;\n            break;\n        case 1005:\n            if (strcmp(optarg, \"north\") == 0) {\n                im->legendposition = NORTH;\n            } else if (strcmp(optarg, \"west\") == 0) {\n                im->legendposition = WEST;\n            } else if (strcmp(optarg, \"south\") == 0) {\n                im->legendposition = SOUTH;\n            } else if (strcmp(optarg, \"east\") == 0) {\n                im->legendposition = EAST;\n            } else {\n                rrd_set_error(\"unknown legend-position '%s'\", optarg);\n                return;\n            }\n            break;\n        case 1006:\n            if (strcmp(optarg, \"topdown\") == 0) {\n                im->legenddirection = TOP_DOWN;\n            } else if (strcmp(optarg, \"bottomup\") == 0) {\n                im->legenddirection = BOTTOM_UP;\n            } else if (strcmp(optarg, \"bottomup2\") == 0) {\n                im->legenddirection = BOTTOM_UP2;\n            } else {\n                rrd_set_error(\"unknown legend-position '%s'\", optarg);\n                return;\n            }\n            break;\n        case 'F':\n            im->extra_flags |= FORCE_RULES_LEGEND;\n            break;\n        case 1001:\n            im->extra_flags |= NO_RRDTOOL_TAG;\n            break;\n        case LONGOPT_UNITS_SI:\n            if (im->extra_flags & FORCE_UNITS) {\n                rrd_set_error(\"--units can only be used once!\");\n                return;\n            }\n            if (strcmp(optarg, \"si\") == 0)\n                im->extra_flags |= FORCE_UNITS_SI;\n            else {\n                rrd_set_error(\"invalid argument for --units: %s\", optarg);\n                return;\n            }\n            break;\n        case 'X':\n            im->unitsexponent = atoi(optarg);\n            break;\n        case 'L':\n            im->unitslength = atoi(optarg);\n            im->forceleftspace = 1;\n            break;\n        case 'T':\n            if (rrd_strtodbl(optarg, 0, &(im->tabwidth), \"option -T\") != 2)\n                return;\n            break;\n        case 'S':\n            im->step = atoi(optarg);\n            break;\n        case 'N':\n            im->gridfit = 0;\n            break;\n        case 'P':\n            im->with_markup = 1;\n            break;\n        case 's':\n            if ((parsetime_error = rrd_parsetime(optarg, &start_tv))) {\n                rrd_set_error(\"start time: %s\", parsetime_error);\n                return;\n            }\n            break;\n        case 'e':\n            if ((parsetime_error = rrd_parsetime(optarg, &end_tv))) {\n                rrd_set_error(\"end time: %s\", parsetime_error);\n                return;\n            }\n            break;\n        case 'x':\n            if (strcmp(optarg, \"none\") == 0) {\n                im->draw_x_grid = 0;\n                break;\n            };\n            if (sscanf(optarg,\n                       \"%10[A-Z]:%ld:%10[A-Z]:%ld:%10[A-Z]:%ld:%ld:%n\",\n                       scan_gtm,\n                       &im->xlab_user.gridst,\n                       scan_mtm,\n                       &im->xlab_user.mgridst,\n                       scan_ltm,\n                       &im->xlab_user.labst,\n                       &im->xlab_user.precis, &stroff) == 7 && stroff != 0) {\n\t\t\t\tim->xlab_form=strdup(optarg + stroff);\n\t\t\t\tif (!im->xlab_form) {\n                    rrd_set_error(\"cannot allocate memory for xlab_form\");\n                    return;\n\t\t\t\t}\n                if ((int)\n                    (im->xlab_user.gridtm = tmt_conv(scan_gtm)) == -1) {\n                    rrd_set_error(\"unknown keyword %s\", scan_gtm);\n                    return;\n                } else if ((int)\n                           (im->xlab_user.mgridtm = tmt_conv(scan_mtm))\n                           == -1) {\n                    rrd_set_error(\"unknown keyword %s\", scan_mtm);\n                    return;\n                } else if ((int)\n                           (im->xlab_user.labtm = tmt_conv(scan_ltm)) == -1) {\n                    rrd_set_error(\"unknown keyword %s\", scan_ltm);\n                    return;\n                }\n                im->xlab_user.minsec = 1;\n                im->xlab_user.stst = im->xlab_form ? im->xlab_form : \"\";\n            } else {\n                rrd_set_error(\"invalid x-grid format\");\n                return;\n            }\n            break;\n        case 'y':\n            if (strcmp(optarg, \"none\") == 0) {\n                im->draw_y_grid = 0;\n                break;\n            };\n            if (sscanf(optarg, \"%[-0-9.e+]:%d\", double_str , &im->ylabfact) == 2) {\n                if (rrd_strtodbl( double_str, 0, &(im->ygridstep), \"option -y\") != 2){\n                    return;\n                }\n                if (im->ygridstep <= 0) {\n                    rrd_set_error(\"grid step must be > 0\");\n                    return;\n                } else if (im->ylabfact < 1) {\n                    rrd_set_error(\"label factor must be > 0\");\n                    return;\n                }\n            } else {\n                rrd_set_error(\"invalid y-grid format\");\n                return;\n            }\n            break;\n        case 1007:\n            im->draw_3d_border = atoi(optarg);\n            break;\n        case 1008: /* grid-dash */\n            if(sscanf(optarg,\n                      \"%[-0-9.e+]:%[-0-9.e+]\",\n                      double_str,\n                      double_str2 ) != 2) {\n                if ( rrd_strtodbl( double_str, 0, &(im->grid_dash_on),NULL) !=2 \n                     || rrd_strtodbl( double_str2, 0, &(im->grid_dash_off), NULL) != 2 ){\n                    rrd_set_error(\"expected grid-dash format float:float\");\n                    return;\n                }\n            }\n            break;   \n        case 1009: /* enable dynamic labels */\n            im->dynamic_labels = 1;\n            break;         \n        case 1010:\n            strncpy(week_fmt,optarg,sizeof week_fmt);\n            week_fmt[(sizeof week_fmt)-1]='\\0';\n            break;\n        case 1002: /* right y axis */\n            if(sscanf(optarg,\n                      \"%[-0-9.e+]:%[-0-9.e+]\",\n                      double_str,\n                      double_str2 ) == 2\n                && rrd_strtodbl( double_str, 0, &(im->second_axis_scale),NULL) == 2\n                && rrd_strtodbl( double_str2, 0, &(im->second_axis_shift),NULL) == 2){\n                if(im->second_axis_scale==0){\n                    rrd_set_error(\"the second_axis_scale  must not be 0\");\n                    return;\n                }\n            } else {\n                rrd_set_error(\"invalid right-axis format expected scale:shift\");\n                return;\n            }\n            break;\n        case 1003:\n            im->second_axis_legend=strdup(optarg);\n            if (!im->second_axis_legend) {\n                rrd_set_error(\"cannot allocate memory for second_axis_legend\");\n                return;\n            }\n            break;\n        case 1004:\n            if (bad_format_axis(optarg)){\n                return;\n            }\n            im->second_axis_format=strdup(optarg);\n            if (!im->second_axis_format) {\n                rrd_set_error(\"cannot allocate memory for second_axis_format\");\n                return;\n            }\n            break;\n        case 1012:\n            if (bad_format_axis(optarg)){\n                return;\n            }\n            im->primary_axis_format=strdup(optarg);\n            if (!im->primary_axis_format) {\n                rrd_set_error(\"cannot allocate memory for primary_axis_format\");\n                return;\n            }\n            break;\n        case 'v':\n            im->ylegend=strdup(optarg);\n            if (!im->ylegend) {\n                rrd_set_error(\"cannot allocate memory for ylegend\");\n                return;\n            }\n            break;\n        case 'u':\n            if (rrd_strtodbl(optarg, 0, &(im->maxval), \"option -u\") != 2){\n                return;\n            }\n            break;\n        case 'l':\n            if (rrd_strtodbl(optarg, 0, &(im->minval), \"option -l\") != 2){\n                return;\n            }\n            break;\n        case 'b':\n            im->base = atol(optarg);\n            if (im->base != 1024 && im->base != 1000) {\n                rrd_set_error\n                    (\"the only sensible value for base apart from 1000 is 1024\");\n                return;\n            }\n            break;\n        case 'w':\n            long_tmp = atol(optarg);\n            if (long_tmp < 10) {\n                rrd_set_error(\"width below 10 pixels\");\n                return;\n            }\n            im->xsize = long_tmp;\n            break;\n        case 'h':\n            long_tmp = atol(optarg);\n            if (long_tmp < 10) {\n                rrd_set_error(\"height below 10 pixels\");\n                return;\n            }\n            im->ysize = long_tmp;\n            break;\n        case 'D':\n            im->extra_flags |= FULL_SIZE_MODE;\n            break;\n        case 'i':\n            /* interlaced png not supported at the moment */\n            break;\n        case 'r':\n            im->rigid = 1;\n            break;\n        case 'f':\n            im->imginfo = optarg;\n            break;\n        case 'a':\n            if ((int)\n                (im->imgformat = if_conv(optarg)) == -1) {\n                rrd_set_error(\"unsupported graphics format '%s'\", optarg);\n                return;\n            }\n            break;\n        case 1011:\n            if ((int)\n                (im->graph_type = type_conv(optarg)) == -1) {\n                rrd_set_error(\"unsupported graphics type '%s'\", optarg);\n                return;\n            }\n            break;\n        case 'z':\n            im->lazy = 1;\n            break;\n        case 'E':\n            im->slopemode = 1;\n            break;\n        case 'o':\n            im->logarithmic = 1;\n            break;\n        case 'c':\n            if (sscanf(optarg,\n                       \"%10[A-Z]#%n%8lx%n\",\n                       col_nam, &col_start, &color, &col_end) == 2) {\n                int       ci;\n                int       col_len = col_end - col_start;\n\n                switch (col_len) {\n                case 3:\n                    color =\n                        (((color & 0xF00) * 0x110000) | ((color & 0x0F0) *\n                                                         0x011000) |\n                         ((color & 0x00F)\n                          * 0x001100)\n                         | 0x000000FF);\n                    break;\n                case 4:\n                    color =\n                        (((color & 0xF000) *\n                          0x11000) | ((color & 0x0F00) *\n                                      0x01100) | ((color &\n                                                   0x00F0) *\n                                                  0x00110) |\n                         ((color & 0x000F) * 0x00011)\n                        );\n                    break;\n                case 6:\n                    color = (color << 8) + 0xff /* shift left by 8 */ ;\n                    break;\n                case 8:\n                    break;\n                default:\n                    rrd_set_error(\"the color format is #RRGGBB[AA]\");\n                    return;\n                }\n                if ((ci = grc_conv(col_nam)) != -1) {\n                    im->graph_col[ci] = gfx_hex_to_col(color);\n                } else {\n                    rrd_set_error(\"invalid color name '%s'\", col_nam);\n                    return;\n                }\n            } else {\n                rrd_set_error(\"invalid color def format\");\n                return;\n            }\n            break;\n        case 'n':{\n            char      prop[15];\n            double    size = 1;\n            int       end;\n\n            if (sscanf(optarg, \"%10[A-Z]:%[-0-9.e+]%n\", prop, double_str, &end) >= 2\n                && rrd_strtodbl( double_str, 0, &size, NULL) == 2) {\n                int       sindex, propidx;\n\n                if ((sindex = text_prop_conv(prop)) != -1) {\n                    for (propidx = sindex;\n                         propidx < TEXT_PROP_LAST; propidx++) {\n                        if (size > 0) {\n                            rrd_set_font_desc(im,propidx,NULL,size);\n                        }\n                        if ((int) strlen(optarg) > end+2) {\n                            if (optarg[end] == ':') {\n                                rrd_set_font_desc(im,propidx,optarg + end + 1,0);\n                            } else {\n                                rrd_set_error\n                                    (\"expected : after font size in '%s'\",\n                                     optarg);\n                                return;\n                            }\n                        }\n                        /* only run the for loop for DEFAULT (0) for\n                           all others, we break here. woodo programming */\n                        if (propidx == sindex && sindex != 0)\n                            break;\n                    }\n                } else {\n                    rrd_set_error(\"invalid fonttag '%s'\", prop);\n                    return;\n                }\n            } else {\n                rrd_set_error(\"invalid text property format\");\n                return;\n            }\n            break;\n        }\n        case 'm':\n            if (rrd_strtodbl(optarg, 0, &(im->zoom), \"option -m\") != 2){\n                return;\n            }\n            if (im->zoom <= 0.0) {\n                rrd_set_error(\"zoom factor must be > 0\");\n                return;\n            }\n            break;\n        case 't':\n            im->title=strdup(optarg);\n            if (!im->title) {\n                rrd_set_error(\"cannot allocate memory for title\");\n                return;\n            }\n            break;\n        case 'R':\n            if (strcmp(optarg, \"normal\") == 0) {\n                cairo_font_options_set_antialias\n                    (im->font_options, CAIRO_ANTIALIAS_GRAY);\n                cairo_font_options_set_hint_style\n                    (im->font_options, CAIRO_HINT_STYLE_FULL);\n            } else if (strcmp(optarg, \"light\") == 0) {\n                cairo_font_options_set_antialias\n                    (im->font_options, CAIRO_ANTIALIAS_GRAY);\n                cairo_font_options_set_hint_style\n                    (im->font_options, CAIRO_HINT_STYLE_SLIGHT);\n            } else if (strcmp(optarg, \"mono\") == 0) {\n                cairo_font_options_set_antialias\n                    (im->font_options, CAIRO_ANTIALIAS_NONE);\n                cairo_font_options_set_hint_style\n                    (im->font_options, CAIRO_HINT_STYLE_FULL);\n            } else {\n                rrd_set_error(\"unknown font-render-mode '%s'\", optarg);\n                return;\n            }\n            break;\n        case 'G':\n            if (strcmp(optarg, \"normal\") == 0)\n                im->graph_antialias = CAIRO_ANTIALIAS_GRAY;\n            else if (strcmp(optarg, \"mono\") == 0)\n                im->graph_antialias = CAIRO_ANTIALIAS_NONE;\n            else {\n                rrd_set_error(\"unknown graph-render-mode '%s'\", optarg);\n                return;\n            }\n            break;\n        case 'B':\n            /* not supported curently */\n            break;\n        case 'W':\n            im->watermark=strdup(optarg);\n            if (!im->watermark) {\n                rrd_set_error(\"cannot allocate memory for watermark\");\n                return;\n            }\n            break;\n        case 'd':\n        {\n            if (im->daemon_addr != NULL)\n            {\n                rrd_set_error (\"You cannot specify --daemon \"\n                        \"more than once.\");\n                return;\n            }\n\n            im->daemon_addr = strdup(optarg);\n            if (im->daemon_addr == NULL)\n            {\n              rrd_set_error(\"strdup failed\");\n              return;\n            }\n\n            break;\n        }\n        case '?':\n            if (optopt != 0)\n                rrd_set_error(\"unknown option '%c'\", optopt);\n            else\n                rrd_set_error(\"unknown option '%s'\", argv[optind - 1]);\n            return;\n        }\n    } /* while (1) */\n\n    pango_cairo_context_set_font_options(pango_layout_get_context(im->layout), im->font_options);\n    pango_layout_context_changed(im->layout);\n\n\n\n    if (im->logarithmic && im->minval <= 0) {\n        rrd_set_error\n            (\"for a logarithmic yaxis you must specify a lower-limit > 0\");\n        return;\n    }\n\n    if (rrd_proc_start_end(&start_tv, &end_tv, &start_tmp, &end_tmp) == -1) {\n        /* error string is set in rrd_parsetime.c */\n        return;\n    }\n\n    if (start_tmp < 3600 * 24 * 365 * 10) {\n        rrd_set_error\n            (\"the first entry to fetch should be after 1980 (%ld)\",\n             start_tmp);\n        return;\n    }\n\n    if (end_tmp < start_tmp) {\n        rrd_set_error\n            (\"start (%ld) should be less than end (%ld)\", start_tmp, end_tmp);\n        return;\n    }\n\n    im->start = start_tmp;\n    im->end = end_tmp;\n    im->step = max((long) im->step, (im->end - im->start) / im->xsize);\n}\n\nint rrd_graph_color(\n    image_desc_t\n    *im,\n    char *var,\n    char *err,\n    int optional)\n{\n    char     *color;\n    graph_desc_t *gdp = &im->gdes[im->gdes_c - 1];\n\n    color = strstr(var, \"#\");\n    if (color == NULL) {\n        if (optional == 0) {\n            rrd_set_error(\"Found no color in %s\", err);\n            return 0;\n        }\n        return 0;\n    } else {\n        int       n = 0;\n        char     *rest;\n        long unsigned int col;\n\n        rest = strstr(color, \":\");\n        if (rest != NULL)\n            n = rest - color;\n        else\n            n = strlen(color);\n        switch (n) {\n        case 7:\n            sscanf(color, \"#%6lx%n\", &col, &n);\n            col = (col << 8) + 0xff /* shift left by 8 */ ;\n            if (n != 7)\n                rrd_set_error(\"Color problem in %s\", err);\n            break;\n        case 9:\n            sscanf(color, \"#%8lx%n\", &col, &n);\n            if (n == 9)\n                break;\n        default:\n            rrd_set_error(\"Color problem in %s\", err);\n        }\n        if (rrd_test_error())\n            return 0;\n        gdp->col = gfx_hex_to_col(col);\n        return n;\n    }\n}\n\n\nstatic int bad_format_check(const char *pattern, char *fmt) {\n    GError *gerr = NULL;\n    GRegex *re = g_regex_new(pattern, G_REGEX_EXTENDED, 0, &gerr);\n    GMatchInfo *mi;\n    if (gerr != NULL) {\n        rrd_set_error(\"cannot compile regular expression: %s (%s)\", gerr->message,pattern);\n        return 1;\n    }\n    int m = g_regex_match(re, fmt, 0, &mi);\n    g_match_info_free (mi);\n    g_regex_unref(re);\n    if (!m) {\n        rrd_set_error(\"invalid format string '%s' (should match '%s')\",fmt,pattern);\n        return 1;\n    }\n    return 0;\n}\n\n#define SAFE_STRING \"(?:[^%]+|%%)*\"\n\nint bad_format_imginfo(char *fmt){\n    return bad_format_check(\"^\" SAFE_STRING \"%s\" SAFE_STRING \"%lu\" SAFE_STRING \"%lu\" SAFE_STRING \"$\",fmt);\n}\n#define FLOAT_STRING \"%[+- 0#]?[0-9]*([.][0-9]+)?l[eEfF]\"\n\nint bad_format_axis(char *fmt){\n    return bad_format_check(\"^\" SAFE_STRING FLOAT_STRING SAFE_STRING \"$\",fmt);\n}\n\nint bad_format_print(char *fmt){\n    return bad_format_check(\"^\" SAFE_STRING FLOAT_STRING SAFE_STRING \"%s\" SAFE_STRING \"$\",fmt);\n}\n\nint vdef_parse(\n    struct graph_desc_t\n    *gdes,\n    const char *const str)\n{\n    /* A VDEF currently is either \"func\" or \"param,func\"\n     * so the parsing is rather simple.  Change if needed.\n     */\n    double    param;\n    char      func[30], double_str[21];\n    int       n;\n\n    n = 0;\n    sscanf(str, \"%20[-0-9.e+],%29[A-Z]%n\", double_str, func, &n);\n    if ( rrd_strtodbl( double_str, NULL, &param, NULL) != 2 ){\n        n = 0;\n        sscanf(str, \"%29[A-Z]%n\", func, &n);\n        if (n == (int) strlen(str)) {   /* matched */\n            param = DNAN;\n        } else {\n            rrd_set_error\n                (\"Unknown function string '%s' in VDEF '%s'\",\n                 str, gdes->vname);\n            return -1;\n        }\n    }\n    if (!strcmp(\"PERCENT\", func))\n        gdes->vf.op = VDEF_PERCENT;\n    else if (!strcmp(\"PERCENTNAN\", func))\n        gdes->vf.op = VDEF_PERCENTNAN;\n    else if (!strcmp(\"MAXIMUM\", func))\n        gdes->vf.op = VDEF_MAXIMUM;\n    else if (!strcmp(\"AVERAGE\", func))\n        gdes->vf.op = VDEF_AVERAGE;\n    else if (!strcmp(\"STDEV\", func))\n        gdes->vf.op = VDEF_STDEV;\n    else if (!strcmp(\"MINIMUM\", func))\n        gdes->vf.op = VDEF_MINIMUM;\n    else if (!strcmp(\"TOTAL\", func))\n        gdes->vf.op = VDEF_TOTAL;\n    else if (!strcmp(\"FIRST\", func))\n        gdes->vf.op = VDEF_FIRST;\n    else if (!strcmp(\"LAST\", func))\n        gdes->vf.op = VDEF_LAST;\n    else if (!strcmp(\"LSLSLOPE\", func))\n        gdes->vf.op = VDEF_LSLSLOPE;\n    else if (!strcmp(\"LSLINT\", func))\n        gdes->vf.op = VDEF_LSLINT;\n    else if (!strcmp(\"LSLCORREL\", func))\n        gdes->vf.op = VDEF_LSLCORREL;\n    else {\n        rrd_set_error\n            (\"Unknown function '%s' in VDEF '%s'\\n\", func, gdes->vname);\n        return -1;\n    };\n    switch (gdes->vf.op) {\n    case VDEF_PERCENT:\n    case VDEF_PERCENTNAN:\n        if (isnan(param)) { /* no parameter given */\n            rrd_set_error\n                (\"Function '%s' needs parameter in VDEF '%s'\\n\",\n                 func, gdes->vname);\n            return -1;\n        };\n        if (param >= 0.0 && param <= 100.0) {\n            gdes->vf.param = param;\n            gdes->vf.val = DNAN;    /* undefined */\n            gdes->vf.when = 0;  /* undefined */\n            gdes->vf.never = 1;\n        } else {\n            rrd_set_error\n                (\"Parameter '%f' out of range in VDEF '%s'\\n\",\n                 param, gdes->vname);\n            return -1;\n        };\n        break;\n    case VDEF_MAXIMUM:\n    case VDEF_AVERAGE:\n    case VDEF_STDEV:\n    case VDEF_MINIMUM:\n    case VDEF_TOTAL:\n    case VDEF_FIRST:\n    case VDEF_LAST:\n    case VDEF_LSLSLOPE:\n    case VDEF_LSLINT:\n    case VDEF_LSLCORREL:\n        if (isnan(param)) {\n            gdes->vf.param = DNAN;\n            gdes->vf.val = DNAN;\n            gdes->vf.when = 0;\n            gdes->vf.never = 1;\n        } else {\n            rrd_set_error\n                (\"Function '%s' needs no parameter in VDEF '%s'\\n\",\n                 func, gdes->vname);\n            return -1;\n        };\n        break;\n    };\n    return 0;\n}\n\n\nint vdef_calc(\n    image_desc_t *im,\n    int gdi)\n{\n    graph_desc_t *src, *dst;\n    rrd_value_t *data;\n    long      step, steps;\n\n    dst = &im->gdes[gdi];\n    src = &im->gdes[dst->vidx];\n    data = src->data + src->ds;\n\n    steps = (src->end - src->start) / src->step;\n#if 0\n    printf\n        (\"DEBUG: start == %lu, end == %lu, %lu steps\\n\",\n         src->start, src->end, steps);\n#endif\n    switch (dst->vf.op) {\n    case VDEF_PERCENT:{\n        rrd_value_t *array;\n        int       field;\n        if ((array = (rrd_value_t*)malloc(steps * sizeof(double))) == NULL) {\n            rrd_set_error(\"malloc VDEV_PERCENT\");\n            return -1;\n        }\n        for (step = 0; step < steps; step++) {\n            array[step] = data[step * src->ds_cnt];\n        }\n        qsort(array, step, sizeof(double), vdef_percent_compar);\n        field = round((dst->vf.param * (double)(steps - 1)) / 100.0);\n        dst->vf.val = array[field];\n        dst->vf.when = 0;   /* no time component */\n        dst->vf.never = 1;\n        free(array);\n#if 0\n        for (step = 0; step < steps; step++)\n            printf(\"DEBUG: %3li:%10.2f %c\\n\",\n                   step, array[step], step == field ? '*' : ' ');\n#endif\n    }\n        break;\n    case VDEF_PERCENTNAN:{\n        rrd_value_t *array;\n        int       field;\n       /* count number of \"valid\" values */\n       int nancount=0;\n       for (step = 0; step < steps; step++) {\n         if (!isnan(data[step * src->ds_cnt])) { nancount++; }\n       }\n       /* and allocate it */\n        if ((array = (rrd_value_t*)malloc(nancount * sizeof(double))) == NULL) {\n            rrd_set_error(\"malloc VDEV_PERCENT\");\n            return -1;\n        }\n       /* and fill it in */\n       field=0;\n        for (step = 0; step < steps; step++) {\n           if (!isnan(data[step * src->ds_cnt])) {\n                array[field] = data[step * src->ds_cnt];\n               field++;\n            }\n        }\n        qsort(array, nancount, sizeof(double), vdef_percent_compar);\n        field = round( dst->vf.param * (double)(nancount - 1) / 100.0);\n        dst->vf.val = array[field];\n        dst->vf.when = 0;   /* no time component */\n        dst->vf.never = 1;\n        free(array);\n    }\n        break;\n    case VDEF_MAXIMUM:\n        step = 0;\n        while (step != steps && isnan(data[step * src->ds_cnt]))\n            step++;\n        if (step == steps) {\n            dst->vf.val = DNAN;\n            dst->vf.when = 0;\n            dst->vf.never = 1;\n        } else {\n            dst->vf.val = data[step * src->ds_cnt];\n            dst->vf.when = src->start + (step + 1) * src->step;\n            dst->vf.never = 0;\n        }\n        while (step != steps) {\n            if (finite(data[step * src->ds_cnt])) {\n                if (data[step * src->ds_cnt] > dst->vf.val) {\n                    dst->vf.val = data[step * src->ds_cnt];\n                    dst->vf.when = src->start + (step + 1) * src->step;\n                    dst->vf.never = 0;\n                }\n            }\n            step++;\n        }\n        break;\n    case VDEF_TOTAL:\n    case VDEF_STDEV:\n    case VDEF_AVERAGE:{\n        int       cnt = 0;\n        double    sum = 0.0;\n        double    average = 0.0;\n\n        for (step = 0; step < steps; step++) {\n            if (finite(data[step * src->ds_cnt])) {\n                sum += data[step * src->ds_cnt];\n                cnt++;\n            };\n        }\n        if (cnt) {\n            if (dst->vf.op == VDEF_TOTAL) {\n                dst->vf.val = sum * src->step;\n                dst->vf.when = 0;   /* no time component */\n                dst->vf.never = 1;\n            } else if (dst->vf.op == VDEF_AVERAGE) {\n                dst->vf.val = sum / cnt;\n                dst->vf.when = 0;   /* no time component */\n                dst->vf.never = 1;\n            } else {\n                average = sum / cnt;\n                sum = 0.0;\n                for (step = 0; step < steps; step++) {\n                    if (finite(data[step * src->ds_cnt])) {\n                        sum += pow((data[step * src->ds_cnt] - average), 2.0);\n                    };\n                }\n                dst->vf.val = pow(sum / cnt, 0.5);\n                dst->vf.when = 0;   /* no time component */\n                dst->vf.never = 1;\n            };\n        } else {\n            dst->vf.val = DNAN;\n            dst->vf.when = 0;\n            dst->vf.never = 1;\n        }\n    }\n        break;\n    case VDEF_MINIMUM:\n        step = 0;\n        while (step != steps && isnan(data[step * src->ds_cnt]))\n            step++;\n        if (step == steps) {\n            dst->vf.val = DNAN;\n            dst->vf.when = 0;\n            dst->vf.never = 1;\n        } else {\n            dst->vf.val = data[step * src->ds_cnt];\n            dst->vf.when = src->start + (step + 1) * src->step;\n            dst->vf.never = 0;\n        }\n        while (step != steps) {\n            if (finite(data[step * src->ds_cnt])) {\n                if (data[step * src->ds_cnt] < dst->vf.val) {\n                    dst->vf.val = data[step * src->ds_cnt];\n                    dst->vf.when = src->start + (step + 1) * src->step;\n                    dst->vf.never = 0;\n                }\n            }\n            step++;\n        }\n        break;\n    case VDEF_FIRST:\n        /* The time value returned here is one step before the\n         * actual time value.  This is the start of the first\n         * non-NaN interval.\n         */\n        step = 0;\n        while (step != steps && isnan(data[step * src->ds_cnt]))\n            step++;\n        if (step == steps) {    /* all entries were NaN */\n            dst->vf.val = DNAN;\n            dst->vf.when = 0;\n            dst->vf.never = 1;\n        } else {\n            dst->vf.val = data[step * src->ds_cnt];\n            dst->vf.when = src->start + step * src->step;\n            dst->vf.never = 0;\n        }\n        break;\n    case VDEF_LAST:\n        /* The time value returned here is the\n         * actual time value.  This is the end of the last\n         * non-NaN interval.\n         */\n        step = steps - 1;\n        while (step >= 0 && isnan(data[step * src->ds_cnt]))\n            step--;\n        if (step < 0) { /* all entries were NaN */\n            dst->vf.val = DNAN;\n            dst->vf.when = 0;\n            dst->vf.never = 1;\n        } else {\n            dst->vf.val = data[step * src->ds_cnt];\n            dst->vf.when = src->start + (step + 1) * src->step;\n            dst->vf.never = 0;\n        }\n        break;\n    case VDEF_LSLSLOPE:\n    case VDEF_LSLINT:\n    case VDEF_LSLCORREL:{\n        /* Bestfit line by linear least squares method */\n\n        int       cnt = 0;\n        double    SUMx, SUMy, SUMxy, SUMxx, SUMyy, slope, y_intercept, correl;\n\n        SUMx = 0;\n        SUMy = 0;\n        SUMxy = 0;\n        SUMxx = 0;\n        SUMyy = 0;\n        for (step = 0; step < steps; step++) {\n            if (finite(data[step * src->ds_cnt])) {\n                cnt++;\n                SUMx += step;\n                SUMxx += step * step;\n                SUMxy += step * data[step * src->ds_cnt];\n                SUMy += data[step * src->ds_cnt];\n                SUMyy += data[step * src->ds_cnt] * data[step * src->ds_cnt];\n            };\n        }\n\n        slope = (SUMx * SUMy - cnt * SUMxy) / (SUMx * SUMx - cnt * SUMxx);\n        y_intercept = (SUMy - slope * SUMx) / cnt;\n        correl =\n            (SUMxy -\n             (SUMx * SUMy) / cnt) /\n            sqrt((SUMxx -\n                  (SUMx * SUMx) / cnt) * (SUMyy - (SUMy * SUMy) / cnt));\n        if (cnt) {\n            if (dst->vf.op == VDEF_LSLSLOPE) {\n                dst->vf.val = slope;\n                dst->vf.when = 0;\n                dst->vf.never = 1;\n            } else if (dst->vf.op == VDEF_LSLINT) {\n                dst->vf.val = y_intercept;\n                dst->vf.when = 0;\n                dst->vf.never = 1;\n            } else if (dst->vf.op == VDEF_LSLCORREL) {\n                dst->vf.val = correl;\n                dst->vf.when = 0;\n                dst->vf.never = 1;\n            };\n        } else {\n            dst->vf.val = DNAN;\n            dst->vf.when = 0;\n            dst->vf.never = 1;\n        }\n    }\n        break;\n    }\n    return 0;\n}\n\n/* NaN < -INF < finite_values < INF */\nint vdef_percent_compar(\n    const void\n    *a,\n    const void\n    *b)\n{\n    /* Equality is not returned; this doesn't hurt except\n     * (maybe) for a little performance.\n     */\n\n    /* First catch NaN values. They are smallest */\n    if (isnan(*(double *) a))\n        return -1;\n    if (isnan(*(double *) b))\n        return 1;\n    /* NaN doesn't reach this part so INF and -INF are extremes.\n     * The sign from isinf() is compatible with the sign we return\n     */\n    if (isinf(*(double *) a))\n        return isinf(*(double *) a);\n    if (isinf(*(double *) b))\n        return isinf(*(double *) b);\n    /* If we reach this, both values must be finite */\n    if (*(double *) a < *(double *) b)\n        return -1;\n    else\n        return 1;\n}\n\nvoid grinfo_push(\n    image_desc_t *im,\n    char *key,\n    rrd_info_type_t type,\n    rrd_infoval_t value)\n{\n    im->grinfo_current = rrd_info_push(im->grinfo_current, key, type, value);\n    if (im->grinfo == NULL) {\n        im->grinfo = im->grinfo_current;\n    }\n}\n\n\nvoid time_clean(\n    char *result,\n    char *format)\n{\n    int       j, jj;\n    \n/*     Handling based on\n       - ANSI C99 Specifications                         http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf\n       - Single UNIX Specification version 2             http://www.opengroup.org/onlinepubs/007908799/xsh/strftime.html \n       - POSIX:2001/Single UNIX Specification version 3  http://www.opengroup.org/onlinepubs/009695399/functions/strftime.html\n       - POSIX:2008 Specifications                       http://www.opengroup.org/onlinepubs/9699919799/functions/strftime.html\n       Specifications tells \n       \"If a conversion specifier is not one of the above, the behavior is undefined.\"\n\n      C99 tells\n       \"A conversion specifier consists of a % character, possibly followed by an E or O modifier character (described below), followed by a character that determines the behavior of the conversion specifier.\n\n      POSIX:2001 tells\n      \"A conversion specification consists of a '%' character, possibly followed by an E or O modifier, and a terminating conversion specifier character that determines the conversion specification's behavior.\"\n\n      POSIX:2008 introduce more complexe behavior that are not handled here.\n\n      According to this, this code will replace:\n      - % followed by @ by a %@\n      - % followed by   by a %SPACE\n      - % followed by . by a %.\n      - % followed by % by a %\n      - % followed by t by a TAB\n      - % followed by E then anything by '-'\n      - % followed by O then anything by '-'\n      - % followed by anything else by at least one '-'. More characters may be added to better fit expected output length\n*/\n\n    jj = 0;\n    for(j = 0; (j < FMT_LEG_LEN - 1) && (jj < FMT_LEG_LEN); j++) { /* we don't need to parse the last char */\n        if (format[j] == '%') {\n            if ((format[j+1] == 'E') || (format[j+1] == 'O')) {\n                result[jj++] = '-';\n                j+=2; /* We skip next 2 following char */\n            } else if ((format[j+1] == 'C') || (format[j+1] == 'd') ||\n                       (format[j+1] == 'g') || (format[j+1] == 'H') ||\n                       (format[j+1] == 'I') || (format[j+1] == 'm') ||\n                       (format[j+1] == 'M') || (format[j+1] == 'S') ||\n                       (format[j+1] == 'U') || (format[j+1] == 'V') ||\n                       (format[j+1] == 'W') || (format[j+1] == 'y')) {\n                result[jj++] = '-';\n                if (jj < FMT_LEG_LEN) {\n                    result[jj++] = '-';\n                }\n                j++; /* We skip the following char */\n            } else if (format[j+1] == 'j') {\n                result[jj++] = '-';\n                if (jj < FMT_LEG_LEN - 1) {\n                    result[jj++] = '-';\n                    result[jj++] = '-';\n               }\n                j++; /* We skip the following char */\n            } else if ((format[j+1] == 'G') || (format[j+1] == 'Y')) {\n                /* Assuming Year on 4 digit */\n                result[jj++] = '-';\n                if (jj < FMT_LEG_LEN - 2) {\n                    result[jj++] = '-';\n                    result[jj++] = '-';\n                    result[jj++] = '-';\n                }\n                j++; /* We skip the following char */\n            } else if (format[j+1] == 'R') {\n                result[jj++] = '-';\n                if (jj < FMT_LEG_LEN - 3) {\n                    result[jj++] = '-';\n                    result[jj++] = ':';\n                    result[jj++] = '-';\n                    result[jj++] = '-';\n                }\n                j++; /* We skip the following char */\n            } else if (format[j+1] == 'T') {\n                result[jj++] = '-';\n                if (jj < FMT_LEG_LEN - 6) {\n                    result[jj++] = '-';\n                    result[jj++] = ':';\n                    result[jj++] = '-';\n                    result[jj++] = '-';\n                    result[jj++] = ':';\n                    result[jj++] = '-';\n                    result[jj++] = '-';\n                }\n                j++; /* We skip the following char */\n            } else if (format[j+1] == 'F') {\n                result[jj++] = '-';\n                if (jj < FMT_LEG_LEN - 8) {\n                    result[jj++] = '-';\n                    result[jj++] = '-';\n                    result[jj++] = '-';\n                    result[jj++] = '-';\n                    result[jj++] = '-';\n                    result[jj++] = '-';\n                    result[jj++] = '-';\n                    result[jj++] = '-';\n                    result[jj++] = '-';\n                }\n                j++; /* We skip the following char */\n            } else if (format[j+1] == 'D') {\n                result[jj++] = '-';\n                if (jj < FMT_LEG_LEN - 6) {\n                    result[jj++] = '-';\n                    result[jj++] = '/';\n                    result[jj++] = '-';\n                    result[jj++] = '-';\n                    result[jj++] = '/';\n                    result[jj++] = '-';\n                    result[jj++] = '-';\n                }\n                j++; /* We skip the following char */\n            } else if (format[j+1] == 'n') {\n                result[jj++] = '\\r';\n                result[jj++] = '\\n';\n                j++; /* We skip the following char */\n            } else if (format[j+1] == 't') {\n                result[jj++] = '\\t';\n                j++; /* We skip the following char */\n            } else if (format[j+1] == '%') {\n                result[jj++] = '%';\n                j++; /* We skip the following char */\n            } else if (format[j+1] == ' ') {\n                if (jj < FMT_LEG_LEN - 1) {\n                    result[jj++] = '%';\n                    result[jj++] = ' ';\n                }\n                j++; /* We skip the following char */\n            } else if (format[j+1] == '.') {\n                if (jj < FMT_LEG_LEN - 1) {\n                    result[jj++] = '%';\n                    result[jj++] = '.';\n                }\n                j++; /* We skip the following char */\n            } else if (format[j+1] == '@') {\n                if (jj < FMT_LEG_LEN - 1) {\n                    result[jj++] = '%';\n                    result[jj++] = '@';\n                }\n                j++; /* We skip the following char */\n            } else {\n                result[jj++] = '-';\n                j++; /* We skip the following char */\n            }\n        } else {\n                result[jj++] = format[j];\n        }\n    }\n    result[jj] = '\\0'; /* We must force the end of the string */\n}\n", "#ifndef RRD_GRAPH_H_DBEDBFB6C5844ED9BEA6242F879CA284\n#define RRD_GRAPH_H_DBEDBFB6C5844ED9BEA6242F879CA284\n\n#define y0 cairo_y0\n#define y1 cairo_y1\n#define index cairo_index\n\n/* this may configure __EXTENSIONS__ without which pango will fail to compile\n   so load this early */\n#include \"rrd_config.h\"\n\n#include <cairo.h>\n#include <cairo-pdf.h>\n#include <cairo-svg.h>\n#include <cairo-ps.h>\n\n#include <pango/pangocairo.h>\n\n\n#include \"rrd_tool.h\"\n#include \"rrd_rpncalc.h\"\n\n#include <glib.h>\n\n\n#ifdef WIN32\n#  include <windows.h>\n#  define MAXPATH MAX_PATH\n#endif\n\n#define ALTYGRID  \t 0x01   /* use alternative y grid algorithm */\n#define ALTAUTOSCALE\t 0x02   /* use alternative algorithm to find lower and upper bounds */\n#define ALTAUTOSCALE_MIN 0x04   /* use alternative algorithm to find lower bounds */\n#define ALTAUTOSCALE_MAX 0x08   /* use alternative algorithm to find upper bounds */\n#define NOLEGEND\t 0x10   /* use no legend */\n#define NOMINOR          0x20   /* Turn off minor gridlines */\n#define ONLY_GRAPH       0x40   /* use only graph */\n#define FORCE_RULES_LEGEND 0x80 /* force printing of HRULE and VRULE legend */\n\n#define FORCE_UNITS 0x100   /* mask for all FORCE_UNITS_* flags */\n#define FORCE_UNITS_SI 0x100    /* force use of SI units in Y axis (no effect in linear graph, SI instead of E in log graph) */\n\n#define FULL_SIZE_MODE     0x200    /* -width and -height indicate the total size of the image */\n#define NO_RRDTOOL_TAG 0x400  /* disable the rrdtool tag */\n#define ALLOW_MISSING_DS 0x800  /* missing DS is not fatal */\n\n#define gdes_fetch_key(x)  sprintf_alloc(\"%s:%d:%d:%d:%d\",x.rrd,x.cf,x.cf_reduce,x.start_orig,x.end_orig,x.step_orig)\n\nenum tmt_en { TMT_SECOND = 0, TMT_MINUTE, TMT_HOUR, TMT_DAY,\n    TMT_WEEK, TMT_MONTH, TMT_YEAR\n};\n\nenum grc_en { GRC_CANVAS = 0, GRC_BACK, GRC_SHADEA, GRC_SHADEB,\n    GRC_GRID, GRC_MGRID, GRC_FONT, GRC_ARROW, GRC_AXIS, GRC_FRAME, __GRC_END__\n};\n\n#define MGRIDWIDTH 0.6\n#define GRIDWIDTH  0.4\n\nenum gf_en { GF_PRINT = 0, GF_GPRINT, GF_COMMENT, GF_HRULE, GF_VRULE, GF_LINE,\n    GF_AREA,GF_GRAD, GF_STACK, GF_TICK, GF_TEXTALIGN,\n    GF_DEF, GF_CDEF, GF_VDEF, GF_SHIFT,\n    GF_XPORT, GF_XAXIS, GF_YAXIS\n};\n\nenum txa_en { TXA_LEFT = 0, TXA_RIGHT, TXA_CENTER, TXA_JUSTIFIED };\n\nenum vdef_op_en {\n    VDEF_MAXIMUM = 0    /* like the MAX in (G)PRINT */\n        , VDEF_MINIMUM  /* like the MIN in (G)PRINT */\n        , VDEF_AVERAGE  /* like the AVERAGE in (G)PRINT */\n        , VDEF_STDEV    /* the standard deviation */\n        , VDEF_PERCENT  /* Nth percentile */\n        , VDEF_TOTAL    /* average multiplied by time */\n        , VDEF_FIRST    /* first non-unknown value and time */\n        , VDEF_LAST     /* last  non-unknown value and time */\n        , VDEF_LSLSLOPE /* least squares line slope */\n        , VDEF_LSLINT   /* least squares line y_intercept */\n        , VDEF_LSLCORREL    /* least squares line correlation coefficient */\n        , VDEF_PERCENTNAN  /* Nth percentile ignoring NAN*/\n};\nenum text_prop_en { \n    TEXT_PROP_DEFAULT = 0,  /* default settings */\n    TEXT_PROP_TITLE,    /* properties for the title */\n    TEXT_PROP_AXIS,     /* for the numbers next to the axis */\n    TEXT_PROP_UNIT,     /* for the vertical unit description */\n    TEXT_PROP_LEGEND,   /* for the legend below the graph */\n    TEXT_PROP_WATERMARK, /* for the little text to the side of the graph */\n    TEXT_PROP_LAST\n};\n\nenum legend_pos{ NORTH = 0, WEST, SOUTH, EAST };\nenum legend_direction { TOP_DOWN = 0, BOTTOM_UP, BOTTOM_UP2 };\n\nenum gfx_if_en { IF_PNG = 0, IF_SVG, IF_EPS, IF_PDF, \n\t\t IF_XML=128, IF_CSV=129, IF_TSV=130, IF_SSV=131, IF_JSON=132,\n\t\t IF_XMLENUM=133, IF_JSONTIME=134\n};\nenum gfx_en { GFX_LINE = 0, GFX_AREA, GFX_TEXT };\nenum gfx_h_align_en { GFX_H_NULL = 0, GFX_H_LEFT, GFX_H_RIGHT, GFX_H_CENTER };\nenum gfx_v_align_en { GFX_V_NULL = 0, GFX_V_TOP, GFX_V_BOTTOM, GFX_V_CENTER };\n\nenum gfx_type_en {GTYPE_TIME=0,GTYPE_XY=1};\n\n/* cairo color components */\ntypedef struct gfx_color_t {\n    double    red;\n    double    green;\n    double    blue;\n    double    alpha;\n} gfx_color_t;\n\ntypedef struct keyvalue_t {\n  char* key;\n  char* value;\n  char* keyvalue;\n  int pos;\n  int flag;\n} keyvalue_t;\n\ntypedef struct keyint_t {\n  char*key;\n  int value;\n} keyint_t;\n\ntypedef struct parsedargs_t {\n  char *arg; /* copy of the parsed string - rewritten*/\n  const char *arg_orig; /* original argument */\n  int kv_cnt; /* number of key/value arguments */\n  keyvalue_t *kv_args; /* key value arguments */\n} parsedargs_t;\nvoid initParsedArguments(parsedargs_t*);\nvoid freeParsedArguments(parsedargs_t*);\nint addToArguments(parsedargs_t*, char*, char*, char*, int);\nint parseArguments(const char*, parsedargs_t*);\nvoid dumpKeyValue(char* ,keyvalue_t*);\nvoid dumpArguments(parsedargs_t*);\nchar* getKeyValueArgument(const char*, int, parsedargs_t*);\nint getMappedKeyValueArgument(const char*,int, parsedargs_t*,\n\t\t\t      int*,keyint_t**);\nint getLong(const char*,long *,char**,int);\nint getDouble(const char*,double *,char**);\nkeyvalue_t* getFirstUnusedArgument(int, parsedargs_t*);\nchar* checkUnusedValues(parsedargs_t*);\n\ntypedef struct text_prop_t {\n    double    size;\n    char      font[1024];\n    PangoFontDescription *font_desc;\n} text_prop_t;\n\n\ntypedef struct vdef_t {\n    enum vdef_op_en op;\n    double    param;    /* parameter for function, if applicable */\n    double    val;      /* resulting value */\n    time_t    when;     /* timestamp, if applicable */\n    int       never;    /* boolean, indicate that when value mean never */\n} vdef_t;\n\ntypedef struct xlab_t {\n    long      minsec;   /* minimum sec per pix */\n    long      length;   /* number of secs on the image */\n    enum tmt_en gridtm; /* grid interval in what ? */\n    long      gridst;   /* how many whats per grid */\n    enum tmt_en mgridtm;    /* label interval in what ? */\n    long      mgridst;  /* how many whats per label */\n    enum tmt_en labtm;  /* label interval in what ? */\n    long      labst;    /* how many whats per label */\n    long      precis;   /* label precision -> label placement */\n    char     *stst;     /* strftime string */\n} xlab_t;\n\ntypedef struct ygrid_scale_t {  /* y axis grid scaling info */\n    double    gridstep;\n    int       labfact;\n    char      labfmt[64];\n} ygrid_scale_t;\n\n/* sensible y label intervals ...*/\n\ntypedef struct ylab_t {\n    double    grid;     /* grid spacing */\n    int       lfac[4];  /* associated label spacing */\n} ylab_t;\n\n/* this structure describes the elements which can make up a graph.\n   because they are quite diverse, not all elements will use all the\n   possible parts of the structure. */\n#ifdef HAVE_SNPRINTF\n#define FMT_LEG_LEN 200\n#else\n#define FMT_LEG_LEN 2000\n#endif\n\n# define MAX_AXIS 4\n\ntypedef struct graph_desc_t {\n    enum gf_en gf;       /* graphing function */\n    int       stack;     /* boolean */\n    int       debug;     /* boolean */\n    int       skipscale; /* boolean */\n    char      vname[MAX_VNAME_LEN + 1]; /* name of the variable */\n    long      vidx;      /* gdes reference */\n    char      rrd[1024];    /* name of the rrd_file containing data */\n    char      ds_nam[DS_NAM_SIZE];  /* data source name */\n    long      ds;       /* data source number */\n    char      daemon[256];\n    enum cf_en cf;      /* consolidation function */\n    enum cf_en cf_reduce;   /* consolidation function for reduce_data() */\n    int        cf_reduce_set; /* is the cf_reduce option set */\n    struct gfx_color_t col, col2; /* graph color */\n\tdouble    gradheight;\n    char      format[FMT_LEG_LEN + 5];  /* format for PRINT AND GPRINT */\n    char      legend[FMT_LEG_LEN + 5];  /* legend */\n    int       strftm;   /* should the VDEF legend be formated with strftime */\n    double    leg_x, leg_y; /* location of legend */\n    double    yrule;    /* value for y rule line and for VDEF */\n    time_t    xrule;    /* time for x rule line and for VDEF */\n    vdef_t    vf;       /* instruction for VDEF function */\n    rpnp_t   *rpnp;     /* instructions for CDEF function */\n    char     *rpn;      /* string representation of rpn */\n\n    /* SHIFT implementation */\n    int       shidx;    /* gdes reference for offset (-1 --> constant) */\n    time_t    shval;    /* offset if shidx is -1 */\n    time_t    shift;    /* current shift applied */\n\n    /* description of data fetched for the graph element */\n    time_t    start, end;   /* timestaps for first and last data element */\n    time_t    start_orig, end_orig; /* timestaps for first and last data element */\n    unsigned long step; /* time between samples */\n    unsigned long step_orig;    /* time between samples */\n    unsigned long ds_cnt;   /* how many data sources are there in the fetch */\n    long      data_first;   /* first pointer to this data */\n    char    **ds_namv;  /* name of datasources  in the fetch. */\n    rrd_value_t *data;  /* the raw data drawn from the rrd */\n    rrd_value_t *p_data;    /* processed data, xsize elments */\n    double    linewidth;    /* linewideth */\n\n    /* dashed line stuff */\n    int       dash;     /* boolean, draw dashed line? */\n    double   *p_dashes; /* pointer do dash array which keeps the lengths of dashes */\n    int       ndash;    /* number of dash segments */\n    double    offset;   /* dash offset along the line */\n\n\n    enum txa_en txtalign;   /* change default alignment strategy for text */\n\n    /* the axis to use for this graph in x and y*/\n    int xaxisidx;\n    int yaxisidx;\n} graph_desc_t;\n\ntypedef struct image_desc_t {\n\n    /* configuration of graph */\n    char      graphfile[MAXPATH];   /* filename for graphic */\n    enum      gfx_type_en graph_type; /* type of the graph */\n    long      xsize, ysize; /* graph area size in pixels */\n    struct gfx_color_t graph_col[__GRC_END__];  /* real colors for the graph */\n    text_prop_t text_prop[TEXT_PROP_LAST];  /* text properties */\n    char      *ylegend; /* legend along the yaxis */\n    char      *title;   /* title for graph */\n    char      *watermark;   /* watermark for graph */\n    int       draw_x_grid;  /* no x-grid at all */\n    int       draw_y_grid;  /* no y-grid at all */\n    unsigned int draw_3d_border; /* size of border in pixels, 0 for off */\n    unsigned int dynamic_labels; /* pick the label shape according to the line drawn */\n    double    grid_dash_on, grid_dash_off;\n    xlab_t    xlab_user;    /* user defined labeling for xaxis */\n    char      *xlab_form;   /* format for the label on the xaxis */\n    double    second_axis_scale; /* relative to the first axis (0 to disable) */\n    double    second_axis_shift; /* how much is it shifted vs the first axis */\n    char      *second_axis_legend; /* label to put on the seond axis */\n    char      *second_axis_format; /* format for the numbers on the scond axis */    \n    char      *primary_axis_format; /* format for the numbers on the primary axis */\n    double    ygridstep;    /* user defined step for y grid */\n    int       ylabfact; /* every how many y grid shall a label be written ? */\n    double    tabwidth; /* tabwdith */\n    time_t    start, end;   /* what time does the graph cover */\n    unsigned long step; /* any preference for the default step ? */\n    rrd_value_t minval, maxval; /* extreme values in the data */\n    int       rigid;    /* do not expand range even with \n                           values outside */\n    ygrid_scale_t ygrid_scale;  /* calculated y axis grid info */\n    int       gridfit;  /* adjust y-axis range etc so all\n                           grindlines falls in integer pixel values */\n    char     *imginfo;  /* construct an <IMG ... tag and return \n                           as first retval */\n    enum gfx_if_en imgformat;   /* image format */\n    char     *daemon_addr;  /* rrdcached connection string */\n    int       lazy;     /* only update the image if there is\n                           reasonable probablility that the\n                           existing one is out of date */\n    int       slopemode;    /* connect the dots of the curve directly, not using a stair */\n    enum legend_pos legendposition; /* the position of the legend: north, west, south or east */\n    enum legend_direction legenddirection; /* The direction of the legend topdown or bottomup */\n    int       logarithmic;  /* scale the yaxis logarithmic */\n    double    force_scale_min;  /* Force a scale--min */\n    double    force_scale_max;  /* Force a scale--max */\n\n    /* status information */\n    int       with_markup;\n    long      xorigin, yorigin; /* where is (0,0) of the graph */\n    long      xOriginTitle, yOriginTitle; /* where is the origin of the title */\n    long      xOriginLegendY, yOriginLegendY; /* where is the origin of the y legend */\n    long      xOriginLegendY2, yOriginLegendY2; /* where is the origin of the second y legend */\n    long      xOriginLegend, yOriginLegend; /* where is the origin of the legend */\n    long      ximg, yimg;   /* total size of the image */\n    long      legendwidth, legendheight; /* the calculated height and width of the legend */\n    size_t    rendered_image_size;\n    double    zoom;\n    double    magfact;  /* numerical magnitude */\n    long      base;     /* 1000 or 1024 depending on what we graph */\n    char      symbol;   /* magnitude symbol for y-axis */\n    float     viewfactor;   /* how should the numbers on the y-axis be scaled for viewing ? */\n    int       unitsexponent;    /* 10*exponent for units on y-asis */\n    int       unitslength;  /* width of the yaxis labels */\n    int       forceleftspace;   /* do not kill the space to the left of the y-axis if there is no grid */\n\n    int       extra_flags;  /* flags for boolean options */\n    /* data elements */\n\n    unsigned char *rendered_image;\n    long      prt_c;    /* number of print elements */\n    long      gdes_c;   /* number of graphics elements */\n    graph_desc_t *gdes; /* points to an array of graph elements */\n    cairo_surface_t *surface;   /* graphics library */\n    cairo_t  *cr;       /* drawin context */\n    cairo_font_options_t *font_options; /* cairo font options */\n    cairo_antialias_t graph_antialias;  /* antialiasing for the graph */\n    PangoLayout *layout; /* the pango layout we use for writing fonts */\n    rrd_info_t *grinfo; /* root pointer to extra graph info */\n    rrd_info_t *grinfo_current; /* pointing to current entry */\n    GHashTable* gdef_map;  /* a map of all *def gdef entries for quick access */\n    GHashTable* rrd_map;  /* a map of all rrd files in use for gdef entries */\n} image_desc_t;\n\n/* Prototypes */\nint       xtr(\n    image_desc_t *,\n    time_t);\ndouble    ytr(\n    image_desc_t *,\n    double);\nenum gf_en gf_conv(\n    char *);\nenum gfx_if_en if_conv(\n    char *);\nenum gfx_type_en type_conv(\n    char *);\nenum tmt_en tmt_conv(\n    char *);\nenum grc_en grc_conv(\n    char *);\nenum text_prop_en text_prop_conv(\n    char *);\nint       im_free(\n    image_desc_t *);\nvoid      auto_scale(\n    image_desc_t *,\n    double *,\n    char **,\n    double *);\nvoid      si_unit(\n    image_desc_t *);\nvoid      expand_range(\n    image_desc_t *);\nvoid      apply_gridfit(\n    image_desc_t *);\nvoid      reduce_data(\n    enum cf_en,\n    unsigned long,\n    time_t *,\n    time_t *,\n    unsigned long *,\n    unsigned long *,\n    rrd_value_t **);\nint       data_fetch(\n    image_desc_t *);\nlong      lcd(\n    long *);\nint       data_calc(\n    image_desc_t *);\nint       data_proc(\n    image_desc_t *);\ntime_t    find_first_time(\n    time_t,\n    enum tmt_en,\n    long);\ntime_t    find_next_time(\n    time_t,\n    enum tmt_en,\n    long);\nint       print_calc(\n    image_desc_t *);\nint       leg_place(\n    image_desc_t *,\n    int);\nint       calc_horizontal_grid(\n    image_desc_t *);\nint       draw_horizontal_grid(\n    image_desc_t *);\nint       horizontal_log_grid(\n    image_desc_t *);\nvoid      vertical_grid(\n    image_desc_t *);\nvoid      axis_paint(\n    image_desc_t *);\nvoid      grid_paint(\n    image_desc_t *);\nint       lazy_check(\n    image_desc_t *);\nint       graph_paint(\n    image_desc_t *);\nint       graph_paint_timestring(\n                                image_desc_t *,int,int);\nint       graph_paint_xy(\n                        image_desc_t *,int,int);\nint       rrd_graph_xport(\n    image_desc_t *);\n\nint       graph_cairo_setup(\n    image_desc_t *);\nint       graph_cairo_finish(\n    image_desc_t *);\n\nint       gdes_alloc(\n    image_desc_t *);\nint       scan_for_col(\n    const char *const,\n    int,\n    char *const);\nvoid      rrd_graph_init(\n    image_desc_t *);\n\nvoid      time_clean(\n    char *result,\n    char *format);\n\nvoid      rrd_graph_options(\n    int,\n    char **,\n    image_desc_t *);\nvoid      rrd_graph_script(\n    int,\n    char **,\n    image_desc_t *,\n    int);\nint       rrd_graph_color(\n    image_desc_t *,\n    char *,\n    char *,\n    int);\nint       bad_format_axis(\n    char *);\nint       bad_format_print(\n    char *);\nint       bad_format_imginfo(\n    char *);\nint       bad_format_imginfo(\n    char *);\nint       vdef_parse(\n    struct graph_desc_t *,\n    const char *const);\nint       vdef_calc(\n    image_desc_t *,\n    int);\nint       vdef_percent_compar(\n    const void *,\n    const void *);\nint       graph_size_location(\n    image_desc_t *,\n    int);\n\n\n/* create a new line */\nvoid      gfx_line(\n    image_desc_t *im,\n    double X0,\n    double Y0,\n    double X1,\n    double Y1,\n    double width,\n    gfx_color_t color);\n\nvoid      gfx_dashed_line(\n    image_desc_t *im,\n    double X0,\n    double Y0,\n    double X1,\n    double Y1,\n    double width,\n    gfx_color_t color,\n    double dash_on,\n    double dash_off);\n\n/* create a new area */\nvoid      gfx_new_area(\n    image_desc_t *im,\n    double X0,\n    double Y0,\n    double X1,\n    double Y1,\n    double X2,\n    double Y2,\n    gfx_color_t color);\n\n/* add a point to a line or to an area */\nvoid      gfx_add_point(\n    image_desc_t *im,\n    double x,\n    double y);\n\n/* create a rect that has a gradient from color1 to color2 in height pixels \n * height > 0:\n * \t\tgradient starts at top and goes down a fixed number of pixels (fire style)\n * height < 0:\n * \t\tgradient starts at bottom and goes up a fixed number of pixels (constant style)\n * height == 0:\n * \t\tgradient is stretched between two points\n */\nvoid gfx_add_rect_fadey(\n    image_desc_t *im,\n    double x1,double y1,\n    double x2,double y2,\n\tdouble py,\n    gfx_color_t color1,\n\tgfx_color_t color2,\n\tdouble height);\n\t\t\t\t\n\n\n/* close current path so it ends at the same point as it started */\nvoid      gfx_close_path(\n    image_desc_t *im);\n\n\n/* create a text node */\nvoid      gfx_text(\n    image_desc_t *im,\n    double x,\n    double y,\n    gfx_color_t color,\n    PangoFontDescription *font_desc,\n    double tabwidth,\n    double angle,\n    enum gfx_h_align_en h_align,\n    enum gfx_v_align_en v_align,\n    const char *text);\n\n/* measure width of a text string */\ndouble    gfx_get_text_width(\n    image_desc_t *im,\n    double start,\n    PangoFontDescription *font_desc,\n    double tabwidth,\n    char *text);\n\n\n/* convert color */\ngfx_color_t gfx_hex_to_col(\n    long unsigned int);\n\nvoid      gfx_line_fit(\n    image_desc_t *im,\n    double *x,\n    double *y);\n\nvoid      gfx_area_fit(\n    image_desc_t *im,\n    double *x,\n    double *y);\n\n#endif\n\nvoid      grinfo_push(\n    image_desc_t *im,\n    char *key,\n    rrd_info_type_t type,    rrd_infoval_t value);\n\n\n"], "filenames": ["src/rrd_graph.c", "src/rrd_graph.h"], "buggy_code_start_loc": [8, 456], "buggy_code_end_loc": [5163, 457], "fixing_code_start_loc": [9, 456], "fixing_code_end_loc": [5094, 461], "type": "CWE-134", "message": "Multiple format string vulnerabilities in the python module in RRDtool, as used in Zenoss Core before 4.2.5 and other products, allow remote attackers to execute arbitrary code or cause a denial of service (application crash) via a crafted third argument to the rrdtool.graph function, aka ZEN-15415, a related issue to CVE-2013-2131.", "other": {"cve": {"id": "CVE-2014-6262", "sourceIdentifier": "cve@mitre.org", "published": "2020-02-12T02:15:10.603", "lastModified": "2022-01-01T19:51:42.883", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Multiple format string vulnerabilities in the python module in RRDtool, as used in Zenoss Core before 4.2.5 and other products, allow remote attackers to execute arbitrary code or cause a denial of service (application crash) via a crafted third argument to the rrdtool.graph function, aka ZEN-15415, a related issue to CVE-2013-2131."}, {"lang": "es", "value": "M\u00faltiples vulnerabilidades de cadena de formato en el m\u00f3dulo de Python en RRDtool, como es usado en Zenoss Core versiones anteriores a 4.2.5 y otros productos, permiten a atacantes remotos ejecutar c\u00f3digo arbitrario o causar una denegaci\u00f3n de servicio (bloqueo de aplicaci\u00f3n) por medio de un tercer argumento dise\u00f1ado en la funci\u00f3n rrdtool.graph, tambi\u00e9n se conoce como ZEN-15415, un problema relacionado con CVE-2013-2131."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-134"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:zenoss:zenoss_core:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.2.5", "matchCriteriaId": "DD20F6C1-D042-4960-8F39-C3D82B3121D2"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}], "references": [{"url": "http://www.kb.cert.org/vuls/id/449452", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "US Government Resource"]}, {"url": "https://docs.google.com/spreadsheets/d/1dHAc4PxUbs-4Dxzm1wSCE0sMz5UCMY6SW3PlMHSyuuQ/edit?usp=sharing", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/oetiker/rrdtool-1.x/commit/64ed5314af1255ab6dded45f70b39cdeab5ae2ec", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/oetiker/rrdtool-1.x/commit/85261a013112e278c90224033f5b0592ee387786", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/oetiker/rrdtool-1.x/pull/532", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/03/msg00000.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/03/msg00003.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://www.securityfocus.com/bid/71540", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}]}, "github_commit_url": "https://github.com/oetiker/rrdtool-1.x/commit/64ed5314af1255ab6dded45f70b39cdeab5ae2ec"}}