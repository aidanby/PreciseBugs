{"buggy_code": ["/* $Id$ */\n/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#include <pjsip/sip_ua_layer.h>\n#include <pjsip/sip_module.h>\n#include <pjsip/sip_dialog.h>\n#include <pjsip/sip_endpoint.h>\n#include <pjsip/sip_errno.h>\n#include <pjsip/sip_transaction.h>\n#include <pj/os.h>\n#include <pj/hash.h>\n#include <pj/assert.h>\n#include <pj/string.h>\n#include <pj/pool.h>\n#include <pj/log.h>\n\n\n#define THIS_FILE    \"sip_ua_layer.c\"\n\n/*\n * Static prototypes.\n */\nstatic pj_status_t mod_ua_load(pjsip_endpoint *endpt);\nstatic pj_status_t mod_ua_unload(void);\nstatic pj_bool_t   mod_ua_on_rx_request(pjsip_rx_data *rdata);\nstatic pj_bool_t   mod_ua_on_rx_response(pjsip_rx_data *rdata);\nstatic void\t   mod_ua_on_tsx_state(pjsip_transaction*, pjsip_event*);\n\n\nextern long pjsip_dlg_lock_tls_id;\t/* defined in sip_dialog.c */\n\n/* This struct is used to represent list of dialog inside a dialog set.\n * We don't want to use pjsip_dialog for this purpose, to save some\n * memory (about 100 bytes per dialog set).\n */\nstruct dlg_set_head\n{\n    PJ_DECL_LIST_MEMBER(pjsip_dialog);\n};\n\n/* This struct represents a dialog set.\n * This is the value that will be put in the UA's hash table.\n */\nstruct dlg_set\n{\n    /* To put this node in free dlg_set nodes in UA. */\n    PJ_DECL_LIST_MEMBER(struct dlg_set);\n\n    /* This is the buffer to store this entry in the hash table. */\n    pj_hash_entry_buf ht_entry;\n\n    /* List of dialog in this dialog set. */\n    struct dlg_set_head  dlg_list;\n};\n\n\n/*\n * Module interface.\n */\nstatic struct user_agent\n{\n    pjsip_module\t mod;\n    pj_pool_t\t\t*pool;\n    pjsip_endpoint\t*endpt;\n    pj_mutex_t\t\t*mutex;\n    pj_hash_table_t\t*dlg_table;\n    pjsip_ua_init_param  param;\n    struct dlg_set\t free_dlgset_nodes;\n\n} mod_ua = \n{\n  {\n    NULL, NULL,\t\t    /* prev, next.\t\t\t*/\n    { \"mod-ua\", 6 },\t    /* Name.\t\t\t\t*/\n    -1,\t\t\t    /* Id\t\t\t\t*/\n    PJSIP_MOD_PRIORITY_UA_PROXY_LAYER,\t/* Priority\t\t*/\n    &mod_ua_load,\t    /* load()\t\t\t\t*/\n    NULL,\t\t    /* start()\t\t\t\t*/\n    NULL,\t\t    /* stop()\t\t\t\t*/\n    &mod_ua_unload,\t    /* unload()\t\t\t\t*/\n    &mod_ua_on_rx_request,  /* on_rx_request()\t\t\t*/\n    &mod_ua_on_rx_response, /* on_rx_response()\t\t\t*/\n    NULL,\t\t    /* on_tx_request.\t\t\t*/\n    NULL,\t\t    /* on_tx_response()\t\t\t*/\n    &mod_ua_on_tsx_state,   /* on_tsx_state()\t\t\t*/\n  }\n};\n\n/* \n * mod_ua_load()\n *\n * Called when module is being loaded by endpoint.\n */\nstatic pj_status_t mod_ua_load(pjsip_endpoint *endpt)\n{\n    pj_status_t status;\n\n    /* Initialize the user agent. */\n    mod_ua.endpt = endpt;\n    mod_ua.pool = pjsip_endpt_create_pool( endpt, \"ua%p\", PJSIP_POOL_LEN_UA,\n\t\t\t\t\t   PJSIP_POOL_INC_UA);\n    if (mod_ua.pool == NULL)\n\treturn PJ_ENOMEM;\n\n    status = pj_mutex_create_recursive(mod_ua.pool, \" ua%p\", &mod_ua.mutex);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    mod_ua.dlg_table = pj_hash_create(mod_ua.pool, PJSIP_MAX_DIALOG_COUNT);\n    if (mod_ua.dlg_table == NULL)\n\treturn PJ_ENOMEM;\n\n    pj_list_init(&mod_ua.free_dlgset_nodes);\n\n    /* Initialize dialog lock. */\n    status = pj_thread_local_alloc(&pjsip_dlg_lock_tls_id);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    pj_thread_local_set(pjsip_dlg_lock_tls_id, NULL);\n\n    return PJ_SUCCESS;\n\n}\n\n/*\n * mod_ua_unload()\n *\n * Called when module is being unloaded.\n */\nstatic pj_status_t mod_ua_unload(void)\n{\n    pj_thread_local_free(pjsip_dlg_lock_tls_id);\n    pj_mutex_destroy(mod_ua.mutex);\n\n    /* Release pool */\n    if (mod_ua.pool) {\n\tpjsip_endpt_release_pool( mod_ua.endpt, mod_ua.pool );\n    }\n    return PJ_SUCCESS;\n}\n\n/*\n * mod_ua_on_tsx_stats()\n *\n * Called on changed on transaction state.\n */\nstatic void mod_ua_on_tsx_state( pjsip_transaction *tsx, pjsip_event *e)\n{\n    pjsip_dialog *dlg;\n\n    /* If the module id is -1, it could mean that the module has been\n     * destroyed.\n     */\n    if (mod_ua.mod.id == -1)\n\treturn;\n\n    /* Get the dialog where this transaction belongs. */\n    dlg = (pjsip_dialog*) tsx->mod_data[mod_ua.mod.id];\n    \n    /* If dialog instance has gone, it could mean that the dialog\n     * may has been destroyed.\n     */\n    if (dlg == NULL)\n\treturn;\n\n    /* Hand over the event to the dialog. */\n    pjsip_dlg_on_tsx_state(dlg, tsx, e);\n}\n\n\n/*\n * Init user agent module and register it to the endpoint.\n */\nPJ_DEF(pj_status_t) pjsip_ua_init_module( pjsip_endpoint *endpt,\n\t\t\t\t\t  const pjsip_ua_init_param *prm)\n{\n    pj_status_t status;\n\n    /* Check if module already registered. */\n    PJ_ASSERT_RETURN(mod_ua.mod.id == -1, PJ_EINVALIDOP);\n\n    /* Copy param, if exists. */\n    if (prm)\n\tpj_memcpy(&mod_ua.param, prm, sizeof(pjsip_ua_init_param));\n\n    /* Register the module. */\n    status = pjsip_endpt_register_module(endpt, &mod_ua.mod);\n\n    return status;\n}\n\n/*\n * Get the instance of the user agent.\n *\n */\nPJ_DEF(pjsip_user_agent*) pjsip_ua_instance(void)\n{\n    return &mod_ua.mod;\n}\n\n\n/*\n * Get the endpoint where this UA is currently registered.\n */\nPJ_DEF(pjsip_endpoint*) pjsip_ua_get_endpt(pjsip_user_agent *ua)\n{\n    PJ_UNUSED_ARG(ua);\n    pj_assert(ua == &mod_ua.mod);\n    return mod_ua.endpt;\n}\n\n\n/*\n * Destroy the user agent layer.\n */\nPJ_DEF(pj_status_t) pjsip_ua_destroy(void)\n{\n    /* Check if module already destroyed. */\n    PJ_ASSERT_RETURN(mod_ua.mod.id != -1, PJ_EINVALIDOP);\n\n    return pjsip_endpt_unregister_module(mod_ua.endpt, &mod_ua.mod);\n}\n\n\n\n/*\n * Create key to identify dialog set.\n */\n/*\nPJ_DEF(void) pjsip_ua_create_dlg_set_key( pj_pool_t *pool,\n\t\t\t\t\t  pj_str_t *set_key,\n\t\t\t\t\t  const pj_str_t *call_id,\n\t\t\t\t\t  const pj_str_t *local_tag)\n{\n    PJ_ASSERT_ON_FAIL(pool && set_key && call_id && local_tag, return;);\n\n    set_key->slen = call_id->slen + local_tag->slen + 1;\n    set_key->ptr = (char*) pj_pool_alloc(pool, set_key->slen);\n    pj_assert(set_key->ptr != NULL);\n\n    pj_memcpy(set_key->ptr, call_id->ptr, call_id->slen);\n    set_key->ptr[call_id->slen] = '$';\n    pj_memcpy(set_key->ptr + call_id->slen + 1, \n\t      local_tag->ptr, local_tag->slen);\n}\n*/\n\n/*\n * Acquire one dlg_set node to be put in the hash table.\n * This will first look in the free nodes list, then allocate\n * a new one from UA's pool when one is not available.\n */\nstatic struct dlg_set *alloc_dlgset_node(void)\n{\n    struct dlg_set *set;\n\n    if (!pj_list_empty(&mod_ua.free_dlgset_nodes)) {\n\tset = mod_ua.free_dlgset_nodes.next;\n\tpj_list_erase(set);\n\treturn set;\n    } else {\n\tset = PJ_POOL_ALLOC_T(mod_ua.pool, struct dlg_set);\n\treturn set;\n    }\n}\n\n/*\n * Register new dialog. Called by pjsip_dlg_create_uac() and\n * pjsip_dlg_create_uas_and_inc_lock();\n */\nPJ_DEF(pj_status_t) pjsip_ua_register_dlg( pjsip_user_agent *ua,\n\t\t\t\t\t   pjsip_dialog *dlg )\n{\n    /* Sanity check. */\n    PJ_ASSERT_RETURN(ua && dlg, PJ_EINVAL);\n\n    /* For all dialogs, local tag (inc hash) must has been initialized. */\n    PJ_ASSERT_RETURN(dlg->local.info && dlg->local.info->tag.slen &&\n\t\t     dlg->local.tag_hval != 0, PJ_EBUG);\n\n    /* For UAS dialog, remote tag (inc hash) must have been initialized. */\n    //PJ_ASSERT_RETURN(dlg->role==PJSIP_ROLE_UAC ||\n    //\t\t     (dlg->role==PJSIP_ROLE_UAS && dlg->remote.info->tag.slen\n    //\t\t      && dlg->remote.tag_hval != 0), PJ_EBUG);\n\n    /* Lock the user agent. */\n    pj_mutex_lock(mod_ua.mutex);\n\n    /* For UAC, check if there is existing dialog in the same set. */\n    if (dlg->role == PJSIP_ROLE_UAC) {\n\tstruct dlg_set *dlg_set;\n\n\tdlg_set = (struct dlg_set*)\n\t\t  pj_hash_get_lower( mod_ua.dlg_table,\n                                     dlg->local.info->tag.ptr, \n\t\t\t             (unsigned)dlg->local.info->tag.slen,\n\t\t\t             &dlg->local.tag_hval);\n\n\tif (dlg_set) {\n\t    /* This is NOT the first dialog in the dialog set. \n\t     * Just add this dialog in the list.\n\t     */\n\t    pj_assert(dlg_set->dlg_list.next != (void*)&dlg_set->dlg_list);\n\t    pj_list_push_back(&dlg_set->dlg_list, dlg);\n\n\t    dlg->dlg_set = dlg_set;\n\n\t} else {\n\t    /* This is the first dialog in the dialog set. \n\t     * Create the dialog set and add this dialog to it.\n\t     */\n\t    dlg_set = alloc_dlgset_node();\n\t    pj_list_init(&dlg_set->dlg_list);\n\t    pj_list_push_back(&dlg_set->dlg_list, dlg);\n\n\t    dlg->dlg_set = dlg_set;\n\n\t    /* Register the dialog set in the hash table. */\n\t    pj_hash_set_np_lower(mod_ua.dlg_table, \n\t\t\t         dlg->local.info->tag.ptr,\n                                 (unsigned)dlg->local.info->tag.slen,\n\t\t\t         dlg->local.tag_hval, dlg_set->ht_entry,\n                                 dlg_set);\n\t}\n\n    } else {\n\t/* For UAS, create the dialog set with a single dialog as member. */\n\tstruct dlg_set *dlg_set;\n\n\tdlg_set = alloc_dlgset_node();\n\tpj_list_init(&dlg_set->dlg_list);\n\tpj_list_push_back(&dlg_set->dlg_list, dlg);\n\n\tdlg->dlg_set = dlg_set;\n\n\tpj_hash_set_np_lower(mod_ua.dlg_table, \n\t\t             dlg->local.info->tag.ptr,\n                             (unsigned)dlg->local.info->tag.slen,\n\t\t             dlg->local.tag_hval, dlg_set->ht_entry, dlg_set);\n    }\n\n    /* Unlock user agent. */\n    pj_mutex_unlock(mod_ua.mutex);\n\n    /* Done. */\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(pj_status_t) pjsip_ua_unregister_dlg( pjsip_user_agent *ua,\n\t\t\t\t\t     pjsip_dialog *dlg )\n{\n    struct dlg_set *dlg_set;\n    pjsip_dialog *d;\n\n    /* Sanity-check arguments. */\n    PJ_ASSERT_RETURN(ua && dlg, PJ_EINVAL);\n\n    /* Check that dialog has been registered. */\n    PJ_ASSERT_RETURN(dlg->dlg_set, PJ_EINVALIDOP);\n\n    /* Lock user agent. */\n    pj_mutex_lock(mod_ua.mutex);\n\n    /* Find this dialog from the dialog set. */\n    dlg_set = (struct dlg_set*) dlg->dlg_set;\n    d = dlg_set->dlg_list.next;\n    while (d != (pjsip_dialog*)&dlg_set->dlg_list && d != dlg) {\n\td = d->next;\n    }\n\n    if (d != dlg) {\n\tpj_assert(!\"Dialog is not registered!\");\n\tpj_mutex_unlock(mod_ua.mutex);\n\treturn PJ_EINVALIDOP;\n    }\n\n    /* Remove this dialog from the list. */\n    pj_list_erase(dlg);\n\n    /* If dialog list is empty, remove the dialog set from the hash table. */\n    if (pj_list_empty(&dlg_set->dlg_list)) {\n\tpj_hash_set_lower(NULL, mod_ua.dlg_table, dlg->local.info->tag.ptr,\n\t\t          (unsigned)dlg->local.info->tag.slen, \n\t\t\t  dlg->local.tag_hval, NULL);\n\n\t/* Return dlg_set to free nodes. */\n\tpj_list_push_back(&mod_ua.free_dlgset_nodes, dlg_set);\n    }\n\n    /* Unlock user agent. */\n    pj_mutex_unlock(mod_ua.mutex);\n\n    /* Done. */\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(pjsip_dialog*) pjsip_rdata_get_dlg( pjsip_rx_data *rdata )\n{\n    return (pjsip_dialog*) rdata->endpt_info.mod_data[mod_ua.mod.id];\n}\n\nPJ_DEF(pjsip_dialog*) pjsip_tdata_get_dlg( pjsip_tx_data *tdata )\n{\n    return (pjsip_dialog*) tdata->mod_data[mod_ua.mod.id];\n}\n\nPJ_DEF(pjsip_dialog*) pjsip_tsx_get_dlg( pjsip_transaction *tsx )\n{\n    return (pjsip_dialog*) tsx->mod_data[mod_ua.mod.id];\n}\n\n\n/*\n * Retrieve the current number of dialog-set currently registered\n * in the hash table. \n */\nPJ_DEF(unsigned) pjsip_ua_get_dlg_set_count(void)\n{\n    unsigned count;\n\n    PJ_ASSERT_RETURN(mod_ua.endpt, 0);\n\n    pj_mutex_lock(mod_ua.mutex);\n    count = pj_hash_count(mod_ua.dlg_table);\n    pj_mutex_unlock(mod_ua.mutex);\n\n    return count;\n}\n\n\n/* \n * Find a dialog.\n */\nPJ_DEF(pjsip_dialog*) pjsip_ua_find_dialog(const pj_str_t *call_id,\n\t\t\t\t\t   const pj_str_t *local_tag,\n\t\t\t\t\t   const pj_str_t *remote_tag,\n\t\t\t\t\t   pj_bool_t lock_dialog)\n{\n    struct dlg_set *dlg_set;\n    pjsip_dialog *dlg;\n\n    PJ_ASSERT_RETURN(call_id && local_tag && remote_tag, NULL);\n\n    /* Lock user agent. */\n    pj_mutex_lock(mod_ua.mutex);\n\n    /* Lookup the dialog set. */\n    dlg_set = (struct dlg_set*)\n    \t      pj_hash_get_lower(mod_ua.dlg_table, local_tag->ptr,\n                                (unsigned)local_tag->slen, NULL);\n    if (dlg_set == NULL) {\n\t/* Not found */\n\tpj_mutex_unlock(mod_ua.mutex);\n\treturn NULL;\n    }\n\n    /* Dialog set is found, now find the matching dialog based on the\n     * remote tag.\n     */\n    dlg = dlg_set->dlg_list.next;\n    while (dlg != (pjsip_dialog*)&dlg_set->dlg_list) {\t\n\tif (pj_stricmp(&dlg->remote.info->tag, remote_tag) == 0)\n\t    break;\n\tdlg = dlg->next;\n    }\n\n    if (dlg == (pjsip_dialog*)&dlg_set->dlg_list) {\n\t/* Not found */\n\tpj_mutex_unlock(mod_ua.mutex);\n\treturn NULL;\n    }\n\n    /* Dialog has been found. It SHOULD have the right Call-ID!! */\n    if (pj_strcmp(&dlg->call_id->id, call_id)!=0) {\n\n\tPJ_LOG(6, (THIS_FILE, \"Dialog not found: local and remote tags \"\n\t\t              \"matched but not call id\"));\n\n        pj_mutex_unlock(mod_ua.mutex);\n        return NULL;\n    }\n\n    if (lock_dialog) {\n\tif (pjsip_dlg_try_inc_lock(dlg) != PJ_SUCCESS) {\n\n\t    /*\n\t     * Unable to acquire dialog's lock while holding the user\n\t     * agent's mutex. Release the UA mutex before retrying once\n\t     * more.\n\t     *\n\t     * THIS MAY CAUSE RACE CONDITION!\n\t     */\n\n\t    /* Unlock user agent. */\n\t    pj_mutex_unlock(mod_ua.mutex);\n\t    /* Lock dialog */\n\t    pjsip_dlg_inc_lock(dlg);\n\n\t} else {\n\t    /* Unlock user agent. */\n\t    pj_mutex_unlock(mod_ua.mutex);\n\t}\n\n    } else {\n\t/* Unlock user agent. */\n\tpj_mutex_unlock(mod_ua.mutex);\n    }\n\n    return dlg;\n}\n\n\n/*\n * Find the first dialog in dialog set in hash table for an incoming message.\n */\nstatic struct dlg_set *find_dlg_set_for_msg( pjsip_rx_data *rdata )\n{\n    /* CANCEL message doesn't have To tag, so we must lookup the dialog\n     * by finding the INVITE UAS transaction being cancelled.\n     */\n    if (rdata->msg_info.cseq->method.id == PJSIP_CANCEL_METHOD) {\n\n\tpjsip_dialog *dlg;\n\n\t/* Create key for the rdata, but this time, use INVITE as the\n\t * method.\n\t */\n\tpj_str_t key;\n\tpjsip_role_e role;\n\tpjsip_transaction *tsx;\n\n\tif (rdata->msg_info.msg->type == PJSIP_REQUEST_MSG)\n\t    role = PJSIP_ROLE_UAS;\n\telse\n\t    role = PJSIP_ROLE_UAC;\n\n\tpjsip_tsx_create_key(rdata->tp_info.pool, &key, role, \n\t\t\t     pjsip_get_invite_method(), rdata);\n\n\t/* Lookup the INVITE transaction */\n\ttsx = pjsip_tsx_layer_find_tsx2(&key, PJ_TRUE);\n\n\t/* We should find the dialog attached to the INVITE transaction */\n\tif (tsx) {\n\t    dlg = (pjsip_dialog*) tsx->mod_data[mod_ua.mod.id];\n\t    pj_grp_lock_dec_ref(tsx->grp_lock);\n\n\t    /* Dlg may be NULL on some extreme condition\n\t     * (e.g. during debugging where initially there is a dialog)\n\t     */\n\t    return dlg ? (struct dlg_set*) dlg->dlg_set : NULL;\n\n\t} else {\n\t    return NULL;\n\t}\n\n\n    } else {\n\tpj_str_t *tag;\n\tstruct dlg_set *dlg_set;\n\n\tif (rdata->msg_info.msg->type == PJSIP_REQUEST_MSG)\n\t    tag = &rdata->msg_info.to->tag;\n\telse\n\t    tag = &rdata->msg_info.from->tag;\n\n\t/* Lookup the dialog set. */\n\tdlg_set = (struct dlg_set*)\n\t\t  pj_hash_get_lower(mod_ua.dlg_table, tag->ptr, \n\t\t\t\t    (unsigned)tag->slen, NULL);\n\treturn dlg_set;\n    }\n}\n\n/* On received requests. */\nstatic pj_bool_t mod_ua_on_rx_request(pjsip_rx_data *rdata)\n{\n    struct dlg_set *dlg_set;\n    pj_str_t *from_tag;\n    pjsip_dialog *dlg;\n    pj_status_t status;\n\n    /* Optimized path: bail out early if request is not CANCEL and it doesn't\n     * have To tag \n     */\n    if (rdata->msg_info.to->tag.slen == 0 && \n\trdata->msg_info.msg->line.req.method.id != PJSIP_CANCEL_METHOD)\n    {\n\treturn PJ_FALSE;\n    }\n\n    /* Incoming REGISTER may have tags in it */\n    if (rdata->msg_info.msg->line.req.method.id == PJSIP_REGISTER_METHOD)\n\treturn PJ_FALSE;\n\nretry_on_deadlock:\n\n    /* Lock user agent before looking up the dialog hash table. */\n    pj_mutex_lock(mod_ua.mutex);\n\n    /* Lookup the dialog set, based on the To tag header. */\n    dlg_set = find_dlg_set_for_msg(rdata);\n\n    /* If dialog is not found, respond with 481 (Call/Transaction\n     * Does Not Exist).\n     */\n    if (dlg_set == NULL) {\n\t/* Unable to find dialog. */\n\tpj_mutex_unlock(mod_ua.mutex);\n\n\tif (rdata->msg_info.msg->line.req.method.id != PJSIP_ACK_METHOD) {\n\t    PJ_LOG(5,(THIS_FILE, \n\t\t      \"Unable to find dialogset for %s, answering with 481\",\n\t\t      pjsip_rx_data_get_info(rdata)));\n\n\t    /* Respond with 481 . */\n\t    pjsip_endpt_respond_stateless( mod_ua.endpt, rdata, 481, NULL, \n\t\t\t\t\t   NULL, NULL );\n\t}\n\treturn PJ_TRUE;\n    }\n\n    /* Dialog set has been found.\n     * Find the dialog in the dialog set based on the content of the remote \n     * tag.\n     */\n    from_tag = &rdata->msg_info.from->tag;\n    dlg = dlg_set->dlg_list.next;\n    while (dlg != (pjsip_dialog*)&dlg_set->dlg_list) {\n\t\n\tif (pj_stricmp(&dlg->remote.info->tag, from_tag) == 0)\n\t    break;\n\n\tdlg = dlg->next;\n    }\n\n    /* Dialog may not be found, e.g. in this case:\n     *\t- UAC sends SUBSCRIBE, then UAS sends NOTIFY before answering\n     *    SUBSCRIBE request with 2xx.\n     *\n     * In this case, we can accept the request ONLY when the original \n     * dialog still has empty To tag.\n     */\n    if (dlg == (pjsip_dialog*)&dlg_set->dlg_list) {\n\n\tpjsip_dialog *first_dlg = dlg_set->dlg_list.next;\n\n\tif (first_dlg->remote.info->tag.slen != 0) {\n\t    /* Not found. Mulfunction UAC? */\n\t    pj_mutex_unlock(mod_ua.mutex);\n\n\t    if (rdata->msg_info.msg->line.req.method.id != PJSIP_ACK_METHOD) {\n\t\tPJ_LOG(5,(THIS_FILE, \n\t\t          \"Unable to find dialog for %s, answering with 481\",\n\t\t          pjsip_rx_data_get_info(rdata)));\n\n\t\tpjsip_endpt_respond_stateless(mod_ua.endpt, rdata,\n\t\t\t\t\t      PJSIP_SC_CALL_TSX_DOES_NOT_EXIST, \n\t\t\t\t\t      NULL, NULL, NULL);\n\t    } else {\n\t\tPJ_LOG(5,(THIS_FILE, \n\t\t          \"Unable to find dialog for %s\",\n\t\t          pjsip_rx_data_get_info(rdata)));\n\t    }\n\t    return PJ_TRUE;\n\t}\n\n\tdlg = first_dlg;\n    }\n\n    /* Mark the dialog id of the request. */\n    rdata->endpt_info.mod_data[mod_ua.mod.id] = dlg;\n\n    /* Try to lock the dialog */\n    PJ_LOG(6,(dlg->obj_name, \"UA layer acquiring dialog lock for request\"));\n    status = pjsip_dlg_try_inc_lock(dlg);\n    if (status != PJ_SUCCESS) {\n\t/* Failed to acquire dialog mutex immediately, this could be \n\t * because of deadlock. Release UA mutex, yield, and retry \n\t * the whole thing once again.\n\t */\n\tpj_mutex_unlock(mod_ua.mutex);\n\tpj_thread_sleep(0);\n\tgoto retry_on_deadlock;\n    }\n\n    /* Done with processing in UA layer, release lock */\n    pj_mutex_unlock(mod_ua.mutex);\n\n    /* Pass to dialog. */\n    pjsip_dlg_on_rx_request(dlg, rdata);\n\n    /* Unlock the dialog. This may destroy the dialog */\n    pjsip_dlg_dec_lock(dlg);\n\n    /* Report as handled. */\n    return PJ_TRUE;\n}\n\n\n/* On rx response notification.\n */\nstatic pj_bool_t mod_ua_on_rx_response(pjsip_rx_data *rdata)\n{\n    pjsip_transaction *tsx;\n    struct dlg_set *dlg_set;\n    pjsip_dialog *dlg;\n    pj_status_t status;\n\n    /*\n     * Find the dialog instance for the response.\n     * All outgoing dialog requests are sent statefully, which means\n     * there will be an UAC transaction associated with this response,\n     * and the dialog instance will be recorded in that transaction.\n     *\n     * But even when transaction is found, there is possibility that\n     * the response is a forked response.\n     */\n\nretry_on_deadlock:\n\n    dlg = NULL;\n\n    /* Lock user agent dlg table before we're doing anything. */\n    pj_mutex_lock(mod_ua.mutex);\n\n    /* Check if transaction is present. */\n    tsx = pjsip_rdata_get_tsx(rdata);\n    if (tsx) {\n\t/* Check if dialog is present in the transaction. */\n\tdlg = pjsip_tsx_get_dlg(tsx);\n\tif (!dlg) {\n\t    /* Unlock dialog hash table. */\n\t    pj_mutex_unlock(mod_ua.mutex);\n\t    return PJ_FALSE;\n\t}\n\n\t/* Get the dialog set. */\n\tdlg_set = (struct dlg_set*) dlg->dlg_set;\n\n\t/* Even if transaction is found and (candidate) dialog has been \n\t * identified, it's possible that the request has forked.\n\t */\n\n    } else {\n\t/* Transaction is not present.\n\t * Check if this is a 2xx/OK response to INVITE, which in this\n\t * case the response will be handled directly by the\n\t * dialog.\n\t */\n\tpjsip_cseq_hdr *cseq_hdr = rdata->msg_info.cseq;\n\n\tif (cseq_hdr->method.id != PJSIP_INVITE_METHOD ||\n\t    rdata->msg_info.msg->line.status.code / 100 != 2)\n\t{\n\t    /* Not a 2xx response to INVITE.\n\t     * This must be some stateless response sent by other modules,\n\t     * or a very late response.\n\t     */\n\t    /* Unlock dialog hash table. */\n\t    pj_mutex_unlock(mod_ua.mutex);\n\t    return PJ_FALSE;\n\t}\n\n\n\t/* Get the dialog set. */\n\tdlg_set = (struct dlg_set*)\n\t\t  pj_hash_get_lower(mod_ua.dlg_table, \n\t\t\t            rdata->msg_info.from->tag.ptr,\n\t\t\t            (unsigned)rdata->msg_info.from->tag.slen,\n\t\t\t            NULL);\n\n\tif (!dlg_set) {\n\t    /* Unlock dialog hash table. */\n\t    pj_mutex_unlock(mod_ua.mutex);\n\n\t    /* Strayed 2xx response!! */\n\t    PJ_LOG(4,(THIS_FILE, \n\t\t      \"Received strayed 2xx response (no dialog is found)\"\n\t\t      \" from %s:%d: %s\",\n\t\t      rdata->pkt_info.src_name, rdata->pkt_info.src_port,\n\t\t      pjsip_rx_data_get_info(rdata)));\n\n\t    return PJ_TRUE;\n\t}\n    }\n\n    /* At this point, we must have the dialog set, and the dialog set\n     * must have a dialog in the list.\n     */\n    pj_assert(dlg_set && !pj_list_empty(&dlg_set->dlg_list));\n\n    /* Check for forked response. \n     * Request will fork only for the initial INVITE request.\n     */\n\n    //This doesn't work when there is authentication challenge, since \n    //first_cseq evaluation will yield false.\n    //if (rdata->msg_info.cseq->method.id == PJSIP_INVITE_METHOD &&\n    //\trdata->msg_info.cseq->cseq == dlg_set->dlg_list.next->local.first_cseq)\n\n    if (rdata->msg_info.cseq->method.id == PJSIP_INVITE_METHOD) {\n\t\n\tint st_code = rdata->msg_info.msg->line.status.code;\n\tpj_str_t *to_tag = &rdata->msg_info.to->tag;\n\n\tdlg = dlg_set->dlg_list.next;\n\n\twhile (dlg != (pjsip_dialog*)&dlg_set->dlg_list) {\n\n\t    /* If there is dialog with no remote tag (i.e. dialog has not\n\t     * been established yet), then send this response to that\n\t     * dialog.\n\t     */\n\t    if (dlg->remote.info->tag.slen == 0)\n\t\tbreak;\n\n\t    /* Otherwise find the one with matching To tag. */\n\t    if (pj_stricmp(to_tag, &dlg->remote.info->tag) == 0)\n\t\tbreak;\n\n\t    dlg = dlg->next;\n\t}\n\n\t/* If no dialog with matching remote tag is found, this must be\n\t * a forked response. Respond to this ONLY when response is non-100\n\t * provisional response OR a 2xx response.\n\t */\n\tif (dlg == (pjsip_dialog*)&dlg_set->dlg_list &&\n\t    ((st_code/100==1 && st_code!=100) || st_code/100==2)) \n\t{\n\n\t    PJ_LOG(5,(THIS_FILE, \n\t\t      \"Received forked %s for existing dialog %s\",\n\t\t      pjsip_rx_data_get_info(rdata), \n\t\t      dlg_set->dlg_list.next->obj_name));\n\n\t    /* Report to application about forked condition.\n\t     * Application can either create a dialog or ignore the response.\n\t     */\n\t    if (mod_ua.param.on_dlg_forked) {\n\t\tdlg = (*mod_ua.param.on_dlg_forked)(dlg_set->dlg_list.next, \n\t\t\t\t\t\t    rdata);\n\t\tif (dlg == NULL) {\n\t\t    pj_mutex_unlock(mod_ua.mutex);\n\t\t    return PJ_TRUE;\n\t\t}\n\t    } else {\n\t\tdlg = dlg_set->dlg_list.next;\n\n\t\tPJ_LOG(4,(THIS_FILE, \n\t\t\t  \"Unhandled forked %s from %s:%d, response will be \"\n\t\t\t  \"handed over to the first dialog\",\n\t\t\t  pjsip_rx_data_get_info(rdata),\n\t\t\t  rdata->pkt_info.src_name, rdata->pkt_info.src_port));\n\t    }\n\n\t} else if (dlg == (pjsip_dialog*)&dlg_set->dlg_list) {\n\n\t    /* For 100 or non-2xx response which has different To tag,\n\t     * pass the response to the first dialog.\n\t     */\n\n\t    dlg = dlg_set->dlg_list.next;\n\n\t}\n\n    } else {\n\t/* Either this is a non-INVITE response, or subsequent INVITE\n\t * within dialog. The dialog should have been identified when\n\t * the transaction was found.\n\t */\n\tpj_assert(tsx != NULL);\n\tpj_assert(dlg != NULL);\n    }\n\n    /* The dialog must have been found. */\n    pj_assert(dlg != NULL);\n\n    /* Put the dialog instance in the rdata. */\n    rdata->endpt_info.mod_data[mod_ua.mod.id] = dlg;\n\n    /* Attempt to acquire lock to the dialog. */\n    PJ_LOG(6,(dlg->obj_name, \"UA layer acquiring dialog lock for response\"));\n    status = pjsip_dlg_try_inc_lock(dlg);\n    if (status != PJ_SUCCESS) {\n\t/* Failed to acquire dialog mutex. This could indicate a deadlock\n\t * situation, and for safety, try to avoid deadlock by releasing\n\t * UA mutex, yield, and retry the whole processing once again.\n\t */\n\tpj_mutex_unlock(mod_ua.mutex);\n\tpj_thread_sleep(0);\n\tgoto retry_on_deadlock;\n    }\n\n    /* We're done with processing in the UA layer, we can release the mutex */\n    pj_mutex_unlock(mod_ua.mutex);\n\n    /* Pass the response to the dialog. */\n    pjsip_dlg_on_rx_response(dlg, rdata);\n\n    /* Unlock the dialog. This may destroy the dialog. */\n    pjsip_dlg_dec_lock(dlg);\n\n    /* Done. */\n    return PJ_TRUE;\n}\n\n\n#if PJ_LOG_MAX_LEVEL >= 3\nstatic void print_dialog( const char *title,\n\t\t\t  pjsip_dialog *dlg, char *buf, pj_size_t size)\n{\n    int len;\n    char userinfo[PJSIP_MAX_URL_SIZE];\n\n    len = pjsip_hdr_print_on(dlg->remote.info, userinfo, sizeof(userinfo));\n    if (len < 0)\n\tpj_ansi_strcpy(userinfo, \"<--uri too long-->\");\n    else\n\tuserinfo[len] = '\\0';\n    \n    len = pj_ansi_snprintf(buf, size, \"%s[%s]  %s\",\n\t\t\t   title,\n\t\t\t   (dlg->state==PJSIP_DIALOG_STATE_NULL ? \" - \" :\n\t\t\t\t\t\t\t     \"est\"),\n\t\t      userinfo);\n    if (len < 1 || len >= (int)size) {\n\tpj_ansi_strcpy(buf, \"<--uri too long-->\");\n    } else\n\tbuf[len] = '\\0';\n}\n#endif\n\n/*\n * Dump user agent contents (e.g. all dialogs).\n */\nPJ_DEF(void) pjsip_ua_dump(pj_bool_t detail)\n{\n#if PJ_LOG_MAX_LEVEL >= 3\n    pj_hash_iterator_t itbuf, *it;\n    char dlginfo[128];\n\n    pj_mutex_lock(mod_ua.mutex);\n\n    PJ_LOG(3, (THIS_FILE, \"Number of dialog sets: %u\", \n\t\t\t  pj_hash_count(mod_ua.dlg_table)));\n\n    if (detail && pj_hash_count(mod_ua.dlg_table)) {\n\tPJ_LOG(3, (THIS_FILE, \"Dumping dialog sets:\"));\n\tit = pj_hash_first(mod_ua.dlg_table, &itbuf);\n\tfor (; it != NULL; it = pj_hash_next(mod_ua.dlg_table, it))  {\n\t    struct dlg_set *dlg_set;\n\t    pjsip_dialog *dlg;\n\t    const char *title;\n\n\t    dlg_set = (struct dlg_set*) pj_hash_this(mod_ua.dlg_table, it);\n\t    if (!dlg_set || pj_list_empty(&dlg_set->dlg_list)) continue;\n\n\t    /* First dialog in dialog set. */\n\t    dlg = dlg_set->dlg_list.next;\n\t    if (dlg->role == PJSIP_ROLE_UAC)\n\t\ttitle = \"  [out] \";\n\t    else\n\t\ttitle = \"  [in]  \";\n\n\t    print_dialog(title, dlg, dlginfo, sizeof(dlginfo));\n\t    PJ_LOG(3,(THIS_FILE, \"%s\", dlginfo));\n\n\t    /* Next dialog in dialog set (forked) */\n\t    dlg = dlg->next;\n\t    while (dlg != (pjsip_dialog*) &dlg_set->dlg_list) {\n\t\tprint_dialog(\"    [forked] \", dlg, dlginfo, sizeof(dlginfo));\n\t\tdlg = dlg->next;\n\t    }\n\t}\n    }\n\n    pj_mutex_unlock(mod_ua.mutex);\n#endif\n}\n\n"], "fixing_code": ["/* $Id$ */\n/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#include <pjsip/sip_ua_layer.h>\n#include <pjsip/sip_module.h>\n#include <pjsip/sip_dialog.h>\n#include <pjsip/sip_endpoint.h>\n#include <pjsip/sip_errno.h>\n#include <pjsip/sip_transaction.h>\n#include <pj/os.h>\n#include <pj/hash.h>\n#include <pj/assert.h>\n#include <pj/string.h>\n#include <pj/pool.h>\n#include <pj/log.h>\n\n\n#define THIS_FILE    \"sip_ua_layer.c\"\n\n/*\n * Static prototypes.\n */\nstatic pj_status_t mod_ua_load(pjsip_endpoint *endpt);\nstatic pj_status_t mod_ua_unload(void);\nstatic pj_bool_t   mod_ua_on_rx_request(pjsip_rx_data *rdata);\nstatic pj_bool_t   mod_ua_on_rx_response(pjsip_rx_data *rdata);\nstatic void\t   mod_ua_on_tsx_state(pjsip_transaction*, pjsip_event*);\n\n\nextern long pjsip_dlg_lock_tls_id;\t/* defined in sip_dialog.c */\n\n/* This struct is used to represent list of dialog inside a dialog set.\n * We don't want to use pjsip_dialog for this purpose, to save some\n * memory (about 100 bytes per dialog set).\n */\nstruct dlg_set_head\n{\n    PJ_DECL_LIST_MEMBER(pjsip_dialog);\n};\n\n/* This struct represents a dialog set.\n * This is the value that will be put in the UA's hash table.\n */\nstruct dlg_set\n{\n    /* To put this node in free dlg_set nodes in UA. */\n    PJ_DECL_LIST_MEMBER(struct dlg_set);\n\n    /* This is the buffer to store this entry in the hash table. */\n    pj_hash_entry_buf ht_entry;\n\n    /* Entry key in the hash table */\n    pj_str_t ht_key;\n\n    /* List of dialog in this dialog set. */\n    struct dlg_set_head  dlg_list;\n};\n\n\n/*\n * Module interface.\n */\nstatic struct user_agent\n{\n    pjsip_module\t mod;\n    pj_pool_t\t\t*pool;\n    pjsip_endpoint\t*endpt;\n    pj_mutex_t\t\t*mutex;\n    pj_hash_table_t\t*dlg_table;\n    pjsip_ua_init_param  param;\n    struct dlg_set\t free_dlgset_nodes;\n\n} mod_ua = \n{\n  {\n    NULL, NULL,\t\t    /* prev, next.\t\t\t*/\n    { \"mod-ua\", 6 },\t    /* Name.\t\t\t\t*/\n    -1,\t\t\t    /* Id\t\t\t\t*/\n    PJSIP_MOD_PRIORITY_UA_PROXY_LAYER,\t/* Priority\t\t*/\n    &mod_ua_load,\t    /* load()\t\t\t\t*/\n    NULL,\t\t    /* start()\t\t\t\t*/\n    NULL,\t\t    /* stop()\t\t\t\t*/\n    &mod_ua_unload,\t    /* unload()\t\t\t\t*/\n    &mod_ua_on_rx_request,  /* on_rx_request()\t\t\t*/\n    &mod_ua_on_rx_response, /* on_rx_response()\t\t\t*/\n    NULL,\t\t    /* on_tx_request.\t\t\t*/\n    NULL,\t\t    /* on_tx_response()\t\t\t*/\n    &mod_ua_on_tsx_state,   /* on_tsx_state()\t\t\t*/\n  }\n};\n\n/* \n * mod_ua_load()\n *\n * Called when module is being loaded by endpoint.\n */\nstatic pj_status_t mod_ua_load(pjsip_endpoint *endpt)\n{\n    pj_status_t status;\n\n    /* Initialize the user agent. */\n    mod_ua.endpt = endpt;\n    mod_ua.pool = pjsip_endpt_create_pool( endpt, \"ua%p\", PJSIP_POOL_LEN_UA,\n\t\t\t\t\t   PJSIP_POOL_INC_UA);\n    if (mod_ua.pool == NULL)\n\treturn PJ_ENOMEM;\n\n    status = pj_mutex_create_recursive(mod_ua.pool, \" ua%p\", &mod_ua.mutex);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    mod_ua.dlg_table = pj_hash_create(mod_ua.pool, PJSIP_MAX_DIALOG_COUNT);\n    if (mod_ua.dlg_table == NULL)\n\treturn PJ_ENOMEM;\n\n    pj_list_init(&mod_ua.free_dlgset_nodes);\n\n    /* Initialize dialog lock. */\n    status = pj_thread_local_alloc(&pjsip_dlg_lock_tls_id);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    pj_thread_local_set(pjsip_dlg_lock_tls_id, NULL);\n\n    return PJ_SUCCESS;\n\n}\n\n/*\n * mod_ua_unload()\n *\n * Called when module is being unloaded.\n */\nstatic pj_status_t mod_ua_unload(void)\n{\n    pj_thread_local_free(pjsip_dlg_lock_tls_id);\n    pj_mutex_destroy(mod_ua.mutex);\n\n    /* Release pool */\n    if (mod_ua.pool) {\n\tpjsip_endpt_release_pool( mod_ua.endpt, mod_ua.pool );\n    }\n    return PJ_SUCCESS;\n}\n\n/*\n * mod_ua_on_tsx_stats()\n *\n * Called on changed on transaction state.\n */\nstatic void mod_ua_on_tsx_state( pjsip_transaction *tsx, pjsip_event *e)\n{\n    pjsip_dialog *dlg;\n\n    /* If the module id is -1, it could mean that the module has been\n     * destroyed.\n     */\n    if (mod_ua.mod.id == -1)\n\treturn;\n\n    /* Get the dialog where this transaction belongs. */\n    dlg = (pjsip_dialog*) tsx->mod_data[mod_ua.mod.id];\n    \n    /* If dialog instance has gone, it could mean that the dialog\n     * may has been destroyed.\n     */\n    if (dlg == NULL)\n\treturn;\n\n    /* Hand over the event to the dialog. */\n    pjsip_dlg_on_tsx_state(dlg, tsx, e);\n}\n\n\n/*\n * Init user agent module and register it to the endpoint.\n */\nPJ_DEF(pj_status_t) pjsip_ua_init_module( pjsip_endpoint *endpt,\n\t\t\t\t\t  const pjsip_ua_init_param *prm)\n{\n    pj_status_t status;\n\n    /* Check if module already registered. */\n    PJ_ASSERT_RETURN(mod_ua.mod.id == -1, PJ_EINVALIDOP);\n\n    /* Copy param, if exists. */\n    if (prm)\n\tpj_memcpy(&mod_ua.param, prm, sizeof(pjsip_ua_init_param));\n\n    /* Register the module. */\n    status = pjsip_endpt_register_module(endpt, &mod_ua.mod);\n\n    return status;\n}\n\n/*\n * Get the instance of the user agent.\n *\n */\nPJ_DEF(pjsip_user_agent*) pjsip_ua_instance(void)\n{\n    return &mod_ua.mod;\n}\n\n\n/*\n * Get the endpoint where this UA is currently registered.\n */\nPJ_DEF(pjsip_endpoint*) pjsip_ua_get_endpt(pjsip_user_agent *ua)\n{\n    PJ_UNUSED_ARG(ua);\n    pj_assert(ua == &mod_ua.mod);\n    return mod_ua.endpt;\n}\n\n\n/*\n * Destroy the user agent layer.\n */\nPJ_DEF(pj_status_t) pjsip_ua_destroy(void)\n{\n    /* Check if module already destroyed. */\n    PJ_ASSERT_RETURN(mod_ua.mod.id != -1, PJ_EINVALIDOP);\n\n    return pjsip_endpt_unregister_module(mod_ua.endpt, &mod_ua.mod);\n}\n\n\n\n/*\n * Create key to identify dialog set.\n */\n/*\nPJ_DEF(void) pjsip_ua_create_dlg_set_key( pj_pool_t *pool,\n\t\t\t\t\t  pj_str_t *set_key,\n\t\t\t\t\t  const pj_str_t *call_id,\n\t\t\t\t\t  const pj_str_t *local_tag)\n{\n    PJ_ASSERT_ON_FAIL(pool && set_key && call_id && local_tag, return;);\n\n    set_key->slen = call_id->slen + local_tag->slen + 1;\n    set_key->ptr = (char*) pj_pool_alloc(pool, set_key->slen);\n    pj_assert(set_key->ptr != NULL);\n\n    pj_memcpy(set_key->ptr, call_id->ptr, call_id->slen);\n    set_key->ptr[call_id->slen] = '$';\n    pj_memcpy(set_key->ptr + call_id->slen + 1, \n\t      local_tag->ptr, local_tag->slen);\n}\n*/\n\n/*\n * Acquire one dlg_set node to be put in the hash table.\n * This will first look in the free nodes list, then allocate\n * a new one from UA's pool when one is not available.\n */\nstatic struct dlg_set *alloc_dlgset_node(void)\n{\n    struct dlg_set *set;\n\n    if (!pj_list_empty(&mod_ua.free_dlgset_nodes)) {\n\tset = mod_ua.free_dlgset_nodes.next;\n\tpj_list_erase(set);\n\treturn set;\n    } else {\n\tset = PJ_POOL_ALLOC_T(mod_ua.pool, struct dlg_set);\n\treturn set;\n    }\n}\n\n/*\n * Register new dialog. Called by pjsip_dlg_create_uac() and\n * pjsip_dlg_create_uas_and_inc_lock();\n */\nPJ_DEF(pj_status_t) pjsip_ua_register_dlg( pjsip_user_agent *ua,\n\t\t\t\t\t   pjsip_dialog *dlg )\n{\n    /* Sanity check. */\n    PJ_ASSERT_RETURN(ua && dlg, PJ_EINVAL);\n\n    /* For all dialogs, local tag (inc hash) must has been initialized. */\n    PJ_ASSERT_RETURN(dlg->local.info && dlg->local.info->tag.slen &&\n\t\t     dlg->local.tag_hval != 0, PJ_EBUG);\n\n    /* For UAS dialog, remote tag (inc hash) must have been initialized. */\n    //PJ_ASSERT_RETURN(dlg->role==PJSIP_ROLE_UAC ||\n    //\t\t     (dlg->role==PJSIP_ROLE_UAS && dlg->remote.info->tag.slen\n    //\t\t      && dlg->remote.tag_hval != 0), PJ_EBUG);\n\n    /* Lock the user agent. */\n    pj_mutex_lock(mod_ua.mutex);\n\n    /* For UAC, check if there is existing dialog in the same set. */\n    if (dlg->role == PJSIP_ROLE_UAC) {\n\tstruct dlg_set *dlg_set;\n\n\tdlg_set = (struct dlg_set*)\n\t\t  pj_hash_get_lower( mod_ua.dlg_table,\n                                     dlg->local.info->tag.ptr, \n\t\t\t             (unsigned)dlg->local.info->tag.slen,\n\t\t\t             &dlg->local.tag_hval);\n\n\tif (dlg_set) {\n\t    /* This is NOT the first dialog in the dialog set. \n\t     * Just add this dialog in the list.\n\t     */\n\t    pj_assert(dlg_set->dlg_list.next != (void*)&dlg_set->dlg_list);\n\t    pj_list_push_back(&dlg_set->dlg_list, dlg);\n\n\t    dlg->dlg_set = dlg_set;\n\n\t} else {\n\t    /* This is the first dialog in the dialog set. \n\t     * Create the dialog set and add this dialog to it.\n\t     */\n\t    dlg_set = alloc_dlgset_node();\n\t    dlg_set->ht_key = dlg->local.info->tag;\n\t    pj_list_init(&dlg_set->dlg_list);\n\t    pj_list_push_back(&dlg_set->dlg_list, dlg);\n\n\t    dlg->dlg_set = dlg_set;\n\n\t    /* Register the dialog set in the hash table. */\n\t    pj_hash_set_np_lower(mod_ua.dlg_table, \n\t\t\t         dlg_set->ht_key.ptr,\n                                 (unsigned)dlg_set->ht_key.slen,\n\t\t\t         dlg->local.tag_hval, dlg_set->ht_entry,\n                                 dlg_set);\n\t}\n\n    } else {\n\t/* For UAS, create the dialog set with a single dialog as member. */\n\tstruct dlg_set *dlg_set;\n\n\tdlg_set = alloc_dlgset_node();\n\tdlg_set->ht_key = dlg->local.info->tag;\n\tpj_list_init(&dlg_set->dlg_list);\n\tpj_list_push_back(&dlg_set->dlg_list, dlg);\n\n\tdlg->dlg_set = dlg_set;\n\n\tpj_hash_set_np_lower(mod_ua.dlg_table, \n\t\t             dlg_set->ht_key.ptr,\n                             (unsigned)dlg_set->ht_key.slen,\n\t\t             dlg->local.tag_hval, dlg_set->ht_entry, dlg_set);\n    }\n\n    /* Unlock user agent. */\n    pj_mutex_unlock(mod_ua.mutex);\n\n    /* Done. */\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(pj_status_t) pjsip_ua_unregister_dlg( pjsip_user_agent *ua,\n\t\t\t\t\t     pjsip_dialog *dlg )\n{\n    struct dlg_set *dlg_set;\n    pjsip_dialog *d;\n\n    /* Sanity-check arguments. */\n    PJ_ASSERT_RETURN(ua && dlg, PJ_EINVAL);\n\n    /* Check that dialog has been registered. */\n    PJ_ASSERT_RETURN(dlg->dlg_set, PJ_EINVALIDOP);\n\n    /* Lock user agent. */\n    pj_mutex_lock(mod_ua.mutex);\n\n    /* Find this dialog from the dialog set. */\n    dlg_set = (struct dlg_set*) dlg->dlg_set;\n    d = dlg_set->dlg_list.next;\n    while (d != (pjsip_dialog*)&dlg_set->dlg_list && d != dlg) {\n\td = d->next;\n    }\n\n    if (d != dlg) {\n\tpj_assert(!\"Dialog is not registered!\");\n\tpj_mutex_unlock(mod_ua.mutex);\n\treturn PJ_EINVALIDOP;\n    }\n\n    /* Remove this dialog from the list. */\n    pj_list_erase(dlg);\n\n    /* If dialog list is empty, remove the dialog set from the hash table. */\n    if (pj_list_empty(&dlg_set->dlg_list)) {\n\n\t/* Verify that the dialog set is valid */\n\tpj_assert(pj_hash_get_lower(mod_ua.dlg_table, dlg_set->ht_key.ptr,\n\t\t\t\t    (unsigned)dlg_set->ht_key.slen,\n\t\t\t\t    &dlg->local.tag_hval) == dlg_set);\n\n\tpj_hash_set_lower(NULL, mod_ua.dlg_table, dlg_set->ht_key.ptr,\n\t\t          (unsigned)dlg_set->ht_key.slen,\n\t\t\t  dlg->local.tag_hval, NULL);\n\n\t/* Return dlg_set to free nodes. */\n\tpj_list_push_back(&mod_ua.free_dlgset_nodes, dlg_set);\n    } else {\n\t/* If the just unregistered dialog is being used as hash key,\n\t * reset the dlg_set entry with a new key (i.e: from the first dialog\n\t * in dlg_set).\n\t */\n\tif (dlg_set->ht_key.ptr  == dlg->local.info->tag.ptr &&\n\t    dlg_set->ht_key.slen == dlg->local.info->tag.slen)\n\t{\n\t    pjsip_dialog* key_dlg = dlg_set->dlg_list.next;\n\n\t    /* Verify that the old & new keys share the hash value */\n\t    pj_assert(key_dlg->local.tag_hval == dlg->local.tag_hval);\n\n\t    pj_hash_set_lower(NULL, mod_ua.dlg_table, dlg_set->ht_key.ptr,\n\t\t\t      (unsigned)dlg_set->ht_key.slen,\n\t\t\t      dlg->local.tag_hval, NULL);\n\n\t    dlg_set->ht_key = key_dlg->local.info->tag;\n\n\t    pj_hash_set_np_lower(mod_ua.dlg_table,\n\t\t\t\t dlg_set->ht_key.ptr,\n\t\t\t\t (unsigned)dlg_set->ht_key.slen,\n\t\t\t\t key_dlg->local.tag_hval, dlg_set->ht_entry,\n\t\t\t\t dlg_set);\n\t}\n    }\n\n    /* Unlock user agent. */\n    pj_mutex_unlock(mod_ua.mutex);\n\n    /* Done. */\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(pjsip_dialog*) pjsip_rdata_get_dlg( pjsip_rx_data *rdata )\n{\n    return (pjsip_dialog*) rdata->endpt_info.mod_data[mod_ua.mod.id];\n}\n\nPJ_DEF(pjsip_dialog*) pjsip_tdata_get_dlg( pjsip_tx_data *tdata )\n{\n    return (pjsip_dialog*) tdata->mod_data[mod_ua.mod.id];\n}\n\nPJ_DEF(pjsip_dialog*) pjsip_tsx_get_dlg( pjsip_transaction *tsx )\n{\n    return (pjsip_dialog*) tsx->mod_data[mod_ua.mod.id];\n}\n\n\n/*\n * Retrieve the current number of dialog-set currently registered\n * in the hash table. \n */\nPJ_DEF(unsigned) pjsip_ua_get_dlg_set_count(void)\n{\n    unsigned count;\n\n    PJ_ASSERT_RETURN(mod_ua.endpt, 0);\n\n    pj_mutex_lock(mod_ua.mutex);\n    count = pj_hash_count(mod_ua.dlg_table);\n    pj_mutex_unlock(mod_ua.mutex);\n\n    return count;\n}\n\n\n/* \n * Find a dialog.\n */\nPJ_DEF(pjsip_dialog*) pjsip_ua_find_dialog(const pj_str_t *call_id,\n\t\t\t\t\t   const pj_str_t *local_tag,\n\t\t\t\t\t   const pj_str_t *remote_tag,\n\t\t\t\t\t   pj_bool_t lock_dialog)\n{\n    struct dlg_set *dlg_set;\n    pjsip_dialog *dlg;\n\n    PJ_ASSERT_RETURN(call_id && local_tag && remote_tag, NULL);\n\n    /* Lock user agent. */\n    pj_mutex_lock(mod_ua.mutex);\n\n    /* Lookup the dialog set. */\n    dlg_set = (struct dlg_set*)\n    \t      pj_hash_get_lower(mod_ua.dlg_table, local_tag->ptr,\n                                (unsigned)local_tag->slen, NULL);\n    if (dlg_set == NULL) {\n\t/* Not found */\n\tpj_mutex_unlock(mod_ua.mutex);\n\treturn NULL;\n    }\n\n    /* Dialog set is found, now find the matching dialog based on the\n     * remote tag.\n     */\n    dlg = dlg_set->dlg_list.next;\n    while (dlg != (pjsip_dialog*)&dlg_set->dlg_list) {\t\n\tif (pj_stricmp(&dlg->remote.info->tag, remote_tag) == 0)\n\t    break;\n\tdlg = dlg->next;\n    }\n\n    if (dlg == (pjsip_dialog*)&dlg_set->dlg_list) {\n\t/* Not found */\n\tpj_mutex_unlock(mod_ua.mutex);\n\treturn NULL;\n    }\n\n    /* Dialog has been found. It SHOULD have the right Call-ID!! */\n    if (pj_strcmp(&dlg->call_id->id, call_id)!=0) {\n\n\tPJ_LOG(6, (THIS_FILE, \"Dialog not found: local and remote tags \"\n\t\t              \"matched but not call id\"));\n\n        pj_mutex_unlock(mod_ua.mutex);\n        return NULL;\n    }\n\n    if (lock_dialog) {\n\tif (pjsip_dlg_try_inc_lock(dlg) != PJ_SUCCESS) {\n\n\t    /*\n\t     * Unable to acquire dialog's lock while holding the user\n\t     * agent's mutex. Release the UA mutex before retrying once\n\t     * more.\n\t     *\n\t     * THIS MAY CAUSE RACE CONDITION!\n\t     */\n\n\t    /* Unlock user agent. */\n\t    pj_mutex_unlock(mod_ua.mutex);\n\t    /* Lock dialog */\n\t    pjsip_dlg_inc_lock(dlg);\n\n\t} else {\n\t    /* Unlock user agent. */\n\t    pj_mutex_unlock(mod_ua.mutex);\n\t}\n\n    } else {\n\t/* Unlock user agent. */\n\tpj_mutex_unlock(mod_ua.mutex);\n    }\n\n    return dlg;\n}\n\n\n/*\n * Find the first dialog in dialog set in hash table for an incoming message.\n */\nstatic struct dlg_set *find_dlg_set_for_msg( pjsip_rx_data *rdata )\n{\n    /* CANCEL message doesn't have To tag, so we must lookup the dialog\n     * by finding the INVITE UAS transaction being cancelled.\n     */\n    if (rdata->msg_info.cseq->method.id == PJSIP_CANCEL_METHOD) {\n\n\tpjsip_dialog *dlg;\n\n\t/* Create key for the rdata, but this time, use INVITE as the\n\t * method.\n\t */\n\tpj_str_t key;\n\tpjsip_role_e role;\n\tpjsip_transaction *tsx;\n\n\tif (rdata->msg_info.msg->type == PJSIP_REQUEST_MSG)\n\t    role = PJSIP_ROLE_UAS;\n\telse\n\t    role = PJSIP_ROLE_UAC;\n\n\tpjsip_tsx_create_key(rdata->tp_info.pool, &key, role, \n\t\t\t     pjsip_get_invite_method(), rdata);\n\n\t/* Lookup the INVITE transaction */\n\ttsx = pjsip_tsx_layer_find_tsx2(&key, PJ_TRUE);\n\n\t/* We should find the dialog attached to the INVITE transaction */\n\tif (tsx) {\n\t    dlg = (pjsip_dialog*) tsx->mod_data[mod_ua.mod.id];\n\t    pj_grp_lock_dec_ref(tsx->grp_lock);\n\n\t    /* Dlg may be NULL on some extreme condition\n\t     * (e.g. during debugging where initially there is a dialog)\n\t     */\n\t    return dlg ? (struct dlg_set*) dlg->dlg_set : NULL;\n\n\t} else {\n\t    return NULL;\n\t}\n\n\n    } else {\n\tpj_str_t *tag;\n\tstruct dlg_set *dlg_set;\n\n\tif (rdata->msg_info.msg->type == PJSIP_REQUEST_MSG)\n\t    tag = &rdata->msg_info.to->tag;\n\telse\n\t    tag = &rdata->msg_info.from->tag;\n\n\t/* Lookup the dialog set. */\n\tdlg_set = (struct dlg_set*)\n\t\t  pj_hash_get_lower(mod_ua.dlg_table, tag->ptr, \n\t\t\t\t    (unsigned)tag->slen, NULL);\n\treturn dlg_set;\n    }\n}\n\n/* On received requests. */\nstatic pj_bool_t mod_ua_on_rx_request(pjsip_rx_data *rdata)\n{\n    struct dlg_set *dlg_set;\n    pj_str_t *from_tag;\n    pjsip_dialog *dlg;\n    pj_status_t status;\n\n    /* Optimized path: bail out early if request is not CANCEL and it doesn't\n     * have To tag \n     */\n    if (rdata->msg_info.to->tag.slen == 0 && \n\trdata->msg_info.msg->line.req.method.id != PJSIP_CANCEL_METHOD)\n    {\n\treturn PJ_FALSE;\n    }\n\n    /* Incoming REGISTER may have tags in it */\n    if (rdata->msg_info.msg->line.req.method.id == PJSIP_REGISTER_METHOD)\n\treturn PJ_FALSE;\n\nretry_on_deadlock:\n\n    /* Lock user agent before looking up the dialog hash table. */\n    pj_mutex_lock(mod_ua.mutex);\n\n    /* Lookup the dialog set, based on the To tag header. */\n    dlg_set = find_dlg_set_for_msg(rdata);\n\n    /* If dialog is not found, respond with 481 (Call/Transaction\n     * Does Not Exist).\n     */\n    if (dlg_set == NULL) {\n\t/* Unable to find dialog. */\n\tpj_mutex_unlock(mod_ua.mutex);\n\n\tif (rdata->msg_info.msg->line.req.method.id != PJSIP_ACK_METHOD) {\n\t    PJ_LOG(5,(THIS_FILE, \n\t\t      \"Unable to find dialogset for %s, answering with 481\",\n\t\t      pjsip_rx_data_get_info(rdata)));\n\n\t    /* Respond with 481 . */\n\t    pjsip_endpt_respond_stateless( mod_ua.endpt, rdata, 481, NULL, \n\t\t\t\t\t   NULL, NULL );\n\t}\n\treturn PJ_TRUE;\n    }\n\n    /* Dialog set has been found.\n     * Find the dialog in the dialog set based on the content of the remote \n     * tag.\n     */\n    from_tag = &rdata->msg_info.from->tag;\n    dlg = dlg_set->dlg_list.next;\n    while (dlg != (pjsip_dialog*)&dlg_set->dlg_list) {\n\t\n\tif (pj_stricmp(&dlg->remote.info->tag, from_tag) == 0)\n\t    break;\n\n\tdlg = dlg->next;\n    }\n\n    /* Dialog may not be found, e.g. in this case:\n     *\t- UAC sends SUBSCRIBE, then UAS sends NOTIFY before answering\n     *    SUBSCRIBE request with 2xx.\n     *\n     * In this case, we can accept the request ONLY when the original \n     * dialog still has empty To tag.\n     */\n    if (dlg == (pjsip_dialog*)&dlg_set->dlg_list) {\n\n\tpjsip_dialog *first_dlg = dlg_set->dlg_list.next;\n\n\tif (first_dlg->remote.info->tag.slen != 0) {\n\t    /* Not found. Mulfunction UAC? */\n\t    pj_mutex_unlock(mod_ua.mutex);\n\n\t    if (rdata->msg_info.msg->line.req.method.id != PJSIP_ACK_METHOD) {\n\t\tPJ_LOG(5,(THIS_FILE, \n\t\t          \"Unable to find dialog for %s, answering with 481\",\n\t\t          pjsip_rx_data_get_info(rdata)));\n\n\t\tpjsip_endpt_respond_stateless(mod_ua.endpt, rdata,\n\t\t\t\t\t      PJSIP_SC_CALL_TSX_DOES_NOT_EXIST, \n\t\t\t\t\t      NULL, NULL, NULL);\n\t    } else {\n\t\tPJ_LOG(5,(THIS_FILE, \n\t\t          \"Unable to find dialog for %s\",\n\t\t          pjsip_rx_data_get_info(rdata)));\n\t    }\n\t    return PJ_TRUE;\n\t}\n\n\tdlg = first_dlg;\n    }\n\n    /* Mark the dialog id of the request. */\n    rdata->endpt_info.mod_data[mod_ua.mod.id] = dlg;\n\n    /* Try to lock the dialog */\n    PJ_LOG(6,(dlg->obj_name, \"UA layer acquiring dialog lock for request\"));\n    status = pjsip_dlg_try_inc_lock(dlg);\n    if (status != PJ_SUCCESS) {\n\t/* Failed to acquire dialog mutex immediately, this could be \n\t * because of deadlock. Release UA mutex, yield, and retry \n\t * the whole thing once again.\n\t */\n\tpj_mutex_unlock(mod_ua.mutex);\n\tpj_thread_sleep(0);\n\tgoto retry_on_deadlock;\n    }\n\n    /* Done with processing in UA layer, release lock */\n    pj_mutex_unlock(mod_ua.mutex);\n\n    /* Pass to dialog. */\n    pjsip_dlg_on_rx_request(dlg, rdata);\n\n    /* Unlock the dialog. This may destroy the dialog */\n    pjsip_dlg_dec_lock(dlg);\n\n    /* Report as handled. */\n    return PJ_TRUE;\n}\n\n\n/* On rx response notification.\n */\nstatic pj_bool_t mod_ua_on_rx_response(pjsip_rx_data *rdata)\n{\n    pjsip_transaction *tsx;\n    struct dlg_set *dlg_set;\n    pjsip_dialog *dlg;\n    pj_status_t status;\n\n    /*\n     * Find the dialog instance for the response.\n     * All outgoing dialog requests are sent statefully, which means\n     * there will be an UAC transaction associated with this response,\n     * and the dialog instance will be recorded in that transaction.\n     *\n     * But even when transaction is found, there is possibility that\n     * the response is a forked response.\n     */\n\nretry_on_deadlock:\n\n    dlg = NULL;\n\n    /* Lock user agent dlg table before we're doing anything. */\n    pj_mutex_lock(mod_ua.mutex);\n\n    /* Check if transaction is present. */\n    tsx = pjsip_rdata_get_tsx(rdata);\n    if (tsx) {\n\t/* Check if dialog is present in the transaction. */\n\tdlg = pjsip_tsx_get_dlg(tsx);\n\tif (!dlg) {\n\t    /* Unlock dialog hash table. */\n\t    pj_mutex_unlock(mod_ua.mutex);\n\t    return PJ_FALSE;\n\t}\n\n\t/* Get the dialog set. */\n\tdlg_set = (struct dlg_set*) dlg->dlg_set;\n\n\t/* Even if transaction is found and (candidate) dialog has been \n\t * identified, it's possible that the request has forked.\n\t */\n\n    } else {\n\t/* Transaction is not present.\n\t * Check if this is a 2xx/OK response to INVITE, which in this\n\t * case the response will be handled directly by the\n\t * dialog.\n\t */\n\tpjsip_cseq_hdr *cseq_hdr = rdata->msg_info.cseq;\n\n\tif (cseq_hdr->method.id != PJSIP_INVITE_METHOD ||\n\t    rdata->msg_info.msg->line.status.code / 100 != 2)\n\t{\n\t    /* Not a 2xx response to INVITE.\n\t     * This must be some stateless response sent by other modules,\n\t     * or a very late response.\n\t     */\n\t    /* Unlock dialog hash table. */\n\t    pj_mutex_unlock(mod_ua.mutex);\n\t    return PJ_FALSE;\n\t}\n\n\n\t/* Get the dialog set. */\n\tdlg_set = (struct dlg_set*)\n\t\t  pj_hash_get_lower(mod_ua.dlg_table, \n\t\t\t            rdata->msg_info.from->tag.ptr,\n\t\t\t            (unsigned)rdata->msg_info.from->tag.slen,\n\t\t\t            NULL);\n\n\tif (!dlg_set) {\n\t    /* Unlock dialog hash table. */\n\t    pj_mutex_unlock(mod_ua.mutex);\n\n\t    /* Strayed 2xx response!! */\n\t    PJ_LOG(4,(THIS_FILE, \n\t\t      \"Received strayed 2xx response (no dialog is found)\"\n\t\t      \" from %s:%d: %s\",\n\t\t      rdata->pkt_info.src_name, rdata->pkt_info.src_port,\n\t\t      pjsip_rx_data_get_info(rdata)));\n\n\t    return PJ_TRUE;\n\t}\n    }\n\n    /* At this point, we must have the dialog set, and the dialog set\n     * must have a dialog in the list.\n     */\n    pj_assert(dlg_set && !pj_list_empty(&dlg_set->dlg_list));\n\n    /* Check for forked response. \n     * Request will fork only for the initial INVITE request.\n     */\n\n    //This doesn't work when there is authentication challenge, since \n    //first_cseq evaluation will yield false.\n    //if (rdata->msg_info.cseq->method.id == PJSIP_INVITE_METHOD &&\n    //\trdata->msg_info.cseq->cseq == dlg_set->dlg_list.next->local.first_cseq)\n\n    if (rdata->msg_info.cseq->method.id == PJSIP_INVITE_METHOD) {\n\t\n\tint st_code = rdata->msg_info.msg->line.status.code;\n\tpj_str_t *to_tag = &rdata->msg_info.to->tag;\n\n\tdlg = dlg_set->dlg_list.next;\n\n\twhile (dlg != (pjsip_dialog*)&dlg_set->dlg_list) {\n\n\t    /* If there is dialog with no remote tag (i.e. dialog has not\n\t     * been established yet), then send this response to that\n\t     * dialog.\n\t     */\n\t    if (dlg->remote.info->tag.slen == 0)\n\t\tbreak;\n\n\t    /* Otherwise find the one with matching To tag. */\n\t    if (pj_stricmp(to_tag, &dlg->remote.info->tag) == 0)\n\t\tbreak;\n\n\t    dlg = dlg->next;\n\t}\n\n\t/* If no dialog with matching remote tag is found, this must be\n\t * a forked response. Respond to this ONLY when response is non-100\n\t * provisional response OR a 2xx response.\n\t */\n\tif (dlg == (pjsip_dialog*)&dlg_set->dlg_list &&\n\t    ((st_code/100==1 && st_code!=100) || st_code/100==2)) \n\t{\n\n\t    PJ_LOG(5,(THIS_FILE, \n\t\t      \"Received forked %s for existing dialog %s\",\n\t\t      pjsip_rx_data_get_info(rdata), \n\t\t      dlg_set->dlg_list.next->obj_name));\n\n\t    /* Report to application about forked condition.\n\t     * Application can either create a dialog or ignore the response.\n\t     */\n\t    if (mod_ua.param.on_dlg_forked) {\n\t\tdlg = (*mod_ua.param.on_dlg_forked)(dlg_set->dlg_list.next, \n\t\t\t\t\t\t    rdata);\n\t\tif (dlg == NULL) {\n\t\t    pj_mutex_unlock(mod_ua.mutex);\n\t\t    return PJ_TRUE;\n\t\t}\n\t    } else {\n\t\tdlg = dlg_set->dlg_list.next;\n\n\t\tPJ_LOG(4,(THIS_FILE, \n\t\t\t  \"Unhandled forked %s from %s:%d, response will be \"\n\t\t\t  \"handed over to the first dialog\",\n\t\t\t  pjsip_rx_data_get_info(rdata),\n\t\t\t  rdata->pkt_info.src_name, rdata->pkt_info.src_port));\n\t    }\n\n\t} else if (dlg == (pjsip_dialog*)&dlg_set->dlg_list) {\n\n\t    /* For 100 or non-2xx response which has different To tag,\n\t     * pass the response to the first dialog.\n\t     */\n\n\t    dlg = dlg_set->dlg_list.next;\n\n\t}\n\n    } else {\n\t/* Either this is a non-INVITE response, or subsequent INVITE\n\t * within dialog. The dialog should have been identified when\n\t * the transaction was found.\n\t */\n\tpj_assert(tsx != NULL);\n\tpj_assert(dlg != NULL);\n    }\n\n    /* The dialog must have been found. */\n    pj_assert(dlg != NULL);\n\n    /* Put the dialog instance in the rdata. */\n    rdata->endpt_info.mod_data[mod_ua.mod.id] = dlg;\n\n    /* Attempt to acquire lock to the dialog. */\n    PJ_LOG(6,(dlg->obj_name, \"UA layer acquiring dialog lock for response\"));\n    status = pjsip_dlg_try_inc_lock(dlg);\n    if (status != PJ_SUCCESS) {\n\t/* Failed to acquire dialog mutex. This could indicate a deadlock\n\t * situation, and for safety, try to avoid deadlock by releasing\n\t * UA mutex, yield, and retry the whole processing once again.\n\t */\n\tpj_mutex_unlock(mod_ua.mutex);\n\tpj_thread_sleep(0);\n\tgoto retry_on_deadlock;\n    }\n\n    /* We're done with processing in the UA layer, we can release the mutex */\n    pj_mutex_unlock(mod_ua.mutex);\n\n    /* Pass the response to the dialog. */\n    pjsip_dlg_on_rx_response(dlg, rdata);\n\n    /* Unlock the dialog. This may destroy the dialog. */\n    pjsip_dlg_dec_lock(dlg);\n\n    /* Done. */\n    return PJ_TRUE;\n}\n\n\n#if PJ_LOG_MAX_LEVEL >= 3\nstatic void print_dialog( const char *title,\n\t\t\t  pjsip_dialog *dlg, char *buf, pj_size_t size)\n{\n    int len;\n    char userinfo[PJSIP_MAX_URL_SIZE];\n\n    len = pjsip_hdr_print_on(dlg->remote.info, userinfo, sizeof(userinfo));\n    if (len < 0)\n\tpj_ansi_strcpy(userinfo, \"<--uri too long-->\");\n    else\n\tuserinfo[len] = '\\0';\n    \n    len = pj_ansi_snprintf(buf, size, \"%s[%s]  %s\",\n\t\t\t   title,\n\t\t\t   (dlg->state==PJSIP_DIALOG_STATE_NULL ? \" - \" :\n\t\t\t\t\t\t\t     \"est\"),\n\t\t      userinfo);\n    if (len < 1 || len >= (int)size) {\n\tpj_ansi_strcpy(buf, \"<--uri too long-->\");\n    } else\n\tbuf[len] = '\\0';\n}\n#endif\n\n/*\n * Dump user agent contents (e.g. all dialogs).\n */\nPJ_DEF(void) pjsip_ua_dump(pj_bool_t detail)\n{\n#if PJ_LOG_MAX_LEVEL >= 3\n    pj_hash_iterator_t itbuf, *it;\n    char dlginfo[128];\n\n    pj_mutex_lock(mod_ua.mutex);\n\n    PJ_LOG(3, (THIS_FILE, \"Number of dialog sets: %u\", \n\t\t\t  pj_hash_count(mod_ua.dlg_table)));\n\n    if (detail && pj_hash_count(mod_ua.dlg_table)) {\n\tPJ_LOG(3, (THIS_FILE, \"Dumping dialog sets:\"));\n\tit = pj_hash_first(mod_ua.dlg_table, &itbuf);\n\tfor (; it != NULL; it = pj_hash_next(mod_ua.dlg_table, it))  {\n\t    struct dlg_set *dlg_set;\n\t    pjsip_dialog *dlg;\n\t    const char *title;\n\n\t    dlg_set = (struct dlg_set*) pj_hash_this(mod_ua.dlg_table, it);\n\t    if (!dlg_set || pj_list_empty(&dlg_set->dlg_list)) continue;\n\n\t    /* First dialog in dialog set. */\n\t    dlg = dlg_set->dlg_list.next;\n\t    if (dlg->role == PJSIP_ROLE_UAC)\n\t\ttitle = \"  [out] \";\n\t    else\n\t\ttitle = \"  [in]  \";\n\n\t    print_dialog(title, dlg, dlginfo, sizeof(dlginfo));\n\t    PJ_LOG(3,(THIS_FILE, \"%s\", dlginfo));\n\n\t    /* Next dialog in dialog set (forked) */\n\t    dlg = dlg->next;\n\t    while (dlg != (pjsip_dialog*) &dlg_set->dlg_list) {\n\t\tprint_dialog(\"    [forked] \", dlg, dlginfo, sizeof(dlginfo));\n\t\tdlg = dlg->next;\n\t    }\n\t}\n    }\n\n    pj_mutex_unlock(mod_ua.mutex);\n#endif\n}\n\n"], "filenames": ["pjsip/src/pjsip/sip_ua_layer.c"], "buggy_code_start_loc": [67], "buggy_code_end_loc": [405], "fixing_code_start_loc": [68], "fixing_code_end_loc": [442], "type": "CWE-416", "message": "PJSIP is a free and open source multimedia communication library written in C language implementing standard based protocols such as SIP, SDP, RTP, STUN, TURN, and ICE. In versions up to and including 2.11.1 when in a dialog set (or forking) scenario, a hash key shared by multiple UAC dialogs can potentially be prematurely freed when one of the dialogs is destroyed . The issue may cause a dialog set to be registered in the hash table multiple times (with different hash keys) leading to undefined behavior such as dialog list collision which eventually leading to endless loop. A patch is available in commit db3235953baa56d2fb0e276ca510fefca751643f which will be included in the next release. There are no known workarounds for this issue.", "other": {"cve": {"id": "CVE-2022-23608", "sourceIdentifier": "security-advisories@github.com", "published": "2022-02-22T20:15:07.693", "lastModified": "2023-02-02T18:30:18.493", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "PJSIP is a free and open source multimedia communication library written in C language implementing standard based protocols such as SIP, SDP, RTP, STUN, TURN, and ICE. In versions up to and including 2.11.1 when in a dialog set (or forking) scenario, a hash key shared by multiple UAC dialogs can potentially be prematurely freed when one of the dialogs is destroyed . The issue may cause a dialog set to be registered in the hash table multiple times (with different hash keys) leading to undefined behavior such as dialog list collision which eventually leading to endless loop. A patch is available in commit db3235953baa56d2fb0e276ca510fefca751643f which will be included in the next release. There are no known workarounds for this issue."}, {"lang": "es", "value": "PJSIP es una biblioteca de comunicaci\u00f3n multimedia gratuita y de c\u00f3digo abierto escrita en lenguaje C que implementa protocolos basados en est\u00e1ndares como SIP, SDP, RTP, STUN, TURN e ICE. En las versiones hasta la versi\u00f3n 2.11.1 inclusive, cuando se encuentra en un escenario de conjunto de di\u00e1logos (o bifurcaci\u00f3n), una clave hash compartida por varios di\u00e1logos de UAC puede potencialmente liberarse prematuramente cuando se destruye uno de los di\u00e1logos. El problema puede hacer que un conjunto de di\u00e1logos se registre en la tabla hash varias veces (con diferentes claves hash), lo que lleva a un comportamiento indefinido, como la colisi\u00f3n de la lista de di\u00e1logos, lo que eventualmente conduce a un bucle sin fin. Hay un parche disponible en la confirmaci\u00f3n db3235953baa56d2fb0e276ca510fefca751643f que se incluir\u00e1 en la pr\u00f3xima versi\u00f3n. No hay soluciones alternativas conocidas para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:teluu:pjsip:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.11.1", "matchCriteriaId": "6BB0273A-3235-4BC7-A1BE-7D35BABD8617"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:asterisk:certified_asterisk:*:*:*:*:*:*:*:*", "versionEndExcluding": "16.8.0", "matchCriteriaId": "02200524-98C1-49E2-8DFE-7BE82E1181E2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:asterisk:certified_asterisk:16.8.0:cert1:*:*:*:*:*:*", "matchCriteriaId": "E64BCD44-2298-4710-9CC3-DF82E6A8DF94"}, {"vulnerable": true, "criteria": "cpe:2.3:a:asterisk:certified_asterisk:16.8.0:cert10:*:*:*:*:*:*", "matchCriteriaId": "91CCAB0C-C0F8-4619-AAE1-F6F13FF31570"}, {"vulnerable": true, "criteria": "cpe:2.3:a:asterisk:certified_asterisk:16.8.0:cert11:*:*:*:*:*:*", "matchCriteriaId": "F2B7CBB3-E037-416B-AD16-9A553D6A4775"}, {"vulnerable": true, "criteria": "cpe:2.3:a:asterisk:certified_asterisk:16.8.0:cert12:*:*:*:*:*:*", "matchCriteriaId": "DE7DDFE1-6A06-477A-AB45-D00053CFA7EC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:asterisk:certified_asterisk:16.8.0:cert2:*:*:*:*:*:*", "matchCriteriaId": "A35C117A-6EFB-42EB-AD2A-EA7866606927"}, {"vulnerable": true, "criteria": "cpe:2.3:a:asterisk:certified_asterisk:16.8.0:cert3:*:*:*:*:*:*", "matchCriteriaId": "40003CBE-792F-4875-9E60-6F1CE0BBAA8E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:asterisk:certified_asterisk:16.8.0:cert4:*:*:*:*:*:*", "matchCriteriaId": "46A7AA7B-13F2-496A-99ED-1CC13234E8CB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:asterisk:certified_asterisk:16.8.0:cert5:*:*:*:*:*:*", "matchCriteriaId": "147663CB-B48D-4D89-96BF-F92FF96F347F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:asterisk:certified_asterisk:16.8.0:cert6:*:*:*:*:*:*", "matchCriteriaId": "27DBBC83-930A-4ECE-8C1E-47481D881B0D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:asterisk:certified_asterisk:16.8.0:cert7:*:*:*:*:*:*", "matchCriteriaId": "B987A13D-A363-4DCE-BBA1-E35E81ACBA60"}, {"vulnerable": true, "criteria": "cpe:2.3:a:asterisk:certified_asterisk:16.8.0:cert8:*:*:*:*:*:*", "matchCriteriaId": "01A5B7F9-FAD2-4C0C-937D-CF1086512130"}, {"vulnerable": true, "criteria": "cpe:2.3:a:asterisk:certified_asterisk:16.8.0:cert9:*:*:*:*:*:*", "matchCriteriaId": "F60B4271-F987-4932-86EE-45ED099661E1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:asterisk:*:*:*:*:*:*:*:*", "versionStartIncluding": "16.0.0", "versionEndExcluding": "16.24.1", "matchCriteriaId": "DE99C3B4-20EC-4AC8-9A0A-C690E2DBED99"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:asterisk:*:*:*:*:*:*:*:*", "versionStartIncluding": "18.0.0", "versionEndExcluding": "18.10.1", "matchCriteriaId": "C109B569-DE0D-4AE4-A128-239077CCC05F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:asterisk:*:*:*:*:*:*:*:*", "versionStartIncluding": "19.0.0", "versionEndExcluding": "19.2.1", "matchCriteriaId": "44E4E3A7-8CB3-491C-98F6-F78345533E3B"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "http://packetstormsecurity.com/files/166226/Asterisk-Project-Security-Advisory-AST-2022-005.html", "source": "security-advisories@github.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://seclists.org/fulldisclosure/2022/Mar/1", "source": "security-advisories@github.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/pjsip/pjproject/commit/db3235953baa56d2fb0e276ca510fefca751643f", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/pjsip/pjproject/security/advisories/GHSA-ffff-m5fm-qm62", "source": "security-advisories@github.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/03/msg00035.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/03/msg00040.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/11/msg00021.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202210-37", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5285", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/pjsip/pjproject/commit/db3235953baa56d2fb0e276ca510fefca751643f"}}