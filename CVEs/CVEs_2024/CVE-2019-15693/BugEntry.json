{"buggy_code": ["/* Copyright (C) 2000-2003 Constantin Kaplinsky.  All Rights Reserved.\n * Copyright 2004-2005 Cendio AB.\n * Copyright 2009-2015 Pierre Ossman for Cendio AB\n * Copyright (C) 2011 D. R. Commander.  All Rights Reserved.\n *    \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n//\n// Tight decoding functions.\n//\n// This file is #included after having set the following macro:\n// BPP                - 8, 16 or 32\n\nnamespace rfb {\n\n// CONCAT2E concatenates its arguments, expanding them if they are macros\n\n#ifndef CONCAT2E\n#define CONCAT2(a,b) a##b\n#define CONCAT2E(a,b) CONCAT2(a,b)\n#endif\n\n#define PIXEL_T rdr::CONCAT2E(U,BPP)\n\n#if BPP == 32\n\nvoid\nTightDecoder::FilterGradient24(const rdr::U8 *inbuf,\n                               const PixelFormat& pf, PIXEL_T* outbuf,\n                               int stride, const Rect& r)\n{\n  int x, y, c;\n  rdr::U8 prevRow[TIGHT_MAX_WIDTH*3];\n  rdr::U8 thisRow[TIGHT_MAX_WIDTH*3];\n  rdr::U8 pix[3]; \n  int est[3]; \n\n  memset(prevRow, 0, sizeof(prevRow));\n\n  // Set up shortcut variables\n  int rectHeight = r.height();\n  int rectWidth = r.width();\n\n  for (y = 0; y < rectHeight; y++) {\n    /* First pixel in a row */\n    for (c = 0; c < 3; c++) {\n      pix[c] = inbuf[y*rectWidth*3+c] + prevRow[c];\n      thisRow[c] = pix[c];\n    }\n    pf.bufferFromRGB((rdr::U8*)&outbuf[y*stride], pix, 1);\n\n    /* Remaining pixels of a row */\n    for (x = 1; x < rectWidth; x++) {\n      for (c = 0; c < 3; c++) {\n        est[c] = prevRow[x*3+c] + pix[c] - prevRow[(x-1)*3+c];\n        if (est[c] > 0xff) {\n          est[c] = 0xff;\n        } else if (est[c] < 0) {\n          est[c] = 0;\n        }\n        pix[c] = inbuf[(y*rectWidth+x)*3+c] + est[c];\n        thisRow[x*3+c] = pix[c];\n      }\n      pf.bufferFromRGB((rdr::U8*)&outbuf[y*stride+x], pix, 1);\n    }\n\n    memcpy(prevRow, thisRow, sizeof(prevRow));\n  }\n}\n\n#endif\n\n#if BPP != 8\n\nvoid TightDecoder::FilterGradient(const rdr::U8* inbuf,\n                                  const PixelFormat& pf, PIXEL_T* outbuf,\n                                  int stride, const Rect& r)\n{\n  int x, y, c;\n  static rdr::U8 prevRow[TIGHT_MAX_WIDTH*3];\n  static rdr::U8 thisRow[TIGHT_MAX_WIDTH*3];\n  rdr::U8 pix[3]; \n  int est[3]; \n\n  memset(prevRow, 0, sizeof(prevRow));\n\n  // Set up shortcut variables\n  int rectHeight = r.height();\n  int rectWidth = r.width();\n\n  for (y = 0; y < rectHeight; y++) {\n    /* First pixel in a row */\n    pf.rgbFromBuffer(pix, &inbuf[y*rectWidth], 1);\n    for (c = 0; c < 3; c++)\n      pix[c] += prevRow[c];\n\n    memcpy(thisRow, pix, sizeof(pix));\n\n    pf.bufferFromRGB((rdr::U8*)&outbuf[y*stride], pix, 1);\n\n    /* Remaining pixels of a row */\n    for (x = 1; x < rectWidth; x++) {\n      for (c = 0; c < 3; c++) {\n        est[c] = prevRow[x*3+c] + pix[c] - prevRow[(x-1)*3+c];\n        if (est[c] > 255) {\n          est[c] = 255;\n        } else if (est[c] < 0) {\n          est[c] = 0;\n        }\n      }\n\n      pf.rgbFromBuffer(pix, &inbuf[y*rectWidth+x], 1);\n      for (c = 0; c < 3; c++)\n        pix[c] += est[c];\n\n      memcpy(&thisRow[x*3], pix, sizeof(pix));\n\n      pf.bufferFromRGB((rdr::U8*)&outbuf[y*stride+x], pix, 1);\n    }\n\n    memcpy(prevRow, thisRow, sizeof(prevRow));\n  }\n}\n\n#endif\n\nvoid TightDecoder::FilterPalette(const PIXEL_T* palette, int palSize,\n                                 const rdr::U8* inbuf, PIXEL_T* outbuf,\n                                 int stride, const Rect& r)\n{\n  // Indexed color\n  int x, h = r.height(), w = r.width(), b, pad = stride - w;\n  PIXEL_T* ptr = outbuf;\n  rdr::U8 bits;\n  const rdr::U8* srcPtr = inbuf;\n  if (palSize <= 2) {\n    // 2-color palette\n    while (h > 0) {\n      for (x = 0; x < w / 8; x++) {\n        bits = *srcPtr++;\n        for (b = 7; b >= 0; b--) {\n          *ptr++ = palette[bits >> b & 1];\n        }\n      }\n      if (w % 8 != 0) {\n        bits = *srcPtr++;\n        for (b = 7; b >= 8 - w % 8; b--) {\n          *ptr++ = palette[bits >> b & 1];\n        }\n      }\n      ptr += pad;\n      h--;\n    }\n  } else {\n    // 256-color palette\n    while (h > 0) {\n      PIXEL_T *endOfRow = ptr + w;\n      while (ptr < endOfRow) {\n        *ptr++ = palette[*srcPtr++];\n      }\n      ptr += pad;\n      h--;\n    }\n  }\n}\n\n#undef PIXEL_T\n}\n"], "fixing_code": ["/* Copyright (C) 2000-2003 Constantin Kaplinsky.  All Rights Reserved.\n * Copyright 2004-2005 Cendio AB.\n * Copyright 2009-2015 Pierre Ossman for Cendio AB\n * Copyright (C) 2011 D. R. Commander.  All Rights Reserved.\n *    \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n//\n// Tight decoding functions.\n//\n// This file is #included after having set the following macro:\n// BPP                - 8, 16 or 32\n\nnamespace rfb {\n\n// CONCAT2E concatenates its arguments, expanding them if they are macros\n\n#ifndef CONCAT2E\n#define CONCAT2(a,b) a##b\n#define CONCAT2E(a,b) CONCAT2(a,b)\n#endif\n\n#define PIXEL_T rdr::CONCAT2E(U,BPP)\n\n#if BPP == 32\n\nvoid\nTightDecoder::FilterGradient24(const rdr::U8 *inbuf,\n                               const PixelFormat& pf, PIXEL_T* outbuf,\n                               int stride, const Rect& r)\n{\n  int x, y, c;\n  rdr::U8 prevRow[TIGHT_MAX_WIDTH*3];\n  rdr::U8 thisRow[TIGHT_MAX_WIDTH*3];\n  rdr::U8 pix[3]; \n  int est[3]; \n\n  memset(prevRow, 0, sizeof(prevRow));\n\n  // Set up shortcut variables\n  int rectHeight = r.height();\n  int rectWidth = r.width();\n\n  for (y = 0; y < rectHeight; y++) {\n    for (x = 0; x < rectWidth; x++) {\n      /* First pixel in a row */\n      if (x == 0) {\n        for (c = 0; c < 3; c++) {\n          pix[c] = inbuf[y*rectWidth*3+c] + prevRow[c];\n          thisRow[c] = pix[c];\n        }\n        pf.bufferFromRGB((rdr::U8*)&outbuf[y*stride], pix, 1);\n        continue;\n      }\n\n      for (c = 0; c < 3; c++) {\n        est[c] = prevRow[x*3+c] + pix[c] - prevRow[(x-1)*3+c];\n        if (est[c] > 0xff) {\n          est[c] = 0xff;\n        } else if (est[c] < 0) {\n          est[c] = 0;\n        }\n        pix[c] = inbuf[(y*rectWidth+x)*3+c] + est[c];\n        thisRow[x*3+c] = pix[c];\n      }\n      pf.bufferFromRGB((rdr::U8*)&outbuf[y*stride+x], pix, 1);\n    }\n\n    memcpy(prevRow, thisRow, sizeof(prevRow));\n  }\n}\n\n#endif\n\n#if BPP != 8\n\nvoid TightDecoder::FilterGradient(const rdr::U8* inbuf,\n                                  const PixelFormat& pf, PIXEL_T* outbuf,\n                                  int stride, const Rect& r)\n{\n  int x, y, c;\n  static rdr::U8 prevRow[TIGHT_MAX_WIDTH*3];\n  static rdr::U8 thisRow[TIGHT_MAX_WIDTH*3];\n  rdr::U8 pix[3]; \n  int est[3]; \n\n  memset(prevRow, 0, sizeof(prevRow));\n\n  // Set up shortcut variables\n  int rectHeight = r.height();\n  int rectWidth = r.width();\n\n  for (y = 0; y < rectHeight; y++) {\n    for (x = 0; x < rectWidth; x++) {\n      /* First pixel in a row */\n      if (x == 0) {\n        pf.rgbFromBuffer(pix, &inbuf[y*rectWidth], 1);\n        for (c = 0; c < 3; c++)\n          pix[c] += prevRow[c];\n\n        memcpy(thisRow, pix, sizeof(pix));\n\n        pf.bufferFromRGB((rdr::U8*)&outbuf[y*stride], pix, 1);\n\n        continue;\n      }\n\n      for (c = 0; c < 3; c++) {\n        est[c] = prevRow[x*3+c] + pix[c] - prevRow[(x-1)*3+c];\n        if (est[c] > 255) {\n          est[c] = 255;\n        } else if (est[c] < 0) {\n          est[c] = 0;\n        }\n      }\n\n      pf.rgbFromBuffer(pix, &inbuf[y*rectWidth+x], 1);\n      for (c = 0; c < 3; c++)\n        pix[c] += est[c];\n\n      memcpy(&thisRow[x*3], pix, sizeof(pix));\n\n      pf.bufferFromRGB((rdr::U8*)&outbuf[y*stride+x], pix, 1);\n    }\n\n    memcpy(prevRow, thisRow, sizeof(prevRow));\n  }\n}\n\n#endif\n\nvoid TightDecoder::FilterPalette(const PIXEL_T* palette, int palSize,\n                                 const rdr::U8* inbuf, PIXEL_T* outbuf,\n                                 int stride, const Rect& r)\n{\n  // Indexed color\n  int x, h = r.height(), w = r.width(), b, pad = stride - w;\n  PIXEL_T* ptr = outbuf;\n  rdr::U8 bits;\n  const rdr::U8* srcPtr = inbuf;\n  if (palSize <= 2) {\n    // 2-color palette\n    while (h > 0) {\n      for (x = 0; x < w / 8; x++) {\n        bits = *srcPtr++;\n        for (b = 7; b >= 0; b--) {\n          *ptr++ = palette[bits >> b & 1];\n        }\n      }\n      if (w % 8 != 0) {\n        bits = *srcPtr++;\n        for (b = 7; b >= 8 - w % 8; b--) {\n          *ptr++ = palette[bits >> b & 1];\n        }\n      }\n      ptr += pad;\n      h--;\n    }\n  } else {\n    // 256-color palette\n    while (h > 0) {\n      PIXEL_T *endOfRow = ptr + w;\n      while (ptr < endOfRow) {\n        *ptr++ = palette[*srcPtr++];\n      }\n      ptr += pad;\n      h--;\n    }\n  }\n}\n\n#undef PIXEL_T\n}\n"], "filenames": ["common/rfb/tightDecode.h"], "buggy_code_start_loc": [59], "buggy_code_end_loc": [117], "fixing_code_start_loc": [59], "fixing_code_end_loc": [122], "type": "CWE-787", "message": "TigerVNC version prior to 1.10.1 is vulnerable to heap buffer overflow, which occurs in TightDecoder::FilterGradient. Exploitation of this vulnerability could potentially result into remote code execution. This attack appear to be exploitable via network connectivity.", "other": {"cve": {"id": "CVE-2019-15693", "sourceIdentifier": "vulnerability@kaspersky.com", "published": "2019-12-26T15:15:11.257", "lastModified": "2023-01-20T15:40:07.637", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "TigerVNC version prior to 1.10.1 is vulnerable to heap buffer overflow, which occurs in TightDecoder::FilterGradient. Exploitation of this vulnerability could potentially result into remote code execution. This attack appear to be exploitable via network connectivity."}, {"lang": "es", "value": "TigerVNC versiones anteriores a 1.10.1, es vulnerable al desbordamiento de b\u00fafer de la pila, que se presenta en la funci\u00f3n TightDecoder::FilterGradient. La explotaci\u00f3n de esta vulnerabilidad podr\u00eda resultar potencialmente en una ejecuci\u00f3n de c\u00f3digo remota. Este ataque parece ser explotable a trav\u00e9s de la conectividad de red."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.2, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}, {"source": "vulnerability@kaspersky.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-122"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:tigervnc:tigervnc:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.10.1", "matchCriteriaId": "5DB31840-DC35-40A5-8126-FF5FDD81EAD7"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-01/msg00039.html", "source": "vulnerability@kaspersky.com", "tags": ["Broken Link"]}, {"url": "https://github.com/CendioOssman/tigervnc/commit/b4ada8d0c6dac98c8b91fc64d112569a8ae5fb95", "source": "vulnerability@kaspersky.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/TigerVNC/tigervnc/releases/tag/v1.10.1", "source": "vulnerability@kaspersky.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://www.openwall.com/lists/oss-security/2019/12/20/2", "source": "vulnerability@kaspersky.com", "tags": ["Exploit", "Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/CendioOssman/tigervnc/commit/b4ada8d0c6dac98c8b91fc64d112569a8ae5fb95"}}