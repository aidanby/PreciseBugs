{"buggy_code": ["/*\nCopyright 2015, 2016 OpenMarket Ltd\nCopyright 2017, 2018 New Vector Ltd\nCopyright 2019 Michael Telatynski <7t3chguy@gmail.com>\nCopyright 2019 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport React, { LegacyRef, ReactElement, ReactNode } from \"react\";\nimport sanitizeHtml from \"sanitize-html\";\nimport cheerio from \"cheerio\";\nimport classNames from \"classnames\";\nimport EMOJIBASE_REGEX from \"emojibase-regex\";\nimport { merge, split } from \"lodash\";\nimport katex from \"katex\";\nimport { decode } from \"html-entities\";\nimport { IContent } from \"matrix-js-sdk/src/models/event\";\nimport { Optional } from \"matrix-events-sdk\";\nimport _Linkify from \"linkify-react\";\n\nimport {\n    _linkifyElement,\n    _linkifyString,\n    ELEMENT_URL_PATTERN,\n    options as linkifyMatrixOptions,\n} from \"./linkify-matrix\";\nimport { IExtendedSanitizeOptions } from \"./@types/sanitize-html\";\nimport SettingsStore from \"./settings/SettingsStore\";\nimport { tryTransformPermalinkToLocalHref } from \"./utils/permalinks/Permalinks\";\nimport { getEmojiFromUnicode } from \"./emoji\";\nimport { mediaFromMxc } from \"./customisations/Media\";\nimport { stripHTMLReply, stripPlainReply } from \"./utils/Reply\";\n\n// Anything outside the basic multilingual plane will be a surrogate pair\nconst SURROGATE_PAIR_PATTERN = /([\\ud800-\\udbff])([\\udc00-\\udfff])/;\n// And there a bunch more symbol characters that emojibase has within the\n// BMP, so this includes the ranges from 'letterlike symbols' to\n// 'miscellaneous symbols and arrows' which should catch all of them\n// (with plenty of false positives, but that's OK)\nconst SYMBOL_PATTERN = /([\\u2100-\\u2bff])/;\n\n// Regex pattern for non-emoji characters that can appear in an \"all-emoji\" message (Zero-Width Joiner, Zero-Width Space, other whitespace)\nconst EMOJI_SEPARATOR_REGEX = /[\\u200D\\u200B\\s]/g;\n\nconst BIGEMOJI_REGEX = new RegExp(`^(${EMOJIBASE_REGEX.source})+$`, \"i\");\n\nconst COLOR_REGEX = /^#[0-9a-fA-F]{6}$/;\n\nexport const PERMITTED_URL_SCHEMES = [\n    \"bitcoin\",\n    \"ftp\",\n    \"geo\",\n    \"http\",\n    \"https\",\n    \"im\",\n    \"irc\",\n    \"ircs\",\n    \"magnet\",\n    \"mailto\",\n    \"matrix\",\n    \"mms\",\n    \"news\",\n    \"nntp\",\n    \"openpgp4fpr\",\n    \"sip\",\n    \"sftp\",\n    \"sms\",\n    \"smsto\",\n    \"ssh\",\n    \"tel\",\n    \"urn\",\n    \"webcal\",\n    \"wtai\",\n    \"xmpp\",\n];\n\nconst MEDIA_API_MXC_REGEX = /\\/_matrix\\/media\\/r0\\/(?:download|thumbnail)\\/(.+?)\\/(.+?)(?:[?/]|$)/;\n\n/*\n * Return true if the given string contains emoji\n * Uses a much, much simpler regex than emojibase's so will give false\n * positives, but useful for fast-path testing strings to see if they\n * need emojification.\n */\nfunction mightContainEmoji(str?: string): boolean {\n    return !!str && (SURROGATE_PAIR_PATTERN.test(str) || SYMBOL_PATTERN.test(str));\n}\n\n/**\n * Returns the shortcode for an emoji character.\n *\n * @param {String} char The emoji character\n * @return {String} The shortcode (such as :thumbup:)\n */\nexport function unicodeToShortcode(char: string): string {\n    const shortcodes = getEmojiFromUnicode(char)?.shortcodes;\n    return shortcodes?.length ? `:${shortcodes[0]}:` : \"\";\n}\n\n/*\n * Given an untrusted HTML string, return a React node with an sanitized version\n * of that HTML.\n */\nexport function sanitizedHtmlNode(insaneHtml: string): ReactNode {\n    const saneHtml = sanitizeHtml(insaneHtml, sanitizeHtmlParams);\n\n    return <div dangerouslySetInnerHTML={{ __html: saneHtml }} dir=\"auto\" />;\n}\n\nexport function getHtmlText(insaneHtml: string): string {\n    return sanitizeHtml(insaneHtml, {\n        allowedTags: [],\n        allowedAttributes: {},\n        selfClosing: [],\n        allowedSchemes: [],\n        disallowedTagsMode: \"discard\",\n    });\n}\n\n/**\n * Tests if a URL from an untrusted source may be safely put into the DOM\n * The biggest threat here is javascript: URIs.\n * Note that the HTML sanitiser library has its own internal logic for\n * doing this, to which we pass the same list of schemes. This is used in\n * other places we need to sanitise URLs.\n * @return true if permitted, otherwise false\n */\nexport function isUrlPermitted(inputUrl: string): boolean {\n    try {\n        // URL parser protocol includes the trailing colon\n        return PERMITTED_URL_SCHEMES.includes(new URL(inputUrl).protocol.slice(0, -1));\n    } catch (e) {\n        return false;\n    }\n}\n\nconst transformTags: IExtendedSanitizeOptions[\"transformTags\"] = {\n    // custom to matrix\n    // add blank targets to all hyperlinks except vector URLs\n    \"a\": function (tagName: string, attribs: sanitizeHtml.Attributes) {\n        if (attribs.href) {\n            attribs.target = \"_blank\"; // by default\n\n            const transformed = tryTransformPermalinkToLocalHref(attribs.href); // only used to check if it is a link that can be handled locally\n            if (\n                transformed !== attribs.href || // it could be converted so handle locally symbols e.g. @user:server.tdl, matrix: and matrix.to\n                attribs.href.match(ELEMENT_URL_PATTERN) // for https links to Element domains\n            ) {\n                delete attribs.target;\n            }\n        } else {\n            // Delete the href attrib if it is falsy\n            delete attribs.href;\n        }\n\n        attribs.rel = \"noreferrer noopener\"; // https://mathiasbynens.github.io/rel-noopener/\n        return { tagName, attribs };\n    },\n    \"img\": function (tagName: string, attribs: sanitizeHtml.Attributes) {\n        let src = attribs.src;\n        // Strip out imgs that aren't `mxc` here instead of using allowedSchemesByTag\n        // because transformTags is used _before_ we filter by allowedSchemesByTag and\n        // we don't want to allow images with `https?` `src`s.\n        // We also drop inline images (as if they were not present at all) when the \"show\n        // images\" preference is disabled. Future work might expose some UI to reveal them\n        // like standalone image events have.\n        if (!src || !SettingsStore.getValue(\"showImages\")) {\n            return { tagName, attribs: {} };\n        }\n\n        if (!src.startsWith(\"mxc://\")) {\n            const match = MEDIA_API_MXC_REGEX.exec(src);\n            if (match) {\n                src = `mxc://${match[1]}/${match[2]}`;\n            }\n        }\n\n        if (!src.startsWith(\"mxc://\")) {\n            return { tagName, attribs: {} };\n        }\n\n        const requestedWidth = Number(attribs.width);\n        const requestedHeight = Number(attribs.height);\n        const width = Math.min(requestedWidth || 800, 800);\n        const height = Math.min(requestedHeight || 600, 600);\n        // specify width/height as max values instead of absolute ones to allow object-fit to do its thing\n        // we only allow our own styles for this tag so overwrite the attribute\n        attribs.style = `max-width: ${width}px; max-height: ${height}px;`;\n        if (requestedWidth) {\n            attribs.style += \"width: 100%;\";\n        }\n        if (requestedHeight) {\n            attribs.style += \"height: 100%;\";\n        }\n\n        attribs.src = mediaFromMxc(src).getThumbnailOfSourceHttp(width, height)!;\n        return { tagName, attribs };\n    },\n    \"code\": function (tagName: string, attribs: sanitizeHtml.Attributes) {\n        if (typeof attribs.class !== \"undefined\") {\n            // Filter out all classes other than ones starting with language- for syntax highlighting.\n            const classes = attribs.class.split(/\\s/).filter(function (cl) {\n                return cl.startsWith(\"language-\") && !cl.startsWith(\"language-_\");\n            });\n            attribs.class = classes.join(\" \");\n        }\n        return { tagName, attribs };\n    },\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    \"*\": function (tagName: string, attribs: sanitizeHtml.Attributes) {\n        // Delete any style previously assigned, style is an allowedTag for font, span & img,\n        // because attributes are stripped after transforming.\n        // For img this is trusted as it is generated wholly within the img transformation method.\n        if (tagName !== \"img\") {\n            delete attribs.style;\n        }\n\n        // Sanitise and transform data-mx-color and data-mx-bg-color to their CSS\n        // equivalents\n        const customCSSMapper: Record<string, string> = {\n            \"data-mx-color\": \"color\",\n            \"data-mx-bg-color\": \"background-color\",\n            // $customAttributeKey: $cssAttributeKey\n        };\n\n        let style = \"\";\n        Object.keys(customCSSMapper).forEach((customAttributeKey) => {\n            const cssAttributeKey = customCSSMapper[customAttributeKey];\n            const customAttributeValue = attribs[customAttributeKey];\n            if (\n                customAttributeValue &&\n                typeof customAttributeValue === \"string\" &&\n                COLOR_REGEX.test(customAttributeValue)\n            ) {\n                style += cssAttributeKey + \":\" + customAttributeValue + \";\";\n                delete attribs[customAttributeKey];\n            }\n        });\n\n        if (style) {\n            attribs.style = style + (attribs.style || \"\");\n        }\n\n        return { tagName, attribs };\n    },\n};\n\nconst sanitizeHtmlParams: IExtendedSanitizeOptions = {\n    allowedTags: [\n        \"font\", // custom to matrix for IRC-style font coloring\n        \"del\", // for markdown\n        \"h1\",\n        \"h2\",\n        \"h3\",\n        \"h4\",\n        \"h5\",\n        \"h6\",\n        \"blockquote\",\n        \"p\",\n        \"a\",\n        \"ul\",\n        \"ol\",\n        \"sup\",\n        \"sub\",\n        \"nl\",\n        \"li\",\n        \"b\",\n        \"i\",\n        \"u\",\n        \"strong\",\n        \"em\",\n        \"strike\",\n        \"code\",\n        \"hr\",\n        \"br\",\n        \"div\",\n        \"table\",\n        \"thead\",\n        \"caption\",\n        \"tbody\",\n        \"tr\",\n        \"th\",\n        \"td\",\n        \"pre\",\n        \"span\",\n        \"img\",\n        \"details\",\n        \"summary\",\n    ],\n    allowedAttributes: {\n        // attribute sanitization happens after transformations, so we have to accept `style` for font, span & img\n        // but strip during the transformation.\n        // custom ones first:\n        font: [\"color\", \"data-mx-bg-color\", \"data-mx-color\", \"style\"], // custom to matrix\n        span: [\"data-mx-maths\", \"data-mx-bg-color\", \"data-mx-color\", \"data-mx-spoiler\", \"style\"], // custom to matrix\n        div: [\"data-mx-maths\"],\n        a: [\"href\", \"name\", \"target\", \"rel\"], // remote target: custom to matrix\n        // img tags also accept width/height, we just map those to max-width & max-height during transformation\n        img: [\"src\", \"alt\", \"title\", \"style\"],\n        ol: [\"start\"],\n        code: [\"class\"], // We don't actually allow all classes, we filter them in transformTags\n    },\n    // Lots of these won't come up by default because we don't allow them\n    selfClosing: [\"img\", \"br\", \"hr\", \"area\", \"base\", \"basefont\", \"input\", \"link\", \"meta\"],\n    // URL schemes we permit\n    allowedSchemes: PERMITTED_URL_SCHEMES,\n    allowProtocolRelative: false,\n    transformTags,\n    // 50 levels deep \"should be enough for anyone\"\n    nestingLimit: 50,\n};\n\n// this is the same as the above except with less rewriting\nconst composerSanitizeHtmlParams: IExtendedSanitizeOptions = {\n    ...sanitizeHtmlParams,\n    transformTags: {\n        \"code\": transformTags[\"code\"],\n        \"*\": transformTags[\"*\"],\n    },\n};\n\n// reduced set of allowed tags to avoid turning topics into Myspace\nconst topicSanitizeHtmlParams: IExtendedSanitizeOptions = {\n    ...sanitizeHtmlParams,\n    allowedTags: [\n        \"font\", // custom to matrix for IRC-style font coloring\n        \"del\", // for markdown\n        \"a\",\n        \"sup\",\n        \"sub\",\n        \"b\",\n        \"i\",\n        \"u\",\n        \"strong\",\n        \"em\",\n        \"strike\",\n        \"br\",\n        \"div\",\n        \"span\",\n    ],\n};\n\nabstract class BaseHighlighter<T extends React.ReactNode> {\n    public constructor(public highlightClass: string, public highlightLink?: string) {}\n\n    /**\n     * apply the highlights to a section of text\n     *\n     * @param {string} safeSnippet The snippet of text to apply the highlights\n     *     to.\n     * @param {string[]} safeHighlights A list of substrings to highlight,\n     *     sorted by descending length.\n     *\n     * returns a list of results (strings for HtmlHighligher, react nodes for\n     * TextHighlighter).\n     */\n    public applyHighlights(safeSnippet: string, safeHighlights: string[]): T[] {\n        let lastOffset = 0;\n        let offset;\n        let nodes: T[] = [];\n\n        const safeHighlight = safeHighlights[0];\n        while ((offset = safeSnippet.toLowerCase().indexOf(safeHighlight.toLowerCase(), lastOffset)) >= 0) {\n            // handle preamble\n            if (offset > lastOffset) {\n                const subSnippet = safeSnippet.substring(lastOffset, offset);\n                nodes = nodes.concat(this.applySubHighlights(subSnippet, safeHighlights));\n            }\n\n            // do highlight. use the original string rather than safeHighlight\n            // to preserve the original casing.\n            const endOffset = offset + safeHighlight.length;\n            nodes.push(this.processSnippet(safeSnippet.substring(offset, endOffset), true));\n\n            lastOffset = endOffset;\n        }\n\n        // handle postamble\n        if (lastOffset !== safeSnippet.length) {\n            const subSnippet = safeSnippet.substring(lastOffset, undefined);\n            nodes = nodes.concat(this.applySubHighlights(subSnippet, safeHighlights));\n        }\n        return nodes;\n    }\n\n    private applySubHighlights(safeSnippet: string, safeHighlights: string[]): T[] {\n        if (safeHighlights[1]) {\n            // recurse into this range to check for the next set of highlight matches\n            return this.applyHighlights(safeSnippet, safeHighlights.slice(1));\n        } else {\n            // no more highlights to be found, just return the unhighlighted string\n            return [this.processSnippet(safeSnippet, false)];\n        }\n    }\n\n    protected abstract processSnippet(snippet: string, highlight: boolean): T;\n}\n\nclass HtmlHighlighter extends BaseHighlighter<string> {\n    /* highlight the given snippet if required\n     *\n     * snippet: content of the span; must have been sanitised\n     * highlight: true to highlight as a search match\n     *\n     * returns an HTML string\n     */\n    protected processSnippet(snippet: string, highlight: boolean): string {\n        if (!highlight) {\n            // nothing required here\n            return snippet;\n        }\n\n        let span = `<span class=\"${this.highlightClass}\">${snippet}</span>`;\n\n        if (this.highlightLink) {\n            span = `<a href=\"${encodeURI(this.highlightLink)}\">${span}</a>`;\n        }\n        return span;\n    }\n}\n\ninterface IOpts {\n    highlightLink?: string;\n    disableBigEmoji?: boolean;\n    stripReplyFallback?: boolean;\n    returnString?: boolean;\n    forComposerQuote?: boolean;\n    ref?: React.Ref<HTMLSpanElement>;\n}\n\nexport interface IOptsReturnNode extends IOpts {\n    returnString: false | undefined;\n}\n\nexport interface IOptsReturnString extends IOpts {\n    returnString: true;\n}\n\nconst emojiToHtmlSpan = (emoji: string): string =>\n    `<span class='mx_Emoji' title='${unicodeToShortcode(emoji)}'>${emoji}</span>`;\nconst emojiToJsxSpan = (emoji: string, key: number): JSX.Element => (\n    <span key={key} className=\"mx_Emoji\" title={unicodeToShortcode(emoji)}>\n        {emoji}\n    </span>\n);\n\n/**\n * Wraps emojis in <span> to style them separately from the rest of message. Consecutive emojis (and modifiers) are wrapped\n * in the same <span>.\n * @param {string} message the text to format\n * @param {boolean} isHtmlMessage whether the message contains HTML\n * @returns if isHtmlMessage is true, returns an array of strings, otherwise return an array of React Elements for emojis\n * and plain text for everything else\n */\nfunction formatEmojis(message: string | undefined, isHtmlMessage: boolean): (JSX.Element | string)[] {\n    const emojiToSpan = isHtmlMessage ? emojiToHtmlSpan : emojiToJsxSpan;\n    const result: (JSX.Element | string)[] = [];\n    let text = \"\";\n    let key = 0;\n\n    // We use lodash's grapheme splitter to avoid breaking apart compound emojis\n    for (const char of split(message, \"\")) {\n        if (EMOJIBASE_REGEX.test(char)) {\n            if (text) {\n                result.push(text);\n                text = \"\";\n            }\n            result.push(emojiToSpan(char, key));\n            key++;\n        } else {\n            text += char;\n        }\n    }\n    if (text) {\n        result.push(text);\n    }\n    return result;\n}\n\n/* turn a matrix event body into html\n *\n * content: 'content' of the MatrixEvent\n *\n * highlights: optional list of words to highlight, ordered by longest word first\n *\n * opts.highlightLink: optional href to add to highlighted words\n * opts.disableBigEmoji: optional argument to disable the big emoji class.\n * opts.stripReplyFallback: optional argument specifying the event is a reply and so fallback needs removing\n * opts.returnString: return an HTML string rather than JSX elements\n * opts.forComposerQuote: optional param to lessen the url rewriting done by sanitization, for quoting into composer\n * opts.ref: React ref to attach to any React components returned (not compatible with opts.returnString)\n */\nexport function bodyToHtml(content: IContent, highlights: Optional<string[]>, opts: IOptsReturnString): string;\nexport function bodyToHtml(content: IContent, highlights: Optional<string[]>, opts: IOptsReturnNode): ReactNode;\nexport function bodyToHtml(content: IContent, highlights: Optional<string[]>, opts: IOpts = {}): ReactNode | string {\n    const isFormattedBody = content.format === \"org.matrix.custom.html\" && typeof content.formatted_body === \"string\";\n    let bodyHasEmoji = false;\n    let isHtmlMessage = false;\n\n    let sanitizeParams = sanitizeHtmlParams;\n    if (opts.forComposerQuote) {\n        sanitizeParams = composerSanitizeHtmlParams;\n    }\n\n    let strippedBody: string;\n    let safeBody: string | undefined; // safe, sanitised HTML, preferred over `strippedBody` which is fully plaintext\n\n    try {\n        // sanitizeHtml can hang if an unclosed HTML tag is thrown at it\n        // A search for `<foo` will make the browser crash an alternative would be to escape HTML special characters\n        // but that would bring no additional benefit as the highlighter does not work with those special chars\n        const safeHighlights = highlights\n            ?.filter((highlight: string): boolean => !highlight.includes(\"<\"))\n            .map((highlight: string): string => sanitizeHtml(highlight, sanitizeParams));\n\n        let formattedBody = typeof content.formatted_body === \"string\" ? content.formatted_body : null;\n        const plainBody = typeof content.body === \"string\" ? content.body : \"\";\n\n        if (opts.stripReplyFallback && formattedBody) formattedBody = stripHTMLReply(formattedBody);\n        strippedBody = opts.stripReplyFallback ? stripPlainReply(plainBody) : plainBody;\n        bodyHasEmoji = mightContainEmoji(isFormattedBody ? formattedBody! : plainBody);\n\n        const highlighter = safeHighlights?.length\n            ? new HtmlHighlighter(\"mx_EventTile_searchHighlight\", opts.highlightLink)\n            : null;\n\n        if (isFormattedBody) {\n            if (highlighter) {\n                // XXX: We sanitize the HTML whilst also highlighting its text nodes, to avoid accidentally trying\n                // to highlight HTML tags themselves. However, this does mean that we don't highlight textnodes which\n                // are interrupted by HTML tags (not that we did before) - e.g. foo<span/>bar won't get highlighted\n                // by an attempt to search for 'foobar'.  Then again, the search query probably wouldn't work either\n                // XXX: hacky bodge to temporarily apply a textFilter to the sanitizeParams structure.\n                sanitizeParams.textFilter = function (safeText) {\n                    return highlighter.applyHighlights(safeText, safeHighlights!).join(\"\");\n                };\n            }\n\n            safeBody = sanitizeHtml(formattedBody!, sanitizeParams);\n            const phtml = cheerio.load(safeBody, {\n                // @ts-ignore: The `_useHtmlParser2` internal option is the\n                // simplest way to both parse and render using `htmlparser2`.\n                _useHtmlParser2: true,\n                decodeEntities: false,\n            });\n            const isPlainText = phtml.html() === phtml.root().text();\n            isHtmlMessage = !isPlainText;\n\n            if (isHtmlMessage && SettingsStore.getValue(\"feature_latex_maths\")) {\n                // @ts-ignore - The types for `replaceWith` wrongly expect\n                // Cheerio instance to be returned.\n                phtml('div, span[data-mx-maths!=\"\"]').replaceWith(function (i, e) {\n                    return katex.renderToString(decode(phtml(e).attr(\"data-mx-maths\")), {\n                        throwOnError: false,\n                        // @ts-ignore - `e` can be an Element, not just a Node\n                        displayMode: e.name == \"div\",\n                        output: \"htmlAndMathml\",\n                    });\n                });\n                safeBody = phtml.html();\n            }\n            if (bodyHasEmoji) {\n                safeBody = formatEmojis(safeBody, true).join(\"\");\n            }\n        } else if (highlighter) {\n            safeBody = highlighter.applyHighlights(plainBody, safeHighlights!).join(\"\");\n        }\n    } finally {\n        delete sanitizeParams.textFilter;\n    }\n\n    const contentBody = safeBody ?? strippedBody;\n    if (opts.returnString) {\n        return contentBody;\n    }\n\n    let emojiBody = false;\n    if (!opts.disableBigEmoji && bodyHasEmoji) {\n        let contentBodyTrimmed = contentBody !== undefined ? contentBody.trim() : \"\";\n\n        // Remove zero width joiner, zero width spaces and other spaces in body\n        // text. This ensures that emojis with spaces in between or that are made\n        // up of multiple unicode characters are still counted as purely emoji\n        // messages.\n        contentBodyTrimmed = contentBodyTrimmed.replace(EMOJI_SEPARATOR_REGEX, \"\");\n\n        const match = BIGEMOJI_REGEX.exec(contentBodyTrimmed);\n        emojiBody =\n            match?.[0]?.length === contentBodyTrimmed.length &&\n            // Prevent user pills expanding for users with only emoji in\n            // their username. Permalinks (links in pills) can be any URL\n            // now, so we just check for an HTTP-looking thing.\n            (strippedBody === safeBody || // replies have the html fallbacks, account for that here\n                content.formatted_body === undefined ||\n                (!content.formatted_body.includes(\"http:\") && !content.formatted_body.includes(\"https:\")));\n    }\n\n    const className = classNames({\n        \"mx_EventTile_body\": true,\n        \"mx_EventTile_bigEmoji\": emojiBody,\n        \"markdown-body\": isHtmlMessage && !emojiBody,\n    });\n\n    let emojiBodyElements: JSX.Element[] | undefined;\n    if (!safeBody && bodyHasEmoji) {\n        emojiBodyElements = formatEmojis(strippedBody, false) as JSX.Element[];\n    }\n\n    return safeBody ? (\n        <span\n            key=\"body\"\n            ref={opts.ref}\n            className={className}\n            dangerouslySetInnerHTML={{ __html: safeBody }}\n            dir=\"auto\"\n        />\n    ) : (\n        <span key=\"body\" ref={opts.ref} className={className} dir=\"auto\">\n            {emojiBodyElements || strippedBody}\n        </span>\n    );\n}\n\n/**\n * Turn a room topic into html\n * @param topic plain text topic\n * @param htmlTopic optional html topic\n * @param ref React ref to attach to any React components returned\n * @param allowExtendedHtml whether to allow extended HTML tags such as headings and lists\n * @return The HTML-ified node.\n */\nexport function topicToHtml(\n    topic?: string,\n    htmlTopic?: string,\n    ref?: LegacyRef<HTMLSpanElement>,\n    allowExtendedHtml = false,\n): ReactNode {\n    if (!SettingsStore.getValue(\"feature_html_topic\")) {\n        htmlTopic = undefined;\n    }\n\n    let isFormattedTopic = !!htmlTopic;\n    let topicHasEmoji = false;\n    let safeTopic = \"\";\n\n    try {\n        topicHasEmoji = mightContainEmoji(isFormattedTopic ? htmlTopic! : topic);\n\n        if (isFormattedTopic) {\n            safeTopic = sanitizeHtml(htmlTopic!, allowExtendedHtml ? sanitizeHtmlParams : topicSanitizeHtmlParams);\n            if (topicHasEmoji) {\n                safeTopic = formatEmojis(safeTopic, true).join(\"\");\n            }\n        }\n    } catch {\n        isFormattedTopic = false; // Fall back to plain-text topic\n    }\n\n    let emojiBodyElements: ReturnType<typeof formatEmojis> | undefined;\n    if (!isFormattedTopic && topicHasEmoji) {\n        emojiBodyElements = formatEmojis(topic, false);\n    }\n\n    return isFormattedTopic ? (\n        <span ref={ref} dangerouslySetInnerHTML={{ __html: safeTopic }} dir=\"auto\" />\n    ) : (\n        <span ref={ref} dir=\"auto\">\n            {emojiBodyElements || topic}\n        </span>\n    );\n}\n\n/* Wrapper around linkify-react merging in our default linkify options */\nexport function Linkify({ as, options, children }: React.ComponentProps<typeof _Linkify>): ReactElement {\n    return (\n        <_Linkify as={as} options={merge({}, linkifyMatrixOptions, options)}>\n            {children}\n        </_Linkify>\n    );\n}\n\n/**\n * Linkifies the given string. This is a wrapper around 'linkifyjs/string'.\n *\n * @param {string} str string to linkify\n * @param {object} [options] Options for linkifyString. Default: linkifyMatrixOptions\n * @returns {string} Linkified string\n */\nexport function linkifyString(str: string, options = linkifyMatrixOptions): string {\n    return _linkifyString(str, options);\n}\n\n/**\n * Linkifies the given DOM element. This is a wrapper around 'linkifyjs/element'.\n *\n * @param {object} element DOM element to linkify\n * @param {object} [options] Options for linkifyElement. Default: linkifyMatrixOptions\n * @returns {object}\n */\nexport function linkifyElement(element: HTMLElement, options = linkifyMatrixOptions): HTMLElement {\n    return _linkifyElement(element, options);\n}\n\n/**\n * Linkify the given string and sanitize the HTML afterwards.\n *\n * @param {string} dirtyHtml The HTML string to sanitize and linkify\n * @param {object} [options] Options for linkifyString. Default: linkifyMatrixOptions\n * @returns {string}\n */\nexport function linkifyAndSanitizeHtml(dirtyHtml: string, options = linkifyMatrixOptions): string {\n    return sanitizeHtml(linkifyString(dirtyHtml, options), sanitizeHtmlParams);\n}\n\n/**\n * Returns if a node is a block element or not.\n * Only takes html nodes into account that are allowed in matrix messages.\n *\n * @param {Node} node\n * @returns {bool}\n */\nexport function checkBlockNode(node: Node): boolean {\n    switch (node.nodeName) {\n        case \"H1\":\n        case \"H2\":\n        case \"H3\":\n        case \"H4\":\n        case \"H5\":\n        case \"H6\":\n        case \"PRE\":\n        case \"BLOCKQUOTE\":\n        case \"P\":\n        case \"UL\":\n        case \"OL\":\n        case \"LI\":\n        case \"HR\":\n        case \"TABLE\":\n        case \"THEAD\":\n        case \"TBODY\":\n        case \"TR\":\n        case \"TH\":\n        case \"TD\":\n            return true;\n        case \"DIV\":\n            // don't treat math nodes as block nodes for deserializing\n            return !(node as HTMLElement).hasAttribute(\"data-mx-maths\");\n        default:\n            return false;\n    }\n}\n", "/*\nCopyright 2015 OpenMarket Ltd\nCopyright 2019 - 2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport React from \"react\";\nimport { MatrixEvent } from \"matrix-js-sdk/src/models/event\";\n\nimport RoomContext, { TimelineRenderingType } from \"../../../contexts/RoomContext\";\nimport SettingsStore from \"../../../settings/SettingsStore\";\nimport { RoomPermalinkCreator } from \"../../../utils/permalinks/Permalinks\";\nimport DateSeparator from \"../messages/DateSeparator\";\nimport EventTile from \"./EventTile\";\nimport { shouldFormContinuation } from \"../../structures/MessagePanel\";\nimport { wantsDateSeparator } from \"../../../DateUtils\";\nimport LegacyCallEventGrouper, { buildLegacyCallEventGroupers } from \"../../structures/LegacyCallEventGrouper\";\nimport { haveRendererForEvent } from \"../../../events/EventTileFactory\";\n\ninterface IProps {\n    // a list of strings to be highlighted in the results\n    searchHighlights?: string[];\n    // href for the highlights in this result\n    resultLink?: string;\n    // timeline of the search result\n    timeline: MatrixEvent[];\n    // indexes of the matching events (not contextual ones)\n    ourEventsIndexes: number[];\n    onHeightChanged?: () => void;\n    permalinkCreator?: RoomPermalinkCreator;\n}\n\nexport default class SearchResultTile extends React.Component<IProps> {\n    public static contextType = RoomContext;\n    public context!: React.ContextType<typeof RoomContext>;\n\n    // A map of <callId, LegacyCallEventGrouper>\n    private callEventGroupers = new Map<string, LegacyCallEventGrouper>();\n\n    public constructor(props: IProps, context: React.ContextType<typeof RoomContext>) {\n        super(props, context);\n\n        this.buildLegacyCallEventGroupers(this.props.timeline);\n    }\n\n    private buildLegacyCallEventGroupers(events?: MatrixEvent[]): void {\n        this.callEventGroupers = buildLegacyCallEventGroupers(this.callEventGroupers, events);\n    }\n\n    public render(): React.ReactNode {\n        const timeline = this.props.timeline;\n        const resultEvent = timeline[this.props.ourEventsIndexes[0]];\n        const eventId = resultEvent.getId();\n\n        const ts1 = resultEvent.getTs();\n        const ret = [<DateSeparator key={ts1 + \"-search\"} roomId={resultEvent.getRoomId()} ts={ts1} />];\n        const layout = SettingsStore.getValue(\"layout\");\n        const isTwelveHour = SettingsStore.getValue(\"showTwelveHourTimestamps\");\n        const alwaysShowTimestamps = SettingsStore.getValue(\"alwaysShowTimestamps\");\n\n        for (let j = 0; j < timeline.length; j++) {\n            const mxEv = timeline[j];\n            let highlights;\n            const contextual = !this.props.ourEventsIndexes.includes(j);\n            if (!contextual) {\n                highlights = this.props.searchHighlights;\n            }\n\n            if (haveRendererForEvent(mxEv, this.context?.showHiddenEvents)) {\n                // do we need a date separator since the last event?\n                const prevEv = timeline[j - 1];\n                // is this a continuation of the previous message?\n                const continuation =\n                    prevEv &&\n                    !wantsDateSeparator(prevEv.getDate() || undefined, mxEv.getDate() || undefined) &&\n                    shouldFormContinuation(prevEv, mxEv, this.context?.showHiddenEvents, TimelineRenderingType.Search);\n\n                let lastInSection = true;\n                const nextEv = timeline[j + 1];\n                if (nextEv) {\n                    const willWantDateSeparator = wantsDateSeparator(\n                        mxEv.getDate() || undefined,\n                        nextEv.getDate() || undefined,\n                    );\n                    lastInSection =\n                        willWantDateSeparator ||\n                        mxEv.getSender() !== nextEv.getSender() ||\n                        !shouldFormContinuation(\n                            mxEv,\n                            nextEv,\n                            this.context?.showHiddenEvents,\n                            TimelineRenderingType.Search,\n                        );\n                }\n\n                ret.push(\n                    <EventTile\n                        key={`${eventId}+${j}`}\n                        mxEvent={mxEv}\n                        layout={layout}\n                        contextual={contextual}\n                        highlights={highlights}\n                        permalinkCreator={this.props.permalinkCreator}\n                        highlightLink={this.props.resultLink}\n                        onHeightChanged={this.props.onHeightChanged}\n                        isTwelveHour={isTwelveHour}\n                        alwaysShowTimestamps={alwaysShowTimestamps}\n                        lastInSection={lastInSection}\n                        continuation={continuation}\n                        callEventGrouper={this.callEventGroupers.get(mxEv.getContent().call_id)}\n                    />,\n                );\n            }\n        }\n\n        return (\n            <li data-scroll-tokens={eventId}>\n                <ol>{ret}</ol>\n            </li>\n        );\n    }\n}\n", "/*\nCopyright 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport React from \"react\";\nimport { mocked } from \"jest-mock\";\nimport { render, screen } from \"@testing-library/react\";\n\nimport { topicToHtml } from \"../src/HtmlUtils\";\nimport SettingsStore from \"../src/settings/SettingsStore\";\n\njest.mock(\"../src/settings/SettingsStore\");\n\nconst enableHtmlTopicFeature = () => {\n    mocked(SettingsStore).getValue.mockImplementation((arg): any => {\n        return arg === \"feature_html_topic\";\n    });\n};\n\ndescribe(\"HtmlUtils\", () => {\n    function getContent() {\n        return screen.getByRole(\"contentinfo\").children[0].innerHTML;\n    }\n\n    it(\"converts plain text topic to HTML\", () => {\n        render(<div role=\"contentinfo\">{topicToHtml(\"pizza\", undefined, null, false)}</div>);\n        expect(getContent()).toEqual(\"pizza\");\n    });\n\n    it(\"converts plain text topic with emoji to HTML\", () => {\n        render(<div role=\"contentinfo\">{topicToHtml(\"pizza \ud83c\udf55\", undefined, null, false)}</div>);\n        expect(getContent()).toEqual('pizza <span class=\"mx_Emoji\" title=\":pizza:\">\ud83c\udf55</span>');\n    });\n\n    it(\"converts literal HTML topic to HTML\", async () => {\n        enableHtmlTopicFeature();\n        render(<div role=\"contentinfo\">{topicToHtml(\"<b>pizza</b>\", undefined, null, false)}</div>);\n        expect(getContent()).toEqual(\"&lt;b&gt;pizza&lt;/b&gt;\");\n    });\n\n    it(\"converts true HTML topic to HTML\", async () => {\n        enableHtmlTopicFeature();\n        render(<div role=\"contentinfo\">{topicToHtml(\"**pizza**\", \"<b>pizza</b>\", null, false)}</div>);\n        expect(getContent()).toEqual(\"<b>pizza</b>\");\n    });\n\n    it(\"converts true HTML topic with emoji to HTML\", async () => {\n        enableHtmlTopicFeature();\n        render(<div role=\"contentinfo\">{topicToHtml(\"**pizza** \ud83c\udf55\", \"<b>pizza</b> \ud83c\udf55\", null, false)}</div>);\n        expect(getContent()).toEqual('<b>pizza</b> <span class=\"mx_Emoji\" title=\":pizza:\">\ud83c\udf55</span>');\n    });\n});\n"], "fixing_code": ["/*\nCopyright 2015, 2016 OpenMarket Ltd\nCopyright 2017, 2018 New Vector Ltd\nCopyright 2019 Michael Telatynski <7t3chguy@gmail.com>\nCopyright 2019 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport React, { LegacyRef, ReactElement, ReactNode } from \"react\";\nimport sanitizeHtml from \"sanitize-html\";\nimport cheerio from \"cheerio\";\nimport classNames from \"classnames\";\nimport EMOJIBASE_REGEX from \"emojibase-regex\";\nimport { merge, split } from \"lodash\";\nimport katex from \"katex\";\nimport { decode } from \"html-entities\";\nimport { IContent } from \"matrix-js-sdk/src/models/event\";\nimport { Optional } from \"matrix-events-sdk\";\nimport _Linkify from \"linkify-react\";\nimport escapeHtml from \"escape-html\";\n\nimport {\n    _linkifyElement,\n    _linkifyString,\n    ELEMENT_URL_PATTERN,\n    options as linkifyMatrixOptions,\n} from \"./linkify-matrix\";\nimport { IExtendedSanitizeOptions } from \"./@types/sanitize-html\";\nimport SettingsStore from \"./settings/SettingsStore\";\nimport { tryTransformPermalinkToLocalHref } from \"./utils/permalinks/Permalinks\";\nimport { getEmojiFromUnicode } from \"./emoji\";\nimport { mediaFromMxc } from \"./customisations/Media\";\nimport { stripHTMLReply, stripPlainReply } from \"./utils/Reply\";\n\n// Anything outside the basic multilingual plane will be a surrogate pair\nconst SURROGATE_PAIR_PATTERN = /([\\ud800-\\udbff])([\\udc00-\\udfff])/;\n// And there a bunch more symbol characters that emojibase has within the\n// BMP, so this includes the ranges from 'letterlike symbols' to\n// 'miscellaneous symbols and arrows' which should catch all of them\n// (with plenty of false positives, but that's OK)\nconst SYMBOL_PATTERN = /([\\u2100-\\u2bff])/;\n\n// Regex pattern for non-emoji characters that can appear in an \"all-emoji\" message (Zero-Width Joiner, Zero-Width Space, other whitespace)\nconst EMOJI_SEPARATOR_REGEX = /[\\u200D\\u200B\\s]/g;\n\nconst BIGEMOJI_REGEX = new RegExp(`^(${EMOJIBASE_REGEX.source})+$`, \"i\");\n\nconst COLOR_REGEX = /^#[0-9a-fA-F]{6}$/;\n\nexport const PERMITTED_URL_SCHEMES = [\n    \"bitcoin\",\n    \"ftp\",\n    \"geo\",\n    \"http\",\n    \"https\",\n    \"im\",\n    \"irc\",\n    \"ircs\",\n    \"magnet\",\n    \"mailto\",\n    \"matrix\",\n    \"mms\",\n    \"news\",\n    \"nntp\",\n    \"openpgp4fpr\",\n    \"sip\",\n    \"sftp\",\n    \"sms\",\n    \"smsto\",\n    \"ssh\",\n    \"tel\",\n    \"urn\",\n    \"webcal\",\n    \"wtai\",\n    \"xmpp\",\n];\n\nconst MEDIA_API_MXC_REGEX = /\\/_matrix\\/media\\/r0\\/(?:download|thumbnail)\\/(.+?)\\/(.+?)(?:[?/]|$)/;\n\n/*\n * Return true if the given string contains emoji\n * Uses a much, much simpler regex than emojibase's so will give false\n * positives, but useful for fast-path testing strings to see if they\n * need emojification.\n */\nfunction mightContainEmoji(str?: string): boolean {\n    return !!str && (SURROGATE_PAIR_PATTERN.test(str) || SYMBOL_PATTERN.test(str));\n}\n\n/**\n * Returns the shortcode for an emoji character.\n *\n * @param {String} char The emoji character\n * @return {String} The shortcode (such as :thumbup:)\n */\nexport function unicodeToShortcode(char: string): string {\n    const shortcodes = getEmojiFromUnicode(char)?.shortcodes;\n    return shortcodes?.length ? `:${shortcodes[0]}:` : \"\";\n}\n\n/*\n * Given an untrusted HTML string, return a React node with an sanitized version\n * of that HTML.\n */\nexport function sanitizedHtmlNode(insaneHtml: string): ReactNode {\n    const saneHtml = sanitizeHtml(insaneHtml, sanitizeHtmlParams);\n\n    return <div dangerouslySetInnerHTML={{ __html: saneHtml }} dir=\"auto\" />;\n}\n\nexport function getHtmlText(insaneHtml: string): string {\n    return sanitizeHtml(insaneHtml, {\n        allowedTags: [],\n        allowedAttributes: {},\n        selfClosing: [],\n        allowedSchemes: [],\n        disallowedTagsMode: \"discard\",\n    });\n}\n\n/**\n * Tests if a URL from an untrusted source may be safely put into the DOM\n * The biggest threat here is javascript: URIs.\n * Note that the HTML sanitiser library has its own internal logic for\n * doing this, to which we pass the same list of schemes. This is used in\n * other places we need to sanitise URLs.\n * @return true if permitted, otherwise false\n */\nexport function isUrlPermitted(inputUrl: string): boolean {\n    try {\n        // URL parser protocol includes the trailing colon\n        return PERMITTED_URL_SCHEMES.includes(new URL(inputUrl).protocol.slice(0, -1));\n    } catch (e) {\n        return false;\n    }\n}\n\nconst transformTags: IExtendedSanitizeOptions[\"transformTags\"] = {\n    // custom to matrix\n    // add blank targets to all hyperlinks except vector URLs\n    \"a\": function (tagName: string, attribs: sanitizeHtml.Attributes) {\n        if (attribs.href) {\n            attribs.target = \"_blank\"; // by default\n\n            const transformed = tryTransformPermalinkToLocalHref(attribs.href); // only used to check if it is a link that can be handled locally\n            if (\n                transformed !== attribs.href || // it could be converted so handle locally symbols e.g. @user:server.tdl, matrix: and matrix.to\n                attribs.href.match(ELEMENT_URL_PATTERN) // for https links to Element domains\n            ) {\n                delete attribs.target;\n            }\n        } else {\n            // Delete the href attrib if it is falsy\n            delete attribs.href;\n        }\n\n        attribs.rel = \"noreferrer noopener\"; // https://mathiasbynens.github.io/rel-noopener/\n        return { tagName, attribs };\n    },\n    \"img\": function (tagName: string, attribs: sanitizeHtml.Attributes) {\n        let src = attribs.src;\n        // Strip out imgs that aren't `mxc` here instead of using allowedSchemesByTag\n        // because transformTags is used _before_ we filter by allowedSchemesByTag and\n        // we don't want to allow images with `https?` `src`s.\n        // We also drop inline images (as if they were not present at all) when the \"show\n        // images\" preference is disabled. Future work might expose some UI to reveal them\n        // like standalone image events have.\n        if (!src || !SettingsStore.getValue(\"showImages\")) {\n            return { tagName, attribs: {} };\n        }\n\n        if (!src.startsWith(\"mxc://\")) {\n            const match = MEDIA_API_MXC_REGEX.exec(src);\n            if (match) {\n                src = `mxc://${match[1]}/${match[2]}`;\n            }\n        }\n\n        if (!src.startsWith(\"mxc://\")) {\n            return { tagName, attribs: {} };\n        }\n\n        const requestedWidth = Number(attribs.width);\n        const requestedHeight = Number(attribs.height);\n        const width = Math.min(requestedWidth || 800, 800);\n        const height = Math.min(requestedHeight || 600, 600);\n        // specify width/height as max values instead of absolute ones to allow object-fit to do its thing\n        // we only allow our own styles for this tag so overwrite the attribute\n        attribs.style = `max-width: ${width}px; max-height: ${height}px;`;\n        if (requestedWidth) {\n            attribs.style += \"width: 100%;\";\n        }\n        if (requestedHeight) {\n            attribs.style += \"height: 100%;\";\n        }\n\n        attribs.src = mediaFromMxc(src).getThumbnailOfSourceHttp(width, height)!;\n        return { tagName, attribs };\n    },\n    \"code\": function (tagName: string, attribs: sanitizeHtml.Attributes) {\n        if (typeof attribs.class !== \"undefined\") {\n            // Filter out all classes other than ones starting with language- for syntax highlighting.\n            const classes = attribs.class.split(/\\s/).filter(function (cl) {\n                return cl.startsWith(\"language-\") && !cl.startsWith(\"language-_\");\n            });\n            attribs.class = classes.join(\" \");\n        }\n        return { tagName, attribs };\n    },\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    \"*\": function (tagName: string, attribs: sanitizeHtml.Attributes) {\n        // Delete any style previously assigned, style is an allowedTag for font, span & img,\n        // because attributes are stripped after transforming.\n        // For img this is trusted as it is generated wholly within the img transformation method.\n        if (tagName !== \"img\") {\n            delete attribs.style;\n        }\n\n        // Sanitise and transform data-mx-color and data-mx-bg-color to their CSS\n        // equivalents\n        const customCSSMapper: Record<string, string> = {\n            \"data-mx-color\": \"color\",\n            \"data-mx-bg-color\": \"background-color\",\n            // $customAttributeKey: $cssAttributeKey\n        };\n\n        let style = \"\";\n        Object.keys(customCSSMapper).forEach((customAttributeKey) => {\n            const cssAttributeKey = customCSSMapper[customAttributeKey];\n            const customAttributeValue = attribs[customAttributeKey];\n            if (\n                customAttributeValue &&\n                typeof customAttributeValue === \"string\" &&\n                COLOR_REGEX.test(customAttributeValue)\n            ) {\n                style += cssAttributeKey + \":\" + customAttributeValue + \";\";\n                delete attribs[customAttributeKey];\n            }\n        });\n\n        if (style) {\n            attribs.style = style + (attribs.style || \"\");\n        }\n\n        return { tagName, attribs };\n    },\n};\n\nconst sanitizeHtmlParams: IExtendedSanitizeOptions = {\n    allowedTags: [\n        \"font\", // custom to matrix for IRC-style font coloring\n        \"del\", // for markdown\n        \"h1\",\n        \"h2\",\n        \"h3\",\n        \"h4\",\n        \"h5\",\n        \"h6\",\n        \"blockquote\",\n        \"p\",\n        \"a\",\n        \"ul\",\n        \"ol\",\n        \"sup\",\n        \"sub\",\n        \"nl\",\n        \"li\",\n        \"b\",\n        \"i\",\n        \"u\",\n        \"strong\",\n        \"em\",\n        \"strike\",\n        \"code\",\n        \"hr\",\n        \"br\",\n        \"div\",\n        \"table\",\n        \"thead\",\n        \"caption\",\n        \"tbody\",\n        \"tr\",\n        \"th\",\n        \"td\",\n        \"pre\",\n        \"span\",\n        \"img\",\n        \"details\",\n        \"summary\",\n    ],\n    allowedAttributes: {\n        // attribute sanitization happens after transformations, so we have to accept `style` for font, span & img\n        // but strip during the transformation.\n        // custom ones first:\n        font: [\"color\", \"data-mx-bg-color\", \"data-mx-color\", \"style\"], // custom to matrix\n        span: [\"data-mx-maths\", \"data-mx-bg-color\", \"data-mx-color\", \"data-mx-spoiler\", \"style\"], // custom to matrix\n        div: [\"data-mx-maths\"],\n        a: [\"href\", \"name\", \"target\", \"rel\"], // remote target: custom to matrix\n        // img tags also accept width/height, we just map those to max-width & max-height during transformation\n        img: [\"src\", \"alt\", \"title\", \"style\"],\n        ol: [\"start\"],\n        code: [\"class\"], // We don't actually allow all classes, we filter them in transformTags\n    },\n    // Lots of these won't come up by default because we don't allow them\n    selfClosing: [\"img\", \"br\", \"hr\", \"area\", \"base\", \"basefont\", \"input\", \"link\", \"meta\"],\n    // URL schemes we permit\n    allowedSchemes: PERMITTED_URL_SCHEMES,\n    allowProtocolRelative: false,\n    transformTags,\n    // 50 levels deep \"should be enough for anyone\"\n    nestingLimit: 50,\n};\n\n// this is the same as the above except with less rewriting\nconst composerSanitizeHtmlParams: IExtendedSanitizeOptions = {\n    ...sanitizeHtmlParams,\n    transformTags: {\n        \"code\": transformTags[\"code\"],\n        \"*\": transformTags[\"*\"],\n    },\n};\n\n// reduced set of allowed tags to avoid turning topics into Myspace\nconst topicSanitizeHtmlParams: IExtendedSanitizeOptions = {\n    ...sanitizeHtmlParams,\n    allowedTags: [\n        \"font\", // custom to matrix for IRC-style font coloring\n        \"del\", // for markdown\n        \"a\",\n        \"sup\",\n        \"sub\",\n        \"b\",\n        \"i\",\n        \"u\",\n        \"strong\",\n        \"em\",\n        \"strike\",\n        \"br\",\n        \"div\",\n        \"span\",\n    ],\n};\n\nabstract class BaseHighlighter<T extends React.ReactNode> {\n    public constructor(public highlightClass: string, public highlightLink?: string) {}\n\n    /**\n     * Apply the highlights to a section of text\n     *\n     * @param {string} safeSnippet The snippet of text to apply the highlights\n     *     to. This input must be sanitised as it will be treated as HTML.\n     * @param {string[]} safeHighlights A list of substrings to highlight,\n     *     sorted by descending length.\n     *\n     * returns a list of results (strings for HtmlHighligher, react nodes for\n     * TextHighlighter).\n     */\n    public applyHighlights(safeSnippet: string, safeHighlights: string[]): T[] {\n        let lastOffset = 0;\n        let offset: number;\n        let nodes: T[] = [];\n\n        const safeHighlight = safeHighlights[0];\n        while ((offset = safeSnippet.toLowerCase().indexOf(safeHighlight.toLowerCase(), lastOffset)) >= 0) {\n            // handle preamble\n            if (offset > lastOffset) {\n                const subSnippet = safeSnippet.substring(lastOffset, offset);\n                nodes = nodes.concat(this.applySubHighlights(subSnippet, safeHighlights));\n            }\n\n            // do highlight. use the original string rather than safeHighlight\n            // to preserve the original casing.\n            const endOffset = offset + safeHighlight.length;\n            nodes.push(this.processSnippet(safeSnippet.substring(offset, endOffset), true));\n\n            lastOffset = endOffset;\n        }\n\n        // handle postamble\n        if (lastOffset !== safeSnippet.length) {\n            const subSnippet = safeSnippet.substring(lastOffset, undefined);\n            nodes = nodes.concat(this.applySubHighlights(subSnippet, safeHighlights));\n        }\n        return nodes;\n    }\n\n    private applySubHighlights(safeSnippet: string, safeHighlights: string[]): T[] {\n        if (safeHighlights[1]) {\n            // recurse into this range to check for the next set of highlight matches\n            return this.applyHighlights(safeSnippet, safeHighlights.slice(1));\n        } else {\n            // no more highlights to be found, just return the unhighlighted string\n            return [this.processSnippet(safeSnippet, false)];\n        }\n    }\n\n    protected abstract processSnippet(snippet: string, highlight: boolean): T;\n}\n\nclass HtmlHighlighter extends BaseHighlighter<string> {\n    /* highlight the given snippet if required\n     *\n     * snippet: content of the span; must have been sanitised\n     * highlight: true to highlight as a search match\n     *\n     * returns an HTML string\n     */\n    protected processSnippet(snippet: string, highlight: boolean): string {\n        if (!highlight) {\n            // nothing required here\n            return snippet;\n        }\n\n        let span = `<span class=\"${this.highlightClass}\">${snippet}</span>`;\n\n        if (this.highlightLink) {\n            span = `<a href=\"${encodeURI(this.highlightLink)}\">${span}</a>`;\n        }\n        return span;\n    }\n}\n\ninterface IOpts {\n    highlightLink?: string;\n    disableBigEmoji?: boolean;\n    stripReplyFallback?: boolean;\n    returnString?: boolean;\n    forComposerQuote?: boolean;\n    ref?: React.Ref<HTMLSpanElement>;\n}\n\nexport interface IOptsReturnNode extends IOpts {\n    returnString?: false | undefined;\n}\n\nexport interface IOptsReturnString extends IOpts {\n    returnString: true;\n}\n\nconst emojiToHtmlSpan = (emoji: string): string =>\n    `<span class='mx_Emoji' title='${unicodeToShortcode(emoji)}'>${emoji}</span>`;\nconst emojiToJsxSpan = (emoji: string, key: number): JSX.Element => (\n    <span key={key} className=\"mx_Emoji\" title={unicodeToShortcode(emoji)}>\n        {emoji}\n    </span>\n);\n\n/**\n * Wraps emojis in <span> to style them separately from the rest of message. Consecutive emojis (and modifiers) are wrapped\n * in the same <span>.\n * @param {string} message the text to format\n * @param {boolean} isHtmlMessage whether the message contains HTML\n * @returns if isHtmlMessage is true, returns an array of strings, otherwise return an array of React Elements for emojis\n * and plain text for everything else\n */\nfunction formatEmojis(message: string | undefined, isHtmlMessage: boolean): (JSX.Element | string)[] {\n    const emojiToSpan = isHtmlMessage ? emojiToHtmlSpan : emojiToJsxSpan;\n    const result: (JSX.Element | string)[] = [];\n    let text = \"\";\n    let key = 0;\n\n    // We use lodash's grapheme splitter to avoid breaking apart compound emojis\n    for (const char of split(message, \"\")) {\n        if (EMOJIBASE_REGEX.test(char)) {\n            if (text) {\n                result.push(text);\n                text = \"\";\n            }\n            result.push(emojiToSpan(char, key));\n            key++;\n        } else {\n            text += char;\n        }\n    }\n    if (text) {\n        result.push(text);\n    }\n    return result;\n}\n\n/* turn a matrix event body into html\n *\n * content: 'content' of the MatrixEvent\n *\n * highlights: optional list of words to highlight, ordered by longest word first\n *\n * opts.highlightLink: optional href to add to highlighted words\n * opts.disableBigEmoji: optional argument to disable the big emoji class.\n * opts.stripReplyFallback: optional argument specifying the event is a reply and so fallback needs removing\n * opts.returnString: return an HTML string rather than JSX elements\n * opts.forComposerQuote: optional param to lessen the url rewriting done by sanitization, for quoting into composer\n * opts.ref: React ref to attach to any React components returned (not compatible with opts.returnString)\n */\nexport function bodyToHtml(content: IContent, highlights: Optional<string[]>, opts: IOptsReturnString): string;\nexport function bodyToHtml(content: IContent, highlights: Optional<string[]>, opts: IOptsReturnNode): ReactNode;\nexport function bodyToHtml(content: IContent, highlights: Optional<string[]>, opts: IOpts = {}): ReactNode | string {\n    const isFormattedBody = content.format === \"org.matrix.custom.html\" && typeof content.formatted_body === \"string\";\n    let bodyHasEmoji = false;\n    let isHtmlMessage = false;\n\n    let sanitizeParams = sanitizeHtmlParams;\n    if (opts.forComposerQuote) {\n        sanitizeParams = composerSanitizeHtmlParams;\n    }\n\n    let strippedBody: string;\n    let safeBody: string | undefined; // safe, sanitised HTML, preferred over `strippedBody` which is fully plaintext\n\n    try {\n        // sanitizeHtml can hang if an unclosed HTML tag is thrown at it\n        // A search for `<foo` will make the browser crash an alternative would be to escape HTML special characters\n        // but that would bring no additional benefit as the highlighter does not work with those special chars\n        const safeHighlights = highlights\n            ?.filter((highlight: string): boolean => !highlight.includes(\"<\"))\n            .map((highlight: string): string => sanitizeHtml(highlight, sanitizeParams));\n\n        let formattedBody = typeof content.formatted_body === \"string\" ? content.formatted_body : null;\n        const plainBody = typeof content.body === \"string\" ? content.body : \"\";\n\n        if (opts.stripReplyFallback && formattedBody) formattedBody = stripHTMLReply(formattedBody);\n        strippedBody = opts.stripReplyFallback ? stripPlainReply(plainBody) : plainBody;\n        bodyHasEmoji = mightContainEmoji(isFormattedBody ? formattedBody! : plainBody);\n\n        const highlighter = safeHighlights?.length\n            ? new HtmlHighlighter(\"mx_EventTile_searchHighlight\", opts.highlightLink)\n            : null;\n\n        if (isFormattedBody) {\n            if (highlighter) {\n                // XXX: We sanitize the HTML whilst also highlighting its text nodes, to avoid accidentally trying\n                // to highlight HTML tags themselves. However, this does mean that we don't highlight textnodes which\n                // are interrupted by HTML tags (not that we did before) - e.g. foo<span/>bar won't get highlighted\n                // by an attempt to search for 'foobar'.  Then again, the search query probably wouldn't work either\n                // XXX: hacky bodge to temporarily apply a textFilter to the sanitizeParams structure.\n                sanitizeParams.textFilter = function (safeText) {\n                    return highlighter.applyHighlights(safeText, safeHighlights!).join(\"\");\n                };\n            }\n\n            safeBody = sanitizeHtml(formattedBody!, sanitizeParams);\n            const phtml = cheerio.load(safeBody, {\n                // @ts-ignore: The `_useHtmlParser2` internal option is the\n                // simplest way to both parse and render using `htmlparser2`.\n                _useHtmlParser2: true,\n                decodeEntities: false,\n            });\n            const isPlainText = phtml.html() === phtml.root().text();\n            isHtmlMessage = !isPlainText;\n\n            if (isHtmlMessage && SettingsStore.getValue(\"feature_latex_maths\")) {\n                // @ts-ignore - The types for `replaceWith` wrongly expect\n                // Cheerio instance to be returned.\n                phtml('div, span[data-mx-maths!=\"\"]').replaceWith(function (i, e) {\n                    return katex.renderToString(decode(phtml(e).attr(\"data-mx-maths\")), {\n                        throwOnError: false,\n                        // @ts-ignore - `e` can be an Element, not just a Node\n                        displayMode: e.name == \"div\",\n                        output: \"htmlAndMathml\",\n                    });\n                });\n                safeBody = phtml.html();\n            }\n            if (bodyHasEmoji) {\n                safeBody = formatEmojis(safeBody, true).join(\"\");\n            }\n        } else if (highlighter) {\n            safeBody = highlighter.applyHighlights(escapeHtml(plainBody), safeHighlights!).join(\"\");\n        }\n    } finally {\n        delete sanitizeParams.textFilter;\n    }\n\n    const contentBody = safeBody ?? strippedBody;\n    if (opts.returnString) {\n        return contentBody;\n    }\n\n    let emojiBody = false;\n    if (!opts.disableBigEmoji && bodyHasEmoji) {\n        let contentBodyTrimmed = contentBody !== undefined ? contentBody.trim() : \"\";\n\n        // Remove zero width joiner, zero width spaces and other spaces in body\n        // text. This ensures that emojis with spaces in between or that are made\n        // up of multiple unicode characters are still counted as purely emoji\n        // messages.\n        contentBodyTrimmed = contentBodyTrimmed.replace(EMOJI_SEPARATOR_REGEX, \"\");\n\n        const match = BIGEMOJI_REGEX.exec(contentBodyTrimmed);\n        emojiBody =\n            match?.[0]?.length === contentBodyTrimmed.length &&\n            // Prevent user pills expanding for users with only emoji in\n            // their username. Permalinks (links in pills) can be any URL\n            // now, so we just check for an HTTP-looking thing.\n            (strippedBody === safeBody || // replies have the html fallbacks, account for that here\n                content.formatted_body === undefined ||\n                (!content.formatted_body.includes(\"http:\") && !content.formatted_body.includes(\"https:\")));\n    }\n\n    const className = classNames({\n        \"mx_EventTile_body\": true,\n        \"mx_EventTile_bigEmoji\": emojiBody,\n        \"markdown-body\": isHtmlMessage && !emojiBody,\n    });\n\n    let emojiBodyElements: JSX.Element[] | undefined;\n    if (!safeBody && bodyHasEmoji) {\n        emojiBodyElements = formatEmojis(strippedBody, false) as JSX.Element[];\n    }\n\n    return safeBody ? (\n        <span\n            key=\"body\"\n            ref={opts.ref}\n            className={className}\n            dangerouslySetInnerHTML={{ __html: safeBody }}\n            dir=\"auto\"\n        />\n    ) : (\n        <span key=\"body\" ref={opts.ref} className={className} dir=\"auto\">\n            {emojiBodyElements || strippedBody}\n        </span>\n    );\n}\n\n/**\n * Turn a room topic into html\n * @param topic plain text topic\n * @param htmlTopic optional html topic\n * @param ref React ref to attach to any React components returned\n * @param allowExtendedHtml whether to allow extended HTML tags such as headings and lists\n * @return The HTML-ified node.\n */\nexport function topicToHtml(\n    topic?: string,\n    htmlTopic?: string,\n    ref?: LegacyRef<HTMLSpanElement>,\n    allowExtendedHtml = false,\n): ReactNode {\n    if (!SettingsStore.getValue(\"feature_html_topic\")) {\n        htmlTopic = undefined;\n    }\n\n    let isFormattedTopic = !!htmlTopic;\n    let topicHasEmoji = false;\n    let safeTopic = \"\";\n\n    try {\n        topicHasEmoji = mightContainEmoji(isFormattedTopic ? htmlTopic! : topic);\n\n        if (isFormattedTopic) {\n            safeTopic = sanitizeHtml(htmlTopic!, allowExtendedHtml ? sanitizeHtmlParams : topicSanitizeHtmlParams);\n            if (topicHasEmoji) {\n                safeTopic = formatEmojis(safeTopic, true).join(\"\");\n            }\n        }\n    } catch {\n        isFormattedTopic = false; // Fall back to plain-text topic\n    }\n\n    let emojiBodyElements: ReturnType<typeof formatEmojis> | undefined;\n    if (!isFormattedTopic && topicHasEmoji) {\n        emojiBodyElements = formatEmojis(topic, false);\n    }\n\n    return isFormattedTopic ? (\n        <span ref={ref} dangerouslySetInnerHTML={{ __html: safeTopic }} dir=\"auto\" />\n    ) : (\n        <span ref={ref} dir=\"auto\">\n            {emojiBodyElements || topic}\n        </span>\n    );\n}\n\n/* Wrapper around linkify-react merging in our default linkify options */\nexport function Linkify({ as, options, children }: React.ComponentProps<typeof _Linkify>): ReactElement {\n    return (\n        <_Linkify as={as} options={merge({}, linkifyMatrixOptions, options)}>\n            {children}\n        </_Linkify>\n    );\n}\n\n/**\n * Linkifies the given string. This is a wrapper around 'linkifyjs/string'.\n *\n * @param {string} str string to linkify\n * @param {object} [options] Options for linkifyString. Default: linkifyMatrixOptions\n * @returns {string} Linkified string\n */\nexport function linkifyString(str: string, options = linkifyMatrixOptions): string {\n    return _linkifyString(str, options);\n}\n\n/**\n * Linkifies the given DOM element. This is a wrapper around 'linkifyjs/element'.\n *\n * @param {object} element DOM element to linkify\n * @param {object} [options] Options for linkifyElement. Default: linkifyMatrixOptions\n * @returns {object}\n */\nexport function linkifyElement(element: HTMLElement, options = linkifyMatrixOptions): HTMLElement {\n    return _linkifyElement(element, options);\n}\n\n/**\n * Linkify the given string and sanitize the HTML afterwards.\n *\n * @param {string} dirtyHtml The HTML string to sanitize and linkify\n * @param {object} [options] Options for linkifyString. Default: linkifyMatrixOptions\n * @returns {string}\n */\nexport function linkifyAndSanitizeHtml(dirtyHtml: string, options = linkifyMatrixOptions): string {\n    return sanitizeHtml(linkifyString(dirtyHtml, options), sanitizeHtmlParams);\n}\n\n/**\n * Returns if a node is a block element or not.\n * Only takes html nodes into account that are allowed in matrix messages.\n *\n * @param {Node} node\n * @returns {bool}\n */\nexport function checkBlockNode(node: Node): boolean {\n    switch (node.nodeName) {\n        case \"H1\":\n        case \"H2\":\n        case \"H3\":\n        case \"H4\":\n        case \"H5\":\n        case \"H6\":\n        case \"PRE\":\n        case \"BLOCKQUOTE\":\n        case \"P\":\n        case \"UL\":\n        case \"OL\":\n        case \"LI\":\n        case \"HR\":\n        case \"TABLE\":\n        case \"THEAD\":\n        case \"TBODY\":\n        case \"TR\":\n        case \"TH\":\n        case \"TD\":\n            return true;\n        case \"DIV\":\n            // don't treat math nodes as block nodes for deserializing\n            return !(node as HTMLElement).hasAttribute(\"data-mx-maths\");\n        default:\n            return false;\n    }\n}\n", "/*\nCopyright 2015 OpenMarket Ltd\nCopyright 2019 - 2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport React from \"react\";\nimport { MatrixEvent } from \"matrix-js-sdk/src/models/event\";\n\nimport RoomContext, { TimelineRenderingType } from \"../../../contexts/RoomContext\";\nimport SettingsStore from \"../../../settings/SettingsStore\";\nimport { RoomPermalinkCreator } from \"../../../utils/permalinks/Permalinks\";\nimport DateSeparator from \"../messages/DateSeparator\";\nimport EventTile from \"./EventTile\";\nimport { shouldFormContinuation } from \"../../structures/MessagePanel\";\nimport { wantsDateSeparator } from \"../../../DateUtils\";\nimport LegacyCallEventGrouper, { buildLegacyCallEventGroupers } from \"../../structures/LegacyCallEventGrouper\";\nimport { haveRendererForEvent } from \"../../../events/EventTileFactory\";\n\ninterface IProps {\n    // a list of strings to be highlighted in the results\n    searchHighlights?: string[];\n    // href for the highlights in this result\n    resultLink?: string;\n    // timeline of the search result\n    timeline: MatrixEvent[];\n    // indexes of the matching events (not contextual ones)\n    ourEventsIndexes: number[];\n    onHeightChanged?: () => void;\n    permalinkCreator?: RoomPermalinkCreator;\n}\n\nexport default class SearchResultTile extends React.Component<IProps> {\n    public static contextType = RoomContext;\n    public context!: React.ContextType<typeof RoomContext>;\n\n    // A map of <callId, LegacyCallEventGrouper>\n    private callEventGroupers = new Map<string, LegacyCallEventGrouper>();\n\n    public constructor(props: IProps, context: React.ContextType<typeof RoomContext>) {\n        super(props, context);\n\n        this.buildLegacyCallEventGroupers(this.props.timeline);\n    }\n\n    private buildLegacyCallEventGroupers(events?: MatrixEvent[]): void {\n        this.callEventGroupers = buildLegacyCallEventGroupers(this.callEventGroupers, events);\n    }\n\n    public render(): React.ReactNode {\n        const timeline = this.props.timeline;\n        const resultEvent = timeline[this.props.ourEventsIndexes[0]];\n        const eventId = resultEvent.getId();\n\n        const ts1 = resultEvent.getTs();\n        const ret = [<DateSeparator key={ts1 + \"-search\"} roomId={resultEvent.getRoomId()} ts={ts1} />];\n        const layout = SettingsStore.getValue(\"layout\");\n        const isTwelveHour = SettingsStore.getValue(\"showTwelveHourTimestamps\");\n        const alwaysShowTimestamps = SettingsStore.getValue(\"alwaysShowTimestamps\");\n\n        for (let j = 0; j < timeline.length; j++) {\n            const mxEv = timeline[j];\n            let highlights: string[] | undefined;\n            const contextual = !this.props.ourEventsIndexes.includes(j);\n            if (!contextual) {\n                highlights = this.props.searchHighlights;\n            }\n\n            if (haveRendererForEvent(mxEv, this.context?.showHiddenEvents)) {\n                // do we need a date separator since the last event?\n                const prevEv = timeline[j - 1];\n                // is this a continuation of the previous message?\n                const continuation =\n                    prevEv &&\n                    !wantsDateSeparator(prevEv.getDate() || undefined, mxEv.getDate() || undefined) &&\n                    shouldFormContinuation(prevEv, mxEv, this.context?.showHiddenEvents, TimelineRenderingType.Search);\n\n                let lastInSection = true;\n                const nextEv = timeline[j + 1];\n                if (nextEv) {\n                    const willWantDateSeparator = wantsDateSeparator(\n                        mxEv.getDate() || undefined,\n                        nextEv.getDate() || undefined,\n                    );\n                    lastInSection =\n                        willWantDateSeparator ||\n                        mxEv.getSender() !== nextEv.getSender() ||\n                        !shouldFormContinuation(\n                            mxEv,\n                            nextEv,\n                            this.context?.showHiddenEvents,\n                            TimelineRenderingType.Search,\n                        );\n                }\n\n                ret.push(\n                    <EventTile\n                        key={`${eventId}+${j}`}\n                        mxEvent={mxEv}\n                        layout={layout}\n                        contextual={contextual}\n                        highlights={highlights}\n                        permalinkCreator={this.props.permalinkCreator}\n                        highlightLink={this.props.resultLink}\n                        onHeightChanged={this.props.onHeightChanged}\n                        isTwelveHour={isTwelveHour}\n                        alwaysShowTimestamps={alwaysShowTimestamps}\n                        lastInSection={lastInSection}\n                        continuation={continuation}\n                        callEventGrouper={this.callEventGroupers.get(mxEv.getContent().call_id)}\n                    />,\n                );\n            }\n        }\n\n        return (\n            <li data-scroll-tokens={eventId}>\n                <ol>{ret}</ol>\n            </li>\n        );\n    }\n}\n", "/*\nCopyright 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport React, { ReactElement } from \"react\";\nimport { mocked } from \"jest-mock\";\nimport { render, screen } from \"@testing-library/react\";\nimport { IContent } from \"matrix-js-sdk/src/models/event\";\n\nimport { bodyToHtml, topicToHtml } from \"../src/HtmlUtils\";\nimport SettingsStore from \"../src/settings/SettingsStore\";\n\njest.mock(\"../src/settings/SettingsStore\");\n\nconst enableHtmlTopicFeature = () => {\n    mocked(SettingsStore).getValue.mockImplementation((arg): any => {\n        return arg === \"feature_html_topic\";\n    });\n};\n\ndescribe(\"topicToHtml\", () => {\n    function getContent() {\n        return screen.getByRole(\"contentinfo\").children[0].innerHTML;\n    }\n\n    it(\"converts plain text topic to HTML\", () => {\n        render(<div role=\"contentinfo\">{topicToHtml(\"pizza\", undefined, null, false)}</div>);\n        expect(getContent()).toEqual(\"pizza\");\n    });\n\n    it(\"converts plain text topic with emoji to HTML\", () => {\n        render(<div role=\"contentinfo\">{topicToHtml(\"pizza \ud83c\udf55\", undefined, null, false)}</div>);\n        expect(getContent()).toEqual('pizza <span class=\"mx_Emoji\" title=\":pizza:\">\ud83c\udf55</span>');\n    });\n\n    it(\"converts literal HTML topic to HTML\", async () => {\n        enableHtmlTopicFeature();\n        render(<div role=\"contentinfo\">{topicToHtml(\"<b>pizza</b>\", undefined, null, false)}</div>);\n        expect(getContent()).toEqual(\"&lt;b&gt;pizza&lt;/b&gt;\");\n    });\n\n    it(\"converts true HTML topic to HTML\", async () => {\n        enableHtmlTopicFeature();\n        render(<div role=\"contentinfo\">{topicToHtml(\"**pizza**\", \"<b>pizza</b>\", null, false)}</div>);\n        expect(getContent()).toEqual(\"<b>pizza</b>\");\n    });\n\n    it(\"converts true HTML topic with emoji to HTML\", async () => {\n        enableHtmlTopicFeature();\n        render(<div role=\"contentinfo\">{topicToHtml(\"**pizza** \ud83c\udf55\", \"<b>pizza</b> \ud83c\udf55\", null, false)}</div>);\n        expect(getContent()).toEqual('<b>pizza</b> <span class=\"mx_Emoji\" title=\":pizza:\">\ud83c\udf55</span>');\n    });\n});\n\ndescribe(\"bodyToHtml\", () => {\n    function getHtml(content: IContent, highlights?: string[]): string {\n        return (bodyToHtml(content, highlights, {}) as ReactElement).props.dangerouslySetInnerHTML.__html;\n    }\n\n    it(\"should apply highlights to HTML messages\", () => {\n        const html = getHtml(\n            {\n                body: \"test **foo** bar\",\n                msgtype: \"m.text\",\n                formatted_body: \"test <b>foo</b> bar\",\n                format: \"org.matrix.custom.html\",\n            },\n            [\"test\"],\n        );\n\n        expect(html).toMatchInlineSnapshot(`\"<span class=\"mx_EventTile_searchHighlight\">test</span> <b>foo</b> bar\"`);\n    });\n\n    it(\"should apply highlights to plaintext messages\", () => {\n        const html = getHtml(\n            {\n                body: \"test foo bar\",\n                msgtype: \"m.text\",\n            },\n            [\"test\"],\n        );\n\n        expect(html).toMatchInlineSnapshot(`\"<span class=\"mx_EventTile_searchHighlight\">test</span> foo bar\"`);\n    });\n\n    it(\"should not respect HTML tags in plaintext message highlighting\", () => {\n        const html = getHtml(\n            {\n                body: \"test foo <b>bar\",\n                msgtype: \"m.text\",\n            },\n            [\"test\"],\n        );\n\n        expect(html).toMatchInlineSnapshot(`\"<span class=\"mx_EventTile_searchHighlight\">test</span> foo &lt;b&gt;bar\"`);\n    });\n});\n"], "filenames": ["src/HtmlUtils.tsx", "src/components/views/rooms/SearchResultTile.tsx", "test/HtmlUtils-test.tsx"], "buggy_code_start_loc": [30, 74, 17], "buggy_code_end_loc": [578, 75, 64], "fixing_code_start_loc": [31, 74, 17], "fixing_code_end_loc": [579, 75, 110], "type": "CWE-74", "message": "matrix-react-sdk is a react-based SDK for inserting a Matrix chat/VoIP client into a web page. Prior to version 3.71.0, plain text messages containing HTML tags are rendered as HTML in the search results. To exploit this, an attacker needs to trick a user into searching for a specific message containing an HTML injection payload. No cross-site scripting attack is possible due to the hardcoded content security policy. Version 3.71.0 of the SDK patches over the issue. As a workaround, restarting the client will clear the HTML injection.", "other": {"cve": {"id": "CVE-2023-30609", "sourceIdentifier": "security-advisories@github.com", "published": "2023-04-25T21:15:10.843", "lastModified": "2023-05-08T18:05:37.577", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "matrix-react-sdk is a react-based SDK for inserting a Matrix chat/VoIP client into a web page. Prior to version 3.71.0, plain text messages containing HTML tags are rendered as HTML in the search results. To exploit this, an attacker needs to trick a user into searching for a specific message containing an HTML injection payload. No cross-site scripting attack is possible due to the hardcoded content security policy. Version 3.71.0 of the SDK patches over the issue. As a workaround, restarting the client will clear the HTML injection."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:N/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-74"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:matrix-react-sdk_project:matrix-react-sdk:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "3.71.0", "matchCriteriaId": "716CC2D8-1E07-4860-8E07-B82C055FBCF5"}]}]}], "references": [{"url": "https://github.com/matrix-org/matrix-react-sdk/commit/bf182bc94556849d7acdfa0e5fdea2aa129ea826", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/matrix-org/matrix-react-sdk/releases/tag/v3.71.0", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/matrix-org/matrix-react-sdk/security/advisories/GHSA-xv83-x443-7rmw", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/matrix-org/matrix-react-sdk/commit/bf182bc94556849d7acdfa0e5fdea2aa129ea826"}}