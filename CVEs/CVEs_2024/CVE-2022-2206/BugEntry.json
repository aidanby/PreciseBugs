{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n/*\n *\n * term.c: functions for controlling the terminal\n *\n * primitive termcap support for Amiga and Win32 included\n *\n * NOTE: padding and variable substitution is not performed,\n * when compiling without HAVE_TGETENT, we use tputs() and tgoto() dummies.\n */\n\n/*\n * Some systems have a prototype for tgetstr() with (char *) instead of\n * (char **). This define removes that prototype. We include our own prototype\n * below.\n */\n#define tgetstr tgetstr_defined_wrong\n\n#include \"vim.h\"\n\n#ifdef HAVE_TGETENT\n# ifdef HAVE_TERMIOS_H\n#  include <termios.h>\t    // seems to be required for some Linux\n# endif\n# ifdef HAVE_TERMCAP_H\n#  include <termcap.h>\n# endif\n\n/*\n * A few linux systems define outfuntype in termcap.h to be used as the third\n * argument for tputs().\n */\n# if defined(VMS) || defined(AMIGA)\n#  define TPUTSFUNCAST (void (*)(unsigned int))\n# else\n#  ifdef HAVE_OUTFUNTYPE\n#   define TPUTSFUNCAST (outfuntype)\n#  else\n#   define TPUTSFUNCAST (int (*)(int))\n#  endif\n# endif\n#endif\n\n#undef tgetstr\n\nstruct builtin_term\n{\n    int\t\tbt_entry;\n    char\t*bt_string;\n};\n\n// start of keys that are not directly used by Vim but can be mapped\n#define BT_EXTRA_KEYS\t0x101\n\nstatic void parse_builtin_tcap(char_u *s);\nstatic void gather_termleader(void);\n#ifdef FEAT_TERMRESPONSE\nstatic void req_codes_from_term(void);\nstatic void req_more_codes_from_term(void);\nstatic void got_code_from_term(char_u *code, int len);\nstatic void check_for_codes_from_term(void);\n#endif\nstatic void del_termcode_idx(int idx);\nstatic int find_term_bykeys(char_u *src);\nstatic int term_is_builtin(char_u *name);\nstatic int term_7to8bit(char_u *p);\n\n#ifdef HAVE_TGETENT\nstatic char *invoke_tgetent(char_u *, char_u *);\n\n/*\n * Here is our own prototype for tgetstr(), any prototypes from the include\n * files have been disabled by the define at the start of this file.\n */\nchar\t\t*tgetstr(char *, char **);\n\n# ifdef FEAT_TERMRESPONSE\n    // Change this to \"if 1\" to debug what happens with termresponse.\n#  if 0\n#   define DEBUG_TERMRESPONSE\nstatic void log_tr(const char *fmt, ...) ATTRIBUTE_FORMAT_PRINTF(1, 2);\n#   define LOG_TR(msg) log_tr msg\n#  else\n#   define LOG_TR(msg) do { /**/ } while (0)\n#  endif\n\ntypedef enum {\n    STATUS_GET,\t\t// send request when switching to RAW mode\n    STATUS_SENT,\t// did send request, checking for response\n    STATUS_GOT,\t\t// received response\n    STATUS_FAIL\t\t// timed out\n} request_progress_T;\n\ntypedef struct {\n    request_progress_T\t    tr_progress;\n    time_t\t\t    tr_start;\t// when request was sent, -1 for never\n} termrequest_T;\n\n#  define TERMREQUEST_INIT {STATUS_GET, -1}\n\n// Request Terminal Version status:\nstatic termrequest_T crv_status = TERMREQUEST_INIT;\n\n// Request Cursor position report:\nstatic termrequest_T u7_status = TERMREQUEST_INIT;\n\n// Request xterm compatibility check:\nstatic termrequest_T xcc_status = TERMREQUEST_INIT;\n\n#  ifdef FEAT_TERMINAL\n// Request foreground color report:\nstatic termrequest_T rfg_status = TERMREQUEST_INIT;\nstatic int fg_r = 0;\nstatic int fg_g = 0;\nstatic int fg_b = 0;\nstatic int bg_r = 255;\nstatic int bg_g = 255;\nstatic int bg_b = 255;\n#  endif\n\n// Request background color report:\nstatic termrequest_T rbg_status = TERMREQUEST_INIT;\n\n// Request cursor blinking mode report:\nstatic termrequest_T rbm_status = TERMREQUEST_INIT;\n\n// Request cursor style report:\nstatic termrequest_T rcs_status = TERMREQUEST_INIT;\n\n// Request window's position report:\nstatic termrequest_T winpos_status = TERMREQUEST_INIT;\n\nstatic termrequest_T *all_termrequests[] = {\n    &crv_status,\n    &u7_status,\n    &xcc_status,\n#  ifdef FEAT_TERMINAL\n    &rfg_status,\n#  endif\n    &rbg_status,\n    &rbm_status,\n    &rcs_status,\n    &winpos_status,\n    NULL\n};\n\n// The t_8u code may default to a value but get reset when the term response is\n// received.  To avoid redrawing too often, only redraw when t_8u is not reset\n// and it was supposed to be written.\n// FALSE -> don't output t_8u yet\n// MAYBE -> tried outputing t_8u while FALSE\n// OK    -> can write t_8u\nint write_t_8u_state = FALSE;\n# endif\n\n/*\n * Don't declare these variables if termcap.h contains them.\n * Autoconf checks if these variables should be declared extern (not all\n * systems have them).\n * Some versions define ospeed to be speed_t, but that is incompatible with\n * BSD, where ospeed is short and speed_t is long.\n */\n# ifndef HAVE_OSPEED\n#  ifdef OSPEED_EXTERN\nextern short ospeed;\n#   else\nshort ospeed;\n#   endif\n# endif\n# ifndef HAVE_UP_BC_PC\n#  ifdef UP_BC_PC_EXTERN\nextern char *UP, *BC, PC;\n#  else\nchar *UP, *BC, PC;\n#  endif\n# endif\n\n# define TGETSTR(s, p)\tvim_tgetstr((s), (p))\n# define TGETENT(b, t)\ttgetent((char *)(b), (char *)(t))\nstatic char_u *vim_tgetstr(char *s, char_u **pp);\n#endif // HAVE_TGETENT\n\nstatic int  detected_8bit = FALSE;\t// detected 8-bit terminal\n\n#if (defined(UNIX) || defined(VMS))\nstatic int focus_state = MAYBE; // TRUE if the Vim window has focus\n#endif\n\n#ifdef FEAT_TERMRESPONSE\n// When the cursor shape was detected these values are used:\n// 1: block, 2: underline, 3: vertical bar\nstatic int initial_cursor_shape = 0;\n\n// The blink flag from the style response may be inverted from the actual\n// blinking state, xterm XORs the flags.\nstatic int initial_cursor_shape_blink = FALSE;\n\n// The blink flag from the blinking-cursor mode response\nstatic int initial_cursor_blink = FALSE;\n#endif\n\n/*\n * Here are the builtin termcap entries.  They are not stored as complete\n * structures with all entries to save space.\n *\n * The entries are also included even when HAVE_TGETENT is defined, the systerm\n * termcap may be incomplee.  When HAVE_TGETENT is defined, the builtin entries\n * can be accessed with \"builtin_amiga\", \"builtin_ansi\", \"builtin_debug\", etc.\n *\n * Each termcap is a list of builtin_term structures. It always starts with\n * KS_NAME, which separates the entries.  See parse_builtin_tcap() for all\n * details.\n * bt_entry is either a KS_xxx code (>= 0), or a K_xxx code.\n *\n * Entries marked with \"guessed\" may be wrong.\n */\nstatic struct builtin_term builtin_termcaps[] =\n{\n\n#if defined(FEAT_GUI)\n/*\n * GUI pseudo term-cap.\n */\n    {(int)KS_NAME,\t\"gui\"},\n    {(int)KS_CE,\t\"\\033|$\"},\n    {(int)KS_AL,\t\"\\033|i\"},\n# ifdef TERMINFO\n    {(int)KS_CAL,\t\"\\033|%p1%dI\"},\n# else\n    {(int)KS_CAL,\t\"\\033|%dI\"},\n# endif\n    {(int)KS_DL,\t\"\\033|d\"},\n# ifdef TERMINFO\n    {(int)KS_CDL,\t\"\\033|%p1%dD\"},\n    {(int)KS_CS,\t\"\\033|%p1%d;%p2%dR\"},\n    {(int)KS_CSV,\t\"\\033|%p1%d;%p2%dV\"},\n# else\n    {(int)KS_CDL,\t\"\\033|%dD\"},\n    {(int)KS_CS,\t\"\\033|%d;%dR\"},\n    {(int)KS_CSV,\t\"\\033|%d;%dV\"},\n# endif\n    {(int)KS_CL,\t\"\\033|C\"},\n\t\t\t// attributes switched on with 'h', off with * 'H'\n    {(int)KS_ME,\t\"\\033|31H\"}, // HL_ALL\n    {(int)KS_MR,\t\"\\033|1h\"},   // HL_INVERSE\n    {(int)KS_MD,\t\"\\033|2h\"},   // HL_BOLD\n    {(int)KS_SE,\t\"\\033|16H\"}, // HL_STANDOUT\n    {(int)KS_SO,\t\"\\033|16h\"}, // HL_STANDOUT\n    {(int)KS_UE,\t\"\\033|8H\"},   // HL_UNDERLINE\n    {(int)KS_US,\t\"\\033|8h\"},   // HL_UNDERLINE\n    {(int)KS_UCE,\t\"\\033|8C\"},   // HL_UNDERCURL\n    {(int)KS_UCS,\t\"\\033|8c\"},   // HL_UNDERCURL\n    {(int)KS_STE,\t\"\\033|4C\"},   // HL_STRIKETHROUGH\n    {(int)KS_STS,\t\"\\033|4c\"},   // HL_STRIKETHROUGH\n    {(int)KS_CZR,\t\"\\033|4H\"},   // HL_ITALIC\n    {(int)KS_CZH,\t\"\\033|4h\"},   // HL_ITALIC\n    {(int)KS_VB,\t\"\\033|f\"},\n    {(int)KS_MS,\t\"y\"},\n    {(int)KS_UT,\t\"y\"},\n    {(int)KS_XN,\t\"y\"},\n    {(int)KS_LE,\t\"\\b\"},\t\t// cursor-left = BS\n    {(int)KS_ND,\t\"\\014\"},\t// cursor-right = CTRL-L\n# ifdef TERMINFO\n    {(int)KS_CM,\t\"\\033|%p1%d;%p2%dM\"},\n# else\n    {(int)KS_CM,\t\"\\033|%d;%dM\"},\n# endif\n\t// there are no key sequences here, the GUI sequences are recognized\n\t// in check_termcode()\n#endif\n\n#ifndef NO_BUILTIN_TCAPS\n\n# if defined(AMIGA) || defined(ALL_BUILTIN_TCAPS)\n/*\n * Amiga console window, default for Amiga\n */\n    {(int)KS_NAME,\t\"amiga\"},\n    {(int)KS_CE,\t\"\\033[K\"},\n    {(int)KS_CD,\t\"\\033[J\"},\n    {(int)KS_AL,\t\"\\033[L\"},\n#  ifdef TERMINFO\n    {(int)KS_CAL,\t\"\\033[%p1%dL\"},\n#  else\n    {(int)KS_CAL,\t\"\\033[%dL\"},\n#  endif\n    {(int)KS_DL,\t\"\\033[M\"},\n#  ifdef TERMINFO\n    {(int)KS_CDL,\t\"\\033[%p1%dM\"},\n#  else\n    {(int)KS_CDL,\t\"\\033[%dM\"},\n#  endif\n    {(int)KS_CL,\t\"\\014\"},\n    {(int)KS_VI,\t\"\\033[0 p\"},\n    {(int)KS_VE,\t\"\\033[1 p\"},\n    {(int)KS_ME,\t\"\\033[0m\"},\n    {(int)KS_MR,\t\"\\033[7m\"},\n    {(int)KS_MD,\t\"\\033[1m\"},\n    {(int)KS_SE,\t\"\\033[0m\"},\n    {(int)KS_SO,\t\"\\033[33m\"},\n    {(int)KS_US,\t\"\\033[4m\"},\n    {(int)KS_UE,\t\"\\033[0m\"},\n    {(int)KS_CZH,\t\"\\033[3m\"},\n    {(int)KS_CZR,\t\"\\033[0m\"},\n#if defined(__amigaos4__) || defined(__MORPHOS__) || defined(__AROS__)\n    {(int)KS_CCO,\t\"8\"},\t\t// allow 8 colors\n#  ifdef TERMINFO\n    {(int)KS_CAB,\t\"\\033[4%p1%dm\"},// set background color\n    {(int)KS_CAF,\t\"\\033[3%p1%dm\"},// set foreground color\n#  else\n    {(int)KS_CAB,\t\"\\033[4%dm\"},\t// set background color\n    {(int)KS_CAF,\t\"\\033[3%dm\"},\t// set foreground color\n#  endif\n    {(int)KS_OP,\t\"\\033[m\"},\t// reset colors\n#endif\n    {(int)KS_MS,\t\"y\"},\n    {(int)KS_UT,\t\"y\"},\t\t// guessed\n    {(int)KS_LE,\t\"\\b\"},\n#  ifdef TERMINFO\n    {(int)KS_CM,\t\"\\033[%i%p1%d;%p2%dH\"},\n#  else\n    {(int)KS_CM,\t\"\\033[%i%d;%dH\"},\n#  endif\n#if defined(__MORPHOS__)\n    {(int)KS_SR,\t\"\\033M\"},\n#endif\n#  ifdef TERMINFO\n    {(int)KS_CRI,\t\"\\033[%p1%dC\"},\n#  else\n    {(int)KS_CRI,\t\"\\033[%dC\"},\n#  endif\n    {K_UP,\t\t\"\\233A\"},\n    {K_DOWN,\t\t\"\\233B\"},\n    {K_LEFT,\t\t\"\\233D\"},\n    {K_RIGHT,\t\t\"\\233C\"},\n    {K_S_UP,\t\t\"\\233T\"},\n    {K_S_DOWN,\t\t\"\\233S\"},\n    {K_S_LEFT,\t\t\"\\233 A\"},\n    {K_S_RIGHT,\t\t\"\\233 @\"},\n    {K_S_TAB,\t\t\"\\233Z\"},\n    {K_F1,\t\t\"\\233\\060~\"},// some compilers don't dig \"\\2330\"\n    {K_F2,\t\t\"\\233\\061~\"},\n    {K_F3,\t\t\"\\233\\062~\"},\n    {K_F4,\t\t\"\\233\\063~\"},\n    {K_F5,\t\t\"\\233\\064~\"},\n    {K_F6,\t\t\"\\233\\065~\"},\n    {K_F7,\t\t\"\\233\\066~\"},\n    {K_F8,\t\t\"\\233\\067~\"},\n    {K_F9,\t\t\"\\233\\070~\"},\n    {K_F10,\t\t\"\\233\\071~\"},\n    {K_S_F1,\t\t\"\\233\\061\\060~\"},\n    {K_S_F2,\t\t\"\\233\\061\\061~\"},\n    {K_S_F3,\t\t\"\\233\\061\\062~\"},\n    {K_S_F4,\t\t\"\\233\\061\\063~\"},\n    {K_S_F5,\t\t\"\\233\\061\\064~\"},\n    {K_S_F6,\t\t\"\\233\\061\\065~\"},\n    {K_S_F7,\t\t\"\\233\\061\\066~\"},\n    {K_S_F8,\t\t\"\\233\\061\\067~\"},\n    {K_S_F9,\t\t\"\\233\\061\\070~\"},\n    {K_S_F10,\t\t\"\\233\\061\\071~\"},\n    {K_HELP,\t\t\"\\233?~\"},\n    {K_INS,\t\t\"\\233\\064\\060~\"},\t// 101 key keyboard\n    {K_PAGEUP,\t\t\"\\233\\064\\061~\"},\t// 101 key keyboard\n    {K_PAGEDOWN,\t\"\\233\\064\\062~\"},\t// 101 key keyboard\n    {K_HOME,\t\t\"\\233\\064\\064~\"},\t// 101 key keyboard\n    {K_END,\t\t\"\\233\\064\\065~\"},\t// 101 key keyboard\n\n    {BT_EXTRA_KEYS,\t\"\"},\n    {TERMCAP2KEY('#', '2'), \"\\233\\065\\064~\"},\t// shifted home key\n    {TERMCAP2KEY('#', '3'), \"\\233\\065\\060~\"},\t// shifted insert key\n    {TERMCAP2KEY('*', '7'), \"\\233\\065\\065~\"},\t// shifted end key\n# endif\n\n# ifdef ALL_BUILTIN_TCAPS\n/*\n * almost standard ANSI terminal\n */\n    {(int)KS_CE,\t\"\\033[K\"},\n    {(int)KS_CD,\t\"\\033[J\"},\n    {(int)KS_AL,\t\"\\033[L\"},\n#  ifdef TERMINFO\n    {(int)KS_CAL,\t\"\\033[%p1%dL\"},\n#  else\n    {(int)KS_CAL,\t\"\\033[%dL\"},\n#  endif\n    {(int)KS_DL,\t\"\\033[M\"},\n#  ifdef TERMINFO\n    {(int)KS_CDL,\t\"\\033[%p1%dM\"},\n#  else\n    {(int)KS_CDL,\t\"\\033[%dM\"},\n#  endif\n    {(int)KS_CL,\t\"\\033[H\\033[2J\"},\n#ifdef notyet\n    {(int)KS_VI,\t\"[VI]\"}, // cursor invisible, VT320: CSI ? 25 l\n    {(int)KS_VE,\t\"[VE]\"}, // cursor visible, VT320: CSI ? 25 h\n#endif\n    {(int)KS_ME,\t\"\\033[m\"},\t// normal mode\n    {(int)KS_MR,\t\"\\033[7m\"},\t// reverse\n    {(int)KS_MD,\t\"\\033[1m\"},\t// bold\n    {(int)KS_SO,\t\"\\033[31m\"},\t// standout mode: red\n    {(int)KS_SE,\t\"\\033[m\"},\t// standout end\n    {(int)KS_CZH,\t\"\\033[35m\"},\t// italic: purple\n    {(int)KS_CZR,\t\"\\033[m\"},\t// italic end\n    {(int)KS_US,\t\"\\033[4m\"},\t// underscore mode\n    {(int)KS_UE,\t\"\\033[m\"},\t// underscore end\n    {(int)KS_CCO,\t\"8\"},\t\t// allow 8 colors\n#  ifdef TERMINFO\n    {(int)KS_CAB,\t\"\\033[4%p1%dm\"},// set background color\n    {(int)KS_CAF,\t\"\\033[3%p1%dm\"},// set foreground color\n#  else\n    {(int)KS_CAB,\t\"\\033[4%dm\"},\t// set background color\n    {(int)KS_CAF,\t\"\\033[3%dm\"},\t// set foreground color\n#  endif\n    {(int)KS_OP,\t\"\\033[m\"},\t// reset colors\n    {(int)KS_MS,\t\"y\"},\t\t// safe to move cur in reverse mode\n    {(int)KS_UT,\t\"y\"},\t\t// guessed\n    {(int)KS_LE,\t\"\\b\"},\n#  ifdef TERMINFO\n    {(int)KS_CM,\t\"\\033[%i%p1%d;%p2%dH\"},\n#  else\n    {(int)KS_CM,\t\"\\033[%i%d;%dH\"},\n#  endif\n    {(int)KS_SR,\t\"\\033M\"},\n#  ifdef TERMINFO\n    {(int)KS_CRI,\t\"\\033[%p1%dC\"},\n#  else\n    {(int)KS_CRI,\t\"\\033[%dC\"},\n#  endif\n\n    {K_UP,\t\t\"\\033[A\"},\n    {K_DOWN,\t\t\"\\033[B\"},\n    {K_LEFT,\t\t\"\\033[D\"},\n    {K_RIGHT,\t\t\"\\033[C\"},\n# endif\n\n# if defined(UNIX) || defined(ALL_BUILTIN_TCAPS) || defined(SOME_BUILTIN_TCAPS)\n/*\n * standard ANSI terminal, default for unix\n */\n    {(int)KS_NAME,\t\"ansi\"},\n    {(int)KS_CE,\t\"\\033[K\"},\n    {(int)KS_AL,\t\"\\033[L\"},\n#  ifdef TERMINFO\n    {(int)KS_CAL,\t\"\\033[%p1%dL\"},\n#  else\n    {(int)KS_CAL,\t\"\\033[%dL\"},\n#  endif\n    {(int)KS_DL,\t\"\\033[M\"},\n#  ifdef TERMINFO\n    {(int)KS_CDL,\t\"\\033[%p1%dM\"},\n#  else\n    {(int)KS_CDL,\t\"\\033[%dM\"},\n#  endif\n    {(int)KS_CL,\t\"\\033[H\\033[2J\"},\n    {(int)KS_ME,\t\"\\033[0m\"},\n    {(int)KS_MR,\t\"\\033[7m\"},\n    {(int)KS_MS,\t\"y\"},\n    {(int)KS_UT,\t\"y\"},\t\t// guessed\n    {(int)KS_LE,\t\"\\b\"},\n#  ifdef TERMINFO\n    {(int)KS_CM,\t\"\\033[%i%p1%d;%p2%dH\"},\n#  else\n    {(int)KS_CM,\t\"\\033[%i%d;%dH\"},\n#  endif\n#  ifdef TERMINFO\n    {(int)KS_CRI,\t\"\\033[%p1%dC\"},\n#  else\n    {(int)KS_CRI,\t\"\\033[%dC\"},\n#  endif\n# endif\n\n# if defined(ALL_BUILTIN_TCAPS)\n/*\n * These codes are valid when nansi.sys or equivalent has been installed.\n * Function keys on a PC are preceded with a NUL. These are converted into\n * K_NUL '\\316' in mch_inchar(), because we cannot handle NULs in key codes.\n * CTRL-arrow is used instead of SHIFT-arrow.\n */\n    {(int)KS_NAME,\t\"pcansi\"},\n    {(int)KS_DL,\t\"\\033[M\"},\n    {(int)KS_AL,\t\"\\033[L\"},\n    {(int)KS_CE,\t\"\\033[K\"},\n    {(int)KS_CL,\t\"\\033[2J\"},\n    {(int)KS_ME,\t\"\\033[0m\"},\n    {(int)KS_MR,\t\"\\033[5m\"},\t// reverse: black on lightgrey\n    {(int)KS_MD,\t\"\\033[1m\"},\t// bold: white text\n    {(int)KS_SE,\t\"\\033[0m\"},\t// standout end\n    {(int)KS_SO,\t\"\\033[31m\"},\t// standout: white on blue\n    {(int)KS_CZH,\t\"\\033[34;43m\"},\t// italic mode: blue text on yellow\n    {(int)KS_CZR,\t\"\\033[0m\"},\t// italic mode end\n    {(int)KS_US,\t\"\\033[36;41m\"},\t// underscore mode: cyan text on red\n    {(int)KS_UE,\t\"\\033[0m\"},\t// underscore mode end\n    {(int)KS_CCO,\t\"8\"},\t\t// allow 8 colors\n#  ifdef TERMINFO\n    {(int)KS_CAB,\t\"\\033[4%p1%dm\"},// set background color\n    {(int)KS_CAF,\t\"\\033[3%p1%dm\"},// set foreground color\n#  else\n    {(int)KS_CAB,\t\"\\033[4%dm\"},\t// set background color\n    {(int)KS_CAF,\t\"\\033[3%dm\"},\t// set foreground color\n#  endif\n    {(int)KS_OP,\t\"\\033[0m\"},\t// reset colors\n    {(int)KS_MS,\t\"y\"},\n    {(int)KS_UT,\t\"y\"},\t\t// guessed\n    {(int)KS_LE,\t\"\\b\"},\n#  ifdef TERMINFO\n    {(int)KS_CM,\t\"\\033[%i%p1%d;%p2%dH\"},\n#  else\n    {(int)KS_CM,\t\"\\033[%i%d;%dH\"},\n#  endif\n#  ifdef TERMINFO\n    {(int)KS_CRI,\t\"\\033[%p1%dC\"},\n#  else\n    {(int)KS_CRI,\t\"\\033[%dC\"},\n#  endif\n    {K_UP,\t\t\"\\316H\"},\n    {K_DOWN,\t\t\"\\316P\"},\n    {K_LEFT,\t\t\"\\316K\"},\n    {K_RIGHT,\t\t\"\\316M\"},\n    {K_S_LEFT,\t\t\"\\316s\"},\n    {K_S_RIGHT,\t\t\"\\316t\"},\n    {K_F1,\t\t\"\\316;\"},\n    {K_F2,\t\t\"\\316<\"},\n    {K_F3,\t\t\"\\316=\"},\n    {K_F4,\t\t\"\\316>\"},\n    {K_F5,\t\t\"\\316?\"},\n    {K_F6,\t\t\"\\316@\"},\n    {K_F7,\t\t\"\\316A\"},\n    {K_F8,\t\t\"\\316B\"},\n    {K_F9,\t\t\"\\316C\"},\n    {K_F10,\t\t\"\\316D\"},\n    {K_F11,\t\t\"\\316\\205\"},\t// guessed\n    {K_F12,\t\t\"\\316\\206\"},\t// guessed\n    {K_S_F1,\t\t\"\\316T\"},\n    {K_S_F2,\t\t\"\\316U\"},\n    {K_S_F3,\t\t\"\\316V\"},\n    {K_S_F4,\t\t\"\\316W\"},\n    {K_S_F5,\t\t\"\\316X\"},\n    {K_S_F6,\t\t\"\\316Y\"},\n    {K_S_F7,\t\t\"\\316Z\"},\n    {K_S_F8,\t\t\"\\316[\"},\n    {K_S_F9,\t\t\"\\316\\\\\"},\n    {K_S_F10,\t\t\"\\316]\"},\n    {K_S_F11,\t\t\"\\316\\207\"},\t// guessed\n    {K_S_F12,\t\t\"\\316\\210\"},\t// guessed\n    {K_INS,\t\t\"\\316R\"},\n    {K_DEL,\t\t\"\\316S\"},\n    {K_HOME,\t\t\"\\316G\"},\n    {K_END,\t\t\"\\316O\"},\n    {K_PAGEDOWN,\t\"\\316Q\"},\n    {K_PAGEUP,\t\t\"\\316I\"},\n# endif\n\n# if defined(MSWIN) || defined(ALL_BUILTIN_TCAPS)\n/*\n * These codes are valid for the Win32 Console .  The entries that start with\n * ESC | are translated into console calls in os_win32.c.  The function keys\n * are also translated in os_win32.c.\n */\n    {(int)KS_NAME,\t\"win32\"},\n    {(int)KS_CE,\t\"\\033|K\"},\t// clear to end of line\n    {(int)KS_AL,\t\"\\033|L\"},\t// add new blank line\n#  ifdef TERMINFO\n    {(int)KS_CAL,\t\"\\033|%p1%dL\"},\t// add number of new blank lines\n#  else\n    {(int)KS_CAL,\t\"\\033|%dL\"},\t// add number of new blank lines\n#  endif\n    {(int)KS_DL,\t\"\\033|M\"},\t// delete line\n#  ifdef TERMINFO\n    {(int)KS_CDL,\t\"\\033|%p1%dM\"},\t// delete number of lines\n    {(int)KS_CSV,\t\"\\033|%p1%d;%p2%dV\"},\n#  else\n    {(int)KS_CDL,\t\"\\033|%dM\"},\t// delete number of lines\n    {(int)KS_CSV,\t\"\\033|%d;%dV\"},\n#  endif\n    {(int)KS_CL,\t\"\\033|J\"},\t// clear screen\n    {(int)KS_CD,\t\"\\033|j\"},\t// clear to end of display\n    {(int)KS_VI,\t\"\\033|v\"},\t// cursor invisible\n    {(int)KS_VE,\t\"\\033|V\"},\t// cursor visible\n\n    {(int)KS_ME,\t\"\\033|0m\"},\t// normal\n    {(int)KS_MR,\t\"\\033|112m\"},\t// reverse: black on lightgray\n    {(int)KS_MD,\t\"\\033|15m\"},\t// bold: white on black\n#if 1\n    {(int)KS_SO,\t\"\\033|31m\"},\t// standout: white on blue\n    {(int)KS_SE,\t\"\\033|0m\"},\t// standout end\n#else\n    {(int)KS_SO,\t\"\\033|F\"},\t// standout: high intensity\n    {(int)KS_SE,\t\"\\033|f\"},\t// standout end\n#endif\n    {(int)KS_CZH,\t\"\\033|225m\"},\t// italic: blue text on yellow\n    {(int)KS_CZR,\t\"\\033|0m\"},\t// italic end\n    {(int)KS_US,\t\"\\033|67m\"},\t// underscore: cyan text on red\n    {(int)KS_UE,\t\"\\033|0m\"},\t// underscore end\n    {(int)KS_CCO,\t\"16\"},\t\t// allow 16 colors\n#  ifdef TERMINFO\n    {(int)KS_CAB,\t\"\\033|%p1%db\"},\t// set background color\n    {(int)KS_CAF,\t\"\\033|%p1%df\"},\t// set foreground color\n#  else\n    {(int)KS_CAB,\t\"\\033|%db\"},\t// set background color\n    {(int)KS_CAF,\t\"\\033|%df\"},\t// set foreground color\n#  endif\n\n    {(int)KS_MS,\t\"y\"},\t\t// save to move cur in reverse mode\n    {(int)KS_UT,\t\"y\"},\n    {(int)KS_XN,\t\"y\"},\n    {(int)KS_LE,\t\"\\b\"},\n#  ifdef TERMINFO\n    {(int)KS_CM,\t\"\\033|%i%p1%d;%p2%dH\"}, // cursor motion\n#  else\n    {(int)KS_CM,\t\"\\033|%i%d;%dH\"}, // cursor motion\n#  endif\n    {(int)KS_VB,\t\"\\033|B\"},\t// visual bell\n    {(int)KS_TI,\t\"\\033|S\"},\t// put terminal in termcap mode\n    {(int)KS_TE,\t\"\\033|E\"},\t// out of termcap mode\n#  ifdef TERMINFO\n    {(int)KS_CS,\t\"\\033|%i%p1%d;%p2%dr\"}, // scroll region\n#  else\n    {(int)KS_CS,\t\"\\033|%i%d;%dr\"}, // scroll region\n#  endif\n#  ifdef FEAT_TERMGUICOLORS\n    {(int)KS_8F,\t\"\\033|38;2;%lu;%lu;%lum\"},\n    {(int)KS_8B,\t\"\\033|48;2;%lu;%lu;%lum\"},\n#  endif\n\n    {K_UP,\t\t\"\\316H\"},\n    {K_DOWN,\t\t\"\\316P\"},\n    {K_LEFT,\t\t\"\\316K\"},\n    {K_RIGHT,\t\t\"\\316M\"},\n    {K_S_UP,\t\t\"\\316\\304\"},\n    {K_S_DOWN,\t\t\"\\316\\317\"},\n    {K_S_LEFT,\t\t\"\\316\\311\"},\n    {K_C_LEFT,\t\t\"\\316s\"},\n    {K_S_RIGHT,\t\t\"\\316\\313\"},\n    {K_C_RIGHT,\t\t\"\\316t\"},\n    {K_S_TAB,\t\t\"\\316\\017\"},\n    {K_F1,\t\t\"\\316;\"},\n    {K_F2,\t\t\"\\316<\"},\n    {K_F3,\t\t\"\\316=\"},\n    {K_F4,\t\t\"\\316>\"},\n    {K_F5,\t\t\"\\316?\"},\n    {K_F6,\t\t\"\\316@\"},\n    {K_F7,\t\t\"\\316A\"},\n    {K_F8,\t\t\"\\316B\"},\n    {K_F9,\t\t\"\\316C\"},\n    {K_F10,\t\t\"\\316D\"},\n    {K_F11,\t\t\"\\316\\205\"},\n    {K_F12,\t\t\"\\316\\206\"},\n    {K_S_F1,\t\t\"\\316T\"},\n    {K_S_F2,\t\t\"\\316U\"},\n    {K_S_F3,\t\t\"\\316V\"},\n    {K_S_F4,\t\t\"\\316W\"},\n    {K_S_F5,\t\t\"\\316X\"},\n    {K_S_F6,\t\t\"\\316Y\"},\n    {K_S_F7,\t\t\"\\316Z\"},\n    {K_S_F8,\t\t\"\\316[\"},\n    {K_S_F9,\t\t\"\\316\\\\\"},\n    {K_S_F10,\t\t\"\\316]\"},\n    {K_S_F11,\t\t\"\\316\\207\"},\n    {K_S_F12,\t\t\"\\316\\210\"},\n    {K_INS,\t\t\"\\316R\"},\n    {K_DEL,\t\t\"\\316S\"},\n    {K_HOME,\t\t\"\\316G\"},\n    {K_S_HOME,\t\t\"\\316\\302\"},\n    {K_C_HOME,\t\t\"\\316w\"},\n    {K_END,\t\t\"\\316O\"},\n    {K_S_END,\t\t\"\\316\\315\"},\n    {K_C_END,\t\t\"\\316u\"},\n    {K_PAGEDOWN,\t\"\\316Q\"},\n    {K_PAGEUP,\t\t\"\\316I\"},\n    {K_KPLUS,\t\t\"\\316N\"},\n    {K_KMINUS,\t\t\"\\316J\"},\n    {K_KMULTIPLY,\t\"\\316\\067\"},\n    {K_K0,\t\t\"\\316\\332\"},\n    {K_K1,\t\t\"\\316\\336\"},\n    {K_K2,\t\t\"\\316\\342\"},\n    {K_K3,\t\t\"\\316\\346\"},\n    {K_K4,\t\t\"\\316\\352\"},\n    {K_K5,\t\t\"\\316\\356\"},\n    {K_K6,\t\t\"\\316\\362\"},\n    {K_K7,\t\t\"\\316\\366\"},\n    {K_K8,\t\t\"\\316\\372\"},\n    {K_K9,\t\t\"\\316\\376\"},\n    {K_BS,\t\t\"\\316x\"},\n    {K_S_BS,\t\t\"\\316y\"},\n# endif\n\n# if defined(VMS) || defined(ALL_BUILTIN_TCAPS)\n/*\n * VT320 is working as an ANSI terminal compatible DEC terminal.\n * (it covers VT1x0, VT2x0 and VT3x0 up to VT320 on VMS as well)\n * TODO:- rewrite ESC[ codes to CSI\n *      - keyboard languages (CSI ? 26 n)\n */\n    {(int)KS_NAME,\t\"vt320\"},\n    {(int)KS_CE,\t\"\\033[K\"},\n    {(int)KS_AL,\t\"\\033[L\"},\n#  ifdef TERMINFO\n    {(int)KS_CAL,\t\"\\033[%p1%dL\"},\n#  else\n    {(int)KS_CAL,\t\"\\033[%dL\"},\n#  endif\n    {(int)KS_DL,\t\"\\033[M\"},\n#  ifdef TERMINFO\n    {(int)KS_CDL,\t\"\\033[%p1%dM\"},\n#  else\n    {(int)KS_CDL,\t\"\\033[%dM\"},\n#  endif\n    {(int)KS_CL,\t\"\\033[H\\033[2J\"},\n    {(int)KS_CD,\t\"\\033[J\"},\n    {(int)KS_CCO,\t\"8\"},\t\t\t// allow 8 colors\n    {(int)KS_ME,\t\"\\033[0m\"},\n    {(int)KS_MR,\t\"\\033[7m\"},\n    {(int)KS_MD,\t\"\\033[1m\"},  // bold mode\n    {(int)KS_SE,\t\"\\033[22m\"},// normal mode\n    {(int)KS_UE,\t\"\\033[24m\"},// exit underscore mode\n    {(int)KS_US,\t\"\\033[4m\"},  // underscore mode\n    {(int)KS_CZH,\t\"\\033[34;43m\"},  // italic mode: blue text on yellow\n    {(int)KS_CZR,\t\"\\033[0m\"},\t    // italic mode end\n    {(int)KS_CAB,\t\"\\033[4%dm\"},\t    // set background color (ANSI)\n    {(int)KS_CAF,\t\"\\033[3%dm\"},\t    // set foreground color (ANSI)\n    {(int)KS_CSB,\t\"\\033[102;%dm\"},\t// set screen background color\n    {(int)KS_CSF,\t\"\\033[101;%dm\"},\t// set screen foreground color\n    {(int)KS_MS,\t\"y\"},\n    {(int)KS_UT,\t\"y\"},\n    {(int)KS_XN,\t\"y\"},\n    {(int)KS_LE,\t\"\\b\"},\n#  ifdef TERMINFO\n    {(int)KS_CM,\t\"\\033[%i%p1%d;%p2%dH\"},\n#  else\n    {(int)KS_CM,\t\"\\033[%i%d;%dH\"},\n#  endif\n#  ifdef TERMINFO\n    {(int)KS_CRI,\t\"\\033[%p1%dC\"},\n#  else\n    {(int)KS_CRI,\t\"\\033[%dC\"},\n#  endif\n    {K_UP,\t\t\"\\033[A\"},\n    {K_DOWN,\t\t\"\\033[B\"},\n    {K_RIGHT,\t\t\"\\033[C\"},\n    {K_LEFT,\t\t\"\\033[D\"},\n    // Note: cursor key sequences for application cursor mode are omitted,\n    // because they interfere with typed commands: <Esc>OA.\n    {K_F1,\t\t\"\\033[11~\"},\n    {K_F2,\t\t\"\\033[12~\"},\n    {K_F3,\t\t\"\\033[13~\"},\n    {K_F4,\t\t\"\\033[14~\"},\n    {K_F5,\t\t\"\\033[15~\"},\n    {K_F6,\t\t\"\\033[17~\"},\n    {K_F7,\t\t\"\\033[18~\"},\n    {K_F8,\t\t\"\\033[19~\"},\n    {K_F9,\t\t\"\\033[20~\"},\n    {K_F10,\t\t\"\\033[21~\"},\n    {K_F11,\t\t\"\\033[23~\"},\n    {K_F12,\t\t\"\\033[24~\"},\n    {K_F13,\t\t\"\\033[25~\"},\n    {K_F14,\t\t\"\\033[26~\"},\n    {K_F15,\t\t\"\\033[28~\"},\t// Help\n    {K_F16,\t\t\"\\033[29~\"},\t// Select\n    {K_F17,\t\t\"\\033[31~\"},\n    {K_F18,\t\t\"\\033[32~\"},\n    {K_F19,\t\t\"\\033[33~\"},\n    {K_F20,\t\t\"\\033[34~\"},\n    {K_INS,\t\t\"\\033[2~\"},\n    {K_DEL,\t\t\"\\033[3~\"},\n    {K_HOME,\t\t\"\\033[1~\"},\n    {K_END,\t\t\"\\033[4~\"},\n    {K_PAGEUP,\t\t\"\\033[5~\"},\n    {K_PAGEDOWN,\t\"\\033[6~\"},\n    // These sequences starting with <Esc> O may interfere with what the user\n    // is typing.  Remove these if that bothers you.\n    {K_KPLUS,\t\t\"\\033Ok\"},\t// keypad plus\n    {K_KMINUS,\t\t\"\\033Om\"},\t// keypad minus\n    {K_KDIVIDE,\t\t\"\\033Oo\"},\t// keypad /\n    {K_KMULTIPLY,\t\"\\033Oj\"},\t// keypad *\n    {K_KENTER,\t\t\"\\033OM\"},\t// keypad Enter\n    {K_K0,\t\t\"\\033Op\"},\t// keypad 0\n    {K_K1,\t\t\"\\033Oq\"},\t// keypad 1\n    {K_K2,\t\t\"\\033Or\"},\t// keypad 2\n    {K_K3,\t\t\"\\033Os\"},\t// keypad 3\n    {K_K4,\t\t\"\\033Ot\"},\t// keypad 4\n    {K_K5,\t\t\"\\033Ou\"},\t// keypad 5\n    {K_K6,\t\t\"\\033Ov\"},\t// keypad 6\n    {K_K7,\t\t\"\\033Ow\"},\t// keypad 7\n    {K_K8,\t\t\"\\033Ox\"},\t// keypad 8\n    {K_K9,\t\t\"\\033Oy\"},\t// keypad 9\n    {K_BS,\t\t\"\\x7f\"},\t// for some reason 0177 doesn't work\n# endif\n\n# if defined(ALL_BUILTIN_TCAPS)\n/*\n * Ordinary vt52\n */\n    {(int)KS_NAME,\t\"vt52\"},\n    {(int)KS_CE,\t\"\\033K\"},\n    {(int)KS_CD,\t\"\\033J\"},\n#  ifdef TERMINFO\n    {(int)KS_CM,\t\"\\033Y%p1%' '%+%c%p2%' '%+%c\"},\n#  else\n    {(int)KS_CM,\t\"\\033Y%+ %+ \"},\n#  endif\n    {(int)KS_LE,\t\"\\b\"},\n    {(int)KS_SR,\t\"\\033I\"},\n    {(int)KS_AL,\t\"\\033L\"},\n    {(int)KS_DL,\t\"\\033M\"},\n    {K_UP,\t\t\"\\033A\"},\n    {K_DOWN,\t\t\"\\033B\"},\n    {K_LEFT,\t\t\"\\033D\"},\n    {K_RIGHT,\t\t\"\\033C\"},\n    {K_F1,\t\t\"\\033P\"},\n    {K_F2,\t\t\"\\033Q\"},\n    {K_F3,\t\t\"\\033R\"},\n    {(int)KS_CL,\t\"\\033H\\033J\"},\n    {(int)KS_MS,\t\"y\"},\n# endif\n\n# if defined(UNIX) || defined(ALL_BUILTIN_TCAPS) || defined(SOME_BUILTIN_TCAPS)\n    {(int)KS_NAME,\t\"xterm\"},\n    {(int)KS_CE,\t\"\\033[K\"},\n    {(int)KS_AL,\t\"\\033[L\"},\n#  ifdef TERMINFO\n    {(int)KS_CAL,\t\"\\033[%p1%dL\"},\n#  else\n    {(int)KS_CAL,\t\"\\033[%dL\"},\n#  endif\n    {(int)KS_DL,\t\"\\033[M\"},\n#  ifdef TERMINFO\n    {(int)KS_CDL,\t\"\\033[%p1%dM\"},\n#  else\n    {(int)KS_CDL,\t\"\\033[%dM\"},\n#  endif\n#  ifdef TERMINFO\n    {(int)KS_CS,\t\"\\033[%i%p1%d;%p2%dr\"},\n#  else\n    {(int)KS_CS,\t\"\\033[%i%d;%dr\"},\n#  endif\n    {(int)KS_CL,\t\"\\033[H\\033[2J\"},\n    {(int)KS_CD,\t\"\\033[J\"},\n    {(int)KS_ME,\t\"\\033[m\"},\n    {(int)KS_MR,\t\"\\033[7m\"},\n    {(int)KS_MD,\t\"\\033[1m\"},\n    {(int)KS_UE,\t\"\\033[m\"},\n    {(int)KS_US,\t\"\\033[4m\"},\n    {(int)KS_STE,\t\"\\033[29m\"},\n    {(int)KS_STS,\t\"\\033[9m\"},\n    {(int)KS_MS,\t\"y\"},\n    {(int)KS_UT,\t\"y\"},\n    {(int)KS_LE,\t\"\\b\"},\n    {(int)KS_VI,\t\"\\033[?25l\"},\n    {(int)KS_VE,\t\"\\033[?25h\"},\n    {(int)KS_VS,\t\"\\033[?12h\"},\n    {(int)KS_CVS,\t\"\\033[?12l\"},\n#  ifdef TERMINFO\n    {(int)KS_CSH,\t\"\\033[%p1%d q\"},\n#  else\n    {(int)KS_CSH,\t\"\\033[%d q\"},\n#  endif\n    {(int)KS_CRC,\t\"\\033[?12$p\"},\n    {(int)KS_CRS,\t\"\\033P$q q\\033\\\\\"},\n#  ifdef TERMINFO\n    {(int)KS_CM,\t\"\\033[%i%p1%d;%p2%dH\"},\n#  else\n    {(int)KS_CM,\t\"\\033[%i%d;%dH\"},\n#  endif\n    {(int)KS_SR,\t\"\\033M\"},\n#  ifdef TERMINFO\n    {(int)KS_CRI,\t\"\\033[%p1%dC\"},\n#  else\n    {(int)KS_CRI,\t\"\\033[%dC\"},\n#  endif\n    {(int)KS_KS,\t\"\\033[?1h\\033=\"},\n    {(int)KS_KE,\t\"\\033[?1l\\033>\"},\n#  ifdef FEAT_XTERM_SAVE\n    {(int)KS_TI,\t\"\\0337\\033[?47h\"},\n    {(int)KS_TE,\t\"\\033[?47l\\0338\"},\n#  endif\n    {(int)KS_CTI,\t\"\\033[>4;2m\"},\n    {(int)KS_CTE,\t\"\\033[>4;m\"},\n    {(int)KS_CIS,\t\"\\033]1;\"},\n    {(int)KS_CIE,\t\"\\007\"},\n    {(int)KS_TS,\t\"\\033]2;\"},\n    {(int)KS_FS,\t\"\\007\"},\n    {(int)KS_CSC,\t\"\\033]12;\"},\n    {(int)KS_CEC,\t\"\\007\"},\n#  ifdef TERMINFO\n    {(int)KS_CWS,\t\"\\033[8;%p1%d;%p2%dt\"},\n    {(int)KS_CWP,\t\"\\033[3;%p1%d;%p2%dt\"},\n    {(int)KS_CGP,\t\"\\033[13t\"},\n#  else\n    {(int)KS_CWS,\t\"\\033[8;%d;%dt\"},\n    {(int)KS_CWP,\t\"\\033[3;%d;%dt\"},\n    {(int)KS_CGP,\t\"\\033[13t\"},\n#  endif\n    {(int)KS_CRV,\t\"\\033[>c\"},\n    {(int)KS_RFG,\t\"\\033]10;?\\007\"},\n    {(int)KS_RBG,\t\"\\033]11;?\\007\"},\n    {(int)KS_U7,\t\"\\033[6n\"},\n#  ifdef FEAT_TERMGUICOLORS\n    // These are printf strings, not terminal codes.\n    {(int)KS_8F,\t\"\\033[38;2;%lu;%lu;%lum\"},\n    {(int)KS_8B,\t\"\\033[48;2;%lu;%lu;%lum\"},\n    {(int)KS_8U,\t\"\\033[58;2;%lu;%lu;%lum\"},\n#  endif\n    {(int)KS_CAU,\t\"\\033[58;5;%dm\"},\n    {(int)KS_CBE,\t\"\\033[?2004h\"},\n    {(int)KS_CBD,\t\"\\033[?2004l\"},\n    {(int)KS_CST,\t\"\\033[22;2t\"},\n    {(int)KS_CRT,\t\"\\033[23;2t\"},\n    {(int)KS_SSI,\t\"\\033[22;1t\"},\n    {(int)KS_SRI,\t\"\\033[23;1t\"},\n#  if (defined(UNIX) || defined(VMS))\n    {(int)KS_FD,\t\"\\033[?1004l\"},\n    {(int)KS_FE,\t\"\\033[?1004h\"},\n#  endif\n\n    {K_UP,\t\t\"\\033O*A\"},\n    {K_DOWN,\t\t\"\\033O*B\"},\n    {K_RIGHT,\t\t\"\\033O*C\"},\n    {K_LEFT,\t\t\"\\033O*D\"},\n    // An extra set of cursor keys for vt100 mode\n    {K_XUP,\t\t\"\\033[@;*A\"},\n    {K_XDOWN,\t\t\"\\033[@;*B\"},\n    {K_XRIGHT,\t\t\"\\033[@;*C\"},\n    {K_XLEFT,\t\t\"\\033[@;*D\"},\n    // An extra set of function keys for vt100 mode\n    {K_XF1,\t\t\"\\033O*P\"},\n    {K_XF2,\t\t\"\\033O*Q\"},\n    {K_XF3,\t\t\"\\033O*R\"},\n    {K_XF4,\t\t\"\\033O*S\"},\n    {K_F1,\t\t\"\\033[11;*~\"},\n    {K_F2,\t\t\"\\033[12;*~\"},\n    {K_F3,\t\t\"\\033[13;*~\"},\n    {K_F4,\t\t\"\\033[14;*~\"},\n    {K_F5,\t\t\"\\033[15;*~\"},\n    {K_F6,\t\t\"\\033[17;*~\"},\n    {K_F7,\t\t\"\\033[18;*~\"},\n    {K_F8,\t\t\"\\033[19;*~\"},\n    {K_F9,\t\t\"\\033[20;*~\"},\n    {K_F10,\t\t\"\\033[21;*~\"},\n    {K_F11,\t\t\"\\033[23;*~\"},\n    {K_F12,\t\t\"\\033[24;*~\"},\n    {K_S_TAB,\t\t\"\\033[Z\"},\n    {K_HELP,\t\t\"\\033[28;*~\"},\n    {K_UNDO,\t\t\"\\033[26;*~\"},\n    {K_INS,\t\t\"\\033[2;*~\"},\n    {K_HOME,\t\t\"\\033[1;*H\"},\n    // {K_S_HOME,\t\t\"\\033O2H\"},\n    // {K_C_HOME,\t\t\"\\033O5H\"},\n    {K_KHOME,\t\t\"\\033[1;*~\"},\n    {K_XHOME,\t\t\"\\033O*H\"},\t// other Home\n    {K_ZHOME,\t\t\"\\033[7;*~\"},\t// other Home\n    {K_END,\t\t\"\\033[1;*F\"},\n    // {K_S_END,\t\t\"\\033O2F\"},\n    // {K_C_END,\t\t\"\\033O5F\"},\n    {K_KEND,\t\t\"\\033[4;*~\"},\n    {K_XEND,\t\t\"\\033O*F\"},\t// other End\n    {K_ZEND,\t\t\"\\033[8;*~\"},\n    {K_PAGEUP,\t\t\"\\033[5;*~\"},\n    {K_PAGEDOWN,\t\"\\033[6;*~\"},\n    {K_KPLUS,\t\t\"\\033O*k\"},     // keypad plus\n    {K_KMINUS,\t\t\"\\033O*m\"},     // keypad minus\n    {K_KDIVIDE,\t\t\"\\033O*o\"},     // keypad /\n    {K_KMULTIPLY,\t\"\\033O*j\"},     // keypad *\n    {K_KENTER,\t\t\"\\033O*M\"},     // keypad Enter\n    {K_KPOINT,\t\t\"\\033O*n\"},     // keypad .\n    {K_K0,\t\t\"\\033O*p\"},     // keypad 0\n    {K_K1,\t\t\"\\033O*q\"},     // keypad 1\n    {K_K2,\t\t\"\\033O*r\"},     // keypad 2\n    {K_K3,\t\t\"\\033O*s\"},     // keypad 3\n    {K_K4,\t\t\"\\033O*t\"},     // keypad 4\n    {K_K5,\t\t\"\\033O*u\"},     // keypad 5\n    {K_K6,\t\t\"\\033O*v\"},     // keypad 6\n    {K_K7,\t\t\"\\033O*w\"},     // keypad 7\n    {K_K8,\t\t\"\\033O*x\"},     // keypad 8\n    {K_K9,\t\t\"\\033O*y\"},     // keypad 9\n    {K_KDEL,\t\t\"\\033[3;*~\"}, // keypad Del\n    {K_PS,\t\t\"\\033[200~\"}, // paste start\n    {K_PE,\t\t\"\\033[201~\"}, // paste end\n\n    {BT_EXTRA_KEYS,   \"\"},\n    {TERMCAP2KEY('k', '0'), \"\\033[10;*~\"}, // F0\n    {TERMCAP2KEY('F', '3'), \"\\033[25;*~\"}, // F13\n    // F14 and F15 are missing, because they send the same codes as the undo\n    // and help key, although they don't work on all keyboards.\n    {TERMCAP2KEY('F', '6'), \"\\033[29;*~\"}, // F16\n    {TERMCAP2KEY('F', '7'), \"\\033[31;*~\"}, // F17\n    {TERMCAP2KEY('F', '8'), \"\\033[32;*~\"}, // F18\n    {TERMCAP2KEY('F', '9'), \"\\033[33;*~\"}, // F19\n    {TERMCAP2KEY('F', 'A'), \"\\033[34;*~\"}, // F20\n\n    {TERMCAP2KEY('F', 'B'), \"\\033[42;*~\"}, // F21\n    {TERMCAP2KEY('F', 'C'), \"\\033[43;*~\"}, // F22\n    {TERMCAP2KEY('F', 'D'), \"\\033[44;*~\"}, // F23\n    {TERMCAP2KEY('F', 'E'), \"\\033[45;*~\"}, // F24\n    {TERMCAP2KEY('F', 'F'), \"\\033[46;*~\"}, // F25\n    {TERMCAP2KEY('F', 'G'), \"\\033[47;*~\"}, // F26\n    {TERMCAP2KEY('F', 'H'), \"\\033[48;*~\"}, // F27\n    {TERMCAP2KEY('F', 'I'), \"\\033[49;*~\"}, // F28\n    {TERMCAP2KEY('F', 'J'), \"\\033[50;*~\"}, // F29\n    {TERMCAP2KEY('F', 'K'), \"\\033[51;*~\"}, // F30\n\n    {TERMCAP2KEY('F', 'L'), \"\\033[52;*~\"}, // F31\n    {TERMCAP2KEY('F', 'M'), \"\\033[53;*~\"}, // F32\n    {TERMCAP2KEY('F', 'N'), \"\\033[54;*~\"}, // F33\n    {TERMCAP2KEY('F', 'O'), \"\\033[55;*~\"}, // F34\n    {TERMCAP2KEY('F', 'P'), \"\\033[56;*~\"}, // F35\n    {TERMCAP2KEY('F', 'Q'), \"\\033[57;*~\"}, // F36\n    {TERMCAP2KEY('F', 'R'), \"\\033[58;*~\"}, // F37\n# endif\n\n# if defined(UNIX) || defined(ALL_BUILTIN_TCAPS)\n/*\n * iris-ansi for Silicon Graphics machines.\n */\n    {(int)KS_NAME,\t\"iris-ansi\"},\n    {(int)KS_CE,\t\"\\033[K\"},\n    {(int)KS_CD,\t\"\\033[J\"},\n    {(int)KS_AL,\t\"\\033[L\"},\n#  ifdef TERMINFO\n    {(int)KS_CAL,\t\"\\033[%p1%dL\"},\n#  else\n    {(int)KS_CAL,\t\"\\033[%dL\"},\n#  endif\n    {(int)KS_DL,\t\"\\033[M\"},\n#  ifdef TERMINFO\n    {(int)KS_CDL,\t\"\\033[%p1%dM\"},\n#  else\n    {(int)KS_CDL,\t\"\\033[%dM\"},\n#  endif\n#if 0\t// The scroll region is not working as Vim expects.\n#  ifdef TERMINFO\n    {(int)KS_CS,\t\"\\033[%i%p1%d;%p2%dr\"},\n#  else\n    {(int)KS_CS,\t\"\\033[%i%d;%dr\"},\n#  endif\n#endif\n    {(int)KS_CL,\t\"\\033[H\\033[2J\"},\n    {(int)KS_VE,\t\"\\033[9/y\\033[12/y\"},\t// These aren't documented\n    {(int)KS_VS,\t\"\\033[10/y\\033[=1h\\033[=2l\"}, // These aren't documented\n    {(int)KS_TI,\t\"\\033[=6h\"},\n    {(int)KS_TE,\t\"\\033[=6l\"},\n    {(int)KS_SE,\t\"\\033[21;27m\"},\n    {(int)KS_SO,\t\"\\033[1;7m\"},\n    {(int)KS_ME,\t\"\\033[m\"},\n    {(int)KS_MR,\t\"\\033[7m\"},\n    {(int)KS_MD,\t\"\\033[1m\"},\n    {(int)KS_CCO,\t\"8\"},\t\t\t// allow 8 colors\n    {(int)KS_CZH,\t\"\\033[3m\"},\t\t// italic mode on\n    {(int)KS_CZR,\t\"\\033[23m\"},\t\t// italic mode off\n    {(int)KS_US,\t\"\\033[4m\"},\t\t// underline on\n    {(int)KS_UE,\t\"\\033[24m\"},\t\t// underline off\n#  ifdef TERMINFO\n    {(int)KS_CAB,\t\"\\033[4%p1%dm\"},    // set background color (ANSI)\n    {(int)KS_CAF,\t\"\\033[3%p1%dm\"},    // set foreground color (ANSI)\n    {(int)KS_CSB,\t\"\\033[102;%p1%dm\"}, // set screen background color\n    {(int)KS_CSF,\t\"\\033[101;%p1%dm\"}, // set screen foreground color\n#  else\n    {(int)KS_CAB,\t\"\\033[4%dm\"},\t    // set background color (ANSI)\n    {(int)KS_CAF,\t\"\\033[3%dm\"},\t    // set foreground color (ANSI)\n    {(int)KS_CSB,\t\"\\033[102;%dm\"},    // set screen background color\n    {(int)KS_CSF,\t\"\\033[101;%dm\"},    // set screen foreground color\n#  endif\n    {(int)KS_MS,\t\"y\"},\t\t// guessed\n    {(int)KS_UT,\t\"y\"},\t\t// guessed\n    {(int)KS_LE,\t\"\\b\"},\n#  ifdef TERMINFO\n    {(int)KS_CM,\t\"\\033[%i%p1%d;%p2%dH\"},\n#  else\n    {(int)KS_CM,\t\"\\033[%i%d;%dH\"},\n#  endif\n    {(int)KS_SR,\t\"\\033M\"},\n#  ifdef TERMINFO\n    {(int)KS_CRI,\t\"\\033[%p1%dC\"},\n#  else\n    {(int)KS_CRI,\t\"\\033[%dC\"},\n#  endif\n    {(int)KS_CIS,\t\"\\033P3.y\"},\n    {(int)KS_CIE,\t\"\\234\"},    // ST \"String Terminator\"\n    {(int)KS_TS,\t\"\\033P1.y\"},\n    {(int)KS_FS,\t\"\\234\"},    // ST \"String Terminator\"\n#  ifdef TERMINFO\n    {(int)KS_CWS,\t\"\\033[203;%p1%d;%p2%d/y\"},\n    {(int)KS_CWP,\t\"\\033[205;%p1%d;%p2%d/y\"},\n#  else\n    {(int)KS_CWS,\t\"\\033[203;%d;%d/y\"},\n    {(int)KS_CWP,\t\"\\033[205;%d;%d/y\"},\n#  endif\n    {K_UP,\t\t\"\\033[A\"},\n    {K_DOWN,\t\t\"\\033[B\"},\n    {K_LEFT,\t\t\"\\033[D\"},\n    {K_RIGHT,\t\t\"\\033[C\"},\n    {K_S_UP,\t\t\"\\033[161q\"},\n    {K_S_DOWN,\t\t\"\\033[164q\"},\n    {K_S_LEFT,\t\t\"\\033[158q\"},\n    {K_S_RIGHT,\t\t\"\\033[167q\"},\n    {K_F1,\t\t\"\\033[001q\"},\n    {K_F2,\t\t\"\\033[002q\"},\n    {K_F3,\t\t\"\\033[003q\"},\n    {K_F4,\t\t\"\\033[004q\"},\n    {K_F5,\t\t\"\\033[005q\"},\n    {K_F6,\t\t\"\\033[006q\"},\n    {K_F7,\t\t\"\\033[007q\"},\n    {K_F8,\t\t\"\\033[008q\"},\n    {K_F9,\t\t\"\\033[009q\"},\n    {K_F10,\t\t\"\\033[010q\"},\n    {K_F11,\t\t\"\\033[011q\"},\n    {K_F12,\t\t\"\\033[012q\"},\n    {K_S_F1,\t\t\"\\033[013q\"},\n    {K_S_F2,\t\t\"\\033[014q\"},\n    {K_S_F3,\t\t\"\\033[015q\"},\n    {K_S_F4,\t\t\"\\033[016q\"},\n    {K_S_F5,\t\t\"\\033[017q\"},\n    {K_S_F6,\t\t\"\\033[018q\"},\n    {K_S_F7,\t\t\"\\033[019q\"},\n    {K_S_F8,\t\t\"\\033[020q\"},\n    {K_S_F9,\t\t\"\\033[021q\"},\n    {K_S_F10,\t\t\"\\033[022q\"},\n    {K_S_F11,\t\t\"\\033[023q\"},\n    {K_S_F12,\t\t\"\\033[024q\"},\n    {K_INS,\t\t\"\\033[139q\"},\n    {K_HOME,\t\t\"\\033[H\"},\n    {K_END,\t\t\"\\033[146q\"},\n    {K_PAGEUP,\t\t\"\\033[150q\"},\n    {K_PAGEDOWN,\t\"\\033[154q\"},\n# endif\n\n# if defined(DEBUG) || defined(ALL_BUILTIN_TCAPS)\n/*\n * for debugging\n */\n    {(int)KS_NAME,\t\"debug\"},\n    {(int)KS_CE,\t\"[CE]\"},\n    {(int)KS_CD,\t\"[CD]\"},\n    {(int)KS_AL,\t\"[AL]\"},\n#  ifdef TERMINFO\n    {(int)KS_CAL,\t\"[CAL%p1%d]\"},\n#  else\n    {(int)KS_CAL,\t\"[CAL%d]\"},\n#  endif\n    {(int)KS_DL,\t\"[DL]\"},\n#  ifdef TERMINFO\n    {(int)KS_CDL,\t\"[CDL%p1%d]\"},\n#  else\n    {(int)KS_CDL,\t\"[CDL%d]\"},\n#  endif\n#  ifdef TERMINFO\n    {(int)KS_CS,\t\"[%p1%dCS%p2%d]\"},\n#  else\n    {(int)KS_CS,\t\"[%dCS%d]\"},\n#  endif\n#  ifdef TERMINFO\n    {(int)KS_CSV,\t\"[%p1%dCSV%p2%d]\"},\n#  else\n    {(int)KS_CSV,\t\"[%dCSV%d]\"},\n#  endif\n#  ifdef TERMINFO\n    {(int)KS_CAB,\t\"[CAB%p1%d]\"},\n    {(int)KS_CAF,\t\"[CAF%p1%d]\"},\n    {(int)KS_CSB,\t\"[CSB%p1%d]\"},\n    {(int)KS_CSF,\t\"[CSF%p1%d]\"},\n#  else\n    {(int)KS_CAB,\t\"[CAB%d]\"},\n    {(int)KS_CAF,\t\"[CAF%d]\"},\n    {(int)KS_CSB,\t\"[CSB%d]\"},\n    {(int)KS_CSF,\t\"[CSF%d]\"},\n#  endif\n    {(int)KS_CAU,\t\"[CAU%d]\"},\n    {(int)KS_OP,\t\"[OP]\"},\n    {(int)KS_LE,\t\"[LE]\"},\n    {(int)KS_CL,\t\"[CL]\"},\n    {(int)KS_VI,\t\"[VI]\"},\n    {(int)KS_VE,\t\"[VE]\"},\n    {(int)KS_VS,\t\"[VS]\"},\n    {(int)KS_ME,\t\"[ME]\"},\n    {(int)KS_MR,\t\"[MR]\"},\n    {(int)KS_MB,\t\"[MB]\"},\n    {(int)KS_MD,\t\"[MD]\"},\n    {(int)KS_SE,\t\"[SE]\"},\n    {(int)KS_SO,\t\"[SO]\"},\n    {(int)KS_UE,\t\"[UE]\"},\n    {(int)KS_US,\t\"[US]\"},\n    {(int)KS_UCE,\t\"[UCE]\"},\n    {(int)KS_UCS,\t\"[UCS]\"},\n    {(int)KS_STE,\t\"[STE]\"},\n    {(int)KS_STS,\t\"[STS]\"},\n    {(int)KS_MS,\t\"[MS]\"},\n    {(int)KS_UT,\t\"[UT]\"},\n    {(int)KS_XN,\t\"[XN]\"},\n#  ifdef TERMINFO\n    {(int)KS_CM,\t\"[%p1%dCM%p2%d]\"},\n#  else\n    {(int)KS_CM,\t\"[%dCM%d]\"},\n#  endif\n    {(int)KS_SR,\t\"[SR]\"},\n#  ifdef TERMINFO\n    {(int)KS_CRI,\t\"[CRI%p1%d]\"},\n#  else\n    {(int)KS_CRI,\t\"[CRI%d]\"},\n#  endif\n    {(int)KS_VB,\t\"[VB]\"},\n    {(int)KS_KS,\t\"[KS]\"},\n    {(int)KS_KE,\t\"[KE]\"},\n    {(int)KS_TI,\t\"[TI]\"},\n    {(int)KS_TE,\t\"[TE]\"},\n    {(int)KS_CIS,\t\"[CIS]\"},\n    {(int)KS_CIE,\t\"[CIE]\"},\n    {(int)KS_CSC,\t\"[CSC]\"},\n    {(int)KS_CEC,\t\"[CEC]\"},\n    {(int)KS_TS,\t\"[TS]\"},\n    {(int)KS_FS,\t\"[FS]\"},\n#  ifdef TERMINFO\n    {(int)KS_CWS,\t\"[%p1%dCWS%p2%d]\"},\n    {(int)KS_CWP,\t\"[%p1%dCWP%p2%d]\"},\n#  else\n    {(int)KS_CWS,\t\"[%dCWS%d]\"},\n    {(int)KS_CWP,\t\"[%dCWP%d]\"},\n#  endif\n    {(int)KS_CRV,\t\"[CRV]\"},\n    {(int)KS_U7,\t\"[U7]\"},\n    {(int)KS_RFG,\t\"[RFG]\"},\n    {(int)KS_RBG,\t\"[RBG]\"},\n    {K_UP,\t\t\"[KU]\"},\n    {K_DOWN,\t\t\"[KD]\"},\n    {K_LEFT,\t\t\"[KL]\"},\n    {K_RIGHT,\t\t\"[KR]\"},\n    {K_XUP,\t\t\"[xKU]\"},\n    {K_XDOWN,\t\t\"[xKD]\"},\n    {K_XLEFT,\t\t\"[xKL]\"},\n    {K_XRIGHT,\t\t\"[xKR]\"},\n    {K_S_UP,\t\t\"[S-KU]\"},\n    {K_S_DOWN,\t\t\"[S-KD]\"},\n    {K_S_LEFT,\t\t\"[S-KL]\"},\n    {K_C_LEFT,\t\t\"[C-KL]\"},\n    {K_S_RIGHT,\t\t\"[S-KR]\"},\n    {K_C_RIGHT,\t\t\"[C-KR]\"},\n    {K_F1,\t\t\"[F1]\"},\n    {K_XF1,\t\t\"[xF1]\"},\n    {K_F2,\t\t\"[F2]\"},\n    {K_XF2,\t\t\"[xF2]\"},\n    {K_F3,\t\t\"[F3]\"},\n    {K_XF3,\t\t\"[xF3]\"},\n    {K_F4,\t\t\"[F4]\"},\n    {K_XF4,\t\t\"[xF4]\"},\n    {K_F5,\t\t\"[F5]\"},\n    {K_F6,\t\t\"[F6]\"},\n    {K_F7,\t\t\"[F7]\"},\n    {K_F8,\t\t\"[F8]\"},\n    {K_F9,\t\t\"[F9]\"},\n    {K_F10,\t\t\"[F10]\"},\n    {K_F11,\t\t\"[F11]\"},\n    {K_F12,\t\t\"[F12]\"},\n    {K_S_F1,\t\t\"[S-F1]\"},\n    {K_S_XF1,\t\t\"[S-xF1]\"},\n    {K_S_F2,\t\t\"[S-F2]\"},\n    {K_S_XF2,\t\t\"[S-xF2]\"},\n    {K_S_F3,\t\t\"[S-F3]\"},\n    {K_S_XF3,\t\t\"[S-xF3]\"},\n    {K_S_F4,\t\t\"[S-F4]\"},\n    {K_S_XF4,\t\t\"[S-xF4]\"},\n    {K_S_F5,\t\t\"[S-F5]\"},\n    {K_S_F6,\t\t\"[S-F6]\"},\n    {K_S_F7,\t\t\"[S-F7]\"},\n    {K_S_F8,\t\t\"[S-F8]\"},\n    {K_S_F9,\t\t\"[S-F9]\"},\n    {K_S_F10,\t\t\"[S-F10]\"},\n    {K_S_F11,\t\t\"[S-F11]\"},\n    {K_S_F12,\t\t\"[S-F12]\"},\n    {K_HELP,\t\t\"[HELP]\"},\n    {K_UNDO,\t\t\"[UNDO]\"},\n    {K_BS,\t\t\"[BS]\"},\n    {K_INS,\t\t\"[INS]\"},\n    {K_KINS,\t\t\"[KINS]\"},\n    {K_DEL,\t\t\"[DEL]\"},\n    {K_KDEL,\t\t\"[KDEL]\"},\n    {K_HOME,\t\t\"[HOME]\"},\n    {K_S_HOME,\t\t\"[C-HOME]\"},\n    {K_C_HOME,\t\t\"[C-HOME]\"},\n    {K_KHOME,\t\t\"[KHOME]\"},\n    {K_XHOME,\t\t\"[XHOME]\"},\n    {K_ZHOME,\t\t\"[ZHOME]\"},\n    {K_END,\t\t\"[END]\"},\n    {K_S_END,\t\t\"[C-END]\"},\n    {K_C_END,\t\t\"[C-END]\"},\n    {K_KEND,\t\t\"[KEND]\"},\n    {K_XEND,\t\t\"[XEND]\"},\n    {K_ZEND,\t\t\"[ZEND]\"},\n    {K_PAGEUP,\t\t\"[PAGEUP]\"},\n    {K_PAGEDOWN,\t\"[PAGEDOWN]\"},\n    {K_KPAGEUP,\t\t\"[KPAGEUP]\"},\n    {K_KPAGEDOWN,\t\"[KPAGEDOWN]\"},\n    {K_MOUSE,\t\t\"[MOUSE]\"},\n    {K_KPLUS,\t\t\"[KPLUS]\"},\n    {K_KMINUS,\t\t\"[KMINUS]\"},\n    {K_KDIVIDE,\t\t\"[KDIVIDE]\"},\n    {K_KMULTIPLY,\t\"[KMULTIPLY]\"},\n    {K_KENTER,\t\t\"[KENTER]\"},\n    {K_KPOINT,\t\t\"[KPOINT]\"},\n    {K_PS,\t\t\"[PASTE-START]\"},\n    {K_PE,\t\t\"[PASTE-END]\"},\n    {K_K0,\t\t\"[K0]\"},\n    {K_K1,\t\t\"[K1]\"},\n    {K_K2,\t\t\"[K2]\"},\n    {K_K3,\t\t\"[K3]\"},\n    {K_K4,\t\t\"[K4]\"},\n    {K_K5,\t\t\"[K5]\"},\n    {K_K6,\t\t\"[K6]\"},\n    {K_K7,\t\t\"[K7]\"},\n    {K_K8,\t\t\"[K8]\"},\n    {K_K9,\t\t\"[K9]\"},\n# endif\n\n#endif // NO_BUILTIN_TCAPS\n\n/*\n * The most minimal terminal: only clear screen and cursor positioning\n * Always included.\n */\n    {(int)KS_NAME,\t\"dumb\"},\n    {(int)KS_CL,\t\"\\014\"},\n#ifdef TERMINFO\n    {(int)KS_CM,\t\"\\033[%i%p1%d;%p2%dH\"},\n#else\n    {(int)KS_CM,\t\"\\033[%i%d;%dH\"},\n#endif\n\n/*\n * end marker\n */\n    {(int)KS_NAME,\tNULL}\n\n};\t// end of builtin_termcaps\n\n#if defined(FEAT_TERMGUICOLORS) || defined(PROTO)\n    static guicolor_T\ntermgui_mch_get_color(char_u *name)\n{\n    return gui_get_color_cmn(name);\n}\n\n    guicolor_T\ntermgui_get_color(char_u *name)\n{\n    guicolor_T\tt;\n\n    if (*name == NUL)\n\treturn INVALCOLOR;\n    t = termgui_mch_get_color(name);\n\n    if (t == INVALCOLOR)\n\tsemsg(_(e_cannot_allocate_color_str), name);\n    return t;\n}\n\n    guicolor_T\ntermgui_mch_get_rgb(guicolor_T color)\n{\n    return color;\n}\n#endif\n\n/*\n * DEFAULT_TERM is used, when no terminal is specified with -T option or $TERM.\n */\n#ifdef AMIGA\n# define DEFAULT_TERM\t(char_u *)\"amiga\"\n#endif\n\n#ifdef MSWIN\n# define DEFAULT_TERM\t(char_u *)\"win32\"\n#endif\n\n#if defined(UNIX)\n# define DEFAULT_TERM\t(char_u *)\"ansi\"\n#endif\n\n#ifdef VMS\n# define DEFAULT_TERM\t(char_u *)\"vt320\"\n#endif\n\n#ifdef __HAIKU__\n# undef DEFAULT_TERM\n# define DEFAULT_TERM\t(char_u *)\"xterm\"\n#endif\n\n#ifndef DEFAULT_TERM\n# define DEFAULT_TERM\t(char_u *)\"dumb\"\n#endif\n\n/*\n * Term_strings contains currently used terminal output strings.\n * It is initialized with the default values by parse_builtin_tcap().\n * The values can be changed by setting the option with the same name.\n */\nchar_u *(term_strings[(int)KS_LAST + 1]);\n\nstatic int\tneed_gather = FALSE;\t    // need to fill termleader[]\nstatic char_u\ttermleader[256 + 1];\t    // for check_termcode()\n#ifdef FEAT_TERMRESPONSE\nstatic int\tcheck_for_codes = FALSE;    // check for key code response\n\n/*\n * Structure and table to store terminal features that can be detected by\n * querying the terminal.  Either by inspecting the termresponse or a more\n * specific request.  Besides this there are:\n * t_colors - number of colors supported\n */\ntypedef struct {\n    char    *tpr_name;\n    int\t    tpr_set_by_termresponse;\n    int\t    tpr_status;\n} termprop_T;\n\n// Values for tpr_status.\n#define TPR_UNKNOWN\t    'u'\n#define TPR_YES\t\t    'y'\n#define TPR_NO\t\t    'n'\n#define TPR_MOUSE_XTERM     'x'\t// use \"xterm\" for 'ttymouse'\n#define TPR_MOUSE_XTERM2    '2'\t// use \"xterm2\" for 'ttymouse'\n#define TPR_MOUSE_SGR\t    's'\t// use \"sgr\" for 'ttymouse'\n\n// can request the cursor style without messing up the display\n#define TPR_CURSOR_STYLE\t    0\n// can request the cursor blink mode without messing up the display\n#define TPR_CURSOR_BLINK\t    1\n// can set the underline color with t_8u without resetting other colors\n#define TPR_UNDERLINE_RGB\t    2\n// mouse support - TPR_MOUSE_XTERM, TPR_MOUSE_XTERM2 or TPR_MOUSE_SGR\n#define TPR_MOUSE\t\t    3\n// table size\n#define TPR_COUNT\t\t    4\n\nstatic termprop_T term_props[TPR_COUNT];\n\n/*\n * Initialize the term_props table.\n * When \"all\" is FALSE only set those that are detected from the version\n * response.\n */\n    void\ninit_term_props(int all)\n{\n    int i;\n\n    term_props[TPR_CURSOR_STYLE].tpr_name = \"cursor_style\";\n    term_props[TPR_CURSOR_STYLE].tpr_set_by_termresponse = FALSE;\n    term_props[TPR_CURSOR_BLINK].tpr_name = \"cursor_blink_mode\";\n    term_props[TPR_CURSOR_BLINK].tpr_set_by_termresponse = FALSE;\n    term_props[TPR_UNDERLINE_RGB].tpr_name = \"underline_rgb\";\n    term_props[TPR_UNDERLINE_RGB].tpr_set_by_termresponse = TRUE;\n    term_props[TPR_MOUSE].tpr_name = \"mouse\";\n    term_props[TPR_MOUSE].tpr_set_by_termresponse = TRUE;\n\n    for (i = 0; i < TPR_COUNT; ++i)\n\tif (all || term_props[i].tpr_set_by_termresponse)\n\t    term_props[i].tpr_status = TPR_UNKNOWN;\n}\n#endif\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n    void\nf_terminalprops(typval_T *argvars UNUSED, typval_T *rettv)\n{\n# ifdef FEAT_TERMRESPONSE\n    int i;\n# endif\n\n    if (rettv_dict_alloc(rettv) == FAIL)\n\treturn;\n# ifdef FEAT_TERMRESPONSE\n    for (i = 0; i < TPR_COUNT; ++i)\n    {\n\tchar_u\tvalue[2];\n\n\tvalue[0] = term_props[i].tpr_status;\n\tvalue[1] = NUL;\n\tdict_add_string(rettv->vval.v_dict, term_props[i].tpr_name, value);\n    }\n# endif\n}\n#endif\n\n    static struct builtin_term *\nfind_builtin_term(char_u *term)\n{\n    struct builtin_term *p;\n\n    p = builtin_termcaps;\n    while (p->bt_string != NULL)\n    {\n\tif (p->bt_entry == (int)KS_NAME)\n\t{\n#ifdef UNIX\n\t    if (STRCMP(p->bt_string, \"iris-ansi\") == 0 && vim_is_iris(term))\n\t\treturn p;\n\t    else if (STRCMP(p->bt_string, \"xterm\") == 0 && vim_is_xterm(term))\n\t\treturn p;\n\t    else\n#endif\n#ifdef VMS\n\t\tif (STRCMP(p->bt_string, \"vt320\") == 0 && vim_is_vt300(term))\n\t\t    return p;\n\t\telse\n#endif\n\t\t  if (STRCMP(term, p->bt_string) == 0)\n\t\t    return p;\n\t}\n\t++p;\n    }\n    return p;\n}\n\n/*\n * Parsing of the builtin termcap entries.\n * Caller should check if 'name' is a valid builtin term.\n * The terminal's name is not set, as this is already done in termcapinit().\n */\n    static void\nparse_builtin_tcap(char_u *term)\n{\n    struct builtin_term\t    *p;\n    char_u\t\t    name[2];\n    int\t\t\t    term_8bit;\n\n    p = find_builtin_term(term);\n    term_8bit = term_is_8bit(term);\n\n    // Do not parse if builtin term not found\n    if (p->bt_string == NULL)\n\treturn;\n\n    for (++p; p->bt_entry != (int)KS_NAME && p->bt_entry != BT_EXTRA_KEYS; ++p)\n    {\n\tif ((int)p->bt_entry >= 0)\t// KS_xx entry\n\t{\n\t    // Only set the value if it wasn't set yet.\n\t    if (term_strings[p->bt_entry] == NULL\n\t\t\t\t || term_strings[p->bt_entry] == empty_option)\n\t    {\n#ifdef FEAT_EVAL\n\t\tint opt_idx = -1;\n#endif\n\t\t// 8bit terminal: use CSI instead of <Esc>[\n\t\tif (term_8bit && term_7to8bit((char_u *)p->bt_string) != 0)\n\t\t{\n\t\t    char_u  *s, *t;\n\n\t\t    s = vim_strsave((char_u *)p->bt_string);\n\t\t    if (s != NULL)\n\t\t    {\n\t\t\tfor (t = s; *t; ++t)\n\t\t\t    if (term_7to8bit(t))\n\t\t\t    {\n\t\t\t\t*t = term_7to8bit(t);\n\t\t\t\tSTRMOVE(t + 1, t + 2);\n\t\t\t    }\n\t\t\tterm_strings[p->bt_entry] = s;\n#ifdef FEAT_EVAL\n\t\t\topt_idx =\n#endif\n\t\t\t\t  set_term_option_alloced(\n\t\t\t\t\t\t   &term_strings[p->bt_entry]);\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    term_strings[p->bt_entry] = (char_u *)p->bt_string;\n#ifdef FEAT_EVAL\n\t\t    opt_idx = get_term_opt_idx(&term_strings[p->bt_entry]);\n#endif\n\t\t}\n#ifdef FEAT_EVAL\n\t\tset_term_option_sctx_idx(NULL, opt_idx);\n#endif\n\t    }\n\t}\n\telse\n\t{\n\t    name[0] = KEY2TERMCAP0((int)p->bt_entry);\n\t    name[1] = KEY2TERMCAP1((int)p->bt_entry);\n\t    if (find_termcode(name) == NULL)\n\t\tadd_termcode(name, (char_u *)p->bt_string, term_8bit);\n\t}\n    }\n}\n\n/*\n * Set number of colors.\n * Store it as a number in t_colors.\n * Store it as a string in T_CCO (using nr_colors[]).\n */\n    void\nset_color_count(int nr)\n{\n    char_u\tnr_colors[20];\t\t// string for number of colors\n\n    t_colors = nr;\n    if (t_colors > 1)\n\tsprintf((char *)nr_colors, \"%d\", t_colors);\n    else\n\t*nr_colors = NUL;\n    set_string_option_direct((char_u *)\"t_Co\", -1, nr_colors, OPT_FREE, 0);\n}\n\n#if defined(FEAT_TERMRESPONSE)\n/*\n * Set the color count to \"val\" and redraw if it changed.\n */\n    static void\nmay_adjust_color_count(int val)\n{\n    if (val != t_colors)\n    {\n\t// Nr of colors changed, initialize highlighting and\n\t// redraw everything.  This causes a redraw, which usually\n\t// clears the message.  Try keeping the message if it\n\t// might work.\n\tset_keep_msg_from_hist();\n\tset_color_count(val);\n\tinit_highlight(TRUE, FALSE);\n# ifdef DEBUG_TERMRESPONSE\n\t{\n\t    int r = redraw_asap(CLEAR);\n\n\t    log_tr(\"Received t_Co, redraw_asap(): %d\", r);\n\t}\n# else\n\tredraw_asap(CLEAR);\n# endif\n    }\n}\n#endif\n\n#ifdef HAVE_TGETENT\nstatic char *(key_names[]) =\n{\n# ifdef FEAT_TERMRESPONSE\n    // Do this one first, it may cause a screen redraw.\n    \"Co\",\n# endif\n    \"ku\", \"kd\", \"kr\", \"kl\",\n    \"#2\", \"#4\", \"%i\", \"*7\",\n    \"k1\", \"k2\", \"k3\", \"k4\", \"k5\", \"k6\",\n    \"k7\", \"k8\", \"k9\", \"k;\", \"F1\", \"F2\",\n    \"%1\", \"&8\", \"kb\", \"kI\", \"kD\", \"kh\",\n    \"@7\", \"kP\", \"kN\", \"K1\", \"K3\", \"K4\", \"K5\", \"kB\",\n    NULL\n};\n#endif\n\n#ifdef HAVE_TGETENT\n    static void\nget_term_entries(int *height, int *width)\n{\n    static struct {\n\t\t    enum SpecialKey dest; // index in term_strings[]\n\t\t    char *name;\t\t  // termcap name for string\n\t\t  } string_names[] =\n\t\t    {\t{KS_CE, \"ce\"}, {KS_AL, \"al\"}, {KS_CAL,\"AL\"},\n\t\t\t{KS_DL, \"dl\"}, {KS_CDL,\"DL\"}, {KS_CS, \"cs\"},\n\t\t\t{KS_CL, \"cl\"}, {KS_CD, \"cd\"},\n\t\t\t{KS_VI, \"vi\"}, {KS_VE, \"ve\"}, {KS_MB, \"mb\"},\n\t\t\t{KS_ME, \"me\"}, {KS_MR, \"mr\"},\n\t\t\t{KS_MD, \"md\"}, {KS_SE, \"se\"}, {KS_SO, \"so\"},\n\t\t\t{KS_CZH,\"ZH\"}, {KS_CZR,\"ZR\"}, {KS_UE, \"ue\"},\n\t\t\t{KS_US, \"us\"}, {KS_UCE, \"Ce\"}, {KS_UCS, \"Cs\"},\n\t\t\t{KS_STE,\"Te\"}, {KS_STS,\"Ts\"},\n\t\t\t{KS_CM, \"cm\"}, {KS_SR, \"sr\"},\n\t\t\t{KS_CRI,\"RI\"}, {KS_VB, \"vb\"}, {KS_KS, \"ks\"},\n\t\t\t{KS_KE, \"ke\"}, {KS_TI, \"ti\"}, {KS_TE, \"te\"},\n\t\t\t{KS_CTI, \"TI\"}, {KS_CTE, \"TE\"},\n\t\t\t{KS_BC, \"bc\"}, {KS_CSB,\"Sb\"}, {KS_CSF,\"Sf\"},\n\t\t\t{KS_CAB,\"AB\"}, {KS_CAF,\"AF\"}, {KS_CAU,\"AU\"},\n\t\t\t{KS_LE, \"le\"},\n\t\t\t{KS_ND, \"nd\"}, {KS_OP, \"op\"}, {KS_CRV, \"RV\"},\n\t\t\t{KS_VS, \"vs\"}, {KS_CVS, \"VS\"},\n\t\t\t{KS_CIS, \"IS\"}, {KS_CIE, \"IE\"},\n\t\t\t{KS_CSC, \"SC\"}, {KS_CEC, \"EC\"},\n\t\t\t{KS_TS, \"ts\"}, {KS_FS, \"fs\"},\n\t\t\t{KS_CWP, \"WP\"}, {KS_CWS, \"WS\"},\n\t\t\t{KS_CSI, \"SI\"}, {KS_CEI, \"EI\"},\n\t\t\t{KS_U7, \"u7\"}, {KS_RFG, \"RF\"}, {KS_RBG, \"RB\"},\n\t\t\t{KS_8F, \"8f\"}, {KS_8B, \"8b\"}, {KS_8U, \"8u\"},\n\t\t\t{KS_CBE, \"BE\"}, {KS_CBD, \"BD\"},\n\t\t\t{KS_CPS, \"PS\"}, {KS_CPE, \"PE\"},\n\t\t\t{KS_CST, \"ST\"}, {KS_CRT, \"RT\"},\n\t\t\t{KS_SSI, \"Si\"}, {KS_SRI, \"Ri\"},\n\t\t\t{(enum SpecialKey)0, NULL}\n\t\t    };\n    int\t\t    i;\n    char_u\t    *p;\n    static char_u   tstrbuf[TBUFSZ];\n    char_u\t    *tp = tstrbuf;\n\n    /*\n     * get output strings\n     */\n    for (i = 0; string_names[i].name != NULL; ++i)\n    {\n\tif (TERM_STR(string_names[i].dest) == NULL\n\t\t\t     || TERM_STR(string_names[i].dest) == empty_option)\n\t{\n\t    TERM_STR(string_names[i].dest) = TGETSTR(string_names[i].name, &tp);\n#ifdef FEAT_EVAL\n\t    set_term_option_sctx_idx(string_names[i].name, -1);\n#endif\n\t}\n    }\n\n    // tgetflag() returns 1 if the flag is present, 0 if not and\n    // possibly -1 if the flag doesn't exist.\n    if ((T_MS == NULL || T_MS == empty_option) && tgetflag(\"ms\") > 0)\n\tT_MS = (char_u *)\"y\";\n    if ((T_XS == NULL || T_XS == empty_option) && tgetflag(\"xs\") > 0)\n\tT_XS = (char_u *)\"y\";\n    if ((T_XN == NULL || T_XN == empty_option) && tgetflag(\"xn\") > 0)\n\tT_XN = (char_u *)\"y\";\n    if ((T_DB == NULL || T_DB == empty_option) && tgetflag(\"db\") > 0)\n\tT_DB = (char_u *)\"y\";\n    if ((T_DA == NULL || T_DA == empty_option) && tgetflag(\"da\") > 0)\n\tT_DA = (char_u *)\"y\";\n    if ((T_UT == NULL || T_UT == empty_option) && tgetflag(\"ut\") > 0)\n\tT_UT = (char_u *)\"y\";\n\n    /*\n     * get key codes\n     */\n    for (i = 0; key_names[i] != NULL; ++i)\n\tif (find_termcode((char_u *)key_names[i]) == NULL)\n\t{\n\t    p = TGETSTR(key_names[i], &tp);\n\t    // if cursor-left == backspace, ignore it (televideo 925)\n\t    if (p != NULL\n\t\t    && (*p != Ctrl_H\n\t\t\t|| key_names[i][0] != 'k'\n\t\t\t|| key_names[i][1] != 'l'))\n\t\tadd_termcode((char_u *)key_names[i], p, FALSE);\n\t}\n\n    if (*height == 0)\n\t*height = tgetnum(\"li\");\n    if (*width == 0)\n\t*width = tgetnum(\"co\");\n\n    /*\n     * Get number of colors (if not done already).\n     */\n    if (TERM_STR(KS_CCO) == NULL || TERM_STR(KS_CCO) == empty_option)\n    {\n\tset_color_count(tgetnum(\"Co\"));\n#ifdef FEAT_EVAL\n\tset_term_option_sctx_idx(\"Co\", -1);\n#endif\n    }\n\n# ifndef hpux\n    BC = (char *)TGETSTR(\"bc\", &tp);\n    UP = (char *)TGETSTR(\"up\", &tp);\n    p = TGETSTR(\"pc\", &tp);\n    if (p)\n\tPC = *p;\n# endif\n}\n#endif\n\n    static void\nreport_term_error(char *error_msg, char_u *term)\n{\n    struct builtin_term *termp;\n    int\t\t\ti;\n\n    mch_errmsg(\"\\r\\n\");\n    if (error_msg != NULL)\n    {\n\tmch_errmsg(error_msg);\n\tmch_errmsg(\"\\r\\n\");\n    }\n    mch_errmsg(\"'\");\n    mch_errmsg((char *)term);\n    mch_errmsg(_(\"' not known. Available builtin terminals are:\"));\n    mch_errmsg(\"\\r\\n\");\n    for (termp = &(builtin_termcaps[0]); termp->bt_string != NULL; ++termp)\n    {\n\tif (termp->bt_entry == (int)KS_NAME\n\t\t&& STRCMP(termp->bt_string, \"gui\") != 0)\n\t{\n#ifdef HAVE_TGETENT\n\t    mch_errmsg(\"    builtin_\");\n#else\n\t    mch_errmsg(\"    \");\n#endif\n\t    mch_errmsg(termp->bt_string);\n\t    mch_errmsg(\"\\r\\n\");\n\t}\n    }\n    // Output extra 'cmdheight' line breaks to avoid that the following error\n    // message overwrites the last terminal name.\n    for (i = 1; i < p_ch; ++i)\n\tmch_errmsg(\"\\r\\n\");\n}\n\n    static void\nreport_default_term(char_u *term)\n{\n    mch_errmsg(_(\"defaulting to '\"));\n    mch_errmsg((char *)term);\n    mch_errmsg(\"'\\r\\n\");\n    if (emsg_silent == 0 && !in_assert_fails)\n    {\n\tscreen_start();\t// don't know where cursor is now\n\tout_flush();\n\tif (!is_not_a_term())\n\t    ui_delay(2007L, TRUE);\n    }\n}\n\n/*\n * Set terminal options for terminal \"term\".\n * Return OK if terminal 'term' was found in a termcap, FAIL otherwise.\n *\n * While doing this, until ttest(), some options may be NULL, be careful.\n */\n    int\nset_termname(char_u *term)\n{\n    struct builtin_term *termp;\n#ifdef HAVE_TGETENT\n    int\t\tbuiltin_first = p_tbi;\n    int\t\ttry;\n    int\t\ttermcap_cleared = FALSE;\n#endif\n    int\t\twidth = 0, height = 0;\n    char\t*error_msg = NULL;\n    char_u\t*bs_p, *del_p;\n\n    // In silect mode (ex -s) we don't use the 'term' option.\n    if (silent_mode)\n\treturn OK;\n\n    detected_8bit = FALSE;\t\t// reset 8-bit detection\n\n    if (term_is_builtin(term))\n    {\n\tterm += 8;\n#ifdef HAVE_TGETENT\n\tbuiltin_first = 1;\n#endif\n    }\n\n/*\n * If HAVE_TGETENT is not defined, only the builtin termcap is used, otherwise:\n *   If builtin_first is TRUE:\n *     0. try builtin termcap\n *     1. try external termcap\n *     2. if both fail default to a builtin terminal\n *   If builtin_first is FALSE:\n *     1. try external termcap\n *     2. try builtin termcap, if both fail default to a builtin terminal\n */\n#ifdef HAVE_TGETENT\n    for (try = builtin_first ? 0 : 1; try < 3; ++try)\n    {\n\t/*\n\t * Use external termcap\n\t */\n\tif (try == 1)\n\t{\n\t    char_u\t    tbuf[TBUFSZ];\n\n\t    /*\n\t     * If the external termcap does not have a matching entry, try the\n\t     * builtin ones.\n\t     */\n\t    if ((error_msg = invoke_tgetent(tbuf, term)) == NULL)\n\t    {\n\t\tif (!termcap_cleared)\n\t\t{\n\t\t    clear_termoptions();\t// clear old options\n\t\t    termcap_cleared = TRUE;\n\t\t}\n\n\t\tget_term_entries(&height, &width);\n\t    }\n\t}\n\telse\t    // try == 0 || try == 2\n#endif // HAVE_TGETENT\n\t/*\n\t * Use builtin termcap\n\t */\n\t{\n#ifdef HAVE_TGETENT\n\t    /*\n\t     * If builtin termcap was already used, there is no need to search\n\t     * for the builtin termcap again, quit now.\n\t     */\n\t    if (try == 2 && builtin_first && termcap_cleared)\n\t\tbreak;\n#endif\n\t    /*\n\t     * search for 'term' in builtin_termcaps[]\n\t     */\n\t    termp = find_builtin_term(term);\n\t    if (termp->bt_string == NULL)\t// did not find it\n\t    {\n#ifdef HAVE_TGETENT\n\t\t/*\n\t\t * If try == 0, first try the external termcap. If that is not\n\t\t * found we'll get back here with try == 2.\n\t\t * If termcap_cleared is set we used the external termcap,\n\t\t * don't complain about not finding the term in the builtin\n\t\t * termcap.\n\t\t */\n\t\tif (try == 0)\t\t\t// try external one\n\t\t    continue;\n\t\tif (termcap_cleared)\t\t// found in external termcap\n\t\t    break;\n#endif\n\t\treport_term_error(error_msg, term);\n\n\t\t// when user typed :set term=xxx, quit here\n\t\tif (starting != NO_SCREEN)\n\t\t{\n\t\t    screen_start();\t// don't know where cursor is now\n\t\t    wait_return(TRUE);\n\t\t    return FAIL;\n\t\t}\n\t\tterm = DEFAULT_TERM;\n\t\treport_default_term(term);\n\t\tset_string_option_direct((char_u *)\"term\", -1, term,\n\t\t\t\t\t\t\t\t OPT_FREE, 0);\n\t\tdisplay_errors();\n\t    }\n\t    out_flush();\n#ifdef HAVE_TGETENT\n\t    if (!termcap_cleared)\n\t    {\n#endif\n\t\tclear_termoptions();\t    // clear old options\n#ifdef HAVE_TGETENT\n\t\ttermcap_cleared = TRUE;\n\t    }\n#endif\n\t    parse_builtin_tcap(term);\n#ifdef FEAT_GUI\n\t    if (term_is_gui(term))\n\t    {\n\t\tout_flush();\n\t\tgui_init();\n\t\t// If starting the GUI failed, don't do any of the other\n\t\t// things for this terminal\n\t\tif (!gui.in_use)\n\t\t    return FAIL;\n#ifdef HAVE_TGETENT\n\t\tbreak;\t\t// don't try using external termcap\n#endif\n\t    }\n#endif // FEAT_GUI\n\t}\n#ifdef HAVE_TGETENT\n    }\n#endif\n\n/*\n * special: There is no info in the termcap about whether the cursor\n * positioning is relative to the start of the screen or to the start of the\n * scrolling region.  We just guess here. Only msdos pcterm is known to do it\n * relative.\n */\n    if (STRCMP(term, \"pcterm\") == 0)\n\tT_CCS = (char_u *)\"yes\";\n    else\n\tT_CCS = empty_option;\n\n#ifdef UNIX\n/*\n * Any \"stty\" settings override the default for t_kb from the termcap.\n * This is in os_unix.c, because it depends a lot on the version of unix that\n * is being used.\n * Don't do this when the GUI is active, it uses \"t_kb\" and \"t_kD\" directly.\n */\n# ifdef FEAT_GUI\n    if (!gui.in_use)\n# endif\n\tget_stty();\n#endif\n\n/*\n * If the termcap has no entry for 'bs' and/or 'del' and the ioctl() also\n * didn't work, use the default CTRL-H\n * The default for t_kD is DEL, unless t_kb is DEL.\n * The vim_strsave'd strings are probably lost forever, well it's only two\n * bytes.  Don't do this when the GUI is active, it uses \"t_kb\" and \"t_kD\"\n * directly.\n */\n#ifdef FEAT_GUI\n    if (!gui.in_use)\n#endif\n    {\n\tbs_p = find_termcode((char_u *)\"kb\");\n\tdel_p = find_termcode((char_u *)\"kD\");\n\tif (bs_p == NULL || *bs_p == NUL)\n\t    add_termcode((char_u *)\"kb\", (bs_p = (char_u *)CTRL_H_STR), FALSE);\n\tif ((del_p == NULL || *del_p == NUL) &&\n\t\t\t\t\t    (bs_p == NULL || *bs_p != DEL))\n\t    add_termcode((char_u *)\"kD\", (char_u *)DEL_STR, FALSE);\n    }\n\n#if defined(UNIX) || defined(VMS)\n    term_is_xterm = vim_is_xterm(term);\n#endif\n#ifdef FEAT_TERMRESPONSE\n    // Reset terminal properties that are set based on the termresponse, which\n    // will be sent out soon.\n    init_term_props(FALSE);\n#endif\n\n#if defined(UNIX) || defined(VMS)\n    /*\n     * For Unix, set the 'ttymouse' option to the type of mouse to be used.\n     * The termcode for the mouse is added as a side effect in option.c.\n     */\n    {\n\tchar_u\t*p = (char_u *)\"\";\n\n# ifdef FEAT_MOUSE_XTERM\n\tif (use_xterm_like_mouse(term))\n\t{\n\t    if (use_xterm_mouse())\n\t\tp = NULL;\t// keep existing value, might be \"xterm2\"\n\t    else\n\t\tp = (char_u *)\"xterm\";\n\t}\n# endif\n\tif (p != NULL)\n\t{\n\t    set_option_value_give_err((char_u *)\"ttym\", 0L, p, 0);\n\t    // Reset the WAS_SET flag, 'ttymouse' can be set to \"sgr\" or\n\t    // \"xterm2\" in check_termcode().\n\t    reset_option_was_set((char_u *)\"ttym\");\n\t}\n\tif (p == NULL\n#  ifdef FEAT_GUI\n\t\t|| gui.in_use\n#  endif\n\t\t)\n\t    check_mouse_termcode();\t// set mouse termcode anyway\n    }\n#else\n    set_mouse_termcode(KS_MOUSE, (char_u *)\"\\233M\");\n#endif\n\n#ifdef FEAT_MOUSE_XTERM\n    // Focus reporting is supported by xterm compatible terminals and tmux.\n    if (use_xterm_like_mouse(term))\n    {\n\tchar_u name[3];\n\n\t// handle focus in event\n\tname[0] = KS_EXTRA;\n\tname[1] = KE_FOCUSGAINED;\n\tname[2] = NUL;\n\tadd_termcode(name, (char_u *)\"\\033[I\", FALSE);\n\n\t// handle focus out event\n\tname[1] = KE_FOCUSLOST;\n\tadd_termcode(name, (char_u *)\"\\033[O\", FALSE);\n\n\tneed_gather = TRUE;\n    }\n#endif\n#if (defined(UNIX) || defined(VMS))\n    // First time after setting 'term' a focus event is always reported.\n    focus_state = MAYBE;\n#endif\n\n#ifdef USE_TERM_CONSOLE\n    // DEFAULT_TERM indicates that it is the machine console.\n    if (STRCMP(term, DEFAULT_TERM) != 0)\n\tterm_console = FALSE;\n    else\n    {\n\tterm_console = TRUE;\n# ifdef AMIGA\n\twin_resize_on();\t// enable window resizing reports\n# endif\n    }\n#endif\n\n#if defined(UNIX) || defined(VMS)\n    /*\n     * 'ttyfast' is default on for xterm, iris-ansi and a few others.\n     */\n    if (vim_is_fastterm(term))\n\tp_tf = TRUE;\n#endif\n#ifdef USE_TERM_CONSOLE\n    /*\n     * 'ttyfast' is default on consoles\n     */\n    if (term_console)\n\tp_tf = TRUE;\n#endif\n\n    ttest(TRUE);\t// make sure we have a valid set of terminal codes\n\n    full_screen = TRUE;\t\t// we can use termcap codes from now on\n    set_term_defaults();\t// use current values as defaults\n#ifdef FEAT_TERMRESPONSE\n    LOG_TR((\"setting crv_status to STATUS_GET\"));\n    crv_status.tr_progress = STATUS_GET;\t// Get terminal version later\n    write_t_8u_state = FALSE;\n#endif\n\n    /*\n     * Initialize the terminal with the appropriate termcap codes.\n     * Set the mouse and window title if possible.\n     * Don't do this when starting, need to parse the .vimrc first, because it\n     * may redefine t_TI etc.\n     */\n    if (starting != NO_SCREEN)\n    {\n\tstarttermcap();\t\t// may change terminal mode\n\tsetmouse();\t\t// may start using the mouse\n\tmaketitle();\t\t// may display window title\n    }\n\n\t// display initial screen after ttest() checking. jw.\n    if (width <= 0 || height <= 0)\n    {\n\t// termcap failed to report size\n\t// set defaults, in case ui_get_shellsize() also fails\n\twidth = 80;\n#if defined(MSWIN)\n\theight = 25;\t    // console is often 25 lines\n#else\n\theight = 24;\t    // most terminals are 24 lines\n#endif\n    }\n    set_shellsize(width, height, FALSE);\t// may change Rows\n    if (starting != NO_SCREEN)\n    {\n\tif (scroll_region)\n\t    scroll_region_reset();\t\t// In case Rows changed\n\tcheck_map_keycodes();\t// check mappings for terminal codes used\n\n\t{\n\t    buf_T\t*buf;\n\t    aco_save_T\taco;\n\n\t    /*\n\t     * Execute the TermChanged autocommands for each buffer that is\n\t     * loaded.\n\t     */\n\t    FOR_ALL_BUFFERS(buf)\n\t    {\n\t\tif (curbuf->b_ml.ml_mfp != NULL)\n\t\t{\n\t\t    aucmd_prepbuf(&aco, buf);\n\t\t    apply_autocmds(EVENT_TERMCHANGED, NULL, NULL, FALSE,\n\t\t\t\t\t\t\t\t      curbuf);\n\t\t    // restore curwin/curbuf and a few other things\n\t\t    aucmd_restbuf(&aco);\n\t\t}\n\t    }\n\t}\n    }\n\n#ifdef FEAT_TERMRESPONSE\n    may_req_termresponse();\n#endif\n\n    return OK;\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n\n# ifdef HAVE_DEL_CURTERM\n#  include <term.h>\t    // declares cur_term\n# endif\n\n/*\n * If supported, delete \"cur_term\", which caches terminal related entries.\n * Avoids that valgrind reports possibly lost memory.\n */\n    void\nfree_cur_term()\n{\n# ifdef HAVE_DEL_CURTERM\n    if (cur_term)\n\tdel_curterm(cur_term);\n# endif\n}\n\n#endif\n\n#ifdef HAVE_TGETENT\n/*\n * Call tgetent()\n * Return error message if it fails, NULL if it's OK.\n */\n    static char *\ninvoke_tgetent(char_u *tbuf, char_u *term)\n{\n    int\t    i;\n\n    // Note: Valgrind may report a leak here, because the library keeps one\n    // buffer around that we can't ever free.\n    i = TGETENT(tbuf, term);\n    if (i < 0\t\t    // -1 is always an error\n# ifdef TGETENT_ZERO_ERR\n\t    || i == 0\t    // sometimes zero is also an error\n# endif\n       )\n    {\n\t// On FreeBSD tputs() gets a SEGV after a tgetent() which fails.  Call\n\t// tgetent() with the always existing \"dumb\" entry to avoid a crash or\n\t// hang.\n\t(void)TGETENT(tbuf, \"dumb\");\n\n\tif (i < 0)\n# ifdef TGETENT_ZERO_ERR\n\t    return _(e_cannot_open_termcap_file);\n\tif (i == 0)\n# endif\n#ifdef TERMINFO\n\t    return _(e_terminal_entry_not_found_in_terminfo);\n#else\n\t    return _(e_terminal_entry_not_found_in_termcap);\n#endif\n    }\n    return NULL;\n}\n\n/*\n * Some versions of tgetstr() have been reported to return -1 instead of NULL.\n * Fix that here.\n */\n    static char_u *\nvim_tgetstr(char *s, char_u **pp)\n{\n    char\t*p;\n\n    p = tgetstr(s, (char **)pp);\n    if (p == (char *)-1)\n\tp = NULL;\n    return (char_u *)p;\n}\n#endif // HAVE_TGETENT\n\n#if defined(HAVE_TGETENT) && (defined(UNIX) || defined(VMS) || defined(MACOS_X))\n/*\n * Get Columns and Rows from the termcap. Used after a window signal if the\n * ioctl() fails. It doesn't make sense to call tgetent each time if the \"co\"\n * and \"li\" entries never change. But on some systems this works.\n * Errors while getting the entries are ignored.\n */\n    void\ngetlinecol(\n    long\t*cp,\t// pointer to columns\n    long\t*rp)\t// pointer to rows\n{\n    char_u\ttbuf[TBUFSZ];\n\n    if (T_NAME != NULL && *T_NAME != NUL && invoke_tgetent(tbuf, T_NAME) == NULL)\n    {\n\tif (*cp == 0)\n\t    *cp = tgetnum(\"co\");\n\tif (*rp == 0)\n\t    *rp = tgetnum(\"li\");\n    }\n}\n#endif // defined(HAVE_TGETENT) && defined(UNIX)\n\n/*\n * Get a string entry from the termcap and add it to the list of termcodes.\n * Used for <t_xx> special keys.\n * Give an error message for failure when not sourcing.\n * If force given, replace an existing entry.\n * Return FAIL if the entry was not found, OK if the entry was added.\n */\n    int\nadd_termcap_entry(char_u *name, int force)\n{\n    char_u  *term;\n    int\t    key;\n    struct builtin_term *termp;\n#ifdef HAVE_TGETENT\n    char_u  *string;\n    int\t    i;\n    int\t    builtin_first;\n    char_u  tbuf[TBUFSZ];\n    char_u  tstrbuf[TBUFSZ];\n    char_u  *tp = tstrbuf;\n    char    *error_msg = NULL;\n#endif\n\n/*\n * If the GUI is running or will start in a moment, we only support the keys\n * that the GUI can produce.\n */\n#ifdef FEAT_GUI\n    if (gui.in_use || gui.starting)\n\treturn gui_mch_haskey(name);\n#endif\n\n    if (!force && find_termcode(name) != NULL)\t    // it's already there\n\treturn OK;\n\n    term = T_NAME;\n    if (term == NULL || *term == NUL)\t    // 'term' not defined yet\n\treturn FAIL;\n\n    if (term_is_builtin(term))\t\t    // name starts with \"builtin_\"\n    {\n\tterm += 8;\n#ifdef HAVE_TGETENT\n\tbuiltin_first = TRUE;\n#endif\n    }\n#ifdef HAVE_TGETENT\n    else\n\tbuiltin_first = p_tbi;\n#endif\n\n#ifdef HAVE_TGETENT\n/*\n * We can get the entry from the builtin termcap and from the external one.\n * If 'ttybuiltin' is on or the terminal name starts with \"builtin_\", try\n * builtin termcap first.\n * If 'ttybuiltin' is off, try external termcap first.\n */\n    for (i = 0; i < 2; ++i)\n    {\n\tif ((!builtin_first) == i)\n#endif\n\t/*\n\t * Search in builtin termcap\n\t */\n\t{\n\t    termp = find_builtin_term(term);\n\t    if (termp->bt_string != NULL)\t// found it\n\t    {\n\t\tkey = TERMCAP2KEY(name[0], name[1]);\n\t\t++termp;\n\t\twhile (termp->bt_entry != (int)KS_NAME)\n\t\t{\n\t\t    if ((int)termp->bt_entry == key)\n\t\t    {\n\t\t\tadd_termcode(name, (char_u *)termp->bt_string,\n\t\t\t\t\t\t\t  term_is_8bit(term));\n\t\t\treturn OK;\n\t\t    }\n\t\t    ++termp;\n\t\t}\n\t    }\n\t}\n#ifdef HAVE_TGETENT\n\telse\n\t/*\n\t * Search in external termcap\n\t */\n\t{\n\t    error_msg = invoke_tgetent(tbuf, term);\n\t    if (error_msg == NULL)\n\t    {\n\t\tstring = TGETSTR((char *)name, &tp);\n\t\tif (string != NULL && *string != NUL)\n\t\t{\n\t\t    add_termcode(name, string, FALSE);\n\t\t    return OK;\n\t\t}\n\t    }\n\t}\n    }\n#endif\n\n    if (SOURCING_NAME == NULL)\n    {\n#ifdef HAVE_TGETENT\n\tif (error_msg != NULL)\n\t    emsg(error_msg);\n\telse\n#endif\n\t    semsg(_(e_no_str_entry_in_termcap), name);\n    }\n    return FAIL;\n}\n\n    static int\nterm_is_builtin(char_u *name)\n{\n    return (STRNCMP(name, \"builtin_\", (size_t)8) == 0);\n}\n\n/*\n * Return TRUE if terminal \"name\" uses CSI instead of <Esc>[.\n * Assume that the terminal is using 8-bit controls when the name contains\n * \"8bit\", like in \"xterm-8bit\".\n */\n    int\nterm_is_8bit(char_u *name)\n{\n    return (detected_8bit || strstr((char *)name, \"8bit\") != NULL);\n}\n\n/*\n * Translate terminal control chars from 7-bit to 8-bit:\n * <Esc>[ -> CSI  <M_C_[>\n * <Esc>] -> OSC  <M-C-]>\n * <Esc>O -> <M-C-O>\n */\n    static int\nterm_7to8bit(char_u *p)\n{\n    if (*p == ESC)\n    {\n\tif (p[1] == '[')\n\t    return CSI;\n\tif (p[1] == ']')\n\t    return OSC;\n\tif (p[1] == 'O')\n\t    return 0x8f;\n    }\n    return 0;\n}\n\n#if defined(FEAT_GUI) || defined(PROTO)\n    int\nterm_is_gui(char_u *name)\n{\n    return (STRCMP(name, \"builtin_gui\") == 0 || STRCMP(name, \"gui\") == 0);\n}\n#endif\n\n#if !defined(HAVE_TGETENT) || defined(AMIGA) || defined(PROTO)\n\n    char_u *\ntltoa(unsigned long i)\n{\n    static char_u buf[16];\n    char_u\t*p;\n\n    p = buf + 15;\n    *p = '\\0';\n    do\n    {\n\t--p;\n\t*p = (char_u) (i % 10 + '0');\n\ti /= 10;\n    }\n    while (i > 0 && p > buf);\n    return p;\n}\n#endif\n\n#ifndef HAVE_TGETENT\n\n/*\n * minimal tgoto() implementation.\n * no padding and we only parse for %i %d and %+char\n */\n    static char *\ntgoto(char *cm, int x, int y)\n{\n    static char buf[30];\n    char *p, *s, *e;\n\n    if (!cm)\n\treturn \"OOPS\";\n    e = buf + 29;\n    for (s = buf; s < e && *cm; cm++)\n    {\n\tif (*cm != '%')\n\t{\n\t    *s++ = *cm;\n\t    continue;\n\t}\n\tswitch (*++cm)\n\t{\n\tcase 'd':\n\t    p = (char *)tltoa((unsigned long)y);\n\t    y = x;\n\t    while (*p)\n\t\t*s++ = *p++;\n\t    break;\n\tcase 'i':\n\t    x++;\n\t    y++;\n\t    break;\n\tcase '+':\n\t    *s++ = (char)(*++cm + y);\n\t    y = x;\n\t    break;\n\tcase '%':\n\t    *s++ = *cm;\n\t    break;\n\tdefault:\n\t    return \"OOPS\";\n\t}\n    }\n    *s = '\\0';\n    return buf;\n}\n\n#endif // HAVE_TGETENT\n\n/*\n * Set the terminal name and initialize the terminal options.\n * If \"name\" is NULL or empty, get the terminal name from the environment.\n * If that fails, use the default terminal name.\n */\n    void\ntermcapinit(char_u *name)\n{\n    char_u\t*term;\n\n    if (name != NULL && *name == NUL)\n\tname = NULL;\t    // empty name is equal to no name\n    term = name;\n\n#ifndef MSWIN\n    if (term == NULL)\n\tterm = mch_getenv((char_u *)\"TERM\");\n#endif\n    if (term == NULL || *term == NUL)\n\tterm = DEFAULT_TERM;\n    set_string_option_direct((char_u *)\"term\", -1, term, OPT_FREE, 0);\n\n    // Set the default terminal name.\n    set_string_default(\"term\", term);\n    set_string_default(\"ttytype\", term);\n\n    /*\n     * Avoid using \"term\" here, because the next mch_getenv() may overwrite it.\n     */\n    set_termname(T_NAME != NULL ? T_NAME : term);\n}\n\n/*\n * The number of calls to ui_write is reduced by using \"out_buf\".\n */\n#define OUT_SIZE\t2047\n\n// add one to allow mch_write() in os_win32.c to append a NUL\nstatic char_u\t\tout_buf[OUT_SIZE + 1];\n\nstatic int\t\tout_pos = 0;\t// number of chars in out_buf\n\n// Since the maximum number of SGR parameters shown as a normal value range is\n// 16, the escape sequence length can be 4 * 16 + lead + tail.\n#define MAX_ESC_SEQ_LEN\t80\n\n/*\n * out_flush(): flush the output buffer\n */\n    void\nout_flush(void)\n{\n    int\t    len;\n\n    if (out_pos != 0)\n    {\n\t// set out_pos to 0 before ui_write, to avoid recursiveness\n\tlen = out_pos;\n\tout_pos = 0;\n\tui_write(out_buf, len, FALSE);\n#ifdef FEAT_JOB_CHANNEL\n\tif (ch_log_output != FALSE)\n\t{\n\t    out_buf[len] = NUL;\n\t    ch_log(NULL, \"raw %s output: \\\"%s\\\"\",\n# ifdef FEAT_GUI\n\t\t\t(gui.in_use && !gui.dying && !gui.starting) ? \"GUI\" :\n# endif\n\t\t\t\"terminal\",\n\t\t\tout_buf);\n\t    if (ch_log_output == TRUE)\n\t\tch_log_output = FALSE;  // only log once\n\t}\n#endif\n    }\n}\n\n/*\n * out_flush_cursor(): flush the output buffer and redraw the cursor.\n * Does not flush recursively in the GUI to avoid slow drawing.\n */\n    void\nout_flush_cursor(\n    int\t    force UNUSED,   // when TRUE, update cursor even when not moved\n    int\t    clear_selection UNUSED) // clear selection under cursor\n{\n    mch_disable_flush();\n    out_flush();\n    mch_enable_flush();\n#ifdef FEAT_GUI\n    if (gui.in_use)\n    {\n\tgui_update_cursor(force, clear_selection);\n\tgui_may_flush();\n    }\n#endif\n}\n\n\n/*\n * Sometimes a byte out of a multi-byte character is written with out_char().\n * To avoid flushing half of the character, call this function first.\n */\n    void\nout_flush_check(void)\n{\n    if (enc_dbcs != 0 && out_pos >= OUT_SIZE - MB_MAXBYTES)\n\tout_flush();\n}\n\n#ifdef FEAT_GUI\n/*\n * out_trash(): Throw away the contents of the output buffer\n */\n    void\nout_trash(void)\n{\n    out_pos = 0;\n}\n#endif\n\n/*\n * out_char(c): put a byte into the output buffer.\n *\t\tFlush it if it becomes full.\n * This should not be used for outputting text on the screen (use functions\n * like msg_puts() and screen_putchar() for that).\n */\n    void\nout_char(unsigned c)\n{\n#if defined(UNIX) || defined(VMS) || defined(AMIGA) || defined(MACOS_X)\n    if (c == '\\n')\t// turn LF into CR-LF (CRMOD doesn't seem to do this)\n\tout_char('\\r');\n#endif\n\n    out_buf[out_pos++] = c;\n\n    // For testing we flush each time.\n    if (out_pos >= OUT_SIZE || p_wd)\n\tout_flush();\n}\n\n/*\n * Output \"c\" like out_char(), but don't flush when p_wd is set.\n */\n    static int\nout_char_nf(int c)\n{\n    out_buf[out_pos++] = (unsigned)c;\n\n    if (out_pos >= OUT_SIZE)\n\tout_flush();\n    return (unsigned)c;\n}\n\n/*\n * A never-padding out_str().\n * Use this whenever you don't want to run the string through tputs().\n * tputs() above is harmless, but tputs() from the termcap library\n * is likely to strip off leading digits, that it mistakes for padding\n * information, and \"%i\", \"%d\", etc.\n * This should only be used for writing terminal codes, not for outputting\n * normal text (use functions like msg_puts() and screen_putchar() for that).\n */\n    void\nout_str_nf(char_u *s)\n{\n    // avoid terminal strings being split up\n    if (out_pos > OUT_SIZE - MAX_ESC_SEQ_LEN)\n\tout_flush();\n\n    while (*s)\n\tout_char_nf(*s++);\n\n    // For testing we write one string at a time.\n    if (p_wd)\n\tout_flush();\n}\n\n/*\n * A conditional-flushing out_str, mainly for visualbell.\n * Handles a delay internally, because termlib may not respect the delay or do\n * it at the wrong time.\n * Note: Only for terminal strings.\n */\n    void\nout_str_cf(char_u *s)\n{\n    if (s != NULL && *s)\n    {\n#ifdef HAVE_TGETENT\n\tchar_u *p;\n#endif\n\n#ifdef FEAT_GUI\n\t// Don't use tputs() when GUI is used, ncurses crashes.\n\tif (gui.in_use)\n\t{\n\t    out_str_nf(s);\n\t    return;\n\t}\n#endif\n\tif (out_pos > OUT_SIZE - MAX_ESC_SEQ_LEN)\n\t    out_flush();\n#ifdef HAVE_TGETENT\n\tfor (p = s; *s; ++s)\n\t{\n\t    // flush just before delay command\n\t    if (*s == '$' && *(s + 1) == '<')\n\t    {\n\t\tchar_u save_c = *s;\n\t\tint duration = atoi((char *)s + 2);\n\n\t\t*s = NUL;\n\t\ttputs((char *)p, 1, TPUTSFUNCAST out_char_nf);\n\t\t*s = save_c;\n\t\tout_flush();\n# ifdef ELAPSED_FUNC\n\t\t// Only sleep here if we can limit this happening in\n\t\t// vim_beep().\n\t\tp = vim_strchr(s, '>');\n\t\tif (p == NULL || duration <= 0)\n\t\t{\n\t\t    // can't parse the time, don't sleep here\n\t\t    p = s;\n\t\t}\n\t\telse\n\t\t{\n\t\t    ++p;\n\t\t    do_sleep(duration, FALSE);\n\t\t}\n# else\n\t\t// Rely on the terminal library to sleep.\n\t\tp = s;\n# endif\n\t\tbreak;\n\t    }\n\t}\n\ttputs((char *)p, 1, TPUTSFUNCAST out_char_nf);\n#else\n\twhile (*s)\n\t    out_char_nf(*s++);\n#endif\n\n\t// For testing we write one string at a time.\n\tif (p_wd)\n\t    out_flush();\n    }\n}\n\n/*\n * out_str(s): Put a character string a byte at a time into the output buffer.\n * If HAVE_TGETENT is defined use tputs(), the termcap parser. (jw)\n * This should only be used for writing terminal codes, not for outputting\n * normal text (use functions like msg_puts() and screen_putchar() for that).\n */\n    void\nout_str(char_u *s)\n{\n    if (s != NULL && *s)\n    {\n#ifdef FEAT_GUI\n\t// Don't use tputs() when GUI is used, ncurses crashes.\n\tif (gui.in_use)\n\t{\n\t    out_str_nf(s);\n\t    return;\n\t}\n#endif\n\t// avoid terminal strings being split up\n\tif (out_pos > OUT_SIZE - MAX_ESC_SEQ_LEN)\n\t    out_flush();\n#ifdef HAVE_TGETENT\n\ttputs((char *)s, 1, TPUTSFUNCAST out_char_nf);\n#else\n\twhile (*s)\n\t    out_char_nf(*s++);\n#endif\n\n\t// For testing we write one string at a time.\n\tif (p_wd)\n\t    out_flush();\n    }\n}\n\n/*\n * cursor positioning using termcap parser. (jw)\n */\n    void\nterm_windgoto(int row, int col)\n{\n    OUT_STR(tgoto((char *)T_CM, col, row));\n}\n\n    void\nterm_cursor_right(int i)\n{\n    OUT_STR(tgoto((char *)T_CRI, 0, i));\n}\n\n    void\nterm_append_lines(int line_count)\n{\n    OUT_STR(tgoto((char *)T_CAL, 0, line_count));\n}\n\n    void\nterm_delete_lines(int line_count)\n{\n    OUT_STR(tgoto((char *)T_CDL, 0, line_count));\n}\n\n#if defined(HAVE_TGETENT) || defined(PROTO)\n    void\nterm_set_winpos(int x, int y)\n{\n    // Can't handle a negative value here\n    if (x < 0)\n\tx = 0;\n    if (y < 0)\n\ty = 0;\n    OUT_STR(tgoto((char *)T_CWP, y, x));\n}\n\n# if defined(FEAT_TERMRESPONSE) || defined(PROTO)\n/*\n * Return TRUE if we can request the terminal for a response.\n */\n    static int\ncan_get_termresponse()\n{\n    return cur_tmode == TMODE_RAW\n\t    && termcap_active\n#  ifdef UNIX\n\t    && (is_not_a_term() || (isatty(1) && isatty(read_cmd_fd)))\n#  endif\n\t    && p_ek;\n}\n\n/*\n * Set \"status\" to STATUS_SENT.\n */\n    static void\ntermrequest_sent(termrequest_T *status)\n{\n    status->tr_progress = STATUS_SENT;\n    status->tr_start = time(NULL);\n}\n\n/*\n * Return TRUE if any of the requests are in STATUS_SENT.\n */\n    static int\ntermrequest_any_pending()\n{\n    int\t    i;\n    time_t  now = time(NULL);\n\n    for (i = 0; all_termrequests[i] != NULL; ++i)\n    {\n\tif (all_termrequests[i]->tr_progress == STATUS_SENT)\n\t{\n\t    if (all_termrequests[i]->tr_start > 0 && now > 0\n\t\t\t\t    && all_termrequests[i]->tr_start + 2 < now)\n\t\t// Sent the request more than 2 seconds ago and didn't get a\n\t\t// response, assume it failed.\n\t\tall_termrequests[i]->tr_progress = STATUS_FAIL;\n\t    else\n\t\treturn TRUE;\n\t}\n    }\n    return FALSE;\n}\n\nstatic int winpos_x = -1;\nstatic int winpos_y = -1;\nstatic int did_request_winpos = 0;\n\n# if defined(FEAT_EVAL) || defined(FEAT_TERMINAL) || defined(PROTO)\n/*\n * Try getting the Vim window position from the terminal.\n * Returns OK or FAIL.\n */\n    int\nterm_get_winpos(int *x, int *y, varnumber_T timeout)\n{\n    int count = 0;\n    int prev_winpos_x = winpos_x;\n    int prev_winpos_y = winpos_y;\n\n    if (*T_CGP == NUL || !can_get_termresponse())\n\treturn FAIL;\n    winpos_x = -1;\n    winpos_y = -1;\n    ++did_request_winpos;\n    termrequest_sent(&winpos_status);\n    OUT_STR(T_CGP);\n    out_flush();\n\n    // Try reading the result for \"timeout\" msec.\n    while (count++ <= timeout / 10 && !got_int)\n    {\n\t(void)vpeekc_nomap();\n\tif (winpos_x >= 0 && winpos_y >= 0)\n\t{\n\t    *x = winpos_x;\n\t    *y = winpos_y;\n\t    return OK;\n\t}\n\tui_delay(10L, FALSE);\n    }\n    // Do not reset \"did_request_winpos\", if we timed out the response might\n    // still come later and we must consume it.\n\n    winpos_x = prev_winpos_x;\n    winpos_y = prev_winpos_y;\n    if (timeout < 10 && prev_winpos_y >= 0 && prev_winpos_x >= 0)\n    {\n\t// Polling: return previous values if we have them.\n\t*x = winpos_x;\n\t*y = winpos_y;\n\treturn OK;\n    }\n\n    return FALSE;\n}\n#  endif\n# endif\n\n    void\nterm_set_winsize(int height, int width)\n{\n    OUT_STR(tgoto((char *)T_CWS, width, height));\n}\n#endif\n\n    static void\nterm_color(char_u *s, int n)\n{\n    char\tbuf[20];\n    int\t\ti = *s == CSI ? 1 : 2;\n\t\t// index in s[] just after <Esc>[ or CSI\n\n    // Special handling of 16 colors, because termcap can't handle it\n    // Also accept \"\\e[3%dm\" for TERMINFO, it is sometimes used\n    // Also accept CSI instead of <Esc>[\n    if (n >= 8 && t_colors >= 16\n\t      && ((s[0] == ESC && s[1] == '[')\n#if defined(FEAT_VTP) && defined(FEAT_TERMGUICOLORS)\n\t\t  || (s[0] == ESC && s[1] == '|')\n#endif\n\t\t  || (s[0] == CSI && (i = 1) == 1))\n\t      && s[i] != NUL\n\t      && (STRCMP(s + i + 1, \"%p1%dm\") == 0\n\t\t  || STRCMP(s + i + 1, \"%dm\") == 0)\n\t      && (s[i] == '3' || s[i] == '4'))\n    {\n#ifdef TERMINFO\n\tchar *format = \"%s%s%%p1%%dm\";\n#else\n\tchar *format = \"%s%s%%dm\";\n#endif\n\tchar *lead = i == 2 ? (\n#if defined(FEAT_VTP) && defined(FEAT_TERMGUICOLORS)\n\t\t    s[1] == '|' ? \"\\033|\" :\n#endif\n\t\t    \"\\033[\") : \"\\233\";\n\tchar *tail = s[i] == '3' ? (n >= 16 ? \"38;5;\" : \"9\")\n\t\t\t\t : (n >= 16 ? \"48;5;\" : \"10\");\n\n\tsprintf(buf, format, lead, tail);\n\tOUT_STR(tgoto(buf, 0, n >= 16 ? n : n - 8));\n    }\n    else\n\tOUT_STR(tgoto((char *)s, 0, n));\n}\n\n    void\nterm_fg_color(int n)\n{\n    // Use \"AF\" termcap entry if present, \"Sf\" entry otherwise\n    if (*T_CAF)\n\tterm_color(T_CAF, n);\n    else if (*T_CSF)\n\tterm_color(T_CSF, n);\n}\n\n    void\nterm_bg_color(int n)\n{\n    // Use \"AB\" termcap entry if present, \"Sb\" entry otherwise\n    if (*T_CAB)\n\tterm_color(T_CAB, n);\n    else if (*T_CSB)\n\tterm_color(T_CSB, n);\n}\n\n    void\nterm_ul_color(int n)\n{\n    if (*T_CAU)\n\tterm_color(T_CAU, n);\n}\n\n/*\n * Return \"dark\" or \"light\" depending on the kind of terminal.\n * This is just guessing!  Recognized are:\n * \"linux\"\t    Linux console\n * \"screen.linux\"   Linux console with screen\n * \"cygwin.*\"\t    Cygwin shell\n * \"putty.*\"\t    Putty program\n * We also check the COLORFGBG environment variable, which is set by\n * rxvt and derivatives. This variable contains either two or three\n * values separated by semicolons; we want the last value in either\n * case. If this value is 0-6 or 8, our background is dark.\n */\n    char_u *\nterm_bg_default(void)\n{\n#if defined(MSWIN)\n    // DOS console is nearly always black\n    return (char_u *)\"dark\";\n#else\n    char_u\t*p;\n\n    if (STRCMP(T_NAME, \"linux\") == 0\n\t    || STRCMP(T_NAME, \"screen.linux\") == 0\n\t    || STRNCMP(T_NAME, \"cygwin\", 6) == 0\n\t    || STRNCMP(T_NAME, \"putty\", 5) == 0\n\t    || ((p = mch_getenv((char_u *)\"COLORFGBG\")) != NULL\n\t\t&& (p = vim_strrchr(p, ';')) != NULL\n\t\t&& ((p[1] >= '0' && p[1] <= '6') || p[1] == '8')\n\t\t&& p[2] == NUL))\n\treturn (char_u *)\"dark\";\n    return (char_u *)\"light\";\n#endif\n}\n\n#if defined(FEAT_TERMGUICOLORS) || defined(PROTO)\n\n#define RED(rgb)   (((long_u)(rgb) >> 16) & 0xFF)\n#define GREEN(rgb) (((long_u)(rgb) >>  8) & 0xFF)\n#define BLUE(rgb)  (((long_u)(rgb)      ) & 0xFF)\n\n    static void\nterm_rgb_color(char_u *s, guicolor_T rgb)\n{\n#define MAX_COLOR_STR_LEN 100\n    char\tbuf[MAX_COLOR_STR_LEN];\n\n    if (*s == NUL)\n\treturn;\n    vim_snprintf(buf, MAX_COLOR_STR_LEN,\n\t\t\t\t  (char *)s, RED(rgb), GREEN(rgb), BLUE(rgb));\n#ifdef FEAT_VTP\n    if (use_wt())\n    {\n\tout_flush();\n\tbuf[1] = '[';\n\tvtp_printf(buf);\n    }\n    else\n#endif\n\tOUT_STR(buf);\n}\n\n    void\nterm_fg_rgb_color(guicolor_T rgb)\n{\n    term_rgb_color(T_8F, rgb);\n}\n\n    void\nterm_bg_rgb_color(guicolor_T rgb)\n{\n    if (rgb != INVALCOLOR)\n\tterm_rgb_color(T_8B, rgb);\n}\n\n    void\nterm_ul_rgb_color(guicolor_T rgb)\n{\n# ifdef FEAT_TERMRESPONSE\n    if (write_t_8u_state != OK)\n\twrite_t_8u_state = MAYBE;\n    else\n# endif\n\tterm_rgb_color(T_8U, rgb);\n}\n#endif\n\n#if (defined(UNIX) || defined(VMS) || defined(MACOS_X)) || defined(PROTO)\n/*\n * Generic function to set window title, using t_ts and t_fs.\n */\n    void\nterm_settitle(char_u *title)\n{\n    MAY_WANT_TO_LOG_THIS;\n\n    // t_ts takes one argument: column in status line\n    OUT_STR(tgoto((char *)T_TS, 0, 0));\t// set title start\n    out_str_nf(title);\n    out_str(T_FS);\t\t\t// set title end\n    out_flush();\n}\n\n/*\n * Tell the terminal to push (save) the title and/or icon, so that it can be\n * popped (restored) later.\n */\n    void\nterm_push_title(int which)\n{\n    if ((which & SAVE_RESTORE_TITLE) && T_CST != NULL && *T_CST != NUL)\n    {\n\tOUT_STR(T_CST);\n\tout_flush();\n    }\n\n    if ((which & SAVE_RESTORE_ICON) && T_SSI != NULL && *T_SSI != NUL)\n    {\n\tOUT_STR(T_SSI);\n\tout_flush();\n    }\n}\n\n/*\n * Tell the terminal to pop the title and/or icon.\n */\n    void\nterm_pop_title(int which)\n{\n    if ((which & SAVE_RESTORE_TITLE) && T_CRT != NULL && *T_CRT != NUL)\n    {\n\tOUT_STR(T_CRT);\n\tout_flush();\n    }\n\n    if ((which & SAVE_RESTORE_ICON) && T_SRI != NULL && *T_SRI != NUL)\n    {\n\tOUT_STR(T_SRI);\n\tout_flush();\n    }\n}\n#endif\n\n/*\n * Make sure we have a valid set or terminal options.\n * Replace all entries that are NULL by empty_option\n */\n    void\nttest(int pairs)\n{\n    char_u *env_colors;\n\n    check_options();\t\t    // make sure no options are NULL\n\n    /*\n     * MUST have \"cm\": cursor motion.\n     */\n    if (*T_CM == NUL)\n\temsg(_(e_terminal_capability_cm_required));\n\n    /*\n     * if \"cs\" defined, use a scroll region, it's faster.\n     */\n    if (*T_CS != NUL)\n\tscroll_region = TRUE;\n    else\n\tscroll_region = FALSE;\n\n    if (pairs)\n    {\n\t/*\n\t * optional pairs\n\t */\n\t// TP goes to normal mode for TI (invert) and TB (bold)\n\tif (*T_ME == NUL)\n\t    T_ME = T_MR = T_MD = T_MB = empty_option;\n\tif (*T_SO == NUL || *T_SE == NUL)\n\t    T_SO = T_SE = empty_option;\n\tif (*T_US == NUL || *T_UE == NUL)\n\t    T_US = T_UE = empty_option;\n\tif (*T_CZH == NUL || *T_CZR == NUL)\n\t    T_CZH = T_CZR = empty_option;\n\n\t// T_VE is needed even though T_VI is not defined\n\tif (*T_VE == NUL)\n\t    T_VI = empty_option;\n\n\t// if 'mr' or 'me' is not defined use 'so' and 'se'\n\tif (*T_ME == NUL)\n\t{\n\t    T_ME = T_SE;\n\t    T_MR = T_SO;\n\t    T_MD = T_SO;\n\t}\n\n\t// if 'so' or 'se' is not defined use 'mr' and 'me'\n\tif (*T_SO == NUL)\n\t{\n\t    T_SE = T_ME;\n\t    if (*T_MR == NUL)\n\t\tT_SO = T_MD;\n\t    else\n\t\tT_SO = T_MR;\n\t}\n\n\t// if 'ZH' or 'ZR' is not defined use 'mr' and 'me'\n\tif (*T_CZH == NUL)\n\t{\n\t    T_CZR = T_ME;\n\t    if (*T_MR == NUL)\n\t\tT_CZH = T_MD;\n\t    else\n\t\tT_CZH = T_MR;\n\t}\n\n\t// \"Sb\" and \"Sf\" come in pairs\n\tif (*T_CSB == NUL || *T_CSF == NUL)\n\t{\n\t    T_CSB = empty_option;\n\t    T_CSF = empty_option;\n\t}\n\n\t// \"AB\" and \"AF\" come in pairs\n\tif (*T_CAB == NUL || *T_CAF == NUL)\n\t{\n\t    T_CAB = empty_option;\n\t    T_CAF = empty_option;\n\t}\n\n\t// if 'Sb' and 'AB' are not defined, reset \"Co\"\n\tif (*T_CSB == NUL && *T_CAB == NUL)\n\t    free_one_termoption(T_CCO);\n\n\t// Set 'weirdinvert' according to value of 't_xs'\n\tp_wiv = (*T_XS != NUL);\n    }\n    need_gather = TRUE;\n\n    // Set t_colors to the value of $COLORS or t_Co.  Ignore $COLORS in the\n    // GUI.\n    t_colors = atoi((char *)T_CCO);\n#ifdef FEAT_GUI\n    if (!gui.in_use)\n#endif\n    {\n\tenv_colors = mch_getenv((char_u *)\"COLORS\");\n\tif (env_colors != NULL && isdigit(*env_colors))\n\t{\n\t    int colors = atoi((char *)env_colors);\n\n\t    if (colors != t_colors)\n\t\tset_color_count(colors);\n\t}\n    }\n}\n\n#if (defined(FEAT_GUI) && (defined(FEAT_MENU) || !defined(USE_ON_FLY_SCROLL))) \\\n\t|| defined(PROTO)\n/*\n * Represent the given long_u as individual bytes, with the most significant\n * byte first, and store them in dst.\n */\n    void\nadd_long_to_buf(long_u val, char_u *dst)\n{\n    int\t    i;\n    int\t    shift;\n\n    for (i = 1; i <= (int)sizeof(long_u); i++)\n    {\n\tshift = 8 * (sizeof(long_u) - i);\n\tdst[i - 1] = (char_u) ((val >> shift) & 0xff);\n    }\n}\n\n/*\n * Interpret the next string of bytes in buf as a long integer, with the most\n * significant byte first.  Note that it is assumed that buf has been through\n * inchar(), so that NUL and K_SPECIAL will be represented as three bytes each.\n * Puts result in val, and returns the number of bytes read from buf\n * (between sizeof(long_u) and 2 * sizeof(long_u)), or -1 if not enough bytes\n * were present.\n */\n    static int\nget_long_from_buf(char_u *buf, long_u *val)\n{\n    int\t    len;\n    char_u  bytes[sizeof(long_u)];\n    int\t    i;\n    int\t    shift;\n\n    *val = 0;\n    len = get_bytes_from_buf(buf, bytes, (int)sizeof(long_u));\n    if (len != -1)\n    {\n\tfor (i = 0; i < (int)sizeof(long_u); i++)\n\t{\n\t    shift = 8 * (sizeof(long_u) - 1 - i);\n\t    *val += (long_u)bytes[i] << shift;\n\t}\n    }\n    return len;\n}\n#endif\n\n/*\n * Read the next num_bytes bytes from buf, and store them in bytes.  Assume\n * that buf has been through inchar().\tReturns the actual number of bytes used\n * from buf (between num_bytes and num_bytes*2), or -1 if not enough bytes were\n * available.\n */\n    int\nget_bytes_from_buf(char_u *buf, char_u *bytes, int num_bytes)\n{\n    int\t    len = 0;\n    int\t    i;\n    char_u  c;\n\n    for (i = 0; i < num_bytes; i++)\n    {\n\tif ((c = buf[len++]) == NUL)\n\t    return -1;\n\tif (c == K_SPECIAL)\n\t{\n\t    if (buf[len] == NUL || buf[len + 1] == NUL)\t    // cannot happen?\n\t\treturn -1;\n\t    if (buf[len++] == (int)KS_ZERO)\n\t\tc = NUL;\n\t    // else it should be KS_SPECIAL; when followed by KE_FILLER c is\n\t    // K_SPECIAL, or followed by KE_CSI and c must be CSI.\n\t    if (buf[len++] == (int)KE_CSI)\n\t\tc = CSI;\n\t}\n\telse if (c == CSI && buf[len] == KS_EXTRA\n\t\t\t\t\t       && buf[len + 1] == (int)KE_CSI)\n\t    // CSI is stored as CSI KS_SPECIAL KE_CSI to avoid confusion with\n\t    // the start of a special key, see add_to_input_buf_csi().\n\t    len += 2;\n\tbytes[i] = c;\n    }\n    return len;\n}\n\n/*\n * Check if the new shell size is valid, correct it if it's too small or way\n * too big.\n */\n    void\ncheck_shellsize(void)\n{\n    if (Rows < min_rows())\t// need room for one window and command line\n\tRows = min_rows();\n    limit_screen_size();\n}\n\n/*\n * Limit Rows and Columns to avoid an overflow in Rows * Columns.\n */\n    void\nlimit_screen_size(void)\n{\n    if (Columns < MIN_COLUMNS)\n\tColumns = MIN_COLUMNS;\n    else if (Columns > 10000)\n\tColumns = 10000;\n    if (Rows > 1000)\n\tRows = 1000;\n}\n\n/*\n * Invoked just before the screen structures are going to be (re)allocated.\n */\n    void\nwin_new_shellsize(void)\n{\n    static int\told_Rows = 0;\n    static int\told_Columns = 0;\n\n    if (old_Rows != Rows || old_Columns != Columns)\n\tui_new_shellsize();\n    if (old_Rows != Rows)\n    {\n\t// If 'window' uses the whole screen, keep it using that.\n\t// Don't change it when set with \"-w size\" on the command line.\n\tif (p_window == old_Rows - 1\n\t\t    || (old_Rows == 0 && !option_was_set((char_u *)\"window\")))\n\t    p_window = Rows - 1;\n\told_Rows = Rows;\n\tshell_new_rows();\t// update window sizes\n    }\n    if (old_Columns != Columns)\n    {\n\told_Columns = Columns;\n\tshell_new_columns();\t// update window sizes\n    }\n}\n\n/*\n * Call this function when the Vim shell has been resized in any way.\n * Will obtain the current size and redraw (also when size didn't change).\n */\n    void\nshell_resized(void)\n{\n    set_shellsize(0, 0, FALSE);\n}\n\n/*\n * Check if the shell size changed.  Handle a resize.\n * When the size didn't change, nothing happens.\n */\n    void\nshell_resized_check(void)\n{\n    int\t\told_Rows = Rows;\n    int\t\told_Columns = Columns;\n\n    if (!exiting\n#ifdef FEAT_GUI\n\t    // Do not get the size when executing a shell command during\n\t    // startup.\n\t    && !gui.starting\n#endif\n\t    )\n    {\n\t(void)ui_get_shellsize();\n\tcheck_shellsize();\n\tif (old_Rows != Rows || old_Columns != Columns)\n\t    shell_resized();\n    }\n}\n\n/*\n * Set size of the Vim shell.\n * If 'mustset' is TRUE, we must set Rows and Columns, do not get the real\n * window size (this is used for the :win command).\n * If 'mustset' is FALSE, we may try to get the real window size and if\n * it fails use 'width' and 'height'.\n */\n    void\nset_shellsize(int width, int height, int mustset)\n{\n    static int\t\tbusy = FALSE;\n\n    /*\n     * Avoid recursiveness, can happen when setting the window size causes\n     * another window-changed signal.\n     */\n    if (busy)\n\treturn;\n\n    if (width < 0 || height < 0)    // just checking...\n\treturn;\n\n    if (State == MODE_HITRETURN || State == MODE_SETWSIZE)\n    {\n\t// postpone the resizing\n\tState = MODE_SETWSIZE;\n\treturn;\n    }\n\n    if (updating_screen)\n\t// resizing while in update_screen() may cause a crash\n\treturn;\n\n    // curwin->w_buffer can be NULL when we are closing a window and the\n    // buffer (or window) has already been closed and removing a scrollbar\n    // causes a resize event. Don't resize then, it will happen after entering\n    // another buffer.\n    if (curwin->w_buffer == NULL || curwin->w_lines == NULL)\n\treturn;\n\n    ++busy;\n\n#ifdef AMIGA\n    out_flush();\t    // must do this before mch_get_shellsize() for\n\t\t\t    // some obscure reason\n#endif\n\n    if (mustset || (ui_get_shellsize() == FAIL && height != 0))\n    {\n\tRows = height;\n\tColumns = width;\n\tcheck_shellsize();\n\tui_set_shellsize(mustset);\n    }\n    else\n\tcheck_shellsize();\n\n    // The window layout used to be adjusted here, but it now happens in\n    // screenalloc() (also invoked from screenclear()).  That is because the\n    // \"busy\" check above may skip this, but not screenalloc().\n\n    if (State != MODE_ASKMORE && State != MODE_EXTERNCMD\n\t\t\t\t\t\t      && State != MODE_CONFIRM)\n\tscreenclear();\n    else\n\tscreen_start();\t    // don't know where cursor is now\n\n    if (starting != NO_SCREEN)\n    {\n\tmaketitle();\n\n\tchanged_line_abv_curs();\n\tinvalidate_botline();\n\n\t/*\n\t * We only redraw when it's needed:\n\t * - While at the more prompt or executing an external command, don't\n\t *   redraw, but position the cursor.\n\t * - While editing the command line, only redraw that.\n\t * - in Ex mode, don't redraw anything.\n\t * - Otherwise, redraw right now, and position the cursor.\n\t * Always need to call update_screen() or screenalloc(), to make\n\t * sure Rows/Columns and the size of ScreenLines[] is correct!\n\t */\n\tif (State == MODE_ASKMORE || State == MODE_EXTERNCMD\n\t\t\t\t     || State == MODE_CONFIRM || exmode_active)\n\t{\n\t    screenalloc(FALSE);\n\t    repeat_message();\n\t}\n\telse\n\t{\n\t    if (curwin->w_p_scb)\n\t\tdo_check_scrollbind(TRUE);\n\t    if (State & MODE_CMDLINE)\n\t    {\n\t\tupdate_screen(NOT_VALID);\n\t\tredrawcmdline();\n\t    }\n\t    else\n\t    {\n\t\tupdate_topline();\n\t\tif (pum_visible())\n\t\t{\n\t\t    redraw_later(NOT_VALID);\n\t\t    ins_compl_show_pum();\n\t\t}\n\t\tupdate_screen(NOT_VALID);\n\t\tif (redrawing())\n\t\t    setcursor();\n\t    }\n\t}\n\tcursor_on();\t    // redrawing may have switched it off\n    }\n    out_flush();\n    --busy;\n}\n\n/*\n * Set the terminal to TMODE_RAW (for Normal mode) or TMODE_COOK (for external\n * commands and Ex mode).\n */\n    void\nsettmode(tmode_T tmode)\n{\n#ifdef FEAT_GUI\n    // don't set the term where gvim was started to any mode\n    if (gui.in_use)\n\treturn;\n#endif\n\n    if (full_screen)\n    {\n\t/*\n\t * When returning after calling a shell cur_tmode is TMODE_UNKNOWN,\n\t * set the terminal to raw mode, even though we think it already is,\n\t * because the shell program may have reset the terminal mode.\n\t * When we think the terminal is normal, don't try to set it to\n\t * normal again, because that causes problems (logout!) on some\n\t * machines.\n\t */\n\tif (tmode != cur_tmode)\n\t{\n#ifdef FEAT_TERMRESPONSE\n# ifdef FEAT_GUI\n\t    if (!gui.in_use && !gui.starting)\n# endif\n\t    {\n\t\t// May need to check for T_CRV response and termcodes, it\n\t\t// doesn't work in Cooked mode, an external program may get\n\t\t// them.\n\t\tif (tmode != TMODE_RAW && termrequest_any_pending())\n\t\t    (void)vpeekc_nomap();\n\t\tcheck_for_codes_from_term();\n\t    }\n#endif\n\t    if (tmode != TMODE_RAW)\n\t\tmch_setmouse(FALSE);\t// switch mouse off\n\n\t    // Disable bracketed paste and modifyOtherKeys in cooked mode.\n\t    // Avoid doing this too often, on some terminals the codes are not\n\t    // handled properly.\n\t    if (termcap_active && tmode != TMODE_SLEEP\n\t\t\t\t\t\t   && cur_tmode != TMODE_SLEEP)\n\t    {\n\t\tMAY_WANT_TO_LOG_THIS;\n\n\t\tif (tmode != TMODE_RAW)\n\t\t{\n\t\t    out_str(T_BD);\t// disable bracketed paste mode\n\t\t    out_str(T_CTE);\t// possibly disables modifyOtherKeys\n\t\t}\n\t\telse\n\t\t{\n\t\t    out_str(T_BE);\t// enable bracketed paste mode (should\n\t\t\t\t\t// be before mch_settmode().\n\t\t    out_str(T_CTI);\t// possibly enables modifyOtherKeys\n\t\t}\n\t    }\n\t    out_flush();\n\t    mch_settmode(tmode);\t// machine specific function\n\t    cur_tmode = tmode;\n\t    if (tmode == TMODE_RAW)\n\t\tsetmouse();\t\t// may switch mouse on\n\t    out_flush();\n\t}\n#ifdef FEAT_TERMRESPONSE\n\tmay_req_termresponse();\n#endif\n    }\n}\n\n    void\nstarttermcap(void)\n{\n    if (full_screen && !termcap_active)\n    {\n\tMAY_WANT_TO_LOG_THIS;\n\n\tout_str(T_TI);\t\t\t// start termcap mode\n\tout_str(T_CTI);\t\t\t// start \"raw\" mode\n\tout_str(T_KS);\t\t\t// start \"keypad transmit\" mode\n\tout_str(T_BE);\t\t\t// enable bracketed paste mode\n\n#if defined(UNIX) || defined(VMS)\n\t// Enable xterm's focus reporting mode when 'esckeys' is set.\n\tif (p_ek && *T_FE != NUL)\n\t    out_str(T_FE);\n#endif\n\n\tout_flush();\n\ttermcap_active = TRUE;\n\tscreen_start();\t\t\t// don't know where cursor is now\n#ifdef FEAT_TERMRESPONSE\n# ifdef FEAT_GUI\n\tif (!gui.in_use && !gui.starting)\n# endif\n\t{\n\t    may_req_termresponse();\n\t    // Immediately check for a response.  If t_Co changes, we don't\n\t    // want to redraw with wrong colors first.\n\t    if (crv_status.tr_progress == STATUS_SENT)\n\t\tcheck_for_codes_from_term();\n\t}\n#endif\n    }\n}\n\n    void\nstoptermcap(void)\n{\n    screen_stop_highlight();\n    reset_cterm_colors();\n    if (termcap_active)\n    {\n#ifdef FEAT_TERMRESPONSE\n# ifdef FEAT_GUI\n\tif (!gui.in_use && !gui.starting)\n# endif\n\t{\n\t    // May need to discard T_CRV, T_U7 or T_RBG response.\n\t    if (termrequest_any_pending())\n\t    {\n# ifdef UNIX\n\t\t// Give the terminal a chance to respond.\n\t\tmch_delay(100L, 0);\n# endif\n# ifdef TCIFLUSH\n\t\t// Discard data received but not read.\n\t\tif (exiting)\n\t\t    tcflush(fileno(stdin), TCIFLUSH);\n# endif\n\t    }\n\t    // Check for termcodes first, otherwise an external program may\n\t    // get them.\n\t    check_for_codes_from_term();\n\t}\n#endif\n\tMAY_WANT_TO_LOG_THIS;\n\n#if defined(UNIX) || defined(VMS)\n\t// Disable xterm's focus reporting mode if 'esckeys' is set.\n\tif (p_ek && *T_FD != NUL)\n\t    out_str(T_FD);\n#endif\n\n\tout_str(T_BD);\t\t\t// disable bracketed paste mode\n\tout_str(T_KE);\t\t\t// stop \"keypad transmit\" mode\n\tout_flush();\n\ttermcap_active = FALSE;\n\tcursor_on();\t\t\t// just in case it is still off\n\tout_str(T_CTE);\t\t\t// stop \"raw\" mode\n\tout_str(T_TE);\t\t\t// stop termcap mode\n\tscreen_start();\t\t\t// don't know where cursor is now\n\tout_flush();\n    }\n}\n\n#if defined(FEAT_TERMRESPONSE) || defined(PROTO)\n/*\n * Request version string (for xterm) when needed.\n * Only do this after switching to raw mode, otherwise the result will be\n * echoed.\n * Only do this after startup has finished, to avoid that the response comes\n * while executing \"-c !cmd\" or even after \"-c quit\".\n * Only do this after termcap mode has been started, otherwise the codes for\n * the cursor keys may be wrong.\n * Only do this when 'esckeys' is on, otherwise the response causes trouble in\n * Insert mode.\n * On Unix only do it when both output and input are a tty (avoid writing\n * request to terminal while reading from a file).\n * The result is caught in check_termcode().\n */\n    void\nmay_req_termresponse(void)\n{\n    if (crv_status.tr_progress == STATUS_GET\n\t    && can_get_termresponse()\n\t    && starting == 0\n\t    && *T_CRV != NUL)\n    {\n\tMAY_WANT_TO_LOG_THIS;\n\tLOG_TR((\"Sending CRV request\"));\n\tout_str(T_CRV);\n\ttermrequest_sent(&crv_status);\n\t// check for the characters now, otherwise they might be eaten by\n\t// get_keystroke()\n\tout_flush();\n\t(void)vpeekc_nomap();\n    }\n}\n\n/*\n * Send sequences to the terminal and check with t_u7 how the cursor moves, to\n * find out properties of the terminal.\n * Note that this goes out before T_CRV, so that the result can be used when\n * the termresponse arrives.\n */\n    void\ncheck_terminal_behavior(void)\n{\n    int\t    did_send = FALSE;\n\n    if (!can_get_termresponse() || starting != 0 || *T_U7 == NUL)\n\treturn;\n\n    if (u7_status.tr_progress == STATUS_GET\n\t    && !option_was_set((char_u *)\"ambiwidth\"))\n    {\n\tchar_u\tbuf[16];\n\n\t// Ambiguous width check.\n\t// Check how the terminal treats ambiguous character width (UAX #11).\n\t// First, we move the cursor to (1, 0) and print a test ambiguous\n\t// character \\u25bd (WHITE DOWN-POINTING TRIANGLE) and then query\n\t// the current cursor position.  If the terminal treats \\u25bd as\n\t// single width, the position is (1, 1), or if it is treated as double\n\t// width, that will be (1, 2).  This function has the side effect that\n\t// changes cursor position, so it must be called immediately after\n\t// entering termcap mode.\n\tMAY_WANT_TO_LOG_THIS;\n\tLOG_TR((\"Sending request for ambiwidth check\"));\n\t// Do this in the second row.  In the first row the returned sequence\n\t// may be CSI 1;2R, which is the same as <S-F3>.\n\tterm_windgoto(1, 0);\n\tbuf[mb_char2bytes(0x25bd, buf)] = NUL;\n\tout_str(buf);\n\tout_str(T_U7);\n\ttermrequest_sent(&u7_status);\n\tout_flush();\n\tdid_send = TRUE;\n\n\t// This overwrites a few characters on the screen, a redraw is needed\n\t// after this. Clear them out for now.\n\tscreen_stop_highlight();\n\tterm_windgoto(1, 0);\n\tout_str((char_u *)\"  \");\n\tline_was_clobbered(1);\n    }\n\n    if (xcc_status.tr_progress == STATUS_GET && Rows > 2)\n    {\n\t// 2. Check compatibility with xterm.\n\t// We move the cursor to (2, 0), print a test sequence and then query\n\t// the current cursor position.  If the terminal properly handles\n\t// unknown DCS string and CSI sequence with intermediate byte, the test\n\t// sequence is ignored and the cursor does not move.  If the terminal\n\t// handles test sequence incorrectly, a garbage string is displayed and\n\t// the cursor does move.\n\tMAY_WANT_TO_LOG_THIS;\n\tLOG_TR((\"Sending xterm compatibility test sequence.\"));\n\t// Do this in the third row.  Second row is used by ambiguous\n\t// character width check.\n\tterm_windgoto(2, 0);\n\t// send the test DCS string.\n\tout_str((char_u *)\"\\033Pzz\\033\\\\\");\n\t// send the test CSI sequence with intermediate byte.\n\tout_str((char_u *)\"\\033[0%m\");\n\tout_str(T_U7);\n\ttermrequest_sent(&xcc_status);\n\tout_flush();\n\tdid_send = TRUE;\n\n\t// If the terminal handles test sequence incorrectly, garbage text is\n\t// displayed. Clear them out for now.\n\tscreen_stop_highlight();\n\tterm_windgoto(2, 0);\n\tout_str((char_u *)\"           \");\n\tline_was_clobbered(2);\n    }\n\n    if (did_send)\n    {\n\tterm_windgoto(0, 0);\n\n\t// Need to reset the known cursor position.\n\tscreen_start();\n\n\t// check for the characters now, otherwise they might be eaten by\n\t// get_keystroke()\n\tout_flush();\n\t(void)vpeekc_nomap();\n    }\n}\n\n/*\n * Similar to requesting the version string: Request the terminal background\n * color when it is the right moment.\n */\n    void\nmay_req_bg_color(void)\n{\n    if (can_get_termresponse() && starting == 0)\n    {\n\tint didit = FALSE;\n\n# ifdef FEAT_TERMINAL\n\t// Only request foreground if t_RF is set.\n\tif (rfg_status.tr_progress == STATUS_GET && *T_RFG != NUL)\n\t{\n\t    MAY_WANT_TO_LOG_THIS;\n\t    LOG_TR((\"Sending FG request\"));\n\t    out_str(T_RFG);\n\t    termrequest_sent(&rfg_status);\n\t    didit = TRUE;\n\t}\n# endif\n\n\t// Only request background if t_RB is set.\n\tif (rbg_status.tr_progress == STATUS_GET && *T_RBG != NUL)\n\t{\n\t    MAY_WANT_TO_LOG_THIS;\n\t    LOG_TR((\"Sending BG request\"));\n\t    out_str(T_RBG);\n\t    termrequest_sent(&rbg_status);\n\t    didit = TRUE;\n\t}\n\n\tif (didit)\n\t{\n\t    // check for the characters now, otherwise they might be eaten by\n\t    // get_keystroke()\n\t    out_flush();\n\t    (void)vpeekc_nomap();\n\t}\n    }\n}\n\n# ifdef DEBUG_TERMRESPONSE\n    static void\nlog_tr(const char *fmt, ...)\n{\n    static FILE *fd_tr = NULL;\n    static proftime_T start;\n    proftime_T now;\n    va_list ap;\n\n    if (fd_tr == NULL)\n    {\n\tfd_tr = fopen(\"termresponse.log\", \"w\");\n\tprofile_start(&start);\n    }\n    now = start;\n    profile_end(&now);\n    fprintf(fd_tr, \"%s: %s \", profile_msg(&now),\n\t\t\t\t\tmust_redraw == NOT_VALID ? \"NV\"\n\t\t\t\t\t: must_redraw == CLEAR ? \"CL\" : \"  \");\n    va_start(ap, fmt);\n    vfprintf(fd_tr, fmt, ap);\n    va_end(ap);\n    fputc('\\n', fd_tr);\n    fflush(fd_tr);\n}\n# endif\n#endif\n\n/*\n * Return TRUE when saving and restoring the screen.\n */\n    int\nswapping_screen(void)\n{\n    return (full_screen && *T_TI != NUL);\n}\n\n/*\n * By outputting the 'cursor very visible' termcap code, for some windowed\n * terminals this makes the screen scrolled to the correct position.\n * Used when starting Vim or returning from a shell.\n */\n    void\nscroll_start(void)\n{\n    if (*T_VS != NUL && *T_CVS != NUL)\n    {\n\tMAY_WANT_TO_LOG_THIS;\n\tout_str(T_VS);\n\tout_str(T_CVS);\n\tscreen_start();\t\t// don't know where cursor is now\n    }\n}\n\n// True if cursor is not visible\nstatic int cursor_is_off = FALSE;\n\n// True if cursor is not visible due to an ongoing cursor-less sleep\nstatic int cursor_is_asleep = FALSE;\n\n/*\n * Enable the cursor without checking if it's already enabled.\n */\n    void\ncursor_on_force(void)\n{\n    out_str(T_VE);\n    cursor_is_off = FALSE;\n    cursor_is_asleep = FALSE;\n}\n\n/*\n * Enable the cursor if it's currently off.\n */\n    void\ncursor_on(void)\n{\n    if (cursor_is_off && !cursor_is_asleep)\n\tcursor_on_force();\n}\n\n/*\n * Disable the cursor.\n */\n    void\ncursor_off(void)\n{\n    if (full_screen && !cursor_is_off)\n    {\n\tout_str(T_VI);\t    // disable cursor\n\tcursor_is_off = TRUE;\n    }\n}\n\n#ifdef FEAT_GUI\n/*\n * Check whether the cursor is invisible due to an ongoing cursor-less sleep\n */\n    int\ncursor_is_sleeping(void)\n{\n    return cursor_is_asleep;\n}\n#endif\n\n/*\n * Disable the cursor and mark it disabled by cursor-less sleep\n */\n    void\ncursor_sleep(void)\n{\n    cursor_is_asleep = TRUE;\n    cursor_off();\n}\n\n/*\n * Enable the cursor and mark it not disabled by cursor-less sleep\n */\n    void\ncursor_unsleep(void)\n{\n    cursor_is_asleep = FALSE;\n    cursor_on();\n}\n\n#if defined(CURSOR_SHAPE) || defined(PROTO)\n/*\n * Set cursor shape to match Insert or Replace mode.\n */\n    void\nterm_cursor_mode(int forced)\n{\n    static int showing_mode = -1;\n    char_u *p;\n\n    // Only do something when redrawing the screen and we can restore the\n    // mode.\n    if (!full_screen || *T_CEI == NUL)\n    {\n# ifdef FEAT_TERMRESPONSE\n\tif (forced && initial_cursor_shape > 0)\n\t    // Restore to initial values.\n\t    term_cursor_shape(initial_cursor_shape, initial_cursor_blink);\n# endif\n\treturn;\n    }\n\n    if ((State & MODE_REPLACE) == MODE_REPLACE)\n    {\n\tif (forced || showing_mode != MODE_REPLACE)\n\t{\n\t    if (*T_CSR != NUL)\n\t\tp = T_CSR;\t// Replace mode cursor\n\t    else\n\t\tp = T_CSI;\t// fall back to Insert mode cursor\n\t    if (*p != NUL)\n\t    {\n\t\tout_str(p);\n\t\tshowing_mode = MODE_REPLACE;\n\t    }\n\t}\n    }\n    else if (State & MODE_INSERT)\n    {\n\tif ((forced || showing_mode != MODE_INSERT) && *T_CSI != NUL)\n\t{\n\t    out_str(T_CSI);\t    // Insert mode cursor\n\t    showing_mode = MODE_INSERT;\n\t}\n    }\n    else if (forced || showing_mode != MODE_NORMAL)\n    {\n\tout_str(T_CEI);\t\t    // non-Insert mode cursor\n\tshowing_mode = MODE_NORMAL;\n    }\n}\n\n# if defined(FEAT_TERMINAL) || defined(PROTO)\n    void\nterm_cursor_color(char_u *color)\n{\n    if (*T_CSC != NUL)\n    {\n\tout_str(T_CSC);\t\t// set cursor color start\n\tout_str_nf(color);\n\tout_str(T_CEC);\t\t// set cursor color end\n\tout_flush();\n    }\n}\n# endif\n\n    int\nblink_state_is_inverted()\n{\n#ifdef FEAT_TERMRESPONSE\n    return rbm_status.tr_progress == STATUS_GOT\n\t&& rcs_status.tr_progress == STATUS_GOT\n\t\t&& initial_cursor_blink != initial_cursor_shape_blink;\n#else\n    return FALSE;\n#endif\n}\n\n/*\n * \"shape\": 1 = block, 2 = underline, 3 = vertical bar\n */\n    void\nterm_cursor_shape(int shape, int blink)\n{\n    if (*T_CSH != NUL)\n    {\n\tOUT_STR(tgoto((char *)T_CSH, 0, shape * 2 - blink));\n\tout_flush();\n    }\n    else\n    {\n\tint do_blink = blink;\n\n\t// t_SH is empty: try setting just the blink state.\n\t// The blink flags are XORed together, if the initial blinking from\n\t// style and shape differs, we need to invert the flag here.\n\tif (blink_state_is_inverted())\n\t    do_blink = !blink;\n\n\tif (do_blink && *T_VS != NUL)\n\t{\n\t    out_str(T_VS);\n\t    out_flush();\n\t}\n\telse if (!do_blink && *T_CVS != NUL)\n\t{\n\t    out_str(T_CVS);\n\t    out_flush();\n\t}\n    }\n}\n#endif\n\n/*\n * Set scrolling region for window 'wp'.\n * The region starts 'off' lines from the start of the window.\n * Also set the vertical scroll region for a vertically split window.  Always\n * the full width of the window, excluding the vertical separator.\n */\n    void\nscroll_region_set(win_T *wp, int off)\n{\n    OUT_STR(tgoto((char *)T_CS, W_WINROW(wp) + wp->w_height - 1,\n\t\t\t\t\t\t\t W_WINROW(wp) + off));\n    if (*T_CSV != NUL && wp->w_width != Columns)\n\tOUT_STR(tgoto((char *)T_CSV, wp->w_wincol + wp->w_width - 1,\n\t\t\t\t\t\t\t       wp->w_wincol));\n    screen_start();\t\t    // don't know where cursor is now\n}\n\n/*\n * Reset scrolling region to the whole screen.\n */\n    void\nscroll_region_reset(void)\n{\n    OUT_STR(tgoto((char *)T_CS, (int)Rows - 1, 0));\n    if (*T_CSV != NUL)\n\tOUT_STR(tgoto((char *)T_CSV, (int)Columns - 1, 0));\n    screen_start();\t\t    // don't know where cursor is now\n}\n\n\n/*\n * List of terminal codes that are currently recognized.\n */\n\nstatic struct termcode\n{\n    char_u  name[2];\t    // termcap name of entry\n    char_u  *code;\t    // terminal code (in allocated memory)\n    int\t    len;\t    // STRLEN(code)\n    int\t    modlen;\t    // length of part before \";*~\".\n} *termcodes = NULL;\n\nstatic int  tc_max_len = 0; // number of entries that termcodes[] can hold\nstatic int  tc_len = 0;\t    // current number of entries in termcodes[]\n\nstatic int termcode_star(char_u *code, int len);\n\n    void\nclear_termcodes(void)\n{\n    while (tc_len > 0)\n\tvim_free(termcodes[--tc_len].code);\n    VIM_CLEAR(termcodes);\n    tc_max_len = 0;\n\n#ifdef HAVE_TGETENT\n    BC = (char *)empty_option;\n    UP = (char *)empty_option;\n    PC = NUL;\t\t\t// set pad character to NUL\n    ospeed = 0;\n#endif\n\n    need_gather = TRUE;\t\t// need to fill termleader[]\n}\n\n#define ATC_FROM_TERM 55\n\n/*\n * Add a new entry to the list of terminal codes.\n * The list is kept alphabetical for \":set termcap\"\n * \"flags\" is TRUE when replacing 7-bit by 8-bit controls is desired.\n * \"flags\" can also be ATC_FROM_TERM for got_code_from_term().\n */\n    void\nadd_termcode(char_u *name, char_u *string, int flags)\n{\n    struct termcode *new_tc;\n    int\t\t    i, j;\n    char_u\t    *s;\n    int\t\t    len;\n\n    if (string == NULL || *string == NUL)\n    {\n\tdel_termcode(name);\n\treturn;\n    }\n\n#if defined(MSWIN) && !defined(FEAT_GUI)\n    s = vim_strnsave(string, STRLEN(string) + 1);\n#else\n# ifdef VIMDLL\n    if (!gui.in_use)\n\ts = vim_strnsave(string, STRLEN(string) + 1);\n    else\n# endif\n\ts = vim_strsave(string);\n#endif\n    if (s == NULL)\n\treturn;\n\n    // Change leading <Esc>[ to CSI, change <Esc>O to <M-O>.\n    if (flags != 0 && flags != ATC_FROM_TERM && term_7to8bit(string) != 0)\n    {\n\tSTRMOVE(s, s + 1);\n\ts[0] = term_7to8bit(string);\n    }\n\n#if defined(MSWIN) && (!defined(FEAT_GUI) || defined(VIMDLL))\n# ifdef VIMDLL\n    if (!gui.in_use)\n# endif\n    {\n\tif (s[0] == K_NUL)\n\t{\n\t    STRMOVE(s + 1, s);\n\t    s[1] = 3;\n\t}\n    }\n#endif\n\n    len = (int)STRLEN(s);\n\n    need_gather = TRUE;\t\t// need to fill termleader[]\n\n    /*\n     * need to make space for more entries\n     */\n    if (tc_len == tc_max_len)\n    {\n\ttc_max_len += 20;\n\tnew_tc = ALLOC_MULT(struct termcode, tc_max_len);\n\tif (new_tc == NULL)\n\t{\n\t    tc_max_len -= 20;\n\t    vim_free(s);\n\t    return;\n\t}\n\tfor (i = 0; i < tc_len; ++i)\n\t    new_tc[i] = termcodes[i];\n\tvim_free(termcodes);\n\ttermcodes = new_tc;\n    }\n\n    /*\n     * Look for existing entry with the same name, it is replaced.\n     * Look for an existing entry that is alphabetical higher, the new entry\n     * is inserted in front of it.\n     */\n    for (i = 0; i < tc_len; ++i)\n    {\n\tif (termcodes[i].name[0] < name[0])\n\t    continue;\n\tif (termcodes[i].name[0] == name[0])\n\t{\n\t    if (termcodes[i].name[1] < name[1])\n\t\tcontinue;\n\t    /*\n\t     * Exact match: May replace old code.\n\t     */\n\t    if (termcodes[i].name[1] == name[1])\n\t    {\n\t\tif (flags == ATC_FROM_TERM && (j = termcode_star(\n\t\t\t\t    termcodes[i].code, termcodes[i].len)) > 0)\n\t\t{\n\t\t    // Don't replace ESC[123;*X or ESC O*X with another when\n\t\t    // invoked from got_code_from_term().\n\t\t    if (len == termcodes[i].len - j\n\t\t\t    && STRNCMP(s, termcodes[i].code, len - 1) == 0\n\t\t\t    && s[len - 1]\n\t\t\t\t   == termcodes[i].code[termcodes[i].len - 1])\n\t\t    {\n\t\t\t// They are equal but for the \";*\": don't add it.\n\t\t\tvim_free(s);\n\t\t\treturn;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Replace old code.\n\t\t    vim_free(termcodes[i].code);\n\t\t    --tc_len;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\t/*\n\t * Found alphabetical larger entry, move rest to insert new entry\n\t */\n\tfor (j = tc_len; j > i; --j)\n\t    termcodes[j] = termcodes[j - 1];\n\tbreak;\n    }\n\n    termcodes[i].name[0] = name[0];\n    termcodes[i].name[1] = name[1];\n    termcodes[i].code = s;\n    termcodes[i].len = len;\n\n    // For xterm we recognize special codes like \"ESC[42;*X\" and \"ESC O*X\" that\n    // accept modifiers.\n    termcodes[i].modlen = 0;\n    j = termcode_star(s, len);\n    if (j > 0)\n    {\n\ttermcodes[i].modlen = len - 1 - j;\n\t// For \"CSI[@;X\" the \"@\" is not included in \"modlen\".\n\tif (termcodes[i].code[termcodes[i].modlen - 1] == '@')\n\t    --termcodes[i].modlen;\n    }\n    ++tc_len;\n}\n\n/*\n * Check termcode \"code[len]\" for ending in ;*X or *X.\n * The \"X\" can be any character.\n * Return 0 if not found, 2 for ;*X and 1 for *X.\n */\n    static int\ntermcode_star(char_u *code, int len)\n{\n    // Shortest is <M-O>*X.  With ; shortest is <CSI>@;*X\n    if (len >= 3 && code[len - 2] == '*')\n    {\n\tif (len >= 5 && code[len - 3] == ';')\n\t    return 2;\n\telse\n\t    return 1;\n    }\n    return 0;\n}\n\n    char_u  *\nfind_termcode(char_u *name)\n{\n    int\t    i;\n\n    for (i = 0; i < tc_len; ++i)\n\tif (termcodes[i].name[0] == name[0] && termcodes[i].name[1] == name[1])\n\t    return termcodes[i].code;\n    return NULL;\n}\n\n    char_u *\nget_termcode(int i)\n{\n    if (i >= tc_len)\n\treturn NULL;\n    return &termcodes[i].name[0];\n}\n\n/*\n * Returns the length of the terminal code at index 'idx'.\n */\n    int\nget_termcode_len(int idx)\n{\n    return termcodes[idx].len;\n}\n\n    void\ndel_termcode(char_u *name)\n{\n    int\t    i;\n\n    if (termcodes == NULL)\t// nothing there yet\n\treturn;\n\n    need_gather = TRUE;\t\t// need to fill termleader[]\n\n    for (i = 0; i < tc_len; ++i)\n\tif (termcodes[i].name[0] == name[0] && termcodes[i].name[1] == name[1])\n\t{\n\t    del_termcode_idx(i);\n\t    return;\n\t}\n    // not found. Give error message?\n}\n\n    static void\ndel_termcode_idx(int idx)\n{\n    int\t\ti;\n\n    vim_free(termcodes[idx].code);\n    --tc_len;\n    for (i = idx; i < tc_len; ++i)\n\ttermcodes[i] = termcodes[i + 1];\n}\n\n#ifdef FEAT_TERMRESPONSE\n/*\n * Called when detected that the terminal sends 8-bit codes.\n * Convert all 7-bit codes to their 8-bit equivalent.\n */\n    static void\nswitch_to_8bit(void)\n{\n    int\t\ti;\n    int\t\tc;\n\n    // Only need to do something when not already using 8-bit codes.\n    if (!term_is_8bit(T_NAME))\n    {\n\tfor (i = 0; i < tc_len; ++i)\n\t{\n\t    c = term_7to8bit(termcodes[i].code);\n\t    if (c != 0)\n\t    {\n\t\tSTRMOVE(termcodes[i].code + 1, termcodes[i].code + 2);\n\t\ttermcodes[i].code[0] = c;\n\t    }\n\t}\n\tneed_gather = TRUE;\t\t// need to fill termleader[]\n    }\n    detected_8bit = TRUE;\n    LOG_TR((\"Switching to 8 bit\"));\n}\n#endif\n\n#ifdef CHECK_DOUBLE_CLICK\nstatic linenr_T orig_topline = 0;\n# ifdef FEAT_DIFF\nstatic int orig_topfill = 0;\n# endif\n#endif\n#if defined(CHECK_DOUBLE_CLICK) || defined(PROTO)\n/*\n * Checking for double-clicks ourselves.\n * \"orig_topline\" is used to avoid detecting a double-click when the window\n * contents scrolled (e.g., when 'scrolloff' is non-zero).\n */\n/*\n * Set orig_topline.  Used when jumping to another window, so that a double\n * click still works.\n */\n    void\nset_mouse_topline(win_T *wp)\n{\n    orig_topline = wp->w_topline;\n# ifdef FEAT_DIFF\n    orig_topfill = wp->w_topfill;\n# endif\n}\n\n/*\n * Returns TRUE if the top line and top fill of window 'wp' matches the saved\n * topline and topfill.\n */\n    int\nis_mouse_topline(win_T *wp)\n{\n    return orig_topline == wp->w_topline\n#ifdef FEAT_DIFF\n\t&& orig_topfill == wp->w_topfill\n#endif\n\t;\n}\n#endif\n\n/*\n * If \"buf\" is NULL put \"string[new_slen]\" in typebuf; \"buflen\" is not used.\n * If \"buf\" is not NULL put \"string[new_slen]\" in \"buf[bufsize]\" and adjust\n * \"buflen\".\n * Remove \"slen\" bytes.\n * Returns FAIL for error.\n */\n    int\nput_string_in_typebuf(\n\tint\toffset,\n\tint\tslen,\n\tchar_u\t*string,\n\tint\tnew_slen,\n\tchar_u\t*buf,\n\tint\tbufsize,\n\tint\t*buflen)\n{\n    int\t\textra = new_slen - slen;\n\n    string[new_slen] = NUL;\n    if (buf == NULL)\n    {\n\tif (extra < 0)\n\t    // remove matched chars, taking care of noremap\n\t    del_typebuf(-extra, offset);\n\telse if (extra > 0)\n\t    // insert the extra space we need\n\t    if (ins_typebuf(string + slen, REMAP_YES, offset, FALSE, FALSE)\n\t\t\t\t\t\t\t\t       == FAIL)\n\t\treturn FAIL;\n\n\t// Careful: del_typebuf() and ins_typebuf() may have reallocated\n\t// typebuf.tb_buf[]!\n\tmch_memmove(typebuf.tb_buf + typebuf.tb_off + offset, string,\n\t\t\t\t\t\t\t     (size_t)new_slen);\n    }\n    else\n    {\n\tif (extra < 0)\n\t    // remove matched characters\n\t    mch_memmove(buf + offset, buf + offset - extra,\n\t\t\t\t\t   (size_t)(*buflen + offset + extra));\n\telse if (extra > 0)\n\t{\n\t    // Insert the extra space we need.  If there is insufficient\n\t    // space return -1.\n\t    if (*buflen + extra + new_slen >= bufsize)\n\t\treturn FAIL;\n\t    mch_memmove(buf + offset + extra, buf + offset,\n\t\t\t\t\t\t   (size_t)(*buflen - offset));\n\t}\n\tmch_memmove(buf + offset, string, (size_t)new_slen);\n\t*buflen = *buflen + extra + new_slen;\n    }\n    return OK;\n}\n\n/*\n * Decode a modifier number as xterm provides it into MOD_MASK bits.\n */\n    int\ndecode_modifiers(int n)\n{\n    int\t    code = n - 1;\n    int\t    modifiers = 0;\n\n    if (code & 1)\n\tmodifiers |= MOD_MASK_SHIFT;\n    if (code & 2)\n\tmodifiers |= MOD_MASK_ALT;\n    if (code & 4)\n\tmodifiers |= MOD_MASK_CTRL;\n    if (code & 8)\n\tmodifiers |= MOD_MASK_META;\n    return modifiers;\n}\n\n    static int\nmodifiers2keycode(int modifiers, int *key, char_u *string)\n{\n    int new_slen = 0;\n\n    if (modifiers != 0)\n    {\n\t// Some keys have the modifier included.  Need to handle that here to\n\t// make mappings work.  This may result in a special key, such as\n\t// K_S_TAB.\n\t*key = simplify_key(*key, &modifiers);\n\tif (modifiers != 0)\n\t{\n\t    string[new_slen++] = K_SPECIAL;\n\t    string[new_slen++] = (int)KS_MODIFIER;\n\t    string[new_slen++] = modifiers;\n\t}\n    }\n    return new_slen;\n}\n\n#ifdef FEAT_TERMRESPONSE\n/*\n * Handle a cursor position report.\n */\n    static void\nhandle_u7_response(int *arg, char_u *tp UNUSED, int csi_len UNUSED)\n{\n    if (arg[0] == 2 && arg[1] >= 2)\n    {\n\tchar *aw = NULL;\n\n\tLOG_TR((\"Received U7 status: %s\", tp));\n\tu7_status.tr_progress = STATUS_GOT;\n\tdid_cursorhold = TRUE;\n\tif (arg[1] == 2)\n\t    aw = \"single\";\n\telse if (arg[1] == 3)\n\t    aw = \"double\";\n\tif (aw != NULL && STRCMP(aw, p_ambw) != 0)\n\t{\n\t    // Setting the option causes a screen redraw. Do\n\t    // that right away if possible, keeping any\n\t    // messages.\n\t    set_option_value_give_err((char_u *)\"ambw\", 0L, (char_u *)aw, 0);\n# ifdef DEBUG_TERMRESPONSE\n\t    {\n\t\tint r = redraw_asap(CLEAR);\n\n\t\tlog_tr(\"set 'ambiwidth', redraw_asap(): %d\", r);\n\t    }\n# else\n\t    redraw_asap(CLEAR);\n# endif\n# ifdef FEAT_EVAL\n\t    set_vim_var_string(VV_TERMU7RESP, tp, csi_len);\n# endif\n\t}\n    }\n    else if (arg[0] == 3)\n    {\n\tint value;\n\n\tLOG_TR((\"Received compatibility test result: %s\", tp));\n\txcc_status.tr_progress = STATUS_GOT;\n\n\t// Third row: xterm compatibility test.\n\t// If the cursor is on the first column then the terminal can handle\n\t// the request for cursor style and blinking.\n\tvalue = arg[1] == 1 ? TPR_YES : TPR_NO;\n\tterm_props[TPR_CURSOR_STYLE].tpr_status = value;\n\tterm_props[TPR_CURSOR_BLINK].tpr_status = value;\n    }\n}\n\n/*\n * Handle a response to T_CRV: {lead}{first}{x};{vers};{y}c\n * Xterm and alike use '>' for {first}.\n * Rxvt sends \"{lead}?1;2c\".\n */\n    static void\nhandle_version_response(int first, int *arg, int argc, char_u *tp)\n{\n    // The xterm version.  It is set to zero when it can't be an actual xterm\n    // version.\n    int version = arg[1];\n\n    LOG_TR((\"Received CRV response: %s\", tp));\n    crv_status.tr_progress = STATUS_GOT;\n    did_cursorhold = TRUE;\n\n    // Reset terminal properties that are set based on the termresponse.\n    // Mainly useful for tests that send the termresponse multiple times.\n    // For testing all props can be reset.\n    init_term_props(\n#ifdef FEAT_EVAL\n\t    reset_term_props_on_termresponse\n#else\n\t    FALSE\n#endif\n\t    );\n\n    // If this code starts with CSI, you can bet that the\n    // terminal uses 8-bit codes.\n    if (tp[0] == CSI)\n\tswitch_to_8bit();\n\n    // Screen sends 40500.\n    // rxvt sends its version number: \"20703\" is 2.7.3.\n    // Ignore it for when the user has set 'term' to xterm,\n    // even though it's an rxvt.\n    if (version > 20000)\n\tversion = 0;\n\n    // Figure out more if the response is CSI > 99 ; 99 ; 99 c\n    if (first == '>' && argc == 3)\n    {\n\tint need_flush = FALSE;\n\n\t// mintty 2.9.5 sends 77;20905;0c.\n\t// (77 is ASCII 'M' for mintty.)\n\tif (arg[0] == 77)\n\t{\n\t    // mintty can do SGR mouse reporting\n\t    term_props[TPR_MOUSE].tpr_status = TPR_MOUSE_SGR;\n\t}\n\n\t// If xterm version >= 141 try to get termcap codes.  For other\n\t// terminals the request should be ignored.\n\tif (version >= 141 && p_xtermcodes)\n\t{\n\t    LOG_TR((\"Enable checking for XT codes\"));\n\t    check_for_codes = TRUE;\n\t    need_gather = TRUE;\n\t    req_codes_from_term();\n\t}\n\n\t// libvterm sends 0;100;0\n\tif (version == 100 && arg[0] == 0 && arg[2] == 0)\n\t{\n\t    // If run from Vim $COLORS is set to the number of\n\t    // colors the terminal supports.  Otherwise assume\n\t    // 256, libvterm supports even more.\n\t    if (mch_getenv((char_u *)\"COLORS\") == NULL)\n\t\tmay_adjust_color_count(256);\n\t    // Libvterm can handle SGR mouse reporting.\n\t    term_props[TPR_MOUSE].tpr_status = TPR_MOUSE_SGR;\n\t}\n\n\tif (version == 95)\n\t{\n\t    // Mac Terminal.app sends 1;95;0\n\t    if (arg[0] == 1 && arg[2] == 0)\n\t    {\n\t\tterm_props[TPR_UNDERLINE_RGB].tpr_status = TPR_YES;\n\t\tterm_props[TPR_MOUSE].tpr_status = TPR_MOUSE_SGR;\n\t    }\n\t    // iTerm2 sends 0;95;0\n\t    else if (arg[0] == 0 && arg[2] == 0)\n\t    {\n\t\t// iTerm2 can do SGR mouse reporting\n\t\tterm_props[TPR_MOUSE].tpr_status = TPR_MOUSE_SGR;\n\t    }\n\t    // old iTerm2 sends 0;95;\n\t    else if (arg[0] == 0 && arg[2] == -1)\n\t\tterm_props[TPR_UNDERLINE_RGB].tpr_status = TPR_YES;\n\t}\n\n\t// screen sends 83;40500;0 83 is 'S' in ASCII.\n\tif (arg[0] == 83)\n\t{\n\t    // screen supports SGR mouse codes since 4.7.0\n\t    if (arg[1] >= 40700)\n\t\tterm_props[TPR_MOUSE].tpr_status = TPR_MOUSE_SGR;\n\t    else\n\t\tterm_props[TPR_MOUSE].tpr_status = TPR_MOUSE_XTERM;\n\t}\n\n\t// If no recognized terminal has set mouse behavior, assume xterm.\n\tif (term_props[TPR_MOUSE].tpr_status == TPR_UNKNOWN)\n\t{\n\t    // Xterm version 277 supports SGR.\n\t    // Xterm version >= 95 supports mouse dragging.\n\t    if (version >= 277)\n\t\tterm_props[TPR_MOUSE].tpr_status = TPR_MOUSE_SGR;\n\t    else if (version >= 95)\n\t\tterm_props[TPR_MOUSE].tpr_status = TPR_MOUSE_XTERM2;\n\t}\n\n\t// Detect terminals that set $TERM to something like\n\t// \"xterm-256color\" but are not fully xterm compatible.\n\t//\n\t// Gnome terminal sends 1;3801;0, 1;4402;0 or 1;2501;0.\n\t// Newer Gnome-terminal sends 65;6001;1.\n\t// xfce4-terminal sends 1;2802;0.\n\t// screen sends 83;40500;0\n\t// Assuming any version number over 2500 is not an\n\t// xterm (without the limit for rxvt and screen).\n\tif (arg[1] >= 2500)\n\t    term_props[TPR_UNDERLINE_RGB].tpr_status = TPR_YES;\n\n\telse if (version == 136 && arg[2] == 0)\n\t{\n\t    term_props[TPR_UNDERLINE_RGB].tpr_status = TPR_YES;\n\n\t    // PuTTY sends 0;136;0\n\t    if (arg[0] == 0)\n\t    {\n\t\t// supports sgr-like mouse reporting.\n\t\tterm_props[TPR_MOUSE].tpr_status = TPR_MOUSE_SGR;\n\t    }\n\t    // vandyke SecureCRT sends 1;136;0\n\t}\n\n\t// Konsole sends 0;115;0 - but t_u8 does not actually work, therefore\n\t// commented out.\n\t// else if (version == 115 && arg[0] == 0 && arg[2] == 0)\n\t//     term_props[TPR_UNDERLINE_RGB].tpr_status = TPR_YES;\n\n\t// GNU screen sends 83;30600;0, 83;40500;0, etc.\n\t// 30600/40500 is a version number of GNU screen. DA2 support is added\n\t// on 3.6.  DCS string has a special meaning to GNU screen, but xterm\n\t// compatibility checking does not detect GNU screen.\n\tif (arg[0] == 83 && arg[1] >= 30600)\n\t{\n\t    term_props[TPR_CURSOR_STYLE].tpr_status = TPR_NO;\n\t    term_props[TPR_CURSOR_BLINK].tpr_status = TPR_NO;\n\t}\n\n\t// Xterm first responded to this request at patch level\n\t// 95, so assume anything below 95 is not xterm and hopefully supports\n\t// the underline RGB color sequence.\n\tif (version < 95)\n\t    term_props[TPR_UNDERLINE_RGB].tpr_status = TPR_YES;\n\n\t// Getting the cursor style is only supported properly by xterm since\n\t// version 279 (otherwise it returns 0x18).\n\tif (version < 279)\n\t    term_props[TPR_CURSOR_STYLE].tpr_status = TPR_NO;\n\n\t/*\n\t * Take action on the detected properties.\n\t */\n\n\t// Unless the underline RGB color is expected to work, disable \"t_8u\".\n\t// It does not work for the real Xterm, it resets the background color.\n\t// This may cause some flicker.  Alternative would be to set \"t_8u\"\n\t// here if the terminal is expected to support it, but that might\n\t// conflict with what was set in the .vimrc.\n\tif (term_props[TPR_UNDERLINE_RGB].tpr_status != TPR_YES\n\t\t\t&& *T_8U != NUL\n\t\t\t&& !option_was_set((char_u *)\"t_8u\"))\n\t{\n\t    set_string_option_direct((char_u *)\"t_8u\", -1, (char_u *)\"\",\n\t\t\t\t\t\t\t\t  OPT_FREE, 0);\n\t}\n\tif (*T_8U != NUL && write_t_8u_state == MAYBE)\n\t    // Did skip writing t_8u, a complete redraw is needed.\n\t    redraw_later_clear();\n\twrite_t_8u_state = OK;  // can output t_8u now\n\n\t// Only set 'ttymouse' automatically if it was not set\n\t// by the user already.\n\tif (!option_was_set((char_u *)\"ttym\")\n\t\t&& (term_props[TPR_MOUSE].tpr_status == TPR_MOUSE_XTERM2\n\t\t    || term_props[TPR_MOUSE].tpr_status == TPR_MOUSE_SGR))\n\t{\n\t    set_option_value_give_err((char_u *)\"ttym\", 0L,\n\t\t    term_props[TPR_MOUSE].tpr_status == TPR_MOUSE_SGR\n\t\t\t\t    ? (char_u *)\"sgr\" : (char_u *)\"xterm2\", 0);\n\t}\n\n\t// Only request the cursor style if t_SH and t_RS are\n\t// set. Only supported properly by xterm since version\n\t// 279 (otherwise it returns 0x18).\n\t// Only when getting the cursor style was detected to work.\n\t// Not for Terminal.app, it can't handle t_RS, it\n\t// echoes the characters to the screen.\n\tif (rcs_status.tr_progress == STATUS_GET\n\t\t&& term_props[TPR_CURSOR_STYLE].tpr_status == TPR_YES\n\t\t&& *T_CSH != NUL\n\t\t&& *T_CRS != NUL)\n\t{\n\t    MAY_WANT_TO_LOG_THIS;\n\t    LOG_TR((\"Sending cursor style request\"));\n\t    out_str(T_CRS);\n\t    termrequest_sent(&rcs_status);\n\t    need_flush = TRUE;\n\t}\n\n\t// Only request the cursor blink mode if t_RC set. Not\n\t// for Gnome terminal, it can't handle t_RC, it\n\t// echoes the characters to the screen.\n\t// Only when getting the cursor style was detected to work.\n\tif (rbm_status.tr_progress == STATUS_GET\n\t\t&& term_props[TPR_CURSOR_BLINK].tpr_status == TPR_YES\n\t\t&& *T_CRC != NUL)\n\t{\n\t    MAY_WANT_TO_LOG_THIS;\n\t    LOG_TR((\"Sending cursor blink mode request\"));\n\t    out_str(T_CRC);\n\t    termrequest_sent(&rbm_status);\n\t    need_flush = TRUE;\n\t}\n\n\tif (need_flush)\n\t    out_flush();\n    }\n}\n\n/*\n * Handle a sequence with key and modifier, one of:\n *\t{lead}27;{modifier};{key}~\n *\t{lead}{key};{modifier}u\n * Returns the difference in length.\n */\n    static int\nhandle_key_with_modifier(\n\tint\t*arg,\n\tint\ttrail,\n\tint\tcsi_len,\n\tint\toffset,\n\tchar_u\t*buf,\n\tint\tbufsize,\n\tint\t*buflen)\n{\n    int\t    key;\n    int\t    modifiers;\n    int\t    new_slen;\n    char_u  string[MAX_KEY_CODE_LEN + 1];\n\n    seenModifyOtherKeys = TRUE;\n    if (trail == 'u')\n\tkey = arg[0];\n    else\n\tkey = arg[2];\n\n    modifiers = decode_modifiers(arg[1]);\n\n    // Some keys need adjustment when the Ctrl modifier is used.\n    key = may_adjust_key_for_ctrl(modifiers, key);\n\n    // May remove the shift modifier if it's already included in the key.\n    modifiers = may_remove_shift_modifier(modifiers, key);\n\n    // insert modifiers with KS_MODIFIER\n    new_slen = modifiers2keycode(modifiers, &key, string);\n\n    if (IS_SPECIAL(key))\n    {\n\tstring[new_slen++] = K_SPECIAL;\n\tstring[new_slen++] = KEY2TERMCAP0(key);\n\tstring[new_slen++] = KEY2TERMCAP1(key);\n    }\n    else if (has_mbyte)\n\tnew_slen += (*mb_char2bytes)(key, string + new_slen);\n    else\n\tstring[new_slen++] = key;\n\n    if (put_string_in_typebuf(offset, csi_len, string, new_slen,\n\t\t\t\t\t\t buf, bufsize, buflen) == FAIL)\n\treturn -1;\n    return new_slen - csi_len + offset;\n}\n\n/*\n * Handle a CSI escape sequence.\n * - Xterm version string.\n *\n * - Cursor position report: {lead}{row};{col}R\n *   The final byte must be 'R'. It is used for checking the\n *   ambiguous-width character state.\n *\n * - window position reply: {lead}3;{x};{y}t\n *\n * - key with modifiers when modifyOtherKeys is enabled:\n *\t    {lead}27;{modifier};{key}~\n *\t    {lead}{key};{modifier}u\n * Return 0 for no match, -1 for partial match, > 0 for full match.\n */\n    static int\nhandle_csi(\n\tchar_u\t*tp,\n\tint\tlen,\n\tchar_u\t*argp,\n\tint\toffset,\n\tchar_u  *buf,\n\tint\tbufsize,\n\tint\t*buflen,\n\tchar_u\t*key_name,\n\tint\t*slen)\n{\n    int\t\tfirst = -1;  // optional char right after {lead}\n    int\t\ttrail;\t     // char that ends CSI sequence\n    int\t\targ[3] = {-1, -1, -1};\t// argument numbers\n    int\t\targc;\t\t\t// number of arguments\n    char_u\t*ap = argp;\n    int\t\tcsi_len;\n\n    // Check for non-digit after CSI.\n    if (!VIM_ISDIGIT(*ap))\n\tfirst = *ap++;\n\n    // Find up to three argument numbers.\n    for (argc = 0; argc < 3; )\n    {\n\tif (ap >= tp + len)\n\t    return -1;\n\tif (*ap == ';')\n\t    arg[argc++] = -1;  // omitted number\n\telse if (VIM_ISDIGIT(*ap))\n\t{\n\t    arg[argc] = 0;\n\t    for (;;)\n\t    {\n\t\tif (ap >= tp + len)\n\t\t    return -1;\n\t\tif (!VIM_ISDIGIT(*ap))\n\t\t    break;\n\t\targ[argc] = arg[argc] * 10 + (*ap - '0');\n\t\t++ap;\n\t    }\n\t    ++argc;\n\t}\n\tif (*ap == ';')\n\t    ++ap;\n\telse\n\t    break;\n    }\n\n    // mrxvt has been reported to have \"+\" in the version. Assume\n    // the escape sequence ends with a letter or one of \"{|}~\".\n    while (ap < tp + len\n\t    && !(*ap >= '{' && *ap <= '~')\n\t    && !ASCII_ISALPHA(*ap))\n\t++ap;\n    if (ap >= tp + len)\n\treturn -1;\n    trail = *ap;\n    csi_len = (int)(ap - tp) + 1;\n\n    // Cursor position report: Eat it when there are 2 arguments\n    // and it ends in 'R'. Also when u7_status is not \"sent\", it\n    // may be from a previous Vim that just exited.  But not for\n    // <S-F3>, it sends something similar, check for row and column\n    // to make sense.\n    if (first == -1 && argc == 2 && trail == 'R')\n    {\n\thandle_u7_response(arg, tp, csi_len);\n\n\tkey_name[0] = (int)KS_EXTRA;\n\tkey_name[1] = (int)KE_IGNORE;\n\t*slen = csi_len;\n    }\n\n    // Version string: Eat it when there is at least one digit and\n    // it ends in 'c'\n    else if (*T_CRV != NUL && ap > argp + 1 && trail == 'c')\n    {\n\thandle_version_response(first, arg, argc, tp);\n\n\t*slen = csi_len;\n# ifdef FEAT_EVAL\n\tset_vim_var_string(VV_TERMRESPONSE, tp, *slen);\n# endif\n\tapply_autocmds(EVENT_TERMRESPONSE,\n\t\t\t\t\tNULL, NULL, FALSE, curbuf);\n\tkey_name[0] = (int)KS_EXTRA;\n\tkey_name[1] = (int)KE_IGNORE;\n    }\n\n    // Check blinking cursor from xterm:\n    // {lead}?12;1$y       set\n    // {lead}?12;2$y       not set\n    //\n    // {lead} can be <Esc>[ or CSI\n    else if (rbm_status.tr_progress == STATUS_SENT\n\t    && first == '?'\n\t    && ap == argp + 6\n\t    && arg[0] == 12\n\t    && ap[-1] == '$'\n\t    && trail == 'y')\n    {\n\tinitial_cursor_blink = (arg[1] == '1');\n\trbm_status.tr_progress = STATUS_GOT;\n\tLOG_TR((\"Received cursor blinking mode response: %s\", tp));\n\tkey_name[0] = (int)KS_EXTRA;\n\tkey_name[1] = (int)KE_IGNORE;\n\t*slen = csi_len;\n# ifdef FEAT_EVAL\n\tset_vim_var_string(VV_TERMBLINKRESP, tp, *slen);\n# endif\n    }\n\n    // Check for a window position response from the terminal:\n    //       {lead}3;{x};{y}t\n    else if (did_request_winpos && argc == 3 && arg[0] == 3\n\t\t\t\t\t\t   && trail == 't')\n    {\n\twinpos_x = arg[1];\n\twinpos_y = arg[2];\n\t// got finished code: consume it\n\tkey_name[0] = (int)KS_EXTRA;\n\tkey_name[1] = (int)KE_IGNORE;\n\t*slen = csi_len;\n\n\tif (--did_request_winpos <= 0)\n\t    winpos_status.tr_progress = STATUS_GOT;\n    }\n\n    // Key with modifier:\n    //\t{lead}27;{modifier};{key}~\n    //\t{lead}{key};{modifier}u\n    else if ((arg[0] == 27 && argc == 3 && trail == '~')\n\t    || (argc == 2 && trail == 'u'))\n    {\n\treturn len + handle_key_with_modifier(arg, trail,\n\t\t\t    csi_len, offset, buf, bufsize, buflen);\n    }\n\n    // else: Unknown CSI sequence.  We could drop it, but then the\n    // user can't create a map for it.\n    return 0;\n}\n\n/*\n * Handle an OSC sequence, fore/background color response from the terminal:\n *\n *       {lead}{code};rgb:{rrrr}/{gggg}/{bbbb}{tail}\n * or    {lead}{code};rgb:{rr}/{gg}/{bb}{tail}\n *\n * {code} is 10 for foreground, 11 for background\n * {lead} can be <Esc>] or OSC\n * {tail} can be '\\007', <Esc>\\ or STERM.\n *\n * Consume any code that starts with \"{lead}11;\", it's also\n * possible that \"rgba\" is following.\n */\n    static int\nhandle_osc(char_u *tp, char_u *argp, int len, char_u *key_name, int *slen)\n{\n    int\t\ti, j;\n\n    j = 1 + (tp[0] == ESC);\n    if (len >= j + 3 && (argp[0] != '1'\n\t\t\t     || (argp[1] != '1' && argp[1] != '0')\n\t\t\t     || argp[2] != ';'))\n\ti = 0; // no match\n    else\n\tfor (i = j; i < len; ++i)\n\t    if (tp[i] == '\\007' || (tp[0] == OSC ? tp[i] == STERM\n\t\t\t: (tp[i] == ESC && i + 1 < len && tp[i + 1] == '\\\\')))\n\t    {\n\t\tint is_bg = argp[1] == '1';\n\t\tint is_4digit = i - j >= 21 && tp[j + 11] == '/'\n\t\t\t\t\t\t  && tp[j + 16] == '/';\n\n\t\tif (i - j >= 15 && STRNCMP(tp + j + 3, \"rgb:\", 4) == 0\n\t\t\t    && (is_4digit\n\t\t\t\t   || (tp[j + 9] == '/' && tp[i + 12 == '/'])))\n\t\t{\n\t\t    char_u *tp_r = tp + j + 7;\n\t\t    char_u *tp_g = tp + j + (is_4digit ? 12 : 10);\n\t\t    char_u *tp_b = tp + j + (is_4digit ? 17 : 13);\n# ifdef FEAT_TERMINAL\n\t\t    int rval, gval, bval;\n\n\t\t    rval = hexhex2nr(tp_r);\n\t\t    gval = hexhex2nr(tp_b);\n\t\t    bval = hexhex2nr(tp_g);\n# endif\n\t\t    if (is_bg)\n\t\t    {\n\t\t\tchar *new_bg_val = (3 * '6' < *tp_r + *tp_g +\n\t\t\t\t\t     *tp_b) ? \"light\" : \"dark\";\n\n\t\t\tLOG_TR((\"Received RBG response: %s\", tp));\n\t\t\trbg_status.tr_progress = STATUS_GOT;\n# ifdef FEAT_TERMINAL\n\t\t\tbg_r = rval;\n\t\t\tbg_g = gval;\n\t\t\tbg_b = bval;\n# endif\n\t\t\tif (!option_was_set((char_u *)\"bg\")\n\t\t\t\t      && STRCMP(p_bg, new_bg_val) != 0)\n\t\t\t{\n\t\t\t    // value differs, apply it\n\t\t\t    set_option_value_give_err((char_u *)\"bg\",\n\t\t\t\t\t\t  0L, (char_u *)new_bg_val, 0);\n\t\t\t    reset_option_was_set((char_u *)\"bg\");\n\t\t\t    redraw_asap(CLEAR);\n\t\t\t}\n\t\t    }\n# ifdef FEAT_TERMINAL\n\t\t    else\n\t\t    {\n\t\t\tLOG_TR((\"Received RFG response: %s\", tp));\n\t\t\trfg_status.tr_progress = STATUS_GOT;\n\t\t\tfg_r = rval;\n\t\t\tfg_g = gval;\n\t\t\tfg_b = bval;\n\t\t    }\n# endif\n\t\t}\n\n\t\t// got finished code: consume it\n\t\tkey_name[0] = (int)KS_EXTRA;\n\t\tkey_name[1] = (int)KE_IGNORE;\n\t\t*slen = i + 1 + (tp[i] == ESC);\n# ifdef FEAT_EVAL\n\t\tset_vim_var_string(is_bg ? VV_TERMRBGRESP\n\t\t\t\t\t\t  : VV_TERMRFGRESP, tp, *slen);\n# endif\n\t\tbreak;\n\t    }\n    if (i == len)\n    {\n\tLOG_TR((\"not enough characters for RB\"));\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Check for key code response from xterm:\n * {lead}{flag}+r<hex bytes><{tail}\n *\n * {lead} can be <Esc>P or DCS\n * {flag} can be '0' or '1'\n * {tail} can be Esc>\\ or STERM\n *\n * Check for cursor shape response from xterm:\n * {lead}1$r<digit> q{tail}\n *\n * {lead} can be <Esc>P or DCS\n * {tail} can be <Esc>\\ or STERM\n *\n * Consume any code that starts with \"{lead}.+r\" or \"{lead}.$r\".\n */\n    static int\nhandle_dcs(char_u *tp, char_u *argp, int len, char_u *key_name, int *slen)\n{\n    int i, j;\n\n    j = 1 + (tp[0] == ESC);\n    if (len < j + 3)\n\ti = len; // need more chars\n    else if ((argp[1] != '+' && argp[1] != '$') || argp[2] != 'r')\n\ti = 0; // no match\n    else if (argp[1] == '+')\n\t// key code response\n\tfor (i = j; i < len; ++i)\n\t{\n\t    if ((tp[i] == ESC && i + 1 < len && tp[i + 1] == '\\\\')\n\t\t    || tp[i] == STERM)\n\t    {\n\t\tif (i - j >= 3)\n\t\t    got_code_from_term(tp + j, i);\n\t\tkey_name[0] = (int)KS_EXTRA;\n\t\tkey_name[1] = (int)KE_IGNORE;\n\t\t*slen = i + 1 + (tp[i] == ESC);\n\t\tbreak;\n\t    }\n\t}\n    else\n    {\n\t// Probably the cursor shape response.  Make sure that \"i\"\n\t// is equal to \"len\" when there are not sufficient\n\t// characters.\n\tfor (i = j + 3; i < len; ++i)\n\t{\n\t    if (i - j == 3 && !isdigit(tp[i]))\n\t\tbreak;\n\t    if (i - j == 4 && tp[i] != ' ')\n\t\tbreak;\n\t    if (i - j == 5 && tp[i] != 'q')\n\t\tbreak;\n\t    if (i - j == 6 && tp[i] != ESC && tp[i] != STERM)\n\t\tbreak;\n\t    if ((i - j == 6 && tp[i] == STERM)\n\t     || (i - j == 7 && tp[i] == '\\\\'))\n\t    {\n\t\tint number = argp[3] - '0';\n\n\t\t// 0, 1 = block blink, 2 = block\n\t\t// 3 = underline blink, 4 = underline\n\t\t// 5 = vertical bar blink, 6 = vertical bar\n\t\tnumber = number == 0 ? 1 : number;\n\t\tinitial_cursor_shape = (number + 1) / 2;\n\t\t// The blink flag is actually inverted, compared to\n\t\t// the value set with T_SH.\n\t\tinitial_cursor_shape_blink =\n\t\t\t\t       (number & 1) ? FALSE : TRUE;\n\t\trcs_status.tr_progress = STATUS_GOT;\n\t\tLOG_TR((\"Received cursor shape response: %s\", tp));\n\n\t\tkey_name[0] = (int)KS_EXTRA;\n\t\tkey_name[1] = (int)KE_IGNORE;\n\t\t*slen = i + 1;\n# ifdef FEAT_EVAL\n\t\tset_vim_var_string(VV_TERMSTYLERESP, tp, *slen);\n# endif\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    if (i == len)\n    {\n\t// These codes arrive many together, each code can be\n\t// truncated at any point.\n\tLOG_TR((\"not enough characters for XT\"));\n\treturn FAIL;\n    }\n    return OK;\n}\n#endif // FEAT_TERMRESPONSE\n\n/*\n * Check if typebuf.tb_buf[] contains a terminal key code.\n * Check from typebuf.tb_buf[typebuf.tb_off] to typebuf.tb_buf[typebuf.tb_off\n * + \"max_offset\"].\n * Return 0 for no match, -1 for partial match, > 0 for full match.\n * Return KEYLEN_REMOVED when a key code was deleted.\n * With a match, the match is removed, the replacement code is inserted in\n * typebuf.tb_buf[] and the number of characters in typebuf.tb_buf[] is\n * returned.\n * When \"buf\" is not NULL, buf[bufsize] is used instead of typebuf.tb_buf[].\n * \"buflen\" is then the length of the string in buf[] and is updated for\n * inserts and deletes.\n */\n    int\ncheck_termcode(\n    int\t\tmax_offset,\n    char_u\t*buf,\n    int\t\tbufsize,\n    int\t\t*buflen)\n{\n    char_u\t*tp;\n    char_u\t*p;\n    int\t\tslen = 0;\t// init for GCC\n    int\t\tmodslen;\n    int\t\tlen;\n    int\t\tretval = 0;\n    int\t\toffset;\n    char_u\tkey_name[2];\n    int\t\tmodifiers;\n    char_u\t*modifiers_start = NULL;\n    int\t\tkey;\n    int\t\tnew_slen;   // Length of what will replace the termcode\n    char_u\tstring[MAX_KEY_CODE_LEN + 1];\n    int\t\ti, j;\n    int\t\tidx = 0;\n    int\t\tcpo_koffset;\n\n    cpo_koffset = (vim_strchr(p_cpo, CPO_KOFFSET) != NULL);\n\n    /*\n     * Speed up the checks for terminal codes by gathering all first bytes\n     * used in termleader[].  Often this is just a single <Esc>.\n     */\n    if (need_gather)\n\tgather_termleader();\n\n    /*\n     * Check at several positions in typebuf.tb_buf[], to catch something like\n     * \"x<Up>\" that can be mapped. Stop at max_offset, because characters\n     * after that cannot be used for mapping, and with @r commands\n     * typebuf.tb_buf[] can become very long.\n     * This is used often, KEEP IT FAST!\n     */\n    for (offset = 0; offset < max_offset; ++offset)\n    {\n\tif (buf == NULL)\n\t{\n\t    if (offset >= typebuf.tb_len)\n\t\tbreak;\n\t    tp = typebuf.tb_buf + typebuf.tb_off + offset;\n\t    len = typebuf.tb_len - offset;\t// length of the input\n\t}\n\telse\n\t{\n\t    if (offset >= *buflen)\n\t\tbreak;\n\t    tp = buf + offset;\n\t    len = *buflen - offset;\n\t}\n\n\t/*\n\t * Don't check characters after K_SPECIAL, those are already\n\t * translated terminal chars (avoid translating ~@^Hx).\n\t */\n\tif (*tp == K_SPECIAL)\n\t{\n\t    offset += 2;\t// there are always 2 extra characters\n\t    continue;\n\t}\n\n\t/*\n\t * Skip this position if the character does not appear as the first\n\t * character in term_strings. This speeds up a lot, since most\n\t * termcodes start with the same character (ESC or CSI).\n\t */\n\ti = *tp;\n\tfor (p = termleader; *p && *p != i; ++p)\n\t    ;\n\tif (*p == NUL)\n\t    continue;\n\n\t/*\n\t * Skip this position if p_ek is not set and tp[0] is an ESC and we\n\t * are in Insert mode.\n\t */\n\tif (*tp == ESC && !p_ek && (State & MODE_INSERT))\n\t    continue;\n\n\tkey_name[0] = NUL;\t// no key name found yet\n\tkey_name[1] = NUL;\t// no key name found yet\n\tmodifiers = 0;\t\t// no modifiers yet\n\n#ifdef FEAT_GUI\n\tif (gui.in_use)\n\t{\n\t    /*\n\t     * GUI special key codes are all of the form [CSI xx].\n\t     */\n\t    if (*tp == CSI)\t    // Special key from GUI\n\t    {\n\t\tif (len < 3)\n\t\t    return -1;\t    // Shouldn't happen\n\t\tslen = 3;\n\t\tkey_name[0] = tp[1];\n\t\tkey_name[1] = tp[2];\n\t    }\n\t}\n\telse\n#endif // FEAT_GUI\n\t{\n\t    int  mouse_index_found = -1;\n\n\t    for (idx = 0; idx < tc_len; ++idx)\n\t    {\n\t\t/*\n\t\t * Ignore the entry if we are not at the start of\n\t\t * typebuf.tb_buf[]\n\t\t * and there are not enough characters to make a match.\n\t\t * But only when the 'K' flag is in 'cpoptions'.\n\t\t */\n\t\tslen = termcodes[idx].len;\n\t\tmodifiers_start = NULL;\n\t\tif (cpo_koffset && offset && len < slen)\n\t\t    continue;\n\t\tif (STRNCMP(termcodes[idx].code, tp,\n\t\t\t\t     (size_t)(slen > len ? len : slen)) == 0)\n\t\t{\n\t\t    int\t    looks_like_mouse_start = FALSE;\n\n\t\t    if (len < slen)\t\t// got a partial sequence\n\t\t\treturn -1;\t\t// need to get more chars\n\n\t\t    /*\n\t\t     * When found a keypad key, check if there is another key\n\t\t     * that matches and use that one.  This makes <Home> to be\n\t\t     * found instead of <kHome> when they produce the same\n\t\t     * key code.\n\t\t     */\n\t\t    if (termcodes[idx].name[0] == 'K'\n\t\t\t\t       && VIM_ISDIGIT(termcodes[idx].name[1]))\n\t\t    {\n\t\t\tfor (j = idx + 1; j < tc_len; ++j)\n\t\t\t    if (termcodes[j].len == slen &&\n\t\t\t\t    STRNCMP(termcodes[idx].code,\n\t\t\t\t\t    termcodes[j].code, slen) == 0)\n\t\t\t    {\n\t\t\t\tidx = j;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t    }\n\n\t\t    if (slen == 2 && len > 2\n\t\t\t    && termcodes[idx].code[0] == ESC\n\t\t\t    && termcodes[idx].code[1] == '[')\n\t\t    {\n\t\t\t// The mouse termcode \"ESC [\" is also the prefix of\n\t\t\t// \"ESC [ I\" (focus gained) and other keys.  Check some\n\t\t\t// more bytes to find out.\n\t\t\tif (!isdigit(tp[2]))\n\t\t\t{\n\t\t\t    // ESC [ without number following: Only use it when\n\t\t\t    // there is no other match.\n\t\t\t    looks_like_mouse_start = TRUE;\n\t\t\t}\n\t\t\telse if (termcodes[idx].name[0] == KS_DEC_MOUSE)\n\t\t\t{\n\t\t\t    char_u  *nr = tp + 2;\n\t\t\t    int\t    count = 0;\n\n\t\t\t    // If a digit is following it could be a key with\n\t\t\t    // modifier, e.g., ESC [ 1;2P.  Can be confused\n\t\t\t    // with DEC_MOUSE, which requires four numbers\n\t\t\t    // following.  If not then it can't be a DEC_MOUSE\n\t\t\t    // code.\n\t\t\t    for (;;)\n\t\t\t    {\n\t\t\t\t++count;\n\t\t\t\t(void)getdigits(&nr);\n\t\t\t\tif (nr >= tp + len)\n\t\t\t\t    return -1;\t// partial sequence\n\t\t\t\tif (*nr != ';')\n\t\t\t\t    break;\n\t\t\t\t++nr;\n\t\t\t\tif (nr >= tp + len)\n\t\t\t\t    return -1;\t// partial sequence\n\t\t\t    }\n\t\t\t    if (count < 4)\n\t\t\t\tcontinue;\t// no match\n\t\t\t}\n\t\t    }\n\t\t    if (looks_like_mouse_start)\n\t\t    {\n\t\t\t// Only use it when there is no other match.\n\t\t\tif (mouse_index_found < 0)\n\t\t\t    mouse_index_found = idx;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tkey_name[0] = termcodes[idx].name[0];\n\t\t\tkey_name[1] = termcodes[idx].name[1];\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\n\t\t/*\n\t\t * Check for code with modifier, like xterm uses:\n\t\t * <Esc>[123;*X  (modslen == slen - 3)\n\t\t * <Esc>[@;*X    (matches <Esc>[X and <Esc>[1;9X )\n\t\t * Also <Esc>O*X and <M-O>*X (modslen == slen - 2).\n\t\t * When there is a modifier the * matches a number.\n\t\t * When there is no modifier the ;* or * is omitted.\n\t\t */\n\t\tif (termcodes[idx].modlen > 0 && mouse_index_found < 0)\n\t\t{\n\t\t    int at_code;\n\n\t\t    modslen = termcodes[idx].modlen;\n\t\t    if (cpo_koffset && offset && len < modslen)\n\t\t\tcontinue;\n\t\t    at_code = termcodes[idx].code[modslen] == '@';\n\t\t    if (STRNCMP(termcodes[idx].code, tp,\n\t\t\t\t(size_t)(modslen > len ? len : modslen)) == 0)\n\t\t    {\n\t\t\tint\t    n;\n\n\t\t\tif (len <= modslen)\t// got a partial sequence\n\t\t\t    return -1;\t\t// need to get more chars\n\n\t\t\tif (tp[modslen] == termcodes[idx].code[slen - 1])\n\t\t\t    // no modifiers\n\t\t\t    slen = modslen + 1;\n\t\t\telse if (tp[modslen] != ';' && modslen == slen - 3)\n\t\t\t    // no match for \"code;*X\" with \"code;\"\n\t\t\t    continue;\n\t\t\telse if (at_code && tp[modslen] != '1')\n\t\t\t    // no match for \"<Esc>[@\" with \"<Esc>[1\"\n\t\t\t    continue;\n\t\t\telse\n\t\t\t{\n\t\t\t    // Skip over the digits, the final char must\n\t\t\t    // follow. URXVT can use a negative value, thus\n\t\t\t    // also accept '-'.\n\t\t\t    for (j = slen - 2; j < len && (isdigit(tp[j])\n\t\t\t\t       || tp[j] == '-' || tp[j] == ';'); ++j)\n\t\t\t\t;\n\t\t\t    ++j;\n\t\t\t    if (len < j)\t// got a partial sequence\n\t\t\t\treturn -1;\t// need to get more chars\n\t\t\t    if (tp[j - 1] != termcodes[idx].code[slen - 1])\n\t\t\t\tcontinue;\t// no match\n\n\t\t\t    modifiers_start = tp + slen - 2;\n\n\t\t\t    // Match!  Convert modifier bits.\n\t\t\t    n = atoi((char *)modifiers_start);\n\t\t\t    modifiers |= decode_modifiers(n);\n\n\t\t\t    slen = j;\n\t\t\t}\n\t\t\tkey_name[0] = termcodes[idx].name[0];\n\t\t\tkey_name[1] = termcodes[idx].name[1];\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t    if (idx == tc_len && mouse_index_found >= 0)\n\t    {\n\t\tkey_name[0] = termcodes[mouse_index_found].name[0];\n\t\tkey_name[1] = termcodes[mouse_index_found].name[1];\n\t    }\n\t}\n\n#ifdef FEAT_TERMRESPONSE\n\tif (key_name[0] == NUL\n\t    // Mouse codes of DEC and pterm start with <ESC>[.  When\n\t    // detecting the start of these mouse codes they might as well be\n\t    // another key code or terminal response.\n# ifdef FEAT_MOUSE_DEC\n\t    || key_name[0] == KS_DEC_MOUSE\n# endif\n# ifdef FEAT_MOUSE_PTERM\n\t    || key_name[0] == KS_PTERM_MOUSE\n# endif\n\t   )\n\t{\n\t    char_u *argp = tp[0] == ESC ? tp + 2 : tp + 1;\n\n\t    /*\n\t     * Check for responses from the terminal starting with {lead}:\n\t     * \"<Esc>[\" or CSI followed by [0-9>?]\n\t     *\n\t     * - Xterm version string: {lead}>{x};{vers};{y}c\n\t     *   Also eat other possible responses to t_RV, rxvt returns\n\t     *   \"{lead}?1;2c\".\n\t     *\n\t     * - Cursor position report: {lead}{row};{col}R\n\t     *   The final byte must be 'R'. It is used for checking the\n\t     *   ambiguous-width character state.\n\t     *\n\t     * - window position reply: {lead}3;{x};{y}t\n\t     *\n\t     * - key with modifiers when modifyOtherKeys is enabled:\n\t     *\t    {lead}27;{modifier};{key}~\n\t     *\t    {lead}{key};{modifier}u\n\t     */\n\t    if (((tp[0] == ESC && len >= 3 && tp[1] == '[')\n\t\t\t    || (tp[0] == CSI && len >= 2))\n\t\t    && (VIM_ISDIGIT(*argp) || *argp == '>' || *argp == '?'))\n\t    {\n\t\tint resp = handle_csi(tp, len, argp, offset, buf,\n\t\t\t\t\t     bufsize, buflen, key_name, &slen);\n\t\tif (resp != 0)\n\t\t{\n# ifdef DEBUG_TERMRESPONSE\n\t\t    if (resp == -1)\n\t\t\tLOG_TR((\"Not enough characters for CSI sequence\"));\n# endif\n\t\t    return resp;\n\t\t}\n\t    }\n\n\t    // Check for fore/background color response from the terminal,\n\t    // starting} with <Esc>] or OSC\n\t    else if ((*T_RBG != NUL || *T_RFG != NUL)\n\t\t\t&& ((tp[0] == ESC && len >= 2 && tp[1] == ']')\n\t\t\t    || tp[0] == OSC))\n\t    {\n\t\tif (handle_osc(tp, argp, len, key_name, &slen) == FAIL)\n\t\t    return -1;\n\t    }\n\n\t    // Check for key code response from xterm,\n\t    // starting with <Esc>P or DCS\n\t    else if ((check_for_codes || rcs_status.tr_progress == STATUS_SENT)\n\t\t    && ((tp[0] == ESC && len >= 2 && tp[1] == 'P')\n\t\t\t|| tp[0] == DCS))\n\t    {\n\t\tif (handle_dcs(tp, argp, len, key_name, &slen) == FAIL)\n\t\t    return -1;\n\t    }\n\t}\n#endif\n\n\tif (key_name[0] == NUL)\n\t    continue;\t    // No match at this position, try next one\n\n\t// We only get here when we have a complete termcode match\n\n#ifdef FEAT_GUI\n\t/*\n\t * Only in the GUI: Fetch the pointer coordinates of the scroll event\n\t * so that we know which window to scroll later.\n\t */\n\tif (gui.in_use\n\t\t&& key_name[0] == (int)KS_EXTRA\n\t\t&& (key_name[1] == (int)KE_X1MOUSE\n\t\t    || key_name[1] == (int)KE_X2MOUSE\n\t\t    || key_name[1] == (int)KE_MOUSEMOVE_XY\n\t\t    || key_name[1] == (int)KE_MOUSELEFT\n\t\t    || key_name[1] == (int)KE_MOUSERIGHT\n\t\t    || key_name[1] == (int)KE_MOUSEDOWN\n\t\t    || key_name[1] == (int)KE_MOUSEUP))\n\t{\n\t    char_u\tbytes[6];\n\t    int\t\tnum_bytes = get_bytes_from_buf(tp + slen, bytes, 4);\n\n\t    if (num_bytes == -1)\t// not enough coordinates\n\t\treturn -1;\n\t    mouse_col = 128 * (bytes[0] - ' ' - 1) + bytes[1] - ' ' - 1;\n\t    mouse_row = 128 * (bytes[2] - ' ' - 1) + bytes[3] - ' ' - 1;\n\t    slen += num_bytes;\n\t    // equal to K_MOUSEMOVE\n\t    if (key_name[1] == (int)KE_MOUSEMOVE_XY)\n\t\tkey_name[1] = (int)KE_MOUSEMOVE;\n\t}\n\telse\n#endif\n\t/*\n\t * If it is a mouse click, get the coordinates.\n\t */\n\tif (key_name[0] == KS_MOUSE\n#ifdef FEAT_MOUSE_GPM\n\t\t|| key_name[0] == KS_GPM_MOUSE\n#endif\n#ifdef FEAT_MOUSE_JSB\n\t\t|| key_name[0] == KS_JSBTERM_MOUSE\n#endif\n#ifdef FEAT_MOUSE_NET\n\t\t|| key_name[0] == KS_NETTERM_MOUSE\n#endif\n#ifdef FEAT_MOUSE_DEC\n\t\t|| key_name[0] == KS_DEC_MOUSE\n#endif\n#ifdef FEAT_MOUSE_PTERM\n\t\t|| key_name[0] == KS_PTERM_MOUSE\n#endif\n#ifdef FEAT_MOUSE_URXVT\n\t\t|| key_name[0] == KS_URXVT_MOUSE\n#endif\n\t\t|| key_name[0] == KS_SGR_MOUSE\n\t\t|| key_name[0] == KS_SGR_MOUSE_RELEASE)\n\t{\n\t    if (check_termcode_mouse(tp, &slen, key_name, modifiers_start, idx,\n\t\t\t\t\t\t\t     &modifiers) == -1)\n\t\treturn -1;\n\t}\n\n#ifdef FEAT_GUI\n\t/*\n\t * If using the GUI, then we get menu and scrollbar events.\n\t *\n\t * A menu event is encoded as K_SPECIAL, KS_MENU, KE_FILLER followed by\n\t * four bytes which are to be taken as a pointer to the vimmenu_T\n\t * structure.\n\t *\n\t * A tab line event is encoded as K_SPECIAL KS_TABLINE nr, where \"nr\"\n\t * is one byte with the tab index.\n\t *\n\t * A scrollbar event is K_SPECIAL, KS_VER_SCROLLBAR, KE_FILLER followed\n\t * by one byte representing the scrollbar number, and then four bytes\n\t * representing a long_u which is the new value of the scrollbar.\n\t *\n\t * A horizontal scrollbar event is K_SPECIAL, KS_HOR_SCROLLBAR,\n\t * KE_FILLER followed by four bytes representing a long_u which is the\n\t * new value of the scrollbar.\n\t */\n# ifdef FEAT_MENU\n\telse if (key_name[0] == (int)KS_MENU)\n\t{\n\t    long_u\tval;\n\t    int\t\tnum_bytes = get_long_from_buf(tp + slen, &val);\n\n\t    if (num_bytes == -1)\n\t\treturn -1;\n\t    current_menu = (vimmenu_T *)val;\n\t    slen += num_bytes;\n\n\t    // The menu may have been deleted right after it was used, check\n\t    // for that.\n\t    if (check_menu_pointer(root_menu, current_menu) == FAIL)\n\t    {\n\t\tkey_name[0] = KS_EXTRA;\n\t\tkey_name[1] = (int)KE_IGNORE;\n\t    }\n\t}\n# endif\n# ifdef FEAT_GUI_TABLINE\n\telse if (key_name[0] == (int)KS_TABLINE)\n\t{\n\t    // Selecting tabline tab or using its menu.\n\t    char_u\tbytes[6];\n\t    int\t\tnum_bytes = get_bytes_from_buf(tp + slen, bytes, 1);\n\n\t    if (num_bytes == -1)\n\t\treturn -1;\n\t    current_tab = (int)bytes[0];\n\t    if (current_tab == 255)\t// -1 in a byte gives 255\n\t\tcurrent_tab = -1;\n\t    slen += num_bytes;\n\t}\n\telse if (key_name[0] == (int)KS_TABMENU)\n\t{\n\t    // Selecting tabline tab or using its menu.\n\t    char_u\tbytes[6];\n\t    int\t\tnum_bytes = get_bytes_from_buf(tp + slen, bytes, 2);\n\n\t    if (num_bytes == -1)\n\t\treturn -1;\n\t    current_tab = (int)bytes[0];\n\t    current_tabmenu = (int)bytes[1];\n\t    slen += num_bytes;\n\t}\n# endif\n# ifndef USE_ON_FLY_SCROLL\n\telse if (key_name[0] == (int)KS_VER_SCROLLBAR)\n\t{\n\t    long_u\tval;\n\t    char_u\tbytes[6];\n\t    int\t\tnum_bytes;\n\n\t    // Get the last scrollbar event in the queue of the same type\n\t    j = 0;\n\t    for (i = 0; tp[j] == CSI && tp[j + 1] == KS_VER_SCROLLBAR\n\t\t\t\t\t\t     && tp[j + 2] != NUL; ++i)\n\t    {\n\t\tj += 3;\n\t\tnum_bytes = get_bytes_from_buf(tp + j, bytes, 1);\n\t\tif (num_bytes == -1)\n\t\t    break;\n\t\tif (i == 0)\n\t\t    current_scrollbar = (int)bytes[0];\n\t\telse if (current_scrollbar != (int)bytes[0])\n\t\t    break;\n\t\tj += num_bytes;\n\t\tnum_bytes = get_long_from_buf(tp + j, &val);\n\t\tif (num_bytes == -1)\n\t\t    break;\n\t\tscrollbar_value = val;\n\t\tj += num_bytes;\n\t\tslen = j;\n\t    }\n\t    if (i == 0)\t\t// not enough characters to make one\n\t\treturn -1;\n\t}\n\telse if (key_name[0] == (int)KS_HOR_SCROLLBAR)\n\t{\n\t    long_u\tval;\n\t    int\t\tnum_bytes;\n\n\t    // Get the last horiz. scrollbar event in the queue\n\t    j = 0;\n\t    for (i = 0; tp[j] == CSI && tp[j + 1] == KS_HOR_SCROLLBAR\n\t\t\t\t\t\t     && tp[j + 2] != NUL; ++i)\n\t    {\n\t\tj += 3;\n\t\tnum_bytes = get_long_from_buf(tp + j, &val);\n\t\tif (num_bytes == -1)\n\t\t    break;\n\t\tscrollbar_value = val;\n\t\tj += num_bytes;\n\t\tslen = j;\n\t    }\n\t    if (i == 0)\t\t// not enough characters to make one\n\t\treturn -1;\n\t}\n# endif // !USE_ON_FLY_SCROLL\n#endif // FEAT_GUI\n\n#if (defined(UNIX) || defined(VMS))\n\t/*\n\t * Handle FocusIn/FocusOut event sequences reported by XTerm.\n\t * (CSI I/CSI O)\n\t */\n\tif (key_name[0] == KS_EXTRA\n# ifdef FEAT_GUI\n\t\t&& !gui.in_use\n# endif\n\t    )\n\t{\n\t    if (key_name[1] == KE_FOCUSGAINED)\n\t    {\n\t\tif (!focus_state)\n\t\t{\n\t\t    ui_focus_change(TRUE);\n\t\t    did_cursorhold = TRUE;\n\t\t    focus_state = TRUE;\n\t\t}\n\t\tkey_name[1] = (int)KE_IGNORE;\n\t    }\n\t    else if (key_name[1] == KE_FOCUSLOST)\n\t    {\n\t\tif (focus_state)\n\t\t{\n\t\t    ui_focus_change(FALSE);\n\t\t    did_cursorhold = TRUE;\n\t\t    focus_state = FALSE;\n\t\t}\n\t\tkey_name[1] = (int)KE_IGNORE;\n\t    }\n\t}\n#endif\n\n\t/*\n\t * Change <xHome> to <Home>, <xUp> to <Up>, etc.\n\t */\n\tkey = handle_x_keys(TERMCAP2KEY(key_name[0], key_name[1]));\n\n\t/*\n\t * Add any modifier codes to our string.\n\t */\n\tnew_slen = modifiers2keycode(modifiers, &key, string);\n\n\t// Finally, add the special key code to our string\n\tkey_name[0] = KEY2TERMCAP0(key);\n\tkey_name[1] = KEY2TERMCAP1(key);\n\tif (key_name[0] == KS_KEY)\n\t{\n\t    // from \":set <M-b>=xx\"\n\t    if (has_mbyte)\n\t\tnew_slen += (*mb_char2bytes)(key_name[1], string + new_slen);\n\t    else\n\t\tstring[new_slen++] = key_name[1];\n\t}\n\telse if (new_slen == 0 && key_name[0] == KS_EXTRA\n\t\t\t\t\t\t  && key_name[1] == KE_IGNORE)\n\t{\n\t    // Do not put K_IGNORE into the buffer, do return KEYLEN_REMOVED\n\t    // to indicate what happened.\n\t    retval = KEYLEN_REMOVED;\n\t}\n\telse\n\t{\n\t    string[new_slen++] = K_SPECIAL;\n\t    string[new_slen++] = key_name[0];\n\t    string[new_slen++] = key_name[1];\n\t}\n\tif (put_string_in_typebuf(offset, slen, string, new_slen,\n\t\t\t\t\t\t buf, bufsize, buflen) == FAIL)\n\t    return -1;\n\treturn retval == 0 ? (len + new_slen - slen + offset) : retval;\n    }\n\n#ifdef FEAT_TERMRESPONSE\n    LOG_TR((\"normal character\"));\n#endif\n\n    return 0;\t\t\t    // no match found\n}\n\n#if (defined(FEAT_TERMINAL) && defined(FEAT_TERMRESPONSE)) || defined(PROTO)\n/*\n * Get the text foreground color, if known.\n */\n    void\nterm_get_fg_color(char_u *r, char_u *g, char_u *b)\n{\n    if (rfg_status.tr_progress == STATUS_GOT)\n    {\n\t*r = fg_r;\n\t*g = fg_g;\n\t*b = fg_b;\n    }\n}\n\n/*\n * Get the text background color, if known.\n */\n    void\nterm_get_bg_color(char_u *r, char_u *g, char_u *b)\n{\n    if (rbg_status.tr_progress == STATUS_GOT)\n    {\n\t*r = bg_r;\n\t*g = bg_g;\n\t*b = bg_b;\n    }\n}\n#endif\n\n/*\n * Replace any terminal code strings in from[] with the equivalent internal\n * vim representation.\tThis is used for the \"from\" and \"to\" part of a\n * mapping, and the \"to\" part of a menu command.\n * Any strings like \"<C-UP>\" are also replaced, unless 'cpoptions' contains\n * '<'.\n * K_SPECIAL by itself is replaced by K_SPECIAL KS_SPECIAL KE_FILLER.\n *\n * The replacement is done in result[] and finally copied into allocated\n * memory. If this all works well *bufp is set to the allocated memory and a\n * pointer to it is returned. If something fails *bufp is set to NULL and from\n * is returned.\n *\n * CTRL-V characters are removed.  When \"flags\" has REPTERM_FROM_PART, a\n * trailing CTRL-V is included, otherwise it is removed (for \":map xx ^V\", maps\n * xx to nothing).  When 'cpoptions' does not contain 'B', a backslash can be\n * used instead of a CTRL-V.\n *\n * Flags:\n *  REPTERM_FROM_PART\tsee above\n *  REPTERM_DO_LT\talso translate <lt>\n *  REPTERM_SPECIAL\talways accept <key> notation\n *  REPTERM_NO_SIMPLIFY\tdo not simplify <C-H> to 0x08 and set 8th bit for <A-x>\n *\n * \"did_simplify\" is set when some <C-H> or <A-x> code was simplified, unless\n * it is NULL.\n */\n    char_u *\nreplace_termcodes(\n    char_u\t*from,\n    char_u\t**bufp,\n    int\t\tflags,\n    int\t\t*did_simplify)\n{\n    int\t\ti;\n    int\t\tslen;\n    int\t\tkey;\n    size_t\tdlen = 0;\n    char_u\t*src;\n    int\t\tdo_backslash;\t// backslash is a special character\n    int\t\tdo_special;\t// recognize <> key codes\n    int\t\tdo_key_code;\t// recognize raw key codes\n    char_u\t*result;\t// buffer for resulting string\n    garray_T\tga;\n\n    do_backslash = (vim_strchr(p_cpo, CPO_BSLASH) == NULL);\n    do_special = (vim_strchr(p_cpo, CPO_SPECI) == NULL)\n\t\t\t\t\t\t  || (flags & REPTERM_SPECIAL);\n    do_key_code = (vim_strchr(p_cpo, CPO_KEYCODE) == NULL);\n    src = from;\n\n    /*\n     * Allocate space for the translation.  Worst case a single character is\n     * replaced by 6 bytes (shifted special key), plus a NUL at the end.\n     * In the rare case more might be needed ga_grow() must be called again.\n     */\n    ga_init2(&ga, 1L, 100);\n    if (ga_grow(&ga, (int)(STRLEN(src) * 6 + 1)) == FAIL) // out of memory\n    {\n\t*bufp = NULL;\n\treturn from;\n    }\n    result = ga.ga_data;\n\n    /*\n     * Check for #n at start only: function key n\n     */\n    if ((flags & REPTERM_FROM_PART) && src[0] == '#' && VIM_ISDIGIT(src[1]))\n    {\n\tresult[dlen++] = K_SPECIAL;\n\tresult[dlen++] = 'k';\n\tif (src[1] == '0')\n\t    result[dlen++] = ';';\t// #0 is F10 is \"k;\"\n\telse\n\t    result[dlen++] = src[1];\t// #3 is F3 is \"k3\"\n\tsrc += 2;\n    }\n\n    /*\n     * Copy each byte from *from to result[dlen]\n     */\n    while (*src != NUL)\n    {\n\t/*\n\t * If 'cpoptions' does not contain '<', check for special key codes,\n\t * like \"<C-S-LeftMouse>\"\n\t */\n\tif (do_special && ((flags & REPTERM_DO_LT)\n\t\t\t\t\t      || STRNCMP(src, \"<lt>\", 4) != 0))\n\t{\n#ifdef FEAT_EVAL\n\t    /*\n\t     * Change <SID>Func to K_SNR <script-nr> _Func.  This name is used\n\t     * for script-locla user functions.\n\t     * (room: 5 * 6 = 30 bytes; needed: 3 + <nr> + 1 <= 14)\n\t     * Also change <SID>name.Func to K_SNR <import-script-nr> _Func.\n\t     * Only if \"name\" is recognized as an import.\n\t     */\n\t    if (STRNICMP(src, \"<SID>\", 5) == 0)\n\t    {\n\t\tif (current_sctx.sc_sid <= 0)\n\t\t    emsg(_(e_using_sid_not_in_script_context));\n\t\telse\n\t\t{\n\t\t    char_u  *dot;\n\t\t    long    sid = current_sctx.sc_sid;\n\n\t\t    src += 5;\n\t\t    if (in_vim9script()\n\t\t\t\t       && (dot = vim_strchr(src, '.')) != NULL)\n\t\t    {\n\t\t\timported_T *imp = find_imported(src, dot - src, FALSE);\n\n\t\t\tif (imp != NULL)\n\t\t\t{\n\t\t\t    scriptitem_T    *si = SCRIPT_ITEM(imp->imp_sid);\n\t\t\t    size_t\t    len;\n\n\t\t\t    src = dot + 1;\n\t\t\t    if (si->sn_autoload_prefix != NULL)\n\t\t\t    {\n\t\t\t\t// Turn \"<SID>name.Func\"\n\t\t\t\t// into \"scriptname#Func\".\n\t\t\t\tlen = STRLEN(si->sn_autoload_prefix);\n\t\t\t\tif (ga_grow(&ga,\n\t\t\t\t     (int)(STRLEN(src) * 6 + len + 1)) == FAIL)\n\t\t\t\t{\n\t\t\t\t    ga_clear(&ga);\n\t\t\t\t    *bufp = NULL;\n\t\t\t\t    return from;\n\t\t\t\t}\n\t\t\t\tresult = ga.ga_data;\n\t\t\t\tSTRCPY(result + dlen, si->sn_autoload_prefix);\n\t\t\t\tdlen += len;\n\t\t\t\tcontinue;\n\t\t\t    }\n\t\t\t    sid = imp->imp_sid;\n\t\t\t}\n\t\t    }\n\n\t\t    result[dlen++] = K_SPECIAL;\n\t\t    result[dlen++] = (int)KS_EXTRA;\n\t\t    result[dlen++] = (int)KE_SNR;\n\t\t    sprintf((char *)result + dlen, \"%ld\", sid);\n\t\t    dlen += STRLEN(result + dlen);\n\t\t    result[dlen++] = '_';\n\t\t    continue;\n\t\t}\n\t    }\n#endif\n\t    slen = trans_special(&src, result + dlen, FSK_KEYCODE\n\t\t\t  | ((flags & REPTERM_NO_SIMPLIFY) ? 0 : FSK_SIMPLIFY),\n\t\t\t\t\t\t\t   TRUE, did_simplify);\n\t    if (slen)\n\t    {\n\t\tdlen += slen;\n\t\tcontinue;\n\t    }\n\t}\n\n\t/*\n\t * If 'cpoptions' does not contain 'k', see if it's an actual key-code.\n\t * Note that this is also checked after replacing the <> form.\n\t * Single character codes are NOT replaced (e.g. ^H or DEL), because\n\t * it could be a character in the file.\n\t */\n\tif (do_key_code)\n\t{\n\t    i = find_term_bykeys(src);\n\t    if (i >= 0)\n\t    {\n\t\tresult[dlen++] = K_SPECIAL;\n\t\tresult[dlen++] = termcodes[i].name[0];\n\t\tresult[dlen++] = termcodes[i].name[1];\n\t\tsrc += termcodes[i].len;\n\t\t// If terminal code matched, continue after it.\n\t\tcontinue;\n\t    }\n\t}\n\n#ifdef FEAT_EVAL\n\tif (do_special)\n\t{\n\t    char_u\t*p, *s, len;\n\n\t    /*\n\t     * Replace <Leader> by the value of \"mapleader\".\n\t     * Replace <LocalLeader> by the value of \"maplocalleader\".\n\t     * If \"mapleader\" or \"maplocalleader\" isn't set use a backslash.\n\t     */\n\t    if (STRNICMP(src, \"<Leader>\", 8) == 0)\n\t    {\n\t\tlen = 8;\n\t\tp = get_var_value((char_u *)\"g:mapleader\");\n\t    }\n\t    else if (STRNICMP(src, \"<LocalLeader>\", 13) == 0)\n\t    {\n\t\tlen = 13;\n\t\tp = get_var_value((char_u *)\"g:maplocalleader\");\n\t    }\n\t    else\n\t    {\n\t\tlen = 0;\n\t\tp = NULL;\n\t    }\n\t    if (len != 0)\n\t    {\n\t\t// Allow up to 8 * 6 characters for \"mapleader\".\n\t\tif (p == NULL || *p == NUL || STRLEN(p) > 8 * 6)\n\t\t    s = (char_u *)\"\\\\\";\n\t\telse\n\t\t    s = p;\n\t\twhile (*s != NUL)\n\t\t    result[dlen++] = *s++;\n\t\tsrc += len;\n\t\tcontinue;\n\t    }\n\t}\n#endif\n\n\t/*\n\t * Remove CTRL-V and ignore the next character.\n\t * For \"from\" side the CTRL-V at the end is included, for the \"to\"\n\t * part it is removed.\n\t * If 'cpoptions' does not contain 'B', also accept a backslash.\n\t */\n\tkey = *src;\n\tif (key == Ctrl_V || (do_backslash && key == '\\\\'))\n\t{\n\t    ++src;\t\t\t\t// skip CTRL-V or backslash\n\t    if (*src == NUL)\n\t    {\n\t\tif (flags & REPTERM_FROM_PART)\n\t\t    result[dlen++] = key;\n\t\tbreak;\n\t    }\n\t}\n\n\t// skip multibyte char correctly\n\tfor (i = (*mb_ptr2len)(src); i > 0; --i)\n\t{\n\t    /*\n\t     * If the character is K_SPECIAL, replace it with K_SPECIAL\n\t     * KS_SPECIAL KE_FILLER.\n\t     * If compiled with the GUI replace CSI with K_CSI.\n\t     */\n\t    if (*src == K_SPECIAL)\n\t    {\n\t\tresult[dlen++] = K_SPECIAL;\n\t\tresult[dlen++] = KS_SPECIAL;\n\t\tresult[dlen++] = KE_FILLER;\n\t    }\n# ifdef FEAT_GUI\n\t    else if (*src == CSI)\n\t    {\n\t\tresult[dlen++] = K_SPECIAL;\n\t\tresult[dlen++] = KS_EXTRA;\n\t\tresult[dlen++] = (int)KE_CSI;\n\t    }\n# endif\n\t    else\n\t\tresult[dlen++] = *src;\n\t    ++src;\n\t}\n    }\n    result[dlen] = NUL;\n\n    /*\n     * Copy the new string to allocated memory.\n     * If this fails, just return from.\n     */\n    if ((*bufp = vim_strsave(result)) != NULL)\n\tfrom = *bufp;\n    vim_free(result);\n    return from;\n}\n\n/*\n * Find a termcode with keys 'src' (must be NUL terminated).\n * Return the index in termcodes[], or -1 if not found.\n */\n    static int\nfind_term_bykeys(char_u *src)\n{\n    int\t\ti;\n    int\t\tslen = (int)STRLEN(src);\n\n    for (i = 0; i < tc_len; ++i)\n    {\n\tif (slen == termcodes[i].len\n\t\t\t&& STRNCMP(termcodes[i].code, src, (size_t)slen) == 0)\n\t    return i;\n    }\n    return -1;\n}\n\n/*\n * Gather the first characters in the terminal key codes into a string.\n * Used to speed up check_termcode().\n */\n    static void\ngather_termleader(void)\n{\n    int\t    i;\n    int\t    len = 0;\n\n#ifdef FEAT_GUI\n    if (gui.in_use)\n\ttermleader[len++] = CSI;    // the GUI codes are not in termcodes[]\n#endif\n#ifdef FEAT_TERMRESPONSE\n    if (check_for_codes || *T_CRS != NUL)\n\ttermleader[len++] = DCS;    // the termcode response starts with DCS\n\t\t\t\t    // in 8-bit mode\n#endif\n    termleader[len] = NUL;\n\n    for (i = 0; i < tc_len; ++i)\n\tif (vim_strchr(termleader, termcodes[i].code[0]) == NULL)\n\t{\n\t    termleader[len++] = termcodes[i].code[0];\n\t    termleader[len] = NUL;\n\t}\n\n    need_gather = FALSE;\n}\n\n/*\n * Show all termcodes (for \":set termcap\")\n * This code looks a lot like showoptions(), but is different.\n * \"flags\" can have OPT_ONECOLUMN.\n */\n    void\nshow_termcodes(int flags)\n{\n    int\t\tcol;\n    int\t\t*items;\n    int\t\titem_count;\n    int\t\trun;\n    int\t\trow, rows;\n    int\t\tcols;\n    int\t\ti;\n    int\t\tlen;\n\n#define INC3 27\t    // try to make three columns\n#define INC2 40\t    // try to make two columns\n#define GAP 2\t    // spaces between columns\n\n    if (tc_len == 0)\t    // no terminal codes (must be GUI)\n\treturn;\n    items = ALLOC_MULT(int, tc_len);\n    if (items == NULL)\n\treturn;\n\n    // Highlight title\n    msg_puts_title(_(\"\\n--- Terminal keys ---\"));\n\n    /*\n     * Do the loop three times:\n     * 1. display the short items (non-strings and short strings)\n     * 2. display the medium items (medium length strings)\n     * 3. display the long items (remaining strings)\n     * When \"flags\" has OPT_ONECOLUMN do everything in 3.\n     */\n    for (run = (flags & OPT_ONECOLUMN) ? 3 : 1; run <= 3 && !got_int; ++run)\n    {\n\t/*\n\t * collect the items in items[]\n\t */\n\titem_count = 0;\n\tfor (i = 0; i < tc_len; i++)\n\t{\n\t    len = show_one_termcode(termcodes[i].name,\n\t\t\t\t\t\t    termcodes[i].code, FALSE);\n\t    if ((flags & OPT_ONECOLUMN) ||\n\t\t    (len <= INC3 - GAP ? run == 1\n\t\t\t: len <= INC2 - GAP ? run == 2\n\t\t\t: run == 3))\n\t\titems[item_count++] = i;\n\t}\n\n\t/*\n\t * display the items\n\t */\n\tif (run <= 2)\n\t{\n\t    cols = (Columns + GAP) / (run == 1 ? INC3 : INC2);\n\t    if (cols == 0)\n\t\tcols = 1;\n\t    rows = (item_count + cols - 1) / cols;\n\t}\n\telse\t// run == 3\n\t    rows = item_count;\n\tfor (row = 0; row < rows && !got_int; ++row)\n\t{\n\t    msg_putchar('\\n');\t\t\t// go to next line\n\t    if (got_int)\t\t\t// 'q' typed in more\n\t\tbreak;\n\t    col = 0;\n\t    for (i = row; i < item_count; i += rows)\n\t    {\n\t\tmsg_col = col;\t\t\t// make columns\n\t\tshow_one_termcode(termcodes[items[i]].name,\n\t\t\t\t\t      termcodes[items[i]].code, TRUE);\n\t\tif (run == 2)\n\t\t    col += INC2;\n\t\telse\n\t\t    col += INC3;\n\t    }\n\t    out_flush();\n\t    ui_breakcheck();\n\t}\n    }\n    vim_free(items);\n}\n\n/*\n * Show one termcode entry.\n * Output goes into IObuff[]\n */\n    int\nshow_one_termcode(char_u *name, char_u *code, int printit)\n{\n    char_u\t*p;\n    int\t\tlen;\n\n    if (name[0] > '~')\n    {\n\tIObuff[0] = ' ';\n\tIObuff[1] = ' ';\n\tIObuff[2] = ' ';\n\tIObuff[3] = ' ';\n    }\n    else\n    {\n\tIObuff[0] = 't';\n\tIObuff[1] = '_';\n\tIObuff[2] = name[0];\n\tIObuff[3] = name[1];\n    }\n    IObuff[4] = ' ';\n\n    p = get_special_key_name(TERMCAP2KEY(name[0], name[1]), 0);\n    if (p[1] != 't')\n\tSTRCPY(IObuff + 5, p);\n    else\n\tIObuff[5] = NUL;\n    len = (int)STRLEN(IObuff);\n    do\n\tIObuff[len++] = ' ';\n    while (len < 17);\n    IObuff[len] = NUL;\n    if (code == NULL)\n\tlen += 4;\n    else\n\tlen += vim_strsize(code);\n\n    if (printit)\n    {\n\tmsg_puts((char *)IObuff);\n\tif (code == NULL)\n\t    msg_puts(\"NULL\");\n\telse\n\t    msg_outtrans(code);\n    }\n    return len;\n}\n\n#if defined(FEAT_TERMRESPONSE) || defined(PROTO)\n/*\n * For Xterm >= 140 compiled with OPT_TCAP_QUERY: Obtain the actually used\n * termcap codes from the terminal itself.\n * We get them one by one to avoid a very long response string.\n */\nstatic int xt_index_in = 0;\nstatic int xt_index_out = 0;\n\n    static void\nreq_codes_from_term(void)\n{\n    xt_index_out = 0;\n    xt_index_in = 0;\n    req_more_codes_from_term();\n}\n\n    static void\nreq_more_codes_from_term(void)\n{\n    char\tbuf[23];  // extra size to shut up LGTM\n    int\t\told_idx = xt_index_out;\n\n    // Don't do anything when going to exit.\n    if (exiting)\n\treturn;\n\n    // Send up to 10 more requests out than we received.  Avoid sending too\n    // many, there can be a buffer overflow somewhere.\n    while (xt_index_out < xt_index_in + 10 && key_names[xt_index_out] != NULL)\n    {\n\tchar *key_name = key_names[xt_index_out];\n\n\tMAY_WANT_TO_LOG_THIS;\n\tLOG_TR((\"Requesting XT %d: %s\", xt_index_out, key_name));\n\tsprintf(buf, \"\\033P+q%02x%02x\\033\\\\\", key_name[0], key_name[1]);\n\tout_str_nf((char_u *)buf);\n\t++xt_index_out;\n    }\n\n    // Send the codes out right away.\n    if (xt_index_out != old_idx)\n\tout_flush();\n}\n\n/*\n * Decode key code response from xterm: '<Esc>P1+r<name>=<string><Esc>\\'.\n * A \"0\" instead of the \"1\" indicates a code that isn't supported.\n * Both <name> and <string> are encoded in hex.\n * \"code\" points to the \"0\" or \"1\".\n */\n    static void\ngot_code_from_term(char_u *code, int len)\n{\n#define XT_LEN 100\n    char_u\tname[3];\n    char_u\tstr[XT_LEN];\n    int\t\ti;\n    int\t\tj = 0;\n    int\t\tc;\n\n    // A '1' means the code is supported, a '0' means it isn't.\n    // When half the length is > XT_LEN we can't use it.\n    // Our names are currently all 2 characters.\n    if (code[0] == '1' && code[7] == '=' && len / 2 < XT_LEN)\n    {\n\t// Get the name from the response and find it in the table.\n\tname[0] = hexhex2nr(code + 3);\n\tname[1] = hexhex2nr(code + 5);\n\tname[2] = NUL;\n\tfor (i = 0; key_names[i] != NULL; ++i)\n\t{\n\t    if (STRCMP(key_names[i], name) == 0)\n\t    {\n\t\txt_index_in = i;\n\t\tbreak;\n\t    }\n\t}\n\n\tLOG_TR((\"Received XT %d: %s\", xt_index_in, (char *)name));\n\n\tif (key_names[i] != NULL)\n\t{\n\t    for (i = 8; (c = hexhex2nr(code + i)) >= 0; i += 2)\n\t\tstr[j++] = c;\n\t    str[j] = NUL;\n\t    if (name[0] == 'C' && name[1] == 'o')\n\t    {\n\t\t// Color count is not a key code.\n\t\tmay_adjust_color_count(atoi((char *)str));\n\t    }\n\t    else\n\t    {\n\t\t// First delete any existing entry with the same code.\n\t\ti = find_term_bykeys(str);\n\t\tif (i >= 0)\n\t\t    del_termcode_idx(i);\n\t\tadd_termcode(name, str, ATC_FROM_TERM);\n\t    }\n\t}\n    }\n\n    // May request more codes now that we received one.\n    ++xt_index_in;\n    req_more_codes_from_term();\n}\n\n/*\n * Check if there are any unanswered requests and deal with them.\n * This is called before starting an external program or getting direct\n * keyboard input.  We don't want responses to be send to that program or\n * handled as typed text.\n */\n    static void\ncheck_for_codes_from_term(void)\n{\n    int\t\tc;\n\n    // If no codes requested or all are answered, no need to wait.\n    if (xt_index_out == 0 || xt_index_out == xt_index_in)\n\treturn;\n\n    // Vgetc() will check for and handle any response.\n    // Keep calling vpeekc() until we don't get any responses.\n    ++no_mapping;\n    ++allow_keys;\n    for (;;)\n    {\n\tc = vpeekc();\n\tif (c == NUL)\t    // nothing available\n\t    break;\n\n\t// If a response is recognized it's replaced with K_IGNORE, must read\n\t// it from the input stream.  If there is no K_IGNORE we can't do\n\t// anything, break here (there might be some responses further on, but\n\t// we don't want to throw away any typed chars).\n\tif (c != K_SPECIAL && c != K_IGNORE)\n\t    break;\n\tc = vgetc();\n\tif (c != K_IGNORE)\n\t{\n\t    vungetc(c);\n\t    break;\n\t}\n    }\n    --no_mapping;\n    --allow_keys;\n}\n#endif\n\n#if (defined(MSWIN) && (!defined(FEAT_GUI) || defined(VIMDLL))) || defined(PROTO)\nstatic char ksme_str[20];\nstatic char ksmr_str[20];\nstatic char ksmd_str[20];\n\n/*\n * For Win32 console: update termcap codes for existing console attributes.\n */\n    void\nupdate_tcap(int attr)\n{\n    struct builtin_term *p;\n\n    p = find_builtin_term(DEFAULT_TERM);\n    sprintf(ksme_str, \"\\033|%dm\", attr);\n    sprintf(ksmd_str, \"\\033|%dm\", attr | 0x08);  // FOREGROUND_INTENSITY\n    sprintf(ksmr_str, \"\\033|%dm\", ((attr & 0x0F) << 4) | ((attr & 0xF0) >> 4));\n\n    while (p->bt_string != NULL)\n    {\n      if (p->bt_entry == (int)KS_ME)\n\t  p->bt_string = &ksme_str[0];\n      else if (p->bt_entry == (int)KS_MR)\n\t  p->bt_string = &ksmr_str[0];\n      else if (p->bt_entry == (int)KS_MD)\n\t  p->bt_string = &ksmd_str[0];\n      ++p;\n    }\n}\n\n# ifdef FEAT_TERMGUICOLORS\n#  define KSSIZE 20\n\ntypedef enum\n{\n    CMODE_INDEXED = 0,\t// Use cmd.exe 4bit palette.\n    CMODE_RGB,\t\t// Use 24bit RGB colors using VTP.\n    CMODE_256COL,\t// Emulate xterm's 256-color palette using VTP.\n    CMODE_LAST,\n} cmode_T;\n\nstruct ks_tbl_S\n{\n    int  code;\t\t\t\t// value of KS_\n    char *vtp;\t\t\t\t// code in RGB mode\n    char *vtp2;\t\t\t\t// code in 256color mode\n    char buf[CMODE_LAST][KSSIZE];\t// real buffer\n};\n\nstatic struct ks_tbl_S ks_tbl[] =\n{\n    {(int)KS_ME,  \"\\033|0m\",  \"\\033|0m\", {\"\"}},   // normal\n    {(int)KS_MR,  \"\\033|7m\",  \"\\033|7m\", {\"\"}},   // reverse\n    {(int)KS_MD,  \"\\033|1m\",  \"\\033|1m\", {\"\"}},   // bold\n    {(int)KS_SO,  \"\\033|91m\", \"\\033|91m\", {\"\"}},  // standout: bright red text\n    {(int)KS_SE,  \"\\033|39m\", \"\\033|39m\", {\"\"}},  // standout end: default color\n    {(int)KS_CZH, \"\\033|3m\",  \"\\033|3m\", {\"\"}},   // italic\n    {(int)KS_CZR, \"\\033|0m\",  \"\\033|0m\", {\"\"}},   // italic end\n    {(int)KS_US,  \"\\033|4m\",  \"\\033|4m\", {\"\"}},   // underscore\n    {(int)KS_UE,  \"\\033|24m\", \"\\033|24m\", {\"\"}},  // underscore end\n#  ifdef TERMINFO\n    {(int)KS_CAB, \"\\033|%p1%db\", \"\\033|%p14%dm\", {\"\"}}, // set background color\n    {(int)KS_CAF, \"\\033|%p1%df\", \"\\033|%p13%dm\", {\"\"}}, // set foreground color\n    {(int)KS_CS,  \"\\033|%p1%d;%p2%dR\", \"\\033|%p1%d;%p2%dR\", {\"\"}},\n    {(int)KS_CSV, \"\\033|%p1%d;%p2%dV\", \"\\033|%p1%d;%p2%dV\", {\"\"}},\n#  else\n    {(int)KS_CAB, \"\\033|%db\", \"\\033|4%dm\", {\"\"}}, // set background color\n    {(int)KS_CAF, \"\\033|%df\", \"\\033|3%dm\", {\"\"}}, // set foreground color\n    {(int)KS_CS,  \"\\033|%d;%dR\", \"\\033|%d;%dR\", {\"\"}},\n    {(int)KS_CSV, \"\\033|%d;%dV\", \"\\033|%d;%dV\", {\"\"}},\n#  endif\n    {(int)KS_CCO, \"256\", \"256\", {\"\"}},\t    // colors\n    {(int)KS_NAME, NULL, NULL, {\"\"}}\t\t\t    // terminator\n};\n\n    static struct builtin_term *\nfind_first_tcap(\n    char_u *name,\n    int\t    code)\n{\n    struct builtin_term *p;\n\n    for (p = find_builtin_term(name); p->bt_string != NULL; ++p)\n\tif (p->bt_entry == code)\n\t    return p;\n    return NULL;\n}\n# endif\n\n/*\n * For Win32 console: replace the sequence immediately after termguicolors.\n */\n    void\nswap_tcap(void)\n{\n# ifdef FEAT_TERMGUICOLORS\n    static int\t\tinit_done = FALSE;\n    static cmode_T\tcurr_mode;\n    struct ks_tbl_S\t*ks;\n    struct builtin_term *bt;\n    cmode_T\t\tmode;\n\n    if (!init_done)\n    {\n\tfor (ks = ks_tbl; ks->code != (int)KS_NAME; ks++)\n\t{\n\t    bt = find_first_tcap(DEFAULT_TERM, ks->code);\n\t    if (bt != NULL)\n\t    {\n\t\t// Preserve the original value.\n\t\tSTRNCPY(ks->buf[CMODE_INDEXED], bt->bt_string, KSSIZE);\n\t\tSTRNCPY(ks->buf[CMODE_RGB], ks->vtp, KSSIZE);\n\t\tSTRNCPY(ks->buf[CMODE_256COL], ks->vtp2, KSSIZE);\n\n\t\tbt->bt_string = ks->buf[CMODE_INDEXED];\n\t    }\n\t}\n\tinit_done = TRUE;\n\tcurr_mode = CMODE_INDEXED;\n    }\n\n    if (p_tgc)\n\tmode = CMODE_RGB;\n    else if (t_colors >= 256)\n\tmode = CMODE_256COL;\n    else\n\tmode = CMODE_INDEXED;\n\n    if (mode == curr_mode)\n\treturn;\n\n    for (ks = ks_tbl; ks->code != (int)KS_NAME; ks++)\n    {\n\tbt = find_first_tcap(DEFAULT_TERM, ks->code);\n\tif (bt != NULL)\n\t    bt->bt_string = ks->buf[mode];\n    }\n\n    curr_mode = mode;\n# endif\n}\n\n#endif\n\n\n#if (defined(MSWIN) && (!defined(FEAT_GUI_MSWIN) || defined(VIMDLL))) || defined(FEAT_TERMINAL) \\\n\t|| defined(PROTO)\nstatic int cube_value[] = {\n    0x00, 0x5F, 0x87, 0xAF, 0xD7, 0xFF\n};\n\nstatic int grey_ramp[] = {\n    0x08, 0x12, 0x1C, 0x26, 0x30, 0x3A, 0x44, 0x4E, 0x58, 0x62, 0x6C, 0x76,\n    0x80, 0x8A, 0x94, 0x9E, 0xA8, 0xB2, 0xBC, 0xC6, 0xD0, 0xDA, 0xE4, 0xEE\n};\n\nstatic const char_u ansi_table[16][3] = {\n//   R    G    B\n  {  0,   0,   0}, // black\n  {224,   0,   0}, // dark red\n  {  0, 224,   0}, // dark green\n  {224, 224,   0}, // dark yellow / brown\n  {  0,   0, 224}, // dark blue\n  {224,   0, 224}, // dark magenta\n  {  0, 224, 224}, // dark cyan\n  {224, 224, 224}, // light grey\n\n  {128, 128, 128}, // dark grey\n  {255,  64,  64}, // light red\n  { 64, 255,  64}, // light green\n  {255, 255,  64}, // yellow\n  { 64,  64, 255}, // light blue\n  {255,  64, 255}, // light magenta\n  { 64, 255, 255}, // light cyan\n  {255, 255, 255}, // white\n};\n\n#if defined(MSWIN)\n// Mapping between cterm indices < 16 and their counterpart in the ANSI palette.\nstatic const char_u cterm_ansi_idx[] = {\n    0, 4, 2, 6, 1, 5, 3, 7, 8, 12, 10, 14, 9, 13, 11, 15\n};\n#endif\n\n#define ANSI_INDEX_NONE 0\n\n    void\nansi_color2rgb(int nr, char_u *r, char_u *g, char_u *b, char_u *ansi_idx)\n{\n    if (nr < 16)\n    {\n\t*r = ansi_table[nr][0];\n\t*g = ansi_table[nr][1];\n\t*b = ansi_table[nr][2];\n\t*ansi_idx = nr;\n    }\n    else\n    {\n\t*r = 0;\n\t*g = 0;\n\t*b = 0;\n\t*ansi_idx = ANSI_INDEX_NONE;\n    }\n}\n\n    void\ncterm_color2rgb(int nr, char_u *r, char_u *g, char_u *b, char_u *ansi_idx)\n{\n    int idx;\n\n    if (nr < 16)\n    {\n#if defined(MSWIN)\n\tidx = cterm_ansi_idx[nr];\n#else\n\tidx = nr;\n#endif\n\t*r = ansi_table[idx][0];\n\t*g = ansi_table[idx][1];\n\t*b = ansi_table[idx][2];\n\t*ansi_idx = idx + 1;\n    }\n    else if (nr < 232)\n    {\n\t// 216 color cube\n\tidx = nr - 16;\n\t*r = cube_value[idx / 36 % 6];\n\t*g = cube_value[idx / 6  % 6];\n\t*b = cube_value[idx      % 6];\n\t*ansi_idx = ANSI_INDEX_NONE;\n    }\n    else if (nr < 256)\n    {\n\t// 24 grey scale ramp\n\tidx = nr - 232;\n\t*r = grey_ramp[idx];\n\t*g = grey_ramp[idx];\n\t*b = grey_ramp[idx];\n\t*ansi_idx = ANSI_INDEX_NONE;\n    }\n    else\n    {\n\t*r = 0;\n\t*g = 0;\n\t*b = 0;\n\t*ansi_idx = ANSI_INDEX_NONE;\n    }\n}\n#endif\n\n/*\n * Replace K_BS by <BS> and K_DEL by <DEL>\n */\n    void\nterm_replace_bs_del_keycode(char_u *ta_buf, int ta_len, int len)\n{\n    int\t\ti;\n    int\t\tc;\n\n    for (i = ta_len; i < ta_len + len; ++i)\n    {\n\tif (ta_buf[i] == CSI && len - i > 2)\n\t{\n\t    c = TERMCAP2KEY(ta_buf[i + 1], ta_buf[i + 2]);\n\t    if (c == K_DEL || c == K_KDEL || c == K_BS)\n\t    {\n\t\tmch_memmove(ta_buf + i + 1, ta_buf + i + 3,\n\t\t\t(size_t)(len - i - 2));\n\t\tif (c == K_DEL || c == K_KDEL)\n\t\t    ta_buf[i] = DEL;\n\t\telse\n\t\t    ta_buf[i] = Ctrl_H;\n\t\tlen -= 2;\n\t    }\n\t}\n\telse if (ta_buf[i] == '\\r')\n\t    ta_buf[i] = '\\n';\n\tif (has_mbyte)\n\t    i += (*mb_ptr2len_len)(ta_buf + i, ta_len + len - i) - 1;\n    }\n}\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    5159,\n/**/\n    5158,\n/**/\n    5157,\n/**/\n    5156,\n/**/\n    5155,\n/**/\n    5154,\n/**/\n    5153,\n/**/\n    5152,\n/**/\n    5151,\n/**/\n    5150,\n/**/\n    5149,\n/**/\n    5148,\n/**/\n    5147,\n/**/\n    5146,\n/**/\n    5145,\n/**/\n    5144,\n/**/\n    5143,\n/**/\n    5142,\n/**/\n    5141,\n/**/\n    5140,\n/**/\n    5139,\n/**/\n    5138,\n/**/\n    5137,\n/**/\n    5136,\n/**/\n    5135,\n/**/\n    5134,\n/**/\n    5133,\n/**/\n    5132,\n/**/\n    5131,\n/**/\n    5130,\n/**/\n    5129,\n/**/\n    5128,\n/**/\n    5127,\n/**/\n    5126,\n/**/\n    5125,\n/**/\n    5124,\n/**/\n    5123,\n/**/\n    5122,\n/**/\n    5121,\n/**/\n    5120,\n/**/\n    5119,\n/**/\n    5118,\n/**/\n    5117,\n/**/\n    5116,\n/**/\n    5115,\n/**/\n    5114,\n/**/\n    5113,\n/**/\n    5112,\n/**/\n    5111,\n/**/\n    5110,\n/**/\n    5109,\n/**/\n    5108,\n/**/\n    5107,\n/**/\n    5106,\n/**/\n    5105,\n/**/\n    5104,\n/**/\n    5103,\n/**/\n    5102,\n/**/\n    5101,\n/**/\n    5100,\n/**/\n    5099,\n/**/\n    5098,\n/**/\n    5097,\n/**/\n    5096,\n/**/\n    5095,\n/**/\n    5094,\n/**/\n    5093,\n/**/\n    5092,\n/**/\n    5091,\n/**/\n    5090,\n/**/\n    5089,\n/**/\n    5088,\n/**/\n    5087,\n/**/\n    5086,\n/**/\n    5085,\n/**/\n    5084,\n/**/\n    5083,\n/**/\n    5082,\n/**/\n    5081,\n/**/\n    5080,\n/**/\n    5079,\n/**/\n    5078,\n/**/\n    5077,\n/**/\n    5076,\n/**/\n    5075,\n/**/\n    5074,\n/**/\n    5073,\n/**/\n    5072,\n/**/\n    5071,\n/**/\n    5070,\n/**/\n    5069,\n/**/\n    5068,\n/**/\n    5067,\n/**/\n    5066,\n/**/\n    5065,\n/**/\n    5064,\n/**/\n    5063,\n/**/\n    5062,\n/**/\n    5061,\n/**/\n    5060,\n/**/\n    5059,\n/**/\n    5058,\n/**/\n    5057,\n/**/\n    5056,\n/**/\n    5055,\n/**/\n    5054,\n/**/\n    5053,\n/**/\n    5052,\n/**/\n    5051,\n/**/\n    5050,\n/**/\n    5049,\n/**/\n    5048,\n/**/\n    5047,\n/**/\n    5046,\n/**/\n    5045,\n/**/\n    5044,\n/**/\n    5043,\n/**/\n    5042,\n/**/\n    5041,\n/**/\n    5040,\n/**/\n    5039,\n/**/\n    5038,\n/**/\n    5037,\n/**/\n    5036,\n/**/\n    5035,\n/**/\n    5034,\n/**/\n    5033,\n/**/\n    5032,\n/**/\n    5031,\n/**/\n    5030,\n/**/\n    5029,\n/**/\n    5028,\n/**/\n    5027,\n/**/\n    5026,\n/**/\n    5025,\n/**/\n    5024,\n/**/\n    5023,\n/**/\n    5022,\n/**/\n    5021,\n/**/\n    5020,\n/**/\n    5019,\n/**/\n    5018,\n/**/\n    5017,\n/**/\n    5016,\n/**/\n    5015,\n/**/\n    5014,\n/**/\n    5013,\n/**/\n    5012,\n/**/\n    5011,\n/**/\n    5010,\n/**/\n    5009,\n/**/\n    5008,\n/**/\n    5007,\n/**/\n    5006,\n/**/\n    5005,\n/**/\n    5004,\n/**/\n    5003,\n/**/\n    5002,\n/**/\n    5001,\n/**/\n    5000,\n/**/\n    4999,\n/**/\n    4998,\n/**/\n    4997,\n/**/\n    4996,\n/**/\n    4995,\n/**/\n    4994,\n/**/\n    4993,\n/**/\n    4992,\n/**/\n    4991,\n/**/\n    4990,\n/**/\n    4989,\n/**/\n    4988,\n/**/\n    4987,\n/**/\n    4986,\n/**/\n    4985,\n/**/\n    4984,\n/**/\n    4983,\n/**/\n    4982,\n/**/\n    4981,\n/**/\n    4980,\n/**/\n    4979,\n/**/\n    4978,\n/**/\n    4977,\n/**/\n    4976,\n/**/\n    4975,\n/**/\n    4974,\n/**/\n    4973,\n/**/\n    4972,\n/**/\n    4971,\n/**/\n    4970,\n/**/\n    4969,\n/**/\n    4968,\n/**/\n    4967,\n/**/\n    4966,\n/**/\n    4965,\n/**/\n    4964,\n/**/\n    4963,\n/**/\n    4962,\n/**/\n    4961,\n/**/\n    4960,\n/**/\n    4959,\n/**/\n    4958,\n/**/\n    4957,\n/**/\n    4956,\n/**/\n    4955,\n/**/\n    4954,\n/**/\n    4953,\n/**/\n    4952,\n/**/\n    4951,\n/**/\n    4950,\n/**/\n    4949,\n/**/\n    4948,\n/**/\n    4947,\n/**/\n    4946,\n/**/\n    4945,\n/**/\n    4944,\n/**/\n    4943,\n/**/\n    4942,\n/**/\n    4941,\n/**/\n    4940,\n/**/\n    4939,\n/**/\n    4938,\n/**/\n    4937,\n/**/\n    4936,\n/**/\n    4935,\n/**/\n    4934,\n/**/\n    4933,\n/**/\n    4932,\n/**/\n    4931,\n/**/\n    4930,\n/**/\n    4929,\n/**/\n    4928,\n/**/\n    4927,\n/**/\n    4926,\n/**/\n    4925,\n/**/\n    4924,\n/**/\n    4923,\n/**/\n    4922,\n/**/\n    4921,\n/**/\n    4920,\n/**/\n    4919,\n/**/\n    4918,\n/**/\n    4917,\n/**/\n    4916,\n/**/\n    4915,\n/**/\n    4914,\n/**/\n    4913,\n/**/\n    4912,\n/**/\n    4911,\n/**/\n    4910,\n/**/\n    4909,\n/**/\n    4908,\n/**/\n    4907,\n/**/\n    4906,\n/**/\n    4905,\n/**/\n    4904,\n/**/\n    4903,\n/**/\n    4902,\n/**/\n    4901,\n/**/\n    4900,\n/**/\n    4899,\n/**/\n    4898,\n/**/\n    4897,\n/**/\n    4896,\n/**/\n    4895,\n/**/\n    4894,\n/**/\n    4893,\n/**/\n    4892,\n/**/\n    4891,\n/**/\n    4890,\n/**/\n    4889,\n/**/\n    4888,\n/**/\n    4887,\n/**/\n    4886,\n/**/\n    4885,\n/**/\n    4884,\n/**/\n    4883,\n/**/\n    4882,\n/**/\n    4881,\n/**/\n    4880,\n/**/\n    4879,\n/**/\n    4878,\n/**/\n    4877,\n/**/\n    4876,\n/**/\n    4875,\n/**/\n    4874,\n/**/\n    4873,\n/**/\n    4872,\n/**/\n    4871,\n/**/\n    4870,\n/**/\n    4869,\n/**/\n    4868,\n/**/\n    4867,\n/**/\n    4866,\n/**/\n    4865,\n/**/\n    4864,\n/**/\n    4863,\n/**/\n    4862,\n/**/\n    4861,\n/**/\n    4860,\n/**/\n    4859,\n/**/\n    4858,\n/**/\n    4857,\n/**/\n    4856,\n/**/\n    4855,\n/**/\n    4854,\n/**/\n    4853,\n/**/\n    4852,\n/**/\n    4851,\n/**/\n    4850,\n/**/\n    4849,\n/**/\n    4848,\n/**/\n    4847,\n/**/\n    4846,\n/**/\n    4845,\n/**/\n    4844,\n/**/\n    4843,\n/**/\n    4842,\n/**/\n    4841,\n/**/\n    4840,\n/**/\n    4839,\n/**/\n    4838,\n/**/\n    4837,\n/**/\n    4836,\n/**/\n    4835,\n/**/\n    4834,\n/**/\n    4833,\n/**/\n    4832,\n/**/\n    4831,\n/**/\n    4830,\n/**/\n    4829,\n/**/\n    4828,\n/**/\n    4827,\n/**/\n    4826,\n/**/\n    4825,\n/**/\n    4824,\n/**/\n    4823,\n/**/\n    4822,\n/**/\n    4821,\n/**/\n    4820,\n/**/\n    4819,\n/**/\n    4818,\n/**/\n    4817,\n/**/\n    4816,\n/**/\n    4815,\n/**/\n    4814,\n/**/\n    4813,\n/**/\n    4812,\n/**/\n    4811,\n/**/\n    4810,\n/**/\n    4809,\n/**/\n    4808,\n/**/\n    4807,\n/**/\n    4806,\n/**/\n    4805,\n/**/\n    4804,\n/**/\n    4803,\n/**/\n    4802,\n/**/\n    4801,\n/**/\n    4800,\n/**/\n    4799,\n/**/\n    4798,\n/**/\n    4797,\n/**/\n    4796,\n/**/\n    4795,\n/**/\n    4794,\n/**/\n    4793,\n/**/\n    4792,\n/**/\n    4791,\n/**/\n    4790,\n/**/\n    4789,\n/**/\n    4788,\n/**/\n    4787,\n/**/\n    4786,\n/**/\n    4785,\n/**/\n    4784,\n/**/\n    4783,\n/**/\n    4782,\n/**/\n    4781,\n/**/\n    4780,\n/**/\n    4779,\n/**/\n    4778,\n/**/\n    4777,\n/**/\n    4776,\n/**/\n    4775,\n/**/\n    4774,\n/**/\n    4773,\n/**/\n    4772,\n/**/\n    4771,\n/**/\n    4770,\n/**/\n    4769,\n/**/\n    4768,\n/**/\n    4767,\n/**/\n    4766,\n/**/\n    4765,\n/**/\n    4764,\n/**/\n    4763,\n/**/\n    4762,\n/**/\n    4761,\n/**/\n    4760,\n/**/\n    4759,\n/**/\n    4758,\n/**/\n    4757,\n/**/\n    4756,\n/**/\n    4755,\n/**/\n    4754,\n/**/\n    4753,\n/**/\n    4752,\n/**/\n    4751,\n/**/\n    4750,\n/**/\n    4749,\n/**/\n    4748,\n/**/\n    4747,\n/**/\n    4746,\n/**/\n    4745,\n/**/\n    4744,\n/**/\n    4743,\n/**/\n    4742,\n/**/\n    4741,\n/**/\n    4740,\n/**/\n    4739,\n/**/\n    4738,\n/**/\n    4737,\n/**/\n    4736,\n/**/\n    4735,\n/**/\n    4734,\n/**/\n    4733,\n/**/\n    4732,\n/**/\n    4731,\n/**/\n    4730,\n/**/\n    4729,\n/**/\n    4728,\n/**/\n    4727,\n/**/\n    4726,\n/**/\n    4725,\n/**/\n    4724,\n/**/\n    4723,\n/**/\n    4722,\n/**/\n    4721,\n/**/\n    4720,\n/**/\n    4719,\n/**/\n    4718,\n/**/\n    4717,\n/**/\n    4716,\n/**/\n    4715,\n/**/\n    4714,\n/**/\n    4713,\n/**/\n    4712,\n/**/\n    4711,\n/**/\n    4710,\n/**/\n    4709,\n/**/\n    4708,\n/**/\n    4707,\n/**/\n    4706,\n/**/\n    4705,\n/**/\n    4704,\n/**/\n    4703,\n/**/\n    4702,\n/**/\n    4701,\n/**/\n    4700,\n/**/\n    4699,\n/**/\n    4698,\n/**/\n    4697,\n/**/\n    4696,\n/**/\n    4695,\n/**/\n    4694,\n/**/\n    4693,\n/**/\n    4692,\n/**/\n    4691,\n/**/\n    4690,\n/**/\n    4689,\n/**/\n    4688,\n/**/\n    4687,\n/**/\n    4686,\n/**/\n    4685,\n/**/\n    4684,\n/**/\n    4683,\n/**/\n    4682,\n/**/\n    4681,\n/**/\n    4680,\n/**/\n    4679,\n/**/\n    4678,\n/**/\n    4677,\n/**/\n    4676,\n/**/\n    4675,\n/**/\n    4674,\n/**/\n    4673,\n/**/\n    4672,\n/**/\n    4671,\n/**/\n    4670,\n/**/\n    4669,\n/**/\n    4668,\n/**/\n    4667,\n/**/\n    4666,\n/**/\n    4665,\n/**/\n    4664,\n/**/\n    4663,\n/**/\n    4662,\n/**/\n    4661,\n/**/\n    4660,\n/**/\n    4659,\n/**/\n    4658,\n/**/\n    4657,\n/**/\n    4656,\n/**/\n    4655,\n/**/\n    4654,\n/**/\n    4653,\n/**/\n    4652,\n/**/\n    4651,\n/**/\n    4650,\n/**/\n    4649,\n/**/\n    4648,\n/**/\n    4647,\n/**/\n    4646,\n/**/\n    4645,\n/**/\n    4644,\n/**/\n    4643,\n/**/\n    4642,\n/**/\n    4641,\n/**/\n    4640,\n/**/\n    4639,\n/**/\n    4638,\n/**/\n    4637,\n/**/\n    4636,\n/**/\n    4635,\n/**/\n    4634,\n/**/\n    4633,\n/**/\n    4632,\n/**/\n    4631,\n/**/\n    4630,\n/**/\n    4629,\n/**/\n    4628,\n/**/\n    4627,\n/**/\n    4626,\n/**/\n    4625,\n/**/\n    4624,\n/**/\n    4623,\n/**/\n    4622,\n/**/\n    4621,\n/**/\n    4620,\n/**/\n    4619,\n/**/\n    4618,\n/**/\n    4617,\n/**/\n    4616,\n/**/\n    4615,\n/**/\n    4614,\n/**/\n    4613,\n/**/\n    4612,\n/**/\n    4611,\n/**/\n    4610,\n/**/\n    4609,\n/**/\n    4608,\n/**/\n    4607,\n/**/\n    4606,\n/**/\n    4605,\n/**/\n    4604,\n/**/\n    4603,\n/**/\n    4602,\n/**/\n    4601,\n/**/\n    4600,\n/**/\n    4599,\n/**/\n    4598,\n/**/\n    4597,\n/**/\n    4596,\n/**/\n    4595,\n/**/\n    4594,\n/**/\n    4593,\n/**/\n    4592,\n/**/\n    4591,\n/**/\n    4590,\n/**/\n    4589,\n/**/\n    4588,\n/**/\n    4587,\n/**/\n    4586,\n/**/\n    4585,\n/**/\n    4584,\n/**/\n    4583,\n/**/\n    4582,\n/**/\n    4581,\n/**/\n    4580,\n/**/\n    4579,\n/**/\n    4578,\n/**/\n    4577,\n/**/\n    4576,\n/**/\n    4575,\n/**/\n    4574,\n/**/\n    4573,\n/**/\n    4572,\n/**/\n    4571,\n/**/\n    4570,\n/**/\n    4569,\n/**/\n    4568,\n/**/\n    4567,\n/**/\n    4566,\n/**/\n    4565,\n/**/\n    4564,\n/**/\n    4563,\n/**/\n    4562,\n/**/\n    4561,\n/**/\n    4560,\n/**/\n    4559,\n/**/\n    4558,\n/**/\n    4557,\n/**/\n    4556,\n/**/\n    4555,\n/**/\n    4554,\n/**/\n    4553,\n/**/\n    4552,\n/**/\n    4551,\n/**/\n    4550,\n/**/\n    4549,\n/**/\n    4548,\n/**/\n    4547,\n/**/\n    4546,\n/**/\n    4545,\n/**/\n    4544,\n/**/\n    4543,\n/**/\n    4542,\n/**/\n    4541,\n/**/\n    4540,\n/**/\n    4539,\n/**/\n    4538,\n/**/\n    4537,\n/**/\n    4536,\n/**/\n    4535,\n/**/\n    4534,\n/**/\n    4533,\n/**/\n    4532,\n/**/\n    4531,\n/**/\n    4530,\n/**/\n    4529,\n/**/\n    4528,\n/**/\n    4527,\n/**/\n    4526,\n/**/\n    4525,\n/**/\n    4524,\n/**/\n    4523,\n/**/\n    4522,\n/**/\n    4521,\n/**/\n    4520,\n/**/\n    4519,\n/**/\n    4518,\n/**/\n    4517,\n/**/\n    4516,\n/**/\n    4515,\n/**/\n    4514,\n/**/\n    4513,\n/**/\n    4512,\n/**/\n    4511,\n/**/\n    4510,\n/**/\n    4509,\n/**/\n    4508,\n/**/\n    4507,\n/**/\n    4506,\n/**/\n    4505,\n/**/\n    4504,\n/**/\n    4503,\n/**/\n    4502,\n/**/\n    4501,\n/**/\n    4500,\n/**/\n    4499,\n/**/\n    4498,\n/**/\n    4497,\n/**/\n    4496,\n/**/\n    4495,\n/**/\n    4494,\n/**/\n    4493,\n/**/\n    4492,\n/**/\n    4491,\n/**/\n    4490,\n/**/\n    4489,\n/**/\n    4488,\n/**/\n    4487,\n/**/\n    4486,\n/**/\n    4485,\n/**/\n    4484,\n/**/\n    4483,\n/**/\n    4482,\n/**/\n    4481,\n/**/\n    4480,\n/**/\n    4479,\n/**/\n    4478,\n/**/\n    4477,\n/**/\n    4476,\n/**/\n    4475,\n/**/\n    4474,\n/**/\n    4473,\n/**/\n    4472,\n/**/\n    4471,\n/**/\n    4470,\n/**/\n    4469,\n/**/\n    4468,\n/**/\n    4467,\n/**/\n    4466,\n/**/\n    4465,\n/**/\n    4464,\n/**/\n    4463,\n/**/\n    4462,\n/**/\n    4461,\n/**/\n    4460,\n/**/\n    4459,\n/**/\n    4458,\n/**/\n    4457,\n/**/\n    4456,\n/**/\n    4455,\n/**/\n    4454,\n/**/\n    4453,\n/**/\n    4452,\n/**/\n    4451,\n/**/\n    4450,\n/**/\n    4449,\n/**/\n    4448,\n/**/\n    4447,\n/**/\n    4446,\n/**/\n    4445,\n/**/\n    4444,\n/**/\n    4443,\n/**/\n    4442,\n/**/\n    4441,\n/**/\n    4440,\n/**/\n    4439,\n/**/\n    4438,\n/**/\n    4437,\n/**/\n    4436,\n/**/\n    4435,\n/**/\n    4434,\n/**/\n    4433,\n/**/\n    4432,\n/**/\n    4431,\n/**/\n    4430,\n/**/\n    4429,\n/**/\n    4428,\n/**/\n    4427,\n/**/\n    4426,\n/**/\n    4425,\n/**/\n    4424,\n/**/\n    4423,\n/**/\n    4422,\n/**/\n    4421,\n/**/\n    4420,\n/**/\n    4419,\n/**/\n    4418,\n/**/\n    4417,\n/**/\n    4416,\n/**/\n    4415,\n/**/\n    4414,\n/**/\n    4413,\n/**/\n    4412,\n/**/\n    4411,\n/**/\n    4410,\n/**/\n    4409,\n/**/\n    4408,\n/**/\n    4407,\n/**/\n    4406,\n/**/\n    4405,\n/**/\n    4404,\n/**/\n    4403,\n/**/\n    4402,\n/**/\n    4401,\n/**/\n    4400,\n/**/\n    4399,\n/**/\n    4398,\n/**/\n    4397,\n/**/\n    4396,\n/**/\n    4395,\n/**/\n    4394,\n/**/\n    4393,\n/**/\n    4392,\n/**/\n    4391,\n/**/\n    4390,\n/**/\n    4389,\n/**/\n    4388,\n/**/\n    4387,\n/**/\n    4386,\n/**/\n    4385,\n/**/\n    4384,\n/**/\n    4383,\n/**/\n    4382,\n/**/\n    4381,\n/**/\n    4380,\n/**/\n    4379,\n/**/\n    4378,\n/**/\n    4377,\n/**/\n    4376,\n/**/\n    4375,\n/**/\n    4374,\n/**/\n    4373,\n/**/\n    4372,\n/**/\n    4371,\n/**/\n    4370,\n/**/\n    4369,\n/**/\n    4368,\n/**/\n    4367,\n/**/\n    4366,\n/**/\n    4365,\n/**/\n    4364,\n/**/\n    4363,\n/**/\n    4362,\n/**/\n    4361,\n/**/\n    4360,\n/**/\n    4359,\n/**/\n    4358,\n/**/\n    4357,\n/**/\n    4356,\n/**/\n    4355,\n/**/\n    4354,\n/**/\n    4353,\n/**/\n    4352,\n/**/\n    4351,\n/**/\n    4350,\n/**/\n    4349,\n/**/\n    4348,\n/**/\n    4347,\n/**/\n    4346,\n/**/\n    4345,\n/**/\n    4344,\n/**/\n    4343,\n/**/\n    4342,\n/**/\n    4341,\n/**/\n    4340,\n/**/\n    4339,\n/**/\n    4338,\n/**/\n    4337,\n/**/\n    4336,\n/**/\n    4335,\n/**/\n    4334,\n/**/\n    4333,\n/**/\n    4332,\n/**/\n    4331,\n/**/\n    4330,\n/**/\n    4329,\n/**/\n    4328,\n/**/\n    4327,\n/**/\n    4326,\n/**/\n    4325,\n/**/\n    4324,\n/**/\n    4323,\n/**/\n    4322,\n/**/\n    4321,\n/**/\n    4320,\n/**/\n    4319,\n/**/\n    4318,\n/**/\n    4317,\n/**/\n    4316,\n/**/\n    4315,\n/**/\n    4314,\n/**/\n    4313,\n/**/\n    4312,\n/**/\n    4311,\n/**/\n    4310,\n/**/\n    4309,\n/**/\n    4308,\n/**/\n    4307,\n/**/\n    4306,\n/**/\n    4305,\n/**/\n    4304,\n/**/\n    4303,\n/**/\n    4302,\n/**/\n    4301,\n/**/\n    4300,\n/**/\n    4299,\n/**/\n    4298,\n/**/\n    4297,\n/**/\n    4296,\n/**/\n    4295,\n/**/\n    4294,\n/**/\n    4293,\n/**/\n    4292,\n/**/\n    4291,\n/**/\n    4290,\n/**/\n    4289,\n/**/\n    4288,\n/**/\n    4287,\n/**/\n    4286,\n/**/\n    4285,\n/**/\n    4284,\n/**/\n    4283,\n/**/\n    4282,\n/**/\n    4281,\n/**/\n    4280,\n/**/\n    4279,\n/**/\n    4278,\n/**/\n    4277,\n/**/\n    4276,\n/**/\n    4275,\n/**/\n    4274,\n/**/\n    4273,\n/**/\n    4272,\n/**/\n    4271,\n/**/\n    4270,\n/**/\n    4269,\n/**/\n    4268,\n/**/\n    4267,\n/**/\n    4266,\n/**/\n    4265,\n/**/\n    4264,\n/**/\n    4263,\n/**/\n    4262,\n/**/\n    4261,\n/**/\n    4260,\n/**/\n    4259,\n/**/\n    4258,\n/**/\n    4257,\n/**/\n    4256,\n/**/\n    4255,\n/**/\n    4254,\n/**/\n    4253,\n/**/\n    4252,\n/**/\n    4251,\n/**/\n    4250,\n/**/\n    4249,\n/**/\n    4248,\n/**/\n    4247,\n/**/\n    4246,\n/**/\n    4245,\n/**/\n    4244,\n/**/\n    4243,\n/**/\n    4242,\n/**/\n    4241,\n/**/\n    4240,\n/**/\n    4239,\n/**/\n    4238,\n/**/\n    4237,\n/**/\n    4236,\n/**/\n    4235,\n/**/\n    4234,\n/**/\n    4233,\n/**/\n    4232,\n/**/\n    4231,\n/**/\n    4230,\n/**/\n    4229,\n/**/\n    4228,\n/**/\n    4227,\n/**/\n    4226,\n/**/\n    4225,\n/**/\n    4224,\n/**/\n    4223,\n/**/\n    4222,\n/**/\n    4221,\n/**/\n    4220,\n/**/\n    4219,\n/**/\n    4218,\n/**/\n    4217,\n/**/\n    4216,\n/**/\n    4215,\n/**/\n    4214,\n/**/\n    4213,\n/**/\n    4212,\n/**/\n    4211,\n/**/\n    4210,\n/**/\n    4209,\n/**/\n    4208,\n/**/\n    4207,\n/**/\n    4206,\n/**/\n    4205,\n/**/\n    4204,\n/**/\n    4203,\n/**/\n    4202,\n/**/\n    4201,\n/**/\n    4200,\n/**/\n    4199,\n/**/\n    4198,\n/**/\n    4197,\n/**/\n    4196,\n/**/\n    4195,\n/**/\n    4194,\n/**/\n    4193,\n/**/\n    4192,\n/**/\n    4191,\n/**/\n    4190,\n/**/\n    4189,\n/**/\n    4188,\n/**/\n    4187,\n/**/\n    4186,\n/**/\n    4185,\n/**/\n    4184,\n/**/\n    4183,\n/**/\n    4182,\n/**/\n    4181,\n/**/\n    4180,\n/**/\n    4179,\n/**/\n    4178,\n/**/\n    4177,\n/**/\n    4176,\n/**/\n    4175,\n/**/\n    4174,\n/**/\n    4173,\n/**/\n    4172,\n/**/\n    4171,\n/**/\n    4170,\n/**/\n    4169,\n/**/\n    4168,\n/**/\n    4167,\n/**/\n    4166,\n/**/\n    4165,\n/**/\n    4164,\n/**/\n    4163,\n/**/\n    4162,\n/**/\n    4161,\n/**/\n    4160,\n/**/\n    4159,\n/**/\n    4158,\n/**/\n    4157,\n/**/\n    4156,\n/**/\n    4155,\n/**/\n    4154,\n/**/\n    4153,\n/**/\n    4152,\n/**/\n    4151,\n/**/\n    4150,\n/**/\n    4149,\n/**/\n    4148,\n/**/\n    4147,\n/**/\n    4146,\n/**/\n    4145,\n/**/\n    4144,\n/**/\n    4143,\n/**/\n    4142,\n/**/\n    4141,\n/**/\n    4140,\n/**/\n    4139,\n/**/\n    4138,\n/**/\n    4137,\n/**/\n    4136,\n/**/\n    4135,\n/**/\n    4134,\n/**/\n    4133,\n/**/\n    4132,\n/**/\n    4131,\n/**/\n    4130,\n/**/\n    4129,\n/**/\n    4128,\n/**/\n    4127,\n/**/\n    4126,\n/**/\n    4125,\n/**/\n    4124,\n/**/\n    4123,\n/**/\n    4122,\n/**/\n    4121,\n/**/\n    4120,\n/**/\n    4119,\n/**/\n    4118,\n/**/\n    4117,\n/**/\n    4116,\n/**/\n    4115,\n/**/\n    4114,\n/**/\n    4113,\n/**/\n    4112,\n/**/\n    4111,\n/**/\n    4110,\n/**/\n    4109,\n/**/\n    4108,\n/**/\n    4107,\n/**/\n    4106,\n/**/\n    4105,\n/**/\n    4104,\n/**/\n    4103,\n/**/\n    4102,\n/**/\n    4101,\n/**/\n    4100,\n/**/\n    4099,\n/**/\n    4098,\n/**/\n    4097,\n/**/\n    4096,\n/**/\n    4095,\n/**/\n    4094,\n/**/\n    4093,\n/**/\n    4092,\n/**/\n    4091,\n/**/\n    4090,\n/**/\n    4089,\n/**/\n    4088,\n/**/\n    4087,\n/**/\n    4086,\n/**/\n    4085,\n/**/\n    4084,\n/**/\n    4083,\n/**/\n    4082,\n/**/\n    4081,\n/**/\n    4080,\n/**/\n    4079,\n/**/\n    4078,\n/**/\n    4077,\n/**/\n    4076,\n/**/\n    4075,\n/**/\n    4074,\n/**/\n    4073,\n/**/\n    4072,\n/**/\n    4071,\n/**/\n    4070,\n/**/\n    4069,\n/**/\n    4068,\n/**/\n    4067,\n/**/\n    4066,\n/**/\n    4065,\n/**/\n    4064,\n/**/\n    4063,\n/**/\n    4062,\n/**/\n    4061,\n/**/\n    4060,\n/**/\n    4059,\n/**/\n    4058,\n/**/\n    4057,\n/**/\n    4056,\n/**/\n    4055,\n/**/\n    4054,\n/**/\n    4053,\n/**/\n    4052,\n/**/\n    4051,\n/**/\n    4050,\n/**/\n    4049,\n/**/\n    4048,\n/**/\n    4047,\n/**/\n    4046,\n/**/\n    4045,\n/**/\n    4044,\n/**/\n    4043,\n/**/\n    4042,\n/**/\n    4041,\n/**/\n    4040,\n/**/\n    4039,\n/**/\n    4038,\n/**/\n    4037,\n/**/\n    4036,\n/**/\n    4035,\n/**/\n    4034,\n/**/\n    4033,\n/**/\n    4032,\n/**/\n    4031,\n/**/\n    4030,\n/**/\n    4029,\n/**/\n    4028,\n/**/\n    4027,\n/**/\n    4026,\n/**/\n    4025,\n/**/\n    4024,\n/**/\n    4023,\n/**/\n    4022,\n/**/\n    4021,\n/**/\n    4020,\n/**/\n    4019,\n/**/\n    4018,\n/**/\n    4017,\n/**/\n    4016,\n/**/\n    4015,\n/**/\n    4014,\n/**/\n    4013,\n/**/\n    4012,\n/**/\n    4011,\n/**/\n    4010,\n/**/\n    4009,\n/**/\n    4008,\n/**/\n    4007,\n/**/\n    4006,\n/**/\n    4005,\n/**/\n    4004,\n/**/\n    4003,\n/**/\n    4002,\n/**/\n    4001,\n/**/\n    4000,\n/**/\n    3999,\n/**/\n    3998,\n/**/\n    3997,\n/**/\n    3996,\n/**/\n    3995,\n/**/\n    3994,\n/**/\n    3993,\n/**/\n    3992,\n/**/\n    3991,\n/**/\n    3990,\n/**/\n    3989,\n/**/\n    3988,\n/**/\n    3987,\n/**/\n    3986,\n/**/\n    3985,\n/**/\n    3984,\n/**/\n    3983,\n/**/\n    3982,\n/**/\n    3981,\n/**/\n    3980,\n/**/\n    3979,\n/**/\n    3978,\n/**/\n    3977,\n/**/\n    3976,\n/**/\n    3975,\n/**/\n    3974,\n/**/\n    3973,\n/**/\n    3972,\n/**/\n    3971,\n/**/\n    3970,\n/**/\n    3969,\n/**/\n    3968,\n/**/\n    3967,\n/**/\n    3966,\n/**/\n    3965,\n/**/\n    3964,\n/**/\n    3963,\n/**/\n    3962,\n/**/\n    3961,\n/**/\n    3960,\n/**/\n    3959,\n/**/\n    3958,\n/**/\n    3957,\n/**/\n    3956,\n/**/\n    3955,\n/**/\n    3954,\n/**/\n    3953,\n/**/\n    3952,\n/**/\n    3951,\n/**/\n    3950,\n/**/\n    3949,\n/**/\n    3948,\n/**/\n    3947,\n/**/\n    3946,\n/**/\n    3945,\n/**/\n    3944,\n/**/\n    3943,\n/**/\n    3942,\n/**/\n    3941,\n/**/\n    3940,\n/**/\n    3939,\n/**/\n    3938,\n/**/\n    3937,\n/**/\n    3936,\n/**/\n    3935,\n/**/\n    3934,\n/**/\n    3933,\n/**/\n    3932,\n/**/\n    3931,\n/**/\n    3930,\n/**/\n    3929,\n/**/\n    3928,\n/**/\n    3927,\n/**/\n    3926,\n/**/\n    3925,\n/**/\n    3924,\n/**/\n    3923,\n/**/\n    3922,\n/**/\n    3921,\n/**/\n    3920,\n/**/\n    3919,\n/**/\n    3918,\n/**/\n    3917,\n/**/\n    3916,\n/**/\n    3915,\n/**/\n    3914,\n/**/\n    3913,\n/**/\n    3912,\n/**/\n    3911,\n/**/\n    3910,\n/**/\n    3909,\n/**/\n    3908,\n/**/\n    3907,\n/**/\n    3906,\n/**/\n    3905,\n/**/\n    3904,\n/**/\n    3903,\n/**/\n    3902,\n/**/\n    3901,\n/**/\n    3900,\n/**/\n    3899,\n/**/\n    3898,\n/**/\n    3897,\n/**/\n    3896,\n/**/\n    3895,\n/**/\n    3894,\n/**/\n    3893,\n/**/\n    3892,\n/**/\n    3891,\n/**/\n    3890,\n/**/\n    3889,\n/**/\n    3888,\n/**/\n    3887,\n/**/\n    3886,\n/**/\n    3885,\n/**/\n    3884,\n/**/\n    3883,\n/**/\n    3882,\n/**/\n    3881,\n/**/\n    3880,\n/**/\n    3879,\n/**/\n    3878,\n/**/\n    3877,\n/**/\n    3876,\n/**/\n    3875,\n/**/\n    3874,\n/**/\n    3873,\n/**/\n    3872,\n/**/\n    3871,\n/**/\n    3870,\n/**/\n    3869,\n/**/\n    3868,\n/**/\n    3867,\n/**/\n    3866,\n/**/\n    3865,\n/**/\n    3864,\n/**/\n    3863,\n/**/\n    3862,\n/**/\n    3861,\n/**/\n    3860,\n/**/\n    3859,\n/**/\n    3858,\n/**/\n    3857,\n/**/\n    3856,\n/**/\n    3855,\n/**/\n    3854,\n/**/\n    3853,\n/**/\n    3852,\n/**/\n    3851,\n/**/\n    3850,\n/**/\n    3849,\n/**/\n    3848,\n/**/\n    3847,\n/**/\n    3846,\n/**/\n    3845,\n/**/\n    3844,\n/**/\n    3843,\n/**/\n    3842,\n/**/\n    3841,\n/**/\n    3840,\n/**/\n    3839,\n/**/\n    3838,\n/**/\n    3837,\n/**/\n    3836,\n/**/\n    3835,\n/**/\n    3834,\n/**/\n    3833,\n/**/\n    3832,\n/**/\n    3831,\n/**/\n    3830,\n/**/\n    3829,\n/**/\n    3828,\n/**/\n    3827,\n/**/\n    3826,\n/**/\n    3825,\n/**/\n    3824,\n/**/\n    3823,\n/**/\n    3822,\n/**/\n    3821,\n/**/\n    3820,\n/**/\n    3819,\n/**/\n    3818,\n/**/\n    3817,\n/**/\n    3816,\n/**/\n    3815,\n/**/\n    3814,\n/**/\n    3813,\n/**/\n    3812,\n/**/\n    3811,\n/**/\n    3810,\n/**/\n    3809,\n/**/\n    3808,\n/**/\n    3807,\n/**/\n    3806,\n/**/\n    3805,\n/**/\n    3804,\n/**/\n    3803,\n/**/\n    3802,\n/**/\n    3801,\n/**/\n    3800,\n/**/\n    3799,\n/**/\n    3798,\n/**/\n    3797,\n/**/\n    3796,\n/**/\n    3795,\n/**/\n    3794,\n/**/\n    3793,\n/**/\n    3792,\n/**/\n    3791,\n/**/\n    3790,\n/**/\n    3789,\n/**/\n    3788,\n/**/\n    3787,\n/**/\n    3786,\n/**/\n    3785,\n/**/\n    3784,\n/**/\n    3783,\n/**/\n    3782,\n/**/\n    3781,\n/**/\n    3780,\n/**/\n    3779,\n/**/\n    3778,\n/**/\n    3777,\n/**/\n    3776,\n/**/\n    3775,\n/**/\n    3774,\n/**/\n    3773,\n/**/\n    3772,\n/**/\n    3771,\n/**/\n    3770,\n/**/\n    3769,\n/**/\n    3768,\n/**/\n    3767,\n/**/\n    3766,\n/**/\n    3765,\n/**/\n    3764,\n/**/\n    3763,\n/**/\n    3762,\n/**/\n    3761,\n/**/\n    3760,\n/**/\n    3759,\n/**/\n    3758,\n/**/\n    3757,\n/**/\n    3756,\n/**/\n    3755,\n/**/\n    3754,\n/**/\n    3753,\n/**/\n    3752,\n/**/\n    3751,\n/**/\n    3750,\n/**/\n    3749,\n/**/\n    3748,\n/**/\n    3747,\n/**/\n    3746,\n/**/\n    3745,\n/**/\n    3744,\n/**/\n    3743,\n/**/\n    3742,\n/**/\n    3741,\n/**/\n    3740,\n/**/\n    3739,\n/**/\n    3738,\n/**/\n    3737,\n/**/\n    3736,\n/**/\n    3735,\n/**/\n    3734,\n/**/\n    3733,\n/**/\n    3732,\n/**/\n    3731,\n/**/\n    3730,\n/**/\n    3729,\n/**/\n    3728,\n/**/\n    3727,\n/**/\n    3726,\n/**/\n    3725,\n/**/\n    3724,\n/**/\n    3723,\n/**/\n    3722,\n/**/\n    3721,\n/**/\n    3720,\n/**/\n    3719,\n/**/\n    3718,\n/**/\n    3717,\n/**/\n    3716,\n/**/\n    3715,\n/**/\n    3714,\n/**/\n    3713,\n/**/\n    3712,\n/**/\n    3711,\n/**/\n    3710,\n/**/\n    3709,\n/**/\n    3708,\n/**/\n    3707,\n/**/\n    3706,\n/**/\n    3705,\n/**/\n    3704,\n/**/\n    3703,\n/**/\n    3702,\n/**/\n    3701,\n/**/\n    3700,\n/**/\n    3699,\n/**/\n    3698,\n/**/\n    3697,\n/**/\n    3696,\n/**/\n    3695,\n/**/\n    3694,\n/**/\n    3693,\n/**/\n    3692,\n/**/\n    3691,\n/**/\n    3690,\n/**/\n    3689,\n/**/\n    3688,\n/**/\n    3687,\n/**/\n    3686,\n/**/\n    3685,\n/**/\n    3684,\n/**/\n    3683,\n/**/\n    3682,\n/**/\n    3681,\n/**/\n    3680,\n/**/\n    3679,\n/**/\n    3678,\n/**/\n    3677,\n/**/\n    3676,\n/**/\n    3675,\n/**/\n    3674,\n/**/\n    3673,\n/**/\n    3672,\n/**/\n    3671,\n/**/\n    3670,\n/**/\n    3669,\n/**/\n    3668,\n/**/\n    3667,\n/**/\n    3666,\n/**/\n    3665,\n/**/\n    3664,\n/**/\n    3663,\n/**/\n    3662,\n/**/\n    3661,\n/**/\n    3660,\n/**/\n    3659,\n/**/\n    3658,\n/**/\n    3657,\n/**/\n    3656,\n/**/\n    3655,\n/**/\n    3654,\n/**/\n    3653,\n/**/\n    3652,\n/**/\n    3651,\n/**/\n    3650,\n/**/\n    3649,\n/**/\n    3648,\n/**/\n    3647,\n/**/\n    3646,\n/**/\n    3645,\n/**/\n    3644,\n/**/\n    3643,\n/**/\n    3642,\n/**/\n    3641,\n/**/\n    3640,\n/**/\n    3639,\n/**/\n    3638,\n/**/\n    3637,\n/**/\n    3636,\n/**/\n    3635,\n/**/\n    3634,\n/**/\n    3633,\n/**/\n    3632,\n/**/\n    3631,\n/**/\n    3630,\n/**/\n    3629,\n/**/\n    3628,\n/**/\n    3627,\n/**/\n    3626,\n/**/\n    3625,\n/**/\n    3624,\n/**/\n    3623,\n/**/\n    3622,\n/**/\n    3621,\n/**/\n    3620,\n/**/\n    3619,\n/**/\n    3618,\n/**/\n    3617,\n/**/\n    3616,\n/**/\n    3615,\n/**/\n    3614,\n/**/\n    3613,\n/**/\n    3612,\n/**/\n    3611,\n/**/\n    3610,\n/**/\n    3609,\n/**/\n    3608,\n/**/\n    3607,\n/**/\n    3606,\n/**/\n    3605,\n/**/\n    3604,\n/**/\n    3603,\n/**/\n    3602,\n/**/\n    3601,\n/**/\n    3600,\n/**/\n    3599,\n/**/\n    3598,\n/**/\n    3597,\n/**/\n    3596,\n/**/\n    3595,\n/**/\n    3594,\n/**/\n    3593,\n/**/\n    3592,\n/**/\n    3591,\n/**/\n    3590,\n/**/\n    3589,\n/**/\n    3588,\n/**/\n    3587,\n/**/\n    3586,\n/**/\n    3585,\n/**/\n    3584,\n/**/\n    3583,\n/**/\n    3582,\n/**/\n    3581,\n/**/\n    3580,\n/**/\n    3579,\n/**/\n    3578,\n/**/\n    3577,\n/**/\n    3576,\n/**/\n    3575,\n/**/\n    3574,\n/**/\n    3573,\n/**/\n    3572,\n/**/\n    3571,\n/**/\n    3570,\n/**/\n    3569,\n/**/\n    3568,\n/**/\n    3567,\n/**/\n    3566,\n/**/\n    3565,\n/**/\n    3564,\n/**/\n    3563,\n/**/\n    3562,\n/**/\n    3561,\n/**/\n    3560,\n/**/\n    3559,\n/**/\n    3558,\n/**/\n    3557,\n/**/\n    3556,\n/**/\n    3555,\n/**/\n    3554,\n/**/\n    3553,\n/**/\n    3552,\n/**/\n    3551,\n/**/\n    3550,\n/**/\n    3549,\n/**/\n    3548,\n/**/\n    3547,\n/**/\n    3546,\n/**/\n    3545,\n/**/\n    3544,\n/**/\n    3543,\n/**/\n    3542,\n/**/\n    3541,\n/**/\n    3540,\n/**/\n    3539,\n/**/\n    3538,\n/**/\n    3537,\n/**/\n    3536,\n/**/\n    3535,\n/**/\n    3534,\n/**/\n    3533,\n/**/\n    3532,\n/**/\n    3531,\n/**/\n    3530,\n/**/\n    3529,\n/**/\n    3528,\n/**/\n    3527,\n/**/\n    3526,\n/**/\n    3525,\n/**/\n    3524,\n/**/\n    3523,\n/**/\n    3522,\n/**/\n    3521,\n/**/\n    3520,\n/**/\n    3519,\n/**/\n    3518,\n/**/\n    3517,\n/**/\n    3516,\n/**/\n    3515,\n/**/\n    3514,\n/**/\n    3513,\n/**/\n    3512,\n/**/\n    3511,\n/**/\n    3510,\n/**/\n    3509,\n/**/\n    3508,\n/**/\n    3507,\n/**/\n    3506,\n/**/\n    3505,\n/**/\n    3504,\n/**/\n    3503,\n/**/\n    3502,\n/**/\n    3501,\n/**/\n    3500,\n/**/\n    3499,\n/**/\n    3498,\n/**/\n    3497,\n/**/\n    3496,\n/**/\n    3495,\n/**/\n    3494,\n/**/\n    3493,\n/**/\n    3492,\n/**/\n    3491,\n/**/\n    3490,\n/**/\n    3489,\n/**/\n    3488,\n/**/\n    3487,\n/**/\n    3486,\n/**/\n    3485,\n/**/\n    3484,\n/**/\n    3483,\n/**/\n    3482,\n/**/\n    3481,\n/**/\n    3480,\n/**/\n    3479,\n/**/\n    3478,\n/**/\n    3477,\n/**/\n    3476,\n/**/\n    3475,\n/**/\n    3474,\n/**/\n    3473,\n/**/\n    3472,\n/**/\n    3471,\n/**/\n    3470,\n/**/\n    3469,\n/**/\n    3468,\n/**/\n    3467,\n/**/\n    3466,\n/**/\n    3465,\n/**/\n    3464,\n/**/\n    3463,\n/**/\n    3462,\n/**/\n    3461,\n/**/\n    3460,\n/**/\n    3459,\n/**/\n    3458,\n/**/\n    3457,\n/**/\n    3456,\n/**/\n    3455,\n/**/\n    3454,\n/**/\n    3453,\n/**/\n    3452,\n/**/\n    3451,\n/**/\n    3450,\n/**/\n    3449,\n/**/\n    3448,\n/**/\n    3447,\n/**/\n    3446,\n/**/\n    3445,\n/**/\n    3444,\n/**/\n    3443,\n/**/\n    3442,\n/**/\n    3441,\n/**/\n    3440,\n/**/\n    3439,\n/**/\n    3438,\n/**/\n    3437,\n/**/\n    3436,\n/**/\n    3435,\n/**/\n    3434,\n/**/\n    3433,\n/**/\n    3432,\n/**/\n    3431,\n/**/\n    3430,\n/**/\n    3429,\n/**/\n    3428,\n/**/\n    3427,\n/**/\n    3426,\n/**/\n    3425,\n/**/\n    3424,\n/**/\n    3423,\n/**/\n    3422,\n/**/\n    3421,\n/**/\n    3420,\n/**/\n    3419,\n/**/\n    3418,\n/**/\n    3417,\n/**/\n    3416,\n/**/\n    3415,\n/**/\n    3414,\n/**/\n    3413,\n/**/\n    3412,\n/**/\n    3411,\n/**/\n    3410,\n/**/\n    3409,\n/**/\n    3408,\n/**/\n    3407,\n/**/\n    3406,\n/**/\n    3405,\n/**/\n    3404,\n/**/\n    3403,\n/**/\n    3402,\n/**/\n    3401,\n/**/\n    3400,\n/**/\n    3399,\n/**/\n    3398,\n/**/\n    3397,\n/**/\n    3396,\n/**/\n    3395,\n/**/\n    3394,\n/**/\n    3393,\n/**/\n    3392,\n/**/\n    3391,\n/**/\n    3390,\n/**/\n    3389,\n/**/\n    3388,\n/**/\n    3387,\n/**/\n    3386,\n/**/\n    3385,\n/**/\n    3384,\n/**/\n    3383,\n/**/\n    3382,\n/**/\n    3381,\n/**/\n    3380,\n/**/\n    3379,\n/**/\n    3378,\n/**/\n    3377,\n/**/\n    3376,\n/**/\n    3375,\n/**/\n    3374,\n/**/\n    3373,\n/**/\n    3372,\n/**/\n    3371,\n/**/\n    3370,\n/**/\n    3369,\n/**/\n    3368,\n/**/\n    3367,\n/**/\n    3366,\n/**/\n    3365,\n/**/\n    3364,\n/**/\n    3363,\n/**/\n    3362,\n/**/\n    3361,\n/**/\n    3360,\n/**/\n    3359,\n/**/\n    3358,\n/**/\n    3357,\n/**/\n    3356,\n/**/\n    3355,\n/**/\n    3354,\n/**/\n    3353,\n/**/\n    3352,\n/**/\n    3351,\n/**/\n    3350,\n/**/\n    3349,\n/**/\n    3348,\n/**/\n    3347,\n/**/\n    3346,\n/**/\n    3345,\n/**/\n    3344,\n/**/\n    3343,\n/**/\n    3342,\n/**/\n    3341,\n/**/\n    3340,\n/**/\n    3339,\n/**/\n    3338,\n/**/\n    3337,\n/**/\n    3336,\n/**/\n    3335,\n/**/\n    3334,\n/**/\n    3333,\n/**/\n    3332,\n/**/\n    3331,\n/**/\n    3330,\n/**/\n    3329,\n/**/\n    3328,\n/**/\n    3327,\n/**/\n    3326,\n/**/\n    3325,\n/**/\n    3324,\n/**/\n    3323,\n/**/\n    3322,\n/**/\n    3321,\n/**/\n    3320,\n/**/\n    3319,\n/**/\n    3318,\n/**/\n    3317,\n/**/\n    3316,\n/**/\n    3315,\n/**/\n    3314,\n/**/\n    3313,\n/**/\n    3312,\n/**/\n    3311,\n/**/\n    3310,\n/**/\n    3309,\n/**/\n    3308,\n/**/\n    3307,\n/**/\n    3306,\n/**/\n    3305,\n/**/\n    3304,\n/**/\n    3303,\n/**/\n    3302,\n/**/\n    3301,\n/**/\n    3300,\n/**/\n    3299,\n/**/\n    3298,\n/**/\n    3297,\n/**/\n    3296,\n/**/\n    3295,\n/**/\n    3294,\n/**/\n    3293,\n/**/\n    3292,\n/**/\n    3291,\n/**/\n    3290,\n/**/\n    3289,\n/**/\n    3288,\n/**/\n    3287,\n/**/\n    3286,\n/**/\n    3285,\n/**/\n    3284,\n/**/\n    3283,\n/**/\n    3282,\n/**/\n    3281,\n/**/\n    3280,\n/**/\n    3279,\n/**/\n    3278,\n/**/\n    3277,\n/**/\n    3276,\n/**/\n    3275,\n/**/\n    3274,\n/**/\n    3273,\n/**/\n    3272,\n/**/\n    3271,\n/**/\n    3270,\n/**/\n    3269,\n/**/\n    3268,\n/**/\n    3267,\n/**/\n    3266,\n/**/\n    3265,\n/**/\n    3264,\n/**/\n    3263,\n/**/\n    3262,\n/**/\n    3261,\n/**/\n    3260,\n/**/\n    3259,\n/**/\n    3258,\n/**/\n    3257,\n/**/\n    3256,\n/**/\n    3255,\n/**/\n    3254,\n/**/\n    3253,\n/**/\n    3252,\n/**/\n    3251,\n/**/\n    3250,\n/**/\n    3249,\n/**/\n    3248,\n/**/\n    3247,\n/**/\n    3246,\n/**/\n    3245,\n/**/\n    3244,\n/**/\n    3243,\n/**/\n    3242,\n/**/\n    3241,\n/**/\n    3240,\n/**/\n    3239,\n/**/\n    3238,\n/**/\n    3237,\n/**/\n    3236,\n/**/\n    3235,\n/**/\n    3234,\n/**/\n    3233,\n/**/\n    3232,\n/**/\n    3231,\n/**/\n    3230,\n/**/\n    3229,\n/**/\n    3228,\n/**/\n    3227,\n/**/\n    3226,\n/**/\n    3225,\n/**/\n    3224,\n/**/\n    3223,\n/**/\n    3222,\n/**/\n    3221,\n/**/\n    3220,\n/**/\n    3219,\n/**/\n    3218,\n/**/\n    3217,\n/**/\n    3216,\n/**/\n    3215,\n/**/\n    3214,\n/**/\n    3213,\n/**/\n    3212,\n/**/\n    3211,\n/**/\n    3210,\n/**/\n    3209,\n/**/\n    3208,\n/**/\n    3207,\n/**/\n    3206,\n/**/\n    3205,\n/**/\n    3204,\n/**/\n    3203,\n/**/\n    3202,\n/**/\n    3201,\n/**/\n    3200,\n/**/\n    3199,\n/**/\n    3198,\n/**/\n    3197,\n/**/\n    3196,\n/**/\n    3195,\n/**/\n    3194,\n/**/\n    3193,\n/**/\n    3192,\n/**/\n    3191,\n/**/\n    3190,\n/**/\n    3189,\n/**/\n    3188,\n/**/\n    3187,\n/**/\n    3186,\n/**/\n    3185,\n/**/\n    3184,\n/**/\n    3183,\n/**/\n    3182,\n/**/\n    3181,\n/**/\n    3180,\n/**/\n    3179,\n/**/\n    3178,\n/**/\n    3177,\n/**/\n    3176,\n/**/\n    3175,\n/**/\n    3174,\n/**/\n    3173,\n/**/\n    3172,\n/**/\n    3171,\n/**/\n    3170,\n/**/\n    3169,\n/**/\n    3168,\n/**/\n    3167,\n/**/\n    3166,\n/**/\n    3165,\n/**/\n    3164,\n/**/\n    3163,\n/**/\n    3162,\n/**/\n    3161,\n/**/\n    3160,\n/**/\n    3159,\n/**/\n    3158,\n/**/\n    3157,\n/**/\n    3156,\n/**/\n    3155,\n/**/\n    3154,\n/**/\n    3153,\n/**/\n    3152,\n/**/\n    3151,\n/**/\n    3150,\n/**/\n    3149,\n/**/\n    3148,\n/**/\n    3147,\n/**/\n    3146,\n/**/\n    3145,\n/**/\n    3144,\n/**/\n    3143,\n/**/\n    3142,\n/**/\n    3141,\n/**/\n    3140,\n/**/\n    3139,\n/**/\n    3138,\n/**/\n    3137,\n/**/\n    3136,\n/**/\n    3135,\n/**/\n    3134,\n/**/\n    3133,\n/**/\n    3132,\n/**/\n    3131,\n/**/\n    3130,\n/**/\n    3129,\n/**/\n    3128,\n/**/\n    3127,\n/**/\n    3126,\n/**/\n    3125,\n/**/\n    3124,\n/**/\n    3123,\n/**/\n    3122,\n/**/\n    3121,\n/**/\n    3120,\n/**/\n    3119,\n/**/\n    3118,\n/**/\n    3117,\n/**/\n    3116,\n/**/\n    3115,\n/**/\n    3114,\n/**/\n    3113,\n/**/\n    3112,\n/**/\n    3111,\n/**/\n    3110,\n/**/\n    3109,\n/**/\n    3108,\n/**/\n    3107,\n/**/\n    3106,\n/**/\n    3105,\n/**/\n    3104,\n/**/\n    3103,\n/**/\n    3102,\n/**/\n    3101,\n/**/\n    3100,\n/**/\n    3099,\n/**/\n    3098,\n/**/\n    3097,\n/**/\n    3096,\n/**/\n    3095,\n/**/\n    3094,\n/**/\n    3093,\n/**/\n    3092,\n/**/\n    3091,\n/**/\n    3090,\n/**/\n    3089,\n/**/\n    3088,\n/**/\n    3087,\n/**/\n    3086,\n/**/\n    3085,\n/**/\n    3084,\n/**/\n    3083,\n/**/\n    3082,\n/**/\n    3081,\n/**/\n    3080,\n/**/\n    3079,\n/**/\n    3078,\n/**/\n    3077,\n/**/\n    3076,\n/**/\n    3075,\n/**/\n    3074,\n/**/\n    3073,\n/**/\n    3072,\n/**/\n    3071,\n/**/\n    3070,\n/**/\n    3069,\n/**/\n    3068,\n/**/\n    3067,\n/**/\n    3066,\n/**/\n    3065,\n/**/\n    3064,\n/**/\n    3063,\n/**/\n    3062,\n/**/\n    3061,\n/**/\n    3060,\n/**/\n    3059,\n/**/\n    3058,\n/**/\n    3057,\n/**/\n    3056,\n/**/\n    3055,\n/**/\n    3054,\n/**/\n    3053,\n/**/\n    3052,\n/**/\n    3051,\n/**/\n    3050,\n/**/\n    3049,\n/**/\n    3048,\n/**/\n    3047,\n/**/\n    3046,\n/**/\n    3045,\n/**/\n    3044,\n/**/\n    3043,\n/**/\n    3042,\n/**/\n    3041,\n/**/\n    3040,\n/**/\n    3039,\n/**/\n    3038,\n/**/\n    3037,\n/**/\n    3036,\n/**/\n    3035,\n/**/\n    3034,\n/**/\n    3033,\n/**/\n    3032,\n/**/\n    3031,\n/**/\n    3030,\n/**/\n    3029,\n/**/\n    3028,\n/**/\n    3027,\n/**/\n    3026,\n/**/\n    3025,\n/**/\n    3024,\n/**/\n    3023,\n/**/\n    3022,\n/**/\n    3021,\n/**/\n    3020,\n/**/\n    3019,\n/**/\n    3018,\n/**/\n    3017,\n/**/\n    3016,\n/**/\n    3015,\n/**/\n    3014,\n/**/\n    3013,\n/**/\n    3012,\n/**/\n    3011,\n/**/\n    3010,\n/**/\n    3009,\n/**/\n    3008,\n/**/\n    3007,\n/**/\n    3006,\n/**/\n    3005,\n/**/\n    3004,\n/**/\n    3003,\n/**/\n    3002,\n/**/\n    3001,\n/**/\n    3000,\n/**/\n    2999,\n/**/\n    2998,\n/**/\n    2997,\n/**/\n    2996,\n/**/\n    2995,\n/**/\n    2994,\n/**/\n    2993,\n/**/\n    2992,\n/**/\n    2991,\n/**/\n    2990,\n/**/\n    2989,\n/**/\n    2988,\n/**/\n    2987,\n/**/\n    2986,\n/**/\n    2985,\n/**/\n    2984,\n/**/\n    2983,\n/**/\n    2982,\n/**/\n    2981,\n/**/\n    2980,\n/**/\n    2979,\n/**/\n    2978,\n/**/\n    2977,\n/**/\n    2976,\n/**/\n    2975,\n/**/\n    2974,\n/**/\n    2973,\n/**/\n    2972,\n/**/\n    2971,\n/**/\n    2970,\n/**/\n    2969,\n/**/\n    2968,\n/**/\n    2967,\n/**/\n    2966,\n/**/\n    2965,\n/**/\n    2964,\n/**/\n    2963,\n/**/\n    2962,\n/**/\n    2961,\n/**/\n    2960,\n/**/\n    2959,\n/**/\n    2958,\n/**/\n    2957,\n/**/\n    2956,\n/**/\n    2955,\n/**/\n    2954,\n/**/\n    2953,\n/**/\n    2952,\n/**/\n    2951,\n/**/\n    2950,\n/**/\n    2949,\n/**/\n    2948,\n/**/\n    2947,\n/**/\n    2946,\n/**/\n    2945,\n/**/\n    2944,\n/**/\n    2943,\n/**/\n    2942,\n/**/\n    2941,\n/**/\n    2940,\n/**/\n    2939,\n/**/\n    2938,\n/**/\n    2937,\n/**/\n    2936,\n/**/\n    2935,\n/**/\n    2934,\n/**/\n    2933,\n/**/\n    2932,\n/**/\n    2931,\n/**/\n    2930,\n/**/\n    2929,\n/**/\n    2928,\n/**/\n    2927,\n/**/\n    2926,\n/**/\n    2925,\n/**/\n    2924,\n/**/\n    2923,\n/**/\n    2922,\n/**/\n    2921,\n/**/\n    2920,\n/**/\n    2919,\n/**/\n    2918,\n/**/\n    2917,\n/**/\n    2916,\n/**/\n    2915,\n/**/\n    2914,\n/**/\n    2913,\n/**/\n    2912,\n/**/\n    2911,\n/**/\n    2910,\n/**/\n    2909,\n/**/\n    2908,\n/**/\n    2907,\n/**/\n    2906,\n/**/\n    2905,\n/**/\n    2904,\n/**/\n    2903,\n/**/\n    2902,\n/**/\n    2901,\n/**/\n    2900,\n/**/\n    2899,\n/**/\n    2898,\n/**/\n    2897,\n/**/\n    2896,\n/**/\n    2895,\n/**/\n    2894,\n/**/\n    2893,\n/**/\n    2892,\n/**/\n    2891,\n/**/\n    2890,\n/**/\n    2889,\n/**/\n    2888,\n/**/\n    2887,\n/**/\n    2886,\n/**/\n    2885,\n/**/\n    2884,\n/**/\n    2883,\n/**/\n    2882,\n/**/\n    2881,\n/**/\n    2880,\n/**/\n    2879,\n/**/\n    2878,\n/**/\n    2877,\n/**/\n    2876,\n/**/\n    2875,\n/**/\n    2874,\n/**/\n    2873,\n/**/\n    2872,\n/**/\n    2871,\n/**/\n    2870,\n/**/\n    2869,\n/**/\n    2868,\n/**/\n    2867,\n/**/\n    2866,\n/**/\n    2865,\n/**/\n    2864,\n/**/\n    2863,\n/**/\n    2862,\n/**/\n    2861,\n/**/\n    2860,\n/**/\n    2859,\n/**/\n    2858,\n/**/\n    2857,\n/**/\n    2856,\n/**/\n    2855,\n/**/\n    2854,\n/**/\n    2853,\n/**/\n    2852,\n/**/\n    2851,\n/**/\n    2850,\n/**/\n    2849,\n/**/\n    2848,\n/**/\n    2847,\n/**/\n    2846,\n/**/\n    2845,\n/**/\n    2844,\n/**/\n    2843,\n/**/\n    2842,\n/**/\n    2841,\n/**/\n    2840,\n/**/\n    2839,\n/**/\n    2838,\n/**/\n    2837,\n/**/\n    2836,\n/**/\n    2835,\n/**/\n    2834,\n/**/\n    2833,\n/**/\n    2832,\n/**/\n    2831,\n/**/\n    2830,\n/**/\n    2829,\n/**/\n    2828,\n/**/\n    2827,\n/**/\n    2826,\n/**/\n    2825,\n/**/\n    2824,\n/**/\n    2823,\n/**/\n    2822,\n/**/\n    2821,\n/**/\n    2820,\n/**/\n    2819,\n/**/\n    2818,\n/**/\n    2817,\n/**/\n    2816,\n/**/\n    2815,\n/**/\n    2814,\n/**/\n    2813,\n/**/\n    2812,\n/**/\n    2811,\n/**/\n    2810,\n/**/\n    2809,\n/**/\n    2808,\n/**/\n    2807,\n/**/\n    2806,\n/**/\n    2805,\n/**/\n    2804,\n/**/\n    2803,\n/**/\n    2802,\n/**/\n    2801,\n/**/\n    2800,\n/**/\n    2799,\n/**/\n    2798,\n/**/\n    2797,\n/**/\n    2796,\n/**/\n    2795,\n/**/\n    2794,\n/**/\n    2793,\n/**/\n    2792,\n/**/\n    2791,\n/**/\n    2790,\n/**/\n    2789,\n/**/\n    2788,\n/**/\n    2787,\n/**/\n    2786,\n/**/\n    2785,\n/**/\n    2784,\n/**/\n    2783,\n/**/\n    2782,\n/**/\n    2781,\n/**/\n    2780,\n/**/\n    2779,\n/**/\n    2778,\n/**/\n    2777,\n/**/\n    2776,\n/**/\n    2775,\n/**/\n    2774,\n/**/\n    2773,\n/**/\n    2772,\n/**/\n    2771,\n/**/\n    2770,\n/**/\n    2769,\n/**/\n    2768,\n/**/\n    2767,\n/**/\n    2766,\n/**/\n    2765,\n/**/\n    2764,\n/**/\n    2763,\n/**/\n    2762,\n/**/\n    2761,\n/**/\n    2760,\n/**/\n    2759,\n/**/\n    2758,\n/**/\n    2757,\n/**/\n    2756,\n/**/\n    2755,\n/**/\n    2754,\n/**/\n    2753,\n/**/\n    2752,\n/**/\n    2751,\n/**/\n    2750,\n/**/\n    2749,\n/**/\n    2748,\n/**/\n    2747,\n/**/\n    2746,\n/**/\n    2745,\n/**/\n    2744,\n/**/\n    2743,\n/**/\n    2742,\n/**/\n    2741,\n/**/\n    2740,\n/**/\n    2739,\n/**/\n    2738,\n/**/\n    2737,\n/**/\n    2736,\n/**/\n    2735,\n/**/\n    2734,\n/**/\n    2733,\n/**/\n    2732,\n/**/\n    2731,\n/**/\n    2730,\n/**/\n    2729,\n/**/\n    2728,\n/**/\n    2727,\n/**/\n    2726,\n/**/\n    2725,\n/**/\n    2724,\n/**/\n    2723,\n/**/\n    2722,\n/**/\n    2721,\n/**/\n    2720,\n/**/\n    2719,\n/**/\n    2718,\n/**/\n    2717,\n/**/\n    2716,\n/**/\n    2715,\n/**/\n    2714,\n/**/\n    2713,\n/**/\n    2712,\n/**/\n    2711,\n/**/\n    2710,\n/**/\n    2709,\n/**/\n    2708,\n/**/\n    2707,\n/**/\n    2706,\n/**/\n    2705,\n/**/\n    2704,\n/**/\n    2703,\n/**/\n    2702,\n/**/\n    2701,\n/**/\n    2700,\n/**/\n    2699,\n/**/\n    2698,\n/**/\n    2697,\n/**/\n    2696,\n/**/\n    2695,\n/**/\n    2694,\n/**/\n    2693,\n/**/\n    2692,\n/**/\n    2691,\n/**/\n    2690,\n/**/\n    2689,\n/**/\n    2688,\n/**/\n    2687,\n/**/\n    2686,\n/**/\n    2685,\n/**/\n    2684,\n/**/\n    2683,\n/**/\n    2682,\n/**/\n    2681,\n/**/\n    2680,\n/**/\n    2679,\n/**/\n    2678,\n/**/\n    2677,\n/**/\n    2676,\n/**/\n    2675,\n/**/\n    2674,\n/**/\n    2673,\n/**/\n    2672,\n/**/\n    2671,\n/**/\n    2670,\n/**/\n    2669,\n/**/\n    2668,\n/**/\n    2667,\n/**/\n    2666,\n/**/\n    2665,\n/**/\n    2664,\n/**/\n    2663,\n/**/\n    2662,\n/**/\n    2661,\n/**/\n    2660,\n/**/\n    2659,\n/**/\n    2658,\n/**/\n    2657,\n/**/\n    2656,\n/**/\n    2655,\n/**/\n    2654,\n/**/\n    2653,\n/**/\n    2652,\n/**/\n    2651,\n/**/\n    2650,\n/**/\n    2649,\n/**/\n    2648,\n/**/\n    2647,\n/**/\n    2646,\n/**/\n    2645,\n/**/\n    2644,\n/**/\n    2643,\n/**/\n    2642,\n/**/\n    2641,\n/**/\n    2640,\n/**/\n    2639,\n/**/\n    2638,\n/**/\n    2637,\n/**/\n    2636,\n/**/\n    2635,\n/**/\n    2634,\n/**/\n    2633,\n/**/\n    2632,\n/**/\n    2631,\n/**/\n    2630,\n/**/\n    2629,\n/**/\n    2628,\n/**/\n    2627,\n/**/\n    2626,\n/**/\n    2625,\n/**/\n    2624,\n/**/\n    2623,\n/**/\n    2622,\n/**/\n    2621,\n/**/\n    2620,\n/**/\n    2619,\n/**/\n    2618,\n/**/\n    2617,\n/**/\n    2616,\n/**/\n    2615,\n/**/\n    2614,\n/**/\n    2613,\n/**/\n    2612,\n/**/\n    2611,\n/**/\n    2610,\n/**/\n    2609,\n/**/\n    2608,\n/**/\n    2607,\n/**/\n    2606,\n/**/\n    2605,\n/**/\n    2604,\n/**/\n    2603,\n/**/\n    2602,\n/**/\n    2601,\n/**/\n    2600,\n/**/\n    2599,\n/**/\n    2598,\n/**/\n    2597,\n/**/\n    2596,\n/**/\n    2595,\n/**/\n    2594,\n/**/\n    2593,\n/**/\n    2592,\n/**/\n    2591,\n/**/\n    2590,\n/**/\n    2589,\n/**/\n    2588,\n/**/\n    2587,\n/**/\n    2586,\n/**/\n    2585,\n/**/\n    2584,\n/**/\n    2583,\n/**/\n    2582,\n/**/\n    2581,\n/**/\n    2580,\n/**/\n    2579,\n/**/\n    2578,\n/**/\n    2577,\n/**/\n    2576,\n/**/\n    2575,\n/**/\n    2574,\n/**/\n    2573,\n/**/\n    2572,\n/**/\n    2571,\n/**/\n    2570,\n/**/\n    2569,\n/**/\n    2568,\n/**/\n    2567,\n/**/\n    2566,\n/**/\n    2565,\n/**/\n    2564,\n/**/\n    2563,\n/**/\n    2562,\n/**/\n    2561,\n/**/\n    2560,\n/**/\n    2559,\n/**/\n    2558,\n/**/\n    2557,\n/**/\n    2556,\n/**/\n    2555,\n/**/\n    2554,\n/**/\n    2553,\n/**/\n    2552,\n/**/\n    2551,\n/**/\n    2550,\n/**/\n    2549,\n/**/\n    2548,\n/**/\n    2547,\n/**/\n    2546,\n/**/\n    2545,\n/**/\n    2544,\n/**/\n    2543,\n/**/\n    2542,\n/**/\n    2541,\n/**/\n    2540,\n/**/\n    2539,\n/**/\n    2538,\n/**/\n    2537,\n/**/\n    2536,\n/**/\n    2535,\n/**/\n    2534,\n/**/\n    2533,\n/**/\n    2532,\n/**/\n    2531,\n/**/\n    2530,\n/**/\n    2529,\n/**/\n    2528,\n/**/\n    2527,\n/**/\n    2526,\n/**/\n    2525,\n/**/\n    2524,\n/**/\n    2523,\n/**/\n    2522,\n/**/\n    2521,\n/**/\n    2520,\n/**/\n    2519,\n/**/\n    2518,\n/**/\n    2517,\n/**/\n    2516,\n/**/\n    2515,\n/**/\n    2514,\n/**/\n    2513,\n/**/\n    2512,\n/**/\n    2511,\n/**/\n    2510,\n/**/\n    2509,\n/**/\n    2508,\n/**/\n    2507,\n/**/\n    2506,\n/**/\n    2505,\n/**/\n    2504,\n/**/\n    2503,\n/**/\n    2502,\n/**/\n    2501,\n/**/\n    2500,\n/**/\n    2499,\n/**/\n    2498,\n/**/\n    2497,\n/**/\n    2496,\n/**/\n    2495,\n/**/\n    2494,\n/**/\n    2493,\n/**/\n    2492,\n/**/\n    2491,\n/**/\n    2490,\n/**/\n    2489,\n/**/\n    2488,\n/**/\n    2487,\n/**/\n    2486,\n/**/\n    2485,\n/**/\n    2484,\n/**/\n    2483,\n/**/\n    2482,\n/**/\n    2481,\n/**/\n    2480,\n/**/\n    2479,\n/**/\n    2478,\n/**/\n    2477,\n/**/\n    2476,\n/**/\n    2475,\n/**/\n    2474,\n/**/\n    2473,\n/**/\n    2472,\n/**/\n    2471,\n/**/\n    2470,\n/**/\n    2469,\n/**/\n    2468,\n/**/\n    2467,\n/**/\n    2466,\n/**/\n    2465,\n/**/\n    2464,\n/**/\n    2463,\n/**/\n    2462,\n/**/\n    2461,\n/**/\n    2460,\n/**/\n    2459,\n/**/\n    2458,\n/**/\n    2457,\n/**/\n    2456,\n/**/\n    2455,\n/**/\n    2454,\n/**/\n    2453,\n/**/\n    2452,\n/**/\n    2451,\n/**/\n    2450,\n/**/\n    2449,\n/**/\n    2448,\n/**/\n    2447,\n/**/\n    2446,\n/**/\n    2445,\n/**/\n    2444,\n/**/\n    2443,\n/**/\n    2442,\n/**/\n    2441,\n/**/\n    2440,\n/**/\n    2439,\n/**/\n    2438,\n/**/\n    2437,\n/**/\n    2436,\n/**/\n    2435,\n/**/\n    2434,\n/**/\n    2433,\n/**/\n    2432,\n/**/\n    2431,\n/**/\n    2430,\n/**/\n    2429,\n/**/\n    2428,\n/**/\n    2427,\n/**/\n    2426,\n/**/\n    2425,\n/**/\n    2424,\n/**/\n    2423,\n/**/\n    2422,\n/**/\n    2421,\n/**/\n    2420,\n/**/\n    2419,\n/**/\n    2418,\n/**/\n    2417,\n/**/\n    2416,\n/**/\n    2415,\n/**/\n    2414,\n/**/\n    2413,\n/**/\n    2412,\n/**/\n    2411,\n/**/\n    2410,\n/**/\n    2409,\n/**/\n    2408,\n/**/\n    2407,\n/**/\n    2406,\n/**/\n    2405,\n/**/\n    2404,\n/**/\n    2403,\n/**/\n    2402,\n/**/\n    2401,\n/**/\n    2400,\n/**/\n    2399,\n/**/\n    2398,\n/**/\n    2397,\n/**/\n    2396,\n/**/\n    2395,\n/**/\n    2394,\n/**/\n    2393,\n/**/\n    2392,\n/**/\n    2391,\n/**/\n    2390,\n/**/\n    2389,\n/**/\n    2388,\n/**/\n    2387,\n/**/\n    2386,\n/**/\n    2385,\n/**/\n    2384,\n/**/\n    2383,\n/**/\n    2382,\n/**/\n    2381,\n/**/\n    2380,\n/**/\n    2379,\n/**/\n    2378,\n/**/\n    2377,\n/**/\n    2376,\n/**/\n    2375,\n/**/\n    2374,\n/**/\n    2373,\n/**/\n    2372,\n/**/\n    2371,\n/**/\n    2370,\n/**/\n    2369,\n/**/\n    2368,\n/**/\n    2367,\n/**/\n    2366,\n/**/\n    2365,\n/**/\n    2364,\n/**/\n    2363,\n/**/\n    2362,\n/**/\n    2361,\n/**/\n    2360,\n/**/\n    2359,\n/**/\n    2358,\n/**/\n    2357,\n/**/\n    2356,\n/**/\n    2355,\n/**/\n    2354,\n/**/\n    2353,\n/**/\n    2352,\n/**/\n    2351,\n/**/\n    2350,\n/**/\n    2349,\n/**/\n    2348,\n/**/\n    2347,\n/**/\n    2346,\n/**/\n    2345,\n/**/\n    2344,\n/**/\n    2343,\n/**/\n    2342,\n/**/\n    2341,\n/**/\n    2340,\n/**/\n    2339,\n/**/\n    2338,\n/**/\n    2337,\n/**/\n    2336,\n/**/\n    2335,\n/**/\n    2334,\n/**/\n    2333,\n/**/\n    2332,\n/**/\n    2331,\n/**/\n    2330,\n/**/\n    2329,\n/**/\n    2328,\n/**/\n    2327,\n/**/\n    2326,\n/**/\n    2325,\n/**/\n    2324,\n/**/\n    2323,\n/**/\n    2322,\n/**/\n    2321,\n/**/\n    2320,\n/**/\n    2319,\n/**/\n    2318,\n/**/\n    2317,\n/**/\n    2316,\n/**/\n    2315,\n/**/\n    2314,\n/**/\n    2313,\n/**/\n    2312,\n/**/\n    2311,\n/**/\n    2310,\n/**/\n    2309,\n/**/\n    2308,\n/**/\n    2307,\n/**/\n    2306,\n/**/\n    2305,\n/**/\n    2304,\n/**/\n    2303,\n/**/\n    2302,\n/**/\n    2301,\n/**/\n    2300,\n/**/\n    2299,\n/**/\n    2298,\n/**/\n    2297,\n/**/\n    2296,\n/**/\n    2295,\n/**/\n    2294,\n/**/\n    2293,\n/**/\n    2292,\n/**/\n    2291,\n/**/\n    2290,\n/**/\n    2289,\n/**/\n    2288,\n/**/\n    2287,\n/**/\n    2286,\n/**/\n    2285,\n/**/\n    2284,\n/**/\n    2283,\n/**/\n    2282,\n/**/\n    2281,\n/**/\n    2280,\n/**/\n    2279,\n/**/\n    2278,\n/**/\n    2277,\n/**/\n    2276,\n/**/\n    2275,\n/**/\n    2274,\n/**/\n    2273,\n/**/\n    2272,\n/**/\n    2271,\n/**/\n    2270,\n/**/\n    2269,\n/**/\n    2268,\n/**/\n    2267,\n/**/\n    2266,\n/**/\n    2265,\n/**/\n    2264,\n/**/\n    2263,\n/**/\n    2262,\n/**/\n    2261,\n/**/\n    2260,\n/**/\n    2259,\n/**/\n    2258,\n/**/\n    2257,\n/**/\n    2256,\n/**/\n    2255,\n/**/\n    2254,\n/**/\n    2253,\n/**/\n    2252,\n/**/\n    2251,\n/**/\n    2250,\n/**/\n    2249,\n/**/\n    2248,\n/**/\n    2247,\n/**/\n    2246,\n/**/\n    2245,\n/**/\n    2244,\n/**/\n    2243,\n/**/\n    2242,\n/**/\n    2241,\n/**/\n    2240,\n/**/\n    2239,\n/**/\n    2238,\n/**/\n    2237,\n/**/\n    2236,\n/**/\n    2235,\n/**/\n    2234,\n/**/\n    2233,\n/**/\n    2232,\n/**/\n    2231,\n/**/\n    2230,\n/**/\n    2229,\n/**/\n    2228,\n/**/\n    2227,\n/**/\n    2226,\n/**/\n    2225,\n/**/\n    2224,\n/**/\n    2223,\n/**/\n    2222,\n/**/\n    2221,\n/**/\n    2220,\n/**/\n    2219,\n/**/\n    2218,\n/**/\n    2217,\n/**/\n    2216,\n/**/\n    2215,\n/**/\n    2214,\n/**/\n    2213,\n/**/\n    2212,\n/**/\n    2211,\n/**/\n    2210,\n/**/\n    2209,\n/**/\n    2208,\n/**/\n    2207,\n/**/\n    2206,\n/**/\n    2205,\n/**/\n    2204,\n/**/\n    2203,\n/**/\n    2202,\n/**/\n    2201,\n/**/\n    2200,\n/**/\n    2199,\n/**/\n    2198,\n/**/\n    2197,\n/**/\n    2196,\n/**/\n    2195,\n/**/\n    2194,\n/**/\n    2193,\n/**/\n    2192,\n/**/\n    2191,\n/**/\n    2190,\n/**/\n    2189,\n/**/\n    2188,\n/**/\n    2187,\n/**/\n    2186,\n/**/\n    2185,\n/**/\n    2184,\n/**/\n    2183,\n/**/\n    2182,\n/**/\n    2181,\n/**/\n    2180,\n/**/\n    2179,\n/**/\n    2178,\n/**/\n    2177,\n/**/\n    2176,\n/**/\n    2175,\n/**/\n    2174,\n/**/\n    2173,\n/**/\n    2172,\n/**/\n    2171,\n/**/\n    2170,\n/**/\n    2169,\n/**/\n    2168,\n/**/\n    2167,\n/**/\n    2166,\n/**/\n    2165,\n/**/\n    2164,\n/**/\n    2163,\n/**/\n    2162,\n/**/\n    2161,\n/**/\n    2160,\n/**/\n    2159,\n/**/\n    2158,\n/**/\n    2157,\n/**/\n    2156,\n/**/\n    2155,\n/**/\n    2154,\n/**/\n    2153,\n/**/\n    2152,\n/**/\n    2151,\n/**/\n    2150,\n/**/\n    2149,\n/**/\n    2148,\n/**/\n    2147,\n/**/\n    2146,\n/**/\n    2145,\n/**/\n    2144,\n/**/\n    2143,\n/**/\n    2142,\n/**/\n    2141,\n/**/\n    2140,\n/**/\n    2139,\n/**/\n    2138,\n/**/\n    2137,\n/**/\n    2136,\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    while (l < h)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n/*\n *\n * term.c: functions for controlling the terminal\n *\n * primitive termcap support for Amiga and Win32 included\n *\n * NOTE: padding and variable substitution is not performed,\n * when compiling without HAVE_TGETENT, we use tputs() and tgoto() dummies.\n */\n\n/*\n * Some systems have a prototype for tgetstr() with (char *) instead of\n * (char **). This define removes that prototype. We include our own prototype\n * below.\n */\n#define tgetstr tgetstr_defined_wrong\n\n#include \"vim.h\"\n\n#ifdef HAVE_TGETENT\n# ifdef HAVE_TERMIOS_H\n#  include <termios.h>\t    // seems to be required for some Linux\n# endif\n# ifdef HAVE_TERMCAP_H\n#  include <termcap.h>\n# endif\n\n/*\n * A few linux systems define outfuntype in termcap.h to be used as the third\n * argument for tputs().\n */\n# if defined(VMS) || defined(AMIGA)\n#  define TPUTSFUNCAST (void (*)(unsigned int))\n# else\n#  ifdef HAVE_OUTFUNTYPE\n#   define TPUTSFUNCAST (outfuntype)\n#  else\n#   define TPUTSFUNCAST (int (*)(int))\n#  endif\n# endif\n#endif\n\n#undef tgetstr\n\nstruct builtin_term\n{\n    int\t\tbt_entry;\n    char\t*bt_string;\n};\n\n// start of keys that are not directly used by Vim but can be mapped\n#define BT_EXTRA_KEYS\t0x101\n\nstatic void parse_builtin_tcap(char_u *s);\nstatic void gather_termleader(void);\n#ifdef FEAT_TERMRESPONSE\nstatic void req_codes_from_term(void);\nstatic void req_more_codes_from_term(void);\nstatic void got_code_from_term(char_u *code, int len);\nstatic void check_for_codes_from_term(void);\n#endif\nstatic void del_termcode_idx(int idx);\nstatic int find_term_bykeys(char_u *src);\nstatic int term_is_builtin(char_u *name);\nstatic int term_7to8bit(char_u *p);\n\n#ifdef HAVE_TGETENT\nstatic char *invoke_tgetent(char_u *, char_u *);\n\n/*\n * Here is our own prototype for tgetstr(), any prototypes from the include\n * files have been disabled by the define at the start of this file.\n */\nchar\t\t*tgetstr(char *, char **);\n\n# ifdef FEAT_TERMRESPONSE\n    // Change this to \"if 1\" to debug what happens with termresponse.\n#  if 0\n#   define DEBUG_TERMRESPONSE\nstatic void log_tr(const char *fmt, ...) ATTRIBUTE_FORMAT_PRINTF(1, 2);\n#   define LOG_TR(msg) log_tr msg\n#  else\n#   define LOG_TR(msg) do { /**/ } while (0)\n#  endif\n\ntypedef enum {\n    STATUS_GET,\t\t// send request when switching to RAW mode\n    STATUS_SENT,\t// did send request, checking for response\n    STATUS_GOT,\t\t// received response\n    STATUS_FAIL\t\t// timed out\n} request_progress_T;\n\ntypedef struct {\n    request_progress_T\t    tr_progress;\n    time_t\t\t    tr_start;\t// when request was sent, -1 for never\n} termrequest_T;\n\n#  define TERMREQUEST_INIT {STATUS_GET, -1}\n\n// Request Terminal Version status:\nstatic termrequest_T crv_status = TERMREQUEST_INIT;\n\n// Request Cursor position report:\nstatic termrequest_T u7_status = TERMREQUEST_INIT;\n\n// Request xterm compatibility check:\nstatic termrequest_T xcc_status = TERMREQUEST_INIT;\n\n#  ifdef FEAT_TERMINAL\n// Request foreground color report:\nstatic termrequest_T rfg_status = TERMREQUEST_INIT;\nstatic int fg_r = 0;\nstatic int fg_g = 0;\nstatic int fg_b = 0;\nstatic int bg_r = 255;\nstatic int bg_g = 255;\nstatic int bg_b = 255;\n#  endif\n\n// Request background color report:\nstatic termrequest_T rbg_status = TERMREQUEST_INIT;\n\n// Request cursor blinking mode report:\nstatic termrequest_T rbm_status = TERMREQUEST_INIT;\n\n// Request cursor style report:\nstatic termrequest_T rcs_status = TERMREQUEST_INIT;\n\n// Request window's position report:\nstatic termrequest_T winpos_status = TERMREQUEST_INIT;\n\nstatic termrequest_T *all_termrequests[] = {\n    &crv_status,\n    &u7_status,\n    &xcc_status,\n#  ifdef FEAT_TERMINAL\n    &rfg_status,\n#  endif\n    &rbg_status,\n    &rbm_status,\n    &rcs_status,\n    &winpos_status,\n    NULL\n};\n\n// The t_8u code may default to a value but get reset when the term response is\n// received.  To avoid redrawing too often, only redraw when t_8u is not reset\n// and it was supposed to be written.\n// FALSE -> don't output t_8u yet\n// MAYBE -> tried outputing t_8u while FALSE\n// OK    -> can write t_8u\nint write_t_8u_state = FALSE;\n# endif\n\n/*\n * Don't declare these variables if termcap.h contains them.\n * Autoconf checks if these variables should be declared extern (not all\n * systems have them).\n * Some versions define ospeed to be speed_t, but that is incompatible with\n * BSD, where ospeed is short and speed_t is long.\n */\n# ifndef HAVE_OSPEED\n#  ifdef OSPEED_EXTERN\nextern short ospeed;\n#   else\nshort ospeed;\n#   endif\n# endif\n# ifndef HAVE_UP_BC_PC\n#  ifdef UP_BC_PC_EXTERN\nextern char *UP, *BC, PC;\n#  else\nchar *UP, *BC, PC;\n#  endif\n# endif\n\n# define TGETSTR(s, p)\tvim_tgetstr((s), (p))\n# define TGETENT(b, t)\ttgetent((char *)(b), (char *)(t))\nstatic char_u *vim_tgetstr(char *s, char_u **pp);\n#endif // HAVE_TGETENT\n\nstatic int  detected_8bit = FALSE;\t// detected 8-bit terminal\n\n#if (defined(UNIX) || defined(VMS))\nstatic int focus_state = MAYBE; // TRUE if the Vim window has focus\n#endif\n\n#ifdef FEAT_TERMRESPONSE\n// When the cursor shape was detected these values are used:\n// 1: block, 2: underline, 3: vertical bar\nstatic int initial_cursor_shape = 0;\n\n// The blink flag from the style response may be inverted from the actual\n// blinking state, xterm XORs the flags.\nstatic int initial_cursor_shape_blink = FALSE;\n\n// The blink flag from the blinking-cursor mode response\nstatic int initial_cursor_blink = FALSE;\n#endif\n\n/*\n * Here are the builtin termcap entries.  They are not stored as complete\n * structures with all entries to save space.\n *\n * The entries are also included even when HAVE_TGETENT is defined, the systerm\n * termcap may be incomplee.  When HAVE_TGETENT is defined, the builtin entries\n * can be accessed with \"builtin_amiga\", \"builtin_ansi\", \"builtin_debug\", etc.\n *\n * Each termcap is a list of builtin_term structures. It always starts with\n * KS_NAME, which separates the entries.  See parse_builtin_tcap() for all\n * details.\n * bt_entry is either a KS_xxx code (>= 0), or a K_xxx code.\n *\n * Entries marked with \"guessed\" may be wrong.\n */\nstatic struct builtin_term builtin_termcaps[] =\n{\n\n#if defined(FEAT_GUI)\n/*\n * GUI pseudo term-cap.\n */\n    {(int)KS_NAME,\t\"gui\"},\n    {(int)KS_CE,\t\"\\033|$\"},\n    {(int)KS_AL,\t\"\\033|i\"},\n# ifdef TERMINFO\n    {(int)KS_CAL,\t\"\\033|%p1%dI\"},\n# else\n    {(int)KS_CAL,\t\"\\033|%dI\"},\n# endif\n    {(int)KS_DL,\t\"\\033|d\"},\n# ifdef TERMINFO\n    {(int)KS_CDL,\t\"\\033|%p1%dD\"},\n    {(int)KS_CS,\t\"\\033|%p1%d;%p2%dR\"},\n    {(int)KS_CSV,\t\"\\033|%p1%d;%p2%dV\"},\n# else\n    {(int)KS_CDL,\t\"\\033|%dD\"},\n    {(int)KS_CS,\t\"\\033|%d;%dR\"},\n    {(int)KS_CSV,\t\"\\033|%d;%dV\"},\n# endif\n    {(int)KS_CL,\t\"\\033|C\"},\n\t\t\t// attributes switched on with 'h', off with * 'H'\n    {(int)KS_ME,\t\"\\033|31H\"}, // HL_ALL\n    {(int)KS_MR,\t\"\\033|1h\"},   // HL_INVERSE\n    {(int)KS_MD,\t\"\\033|2h\"},   // HL_BOLD\n    {(int)KS_SE,\t\"\\033|16H\"}, // HL_STANDOUT\n    {(int)KS_SO,\t\"\\033|16h\"}, // HL_STANDOUT\n    {(int)KS_UE,\t\"\\033|8H\"},   // HL_UNDERLINE\n    {(int)KS_US,\t\"\\033|8h\"},   // HL_UNDERLINE\n    {(int)KS_UCE,\t\"\\033|8C\"},   // HL_UNDERCURL\n    {(int)KS_UCS,\t\"\\033|8c\"},   // HL_UNDERCURL\n    {(int)KS_STE,\t\"\\033|4C\"},   // HL_STRIKETHROUGH\n    {(int)KS_STS,\t\"\\033|4c\"},   // HL_STRIKETHROUGH\n    {(int)KS_CZR,\t\"\\033|4H\"},   // HL_ITALIC\n    {(int)KS_CZH,\t\"\\033|4h\"},   // HL_ITALIC\n    {(int)KS_VB,\t\"\\033|f\"},\n    {(int)KS_MS,\t\"y\"},\n    {(int)KS_UT,\t\"y\"},\n    {(int)KS_XN,\t\"y\"},\n    {(int)KS_LE,\t\"\\b\"},\t\t// cursor-left = BS\n    {(int)KS_ND,\t\"\\014\"},\t// cursor-right = CTRL-L\n# ifdef TERMINFO\n    {(int)KS_CM,\t\"\\033|%p1%d;%p2%dM\"},\n# else\n    {(int)KS_CM,\t\"\\033|%d;%dM\"},\n# endif\n\t// there are no key sequences here, the GUI sequences are recognized\n\t// in check_termcode()\n#endif\n\n#ifndef NO_BUILTIN_TCAPS\n\n# if defined(AMIGA) || defined(ALL_BUILTIN_TCAPS)\n/*\n * Amiga console window, default for Amiga\n */\n    {(int)KS_NAME,\t\"amiga\"},\n    {(int)KS_CE,\t\"\\033[K\"},\n    {(int)KS_CD,\t\"\\033[J\"},\n    {(int)KS_AL,\t\"\\033[L\"},\n#  ifdef TERMINFO\n    {(int)KS_CAL,\t\"\\033[%p1%dL\"},\n#  else\n    {(int)KS_CAL,\t\"\\033[%dL\"},\n#  endif\n    {(int)KS_DL,\t\"\\033[M\"},\n#  ifdef TERMINFO\n    {(int)KS_CDL,\t\"\\033[%p1%dM\"},\n#  else\n    {(int)KS_CDL,\t\"\\033[%dM\"},\n#  endif\n    {(int)KS_CL,\t\"\\014\"},\n    {(int)KS_VI,\t\"\\033[0 p\"},\n    {(int)KS_VE,\t\"\\033[1 p\"},\n    {(int)KS_ME,\t\"\\033[0m\"},\n    {(int)KS_MR,\t\"\\033[7m\"},\n    {(int)KS_MD,\t\"\\033[1m\"},\n    {(int)KS_SE,\t\"\\033[0m\"},\n    {(int)KS_SO,\t\"\\033[33m\"},\n    {(int)KS_US,\t\"\\033[4m\"},\n    {(int)KS_UE,\t\"\\033[0m\"},\n    {(int)KS_CZH,\t\"\\033[3m\"},\n    {(int)KS_CZR,\t\"\\033[0m\"},\n#if defined(__amigaos4__) || defined(__MORPHOS__) || defined(__AROS__)\n    {(int)KS_CCO,\t\"8\"},\t\t// allow 8 colors\n#  ifdef TERMINFO\n    {(int)KS_CAB,\t\"\\033[4%p1%dm\"},// set background color\n    {(int)KS_CAF,\t\"\\033[3%p1%dm\"},// set foreground color\n#  else\n    {(int)KS_CAB,\t\"\\033[4%dm\"},\t// set background color\n    {(int)KS_CAF,\t\"\\033[3%dm\"},\t// set foreground color\n#  endif\n    {(int)KS_OP,\t\"\\033[m\"},\t// reset colors\n#endif\n    {(int)KS_MS,\t\"y\"},\n    {(int)KS_UT,\t\"y\"},\t\t// guessed\n    {(int)KS_LE,\t\"\\b\"},\n#  ifdef TERMINFO\n    {(int)KS_CM,\t\"\\033[%i%p1%d;%p2%dH\"},\n#  else\n    {(int)KS_CM,\t\"\\033[%i%d;%dH\"},\n#  endif\n#if defined(__MORPHOS__)\n    {(int)KS_SR,\t\"\\033M\"},\n#endif\n#  ifdef TERMINFO\n    {(int)KS_CRI,\t\"\\033[%p1%dC\"},\n#  else\n    {(int)KS_CRI,\t\"\\033[%dC\"},\n#  endif\n    {K_UP,\t\t\"\\233A\"},\n    {K_DOWN,\t\t\"\\233B\"},\n    {K_LEFT,\t\t\"\\233D\"},\n    {K_RIGHT,\t\t\"\\233C\"},\n    {K_S_UP,\t\t\"\\233T\"},\n    {K_S_DOWN,\t\t\"\\233S\"},\n    {K_S_LEFT,\t\t\"\\233 A\"},\n    {K_S_RIGHT,\t\t\"\\233 @\"},\n    {K_S_TAB,\t\t\"\\233Z\"},\n    {K_F1,\t\t\"\\233\\060~\"},// some compilers don't dig \"\\2330\"\n    {K_F2,\t\t\"\\233\\061~\"},\n    {K_F3,\t\t\"\\233\\062~\"},\n    {K_F4,\t\t\"\\233\\063~\"},\n    {K_F5,\t\t\"\\233\\064~\"},\n    {K_F6,\t\t\"\\233\\065~\"},\n    {K_F7,\t\t\"\\233\\066~\"},\n    {K_F8,\t\t\"\\233\\067~\"},\n    {K_F9,\t\t\"\\233\\070~\"},\n    {K_F10,\t\t\"\\233\\071~\"},\n    {K_S_F1,\t\t\"\\233\\061\\060~\"},\n    {K_S_F2,\t\t\"\\233\\061\\061~\"},\n    {K_S_F3,\t\t\"\\233\\061\\062~\"},\n    {K_S_F4,\t\t\"\\233\\061\\063~\"},\n    {K_S_F5,\t\t\"\\233\\061\\064~\"},\n    {K_S_F6,\t\t\"\\233\\061\\065~\"},\n    {K_S_F7,\t\t\"\\233\\061\\066~\"},\n    {K_S_F8,\t\t\"\\233\\061\\067~\"},\n    {K_S_F9,\t\t\"\\233\\061\\070~\"},\n    {K_S_F10,\t\t\"\\233\\061\\071~\"},\n    {K_HELP,\t\t\"\\233?~\"},\n    {K_INS,\t\t\"\\233\\064\\060~\"},\t// 101 key keyboard\n    {K_PAGEUP,\t\t\"\\233\\064\\061~\"},\t// 101 key keyboard\n    {K_PAGEDOWN,\t\"\\233\\064\\062~\"},\t// 101 key keyboard\n    {K_HOME,\t\t\"\\233\\064\\064~\"},\t// 101 key keyboard\n    {K_END,\t\t\"\\233\\064\\065~\"},\t// 101 key keyboard\n\n    {BT_EXTRA_KEYS,\t\"\"},\n    {TERMCAP2KEY('#', '2'), \"\\233\\065\\064~\"},\t// shifted home key\n    {TERMCAP2KEY('#', '3'), \"\\233\\065\\060~\"},\t// shifted insert key\n    {TERMCAP2KEY('*', '7'), \"\\233\\065\\065~\"},\t// shifted end key\n# endif\n\n# ifdef ALL_BUILTIN_TCAPS\n/*\n * almost standard ANSI terminal\n */\n    {(int)KS_CE,\t\"\\033[K\"},\n    {(int)KS_CD,\t\"\\033[J\"},\n    {(int)KS_AL,\t\"\\033[L\"},\n#  ifdef TERMINFO\n    {(int)KS_CAL,\t\"\\033[%p1%dL\"},\n#  else\n    {(int)KS_CAL,\t\"\\033[%dL\"},\n#  endif\n    {(int)KS_DL,\t\"\\033[M\"},\n#  ifdef TERMINFO\n    {(int)KS_CDL,\t\"\\033[%p1%dM\"},\n#  else\n    {(int)KS_CDL,\t\"\\033[%dM\"},\n#  endif\n    {(int)KS_CL,\t\"\\033[H\\033[2J\"},\n#ifdef notyet\n    {(int)KS_VI,\t\"[VI]\"}, // cursor invisible, VT320: CSI ? 25 l\n    {(int)KS_VE,\t\"[VE]\"}, // cursor visible, VT320: CSI ? 25 h\n#endif\n    {(int)KS_ME,\t\"\\033[m\"},\t// normal mode\n    {(int)KS_MR,\t\"\\033[7m\"},\t// reverse\n    {(int)KS_MD,\t\"\\033[1m\"},\t// bold\n    {(int)KS_SO,\t\"\\033[31m\"},\t// standout mode: red\n    {(int)KS_SE,\t\"\\033[m\"},\t// standout end\n    {(int)KS_CZH,\t\"\\033[35m\"},\t// italic: purple\n    {(int)KS_CZR,\t\"\\033[m\"},\t// italic end\n    {(int)KS_US,\t\"\\033[4m\"},\t// underscore mode\n    {(int)KS_UE,\t\"\\033[m\"},\t// underscore end\n    {(int)KS_CCO,\t\"8\"},\t\t// allow 8 colors\n#  ifdef TERMINFO\n    {(int)KS_CAB,\t\"\\033[4%p1%dm\"},// set background color\n    {(int)KS_CAF,\t\"\\033[3%p1%dm\"},// set foreground color\n#  else\n    {(int)KS_CAB,\t\"\\033[4%dm\"},\t// set background color\n    {(int)KS_CAF,\t\"\\033[3%dm\"},\t// set foreground color\n#  endif\n    {(int)KS_OP,\t\"\\033[m\"},\t// reset colors\n    {(int)KS_MS,\t\"y\"},\t\t// safe to move cur in reverse mode\n    {(int)KS_UT,\t\"y\"},\t\t// guessed\n    {(int)KS_LE,\t\"\\b\"},\n#  ifdef TERMINFO\n    {(int)KS_CM,\t\"\\033[%i%p1%d;%p2%dH\"},\n#  else\n    {(int)KS_CM,\t\"\\033[%i%d;%dH\"},\n#  endif\n    {(int)KS_SR,\t\"\\033M\"},\n#  ifdef TERMINFO\n    {(int)KS_CRI,\t\"\\033[%p1%dC\"},\n#  else\n    {(int)KS_CRI,\t\"\\033[%dC\"},\n#  endif\n\n    {K_UP,\t\t\"\\033[A\"},\n    {K_DOWN,\t\t\"\\033[B\"},\n    {K_LEFT,\t\t\"\\033[D\"},\n    {K_RIGHT,\t\t\"\\033[C\"},\n# endif\n\n# if defined(UNIX) || defined(ALL_BUILTIN_TCAPS) || defined(SOME_BUILTIN_TCAPS)\n/*\n * standard ANSI terminal, default for unix\n */\n    {(int)KS_NAME,\t\"ansi\"},\n    {(int)KS_CE,\t\"\\033[K\"},\n    {(int)KS_AL,\t\"\\033[L\"},\n#  ifdef TERMINFO\n    {(int)KS_CAL,\t\"\\033[%p1%dL\"},\n#  else\n    {(int)KS_CAL,\t\"\\033[%dL\"},\n#  endif\n    {(int)KS_DL,\t\"\\033[M\"},\n#  ifdef TERMINFO\n    {(int)KS_CDL,\t\"\\033[%p1%dM\"},\n#  else\n    {(int)KS_CDL,\t\"\\033[%dM\"},\n#  endif\n    {(int)KS_CL,\t\"\\033[H\\033[2J\"},\n    {(int)KS_ME,\t\"\\033[0m\"},\n    {(int)KS_MR,\t\"\\033[7m\"},\n    {(int)KS_MS,\t\"y\"},\n    {(int)KS_UT,\t\"y\"},\t\t// guessed\n    {(int)KS_LE,\t\"\\b\"},\n#  ifdef TERMINFO\n    {(int)KS_CM,\t\"\\033[%i%p1%d;%p2%dH\"},\n#  else\n    {(int)KS_CM,\t\"\\033[%i%d;%dH\"},\n#  endif\n#  ifdef TERMINFO\n    {(int)KS_CRI,\t\"\\033[%p1%dC\"},\n#  else\n    {(int)KS_CRI,\t\"\\033[%dC\"},\n#  endif\n# endif\n\n# if defined(ALL_BUILTIN_TCAPS)\n/*\n * These codes are valid when nansi.sys or equivalent has been installed.\n * Function keys on a PC are preceded with a NUL. These are converted into\n * K_NUL '\\316' in mch_inchar(), because we cannot handle NULs in key codes.\n * CTRL-arrow is used instead of SHIFT-arrow.\n */\n    {(int)KS_NAME,\t\"pcansi\"},\n    {(int)KS_DL,\t\"\\033[M\"},\n    {(int)KS_AL,\t\"\\033[L\"},\n    {(int)KS_CE,\t\"\\033[K\"},\n    {(int)KS_CL,\t\"\\033[2J\"},\n    {(int)KS_ME,\t\"\\033[0m\"},\n    {(int)KS_MR,\t\"\\033[5m\"},\t// reverse: black on lightgrey\n    {(int)KS_MD,\t\"\\033[1m\"},\t// bold: white text\n    {(int)KS_SE,\t\"\\033[0m\"},\t// standout end\n    {(int)KS_SO,\t\"\\033[31m\"},\t// standout: white on blue\n    {(int)KS_CZH,\t\"\\033[34;43m\"},\t// italic mode: blue text on yellow\n    {(int)KS_CZR,\t\"\\033[0m\"},\t// italic mode end\n    {(int)KS_US,\t\"\\033[36;41m\"},\t// underscore mode: cyan text on red\n    {(int)KS_UE,\t\"\\033[0m\"},\t// underscore mode end\n    {(int)KS_CCO,\t\"8\"},\t\t// allow 8 colors\n#  ifdef TERMINFO\n    {(int)KS_CAB,\t\"\\033[4%p1%dm\"},// set background color\n    {(int)KS_CAF,\t\"\\033[3%p1%dm\"},// set foreground color\n#  else\n    {(int)KS_CAB,\t\"\\033[4%dm\"},\t// set background color\n    {(int)KS_CAF,\t\"\\033[3%dm\"},\t// set foreground color\n#  endif\n    {(int)KS_OP,\t\"\\033[0m\"},\t// reset colors\n    {(int)KS_MS,\t\"y\"},\n    {(int)KS_UT,\t\"y\"},\t\t// guessed\n    {(int)KS_LE,\t\"\\b\"},\n#  ifdef TERMINFO\n    {(int)KS_CM,\t\"\\033[%i%p1%d;%p2%dH\"},\n#  else\n    {(int)KS_CM,\t\"\\033[%i%d;%dH\"},\n#  endif\n#  ifdef TERMINFO\n    {(int)KS_CRI,\t\"\\033[%p1%dC\"},\n#  else\n    {(int)KS_CRI,\t\"\\033[%dC\"},\n#  endif\n    {K_UP,\t\t\"\\316H\"},\n    {K_DOWN,\t\t\"\\316P\"},\n    {K_LEFT,\t\t\"\\316K\"},\n    {K_RIGHT,\t\t\"\\316M\"},\n    {K_S_LEFT,\t\t\"\\316s\"},\n    {K_S_RIGHT,\t\t\"\\316t\"},\n    {K_F1,\t\t\"\\316;\"},\n    {K_F2,\t\t\"\\316<\"},\n    {K_F3,\t\t\"\\316=\"},\n    {K_F4,\t\t\"\\316>\"},\n    {K_F5,\t\t\"\\316?\"},\n    {K_F6,\t\t\"\\316@\"},\n    {K_F7,\t\t\"\\316A\"},\n    {K_F8,\t\t\"\\316B\"},\n    {K_F9,\t\t\"\\316C\"},\n    {K_F10,\t\t\"\\316D\"},\n    {K_F11,\t\t\"\\316\\205\"},\t// guessed\n    {K_F12,\t\t\"\\316\\206\"},\t// guessed\n    {K_S_F1,\t\t\"\\316T\"},\n    {K_S_F2,\t\t\"\\316U\"},\n    {K_S_F3,\t\t\"\\316V\"},\n    {K_S_F4,\t\t\"\\316W\"},\n    {K_S_F5,\t\t\"\\316X\"},\n    {K_S_F6,\t\t\"\\316Y\"},\n    {K_S_F7,\t\t\"\\316Z\"},\n    {K_S_F8,\t\t\"\\316[\"},\n    {K_S_F9,\t\t\"\\316\\\\\"},\n    {K_S_F10,\t\t\"\\316]\"},\n    {K_S_F11,\t\t\"\\316\\207\"},\t// guessed\n    {K_S_F12,\t\t\"\\316\\210\"},\t// guessed\n    {K_INS,\t\t\"\\316R\"},\n    {K_DEL,\t\t\"\\316S\"},\n    {K_HOME,\t\t\"\\316G\"},\n    {K_END,\t\t\"\\316O\"},\n    {K_PAGEDOWN,\t\"\\316Q\"},\n    {K_PAGEUP,\t\t\"\\316I\"},\n# endif\n\n# if defined(MSWIN) || defined(ALL_BUILTIN_TCAPS)\n/*\n * These codes are valid for the Win32 Console .  The entries that start with\n * ESC | are translated into console calls in os_win32.c.  The function keys\n * are also translated in os_win32.c.\n */\n    {(int)KS_NAME,\t\"win32\"},\n    {(int)KS_CE,\t\"\\033|K\"},\t// clear to end of line\n    {(int)KS_AL,\t\"\\033|L\"},\t// add new blank line\n#  ifdef TERMINFO\n    {(int)KS_CAL,\t\"\\033|%p1%dL\"},\t// add number of new blank lines\n#  else\n    {(int)KS_CAL,\t\"\\033|%dL\"},\t// add number of new blank lines\n#  endif\n    {(int)KS_DL,\t\"\\033|M\"},\t// delete line\n#  ifdef TERMINFO\n    {(int)KS_CDL,\t\"\\033|%p1%dM\"},\t// delete number of lines\n    {(int)KS_CSV,\t\"\\033|%p1%d;%p2%dV\"},\n#  else\n    {(int)KS_CDL,\t\"\\033|%dM\"},\t// delete number of lines\n    {(int)KS_CSV,\t\"\\033|%d;%dV\"},\n#  endif\n    {(int)KS_CL,\t\"\\033|J\"},\t// clear screen\n    {(int)KS_CD,\t\"\\033|j\"},\t// clear to end of display\n    {(int)KS_VI,\t\"\\033|v\"},\t// cursor invisible\n    {(int)KS_VE,\t\"\\033|V\"},\t// cursor visible\n\n    {(int)KS_ME,\t\"\\033|0m\"},\t// normal\n    {(int)KS_MR,\t\"\\033|112m\"},\t// reverse: black on lightgray\n    {(int)KS_MD,\t\"\\033|15m\"},\t// bold: white on black\n#if 1\n    {(int)KS_SO,\t\"\\033|31m\"},\t// standout: white on blue\n    {(int)KS_SE,\t\"\\033|0m\"},\t// standout end\n#else\n    {(int)KS_SO,\t\"\\033|F\"},\t// standout: high intensity\n    {(int)KS_SE,\t\"\\033|f\"},\t// standout end\n#endif\n    {(int)KS_CZH,\t\"\\033|225m\"},\t// italic: blue text on yellow\n    {(int)KS_CZR,\t\"\\033|0m\"},\t// italic end\n    {(int)KS_US,\t\"\\033|67m\"},\t// underscore: cyan text on red\n    {(int)KS_UE,\t\"\\033|0m\"},\t// underscore end\n    {(int)KS_CCO,\t\"16\"},\t\t// allow 16 colors\n#  ifdef TERMINFO\n    {(int)KS_CAB,\t\"\\033|%p1%db\"},\t// set background color\n    {(int)KS_CAF,\t\"\\033|%p1%df\"},\t// set foreground color\n#  else\n    {(int)KS_CAB,\t\"\\033|%db\"},\t// set background color\n    {(int)KS_CAF,\t\"\\033|%df\"},\t// set foreground color\n#  endif\n\n    {(int)KS_MS,\t\"y\"},\t\t// save to move cur in reverse mode\n    {(int)KS_UT,\t\"y\"},\n    {(int)KS_XN,\t\"y\"},\n    {(int)KS_LE,\t\"\\b\"},\n#  ifdef TERMINFO\n    {(int)KS_CM,\t\"\\033|%i%p1%d;%p2%dH\"}, // cursor motion\n#  else\n    {(int)KS_CM,\t\"\\033|%i%d;%dH\"}, // cursor motion\n#  endif\n    {(int)KS_VB,\t\"\\033|B\"},\t// visual bell\n    {(int)KS_TI,\t\"\\033|S\"},\t// put terminal in termcap mode\n    {(int)KS_TE,\t\"\\033|E\"},\t// out of termcap mode\n#  ifdef TERMINFO\n    {(int)KS_CS,\t\"\\033|%i%p1%d;%p2%dr\"}, // scroll region\n#  else\n    {(int)KS_CS,\t\"\\033|%i%d;%dr\"}, // scroll region\n#  endif\n#  ifdef FEAT_TERMGUICOLORS\n    {(int)KS_8F,\t\"\\033|38;2;%lu;%lu;%lum\"},\n    {(int)KS_8B,\t\"\\033|48;2;%lu;%lu;%lum\"},\n#  endif\n\n    {K_UP,\t\t\"\\316H\"},\n    {K_DOWN,\t\t\"\\316P\"},\n    {K_LEFT,\t\t\"\\316K\"},\n    {K_RIGHT,\t\t\"\\316M\"},\n    {K_S_UP,\t\t\"\\316\\304\"},\n    {K_S_DOWN,\t\t\"\\316\\317\"},\n    {K_S_LEFT,\t\t\"\\316\\311\"},\n    {K_C_LEFT,\t\t\"\\316s\"},\n    {K_S_RIGHT,\t\t\"\\316\\313\"},\n    {K_C_RIGHT,\t\t\"\\316t\"},\n    {K_S_TAB,\t\t\"\\316\\017\"},\n    {K_F1,\t\t\"\\316;\"},\n    {K_F2,\t\t\"\\316<\"},\n    {K_F3,\t\t\"\\316=\"},\n    {K_F4,\t\t\"\\316>\"},\n    {K_F5,\t\t\"\\316?\"},\n    {K_F6,\t\t\"\\316@\"},\n    {K_F7,\t\t\"\\316A\"},\n    {K_F8,\t\t\"\\316B\"},\n    {K_F9,\t\t\"\\316C\"},\n    {K_F10,\t\t\"\\316D\"},\n    {K_F11,\t\t\"\\316\\205\"},\n    {K_F12,\t\t\"\\316\\206\"},\n    {K_S_F1,\t\t\"\\316T\"},\n    {K_S_F2,\t\t\"\\316U\"},\n    {K_S_F3,\t\t\"\\316V\"},\n    {K_S_F4,\t\t\"\\316W\"},\n    {K_S_F5,\t\t\"\\316X\"},\n    {K_S_F6,\t\t\"\\316Y\"},\n    {K_S_F7,\t\t\"\\316Z\"},\n    {K_S_F8,\t\t\"\\316[\"},\n    {K_S_F9,\t\t\"\\316\\\\\"},\n    {K_S_F10,\t\t\"\\316]\"},\n    {K_S_F11,\t\t\"\\316\\207\"},\n    {K_S_F12,\t\t\"\\316\\210\"},\n    {K_INS,\t\t\"\\316R\"},\n    {K_DEL,\t\t\"\\316S\"},\n    {K_HOME,\t\t\"\\316G\"},\n    {K_S_HOME,\t\t\"\\316\\302\"},\n    {K_C_HOME,\t\t\"\\316w\"},\n    {K_END,\t\t\"\\316O\"},\n    {K_S_END,\t\t\"\\316\\315\"},\n    {K_C_END,\t\t\"\\316u\"},\n    {K_PAGEDOWN,\t\"\\316Q\"},\n    {K_PAGEUP,\t\t\"\\316I\"},\n    {K_KPLUS,\t\t\"\\316N\"},\n    {K_KMINUS,\t\t\"\\316J\"},\n    {K_KMULTIPLY,\t\"\\316\\067\"},\n    {K_K0,\t\t\"\\316\\332\"},\n    {K_K1,\t\t\"\\316\\336\"},\n    {K_K2,\t\t\"\\316\\342\"},\n    {K_K3,\t\t\"\\316\\346\"},\n    {K_K4,\t\t\"\\316\\352\"},\n    {K_K5,\t\t\"\\316\\356\"},\n    {K_K6,\t\t\"\\316\\362\"},\n    {K_K7,\t\t\"\\316\\366\"},\n    {K_K8,\t\t\"\\316\\372\"},\n    {K_K9,\t\t\"\\316\\376\"},\n    {K_BS,\t\t\"\\316x\"},\n    {K_S_BS,\t\t\"\\316y\"},\n# endif\n\n# if defined(VMS) || defined(ALL_BUILTIN_TCAPS)\n/*\n * VT320 is working as an ANSI terminal compatible DEC terminal.\n * (it covers VT1x0, VT2x0 and VT3x0 up to VT320 on VMS as well)\n * TODO:- rewrite ESC[ codes to CSI\n *      - keyboard languages (CSI ? 26 n)\n */\n    {(int)KS_NAME,\t\"vt320\"},\n    {(int)KS_CE,\t\"\\033[K\"},\n    {(int)KS_AL,\t\"\\033[L\"},\n#  ifdef TERMINFO\n    {(int)KS_CAL,\t\"\\033[%p1%dL\"},\n#  else\n    {(int)KS_CAL,\t\"\\033[%dL\"},\n#  endif\n    {(int)KS_DL,\t\"\\033[M\"},\n#  ifdef TERMINFO\n    {(int)KS_CDL,\t\"\\033[%p1%dM\"},\n#  else\n    {(int)KS_CDL,\t\"\\033[%dM\"},\n#  endif\n    {(int)KS_CL,\t\"\\033[H\\033[2J\"},\n    {(int)KS_CD,\t\"\\033[J\"},\n    {(int)KS_CCO,\t\"8\"},\t\t\t// allow 8 colors\n    {(int)KS_ME,\t\"\\033[0m\"},\n    {(int)KS_MR,\t\"\\033[7m\"},\n    {(int)KS_MD,\t\"\\033[1m\"},  // bold mode\n    {(int)KS_SE,\t\"\\033[22m\"},// normal mode\n    {(int)KS_UE,\t\"\\033[24m\"},// exit underscore mode\n    {(int)KS_US,\t\"\\033[4m\"},  // underscore mode\n    {(int)KS_CZH,\t\"\\033[34;43m\"},  // italic mode: blue text on yellow\n    {(int)KS_CZR,\t\"\\033[0m\"},\t    // italic mode end\n    {(int)KS_CAB,\t\"\\033[4%dm\"},\t    // set background color (ANSI)\n    {(int)KS_CAF,\t\"\\033[3%dm\"},\t    // set foreground color (ANSI)\n    {(int)KS_CSB,\t\"\\033[102;%dm\"},\t// set screen background color\n    {(int)KS_CSF,\t\"\\033[101;%dm\"},\t// set screen foreground color\n    {(int)KS_MS,\t\"y\"},\n    {(int)KS_UT,\t\"y\"},\n    {(int)KS_XN,\t\"y\"},\n    {(int)KS_LE,\t\"\\b\"},\n#  ifdef TERMINFO\n    {(int)KS_CM,\t\"\\033[%i%p1%d;%p2%dH\"},\n#  else\n    {(int)KS_CM,\t\"\\033[%i%d;%dH\"},\n#  endif\n#  ifdef TERMINFO\n    {(int)KS_CRI,\t\"\\033[%p1%dC\"},\n#  else\n    {(int)KS_CRI,\t\"\\033[%dC\"},\n#  endif\n    {K_UP,\t\t\"\\033[A\"},\n    {K_DOWN,\t\t\"\\033[B\"},\n    {K_RIGHT,\t\t\"\\033[C\"},\n    {K_LEFT,\t\t\"\\033[D\"},\n    // Note: cursor key sequences for application cursor mode are omitted,\n    // because they interfere with typed commands: <Esc>OA.\n    {K_F1,\t\t\"\\033[11~\"},\n    {K_F2,\t\t\"\\033[12~\"},\n    {K_F3,\t\t\"\\033[13~\"},\n    {K_F4,\t\t\"\\033[14~\"},\n    {K_F5,\t\t\"\\033[15~\"},\n    {K_F6,\t\t\"\\033[17~\"},\n    {K_F7,\t\t\"\\033[18~\"},\n    {K_F8,\t\t\"\\033[19~\"},\n    {K_F9,\t\t\"\\033[20~\"},\n    {K_F10,\t\t\"\\033[21~\"},\n    {K_F11,\t\t\"\\033[23~\"},\n    {K_F12,\t\t\"\\033[24~\"},\n    {K_F13,\t\t\"\\033[25~\"},\n    {K_F14,\t\t\"\\033[26~\"},\n    {K_F15,\t\t\"\\033[28~\"},\t// Help\n    {K_F16,\t\t\"\\033[29~\"},\t// Select\n    {K_F17,\t\t\"\\033[31~\"},\n    {K_F18,\t\t\"\\033[32~\"},\n    {K_F19,\t\t\"\\033[33~\"},\n    {K_F20,\t\t\"\\033[34~\"},\n    {K_INS,\t\t\"\\033[2~\"},\n    {K_DEL,\t\t\"\\033[3~\"},\n    {K_HOME,\t\t\"\\033[1~\"},\n    {K_END,\t\t\"\\033[4~\"},\n    {K_PAGEUP,\t\t\"\\033[5~\"},\n    {K_PAGEDOWN,\t\"\\033[6~\"},\n    // These sequences starting with <Esc> O may interfere with what the user\n    // is typing.  Remove these if that bothers you.\n    {K_KPLUS,\t\t\"\\033Ok\"},\t// keypad plus\n    {K_KMINUS,\t\t\"\\033Om\"},\t// keypad minus\n    {K_KDIVIDE,\t\t\"\\033Oo\"},\t// keypad /\n    {K_KMULTIPLY,\t\"\\033Oj\"},\t// keypad *\n    {K_KENTER,\t\t\"\\033OM\"},\t// keypad Enter\n    {K_K0,\t\t\"\\033Op\"},\t// keypad 0\n    {K_K1,\t\t\"\\033Oq\"},\t// keypad 1\n    {K_K2,\t\t\"\\033Or\"},\t// keypad 2\n    {K_K3,\t\t\"\\033Os\"},\t// keypad 3\n    {K_K4,\t\t\"\\033Ot\"},\t// keypad 4\n    {K_K5,\t\t\"\\033Ou\"},\t// keypad 5\n    {K_K6,\t\t\"\\033Ov\"},\t// keypad 6\n    {K_K7,\t\t\"\\033Ow\"},\t// keypad 7\n    {K_K8,\t\t\"\\033Ox\"},\t// keypad 8\n    {K_K9,\t\t\"\\033Oy\"},\t// keypad 9\n    {K_BS,\t\t\"\\x7f\"},\t// for some reason 0177 doesn't work\n# endif\n\n# if defined(ALL_BUILTIN_TCAPS)\n/*\n * Ordinary vt52\n */\n    {(int)KS_NAME,\t\"vt52\"},\n    {(int)KS_CE,\t\"\\033K\"},\n    {(int)KS_CD,\t\"\\033J\"},\n#  ifdef TERMINFO\n    {(int)KS_CM,\t\"\\033Y%p1%' '%+%c%p2%' '%+%c\"},\n#  else\n    {(int)KS_CM,\t\"\\033Y%+ %+ \"},\n#  endif\n    {(int)KS_LE,\t\"\\b\"},\n    {(int)KS_SR,\t\"\\033I\"},\n    {(int)KS_AL,\t\"\\033L\"},\n    {(int)KS_DL,\t\"\\033M\"},\n    {K_UP,\t\t\"\\033A\"},\n    {K_DOWN,\t\t\"\\033B\"},\n    {K_LEFT,\t\t\"\\033D\"},\n    {K_RIGHT,\t\t\"\\033C\"},\n    {K_F1,\t\t\"\\033P\"},\n    {K_F2,\t\t\"\\033Q\"},\n    {K_F3,\t\t\"\\033R\"},\n    {(int)KS_CL,\t\"\\033H\\033J\"},\n    {(int)KS_MS,\t\"y\"},\n# endif\n\n# if defined(UNIX) || defined(ALL_BUILTIN_TCAPS) || defined(SOME_BUILTIN_TCAPS)\n    {(int)KS_NAME,\t\"xterm\"},\n    {(int)KS_CE,\t\"\\033[K\"},\n    {(int)KS_AL,\t\"\\033[L\"},\n#  ifdef TERMINFO\n    {(int)KS_CAL,\t\"\\033[%p1%dL\"},\n#  else\n    {(int)KS_CAL,\t\"\\033[%dL\"},\n#  endif\n    {(int)KS_DL,\t\"\\033[M\"},\n#  ifdef TERMINFO\n    {(int)KS_CDL,\t\"\\033[%p1%dM\"},\n#  else\n    {(int)KS_CDL,\t\"\\033[%dM\"},\n#  endif\n#  ifdef TERMINFO\n    {(int)KS_CS,\t\"\\033[%i%p1%d;%p2%dr\"},\n#  else\n    {(int)KS_CS,\t\"\\033[%i%d;%dr\"},\n#  endif\n    {(int)KS_CL,\t\"\\033[H\\033[2J\"},\n    {(int)KS_CD,\t\"\\033[J\"},\n    {(int)KS_ME,\t\"\\033[m\"},\n    {(int)KS_MR,\t\"\\033[7m\"},\n    {(int)KS_MD,\t\"\\033[1m\"},\n    {(int)KS_UE,\t\"\\033[m\"},\n    {(int)KS_US,\t\"\\033[4m\"},\n    {(int)KS_STE,\t\"\\033[29m\"},\n    {(int)KS_STS,\t\"\\033[9m\"},\n    {(int)KS_MS,\t\"y\"},\n    {(int)KS_UT,\t\"y\"},\n    {(int)KS_LE,\t\"\\b\"},\n    {(int)KS_VI,\t\"\\033[?25l\"},\n    {(int)KS_VE,\t\"\\033[?25h\"},\n    {(int)KS_VS,\t\"\\033[?12h\"},\n    {(int)KS_CVS,\t\"\\033[?12l\"},\n#  ifdef TERMINFO\n    {(int)KS_CSH,\t\"\\033[%p1%d q\"},\n#  else\n    {(int)KS_CSH,\t\"\\033[%d q\"},\n#  endif\n    {(int)KS_CRC,\t\"\\033[?12$p\"},\n    {(int)KS_CRS,\t\"\\033P$q q\\033\\\\\"},\n#  ifdef TERMINFO\n    {(int)KS_CM,\t\"\\033[%i%p1%d;%p2%dH\"},\n#  else\n    {(int)KS_CM,\t\"\\033[%i%d;%dH\"},\n#  endif\n    {(int)KS_SR,\t\"\\033M\"},\n#  ifdef TERMINFO\n    {(int)KS_CRI,\t\"\\033[%p1%dC\"},\n#  else\n    {(int)KS_CRI,\t\"\\033[%dC\"},\n#  endif\n    {(int)KS_KS,\t\"\\033[?1h\\033=\"},\n    {(int)KS_KE,\t\"\\033[?1l\\033>\"},\n#  ifdef FEAT_XTERM_SAVE\n    {(int)KS_TI,\t\"\\0337\\033[?47h\"},\n    {(int)KS_TE,\t\"\\033[?47l\\0338\"},\n#  endif\n    {(int)KS_CTI,\t\"\\033[>4;2m\"},\n    {(int)KS_CTE,\t\"\\033[>4;m\"},\n    {(int)KS_CIS,\t\"\\033]1;\"},\n    {(int)KS_CIE,\t\"\\007\"},\n    {(int)KS_TS,\t\"\\033]2;\"},\n    {(int)KS_FS,\t\"\\007\"},\n    {(int)KS_CSC,\t\"\\033]12;\"},\n    {(int)KS_CEC,\t\"\\007\"},\n#  ifdef TERMINFO\n    {(int)KS_CWS,\t\"\\033[8;%p1%d;%p2%dt\"},\n    {(int)KS_CWP,\t\"\\033[3;%p1%d;%p2%dt\"},\n    {(int)KS_CGP,\t\"\\033[13t\"},\n#  else\n    {(int)KS_CWS,\t\"\\033[8;%d;%dt\"},\n    {(int)KS_CWP,\t\"\\033[3;%d;%dt\"},\n    {(int)KS_CGP,\t\"\\033[13t\"},\n#  endif\n    {(int)KS_CRV,\t\"\\033[>c\"},\n    {(int)KS_RFG,\t\"\\033]10;?\\007\"},\n    {(int)KS_RBG,\t\"\\033]11;?\\007\"},\n    {(int)KS_U7,\t\"\\033[6n\"},\n#  ifdef FEAT_TERMGUICOLORS\n    // These are printf strings, not terminal codes.\n    {(int)KS_8F,\t\"\\033[38;2;%lu;%lu;%lum\"},\n    {(int)KS_8B,\t\"\\033[48;2;%lu;%lu;%lum\"},\n    {(int)KS_8U,\t\"\\033[58;2;%lu;%lu;%lum\"},\n#  endif\n    {(int)KS_CAU,\t\"\\033[58;5;%dm\"},\n    {(int)KS_CBE,\t\"\\033[?2004h\"},\n    {(int)KS_CBD,\t\"\\033[?2004l\"},\n    {(int)KS_CST,\t\"\\033[22;2t\"},\n    {(int)KS_CRT,\t\"\\033[23;2t\"},\n    {(int)KS_SSI,\t\"\\033[22;1t\"},\n    {(int)KS_SRI,\t\"\\033[23;1t\"},\n#  if (defined(UNIX) || defined(VMS))\n    {(int)KS_FD,\t\"\\033[?1004l\"},\n    {(int)KS_FE,\t\"\\033[?1004h\"},\n#  endif\n\n    {K_UP,\t\t\"\\033O*A\"},\n    {K_DOWN,\t\t\"\\033O*B\"},\n    {K_RIGHT,\t\t\"\\033O*C\"},\n    {K_LEFT,\t\t\"\\033O*D\"},\n    // An extra set of cursor keys for vt100 mode\n    {K_XUP,\t\t\"\\033[@;*A\"},\n    {K_XDOWN,\t\t\"\\033[@;*B\"},\n    {K_XRIGHT,\t\t\"\\033[@;*C\"},\n    {K_XLEFT,\t\t\"\\033[@;*D\"},\n    // An extra set of function keys for vt100 mode\n    {K_XF1,\t\t\"\\033O*P\"},\n    {K_XF2,\t\t\"\\033O*Q\"},\n    {K_XF3,\t\t\"\\033O*R\"},\n    {K_XF4,\t\t\"\\033O*S\"},\n    {K_F1,\t\t\"\\033[11;*~\"},\n    {K_F2,\t\t\"\\033[12;*~\"},\n    {K_F3,\t\t\"\\033[13;*~\"},\n    {K_F4,\t\t\"\\033[14;*~\"},\n    {K_F5,\t\t\"\\033[15;*~\"},\n    {K_F6,\t\t\"\\033[17;*~\"},\n    {K_F7,\t\t\"\\033[18;*~\"},\n    {K_F8,\t\t\"\\033[19;*~\"},\n    {K_F9,\t\t\"\\033[20;*~\"},\n    {K_F10,\t\t\"\\033[21;*~\"},\n    {K_F11,\t\t\"\\033[23;*~\"},\n    {K_F12,\t\t\"\\033[24;*~\"},\n    {K_S_TAB,\t\t\"\\033[Z\"},\n    {K_HELP,\t\t\"\\033[28;*~\"},\n    {K_UNDO,\t\t\"\\033[26;*~\"},\n    {K_INS,\t\t\"\\033[2;*~\"},\n    {K_HOME,\t\t\"\\033[1;*H\"},\n    // {K_S_HOME,\t\t\"\\033O2H\"},\n    // {K_C_HOME,\t\t\"\\033O5H\"},\n    {K_KHOME,\t\t\"\\033[1;*~\"},\n    {K_XHOME,\t\t\"\\033O*H\"},\t// other Home\n    {K_ZHOME,\t\t\"\\033[7;*~\"},\t// other Home\n    {K_END,\t\t\"\\033[1;*F\"},\n    // {K_S_END,\t\t\"\\033O2F\"},\n    // {K_C_END,\t\t\"\\033O5F\"},\n    {K_KEND,\t\t\"\\033[4;*~\"},\n    {K_XEND,\t\t\"\\033O*F\"},\t// other End\n    {K_ZEND,\t\t\"\\033[8;*~\"},\n    {K_PAGEUP,\t\t\"\\033[5;*~\"},\n    {K_PAGEDOWN,\t\"\\033[6;*~\"},\n    {K_KPLUS,\t\t\"\\033O*k\"},     // keypad plus\n    {K_KMINUS,\t\t\"\\033O*m\"},     // keypad minus\n    {K_KDIVIDE,\t\t\"\\033O*o\"},     // keypad /\n    {K_KMULTIPLY,\t\"\\033O*j\"},     // keypad *\n    {K_KENTER,\t\t\"\\033O*M\"},     // keypad Enter\n    {K_KPOINT,\t\t\"\\033O*n\"},     // keypad .\n    {K_K0,\t\t\"\\033O*p\"},     // keypad 0\n    {K_K1,\t\t\"\\033O*q\"},     // keypad 1\n    {K_K2,\t\t\"\\033O*r\"},     // keypad 2\n    {K_K3,\t\t\"\\033O*s\"},     // keypad 3\n    {K_K4,\t\t\"\\033O*t\"},     // keypad 4\n    {K_K5,\t\t\"\\033O*u\"},     // keypad 5\n    {K_K6,\t\t\"\\033O*v\"},     // keypad 6\n    {K_K7,\t\t\"\\033O*w\"},     // keypad 7\n    {K_K8,\t\t\"\\033O*x\"},     // keypad 8\n    {K_K9,\t\t\"\\033O*y\"},     // keypad 9\n    {K_KDEL,\t\t\"\\033[3;*~\"}, // keypad Del\n    {K_PS,\t\t\"\\033[200~\"}, // paste start\n    {K_PE,\t\t\"\\033[201~\"}, // paste end\n\n    {BT_EXTRA_KEYS,   \"\"},\n    {TERMCAP2KEY('k', '0'), \"\\033[10;*~\"}, // F0\n    {TERMCAP2KEY('F', '3'), \"\\033[25;*~\"}, // F13\n    // F14 and F15 are missing, because they send the same codes as the undo\n    // and help key, although they don't work on all keyboards.\n    {TERMCAP2KEY('F', '6'), \"\\033[29;*~\"}, // F16\n    {TERMCAP2KEY('F', '7'), \"\\033[31;*~\"}, // F17\n    {TERMCAP2KEY('F', '8'), \"\\033[32;*~\"}, // F18\n    {TERMCAP2KEY('F', '9'), \"\\033[33;*~\"}, // F19\n    {TERMCAP2KEY('F', 'A'), \"\\033[34;*~\"}, // F20\n\n    {TERMCAP2KEY('F', 'B'), \"\\033[42;*~\"}, // F21\n    {TERMCAP2KEY('F', 'C'), \"\\033[43;*~\"}, // F22\n    {TERMCAP2KEY('F', 'D'), \"\\033[44;*~\"}, // F23\n    {TERMCAP2KEY('F', 'E'), \"\\033[45;*~\"}, // F24\n    {TERMCAP2KEY('F', 'F'), \"\\033[46;*~\"}, // F25\n    {TERMCAP2KEY('F', 'G'), \"\\033[47;*~\"}, // F26\n    {TERMCAP2KEY('F', 'H'), \"\\033[48;*~\"}, // F27\n    {TERMCAP2KEY('F', 'I'), \"\\033[49;*~\"}, // F28\n    {TERMCAP2KEY('F', 'J'), \"\\033[50;*~\"}, // F29\n    {TERMCAP2KEY('F', 'K'), \"\\033[51;*~\"}, // F30\n\n    {TERMCAP2KEY('F', 'L'), \"\\033[52;*~\"}, // F31\n    {TERMCAP2KEY('F', 'M'), \"\\033[53;*~\"}, // F32\n    {TERMCAP2KEY('F', 'N'), \"\\033[54;*~\"}, // F33\n    {TERMCAP2KEY('F', 'O'), \"\\033[55;*~\"}, // F34\n    {TERMCAP2KEY('F', 'P'), \"\\033[56;*~\"}, // F35\n    {TERMCAP2KEY('F', 'Q'), \"\\033[57;*~\"}, // F36\n    {TERMCAP2KEY('F', 'R'), \"\\033[58;*~\"}, // F37\n# endif\n\n# if defined(UNIX) || defined(ALL_BUILTIN_TCAPS)\n/*\n * iris-ansi for Silicon Graphics machines.\n */\n    {(int)KS_NAME,\t\"iris-ansi\"},\n    {(int)KS_CE,\t\"\\033[K\"},\n    {(int)KS_CD,\t\"\\033[J\"},\n    {(int)KS_AL,\t\"\\033[L\"},\n#  ifdef TERMINFO\n    {(int)KS_CAL,\t\"\\033[%p1%dL\"},\n#  else\n    {(int)KS_CAL,\t\"\\033[%dL\"},\n#  endif\n    {(int)KS_DL,\t\"\\033[M\"},\n#  ifdef TERMINFO\n    {(int)KS_CDL,\t\"\\033[%p1%dM\"},\n#  else\n    {(int)KS_CDL,\t\"\\033[%dM\"},\n#  endif\n#if 0\t// The scroll region is not working as Vim expects.\n#  ifdef TERMINFO\n    {(int)KS_CS,\t\"\\033[%i%p1%d;%p2%dr\"},\n#  else\n    {(int)KS_CS,\t\"\\033[%i%d;%dr\"},\n#  endif\n#endif\n    {(int)KS_CL,\t\"\\033[H\\033[2J\"},\n    {(int)KS_VE,\t\"\\033[9/y\\033[12/y\"},\t// These aren't documented\n    {(int)KS_VS,\t\"\\033[10/y\\033[=1h\\033[=2l\"}, // These aren't documented\n    {(int)KS_TI,\t\"\\033[=6h\"},\n    {(int)KS_TE,\t\"\\033[=6l\"},\n    {(int)KS_SE,\t\"\\033[21;27m\"},\n    {(int)KS_SO,\t\"\\033[1;7m\"},\n    {(int)KS_ME,\t\"\\033[m\"},\n    {(int)KS_MR,\t\"\\033[7m\"},\n    {(int)KS_MD,\t\"\\033[1m\"},\n    {(int)KS_CCO,\t\"8\"},\t\t\t// allow 8 colors\n    {(int)KS_CZH,\t\"\\033[3m\"},\t\t// italic mode on\n    {(int)KS_CZR,\t\"\\033[23m\"},\t\t// italic mode off\n    {(int)KS_US,\t\"\\033[4m\"},\t\t// underline on\n    {(int)KS_UE,\t\"\\033[24m\"},\t\t// underline off\n#  ifdef TERMINFO\n    {(int)KS_CAB,\t\"\\033[4%p1%dm\"},    // set background color (ANSI)\n    {(int)KS_CAF,\t\"\\033[3%p1%dm\"},    // set foreground color (ANSI)\n    {(int)KS_CSB,\t\"\\033[102;%p1%dm\"}, // set screen background color\n    {(int)KS_CSF,\t\"\\033[101;%p1%dm\"}, // set screen foreground color\n#  else\n    {(int)KS_CAB,\t\"\\033[4%dm\"},\t    // set background color (ANSI)\n    {(int)KS_CAF,\t\"\\033[3%dm\"},\t    // set foreground color (ANSI)\n    {(int)KS_CSB,\t\"\\033[102;%dm\"},    // set screen background color\n    {(int)KS_CSF,\t\"\\033[101;%dm\"},    // set screen foreground color\n#  endif\n    {(int)KS_MS,\t\"y\"},\t\t// guessed\n    {(int)KS_UT,\t\"y\"},\t\t// guessed\n    {(int)KS_LE,\t\"\\b\"},\n#  ifdef TERMINFO\n    {(int)KS_CM,\t\"\\033[%i%p1%d;%p2%dH\"},\n#  else\n    {(int)KS_CM,\t\"\\033[%i%d;%dH\"},\n#  endif\n    {(int)KS_SR,\t\"\\033M\"},\n#  ifdef TERMINFO\n    {(int)KS_CRI,\t\"\\033[%p1%dC\"},\n#  else\n    {(int)KS_CRI,\t\"\\033[%dC\"},\n#  endif\n    {(int)KS_CIS,\t\"\\033P3.y\"},\n    {(int)KS_CIE,\t\"\\234\"},    // ST \"String Terminator\"\n    {(int)KS_TS,\t\"\\033P1.y\"},\n    {(int)KS_FS,\t\"\\234\"},    // ST \"String Terminator\"\n#  ifdef TERMINFO\n    {(int)KS_CWS,\t\"\\033[203;%p1%d;%p2%d/y\"},\n    {(int)KS_CWP,\t\"\\033[205;%p1%d;%p2%d/y\"},\n#  else\n    {(int)KS_CWS,\t\"\\033[203;%d;%d/y\"},\n    {(int)KS_CWP,\t\"\\033[205;%d;%d/y\"},\n#  endif\n    {K_UP,\t\t\"\\033[A\"},\n    {K_DOWN,\t\t\"\\033[B\"},\n    {K_LEFT,\t\t\"\\033[D\"},\n    {K_RIGHT,\t\t\"\\033[C\"},\n    {K_S_UP,\t\t\"\\033[161q\"},\n    {K_S_DOWN,\t\t\"\\033[164q\"},\n    {K_S_LEFT,\t\t\"\\033[158q\"},\n    {K_S_RIGHT,\t\t\"\\033[167q\"},\n    {K_F1,\t\t\"\\033[001q\"},\n    {K_F2,\t\t\"\\033[002q\"},\n    {K_F3,\t\t\"\\033[003q\"},\n    {K_F4,\t\t\"\\033[004q\"},\n    {K_F5,\t\t\"\\033[005q\"},\n    {K_F6,\t\t\"\\033[006q\"},\n    {K_F7,\t\t\"\\033[007q\"},\n    {K_F8,\t\t\"\\033[008q\"},\n    {K_F9,\t\t\"\\033[009q\"},\n    {K_F10,\t\t\"\\033[010q\"},\n    {K_F11,\t\t\"\\033[011q\"},\n    {K_F12,\t\t\"\\033[012q\"},\n    {K_S_F1,\t\t\"\\033[013q\"},\n    {K_S_F2,\t\t\"\\033[014q\"},\n    {K_S_F3,\t\t\"\\033[015q\"},\n    {K_S_F4,\t\t\"\\033[016q\"},\n    {K_S_F5,\t\t\"\\033[017q\"},\n    {K_S_F6,\t\t\"\\033[018q\"},\n    {K_S_F7,\t\t\"\\033[019q\"},\n    {K_S_F8,\t\t\"\\033[020q\"},\n    {K_S_F9,\t\t\"\\033[021q\"},\n    {K_S_F10,\t\t\"\\033[022q\"},\n    {K_S_F11,\t\t\"\\033[023q\"},\n    {K_S_F12,\t\t\"\\033[024q\"},\n    {K_INS,\t\t\"\\033[139q\"},\n    {K_HOME,\t\t\"\\033[H\"},\n    {K_END,\t\t\"\\033[146q\"},\n    {K_PAGEUP,\t\t\"\\033[150q\"},\n    {K_PAGEDOWN,\t\"\\033[154q\"},\n# endif\n\n# if defined(DEBUG) || defined(ALL_BUILTIN_TCAPS)\n/*\n * for debugging\n */\n    {(int)KS_NAME,\t\"debug\"},\n    {(int)KS_CE,\t\"[CE]\"},\n    {(int)KS_CD,\t\"[CD]\"},\n    {(int)KS_AL,\t\"[AL]\"},\n#  ifdef TERMINFO\n    {(int)KS_CAL,\t\"[CAL%p1%d]\"},\n#  else\n    {(int)KS_CAL,\t\"[CAL%d]\"},\n#  endif\n    {(int)KS_DL,\t\"[DL]\"},\n#  ifdef TERMINFO\n    {(int)KS_CDL,\t\"[CDL%p1%d]\"},\n#  else\n    {(int)KS_CDL,\t\"[CDL%d]\"},\n#  endif\n#  ifdef TERMINFO\n    {(int)KS_CS,\t\"[%p1%dCS%p2%d]\"},\n#  else\n    {(int)KS_CS,\t\"[%dCS%d]\"},\n#  endif\n#  ifdef TERMINFO\n    {(int)KS_CSV,\t\"[%p1%dCSV%p2%d]\"},\n#  else\n    {(int)KS_CSV,\t\"[%dCSV%d]\"},\n#  endif\n#  ifdef TERMINFO\n    {(int)KS_CAB,\t\"[CAB%p1%d]\"},\n    {(int)KS_CAF,\t\"[CAF%p1%d]\"},\n    {(int)KS_CSB,\t\"[CSB%p1%d]\"},\n    {(int)KS_CSF,\t\"[CSF%p1%d]\"},\n#  else\n    {(int)KS_CAB,\t\"[CAB%d]\"},\n    {(int)KS_CAF,\t\"[CAF%d]\"},\n    {(int)KS_CSB,\t\"[CSB%d]\"},\n    {(int)KS_CSF,\t\"[CSF%d]\"},\n#  endif\n    {(int)KS_CAU,\t\"[CAU%d]\"},\n    {(int)KS_OP,\t\"[OP]\"},\n    {(int)KS_LE,\t\"[LE]\"},\n    {(int)KS_CL,\t\"[CL]\"},\n    {(int)KS_VI,\t\"[VI]\"},\n    {(int)KS_VE,\t\"[VE]\"},\n    {(int)KS_VS,\t\"[VS]\"},\n    {(int)KS_ME,\t\"[ME]\"},\n    {(int)KS_MR,\t\"[MR]\"},\n    {(int)KS_MB,\t\"[MB]\"},\n    {(int)KS_MD,\t\"[MD]\"},\n    {(int)KS_SE,\t\"[SE]\"},\n    {(int)KS_SO,\t\"[SO]\"},\n    {(int)KS_UE,\t\"[UE]\"},\n    {(int)KS_US,\t\"[US]\"},\n    {(int)KS_UCE,\t\"[UCE]\"},\n    {(int)KS_UCS,\t\"[UCS]\"},\n    {(int)KS_STE,\t\"[STE]\"},\n    {(int)KS_STS,\t\"[STS]\"},\n    {(int)KS_MS,\t\"[MS]\"},\n    {(int)KS_UT,\t\"[UT]\"},\n    {(int)KS_XN,\t\"[XN]\"},\n#  ifdef TERMINFO\n    {(int)KS_CM,\t\"[%p1%dCM%p2%d]\"},\n#  else\n    {(int)KS_CM,\t\"[%dCM%d]\"},\n#  endif\n    {(int)KS_SR,\t\"[SR]\"},\n#  ifdef TERMINFO\n    {(int)KS_CRI,\t\"[CRI%p1%d]\"},\n#  else\n    {(int)KS_CRI,\t\"[CRI%d]\"},\n#  endif\n    {(int)KS_VB,\t\"[VB]\"},\n    {(int)KS_KS,\t\"[KS]\"},\n    {(int)KS_KE,\t\"[KE]\"},\n    {(int)KS_TI,\t\"[TI]\"},\n    {(int)KS_TE,\t\"[TE]\"},\n    {(int)KS_CIS,\t\"[CIS]\"},\n    {(int)KS_CIE,\t\"[CIE]\"},\n    {(int)KS_CSC,\t\"[CSC]\"},\n    {(int)KS_CEC,\t\"[CEC]\"},\n    {(int)KS_TS,\t\"[TS]\"},\n    {(int)KS_FS,\t\"[FS]\"},\n#  ifdef TERMINFO\n    {(int)KS_CWS,\t\"[%p1%dCWS%p2%d]\"},\n    {(int)KS_CWP,\t\"[%p1%dCWP%p2%d]\"},\n#  else\n    {(int)KS_CWS,\t\"[%dCWS%d]\"},\n    {(int)KS_CWP,\t\"[%dCWP%d]\"},\n#  endif\n    {(int)KS_CRV,\t\"[CRV]\"},\n    {(int)KS_U7,\t\"[U7]\"},\n    {(int)KS_RFG,\t\"[RFG]\"},\n    {(int)KS_RBG,\t\"[RBG]\"},\n    {K_UP,\t\t\"[KU]\"},\n    {K_DOWN,\t\t\"[KD]\"},\n    {K_LEFT,\t\t\"[KL]\"},\n    {K_RIGHT,\t\t\"[KR]\"},\n    {K_XUP,\t\t\"[xKU]\"},\n    {K_XDOWN,\t\t\"[xKD]\"},\n    {K_XLEFT,\t\t\"[xKL]\"},\n    {K_XRIGHT,\t\t\"[xKR]\"},\n    {K_S_UP,\t\t\"[S-KU]\"},\n    {K_S_DOWN,\t\t\"[S-KD]\"},\n    {K_S_LEFT,\t\t\"[S-KL]\"},\n    {K_C_LEFT,\t\t\"[C-KL]\"},\n    {K_S_RIGHT,\t\t\"[S-KR]\"},\n    {K_C_RIGHT,\t\t\"[C-KR]\"},\n    {K_F1,\t\t\"[F1]\"},\n    {K_XF1,\t\t\"[xF1]\"},\n    {K_F2,\t\t\"[F2]\"},\n    {K_XF2,\t\t\"[xF2]\"},\n    {K_F3,\t\t\"[F3]\"},\n    {K_XF3,\t\t\"[xF3]\"},\n    {K_F4,\t\t\"[F4]\"},\n    {K_XF4,\t\t\"[xF4]\"},\n    {K_F5,\t\t\"[F5]\"},\n    {K_F6,\t\t\"[F6]\"},\n    {K_F7,\t\t\"[F7]\"},\n    {K_F8,\t\t\"[F8]\"},\n    {K_F9,\t\t\"[F9]\"},\n    {K_F10,\t\t\"[F10]\"},\n    {K_F11,\t\t\"[F11]\"},\n    {K_F12,\t\t\"[F12]\"},\n    {K_S_F1,\t\t\"[S-F1]\"},\n    {K_S_XF1,\t\t\"[S-xF1]\"},\n    {K_S_F2,\t\t\"[S-F2]\"},\n    {K_S_XF2,\t\t\"[S-xF2]\"},\n    {K_S_F3,\t\t\"[S-F3]\"},\n    {K_S_XF3,\t\t\"[S-xF3]\"},\n    {K_S_F4,\t\t\"[S-F4]\"},\n    {K_S_XF4,\t\t\"[S-xF4]\"},\n    {K_S_F5,\t\t\"[S-F5]\"},\n    {K_S_F6,\t\t\"[S-F6]\"},\n    {K_S_F7,\t\t\"[S-F7]\"},\n    {K_S_F8,\t\t\"[S-F8]\"},\n    {K_S_F9,\t\t\"[S-F9]\"},\n    {K_S_F10,\t\t\"[S-F10]\"},\n    {K_S_F11,\t\t\"[S-F11]\"},\n    {K_S_F12,\t\t\"[S-F12]\"},\n    {K_HELP,\t\t\"[HELP]\"},\n    {K_UNDO,\t\t\"[UNDO]\"},\n    {K_BS,\t\t\"[BS]\"},\n    {K_INS,\t\t\"[INS]\"},\n    {K_KINS,\t\t\"[KINS]\"},\n    {K_DEL,\t\t\"[DEL]\"},\n    {K_KDEL,\t\t\"[KDEL]\"},\n    {K_HOME,\t\t\"[HOME]\"},\n    {K_S_HOME,\t\t\"[C-HOME]\"},\n    {K_C_HOME,\t\t\"[C-HOME]\"},\n    {K_KHOME,\t\t\"[KHOME]\"},\n    {K_XHOME,\t\t\"[XHOME]\"},\n    {K_ZHOME,\t\t\"[ZHOME]\"},\n    {K_END,\t\t\"[END]\"},\n    {K_S_END,\t\t\"[C-END]\"},\n    {K_C_END,\t\t\"[C-END]\"},\n    {K_KEND,\t\t\"[KEND]\"},\n    {K_XEND,\t\t\"[XEND]\"},\n    {K_ZEND,\t\t\"[ZEND]\"},\n    {K_PAGEUP,\t\t\"[PAGEUP]\"},\n    {K_PAGEDOWN,\t\"[PAGEDOWN]\"},\n    {K_KPAGEUP,\t\t\"[KPAGEUP]\"},\n    {K_KPAGEDOWN,\t\"[KPAGEDOWN]\"},\n    {K_MOUSE,\t\t\"[MOUSE]\"},\n    {K_KPLUS,\t\t\"[KPLUS]\"},\n    {K_KMINUS,\t\t\"[KMINUS]\"},\n    {K_KDIVIDE,\t\t\"[KDIVIDE]\"},\n    {K_KMULTIPLY,\t\"[KMULTIPLY]\"},\n    {K_KENTER,\t\t\"[KENTER]\"},\n    {K_KPOINT,\t\t\"[KPOINT]\"},\n    {K_PS,\t\t\"[PASTE-START]\"},\n    {K_PE,\t\t\"[PASTE-END]\"},\n    {K_K0,\t\t\"[K0]\"},\n    {K_K1,\t\t\"[K1]\"},\n    {K_K2,\t\t\"[K2]\"},\n    {K_K3,\t\t\"[K3]\"},\n    {K_K4,\t\t\"[K4]\"},\n    {K_K5,\t\t\"[K5]\"},\n    {K_K6,\t\t\"[K6]\"},\n    {K_K7,\t\t\"[K7]\"},\n    {K_K8,\t\t\"[K8]\"},\n    {K_K9,\t\t\"[K9]\"},\n# endif\n\n#endif // NO_BUILTIN_TCAPS\n\n/*\n * The most minimal terminal: only clear screen and cursor positioning\n * Always included.\n */\n    {(int)KS_NAME,\t\"dumb\"},\n    {(int)KS_CL,\t\"\\014\"},\n#ifdef TERMINFO\n    {(int)KS_CM,\t\"\\033[%i%p1%d;%p2%dH\"},\n#else\n    {(int)KS_CM,\t\"\\033[%i%d;%dH\"},\n#endif\n\n/*\n * end marker\n */\n    {(int)KS_NAME,\tNULL}\n\n};\t// end of builtin_termcaps\n\n#if defined(FEAT_TERMGUICOLORS) || defined(PROTO)\n    static guicolor_T\ntermgui_mch_get_color(char_u *name)\n{\n    return gui_get_color_cmn(name);\n}\n\n    guicolor_T\ntermgui_get_color(char_u *name)\n{\n    guicolor_T\tt;\n\n    if (*name == NUL)\n\treturn INVALCOLOR;\n    t = termgui_mch_get_color(name);\n\n    if (t == INVALCOLOR)\n\tsemsg(_(e_cannot_allocate_color_str), name);\n    return t;\n}\n\n    guicolor_T\ntermgui_mch_get_rgb(guicolor_T color)\n{\n    return color;\n}\n#endif\n\n/*\n * DEFAULT_TERM is used, when no terminal is specified with -T option or $TERM.\n */\n#ifdef AMIGA\n# define DEFAULT_TERM\t(char_u *)\"amiga\"\n#endif\n\n#ifdef MSWIN\n# define DEFAULT_TERM\t(char_u *)\"win32\"\n#endif\n\n#if defined(UNIX)\n# define DEFAULT_TERM\t(char_u *)\"ansi\"\n#endif\n\n#ifdef VMS\n# define DEFAULT_TERM\t(char_u *)\"vt320\"\n#endif\n\n#ifdef __HAIKU__\n# undef DEFAULT_TERM\n# define DEFAULT_TERM\t(char_u *)\"xterm\"\n#endif\n\n#ifndef DEFAULT_TERM\n# define DEFAULT_TERM\t(char_u *)\"dumb\"\n#endif\n\n/*\n * Term_strings contains currently used terminal output strings.\n * It is initialized with the default values by parse_builtin_tcap().\n * The values can be changed by setting the option with the same name.\n */\nchar_u *(term_strings[(int)KS_LAST + 1]);\n\nstatic int\tneed_gather = FALSE;\t    // need to fill termleader[]\nstatic char_u\ttermleader[256 + 1];\t    // for check_termcode()\n#ifdef FEAT_TERMRESPONSE\nstatic int\tcheck_for_codes = FALSE;    // check for key code response\n\n/*\n * Structure and table to store terminal features that can be detected by\n * querying the terminal.  Either by inspecting the termresponse or a more\n * specific request.  Besides this there are:\n * t_colors - number of colors supported\n */\ntypedef struct {\n    char    *tpr_name;\n    int\t    tpr_set_by_termresponse;\n    int\t    tpr_status;\n} termprop_T;\n\n// Values for tpr_status.\n#define TPR_UNKNOWN\t    'u'\n#define TPR_YES\t\t    'y'\n#define TPR_NO\t\t    'n'\n#define TPR_MOUSE_XTERM     'x'\t// use \"xterm\" for 'ttymouse'\n#define TPR_MOUSE_XTERM2    '2'\t// use \"xterm2\" for 'ttymouse'\n#define TPR_MOUSE_SGR\t    's'\t// use \"sgr\" for 'ttymouse'\n\n// can request the cursor style without messing up the display\n#define TPR_CURSOR_STYLE\t    0\n// can request the cursor blink mode without messing up the display\n#define TPR_CURSOR_BLINK\t    1\n// can set the underline color with t_8u without resetting other colors\n#define TPR_UNDERLINE_RGB\t    2\n// mouse support - TPR_MOUSE_XTERM, TPR_MOUSE_XTERM2 or TPR_MOUSE_SGR\n#define TPR_MOUSE\t\t    3\n// table size\n#define TPR_COUNT\t\t    4\n\nstatic termprop_T term_props[TPR_COUNT];\n\n/*\n * Initialize the term_props table.\n * When \"all\" is FALSE only set those that are detected from the version\n * response.\n */\n    void\ninit_term_props(int all)\n{\n    int i;\n\n    term_props[TPR_CURSOR_STYLE].tpr_name = \"cursor_style\";\n    term_props[TPR_CURSOR_STYLE].tpr_set_by_termresponse = FALSE;\n    term_props[TPR_CURSOR_BLINK].tpr_name = \"cursor_blink_mode\";\n    term_props[TPR_CURSOR_BLINK].tpr_set_by_termresponse = FALSE;\n    term_props[TPR_UNDERLINE_RGB].tpr_name = \"underline_rgb\";\n    term_props[TPR_UNDERLINE_RGB].tpr_set_by_termresponse = TRUE;\n    term_props[TPR_MOUSE].tpr_name = \"mouse\";\n    term_props[TPR_MOUSE].tpr_set_by_termresponse = TRUE;\n\n    for (i = 0; i < TPR_COUNT; ++i)\n\tif (all || term_props[i].tpr_set_by_termresponse)\n\t    term_props[i].tpr_status = TPR_UNKNOWN;\n}\n#endif\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n    void\nf_terminalprops(typval_T *argvars UNUSED, typval_T *rettv)\n{\n# ifdef FEAT_TERMRESPONSE\n    int i;\n# endif\n\n    if (rettv_dict_alloc(rettv) == FAIL)\n\treturn;\n# ifdef FEAT_TERMRESPONSE\n    for (i = 0; i < TPR_COUNT; ++i)\n    {\n\tchar_u\tvalue[2];\n\n\tvalue[0] = term_props[i].tpr_status;\n\tvalue[1] = NUL;\n\tdict_add_string(rettv->vval.v_dict, term_props[i].tpr_name, value);\n    }\n# endif\n}\n#endif\n\n    static struct builtin_term *\nfind_builtin_term(char_u *term)\n{\n    struct builtin_term *p;\n\n    p = builtin_termcaps;\n    while (p->bt_string != NULL)\n    {\n\tif (p->bt_entry == (int)KS_NAME)\n\t{\n#ifdef UNIX\n\t    if (STRCMP(p->bt_string, \"iris-ansi\") == 0 && vim_is_iris(term))\n\t\treturn p;\n\t    else if (STRCMP(p->bt_string, \"xterm\") == 0 && vim_is_xterm(term))\n\t\treturn p;\n\t    else\n#endif\n#ifdef VMS\n\t\tif (STRCMP(p->bt_string, \"vt320\") == 0 && vim_is_vt300(term))\n\t\t    return p;\n\t\telse\n#endif\n\t\t  if (STRCMP(term, p->bt_string) == 0)\n\t\t    return p;\n\t}\n\t++p;\n    }\n    return p;\n}\n\n/*\n * Parsing of the builtin termcap entries.\n * Caller should check if 'name' is a valid builtin term.\n * The terminal's name is not set, as this is already done in termcapinit().\n */\n    static void\nparse_builtin_tcap(char_u *term)\n{\n    struct builtin_term\t    *p;\n    char_u\t\t    name[2];\n    int\t\t\t    term_8bit;\n\n    p = find_builtin_term(term);\n    term_8bit = term_is_8bit(term);\n\n    // Do not parse if builtin term not found\n    if (p->bt_string == NULL)\n\treturn;\n\n    for (++p; p->bt_entry != (int)KS_NAME && p->bt_entry != BT_EXTRA_KEYS; ++p)\n    {\n\tif ((int)p->bt_entry >= 0)\t// KS_xx entry\n\t{\n\t    // Only set the value if it wasn't set yet.\n\t    if (term_strings[p->bt_entry] == NULL\n\t\t\t\t || term_strings[p->bt_entry] == empty_option)\n\t    {\n#ifdef FEAT_EVAL\n\t\tint opt_idx = -1;\n#endif\n\t\t// 8bit terminal: use CSI instead of <Esc>[\n\t\tif (term_8bit && term_7to8bit((char_u *)p->bt_string) != 0)\n\t\t{\n\t\t    char_u  *s, *t;\n\n\t\t    s = vim_strsave((char_u *)p->bt_string);\n\t\t    if (s != NULL)\n\t\t    {\n\t\t\tfor (t = s; *t; ++t)\n\t\t\t    if (term_7to8bit(t))\n\t\t\t    {\n\t\t\t\t*t = term_7to8bit(t);\n\t\t\t\tSTRMOVE(t + 1, t + 2);\n\t\t\t    }\n\t\t\tterm_strings[p->bt_entry] = s;\n#ifdef FEAT_EVAL\n\t\t\topt_idx =\n#endif\n\t\t\t\t  set_term_option_alloced(\n\t\t\t\t\t\t   &term_strings[p->bt_entry]);\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    term_strings[p->bt_entry] = (char_u *)p->bt_string;\n#ifdef FEAT_EVAL\n\t\t    opt_idx = get_term_opt_idx(&term_strings[p->bt_entry]);\n#endif\n\t\t}\n#ifdef FEAT_EVAL\n\t\tset_term_option_sctx_idx(NULL, opt_idx);\n#endif\n\t    }\n\t}\n\telse\n\t{\n\t    name[0] = KEY2TERMCAP0((int)p->bt_entry);\n\t    name[1] = KEY2TERMCAP1((int)p->bt_entry);\n\t    if (find_termcode(name) == NULL)\n\t\tadd_termcode(name, (char_u *)p->bt_string, term_8bit);\n\t}\n    }\n}\n\n/*\n * Set number of colors.\n * Store it as a number in t_colors.\n * Store it as a string in T_CCO (using nr_colors[]).\n */\n    void\nset_color_count(int nr)\n{\n    char_u\tnr_colors[20];\t\t// string for number of colors\n\n    t_colors = nr;\n    if (t_colors > 1)\n\tsprintf((char *)nr_colors, \"%d\", t_colors);\n    else\n\t*nr_colors = NUL;\n    set_string_option_direct((char_u *)\"t_Co\", -1, nr_colors, OPT_FREE, 0);\n}\n\n#if defined(FEAT_TERMRESPONSE)\n/*\n * Set the color count to \"val\" and redraw if it changed.\n */\n    static void\nmay_adjust_color_count(int val)\n{\n    if (val != t_colors)\n    {\n\t// Nr of colors changed, initialize highlighting and\n\t// redraw everything.  This causes a redraw, which usually\n\t// clears the message.  Try keeping the message if it\n\t// might work.\n\tset_keep_msg_from_hist();\n\tset_color_count(val);\n\tinit_highlight(TRUE, FALSE);\n# ifdef DEBUG_TERMRESPONSE\n\t{\n\t    int r = redraw_asap(CLEAR);\n\n\t    log_tr(\"Received t_Co, redraw_asap(): %d\", r);\n\t}\n# else\n\tredraw_asap(CLEAR);\n# endif\n    }\n}\n#endif\n\n#ifdef HAVE_TGETENT\nstatic char *(key_names[]) =\n{\n# ifdef FEAT_TERMRESPONSE\n    // Do this one first, it may cause a screen redraw.\n    \"Co\",\n# endif\n    \"ku\", \"kd\", \"kr\", \"kl\",\n    \"#2\", \"#4\", \"%i\", \"*7\",\n    \"k1\", \"k2\", \"k3\", \"k4\", \"k5\", \"k6\",\n    \"k7\", \"k8\", \"k9\", \"k;\", \"F1\", \"F2\",\n    \"%1\", \"&8\", \"kb\", \"kI\", \"kD\", \"kh\",\n    \"@7\", \"kP\", \"kN\", \"K1\", \"K3\", \"K4\", \"K5\", \"kB\",\n    NULL\n};\n#endif\n\n#ifdef HAVE_TGETENT\n    static void\nget_term_entries(int *height, int *width)\n{\n    static struct {\n\t\t    enum SpecialKey dest; // index in term_strings[]\n\t\t    char *name;\t\t  // termcap name for string\n\t\t  } string_names[] =\n\t\t    {\t{KS_CE, \"ce\"}, {KS_AL, \"al\"}, {KS_CAL,\"AL\"},\n\t\t\t{KS_DL, \"dl\"}, {KS_CDL,\"DL\"}, {KS_CS, \"cs\"},\n\t\t\t{KS_CL, \"cl\"}, {KS_CD, \"cd\"},\n\t\t\t{KS_VI, \"vi\"}, {KS_VE, \"ve\"}, {KS_MB, \"mb\"},\n\t\t\t{KS_ME, \"me\"}, {KS_MR, \"mr\"},\n\t\t\t{KS_MD, \"md\"}, {KS_SE, \"se\"}, {KS_SO, \"so\"},\n\t\t\t{KS_CZH,\"ZH\"}, {KS_CZR,\"ZR\"}, {KS_UE, \"ue\"},\n\t\t\t{KS_US, \"us\"}, {KS_UCE, \"Ce\"}, {KS_UCS, \"Cs\"},\n\t\t\t{KS_STE,\"Te\"}, {KS_STS,\"Ts\"},\n\t\t\t{KS_CM, \"cm\"}, {KS_SR, \"sr\"},\n\t\t\t{KS_CRI,\"RI\"}, {KS_VB, \"vb\"}, {KS_KS, \"ks\"},\n\t\t\t{KS_KE, \"ke\"}, {KS_TI, \"ti\"}, {KS_TE, \"te\"},\n\t\t\t{KS_CTI, \"TI\"}, {KS_CTE, \"TE\"},\n\t\t\t{KS_BC, \"bc\"}, {KS_CSB,\"Sb\"}, {KS_CSF,\"Sf\"},\n\t\t\t{KS_CAB,\"AB\"}, {KS_CAF,\"AF\"}, {KS_CAU,\"AU\"},\n\t\t\t{KS_LE, \"le\"},\n\t\t\t{KS_ND, \"nd\"}, {KS_OP, \"op\"}, {KS_CRV, \"RV\"},\n\t\t\t{KS_VS, \"vs\"}, {KS_CVS, \"VS\"},\n\t\t\t{KS_CIS, \"IS\"}, {KS_CIE, \"IE\"},\n\t\t\t{KS_CSC, \"SC\"}, {KS_CEC, \"EC\"},\n\t\t\t{KS_TS, \"ts\"}, {KS_FS, \"fs\"},\n\t\t\t{KS_CWP, \"WP\"}, {KS_CWS, \"WS\"},\n\t\t\t{KS_CSI, \"SI\"}, {KS_CEI, \"EI\"},\n\t\t\t{KS_U7, \"u7\"}, {KS_RFG, \"RF\"}, {KS_RBG, \"RB\"},\n\t\t\t{KS_8F, \"8f\"}, {KS_8B, \"8b\"}, {KS_8U, \"8u\"},\n\t\t\t{KS_CBE, \"BE\"}, {KS_CBD, \"BD\"},\n\t\t\t{KS_CPS, \"PS\"}, {KS_CPE, \"PE\"},\n\t\t\t{KS_CST, \"ST\"}, {KS_CRT, \"RT\"},\n\t\t\t{KS_SSI, \"Si\"}, {KS_SRI, \"Ri\"},\n\t\t\t{(enum SpecialKey)0, NULL}\n\t\t    };\n    int\t\t    i;\n    char_u\t    *p;\n    static char_u   tstrbuf[TBUFSZ];\n    char_u\t    *tp = tstrbuf;\n\n    /*\n     * get output strings\n     */\n    for (i = 0; string_names[i].name != NULL; ++i)\n    {\n\tif (TERM_STR(string_names[i].dest) == NULL\n\t\t\t     || TERM_STR(string_names[i].dest) == empty_option)\n\t{\n\t    TERM_STR(string_names[i].dest) = TGETSTR(string_names[i].name, &tp);\n#ifdef FEAT_EVAL\n\t    set_term_option_sctx_idx(string_names[i].name, -1);\n#endif\n\t}\n    }\n\n    // tgetflag() returns 1 if the flag is present, 0 if not and\n    // possibly -1 if the flag doesn't exist.\n    if ((T_MS == NULL || T_MS == empty_option) && tgetflag(\"ms\") > 0)\n\tT_MS = (char_u *)\"y\";\n    if ((T_XS == NULL || T_XS == empty_option) && tgetflag(\"xs\") > 0)\n\tT_XS = (char_u *)\"y\";\n    if ((T_XN == NULL || T_XN == empty_option) && tgetflag(\"xn\") > 0)\n\tT_XN = (char_u *)\"y\";\n    if ((T_DB == NULL || T_DB == empty_option) && tgetflag(\"db\") > 0)\n\tT_DB = (char_u *)\"y\";\n    if ((T_DA == NULL || T_DA == empty_option) && tgetflag(\"da\") > 0)\n\tT_DA = (char_u *)\"y\";\n    if ((T_UT == NULL || T_UT == empty_option) && tgetflag(\"ut\") > 0)\n\tT_UT = (char_u *)\"y\";\n\n    /*\n     * get key codes\n     */\n    for (i = 0; key_names[i] != NULL; ++i)\n\tif (find_termcode((char_u *)key_names[i]) == NULL)\n\t{\n\t    p = TGETSTR(key_names[i], &tp);\n\t    // if cursor-left == backspace, ignore it (televideo 925)\n\t    if (p != NULL\n\t\t    && (*p != Ctrl_H\n\t\t\t|| key_names[i][0] != 'k'\n\t\t\t|| key_names[i][1] != 'l'))\n\t\tadd_termcode((char_u *)key_names[i], p, FALSE);\n\t}\n\n    if (*height == 0)\n\t*height = tgetnum(\"li\");\n    if (*width == 0)\n\t*width = tgetnum(\"co\");\n\n    /*\n     * Get number of colors (if not done already).\n     */\n    if (TERM_STR(KS_CCO) == NULL || TERM_STR(KS_CCO) == empty_option)\n    {\n\tset_color_count(tgetnum(\"Co\"));\n#ifdef FEAT_EVAL\n\tset_term_option_sctx_idx(\"Co\", -1);\n#endif\n    }\n\n# ifndef hpux\n    BC = (char *)TGETSTR(\"bc\", &tp);\n    UP = (char *)TGETSTR(\"up\", &tp);\n    p = TGETSTR(\"pc\", &tp);\n    if (p)\n\tPC = *p;\n# endif\n}\n#endif\n\n    static void\nreport_term_error(char *error_msg, char_u *term)\n{\n    struct builtin_term *termp;\n    int\t\t\ti;\n\n    mch_errmsg(\"\\r\\n\");\n    if (error_msg != NULL)\n    {\n\tmch_errmsg(error_msg);\n\tmch_errmsg(\"\\r\\n\");\n    }\n    mch_errmsg(\"'\");\n    mch_errmsg((char *)term);\n    mch_errmsg(_(\"' not known. Available builtin terminals are:\"));\n    mch_errmsg(\"\\r\\n\");\n    for (termp = &(builtin_termcaps[0]); termp->bt_string != NULL; ++termp)\n    {\n\tif (termp->bt_entry == (int)KS_NAME\n\t\t&& STRCMP(termp->bt_string, \"gui\") != 0)\n\t{\n#ifdef HAVE_TGETENT\n\t    mch_errmsg(\"    builtin_\");\n#else\n\t    mch_errmsg(\"    \");\n#endif\n\t    mch_errmsg(termp->bt_string);\n\t    mch_errmsg(\"\\r\\n\");\n\t}\n    }\n    // Output extra 'cmdheight' line breaks to avoid that the following error\n    // message overwrites the last terminal name.\n    for (i = 1; i < p_ch; ++i)\n\tmch_errmsg(\"\\r\\n\");\n}\n\n    static void\nreport_default_term(char_u *term)\n{\n    mch_errmsg(_(\"defaulting to '\"));\n    mch_errmsg((char *)term);\n    mch_errmsg(\"'\\r\\n\");\n    if (emsg_silent == 0 && !in_assert_fails)\n    {\n\tscreen_start();\t// don't know where cursor is now\n\tout_flush();\n\tif (!is_not_a_term())\n\t    ui_delay(2007L, TRUE);\n    }\n}\n\n/*\n * Set terminal options for terminal \"term\".\n * Return OK if terminal 'term' was found in a termcap, FAIL otherwise.\n *\n * While doing this, until ttest(), some options may be NULL, be careful.\n */\n    int\nset_termname(char_u *term)\n{\n    struct builtin_term *termp;\n#ifdef HAVE_TGETENT\n    int\t\tbuiltin_first = p_tbi;\n    int\t\ttry;\n    int\t\ttermcap_cleared = FALSE;\n#endif\n    int\t\twidth = 0, height = 0;\n    char\t*error_msg = NULL;\n    char_u\t*bs_p, *del_p;\n\n    // In silect mode (ex -s) we don't use the 'term' option.\n    if (silent_mode)\n\treturn OK;\n\n    detected_8bit = FALSE;\t\t// reset 8-bit detection\n\n    if (term_is_builtin(term))\n    {\n\tterm += 8;\n#ifdef HAVE_TGETENT\n\tbuiltin_first = 1;\n#endif\n    }\n\n/*\n * If HAVE_TGETENT is not defined, only the builtin termcap is used, otherwise:\n *   If builtin_first is TRUE:\n *     0. try builtin termcap\n *     1. try external termcap\n *     2. if both fail default to a builtin terminal\n *   If builtin_first is FALSE:\n *     1. try external termcap\n *     2. try builtin termcap, if both fail default to a builtin terminal\n */\n#ifdef HAVE_TGETENT\n    for (try = builtin_first ? 0 : 1; try < 3; ++try)\n    {\n\t/*\n\t * Use external termcap\n\t */\n\tif (try == 1)\n\t{\n\t    char_u\t    tbuf[TBUFSZ];\n\n\t    /*\n\t     * If the external termcap does not have a matching entry, try the\n\t     * builtin ones.\n\t     */\n\t    if ((error_msg = invoke_tgetent(tbuf, term)) == NULL)\n\t    {\n\t\tif (!termcap_cleared)\n\t\t{\n\t\t    clear_termoptions();\t// clear old options\n\t\t    termcap_cleared = TRUE;\n\t\t}\n\n\t\tget_term_entries(&height, &width);\n\t    }\n\t}\n\telse\t    // try == 0 || try == 2\n#endif // HAVE_TGETENT\n\t/*\n\t * Use builtin termcap\n\t */\n\t{\n#ifdef HAVE_TGETENT\n\t    /*\n\t     * If builtin termcap was already used, there is no need to search\n\t     * for the builtin termcap again, quit now.\n\t     */\n\t    if (try == 2 && builtin_first && termcap_cleared)\n\t\tbreak;\n#endif\n\t    /*\n\t     * search for 'term' in builtin_termcaps[]\n\t     */\n\t    termp = find_builtin_term(term);\n\t    if (termp->bt_string == NULL)\t// did not find it\n\t    {\n#ifdef HAVE_TGETENT\n\t\t/*\n\t\t * If try == 0, first try the external termcap. If that is not\n\t\t * found we'll get back here with try == 2.\n\t\t * If termcap_cleared is set we used the external termcap,\n\t\t * don't complain about not finding the term in the builtin\n\t\t * termcap.\n\t\t */\n\t\tif (try == 0)\t\t\t// try external one\n\t\t    continue;\n\t\tif (termcap_cleared)\t\t// found in external termcap\n\t\t    break;\n#endif\n\t\treport_term_error(error_msg, term);\n\n\t\t// when user typed :set term=xxx, quit here\n\t\tif (starting != NO_SCREEN)\n\t\t{\n\t\t    screen_start();\t// don't know where cursor is now\n\t\t    wait_return(TRUE);\n\t\t    return FAIL;\n\t\t}\n\t\tterm = DEFAULT_TERM;\n\t\treport_default_term(term);\n\t\tset_string_option_direct((char_u *)\"term\", -1, term,\n\t\t\t\t\t\t\t\t OPT_FREE, 0);\n\t\tdisplay_errors();\n\t    }\n\t    out_flush();\n#ifdef HAVE_TGETENT\n\t    if (!termcap_cleared)\n\t    {\n#endif\n\t\tclear_termoptions();\t    // clear old options\n#ifdef HAVE_TGETENT\n\t\ttermcap_cleared = TRUE;\n\t    }\n#endif\n\t    parse_builtin_tcap(term);\n#ifdef FEAT_GUI\n\t    if (term_is_gui(term))\n\t    {\n\t\tout_flush();\n\t\tgui_init();\n\t\t// If starting the GUI failed, don't do any of the other\n\t\t// things for this terminal\n\t\tif (!gui.in_use)\n\t\t    return FAIL;\n#ifdef HAVE_TGETENT\n\t\tbreak;\t\t// don't try using external termcap\n#endif\n\t    }\n#endif // FEAT_GUI\n\t}\n#ifdef HAVE_TGETENT\n    }\n#endif\n\n/*\n * special: There is no info in the termcap about whether the cursor\n * positioning is relative to the start of the screen or to the start of the\n * scrolling region.  We just guess here. Only msdos pcterm is known to do it\n * relative.\n */\n    if (STRCMP(term, \"pcterm\") == 0)\n\tT_CCS = (char_u *)\"yes\";\n    else\n\tT_CCS = empty_option;\n\n#ifdef UNIX\n/*\n * Any \"stty\" settings override the default for t_kb from the termcap.\n * This is in os_unix.c, because it depends a lot on the version of unix that\n * is being used.\n * Don't do this when the GUI is active, it uses \"t_kb\" and \"t_kD\" directly.\n */\n# ifdef FEAT_GUI\n    if (!gui.in_use)\n# endif\n\tget_stty();\n#endif\n\n/*\n * If the termcap has no entry for 'bs' and/or 'del' and the ioctl() also\n * didn't work, use the default CTRL-H\n * The default for t_kD is DEL, unless t_kb is DEL.\n * The vim_strsave'd strings are probably lost forever, well it's only two\n * bytes.  Don't do this when the GUI is active, it uses \"t_kb\" and \"t_kD\"\n * directly.\n */\n#ifdef FEAT_GUI\n    if (!gui.in_use)\n#endif\n    {\n\tbs_p = find_termcode((char_u *)\"kb\");\n\tdel_p = find_termcode((char_u *)\"kD\");\n\tif (bs_p == NULL || *bs_p == NUL)\n\t    add_termcode((char_u *)\"kb\", (bs_p = (char_u *)CTRL_H_STR), FALSE);\n\tif ((del_p == NULL || *del_p == NUL) &&\n\t\t\t\t\t    (bs_p == NULL || *bs_p != DEL))\n\t    add_termcode((char_u *)\"kD\", (char_u *)DEL_STR, FALSE);\n    }\n\n#if defined(UNIX) || defined(VMS)\n    term_is_xterm = vim_is_xterm(term);\n#endif\n#ifdef FEAT_TERMRESPONSE\n    // Reset terminal properties that are set based on the termresponse, which\n    // will be sent out soon.\n    init_term_props(FALSE);\n#endif\n\n#if defined(UNIX) || defined(VMS)\n    /*\n     * For Unix, set the 'ttymouse' option to the type of mouse to be used.\n     * The termcode for the mouse is added as a side effect in option.c.\n     */\n    {\n\tchar_u\t*p = (char_u *)\"\";\n\n# ifdef FEAT_MOUSE_XTERM\n\tif (use_xterm_like_mouse(term))\n\t{\n\t    if (use_xterm_mouse())\n\t\tp = NULL;\t// keep existing value, might be \"xterm2\"\n\t    else\n\t\tp = (char_u *)\"xterm\";\n\t}\n# endif\n\tif (p != NULL)\n\t{\n\t    set_option_value_give_err((char_u *)\"ttym\", 0L, p, 0);\n\t    // Reset the WAS_SET flag, 'ttymouse' can be set to \"sgr\" or\n\t    // \"xterm2\" in check_termcode().\n\t    reset_option_was_set((char_u *)\"ttym\");\n\t}\n\tif (p == NULL\n#  ifdef FEAT_GUI\n\t\t|| gui.in_use\n#  endif\n\t\t)\n\t    check_mouse_termcode();\t// set mouse termcode anyway\n    }\n#else\n    set_mouse_termcode(KS_MOUSE, (char_u *)\"\\233M\");\n#endif\n\n#ifdef FEAT_MOUSE_XTERM\n    // Focus reporting is supported by xterm compatible terminals and tmux.\n    if (use_xterm_like_mouse(term))\n    {\n\tchar_u name[3];\n\n\t// handle focus in event\n\tname[0] = KS_EXTRA;\n\tname[1] = KE_FOCUSGAINED;\n\tname[2] = NUL;\n\tadd_termcode(name, (char_u *)\"\\033[I\", FALSE);\n\n\t// handle focus out event\n\tname[1] = KE_FOCUSLOST;\n\tadd_termcode(name, (char_u *)\"\\033[O\", FALSE);\n\n\tneed_gather = TRUE;\n    }\n#endif\n#if (defined(UNIX) || defined(VMS))\n    // First time after setting 'term' a focus event is always reported.\n    focus_state = MAYBE;\n#endif\n\n#ifdef USE_TERM_CONSOLE\n    // DEFAULT_TERM indicates that it is the machine console.\n    if (STRCMP(term, DEFAULT_TERM) != 0)\n\tterm_console = FALSE;\n    else\n    {\n\tterm_console = TRUE;\n# ifdef AMIGA\n\twin_resize_on();\t// enable window resizing reports\n# endif\n    }\n#endif\n\n#if defined(UNIX) || defined(VMS)\n    /*\n     * 'ttyfast' is default on for xterm, iris-ansi and a few others.\n     */\n    if (vim_is_fastterm(term))\n\tp_tf = TRUE;\n#endif\n#ifdef USE_TERM_CONSOLE\n    /*\n     * 'ttyfast' is default on consoles\n     */\n    if (term_console)\n\tp_tf = TRUE;\n#endif\n\n    ttest(TRUE);\t// make sure we have a valid set of terminal codes\n\n    full_screen = TRUE;\t\t// we can use termcap codes from now on\n    set_term_defaults();\t// use current values as defaults\n#ifdef FEAT_TERMRESPONSE\n    LOG_TR((\"setting crv_status to STATUS_GET\"));\n    crv_status.tr_progress = STATUS_GET;\t// Get terminal version later\n    write_t_8u_state = FALSE;\n#endif\n\n    /*\n     * Initialize the terminal with the appropriate termcap codes.\n     * Set the mouse and window title if possible.\n     * Don't do this when starting, need to parse the .vimrc first, because it\n     * may redefine t_TI etc.\n     */\n    if (starting != NO_SCREEN)\n    {\n\tstarttermcap();\t\t// may change terminal mode\n\tsetmouse();\t\t// may start using the mouse\n\tmaketitle();\t\t// may display window title\n    }\n\n\t// display initial screen after ttest() checking. jw.\n    if (width <= 0 || height <= 0)\n    {\n\t// termcap failed to report size\n\t// set defaults, in case ui_get_shellsize() also fails\n\twidth = 80;\n#if defined(MSWIN)\n\theight = 25;\t    // console is often 25 lines\n#else\n\theight = 24;\t    // most terminals are 24 lines\n#endif\n    }\n    set_shellsize(width, height, FALSE);\t// may change Rows\n    if (starting != NO_SCREEN)\n    {\n\tif (scroll_region)\n\t    scroll_region_reset();\t\t// In case Rows changed\n\tcheck_map_keycodes();\t// check mappings for terminal codes used\n\n\t{\n\t    buf_T\t*buf;\n\t    aco_save_T\taco;\n\n\t    /*\n\t     * Execute the TermChanged autocommands for each buffer that is\n\t     * loaded.\n\t     */\n\t    FOR_ALL_BUFFERS(buf)\n\t    {\n\t\tif (curbuf->b_ml.ml_mfp != NULL)\n\t\t{\n\t\t    aucmd_prepbuf(&aco, buf);\n\t\t    apply_autocmds(EVENT_TERMCHANGED, NULL, NULL, FALSE,\n\t\t\t\t\t\t\t\t      curbuf);\n\t\t    // restore curwin/curbuf and a few other things\n\t\t    aucmd_restbuf(&aco);\n\t\t}\n\t    }\n\t}\n    }\n\n#ifdef FEAT_TERMRESPONSE\n    may_req_termresponse();\n#endif\n\n    return OK;\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n\n# ifdef HAVE_DEL_CURTERM\n#  include <term.h>\t    // declares cur_term\n# endif\n\n/*\n * If supported, delete \"cur_term\", which caches terminal related entries.\n * Avoids that valgrind reports possibly lost memory.\n */\n    void\nfree_cur_term()\n{\n# ifdef HAVE_DEL_CURTERM\n    if (cur_term)\n\tdel_curterm(cur_term);\n# endif\n}\n\n#endif\n\n#ifdef HAVE_TGETENT\n/*\n * Call tgetent()\n * Return error message if it fails, NULL if it's OK.\n */\n    static char *\ninvoke_tgetent(char_u *tbuf, char_u *term)\n{\n    int\t    i;\n\n    // Note: Valgrind may report a leak here, because the library keeps one\n    // buffer around that we can't ever free.\n    i = TGETENT(tbuf, term);\n    if (i < 0\t\t    // -1 is always an error\n# ifdef TGETENT_ZERO_ERR\n\t    || i == 0\t    // sometimes zero is also an error\n# endif\n       )\n    {\n\t// On FreeBSD tputs() gets a SEGV after a tgetent() which fails.  Call\n\t// tgetent() with the always existing \"dumb\" entry to avoid a crash or\n\t// hang.\n\t(void)TGETENT(tbuf, \"dumb\");\n\n\tif (i < 0)\n# ifdef TGETENT_ZERO_ERR\n\t    return _(e_cannot_open_termcap_file);\n\tif (i == 0)\n# endif\n#ifdef TERMINFO\n\t    return _(e_terminal_entry_not_found_in_terminfo);\n#else\n\t    return _(e_terminal_entry_not_found_in_termcap);\n#endif\n    }\n    return NULL;\n}\n\n/*\n * Some versions of tgetstr() have been reported to return -1 instead of NULL.\n * Fix that here.\n */\n    static char_u *\nvim_tgetstr(char *s, char_u **pp)\n{\n    char\t*p;\n\n    p = tgetstr(s, (char **)pp);\n    if (p == (char *)-1)\n\tp = NULL;\n    return (char_u *)p;\n}\n#endif // HAVE_TGETENT\n\n#if defined(HAVE_TGETENT) && (defined(UNIX) || defined(VMS) || defined(MACOS_X))\n/*\n * Get Columns and Rows from the termcap. Used after a window signal if the\n * ioctl() fails. It doesn't make sense to call tgetent each time if the \"co\"\n * and \"li\" entries never change. But on some systems this works.\n * Errors while getting the entries are ignored.\n */\n    void\ngetlinecol(\n    long\t*cp,\t// pointer to columns\n    long\t*rp)\t// pointer to rows\n{\n    char_u\ttbuf[TBUFSZ];\n\n    if (T_NAME != NULL && *T_NAME != NUL && invoke_tgetent(tbuf, T_NAME) == NULL)\n    {\n\tif (*cp == 0)\n\t    *cp = tgetnum(\"co\");\n\tif (*rp == 0)\n\t    *rp = tgetnum(\"li\");\n    }\n}\n#endif // defined(HAVE_TGETENT) && defined(UNIX)\n\n/*\n * Get a string entry from the termcap and add it to the list of termcodes.\n * Used for <t_xx> special keys.\n * Give an error message for failure when not sourcing.\n * If force given, replace an existing entry.\n * Return FAIL if the entry was not found, OK if the entry was added.\n */\n    int\nadd_termcap_entry(char_u *name, int force)\n{\n    char_u  *term;\n    int\t    key;\n    struct builtin_term *termp;\n#ifdef HAVE_TGETENT\n    char_u  *string;\n    int\t    i;\n    int\t    builtin_first;\n    char_u  tbuf[TBUFSZ];\n    char_u  tstrbuf[TBUFSZ];\n    char_u  *tp = tstrbuf;\n    char    *error_msg = NULL;\n#endif\n\n/*\n * If the GUI is running or will start in a moment, we only support the keys\n * that the GUI can produce.\n */\n#ifdef FEAT_GUI\n    if (gui.in_use || gui.starting)\n\treturn gui_mch_haskey(name);\n#endif\n\n    if (!force && find_termcode(name) != NULL)\t    // it's already there\n\treturn OK;\n\n    term = T_NAME;\n    if (term == NULL || *term == NUL)\t    // 'term' not defined yet\n\treturn FAIL;\n\n    if (term_is_builtin(term))\t\t    // name starts with \"builtin_\"\n    {\n\tterm += 8;\n#ifdef HAVE_TGETENT\n\tbuiltin_first = TRUE;\n#endif\n    }\n#ifdef HAVE_TGETENT\n    else\n\tbuiltin_first = p_tbi;\n#endif\n\n#ifdef HAVE_TGETENT\n/*\n * We can get the entry from the builtin termcap and from the external one.\n * If 'ttybuiltin' is on or the terminal name starts with \"builtin_\", try\n * builtin termcap first.\n * If 'ttybuiltin' is off, try external termcap first.\n */\n    for (i = 0; i < 2; ++i)\n    {\n\tif ((!builtin_first) == i)\n#endif\n\t/*\n\t * Search in builtin termcap\n\t */\n\t{\n\t    termp = find_builtin_term(term);\n\t    if (termp->bt_string != NULL)\t// found it\n\t    {\n\t\tkey = TERMCAP2KEY(name[0], name[1]);\n\t\t++termp;\n\t\twhile (termp->bt_entry != (int)KS_NAME)\n\t\t{\n\t\t    if ((int)termp->bt_entry == key)\n\t\t    {\n\t\t\tadd_termcode(name, (char_u *)termp->bt_string,\n\t\t\t\t\t\t\t  term_is_8bit(term));\n\t\t\treturn OK;\n\t\t    }\n\t\t    ++termp;\n\t\t}\n\t    }\n\t}\n#ifdef HAVE_TGETENT\n\telse\n\t/*\n\t * Search in external termcap\n\t */\n\t{\n\t    error_msg = invoke_tgetent(tbuf, term);\n\t    if (error_msg == NULL)\n\t    {\n\t\tstring = TGETSTR((char *)name, &tp);\n\t\tif (string != NULL && *string != NUL)\n\t\t{\n\t\t    add_termcode(name, string, FALSE);\n\t\t    return OK;\n\t\t}\n\t    }\n\t}\n    }\n#endif\n\n    if (SOURCING_NAME == NULL)\n    {\n#ifdef HAVE_TGETENT\n\tif (error_msg != NULL)\n\t    emsg(error_msg);\n\telse\n#endif\n\t    semsg(_(e_no_str_entry_in_termcap), name);\n    }\n    return FAIL;\n}\n\n    static int\nterm_is_builtin(char_u *name)\n{\n    return (STRNCMP(name, \"builtin_\", (size_t)8) == 0);\n}\n\n/*\n * Return TRUE if terminal \"name\" uses CSI instead of <Esc>[.\n * Assume that the terminal is using 8-bit controls when the name contains\n * \"8bit\", like in \"xterm-8bit\".\n */\n    int\nterm_is_8bit(char_u *name)\n{\n    return (detected_8bit || strstr((char *)name, \"8bit\") != NULL);\n}\n\n/*\n * Translate terminal control chars from 7-bit to 8-bit:\n * <Esc>[ -> CSI  <M_C_[>\n * <Esc>] -> OSC  <M-C-]>\n * <Esc>O -> <M-C-O>\n */\n    static int\nterm_7to8bit(char_u *p)\n{\n    if (*p == ESC)\n    {\n\tif (p[1] == '[')\n\t    return CSI;\n\tif (p[1] == ']')\n\t    return OSC;\n\tif (p[1] == 'O')\n\t    return 0x8f;\n    }\n    return 0;\n}\n\n#if defined(FEAT_GUI) || defined(PROTO)\n    int\nterm_is_gui(char_u *name)\n{\n    return (STRCMP(name, \"builtin_gui\") == 0 || STRCMP(name, \"gui\") == 0);\n}\n#endif\n\n#if !defined(HAVE_TGETENT) || defined(AMIGA) || defined(PROTO)\n\n    char_u *\ntltoa(unsigned long i)\n{\n    static char_u buf[16];\n    char_u\t*p;\n\n    p = buf + 15;\n    *p = '\\0';\n    do\n    {\n\t--p;\n\t*p = (char_u) (i % 10 + '0');\n\ti /= 10;\n    }\n    while (i > 0 && p > buf);\n    return p;\n}\n#endif\n\n#ifndef HAVE_TGETENT\n\n/*\n * minimal tgoto() implementation.\n * no padding and we only parse for %i %d and %+char\n */\n    static char *\ntgoto(char *cm, int x, int y)\n{\n    static char buf[30];\n    char *p, *s, *e;\n\n    if (!cm)\n\treturn \"OOPS\";\n    e = buf + 29;\n    for (s = buf; s < e && *cm; cm++)\n    {\n\tif (*cm != '%')\n\t{\n\t    *s++ = *cm;\n\t    continue;\n\t}\n\tswitch (*++cm)\n\t{\n\tcase 'd':\n\t    p = (char *)tltoa((unsigned long)y);\n\t    y = x;\n\t    while (*p)\n\t\t*s++ = *p++;\n\t    break;\n\tcase 'i':\n\t    x++;\n\t    y++;\n\t    break;\n\tcase '+':\n\t    *s++ = (char)(*++cm + y);\n\t    y = x;\n\t    break;\n\tcase '%':\n\t    *s++ = *cm;\n\t    break;\n\tdefault:\n\t    return \"OOPS\";\n\t}\n    }\n    *s = '\\0';\n    return buf;\n}\n\n#endif // HAVE_TGETENT\n\n/*\n * Set the terminal name and initialize the terminal options.\n * If \"name\" is NULL or empty, get the terminal name from the environment.\n * If that fails, use the default terminal name.\n */\n    void\ntermcapinit(char_u *name)\n{\n    char_u\t*term;\n\n    if (name != NULL && *name == NUL)\n\tname = NULL;\t    // empty name is equal to no name\n    term = name;\n\n#ifndef MSWIN\n    if (term == NULL)\n\tterm = mch_getenv((char_u *)\"TERM\");\n#endif\n    if (term == NULL || *term == NUL)\n\tterm = DEFAULT_TERM;\n    set_string_option_direct((char_u *)\"term\", -1, term, OPT_FREE, 0);\n\n    // Set the default terminal name.\n    set_string_default(\"term\", term);\n    set_string_default(\"ttytype\", term);\n\n    /*\n     * Avoid using \"term\" here, because the next mch_getenv() may overwrite it.\n     */\n    set_termname(T_NAME != NULL ? T_NAME : term);\n}\n\n/*\n * The number of calls to ui_write is reduced by using \"out_buf\".\n */\n#define OUT_SIZE\t2047\n\n// add one to allow mch_write() in os_win32.c to append a NUL\nstatic char_u\t\tout_buf[OUT_SIZE + 1];\n\nstatic int\t\tout_pos = 0;\t// number of chars in out_buf\n\n// Since the maximum number of SGR parameters shown as a normal value range is\n// 16, the escape sequence length can be 4 * 16 + lead + tail.\n#define MAX_ESC_SEQ_LEN\t80\n\n/*\n * out_flush(): flush the output buffer\n */\n    void\nout_flush(void)\n{\n    int\t    len;\n\n    if (out_pos != 0)\n    {\n\t// set out_pos to 0 before ui_write, to avoid recursiveness\n\tlen = out_pos;\n\tout_pos = 0;\n\tui_write(out_buf, len, FALSE);\n#ifdef FEAT_JOB_CHANNEL\n\tif (ch_log_output != FALSE)\n\t{\n\t    out_buf[len] = NUL;\n\t    ch_log(NULL, \"raw %s output: \\\"%s\\\"\",\n# ifdef FEAT_GUI\n\t\t\t(gui.in_use && !gui.dying && !gui.starting) ? \"GUI\" :\n# endif\n\t\t\t\"terminal\",\n\t\t\tout_buf);\n\t    if (ch_log_output == TRUE)\n\t\tch_log_output = FALSE;  // only log once\n\t}\n#endif\n    }\n}\n\n/*\n * out_flush_cursor(): flush the output buffer and redraw the cursor.\n * Does not flush recursively in the GUI to avoid slow drawing.\n */\n    void\nout_flush_cursor(\n    int\t    force UNUSED,   // when TRUE, update cursor even when not moved\n    int\t    clear_selection UNUSED) // clear selection under cursor\n{\n    mch_disable_flush();\n    out_flush();\n    mch_enable_flush();\n#ifdef FEAT_GUI\n    if (gui.in_use)\n    {\n\tgui_update_cursor(force, clear_selection);\n\tgui_may_flush();\n    }\n#endif\n}\n\n\n/*\n * Sometimes a byte out of a multi-byte character is written with out_char().\n * To avoid flushing half of the character, call this function first.\n */\n    void\nout_flush_check(void)\n{\n    if (enc_dbcs != 0 && out_pos >= OUT_SIZE - MB_MAXBYTES)\n\tout_flush();\n}\n\n#ifdef FEAT_GUI\n/*\n * out_trash(): Throw away the contents of the output buffer\n */\n    void\nout_trash(void)\n{\n    out_pos = 0;\n}\n#endif\n\n/*\n * out_char(c): put a byte into the output buffer.\n *\t\tFlush it if it becomes full.\n * This should not be used for outputting text on the screen (use functions\n * like msg_puts() and screen_putchar() for that).\n */\n    void\nout_char(unsigned c)\n{\n#if defined(UNIX) || defined(VMS) || defined(AMIGA) || defined(MACOS_X)\n    if (c == '\\n')\t// turn LF into CR-LF (CRMOD doesn't seem to do this)\n\tout_char('\\r');\n#endif\n\n    out_buf[out_pos++] = c;\n\n    // For testing we flush each time.\n    if (out_pos >= OUT_SIZE || p_wd)\n\tout_flush();\n}\n\n/*\n * Output \"c\" like out_char(), but don't flush when p_wd is set.\n */\n    static int\nout_char_nf(int c)\n{\n    out_buf[out_pos++] = (unsigned)c;\n\n    if (out_pos >= OUT_SIZE)\n\tout_flush();\n    return (unsigned)c;\n}\n\n/*\n * A never-padding out_str().\n * Use this whenever you don't want to run the string through tputs().\n * tputs() above is harmless, but tputs() from the termcap library\n * is likely to strip off leading digits, that it mistakes for padding\n * information, and \"%i\", \"%d\", etc.\n * This should only be used for writing terminal codes, not for outputting\n * normal text (use functions like msg_puts() and screen_putchar() for that).\n */\n    void\nout_str_nf(char_u *s)\n{\n    // avoid terminal strings being split up\n    if (out_pos > OUT_SIZE - MAX_ESC_SEQ_LEN)\n\tout_flush();\n\n    while (*s)\n\tout_char_nf(*s++);\n\n    // For testing we write one string at a time.\n    if (p_wd)\n\tout_flush();\n}\n\n/*\n * A conditional-flushing out_str, mainly for visualbell.\n * Handles a delay internally, because termlib may not respect the delay or do\n * it at the wrong time.\n * Note: Only for terminal strings.\n */\n    void\nout_str_cf(char_u *s)\n{\n    if (s != NULL && *s)\n    {\n#ifdef HAVE_TGETENT\n\tchar_u *p;\n#endif\n\n#ifdef FEAT_GUI\n\t// Don't use tputs() when GUI is used, ncurses crashes.\n\tif (gui.in_use)\n\t{\n\t    out_str_nf(s);\n\t    return;\n\t}\n#endif\n\tif (out_pos > OUT_SIZE - MAX_ESC_SEQ_LEN)\n\t    out_flush();\n#ifdef HAVE_TGETENT\n\tfor (p = s; *s; ++s)\n\t{\n\t    // flush just before delay command\n\t    if (*s == '$' && *(s + 1) == '<')\n\t    {\n\t\tchar_u save_c = *s;\n\t\tint duration = atoi((char *)s + 2);\n\n\t\t*s = NUL;\n\t\ttputs((char *)p, 1, TPUTSFUNCAST out_char_nf);\n\t\t*s = save_c;\n\t\tout_flush();\n# ifdef ELAPSED_FUNC\n\t\t// Only sleep here if we can limit this happening in\n\t\t// vim_beep().\n\t\tp = vim_strchr(s, '>');\n\t\tif (p == NULL || duration <= 0)\n\t\t{\n\t\t    // can't parse the time, don't sleep here\n\t\t    p = s;\n\t\t}\n\t\telse\n\t\t{\n\t\t    ++p;\n\t\t    do_sleep(duration, FALSE);\n\t\t}\n# else\n\t\t// Rely on the terminal library to sleep.\n\t\tp = s;\n# endif\n\t\tbreak;\n\t    }\n\t}\n\ttputs((char *)p, 1, TPUTSFUNCAST out_char_nf);\n#else\n\twhile (*s)\n\t    out_char_nf(*s++);\n#endif\n\n\t// For testing we write one string at a time.\n\tif (p_wd)\n\t    out_flush();\n    }\n}\n\n/*\n * out_str(s): Put a character string a byte at a time into the output buffer.\n * If HAVE_TGETENT is defined use tputs(), the termcap parser. (jw)\n * This should only be used for writing terminal codes, not for outputting\n * normal text (use functions like msg_puts() and screen_putchar() for that).\n */\n    void\nout_str(char_u *s)\n{\n    if (s != NULL && *s)\n    {\n#ifdef FEAT_GUI\n\t// Don't use tputs() when GUI is used, ncurses crashes.\n\tif (gui.in_use)\n\t{\n\t    out_str_nf(s);\n\t    return;\n\t}\n#endif\n\t// avoid terminal strings being split up\n\tif (out_pos > OUT_SIZE - MAX_ESC_SEQ_LEN)\n\t    out_flush();\n#ifdef HAVE_TGETENT\n\ttputs((char *)s, 1, TPUTSFUNCAST out_char_nf);\n#else\n\twhile (*s)\n\t    out_char_nf(*s++);\n#endif\n\n\t// For testing we write one string at a time.\n\tif (p_wd)\n\t    out_flush();\n    }\n}\n\n/*\n * cursor positioning using termcap parser. (jw)\n */\n    void\nterm_windgoto(int row, int col)\n{\n    OUT_STR(tgoto((char *)T_CM, col, row));\n}\n\n    void\nterm_cursor_right(int i)\n{\n    OUT_STR(tgoto((char *)T_CRI, 0, i));\n}\n\n    void\nterm_append_lines(int line_count)\n{\n    OUT_STR(tgoto((char *)T_CAL, 0, line_count));\n}\n\n    void\nterm_delete_lines(int line_count)\n{\n    OUT_STR(tgoto((char *)T_CDL, 0, line_count));\n}\n\n#if defined(HAVE_TGETENT) || defined(PROTO)\n    void\nterm_set_winpos(int x, int y)\n{\n    // Can't handle a negative value here\n    if (x < 0)\n\tx = 0;\n    if (y < 0)\n\ty = 0;\n    OUT_STR(tgoto((char *)T_CWP, y, x));\n}\n\n# if defined(FEAT_TERMRESPONSE) || defined(PROTO)\n/*\n * Return TRUE if we can request the terminal for a response.\n */\n    static int\ncan_get_termresponse()\n{\n    return cur_tmode == TMODE_RAW\n\t    && termcap_active\n#  ifdef UNIX\n\t    && (is_not_a_term() || (isatty(1) && isatty(read_cmd_fd)))\n#  endif\n\t    && p_ek;\n}\n\n/*\n * Set \"status\" to STATUS_SENT.\n */\n    static void\ntermrequest_sent(termrequest_T *status)\n{\n    status->tr_progress = STATUS_SENT;\n    status->tr_start = time(NULL);\n}\n\n/*\n * Return TRUE if any of the requests are in STATUS_SENT.\n */\n    static int\ntermrequest_any_pending()\n{\n    int\t    i;\n    time_t  now = time(NULL);\n\n    for (i = 0; all_termrequests[i] != NULL; ++i)\n    {\n\tif (all_termrequests[i]->tr_progress == STATUS_SENT)\n\t{\n\t    if (all_termrequests[i]->tr_start > 0 && now > 0\n\t\t\t\t    && all_termrequests[i]->tr_start + 2 < now)\n\t\t// Sent the request more than 2 seconds ago and didn't get a\n\t\t// response, assume it failed.\n\t\tall_termrequests[i]->tr_progress = STATUS_FAIL;\n\t    else\n\t\treturn TRUE;\n\t}\n    }\n    return FALSE;\n}\n\nstatic int winpos_x = -1;\nstatic int winpos_y = -1;\nstatic int did_request_winpos = 0;\n\n# if defined(FEAT_EVAL) || defined(FEAT_TERMINAL) || defined(PROTO)\n/*\n * Try getting the Vim window position from the terminal.\n * Returns OK or FAIL.\n */\n    int\nterm_get_winpos(int *x, int *y, varnumber_T timeout)\n{\n    int count = 0;\n    int prev_winpos_x = winpos_x;\n    int prev_winpos_y = winpos_y;\n\n    if (*T_CGP == NUL || !can_get_termresponse())\n\treturn FAIL;\n    winpos_x = -1;\n    winpos_y = -1;\n    ++did_request_winpos;\n    termrequest_sent(&winpos_status);\n    OUT_STR(T_CGP);\n    out_flush();\n\n    // Try reading the result for \"timeout\" msec.\n    while (count++ <= timeout / 10 && !got_int)\n    {\n\t(void)vpeekc_nomap();\n\tif (winpos_x >= 0 && winpos_y >= 0)\n\t{\n\t    *x = winpos_x;\n\t    *y = winpos_y;\n\t    return OK;\n\t}\n\tui_delay(10L, FALSE);\n    }\n    // Do not reset \"did_request_winpos\", if we timed out the response might\n    // still come later and we must consume it.\n\n    winpos_x = prev_winpos_x;\n    winpos_y = prev_winpos_y;\n    if (timeout < 10 && prev_winpos_y >= 0 && prev_winpos_x >= 0)\n    {\n\t// Polling: return previous values if we have them.\n\t*x = winpos_x;\n\t*y = winpos_y;\n\treturn OK;\n    }\n\n    return FALSE;\n}\n#  endif\n# endif\n\n    void\nterm_set_winsize(int height, int width)\n{\n    OUT_STR(tgoto((char *)T_CWS, width, height));\n}\n#endif\n\n    static void\nterm_color(char_u *s, int n)\n{\n    char\tbuf[20];\n    int\t\ti = *s == CSI ? 1 : 2;\n\t\t// index in s[] just after <Esc>[ or CSI\n\n    // Special handling of 16 colors, because termcap can't handle it\n    // Also accept \"\\e[3%dm\" for TERMINFO, it is sometimes used\n    // Also accept CSI instead of <Esc>[\n    if (n >= 8 && t_colors >= 16\n\t      && ((s[0] == ESC && s[1] == '[')\n#if defined(FEAT_VTP) && defined(FEAT_TERMGUICOLORS)\n\t\t  || (s[0] == ESC && s[1] == '|')\n#endif\n\t\t  || (s[0] == CSI && (i = 1) == 1))\n\t      && s[i] != NUL\n\t      && (STRCMP(s + i + 1, \"%p1%dm\") == 0\n\t\t  || STRCMP(s + i + 1, \"%dm\") == 0)\n\t      && (s[i] == '3' || s[i] == '4'))\n    {\n#ifdef TERMINFO\n\tchar *format = \"%s%s%%p1%%dm\";\n#else\n\tchar *format = \"%s%s%%dm\";\n#endif\n\tchar *lead = i == 2 ? (\n#if defined(FEAT_VTP) && defined(FEAT_TERMGUICOLORS)\n\t\t    s[1] == '|' ? \"\\033|\" :\n#endif\n\t\t    \"\\033[\") : \"\\233\";\n\tchar *tail = s[i] == '3' ? (n >= 16 ? \"38;5;\" : \"9\")\n\t\t\t\t : (n >= 16 ? \"48;5;\" : \"10\");\n\n\tsprintf(buf, format, lead, tail);\n\tOUT_STR(tgoto(buf, 0, n >= 16 ? n : n - 8));\n    }\n    else\n\tOUT_STR(tgoto((char *)s, 0, n));\n}\n\n    void\nterm_fg_color(int n)\n{\n    // Use \"AF\" termcap entry if present, \"Sf\" entry otherwise\n    if (*T_CAF)\n\tterm_color(T_CAF, n);\n    else if (*T_CSF)\n\tterm_color(T_CSF, n);\n}\n\n    void\nterm_bg_color(int n)\n{\n    // Use \"AB\" termcap entry if present, \"Sb\" entry otherwise\n    if (*T_CAB)\n\tterm_color(T_CAB, n);\n    else if (*T_CSB)\n\tterm_color(T_CSB, n);\n}\n\n    void\nterm_ul_color(int n)\n{\n    if (*T_CAU)\n\tterm_color(T_CAU, n);\n}\n\n/*\n * Return \"dark\" or \"light\" depending on the kind of terminal.\n * This is just guessing!  Recognized are:\n * \"linux\"\t    Linux console\n * \"screen.linux\"   Linux console with screen\n * \"cygwin.*\"\t    Cygwin shell\n * \"putty.*\"\t    Putty program\n * We also check the COLORFGBG environment variable, which is set by\n * rxvt and derivatives. This variable contains either two or three\n * values separated by semicolons; we want the last value in either\n * case. If this value is 0-6 or 8, our background is dark.\n */\n    char_u *\nterm_bg_default(void)\n{\n#if defined(MSWIN)\n    // DOS console is nearly always black\n    return (char_u *)\"dark\";\n#else\n    char_u\t*p;\n\n    if (STRCMP(T_NAME, \"linux\") == 0\n\t    || STRCMP(T_NAME, \"screen.linux\") == 0\n\t    || STRNCMP(T_NAME, \"cygwin\", 6) == 0\n\t    || STRNCMP(T_NAME, \"putty\", 5) == 0\n\t    || ((p = mch_getenv((char_u *)\"COLORFGBG\")) != NULL\n\t\t&& (p = vim_strrchr(p, ';')) != NULL\n\t\t&& ((p[1] >= '0' && p[1] <= '6') || p[1] == '8')\n\t\t&& p[2] == NUL))\n\treturn (char_u *)\"dark\";\n    return (char_u *)\"light\";\n#endif\n}\n\n#if defined(FEAT_TERMGUICOLORS) || defined(PROTO)\n\n#define RED(rgb)   (((long_u)(rgb) >> 16) & 0xFF)\n#define GREEN(rgb) (((long_u)(rgb) >>  8) & 0xFF)\n#define BLUE(rgb)  (((long_u)(rgb)      ) & 0xFF)\n\n    static void\nterm_rgb_color(char_u *s, guicolor_T rgb)\n{\n#define MAX_COLOR_STR_LEN 100\n    char\tbuf[MAX_COLOR_STR_LEN];\n\n    if (*s == NUL)\n\treturn;\n    vim_snprintf(buf, MAX_COLOR_STR_LEN,\n\t\t\t\t  (char *)s, RED(rgb), GREEN(rgb), BLUE(rgb));\n#ifdef FEAT_VTP\n    if (use_wt())\n    {\n\tout_flush();\n\tbuf[1] = '[';\n\tvtp_printf(buf);\n    }\n    else\n#endif\n\tOUT_STR(buf);\n}\n\n    void\nterm_fg_rgb_color(guicolor_T rgb)\n{\n    term_rgb_color(T_8F, rgb);\n}\n\n    void\nterm_bg_rgb_color(guicolor_T rgb)\n{\n    if (rgb != INVALCOLOR)\n\tterm_rgb_color(T_8B, rgb);\n}\n\n    void\nterm_ul_rgb_color(guicolor_T rgb)\n{\n# ifdef FEAT_TERMRESPONSE\n    if (write_t_8u_state != OK)\n\twrite_t_8u_state = MAYBE;\n    else\n# endif\n\tterm_rgb_color(T_8U, rgb);\n}\n#endif\n\n#if (defined(UNIX) || defined(VMS) || defined(MACOS_X)) || defined(PROTO)\n/*\n * Generic function to set window title, using t_ts and t_fs.\n */\n    void\nterm_settitle(char_u *title)\n{\n    MAY_WANT_TO_LOG_THIS;\n\n    // t_ts takes one argument: column in status line\n    OUT_STR(tgoto((char *)T_TS, 0, 0));\t// set title start\n    out_str_nf(title);\n    out_str(T_FS);\t\t\t// set title end\n    out_flush();\n}\n\n/*\n * Tell the terminal to push (save) the title and/or icon, so that it can be\n * popped (restored) later.\n */\n    void\nterm_push_title(int which)\n{\n    if ((which & SAVE_RESTORE_TITLE) && T_CST != NULL && *T_CST != NUL)\n    {\n\tOUT_STR(T_CST);\n\tout_flush();\n    }\n\n    if ((which & SAVE_RESTORE_ICON) && T_SSI != NULL && *T_SSI != NUL)\n    {\n\tOUT_STR(T_SSI);\n\tout_flush();\n    }\n}\n\n/*\n * Tell the terminal to pop the title and/or icon.\n */\n    void\nterm_pop_title(int which)\n{\n    if ((which & SAVE_RESTORE_TITLE) && T_CRT != NULL && *T_CRT != NUL)\n    {\n\tOUT_STR(T_CRT);\n\tout_flush();\n    }\n\n    if ((which & SAVE_RESTORE_ICON) && T_SRI != NULL && *T_SRI != NUL)\n    {\n\tOUT_STR(T_SRI);\n\tout_flush();\n    }\n}\n#endif\n\n/*\n * Make sure we have a valid set or terminal options.\n * Replace all entries that are NULL by empty_option\n */\n    void\nttest(int pairs)\n{\n    char_u *env_colors;\n\n    check_options();\t\t    // make sure no options are NULL\n\n    /*\n     * MUST have \"cm\": cursor motion.\n     */\n    if (*T_CM == NUL)\n\temsg(_(e_terminal_capability_cm_required));\n\n    /*\n     * if \"cs\" defined, use a scroll region, it's faster.\n     */\n    if (*T_CS != NUL)\n\tscroll_region = TRUE;\n    else\n\tscroll_region = FALSE;\n\n    if (pairs)\n    {\n\t/*\n\t * optional pairs\n\t */\n\t// TP goes to normal mode for TI (invert) and TB (bold)\n\tif (*T_ME == NUL)\n\t    T_ME = T_MR = T_MD = T_MB = empty_option;\n\tif (*T_SO == NUL || *T_SE == NUL)\n\t    T_SO = T_SE = empty_option;\n\tif (*T_US == NUL || *T_UE == NUL)\n\t    T_US = T_UE = empty_option;\n\tif (*T_CZH == NUL || *T_CZR == NUL)\n\t    T_CZH = T_CZR = empty_option;\n\n\t// T_VE is needed even though T_VI is not defined\n\tif (*T_VE == NUL)\n\t    T_VI = empty_option;\n\n\t// if 'mr' or 'me' is not defined use 'so' and 'se'\n\tif (*T_ME == NUL)\n\t{\n\t    T_ME = T_SE;\n\t    T_MR = T_SO;\n\t    T_MD = T_SO;\n\t}\n\n\t// if 'so' or 'se' is not defined use 'mr' and 'me'\n\tif (*T_SO == NUL)\n\t{\n\t    T_SE = T_ME;\n\t    if (*T_MR == NUL)\n\t\tT_SO = T_MD;\n\t    else\n\t\tT_SO = T_MR;\n\t}\n\n\t// if 'ZH' or 'ZR' is not defined use 'mr' and 'me'\n\tif (*T_CZH == NUL)\n\t{\n\t    T_CZR = T_ME;\n\t    if (*T_MR == NUL)\n\t\tT_CZH = T_MD;\n\t    else\n\t\tT_CZH = T_MR;\n\t}\n\n\t// \"Sb\" and \"Sf\" come in pairs\n\tif (*T_CSB == NUL || *T_CSF == NUL)\n\t{\n\t    T_CSB = empty_option;\n\t    T_CSF = empty_option;\n\t}\n\n\t// \"AB\" and \"AF\" come in pairs\n\tif (*T_CAB == NUL || *T_CAF == NUL)\n\t{\n\t    T_CAB = empty_option;\n\t    T_CAF = empty_option;\n\t}\n\n\t// if 'Sb' and 'AB' are not defined, reset \"Co\"\n\tif (*T_CSB == NUL && *T_CAB == NUL)\n\t    free_one_termoption(T_CCO);\n\n\t// Set 'weirdinvert' according to value of 't_xs'\n\tp_wiv = (*T_XS != NUL);\n    }\n    need_gather = TRUE;\n\n    // Set t_colors to the value of $COLORS or t_Co.  Ignore $COLORS in the\n    // GUI.\n    t_colors = atoi((char *)T_CCO);\n#ifdef FEAT_GUI\n    if (!gui.in_use)\n#endif\n    {\n\tenv_colors = mch_getenv((char_u *)\"COLORS\");\n\tif (env_colors != NULL && isdigit(*env_colors))\n\t{\n\t    int colors = atoi((char *)env_colors);\n\n\t    if (colors != t_colors)\n\t\tset_color_count(colors);\n\t}\n    }\n}\n\n#if (defined(FEAT_GUI) && (defined(FEAT_MENU) || !defined(USE_ON_FLY_SCROLL))) \\\n\t|| defined(PROTO)\n/*\n * Represent the given long_u as individual bytes, with the most significant\n * byte first, and store them in dst.\n */\n    void\nadd_long_to_buf(long_u val, char_u *dst)\n{\n    int\t    i;\n    int\t    shift;\n\n    for (i = 1; i <= (int)sizeof(long_u); i++)\n    {\n\tshift = 8 * (sizeof(long_u) - i);\n\tdst[i - 1] = (char_u) ((val >> shift) & 0xff);\n    }\n}\n\n/*\n * Interpret the next string of bytes in buf as a long integer, with the most\n * significant byte first.  Note that it is assumed that buf has been through\n * inchar(), so that NUL and K_SPECIAL will be represented as three bytes each.\n * Puts result in val, and returns the number of bytes read from buf\n * (between sizeof(long_u) and 2 * sizeof(long_u)), or -1 if not enough bytes\n * were present.\n */\n    static int\nget_long_from_buf(char_u *buf, long_u *val)\n{\n    int\t    len;\n    char_u  bytes[sizeof(long_u)];\n    int\t    i;\n    int\t    shift;\n\n    *val = 0;\n    len = get_bytes_from_buf(buf, bytes, (int)sizeof(long_u));\n    if (len != -1)\n    {\n\tfor (i = 0; i < (int)sizeof(long_u); i++)\n\t{\n\t    shift = 8 * (sizeof(long_u) - 1 - i);\n\t    *val += (long_u)bytes[i] << shift;\n\t}\n    }\n    return len;\n}\n#endif\n\n/*\n * Read the next num_bytes bytes from buf, and store them in bytes.  Assume\n * that buf has been through inchar().\tReturns the actual number of bytes used\n * from buf (between num_bytes and num_bytes*2), or -1 if not enough bytes were\n * available.\n */\n    int\nget_bytes_from_buf(char_u *buf, char_u *bytes, int num_bytes)\n{\n    int\t    len = 0;\n    int\t    i;\n    char_u  c;\n\n    for (i = 0; i < num_bytes; i++)\n    {\n\tif ((c = buf[len++]) == NUL)\n\t    return -1;\n\tif (c == K_SPECIAL)\n\t{\n\t    if (buf[len] == NUL || buf[len + 1] == NUL)\t    // cannot happen?\n\t\treturn -1;\n\t    if (buf[len++] == (int)KS_ZERO)\n\t\tc = NUL;\n\t    // else it should be KS_SPECIAL; when followed by KE_FILLER c is\n\t    // K_SPECIAL, or followed by KE_CSI and c must be CSI.\n\t    if (buf[len++] == (int)KE_CSI)\n\t\tc = CSI;\n\t}\n\telse if (c == CSI && buf[len] == KS_EXTRA\n\t\t\t\t\t       && buf[len + 1] == (int)KE_CSI)\n\t    // CSI is stored as CSI KS_SPECIAL KE_CSI to avoid confusion with\n\t    // the start of a special key, see add_to_input_buf_csi().\n\t    len += 2;\n\tbytes[i] = c;\n    }\n    return len;\n}\n\n/*\n * Check if the new shell size is valid, correct it if it's too small or way\n * too big.\n */\n    void\ncheck_shellsize(void)\n{\n    if (Rows < min_rows())\t// need room for one window and command line\n\tRows = min_rows();\n    limit_screen_size();\n\n    // make sure these values are not invalid\n    if (cmdline_row >= Rows)\n\tcmdline_row = Rows - 1;\n    if (msg_row >= Rows)\n\tmsg_row = Rows - 1;\n}\n\n/*\n * Limit Rows and Columns to avoid an overflow in Rows * Columns.\n */\n    void\nlimit_screen_size(void)\n{\n    if (Columns < MIN_COLUMNS)\n\tColumns = MIN_COLUMNS;\n    else if (Columns > 10000)\n\tColumns = 10000;\n    if (Rows > 1000)\n\tRows = 1000;\n}\n\n/*\n * Invoked just before the screen structures are going to be (re)allocated.\n */\n    void\nwin_new_shellsize(void)\n{\n    static int\told_Rows = 0;\n    static int\told_Columns = 0;\n\n    if (old_Rows != Rows || old_Columns != Columns)\n\tui_new_shellsize();\n    if (old_Rows != Rows)\n    {\n\t// If 'window' uses the whole screen, keep it using that.\n\t// Don't change it when set with \"-w size\" on the command line.\n\tif (p_window == old_Rows - 1\n\t\t    || (old_Rows == 0 && !option_was_set((char_u *)\"window\")))\n\t    p_window = Rows - 1;\n\told_Rows = Rows;\n\tshell_new_rows();\t// update window sizes\n    }\n    if (old_Columns != Columns)\n    {\n\told_Columns = Columns;\n\tshell_new_columns();\t// update window sizes\n    }\n}\n\n/*\n * Call this function when the Vim shell has been resized in any way.\n * Will obtain the current size and redraw (also when size didn't change).\n */\n    void\nshell_resized(void)\n{\n    set_shellsize(0, 0, FALSE);\n}\n\n/*\n * Check if the shell size changed.  Handle a resize.\n * When the size didn't change, nothing happens.\n */\n    void\nshell_resized_check(void)\n{\n    int\t\told_Rows = Rows;\n    int\t\told_Columns = Columns;\n\n    if (!exiting\n#ifdef FEAT_GUI\n\t    // Do not get the size when executing a shell command during\n\t    // startup.\n\t    && !gui.starting\n#endif\n\t    )\n    {\n\t(void)ui_get_shellsize();\n\tcheck_shellsize();\n\tif (old_Rows != Rows || old_Columns != Columns)\n\t    shell_resized();\n    }\n}\n\n/*\n * Set size of the Vim shell.\n * If 'mustset' is TRUE, we must set Rows and Columns, do not get the real\n * window size (this is used for the :win command).\n * If 'mustset' is FALSE, we may try to get the real window size and if\n * it fails use 'width' and 'height'.\n */\n    void\nset_shellsize(int width, int height, int mustset)\n{\n    static int\t\tbusy = FALSE;\n\n    /*\n     * Avoid recursiveness, can happen when setting the window size causes\n     * another window-changed signal.\n     */\n    if (busy)\n\treturn;\n\n    if (width < 0 || height < 0)    // just checking...\n\treturn;\n\n    if (State == MODE_HITRETURN || State == MODE_SETWSIZE)\n    {\n\t// postpone the resizing\n\tState = MODE_SETWSIZE;\n\treturn;\n    }\n\n    if (updating_screen)\n\t// resizing while in update_screen() may cause a crash\n\treturn;\n\n    // curwin->w_buffer can be NULL when we are closing a window and the\n    // buffer (or window) has already been closed and removing a scrollbar\n    // causes a resize event. Don't resize then, it will happen after entering\n    // another buffer.\n    if (curwin->w_buffer == NULL || curwin->w_lines == NULL)\n\treturn;\n\n    ++busy;\n\n#ifdef AMIGA\n    out_flush();\t    // must do this before mch_get_shellsize() for\n\t\t\t    // some obscure reason\n#endif\n\n    if (mustset || (ui_get_shellsize() == FAIL && height != 0))\n    {\n\tRows = height;\n\tColumns = width;\n\tcheck_shellsize();\n\tui_set_shellsize(mustset);\n    }\n    else\n\tcheck_shellsize();\n\n    // The window layout used to be adjusted here, but it now happens in\n    // screenalloc() (also invoked from screenclear()).  That is because the\n    // \"busy\" check above may skip this, but not screenalloc().\n\n    if (State != MODE_ASKMORE && State != MODE_EXTERNCMD\n\t\t\t\t\t\t      && State != MODE_CONFIRM)\n\tscreenclear();\n    else\n\tscreen_start();\t    // don't know where cursor is now\n\n    if (starting != NO_SCREEN)\n    {\n\tmaketitle();\n\n\tchanged_line_abv_curs();\n\tinvalidate_botline();\n\n\t/*\n\t * We only redraw when it's needed:\n\t * - While at the more prompt or executing an external command, don't\n\t *   redraw, but position the cursor.\n\t * - While editing the command line, only redraw that.\n\t * - in Ex mode, don't redraw anything.\n\t * - Otherwise, redraw right now, and position the cursor.\n\t * Always need to call update_screen() or screenalloc(), to make\n\t * sure Rows/Columns and the size of ScreenLines[] is correct!\n\t */\n\tif (State == MODE_ASKMORE || State == MODE_EXTERNCMD\n\t\t\t\t     || State == MODE_CONFIRM || exmode_active)\n\t{\n\t    screenalloc(FALSE);\n\t    repeat_message();\n\t}\n\telse\n\t{\n\t    if (curwin->w_p_scb)\n\t\tdo_check_scrollbind(TRUE);\n\t    if (State & MODE_CMDLINE)\n\t    {\n\t\tupdate_screen(NOT_VALID);\n\t\tredrawcmdline();\n\t    }\n\t    else\n\t    {\n\t\tupdate_topline();\n\t\tif (pum_visible())\n\t\t{\n\t\t    redraw_later(NOT_VALID);\n\t\t    ins_compl_show_pum();\n\t\t}\n\t\tupdate_screen(NOT_VALID);\n\t\tif (redrawing())\n\t\t    setcursor();\n\t    }\n\t}\n\tcursor_on();\t    // redrawing may have switched it off\n    }\n    out_flush();\n    --busy;\n}\n\n/*\n * Set the terminal to TMODE_RAW (for Normal mode) or TMODE_COOK (for external\n * commands and Ex mode).\n */\n    void\nsettmode(tmode_T tmode)\n{\n#ifdef FEAT_GUI\n    // don't set the term where gvim was started to any mode\n    if (gui.in_use)\n\treturn;\n#endif\n\n    if (full_screen)\n    {\n\t/*\n\t * When returning after calling a shell cur_tmode is TMODE_UNKNOWN,\n\t * set the terminal to raw mode, even though we think it already is,\n\t * because the shell program may have reset the terminal mode.\n\t * When we think the terminal is normal, don't try to set it to\n\t * normal again, because that causes problems (logout!) on some\n\t * machines.\n\t */\n\tif (tmode != cur_tmode)\n\t{\n#ifdef FEAT_TERMRESPONSE\n# ifdef FEAT_GUI\n\t    if (!gui.in_use && !gui.starting)\n# endif\n\t    {\n\t\t// May need to check for T_CRV response and termcodes, it\n\t\t// doesn't work in Cooked mode, an external program may get\n\t\t// them.\n\t\tif (tmode != TMODE_RAW && termrequest_any_pending())\n\t\t    (void)vpeekc_nomap();\n\t\tcheck_for_codes_from_term();\n\t    }\n#endif\n\t    if (tmode != TMODE_RAW)\n\t\tmch_setmouse(FALSE);\t// switch mouse off\n\n\t    // Disable bracketed paste and modifyOtherKeys in cooked mode.\n\t    // Avoid doing this too often, on some terminals the codes are not\n\t    // handled properly.\n\t    if (termcap_active && tmode != TMODE_SLEEP\n\t\t\t\t\t\t   && cur_tmode != TMODE_SLEEP)\n\t    {\n\t\tMAY_WANT_TO_LOG_THIS;\n\n\t\tif (tmode != TMODE_RAW)\n\t\t{\n\t\t    out_str(T_BD);\t// disable bracketed paste mode\n\t\t    out_str(T_CTE);\t// possibly disables modifyOtherKeys\n\t\t}\n\t\telse\n\t\t{\n\t\t    out_str(T_BE);\t// enable bracketed paste mode (should\n\t\t\t\t\t// be before mch_settmode().\n\t\t    out_str(T_CTI);\t// possibly enables modifyOtherKeys\n\t\t}\n\t    }\n\t    out_flush();\n\t    mch_settmode(tmode);\t// machine specific function\n\t    cur_tmode = tmode;\n\t    if (tmode == TMODE_RAW)\n\t\tsetmouse();\t\t// may switch mouse on\n\t    out_flush();\n\t}\n#ifdef FEAT_TERMRESPONSE\n\tmay_req_termresponse();\n#endif\n    }\n}\n\n    void\nstarttermcap(void)\n{\n    if (full_screen && !termcap_active)\n    {\n\tMAY_WANT_TO_LOG_THIS;\n\n\tout_str(T_TI);\t\t\t// start termcap mode\n\tout_str(T_CTI);\t\t\t// start \"raw\" mode\n\tout_str(T_KS);\t\t\t// start \"keypad transmit\" mode\n\tout_str(T_BE);\t\t\t// enable bracketed paste mode\n\n#if defined(UNIX) || defined(VMS)\n\t// Enable xterm's focus reporting mode when 'esckeys' is set.\n\tif (p_ek && *T_FE != NUL)\n\t    out_str(T_FE);\n#endif\n\n\tout_flush();\n\ttermcap_active = TRUE;\n\tscreen_start();\t\t\t// don't know where cursor is now\n#ifdef FEAT_TERMRESPONSE\n# ifdef FEAT_GUI\n\tif (!gui.in_use && !gui.starting)\n# endif\n\t{\n\t    may_req_termresponse();\n\t    // Immediately check for a response.  If t_Co changes, we don't\n\t    // want to redraw with wrong colors first.\n\t    if (crv_status.tr_progress == STATUS_SENT)\n\t\tcheck_for_codes_from_term();\n\t}\n#endif\n    }\n}\n\n    void\nstoptermcap(void)\n{\n    screen_stop_highlight();\n    reset_cterm_colors();\n    if (termcap_active)\n    {\n#ifdef FEAT_TERMRESPONSE\n# ifdef FEAT_GUI\n\tif (!gui.in_use && !gui.starting)\n# endif\n\t{\n\t    // May need to discard T_CRV, T_U7 or T_RBG response.\n\t    if (termrequest_any_pending())\n\t    {\n# ifdef UNIX\n\t\t// Give the terminal a chance to respond.\n\t\tmch_delay(100L, 0);\n# endif\n# ifdef TCIFLUSH\n\t\t// Discard data received but not read.\n\t\tif (exiting)\n\t\t    tcflush(fileno(stdin), TCIFLUSH);\n# endif\n\t    }\n\t    // Check for termcodes first, otherwise an external program may\n\t    // get them.\n\t    check_for_codes_from_term();\n\t}\n#endif\n\tMAY_WANT_TO_LOG_THIS;\n\n#if defined(UNIX) || defined(VMS)\n\t// Disable xterm's focus reporting mode if 'esckeys' is set.\n\tif (p_ek && *T_FD != NUL)\n\t    out_str(T_FD);\n#endif\n\n\tout_str(T_BD);\t\t\t// disable bracketed paste mode\n\tout_str(T_KE);\t\t\t// stop \"keypad transmit\" mode\n\tout_flush();\n\ttermcap_active = FALSE;\n\tcursor_on();\t\t\t// just in case it is still off\n\tout_str(T_CTE);\t\t\t// stop \"raw\" mode\n\tout_str(T_TE);\t\t\t// stop termcap mode\n\tscreen_start();\t\t\t// don't know where cursor is now\n\tout_flush();\n    }\n}\n\n#if defined(FEAT_TERMRESPONSE) || defined(PROTO)\n/*\n * Request version string (for xterm) when needed.\n * Only do this after switching to raw mode, otherwise the result will be\n * echoed.\n * Only do this after startup has finished, to avoid that the response comes\n * while executing \"-c !cmd\" or even after \"-c quit\".\n * Only do this after termcap mode has been started, otherwise the codes for\n * the cursor keys may be wrong.\n * Only do this when 'esckeys' is on, otherwise the response causes trouble in\n * Insert mode.\n * On Unix only do it when both output and input are a tty (avoid writing\n * request to terminal while reading from a file).\n * The result is caught in check_termcode().\n */\n    void\nmay_req_termresponse(void)\n{\n    if (crv_status.tr_progress == STATUS_GET\n\t    && can_get_termresponse()\n\t    && starting == 0\n\t    && *T_CRV != NUL)\n    {\n\tMAY_WANT_TO_LOG_THIS;\n\tLOG_TR((\"Sending CRV request\"));\n\tout_str(T_CRV);\n\ttermrequest_sent(&crv_status);\n\t// check for the characters now, otherwise they might be eaten by\n\t// get_keystroke()\n\tout_flush();\n\t(void)vpeekc_nomap();\n    }\n}\n\n/*\n * Send sequences to the terminal and check with t_u7 how the cursor moves, to\n * find out properties of the terminal.\n * Note that this goes out before T_CRV, so that the result can be used when\n * the termresponse arrives.\n */\n    void\ncheck_terminal_behavior(void)\n{\n    int\t    did_send = FALSE;\n\n    if (!can_get_termresponse() || starting != 0 || *T_U7 == NUL)\n\treturn;\n\n    if (u7_status.tr_progress == STATUS_GET\n\t    && !option_was_set((char_u *)\"ambiwidth\"))\n    {\n\tchar_u\tbuf[16];\n\n\t// Ambiguous width check.\n\t// Check how the terminal treats ambiguous character width (UAX #11).\n\t// First, we move the cursor to (1, 0) and print a test ambiguous\n\t// character \\u25bd (WHITE DOWN-POINTING TRIANGLE) and then query\n\t// the current cursor position.  If the terminal treats \\u25bd as\n\t// single width, the position is (1, 1), or if it is treated as double\n\t// width, that will be (1, 2).  This function has the side effect that\n\t// changes cursor position, so it must be called immediately after\n\t// entering termcap mode.\n\tMAY_WANT_TO_LOG_THIS;\n\tLOG_TR((\"Sending request for ambiwidth check\"));\n\t// Do this in the second row.  In the first row the returned sequence\n\t// may be CSI 1;2R, which is the same as <S-F3>.\n\tterm_windgoto(1, 0);\n\tbuf[mb_char2bytes(0x25bd, buf)] = NUL;\n\tout_str(buf);\n\tout_str(T_U7);\n\ttermrequest_sent(&u7_status);\n\tout_flush();\n\tdid_send = TRUE;\n\n\t// This overwrites a few characters on the screen, a redraw is needed\n\t// after this. Clear them out for now.\n\tscreen_stop_highlight();\n\tterm_windgoto(1, 0);\n\tout_str((char_u *)\"  \");\n\tline_was_clobbered(1);\n    }\n\n    if (xcc_status.tr_progress == STATUS_GET && Rows > 2)\n    {\n\t// 2. Check compatibility with xterm.\n\t// We move the cursor to (2, 0), print a test sequence and then query\n\t// the current cursor position.  If the terminal properly handles\n\t// unknown DCS string and CSI sequence with intermediate byte, the test\n\t// sequence is ignored and the cursor does not move.  If the terminal\n\t// handles test sequence incorrectly, a garbage string is displayed and\n\t// the cursor does move.\n\tMAY_WANT_TO_LOG_THIS;\n\tLOG_TR((\"Sending xterm compatibility test sequence.\"));\n\t// Do this in the third row.  Second row is used by ambiguous\n\t// character width check.\n\tterm_windgoto(2, 0);\n\t// send the test DCS string.\n\tout_str((char_u *)\"\\033Pzz\\033\\\\\");\n\t// send the test CSI sequence with intermediate byte.\n\tout_str((char_u *)\"\\033[0%m\");\n\tout_str(T_U7);\n\ttermrequest_sent(&xcc_status);\n\tout_flush();\n\tdid_send = TRUE;\n\n\t// If the terminal handles test sequence incorrectly, garbage text is\n\t// displayed. Clear them out for now.\n\tscreen_stop_highlight();\n\tterm_windgoto(2, 0);\n\tout_str((char_u *)\"           \");\n\tline_was_clobbered(2);\n    }\n\n    if (did_send)\n    {\n\tterm_windgoto(0, 0);\n\n\t// Need to reset the known cursor position.\n\tscreen_start();\n\n\t// check for the characters now, otherwise they might be eaten by\n\t// get_keystroke()\n\tout_flush();\n\t(void)vpeekc_nomap();\n    }\n}\n\n/*\n * Similar to requesting the version string: Request the terminal background\n * color when it is the right moment.\n */\n    void\nmay_req_bg_color(void)\n{\n    if (can_get_termresponse() && starting == 0)\n    {\n\tint didit = FALSE;\n\n# ifdef FEAT_TERMINAL\n\t// Only request foreground if t_RF is set.\n\tif (rfg_status.tr_progress == STATUS_GET && *T_RFG != NUL)\n\t{\n\t    MAY_WANT_TO_LOG_THIS;\n\t    LOG_TR((\"Sending FG request\"));\n\t    out_str(T_RFG);\n\t    termrequest_sent(&rfg_status);\n\t    didit = TRUE;\n\t}\n# endif\n\n\t// Only request background if t_RB is set.\n\tif (rbg_status.tr_progress == STATUS_GET && *T_RBG != NUL)\n\t{\n\t    MAY_WANT_TO_LOG_THIS;\n\t    LOG_TR((\"Sending BG request\"));\n\t    out_str(T_RBG);\n\t    termrequest_sent(&rbg_status);\n\t    didit = TRUE;\n\t}\n\n\tif (didit)\n\t{\n\t    // check for the characters now, otherwise they might be eaten by\n\t    // get_keystroke()\n\t    out_flush();\n\t    (void)vpeekc_nomap();\n\t}\n    }\n}\n\n# ifdef DEBUG_TERMRESPONSE\n    static void\nlog_tr(const char *fmt, ...)\n{\n    static FILE *fd_tr = NULL;\n    static proftime_T start;\n    proftime_T now;\n    va_list ap;\n\n    if (fd_tr == NULL)\n    {\n\tfd_tr = fopen(\"termresponse.log\", \"w\");\n\tprofile_start(&start);\n    }\n    now = start;\n    profile_end(&now);\n    fprintf(fd_tr, \"%s: %s \", profile_msg(&now),\n\t\t\t\t\tmust_redraw == NOT_VALID ? \"NV\"\n\t\t\t\t\t: must_redraw == CLEAR ? \"CL\" : \"  \");\n    va_start(ap, fmt);\n    vfprintf(fd_tr, fmt, ap);\n    va_end(ap);\n    fputc('\\n', fd_tr);\n    fflush(fd_tr);\n}\n# endif\n#endif\n\n/*\n * Return TRUE when saving and restoring the screen.\n */\n    int\nswapping_screen(void)\n{\n    return (full_screen && *T_TI != NUL);\n}\n\n/*\n * By outputting the 'cursor very visible' termcap code, for some windowed\n * terminals this makes the screen scrolled to the correct position.\n * Used when starting Vim or returning from a shell.\n */\n    void\nscroll_start(void)\n{\n    if (*T_VS != NUL && *T_CVS != NUL)\n    {\n\tMAY_WANT_TO_LOG_THIS;\n\tout_str(T_VS);\n\tout_str(T_CVS);\n\tscreen_start();\t\t// don't know where cursor is now\n    }\n}\n\n// True if cursor is not visible\nstatic int cursor_is_off = FALSE;\n\n// True if cursor is not visible due to an ongoing cursor-less sleep\nstatic int cursor_is_asleep = FALSE;\n\n/*\n * Enable the cursor without checking if it's already enabled.\n */\n    void\ncursor_on_force(void)\n{\n    out_str(T_VE);\n    cursor_is_off = FALSE;\n    cursor_is_asleep = FALSE;\n}\n\n/*\n * Enable the cursor if it's currently off.\n */\n    void\ncursor_on(void)\n{\n    if (cursor_is_off && !cursor_is_asleep)\n\tcursor_on_force();\n}\n\n/*\n * Disable the cursor.\n */\n    void\ncursor_off(void)\n{\n    if (full_screen && !cursor_is_off)\n    {\n\tout_str(T_VI);\t    // disable cursor\n\tcursor_is_off = TRUE;\n    }\n}\n\n#ifdef FEAT_GUI\n/*\n * Check whether the cursor is invisible due to an ongoing cursor-less sleep\n */\n    int\ncursor_is_sleeping(void)\n{\n    return cursor_is_asleep;\n}\n#endif\n\n/*\n * Disable the cursor and mark it disabled by cursor-less sleep\n */\n    void\ncursor_sleep(void)\n{\n    cursor_is_asleep = TRUE;\n    cursor_off();\n}\n\n/*\n * Enable the cursor and mark it not disabled by cursor-less sleep\n */\n    void\ncursor_unsleep(void)\n{\n    cursor_is_asleep = FALSE;\n    cursor_on();\n}\n\n#if defined(CURSOR_SHAPE) || defined(PROTO)\n/*\n * Set cursor shape to match Insert or Replace mode.\n */\n    void\nterm_cursor_mode(int forced)\n{\n    static int showing_mode = -1;\n    char_u *p;\n\n    // Only do something when redrawing the screen and we can restore the\n    // mode.\n    if (!full_screen || *T_CEI == NUL)\n    {\n# ifdef FEAT_TERMRESPONSE\n\tif (forced && initial_cursor_shape > 0)\n\t    // Restore to initial values.\n\t    term_cursor_shape(initial_cursor_shape, initial_cursor_blink);\n# endif\n\treturn;\n    }\n\n    if ((State & MODE_REPLACE) == MODE_REPLACE)\n    {\n\tif (forced || showing_mode != MODE_REPLACE)\n\t{\n\t    if (*T_CSR != NUL)\n\t\tp = T_CSR;\t// Replace mode cursor\n\t    else\n\t\tp = T_CSI;\t// fall back to Insert mode cursor\n\t    if (*p != NUL)\n\t    {\n\t\tout_str(p);\n\t\tshowing_mode = MODE_REPLACE;\n\t    }\n\t}\n    }\n    else if (State & MODE_INSERT)\n    {\n\tif ((forced || showing_mode != MODE_INSERT) && *T_CSI != NUL)\n\t{\n\t    out_str(T_CSI);\t    // Insert mode cursor\n\t    showing_mode = MODE_INSERT;\n\t}\n    }\n    else if (forced || showing_mode != MODE_NORMAL)\n    {\n\tout_str(T_CEI);\t\t    // non-Insert mode cursor\n\tshowing_mode = MODE_NORMAL;\n    }\n}\n\n# if defined(FEAT_TERMINAL) || defined(PROTO)\n    void\nterm_cursor_color(char_u *color)\n{\n    if (*T_CSC != NUL)\n    {\n\tout_str(T_CSC);\t\t// set cursor color start\n\tout_str_nf(color);\n\tout_str(T_CEC);\t\t// set cursor color end\n\tout_flush();\n    }\n}\n# endif\n\n    int\nblink_state_is_inverted()\n{\n#ifdef FEAT_TERMRESPONSE\n    return rbm_status.tr_progress == STATUS_GOT\n\t&& rcs_status.tr_progress == STATUS_GOT\n\t\t&& initial_cursor_blink != initial_cursor_shape_blink;\n#else\n    return FALSE;\n#endif\n}\n\n/*\n * \"shape\": 1 = block, 2 = underline, 3 = vertical bar\n */\n    void\nterm_cursor_shape(int shape, int blink)\n{\n    if (*T_CSH != NUL)\n    {\n\tOUT_STR(tgoto((char *)T_CSH, 0, shape * 2 - blink));\n\tout_flush();\n    }\n    else\n    {\n\tint do_blink = blink;\n\n\t// t_SH is empty: try setting just the blink state.\n\t// The blink flags are XORed together, if the initial blinking from\n\t// style and shape differs, we need to invert the flag here.\n\tif (blink_state_is_inverted())\n\t    do_blink = !blink;\n\n\tif (do_blink && *T_VS != NUL)\n\t{\n\t    out_str(T_VS);\n\t    out_flush();\n\t}\n\telse if (!do_blink && *T_CVS != NUL)\n\t{\n\t    out_str(T_CVS);\n\t    out_flush();\n\t}\n    }\n}\n#endif\n\n/*\n * Set scrolling region for window 'wp'.\n * The region starts 'off' lines from the start of the window.\n * Also set the vertical scroll region for a vertically split window.  Always\n * the full width of the window, excluding the vertical separator.\n */\n    void\nscroll_region_set(win_T *wp, int off)\n{\n    OUT_STR(tgoto((char *)T_CS, W_WINROW(wp) + wp->w_height - 1,\n\t\t\t\t\t\t\t W_WINROW(wp) + off));\n    if (*T_CSV != NUL && wp->w_width != Columns)\n\tOUT_STR(tgoto((char *)T_CSV, wp->w_wincol + wp->w_width - 1,\n\t\t\t\t\t\t\t       wp->w_wincol));\n    screen_start();\t\t    // don't know where cursor is now\n}\n\n/*\n * Reset scrolling region to the whole screen.\n */\n    void\nscroll_region_reset(void)\n{\n    OUT_STR(tgoto((char *)T_CS, (int)Rows - 1, 0));\n    if (*T_CSV != NUL)\n\tOUT_STR(tgoto((char *)T_CSV, (int)Columns - 1, 0));\n    screen_start();\t\t    // don't know where cursor is now\n}\n\n\n/*\n * List of terminal codes that are currently recognized.\n */\n\nstatic struct termcode\n{\n    char_u  name[2];\t    // termcap name of entry\n    char_u  *code;\t    // terminal code (in allocated memory)\n    int\t    len;\t    // STRLEN(code)\n    int\t    modlen;\t    // length of part before \";*~\".\n} *termcodes = NULL;\n\nstatic int  tc_max_len = 0; // number of entries that termcodes[] can hold\nstatic int  tc_len = 0;\t    // current number of entries in termcodes[]\n\nstatic int termcode_star(char_u *code, int len);\n\n    void\nclear_termcodes(void)\n{\n    while (tc_len > 0)\n\tvim_free(termcodes[--tc_len].code);\n    VIM_CLEAR(termcodes);\n    tc_max_len = 0;\n\n#ifdef HAVE_TGETENT\n    BC = (char *)empty_option;\n    UP = (char *)empty_option;\n    PC = NUL;\t\t\t// set pad character to NUL\n    ospeed = 0;\n#endif\n\n    need_gather = TRUE;\t\t// need to fill termleader[]\n}\n\n#define ATC_FROM_TERM 55\n\n/*\n * Add a new entry to the list of terminal codes.\n * The list is kept alphabetical for \":set termcap\"\n * \"flags\" is TRUE when replacing 7-bit by 8-bit controls is desired.\n * \"flags\" can also be ATC_FROM_TERM for got_code_from_term().\n */\n    void\nadd_termcode(char_u *name, char_u *string, int flags)\n{\n    struct termcode *new_tc;\n    int\t\t    i, j;\n    char_u\t    *s;\n    int\t\t    len;\n\n    if (string == NULL || *string == NUL)\n    {\n\tdel_termcode(name);\n\treturn;\n    }\n\n#if defined(MSWIN) && !defined(FEAT_GUI)\n    s = vim_strnsave(string, STRLEN(string) + 1);\n#else\n# ifdef VIMDLL\n    if (!gui.in_use)\n\ts = vim_strnsave(string, STRLEN(string) + 1);\n    else\n# endif\n\ts = vim_strsave(string);\n#endif\n    if (s == NULL)\n\treturn;\n\n    // Change leading <Esc>[ to CSI, change <Esc>O to <M-O>.\n    if (flags != 0 && flags != ATC_FROM_TERM && term_7to8bit(string) != 0)\n    {\n\tSTRMOVE(s, s + 1);\n\ts[0] = term_7to8bit(string);\n    }\n\n#if defined(MSWIN) && (!defined(FEAT_GUI) || defined(VIMDLL))\n# ifdef VIMDLL\n    if (!gui.in_use)\n# endif\n    {\n\tif (s[0] == K_NUL)\n\t{\n\t    STRMOVE(s + 1, s);\n\t    s[1] = 3;\n\t}\n    }\n#endif\n\n    len = (int)STRLEN(s);\n\n    need_gather = TRUE;\t\t// need to fill termleader[]\n\n    /*\n     * need to make space for more entries\n     */\n    if (tc_len == tc_max_len)\n    {\n\ttc_max_len += 20;\n\tnew_tc = ALLOC_MULT(struct termcode, tc_max_len);\n\tif (new_tc == NULL)\n\t{\n\t    tc_max_len -= 20;\n\t    vim_free(s);\n\t    return;\n\t}\n\tfor (i = 0; i < tc_len; ++i)\n\t    new_tc[i] = termcodes[i];\n\tvim_free(termcodes);\n\ttermcodes = new_tc;\n    }\n\n    /*\n     * Look for existing entry with the same name, it is replaced.\n     * Look for an existing entry that is alphabetical higher, the new entry\n     * is inserted in front of it.\n     */\n    for (i = 0; i < tc_len; ++i)\n    {\n\tif (termcodes[i].name[0] < name[0])\n\t    continue;\n\tif (termcodes[i].name[0] == name[0])\n\t{\n\t    if (termcodes[i].name[1] < name[1])\n\t\tcontinue;\n\t    /*\n\t     * Exact match: May replace old code.\n\t     */\n\t    if (termcodes[i].name[1] == name[1])\n\t    {\n\t\tif (flags == ATC_FROM_TERM && (j = termcode_star(\n\t\t\t\t    termcodes[i].code, termcodes[i].len)) > 0)\n\t\t{\n\t\t    // Don't replace ESC[123;*X or ESC O*X with another when\n\t\t    // invoked from got_code_from_term().\n\t\t    if (len == termcodes[i].len - j\n\t\t\t    && STRNCMP(s, termcodes[i].code, len - 1) == 0\n\t\t\t    && s[len - 1]\n\t\t\t\t   == termcodes[i].code[termcodes[i].len - 1])\n\t\t    {\n\t\t\t// They are equal but for the \";*\": don't add it.\n\t\t\tvim_free(s);\n\t\t\treturn;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Replace old code.\n\t\t    vim_free(termcodes[i].code);\n\t\t    --tc_len;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\t/*\n\t * Found alphabetical larger entry, move rest to insert new entry\n\t */\n\tfor (j = tc_len; j > i; --j)\n\t    termcodes[j] = termcodes[j - 1];\n\tbreak;\n    }\n\n    termcodes[i].name[0] = name[0];\n    termcodes[i].name[1] = name[1];\n    termcodes[i].code = s;\n    termcodes[i].len = len;\n\n    // For xterm we recognize special codes like \"ESC[42;*X\" and \"ESC O*X\" that\n    // accept modifiers.\n    termcodes[i].modlen = 0;\n    j = termcode_star(s, len);\n    if (j > 0)\n    {\n\ttermcodes[i].modlen = len - 1 - j;\n\t// For \"CSI[@;X\" the \"@\" is not included in \"modlen\".\n\tif (termcodes[i].code[termcodes[i].modlen - 1] == '@')\n\t    --termcodes[i].modlen;\n    }\n    ++tc_len;\n}\n\n/*\n * Check termcode \"code[len]\" for ending in ;*X or *X.\n * The \"X\" can be any character.\n * Return 0 if not found, 2 for ;*X and 1 for *X.\n */\n    static int\ntermcode_star(char_u *code, int len)\n{\n    // Shortest is <M-O>*X.  With ; shortest is <CSI>@;*X\n    if (len >= 3 && code[len - 2] == '*')\n    {\n\tif (len >= 5 && code[len - 3] == ';')\n\t    return 2;\n\telse\n\t    return 1;\n    }\n    return 0;\n}\n\n    char_u  *\nfind_termcode(char_u *name)\n{\n    int\t    i;\n\n    for (i = 0; i < tc_len; ++i)\n\tif (termcodes[i].name[0] == name[0] && termcodes[i].name[1] == name[1])\n\t    return termcodes[i].code;\n    return NULL;\n}\n\n    char_u *\nget_termcode(int i)\n{\n    if (i >= tc_len)\n\treturn NULL;\n    return &termcodes[i].name[0];\n}\n\n/*\n * Returns the length of the terminal code at index 'idx'.\n */\n    int\nget_termcode_len(int idx)\n{\n    return termcodes[idx].len;\n}\n\n    void\ndel_termcode(char_u *name)\n{\n    int\t    i;\n\n    if (termcodes == NULL)\t// nothing there yet\n\treturn;\n\n    need_gather = TRUE;\t\t// need to fill termleader[]\n\n    for (i = 0; i < tc_len; ++i)\n\tif (termcodes[i].name[0] == name[0] && termcodes[i].name[1] == name[1])\n\t{\n\t    del_termcode_idx(i);\n\t    return;\n\t}\n    // not found. Give error message?\n}\n\n    static void\ndel_termcode_idx(int idx)\n{\n    int\t\ti;\n\n    vim_free(termcodes[idx].code);\n    --tc_len;\n    for (i = idx; i < tc_len; ++i)\n\ttermcodes[i] = termcodes[i + 1];\n}\n\n#ifdef FEAT_TERMRESPONSE\n/*\n * Called when detected that the terminal sends 8-bit codes.\n * Convert all 7-bit codes to their 8-bit equivalent.\n */\n    static void\nswitch_to_8bit(void)\n{\n    int\t\ti;\n    int\t\tc;\n\n    // Only need to do something when not already using 8-bit codes.\n    if (!term_is_8bit(T_NAME))\n    {\n\tfor (i = 0; i < tc_len; ++i)\n\t{\n\t    c = term_7to8bit(termcodes[i].code);\n\t    if (c != 0)\n\t    {\n\t\tSTRMOVE(termcodes[i].code + 1, termcodes[i].code + 2);\n\t\ttermcodes[i].code[0] = c;\n\t    }\n\t}\n\tneed_gather = TRUE;\t\t// need to fill termleader[]\n    }\n    detected_8bit = TRUE;\n    LOG_TR((\"Switching to 8 bit\"));\n}\n#endif\n\n#ifdef CHECK_DOUBLE_CLICK\nstatic linenr_T orig_topline = 0;\n# ifdef FEAT_DIFF\nstatic int orig_topfill = 0;\n# endif\n#endif\n#if defined(CHECK_DOUBLE_CLICK) || defined(PROTO)\n/*\n * Checking for double-clicks ourselves.\n * \"orig_topline\" is used to avoid detecting a double-click when the window\n * contents scrolled (e.g., when 'scrolloff' is non-zero).\n */\n/*\n * Set orig_topline.  Used when jumping to another window, so that a double\n * click still works.\n */\n    void\nset_mouse_topline(win_T *wp)\n{\n    orig_topline = wp->w_topline;\n# ifdef FEAT_DIFF\n    orig_topfill = wp->w_topfill;\n# endif\n}\n\n/*\n * Returns TRUE if the top line and top fill of window 'wp' matches the saved\n * topline and topfill.\n */\n    int\nis_mouse_topline(win_T *wp)\n{\n    return orig_topline == wp->w_topline\n#ifdef FEAT_DIFF\n\t&& orig_topfill == wp->w_topfill\n#endif\n\t;\n}\n#endif\n\n/*\n * If \"buf\" is NULL put \"string[new_slen]\" in typebuf; \"buflen\" is not used.\n * If \"buf\" is not NULL put \"string[new_slen]\" in \"buf[bufsize]\" and adjust\n * \"buflen\".\n * Remove \"slen\" bytes.\n * Returns FAIL for error.\n */\n    int\nput_string_in_typebuf(\n\tint\toffset,\n\tint\tslen,\n\tchar_u\t*string,\n\tint\tnew_slen,\n\tchar_u\t*buf,\n\tint\tbufsize,\n\tint\t*buflen)\n{\n    int\t\textra = new_slen - slen;\n\n    string[new_slen] = NUL;\n    if (buf == NULL)\n    {\n\tif (extra < 0)\n\t    // remove matched chars, taking care of noremap\n\t    del_typebuf(-extra, offset);\n\telse if (extra > 0)\n\t    // insert the extra space we need\n\t    if (ins_typebuf(string + slen, REMAP_YES, offset, FALSE, FALSE)\n\t\t\t\t\t\t\t\t       == FAIL)\n\t\treturn FAIL;\n\n\t// Careful: del_typebuf() and ins_typebuf() may have reallocated\n\t// typebuf.tb_buf[]!\n\tmch_memmove(typebuf.tb_buf + typebuf.tb_off + offset, string,\n\t\t\t\t\t\t\t     (size_t)new_slen);\n    }\n    else\n    {\n\tif (extra < 0)\n\t    // remove matched characters\n\t    mch_memmove(buf + offset, buf + offset - extra,\n\t\t\t\t\t   (size_t)(*buflen + offset + extra));\n\telse if (extra > 0)\n\t{\n\t    // Insert the extra space we need.  If there is insufficient\n\t    // space return -1.\n\t    if (*buflen + extra + new_slen >= bufsize)\n\t\treturn FAIL;\n\t    mch_memmove(buf + offset + extra, buf + offset,\n\t\t\t\t\t\t   (size_t)(*buflen - offset));\n\t}\n\tmch_memmove(buf + offset, string, (size_t)new_slen);\n\t*buflen = *buflen + extra + new_slen;\n    }\n    return OK;\n}\n\n/*\n * Decode a modifier number as xterm provides it into MOD_MASK bits.\n */\n    int\ndecode_modifiers(int n)\n{\n    int\t    code = n - 1;\n    int\t    modifiers = 0;\n\n    if (code & 1)\n\tmodifiers |= MOD_MASK_SHIFT;\n    if (code & 2)\n\tmodifiers |= MOD_MASK_ALT;\n    if (code & 4)\n\tmodifiers |= MOD_MASK_CTRL;\n    if (code & 8)\n\tmodifiers |= MOD_MASK_META;\n    return modifiers;\n}\n\n    static int\nmodifiers2keycode(int modifiers, int *key, char_u *string)\n{\n    int new_slen = 0;\n\n    if (modifiers != 0)\n    {\n\t// Some keys have the modifier included.  Need to handle that here to\n\t// make mappings work.  This may result in a special key, such as\n\t// K_S_TAB.\n\t*key = simplify_key(*key, &modifiers);\n\tif (modifiers != 0)\n\t{\n\t    string[new_slen++] = K_SPECIAL;\n\t    string[new_slen++] = (int)KS_MODIFIER;\n\t    string[new_slen++] = modifiers;\n\t}\n    }\n    return new_slen;\n}\n\n#ifdef FEAT_TERMRESPONSE\n/*\n * Handle a cursor position report.\n */\n    static void\nhandle_u7_response(int *arg, char_u *tp UNUSED, int csi_len UNUSED)\n{\n    if (arg[0] == 2 && arg[1] >= 2)\n    {\n\tchar *aw = NULL;\n\n\tLOG_TR((\"Received U7 status: %s\", tp));\n\tu7_status.tr_progress = STATUS_GOT;\n\tdid_cursorhold = TRUE;\n\tif (arg[1] == 2)\n\t    aw = \"single\";\n\telse if (arg[1] == 3)\n\t    aw = \"double\";\n\tif (aw != NULL && STRCMP(aw, p_ambw) != 0)\n\t{\n\t    // Setting the option causes a screen redraw. Do\n\t    // that right away if possible, keeping any\n\t    // messages.\n\t    set_option_value_give_err((char_u *)\"ambw\", 0L, (char_u *)aw, 0);\n# ifdef DEBUG_TERMRESPONSE\n\t    {\n\t\tint r = redraw_asap(CLEAR);\n\n\t\tlog_tr(\"set 'ambiwidth', redraw_asap(): %d\", r);\n\t    }\n# else\n\t    redraw_asap(CLEAR);\n# endif\n# ifdef FEAT_EVAL\n\t    set_vim_var_string(VV_TERMU7RESP, tp, csi_len);\n# endif\n\t}\n    }\n    else if (arg[0] == 3)\n    {\n\tint value;\n\n\tLOG_TR((\"Received compatibility test result: %s\", tp));\n\txcc_status.tr_progress = STATUS_GOT;\n\n\t// Third row: xterm compatibility test.\n\t// If the cursor is on the first column then the terminal can handle\n\t// the request for cursor style and blinking.\n\tvalue = arg[1] == 1 ? TPR_YES : TPR_NO;\n\tterm_props[TPR_CURSOR_STYLE].tpr_status = value;\n\tterm_props[TPR_CURSOR_BLINK].tpr_status = value;\n    }\n}\n\n/*\n * Handle a response to T_CRV: {lead}{first}{x};{vers};{y}c\n * Xterm and alike use '>' for {first}.\n * Rxvt sends \"{lead}?1;2c\".\n */\n    static void\nhandle_version_response(int first, int *arg, int argc, char_u *tp)\n{\n    // The xterm version.  It is set to zero when it can't be an actual xterm\n    // version.\n    int version = arg[1];\n\n    LOG_TR((\"Received CRV response: %s\", tp));\n    crv_status.tr_progress = STATUS_GOT;\n    did_cursorhold = TRUE;\n\n    // Reset terminal properties that are set based on the termresponse.\n    // Mainly useful for tests that send the termresponse multiple times.\n    // For testing all props can be reset.\n    init_term_props(\n#ifdef FEAT_EVAL\n\t    reset_term_props_on_termresponse\n#else\n\t    FALSE\n#endif\n\t    );\n\n    // If this code starts with CSI, you can bet that the\n    // terminal uses 8-bit codes.\n    if (tp[0] == CSI)\n\tswitch_to_8bit();\n\n    // Screen sends 40500.\n    // rxvt sends its version number: \"20703\" is 2.7.3.\n    // Ignore it for when the user has set 'term' to xterm,\n    // even though it's an rxvt.\n    if (version > 20000)\n\tversion = 0;\n\n    // Figure out more if the response is CSI > 99 ; 99 ; 99 c\n    if (first == '>' && argc == 3)\n    {\n\tint need_flush = FALSE;\n\n\t// mintty 2.9.5 sends 77;20905;0c.\n\t// (77 is ASCII 'M' for mintty.)\n\tif (arg[0] == 77)\n\t{\n\t    // mintty can do SGR mouse reporting\n\t    term_props[TPR_MOUSE].tpr_status = TPR_MOUSE_SGR;\n\t}\n\n\t// If xterm version >= 141 try to get termcap codes.  For other\n\t// terminals the request should be ignored.\n\tif (version >= 141 && p_xtermcodes)\n\t{\n\t    LOG_TR((\"Enable checking for XT codes\"));\n\t    check_for_codes = TRUE;\n\t    need_gather = TRUE;\n\t    req_codes_from_term();\n\t}\n\n\t// libvterm sends 0;100;0\n\tif (version == 100 && arg[0] == 0 && arg[2] == 0)\n\t{\n\t    // If run from Vim $COLORS is set to the number of\n\t    // colors the terminal supports.  Otherwise assume\n\t    // 256, libvterm supports even more.\n\t    if (mch_getenv((char_u *)\"COLORS\") == NULL)\n\t\tmay_adjust_color_count(256);\n\t    // Libvterm can handle SGR mouse reporting.\n\t    term_props[TPR_MOUSE].tpr_status = TPR_MOUSE_SGR;\n\t}\n\n\tif (version == 95)\n\t{\n\t    // Mac Terminal.app sends 1;95;0\n\t    if (arg[0] == 1 && arg[2] == 0)\n\t    {\n\t\tterm_props[TPR_UNDERLINE_RGB].tpr_status = TPR_YES;\n\t\tterm_props[TPR_MOUSE].tpr_status = TPR_MOUSE_SGR;\n\t    }\n\t    // iTerm2 sends 0;95;0\n\t    else if (arg[0] == 0 && arg[2] == 0)\n\t    {\n\t\t// iTerm2 can do SGR mouse reporting\n\t\tterm_props[TPR_MOUSE].tpr_status = TPR_MOUSE_SGR;\n\t    }\n\t    // old iTerm2 sends 0;95;\n\t    else if (arg[0] == 0 && arg[2] == -1)\n\t\tterm_props[TPR_UNDERLINE_RGB].tpr_status = TPR_YES;\n\t}\n\n\t// screen sends 83;40500;0 83 is 'S' in ASCII.\n\tif (arg[0] == 83)\n\t{\n\t    // screen supports SGR mouse codes since 4.7.0\n\t    if (arg[1] >= 40700)\n\t\tterm_props[TPR_MOUSE].tpr_status = TPR_MOUSE_SGR;\n\t    else\n\t\tterm_props[TPR_MOUSE].tpr_status = TPR_MOUSE_XTERM;\n\t}\n\n\t// If no recognized terminal has set mouse behavior, assume xterm.\n\tif (term_props[TPR_MOUSE].tpr_status == TPR_UNKNOWN)\n\t{\n\t    // Xterm version 277 supports SGR.\n\t    // Xterm version >= 95 supports mouse dragging.\n\t    if (version >= 277)\n\t\tterm_props[TPR_MOUSE].tpr_status = TPR_MOUSE_SGR;\n\t    else if (version >= 95)\n\t\tterm_props[TPR_MOUSE].tpr_status = TPR_MOUSE_XTERM2;\n\t}\n\n\t// Detect terminals that set $TERM to something like\n\t// \"xterm-256color\" but are not fully xterm compatible.\n\t//\n\t// Gnome terminal sends 1;3801;0, 1;4402;0 or 1;2501;0.\n\t// Newer Gnome-terminal sends 65;6001;1.\n\t// xfce4-terminal sends 1;2802;0.\n\t// screen sends 83;40500;0\n\t// Assuming any version number over 2500 is not an\n\t// xterm (without the limit for rxvt and screen).\n\tif (arg[1] >= 2500)\n\t    term_props[TPR_UNDERLINE_RGB].tpr_status = TPR_YES;\n\n\telse if (version == 136 && arg[2] == 0)\n\t{\n\t    term_props[TPR_UNDERLINE_RGB].tpr_status = TPR_YES;\n\n\t    // PuTTY sends 0;136;0\n\t    if (arg[0] == 0)\n\t    {\n\t\t// supports sgr-like mouse reporting.\n\t\tterm_props[TPR_MOUSE].tpr_status = TPR_MOUSE_SGR;\n\t    }\n\t    // vandyke SecureCRT sends 1;136;0\n\t}\n\n\t// Konsole sends 0;115;0 - but t_u8 does not actually work, therefore\n\t// commented out.\n\t// else if (version == 115 && arg[0] == 0 && arg[2] == 0)\n\t//     term_props[TPR_UNDERLINE_RGB].tpr_status = TPR_YES;\n\n\t// GNU screen sends 83;30600;0, 83;40500;0, etc.\n\t// 30600/40500 is a version number of GNU screen. DA2 support is added\n\t// on 3.6.  DCS string has a special meaning to GNU screen, but xterm\n\t// compatibility checking does not detect GNU screen.\n\tif (arg[0] == 83 && arg[1] >= 30600)\n\t{\n\t    term_props[TPR_CURSOR_STYLE].tpr_status = TPR_NO;\n\t    term_props[TPR_CURSOR_BLINK].tpr_status = TPR_NO;\n\t}\n\n\t// Xterm first responded to this request at patch level\n\t// 95, so assume anything below 95 is not xterm and hopefully supports\n\t// the underline RGB color sequence.\n\tif (version < 95)\n\t    term_props[TPR_UNDERLINE_RGB].tpr_status = TPR_YES;\n\n\t// Getting the cursor style is only supported properly by xterm since\n\t// version 279 (otherwise it returns 0x18).\n\tif (version < 279)\n\t    term_props[TPR_CURSOR_STYLE].tpr_status = TPR_NO;\n\n\t/*\n\t * Take action on the detected properties.\n\t */\n\n\t// Unless the underline RGB color is expected to work, disable \"t_8u\".\n\t// It does not work for the real Xterm, it resets the background color.\n\t// This may cause some flicker.  Alternative would be to set \"t_8u\"\n\t// here if the terminal is expected to support it, but that might\n\t// conflict with what was set in the .vimrc.\n\tif (term_props[TPR_UNDERLINE_RGB].tpr_status != TPR_YES\n\t\t\t&& *T_8U != NUL\n\t\t\t&& !option_was_set((char_u *)\"t_8u\"))\n\t{\n\t    set_string_option_direct((char_u *)\"t_8u\", -1, (char_u *)\"\",\n\t\t\t\t\t\t\t\t  OPT_FREE, 0);\n\t}\n\tif (*T_8U != NUL && write_t_8u_state == MAYBE)\n\t    // Did skip writing t_8u, a complete redraw is needed.\n\t    redraw_later_clear();\n\twrite_t_8u_state = OK;  // can output t_8u now\n\n\t// Only set 'ttymouse' automatically if it was not set\n\t// by the user already.\n\tif (!option_was_set((char_u *)\"ttym\")\n\t\t&& (term_props[TPR_MOUSE].tpr_status == TPR_MOUSE_XTERM2\n\t\t    || term_props[TPR_MOUSE].tpr_status == TPR_MOUSE_SGR))\n\t{\n\t    set_option_value_give_err((char_u *)\"ttym\", 0L,\n\t\t    term_props[TPR_MOUSE].tpr_status == TPR_MOUSE_SGR\n\t\t\t\t    ? (char_u *)\"sgr\" : (char_u *)\"xterm2\", 0);\n\t}\n\n\t// Only request the cursor style if t_SH and t_RS are\n\t// set. Only supported properly by xterm since version\n\t// 279 (otherwise it returns 0x18).\n\t// Only when getting the cursor style was detected to work.\n\t// Not for Terminal.app, it can't handle t_RS, it\n\t// echoes the characters to the screen.\n\tif (rcs_status.tr_progress == STATUS_GET\n\t\t&& term_props[TPR_CURSOR_STYLE].tpr_status == TPR_YES\n\t\t&& *T_CSH != NUL\n\t\t&& *T_CRS != NUL)\n\t{\n\t    MAY_WANT_TO_LOG_THIS;\n\t    LOG_TR((\"Sending cursor style request\"));\n\t    out_str(T_CRS);\n\t    termrequest_sent(&rcs_status);\n\t    need_flush = TRUE;\n\t}\n\n\t// Only request the cursor blink mode if t_RC set. Not\n\t// for Gnome terminal, it can't handle t_RC, it\n\t// echoes the characters to the screen.\n\t// Only when getting the cursor style was detected to work.\n\tif (rbm_status.tr_progress == STATUS_GET\n\t\t&& term_props[TPR_CURSOR_BLINK].tpr_status == TPR_YES\n\t\t&& *T_CRC != NUL)\n\t{\n\t    MAY_WANT_TO_LOG_THIS;\n\t    LOG_TR((\"Sending cursor blink mode request\"));\n\t    out_str(T_CRC);\n\t    termrequest_sent(&rbm_status);\n\t    need_flush = TRUE;\n\t}\n\n\tif (need_flush)\n\t    out_flush();\n    }\n}\n\n/*\n * Handle a sequence with key and modifier, one of:\n *\t{lead}27;{modifier};{key}~\n *\t{lead}{key};{modifier}u\n * Returns the difference in length.\n */\n    static int\nhandle_key_with_modifier(\n\tint\t*arg,\n\tint\ttrail,\n\tint\tcsi_len,\n\tint\toffset,\n\tchar_u\t*buf,\n\tint\tbufsize,\n\tint\t*buflen)\n{\n    int\t    key;\n    int\t    modifiers;\n    int\t    new_slen;\n    char_u  string[MAX_KEY_CODE_LEN + 1];\n\n    seenModifyOtherKeys = TRUE;\n    if (trail == 'u')\n\tkey = arg[0];\n    else\n\tkey = arg[2];\n\n    modifiers = decode_modifiers(arg[1]);\n\n    // Some keys need adjustment when the Ctrl modifier is used.\n    key = may_adjust_key_for_ctrl(modifiers, key);\n\n    // May remove the shift modifier if it's already included in the key.\n    modifiers = may_remove_shift_modifier(modifiers, key);\n\n    // insert modifiers with KS_MODIFIER\n    new_slen = modifiers2keycode(modifiers, &key, string);\n\n    if (IS_SPECIAL(key))\n    {\n\tstring[new_slen++] = K_SPECIAL;\n\tstring[new_slen++] = KEY2TERMCAP0(key);\n\tstring[new_slen++] = KEY2TERMCAP1(key);\n    }\n    else if (has_mbyte)\n\tnew_slen += (*mb_char2bytes)(key, string + new_slen);\n    else\n\tstring[new_slen++] = key;\n\n    if (put_string_in_typebuf(offset, csi_len, string, new_slen,\n\t\t\t\t\t\t buf, bufsize, buflen) == FAIL)\n\treturn -1;\n    return new_slen - csi_len + offset;\n}\n\n/*\n * Handle a CSI escape sequence.\n * - Xterm version string.\n *\n * - Cursor position report: {lead}{row};{col}R\n *   The final byte must be 'R'. It is used for checking the\n *   ambiguous-width character state.\n *\n * - window position reply: {lead}3;{x};{y}t\n *\n * - key with modifiers when modifyOtherKeys is enabled:\n *\t    {lead}27;{modifier};{key}~\n *\t    {lead}{key};{modifier}u\n * Return 0 for no match, -1 for partial match, > 0 for full match.\n */\n    static int\nhandle_csi(\n\tchar_u\t*tp,\n\tint\tlen,\n\tchar_u\t*argp,\n\tint\toffset,\n\tchar_u  *buf,\n\tint\tbufsize,\n\tint\t*buflen,\n\tchar_u\t*key_name,\n\tint\t*slen)\n{\n    int\t\tfirst = -1;  // optional char right after {lead}\n    int\t\ttrail;\t     // char that ends CSI sequence\n    int\t\targ[3] = {-1, -1, -1};\t// argument numbers\n    int\t\targc;\t\t\t// number of arguments\n    char_u\t*ap = argp;\n    int\t\tcsi_len;\n\n    // Check for non-digit after CSI.\n    if (!VIM_ISDIGIT(*ap))\n\tfirst = *ap++;\n\n    // Find up to three argument numbers.\n    for (argc = 0; argc < 3; )\n    {\n\tif (ap >= tp + len)\n\t    return -1;\n\tif (*ap == ';')\n\t    arg[argc++] = -1;  // omitted number\n\telse if (VIM_ISDIGIT(*ap))\n\t{\n\t    arg[argc] = 0;\n\t    for (;;)\n\t    {\n\t\tif (ap >= tp + len)\n\t\t    return -1;\n\t\tif (!VIM_ISDIGIT(*ap))\n\t\t    break;\n\t\targ[argc] = arg[argc] * 10 + (*ap - '0');\n\t\t++ap;\n\t    }\n\t    ++argc;\n\t}\n\tif (*ap == ';')\n\t    ++ap;\n\telse\n\t    break;\n    }\n\n    // mrxvt has been reported to have \"+\" in the version. Assume\n    // the escape sequence ends with a letter or one of \"{|}~\".\n    while (ap < tp + len\n\t    && !(*ap >= '{' && *ap <= '~')\n\t    && !ASCII_ISALPHA(*ap))\n\t++ap;\n    if (ap >= tp + len)\n\treturn -1;\n    trail = *ap;\n    csi_len = (int)(ap - tp) + 1;\n\n    // Cursor position report: Eat it when there are 2 arguments\n    // and it ends in 'R'. Also when u7_status is not \"sent\", it\n    // may be from a previous Vim that just exited.  But not for\n    // <S-F3>, it sends something similar, check for row and column\n    // to make sense.\n    if (first == -1 && argc == 2 && trail == 'R')\n    {\n\thandle_u7_response(arg, tp, csi_len);\n\n\tkey_name[0] = (int)KS_EXTRA;\n\tkey_name[1] = (int)KE_IGNORE;\n\t*slen = csi_len;\n    }\n\n    // Version string: Eat it when there is at least one digit and\n    // it ends in 'c'\n    else if (*T_CRV != NUL && ap > argp + 1 && trail == 'c')\n    {\n\thandle_version_response(first, arg, argc, tp);\n\n\t*slen = csi_len;\n# ifdef FEAT_EVAL\n\tset_vim_var_string(VV_TERMRESPONSE, tp, *slen);\n# endif\n\tapply_autocmds(EVENT_TERMRESPONSE,\n\t\t\t\t\tNULL, NULL, FALSE, curbuf);\n\tkey_name[0] = (int)KS_EXTRA;\n\tkey_name[1] = (int)KE_IGNORE;\n    }\n\n    // Check blinking cursor from xterm:\n    // {lead}?12;1$y       set\n    // {lead}?12;2$y       not set\n    //\n    // {lead} can be <Esc>[ or CSI\n    else if (rbm_status.tr_progress == STATUS_SENT\n\t    && first == '?'\n\t    && ap == argp + 6\n\t    && arg[0] == 12\n\t    && ap[-1] == '$'\n\t    && trail == 'y')\n    {\n\tinitial_cursor_blink = (arg[1] == '1');\n\trbm_status.tr_progress = STATUS_GOT;\n\tLOG_TR((\"Received cursor blinking mode response: %s\", tp));\n\tkey_name[0] = (int)KS_EXTRA;\n\tkey_name[1] = (int)KE_IGNORE;\n\t*slen = csi_len;\n# ifdef FEAT_EVAL\n\tset_vim_var_string(VV_TERMBLINKRESP, tp, *slen);\n# endif\n    }\n\n    // Check for a window position response from the terminal:\n    //       {lead}3;{x};{y}t\n    else if (did_request_winpos && argc == 3 && arg[0] == 3\n\t\t\t\t\t\t   && trail == 't')\n    {\n\twinpos_x = arg[1];\n\twinpos_y = arg[2];\n\t// got finished code: consume it\n\tkey_name[0] = (int)KS_EXTRA;\n\tkey_name[1] = (int)KE_IGNORE;\n\t*slen = csi_len;\n\n\tif (--did_request_winpos <= 0)\n\t    winpos_status.tr_progress = STATUS_GOT;\n    }\n\n    // Key with modifier:\n    //\t{lead}27;{modifier};{key}~\n    //\t{lead}{key};{modifier}u\n    else if ((arg[0] == 27 && argc == 3 && trail == '~')\n\t    || (argc == 2 && trail == 'u'))\n    {\n\treturn len + handle_key_with_modifier(arg, trail,\n\t\t\t    csi_len, offset, buf, bufsize, buflen);\n    }\n\n    // else: Unknown CSI sequence.  We could drop it, but then the\n    // user can't create a map for it.\n    return 0;\n}\n\n/*\n * Handle an OSC sequence, fore/background color response from the terminal:\n *\n *       {lead}{code};rgb:{rrrr}/{gggg}/{bbbb}{tail}\n * or    {lead}{code};rgb:{rr}/{gg}/{bb}{tail}\n *\n * {code} is 10 for foreground, 11 for background\n * {lead} can be <Esc>] or OSC\n * {tail} can be '\\007', <Esc>\\ or STERM.\n *\n * Consume any code that starts with \"{lead}11;\", it's also\n * possible that \"rgba\" is following.\n */\n    static int\nhandle_osc(char_u *tp, char_u *argp, int len, char_u *key_name, int *slen)\n{\n    int\t\ti, j;\n\n    j = 1 + (tp[0] == ESC);\n    if (len >= j + 3 && (argp[0] != '1'\n\t\t\t     || (argp[1] != '1' && argp[1] != '0')\n\t\t\t     || argp[2] != ';'))\n\ti = 0; // no match\n    else\n\tfor (i = j; i < len; ++i)\n\t    if (tp[i] == '\\007' || (tp[0] == OSC ? tp[i] == STERM\n\t\t\t: (tp[i] == ESC && i + 1 < len && tp[i + 1] == '\\\\')))\n\t    {\n\t\tint is_bg = argp[1] == '1';\n\t\tint is_4digit = i - j >= 21 && tp[j + 11] == '/'\n\t\t\t\t\t\t  && tp[j + 16] == '/';\n\n\t\tif (i - j >= 15 && STRNCMP(tp + j + 3, \"rgb:\", 4) == 0\n\t\t\t    && (is_4digit\n\t\t\t\t   || (tp[j + 9] == '/' && tp[i + 12 == '/'])))\n\t\t{\n\t\t    char_u *tp_r = tp + j + 7;\n\t\t    char_u *tp_g = tp + j + (is_4digit ? 12 : 10);\n\t\t    char_u *tp_b = tp + j + (is_4digit ? 17 : 13);\n# ifdef FEAT_TERMINAL\n\t\t    int rval, gval, bval;\n\n\t\t    rval = hexhex2nr(tp_r);\n\t\t    gval = hexhex2nr(tp_b);\n\t\t    bval = hexhex2nr(tp_g);\n# endif\n\t\t    if (is_bg)\n\t\t    {\n\t\t\tchar *new_bg_val = (3 * '6' < *tp_r + *tp_g +\n\t\t\t\t\t     *tp_b) ? \"light\" : \"dark\";\n\n\t\t\tLOG_TR((\"Received RBG response: %s\", tp));\n\t\t\trbg_status.tr_progress = STATUS_GOT;\n# ifdef FEAT_TERMINAL\n\t\t\tbg_r = rval;\n\t\t\tbg_g = gval;\n\t\t\tbg_b = bval;\n# endif\n\t\t\tif (!option_was_set((char_u *)\"bg\")\n\t\t\t\t      && STRCMP(p_bg, new_bg_val) != 0)\n\t\t\t{\n\t\t\t    // value differs, apply it\n\t\t\t    set_option_value_give_err((char_u *)\"bg\",\n\t\t\t\t\t\t  0L, (char_u *)new_bg_val, 0);\n\t\t\t    reset_option_was_set((char_u *)\"bg\");\n\t\t\t    redraw_asap(CLEAR);\n\t\t\t}\n\t\t    }\n# ifdef FEAT_TERMINAL\n\t\t    else\n\t\t    {\n\t\t\tLOG_TR((\"Received RFG response: %s\", tp));\n\t\t\trfg_status.tr_progress = STATUS_GOT;\n\t\t\tfg_r = rval;\n\t\t\tfg_g = gval;\n\t\t\tfg_b = bval;\n\t\t    }\n# endif\n\t\t}\n\n\t\t// got finished code: consume it\n\t\tkey_name[0] = (int)KS_EXTRA;\n\t\tkey_name[1] = (int)KE_IGNORE;\n\t\t*slen = i + 1 + (tp[i] == ESC);\n# ifdef FEAT_EVAL\n\t\tset_vim_var_string(is_bg ? VV_TERMRBGRESP\n\t\t\t\t\t\t  : VV_TERMRFGRESP, tp, *slen);\n# endif\n\t\tbreak;\n\t    }\n    if (i == len)\n    {\n\tLOG_TR((\"not enough characters for RB\"));\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Check for key code response from xterm:\n * {lead}{flag}+r<hex bytes><{tail}\n *\n * {lead} can be <Esc>P or DCS\n * {flag} can be '0' or '1'\n * {tail} can be Esc>\\ or STERM\n *\n * Check for cursor shape response from xterm:\n * {lead}1$r<digit> q{tail}\n *\n * {lead} can be <Esc>P or DCS\n * {tail} can be <Esc>\\ or STERM\n *\n * Consume any code that starts with \"{lead}.+r\" or \"{lead}.$r\".\n */\n    static int\nhandle_dcs(char_u *tp, char_u *argp, int len, char_u *key_name, int *slen)\n{\n    int i, j;\n\n    j = 1 + (tp[0] == ESC);\n    if (len < j + 3)\n\ti = len; // need more chars\n    else if ((argp[1] != '+' && argp[1] != '$') || argp[2] != 'r')\n\ti = 0; // no match\n    else if (argp[1] == '+')\n\t// key code response\n\tfor (i = j; i < len; ++i)\n\t{\n\t    if ((tp[i] == ESC && i + 1 < len && tp[i + 1] == '\\\\')\n\t\t    || tp[i] == STERM)\n\t    {\n\t\tif (i - j >= 3)\n\t\t    got_code_from_term(tp + j, i);\n\t\tkey_name[0] = (int)KS_EXTRA;\n\t\tkey_name[1] = (int)KE_IGNORE;\n\t\t*slen = i + 1 + (tp[i] == ESC);\n\t\tbreak;\n\t    }\n\t}\n    else\n    {\n\t// Probably the cursor shape response.  Make sure that \"i\"\n\t// is equal to \"len\" when there are not sufficient\n\t// characters.\n\tfor (i = j + 3; i < len; ++i)\n\t{\n\t    if (i - j == 3 && !isdigit(tp[i]))\n\t\tbreak;\n\t    if (i - j == 4 && tp[i] != ' ')\n\t\tbreak;\n\t    if (i - j == 5 && tp[i] != 'q')\n\t\tbreak;\n\t    if (i - j == 6 && tp[i] != ESC && tp[i] != STERM)\n\t\tbreak;\n\t    if ((i - j == 6 && tp[i] == STERM)\n\t     || (i - j == 7 && tp[i] == '\\\\'))\n\t    {\n\t\tint number = argp[3] - '0';\n\n\t\t// 0, 1 = block blink, 2 = block\n\t\t// 3 = underline blink, 4 = underline\n\t\t// 5 = vertical bar blink, 6 = vertical bar\n\t\tnumber = number == 0 ? 1 : number;\n\t\tinitial_cursor_shape = (number + 1) / 2;\n\t\t// The blink flag is actually inverted, compared to\n\t\t// the value set with T_SH.\n\t\tinitial_cursor_shape_blink =\n\t\t\t\t       (number & 1) ? FALSE : TRUE;\n\t\trcs_status.tr_progress = STATUS_GOT;\n\t\tLOG_TR((\"Received cursor shape response: %s\", tp));\n\n\t\tkey_name[0] = (int)KS_EXTRA;\n\t\tkey_name[1] = (int)KE_IGNORE;\n\t\t*slen = i + 1;\n# ifdef FEAT_EVAL\n\t\tset_vim_var_string(VV_TERMSTYLERESP, tp, *slen);\n# endif\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    if (i == len)\n    {\n\t// These codes arrive many together, each code can be\n\t// truncated at any point.\n\tLOG_TR((\"not enough characters for XT\"));\n\treturn FAIL;\n    }\n    return OK;\n}\n#endif // FEAT_TERMRESPONSE\n\n/*\n * Check if typebuf.tb_buf[] contains a terminal key code.\n * Check from typebuf.tb_buf[typebuf.tb_off] to typebuf.tb_buf[typebuf.tb_off\n * + \"max_offset\"].\n * Return 0 for no match, -1 for partial match, > 0 for full match.\n * Return KEYLEN_REMOVED when a key code was deleted.\n * With a match, the match is removed, the replacement code is inserted in\n * typebuf.tb_buf[] and the number of characters in typebuf.tb_buf[] is\n * returned.\n * When \"buf\" is not NULL, buf[bufsize] is used instead of typebuf.tb_buf[].\n * \"buflen\" is then the length of the string in buf[] and is updated for\n * inserts and deletes.\n */\n    int\ncheck_termcode(\n    int\t\tmax_offset,\n    char_u\t*buf,\n    int\t\tbufsize,\n    int\t\t*buflen)\n{\n    char_u\t*tp;\n    char_u\t*p;\n    int\t\tslen = 0;\t// init for GCC\n    int\t\tmodslen;\n    int\t\tlen;\n    int\t\tretval = 0;\n    int\t\toffset;\n    char_u\tkey_name[2];\n    int\t\tmodifiers;\n    char_u\t*modifiers_start = NULL;\n    int\t\tkey;\n    int\t\tnew_slen;   // Length of what will replace the termcode\n    char_u\tstring[MAX_KEY_CODE_LEN + 1];\n    int\t\ti, j;\n    int\t\tidx = 0;\n    int\t\tcpo_koffset;\n\n    cpo_koffset = (vim_strchr(p_cpo, CPO_KOFFSET) != NULL);\n\n    /*\n     * Speed up the checks for terminal codes by gathering all first bytes\n     * used in termleader[].  Often this is just a single <Esc>.\n     */\n    if (need_gather)\n\tgather_termleader();\n\n    /*\n     * Check at several positions in typebuf.tb_buf[], to catch something like\n     * \"x<Up>\" that can be mapped. Stop at max_offset, because characters\n     * after that cannot be used for mapping, and with @r commands\n     * typebuf.tb_buf[] can become very long.\n     * This is used often, KEEP IT FAST!\n     */\n    for (offset = 0; offset < max_offset; ++offset)\n    {\n\tif (buf == NULL)\n\t{\n\t    if (offset >= typebuf.tb_len)\n\t\tbreak;\n\t    tp = typebuf.tb_buf + typebuf.tb_off + offset;\n\t    len = typebuf.tb_len - offset;\t// length of the input\n\t}\n\telse\n\t{\n\t    if (offset >= *buflen)\n\t\tbreak;\n\t    tp = buf + offset;\n\t    len = *buflen - offset;\n\t}\n\n\t/*\n\t * Don't check characters after K_SPECIAL, those are already\n\t * translated terminal chars (avoid translating ~@^Hx).\n\t */\n\tif (*tp == K_SPECIAL)\n\t{\n\t    offset += 2;\t// there are always 2 extra characters\n\t    continue;\n\t}\n\n\t/*\n\t * Skip this position if the character does not appear as the first\n\t * character in term_strings. This speeds up a lot, since most\n\t * termcodes start with the same character (ESC or CSI).\n\t */\n\ti = *tp;\n\tfor (p = termleader; *p && *p != i; ++p)\n\t    ;\n\tif (*p == NUL)\n\t    continue;\n\n\t/*\n\t * Skip this position if p_ek is not set and tp[0] is an ESC and we\n\t * are in Insert mode.\n\t */\n\tif (*tp == ESC && !p_ek && (State & MODE_INSERT))\n\t    continue;\n\n\tkey_name[0] = NUL;\t// no key name found yet\n\tkey_name[1] = NUL;\t// no key name found yet\n\tmodifiers = 0;\t\t// no modifiers yet\n\n#ifdef FEAT_GUI\n\tif (gui.in_use)\n\t{\n\t    /*\n\t     * GUI special key codes are all of the form [CSI xx].\n\t     */\n\t    if (*tp == CSI)\t    // Special key from GUI\n\t    {\n\t\tif (len < 3)\n\t\t    return -1;\t    // Shouldn't happen\n\t\tslen = 3;\n\t\tkey_name[0] = tp[1];\n\t\tkey_name[1] = tp[2];\n\t    }\n\t}\n\telse\n#endif // FEAT_GUI\n\t{\n\t    int  mouse_index_found = -1;\n\n\t    for (idx = 0; idx < tc_len; ++idx)\n\t    {\n\t\t/*\n\t\t * Ignore the entry if we are not at the start of\n\t\t * typebuf.tb_buf[]\n\t\t * and there are not enough characters to make a match.\n\t\t * But only when the 'K' flag is in 'cpoptions'.\n\t\t */\n\t\tslen = termcodes[idx].len;\n\t\tmodifiers_start = NULL;\n\t\tif (cpo_koffset && offset && len < slen)\n\t\t    continue;\n\t\tif (STRNCMP(termcodes[idx].code, tp,\n\t\t\t\t     (size_t)(slen > len ? len : slen)) == 0)\n\t\t{\n\t\t    int\t    looks_like_mouse_start = FALSE;\n\n\t\t    if (len < slen)\t\t// got a partial sequence\n\t\t\treturn -1;\t\t// need to get more chars\n\n\t\t    /*\n\t\t     * When found a keypad key, check if there is another key\n\t\t     * that matches and use that one.  This makes <Home> to be\n\t\t     * found instead of <kHome> when they produce the same\n\t\t     * key code.\n\t\t     */\n\t\t    if (termcodes[idx].name[0] == 'K'\n\t\t\t\t       && VIM_ISDIGIT(termcodes[idx].name[1]))\n\t\t    {\n\t\t\tfor (j = idx + 1; j < tc_len; ++j)\n\t\t\t    if (termcodes[j].len == slen &&\n\t\t\t\t    STRNCMP(termcodes[idx].code,\n\t\t\t\t\t    termcodes[j].code, slen) == 0)\n\t\t\t    {\n\t\t\t\tidx = j;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t    }\n\n\t\t    if (slen == 2 && len > 2\n\t\t\t    && termcodes[idx].code[0] == ESC\n\t\t\t    && termcodes[idx].code[1] == '[')\n\t\t    {\n\t\t\t// The mouse termcode \"ESC [\" is also the prefix of\n\t\t\t// \"ESC [ I\" (focus gained) and other keys.  Check some\n\t\t\t// more bytes to find out.\n\t\t\tif (!isdigit(tp[2]))\n\t\t\t{\n\t\t\t    // ESC [ without number following: Only use it when\n\t\t\t    // there is no other match.\n\t\t\t    looks_like_mouse_start = TRUE;\n\t\t\t}\n\t\t\telse if (termcodes[idx].name[0] == KS_DEC_MOUSE)\n\t\t\t{\n\t\t\t    char_u  *nr = tp + 2;\n\t\t\t    int\t    count = 0;\n\n\t\t\t    // If a digit is following it could be a key with\n\t\t\t    // modifier, e.g., ESC [ 1;2P.  Can be confused\n\t\t\t    // with DEC_MOUSE, which requires four numbers\n\t\t\t    // following.  If not then it can't be a DEC_MOUSE\n\t\t\t    // code.\n\t\t\t    for (;;)\n\t\t\t    {\n\t\t\t\t++count;\n\t\t\t\t(void)getdigits(&nr);\n\t\t\t\tif (nr >= tp + len)\n\t\t\t\t    return -1;\t// partial sequence\n\t\t\t\tif (*nr != ';')\n\t\t\t\t    break;\n\t\t\t\t++nr;\n\t\t\t\tif (nr >= tp + len)\n\t\t\t\t    return -1;\t// partial sequence\n\t\t\t    }\n\t\t\t    if (count < 4)\n\t\t\t\tcontinue;\t// no match\n\t\t\t}\n\t\t    }\n\t\t    if (looks_like_mouse_start)\n\t\t    {\n\t\t\t// Only use it when there is no other match.\n\t\t\tif (mouse_index_found < 0)\n\t\t\t    mouse_index_found = idx;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tkey_name[0] = termcodes[idx].name[0];\n\t\t\tkey_name[1] = termcodes[idx].name[1];\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\n\t\t/*\n\t\t * Check for code with modifier, like xterm uses:\n\t\t * <Esc>[123;*X  (modslen == slen - 3)\n\t\t * <Esc>[@;*X    (matches <Esc>[X and <Esc>[1;9X )\n\t\t * Also <Esc>O*X and <M-O>*X (modslen == slen - 2).\n\t\t * When there is a modifier the * matches a number.\n\t\t * When there is no modifier the ;* or * is omitted.\n\t\t */\n\t\tif (termcodes[idx].modlen > 0 && mouse_index_found < 0)\n\t\t{\n\t\t    int at_code;\n\n\t\t    modslen = termcodes[idx].modlen;\n\t\t    if (cpo_koffset && offset && len < modslen)\n\t\t\tcontinue;\n\t\t    at_code = termcodes[idx].code[modslen] == '@';\n\t\t    if (STRNCMP(termcodes[idx].code, tp,\n\t\t\t\t(size_t)(modslen > len ? len : modslen)) == 0)\n\t\t    {\n\t\t\tint\t    n;\n\n\t\t\tif (len <= modslen)\t// got a partial sequence\n\t\t\t    return -1;\t\t// need to get more chars\n\n\t\t\tif (tp[modslen] == termcodes[idx].code[slen - 1])\n\t\t\t    // no modifiers\n\t\t\t    slen = modslen + 1;\n\t\t\telse if (tp[modslen] != ';' && modslen == slen - 3)\n\t\t\t    // no match for \"code;*X\" with \"code;\"\n\t\t\t    continue;\n\t\t\telse if (at_code && tp[modslen] != '1')\n\t\t\t    // no match for \"<Esc>[@\" with \"<Esc>[1\"\n\t\t\t    continue;\n\t\t\telse\n\t\t\t{\n\t\t\t    // Skip over the digits, the final char must\n\t\t\t    // follow. URXVT can use a negative value, thus\n\t\t\t    // also accept '-'.\n\t\t\t    for (j = slen - 2; j < len && (isdigit(tp[j])\n\t\t\t\t       || tp[j] == '-' || tp[j] == ';'); ++j)\n\t\t\t\t;\n\t\t\t    ++j;\n\t\t\t    if (len < j)\t// got a partial sequence\n\t\t\t\treturn -1;\t// need to get more chars\n\t\t\t    if (tp[j - 1] != termcodes[idx].code[slen - 1])\n\t\t\t\tcontinue;\t// no match\n\n\t\t\t    modifiers_start = tp + slen - 2;\n\n\t\t\t    // Match!  Convert modifier bits.\n\t\t\t    n = atoi((char *)modifiers_start);\n\t\t\t    modifiers |= decode_modifiers(n);\n\n\t\t\t    slen = j;\n\t\t\t}\n\t\t\tkey_name[0] = termcodes[idx].name[0];\n\t\t\tkey_name[1] = termcodes[idx].name[1];\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t    if (idx == tc_len && mouse_index_found >= 0)\n\t    {\n\t\tkey_name[0] = termcodes[mouse_index_found].name[0];\n\t\tkey_name[1] = termcodes[mouse_index_found].name[1];\n\t    }\n\t}\n\n#ifdef FEAT_TERMRESPONSE\n\tif (key_name[0] == NUL\n\t    // Mouse codes of DEC and pterm start with <ESC>[.  When\n\t    // detecting the start of these mouse codes they might as well be\n\t    // another key code or terminal response.\n# ifdef FEAT_MOUSE_DEC\n\t    || key_name[0] == KS_DEC_MOUSE\n# endif\n# ifdef FEAT_MOUSE_PTERM\n\t    || key_name[0] == KS_PTERM_MOUSE\n# endif\n\t   )\n\t{\n\t    char_u *argp = tp[0] == ESC ? tp + 2 : tp + 1;\n\n\t    /*\n\t     * Check for responses from the terminal starting with {lead}:\n\t     * \"<Esc>[\" or CSI followed by [0-9>?]\n\t     *\n\t     * - Xterm version string: {lead}>{x};{vers};{y}c\n\t     *   Also eat other possible responses to t_RV, rxvt returns\n\t     *   \"{lead}?1;2c\".\n\t     *\n\t     * - Cursor position report: {lead}{row};{col}R\n\t     *   The final byte must be 'R'. It is used for checking the\n\t     *   ambiguous-width character state.\n\t     *\n\t     * - window position reply: {lead}3;{x};{y}t\n\t     *\n\t     * - key with modifiers when modifyOtherKeys is enabled:\n\t     *\t    {lead}27;{modifier};{key}~\n\t     *\t    {lead}{key};{modifier}u\n\t     */\n\t    if (((tp[0] == ESC && len >= 3 && tp[1] == '[')\n\t\t\t    || (tp[0] == CSI && len >= 2))\n\t\t    && (VIM_ISDIGIT(*argp) || *argp == '>' || *argp == '?'))\n\t    {\n\t\tint resp = handle_csi(tp, len, argp, offset, buf,\n\t\t\t\t\t     bufsize, buflen, key_name, &slen);\n\t\tif (resp != 0)\n\t\t{\n# ifdef DEBUG_TERMRESPONSE\n\t\t    if (resp == -1)\n\t\t\tLOG_TR((\"Not enough characters for CSI sequence\"));\n# endif\n\t\t    return resp;\n\t\t}\n\t    }\n\n\t    // Check for fore/background color response from the terminal,\n\t    // starting} with <Esc>] or OSC\n\t    else if ((*T_RBG != NUL || *T_RFG != NUL)\n\t\t\t&& ((tp[0] == ESC && len >= 2 && tp[1] == ']')\n\t\t\t    || tp[0] == OSC))\n\t    {\n\t\tif (handle_osc(tp, argp, len, key_name, &slen) == FAIL)\n\t\t    return -1;\n\t    }\n\n\t    // Check for key code response from xterm,\n\t    // starting with <Esc>P or DCS\n\t    else if ((check_for_codes || rcs_status.tr_progress == STATUS_SENT)\n\t\t    && ((tp[0] == ESC && len >= 2 && tp[1] == 'P')\n\t\t\t|| tp[0] == DCS))\n\t    {\n\t\tif (handle_dcs(tp, argp, len, key_name, &slen) == FAIL)\n\t\t    return -1;\n\t    }\n\t}\n#endif\n\n\tif (key_name[0] == NUL)\n\t    continue;\t    // No match at this position, try next one\n\n\t// We only get here when we have a complete termcode match\n\n#ifdef FEAT_GUI\n\t/*\n\t * Only in the GUI: Fetch the pointer coordinates of the scroll event\n\t * so that we know which window to scroll later.\n\t */\n\tif (gui.in_use\n\t\t&& key_name[0] == (int)KS_EXTRA\n\t\t&& (key_name[1] == (int)KE_X1MOUSE\n\t\t    || key_name[1] == (int)KE_X2MOUSE\n\t\t    || key_name[1] == (int)KE_MOUSEMOVE_XY\n\t\t    || key_name[1] == (int)KE_MOUSELEFT\n\t\t    || key_name[1] == (int)KE_MOUSERIGHT\n\t\t    || key_name[1] == (int)KE_MOUSEDOWN\n\t\t    || key_name[1] == (int)KE_MOUSEUP))\n\t{\n\t    char_u\tbytes[6];\n\t    int\t\tnum_bytes = get_bytes_from_buf(tp + slen, bytes, 4);\n\n\t    if (num_bytes == -1)\t// not enough coordinates\n\t\treturn -1;\n\t    mouse_col = 128 * (bytes[0] - ' ' - 1) + bytes[1] - ' ' - 1;\n\t    mouse_row = 128 * (bytes[2] - ' ' - 1) + bytes[3] - ' ' - 1;\n\t    slen += num_bytes;\n\t    // equal to K_MOUSEMOVE\n\t    if (key_name[1] == (int)KE_MOUSEMOVE_XY)\n\t\tkey_name[1] = (int)KE_MOUSEMOVE;\n\t}\n\telse\n#endif\n\t/*\n\t * If it is a mouse click, get the coordinates.\n\t */\n\tif (key_name[0] == KS_MOUSE\n#ifdef FEAT_MOUSE_GPM\n\t\t|| key_name[0] == KS_GPM_MOUSE\n#endif\n#ifdef FEAT_MOUSE_JSB\n\t\t|| key_name[0] == KS_JSBTERM_MOUSE\n#endif\n#ifdef FEAT_MOUSE_NET\n\t\t|| key_name[0] == KS_NETTERM_MOUSE\n#endif\n#ifdef FEAT_MOUSE_DEC\n\t\t|| key_name[0] == KS_DEC_MOUSE\n#endif\n#ifdef FEAT_MOUSE_PTERM\n\t\t|| key_name[0] == KS_PTERM_MOUSE\n#endif\n#ifdef FEAT_MOUSE_URXVT\n\t\t|| key_name[0] == KS_URXVT_MOUSE\n#endif\n\t\t|| key_name[0] == KS_SGR_MOUSE\n\t\t|| key_name[0] == KS_SGR_MOUSE_RELEASE)\n\t{\n\t    if (check_termcode_mouse(tp, &slen, key_name, modifiers_start, idx,\n\t\t\t\t\t\t\t     &modifiers) == -1)\n\t\treturn -1;\n\t}\n\n#ifdef FEAT_GUI\n\t/*\n\t * If using the GUI, then we get menu and scrollbar events.\n\t *\n\t * A menu event is encoded as K_SPECIAL, KS_MENU, KE_FILLER followed by\n\t * four bytes which are to be taken as a pointer to the vimmenu_T\n\t * structure.\n\t *\n\t * A tab line event is encoded as K_SPECIAL KS_TABLINE nr, where \"nr\"\n\t * is one byte with the tab index.\n\t *\n\t * A scrollbar event is K_SPECIAL, KS_VER_SCROLLBAR, KE_FILLER followed\n\t * by one byte representing the scrollbar number, and then four bytes\n\t * representing a long_u which is the new value of the scrollbar.\n\t *\n\t * A horizontal scrollbar event is K_SPECIAL, KS_HOR_SCROLLBAR,\n\t * KE_FILLER followed by four bytes representing a long_u which is the\n\t * new value of the scrollbar.\n\t */\n# ifdef FEAT_MENU\n\telse if (key_name[0] == (int)KS_MENU)\n\t{\n\t    long_u\tval;\n\t    int\t\tnum_bytes = get_long_from_buf(tp + slen, &val);\n\n\t    if (num_bytes == -1)\n\t\treturn -1;\n\t    current_menu = (vimmenu_T *)val;\n\t    slen += num_bytes;\n\n\t    // The menu may have been deleted right after it was used, check\n\t    // for that.\n\t    if (check_menu_pointer(root_menu, current_menu) == FAIL)\n\t    {\n\t\tkey_name[0] = KS_EXTRA;\n\t\tkey_name[1] = (int)KE_IGNORE;\n\t    }\n\t}\n# endif\n# ifdef FEAT_GUI_TABLINE\n\telse if (key_name[0] == (int)KS_TABLINE)\n\t{\n\t    // Selecting tabline tab or using its menu.\n\t    char_u\tbytes[6];\n\t    int\t\tnum_bytes = get_bytes_from_buf(tp + slen, bytes, 1);\n\n\t    if (num_bytes == -1)\n\t\treturn -1;\n\t    current_tab = (int)bytes[0];\n\t    if (current_tab == 255)\t// -1 in a byte gives 255\n\t\tcurrent_tab = -1;\n\t    slen += num_bytes;\n\t}\n\telse if (key_name[0] == (int)KS_TABMENU)\n\t{\n\t    // Selecting tabline tab or using its menu.\n\t    char_u\tbytes[6];\n\t    int\t\tnum_bytes = get_bytes_from_buf(tp + slen, bytes, 2);\n\n\t    if (num_bytes == -1)\n\t\treturn -1;\n\t    current_tab = (int)bytes[0];\n\t    current_tabmenu = (int)bytes[1];\n\t    slen += num_bytes;\n\t}\n# endif\n# ifndef USE_ON_FLY_SCROLL\n\telse if (key_name[0] == (int)KS_VER_SCROLLBAR)\n\t{\n\t    long_u\tval;\n\t    char_u\tbytes[6];\n\t    int\t\tnum_bytes;\n\n\t    // Get the last scrollbar event in the queue of the same type\n\t    j = 0;\n\t    for (i = 0; tp[j] == CSI && tp[j + 1] == KS_VER_SCROLLBAR\n\t\t\t\t\t\t     && tp[j + 2] != NUL; ++i)\n\t    {\n\t\tj += 3;\n\t\tnum_bytes = get_bytes_from_buf(tp + j, bytes, 1);\n\t\tif (num_bytes == -1)\n\t\t    break;\n\t\tif (i == 0)\n\t\t    current_scrollbar = (int)bytes[0];\n\t\telse if (current_scrollbar != (int)bytes[0])\n\t\t    break;\n\t\tj += num_bytes;\n\t\tnum_bytes = get_long_from_buf(tp + j, &val);\n\t\tif (num_bytes == -1)\n\t\t    break;\n\t\tscrollbar_value = val;\n\t\tj += num_bytes;\n\t\tslen = j;\n\t    }\n\t    if (i == 0)\t\t// not enough characters to make one\n\t\treturn -1;\n\t}\n\telse if (key_name[0] == (int)KS_HOR_SCROLLBAR)\n\t{\n\t    long_u\tval;\n\t    int\t\tnum_bytes;\n\n\t    // Get the last horiz. scrollbar event in the queue\n\t    j = 0;\n\t    for (i = 0; tp[j] == CSI && tp[j + 1] == KS_HOR_SCROLLBAR\n\t\t\t\t\t\t     && tp[j + 2] != NUL; ++i)\n\t    {\n\t\tj += 3;\n\t\tnum_bytes = get_long_from_buf(tp + j, &val);\n\t\tif (num_bytes == -1)\n\t\t    break;\n\t\tscrollbar_value = val;\n\t\tj += num_bytes;\n\t\tslen = j;\n\t    }\n\t    if (i == 0)\t\t// not enough characters to make one\n\t\treturn -1;\n\t}\n# endif // !USE_ON_FLY_SCROLL\n#endif // FEAT_GUI\n\n#if (defined(UNIX) || defined(VMS))\n\t/*\n\t * Handle FocusIn/FocusOut event sequences reported by XTerm.\n\t * (CSI I/CSI O)\n\t */\n\tif (key_name[0] == KS_EXTRA\n# ifdef FEAT_GUI\n\t\t&& !gui.in_use\n# endif\n\t    )\n\t{\n\t    if (key_name[1] == KE_FOCUSGAINED)\n\t    {\n\t\tif (!focus_state)\n\t\t{\n\t\t    ui_focus_change(TRUE);\n\t\t    did_cursorhold = TRUE;\n\t\t    focus_state = TRUE;\n\t\t}\n\t\tkey_name[1] = (int)KE_IGNORE;\n\t    }\n\t    else if (key_name[1] == KE_FOCUSLOST)\n\t    {\n\t\tif (focus_state)\n\t\t{\n\t\t    ui_focus_change(FALSE);\n\t\t    did_cursorhold = TRUE;\n\t\t    focus_state = FALSE;\n\t\t}\n\t\tkey_name[1] = (int)KE_IGNORE;\n\t    }\n\t}\n#endif\n\n\t/*\n\t * Change <xHome> to <Home>, <xUp> to <Up>, etc.\n\t */\n\tkey = handle_x_keys(TERMCAP2KEY(key_name[0], key_name[1]));\n\n\t/*\n\t * Add any modifier codes to our string.\n\t */\n\tnew_slen = modifiers2keycode(modifiers, &key, string);\n\n\t// Finally, add the special key code to our string\n\tkey_name[0] = KEY2TERMCAP0(key);\n\tkey_name[1] = KEY2TERMCAP1(key);\n\tif (key_name[0] == KS_KEY)\n\t{\n\t    // from \":set <M-b>=xx\"\n\t    if (has_mbyte)\n\t\tnew_slen += (*mb_char2bytes)(key_name[1], string + new_slen);\n\t    else\n\t\tstring[new_slen++] = key_name[1];\n\t}\n\telse if (new_slen == 0 && key_name[0] == KS_EXTRA\n\t\t\t\t\t\t  && key_name[1] == KE_IGNORE)\n\t{\n\t    // Do not put K_IGNORE into the buffer, do return KEYLEN_REMOVED\n\t    // to indicate what happened.\n\t    retval = KEYLEN_REMOVED;\n\t}\n\telse\n\t{\n\t    string[new_slen++] = K_SPECIAL;\n\t    string[new_slen++] = key_name[0];\n\t    string[new_slen++] = key_name[1];\n\t}\n\tif (put_string_in_typebuf(offset, slen, string, new_slen,\n\t\t\t\t\t\t buf, bufsize, buflen) == FAIL)\n\t    return -1;\n\treturn retval == 0 ? (len + new_slen - slen + offset) : retval;\n    }\n\n#ifdef FEAT_TERMRESPONSE\n    LOG_TR((\"normal character\"));\n#endif\n\n    return 0;\t\t\t    // no match found\n}\n\n#if (defined(FEAT_TERMINAL) && defined(FEAT_TERMRESPONSE)) || defined(PROTO)\n/*\n * Get the text foreground color, if known.\n */\n    void\nterm_get_fg_color(char_u *r, char_u *g, char_u *b)\n{\n    if (rfg_status.tr_progress == STATUS_GOT)\n    {\n\t*r = fg_r;\n\t*g = fg_g;\n\t*b = fg_b;\n    }\n}\n\n/*\n * Get the text background color, if known.\n */\n    void\nterm_get_bg_color(char_u *r, char_u *g, char_u *b)\n{\n    if (rbg_status.tr_progress == STATUS_GOT)\n    {\n\t*r = bg_r;\n\t*g = bg_g;\n\t*b = bg_b;\n    }\n}\n#endif\n\n/*\n * Replace any terminal code strings in from[] with the equivalent internal\n * vim representation.\tThis is used for the \"from\" and \"to\" part of a\n * mapping, and the \"to\" part of a menu command.\n * Any strings like \"<C-UP>\" are also replaced, unless 'cpoptions' contains\n * '<'.\n * K_SPECIAL by itself is replaced by K_SPECIAL KS_SPECIAL KE_FILLER.\n *\n * The replacement is done in result[] and finally copied into allocated\n * memory. If this all works well *bufp is set to the allocated memory and a\n * pointer to it is returned. If something fails *bufp is set to NULL and from\n * is returned.\n *\n * CTRL-V characters are removed.  When \"flags\" has REPTERM_FROM_PART, a\n * trailing CTRL-V is included, otherwise it is removed (for \":map xx ^V\", maps\n * xx to nothing).  When 'cpoptions' does not contain 'B', a backslash can be\n * used instead of a CTRL-V.\n *\n * Flags:\n *  REPTERM_FROM_PART\tsee above\n *  REPTERM_DO_LT\talso translate <lt>\n *  REPTERM_SPECIAL\talways accept <key> notation\n *  REPTERM_NO_SIMPLIFY\tdo not simplify <C-H> to 0x08 and set 8th bit for <A-x>\n *\n * \"did_simplify\" is set when some <C-H> or <A-x> code was simplified, unless\n * it is NULL.\n */\n    char_u *\nreplace_termcodes(\n    char_u\t*from,\n    char_u\t**bufp,\n    int\t\tflags,\n    int\t\t*did_simplify)\n{\n    int\t\ti;\n    int\t\tslen;\n    int\t\tkey;\n    size_t\tdlen = 0;\n    char_u\t*src;\n    int\t\tdo_backslash;\t// backslash is a special character\n    int\t\tdo_special;\t// recognize <> key codes\n    int\t\tdo_key_code;\t// recognize raw key codes\n    char_u\t*result;\t// buffer for resulting string\n    garray_T\tga;\n\n    do_backslash = (vim_strchr(p_cpo, CPO_BSLASH) == NULL);\n    do_special = (vim_strchr(p_cpo, CPO_SPECI) == NULL)\n\t\t\t\t\t\t  || (flags & REPTERM_SPECIAL);\n    do_key_code = (vim_strchr(p_cpo, CPO_KEYCODE) == NULL);\n    src = from;\n\n    /*\n     * Allocate space for the translation.  Worst case a single character is\n     * replaced by 6 bytes (shifted special key), plus a NUL at the end.\n     * In the rare case more might be needed ga_grow() must be called again.\n     */\n    ga_init2(&ga, 1L, 100);\n    if (ga_grow(&ga, (int)(STRLEN(src) * 6 + 1)) == FAIL) // out of memory\n    {\n\t*bufp = NULL;\n\treturn from;\n    }\n    result = ga.ga_data;\n\n    /*\n     * Check for #n at start only: function key n\n     */\n    if ((flags & REPTERM_FROM_PART) && src[0] == '#' && VIM_ISDIGIT(src[1]))\n    {\n\tresult[dlen++] = K_SPECIAL;\n\tresult[dlen++] = 'k';\n\tif (src[1] == '0')\n\t    result[dlen++] = ';';\t// #0 is F10 is \"k;\"\n\telse\n\t    result[dlen++] = src[1];\t// #3 is F3 is \"k3\"\n\tsrc += 2;\n    }\n\n    /*\n     * Copy each byte from *from to result[dlen]\n     */\n    while (*src != NUL)\n    {\n\t/*\n\t * If 'cpoptions' does not contain '<', check for special key codes,\n\t * like \"<C-S-LeftMouse>\"\n\t */\n\tif (do_special && ((flags & REPTERM_DO_LT)\n\t\t\t\t\t      || STRNCMP(src, \"<lt>\", 4) != 0))\n\t{\n#ifdef FEAT_EVAL\n\t    /*\n\t     * Change <SID>Func to K_SNR <script-nr> _Func.  This name is used\n\t     * for script-locla user functions.\n\t     * (room: 5 * 6 = 30 bytes; needed: 3 + <nr> + 1 <= 14)\n\t     * Also change <SID>name.Func to K_SNR <import-script-nr> _Func.\n\t     * Only if \"name\" is recognized as an import.\n\t     */\n\t    if (STRNICMP(src, \"<SID>\", 5) == 0)\n\t    {\n\t\tif (current_sctx.sc_sid <= 0)\n\t\t    emsg(_(e_using_sid_not_in_script_context));\n\t\telse\n\t\t{\n\t\t    char_u  *dot;\n\t\t    long    sid = current_sctx.sc_sid;\n\n\t\t    src += 5;\n\t\t    if (in_vim9script()\n\t\t\t\t       && (dot = vim_strchr(src, '.')) != NULL)\n\t\t    {\n\t\t\timported_T *imp = find_imported(src, dot - src, FALSE);\n\n\t\t\tif (imp != NULL)\n\t\t\t{\n\t\t\t    scriptitem_T    *si = SCRIPT_ITEM(imp->imp_sid);\n\t\t\t    size_t\t    len;\n\n\t\t\t    src = dot + 1;\n\t\t\t    if (si->sn_autoload_prefix != NULL)\n\t\t\t    {\n\t\t\t\t// Turn \"<SID>name.Func\"\n\t\t\t\t// into \"scriptname#Func\".\n\t\t\t\tlen = STRLEN(si->sn_autoload_prefix);\n\t\t\t\tif (ga_grow(&ga,\n\t\t\t\t     (int)(STRLEN(src) * 6 + len + 1)) == FAIL)\n\t\t\t\t{\n\t\t\t\t    ga_clear(&ga);\n\t\t\t\t    *bufp = NULL;\n\t\t\t\t    return from;\n\t\t\t\t}\n\t\t\t\tresult = ga.ga_data;\n\t\t\t\tSTRCPY(result + dlen, si->sn_autoload_prefix);\n\t\t\t\tdlen += len;\n\t\t\t\tcontinue;\n\t\t\t    }\n\t\t\t    sid = imp->imp_sid;\n\t\t\t}\n\t\t    }\n\n\t\t    result[dlen++] = K_SPECIAL;\n\t\t    result[dlen++] = (int)KS_EXTRA;\n\t\t    result[dlen++] = (int)KE_SNR;\n\t\t    sprintf((char *)result + dlen, \"%ld\", sid);\n\t\t    dlen += STRLEN(result + dlen);\n\t\t    result[dlen++] = '_';\n\t\t    continue;\n\t\t}\n\t    }\n#endif\n\t    slen = trans_special(&src, result + dlen, FSK_KEYCODE\n\t\t\t  | ((flags & REPTERM_NO_SIMPLIFY) ? 0 : FSK_SIMPLIFY),\n\t\t\t\t\t\t\t   TRUE, did_simplify);\n\t    if (slen)\n\t    {\n\t\tdlen += slen;\n\t\tcontinue;\n\t    }\n\t}\n\n\t/*\n\t * If 'cpoptions' does not contain 'k', see if it's an actual key-code.\n\t * Note that this is also checked after replacing the <> form.\n\t * Single character codes are NOT replaced (e.g. ^H or DEL), because\n\t * it could be a character in the file.\n\t */\n\tif (do_key_code)\n\t{\n\t    i = find_term_bykeys(src);\n\t    if (i >= 0)\n\t    {\n\t\tresult[dlen++] = K_SPECIAL;\n\t\tresult[dlen++] = termcodes[i].name[0];\n\t\tresult[dlen++] = termcodes[i].name[1];\n\t\tsrc += termcodes[i].len;\n\t\t// If terminal code matched, continue after it.\n\t\tcontinue;\n\t    }\n\t}\n\n#ifdef FEAT_EVAL\n\tif (do_special)\n\t{\n\t    char_u\t*p, *s, len;\n\n\t    /*\n\t     * Replace <Leader> by the value of \"mapleader\".\n\t     * Replace <LocalLeader> by the value of \"maplocalleader\".\n\t     * If \"mapleader\" or \"maplocalleader\" isn't set use a backslash.\n\t     */\n\t    if (STRNICMP(src, \"<Leader>\", 8) == 0)\n\t    {\n\t\tlen = 8;\n\t\tp = get_var_value((char_u *)\"g:mapleader\");\n\t    }\n\t    else if (STRNICMP(src, \"<LocalLeader>\", 13) == 0)\n\t    {\n\t\tlen = 13;\n\t\tp = get_var_value((char_u *)\"g:maplocalleader\");\n\t    }\n\t    else\n\t    {\n\t\tlen = 0;\n\t\tp = NULL;\n\t    }\n\t    if (len != 0)\n\t    {\n\t\t// Allow up to 8 * 6 characters for \"mapleader\".\n\t\tif (p == NULL || *p == NUL || STRLEN(p) > 8 * 6)\n\t\t    s = (char_u *)\"\\\\\";\n\t\telse\n\t\t    s = p;\n\t\twhile (*s != NUL)\n\t\t    result[dlen++] = *s++;\n\t\tsrc += len;\n\t\tcontinue;\n\t    }\n\t}\n#endif\n\n\t/*\n\t * Remove CTRL-V and ignore the next character.\n\t * For \"from\" side the CTRL-V at the end is included, for the \"to\"\n\t * part it is removed.\n\t * If 'cpoptions' does not contain 'B', also accept a backslash.\n\t */\n\tkey = *src;\n\tif (key == Ctrl_V || (do_backslash && key == '\\\\'))\n\t{\n\t    ++src;\t\t\t\t// skip CTRL-V or backslash\n\t    if (*src == NUL)\n\t    {\n\t\tif (flags & REPTERM_FROM_PART)\n\t\t    result[dlen++] = key;\n\t\tbreak;\n\t    }\n\t}\n\n\t// skip multibyte char correctly\n\tfor (i = (*mb_ptr2len)(src); i > 0; --i)\n\t{\n\t    /*\n\t     * If the character is K_SPECIAL, replace it with K_SPECIAL\n\t     * KS_SPECIAL KE_FILLER.\n\t     * If compiled with the GUI replace CSI with K_CSI.\n\t     */\n\t    if (*src == K_SPECIAL)\n\t    {\n\t\tresult[dlen++] = K_SPECIAL;\n\t\tresult[dlen++] = KS_SPECIAL;\n\t\tresult[dlen++] = KE_FILLER;\n\t    }\n# ifdef FEAT_GUI\n\t    else if (*src == CSI)\n\t    {\n\t\tresult[dlen++] = K_SPECIAL;\n\t\tresult[dlen++] = KS_EXTRA;\n\t\tresult[dlen++] = (int)KE_CSI;\n\t    }\n# endif\n\t    else\n\t\tresult[dlen++] = *src;\n\t    ++src;\n\t}\n    }\n    result[dlen] = NUL;\n\n    /*\n     * Copy the new string to allocated memory.\n     * If this fails, just return from.\n     */\n    if ((*bufp = vim_strsave(result)) != NULL)\n\tfrom = *bufp;\n    vim_free(result);\n    return from;\n}\n\n/*\n * Find a termcode with keys 'src' (must be NUL terminated).\n * Return the index in termcodes[], or -1 if not found.\n */\n    static int\nfind_term_bykeys(char_u *src)\n{\n    int\t\ti;\n    int\t\tslen = (int)STRLEN(src);\n\n    for (i = 0; i < tc_len; ++i)\n    {\n\tif (slen == termcodes[i].len\n\t\t\t&& STRNCMP(termcodes[i].code, src, (size_t)slen) == 0)\n\t    return i;\n    }\n    return -1;\n}\n\n/*\n * Gather the first characters in the terminal key codes into a string.\n * Used to speed up check_termcode().\n */\n    static void\ngather_termleader(void)\n{\n    int\t    i;\n    int\t    len = 0;\n\n#ifdef FEAT_GUI\n    if (gui.in_use)\n\ttermleader[len++] = CSI;    // the GUI codes are not in termcodes[]\n#endif\n#ifdef FEAT_TERMRESPONSE\n    if (check_for_codes || *T_CRS != NUL)\n\ttermleader[len++] = DCS;    // the termcode response starts with DCS\n\t\t\t\t    // in 8-bit mode\n#endif\n    termleader[len] = NUL;\n\n    for (i = 0; i < tc_len; ++i)\n\tif (vim_strchr(termleader, termcodes[i].code[0]) == NULL)\n\t{\n\t    termleader[len++] = termcodes[i].code[0];\n\t    termleader[len] = NUL;\n\t}\n\n    need_gather = FALSE;\n}\n\n/*\n * Show all termcodes (for \":set termcap\")\n * This code looks a lot like showoptions(), but is different.\n * \"flags\" can have OPT_ONECOLUMN.\n */\n    void\nshow_termcodes(int flags)\n{\n    int\t\tcol;\n    int\t\t*items;\n    int\t\titem_count;\n    int\t\trun;\n    int\t\trow, rows;\n    int\t\tcols;\n    int\t\ti;\n    int\t\tlen;\n\n#define INC3 27\t    // try to make three columns\n#define INC2 40\t    // try to make two columns\n#define GAP 2\t    // spaces between columns\n\n    if (tc_len == 0)\t    // no terminal codes (must be GUI)\n\treturn;\n    items = ALLOC_MULT(int, tc_len);\n    if (items == NULL)\n\treturn;\n\n    // Highlight title\n    msg_puts_title(_(\"\\n--- Terminal keys ---\"));\n\n    /*\n     * Do the loop three times:\n     * 1. display the short items (non-strings and short strings)\n     * 2. display the medium items (medium length strings)\n     * 3. display the long items (remaining strings)\n     * When \"flags\" has OPT_ONECOLUMN do everything in 3.\n     */\n    for (run = (flags & OPT_ONECOLUMN) ? 3 : 1; run <= 3 && !got_int; ++run)\n    {\n\t/*\n\t * collect the items in items[]\n\t */\n\titem_count = 0;\n\tfor (i = 0; i < tc_len; i++)\n\t{\n\t    len = show_one_termcode(termcodes[i].name,\n\t\t\t\t\t\t    termcodes[i].code, FALSE);\n\t    if ((flags & OPT_ONECOLUMN) ||\n\t\t    (len <= INC3 - GAP ? run == 1\n\t\t\t: len <= INC2 - GAP ? run == 2\n\t\t\t: run == 3))\n\t\titems[item_count++] = i;\n\t}\n\n\t/*\n\t * display the items\n\t */\n\tif (run <= 2)\n\t{\n\t    cols = (Columns + GAP) / (run == 1 ? INC3 : INC2);\n\t    if (cols == 0)\n\t\tcols = 1;\n\t    rows = (item_count + cols - 1) / cols;\n\t}\n\telse\t// run == 3\n\t    rows = item_count;\n\tfor (row = 0; row < rows && !got_int; ++row)\n\t{\n\t    msg_putchar('\\n');\t\t\t// go to next line\n\t    if (got_int)\t\t\t// 'q' typed in more\n\t\tbreak;\n\t    col = 0;\n\t    for (i = row; i < item_count; i += rows)\n\t    {\n\t\tmsg_col = col;\t\t\t// make columns\n\t\tshow_one_termcode(termcodes[items[i]].name,\n\t\t\t\t\t      termcodes[items[i]].code, TRUE);\n\t\tif (run == 2)\n\t\t    col += INC2;\n\t\telse\n\t\t    col += INC3;\n\t    }\n\t    out_flush();\n\t    ui_breakcheck();\n\t}\n    }\n    vim_free(items);\n}\n\n/*\n * Show one termcode entry.\n * Output goes into IObuff[]\n */\n    int\nshow_one_termcode(char_u *name, char_u *code, int printit)\n{\n    char_u\t*p;\n    int\t\tlen;\n\n    if (name[0] > '~')\n    {\n\tIObuff[0] = ' ';\n\tIObuff[1] = ' ';\n\tIObuff[2] = ' ';\n\tIObuff[3] = ' ';\n    }\n    else\n    {\n\tIObuff[0] = 't';\n\tIObuff[1] = '_';\n\tIObuff[2] = name[0];\n\tIObuff[3] = name[1];\n    }\n    IObuff[4] = ' ';\n\n    p = get_special_key_name(TERMCAP2KEY(name[0], name[1]), 0);\n    if (p[1] != 't')\n\tSTRCPY(IObuff + 5, p);\n    else\n\tIObuff[5] = NUL;\n    len = (int)STRLEN(IObuff);\n    do\n\tIObuff[len++] = ' ';\n    while (len < 17);\n    IObuff[len] = NUL;\n    if (code == NULL)\n\tlen += 4;\n    else\n\tlen += vim_strsize(code);\n\n    if (printit)\n    {\n\tmsg_puts((char *)IObuff);\n\tif (code == NULL)\n\t    msg_puts(\"NULL\");\n\telse\n\t    msg_outtrans(code);\n    }\n    return len;\n}\n\n#if defined(FEAT_TERMRESPONSE) || defined(PROTO)\n/*\n * For Xterm >= 140 compiled with OPT_TCAP_QUERY: Obtain the actually used\n * termcap codes from the terminal itself.\n * We get them one by one to avoid a very long response string.\n */\nstatic int xt_index_in = 0;\nstatic int xt_index_out = 0;\n\n    static void\nreq_codes_from_term(void)\n{\n    xt_index_out = 0;\n    xt_index_in = 0;\n    req_more_codes_from_term();\n}\n\n    static void\nreq_more_codes_from_term(void)\n{\n    char\tbuf[23];  // extra size to shut up LGTM\n    int\t\told_idx = xt_index_out;\n\n    // Don't do anything when going to exit.\n    if (exiting)\n\treturn;\n\n    // Send up to 10 more requests out than we received.  Avoid sending too\n    // many, there can be a buffer overflow somewhere.\n    while (xt_index_out < xt_index_in + 10 && key_names[xt_index_out] != NULL)\n    {\n\tchar *key_name = key_names[xt_index_out];\n\n\tMAY_WANT_TO_LOG_THIS;\n\tLOG_TR((\"Requesting XT %d: %s\", xt_index_out, key_name));\n\tsprintf(buf, \"\\033P+q%02x%02x\\033\\\\\", key_name[0], key_name[1]);\n\tout_str_nf((char_u *)buf);\n\t++xt_index_out;\n    }\n\n    // Send the codes out right away.\n    if (xt_index_out != old_idx)\n\tout_flush();\n}\n\n/*\n * Decode key code response from xterm: '<Esc>P1+r<name>=<string><Esc>\\'.\n * A \"0\" instead of the \"1\" indicates a code that isn't supported.\n * Both <name> and <string> are encoded in hex.\n * \"code\" points to the \"0\" or \"1\".\n */\n    static void\ngot_code_from_term(char_u *code, int len)\n{\n#define XT_LEN 100\n    char_u\tname[3];\n    char_u\tstr[XT_LEN];\n    int\t\ti;\n    int\t\tj = 0;\n    int\t\tc;\n\n    // A '1' means the code is supported, a '0' means it isn't.\n    // When half the length is > XT_LEN we can't use it.\n    // Our names are currently all 2 characters.\n    if (code[0] == '1' && code[7] == '=' && len / 2 < XT_LEN)\n    {\n\t// Get the name from the response and find it in the table.\n\tname[0] = hexhex2nr(code + 3);\n\tname[1] = hexhex2nr(code + 5);\n\tname[2] = NUL;\n\tfor (i = 0; key_names[i] != NULL; ++i)\n\t{\n\t    if (STRCMP(key_names[i], name) == 0)\n\t    {\n\t\txt_index_in = i;\n\t\tbreak;\n\t    }\n\t}\n\n\tLOG_TR((\"Received XT %d: %s\", xt_index_in, (char *)name));\n\n\tif (key_names[i] != NULL)\n\t{\n\t    for (i = 8; (c = hexhex2nr(code + i)) >= 0; i += 2)\n\t\tstr[j++] = c;\n\t    str[j] = NUL;\n\t    if (name[0] == 'C' && name[1] == 'o')\n\t    {\n\t\t// Color count is not a key code.\n\t\tmay_adjust_color_count(atoi((char *)str));\n\t    }\n\t    else\n\t    {\n\t\t// First delete any existing entry with the same code.\n\t\ti = find_term_bykeys(str);\n\t\tif (i >= 0)\n\t\t    del_termcode_idx(i);\n\t\tadd_termcode(name, str, ATC_FROM_TERM);\n\t    }\n\t}\n    }\n\n    // May request more codes now that we received one.\n    ++xt_index_in;\n    req_more_codes_from_term();\n}\n\n/*\n * Check if there are any unanswered requests and deal with them.\n * This is called before starting an external program or getting direct\n * keyboard input.  We don't want responses to be send to that program or\n * handled as typed text.\n */\n    static void\ncheck_for_codes_from_term(void)\n{\n    int\t\tc;\n\n    // If no codes requested or all are answered, no need to wait.\n    if (xt_index_out == 0 || xt_index_out == xt_index_in)\n\treturn;\n\n    // Vgetc() will check for and handle any response.\n    // Keep calling vpeekc() until we don't get any responses.\n    ++no_mapping;\n    ++allow_keys;\n    for (;;)\n    {\n\tc = vpeekc();\n\tif (c == NUL)\t    // nothing available\n\t    break;\n\n\t// If a response is recognized it's replaced with K_IGNORE, must read\n\t// it from the input stream.  If there is no K_IGNORE we can't do\n\t// anything, break here (there might be some responses further on, but\n\t// we don't want to throw away any typed chars).\n\tif (c != K_SPECIAL && c != K_IGNORE)\n\t    break;\n\tc = vgetc();\n\tif (c != K_IGNORE)\n\t{\n\t    vungetc(c);\n\t    break;\n\t}\n    }\n    --no_mapping;\n    --allow_keys;\n}\n#endif\n\n#if (defined(MSWIN) && (!defined(FEAT_GUI) || defined(VIMDLL))) || defined(PROTO)\nstatic char ksme_str[20];\nstatic char ksmr_str[20];\nstatic char ksmd_str[20];\n\n/*\n * For Win32 console: update termcap codes for existing console attributes.\n */\n    void\nupdate_tcap(int attr)\n{\n    struct builtin_term *p;\n\n    p = find_builtin_term(DEFAULT_TERM);\n    sprintf(ksme_str, \"\\033|%dm\", attr);\n    sprintf(ksmd_str, \"\\033|%dm\", attr | 0x08);  // FOREGROUND_INTENSITY\n    sprintf(ksmr_str, \"\\033|%dm\", ((attr & 0x0F) << 4) | ((attr & 0xF0) >> 4));\n\n    while (p->bt_string != NULL)\n    {\n      if (p->bt_entry == (int)KS_ME)\n\t  p->bt_string = &ksme_str[0];\n      else if (p->bt_entry == (int)KS_MR)\n\t  p->bt_string = &ksmr_str[0];\n      else if (p->bt_entry == (int)KS_MD)\n\t  p->bt_string = &ksmd_str[0];\n      ++p;\n    }\n}\n\n# ifdef FEAT_TERMGUICOLORS\n#  define KSSIZE 20\n\ntypedef enum\n{\n    CMODE_INDEXED = 0,\t// Use cmd.exe 4bit palette.\n    CMODE_RGB,\t\t// Use 24bit RGB colors using VTP.\n    CMODE_256COL,\t// Emulate xterm's 256-color palette using VTP.\n    CMODE_LAST,\n} cmode_T;\n\nstruct ks_tbl_S\n{\n    int  code;\t\t\t\t// value of KS_\n    char *vtp;\t\t\t\t// code in RGB mode\n    char *vtp2;\t\t\t\t// code in 256color mode\n    char buf[CMODE_LAST][KSSIZE];\t// real buffer\n};\n\nstatic struct ks_tbl_S ks_tbl[] =\n{\n    {(int)KS_ME,  \"\\033|0m\",  \"\\033|0m\", {\"\"}},   // normal\n    {(int)KS_MR,  \"\\033|7m\",  \"\\033|7m\", {\"\"}},   // reverse\n    {(int)KS_MD,  \"\\033|1m\",  \"\\033|1m\", {\"\"}},   // bold\n    {(int)KS_SO,  \"\\033|91m\", \"\\033|91m\", {\"\"}},  // standout: bright red text\n    {(int)KS_SE,  \"\\033|39m\", \"\\033|39m\", {\"\"}},  // standout end: default color\n    {(int)KS_CZH, \"\\033|3m\",  \"\\033|3m\", {\"\"}},   // italic\n    {(int)KS_CZR, \"\\033|0m\",  \"\\033|0m\", {\"\"}},   // italic end\n    {(int)KS_US,  \"\\033|4m\",  \"\\033|4m\", {\"\"}},   // underscore\n    {(int)KS_UE,  \"\\033|24m\", \"\\033|24m\", {\"\"}},  // underscore end\n#  ifdef TERMINFO\n    {(int)KS_CAB, \"\\033|%p1%db\", \"\\033|%p14%dm\", {\"\"}}, // set background color\n    {(int)KS_CAF, \"\\033|%p1%df\", \"\\033|%p13%dm\", {\"\"}}, // set foreground color\n    {(int)KS_CS,  \"\\033|%p1%d;%p2%dR\", \"\\033|%p1%d;%p2%dR\", {\"\"}},\n    {(int)KS_CSV, \"\\033|%p1%d;%p2%dV\", \"\\033|%p1%d;%p2%dV\", {\"\"}},\n#  else\n    {(int)KS_CAB, \"\\033|%db\", \"\\033|4%dm\", {\"\"}}, // set background color\n    {(int)KS_CAF, \"\\033|%df\", \"\\033|3%dm\", {\"\"}}, // set foreground color\n    {(int)KS_CS,  \"\\033|%d;%dR\", \"\\033|%d;%dR\", {\"\"}},\n    {(int)KS_CSV, \"\\033|%d;%dV\", \"\\033|%d;%dV\", {\"\"}},\n#  endif\n    {(int)KS_CCO, \"256\", \"256\", {\"\"}},\t    // colors\n    {(int)KS_NAME, NULL, NULL, {\"\"}}\t\t\t    // terminator\n};\n\n    static struct builtin_term *\nfind_first_tcap(\n    char_u *name,\n    int\t    code)\n{\n    struct builtin_term *p;\n\n    for (p = find_builtin_term(name); p->bt_string != NULL; ++p)\n\tif (p->bt_entry == code)\n\t    return p;\n    return NULL;\n}\n# endif\n\n/*\n * For Win32 console: replace the sequence immediately after termguicolors.\n */\n    void\nswap_tcap(void)\n{\n# ifdef FEAT_TERMGUICOLORS\n    static int\t\tinit_done = FALSE;\n    static cmode_T\tcurr_mode;\n    struct ks_tbl_S\t*ks;\n    struct builtin_term *bt;\n    cmode_T\t\tmode;\n\n    if (!init_done)\n    {\n\tfor (ks = ks_tbl; ks->code != (int)KS_NAME; ks++)\n\t{\n\t    bt = find_first_tcap(DEFAULT_TERM, ks->code);\n\t    if (bt != NULL)\n\t    {\n\t\t// Preserve the original value.\n\t\tSTRNCPY(ks->buf[CMODE_INDEXED], bt->bt_string, KSSIZE);\n\t\tSTRNCPY(ks->buf[CMODE_RGB], ks->vtp, KSSIZE);\n\t\tSTRNCPY(ks->buf[CMODE_256COL], ks->vtp2, KSSIZE);\n\n\t\tbt->bt_string = ks->buf[CMODE_INDEXED];\n\t    }\n\t}\n\tinit_done = TRUE;\n\tcurr_mode = CMODE_INDEXED;\n    }\n\n    if (p_tgc)\n\tmode = CMODE_RGB;\n    else if (t_colors >= 256)\n\tmode = CMODE_256COL;\n    else\n\tmode = CMODE_INDEXED;\n\n    if (mode == curr_mode)\n\treturn;\n\n    for (ks = ks_tbl; ks->code != (int)KS_NAME; ks++)\n    {\n\tbt = find_first_tcap(DEFAULT_TERM, ks->code);\n\tif (bt != NULL)\n\t    bt->bt_string = ks->buf[mode];\n    }\n\n    curr_mode = mode;\n# endif\n}\n\n#endif\n\n\n#if (defined(MSWIN) && (!defined(FEAT_GUI_MSWIN) || defined(VIMDLL))) || defined(FEAT_TERMINAL) \\\n\t|| defined(PROTO)\nstatic int cube_value[] = {\n    0x00, 0x5F, 0x87, 0xAF, 0xD7, 0xFF\n};\n\nstatic int grey_ramp[] = {\n    0x08, 0x12, 0x1C, 0x26, 0x30, 0x3A, 0x44, 0x4E, 0x58, 0x62, 0x6C, 0x76,\n    0x80, 0x8A, 0x94, 0x9E, 0xA8, 0xB2, 0xBC, 0xC6, 0xD0, 0xDA, 0xE4, 0xEE\n};\n\nstatic const char_u ansi_table[16][3] = {\n//   R    G    B\n  {  0,   0,   0}, // black\n  {224,   0,   0}, // dark red\n  {  0, 224,   0}, // dark green\n  {224, 224,   0}, // dark yellow / brown\n  {  0,   0, 224}, // dark blue\n  {224,   0, 224}, // dark magenta\n  {  0, 224, 224}, // dark cyan\n  {224, 224, 224}, // light grey\n\n  {128, 128, 128}, // dark grey\n  {255,  64,  64}, // light red\n  { 64, 255,  64}, // light green\n  {255, 255,  64}, // yellow\n  { 64,  64, 255}, // light blue\n  {255,  64, 255}, // light magenta\n  { 64, 255, 255}, // light cyan\n  {255, 255, 255}, // white\n};\n\n#if defined(MSWIN)\n// Mapping between cterm indices < 16 and their counterpart in the ANSI palette.\nstatic const char_u cterm_ansi_idx[] = {\n    0, 4, 2, 6, 1, 5, 3, 7, 8, 12, 10, 14, 9, 13, 11, 15\n};\n#endif\n\n#define ANSI_INDEX_NONE 0\n\n    void\nansi_color2rgb(int nr, char_u *r, char_u *g, char_u *b, char_u *ansi_idx)\n{\n    if (nr < 16)\n    {\n\t*r = ansi_table[nr][0];\n\t*g = ansi_table[nr][1];\n\t*b = ansi_table[nr][2];\n\t*ansi_idx = nr;\n    }\n    else\n    {\n\t*r = 0;\n\t*g = 0;\n\t*b = 0;\n\t*ansi_idx = ANSI_INDEX_NONE;\n    }\n}\n\n    void\ncterm_color2rgb(int nr, char_u *r, char_u *g, char_u *b, char_u *ansi_idx)\n{\n    int idx;\n\n    if (nr < 16)\n    {\n#if defined(MSWIN)\n\tidx = cterm_ansi_idx[nr];\n#else\n\tidx = nr;\n#endif\n\t*r = ansi_table[idx][0];\n\t*g = ansi_table[idx][1];\n\t*b = ansi_table[idx][2];\n\t*ansi_idx = idx + 1;\n    }\n    else if (nr < 232)\n    {\n\t// 216 color cube\n\tidx = nr - 16;\n\t*r = cube_value[idx / 36 % 6];\n\t*g = cube_value[idx / 6  % 6];\n\t*b = cube_value[idx      % 6];\n\t*ansi_idx = ANSI_INDEX_NONE;\n    }\n    else if (nr < 256)\n    {\n\t// 24 grey scale ramp\n\tidx = nr - 232;\n\t*r = grey_ramp[idx];\n\t*g = grey_ramp[idx];\n\t*b = grey_ramp[idx];\n\t*ansi_idx = ANSI_INDEX_NONE;\n    }\n    else\n    {\n\t*r = 0;\n\t*g = 0;\n\t*b = 0;\n\t*ansi_idx = ANSI_INDEX_NONE;\n    }\n}\n#endif\n\n/*\n * Replace K_BS by <BS> and K_DEL by <DEL>\n */\n    void\nterm_replace_bs_del_keycode(char_u *ta_buf, int ta_len, int len)\n{\n    int\t\ti;\n    int\t\tc;\n\n    for (i = ta_len; i < ta_len + len; ++i)\n    {\n\tif (ta_buf[i] == CSI && len - i > 2)\n\t{\n\t    c = TERMCAP2KEY(ta_buf[i + 1], ta_buf[i + 2]);\n\t    if (c == K_DEL || c == K_KDEL || c == K_BS)\n\t    {\n\t\tmch_memmove(ta_buf + i + 1, ta_buf + i + 3,\n\t\t\t(size_t)(len - i - 2));\n\t\tif (c == K_DEL || c == K_KDEL)\n\t\t    ta_buf[i] = DEL;\n\t\telse\n\t\t    ta_buf[i] = Ctrl_H;\n\t\tlen -= 2;\n\t    }\n\t}\n\telse if (ta_buf[i] == '\\r')\n\t    ta_buf[i] = '\\n';\n\tif (has_mbyte)\n\t    i += (*mb_ptr2len_len)(ta_buf + i, ta_len + len - i) - 1;\n    }\n}\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    5160,\n/**/\n    5159,\n/**/\n    5158,\n/**/\n    5157,\n/**/\n    5156,\n/**/\n    5155,\n/**/\n    5154,\n/**/\n    5153,\n/**/\n    5152,\n/**/\n    5151,\n/**/\n    5150,\n/**/\n    5149,\n/**/\n    5148,\n/**/\n    5147,\n/**/\n    5146,\n/**/\n    5145,\n/**/\n    5144,\n/**/\n    5143,\n/**/\n    5142,\n/**/\n    5141,\n/**/\n    5140,\n/**/\n    5139,\n/**/\n    5138,\n/**/\n    5137,\n/**/\n    5136,\n/**/\n    5135,\n/**/\n    5134,\n/**/\n    5133,\n/**/\n    5132,\n/**/\n    5131,\n/**/\n    5130,\n/**/\n    5129,\n/**/\n    5128,\n/**/\n    5127,\n/**/\n    5126,\n/**/\n    5125,\n/**/\n    5124,\n/**/\n    5123,\n/**/\n    5122,\n/**/\n    5121,\n/**/\n    5120,\n/**/\n    5119,\n/**/\n    5118,\n/**/\n    5117,\n/**/\n    5116,\n/**/\n    5115,\n/**/\n    5114,\n/**/\n    5113,\n/**/\n    5112,\n/**/\n    5111,\n/**/\n    5110,\n/**/\n    5109,\n/**/\n    5108,\n/**/\n    5107,\n/**/\n    5106,\n/**/\n    5105,\n/**/\n    5104,\n/**/\n    5103,\n/**/\n    5102,\n/**/\n    5101,\n/**/\n    5100,\n/**/\n    5099,\n/**/\n    5098,\n/**/\n    5097,\n/**/\n    5096,\n/**/\n    5095,\n/**/\n    5094,\n/**/\n    5093,\n/**/\n    5092,\n/**/\n    5091,\n/**/\n    5090,\n/**/\n    5089,\n/**/\n    5088,\n/**/\n    5087,\n/**/\n    5086,\n/**/\n    5085,\n/**/\n    5084,\n/**/\n    5083,\n/**/\n    5082,\n/**/\n    5081,\n/**/\n    5080,\n/**/\n    5079,\n/**/\n    5078,\n/**/\n    5077,\n/**/\n    5076,\n/**/\n    5075,\n/**/\n    5074,\n/**/\n    5073,\n/**/\n    5072,\n/**/\n    5071,\n/**/\n    5070,\n/**/\n    5069,\n/**/\n    5068,\n/**/\n    5067,\n/**/\n    5066,\n/**/\n    5065,\n/**/\n    5064,\n/**/\n    5063,\n/**/\n    5062,\n/**/\n    5061,\n/**/\n    5060,\n/**/\n    5059,\n/**/\n    5058,\n/**/\n    5057,\n/**/\n    5056,\n/**/\n    5055,\n/**/\n    5054,\n/**/\n    5053,\n/**/\n    5052,\n/**/\n    5051,\n/**/\n    5050,\n/**/\n    5049,\n/**/\n    5048,\n/**/\n    5047,\n/**/\n    5046,\n/**/\n    5045,\n/**/\n    5044,\n/**/\n    5043,\n/**/\n    5042,\n/**/\n    5041,\n/**/\n    5040,\n/**/\n    5039,\n/**/\n    5038,\n/**/\n    5037,\n/**/\n    5036,\n/**/\n    5035,\n/**/\n    5034,\n/**/\n    5033,\n/**/\n    5032,\n/**/\n    5031,\n/**/\n    5030,\n/**/\n    5029,\n/**/\n    5028,\n/**/\n    5027,\n/**/\n    5026,\n/**/\n    5025,\n/**/\n    5024,\n/**/\n    5023,\n/**/\n    5022,\n/**/\n    5021,\n/**/\n    5020,\n/**/\n    5019,\n/**/\n    5018,\n/**/\n    5017,\n/**/\n    5016,\n/**/\n    5015,\n/**/\n    5014,\n/**/\n    5013,\n/**/\n    5012,\n/**/\n    5011,\n/**/\n    5010,\n/**/\n    5009,\n/**/\n    5008,\n/**/\n    5007,\n/**/\n    5006,\n/**/\n    5005,\n/**/\n    5004,\n/**/\n    5003,\n/**/\n    5002,\n/**/\n    5001,\n/**/\n    5000,\n/**/\n    4999,\n/**/\n    4998,\n/**/\n    4997,\n/**/\n    4996,\n/**/\n    4995,\n/**/\n    4994,\n/**/\n    4993,\n/**/\n    4992,\n/**/\n    4991,\n/**/\n    4990,\n/**/\n    4989,\n/**/\n    4988,\n/**/\n    4987,\n/**/\n    4986,\n/**/\n    4985,\n/**/\n    4984,\n/**/\n    4983,\n/**/\n    4982,\n/**/\n    4981,\n/**/\n    4980,\n/**/\n    4979,\n/**/\n    4978,\n/**/\n    4977,\n/**/\n    4976,\n/**/\n    4975,\n/**/\n    4974,\n/**/\n    4973,\n/**/\n    4972,\n/**/\n    4971,\n/**/\n    4970,\n/**/\n    4969,\n/**/\n    4968,\n/**/\n    4967,\n/**/\n    4966,\n/**/\n    4965,\n/**/\n    4964,\n/**/\n    4963,\n/**/\n    4962,\n/**/\n    4961,\n/**/\n    4960,\n/**/\n    4959,\n/**/\n    4958,\n/**/\n    4957,\n/**/\n    4956,\n/**/\n    4955,\n/**/\n    4954,\n/**/\n    4953,\n/**/\n    4952,\n/**/\n    4951,\n/**/\n    4950,\n/**/\n    4949,\n/**/\n    4948,\n/**/\n    4947,\n/**/\n    4946,\n/**/\n    4945,\n/**/\n    4944,\n/**/\n    4943,\n/**/\n    4942,\n/**/\n    4941,\n/**/\n    4940,\n/**/\n    4939,\n/**/\n    4938,\n/**/\n    4937,\n/**/\n    4936,\n/**/\n    4935,\n/**/\n    4934,\n/**/\n    4933,\n/**/\n    4932,\n/**/\n    4931,\n/**/\n    4930,\n/**/\n    4929,\n/**/\n    4928,\n/**/\n    4927,\n/**/\n    4926,\n/**/\n    4925,\n/**/\n    4924,\n/**/\n    4923,\n/**/\n    4922,\n/**/\n    4921,\n/**/\n    4920,\n/**/\n    4919,\n/**/\n    4918,\n/**/\n    4917,\n/**/\n    4916,\n/**/\n    4915,\n/**/\n    4914,\n/**/\n    4913,\n/**/\n    4912,\n/**/\n    4911,\n/**/\n    4910,\n/**/\n    4909,\n/**/\n    4908,\n/**/\n    4907,\n/**/\n    4906,\n/**/\n    4905,\n/**/\n    4904,\n/**/\n    4903,\n/**/\n    4902,\n/**/\n    4901,\n/**/\n    4900,\n/**/\n    4899,\n/**/\n    4898,\n/**/\n    4897,\n/**/\n    4896,\n/**/\n    4895,\n/**/\n    4894,\n/**/\n    4893,\n/**/\n    4892,\n/**/\n    4891,\n/**/\n    4890,\n/**/\n    4889,\n/**/\n    4888,\n/**/\n    4887,\n/**/\n    4886,\n/**/\n    4885,\n/**/\n    4884,\n/**/\n    4883,\n/**/\n    4882,\n/**/\n    4881,\n/**/\n    4880,\n/**/\n    4879,\n/**/\n    4878,\n/**/\n    4877,\n/**/\n    4876,\n/**/\n    4875,\n/**/\n    4874,\n/**/\n    4873,\n/**/\n    4872,\n/**/\n    4871,\n/**/\n    4870,\n/**/\n    4869,\n/**/\n    4868,\n/**/\n    4867,\n/**/\n    4866,\n/**/\n    4865,\n/**/\n    4864,\n/**/\n    4863,\n/**/\n    4862,\n/**/\n    4861,\n/**/\n    4860,\n/**/\n    4859,\n/**/\n    4858,\n/**/\n    4857,\n/**/\n    4856,\n/**/\n    4855,\n/**/\n    4854,\n/**/\n    4853,\n/**/\n    4852,\n/**/\n    4851,\n/**/\n    4850,\n/**/\n    4849,\n/**/\n    4848,\n/**/\n    4847,\n/**/\n    4846,\n/**/\n    4845,\n/**/\n    4844,\n/**/\n    4843,\n/**/\n    4842,\n/**/\n    4841,\n/**/\n    4840,\n/**/\n    4839,\n/**/\n    4838,\n/**/\n    4837,\n/**/\n    4836,\n/**/\n    4835,\n/**/\n    4834,\n/**/\n    4833,\n/**/\n    4832,\n/**/\n    4831,\n/**/\n    4830,\n/**/\n    4829,\n/**/\n    4828,\n/**/\n    4827,\n/**/\n    4826,\n/**/\n    4825,\n/**/\n    4824,\n/**/\n    4823,\n/**/\n    4822,\n/**/\n    4821,\n/**/\n    4820,\n/**/\n    4819,\n/**/\n    4818,\n/**/\n    4817,\n/**/\n    4816,\n/**/\n    4815,\n/**/\n    4814,\n/**/\n    4813,\n/**/\n    4812,\n/**/\n    4811,\n/**/\n    4810,\n/**/\n    4809,\n/**/\n    4808,\n/**/\n    4807,\n/**/\n    4806,\n/**/\n    4805,\n/**/\n    4804,\n/**/\n    4803,\n/**/\n    4802,\n/**/\n    4801,\n/**/\n    4800,\n/**/\n    4799,\n/**/\n    4798,\n/**/\n    4797,\n/**/\n    4796,\n/**/\n    4795,\n/**/\n    4794,\n/**/\n    4793,\n/**/\n    4792,\n/**/\n    4791,\n/**/\n    4790,\n/**/\n    4789,\n/**/\n    4788,\n/**/\n    4787,\n/**/\n    4786,\n/**/\n    4785,\n/**/\n    4784,\n/**/\n    4783,\n/**/\n    4782,\n/**/\n    4781,\n/**/\n    4780,\n/**/\n    4779,\n/**/\n    4778,\n/**/\n    4777,\n/**/\n    4776,\n/**/\n    4775,\n/**/\n    4774,\n/**/\n    4773,\n/**/\n    4772,\n/**/\n    4771,\n/**/\n    4770,\n/**/\n    4769,\n/**/\n    4768,\n/**/\n    4767,\n/**/\n    4766,\n/**/\n    4765,\n/**/\n    4764,\n/**/\n    4763,\n/**/\n    4762,\n/**/\n    4761,\n/**/\n    4760,\n/**/\n    4759,\n/**/\n    4758,\n/**/\n    4757,\n/**/\n    4756,\n/**/\n    4755,\n/**/\n    4754,\n/**/\n    4753,\n/**/\n    4752,\n/**/\n    4751,\n/**/\n    4750,\n/**/\n    4749,\n/**/\n    4748,\n/**/\n    4747,\n/**/\n    4746,\n/**/\n    4745,\n/**/\n    4744,\n/**/\n    4743,\n/**/\n    4742,\n/**/\n    4741,\n/**/\n    4740,\n/**/\n    4739,\n/**/\n    4738,\n/**/\n    4737,\n/**/\n    4736,\n/**/\n    4735,\n/**/\n    4734,\n/**/\n    4733,\n/**/\n    4732,\n/**/\n    4731,\n/**/\n    4730,\n/**/\n    4729,\n/**/\n    4728,\n/**/\n    4727,\n/**/\n    4726,\n/**/\n    4725,\n/**/\n    4724,\n/**/\n    4723,\n/**/\n    4722,\n/**/\n    4721,\n/**/\n    4720,\n/**/\n    4719,\n/**/\n    4718,\n/**/\n    4717,\n/**/\n    4716,\n/**/\n    4715,\n/**/\n    4714,\n/**/\n    4713,\n/**/\n    4712,\n/**/\n    4711,\n/**/\n    4710,\n/**/\n    4709,\n/**/\n    4708,\n/**/\n    4707,\n/**/\n    4706,\n/**/\n    4705,\n/**/\n    4704,\n/**/\n    4703,\n/**/\n    4702,\n/**/\n    4701,\n/**/\n    4700,\n/**/\n    4699,\n/**/\n    4698,\n/**/\n    4697,\n/**/\n    4696,\n/**/\n    4695,\n/**/\n    4694,\n/**/\n    4693,\n/**/\n    4692,\n/**/\n    4691,\n/**/\n    4690,\n/**/\n    4689,\n/**/\n    4688,\n/**/\n    4687,\n/**/\n    4686,\n/**/\n    4685,\n/**/\n    4684,\n/**/\n    4683,\n/**/\n    4682,\n/**/\n    4681,\n/**/\n    4680,\n/**/\n    4679,\n/**/\n    4678,\n/**/\n    4677,\n/**/\n    4676,\n/**/\n    4675,\n/**/\n    4674,\n/**/\n    4673,\n/**/\n    4672,\n/**/\n    4671,\n/**/\n    4670,\n/**/\n    4669,\n/**/\n    4668,\n/**/\n    4667,\n/**/\n    4666,\n/**/\n    4665,\n/**/\n    4664,\n/**/\n    4663,\n/**/\n    4662,\n/**/\n    4661,\n/**/\n    4660,\n/**/\n    4659,\n/**/\n    4658,\n/**/\n    4657,\n/**/\n    4656,\n/**/\n    4655,\n/**/\n    4654,\n/**/\n    4653,\n/**/\n    4652,\n/**/\n    4651,\n/**/\n    4650,\n/**/\n    4649,\n/**/\n    4648,\n/**/\n    4647,\n/**/\n    4646,\n/**/\n    4645,\n/**/\n    4644,\n/**/\n    4643,\n/**/\n    4642,\n/**/\n    4641,\n/**/\n    4640,\n/**/\n    4639,\n/**/\n    4638,\n/**/\n    4637,\n/**/\n    4636,\n/**/\n    4635,\n/**/\n    4634,\n/**/\n    4633,\n/**/\n    4632,\n/**/\n    4631,\n/**/\n    4630,\n/**/\n    4629,\n/**/\n    4628,\n/**/\n    4627,\n/**/\n    4626,\n/**/\n    4625,\n/**/\n    4624,\n/**/\n    4623,\n/**/\n    4622,\n/**/\n    4621,\n/**/\n    4620,\n/**/\n    4619,\n/**/\n    4618,\n/**/\n    4617,\n/**/\n    4616,\n/**/\n    4615,\n/**/\n    4614,\n/**/\n    4613,\n/**/\n    4612,\n/**/\n    4611,\n/**/\n    4610,\n/**/\n    4609,\n/**/\n    4608,\n/**/\n    4607,\n/**/\n    4606,\n/**/\n    4605,\n/**/\n    4604,\n/**/\n    4603,\n/**/\n    4602,\n/**/\n    4601,\n/**/\n    4600,\n/**/\n    4599,\n/**/\n    4598,\n/**/\n    4597,\n/**/\n    4596,\n/**/\n    4595,\n/**/\n    4594,\n/**/\n    4593,\n/**/\n    4592,\n/**/\n    4591,\n/**/\n    4590,\n/**/\n    4589,\n/**/\n    4588,\n/**/\n    4587,\n/**/\n    4586,\n/**/\n    4585,\n/**/\n    4584,\n/**/\n    4583,\n/**/\n    4582,\n/**/\n    4581,\n/**/\n    4580,\n/**/\n    4579,\n/**/\n    4578,\n/**/\n    4577,\n/**/\n    4576,\n/**/\n    4575,\n/**/\n    4574,\n/**/\n    4573,\n/**/\n    4572,\n/**/\n    4571,\n/**/\n    4570,\n/**/\n    4569,\n/**/\n    4568,\n/**/\n    4567,\n/**/\n    4566,\n/**/\n    4565,\n/**/\n    4564,\n/**/\n    4563,\n/**/\n    4562,\n/**/\n    4561,\n/**/\n    4560,\n/**/\n    4559,\n/**/\n    4558,\n/**/\n    4557,\n/**/\n    4556,\n/**/\n    4555,\n/**/\n    4554,\n/**/\n    4553,\n/**/\n    4552,\n/**/\n    4551,\n/**/\n    4550,\n/**/\n    4549,\n/**/\n    4548,\n/**/\n    4547,\n/**/\n    4546,\n/**/\n    4545,\n/**/\n    4544,\n/**/\n    4543,\n/**/\n    4542,\n/**/\n    4541,\n/**/\n    4540,\n/**/\n    4539,\n/**/\n    4538,\n/**/\n    4537,\n/**/\n    4536,\n/**/\n    4535,\n/**/\n    4534,\n/**/\n    4533,\n/**/\n    4532,\n/**/\n    4531,\n/**/\n    4530,\n/**/\n    4529,\n/**/\n    4528,\n/**/\n    4527,\n/**/\n    4526,\n/**/\n    4525,\n/**/\n    4524,\n/**/\n    4523,\n/**/\n    4522,\n/**/\n    4521,\n/**/\n    4520,\n/**/\n    4519,\n/**/\n    4518,\n/**/\n    4517,\n/**/\n    4516,\n/**/\n    4515,\n/**/\n    4514,\n/**/\n    4513,\n/**/\n    4512,\n/**/\n    4511,\n/**/\n    4510,\n/**/\n    4509,\n/**/\n    4508,\n/**/\n    4507,\n/**/\n    4506,\n/**/\n    4505,\n/**/\n    4504,\n/**/\n    4503,\n/**/\n    4502,\n/**/\n    4501,\n/**/\n    4500,\n/**/\n    4499,\n/**/\n    4498,\n/**/\n    4497,\n/**/\n    4496,\n/**/\n    4495,\n/**/\n    4494,\n/**/\n    4493,\n/**/\n    4492,\n/**/\n    4491,\n/**/\n    4490,\n/**/\n    4489,\n/**/\n    4488,\n/**/\n    4487,\n/**/\n    4486,\n/**/\n    4485,\n/**/\n    4484,\n/**/\n    4483,\n/**/\n    4482,\n/**/\n    4481,\n/**/\n    4480,\n/**/\n    4479,\n/**/\n    4478,\n/**/\n    4477,\n/**/\n    4476,\n/**/\n    4475,\n/**/\n    4474,\n/**/\n    4473,\n/**/\n    4472,\n/**/\n    4471,\n/**/\n    4470,\n/**/\n    4469,\n/**/\n    4468,\n/**/\n    4467,\n/**/\n    4466,\n/**/\n    4465,\n/**/\n    4464,\n/**/\n    4463,\n/**/\n    4462,\n/**/\n    4461,\n/**/\n    4460,\n/**/\n    4459,\n/**/\n    4458,\n/**/\n    4457,\n/**/\n    4456,\n/**/\n    4455,\n/**/\n    4454,\n/**/\n    4453,\n/**/\n    4452,\n/**/\n    4451,\n/**/\n    4450,\n/**/\n    4449,\n/**/\n    4448,\n/**/\n    4447,\n/**/\n    4446,\n/**/\n    4445,\n/**/\n    4444,\n/**/\n    4443,\n/**/\n    4442,\n/**/\n    4441,\n/**/\n    4440,\n/**/\n    4439,\n/**/\n    4438,\n/**/\n    4437,\n/**/\n    4436,\n/**/\n    4435,\n/**/\n    4434,\n/**/\n    4433,\n/**/\n    4432,\n/**/\n    4431,\n/**/\n    4430,\n/**/\n    4429,\n/**/\n    4428,\n/**/\n    4427,\n/**/\n    4426,\n/**/\n    4425,\n/**/\n    4424,\n/**/\n    4423,\n/**/\n    4422,\n/**/\n    4421,\n/**/\n    4420,\n/**/\n    4419,\n/**/\n    4418,\n/**/\n    4417,\n/**/\n    4416,\n/**/\n    4415,\n/**/\n    4414,\n/**/\n    4413,\n/**/\n    4412,\n/**/\n    4411,\n/**/\n    4410,\n/**/\n    4409,\n/**/\n    4408,\n/**/\n    4407,\n/**/\n    4406,\n/**/\n    4405,\n/**/\n    4404,\n/**/\n    4403,\n/**/\n    4402,\n/**/\n    4401,\n/**/\n    4400,\n/**/\n    4399,\n/**/\n    4398,\n/**/\n    4397,\n/**/\n    4396,\n/**/\n    4395,\n/**/\n    4394,\n/**/\n    4393,\n/**/\n    4392,\n/**/\n    4391,\n/**/\n    4390,\n/**/\n    4389,\n/**/\n    4388,\n/**/\n    4387,\n/**/\n    4386,\n/**/\n    4385,\n/**/\n    4384,\n/**/\n    4383,\n/**/\n    4382,\n/**/\n    4381,\n/**/\n    4380,\n/**/\n    4379,\n/**/\n    4378,\n/**/\n    4377,\n/**/\n    4376,\n/**/\n    4375,\n/**/\n    4374,\n/**/\n    4373,\n/**/\n    4372,\n/**/\n    4371,\n/**/\n    4370,\n/**/\n    4369,\n/**/\n    4368,\n/**/\n    4367,\n/**/\n    4366,\n/**/\n    4365,\n/**/\n    4364,\n/**/\n    4363,\n/**/\n    4362,\n/**/\n    4361,\n/**/\n    4360,\n/**/\n    4359,\n/**/\n    4358,\n/**/\n    4357,\n/**/\n    4356,\n/**/\n    4355,\n/**/\n    4354,\n/**/\n    4353,\n/**/\n    4352,\n/**/\n    4351,\n/**/\n    4350,\n/**/\n    4349,\n/**/\n    4348,\n/**/\n    4347,\n/**/\n    4346,\n/**/\n    4345,\n/**/\n    4344,\n/**/\n    4343,\n/**/\n    4342,\n/**/\n    4341,\n/**/\n    4340,\n/**/\n    4339,\n/**/\n    4338,\n/**/\n    4337,\n/**/\n    4336,\n/**/\n    4335,\n/**/\n    4334,\n/**/\n    4333,\n/**/\n    4332,\n/**/\n    4331,\n/**/\n    4330,\n/**/\n    4329,\n/**/\n    4328,\n/**/\n    4327,\n/**/\n    4326,\n/**/\n    4325,\n/**/\n    4324,\n/**/\n    4323,\n/**/\n    4322,\n/**/\n    4321,\n/**/\n    4320,\n/**/\n    4319,\n/**/\n    4318,\n/**/\n    4317,\n/**/\n    4316,\n/**/\n    4315,\n/**/\n    4314,\n/**/\n    4313,\n/**/\n    4312,\n/**/\n    4311,\n/**/\n    4310,\n/**/\n    4309,\n/**/\n    4308,\n/**/\n    4307,\n/**/\n    4306,\n/**/\n    4305,\n/**/\n    4304,\n/**/\n    4303,\n/**/\n    4302,\n/**/\n    4301,\n/**/\n    4300,\n/**/\n    4299,\n/**/\n    4298,\n/**/\n    4297,\n/**/\n    4296,\n/**/\n    4295,\n/**/\n    4294,\n/**/\n    4293,\n/**/\n    4292,\n/**/\n    4291,\n/**/\n    4290,\n/**/\n    4289,\n/**/\n    4288,\n/**/\n    4287,\n/**/\n    4286,\n/**/\n    4285,\n/**/\n    4284,\n/**/\n    4283,\n/**/\n    4282,\n/**/\n    4281,\n/**/\n    4280,\n/**/\n    4279,\n/**/\n    4278,\n/**/\n    4277,\n/**/\n    4276,\n/**/\n    4275,\n/**/\n    4274,\n/**/\n    4273,\n/**/\n    4272,\n/**/\n    4271,\n/**/\n    4270,\n/**/\n    4269,\n/**/\n    4268,\n/**/\n    4267,\n/**/\n    4266,\n/**/\n    4265,\n/**/\n    4264,\n/**/\n    4263,\n/**/\n    4262,\n/**/\n    4261,\n/**/\n    4260,\n/**/\n    4259,\n/**/\n    4258,\n/**/\n    4257,\n/**/\n    4256,\n/**/\n    4255,\n/**/\n    4254,\n/**/\n    4253,\n/**/\n    4252,\n/**/\n    4251,\n/**/\n    4250,\n/**/\n    4249,\n/**/\n    4248,\n/**/\n    4247,\n/**/\n    4246,\n/**/\n    4245,\n/**/\n    4244,\n/**/\n    4243,\n/**/\n    4242,\n/**/\n    4241,\n/**/\n    4240,\n/**/\n    4239,\n/**/\n    4238,\n/**/\n    4237,\n/**/\n    4236,\n/**/\n    4235,\n/**/\n    4234,\n/**/\n    4233,\n/**/\n    4232,\n/**/\n    4231,\n/**/\n    4230,\n/**/\n    4229,\n/**/\n    4228,\n/**/\n    4227,\n/**/\n    4226,\n/**/\n    4225,\n/**/\n    4224,\n/**/\n    4223,\n/**/\n    4222,\n/**/\n    4221,\n/**/\n    4220,\n/**/\n    4219,\n/**/\n    4218,\n/**/\n    4217,\n/**/\n    4216,\n/**/\n    4215,\n/**/\n    4214,\n/**/\n    4213,\n/**/\n    4212,\n/**/\n    4211,\n/**/\n    4210,\n/**/\n    4209,\n/**/\n    4208,\n/**/\n    4207,\n/**/\n    4206,\n/**/\n    4205,\n/**/\n    4204,\n/**/\n    4203,\n/**/\n    4202,\n/**/\n    4201,\n/**/\n    4200,\n/**/\n    4199,\n/**/\n    4198,\n/**/\n    4197,\n/**/\n    4196,\n/**/\n    4195,\n/**/\n    4194,\n/**/\n    4193,\n/**/\n    4192,\n/**/\n    4191,\n/**/\n    4190,\n/**/\n    4189,\n/**/\n    4188,\n/**/\n    4187,\n/**/\n    4186,\n/**/\n    4185,\n/**/\n    4184,\n/**/\n    4183,\n/**/\n    4182,\n/**/\n    4181,\n/**/\n    4180,\n/**/\n    4179,\n/**/\n    4178,\n/**/\n    4177,\n/**/\n    4176,\n/**/\n    4175,\n/**/\n    4174,\n/**/\n    4173,\n/**/\n    4172,\n/**/\n    4171,\n/**/\n    4170,\n/**/\n    4169,\n/**/\n    4168,\n/**/\n    4167,\n/**/\n    4166,\n/**/\n    4165,\n/**/\n    4164,\n/**/\n    4163,\n/**/\n    4162,\n/**/\n    4161,\n/**/\n    4160,\n/**/\n    4159,\n/**/\n    4158,\n/**/\n    4157,\n/**/\n    4156,\n/**/\n    4155,\n/**/\n    4154,\n/**/\n    4153,\n/**/\n    4152,\n/**/\n    4151,\n/**/\n    4150,\n/**/\n    4149,\n/**/\n    4148,\n/**/\n    4147,\n/**/\n    4146,\n/**/\n    4145,\n/**/\n    4144,\n/**/\n    4143,\n/**/\n    4142,\n/**/\n    4141,\n/**/\n    4140,\n/**/\n    4139,\n/**/\n    4138,\n/**/\n    4137,\n/**/\n    4136,\n/**/\n    4135,\n/**/\n    4134,\n/**/\n    4133,\n/**/\n    4132,\n/**/\n    4131,\n/**/\n    4130,\n/**/\n    4129,\n/**/\n    4128,\n/**/\n    4127,\n/**/\n    4126,\n/**/\n    4125,\n/**/\n    4124,\n/**/\n    4123,\n/**/\n    4122,\n/**/\n    4121,\n/**/\n    4120,\n/**/\n    4119,\n/**/\n    4118,\n/**/\n    4117,\n/**/\n    4116,\n/**/\n    4115,\n/**/\n    4114,\n/**/\n    4113,\n/**/\n    4112,\n/**/\n    4111,\n/**/\n    4110,\n/**/\n    4109,\n/**/\n    4108,\n/**/\n    4107,\n/**/\n    4106,\n/**/\n    4105,\n/**/\n    4104,\n/**/\n    4103,\n/**/\n    4102,\n/**/\n    4101,\n/**/\n    4100,\n/**/\n    4099,\n/**/\n    4098,\n/**/\n    4097,\n/**/\n    4096,\n/**/\n    4095,\n/**/\n    4094,\n/**/\n    4093,\n/**/\n    4092,\n/**/\n    4091,\n/**/\n    4090,\n/**/\n    4089,\n/**/\n    4088,\n/**/\n    4087,\n/**/\n    4086,\n/**/\n    4085,\n/**/\n    4084,\n/**/\n    4083,\n/**/\n    4082,\n/**/\n    4081,\n/**/\n    4080,\n/**/\n    4079,\n/**/\n    4078,\n/**/\n    4077,\n/**/\n    4076,\n/**/\n    4075,\n/**/\n    4074,\n/**/\n    4073,\n/**/\n    4072,\n/**/\n    4071,\n/**/\n    4070,\n/**/\n    4069,\n/**/\n    4068,\n/**/\n    4067,\n/**/\n    4066,\n/**/\n    4065,\n/**/\n    4064,\n/**/\n    4063,\n/**/\n    4062,\n/**/\n    4061,\n/**/\n    4060,\n/**/\n    4059,\n/**/\n    4058,\n/**/\n    4057,\n/**/\n    4056,\n/**/\n    4055,\n/**/\n    4054,\n/**/\n    4053,\n/**/\n    4052,\n/**/\n    4051,\n/**/\n    4050,\n/**/\n    4049,\n/**/\n    4048,\n/**/\n    4047,\n/**/\n    4046,\n/**/\n    4045,\n/**/\n    4044,\n/**/\n    4043,\n/**/\n    4042,\n/**/\n    4041,\n/**/\n    4040,\n/**/\n    4039,\n/**/\n    4038,\n/**/\n    4037,\n/**/\n    4036,\n/**/\n    4035,\n/**/\n    4034,\n/**/\n    4033,\n/**/\n    4032,\n/**/\n    4031,\n/**/\n    4030,\n/**/\n    4029,\n/**/\n    4028,\n/**/\n    4027,\n/**/\n    4026,\n/**/\n    4025,\n/**/\n    4024,\n/**/\n    4023,\n/**/\n    4022,\n/**/\n    4021,\n/**/\n    4020,\n/**/\n    4019,\n/**/\n    4018,\n/**/\n    4017,\n/**/\n    4016,\n/**/\n    4015,\n/**/\n    4014,\n/**/\n    4013,\n/**/\n    4012,\n/**/\n    4011,\n/**/\n    4010,\n/**/\n    4009,\n/**/\n    4008,\n/**/\n    4007,\n/**/\n    4006,\n/**/\n    4005,\n/**/\n    4004,\n/**/\n    4003,\n/**/\n    4002,\n/**/\n    4001,\n/**/\n    4000,\n/**/\n    3999,\n/**/\n    3998,\n/**/\n    3997,\n/**/\n    3996,\n/**/\n    3995,\n/**/\n    3994,\n/**/\n    3993,\n/**/\n    3992,\n/**/\n    3991,\n/**/\n    3990,\n/**/\n    3989,\n/**/\n    3988,\n/**/\n    3987,\n/**/\n    3986,\n/**/\n    3985,\n/**/\n    3984,\n/**/\n    3983,\n/**/\n    3982,\n/**/\n    3981,\n/**/\n    3980,\n/**/\n    3979,\n/**/\n    3978,\n/**/\n    3977,\n/**/\n    3976,\n/**/\n    3975,\n/**/\n    3974,\n/**/\n    3973,\n/**/\n    3972,\n/**/\n    3971,\n/**/\n    3970,\n/**/\n    3969,\n/**/\n    3968,\n/**/\n    3967,\n/**/\n    3966,\n/**/\n    3965,\n/**/\n    3964,\n/**/\n    3963,\n/**/\n    3962,\n/**/\n    3961,\n/**/\n    3960,\n/**/\n    3959,\n/**/\n    3958,\n/**/\n    3957,\n/**/\n    3956,\n/**/\n    3955,\n/**/\n    3954,\n/**/\n    3953,\n/**/\n    3952,\n/**/\n    3951,\n/**/\n    3950,\n/**/\n    3949,\n/**/\n    3948,\n/**/\n    3947,\n/**/\n    3946,\n/**/\n    3945,\n/**/\n    3944,\n/**/\n    3943,\n/**/\n    3942,\n/**/\n    3941,\n/**/\n    3940,\n/**/\n    3939,\n/**/\n    3938,\n/**/\n    3937,\n/**/\n    3936,\n/**/\n    3935,\n/**/\n    3934,\n/**/\n    3933,\n/**/\n    3932,\n/**/\n    3931,\n/**/\n    3930,\n/**/\n    3929,\n/**/\n    3928,\n/**/\n    3927,\n/**/\n    3926,\n/**/\n    3925,\n/**/\n    3924,\n/**/\n    3923,\n/**/\n    3922,\n/**/\n    3921,\n/**/\n    3920,\n/**/\n    3919,\n/**/\n    3918,\n/**/\n    3917,\n/**/\n    3916,\n/**/\n    3915,\n/**/\n    3914,\n/**/\n    3913,\n/**/\n    3912,\n/**/\n    3911,\n/**/\n    3910,\n/**/\n    3909,\n/**/\n    3908,\n/**/\n    3907,\n/**/\n    3906,\n/**/\n    3905,\n/**/\n    3904,\n/**/\n    3903,\n/**/\n    3902,\n/**/\n    3901,\n/**/\n    3900,\n/**/\n    3899,\n/**/\n    3898,\n/**/\n    3897,\n/**/\n    3896,\n/**/\n    3895,\n/**/\n    3894,\n/**/\n    3893,\n/**/\n    3892,\n/**/\n    3891,\n/**/\n    3890,\n/**/\n    3889,\n/**/\n    3888,\n/**/\n    3887,\n/**/\n    3886,\n/**/\n    3885,\n/**/\n    3884,\n/**/\n    3883,\n/**/\n    3882,\n/**/\n    3881,\n/**/\n    3880,\n/**/\n    3879,\n/**/\n    3878,\n/**/\n    3877,\n/**/\n    3876,\n/**/\n    3875,\n/**/\n    3874,\n/**/\n    3873,\n/**/\n    3872,\n/**/\n    3871,\n/**/\n    3870,\n/**/\n    3869,\n/**/\n    3868,\n/**/\n    3867,\n/**/\n    3866,\n/**/\n    3865,\n/**/\n    3864,\n/**/\n    3863,\n/**/\n    3862,\n/**/\n    3861,\n/**/\n    3860,\n/**/\n    3859,\n/**/\n    3858,\n/**/\n    3857,\n/**/\n    3856,\n/**/\n    3855,\n/**/\n    3854,\n/**/\n    3853,\n/**/\n    3852,\n/**/\n    3851,\n/**/\n    3850,\n/**/\n    3849,\n/**/\n    3848,\n/**/\n    3847,\n/**/\n    3846,\n/**/\n    3845,\n/**/\n    3844,\n/**/\n    3843,\n/**/\n    3842,\n/**/\n    3841,\n/**/\n    3840,\n/**/\n    3839,\n/**/\n    3838,\n/**/\n    3837,\n/**/\n    3836,\n/**/\n    3835,\n/**/\n    3834,\n/**/\n    3833,\n/**/\n    3832,\n/**/\n    3831,\n/**/\n    3830,\n/**/\n    3829,\n/**/\n    3828,\n/**/\n    3827,\n/**/\n    3826,\n/**/\n    3825,\n/**/\n    3824,\n/**/\n    3823,\n/**/\n    3822,\n/**/\n    3821,\n/**/\n    3820,\n/**/\n    3819,\n/**/\n    3818,\n/**/\n    3817,\n/**/\n    3816,\n/**/\n    3815,\n/**/\n    3814,\n/**/\n    3813,\n/**/\n    3812,\n/**/\n    3811,\n/**/\n    3810,\n/**/\n    3809,\n/**/\n    3808,\n/**/\n    3807,\n/**/\n    3806,\n/**/\n    3805,\n/**/\n    3804,\n/**/\n    3803,\n/**/\n    3802,\n/**/\n    3801,\n/**/\n    3800,\n/**/\n    3799,\n/**/\n    3798,\n/**/\n    3797,\n/**/\n    3796,\n/**/\n    3795,\n/**/\n    3794,\n/**/\n    3793,\n/**/\n    3792,\n/**/\n    3791,\n/**/\n    3790,\n/**/\n    3789,\n/**/\n    3788,\n/**/\n    3787,\n/**/\n    3786,\n/**/\n    3785,\n/**/\n    3784,\n/**/\n    3783,\n/**/\n    3782,\n/**/\n    3781,\n/**/\n    3780,\n/**/\n    3779,\n/**/\n    3778,\n/**/\n    3777,\n/**/\n    3776,\n/**/\n    3775,\n/**/\n    3774,\n/**/\n    3773,\n/**/\n    3772,\n/**/\n    3771,\n/**/\n    3770,\n/**/\n    3769,\n/**/\n    3768,\n/**/\n    3767,\n/**/\n    3766,\n/**/\n    3765,\n/**/\n    3764,\n/**/\n    3763,\n/**/\n    3762,\n/**/\n    3761,\n/**/\n    3760,\n/**/\n    3759,\n/**/\n    3758,\n/**/\n    3757,\n/**/\n    3756,\n/**/\n    3755,\n/**/\n    3754,\n/**/\n    3753,\n/**/\n    3752,\n/**/\n    3751,\n/**/\n    3750,\n/**/\n    3749,\n/**/\n    3748,\n/**/\n    3747,\n/**/\n    3746,\n/**/\n    3745,\n/**/\n    3744,\n/**/\n    3743,\n/**/\n    3742,\n/**/\n    3741,\n/**/\n    3740,\n/**/\n    3739,\n/**/\n    3738,\n/**/\n    3737,\n/**/\n    3736,\n/**/\n    3735,\n/**/\n    3734,\n/**/\n    3733,\n/**/\n    3732,\n/**/\n    3731,\n/**/\n    3730,\n/**/\n    3729,\n/**/\n    3728,\n/**/\n    3727,\n/**/\n    3726,\n/**/\n    3725,\n/**/\n    3724,\n/**/\n    3723,\n/**/\n    3722,\n/**/\n    3721,\n/**/\n    3720,\n/**/\n    3719,\n/**/\n    3718,\n/**/\n    3717,\n/**/\n    3716,\n/**/\n    3715,\n/**/\n    3714,\n/**/\n    3713,\n/**/\n    3712,\n/**/\n    3711,\n/**/\n    3710,\n/**/\n    3709,\n/**/\n    3708,\n/**/\n    3707,\n/**/\n    3706,\n/**/\n    3705,\n/**/\n    3704,\n/**/\n    3703,\n/**/\n    3702,\n/**/\n    3701,\n/**/\n    3700,\n/**/\n    3699,\n/**/\n    3698,\n/**/\n    3697,\n/**/\n    3696,\n/**/\n    3695,\n/**/\n    3694,\n/**/\n    3693,\n/**/\n    3692,\n/**/\n    3691,\n/**/\n    3690,\n/**/\n    3689,\n/**/\n    3688,\n/**/\n    3687,\n/**/\n    3686,\n/**/\n    3685,\n/**/\n    3684,\n/**/\n    3683,\n/**/\n    3682,\n/**/\n    3681,\n/**/\n    3680,\n/**/\n    3679,\n/**/\n    3678,\n/**/\n    3677,\n/**/\n    3676,\n/**/\n    3675,\n/**/\n    3674,\n/**/\n    3673,\n/**/\n    3672,\n/**/\n    3671,\n/**/\n    3670,\n/**/\n    3669,\n/**/\n    3668,\n/**/\n    3667,\n/**/\n    3666,\n/**/\n    3665,\n/**/\n    3664,\n/**/\n    3663,\n/**/\n    3662,\n/**/\n    3661,\n/**/\n    3660,\n/**/\n    3659,\n/**/\n    3658,\n/**/\n    3657,\n/**/\n    3656,\n/**/\n    3655,\n/**/\n    3654,\n/**/\n    3653,\n/**/\n    3652,\n/**/\n    3651,\n/**/\n    3650,\n/**/\n    3649,\n/**/\n    3648,\n/**/\n    3647,\n/**/\n    3646,\n/**/\n    3645,\n/**/\n    3644,\n/**/\n    3643,\n/**/\n    3642,\n/**/\n    3641,\n/**/\n    3640,\n/**/\n    3639,\n/**/\n    3638,\n/**/\n    3637,\n/**/\n    3636,\n/**/\n    3635,\n/**/\n    3634,\n/**/\n    3633,\n/**/\n    3632,\n/**/\n    3631,\n/**/\n    3630,\n/**/\n    3629,\n/**/\n    3628,\n/**/\n    3627,\n/**/\n    3626,\n/**/\n    3625,\n/**/\n    3624,\n/**/\n    3623,\n/**/\n    3622,\n/**/\n    3621,\n/**/\n    3620,\n/**/\n    3619,\n/**/\n    3618,\n/**/\n    3617,\n/**/\n    3616,\n/**/\n    3615,\n/**/\n    3614,\n/**/\n    3613,\n/**/\n    3612,\n/**/\n    3611,\n/**/\n    3610,\n/**/\n    3609,\n/**/\n    3608,\n/**/\n    3607,\n/**/\n    3606,\n/**/\n    3605,\n/**/\n    3604,\n/**/\n    3603,\n/**/\n    3602,\n/**/\n    3601,\n/**/\n    3600,\n/**/\n    3599,\n/**/\n    3598,\n/**/\n    3597,\n/**/\n    3596,\n/**/\n    3595,\n/**/\n    3594,\n/**/\n    3593,\n/**/\n    3592,\n/**/\n    3591,\n/**/\n    3590,\n/**/\n    3589,\n/**/\n    3588,\n/**/\n    3587,\n/**/\n    3586,\n/**/\n    3585,\n/**/\n    3584,\n/**/\n    3583,\n/**/\n    3582,\n/**/\n    3581,\n/**/\n    3580,\n/**/\n    3579,\n/**/\n    3578,\n/**/\n    3577,\n/**/\n    3576,\n/**/\n    3575,\n/**/\n    3574,\n/**/\n    3573,\n/**/\n    3572,\n/**/\n    3571,\n/**/\n    3570,\n/**/\n    3569,\n/**/\n    3568,\n/**/\n    3567,\n/**/\n    3566,\n/**/\n    3565,\n/**/\n    3564,\n/**/\n    3563,\n/**/\n    3562,\n/**/\n    3561,\n/**/\n    3560,\n/**/\n    3559,\n/**/\n    3558,\n/**/\n    3557,\n/**/\n    3556,\n/**/\n    3555,\n/**/\n    3554,\n/**/\n    3553,\n/**/\n    3552,\n/**/\n    3551,\n/**/\n    3550,\n/**/\n    3549,\n/**/\n    3548,\n/**/\n    3547,\n/**/\n    3546,\n/**/\n    3545,\n/**/\n    3544,\n/**/\n    3543,\n/**/\n    3542,\n/**/\n    3541,\n/**/\n    3540,\n/**/\n    3539,\n/**/\n    3538,\n/**/\n    3537,\n/**/\n    3536,\n/**/\n    3535,\n/**/\n    3534,\n/**/\n    3533,\n/**/\n    3532,\n/**/\n    3531,\n/**/\n    3530,\n/**/\n    3529,\n/**/\n    3528,\n/**/\n    3527,\n/**/\n    3526,\n/**/\n    3525,\n/**/\n    3524,\n/**/\n    3523,\n/**/\n    3522,\n/**/\n    3521,\n/**/\n    3520,\n/**/\n    3519,\n/**/\n    3518,\n/**/\n    3517,\n/**/\n    3516,\n/**/\n    3515,\n/**/\n    3514,\n/**/\n    3513,\n/**/\n    3512,\n/**/\n    3511,\n/**/\n    3510,\n/**/\n    3509,\n/**/\n    3508,\n/**/\n    3507,\n/**/\n    3506,\n/**/\n    3505,\n/**/\n    3504,\n/**/\n    3503,\n/**/\n    3502,\n/**/\n    3501,\n/**/\n    3500,\n/**/\n    3499,\n/**/\n    3498,\n/**/\n    3497,\n/**/\n    3496,\n/**/\n    3495,\n/**/\n    3494,\n/**/\n    3493,\n/**/\n    3492,\n/**/\n    3491,\n/**/\n    3490,\n/**/\n    3489,\n/**/\n    3488,\n/**/\n    3487,\n/**/\n    3486,\n/**/\n    3485,\n/**/\n    3484,\n/**/\n    3483,\n/**/\n    3482,\n/**/\n    3481,\n/**/\n    3480,\n/**/\n    3479,\n/**/\n    3478,\n/**/\n    3477,\n/**/\n    3476,\n/**/\n    3475,\n/**/\n    3474,\n/**/\n    3473,\n/**/\n    3472,\n/**/\n    3471,\n/**/\n    3470,\n/**/\n    3469,\n/**/\n    3468,\n/**/\n    3467,\n/**/\n    3466,\n/**/\n    3465,\n/**/\n    3464,\n/**/\n    3463,\n/**/\n    3462,\n/**/\n    3461,\n/**/\n    3460,\n/**/\n    3459,\n/**/\n    3458,\n/**/\n    3457,\n/**/\n    3456,\n/**/\n    3455,\n/**/\n    3454,\n/**/\n    3453,\n/**/\n    3452,\n/**/\n    3451,\n/**/\n    3450,\n/**/\n    3449,\n/**/\n    3448,\n/**/\n    3447,\n/**/\n    3446,\n/**/\n    3445,\n/**/\n    3444,\n/**/\n    3443,\n/**/\n    3442,\n/**/\n    3441,\n/**/\n    3440,\n/**/\n    3439,\n/**/\n    3438,\n/**/\n    3437,\n/**/\n    3436,\n/**/\n    3435,\n/**/\n    3434,\n/**/\n    3433,\n/**/\n    3432,\n/**/\n    3431,\n/**/\n    3430,\n/**/\n    3429,\n/**/\n    3428,\n/**/\n    3427,\n/**/\n    3426,\n/**/\n    3425,\n/**/\n    3424,\n/**/\n    3423,\n/**/\n    3422,\n/**/\n    3421,\n/**/\n    3420,\n/**/\n    3419,\n/**/\n    3418,\n/**/\n    3417,\n/**/\n    3416,\n/**/\n    3415,\n/**/\n    3414,\n/**/\n    3413,\n/**/\n    3412,\n/**/\n    3411,\n/**/\n    3410,\n/**/\n    3409,\n/**/\n    3408,\n/**/\n    3407,\n/**/\n    3406,\n/**/\n    3405,\n/**/\n    3404,\n/**/\n    3403,\n/**/\n    3402,\n/**/\n    3401,\n/**/\n    3400,\n/**/\n    3399,\n/**/\n    3398,\n/**/\n    3397,\n/**/\n    3396,\n/**/\n    3395,\n/**/\n    3394,\n/**/\n    3393,\n/**/\n    3392,\n/**/\n    3391,\n/**/\n    3390,\n/**/\n    3389,\n/**/\n    3388,\n/**/\n    3387,\n/**/\n    3386,\n/**/\n    3385,\n/**/\n    3384,\n/**/\n    3383,\n/**/\n    3382,\n/**/\n    3381,\n/**/\n    3380,\n/**/\n    3379,\n/**/\n    3378,\n/**/\n    3377,\n/**/\n    3376,\n/**/\n    3375,\n/**/\n    3374,\n/**/\n    3373,\n/**/\n    3372,\n/**/\n    3371,\n/**/\n    3370,\n/**/\n    3369,\n/**/\n    3368,\n/**/\n    3367,\n/**/\n    3366,\n/**/\n    3365,\n/**/\n    3364,\n/**/\n    3363,\n/**/\n    3362,\n/**/\n    3361,\n/**/\n    3360,\n/**/\n    3359,\n/**/\n    3358,\n/**/\n    3357,\n/**/\n    3356,\n/**/\n    3355,\n/**/\n    3354,\n/**/\n    3353,\n/**/\n    3352,\n/**/\n    3351,\n/**/\n    3350,\n/**/\n    3349,\n/**/\n    3348,\n/**/\n    3347,\n/**/\n    3346,\n/**/\n    3345,\n/**/\n    3344,\n/**/\n    3343,\n/**/\n    3342,\n/**/\n    3341,\n/**/\n    3340,\n/**/\n    3339,\n/**/\n    3338,\n/**/\n    3337,\n/**/\n    3336,\n/**/\n    3335,\n/**/\n    3334,\n/**/\n    3333,\n/**/\n    3332,\n/**/\n    3331,\n/**/\n    3330,\n/**/\n    3329,\n/**/\n    3328,\n/**/\n    3327,\n/**/\n    3326,\n/**/\n    3325,\n/**/\n    3324,\n/**/\n    3323,\n/**/\n    3322,\n/**/\n    3321,\n/**/\n    3320,\n/**/\n    3319,\n/**/\n    3318,\n/**/\n    3317,\n/**/\n    3316,\n/**/\n    3315,\n/**/\n    3314,\n/**/\n    3313,\n/**/\n    3312,\n/**/\n    3311,\n/**/\n    3310,\n/**/\n    3309,\n/**/\n    3308,\n/**/\n    3307,\n/**/\n    3306,\n/**/\n    3305,\n/**/\n    3304,\n/**/\n    3303,\n/**/\n    3302,\n/**/\n    3301,\n/**/\n    3300,\n/**/\n    3299,\n/**/\n    3298,\n/**/\n    3297,\n/**/\n    3296,\n/**/\n    3295,\n/**/\n    3294,\n/**/\n    3293,\n/**/\n    3292,\n/**/\n    3291,\n/**/\n    3290,\n/**/\n    3289,\n/**/\n    3288,\n/**/\n    3287,\n/**/\n    3286,\n/**/\n    3285,\n/**/\n    3284,\n/**/\n    3283,\n/**/\n    3282,\n/**/\n    3281,\n/**/\n    3280,\n/**/\n    3279,\n/**/\n    3278,\n/**/\n    3277,\n/**/\n    3276,\n/**/\n    3275,\n/**/\n    3274,\n/**/\n    3273,\n/**/\n    3272,\n/**/\n    3271,\n/**/\n    3270,\n/**/\n    3269,\n/**/\n    3268,\n/**/\n    3267,\n/**/\n    3266,\n/**/\n    3265,\n/**/\n    3264,\n/**/\n    3263,\n/**/\n    3262,\n/**/\n    3261,\n/**/\n    3260,\n/**/\n    3259,\n/**/\n    3258,\n/**/\n    3257,\n/**/\n    3256,\n/**/\n    3255,\n/**/\n    3254,\n/**/\n    3253,\n/**/\n    3252,\n/**/\n    3251,\n/**/\n    3250,\n/**/\n    3249,\n/**/\n    3248,\n/**/\n    3247,\n/**/\n    3246,\n/**/\n    3245,\n/**/\n    3244,\n/**/\n    3243,\n/**/\n    3242,\n/**/\n    3241,\n/**/\n    3240,\n/**/\n    3239,\n/**/\n    3238,\n/**/\n    3237,\n/**/\n    3236,\n/**/\n    3235,\n/**/\n    3234,\n/**/\n    3233,\n/**/\n    3232,\n/**/\n    3231,\n/**/\n    3230,\n/**/\n    3229,\n/**/\n    3228,\n/**/\n    3227,\n/**/\n    3226,\n/**/\n    3225,\n/**/\n    3224,\n/**/\n    3223,\n/**/\n    3222,\n/**/\n    3221,\n/**/\n    3220,\n/**/\n    3219,\n/**/\n    3218,\n/**/\n    3217,\n/**/\n    3216,\n/**/\n    3215,\n/**/\n    3214,\n/**/\n    3213,\n/**/\n    3212,\n/**/\n    3211,\n/**/\n    3210,\n/**/\n    3209,\n/**/\n    3208,\n/**/\n    3207,\n/**/\n    3206,\n/**/\n    3205,\n/**/\n    3204,\n/**/\n    3203,\n/**/\n    3202,\n/**/\n    3201,\n/**/\n    3200,\n/**/\n    3199,\n/**/\n    3198,\n/**/\n    3197,\n/**/\n    3196,\n/**/\n    3195,\n/**/\n    3194,\n/**/\n    3193,\n/**/\n    3192,\n/**/\n    3191,\n/**/\n    3190,\n/**/\n    3189,\n/**/\n    3188,\n/**/\n    3187,\n/**/\n    3186,\n/**/\n    3185,\n/**/\n    3184,\n/**/\n    3183,\n/**/\n    3182,\n/**/\n    3181,\n/**/\n    3180,\n/**/\n    3179,\n/**/\n    3178,\n/**/\n    3177,\n/**/\n    3176,\n/**/\n    3175,\n/**/\n    3174,\n/**/\n    3173,\n/**/\n    3172,\n/**/\n    3171,\n/**/\n    3170,\n/**/\n    3169,\n/**/\n    3168,\n/**/\n    3167,\n/**/\n    3166,\n/**/\n    3165,\n/**/\n    3164,\n/**/\n    3163,\n/**/\n    3162,\n/**/\n    3161,\n/**/\n    3160,\n/**/\n    3159,\n/**/\n    3158,\n/**/\n    3157,\n/**/\n    3156,\n/**/\n    3155,\n/**/\n    3154,\n/**/\n    3153,\n/**/\n    3152,\n/**/\n    3151,\n/**/\n    3150,\n/**/\n    3149,\n/**/\n    3148,\n/**/\n    3147,\n/**/\n    3146,\n/**/\n    3145,\n/**/\n    3144,\n/**/\n    3143,\n/**/\n    3142,\n/**/\n    3141,\n/**/\n    3140,\n/**/\n    3139,\n/**/\n    3138,\n/**/\n    3137,\n/**/\n    3136,\n/**/\n    3135,\n/**/\n    3134,\n/**/\n    3133,\n/**/\n    3132,\n/**/\n    3131,\n/**/\n    3130,\n/**/\n    3129,\n/**/\n    3128,\n/**/\n    3127,\n/**/\n    3126,\n/**/\n    3125,\n/**/\n    3124,\n/**/\n    3123,\n/**/\n    3122,\n/**/\n    3121,\n/**/\n    3120,\n/**/\n    3119,\n/**/\n    3118,\n/**/\n    3117,\n/**/\n    3116,\n/**/\n    3115,\n/**/\n    3114,\n/**/\n    3113,\n/**/\n    3112,\n/**/\n    3111,\n/**/\n    3110,\n/**/\n    3109,\n/**/\n    3108,\n/**/\n    3107,\n/**/\n    3106,\n/**/\n    3105,\n/**/\n    3104,\n/**/\n    3103,\n/**/\n    3102,\n/**/\n    3101,\n/**/\n    3100,\n/**/\n    3099,\n/**/\n    3098,\n/**/\n    3097,\n/**/\n    3096,\n/**/\n    3095,\n/**/\n    3094,\n/**/\n    3093,\n/**/\n    3092,\n/**/\n    3091,\n/**/\n    3090,\n/**/\n    3089,\n/**/\n    3088,\n/**/\n    3087,\n/**/\n    3086,\n/**/\n    3085,\n/**/\n    3084,\n/**/\n    3083,\n/**/\n    3082,\n/**/\n    3081,\n/**/\n    3080,\n/**/\n    3079,\n/**/\n    3078,\n/**/\n    3077,\n/**/\n    3076,\n/**/\n    3075,\n/**/\n    3074,\n/**/\n    3073,\n/**/\n    3072,\n/**/\n    3071,\n/**/\n    3070,\n/**/\n    3069,\n/**/\n    3068,\n/**/\n    3067,\n/**/\n    3066,\n/**/\n    3065,\n/**/\n    3064,\n/**/\n    3063,\n/**/\n    3062,\n/**/\n    3061,\n/**/\n    3060,\n/**/\n    3059,\n/**/\n    3058,\n/**/\n    3057,\n/**/\n    3056,\n/**/\n    3055,\n/**/\n    3054,\n/**/\n    3053,\n/**/\n    3052,\n/**/\n    3051,\n/**/\n    3050,\n/**/\n    3049,\n/**/\n    3048,\n/**/\n    3047,\n/**/\n    3046,\n/**/\n    3045,\n/**/\n    3044,\n/**/\n    3043,\n/**/\n    3042,\n/**/\n    3041,\n/**/\n    3040,\n/**/\n    3039,\n/**/\n    3038,\n/**/\n    3037,\n/**/\n    3036,\n/**/\n    3035,\n/**/\n    3034,\n/**/\n    3033,\n/**/\n    3032,\n/**/\n    3031,\n/**/\n    3030,\n/**/\n    3029,\n/**/\n    3028,\n/**/\n    3027,\n/**/\n    3026,\n/**/\n    3025,\n/**/\n    3024,\n/**/\n    3023,\n/**/\n    3022,\n/**/\n    3021,\n/**/\n    3020,\n/**/\n    3019,\n/**/\n    3018,\n/**/\n    3017,\n/**/\n    3016,\n/**/\n    3015,\n/**/\n    3014,\n/**/\n    3013,\n/**/\n    3012,\n/**/\n    3011,\n/**/\n    3010,\n/**/\n    3009,\n/**/\n    3008,\n/**/\n    3007,\n/**/\n    3006,\n/**/\n    3005,\n/**/\n    3004,\n/**/\n    3003,\n/**/\n    3002,\n/**/\n    3001,\n/**/\n    3000,\n/**/\n    2999,\n/**/\n    2998,\n/**/\n    2997,\n/**/\n    2996,\n/**/\n    2995,\n/**/\n    2994,\n/**/\n    2993,\n/**/\n    2992,\n/**/\n    2991,\n/**/\n    2990,\n/**/\n    2989,\n/**/\n    2988,\n/**/\n    2987,\n/**/\n    2986,\n/**/\n    2985,\n/**/\n    2984,\n/**/\n    2983,\n/**/\n    2982,\n/**/\n    2981,\n/**/\n    2980,\n/**/\n    2979,\n/**/\n    2978,\n/**/\n    2977,\n/**/\n    2976,\n/**/\n    2975,\n/**/\n    2974,\n/**/\n    2973,\n/**/\n    2972,\n/**/\n    2971,\n/**/\n    2970,\n/**/\n    2969,\n/**/\n    2968,\n/**/\n    2967,\n/**/\n    2966,\n/**/\n    2965,\n/**/\n    2964,\n/**/\n    2963,\n/**/\n    2962,\n/**/\n    2961,\n/**/\n    2960,\n/**/\n    2959,\n/**/\n    2958,\n/**/\n    2957,\n/**/\n    2956,\n/**/\n    2955,\n/**/\n    2954,\n/**/\n    2953,\n/**/\n    2952,\n/**/\n    2951,\n/**/\n    2950,\n/**/\n    2949,\n/**/\n    2948,\n/**/\n    2947,\n/**/\n    2946,\n/**/\n    2945,\n/**/\n    2944,\n/**/\n    2943,\n/**/\n    2942,\n/**/\n    2941,\n/**/\n    2940,\n/**/\n    2939,\n/**/\n    2938,\n/**/\n    2937,\n/**/\n    2936,\n/**/\n    2935,\n/**/\n    2934,\n/**/\n    2933,\n/**/\n    2932,\n/**/\n    2931,\n/**/\n    2930,\n/**/\n    2929,\n/**/\n    2928,\n/**/\n    2927,\n/**/\n    2926,\n/**/\n    2925,\n/**/\n    2924,\n/**/\n    2923,\n/**/\n    2922,\n/**/\n    2921,\n/**/\n    2920,\n/**/\n    2919,\n/**/\n    2918,\n/**/\n    2917,\n/**/\n    2916,\n/**/\n    2915,\n/**/\n    2914,\n/**/\n    2913,\n/**/\n    2912,\n/**/\n    2911,\n/**/\n    2910,\n/**/\n    2909,\n/**/\n    2908,\n/**/\n    2907,\n/**/\n    2906,\n/**/\n    2905,\n/**/\n    2904,\n/**/\n    2903,\n/**/\n    2902,\n/**/\n    2901,\n/**/\n    2900,\n/**/\n    2899,\n/**/\n    2898,\n/**/\n    2897,\n/**/\n    2896,\n/**/\n    2895,\n/**/\n    2894,\n/**/\n    2893,\n/**/\n    2892,\n/**/\n    2891,\n/**/\n    2890,\n/**/\n    2889,\n/**/\n    2888,\n/**/\n    2887,\n/**/\n    2886,\n/**/\n    2885,\n/**/\n    2884,\n/**/\n    2883,\n/**/\n    2882,\n/**/\n    2881,\n/**/\n    2880,\n/**/\n    2879,\n/**/\n    2878,\n/**/\n    2877,\n/**/\n    2876,\n/**/\n    2875,\n/**/\n    2874,\n/**/\n    2873,\n/**/\n    2872,\n/**/\n    2871,\n/**/\n    2870,\n/**/\n    2869,\n/**/\n    2868,\n/**/\n    2867,\n/**/\n    2866,\n/**/\n    2865,\n/**/\n    2864,\n/**/\n    2863,\n/**/\n    2862,\n/**/\n    2861,\n/**/\n    2860,\n/**/\n    2859,\n/**/\n    2858,\n/**/\n    2857,\n/**/\n    2856,\n/**/\n    2855,\n/**/\n    2854,\n/**/\n    2853,\n/**/\n    2852,\n/**/\n    2851,\n/**/\n    2850,\n/**/\n    2849,\n/**/\n    2848,\n/**/\n    2847,\n/**/\n    2846,\n/**/\n    2845,\n/**/\n    2844,\n/**/\n    2843,\n/**/\n    2842,\n/**/\n    2841,\n/**/\n    2840,\n/**/\n    2839,\n/**/\n    2838,\n/**/\n    2837,\n/**/\n    2836,\n/**/\n    2835,\n/**/\n    2834,\n/**/\n    2833,\n/**/\n    2832,\n/**/\n    2831,\n/**/\n    2830,\n/**/\n    2829,\n/**/\n    2828,\n/**/\n    2827,\n/**/\n    2826,\n/**/\n    2825,\n/**/\n    2824,\n/**/\n    2823,\n/**/\n    2822,\n/**/\n    2821,\n/**/\n    2820,\n/**/\n    2819,\n/**/\n    2818,\n/**/\n    2817,\n/**/\n    2816,\n/**/\n    2815,\n/**/\n    2814,\n/**/\n    2813,\n/**/\n    2812,\n/**/\n    2811,\n/**/\n    2810,\n/**/\n    2809,\n/**/\n    2808,\n/**/\n    2807,\n/**/\n    2806,\n/**/\n    2805,\n/**/\n    2804,\n/**/\n    2803,\n/**/\n    2802,\n/**/\n    2801,\n/**/\n    2800,\n/**/\n    2799,\n/**/\n    2798,\n/**/\n    2797,\n/**/\n    2796,\n/**/\n    2795,\n/**/\n    2794,\n/**/\n    2793,\n/**/\n    2792,\n/**/\n    2791,\n/**/\n    2790,\n/**/\n    2789,\n/**/\n    2788,\n/**/\n    2787,\n/**/\n    2786,\n/**/\n    2785,\n/**/\n    2784,\n/**/\n    2783,\n/**/\n    2782,\n/**/\n    2781,\n/**/\n    2780,\n/**/\n    2779,\n/**/\n    2778,\n/**/\n    2777,\n/**/\n    2776,\n/**/\n    2775,\n/**/\n    2774,\n/**/\n    2773,\n/**/\n    2772,\n/**/\n    2771,\n/**/\n    2770,\n/**/\n    2769,\n/**/\n    2768,\n/**/\n    2767,\n/**/\n    2766,\n/**/\n    2765,\n/**/\n    2764,\n/**/\n    2763,\n/**/\n    2762,\n/**/\n    2761,\n/**/\n    2760,\n/**/\n    2759,\n/**/\n    2758,\n/**/\n    2757,\n/**/\n    2756,\n/**/\n    2755,\n/**/\n    2754,\n/**/\n    2753,\n/**/\n    2752,\n/**/\n    2751,\n/**/\n    2750,\n/**/\n    2749,\n/**/\n    2748,\n/**/\n    2747,\n/**/\n    2746,\n/**/\n    2745,\n/**/\n    2744,\n/**/\n    2743,\n/**/\n    2742,\n/**/\n    2741,\n/**/\n    2740,\n/**/\n    2739,\n/**/\n    2738,\n/**/\n    2737,\n/**/\n    2736,\n/**/\n    2735,\n/**/\n    2734,\n/**/\n    2733,\n/**/\n    2732,\n/**/\n    2731,\n/**/\n    2730,\n/**/\n    2729,\n/**/\n    2728,\n/**/\n    2727,\n/**/\n    2726,\n/**/\n    2725,\n/**/\n    2724,\n/**/\n    2723,\n/**/\n    2722,\n/**/\n    2721,\n/**/\n    2720,\n/**/\n    2719,\n/**/\n    2718,\n/**/\n    2717,\n/**/\n    2716,\n/**/\n    2715,\n/**/\n    2714,\n/**/\n    2713,\n/**/\n    2712,\n/**/\n    2711,\n/**/\n    2710,\n/**/\n    2709,\n/**/\n    2708,\n/**/\n    2707,\n/**/\n    2706,\n/**/\n    2705,\n/**/\n    2704,\n/**/\n    2703,\n/**/\n    2702,\n/**/\n    2701,\n/**/\n    2700,\n/**/\n    2699,\n/**/\n    2698,\n/**/\n    2697,\n/**/\n    2696,\n/**/\n    2695,\n/**/\n    2694,\n/**/\n    2693,\n/**/\n    2692,\n/**/\n    2691,\n/**/\n    2690,\n/**/\n    2689,\n/**/\n    2688,\n/**/\n    2687,\n/**/\n    2686,\n/**/\n    2685,\n/**/\n    2684,\n/**/\n    2683,\n/**/\n    2682,\n/**/\n    2681,\n/**/\n    2680,\n/**/\n    2679,\n/**/\n    2678,\n/**/\n    2677,\n/**/\n    2676,\n/**/\n    2675,\n/**/\n    2674,\n/**/\n    2673,\n/**/\n    2672,\n/**/\n    2671,\n/**/\n    2670,\n/**/\n    2669,\n/**/\n    2668,\n/**/\n    2667,\n/**/\n    2666,\n/**/\n    2665,\n/**/\n    2664,\n/**/\n    2663,\n/**/\n    2662,\n/**/\n    2661,\n/**/\n    2660,\n/**/\n    2659,\n/**/\n    2658,\n/**/\n    2657,\n/**/\n    2656,\n/**/\n    2655,\n/**/\n    2654,\n/**/\n    2653,\n/**/\n    2652,\n/**/\n    2651,\n/**/\n    2650,\n/**/\n    2649,\n/**/\n    2648,\n/**/\n    2647,\n/**/\n    2646,\n/**/\n    2645,\n/**/\n    2644,\n/**/\n    2643,\n/**/\n    2642,\n/**/\n    2641,\n/**/\n    2640,\n/**/\n    2639,\n/**/\n    2638,\n/**/\n    2637,\n/**/\n    2636,\n/**/\n    2635,\n/**/\n    2634,\n/**/\n    2633,\n/**/\n    2632,\n/**/\n    2631,\n/**/\n    2630,\n/**/\n    2629,\n/**/\n    2628,\n/**/\n    2627,\n/**/\n    2626,\n/**/\n    2625,\n/**/\n    2624,\n/**/\n    2623,\n/**/\n    2622,\n/**/\n    2621,\n/**/\n    2620,\n/**/\n    2619,\n/**/\n    2618,\n/**/\n    2617,\n/**/\n    2616,\n/**/\n    2615,\n/**/\n    2614,\n/**/\n    2613,\n/**/\n    2612,\n/**/\n    2611,\n/**/\n    2610,\n/**/\n    2609,\n/**/\n    2608,\n/**/\n    2607,\n/**/\n    2606,\n/**/\n    2605,\n/**/\n    2604,\n/**/\n    2603,\n/**/\n    2602,\n/**/\n    2601,\n/**/\n    2600,\n/**/\n    2599,\n/**/\n    2598,\n/**/\n    2597,\n/**/\n    2596,\n/**/\n    2595,\n/**/\n    2594,\n/**/\n    2593,\n/**/\n    2592,\n/**/\n    2591,\n/**/\n    2590,\n/**/\n    2589,\n/**/\n    2588,\n/**/\n    2587,\n/**/\n    2586,\n/**/\n    2585,\n/**/\n    2584,\n/**/\n    2583,\n/**/\n    2582,\n/**/\n    2581,\n/**/\n    2580,\n/**/\n    2579,\n/**/\n    2578,\n/**/\n    2577,\n/**/\n    2576,\n/**/\n    2575,\n/**/\n    2574,\n/**/\n    2573,\n/**/\n    2572,\n/**/\n    2571,\n/**/\n    2570,\n/**/\n    2569,\n/**/\n    2568,\n/**/\n    2567,\n/**/\n    2566,\n/**/\n    2565,\n/**/\n    2564,\n/**/\n    2563,\n/**/\n    2562,\n/**/\n    2561,\n/**/\n    2560,\n/**/\n    2559,\n/**/\n    2558,\n/**/\n    2557,\n/**/\n    2556,\n/**/\n    2555,\n/**/\n    2554,\n/**/\n    2553,\n/**/\n    2552,\n/**/\n    2551,\n/**/\n    2550,\n/**/\n    2549,\n/**/\n    2548,\n/**/\n    2547,\n/**/\n    2546,\n/**/\n    2545,\n/**/\n    2544,\n/**/\n    2543,\n/**/\n    2542,\n/**/\n    2541,\n/**/\n    2540,\n/**/\n    2539,\n/**/\n    2538,\n/**/\n    2537,\n/**/\n    2536,\n/**/\n    2535,\n/**/\n    2534,\n/**/\n    2533,\n/**/\n    2532,\n/**/\n    2531,\n/**/\n    2530,\n/**/\n    2529,\n/**/\n    2528,\n/**/\n    2527,\n/**/\n    2526,\n/**/\n    2525,\n/**/\n    2524,\n/**/\n    2523,\n/**/\n    2522,\n/**/\n    2521,\n/**/\n    2520,\n/**/\n    2519,\n/**/\n    2518,\n/**/\n    2517,\n/**/\n    2516,\n/**/\n    2515,\n/**/\n    2514,\n/**/\n    2513,\n/**/\n    2512,\n/**/\n    2511,\n/**/\n    2510,\n/**/\n    2509,\n/**/\n    2508,\n/**/\n    2507,\n/**/\n    2506,\n/**/\n    2505,\n/**/\n    2504,\n/**/\n    2503,\n/**/\n    2502,\n/**/\n    2501,\n/**/\n    2500,\n/**/\n    2499,\n/**/\n    2498,\n/**/\n    2497,\n/**/\n    2496,\n/**/\n    2495,\n/**/\n    2494,\n/**/\n    2493,\n/**/\n    2492,\n/**/\n    2491,\n/**/\n    2490,\n/**/\n    2489,\n/**/\n    2488,\n/**/\n    2487,\n/**/\n    2486,\n/**/\n    2485,\n/**/\n    2484,\n/**/\n    2483,\n/**/\n    2482,\n/**/\n    2481,\n/**/\n    2480,\n/**/\n    2479,\n/**/\n    2478,\n/**/\n    2477,\n/**/\n    2476,\n/**/\n    2475,\n/**/\n    2474,\n/**/\n    2473,\n/**/\n    2472,\n/**/\n    2471,\n/**/\n    2470,\n/**/\n    2469,\n/**/\n    2468,\n/**/\n    2467,\n/**/\n    2466,\n/**/\n    2465,\n/**/\n    2464,\n/**/\n    2463,\n/**/\n    2462,\n/**/\n    2461,\n/**/\n    2460,\n/**/\n    2459,\n/**/\n    2458,\n/**/\n    2457,\n/**/\n    2456,\n/**/\n    2455,\n/**/\n    2454,\n/**/\n    2453,\n/**/\n    2452,\n/**/\n    2451,\n/**/\n    2450,\n/**/\n    2449,\n/**/\n    2448,\n/**/\n    2447,\n/**/\n    2446,\n/**/\n    2445,\n/**/\n    2444,\n/**/\n    2443,\n/**/\n    2442,\n/**/\n    2441,\n/**/\n    2440,\n/**/\n    2439,\n/**/\n    2438,\n/**/\n    2437,\n/**/\n    2436,\n/**/\n    2435,\n/**/\n    2434,\n/**/\n    2433,\n/**/\n    2432,\n/**/\n    2431,\n/**/\n    2430,\n/**/\n    2429,\n/**/\n    2428,\n/**/\n    2427,\n/**/\n    2426,\n/**/\n    2425,\n/**/\n    2424,\n/**/\n    2423,\n/**/\n    2422,\n/**/\n    2421,\n/**/\n    2420,\n/**/\n    2419,\n/**/\n    2418,\n/**/\n    2417,\n/**/\n    2416,\n/**/\n    2415,\n/**/\n    2414,\n/**/\n    2413,\n/**/\n    2412,\n/**/\n    2411,\n/**/\n    2410,\n/**/\n    2409,\n/**/\n    2408,\n/**/\n    2407,\n/**/\n    2406,\n/**/\n    2405,\n/**/\n    2404,\n/**/\n    2403,\n/**/\n    2402,\n/**/\n    2401,\n/**/\n    2400,\n/**/\n    2399,\n/**/\n    2398,\n/**/\n    2397,\n/**/\n    2396,\n/**/\n    2395,\n/**/\n    2394,\n/**/\n    2393,\n/**/\n    2392,\n/**/\n    2391,\n/**/\n    2390,\n/**/\n    2389,\n/**/\n    2388,\n/**/\n    2387,\n/**/\n    2386,\n/**/\n    2385,\n/**/\n    2384,\n/**/\n    2383,\n/**/\n    2382,\n/**/\n    2381,\n/**/\n    2380,\n/**/\n    2379,\n/**/\n    2378,\n/**/\n    2377,\n/**/\n    2376,\n/**/\n    2375,\n/**/\n    2374,\n/**/\n    2373,\n/**/\n    2372,\n/**/\n    2371,\n/**/\n    2370,\n/**/\n    2369,\n/**/\n    2368,\n/**/\n    2367,\n/**/\n    2366,\n/**/\n    2365,\n/**/\n    2364,\n/**/\n    2363,\n/**/\n    2362,\n/**/\n    2361,\n/**/\n    2360,\n/**/\n    2359,\n/**/\n    2358,\n/**/\n    2357,\n/**/\n    2356,\n/**/\n    2355,\n/**/\n    2354,\n/**/\n    2353,\n/**/\n    2352,\n/**/\n    2351,\n/**/\n    2350,\n/**/\n    2349,\n/**/\n    2348,\n/**/\n    2347,\n/**/\n    2346,\n/**/\n    2345,\n/**/\n    2344,\n/**/\n    2343,\n/**/\n    2342,\n/**/\n    2341,\n/**/\n    2340,\n/**/\n    2339,\n/**/\n    2338,\n/**/\n    2337,\n/**/\n    2336,\n/**/\n    2335,\n/**/\n    2334,\n/**/\n    2333,\n/**/\n    2332,\n/**/\n    2331,\n/**/\n    2330,\n/**/\n    2329,\n/**/\n    2328,\n/**/\n    2327,\n/**/\n    2326,\n/**/\n    2325,\n/**/\n    2324,\n/**/\n    2323,\n/**/\n    2322,\n/**/\n    2321,\n/**/\n    2320,\n/**/\n    2319,\n/**/\n    2318,\n/**/\n    2317,\n/**/\n    2316,\n/**/\n    2315,\n/**/\n    2314,\n/**/\n    2313,\n/**/\n    2312,\n/**/\n    2311,\n/**/\n    2310,\n/**/\n    2309,\n/**/\n    2308,\n/**/\n    2307,\n/**/\n    2306,\n/**/\n    2305,\n/**/\n    2304,\n/**/\n    2303,\n/**/\n    2302,\n/**/\n    2301,\n/**/\n    2300,\n/**/\n    2299,\n/**/\n    2298,\n/**/\n    2297,\n/**/\n    2296,\n/**/\n    2295,\n/**/\n    2294,\n/**/\n    2293,\n/**/\n    2292,\n/**/\n    2291,\n/**/\n    2290,\n/**/\n    2289,\n/**/\n    2288,\n/**/\n    2287,\n/**/\n    2286,\n/**/\n    2285,\n/**/\n    2284,\n/**/\n    2283,\n/**/\n    2282,\n/**/\n    2281,\n/**/\n    2280,\n/**/\n    2279,\n/**/\n    2278,\n/**/\n    2277,\n/**/\n    2276,\n/**/\n    2275,\n/**/\n    2274,\n/**/\n    2273,\n/**/\n    2272,\n/**/\n    2271,\n/**/\n    2270,\n/**/\n    2269,\n/**/\n    2268,\n/**/\n    2267,\n/**/\n    2266,\n/**/\n    2265,\n/**/\n    2264,\n/**/\n    2263,\n/**/\n    2262,\n/**/\n    2261,\n/**/\n    2260,\n/**/\n    2259,\n/**/\n    2258,\n/**/\n    2257,\n/**/\n    2256,\n/**/\n    2255,\n/**/\n    2254,\n/**/\n    2253,\n/**/\n    2252,\n/**/\n    2251,\n/**/\n    2250,\n/**/\n    2249,\n/**/\n    2248,\n/**/\n    2247,\n/**/\n    2246,\n/**/\n    2245,\n/**/\n    2244,\n/**/\n    2243,\n/**/\n    2242,\n/**/\n    2241,\n/**/\n    2240,\n/**/\n    2239,\n/**/\n    2238,\n/**/\n    2237,\n/**/\n    2236,\n/**/\n    2235,\n/**/\n    2234,\n/**/\n    2233,\n/**/\n    2232,\n/**/\n    2231,\n/**/\n    2230,\n/**/\n    2229,\n/**/\n    2228,\n/**/\n    2227,\n/**/\n    2226,\n/**/\n    2225,\n/**/\n    2224,\n/**/\n    2223,\n/**/\n    2222,\n/**/\n    2221,\n/**/\n    2220,\n/**/\n    2219,\n/**/\n    2218,\n/**/\n    2217,\n/**/\n    2216,\n/**/\n    2215,\n/**/\n    2214,\n/**/\n    2213,\n/**/\n    2212,\n/**/\n    2211,\n/**/\n    2210,\n/**/\n    2209,\n/**/\n    2208,\n/**/\n    2207,\n/**/\n    2206,\n/**/\n    2205,\n/**/\n    2204,\n/**/\n    2203,\n/**/\n    2202,\n/**/\n    2201,\n/**/\n    2200,\n/**/\n    2199,\n/**/\n    2198,\n/**/\n    2197,\n/**/\n    2196,\n/**/\n    2195,\n/**/\n    2194,\n/**/\n    2193,\n/**/\n    2192,\n/**/\n    2191,\n/**/\n    2190,\n/**/\n    2189,\n/**/\n    2188,\n/**/\n    2187,\n/**/\n    2186,\n/**/\n    2185,\n/**/\n    2184,\n/**/\n    2183,\n/**/\n    2182,\n/**/\n    2181,\n/**/\n    2180,\n/**/\n    2179,\n/**/\n    2178,\n/**/\n    2177,\n/**/\n    2176,\n/**/\n    2175,\n/**/\n    2174,\n/**/\n    2173,\n/**/\n    2172,\n/**/\n    2171,\n/**/\n    2170,\n/**/\n    2169,\n/**/\n    2168,\n/**/\n    2167,\n/**/\n    2166,\n/**/\n    2165,\n/**/\n    2164,\n/**/\n    2163,\n/**/\n    2162,\n/**/\n    2161,\n/**/\n    2160,\n/**/\n    2159,\n/**/\n    2158,\n/**/\n    2157,\n/**/\n    2156,\n/**/\n    2155,\n/**/\n    2154,\n/**/\n    2153,\n/**/\n    2152,\n/**/\n    2151,\n/**/\n    2150,\n/**/\n    2149,\n/**/\n    2148,\n/**/\n    2147,\n/**/\n    2146,\n/**/\n    2145,\n/**/\n    2144,\n/**/\n    2143,\n/**/\n    2142,\n/**/\n    2141,\n/**/\n    2140,\n/**/\n    2139,\n/**/\n    2138,\n/**/\n    2137,\n/**/\n    2136,\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    while (l < h)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "filenames": ["src/term.c", "src/version.c"], "buggy_code_start_loc": [3368, 737], "buggy_code_end_loc": [3368, 737], "fixing_code_start_loc": [3369, 738], "fixing_code_end_loc": [3375, 740], "type": "CWE-125", "message": "Out-of-bounds Read in GitHub repository vim/vim prior to 8.2.", "other": {"cve": {"id": "CVE-2022-2206", "sourceIdentifier": "security@huntr.dev", "published": "2022-06-26T19:15:09.103", "lastModified": "2023-05-03T12:15:47.010", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Out-of-bounds Read in GitHub repository vim/vim prior to 8.2."}, {"lang": "es", "value": "Una lectura fuera de l\u00edmites en el repositorio de GitHub vim/vim versiones anteriores a 8.2"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "8.2.5160", "matchCriteriaId": "791EA41D-CD9E-4ACD-9CB5-65F70E8BBEDB"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}]}]}], "references": [{"url": "https://github.com/vim/vim/commit/e178af5a586ea023622d460779fdcabbbfac0908", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/01d01e74-55d0-4d9e-878e-79ba599be668", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/GFD2A4YLBR7OIRHTL7CK6YNMEIQ264CN/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/U743FMJGFQ35GBPCQ6OWMVZEJPDFVEWM/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202208-32", "source": "security@huntr.dev", "tags": ["Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202305-16", "source": "security@huntr.dev"}]}, "github_commit_url": "https://github.com/vim/vim/commit/e178af5a586ea023622d460779fdcabbbfac0908"}}