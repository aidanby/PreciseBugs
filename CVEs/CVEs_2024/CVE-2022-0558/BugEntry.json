{"buggy_code": ["<?php\n\nnamespace MicroweberPackages\\Helper;\n\nclass HTMLClean\n{\n    public function clean($html) {\n\n        $antiXss = new \\voku\\helper\\AntiXSS();\n        $html = $antiXss->xss_clean($html);\n\n        $path = storage_path() . '/html_purifier';\n        if (!is_dir($path)) {\n            mkdir_recursive($path);\n        }\n\n        $config = \\HTMLPurifier_Config::createDefault();\n        if ($path) {\n            $config->set('Cache.SerializerPath', $path);\n        }\n\n        $config->set('URI.DisableExternal', true);\n        $config->set('URI.DisableExternalResources', true);\n    //    $config->set('URI.DisableResources', true);\n        $config->set('URI.Host', site_hostname());\n\n        $purifier = new \\HTMLPurifier($config);\n        $html = $purifier->purify($html);\n\n        return $html;\n    }\n}\n", "<?php\n/**\n * Created by PhpStorm.\n * User: Bojidar\n * Date: 2/27/2020\n * Time: 3:34 PM\n */\n\n// Language is changed\nevent_bind('mw.admin.change_language', function () {\n    sync_tags();\n});\n\nfunction sync_tags() {\n    $tagging_tags = db_get('tagging_tags', 'no_limit=1');\n    if (!empty($tagging_tags)) {\n        foreach ($tagging_tags as $tagging_tag) {\n            $save = tagging_tag_edit($tagging_tag);\n        }\n    }\n}\n\napi_expose_admin('tagging_tag/autocomplete', 'tagging_tag_autocomplete');\nfunction tagging_tag_autocomplete($params) {\n\n    $founded_tags = [];\n\n    $filter = '';\n    if (isset($params['keyword'])) {\n        $filter = 'keyword=' . $params['keyword'].'&search_in_fields=name,slug&no_cache=1';\n    }\n\n    $tagging_tags = db_get('tagging_tags', $filter);\n    if ($tagging_tags) {\n        foreach ($tagging_tags as $tagging_tag) {\n            $founded_tags[] = [\n                'id' => $tagging_tag['id'],\n                'title' => $tagging_tag['name'],\n            ];\n        }\n    }\n\n    return ['data'=>$founded_tags];\n}\n\napi_expose_admin('tagging_tag/edit', 'tagging_tag_edit');\nfunction tagging_tag_edit($params) {\n\n    if (empty(trim($params['name']))) {\n        return ['status'=>false];\n    }\n\n    if (!isset($params['slug'])) {\n        $params['slug'] = '';\n    }\n\n    if (!isset($params['description'])) {\n        $params['description'] = '';\n    }\n\n    $newData = [];\n    $newData['name'] = $params['name'];\n    $newData['slug'] = $params['slug'];\n    $newData['description'] = $params['description'];\n    if (isset($params['id'])) {\n        $newData['id'] = $params['id'];\n    }\n\n    if (isset($params['tagging_tag_id']) && !empty($params['tagging_tag_id'])) {\n        $tagging_tag_id = $params['tagging_tag_id'];\n        $tag = db_get('tagging_tags', [\n            'no_cache'=>false,\n            'id'=>$tagging_tag_id,\n            'single'=>1\n        ]);\n        if ($tag) {\n            $newData['id'] = $tag['id'];\n        }\n    }\n\n    if (empty($newData['slug'])) {\n        $newData['slug'] = mw()->url_manager->slug($newData['name']);\n    } else {\n        $newData['slug'] = mw()->url_manager->slug($newData['slug']);\n    }\n\n    // Update all posts name with tag slug\n    $getTaggingTagged = db_get('tagging_tagged', 'tag_slug='.$newData['slug'].'&no_cache=1');\n    if ($getTaggingTagged) {\n        foreach ($getTaggingTagged as $taggingTaggedPost) {\n\n            $newTaggingTaggedPost = [];\n            $newTaggingTaggedPost['id'] = $taggingTaggedPost['id'];\n            $newTaggingTaggedPost['tag_name'] = $newData['name'];\n\n            db_save('tagging_tagged', $newTaggingTaggedPost);\n        }\n    }\n\n    if (!isset($newData['id'])) {\n        $findTaggingTag = db_get('tagging_tags', 'slug=' . $newData['slug'].'&single=1');\n        if ($findTaggingTag) {\n            $newData['id'] = $findTaggingTag['id'];\n            return ['status'=>false,'message'=>'The tag slug is allready exists.', 'id'=> $newData['id']];\n        }\n    }\n\n\n    $tagSaved = db_save('tagging_tags',$newData);\n    if ($tagSaved) {\n\n        if (!isset($newData['id'])) {\n            $newData['id'] = $tagSaved;\n        }\n\n        return $newData;\n    }\n\n    return ['status'=>false];\n\n}\n\napi_expose_admin('tagging_tag/get', 'tagging_tag_get');\nfunction tagging_tag_get($params) {\n\n    $filter = 'order_by=id desc';\n    if (isset($params['keyword'])) {\n        $filter .= '&keyword=' . $params['keyword'].'&search_in_fields=name,slug';\n    }\n\n    $tagging_tags = db_get('tagging_tags', $filter);\n    if ($tagging_tags) {\n        foreach ($tagging_tags as &$tag) {\n            $tag['posts_count'] = db_get('tagging_tagged', [\n                'tag_slug'=>$tag['slug'],\n                'count'=>1\n            ]);\n        }\n        return $tagging_tags;\n    }\n\n    return ['error'=>true];\n}\n\napi_expose_admin('tagging_tag/view', 'tagging_tag_view');\nfunction tagging_tag_view($params) {\n\n    $tagging_tag_id = $params['tagging_tag_id'];\n    $filter = [\n        'no_cache'=>false,\n        'id'=>$tagging_tag_id,\n        'single'=>1\n    ];\n    $tag = db_get('tagging_tags', $filter);\n\n    return $tag;\n}\n\napi_expose_admin('tagging_tag/delete', 'tagging_tag_delete');\nfunction tagging_tag_delete($params) {\n\n    $tagging_tag_id = $params['tagging_tag_id'];\n    $filter = [\n        'no_cache'=>false,\n        'id'=>$tagging_tag_id,\n        'single'=>1\n    ];\n    $tag = db_get('tagging_tags', $filter);\n    if ($tag) {\n        if (db_delete('tagging_tags', $tagging_tag_id)) {\n\n            // Delete this tag for all posts\n            db_delete('tagging_tagged', $tag['name'], 'tag_name');\n\n            echo json_encode(['status'=>true]);\n            exit;\n        }\n    }\n\n    echo json_encode(['status'=>false]);\n    exit;\n}\n\n\n"], "fixing_code": ["<?php\n\nnamespace MicroweberPackages\\Helper;\n\nclass HTMLClean\n{\n    public function cleanArray($array) {\n        if (is_array($array)) {\n\n            $cleanedArray = [];\n            foreach ($array as $key=>$value) {\n                $cleanedArray[$key] = $this->clean($value);\n            }\n\n            return $cleanedArray;\n        }\n    }\n\n    public function clean($html) {\n\n        $antiXss = new \\voku\\helper\\AntiXSS();\n        $html = $antiXss->xss_clean($html);\n\n        $path = storage_path() . '/html_purifier';\n        if (!is_dir($path)) {\n            mkdir_recursive($path);\n        }\n\n        $config = \\HTMLPurifier_Config::createDefault();\n        if ($path) {\n            $config->set('Cache.SerializerPath', $path);\n        }\n\n        $config->set('URI.DisableExternal', true);\n        $config->set('URI.DisableExternalResources', true);\n    //    $config->set('URI.DisableResources', true);\n        $config->set('URI.Host', site_hostname());\n\n        $purifier = new \\HTMLPurifier($config);\n        $html = $purifier->purify($html);\n\n        return $html;\n    }\n}\n", "<?php\n/**\n * Created by PhpStorm.\n * User: Bojidar\n * Date: 2/27/2020\n * Time: 3:34 PM\n */\n\n// Language is changed\nevent_bind('mw.admin.change_language', function () {\n    sync_tags();\n});\n\nfunction sync_tags() {\n    $tagging_tags = db_get('tagging_tags', 'no_limit=1');\n    if (!empty($tagging_tags)) {\n        foreach ($tagging_tags as $tagging_tag) {\n            $save = tagging_tag_edit($tagging_tag);\n        }\n    }\n}\n\napi_expose_admin('tagging_tag/autocomplete', 'tagging_tag_autocomplete');\nfunction tagging_tag_autocomplete($params) {\n\n    $founded_tags = [];\n\n    $filter = '';\n    if (isset($params['keyword'])) {\n        $filter = 'keyword=' . $params['keyword'].'&search_in_fields=name,slug&no_cache=1';\n    }\n\n    $tagging_tags = db_get('tagging_tags', $filter);\n    if ($tagging_tags) {\n        foreach ($tagging_tags as $tagging_tag) {\n            $founded_tags[] = [\n                'id' => $tagging_tag['id'],\n                'title' => $tagging_tag['name'],\n            ];\n        }\n    }\n\n    return ['data'=>$founded_tags];\n}\n\napi_expose_admin('tagging_tag/edit', 'tagging_tag_edit');\nfunction tagging_tag_edit($params) {\n\n    if (empty(trim($params['name']))) {\n        return ['status'=>false];\n    }\n\n    if (!isset($params['slug'])) {\n        $params['slug'] = '';\n    }\n\n    if (!isset($params['description'])) {\n        $params['description'] = '';\n    }\n\n    $newData = [];\n    $newData['name'] = $params['name'];\n    $newData['slug'] = $params['slug'];\n    $newData['description'] = $params['description'];\n    if (isset($params['id'])) {\n        $newData['id'] = $params['id'];\n    }\n\n    $cleanInput = new \\MicroweberPackages\\Helper\\HTMLClean();\n    $newData = $cleanInput->cleanArray($newData);\n\n    if (isset($params['tagging_tag_id']) && !empty($params['tagging_tag_id'])) {\n        $tagging_tag_id = $params['tagging_tag_id'];\n        $tag = db_get('tagging_tags', [\n            'no_cache'=>false,\n            'id'=>$tagging_tag_id,\n            'single'=>1\n        ]);\n        if ($tag) {\n            $newData['id'] = $tag['id'];\n        }\n    }\n\n    if (empty($newData['slug'])) {\n        $newData['slug'] = mw()->url_manager->slug($newData['name']);\n    } else {\n        $newData['slug'] = mw()->url_manager->slug($newData['slug']);\n    }\n\n    // Update all posts name with tag slug\n    $getTaggingTagged = db_get('tagging_tagged', 'tag_slug='.$newData['slug'].'&no_cache=1');\n    if ($getTaggingTagged) {\n        foreach ($getTaggingTagged as $taggingTaggedPost) {\n\n            $newTaggingTaggedPost = [];\n            $newTaggingTaggedPost['id'] = $taggingTaggedPost['id'];\n            $newTaggingTaggedPost['tag_name'] = $newData['name'];\n\n            db_save('tagging_tagged', $newTaggingTaggedPost);\n        }\n    }\n\n    if (!isset($newData['id'])) {\n        $findTaggingTag = db_get('tagging_tags', 'slug=' . $newData['slug'].'&single=1');\n        if ($findTaggingTag) {\n            $newData['id'] = $findTaggingTag['id'];\n            return ['status'=>false,'message'=>'The tag slug is allready exists.', 'id'=> $newData['id']];\n        }\n    }\n\n    $tagSaved = db_save('tagging_tags',$newData);\n    if ($tagSaved) {\n\n        if (!isset($newData['id'])) {\n            $newData['id'] = $tagSaved;\n        }\n\n        return $newData;\n    }\n\n    return ['status'=>false];\n\n}\n\napi_expose_admin('tagging_tag/get', 'tagging_tag_get');\nfunction tagging_tag_get($params) {\n\n    $filter = 'order_by=id desc';\n    if (isset($params['keyword'])) {\n        $filter .= '&keyword=' . $params['keyword'].'&search_in_fields=name,slug';\n    }\n\n    $tagging_tags = db_get('tagging_tags', $filter);\n    if ($tagging_tags) {\n        foreach ($tagging_tags as &$tag) {\n            $tag['posts_count'] = db_get('tagging_tagged', [\n                'tag_slug'=>$tag['slug'],\n                'count'=>1\n            ]);\n        }\n        return $tagging_tags;\n    }\n\n    return ['error'=>true];\n}\n\napi_expose_admin('tagging_tag/view', 'tagging_tag_view');\nfunction tagging_tag_view($params) {\n\n    $tagging_tag_id = $params['tagging_tag_id'];\n    $filter = [\n        'no_cache'=>false,\n        'id'=>$tagging_tag_id,\n        'single'=>1\n    ];\n    $tag = db_get('tagging_tags', $filter);\n\n    return $tag;\n}\n\napi_expose_admin('tagging_tag/delete', 'tagging_tag_delete');\nfunction tagging_tag_delete($params) {\n\n    $tagging_tag_id = $params['tagging_tag_id'];\n    $filter = [\n        'no_cache'=>false,\n        'id'=>$tagging_tag_id,\n        'single'=>1\n    ];\n    $tag = db_get('tagging_tags', $filter);\n    if ($tag) {\n        if (db_delete('tagging_tags', $tagging_tag_id)) {\n\n            // Delete this tag for all posts\n            db_delete('tagging_tagged', $tag['name'], 'tag_name');\n\n            echo json_encode(['status'=>true]);\n            exit;\n        }\n    }\n\n    echo json_encode(['status'=>false]);\n    exit;\n}\n\n\n"], "filenames": ["src/MicroweberPackages/Helper/HTMLClean.php", "userfiles/modules/tags/TaggingTagsManager.php"], "buggy_code_start_loc": [6, 68], "buggy_code_end_loc": [6, 108], "fixing_code_start_loc": [7, 69], "fixing_code_end_loc": [19, 109], "type": "CWE-79", "message": "Cross-site Scripting (XSS) - Stored in Packagist microweber/microweber prior to 1.2.11.", "other": {"cve": {"id": "CVE-2022-0558", "sourceIdentifier": "security@huntr.dev", "published": "2022-02-10T10:15:14.797", "lastModified": "2022-02-17T13:54:33.137", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cross-site Scripting (XSS) - Stored in Packagist microweber/microweber prior to 1.2.11."}, {"lang": "es", "value": "Una vulnerabilidad de tipo Cross-site Scripting (XSS) - Almacenado en Packagist microweber/microweber versiones anteriores a 1.2.11"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:microweber:microweber:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.2.11", "matchCriteriaId": "52D59B39-B1A3-45D1-B4C4-65BEF86F2D85"}]}]}], "references": [{"url": "https://github.com/microweber/microweber/commit/14a1bb971bcb8b5456c2bf0020c3018907a2704d", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/8fffc95f-14ae-457b-aecc-be4716a8b91c", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/microweber/microweber/commit/14a1bb971bcb8b5456c2bf0020c3018907a2704d"}}