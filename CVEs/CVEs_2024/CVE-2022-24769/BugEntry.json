{"buggy_code": ["package daemon // import \"github.com/docker/docker/daemon\"\n\nimport (\n\t\"context\"\n\n\t\"github.com/containerd/containerd/pkg/apparmor\"\n\t\"github.com/docker/docker/container\"\n\t\"github.com/docker/docker/daemon/exec\"\n\t\"github.com/docker/docker/oci/caps\"\n\tspecs \"github.com/opencontainers/runtime-spec/specs-go\"\n)\n\nfunc (daemon *Daemon) execSetPlatformOpt(c *container.Container, ec *exec.Config, p *specs.Process) error {\n\tif len(ec.User) > 0 {\n\t\tvar err error\n\t\tp.User, err = getUser(c, ec.User)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif ec.Privileged {\n\t\tif p.Capabilities == nil {\n\t\t\tp.Capabilities = &specs.LinuxCapabilities{}\n\t\t}\n\t\tp.Capabilities.Bounding = caps.GetAllCapabilities()\n\t\tp.Capabilities.Permitted = p.Capabilities.Bounding\n\t\tp.Capabilities.Inheritable = p.Capabilities.Bounding\n\t\tp.Capabilities.Effective = p.Capabilities.Bounding\n\t}\n\tif apparmor.HostSupports() {\n\t\tvar appArmorProfile string\n\t\tif c.AppArmorProfile != \"\" {\n\t\t\tappArmorProfile = c.AppArmorProfile\n\t\t} else if c.HostConfig.Privileged {\n\t\t\t// `docker exec --privileged` does not currently disable AppArmor\n\t\t\t// profiles. Privileged configuration of the container is inherited\n\t\t\tappArmorProfile = unconfinedAppArmorProfile\n\t\t} else {\n\t\t\tappArmorProfile = defaultAppArmorProfile\n\t\t}\n\n\t\tif appArmorProfile == defaultAppArmorProfile {\n\t\t\t// Unattended upgrades and other fun services can unload AppArmor\n\t\t\t// profiles inadvertently. Since we cannot store our profile in\n\t\t\t// /etc/apparmor.d, nor can we practically add other ways of\n\t\t\t// telling the system to keep our profile loaded, in order to make\n\t\t\t// sure that we keep the default profile enabled we dynamically\n\t\t\t// reload it if necessary.\n\t\t\tif err := ensureDefaultAppArmorProfile(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tp.ApparmorProfile = appArmorProfile\n\t}\n\ts := &specs.Spec{Process: p}\n\treturn WithRlimits(daemon, c)(context.Background(), nil, nil, s)\n}\n", "package oci // import \"github.com/docker/docker/oci\"\n\nimport (\n\t\"os\"\n\t\"runtime\"\n\n\t\"github.com/docker/docker/oci/caps\"\n\tspecs \"github.com/opencontainers/runtime-spec/specs-go\"\n)\n\nfunc iPtr(i int64) *int64        { return &i }\nfunc u32Ptr(i int64) *uint32     { u := uint32(i); return &u }\nfunc fmPtr(i int64) *os.FileMode { fm := os.FileMode(i); return &fm }\n\n// DefaultSpec returns the default spec used by docker for the current Platform\nfunc DefaultSpec() specs.Spec {\n\tif runtime.GOOS == \"windows\" {\n\t\treturn DefaultWindowsSpec()\n\t}\n\treturn DefaultLinuxSpec()\n}\n\n// DefaultWindowsSpec create a default spec for running Windows containers\nfunc DefaultWindowsSpec() specs.Spec {\n\treturn specs.Spec{\n\t\tVersion: specs.Version,\n\t\tWindows: &specs.Windows{},\n\t\tProcess: &specs.Process{},\n\t\tRoot:    &specs.Root{},\n\t}\n}\n\n// DefaultLinuxSpec create a default spec for running Linux containers\nfunc DefaultLinuxSpec() specs.Spec {\n\treturn specs.Spec{\n\t\tVersion: specs.Version,\n\t\tProcess: &specs.Process{\n\t\t\tCapabilities: &specs.LinuxCapabilities{\n\t\t\t\tBounding:    caps.DefaultCapabilities(),\n\t\t\t\tPermitted:   caps.DefaultCapabilities(),\n\t\t\t\tInheritable: caps.DefaultCapabilities(),\n\t\t\t\tEffective:   caps.DefaultCapabilities(),\n\t\t\t},\n\t\t},\n\t\tRoot: &specs.Root{},\n\t\tMounts: []specs.Mount{\n\t\t\t{\n\t\t\t\tDestination: \"/proc\",\n\t\t\t\tType:        \"proc\",\n\t\t\t\tSource:      \"proc\",\n\t\t\t\tOptions:     []string{\"nosuid\", \"noexec\", \"nodev\"},\n\t\t\t},\n\t\t\t{\n\t\t\t\tDestination: \"/dev\",\n\t\t\t\tType:        \"tmpfs\",\n\t\t\t\tSource:      \"tmpfs\",\n\t\t\t\tOptions:     []string{\"nosuid\", \"strictatime\", \"mode=755\", \"size=65536k\"},\n\t\t\t},\n\t\t\t{\n\t\t\t\tDestination: \"/dev/pts\",\n\t\t\t\tType:        \"devpts\",\n\t\t\t\tSource:      \"devpts\",\n\t\t\t\tOptions:     []string{\"nosuid\", \"noexec\", \"newinstance\", \"ptmxmode=0666\", \"mode=0620\", \"gid=5\"},\n\t\t\t},\n\t\t\t{\n\t\t\t\tDestination: \"/sys\",\n\t\t\t\tType:        \"sysfs\",\n\t\t\t\tSource:      \"sysfs\",\n\t\t\t\tOptions:     []string{\"nosuid\", \"noexec\", \"nodev\", \"ro\"},\n\t\t\t},\n\t\t\t{\n\t\t\t\tDestination: \"/sys/fs/cgroup\",\n\t\t\t\tType:        \"cgroup\",\n\t\t\t\tSource:      \"cgroup\",\n\t\t\t\tOptions:     []string{\"ro\", \"nosuid\", \"noexec\", \"nodev\"},\n\t\t\t},\n\t\t\t{\n\t\t\t\tDestination: \"/dev/mqueue\",\n\t\t\t\tType:        \"mqueue\",\n\t\t\t\tSource:      \"mqueue\",\n\t\t\t\tOptions:     []string{\"nosuid\", \"noexec\", \"nodev\"},\n\t\t\t},\n\t\t\t{\n\t\t\t\tDestination: \"/dev/shm\",\n\t\t\t\tType:        \"tmpfs\",\n\t\t\t\tSource:      \"shm\",\n\t\t\t\tOptions:     []string{\"nosuid\", \"noexec\", \"nodev\", \"mode=1777\"},\n\t\t\t},\n\t\t},\n\t\tLinux: &specs.Linux{\n\t\t\tMaskedPaths: []string{\n\t\t\t\t\"/proc/asound\",\n\t\t\t\t\"/proc/acpi\",\n\t\t\t\t\"/proc/kcore\",\n\t\t\t\t\"/proc/keys\",\n\t\t\t\t\"/proc/latency_stats\",\n\t\t\t\t\"/proc/timer_list\",\n\t\t\t\t\"/proc/timer_stats\",\n\t\t\t\t\"/proc/sched_debug\",\n\t\t\t\t\"/proc/scsi\",\n\t\t\t\t\"/sys/firmware\",\n\t\t\t},\n\t\t\tReadonlyPaths: []string{\n\t\t\t\t\"/proc/bus\",\n\t\t\t\t\"/proc/fs\",\n\t\t\t\t\"/proc/irq\",\n\t\t\t\t\"/proc/sys\",\n\t\t\t\t\"/proc/sysrq-trigger\",\n\t\t\t},\n\t\t\tNamespaces: []specs.LinuxNamespace{\n\t\t\t\t{Type: \"mount\"},\n\t\t\t\t{Type: \"network\"},\n\t\t\t\t{Type: \"uts\"},\n\t\t\t\t{Type: \"pid\"},\n\t\t\t\t{Type: \"ipc\"},\n\t\t\t},\n\t\t\t// Devices implicitly contains the following devices:\n\t\t\t// null, zero, full, random, urandom, tty, console, and ptmx.\n\t\t\t// ptmx is a bind mount or symlink of the container's ptmx.\n\t\t\t// See also: https://github.com/opencontainers/runtime-spec/blob/master/config-linux.md#default-devices\n\t\t\tDevices: []specs.LinuxDevice{},\n\t\t\tResources: &specs.LinuxResources{\n\t\t\t\tDevices: []specs.LinuxDeviceCgroup{\n\t\t\t\t\t{\n\t\t\t\t\t\tAllow:  false,\n\t\t\t\t\t\tAccess: \"rwm\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tAllow:  true,\n\t\t\t\t\t\tType:   \"c\",\n\t\t\t\t\t\tMajor:  iPtr(1),\n\t\t\t\t\t\tMinor:  iPtr(5),\n\t\t\t\t\t\tAccess: \"rwm\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tAllow:  true,\n\t\t\t\t\t\tType:   \"c\",\n\t\t\t\t\t\tMajor:  iPtr(1),\n\t\t\t\t\t\tMinor:  iPtr(3),\n\t\t\t\t\t\tAccess: \"rwm\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tAllow:  true,\n\t\t\t\t\t\tType:   \"c\",\n\t\t\t\t\t\tMajor:  iPtr(1),\n\t\t\t\t\t\tMinor:  iPtr(9),\n\t\t\t\t\t\tAccess: \"rwm\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tAllow:  true,\n\t\t\t\t\t\tType:   \"c\",\n\t\t\t\t\t\tMajor:  iPtr(1),\n\t\t\t\t\t\tMinor:  iPtr(8),\n\t\t\t\t\t\tAccess: \"rwm\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tAllow:  true,\n\t\t\t\t\t\tType:   \"c\",\n\t\t\t\t\t\tMajor:  iPtr(5),\n\t\t\t\t\t\tMinor:  iPtr(0),\n\t\t\t\t\t\tAccess: \"rwm\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tAllow:  true,\n\t\t\t\t\t\tType:   \"c\",\n\t\t\t\t\t\tMajor:  iPtr(5),\n\t\t\t\t\t\tMinor:  iPtr(1),\n\t\t\t\t\t\tAccess: \"rwm\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tAllow:  false,\n\t\t\t\t\t\tType:   \"c\",\n\t\t\t\t\t\tMajor:  iPtr(10),\n\t\t\t\t\t\tMinor:  iPtr(229),\n\t\t\t\t\t\tAccess: \"rwm\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n}\n", "package oci // import \"github.com/docker/docker/oci\"\n\nimport (\n\t\"fmt\"\n\t\"regexp\"\n\t\"strconv\"\n\n\tspecs \"github.com/opencontainers/runtime-spec/specs-go\"\n)\n\n// TODO verify if this regex is correct for \"a\" (all); the docs (https://github.com/torvalds/linux/blob/v5.10/Documentation/admin-guide/cgroup-v1/devices.rst) describe:\n//      \"'all' means it applies to all types and all major and minor numbers\", and shows an example\n//      that *only* passes `a` as value: `echo a > /sys/fs/cgroup/1/devices.allow, which would be\n//      the \"implicit\" equivalent of \"a *:* rwm\". Source-code also looks to confirm this, and returns\n//      early for \"a\" (all); https://github.com/torvalds/linux/blob/v5.10/security/device_cgroup.c#L614-L642\n//nolint: gosimple\nvar deviceCgroupRuleRegex = regexp.MustCompile(\"^([acb]) ([0-9]+|\\\\*):([0-9]+|\\\\*) ([rwm]{1,3})$\")\n\n// SetCapabilities sets the provided capabilities on the spec\n// All capabilities are added if privileged is true\nfunc SetCapabilities(s *specs.Spec, caplist []string) error {\n\ts.Process.Capabilities.Effective = caplist\n\ts.Process.Capabilities.Bounding = caplist\n\ts.Process.Capabilities.Permitted = caplist\n\ts.Process.Capabilities.Inheritable = caplist\n\t// setUser has already been executed here\n\t// if non root drop capabilities in the way execve does\n\tif s.Process.User.UID != 0 {\n\t\ts.Process.Capabilities.Effective = []string{}\n\t\ts.Process.Capabilities.Permitted = []string{}\n\t}\n\treturn nil\n}\n\n// AppendDevicePermissionsFromCgroupRules takes rules for the devices cgroup to append to the default set\nfunc AppendDevicePermissionsFromCgroupRules(devPermissions []specs.LinuxDeviceCgroup, rules []string) ([]specs.LinuxDeviceCgroup, error) {\n\tfor _, deviceCgroupRule := range rules {\n\t\tss := deviceCgroupRuleRegex.FindAllStringSubmatch(deviceCgroupRule, -1)\n\t\tif len(ss) == 0 || len(ss[0]) != 5 {\n\t\t\treturn nil, fmt.Errorf(\"invalid device cgroup rule format: '%s'\", deviceCgroupRule)\n\t\t}\n\t\tmatches := ss[0]\n\n\t\tdPermissions := specs.LinuxDeviceCgroup{\n\t\t\tAllow:  true,\n\t\t\tType:   matches[1],\n\t\t\tAccess: matches[4],\n\t\t}\n\t\tif matches[2] == \"*\" {\n\t\t\tmajor := int64(-1)\n\t\t\tdPermissions.Major = &major\n\t\t} else {\n\t\t\tmajor, err := strconv.ParseInt(matches[2], 10, 64)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"invalid major value in device cgroup rule format: '%s'\", deviceCgroupRule)\n\t\t\t}\n\t\t\tdPermissions.Major = &major\n\t\t}\n\t\tif matches[3] == \"*\" {\n\t\t\tminor := int64(-1)\n\t\t\tdPermissions.Minor = &minor\n\t\t} else {\n\t\t\tminor, err := strconv.ParseInt(matches[3], 10, 64)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"invalid minor value in device cgroup rule format: '%s'\", deviceCgroupRule)\n\t\t\t}\n\t\t\tdPermissions.Minor = &minor\n\t\t}\n\t\tdevPermissions = append(devPermissions, dPermissions)\n\t}\n\treturn devPermissions, nil\n}\n"], "fixing_code": ["package daemon // import \"github.com/docker/docker/daemon\"\n\nimport (\n\t\"context\"\n\n\t\"github.com/containerd/containerd/pkg/apparmor\"\n\t\"github.com/docker/docker/container\"\n\t\"github.com/docker/docker/daemon/exec\"\n\t\"github.com/docker/docker/oci/caps\"\n\tspecs \"github.com/opencontainers/runtime-spec/specs-go\"\n)\n\nfunc (daemon *Daemon) execSetPlatformOpt(c *container.Container, ec *exec.Config, p *specs.Process) error {\n\tif len(ec.User) > 0 {\n\t\tvar err error\n\t\tp.User, err = getUser(c, ec.User)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif ec.Privileged {\n\t\tp.Capabilities = &specs.LinuxCapabilities{\n\t\t\tBounding:  caps.GetAllCapabilities(),\n\t\t\tPermitted: caps.GetAllCapabilities(),\n\t\t\tEffective: caps.GetAllCapabilities(),\n\t\t}\n\t}\n\tif apparmor.HostSupports() {\n\t\tvar appArmorProfile string\n\t\tif c.AppArmorProfile != \"\" {\n\t\t\tappArmorProfile = c.AppArmorProfile\n\t\t} else if c.HostConfig.Privileged {\n\t\t\t// `docker exec --privileged` does not currently disable AppArmor\n\t\t\t// profiles. Privileged configuration of the container is inherited\n\t\t\tappArmorProfile = unconfinedAppArmorProfile\n\t\t} else {\n\t\t\tappArmorProfile = defaultAppArmorProfile\n\t\t}\n\n\t\tif appArmorProfile == defaultAppArmorProfile {\n\t\t\t// Unattended upgrades and other fun services can unload AppArmor\n\t\t\t// profiles inadvertently. Since we cannot store our profile in\n\t\t\t// /etc/apparmor.d, nor can we practically add other ways of\n\t\t\t// telling the system to keep our profile loaded, in order to make\n\t\t\t// sure that we keep the default profile enabled we dynamically\n\t\t\t// reload it if necessary.\n\t\t\tif err := ensureDefaultAppArmorProfile(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tp.ApparmorProfile = appArmorProfile\n\t}\n\ts := &specs.Spec{Process: p}\n\treturn WithRlimits(daemon, c)(context.Background(), nil, nil, s)\n}\n", "package oci // import \"github.com/docker/docker/oci\"\n\nimport (\n\t\"os\"\n\t\"runtime\"\n\n\t\"github.com/docker/docker/oci/caps\"\n\tspecs \"github.com/opencontainers/runtime-spec/specs-go\"\n)\n\nfunc iPtr(i int64) *int64        { return &i }\nfunc u32Ptr(i int64) *uint32     { u := uint32(i); return &u }\nfunc fmPtr(i int64) *os.FileMode { fm := os.FileMode(i); return &fm }\n\n// DefaultSpec returns the default spec used by docker for the current Platform\nfunc DefaultSpec() specs.Spec {\n\tif runtime.GOOS == \"windows\" {\n\t\treturn DefaultWindowsSpec()\n\t}\n\treturn DefaultLinuxSpec()\n}\n\n// DefaultWindowsSpec create a default spec for running Windows containers\nfunc DefaultWindowsSpec() specs.Spec {\n\treturn specs.Spec{\n\t\tVersion: specs.Version,\n\t\tWindows: &specs.Windows{},\n\t\tProcess: &specs.Process{},\n\t\tRoot:    &specs.Root{},\n\t}\n}\n\n// DefaultLinuxSpec create a default spec for running Linux containers\nfunc DefaultLinuxSpec() specs.Spec {\n\treturn specs.Spec{\n\t\tVersion: specs.Version,\n\t\tProcess: &specs.Process{\n\t\t\tCapabilities: &specs.LinuxCapabilities{\n\t\t\t\tBounding:  caps.DefaultCapabilities(),\n\t\t\t\tPermitted: caps.DefaultCapabilities(),\n\t\t\t\tEffective: caps.DefaultCapabilities(),\n\t\t\t},\n\t\t},\n\t\tRoot: &specs.Root{},\n\t\tMounts: []specs.Mount{\n\t\t\t{\n\t\t\t\tDestination: \"/proc\",\n\t\t\t\tType:        \"proc\",\n\t\t\t\tSource:      \"proc\",\n\t\t\t\tOptions:     []string{\"nosuid\", \"noexec\", \"nodev\"},\n\t\t\t},\n\t\t\t{\n\t\t\t\tDestination: \"/dev\",\n\t\t\t\tType:        \"tmpfs\",\n\t\t\t\tSource:      \"tmpfs\",\n\t\t\t\tOptions:     []string{\"nosuid\", \"strictatime\", \"mode=755\", \"size=65536k\"},\n\t\t\t},\n\t\t\t{\n\t\t\t\tDestination: \"/dev/pts\",\n\t\t\t\tType:        \"devpts\",\n\t\t\t\tSource:      \"devpts\",\n\t\t\t\tOptions:     []string{\"nosuid\", \"noexec\", \"newinstance\", \"ptmxmode=0666\", \"mode=0620\", \"gid=5\"},\n\t\t\t},\n\t\t\t{\n\t\t\t\tDestination: \"/sys\",\n\t\t\t\tType:        \"sysfs\",\n\t\t\t\tSource:      \"sysfs\",\n\t\t\t\tOptions:     []string{\"nosuid\", \"noexec\", \"nodev\", \"ro\"},\n\t\t\t},\n\t\t\t{\n\t\t\t\tDestination: \"/sys/fs/cgroup\",\n\t\t\t\tType:        \"cgroup\",\n\t\t\t\tSource:      \"cgroup\",\n\t\t\t\tOptions:     []string{\"ro\", \"nosuid\", \"noexec\", \"nodev\"},\n\t\t\t},\n\t\t\t{\n\t\t\t\tDestination: \"/dev/mqueue\",\n\t\t\t\tType:        \"mqueue\",\n\t\t\t\tSource:      \"mqueue\",\n\t\t\t\tOptions:     []string{\"nosuid\", \"noexec\", \"nodev\"},\n\t\t\t},\n\t\t\t{\n\t\t\t\tDestination: \"/dev/shm\",\n\t\t\t\tType:        \"tmpfs\",\n\t\t\t\tSource:      \"shm\",\n\t\t\t\tOptions:     []string{\"nosuid\", \"noexec\", \"nodev\", \"mode=1777\"},\n\t\t\t},\n\t\t},\n\t\tLinux: &specs.Linux{\n\t\t\tMaskedPaths: []string{\n\t\t\t\t\"/proc/asound\",\n\t\t\t\t\"/proc/acpi\",\n\t\t\t\t\"/proc/kcore\",\n\t\t\t\t\"/proc/keys\",\n\t\t\t\t\"/proc/latency_stats\",\n\t\t\t\t\"/proc/timer_list\",\n\t\t\t\t\"/proc/timer_stats\",\n\t\t\t\t\"/proc/sched_debug\",\n\t\t\t\t\"/proc/scsi\",\n\t\t\t\t\"/sys/firmware\",\n\t\t\t},\n\t\t\tReadonlyPaths: []string{\n\t\t\t\t\"/proc/bus\",\n\t\t\t\t\"/proc/fs\",\n\t\t\t\t\"/proc/irq\",\n\t\t\t\t\"/proc/sys\",\n\t\t\t\t\"/proc/sysrq-trigger\",\n\t\t\t},\n\t\t\tNamespaces: []specs.LinuxNamespace{\n\t\t\t\t{Type: \"mount\"},\n\t\t\t\t{Type: \"network\"},\n\t\t\t\t{Type: \"uts\"},\n\t\t\t\t{Type: \"pid\"},\n\t\t\t\t{Type: \"ipc\"},\n\t\t\t},\n\t\t\t// Devices implicitly contains the following devices:\n\t\t\t// null, zero, full, random, urandom, tty, console, and ptmx.\n\t\t\t// ptmx is a bind mount or symlink of the container's ptmx.\n\t\t\t// See also: https://github.com/opencontainers/runtime-spec/blob/master/config-linux.md#default-devices\n\t\t\tDevices: []specs.LinuxDevice{},\n\t\t\tResources: &specs.LinuxResources{\n\t\t\t\tDevices: []specs.LinuxDeviceCgroup{\n\t\t\t\t\t{\n\t\t\t\t\t\tAllow:  false,\n\t\t\t\t\t\tAccess: \"rwm\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tAllow:  true,\n\t\t\t\t\t\tType:   \"c\",\n\t\t\t\t\t\tMajor:  iPtr(1),\n\t\t\t\t\t\tMinor:  iPtr(5),\n\t\t\t\t\t\tAccess: \"rwm\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tAllow:  true,\n\t\t\t\t\t\tType:   \"c\",\n\t\t\t\t\t\tMajor:  iPtr(1),\n\t\t\t\t\t\tMinor:  iPtr(3),\n\t\t\t\t\t\tAccess: \"rwm\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tAllow:  true,\n\t\t\t\t\t\tType:   \"c\",\n\t\t\t\t\t\tMajor:  iPtr(1),\n\t\t\t\t\t\tMinor:  iPtr(9),\n\t\t\t\t\t\tAccess: \"rwm\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tAllow:  true,\n\t\t\t\t\t\tType:   \"c\",\n\t\t\t\t\t\tMajor:  iPtr(1),\n\t\t\t\t\t\tMinor:  iPtr(8),\n\t\t\t\t\t\tAccess: \"rwm\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tAllow:  true,\n\t\t\t\t\t\tType:   \"c\",\n\t\t\t\t\t\tMajor:  iPtr(5),\n\t\t\t\t\t\tMinor:  iPtr(0),\n\t\t\t\t\t\tAccess: \"rwm\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tAllow:  true,\n\t\t\t\t\t\tType:   \"c\",\n\t\t\t\t\t\tMajor:  iPtr(5),\n\t\t\t\t\t\tMinor:  iPtr(1),\n\t\t\t\t\t\tAccess: \"rwm\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tAllow:  false,\n\t\t\t\t\t\tType:   \"c\",\n\t\t\t\t\t\tMajor:  iPtr(10),\n\t\t\t\t\t\tMinor:  iPtr(229),\n\t\t\t\t\t\tAccess: \"rwm\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n}\n", "package oci // import \"github.com/docker/docker/oci\"\n\nimport (\n\t\"fmt\"\n\t\"regexp\"\n\t\"strconv\"\n\n\tspecs \"github.com/opencontainers/runtime-spec/specs-go\"\n)\n\n// TODO verify if this regex is correct for \"a\" (all); the docs (https://github.com/torvalds/linux/blob/v5.10/Documentation/admin-guide/cgroup-v1/devices.rst) describe:\n//      \"'all' means it applies to all types and all major and minor numbers\", and shows an example\n//      that *only* passes `a` as value: `echo a > /sys/fs/cgroup/1/devices.allow, which would be\n//      the \"implicit\" equivalent of \"a *:* rwm\". Source-code also looks to confirm this, and returns\n//      early for \"a\" (all); https://github.com/torvalds/linux/blob/v5.10/security/device_cgroup.c#L614-L642\n//nolint: gosimple\nvar deviceCgroupRuleRegex = regexp.MustCompile(\"^([acb]) ([0-9]+|\\\\*):([0-9]+|\\\\*) ([rwm]{1,3})$\")\n\n// SetCapabilities sets the provided capabilities on the spec\n// All capabilities are added if privileged is true.\nfunc SetCapabilities(s *specs.Spec, caplist []string) error {\n\t// setUser has already been executed here\n\tif s.Process.User.UID == 0 {\n\t\ts.Process.Capabilities = &specs.LinuxCapabilities{\n\t\t\tEffective: caplist,\n\t\t\tBounding:  caplist,\n\t\t\tPermitted: caplist,\n\t\t}\n\t} else {\n\t\t// Do not set Effective and Permitted capabilities for non-root users,\n\t\t// to match what execve does.\n\t\ts.Process.Capabilities = &specs.LinuxCapabilities{\n\t\t\tBounding: caplist,\n\t\t}\n\t}\n\treturn nil\n}\n\n// AppendDevicePermissionsFromCgroupRules takes rules for the devices cgroup to append to the default set\nfunc AppendDevicePermissionsFromCgroupRules(devPermissions []specs.LinuxDeviceCgroup, rules []string) ([]specs.LinuxDeviceCgroup, error) {\n\tfor _, deviceCgroupRule := range rules {\n\t\tss := deviceCgroupRuleRegex.FindAllStringSubmatch(deviceCgroupRule, -1)\n\t\tif len(ss) == 0 || len(ss[0]) != 5 {\n\t\t\treturn nil, fmt.Errorf(\"invalid device cgroup rule format: '%s'\", deviceCgroupRule)\n\t\t}\n\t\tmatches := ss[0]\n\n\t\tdPermissions := specs.LinuxDeviceCgroup{\n\t\t\tAllow:  true,\n\t\t\tType:   matches[1],\n\t\t\tAccess: matches[4],\n\t\t}\n\t\tif matches[2] == \"*\" {\n\t\t\tmajor := int64(-1)\n\t\t\tdPermissions.Major = &major\n\t\t} else {\n\t\t\tmajor, err := strconv.ParseInt(matches[2], 10, 64)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"invalid major value in device cgroup rule format: '%s'\", deviceCgroupRule)\n\t\t\t}\n\t\t\tdPermissions.Major = &major\n\t\t}\n\t\tif matches[3] == \"*\" {\n\t\t\tminor := int64(-1)\n\t\t\tdPermissions.Minor = &minor\n\t\t} else {\n\t\t\tminor, err := strconv.ParseInt(matches[3], 10, 64)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"invalid minor value in device cgroup rule format: '%s'\", deviceCgroupRule)\n\t\t\t}\n\t\t\tdPermissions.Minor = &minor\n\t\t}\n\t\tdevPermissions = append(devPermissions, dPermissions)\n\t}\n\treturn devPermissions, nil\n}\n"], "filenames": ["daemon/exec_linux.go", "oci/defaults.go", "oci/oci.go"], "buggy_code_start_loc": [22, 39, 20], "buggy_code_end_loc": [29, 43, 31], "fixing_code_start_loc": [22, 39, 20], "fixing_code_end_loc": [26, 42, 35], "type": "CWE-732", "message": "Moby is an open-source project created by Docker to enable and accelerate software containerization. A bug was found in Moby (Docker Engine) prior to version 20.10.14 where containers were incorrectly started with non-empty inheritable Linux process capabilities, creating an atypical Linux environment and enabling programs with inheritable file capabilities to elevate those capabilities to the permitted set during `execve(2)`. Normally, when executable programs have specified permitted file capabilities, otherwise unprivileged users and processes can execute those programs and gain the specified file capabilities up to the bounding set. Due to this bug, containers which included executable programs with inheritable file capabilities allowed otherwise unprivileged users and processes to additionally gain these inheritable file capabilities up to the container's bounding set. Containers which use Linux users and groups to perform privilege separation inside the container are most directly impacted. This bug did not affect the container security sandbox as the inheritable set never contained more capabilities than were included in the container's bounding set. This bug has been fixed in Moby (Docker Engine) 20.10.14. Running containers should be stopped, deleted, and recreated for the inheritable capabilities to be reset. This fix changes Moby (Docker Engine) behavior such that containers are started with a more typical Linux environment. As a workaround, the entry point of a container can be modified to use a utility like `capsh(1)` to drop inheritable capabilities prior to the primary process starting.", "other": {"cve": {"id": "CVE-2022-24769", "sourceIdentifier": "security-advisories@github.com", "published": "2022-03-24T20:15:09.493", "lastModified": "2023-02-10T17:27:09.170", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Moby is an open-source project created by Docker to enable and accelerate software containerization. A bug was found in Moby (Docker Engine) prior to version 20.10.14 where containers were incorrectly started with non-empty inheritable Linux process capabilities, creating an atypical Linux environment and enabling programs with inheritable file capabilities to elevate those capabilities to the permitted set during `execve(2)`. Normally, when executable programs have specified permitted file capabilities, otherwise unprivileged users and processes can execute those programs and gain the specified file capabilities up to the bounding set. Due to this bug, containers which included executable programs with inheritable file capabilities allowed otherwise unprivileged users and processes to additionally gain these inheritable file capabilities up to the container's bounding set. Containers which use Linux users and groups to perform privilege separation inside the container are most directly impacted. This bug did not affect the container security sandbox as the inheritable set never contained more capabilities than were included in the container's bounding set. This bug has been fixed in Moby (Docker Engine) 20.10.14. Running containers should be stopped, deleted, and recreated for the inheritable capabilities to be reset. This fix changes Moby (Docker Engine) behavior such that containers are started with a more typical Linux environment. As a workaround, the entry point of a container can be modified to use a utility like `capsh(1)` to drop inheritable capabilities prior to the primary process starting."}, {"lang": "es", "value": "Moby es un proyecto de c\u00f3digo abierto creado por Docker para permitir y acelerar la contenci\u00f3n de software. Fue encontrado un bug en Moby (Docker Engine) versiones anteriores a 20.10.14, en el que los contenedores eran iniciados incorrectamente con capacidades de proceso Linux heredables no vac\u00edas, creando un entorno Linux at\u00edpico y permitiendo que los programas con capacidades de archivo heredables elevaran esas capacidades al conjunto permitido durante \"execve(2)\". Normalmente, cuando los programas ejecutables presentan capacidades de archivo permitidas especificadas, los usuarios y procesos no privilegiados pueden ejecutar esos programas y conseguir las capacidades de archivo especificadas hasta el conjunto permitido. Debido a este bug, los contenedores que inclu\u00edan programas ejecutables con capacidades de archivo heredables permit\u00edan que usuarios y procesos no privilegiados consiguieran adicionalmente estas capacidades de archivo heredables hasta el conjunto de l\u00edmites del contenedor. Los contenedores que usan usuarios y grupos de Linux para llevar a cabo la separaci\u00f3n de privilegios dentro del contenedor son los m\u00e1s directamente afectados. Este bug no afectaba a la caja de arena de seguridad del contenedor, ya que el conjunto heredable nunca conten\u00eda m\u00e1s capacidades que las incluidas en el conjunto delimitador del contenedor. Este bug ha sido corregido en Moby (Docker Engine) versi\u00f3n 20.10.14. Los contenedores en ejecuci\u00f3n deben detenerse, eliminarse y volver a crearse para que sean restablecidas las capacidades heredables. Esta correcci\u00f3n cambia el comportamiento de Moby (Docker Engine) para que los contenedores se inicien con un entorno Linux m\u00e1s t\u00edpico. Como medida de mitigaci\u00f3n, el punto de entrada de un contenedor puede modificarse para usar una utilidad como \"capsh(1)\" para eliminar las capacidades heredables antes de que sea iniciado el proceso primario"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.5, "impactScore": 3.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.5, "impactScore": 3.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-732"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-732"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mobyproject:moby:*:*:*:*:*:*:*:*", "versionEndExcluding": "20.10.14", "matchCriteriaId": "251599F9-5922-4381-8D28-A663B2CEA315"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:o:linux:linux_kernel:-:*:*:*:*:*:*:*", "matchCriteriaId": "703AF700-7A70-47E2-BC3A-7FD03B3CA9C1"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:runc:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.1.2", "matchCriteriaId": "1266D0BA-8DDB-43DF-A1A0-D5CE23BE27C1"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA6FEEC2-9F11-4643-8827-749718254FED"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2022/05/12/1", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/moby/moby/commit/2bbc786e4c59761d722d2d1518cd0a32829bc07f", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/moby/moby/releases/tag/v20.10.14", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/moby/moby/security/advisories/GHSA-2mm7-x5h6-5pvq", "source": "security-advisories@github.com", "tags": ["Mitigation", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/6PMQKCAPK2AR3DCYITJYMMNBEGQBGLCC/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/A5AFKOQ5CE3CEIULWW4FLQKHFFU6FSYG/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/A5FQJ3MLFSEKQYCFPFZIKYGBXPZUJFVY/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/FPOJUJZXGMIVKRS4QR75F6OIXNQ6LDBL/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/HIMAHZ6AUIKN7AX26KHZYBXVECIOVWBH/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/HQCVS7WBFSTKJFNX5PGDRARMTOFWV2O7/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5162", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/moby/moby/commit/2bbc786e4c59761d722d2d1518cd0a32829bc07f"}}