{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * cmdhist.c: Functions for the history of the command-line.\n */\n\n#include \"vim.h\"\n\nstatic histentry_T *(history[HIST_COUNT]) = {NULL, NULL, NULL, NULL, NULL};\nstatic int\thisidx[HIST_COUNT] = {-1, -1, -1, -1, -1};  // lastused entry\nstatic int\thisnum[HIST_COUNT] = {0, 0, 0, 0, 0};\n\t\t    // identifying (unique) number of newest history entry\nstatic int\thislen = 0;\t\t// actual length of history tables\n\n/*\n * Return the length of the history tables\n */\n    int\nget_hislen(void)\n{\n    return hislen;\n}\n\n/*\n * Return a pointer to a specified history table\n */\n    histentry_T *\nget_histentry(int hist_type)\n{\n    return history[hist_type];\n}\n\n#if defined(FEAT_VIMINFO) || defined(PROTO)\n    void\nset_histentry(int hist_type, histentry_T *entry)\n{\n    history[hist_type] = entry;\n}\n#endif\n\n    int *\nget_hisidx(int hist_type)\n{\n    return &hisidx[hist_type];\n}\n\n#if defined(FEAT_VIMINFO) || defined(PROTO)\n    int *\nget_hisnum(int hist_type)\n{\n    return &hisnum[hist_type];\n}\n#endif\n\n/*\n * Translate a history character to the associated type number.\n */\n    int\nhist_char2type(int c)\n{\n    if (c == ':')\n\treturn HIST_CMD;\n    if (c == '=')\n\treturn HIST_EXPR;\n    if (c == '@')\n\treturn HIST_INPUT;\n    if (c == '>')\n\treturn HIST_DEBUG;\n    return HIST_SEARCH;\t    // must be '?' or '/'\n}\n\n/*\n * Table of history names.\n * These names are used in :history and various hist...() functions.\n * It is sufficient to give the significant prefix of a history name.\n */\n\nstatic char *(history_names[]) =\n{\n    \"cmd\",\n    \"search\",\n    \"expr\",\n    \"input\",\n    \"debug\",\n    NULL\n};\n\n/*\n * Function given to ExpandGeneric() to obtain the possible first\n * arguments of the \":history command.\n */\n    char_u *\nget_history_arg(expand_T *xp UNUSED, int idx)\n{\n    char    *short_names = \":=@>?/\";\n    int\t    short_names_count = (int)STRLEN(short_names);\n    int\t    history_name_count = ARRAY_LENGTH(history_names) - 1;\n\n    if (idx < short_names_count)\n    {\n\txp->xp_buf[0] = (char_u)short_names[idx];\n\txp->xp_buf[1] = NUL;\n\treturn xp->xp_buf;\n    }\n    if (idx < short_names_count + history_name_count)\n\treturn (char_u *)history_names[idx - short_names_count];\n    if (idx == short_names_count + history_name_count)\n\treturn (char_u *)\"all\";\n    return NULL;\n}\n\n/*\n * init_history() - Initialize the command line history.\n * Also used to re-allocate the history when the size changes.\n */\n    void\ninit_history(void)\n{\n    int\t\tnewlen;\t    // new length of history table\n    histentry_T\t*temp;\n    int\t\ti;\n    int\t\tj;\n    int\t\ttype;\n\n    // If size of history table changed, reallocate it\n    newlen = (int)p_hi;\n    if (newlen == hislen)\t\t// history length didn't change\n\treturn;\n\n    // history length changed\n    for (type = 0; type < HIST_COUNT; ++type)   // adjust the tables\n    {\n\tif (newlen > 0)\n\t{\n\t    temp = ALLOC_MULT(histentry_T, newlen);\n\t    if (temp == NULL)   // out of memory!\n\t    {\n\t\tif (type == 0)  // first one: just keep the old length\n\t\t{\n\t\t    newlen = hislen;\n\t\t    break;\n\t\t}\n\t\t// Already changed one table, now we can only have zero\n\t\t// length for all tables.\n\t\tnewlen = 0;\n\t\ttype = -1;\n\t\tcontinue;\n\t    }\n\t}\n\telse\n\t    temp = NULL;\n\n\tif (hisidx[type] < 0)\t\t// there are no entries yet\n\t{\n\t    for (i = 0; i < newlen; ++i)\n\t\tclear_hist_entry(&temp[i]);\n\t}\n\telse if (newlen > hislen)\t// array becomes bigger\n\t{\n\t    for (i = 0; i <= hisidx[type]; ++i)\n\t\ttemp[i] = history[type][i];\n\t    j = i;\n\t    for ( ; i <= newlen - (hislen - hisidx[type]); ++i)\n\t\tclear_hist_entry(&temp[i]);\n\t    for ( ; j < hislen; ++i, ++j)\n\t\ttemp[i] = history[type][j];\n\t}\n\telse\t\t\t\t// array becomes smaller or 0\n\t{\n\t    j = hisidx[type];\n\t    for (i = newlen - 1; ; --i)\n\t    {\n\t\tif (i >= 0)\t\t// copy newest entries\n\t\t    temp[i] = history[type][j];\n\t\telse\t\t\t// remove older entries\n\t\t    vim_free(history[type][j].hisstr);\n\t\tif (--j < 0)\n\t\t    j = hislen - 1;\n\t\tif (j == hisidx[type])\n\t\t    break;\n\t    }\n\t    hisidx[type] = newlen - 1;\n\t}\n\tvim_free(history[type]);\n\thistory[type] = temp;\n    }\n    hislen = newlen;\n}\n\n    void\nclear_hist_entry(histentry_T *hisptr)\n{\n    hisptr->hisnum = 0;\n    hisptr->viminfo = FALSE;\n    hisptr->hisstr = NULL;\n    hisptr->time_set = 0;\n}\n\n/*\n * Check if command line 'str' is already in history.\n * If 'move_to_front' is TRUE, matching entry is moved to end of history.\n */\n    int\nin_history(\n    int\t    type,\n    char_u  *str,\n    int\t    move_to_front,\t// Move the entry to the front if it exists\n    int\t    sep,\n    int\t    writing)\t\t// ignore entries read from viminfo\n{\n    int\t    i;\n    int\t    last_i = -1;\n    char_u  *p;\n\n    if (hisidx[type] < 0)\n\treturn FALSE;\n    i = hisidx[type];\n    do\n    {\n\tif (history[type][i].hisstr == NULL)\n\t    return FALSE;\n\n\t// For search history, check that the separator character matches as\n\t// well.\n\tp = history[type][i].hisstr;\n\tif (STRCMP(str, p) == 0\n\t\t&& !(writing && history[type][i].viminfo)\n\t\t&& (type != HIST_SEARCH || sep == p[STRLEN(p) + 1]))\n\t{\n\t    if (!move_to_front)\n\t\treturn TRUE;\n\t    last_i = i;\n\t    break;\n\t}\n\tif (--i < 0)\n\t    i = hislen - 1;\n    } while (i != hisidx[type]);\n\n    if (last_i < 0)\n\treturn FALSE;\n\n    str = history[type][i].hisstr;\n    while (i != hisidx[type])\n    {\n\tif (++i >= hislen)\n\t    i = 0;\n\thistory[type][last_i] = history[type][i];\n\tlast_i = i;\n    }\n    history[type][i].hisnum = ++hisnum[type];\n    history[type][i].viminfo = FALSE;\n    history[type][i].hisstr = str;\n    history[type][i].time_set = vim_time();\n    return TRUE;\n}\n\n/*\n * Convert history name (from table above) to its HIST_ equivalent.\n * When \"name\" is empty, return \"cmd\" history.\n * Returns -1 for unknown history name.\n */\n    static int\nget_histtype(char_u *name)\n{\n    int\t\ti;\n    int\t\tlen = (int)STRLEN(name);\n\n    // No argument: use current history.\n    if (len == 0)\n\treturn hist_char2type(get_cmdline_firstc());\n\n    for (i = 0; history_names[i] != NULL; ++i)\n\tif (STRNICMP(name, history_names[i], len) == 0)\n\t    return i;\n\n    if (vim_strchr((char_u *)\":=@>?/\", name[0]) != NULL && name[1] == NUL)\n\treturn hist_char2type(name[0]);\n\n    return -1;\n}\n\nstatic int\tlast_maptick = -1;\t// last seen maptick\n\n/*\n * Add the given string to the given history.  If the string is already in the\n * history then it is moved to the front.  \"histype\" may be one of he HIST_\n * values.\n */\n    void\nadd_to_history(\n    int\t\thistype,\n    char_u\t*new_entry,\n    int\t\tin_map,\t\t// consider maptick when inside a mapping\n    int\t\tsep)\t\t// separator character used (search hist)\n{\n    histentry_T\t*hisptr;\n    int\t\tlen;\n\n    if (hislen == 0)\t\t// no history\n\treturn;\n\n    if ((cmdmod.cmod_flags & CMOD_KEEPPATTERNS) && histype == HIST_SEARCH)\n\treturn;\n\n    // Searches inside the same mapping overwrite each other, so that only\n    // the last line is kept.  Be careful not to remove a line that was moved\n    // down, only lines that were added.\n    if (histype == HIST_SEARCH && in_map)\n    {\n\tif (maptick == last_maptick && hisidx[HIST_SEARCH] >= 0)\n\t{\n\t    // Current line is from the same mapping, remove it\n\t    hisptr = &history[HIST_SEARCH][hisidx[HIST_SEARCH]];\n\t    vim_free(hisptr->hisstr);\n\t    clear_hist_entry(hisptr);\n\t    --hisnum[histype];\n\t    if (--hisidx[HIST_SEARCH] < 0)\n\t\thisidx[HIST_SEARCH] = hislen - 1;\n\t}\n\tlast_maptick = -1;\n    }\n\n    if (in_history(histype, new_entry, TRUE, sep, FALSE))\n\treturn;\n\n    if (++hisidx[histype] == hislen)\n\thisidx[histype] = 0;\n    hisptr = &history[histype][hisidx[histype]];\n    vim_free(hisptr->hisstr);\n\n    // Store the separator after the NUL of the string.\n    len = (int)STRLEN(new_entry);\n    hisptr->hisstr = vim_strnsave(new_entry, len + 2);\n    if (hisptr->hisstr != NULL)\n\thisptr->hisstr[len + 1] = sep;\n\n    hisptr->hisnum = ++hisnum[histype];\n    hisptr->viminfo = FALSE;\n    hisptr->time_set = vim_time();\n    if (histype == HIST_SEARCH && in_map)\n\tlast_maptick = maptick;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n\n/*\n * Get identifier of newest history entry.\n * \"histype\" may be one of the HIST_ values.\n */\n    static int\nget_history_idx(int histype)\n{\n    if (hislen == 0 || histype < 0 || histype >= HIST_COUNT\n\t\t    || hisidx[histype] < 0)\n\treturn -1;\n\n    return history[histype][hisidx[histype]].hisnum;\n}\n\n/*\n * Calculate history index from a number:\n *   num > 0: seen as identifying number of a history entry\n *   num < 0: relative position in history wrt newest entry\n * \"histype\" may be one of the HIST_ values.\n */\n    static int\ncalc_hist_idx(int histype, int num)\n{\n    int\t\ti;\n    histentry_T\t*hist;\n    int\t\twrapped = FALSE;\n\n    if (hislen == 0 || histype < 0 || histype >= HIST_COUNT\n\t\t    || (i = hisidx[histype]) < 0 || num == 0)\n\treturn -1;\n\n    hist = history[histype];\n    if (num > 0)\n    {\n\twhile (hist[i].hisnum > num)\n\t    if (--i < 0)\n\t    {\n\t\tif (wrapped)\n\t\t    break;\n\t\ti += hislen;\n\t\twrapped = TRUE;\n\t    }\n\tif (i >= 0 && hist[i].hisnum == num && hist[i].hisstr != NULL)\n\t    return i;\n    }\n    else if (-num <= hislen)\n    {\n\ti += num + 1;\n\tif (i < 0)\n\t    i += hislen;\n\tif (hist[i].hisstr != NULL)\n\t    return i;\n    }\n    return -1;\n}\n\n/*\n * Get a history entry by its index.\n * \"histype\" may be one of the HIST_ values.\n */\n    static char_u *\nget_history_entry(int histype, int idx)\n{\n    idx = calc_hist_idx(histype, idx);\n    if (idx >= 0)\n\treturn history[histype][idx].hisstr;\n    else\n\treturn (char_u *)\"\";\n}\n\n/*\n * Clear all entries of a history.\n * \"histype\" may be one of the HIST_ values.\n */\n    static int\nclr_history(int histype)\n{\n    int\t\ti;\n    histentry_T\t*hisptr;\n\n    if (hislen != 0 && histype >= 0 && histype < HIST_COUNT)\n    {\n\thisptr = history[histype];\n\tfor (i = hislen; i--;)\n\t{\n\t    vim_free(hisptr->hisstr);\n\t    clear_hist_entry(hisptr);\n\t    hisptr++;\n\t}\n\thisidx[histype] = -1;\t// mark history as cleared\n\thisnum[histype] = 0;\t// reset identifier counter\n\treturn OK;\n    }\n    return FAIL;\n}\n\n/*\n * Remove all entries matching {str} from a history.\n * \"histype\" may be one of the HIST_ values.\n */\n    static int\ndel_history_entry(int histype, char_u *str)\n{\n    regmatch_T\tregmatch;\n    histentry_T\t*hisptr;\n    int\t\tidx;\n    int\t\ti;\n    int\t\tlast;\n    int\t\tfound = FALSE;\n\n    if (hislen == 0 || histype < 0 || histype >= HIST_COUNT || *str == NUL\n\t\t|| hisidx[histype] < 0)\n\treturn FALSE;\n\n    idx = hisidx[histype];\n    regmatch.regprog = vim_regcomp(str, RE_MAGIC + RE_STRING);\n    if (regmatch.regprog == NULL)\n\treturn FALSE;\n\n    regmatch.rm_ic = FALSE;\t// always match case\n\n    i = last = idx;\n    do\n    {\n\thisptr = &history[histype][i];\n\tif (hisptr->hisstr == NULL)\n\t    break;\n\tif (vim_regexec(&regmatch, hisptr->hisstr, (colnr_T)0))\n\t{\n\t    found = TRUE;\n\t    vim_free(hisptr->hisstr);\n\t    clear_hist_entry(hisptr);\n\t}\n\telse\n\t{\n\t    if (i != last)\n\t    {\n\t\thistory[histype][last] = *hisptr;\n\t\tclear_hist_entry(hisptr);\n\t    }\n\t    if (--last < 0)\n\t\tlast += hislen;\n\t}\n\tif (--i < 0)\n\t    i += hislen;\n    } while (i != idx);\n\n    if (history[histype][idx].hisstr == NULL)\n\thisidx[histype] = -1;\n\n    vim_regfree(regmatch.regprog);\n    return found;\n}\n\n/*\n * Remove an indexed entry from a history.\n * \"histype\" may be one of the HIST_ values.\n */\n    static int\ndel_history_idx(int histype, int idx)\n{\n    int\t    i, j;\n\n    i = calc_hist_idx(histype, idx);\n    if (i < 0)\n\treturn FALSE;\n    idx = hisidx[histype];\n    vim_free(history[histype][i].hisstr);\n\n    // When deleting the last added search string in a mapping, reset\n    // last_maptick, so that the last added search string isn't deleted again.\n    if (histype == HIST_SEARCH && maptick == last_maptick && i == idx)\n\tlast_maptick = -1;\n\n    while (i != idx)\n    {\n\tj = (i + 1) % hislen;\n\thistory[histype][i] = history[histype][j];\n\ti = j;\n    }\n    clear_hist_entry(&history[histype][i]);\n    if (--i < 0)\n\ti += hislen;\n    hisidx[histype] = i;\n    return TRUE;\n}\n\n/*\n * \"histadd()\" function\n */\n    void\nf_histadd(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    int\t\thistype;\n    char_u\t*str;\n    char_u\tbuf[NUMBUFLEN];\n\n    rettv->vval.v_number = FALSE;\n    if (check_secure())\n\treturn;\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_string_arg(argvars, 1) == FAIL))\n\treturn;\n\n    str = tv_get_string_chk(&argvars[0]);\t// NULL on type error\n    histype = str != NULL ? get_histtype(str) : -1;\n    if (histype < 0)\n\treturn;\n\n    str = tv_get_string_buf(&argvars[1], buf);\n    if (*str == NUL)\n\treturn;\n\n    init_history();\n    add_to_history(histype, str, FALSE, NUL);\n    rettv->vval.v_number = TRUE;\n}\n\n/*\n * \"histdel()\" function\n */\n    void\nf_histdel(typval_T *argvars UNUSED, typval_T *rettv UNUSED)\n{\n    int\t\tn;\n    char_u\tbuf[NUMBUFLEN];\n    char_u\t*str;\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_opt_string_or_number_arg(argvars, 1) == FAIL))\n\treturn;\n\n    str = tv_get_string_chk(&argvars[0]);\t// NULL on type error\n    if (str == NULL)\n\tn = 0;\n    else if (argvars[1].v_type == VAR_UNKNOWN)\n\t// only one argument: clear entire history\n\tn = clr_history(get_histtype(str));\n    else if (argvars[1].v_type == VAR_NUMBER)\n\t// index given: remove that entry\n\tn = del_history_idx(get_histtype(str),\n\t\t\t\t\t  (int)tv_get_number(&argvars[1]));\n    else\n\t// string given: remove all matching entries\n\tn = del_history_entry(get_histtype(str),\n\t\t\t\t      tv_get_string_buf(&argvars[1], buf));\n    rettv->vval.v_number = n;\n}\n\n/*\n * \"histget()\" function\n */\n    void\nf_histget(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    int\t\ttype;\n    int\t\tidx;\n    char_u\t*str;\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_opt_number_arg(argvars, 1) == FAIL))\n\treturn;\n\n    str = tv_get_string_chk(&argvars[0]);\t// NULL on type error\n    if (str == NULL)\n\trettv->vval.v_string = NULL;\n    else\n    {\n\ttype = get_histtype(str);\n\tif (argvars[1].v_type == VAR_UNKNOWN)\n\t    idx = get_history_idx(type);\n\telse\n\t    idx = (int)tv_get_number_chk(&argvars[1], NULL);\n\t\t\t\t\t\t    // -1 on type error\n\trettv->vval.v_string = vim_strsave(get_history_entry(type, idx));\n    }\n    rettv->v_type = VAR_STRING;\n}\n\n/*\n * \"histnr()\" function\n */\n    void\nf_histnr(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    int\t\ti;\n    char_u\t*histname;\n\n    if (in_vim9script() && check_for_string_arg(argvars, 0) == FAIL)\n\treturn;\n\n    histname = tv_get_string_chk(&argvars[0]);\n    i = histname == NULL ? HIST_CMD - 1 : get_histtype(histname);\n    if (i >= HIST_CMD && i < HIST_COUNT)\n\ti = get_history_idx(i);\n    else\n\ti = -1;\n    rettv->vval.v_number = i;\n}\n#endif // FEAT_EVAL\n\n#if defined(FEAT_CRYPT) || defined(PROTO)\n/*\n * Very specific function to remove the value in \":set key=val\" from the\n * history.\n */\n    void\nremove_key_from_history(void)\n{\n    char_u\t*p;\n    int\t\ti;\n\n    i = hisidx[HIST_CMD];\n    if (i < 0)\n\treturn;\n    p = history[HIST_CMD][i].hisstr;\n    if (p == NULL)\n\treturn;\n\n    for ( ; *p; ++p)\n\tif (STRNCMP(p, \"key\", 3) == 0 && !isalpha(p[3]))\n\t{\n\t    p = vim_strchr(p + 3, '=');\n\t    if (p == NULL)\n\t\tbreak;\n\t    ++p;\n\t    for (i = 0; p[i] && !VIM_ISWHITE(p[i]); ++i)\n\t\tif (p[i] == '\\\\' && p[i + 1])\n\t\t    ++i;\n\t    STRMOVE(p, p + i);\n\t    --p;\n\t}\n}\n#endif\n\n/*\n * :history command - print a history\n */\n    void\nex_history(exarg_T *eap)\n{\n    histentry_T\t*hist;\n    int\t\thistype1 = HIST_CMD;\n    int\t\thistype2 = HIST_CMD;\n    int\t\thisidx1 = 1;\n    int\t\thisidx2 = -1;\n    int\t\tidx;\n    int\t\ti, j, k;\n    char_u\t*end;\n    char_u\t*arg = eap->arg;\n\n    if (hislen == 0)\n    {\n\tmsg(_(\"'history' option is zero\"));\n\treturn;\n    }\n\n    if (!(VIM_ISDIGIT(*arg) || *arg == '-' || *arg == ','))\n    {\n\tend = arg;\n\twhile (ASCII_ISALPHA(*end)\n\t\t|| vim_strchr((char_u *)\":=@>/?\", *end) != NULL)\n\t    end++;\n\ti = *end;\n\t*end = NUL;\n\thistype1 = get_histtype(arg);\n\tif (histype1 == -1)\n\t{\n\t    if (STRNICMP(arg, \"all\", STRLEN(arg)) == 0)\n\t    {\n\t\thistype1 = 0;\n\t\thistype2 = HIST_COUNT-1;\n\t    }\n\t    else\n\t    {\n\t\t*end = i;\n\t\tsemsg(_(e_trailing_characters_str), arg);\n\t\treturn;\n\t    }\n\t}\n\telse\n\t    histype2 = histype1;\n\t*end = i;\n    }\n    else\n\tend = arg;\n    if (!get_list_range(&end, &hisidx1, &hisidx2) || *end != NUL)\n    {\n\tsemsg(_(e_trailing_characters_str), end);\n\treturn;\n    }\n\n    for (; !got_int && histype1 <= histype2; ++histype1)\n    {\n\tSTRCPY(IObuff, \"\\n      #  \");\n\tSTRCAT(STRCAT(IObuff, history_names[histype1]), \" history\");\n\tmsg_puts_title((char *)IObuff);\n\tidx = hisidx[histype1];\n\thist = history[histype1];\n\tj = hisidx1;\n\tk = hisidx2;\n\tif (j < 0)\n\t    j = (-j > hislen) ? 0 : hist[(hislen+j+idx+1) % hislen].hisnum;\n\tif (k < 0)\n\t    k = (-k > hislen) ? 0 : hist[(hislen+k+idx+1) % hislen].hisnum;\n\tif (idx >= 0 && j <= k)\n\t    for (i = idx + 1; !got_int; ++i)\n\t    {\n\t\tif (i == hislen)\n\t\t    i = 0;\n\t\tif (hist[i].hisstr != NULL\n\t\t\t&& hist[i].hisnum >= j && hist[i].hisnum <= k)\n\t\t{\n\t\t    msg_putchar('\\n');\n\t\t    sprintf((char *)IObuff, \"%c%6d  \", i == idx ? '>' : ' ',\n\t\t\t\t\t\t\t      hist[i].hisnum);\n\t\t    if (vim_strsize(hist[i].hisstr) > (int)Columns - 10)\n\t\t\ttrunc_string(hist[i].hisstr, IObuff + STRLEN(IObuff),\n\t\t\t     (int)Columns - 10, IOSIZE - (int)STRLEN(IObuff));\n\t\t    else\n\t\t\tSTRCAT(IObuff, hist[i].hisstr);\n\t\t    msg_outtrans(IObuff);\n\t\t    out_flush();\n\t\t}\n\t\tif (i == idx)\n\t\t    break;\n\t    }\n    }\n}\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n */\n\n// Use PLURAL_MSG() for messages that are passed to ngettext(), so that the\n// second one uses msgid_plural.\n#ifdef DO_INIT\n# define PLURAL_MSG(var1, msg1, var2, msg2) \\\n\tchar var1[] = msg1; \\\n\tchar var2[] = msg2;\n#else\n# define PLURAL_MSG(var1, msg1, var2, msg2) \\\n\textern char var1[]; \\\n\textern char var2[];\n#endif\n\n/*\n * Definition of error messages, sorted on error number.\n */\n\nEXTERN char e_interrupted[]\n\tINIT(= N_(\"Interrupted\"));\n\nEXTERN char e_backslash_should_be_followed_by[]\n\tINIT(= N_(\"E10: \\\\ should be followed by /, ? or &\"));\nEXTERN char e_invalid_in_cmdline_window[]\n\tINIT(= N_(\"E11: Invalid in command-line window; :q<CR> closes the window\"));\nEXTERN char e_command_not_allowed_from_vimrc_in_current_dir_or_tag_search[]\n\tINIT(= N_(\"E12: Command not allowed from exrc/vimrc in current dir or tag search\"));\nEXTERN char e_file_exists[]\n\tINIT(= N_(\"E13: File exists (add ! to override)\"));\n// E14 unused\n#ifdef FEAT_EVAL\nEXTERN char e_invalid_expression_str[]\n\tINIT(= N_(\"E15: Invalid expression: \\\"%s\\\"\"));\n#endif\nEXTERN char e_invalid_range[]\n\tINIT(= N_(\"E16: Invalid range\"));\n#if defined(UNIX) || defined(FEAT_SYN_HL) \\\n\t    || defined(FEAT_SPELL) || defined(FEAT_EVAL)\nEXTERN char e_str_is_directory[]\n\tINIT(= N_(\"E17: \\\"%s\\\" is a directory\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_unexpected_characters_in_let[]\n\tINIT(= N_(\"E18: Unexpected characters in :let\"));\nEXTERN char e_unexpected_characters_in_assignment[]\n\tINIT(= N_(\"E18: Unexpected characters in assignment\"));\n#endif\nEXTERN char e_mark_has_invalid_line_number[]\n\tINIT(= N_(\"E19: Mark has invalid line number\"));\nEXTERN char e_mark_not_set[]\n\tINIT(= N_(\"E20: Mark not set\"));\nEXTERN char e_cannot_make_changes_modifiable_is_off[]\n\tINIT(= N_(\"E21: Cannot make changes, 'modifiable' is off\"));\nEXTERN char e_scripts_nested_too_deep[]\n\tINIT(= N_(\"E22: Scripts nested too deep\"));\nEXTERN char e_no_alternate_file[]\n\tINIT(= N_(\"E23: No alternate file\"));\nEXTERN char e_no_such_abbreviation[]\n\tINIT(= N_(\"E24: No such abbreviation\"));\n#if !defined(FEAT_GUI) || defined(VIMDLL)\nEXTERN char e_gui_cannot_be_used_not_enabled_at_compile_time[]\n\tINIT(= N_(\"E25: GUI cannot be used: Not enabled at compile time\"));\n#endif\n#ifndef FEAT_RIGHTLEFT\nEXTERN char e_hebrew_cannot_be_used_not_enabled_at_compile_time[]\n\tINIT(= N_(\"E26: Hebrew cannot be used: Not enabled at compile time\\n\"));\n#endif\nEXTERN char e_farsi_support_has_been_removed[]\n\tINIT(= N_(\"E27: Farsi support has been removed\\n\"));\n#if defined(FEAT_SEARCH_EXTRA) || defined(FEAT_SYN_HL)\nEXTERN char e_no_such_highlight_group_name_str[]\n\tINIT(= N_(\"E28: No such highlight group name: %s\"));\n#endif\nEXTERN char e_no_inserted_text_yet[]\n\tINIT(= N_(\"E29: No inserted text yet\"));\nEXTERN char e_no_previous_command_line[]\n\tINIT(= N_(\"E30: No previous command line\"));\nEXTERN char e_no_such_mapping[]\n\tINIT(= N_(\"E31: No such mapping\"));\nEXTERN char e_no_file_name[]\n\tINIT(= N_(\"E32: No file name\"));\nEXTERN char e_no_previous_substitute_regular_expression[]\n\tINIT(= N_(\"E33: No previous substitute regular expression\"));\nEXTERN char e_no_previous_command[]\n\tINIT(= N_(\"E34: No previous command\"));\nEXTERN char e_no_previous_regular_expression[]\n\tINIT(= N_(\"E35: No previous regular expression\"));\nEXTERN char e_not_enough_room[]\n\tINIT(= N_(\"E36: Not enough room\"));\nEXTERN char e_no_write_since_last_change[]\n\tINIT(= N_(\"E37: No write since last change\"));\nEXTERN char e_no_write_since_last_change_add_bang_to_override[]\n\tINIT(= N_(\"E37: No write since last change (add ! to override)\"));\nEXTERN char e_null_argument[]\n\tINIT(= \"E38: Null argument\");\n#if defined(FEAT_DIGRAPHS) || defined(FEAT_TIMERS) || defined(FEAT_EVAL)\nEXTERN char e_number_expected[]\n\tINIT(= N_(\"E39: Number expected\"));\n#endif\n#ifdef FEAT_QUICKFIX\nEXTERN char e_cant_open_errorfile_str[]\n\tINIT(= N_(\"E40: Can't open errorfile %s\"));\n#endif\nEXTERN char e_out_of_memory[]\n\tINIT(= N_(\"E41: Out of memory!\"));\n#ifdef FEAT_QUICKFIX\nEXTERN char e_no_errors[]\n\tINIT(= N_(\"E42: No Errors\"));\n#endif\nEXTERN char e_damaged_match_string[]\n\tINIT(= \"E43: Damaged match string\");\nEXTERN char e_corrupted_regexp_program[]\n\tINIT(= \"E44: Corrupted regexp program\");\nEXTERN char e_readonly_option_is_set_add_bang_to_override[]\n\tINIT(= N_(\"E45: 'readonly' option is set (add ! to override)\"));\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_change_readonly_variable[]\n\tINIT(= N_(\"E46: Cannot change read-only variable\"));\nEXTERN char e_cannot_change_readonly_variable_str[]\n\tINIT(= N_(\"E46: Cannot change read-only variable \\\"%s\\\"\"));\n#endif\n#ifdef FEAT_QUICKFIX\nEXTERN char e_error_while_reading_errorfile[]\n\tINIT(= N_(\"E47: Error while reading errorfile\"));\n#endif\n#ifdef HAVE_SANDBOX\nEXTERN char e_not_allowed_in_sandbox[]\n\tINIT(= N_(\"E48: Not allowed in sandbox\"));\n#endif\nEXTERN char e_invalid_scroll_size[]\n\tINIT(= N_(\"E49: Invalid scroll size\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_too_many_z[]\n\tINIT(= N_(\"E50: Too many \\\\z(\"));\n#endif\nEXTERN char e_too_many_str_open[]\n\tINIT(= N_(\"E51: Too many %s(\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_unmatched_z[]\n\tINIT(= N_(\"E52: Unmatched \\\\z(\"));\n#endif\nEXTERN char e_unmatched_str_percent_open[]\n\tINIT(= N_(\"E53: Unmatched %s%%(\"));\nEXTERN char e_unmatched_str_open[]\n\tINIT(= N_(\"E54: Unmatched %s(\"));\nEXTERN char e_unmatched_str_close[]\n\tINIT(= N_(\"E55: Unmatched %s)\"));\n// E56 unused\n// E57 unused\n// E58 unused\nEXTERN char e_invalid_character_after_str_at[]\n\tINIT(= N_(\"E59: Invalid character after %s@\"));\nEXTERN char e_too_many_complex_str_curly[]\n\tINIT(= N_(\"E60: Too many complex %s{...}s\"));\nEXTERN char e_nested_str[]\n\tINIT(= N_(\"E61: Nested %s*\"));\nEXTERN char e_nested_str_chr[]\n\tINIT(= N_(\"E62: Nested %s%c\"));\nEXTERN char e_invalid_use_of_underscore[]\n\tINIT(= N_(\"E63: Invalid use of \\\\_\"));\nEXTERN char e_str_chr_follows_nothing[]\n\tINIT(= N_(\"E64: %s%c follows nothing\"));\nEXTERN char e_illegal_back_reference[]\n\tINIT(= N_(\"E65: Illegal back reference\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_z_not_allowed_here[]\n\tINIT(= N_(\"E66: \\\\z( not allowed here\"));\nEXTERN char e_z1_z9_not_allowed_here[]\n\tINIT(= N_(\"E67: \\\\z1 - \\\\z9 not allowed here\"));\n#endif\nEXTERN char e_invalid_character_after_bsl_z[]\n\tINIT(= N_(\"E68: Invalid character after \\\\z\"));\nEXTERN char e_missing_sb_after_str[]\n\tINIT(= N_(\"E69: Missing ] after %s%%[\"));\nEXTERN char e_empty_str_brackets[]\n\tINIT(= N_(\"E70: Empty %s%%[]\"));\nEXTERN char e_invalid_character_after_str[]\n\tINIT(= N_(\"E71: Invalid character after %s%%\"));\nEXTERN char e_close_error_on_swap_file[]\n\tINIT(= N_(\"E72: Close error on swap file\"));\nEXTERN char e_tag_stack_empty[]\n\tINIT(= N_(\"E73: Tag stack empty\"));\nEXTERN char e_command_too_complex[]\n\tINIT(= N_(\"E74: Command too complex\"));\nEXTERN char e_name_too_long[]\n\tINIT(= N_(\"E75: Name too long\"));\nEXTERN char e_too_many_brackets[]\n\tINIT(= N_(\"E76: Too many [\"));\nEXTERN char e_too_many_file_names[]\n\tINIT(= N_(\"E77: Too many file names\"));\nEXTERN char e_unknown_mark[]\n\tINIT(= N_(\"E78: Unknown mark\"));\nEXTERN char e_cannot_expand_wildcards[]\n\tINIT(= N_(\"E79: Cannot expand wildcards\"));\nEXTERN char e_error_while_writing[]\n\tINIT(= N_(\"E80: Error while writing\"));\n#ifdef FEAT_EVAL\nEXTERN char e_using_sid_not_in_script_context[]\n\tINIT(= N_(\"E81: Using <SID> not in a script context\"));\n#endif\nEXTERN char e_cannot_allocate_any_buffer_exiting[]\n\tINIT(= N_(\"E82: Cannot allocate any buffer, exiting...\"));\nEXTERN char e_cannot_allocate_buffer_using_other_one[]\n\tINIT(= N_(\"E83: Cannot allocate buffer, using other one...\"));\nEXTERN char e_no_modified_buffer_found[]\n\tINIT(= N_(\"E84: No modified buffer found\"));\nEXTERN char e_there_is_no_listed_buffer[]\n\tINIT(= N_(\"E85: There is no listed buffer\"));\nEXTERN char e_buffer_nr_does_not_exist[]\n\tINIT(= N_(\"E86: Buffer %ld does not exist\"));\nEXTERN char e_cannot_go_beyond_last_buffer[]\n\tINIT(= N_(\"E87: Cannot go beyond last buffer\"));\nEXTERN char e_cannot_go_before_first_buffer[]\n\tINIT(= N_(\"E88: Cannot go before first buffer\"));\nEXTERN char e_no_write_since_last_change_for_buffer_nr_add_bang_to_override[]\n\tINIT(= N_(\"E89: No write since last change for buffer %d (add ! to override)\"));\nEXTERN char e_cannot_unload_last_buffer[]\n\tINIT(= N_(\"E90: Cannot unload last buffer\"));\nEXTERN char e_shell_option_is_empty[]\n\tINIT(= N_(\"E91: 'shell' option is empty\"));\nEXTERN char e_buffer_nr_not_found[]\n\tINIT(= N_(\"E92: Buffer %d not found\"));\nEXTERN char e_more_than_one_match_for_str[]\n\tINIT(= N_(\"E93: More than one match for %s\"));\nEXTERN char e_no_matching_buffer_for_str[]\n\tINIT(= N_(\"E94: No matching buffer for %s\"));\nEXTERN char e_buffer_with_this_name_already_exists[]\n\tINIT(= N_(\"E95: Buffer with this name already exists\"));\n#if defined(FEAT_DIFF)\nEXTERN char e_cannot_diff_more_than_nr_buffers[]\n\tINIT(= N_(\"E96: Cannot diff more than %d buffers\"));\nEXTERN char e_cannot_create_diffs[]\n\tINIT(= N_(\"E97: Cannot create diffs\"));\nEXTERN char e_cannot_read_diff_output[]\n\tINIT(= N_(\"E98: Cannot read diff output\"));\nEXTERN char e_current_buffer_is_not_in_diff_mode[]\n\tINIT(= N_(\"E99: Current buffer is not in diff mode\"));\nEXTERN char e_no_other_buffer_in_diff_mode[]\n\tINIT(= N_(\"E100: No other buffer in diff mode\"));\nEXTERN char e_more_than_two_buffers_in_diff_mode_dont_know_which_one_to_use[]\n\tINIT(= N_(\"E101: More than two buffers in diff mode, don't know which one to use\"));\nEXTERN char e_cant_find_buffer_str[]\n\tINIT(= N_(\"E102: Can't find buffer \\\"%s\\\"\"));\nEXTERN char e_buffer_str_is_not_in_diff_mode[]\n\tINIT(= N_(\"E103: Buffer \\\"%s\\\" is not in diff mode\"));\n#endif\n#ifdef FEAT_DIGRAPHS\nEXTERN char e_escape_not_allowed_in_digraph[]\n\tINIT(= N_(\"E104: Escape not allowed in digraph\"));\n#endif\n#ifdef FEAT_KEYMAP\nEXTERN char e_using_loadkeymap_not_in_sourced_file[]\n\tINIT(= N_(\"E105: Using :loadkeymap not in a sourced file\"));\n#endif\n// E106 unused\n#ifdef FEAT_EVAL\nEXTERN char e_missing_parenthesis_str[]\n\tINIT(= N_(\"E107: Missing parentheses: %s\"));\nEXTERN char e_no_such_variable_str[]\n\tINIT(= N_(\"E108: No such variable: \\\"%s\\\"\"));\nEXTERN char e_missing_colon_after_questionmark[]\n\tINIT(= N_(\"E109: Missing ':' after '?'\"));\nEXTERN char e_missing_closing_paren[]\n\tINIT(= N_(\"E110: Missing ')'\"));\nEXTERN char e_missing_closing_square_brace[]\n\tINIT(= N_(\"E111: Missing ']'\"));\nEXTERN char e_option_name_missing_str[]\n\tINIT(= N_(\"E112: Option name missing: %s\"));\nEXTERN char e_unknown_option_str[]\n\tINIT(= N_(\"E113: Unknown option: %s\"));\nEXTERN char e_missing_double_quote_str[]\n\tINIT(= N_(\"E114: Missing double quote: %s\"));\nEXTERN char e_missing_single_quote_str[]\n\tINIT(= N_(\"E115: Missing single quote: %s\"));\nEXTERN char e_invalid_arguments_for_function_str[]\n\tINIT(= N_(\"E116: Invalid arguments for function %s\"));\nEXTERN char e_unknown_function_str[]\n\tINIT(= N_(\"E117: Unknown function: %s\"));\nEXTERN char e_too_many_arguments_for_function_str[]\n\tINIT(= N_(\"E118: Too many arguments for function: %s\"));\nEXTERN char e_not_enough_arguments_for_function_str[]\n\tINIT(= N_(\"E119: Not enough arguments for function: %s\"));\nEXTERN char e_using_sid_not_in_script_context_str[]\n\tINIT(= N_(\"E120: Using <SID> not in a script context: %s\"));\nEXTERN char e_undefined_variable_str[]\n\tINIT(= N_(\"E121: Undefined variable: %s\"));\nEXTERN char e_undefined_variable_char_str[]\n\tINIT(= N_(\"E121: Undefined variable: %c:%s\"));\nEXTERN char e_function_str_already_exists_add_bang_to_replace[]\n\tINIT(= N_(\"E122: Function %s already exists, add ! to replace it\"));\nEXTERN char e_undefined_function_str[]\n\tINIT(= N_(\"E123: Undefined function: %s\"));\nEXTERN char e_missing_paren_str[]\n\tINIT(= N_(\"E124: Missing '(': %s\"));\nEXTERN char e_illegal_argument_str[]\n\tINIT(= N_(\"E125: Illegal argument: %s\"));\nEXTERN char e_missing_endfunction[]\n\tINIT(= N_(\"E126: Missing :endfunction\"));\nEXTERN char e_cannot_redefine_function_str_it_is_in_use[]\n\tINIT(= N_(\"E127: Cannot redefine function %s: It is in use\"));\nEXTERN char e_function_name_must_start_with_capital_or_s_str[]\n\tINIT(= N_(\"E128: Function name must start with a capital or \\\"s:\\\": %s\"));\nEXTERN char e_function_name_required[]\n\tINIT(= N_(\"E129: Function name required\"));\n// E130 unused\nEXTERN char e_cannot_delete_function_str_it_is_in_use[]\n\tINIT(= N_(\"E131: Cannot delete function %s: It is in use\"));\nEXTERN char e_function_call_depth_is_higher_than_macfuncdepth[]\n\tINIT(= N_(\"E132: Function call depth is higher than 'maxfuncdepth'\"));\nEXTERN char e_return_not_inside_function[]\n\tINIT(= N_(\"E133: :return not inside a function\"));\n#endif\nEXTERN char e_cannot_move_range_of_lines_into_itself[]\n\tINIT(= N_(\"E134: Cannot move a range of lines into itself\"));\nEXTERN char e_filter_autocommands_must_not_change_current_buffer[]\n\tINIT(= N_(\"E135: *Filter* Autocommands must not change current buffer\"));\n#if defined(FEAT_VIMINFO)\nEXTERN char e_viminfo_too_many_errors_skipping_rest_of_file[]\n\tINIT(= N_(\"E136: viminfo: Too many errors, skipping rest of file\"));\nEXTERN char e_viminfo_file_is_not_writable_str[]\n\tINIT(= N_(\"E137: Viminfo file is not writable: %s\"));\nEXTERN char e_cant_write_viminfo_file_str[]\n\tINIT(= N_(\"E138: Can't write viminfo file %s!\"));\n#endif\nEXTERN char e_file_is_loaded_in_another_buffer[]\n\tINIT(= N_(\"E139: File is loaded in another buffer\"));\nEXTERN char e_use_bang_to_write_partial_buffer[]\n\tINIT(= N_(\"E140: Use ! to write partial buffer\"));\nEXTERN char e_no_file_name_for_buffer_nr[]\n\tINIT(= N_(\"E141: No file name for buffer %ld\"));\nEXTERN char e_file_not_written_writing_is_disabled_by_write_option[]\n\tINIT(= N_(\"E142: File not written: Writing is disabled by 'write' option\"));\nEXTERN char e_autocommands_unexpectedly_deleted_new_buffer_str[]\n\tINIT(= N_(\"E143: Autocommands unexpectedly deleted new buffer %s\"));\nEXTERN char e_non_numeric_argument_to_z[]\n\tINIT(= N_(\"E144: Non-numeric argument to :z\"));\nEXTERN char e_shell_commands_and_some_functionality_not_allowed_in_rvim[]\n\tINIT(= N_(\"E145: Shell commands and some functionality not allowed in rvim\"));\nEXTERN char e_regular_expressions_cant_be_delimited_by_letters[]\n\tINIT(= N_(\"E146: Regular expressions can't be delimited by letters\"));\nEXTERN char e_cannot_do_global_recursive_with_range[]\n\tINIT(= N_(\"E147: Cannot do :global recursive with a range\"));\nEXTERN char e_regular_expression_missing_from_global[]\n\tINIT(= N_(\"E148: Regular expression missing from :global\"));\nEXTERN char e_sorry_no_help_for_str[]\n\tINIT(= N_(\"E149: Sorry, no help for %s\"));\nEXTERN char e_not_a_directory_str[]\n\tINIT(= N_(\"E150: Not a directory: %s\"));\nEXTERN char e_no_match_str_1[]\n\tINIT(= N_(\"E151: No match: %s\"));\nEXTERN char e_cannot_open_str_for_writing_1[]\n\tINIT(= N_(\"E152: Cannot open %s for writing\"));\nEXTERN char e_unable_to_open_str_for_reading[]\n\tINIT(= N_(\"E153: Unable to open %s for reading\"));\nEXTERN char e_duplicate_tag_str_in_file_str_str[]\n\tINIT(= N_(\"E154: Duplicate tag \\\"%s\\\" in file %s/%s\"));\n#ifdef FEAT_SIGNS\nEXTERN char e_unknown_sign_str[]\n\tINIT(= N_(\"E155: Unknown sign: %s\"));\nEXTERN char e_missing_sign_name[]\n\tINIT(= N_(\"E156: Missing sign name\"));\nEXTERN char e_invalid_sign_id_nr[]\n\tINIT(= N_(\"E157: Invalid sign ID: %d\"));\n#endif\n#if defined(FEAT_SIGNS) || defined(FEAT_EVAL)\nEXTERN char e_invalid_buffer_name_str[]\n\tINIT(= N_(\"E158: Invalid buffer name: %s\"));\n#endif\n#ifdef FEAT_SIGNS\nEXTERN char e_missing_sign_number[]\n\tINIT(= N_(\"E159: Missing sign number\"));\nEXTERN char e_unknown_sign_command_str[]\n\tINIT(= N_(\"E160: Unknown sign command: %s\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_breakpoint_not_found_str[]\n\tINIT(= N_(\"E161: Breakpoint not found: %s\"));\n#endif\nEXTERN char e_no_write_since_last_change_for_buffer_str[]\n\tINIT(= N_(\"E162: No write since last change for buffer \\\"%s\\\"\"));\nEXTERN char e_there_is_only_one_file_to_edit[]\n\tINIT(= N_(\"E163: There is only one file to edit\"));\nEXTERN char e_cannot_go_before_first_file[]\n\tINIT(= N_(\"E164: Cannot go before first file\"));\nEXTERN char e_cannot_go_beyond_last_file[]\n\tINIT(= N_(\"E165: Cannot go beyond last file\"));\nEXTERN char e_cant_open_linked_file_for_writing[]\n\tINIT(= N_(\"E166: Can't open linked file for writing\"));\nEXTERN char e_scriptencoding_used_outside_of_sourced_file[]\n\tINIT(= N_(\"E167: :scriptencoding used outside of a sourced file\"));\n#ifdef FEAT_EVAL\nEXTERN char e_finish_used_outside_of_sourced_file[]\n\tINIT(= N_(\"E168: :finish used outside of a sourced file\"));\n#endif\nEXTERN char e_command_too_recursive[]\n\tINIT(= N_(\"E169: Command too recursive\"));\n#ifdef FEAT_EVAL\nEXTERN char e_missing_endwhile[]\n\tINIT(= N_(\"E170: Missing :endwhile\"));\nEXTERN char e_missing_endfor[]\n\tINIT(= N_(\"E170: Missing :endfor\"));\nEXTERN char e_missing_endif[]\n\tINIT(= N_(\"E171: Missing :endif\"));\nEXTERN char e_missing_marker[]\n\tINIT(= N_(\"E172: Missing marker\"));\n#endif\n\nPLURAL_MSG(e_nr_more_file_to_edit, \"E173: %d more file to edit\",\n\t\te_nr_more_files_to_edit, \"E173: %d more files to edit\")\n\nEXTERN char e_command_already_exists_add_bang_to_replace_it_str[]\n\tINIT(= N_(\"E174: Command already exists: add ! to replace it: %s\"));\nEXTERN char e_no_attribute_specified[]\n\tINIT(= N_(\"E175: No attribute specified\"));\nEXTERN char e_invalid_number_of_arguments[]\n\tINIT(= N_(\"E176: Invalid number of arguments\"));\nEXTERN char e_count_cannot_be_specified_twice[]\n\tINIT(= N_(\"E177: Count cannot be specified twice\"));\nEXTERN char e_invalid_default_value_for_count[]\n\tINIT(= N_(\"E178: Invalid default value for count\"));\nEXTERN char e_argument_required_for_str[]\n\tINIT(= N_(\"E179: Argument required for %s\"));\nEXTERN char e_invalid_complete_value_str[]\n\tINIT(= N_(\"E180: Invalid complete value: %s\"));\nEXTERN char e_invalid_address_type_value_str[]\n\tINIT(= N_(\"E180: Invalid address type value: %s\"));\nEXTERN char e_invalid_attribute_str[]\n\tINIT(= N_(\"E181: Invalid attribute: %s\"));\nEXTERN char e_invalid_command_name[]\n\tINIT(= N_(\"E182: Invalid command name\"));\nEXTERN char e_user_defined_commands_must_start_with_an_uppercase_letter[]\n\tINIT(= N_(\"E183: User defined commands must start with an uppercase letter\"));\nEXTERN char e_no_such_user_defined_command_str[]\n\tINIT(= N_(\"E184: No such user-defined command: %s\"));\nEXTERN char e_cannot_find_color_scheme_str[]\n\tINIT(= N_(\"E185: Cannot find color scheme '%s'\"));\nEXTERN char e_no_previous_directory[]\n\tINIT(= N_(\"E186: No previous directory\"));\nEXTERN char e_directory_unknown[]\n\tINIT(= N_(\"E187: Directory unknown\"));\nEXTERN char e_obtaining_window_position_not_implemented_for_this_platform[]\n\tINIT(= N_(\"E188: Obtaining window position not implemented for this platform\"));\nEXTERN char e_str_exists_add_bang_to_override[]\n\tINIT(= N_(\"E189: \\\"%s\\\" exists (add ! to override)\"));\nEXTERN char e_cannot_open_str_for_writing_2[]\n\tINIT(= N_(\"E190: Cannot open \\\"%s\\\" for writing\"));\nEXTERN char e_argument_must_be_letter_or_forward_backward_quote[]\n\tINIT(= N_(\"E191: Argument must be a letter or forward/backward quote\"));\nEXTERN char e_recursive_use_of_normal_too_deep[]\n\tINIT(= N_(\"E192: Recursive use of :normal too deep\"));\n#ifdef FEAT_EVAL\nEXTERN char e_str_not_inside_function[]\n\tINIT(= N_(\"E193: %s not inside a function\"));\n#endif\nEXTERN char e_no_alternate_file_name_to_substitute_for_hash[]\n\tINIT(= N_(\"E194: No alternate file name to substitute for '#'\"));\n#ifdef FEAT_VIMINFO\nEXTERN char e_cannot_open_viminfo_file_for_reading[]\n\tINIT(= N_(\"E195: Cannot open viminfo file for reading\"));\n#endif\n#ifndef FEAT_DIGRAPHS\nEXTERN char e_no_digraphs_version[]\n\tINIT(= N_(\"E196: No digraphs in this version\"));\n#endif\nEXTERN char e_cannot_set_language_to_str[]\n\tINIT(= N_(\"E197: Cannot set language to \\\"%s\\\"\"));\n// E198 unused\nEXTERN char e_active_window_or_buffer_deleted[]\n\tINIT(= N_(\"E199: Active window or buffer deleted\"));\nEXTERN char e_readpre_autocommands_made_file_unreadable[]\n\tINIT(= N_(\"E200: *ReadPre autocommands made the file unreadable\"));\nEXTERN char e_readpre_autocommands_must_not_change_current_buffer[]\n\tINIT(= N_(\"E201: *ReadPre autocommands must not change current buffer\"));\n#ifdef FEAT_EVAL\nEXTERN char e_conversion_mad_file_unreadable[]\n\tINIT(= N_(\"E202: Conversion made file unreadable!\"));\n#endif\nEXTERN char e_autocommands_deleted_or_unloaded_buffer_to_be_written[]\n\tINIT(= N_(\"E203: Autocommands deleted or unloaded buffer to be written\"));\nEXTERN char e_autocommands_changed_number_of_lines_in_unexpected_way[]\n\tINIT(= N_(\"E204: Autocommand changed number of lines in unexpected way\"));\nEXTERN char e_patchmode_cant_save_original_file[]\n\tINIT(= N_(\"E205: Patchmode: can't save original file\"));\nEXTERN char e_patchmode_cant_touch_empty_original_file[]\n\tINIT(= N_(\"E206: Patchmode: can't touch empty original file\"));\nEXTERN char e_cant_delete_backup_file[]\n\tINIT(= N_(\"E207: Can't delete backup file\"));\nEXTERN char e_error_writing_to_str[]\n\tINIT(= N_(\"E208: Error writing to \\\"%s\\\"\"));\nEXTERN char e_error_closing_str[]\n\tINIT(= N_(\"E209: Error closing \\\"%s\\\"\"));\nEXTERN char e_error_reading_str[]\n\tINIT(= N_(\"E210: Error reading \\\"%s\\\"\"));\nEXTERN char e_file_str_no_longer_available[]\n\tINIT(= N_(\"E211: File \\\"%s\\\" no longer available\"));\nEXTERN char e_cant_open_file_for_writing[]\n\tINIT(= N_(\"E212: Can't open file for writing\"));\nEXTERN char e_cannot_convert_add_bang_to_write_without_conversion[]\n\tINIT(= N_(\"E213: Cannot convert (add ! to write without conversion)\"));\n#ifdef FEAT_EVAL\nEXTERN char e_cant_find_temp_file_for_writing[]\n\tINIT(= N_(\"E214: Can't find temp file for writing\"));\n#endif\nEXTERN char e_illegal_character_after_star_str[]\n\tINIT(= N_(\"E215: Illegal character after *: %s\"));\nEXTERN char e_no_such_event_str[]\n\tINIT(= N_(\"E216: No such event: %s\"));\nEXTERN char e_no_such_group_or_event_str[]\n\tINIT(= N_(\"E216: No such group or event: %s\"));\nEXTERN char e_cant_execute_autocommands_for_all_events[]\n\tINIT(= N_(\"E217: Can't execute autocommands for ALL events\"));\nEXTERN char e_autocommand_nesting_too_deep[]\n\tINIT(= N_(\"E218: Autocommand nesting too deep\"));\nEXTERN char e_missing_open_curly[]\n\tINIT(= N_(\"E219: Missing {.\"));\nEXTERN char e_missing_close_curly[]\n\tINIT(= N_(\"E220: Missing }.\"));\n#ifdef FEAT_EVAL\nEXTERN char e_marker_cannot_start_with_lower_case_letter[]\n\tINIT(= N_(\"E221: Marker cannot start with lower case letter\"));\n#endif\nEXTERN char e_add_to_internal_buffer_that_was_already_read_from[]\n\tINIT(= \"E222: Add to internal buffer that was already read from\");\nEXTERN char e_recursive_mapping[]\n\tINIT(= N_(\"E223: Recursive mapping\"));\nEXTERN char e_global_abbreviation_already_exists_for_str[]\n\tINIT(= N_(\"E224: Global abbreviation already exists for %s\"));\nEXTERN char e_global_mapping_already_exists_for_str[]\n\tINIT(= N_(\"E225: Global mapping already exists for %s\"));\nEXTERN char e_abbreviation_already_exists_for_str[]\n\tINIT(= N_(\"E226: Abbreviation already exists for %s\"));\nEXTERN char e_mapping_already_exists_for_str[]\n\tINIT(= N_(\"E227: Mapping already exists for %s\"));\nEXTERN char e_makemap_illegal_mode[]\n\tINIT(= \"E228: makemap: Illegal mode\");\n#ifdef FEAT_GUI\nEXTERN char e_cannot_start_the_GUI[]\n\tINIT(= N_(\"E229: Cannot start the GUI\"));\nEXTERN char e_cannot_read_from_str[]\n\tINIT(= N_(\"E230: Cannot read from \\\"%s\\\"\"));\nEXTERN char e_guifontwide_invalid[]\n\tINIT(= N_(\"E231: 'guifontwide' invalid\"));\n#ifdef FEAT_BEVAL_GUI\nEXTERN char e_cannot_create_ballooneval_with_both_message_and_callback[]\n\tINIT(= \"E232: Cannot create BalloonEval with both message and callback\");\n#endif\n# if defined(FEAT_GUI_GTK) || defined(FEAT_GUI_X11)\nEXTERN char e_cannot_open_display[]\n\tINIT(= N_(\"E233: Cannot open display\"));\n# endif\n# if defined(FEAT_XFONTSET)\nEXTERN char e_unknown_fontset_str[]\n\tINIT(= N_(\"E234: Unknown fontset: %s\"));\n# endif\n# if defined(FEAT_GUI_X11) || defined(FEAT_GUI_GTK) \\\n\t|| defined(FEAT_GUI_PHOTON) || defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_HAIKU)\nEXTERN char e_unknown_font_str[]\n\tINIT(= N_(\"E235: Unknown font: %s\"));\n# endif\n# if defined(FEAT_GUI_X11) && !defined(FEAT_GUI_GTK)\nEXTERN char e_font_str_is_not_fixed_width[]\n\tINIT(= N_(\"E236: Font \\\"%s\\\" is not fixed-width\"));\n# endif\n#endif\n#ifdef MSWIN\nEXTERN char e_printer_selection_failed[]\n\tINIT(= N_(\"E237: Printer selection failed\"));\nEXTERN char e_print_error_str[]\n\tINIT(= N_(\"E238: Print error: %s\"));\n#endif\n#ifdef FEAT_SIGNS\nEXTERN char e_invalid_sign_text_str[]\n\tINIT(= N_(\"E239: Invalid sign text: %s\"));\n#endif\n#if defined(FEAT_CLIENTSERVER) && defined(FEAT_X11)\nEXTERN char e_no_connection_to_x_server[]\n\tINIT(= N_(\"E240: No connection to the X server\"));\n#endif\n#ifdef FEAT_CLIENTSERVER\nEXTERN char e_unable_to_send_to_str[]\n\tINIT(= N_(\"E241: Unable to send to %s\"));\n#endif\nEXTERN char e_cant_split_window_while_closing_another[]\n\tINIT(= N_(\"E242: Can't split a window while closing another\"));\n#if defined(FEAT_GUI_MSWIN) && !defined(FEAT_OLE)\nEXTERN char e_argument_not_supported_str_use_ole_version[]\n\tINIT(= N_(\"E243: Argument not supported: \\\"-%s\\\"; Use the OLE version.\"));\n#endif\n#ifdef MSWIN\nEXTERN char e_illegal_str_name_str_in_font_name_str[]\n\tINIT(= N_(\"E244: Illegal %s name \\\"%s\\\" in font name \\\"%s\\\"\"));\nEXTERN char e_illegal_char_nr_in_font_name_str[]\n\tINIT(= N_(\"E245: Illegal char '%c' in font name \\\"%s\\\"\"));\n#endif\nEXTERN char e_filechangedshell_autocommand_deleted_buffer[]\n\tINIT(= N_(\"E246: FileChangedShell autocommand deleted buffer\"));\n#ifdef FEAT_CLIENTSERVER\nEXTERN char e_no_registered_server_named_str[]\n\tINIT(= N_(\"E247: No registered server named \\\"%s\\\"\"));\nEXTERN char e_failed_to_send_command_to_destination_program[]\n\tINIT(= N_(\"E248: Failed to send command to the destination program\"));\n#endif\nEXTERN char e_window_layout_changed_unexpectedly[]\n\tINIT(= N_(\"E249: Window layout changed unexpectedly\"));\n#ifdef FEAT_XFONTSET\nEXTERN char e_fonts_for_the_following_charsets_are_missing_in_fontset[]\n\tINIT(= N_(\"E250: Fonts for the following charsets are missing in fontset %s:\"));\n#endif\n#ifdef FEAT_CLIENTSERVER\nEXTERN char e_vim_instance_registry_property_is_badly_formed_deleted[]\n\tINIT(= N_(\"E251: VIM instance registry property is badly formed.  Deleted!\"));\n#endif\n#ifdef FEAT_GUI_X11\nEXTERN char e_fontsent_name_str_font_str_is_not_fixed_width[]\n\tINIT(= N_(\"E252: Fontset name: %s - Font '%s' is not fixed-width\"));\nEXTERN char e_fontset_name_str[]\n\tINIT(= N_(\"E253: Fontset name: %s\"));\n#endif\n#if defined(FEAT_GUI) || defined(FEAT_TERMGUICOLORS)\nEXTERN char e_cannot_allocate_color_str[]\n\tINIT(= N_(\"E254: Cannot allocate color %s\"));\n#endif\n#if defined(FEAT_SIGN_ICONS) && !defined(FEAT_GUI_GTK)\nEXTERN char e_couldnt_read_in_sign_data[]\n\tINIT(= N_(\"E255: Couldn't read in sign data\"));\n#endif\n// E256 unused\n#ifdef FEAT_CSCOPE\nEXTERN char e_cstag_tag_not_founc[]\n\tINIT(= N_(\"E257: cstag: Tag not found\"));\n#endif\n#ifdef FEAT_CLIENTSERVER\nEXTERN char e_unable_to_send_to_client[]\n\tINIT(= N_(\"E258: Unable to send to client\"));\n#endif\n#ifdef FEAT_CSCOPE\nEXTERN char e_no_matches_found_for_cscope_query_str_of_str[]\n\tINIT(= N_(\"E259: No matches found for cscope query %s of %s\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_missing_name_after_method[]\n\tINIT(= N_(\"E260: Missing name after ->\"));\n#endif\n#ifdef FEAT_CSCOPE\nEXTERN char e_cscope_connection_str_not_founc[]\n\tINIT(= N_(\"E261: Cscope connection %s not found\"));\nEXTERN char e_error_reading_cscope_connection_nr[]\n\tINIT(= N_(\"E262: Error reading cscope connection %d\"));\n#endif\n#if defined(DYNAMIC_PYTHON) || defined(DYNAMIC_PYTHON3)\nEXTERN char e_sorry_this_command_is_disabled_python_library_could_not_be_found[]\n\tINIT(= N_(\"E263: Sorry, this command is disabled, the Python library could not be loaded.\"));\n#endif\n#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3)\nEXTERN char e_python_error_initialising_io_object[]\n\tINIT(= N_(\"E264: Python: Error initialising I/O objects\"));\n#endif\n#ifdef FEAT_RUBY\nEXTERN char e_dollar_must_be_an_instance_of_string[]\n\tINIT(= N_(\"E265: $_ must be an instance of String\"));\n#endif\n#ifdef DYNAMIC_RUBY\nEXTERN char e_sorry_this_command_is_disabled_the_ruby_library_could_not_be_loaded[]\n\tINIT(= N_(\"E266: Sorry, this command is disabled, the Ruby library could not be loaded.\"));\n#endif\n#ifdef FEAT_RUBY\nEXTERN char e_unexpected_return[]\n\tINIT(= N_(\"E267: Unexpected return\"));\nEXTERN char e_unexpected_next[]\n\tINIT(= N_(\"E268: Unexpected next\"));\nEXTERN char e_unexpected_break[]\n\tINIT(= N_(\"E269: Unexpected break\"));\nEXTERN char e_unexpected_redo[]\n\tINIT(= N_(\"E270: Unexpected redo\"));\nEXTERN char e_retry_outside_of_rescue_clause[]\n\tINIT(= N_(\"E271: Retry outside of rescue clause\"));\nEXTERN char e_unhandled_exception[]\n\tINIT(= N_(\"E272: Unhandled exception\"));\nEXTERN char e_unknown_longjmp_status_nr[]\n\tINIT(= N_(\"E273: Unknown longjmp status %d\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_no_white_space_allowed_before_parenthesis[]\n\tINIT(= N_(\"E274: No white space allowed before parenthesis\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_cannot_add_text_property_to_unloaded_buffer[]\n\tINIT(= N_(\"E275: Cannot add text property to unloaded buffer\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_use_function_as_method_str[]\n\tINIT(= N_(\"E276: Cannot use function as a method: %s\"));\n#endif\n#ifdef FEAT_CLIENTSERVER\nEXTERN char e_unable_to_read_server_reply[]\n\tINIT(= N_(\"E277: Unable to read a server reply\"));\n#endif\n// E278 unused\n#if defined(FEAT_TERMINAL) && !defined(UNIX) && !defined(MSWIN)\nEXTERN char e_sorry_plusplusshell_not_supported_on_this_system[]\n\tINIT(= N_(\"E279: Sorry, ++shell is not supported on this system\"));\n#endif\n#ifdef FEAT_TCL\nEXTERN char e_tcl_fatal_error_reflist_corrupt_please_report_this[]\n\tINIT(= \"E280: TCL FATAL ERROR: reflist corrupt!? Please report this to vim-dev@vim.org\");\n#endif\n// E281 unused\nEXTERN char e_cannot_read_from_str_2[]\n\tINIT(= N_(\"E282: Cannot read from \\\"%s\\\"\"));\nEXTERN char e_no_marks_matching_str[]\n\tINIT(= N_(\"E283: No marks matching \\\"%s\\\"\"));\n#ifdef FEAT_XIM\n# ifndef FEAT_GUI_GTK\nEXTERN char e_cannot_set_ic_values[]\n\tINIT(= N_(\"E284: Cannot set IC values\"));\n# endif\n# ifdef FEAT_GUI_X11\nEXTERN char e_failed_to_create_input_context[]\n\tINIT(= N_(\"E285: Failed to create input context\"));\nEXTERN char e_failed_to_open_input_method[]\n\tINIT(= N_(\"E286: Failed to open input method\"));\nEXTERN char e_warning_could_not_set_destroy_callback_to_im[]\n\tINIT(= N_(\"E287: Warning: Could not set destroy callback to IM\"));\nEXTERN char e_input_method_doesnt_support_any_style[]\n\tINIT(= N_(\"E288: Input method doesn't support any style\"));\nEXTERN char e_input_method_doesnt_support_my_preedit_type[]\n\tINIT(= N_(\"E289: Input method doesn't support my preedit type\"));\n# endif\n#endif\n#ifdef FEAT_SEARCH_EXTRA\nEXTERN char e_list_or_number_required[]\n\tINIT(= N_(\"E290: List or number required\"));\n#endif\n// E291 unused\nEXTERN char e_invalid_count_for_del_bytes_nr[]\n\tINIT(= \"E292: Invalid count for del_bytes(): %ld\");\nEXTERN char e_block_was_not_locked[]\n\tINIT(= \"E293: Block was not locked\");\nEXTERN char e_seek_error_in_swap_file_read[]\n\tINIT(= N_(\"E294: Seek error in swap file read\"));\nEXTERN char e_read_error_in_swap_file[]\n\tINIT(= N_(\"E295: Read error in swap file\"));\nEXTERN char e_seek_error_in_swap_file_write[]\n\tINIT(= N_(\"E296: Seek error in swap file write\"));\nEXTERN char e_write_error_in_swap_file[]\n\tINIT(= N_(\"E297: Write error in swap file\"));\nEXTERN char e_didnt_get_block_nr_zero[]\n\tINIT(= \"E298: Didn't get block nr 0?\");\nEXTERN char e_didnt_get_block_nr_one[]\n\tINIT(= \"E298: Didn't get block nr 1?\");\nEXTERN char e_didnt_get_block_nr_two[]\n\tINIT(= \"E298: Didn't get block nr 2?\");\n#ifdef FEAT_PERL\nEXTERN char e_perl_evaluation_forbidden_in_sandbox_without_safe_module[]\n\tINIT(= N_(\"E299: Perl evaluation forbidden in sandbox without the Safe module\"));\n#endif\nEXTERN char e_swap_file_already_exists_symlink_attack[]\n\tINIT(= N_(\"E300: Swap file already exists (symlink attack?)\"));\nEXTERN char e_oops_lost_the_swap_file[]\n\tINIT(= N_(\"E301: Oops, lost the swap file!!!\"));\nEXTERN char e_could_not_rename_swap_file[]\n\tINIT(= N_(\"E302: Could not rename swap file\"));\nEXTERN char e_unable_to_open_swap_file_for_str_recovery_impossible[]\n\tINIT(= N_(\"E303: Unable to open swap file for \\\"%s\\\", recovery impossible\"));\nEXTERN char e_ml_upd_block0_didnt_get_block_zero[]\n\tINIT(= \"E304: ml_upd_block0(): Didn't get block 0??\");\nEXTERN char e_no_swap_file_found_for_str[]\n\tINIT(= N_(\"E305: No swap file found for %s\"));\nEXTERN char e_cannot_open_str[]\n\tINIT(= N_(\"E306: Cannot open %s\"));\nEXTERN char e_str_does_not_look_like_vim_swap_file[]\n\tINIT(= N_(\"E307: %s does not look like a Vim swap file\"));\nEXTERN char e_warning_original_file_may_have_been_changed[]\n\tINIT(= N_(\"E308: Warning: Original file may have been changed\"));\nEXTERN char e_unable_to_read_block_one_from_str[]\n\tINIT(= N_(\"E309: Unable to read block 1 from %s\"));\nEXTERN char e_block_one_id_wrong_str_not_swp_file[]\n\tINIT(= N_(\"E310: Block 1 ID wrong (%s not a .swp file?)\"));\nEXTERN char e_recovery_interrupted[]\n\tINIT(= N_(\"E311: Recovery Interrupted\"));\nEXTERN char e_errors_detected_while_recovering_look_for_lines_starting_with_questions[]\n\tINIT(= N_(\"E312: Errors detected while recovering; look for lines starting with ???\"));\nEXTERN char e_cannot_preserve_there_is_no_swap_file[]\n\tINIT(= N_(\"E313: Cannot preserve, there is no swap file\"));\nEXTERN char e_preserve_failed[]\n\tINIT(= N_(\"E314: Preserve failed\"));\nEXTERN char e_ml_get_invalid_lnum_nr[]\n\tINIT(= \"E315: ml_get: Invalid lnum: %ld\");\nEXTERN char e_ml_get_cannot_find_line_nr_in_buffer_nr_str[]\n\tINIT(= \"E316: ml_get: Cannot find line %ld in buffer %d %s\");\nEXTERN char e_pointer_block_id_wrong[]\n\tINIT(= \"E317: Pointer block id wrong\");\nEXTERN char e_pointer_block_id_wrong_two[]\n\tINIT(= \"E317: Pointer block id wrong 2\");\nEXTERN char e_pointer_block_id_wrong_three[]\n\tINIT(= \"E317: Pointer block id wrong 3\");\nEXTERN char e_pointer_block_id_wrong_four[]\n\tINIT(= \"E317: Pointer block id wrong 4\");\nEXTERN char e_updated_too_many_blocks[]\n\tINIT(= \"E318: Updated too many blocks?\");\nEXTERN char e_sorry_command_is_not_available_in_this_version[]\n\tINIT(= N_(\"E319: Sorry, the command is not available in this version\"));\nEXTERN char e_cannot_find_line_nr[]\n\tINIT(= \"E320: Cannot find line %ld\");\nEXTERN char e_could_not_reload_str[]\n\tINIT(= N_(\"E321: Could not reload \\\"%s\\\"\"));\nEXTERN char e_line_number_out_of_range_nr_past_the_end[]\n\tINIT(= \"E322: Line number out of range: %ld past the end\");\nEXTERN char e_line_count_wrong_in_block_nr[]\n\tINIT(= \"E323: Line count wrong in block %ld\");\n#ifdef FEAT_POSTSCRIPT\nEXTERN char e_cant_open_postscript_output_file[]\n\tINIT(= N_(\"E324: Can't open PostScript output file\"));\n#endif\nEXTERN char e_attention[]\n\tINIT(= N_(\"E325: ATTENTION\"));\nEXTERN char e_too_many_swap_files_found[]\n\tINIT(= N_(\"E326: Too many swap files found\"));\n#ifdef FEAT_MENU\nEXTERN char_u e_part_of_menu_item_path_is_not_sub_menu[]\n\tINIT(= N_(\"E327: Part of menu-item path is not sub-menu\"));\nEXTERN char e_menu_only_exists_in_another_mode[]\n\tINIT(= N_(\"E328: Menu only exists in another mode\"));\nEXTERN char_u e_no_menu_str[]\n\tINIT(= N_(\"E329: No menu \\\"%s\\\"\"));\nEXTERN char e_menu_path_must_not_lead_to_sub_menu[]\n\tINIT(= N_(\"E330: Menu path must not lead to a sub-menu\"));\nEXTERN char e_must_not_add_menu_items_directly_to_menu_bar[]\n\tINIT(= N_(\"E331: Must not add menu items directly to menu bar\"));\nEXTERN char e_separator_cannot_be_part_of_menu_path[]\n\tINIT(= N_(\"E332: Separator cannot be part of a menu path\"));\nEXTERN char e_menu_path_must_lead_to_menu_item[]\n\tINIT(= N_(\"E333: Menu path must lead to a menu item\"));\nEXTERN char e_menu_not_found_str[]\n\tINIT(= N_(\"E334: Menu not found: %s\"));\nEXTERN char e_menu_not_defined_for_str_mode[]\n\tINIT(= N_(\"E335: Menu not defined for %s mode\"));\nEXTERN char e_menu_path_must_lead_to_sub_menu[]\n\tINIT(= N_(\"E336: Menu path must lead to a sub-menu\"));\nEXTERN char e_menu_not_found_check_menu_names[]\n\tINIT(= N_(\"E337: Menu not found - check menu names\"));\n#endif\n#ifdef FEAT_BROWSE\nEXTERN char e_sorry_no_file_browser_in_console_mode[]\n\tINIT(= N_(\"E338: Sorry, no file browser in console mode\"));\n#endif\nEXTERN char e_pattern_too_long[]\n\tINIT(= N_(\"E339: Pattern too long\"));\nEXTERN char e_internal_error_please_report_a_bug[]\n\tINIT(= N_(\"E340: Internal error; if you can reproduce please report a bug\"));\nEXTERN char e_internal_error_lalloc_zero[]\n\tINIT(= \"E341: Internal error: lalloc(0, )\");\nEXTERN char e_out_of_memory_allocating_nr_bytes[]\n\tINIT(= N_(\"E342: Out of memory!  (allocating %lu bytes)\"));\nEXTERN char e_invalid_path_number_must_be_at_end_of_path_or_be_followed_by_str[]\n\tINIT(= N_(\"E343: Invalid path: '**[number]' must be at the end of the path or be followed by '%s'.\"));\nEXTERN char e_cant_find_directory_str_in_cdpath[]\n\tINIT(= N_(\"E344: Can't find directory \\\"%s\\\" in cdpath\"));\nEXTERN char e_cant_find_file_str_in_path[]\n\tINIT(= N_(\"E345: Can't find file \\\"%s\\\" in path\"));\nEXTERN char e_no_more_directory_str_found_in_cdpath[]\n\tINIT(= N_(\"E346: No more directory \\\"%s\\\" found in cdpath\"));\nEXTERN char e_no_more_file_str_found_in_path[]\n\tINIT(= N_(\"E347: No more file \\\"%s\\\" found in path\"));\nEXTERN char e_no_string_under_cursor[]\n\tINIT(= N_(\"E348: No string under cursor\"));\nEXTERN char e_no_identifier_under_cursor[]\n\tINIT(= N_(\"E349: No identifier under cursor\"));\n#ifdef FEAT_FOLDING\nEXTERN char e_cannot_create_fold_with_current_foldmethod[]\n\tINIT(= N_(\"E350: Cannot create fold with current 'foldmethod'\"));\nEXTERN char e_cannot_delete_fold_with_current_foldmethod[]\n\tINIT(= N_(\"E351: Cannot delete fold with current 'foldmethod'\"));\nEXTERN char e_cannot_erase_folds_with_current_foldmethod[]\n\tINIT(= N_(\"E352: Cannot erase folds with current 'foldmethod'\"));\n#endif\nEXTERN char e_nothing_in_register_str[]\n\tINIT(= N_(\"E353: Nothing in register %s\"));\nEXTERN char e_invalid_register_name_str[]\n\tINIT(= N_(\"E354: Invalid register name: '%s'\"));\nEXTERN char e_unknown_option_str_2[]\n\tINIT(= N_(\"E355: Unknown option: %s\"));\nEXTERN char e_get_varp_error[]\n\tINIT(= \"E356: get_varp ERROR\");\n#ifdef FEAT_LANGMAP\nEXTERN char e_langmap_matching_character_missing_for_str[]\n\tINIT(= N_(\"E357: 'langmap': Matching character missing for %s\"));\nEXTERN char e_langmap_extra_characters_after_semicolon_str[]\n\tINIT(= N_(\"E358: 'langmap': Extra characters after semicolon: %s\"));\n#endif\n#if defined(AMIGA) || defined(MACOS_X) || defined(MSWIN)  \\\n\t|| defined(UNIX) || defined(VMS)\nEXTERN char e_screen_mode_setting_not_supported[]\n\tINIT(= N_(\"E359: Screen mode setting not supported\"));\n#endif\n#ifdef AMIGA\nEXTERN char e_cannot_execute_shell_with_f_option[]\n\tINIT(= N_(\"E360: Cannot execute shell with -f option\"));\n#endif\n// E361 unused\n#if defined(FEAT_EVAL)\nEXTERN char e_using_boolean_value_as_float[]\n\tINIT(= N_(\"E362: Using a boolean value as a Float\"));\n#endif\nEXTERN char e_pattern_uses_more_memory_than_maxmempattern[]\n\tINIT(= N_(\"E363: Pattern uses more memory than 'maxmempattern'\"));\n#ifdef FEAT_LIBCALL\nEXTERN char e_library_call_failed_for_str[]\n\tINIT(= N_(\"E364: Library call failed for \\\"%s()\\\"\"));\n#endif\n#ifdef FEAT_POSTSCRIPT\nEXTERN char e_failed_to_print_postscript_file[]\n\tINIT(= N_(\"E365: Failed to print PostScript file\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_not_allowed_to_enter_popup_window[]\n\tINIT(= N_(\"E366: Not allowed to enter a popup window\"));\n#endif\nEXTERN char e_no_such_group_str[]\n\tINIT(= N_(\"E367: No such group: \\\"%s\\\"\"));\n#ifdef FEAT_LIBCALL\nEXTERN char e_got_sig_str_in_libcall[]\n\tINIT(= N_(\"E368: Got SIG%s in libcall()\"));\n#endif\nEXTERN char e_invalid_item_in_str_brackets[]\n\tINIT(= N_(\"E369: Invalid item in %s%%[]\"));\n#ifdef USING_LOAD_LIBRARY\nEXTERN char e_could_not_load_library_str_str[]\n\tINIT(= N_(\"E370: Could not load library %s: %s\"));\n#endif\n#ifdef FEAT_GUI_MSWIN\nEXTERN char e_command_not_found[]\n\tINIT(= N_(\"E371: Command not found\"));\n#endif\n#ifdef FEAT_QUICKFIX\nEXTERN char e_too_many_chr_in_format_string[]\n\tINIT(= N_(\"E372: Too many %%%c in format string\"));\nEXTERN char e_unexpected_chr_in_format_str[]\n\tINIT(= N_(\"E373: Unexpected %%%c in format string\"));\nEXTERN char e_missing_rsb_in_format_string[]\n\tINIT(= N_(\"E374: Missing ] in format string\"));\nEXTERN char e_unsupported_chr_in_format_string[]\n\tINIT(= N_(\"E375: Unsupported %%%c in format string\"));\nEXTERN char e_invalid_chr_in_format_string_prefix[]\n\tINIT(= N_(\"E376: Invalid %%%c in format string prefix\"));\nEXTERN char e_invalid_chr_in_format_string[]\n\tINIT(= N_(\"E377: Invalid %%%c in format string\"));\nEXTERN char e_errorformat_contains_no_pattern[]\n\tINIT(= N_(\"E378: 'errorformat' contains no pattern\"));\nEXTERN char e_missing_or_empty_directory_name[]\n\tINIT(= N_(\"E379: Missing or empty directory name\"));\nEXTERN char e_at_bottom_of_quickfix_stack[]\n\tINIT(= N_(\"E380: At bottom of quickfix stack\"));\nEXTERN char e_at_top_of_quickfix_stack[]\n\tINIT(= N_(\"E381: At top of quickfix stack\"));\n#endif\nEXTERN char e_cannot_write_buftype_option_is_set[]\n\tINIT(= N_(\"E382: Cannot write, 'buftype' option is set\"));\nEXTERN char e_invalid_search_string_str[]\n\tINIT(= N_(\"E383: Invalid search string: %s\"));\nEXTERN char e_search_hit_top_without_match_for_str[]\n\tINIT(= N_(\"E384: Search hit TOP without match for: %s\"));\nEXTERN char e_search_hit_bottom_without_match_for_str[]\n\tINIT(= N_(\"E385: Search hit BOTTOM without match for: %s\"));\nEXTERN char e_expected_question_or_slash_after_semicolon[]\n\tINIT(= N_(\"E386: Expected '?' or '/'  after ';'\"));\n#ifdef FEAT_FIND_ID\nEXTERN char e_match_is_on_current_line[]\n\tINIT(= N_(\"E387: Match is on current line\"));\nEXTERN char e_couldnt_find_definition[]\n\tINIT(= N_(\"E388: Couldn't find definition\"));\nEXTERN char e_couldnt_find_pattern[]\n\tINIT(= N_(\"E389: Couldn't find pattern\"));\n#endif\n#ifdef FEAT_SYN_HL\nEXTERN char e_illegal_argument_str_2[]\n\tINIT(= N_(\"E390: Illegal argument: %s\"));\nEXTERN char e_no_such_syntax_cluster_str_1[]\n\tINIT(= N_(\"E391: No such syntax cluster: %s\"));\nEXTERN char e_no_such_syntax_cluster_str_2[]\n\tINIT(= N_(\"E392: No such syntax cluster: %s\"));\nEXTERN char e_groupthere_not_accepted_here[]\n\tINIT(= N_(\"E393: group[t]here not accepted here\"));\nEXTERN char e_didnt_find_region_item_for_str[]\n\tINIT(= N_(\"E394: Didn't find region item for %s\"));\nEXTERN char e_contains_argument_not_accepted_here[]\n\tINIT(= N_(\"E395: Contains argument not accepted here\"));\n// E396 unused\nEXTERN char e_filename_required[]\n\tINIT(= N_(\"E397: Filename required\"));\nEXTERN char e_missing_equal_str[]\n\tINIT(= N_(\"E398: Missing '=': %s\"));\nEXTERN char e_not_enough_arguments_syntax_region_str[]\n\tINIT(= N_(\"E399: Not enough arguments: syntax region %s\"));\nEXTERN char e_no_cluster_specified[]\n\tINIT(= N_(\"E400: No cluster specified\"));\nEXTERN char e_pattern_delimiter_not_found_str[]\n\tINIT(= N_(\"E401: Pattern delimiter not found: %s\"));\nEXTERN char e_garbage_after_pattern_str[]\n\tINIT(= N_(\"E402: Garbage after pattern: %s\"));\nEXTERN char e_syntax_sync_line_continuations_pattern_specified_twice[]\n\tINIT(= N_(\"E403: syntax sync: Line continuations pattern specified twice\"));\nEXTERN char e_illegal_arguments_str[]\n\tINIT(= N_(\"E404: Illegal arguments: %s\"));\nEXTERN char e_missing_equal_sign_str[]\n\tINIT(= N_(\"E405: Missing equal sign: %s\"));\nEXTERN char e_empty_argument_str[]\n\tINIT(= N_(\"E406: Empty argument: %s\"));\nEXTERN char e_str_not_allowed_here[]\n\tINIT(= N_(\"E407: %s not allowed here\"));\nEXTERN char e_str_must_be_first_in_contains_list[]\n\tINIT(= N_(\"E408: %s must be first in contains list\"));\nEXTERN char e_unknown_group_name_str[]\n\tINIT(= N_(\"E409: Unknown group name: %s\"));\nEXTERN char e_invalid_syntax_subcommand_str[]\n\tINIT(= N_(\"E410: Invalid :syntax subcommand: %s\"));\n#endif\nEXTERN char e_highlight_group_name_not_found_str[]\n\tINIT(= N_(\"E411: Highlight group not found: %s\"));\nEXTERN char e_not_enough_arguments_highlight_link_str[]\n\tINIT(= N_(\"E412: Not enough arguments: \\\":highlight link %s\\\"\"));\nEXTERN char e_too_many_arguments_highlight_link_str[]\n\tINIT(= N_(\"E413: Too many arguments: \\\":highlight link %s\\\"\"));\nEXTERN char e_group_has_settings_highlight_link_ignored[]\n\tINIT(= N_(\"E414: Group has settings, highlight link ignored\"));\nEXTERN char e_unexpected_equal_sign_str[]\n\tINIT(= N_(\"E415: Unexpected equal sign: %s\"));\nEXTERN char e_missing_equal_sign_str_2[]\n\tINIT(= N_(\"E416: Missing equal sign: %s\"));\nEXTERN char e_missing_argument_str[]\n\tINIT(= N_(\"E417: Missing argument: %s\"));\nEXTERN char e_illegal_value_str[]\n\tINIT(= N_(\"E418: Illegal value: %s\"));\nEXTERN char e_im_a_teapot[]\n\tINIT(= N_(\"E418: I'm a teapot\"));\nEXTERN char e_fg_color_unknown[]\n\tINIT(= N_(\"E419: FG color unknown\"));\nEXTERN char e_bg_color_unknown[]\n\tINIT(= N_(\"E420: BG color unknown\"));\nEXTERN char e_color_name_or_number_not_recognized_str[]\n\tINIT(= N_(\"E421: Color name or number not recognized: %s\"));\nEXTERN char e_terminal_code_too_long_str[]\n\tINIT(= N_(\"E422: Terminal code too long: %s\"));\nEXTERN char e_illegal_argument_str_3[]\n\tINIT(= N_(\"E423: Illegal argument: %s\"));\nEXTERN char e_too_many_different_highlighting_attributes_in_use[]\n\tINIT(= N_(\"E424: Too many different highlighting attributes in use\"));\nEXTERN char e_cannot_go_before_first_matching_tag[]\n\tINIT(= N_(\"E425: Cannot go before first matching tag\"));\nEXTERN char e_tag_not_found_str[]\n\tINIT(= N_(\"E426: Tag not found: %s\"));\nEXTERN char e_there_is_only_one_matching_tag[]\n\tINIT(= N_(\"E427: There is only one matching tag\"));\nEXTERN char e_cannot_go_beyond_last_matching_tag[]\n\tINIT(= N_(\"E428: Cannot go beyond last matching tag\"));\nEXTERN char e_file_str_does_not_exist[]\n\tINIT(= N_(\"E429: File \\\"%s\\\" does not exist\"));\n#ifdef FEAT_EMACS_TAGS\nEXTERN char e_tag_file_path_truncated_for_str[]\n\tINIT(= N_(\"E430: Tag file path truncated for %s\\n\"));\n#endif\nEXTERN char e_format_error_in_tags_file_str[]\n\tINIT(= N_(\"E431: Format error in tags file \\\"%s\\\"\"));\nEXTERN char e_tags_file_not_sorted_str[]\n\tINIT(= N_(\"E432: Tags file not sorted: %s\"));\nEXTERN char e_no_tags_file[]\n\tINIT(= N_(\"E433: No tags file\"));\nEXTERN char e_cannot_find_tag_pattern[]\n\tINIT(= N_(\"E434: Can't find tag pattern\"));\nEXTERN char e_couldnt_find_tag_just_guessing[]\n\tINIT(= N_(\"E435: Couldn't find tag, just guessing!\"));\nEXTERN char e_no_str_entry_in_termcap[]\n\tINIT(= N_(\"E436: No \\\"%s\\\" entry in termcap\"));\nEXTERN char e_terminal_capability_cm_required[]\n\tINIT(= N_(\"E437: Terminal capability \\\"cm\\\" required\"));\nEXTERN char e_u_undo_line_numbers_wrong[]\n\tINIT(= \"E438: u_undo: Line numbers wrong\");\nEXTERN char e_undo_list_corrupt[]\n\tINIT(= \"E439: Undo list corrupt\");\nEXTERN char e_undo_line_missing[]\n\tINIT(= \"E440: Undo line missing\");\n#ifdef FEAT_QUICKFIX\nEXTERN char e_there_is_no_preview_window[]\n\tINIT(= N_(\"E441: There is no preview window\"));\n#endif\nEXTERN char e_cant_split_topleft_and_botright_at_the_same_time[]\n\tINIT(= N_(\"E442: Can't split topleft and botright at the same time\"));\nEXTERN char e_cannot_rotate_when_another_window_is_split[]\n\tINIT(= N_(\"E443: Cannot rotate when another window is split\"));\nEXTERN char e_cannot_close_last_window[]\n\tINIT(= N_(\"E444: Cannot close last window\"));\nEXTERN char e_other_window_contains_changes[]\n\tINIT(= N_(\"E445: Other window contains changes\"));\nEXTERN char e_no_file_name_under_cursor[]\n\tINIT(= N_(\"E446: No file name under cursor\"));\nEXTERN char e_cant_find_file_str_in_path_2[]\n\tINIT(= N_(\"E447: Can't find file \\\"%s\\\" in path\"));\n#ifdef USING_LOAD_LIBRARY\nEXTERN char e_could_not_load_library_function_str[]\n\tINIT(= N_(\"E448: Could not load library function %s\"));\n#endif\n#ifdef FEAT_CLIENTSERVER\nEXTERN char e_invalid_expression_received[]\n\tINIT(= N_(\"E449: Invalid expression received\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_buffer_number_text_or_list_required[]\n\tINIT(= N_(\"E450: Buffer number, text or a list required\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_expected_right_curly_str[]\n\tINIT(= N_(\"E451: Expected }: %s\"));\nEXTERN char e_double_semicolon_in_list_of_variables[]\n\tINIT(= N_(\"E452: Double ; in list of variables\"));\n#endif\nEXTERN char e_ul_color_unknown[]\n\tINIT(= N_(\"E453: UL color unknown\"));\n#ifdef FEAT_EVAL\nEXTERN char e_function_list_was_modified[]\n\tINIT(= N_(\"E454: Function list was modified\"));\n#endif\n#ifdef FEAT_POSTSCRIPT\nEXTERN char e_error_writing_to_postscript_output_file[]\n\tINIT(= N_(\"E455: Error writing to PostScript output file\"));\nEXTERN char e_cant_open_file_str_2[]\n\tINIT(= N_(\"E456: Can't open file \\\"%s\\\"\"));\nEXTERN char e_cant_find_postscript_resource_file_str_ps[]\n\tINIT(= N_(\"E456: Can't find PostScript resource file \\\"%s.ps\\\"\"));\nEXTERN char e_cant_read_postscript_resource_file_str[]\n\tINIT(= N_(\"E457: Can't read PostScript resource file \\\"%s\\\"\"));\n#endif\n#ifdef FEAT_GUI_X11\nEXTERN char e_cannot_allocate_colormap_entry_some_colors_may_be_incorrect[]\n\tINIT(= N_(\"E458: Cannot allocate colormap entry, some colors may be incorrect\"));\n#endif\n#if defined(UNIX) || defined(FEAT_SESSION)\nEXTERN char e_cannot_go_back_to_previous_directory[]\n\tINIT(= N_(\"E459: Cannot go back to previous directory\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_entries_missing_in_mapset_dict_argument[]\n\tINIT(= N_(\"E460: Entries missing in mapset() dict argument\"));\nEXTERN char e_illegal_variable_name_str[]\n\tINIT(= N_(\"E461: Illegal variable name: %s\"));\n#endif\nEXTERN char e_could_not_prepare_for_reloading_str[]\n\tINIT(= N_(\"E462: Could not prepare for reloading \\\"%s\\\"\"));\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_region_is_guarded_cannot_modify[]\n\tINIT(= N_(\"E463: Region is guarded, cannot modify\"));\n#endif\nEXTERN char e_ambiguous_use_of_user_defined_command[]\n\tINIT(= N_(\"E464: Ambiguous use of user-defined command\"));\n#ifdef FEAT_EVAL\nEXTERN char e_ambiguous_use_of_user_defined_command_str[]\n\tINIT(= N_(\"E464: Ambiguous use of user-defined command: %s\"));\n#endif\nEXTERN char e_winsize_requires_two_number_arguments[]\n\tINIT(= N_(\"E465: :winsize requires two number arguments\"));\nEXTERN char e_winpos_requires_two_number_arguments[]\n\tINIT(= N_(\"E466: :winpos requires two number arguments\"));\n#ifdef FEAT_EVAL\nEXTERN char e_custom_completion_requires_function_argument[]\n\tINIT(= N_(\"E467: Custom completion requires a function argument\"));\n#endif\nEXTERN char e_completion_argument_only_allowed_for_custom_completion[]\n\tINIT(= N_(\"E468: Completion argument only allowed for custom completion\"));\n#ifdef FEAT_CSCOPE\nEXTERN char e_invalid_cscopequickfix_flag_chr_for_chr[]\n\tINIT(= N_(\"E469: Invalid cscopequickfix flag %c for %c\"));\n#endif\nEXTERN char e_command_aborted[]\n\tINIT(= N_(\"E470: Command aborted\"));\nEXTERN char e_argument_required[]\n\tINIT(= N_(\"E471: Argument required\"));\nEXTERN char e_command_failed[]\n\tINIT(= N_(\"E472: Command failed\"));\nEXTERN char e_internal_error_in_regexp[]\n\tINIT(= \"E473: Internal error in regexp\");\nEXTERN char e_invalid_argument[]\n\tINIT(= N_(\"E474: Invalid argument\"));\nEXTERN char e_invalid_argument_str[]\n\tINIT(= N_(\"E475: Invalid argument: %s\"));\nEXTERN char e_invalid_value_for_argument_str[]\n\tINIT(= N_(\"E475: Invalid value for argument %s\"));\n#if defined(FEAT_JOB_CHANNEL) || defined(FEAT_PROP_POPUP) || defined(FEAT_EVAL)\nEXTERN char e_invalid_value_for_argument_str_str[]\n\tINIT(= N_(\"E475: Invalid value for argument %s: %s\"));\n#endif\nEXTERN char e_invalid_command[]\n\tINIT(= N_(\"E476: Invalid command\"));\nEXTERN char e_invalid_command_str[]\n\tINIT(= N_(\"E476: Invalid command: %s\"));\n#ifdef FEAT_EVAL\nEXTERN char e_invalid_command_str_expected_str[]\n\tINIT(= N_(\"E476: Invalid command: %s, expected %s\"));\n#endif\nEXTERN char e_no_bang_allowed[]\n\tINIT(= N_(\"E477: No ! allowed\"));\nEXTERN char e_dont_panic[]\n\tINIT(= N_(\"E478: Don't panic!\"));\nEXTERN char e_no_match[]\n\tINIT(= N_(\"E479: No match\"));\nEXTERN char e_no_match_str_2[]\n\tINIT(= N_(\"E480: No match: %s\"));\nEXTERN char e_no_range_allowed[]\n\tINIT(= N_(\"E481: No range allowed\"));\nEXTERN char e_cant_create_file_str[]\n\tINIT(= N_(\"E482: Can't create file %s\"));\nEXTERN char e_cant_get_temp_file_name[]\n\tINIT(= N_(\"E483: Can't get temp file name\"));\nEXTERN char e_cant_open_file_str[]\n\tINIT(= N_(\"E484: Can't open file %s\"));\nEXTERN char e_cant_read_file_str[]\n\tINIT(= N_(\"E485: Can't read file %s\"));\nEXTERN char e_pattern_not_found[]\n\tINIT(= N_(\"E486: Pattern not found\"));\nEXTERN char e_pattern_not_found_str[]\n\tINIT(= N_(\"E486: Pattern not found: %s\"));\nEXTERN char e_argument_must_be_positive[]\n\tINIT(= N_(\"E487: Argument must be positive\"));\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_argument_must_be_positive_str[]\n\tINIT(= N_(\"E487: Argument must be positive: %s\"));\n#endif\nEXTERN char e_trailing_characters[]\n\tINIT(= N_(\"E488: Trailing characters\"));\nEXTERN char e_trailing_characters_str[]\n\tINIT(= N_(\"E488: Trailing characters: %s\"));\nEXTERN char e_no_call_stack_to_substitute_for_stack[]\n\tINIT(= N_(\"E489: No call stack to substitute for \\\"<stack>\\\"\"));\n#ifdef FEAT_FOLDING\nEXTERN char e_no_fold_found[]\n\tINIT(= N_(\"E490: No fold found\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_json_decode_error_at_str[]\n\tINIT(= N_(\"E491: JSON decode error at '%s'\"));\n#endif\nEXTERN char e_not_an_editor_command[]\n\tINIT(= N_(\"E492: Not an editor command\"));\nEXTERN char e_backwards_range_given[]\n\tINIT(= N_(\"E493: Backwards range given\"));\nEXTERN char e_use_w_or_w_gt_gt[]\n\tINIT(= N_(\"E494: Use w or w>>\"));\nEXTERN char e_no_autocommand_file_name_to_substitute_for_afile[]\n\tINIT(= N_(\"E495: No autocommand file name to substitute for \\\"<afile>\\\"\"));\nEXTERN char e_no_autocommand_buffer_number_to_substitute_for_abuf[]\n\tINIT(= N_(\"E496: No autocommand buffer number to substitute for \\\"<abuf>\\\"\"));\nEXTERN char e_no_autocommand_match_name_to_substitute_for_amatch[]\n\tINIT(= N_(\"E497: No autocommand match name to substitute for \\\"<amatch>\\\"\"));\nEXTERN char e_no_source_file_name_to_substitute_for_sfile[]\n\tINIT(= N_(\"E498: No :source file name to substitute for \\\"<sfile>\\\"\"));\nEXTERN char e_empty_file_name_for_percent_or_hash_only_works_with_ph[]\n\t// xgettext:no-c-format\n\tINIT(= N_(\"E499: Empty file name for '%' or '#', only works with \\\":p:h\\\"\"));\nEXTERN char e_evaluates_to_an_empty_string[]\n\tINIT(= N_(\"E500: Evaluates to an empty string\"));\nEXTERN char e_at_end_of_file[]\n\tINIT(= N_(\"E501: At end-of-file\"));\n\t// E502\nEXTERN char e_is_a_directory[]\n\tINIT(= N_(\"is a directory\"));\n\t// E503\nEXTERN char e_is_not_file_or_writable_device[]\n\tINIT(= N_(\"is not a file or writable device\"));\nEXTERN char e_str_is_not_file_or_writable_device[]\n\tINIT(= N_(\"E503: \\\"%s\\\" is not a file or writable device\"));\nEXTERN char e_coffee_currently_not_available[]\n\tINIT(= N_(\"E503: Coffee is currently not available\"));\n\t// E504\nEXTERN char e_is_read_only_cannot_override_W_in_cpoptions[]\n\tINIT(= N_(\"is read-only (cannot override: \\\"W\\\" in 'cpoptions')\"));\n\t// E505\nEXTERN char e_is_read_only_add_bang_to_override[]\n\tINIT(= N_(\"is read-only (add ! to override)\"));\nEXTERN char e_str_is_read_only_add_bang_to_override[]\n\tINIT(= N_(\"E505: \\\"%s\\\" is read-only (add ! to override)\"));\nEXTERN char e_cant_write_to_backup_file_add_bang_to_override[]\n\tINIT(= N_(\"E506: Can't write to backup file (add ! to override)\"));\nEXTERN char e_close_error_for_backup_file_add_bang_to_write_anyway[]\n\tINIT(= N_(\"E507: Close error for backup file (add ! to write anyway)\"));\nEXTERN char e_cant_read_file_for_backup_add_bang_to_write_anyway[]\n\tINIT(= N_(\"E508: Can't read file for backup (add ! to write anyway)\"));\nEXTERN char e_cannot_create_backup_file_add_bang_to_write_anyway[]\n\tINIT(= N_(\"E509: Cannot create backup file (add ! to override)\"));\nEXTERN char e_cant_make_backup_file_add_bang_to_write_anyway[]\n\tINIT(= N_(\"E510: Can't make backup file (add ! to write anyway)\"));\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_netbeans_already_connected[]\n\tINIT(= N_(\"E511: NetBeans already connected\"));\n#endif\nEXTERN char e_close_failed[]\n\tINIT(= N_(\"E512: Close failed\"));\nEXTERN char e_write_error_conversion_failed_make_fenc_empty_to_override[]\n\tINIT(= N_(\"E513: Write error, conversion failed (make 'fenc' empty to override)\"));\nEXTERN char e_write_error_conversion_failed_in_line_nr_make_fenc_empty_to_override[]\n\tINIT(= N_(\"E513: Write error, conversion failed in line %ld (make 'fenc' empty to override)\"));\nEXTERN char e_write_error_file_system_full[]\n\tINIT(= N_(\"E514: Write error (file system full?)\"));\nEXTERN char e_no_buffers_were_unloaded[]\n\tINIT(= N_(\"E515: No buffers were unloaded\"));\nEXTERN char e_no_buffers_were_deleted[]\n\tINIT(= N_(\"E516: No buffers were deleted\"));\nEXTERN char e_no_buffers_were_wiped_out[]\n\tINIT(= N_(\"E517: No buffers were wiped out\"));\nEXTERN char e_unknown_option[]\n\tINIT(= N_(\"E518: Unknown option\"));\nEXTERN char e_option_not_supported[]\n\tINIT(= N_(\"E519: Option not supported\"));\nEXTERN char e_not_allowed_in_modeline[]\n\tINIT(= N_(\"E520: Not allowed in a modeline\"));\nEXTERN char e_number_required_after_equal[]\n\tINIT(= N_(\"E521: Number required after =\"));\nEXTERN char e_number_required_after_str_equal_str[]\n\tINIT(= N_(\"E521: Number required: &%s = '%s'\"));\nEXTERN char e_not_found_in_termcap[]\n\tINIT(= N_(\"E522: Not found in termcap\"));\nEXTERN char e_not_allowed_here[]\n\tINIT(= N_(\"E523: Not allowed here\"));\nEXTERN char e_missing_colon[]\n\tINIT(= N_(\"E524: Missing colon\"));\nEXTERN char e_zero_length_string[]\n\tINIT(= N_(\"E525: Zero length string\"));\n#ifdef FEAT_VIMINFO\nEXTERN char e_missing_number_after_angle_str_angle[]\n\tINIT(= N_(\"E526: Missing number after <%s>\"));\nEXTERN char e_missing_comma[]\n\tINIT(= N_(\"E527: Missing comma\"));\nEXTERN char e_must_specify_a_value[]\n\tINIT(= N_(\"E528: Must specify a ' value\"));\n#endif\nEXTERN char e_cannot_set_term_to_empty_string[]\n\tINIT(= N_(\"E529: Cannot set 'term' to empty string\"));\n#ifdef FEAT_GUI\nEXTERN char e_cannot_change_term_in_GUI[]\n\tINIT(= N_(\"E530: Cannot change 'term' in the GUI\"));\nEXTERN char e_use_gui_to_start_GUI[]\n\tINIT(= N_(\"E531: Use \\\":gui\\\" to start the GUI\"));\n#endif\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_highlighting_color_name_too_long_in_defineAnnoType[]\n\tINIT(= N_(\"E532: Highlighting color name too long in defineAnnoType\"));\n#endif\n#ifdef FEAT_GUI\nEXTERN char e_cant_select_wide_font[]\n\tINIT(= N_(\"E533: Can't select wide font\"));\nEXTERN char e_invalid_wide_font[]\n\tINIT(= N_(\"E534: Invalid wide font\"));\n#endif\nEXTERN char e_illegal_character_after_chr[]\n\tINIT(= N_(\"E535: Illegal character after <%c>\"));\n#ifdef FEAT_FOLDING\nEXTERN char e_comma_required[]\n\tINIT(= N_(\"E536: Comma required\"));\nEXTERN char e_commentstring_must_be_empty_or_contain_str[]\n\tINIT(= N_(\"E537: 'commentstring' must be empty or contain %s\"));\n#endif\nEXTERN char e_pattern_found_in_every_line_str[]\n\tINIT(= N_(\"E538: Pattern found in every line: %s\"));\nEXTERN char e_illegal_character_str[]\n\tINIT(= N_(\"E539: Illegal character <%s>\"));\n#ifdef FEAT_STL_OPT\nEXTERN char e_unclosed_expression_sequence[]\n\tINIT(= N_(\"E540: Unclosed expression sequence\"));\n// E541 unused\nEXTERN char e_unbalanced_groups[]\n\tINIT(= N_(\"E542: Unbalanced groups\"));\n#endif\n#ifdef MSWIN\nEXTERN char e_not_valid_codepage[]\n\tINIT(= N_(\"E543: Not a valid codepage\"));\n#endif\n#ifdef FEAT_KEYMAP\nEXTERN char e_keymap_file_not_found[]\n\tINIT(= N_(\"E544: Keymap file not found\"));\n#endif\n#ifdef CURSOR_SHAPE\nEXTERN char e_missing_colon_2[]\n\tINIT(= N_(\"E545: Missing colon\"));\nEXTERN char e_illegal_mode[]\n\tINIT(= N_(\"E546: Illegal mode\"));\n#endif\n#ifdef FEAT_MOUSESHAPE\nEXTERN char e_illegal_mouseshape[]\n\tINIT(= N_(\"E547: Illegal mouseshape\"));\n#endif\n#ifdef CURSOR_SHAPE\nEXTERN char e_digit_expected[]\n\tINIT(= N_(\"E548: Digit expected\"));\nEXTERN char e_illegal_percentage[]\n\tINIT(= N_(\"E549: Illegal percentage\"));\n#endif\n#ifdef FEAT_PRINTER\nEXTERN char e_missing_colon_3[]\n\tINIT(= N_(\"E550: Missing colon\"));\nEXTERN char e_illegal_component[]\n\tINIT(= N_(\"E551: Illegal component\"));\nEXTERN char e_digit_expected_2[]\n\tINIT(= N_(\"E552: Digit expected\"));\n#endif\n#ifdef FEAT_QUICKFIX\nEXTERN char e_no_more_items[]\n\tINIT(= N_(\"E553: No more items\"));\n#endif\nEXTERN char e_syntax_error_in_str_curlies[]\n\tINIT(= N_(\"E554: Syntax error in %s{...}\"));\nEXTERN char e_at_bottom_of_tag_stack[]\n\tINIT(= N_(\"E555: At bottom of tag stack\"));\nEXTERN char e_at_top_of_tag_stack[]\n\tINIT(= N_(\"E556: At top of tag stack\"));\nEXTERN char e_cannot_open_termcap_file[]\n\tINIT(= N_(\"E557: Cannot open termcap file\"));\nEXTERN char e_terminal_entry_not_found_in_terminfo[]\n\tINIT(= N_(\"E558: Terminal entry not found in terminfo\"));\n#if defined(HAVE_TGETENT) && !defined(TERMINFO)\nEXTERN char e_terminal_entry_not_found_in_termcap[]\n\tINIT(= N_(\"E559: Terminal entry not found in termcap\"));\n#endif\n#ifdef FEAT_CSCOPE\nEXTERN char e_usage_cscope_str[]\n\tINIT(= N_(\"E560: Usage: cs[cope] %s\"));\nEXTERN char e_unknown_cscope_search_type[]\n\tINIT(= N_(\"E561: Unknown cscope search type\"));\nEXTERN char e_usage_cstag_ident[]\n\tINIT(= N_(\"E562: Usage: cstag <ident>\"));\nEXTERN char e_stat_str_error_nr[]\n\tINIT(= N_(\"E563: stat(%s) error: %d\"));\nEXTERN char e_str_is_not_directory_or_valid_cscope_database[]\n\tINIT(= N_(\"E564: %s is not a directory or a valid cscope database\"));\n#endif\nEXTERN char e_not_allowed_to_change_text_or_change_window[]\n\tINIT(= N_(\"E565: Not allowed to change text or change window\"));\n#ifdef FEAT_CSCOPE\nEXTERN char e_could_not_create_cscope_pipes[]\n\tINIT(= N_(\"E566: Could not create cscope pipes\"));\nEXTERN char e_no_cscope_connections[]\n\tINIT(= N_(\"E567: No cscope connections\"));\nEXTERN char e_duplicate_cscope_database_not_added[]\n\tINIT(= N_(\"E568: Duplicate cscope database not added\"));\n// E569 unused\nEXTERN char e_fatal_error_in_cs_manage_matches[]\n\tINIT(= \"E570: Fatal error in cs_manage_matches\");\n#endif\n#ifdef DYNAMIC_TCL\nEXTERN char e_sorry_this_command_is_disabled_tcl_library_could_not_be_loaded[]\n\tINIT(= N_(\"E571: Sorry, this command is disabled: the Tcl library could not be loaded.\"));\n#endif\n#ifdef FEAT_TCL\nEXTERN char e_exit_code_nr[]\n\tINIT(= N_(\"E572: Exit code %d\"));\n#endif\n#ifdef FEAT_CLIENTSERVER\nEXTERN char e_invalid_server_id_used_str[]\n\tINIT(= N_(\"E573: Invalid server id used: %s\"));\n#endif\n#ifdef FEAT_VIMINFO\nEXTERN char e_unknown_register_type_nr[]\n\tINIT(= N_(\"E574: Unknown register type %d\"));\n\t// E575\nEXTERN char e_illegal_starting_char[]\n\tINIT(= N_(\"Illegal starting char\"));\n\t// E576\nEXTERN char e_nonr_missing_gt[]\n\tINIT(= N_(\"Missing '>'\"));\n\t// E577\nEXTERN char e_illegal_register_name[]\n\tINIT(= N_(\"Illegal register name\"));\n#endif\n// E578 unused\n#ifdef FEAT_EVAL\nEXTERN char e_if_nesting_too_deep[]\n\tINIT(= N_(\"E579: :if nesting too deep\"));\nEXTERN char e_block_nesting_too_deep[]\n\tINIT(= N_(\"E579: Block nesting too deep\"));\nEXTERN char e_endif_without_if[]\n\tINIT(= N_(\"E580: :endif without :if\"));\nEXTERN char e_else_without_if[]\n\tINIT(= N_(\"E581: :else without :if\"));\nEXTERN char e_elseif_without_if[]\n\tINIT(= N_(\"E582: :elseif without :if\"));\nEXTERN char e_multiple_else[]\n\tINIT(= N_(\"E583: Multiple :else\"));\nEXTERN char e_elseif_after_else[]\n\tINIT(= N_(\"E584: :elseif after :else\"));\nEXTERN char e_while_for_nesting_too_deep[]\n\tINIT(= N_(\"E585: :while/:for nesting too deep\"));\nEXTERN char e_continue_without_while_or_for[]\n\tINIT(= N_(\"E586: :continue without :while or :for\"));\nEXTERN char e_break_without_while_or_for[]\n\tINIT(= N_(\"E587: :break without :while or :for\"));\nEXTERN char e_endwhile_without_while[]\n\tINIT(= N_(\"E588: :endwhile without :while\"));\nEXTERN char e_endfor_without_for[]\n\tINIT(= N_(\"E588: :endfor without :for\"));\n#endif\nEXTERN char e_backupext_and_patchmode_are_equal[]\n\tINIT(= N_(\"E589: 'backupext' and 'patchmode' are equal\"));\n#ifdef FEAT_QUICKFIX\nEXTERN char e_preview_window_already_exists[]\n\tINIT(= N_(\"E590: A preview window already exists\"));\n#endif\nEXTERN char e_winheight_cannot_be_smaller_than_winminheight[]\n\tINIT(= N_(\"E591: 'winheight' cannot be smaller than 'winminheight'\"));\nEXTERN char e_winwidth_cannot_be_smaller_than_winminwidth[]\n\tINIT(= N_(\"E592: 'winwidth' cannot be smaller than 'winminwidth'\"));\nEXTERN char e_need_at_least_nr_lines[]\n\tINIT(= N_(\"E593: Need at least %d lines\"));\nEXTERN char e_need_at_least_nr_columns[]\n\tINIT(= N_(\"E594: Need at least %d columns\"));\n#ifdef FEAT_LINEBREAK\nEXTERN char e_showbreak_contains_unprintable_or_wide_character[]\n\tINIT(= N_(\"E595: 'showbreak' contains unprintable or wide character\"));\n#endif\n#ifdef FEAT_GUI\nEXTERN char e_invalid_fonts[]\n\tINIT(= N_(\"E596: Invalid font(s)\"));\n# ifdef FEAT_XFONTSET\nEXTERN char e_cant_select_fontset[]\n\tINIT(= N_(\"E597: Can't select fontset\"));\nEXTERN char e_invalid_fontset[]\n\tINIT(= N_(\"E598: Invalid fontset\"));\n# endif\n#endif\n#if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)\nEXTERN char e_value_of_imactivatekey_is_invalid[]\n\tINIT(= N_(\"E599: Value of 'imactivatekey' is invalid\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_missing_endtry[]\n\tINIT(= N_(\"E600: Missing :endtry\"));\nEXTERN char e_try_nesting_too_deep[]\n\tINIT(= N_(\"E601: :try nesting too deep\"));\nEXTERN char e_endtry_without_try[]\n\tINIT(= N_(\"E602: :endtry without :try\"));\nEXTERN char e_catch_without_try[]\n\tINIT(= N_(\"E603: :catch without :try\"));\nEXTERN char e_catch_after_finally[]\n\tINIT(= N_(\"E604: :catch after :finally\"));\nEXTERN char e_exception_not_caught_str[]\n\tINIT(= N_(\"E605: Exception not caught: %s\"));\nEXTERN char e_finally_without_try[]\n\tINIT(= N_(\"E606: :finally without :try\"));\nEXTERN char e_multiple_finally[]\n\tINIT(= N_(\"E607: Multiple :finally\"));\nEXTERN char e_cannot_throw_exceptions_with_vim_prefix[]\n\tINIT(= N_(\"E608: Cannot :throw exceptions with 'Vim' prefix\"));\n#endif\n#ifdef FEAT_CSCOPE\nEXTERN char e_cscope_error_str[]\n\tINIT(= N_(\"E609: Cscope error: %s\"));\n#endif\nEXTERN char e_no_argument_to_delete[]\n\tINIT(= N_(\"E610: No argument to delete\"));\n#ifdef FEAT_EVAL\nEXTERN char e_using_special_as_number[]\n\tINIT(= N_(\"E611: Using a Special as a Number\"));\n#endif\n#ifdef FEAT_SIGNS\nEXTERN char e_too_many_signs_defined[]\n\tINIT(= N_(\"E612: Too many signs defined\"));\n#endif\n#if defined(MSWIN) && defined(FEAT_PRINTER)\nEXTERN char e_unknown_printer_font_str[]\n\tINIT(= N_(\"E613: Unknown printer font: %s\"));\n#endif\nEXTERN char e_class_required[]\n\tINIT(= N_(\"E614: Class required\"));\n// E615 unused\nEXTERN char e_object_required_for_argument_nr[]\n\tINIT(= N_(\"E616: Object required for argument %d\"));\n#ifdef FEAT_GUI_GTK\nEXTERN char e_cannot_be_changed_in_gtk_GUI[]\n\tINIT(= N_(\"E617: Cannot be changed in the GTK GUI\"));\n#endif\n#ifdef FEAT_POSTSCRIPT\nEXTERN char e_file_str_is_not_postscript_resource_file[]\n\tINIT(= N_(\"E618: File \\\"%s\\\" is not a PostScript resource file\"));\nEXTERN char e_file_str_is_not_supported_postscript_resource_file[]\n\tINIT(= N_(\"E619: File \\\"%s\\\" is not a supported PostScript resource file\"));\nEXTERN char e_unable_to_convert_to_print_encoding_str[]\n\tINIT(= N_(\"E620: Unable to convert to print encoding \\\"%s\\\"\"));\nEXTERN char e_str_resource_file_has_wrong_version[]\n\tINIT(= N_(\"E621: \\\"%s\\\" resource file has wrong version\"));\n#endif\n#ifdef FEAT_CSCOPE\nEXTERN char e_could_not_fork_for_cscope[]\n\tINIT(= N_(\"E622: Could not fork for cscope\"));\n# ifndef UNIX\nEXTERN char e_could_not_spawn_cscope_process[]\n\tINIT(= N_(\"E623: Could not spawn cscope process\"));\n# endif\n#endif\n#if defined(FEAT_PRINTER) && defined(FEAT_POSTSCRIPT)\nEXTERN char e_cant_open_file_str_3[]\n\tINIT(= N_(\"E624: Can't open file \\\"%s\\\"\"));\n#endif\n#if defined(FEAT_CSCOPE) && !defined(UNIX)\nEXTERN char e_cannot_open_cscope_database_str[]\n\tINIT(= N_(\"E625: Cannot open cscope database: %s\"));\nEXTERN char e_cannot_get_cscope_database_information[]\n\tINIT(= N_(\"E626: Cannot get cscope database information\"));\n#endif\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_missing_colon_str[]\n\tINIT(= N_(\"E627: Missing colon: %s\"));\nEXTERN char e_missing_bang_or_slash_in_str[]\n\tINIT(= N_(\"E628: Missing ! or / in: %s\"));\n#ifdef NBDEBUG\nEXTERN char e_bad_return_from_nb_do_cmd[]\n\tINIT(= \"E629: Bad return from nb_do_cmd\");\n#endif\n#endif\n#ifdef FEAT_JOB_CHANNEL\nEXTERN char e_str_write_while_not_connected[]\n\tINIT(= N_(\"E630: %s(): Write while not connected\"));\nEXTERN char e_str_write_failed[]\n\tINIT(= N_(\"E631: %s(): Write failed\"));\n#endif\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_invalid_buffer_identifier_in_getlength[]\n\tINIT(= N_(\"E632: Invalid buffer identifier in getLength\"));\nEXTERN char e_invalid_buffer_identifier_in_gettext[]\n\tINIT(= N_(\"E633: Invalid buffer identifier in getText\"));\nEXTERN char e_invalid_buffer_identifier_in_remove[]\n\tINIT(= N_(\"E634: Invalid buffer identifier in remove\"));\nEXTERN char e_invalid_buffer_identifier_in_insert[]\n\tINIT(= N_(\"E635: Invalid buffer identifier in insert\"));\nEXTERN char e_invalid_buffer_identifier_in_create[]\n\tINIT(= N_(\"E636: Invalid buffer identifier in create\"));\nEXTERN char e_invalid_buffer_identifier_in_startdocumentlisten[]\n\tINIT(= N_(\"E637: Invalid buffer identifier in startDocumentListen\"));\nEXTERN char e_invalid_buffer_identifier_in_stopdocumentlisten[]\n\tINIT(= N_(\"E638: Invalid buffer identifier in stopDocumentListen\"));\nEXTERN char e_invalid_buffer_identifier_in_settitle[]\n\tINIT(= N_(\"E639: Invalid buffer identifier in setTitle\"));\nEXTERN char e_invalid_buffer_identifier_in_initdone[]\n\tINIT(= N_(\"E640: Invalid buffer identifier in initDone\"));\nEXTERN char e_invalid_buffer_identifier_in_setbuffernumber[]\n\tINIT(= N_(\"E641: Invalid buffer identifier in setBufferNumber\"));\nEXTERN char e_file_str_not_found_in_setbuffernumber[]\n\tINIT(= N_(\"E642: File %s not found in setBufferNumber\"));\nEXTERN char e_invalid_buffer_identifier_in_setfullname[]\n\tINIT(= N_(\"E643: Invalid buffer identifier in setFullName\"));\nEXTERN char e_invalid_buffer_identifier_in_editfile[]\n\tINIT(= N_(\"E644: Invalid buffer identifier in editFile\"));\nEXTERN char e_invalid_buffer_identifier_in_setvisible[]\n\tINIT(= N_(\"E645: Invalid buffer identifier in setVisible\"));\nEXTERN char e_invalid_buffer_identifier_in_setmodified[]\n\tINIT(= N_(\"E646: Invalid buffer identifier in setModified\"));\nEXTERN char e_invalid_buffer_identifier_in_setdot[]\n\tINIT(= N_(\"E647: Invalid buffer identifier in setDot\"));\nEXTERN char e_invalid_buffer_identifier_in_close[]\n\tINIT(= N_(\"E648: Invalid buffer identifier in close\"));\nEXTERN char e_invalid_buffer_identifier_in_close_2[]\n\tINIT(= N_(\"E649: Invalid buffer identifier in close\"));\nEXTERN char e_invalid_buffer_identifier_in_defineannotype[]\n\tINIT(= N_(\"E650: Invalid buffer identifier in defineAnnoType\"));\nEXTERN char e_invalid_buffer_identifier_in_addanno[]\n\tINIT(= N_(\"E651: Invalid buffer identifier in addAnno\"));\nEXTERN char e_invalid_buffer_identifier_in_getanno[]\n\tINIT(= N_(\"E652: Invalid buffer identifier in getAnno\"));\n#endif\n// E653 unused\nEXTERN char e_missing_delimiter_after_search_pattern_str[]\n\tINIT(= N_(\"E654: Missing delimiter after search pattern: %s\"));\n#ifdef FEAT_EVAL\nEXTERN char e_too_many_symbolic_links_cycle[]\n\tINIT(= N_(\"E655: Too many symbolic links (cycle?)\"));\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t// E656\nEXTERN char e_netbeans_disallows_writes_of_unmodified_buffers[]\n\tINIT(= N_(\"NetBeans disallows writes of unmodified buffers\"));\n\t// E657\nEXTERN char e_partial_writes_disallowed_for_netbeans_buffers[]\n\tINIT(= N_(\"Partial writes disallowed for NetBeans buffers\"));\nEXTERN char e_netbeans_connection_lost_for_buffer_nr[]\n\tINIT(= N_(\"E658: NetBeans connection lost for buffer %d\"));\n#endif\n#ifdef FEAT_PYTHON\nEXTERN char e_cannot_invoke_python_recursively[]\n\tINIT(= N_(\"E659: Cannot invoke Python recursively\"));\n#endif\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_cannot_open_netbeans_connection_info_file[]\n\tINIT(= \"E660: Cannot open NetBeans connection info file\");\n#endif\n#ifdef FEAT_MULTI_LANG\nEXTERN char e_sorry_no_str_help_for_str[]\n\tINIT(= N_(\"E661: Sorry, no '%s' help for %s\"));\n#endif\nEXTERN char e_at_start_of_changelist[]\n\tINIT(= N_(\"E662: At start of changelist\"));\nEXTERN char e_at_end_of_changelist[]\n\tINIT(= N_(\"E663: At end of changelist\"));\nEXTERN char e_changelist_is_empty[]\n\tINIT(= N_(\"E664: Changelist is empty\"));\n#ifdef FEAT_GUI\nEXTERN char e_cannot_start_gui_no_valid_font_found[]\n\tINIT(= N_(\"E665: Cannot start GUI, no valid font found\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_compiler_not_supported_str[]\n\tINIT(= N_(\"E666: Compiler not supported: %s\"));\n#endif\n#ifdef HAVE_FSYNC\nEXTERN char e_fsync_failed[]\n\tINIT(= N_(\"E667: Fsync failed\"));\n#endif\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_wrong_access_mode_for_netbeans_connection_info_file_str[]\n\tINIT(= N_(\"E668: Wrong access mode for NetBeans connection info file: \\\"%s\\\"\"));\n#endif\nEXTERN char e_unprintable_character_in_group_name[]\n\tINIT(= N_(\"E669: Unprintable character in group name\"));\nEXTERN char e_mix_of_help_file_encodings_within_language_str[]\n\tINIT(= N_(\"E670: Mix of help file encodings within a language: %s\"));\n#ifdef FEAT_GUI_MSWIN\nEXTERN char e_cannot_find_window_title_str[]\n\tINIT(= N_(\"E671: Cannot find window title \\\"%s\\\"\"));\nEXTERN char e_unable_to_open_window_inside_mdi_application[]\n\tINIT(= N_(\"E672: Unable to open window inside MDI application\"));\n#endif\n#if defined(FEAT_PRINTER) && defined(FEAT_POSTSCRIPT)\nEXTERN char e_incompatible_multi_byte_encoding_and_character_set[]\n\tINIT(= N_(\"E673: Incompatible multi-byte encoding and character set\"));\nEXTERN char e_printmbcharset_cannot_be_empty_with_multi_byte_encoding[]\n\tINIT(= N_(\"E674: printmbcharset cannot be empty with multi-byte encoding.\"));\nEXTERN char e_no_default_font_specified_for_multi_byte_printing[]\n\tINIT(= N_(\"E675: No default font specified for multi-byte printing.\"));\n#endif\nEXTERN char e_no_matching_autocommands_for_buftype_str_buffer[]\n\tINIT(= N_(\"E676: No matching autocommands for buftype=%s buffer\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_error_writing_temp_file[]\n\tINIT(= N_(\"E677: Error writing temp file\"));\n#endif\nEXTERN char e_invalid_character_after_str_2[]\n\tINIT(= N_(\"E678: Invalid character after %s%%[dxouU]\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_recursive_loop_loading_syncolor_vim[]\n\tINIT(= N_(\"E679: Recursive loop loading syncolor.vim\"));\n#endif\nEXTERN char e_buffer_nr_invalid_buffer_number[]\n\tINIT(= N_(\"E680: <buffer=%d>: invalid buffer number\"));\n#ifdef FEAT_QUICKFIX\nEXTERN char e_buffer_is_not_loaded[]\n\tINIT(= N_(\"E681: Buffer is not loaded\"));\nEXTERN char e_invalid_search_pattern_or_delimiter[]\n\tINIT(= N_(\"E682: Invalid search pattern or delimiter\"));\nEXTERN char e_file_name_missing_or_invalid_pattern[]\n\tINIT(= N_(\"E683: File name missing or invalid pattern\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_list_index_out_of_range_nr[]\n\tINIT(= N_(\"E684: List index out of range: %ld\"));\n#endif\nEXTERN char e_internal_error_str[]\n\tINIT(= N_(\"E685: Internal error: %s\"));\n#ifdef FEAT_EVAL\nEXTERN char e_argument_of_str_must_be_list[]\n\tINIT(= N_(\"E686: Argument of %s must be a List\"));\nEXTERN char e_less_targets_than_list_items[]\n\tINIT(= N_(\"E687: Less targets than List items\"));\nEXTERN char e_more_targets_than_list_items[]\n\tINIT(= N_(\"E688: More targets than List items\"));\nEXTERN char e_index_not_allowed_after_str_str[]\n\tINIT(= N_(\"E689: Index not allowed after a %s: %s\"));\nEXTERN char e_missing_in_after_for[]\n\tINIT(= N_(\"E690: Missing \\\"in\\\" after :for\"));\nEXTERN char e_can_only_compare_list_with_list[]\n\tINIT(= N_(\"E691: Can only compare List with List\"));\nEXTERN char e_invalid_operation_for_list[]\n\tINIT(= N_(\"E692: Invalid operation for List\"));\nEXTERN char e_list_or_class_required_for_argument_nr[]\n\tINIT(= N_(\"E693: List or Class required for argument %d\"));\nEXTERN char e_invalid_operation_for_funcrefs[]\n\tINIT(= N_(\"E694: Invalid operation for Funcrefs\"));\nEXTERN char e_cannot_index_a_funcref[]\n\tINIT(= N_(\"E695: Cannot index a Funcref\"));\nEXTERN char e_missing_comma_in_list_str[]\n\tINIT(= N_(\"E696: Missing comma in List: %s\"));\nEXTERN char e_missing_end_of_list_rsb_str[]\n\tINIT(= N_(\"E697: Missing end of List ']': %s\"));\nEXTERN char e_variable_nested_too_deep_for_making_copy[]\n\tINIT(= N_(\"E698: Variable nested too deep for making a copy\"));\nEXTERN char e_too_many_arguments[]\n\tINIT(= N_(\"E699: Too many arguments\"));\nEXTERN char e_unknown_function_str_2[]\n\tINIT(= N_(\"E700: Unknown function: %s\"));\nEXTERN char e_invalid_type_for_len[]\n\tINIT(= N_(\"E701: Invalid type for len()\"));\nEXTERN char e_sort_compare_function_failed[]\n\tINIT(= N_(\"E702: Sort compare function failed\"));\nEXTERN char e_using_funcref_as_number[]\n\tINIT(= N_(\"E703: Using a Funcref as a Number\"));\nEXTERN char e_funcref_variable_name_must_start_with_capital_str[]\n\tINIT(= N_(\"E704: Funcref variable name must start with a capital: %s\"));\nEXTERN char e_variable_name_conflicts_with_existing_function_str[]\n\tINIT(= N_(\"E705: Variable name conflicts with existing function: %s\"));\nEXTERN char e_argument_of_str_must_be_list_string_or_dictionary[]\n\tINIT(= N_(\"E706: Argument of %s must be a List, String or Dictionary\"));\nEXTERN char e_function_name_conflicts_with_variable_str[]\n\tINIT(= N_(\"E707: Function name conflicts with variable: %s\"));\nEXTERN char e_slice_must_come_last[]\n\tINIT(= N_(\"E708: [:] must come last\"));\nEXTERN char e_slice_requires_list_or_blob_value[]\n\tINIT(= N_(\"E709: [:] requires a List or Blob value\"));\nEXTERN char e_list_value_has_more_items_than_targets[]\n\tINIT(= N_(\"E710: List value has more items than targets\"));\nEXTERN char e_list_value_does_not_have_enough_items[]\n\tINIT(= N_(\"E711: List value does not have enough items\"));\nEXTERN char e_argument_of_str_must_be_list_or_dictionary[]\n\tINIT(= N_(\"E712: Argument of %s must be a List or Dictionary\"));\nEXTERN char e_cannot_use_empty_key_for_dictionary[]\n\tINIT(= N_(\"E713: Cannot use empty key for Dictionary\"));\nEXTERN char e_list_required[]\n\tINIT(= N_(\"E714: List required\"));\nEXTERN char e_dictionary_required[]\n\tINIT(= N_(\"E715: Dictionary required\"));\nEXTERN char e_key_not_present_in_dictionary_str[]\n\tINIT(= N_(\"E716: Key not present in Dictionary: \\\"%s\\\"\"));\nEXTERN char e_dictionary_entry_already_exists[]\n\tINIT(= N_(\"E717: Dictionary entry already exists\"));\nEXTERN char e_funcref_required[]\n\tINIT(= N_(\"E718: Funcref required\"));\nEXTERN char e_cannot_slice_dictionary[]\n\tINIT(= N_(\"E719: Cannot slice a Dictionary\"));\nEXTERN char e_missing_colon_in_dictionary_str[]\n\tINIT(= N_(\"E720: Missing colon in Dictionary: %s\"));\nEXTERN char e_duplicate_key_in_dictionary_str[]\n\tINIT(= N_(\"E721: Duplicate key in Dictionary: \\\"%s\\\"\"));\nEXTERN char e_missing_comma_in_dictionary_str[]\n\tINIT(= N_(\"E722: Missing comma in Dictionary: %s\"));\nEXTERN char e_missing_dict_end_str[]\n\tINIT(= N_(\"E723: Missing end of Dictionary '}': %s\"));\nEXTERN char e_variable_nested_too_deep_for_displaying[]\n\tINIT(= N_(\"E724: Variable nested too deep for displaying\"));\nEXTERN char e_calling_dict_function_without_dictionary_str[]\n\tINIT(= N_(\"E725: Calling dict function without Dictionary: %s\"));\nEXTERN char e_stride_is_zero[]\n\tINIT(= N_(\"E726: Stride is zero\"));\nEXTERN char e_start_past_end[]\n\tINIT(= N_(\"E727: Start past end\"));\nEXTERN char e_using_dictionary_as_number[]\n\tINIT(= N_(\"E728: Using a Dictionary as a Number\"));\nEXTERN char e_using_funcref_as_string[]\n\tINIT(= N_(\"E729: Using a Funcref as a String\"));\nEXTERN char e_using_list_as_string[]\n\tINIT(= N_(\"E730: Using a List as a String\"));\nEXTERN char e_using_dictionary_as_string[]\n\tINIT(= N_(\"E731: Using a Dictionary as a String\"));\nEXTERN char e_using_endfor_with_while[]\n\tINIT(= N_(\"E732: Using :endfor with :while\"));\nEXTERN char e_using_endwhile_with_for[]\n\tINIT(= N_(\"E733: Using :endwhile with :for\"));\nEXTERN char e_wrong_variable_type_for_str_equal[]\n\tINIT(= N_(\"E734: Wrong variable type for %s=\"));\nEXTERN char e_can_only_compare_dictionary_with_dictionary[]\n\tINIT(= N_(\"E735: Can only compare Dictionary with Dictionary\"));\nEXTERN char e_invalid_operation_for_dictionary[]\n\tINIT(= N_(\"E736: Invalid operation for Dictionary\"));\nEXTERN char e_key_already_exists_str[]\n\tINIT(= N_(\"E737: Key already exists: %s\"));\nEXTERN char e_cant_list_variables_for_str[]\n\tINIT(= N_(\"E738: Can't list variables for %s\"));\nEXTERN char e_cannot_create_directory_str[]\n\tINIT(= N_(\"E739: Cannot create directory: %s\"));\nEXTERN char e_too_many_arguments_for_function_str_2[]\n\tINIT(= N_(\"E740: Too many arguments for function %s\"));\nEXTERN char e_value_is_locked[]\n\tINIT(= N_(\"E741: Value is locked\"));\nEXTERN char e_value_is_locked_str[]\n\tINIT(= N_(\"E741: Value is locked: %s\"));\nEXTERN char e_cannot_change_value[]\n\tINIT(= N_(\"E742: Cannot change value\"));\nEXTERN char e_cannot_change_value_of_str[]\n\tINIT(= N_(\"E742: Cannot change value of %s\"));\nEXTERN char e_variable_nested_too_deep_for_unlock[]\n\tINIT(= N_(\"E743: Variable nested too deep for (un)lock\"));\n#endif\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_netbeans_does_not_allow_changes_in_read_only_files[]\n\tINIT(= N_(\"E744: NetBeans does not allow changes in read-only files\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_using_list_as_number[]\n\tINIT(= N_(\"E745: Using a List as a Number\"));\nEXTERN char e_function_name_does_not_match_script_file_name_str[]\n\tINIT(= N_(\"E746: Function name does not match script file name: %s\"));\n#endif\nEXTERN char e_cannot_change_directory_buffer_is_modified_add_bang_to_override[]\n\tINIT(= N_(\"E747: Cannot change directory, buffer is modified (add ! to override)\"));\nEXTERN char e_no_previously_used_register[]\n\tINIT(= N_(\"E748: No previously used register\"));\nEXTERN char e_empty_buffer[]\n\tINIT(= N_(\"E749: Empty buffer\"));\n#ifdef FEAT_PROFILE\nEXTERN char e_first_use_profile_start_fname[]\n\tINIT(= N_(\"E750: First use \\\":profile start {fname}\\\"\"));\n#endif\n#ifdef FEAT_SPELL\nEXTERN char e_output_file_name_must_not_have_region_name[]\n\tINIT(= N_(\"E751: Output file name must not have region name\"));\nEXTERN char e_no_previous_spell_replacement[]\n\tINIT(= N_(\"E752: No previous spell replacement\"));\nEXTERN char e_not_found_str[]\n\tINIT(= N_(\"E753: Not found: %s\"));\nEXTERN char e_only_up_to_nr_regions_supported[]\n\tINIT(= N_(\"E754: Only up to %d regions supported\"));\nEXTERN char e_invalid_region_in_str[]\n\tINIT(= N_(\"E755: Invalid region in %s\"));\nEXTERN char e_spell_checking_is_not_possible[]\n\tINIT(= N_(\"E756: Spell checking is not possible\"));\nEXTERN char e_this_does_not_look_like_spell_file[]\n\tINIT(= N_(\"E757: This does not look like a spell file\"));\nEXTERN char e_truncated_spell_file[]\n\tINIT(= N_(\"E758: Truncated spell file\"));\nEXTERN char e_format_error_in_spell_file[]\n\tINIT(= N_(\"E759: Format error in spell file\"));\nEXTERN char e_no_word_count_in_str[]\n\tINIT(= N_(\"E760: No word count in %s\"));\nEXTERN char e_format_error_in_affix_file_fol_low_or_upp[]\n\tINIT(= N_(\"E761: Format error in affix file FOL, LOW or UPP\"));\nEXTERN char e_character_in_fol_low_or_upp_is_out_of_range[]\n\tINIT(= N_(\"E762: Character in FOL, LOW or UPP is out of range\"));\nEXTERN char e_word_characters_differ_between_spell_files[]\n\tINIT(= N_(\"E763: Word characters differ between spell files\"));\n#endif\n#if defined(FEAT_SYN_HL) || defined(FEAT_COMPL_FUNC) || defined(FEAT_SPELL)\nEXTERN char e_option_str_is_not_set[]\n\tINIT(= N_(\"E764: Option '%s' is not set\"));\n#endif\n#ifdef FEAT_SPELL\nEXTERN char e_spellfile_does_not_have_nr_entries[]\n\tINIT(= N_(\"E765: 'spellfile' does not have %d entries\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_insufficient_arguments_for_printf[]\n\tINIT(= N_(\"E766: Insufficient arguments for printf()\"));\n#endif\nEXTERN char e_too_many_arguments_to_printf[]\n\tINIT(= N_(\"E767: Too many arguments for printf()\"));\nEXTERN char e_swap_file_exists_str_silent_overrides[]\n\tINIT(= N_(\"E768: Swap file exists: %s (:silent! overrides)\"));\nEXTERN char e_missing_rsb_after_str_lsb[]\n\tINIT(= N_(\"E769: Missing ] after %s[\"));\n#ifdef FEAT_SPELL\nEXTERN char e_unsupported_section_in_spell_file[]\n\tINIT(= N_(\"E770: Unsupported section in spell file\"));\nEXTERN char e_old_spell_file_needs_to_be_updated[]\n\tINIT(= N_(\"E771: Old spell file, needs to be updated\"));\nEXTERN char e_spell_file_is_for_newer_version_of_vim[]\n\tINIT(= N_(\"E772: Spell file is for newer version of Vim\"));\n#endif\nEXTERN char e_symlink_loop_for_str[]\n\tINIT(= N_(\"E773: Symlink loop for \\\"%s\\\"\"));\n#ifdef FEAT_EVAL\nEXTERN char e_operatorfunc_is_empty[]\n\tINIT(= N_(\"E774: 'operatorfunc' is empty\"));\n#else\nEXTERN char e_eval_feature_not_available[]\n\tINIT(= N_(\"E775: Eval feature not available\"));\n#endif\n#ifdef FEAT_QUICKFIX\nEXTERN char e_no_location_list[]\n\tINIT(= N_(\"E776: No location list\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_string_or_list_expected[]\n\tINIT(= N_(\"E777: String or List expected\"));\n#endif\n#ifdef FEAT_SPELL\nEXTERN char e_this_does_not_look_like_sug_file_str[]\n\tINIT(= N_(\"E778: This does not look like a .sug file: %s\"));\nEXTERN char e_old_sug_file_needs_to_be_updated_str[]\n\tINIT(= N_(\"E779: Old .sug file, needs to be updated: %s\"));\nEXTERN char e_sug_file_is_for_newer_version_of_vim_str[]\n\tINIT(= N_(\"E780: .sug file is for newer version of Vim: %s\"));\nEXTERN char e_sug_file_doesnt_match_spl_file_str[]\n\tINIT(= N_(\"E781: .sug file doesn't match .spl file: %s\"));\nEXTERN char e_error_while_reading_sug_file_str[]\n\tINIT(= N_(\"E782: Error while reading .sug file: %s\"));\nEXTERN char e_duplicate_char_in_map_entry[]\n\tINIT(= N_(\"E783: Duplicate char in MAP entry\"));\n#endif\nEXTERN char e_cannot_close_last_tab_page[]\n\tINIT(= N_(\"E784: Cannot close last tab page\"));\n#ifdef FEAT_EVAL\n# ifdef FEAT_COMPL_FUNC\nEXTERN char e_complete_can_only_be_used_in_insert_mode[]\n\tINIT(= N_(\"E785: complete() can only be used in Insert mode\"));\n# endif\nEXTERN char e_range_not_allowed[]\n\tINIT(= N_(\"E786: Range not allowed\"));\n#endif\n#ifdef FEAT_DIFF\nEXTERN char e_buffer_changed_unexpectedly[]\n\tINIT(= N_(\"E787: Buffer changed unexpectedly\"));\n#endif\nEXTERN char e_not_allowed_to_edit_another_buffer_now[]\n\tINIT(= N_(\"E788: Not allowed to edit another buffer now\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_error_missing_rsb_str[]\n\tINIT(= N_(\"E789: Missing ']': %s\"));\n#endif\nEXTERN char e_undojoin_is_not_allowed_after_undo[]\n\tINIT(= N_(\"E790: undojoin is not allowed after undo\"));\n#ifdef FEAT_KEYMAP\nEXTERN char e_empty_keymap_entry[]\n\tINIT(= N_(\"E791: Empty keymap entry\"));\n#endif\n#ifdef FEAT_MENU\nEXTERN char e_empty_menu_name[]\n\tINIT(= N_(\"E792: Empty menu name\"));\n#endif\n#ifdef FEAT_DIFF\nEXTERN char e_no_other_buffer_in_diff_mode_is_modifiable[]\n\tINIT(= N_(\"E793: No other buffer in diff mode is modifiable\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_set_variable_in_sandbox[]\n\tINIT(= N_(\"E794: Cannot set variable in the sandbox\"));\nEXTERN char e_cannot_set_variable_in_sandbox_str[]\n\tINIT(= N_(\"E794: Cannot set variable in the sandbox: \\\"%s\\\"\"));\nEXTERN char e_cannot_delete_variable[]\n\tINIT(= N_(\"E795: Cannot delete variable\"));\nEXTERN char e_cannot_delete_variable_str[]\n\tINIT(= N_(\"E795: Cannot delete variable %s\"));\n#endif\n#ifdef MSWIN\n\t// E796\nEXTERN char e_writing_to_device_disabled_with_opendevice_option[]\n\tINIT(= N_(\"writing to device disabled with 'opendevice' option\"));\n#endif\n#ifdef FEAT_SPELL\nEXTERN char e_spellfilemising_autocommand_deleted_buffer[]\n\tINIT(= N_(\"E797: SpellFileMissing autocommand deleted buffer\"));\n#endif\n#ifdef FEAT_SEARCH_EXTRA\nEXTERN char e_id_is_reserved_for_match_nr[]\n\tINIT(= N_(\"E798: ID is reserved for \\\":match\\\": %d\"));\nEXTERN char e_invalid_id_nr_must_be_greater_than_or_equal_to_one_1[]\n\tINIT(= N_(\"E799: Invalid ID: %d (must be greater than or equal to 1)\"));\n#endif\n#ifndef FEAT_ARABIC\nEXTERN char e_arabic_cannot_be_used_not_enabled_at_compile_time[]\n\tINIT(= N_(\"E800: Arabic cannot be used: Not enabled at compile time\\n\"));\n#endif\n#ifdef FEAT_SEARCH_EXTRA\nEXTERN char e_id_already_taken_nr[]\n\tINIT(= N_(\"E801: ID already taken: %d\"));\nEXTERN char e_invalid_id_nr_must_be_greater_than_or_equal_to_one_2[]\n\tINIT(= N_(\"E802: Invalid ID: %d (must be greater than or equal to 1)\"));\nEXTERN char e_id_not_found_nr[]\n\tINIT(= N_(\"E803: ID not found: %d\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_use_percent_with_float[]\n\t// xgettext:no-c-format\n\tINIT(= N_(\"E804: Cannot use '%' with Float\"));\nEXTERN char e_using_float_as_number[]\n\tINIT(= N_(\"E805: Using a Float as a Number\"));\nEXTERN char e_using_float_as_string[]\n\tINIT(= N_(\"E806: Using a Float as a String\"));\nEXTERN char e_expected_float_argument_for_printf[]\n\tINIT(= N_(\"E807: Expected Float argument for printf()\"));\nEXTERN char e_number_or_float_required[]\n\tINIT(= N_(\"E808: Number or Float required\"));\n#endif\n#ifndef FEAT_EVAL\nEXTERN char e_hashsmall_is_not_available_without_the_eval_feature[]\n\tINIT(= N_(\"E809: #< is not available without the +eval feature\"));\n#endif\n#ifdef FEAT_DIFF\nEXTERN char e_cannot_read_or_write_temp_files[]\n\tINIT(= N_(\"E810: Cannot read or write temp files\"));\n#endif\nEXTERN char e_not_allowed_to_change_buffer_information_now[]\n\tINIT(= N_(\"E811: Not allowed to change buffer information now\"));\nEXTERN char e_autocommands_changed_buffer_or_buffer_name[]\n\tINIT(= N_(\"E812: Autocommands changed buffer or buffer name\"));\nEXTERN char e_cannot_close_autocmd_or_popup_window[]\n\tINIT(= N_(\"E813: Cannot close autocmd or popup window\"));\nEXTERN char e_cannot_close_window_only_autocmd_window_would_remain[]\n\tINIT(= N_(\"E814: Cannot close window, only autocmd window would remain\"));\n#ifdef FEAT_MZSCHEME\nEXTERN char e_sorry_this_command_is_disabled_the_mzscheme_libraries_could_not_be_loaded[]\n\tINIT(= N_(\"E815: Sorry, this command is disabled, the MzScheme libraries could not be loaded.\"));\n#endif\n#ifdef FEAT_DIFF\nEXTERN char e_cannot_read_patch_output[]\n\tINIT(= N_(\"E816: Cannot read patch output\"));\n#endif\n#ifdef FEAT_CRYPT\nEXTERN char e_blowfish_big_little_endian_use_wrong[]\n\tINIT(= N_(\"E817: Blowfish big/little endian use wrong\"));\nEXTERN char e_sha256_test_failed[]\n\tINIT(= N_(\"E818: sha256 test failed\"));\nEXTERN char e_blowfish_test_failed[]\n\tINIT(= N_(\"E819: Blowfish test failed\"));\nEXTERN char e_sizeof_uint32_isnot_four[]\n\tINIT(= N_(\"E820: sizeof(uint32_t) != 4\"));\nEXTERN char e_file_is_encrypted_with_unknown_method[]\n\tINIT(= N_(\"E821: File is encrypted with unknown method\"));\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\nEXTERN char e_cannot_open_undo_file_for_reading_str[]\n\tINIT(= N_(\"E822: Cannot open undo file for reading: %s\"));\nEXTERN char e_not_an_undo_file_str[]\n\tINIT(= N_(\"E823: Not an undo file: %s\"));\nEXTERN char e_incompatible_undo_file_str[]\n\tINIT(= N_(\"E824: Incompatible undo file: %s\"));\nEXTERN char e_corrupted_undo_file_str_str[]\n\tINIT(= N_(\"E825: Corrupted undo file (%s): %s\"));\n# ifdef FEAT_CRYPT\nEXTERN char e_undo_file_decryption_failed[]\n\tINIT(= N_(\"E826: Undo file decryption failed: %s\"));\n# else\nEXTERN char e_undo_file_is_encrypted_str[]\n\tINIT(= N_(\"E827: Undo file is encrypted: %s\"));\n# endif\nEXTERN char e_cannot_open_undo_file_for_writing_str[]\n\tINIT(= N_(\"E828: Cannot open undo file for writing: %s\"));\nEXTERN char e_write_error_in_undo_file_str[]\n\tINIT(= N_(\"E829: Write error in undo file: %s\"));\n#endif\nEXTERN char e_undo_number_nr_not_found[]\n\tINIT(= N_(\"E830: Undo number %ld not found\"));\n#ifdef FEAT_CRYPT\nEXTERN char e_bf_key_init_called_with_empty_password[]\n\tINIT(= \"E831: bf_key_init() called with empty password\");\n# ifdef FEAT_PERSISTENT_UNDO\nEXTERN char e_non_encrypted_file_has_encrypted_undo_file_str[]\n\tINIT(= N_(\"E832: Non-encrypted file has encrypted undo file: %s\"));\n# endif\n#else\nEXTERN char e_str_is_encrypted_and_this_version_of_vim_does_not_support_encryption[]\n\tINIT(= N_(\"E833: %s is encrypted and this version of Vim does not support encryption\"));\n#endif\nEXTERN char e_conflicts_with_value_of_listchars[]\n\tINIT(= N_(\"E834: Conflicts with value of 'listchars'\"));\nEXTERN char e_conflicts_with_value_of_fillchars[]\n\tINIT(= N_(\"E835: Conflicts with value of 'fillchars'\"));\n#ifdef DYNAMIC_PYTHON\nEXTERN char e_this_vim_cannot_execute_python_after_using_py3[]\n\tINIT(= N_(\"E836: This Vim cannot execute :python after using :py3\"));\nEXTERN char e_this_vim_cannot_execute_py3_after_using_python[]\n\tINIT(= N_(\"E837: This Vim cannot execute :py3 after using :python\"));\n#endif\n#if defined(FEAT_NETBEANS_INTG) && defined(FEAT_GUI)\nEXTERN char e_netbeans_is_not_supported_with_this_GUI[]\n\tINIT(= N_(\"E838: NetBeans is not supported with this GUI\"));\n#endif\n// E839 unused\n# ifdef FEAT_COMPL_FUNC\nEXTERN char e_complete_function_deleted_text[]\n\tINIT(= N_(\"E840: Completion function deleted text\"));\n# endif\nEXTERN char e_reserved_name_cannot_be_used_for_user_defined_command[]\n\tINIT(= N_(\"E841: Reserved name, cannot be used for user defined command\"));\nEXTERN char e_no_line_number_to_use_for_slnum[]\n\tINIT(= N_(\"E842: No line number to use for \\\"<slnum>\\\"\"));\n#ifdef FEAT_CRYPT\nEXTERN char e_error_while_updating_swap_file_crypt[]\n\tINIT(= N_(\"E843: Error while updating swap file crypt\"));\n#endif\n#ifdef FEAT_CONCEAL\nEXTERN char e_invalid_cchar_value[]\n\tINIT(= N_(\"E844: Invalid cchar value\"));\n#endif\n#ifdef FEAT_SPELL\nEXTERN char e_insufficient_memory_word_list_will_be_incomplete[]\n\tINIT(= N_(\"E845: Insufficient memory, word list will be incomplete\"));\n#endif\nEXTERN char e_key_code_not_set[]\n\tINIT(= N_(\"E846: Key code not set\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_too_many_syntax_includes[]\n\tINIT(= N_(\"E847: Too many syntax includes\"));\nEXTERN char e_too_many_syntax_clusters[]\n\tINIT(= N_(\"E848: Too many syntax clusters\"));\n#endif\nEXTERN char e_too_many_highlight_and_syntax_groups[]\n\tINIT(= N_(\"E849: Too many highlight and syntax groups\"));\n#ifndef FEAT_CLIPBOARD\nEXTERN char e_invalid_register_name[]\n\tINIT(= N_(\"E850: Invalid register name\"));\n#endif\n#ifdef FEAT_GUI\nEXTERN char e_failed_to_create_new_process_for_GUI[]\n\tINIT(= N_(\"E851: Failed to create a new process for the GUI\"));\nEXTERN char e_the_child_process_failed_to_start_GUI[]\n\tINIT(= N_(\"E852: The child process failed to start the GUI\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_duplicate_argument_name_str[]\n\tINIT(= N_(\"E853: Duplicate argument name: %s\"));\n#endif\nEXTERN char e_path_too_long_for_completion[]\n\tINIT(= N_(\"E854: Path too long for completion\"));\nEXTERN char e_autocommands_caused_command_to_abort[]\n\tINIT(= N_(\"E855: Autocommands caused command to abort\"));\n#ifdef FEAT_EVAL\nEXTERN char e_assert_fails_second_arg[]\n\tINIT(= N_(\"E856: \\\"assert_fails()\\\" second argument must be a string or a list with one or two strings\"));\nEXTERN char e_dictionary_key_str_required[]\n\tINIT(= N_(\"E857: Dictionary key \\\"%s\\\" required\"));\n#endif\n#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3)\nEXTERN char e_eval_did_not_return_valid_python_object[]\n\tINIT(= N_(\"E858: Eval did not return a valid python object\"));\nEXTERN char e_failed_to_convert_returned_python_object_to_vim_value[]\n\tINIT(= N_(\"E859: Failed to convert returned python object to a Vim value\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_need_id_and_type_or_types_with_both[]\n\tINIT(= N_(\"E860: Need 'id' and 'type' or 'types' with 'both'\"));\n# ifdef FEAT_TERMINAL\nEXTERN char e_cannot_open_second_popup_with_terminal[]\n\tINIT(= N_(\"E861: Cannot open a second popup with a terminal\"));\n# endif\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_use_g_here[]\n\tINIT(= N_(\"E862: Cannot use g: here\"));\n#endif\n#if defined(FEAT_PROP_POPUP) && defined(FEAT_TERMINAL)\nEXTERN char e_not_allowed_for_terminal_in_popup_window[]\n\tINIT(= N_(\"E863: Not allowed for a terminal in a popup window\"));\n#endif\nEXTERN char e_percent_hash_can_only_be_followed_by_zero_one_two_automatic_engine_will_be_used[]\n\t// xgettext:no-c-format\n\tINIT(= N_(\"E864: \\\\%#= can only be followed by 0, 1, or 2. The automatic engine will be used\"));\nEXTERN char e_nfa_regexp_end_encountered_prematurely[]\n\tINIT(= N_(\"E865: (NFA) Regexp end encountered prematurely\"));\nEXTERN char e_nfa_regexp_misplaced_chr[]\n\tINIT(= N_(\"E866: (NFA regexp) Misplaced %c\"));\nEXTERN char e_nfa_regexp_unknown_operator_z_chr[]\n\tINIT(= N_(\"E867: (NFA regexp) Unknown operator '\\\\z%c'\"));\nEXTERN char e_nfa_regexp_unknown_operator_percent_chr[]\n\tINIT(= N_(\"E867: (NFA regexp) Unknown operator '\\\\%%%c'\"));\nEXTERN char e_error_building_nfa_with_equivalence_class[]\n\tINIT(= N_(\"E868: Error building NFA with equivalence class!\"));\nEXTERN char e_nfa_regexp_unknown_operator_at_chr[]\n\tINIT(= N_(\"E869: (NFA regexp) Unknown operator '\\\\@%c'\"));\nEXTERN char e_nfa_regexp_error_reading_repetition_limits[]\n\tINIT(= N_(\"E870: (NFA regexp) Error reading repetition limits\"));\nEXTERN char e_nfa_regexp_cant_have_multi_follow_multi[]\n\tINIT(= N_(\"E871: (NFA regexp) Can't have a multi follow a multi\"));\nEXTERN char e_nfa_regexp_too_many_parens[]\n\tINIT(= N_(\"E872: (NFA regexp) Too many '('\"));\nEXTERN char e_nfa_regexp_proper_termination_error[]\n\tINIT(= N_(\"E873: (NFA regexp) proper termination error\"));\nEXTERN char e_nfa_regexp_could_not_pop_stack[]\n\tINIT(= N_(\"E874: (NFA regexp) Could not pop the stack!\"));\nEXTERN char e_nfa_regexp_while_converting_from_postfix_to_nfa_too_many_stats_left_on_stack[]\n\tINIT(= N_(\"E875: (NFA regexp) (While converting from postfix to NFA), too many states left on stack\"));\nEXTERN char e_nfa_regexp_not_enough_space_to_store_whole_nfa[]\n\tINIT(= N_(\"E876: (NFA regexp) Not enough space to store the whole NFA\"));\nEXTERN char e_nfa_regexp_invalid_character_class_nr[]\n\tINIT(= \"E877: (NFA regexp) Invalid character class: %d\");\nEXTERN char e_nfa_regexp_could_not_allocate_memory_for_branch_traversal[]\n\tINIT(= N_(\"E878: (NFA regexp) Could not allocate memory for branch traversal!\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_nfa_regexp_too_many_z[]\n\tINIT(= N_(\"E879: (NFA regexp) Too many \\\\z(\"));\n#endif\n#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3)\nEXTERN char e_cant_handle_systemexit_of_python_exception_in_vim[]\n\tINIT(= N_(\"E880: Can't handle SystemExit of python exception in vim\"));\n#endif\nEXTERN char e_line_count_changed_unexpectedly[]\n\tINIT(= N_(\"E881: Line count changed unexpectedly\"));\n#ifdef FEAT_EVAL\nEXTERN char e_uniq_compare_function_failed[]\n\tINIT(= N_(\"E882: Uniq compare function failed\"));\nEXTERN char e_search_pattern_and_expression_register_may_not_contain_two_or_more_lines[]\n\tINIT(= N_(\"E883: Search pattern and expression register may not contain two or more lines\"));\nEXTERN char e_function_name_cannot_contain_colon_str[]\n\tINIT(= N_(\"E884: Function name cannot contain a colon: %s\"));\n#endif\n#ifdef FEAT_SIGNS\nEXTERN char e_not_possible_to_change_sign_str[]\n\tINIT(= N_(\"E885: Not possible to change sign %s\"));\n#endif\n#ifdef FEAT_VIMINFO\nEXTERN char e_cant_rename_viminfo_file_to_str[]\n\tINIT(= N_(\"E886: Can't rename viminfo file to %s!\"));\n#endif\n#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3)\nEXTERN char e_sorry_this_command_is_disabled_python_side_module_could_not_be_loaded[]\n\tINIT(= N_(\"E887: Sorry, this command is disabled, the Python's site module could not be loaded.\"));\n#endif\nEXTERN char e_nfa_regexp_cannot_repeat_str[]\n\tINIT(= N_(\"E888: (NFA regexp) cannot repeat %s\"));\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_number_required[]\n\tINIT(= N_(\"E889: Number required\"));\n#endif\n#ifdef FEAT_SYN_HL\nEXTERN char e_trailing_char_after_rsb_str_str[]\n\tINIT(= N_(\"E890: Trailing char after ']': %s]%s\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_using_funcref_as_float[]\n\tINIT(= N_(\"E891: Using a Funcref as a Float\"));\nEXTERN char e_using_string_as_float[]\n\tINIT(= N_(\"E892: Using a String as a Float\"));\nEXTERN char e_using_list_as_float[]\n\tINIT(= N_(\"E893: Using a List as a Float\"));\nEXTERN char e_using_dictionary_as_float[]\n\tINIT(= N_(\"E894: Using a Dictionary as a Float\"));\n#endif\n#ifdef FEAT_MZSCHEME\nEXTERN char e_sorry_this_command_is_disabled_the_mzscheme_racket_base_module_could_not_be_loaded[]\n\tINIT(= N_(\"E895: Sorry, this command is disabled, the MzScheme's racket/base module could not be loaded.\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_argument_of_str_must_be_list_dictionary_or_blob[]\n\tINIT(= N_(\"E896: Argument of %s must be a List, Dictionary or Blob\"));\nEXTERN char e_list_or_blob_required[]\n\tINIT(= N_(\"E897: List or Blob required\"));\n#endif\n#ifdef FEAT_JOB_CHANNEL\nEXTERN char e_socket_in_channel_connect[]\n\tINIT(= N_(\"E898: socket() in channel_connect()\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_argument_of_str_must_be_list_or_blob[]\n\tINIT(= N_(\"E899: Argument of %s must be a List or Blob\"));\nEXTERN char e_maxdepth_must_be_non_negative_number[]\n\tINIT(= N_(\"E900: maxdepth must be non-negative number\"));\n#endif\n#ifdef FEAT_JOB_CHANNEL\nEXTERN char e_getaddrinfo_in_channel_open_str[]\n\tINIT(= N_(\"E901: getaddrinfo() in channel_open(): %s\"));\n# ifndef FEAT_IPV6\nEXTERN char e_gethostbyname_in_channel_open[]\n\tINIT(= N_(\"E901: gethostbyname() in channel_open()\"));\n# endif\nEXTERN char e_cannot_connect_to_port[]\n\tINIT(= N_(\"E902: Cannot connect to port\"));\nEXTERN char e_received_command_with_non_string_argument[]\n\tINIT(= N_(\"E903: Received command with non-string argument\"));\nEXTERN char e_last_argument_for_expr_call_must_be_number[]\n\tINIT(= N_(\"E904: Last argument for expr/call must be a number\"));\nEXTERN char e_third_argument_for_call_must_be_list[]\n\tINIT(= N_(\"E904: Third argument for call must be a list\"));\nEXTERN char e_received_unknown_command_str[]\n\tINIT(= N_(\"E905: Received unknown command: %s\"));\nEXTERN char e_not_an_open_channel[]\n\tINIT(= N_(\"E906: Not an open channel\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_using_special_value_as_float[]\n\tINIT(= N_(\"E907: Using a special value as a Float\"));\nEXTERN char e_using_invalid_value_as_string_str[]\n\tINIT(= N_(\"E908: Using an invalid value as a String: %s\"));\nEXTERN char e_cannot_index_special_variable[]\n\tINIT(= N_(\"E909: Cannot index a special variable\"));\n#endif\n#ifdef FEAT_JOB_CHANNEL\nEXTERN char e_using_job_as_number[]\n\tINIT(= N_(\"E910: Using a Job as a Number\"));\nEXTERN char e_using_job_as_float[]\n\tINIT(= N_(\"E911: Using a Job as a Float\"));\nEXTERN char e_cannot_use_evalexpr_sendexpr_with_raw_or_nl_channel[]\n\tINIT(= N_(\"E912: Cannot use ch_evalexpr()/ch_sendexpr() with a raw or nl channel\"));\nEXTERN char e_using_channel_as_number[]\n\tINIT(= N_(\"E913: Using a Channel as a Number\"));\nEXTERN char e_using_channel_as_float[]\n\tINIT(= N_(\"E914: Using a Channel as a Float\"));\nEXTERN char e_in_io_buffer_requires_in_buf_or_in_name_to_be_set[]\n\tINIT(= N_(\"E915: in_io buffer requires in_buf or in_name to be set\"));\nEXTERN char e_not_valid_job[]\n\tINIT(= N_(\"E916: Not a valid job\"));\nEXTERN char e_cannot_use_callback_with_str[]\n\tINIT(= N_(\"E917: Cannot use a callback with %s()\"));\nEXTERN char e_buffer_must_be_loaded_str[]\n\tINIT(= N_(\"E918: Buffer must be loaded: %s\"));\n#endif\nEXTERN char e_directory_not_found_in_str_str[]\n\tINIT(= N_(\"E919: Directory not found in '%s': \\\"%s\\\"\"));\n#ifdef FEAT_JOB_CHANNEL\nEXTERN char e_io_file_requires_name_to_be_set[]\n\tINIT(= N_(\"E920: _io file requires _name to be set\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_invalid_callback_argument[]\n\tINIT(= N_(\"E921: Invalid callback argument\"));\n// E922 unused\nEXTERN char e_second_argument_of_function_must_be_list_or_dict[]\n\tINIT(= N_(\"E923: Second argument of function() must be a list or a dict\"));\n#endif\n#ifdef FEAT_QUICKFIX\nEXTERN char e_current_window_was_closed[]\n\tINIT(= N_(\"E924: Current window was closed\"));\nEXTERN char e_current_quickfix_list_was_changed[]\n\tINIT(= N_(\"E925: Current quickfix list was changed\"));\nEXTERN char e_current_location_list_was_changed[]\n\tINIT(= N_(\"E926: Current location list was changed\"));\n#endif\n#ifdef FEAT_EVAL\n# ifdef FEAT_QUICKFIX\nEXTERN char e_invalid_action_str_1[]\n\tINIT(= N_(\"E927: Invalid action: '%s'\"));\n# endif\nEXTERN char e_string_required[]\n\tINIT(= N_(\"E928: String required\"));\n#endif\n#ifdef FEAT_VIMINFO\nEXTERN char e_too_many_viminfo_temp_files_like_str[]\n\tINIT(= N_(\"E929: Too many viminfo temp files, like %s!\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_use_redir_inside_execute[]\n\tINIT(= N_(\"E930: Cannot use :redir inside execute()\"));\n#endif\nEXTERN char e_buffer_cannot_be_registered[]\n\tINIT(= N_(\"E931: Buffer cannot be registered\"));\n#ifdef FEAT_EVAL\nEXTERN char e_closure_function_should_not_be_at_top_level_str[]\n\tINIT(= N_(\"E932: Closure function should not be at top level: %s\"));\nEXTERN char e_function_was_deleted_str[]\n\tINIT(= N_(\"E933: Function was deleted: %s\"));\n#endif\n#ifdef FEAT_SIGNS\nEXTERN char e_cannot_jump_to_buffer_that_does_not_have_name[]\n\tINIT(= N_(\"E934: Cannot jump to a buffer that does not have a name\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_invalid_submatch_number_nr[]\n\tINIT(= N_(\"E935: Invalid submatch number: %d\"));\n#endif\nEXTERN char e_cannot_delete_current_group[]\n\tINIT(= N_(\"E936: Cannot delete the current group\"));\nEXTERN char e_attempt_to_delete_buffer_that_is_in_use_str[]\n\tINIT(= N_(\"E937: Attempt to delete a buffer that is in use: %s\"));\n#ifdef FEAT_EVAL\nEXTERN char e_duplicate_key_in_json_str[]\n\tINIT(= N_(\"E938: Duplicate key in JSON: \\\"%s\\\"\"));\n#endif\nEXTERN char e_positive_count_required[]\n\tINIT(= N_(\"E939: Positive count required\"));\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_lock_or_unlock_variable_str[]\n\tINIT(= N_(\"E940: Cannot lock or unlock variable %s\"));\n# ifdef FEAT_CLIENTSERVER\nEXTERN char e_already_started_server[]\n\tINIT(= N_(\"E941: Already started a server\"));\n# else\nEXTERN char e_clientserver_feature_not_available[]\n\tINIT(= N_(\"E942: +clientserver feature not available\"));\n# endif\n#endif\nEXTERN char e_command_table_needs_to_be_updated_run_make_cmdidxs[]\n\tINIT(= \"E943: Command table needs to be updated, run 'make cmdidxs'\");\nEXTERN char e_reverse_range_in_character_class[]\n\tINIT(= N_(\"E944: Reverse range in character class\"));\nEXTERN char e_range_too_large_in_character_class[]\n\tINIT(= N_(\"E945: Range too large in character class\"));\n#ifdef FEAT_TERMINAL\nEXTERN char e_cannot_make_terminal_with_running_job_modifiable[]\n\tINIT(= N_(\"E946: Cannot make a terminal with running job modifiable\"));\nEXTERN char e_job_still_running_in_buffer_str[]\n\tINIT(= N_(\"E947: Job still running in buffer \\\"%s\\\"\"));\nEXTERN char e_job_still_running[]\n\tINIT(= N_(\"E948: Job still running\"));\nEXTERN char e_job_still_running_add_bang_to_end_the_job[]\n\tINIT(= N_(\"E948: Job still running (add ! to end the job)\"));\n#endif\nEXTERN char e_file_changed_while_writing[]\n\tINIT(= N_(\"E949: File changed while writing\"));\nEXTERN char e_cannot_convert_between_str_and_str[]\n\tINIT(= N_(\"E950: Cannot convert between %s and %s\"));\nEXTERN char e_percent_value_too_large[]\n\t// xgettext:no-c-format\n\tINIT(= N_(\"E951: \\\\% value too large\"));\n#if defined(FEAT_EVAL) && defined(FEAT_QUICKFIX)\nEXTERN char e_autocommand_caused_recursive_behavior[]\n\tINIT(= N_(\"E952: Autocommand caused recursive behavior\"));\n#endif\n#ifdef FEAT_TERMINAL\nEXTERN char e_file_exists_str[]\n\tINIT(= N_(\"E953: File exists: %s\"));\n#endif\n#if defined(FEAT_TERMGUICOLORS) && defined(FEAT_VTP)\nEXTERN char e_24_bit_colors_are_not_supported_on_this_environment[]\n\tINIT(= N_(\"E954: 24-bit colors are not supported on this environment\"));\n#endif\n#ifdef FEAT_TERMINAL\nEXTERN char e_not_terminal_buffer[]\n\tINIT(= N_(\"E955: Not a terminal buffer\"));\n#endif\nEXTERN char e_cannot_use_pattern_recursively[]\n\tINIT(= N_(\"E956: Cannot use pattern recursively\"));\n#ifdef FEAT_EVAL\nEXTERN char e_invalid_window_number[]\n\tINIT(= N_(\"E957: Invalid window number\"));\n#endif\n#ifdef FEAT_TERMINAL\nEXTERN char e_job_already_finished[]\n\tINIT(= N_(\"E958: Job already finished\"));\n#endif\n#ifdef FEAT_DIFF\nEXTERN char e_invalid_diff_format[]\n\tINIT(= N_(\"E959: Invalid diff format.\"));\nEXTERN char e_problem_creating_internal_diff[]\n\tINIT(= N_(\"E960: Problem creating the internal diff\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_no_line_number_to_use_for_sflnum[]\n\tINIT(= N_(\"E961: No line number to use for \\\"<sflnum>\\\"\"));\nEXTERN char e_invalid_action_str_2[]\n\tINIT(= N_(\"E962: Invalid action: '%s'\"));\nEXTERN char e_setting_v_str_to_value_with_wrong_type[]\n\tINIT(= N_(\"E963: Setting v:%s to value with wrong type\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char_u e_invalid_column_number_nr[]\n\tINIT(= N_(\"E964: Invalid column number: %ld\"));\nEXTERN char e_missing_property_type_name[]\n\tINIT(= N_(\"E965: Missing property type name\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char_u e_invalid_line_number_nr[]\n\tINIT(= N_(\"E966: Invalid line number: %ld\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_text_property_info_corrupted[]\n\tINIT(= \"E967: Text property info corrupted\");\nEXTERN char e_need_at_least_one_of_id_or_type[]\n\tINIT(= N_(\"E968: Need at least one of 'id' or 'type'\"));\nEXTERN char e_property_type_str_already_defined[]\n\tINIT(= N_(\"E969: Property type %s already defined\"));\nEXTERN char e_unknown_highlight_group_name_str[]\n\tINIT(= N_(\"E970: Unknown highlight group name: '%s'\"));\nEXTERN char e_property_type_str_does_not_exist[]\n\tINIT(= N_(\"E971: Property type %s does not exist\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_blob_value_does_not_have_right_number_of_bytes[]\n\tINIT(= N_(\"E972: Blob value does not have the right number of bytes\"));\nEXTERN char e_blob_literal_should_have_an_even_number_of_hex_characters[]\n\tINIT(= N_(\"E973: Blob literal should have an even number of hex characters\"));\nEXTERN char e_using_blob_as_number[]\n\tINIT(= N_(\"E974: Using a Blob as a Number\"));\nEXTERN char e_using_blob_as_float[]\n\tINIT(= N_(\"E975: Using a Blob as a Float\"));\nEXTERN char e_using_blob_as_string[]\n\tINIT(= N_(\"E976: Using a Blob as a String\"));\nEXTERN char e_can_only_compare_blob_with_blob[]\n\tINIT(= N_(\"E977: Can only compare Blob with Blob\"));\nEXTERN char e_invalid_operation_for_blob[]\n\tINIT(= N_(\"E978: Invalid operation for Blob\"));\nEXTERN char e_blob_index_out_of_range_nr[]\n\tINIT(= N_(\"E979: Blob index out of range: %ld\"));\n# ifndef USE_INPUT_BUF\nEXTERN char e_lowlevel_input_not_supported[]\n\tINIT(= N_(\"E980: Lowlevel input not supported\"));\n# endif\n#endif\nEXTERN char e_command_not_allowed_in_rvim[]\n\tINIT(= N_(\"E981: Command not allowed in rvim\"));\n#if defined(FEAT_TERMINAL) && defined(MSWIN)\nEXTERN char e_conpty_is_not_available[]\n\tINIT(= N_(\"E982: ConPTY is not available\"));\n#endif\nEXTERN char e_duplicate_argument_str[]\n\tINIT(= N_(\"E983: Duplicate argument: %s\"));\nEXTERN char e_scriptversion_used_outside_of_sourced_file[]\n\tINIT(= N_(\"E984: :scriptversion used outside of a sourced file\"));\n#ifdef FEAT_EVAL\nEXTERN char e_dot_equal_not_supported_with_script_version_two[]\n\tINIT(= N_(\"E985: .= is not supported with script version >= 2\"));\nEXTERN char e_cannot_modify_tag_stack_within_tagfunc[]\n\tINIT(= N_(\"E986: Cannot modify the tag stack within tagfunc\"));\nEXTERN char e_invalid_return_value_from_tagfunc[]\n\tINIT(= N_(\"E987: Invalid return value from tagfunc\"));\n#endif\n#ifdef GUI_MAY_SPAWN\nEXTERN char e_gui_cannot_be_used_cannot_execute_gvim_exe[]\n\tINIT(= N_(\"E988: GUI cannot be used. Cannot execute gvim.exe.\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_non_default_argument_follows_default_argument[]\n\tINIT(= N_(\"E989: Non-default argument follows default argument\"));\nEXTERN char e_missing_end_marker_str[]\n\tINIT(= N_(\"E990: Missing end marker '%s'\"));\nEXTERN char e_cannot_use_heredoc_here[]\n\tINIT(= N_(\"E991: Cannot use =<< here\"));\n#endif\nEXTERN char e_not_allowed_in_modeline_when_modelineexpr_is_off[]\n\tINIT(= N_(\"E992: Not allowed in a modeline when 'modelineexpr' is off\"));\n#ifdef FEAT_EVAL\nEXTERN char e_window_nr_is_not_popup_window[]\n\tINIT(= N_(\"E993: Window %d is not a popup window\"));\nEXTERN char e_not_allowed_in_popup_window[]\n\tINIT(= N_(\"E994: Not allowed in a popup window\"));\nEXTERN char e_cannot_modify_existing_variable[]\n\tINIT(= N_(\"E995: Cannot modify existing variable\"));\nEXTERN char e_cannot_lock_range[]\n\tINIT(= N_(\"E996: Cannot lock a range\"));\nEXTERN char e_cannot_lock_option[]\n\tINIT(= N_(\"E996: Cannot lock an option\"));\nEXTERN char e_cannot_lock_list_or_dict[]\n\tINIT(= N_(\"E996: Cannot lock a list or dict\"));\nEXTERN char e_cannot_lock_environment_variable[]\n\tINIT(= N_(\"E996: Cannot lock an environment variable\"));\nEXTERN char e_cannot_lock_register[]\n\tINIT(= N_(\"E996: Cannot lock a register\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_tabpage_not_found_nr[]\n\tINIT(= N_(\"E997: Tabpage not found: %d\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_reduce_of_an_empty_str_with_no_initial_value[]\n\tINIT(= N_(\"E998: Reduce of an empty %s with no initial value\"));\n#endif\nEXTERN char e_scriptversion_not_supported_nr[]\n\tINIT(= N_(\"E999: scriptversion not supported: %d\"));\n// E1000 unused\n#ifdef FEAT_EVAL\nEXTERN char e_variable_not_found_str[]\n\tINIT(= N_(\"E1001: Variable not found: %s\"));\nEXTERN char e_syntax_error_at_str[]\n\tINIT(= N_(\"E1002: Syntax error at %s\"));\nEXTERN char e_missing_return_value[]\n\tINIT(= N_(\"E1003: Missing return value\"));\nEXTERN char e_white_space_required_before_and_after_str_at_str[]\n\tINIT(= N_(\"E1004: White space required before and after '%s' at \\\"%s\\\"\"));\nEXTERN char e_too_many_argument_types[]\n\tINIT(= N_(\"E1005: Too many argument types\"));\nEXTERN char e_str_is_used_as_argument[]\n\tINIT(= N_(\"E1006: %s is used as an argument\"));\nEXTERN char e_mandatory_argument_after_optional_argument[]\n\tINIT(= N_(\"E1007: Mandatory argument after optional argument\"));\nEXTERN char e_missing_type_after_str[]\n\tINIT(= N_(\"E1008: Missing <type> after %s\"));\nEXTERN char e_missing_gt_after_type_str[]\n\tINIT(= N_(\"E1009: Missing > after type: %s\"));\nEXTERN char e_type_not_recognized_str[]\n\tINIT(= N_(\"E1010: Type not recognized: %s\"));\nEXTERN char e_name_too_long_str[]\n\tINIT(= N_(\"E1011: Name too long: %s\"));\nEXTERN char e_type_mismatch_expected_str_but_got_str[]\n\tINIT(= N_(\"E1012: Type mismatch; expected %s but got %s\"));\nEXTERN char e_type_mismatch_expected_str_but_got_str_in_str[]\n\tINIT(= N_(\"E1012: Type mismatch; expected %s but got %s in %s\"));\nEXTERN char e_argument_nr_type_mismatch_expected_str_but_got_str[]\n\tINIT(= N_(\"E1013: Argument %d: type mismatch, expected %s but got %s\"));\nEXTERN char e_argument_nr_type_mismatch_expected_str_but_got_str_in_str[]\n\tINIT(= N_(\"E1013: Argument %d: type mismatch, expected %s but got %s in %s\"));\nEXTERN char e_invalid_key_str[]\n\tINIT(= N_(\"E1014: Invalid key: %s\"));\nEXTERN char e_name_expected_str[]\n\tINIT(= N_(\"E1015: Name expected: %s\"));\nEXTERN char e_cannot_declare_a_scope_variable_str[]\n\tINIT(= N_(\"E1016: Cannot declare a %s variable: %s\"));\nEXTERN char e_cannot_declare_an_environment_variable_str[]\n\tINIT(= N_(\"E1016: Cannot declare an environment variable: %s\"));\nEXTERN char e_variable_already_declared_str[]\n\tINIT(= N_(\"E1017: Variable already declared: %s\"));\nEXTERN char e_cannot_assign_to_constant_str[]\n\tINIT(= N_(\"E1018: Cannot assign to a constant: %s\"));\nEXTERN char e_can_only_concatenate_to_string[]\n\tINIT(= N_(\"E1019: Can only concatenate to string\"));\nEXTERN char e_cannot_use_operator_on_new_variable_str[]\n\tINIT(= N_(\"E1020: Cannot use an operator on a new variable: %s\"));\nEXTERN char e_const_requires_a_value[]\n\tINIT(= N_(\"E1021: Const requires a value\"));\nEXTERN char e_type_or_initialization_required[]\n\tINIT(= N_(\"E1022: Type or initialization required\"));\nEXTERN char e_using_number_as_bool_nr[]\n\tINIT(= N_(\"E1023: Using a Number as a Bool: %lld\"));\nEXTERN char e_using_number_as_string[]\n\tINIT(= N_(\"E1024: Using a Number as a String\"));\nEXTERN char e_using_rcurly_outside_if_block_scope[]\n\tINIT(= N_(\"E1025: Using } outside of a block scope\"));\n#endif\nEXTERN char e_missing_rcurly[]\n\tINIT(= N_(\"E1026: Missing }\"));\n#ifdef FEAT_EVAL\nEXTERN char e_missing_return_statement[]\n\tINIT(= N_(\"E1027: Missing return statement\"));\nEXTERN char e_compiling_def_function_failed[]\n\tINIT(= N_(\"E1028: Compiling :def function failed\"));\nEXTERN char e_expected_str_but_got_str[]\n\tINIT(= N_(\"E1029: Expected %s but got %s\"));\nEXTERN char e_using_string_as_number_str[]\n\tINIT(= N_(\"E1030: Using a String as a Number: \\\"%s\\\"\"));\nEXTERN char e_cannot_use_void_value[]\n\tINIT(= N_(\"E1031: Cannot use void value\"));\nEXTERN char e_missing_catch_or_finally[]\n\tINIT(= N_(\"E1032: Missing :catch or :finally\"));\nEXTERN char e_catch_unreachable_after_catch_all[]\n\tINIT(= N_(\"E1033: Catch unreachable after catch-all\"));\nEXTERN char e_cannot_use_reserved_name_str[]\n\tINIT(= N_(\"E1034: Cannot use reserved name %s\"));\nEXTERN char e_percent_requires_number_arguments[]\n\t// xgettext:no-c-format\n\tINIT(= N_(\"E1035: % requires number arguments\"));\nEXTERN char e_char_requires_number_or_float_arguments[]\n\tINIT(= N_(\"E1036: %c requires number or float arguments\"));\nEXTERN char e_cannot_use_str_with_str[]\n\tINIT(= N_(\"E1037: Cannot use \\\"%s\\\" with %s\"));\nEXTERN char e_vim9script_can_only_be_used_in_script[]\n\tINIT(= N_(\"E1038: \\\"vim9script\\\" can only be used in a script\"));\nEXTERN char e_vim9script_must_be_first_command_in_script[]\n\tINIT(= N_(\"E1039: \\\"vim9script\\\" must be the first command in a script\"));\n#endif\nEXTERN char e_cannot_use_scriptversion_after_vim9script[]\n\tINIT(= N_(\"E1040: Cannot use :scriptversion after :vim9script\"));\n#ifdef FEAT_EVAL\nEXTERN char e_redefining_script_item_str[]\n\tINIT(= N_(\"E1041: Redefining script item: \\\"%s\\\"\"));\nEXTERN char e_export_can_only_be_used_in_vim9script[]\n\tINIT(= N_(\"E1042: Export can only be used in vim9script\"));\nEXTERN char e_invalid_command_after_export[]\n\tINIT(= N_(\"E1043: Invalid command after :export\"));\nEXTERN char e_export_with_invalid_argument[]\n\tINIT(= N_(\"E1044: Export with invalid argument\"));\n// E1045 not used\n// E1046 not used\nEXTERN char e_syntax_error_in_import_str[]\n\tINIT(= N_(\"E1047: Syntax error in import: %s\"));\nEXTERN char e_item_not_found_in_script_str[]\n\tINIT(= N_(\"E1048: Item not found in script: %s\"));\nEXTERN char e_item_not_exported_in_script_str[]\n\tINIT(= N_(\"E1049: Item not exported in script: %s\"));\n#endif\nEXTERN char e_colon_required_before_range_str[]\n\tINIT(= N_(\"E1050: Colon required before a range: %s\"));\n#ifdef FEAT_EVAL\nEXTERN char e_wrong_argument_type_for_plus[]\n\tINIT(= N_(\"E1051: Wrong argument type for +\"));\nEXTERN char e_cannot_declare_an_option_str[]\n\tINIT(= N_(\"E1052: Cannot declare an option: %s\"));\nEXTERN char e_could_not_import_str[]\n\tINIT(= N_(\"E1053: Could not import \\\"%s\\\"\"));\nEXTERN char e_variable_already_declared_in_script_str[]\n\tINIT(= N_(\"E1054: Variable already declared in the script: %s\"));\nEXTERN char e_missing_name_after_dots[]\n\tINIT(= N_(\"E1055: Missing name after ...\"));\nEXTERN char e_expected_type_str[]\n\tINIT(= N_(\"E1056: Expected a type: %s\"));\nEXTERN char e_missing_enddef[]\n\tINIT(= N_(\"E1057: Missing :enddef\"));\nEXTERN char e_function_nesting_too_deep[]\n\tINIT(= N_(\"E1058: Function nesting too deep\"));\nEXTERN char e_no_white_space_allowed_before_colon_str[]\n\tINIT(= N_(\"E1059: No white space allowed before colon: %s\"));\nEXTERN char e_expected_dot_after_name_str[]\n\tINIT(= N_(\"E1060: Expected dot after name: %s\"));\nEXTERN char e_cannot_find_function_str[]\n\tINIT(= N_(\"E1061: Cannot find function %s\"));\nEXTERN char e_cannot_index_number[]\n\tINIT(= N_(\"E1062: Cannot index a Number\"));\nEXTERN char e_type_mismatch_for_v_variable[]\n\tINIT(= N_(\"E1063: Type mismatch for v: variable\"));\n#endif\nEXTERN char e_yank_register_changed_while_using_it[]\n\tINIT(= N_(\"E1064: Yank register changed while using it\"));\nEXTERN char e_command_cannot_be_shortened_str[]\n\tINIT(= N_(\"E1065: Command cannot be shortened: %s\"));\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_declare_a_register_str[]\n\tINIT(= N_(\"E1066: Cannot declare a register: %s\"));\nEXTERN char e_separator_mismatch_str[]\n\tINIT(= N_(\"E1067: Separator mismatch: %s\"));\nEXTERN char e_no_white_space_allowed_before_str_str[]\n\tINIT(= N_(\"E1068: No white space allowed before '%s': %s\"));\nEXTERN char e_white_space_required_after_str_str[]\n\tINIT(= N_(\"E1069: White space required after '%s': %s\"));\nEXTERN char e_invalid_string_for_import_str[]\n\tINIT(= N_(\"E1071: Invalid string for :import: %s\"));\nEXTERN char e_cannot_compare_str_with_str[]\n\tINIT(= N_(\"E1072: Cannot compare %s with %s\"));\nEXTERN char e_name_already_defined_str[]\n\tINIT(= N_(\"E1073: Name already defined: %s\"));\nEXTERN char e_no_white_space_allowed_after_dot[]\n\tINIT(= N_(\"E1074: No white space allowed after dot\"));\nEXTERN char e_namespace_not_supported_str[]\n\tINIT(= N_(\"E1075: Namespace not supported: %s\"));\n// E1076 unused (was deleted)\nEXTERN char e_missing_argument_type_for_str[]\n\tINIT(= N_(\"E1077: Missing argument type for %s\"));\n#endif\nEXTERN char e_invalid_command_nested_did_you_mean_plusplus_nested[]\n\tINIT(= N_(\"E1078: Invalid command \\\"nested\\\", did you mean \\\"++nested\\\"?\"));\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_declare_variable_on_command_line[]\n\tINIT(= N_(\"E1079: Cannot declare a variable on the command line\"));\nEXTERN char e_invalid_assignment[]\n\tINIT(= N_(\"E1080: Invalid assignment\"));\nEXTERN char e_cannot_unlet_str[]\n\tINIT(= N_(\"E1081: Cannot unlet %s\"));\n#endif\nEXTERN char e_command_modifier_without_command[]\n\tINIT(= N_(\"E1082: Command modifier without command\"));\n#ifdef FEAT_EVAL\nEXTERN char e_missing_backtick[]\n\tINIT(= N_(\"E1083: Missing backtick\"));\nEXTERN char e_cannot_delete_vim9_script_function_str[]\n\tINIT(= N_(\"E1084: Cannot delete Vim9 script function %s\"));\nEXTERN char e_not_callable_type_str[]\n\tINIT(= N_(\"E1085: Not a callable type: %s\"));\n// E1086 unused\nEXTERN char e_cannot_use_index_when_declaring_variable[]\n\tINIT(= N_(\"E1087: Cannot use an index when declaring a variable\"));\nEXTERN char e_script_cannot_import_itself[]\n\tINIT(= N_(\"E1088: Script cannot import itself\"));\nEXTERN char e_unknown_variable_str[]\n\tINIT(= N_(\"E1089: Unknown variable: %s\"));\nEXTERN char e_cannot_assign_to_argument_str[]\n\tINIT(= N_(\"E1090: Cannot assign to argument %s\"));\nEXTERN char e_function_is_not_compiled_str[]\n\tINIT(= N_(\"E1091: Function is not compiled: %s\"));\nEXTERN char e_cannot_nest_redir[]\n\tINIT(= N_(\"E1092: Cannot nest :redir\"));\nEXTERN char e_expected_nr_items_but_got_nr[]\n\tINIT(= N_(\"E1093: Expected %d items but got %d\"));\nEXTERN char e_import_can_only_be_used_in_script[]\n\tINIT(= N_(\"E1094: Import can only be used in a script\"));\nEXTERN char e_unreachable_code_after_str[]\n\tINIT(= N_(\"E1095: Unreachable code after :%s\"));\nEXTERN char e_returning_value_in_function_without_return_type[]\n\tINIT(= N_(\"E1096: Returning a value in a function without a return type\"));\nEXTERN char e_line_incomplete[]\n\tINIT(= N_(\"E1097: Line incomplete\"));\nEXTERN char e_string_list_or_blob_required[]\n\tINIT(= N_(\"E1098: String, List or Blob required\"));\nEXTERN char e_unknown_error_while_executing_str[]\n\tINIT(= N_(\"E1099: Unknown error while executing %s\"));\nEXTERN char e_command_not_supported_in_vim9_script_missing_var_str[]\n\tINIT(= N_(\"E1100: Command not supported in Vim9 script (missing :var?): %s\"));\nEXTERN char e_cannot_declare_script_variable_in_function_str[]\n\tINIT(= N_(\"E1101: Cannot declare a script variable in a function: %s\"));\nEXTERN char e_lambda_function_not_found_str[]\n\tINIT(= N_(\"E1102: Lambda function not found: %s\"));\nEXTERN char e_dictionary_not_set[]\n\tINIT(= N_(\"E1103: Dictionary not set\"));\nEXTERN char e_missing_gt[]\n\tINIT(= N_(\"E1104: Missing >\"));\nEXTERN char e_cannot_convert_str_to_string[]\n\tINIT(= N_(\"E1105: Cannot convert %s to string\"));\n\nPLURAL_MSG(e_one_argument_too_many, \"E1106: One argument too many\",\n\t\te_nr_arguments_too_many, \"E1106: %d arguments too many\")\n\nEXTERN char e_string_list_dict_or_blob_required[]\n\tINIT(= N_(\"E1107: String, List, Dict or Blob required\"));\n// E1108 unused\nEXTERN char e_list_item_nr_is_not_list[]\n\tINIT(= N_(\"E1109: List item %d is not a List\"));\nEXTERN char e_list_item_nr_does_not_contain_3_numbers[]\n\tINIT(= N_(\"E1110: List item %d does not contain 3 numbers\"));\nEXTERN char e_list_item_nr_range_invalid[]\n\tINIT(= N_(\"E1111: List item %d range invalid\"));\nEXTERN char e_list_item_nr_cell_width_invalid[]\n\tINIT(= N_(\"E1112: List item %d cell width invalid\"));\nEXTERN char e_overlapping_ranges_for_nr[]\n\tINIT(= N_(\"E1113: Overlapping ranges for 0x%lx\"));\nEXTERN char e_only_values_of_0x80_and_higher_supported[]\n\tINIT(= N_(\"E1114: Only values of 0x80 and higher supported\"));\nEXTERN char e_assert_fails_fourth_argument[]\n\tINIT(= N_(\"E1115: \\\"assert_fails()\\\" fourth argument must be a number\"));\nEXTERN char e_assert_fails_fifth_argument[]\n\tINIT(= N_(\"E1116: \\\"assert_fails()\\\" fifth argument must be a string\"));\nEXTERN char e_cannot_use_bang_with_nested_def[]\n\tINIT(= N_(\"E1117: Cannot use ! with nested :def\"));\nEXTERN char e_cannot_change_locked_list[]\n\tINIT(= N_(\"E1118: Cannot change locked list\"));\nEXTERN char e_cannot_change_locked_list_item[]\n\tINIT(= N_(\"E1119: Cannot change locked list item\"));\nEXTERN char e_cannot_change_dict[]\n\tINIT(= N_(\"E1120: Cannot change dict\"));\nEXTERN char e_cannot_change_dict_item[]\n\tINIT(= N_(\"E1121: Cannot change dict item\"));\nEXTERN char e_variable_is_locked_str[]\n\tINIT(= N_(\"E1122: Variable is locked: %s\"));\nEXTERN char e_missing_comma_before_argument_str[]\n\tINIT(= N_(\"E1123: Missing comma before argument: %s\"));\nEXTERN char e_str_cannot_be_used_in_legacy_vim_script[]\n\tINIT(= N_(\"E1124: \\\"%s\\\" cannot be used in legacy Vim script\"));\nEXTERN char e_final_requires_a_value[]\n\tINIT(= N_(\"E1125: Final requires a value\"));\nEXTERN char e_cannot_use_let_in_vim9_script[]\n\tINIT(= N_(\"E1126: Cannot use :let in Vim9 script\"));\nEXTERN char e_missing_name_after_dot[]\n\tINIT(= N_(\"E1127: Missing name after dot\"));\nEXTERN char e_endblock_without_block[]\n\tINIT(= N_(\"E1128: } without {\"));\nEXTERN char e_throw_with_empty_string[]\n\tINIT(= N_(\"E1129: Throw with empty string\"));\nEXTERN char e_cannot_add_to_null_list[]\n\tINIT(= N_(\"E1130: Cannot add to null list\"));\nEXTERN char e_cannot_add_to_null_blob[]\n\tINIT(= N_(\"E1131: Cannot add to null blob\"));\nEXTERN char e_missing_function_argument[]\n\tINIT(= N_(\"E1132: Missing function argument\"));\nEXTERN char e_cannot_extend_null_dict[]\n\tINIT(= N_(\"E1133: Cannot extend a null dict\"));\nEXTERN char e_cannot_extend_null_list[]\n\tINIT(= N_(\"E1134: Cannot extend a null list\"));\nEXTERN char e_using_string_as_bool_str[]\n\tINIT(= N_(\"E1135: Using a String as a Bool: \\\"%s\\\"\"));\n#endif\nEXTERN char e_cmd_mapping_must_end_with_cr_before_second_cmd[]\n\tINIT(= N_(\"E1136: <Cmd> mapping must end with <CR> before second <Cmd>\"));\n// E1137 unused\n#ifdef FEAT_EVAL\nEXTERN char e_using_bool_as_number[]\n\tINIT(= N_(\"E1138: Using a Bool as a Number\"));\nEXTERN char e_missing_matching_bracket_after_dict_key[]\n\tINIT(= N_(\"E1139: Missing matching bracket after dict key\"));\nEXTERN char e_for_argument_must_be_sequence_of_lists[]\n\tINIT(= N_(\"E1140: :for argument must be a sequence of lists\"));\nEXTERN char e_indexable_type_required[]\n\tINIT(= N_(\"E1141: Indexable type required\"));\nEXTERN char e_calling_test_garbagecollect_now_while_v_testing_is_not_set[]\n\tINIT(= N_(\"E1142: Calling test_garbagecollect_now() while v:testing is not set\"));\nEXTERN char e_empty_expression_str[]\n\tINIT(= N_(\"E1143: Empty expression: \\\"%s\\\"\"));\nEXTERN char e_command_str_not_followed_by_white_space_str[]\n\tINIT(= N_(\"E1144: Command \\\"%s\\\" is not followed by white space: %s\"));\nEXTERN char e_missing_heredoc_end_marker_str[]\n\tINIT(= N_(\"E1145: Missing heredoc end marker: %s\"));\nEXTERN char e_command_not_recognized_str[]\n\tINIT(= N_(\"E1146: Command not recognized: %s\"));\nEXTERN char e_list_not_set[]\n\tINIT(= N_(\"E1147: List not set\"));\nEXTERN char e_cannot_index_str[]\n\tINIT(= N_(\"E1148: Cannot index a %s\"));\nEXTERN char e_script_variable_invalid_after_reload_in_function_str[]\n\tINIT(= N_(\"E1149: Script variable is invalid after reload in function %s\"));\nEXTERN char e_script_variable_type_changed[]\n\tINIT(= N_(\"E1150: Script variable type changed\"));\nEXTERN char e_mismatched_endfunction[]\n\tINIT(= N_(\"E1151: Mismatched endfunction\"));\nEXTERN char e_mismatched_enddef[]\n\tINIT(= N_(\"E1152: Mismatched enddef\"));\nEXTERN char e_invalid_operation_for_str[]\n\tINIT(= N_(\"E1153: Invalid operation for %s\"));\nEXTERN char e_divide_by_zero[]\n\tINIT(= N_(\"E1154: Divide by zero\"));\n#endif\nEXTERN char e_cannot_define_autocommands_for_all_events[]\n\tINIT(= N_(\"E1155: Cannot define autocommands for ALL events\"));\nEXTERN char e_cannot_change_arglist_recursively[]\n\tINIT(= N_(\"E1156: Cannot change the argument list recursively\"));\n#ifdef FEAT_EVAL\nEXTERN char e_missing_return_type[]\n\tINIT(= N_(\"E1157: Missing return type\"));\nEXTERN char e_cannot_use_flatten_in_vim9_script[]\n\tINIT(= N_(\"E1158: Cannot use flatten() in Vim9 script, use flattennew()\"));\n#endif\nEXTERN char e_cannot_split_window_when_closing_buffer[]\n\tINIT(= N_(\"E1159: Cannot split a window when closing the buffer\"));\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_use_default_for_variable_arguments[]\n\tINIT(= N_(\"E1160: Cannot use a default for variable arguments\"));\nEXTERN char e_cannot_json_encode_str[]\n\tINIT(= N_(\"E1161: Cannot json encode a %s\"));\nEXTERN char e_register_name_must_be_one_char_str[]\n\tINIT(= N_(\"E1162: Register name must be one character: %s\"));\nEXTERN char e_variable_nr_type_mismatch_expected_str_but_got_str[]\n\tINIT(= N_(\"E1163: Variable %d: type mismatch, expected %s but got %s\"));\nEXTERN char e_variable_nr_type_mismatch_expected_str_but_got_str_in_str[]\n\tINIT(= N_(\"E1163: Variable %d: type mismatch, expected %s but got %s in %s\"));\n#endif\nEXTERN char e_vim9cmd_must_be_followed_by_command[]\n\tINIT(= N_(\"E1164: vim9cmd must be followed by a command\"));\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_use_range_with_assignment_str[]\n\tINIT(= N_(\"E1165: Cannot use a range with an assignment: %s\"));\nEXTERN char e_cannot_use_range_with_dictionary[]\n\tINIT(= N_(\"E1166: Cannot use a range with a dictionary\"));\nEXTERN char e_argument_name_shadows_existing_variable_str[]\n\tINIT(= N_(\"E1167: Argument name shadows existing variable: %s\"));\nEXTERN char e_argument_already_declared_in_script_str[]\n\tINIT(= N_(\"E1168: Argument already declared in the script: %s\"));\nEXTERN char e_expression_too_recursive_str[]\n\tINIT(= N_(\"E1169: Expression too recursive: %s\"));\nEXTERN char e_cannot_use_hash_curly_to_start_comment[]\n\tINIT(= N_(\"E1170: Cannot use #{ to start a comment\"));\nEXTERN char e_missing_end_block[]\n\tINIT(= N_(\"E1171: Missing } after inline function\"));\nEXTERN char e_cannot_use_default_values_in_lambda[]\n\tINIT(= N_(\"E1172: Cannot use default values in a lambda\"));\nEXTERN char e_text_found_after_str_str[]\n\tINIT(= N_(\"E1173: Text found after %s: %s\"));\nEXTERN char e_string_required_for_argument_nr[]\n\tINIT(= N_(\"E1174: String required for argument %d\"));\nEXTERN char e_non_empty_string_required_for_argument_nr[]\n\tINIT(= N_(\"E1175: Non-empty string required for argument %d\"));\nEXTERN char e_misplaced_command_modifier[]\n\tINIT(= N_(\"E1176: Misplaced command modifier\"));\nEXTERN char e_for_loop_on_str_not_supported[]\n\tINIT(= N_(\"E1177: For loop on %s not supported\"));\nEXTERN char e_cannot_lock_unlock_local_variable[]\n\tINIT(= N_(\"E1178: Cannot lock or unlock a local variable\"));\n#endif\n#ifdef FEAT_TERMINAL\nEXTERN char e_failed_to_extract_pwd_from_str_check_your_shell_config[]\n\tINIT(= N_(\"E1179: Failed to extract PWD from %s, check your shell's config related to OSC 7\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_variable_arguments_type_must_be_list_str[]\n\tINIT(= N_(\"E1180: Variable arguments type must be a list: %s\"));\nEXTERN char e_cannot_use_underscore_here[]\n\tINIT(= N_(\"E1181: Cannot use an underscore here\"));\nEXTERN char e_cannot_define_dict_func_in_vim9_script_str[]\n\tINIT(= N_(\"E1182: Cannot define a dict function in Vim9 script: %s\"));\nEXTERN char e_cannot_use_range_with_assignment_operator_str[]\n\tINIT(= N_(\"E1183: Cannot use a range with an assignment operator: %s\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_blob_not_set[]\n\tINIT(= N_(\"E1184: Blob not set\"));\nEXTERN char e_missing_redir_end[]\n\tINIT(= N_(\"E1185: Missing :redir END\"));\nEXTERN char e_expression_does_not_result_in_value_str[]\n\tINIT(= N_(\"E1186: Expression does not result in a value: %s\"));\n#endif\nEXTERN char e_failed_to_source_defaults[]\n\tINIT(= N_(\"E1187: Failed to source defaults.vim\"));\n#if defined(FEAT_TERMINAL)\nEXTERN char e_cannot_open_terminal_from_command_line_window[]\n\tINIT(= N_(\"E1188: Cannot open a terminal from the command line window\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_use_legacy_with_command_str[]\n\tINIT(= N_(\"E1189: Cannot use :legacy with this command: %s\"));\n\nPLURAL_MSG(e_one_argument_too_few, \"E1190: One argument too few\",\n\t\te_nr_arguments_too_few, \"E1190: %d arguments too few\")\n\nEXTERN char e_call_to_function_that_failed_to_compile_str[]\n\tINIT(= N_(\"E1191: Call to function that failed to compile: %s\"));\nEXTERN char e_empty_function_name[]\n\tINIT(= N_(\"E1192: Empty function name\"));\n#endif\n// libsodium\n#ifdef FEAT_CRYPT\n# ifndef FEAT_SODIUM\nEXTERN char e_libsodium_not_built_in[]\n\tINIT(= N_(\"E1193: cryptmethod xchacha20 not built into this Vim\"));\n# else\n#  if 0\nEXTERN char e_libsodium_cannot_encrypt_header[]\n\tINIT(= N_(\"E1194: Cannot encrypt header, not enough space\"));\nEXTERN char e_libsodium_cannot_encrypt_buffer[]\n\tINIT(= N_(\"E1195: Cannot encrypt buffer, not enough space\"));\nEXTERN char e_libsodium_cannot_decrypt_header[]\n\tINIT(= N_(\"E1196: Cannot decrypt header, not enough space\"));\n#  endif\nEXTERN char e_libsodium_cannot_allocate_buffer[]\n\tINIT(= N_(\"E1197: Cannot allocate_buffer for encryption\"));\nEXTERN char e_libsodium_decryption_failed_header_incomplete[]\n\tINIT(= N_(\"E1198: Decryption failed: Header incomplete!\"));\n#  if 0\nEXTERN char e_libsodium_cannot_decrypt_buffer[]\n\tINIT(= N_(\"E1199: Cannot decrypt buffer, not enough space\"));\n#  endif\nEXTERN char e_libsodium_decryption_failed[]\n\tINIT(= N_(\"E1200: Decryption failed!\"));\nEXTERN char e_libsodium_decryption_failed_premature[]\n\tINIT(= N_(\"E1201: Decryption failed: pre-mature end of file!\"));\n# endif\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_no_white_space_allowed_after_str_str[]\n\tINIT(= N_(\"E1202: No white space allowed after '%s': %s\"));\nEXTERN char e_dot_not_allowed_after_str_str[]\n\tINIT(= N_(\"E1203: Dot not allowed after a %s: %s\"));\n#endif\nEXTERN char e_regexp_number_after_dot_pos_search_chr[]\n\tINIT(= N_(\"E1204: No Number allowed after .: '\\\\%%%c'\"));\nEXTERN char e_no_white_space_allowed_between_option_and[]\n\tINIT(= N_(\"E1205: No white space allowed between option and\"));\n#ifdef FEAT_EVAL\nEXTERN char e_dict_required_for_argument_nr[]\n\tINIT(= N_(\"E1206: Dictionary required for argument %d\"));\nEXTERN char e_expression_without_effect_str[]\n\tINIT(= N_(\"E1207: Expression without an effect: %s\"));\n#endif\nEXTERN char e_complete_used_without_allowing_arguments[]\n\tINIT(= N_(\"E1208: -complete used without allowing arguments\"));\n#ifdef FEAT_EVAL\nEXTERN char e_invalid_value_for_line_number_str[]\n\tINIT(= N_(\"E1209: Invalid value for a line number: \\\"%s\\\"\"));\nEXTERN char e_number_required_for_argument_nr[]\n\tINIT(= N_(\"E1210: Number required for argument %d\"));\nEXTERN char e_list_required_for_argument_nr[]\n\tINIT(= N_(\"E1211: List required for argument %d\"));\nEXTERN char e_bool_required_for_argument_nr[]\n\tINIT(= N_(\"E1212: Bool required for argument %d\"));\nEXTERN char e_redefining_imported_item_str[]\n\tINIT(= N_(\"E1213: Redefining imported item \\\"%s\\\"\"));\n#endif\n#if defined(FEAT_DIGRAPHS)\nEXTERN char e_digraph_must_be_just_two_characters_str[]\n\tINIT(= N_(\"E1214: Digraph must be just two characters: %s\"));\nEXTERN char e_digraph_argument_must_be_one_character_str[]\n\tINIT(= N_(\"E1215: Digraph must be one character: %s\"));\nEXTERN char e_digraph_setlist_argument_must_be_list_of_lists_with_two_items[]\n\tINIT(= N_(\"E1216: digraph_setlist() argument must be a list of lists with two items\"));\n#endif\n#ifdef FEAT_EVAL\n# ifdef FEAT_JOB_CHANNEL\nEXTERN char e_chan_or_job_required_for_argument_nr[]\n\tINIT(= N_(\"E1217: Channel or Job required for argument %d\"));\nEXTERN char e_job_required_for_argument_nr[]\n\tINIT(= N_(\"E1218: Job required for argument %d\"));\n# endif\nEXTERN char e_float_or_number_required_for_argument_nr[]\n\tINIT(= N_(\"E1219: Float or Number required for argument %d\"));\nEXTERN char e_string_or_number_required_for_argument_nr[]\n\tINIT(= N_(\"E1220: String or Number required for argument %d\"));\n# ifdef FEAT_JOB_CHANNEL\nEXTERN char e_string_or_blob_required_for_argument_nr[]\n\tINIT(= N_(\"E1221: String or Blob required for argument %d\"));\n# endif\nEXTERN char e_string_or_list_required_for_argument_nr[]\n\tINIT(= N_(\"E1222: String or List required for argument %d\"));\nEXTERN char e_string_or_dict_required_for_argument_nr[]\n\tINIT(= N_(\"E1223: String or Dictionary required for argument %d\"));\nEXTERN char e_string_number_or_list_required_for_argument_nr[]\n\tINIT(= N_(\"E1224: String, Number or List required for argument %d\"));\nEXTERN char e_string_list_or_dict_required_for_argument_nr[]\n\tINIT(= N_(\"E1225: String, List or Dictionary required for argument %d\"));\nEXTERN char e_list_or_blob_required_for_argument_nr[]\n\tINIT(= N_(\"E1226: List or Blob required for argument %d\"));\nEXTERN char e_list_or_dict_required_for_argument_nr[]\n\tINIT(= N_(\"E1227: List or Dictionary required for argument %d\"));\nEXTERN char e_list_dict_or_blob_required_for_argument_nr[]\n\tINIT(= N_(\"E1228: List, Dictionary or Blob required for argument %d\"));\nEXTERN char e_expected_dictionary_for_using_key_str_but_got_str[]\n\tINIT(= N_(\"E1229: Expected dictionary for using key \\\"%s\\\", but got %s\"));\n#endif\n#ifdef FEAT_SODIUM\nEXTERN char e_encryption_sodium_mlock_failed[]\n\tINIT(= N_(\"E1230: Encryption: sodium_mlock() failed\"));\n#endif\nEXTERN char e_cannot_use_bar_to_separate_commands_here_str[]\n\tINIT(= N_(\"E1231: Cannot use a bar to separate commands here: %s\"));\n#ifdef FEAT_EVAL\nEXTERN char e_argument_of_exists_compiled_must_be_literal_string[]\n\tINIT(= N_(\"E1232: Argument of exists_compiled() must be a literal string\"));\nEXTERN char e_exists_compiled_can_only_be_used_in_def_function[]\n\tINIT(= N_(\"E1233: exists_compiled() can only be used in a :def function\"));\n#endif\nEXTERN char e_legacy_must_be_followed_by_command[]\n\tINIT(= N_(\"E1234: legacy must be followed by a command\"));\n#ifdef FEAT_EVAL\n// E1235 unused\nEXTERN char e_cannot_use_str_itself_it_is_imported[]\n\tINIT(= N_(\"E1236: Cannot use %s itself, it is imported\"));\n#endif\nEXTERN char e_no_such_user_defined_command_in_current_buffer_str[]\n\tINIT(= N_(\"E1237: No such user-defined command in current buffer: %s\"));\n#ifdef FEAT_EVAL\nEXTERN char e_blob_required_for_argument_nr[]\n\tINIT(= N_(\"E1238: Blob required for argument %d\"));\nEXTERN char e_invalid_value_for_blob_nr[]\n\tINIT(= N_(\"E1239: Invalid value for blob: %d\"));\n#endif\nEXTERN char e_resulting_text_too_long[]\n\tINIT(= N_(\"E1240: Resulting text too long\"));\n#ifdef FEAT_EVAL\nEXTERN char e_separator_not_supported_str[]\n\tINIT(= N_(\"E1241: Separator not supported: %s\"));\nEXTERN char e_no_white_space_allowed_before_separator_str[]\n\tINIT(= N_(\"E1242: No white space allowed before separator: %s\"));\n#endif\n#ifdef FEAT_GUI_GTK\nEXTERN char e_ascii_code_not_in_range[]\n\tINIT(= N_(\"E1243: ASCII code not in 32-127 range\"));\n#endif\n#ifdef FEAT_EVAL\n# if defined(FEAT_GUI) || defined(FEAT_TERMGUICOLORS)\nEXTERN char e_bad_color_string_str[]\n\tINIT(= N_(\"E1244: Bad color string: %s\"));\n# endif\nEXTERN char e_cannot_expand_sfile_in_vim9_function[]\n\tINIT(= N_(\"E1245: Cannot expand <sfile> in a Vim9 function\"));\nEXTERN char e_cannot_find_variable_to_unlock_str[]\n\tINIT(= N_(\"E1246: Cannot find variable to (un)lock: %s\"));\n#endif\nEXTERN char e_line_number_out_of_range[]\n\tINIT(= N_(\"E1247: Line number out of range\"));\n#ifdef FEAT_EVAL\nEXTERN char e_closure_called_from_invalid_context[]\n\tINIT(= N_(\"E1248: Closure called from invalid context\"));\n#endif\nEXTERN char e_highlight_group_name_too_long[]\n\tINIT(= N_(\"E1249: Highlight group name too long\"));\n#ifdef FEAT_EVAL\nEXTERN char e_argument_of_str_must_be_list_string_dictionary_or_blob[]\n\tINIT(= N_(\"E1250: Argument of %s must be a List, String, Dictionary or Blob\"));\nEXTERN char e_list_dict_blob_or_string_required_for_argument_nr[]\n\tINIT(= N_(\"E1251: List, Dictionary, Blob or String required for argument %d\"));\nEXTERN char e_string_list_or_blob_required_for_argument_nr[]\n\tINIT(= N_(\"E1252: String, List or Blob required for argument %d\"));\n// E1253 unused\nEXTERN char e_cannot_use_script_variable_in_for_loop[]\n\tINIT(= N_(\"E1254: Cannot use script variable in for loop\"));\n#endif\nEXTERN char e_cmd_mapping_must_end_with_cr[]\n\tINIT(= N_(\"E1255: <Cmd> mapping must end with <CR>\"));\n#ifdef FEAT_EVAL\nEXTERN char e_string_or_function_required_for_argument_nr[]\n\tINIT(= N_(\"E1256: String or function required for argument %d\"));\nEXTERN char e_imported_script_must_use_as_or_end_in_dot_vim_str[]\n\tINIT(= N_(\"E1257: Imported script must use \\\"as\\\" or end in .vim: %s\"));\nEXTERN char e_no_dot_after_imported_name_str[]\n\tINIT(= N_(\"E1258: No '.' after imported name: %s\"));\nEXTERN char e_missing_name_after_imported_name_str[]\n\tINIT(= N_(\"E1259: Missing name after imported name: %s\"));\nEXTERN char e_cannot_unlet_imported_item_str[]\n\tINIT(= N_(\"E1260: Cannot unlet an imported item: %s\"));\nEXTERN char e_cannot_import_dot_vim_without_using_as[]\n\tINIT(= N_(\"E1261: Cannot import .vim without using \\\"as\\\"\"));\nEXTERN char e_cannot_import_same_script_twice_str[]\n\tINIT(= N_(\"E1262: Cannot import the same script twice: %s\"));\nEXTERN char e_cannot_use_name_with_hash_in_vim9_script_use_export_instead[]\n\tINIT(= N_(\"E1263: Cannot use name with # in Vim9 script, use export instead\"));\nEXTERN char e_autoload_import_cannot_use_absolute_or_relative_path[]\n\tINIT(= N_(\"E1264: Autoload import cannot use absolute or relative path: %s\"));\nEXTERN char e_cannot_use_partial_here[]\n\tINIT(= N_(\"E1265: Cannot use a partial here\"));\n#endif\n#if defined(FEAT_PYTHON3) && defined(MSWIN)\nEXTERN char e_critical_error_in_python3_initialization_check_your_installation[]\n\tINIT(= N_(\"E1266: Critical error in python3 initialization, check your python3 installation\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_function_name_must_start_with_capital_str[]\n\tINIT(= N_(\"E1267: Function name must start with a capital: %s\"));\nEXTERN char e_cannot_use_s_colon_in_vim9_script_str[]\n\tINIT(= N_(\"E1268: Cannot use s: in Vim9 script: %s\"));\nEXTERN char e_cannot_create_vim9_script_variable_in_function_str[]\n\tINIT(= N_(\"E1269: Cannot create a Vim9 script variable in a function: %s\"));\n#endif\nEXTERN char e_cannot_use_s_backslash_in_vim9_script[]\n\tINIT(= N_(\"E1270: Cannot use :s\\\\/sub/ in Vim9 script\"));\n#ifdef FEAT_EVAL\nEXTERN char e_compiling_closure_without_context_str[]\n\tINIT(= N_(\"E1271: Compiling closure without context: %s\"));\nEXTERN char e_using_type_not_in_script_context_str[]\n\tINIT(= N_(\"E1272: Using type not in a script context: %s\"));\n#endif\nEXTERN char e_nfa_regexp_missing_value_in_chr[]\n\tINIT(= N_(\"E1273: (NFA regexp) missing value in '\\\\%%%c'\"));\nEXTERN char e_no_script_file_name_to_substitute_for_script[]\n\tINIT(= N_(\"E1274: No script file name to substitute for \\\"<script>\\\"\"));\n#ifdef FEAT_EVAL\nEXTERN char e_string_or_function_required_for_arrow_parens_expr[]\n\tINIT(= N_(\"E1275: String or function required for ->(expr)\"));\nEXTERN char e_illegal_map_mode_string_str[]\n\tINIT(= N_(\"E1276: Illegal map mode string: '%s'\"));\n# if !defined(FEAT_JOB_CHANNEL)\nEXTERN char e_channel_job_feature_not_available[]\n\tINIT(= N_(\"E1277: Channel and job feature is not available\"));\n# endif\nEXTERN char e_stray_closing_curly_str[]\n\tINIT(= N_(\"E1278: Stray '}' without a matching '{': %s\"));\nEXTERN char e_missing_close_curly_str[]\n\tINIT(= N_(\"E1279: Missing '}': %s\"));\n#endif\n#ifdef FEAT_SPELL\nEXTERN char e_illegal_character_in_word[]\n\tINIT(= N_(\"E1280: Illegal character in word\"));\n#endif\nEXTERN char e_atom_engine_must_be_at_start_of_pattern[]\n\tINIT(= N_(\"E1281: Atom '\\\\%%#=%c' must be at the start of the pattern\"));\n#ifdef FEAT_EVAL\nEXTERN char e_bitshift_ops_must_be_number[]\n\tINIT(= N_(\"E1282: Bitshift operands must be numbers\"));\nEXTERN char e_bitshift_ops_must_be_positive[]\n\tINIT(= N_(\"E1283: Bitshift amount must be a positive number\"));\n#endif\n#if defined(FEAT_PROP_POPUP)\nEXTERN char e_argument_1_list_item_nr_dictionary_required[]\n\tINIT(= N_(\"E1284: Argument 1, list item %d: Dictionary required\"));\n#endif\n#ifdef FEAT_RELTIME\nEXTERN char e_could_not_clear_timeout_str[]\n\tINIT(= N_(\"E1285: Could not clear timeout: %s\"));\nEXTERN char e_could_not_set_timeout_str[]\n\tINIT(= N_(\"E1286: Could not set timeout: %s\"));\n#ifndef PROF_NSEC\nEXTERN char e_could_not_set_handler_for_timeout_str[]\n\tINIT(= N_(\"E1287: Could not set handler for timeout: %s\"));\nEXTERN char e_could_not_reset_handler_for_timeout_str[]\n\tINIT(= N_(\"E1288: Could not reset handler for timeout: %s\"));\nEXTERN char e_could_not_check_for_pending_sigalrm_str[]\n\tINIT(= N_(\"E1289: Could not check for pending SIGALRM: %s\"));\n#endif\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_substitute_nesting_too_deep[]\n\tINIT(= N_(\"E1290: substitute nesting too deep\"));\nEXTERN char e_invalid_argument_nr[]\n\tINIT(= N_(\"E1291: Invalid argument: %ld\"));\n#endif\nEXTERN char e_cmdline_window_already_open[]\n\tINIT(= N_(\"E1292: Command-line window is already open\"));\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_cannot_use_negative_id_after_adding_textprop_with_text[]\n\tINIT(= N_(\"E1293: Cannot use a negative id after adding a textprop with text\"));\nEXTERN char e_can_only_use_text_align_when_column_is_zero[]\n\tINIT(= N_(\"E1294: Can only use text_align when column is zero\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_cannot_specify_both_type_and_types[]\n\tINIT(= N_(\"E1295: Cannot specify both 'type' and 'types'\"));\nEXTERN char e_can_only_use_left_padding_when_column_is_zero[]\n\tINIT(= N_(\"E1296: Can only use left padding when column is zero\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_non_null_dict_required_for_argument_nr[]\n\tINIT(= N_(\"E1297: Non-NULL Dictionary required for argument %d\"));\nEXTERN char e_non_null_list_required_for_argument_nr[]\n\tINIT(= N_(\"E1298: Non-NULL List required for argument %d\"));\n#endif\nEXTERN char e_window_unexpectedly_close_while_searching_for_tags[]\n\tINIT(= N_(\"E1299: Window unexpectedly closed while searching for tags\"));\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_use_partial_with_dictionary_for_defer[]\n\tINIT(= N_(\"E1300: Cannot use a partial with dictionary for :defer\"));\nEXTERN char e_string_number_list_or_blob_required_for_argument_nr[]\n\tINIT(= N_(\"E1301: String, Number, List or Blob required for argument %d\"));\nEXTERN char e_script_variable_was_deleted[]\n\tINIT(= N_(\"E1302: Script variable was deleted\"));\nEXTERN char e_custom_list_completion_function_does_not_return_list_but_str[]\n\tINIT(= N_(\"E1303: Custom list completion function does not return a List but a %s\"));\nEXTERN char e_cannot_use_type_with_this_variable_str[]\n\tINIT(= N_(\"E1304: Cannot use type with this variable: %s\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_cannot_use_length_endcol_and_endlnum_with_text[]\n\tINIT(= N_(\"E1305: Cannot use \\\"length\\\", \\\"end_col\\\" and \\\"end_lnum\\\" with \\\"text\\\"\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_loop_nesting_too_deep[]\n\tINIT(= N_(\"E1306: Loop nesting too deep\"));\nEXTERN char e_argument_nr_trying_to_modify_const_str[]\n\tINIT(= N_(\"E1307: Argument %d: Trying to modify a const %s\"));\nEXTERN char e_cannot_resize_window_in_another_tab_page[]\n\tINIT(= N_(\"E1308: Cannot resize a window in another tab page\"));\n#endif\nEXTERN char e_cannot_change_mappings_while_listing[]\n\tINIT(= N_(\"E1309: Cannot change mappings while listing\"));\n#if defined(FEAT_MENU)\nEXTERN char e_cannot_change_menus_while_listing[]\n\tINIT(= N_(\"E1310: Cannot change menus while listing\"));\n#endif\nEXTERN char e_cannot_change_user_commands_while_listing[]\n\tINIT(= N_(\"E1311: Cannot change user commands while listing\"));\nEXTERN char e_not_allowed_to_change_window_layout_in_this_autocmd[]\n\tINIT(= N_(\"E1312: Not allowed to change the window layout in this autocmd\"));\nEXTERN char e_not_allowed_to_add_or_remove_entries_str[]\n\tINIT(= N_(\"E1313: Not allowed to add or remove entries (%s)\"));\n#ifdef FEAT_EVAL\nEXTERN char e_class_name_must_start_with_uppercase_letter_str[]\n\tINIT(= N_(\"E1314: Class name must start with an uppercase letter: %s\"));\nEXTERN char e_white_space_required_after_name_str[]\n\tINIT(= N_(\"E1315: White space required after name: %s\"));\nEXTERN char e_class_can_only_be_defined_in_vim9_script[]\n\tINIT(= N_(\"E1316: Class can only be defined in Vim9 script\"));\nEXTERN char e_invalid_object_variable_declaration_str[]\n\tINIT(= N_(\"E1317: Invalid object variable declaration: %s\"));\nEXTERN char e_not_valid_command_in_class_str[]\n\tINIT(= N_(\"E1318: Not a valid command in a class: %s\"));\nEXTERN char e_using_class_as_number[]\n\tINIT(= N_(\"E1319: Using a class as a Number\"));\nEXTERN char e_using_object_as_number[]\n\tINIT(= N_(\"E1320: Using an object as a Number\"));\nEXTERN char e_using_class_as_float[]\n\tINIT(= N_(\"E1321: Using a class as a Float\"));\nEXTERN char e_using_object_as_float[]\n\tINIT(= N_(\"E1322: Using an object as a Float\"));\nEXTERN char e_using_class_as_string[]\n\tINIT(= N_(\"E1323: Using a class as a String\"));\nEXTERN char e_using_object_as_string[]\n\tINIT(= N_(\"E1324: Using an object as a String\"));\nEXTERN char e_method_not_found_on_class_str_str[]\n\tINIT(= N_(\"E1325: Method \\\"%s\\\" not found in class \\\"%s\\\"\"));\nEXTERN char e_variable_not_found_on_object_str_str[]\n\tINIT(= N_(\"E1326: Variable \\\"%s\\\" not found in object \\\"%s\\\"\"));\nEXTERN char e_object_required_found_str[]\n\tINIT(= N_(\"E1327: Object required, found %s\"));\nEXTERN char e_constructor_default_value_must_be_vnone_str[]\n\tINIT(= N_(\"E1328: Constructor default value must be v:none: %s\"));\n// E1329 unused\nEXTERN char e_invalid_type_for_object_variable_str[]\n\tINIT(= N_(\"E1330: Invalid type for object variable: %s\"));\nEXTERN char e_public_must_be_followed_by_this_or_static[]\n\tINIT(= N_(\"E1331: Public must be followed by \\\"this\\\" or \\\"static\\\"\"));\nEXTERN char e_public_variable_name_cannot_start_with_underscore_str[]\n\tINIT(= N_(\"E1332: Public variable name cannot start with underscore: %s\"));\nEXTERN char e_cannot_access_private_variable_str[]\n\tINIT(= N_(\"E1333: Cannot access private variable \\\"%s\\\" in class \\\"%s\\\"\"));\n// E1334 unused\nEXTERN char e_variable_is_not_writable_str[]\n\tINIT(= N_(\"E1335: Variable \\\"%s\\\" in class \\\"%s\\\" is not writable\"));\n#endif\nEXTERN char e_internal_error_shortmess_too_long[]\n\tINIT(= \"E1336: Internal error: shortmess too long\");\n#ifdef FEAT_EVAL\nEXTERN char e_class_variable_str_not_found_in_class_str[]\n\tINIT(= N_(\"E1337: Class variable \\\"%s\\\" not found in class \\\"%s\\\"\"));\n// E1338 unused\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_cannot_add_textprop_with_text_after_using_textprop_with_negative_id[]\n\tINIT(= N_(\"E1339: Cannot add a textprop with text after using a textprop with a negative id\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_argument_already_declared_in_class_str[]\n\tINIT(= N_(\"E1340: Argument already declared in the class: %s\"));\nEXTERN char e_variable_already_declared_in_class_str[]\n\tINIT(= N_(\"E1341: Variable already declared in the class: %s\"));\nEXTERN char e_interface_can_only_be_defined_in_vim9_script[]\n\tINIT(= N_(\"E1342: Interface can only be defined in Vim9 script\"));\nEXTERN char e_interface_name_must_start_with_uppercase_letter_str[]\n\tINIT(= N_(\"E1343: Interface name must start with an uppercase letter: %s\"));\nEXTERN char e_cannot_initialize_variable_in_interface[]\n\tINIT(= N_(\"E1344: Cannot initialize a variable in an interface\"));\nEXTERN char e_not_valid_command_in_interface_str[]\n\tINIT(= N_(\"E1345: Not a valid command in an interface: %s\"));\nEXTERN char e_interface_name_not_found_str[]\n\tINIT(= N_(\"E1346: Interface name not found: %s\"));\nEXTERN char e_not_valid_interface_str[]\n\tINIT(= N_(\"E1347: Not a valid interface: %s\"));\nEXTERN char e_variable_str_of_interface_str_not_implemented[]\n\tINIT(= N_(\"E1348: Variable \\\"%s\\\" of interface \\\"%s\\\" is not implemented\"));\nEXTERN char e_method_str_of_interface_str_not_implemented[]\n\tINIT(= N_(\"E1349: Method \\\"%s\\\" of interface \\\"%s\\\" is not implemented\"));\nEXTERN char e_duplicate_implements[]\n\tINIT(= N_(\"E1350: Duplicate \\\"implements\\\"\"));\nEXTERN char e_duplicate_interface_after_implements_str[]\n\tINIT(= N_(\"E1351: Duplicate interface after \\\"implements\\\": %s\"));\nEXTERN char e_duplicate_extends[]\n\tINIT(= N_(\"E1352: Duplicate \\\"extends\\\"\"));\nEXTERN char e_class_name_not_found_str[]\n\tINIT(= N_(\"E1353: Class name not found: %s\"));\nEXTERN char e_cannot_extend_str[]\n\tINIT(= N_(\"E1354: Cannot extend %s\"));\nEXTERN char e_duplicate_function_str[]\n\tINIT(= N_(\"E1355: Duplicate function: %s\"));\nEXTERN char e_super_must_be_followed_by_dot[]\n\tINIT(= N_(\"E1356: \\\"super\\\" must be followed by a dot\"));\nEXTERN char e_using_super_not_in_class_method[]\n\tINIT(= N_(\"E1357: Using \\\"super\\\" not in a class method\"));\nEXTERN char e_using_super_not_in_child_class[]\n\tINIT(= N_(\"E1358: Using \\\"super\\\" not in a child class\"));\nEXTERN char e_cannot_define_new_method_in_abstract_class[]\n\tINIT(= N_(\"E1359: Cannot define a \\\"new\\\" method in an abstract class\"));\nEXTERN char e_using_null_object[]\n\tINIT(= N_(\"E1360: Using a null object\"));\n#endif\nEXTERN char e_cannot_use_color_none_did_you_mean_none[]\n\tINIT(= N_(\"E1361: Cannot use color \\\"none\\\", did you mean \\\"NONE\\\"?\"));\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_use_non_null_object[]\n\tINIT(= N_(\"E1362: Cannot use a non-null object\"));\nEXTERN char e_incomplete_type[]\n\tINIT(= N_(\"E1363: Incomplete type\"));\n#endif\nEXTERN char e_warning_pointer_block_corrupted[]\n\tINIT(= N_(\"E1364: Warning: Pointer block corrupted\"));\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_use_a_return_type_with_new_method[]\n\tINIT(= N_(\"E1365: Cannot use a return type with the \\\"new\\\" method\"));\nEXTERN char e_cannot_access_private_method_str[]\n\tINIT(= N_(\"E1366: Cannot access private method: %s\"));\nEXTERN char e_variable_str_of_interface_str_has_different_access[]\n\tINIT(= N_(\"E1367: Access level of variable \\\"%s\\\" of interface \\\"%s\\\" is different\"));\nEXTERN char e_static_cannot_be_followed_by_this[]\n\tINIT(= N_(\"E1368: Static cannot be followed by \\\"this\\\" in a variable name\"));\nEXTERN char e_duplicate_variable_str[]\n\tINIT(= N_(\"E1369: Duplicate variable: %s\"));\nEXTERN char e_cannot_define_new_method_as_static[]\n\tINIT(= N_(\"E1370: Cannot define a \\\"new\\\" method as static\"));\nEXTERN char e_abstract_must_be_followed_by_def_or_static[]\n\tINIT(= N_(\"E1371: Abstract must be followed by \\\"def\\\" or \\\"static\\\"\"));\nEXTERN char e_abstract_method_in_concrete_class[]\n\tINIT(= N_(\"E1372: Abstract method \\\"%s\\\" cannot be defined in a concrete class\"));\nEXTERN char e_abstract_method_str_not_found[]\n\tINIT(= N_(\"E1373: Abstract method \\\"%s\\\" is not implemented\"));\nEXTERN char e_class_variable_str_accessible_only_inside_class_str[]\n\tINIT(= N_(\"E1374: Class variable \\\"%s\\\" accessible only inside class \\\"%s\\\"\"));\nEXTERN char e_class_variable_str_accessible_only_using_class_str[]\n\tINIT(= N_(\"E1375: Class variable \\\"%s\\\" accessible only using class \\\"%s\\\"\"));\nEXTERN char e_object_variable_str_accessible_only_using_object_str[]\n\tINIT(= N_(\"E1376: Object variable \\\"%s\\\" accessible only using class \\\"%s\\\" object\"));\nEXTERN char e_method_str_of_class_str_has_different_access[]\n\tINIT(= N_(\"E1377: Access level of method \\\"%s\\\" is different in class \\\"%s\\\"\"));\nEXTERN char e_static_member_not_supported_in_interface[]\n\tINIT(= N_(\"E1378: Static member not supported in an interface\"));\nEXTERN char e_private_variable_not_supported_in_interface[]\n\tINIT(= N_(\"E1379: Private variable not supported in an interface\"));\nEXTERN char e_private_method_not_supported_in_interface[]\n\tINIT(= N_(\"E1380: Private method not supported in an interface\"));\nEXTERN char e_interface_cannot_use_implements[]\n\tINIT(= N_(\"E1381: Interface cannot use \\\"implements\\\"\"));\nEXTERN char e_variable_str_type_mismatch_expected_str_but_got_str[]\n\tINIT(= N_(\"E1382: Variable \\\"%s\\\": type mismatch, expected %s but got %s\"));\nEXTERN char e_method_str_type_mismatch_expected_str_but_got_str[]\n\tINIT(= N_(\"E1383: Method \\\"%s\\\": type mismatch, expected %s but got %s\"));\nEXTERN char e_class_method_str_accessible_only_inside_class_str[]\n\tINIT(= N_(\"E1384: Class method \\\"%s\\\" accessible only inside class \\\"%s\\\"\"));\nEXTERN char e_class_method_str_accessible_only_using_class_str[]\n\tINIT(= N_(\"E1385: Class method \\\"%s\\\" accessible only using class \\\"%s\\\"\"));\nEXTERN char e_object_method_str_accessible_only_using_object_str[]\n\tINIT(= N_(\"E1386: Object method \\\"%s\\\" accessible only using class \\\"%s\\\" object\"));\nEXTERN char e_public_variable_not_supported_in_interface[]\n\tINIT(= N_(\"E1387: Public variable not supported in an interface\"));\nEXTERN char e_public_keyword_not_supported_for_method[]\n\tINIT(= N_(\"E1388: Public keyword not supported for a method\"));\nEXTERN char e_missing_name_after_implements[]\n\tINIT(= N_(\"E1389: Missing name after implements\"));\nEXTERN char e_cannot_use_an_object_variable_except_with_the_new_method_str[]\n\tINIT(= N_(\"E1390: Cannot use an object variable \\\"this.%s\\\" except with the \\\"new\\\" method\"));\nEXTERN char e_cannot_lock_object_variable_str[]\n\tINIT(= N_(\"E1391: Cannot (un)lock variable \\\"%s\\\" in class \\\"%s\\\"\"));\nEXTERN char e_cannot_lock_class_variable_str[]\n\tINIT(= N_(\"E1392: Cannot (un)lock class variable \\\"%s\\\" in class \\\"%s\\\"\"));\n#endif\n// E1393 - E1499 unused (reserved for Vim9 class support)\nEXTERN char e_cannot_mix_positional_and_non_positional_str[]\n\tINIT(= N_(\"E1500: Cannot mix positional and non-positional arguments: %s\"));\nEXTERN char e_fmt_arg_nr_unused_str[]\n\tINIT(= N_(\"E1501: format argument %d unused in $-style format: %s\"));\nEXTERN char e_positional_num_field_spec_reused_str_str[]\n\tINIT(= N_(\"E1502: Positional argument %d used as field width reused as different type: %s/%s\"));\nEXTERN char e_positional_nr_out_of_bounds_str[]\n\tINIT(= N_(\"E1503: Positional argument %d out of bounds: %s\"));\nEXTERN char e_positional_arg_num_type_inconsistent_str_str[]\n\tINIT(= N_(\"E1504: Positional argument %d type used inconsistently: %s/%s\"));\nEXTERN char e_invalid_format_specifier_str[]\n\tINIT(= N_(\"E1505: Invalid format specifier: %s\"));\nEXTERN char e_xattr_erange[]\n\tINIT(= N_(\"E1506: Buffer too small to copy xattr value or key\"));\nEXTERN char e_aptypes_is_null_nr_str[]\n\tINIT(= \"E1507: Internal error: ap_types or ap_types[idx] is NULL: %d: %s\");\nEXTERN char e_xattr_e2big[]\n\tINIT(= N_(\"E1508: Size of the extended attribute value is larger than the maximum size allowed\"));\nEXTERN char e_xattr_other[]\n\tINIT(= N_(\"E1509: Error occurred when reading or writing extended attribute\"));\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * ex_getln.c: Functions for entering and editing an Ex command line.\n */\n\n#include \"vim.h\"\n\n#ifndef MAX\n# define MAX(x,y) ((x) > (y) ? (x) : (y))\n#endif\n\n// Return value when handling keys in command-line mode.\n#define CMDLINE_NOT_CHANGED\t1\n#define CMDLINE_CHANGED\t\t2\n#define GOTO_NORMAL_MODE\t3\n#define PROCESS_NEXT_KEY\t4\n\n// The current cmdline_info.  It is initialized in getcmdline() and after that\n// used by other functions.  When invoking getcmdline() recursively it needs\n// to be saved with save_cmdline() and restored with restore_cmdline().\nstatic cmdline_info_T ccline;\n\n#ifdef FEAT_EVAL\nstatic int\tnew_cmdpos;\t// position set by set_cmdline_pos()\n#endif\n\nstatic int\textra_char = NUL;  // extra character to display when redrawing\n\t\t\t\t   // the command line\nstatic int\textra_char_shift;\n\n#ifdef FEAT_RIGHTLEFT\nstatic int\tcmd_hkmap = 0;\t// Hebrew mapping during command line\n#endif\n\nstatic char_u\t*getcmdline_int(int firstc, long count, int indent, int clear_ccline);\nstatic int\tcmdline_charsize(int idx);\nstatic void\tset_cmdspos(void);\nstatic void\tset_cmdspos_cursor(void);\nstatic void\tcorrect_cmdspos(int idx, int cells);\nstatic void\talloc_cmdbuff(int len);\nstatic void\tdraw_cmdline(int start, int len);\nstatic void\tsave_cmdline(cmdline_info_T *ccp);\nstatic void\trestore_cmdline(cmdline_info_T *ccp);\nstatic int\tcmdline_paste(int regname, int literally, int remcr);\nstatic void\tredrawcmdprompt(void);\nstatic int\tccheck_abbr(int);\nstatic int\topen_cmdwin(void);\n#ifdef FEAT_SEARCH_EXTRA\nstatic int\tempty_pattern_magic(char_u *pat, size_t len, magic_T magic_val);\n#endif\n\nstatic int\tcedit_key = -1;\t// key value of 'cedit' option\n\n    static void\ntrigger_cmd_autocmd(int typechar, int evt)\n{\n    char_u\ttypestr[2];\n\n    typestr[0] = typechar;\n    typestr[1] = NUL;\n    apply_autocmds(evt, typestr, typestr, FALSE, curbuf);\n}\n\n/*\n * Abandon the command line.\n */\n    static void\nabandon_cmdline(void)\n{\n    VIM_CLEAR(ccline.cmdbuff);\n    if (msg_scrolled == 0)\n\tcompute_cmdrow();\n    msg(\"\");\n    redraw_cmdline = TRUE;\n}\n\n#ifdef FEAT_SEARCH_EXTRA\n/*\n * Guess that the pattern matches everything.  Only finds specific cases, such\n * as a trailing \\|, which can happen while typing a pattern.\n */\n    static int\nempty_pattern(char_u *p, int delim)\n{\n    size_t\tn = STRLEN(p);\n    magic_T\tmagic_val = MAGIC_ON;\n\n    if (n > 0)\n\t(void) skip_regexp_ex(p, delim, magic_isset(), NULL, NULL, &magic_val);\n    else\n\treturn TRUE;\n\n    return empty_pattern_magic(p, n, magic_val);\n}\n\n    static int\nempty_pattern_magic(char_u *p, size_t len, magic_T magic_val)\n{\n    // remove trailing \\v and the like\n    while (len >= 2 && p[len - 2] == '\\\\'\n\t\t\t&& vim_strchr((char_u *)\"mMvVcCZ\", p[len - 1]) != NULL)\n       len -= 2;\n\n    // true, if the pattern is empty, or the pattern ends with \\| and magic is\n    // set (or it ends with '|' and very magic is set)\n    return len == 0 || (len > 1\n\t    && ((p[len - 2] == '\\\\'\n\t\t\t\t && p[len - 1] == '|' && magic_val == MAGIC_ON)\n\t\t|| (p[len - 2] != '\\\\'\n\t\t\t     && p[len - 1] == '|' && magic_val == MAGIC_ALL)));\n}\n\n// Struct to store the viewstate during 'incsearch' highlighting.\ntypedef struct {\n    colnr_T\tvs_curswant;\n    colnr_T\tvs_leftcol;\n    colnr_T\tvs_skipcol;\n    linenr_T\tvs_topline;\n# ifdef FEAT_DIFF\n    int\t\tvs_topfill;\n# endif\n    linenr_T\tvs_botline;\n    linenr_T\tvs_empty_rows;\n} viewstate_T;\n\n    static void\nsave_viewstate(viewstate_T *vs)\n{\n    vs->vs_curswant = curwin->w_curswant;\n    vs->vs_leftcol = curwin->w_leftcol;\n    vs->vs_skipcol = curwin->w_skipcol;\n    vs->vs_topline = curwin->w_topline;\n# ifdef FEAT_DIFF\n    vs->vs_topfill = curwin->w_topfill;\n# endif\n    vs->vs_botline = curwin->w_botline;\n    vs->vs_empty_rows = curwin->w_empty_rows;\n}\n\n    static void\nrestore_viewstate(viewstate_T *vs)\n{\n    curwin->w_curswant = vs->vs_curswant;\n    curwin->w_leftcol = vs->vs_leftcol;\n    curwin->w_skipcol = vs->vs_skipcol;\n    curwin->w_topline = vs->vs_topline;\n# ifdef FEAT_DIFF\n    curwin->w_topfill = vs->vs_topfill;\n# endif\n    curwin->w_botline = vs->vs_botline;\n    curwin->w_empty_rows = vs->vs_empty_rows;\n}\n\n// Struct to store the state of 'incsearch' highlighting.\ntypedef struct {\n    pos_T\tsearch_start;\t// where 'incsearch' starts searching\n    pos_T\tsave_cursor;\n    int\t\twinid;\t\t// window where this state is valid\n    viewstate_T\tinit_viewstate;\n    viewstate_T\told_viewstate;\n    pos_T\tmatch_start;\n    pos_T\tmatch_end;\n    int\t\tdid_incsearch;\n    int\t\tincsearch_postponed;\n    optmagic_T\tmagic_overruled_save;\n} incsearch_state_T;\n\n    static void\ninit_incsearch_state(incsearch_state_T *is_state)\n{\n    is_state->winid = curwin->w_id;\n    is_state->match_start = curwin->w_cursor;\n    is_state->did_incsearch = FALSE;\n    is_state->incsearch_postponed = FALSE;\n    is_state->magic_overruled_save = magic_overruled;\n    CLEAR_POS(&is_state->match_end);\n    is_state->save_cursor = curwin->w_cursor;  // may be restored later\n    is_state->search_start = curwin->w_cursor;\n    save_viewstate(&is_state->init_viewstate);\n    save_viewstate(&is_state->old_viewstate);\n}\n\n/*\n * First move cursor to end of match, then to the start.  This\n * moves the whole match onto the screen when 'nowrap' is set.\n */\n    static void\nset_search_match(pos_T *t)\n{\n    t->lnum += search_match_lines;\n    t->col = search_match_endcol;\n    if (t->lnum > curbuf->b_ml.ml_line_count)\n    {\n\tt->lnum = curbuf->b_ml.ml_line_count;\n\tcoladvance((colnr_T)MAXCOL);\n    }\n}\n\n/*\n * Return TRUE when 'incsearch' highlighting is to be done.\n * Sets search_first_line and search_last_line to the address range.\n * May change the last search pattern.\n */\n    static int\ndo_incsearch_highlighting(\n\tint\t\t    firstc,\n\tint\t\t    *search_delim,\n\tincsearch_state_T   *is_state,\n\tint\t\t    *skiplen,\n\tint\t\t    *patlen)\n{\n    char_u\t*cmd;\n    cmdmod_T\tdummy_cmdmod;\n    char_u\t*p;\n    int\t\tdelim_optional = FALSE;\n    int\t\tdelim;\n    char_u\t*end;\n    char\t*dummy;\n    exarg_T\tea;\n    pos_T\tsave_cursor;\n    int\t\tuse_last_pat;\n    int\t\tretval = FALSE;\n    magic_T     magic = 0;\n\n    *skiplen = 0;\n    *patlen = ccline.cmdlen;\n\n    if (!p_is || cmd_silent)\n\treturn FALSE;\n\n    // by default search all lines\n    search_first_line = 0;\n    search_last_line = MAXLNUM;\n\n    if (firstc == '/' || firstc == '?')\n    {\n\t*search_delim = firstc;\n\treturn TRUE;\n    }\n    if (firstc != ':')\n\treturn FALSE;\n\n    ++emsg_off;\n    CLEAR_FIELD(ea);\n    ea.line1 = 1;\n    ea.line2 = 1;\n    ea.cmd = ccline.cmdbuff;\n    ea.addr_type = ADDR_LINES;\n\n    parse_command_modifiers(&ea, &dummy, &dummy_cmdmod, TRUE);\n\n    cmd = skip_range(ea.cmd, TRUE, NULL);\n    if (vim_strchr((char_u *)\"sgvl\", *cmd) == NULL)\n\tgoto theend;\n\n    // Skip over \"substitute\" to find the pattern separator.\n    for (p = cmd; ASCII_ISALPHA(*p); ++p)\n\t;\n    if (*skipwhite(p) == NUL)\n\tgoto theend;\n\n    if (STRNCMP(cmd, \"substitute\", p - cmd) == 0\n\t    || STRNCMP(cmd, \"smagic\", p - cmd) == 0\n\t    || STRNCMP(cmd, \"snomagic\", MAX(p - cmd, 3)) == 0\n\t    || STRNCMP(cmd, \"vglobal\", p - cmd) == 0)\n    {\n\tif (*cmd == 's' && cmd[1] == 'm')\n\t    magic_overruled = OPTION_MAGIC_ON;\n\telse if (*cmd == 's' && cmd[1] == 'n')\n\t    magic_overruled = OPTION_MAGIC_OFF;\n    }\n    else if (STRNCMP(cmd, \"sort\", MAX(p - cmd, 3)) == 0)\n    {\n\t// skip over ! and flags\n\tif (*p == '!')\n\t    p = skipwhite(p + 1);\n\twhile (ASCII_ISALPHA(*(p = skipwhite(p))))\n\t    ++p;\n\tif (*p == NUL)\n\t    goto theend;\n    }\n    else if (STRNCMP(cmd, \"vimgrep\", MAX(p - cmd, 3)) == 0\n\t|| STRNCMP(cmd, \"vimgrepadd\", MAX(p - cmd, 8)) == 0\n\t|| STRNCMP(cmd, \"lvimgrep\", MAX(p - cmd, 2)) == 0\n\t|| STRNCMP(cmd, \"lvimgrepadd\", MAX(p - cmd, 9)) == 0\n\t|| STRNCMP(cmd, \"global\", p - cmd) == 0)\n    {\n\t// skip over \"!\"\n\tif (*p == '!')\n\t{\n\t    p++;\n\t    if (*skipwhite(p) == NUL)\n\t\tgoto theend;\n\t}\n\tif (*cmd != 'g')\n\t    delim_optional = TRUE;\n    }\n    else\n\tgoto theend;\n\n    p = skipwhite(p);\n    delim = (delim_optional && vim_isIDc(*p)) ? ' ' : *p++;\n    *search_delim = delim;\n    end = skip_regexp_ex(p, delim, magic_isset(), NULL, NULL, &magic);\n\n    use_last_pat = end == p && *end == delim;\n\n    if (end == p && !use_last_pat)\n\tgoto theend;\n\n    // Don't do 'hlsearch' highlighting if the pattern matches everything.\n    if (!use_last_pat)\n    {\n\tchar c = *end;\n\tint  empty;\n\n\t*end = NUL;\n\tempty = empty_pattern_magic(p, STRLEN(p), magic);\n\t*end = c;\n\tif (empty)\n\t    goto theend;\n    }\n\n    // found a non-empty pattern or //\n    *skiplen = (int)(p - ccline.cmdbuff);\n    *patlen = (int)(end - p);\n\n    // parse the address range\n    save_cursor = curwin->w_cursor;\n    curwin->w_cursor = is_state->search_start;\n    parse_cmd_address(&ea, &dummy, TRUE);\n    if (ea.addr_count > 0)\n    {\n\t// Allow for reverse match.\n\tif (ea.line2 < ea.line1)\n\t{\n\t    search_first_line = ea.line2;\n\t    search_last_line = ea.line1;\n\t}\n\telse\n\t{\n\t    search_first_line = ea.line1;\n\t    search_last_line = ea.line2;\n\t}\n    }\n    else if (cmd[0] == 's' && cmd[1] != 'o')\n    {\n\t// :s defaults to the current line\n\tsearch_first_line = curwin->w_cursor.lnum;\n\tsearch_last_line = curwin->w_cursor.lnum;\n    }\n\n    curwin->w_cursor = save_cursor;\n    retval = TRUE;\ntheend:\n    --emsg_off;\n    return retval;\n}\n\n    static void\nfinish_incsearch_highlighting(\n\tint gotesc,\n\tincsearch_state_T *is_state,\n\tint call_update_screen)\n{\n    if (!is_state->did_incsearch)\n\treturn;\n\n    is_state->did_incsearch = FALSE;\n    if (gotesc)\n\tcurwin->w_cursor = is_state->save_cursor;\n    else\n    {\n\tif (!EQUAL_POS(is_state->save_cursor, is_state->search_start))\n\t{\n\t    // put the '\" mark at the original position\n\t    curwin->w_cursor = is_state->save_cursor;\n\t    setpcmark();\n\t}\n\tcurwin->w_cursor = is_state->search_start;\n    }\n    restore_viewstate(&is_state->old_viewstate);\n    highlight_match = FALSE;\n\n    // by default search all lines\n    search_first_line = 0;\n    search_last_line = MAXLNUM;\n\n    magic_overruled = is_state->magic_overruled_save;\n\n    validate_cursor();\t// needed for TAB\n    status_redraw_all();\n    redraw_all_later(UPD_SOME_VALID);\n    if (call_update_screen)\n\tupdate_screen(UPD_SOME_VALID);\n}\n\n/*\n * Do 'incsearch' highlighting if desired.\n */\n    static void\nmay_do_incsearch_highlighting(\n\tint\t\t    firstc,\n\tlong\t\t    count,\n\tincsearch_state_T   *is_state)\n{\n    int\t\tskiplen, patlen;\n    int\t\tfound;  // do_search() result\n    pos_T\tend_pos;\n#ifdef FEAT_RELTIME\n    searchit_arg_T sia;\n#endif\n    int\t\tnext_char;\n    int\t\tuse_last_pat;\n    int\t\tdid_do_incsearch = is_state->did_incsearch;\n    int\t\tsearch_delim;\n\n    // Parsing range may already set the last search pattern.\n    // NOTE: must call restore_last_search_pattern() before returning!\n    save_last_search_pattern();\n\n    if (!do_incsearch_highlighting(firstc, &search_delim, is_state,\n\t\t\t\t\t\t\t    &skiplen, &patlen))\n    {\n\trestore_last_search_pattern();\n\tfinish_incsearch_highlighting(FALSE, is_state, TRUE);\n\tif (did_do_incsearch && vpeekc() == NUL)\n\t    // may have skipped a redraw, do it now\n\t    redrawcmd();\n\treturn;\n    }\n\n    // If there is a character waiting, search and redraw later.\n    if (char_avail())\n    {\n\trestore_last_search_pattern();\n\tis_state->incsearch_postponed = TRUE;\n\treturn;\n    }\n    is_state->incsearch_postponed = FALSE;\n\n    if (search_first_line == 0)\n\t// start at the original cursor position\n\tcurwin->w_cursor = is_state->search_start;\n    else if (search_first_line > curbuf->b_ml.ml_line_count)\n    {\n\t// start after the last line\n\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\tcurwin->w_cursor.col = MAXCOL;\n    }\n    else\n    {\n\t// start at the first line in the range\n\tcurwin->w_cursor.lnum = search_first_line;\n\tcurwin->w_cursor.col = 0;\n    }\n\n    // Use the previous pattern for \":s//\".\n    next_char = ccline.cmdbuff[skiplen + patlen];\n    use_last_pat = patlen == 0 && skiplen > 0\n\t\t\t\t   && ccline.cmdbuff[skiplen - 1] == next_char;\n\n    // If there is no pattern, don't do anything.\n    if (patlen == 0 && !use_last_pat)\n    {\n\tfound = 0;\n\tset_no_hlsearch(TRUE); // turn off previous highlight\n\tredraw_all_later(UPD_SOME_VALID);\n    }\n    else\n    {\n\tint search_flags = SEARCH_OPT + SEARCH_NOOF + SEARCH_PEEK;\n\n\tcursor_off();\t// so the user knows we're busy\n\tout_flush();\n\t++emsg_off;\t// so it doesn't beep if bad expr\n\tif (!p_hls)\n\t    search_flags += SEARCH_KEEP;\n\tif (search_first_line != 0)\n\t    search_flags += SEARCH_START;\n\tccline.cmdbuff[skiplen + patlen] = NUL;\n#ifdef FEAT_RELTIME\n\tCLEAR_FIELD(sia);\n\t// Set the time limit to half a second.\n\tsia.sa_tm = 500;\n#endif\n\tfound = do_search(NULL, firstc == ':' ? '/' : firstc, search_delim,\n\t\t\t\t ccline.cmdbuff + skiplen, count, search_flags,\n#ifdef FEAT_RELTIME\n\t\t&sia\n#else\n\t\tNULL\n#endif\n\t\t);\n\tccline.cmdbuff[skiplen + patlen] = next_char;\n\t--emsg_off;\n\n\tif (curwin->w_cursor.lnum < search_first_line\n\t\t|| curwin->w_cursor.lnum > search_last_line)\n\t{\n\t    // match outside of address range\n\t    found = 0;\n\t    curwin->w_cursor = is_state->search_start;\n\t}\n\n\t// if interrupted while searching, behave like it failed\n\tif (got_int)\n\t{\n\t    (void)vpeekc();\t// remove <C-C> from input stream\n\t    got_int = FALSE;\t// don't abandon the command line\n\t    found = 0;\n\t}\n\telse if (char_avail())\n\t    // cancelled searching because a char was typed\n\t    is_state->incsearch_postponed = TRUE;\n    }\n    if (found != 0)\n\thighlight_match = TRUE;\t\t// highlight position\n    else\n\thighlight_match = FALSE;\t// remove highlight\n\n    // First restore the old curwin values, so the screen is positioned in the\n    // same way as the actual search command.\n    restore_viewstate(&is_state->old_viewstate);\n    changed_cline_bef_curs();\n    update_topline();\n\n    if (found != 0)\n    {\n\tpos_T\t    save_pos = curwin->w_cursor;\n\n\tis_state->match_start = curwin->w_cursor;\n\tset_search_match(&curwin->w_cursor);\n\tvalidate_cursor();\n\tend_pos = curwin->w_cursor;\n\tis_state->match_end = end_pos;\n\tcurwin->w_cursor = save_pos;\n    }\n    else\n\tend_pos = curwin->w_cursor; // shutup gcc 4\n\n    // Disable 'hlsearch' highlighting if the pattern matches everything.\n    // Avoids a flash when typing \"foo\\|\".\n    if (!use_last_pat)\n    {\n\tnext_char = ccline.cmdbuff[skiplen + patlen];\n\tccline.cmdbuff[skiplen + patlen] = NUL;\n\tif (empty_pattern(ccline.cmdbuff + skiplen, search_delim)\n\t\t\t\t\t\t\t       && !no_hlsearch)\n\t{\n\t    redraw_all_later(UPD_SOME_VALID);\n\t    set_no_hlsearch(TRUE);\n\t}\n\tccline.cmdbuff[skiplen + patlen] = next_char;\n    }\n\n    validate_cursor();\n\n    // May redraw the status line to show the cursor position.\n    if (p_ru && curwin->w_status_height > 0)\n\tcurwin->w_redr_status = TRUE;\n\n    update_screen(UPD_SOME_VALID);\n    highlight_match = FALSE;\n    restore_last_search_pattern();\n\n    // Leave it at the end to make CTRL-R CTRL-W work.  But not when beyond the\n    // end of the pattern, e.g. for \":s/pat/\".\n    if (ccline.cmdbuff[skiplen + patlen] != NUL)\n\tcurwin->w_cursor = is_state->search_start;\n    else if (found != 0)\n\tcurwin->w_cursor = end_pos;\n\n    msg_starthere();\n    redrawcmdline();\n    is_state->did_incsearch = TRUE;\n}\n\n/*\n * May adjust 'incsearch' highlighting for typing CTRL-G and CTRL-T, go to next\n * or previous match.\n * Returns FAIL when jumping to cmdline_not_changed;\n */\n    static int\nmay_adjust_incsearch_highlighting(\n\tint\t\t\tfirstc,\n\tlong\t\t\tcount,\n\tincsearch_state_T\t*is_state,\n\tint\t\t\tc)\n{\n    int\t    skiplen, patlen;\n    pos_T   t;\n    char_u  *pat;\n    int\t    search_flags = SEARCH_NOOF;\n    int\t    i;\n    int\t    save;\n    int\t    search_delim;\n\n    // Parsing range may already set the last search pattern.\n    // NOTE: must call restore_last_search_pattern() before returning!\n    save_last_search_pattern();\n\n    if (!do_incsearch_highlighting(firstc, &search_delim, is_state,\n\t\t\t\t\t\t\t    &skiplen, &patlen))\n    {\n\trestore_last_search_pattern();\n\treturn OK;\n    }\n    if (patlen == 0 && ccline.cmdbuff[skiplen] == NUL)\n    {\n\trestore_last_search_pattern();\n\treturn FAIL;\n    }\n\n    if (search_delim == ccline.cmdbuff[skiplen])\n    {\n\tpat = last_search_pattern();\n\tif (pat == NULL)\n\t{\n\t    restore_last_search_pattern();\n\t    return FAIL;\n\t}\n\tskiplen = 0;\n\tpatlen = (int)STRLEN(pat);\n    }\n    else\n\tpat = ccline.cmdbuff + skiplen;\n\n    cursor_off();\n    out_flush();\n    if (c == Ctrl_G)\n    {\n\tt = is_state->match_end;\n\tif (LT_POS(is_state->match_start, is_state->match_end))\n\t    // Start searching at the end of the match not at the beginning of\n\t    // the next column.\n\t    (void)decl(&t);\n\tsearch_flags += SEARCH_COL;\n    }\n    else\n\tt = is_state->match_start;\n    if (!p_hls)\n\tsearch_flags += SEARCH_KEEP;\n    ++emsg_off;\n    save = pat[patlen];\n    pat[patlen] = NUL;\n    i = searchit(curwin, curbuf, &t, NULL,\n\t\t c == Ctrl_G ? FORWARD : BACKWARD,\n\t\t pat, count, search_flags, RE_SEARCH, NULL);\n    --emsg_off;\n    pat[patlen] = save;\n    if (i)\n    {\n\tis_state->search_start = is_state->match_start;\n\tis_state->match_end = t;\n\tis_state->match_start = t;\n\tif (c == Ctrl_T && firstc != '?')\n\t{\n\t    // Move just before the current match, so that when nv_search\n\t    // finishes the cursor will be put back on the match.\n\t    is_state->search_start = t;\n\t    (void)decl(&is_state->search_start);\n\t}\n\telse if (c == Ctrl_G && firstc == '?')\n\t{\n\t    // Move just after the current match, so that when nv_search\n\t    // finishes the cursor will be put back on the match.\n\t    is_state->search_start = t;\n\t    (void)incl(&is_state->search_start);\n\t}\n\tif (LT_POS(t, is_state->search_start) && c == Ctrl_G)\n\t{\n\t    // wrap around\n\t    is_state->search_start = t;\n\t    if (firstc == '?')\n\t\t(void)incl(&is_state->search_start);\n\t    else\n\t\t(void)decl(&is_state->search_start);\n\t}\n\n\tset_search_match(&is_state->match_end);\n\tcurwin->w_cursor = is_state->match_start;\n\tchanged_cline_bef_curs();\n\tupdate_topline();\n\tvalidate_cursor();\n\thighlight_match = TRUE;\n\tsave_viewstate(&is_state->old_viewstate);\n\tupdate_screen(UPD_NOT_VALID);\n\thighlight_match = FALSE;\n\tredrawcmdline();\n\tcurwin->w_cursor = is_state->match_end;\n    }\n    else\n\tvim_beep(BO_ERROR);\n    restore_last_search_pattern();\n    return FAIL;\n}\n\n/*\n * When CTRL-L typed: add character from the match to the pattern.\n * May set \"*c\" to the added character.\n * Return OK when jumping to cmdline_not_changed.\n */\n    static int\nmay_add_char_to_search(int firstc, int *c, incsearch_state_T *is_state)\n{\n    int\t\tskiplen, patlen, search_delim;\n\n    // Parsing range may already set the last search pattern.\n    // NOTE: must call restore_last_search_pattern() before returning!\n    save_last_search_pattern();\n\n    if (!do_incsearch_highlighting(firstc, &search_delim, is_state,\n\t\t\t\t\t\t\t    &skiplen, &patlen))\n    {\n\trestore_last_search_pattern();\n\treturn FAIL;\n    }\n    restore_last_search_pattern();\n\n    // Add a character from under the cursor for 'incsearch'.\n    if (is_state->did_incsearch)\n    {\n\tcurwin->w_cursor = is_state->match_end;\n\t*c = gchar_cursor();\n\tif (*c != NUL)\n\t{\n\t    // If 'ignorecase' and 'smartcase' are set and the\n\t    // command line has no uppercase characters, convert\n\t    // the character to lowercase.\n\t    if (p_ic && p_scs && !pat_has_uppercase(ccline.cmdbuff + skiplen))\n\t\t*c = MB_TOLOWER(*c);\n\t    if (*c == search_delim || vim_strchr((char_u *)(\n\t\t\t     magic_isset() ? \"\\\\~^$.*[\" : \"\\\\^$\"), *c) != NULL)\n\t    {\n\t\t// put a backslash before special characters\n\t\tstuffcharReadbuff(*c);\n\t\t*c = '\\\\';\n\t    }\n\t    // add any composing characters\n\t    if (mb_char2len(*c) != mb_ptr2len(ml_get_cursor()))\n\t    {\n\t\tint save_c = *c;\n\n\t\twhile (mb_char2len(*c) != mb_ptr2len(ml_get_cursor()))\n\t\t{\n\t\t    curwin->w_cursor.col += mb_char2len(*c);\n\t\t    *c = gchar_cursor();\n\t\t    stuffcharReadbuff(*c);\n\t\t}\n\t\t*c = save_c;\n\t    }\n\t    return FAIL;\n\t}\n    }\n    return OK;\n}\n#endif\n\n#ifdef FEAT_ARABIC\n/*\n * Return TRUE if the command line has an Arabic character at or after \"start\"\n * for \"len\" bytes.\n */\n    static int\ncmdline_has_arabic(int start, int len)\n{\n    int\t    j;\n    int\t    mb_l;\n    int\t    u8c;\n    char_u  *p;\n    int\t    u8cc[MAX_MCO];\n\n    if (!enc_utf8)\n\treturn FALSE;\n\n    for (j = start; j < start + len; j += mb_l)\n    {\n\tp = ccline.cmdbuff + j;\n\tu8c = utfc_ptr2char_len(p, u8cc, start + len - j);\n\tmb_l = utfc_ptr2len_len(p, start + len - j);\n\tif (ARABIC_CHAR(u8c))\n\t    return TRUE;\n    }\n    return FALSE;\n}\n#endif\n\n    void\ncmdline_init(void)\n{\n    CLEAR_FIELD(ccline);\n}\n\n/*\n * Handle CTRL-\\ pressed in Command-line mode:\n * - CTRL-\\ CTRL-N goes to Normal mode\n * - CTRL-\\ CTRL-G goes to Insert mode when 'insertmode' is set\n * - CTRL-\\ e prompts for an expression.\n */\n    static int\ncmdline_handle_ctrl_bsl(int c, int *gotesc)\n{\n    ++no_mapping;\n    ++allow_keys;\n    c = plain_vgetc();\n    --no_mapping;\n    --allow_keys;\n\n    // CTRL-\\ e doesn't work when obtaining an expression, unless it\n    // is in a mapping.\n    if (c != Ctrl_N && c != Ctrl_G && (c != 'e'\n\t\t|| (ccline.cmdfirstc == '=' && KeyTyped)\n#ifdef FEAT_EVAL\n\t\t|| cmdline_star > 0\n#endif\n\t\t))\n    {\n\tvungetc(c);\n\treturn PROCESS_NEXT_KEY;\n    }\n\n#ifdef FEAT_EVAL\n    if (c == 'e')\n    {\n\tchar_u\t*p = NULL;\n\tint\tlen;\n\n\t/*\n\t * Replace the command line with the result of an expression.\n\t * This will call getcmdline() recursively in get_expr_register().\n\t */\n\tif (ccline.cmdpos == ccline.cmdlen)\n\t    new_cmdpos = 99999;\t// keep it at the end\n\telse\n\t    new_cmdpos = ccline.cmdpos;\n\n\tc = get_expr_register();\n\tif (c == '=')\n\t{\n\t    // Evaluate the expression.  Set \"textlock\" to avoid nasty things\n\t    // like going to another buffer.\n\t    ++textlock;\n\t    p = get_expr_line();\n\t    --textlock;\n\n\t    if (p != NULL)\n\t    {\n\t\tlen = (int)STRLEN(p);\n\t\tif (realloc_cmdbuff(len + 1) == OK)\n\t\t{\n\t\t    ccline.cmdlen = len;\n\t\t    STRCPY(ccline.cmdbuff, p);\n\t\t    vim_free(p);\n\n\t\t    // Restore the cursor or use the position set with\n\t\t    // set_cmdline_pos().\n\t\t    if (new_cmdpos > ccline.cmdlen)\n\t\t\tccline.cmdpos = ccline.cmdlen;\n\t\t    else\n\t\t\tccline.cmdpos = new_cmdpos;\n\n\t\t    KeyTyped = FALSE;\t// Don't do p_wc completion.\n\t\t    redrawcmd();\n\t\t    return CMDLINE_CHANGED;\n\t\t}\n\t\tvim_free(p);\n\t    }\n\t}\n\tbeep_flush();\n\tgot_int = FALSE;\t// don't abandon the command line\n\tdid_emsg = FALSE;\n\temsg_on_display = FALSE;\n\tredrawcmd();\n\treturn CMDLINE_NOT_CHANGED;\n    }\n#endif\n\n    if (c == Ctrl_G && p_im && restart_edit == 0)\n\trestart_edit = 'a';\n    *gotesc = TRUE;\t// will free ccline.cmdbuff after putting it\n\t\t\t// in history\n    return GOTO_NORMAL_MODE;\n}\n\n/*\n * Completion for 'wildchar' or 'wildcharm' key.\n * - hitting <ESC> twice means: abandon command line.\n * - wildcard expansion is only done when the 'wildchar' key is really\n *   typed, not when it comes from a macro\n * Returns CMDLINE_CHANGED if command line is changed or CMDLINE_NOT_CHANGED.\n */\n    static int\ncmdline_wildchar_complete(\n\tint\t\tc,\n\tint\t\tescape,\n\tint\t\t*did_wild_list,\n\tint\t\t*wim_index_p,\n\texpand_T\t*xp,\n\tint\t\t*gotesc)\n{\n    int\t\twim_index = *wim_index_p;\n    int\t\tres;\n    int\t\tj;\n    int\t\toptions = WILD_NO_BEEP;\n\n    if (wim_flags[wim_index] & WIM_BUFLASTUSED)\n\toptions |= WILD_BUFLASTUSED;\n    if (xp->xp_numfiles > 0)   // typed p_wc at least twice\n    {\n\t// if 'wildmode' contains \"list\" may still need to list\n\tif (xp->xp_numfiles > 1\n\t\t&& !*did_wild_list\n\t\t&& ((wim_flags[wim_index] & WIM_LIST)\n\t\t    || (p_wmnu && (wim_flags[wim_index] & WIM_FULL) != 0)))\n\t{\n\t    (void)showmatches(xp,\n\t\t    p_wmnu && ((wim_flags[wim_index] & WIM_LIST) == 0));\n\t    redrawcmd();\n\t    *did_wild_list = TRUE;\n\t}\n\tif (wim_flags[wim_index] & WIM_LONGEST)\n\t    res = nextwild(xp, WILD_LONGEST, options, escape);\n\telse if (wim_flags[wim_index] & WIM_FULL)\n\t    res = nextwild(xp, WILD_NEXT, options, escape);\n\telse\n\t    res = OK;\t    // don't insert 'wildchar' now\n    }\n    else\t\t    // typed p_wc first time\n    {\n\twim_index = 0;\n\tj = ccline.cmdpos;\n\t// if 'wildmode' first contains \"longest\", get longest\n\t// common part\n\tif (wim_flags[0] & WIM_LONGEST)\n\t    res = nextwild(xp, WILD_LONGEST, options, escape);\n\telse\n\t    res = nextwild(xp, WILD_EXPAND_KEEP, options, escape);\n\n\t// if interrupted while completing, behave like it failed\n\tif (got_int)\n\t{\n\t    (void)vpeekc();\t// remove <C-C> from input stream\n\t    got_int = FALSE;\t// don't abandon the command line\n\t    (void)ExpandOne(xp, NULL, NULL, 0, WILD_FREE);\n\t    xp->xp_context = EXPAND_NOTHING;\n\t    *wim_index_p = wim_index;\n\t    return CMDLINE_CHANGED;\n\t}\n\n\t// when more than one match, and 'wildmode' first contains\n\t// \"list\", or no change and 'wildmode' contains \"longest,list\",\n\t// list all matches\n\tif (res == OK && xp->xp_numfiles > 1)\n\t{\n\t    // a \"longest\" that didn't do anything is skipped (but not\n\t    // \"list:longest\")\n\t    if (wim_flags[0] == WIM_LONGEST && ccline.cmdpos == j)\n\t\twim_index = 1;\n\t    if ((wim_flags[wim_index] & WIM_LIST)\n\t\t    || (p_wmnu && (wim_flags[wim_index] & WIM_FULL) != 0))\n\t    {\n\t\tif (!(wim_flags[0] & WIM_LONGEST))\n\t\t{\n\t\t    int p_wmnu_save = p_wmnu;\n\n\t\t    p_wmnu = 0;\n\n\t\t    // remove match\n\t\t    nextwild(xp, WILD_PREV, 0, escape);\n\t\t    p_wmnu = p_wmnu_save;\n\t\t}\n\t\t(void)showmatches(xp, p_wmnu\n\t\t\t&& ((wim_flags[wim_index] & WIM_LIST) == 0));\n\t\tredrawcmd();\n\t\t*did_wild_list = TRUE;\n\t\tif (wim_flags[wim_index] & WIM_LONGEST)\n\t\t    nextwild(xp, WILD_LONGEST, options, escape);\n\t\telse if (wim_flags[wim_index] & WIM_FULL)\n\t\t    nextwild(xp, WILD_NEXT, options, escape);\n\t    }\n\t    else\n\t\tvim_beep(BO_WILD);\n\t}\n\telse if (xp->xp_numfiles == -1)\n\t    xp->xp_context = EXPAND_NOTHING;\n    }\n    if (wim_index < 3)\n\t++wim_index;\n    if (c == ESC)\n\t*gotesc = TRUE;\n\n    *wim_index_p = wim_index;\n    return (res == OK) ? CMDLINE_CHANGED : CMDLINE_NOT_CHANGED;\n}\n\n/*\n * Handle backspace, delete and CTRL-W keys in the command-line mode.\n * Returns:\n *  CMDLINE_NOT_CHANGED - if the command line is not changed\n *  CMDLINE_CHANGED - if the command line is changed\n *  GOTO_NORMAL_MODE - go back to normal mode\n */\n    static int\ncmdline_erase_chars(\n\tint c,\n\tint indent\n#ifdef FEAT_SEARCH_EXTRA\n\t, incsearch_state_T *isp\n#endif\n\t)\n{\n    int\t\ti;\n    int\t\tj;\n\n    if (c == K_KDEL)\n\tc = K_DEL;\n\n    /*\n     * Delete current character is the same as backspace on next\n     * character, except at end of line.\n     */\n    if (c == K_DEL && ccline.cmdpos != ccline.cmdlen)\n\t++ccline.cmdpos;\n    if (has_mbyte && c == K_DEL)\n\tccline.cmdpos += mb_off_next(ccline.cmdbuff,\n\t\tccline.cmdbuff + ccline.cmdpos);\n    if (ccline.cmdpos > 0)\n    {\n\tchar_u *p;\n\n\tj = ccline.cmdpos;\n\tp = ccline.cmdbuff + j;\n\tif (has_mbyte)\n\t{\n\t    p = mb_prevptr(ccline.cmdbuff, p);\n\t    if (c == Ctrl_W)\n\t    {\n\t\twhile (p > ccline.cmdbuff && vim_isspace(*p))\n\t\t    p = mb_prevptr(ccline.cmdbuff, p);\n\t\ti = mb_get_class(p);\n\t\twhile (p > ccline.cmdbuff && mb_get_class(p) == i)\n\t\t    p = mb_prevptr(ccline.cmdbuff, p);\n\t\tif (mb_get_class(p) != i)\n\t\t    p += (*mb_ptr2len)(p);\n\t    }\n\t}\n\telse if (c == Ctrl_W)\n\t{\n\t    while (p > ccline.cmdbuff && vim_isspace(p[-1]))\n\t\t--p;\n\t    if (p > ccline.cmdbuff)\n\t    {\n\t\ti = vim_iswordc(p[-1]);\n\t\twhile (p > ccline.cmdbuff && !vim_isspace(p[-1])\n\t\t\t&& vim_iswordc(p[-1]) == i)\n\t\t    --p;\n\t    }\n\t}\n\telse\n\t    --p;\n\tccline.cmdpos = (int)(p - ccline.cmdbuff);\n\tccline.cmdlen -= j - ccline.cmdpos;\n\ti = ccline.cmdpos;\n\twhile (i < ccline.cmdlen)\n\t    ccline.cmdbuff[i++] = ccline.cmdbuff[j++];\n\n\t// Truncate at the end, required for multi-byte chars.\n\tccline.cmdbuff[ccline.cmdlen] = NUL;\n#ifdef FEAT_SEARCH_EXTRA\n\tif (ccline.cmdlen == 0)\n\t{\n\t    isp->search_start = isp->save_cursor;\n\t    // save view settings, so that the screen\n\t    // won't be restored at the wrong position\n\t    isp->old_viewstate = isp->init_viewstate;\n\t}\n#endif\n\tredrawcmd();\n    }\n    else if (ccline.cmdlen == 0 && c != Ctrl_W\n\t    && ccline.cmdprompt == NULL && indent == 0)\n    {\n\t// In ex and debug mode it doesn't make sense to return.\n\tif (exmode_active\n#ifdef FEAT_EVAL\n\t\t|| ccline.cmdfirstc == '>'\n#endif\n\t   )\n\t    return CMDLINE_NOT_CHANGED;\n\n\tVIM_CLEAR(ccline.cmdbuff);\t// no commandline to return\n\tif (!cmd_silent)\n\t{\n#ifdef FEAT_RIGHTLEFT\n\t    if (cmdmsg_rl)\n\t\tmsg_col = Columns;\n\t    else\n#endif\n\t\tmsg_col = 0;\n\t    msg_putchar(' ');\t\t// delete ':'\n\t}\n#ifdef FEAT_SEARCH_EXTRA\n\tif (ccline.cmdlen == 0)\n\t    isp->search_start = isp->save_cursor;\n#endif\n\tredraw_cmdline = TRUE;\n\treturn GOTO_NORMAL_MODE;\n    }\n    return CMDLINE_CHANGED;\n}\n\n/*\n * Handle the CTRL-^ key in the command-line mode and toggle the use of the\n * language :lmap mappings and/or Input Method.\n */\n    static void\ncmdline_toggle_langmap(long *b_im_ptr)\n{\n    if (map_to_exists_mode((char_u *)\"\", MODE_LANGMAP, FALSE))\n    {\n\t// \":lmap\" mappings exists, toggle use of mappings.\n\tState ^= MODE_LANGMAP;\n#ifdef HAVE_INPUT_METHOD\n\tim_set_active(FALSE);\t// Disable input method\n#endif\n\tif (b_im_ptr != NULL)\n\t{\n\t    if (State & MODE_LANGMAP)\n\t\t*b_im_ptr = B_IMODE_LMAP;\n\t    else\n\t\t*b_im_ptr = B_IMODE_NONE;\n\t}\n    }\n#ifdef HAVE_INPUT_METHOD\n    else\n    {\n\t// There are no \":lmap\" mappings, toggle IM.  When\n\t// 'imdisable' is set don't try getting the status, it's\n\t// always off.\n\tif ((p_imdisable && b_im_ptr != NULL)\n\t\t? *b_im_ptr == B_IMODE_IM : im_get_status())\n\t{\n\t    im_set_active(FALSE);\t// Disable input method\n\t    if (b_im_ptr != NULL)\n\t\t*b_im_ptr = B_IMODE_NONE;\n\t}\n\telse\n\t{\n\t    im_set_active(TRUE);\t// Enable input method\n\t    if (b_im_ptr != NULL)\n\t\t*b_im_ptr = B_IMODE_IM;\n\t}\n    }\n#endif\n    if (b_im_ptr != NULL)\n    {\n\tif (b_im_ptr == &curbuf->b_p_iminsert)\n\t    set_iminsert_global();\n\telse\n\t    set_imsearch_global();\n    }\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t// may show different cursor shape\n#endif\n#if defined(FEAT_KEYMAP)\n    // Show/unshow value of 'keymap' in status lines later.\n    status_redraw_curbuf();\n#endif\n}\n\n/*\n * Handle the CTRL-R key in the command-line mode and insert the contents of a\n * numbered or named register.\n */\n    static int\ncmdline_insert_reg(int *gotesc UNUSED)\n{\n    int\t\ti;\n    int\t\tc;\n    int\t\tliterally = FALSE;\n#ifdef FEAT_EVAL\n    int\t\tsave_new_cmdpos = new_cmdpos;\n#endif\n\n#ifdef USE_ON_FLY_SCROLL\n    dont_scroll = TRUE;\t// disallow scrolling here\n#endif\n    putcmdline('\"', TRUE);\n    ++no_mapping;\n    ++allow_keys;\n    i = c = plain_vgetc();\t// CTRL-R <char>\n    if (i == Ctrl_O)\n\ti = Ctrl_R;\t\t// CTRL-R CTRL-O == CTRL-R CTRL-R\n    if (i == Ctrl_R)\n\tc = plain_vgetc();\t// CTRL-R CTRL-R <char>\n    extra_char = NUL;\n    --no_mapping;\n    --allow_keys;\n#ifdef FEAT_EVAL\n    /*\n     * Insert the result of an expression.\n     */\n    new_cmdpos = -1;\n    if (c == '=')\n    {\n\tif (ccline.cmdfirstc == '='  // can't do this recursively\n\t\t|| cmdline_star > 0) // or when typing a password\n\t{\n\t    beep_flush();\n\t    c = ESC;\n\t}\n\telse\n\t    c = get_expr_register();\n    }\n#endif\n    if (c != ESC)\t    // use ESC to cancel inserting register\n    {\n\tliterally = i == Ctrl_R\n#ifdef FEAT_CLIPBOARD\n\t\t\t|| (clip_star.available && c == '*')\n\t\t\t|| (clip_plus.available && c == '+')\n#endif\n\t\t\t;\n\tcmdline_paste(c, literally, FALSE);\n\n#ifdef FEAT_EVAL\n\t// When there was a serious error abort getting the\n\t// command line.\n\tif (aborting())\n\t{\n\t    *gotesc = TRUE;  // will free ccline.cmdbuff after\n\t    // putting it in history\n\t    return GOTO_NORMAL_MODE;\n\t}\n#endif\n\tKeyTyped = FALSE;\t// Don't do p_wc completion.\n#ifdef FEAT_EVAL\n\tif (new_cmdpos >= 0)\n\t{\n\t    // set_cmdline_pos() was used\n\t    if (new_cmdpos > ccline.cmdlen)\n\t\tccline.cmdpos = ccline.cmdlen;\n\t    else\n\t\tccline.cmdpos = new_cmdpos;\n\t}\n#endif\n    }\n#ifdef FEAT_EVAL\n    new_cmdpos = save_new_cmdpos;\n#endif\n\n    // remove the double quote\n    redrawcmd();\n\n    // With \"literally\": the command line has already changed.\n    // Else: the text has been stuffed, but the command line didn't change yet.\n    return literally ? CMDLINE_CHANGED : CMDLINE_NOT_CHANGED;\n}\n\n/*\n * Handle the Left and Right mouse clicks in the command-line mode.\n */\n    static void\ncmdline_left_right_mouse(int c, int *ignore_drag_release)\n{\n    if (c == K_LEFTRELEASE || c == K_RIGHTRELEASE)\n\t*ignore_drag_release = TRUE;\n    else\n\t*ignore_drag_release = FALSE;\n# ifdef FEAT_GUI\n    // When GUI is active, also move when 'mouse' is empty\n    if (!gui.in_use)\n# endif\n\tif (!mouse_has(MOUSE_COMMAND))\n\t    return;\n# ifdef FEAT_CLIPBOARD\n    if (mouse_row < cmdline_row && clip_star.available)\n    {\n\tint\t    button, is_click, is_drag;\n\n\t/*\n\t * Handle modeless selection.\n\t */\n\tbutton = get_mouse_button(KEY2TERMCAP1(c),\n\t\t&is_click, &is_drag);\n\tif (mouse_model_popup() && button == MOUSE_LEFT\n\t\t&& (mod_mask & MOD_MASK_SHIFT))\n\t{\n\t    // Translate shift-left to right button.\n\t    button = MOUSE_RIGHT;\n\t    mod_mask &= ~MOD_MASK_SHIFT;\n\t}\n\tclip_modeless(button, is_click, is_drag);\n\treturn;\n    }\n# endif\n\n    set_cmdspos();\n    for (ccline.cmdpos = 0; ccline.cmdpos < ccline.cmdlen;\n\t    ++ccline.cmdpos)\n    {\n\tint\ti;\n\n\ti = cmdline_charsize(ccline.cmdpos);\n\tif (mouse_row <= cmdline_row + ccline.cmdspos / Columns\n\t\t&& mouse_col < ccline.cmdspos % Columns + i)\n\t    break;\n\tif (has_mbyte)\n\t{\n\t    // Count \">\" for double-wide char that doesn't fit.\n\t    correct_cmdspos(ccline.cmdpos, i);\n\t    ccline.cmdpos += (*mb_ptr2len)(ccline.cmdbuff\n\t\t    + ccline.cmdpos) - 1;\n\t}\n\tccline.cmdspos += i;\n    }\n}\n\n/*\n * Handle the Up, Down, Page Up, Page down, CTRL-N and CTRL-P key in the\n * command-line mode. The pressed key is in 'c'.\n * Returns:\n *  CMDLINE_NOT_CHANGED - if the command line is not changed\n *  CMDLINE_CHANGED - if the command line is changed\n *  GOTO_NORMAL_MODE - go back to normal mode\n */\n    static int\ncmdline_browse_history(\n\tint\tc,\n\tint\tfirstc,\n\tchar_u\t**curcmdstr,\n\tint\thistype,\n\tint\t*hiscnt_p,\n\texpand_T *xp)\n{\n    int\t\ti;\n    int\t\tj;\n    char_u\t*lookfor = *curcmdstr;\n    int\t\thiscnt = *hiscnt_p;\n    int\t\tres;\n\n    if (get_hislen() == 0 || firstc == NUL)\t// no history\n\treturn CMDLINE_NOT_CHANGED;\n\n    i = hiscnt;\n\n    // save current command string so it can be restored later\n    if (lookfor == NULL)\n    {\n\tif ((lookfor = vim_strsave(ccline.cmdbuff)) == NULL)\n\t    return CMDLINE_NOT_CHANGED;\n\tlookfor[ccline.cmdpos] = NUL;\n    }\n\n    j = (int)STRLEN(lookfor);\n    for (;;)\n    {\n\t// one step backwards\n\tif (c == K_UP|| c == K_S_UP || c == Ctrl_P\n\t\t|| c == K_PAGEUP || c == K_KPAGEUP)\n\t{\n\t    if (hiscnt == get_hislen())\t// first time\n\t\thiscnt = *get_hisidx(histype);\n\t    else if (hiscnt == 0 && *get_hisidx(histype)\n\t\t    != get_hislen() - 1)\n\t\thiscnt = get_hislen() - 1;\n\t    else if (hiscnt != *get_hisidx(histype) + 1)\n\t\t--hiscnt;\n\t    else\t\t\t// at top of list\n\t    {\n\t\thiscnt = i;\n\t\tbreak;\n\t    }\n\t}\n\telse    // one step forwards\n\t{\n\t    // on last entry, clear the line\n\t    if (hiscnt == *get_hisidx(histype))\n\t    {\n\t\thiscnt = get_hislen();\n\t\tbreak;\n\t    }\n\n\t    // not on a history line, nothing to do\n\t    if (hiscnt == get_hislen())\n\t\tbreak;\n\t    if (hiscnt == get_hislen() - 1)   // wrap around\n\t\thiscnt = 0;\n\t    else\n\t\t++hiscnt;\n\t}\n\tif (hiscnt < 0 || get_histentry(histype)[hiscnt].hisstr\n\t\t== NULL)\n\t{\n\t    hiscnt = i;\n\t    break;\n\t}\n\tif ((c != K_UP && c != K_DOWN)\n\t\t|| hiscnt == i\n\t\t|| STRNCMP(get_histentry(histype)[hiscnt].hisstr,\n\t\t    lookfor, (size_t)j) == 0)\n\t    break;\n    }\n\n    if (hiscnt != i)\t// jumped to other entry\n    {\n\tchar_u\t*p;\n\tint\t\tlen;\n\tint\t\told_firstc;\n\n\tVIM_CLEAR(ccline.cmdbuff);\n\txp->xp_context = EXPAND_NOTHING;\n\tif (hiscnt == get_hislen())\n\t    p = lookfor;\t// back to the old one\n\telse\n\t    p = get_histentry(histype)[hiscnt].hisstr;\n\n\tif (histype == HIST_SEARCH\n\t\t&& p != lookfor\n\t\t&& (old_firstc = p[STRLEN(p) + 1]) != firstc)\n\t{\n\t    // Correct for the separator character used when\n\t    // adding the history entry vs the one used now.\n\t    // First loop: count length.\n\t    // Second loop: copy the characters.\n\t    for (i = 0; i <= 1; ++i)\n\t    {\n\t\tlen = 0;\n\t\tfor (j = 0; p[j] != NUL; ++j)\n\t\t{\n\t\t    // Replace old sep with new sep, unless it is\n\t\t    // escaped.\n\t\t    if (p[j] == old_firstc\n\t\t\t    && (j == 0 || p[j - 1] != '\\\\'))\n\t\t    {\n\t\t\tif (i > 0)\n\t\t\t    ccline.cmdbuff[len] = firstc;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// Escape new sep, unless it is already\n\t\t\t// escaped.\n\t\t\tif (p[j] == firstc\n\t\t\t\t&& (j == 0 || p[j - 1] != '\\\\'))\n\t\t\t{\n\t\t\t    if (i > 0)\n\t\t\t\tccline.cmdbuff[len] = '\\\\';\n\t\t\t    ++len;\n\t\t\t}\n\t\t\tif (i > 0)\n\t\t\t    ccline.cmdbuff[len] = p[j];\n\t\t    }\n\t\t    ++len;\n\t\t}\n\t\tif (i == 0)\n\t\t{\n\t\t    alloc_cmdbuff(len);\n\t\t    if (ccline.cmdbuff == NULL)\n\t\t    {\n\t\t\tres = GOTO_NORMAL_MODE;\n\t\t\tgoto done;\n\t\t    }\n\t\t}\n\t    }\n\t    ccline.cmdbuff[len] = NUL;\n\t}\n\telse\n\t{\n\t    alloc_cmdbuff((int)STRLEN(p));\n\t    if (ccline.cmdbuff == NULL)\n\t    {\n\t\tres = GOTO_NORMAL_MODE;\n\t\tgoto done;\n\t    }\n\t    STRCPY(ccline.cmdbuff, p);\n\t}\n\n\tccline.cmdpos = ccline.cmdlen = (int)STRLEN(ccline.cmdbuff);\n\tredrawcmd();\n\tres = CMDLINE_CHANGED;\n\tgoto done;\n    }\n    beep_flush();\n    res = CMDLINE_NOT_CHANGED;\n\ndone:\n    *curcmdstr = lookfor;\n    *hiscnt_p = hiscnt;\n    return res;\n}\n\n/*\n * Initialize the current command-line info.\n */\n    static int\ninit_ccline(int firstc, int indent)\n{\n    ccline.overstrike = FALSE;\t\t    // always start in insert mode\n\n    /*\n     * set some variables for redrawcmd()\n     */\n    ccline.cmdfirstc = (firstc == '@' ? 0 : firstc);\n    ccline.cmdindent = (firstc > 0 ? indent : 0);\n\n    // alloc initial ccline.cmdbuff\n    alloc_cmdbuff(indent + 50);\n    if (ccline.cmdbuff == NULL)\n\treturn FAIL;\n    ccline.cmdlen = ccline.cmdpos = 0;\n    ccline.cmdbuff[0] = NUL;\n    sb_text_start_cmdline();\n\n    // autoindent for :insert and :append\n    if (firstc <= 0)\n    {\n\tvim_memset(ccline.cmdbuff, ' ', indent);\n\tccline.cmdbuff[indent] = NUL;\n\tccline.cmdpos = indent;\n\tccline.cmdspos = indent;\n\tccline.cmdlen = indent;\n    }\n\n    return OK;\n}\n\n/*\n * getcmdline() - accept a command line starting with firstc.\n *\n * firstc == ':'\t    get \":\" command line.\n * firstc == '/' or '?'\t    get search pattern\n * firstc == '='\t    get expression\n * firstc == '@'\t    get text for input() function\n * firstc == '>'\t    get text for debug mode\n * firstc == NUL\t    get text for :insert command\n * firstc == -1\t\t    like NUL, and break on CTRL-C\n *\n * The line is collected in ccline.cmdbuff, which is reallocated to fit the\n * command line.\n *\n * Careful: getcmdline() can be called recursively!\n *\n * Return pointer to allocated string if there is a commandline, NULL\n * otherwise.\n */\n    char_u *\ngetcmdline(\n    int\t\t  firstc,\n    long\t  count,\t// only used for incremental search\n    int\t\t  indent,\t// indent for inside conditionals\n    getline_opt_T do_concat UNUSED)\n{\n    return getcmdline_int(firstc, count, indent, TRUE);\n}\n\n    static char_u *\ngetcmdline_int(\n    int\t\tfirstc,\n    long\tcount UNUSED,\t// only used for incremental search\n    int\t\tindent,\t\t// indent for inside conditionals\n    int\t\tclear_ccline)\t// clear ccline first\n{\n    static int\tdepth = 0;\t    // call depth\n    int\t\tc;\n    int\t\ti;\n    int\t\tj;\n    int\t\tgotesc = FALSE;\t\t// TRUE when <ESC> just typed\n    int\t\tdo_abbr;\t\t// when TRUE check for abbr.\n    char_u\t*lookfor = NULL;\t// string to match\n    int\t\thiscnt;\t\t\t// current history line in use\n    int\t\thistype;\t\t// history type to be used\n#ifdef FEAT_SEARCH_EXTRA\n    incsearch_state_T\tis_state;\n#endif\n    int\t\tdid_wild_list = FALSE;\t// did wild_list() recently\n    int\t\twim_index = 0;\t\t// index in wim_flags[]\n    int\t\tres;\n    int\t\tsave_msg_scroll = msg_scroll;\n    int\t\tsave_State = State;\t// remember State when called\n    int\t\tsome_key_typed = FALSE;\t// one of the keys was typed\n    // mouse drag and release events are ignored, unless they are\n    // preceded with a mouse down event\n    int\t\tignore_drag_release = TRUE;\n#ifdef FEAT_EVAL\n    int\t\tbreak_ctrl_c = FALSE;\n#endif\n    expand_T\txpc;\n    long\t*b_im_ptr = NULL;\n    buf_T\t*b_im_ptr_buf = NULL;\t// buffer where b_im_ptr is valid\n    cmdline_info_T save_ccline;\n    int\t\tdid_save_ccline = FALSE;\n    int\t\tcmdline_type;\n    int\t\twild_type = 0;\n\n    // one recursion level deeper\n    ++depth;\n\n    if (ccline.cmdbuff != NULL)\n    {\n\t// Being called recursively.  Since ccline is global, we need to save\n\t// the current buffer and restore it when returning.\n\tsave_cmdline(&save_ccline);\n\tdid_save_ccline = TRUE;\n    }\n    if (clear_ccline)\n\tCLEAR_FIELD(ccline);\n\n#ifdef FEAT_EVAL\n    if (firstc == -1)\n    {\n\tfirstc = NUL;\n\tbreak_ctrl_c = TRUE;\n    }\n#endif\n#ifdef FEAT_RIGHTLEFT\n    // start without Hebrew mapping for a command line\n    if (firstc == ':' || firstc == '=' || firstc == '>')\n\tcmd_hkmap = 0;\n#endif\n\n#ifdef FEAT_SEARCH_EXTRA\n    init_incsearch_state(&is_state);\n#endif\n\n    if (init_ccline(firstc, indent) != OK)\n\tgoto theend;\t// out of memory\n\n    if (depth == 50)\n    {\n\t// Somehow got into a loop recursively calling getcmdline(), bail out.\n\temsg(_(e_command_too_recursive));\n\tgoto theend;\n    }\n\n    ExpandInit(&xpc);\n    ccline.xpc = &xpc;\n\n#ifdef FEAT_RIGHTLEFT\n    if (curwin->w_p_rl && *curwin->w_p_rlc == 's'\n\t\t\t\t\t  && (firstc == '/' || firstc == '?'))\n\tcmdmsg_rl = TRUE;\n    else\n\tcmdmsg_rl = FALSE;\n#endif\n\n    redir_off = TRUE;\t\t// don't redirect the typed command\n    if (!cmd_silent)\n    {\n\ti = msg_scrolled;\n\tmsg_scrolled = 0;\t\t// avoid wait_return() message\n\tgotocmdline(TRUE);\n\tmsg_scrolled += i;\n\tredrawcmdprompt();\t\t// draw prompt or indent\n\tset_cmdspos();\n    }\n    xpc.xp_context = EXPAND_NOTHING;\n    xpc.xp_backslash = XP_BS_NONE;\n#ifndef BACKSLASH_IN_FILENAME\n    xpc.xp_shell = FALSE;\n#endif\n\n#if defined(FEAT_EVAL)\n    if (ccline.input_fn)\n    {\n\txpc.xp_context = ccline.xp_context;\n\txpc.xp_pattern = ccline.cmdbuff;\n\txpc.xp_arg = ccline.xp_arg;\n    }\n#endif\n\n    /*\n     * Avoid scrolling when called by a recursive do_cmdline(), e.g. when\n     * doing \":@0\" when register 0 doesn't contain a CR.\n     */\n    msg_scroll = FALSE;\n\n    State = MODE_CMDLINE;\n\n    if (firstc == '/' || firstc == '?' || firstc == '@')\n    {\n\t// Use \":lmap\" mappings for search pattern and input().\n\tif (curbuf->b_p_imsearch == B_IMODE_USE_INSERT)\n\t    b_im_ptr = &curbuf->b_p_iminsert;\n\telse\n\t    b_im_ptr = &curbuf->b_p_imsearch;\n\tb_im_ptr_buf = curbuf;\n\tif (*b_im_ptr == B_IMODE_LMAP)\n\t    State |= MODE_LANGMAP;\n#ifdef HAVE_INPUT_METHOD\n\tim_set_active(*b_im_ptr == B_IMODE_IM);\n#endif\n    }\n#ifdef HAVE_INPUT_METHOD\n    else if (p_imcmdline)\n\tim_set_active(TRUE);\n#endif\n\n    setmouse();\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t\t// may show different cursor shape\n#endif\n\n    // When inside an autocommand for writing \"exiting\" may be set and\n    // terminal mode set to cooked.  Need to set raw mode here then.\n    settmode(TMODE_RAW);\n\n    // Trigger CmdlineEnter autocommands.\n    cmdline_type = firstc == NUL ? '-' : firstc;\n    trigger_cmd_autocmd(cmdline_type, EVENT_CMDLINEENTER);\n#ifdef FEAT_EVAL\n    if (!debug_mode)\n\tmay_trigger_modechanged();\n#endif\n\n    init_history();\n    hiscnt = get_hislen();\t// set hiscnt to impossible history value\n    histype = hist_char2type(firstc);\n\n#ifdef FEAT_DIGRAPHS\n    do_digraph(-1);\t\t// init digraph typeahead\n#endif\n\n    // If something above caused an error, reset the flags, we do want to type\n    // and execute commands. Display may be messed up a bit.\n    if (did_emsg)\n\tredrawcmd();\n\n#ifdef FEAT_STL_OPT\n    // Redraw the statusline in case it uses the current mode using the mode()\n    // function.\n    if (!cmd_silent && msg_scrolled == 0)\n    {\n\tint\tfound_one = FALSE;\n\twin_T\t*wp;\n\n\tFOR_ALL_WINDOWS(wp)\n\t    if (*p_stl != NUL || *wp->w_p_stl != NUL)\n\t    {\n\t\twp->w_redr_status = TRUE;\n\t\tfound_one = TRUE;\n\t    }\n\n\tif (*p_tal != NUL)\n\t{\n\t    redraw_tabline = TRUE;\n\t    found_one = TRUE;\n\t}\n\n\tif (found_one)\n\t    redraw_statuslines();\n    }\n#endif\n\n    did_emsg = FALSE;\n    got_int = FALSE;\n\n    /*\n     * Collect the command string, handling editing keys.\n     */\n    for (;;)\n    {\n\tint trigger_cmdlinechanged = TRUE;\n\tint end_wildmenu;\n\n\tredir_off = TRUE;\t// Don't redirect the typed command.\n\t\t\t\t// Repeated, because a \":redir\" inside\n\t\t\t\t// completion may switch it on.\n#ifdef USE_ON_FLY_SCROLL\n\tdont_scroll = FALSE;\t// allow scrolling here\n#endif\n\tquit_more = FALSE;\t// reset after CTRL-D which had a more-prompt\n\n\tdid_emsg = FALSE;\t// There can't really be a reason why an error\n\t\t\t\t// that occurs while typing a command should\n\t\t\t\t// cause the command not to be executed.\n\n\t// Trigger SafeState if nothing is pending.\n\tmay_trigger_safestate(xpc.xp_numfiles <= 0);\n\n\t// Get a character.  Ignore K_IGNORE and K_NOP, they should not do\n\t// anything, such as stop completion.\n\tdo\n\t{\n\t    cursorcmd();\t\t// set the cursor on the right spot\n\t    c = safe_vgetc();\n\t} while (c == K_IGNORE || c == K_NOP);\n\n\tif (c == K_COMMAND || c == K_SCRIPT_COMMAND)\n\t{\n\t    int\t    clen = ccline.cmdlen;\n\t    int\t    cc_count = aucmd_cmdline_changed_count;\n\n\t    if (do_cmdkey_command(c, DOCMD_NOWAIT) == OK)\n\t    {\n\t\t// Do not trigger CmdlineChanged below if:\n\t\t// - the length of the command line didn't change\n\t\t// - the <Cmd> mapping already triggered the event\n\t\tif (clen == ccline.cmdlen\n\t\t\t\t    || cc_count != aucmd_cmdline_changed_count)\n\t\t    trigger_cmdlinechanged = FALSE;\n\t\tgoto cmdline_changed;\n\t    }\n\t}\n\n\tif (KeyTyped)\n\t{\n\t    some_key_typed = TRUE;\n#ifdef FEAT_RIGHTLEFT\n\t    if (cmd_hkmap)\n\t\tc = hkmap(c);\n\t    if (cmdmsg_rl && !KeyStuffed)\n\t    {\n\t\t// Invert horizontal movements and operations.  Only when\n\t\t// typed by the user directly, not when the result of a\n\t\t// mapping.\n\t\tswitch (c)\n\t\t{\n\t\t    case K_RIGHT:   c = K_LEFT; break;\n\t\t    case K_S_RIGHT: c = K_S_LEFT; break;\n\t\t    case K_C_RIGHT: c = K_C_LEFT; break;\n\t\t    case K_LEFT:    c = K_RIGHT; break;\n\t\t    case K_S_LEFT:  c = K_S_RIGHT; break;\n\t\t    case K_C_LEFT:  c = K_C_RIGHT; break;\n\t\t}\n\t    }\n#endif\n\t}\n\n\t/*\n\t * Ignore got_int when CTRL-C was typed here.\n\t * Don't ignore it in :global, we really need to break then, e.g., for\n\t * \":g/pat/normal /pat\" (without the <CR>).\n\t * Don't ignore it for the input() function.\n\t */\n\tif ((c == Ctrl_C\n#ifdef UNIX\n\t\t|| c == intr_char\n#endif\n\t\t\t\t)\n#if defined(FEAT_EVAL) || defined(FEAT_CRYPT)\n\t\t&& firstc != '@'\n#endif\n#ifdef FEAT_EVAL\n\t\t// do clear got_int in Ex mode to avoid infinite Ctrl-C loop\n\t\t&& (!break_ctrl_c || exmode_active)\n#endif\n\t\t&& !global_busy)\n\t    got_int = FALSE;\n\n\t// free old command line when finished moving around in the history\n\t// list\n\tif (lookfor != NULL\n\t\t&& c != K_S_DOWN && c != K_S_UP\n\t\t&& c != K_DOWN && c != K_UP\n\t\t&& c != K_PAGEDOWN && c != K_PAGEUP\n\t\t&& c != K_KPAGEDOWN && c != K_KPAGEUP\n\t\t&& c != K_LEFT && c != K_RIGHT\n\t\t&& (xpc.xp_numfiles > 0 || (c != Ctrl_P && c != Ctrl_N)))\n\t    VIM_CLEAR(lookfor);\n\n\t/*\n\t * When there are matching completions to select <S-Tab> works like\n\t * CTRL-P (unless 'wc' is <S-Tab>).\n\t */\n\tif (c != p_wc && c == K_S_TAB && xpc.xp_numfiles > 0)\n\t    c = Ctrl_P;\n\n\tif (p_wmnu)\n\t    c = wildmenu_translate_key(&ccline, c, &xpc, did_wild_list);\n\n\tint key_is_wc = (c == p_wc && KeyTyped) || c == p_wcm;\n\tif ((cmdline_pum_active() || did_wild_list) && !key_is_wc)\n\t{\n\t    // Ctrl-Y: Accept the current selection and close the popup menu.\n\t    // Ctrl-E: cancel the cmdline popup menu and return the original\n\t    // text.\n\t    if (c == Ctrl_E || c == Ctrl_Y)\n\t    {\n\t\twild_type = (c == Ctrl_E) ? WILD_CANCEL : WILD_APPLY;\n\t\tif (nextwild(&xpc, wild_type, WILD_NO_BEEP,\n\t\t\t\t\t\t\tfirstc != '@') == FAIL)\n\t\t    break;\n\t    }\n\t}\n\n\t// The wildmenu is cleared if the pressed key is not used for\n\t// navigating the wild menu (i.e. the key is not 'wildchar' or\n\t// 'wildcharm' or Ctrl-N or Ctrl-P or Ctrl-A or Ctrl-L).\n\t// If the popup menu is displayed, then PageDown and PageUp keys are\n\t// also used to navigate the menu.\n\tend_wildmenu = (!key_is_wc\n\t\t&& c != Ctrl_N && c != Ctrl_P && c != Ctrl_A && c != Ctrl_L);\n\tend_wildmenu = end_wildmenu && (!cmdline_pum_active() ||\n\t\t\t    (c != K_PAGEDOWN && c != K_PAGEUP\n\t\t\t     && c != K_KPAGEDOWN && c != K_KPAGEUP));\n\n\t// free expanded names when finished walking through matches\n\tif (end_wildmenu)\n\t{\n\t    if (cmdline_pum_active())\n\t\tcmdline_pum_remove();\n\t    if (xpc.xp_numfiles != -1)\n\t\t(void)ExpandOne(&xpc, NULL, NULL, 0, WILD_FREE);\n\t    did_wild_list = FALSE;\n\t    if (!p_wmnu || (c != K_UP && c != K_DOWN))\n\t\txpc.xp_context = EXPAND_NOTHING;\n\t    wim_index = 0;\n\t    wildmenu_cleanup(&ccline);\n\t}\n\n\tif (p_wmnu)\n\t    c = wildmenu_process_key(&ccline, c, &xpc);\n\n\t// CTRL-\\ CTRL-N goes to Normal mode, CTRL-\\ CTRL-G goes to Insert\n\t// mode when 'insertmode' is set, CTRL-\\ e prompts for an expression.\n\tif (c == Ctrl_BSL)\n\t{\n\t    res = cmdline_handle_ctrl_bsl(c, &gotesc);\n\t    if (res == CMDLINE_CHANGED)\n\t\tgoto cmdline_changed;\n\t    else if (res == CMDLINE_NOT_CHANGED)\n\t\tgoto cmdline_not_changed;\n\t    else if (res == GOTO_NORMAL_MODE)\n\t\tgoto returncmd;\t\t// back to cmd mode\n\t    c = Ctrl_BSL;\t\t// backslash key not processed by\n\t\t\t\t\t// cmdline_handle_ctrl_bsl()\n\t}\n\n\tif (c == cedit_key || c == K_CMDWIN)\n\t{\n\t    // TODO: why is ex_normal_busy checked here?\n\t    if ((c == K_CMDWIN || ex_normal_busy == 0) && got_int == FALSE)\n\t    {\n\t\t/*\n\t\t * Open a window to edit the command line (and history).\n\t\t */\n\t\tc = open_cmdwin();\n\t\tsome_key_typed = TRUE;\n\t    }\n\t}\n#ifdef FEAT_DIGRAPHS\n\telse\n\t    c = do_digraph(c);\n#endif\n\n\tif (c == '\\n' || c == '\\r' || c == K_KENTER || (c == ESC\n\t\t\t&& (!KeyTyped || vim_strchr(p_cpo, CPO_ESC) != NULL)))\n\t{\n\t    // In Ex mode a backslash escapes a newline.\n\t    if (exmode_active\n\t\t    && c != ESC\n\t\t    && ccline.cmdpos == ccline.cmdlen\n\t\t    && ccline.cmdpos > 0\n\t\t    && ccline.cmdbuff[ccline.cmdpos - 1] == '\\\\')\n\t    {\n\t\tif (c == K_KENTER)\n\t\t    c = '\\n';\n\t    }\n\t    else\n\t    {\n\t\tgotesc = FALSE;\t// Might have typed ESC previously, don't\n\t\t\t\t// truncate the cmdline now.\n\t\tif (ccheck_abbr(c + ABBR_OFF))\n\t\t    goto cmdline_changed;\n\t\tif (!cmd_silent)\n\t\t{\n\t\t    windgoto(msg_row, 0);\n\t\t    out_flush();\n\t\t}\n\t\tbreak;\n\t    }\n\t}\n\n\t// Completion for 'wildchar' or 'wildcharm' key.\n\tif ((c == p_wc && !gotesc && KeyTyped) || c == p_wcm)\n\t{\n\t    res = cmdline_wildchar_complete(c, firstc != '@', &did_wild_list,\n\t\t    &wim_index, &xpc, &gotesc);\n\t    if (res == CMDLINE_CHANGED)\n\t\tgoto cmdline_changed;\n\t}\n\n\tgotesc = FALSE;\n\n\t// <S-Tab> goes to last match, in a clumsy way\n\tif (c == K_S_TAB && KeyTyped)\n\t{\n\t    if (nextwild(&xpc, WILD_EXPAND_KEEP, 0, firstc != '@') == OK)\n\t    {\n\t\tif (xpc.xp_numfiles > 1\n\t\t    && ((!did_wild_list && (wim_flags[wim_index] & WIM_LIST))\n\t\t\t    || p_wmnu))\n\t\t{\n\t\t    // Trigger the popup menu when wildoptions=pum\n\t\t    showmatches(&xpc, p_wmnu\n\t\t\t    && ((wim_flags[wim_index] & WIM_LIST) == 0));\n\t\t}\n\t\tif (nextwild(&xpc, WILD_PREV, 0, firstc != '@') == OK\n\t\t\t&& nextwild(&xpc, WILD_PREV, 0, firstc != '@') == OK)\n\t\t    goto cmdline_changed;\n\t    }\n\t}\n\n\tif (c == NUL || c == K_ZERO)\t    // NUL is stored as NL\n\t    c = NL;\n\n\tdo_abbr = TRUE;\t\t// default: check for abbreviation\n\n\t// If already used to cancel/accept wildmenu, don't process the key\n\t// further.\n\tif (wild_type == WILD_CANCEL || wild_type == WILD_APPLY)\n\t{\n\t    wild_type = 0;\n\t    goto cmdline_not_changed;\n\t}\n\n\t/*\n\t * Big switch for a typed command line character.\n\t */\n\tswitch (c)\n\t{\n\tcase K_BS:\n\tcase Ctrl_H:\n\tcase K_DEL:\n\tcase K_KDEL:\n\tcase Ctrl_W:\n\t    res = cmdline_erase_chars(c, indent\n#ifdef FEAT_SEARCH_EXTRA\n\t\t    , &is_state\n#endif\n\t\t    );\n\t    if (res == CMDLINE_NOT_CHANGED)\n\t\tgoto cmdline_not_changed;\n\t    else if (res == GOTO_NORMAL_MODE)\n\t\tgoto returncmd;\t\t// back to cmd mode\n\t    goto cmdline_changed;\n\n\tcase K_INS:\n\tcase K_KINS:\n\t\tccline.overstrike = !ccline.overstrike;\n#ifdef CURSOR_SHAPE\n\t\tui_cursor_shape();\t// may show different cursor shape\n#endif\n\t\tgoto cmdline_not_changed;\n\n\tcase Ctrl_HAT:\n\t\tcmdline_toggle_langmap(\n\t\t\t\t    buf_valid(b_im_ptr_buf) ? b_im_ptr : NULL);\n\t\tgoto cmdline_not_changed;\n\n//\tcase '@':   only in very old vi\n\tcase Ctrl_U:\n\t\t// delete all characters left of the cursor\n\t\tj = ccline.cmdpos;\n\t\tccline.cmdlen -= j;\n\t\ti = ccline.cmdpos = 0;\n\t\twhile (i < ccline.cmdlen)\n\t\t    ccline.cmdbuff[i++] = ccline.cmdbuff[j++];\n\t\t// Truncate at the end, required for multi-byte chars.\n\t\tccline.cmdbuff[ccline.cmdlen] = NUL;\n#ifdef FEAT_SEARCH_EXTRA\n\t\tif (ccline.cmdlen == 0)\n\t\t    is_state.search_start = is_state.save_cursor;\n#endif\n\t\tredrawcmd();\n\t\tgoto cmdline_changed;\n\n#ifdef FEAT_CLIPBOARD\n\tcase Ctrl_Y:\n\t\t// Copy the modeless selection, if there is one.\n\t\tif (clip_star.state != SELECT_CLEARED)\n\t\t{\n\t\t    if (clip_star.state == SELECT_DONE)\n\t\t\tclip_copy_modeless_selection(TRUE);\n\t\t    goto cmdline_not_changed;\n\t\t}\n\t\tbreak;\n#endif\n\n\tcase ESC:\t// get here if p_wc != ESC or when ESC typed twice\n\tcase Ctrl_C:\n\t\t// In exmode it doesn't make sense to return.  Except when\n\t\t// \":normal\" runs out of characters.\n\t\tif (exmode_active\n\t\t\t       && (ex_normal_busy == 0 || typebuf.tb_len > 0))\n\t\t    goto cmdline_not_changed;\n\n\t\tgotesc = TRUE;\t\t// will free ccline.cmdbuff after\n\t\t\t\t\t// putting it in history\n\t\tgoto returncmd;\t\t// back to cmd mode\n\n\tcase Ctrl_R:\t\t\t// insert register\n\t\tres = cmdline_insert_reg(&gotesc);\n\t\tif (res == GOTO_NORMAL_MODE)\n\t\t    goto returncmd;\n\t\tif (res == CMDLINE_CHANGED)\n\t\t    goto cmdline_changed;\n\t\tgoto cmdline_not_changed;\n\n\tcase Ctrl_D:\n\t\tif (showmatches(&xpc, FALSE) == EXPAND_NOTHING)\n\t\t    break;\t// Use ^D as normal char instead\n\n\t\tredrawcmd();\n\t\tcontinue;\t// don't do incremental search now\n\n\tcase K_RIGHT:\n\tcase K_S_RIGHT:\n\tcase K_C_RIGHT:\n\t\tdo\n\t\t{\n\t\t    if (ccline.cmdpos >= ccline.cmdlen)\n\t\t\tbreak;\n\t\t    i = cmdline_charsize(ccline.cmdpos);\n\t\t    if (KeyTyped && ccline.cmdspos + i >= Columns * Rows)\n\t\t\tbreak;\n\t\t    ccline.cmdspos += i;\n\t\t    if (has_mbyte)\n\t\t\tccline.cmdpos += (*mb_ptr2len)(ccline.cmdbuff\n\t\t\t\t\t\t\t     + ccline.cmdpos);\n\t\t    else\n\t\t\t++ccline.cmdpos;\n\t\t}\n\t\twhile ((c == K_S_RIGHT || c == K_C_RIGHT\n\t\t\t       || (mod_mask & (MOD_MASK_SHIFT|MOD_MASK_CTRL)))\n\t\t\t&& ccline.cmdbuff[ccline.cmdpos] != ' ');\n\t\tif (has_mbyte)\n\t\t    set_cmdspos_cursor();\n\t\tgoto cmdline_not_changed;\n\n\tcase K_LEFT:\n\tcase K_S_LEFT:\n\tcase K_C_LEFT:\n\t\tif (ccline.cmdpos == 0)\n\t\t    goto cmdline_not_changed;\n\t\tdo\n\t\t{\n\t\t    --ccline.cmdpos;\n\t\t    if (has_mbyte)\t// move to first byte of char\n\t\t\tccline.cmdpos -= (*mb_head_off)(ccline.cmdbuff,\n\t\t\t\t\t      ccline.cmdbuff + ccline.cmdpos);\n\t\t    ccline.cmdspos -= cmdline_charsize(ccline.cmdpos);\n\t\t}\n\t\twhile (ccline.cmdpos > 0\n\t\t\t&& (c == K_S_LEFT || c == K_C_LEFT\n\t\t\t       || (mod_mask & (MOD_MASK_SHIFT|MOD_MASK_CTRL)))\n\t\t\t&& ccline.cmdbuff[ccline.cmdpos - 1] != ' ');\n\t\tif (has_mbyte)\n\t\t    set_cmdspos_cursor();\n\t\tgoto cmdline_not_changed;\n\n\tcase K_IGNORE:\n\t\t// Ignore mouse event or open_cmdwin() result.\n\t\tgoto cmdline_not_changed;\n\n#ifdef FEAT_GUI_MSWIN\n\t    // On MS-Windows ignore <M-F4>, we get it when closing the window\n\t    // was cancelled.\n\tcase K_F4:\n\t    if (mod_mask == MOD_MASK_ALT)\n\t    {\n\t\tredrawcmd();\t    // somehow the cmdline is cleared\n\t\tgoto cmdline_not_changed;\n\t    }\n\t    break;\n#endif\n\n\tcase K_MIDDLEDRAG:\n\tcase K_MIDDLERELEASE:\n\t\tgoto cmdline_not_changed;\t// Ignore mouse\n\n\tcase K_MIDDLEMOUSE:\n# ifdef FEAT_GUI\n\t\t// When GUI is active, also paste when 'mouse' is empty\n\t\tif (!gui.in_use)\n# endif\n\t\t    if (!mouse_has(MOUSE_COMMAND))\n\t\t\tgoto cmdline_not_changed;   // Ignore mouse\n# ifdef FEAT_CLIPBOARD\n\t\tif (clip_star.available)\n\t\t    cmdline_paste('*', TRUE, TRUE);\n\t\telse\n# endif\n\t\t    cmdline_paste(0, TRUE, TRUE);\n\t\tredrawcmd();\n\t\tgoto cmdline_changed;\n\n# ifdef FEAT_DND\n\tcase K_DROP:\n\t\tcmdline_paste('~', TRUE, FALSE);\n\t\tredrawcmd();\n\t\tgoto cmdline_changed;\n# endif\n\n\tcase K_LEFTDRAG:\n\tcase K_LEFTRELEASE:\n\tcase K_RIGHTDRAG:\n\tcase K_RIGHTRELEASE:\n\t\t// Ignore drag and release events when the button-down wasn't\n\t\t// seen before.\n\t\tif (ignore_drag_release)\n\t\t    goto cmdline_not_changed;\n\t\t// FALLTHROUGH\n\tcase K_LEFTMOUSE:\n\tcase K_RIGHTMOUSE:\n\t\tcmdline_left_right_mouse(c, &ignore_drag_release);\n\t\tgoto cmdline_not_changed;\n\n\t// Mouse scroll wheel: ignored here\n\tcase K_MOUSEDOWN:\n\tcase K_MOUSEUP:\n\tcase K_MOUSELEFT:\n\tcase K_MOUSERIGHT:\n\t// Alternate buttons ignored here\n\tcase K_X1MOUSE:\n\tcase K_X1DRAG:\n\tcase K_X1RELEASE:\n\tcase K_X2MOUSE:\n\tcase K_X2DRAG:\n\tcase K_X2RELEASE:\n\tcase K_MOUSEMOVE:\n\t\tgoto cmdline_not_changed;\n\n#ifdef FEAT_GUI\n\tcase K_LEFTMOUSE_NM:\t// mousefocus click, ignored\n\tcase K_LEFTRELEASE_NM:\n\t\tgoto cmdline_not_changed;\n\n\tcase K_VER_SCROLLBAR:\n\t\tif (msg_scrolled == 0)\n\t\t{\n\t\t    gui_do_scroll();\n\t\t    redrawcmd();\n\t\t}\n\t\tgoto cmdline_not_changed;\n\n\tcase K_HOR_SCROLLBAR:\n\t\tif (msg_scrolled == 0)\n\t\t{\n\t\t    do_mousescroll_horiz(scrollbar_value);\n\t\t    redrawcmd();\n\t\t}\n\t\tgoto cmdline_not_changed;\n#endif\n#ifdef FEAT_GUI_TABLINE\n\tcase K_TABLINE:\n\tcase K_TABMENU:\n\t\t// Don't want to change any tabs here.  Make sure the same tab\n\t\t// is still selected.\n\t\tif (gui_use_tabline())\n\t\t    gui_mch_set_curtab(tabpage_index(curtab));\n\t\tgoto cmdline_not_changed;\n#endif\n\n\tcase K_SELECT:\t    // end of Select mode mapping - ignore\n\t\tgoto cmdline_not_changed;\n\n\tcase Ctrl_B:\t    // begin of command line\n\tcase K_HOME:\n\tcase K_KHOME:\n\tcase K_S_HOME:\n\tcase K_C_HOME:\n\t\tccline.cmdpos = 0;\n\t\tset_cmdspos();\n\t\tgoto cmdline_not_changed;\n\n\tcase Ctrl_E:\t    // end of command line\n\tcase K_END:\n\tcase K_KEND:\n\tcase K_S_END:\n\tcase K_C_END:\n\t\tccline.cmdpos = ccline.cmdlen;\n\t\tset_cmdspos_cursor();\n\t\tgoto cmdline_not_changed;\n\n\tcase Ctrl_A:\t    // all matches\n\t\tif (cmdline_pum_active())\n\t\t    // As Ctrl-A completes all the matches, close the popup\n\t\t    // menu (if present)\n\t\t    cmdline_pum_cleanup(&ccline);\n\n\t\tif (nextwild(&xpc, WILD_ALL, 0, firstc != '@') == FAIL)\n\t\t    break;\n\t\txpc.xp_context = EXPAND_NOTHING;\n\t\tdid_wild_list = FALSE;\n\t\tgoto cmdline_changed;\n\n\tcase Ctrl_L:\n#ifdef FEAT_SEARCH_EXTRA\n\t\tif (may_add_char_to_search(firstc, &c, &is_state) == OK)\n\t\t    goto cmdline_not_changed;\n#endif\n\n\t\t// completion: longest common part\n\t\tif (nextwild(&xpc, WILD_LONGEST, 0, firstc != '@') == FAIL)\n\t\t    break;\n\t\tgoto cmdline_changed;\n\n\tcase Ctrl_N:\t    // next match\n\tcase Ctrl_P:\t    // previous match\n\t\tif (xpc.xp_numfiles > 0)\n\t\t{\n\t\t    wild_type = (c == Ctrl_P) ? WILD_PREV : WILD_NEXT;\n\t\t    if (nextwild(&xpc, wild_type, 0, firstc != '@') == FAIL)\n\t\t\tbreak;\n\t\t    goto cmdline_changed;\n\t\t}\n\t\t// FALLTHROUGH\n\tcase K_UP:\n\tcase K_DOWN:\n\tcase K_S_UP:\n\tcase K_S_DOWN:\n\tcase K_PAGEUP:\n\tcase K_KPAGEUP:\n\tcase K_PAGEDOWN:\n\tcase K_KPAGEDOWN:\n\t\tif (cmdline_pum_active()\n\t\t\t&& (c == K_PAGEUP || c == K_PAGEDOWN ||\n\t\t\t    c == K_KPAGEUP || c == K_KPAGEDOWN))\n\t\t{\n\t\t    // If the popup menu is displayed, then PageUp and PageDown\n\t\t    // are used to scroll the menu.\n\t\t    wild_type = WILD_PAGEUP;\n\t\t    if (c == K_PAGEDOWN || c == K_KPAGEDOWN)\n\t\t\twild_type = WILD_PAGEDOWN;\n\t\t    if (nextwild(&xpc, wild_type, 0, firstc != '@') == FAIL)\n\t\t\tbreak;\n\t\t    goto cmdline_changed;\n\t\t}\n\t\telse\n\t\t{\n\t\t    res = cmdline_browse_history(c, firstc, &lookfor, histype,\n\t\t\t    &hiscnt, &xpc);\n\t\t    if (res == CMDLINE_CHANGED)\n\t\t\tgoto cmdline_changed;\n\t\t    else if (res == GOTO_NORMAL_MODE)\n\t\t\tgoto returncmd;\n\t\t}\n\t\tgoto cmdline_not_changed;\n\n#ifdef FEAT_SEARCH_EXTRA\n\tcase Ctrl_G:\t    // next match\n\tcase Ctrl_T:\t    // previous match\n\t\tif (may_adjust_incsearch_highlighting(\n\t\t\t\t\t  firstc, count, &is_state, c) == FAIL)\n\t\t    goto cmdline_not_changed;\n\t\tbreak;\n#endif\n\n\tcase Ctrl_V:\n\tcase Ctrl_Q:\n\t\t{\n\t\t    ignore_drag_release = TRUE;\n\t\t    putcmdline('^', TRUE);\n\n\t\t    // Get next (two) character(s).  Do not change any\n\t\t    // modifyOtherKeys ESC sequence to a normal key for\n\t\t    // CTRL-SHIFT-V.\n\t\t    c = get_literal(mod_mask & MOD_MASK_SHIFT);\n\n\t\t    do_abbr = FALSE;\t    // don't do abbreviation now\n\t\t    extra_char = NUL;\n\t\t    // may need to remove ^ when composing char was typed\n\t\t    if (enc_utf8 && utf_iscomposing(c) && !cmd_silent)\n\t\t    {\n\t\t\tdraw_cmdline(ccline.cmdpos,\n\t\t\t\t\t\tccline.cmdlen - ccline.cmdpos);\n\t\t\tmsg_putchar(' ');\n\t\t\tcursorcmd();\n\t\t    }\n\t\t}\n\n\t\tbreak;\n\n#ifdef FEAT_DIGRAPHS\n\tcase Ctrl_K:\n\t\tignore_drag_release = TRUE;\n\t\tputcmdline('?', TRUE);\n# ifdef USE_ON_FLY_SCROLL\n\t\tdont_scroll = TRUE;\t    // disallow scrolling here\n# endif\n\t\tc = get_digraph(TRUE);\n\t\textra_char = NUL;\n\t\tif (c != NUL)\n\t\t    break;\n\n\t\tredrawcmd();\n\t\tgoto cmdline_not_changed;\n#endif // FEAT_DIGRAPHS\n\n#ifdef FEAT_RIGHTLEFT\n\tcase Ctrl__:\t    // CTRL-_: switch language mode\n\t\tif (!p_ari)\n\t\t    break;\n\t\tcmd_hkmap = !cmd_hkmap;\n\t\tgoto cmdline_not_changed;\n#endif\n\n\tcase K_PS:\n\t\tbracketed_paste(PASTE_CMDLINE, FALSE, NULL);\n\t\tgoto cmdline_changed;\n\n\tdefault:\n#ifdef UNIX\n\t\tif (c == intr_char)\n\t\t{\n\t\t    gotesc = TRUE;\t// will free ccline.cmdbuff after\n\t\t\t\t\t// putting it in history\n\t\t    goto returncmd;\t// back to Normal mode\n\t\t}\n#endif\n\t\t/*\n\t\t * Normal character with no special meaning.  Just set mod_mask\n\t\t * to 0x0 so that typing Shift-Space in the GUI doesn't enter\n\t\t * the string <S-Space>.  This should only happen after ^V.\n\t\t */\n\t\tif (!IS_SPECIAL(c))\n\t\t    mod_mask = 0x0;\n\t\tbreak;\n\t}\n\t/*\n\t * End of switch on command line character.\n\t * We come here if we have a normal character.\n\t */\n\n\tif (do_abbr && (IS_SPECIAL(c) || !vim_iswordc(c))\n\t\t&& (ccheck_abbr(\n\t\t\t// Add ABBR_OFF for characters above 0x100, this is\n\t\t\t// what check_abbr() expects.\n\t\t\t\t(has_mbyte && c >= 0x100) ? (c + ABBR_OFF) : c)\n\t\t    || c == Ctrl_RSB))\n\t    goto cmdline_changed;\n\n\t/*\n\t * put the character in the command line\n\t */\n\tif (IS_SPECIAL(c) || mod_mask != 0)\n\t    put_on_cmdline(get_special_key_name(c, mod_mask), -1, TRUE);\n\telse\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tj = (*mb_char2bytes)(c, IObuff);\n\t\tIObuff[j] = NUL;\t// exclude composing chars\n\t\tput_on_cmdline(IObuff, j, TRUE);\n\t    }\n\t    else\n\t    {\n\t\tIObuff[0] = c;\n\t\tput_on_cmdline(IObuff, 1, TRUE);\n\t    }\n\t}\n\tgoto cmdline_changed;\n\n/*\n * This part implements incremental searches for \"/\" and \"?\"\n * Jump to cmdline_not_changed when a character has been read but the command\n * line did not change. Then we only search and redraw if something changed in\n * the past.\n * Jump to cmdline_changed when the command line did change.\n * (Sorry for the goto's, I know it is ugly).\n */\ncmdline_not_changed:\n#ifdef FEAT_SEARCH_EXTRA\n\tif (!is_state.incsearch_postponed)\n\t    continue;\n#endif\n\ncmdline_changed:\n#ifdef FEAT_SEARCH_EXTRA\n\t// If the window changed incremental search state is not valid.\n\tif (is_state.winid != curwin->w_id)\n\t    init_incsearch_state(&is_state);\n#endif\n\tif (trigger_cmdlinechanged)\n\t    // Trigger CmdlineChanged autocommands.\n\t    trigger_cmd_autocmd(cmdline_type, EVENT_CMDLINECHANGED);\n\n#ifdef FEAT_SEARCH_EXTRA\n\tif (xpc.xp_context == EXPAND_NOTHING && (KeyTyped || vpeekc() == NUL))\n\t    may_do_incsearch_highlighting(firstc, count, &is_state);\n#endif\n\n#ifdef FEAT_RIGHTLEFT\n\tif (cmdmsg_rl\n# ifdef FEAT_ARABIC\n\t\t|| (p_arshape && !p_tbidi\n\t\t\t\t       && cmdline_has_arabic(0, ccline.cmdlen))\n# endif\n\t\t)\n\t    // Always redraw the whole command line to fix shaping and\n\t    // right-left typing.  Not efficient, but it works.\n\t    // Do it only when there are no characters left to read\n\t    // to avoid useless intermediate redraws.\n\t    if (vpeekc() == NUL)\n\t\tredrawcmd();\n#endif\n    }\n\nreturncmd:\n\n#ifdef FEAT_RIGHTLEFT\n    cmdmsg_rl = FALSE;\n#endif\n\n    // We could have reached here without having a chance to clean up wild menu\n    // if certain special keys like <Esc> or <C-\\> were used as wildchar. Make\n    // sure to still clean up to avoid memory corruption.\n    if (cmdline_pum_active())\n\tcmdline_pum_remove();\n    wildmenu_cleanup(&ccline);\n    did_wild_list = FALSE;\n    wim_index = 0;\n\n    ExpandCleanup(&xpc);\n    ccline.xpc = NULL;\n\n#ifdef FEAT_SEARCH_EXTRA\n    finish_incsearch_highlighting(gotesc, &is_state, FALSE);\n#endif\n\n    if (ccline.cmdbuff != NULL)\n    {\n\t/*\n\t * Put line in history buffer (\":\" and \"=\" only when it was typed).\n\t */\n\tif (ccline.cmdlen && firstc != NUL\n\t\t&& (some_key_typed || histype == HIST_SEARCH))\n\t{\n\t    add_to_history(histype, ccline.cmdbuff, TRUE,\n\t\t\t\t       histype == HIST_SEARCH ? firstc : NUL);\n\t    if (firstc == ':')\n\t    {\n\t\tvim_free(new_last_cmdline);\n\t\tnew_last_cmdline = vim_strsave(ccline.cmdbuff);\n\t    }\n\t}\n\n\tif (gotesc)\n\t    abandon_cmdline();\n    }\n\n    /*\n     * If the screen was shifted up, redraw the whole screen (later).\n     * If the line is too long, clear it, so ruler and shown command do\n     * not get printed in the middle of it.\n     */\n    msg_check();\n    msg_scroll = save_msg_scroll;\n    redir_off = FALSE;\n\n    // When the command line was typed, no need for a wait-return prompt.\n    if (some_key_typed)\n\tneed_wait_return = FALSE;\n\n    // Trigger CmdlineLeave autocommands.\n    trigger_cmd_autocmd(cmdline_type, EVENT_CMDLINELEAVE);\n\n    State = save_State;\n\n#ifdef FEAT_EVAL\n    if (!debug_mode)\n\tmay_trigger_modechanged();\n#endif\n\n#ifdef HAVE_INPUT_METHOD\n    if (b_im_ptr != NULL && buf_valid(b_im_ptr_buf)\n\t\t\t\t\t\t  && *b_im_ptr != B_IMODE_LMAP)\n\tim_save_status(b_im_ptr);\n    im_set_active(FALSE);\n#endif\n    setmouse();\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t\t// may show different cursor shape\n#endif\n    sb_text_end_cmdline();\n\ntheend:\n    {\n\tchar_u *p = ccline.cmdbuff;\n\n\t--depth;\n\tif (did_save_ccline)\n\t    restore_cmdline(&save_ccline);\n\telse\n\t    ccline.cmdbuff = NULL;\n\treturn p;\n    }\n}\n\n#if (defined(FEAT_CRYPT) || defined(FEAT_EVAL)) || defined(PROTO)\n/*\n * Get a command line with a prompt.\n * This is prepared to be called recursively from getcmdline() (e.g. by\n * f_input() when evaluating an expression from CTRL-R =).\n * Returns the command line in allocated memory, or NULL.\n */\n    char_u *\ngetcmdline_prompt(\n    int\t\tfirstc,\n    char_u\t*prompt,\t// command line prompt\n    int\t\tattr,\t\t// attributes for prompt\n    int\t\txp_context,\t// type of expansion\n    char_u\t*xp_arg)\t// user-defined expansion argument\n{\n    char_u\t\t*s;\n    cmdline_info_T\tsave_ccline;\n    int\t\t\tdid_save_ccline = FALSE;\n    int\t\t\tmsg_col_save = msg_col;\n    int\t\t\tmsg_silent_save = msg_silent;\n\n    if (ccline.cmdbuff != NULL)\n    {\n\t// Save the values of the current cmdline and restore them below.\n\tsave_cmdline(&save_ccline);\n\tdid_save_ccline = TRUE;\n    }\n\n    CLEAR_FIELD(ccline);\n    ccline.cmdprompt = prompt;\n    ccline.cmdattr = attr;\n# ifdef FEAT_EVAL\n    ccline.xp_context = xp_context;\n    ccline.xp_arg = xp_arg;\n    ccline.input_fn = (firstc == '@');\n# endif\n    msg_silent = 0;\n    s = getcmdline_int(firstc, 1L, 0, FALSE);\n\n    if (did_save_ccline)\n\trestore_cmdline(&save_ccline);\n\n    msg_silent = msg_silent_save;\n    // Restore msg_col, the prompt from input() may have changed it.\n    // But only if called recursively and the commandline is therefore being\n    // restored to an old one; if not, the input() prompt stays on the screen,\n    // so we need its modified msg_col left intact.\n    if (ccline.cmdbuff != NULL)\n\tmsg_col = msg_col_save;\n\n    return s;\n}\n#endif\n\n/*\n * Read the 'wildmode' option, fill wim_flags[].\n */\n    int\ncheck_opt_wim(void)\n{\n    char_u\tnew_wim_flags[4];\n    char_u\t*p;\n    int\t\ti;\n    int\t\tidx = 0;\n\n    for (i = 0; i < 4; ++i)\n\tnew_wim_flags[i] = 0;\n\n    for (p = p_wim; *p; ++p)\n    {\n\t// Note: Keep this in sync with p_wim_values.\n\tfor (i = 0; ASCII_ISALPHA(p[i]); ++i)\n\t    ;\n\tif (p[i] != NUL && p[i] != ',' && p[i] != ':')\n\t    return FAIL;\n\tif (i == 7 && STRNCMP(p, \"longest\", 7) == 0)\n\t    new_wim_flags[idx] |= WIM_LONGEST;\n\telse if (i == 4 && STRNCMP(p, \"full\", 4) == 0)\n\t    new_wim_flags[idx] |= WIM_FULL;\n\telse if (i == 4 && STRNCMP(p, \"list\", 4) == 0)\n\t    new_wim_flags[idx] |= WIM_LIST;\n\telse if (i == 8 && STRNCMP(p, \"lastused\", 8) == 0)\n\t    new_wim_flags[idx] |= WIM_BUFLASTUSED;\n\telse\n\t    return FAIL;\n\tp += i;\n\tif (*p == NUL)\n\t    break;\n\tif (*p == ',')\n\t{\n\t    if (idx == 3)\n\t\treturn FAIL;\n\t    ++idx;\n\t}\n    }\n\n    // fill remaining entries with last flag\n    while (idx < 3)\n    {\n\tnew_wim_flags[idx + 1] = new_wim_flags[idx];\n\t++idx;\n    }\n\n    // only when there are no errors, wim_flags[] is changed\n    for (i = 0; i < 4; ++i)\n\twim_flags[i] = new_wim_flags[i];\n    return OK;\n}\n\n/*\n * Return TRUE when the text must not be changed and we can't switch to\n * another window or buffer.  TRUE when editing the command line, evaluating\n * 'balloonexpr', etc.\n */\n    int\ntext_locked(void)\n{\n    if (cmdwin_type != 0)\n\treturn TRUE;\n    return textlock != 0;\n}\n\n/*\n * Give an error message for a command that isn't allowed while the cmdline\n * window is open or editing the cmdline in another way.\n */\n    void\ntext_locked_msg(void)\n{\n    emsg(_(get_text_locked_msg()));\n}\n\n    char *\nget_text_locked_msg(void)\n{\n    if (cmdwin_type != 0)\n\treturn e_invalid_in_cmdline_window;\n    return e_not_allowed_to_change_text_or_change_window;\n}\n\n/*\n * Check for text, window or buffer locked.\n * Give an error message and return TRUE if something is locked.\n */\n    int\ntext_or_buf_locked(void)\n{\n    if (text_locked())\n    {\n\ttext_locked_msg();\n\treturn TRUE;\n    }\n    return curbuf_locked();\n}\n\n/*\n * Check if \"curbuf_lock\" or \"allbuf_lock\" is set and return TRUE when it is\n * and give an error message.\n */\n    int\ncurbuf_locked(void)\n{\n    if (curbuf_lock > 0)\n    {\n\temsg(_(e_not_allowed_to_edit_another_buffer_now));\n\treturn TRUE;\n    }\n    return allbuf_locked();\n}\n\n/*\n * Check if \"allbuf_lock\" is set and return TRUE when it is and give an error\n * message.\n */\n    int\nallbuf_locked(void)\n{\n    if (allbuf_lock > 0)\n    {\n\temsg(_(e_not_allowed_to_change_buffer_information_now));\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n    static int\ncmdline_charsize(int idx)\n{\n#if defined(FEAT_CRYPT) || defined(FEAT_EVAL)\n    if (cmdline_star > 0)\t    // showing '*', always 1 position\n\treturn 1;\n#endif\n    return ptr2cells(ccline.cmdbuff + idx);\n}\n\n/*\n * Compute the offset of the cursor on the command line for the prompt and\n * indent.\n */\n    static void\nset_cmdspos(void)\n{\n    if (ccline.cmdfirstc != NUL)\n\tccline.cmdspos = 1 + ccline.cmdindent;\n    else\n\tccline.cmdspos = 0 + ccline.cmdindent;\n}\n\n/*\n * Compute the screen position for the cursor on the command line.\n */\n    static void\nset_cmdspos_cursor(void)\n{\n    int\t\ti, m, c;\n\n    set_cmdspos();\n    if (KeyTyped)\n    {\n\tm = Columns * Rows;\n\tif (m < 0)\t// overflow, Columns or Rows at weird value\n\t    m = MAXCOL;\n    }\n    else\n\tm = MAXCOL;\n    for (i = 0; i < ccline.cmdlen && i < ccline.cmdpos; ++i)\n    {\n\tc = cmdline_charsize(i);\n\t// Count \">\" for double-wide multi-byte char that doesn't fit.\n\tif (has_mbyte)\n\t    correct_cmdspos(i, c);\n\t// If the cmdline doesn't fit, show cursor on last visible char.\n\t// Don't move the cursor itself, so we can still append.\n\tif ((ccline.cmdspos += c) >= m)\n\t{\n\t    ccline.cmdspos -= c;\n\t    break;\n\t}\n\tif (has_mbyte)\n\t    i += (*mb_ptr2len)(ccline.cmdbuff + i) - 1;\n    }\n}\n\n/*\n * Check if the character at \"idx\", which is \"cells\" wide, is a multi-byte\n * character that doesn't fit, so that a \">\" must be displayed.\n */\n    static void\ncorrect_cmdspos(int idx, int cells)\n{\n    if ((*mb_ptr2len)(ccline.cmdbuff + idx) > 1\n\t\t&& (*mb_ptr2cells)(ccline.cmdbuff + idx) > 1\n\t\t&& ccline.cmdspos % Columns + cells > Columns)\n\tccline.cmdspos++;\n}\n\n/*\n * Get an Ex command line for the \":\" command.\n */\n    char_u *\ngetexline(\n    int\t\tc,\t\t// normally ':', NUL for \":append\"\n    void\t*cookie UNUSED,\n    int\t\tindent,\t\t// indent for inside conditionals\n    getline_opt_T options)\n{\n    // When executing a register, remove ':' that's in front of each line.\n    if (exec_from_reg && vpeekc() == ':')\n\t(void)vgetc();\n    return getcmdline(c, 1L, indent, options);\n}\n\n/*\n * Get an Ex command line for Ex mode.\n * In Ex mode we only use the OS supplied line editing features and no\n * mappings or abbreviations.\n * Returns a string in allocated memory or NULL.\n */\n    char_u *\ngetexmodeline(\n    int\t\tpromptc,\t// normally ':', NUL for \":append\" and '?' for\n\t\t\t\t// :s prompt\n    void\t*cookie UNUSED,\n    int\t\tindent,\t\t// indent for inside conditionals\n    getline_opt_T options UNUSED)\n{\n    garray_T\tline_ga;\n    char_u\t*pend;\n    int\t\tstartcol = 0;\n    int\t\tc1 = 0;\n    int\t\tescaped = FALSE;\t// CTRL-V typed\n    int\t\tvcol = 0;\n    char_u\t*p;\n    int\t\tprev_char;\n    int\t\tlen;\n\n    // Switch cursor on now.  This avoids that it happens after the \"\\n\", which\n    // confuses the system function that computes tabstops.\n    cursor_on();\n\n    // always start in column 0; write a newline if necessary\n    compute_cmdrow();\n    if ((msg_col || msg_didout) && promptc != '?')\n\tmsg_putchar('\\n');\n    if (promptc == ':')\n    {\n\t// indent that is only displayed, not in the line itself\n\tif (p_prompt)\n\t    msg_putchar(':');\n\twhile (indent-- > 0)\n\t    msg_putchar(' ');\n\tstartcol = msg_col;\n    }\n\n    ga_init2(&line_ga, 1, 30);\n\n    // autoindent for :insert and :append is in the line itself\n    if (promptc <= 0)\n    {\n\tvcol = indent;\n\twhile (indent >= 8)\n\t{\n\t    ga_append(&line_ga, TAB);\n\t    msg_puts(\"        \");\n\t    indent -= 8;\n\t}\n\twhile (indent-- > 0)\n\t{\n\t    ga_append(&line_ga, ' ');\n\t    msg_putchar(' ');\n\t}\n    }\n    ++no_mapping;\n    ++allow_keys;\n\n    /*\n     * Get the line, one character at a time.\n     */\n    got_int = FALSE;\n    while (!got_int)\n    {\n\tlong    sw;\n\tchar_u *s;\n\n\t// May request the keyboard protocol state now.\n\tmay_send_t_RK();\n\n\tif (ga_grow(&line_ga, 40) == FAIL)\n\t    break;\n\n\t/*\n\t * Get one character at a time.\n\t */\n\tprev_char = c1;\n\n\t// Check for a \":normal\" command and no more characters left.\n\tif (ex_normal_busy > 0 && typebuf.tb_len == 0)\n\t    c1 = '\\n';\n\telse\n\t    c1 = vgetc();\n\n\t/*\n\t * Handle line editing.\n\t * Previously this was left to the system, putting the terminal in\n\t * cooked mode, but then CTRL-D and CTRL-T can't be used properly.\n\t */\n\tif (got_int)\n\t{\n\t    msg_putchar('\\n');\n\t    break;\n\t}\n\n\tif (c1 == K_PS)\n\t{\n\t    bracketed_paste(PASTE_EX, FALSE, &line_ga);\n\t    goto redraw;\n\t}\n\n\tif (!escaped)\n\t{\n\t    // CR typed means \"enter\", which is NL\n\t    if (c1 == '\\r')\n\t\tc1 = '\\n';\n\n\t    if (c1 == BS || c1 == K_BS\n\t\t\t  || c1 == DEL || c1 == K_DEL || c1 == K_KDEL)\n\t    {\n\t\tif (line_ga.ga_len > 0)\n\t\t{\n\t\t    if (has_mbyte)\n\t\t    {\n\t\t\tp = (char_u *)line_ga.ga_data;\n\t\t\tp[line_ga.ga_len] = NUL;\n\t\t\tlen = (*mb_head_off)(p, p + line_ga.ga_len - 1) + 1;\n\t\t\tline_ga.ga_len -= len;\n\t\t    }\n\t\t    else\n\t\t\t--line_ga.ga_len;\n\t\t    goto redraw;\n\t\t}\n\t\tcontinue;\n\t    }\n\n\t    if (c1 == Ctrl_U)\n\t    {\n\t\tmsg_col = startcol;\n\t\tmsg_clr_eos();\n\t\tline_ga.ga_len = 0;\n\t\tgoto redraw;\n\t    }\n\n\t    if (c1 == Ctrl_T)\n\t    {\n\t\tsw = get_sw_value(curbuf);\n\t\tp = (char_u *)line_ga.ga_data;\n\t\tp[line_ga.ga_len] = NUL;\n\t\tindent = get_indent_str(p, 8, FALSE);\n\t\tindent += sw - indent % sw;\nadd_indent:\n\t\twhile (get_indent_str(p, 8, FALSE) < indent)\n\t\t{\n\t\t    (void)ga_grow(&line_ga, 2);  // one more for the NUL\n\t\t    p = (char_u *)line_ga.ga_data;\n\t\t    s = skipwhite(p);\n\t\t    mch_memmove(s + 1, s, line_ga.ga_len - (s - p) + 1);\n\t\t    *s = ' ';\n\t\t    ++line_ga.ga_len;\n\t\t}\nredraw:\n\t\t// redraw the line\n\t\tmsg_col = startcol;\n\t\tvcol = 0;\n\t\tp = (char_u *)line_ga.ga_data;\n\t\tp[line_ga.ga_len] = NUL;\n\t\twhile (p < (char_u *)line_ga.ga_data + line_ga.ga_len)\n\t\t{\n\t\t    if (*p == TAB)\n\t\t    {\n\t\t\tdo\n\t\t\t    msg_putchar(' ');\n\t\t\twhile (++vcol % 8);\n\t\t\t++p;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tlen = mb_ptr2len(p);\n\t\t\tmsg_outtrans_len(p, len);\n\t\t\tvcol += ptr2cells(p);\n\t\t\tp += len;\n\t\t    }\n\t\t}\n\t\tmsg_clr_eos();\n\t\twindgoto(msg_row, msg_col);\n\t\tcontinue;\n\t    }\n\n\t    if (c1 == Ctrl_D)\n\t    {\n\t\t// Delete one shiftwidth.\n\t\tp = (char_u *)line_ga.ga_data;\n\t\tif (prev_char == '0' || prev_char == '^')\n\t\t{\n\t\t    if (prev_char == '^')\n\t\t\tex_keep_indent = TRUE;\n\t\t    indent = 0;\n\t\t    p[--line_ga.ga_len] = NUL;\n\t\t}\n\t\telse\n\t\t{\n\t\t    p[line_ga.ga_len] = NUL;\n\t\t    indent = get_indent_str(p, 8, FALSE);\n\t\t    if (indent > 0)\n\t\t    {\n\t\t\t--indent;\n\t\t\tindent -= indent % get_sw_value(curbuf);\n\t\t    }\n\t\t}\n\t\twhile (get_indent_str(p, 8, FALSE) > indent)\n\t\t{\n\t\t    s = skipwhite(p);\n\t\t    mch_memmove(s - 1, s, line_ga.ga_len - (s - p) + 1);\n\t\t    --line_ga.ga_len;\n\t\t}\n\t\tgoto add_indent;\n\t    }\n\n\t    if (c1 == Ctrl_V || c1 == Ctrl_Q)\n\t    {\n\t\tescaped = TRUE;\n\t\tcontinue;\n\t    }\n\n\t    // Ignore special key codes: mouse movement, K_IGNORE, etc.\n\t    if (IS_SPECIAL(c1))\n\t\tcontinue;\n\t}\n\n\tif (IS_SPECIAL(c1))\n\t    c1 = '?';\n\tif (has_mbyte)\n\t    len = (*mb_char2bytes)(c1,\n\t\t\t\t  (char_u *)line_ga.ga_data + line_ga.ga_len);\n\telse\n\t{\n\t    len = 1;\n\t    ((char_u *)line_ga.ga_data)[line_ga.ga_len] = c1;\n\t}\n\tif (c1 == '\\n')\n\t    msg_putchar('\\n');\n\telse if (c1 == TAB)\n\t{\n\t    // Don't use chartabsize(), 'ts' can be different\n\t    do\n\t\tmsg_putchar(' ');\n\t    while (++vcol % 8);\n\t}\n\telse\n\t{\n\t    msg_outtrans_len(\n\t\t     ((char_u *)line_ga.ga_data) + line_ga.ga_len, len);\n\t    vcol += char2cells(c1);\n\t}\n\tline_ga.ga_len += len;\n\tescaped = FALSE;\n\n\twindgoto(msg_row, msg_col);\n\tpend = (char_u *)(line_ga.ga_data) + line_ga.ga_len;\n\n\t// We are done when a NL is entered, but not when it comes after an\n\t// odd number of backslashes, that results in a NUL.\n\tif (line_ga.ga_len > 0 && pend[-1] == '\\n')\n\t{\n\t    int bcount = 0;\n\n\t    while (line_ga.ga_len - 2 >= bcount && pend[-2 - bcount] == '\\\\')\n\t\t++bcount;\n\n\t    if (bcount > 0)\n\t    {\n\t\t// Halve the number of backslashes: \"\\NL\" -> \"NUL\", \"\\\\NL\" ->\n\t\t// \"\\NL\", etc.\n\t\tline_ga.ga_len -= (bcount + 1) / 2;\n\t\tpend -= (bcount + 1) / 2;\n\t\tpend[-1] = '\\n';\n\t    }\n\n\t    if ((bcount & 1) == 0)\n\t    {\n\t\t--line_ga.ga_len;\n\t\t--pend;\n\t\t*pend = NUL;\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    --no_mapping;\n    --allow_keys;\n\n    // make following messages go to the next line\n    msg_didout = FALSE;\n    msg_col = 0;\n    if (msg_row < Rows - 1)\n\t++msg_row;\n    emsg_on_display = FALSE;\t\t// don't want ui_delay()\n\n    if (got_int)\n\tga_clear(&line_ga);\n\n    return (char_u *)line_ga.ga_data;\n}\n\n# if defined(MCH_CURSOR_SHAPE) || defined(FEAT_GUI) \\\n\t|| defined(FEAT_MOUSESHAPE) || defined(PROTO)\n/*\n * Return TRUE if ccline.overstrike is on.\n */\n    int\ncmdline_overstrike(void)\n{\n    return ccline.overstrike;\n}\n\n/*\n * Return TRUE if the cursor is at the end of the cmdline.\n */\n    int\ncmdline_at_end(void)\n{\n    return (ccline.cmdpos >= ccline.cmdlen);\n}\n#endif\n\n#if (defined(FEAT_XIM) && (defined(FEAT_GUI_GTK))) || defined(PROTO)\n/*\n * Return the virtual column number at the current cursor position.\n * This is used by the IM code to obtain the start of the preedit string.\n */\n    colnr_T\ncmdline_getvcol_cursor(void)\n{\n    if (ccline.cmdbuff == NULL || ccline.cmdpos > ccline.cmdlen)\n\treturn MAXCOL;\n\n    if (has_mbyte)\n    {\n\tcolnr_T\tcol;\n\tint\ti = 0;\n\n\tfor (col = 0; i < ccline.cmdpos; ++col)\n\t    i += (*mb_ptr2len)(ccline.cmdbuff + i);\n\n\treturn col;\n    }\n    else\n\treturn ccline.cmdpos;\n}\n#endif\n\n#if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)\n/*\n * If part of the command line is an IM preedit string, redraw it with\n * IM feedback attributes.  The cursor position is restored after drawing.\n */\n    static void\nredrawcmd_preedit(void)\n{\n    if ((State & MODE_CMDLINE)\n\t    && xic != NULL\n\t    // && im_get_status()  doesn't work when using SCIM\n\t    && !p_imdisable\n\t    && im_is_preediting())\n    {\n\tint\tcmdpos = 0;\n\tint\tcmdspos;\n\tint\told_row;\n\tint\told_col;\n\tcolnr_T\tcol;\n\n\told_row = msg_row;\n\told_col = msg_col;\n\tcmdspos = ((ccline.cmdfirstc != NUL) ? 1 : 0) + ccline.cmdindent;\n\n\tif (has_mbyte)\n\t{\n\t    for (col = 0; col < preedit_start_col\n\t\t\t  && cmdpos < ccline.cmdlen; ++col)\n\t    {\n\t\tcmdspos += (*mb_ptr2cells)(ccline.cmdbuff + cmdpos);\n\t\tcmdpos  += (*mb_ptr2len)(ccline.cmdbuff + cmdpos);\n\t    }\n\t}\n\telse\n\t{\n\t    cmdspos += preedit_start_col;\n\t    cmdpos  += preedit_start_col;\n\t}\n\n\tmsg_row = cmdline_row + (cmdspos / (int)Columns);\n\tmsg_col = cmdspos % (int)Columns;\n\tif (msg_row >= Rows)\n\t    msg_row = Rows - 1;\n\n\tfor (col = 0; cmdpos < ccline.cmdlen; ++col)\n\t{\n\t    int char_len;\n\t    int char_attr;\n\n\t    char_attr = im_get_feedback_attr(col);\n\t    if (char_attr < 0)\n\t\tbreak; // end of preedit string\n\n\t    if (has_mbyte)\n\t\tchar_len = (*mb_ptr2len)(ccline.cmdbuff + cmdpos);\n\t    else\n\t\tchar_len = 1;\n\n\t    msg_outtrans_len_attr(ccline.cmdbuff + cmdpos, char_len, char_attr);\n\t    cmdpos += char_len;\n\t}\n\n\tmsg_row = old_row;\n\tmsg_col = old_col;\n    }\n}\n#endif // FEAT_XIM && FEAT_GUI_GTK\n\n/*\n * Allocate a new command line buffer.\n * Assigns the new buffer to ccline.cmdbuff and ccline.cmdbufflen.\n */\n    static void\nalloc_cmdbuff(int len)\n{\n    /*\n     * give some extra space to avoid having to allocate all the time\n     */\n    if (len < 80)\n\tlen = 100;\n    else\n\tlen += 20;\n\n    ccline.cmdbuff = alloc(len);    // caller should check for out-of-memory\n    ccline.cmdbufflen = len;\n}\n\n/*\n * Re-allocate the command line to length len + something extra.\n * return FAIL for failure, OK otherwise\n */\n    int\nrealloc_cmdbuff(int len)\n{\n    char_u\t*p;\n\n    if (len < ccline.cmdbufflen)\n\treturn OK;\t\t\t// no need to resize\n\n    p = ccline.cmdbuff;\n    alloc_cmdbuff(len);\t\t\t// will get some more\n    if (ccline.cmdbuff == NULL)\t\t// out of memory\n    {\n\tccline.cmdbuff = p;\t\t// keep the old one\n\treturn FAIL;\n    }\n    // There isn't always a NUL after the command, but it may need to be\n    // there, thus copy up to the NUL and add a NUL.\n    mch_memmove(ccline.cmdbuff, p, (size_t)ccline.cmdlen);\n    ccline.cmdbuff[ccline.cmdlen] = NUL;\n    vim_free(p);\n\n    if (ccline.xpc != NULL\n\t    && ccline.xpc->xp_pattern != NULL\n\t    && ccline.xpc->xp_context != EXPAND_NOTHING\n\t    && ccline.xpc->xp_context != EXPAND_UNSUCCESSFUL)\n    {\n\tint i = (int)(ccline.xpc->xp_pattern - p);\n\n\t// If xp_pattern points inside the old cmdbuff it needs to be adjusted\n\t// to point into the newly allocated memory.\n\tif (i >= 0 && i <= ccline.cmdlen)\n\t    ccline.xpc->xp_pattern = ccline.cmdbuff + i;\n    }\n\n    return OK;\n}\n\n#if defined(FEAT_ARABIC) || defined(PROTO)\nstatic char_u\t*arshape_buf = NULL;\n\n# if defined(EXITFREE) || defined(PROTO)\n    void\nfree_arshape_buf(void)\n{\n    vim_free(arshape_buf);\n}\n# endif\n#endif\n\n/*\n * Draw part of the cmdline at the current cursor position.  But draw stars\n * when cmdline_star is TRUE.\n */\n    static void\ndraw_cmdline(int start, int len)\n{\n#if defined(FEAT_CRYPT) || defined(FEAT_EVAL)\n    int\t\ti;\n\n    if (cmdline_star > 0)\n\tfor (i = 0; i < len; ++i)\n\t{\n\t    msg_putchar('*');\n\t    if (has_mbyte)\n\t\ti += (*mb_ptr2len)(ccline.cmdbuff + start + i) - 1;\n\t}\n    else\n#endif\n#ifdef FEAT_ARABIC\n\tif (p_arshape && !p_tbidi && cmdline_has_arabic(start, len))\n    {\n\tstatic int\tbuflen = 0;\n\tchar_u\t\t*p;\n\tint\t\tj;\n\tint\t\tnewlen = 0;\n\tint\t\tmb_l;\n\tint\t\tpc, pc1 = 0;\n\tint\t\tprev_c = 0;\n\tint\t\tprev_c1 = 0;\n\tint\t\tu8c;\n\tint\t\tu8cc[MAX_MCO];\n\tint\t\tnc = 0;\n\n\t/*\n\t * Do arabic shaping into a temporary buffer.  This is very\n\t * inefficient!\n\t */\n\tif (len * 2 + 2 > buflen)\n\t{\n\t    // Re-allocate the buffer.  We keep it around to avoid a lot of\n\t    // alloc()/free() calls.\n\t    vim_free(arshape_buf);\n\t    buflen = len * 2 + 2;\n\t    arshape_buf = alloc(buflen);\n\t    if (arshape_buf == NULL)\n\t\treturn;\t// out of memory\n\t}\n\n\tif (utf_iscomposing(utf_ptr2char(ccline.cmdbuff + start)))\n\t{\n\t    // Prepend a space to draw the leading composing char on.\n\t    arshape_buf[0] = ' ';\n\t    newlen = 1;\n\t}\n\n\tfor (j = start; j < start + len; j += mb_l)\n\t{\n\t    p = ccline.cmdbuff + j;\n\t    u8c = utfc_ptr2char_len(p, u8cc, start + len - j);\n\t    mb_l = utfc_ptr2len_len(p, start + len - j);\n\t    if (ARABIC_CHAR(u8c))\n\t    {\n\t\t// Do Arabic shaping.\n\t\tif (cmdmsg_rl)\n\t\t{\n\t\t    // displaying from right to left\n\t\t    pc = prev_c;\n\t\t    pc1 = prev_c1;\n\t\t    prev_c1 = u8cc[0];\n\t\t    if (j + mb_l >= start + len)\n\t\t\tnc = NUL;\n\t\t    else\n\t\t\tnc = utf_ptr2char(p + mb_l);\n\t\t}\n\t\telse\n\t\t{\n\t\t    // displaying from left to right\n\t\t    if (j + mb_l >= start + len)\n\t\t\tpc = NUL;\n\t\t    else\n\t\t    {\n\t\t\tint\tpcc[MAX_MCO];\n\n\t\t\tpc = utfc_ptr2char_len(p + mb_l, pcc,\n\t\t\t\t\t\t      start + len - j - mb_l);\n\t\t\tpc1 = pcc[0];\n\t\t    }\n\t\t    nc = prev_c;\n\t\t}\n\t\tprev_c = u8c;\n\n\t\tu8c = arabic_shape(u8c, NULL, &u8cc[0], pc, pc1, nc);\n\n\t\tnewlen += (*mb_char2bytes)(u8c, arshape_buf + newlen);\n\t\tif (u8cc[0] != 0)\n\t\t{\n\t\t    newlen += (*mb_char2bytes)(u8cc[0], arshape_buf + newlen);\n\t\t    if (u8cc[1] != 0)\n\t\t\tnewlen += (*mb_char2bytes)(u8cc[1],\n\t\t\t\t\t\t\tarshape_buf + newlen);\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tprev_c = u8c;\n\t\tmch_memmove(arshape_buf + newlen, p, mb_l);\n\t\tnewlen += mb_l;\n\t    }\n\t}\n\n\tmsg_outtrans_len(arshape_buf, newlen);\n    }\n    else\n#endif\n\tmsg_outtrans_len(ccline.cmdbuff + start, len);\n}\n\n/*\n * Put a character on the command line.  Shifts the following text to the\n * right when \"shift\" is TRUE.  Used for CTRL-V, CTRL-K, etc.\n * \"c\" must be printable (fit in one display cell)!\n */\n    void\nputcmdline(int c, int shift)\n{\n    if (cmd_silent)\n\treturn;\n    msg_no_more = TRUE;\n    msg_putchar(c);\n    if (shift)\n\tdraw_cmdline(ccline.cmdpos, ccline.cmdlen - ccline.cmdpos);\n    msg_no_more = FALSE;\n    cursorcmd();\n    extra_char = c;\n    extra_char_shift = shift;\n}\n\n/*\n * Undo a putcmdline(c, FALSE).\n */\n    void\nunputcmdline(void)\n{\n    if (cmd_silent)\n\treturn;\n    msg_no_more = TRUE;\n    if (ccline.cmdlen == ccline.cmdpos)\n\tmsg_putchar(' ');\n    else if (has_mbyte)\n\tdraw_cmdline(ccline.cmdpos,\n\t\t\t       (*mb_ptr2len)(ccline.cmdbuff + ccline.cmdpos));\n    else\n\tdraw_cmdline(ccline.cmdpos, 1);\n    msg_no_more = FALSE;\n    cursorcmd();\n    extra_char = NUL;\n}\n\n/*\n * Put the given string, of the given length, onto the command line.\n * If len is -1, then STRLEN() is used to calculate the length.\n * If 'redraw' is TRUE then the new part of the command line, and the remaining\n * part will be redrawn, otherwise it will not.  If this function is called\n * twice in a row, then 'redraw' should be FALSE and redrawcmd() should be\n * called afterwards.\n */\n    int\nput_on_cmdline(char_u *str, int len, int redraw)\n{\n    int\t\tretval;\n    int\t\ti;\n    int\t\tm;\n    int\t\tc;\n\n    if (len < 0)\n\tlen = (int)STRLEN(str);\n\n    // Check if ccline.cmdbuff needs to be longer\n    if (ccline.cmdlen + len + 1 >= ccline.cmdbufflen)\n\tretval = realloc_cmdbuff(ccline.cmdlen + len + 1);\n    else\n\tretval = OK;\n    if (retval == OK)\n    {\n\tif (!ccline.overstrike)\n\t{\n\t    mch_memmove(ccline.cmdbuff + ccline.cmdpos + len,\n\t\t\t\t\t       ccline.cmdbuff + ccline.cmdpos,\n\t\t\t\t     (size_t)(ccline.cmdlen - ccline.cmdpos));\n\t    ccline.cmdlen += len;\n\t}\n\telse\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\t// Count nr of characters in the new string.\n\t\tm = 0;\n\t\tfor (i = 0; i < len; i += (*mb_ptr2len)(str + i))\n\t\t    ++m;\n\t\t// Count nr of bytes in cmdline that are overwritten by these\n\t\t// characters.\n\t\tfor (i = ccline.cmdpos; i < ccline.cmdlen && m > 0;\n\t\t\t\t i += (*mb_ptr2len)(ccline.cmdbuff + i))\n\t\t    --m;\n\t\tif (i < ccline.cmdlen)\n\t\t{\n\t\t    mch_memmove(ccline.cmdbuff + ccline.cmdpos + len,\n\t\t\t    ccline.cmdbuff + i, (size_t)(ccline.cmdlen - i));\n\t\t    ccline.cmdlen += ccline.cmdpos + len - i;\n\t\t}\n\t\telse\n\t\t    ccline.cmdlen = ccline.cmdpos + len;\n\t    }\n\t    else if (ccline.cmdpos + len > ccline.cmdlen)\n\t\tccline.cmdlen = ccline.cmdpos + len;\n\t}\n\tmch_memmove(ccline.cmdbuff + ccline.cmdpos, str, (size_t)len);\n\tccline.cmdbuff[ccline.cmdlen] = NUL;\n\n\tif (enc_utf8)\n\t{\n\t    // When the inserted text starts with a composing character,\n\t    // backup to the character before it.  There could be two of them.\n\t    i = 0;\n\t    c = utf_ptr2char(ccline.cmdbuff + ccline.cmdpos);\n\t    while (ccline.cmdpos > 0 && utf_iscomposing(c))\n\t    {\n\t\ti = (*mb_head_off)(ccline.cmdbuff,\n\t\t\t\t      ccline.cmdbuff + ccline.cmdpos - 1) + 1;\n\t\tccline.cmdpos -= i;\n\t\tlen += i;\n\t\tc = utf_ptr2char(ccline.cmdbuff + ccline.cmdpos);\n\t    }\n#ifdef FEAT_ARABIC\n\t    if (i == 0 && ccline.cmdpos > 0 && arabic_maycombine(c))\n\t    {\n\t\t// Check the previous character for Arabic combining pair.\n\t\ti = (*mb_head_off)(ccline.cmdbuff,\n\t\t\t\t      ccline.cmdbuff + ccline.cmdpos - 1) + 1;\n\t\tif (arabic_combine(utf_ptr2char(ccline.cmdbuff\n\t\t\t\t\t\t     + ccline.cmdpos - i), c))\n\t\t{\n\t\t    ccline.cmdpos -= i;\n\t\t    len += i;\n\t\t}\n\t\telse\n\t\t    i = 0;\n\t    }\n#endif\n\t    if (i != 0)\n\t    {\n\t\t// Also backup the cursor position.\n\t\ti = ptr2cells(ccline.cmdbuff + ccline.cmdpos);\n\t\tccline.cmdspos -= i;\n\t\tmsg_col -= i;\n\t\tif (msg_col < 0)\n\t\t{\n\t\t    msg_col += Columns;\n\t\t    --msg_row;\n\t\t}\n\t    }\n\t}\n\n\tif (redraw && !cmd_silent)\n\t{\n\t    msg_no_more = TRUE;\n\t    i = cmdline_row;\n\t    cursorcmd();\n\t    draw_cmdline(ccline.cmdpos, ccline.cmdlen - ccline.cmdpos);\n\t    // Avoid clearing the rest of the line too often.\n\t    if (cmdline_row != i || ccline.overstrike)\n\t\tmsg_clr_eos();\n\t    msg_no_more = FALSE;\n\t}\n\tif (KeyTyped)\n\t{\n\t    m = Columns * Rows;\n\t    if (m < 0)\t// overflow, Columns or Rows at weird value\n\t\tm = MAXCOL;\n\t}\n\telse\n\t    m = MAXCOL;\n\tfor (i = 0; i < len; ++i)\n\t{\n\t    c = cmdline_charsize(ccline.cmdpos);\n\t    // count \">\" for a double-wide char that doesn't fit.\n\t    if (has_mbyte)\n\t\tcorrect_cmdspos(ccline.cmdpos, c);\n\t    // Stop cursor at the end of the screen, but do increment the\n\t    // insert position, so that entering a very long command\n\t    // works, even though you can't see it.\n\t    if (ccline.cmdspos + c < m)\n\t\tccline.cmdspos += c;\n\n\t    if (has_mbyte)\n\t    {\n\t\tc = (*mb_ptr2len)(ccline.cmdbuff + ccline.cmdpos) - 1;\n\t\tif (c > len - i - 1)\n\t\t    c = len - i - 1;\n\t\tccline.cmdpos += c;\n\t\ti += c;\n\t    }\n\t    ++ccline.cmdpos;\n\t}\n    }\n    if (redraw)\n\tmsg_check();\n    return retval;\n}\n\nstatic cmdline_info_T\tprev_ccline;\nstatic int\t\tprev_ccline_used = FALSE;\n\n/*\n * Save ccline, because obtaining the \"=\" register may execute \"normal :cmd\"\n * and overwrite it.  But get_cmdline_str() may need it, thus make it\n * available globally in prev_ccline.\n */\n    static void\nsave_cmdline(cmdline_info_T *ccp)\n{\n    if (!prev_ccline_used)\n    {\n\tCLEAR_FIELD(prev_ccline);\n\tprev_ccline_used = TRUE;\n    }\n    *ccp = prev_ccline;\n    prev_ccline = ccline;\n    ccline.cmdbuff = NULL;  // signal that ccline is not in use\n}\n\n/*\n * Restore ccline after it has been saved with save_cmdline().\n */\n    static void\nrestore_cmdline(cmdline_info_T *ccp)\n{\n    ccline = prev_ccline;\n    prev_ccline = *ccp;\n}\n\n/*\n * Paste a yank register into the command line.\n * Used by CTRL-R command in command-line mode.\n * insert_reg() can't be used here, because special characters from the\n * register contents will be interpreted as commands.\n *\n * Return FAIL for failure, OK otherwise.\n */\n    static int\ncmdline_paste(\n    int regname,\n    int literally,\t// Insert text literally instead of \"as typed\"\n    int remcr)\t\t// remove trailing CR\n{\n    long\t\ti;\n    char_u\t\t*arg;\n    char_u\t\t*p;\n    int\t\t\tallocated;\n\n    // check for valid regname; also accept special characters for CTRL-R in\n    // the command line\n    if (regname != Ctrl_F && regname != Ctrl_P && regname != Ctrl_W\n\t    && regname != Ctrl_A && regname != Ctrl_L\n\t    && !valid_yank_reg(regname, FALSE))\n\treturn FAIL;\n\n    // A register containing CTRL-R can cause an endless loop.  Allow using\n    // CTRL-C to break the loop.\n    line_breakcheck();\n    if (got_int)\n\treturn FAIL;\n\n#ifdef FEAT_CLIPBOARD\n    regname = may_get_selection(regname);\n#endif\n\n    // Need to set \"textlock\" to avoid nasty things like going to another\n    // buffer when evaluating an expression.\n    ++textlock;\n    i = get_spec_reg(regname, &arg, &allocated, TRUE);\n    --textlock;\n\n    if (i)\n    {\n\t// Got the value of a special register in \"arg\".\n\tif (arg == NULL)\n\t    return FAIL;\n\n\t// When 'incsearch' is set and CTRL-R CTRL-W used: skip the duplicate\n\t// part of the word.\n\tp = arg;\n\tif (p_is && regname == Ctrl_W)\n\t{\n\t    char_u  *w;\n\t    int\t    len;\n\n\t    // Locate start of last word in the cmd buffer.\n\t    for (w = ccline.cmdbuff + ccline.cmdpos; w > ccline.cmdbuff; )\n\t    {\n\t\tif (has_mbyte)\n\t\t{\n\t\t    len = (*mb_head_off)(ccline.cmdbuff, w - 1) + 1;\n\t\t    if (!vim_iswordc(mb_ptr2char(w - len)))\n\t\t\tbreak;\n\t\t    w -= len;\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (!vim_iswordc(w[-1]))\n\t\t\tbreak;\n\t\t    --w;\n\t\t}\n\t    }\n\t    len = (int)((ccline.cmdbuff + ccline.cmdpos) - w);\n\t    if (p_ic ? STRNICMP(w, arg, len) == 0 : STRNCMP(w, arg, len) == 0)\n\t\tp += len;\n\t}\n\n\tcmdline_paste_str(p, literally);\n\tif (allocated)\n\t    vim_free(arg);\n\treturn OK;\n    }\n\n    return cmdline_paste_reg(regname, literally, remcr);\n}\n\n/*\n * Put a string on the command line.\n * When \"literally\" is TRUE, insert literally.\n * When \"literally\" is FALSE, insert as typed, but don't leave the command\n * line.\n */\n    void\ncmdline_paste_str(char_u *s, int literally)\n{\n    int\t\tc, cv;\n\n    if (literally)\n\tput_on_cmdline(s, -1, TRUE);\n    else\n\twhile (*s != NUL)\n\t{\n\t    cv = *s;\n\t    if (cv == Ctrl_V && s[1])\n\t\t++s;\n\t    if (has_mbyte)\n\t\tc = mb_cptr2char_adv(&s);\n\t    else\n\t\tc = *s++;\n\t    if (cv == Ctrl_V || c == ESC || c == Ctrl_C\n\t\t    || c == CAR || c == NL || c == Ctrl_L\n#ifdef UNIX\n\t\t    || c == intr_char\n#endif\n\t\t    || (c == Ctrl_BSL && *s == Ctrl_N))\n\t\tstuffcharReadbuff(Ctrl_V);\n\t    stuffcharReadbuff(c);\n\t}\n}\n\n/*\n * This function is called when the screen size changes and with incremental\n * search and in other situations where the command line may have been\n * overwritten.\n */\n    void\nredrawcmdline(void)\n{\n    redrawcmdline_ex(TRUE);\n}\n\n/*\n * When \"do_compute_cmdrow\" is TRUE the command line is redrawn at the bottom.\n * If FALSE cmdline_row is used, which should redraw in the same place.\n */\n    void\nredrawcmdline_ex(int do_compute_cmdrow)\n{\n    if (cmd_silent)\n\treturn;\n    need_wait_return = FALSE;\n    if (do_compute_cmdrow)\n\tcompute_cmdrow();\n    redrawcmd();\n    cursorcmd();\n}\n\n    static void\nredrawcmdprompt(void)\n{\n    int\t\ti;\n\n    if (cmd_silent)\n\treturn;\n    if (ccline.cmdfirstc != NUL)\n\tmsg_putchar(ccline.cmdfirstc);\n    if (ccline.cmdprompt != NULL)\n    {\n\tmsg_puts_attr((char *)ccline.cmdprompt, ccline.cmdattr);\n\tccline.cmdindent = msg_col + (msg_row - cmdline_row) * Columns;\n\t// do the reverse of set_cmdspos()\n\tif (ccline.cmdfirstc != NUL)\n\t    --ccline.cmdindent;\n    }\n    else\n\tfor (i = ccline.cmdindent; i > 0; --i)\n\t    msg_putchar(' ');\n}\n\n/*\n * Redraw what is currently on the command line.\n */\n    void\nredrawcmd(void)\n{\n    int save_in_echowindow = in_echowindow;\n\n    if (cmd_silent)\n\treturn;\n\n    // when 'incsearch' is set there may be no command line while redrawing\n    if (ccline.cmdbuff == NULL)\n    {\n\twindgoto(cmdline_row, 0);\n\tmsg_clr_eos();\n\treturn;\n    }\n\n    // Do not put this in the message window.\n    in_echowindow = FALSE;\n\n    sb_text_restart_cmdline();\n    msg_start();\n    redrawcmdprompt();\n\n    // Don't use more prompt, truncate the cmdline if it doesn't fit.\n    msg_no_more = TRUE;\n    draw_cmdline(0, ccline.cmdlen);\n    msg_clr_eos();\n    msg_no_more = FALSE;\n\n    set_cmdspos_cursor();\n    if (extra_char != NUL)\n\tputcmdline(extra_char, extra_char_shift);\n\n    /*\n     * An emsg() before may have set msg_scroll. This is used in normal mode,\n     * in cmdline mode we can reset them now.\n     */\n    msg_scroll = FALSE;\t\t// next message overwrites cmdline\n\n    // Typing ':' at the more prompt may set skip_redraw.  We don't want this\n    // in cmdline mode\n    skip_redraw = FALSE;\n\n    in_echowindow = save_in_echowindow;\n}\n\n    void\ncompute_cmdrow(void)\n{\n    // ignore \"msg_scrolled\" in update_screen(), it will be reset soon.\n    if (exmode_active || (msg_scrolled != 0 && !updating_screen))\n\tcmdline_row = Rows - 1;\n    else\n\tcmdline_row = W_WINROW(lastwin) + lastwin->w_height\n\t\t\t\t\t\t    + lastwin->w_status_height;\n}\n\n    void\ncursorcmd(void)\n{\n    if (cmd_silent)\n\treturn;\n\n#ifdef FEAT_RIGHTLEFT\n    if (cmdmsg_rl)\n    {\n\tmsg_row = cmdline_row  + (ccline.cmdspos / (int)(Columns - 1));\n\tmsg_col = (int)Columns - (ccline.cmdspos % (int)(Columns - 1)) - 1;\n\tif (msg_row <= 0)\n\t    msg_row = Rows - 1;\n    }\n    else\n#endif\n    {\n\tmsg_row = cmdline_row + (ccline.cmdspos / (int)Columns);\n\tmsg_col = ccline.cmdspos % (int)Columns;\n\tif (msg_row >= Rows)\n\t    msg_row = Rows - 1;\n    }\n\n    windgoto(msg_row, msg_col);\n#if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)\n    if (p_imst == IM_ON_THE_SPOT)\n\tredrawcmd_preedit();\n#endif\n#ifdef MCH_CURSOR_SHAPE\n    mch_update_cursor();\n#endif\n}\n\n    void\ngotocmdline(int clr)\n{\n    msg_start();\n#ifdef FEAT_RIGHTLEFT\n    if (cmdmsg_rl)\n\tmsg_col = Columns - 1;\n    else\n#endif\n\tmsg_col = 0;\t    // always start in column 0\n    if (clr)\t\t    // clear the bottom line(s)\n\tmsg_clr_eos();\t    // will reset clear_cmdline\n    windgoto(cmdline_row, 0);\n}\n\n/*\n * Check the word in front of the cursor for an abbreviation.\n * Called when the non-id character \"c\" has been entered.\n * When an abbreviation is recognized it is removed from the text with\n * backspaces and the replacement string is inserted, followed by \"c\".\n */\n    static int\nccheck_abbr(int c)\n{\n    int spos = 0;\n\n    if (p_paste || no_abbr)\t    // no abbreviations or in paste mode\n\treturn FALSE;\n\n    // Do not consider '<,'> be part of the mapping, skip leading whitespace.\n    // Actually accepts any mark.\n    while (VIM_ISWHITE(ccline.cmdbuff[spos]) && spos < ccline.cmdlen)\n\tspos++;\n    if (ccline.cmdlen - spos > 5\n\t    && ccline.cmdbuff[spos] == '\\''\n\t    && ccline.cmdbuff[spos + 2] == ','\n\t    && ccline.cmdbuff[spos + 3] == '\\'')\n\tspos += 5;\n    else\n\t// check abbreviation from the beginning of the commandline\n\tspos = 0;\n\n    return check_abbr(c, ccline.cmdbuff, ccline.cmdpos, spos);\n}\n\n/*\n * Escape special characters in \"fname\", depending on \"what\":\n * VSE_NONE: for when used as a file name argument after a Vim command.\n * VSE_SHELL: for a shell command.\n * VSE_BUFFER: for the \":buffer\" command.\n * Returns the result in allocated memory.\n */\n    char_u *\nvim_strsave_fnameescape(char_u *fname, int what)\n{\n    char_u\t*p;\n#ifdef BACKSLASH_IN_FILENAME\n    char_u\tbuf[20];\n    int\t\tj = 0;\n\n    // Don't escape '[', '{' and '!' if they are in 'isfname' and for the\n    // \":buffer\" command.\n    for (p = what == VSE_BUFFER ? BUFFER_ESC_CHARS : PATH_ESC_CHARS;\n\t\t\t\t\t\t\t\t*p != NUL; ++p)\n\tif ((*p != '[' && *p != '{' && *p != '!') || !vim_isfilec(*p))\n\t    buf[j++] = *p;\n    buf[j] = NUL;\n    p = vim_strsave_escaped(fname, buf);\n#else\n    p = vim_strsave_escaped(fname, what == VSE_SHELL ? SHELL_ESC_CHARS\n\t\t    : what == VSE_BUFFER ? BUFFER_ESC_CHARS : PATH_ESC_CHARS);\n    if (what == VSE_SHELL && csh_like_shell() && p != NULL)\n    {\n\tchar_u\t    *s;\n\n\t// For csh and similar shells need to put two backslashes before '!'.\n\t// One is taken by Vim, one by the shell.\n\ts = vim_strsave_escaped(p, (char_u *)\"!\");\n\tvim_free(p);\n\tp = s;\n    }\n#endif\n\n    // '>' and '+' are special at the start of some commands, e.g. \":edit\" and\n    // \":write\".  \"cd -\" has a special meaning.\n    if (p != NULL && (*p == '>' || *p == '+' || (*p == '-' && p[1] == NUL)))\n\tescape_fname(&p);\n\n    return p;\n}\n\n/*\n * Put a backslash before the file name in \"pp\", which is in allocated memory.\n */\n    void\nescape_fname(char_u **pp)\n{\n    char_u\t*p;\n\n    p = alloc(STRLEN(*pp) + 2);\n    if (p == NULL)\n\treturn;\n\n    p[0] = '\\\\';\n    STRCPY(p + 1, *pp);\n    vim_free(*pp);\n    *pp = p;\n}\n\n/*\n * For each file name in files[num_files]:\n * If 'orig_pat' starts with \"~/\", replace the home directory with \"~\".\n */\n    void\ntilde_replace(\n    char_u  *orig_pat,\n    int\t    num_files,\n    char_u  **files)\n{\n    int\t    i;\n    char_u  *p;\n\n    if (orig_pat[0] == '~' && vim_ispathsep(orig_pat[1]))\n    {\n\tfor (i = 0; i < num_files; ++i)\n\t{\n\t    p = home_replace_save(NULL, files[i]);\n\t    if (p != NULL)\n\t    {\n\t\tvim_free(files[i]);\n\t\tfiles[i] = p;\n\t    }\n\t}\n    }\n}\n\n/*\n * Get a pointer to the current command line info.\n */\n    cmdline_info_T *\nget_cmdline_info(void)\n{\n    return &ccline;\n}\n\n/*\n * Get pointer to the command line info to use. save_cmdline() may clear\n * ccline and put the previous value in prev_ccline.\n */\n    static cmdline_info_T *\nget_ccline_ptr(void)\n{\n    if ((State & MODE_CMDLINE) == 0)\n\treturn NULL;\n    if (ccline.cmdbuff != NULL)\n\treturn &ccline;\n    if (prev_ccline_used && prev_ccline.cmdbuff != NULL)\n\treturn &prev_ccline;\n    return NULL;\n}\n\n/*\n * Get the current command-line type.\n * Returns ':' or '/' or '?' or '@' or '>' or '-'\n * Only works when the command line is being edited.\n * Returns NUL when something is wrong.\n */\n    static int\nget_cmdline_type(void)\n{\n    cmdline_info_T *p = get_ccline_ptr();\n\n    if (p == NULL)\n\treturn NUL;\n    if (p->cmdfirstc == NUL)\n\treturn\n# ifdef FEAT_EVAL\n\t    (p->input_fn) ? '@' :\n# endif\n\t    '-';\n    return p->cmdfirstc;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Get the current command line in allocated memory.\n * Only works when the command line is being edited.\n * Returns NULL when something is wrong.\n */\n    static char_u *\nget_cmdline_str(void)\n{\n    cmdline_info_T *p;\n\n    if (cmdline_star > 0)\n\treturn NULL;\n    p = get_ccline_ptr();\n    if (p == NULL)\n\treturn NULL;\n    return vim_strnsave(p->cmdbuff, p->cmdlen);\n}\n\n/*\n * Get the current command-line completion type.\n */\n    static char_u *\nget_cmdline_completion(void)\n{\n    cmdline_info_T *p;\n    char_u\t*buffer;\n\n    if (cmdline_star > 0)\n\treturn NULL;\n\n    p = get_ccline_ptr();\n    if (p == NULL || p->xpc == NULL)\n\treturn NULL;\n\n    set_expand_context(p->xpc);\n    if (p->xpc->xp_context == EXPAND_UNSUCCESSFUL)\n\treturn NULL;\n\n    char_u *cmd_compl = cmdcomplete_type_to_str(p->xpc->xp_context);\n    if (cmd_compl == NULL)\n\treturn NULL;\n\n    if (p->xpc->xp_context == EXPAND_USER_LIST || p->xpc->xp_context == EXPAND_USER_DEFINED)\n    {\n\tbuffer = alloc(STRLEN(cmd_compl) + STRLEN(p->xpc->xp_arg) + 2);\n\tif (buffer == NULL)\n\t    return NULL;\n\tsprintf((char *)buffer, \"%s,%s\", cmd_compl, p->xpc->xp_arg);\n\treturn buffer;\n    }\n\n    return vim_strsave(cmd_compl);\n}\n\n/*\n * \"getcmdcompltype()\" function\n */\n    void\nf_getcmdcompltype(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = get_cmdline_completion();\n}\n\n/*\n * \"getcmdline()\" function\n */\n    void\nf_getcmdline(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = get_cmdline_str();\n}\n\n/*\n * \"getcmdpos()\" function\n */\n    void\nf_getcmdpos(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    cmdline_info_T *p = get_ccline_ptr();\n\n    rettv->vval.v_number = p != NULL ? p->cmdpos + 1 : 0;\n}\n\n/*\n * \"getcmdscreenpos()\" function\n */\n    void\nf_getcmdscreenpos(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    cmdline_info_T *p = get_ccline_ptr();\n\n    rettv->vval.v_number = p != NULL ? p->cmdspos + 1 : 0;\n}\n\n/*\n * \"getcmdtype()\" function\n */\n    void\nf_getcmdtype(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = alloc(2);\n    if (rettv->vval.v_string == NULL)\n\treturn;\n\n    rettv->vval.v_string[0] = get_cmdline_type();\n    rettv->vval.v_string[1] = NUL;\n}\n\n// Set the command line str to \"str\".\n// Returns 1 when failed, 0 when OK.\n    static int\nset_cmdline_str(char_u *str, int pos)\n{\n    cmdline_info_T  *p = get_ccline_ptr();\n    int\t\t    len;\n\n    if (p == NULL)\n\treturn 1;\n\n    len = (int)STRLEN(str);\n    realloc_cmdbuff(len + 1);\n    p->cmdlen = len;\n    STRCPY(p->cmdbuff, str);\n\n    p->cmdpos = pos < 0 || pos > p->cmdlen ? p->cmdlen : pos;\n    new_cmdpos = p->cmdpos;\n\n    redrawcmd();\n\n    // Trigger CmdlineChanged autocommands.\n    trigger_cmd_autocmd(get_cmdline_type(), EVENT_CMDLINECHANGED);\n\n    return 0;\n}\n\n/*\n * Set the command line byte position to \"pos\".  Zero is the first position.\n * Only works when the command line is being edited.\n * Returns 1 when failed, 0 when OK.\n */\n    static int\nset_cmdline_pos(\n    int\t\tpos)\n{\n    cmdline_info_T *p = get_ccline_ptr();\n\n    if (p == NULL)\n\treturn 1;\n\n    // The position is not set directly but after CTRL-\\ e or CTRL-R = has\n    // changed the command line.\n    if (pos < 0)\n\tnew_cmdpos = 0;\n    else\n\tnew_cmdpos = pos;\n    return 0;\n}\n\n// \"setcmdline()\" function\n    void\nf_setcmdline(typval_T *argvars, typval_T *rettv)\n{\n    int pos = -1;\n\n    if (check_for_string_arg(argvars, 0) == FAIL\n\t    || check_for_opt_number_arg(argvars, 1) == FAIL)\n\treturn;\n\n    if (argvars[1].v_type != VAR_UNKNOWN)\n    {\n\tint error = FALSE;\n\n\tpos = (int)tv_get_number_chk(&argvars[1], &error) - 1;\n\tif (error)\n\t    return;\n\tif (pos < 0)\n\t{\n\t    emsg(_(e_argument_must_be_positive));\n\t    return;\n\t}\n    }\n\n    // Use tv_get_string() to handle a NULL string like an empty string.\n    rettv->vval.v_number = set_cmdline_str(tv_get_string(&argvars[0]), pos);\n}\n\n/*\n * \"setcmdpos()\" function\n */\n    void\nf_setcmdpos(typval_T *argvars, typval_T *rettv)\n{\n    int\t\tpos;\n\n    if (in_vim9script() && check_for_number_arg(argvars, 0) == FAIL)\n\treturn;\n\n    pos = (int)tv_get_number(&argvars[0]) - 1;\n    if (pos >= 0)\n\trettv->vval.v_number = set_cmdline_pos(pos);\n}\n#endif\n\n/*\n * Return the first character of the current command line.\n */\n    int\nget_cmdline_firstc(void)\n{\n    return ccline.cmdfirstc;\n}\n\n/*\n * Get indices \"num1,num2\" that specify a range within a list (not a range of\n * text lines in a buffer!) from a string.  Used for \":history\" and \":clist\".\n * Returns OK if parsed successfully, otherwise FAIL.\n */\n    int\nget_list_range(char_u **str, int *num1, int *num2)\n{\n    int\t\tlen;\n    int\t\tfirst = FALSE;\n    varnumber_T\tnum;\n\n    *str = skipwhite(*str);\n    if (**str == '-' || vim_isdigit(**str))  // parse \"from\" part of range\n    {\n\tvim_str2nr(*str, NULL, &len, 0, &num, NULL, 0, FALSE, NULL);\n\t*str += len;\n\t*num1 = (int)num;\n\tfirst = TRUE;\n    }\n    *str = skipwhite(*str);\n    if (**str == ',')\t\t\t// parse \"to\" part of range\n    {\n\t*str = skipwhite(*str + 1);\n\tvim_str2nr(*str, NULL, &len, 0, &num, NULL, 0, FALSE, NULL);\n\tif (len > 0)\n\t{\n\t    *num2 = (int)num;\n\t    *str = skipwhite(*str + len);\n\t}\n\telse if (!first)\t\t// no number given at all\n\t    return FAIL;\n    }\n    else if (first)\t\t\t// only one number given\n\t*num2 = *num1;\n    return OK;\n}\n\n/*\n * Check value of 'cedit' and set cedit_key.\n * Returns NULL if value is OK, error message otherwise.\n */\n    char *\ndid_set_cedit(optset_T *args UNUSED)\n{\n    int n;\n\n    if (*p_cedit == NUL)\n\tcedit_key = -1;\n    else\n    {\n\tn = string_to_key(p_cedit, FALSE);\n\tif (vim_isprintc(n))\n\t    return e_invalid_argument;\n\tcedit_key = n;\n    }\n    return NULL;\n}\n\n/*\n * Open a window on the current command line and history.  Allow editing in\n * the window.  Returns when the window is closed.\n * Returns:\n *\tCR\t if the command is to be executed\n *\tCtrl_C\t if it is to be abandoned\n *\tK_IGNORE if editing continues\n */\n    static int\nopen_cmdwin(void)\n{\n    bufref_T\t\told_curbuf;\n    win_T\t\t*old_curwin = curwin;\n    bufref_T\t\tbufref;\n    win_T\t\t*wp;\n    int\t\t\ti;\n    linenr_T\t\tlnum;\n    int\t\t\thisttype;\n    garray_T\t\twinsizes;\n    int\t\t\tsave_restart_edit = restart_edit;\n    int\t\t\tsave_State = State;\n    int\t\t\tsave_exmode = exmode_active;\n#ifdef FEAT_RIGHTLEFT\n    int\t\t\tsave_cmdmsg_rl = cmdmsg_rl;\n#endif\n#ifdef FEAT_FOLDING\n    int\t\t\tsave_KeyTyped;\n#endif\n\n    // Can't do this when text or buffer is locked.\n    // Can't do this recursively.  Can't do it when typing a password.\n    if (text_or_buf_locked()\n\t    || cmdwin_type != 0\n# if defined(FEAT_CRYPT) || defined(FEAT_EVAL)\n\t    || cmdline_star > 0\n# endif\n\t    )\n    {\n\tbeep_flush();\n\treturn K_IGNORE;\n    }\n    set_bufref(&old_curbuf, curbuf);\n\n    // Save current window sizes.\n    win_size_save(&winsizes);\n\n    // When using completion in Insert mode with <C-R>=<C-F> one can open the\n    // command line window, but we don't want the popup menu then.\n    pum_undisplay();\n\n    // don't use a new tab page\n    cmdmod.cmod_tab = 0;\n    cmdmod.cmod_flags |= CMOD_NOSWAPFILE;\n\n    // Create a window for the command-line buffer.\n    if (win_split((int)p_cwh, WSP_BOT) == FAIL)\n    {\n\tbeep_flush();\n\tga_clear(&winsizes);\n\treturn K_IGNORE;\n    }\n    // Don't let quitting the More prompt make this fail.\n    got_int = FALSE;\n\n    // Set \"cmdwin_type\" before any autocommands may mess things up.\n    cmdwin_type = get_cmdline_type();\n\n    // Create the command-line buffer empty.\n    if (do_ecmd(0, NULL, NULL, NULL, ECMD_ONE, ECMD_HIDE, NULL) == FAIL)\n    {\n\t// Some autocommand messed it up?\n\twin_close(curwin, TRUE);\n\tga_clear(&winsizes);\n\tcmdwin_type = 0;\n\treturn Ctrl_C;\n    }\n\n    apply_autocmds(EVENT_BUFFILEPRE, NULL, NULL, FALSE, curbuf);\n    (void)setfname(curbuf, (char_u *)_(\"[Command Line]\"), NULL, TRUE);\n    apply_autocmds(EVENT_BUFFILEPOST, NULL, NULL, FALSE, curbuf);\n    set_option_value_give_err((char_u *)\"bt\",\n\t\t\t\t\t    0L, (char_u *)\"nofile\", OPT_LOCAL);\n    curbuf->b_p_ma = TRUE;\n#ifdef FEAT_FOLDING\n    curwin->w_p_fen = FALSE;\n#endif\n# ifdef FEAT_RIGHTLEFT\n    curwin->w_p_rl = cmdmsg_rl;\n    cmdmsg_rl = FALSE;\n# endif\n    RESET_BINDING(curwin);\n\n    // Don't allow switching to another buffer.\n    ++curbuf_lock;\n\n    // Showing the prompt may have set need_wait_return, reset it.\n    need_wait_return = FALSE;\n\n    histtype = hist_char2type(cmdwin_type);\n    if (histtype == HIST_CMD || histtype == HIST_DEBUG)\n    {\n\tif (p_wc == TAB)\n\t{\n\t    // Make Tab start command-line completion: CTRL-X CTRL-V\n\t    add_map((char_u *)\"<buffer> <Tab> <C-X><C-V>\", MODE_INSERT, TRUE);\n\t    add_map((char_u *)\"<buffer> <Tab> a<C-X><C-V>\", MODE_NORMAL, TRUE);\n\n\t    // Make S-Tab work like CTRL-P in command-line completion\n\t    add_map((char_u *)\"<buffer> <S-Tab> <C-P>\", MODE_INSERT, TRUE);\n\t}\n\tset_option_value_give_err((char_u *)\"ft\",\n\t\t\t\t\t       0L, (char_u *)\"vim\", OPT_LOCAL);\n    }\n    --curbuf_lock;\n\n    // Reset 'textwidth' after setting 'filetype' (the Vim filetype plugin\n    // sets 'textwidth' to 78).\n    curbuf->b_p_tw = 0;\n\n    // Fill the buffer with the history.\n    init_history();\n    if (get_hislen() > 0)\n    {\n\ti = *get_hisidx(histtype);\n\tif (i >= 0)\n\t{\n\t    lnum = 0;\n\t    do\n\t    {\n\t\tif (++i == get_hislen())\n\t\t    i = 0;\n\t\tif (get_histentry(histtype)[i].hisstr != NULL)\n\t\t    ml_append(lnum++, get_histentry(histtype)[i].hisstr,\n\t\t\t\t\t\t\t   (colnr_T)0, FALSE);\n\t    }\n\t    while (i != *get_hisidx(histtype));\n\t}\n    }\n\n    // Replace the empty last line with the current command-line and put the\n    // cursor there.\n    ml_replace(curbuf->b_ml.ml_line_count, ccline.cmdbuff, TRUE);\n    curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n    curwin->w_cursor.col = ccline.cmdpos;\n    changed_line_abv_curs();\n    invalidate_botline();\n    redraw_later(UPD_SOME_VALID);\n\n    // No Ex mode here!\n    exmode_active = 0;\n\n    State = MODE_NORMAL;\n    setmouse();\n\n    // Reset here so it can be set by a CmdWinEnter autocommand.\n    cmdwin_result = 0;\n\n    // Trigger CmdwinEnter autocommands.\n    trigger_cmd_autocmd(cmdwin_type, EVENT_CMDWINENTER);\n    if (restart_edit != 0)\t// autocmd with \":startinsert\"\n\tstuffcharReadbuff(K_NOP);\n\n    int save_RedrawingDisabled = RedrawingDisabled;\n    RedrawingDisabled = 0;\n\n    /*\n     * Call the main loop until <CR> or CTRL-C is typed.\n     */\n    main_loop(TRUE, FALSE);\n\n    RedrawingDisabled = save_RedrawingDisabled;\n\n# ifdef FEAT_FOLDING\n    save_KeyTyped = KeyTyped;\n# endif\n\n    // Trigger CmdwinLeave autocommands.\n    trigger_cmd_autocmd(cmdwin_type, EVENT_CMDWINLEAVE);\n\n# ifdef FEAT_FOLDING\n    // Restore KeyTyped in case it is modified by autocommands\n    KeyTyped = save_KeyTyped;\n# endif\n\n    cmdwin_type = 0;\n    exmode_active = save_exmode;\n\n    // Safety check: The old window or buffer was deleted: It's a bug when\n    // this happens!\n    if (!win_valid(old_curwin) || !bufref_valid(&old_curbuf))\n    {\n\tcmdwin_result = Ctrl_C;\n\temsg(_(e_active_window_or_buffer_deleted));\n    }\n    else\n    {\n# if defined(FEAT_EVAL)\n\t// autocmds may abort script processing\n\tif (aborting() && cmdwin_result != K_IGNORE)\n\t    cmdwin_result = Ctrl_C;\n# endif\n\t// Set the new command line from the cmdline buffer.\n\tvim_free(ccline.cmdbuff);\n\tif (cmdwin_result == K_XF1 || cmdwin_result == K_XF2) // :qa[!] typed\n\t{\n\t    char *p = (cmdwin_result == K_XF2) ? \"qa\" : \"qa!\";\n\n\t    if (histtype == HIST_CMD)\n\t    {\n\t\t// Execute the command directly.\n\t\tccline.cmdbuff = vim_strsave((char_u *)p);\n\t\tcmdwin_result = CAR;\n\t    }\n\t    else\n\t    {\n\t\t// First need to cancel what we were doing.\n\t\tccline.cmdbuff = NULL;\n\t\tstuffcharReadbuff(':');\n\t\tstuffReadbuff((char_u *)p);\n\t\tstuffcharReadbuff(CAR);\n\t    }\n\t}\n\telse if (cmdwin_result == Ctrl_C)\n\t{\n\t    // :q or :close, don't execute any command\n\t    // and don't modify the cmd window.\n\t    ccline.cmdbuff = NULL;\n\t}\n\telse\n\t    ccline.cmdbuff = vim_strsave(ml_get_curline());\n\tif (ccline.cmdbuff == NULL)\n\t{\n\t    ccline.cmdbuff = vim_strsave((char_u *)\"\");\n\t    ccline.cmdlen = 0;\n\t    ccline.cmdbufflen = 1;\n\t    ccline.cmdpos = 0;\n\t    cmdwin_result = Ctrl_C;\n\t}\n\telse\n\t{\n\t    ccline.cmdlen = (int)STRLEN(ccline.cmdbuff);\n\t    ccline.cmdbufflen = ccline.cmdlen + 1;\n\t    ccline.cmdpos = curwin->w_cursor.col;\n\t    // If the cursor is on the last character, it probably should be\n\t    // after it.\n\t    if (ccline.cmdpos == ccline.cmdlen - 1\n\t\t    || ccline.cmdpos > ccline.cmdlen)\n\t\tccline.cmdpos = ccline.cmdlen;\n\t}\n\n# ifdef FEAT_CONCEAL\n\t// Avoid command-line window first character being concealed.\n\tcurwin->w_p_cole = 0;\n# endif\n\t// First go back to the original window.\n\twp = curwin;\n\tset_bufref(&bufref, curbuf);\n\n\tskip_win_fix_cursor = TRUE;\n\twin_goto(old_curwin);\n\n\t// win_goto() may trigger an autocommand that already closes the\n\t// cmdline window.\n\tif (win_valid(wp) && wp != curwin)\n\t    win_close(wp, TRUE);\n\n\t// win_close() may have already wiped the buffer when 'bh' is\n\t// set to 'wipe', autocommands may have closed other windows\n\tif (bufref_valid(&bufref) && bufref.br_buf != curbuf)\n\t    close_buffer(NULL, bufref.br_buf, DOBUF_WIPE, FALSE, FALSE);\n\n\t// Restore window sizes.\n\twin_size_restore(&winsizes);\n\tskip_win_fix_cursor = FALSE;\n\n\tif (cmdwin_result == K_IGNORE)\n\t{\n\t    // It can be confusing that the cmdwin still shows, redraw the\n\t    // screen.\n\t    update_screen(UPD_VALID);\n\t    set_cmdspos_cursor();\n\t    redrawcmd();\n\t}\n    }\n\n    ga_clear(&winsizes);\n    restart_edit = save_restart_edit;\n# ifdef FEAT_RIGHTLEFT\n    cmdmsg_rl = save_cmdmsg_rl;\n# endif\n\n    State = save_State;\n    may_trigger_modechanged();\n    setmouse();\n\n    return cmdwin_result;\n}\n\n/*\n * Return TRUE if in the cmdwin, not editing the command line.\n */\n    int\nis_in_cmdwin(void)\n{\n    return cmdwin_type != 0 && get_cmdline_type() == NUL;\n}\n\n/*\n * Used for commands that either take a simple command string argument, or:\n *\tcmd << endmarker\n *\t  {script}\n *\tendmarker\n * Returns a pointer to allocated memory with {script} or NULL.\n */\n    char_u *\nscript_get(exarg_T *eap UNUSED, char_u *cmd UNUSED)\n{\n#ifdef FEAT_EVAL\n    list_T\t*l;\n    listitem_T\t*li;\n    char_u\t*s;\n    garray_T\tga;\n\n    if (cmd[0] != '<' || cmd[1] != '<' || eap->getline == NULL)\n\treturn NULL;\n    cmd += 2;\n\n    l = heredoc_get(eap, cmd, TRUE, FALSE);\n    if (l == NULL)\n\treturn NULL;\n\n    ga_init2(&ga, 1, 0x400);\n\n    FOR_ALL_LIST_ITEMS(l, li)\n    {\n\ts = tv_get_string(&li->li_tv);\n\tga_concat(&ga, s);\n\tga_append(&ga, '\\n');\n    }\n    ga_append(&ga, NUL);\n\n    list_free(l);\n    return (char_u *)ga.ga_data;\n#else\n    return NULL;\n#endif\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * This function is used by f_input() and f_inputdialog() functions. The third\n * argument to f_input() specifies the type of completion to use at the\n * prompt. The third argument to f_inputdialog() specifies the value to return\n * when the user cancels the prompt.\n */\n    void\nget_user_input(\n    typval_T\t*argvars,\n    typval_T\t*rettv,\n    int\t\tinputdialog,\n    int\t\tsecret)\n{\n    char_u\t*prompt;\n    char_u\t*p = NULL;\n    int\t\tc;\n    char_u\tbuf[NUMBUFLEN];\n    int\t\tcmd_silent_save = cmd_silent;\n    char_u\t*defstr = (char_u *)\"\";\n    int\t\txp_type = EXPAND_NOTHING;\n    char_u\t*xp_arg = NULL;\n\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = NULL;\n    if (input_busy)\n\treturn;  // this doesn't work recursively.\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_opt_string_arg(argvars, 1) == FAIL\n\t\t|| (argvars[1].v_type != VAR_UNKNOWN\n\t\t    && check_for_opt_string_arg(argvars, 2) == FAIL)))\n\treturn;\n\n    prompt = tv_get_string_chk(&argvars[0]);\n\n#ifdef NO_CONSOLE_INPUT\n    // While starting up, there is no place to enter text. When running tests\n    // with --not-a-term we assume feedkeys() will be used.\n    if (no_console_input() && !is_not_a_term())\n\treturn;\n#endif\n\n    cmd_silent = FALSE;\t\t// Want to see the prompt.\n    if (prompt != NULL)\n    {\n\t// Only the part of the message after the last NL is considered as\n\t// prompt for the command line\n\tp = vim_strrchr(prompt, '\\n');\n\tif (p == NULL)\n\t    p = prompt;\n\telse\n\t{\n\t    ++p;\n\t    c = *p;\n\t    *p = NUL;\n\t    msg_start();\n\t    msg_clr_eos();\n\t    msg_puts_attr((char *)prompt, get_echo_attr());\n\t    msg_didout = FALSE;\n\t    msg_starthere();\n\t    *p = c;\n\t}\n\tcmdline_row = msg_row;\n\n\tif (argvars[1].v_type != VAR_UNKNOWN)\n\t{\n\t    defstr = tv_get_string_buf_chk(&argvars[1], buf);\n\t    if (defstr != NULL)\n\t\tstuffReadbuffSpec(defstr);\n\n\t    if (!inputdialog && argvars[2].v_type != VAR_UNKNOWN)\n\t    {\n\t\tchar_u\t*xp_name;\n\t\tint\txp_namelen;\n\t\tlong\targt = 0;\n\n\t\t// input() with a third argument: completion\n\t\trettv->vval.v_string = NULL;\n\n\t\txp_name = tv_get_string_buf_chk(&argvars[2], buf);\n\t\tif (xp_name == NULL)\n\t\t    return;\n\n\t\txp_namelen = (int)STRLEN(xp_name);\n\n\t\tif (parse_compl_arg(xp_name, xp_namelen, &xp_type, &argt,\n\t\t\t\t\t\t\t     &xp_arg) == FAIL)\n\t\t    return;\n\t    }\n\t}\n\n\tif (defstr != NULL)\n\t{\n\t    int save_ex_normal_busy = ex_normal_busy;\n\t    int save_vgetc_busy = vgetc_busy;\n\t    int save_input_busy = input_busy;\n\n\t    input_busy |= vgetc_busy;\n\t    ex_normal_busy = 0;\n\t    vgetc_busy = 0;\n\t    rettv->vval.v_string =\n\t\tgetcmdline_prompt(secret ? NUL : '@', p, get_echo_attr(),\n\t\t\t\t\t\t\t      xp_type, xp_arg);\n\t    ex_normal_busy = save_ex_normal_busy;\n\t    vgetc_busy = save_vgetc_busy;\n\t    input_busy = save_input_busy;\n\t}\n\tif (inputdialog && rettv->vval.v_string == NULL\n\t\t&& argvars[1].v_type != VAR_UNKNOWN\n\t\t&& argvars[2].v_type != VAR_UNKNOWN)\n\t    rettv->vval.v_string = vim_strsave(tv_get_string_buf(\n\t\t\t\t\t\t\t   &argvars[2], buf));\n\n\tvim_free(xp_arg);\n\n\t// since the user typed this, no need to wait for return\n\tneed_wait_return = FALSE;\n\tmsg_didout = FALSE;\n    }\n    cmd_silent = cmd_silent_save;\n}\n#endif\n", "\" Tests for the history functions\n\nsource check.vim\nCheckFeature cmdline_hist\n\nset history=7\n\nfunction History_Tests(hist)\n  \" First clear the history\n  call histadd(a:hist, 'dummy')\n  call assert_true(histdel(a:hist))\n  call assert_equal(-1, histnr(a:hist))\n  call assert_equal('', histget(a:hist))\n\n  call assert_true('ls'->histadd(a:hist))\n  call assert_true(histadd(a:hist, 'buffers'))\n  call assert_equal('buffers', histget(a:hist))\n  call assert_equal('ls', histget(a:hist, -2))\n  call assert_equal('ls', histget(a:hist, 1))\n  call assert_equal('', histget(a:hist, 5))\n  call assert_equal('', histget(a:hist, -5))\n  call assert_equal(2, histnr(a:hist))\n  call assert_true(histdel(a:hist, 2))\n  call assert_false(a:hist->histdel(7))\n  call assert_equal(1, histnr(a:hist))\n  call assert_equal('ls', histget(a:hist, -1))\n\n  call assert_true(histadd(a:hist, 'buffers'))\n  call assert_true(histadd(a:hist, 'ls'))\n  call assert_equal('ls', a:hist->histget(-1))\n  call assert_equal(4, a:hist->histnr())\n\n  let a=execute('history ' . a:hist)\n  call assert_match(\"^\\n      #  \\\\S* history\\n      3  buffers\\n>     4  ls$\", a)\n  let a=execute('history all')\n  call assert_match(\"^\\n      #  .* history\\n      3  buffers\\n>     4  ls\", a)\n\n  if len(a:hist) > 0\n    let a=execute('history ' . a:hist . ' 2')\n    call assert_match(\"^\\n      #  \\\\S* history$\", a)\n    let a=execute('history ' . a:hist . ' 3')\n    call assert_match(\"^\\n      #  \\\\S* history\\n      3  buffers$\", a)\n    let a=execute('history ' . a:hist . ' 4')\n    call assert_match(\"^\\n      #  \\\\S* history\\n>     4  ls$\", a)\n    let a=execute('history ' . a:hist . ' 3,4')\n    call assert_match(\"^\\n      #  \\\\S* history\\n      3  buffers\\n>     4  ls$\", a)\n    let a=execute('history ' . a:hist . ' -1')\n    call assert_match(\"^\\n      #  \\\\S* history\\n>     4  ls$\", a)\n    let a=execute('history ' . a:hist . ' -2')\n    call assert_match(\"^\\n      #  \\\\S* history\\n      3  buffers$\", a)\n    let a=execute('history ' . a:hist . ' -2,')\n    call assert_match(\"^\\n      #  \\\\S* history\\n      3  buffers\\n>     4  ls$\", a)\n    let a=execute('history ' . a:hist . ' -3')\n    call assert_match(\"^\\n      #  \\\\S* history$\", a)\n  endif\n\n  \" Test for removing entries matching a pattern\n  for i in range(1, 3)\n      call histadd(a:hist, 'text_' . i)\n  endfor\n  call assert_true(histdel(a:hist, 'text_\\d\\+'))\n  call assert_equal('ls', histget(a:hist, -1))\n\n  \" Test for freeing the entire history list\n  for i in range(1, 7)\n      call histadd(a:hist, 'text_' . i)\n  endfor\n  call histdel(a:hist)\n  for i in range(1, 7)\n    call assert_equal('', histget(a:hist, i))\n    call assert_equal('', histget(a:hist, i - 7 - 1))\n  endfor\n\n  \" Test for freeing an entry at the beginning of the history list\n  for i in range(1, 4)\n      call histadd(a:hist, 'text_' . i)\n  endfor\n  call histdel(a:hist, 1)\n  call assert_equal('', histget(a:hist, 1))\n  call assert_equal('text_4', histget(a:hist, 4))\nendfunction\n\nfunction Test_History()\n  for h in ['cmd', ':', '', 'search', '/', '?', 'expr', '=', 'input', '@', 'debug', '>']\n    call History_Tests(h)\n  endfor\n\n  \" Negative tests\n  call assert_false(histdel('abc'))\n  call assert_equal('', histget('abc'))\n  call assert_fails('call histdel([])', 'E730:')\n  call assert_equal('', histget(10))\n  call assert_fails('call histget([])', 'E730:')\n  call assert_equal(-1, histnr('abc'))\n  call assert_fails('call histnr([])', 'E730:')\n  call assert_fails('history xyz', 'E488:')\n  call assert_fails('history ,abc', 'E488:')\n  call assert_fails('call histdel(\":\", \"\\\\%(\")', 'E53:')\nendfunction\n\nfunction Test_history_truncates_long_entry()\n  \" History entry short enough to fit on the screen should not be truncated.\n  call histadd(':', 'echo x' .. repeat('y', &columns - 17) .. 'z')\n  let a = execute('history : -1')\n\n  call assert_match(\"^\\n      #  cmd history\\n\"\n        \\        .. \"> *\\\\d\\\\+  echo x\" .. repeat('y', &columns - 17) ..  'z$', a)\n\n  \" Long history entry should be truncated to fit on the screen, with, '...'\n  \" inserted in the string to indicate the that there is truncation.\n  call histadd(':', 'echo x' .. repeat('y', &columns - 16) .. 'z')\n  let a = execute('history : -1')\n  call assert_match(\"^\\n      #  cmd history\\n\"\n        \\        .. \">  *\\\\d\\\\+  echo xy\\\\+\\.\\.\\.y\\\\+z$\", a)\nendfunction\n\nfunction Test_Search_history_window()\n  new\n  call setline(1, ['a', 'b', 'a', 'b'])\n  1\n  call feedkeys(\"/a\\<CR>\", 'xt')\n  call assert_equal('a', getline('.'))\n  1\n  call feedkeys(\"/b\\<CR>\", 'xt')\n  call assert_equal('b', getline('.'))\n  1\n  \" select the previous /a command\n  call feedkeys(\"q/kk\\<CR>\", 'x!')\n  call assert_equal('a', getline('.'))\n  call assert_equal('a', @/)\n  bwipe!\nendfunc\n\n\" Test for :history command option completion\nfunction Test_history_completion()\n  call feedkeys(\":history \\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"history / : = > ? @ all cmd debug expr input search', @:)\nendfunc\n\n\" Test for increasing the 'history' option value\nfunc Test_history_size()\n  let save_histsz = &history\n  set history=10\n  call histadd(':', 'ls')\n  call histdel(':')\n  for i in range(1, 5)\n    call histadd(':', 'cmd' .. i)\n  endfor\n  call assert_equal(5, histnr(':'))\n  call assert_equal('cmd5', histget(':', -1))\n\n  set history=15\n  for i in range(6, 10)\n    call histadd(':', 'cmd' .. i)\n  endfor\n  call assert_equal(10, histnr(':'))\n  call assert_equal('cmd1', histget(':', 1))\n  call assert_equal('cmd10', histget(':', -1))\n\n  set history=5\n  call histadd(':', 'abc')\n  call assert_equal('', histget(':', 6))\n  call assert_equal('', histget(':', 12))\n  call assert_equal('cmd7', histget(':', 7))\n  call assert_equal('abc', histget(':', -1))\n\n  \" This test works only when the language is English\n  if v:lang == \"C\" || v:lang =~ '^[Ee]n'\n    set history=0\n    redir => v\n    call feedkeys(\":history\\<CR>\", 'xt')\n    redir END\n    call assert_equal([\"'history' option is zero\"], split(v, \"\\n\"))\n  endif\n\n  let &history=save_histsz\nendfunc\n\n\" Test for recalling old search patterns in /\nfunc Test_history_search()\n  call histdel('/')\n  let g:pat = []\n  func SavePat()\n    call add(g:pat, getcmdline())\n    return ''\n  endfunc\n  cnoremap <F2> <C-\\>eSavePat()<CR>\n  call histadd('/', 'pat1')\n  call histadd('/', 'pat2')\n  let @/ = ''\n  call feedkeys(\"/\\<Up>\\<F2>\\<Up>\\<F2>\\<Down>\\<Down>\\<F2>\\<Esc>\", 'xt')\n  call assert_equal(['pat2', 'pat1', ''], g:pat)\n  cunmap <F2>\n  delfunc SavePat\n\n  \" Search for a pattern that is not present in the history\n  call assert_beeps('call feedkeys(\"/a1b2\\<Up>\\<CR>\", \"xt\")')\n\n  \" Recall patterns with 'history' set to 0\n  set history=0\n  let @/ = 'abc'\n  let cmd = 'call feedkeys(\"/\\<Up>\\<Down>\\<S-Up>\\<S-Down>\\<CR>\", \"xt\")'\n  call assert_fails(cmd, 'E486:')\n  set history&\n\n  \" Recall patterns till the end of history\n  set history=4\n  call histadd('/', 'pat')\n  call histdel('/')\n  call histadd('/', 'pat1')\n  call histadd('/', 'pat2')\n  call assert_beeps('call feedkeys(\"/\\<Up>\\<Up>\\<Up>\\<C-U>\\<cr>\", \"xt\")')\n  call assert_beeps('call feedkeys(\"/\\<Down><cr>\", \"xt\")')\n\n  \" Test for wrapping around the history list\n  for i in range(3, 7)\n    call histadd('/', 'pat' .. i)\n  endfor\n  let upcmd = \"\\<up>\\<up>\\<up>\\<up>\\<up>\"\n  let downcmd = \"\\<down>\\<down>\\<down>\\<down>\\<down>\"\n  try\n    call feedkeys(\"/\" .. upcmd .. \"\\<cr>\", 'xt')\n  catch /E486:/\n  endtry\n  call assert_equal('pat4', @/)\n  try\n    call feedkeys(\"/\" .. upcmd .. downcmd .. \"\\<cr>\", 'xt')\n  catch /E486:/\n  endtry\n  call assert_equal('pat4', @/)\n\n  \" Test for changing the search command separator in the history\n  call assert_fails('call feedkeys(\"/def/\\<cr>\", \"xt\")', 'E486:')\n  call assert_fails('call feedkeys(\"?\\<up>\\<cr>\", \"xt\")', 'E486:')\n  call assert_equal('def?', histget('/', -1))\n\n  call assert_fails('call feedkeys(\"/ghi?\\<cr>\", \"xt\")', 'E486:')\n  call assert_fails('call feedkeys(\"?\\<up>\\<cr>\", \"xt\")', 'E486:')\n  call assert_equal('ghi\\?', histget('/', -1))\n\n  set history&\nendfunc\n\n\" Test for making sure the key value is not stored in history\nfunc Test_history_crypt_key()\n  CheckFeature cryptv\n\n  call feedkeys(\":set bs=2 key=abc ts=8\\<CR>\", 'xt')\n  call assert_equal('set bs=2 key= ts=8', histget(':'))\n\n  call assert_fails(\"call feedkeys(':set bs=2 key-=abc ts=8\\<CR>', 'xt')\")\n  call assert_equal('set bs=2 key-= ts=8', histget(':'))\n\n  set key& bs& ts&\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion != NULL)\n\treturn;\n\n#ifdef BUILD_DATE\n    char *date_time = BUILD_DATE;\n#else\n    char *date_time = __DATE__ \" \" __TIME__;\n#endif\n    char *msg = _(\"%s (%s, compiled %s)\");\n    size_t len = strlen(msg)\n\t+ strlen(VIM_VERSION_LONG_ONLY)\n\t+ strlen(VIM_VERSION_DATE_ONLY)\n\t+ strlen(date_time);\n\n    longVersion = alloc(len);\n    if (longVersion == NULL)\n\tlongVersion = VIM_VERSION_LONG;\n    else\n\tvim_snprintf(longVersion, len, msg,\n\t\tVIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n\t\"++builtin_terms\",\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n\t\"+cmdline_info\",\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n\t\"+file_in_path\",\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n\t\"+float\",\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n\t\"-footer\",\n\t// only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n\t\"+path_extra\",\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n#  ifdef DYNAMIC_PYTHON3_STABLE_ABI\n\t\"+python3/dyn-stable\",\n#  else\n\t\"+python3/dyn\",\n#  endif\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n\t\"+wildignore\",\n\t\"+wildmenu\",\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n# ifdef FEAT_XATTR\n\t\"+xattr\",\n# else\n\t\"-xattr\",\n# endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * cmdhist.c: Functions for the history of the command-line.\n */\n\n#include \"vim.h\"\n\nstatic histentry_T *(history[HIST_COUNT]) = {NULL, NULL, NULL, NULL, NULL};\nstatic int\thisidx[HIST_COUNT] = {-1, -1, -1, -1, -1};  // lastused entry\nstatic int\thisnum[HIST_COUNT] = {0, 0, 0, 0, 0};\n\t\t    // identifying (unique) number of newest history entry\nstatic int\thislen = 0;\t\t// actual length of history tables\n\n/*\n * Return the length of the history tables\n */\n    int\nget_hislen(void)\n{\n    return hislen;\n}\n\n/*\n * Return a pointer to a specified history table\n */\n    histentry_T *\nget_histentry(int hist_type)\n{\n    return history[hist_type];\n}\n\n#if defined(FEAT_VIMINFO) || defined(PROTO)\n    void\nset_histentry(int hist_type, histentry_T *entry)\n{\n    history[hist_type] = entry;\n}\n#endif\n\n    int *\nget_hisidx(int hist_type)\n{\n    return &hisidx[hist_type];\n}\n\n#if defined(FEAT_VIMINFO) || defined(PROTO)\n    int *\nget_hisnum(int hist_type)\n{\n    return &hisnum[hist_type];\n}\n#endif\n\n/*\n * Translate a history character to the associated type number.\n */\n    int\nhist_char2type(int c)\n{\n    if (c == ':')\n\treturn HIST_CMD;\n    if (c == '=')\n\treturn HIST_EXPR;\n    if (c == '@')\n\treturn HIST_INPUT;\n    if (c == '>')\n\treturn HIST_DEBUG;\n    return HIST_SEARCH;\t    // must be '?' or '/'\n}\n\n/*\n * Table of history names.\n * These names are used in :history and various hist...() functions.\n * It is sufficient to give the significant prefix of a history name.\n */\n\nstatic char *(history_names[]) =\n{\n    \"cmd\",\n    \"search\",\n    \"expr\",\n    \"input\",\n    \"debug\",\n    NULL\n};\n\n/*\n * Function given to ExpandGeneric() to obtain the possible first\n * arguments of the \":history command.\n */\n    char_u *\nget_history_arg(expand_T *xp UNUSED, int idx)\n{\n    char    *short_names = \":=@>?/\";\n    int\t    short_names_count = (int)STRLEN(short_names);\n    int\t    history_name_count = ARRAY_LENGTH(history_names) - 1;\n\n    if (idx < short_names_count)\n    {\n\txp->xp_buf[0] = (char_u)short_names[idx];\n\txp->xp_buf[1] = NUL;\n\treturn xp->xp_buf;\n    }\n    if (idx < short_names_count + history_name_count)\n\treturn (char_u *)history_names[idx - short_names_count];\n    if (idx == short_names_count + history_name_count)\n\treturn (char_u *)\"all\";\n    return NULL;\n}\n\n/*\n * init_history() - Initialize the command line history.\n * Also used to re-allocate the history when the size changes.\n */\n    void\ninit_history(void)\n{\n    int\t\tnewlen;\t    // new length of history table\n    histentry_T\t*temp;\n    int\t\ti;\n    int\t\tj;\n    int\t\ttype;\n\n    // If size of history table changed, reallocate it\n    newlen = (int)p_hi;\n    if (newlen == hislen)\t\t// history length didn't change\n\treturn;\n\n    // history length changed\n    for (type = 0; type < HIST_COUNT; ++type)   // adjust the tables\n    {\n\tif (newlen > 0)\n\t{\n\t    temp = ALLOC_MULT(histentry_T, newlen);\n\t    if (temp == NULL)   // out of memory!\n\t    {\n\t\tif (type == 0)  // first one: just keep the old length\n\t\t{\n\t\t    newlen = hislen;\n\t\t    break;\n\t\t}\n\t\t// Already changed one table, now we can only have zero\n\t\t// length for all tables.\n\t\tnewlen = 0;\n\t\ttype = -1;\n\t\tcontinue;\n\t    }\n\t}\n\telse\n\t    temp = NULL;\n\n\tif (hisidx[type] < 0)\t\t// there are no entries yet\n\t{\n\t    for (i = 0; i < newlen; ++i)\n\t\tclear_hist_entry(&temp[i]);\n\t}\n\telse if (newlen > hislen)\t// array becomes bigger\n\t{\n\t    for (i = 0; i <= hisidx[type]; ++i)\n\t\ttemp[i] = history[type][i];\n\t    j = i;\n\t    for ( ; i <= newlen - (hislen - hisidx[type]); ++i)\n\t\tclear_hist_entry(&temp[i]);\n\t    for ( ; j < hislen; ++i, ++j)\n\t\ttemp[i] = history[type][j];\n\t}\n\telse\t\t\t\t// array becomes smaller or 0\n\t{\n\t    j = hisidx[type];\n\t    for (i = newlen - 1; ; --i)\n\t    {\n\t\tif (i >= 0)\t\t// copy newest entries\n\t\t    temp[i] = history[type][j];\n\t\telse\t\t\t// remove older entries\n\t\t    vim_free(history[type][j].hisstr);\n\t\tif (--j < 0)\n\t\t    j = hislen - 1;\n\t\tif (j == hisidx[type])\n\t\t    break;\n\t    }\n\t    hisidx[type] = newlen - 1;\n\t}\n\tvim_free(history[type]);\n\thistory[type] = temp;\n    }\n    hislen = newlen;\n}\n\n    void\nclear_hist_entry(histentry_T *hisptr)\n{\n    hisptr->hisnum = 0;\n    hisptr->viminfo = FALSE;\n    hisptr->hisstr = NULL;\n    hisptr->time_set = 0;\n}\n\n/*\n * Check if command line 'str' is already in history.\n * If 'move_to_front' is TRUE, matching entry is moved to end of history.\n */\n    int\nin_history(\n    int\t    type,\n    char_u  *str,\n    int\t    move_to_front,\t// Move the entry to the front if it exists\n    int\t    sep,\n    int\t    writing)\t\t// ignore entries read from viminfo\n{\n    int\t    i;\n    int\t    last_i = -1;\n    char_u  *p;\n\n    if (hisidx[type] < 0)\n\treturn FALSE;\n    i = hisidx[type];\n    do\n    {\n\tif (history[type][i].hisstr == NULL)\n\t    return FALSE;\n\n\t// For search history, check that the separator character matches as\n\t// well.\n\tp = history[type][i].hisstr;\n\tif (STRCMP(str, p) == 0\n\t\t&& !(writing && history[type][i].viminfo)\n\t\t&& (type != HIST_SEARCH || sep == p[STRLEN(p) + 1]))\n\t{\n\t    if (!move_to_front)\n\t\treturn TRUE;\n\t    last_i = i;\n\t    break;\n\t}\n\tif (--i < 0)\n\t    i = hislen - 1;\n    } while (i != hisidx[type]);\n\n    if (last_i < 0)\n\treturn FALSE;\n\n    str = history[type][i].hisstr;\n    while (i != hisidx[type])\n    {\n\tif (++i >= hislen)\n\t    i = 0;\n\thistory[type][last_i] = history[type][i];\n\tlast_i = i;\n    }\n    history[type][i].hisnum = ++hisnum[type];\n    history[type][i].viminfo = FALSE;\n    history[type][i].hisstr = str;\n    history[type][i].time_set = vim_time();\n    return TRUE;\n}\n\n/*\n * Convert history name (from table above) to its HIST_ equivalent.\n * When \"name\" is empty, return \"cmd\" history.\n * Returns -1 for unknown history name.\n */\n    static int\nget_histtype(char_u *name)\n{\n    int\t\ti;\n    int\t\tlen = (int)STRLEN(name);\n\n    // No argument: use current history.\n    if (len == 0)\n\treturn hist_char2type(get_cmdline_firstc());\n\n    for (i = 0; history_names[i] != NULL; ++i)\n\tif (STRNICMP(name, history_names[i], len) == 0)\n\t    return i;\n\n    if (vim_strchr((char_u *)\":=@>?/\", name[0]) != NULL && name[1] == NUL)\n\treturn hist_char2type(name[0]);\n\n    return -1;\n}\n\nstatic int\tlast_maptick = -1;\t// last seen maptick\n\n/*\n * Add the given string to the given history.  If the string is already in the\n * history then it is moved to the front.  \"histype\" may be one of he HIST_\n * values.\n */\n    void\nadd_to_history(\n    int\t\thistype,\n    char_u\t*new_entry,\n    int\t\tin_map,\t\t// consider maptick when inside a mapping\n    int\t\tsep)\t\t// separator character used (search hist)\n{\n    histentry_T\t*hisptr;\n    int\t\tlen;\n\n    if (hislen == 0)\t\t// no history\n\treturn;\n\n    if ((cmdmod.cmod_flags & CMOD_KEEPPATTERNS) && histype == HIST_SEARCH)\n\treturn;\n\n    // Searches inside the same mapping overwrite each other, so that only\n    // the last line is kept.  Be careful not to remove a line that was moved\n    // down, only lines that were added.\n    if (histype == HIST_SEARCH && in_map)\n    {\n\tif (maptick == last_maptick && hisidx[HIST_SEARCH] >= 0)\n\t{\n\t    // Current line is from the same mapping, remove it\n\t    hisptr = &history[HIST_SEARCH][hisidx[HIST_SEARCH]];\n\t    vim_free(hisptr->hisstr);\n\t    clear_hist_entry(hisptr);\n\t    --hisnum[histype];\n\t    if (--hisidx[HIST_SEARCH] < 0)\n\t\thisidx[HIST_SEARCH] = hislen - 1;\n\t}\n\tlast_maptick = -1;\n    }\n\n    if (in_history(histype, new_entry, TRUE, sep, FALSE))\n\treturn;\n\n    if (++hisidx[histype] == hislen)\n\thisidx[histype] = 0;\n    hisptr = &history[histype][hisidx[histype]];\n    vim_free(hisptr->hisstr);\n\n    // Store the separator after the NUL of the string.\n    len = (int)STRLEN(new_entry);\n    hisptr->hisstr = vim_strnsave(new_entry, len + 2);\n    if (hisptr->hisstr != NULL)\n\thisptr->hisstr[len + 1] = sep;\n\n    hisptr->hisnum = ++hisnum[histype];\n    hisptr->viminfo = FALSE;\n    hisptr->time_set = vim_time();\n    if (histype == HIST_SEARCH && in_map)\n\tlast_maptick = maptick;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n\n/*\n * Get identifier of newest history entry.\n * \"histype\" may be one of the HIST_ values.\n */\n    static int\nget_history_idx(int histype)\n{\n    if (hislen == 0 || histype < 0 || histype >= HIST_COUNT\n\t\t    || hisidx[histype] < 0)\n\treturn -1;\n\n    return history[histype][hisidx[histype]].hisnum;\n}\n\n/*\n * Calculate history index from a number:\n *   num > 0: seen as identifying number of a history entry\n *   num < 0: relative position in history wrt newest entry\n * \"histype\" may be one of the HIST_ values.\n */\n    static int\ncalc_hist_idx(int histype, int num)\n{\n    int\t\ti;\n    histentry_T\t*hist;\n    int\t\twrapped = FALSE;\n\n    if (hislen == 0 || histype < 0 || histype >= HIST_COUNT\n\t\t    || (i = hisidx[histype]) < 0 || num == 0)\n\treturn -1;\n\n    hist = history[histype];\n    if (num > 0)\n    {\n\twhile (hist[i].hisnum > num)\n\t    if (--i < 0)\n\t    {\n\t\tif (wrapped)\n\t\t    break;\n\t\ti += hislen;\n\t\twrapped = TRUE;\n\t    }\n\tif (i >= 0 && hist[i].hisnum == num && hist[i].hisstr != NULL)\n\t    return i;\n    }\n    else if (-num <= hislen)\n    {\n\ti += num + 1;\n\tif (i < 0)\n\t    i += hislen;\n\tif (hist[i].hisstr != NULL)\n\t    return i;\n    }\n    return -1;\n}\n\n/*\n * Get a history entry by its index.\n * \"histype\" may be one of the HIST_ values.\n */\n    static char_u *\nget_history_entry(int histype, int idx)\n{\n    idx = calc_hist_idx(histype, idx);\n    if (idx >= 0)\n\treturn history[histype][idx].hisstr;\n    else\n\treturn (char_u *)\"\";\n}\n\n/*\n * Clear all entries of a history.\n * \"histype\" may be one of the HIST_ values.\n */\n    static int\nclr_history(int histype)\n{\n    int\t\ti;\n    histentry_T\t*hisptr;\n\n    if (hislen != 0 && histype >= 0 && histype < HIST_COUNT)\n    {\n\thisptr = history[histype];\n\tfor (i = hislen; i--;)\n\t{\n\t    vim_free(hisptr->hisstr);\n\t    clear_hist_entry(hisptr);\n\t    hisptr++;\n\t}\n\thisidx[histype] = -1;\t// mark history as cleared\n\thisnum[histype] = 0;\t// reset identifier counter\n\treturn OK;\n    }\n    return FAIL;\n}\n\n/*\n * Remove all entries matching {str} from a history.\n * \"histype\" may be one of the HIST_ values.\n */\n    static int\ndel_history_entry(int histype, char_u *str)\n{\n    regmatch_T\tregmatch;\n    histentry_T\t*hisptr;\n    int\t\tidx;\n    int\t\ti;\n    int\t\tlast;\n    int\t\tfound = FALSE;\n\n    if (hislen == 0 || histype < 0 || histype >= HIST_COUNT || *str == NUL\n\t\t|| hisidx[histype] < 0)\n\treturn FALSE;\n\n    idx = hisidx[histype];\n    regmatch.regprog = vim_regcomp(str, RE_MAGIC + RE_STRING);\n    if (regmatch.regprog == NULL)\n\treturn FALSE;\n\n    regmatch.rm_ic = FALSE;\t// always match case\n\n    i = last = idx;\n    do\n    {\n\thisptr = &history[histype][i];\n\tif (hisptr->hisstr == NULL)\n\t    break;\n\tif (vim_regexec(&regmatch, hisptr->hisstr, (colnr_T)0))\n\t{\n\t    found = TRUE;\n\t    vim_free(hisptr->hisstr);\n\t    clear_hist_entry(hisptr);\n\t}\n\telse\n\t{\n\t    if (i != last)\n\t    {\n\t\thistory[histype][last] = *hisptr;\n\t\tclear_hist_entry(hisptr);\n\t    }\n\t    if (--last < 0)\n\t\tlast += hislen;\n\t}\n\tif (--i < 0)\n\t    i += hislen;\n    } while (i != idx);\n\n    if (history[histype][idx].hisstr == NULL)\n\thisidx[histype] = -1;\n\n    vim_regfree(regmatch.regprog);\n    return found;\n}\n\n/*\n * Remove an indexed entry from a history.\n * \"histype\" may be one of the HIST_ values.\n */\n    static int\ndel_history_idx(int histype, int idx)\n{\n    int\t    i, j;\n\n    i = calc_hist_idx(histype, idx);\n    if (i < 0)\n\treturn FALSE;\n    idx = hisidx[histype];\n    vim_free(history[histype][i].hisstr);\n\n    // When deleting the last added search string in a mapping, reset\n    // last_maptick, so that the last added search string isn't deleted again.\n    if (histype == HIST_SEARCH && maptick == last_maptick && i == idx)\n\tlast_maptick = -1;\n\n    while (i != idx)\n    {\n\tj = (i + 1) % hislen;\n\thistory[histype][i] = history[histype][j];\n\ti = j;\n    }\n    clear_hist_entry(&history[histype][i]);\n    if (--i < 0)\n\ti += hislen;\n    hisidx[histype] = i;\n    return TRUE;\n}\n\n/*\n * \"histadd()\" function\n */\n    void\nf_histadd(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    int\t\thistype;\n    char_u\t*str;\n    char_u\tbuf[NUMBUFLEN];\n\n    rettv->vval.v_number = FALSE;\n    if (check_secure())\n\treturn;\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_string_arg(argvars, 1) == FAIL))\n\treturn;\n\n    str = tv_get_string_chk(&argvars[0]);\t// NULL on type error\n    histype = str != NULL ? get_histtype(str) : -1;\n    if (histype < 0)\n\treturn;\n\n    str = tv_get_string_buf(&argvars[1], buf);\n    if (*str == NUL)\n\treturn;\n\n    init_history();\n    add_to_history(histype, str, FALSE, NUL);\n    rettv->vval.v_number = TRUE;\n}\n\n/*\n * \"histdel()\" function\n */\n    void\nf_histdel(typval_T *argvars UNUSED, typval_T *rettv UNUSED)\n{\n    int\t\tn;\n    char_u\tbuf[NUMBUFLEN];\n    char_u\t*str;\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_opt_string_or_number_arg(argvars, 1) == FAIL))\n\treturn;\n\n    str = tv_get_string_chk(&argvars[0]);\t// NULL on type error\n    if (str == NULL)\n\tn = 0;\n    else if (argvars[1].v_type == VAR_UNKNOWN)\n\t// only one argument: clear entire history\n\tn = clr_history(get_histtype(str));\n    else if (argvars[1].v_type == VAR_NUMBER)\n\t// index given: remove that entry\n\tn = del_history_idx(get_histtype(str),\n\t\t\t\t\t  (int)tv_get_number(&argvars[1]));\n    else\n\t// string given: remove all matching entries\n\tn = del_history_entry(get_histtype(str),\n\t\t\t\t      tv_get_string_buf(&argvars[1], buf));\n    rettv->vval.v_number = n;\n}\n\n/*\n * \"histget()\" function\n */\n    void\nf_histget(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    int\t\ttype;\n    int\t\tidx;\n    char_u\t*str;\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_opt_number_arg(argvars, 1) == FAIL))\n\treturn;\n\n    str = tv_get_string_chk(&argvars[0]);\t// NULL on type error\n    if (str == NULL)\n\trettv->vval.v_string = NULL;\n    else\n    {\n\ttype = get_histtype(str);\n\tif (argvars[1].v_type == VAR_UNKNOWN)\n\t    idx = get_history_idx(type);\n\telse\n\t    idx = (int)tv_get_number_chk(&argvars[1], NULL);\n\t\t\t\t\t\t    // -1 on type error\n\trettv->vval.v_string = vim_strsave(get_history_entry(type, idx));\n    }\n    rettv->v_type = VAR_STRING;\n}\n\n/*\n * \"histnr()\" function\n */\n    void\nf_histnr(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    int\t\ti;\n    char_u\t*histname;\n\n    if (in_vim9script() && check_for_string_arg(argvars, 0) == FAIL)\n\treturn;\n\n    histname = tv_get_string_chk(&argvars[0]);\n    i = histname == NULL ? HIST_CMD - 1 : get_histtype(histname);\n    if (i >= HIST_CMD && i < HIST_COUNT)\n\ti = get_history_idx(i);\n    else\n\ti = -1;\n    rettv->vval.v_number = i;\n}\n#endif // FEAT_EVAL\n\n#if defined(FEAT_CRYPT) || defined(PROTO)\n/*\n * Very specific function to remove the value in \":set key=val\" from the\n * history.\n */\n    void\nremove_key_from_history(void)\n{\n    char_u\t*p;\n    int\t\ti;\n\n    i = hisidx[HIST_CMD];\n    if (i < 0)\n\treturn;\n    p = history[HIST_CMD][i].hisstr;\n    if (p == NULL)\n\treturn;\n\n    for ( ; *p; ++p)\n\tif (STRNCMP(p, \"key\", 3) == 0 && !isalpha(p[3]))\n\t{\n\t    p = vim_strchr(p + 3, '=');\n\t    if (p == NULL)\n\t\tbreak;\n\t    ++p;\n\t    for (i = 0; p[i] && !VIM_ISWHITE(p[i]); ++i)\n\t\tif (p[i] == '\\\\' && p[i + 1])\n\t\t    ++i;\n\t    STRMOVE(p, p + i);\n\t    --p;\n\t}\n}\n#endif\n\n/*\n * :history command - print a history\n */\n    void\nex_history(exarg_T *eap)\n{\n    histentry_T\t*hist;\n    int\t\thistype1 = HIST_CMD;\n    int\t\thistype2 = HIST_CMD;\n    int\t\thisidx1 = 1;\n    int\t\thisidx2 = -1;\n    int\t\tidx;\n    int\t\ti, j, k;\n    char_u\t*end;\n    char_u\t*arg = eap->arg;\n\n    if (hislen == 0)\n    {\n\tmsg(_(\"'history' option is zero\"));\n\treturn;\n    }\n\n    if (!(VIM_ISDIGIT(*arg) || *arg == '-' || *arg == ','))\n    {\n\tend = arg;\n\twhile (ASCII_ISALPHA(*end)\n\t\t|| vim_strchr((char_u *)\":=@>/?\", *end) != NULL)\n\t    end++;\n\ti = *end;\n\t*end = NUL;\n\thistype1 = get_histtype(arg);\n\tif (histype1 == -1)\n\t{\n\t    if (STRNICMP(arg, \"all\", STRLEN(arg)) == 0)\n\t    {\n\t\thistype1 = 0;\n\t\thistype2 = HIST_COUNT-1;\n\t    }\n\t    else\n\t    {\n\t\t*end = i;\n\t\tsemsg(_(e_trailing_characters_str), arg);\n\t\treturn;\n\t    }\n\t}\n\telse\n\t    histype2 = histype1;\n\t*end = i;\n    }\n    else\n\tend = arg;\n    if (!get_list_range(&end, &hisidx1, &hisidx2) || *end != NUL)\n    {\n\tif (*end != NUL)\n\t    semsg(_(e_trailing_characters_str), end);\n\telse\n\t    semsg(_(e_val_too_large), arg);\n\treturn;\n    }\n\n    for (; !got_int && histype1 <= histype2; ++histype1)\n    {\n\tSTRCPY(IObuff, \"\\n      #  \");\n\tSTRCAT(STRCAT(IObuff, history_names[histype1]), \" history\");\n\tmsg_puts_title((char *)IObuff);\n\tidx = hisidx[histype1];\n\thist = history[histype1];\n\tj = hisidx1;\n\tk = hisidx2;\n\tif (j < 0)\n\t    j = (-j > hislen) ? 0 : hist[(hislen+j+idx+1) % hislen].hisnum;\n\tif (k < 0)\n\t    k = (-k > hislen) ? 0 : hist[(hislen+k+idx+1) % hislen].hisnum;\n\tif (idx >= 0 && j <= k)\n\t    for (i = idx + 1; !got_int; ++i)\n\t    {\n\t\tif (i == hislen)\n\t\t    i = 0;\n\t\tif (hist[i].hisstr != NULL\n\t\t\t&& hist[i].hisnum >= j && hist[i].hisnum <= k)\n\t\t{\n\t\t    msg_putchar('\\n');\n\t\t    sprintf((char *)IObuff, \"%c%6d  \", i == idx ? '>' : ' ',\n\t\t\t\t\t\t\t      hist[i].hisnum);\n\t\t    if (vim_strsize(hist[i].hisstr) > (int)Columns - 10)\n\t\t\ttrunc_string(hist[i].hisstr, IObuff + STRLEN(IObuff),\n\t\t\t     (int)Columns - 10, IOSIZE - (int)STRLEN(IObuff));\n\t\t    else\n\t\t\tSTRCAT(IObuff, hist[i].hisstr);\n\t\t    msg_outtrans(IObuff);\n\t\t    out_flush();\n\t\t}\n\t\tif (i == idx)\n\t\t    break;\n\t    }\n    }\n}\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n */\n\n// Use PLURAL_MSG() for messages that are passed to ngettext(), so that the\n// second one uses msgid_plural.\n#ifdef DO_INIT\n# define PLURAL_MSG(var1, msg1, var2, msg2) \\\n\tchar var1[] = msg1; \\\n\tchar var2[] = msg2;\n#else\n# define PLURAL_MSG(var1, msg1, var2, msg2) \\\n\textern char var1[]; \\\n\textern char var2[];\n#endif\n\n/*\n * Definition of error messages, sorted on error number.\n */\n\nEXTERN char e_interrupted[]\n\tINIT(= N_(\"Interrupted\"));\n\nEXTERN char e_backslash_should_be_followed_by[]\n\tINIT(= N_(\"E10: \\\\ should be followed by /, ? or &\"));\nEXTERN char e_invalid_in_cmdline_window[]\n\tINIT(= N_(\"E11: Invalid in command-line window; :q<CR> closes the window\"));\nEXTERN char e_command_not_allowed_from_vimrc_in_current_dir_or_tag_search[]\n\tINIT(= N_(\"E12: Command not allowed from exrc/vimrc in current dir or tag search\"));\nEXTERN char e_file_exists[]\n\tINIT(= N_(\"E13: File exists (add ! to override)\"));\n// E14 unused\n#ifdef FEAT_EVAL\nEXTERN char e_invalid_expression_str[]\n\tINIT(= N_(\"E15: Invalid expression: \\\"%s\\\"\"));\n#endif\nEXTERN char e_invalid_range[]\n\tINIT(= N_(\"E16: Invalid range\"));\n#if defined(UNIX) || defined(FEAT_SYN_HL) \\\n\t    || defined(FEAT_SPELL) || defined(FEAT_EVAL)\nEXTERN char e_str_is_directory[]\n\tINIT(= N_(\"E17: \\\"%s\\\" is a directory\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_unexpected_characters_in_let[]\n\tINIT(= N_(\"E18: Unexpected characters in :let\"));\nEXTERN char e_unexpected_characters_in_assignment[]\n\tINIT(= N_(\"E18: Unexpected characters in assignment\"));\n#endif\nEXTERN char e_mark_has_invalid_line_number[]\n\tINIT(= N_(\"E19: Mark has invalid line number\"));\nEXTERN char e_mark_not_set[]\n\tINIT(= N_(\"E20: Mark not set\"));\nEXTERN char e_cannot_make_changes_modifiable_is_off[]\n\tINIT(= N_(\"E21: Cannot make changes, 'modifiable' is off\"));\nEXTERN char e_scripts_nested_too_deep[]\n\tINIT(= N_(\"E22: Scripts nested too deep\"));\nEXTERN char e_no_alternate_file[]\n\tINIT(= N_(\"E23: No alternate file\"));\nEXTERN char e_no_such_abbreviation[]\n\tINIT(= N_(\"E24: No such abbreviation\"));\n#if !defined(FEAT_GUI) || defined(VIMDLL)\nEXTERN char e_gui_cannot_be_used_not_enabled_at_compile_time[]\n\tINIT(= N_(\"E25: GUI cannot be used: Not enabled at compile time\"));\n#endif\n#ifndef FEAT_RIGHTLEFT\nEXTERN char e_hebrew_cannot_be_used_not_enabled_at_compile_time[]\n\tINIT(= N_(\"E26: Hebrew cannot be used: Not enabled at compile time\\n\"));\n#endif\nEXTERN char e_farsi_support_has_been_removed[]\n\tINIT(= N_(\"E27: Farsi support has been removed\\n\"));\n#if defined(FEAT_SEARCH_EXTRA) || defined(FEAT_SYN_HL)\nEXTERN char e_no_such_highlight_group_name_str[]\n\tINIT(= N_(\"E28: No such highlight group name: %s\"));\n#endif\nEXTERN char e_no_inserted_text_yet[]\n\tINIT(= N_(\"E29: No inserted text yet\"));\nEXTERN char e_no_previous_command_line[]\n\tINIT(= N_(\"E30: No previous command line\"));\nEXTERN char e_no_such_mapping[]\n\tINIT(= N_(\"E31: No such mapping\"));\nEXTERN char e_no_file_name[]\n\tINIT(= N_(\"E32: No file name\"));\nEXTERN char e_no_previous_substitute_regular_expression[]\n\tINIT(= N_(\"E33: No previous substitute regular expression\"));\nEXTERN char e_no_previous_command[]\n\tINIT(= N_(\"E34: No previous command\"));\nEXTERN char e_no_previous_regular_expression[]\n\tINIT(= N_(\"E35: No previous regular expression\"));\nEXTERN char e_not_enough_room[]\n\tINIT(= N_(\"E36: Not enough room\"));\nEXTERN char e_no_write_since_last_change[]\n\tINIT(= N_(\"E37: No write since last change\"));\nEXTERN char e_no_write_since_last_change_add_bang_to_override[]\n\tINIT(= N_(\"E37: No write since last change (add ! to override)\"));\nEXTERN char e_null_argument[]\n\tINIT(= \"E38: Null argument\");\n#if defined(FEAT_DIGRAPHS) || defined(FEAT_TIMERS) || defined(FEAT_EVAL)\nEXTERN char e_number_expected[]\n\tINIT(= N_(\"E39: Number expected\"));\n#endif\n#ifdef FEAT_QUICKFIX\nEXTERN char e_cant_open_errorfile_str[]\n\tINIT(= N_(\"E40: Can't open errorfile %s\"));\n#endif\nEXTERN char e_out_of_memory[]\n\tINIT(= N_(\"E41: Out of memory!\"));\n#ifdef FEAT_QUICKFIX\nEXTERN char e_no_errors[]\n\tINIT(= N_(\"E42: No Errors\"));\n#endif\nEXTERN char e_damaged_match_string[]\n\tINIT(= \"E43: Damaged match string\");\nEXTERN char e_corrupted_regexp_program[]\n\tINIT(= \"E44: Corrupted regexp program\");\nEXTERN char e_readonly_option_is_set_add_bang_to_override[]\n\tINIT(= N_(\"E45: 'readonly' option is set (add ! to override)\"));\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_change_readonly_variable[]\n\tINIT(= N_(\"E46: Cannot change read-only variable\"));\nEXTERN char e_cannot_change_readonly_variable_str[]\n\tINIT(= N_(\"E46: Cannot change read-only variable \\\"%s\\\"\"));\n#endif\n#ifdef FEAT_QUICKFIX\nEXTERN char e_error_while_reading_errorfile[]\n\tINIT(= N_(\"E47: Error while reading errorfile\"));\n#endif\n#ifdef HAVE_SANDBOX\nEXTERN char e_not_allowed_in_sandbox[]\n\tINIT(= N_(\"E48: Not allowed in sandbox\"));\n#endif\nEXTERN char e_invalid_scroll_size[]\n\tINIT(= N_(\"E49: Invalid scroll size\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_too_many_z[]\n\tINIT(= N_(\"E50: Too many \\\\z(\"));\n#endif\nEXTERN char e_too_many_str_open[]\n\tINIT(= N_(\"E51: Too many %s(\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_unmatched_z[]\n\tINIT(= N_(\"E52: Unmatched \\\\z(\"));\n#endif\nEXTERN char e_unmatched_str_percent_open[]\n\tINIT(= N_(\"E53: Unmatched %s%%(\"));\nEXTERN char e_unmatched_str_open[]\n\tINIT(= N_(\"E54: Unmatched %s(\"));\nEXTERN char e_unmatched_str_close[]\n\tINIT(= N_(\"E55: Unmatched %s)\"));\n// E56 unused\n// E57 unused\n// E58 unused\nEXTERN char e_invalid_character_after_str_at[]\n\tINIT(= N_(\"E59: Invalid character after %s@\"));\nEXTERN char e_too_many_complex_str_curly[]\n\tINIT(= N_(\"E60: Too many complex %s{...}s\"));\nEXTERN char e_nested_str[]\n\tINIT(= N_(\"E61: Nested %s*\"));\nEXTERN char e_nested_str_chr[]\n\tINIT(= N_(\"E62: Nested %s%c\"));\nEXTERN char e_invalid_use_of_underscore[]\n\tINIT(= N_(\"E63: Invalid use of \\\\_\"));\nEXTERN char e_str_chr_follows_nothing[]\n\tINIT(= N_(\"E64: %s%c follows nothing\"));\nEXTERN char e_illegal_back_reference[]\n\tINIT(= N_(\"E65: Illegal back reference\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_z_not_allowed_here[]\n\tINIT(= N_(\"E66: \\\\z( not allowed here\"));\nEXTERN char e_z1_z9_not_allowed_here[]\n\tINIT(= N_(\"E67: \\\\z1 - \\\\z9 not allowed here\"));\n#endif\nEXTERN char e_invalid_character_after_bsl_z[]\n\tINIT(= N_(\"E68: Invalid character after \\\\z\"));\nEXTERN char e_missing_sb_after_str[]\n\tINIT(= N_(\"E69: Missing ] after %s%%[\"));\nEXTERN char e_empty_str_brackets[]\n\tINIT(= N_(\"E70: Empty %s%%[]\"));\nEXTERN char e_invalid_character_after_str[]\n\tINIT(= N_(\"E71: Invalid character after %s%%\"));\nEXTERN char e_close_error_on_swap_file[]\n\tINIT(= N_(\"E72: Close error on swap file\"));\nEXTERN char e_tag_stack_empty[]\n\tINIT(= N_(\"E73: Tag stack empty\"));\nEXTERN char e_command_too_complex[]\n\tINIT(= N_(\"E74: Command too complex\"));\nEXTERN char e_name_too_long[]\n\tINIT(= N_(\"E75: Name too long\"));\nEXTERN char e_too_many_brackets[]\n\tINIT(= N_(\"E76: Too many [\"));\nEXTERN char e_too_many_file_names[]\n\tINIT(= N_(\"E77: Too many file names\"));\nEXTERN char e_unknown_mark[]\n\tINIT(= N_(\"E78: Unknown mark\"));\nEXTERN char e_cannot_expand_wildcards[]\n\tINIT(= N_(\"E79: Cannot expand wildcards\"));\nEXTERN char e_error_while_writing[]\n\tINIT(= N_(\"E80: Error while writing\"));\n#ifdef FEAT_EVAL\nEXTERN char e_using_sid_not_in_script_context[]\n\tINIT(= N_(\"E81: Using <SID> not in a script context\"));\n#endif\nEXTERN char e_cannot_allocate_any_buffer_exiting[]\n\tINIT(= N_(\"E82: Cannot allocate any buffer, exiting...\"));\nEXTERN char e_cannot_allocate_buffer_using_other_one[]\n\tINIT(= N_(\"E83: Cannot allocate buffer, using other one...\"));\nEXTERN char e_no_modified_buffer_found[]\n\tINIT(= N_(\"E84: No modified buffer found\"));\nEXTERN char e_there_is_no_listed_buffer[]\n\tINIT(= N_(\"E85: There is no listed buffer\"));\nEXTERN char e_buffer_nr_does_not_exist[]\n\tINIT(= N_(\"E86: Buffer %ld does not exist\"));\nEXTERN char e_cannot_go_beyond_last_buffer[]\n\tINIT(= N_(\"E87: Cannot go beyond last buffer\"));\nEXTERN char e_cannot_go_before_first_buffer[]\n\tINIT(= N_(\"E88: Cannot go before first buffer\"));\nEXTERN char e_no_write_since_last_change_for_buffer_nr_add_bang_to_override[]\n\tINIT(= N_(\"E89: No write since last change for buffer %d (add ! to override)\"));\nEXTERN char e_cannot_unload_last_buffer[]\n\tINIT(= N_(\"E90: Cannot unload last buffer\"));\nEXTERN char e_shell_option_is_empty[]\n\tINIT(= N_(\"E91: 'shell' option is empty\"));\nEXTERN char e_buffer_nr_not_found[]\n\tINIT(= N_(\"E92: Buffer %d not found\"));\nEXTERN char e_more_than_one_match_for_str[]\n\tINIT(= N_(\"E93: More than one match for %s\"));\nEXTERN char e_no_matching_buffer_for_str[]\n\tINIT(= N_(\"E94: No matching buffer for %s\"));\nEXTERN char e_buffer_with_this_name_already_exists[]\n\tINIT(= N_(\"E95: Buffer with this name already exists\"));\n#if defined(FEAT_DIFF)\nEXTERN char e_cannot_diff_more_than_nr_buffers[]\n\tINIT(= N_(\"E96: Cannot diff more than %d buffers\"));\nEXTERN char e_cannot_create_diffs[]\n\tINIT(= N_(\"E97: Cannot create diffs\"));\nEXTERN char e_cannot_read_diff_output[]\n\tINIT(= N_(\"E98: Cannot read diff output\"));\nEXTERN char e_current_buffer_is_not_in_diff_mode[]\n\tINIT(= N_(\"E99: Current buffer is not in diff mode\"));\nEXTERN char e_no_other_buffer_in_diff_mode[]\n\tINIT(= N_(\"E100: No other buffer in diff mode\"));\nEXTERN char e_more_than_two_buffers_in_diff_mode_dont_know_which_one_to_use[]\n\tINIT(= N_(\"E101: More than two buffers in diff mode, don't know which one to use\"));\nEXTERN char e_cant_find_buffer_str[]\n\tINIT(= N_(\"E102: Can't find buffer \\\"%s\\\"\"));\nEXTERN char e_buffer_str_is_not_in_diff_mode[]\n\tINIT(= N_(\"E103: Buffer \\\"%s\\\" is not in diff mode\"));\n#endif\n#ifdef FEAT_DIGRAPHS\nEXTERN char e_escape_not_allowed_in_digraph[]\n\tINIT(= N_(\"E104: Escape not allowed in digraph\"));\n#endif\n#ifdef FEAT_KEYMAP\nEXTERN char e_using_loadkeymap_not_in_sourced_file[]\n\tINIT(= N_(\"E105: Using :loadkeymap not in a sourced file\"));\n#endif\n// E106 unused\n#ifdef FEAT_EVAL\nEXTERN char e_missing_parenthesis_str[]\n\tINIT(= N_(\"E107: Missing parentheses: %s\"));\nEXTERN char e_no_such_variable_str[]\n\tINIT(= N_(\"E108: No such variable: \\\"%s\\\"\"));\nEXTERN char e_missing_colon_after_questionmark[]\n\tINIT(= N_(\"E109: Missing ':' after '?'\"));\nEXTERN char e_missing_closing_paren[]\n\tINIT(= N_(\"E110: Missing ')'\"));\nEXTERN char e_missing_closing_square_brace[]\n\tINIT(= N_(\"E111: Missing ']'\"));\nEXTERN char e_option_name_missing_str[]\n\tINIT(= N_(\"E112: Option name missing: %s\"));\nEXTERN char e_unknown_option_str[]\n\tINIT(= N_(\"E113: Unknown option: %s\"));\nEXTERN char e_missing_double_quote_str[]\n\tINIT(= N_(\"E114: Missing double quote: %s\"));\nEXTERN char e_missing_single_quote_str[]\n\tINIT(= N_(\"E115: Missing single quote: %s\"));\nEXTERN char e_invalid_arguments_for_function_str[]\n\tINIT(= N_(\"E116: Invalid arguments for function %s\"));\nEXTERN char e_unknown_function_str[]\n\tINIT(= N_(\"E117: Unknown function: %s\"));\nEXTERN char e_too_many_arguments_for_function_str[]\n\tINIT(= N_(\"E118: Too many arguments for function: %s\"));\nEXTERN char e_not_enough_arguments_for_function_str[]\n\tINIT(= N_(\"E119: Not enough arguments for function: %s\"));\nEXTERN char e_using_sid_not_in_script_context_str[]\n\tINIT(= N_(\"E120: Using <SID> not in a script context: %s\"));\nEXTERN char e_undefined_variable_str[]\n\tINIT(= N_(\"E121: Undefined variable: %s\"));\nEXTERN char e_undefined_variable_char_str[]\n\tINIT(= N_(\"E121: Undefined variable: %c:%s\"));\nEXTERN char e_function_str_already_exists_add_bang_to_replace[]\n\tINIT(= N_(\"E122: Function %s already exists, add ! to replace it\"));\nEXTERN char e_undefined_function_str[]\n\tINIT(= N_(\"E123: Undefined function: %s\"));\nEXTERN char e_missing_paren_str[]\n\tINIT(= N_(\"E124: Missing '(': %s\"));\nEXTERN char e_illegal_argument_str[]\n\tINIT(= N_(\"E125: Illegal argument: %s\"));\nEXTERN char e_missing_endfunction[]\n\tINIT(= N_(\"E126: Missing :endfunction\"));\nEXTERN char e_cannot_redefine_function_str_it_is_in_use[]\n\tINIT(= N_(\"E127: Cannot redefine function %s: It is in use\"));\nEXTERN char e_function_name_must_start_with_capital_or_s_str[]\n\tINIT(= N_(\"E128: Function name must start with a capital or \\\"s:\\\": %s\"));\nEXTERN char e_function_name_required[]\n\tINIT(= N_(\"E129: Function name required\"));\n// E130 unused\nEXTERN char e_cannot_delete_function_str_it_is_in_use[]\n\tINIT(= N_(\"E131: Cannot delete function %s: It is in use\"));\nEXTERN char e_function_call_depth_is_higher_than_macfuncdepth[]\n\tINIT(= N_(\"E132: Function call depth is higher than 'maxfuncdepth'\"));\nEXTERN char e_return_not_inside_function[]\n\tINIT(= N_(\"E133: :return not inside a function\"));\n#endif\nEXTERN char e_cannot_move_range_of_lines_into_itself[]\n\tINIT(= N_(\"E134: Cannot move a range of lines into itself\"));\nEXTERN char e_filter_autocommands_must_not_change_current_buffer[]\n\tINIT(= N_(\"E135: *Filter* Autocommands must not change current buffer\"));\n#if defined(FEAT_VIMINFO)\nEXTERN char e_viminfo_too_many_errors_skipping_rest_of_file[]\n\tINIT(= N_(\"E136: viminfo: Too many errors, skipping rest of file\"));\nEXTERN char e_viminfo_file_is_not_writable_str[]\n\tINIT(= N_(\"E137: Viminfo file is not writable: %s\"));\nEXTERN char e_cant_write_viminfo_file_str[]\n\tINIT(= N_(\"E138: Can't write viminfo file %s!\"));\n#endif\nEXTERN char e_file_is_loaded_in_another_buffer[]\n\tINIT(= N_(\"E139: File is loaded in another buffer\"));\nEXTERN char e_use_bang_to_write_partial_buffer[]\n\tINIT(= N_(\"E140: Use ! to write partial buffer\"));\nEXTERN char e_no_file_name_for_buffer_nr[]\n\tINIT(= N_(\"E141: No file name for buffer %ld\"));\nEXTERN char e_file_not_written_writing_is_disabled_by_write_option[]\n\tINIT(= N_(\"E142: File not written: Writing is disabled by 'write' option\"));\nEXTERN char e_autocommands_unexpectedly_deleted_new_buffer_str[]\n\tINIT(= N_(\"E143: Autocommands unexpectedly deleted new buffer %s\"));\nEXTERN char e_non_numeric_argument_to_z[]\n\tINIT(= N_(\"E144: Non-numeric argument to :z\"));\nEXTERN char e_shell_commands_and_some_functionality_not_allowed_in_rvim[]\n\tINIT(= N_(\"E145: Shell commands and some functionality not allowed in rvim\"));\nEXTERN char e_regular_expressions_cant_be_delimited_by_letters[]\n\tINIT(= N_(\"E146: Regular expressions can't be delimited by letters\"));\nEXTERN char e_cannot_do_global_recursive_with_range[]\n\tINIT(= N_(\"E147: Cannot do :global recursive with a range\"));\nEXTERN char e_regular_expression_missing_from_global[]\n\tINIT(= N_(\"E148: Regular expression missing from :global\"));\nEXTERN char e_sorry_no_help_for_str[]\n\tINIT(= N_(\"E149: Sorry, no help for %s\"));\nEXTERN char e_not_a_directory_str[]\n\tINIT(= N_(\"E150: Not a directory: %s\"));\nEXTERN char e_no_match_str_1[]\n\tINIT(= N_(\"E151: No match: %s\"));\nEXTERN char e_cannot_open_str_for_writing_1[]\n\tINIT(= N_(\"E152: Cannot open %s for writing\"));\nEXTERN char e_unable_to_open_str_for_reading[]\n\tINIT(= N_(\"E153: Unable to open %s for reading\"));\nEXTERN char e_duplicate_tag_str_in_file_str_str[]\n\tINIT(= N_(\"E154: Duplicate tag \\\"%s\\\" in file %s/%s\"));\n#ifdef FEAT_SIGNS\nEXTERN char e_unknown_sign_str[]\n\tINIT(= N_(\"E155: Unknown sign: %s\"));\nEXTERN char e_missing_sign_name[]\n\tINIT(= N_(\"E156: Missing sign name\"));\nEXTERN char e_invalid_sign_id_nr[]\n\tINIT(= N_(\"E157: Invalid sign ID: %d\"));\n#endif\n#if defined(FEAT_SIGNS) || defined(FEAT_EVAL)\nEXTERN char e_invalid_buffer_name_str[]\n\tINIT(= N_(\"E158: Invalid buffer name: %s\"));\n#endif\n#ifdef FEAT_SIGNS\nEXTERN char e_missing_sign_number[]\n\tINIT(= N_(\"E159: Missing sign number\"));\nEXTERN char e_unknown_sign_command_str[]\n\tINIT(= N_(\"E160: Unknown sign command: %s\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_breakpoint_not_found_str[]\n\tINIT(= N_(\"E161: Breakpoint not found: %s\"));\n#endif\nEXTERN char e_no_write_since_last_change_for_buffer_str[]\n\tINIT(= N_(\"E162: No write since last change for buffer \\\"%s\\\"\"));\nEXTERN char e_there_is_only_one_file_to_edit[]\n\tINIT(= N_(\"E163: There is only one file to edit\"));\nEXTERN char e_cannot_go_before_first_file[]\n\tINIT(= N_(\"E164: Cannot go before first file\"));\nEXTERN char e_cannot_go_beyond_last_file[]\n\tINIT(= N_(\"E165: Cannot go beyond last file\"));\nEXTERN char e_cant_open_linked_file_for_writing[]\n\tINIT(= N_(\"E166: Can't open linked file for writing\"));\nEXTERN char e_scriptencoding_used_outside_of_sourced_file[]\n\tINIT(= N_(\"E167: :scriptencoding used outside of a sourced file\"));\n#ifdef FEAT_EVAL\nEXTERN char e_finish_used_outside_of_sourced_file[]\n\tINIT(= N_(\"E168: :finish used outside of a sourced file\"));\n#endif\nEXTERN char e_command_too_recursive[]\n\tINIT(= N_(\"E169: Command too recursive\"));\n#ifdef FEAT_EVAL\nEXTERN char e_missing_endwhile[]\n\tINIT(= N_(\"E170: Missing :endwhile\"));\nEXTERN char e_missing_endfor[]\n\tINIT(= N_(\"E170: Missing :endfor\"));\nEXTERN char e_missing_endif[]\n\tINIT(= N_(\"E171: Missing :endif\"));\nEXTERN char e_missing_marker[]\n\tINIT(= N_(\"E172: Missing marker\"));\n#endif\n\nPLURAL_MSG(e_nr_more_file_to_edit, \"E173: %d more file to edit\",\n\t\te_nr_more_files_to_edit, \"E173: %d more files to edit\")\n\nEXTERN char e_command_already_exists_add_bang_to_replace_it_str[]\n\tINIT(= N_(\"E174: Command already exists: add ! to replace it: %s\"));\nEXTERN char e_no_attribute_specified[]\n\tINIT(= N_(\"E175: No attribute specified\"));\nEXTERN char e_invalid_number_of_arguments[]\n\tINIT(= N_(\"E176: Invalid number of arguments\"));\nEXTERN char e_count_cannot_be_specified_twice[]\n\tINIT(= N_(\"E177: Count cannot be specified twice\"));\nEXTERN char e_invalid_default_value_for_count[]\n\tINIT(= N_(\"E178: Invalid default value for count\"));\nEXTERN char e_argument_required_for_str[]\n\tINIT(= N_(\"E179: Argument required for %s\"));\nEXTERN char e_invalid_complete_value_str[]\n\tINIT(= N_(\"E180: Invalid complete value: %s\"));\nEXTERN char e_invalid_address_type_value_str[]\n\tINIT(= N_(\"E180: Invalid address type value: %s\"));\nEXTERN char e_invalid_attribute_str[]\n\tINIT(= N_(\"E181: Invalid attribute: %s\"));\nEXTERN char e_invalid_command_name[]\n\tINIT(= N_(\"E182: Invalid command name\"));\nEXTERN char e_user_defined_commands_must_start_with_an_uppercase_letter[]\n\tINIT(= N_(\"E183: User defined commands must start with an uppercase letter\"));\nEXTERN char e_no_such_user_defined_command_str[]\n\tINIT(= N_(\"E184: No such user-defined command: %s\"));\nEXTERN char e_cannot_find_color_scheme_str[]\n\tINIT(= N_(\"E185: Cannot find color scheme '%s'\"));\nEXTERN char e_no_previous_directory[]\n\tINIT(= N_(\"E186: No previous directory\"));\nEXTERN char e_directory_unknown[]\n\tINIT(= N_(\"E187: Directory unknown\"));\nEXTERN char e_obtaining_window_position_not_implemented_for_this_platform[]\n\tINIT(= N_(\"E188: Obtaining window position not implemented for this platform\"));\nEXTERN char e_str_exists_add_bang_to_override[]\n\tINIT(= N_(\"E189: \\\"%s\\\" exists (add ! to override)\"));\nEXTERN char e_cannot_open_str_for_writing_2[]\n\tINIT(= N_(\"E190: Cannot open \\\"%s\\\" for writing\"));\nEXTERN char e_argument_must_be_letter_or_forward_backward_quote[]\n\tINIT(= N_(\"E191: Argument must be a letter or forward/backward quote\"));\nEXTERN char e_recursive_use_of_normal_too_deep[]\n\tINIT(= N_(\"E192: Recursive use of :normal too deep\"));\n#ifdef FEAT_EVAL\nEXTERN char e_str_not_inside_function[]\n\tINIT(= N_(\"E193: %s not inside a function\"));\n#endif\nEXTERN char e_no_alternate_file_name_to_substitute_for_hash[]\n\tINIT(= N_(\"E194: No alternate file name to substitute for '#'\"));\n#ifdef FEAT_VIMINFO\nEXTERN char e_cannot_open_viminfo_file_for_reading[]\n\tINIT(= N_(\"E195: Cannot open viminfo file for reading\"));\n#endif\n#ifndef FEAT_DIGRAPHS\nEXTERN char e_no_digraphs_version[]\n\tINIT(= N_(\"E196: No digraphs in this version\"));\n#endif\nEXTERN char e_cannot_set_language_to_str[]\n\tINIT(= N_(\"E197: Cannot set language to \\\"%s\\\"\"));\n// E198 unused\nEXTERN char e_active_window_or_buffer_deleted[]\n\tINIT(= N_(\"E199: Active window or buffer deleted\"));\nEXTERN char e_readpre_autocommands_made_file_unreadable[]\n\tINIT(= N_(\"E200: *ReadPre autocommands made the file unreadable\"));\nEXTERN char e_readpre_autocommands_must_not_change_current_buffer[]\n\tINIT(= N_(\"E201: *ReadPre autocommands must not change current buffer\"));\n#ifdef FEAT_EVAL\nEXTERN char e_conversion_mad_file_unreadable[]\n\tINIT(= N_(\"E202: Conversion made file unreadable!\"));\n#endif\nEXTERN char e_autocommands_deleted_or_unloaded_buffer_to_be_written[]\n\tINIT(= N_(\"E203: Autocommands deleted or unloaded buffer to be written\"));\nEXTERN char e_autocommands_changed_number_of_lines_in_unexpected_way[]\n\tINIT(= N_(\"E204: Autocommand changed number of lines in unexpected way\"));\nEXTERN char e_patchmode_cant_save_original_file[]\n\tINIT(= N_(\"E205: Patchmode: can't save original file\"));\nEXTERN char e_patchmode_cant_touch_empty_original_file[]\n\tINIT(= N_(\"E206: Patchmode: can't touch empty original file\"));\nEXTERN char e_cant_delete_backup_file[]\n\tINIT(= N_(\"E207: Can't delete backup file\"));\nEXTERN char e_error_writing_to_str[]\n\tINIT(= N_(\"E208: Error writing to \\\"%s\\\"\"));\nEXTERN char e_error_closing_str[]\n\tINIT(= N_(\"E209: Error closing \\\"%s\\\"\"));\nEXTERN char e_error_reading_str[]\n\tINIT(= N_(\"E210: Error reading \\\"%s\\\"\"));\nEXTERN char e_file_str_no_longer_available[]\n\tINIT(= N_(\"E211: File \\\"%s\\\" no longer available\"));\nEXTERN char e_cant_open_file_for_writing[]\n\tINIT(= N_(\"E212: Can't open file for writing\"));\nEXTERN char e_cannot_convert_add_bang_to_write_without_conversion[]\n\tINIT(= N_(\"E213: Cannot convert (add ! to write without conversion)\"));\n#ifdef FEAT_EVAL\nEXTERN char e_cant_find_temp_file_for_writing[]\n\tINIT(= N_(\"E214: Can't find temp file for writing\"));\n#endif\nEXTERN char e_illegal_character_after_star_str[]\n\tINIT(= N_(\"E215: Illegal character after *: %s\"));\nEXTERN char e_no_such_event_str[]\n\tINIT(= N_(\"E216: No such event: %s\"));\nEXTERN char e_no_such_group_or_event_str[]\n\tINIT(= N_(\"E216: No such group or event: %s\"));\nEXTERN char e_cant_execute_autocommands_for_all_events[]\n\tINIT(= N_(\"E217: Can't execute autocommands for ALL events\"));\nEXTERN char e_autocommand_nesting_too_deep[]\n\tINIT(= N_(\"E218: Autocommand nesting too deep\"));\nEXTERN char e_missing_open_curly[]\n\tINIT(= N_(\"E219: Missing {.\"));\nEXTERN char e_missing_close_curly[]\n\tINIT(= N_(\"E220: Missing }.\"));\n#ifdef FEAT_EVAL\nEXTERN char e_marker_cannot_start_with_lower_case_letter[]\n\tINIT(= N_(\"E221: Marker cannot start with lower case letter\"));\n#endif\nEXTERN char e_add_to_internal_buffer_that_was_already_read_from[]\n\tINIT(= \"E222: Add to internal buffer that was already read from\");\nEXTERN char e_recursive_mapping[]\n\tINIT(= N_(\"E223: Recursive mapping\"));\nEXTERN char e_global_abbreviation_already_exists_for_str[]\n\tINIT(= N_(\"E224: Global abbreviation already exists for %s\"));\nEXTERN char e_global_mapping_already_exists_for_str[]\n\tINIT(= N_(\"E225: Global mapping already exists for %s\"));\nEXTERN char e_abbreviation_already_exists_for_str[]\n\tINIT(= N_(\"E226: Abbreviation already exists for %s\"));\nEXTERN char e_mapping_already_exists_for_str[]\n\tINIT(= N_(\"E227: Mapping already exists for %s\"));\nEXTERN char e_makemap_illegal_mode[]\n\tINIT(= \"E228: makemap: Illegal mode\");\n#ifdef FEAT_GUI\nEXTERN char e_cannot_start_the_GUI[]\n\tINIT(= N_(\"E229: Cannot start the GUI\"));\nEXTERN char e_cannot_read_from_str[]\n\tINIT(= N_(\"E230: Cannot read from \\\"%s\\\"\"));\nEXTERN char e_guifontwide_invalid[]\n\tINIT(= N_(\"E231: 'guifontwide' invalid\"));\n#ifdef FEAT_BEVAL_GUI\nEXTERN char e_cannot_create_ballooneval_with_both_message_and_callback[]\n\tINIT(= \"E232: Cannot create BalloonEval with both message and callback\");\n#endif\n# if defined(FEAT_GUI_GTK) || defined(FEAT_GUI_X11)\nEXTERN char e_cannot_open_display[]\n\tINIT(= N_(\"E233: Cannot open display\"));\n# endif\n# if defined(FEAT_XFONTSET)\nEXTERN char e_unknown_fontset_str[]\n\tINIT(= N_(\"E234: Unknown fontset: %s\"));\n# endif\n# if defined(FEAT_GUI_X11) || defined(FEAT_GUI_GTK) \\\n\t|| defined(FEAT_GUI_PHOTON) || defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_HAIKU)\nEXTERN char e_unknown_font_str[]\n\tINIT(= N_(\"E235: Unknown font: %s\"));\n# endif\n# if defined(FEAT_GUI_X11) && !defined(FEAT_GUI_GTK)\nEXTERN char e_font_str_is_not_fixed_width[]\n\tINIT(= N_(\"E236: Font \\\"%s\\\" is not fixed-width\"));\n# endif\n#endif\n#ifdef MSWIN\nEXTERN char e_printer_selection_failed[]\n\tINIT(= N_(\"E237: Printer selection failed\"));\nEXTERN char e_print_error_str[]\n\tINIT(= N_(\"E238: Print error: %s\"));\n#endif\n#ifdef FEAT_SIGNS\nEXTERN char e_invalid_sign_text_str[]\n\tINIT(= N_(\"E239: Invalid sign text: %s\"));\n#endif\n#if defined(FEAT_CLIENTSERVER) && defined(FEAT_X11)\nEXTERN char e_no_connection_to_x_server[]\n\tINIT(= N_(\"E240: No connection to the X server\"));\n#endif\n#ifdef FEAT_CLIENTSERVER\nEXTERN char e_unable_to_send_to_str[]\n\tINIT(= N_(\"E241: Unable to send to %s\"));\n#endif\nEXTERN char e_cant_split_window_while_closing_another[]\n\tINIT(= N_(\"E242: Can't split a window while closing another\"));\n#if defined(FEAT_GUI_MSWIN) && !defined(FEAT_OLE)\nEXTERN char e_argument_not_supported_str_use_ole_version[]\n\tINIT(= N_(\"E243: Argument not supported: \\\"-%s\\\"; Use the OLE version.\"));\n#endif\n#ifdef MSWIN\nEXTERN char e_illegal_str_name_str_in_font_name_str[]\n\tINIT(= N_(\"E244: Illegal %s name \\\"%s\\\" in font name \\\"%s\\\"\"));\nEXTERN char e_illegal_char_nr_in_font_name_str[]\n\tINIT(= N_(\"E245: Illegal char '%c' in font name \\\"%s\\\"\"));\n#endif\nEXTERN char e_filechangedshell_autocommand_deleted_buffer[]\n\tINIT(= N_(\"E246: FileChangedShell autocommand deleted buffer\"));\n#ifdef FEAT_CLIENTSERVER\nEXTERN char e_no_registered_server_named_str[]\n\tINIT(= N_(\"E247: No registered server named \\\"%s\\\"\"));\nEXTERN char e_failed_to_send_command_to_destination_program[]\n\tINIT(= N_(\"E248: Failed to send command to the destination program\"));\n#endif\nEXTERN char e_window_layout_changed_unexpectedly[]\n\tINIT(= N_(\"E249: Window layout changed unexpectedly\"));\n#ifdef FEAT_XFONTSET\nEXTERN char e_fonts_for_the_following_charsets_are_missing_in_fontset[]\n\tINIT(= N_(\"E250: Fonts for the following charsets are missing in fontset %s:\"));\n#endif\n#ifdef FEAT_CLIENTSERVER\nEXTERN char e_vim_instance_registry_property_is_badly_formed_deleted[]\n\tINIT(= N_(\"E251: VIM instance registry property is badly formed.  Deleted!\"));\n#endif\n#ifdef FEAT_GUI_X11\nEXTERN char e_fontsent_name_str_font_str_is_not_fixed_width[]\n\tINIT(= N_(\"E252: Fontset name: %s - Font '%s' is not fixed-width\"));\nEXTERN char e_fontset_name_str[]\n\tINIT(= N_(\"E253: Fontset name: %s\"));\n#endif\n#if defined(FEAT_GUI) || defined(FEAT_TERMGUICOLORS)\nEXTERN char e_cannot_allocate_color_str[]\n\tINIT(= N_(\"E254: Cannot allocate color %s\"));\n#endif\n#if defined(FEAT_SIGN_ICONS) && !defined(FEAT_GUI_GTK)\nEXTERN char e_couldnt_read_in_sign_data[]\n\tINIT(= N_(\"E255: Couldn't read in sign data\"));\n#endif\n// E256 unused\n#ifdef FEAT_CSCOPE\nEXTERN char e_cstag_tag_not_founc[]\n\tINIT(= N_(\"E257: cstag: Tag not found\"));\n#endif\n#ifdef FEAT_CLIENTSERVER\nEXTERN char e_unable_to_send_to_client[]\n\tINIT(= N_(\"E258: Unable to send to client\"));\n#endif\n#ifdef FEAT_CSCOPE\nEXTERN char e_no_matches_found_for_cscope_query_str_of_str[]\n\tINIT(= N_(\"E259: No matches found for cscope query %s of %s\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_missing_name_after_method[]\n\tINIT(= N_(\"E260: Missing name after ->\"));\n#endif\n#ifdef FEAT_CSCOPE\nEXTERN char e_cscope_connection_str_not_founc[]\n\tINIT(= N_(\"E261: Cscope connection %s not found\"));\nEXTERN char e_error_reading_cscope_connection_nr[]\n\tINIT(= N_(\"E262: Error reading cscope connection %d\"));\n#endif\n#if defined(DYNAMIC_PYTHON) || defined(DYNAMIC_PYTHON3)\nEXTERN char e_sorry_this_command_is_disabled_python_library_could_not_be_found[]\n\tINIT(= N_(\"E263: Sorry, this command is disabled, the Python library could not be loaded.\"));\n#endif\n#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3)\nEXTERN char e_python_error_initialising_io_object[]\n\tINIT(= N_(\"E264: Python: Error initialising I/O objects\"));\n#endif\n#ifdef FEAT_RUBY\nEXTERN char e_dollar_must_be_an_instance_of_string[]\n\tINIT(= N_(\"E265: $_ must be an instance of String\"));\n#endif\n#ifdef DYNAMIC_RUBY\nEXTERN char e_sorry_this_command_is_disabled_the_ruby_library_could_not_be_loaded[]\n\tINIT(= N_(\"E266: Sorry, this command is disabled, the Ruby library could not be loaded.\"));\n#endif\n#ifdef FEAT_RUBY\nEXTERN char e_unexpected_return[]\n\tINIT(= N_(\"E267: Unexpected return\"));\nEXTERN char e_unexpected_next[]\n\tINIT(= N_(\"E268: Unexpected next\"));\nEXTERN char e_unexpected_break[]\n\tINIT(= N_(\"E269: Unexpected break\"));\nEXTERN char e_unexpected_redo[]\n\tINIT(= N_(\"E270: Unexpected redo\"));\nEXTERN char e_retry_outside_of_rescue_clause[]\n\tINIT(= N_(\"E271: Retry outside of rescue clause\"));\nEXTERN char e_unhandled_exception[]\n\tINIT(= N_(\"E272: Unhandled exception\"));\nEXTERN char e_unknown_longjmp_status_nr[]\n\tINIT(= N_(\"E273: Unknown longjmp status %d\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_no_white_space_allowed_before_parenthesis[]\n\tINIT(= N_(\"E274: No white space allowed before parenthesis\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_cannot_add_text_property_to_unloaded_buffer[]\n\tINIT(= N_(\"E275: Cannot add text property to unloaded buffer\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_use_function_as_method_str[]\n\tINIT(= N_(\"E276: Cannot use function as a method: %s\"));\n#endif\n#ifdef FEAT_CLIENTSERVER\nEXTERN char e_unable_to_read_server_reply[]\n\tINIT(= N_(\"E277: Unable to read a server reply\"));\n#endif\n// E278 unused\n#if defined(FEAT_TERMINAL) && !defined(UNIX) && !defined(MSWIN)\nEXTERN char e_sorry_plusplusshell_not_supported_on_this_system[]\n\tINIT(= N_(\"E279: Sorry, ++shell is not supported on this system\"));\n#endif\n#ifdef FEAT_TCL\nEXTERN char e_tcl_fatal_error_reflist_corrupt_please_report_this[]\n\tINIT(= \"E280: TCL FATAL ERROR: reflist corrupt!? Please report this to vim-dev@vim.org\");\n#endif\n// E281 unused\nEXTERN char e_cannot_read_from_str_2[]\n\tINIT(= N_(\"E282: Cannot read from \\\"%s\\\"\"));\nEXTERN char e_no_marks_matching_str[]\n\tINIT(= N_(\"E283: No marks matching \\\"%s\\\"\"));\n#ifdef FEAT_XIM\n# ifndef FEAT_GUI_GTK\nEXTERN char e_cannot_set_ic_values[]\n\tINIT(= N_(\"E284: Cannot set IC values\"));\n# endif\n# ifdef FEAT_GUI_X11\nEXTERN char e_failed_to_create_input_context[]\n\tINIT(= N_(\"E285: Failed to create input context\"));\nEXTERN char e_failed_to_open_input_method[]\n\tINIT(= N_(\"E286: Failed to open input method\"));\nEXTERN char e_warning_could_not_set_destroy_callback_to_im[]\n\tINIT(= N_(\"E287: Warning: Could not set destroy callback to IM\"));\nEXTERN char e_input_method_doesnt_support_any_style[]\n\tINIT(= N_(\"E288: Input method doesn't support any style\"));\nEXTERN char e_input_method_doesnt_support_my_preedit_type[]\n\tINIT(= N_(\"E289: Input method doesn't support my preedit type\"));\n# endif\n#endif\n#ifdef FEAT_SEARCH_EXTRA\nEXTERN char e_list_or_number_required[]\n\tINIT(= N_(\"E290: List or number required\"));\n#endif\n// E291 unused\nEXTERN char e_invalid_count_for_del_bytes_nr[]\n\tINIT(= \"E292: Invalid count for del_bytes(): %ld\");\nEXTERN char e_block_was_not_locked[]\n\tINIT(= \"E293: Block was not locked\");\nEXTERN char e_seek_error_in_swap_file_read[]\n\tINIT(= N_(\"E294: Seek error in swap file read\"));\nEXTERN char e_read_error_in_swap_file[]\n\tINIT(= N_(\"E295: Read error in swap file\"));\nEXTERN char e_seek_error_in_swap_file_write[]\n\tINIT(= N_(\"E296: Seek error in swap file write\"));\nEXTERN char e_write_error_in_swap_file[]\n\tINIT(= N_(\"E297: Write error in swap file\"));\nEXTERN char e_didnt_get_block_nr_zero[]\n\tINIT(= \"E298: Didn't get block nr 0?\");\nEXTERN char e_didnt_get_block_nr_one[]\n\tINIT(= \"E298: Didn't get block nr 1?\");\nEXTERN char e_didnt_get_block_nr_two[]\n\tINIT(= \"E298: Didn't get block nr 2?\");\n#ifdef FEAT_PERL\nEXTERN char e_perl_evaluation_forbidden_in_sandbox_without_safe_module[]\n\tINIT(= N_(\"E299: Perl evaluation forbidden in sandbox without the Safe module\"));\n#endif\nEXTERN char e_swap_file_already_exists_symlink_attack[]\n\tINIT(= N_(\"E300: Swap file already exists (symlink attack?)\"));\nEXTERN char e_oops_lost_the_swap_file[]\n\tINIT(= N_(\"E301: Oops, lost the swap file!!!\"));\nEXTERN char e_could_not_rename_swap_file[]\n\tINIT(= N_(\"E302: Could not rename swap file\"));\nEXTERN char e_unable_to_open_swap_file_for_str_recovery_impossible[]\n\tINIT(= N_(\"E303: Unable to open swap file for \\\"%s\\\", recovery impossible\"));\nEXTERN char e_ml_upd_block0_didnt_get_block_zero[]\n\tINIT(= \"E304: ml_upd_block0(): Didn't get block 0??\");\nEXTERN char e_no_swap_file_found_for_str[]\n\tINIT(= N_(\"E305: No swap file found for %s\"));\nEXTERN char e_cannot_open_str[]\n\tINIT(= N_(\"E306: Cannot open %s\"));\nEXTERN char e_str_does_not_look_like_vim_swap_file[]\n\tINIT(= N_(\"E307: %s does not look like a Vim swap file\"));\nEXTERN char e_warning_original_file_may_have_been_changed[]\n\tINIT(= N_(\"E308: Warning: Original file may have been changed\"));\nEXTERN char e_unable_to_read_block_one_from_str[]\n\tINIT(= N_(\"E309: Unable to read block 1 from %s\"));\nEXTERN char e_block_one_id_wrong_str_not_swp_file[]\n\tINIT(= N_(\"E310: Block 1 ID wrong (%s not a .swp file?)\"));\nEXTERN char e_recovery_interrupted[]\n\tINIT(= N_(\"E311: Recovery Interrupted\"));\nEXTERN char e_errors_detected_while_recovering_look_for_lines_starting_with_questions[]\n\tINIT(= N_(\"E312: Errors detected while recovering; look for lines starting with ???\"));\nEXTERN char e_cannot_preserve_there_is_no_swap_file[]\n\tINIT(= N_(\"E313: Cannot preserve, there is no swap file\"));\nEXTERN char e_preserve_failed[]\n\tINIT(= N_(\"E314: Preserve failed\"));\nEXTERN char e_ml_get_invalid_lnum_nr[]\n\tINIT(= \"E315: ml_get: Invalid lnum: %ld\");\nEXTERN char e_ml_get_cannot_find_line_nr_in_buffer_nr_str[]\n\tINIT(= \"E316: ml_get: Cannot find line %ld in buffer %d %s\");\nEXTERN char e_pointer_block_id_wrong[]\n\tINIT(= \"E317: Pointer block id wrong\");\nEXTERN char e_pointer_block_id_wrong_two[]\n\tINIT(= \"E317: Pointer block id wrong 2\");\nEXTERN char e_pointer_block_id_wrong_three[]\n\tINIT(= \"E317: Pointer block id wrong 3\");\nEXTERN char e_pointer_block_id_wrong_four[]\n\tINIT(= \"E317: Pointer block id wrong 4\");\nEXTERN char e_updated_too_many_blocks[]\n\tINIT(= \"E318: Updated too many blocks?\");\nEXTERN char e_sorry_command_is_not_available_in_this_version[]\n\tINIT(= N_(\"E319: Sorry, the command is not available in this version\"));\nEXTERN char e_cannot_find_line_nr[]\n\tINIT(= \"E320: Cannot find line %ld\");\nEXTERN char e_could_not_reload_str[]\n\tINIT(= N_(\"E321: Could not reload \\\"%s\\\"\"));\nEXTERN char e_line_number_out_of_range_nr_past_the_end[]\n\tINIT(= \"E322: Line number out of range: %ld past the end\");\nEXTERN char e_line_count_wrong_in_block_nr[]\n\tINIT(= \"E323: Line count wrong in block %ld\");\n#ifdef FEAT_POSTSCRIPT\nEXTERN char e_cant_open_postscript_output_file[]\n\tINIT(= N_(\"E324: Can't open PostScript output file\"));\n#endif\nEXTERN char e_attention[]\n\tINIT(= N_(\"E325: ATTENTION\"));\nEXTERN char e_too_many_swap_files_found[]\n\tINIT(= N_(\"E326: Too many swap files found\"));\n#ifdef FEAT_MENU\nEXTERN char_u e_part_of_menu_item_path_is_not_sub_menu[]\n\tINIT(= N_(\"E327: Part of menu-item path is not sub-menu\"));\nEXTERN char e_menu_only_exists_in_another_mode[]\n\tINIT(= N_(\"E328: Menu only exists in another mode\"));\nEXTERN char_u e_no_menu_str[]\n\tINIT(= N_(\"E329: No menu \\\"%s\\\"\"));\nEXTERN char e_menu_path_must_not_lead_to_sub_menu[]\n\tINIT(= N_(\"E330: Menu path must not lead to a sub-menu\"));\nEXTERN char e_must_not_add_menu_items_directly_to_menu_bar[]\n\tINIT(= N_(\"E331: Must not add menu items directly to menu bar\"));\nEXTERN char e_separator_cannot_be_part_of_menu_path[]\n\tINIT(= N_(\"E332: Separator cannot be part of a menu path\"));\nEXTERN char e_menu_path_must_lead_to_menu_item[]\n\tINIT(= N_(\"E333: Menu path must lead to a menu item\"));\nEXTERN char e_menu_not_found_str[]\n\tINIT(= N_(\"E334: Menu not found: %s\"));\nEXTERN char e_menu_not_defined_for_str_mode[]\n\tINIT(= N_(\"E335: Menu not defined for %s mode\"));\nEXTERN char e_menu_path_must_lead_to_sub_menu[]\n\tINIT(= N_(\"E336: Menu path must lead to a sub-menu\"));\nEXTERN char e_menu_not_found_check_menu_names[]\n\tINIT(= N_(\"E337: Menu not found - check menu names\"));\n#endif\n#ifdef FEAT_BROWSE\nEXTERN char e_sorry_no_file_browser_in_console_mode[]\n\tINIT(= N_(\"E338: Sorry, no file browser in console mode\"));\n#endif\nEXTERN char e_pattern_too_long[]\n\tINIT(= N_(\"E339: Pattern too long\"));\nEXTERN char e_internal_error_please_report_a_bug[]\n\tINIT(= N_(\"E340: Internal error; if you can reproduce please report a bug\"));\nEXTERN char e_internal_error_lalloc_zero[]\n\tINIT(= \"E341: Internal error: lalloc(0, )\");\nEXTERN char e_out_of_memory_allocating_nr_bytes[]\n\tINIT(= N_(\"E342: Out of memory!  (allocating %lu bytes)\"));\nEXTERN char e_invalid_path_number_must_be_at_end_of_path_or_be_followed_by_str[]\n\tINIT(= N_(\"E343: Invalid path: '**[number]' must be at the end of the path or be followed by '%s'.\"));\nEXTERN char e_cant_find_directory_str_in_cdpath[]\n\tINIT(= N_(\"E344: Can't find directory \\\"%s\\\" in cdpath\"));\nEXTERN char e_cant_find_file_str_in_path[]\n\tINIT(= N_(\"E345: Can't find file \\\"%s\\\" in path\"));\nEXTERN char e_no_more_directory_str_found_in_cdpath[]\n\tINIT(= N_(\"E346: No more directory \\\"%s\\\" found in cdpath\"));\nEXTERN char e_no_more_file_str_found_in_path[]\n\tINIT(= N_(\"E347: No more file \\\"%s\\\" found in path\"));\nEXTERN char e_no_string_under_cursor[]\n\tINIT(= N_(\"E348: No string under cursor\"));\nEXTERN char e_no_identifier_under_cursor[]\n\tINIT(= N_(\"E349: No identifier under cursor\"));\n#ifdef FEAT_FOLDING\nEXTERN char e_cannot_create_fold_with_current_foldmethod[]\n\tINIT(= N_(\"E350: Cannot create fold with current 'foldmethod'\"));\nEXTERN char e_cannot_delete_fold_with_current_foldmethod[]\n\tINIT(= N_(\"E351: Cannot delete fold with current 'foldmethod'\"));\nEXTERN char e_cannot_erase_folds_with_current_foldmethod[]\n\tINIT(= N_(\"E352: Cannot erase folds with current 'foldmethod'\"));\n#endif\nEXTERN char e_nothing_in_register_str[]\n\tINIT(= N_(\"E353: Nothing in register %s\"));\nEXTERN char e_invalid_register_name_str[]\n\tINIT(= N_(\"E354: Invalid register name: '%s'\"));\nEXTERN char e_unknown_option_str_2[]\n\tINIT(= N_(\"E355: Unknown option: %s\"));\nEXTERN char e_get_varp_error[]\n\tINIT(= \"E356: get_varp ERROR\");\n#ifdef FEAT_LANGMAP\nEXTERN char e_langmap_matching_character_missing_for_str[]\n\tINIT(= N_(\"E357: 'langmap': Matching character missing for %s\"));\nEXTERN char e_langmap_extra_characters_after_semicolon_str[]\n\tINIT(= N_(\"E358: 'langmap': Extra characters after semicolon: %s\"));\n#endif\n#if defined(AMIGA) || defined(MACOS_X) || defined(MSWIN)  \\\n\t|| defined(UNIX) || defined(VMS)\nEXTERN char e_screen_mode_setting_not_supported[]\n\tINIT(= N_(\"E359: Screen mode setting not supported\"));\n#endif\n#ifdef AMIGA\nEXTERN char e_cannot_execute_shell_with_f_option[]\n\tINIT(= N_(\"E360: Cannot execute shell with -f option\"));\n#endif\n// E361 unused\n#if defined(FEAT_EVAL)\nEXTERN char e_using_boolean_value_as_float[]\n\tINIT(= N_(\"E362: Using a boolean value as a Float\"));\n#endif\nEXTERN char e_pattern_uses_more_memory_than_maxmempattern[]\n\tINIT(= N_(\"E363: Pattern uses more memory than 'maxmempattern'\"));\n#ifdef FEAT_LIBCALL\nEXTERN char e_library_call_failed_for_str[]\n\tINIT(= N_(\"E364: Library call failed for \\\"%s()\\\"\"));\n#endif\n#ifdef FEAT_POSTSCRIPT\nEXTERN char e_failed_to_print_postscript_file[]\n\tINIT(= N_(\"E365: Failed to print PostScript file\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_not_allowed_to_enter_popup_window[]\n\tINIT(= N_(\"E366: Not allowed to enter a popup window\"));\n#endif\nEXTERN char e_no_such_group_str[]\n\tINIT(= N_(\"E367: No such group: \\\"%s\\\"\"));\n#ifdef FEAT_LIBCALL\nEXTERN char e_got_sig_str_in_libcall[]\n\tINIT(= N_(\"E368: Got SIG%s in libcall()\"));\n#endif\nEXTERN char e_invalid_item_in_str_brackets[]\n\tINIT(= N_(\"E369: Invalid item in %s%%[]\"));\n#ifdef USING_LOAD_LIBRARY\nEXTERN char e_could_not_load_library_str_str[]\n\tINIT(= N_(\"E370: Could not load library %s: %s\"));\n#endif\n#ifdef FEAT_GUI_MSWIN\nEXTERN char e_command_not_found[]\n\tINIT(= N_(\"E371: Command not found\"));\n#endif\n#ifdef FEAT_QUICKFIX\nEXTERN char e_too_many_chr_in_format_string[]\n\tINIT(= N_(\"E372: Too many %%%c in format string\"));\nEXTERN char e_unexpected_chr_in_format_str[]\n\tINIT(= N_(\"E373: Unexpected %%%c in format string\"));\nEXTERN char e_missing_rsb_in_format_string[]\n\tINIT(= N_(\"E374: Missing ] in format string\"));\nEXTERN char e_unsupported_chr_in_format_string[]\n\tINIT(= N_(\"E375: Unsupported %%%c in format string\"));\nEXTERN char e_invalid_chr_in_format_string_prefix[]\n\tINIT(= N_(\"E376: Invalid %%%c in format string prefix\"));\nEXTERN char e_invalid_chr_in_format_string[]\n\tINIT(= N_(\"E377: Invalid %%%c in format string\"));\nEXTERN char e_errorformat_contains_no_pattern[]\n\tINIT(= N_(\"E378: 'errorformat' contains no pattern\"));\nEXTERN char e_missing_or_empty_directory_name[]\n\tINIT(= N_(\"E379: Missing or empty directory name\"));\nEXTERN char e_at_bottom_of_quickfix_stack[]\n\tINIT(= N_(\"E380: At bottom of quickfix stack\"));\nEXTERN char e_at_top_of_quickfix_stack[]\n\tINIT(= N_(\"E381: At top of quickfix stack\"));\n#endif\nEXTERN char e_cannot_write_buftype_option_is_set[]\n\tINIT(= N_(\"E382: Cannot write, 'buftype' option is set\"));\nEXTERN char e_invalid_search_string_str[]\n\tINIT(= N_(\"E383: Invalid search string: %s\"));\nEXTERN char e_search_hit_top_without_match_for_str[]\n\tINIT(= N_(\"E384: Search hit TOP without match for: %s\"));\nEXTERN char e_search_hit_bottom_without_match_for_str[]\n\tINIT(= N_(\"E385: Search hit BOTTOM without match for: %s\"));\nEXTERN char e_expected_question_or_slash_after_semicolon[]\n\tINIT(= N_(\"E386: Expected '?' or '/'  after ';'\"));\n#ifdef FEAT_FIND_ID\nEXTERN char e_match_is_on_current_line[]\n\tINIT(= N_(\"E387: Match is on current line\"));\nEXTERN char e_couldnt_find_definition[]\n\tINIT(= N_(\"E388: Couldn't find definition\"));\nEXTERN char e_couldnt_find_pattern[]\n\tINIT(= N_(\"E389: Couldn't find pattern\"));\n#endif\n#ifdef FEAT_SYN_HL\nEXTERN char e_illegal_argument_str_2[]\n\tINIT(= N_(\"E390: Illegal argument: %s\"));\nEXTERN char e_no_such_syntax_cluster_str_1[]\n\tINIT(= N_(\"E391: No such syntax cluster: %s\"));\nEXTERN char e_no_such_syntax_cluster_str_2[]\n\tINIT(= N_(\"E392: No such syntax cluster: %s\"));\nEXTERN char e_groupthere_not_accepted_here[]\n\tINIT(= N_(\"E393: group[t]here not accepted here\"));\nEXTERN char e_didnt_find_region_item_for_str[]\n\tINIT(= N_(\"E394: Didn't find region item for %s\"));\nEXTERN char e_contains_argument_not_accepted_here[]\n\tINIT(= N_(\"E395: Contains argument not accepted here\"));\n// E396 unused\nEXTERN char e_filename_required[]\n\tINIT(= N_(\"E397: Filename required\"));\nEXTERN char e_missing_equal_str[]\n\tINIT(= N_(\"E398: Missing '=': %s\"));\nEXTERN char e_not_enough_arguments_syntax_region_str[]\n\tINIT(= N_(\"E399: Not enough arguments: syntax region %s\"));\nEXTERN char e_no_cluster_specified[]\n\tINIT(= N_(\"E400: No cluster specified\"));\nEXTERN char e_pattern_delimiter_not_found_str[]\n\tINIT(= N_(\"E401: Pattern delimiter not found: %s\"));\nEXTERN char e_garbage_after_pattern_str[]\n\tINIT(= N_(\"E402: Garbage after pattern: %s\"));\nEXTERN char e_syntax_sync_line_continuations_pattern_specified_twice[]\n\tINIT(= N_(\"E403: syntax sync: Line continuations pattern specified twice\"));\nEXTERN char e_illegal_arguments_str[]\n\tINIT(= N_(\"E404: Illegal arguments: %s\"));\nEXTERN char e_missing_equal_sign_str[]\n\tINIT(= N_(\"E405: Missing equal sign: %s\"));\nEXTERN char e_empty_argument_str[]\n\tINIT(= N_(\"E406: Empty argument: %s\"));\nEXTERN char e_str_not_allowed_here[]\n\tINIT(= N_(\"E407: %s not allowed here\"));\nEXTERN char e_str_must_be_first_in_contains_list[]\n\tINIT(= N_(\"E408: %s must be first in contains list\"));\nEXTERN char e_unknown_group_name_str[]\n\tINIT(= N_(\"E409: Unknown group name: %s\"));\nEXTERN char e_invalid_syntax_subcommand_str[]\n\tINIT(= N_(\"E410: Invalid :syntax subcommand: %s\"));\n#endif\nEXTERN char e_highlight_group_name_not_found_str[]\n\tINIT(= N_(\"E411: Highlight group not found: %s\"));\nEXTERN char e_not_enough_arguments_highlight_link_str[]\n\tINIT(= N_(\"E412: Not enough arguments: \\\":highlight link %s\\\"\"));\nEXTERN char e_too_many_arguments_highlight_link_str[]\n\tINIT(= N_(\"E413: Too many arguments: \\\":highlight link %s\\\"\"));\nEXTERN char e_group_has_settings_highlight_link_ignored[]\n\tINIT(= N_(\"E414: Group has settings, highlight link ignored\"));\nEXTERN char e_unexpected_equal_sign_str[]\n\tINIT(= N_(\"E415: Unexpected equal sign: %s\"));\nEXTERN char e_missing_equal_sign_str_2[]\n\tINIT(= N_(\"E416: Missing equal sign: %s\"));\nEXTERN char e_missing_argument_str[]\n\tINIT(= N_(\"E417: Missing argument: %s\"));\nEXTERN char e_illegal_value_str[]\n\tINIT(= N_(\"E418: Illegal value: %s\"));\nEXTERN char e_im_a_teapot[]\n\tINIT(= N_(\"E418: I'm a teapot\"));\nEXTERN char e_fg_color_unknown[]\n\tINIT(= N_(\"E419: FG color unknown\"));\nEXTERN char e_bg_color_unknown[]\n\tINIT(= N_(\"E420: BG color unknown\"));\nEXTERN char e_color_name_or_number_not_recognized_str[]\n\tINIT(= N_(\"E421: Color name or number not recognized: %s\"));\nEXTERN char e_terminal_code_too_long_str[]\n\tINIT(= N_(\"E422: Terminal code too long: %s\"));\nEXTERN char e_illegal_argument_str_3[]\n\tINIT(= N_(\"E423: Illegal argument: %s\"));\nEXTERN char e_too_many_different_highlighting_attributes_in_use[]\n\tINIT(= N_(\"E424: Too many different highlighting attributes in use\"));\nEXTERN char e_cannot_go_before_first_matching_tag[]\n\tINIT(= N_(\"E425: Cannot go before first matching tag\"));\nEXTERN char e_tag_not_found_str[]\n\tINIT(= N_(\"E426: Tag not found: %s\"));\nEXTERN char e_there_is_only_one_matching_tag[]\n\tINIT(= N_(\"E427: There is only one matching tag\"));\nEXTERN char e_cannot_go_beyond_last_matching_tag[]\n\tINIT(= N_(\"E428: Cannot go beyond last matching tag\"));\nEXTERN char e_file_str_does_not_exist[]\n\tINIT(= N_(\"E429: File \\\"%s\\\" does not exist\"));\n#ifdef FEAT_EMACS_TAGS\nEXTERN char e_tag_file_path_truncated_for_str[]\n\tINIT(= N_(\"E430: Tag file path truncated for %s\\n\"));\n#endif\nEXTERN char e_format_error_in_tags_file_str[]\n\tINIT(= N_(\"E431: Format error in tags file \\\"%s\\\"\"));\nEXTERN char e_tags_file_not_sorted_str[]\n\tINIT(= N_(\"E432: Tags file not sorted: %s\"));\nEXTERN char e_no_tags_file[]\n\tINIT(= N_(\"E433: No tags file\"));\nEXTERN char e_cannot_find_tag_pattern[]\n\tINIT(= N_(\"E434: Can't find tag pattern\"));\nEXTERN char e_couldnt_find_tag_just_guessing[]\n\tINIT(= N_(\"E435: Couldn't find tag, just guessing!\"));\nEXTERN char e_no_str_entry_in_termcap[]\n\tINIT(= N_(\"E436: No \\\"%s\\\" entry in termcap\"));\nEXTERN char e_terminal_capability_cm_required[]\n\tINIT(= N_(\"E437: Terminal capability \\\"cm\\\" required\"));\nEXTERN char e_u_undo_line_numbers_wrong[]\n\tINIT(= \"E438: u_undo: Line numbers wrong\");\nEXTERN char e_undo_list_corrupt[]\n\tINIT(= \"E439: Undo list corrupt\");\nEXTERN char e_undo_line_missing[]\n\tINIT(= \"E440: Undo line missing\");\n#ifdef FEAT_QUICKFIX\nEXTERN char e_there_is_no_preview_window[]\n\tINIT(= N_(\"E441: There is no preview window\"));\n#endif\nEXTERN char e_cant_split_topleft_and_botright_at_the_same_time[]\n\tINIT(= N_(\"E442: Can't split topleft and botright at the same time\"));\nEXTERN char e_cannot_rotate_when_another_window_is_split[]\n\tINIT(= N_(\"E443: Cannot rotate when another window is split\"));\nEXTERN char e_cannot_close_last_window[]\n\tINIT(= N_(\"E444: Cannot close last window\"));\nEXTERN char e_other_window_contains_changes[]\n\tINIT(= N_(\"E445: Other window contains changes\"));\nEXTERN char e_no_file_name_under_cursor[]\n\tINIT(= N_(\"E446: No file name under cursor\"));\nEXTERN char e_cant_find_file_str_in_path_2[]\n\tINIT(= N_(\"E447: Can't find file \\\"%s\\\" in path\"));\n#ifdef USING_LOAD_LIBRARY\nEXTERN char e_could_not_load_library_function_str[]\n\tINIT(= N_(\"E448: Could not load library function %s\"));\n#endif\n#ifdef FEAT_CLIENTSERVER\nEXTERN char e_invalid_expression_received[]\n\tINIT(= N_(\"E449: Invalid expression received\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_buffer_number_text_or_list_required[]\n\tINIT(= N_(\"E450: Buffer number, text or a list required\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_expected_right_curly_str[]\n\tINIT(= N_(\"E451: Expected }: %s\"));\nEXTERN char e_double_semicolon_in_list_of_variables[]\n\tINIT(= N_(\"E452: Double ; in list of variables\"));\n#endif\nEXTERN char e_ul_color_unknown[]\n\tINIT(= N_(\"E453: UL color unknown\"));\n#ifdef FEAT_EVAL\nEXTERN char e_function_list_was_modified[]\n\tINIT(= N_(\"E454: Function list was modified\"));\n#endif\n#ifdef FEAT_POSTSCRIPT\nEXTERN char e_error_writing_to_postscript_output_file[]\n\tINIT(= N_(\"E455: Error writing to PostScript output file\"));\nEXTERN char e_cant_open_file_str_2[]\n\tINIT(= N_(\"E456: Can't open file \\\"%s\\\"\"));\nEXTERN char e_cant_find_postscript_resource_file_str_ps[]\n\tINIT(= N_(\"E456: Can't find PostScript resource file \\\"%s.ps\\\"\"));\nEXTERN char e_cant_read_postscript_resource_file_str[]\n\tINIT(= N_(\"E457: Can't read PostScript resource file \\\"%s\\\"\"));\n#endif\n#ifdef FEAT_GUI_X11\nEXTERN char e_cannot_allocate_colormap_entry_some_colors_may_be_incorrect[]\n\tINIT(= N_(\"E458: Cannot allocate colormap entry, some colors may be incorrect\"));\n#endif\n#if defined(UNIX) || defined(FEAT_SESSION)\nEXTERN char e_cannot_go_back_to_previous_directory[]\n\tINIT(= N_(\"E459: Cannot go back to previous directory\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_entries_missing_in_mapset_dict_argument[]\n\tINIT(= N_(\"E460: Entries missing in mapset() dict argument\"));\nEXTERN char e_illegal_variable_name_str[]\n\tINIT(= N_(\"E461: Illegal variable name: %s\"));\n#endif\nEXTERN char e_could_not_prepare_for_reloading_str[]\n\tINIT(= N_(\"E462: Could not prepare for reloading \\\"%s\\\"\"));\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_region_is_guarded_cannot_modify[]\n\tINIT(= N_(\"E463: Region is guarded, cannot modify\"));\n#endif\nEXTERN char e_ambiguous_use_of_user_defined_command[]\n\tINIT(= N_(\"E464: Ambiguous use of user-defined command\"));\n#ifdef FEAT_EVAL\nEXTERN char e_ambiguous_use_of_user_defined_command_str[]\n\tINIT(= N_(\"E464: Ambiguous use of user-defined command: %s\"));\n#endif\nEXTERN char e_winsize_requires_two_number_arguments[]\n\tINIT(= N_(\"E465: :winsize requires two number arguments\"));\nEXTERN char e_winpos_requires_two_number_arguments[]\n\tINIT(= N_(\"E466: :winpos requires two number arguments\"));\n#ifdef FEAT_EVAL\nEXTERN char e_custom_completion_requires_function_argument[]\n\tINIT(= N_(\"E467: Custom completion requires a function argument\"));\n#endif\nEXTERN char e_completion_argument_only_allowed_for_custom_completion[]\n\tINIT(= N_(\"E468: Completion argument only allowed for custom completion\"));\n#ifdef FEAT_CSCOPE\nEXTERN char e_invalid_cscopequickfix_flag_chr_for_chr[]\n\tINIT(= N_(\"E469: Invalid cscopequickfix flag %c for %c\"));\n#endif\nEXTERN char e_command_aborted[]\n\tINIT(= N_(\"E470: Command aborted\"));\nEXTERN char e_argument_required[]\n\tINIT(= N_(\"E471: Argument required\"));\nEXTERN char e_command_failed[]\n\tINIT(= N_(\"E472: Command failed\"));\nEXTERN char e_internal_error_in_regexp[]\n\tINIT(= \"E473: Internal error in regexp\");\nEXTERN char e_invalid_argument[]\n\tINIT(= N_(\"E474: Invalid argument\"));\nEXTERN char e_invalid_argument_str[]\n\tINIT(= N_(\"E475: Invalid argument: %s\"));\nEXTERN char e_invalid_value_for_argument_str[]\n\tINIT(= N_(\"E475: Invalid value for argument %s\"));\n#if defined(FEAT_JOB_CHANNEL) || defined(FEAT_PROP_POPUP) || defined(FEAT_EVAL)\nEXTERN char e_invalid_value_for_argument_str_str[]\n\tINIT(= N_(\"E475: Invalid value for argument %s: %s\"));\n#endif\nEXTERN char e_invalid_command[]\n\tINIT(= N_(\"E476: Invalid command\"));\nEXTERN char e_invalid_command_str[]\n\tINIT(= N_(\"E476: Invalid command: %s\"));\n#ifdef FEAT_EVAL\nEXTERN char e_invalid_command_str_expected_str[]\n\tINIT(= N_(\"E476: Invalid command: %s, expected %s\"));\n#endif\nEXTERN char e_no_bang_allowed[]\n\tINIT(= N_(\"E477: No ! allowed\"));\nEXTERN char e_dont_panic[]\n\tINIT(= N_(\"E478: Don't panic!\"));\nEXTERN char e_no_match[]\n\tINIT(= N_(\"E479: No match\"));\nEXTERN char e_no_match_str_2[]\n\tINIT(= N_(\"E480: No match: %s\"));\nEXTERN char e_no_range_allowed[]\n\tINIT(= N_(\"E481: No range allowed\"));\nEXTERN char e_cant_create_file_str[]\n\tINIT(= N_(\"E482: Can't create file %s\"));\nEXTERN char e_cant_get_temp_file_name[]\n\tINIT(= N_(\"E483: Can't get temp file name\"));\nEXTERN char e_cant_open_file_str[]\n\tINIT(= N_(\"E484: Can't open file %s\"));\nEXTERN char e_cant_read_file_str[]\n\tINIT(= N_(\"E485: Can't read file %s\"));\nEXTERN char e_pattern_not_found[]\n\tINIT(= N_(\"E486: Pattern not found\"));\nEXTERN char e_pattern_not_found_str[]\n\tINIT(= N_(\"E486: Pattern not found: %s\"));\nEXTERN char e_argument_must_be_positive[]\n\tINIT(= N_(\"E487: Argument must be positive\"));\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_argument_must_be_positive_str[]\n\tINIT(= N_(\"E487: Argument must be positive: %s\"));\n#endif\nEXTERN char e_trailing_characters[]\n\tINIT(= N_(\"E488: Trailing characters\"));\nEXTERN char e_trailing_characters_str[]\n\tINIT(= N_(\"E488: Trailing characters: %s\"));\nEXTERN char e_no_call_stack_to_substitute_for_stack[]\n\tINIT(= N_(\"E489: No call stack to substitute for \\\"<stack>\\\"\"));\n#ifdef FEAT_FOLDING\nEXTERN char e_no_fold_found[]\n\tINIT(= N_(\"E490: No fold found\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_json_decode_error_at_str[]\n\tINIT(= N_(\"E491: JSON decode error at '%s'\"));\n#endif\nEXTERN char e_not_an_editor_command[]\n\tINIT(= N_(\"E492: Not an editor command\"));\nEXTERN char e_backwards_range_given[]\n\tINIT(= N_(\"E493: Backwards range given\"));\nEXTERN char e_use_w_or_w_gt_gt[]\n\tINIT(= N_(\"E494: Use w or w>>\"));\nEXTERN char e_no_autocommand_file_name_to_substitute_for_afile[]\n\tINIT(= N_(\"E495: No autocommand file name to substitute for \\\"<afile>\\\"\"));\nEXTERN char e_no_autocommand_buffer_number_to_substitute_for_abuf[]\n\tINIT(= N_(\"E496: No autocommand buffer number to substitute for \\\"<abuf>\\\"\"));\nEXTERN char e_no_autocommand_match_name_to_substitute_for_amatch[]\n\tINIT(= N_(\"E497: No autocommand match name to substitute for \\\"<amatch>\\\"\"));\nEXTERN char e_no_source_file_name_to_substitute_for_sfile[]\n\tINIT(= N_(\"E498: No :source file name to substitute for \\\"<sfile>\\\"\"));\nEXTERN char e_empty_file_name_for_percent_or_hash_only_works_with_ph[]\n\t// xgettext:no-c-format\n\tINIT(= N_(\"E499: Empty file name for '%' or '#', only works with \\\":p:h\\\"\"));\nEXTERN char e_evaluates_to_an_empty_string[]\n\tINIT(= N_(\"E500: Evaluates to an empty string\"));\nEXTERN char e_at_end_of_file[]\n\tINIT(= N_(\"E501: At end-of-file\"));\n\t// E502\nEXTERN char e_is_a_directory[]\n\tINIT(= N_(\"is a directory\"));\n\t// E503\nEXTERN char e_is_not_file_or_writable_device[]\n\tINIT(= N_(\"is not a file or writable device\"));\nEXTERN char e_str_is_not_file_or_writable_device[]\n\tINIT(= N_(\"E503: \\\"%s\\\" is not a file or writable device\"));\nEXTERN char e_coffee_currently_not_available[]\n\tINIT(= N_(\"E503: Coffee is currently not available\"));\n\t// E504\nEXTERN char e_is_read_only_cannot_override_W_in_cpoptions[]\n\tINIT(= N_(\"is read-only (cannot override: \\\"W\\\" in 'cpoptions')\"));\n\t// E505\nEXTERN char e_is_read_only_add_bang_to_override[]\n\tINIT(= N_(\"is read-only (add ! to override)\"));\nEXTERN char e_str_is_read_only_add_bang_to_override[]\n\tINIT(= N_(\"E505: \\\"%s\\\" is read-only (add ! to override)\"));\nEXTERN char e_cant_write_to_backup_file_add_bang_to_override[]\n\tINIT(= N_(\"E506: Can't write to backup file (add ! to override)\"));\nEXTERN char e_close_error_for_backup_file_add_bang_to_write_anyway[]\n\tINIT(= N_(\"E507: Close error for backup file (add ! to write anyway)\"));\nEXTERN char e_cant_read_file_for_backup_add_bang_to_write_anyway[]\n\tINIT(= N_(\"E508: Can't read file for backup (add ! to write anyway)\"));\nEXTERN char e_cannot_create_backup_file_add_bang_to_write_anyway[]\n\tINIT(= N_(\"E509: Cannot create backup file (add ! to override)\"));\nEXTERN char e_cant_make_backup_file_add_bang_to_write_anyway[]\n\tINIT(= N_(\"E510: Can't make backup file (add ! to write anyway)\"));\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_netbeans_already_connected[]\n\tINIT(= N_(\"E511: NetBeans already connected\"));\n#endif\nEXTERN char e_close_failed[]\n\tINIT(= N_(\"E512: Close failed\"));\nEXTERN char e_write_error_conversion_failed_make_fenc_empty_to_override[]\n\tINIT(= N_(\"E513: Write error, conversion failed (make 'fenc' empty to override)\"));\nEXTERN char e_write_error_conversion_failed_in_line_nr_make_fenc_empty_to_override[]\n\tINIT(= N_(\"E513: Write error, conversion failed in line %ld (make 'fenc' empty to override)\"));\nEXTERN char e_write_error_file_system_full[]\n\tINIT(= N_(\"E514: Write error (file system full?)\"));\nEXTERN char e_no_buffers_were_unloaded[]\n\tINIT(= N_(\"E515: No buffers were unloaded\"));\nEXTERN char e_no_buffers_were_deleted[]\n\tINIT(= N_(\"E516: No buffers were deleted\"));\nEXTERN char e_no_buffers_were_wiped_out[]\n\tINIT(= N_(\"E517: No buffers were wiped out\"));\nEXTERN char e_unknown_option[]\n\tINIT(= N_(\"E518: Unknown option\"));\nEXTERN char e_option_not_supported[]\n\tINIT(= N_(\"E519: Option not supported\"));\nEXTERN char e_not_allowed_in_modeline[]\n\tINIT(= N_(\"E520: Not allowed in a modeline\"));\nEXTERN char e_number_required_after_equal[]\n\tINIT(= N_(\"E521: Number required after =\"));\nEXTERN char e_number_required_after_str_equal_str[]\n\tINIT(= N_(\"E521: Number required: &%s = '%s'\"));\nEXTERN char e_not_found_in_termcap[]\n\tINIT(= N_(\"E522: Not found in termcap\"));\nEXTERN char e_not_allowed_here[]\n\tINIT(= N_(\"E523: Not allowed here\"));\nEXTERN char e_missing_colon[]\n\tINIT(= N_(\"E524: Missing colon\"));\nEXTERN char e_zero_length_string[]\n\tINIT(= N_(\"E525: Zero length string\"));\n#ifdef FEAT_VIMINFO\nEXTERN char e_missing_number_after_angle_str_angle[]\n\tINIT(= N_(\"E526: Missing number after <%s>\"));\nEXTERN char e_missing_comma[]\n\tINIT(= N_(\"E527: Missing comma\"));\nEXTERN char e_must_specify_a_value[]\n\tINIT(= N_(\"E528: Must specify a ' value\"));\n#endif\nEXTERN char e_cannot_set_term_to_empty_string[]\n\tINIT(= N_(\"E529: Cannot set 'term' to empty string\"));\n#ifdef FEAT_GUI\nEXTERN char e_cannot_change_term_in_GUI[]\n\tINIT(= N_(\"E530: Cannot change 'term' in the GUI\"));\nEXTERN char e_use_gui_to_start_GUI[]\n\tINIT(= N_(\"E531: Use \\\":gui\\\" to start the GUI\"));\n#endif\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_highlighting_color_name_too_long_in_defineAnnoType[]\n\tINIT(= N_(\"E532: Highlighting color name too long in defineAnnoType\"));\n#endif\n#ifdef FEAT_GUI\nEXTERN char e_cant_select_wide_font[]\n\tINIT(= N_(\"E533: Can't select wide font\"));\nEXTERN char e_invalid_wide_font[]\n\tINIT(= N_(\"E534: Invalid wide font\"));\n#endif\nEXTERN char e_illegal_character_after_chr[]\n\tINIT(= N_(\"E535: Illegal character after <%c>\"));\n#ifdef FEAT_FOLDING\nEXTERN char e_comma_required[]\n\tINIT(= N_(\"E536: Comma required\"));\nEXTERN char e_commentstring_must_be_empty_or_contain_str[]\n\tINIT(= N_(\"E537: 'commentstring' must be empty or contain %s\"));\n#endif\nEXTERN char e_pattern_found_in_every_line_str[]\n\tINIT(= N_(\"E538: Pattern found in every line: %s\"));\nEXTERN char e_illegal_character_str[]\n\tINIT(= N_(\"E539: Illegal character <%s>\"));\n#ifdef FEAT_STL_OPT\nEXTERN char e_unclosed_expression_sequence[]\n\tINIT(= N_(\"E540: Unclosed expression sequence\"));\n// E541 unused\nEXTERN char e_unbalanced_groups[]\n\tINIT(= N_(\"E542: Unbalanced groups\"));\n#endif\n#ifdef MSWIN\nEXTERN char e_not_valid_codepage[]\n\tINIT(= N_(\"E543: Not a valid codepage\"));\n#endif\n#ifdef FEAT_KEYMAP\nEXTERN char e_keymap_file_not_found[]\n\tINIT(= N_(\"E544: Keymap file not found\"));\n#endif\n#ifdef CURSOR_SHAPE\nEXTERN char e_missing_colon_2[]\n\tINIT(= N_(\"E545: Missing colon\"));\nEXTERN char e_illegal_mode[]\n\tINIT(= N_(\"E546: Illegal mode\"));\n#endif\n#ifdef FEAT_MOUSESHAPE\nEXTERN char e_illegal_mouseshape[]\n\tINIT(= N_(\"E547: Illegal mouseshape\"));\n#endif\n#ifdef CURSOR_SHAPE\nEXTERN char e_digit_expected[]\n\tINIT(= N_(\"E548: Digit expected\"));\nEXTERN char e_illegal_percentage[]\n\tINIT(= N_(\"E549: Illegal percentage\"));\n#endif\n#ifdef FEAT_PRINTER\nEXTERN char e_missing_colon_3[]\n\tINIT(= N_(\"E550: Missing colon\"));\nEXTERN char e_illegal_component[]\n\tINIT(= N_(\"E551: Illegal component\"));\nEXTERN char e_digit_expected_2[]\n\tINIT(= N_(\"E552: Digit expected\"));\n#endif\n#ifdef FEAT_QUICKFIX\nEXTERN char e_no_more_items[]\n\tINIT(= N_(\"E553: No more items\"));\n#endif\nEXTERN char e_syntax_error_in_str_curlies[]\n\tINIT(= N_(\"E554: Syntax error in %s{...}\"));\nEXTERN char e_at_bottom_of_tag_stack[]\n\tINIT(= N_(\"E555: At bottom of tag stack\"));\nEXTERN char e_at_top_of_tag_stack[]\n\tINIT(= N_(\"E556: At top of tag stack\"));\nEXTERN char e_cannot_open_termcap_file[]\n\tINIT(= N_(\"E557: Cannot open termcap file\"));\nEXTERN char e_terminal_entry_not_found_in_terminfo[]\n\tINIT(= N_(\"E558: Terminal entry not found in terminfo\"));\n#if defined(HAVE_TGETENT) && !defined(TERMINFO)\nEXTERN char e_terminal_entry_not_found_in_termcap[]\n\tINIT(= N_(\"E559: Terminal entry not found in termcap\"));\n#endif\n#ifdef FEAT_CSCOPE\nEXTERN char e_usage_cscope_str[]\n\tINIT(= N_(\"E560: Usage: cs[cope] %s\"));\nEXTERN char e_unknown_cscope_search_type[]\n\tINIT(= N_(\"E561: Unknown cscope search type\"));\nEXTERN char e_usage_cstag_ident[]\n\tINIT(= N_(\"E562: Usage: cstag <ident>\"));\nEXTERN char e_stat_str_error_nr[]\n\tINIT(= N_(\"E563: stat(%s) error: %d\"));\nEXTERN char e_str_is_not_directory_or_valid_cscope_database[]\n\tINIT(= N_(\"E564: %s is not a directory or a valid cscope database\"));\n#endif\nEXTERN char e_not_allowed_to_change_text_or_change_window[]\n\tINIT(= N_(\"E565: Not allowed to change text or change window\"));\n#ifdef FEAT_CSCOPE\nEXTERN char e_could_not_create_cscope_pipes[]\n\tINIT(= N_(\"E566: Could not create cscope pipes\"));\nEXTERN char e_no_cscope_connections[]\n\tINIT(= N_(\"E567: No cscope connections\"));\nEXTERN char e_duplicate_cscope_database_not_added[]\n\tINIT(= N_(\"E568: Duplicate cscope database not added\"));\n// E569 unused\nEXTERN char e_fatal_error_in_cs_manage_matches[]\n\tINIT(= \"E570: Fatal error in cs_manage_matches\");\n#endif\n#ifdef DYNAMIC_TCL\nEXTERN char e_sorry_this_command_is_disabled_tcl_library_could_not_be_loaded[]\n\tINIT(= N_(\"E571: Sorry, this command is disabled: the Tcl library could not be loaded.\"));\n#endif\n#ifdef FEAT_TCL\nEXTERN char e_exit_code_nr[]\n\tINIT(= N_(\"E572: Exit code %d\"));\n#endif\n#ifdef FEAT_CLIENTSERVER\nEXTERN char e_invalid_server_id_used_str[]\n\tINIT(= N_(\"E573: Invalid server id used: %s\"));\n#endif\n#ifdef FEAT_VIMINFO\nEXTERN char e_unknown_register_type_nr[]\n\tINIT(= N_(\"E574: Unknown register type %d\"));\n\t// E575\nEXTERN char e_illegal_starting_char[]\n\tINIT(= N_(\"Illegal starting char\"));\n\t// E576\nEXTERN char e_nonr_missing_gt[]\n\tINIT(= N_(\"Missing '>'\"));\n\t// E577\nEXTERN char e_illegal_register_name[]\n\tINIT(= N_(\"Illegal register name\"));\n#endif\n// E578 unused\n#ifdef FEAT_EVAL\nEXTERN char e_if_nesting_too_deep[]\n\tINIT(= N_(\"E579: :if nesting too deep\"));\nEXTERN char e_block_nesting_too_deep[]\n\tINIT(= N_(\"E579: Block nesting too deep\"));\nEXTERN char e_endif_without_if[]\n\tINIT(= N_(\"E580: :endif without :if\"));\nEXTERN char e_else_without_if[]\n\tINIT(= N_(\"E581: :else without :if\"));\nEXTERN char e_elseif_without_if[]\n\tINIT(= N_(\"E582: :elseif without :if\"));\nEXTERN char e_multiple_else[]\n\tINIT(= N_(\"E583: Multiple :else\"));\nEXTERN char e_elseif_after_else[]\n\tINIT(= N_(\"E584: :elseif after :else\"));\nEXTERN char e_while_for_nesting_too_deep[]\n\tINIT(= N_(\"E585: :while/:for nesting too deep\"));\nEXTERN char e_continue_without_while_or_for[]\n\tINIT(= N_(\"E586: :continue without :while or :for\"));\nEXTERN char e_break_without_while_or_for[]\n\tINIT(= N_(\"E587: :break without :while or :for\"));\nEXTERN char e_endwhile_without_while[]\n\tINIT(= N_(\"E588: :endwhile without :while\"));\nEXTERN char e_endfor_without_for[]\n\tINIT(= N_(\"E588: :endfor without :for\"));\n#endif\nEXTERN char e_backupext_and_patchmode_are_equal[]\n\tINIT(= N_(\"E589: 'backupext' and 'patchmode' are equal\"));\n#ifdef FEAT_QUICKFIX\nEXTERN char e_preview_window_already_exists[]\n\tINIT(= N_(\"E590: A preview window already exists\"));\n#endif\nEXTERN char e_winheight_cannot_be_smaller_than_winminheight[]\n\tINIT(= N_(\"E591: 'winheight' cannot be smaller than 'winminheight'\"));\nEXTERN char e_winwidth_cannot_be_smaller_than_winminwidth[]\n\tINIT(= N_(\"E592: 'winwidth' cannot be smaller than 'winminwidth'\"));\nEXTERN char e_need_at_least_nr_lines[]\n\tINIT(= N_(\"E593: Need at least %d lines\"));\nEXTERN char e_need_at_least_nr_columns[]\n\tINIT(= N_(\"E594: Need at least %d columns\"));\n#ifdef FEAT_LINEBREAK\nEXTERN char e_showbreak_contains_unprintable_or_wide_character[]\n\tINIT(= N_(\"E595: 'showbreak' contains unprintable or wide character\"));\n#endif\n#ifdef FEAT_GUI\nEXTERN char e_invalid_fonts[]\n\tINIT(= N_(\"E596: Invalid font(s)\"));\n# ifdef FEAT_XFONTSET\nEXTERN char e_cant_select_fontset[]\n\tINIT(= N_(\"E597: Can't select fontset\"));\nEXTERN char e_invalid_fontset[]\n\tINIT(= N_(\"E598: Invalid fontset\"));\n# endif\n#endif\n#if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)\nEXTERN char e_value_of_imactivatekey_is_invalid[]\n\tINIT(= N_(\"E599: Value of 'imactivatekey' is invalid\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_missing_endtry[]\n\tINIT(= N_(\"E600: Missing :endtry\"));\nEXTERN char e_try_nesting_too_deep[]\n\tINIT(= N_(\"E601: :try nesting too deep\"));\nEXTERN char e_endtry_without_try[]\n\tINIT(= N_(\"E602: :endtry without :try\"));\nEXTERN char e_catch_without_try[]\n\tINIT(= N_(\"E603: :catch without :try\"));\nEXTERN char e_catch_after_finally[]\n\tINIT(= N_(\"E604: :catch after :finally\"));\nEXTERN char e_exception_not_caught_str[]\n\tINIT(= N_(\"E605: Exception not caught: %s\"));\nEXTERN char e_finally_without_try[]\n\tINIT(= N_(\"E606: :finally without :try\"));\nEXTERN char e_multiple_finally[]\n\tINIT(= N_(\"E607: Multiple :finally\"));\nEXTERN char e_cannot_throw_exceptions_with_vim_prefix[]\n\tINIT(= N_(\"E608: Cannot :throw exceptions with 'Vim' prefix\"));\n#endif\n#ifdef FEAT_CSCOPE\nEXTERN char e_cscope_error_str[]\n\tINIT(= N_(\"E609: Cscope error: %s\"));\n#endif\nEXTERN char e_no_argument_to_delete[]\n\tINIT(= N_(\"E610: No argument to delete\"));\n#ifdef FEAT_EVAL\nEXTERN char e_using_special_as_number[]\n\tINIT(= N_(\"E611: Using a Special as a Number\"));\n#endif\n#ifdef FEAT_SIGNS\nEXTERN char e_too_many_signs_defined[]\n\tINIT(= N_(\"E612: Too many signs defined\"));\n#endif\n#if defined(MSWIN) && defined(FEAT_PRINTER)\nEXTERN char e_unknown_printer_font_str[]\n\tINIT(= N_(\"E613: Unknown printer font: %s\"));\n#endif\nEXTERN char e_class_required[]\n\tINIT(= N_(\"E614: Class required\"));\n// E615 unused\nEXTERN char e_object_required_for_argument_nr[]\n\tINIT(= N_(\"E616: Object required for argument %d\"));\n#ifdef FEAT_GUI_GTK\nEXTERN char e_cannot_be_changed_in_gtk_GUI[]\n\tINIT(= N_(\"E617: Cannot be changed in the GTK GUI\"));\n#endif\n#ifdef FEAT_POSTSCRIPT\nEXTERN char e_file_str_is_not_postscript_resource_file[]\n\tINIT(= N_(\"E618: File \\\"%s\\\" is not a PostScript resource file\"));\nEXTERN char e_file_str_is_not_supported_postscript_resource_file[]\n\tINIT(= N_(\"E619: File \\\"%s\\\" is not a supported PostScript resource file\"));\nEXTERN char e_unable_to_convert_to_print_encoding_str[]\n\tINIT(= N_(\"E620: Unable to convert to print encoding \\\"%s\\\"\"));\nEXTERN char e_str_resource_file_has_wrong_version[]\n\tINIT(= N_(\"E621: \\\"%s\\\" resource file has wrong version\"));\n#endif\n#ifdef FEAT_CSCOPE\nEXTERN char e_could_not_fork_for_cscope[]\n\tINIT(= N_(\"E622: Could not fork for cscope\"));\n# ifndef UNIX\nEXTERN char e_could_not_spawn_cscope_process[]\n\tINIT(= N_(\"E623: Could not spawn cscope process\"));\n# endif\n#endif\n#if defined(FEAT_PRINTER) && defined(FEAT_POSTSCRIPT)\nEXTERN char e_cant_open_file_str_3[]\n\tINIT(= N_(\"E624: Can't open file \\\"%s\\\"\"));\n#endif\n#if defined(FEAT_CSCOPE) && !defined(UNIX)\nEXTERN char e_cannot_open_cscope_database_str[]\n\tINIT(= N_(\"E625: Cannot open cscope database: %s\"));\nEXTERN char e_cannot_get_cscope_database_information[]\n\tINIT(= N_(\"E626: Cannot get cscope database information\"));\n#endif\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_missing_colon_str[]\n\tINIT(= N_(\"E627: Missing colon: %s\"));\nEXTERN char e_missing_bang_or_slash_in_str[]\n\tINIT(= N_(\"E628: Missing ! or / in: %s\"));\n#ifdef NBDEBUG\nEXTERN char e_bad_return_from_nb_do_cmd[]\n\tINIT(= \"E629: Bad return from nb_do_cmd\");\n#endif\n#endif\n#ifdef FEAT_JOB_CHANNEL\nEXTERN char e_str_write_while_not_connected[]\n\tINIT(= N_(\"E630: %s(): Write while not connected\"));\nEXTERN char e_str_write_failed[]\n\tINIT(= N_(\"E631: %s(): Write failed\"));\n#endif\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_invalid_buffer_identifier_in_getlength[]\n\tINIT(= N_(\"E632: Invalid buffer identifier in getLength\"));\nEXTERN char e_invalid_buffer_identifier_in_gettext[]\n\tINIT(= N_(\"E633: Invalid buffer identifier in getText\"));\nEXTERN char e_invalid_buffer_identifier_in_remove[]\n\tINIT(= N_(\"E634: Invalid buffer identifier in remove\"));\nEXTERN char e_invalid_buffer_identifier_in_insert[]\n\tINIT(= N_(\"E635: Invalid buffer identifier in insert\"));\nEXTERN char e_invalid_buffer_identifier_in_create[]\n\tINIT(= N_(\"E636: Invalid buffer identifier in create\"));\nEXTERN char e_invalid_buffer_identifier_in_startdocumentlisten[]\n\tINIT(= N_(\"E637: Invalid buffer identifier in startDocumentListen\"));\nEXTERN char e_invalid_buffer_identifier_in_stopdocumentlisten[]\n\tINIT(= N_(\"E638: Invalid buffer identifier in stopDocumentListen\"));\nEXTERN char e_invalid_buffer_identifier_in_settitle[]\n\tINIT(= N_(\"E639: Invalid buffer identifier in setTitle\"));\nEXTERN char e_invalid_buffer_identifier_in_initdone[]\n\tINIT(= N_(\"E640: Invalid buffer identifier in initDone\"));\nEXTERN char e_invalid_buffer_identifier_in_setbuffernumber[]\n\tINIT(= N_(\"E641: Invalid buffer identifier in setBufferNumber\"));\nEXTERN char e_file_str_not_found_in_setbuffernumber[]\n\tINIT(= N_(\"E642: File %s not found in setBufferNumber\"));\nEXTERN char e_invalid_buffer_identifier_in_setfullname[]\n\tINIT(= N_(\"E643: Invalid buffer identifier in setFullName\"));\nEXTERN char e_invalid_buffer_identifier_in_editfile[]\n\tINIT(= N_(\"E644: Invalid buffer identifier in editFile\"));\nEXTERN char e_invalid_buffer_identifier_in_setvisible[]\n\tINIT(= N_(\"E645: Invalid buffer identifier in setVisible\"));\nEXTERN char e_invalid_buffer_identifier_in_setmodified[]\n\tINIT(= N_(\"E646: Invalid buffer identifier in setModified\"));\nEXTERN char e_invalid_buffer_identifier_in_setdot[]\n\tINIT(= N_(\"E647: Invalid buffer identifier in setDot\"));\nEXTERN char e_invalid_buffer_identifier_in_close[]\n\tINIT(= N_(\"E648: Invalid buffer identifier in close\"));\nEXTERN char e_invalid_buffer_identifier_in_close_2[]\n\tINIT(= N_(\"E649: Invalid buffer identifier in close\"));\nEXTERN char e_invalid_buffer_identifier_in_defineannotype[]\n\tINIT(= N_(\"E650: Invalid buffer identifier in defineAnnoType\"));\nEXTERN char e_invalid_buffer_identifier_in_addanno[]\n\tINIT(= N_(\"E651: Invalid buffer identifier in addAnno\"));\nEXTERN char e_invalid_buffer_identifier_in_getanno[]\n\tINIT(= N_(\"E652: Invalid buffer identifier in getAnno\"));\n#endif\n// E653 unused\nEXTERN char e_missing_delimiter_after_search_pattern_str[]\n\tINIT(= N_(\"E654: Missing delimiter after search pattern: %s\"));\n#ifdef FEAT_EVAL\nEXTERN char e_too_many_symbolic_links_cycle[]\n\tINIT(= N_(\"E655: Too many symbolic links (cycle?)\"));\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t// E656\nEXTERN char e_netbeans_disallows_writes_of_unmodified_buffers[]\n\tINIT(= N_(\"NetBeans disallows writes of unmodified buffers\"));\n\t// E657\nEXTERN char e_partial_writes_disallowed_for_netbeans_buffers[]\n\tINIT(= N_(\"Partial writes disallowed for NetBeans buffers\"));\nEXTERN char e_netbeans_connection_lost_for_buffer_nr[]\n\tINIT(= N_(\"E658: NetBeans connection lost for buffer %d\"));\n#endif\n#ifdef FEAT_PYTHON\nEXTERN char e_cannot_invoke_python_recursively[]\n\tINIT(= N_(\"E659: Cannot invoke Python recursively\"));\n#endif\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_cannot_open_netbeans_connection_info_file[]\n\tINIT(= \"E660: Cannot open NetBeans connection info file\");\n#endif\n#ifdef FEAT_MULTI_LANG\nEXTERN char e_sorry_no_str_help_for_str[]\n\tINIT(= N_(\"E661: Sorry, no '%s' help for %s\"));\n#endif\nEXTERN char e_at_start_of_changelist[]\n\tINIT(= N_(\"E662: At start of changelist\"));\nEXTERN char e_at_end_of_changelist[]\n\tINIT(= N_(\"E663: At end of changelist\"));\nEXTERN char e_changelist_is_empty[]\n\tINIT(= N_(\"E664: Changelist is empty\"));\n#ifdef FEAT_GUI\nEXTERN char e_cannot_start_gui_no_valid_font_found[]\n\tINIT(= N_(\"E665: Cannot start GUI, no valid font found\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_compiler_not_supported_str[]\n\tINIT(= N_(\"E666: Compiler not supported: %s\"));\n#endif\n#ifdef HAVE_FSYNC\nEXTERN char e_fsync_failed[]\n\tINIT(= N_(\"E667: Fsync failed\"));\n#endif\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_wrong_access_mode_for_netbeans_connection_info_file_str[]\n\tINIT(= N_(\"E668: Wrong access mode for NetBeans connection info file: \\\"%s\\\"\"));\n#endif\nEXTERN char e_unprintable_character_in_group_name[]\n\tINIT(= N_(\"E669: Unprintable character in group name\"));\nEXTERN char e_mix_of_help_file_encodings_within_language_str[]\n\tINIT(= N_(\"E670: Mix of help file encodings within a language: %s\"));\n#ifdef FEAT_GUI_MSWIN\nEXTERN char e_cannot_find_window_title_str[]\n\tINIT(= N_(\"E671: Cannot find window title \\\"%s\\\"\"));\nEXTERN char e_unable_to_open_window_inside_mdi_application[]\n\tINIT(= N_(\"E672: Unable to open window inside MDI application\"));\n#endif\n#if defined(FEAT_PRINTER) && defined(FEAT_POSTSCRIPT)\nEXTERN char e_incompatible_multi_byte_encoding_and_character_set[]\n\tINIT(= N_(\"E673: Incompatible multi-byte encoding and character set\"));\nEXTERN char e_printmbcharset_cannot_be_empty_with_multi_byte_encoding[]\n\tINIT(= N_(\"E674: printmbcharset cannot be empty with multi-byte encoding.\"));\nEXTERN char e_no_default_font_specified_for_multi_byte_printing[]\n\tINIT(= N_(\"E675: No default font specified for multi-byte printing.\"));\n#endif\nEXTERN char e_no_matching_autocommands_for_buftype_str_buffer[]\n\tINIT(= N_(\"E676: No matching autocommands for buftype=%s buffer\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_error_writing_temp_file[]\n\tINIT(= N_(\"E677: Error writing temp file\"));\n#endif\nEXTERN char e_invalid_character_after_str_2[]\n\tINIT(= N_(\"E678: Invalid character after %s%%[dxouU]\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_recursive_loop_loading_syncolor_vim[]\n\tINIT(= N_(\"E679: Recursive loop loading syncolor.vim\"));\n#endif\nEXTERN char e_buffer_nr_invalid_buffer_number[]\n\tINIT(= N_(\"E680: <buffer=%d>: invalid buffer number\"));\n#ifdef FEAT_QUICKFIX\nEXTERN char e_buffer_is_not_loaded[]\n\tINIT(= N_(\"E681: Buffer is not loaded\"));\nEXTERN char e_invalid_search_pattern_or_delimiter[]\n\tINIT(= N_(\"E682: Invalid search pattern or delimiter\"));\nEXTERN char e_file_name_missing_or_invalid_pattern[]\n\tINIT(= N_(\"E683: File name missing or invalid pattern\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_list_index_out_of_range_nr[]\n\tINIT(= N_(\"E684: List index out of range: %ld\"));\n#endif\nEXTERN char e_internal_error_str[]\n\tINIT(= N_(\"E685: Internal error: %s\"));\n#ifdef FEAT_EVAL\nEXTERN char e_argument_of_str_must_be_list[]\n\tINIT(= N_(\"E686: Argument of %s must be a List\"));\nEXTERN char e_less_targets_than_list_items[]\n\tINIT(= N_(\"E687: Less targets than List items\"));\nEXTERN char e_more_targets_than_list_items[]\n\tINIT(= N_(\"E688: More targets than List items\"));\nEXTERN char e_index_not_allowed_after_str_str[]\n\tINIT(= N_(\"E689: Index not allowed after a %s: %s\"));\nEXTERN char e_missing_in_after_for[]\n\tINIT(= N_(\"E690: Missing \\\"in\\\" after :for\"));\nEXTERN char e_can_only_compare_list_with_list[]\n\tINIT(= N_(\"E691: Can only compare List with List\"));\nEXTERN char e_invalid_operation_for_list[]\n\tINIT(= N_(\"E692: Invalid operation for List\"));\nEXTERN char e_list_or_class_required_for_argument_nr[]\n\tINIT(= N_(\"E693: List or Class required for argument %d\"));\nEXTERN char e_invalid_operation_for_funcrefs[]\n\tINIT(= N_(\"E694: Invalid operation for Funcrefs\"));\nEXTERN char e_cannot_index_a_funcref[]\n\tINIT(= N_(\"E695: Cannot index a Funcref\"));\nEXTERN char e_missing_comma_in_list_str[]\n\tINIT(= N_(\"E696: Missing comma in List: %s\"));\nEXTERN char e_missing_end_of_list_rsb_str[]\n\tINIT(= N_(\"E697: Missing end of List ']': %s\"));\nEXTERN char e_variable_nested_too_deep_for_making_copy[]\n\tINIT(= N_(\"E698: Variable nested too deep for making a copy\"));\nEXTERN char e_too_many_arguments[]\n\tINIT(= N_(\"E699: Too many arguments\"));\nEXTERN char e_unknown_function_str_2[]\n\tINIT(= N_(\"E700: Unknown function: %s\"));\nEXTERN char e_invalid_type_for_len[]\n\tINIT(= N_(\"E701: Invalid type for len()\"));\nEXTERN char e_sort_compare_function_failed[]\n\tINIT(= N_(\"E702: Sort compare function failed\"));\nEXTERN char e_using_funcref_as_number[]\n\tINIT(= N_(\"E703: Using a Funcref as a Number\"));\nEXTERN char e_funcref_variable_name_must_start_with_capital_str[]\n\tINIT(= N_(\"E704: Funcref variable name must start with a capital: %s\"));\nEXTERN char e_variable_name_conflicts_with_existing_function_str[]\n\tINIT(= N_(\"E705: Variable name conflicts with existing function: %s\"));\nEXTERN char e_argument_of_str_must_be_list_string_or_dictionary[]\n\tINIT(= N_(\"E706: Argument of %s must be a List, String or Dictionary\"));\nEXTERN char e_function_name_conflicts_with_variable_str[]\n\tINIT(= N_(\"E707: Function name conflicts with variable: %s\"));\nEXTERN char e_slice_must_come_last[]\n\tINIT(= N_(\"E708: [:] must come last\"));\nEXTERN char e_slice_requires_list_or_blob_value[]\n\tINIT(= N_(\"E709: [:] requires a List or Blob value\"));\nEXTERN char e_list_value_has_more_items_than_targets[]\n\tINIT(= N_(\"E710: List value has more items than targets\"));\nEXTERN char e_list_value_does_not_have_enough_items[]\n\tINIT(= N_(\"E711: List value does not have enough items\"));\nEXTERN char e_argument_of_str_must_be_list_or_dictionary[]\n\tINIT(= N_(\"E712: Argument of %s must be a List or Dictionary\"));\nEXTERN char e_cannot_use_empty_key_for_dictionary[]\n\tINIT(= N_(\"E713: Cannot use empty key for Dictionary\"));\nEXTERN char e_list_required[]\n\tINIT(= N_(\"E714: List required\"));\nEXTERN char e_dictionary_required[]\n\tINIT(= N_(\"E715: Dictionary required\"));\nEXTERN char e_key_not_present_in_dictionary_str[]\n\tINIT(= N_(\"E716: Key not present in Dictionary: \\\"%s\\\"\"));\nEXTERN char e_dictionary_entry_already_exists[]\n\tINIT(= N_(\"E717: Dictionary entry already exists\"));\nEXTERN char e_funcref_required[]\n\tINIT(= N_(\"E718: Funcref required\"));\nEXTERN char e_cannot_slice_dictionary[]\n\tINIT(= N_(\"E719: Cannot slice a Dictionary\"));\nEXTERN char e_missing_colon_in_dictionary_str[]\n\tINIT(= N_(\"E720: Missing colon in Dictionary: %s\"));\nEXTERN char e_duplicate_key_in_dictionary_str[]\n\tINIT(= N_(\"E721: Duplicate key in Dictionary: \\\"%s\\\"\"));\nEXTERN char e_missing_comma_in_dictionary_str[]\n\tINIT(= N_(\"E722: Missing comma in Dictionary: %s\"));\nEXTERN char e_missing_dict_end_str[]\n\tINIT(= N_(\"E723: Missing end of Dictionary '}': %s\"));\nEXTERN char e_variable_nested_too_deep_for_displaying[]\n\tINIT(= N_(\"E724: Variable nested too deep for displaying\"));\nEXTERN char e_calling_dict_function_without_dictionary_str[]\n\tINIT(= N_(\"E725: Calling dict function without Dictionary: %s\"));\nEXTERN char e_stride_is_zero[]\n\tINIT(= N_(\"E726: Stride is zero\"));\nEXTERN char e_start_past_end[]\n\tINIT(= N_(\"E727: Start past end\"));\nEXTERN char e_using_dictionary_as_number[]\n\tINIT(= N_(\"E728: Using a Dictionary as a Number\"));\nEXTERN char e_using_funcref_as_string[]\n\tINIT(= N_(\"E729: Using a Funcref as a String\"));\nEXTERN char e_using_list_as_string[]\n\tINIT(= N_(\"E730: Using a List as a String\"));\nEXTERN char e_using_dictionary_as_string[]\n\tINIT(= N_(\"E731: Using a Dictionary as a String\"));\nEXTERN char e_using_endfor_with_while[]\n\tINIT(= N_(\"E732: Using :endfor with :while\"));\nEXTERN char e_using_endwhile_with_for[]\n\tINIT(= N_(\"E733: Using :endwhile with :for\"));\nEXTERN char e_wrong_variable_type_for_str_equal[]\n\tINIT(= N_(\"E734: Wrong variable type for %s=\"));\nEXTERN char e_can_only_compare_dictionary_with_dictionary[]\n\tINIT(= N_(\"E735: Can only compare Dictionary with Dictionary\"));\nEXTERN char e_invalid_operation_for_dictionary[]\n\tINIT(= N_(\"E736: Invalid operation for Dictionary\"));\nEXTERN char e_key_already_exists_str[]\n\tINIT(= N_(\"E737: Key already exists: %s\"));\nEXTERN char e_cant_list_variables_for_str[]\n\tINIT(= N_(\"E738: Can't list variables for %s\"));\nEXTERN char e_cannot_create_directory_str[]\n\tINIT(= N_(\"E739: Cannot create directory: %s\"));\nEXTERN char e_too_many_arguments_for_function_str_2[]\n\tINIT(= N_(\"E740: Too many arguments for function %s\"));\nEXTERN char e_value_is_locked[]\n\tINIT(= N_(\"E741: Value is locked\"));\nEXTERN char e_value_is_locked_str[]\n\tINIT(= N_(\"E741: Value is locked: %s\"));\nEXTERN char e_cannot_change_value[]\n\tINIT(= N_(\"E742: Cannot change value\"));\nEXTERN char e_cannot_change_value_of_str[]\n\tINIT(= N_(\"E742: Cannot change value of %s\"));\nEXTERN char e_variable_nested_too_deep_for_unlock[]\n\tINIT(= N_(\"E743: Variable nested too deep for (un)lock\"));\n#endif\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_netbeans_does_not_allow_changes_in_read_only_files[]\n\tINIT(= N_(\"E744: NetBeans does not allow changes in read-only files\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_using_list_as_number[]\n\tINIT(= N_(\"E745: Using a List as a Number\"));\nEXTERN char e_function_name_does_not_match_script_file_name_str[]\n\tINIT(= N_(\"E746: Function name does not match script file name: %s\"));\n#endif\nEXTERN char e_cannot_change_directory_buffer_is_modified_add_bang_to_override[]\n\tINIT(= N_(\"E747: Cannot change directory, buffer is modified (add ! to override)\"));\nEXTERN char e_no_previously_used_register[]\n\tINIT(= N_(\"E748: No previously used register\"));\nEXTERN char e_empty_buffer[]\n\tINIT(= N_(\"E749: Empty buffer\"));\n#ifdef FEAT_PROFILE\nEXTERN char e_first_use_profile_start_fname[]\n\tINIT(= N_(\"E750: First use \\\":profile start {fname}\\\"\"));\n#endif\n#ifdef FEAT_SPELL\nEXTERN char e_output_file_name_must_not_have_region_name[]\n\tINIT(= N_(\"E751: Output file name must not have region name\"));\nEXTERN char e_no_previous_spell_replacement[]\n\tINIT(= N_(\"E752: No previous spell replacement\"));\nEXTERN char e_not_found_str[]\n\tINIT(= N_(\"E753: Not found: %s\"));\nEXTERN char e_only_up_to_nr_regions_supported[]\n\tINIT(= N_(\"E754: Only up to %d regions supported\"));\nEXTERN char e_invalid_region_in_str[]\n\tINIT(= N_(\"E755: Invalid region in %s\"));\nEXTERN char e_spell_checking_is_not_possible[]\n\tINIT(= N_(\"E756: Spell checking is not possible\"));\nEXTERN char e_this_does_not_look_like_spell_file[]\n\tINIT(= N_(\"E757: This does not look like a spell file\"));\nEXTERN char e_truncated_spell_file[]\n\tINIT(= N_(\"E758: Truncated spell file\"));\nEXTERN char e_format_error_in_spell_file[]\n\tINIT(= N_(\"E759: Format error in spell file\"));\nEXTERN char e_no_word_count_in_str[]\n\tINIT(= N_(\"E760: No word count in %s\"));\nEXTERN char e_format_error_in_affix_file_fol_low_or_upp[]\n\tINIT(= N_(\"E761: Format error in affix file FOL, LOW or UPP\"));\nEXTERN char e_character_in_fol_low_or_upp_is_out_of_range[]\n\tINIT(= N_(\"E762: Character in FOL, LOW or UPP is out of range\"));\nEXTERN char e_word_characters_differ_between_spell_files[]\n\tINIT(= N_(\"E763: Word characters differ between spell files\"));\n#endif\n#if defined(FEAT_SYN_HL) || defined(FEAT_COMPL_FUNC) || defined(FEAT_SPELL)\nEXTERN char e_option_str_is_not_set[]\n\tINIT(= N_(\"E764: Option '%s' is not set\"));\n#endif\n#ifdef FEAT_SPELL\nEXTERN char e_spellfile_does_not_have_nr_entries[]\n\tINIT(= N_(\"E765: 'spellfile' does not have %d entries\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_insufficient_arguments_for_printf[]\n\tINIT(= N_(\"E766: Insufficient arguments for printf()\"));\n#endif\nEXTERN char e_too_many_arguments_to_printf[]\n\tINIT(= N_(\"E767: Too many arguments for printf()\"));\nEXTERN char e_swap_file_exists_str_silent_overrides[]\n\tINIT(= N_(\"E768: Swap file exists: %s (:silent! overrides)\"));\nEXTERN char e_missing_rsb_after_str_lsb[]\n\tINIT(= N_(\"E769: Missing ] after %s[\"));\n#ifdef FEAT_SPELL\nEXTERN char e_unsupported_section_in_spell_file[]\n\tINIT(= N_(\"E770: Unsupported section in spell file\"));\nEXTERN char e_old_spell_file_needs_to_be_updated[]\n\tINIT(= N_(\"E771: Old spell file, needs to be updated\"));\nEXTERN char e_spell_file_is_for_newer_version_of_vim[]\n\tINIT(= N_(\"E772: Spell file is for newer version of Vim\"));\n#endif\nEXTERN char e_symlink_loop_for_str[]\n\tINIT(= N_(\"E773: Symlink loop for \\\"%s\\\"\"));\n#ifdef FEAT_EVAL\nEXTERN char e_operatorfunc_is_empty[]\n\tINIT(= N_(\"E774: 'operatorfunc' is empty\"));\n#else\nEXTERN char e_eval_feature_not_available[]\n\tINIT(= N_(\"E775: Eval feature not available\"));\n#endif\n#ifdef FEAT_QUICKFIX\nEXTERN char e_no_location_list[]\n\tINIT(= N_(\"E776: No location list\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_string_or_list_expected[]\n\tINIT(= N_(\"E777: String or List expected\"));\n#endif\n#ifdef FEAT_SPELL\nEXTERN char e_this_does_not_look_like_sug_file_str[]\n\tINIT(= N_(\"E778: This does not look like a .sug file: %s\"));\nEXTERN char e_old_sug_file_needs_to_be_updated_str[]\n\tINIT(= N_(\"E779: Old .sug file, needs to be updated: %s\"));\nEXTERN char e_sug_file_is_for_newer_version_of_vim_str[]\n\tINIT(= N_(\"E780: .sug file is for newer version of Vim: %s\"));\nEXTERN char e_sug_file_doesnt_match_spl_file_str[]\n\tINIT(= N_(\"E781: .sug file doesn't match .spl file: %s\"));\nEXTERN char e_error_while_reading_sug_file_str[]\n\tINIT(= N_(\"E782: Error while reading .sug file: %s\"));\nEXTERN char e_duplicate_char_in_map_entry[]\n\tINIT(= N_(\"E783: Duplicate char in MAP entry\"));\n#endif\nEXTERN char e_cannot_close_last_tab_page[]\n\tINIT(= N_(\"E784: Cannot close last tab page\"));\n#ifdef FEAT_EVAL\n# ifdef FEAT_COMPL_FUNC\nEXTERN char e_complete_can_only_be_used_in_insert_mode[]\n\tINIT(= N_(\"E785: complete() can only be used in Insert mode\"));\n# endif\nEXTERN char e_range_not_allowed[]\n\tINIT(= N_(\"E786: Range not allowed\"));\n#endif\n#ifdef FEAT_DIFF\nEXTERN char e_buffer_changed_unexpectedly[]\n\tINIT(= N_(\"E787: Buffer changed unexpectedly\"));\n#endif\nEXTERN char e_not_allowed_to_edit_another_buffer_now[]\n\tINIT(= N_(\"E788: Not allowed to edit another buffer now\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_error_missing_rsb_str[]\n\tINIT(= N_(\"E789: Missing ']': %s\"));\n#endif\nEXTERN char e_undojoin_is_not_allowed_after_undo[]\n\tINIT(= N_(\"E790: undojoin is not allowed after undo\"));\n#ifdef FEAT_KEYMAP\nEXTERN char e_empty_keymap_entry[]\n\tINIT(= N_(\"E791: Empty keymap entry\"));\n#endif\n#ifdef FEAT_MENU\nEXTERN char e_empty_menu_name[]\n\tINIT(= N_(\"E792: Empty menu name\"));\n#endif\n#ifdef FEAT_DIFF\nEXTERN char e_no_other_buffer_in_diff_mode_is_modifiable[]\n\tINIT(= N_(\"E793: No other buffer in diff mode is modifiable\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_set_variable_in_sandbox[]\n\tINIT(= N_(\"E794: Cannot set variable in the sandbox\"));\nEXTERN char e_cannot_set_variable_in_sandbox_str[]\n\tINIT(= N_(\"E794: Cannot set variable in the sandbox: \\\"%s\\\"\"));\nEXTERN char e_cannot_delete_variable[]\n\tINIT(= N_(\"E795: Cannot delete variable\"));\nEXTERN char e_cannot_delete_variable_str[]\n\tINIT(= N_(\"E795: Cannot delete variable %s\"));\n#endif\n#ifdef MSWIN\n\t// E796\nEXTERN char e_writing_to_device_disabled_with_opendevice_option[]\n\tINIT(= N_(\"writing to device disabled with 'opendevice' option\"));\n#endif\n#ifdef FEAT_SPELL\nEXTERN char e_spellfilemising_autocommand_deleted_buffer[]\n\tINIT(= N_(\"E797: SpellFileMissing autocommand deleted buffer\"));\n#endif\n#ifdef FEAT_SEARCH_EXTRA\nEXTERN char e_id_is_reserved_for_match_nr[]\n\tINIT(= N_(\"E798: ID is reserved for \\\":match\\\": %d\"));\nEXTERN char e_invalid_id_nr_must_be_greater_than_or_equal_to_one_1[]\n\tINIT(= N_(\"E799: Invalid ID: %d (must be greater than or equal to 1)\"));\n#endif\n#ifndef FEAT_ARABIC\nEXTERN char e_arabic_cannot_be_used_not_enabled_at_compile_time[]\n\tINIT(= N_(\"E800: Arabic cannot be used: Not enabled at compile time\\n\"));\n#endif\n#ifdef FEAT_SEARCH_EXTRA\nEXTERN char e_id_already_taken_nr[]\n\tINIT(= N_(\"E801: ID already taken: %d\"));\nEXTERN char e_invalid_id_nr_must_be_greater_than_or_equal_to_one_2[]\n\tINIT(= N_(\"E802: Invalid ID: %d (must be greater than or equal to 1)\"));\nEXTERN char e_id_not_found_nr[]\n\tINIT(= N_(\"E803: ID not found: %d\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_use_percent_with_float[]\n\t// xgettext:no-c-format\n\tINIT(= N_(\"E804: Cannot use '%' with Float\"));\nEXTERN char e_using_float_as_number[]\n\tINIT(= N_(\"E805: Using a Float as a Number\"));\nEXTERN char e_using_float_as_string[]\n\tINIT(= N_(\"E806: Using a Float as a String\"));\nEXTERN char e_expected_float_argument_for_printf[]\n\tINIT(= N_(\"E807: Expected Float argument for printf()\"));\nEXTERN char e_number_or_float_required[]\n\tINIT(= N_(\"E808: Number or Float required\"));\n#endif\n#ifndef FEAT_EVAL\nEXTERN char e_hashsmall_is_not_available_without_the_eval_feature[]\n\tINIT(= N_(\"E809: #< is not available without the +eval feature\"));\n#endif\n#ifdef FEAT_DIFF\nEXTERN char e_cannot_read_or_write_temp_files[]\n\tINIT(= N_(\"E810: Cannot read or write temp files\"));\n#endif\nEXTERN char e_not_allowed_to_change_buffer_information_now[]\n\tINIT(= N_(\"E811: Not allowed to change buffer information now\"));\nEXTERN char e_autocommands_changed_buffer_or_buffer_name[]\n\tINIT(= N_(\"E812: Autocommands changed buffer or buffer name\"));\nEXTERN char e_cannot_close_autocmd_or_popup_window[]\n\tINIT(= N_(\"E813: Cannot close autocmd or popup window\"));\nEXTERN char e_cannot_close_window_only_autocmd_window_would_remain[]\n\tINIT(= N_(\"E814: Cannot close window, only autocmd window would remain\"));\n#ifdef FEAT_MZSCHEME\nEXTERN char e_sorry_this_command_is_disabled_the_mzscheme_libraries_could_not_be_loaded[]\n\tINIT(= N_(\"E815: Sorry, this command is disabled, the MzScheme libraries could not be loaded.\"));\n#endif\n#ifdef FEAT_DIFF\nEXTERN char e_cannot_read_patch_output[]\n\tINIT(= N_(\"E816: Cannot read patch output\"));\n#endif\n#ifdef FEAT_CRYPT\nEXTERN char e_blowfish_big_little_endian_use_wrong[]\n\tINIT(= N_(\"E817: Blowfish big/little endian use wrong\"));\nEXTERN char e_sha256_test_failed[]\n\tINIT(= N_(\"E818: sha256 test failed\"));\nEXTERN char e_blowfish_test_failed[]\n\tINIT(= N_(\"E819: Blowfish test failed\"));\nEXTERN char e_sizeof_uint32_isnot_four[]\n\tINIT(= N_(\"E820: sizeof(uint32_t) != 4\"));\nEXTERN char e_file_is_encrypted_with_unknown_method[]\n\tINIT(= N_(\"E821: File is encrypted with unknown method\"));\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\nEXTERN char e_cannot_open_undo_file_for_reading_str[]\n\tINIT(= N_(\"E822: Cannot open undo file for reading: %s\"));\nEXTERN char e_not_an_undo_file_str[]\n\tINIT(= N_(\"E823: Not an undo file: %s\"));\nEXTERN char e_incompatible_undo_file_str[]\n\tINIT(= N_(\"E824: Incompatible undo file: %s\"));\nEXTERN char e_corrupted_undo_file_str_str[]\n\tINIT(= N_(\"E825: Corrupted undo file (%s): %s\"));\n# ifdef FEAT_CRYPT\nEXTERN char e_undo_file_decryption_failed[]\n\tINIT(= N_(\"E826: Undo file decryption failed: %s\"));\n# else\nEXTERN char e_undo_file_is_encrypted_str[]\n\tINIT(= N_(\"E827: Undo file is encrypted: %s\"));\n# endif\nEXTERN char e_cannot_open_undo_file_for_writing_str[]\n\tINIT(= N_(\"E828: Cannot open undo file for writing: %s\"));\nEXTERN char e_write_error_in_undo_file_str[]\n\tINIT(= N_(\"E829: Write error in undo file: %s\"));\n#endif\nEXTERN char e_undo_number_nr_not_found[]\n\tINIT(= N_(\"E830: Undo number %ld not found\"));\n#ifdef FEAT_CRYPT\nEXTERN char e_bf_key_init_called_with_empty_password[]\n\tINIT(= \"E831: bf_key_init() called with empty password\");\n# ifdef FEAT_PERSISTENT_UNDO\nEXTERN char e_non_encrypted_file_has_encrypted_undo_file_str[]\n\tINIT(= N_(\"E832: Non-encrypted file has encrypted undo file: %s\"));\n# endif\n#else\nEXTERN char e_str_is_encrypted_and_this_version_of_vim_does_not_support_encryption[]\n\tINIT(= N_(\"E833: %s is encrypted and this version of Vim does not support encryption\"));\n#endif\nEXTERN char e_conflicts_with_value_of_listchars[]\n\tINIT(= N_(\"E834: Conflicts with value of 'listchars'\"));\nEXTERN char e_conflicts_with_value_of_fillchars[]\n\tINIT(= N_(\"E835: Conflicts with value of 'fillchars'\"));\n#ifdef DYNAMIC_PYTHON\nEXTERN char e_this_vim_cannot_execute_python_after_using_py3[]\n\tINIT(= N_(\"E836: This Vim cannot execute :python after using :py3\"));\nEXTERN char e_this_vim_cannot_execute_py3_after_using_python[]\n\tINIT(= N_(\"E837: This Vim cannot execute :py3 after using :python\"));\n#endif\n#if defined(FEAT_NETBEANS_INTG) && defined(FEAT_GUI)\nEXTERN char e_netbeans_is_not_supported_with_this_GUI[]\n\tINIT(= N_(\"E838: NetBeans is not supported with this GUI\"));\n#endif\n// E839 unused\n# ifdef FEAT_COMPL_FUNC\nEXTERN char e_complete_function_deleted_text[]\n\tINIT(= N_(\"E840: Completion function deleted text\"));\n# endif\nEXTERN char e_reserved_name_cannot_be_used_for_user_defined_command[]\n\tINIT(= N_(\"E841: Reserved name, cannot be used for user defined command\"));\nEXTERN char e_no_line_number_to_use_for_slnum[]\n\tINIT(= N_(\"E842: No line number to use for \\\"<slnum>\\\"\"));\n#ifdef FEAT_CRYPT\nEXTERN char e_error_while_updating_swap_file_crypt[]\n\tINIT(= N_(\"E843: Error while updating swap file crypt\"));\n#endif\n#ifdef FEAT_CONCEAL\nEXTERN char e_invalid_cchar_value[]\n\tINIT(= N_(\"E844: Invalid cchar value\"));\n#endif\n#ifdef FEAT_SPELL\nEXTERN char e_insufficient_memory_word_list_will_be_incomplete[]\n\tINIT(= N_(\"E845: Insufficient memory, word list will be incomplete\"));\n#endif\nEXTERN char e_key_code_not_set[]\n\tINIT(= N_(\"E846: Key code not set\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_too_many_syntax_includes[]\n\tINIT(= N_(\"E847: Too many syntax includes\"));\nEXTERN char e_too_many_syntax_clusters[]\n\tINIT(= N_(\"E848: Too many syntax clusters\"));\n#endif\nEXTERN char e_too_many_highlight_and_syntax_groups[]\n\tINIT(= N_(\"E849: Too many highlight and syntax groups\"));\n#ifndef FEAT_CLIPBOARD\nEXTERN char e_invalid_register_name[]\n\tINIT(= N_(\"E850: Invalid register name\"));\n#endif\n#ifdef FEAT_GUI\nEXTERN char e_failed_to_create_new_process_for_GUI[]\n\tINIT(= N_(\"E851: Failed to create a new process for the GUI\"));\nEXTERN char e_the_child_process_failed_to_start_GUI[]\n\tINIT(= N_(\"E852: The child process failed to start the GUI\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_duplicate_argument_name_str[]\n\tINIT(= N_(\"E853: Duplicate argument name: %s\"));\n#endif\nEXTERN char e_path_too_long_for_completion[]\n\tINIT(= N_(\"E854: Path too long for completion\"));\nEXTERN char e_autocommands_caused_command_to_abort[]\n\tINIT(= N_(\"E855: Autocommands caused command to abort\"));\n#ifdef FEAT_EVAL\nEXTERN char e_assert_fails_second_arg[]\n\tINIT(= N_(\"E856: \\\"assert_fails()\\\" second argument must be a string or a list with one or two strings\"));\nEXTERN char e_dictionary_key_str_required[]\n\tINIT(= N_(\"E857: Dictionary key \\\"%s\\\" required\"));\n#endif\n#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3)\nEXTERN char e_eval_did_not_return_valid_python_object[]\n\tINIT(= N_(\"E858: Eval did not return a valid python object\"));\nEXTERN char e_failed_to_convert_returned_python_object_to_vim_value[]\n\tINIT(= N_(\"E859: Failed to convert returned python object to a Vim value\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_need_id_and_type_or_types_with_both[]\n\tINIT(= N_(\"E860: Need 'id' and 'type' or 'types' with 'both'\"));\n# ifdef FEAT_TERMINAL\nEXTERN char e_cannot_open_second_popup_with_terminal[]\n\tINIT(= N_(\"E861: Cannot open a second popup with a terminal\"));\n# endif\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_use_g_here[]\n\tINIT(= N_(\"E862: Cannot use g: here\"));\n#endif\n#if defined(FEAT_PROP_POPUP) && defined(FEAT_TERMINAL)\nEXTERN char e_not_allowed_for_terminal_in_popup_window[]\n\tINIT(= N_(\"E863: Not allowed for a terminal in a popup window\"));\n#endif\nEXTERN char e_percent_hash_can_only_be_followed_by_zero_one_two_automatic_engine_will_be_used[]\n\t// xgettext:no-c-format\n\tINIT(= N_(\"E864: \\\\%#= can only be followed by 0, 1, or 2. The automatic engine will be used\"));\nEXTERN char e_nfa_regexp_end_encountered_prematurely[]\n\tINIT(= N_(\"E865: (NFA) Regexp end encountered prematurely\"));\nEXTERN char e_nfa_regexp_misplaced_chr[]\n\tINIT(= N_(\"E866: (NFA regexp) Misplaced %c\"));\nEXTERN char e_nfa_regexp_unknown_operator_z_chr[]\n\tINIT(= N_(\"E867: (NFA regexp) Unknown operator '\\\\z%c'\"));\nEXTERN char e_nfa_regexp_unknown_operator_percent_chr[]\n\tINIT(= N_(\"E867: (NFA regexp) Unknown operator '\\\\%%%c'\"));\nEXTERN char e_error_building_nfa_with_equivalence_class[]\n\tINIT(= N_(\"E868: Error building NFA with equivalence class!\"));\nEXTERN char e_nfa_regexp_unknown_operator_at_chr[]\n\tINIT(= N_(\"E869: (NFA regexp) Unknown operator '\\\\@%c'\"));\nEXTERN char e_nfa_regexp_error_reading_repetition_limits[]\n\tINIT(= N_(\"E870: (NFA regexp) Error reading repetition limits\"));\nEXTERN char e_nfa_regexp_cant_have_multi_follow_multi[]\n\tINIT(= N_(\"E871: (NFA regexp) Can't have a multi follow a multi\"));\nEXTERN char e_nfa_regexp_too_many_parens[]\n\tINIT(= N_(\"E872: (NFA regexp) Too many '('\"));\nEXTERN char e_nfa_regexp_proper_termination_error[]\n\tINIT(= N_(\"E873: (NFA regexp) proper termination error\"));\nEXTERN char e_nfa_regexp_could_not_pop_stack[]\n\tINIT(= N_(\"E874: (NFA regexp) Could not pop the stack!\"));\nEXTERN char e_nfa_regexp_while_converting_from_postfix_to_nfa_too_many_stats_left_on_stack[]\n\tINIT(= N_(\"E875: (NFA regexp) (While converting from postfix to NFA), too many states left on stack\"));\nEXTERN char e_nfa_regexp_not_enough_space_to_store_whole_nfa[]\n\tINIT(= N_(\"E876: (NFA regexp) Not enough space to store the whole NFA\"));\nEXTERN char e_nfa_regexp_invalid_character_class_nr[]\n\tINIT(= \"E877: (NFA regexp) Invalid character class: %d\");\nEXTERN char e_nfa_regexp_could_not_allocate_memory_for_branch_traversal[]\n\tINIT(= N_(\"E878: (NFA regexp) Could not allocate memory for branch traversal!\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_nfa_regexp_too_many_z[]\n\tINIT(= N_(\"E879: (NFA regexp) Too many \\\\z(\"));\n#endif\n#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3)\nEXTERN char e_cant_handle_systemexit_of_python_exception_in_vim[]\n\tINIT(= N_(\"E880: Can't handle SystemExit of python exception in vim\"));\n#endif\nEXTERN char e_line_count_changed_unexpectedly[]\n\tINIT(= N_(\"E881: Line count changed unexpectedly\"));\n#ifdef FEAT_EVAL\nEXTERN char e_uniq_compare_function_failed[]\n\tINIT(= N_(\"E882: Uniq compare function failed\"));\nEXTERN char e_search_pattern_and_expression_register_may_not_contain_two_or_more_lines[]\n\tINIT(= N_(\"E883: Search pattern and expression register may not contain two or more lines\"));\nEXTERN char e_function_name_cannot_contain_colon_str[]\n\tINIT(= N_(\"E884: Function name cannot contain a colon: %s\"));\n#endif\n#ifdef FEAT_SIGNS\nEXTERN char e_not_possible_to_change_sign_str[]\n\tINIT(= N_(\"E885: Not possible to change sign %s\"));\n#endif\n#ifdef FEAT_VIMINFO\nEXTERN char e_cant_rename_viminfo_file_to_str[]\n\tINIT(= N_(\"E886: Can't rename viminfo file to %s!\"));\n#endif\n#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3)\nEXTERN char e_sorry_this_command_is_disabled_python_side_module_could_not_be_loaded[]\n\tINIT(= N_(\"E887: Sorry, this command is disabled, the Python's site module could not be loaded.\"));\n#endif\nEXTERN char e_nfa_regexp_cannot_repeat_str[]\n\tINIT(= N_(\"E888: (NFA regexp) cannot repeat %s\"));\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_number_required[]\n\tINIT(= N_(\"E889: Number required\"));\n#endif\n#ifdef FEAT_SYN_HL\nEXTERN char e_trailing_char_after_rsb_str_str[]\n\tINIT(= N_(\"E890: Trailing char after ']': %s]%s\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_using_funcref_as_float[]\n\tINIT(= N_(\"E891: Using a Funcref as a Float\"));\nEXTERN char e_using_string_as_float[]\n\tINIT(= N_(\"E892: Using a String as a Float\"));\nEXTERN char e_using_list_as_float[]\n\tINIT(= N_(\"E893: Using a List as a Float\"));\nEXTERN char e_using_dictionary_as_float[]\n\tINIT(= N_(\"E894: Using a Dictionary as a Float\"));\n#endif\n#ifdef FEAT_MZSCHEME\nEXTERN char e_sorry_this_command_is_disabled_the_mzscheme_racket_base_module_could_not_be_loaded[]\n\tINIT(= N_(\"E895: Sorry, this command is disabled, the MzScheme's racket/base module could not be loaded.\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_argument_of_str_must_be_list_dictionary_or_blob[]\n\tINIT(= N_(\"E896: Argument of %s must be a List, Dictionary or Blob\"));\nEXTERN char e_list_or_blob_required[]\n\tINIT(= N_(\"E897: List or Blob required\"));\n#endif\n#ifdef FEAT_JOB_CHANNEL\nEXTERN char e_socket_in_channel_connect[]\n\tINIT(= N_(\"E898: socket() in channel_connect()\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_argument_of_str_must_be_list_or_blob[]\n\tINIT(= N_(\"E899: Argument of %s must be a List or Blob\"));\nEXTERN char e_maxdepth_must_be_non_negative_number[]\n\tINIT(= N_(\"E900: maxdepth must be non-negative number\"));\n#endif\n#ifdef FEAT_JOB_CHANNEL\nEXTERN char e_getaddrinfo_in_channel_open_str[]\n\tINIT(= N_(\"E901: getaddrinfo() in channel_open(): %s\"));\n# ifndef FEAT_IPV6\nEXTERN char e_gethostbyname_in_channel_open[]\n\tINIT(= N_(\"E901: gethostbyname() in channel_open()\"));\n# endif\nEXTERN char e_cannot_connect_to_port[]\n\tINIT(= N_(\"E902: Cannot connect to port\"));\nEXTERN char e_received_command_with_non_string_argument[]\n\tINIT(= N_(\"E903: Received command with non-string argument\"));\nEXTERN char e_last_argument_for_expr_call_must_be_number[]\n\tINIT(= N_(\"E904: Last argument for expr/call must be a number\"));\nEXTERN char e_third_argument_for_call_must_be_list[]\n\tINIT(= N_(\"E904: Third argument for call must be a list\"));\nEXTERN char e_received_unknown_command_str[]\n\tINIT(= N_(\"E905: Received unknown command: %s\"));\nEXTERN char e_not_an_open_channel[]\n\tINIT(= N_(\"E906: Not an open channel\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_using_special_value_as_float[]\n\tINIT(= N_(\"E907: Using a special value as a Float\"));\nEXTERN char e_using_invalid_value_as_string_str[]\n\tINIT(= N_(\"E908: Using an invalid value as a String: %s\"));\nEXTERN char e_cannot_index_special_variable[]\n\tINIT(= N_(\"E909: Cannot index a special variable\"));\n#endif\n#ifdef FEAT_JOB_CHANNEL\nEXTERN char e_using_job_as_number[]\n\tINIT(= N_(\"E910: Using a Job as a Number\"));\nEXTERN char e_using_job_as_float[]\n\tINIT(= N_(\"E911: Using a Job as a Float\"));\nEXTERN char e_cannot_use_evalexpr_sendexpr_with_raw_or_nl_channel[]\n\tINIT(= N_(\"E912: Cannot use ch_evalexpr()/ch_sendexpr() with a raw or nl channel\"));\nEXTERN char e_using_channel_as_number[]\n\tINIT(= N_(\"E913: Using a Channel as a Number\"));\nEXTERN char e_using_channel_as_float[]\n\tINIT(= N_(\"E914: Using a Channel as a Float\"));\nEXTERN char e_in_io_buffer_requires_in_buf_or_in_name_to_be_set[]\n\tINIT(= N_(\"E915: in_io buffer requires in_buf or in_name to be set\"));\nEXTERN char e_not_valid_job[]\n\tINIT(= N_(\"E916: Not a valid job\"));\nEXTERN char e_cannot_use_callback_with_str[]\n\tINIT(= N_(\"E917: Cannot use a callback with %s()\"));\nEXTERN char e_buffer_must_be_loaded_str[]\n\tINIT(= N_(\"E918: Buffer must be loaded: %s\"));\n#endif\nEXTERN char e_directory_not_found_in_str_str[]\n\tINIT(= N_(\"E919: Directory not found in '%s': \\\"%s\\\"\"));\n#ifdef FEAT_JOB_CHANNEL\nEXTERN char e_io_file_requires_name_to_be_set[]\n\tINIT(= N_(\"E920: _io file requires _name to be set\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_invalid_callback_argument[]\n\tINIT(= N_(\"E921: Invalid callback argument\"));\n// E922 unused\nEXTERN char e_second_argument_of_function_must_be_list_or_dict[]\n\tINIT(= N_(\"E923: Second argument of function() must be a list or a dict\"));\n#endif\n#ifdef FEAT_QUICKFIX\nEXTERN char e_current_window_was_closed[]\n\tINIT(= N_(\"E924: Current window was closed\"));\nEXTERN char e_current_quickfix_list_was_changed[]\n\tINIT(= N_(\"E925: Current quickfix list was changed\"));\nEXTERN char e_current_location_list_was_changed[]\n\tINIT(= N_(\"E926: Current location list was changed\"));\n#endif\n#ifdef FEAT_EVAL\n# ifdef FEAT_QUICKFIX\nEXTERN char e_invalid_action_str_1[]\n\tINIT(= N_(\"E927: Invalid action: '%s'\"));\n# endif\nEXTERN char e_string_required[]\n\tINIT(= N_(\"E928: String required\"));\n#endif\n#ifdef FEAT_VIMINFO\nEXTERN char e_too_many_viminfo_temp_files_like_str[]\n\tINIT(= N_(\"E929: Too many viminfo temp files, like %s!\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_use_redir_inside_execute[]\n\tINIT(= N_(\"E930: Cannot use :redir inside execute()\"));\n#endif\nEXTERN char e_buffer_cannot_be_registered[]\n\tINIT(= N_(\"E931: Buffer cannot be registered\"));\n#ifdef FEAT_EVAL\nEXTERN char e_closure_function_should_not_be_at_top_level_str[]\n\tINIT(= N_(\"E932: Closure function should not be at top level: %s\"));\nEXTERN char e_function_was_deleted_str[]\n\tINIT(= N_(\"E933: Function was deleted: %s\"));\n#endif\n#ifdef FEAT_SIGNS\nEXTERN char e_cannot_jump_to_buffer_that_does_not_have_name[]\n\tINIT(= N_(\"E934: Cannot jump to a buffer that does not have a name\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_invalid_submatch_number_nr[]\n\tINIT(= N_(\"E935: Invalid submatch number: %d\"));\n#endif\nEXTERN char e_cannot_delete_current_group[]\n\tINIT(= N_(\"E936: Cannot delete the current group\"));\nEXTERN char e_attempt_to_delete_buffer_that_is_in_use_str[]\n\tINIT(= N_(\"E937: Attempt to delete a buffer that is in use: %s\"));\n#ifdef FEAT_EVAL\nEXTERN char e_duplicate_key_in_json_str[]\n\tINIT(= N_(\"E938: Duplicate key in JSON: \\\"%s\\\"\"));\n#endif\nEXTERN char e_positive_count_required[]\n\tINIT(= N_(\"E939: Positive count required\"));\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_lock_or_unlock_variable_str[]\n\tINIT(= N_(\"E940: Cannot lock or unlock variable %s\"));\n# ifdef FEAT_CLIENTSERVER\nEXTERN char e_already_started_server[]\n\tINIT(= N_(\"E941: Already started a server\"));\n# else\nEXTERN char e_clientserver_feature_not_available[]\n\tINIT(= N_(\"E942: +clientserver feature not available\"));\n# endif\n#endif\nEXTERN char e_command_table_needs_to_be_updated_run_make_cmdidxs[]\n\tINIT(= \"E943: Command table needs to be updated, run 'make cmdidxs'\");\nEXTERN char e_reverse_range_in_character_class[]\n\tINIT(= N_(\"E944: Reverse range in character class\"));\nEXTERN char e_range_too_large_in_character_class[]\n\tINIT(= N_(\"E945: Range too large in character class\"));\n#ifdef FEAT_TERMINAL\nEXTERN char e_cannot_make_terminal_with_running_job_modifiable[]\n\tINIT(= N_(\"E946: Cannot make a terminal with running job modifiable\"));\nEXTERN char e_job_still_running_in_buffer_str[]\n\tINIT(= N_(\"E947: Job still running in buffer \\\"%s\\\"\"));\nEXTERN char e_job_still_running[]\n\tINIT(= N_(\"E948: Job still running\"));\nEXTERN char e_job_still_running_add_bang_to_end_the_job[]\n\tINIT(= N_(\"E948: Job still running (add ! to end the job)\"));\n#endif\nEXTERN char e_file_changed_while_writing[]\n\tINIT(= N_(\"E949: File changed while writing\"));\nEXTERN char e_cannot_convert_between_str_and_str[]\n\tINIT(= N_(\"E950: Cannot convert between %s and %s\"));\nEXTERN char e_percent_value_too_large[]\n\t// xgettext:no-c-format\n\tINIT(= N_(\"E951: \\\\% value too large\"));\n#if defined(FEAT_EVAL) && defined(FEAT_QUICKFIX)\nEXTERN char e_autocommand_caused_recursive_behavior[]\n\tINIT(= N_(\"E952: Autocommand caused recursive behavior\"));\n#endif\n#ifdef FEAT_TERMINAL\nEXTERN char e_file_exists_str[]\n\tINIT(= N_(\"E953: File exists: %s\"));\n#endif\n#if defined(FEAT_TERMGUICOLORS) && defined(FEAT_VTP)\nEXTERN char e_24_bit_colors_are_not_supported_on_this_environment[]\n\tINIT(= N_(\"E954: 24-bit colors are not supported on this environment\"));\n#endif\n#ifdef FEAT_TERMINAL\nEXTERN char e_not_terminal_buffer[]\n\tINIT(= N_(\"E955: Not a terminal buffer\"));\n#endif\nEXTERN char e_cannot_use_pattern_recursively[]\n\tINIT(= N_(\"E956: Cannot use pattern recursively\"));\n#ifdef FEAT_EVAL\nEXTERN char e_invalid_window_number[]\n\tINIT(= N_(\"E957: Invalid window number\"));\n#endif\n#ifdef FEAT_TERMINAL\nEXTERN char e_job_already_finished[]\n\tINIT(= N_(\"E958: Job already finished\"));\n#endif\n#ifdef FEAT_DIFF\nEXTERN char e_invalid_diff_format[]\n\tINIT(= N_(\"E959: Invalid diff format.\"));\nEXTERN char e_problem_creating_internal_diff[]\n\tINIT(= N_(\"E960: Problem creating the internal diff\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_no_line_number_to_use_for_sflnum[]\n\tINIT(= N_(\"E961: No line number to use for \\\"<sflnum>\\\"\"));\nEXTERN char e_invalid_action_str_2[]\n\tINIT(= N_(\"E962: Invalid action: '%s'\"));\nEXTERN char e_setting_v_str_to_value_with_wrong_type[]\n\tINIT(= N_(\"E963: Setting v:%s to value with wrong type\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char_u e_invalid_column_number_nr[]\n\tINIT(= N_(\"E964: Invalid column number: %ld\"));\nEXTERN char e_missing_property_type_name[]\n\tINIT(= N_(\"E965: Missing property type name\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char_u e_invalid_line_number_nr[]\n\tINIT(= N_(\"E966: Invalid line number: %ld\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_text_property_info_corrupted[]\n\tINIT(= \"E967: Text property info corrupted\");\nEXTERN char e_need_at_least_one_of_id_or_type[]\n\tINIT(= N_(\"E968: Need at least one of 'id' or 'type'\"));\nEXTERN char e_property_type_str_already_defined[]\n\tINIT(= N_(\"E969: Property type %s already defined\"));\nEXTERN char e_unknown_highlight_group_name_str[]\n\tINIT(= N_(\"E970: Unknown highlight group name: '%s'\"));\nEXTERN char e_property_type_str_does_not_exist[]\n\tINIT(= N_(\"E971: Property type %s does not exist\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_blob_value_does_not_have_right_number_of_bytes[]\n\tINIT(= N_(\"E972: Blob value does not have the right number of bytes\"));\nEXTERN char e_blob_literal_should_have_an_even_number_of_hex_characters[]\n\tINIT(= N_(\"E973: Blob literal should have an even number of hex characters\"));\nEXTERN char e_using_blob_as_number[]\n\tINIT(= N_(\"E974: Using a Blob as a Number\"));\nEXTERN char e_using_blob_as_float[]\n\tINIT(= N_(\"E975: Using a Blob as a Float\"));\nEXTERN char e_using_blob_as_string[]\n\tINIT(= N_(\"E976: Using a Blob as a String\"));\nEXTERN char e_can_only_compare_blob_with_blob[]\n\tINIT(= N_(\"E977: Can only compare Blob with Blob\"));\nEXTERN char e_invalid_operation_for_blob[]\n\tINIT(= N_(\"E978: Invalid operation for Blob\"));\nEXTERN char e_blob_index_out_of_range_nr[]\n\tINIT(= N_(\"E979: Blob index out of range: %ld\"));\n# ifndef USE_INPUT_BUF\nEXTERN char e_lowlevel_input_not_supported[]\n\tINIT(= N_(\"E980: Lowlevel input not supported\"));\n# endif\n#endif\nEXTERN char e_command_not_allowed_in_rvim[]\n\tINIT(= N_(\"E981: Command not allowed in rvim\"));\n#if defined(FEAT_TERMINAL) && defined(MSWIN)\nEXTERN char e_conpty_is_not_available[]\n\tINIT(= N_(\"E982: ConPTY is not available\"));\n#endif\nEXTERN char e_duplicate_argument_str[]\n\tINIT(= N_(\"E983: Duplicate argument: %s\"));\nEXTERN char e_scriptversion_used_outside_of_sourced_file[]\n\tINIT(= N_(\"E984: :scriptversion used outside of a sourced file\"));\n#ifdef FEAT_EVAL\nEXTERN char e_dot_equal_not_supported_with_script_version_two[]\n\tINIT(= N_(\"E985: .= is not supported with script version >= 2\"));\nEXTERN char e_cannot_modify_tag_stack_within_tagfunc[]\n\tINIT(= N_(\"E986: Cannot modify the tag stack within tagfunc\"));\nEXTERN char e_invalid_return_value_from_tagfunc[]\n\tINIT(= N_(\"E987: Invalid return value from tagfunc\"));\n#endif\n#ifdef GUI_MAY_SPAWN\nEXTERN char e_gui_cannot_be_used_cannot_execute_gvim_exe[]\n\tINIT(= N_(\"E988: GUI cannot be used. Cannot execute gvim.exe.\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_non_default_argument_follows_default_argument[]\n\tINIT(= N_(\"E989: Non-default argument follows default argument\"));\nEXTERN char e_missing_end_marker_str[]\n\tINIT(= N_(\"E990: Missing end marker '%s'\"));\nEXTERN char e_cannot_use_heredoc_here[]\n\tINIT(= N_(\"E991: Cannot use =<< here\"));\n#endif\nEXTERN char e_not_allowed_in_modeline_when_modelineexpr_is_off[]\n\tINIT(= N_(\"E992: Not allowed in a modeline when 'modelineexpr' is off\"));\n#ifdef FEAT_EVAL\nEXTERN char e_window_nr_is_not_popup_window[]\n\tINIT(= N_(\"E993: Window %d is not a popup window\"));\nEXTERN char e_not_allowed_in_popup_window[]\n\tINIT(= N_(\"E994: Not allowed in a popup window\"));\nEXTERN char e_cannot_modify_existing_variable[]\n\tINIT(= N_(\"E995: Cannot modify existing variable\"));\nEXTERN char e_cannot_lock_range[]\n\tINIT(= N_(\"E996: Cannot lock a range\"));\nEXTERN char e_cannot_lock_option[]\n\tINIT(= N_(\"E996: Cannot lock an option\"));\nEXTERN char e_cannot_lock_list_or_dict[]\n\tINIT(= N_(\"E996: Cannot lock a list or dict\"));\nEXTERN char e_cannot_lock_environment_variable[]\n\tINIT(= N_(\"E996: Cannot lock an environment variable\"));\nEXTERN char e_cannot_lock_register[]\n\tINIT(= N_(\"E996: Cannot lock a register\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_tabpage_not_found_nr[]\n\tINIT(= N_(\"E997: Tabpage not found: %d\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_reduce_of_an_empty_str_with_no_initial_value[]\n\tINIT(= N_(\"E998: Reduce of an empty %s with no initial value\"));\n#endif\nEXTERN char e_scriptversion_not_supported_nr[]\n\tINIT(= N_(\"E999: scriptversion not supported: %d\"));\n// E1000 unused\n#ifdef FEAT_EVAL\nEXTERN char e_variable_not_found_str[]\n\tINIT(= N_(\"E1001: Variable not found: %s\"));\nEXTERN char e_syntax_error_at_str[]\n\tINIT(= N_(\"E1002: Syntax error at %s\"));\nEXTERN char e_missing_return_value[]\n\tINIT(= N_(\"E1003: Missing return value\"));\nEXTERN char e_white_space_required_before_and_after_str_at_str[]\n\tINIT(= N_(\"E1004: White space required before and after '%s' at \\\"%s\\\"\"));\nEXTERN char e_too_many_argument_types[]\n\tINIT(= N_(\"E1005: Too many argument types\"));\nEXTERN char e_str_is_used_as_argument[]\n\tINIT(= N_(\"E1006: %s is used as an argument\"));\nEXTERN char e_mandatory_argument_after_optional_argument[]\n\tINIT(= N_(\"E1007: Mandatory argument after optional argument\"));\nEXTERN char e_missing_type_after_str[]\n\tINIT(= N_(\"E1008: Missing <type> after %s\"));\nEXTERN char e_missing_gt_after_type_str[]\n\tINIT(= N_(\"E1009: Missing > after type: %s\"));\nEXTERN char e_type_not_recognized_str[]\n\tINIT(= N_(\"E1010: Type not recognized: %s\"));\nEXTERN char e_name_too_long_str[]\n\tINIT(= N_(\"E1011: Name too long: %s\"));\nEXTERN char e_type_mismatch_expected_str_but_got_str[]\n\tINIT(= N_(\"E1012: Type mismatch; expected %s but got %s\"));\nEXTERN char e_type_mismatch_expected_str_but_got_str_in_str[]\n\tINIT(= N_(\"E1012: Type mismatch; expected %s but got %s in %s\"));\nEXTERN char e_argument_nr_type_mismatch_expected_str_but_got_str[]\n\tINIT(= N_(\"E1013: Argument %d: type mismatch, expected %s but got %s\"));\nEXTERN char e_argument_nr_type_mismatch_expected_str_but_got_str_in_str[]\n\tINIT(= N_(\"E1013: Argument %d: type mismatch, expected %s but got %s in %s\"));\nEXTERN char e_invalid_key_str[]\n\tINIT(= N_(\"E1014: Invalid key: %s\"));\nEXTERN char e_name_expected_str[]\n\tINIT(= N_(\"E1015: Name expected: %s\"));\nEXTERN char e_cannot_declare_a_scope_variable_str[]\n\tINIT(= N_(\"E1016: Cannot declare a %s variable: %s\"));\nEXTERN char e_cannot_declare_an_environment_variable_str[]\n\tINIT(= N_(\"E1016: Cannot declare an environment variable: %s\"));\nEXTERN char e_variable_already_declared_str[]\n\tINIT(= N_(\"E1017: Variable already declared: %s\"));\nEXTERN char e_cannot_assign_to_constant_str[]\n\tINIT(= N_(\"E1018: Cannot assign to a constant: %s\"));\nEXTERN char e_can_only_concatenate_to_string[]\n\tINIT(= N_(\"E1019: Can only concatenate to string\"));\nEXTERN char e_cannot_use_operator_on_new_variable_str[]\n\tINIT(= N_(\"E1020: Cannot use an operator on a new variable: %s\"));\nEXTERN char e_const_requires_a_value[]\n\tINIT(= N_(\"E1021: Const requires a value\"));\nEXTERN char e_type_or_initialization_required[]\n\tINIT(= N_(\"E1022: Type or initialization required\"));\nEXTERN char e_using_number_as_bool_nr[]\n\tINIT(= N_(\"E1023: Using a Number as a Bool: %lld\"));\nEXTERN char e_using_number_as_string[]\n\tINIT(= N_(\"E1024: Using a Number as a String\"));\nEXTERN char e_using_rcurly_outside_if_block_scope[]\n\tINIT(= N_(\"E1025: Using } outside of a block scope\"));\n#endif\nEXTERN char e_missing_rcurly[]\n\tINIT(= N_(\"E1026: Missing }\"));\n#ifdef FEAT_EVAL\nEXTERN char e_missing_return_statement[]\n\tINIT(= N_(\"E1027: Missing return statement\"));\nEXTERN char e_compiling_def_function_failed[]\n\tINIT(= N_(\"E1028: Compiling :def function failed\"));\nEXTERN char e_expected_str_but_got_str[]\n\tINIT(= N_(\"E1029: Expected %s but got %s\"));\nEXTERN char e_using_string_as_number_str[]\n\tINIT(= N_(\"E1030: Using a String as a Number: \\\"%s\\\"\"));\nEXTERN char e_cannot_use_void_value[]\n\tINIT(= N_(\"E1031: Cannot use void value\"));\nEXTERN char e_missing_catch_or_finally[]\n\tINIT(= N_(\"E1032: Missing :catch or :finally\"));\nEXTERN char e_catch_unreachable_after_catch_all[]\n\tINIT(= N_(\"E1033: Catch unreachable after catch-all\"));\nEXTERN char e_cannot_use_reserved_name_str[]\n\tINIT(= N_(\"E1034: Cannot use reserved name %s\"));\nEXTERN char e_percent_requires_number_arguments[]\n\t// xgettext:no-c-format\n\tINIT(= N_(\"E1035: % requires number arguments\"));\nEXTERN char e_char_requires_number_or_float_arguments[]\n\tINIT(= N_(\"E1036: %c requires number or float arguments\"));\nEXTERN char e_cannot_use_str_with_str[]\n\tINIT(= N_(\"E1037: Cannot use \\\"%s\\\" with %s\"));\nEXTERN char e_vim9script_can_only_be_used_in_script[]\n\tINIT(= N_(\"E1038: \\\"vim9script\\\" can only be used in a script\"));\nEXTERN char e_vim9script_must_be_first_command_in_script[]\n\tINIT(= N_(\"E1039: \\\"vim9script\\\" must be the first command in a script\"));\n#endif\nEXTERN char e_cannot_use_scriptversion_after_vim9script[]\n\tINIT(= N_(\"E1040: Cannot use :scriptversion after :vim9script\"));\n#ifdef FEAT_EVAL\nEXTERN char e_redefining_script_item_str[]\n\tINIT(= N_(\"E1041: Redefining script item: \\\"%s\\\"\"));\nEXTERN char e_export_can_only_be_used_in_vim9script[]\n\tINIT(= N_(\"E1042: Export can only be used in vim9script\"));\nEXTERN char e_invalid_command_after_export[]\n\tINIT(= N_(\"E1043: Invalid command after :export\"));\nEXTERN char e_export_with_invalid_argument[]\n\tINIT(= N_(\"E1044: Export with invalid argument\"));\n// E1045 not used\n// E1046 not used\nEXTERN char e_syntax_error_in_import_str[]\n\tINIT(= N_(\"E1047: Syntax error in import: %s\"));\nEXTERN char e_item_not_found_in_script_str[]\n\tINIT(= N_(\"E1048: Item not found in script: %s\"));\nEXTERN char e_item_not_exported_in_script_str[]\n\tINIT(= N_(\"E1049: Item not exported in script: %s\"));\n#endif\nEXTERN char e_colon_required_before_range_str[]\n\tINIT(= N_(\"E1050: Colon required before a range: %s\"));\n#ifdef FEAT_EVAL\nEXTERN char e_wrong_argument_type_for_plus[]\n\tINIT(= N_(\"E1051: Wrong argument type for +\"));\nEXTERN char e_cannot_declare_an_option_str[]\n\tINIT(= N_(\"E1052: Cannot declare an option: %s\"));\nEXTERN char e_could_not_import_str[]\n\tINIT(= N_(\"E1053: Could not import \\\"%s\\\"\"));\nEXTERN char e_variable_already_declared_in_script_str[]\n\tINIT(= N_(\"E1054: Variable already declared in the script: %s\"));\nEXTERN char e_missing_name_after_dots[]\n\tINIT(= N_(\"E1055: Missing name after ...\"));\nEXTERN char e_expected_type_str[]\n\tINIT(= N_(\"E1056: Expected a type: %s\"));\nEXTERN char e_missing_enddef[]\n\tINIT(= N_(\"E1057: Missing :enddef\"));\nEXTERN char e_function_nesting_too_deep[]\n\tINIT(= N_(\"E1058: Function nesting too deep\"));\nEXTERN char e_no_white_space_allowed_before_colon_str[]\n\tINIT(= N_(\"E1059: No white space allowed before colon: %s\"));\nEXTERN char e_expected_dot_after_name_str[]\n\tINIT(= N_(\"E1060: Expected dot after name: %s\"));\nEXTERN char e_cannot_find_function_str[]\n\tINIT(= N_(\"E1061: Cannot find function %s\"));\nEXTERN char e_cannot_index_number[]\n\tINIT(= N_(\"E1062: Cannot index a Number\"));\nEXTERN char e_type_mismatch_for_v_variable[]\n\tINIT(= N_(\"E1063: Type mismatch for v: variable\"));\n#endif\nEXTERN char e_yank_register_changed_while_using_it[]\n\tINIT(= N_(\"E1064: Yank register changed while using it\"));\nEXTERN char e_command_cannot_be_shortened_str[]\n\tINIT(= N_(\"E1065: Command cannot be shortened: %s\"));\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_declare_a_register_str[]\n\tINIT(= N_(\"E1066: Cannot declare a register: %s\"));\nEXTERN char e_separator_mismatch_str[]\n\tINIT(= N_(\"E1067: Separator mismatch: %s\"));\nEXTERN char e_no_white_space_allowed_before_str_str[]\n\tINIT(= N_(\"E1068: No white space allowed before '%s': %s\"));\nEXTERN char e_white_space_required_after_str_str[]\n\tINIT(= N_(\"E1069: White space required after '%s': %s\"));\nEXTERN char e_invalid_string_for_import_str[]\n\tINIT(= N_(\"E1071: Invalid string for :import: %s\"));\nEXTERN char e_cannot_compare_str_with_str[]\n\tINIT(= N_(\"E1072: Cannot compare %s with %s\"));\nEXTERN char e_name_already_defined_str[]\n\tINIT(= N_(\"E1073: Name already defined: %s\"));\nEXTERN char e_no_white_space_allowed_after_dot[]\n\tINIT(= N_(\"E1074: No white space allowed after dot\"));\nEXTERN char e_namespace_not_supported_str[]\n\tINIT(= N_(\"E1075: Namespace not supported: %s\"));\n// E1076 unused (was deleted)\nEXTERN char e_missing_argument_type_for_str[]\n\tINIT(= N_(\"E1077: Missing argument type for %s\"));\n#endif\nEXTERN char e_invalid_command_nested_did_you_mean_plusplus_nested[]\n\tINIT(= N_(\"E1078: Invalid command \\\"nested\\\", did you mean \\\"++nested\\\"?\"));\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_declare_variable_on_command_line[]\n\tINIT(= N_(\"E1079: Cannot declare a variable on the command line\"));\nEXTERN char e_invalid_assignment[]\n\tINIT(= N_(\"E1080: Invalid assignment\"));\nEXTERN char e_cannot_unlet_str[]\n\tINIT(= N_(\"E1081: Cannot unlet %s\"));\n#endif\nEXTERN char e_command_modifier_without_command[]\n\tINIT(= N_(\"E1082: Command modifier without command\"));\n#ifdef FEAT_EVAL\nEXTERN char e_missing_backtick[]\n\tINIT(= N_(\"E1083: Missing backtick\"));\nEXTERN char e_cannot_delete_vim9_script_function_str[]\n\tINIT(= N_(\"E1084: Cannot delete Vim9 script function %s\"));\nEXTERN char e_not_callable_type_str[]\n\tINIT(= N_(\"E1085: Not a callable type: %s\"));\n// E1086 unused\nEXTERN char e_cannot_use_index_when_declaring_variable[]\n\tINIT(= N_(\"E1087: Cannot use an index when declaring a variable\"));\nEXTERN char e_script_cannot_import_itself[]\n\tINIT(= N_(\"E1088: Script cannot import itself\"));\nEXTERN char e_unknown_variable_str[]\n\tINIT(= N_(\"E1089: Unknown variable: %s\"));\nEXTERN char e_cannot_assign_to_argument_str[]\n\tINIT(= N_(\"E1090: Cannot assign to argument %s\"));\nEXTERN char e_function_is_not_compiled_str[]\n\tINIT(= N_(\"E1091: Function is not compiled: %s\"));\nEXTERN char e_cannot_nest_redir[]\n\tINIT(= N_(\"E1092: Cannot nest :redir\"));\nEXTERN char e_expected_nr_items_but_got_nr[]\n\tINIT(= N_(\"E1093: Expected %d items but got %d\"));\nEXTERN char e_import_can_only_be_used_in_script[]\n\tINIT(= N_(\"E1094: Import can only be used in a script\"));\nEXTERN char e_unreachable_code_after_str[]\n\tINIT(= N_(\"E1095: Unreachable code after :%s\"));\nEXTERN char e_returning_value_in_function_without_return_type[]\n\tINIT(= N_(\"E1096: Returning a value in a function without a return type\"));\nEXTERN char e_line_incomplete[]\n\tINIT(= N_(\"E1097: Line incomplete\"));\nEXTERN char e_string_list_or_blob_required[]\n\tINIT(= N_(\"E1098: String, List or Blob required\"));\nEXTERN char e_unknown_error_while_executing_str[]\n\tINIT(= N_(\"E1099: Unknown error while executing %s\"));\nEXTERN char e_command_not_supported_in_vim9_script_missing_var_str[]\n\tINIT(= N_(\"E1100: Command not supported in Vim9 script (missing :var?): %s\"));\nEXTERN char e_cannot_declare_script_variable_in_function_str[]\n\tINIT(= N_(\"E1101: Cannot declare a script variable in a function: %s\"));\nEXTERN char e_lambda_function_not_found_str[]\n\tINIT(= N_(\"E1102: Lambda function not found: %s\"));\nEXTERN char e_dictionary_not_set[]\n\tINIT(= N_(\"E1103: Dictionary not set\"));\nEXTERN char e_missing_gt[]\n\tINIT(= N_(\"E1104: Missing >\"));\nEXTERN char e_cannot_convert_str_to_string[]\n\tINIT(= N_(\"E1105: Cannot convert %s to string\"));\n\nPLURAL_MSG(e_one_argument_too_many, \"E1106: One argument too many\",\n\t\te_nr_arguments_too_many, \"E1106: %d arguments too many\")\n\nEXTERN char e_string_list_dict_or_blob_required[]\n\tINIT(= N_(\"E1107: String, List, Dict or Blob required\"));\n// E1108 unused\nEXTERN char e_list_item_nr_is_not_list[]\n\tINIT(= N_(\"E1109: List item %d is not a List\"));\nEXTERN char e_list_item_nr_does_not_contain_3_numbers[]\n\tINIT(= N_(\"E1110: List item %d does not contain 3 numbers\"));\nEXTERN char e_list_item_nr_range_invalid[]\n\tINIT(= N_(\"E1111: List item %d range invalid\"));\nEXTERN char e_list_item_nr_cell_width_invalid[]\n\tINIT(= N_(\"E1112: List item %d cell width invalid\"));\nEXTERN char e_overlapping_ranges_for_nr[]\n\tINIT(= N_(\"E1113: Overlapping ranges for 0x%lx\"));\nEXTERN char e_only_values_of_0x80_and_higher_supported[]\n\tINIT(= N_(\"E1114: Only values of 0x80 and higher supported\"));\nEXTERN char e_assert_fails_fourth_argument[]\n\tINIT(= N_(\"E1115: \\\"assert_fails()\\\" fourth argument must be a number\"));\nEXTERN char e_assert_fails_fifth_argument[]\n\tINIT(= N_(\"E1116: \\\"assert_fails()\\\" fifth argument must be a string\"));\nEXTERN char e_cannot_use_bang_with_nested_def[]\n\tINIT(= N_(\"E1117: Cannot use ! with nested :def\"));\nEXTERN char e_cannot_change_locked_list[]\n\tINIT(= N_(\"E1118: Cannot change locked list\"));\nEXTERN char e_cannot_change_locked_list_item[]\n\tINIT(= N_(\"E1119: Cannot change locked list item\"));\nEXTERN char e_cannot_change_dict[]\n\tINIT(= N_(\"E1120: Cannot change dict\"));\nEXTERN char e_cannot_change_dict_item[]\n\tINIT(= N_(\"E1121: Cannot change dict item\"));\nEXTERN char e_variable_is_locked_str[]\n\tINIT(= N_(\"E1122: Variable is locked: %s\"));\nEXTERN char e_missing_comma_before_argument_str[]\n\tINIT(= N_(\"E1123: Missing comma before argument: %s\"));\nEXTERN char e_str_cannot_be_used_in_legacy_vim_script[]\n\tINIT(= N_(\"E1124: \\\"%s\\\" cannot be used in legacy Vim script\"));\nEXTERN char e_final_requires_a_value[]\n\tINIT(= N_(\"E1125: Final requires a value\"));\nEXTERN char e_cannot_use_let_in_vim9_script[]\n\tINIT(= N_(\"E1126: Cannot use :let in Vim9 script\"));\nEXTERN char e_missing_name_after_dot[]\n\tINIT(= N_(\"E1127: Missing name after dot\"));\nEXTERN char e_endblock_without_block[]\n\tINIT(= N_(\"E1128: } without {\"));\nEXTERN char e_throw_with_empty_string[]\n\tINIT(= N_(\"E1129: Throw with empty string\"));\nEXTERN char e_cannot_add_to_null_list[]\n\tINIT(= N_(\"E1130: Cannot add to null list\"));\nEXTERN char e_cannot_add_to_null_blob[]\n\tINIT(= N_(\"E1131: Cannot add to null blob\"));\nEXTERN char e_missing_function_argument[]\n\tINIT(= N_(\"E1132: Missing function argument\"));\nEXTERN char e_cannot_extend_null_dict[]\n\tINIT(= N_(\"E1133: Cannot extend a null dict\"));\nEXTERN char e_cannot_extend_null_list[]\n\tINIT(= N_(\"E1134: Cannot extend a null list\"));\nEXTERN char e_using_string_as_bool_str[]\n\tINIT(= N_(\"E1135: Using a String as a Bool: \\\"%s\\\"\"));\n#endif\nEXTERN char e_cmd_mapping_must_end_with_cr_before_second_cmd[]\n\tINIT(= N_(\"E1136: <Cmd> mapping must end with <CR> before second <Cmd>\"));\n// E1137 unused\n#ifdef FEAT_EVAL\nEXTERN char e_using_bool_as_number[]\n\tINIT(= N_(\"E1138: Using a Bool as a Number\"));\nEXTERN char e_missing_matching_bracket_after_dict_key[]\n\tINIT(= N_(\"E1139: Missing matching bracket after dict key\"));\nEXTERN char e_for_argument_must_be_sequence_of_lists[]\n\tINIT(= N_(\"E1140: :for argument must be a sequence of lists\"));\nEXTERN char e_indexable_type_required[]\n\tINIT(= N_(\"E1141: Indexable type required\"));\nEXTERN char e_calling_test_garbagecollect_now_while_v_testing_is_not_set[]\n\tINIT(= N_(\"E1142: Calling test_garbagecollect_now() while v:testing is not set\"));\nEXTERN char e_empty_expression_str[]\n\tINIT(= N_(\"E1143: Empty expression: \\\"%s\\\"\"));\nEXTERN char e_command_str_not_followed_by_white_space_str[]\n\tINIT(= N_(\"E1144: Command \\\"%s\\\" is not followed by white space: %s\"));\nEXTERN char e_missing_heredoc_end_marker_str[]\n\tINIT(= N_(\"E1145: Missing heredoc end marker: %s\"));\nEXTERN char e_command_not_recognized_str[]\n\tINIT(= N_(\"E1146: Command not recognized: %s\"));\nEXTERN char e_list_not_set[]\n\tINIT(= N_(\"E1147: List not set\"));\nEXTERN char e_cannot_index_str[]\n\tINIT(= N_(\"E1148: Cannot index a %s\"));\nEXTERN char e_script_variable_invalid_after_reload_in_function_str[]\n\tINIT(= N_(\"E1149: Script variable is invalid after reload in function %s\"));\nEXTERN char e_script_variable_type_changed[]\n\tINIT(= N_(\"E1150: Script variable type changed\"));\nEXTERN char e_mismatched_endfunction[]\n\tINIT(= N_(\"E1151: Mismatched endfunction\"));\nEXTERN char e_mismatched_enddef[]\n\tINIT(= N_(\"E1152: Mismatched enddef\"));\nEXTERN char e_invalid_operation_for_str[]\n\tINIT(= N_(\"E1153: Invalid operation for %s\"));\nEXTERN char e_divide_by_zero[]\n\tINIT(= N_(\"E1154: Divide by zero\"));\n#endif\nEXTERN char e_cannot_define_autocommands_for_all_events[]\n\tINIT(= N_(\"E1155: Cannot define autocommands for ALL events\"));\nEXTERN char e_cannot_change_arglist_recursively[]\n\tINIT(= N_(\"E1156: Cannot change the argument list recursively\"));\n#ifdef FEAT_EVAL\nEXTERN char e_missing_return_type[]\n\tINIT(= N_(\"E1157: Missing return type\"));\nEXTERN char e_cannot_use_flatten_in_vim9_script[]\n\tINIT(= N_(\"E1158: Cannot use flatten() in Vim9 script, use flattennew()\"));\n#endif\nEXTERN char e_cannot_split_window_when_closing_buffer[]\n\tINIT(= N_(\"E1159: Cannot split a window when closing the buffer\"));\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_use_default_for_variable_arguments[]\n\tINIT(= N_(\"E1160: Cannot use a default for variable arguments\"));\nEXTERN char e_cannot_json_encode_str[]\n\tINIT(= N_(\"E1161: Cannot json encode a %s\"));\nEXTERN char e_register_name_must_be_one_char_str[]\n\tINIT(= N_(\"E1162: Register name must be one character: %s\"));\nEXTERN char e_variable_nr_type_mismatch_expected_str_but_got_str[]\n\tINIT(= N_(\"E1163: Variable %d: type mismatch, expected %s but got %s\"));\nEXTERN char e_variable_nr_type_mismatch_expected_str_but_got_str_in_str[]\n\tINIT(= N_(\"E1163: Variable %d: type mismatch, expected %s but got %s in %s\"));\n#endif\nEXTERN char e_vim9cmd_must_be_followed_by_command[]\n\tINIT(= N_(\"E1164: vim9cmd must be followed by a command\"));\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_use_range_with_assignment_str[]\n\tINIT(= N_(\"E1165: Cannot use a range with an assignment: %s\"));\nEXTERN char e_cannot_use_range_with_dictionary[]\n\tINIT(= N_(\"E1166: Cannot use a range with a dictionary\"));\nEXTERN char e_argument_name_shadows_existing_variable_str[]\n\tINIT(= N_(\"E1167: Argument name shadows existing variable: %s\"));\nEXTERN char e_argument_already_declared_in_script_str[]\n\tINIT(= N_(\"E1168: Argument already declared in the script: %s\"));\nEXTERN char e_expression_too_recursive_str[]\n\tINIT(= N_(\"E1169: Expression too recursive: %s\"));\nEXTERN char e_cannot_use_hash_curly_to_start_comment[]\n\tINIT(= N_(\"E1170: Cannot use #{ to start a comment\"));\nEXTERN char e_missing_end_block[]\n\tINIT(= N_(\"E1171: Missing } after inline function\"));\nEXTERN char e_cannot_use_default_values_in_lambda[]\n\tINIT(= N_(\"E1172: Cannot use default values in a lambda\"));\nEXTERN char e_text_found_after_str_str[]\n\tINIT(= N_(\"E1173: Text found after %s: %s\"));\nEXTERN char e_string_required_for_argument_nr[]\n\tINIT(= N_(\"E1174: String required for argument %d\"));\nEXTERN char e_non_empty_string_required_for_argument_nr[]\n\tINIT(= N_(\"E1175: Non-empty string required for argument %d\"));\nEXTERN char e_misplaced_command_modifier[]\n\tINIT(= N_(\"E1176: Misplaced command modifier\"));\nEXTERN char e_for_loop_on_str_not_supported[]\n\tINIT(= N_(\"E1177: For loop on %s not supported\"));\nEXTERN char e_cannot_lock_unlock_local_variable[]\n\tINIT(= N_(\"E1178: Cannot lock or unlock a local variable\"));\n#endif\n#ifdef FEAT_TERMINAL\nEXTERN char e_failed_to_extract_pwd_from_str_check_your_shell_config[]\n\tINIT(= N_(\"E1179: Failed to extract PWD from %s, check your shell's config related to OSC 7\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_variable_arguments_type_must_be_list_str[]\n\tINIT(= N_(\"E1180: Variable arguments type must be a list: %s\"));\nEXTERN char e_cannot_use_underscore_here[]\n\tINIT(= N_(\"E1181: Cannot use an underscore here\"));\nEXTERN char e_cannot_define_dict_func_in_vim9_script_str[]\n\tINIT(= N_(\"E1182: Cannot define a dict function in Vim9 script: %s\"));\nEXTERN char e_cannot_use_range_with_assignment_operator_str[]\n\tINIT(= N_(\"E1183: Cannot use a range with an assignment operator: %s\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_blob_not_set[]\n\tINIT(= N_(\"E1184: Blob not set\"));\nEXTERN char e_missing_redir_end[]\n\tINIT(= N_(\"E1185: Missing :redir END\"));\nEXTERN char e_expression_does_not_result_in_value_str[]\n\tINIT(= N_(\"E1186: Expression does not result in a value: %s\"));\n#endif\nEXTERN char e_failed_to_source_defaults[]\n\tINIT(= N_(\"E1187: Failed to source defaults.vim\"));\n#if defined(FEAT_TERMINAL)\nEXTERN char e_cannot_open_terminal_from_command_line_window[]\n\tINIT(= N_(\"E1188: Cannot open a terminal from the command line window\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_use_legacy_with_command_str[]\n\tINIT(= N_(\"E1189: Cannot use :legacy with this command: %s\"));\n\nPLURAL_MSG(e_one_argument_too_few, \"E1190: One argument too few\",\n\t\te_nr_arguments_too_few, \"E1190: %d arguments too few\")\n\nEXTERN char e_call_to_function_that_failed_to_compile_str[]\n\tINIT(= N_(\"E1191: Call to function that failed to compile: %s\"));\nEXTERN char e_empty_function_name[]\n\tINIT(= N_(\"E1192: Empty function name\"));\n#endif\n// libsodium\n#ifdef FEAT_CRYPT\n# ifndef FEAT_SODIUM\nEXTERN char e_libsodium_not_built_in[]\n\tINIT(= N_(\"E1193: cryptmethod xchacha20 not built into this Vim\"));\n# else\n#  if 0\nEXTERN char e_libsodium_cannot_encrypt_header[]\n\tINIT(= N_(\"E1194: Cannot encrypt header, not enough space\"));\nEXTERN char e_libsodium_cannot_encrypt_buffer[]\n\tINIT(= N_(\"E1195: Cannot encrypt buffer, not enough space\"));\nEXTERN char e_libsodium_cannot_decrypt_header[]\n\tINIT(= N_(\"E1196: Cannot decrypt header, not enough space\"));\n#  endif\nEXTERN char e_libsodium_cannot_allocate_buffer[]\n\tINIT(= N_(\"E1197: Cannot allocate_buffer for encryption\"));\nEXTERN char e_libsodium_decryption_failed_header_incomplete[]\n\tINIT(= N_(\"E1198: Decryption failed: Header incomplete!\"));\n#  if 0\nEXTERN char e_libsodium_cannot_decrypt_buffer[]\n\tINIT(= N_(\"E1199: Cannot decrypt buffer, not enough space\"));\n#  endif\nEXTERN char e_libsodium_decryption_failed[]\n\tINIT(= N_(\"E1200: Decryption failed!\"));\nEXTERN char e_libsodium_decryption_failed_premature[]\n\tINIT(= N_(\"E1201: Decryption failed: pre-mature end of file!\"));\n# endif\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_no_white_space_allowed_after_str_str[]\n\tINIT(= N_(\"E1202: No white space allowed after '%s': %s\"));\nEXTERN char e_dot_not_allowed_after_str_str[]\n\tINIT(= N_(\"E1203: Dot not allowed after a %s: %s\"));\n#endif\nEXTERN char e_regexp_number_after_dot_pos_search_chr[]\n\tINIT(= N_(\"E1204: No Number allowed after .: '\\\\%%%c'\"));\nEXTERN char e_no_white_space_allowed_between_option_and[]\n\tINIT(= N_(\"E1205: No white space allowed between option and\"));\n#ifdef FEAT_EVAL\nEXTERN char e_dict_required_for_argument_nr[]\n\tINIT(= N_(\"E1206: Dictionary required for argument %d\"));\nEXTERN char e_expression_without_effect_str[]\n\tINIT(= N_(\"E1207: Expression without an effect: %s\"));\n#endif\nEXTERN char e_complete_used_without_allowing_arguments[]\n\tINIT(= N_(\"E1208: -complete used without allowing arguments\"));\n#ifdef FEAT_EVAL\nEXTERN char e_invalid_value_for_line_number_str[]\n\tINIT(= N_(\"E1209: Invalid value for a line number: \\\"%s\\\"\"));\nEXTERN char e_number_required_for_argument_nr[]\n\tINIT(= N_(\"E1210: Number required for argument %d\"));\nEXTERN char e_list_required_for_argument_nr[]\n\tINIT(= N_(\"E1211: List required for argument %d\"));\nEXTERN char e_bool_required_for_argument_nr[]\n\tINIT(= N_(\"E1212: Bool required for argument %d\"));\nEXTERN char e_redefining_imported_item_str[]\n\tINIT(= N_(\"E1213: Redefining imported item \\\"%s\\\"\"));\n#endif\n#if defined(FEAT_DIGRAPHS)\nEXTERN char e_digraph_must_be_just_two_characters_str[]\n\tINIT(= N_(\"E1214: Digraph must be just two characters: %s\"));\nEXTERN char e_digraph_argument_must_be_one_character_str[]\n\tINIT(= N_(\"E1215: Digraph must be one character: %s\"));\nEXTERN char e_digraph_setlist_argument_must_be_list_of_lists_with_two_items[]\n\tINIT(= N_(\"E1216: digraph_setlist() argument must be a list of lists with two items\"));\n#endif\n#ifdef FEAT_EVAL\n# ifdef FEAT_JOB_CHANNEL\nEXTERN char e_chan_or_job_required_for_argument_nr[]\n\tINIT(= N_(\"E1217: Channel or Job required for argument %d\"));\nEXTERN char e_job_required_for_argument_nr[]\n\tINIT(= N_(\"E1218: Job required for argument %d\"));\n# endif\nEXTERN char e_float_or_number_required_for_argument_nr[]\n\tINIT(= N_(\"E1219: Float or Number required for argument %d\"));\nEXTERN char e_string_or_number_required_for_argument_nr[]\n\tINIT(= N_(\"E1220: String or Number required for argument %d\"));\n# ifdef FEAT_JOB_CHANNEL\nEXTERN char e_string_or_blob_required_for_argument_nr[]\n\tINIT(= N_(\"E1221: String or Blob required for argument %d\"));\n# endif\nEXTERN char e_string_or_list_required_for_argument_nr[]\n\tINIT(= N_(\"E1222: String or List required for argument %d\"));\nEXTERN char e_string_or_dict_required_for_argument_nr[]\n\tINIT(= N_(\"E1223: String or Dictionary required for argument %d\"));\nEXTERN char e_string_number_or_list_required_for_argument_nr[]\n\tINIT(= N_(\"E1224: String, Number or List required for argument %d\"));\nEXTERN char e_string_list_or_dict_required_for_argument_nr[]\n\tINIT(= N_(\"E1225: String, List or Dictionary required for argument %d\"));\nEXTERN char e_list_or_blob_required_for_argument_nr[]\n\tINIT(= N_(\"E1226: List or Blob required for argument %d\"));\nEXTERN char e_list_or_dict_required_for_argument_nr[]\n\tINIT(= N_(\"E1227: List or Dictionary required for argument %d\"));\nEXTERN char e_list_dict_or_blob_required_for_argument_nr[]\n\tINIT(= N_(\"E1228: List, Dictionary or Blob required for argument %d\"));\nEXTERN char e_expected_dictionary_for_using_key_str_but_got_str[]\n\tINIT(= N_(\"E1229: Expected dictionary for using key \\\"%s\\\", but got %s\"));\n#endif\n#ifdef FEAT_SODIUM\nEXTERN char e_encryption_sodium_mlock_failed[]\n\tINIT(= N_(\"E1230: Encryption: sodium_mlock() failed\"));\n#endif\nEXTERN char e_cannot_use_bar_to_separate_commands_here_str[]\n\tINIT(= N_(\"E1231: Cannot use a bar to separate commands here: %s\"));\n#ifdef FEAT_EVAL\nEXTERN char e_argument_of_exists_compiled_must_be_literal_string[]\n\tINIT(= N_(\"E1232: Argument of exists_compiled() must be a literal string\"));\nEXTERN char e_exists_compiled_can_only_be_used_in_def_function[]\n\tINIT(= N_(\"E1233: exists_compiled() can only be used in a :def function\"));\n#endif\nEXTERN char e_legacy_must_be_followed_by_command[]\n\tINIT(= N_(\"E1234: legacy must be followed by a command\"));\n#ifdef FEAT_EVAL\n// E1235 unused\nEXTERN char e_cannot_use_str_itself_it_is_imported[]\n\tINIT(= N_(\"E1236: Cannot use %s itself, it is imported\"));\n#endif\nEXTERN char e_no_such_user_defined_command_in_current_buffer_str[]\n\tINIT(= N_(\"E1237: No such user-defined command in current buffer: %s\"));\n#ifdef FEAT_EVAL\nEXTERN char e_blob_required_for_argument_nr[]\n\tINIT(= N_(\"E1238: Blob required for argument %d\"));\nEXTERN char e_invalid_value_for_blob_nr[]\n\tINIT(= N_(\"E1239: Invalid value for blob: %d\"));\n#endif\nEXTERN char e_resulting_text_too_long[]\n\tINIT(= N_(\"E1240: Resulting text too long\"));\n#ifdef FEAT_EVAL\nEXTERN char e_separator_not_supported_str[]\n\tINIT(= N_(\"E1241: Separator not supported: %s\"));\nEXTERN char e_no_white_space_allowed_before_separator_str[]\n\tINIT(= N_(\"E1242: No white space allowed before separator: %s\"));\n#endif\n#ifdef FEAT_GUI_GTK\nEXTERN char e_ascii_code_not_in_range[]\n\tINIT(= N_(\"E1243: ASCII code not in 32-127 range\"));\n#endif\n#ifdef FEAT_EVAL\n# if defined(FEAT_GUI) || defined(FEAT_TERMGUICOLORS)\nEXTERN char e_bad_color_string_str[]\n\tINIT(= N_(\"E1244: Bad color string: %s\"));\n# endif\nEXTERN char e_cannot_expand_sfile_in_vim9_function[]\n\tINIT(= N_(\"E1245: Cannot expand <sfile> in a Vim9 function\"));\nEXTERN char e_cannot_find_variable_to_unlock_str[]\n\tINIT(= N_(\"E1246: Cannot find variable to (un)lock: %s\"));\n#endif\nEXTERN char e_line_number_out_of_range[]\n\tINIT(= N_(\"E1247: Line number out of range\"));\n#ifdef FEAT_EVAL\nEXTERN char e_closure_called_from_invalid_context[]\n\tINIT(= N_(\"E1248: Closure called from invalid context\"));\n#endif\nEXTERN char e_highlight_group_name_too_long[]\n\tINIT(= N_(\"E1249: Highlight group name too long\"));\n#ifdef FEAT_EVAL\nEXTERN char e_argument_of_str_must_be_list_string_dictionary_or_blob[]\n\tINIT(= N_(\"E1250: Argument of %s must be a List, String, Dictionary or Blob\"));\nEXTERN char e_list_dict_blob_or_string_required_for_argument_nr[]\n\tINIT(= N_(\"E1251: List, Dictionary, Blob or String required for argument %d\"));\nEXTERN char e_string_list_or_blob_required_for_argument_nr[]\n\tINIT(= N_(\"E1252: String, List or Blob required for argument %d\"));\n// E1253 unused\nEXTERN char e_cannot_use_script_variable_in_for_loop[]\n\tINIT(= N_(\"E1254: Cannot use script variable in for loop\"));\n#endif\nEXTERN char e_cmd_mapping_must_end_with_cr[]\n\tINIT(= N_(\"E1255: <Cmd> mapping must end with <CR>\"));\n#ifdef FEAT_EVAL\nEXTERN char e_string_or_function_required_for_argument_nr[]\n\tINIT(= N_(\"E1256: String or function required for argument %d\"));\nEXTERN char e_imported_script_must_use_as_or_end_in_dot_vim_str[]\n\tINIT(= N_(\"E1257: Imported script must use \\\"as\\\" or end in .vim: %s\"));\nEXTERN char e_no_dot_after_imported_name_str[]\n\tINIT(= N_(\"E1258: No '.' after imported name: %s\"));\nEXTERN char e_missing_name_after_imported_name_str[]\n\tINIT(= N_(\"E1259: Missing name after imported name: %s\"));\nEXTERN char e_cannot_unlet_imported_item_str[]\n\tINIT(= N_(\"E1260: Cannot unlet an imported item: %s\"));\nEXTERN char e_cannot_import_dot_vim_without_using_as[]\n\tINIT(= N_(\"E1261: Cannot import .vim without using \\\"as\\\"\"));\nEXTERN char e_cannot_import_same_script_twice_str[]\n\tINIT(= N_(\"E1262: Cannot import the same script twice: %s\"));\nEXTERN char e_cannot_use_name_with_hash_in_vim9_script_use_export_instead[]\n\tINIT(= N_(\"E1263: Cannot use name with # in Vim9 script, use export instead\"));\nEXTERN char e_autoload_import_cannot_use_absolute_or_relative_path[]\n\tINIT(= N_(\"E1264: Autoload import cannot use absolute or relative path: %s\"));\nEXTERN char e_cannot_use_partial_here[]\n\tINIT(= N_(\"E1265: Cannot use a partial here\"));\n#endif\n#if defined(FEAT_PYTHON3) && defined(MSWIN)\nEXTERN char e_critical_error_in_python3_initialization_check_your_installation[]\n\tINIT(= N_(\"E1266: Critical error in python3 initialization, check your python3 installation\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_function_name_must_start_with_capital_str[]\n\tINIT(= N_(\"E1267: Function name must start with a capital: %s\"));\nEXTERN char e_cannot_use_s_colon_in_vim9_script_str[]\n\tINIT(= N_(\"E1268: Cannot use s: in Vim9 script: %s\"));\nEXTERN char e_cannot_create_vim9_script_variable_in_function_str[]\n\tINIT(= N_(\"E1269: Cannot create a Vim9 script variable in a function: %s\"));\n#endif\nEXTERN char e_cannot_use_s_backslash_in_vim9_script[]\n\tINIT(= N_(\"E1270: Cannot use :s\\\\/sub/ in Vim9 script\"));\n#ifdef FEAT_EVAL\nEXTERN char e_compiling_closure_without_context_str[]\n\tINIT(= N_(\"E1271: Compiling closure without context: %s\"));\nEXTERN char e_using_type_not_in_script_context_str[]\n\tINIT(= N_(\"E1272: Using type not in a script context: %s\"));\n#endif\nEXTERN char e_nfa_regexp_missing_value_in_chr[]\n\tINIT(= N_(\"E1273: (NFA regexp) missing value in '\\\\%%%c'\"));\nEXTERN char e_no_script_file_name_to_substitute_for_script[]\n\tINIT(= N_(\"E1274: No script file name to substitute for \\\"<script>\\\"\"));\n#ifdef FEAT_EVAL\nEXTERN char e_string_or_function_required_for_arrow_parens_expr[]\n\tINIT(= N_(\"E1275: String or function required for ->(expr)\"));\nEXTERN char e_illegal_map_mode_string_str[]\n\tINIT(= N_(\"E1276: Illegal map mode string: '%s'\"));\n# if !defined(FEAT_JOB_CHANNEL)\nEXTERN char e_channel_job_feature_not_available[]\n\tINIT(= N_(\"E1277: Channel and job feature is not available\"));\n# endif\nEXTERN char e_stray_closing_curly_str[]\n\tINIT(= N_(\"E1278: Stray '}' without a matching '{': %s\"));\nEXTERN char e_missing_close_curly_str[]\n\tINIT(= N_(\"E1279: Missing '}': %s\"));\n#endif\n#ifdef FEAT_SPELL\nEXTERN char e_illegal_character_in_word[]\n\tINIT(= N_(\"E1280: Illegal character in word\"));\n#endif\nEXTERN char e_atom_engine_must_be_at_start_of_pattern[]\n\tINIT(= N_(\"E1281: Atom '\\\\%%#=%c' must be at the start of the pattern\"));\n#ifdef FEAT_EVAL\nEXTERN char e_bitshift_ops_must_be_number[]\n\tINIT(= N_(\"E1282: Bitshift operands must be numbers\"));\nEXTERN char e_bitshift_ops_must_be_positive[]\n\tINIT(= N_(\"E1283: Bitshift amount must be a positive number\"));\n#endif\n#if defined(FEAT_PROP_POPUP)\nEXTERN char e_argument_1_list_item_nr_dictionary_required[]\n\tINIT(= N_(\"E1284: Argument 1, list item %d: Dictionary required\"));\n#endif\n#ifdef FEAT_RELTIME\nEXTERN char e_could_not_clear_timeout_str[]\n\tINIT(= N_(\"E1285: Could not clear timeout: %s\"));\nEXTERN char e_could_not_set_timeout_str[]\n\tINIT(= N_(\"E1286: Could not set timeout: %s\"));\n#ifndef PROF_NSEC\nEXTERN char e_could_not_set_handler_for_timeout_str[]\n\tINIT(= N_(\"E1287: Could not set handler for timeout: %s\"));\nEXTERN char e_could_not_reset_handler_for_timeout_str[]\n\tINIT(= N_(\"E1288: Could not reset handler for timeout: %s\"));\nEXTERN char e_could_not_check_for_pending_sigalrm_str[]\n\tINIT(= N_(\"E1289: Could not check for pending SIGALRM: %s\"));\n#endif\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_substitute_nesting_too_deep[]\n\tINIT(= N_(\"E1290: substitute nesting too deep\"));\nEXTERN char e_invalid_argument_nr[]\n\tINIT(= N_(\"E1291: Invalid argument: %ld\"));\n#endif\nEXTERN char e_cmdline_window_already_open[]\n\tINIT(= N_(\"E1292: Command-line window is already open\"));\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_cannot_use_negative_id_after_adding_textprop_with_text[]\n\tINIT(= N_(\"E1293: Cannot use a negative id after adding a textprop with text\"));\nEXTERN char e_can_only_use_text_align_when_column_is_zero[]\n\tINIT(= N_(\"E1294: Can only use text_align when column is zero\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_cannot_specify_both_type_and_types[]\n\tINIT(= N_(\"E1295: Cannot specify both 'type' and 'types'\"));\nEXTERN char e_can_only_use_left_padding_when_column_is_zero[]\n\tINIT(= N_(\"E1296: Can only use left padding when column is zero\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_non_null_dict_required_for_argument_nr[]\n\tINIT(= N_(\"E1297: Non-NULL Dictionary required for argument %d\"));\nEXTERN char e_non_null_list_required_for_argument_nr[]\n\tINIT(= N_(\"E1298: Non-NULL List required for argument %d\"));\n#endif\nEXTERN char e_window_unexpectedly_close_while_searching_for_tags[]\n\tINIT(= N_(\"E1299: Window unexpectedly closed while searching for tags\"));\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_use_partial_with_dictionary_for_defer[]\n\tINIT(= N_(\"E1300: Cannot use a partial with dictionary for :defer\"));\nEXTERN char e_string_number_list_or_blob_required_for_argument_nr[]\n\tINIT(= N_(\"E1301: String, Number, List or Blob required for argument %d\"));\nEXTERN char e_script_variable_was_deleted[]\n\tINIT(= N_(\"E1302: Script variable was deleted\"));\nEXTERN char e_custom_list_completion_function_does_not_return_list_but_str[]\n\tINIT(= N_(\"E1303: Custom list completion function does not return a List but a %s\"));\nEXTERN char e_cannot_use_type_with_this_variable_str[]\n\tINIT(= N_(\"E1304: Cannot use type with this variable: %s\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_cannot_use_length_endcol_and_endlnum_with_text[]\n\tINIT(= N_(\"E1305: Cannot use \\\"length\\\", \\\"end_col\\\" and \\\"end_lnum\\\" with \\\"text\\\"\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_loop_nesting_too_deep[]\n\tINIT(= N_(\"E1306: Loop nesting too deep\"));\nEXTERN char e_argument_nr_trying_to_modify_const_str[]\n\tINIT(= N_(\"E1307: Argument %d: Trying to modify a const %s\"));\nEXTERN char e_cannot_resize_window_in_another_tab_page[]\n\tINIT(= N_(\"E1308: Cannot resize a window in another tab page\"));\n#endif\nEXTERN char e_cannot_change_mappings_while_listing[]\n\tINIT(= N_(\"E1309: Cannot change mappings while listing\"));\n#if defined(FEAT_MENU)\nEXTERN char e_cannot_change_menus_while_listing[]\n\tINIT(= N_(\"E1310: Cannot change menus while listing\"));\n#endif\nEXTERN char e_cannot_change_user_commands_while_listing[]\n\tINIT(= N_(\"E1311: Cannot change user commands while listing\"));\nEXTERN char e_not_allowed_to_change_window_layout_in_this_autocmd[]\n\tINIT(= N_(\"E1312: Not allowed to change the window layout in this autocmd\"));\nEXTERN char e_not_allowed_to_add_or_remove_entries_str[]\n\tINIT(= N_(\"E1313: Not allowed to add or remove entries (%s)\"));\n#ifdef FEAT_EVAL\nEXTERN char e_class_name_must_start_with_uppercase_letter_str[]\n\tINIT(= N_(\"E1314: Class name must start with an uppercase letter: %s\"));\nEXTERN char e_white_space_required_after_name_str[]\n\tINIT(= N_(\"E1315: White space required after name: %s\"));\nEXTERN char e_class_can_only_be_defined_in_vim9_script[]\n\tINIT(= N_(\"E1316: Class can only be defined in Vim9 script\"));\nEXTERN char e_invalid_object_variable_declaration_str[]\n\tINIT(= N_(\"E1317: Invalid object variable declaration: %s\"));\nEXTERN char e_not_valid_command_in_class_str[]\n\tINIT(= N_(\"E1318: Not a valid command in a class: %s\"));\nEXTERN char e_using_class_as_number[]\n\tINIT(= N_(\"E1319: Using a class as a Number\"));\nEXTERN char e_using_object_as_number[]\n\tINIT(= N_(\"E1320: Using an object as a Number\"));\nEXTERN char e_using_class_as_float[]\n\tINIT(= N_(\"E1321: Using a class as a Float\"));\nEXTERN char e_using_object_as_float[]\n\tINIT(= N_(\"E1322: Using an object as a Float\"));\nEXTERN char e_using_class_as_string[]\n\tINIT(= N_(\"E1323: Using a class as a String\"));\nEXTERN char e_using_object_as_string[]\n\tINIT(= N_(\"E1324: Using an object as a String\"));\nEXTERN char e_method_not_found_on_class_str_str[]\n\tINIT(= N_(\"E1325: Method \\\"%s\\\" not found in class \\\"%s\\\"\"));\nEXTERN char e_variable_not_found_on_object_str_str[]\n\tINIT(= N_(\"E1326: Variable \\\"%s\\\" not found in object \\\"%s\\\"\"));\nEXTERN char e_object_required_found_str[]\n\tINIT(= N_(\"E1327: Object required, found %s\"));\nEXTERN char e_constructor_default_value_must_be_vnone_str[]\n\tINIT(= N_(\"E1328: Constructor default value must be v:none: %s\"));\n// E1329 unused\nEXTERN char e_invalid_type_for_object_variable_str[]\n\tINIT(= N_(\"E1330: Invalid type for object variable: %s\"));\nEXTERN char e_public_must_be_followed_by_this_or_static[]\n\tINIT(= N_(\"E1331: Public must be followed by \\\"this\\\" or \\\"static\\\"\"));\nEXTERN char e_public_variable_name_cannot_start_with_underscore_str[]\n\tINIT(= N_(\"E1332: Public variable name cannot start with underscore: %s\"));\nEXTERN char e_cannot_access_private_variable_str[]\n\tINIT(= N_(\"E1333: Cannot access private variable \\\"%s\\\" in class \\\"%s\\\"\"));\n// E1334 unused\nEXTERN char e_variable_is_not_writable_str[]\n\tINIT(= N_(\"E1335: Variable \\\"%s\\\" in class \\\"%s\\\" is not writable\"));\n#endif\nEXTERN char e_internal_error_shortmess_too_long[]\n\tINIT(= \"E1336: Internal error: shortmess too long\");\n#ifdef FEAT_EVAL\nEXTERN char e_class_variable_str_not_found_in_class_str[]\n\tINIT(= N_(\"E1337: Class variable \\\"%s\\\" not found in class \\\"%s\\\"\"));\n// E1338 unused\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_cannot_add_textprop_with_text_after_using_textprop_with_negative_id[]\n\tINIT(= N_(\"E1339: Cannot add a textprop with text after using a textprop with a negative id\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_argument_already_declared_in_class_str[]\n\tINIT(= N_(\"E1340: Argument already declared in the class: %s\"));\nEXTERN char e_variable_already_declared_in_class_str[]\n\tINIT(= N_(\"E1341: Variable already declared in the class: %s\"));\nEXTERN char e_interface_can_only_be_defined_in_vim9_script[]\n\tINIT(= N_(\"E1342: Interface can only be defined in Vim9 script\"));\nEXTERN char e_interface_name_must_start_with_uppercase_letter_str[]\n\tINIT(= N_(\"E1343: Interface name must start with an uppercase letter: %s\"));\nEXTERN char e_cannot_initialize_variable_in_interface[]\n\tINIT(= N_(\"E1344: Cannot initialize a variable in an interface\"));\nEXTERN char e_not_valid_command_in_interface_str[]\n\tINIT(= N_(\"E1345: Not a valid command in an interface: %s\"));\nEXTERN char e_interface_name_not_found_str[]\n\tINIT(= N_(\"E1346: Interface name not found: %s\"));\nEXTERN char e_not_valid_interface_str[]\n\tINIT(= N_(\"E1347: Not a valid interface: %s\"));\nEXTERN char e_variable_str_of_interface_str_not_implemented[]\n\tINIT(= N_(\"E1348: Variable \\\"%s\\\" of interface \\\"%s\\\" is not implemented\"));\nEXTERN char e_method_str_of_interface_str_not_implemented[]\n\tINIT(= N_(\"E1349: Method \\\"%s\\\" of interface \\\"%s\\\" is not implemented\"));\nEXTERN char e_duplicate_implements[]\n\tINIT(= N_(\"E1350: Duplicate \\\"implements\\\"\"));\nEXTERN char e_duplicate_interface_after_implements_str[]\n\tINIT(= N_(\"E1351: Duplicate interface after \\\"implements\\\": %s\"));\nEXTERN char e_duplicate_extends[]\n\tINIT(= N_(\"E1352: Duplicate \\\"extends\\\"\"));\nEXTERN char e_class_name_not_found_str[]\n\tINIT(= N_(\"E1353: Class name not found: %s\"));\nEXTERN char e_cannot_extend_str[]\n\tINIT(= N_(\"E1354: Cannot extend %s\"));\nEXTERN char e_duplicate_function_str[]\n\tINIT(= N_(\"E1355: Duplicate function: %s\"));\nEXTERN char e_super_must_be_followed_by_dot[]\n\tINIT(= N_(\"E1356: \\\"super\\\" must be followed by a dot\"));\nEXTERN char e_using_super_not_in_class_method[]\n\tINIT(= N_(\"E1357: Using \\\"super\\\" not in a class method\"));\nEXTERN char e_using_super_not_in_child_class[]\n\tINIT(= N_(\"E1358: Using \\\"super\\\" not in a child class\"));\nEXTERN char e_cannot_define_new_method_in_abstract_class[]\n\tINIT(= N_(\"E1359: Cannot define a \\\"new\\\" method in an abstract class\"));\nEXTERN char e_using_null_object[]\n\tINIT(= N_(\"E1360: Using a null object\"));\n#endif\nEXTERN char e_cannot_use_color_none_did_you_mean_none[]\n\tINIT(= N_(\"E1361: Cannot use color \\\"none\\\", did you mean \\\"NONE\\\"?\"));\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_use_non_null_object[]\n\tINIT(= N_(\"E1362: Cannot use a non-null object\"));\nEXTERN char e_incomplete_type[]\n\tINIT(= N_(\"E1363: Incomplete type\"));\n#endif\nEXTERN char e_warning_pointer_block_corrupted[]\n\tINIT(= N_(\"E1364: Warning: Pointer block corrupted\"));\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_use_a_return_type_with_new_method[]\n\tINIT(= N_(\"E1365: Cannot use a return type with the \\\"new\\\" method\"));\nEXTERN char e_cannot_access_private_method_str[]\n\tINIT(= N_(\"E1366: Cannot access private method: %s\"));\nEXTERN char e_variable_str_of_interface_str_has_different_access[]\n\tINIT(= N_(\"E1367: Access level of variable \\\"%s\\\" of interface \\\"%s\\\" is different\"));\nEXTERN char e_static_cannot_be_followed_by_this[]\n\tINIT(= N_(\"E1368: Static cannot be followed by \\\"this\\\" in a variable name\"));\nEXTERN char e_duplicate_variable_str[]\n\tINIT(= N_(\"E1369: Duplicate variable: %s\"));\nEXTERN char e_cannot_define_new_method_as_static[]\n\tINIT(= N_(\"E1370: Cannot define a \\\"new\\\" method as static\"));\nEXTERN char e_abstract_must_be_followed_by_def_or_static[]\n\tINIT(= N_(\"E1371: Abstract must be followed by \\\"def\\\" or \\\"static\\\"\"));\nEXTERN char e_abstract_method_in_concrete_class[]\n\tINIT(= N_(\"E1372: Abstract method \\\"%s\\\" cannot be defined in a concrete class\"));\nEXTERN char e_abstract_method_str_not_found[]\n\tINIT(= N_(\"E1373: Abstract method \\\"%s\\\" is not implemented\"));\nEXTERN char e_class_variable_str_accessible_only_inside_class_str[]\n\tINIT(= N_(\"E1374: Class variable \\\"%s\\\" accessible only inside class \\\"%s\\\"\"));\nEXTERN char e_class_variable_str_accessible_only_using_class_str[]\n\tINIT(= N_(\"E1375: Class variable \\\"%s\\\" accessible only using class \\\"%s\\\"\"));\nEXTERN char e_object_variable_str_accessible_only_using_object_str[]\n\tINIT(= N_(\"E1376: Object variable \\\"%s\\\" accessible only using class \\\"%s\\\" object\"));\nEXTERN char e_method_str_of_class_str_has_different_access[]\n\tINIT(= N_(\"E1377: Access level of method \\\"%s\\\" is different in class \\\"%s\\\"\"));\nEXTERN char e_static_member_not_supported_in_interface[]\n\tINIT(= N_(\"E1378: Static member not supported in an interface\"));\nEXTERN char e_private_variable_not_supported_in_interface[]\n\tINIT(= N_(\"E1379: Private variable not supported in an interface\"));\nEXTERN char e_private_method_not_supported_in_interface[]\n\tINIT(= N_(\"E1380: Private method not supported in an interface\"));\nEXTERN char e_interface_cannot_use_implements[]\n\tINIT(= N_(\"E1381: Interface cannot use \\\"implements\\\"\"));\nEXTERN char e_variable_str_type_mismatch_expected_str_but_got_str[]\n\tINIT(= N_(\"E1382: Variable \\\"%s\\\": type mismatch, expected %s but got %s\"));\nEXTERN char e_method_str_type_mismatch_expected_str_but_got_str[]\n\tINIT(= N_(\"E1383: Method \\\"%s\\\": type mismatch, expected %s but got %s\"));\nEXTERN char e_class_method_str_accessible_only_inside_class_str[]\n\tINIT(= N_(\"E1384: Class method \\\"%s\\\" accessible only inside class \\\"%s\\\"\"));\nEXTERN char e_class_method_str_accessible_only_using_class_str[]\n\tINIT(= N_(\"E1385: Class method \\\"%s\\\" accessible only using class \\\"%s\\\"\"));\nEXTERN char e_object_method_str_accessible_only_using_object_str[]\n\tINIT(= N_(\"E1386: Object method \\\"%s\\\" accessible only using class \\\"%s\\\" object\"));\nEXTERN char e_public_variable_not_supported_in_interface[]\n\tINIT(= N_(\"E1387: Public variable not supported in an interface\"));\nEXTERN char e_public_keyword_not_supported_for_method[]\n\tINIT(= N_(\"E1388: Public keyword not supported for a method\"));\nEXTERN char e_missing_name_after_implements[]\n\tINIT(= N_(\"E1389: Missing name after implements\"));\nEXTERN char e_cannot_use_an_object_variable_except_with_the_new_method_str[]\n\tINIT(= N_(\"E1390: Cannot use an object variable \\\"this.%s\\\" except with the \\\"new\\\" method\"));\nEXTERN char e_cannot_lock_object_variable_str[]\n\tINIT(= N_(\"E1391: Cannot (un)lock variable \\\"%s\\\" in class \\\"%s\\\"\"));\nEXTERN char e_cannot_lock_class_variable_str[]\n\tINIT(= N_(\"E1392: Cannot (un)lock class variable \\\"%s\\\" in class \\\"%s\\\"\"));\n#endif\n// E1393 - E1499 unused (reserved for Vim9 class support)\nEXTERN char e_cannot_mix_positional_and_non_positional_str[]\n\tINIT(= N_(\"E1500: Cannot mix positional and non-positional arguments: %s\"));\nEXTERN char e_fmt_arg_nr_unused_str[]\n\tINIT(= N_(\"E1501: format argument %d unused in $-style format: %s\"));\nEXTERN char e_positional_num_field_spec_reused_str_str[]\n\tINIT(= N_(\"E1502: Positional argument %d used as field width reused as different type: %s/%s\"));\nEXTERN char e_positional_nr_out_of_bounds_str[]\n\tINIT(= N_(\"E1503: Positional argument %d out of bounds: %s\"));\nEXTERN char e_positional_arg_num_type_inconsistent_str_str[]\n\tINIT(= N_(\"E1504: Positional argument %d type used inconsistently: %s/%s\"));\nEXTERN char e_invalid_format_specifier_str[]\n\tINIT(= N_(\"E1505: Invalid format specifier: %s\"));\nEXTERN char e_xattr_erange[]\n\tINIT(= N_(\"E1506: Buffer too small to copy xattr value or key\"));\nEXTERN char e_aptypes_is_null_nr_str[]\n\tINIT(= \"E1507: Internal error: ap_types or ap_types[idx] is NULL: %d: %s\");\nEXTERN char e_xattr_e2big[]\n\tINIT(= N_(\"E1508: Size of the extended attribute value is larger than the maximum size allowed\"));\nEXTERN char e_xattr_other[]\n\tINIT(= N_(\"E1509: Error occurred when reading or writing extended attribute\"));\nEXTERN char e_val_too_large[]\n\tINIT(= N_(\"E1510: Value too large: %s\"));\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * ex_getln.c: Functions for entering and editing an Ex command line.\n */\n\n#include \"vim.h\"\n\n#ifndef MAX\n# define MAX(x,y) ((x) > (y) ? (x) : (y))\n#endif\n\n// Return value when handling keys in command-line mode.\n#define CMDLINE_NOT_CHANGED\t1\n#define CMDLINE_CHANGED\t\t2\n#define GOTO_NORMAL_MODE\t3\n#define PROCESS_NEXT_KEY\t4\n\n// The current cmdline_info.  It is initialized in getcmdline() and after that\n// used by other functions.  When invoking getcmdline() recursively it needs\n// to be saved with save_cmdline() and restored with restore_cmdline().\nstatic cmdline_info_T ccline;\n\n#ifdef FEAT_EVAL\nstatic int\tnew_cmdpos;\t// position set by set_cmdline_pos()\n#endif\n\nstatic int\textra_char = NUL;  // extra character to display when redrawing\n\t\t\t\t   // the command line\nstatic int\textra_char_shift;\n\n#ifdef FEAT_RIGHTLEFT\nstatic int\tcmd_hkmap = 0;\t// Hebrew mapping during command line\n#endif\n\nstatic char_u\t*getcmdline_int(int firstc, long count, int indent, int clear_ccline);\nstatic int\tcmdline_charsize(int idx);\nstatic void\tset_cmdspos(void);\nstatic void\tset_cmdspos_cursor(void);\nstatic void\tcorrect_cmdspos(int idx, int cells);\nstatic void\talloc_cmdbuff(int len);\nstatic void\tdraw_cmdline(int start, int len);\nstatic void\tsave_cmdline(cmdline_info_T *ccp);\nstatic void\trestore_cmdline(cmdline_info_T *ccp);\nstatic int\tcmdline_paste(int regname, int literally, int remcr);\nstatic void\tredrawcmdprompt(void);\nstatic int\tccheck_abbr(int);\nstatic int\topen_cmdwin(void);\n#ifdef FEAT_SEARCH_EXTRA\nstatic int\tempty_pattern_magic(char_u *pat, size_t len, magic_T magic_val);\n#endif\n\nstatic int\tcedit_key = -1;\t// key value of 'cedit' option\n\n    static void\ntrigger_cmd_autocmd(int typechar, int evt)\n{\n    char_u\ttypestr[2];\n\n    typestr[0] = typechar;\n    typestr[1] = NUL;\n    apply_autocmds(evt, typestr, typestr, FALSE, curbuf);\n}\n\n/*\n * Abandon the command line.\n */\n    static void\nabandon_cmdline(void)\n{\n    VIM_CLEAR(ccline.cmdbuff);\n    if (msg_scrolled == 0)\n\tcompute_cmdrow();\n    msg(\"\");\n    redraw_cmdline = TRUE;\n}\n\n#ifdef FEAT_SEARCH_EXTRA\n/*\n * Guess that the pattern matches everything.  Only finds specific cases, such\n * as a trailing \\|, which can happen while typing a pattern.\n */\n    static int\nempty_pattern(char_u *p, int delim)\n{\n    size_t\tn = STRLEN(p);\n    magic_T\tmagic_val = MAGIC_ON;\n\n    if (n > 0)\n\t(void) skip_regexp_ex(p, delim, magic_isset(), NULL, NULL, &magic_val);\n    else\n\treturn TRUE;\n\n    return empty_pattern_magic(p, n, magic_val);\n}\n\n    static int\nempty_pattern_magic(char_u *p, size_t len, magic_T magic_val)\n{\n    // remove trailing \\v and the like\n    while (len >= 2 && p[len - 2] == '\\\\'\n\t\t\t&& vim_strchr((char_u *)\"mMvVcCZ\", p[len - 1]) != NULL)\n       len -= 2;\n\n    // true, if the pattern is empty, or the pattern ends with \\| and magic is\n    // set (or it ends with '|' and very magic is set)\n    return len == 0 || (len > 1\n\t    && ((p[len - 2] == '\\\\'\n\t\t\t\t && p[len - 1] == '|' && magic_val == MAGIC_ON)\n\t\t|| (p[len - 2] != '\\\\'\n\t\t\t     && p[len - 1] == '|' && magic_val == MAGIC_ALL)));\n}\n\n// Struct to store the viewstate during 'incsearch' highlighting.\ntypedef struct {\n    colnr_T\tvs_curswant;\n    colnr_T\tvs_leftcol;\n    colnr_T\tvs_skipcol;\n    linenr_T\tvs_topline;\n# ifdef FEAT_DIFF\n    int\t\tvs_topfill;\n# endif\n    linenr_T\tvs_botline;\n    linenr_T\tvs_empty_rows;\n} viewstate_T;\n\n    static void\nsave_viewstate(viewstate_T *vs)\n{\n    vs->vs_curswant = curwin->w_curswant;\n    vs->vs_leftcol = curwin->w_leftcol;\n    vs->vs_skipcol = curwin->w_skipcol;\n    vs->vs_topline = curwin->w_topline;\n# ifdef FEAT_DIFF\n    vs->vs_topfill = curwin->w_topfill;\n# endif\n    vs->vs_botline = curwin->w_botline;\n    vs->vs_empty_rows = curwin->w_empty_rows;\n}\n\n    static void\nrestore_viewstate(viewstate_T *vs)\n{\n    curwin->w_curswant = vs->vs_curswant;\n    curwin->w_leftcol = vs->vs_leftcol;\n    curwin->w_skipcol = vs->vs_skipcol;\n    curwin->w_topline = vs->vs_topline;\n# ifdef FEAT_DIFF\n    curwin->w_topfill = vs->vs_topfill;\n# endif\n    curwin->w_botline = vs->vs_botline;\n    curwin->w_empty_rows = vs->vs_empty_rows;\n}\n\n// Struct to store the state of 'incsearch' highlighting.\ntypedef struct {\n    pos_T\tsearch_start;\t// where 'incsearch' starts searching\n    pos_T\tsave_cursor;\n    int\t\twinid;\t\t// window where this state is valid\n    viewstate_T\tinit_viewstate;\n    viewstate_T\told_viewstate;\n    pos_T\tmatch_start;\n    pos_T\tmatch_end;\n    int\t\tdid_incsearch;\n    int\t\tincsearch_postponed;\n    optmagic_T\tmagic_overruled_save;\n} incsearch_state_T;\n\n    static void\ninit_incsearch_state(incsearch_state_T *is_state)\n{\n    is_state->winid = curwin->w_id;\n    is_state->match_start = curwin->w_cursor;\n    is_state->did_incsearch = FALSE;\n    is_state->incsearch_postponed = FALSE;\n    is_state->magic_overruled_save = magic_overruled;\n    CLEAR_POS(&is_state->match_end);\n    is_state->save_cursor = curwin->w_cursor;  // may be restored later\n    is_state->search_start = curwin->w_cursor;\n    save_viewstate(&is_state->init_viewstate);\n    save_viewstate(&is_state->old_viewstate);\n}\n\n/*\n * First move cursor to end of match, then to the start.  This\n * moves the whole match onto the screen when 'nowrap' is set.\n */\n    static void\nset_search_match(pos_T *t)\n{\n    t->lnum += search_match_lines;\n    t->col = search_match_endcol;\n    if (t->lnum > curbuf->b_ml.ml_line_count)\n    {\n\tt->lnum = curbuf->b_ml.ml_line_count;\n\tcoladvance((colnr_T)MAXCOL);\n    }\n}\n\n/*\n * Return TRUE when 'incsearch' highlighting is to be done.\n * Sets search_first_line and search_last_line to the address range.\n * May change the last search pattern.\n */\n    static int\ndo_incsearch_highlighting(\n\tint\t\t    firstc,\n\tint\t\t    *search_delim,\n\tincsearch_state_T   *is_state,\n\tint\t\t    *skiplen,\n\tint\t\t    *patlen)\n{\n    char_u\t*cmd;\n    cmdmod_T\tdummy_cmdmod;\n    char_u\t*p;\n    int\t\tdelim_optional = FALSE;\n    int\t\tdelim;\n    char_u\t*end;\n    char\t*dummy;\n    exarg_T\tea;\n    pos_T\tsave_cursor;\n    int\t\tuse_last_pat;\n    int\t\tretval = FALSE;\n    magic_T     magic = 0;\n\n    *skiplen = 0;\n    *patlen = ccline.cmdlen;\n\n    if (!p_is || cmd_silent)\n\treturn FALSE;\n\n    // by default search all lines\n    search_first_line = 0;\n    search_last_line = MAXLNUM;\n\n    if (firstc == '/' || firstc == '?')\n    {\n\t*search_delim = firstc;\n\treturn TRUE;\n    }\n    if (firstc != ':')\n\treturn FALSE;\n\n    ++emsg_off;\n    CLEAR_FIELD(ea);\n    ea.line1 = 1;\n    ea.line2 = 1;\n    ea.cmd = ccline.cmdbuff;\n    ea.addr_type = ADDR_LINES;\n\n    parse_command_modifiers(&ea, &dummy, &dummy_cmdmod, TRUE);\n\n    cmd = skip_range(ea.cmd, TRUE, NULL);\n    if (vim_strchr((char_u *)\"sgvl\", *cmd) == NULL)\n\tgoto theend;\n\n    // Skip over \"substitute\" to find the pattern separator.\n    for (p = cmd; ASCII_ISALPHA(*p); ++p)\n\t;\n    if (*skipwhite(p) == NUL)\n\tgoto theend;\n\n    if (STRNCMP(cmd, \"substitute\", p - cmd) == 0\n\t    || STRNCMP(cmd, \"smagic\", p - cmd) == 0\n\t    || STRNCMP(cmd, \"snomagic\", MAX(p - cmd, 3)) == 0\n\t    || STRNCMP(cmd, \"vglobal\", p - cmd) == 0)\n    {\n\tif (*cmd == 's' && cmd[1] == 'm')\n\t    magic_overruled = OPTION_MAGIC_ON;\n\telse if (*cmd == 's' && cmd[1] == 'n')\n\t    magic_overruled = OPTION_MAGIC_OFF;\n    }\n    else if (STRNCMP(cmd, \"sort\", MAX(p - cmd, 3)) == 0)\n    {\n\t// skip over ! and flags\n\tif (*p == '!')\n\t    p = skipwhite(p + 1);\n\twhile (ASCII_ISALPHA(*(p = skipwhite(p))))\n\t    ++p;\n\tif (*p == NUL)\n\t    goto theend;\n    }\n    else if (STRNCMP(cmd, \"vimgrep\", MAX(p - cmd, 3)) == 0\n\t|| STRNCMP(cmd, \"vimgrepadd\", MAX(p - cmd, 8)) == 0\n\t|| STRNCMP(cmd, \"lvimgrep\", MAX(p - cmd, 2)) == 0\n\t|| STRNCMP(cmd, \"lvimgrepadd\", MAX(p - cmd, 9)) == 0\n\t|| STRNCMP(cmd, \"global\", p - cmd) == 0)\n    {\n\t// skip over \"!\"\n\tif (*p == '!')\n\t{\n\t    p++;\n\t    if (*skipwhite(p) == NUL)\n\t\tgoto theend;\n\t}\n\tif (*cmd != 'g')\n\t    delim_optional = TRUE;\n    }\n    else\n\tgoto theend;\n\n    p = skipwhite(p);\n    delim = (delim_optional && vim_isIDc(*p)) ? ' ' : *p++;\n    *search_delim = delim;\n    end = skip_regexp_ex(p, delim, magic_isset(), NULL, NULL, &magic);\n\n    use_last_pat = end == p && *end == delim;\n\n    if (end == p && !use_last_pat)\n\tgoto theend;\n\n    // Don't do 'hlsearch' highlighting if the pattern matches everything.\n    if (!use_last_pat)\n    {\n\tchar c = *end;\n\tint  empty;\n\n\t*end = NUL;\n\tempty = empty_pattern_magic(p, STRLEN(p), magic);\n\t*end = c;\n\tif (empty)\n\t    goto theend;\n    }\n\n    // found a non-empty pattern or //\n    *skiplen = (int)(p - ccline.cmdbuff);\n    *patlen = (int)(end - p);\n\n    // parse the address range\n    save_cursor = curwin->w_cursor;\n    curwin->w_cursor = is_state->search_start;\n    parse_cmd_address(&ea, &dummy, TRUE);\n    if (ea.addr_count > 0)\n    {\n\t// Allow for reverse match.\n\tif (ea.line2 < ea.line1)\n\t{\n\t    search_first_line = ea.line2;\n\t    search_last_line = ea.line1;\n\t}\n\telse\n\t{\n\t    search_first_line = ea.line1;\n\t    search_last_line = ea.line2;\n\t}\n    }\n    else if (cmd[0] == 's' && cmd[1] != 'o')\n    {\n\t// :s defaults to the current line\n\tsearch_first_line = curwin->w_cursor.lnum;\n\tsearch_last_line = curwin->w_cursor.lnum;\n    }\n\n    curwin->w_cursor = save_cursor;\n    retval = TRUE;\ntheend:\n    --emsg_off;\n    return retval;\n}\n\n    static void\nfinish_incsearch_highlighting(\n\tint gotesc,\n\tincsearch_state_T *is_state,\n\tint call_update_screen)\n{\n    if (!is_state->did_incsearch)\n\treturn;\n\n    is_state->did_incsearch = FALSE;\n    if (gotesc)\n\tcurwin->w_cursor = is_state->save_cursor;\n    else\n    {\n\tif (!EQUAL_POS(is_state->save_cursor, is_state->search_start))\n\t{\n\t    // put the '\" mark at the original position\n\t    curwin->w_cursor = is_state->save_cursor;\n\t    setpcmark();\n\t}\n\tcurwin->w_cursor = is_state->search_start;\n    }\n    restore_viewstate(&is_state->old_viewstate);\n    highlight_match = FALSE;\n\n    // by default search all lines\n    search_first_line = 0;\n    search_last_line = MAXLNUM;\n\n    magic_overruled = is_state->magic_overruled_save;\n\n    validate_cursor();\t// needed for TAB\n    status_redraw_all();\n    redraw_all_later(UPD_SOME_VALID);\n    if (call_update_screen)\n\tupdate_screen(UPD_SOME_VALID);\n}\n\n/*\n * Do 'incsearch' highlighting if desired.\n */\n    static void\nmay_do_incsearch_highlighting(\n\tint\t\t    firstc,\n\tlong\t\t    count,\n\tincsearch_state_T   *is_state)\n{\n    int\t\tskiplen, patlen;\n    int\t\tfound;  // do_search() result\n    pos_T\tend_pos;\n#ifdef FEAT_RELTIME\n    searchit_arg_T sia;\n#endif\n    int\t\tnext_char;\n    int\t\tuse_last_pat;\n    int\t\tdid_do_incsearch = is_state->did_incsearch;\n    int\t\tsearch_delim;\n\n    // Parsing range may already set the last search pattern.\n    // NOTE: must call restore_last_search_pattern() before returning!\n    save_last_search_pattern();\n\n    if (!do_incsearch_highlighting(firstc, &search_delim, is_state,\n\t\t\t\t\t\t\t    &skiplen, &patlen))\n    {\n\trestore_last_search_pattern();\n\tfinish_incsearch_highlighting(FALSE, is_state, TRUE);\n\tif (did_do_incsearch && vpeekc() == NUL)\n\t    // may have skipped a redraw, do it now\n\t    redrawcmd();\n\treturn;\n    }\n\n    // If there is a character waiting, search and redraw later.\n    if (char_avail())\n    {\n\trestore_last_search_pattern();\n\tis_state->incsearch_postponed = TRUE;\n\treturn;\n    }\n    is_state->incsearch_postponed = FALSE;\n\n    if (search_first_line == 0)\n\t// start at the original cursor position\n\tcurwin->w_cursor = is_state->search_start;\n    else if (search_first_line > curbuf->b_ml.ml_line_count)\n    {\n\t// start after the last line\n\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\tcurwin->w_cursor.col = MAXCOL;\n    }\n    else\n    {\n\t// start at the first line in the range\n\tcurwin->w_cursor.lnum = search_first_line;\n\tcurwin->w_cursor.col = 0;\n    }\n\n    // Use the previous pattern for \":s//\".\n    next_char = ccline.cmdbuff[skiplen + patlen];\n    use_last_pat = patlen == 0 && skiplen > 0\n\t\t\t\t   && ccline.cmdbuff[skiplen - 1] == next_char;\n\n    // If there is no pattern, don't do anything.\n    if (patlen == 0 && !use_last_pat)\n    {\n\tfound = 0;\n\tset_no_hlsearch(TRUE); // turn off previous highlight\n\tredraw_all_later(UPD_SOME_VALID);\n    }\n    else\n    {\n\tint search_flags = SEARCH_OPT + SEARCH_NOOF + SEARCH_PEEK;\n\n\tcursor_off();\t// so the user knows we're busy\n\tout_flush();\n\t++emsg_off;\t// so it doesn't beep if bad expr\n\tif (!p_hls)\n\t    search_flags += SEARCH_KEEP;\n\tif (search_first_line != 0)\n\t    search_flags += SEARCH_START;\n\tccline.cmdbuff[skiplen + patlen] = NUL;\n#ifdef FEAT_RELTIME\n\tCLEAR_FIELD(sia);\n\t// Set the time limit to half a second.\n\tsia.sa_tm = 500;\n#endif\n\tfound = do_search(NULL, firstc == ':' ? '/' : firstc, search_delim,\n\t\t\t\t ccline.cmdbuff + skiplen, count, search_flags,\n#ifdef FEAT_RELTIME\n\t\t&sia\n#else\n\t\tNULL\n#endif\n\t\t);\n\tccline.cmdbuff[skiplen + patlen] = next_char;\n\t--emsg_off;\n\n\tif (curwin->w_cursor.lnum < search_first_line\n\t\t|| curwin->w_cursor.lnum > search_last_line)\n\t{\n\t    // match outside of address range\n\t    found = 0;\n\t    curwin->w_cursor = is_state->search_start;\n\t}\n\n\t// if interrupted while searching, behave like it failed\n\tif (got_int)\n\t{\n\t    (void)vpeekc();\t// remove <C-C> from input stream\n\t    got_int = FALSE;\t// don't abandon the command line\n\t    found = 0;\n\t}\n\telse if (char_avail())\n\t    // cancelled searching because a char was typed\n\t    is_state->incsearch_postponed = TRUE;\n    }\n    if (found != 0)\n\thighlight_match = TRUE;\t\t// highlight position\n    else\n\thighlight_match = FALSE;\t// remove highlight\n\n    // First restore the old curwin values, so the screen is positioned in the\n    // same way as the actual search command.\n    restore_viewstate(&is_state->old_viewstate);\n    changed_cline_bef_curs();\n    update_topline();\n\n    if (found != 0)\n    {\n\tpos_T\t    save_pos = curwin->w_cursor;\n\n\tis_state->match_start = curwin->w_cursor;\n\tset_search_match(&curwin->w_cursor);\n\tvalidate_cursor();\n\tend_pos = curwin->w_cursor;\n\tis_state->match_end = end_pos;\n\tcurwin->w_cursor = save_pos;\n    }\n    else\n\tend_pos = curwin->w_cursor; // shutup gcc 4\n\n    // Disable 'hlsearch' highlighting if the pattern matches everything.\n    // Avoids a flash when typing \"foo\\|\".\n    if (!use_last_pat)\n    {\n\tnext_char = ccline.cmdbuff[skiplen + patlen];\n\tccline.cmdbuff[skiplen + patlen] = NUL;\n\tif (empty_pattern(ccline.cmdbuff + skiplen, search_delim)\n\t\t\t\t\t\t\t       && !no_hlsearch)\n\t{\n\t    redraw_all_later(UPD_SOME_VALID);\n\t    set_no_hlsearch(TRUE);\n\t}\n\tccline.cmdbuff[skiplen + patlen] = next_char;\n    }\n\n    validate_cursor();\n\n    // May redraw the status line to show the cursor position.\n    if (p_ru && curwin->w_status_height > 0)\n\tcurwin->w_redr_status = TRUE;\n\n    update_screen(UPD_SOME_VALID);\n    highlight_match = FALSE;\n    restore_last_search_pattern();\n\n    // Leave it at the end to make CTRL-R CTRL-W work.  But not when beyond the\n    // end of the pattern, e.g. for \":s/pat/\".\n    if (ccline.cmdbuff[skiplen + patlen] != NUL)\n\tcurwin->w_cursor = is_state->search_start;\n    else if (found != 0)\n\tcurwin->w_cursor = end_pos;\n\n    msg_starthere();\n    redrawcmdline();\n    is_state->did_incsearch = TRUE;\n}\n\n/*\n * May adjust 'incsearch' highlighting for typing CTRL-G and CTRL-T, go to next\n * or previous match.\n * Returns FAIL when jumping to cmdline_not_changed;\n */\n    static int\nmay_adjust_incsearch_highlighting(\n\tint\t\t\tfirstc,\n\tlong\t\t\tcount,\n\tincsearch_state_T\t*is_state,\n\tint\t\t\tc)\n{\n    int\t    skiplen, patlen;\n    pos_T   t;\n    char_u  *pat;\n    int\t    search_flags = SEARCH_NOOF;\n    int\t    i;\n    int\t    save;\n    int\t    search_delim;\n\n    // Parsing range may already set the last search pattern.\n    // NOTE: must call restore_last_search_pattern() before returning!\n    save_last_search_pattern();\n\n    if (!do_incsearch_highlighting(firstc, &search_delim, is_state,\n\t\t\t\t\t\t\t    &skiplen, &patlen))\n    {\n\trestore_last_search_pattern();\n\treturn OK;\n    }\n    if (patlen == 0 && ccline.cmdbuff[skiplen] == NUL)\n    {\n\trestore_last_search_pattern();\n\treturn FAIL;\n    }\n\n    if (search_delim == ccline.cmdbuff[skiplen])\n    {\n\tpat = last_search_pattern();\n\tif (pat == NULL)\n\t{\n\t    restore_last_search_pattern();\n\t    return FAIL;\n\t}\n\tskiplen = 0;\n\tpatlen = (int)STRLEN(pat);\n    }\n    else\n\tpat = ccline.cmdbuff + skiplen;\n\n    cursor_off();\n    out_flush();\n    if (c == Ctrl_G)\n    {\n\tt = is_state->match_end;\n\tif (LT_POS(is_state->match_start, is_state->match_end))\n\t    // Start searching at the end of the match not at the beginning of\n\t    // the next column.\n\t    (void)decl(&t);\n\tsearch_flags += SEARCH_COL;\n    }\n    else\n\tt = is_state->match_start;\n    if (!p_hls)\n\tsearch_flags += SEARCH_KEEP;\n    ++emsg_off;\n    save = pat[patlen];\n    pat[patlen] = NUL;\n    i = searchit(curwin, curbuf, &t, NULL,\n\t\t c == Ctrl_G ? FORWARD : BACKWARD,\n\t\t pat, count, search_flags, RE_SEARCH, NULL);\n    --emsg_off;\n    pat[patlen] = save;\n    if (i)\n    {\n\tis_state->search_start = is_state->match_start;\n\tis_state->match_end = t;\n\tis_state->match_start = t;\n\tif (c == Ctrl_T && firstc != '?')\n\t{\n\t    // Move just before the current match, so that when nv_search\n\t    // finishes the cursor will be put back on the match.\n\t    is_state->search_start = t;\n\t    (void)decl(&is_state->search_start);\n\t}\n\telse if (c == Ctrl_G && firstc == '?')\n\t{\n\t    // Move just after the current match, so that when nv_search\n\t    // finishes the cursor will be put back on the match.\n\t    is_state->search_start = t;\n\t    (void)incl(&is_state->search_start);\n\t}\n\tif (LT_POS(t, is_state->search_start) && c == Ctrl_G)\n\t{\n\t    // wrap around\n\t    is_state->search_start = t;\n\t    if (firstc == '?')\n\t\t(void)incl(&is_state->search_start);\n\t    else\n\t\t(void)decl(&is_state->search_start);\n\t}\n\n\tset_search_match(&is_state->match_end);\n\tcurwin->w_cursor = is_state->match_start;\n\tchanged_cline_bef_curs();\n\tupdate_topline();\n\tvalidate_cursor();\n\thighlight_match = TRUE;\n\tsave_viewstate(&is_state->old_viewstate);\n\tupdate_screen(UPD_NOT_VALID);\n\thighlight_match = FALSE;\n\tredrawcmdline();\n\tcurwin->w_cursor = is_state->match_end;\n    }\n    else\n\tvim_beep(BO_ERROR);\n    restore_last_search_pattern();\n    return FAIL;\n}\n\n/*\n * When CTRL-L typed: add character from the match to the pattern.\n * May set \"*c\" to the added character.\n * Return OK when jumping to cmdline_not_changed.\n */\n    static int\nmay_add_char_to_search(int firstc, int *c, incsearch_state_T *is_state)\n{\n    int\t\tskiplen, patlen, search_delim;\n\n    // Parsing range may already set the last search pattern.\n    // NOTE: must call restore_last_search_pattern() before returning!\n    save_last_search_pattern();\n\n    if (!do_incsearch_highlighting(firstc, &search_delim, is_state,\n\t\t\t\t\t\t\t    &skiplen, &patlen))\n    {\n\trestore_last_search_pattern();\n\treturn FAIL;\n    }\n    restore_last_search_pattern();\n\n    // Add a character from under the cursor for 'incsearch'.\n    if (is_state->did_incsearch)\n    {\n\tcurwin->w_cursor = is_state->match_end;\n\t*c = gchar_cursor();\n\tif (*c != NUL)\n\t{\n\t    // If 'ignorecase' and 'smartcase' are set and the\n\t    // command line has no uppercase characters, convert\n\t    // the character to lowercase.\n\t    if (p_ic && p_scs && !pat_has_uppercase(ccline.cmdbuff + skiplen))\n\t\t*c = MB_TOLOWER(*c);\n\t    if (*c == search_delim || vim_strchr((char_u *)(\n\t\t\t     magic_isset() ? \"\\\\~^$.*[\" : \"\\\\^$\"), *c) != NULL)\n\t    {\n\t\t// put a backslash before special characters\n\t\tstuffcharReadbuff(*c);\n\t\t*c = '\\\\';\n\t    }\n\t    // add any composing characters\n\t    if (mb_char2len(*c) != mb_ptr2len(ml_get_cursor()))\n\t    {\n\t\tint save_c = *c;\n\n\t\twhile (mb_char2len(*c) != mb_ptr2len(ml_get_cursor()))\n\t\t{\n\t\t    curwin->w_cursor.col += mb_char2len(*c);\n\t\t    *c = gchar_cursor();\n\t\t    stuffcharReadbuff(*c);\n\t\t}\n\t\t*c = save_c;\n\t    }\n\t    return FAIL;\n\t}\n    }\n    return OK;\n}\n#endif\n\n#ifdef FEAT_ARABIC\n/*\n * Return TRUE if the command line has an Arabic character at or after \"start\"\n * for \"len\" bytes.\n */\n    static int\ncmdline_has_arabic(int start, int len)\n{\n    int\t    j;\n    int\t    mb_l;\n    int\t    u8c;\n    char_u  *p;\n    int\t    u8cc[MAX_MCO];\n\n    if (!enc_utf8)\n\treturn FALSE;\n\n    for (j = start; j < start + len; j += mb_l)\n    {\n\tp = ccline.cmdbuff + j;\n\tu8c = utfc_ptr2char_len(p, u8cc, start + len - j);\n\tmb_l = utfc_ptr2len_len(p, start + len - j);\n\tif (ARABIC_CHAR(u8c))\n\t    return TRUE;\n    }\n    return FALSE;\n}\n#endif\n\n    void\ncmdline_init(void)\n{\n    CLEAR_FIELD(ccline);\n}\n\n/*\n * Handle CTRL-\\ pressed in Command-line mode:\n * - CTRL-\\ CTRL-N goes to Normal mode\n * - CTRL-\\ CTRL-G goes to Insert mode when 'insertmode' is set\n * - CTRL-\\ e prompts for an expression.\n */\n    static int\ncmdline_handle_ctrl_bsl(int c, int *gotesc)\n{\n    ++no_mapping;\n    ++allow_keys;\n    c = plain_vgetc();\n    --no_mapping;\n    --allow_keys;\n\n    // CTRL-\\ e doesn't work when obtaining an expression, unless it\n    // is in a mapping.\n    if (c != Ctrl_N && c != Ctrl_G && (c != 'e'\n\t\t|| (ccline.cmdfirstc == '=' && KeyTyped)\n#ifdef FEAT_EVAL\n\t\t|| cmdline_star > 0\n#endif\n\t\t))\n    {\n\tvungetc(c);\n\treturn PROCESS_NEXT_KEY;\n    }\n\n#ifdef FEAT_EVAL\n    if (c == 'e')\n    {\n\tchar_u\t*p = NULL;\n\tint\tlen;\n\n\t/*\n\t * Replace the command line with the result of an expression.\n\t * This will call getcmdline() recursively in get_expr_register().\n\t */\n\tif (ccline.cmdpos == ccline.cmdlen)\n\t    new_cmdpos = 99999;\t// keep it at the end\n\telse\n\t    new_cmdpos = ccline.cmdpos;\n\n\tc = get_expr_register();\n\tif (c == '=')\n\t{\n\t    // Evaluate the expression.  Set \"textlock\" to avoid nasty things\n\t    // like going to another buffer.\n\t    ++textlock;\n\t    p = get_expr_line();\n\t    --textlock;\n\n\t    if (p != NULL)\n\t    {\n\t\tlen = (int)STRLEN(p);\n\t\tif (realloc_cmdbuff(len + 1) == OK)\n\t\t{\n\t\t    ccline.cmdlen = len;\n\t\t    STRCPY(ccline.cmdbuff, p);\n\t\t    vim_free(p);\n\n\t\t    // Restore the cursor or use the position set with\n\t\t    // set_cmdline_pos().\n\t\t    if (new_cmdpos > ccline.cmdlen)\n\t\t\tccline.cmdpos = ccline.cmdlen;\n\t\t    else\n\t\t\tccline.cmdpos = new_cmdpos;\n\n\t\t    KeyTyped = FALSE;\t// Don't do p_wc completion.\n\t\t    redrawcmd();\n\t\t    return CMDLINE_CHANGED;\n\t\t}\n\t\tvim_free(p);\n\t    }\n\t}\n\tbeep_flush();\n\tgot_int = FALSE;\t// don't abandon the command line\n\tdid_emsg = FALSE;\n\temsg_on_display = FALSE;\n\tredrawcmd();\n\treturn CMDLINE_NOT_CHANGED;\n    }\n#endif\n\n    if (c == Ctrl_G && p_im && restart_edit == 0)\n\trestart_edit = 'a';\n    *gotesc = TRUE;\t// will free ccline.cmdbuff after putting it\n\t\t\t// in history\n    return GOTO_NORMAL_MODE;\n}\n\n/*\n * Completion for 'wildchar' or 'wildcharm' key.\n * - hitting <ESC> twice means: abandon command line.\n * - wildcard expansion is only done when the 'wildchar' key is really\n *   typed, not when it comes from a macro\n * Returns CMDLINE_CHANGED if command line is changed or CMDLINE_NOT_CHANGED.\n */\n    static int\ncmdline_wildchar_complete(\n\tint\t\tc,\n\tint\t\tescape,\n\tint\t\t*did_wild_list,\n\tint\t\t*wim_index_p,\n\texpand_T\t*xp,\n\tint\t\t*gotesc)\n{\n    int\t\twim_index = *wim_index_p;\n    int\t\tres;\n    int\t\tj;\n    int\t\toptions = WILD_NO_BEEP;\n\n    if (wim_flags[wim_index] & WIM_BUFLASTUSED)\n\toptions |= WILD_BUFLASTUSED;\n    if (xp->xp_numfiles > 0)   // typed p_wc at least twice\n    {\n\t// if 'wildmode' contains \"list\" may still need to list\n\tif (xp->xp_numfiles > 1\n\t\t&& !*did_wild_list\n\t\t&& ((wim_flags[wim_index] & WIM_LIST)\n\t\t    || (p_wmnu && (wim_flags[wim_index] & WIM_FULL) != 0)))\n\t{\n\t    (void)showmatches(xp,\n\t\t    p_wmnu && ((wim_flags[wim_index] & WIM_LIST) == 0));\n\t    redrawcmd();\n\t    *did_wild_list = TRUE;\n\t}\n\tif (wim_flags[wim_index] & WIM_LONGEST)\n\t    res = nextwild(xp, WILD_LONGEST, options, escape);\n\telse if (wim_flags[wim_index] & WIM_FULL)\n\t    res = nextwild(xp, WILD_NEXT, options, escape);\n\telse\n\t    res = OK;\t    // don't insert 'wildchar' now\n    }\n    else\t\t    // typed p_wc first time\n    {\n\twim_index = 0;\n\tj = ccline.cmdpos;\n\t// if 'wildmode' first contains \"longest\", get longest\n\t// common part\n\tif (wim_flags[0] & WIM_LONGEST)\n\t    res = nextwild(xp, WILD_LONGEST, options, escape);\n\telse\n\t    res = nextwild(xp, WILD_EXPAND_KEEP, options, escape);\n\n\t// if interrupted while completing, behave like it failed\n\tif (got_int)\n\t{\n\t    (void)vpeekc();\t// remove <C-C> from input stream\n\t    got_int = FALSE;\t// don't abandon the command line\n\t    (void)ExpandOne(xp, NULL, NULL, 0, WILD_FREE);\n\t    xp->xp_context = EXPAND_NOTHING;\n\t    *wim_index_p = wim_index;\n\t    return CMDLINE_CHANGED;\n\t}\n\n\t// when more than one match, and 'wildmode' first contains\n\t// \"list\", or no change and 'wildmode' contains \"longest,list\",\n\t// list all matches\n\tif (res == OK && xp->xp_numfiles > 1)\n\t{\n\t    // a \"longest\" that didn't do anything is skipped (but not\n\t    // \"list:longest\")\n\t    if (wim_flags[0] == WIM_LONGEST && ccline.cmdpos == j)\n\t\twim_index = 1;\n\t    if ((wim_flags[wim_index] & WIM_LIST)\n\t\t    || (p_wmnu && (wim_flags[wim_index] & WIM_FULL) != 0))\n\t    {\n\t\tif (!(wim_flags[0] & WIM_LONGEST))\n\t\t{\n\t\t    int p_wmnu_save = p_wmnu;\n\n\t\t    p_wmnu = 0;\n\n\t\t    // remove match\n\t\t    nextwild(xp, WILD_PREV, 0, escape);\n\t\t    p_wmnu = p_wmnu_save;\n\t\t}\n\t\t(void)showmatches(xp, p_wmnu\n\t\t\t&& ((wim_flags[wim_index] & WIM_LIST) == 0));\n\t\tredrawcmd();\n\t\t*did_wild_list = TRUE;\n\t\tif (wim_flags[wim_index] & WIM_LONGEST)\n\t\t    nextwild(xp, WILD_LONGEST, options, escape);\n\t\telse if (wim_flags[wim_index] & WIM_FULL)\n\t\t    nextwild(xp, WILD_NEXT, options, escape);\n\t    }\n\t    else\n\t\tvim_beep(BO_WILD);\n\t}\n\telse if (xp->xp_numfiles == -1)\n\t    xp->xp_context = EXPAND_NOTHING;\n    }\n    if (wim_index < 3)\n\t++wim_index;\n    if (c == ESC)\n\t*gotesc = TRUE;\n\n    *wim_index_p = wim_index;\n    return (res == OK) ? CMDLINE_CHANGED : CMDLINE_NOT_CHANGED;\n}\n\n/*\n * Handle backspace, delete and CTRL-W keys in the command-line mode.\n * Returns:\n *  CMDLINE_NOT_CHANGED - if the command line is not changed\n *  CMDLINE_CHANGED - if the command line is changed\n *  GOTO_NORMAL_MODE - go back to normal mode\n */\n    static int\ncmdline_erase_chars(\n\tint c,\n\tint indent\n#ifdef FEAT_SEARCH_EXTRA\n\t, incsearch_state_T *isp\n#endif\n\t)\n{\n    int\t\ti;\n    int\t\tj;\n\n    if (c == K_KDEL)\n\tc = K_DEL;\n\n    /*\n     * Delete current character is the same as backspace on next\n     * character, except at end of line.\n     */\n    if (c == K_DEL && ccline.cmdpos != ccline.cmdlen)\n\t++ccline.cmdpos;\n    if (has_mbyte && c == K_DEL)\n\tccline.cmdpos += mb_off_next(ccline.cmdbuff,\n\t\tccline.cmdbuff + ccline.cmdpos);\n    if (ccline.cmdpos > 0)\n    {\n\tchar_u *p;\n\n\tj = ccline.cmdpos;\n\tp = ccline.cmdbuff + j;\n\tif (has_mbyte)\n\t{\n\t    p = mb_prevptr(ccline.cmdbuff, p);\n\t    if (c == Ctrl_W)\n\t    {\n\t\twhile (p > ccline.cmdbuff && vim_isspace(*p))\n\t\t    p = mb_prevptr(ccline.cmdbuff, p);\n\t\ti = mb_get_class(p);\n\t\twhile (p > ccline.cmdbuff && mb_get_class(p) == i)\n\t\t    p = mb_prevptr(ccline.cmdbuff, p);\n\t\tif (mb_get_class(p) != i)\n\t\t    p += (*mb_ptr2len)(p);\n\t    }\n\t}\n\telse if (c == Ctrl_W)\n\t{\n\t    while (p > ccline.cmdbuff && vim_isspace(p[-1]))\n\t\t--p;\n\t    if (p > ccline.cmdbuff)\n\t    {\n\t\ti = vim_iswordc(p[-1]);\n\t\twhile (p > ccline.cmdbuff && !vim_isspace(p[-1])\n\t\t\t&& vim_iswordc(p[-1]) == i)\n\t\t    --p;\n\t    }\n\t}\n\telse\n\t    --p;\n\tccline.cmdpos = (int)(p - ccline.cmdbuff);\n\tccline.cmdlen -= j - ccline.cmdpos;\n\ti = ccline.cmdpos;\n\twhile (i < ccline.cmdlen)\n\t    ccline.cmdbuff[i++] = ccline.cmdbuff[j++];\n\n\t// Truncate at the end, required for multi-byte chars.\n\tccline.cmdbuff[ccline.cmdlen] = NUL;\n#ifdef FEAT_SEARCH_EXTRA\n\tif (ccline.cmdlen == 0)\n\t{\n\t    isp->search_start = isp->save_cursor;\n\t    // save view settings, so that the screen\n\t    // won't be restored at the wrong position\n\t    isp->old_viewstate = isp->init_viewstate;\n\t}\n#endif\n\tredrawcmd();\n    }\n    else if (ccline.cmdlen == 0 && c != Ctrl_W\n\t    && ccline.cmdprompt == NULL && indent == 0)\n    {\n\t// In ex and debug mode it doesn't make sense to return.\n\tif (exmode_active\n#ifdef FEAT_EVAL\n\t\t|| ccline.cmdfirstc == '>'\n#endif\n\t   )\n\t    return CMDLINE_NOT_CHANGED;\n\n\tVIM_CLEAR(ccline.cmdbuff);\t// no commandline to return\n\tif (!cmd_silent)\n\t{\n#ifdef FEAT_RIGHTLEFT\n\t    if (cmdmsg_rl)\n\t\tmsg_col = Columns;\n\t    else\n#endif\n\t\tmsg_col = 0;\n\t    msg_putchar(' ');\t\t// delete ':'\n\t}\n#ifdef FEAT_SEARCH_EXTRA\n\tif (ccline.cmdlen == 0)\n\t    isp->search_start = isp->save_cursor;\n#endif\n\tredraw_cmdline = TRUE;\n\treturn GOTO_NORMAL_MODE;\n    }\n    return CMDLINE_CHANGED;\n}\n\n/*\n * Handle the CTRL-^ key in the command-line mode and toggle the use of the\n * language :lmap mappings and/or Input Method.\n */\n    static void\ncmdline_toggle_langmap(long *b_im_ptr)\n{\n    if (map_to_exists_mode((char_u *)\"\", MODE_LANGMAP, FALSE))\n    {\n\t// \":lmap\" mappings exists, toggle use of mappings.\n\tState ^= MODE_LANGMAP;\n#ifdef HAVE_INPUT_METHOD\n\tim_set_active(FALSE);\t// Disable input method\n#endif\n\tif (b_im_ptr != NULL)\n\t{\n\t    if (State & MODE_LANGMAP)\n\t\t*b_im_ptr = B_IMODE_LMAP;\n\t    else\n\t\t*b_im_ptr = B_IMODE_NONE;\n\t}\n    }\n#ifdef HAVE_INPUT_METHOD\n    else\n    {\n\t// There are no \":lmap\" mappings, toggle IM.  When\n\t// 'imdisable' is set don't try getting the status, it's\n\t// always off.\n\tif ((p_imdisable && b_im_ptr != NULL)\n\t\t? *b_im_ptr == B_IMODE_IM : im_get_status())\n\t{\n\t    im_set_active(FALSE);\t// Disable input method\n\t    if (b_im_ptr != NULL)\n\t\t*b_im_ptr = B_IMODE_NONE;\n\t}\n\telse\n\t{\n\t    im_set_active(TRUE);\t// Enable input method\n\t    if (b_im_ptr != NULL)\n\t\t*b_im_ptr = B_IMODE_IM;\n\t}\n    }\n#endif\n    if (b_im_ptr != NULL)\n    {\n\tif (b_im_ptr == &curbuf->b_p_iminsert)\n\t    set_iminsert_global();\n\telse\n\t    set_imsearch_global();\n    }\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t// may show different cursor shape\n#endif\n#if defined(FEAT_KEYMAP)\n    // Show/unshow value of 'keymap' in status lines later.\n    status_redraw_curbuf();\n#endif\n}\n\n/*\n * Handle the CTRL-R key in the command-line mode and insert the contents of a\n * numbered or named register.\n */\n    static int\ncmdline_insert_reg(int *gotesc UNUSED)\n{\n    int\t\ti;\n    int\t\tc;\n    int\t\tliterally = FALSE;\n#ifdef FEAT_EVAL\n    int\t\tsave_new_cmdpos = new_cmdpos;\n#endif\n\n#ifdef USE_ON_FLY_SCROLL\n    dont_scroll = TRUE;\t// disallow scrolling here\n#endif\n    putcmdline('\"', TRUE);\n    ++no_mapping;\n    ++allow_keys;\n    i = c = plain_vgetc();\t// CTRL-R <char>\n    if (i == Ctrl_O)\n\ti = Ctrl_R;\t\t// CTRL-R CTRL-O == CTRL-R CTRL-R\n    if (i == Ctrl_R)\n\tc = plain_vgetc();\t// CTRL-R CTRL-R <char>\n    extra_char = NUL;\n    --no_mapping;\n    --allow_keys;\n#ifdef FEAT_EVAL\n    /*\n     * Insert the result of an expression.\n     */\n    new_cmdpos = -1;\n    if (c == '=')\n    {\n\tif (ccline.cmdfirstc == '='  // can't do this recursively\n\t\t|| cmdline_star > 0) // or when typing a password\n\t{\n\t    beep_flush();\n\t    c = ESC;\n\t}\n\telse\n\t    c = get_expr_register();\n    }\n#endif\n    if (c != ESC)\t    // use ESC to cancel inserting register\n    {\n\tliterally = i == Ctrl_R\n#ifdef FEAT_CLIPBOARD\n\t\t\t|| (clip_star.available && c == '*')\n\t\t\t|| (clip_plus.available && c == '+')\n#endif\n\t\t\t;\n\tcmdline_paste(c, literally, FALSE);\n\n#ifdef FEAT_EVAL\n\t// When there was a serious error abort getting the\n\t// command line.\n\tif (aborting())\n\t{\n\t    *gotesc = TRUE;  // will free ccline.cmdbuff after\n\t    // putting it in history\n\t    return GOTO_NORMAL_MODE;\n\t}\n#endif\n\tKeyTyped = FALSE;\t// Don't do p_wc completion.\n#ifdef FEAT_EVAL\n\tif (new_cmdpos >= 0)\n\t{\n\t    // set_cmdline_pos() was used\n\t    if (new_cmdpos > ccline.cmdlen)\n\t\tccline.cmdpos = ccline.cmdlen;\n\t    else\n\t\tccline.cmdpos = new_cmdpos;\n\t}\n#endif\n    }\n#ifdef FEAT_EVAL\n    new_cmdpos = save_new_cmdpos;\n#endif\n\n    // remove the double quote\n    redrawcmd();\n\n    // With \"literally\": the command line has already changed.\n    // Else: the text has been stuffed, but the command line didn't change yet.\n    return literally ? CMDLINE_CHANGED : CMDLINE_NOT_CHANGED;\n}\n\n/*\n * Handle the Left and Right mouse clicks in the command-line mode.\n */\n    static void\ncmdline_left_right_mouse(int c, int *ignore_drag_release)\n{\n    if (c == K_LEFTRELEASE || c == K_RIGHTRELEASE)\n\t*ignore_drag_release = TRUE;\n    else\n\t*ignore_drag_release = FALSE;\n# ifdef FEAT_GUI\n    // When GUI is active, also move when 'mouse' is empty\n    if (!gui.in_use)\n# endif\n\tif (!mouse_has(MOUSE_COMMAND))\n\t    return;\n# ifdef FEAT_CLIPBOARD\n    if (mouse_row < cmdline_row && clip_star.available)\n    {\n\tint\t    button, is_click, is_drag;\n\n\t/*\n\t * Handle modeless selection.\n\t */\n\tbutton = get_mouse_button(KEY2TERMCAP1(c),\n\t\t&is_click, &is_drag);\n\tif (mouse_model_popup() && button == MOUSE_LEFT\n\t\t&& (mod_mask & MOD_MASK_SHIFT))\n\t{\n\t    // Translate shift-left to right button.\n\t    button = MOUSE_RIGHT;\n\t    mod_mask &= ~MOD_MASK_SHIFT;\n\t}\n\tclip_modeless(button, is_click, is_drag);\n\treturn;\n    }\n# endif\n\n    set_cmdspos();\n    for (ccline.cmdpos = 0; ccline.cmdpos < ccline.cmdlen;\n\t    ++ccline.cmdpos)\n    {\n\tint\ti;\n\n\ti = cmdline_charsize(ccline.cmdpos);\n\tif (mouse_row <= cmdline_row + ccline.cmdspos / Columns\n\t\t&& mouse_col < ccline.cmdspos % Columns + i)\n\t    break;\n\tif (has_mbyte)\n\t{\n\t    // Count \">\" for double-wide char that doesn't fit.\n\t    correct_cmdspos(ccline.cmdpos, i);\n\t    ccline.cmdpos += (*mb_ptr2len)(ccline.cmdbuff\n\t\t    + ccline.cmdpos) - 1;\n\t}\n\tccline.cmdspos += i;\n    }\n}\n\n/*\n * Handle the Up, Down, Page Up, Page down, CTRL-N and CTRL-P key in the\n * command-line mode. The pressed key is in 'c'.\n * Returns:\n *  CMDLINE_NOT_CHANGED - if the command line is not changed\n *  CMDLINE_CHANGED - if the command line is changed\n *  GOTO_NORMAL_MODE - go back to normal mode\n */\n    static int\ncmdline_browse_history(\n\tint\tc,\n\tint\tfirstc,\n\tchar_u\t**curcmdstr,\n\tint\thistype,\n\tint\t*hiscnt_p,\n\texpand_T *xp)\n{\n    int\t\ti;\n    int\t\tj;\n    char_u\t*lookfor = *curcmdstr;\n    int\t\thiscnt = *hiscnt_p;\n    int\t\tres;\n\n    if (get_hislen() == 0 || firstc == NUL)\t// no history\n\treturn CMDLINE_NOT_CHANGED;\n\n    i = hiscnt;\n\n    // save current command string so it can be restored later\n    if (lookfor == NULL)\n    {\n\tif ((lookfor = vim_strsave(ccline.cmdbuff)) == NULL)\n\t    return CMDLINE_NOT_CHANGED;\n\tlookfor[ccline.cmdpos] = NUL;\n    }\n\n    j = (int)STRLEN(lookfor);\n    for (;;)\n    {\n\t// one step backwards\n\tif (c == K_UP|| c == K_S_UP || c == Ctrl_P\n\t\t|| c == K_PAGEUP || c == K_KPAGEUP)\n\t{\n\t    if (hiscnt == get_hislen())\t// first time\n\t\thiscnt = *get_hisidx(histype);\n\t    else if (hiscnt == 0 && *get_hisidx(histype)\n\t\t    != get_hislen() - 1)\n\t\thiscnt = get_hislen() - 1;\n\t    else if (hiscnt != *get_hisidx(histype) + 1)\n\t\t--hiscnt;\n\t    else\t\t\t// at top of list\n\t    {\n\t\thiscnt = i;\n\t\tbreak;\n\t    }\n\t}\n\telse    // one step forwards\n\t{\n\t    // on last entry, clear the line\n\t    if (hiscnt == *get_hisidx(histype))\n\t    {\n\t\thiscnt = get_hislen();\n\t\tbreak;\n\t    }\n\n\t    // not on a history line, nothing to do\n\t    if (hiscnt == get_hislen())\n\t\tbreak;\n\t    if (hiscnt == get_hislen() - 1)   // wrap around\n\t\thiscnt = 0;\n\t    else\n\t\t++hiscnt;\n\t}\n\tif (hiscnt < 0 || get_histentry(histype)[hiscnt].hisstr\n\t\t== NULL)\n\t{\n\t    hiscnt = i;\n\t    break;\n\t}\n\tif ((c != K_UP && c != K_DOWN)\n\t\t|| hiscnt == i\n\t\t|| STRNCMP(get_histentry(histype)[hiscnt].hisstr,\n\t\t    lookfor, (size_t)j) == 0)\n\t    break;\n    }\n\n    if (hiscnt != i)\t// jumped to other entry\n    {\n\tchar_u\t*p;\n\tint\t\tlen;\n\tint\t\told_firstc;\n\n\tVIM_CLEAR(ccline.cmdbuff);\n\txp->xp_context = EXPAND_NOTHING;\n\tif (hiscnt == get_hislen())\n\t    p = lookfor;\t// back to the old one\n\telse\n\t    p = get_histentry(histype)[hiscnt].hisstr;\n\n\tif (histype == HIST_SEARCH\n\t\t&& p != lookfor\n\t\t&& (old_firstc = p[STRLEN(p) + 1]) != firstc)\n\t{\n\t    // Correct for the separator character used when\n\t    // adding the history entry vs the one used now.\n\t    // First loop: count length.\n\t    // Second loop: copy the characters.\n\t    for (i = 0; i <= 1; ++i)\n\t    {\n\t\tlen = 0;\n\t\tfor (j = 0; p[j] != NUL; ++j)\n\t\t{\n\t\t    // Replace old sep with new sep, unless it is\n\t\t    // escaped.\n\t\t    if (p[j] == old_firstc\n\t\t\t    && (j == 0 || p[j - 1] != '\\\\'))\n\t\t    {\n\t\t\tif (i > 0)\n\t\t\t    ccline.cmdbuff[len] = firstc;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// Escape new sep, unless it is already\n\t\t\t// escaped.\n\t\t\tif (p[j] == firstc\n\t\t\t\t&& (j == 0 || p[j - 1] != '\\\\'))\n\t\t\t{\n\t\t\t    if (i > 0)\n\t\t\t\tccline.cmdbuff[len] = '\\\\';\n\t\t\t    ++len;\n\t\t\t}\n\t\t\tif (i > 0)\n\t\t\t    ccline.cmdbuff[len] = p[j];\n\t\t    }\n\t\t    ++len;\n\t\t}\n\t\tif (i == 0)\n\t\t{\n\t\t    alloc_cmdbuff(len);\n\t\t    if (ccline.cmdbuff == NULL)\n\t\t    {\n\t\t\tres = GOTO_NORMAL_MODE;\n\t\t\tgoto done;\n\t\t    }\n\t\t}\n\t    }\n\t    ccline.cmdbuff[len] = NUL;\n\t}\n\telse\n\t{\n\t    alloc_cmdbuff((int)STRLEN(p));\n\t    if (ccline.cmdbuff == NULL)\n\t    {\n\t\tres = GOTO_NORMAL_MODE;\n\t\tgoto done;\n\t    }\n\t    STRCPY(ccline.cmdbuff, p);\n\t}\n\n\tccline.cmdpos = ccline.cmdlen = (int)STRLEN(ccline.cmdbuff);\n\tredrawcmd();\n\tres = CMDLINE_CHANGED;\n\tgoto done;\n    }\n    beep_flush();\n    res = CMDLINE_NOT_CHANGED;\n\ndone:\n    *curcmdstr = lookfor;\n    *hiscnt_p = hiscnt;\n    return res;\n}\n\n/*\n * Initialize the current command-line info.\n */\n    static int\ninit_ccline(int firstc, int indent)\n{\n    ccline.overstrike = FALSE;\t\t    // always start in insert mode\n\n    /*\n     * set some variables for redrawcmd()\n     */\n    ccline.cmdfirstc = (firstc == '@' ? 0 : firstc);\n    ccline.cmdindent = (firstc > 0 ? indent : 0);\n\n    // alloc initial ccline.cmdbuff\n    alloc_cmdbuff(indent + 50);\n    if (ccline.cmdbuff == NULL)\n\treturn FAIL;\n    ccline.cmdlen = ccline.cmdpos = 0;\n    ccline.cmdbuff[0] = NUL;\n    sb_text_start_cmdline();\n\n    // autoindent for :insert and :append\n    if (firstc <= 0)\n    {\n\tvim_memset(ccline.cmdbuff, ' ', indent);\n\tccline.cmdbuff[indent] = NUL;\n\tccline.cmdpos = indent;\n\tccline.cmdspos = indent;\n\tccline.cmdlen = indent;\n    }\n\n    return OK;\n}\n\n/*\n * getcmdline() - accept a command line starting with firstc.\n *\n * firstc == ':'\t    get \":\" command line.\n * firstc == '/' or '?'\t    get search pattern\n * firstc == '='\t    get expression\n * firstc == '@'\t    get text for input() function\n * firstc == '>'\t    get text for debug mode\n * firstc == NUL\t    get text for :insert command\n * firstc == -1\t\t    like NUL, and break on CTRL-C\n *\n * The line is collected in ccline.cmdbuff, which is reallocated to fit the\n * command line.\n *\n * Careful: getcmdline() can be called recursively!\n *\n * Return pointer to allocated string if there is a commandline, NULL\n * otherwise.\n */\n    char_u *\ngetcmdline(\n    int\t\t  firstc,\n    long\t  count,\t// only used for incremental search\n    int\t\t  indent,\t// indent for inside conditionals\n    getline_opt_T do_concat UNUSED)\n{\n    return getcmdline_int(firstc, count, indent, TRUE);\n}\n\n    static char_u *\ngetcmdline_int(\n    int\t\tfirstc,\n    long\tcount UNUSED,\t// only used for incremental search\n    int\t\tindent,\t\t// indent for inside conditionals\n    int\t\tclear_ccline)\t// clear ccline first\n{\n    static int\tdepth = 0;\t    // call depth\n    int\t\tc;\n    int\t\ti;\n    int\t\tj;\n    int\t\tgotesc = FALSE;\t\t// TRUE when <ESC> just typed\n    int\t\tdo_abbr;\t\t// when TRUE check for abbr.\n    char_u\t*lookfor = NULL;\t// string to match\n    int\t\thiscnt;\t\t\t// current history line in use\n    int\t\thistype;\t\t// history type to be used\n#ifdef FEAT_SEARCH_EXTRA\n    incsearch_state_T\tis_state;\n#endif\n    int\t\tdid_wild_list = FALSE;\t// did wild_list() recently\n    int\t\twim_index = 0;\t\t// index in wim_flags[]\n    int\t\tres;\n    int\t\tsave_msg_scroll = msg_scroll;\n    int\t\tsave_State = State;\t// remember State when called\n    int\t\tsome_key_typed = FALSE;\t// one of the keys was typed\n    // mouse drag and release events are ignored, unless they are\n    // preceded with a mouse down event\n    int\t\tignore_drag_release = TRUE;\n#ifdef FEAT_EVAL\n    int\t\tbreak_ctrl_c = FALSE;\n#endif\n    expand_T\txpc;\n    long\t*b_im_ptr = NULL;\n    buf_T\t*b_im_ptr_buf = NULL;\t// buffer where b_im_ptr is valid\n    cmdline_info_T save_ccline;\n    int\t\tdid_save_ccline = FALSE;\n    int\t\tcmdline_type;\n    int\t\twild_type = 0;\n\n    // one recursion level deeper\n    ++depth;\n\n    if (ccline.cmdbuff != NULL)\n    {\n\t// Being called recursively.  Since ccline is global, we need to save\n\t// the current buffer and restore it when returning.\n\tsave_cmdline(&save_ccline);\n\tdid_save_ccline = TRUE;\n    }\n    if (clear_ccline)\n\tCLEAR_FIELD(ccline);\n\n#ifdef FEAT_EVAL\n    if (firstc == -1)\n    {\n\tfirstc = NUL;\n\tbreak_ctrl_c = TRUE;\n    }\n#endif\n#ifdef FEAT_RIGHTLEFT\n    // start without Hebrew mapping for a command line\n    if (firstc == ':' || firstc == '=' || firstc == '>')\n\tcmd_hkmap = 0;\n#endif\n\n#ifdef FEAT_SEARCH_EXTRA\n    init_incsearch_state(&is_state);\n#endif\n\n    if (init_ccline(firstc, indent) != OK)\n\tgoto theend;\t// out of memory\n\n    if (depth == 50)\n    {\n\t// Somehow got into a loop recursively calling getcmdline(), bail out.\n\temsg(_(e_command_too_recursive));\n\tgoto theend;\n    }\n\n    ExpandInit(&xpc);\n    ccline.xpc = &xpc;\n\n#ifdef FEAT_RIGHTLEFT\n    if (curwin->w_p_rl && *curwin->w_p_rlc == 's'\n\t\t\t\t\t  && (firstc == '/' || firstc == '?'))\n\tcmdmsg_rl = TRUE;\n    else\n\tcmdmsg_rl = FALSE;\n#endif\n\n    redir_off = TRUE;\t\t// don't redirect the typed command\n    if (!cmd_silent)\n    {\n\ti = msg_scrolled;\n\tmsg_scrolled = 0;\t\t// avoid wait_return() message\n\tgotocmdline(TRUE);\n\tmsg_scrolled += i;\n\tredrawcmdprompt();\t\t// draw prompt or indent\n\tset_cmdspos();\n    }\n    xpc.xp_context = EXPAND_NOTHING;\n    xpc.xp_backslash = XP_BS_NONE;\n#ifndef BACKSLASH_IN_FILENAME\n    xpc.xp_shell = FALSE;\n#endif\n\n#if defined(FEAT_EVAL)\n    if (ccline.input_fn)\n    {\n\txpc.xp_context = ccline.xp_context;\n\txpc.xp_pattern = ccline.cmdbuff;\n\txpc.xp_arg = ccline.xp_arg;\n    }\n#endif\n\n    /*\n     * Avoid scrolling when called by a recursive do_cmdline(), e.g. when\n     * doing \":@0\" when register 0 doesn't contain a CR.\n     */\n    msg_scroll = FALSE;\n\n    State = MODE_CMDLINE;\n\n    if (firstc == '/' || firstc == '?' || firstc == '@')\n    {\n\t// Use \":lmap\" mappings for search pattern and input().\n\tif (curbuf->b_p_imsearch == B_IMODE_USE_INSERT)\n\t    b_im_ptr = &curbuf->b_p_iminsert;\n\telse\n\t    b_im_ptr = &curbuf->b_p_imsearch;\n\tb_im_ptr_buf = curbuf;\n\tif (*b_im_ptr == B_IMODE_LMAP)\n\t    State |= MODE_LANGMAP;\n#ifdef HAVE_INPUT_METHOD\n\tim_set_active(*b_im_ptr == B_IMODE_IM);\n#endif\n    }\n#ifdef HAVE_INPUT_METHOD\n    else if (p_imcmdline)\n\tim_set_active(TRUE);\n#endif\n\n    setmouse();\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t\t// may show different cursor shape\n#endif\n\n    // When inside an autocommand for writing \"exiting\" may be set and\n    // terminal mode set to cooked.  Need to set raw mode here then.\n    settmode(TMODE_RAW);\n\n    // Trigger CmdlineEnter autocommands.\n    cmdline_type = firstc == NUL ? '-' : firstc;\n    trigger_cmd_autocmd(cmdline_type, EVENT_CMDLINEENTER);\n#ifdef FEAT_EVAL\n    if (!debug_mode)\n\tmay_trigger_modechanged();\n#endif\n\n    init_history();\n    hiscnt = get_hislen();\t// set hiscnt to impossible history value\n    histype = hist_char2type(firstc);\n\n#ifdef FEAT_DIGRAPHS\n    do_digraph(-1);\t\t// init digraph typeahead\n#endif\n\n    // If something above caused an error, reset the flags, we do want to type\n    // and execute commands. Display may be messed up a bit.\n    if (did_emsg)\n\tredrawcmd();\n\n#ifdef FEAT_STL_OPT\n    // Redraw the statusline in case it uses the current mode using the mode()\n    // function.\n    if (!cmd_silent && msg_scrolled == 0)\n    {\n\tint\tfound_one = FALSE;\n\twin_T\t*wp;\n\n\tFOR_ALL_WINDOWS(wp)\n\t    if (*p_stl != NUL || *wp->w_p_stl != NUL)\n\t    {\n\t\twp->w_redr_status = TRUE;\n\t\tfound_one = TRUE;\n\t    }\n\n\tif (*p_tal != NUL)\n\t{\n\t    redraw_tabline = TRUE;\n\t    found_one = TRUE;\n\t}\n\n\tif (found_one)\n\t    redraw_statuslines();\n    }\n#endif\n\n    did_emsg = FALSE;\n    got_int = FALSE;\n\n    /*\n     * Collect the command string, handling editing keys.\n     */\n    for (;;)\n    {\n\tint trigger_cmdlinechanged = TRUE;\n\tint end_wildmenu;\n\n\tredir_off = TRUE;\t// Don't redirect the typed command.\n\t\t\t\t// Repeated, because a \":redir\" inside\n\t\t\t\t// completion may switch it on.\n#ifdef USE_ON_FLY_SCROLL\n\tdont_scroll = FALSE;\t// allow scrolling here\n#endif\n\tquit_more = FALSE;\t// reset after CTRL-D which had a more-prompt\n\n\tdid_emsg = FALSE;\t// There can't really be a reason why an error\n\t\t\t\t// that occurs while typing a command should\n\t\t\t\t// cause the command not to be executed.\n\n\t// Trigger SafeState if nothing is pending.\n\tmay_trigger_safestate(xpc.xp_numfiles <= 0);\n\n\t// Get a character.  Ignore K_IGNORE and K_NOP, they should not do\n\t// anything, such as stop completion.\n\tdo\n\t{\n\t    cursorcmd();\t\t// set the cursor on the right spot\n\t    c = safe_vgetc();\n\t} while (c == K_IGNORE || c == K_NOP);\n\n\tif (c == K_COMMAND || c == K_SCRIPT_COMMAND)\n\t{\n\t    int\t    clen = ccline.cmdlen;\n\t    int\t    cc_count = aucmd_cmdline_changed_count;\n\n\t    if (do_cmdkey_command(c, DOCMD_NOWAIT) == OK)\n\t    {\n\t\t// Do not trigger CmdlineChanged below if:\n\t\t// - the length of the command line didn't change\n\t\t// - the <Cmd> mapping already triggered the event\n\t\tif (clen == ccline.cmdlen\n\t\t\t\t    || cc_count != aucmd_cmdline_changed_count)\n\t\t    trigger_cmdlinechanged = FALSE;\n\t\tgoto cmdline_changed;\n\t    }\n\t}\n\n\tif (KeyTyped)\n\t{\n\t    some_key_typed = TRUE;\n#ifdef FEAT_RIGHTLEFT\n\t    if (cmd_hkmap)\n\t\tc = hkmap(c);\n\t    if (cmdmsg_rl && !KeyStuffed)\n\t    {\n\t\t// Invert horizontal movements and operations.  Only when\n\t\t// typed by the user directly, not when the result of a\n\t\t// mapping.\n\t\tswitch (c)\n\t\t{\n\t\t    case K_RIGHT:   c = K_LEFT; break;\n\t\t    case K_S_RIGHT: c = K_S_LEFT; break;\n\t\t    case K_C_RIGHT: c = K_C_LEFT; break;\n\t\t    case K_LEFT:    c = K_RIGHT; break;\n\t\t    case K_S_LEFT:  c = K_S_RIGHT; break;\n\t\t    case K_C_LEFT:  c = K_C_RIGHT; break;\n\t\t}\n\t    }\n#endif\n\t}\n\n\t/*\n\t * Ignore got_int when CTRL-C was typed here.\n\t * Don't ignore it in :global, we really need to break then, e.g., for\n\t * \":g/pat/normal /pat\" (without the <CR>).\n\t * Don't ignore it for the input() function.\n\t */\n\tif ((c == Ctrl_C\n#ifdef UNIX\n\t\t|| c == intr_char\n#endif\n\t\t\t\t)\n#if defined(FEAT_EVAL) || defined(FEAT_CRYPT)\n\t\t&& firstc != '@'\n#endif\n#ifdef FEAT_EVAL\n\t\t// do clear got_int in Ex mode to avoid infinite Ctrl-C loop\n\t\t&& (!break_ctrl_c || exmode_active)\n#endif\n\t\t&& !global_busy)\n\t    got_int = FALSE;\n\n\t// free old command line when finished moving around in the history\n\t// list\n\tif (lookfor != NULL\n\t\t&& c != K_S_DOWN && c != K_S_UP\n\t\t&& c != K_DOWN && c != K_UP\n\t\t&& c != K_PAGEDOWN && c != K_PAGEUP\n\t\t&& c != K_KPAGEDOWN && c != K_KPAGEUP\n\t\t&& c != K_LEFT && c != K_RIGHT\n\t\t&& (xpc.xp_numfiles > 0 || (c != Ctrl_P && c != Ctrl_N)))\n\t    VIM_CLEAR(lookfor);\n\n\t/*\n\t * When there are matching completions to select <S-Tab> works like\n\t * CTRL-P (unless 'wc' is <S-Tab>).\n\t */\n\tif (c != p_wc && c == K_S_TAB && xpc.xp_numfiles > 0)\n\t    c = Ctrl_P;\n\n\tif (p_wmnu)\n\t    c = wildmenu_translate_key(&ccline, c, &xpc, did_wild_list);\n\n\tint key_is_wc = (c == p_wc && KeyTyped) || c == p_wcm;\n\tif ((cmdline_pum_active() || did_wild_list) && !key_is_wc)\n\t{\n\t    // Ctrl-Y: Accept the current selection and close the popup menu.\n\t    // Ctrl-E: cancel the cmdline popup menu and return the original\n\t    // text.\n\t    if (c == Ctrl_E || c == Ctrl_Y)\n\t    {\n\t\twild_type = (c == Ctrl_E) ? WILD_CANCEL : WILD_APPLY;\n\t\tif (nextwild(&xpc, wild_type, WILD_NO_BEEP,\n\t\t\t\t\t\t\tfirstc != '@') == FAIL)\n\t\t    break;\n\t    }\n\t}\n\n\t// The wildmenu is cleared if the pressed key is not used for\n\t// navigating the wild menu (i.e. the key is not 'wildchar' or\n\t// 'wildcharm' or Ctrl-N or Ctrl-P or Ctrl-A or Ctrl-L).\n\t// If the popup menu is displayed, then PageDown and PageUp keys are\n\t// also used to navigate the menu.\n\tend_wildmenu = (!key_is_wc\n\t\t&& c != Ctrl_N && c != Ctrl_P && c != Ctrl_A && c != Ctrl_L);\n\tend_wildmenu = end_wildmenu && (!cmdline_pum_active() ||\n\t\t\t    (c != K_PAGEDOWN && c != K_PAGEUP\n\t\t\t     && c != K_KPAGEDOWN && c != K_KPAGEUP));\n\n\t// free expanded names when finished walking through matches\n\tif (end_wildmenu)\n\t{\n\t    if (cmdline_pum_active())\n\t\tcmdline_pum_remove();\n\t    if (xpc.xp_numfiles != -1)\n\t\t(void)ExpandOne(&xpc, NULL, NULL, 0, WILD_FREE);\n\t    did_wild_list = FALSE;\n\t    if (!p_wmnu || (c != K_UP && c != K_DOWN))\n\t\txpc.xp_context = EXPAND_NOTHING;\n\t    wim_index = 0;\n\t    wildmenu_cleanup(&ccline);\n\t}\n\n\tif (p_wmnu)\n\t    c = wildmenu_process_key(&ccline, c, &xpc);\n\n\t// CTRL-\\ CTRL-N goes to Normal mode, CTRL-\\ CTRL-G goes to Insert\n\t// mode when 'insertmode' is set, CTRL-\\ e prompts for an expression.\n\tif (c == Ctrl_BSL)\n\t{\n\t    res = cmdline_handle_ctrl_bsl(c, &gotesc);\n\t    if (res == CMDLINE_CHANGED)\n\t\tgoto cmdline_changed;\n\t    else if (res == CMDLINE_NOT_CHANGED)\n\t\tgoto cmdline_not_changed;\n\t    else if (res == GOTO_NORMAL_MODE)\n\t\tgoto returncmd;\t\t// back to cmd mode\n\t    c = Ctrl_BSL;\t\t// backslash key not processed by\n\t\t\t\t\t// cmdline_handle_ctrl_bsl()\n\t}\n\n\tif (c == cedit_key || c == K_CMDWIN)\n\t{\n\t    // TODO: why is ex_normal_busy checked here?\n\t    if ((c == K_CMDWIN || ex_normal_busy == 0) && got_int == FALSE)\n\t    {\n\t\t/*\n\t\t * Open a window to edit the command line (and history).\n\t\t */\n\t\tc = open_cmdwin();\n\t\tsome_key_typed = TRUE;\n\t    }\n\t}\n#ifdef FEAT_DIGRAPHS\n\telse\n\t    c = do_digraph(c);\n#endif\n\n\tif (c == '\\n' || c == '\\r' || c == K_KENTER || (c == ESC\n\t\t\t&& (!KeyTyped || vim_strchr(p_cpo, CPO_ESC) != NULL)))\n\t{\n\t    // In Ex mode a backslash escapes a newline.\n\t    if (exmode_active\n\t\t    && c != ESC\n\t\t    && ccline.cmdpos == ccline.cmdlen\n\t\t    && ccline.cmdpos > 0\n\t\t    && ccline.cmdbuff[ccline.cmdpos - 1] == '\\\\')\n\t    {\n\t\tif (c == K_KENTER)\n\t\t    c = '\\n';\n\t    }\n\t    else\n\t    {\n\t\tgotesc = FALSE;\t// Might have typed ESC previously, don't\n\t\t\t\t// truncate the cmdline now.\n\t\tif (ccheck_abbr(c + ABBR_OFF))\n\t\t    goto cmdline_changed;\n\t\tif (!cmd_silent)\n\t\t{\n\t\t    windgoto(msg_row, 0);\n\t\t    out_flush();\n\t\t}\n\t\tbreak;\n\t    }\n\t}\n\n\t// Completion for 'wildchar' or 'wildcharm' key.\n\tif ((c == p_wc && !gotesc && KeyTyped) || c == p_wcm)\n\t{\n\t    res = cmdline_wildchar_complete(c, firstc != '@', &did_wild_list,\n\t\t    &wim_index, &xpc, &gotesc);\n\t    if (res == CMDLINE_CHANGED)\n\t\tgoto cmdline_changed;\n\t}\n\n\tgotesc = FALSE;\n\n\t// <S-Tab> goes to last match, in a clumsy way\n\tif (c == K_S_TAB && KeyTyped)\n\t{\n\t    if (nextwild(&xpc, WILD_EXPAND_KEEP, 0, firstc != '@') == OK)\n\t    {\n\t\tif (xpc.xp_numfiles > 1\n\t\t    && ((!did_wild_list && (wim_flags[wim_index] & WIM_LIST))\n\t\t\t    || p_wmnu))\n\t\t{\n\t\t    // Trigger the popup menu when wildoptions=pum\n\t\t    showmatches(&xpc, p_wmnu\n\t\t\t    && ((wim_flags[wim_index] & WIM_LIST) == 0));\n\t\t}\n\t\tif (nextwild(&xpc, WILD_PREV, 0, firstc != '@') == OK\n\t\t\t&& nextwild(&xpc, WILD_PREV, 0, firstc != '@') == OK)\n\t\t    goto cmdline_changed;\n\t    }\n\t}\n\n\tif (c == NUL || c == K_ZERO)\t    // NUL is stored as NL\n\t    c = NL;\n\n\tdo_abbr = TRUE;\t\t// default: check for abbreviation\n\n\t// If already used to cancel/accept wildmenu, don't process the key\n\t// further.\n\tif (wild_type == WILD_CANCEL || wild_type == WILD_APPLY)\n\t{\n\t    wild_type = 0;\n\t    goto cmdline_not_changed;\n\t}\n\n\t/*\n\t * Big switch for a typed command line character.\n\t */\n\tswitch (c)\n\t{\n\tcase K_BS:\n\tcase Ctrl_H:\n\tcase K_DEL:\n\tcase K_KDEL:\n\tcase Ctrl_W:\n\t    res = cmdline_erase_chars(c, indent\n#ifdef FEAT_SEARCH_EXTRA\n\t\t    , &is_state\n#endif\n\t\t    );\n\t    if (res == CMDLINE_NOT_CHANGED)\n\t\tgoto cmdline_not_changed;\n\t    else if (res == GOTO_NORMAL_MODE)\n\t\tgoto returncmd;\t\t// back to cmd mode\n\t    goto cmdline_changed;\n\n\tcase K_INS:\n\tcase K_KINS:\n\t\tccline.overstrike = !ccline.overstrike;\n#ifdef CURSOR_SHAPE\n\t\tui_cursor_shape();\t// may show different cursor shape\n#endif\n\t\tgoto cmdline_not_changed;\n\n\tcase Ctrl_HAT:\n\t\tcmdline_toggle_langmap(\n\t\t\t\t    buf_valid(b_im_ptr_buf) ? b_im_ptr : NULL);\n\t\tgoto cmdline_not_changed;\n\n//\tcase '@':   only in very old vi\n\tcase Ctrl_U:\n\t\t// delete all characters left of the cursor\n\t\tj = ccline.cmdpos;\n\t\tccline.cmdlen -= j;\n\t\ti = ccline.cmdpos = 0;\n\t\twhile (i < ccline.cmdlen)\n\t\t    ccline.cmdbuff[i++] = ccline.cmdbuff[j++];\n\t\t// Truncate at the end, required for multi-byte chars.\n\t\tccline.cmdbuff[ccline.cmdlen] = NUL;\n#ifdef FEAT_SEARCH_EXTRA\n\t\tif (ccline.cmdlen == 0)\n\t\t    is_state.search_start = is_state.save_cursor;\n#endif\n\t\tredrawcmd();\n\t\tgoto cmdline_changed;\n\n#ifdef FEAT_CLIPBOARD\n\tcase Ctrl_Y:\n\t\t// Copy the modeless selection, if there is one.\n\t\tif (clip_star.state != SELECT_CLEARED)\n\t\t{\n\t\t    if (clip_star.state == SELECT_DONE)\n\t\t\tclip_copy_modeless_selection(TRUE);\n\t\t    goto cmdline_not_changed;\n\t\t}\n\t\tbreak;\n#endif\n\n\tcase ESC:\t// get here if p_wc != ESC or when ESC typed twice\n\tcase Ctrl_C:\n\t\t// In exmode it doesn't make sense to return.  Except when\n\t\t// \":normal\" runs out of characters.\n\t\tif (exmode_active\n\t\t\t       && (ex_normal_busy == 0 || typebuf.tb_len > 0))\n\t\t    goto cmdline_not_changed;\n\n\t\tgotesc = TRUE;\t\t// will free ccline.cmdbuff after\n\t\t\t\t\t// putting it in history\n\t\tgoto returncmd;\t\t// back to cmd mode\n\n\tcase Ctrl_R:\t\t\t// insert register\n\t\tres = cmdline_insert_reg(&gotesc);\n\t\tif (res == GOTO_NORMAL_MODE)\n\t\t    goto returncmd;\n\t\tif (res == CMDLINE_CHANGED)\n\t\t    goto cmdline_changed;\n\t\tgoto cmdline_not_changed;\n\n\tcase Ctrl_D:\n\t\tif (showmatches(&xpc, FALSE) == EXPAND_NOTHING)\n\t\t    break;\t// Use ^D as normal char instead\n\n\t\tredrawcmd();\n\t\tcontinue;\t// don't do incremental search now\n\n\tcase K_RIGHT:\n\tcase K_S_RIGHT:\n\tcase K_C_RIGHT:\n\t\tdo\n\t\t{\n\t\t    if (ccline.cmdpos >= ccline.cmdlen)\n\t\t\tbreak;\n\t\t    i = cmdline_charsize(ccline.cmdpos);\n\t\t    if (KeyTyped && ccline.cmdspos + i >= Columns * Rows)\n\t\t\tbreak;\n\t\t    ccline.cmdspos += i;\n\t\t    if (has_mbyte)\n\t\t\tccline.cmdpos += (*mb_ptr2len)(ccline.cmdbuff\n\t\t\t\t\t\t\t     + ccline.cmdpos);\n\t\t    else\n\t\t\t++ccline.cmdpos;\n\t\t}\n\t\twhile ((c == K_S_RIGHT || c == K_C_RIGHT\n\t\t\t       || (mod_mask & (MOD_MASK_SHIFT|MOD_MASK_CTRL)))\n\t\t\t&& ccline.cmdbuff[ccline.cmdpos] != ' ');\n\t\tif (has_mbyte)\n\t\t    set_cmdspos_cursor();\n\t\tgoto cmdline_not_changed;\n\n\tcase K_LEFT:\n\tcase K_S_LEFT:\n\tcase K_C_LEFT:\n\t\tif (ccline.cmdpos == 0)\n\t\t    goto cmdline_not_changed;\n\t\tdo\n\t\t{\n\t\t    --ccline.cmdpos;\n\t\t    if (has_mbyte)\t// move to first byte of char\n\t\t\tccline.cmdpos -= (*mb_head_off)(ccline.cmdbuff,\n\t\t\t\t\t      ccline.cmdbuff + ccline.cmdpos);\n\t\t    ccline.cmdspos -= cmdline_charsize(ccline.cmdpos);\n\t\t}\n\t\twhile (ccline.cmdpos > 0\n\t\t\t&& (c == K_S_LEFT || c == K_C_LEFT\n\t\t\t       || (mod_mask & (MOD_MASK_SHIFT|MOD_MASK_CTRL)))\n\t\t\t&& ccline.cmdbuff[ccline.cmdpos - 1] != ' ');\n\t\tif (has_mbyte)\n\t\t    set_cmdspos_cursor();\n\t\tgoto cmdline_not_changed;\n\n\tcase K_IGNORE:\n\t\t// Ignore mouse event or open_cmdwin() result.\n\t\tgoto cmdline_not_changed;\n\n#ifdef FEAT_GUI_MSWIN\n\t    // On MS-Windows ignore <M-F4>, we get it when closing the window\n\t    // was cancelled.\n\tcase K_F4:\n\t    if (mod_mask == MOD_MASK_ALT)\n\t    {\n\t\tredrawcmd();\t    // somehow the cmdline is cleared\n\t\tgoto cmdline_not_changed;\n\t    }\n\t    break;\n#endif\n\n\tcase K_MIDDLEDRAG:\n\tcase K_MIDDLERELEASE:\n\t\tgoto cmdline_not_changed;\t// Ignore mouse\n\n\tcase K_MIDDLEMOUSE:\n# ifdef FEAT_GUI\n\t\t// When GUI is active, also paste when 'mouse' is empty\n\t\tif (!gui.in_use)\n# endif\n\t\t    if (!mouse_has(MOUSE_COMMAND))\n\t\t\tgoto cmdline_not_changed;   // Ignore mouse\n# ifdef FEAT_CLIPBOARD\n\t\tif (clip_star.available)\n\t\t    cmdline_paste('*', TRUE, TRUE);\n\t\telse\n# endif\n\t\t    cmdline_paste(0, TRUE, TRUE);\n\t\tredrawcmd();\n\t\tgoto cmdline_changed;\n\n# ifdef FEAT_DND\n\tcase K_DROP:\n\t\tcmdline_paste('~', TRUE, FALSE);\n\t\tredrawcmd();\n\t\tgoto cmdline_changed;\n# endif\n\n\tcase K_LEFTDRAG:\n\tcase K_LEFTRELEASE:\n\tcase K_RIGHTDRAG:\n\tcase K_RIGHTRELEASE:\n\t\t// Ignore drag and release events when the button-down wasn't\n\t\t// seen before.\n\t\tif (ignore_drag_release)\n\t\t    goto cmdline_not_changed;\n\t\t// FALLTHROUGH\n\tcase K_LEFTMOUSE:\n\tcase K_RIGHTMOUSE:\n\t\tcmdline_left_right_mouse(c, &ignore_drag_release);\n\t\tgoto cmdline_not_changed;\n\n\t// Mouse scroll wheel: ignored here\n\tcase K_MOUSEDOWN:\n\tcase K_MOUSEUP:\n\tcase K_MOUSELEFT:\n\tcase K_MOUSERIGHT:\n\t// Alternate buttons ignored here\n\tcase K_X1MOUSE:\n\tcase K_X1DRAG:\n\tcase K_X1RELEASE:\n\tcase K_X2MOUSE:\n\tcase K_X2DRAG:\n\tcase K_X2RELEASE:\n\tcase K_MOUSEMOVE:\n\t\tgoto cmdline_not_changed;\n\n#ifdef FEAT_GUI\n\tcase K_LEFTMOUSE_NM:\t// mousefocus click, ignored\n\tcase K_LEFTRELEASE_NM:\n\t\tgoto cmdline_not_changed;\n\n\tcase K_VER_SCROLLBAR:\n\t\tif (msg_scrolled == 0)\n\t\t{\n\t\t    gui_do_scroll();\n\t\t    redrawcmd();\n\t\t}\n\t\tgoto cmdline_not_changed;\n\n\tcase K_HOR_SCROLLBAR:\n\t\tif (msg_scrolled == 0)\n\t\t{\n\t\t    do_mousescroll_horiz(scrollbar_value);\n\t\t    redrawcmd();\n\t\t}\n\t\tgoto cmdline_not_changed;\n#endif\n#ifdef FEAT_GUI_TABLINE\n\tcase K_TABLINE:\n\tcase K_TABMENU:\n\t\t// Don't want to change any tabs here.  Make sure the same tab\n\t\t// is still selected.\n\t\tif (gui_use_tabline())\n\t\t    gui_mch_set_curtab(tabpage_index(curtab));\n\t\tgoto cmdline_not_changed;\n#endif\n\n\tcase K_SELECT:\t    // end of Select mode mapping - ignore\n\t\tgoto cmdline_not_changed;\n\n\tcase Ctrl_B:\t    // begin of command line\n\tcase K_HOME:\n\tcase K_KHOME:\n\tcase K_S_HOME:\n\tcase K_C_HOME:\n\t\tccline.cmdpos = 0;\n\t\tset_cmdspos();\n\t\tgoto cmdline_not_changed;\n\n\tcase Ctrl_E:\t    // end of command line\n\tcase K_END:\n\tcase K_KEND:\n\tcase K_S_END:\n\tcase K_C_END:\n\t\tccline.cmdpos = ccline.cmdlen;\n\t\tset_cmdspos_cursor();\n\t\tgoto cmdline_not_changed;\n\n\tcase Ctrl_A:\t    // all matches\n\t\tif (cmdline_pum_active())\n\t\t    // As Ctrl-A completes all the matches, close the popup\n\t\t    // menu (if present)\n\t\t    cmdline_pum_cleanup(&ccline);\n\n\t\tif (nextwild(&xpc, WILD_ALL, 0, firstc != '@') == FAIL)\n\t\t    break;\n\t\txpc.xp_context = EXPAND_NOTHING;\n\t\tdid_wild_list = FALSE;\n\t\tgoto cmdline_changed;\n\n\tcase Ctrl_L:\n#ifdef FEAT_SEARCH_EXTRA\n\t\tif (may_add_char_to_search(firstc, &c, &is_state) == OK)\n\t\t    goto cmdline_not_changed;\n#endif\n\n\t\t// completion: longest common part\n\t\tif (nextwild(&xpc, WILD_LONGEST, 0, firstc != '@') == FAIL)\n\t\t    break;\n\t\tgoto cmdline_changed;\n\n\tcase Ctrl_N:\t    // next match\n\tcase Ctrl_P:\t    // previous match\n\t\tif (xpc.xp_numfiles > 0)\n\t\t{\n\t\t    wild_type = (c == Ctrl_P) ? WILD_PREV : WILD_NEXT;\n\t\t    if (nextwild(&xpc, wild_type, 0, firstc != '@') == FAIL)\n\t\t\tbreak;\n\t\t    goto cmdline_changed;\n\t\t}\n\t\t// FALLTHROUGH\n\tcase K_UP:\n\tcase K_DOWN:\n\tcase K_S_UP:\n\tcase K_S_DOWN:\n\tcase K_PAGEUP:\n\tcase K_KPAGEUP:\n\tcase K_PAGEDOWN:\n\tcase K_KPAGEDOWN:\n\t\tif (cmdline_pum_active()\n\t\t\t&& (c == K_PAGEUP || c == K_PAGEDOWN ||\n\t\t\t    c == K_KPAGEUP || c == K_KPAGEDOWN))\n\t\t{\n\t\t    // If the popup menu is displayed, then PageUp and PageDown\n\t\t    // are used to scroll the menu.\n\t\t    wild_type = WILD_PAGEUP;\n\t\t    if (c == K_PAGEDOWN || c == K_KPAGEDOWN)\n\t\t\twild_type = WILD_PAGEDOWN;\n\t\t    if (nextwild(&xpc, wild_type, 0, firstc != '@') == FAIL)\n\t\t\tbreak;\n\t\t    goto cmdline_changed;\n\t\t}\n\t\telse\n\t\t{\n\t\t    res = cmdline_browse_history(c, firstc, &lookfor, histype,\n\t\t\t    &hiscnt, &xpc);\n\t\t    if (res == CMDLINE_CHANGED)\n\t\t\tgoto cmdline_changed;\n\t\t    else if (res == GOTO_NORMAL_MODE)\n\t\t\tgoto returncmd;\n\t\t}\n\t\tgoto cmdline_not_changed;\n\n#ifdef FEAT_SEARCH_EXTRA\n\tcase Ctrl_G:\t    // next match\n\tcase Ctrl_T:\t    // previous match\n\t\tif (may_adjust_incsearch_highlighting(\n\t\t\t\t\t  firstc, count, &is_state, c) == FAIL)\n\t\t    goto cmdline_not_changed;\n\t\tbreak;\n#endif\n\n\tcase Ctrl_V:\n\tcase Ctrl_Q:\n\t\t{\n\t\t    ignore_drag_release = TRUE;\n\t\t    putcmdline('^', TRUE);\n\n\t\t    // Get next (two) character(s).  Do not change any\n\t\t    // modifyOtherKeys ESC sequence to a normal key for\n\t\t    // CTRL-SHIFT-V.\n\t\t    c = get_literal(mod_mask & MOD_MASK_SHIFT);\n\n\t\t    do_abbr = FALSE;\t    // don't do abbreviation now\n\t\t    extra_char = NUL;\n\t\t    // may need to remove ^ when composing char was typed\n\t\t    if (enc_utf8 && utf_iscomposing(c) && !cmd_silent)\n\t\t    {\n\t\t\tdraw_cmdline(ccline.cmdpos,\n\t\t\t\t\t\tccline.cmdlen - ccline.cmdpos);\n\t\t\tmsg_putchar(' ');\n\t\t\tcursorcmd();\n\t\t    }\n\t\t}\n\n\t\tbreak;\n\n#ifdef FEAT_DIGRAPHS\n\tcase Ctrl_K:\n\t\tignore_drag_release = TRUE;\n\t\tputcmdline('?', TRUE);\n# ifdef USE_ON_FLY_SCROLL\n\t\tdont_scroll = TRUE;\t    // disallow scrolling here\n# endif\n\t\tc = get_digraph(TRUE);\n\t\textra_char = NUL;\n\t\tif (c != NUL)\n\t\t    break;\n\n\t\tredrawcmd();\n\t\tgoto cmdline_not_changed;\n#endif // FEAT_DIGRAPHS\n\n#ifdef FEAT_RIGHTLEFT\n\tcase Ctrl__:\t    // CTRL-_: switch language mode\n\t\tif (!p_ari)\n\t\t    break;\n\t\tcmd_hkmap = !cmd_hkmap;\n\t\tgoto cmdline_not_changed;\n#endif\n\n\tcase K_PS:\n\t\tbracketed_paste(PASTE_CMDLINE, FALSE, NULL);\n\t\tgoto cmdline_changed;\n\n\tdefault:\n#ifdef UNIX\n\t\tif (c == intr_char)\n\t\t{\n\t\t    gotesc = TRUE;\t// will free ccline.cmdbuff after\n\t\t\t\t\t// putting it in history\n\t\t    goto returncmd;\t// back to Normal mode\n\t\t}\n#endif\n\t\t/*\n\t\t * Normal character with no special meaning.  Just set mod_mask\n\t\t * to 0x0 so that typing Shift-Space in the GUI doesn't enter\n\t\t * the string <S-Space>.  This should only happen after ^V.\n\t\t */\n\t\tif (!IS_SPECIAL(c))\n\t\t    mod_mask = 0x0;\n\t\tbreak;\n\t}\n\t/*\n\t * End of switch on command line character.\n\t * We come here if we have a normal character.\n\t */\n\n\tif (do_abbr && (IS_SPECIAL(c) || !vim_iswordc(c))\n\t\t&& (ccheck_abbr(\n\t\t\t// Add ABBR_OFF for characters above 0x100, this is\n\t\t\t// what check_abbr() expects.\n\t\t\t\t(has_mbyte && c >= 0x100) ? (c + ABBR_OFF) : c)\n\t\t    || c == Ctrl_RSB))\n\t    goto cmdline_changed;\n\n\t/*\n\t * put the character in the command line\n\t */\n\tif (IS_SPECIAL(c) || mod_mask != 0)\n\t    put_on_cmdline(get_special_key_name(c, mod_mask), -1, TRUE);\n\telse\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tj = (*mb_char2bytes)(c, IObuff);\n\t\tIObuff[j] = NUL;\t// exclude composing chars\n\t\tput_on_cmdline(IObuff, j, TRUE);\n\t    }\n\t    else\n\t    {\n\t\tIObuff[0] = c;\n\t\tput_on_cmdline(IObuff, 1, TRUE);\n\t    }\n\t}\n\tgoto cmdline_changed;\n\n/*\n * This part implements incremental searches for \"/\" and \"?\"\n * Jump to cmdline_not_changed when a character has been read but the command\n * line did not change. Then we only search and redraw if something changed in\n * the past.\n * Jump to cmdline_changed when the command line did change.\n * (Sorry for the goto's, I know it is ugly).\n */\ncmdline_not_changed:\n#ifdef FEAT_SEARCH_EXTRA\n\tif (!is_state.incsearch_postponed)\n\t    continue;\n#endif\n\ncmdline_changed:\n#ifdef FEAT_SEARCH_EXTRA\n\t// If the window changed incremental search state is not valid.\n\tif (is_state.winid != curwin->w_id)\n\t    init_incsearch_state(&is_state);\n#endif\n\tif (trigger_cmdlinechanged)\n\t    // Trigger CmdlineChanged autocommands.\n\t    trigger_cmd_autocmd(cmdline_type, EVENT_CMDLINECHANGED);\n\n#ifdef FEAT_SEARCH_EXTRA\n\tif (xpc.xp_context == EXPAND_NOTHING && (KeyTyped || vpeekc() == NUL))\n\t    may_do_incsearch_highlighting(firstc, count, &is_state);\n#endif\n\n#ifdef FEAT_RIGHTLEFT\n\tif (cmdmsg_rl\n# ifdef FEAT_ARABIC\n\t\t|| (p_arshape && !p_tbidi\n\t\t\t\t       && cmdline_has_arabic(0, ccline.cmdlen))\n# endif\n\t\t)\n\t    // Always redraw the whole command line to fix shaping and\n\t    // right-left typing.  Not efficient, but it works.\n\t    // Do it only when there are no characters left to read\n\t    // to avoid useless intermediate redraws.\n\t    if (vpeekc() == NUL)\n\t\tredrawcmd();\n#endif\n    }\n\nreturncmd:\n\n#ifdef FEAT_RIGHTLEFT\n    cmdmsg_rl = FALSE;\n#endif\n\n    // We could have reached here without having a chance to clean up wild menu\n    // if certain special keys like <Esc> or <C-\\> were used as wildchar. Make\n    // sure to still clean up to avoid memory corruption.\n    if (cmdline_pum_active())\n\tcmdline_pum_remove();\n    wildmenu_cleanup(&ccline);\n    did_wild_list = FALSE;\n    wim_index = 0;\n\n    ExpandCleanup(&xpc);\n    ccline.xpc = NULL;\n\n#ifdef FEAT_SEARCH_EXTRA\n    finish_incsearch_highlighting(gotesc, &is_state, FALSE);\n#endif\n\n    if (ccline.cmdbuff != NULL)\n    {\n\t/*\n\t * Put line in history buffer (\":\" and \"=\" only when it was typed).\n\t */\n\tif (ccline.cmdlen && firstc != NUL\n\t\t&& (some_key_typed || histype == HIST_SEARCH))\n\t{\n\t    add_to_history(histype, ccline.cmdbuff, TRUE,\n\t\t\t\t       histype == HIST_SEARCH ? firstc : NUL);\n\t    if (firstc == ':')\n\t    {\n\t\tvim_free(new_last_cmdline);\n\t\tnew_last_cmdline = vim_strsave(ccline.cmdbuff);\n\t    }\n\t}\n\n\tif (gotesc)\n\t    abandon_cmdline();\n    }\n\n    /*\n     * If the screen was shifted up, redraw the whole screen (later).\n     * If the line is too long, clear it, so ruler and shown command do\n     * not get printed in the middle of it.\n     */\n    msg_check();\n    msg_scroll = save_msg_scroll;\n    redir_off = FALSE;\n\n    // When the command line was typed, no need for a wait-return prompt.\n    if (some_key_typed)\n\tneed_wait_return = FALSE;\n\n    // Trigger CmdlineLeave autocommands.\n    trigger_cmd_autocmd(cmdline_type, EVENT_CMDLINELEAVE);\n\n    State = save_State;\n\n#ifdef FEAT_EVAL\n    if (!debug_mode)\n\tmay_trigger_modechanged();\n#endif\n\n#ifdef HAVE_INPUT_METHOD\n    if (b_im_ptr != NULL && buf_valid(b_im_ptr_buf)\n\t\t\t\t\t\t  && *b_im_ptr != B_IMODE_LMAP)\n\tim_save_status(b_im_ptr);\n    im_set_active(FALSE);\n#endif\n    setmouse();\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t\t// may show different cursor shape\n#endif\n    sb_text_end_cmdline();\n\ntheend:\n    {\n\tchar_u *p = ccline.cmdbuff;\n\n\t--depth;\n\tif (did_save_ccline)\n\t    restore_cmdline(&save_ccline);\n\telse\n\t    ccline.cmdbuff = NULL;\n\treturn p;\n    }\n}\n\n#if (defined(FEAT_CRYPT) || defined(FEAT_EVAL)) || defined(PROTO)\n/*\n * Get a command line with a prompt.\n * This is prepared to be called recursively from getcmdline() (e.g. by\n * f_input() when evaluating an expression from CTRL-R =).\n * Returns the command line in allocated memory, or NULL.\n */\n    char_u *\ngetcmdline_prompt(\n    int\t\tfirstc,\n    char_u\t*prompt,\t// command line prompt\n    int\t\tattr,\t\t// attributes for prompt\n    int\t\txp_context,\t// type of expansion\n    char_u\t*xp_arg)\t// user-defined expansion argument\n{\n    char_u\t\t*s;\n    cmdline_info_T\tsave_ccline;\n    int\t\t\tdid_save_ccline = FALSE;\n    int\t\t\tmsg_col_save = msg_col;\n    int\t\t\tmsg_silent_save = msg_silent;\n\n    if (ccline.cmdbuff != NULL)\n    {\n\t// Save the values of the current cmdline and restore them below.\n\tsave_cmdline(&save_ccline);\n\tdid_save_ccline = TRUE;\n    }\n\n    CLEAR_FIELD(ccline);\n    ccline.cmdprompt = prompt;\n    ccline.cmdattr = attr;\n# ifdef FEAT_EVAL\n    ccline.xp_context = xp_context;\n    ccline.xp_arg = xp_arg;\n    ccline.input_fn = (firstc == '@');\n# endif\n    msg_silent = 0;\n    s = getcmdline_int(firstc, 1L, 0, FALSE);\n\n    if (did_save_ccline)\n\trestore_cmdline(&save_ccline);\n\n    msg_silent = msg_silent_save;\n    // Restore msg_col, the prompt from input() may have changed it.\n    // But only if called recursively and the commandline is therefore being\n    // restored to an old one; if not, the input() prompt stays on the screen,\n    // so we need its modified msg_col left intact.\n    if (ccline.cmdbuff != NULL)\n\tmsg_col = msg_col_save;\n\n    return s;\n}\n#endif\n\n/*\n * Read the 'wildmode' option, fill wim_flags[].\n */\n    int\ncheck_opt_wim(void)\n{\n    char_u\tnew_wim_flags[4];\n    char_u\t*p;\n    int\t\ti;\n    int\t\tidx = 0;\n\n    for (i = 0; i < 4; ++i)\n\tnew_wim_flags[i] = 0;\n\n    for (p = p_wim; *p; ++p)\n    {\n\t// Note: Keep this in sync with p_wim_values.\n\tfor (i = 0; ASCII_ISALPHA(p[i]); ++i)\n\t    ;\n\tif (p[i] != NUL && p[i] != ',' && p[i] != ':')\n\t    return FAIL;\n\tif (i == 7 && STRNCMP(p, \"longest\", 7) == 0)\n\t    new_wim_flags[idx] |= WIM_LONGEST;\n\telse if (i == 4 && STRNCMP(p, \"full\", 4) == 0)\n\t    new_wim_flags[idx] |= WIM_FULL;\n\telse if (i == 4 && STRNCMP(p, \"list\", 4) == 0)\n\t    new_wim_flags[idx] |= WIM_LIST;\n\telse if (i == 8 && STRNCMP(p, \"lastused\", 8) == 0)\n\t    new_wim_flags[idx] |= WIM_BUFLASTUSED;\n\telse\n\t    return FAIL;\n\tp += i;\n\tif (*p == NUL)\n\t    break;\n\tif (*p == ',')\n\t{\n\t    if (idx == 3)\n\t\treturn FAIL;\n\t    ++idx;\n\t}\n    }\n\n    // fill remaining entries with last flag\n    while (idx < 3)\n    {\n\tnew_wim_flags[idx + 1] = new_wim_flags[idx];\n\t++idx;\n    }\n\n    // only when there are no errors, wim_flags[] is changed\n    for (i = 0; i < 4; ++i)\n\twim_flags[i] = new_wim_flags[i];\n    return OK;\n}\n\n/*\n * Return TRUE when the text must not be changed and we can't switch to\n * another window or buffer.  TRUE when editing the command line, evaluating\n * 'balloonexpr', etc.\n */\n    int\ntext_locked(void)\n{\n    if (cmdwin_type != 0)\n\treturn TRUE;\n    return textlock != 0;\n}\n\n/*\n * Give an error message for a command that isn't allowed while the cmdline\n * window is open or editing the cmdline in another way.\n */\n    void\ntext_locked_msg(void)\n{\n    emsg(_(get_text_locked_msg()));\n}\n\n    char *\nget_text_locked_msg(void)\n{\n    if (cmdwin_type != 0)\n\treturn e_invalid_in_cmdline_window;\n    return e_not_allowed_to_change_text_or_change_window;\n}\n\n/*\n * Check for text, window or buffer locked.\n * Give an error message and return TRUE if something is locked.\n */\n    int\ntext_or_buf_locked(void)\n{\n    if (text_locked())\n    {\n\ttext_locked_msg();\n\treturn TRUE;\n    }\n    return curbuf_locked();\n}\n\n/*\n * Check if \"curbuf_lock\" or \"allbuf_lock\" is set and return TRUE when it is\n * and give an error message.\n */\n    int\ncurbuf_locked(void)\n{\n    if (curbuf_lock > 0)\n    {\n\temsg(_(e_not_allowed_to_edit_another_buffer_now));\n\treturn TRUE;\n    }\n    return allbuf_locked();\n}\n\n/*\n * Check if \"allbuf_lock\" is set and return TRUE when it is and give an error\n * message.\n */\n    int\nallbuf_locked(void)\n{\n    if (allbuf_lock > 0)\n    {\n\temsg(_(e_not_allowed_to_change_buffer_information_now));\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n    static int\ncmdline_charsize(int idx)\n{\n#if defined(FEAT_CRYPT) || defined(FEAT_EVAL)\n    if (cmdline_star > 0)\t    // showing '*', always 1 position\n\treturn 1;\n#endif\n    return ptr2cells(ccline.cmdbuff + idx);\n}\n\n/*\n * Compute the offset of the cursor on the command line for the prompt and\n * indent.\n */\n    static void\nset_cmdspos(void)\n{\n    if (ccline.cmdfirstc != NUL)\n\tccline.cmdspos = 1 + ccline.cmdindent;\n    else\n\tccline.cmdspos = 0 + ccline.cmdindent;\n}\n\n/*\n * Compute the screen position for the cursor on the command line.\n */\n    static void\nset_cmdspos_cursor(void)\n{\n    int\t\ti, m, c;\n\n    set_cmdspos();\n    if (KeyTyped)\n    {\n\tm = Columns * Rows;\n\tif (m < 0)\t// overflow, Columns or Rows at weird value\n\t    m = MAXCOL;\n    }\n    else\n\tm = MAXCOL;\n    for (i = 0; i < ccline.cmdlen && i < ccline.cmdpos; ++i)\n    {\n\tc = cmdline_charsize(i);\n\t// Count \">\" for double-wide multi-byte char that doesn't fit.\n\tif (has_mbyte)\n\t    correct_cmdspos(i, c);\n\t// If the cmdline doesn't fit, show cursor on last visible char.\n\t// Don't move the cursor itself, so we can still append.\n\tif ((ccline.cmdspos += c) >= m)\n\t{\n\t    ccline.cmdspos -= c;\n\t    break;\n\t}\n\tif (has_mbyte)\n\t    i += (*mb_ptr2len)(ccline.cmdbuff + i) - 1;\n    }\n}\n\n/*\n * Check if the character at \"idx\", which is \"cells\" wide, is a multi-byte\n * character that doesn't fit, so that a \">\" must be displayed.\n */\n    static void\ncorrect_cmdspos(int idx, int cells)\n{\n    if ((*mb_ptr2len)(ccline.cmdbuff + idx) > 1\n\t\t&& (*mb_ptr2cells)(ccline.cmdbuff + idx) > 1\n\t\t&& ccline.cmdspos % Columns + cells > Columns)\n\tccline.cmdspos++;\n}\n\n/*\n * Get an Ex command line for the \":\" command.\n */\n    char_u *\ngetexline(\n    int\t\tc,\t\t// normally ':', NUL for \":append\"\n    void\t*cookie UNUSED,\n    int\t\tindent,\t\t// indent for inside conditionals\n    getline_opt_T options)\n{\n    // When executing a register, remove ':' that's in front of each line.\n    if (exec_from_reg && vpeekc() == ':')\n\t(void)vgetc();\n    return getcmdline(c, 1L, indent, options);\n}\n\n/*\n * Get an Ex command line for Ex mode.\n * In Ex mode we only use the OS supplied line editing features and no\n * mappings or abbreviations.\n * Returns a string in allocated memory or NULL.\n */\n    char_u *\ngetexmodeline(\n    int\t\tpromptc,\t// normally ':', NUL for \":append\" and '?' for\n\t\t\t\t// :s prompt\n    void\t*cookie UNUSED,\n    int\t\tindent,\t\t// indent for inside conditionals\n    getline_opt_T options UNUSED)\n{\n    garray_T\tline_ga;\n    char_u\t*pend;\n    int\t\tstartcol = 0;\n    int\t\tc1 = 0;\n    int\t\tescaped = FALSE;\t// CTRL-V typed\n    int\t\tvcol = 0;\n    char_u\t*p;\n    int\t\tprev_char;\n    int\t\tlen;\n\n    // Switch cursor on now.  This avoids that it happens after the \"\\n\", which\n    // confuses the system function that computes tabstops.\n    cursor_on();\n\n    // always start in column 0; write a newline if necessary\n    compute_cmdrow();\n    if ((msg_col || msg_didout) && promptc != '?')\n\tmsg_putchar('\\n');\n    if (promptc == ':')\n    {\n\t// indent that is only displayed, not in the line itself\n\tif (p_prompt)\n\t    msg_putchar(':');\n\twhile (indent-- > 0)\n\t    msg_putchar(' ');\n\tstartcol = msg_col;\n    }\n\n    ga_init2(&line_ga, 1, 30);\n\n    // autoindent for :insert and :append is in the line itself\n    if (promptc <= 0)\n    {\n\tvcol = indent;\n\twhile (indent >= 8)\n\t{\n\t    ga_append(&line_ga, TAB);\n\t    msg_puts(\"        \");\n\t    indent -= 8;\n\t}\n\twhile (indent-- > 0)\n\t{\n\t    ga_append(&line_ga, ' ');\n\t    msg_putchar(' ');\n\t}\n    }\n    ++no_mapping;\n    ++allow_keys;\n\n    /*\n     * Get the line, one character at a time.\n     */\n    got_int = FALSE;\n    while (!got_int)\n    {\n\tlong    sw;\n\tchar_u *s;\n\n\t// May request the keyboard protocol state now.\n\tmay_send_t_RK();\n\n\tif (ga_grow(&line_ga, 40) == FAIL)\n\t    break;\n\n\t/*\n\t * Get one character at a time.\n\t */\n\tprev_char = c1;\n\n\t// Check for a \":normal\" command and no more characters left.\n\tif (ex_normal_busy > 0 && typebuf.tb_len == 0)\n\t    c1 = '\\n';\n\telse\n\t    c1 = vgetc();\n\n\t/*\n\t * Handle line editing.\n\t * Previously this was left to the system, putting the terminal in\n\t * cooked mode, but then CTRL-D and CTRL-T can't be used properly.\n\t */\n\tif (got_int)\n\t{\n\t    msg_putchar('\\n');\n\t    break;\n\t}\n\n\tif (c1 == K_PS)\n\t{\n\t    bracketed_paste(PASTE_EX, FALSE, &line_ga);\n\t    goto redraw;\n\t}\n\n\tif (!escaped)\n\t{\n\t    // CR typed means \"enter\", which is NL\n\t    if (c1 == '\\r')\n\t\tc1 = '\\n';\n\n\t    if (c1 == BS || c1 == K_BS\n\t\t\t  || c1 == DEL || c1 == K_DEL || c1 == K_KDEL)\n\t    {\n\t\tif (line_ga.ga_len > 0)\n\t\t{\n\t\t    if (has_mbyte)\n\t\t    {\n\t\t\tp = (char_u *)line_ga.ga_data;\n\t\t\tp[line_ga.ga_len] = NUL;\n\t\t\tlen = (*mb_head_off)(p, p + line_ga.ga_len - 1) + 1;\n\t\t\tline_ga.ga_len -= len;\n\t\t    }\n\t\t    else\n\t\t\t--line_ga.ga_len;\n\t\t    goto redraw;\n\t\t}\n\t\tcontinue;\n\t    }\n\n\t    if (c1 == Ctrl_U)\n\t    {\n\t\tmsg_col = startcol;\n\t\tmsg_clr_eos();\n\t\tline_ga.ga_len = 0;\n\t\tgoto redraw;\n\t    }\n\n\t    if (c1 == Ctrl_T)\n\t    {\n\t\tsw = get_sw_value(curbuf);\n\t\tp = (char_u *)line_ga.ga_data;\n\t\tp[line_ga.ga_len] = NUL;\n\t\tindent = get_indent_str(p, 8, FALSE);\n\t\tindent += sw - indent % sw;\nadd_indent:\n\t\twhile (get_indent_str(p, 8, FALSE) < indent)\n\t\t{\n\t\t    (void)ga_grow(&line_ga, 2);  // one more for the NUL\n\t\t    p = (char_u *)line_ga.ga_data;\n\t\t    s = skipwhite(p);\n\t\t    mch_memmove(s + 1, s, line_ga.ga_len - (s - p) + 1);\n\t\t    *s = ' ';\n\t\t    ++line_ga.ga_len;\n\t\t}\nredraw:\n\t\t// redraw the line\n\t\tmsg_col = startcol;\n\t\tvcol = 0;\n\t\tp = (char_u *)line_ga.ga_data;\n\t\tp[line_ga.ga_len] = NUL;\n\t\twhile (p < (char_u *)line_ga.ga_data + line_ga.ga_len)\n\t\t{\n\t\t    if (*p == TAB)\n\t\t    {\n\t\t\tdo\n\t\t\t    msg_putchar(' ');\n\t\t\twhile (++vcol % 8);\n\t\t\t++p;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tlen = mb_ptr2len(p);\n\t\t\tmsg_outtrans_len(p, len);\n\t\t\tvcol += ptr2cells(p);\n\t\t\tp += len;\n\t\t    }\n\t\t}\n\t\tmsg_clr_eos();\n\t\twindgoto(msg_row, msg_col);\n\t\tcontinue;\n\t    }\n\n\t    if (c1 == Ctrl_D)\n\t    {\n\t\t// Delete one shiftwidth.\n\t\tp = (char_u *)line_ga.ga_data;\n\t\tif (prev_char == '0' || prev_char == '^')\n\t\t{\n\t\t    if (prev_char == '^')\n\t\t\tex_keep_indent = TRUE;\n\t\t    indent = 0;\n\t\t    p[--line_ga.ga_len] = NUL;\n\t\t}\n\t\telse\n\t\t{\n\t\t    p[line_ga.ga_len] = NUL;\n\t\t    indent = get_indent_str(p, 8, FALSE);\n\t\t    if (indent > 0)\n\t\t    {\n\t\t\t--indent;\n\t\t\tindent -= indent % get_sw_value(curbuf);\n\t\t    }\n\t\t}\n\t\twhile (get_indent_str(p, 8, FALSE) > indent)\n\t\t{\n\t\t    s = skipwhite(p);\n\t\t    mch_memmove(s - 1, s, line_ga.ga_len - (s - p) + 1);\n\t\t    --line_ga.ga_len;\n\t\t}\n\t\tgoto add_indent;\n\t    }\n\n\t    if (c1 == Ctrl_V || c1 == Ctrl_Q)\n\t    {\n\t\tescaped = TRUE;\n\t\tcontinue;\n\t    }\n\n\t    // Ignore special key codes: mouse movement, K_IGNORE, etc.\n\t    if (IS_SPECIAL(c1))\n\t\tcontinue;\n\t}\n\n\tif (IS_SPECIAL(c1))\n\t    c1 = '?';\n\tif (has_mbyte)\n\t    len = (*mb_char2bytes)(c1,\n\t\t\t\t  (char_u *)line_ga.ga_data + line_ga.ga_len);\n\telse\n\t{\n\t    len = 1;\n\t    ((char_u *)line_ga.ga_data)[line_ga.ga_len] = c1;\n\t}\n\tif (c1 == '\\n')\n\t    msg_putchar('\\n');\n\telse if (c1 == TAB)\n\t{\n\t    // Don't use chartabsize(), 'ts' can be different\n\t    do\n\t\tmsg_putchar(' ');\n\t    while (++vcol % 8);\n\t}\n\telse\n\t{\n\t    msg_outtrans_len(\n\t\t     ((char_u *)line_ga.ga_data) + line_ga.ga_len, len);\n\t    vcol += char2cells(c1);\n\t}\n\tline_ga.ga_len += len;\n\tescaped = FALSE;\n\n\twindgoto(msg_row, msg_col);\n\tpend = (char_u *)(line_ga.ga_data) + line_ga.ga_len;\n\n\t// We are done when a NL is entered, but not when it comes after an\n\t// odd number of backslashes, that results in a NUL.\n\tif (line_ga.ga_len > 0 && pend[-1] == '\\n')\n\t{\n\t    int bcount = 0;\n\n\t    while (line_ga.ga_len - 2 >= bcount && pend[-2 - bcount] == '\\\\')\n\t\t++bcount;\n\n\t    if (bcount > 0)\n\t    {\n\t\t// Halve the number of backslashes: \"\\NL\" -> \"NUL\", \"\\\\NL\" ->\n\t\t// \"\\NL\", etc.\n\t\tline_ga.ga_len -= (bcount + 1) / 2;\n\t\tpend -= (bcount + 1) / 2;\n\t\tpend[-1] = '\\n';\n\t    }\n\n\t    if ((bcount & 1) == 0)\n\t    {\n\t\t--line_ga.ga_len;\n\t\t--pend;\n\t\t*pend = NUL;\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    --no_mapping;\n    --allow_keys;\n\n    // make following messages go to the next line\n    msg_didout = FALSE;\n    msg_col = 0;\n    if (msg_row < Rows - 1)\n\t++msg_row;\n    emsg_on_display = FALSE;\t\t// don't want ui_delay()\n\n    if (got_int)\n\tga_clear(&line_ga);\n\n    return (char_u *)line_ga.ga_data;\n}\n\n# if defined(MCH_CURSOR_SHAPE) || defined(FEAT_GUI) \\\n\t|| defined(FEAT_MOUSESHAPE) || defined(PROTO)\n/*\n * Return TRUE if ccline.overstrike is on.\n */\n    int\ncmdline_overstrike(void)\n{\n    return ccline.overstrike;\n}\n\n/*\n * Return TRUE if the cursor is at the end of the cmdline.\n */\n    int\ncmdline_at_end(void)\n{\n    return (ccline.cmdpos >= ccline.cmdlen);\n}\n#endif\n\n#if (defined(FEAT_XIM) && (defined(FEAT_GUI_GTK))) || defined(PROTO)\n/*\n * Return the virtual column number at the current cursor position.\n * This is used by the IM code to obtain the start of the preedit string.\n */\n    colnr_T\ncmdline_getvcol_cursor(void)\n{\n    if (ccline.cmdbuff == NULL || ccline.cmdpos > ccline.cmdlen)\n\treturn MAXCOL;\n\n    if (has_mbyte)\n    {\n\tcolnr_T\tcol;\n\tint\ti = 0;\n\n\tfor (col = 0; i < ccline.cmdpos; ++col)\n\t    i += (*mb_ptr2len)(ccline.cmdbuff + i);\n\n\treturn col;\n    }\n    else\n\treturn ccline.cmdpos;\n}\n#endif\n\n#if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)\n/*\n * If part of the command line is an IM preedit string, redraw it with\n * IM feedback attributes.  The cursor position is restored after drawing.\n */\n    static void\nredrawcmd_preedit(void)\n{\n    if ((State & MODE_CMDLINE)\n\t    && xic != NULL\n\t    // && im_get_status()  doesn't work when using SCIM\n\t    && !p_imdisable\n\t    && im_is_preediting())\n    {\n\tint\tcmdpos = 0;\n\tint\tcmdspos;\n\tint\told_row;\n\tint\told_col;\n\tcolnr_T\tcol;\n\n\told_row = msg_row;\n\told_col = msg_col;\n\tcmdspos = ((ccline.cmdfirstc != NUL) ? 1 : 0) + ccline.cmdindent;\n\n\tif (has_mbyte)\n\t{\n\t    for (col = 0; col < preedit_start_col\n\t\t\t  && cmdpos < ccline.cmdlen; ++col)\n\t    {\n\t\tcmdspos += (*mb_ptr2cells)(ccline.cmdbuff + cmdpos);\n\t\tcmdpos  += (*mb_ptr2len)(ccline.cmdbuff + cmdpos);\n\t    }\n\t}\n\telse\n\t{\n\t    cmdspos += preedit_start_col;\n\t    cmdpos  += preedit_start_col;\n\t}\n\n\tmsg_row = cmdline_row + (cmdspos / (int)Columns);\n\tmsg_col = cmdspos % (int)Columns;\n\tif (msg_row >= Rows)\n\t    msg_row = Rows - 1;\n\n\tfor (col = 0; cmdpos < ccline.cmdlen; ++col)\n\t{\n\t    int char_len;\n\t    int char_attr;\n\n\t    char_attr = im_get_feedback_attr(col);\n\t    if (char_attr < 0)\n\t\tbreak; // end of preedit string\n\n\t    if (has_mbyte)\n\t\tchar_len = (*mb_ptr2len)(ccline.cmdbuff + cmdpos);\n\t    else\n\t\tchar_len = 1;\n\n\t    msg_outtrans_len_attr(ccline.cmdbuff + cmdpos, char_len, char_attr);\n\t    cmdpos += char_len;\n\t}\n\n\tmsg_row = old_row;\n\tmsg_col = old_col;\n    }\n}\n#endif // FEAT_XIM && FEAT_GUI_GTK\n\n/*\n * Allocate a new command line buffer.\n * Assigns the new buffer to ccline.cmdbuff and ccline.cmdbufflen.\n */\n    static void\nalloc_cmdbuff(int len)\n{\n    /*\n     * give some extra space to avoid having to allocate all the time\n     */\n    if (len < 80)\n\tlen = 100;\n    else\n\tlen += 20;\n\n    ccline.cmdbuff = alloc(len);    // caller should check for out-of-memory\n    ccline.cmdbufflen = len;\n}\n\n/*\n * Re-allocate the command line to length len + something extra.\n * return FAIL for failure, OK otherwise\n */\n    int\nrealloc_cmdbuff(int len)\n{\n    char_u\t*p;\n\n    if (len < ccline.cmdbufflen)\n\treturn OK;\t\t\t// no need to resize\n\n    p = ccline.cmdbuff;\n    alloc_cmdbuff(len);\t\t\t// will get some more\n    if (ccline.cmdbuff == NULL)\t\t// out of memory\n    {\n\tccline.cmdbuff = p;\t\t// keep the old one\n\treturn FAIL;\n    }\n    // There isn't always a NUL after the command, but it may need to be\n    // there, thus copy up to the NUL and add a NUL.\n    mch_memmove(ccline.cmdbuff, p, (size_t)ccline.cmdlen);\n    ccline.cmdbuff[ccline.cmdlen] = NUL;\n    vim_free(p);\n\n    if (ccline.xpc != NULL\n\t    && ccline.xpc->xp_pattern != NULL\n\t    && ccline.xpc->xp_context != EXPAND_NOTHING\n\t    && ccline.xpc->xp_context != EXPAND_UNSUCCESSFUL)\n    {\n\tint i = (int)(ccline.xpc->xp_pattern - p);\n\n\t// If xp_pattern points inside the old cmdbuff it needs to be adjusted\n\t// to point into the newly allocated memory.\n\tif (i >= 0 && i <= ccline.cmdlen)\n\t    ccline.xpc->xp_pattern = ccline.cmdbuff + i;\n    }\n\n    return OK;\n}\n\n#if defined(FEAT_ARABIC) || defined(PROTO)\nstatic char_u\t*arshape_buf = NULL;\n\n# if defined(EXITFREE) || defined(PROTO)\n    void\nfree_arshape_buf(void)\n{\n    vim_free(arshape_buf);\n}\n# endif\n#endif\n\n/*\n * Draw part of the cmdline at the current cursor position.  But draw stars\n * when cmdline_star is TRUE.\n */\n    static void\ndraw_cmdline(int start, int len)\n{\n#if defined(FEAT_CRYPT) || defined(FEAT_EVAL)\n    int\t\ti;\n\n    if (cmdline_star > 0)\n\tfor (i = 0; i < len; ++i)\n\t{\n\t    msg_putchar('*');\n\t    if (has_mbyte)\n\t\ti += (*mb_ptr2len)(ccline.cmdbuff + start + i) - 1;\n\t}\n    else\n#endif\n#ifdef FEAT_ARABIC\n\tif (p_arshape && !p_tbidi && cmdline_has_arabic(start, len))\n    {\n\tstatic int\tbuflen = 0;\n\tchar_u\t\t*p;\n\tint\t\tj;\n\tint\t\tnewlen = 0;\n\tint\t\tmb_l;\n\tint\t\tpc, pc1 = 0;\n\tint\t\tprev_c = 0;\n\tint\t\tprev_c1 = 0;\n\tint\t\tu8c;\n\tint\t\tu8cc[MAX_MCO];\n\tint\t\tnc = 0;\n\n\t/*\n\t * Do arabic shaping into a temporary buffer.  This is very\n\t * inefficient!\n\t */\n\tif (len * 2 + 2 > buflen)\n\t{\n\t    // Re-allocate the buffer.  We keep it around to avoid a lot of\n\t    // alloc()/free() calls.\n\t    vim_free(arshape_buf);\n\t    buflen = len * 2 + 2;\n\t    arshape_buf = alloc(buflen);\n\t    if (arshape_buf == NULL)\n\t\treturn;\t// out of memory\n\t}\n\n\tif (utf_iscomposing(utf_ptr2char(ccline.cmdbuff + start)))\n\t{\n\t    // Prepend a space to draw the leading composing char on.\n\t    arshape_buf[0] = ' ';\n\t    newlen = 1;\n\t}\n\n\tfor (j = start; j < start + len; j += mb_l)\n\t{\n\t    p = ccline.cmdbuff + j;\n\t    u8c = utfc_ptr2char_len(p, u8cc, start + len - j);\n\t    mb_l = utfc_ptr2len_len(p, start + len - j);\n\t    if (ARABIC_CHAR(u8c))\n\t    {\n\t\t// Do Arabic shaping.\n\t\tif (cmdmsg_rl)\n\t\t{\n\t\t    // displaying from right to left\n\t\t    pc = prev_c;\n\t\t    pc1 = prev_c1;\n\t\t    prev_c1 = u8cc[0];\n\t\t    if (j + mb_l >= start + len)\n\t\t\tnc = NUL;\n\t\t    else\n\t\t\tnc = utf_ptr2char(p + mb_l);\n\t\t}\n\t\telse\n\t\t{\n\t\t    // displaying from left to right\n\t\t    if (j + mb_l >= start + len)\n\t\t\tpc = NUL;\n\t\t    else\n\t\t    {\n\t\t\tint\tpcc[MAX_MCO];\n\n\t\t\tpc = utfc_ptr2char_len(p + mb_l, pcc,\n\t\t\t\t\t\t      start + len - j - mb_l);\n\t\t\tpc1 = pcc[0];\n\t\t    }\n\t\t    nc = prev_c;\n\t\t}\n\t\tprev_c = u8c;\n\n\t\tu8c = arabic_shape(u8c, NULL, &u8cc[0], pc, pc1, nc);\n\n\t\tnewlen += (*mb_char2bytes)(u8c, arshape_buf + newlen);\n\t\tif (u8cc[0] != 0)\n\t\t{\n\t\t    newlen += (*mb_char2bytes)(u8cc[0], arshape_buf + newlen);\n\t\t    if (u8cc[1] != 0)\n\t\t\tnewlen += (*mb_char2bytes)(u8cc[1],\n\t\t\t\t\t\t\tarshape_buf + newlen);\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tprev_c = u8c;\n\t\tmch_memmove(arshape_buf + newlen, p, mb_l);\n\t\tnewlen += mb_l;\n\t    }\n\t}\n\n\tmsg_outtrans_len(arshape_buf, newlen);\n    }\n    else\n#endif\n\tmsg_outtrans_len(ccline.cmdbuff + start, len);\n}\n\n/*\n * Put a character on the command line.  Shifts the following text to the\n * right when \"shift\" is TRUE.  Used for CTRL-V, CTRL-K, etc.\n * \"c\" must be printable (fit in one display cell)!\n */\n    void\nputcmdline(int c, int shift)\n{\n    if (cmd_silent)\n\treturn;\n    msg_no_more = TRUE;\n    msg_putchar(c);\n    if (shift)\n\tdraw_cmdline(ccline.cmdpos, ccline.cmdlen - ccline.cmdpos);\n    msg_no_more = FALSE;\n    cursorcmd();\n    extra_char = c;\n    extra_char_shift = shift;\n}\n\n/*\n * Undo a putcmdline(c, FALSE).\n */\n    void\nunputcmdline(void)\n{\n    if (cmd_silent)\n\treturn;\n    msg_no_more = TRUE;\n    if (ccline.cmdlen == ccline.cmdpos)\n\tmsg_putchar(' ');\n    else if (has_mbyte)\n\tdraw_cmdline(ccline.cmdpos,\n\t\t\t       (*mb_ptr2len)(ccline.cmdbuff + ccline.cmdpos));\n    else\n\tdraw_cmdline(ccline.cmdpos, 1);\n    msg_no_more = FALSE;\n    cursorcmd();\n    extra_char = NUL;\n}\n\n/*\n * Put the given string, of the given length, onto the command line.\n * If len is -1, then STRLEN() is used to calculate the length.\n * If 'redraw' is TRUE then the new part of the command line, and the remaining\n * part will be redrawn, otherwise it will not.  If this function is called\n * twice in a row, then 'redraw' should be FALSE and redrawcmd() should be\n * called afterwards.\n */\n    int\nput_on_cmdline(char_u *str, int len, int redraw)\n{\n    int\t\tretval;\n    int\t\ti;\n    int\t\tm;\n    int\t\tc;\n\n    if (len < 0)\n\tlen = (int)STRLEN(str);\n\n    // Check if ccline.cmdbuff needs to be longer\n    if (ccline.cmdlen + len + 1 >= ccline.cmdbufflen)\n\tretval = realloc_cmdbuff(ccline.cmdlen + len + 1);\n    else\n\tretval = OK;\n    if (retval == OK)\n    {\n\tif (!ccline.overstrike)\n\t{\n\t    mch_memmove(ccline.cmdbuff + ccline.cmdpos + len,\n\t\t\t\t\t       ccline.cmdbuff + ccline.cmdpos,\n\t\t\t\t     (size_t)(ccline.cmdlen - ccline.cmdpos));\n\t    ccline.cmdlen += len;\n\t}\n\telse\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\t// Count nr of characters in the new string.\n\t\tm = 0;\n\t\tfor (i = 0; i < len; i += (*mb_ptr2len)(str + i))\n\t\t    ++m;\n\t\t// Count nr of bytes in cmdline that are overwritten by these\n\t\t// characters.\n\t\tfor (i = ccline.cmdpos; i < ccline.cmdlen && m > 0;\n\t\t\t\t i += (*mb_ptr2len)(ccline.cmdbuff + i))\n\t\t    --m;\n\t\tif (i < ccline.cmdlen)\n\t\t{\n\t\t    mch_memmove(ccline.cmdbuff + ccline.cmdpos + len,\n\t\t\t    ccline.cmdbuff + i, (size_t)(ccline.cmdlen - i));\n\t\t    ccline.cmdlen += ccline.cmdpos + len - i;\n\t\t}\n\t\telse\n\t\t    ccline.cmdlen = ccline.cmdpos + len;\n\t    }\n\t    else if (ccline.cmdpos + len > ccline.cmdlen)\n\t\tccline.cmdlen = ccline.cmdpos + len;\n\t}\n\tmch_memmove(ccline.cmdbuff + ccline.cmdpos, str, (size_t)len);\n\tccline.cmdbuff[ccline.cmdlen] = NUL;\n\n\tif (enc_utf8)\n\t{\n\t    // When the inserted text starts with a composing character,\n\t    // backup to the character before it.  There could be two of them.\n\t    i = 0;\n\t    c = utf_ptr2char(ccline.cmdbuff + ccline.cmdpos);\n\t    while (ccline.cmdpos > 0 && utf_iscomposing(c))\n\t    {\n\t\ti = (*mb_head_off)(ccline.cmdbuff,\n\t\t\t\t      ccline.cmdbuff + ccline.cmdpos - 1) + 1;\n\t\tccline.cmdpos -= i;\n\t\tlen += i;\n\t\tc = utf_ptr2char(ccline.cmdbuff + ccline.cmdpos);\n\t    }\n#ifdef FEAT_ARABIC\n\t    if (i == 0 && ccline.cmdpos > 0 && arabic_maycombine(c))\n\t    {\n\t\t// Check the previous character for Arabic combining pair.\n\t\ti = (*mb_head_off)(ccline.cmdbuff,\n\t\t\t\t      ccline.cmdbuff + ccline.cmdpos - 1) + 1;\n\t\tif (arabic_combine(utf_ptr2char(ccline.cmdbuff\n\t\t\t\t\t\t     + ccline.cmdpos - i), c))\n\t\t{\n\t\t    ccline.cmdpos -= i;\n\t\t    len += i;\n\t\t}\n\t\telse\n\t\t    i = 0;\n\t    }\n#endif\n\t    if (i != 0)\n\t    {\n\t\t// Also backup the cursor position.\n\t\ti = ptr2cells(ccline.cmdbuff + ccline.cmdpos);\n\t\tccline.cmdspos -= i;\n\t\tmsg_col -= i;\n\t\tif (msg_col < 0)\n\t\t{\n\t\t    msg_col += Columns;\n\t\t    --msg_row;\n\t\t}\n\t    }\n\t}\n\n\tif (redraw && !cmd_silent)\n\t{\n\t    msg_no_more = TRUE;\n\t    i = cmdline_row;\n\t    cursorcmd();\n\t    draw_cmdline(ccline.cmdpos, ccline.cmdlen - ccline.cmdpos);\n\t    // Avoid clearing the rest of the line too often.\n\t    if (cmdline_row != i || ccline.overstrike)\n\t\tmsg_clr_eos();\n\t    msg_no_more = FALSE;\n\t}\n\tif (KeyTyped)\n\t{\n\t    m = Columns * Rows;\n\t    if (m < 0)\t// overflow, Columns or Rows at weird value\n\t\tm = MAXCOL;\n\t}\n\telse\n\t    m = MAXCOL;\n\tfor (i = 0; i < len; ++i)\n\t{\n\t    c = cmdline_charsize(ccline.cmdpos);\n\t    // count \">\" for a double-wide char that doesn't fit.\n\t    if (has_mbyte)\n\t\tcorrect_cmdspos(ccline.cmdpos, c);\n\t    // Stop cursor at the end of the screen, but do increment the\n\t    // insert position, so that entering a very long command\n\t    // works, even though you can't see it.\n\t    if (ccline.cmdspos + c < m)\n\t\tccline.cmdspos += c;\n\n\t    if (has_mbyte)\n\t    {\n\t\tc = (*mb_ptr2len)(ccline.cmdbuff + ccline.cmdpos) - 1;\n\t\tif (c > len - i - 1)\n\t\t    c = len - i - 1;\n\t\tccline.cmdpos += c;\n\t\ti += c;\n\t    }\n\t    ++ccline.cmdpos;\n\t}\n    }\n    if (redraw)\n\tmsg_check();\n    return retval;\n}\n\nstatic cmdline_info_T\tprev_ccline;\nstatic int\t\tprev_ccline_used = FALSE;\n\n/*\n * Save ccline, because obtaining the \"=\" register may execute \"normal :cmd\"\n * and overwrite it.  But get_cmdline_str() may need it, thus make it\n * available globally in prev_ccline.\n */\n    static void\nsave_cmdline(cmdline_info_T *ccp)\n{\n    if (!prev_ccline_used)\n    {\n\tCLEAR_FIELD(prev_ccline);\n\tprev_ccline_used = TRUE;\n    }\n    *ccp = prev_ccline;\n    prev_ccline = ccline;\n    ccline.cmdbuff = NULL;  // signal that ccline is not in use\n}\n\n/*\n * Restore ccline after it has been saved with save_cmdline().\n */\n    static void\nrestore_cmdline(cmdline_info_T *ccp)\n{\n    ccline = prev_ccline;\n    prev_ccline = *ccp;\n}\n\n/*\n * Paste a yank register into the command line.\n * Used by CTRL-R command in command-line mode.\n * insert_reg() can't be used here, because special characters from the\n * register contents will be interpreted as commands.\n *\n * Return FAIL for failure, OK otherwise.\n */\n    static int\ncmdline_paste(\n    int regname,\n    int literally,\t// Insert text literally instead of \"as typed\"\n    int remcr)\t\t// remove trailing CR\n{\n    long\t\ti;\n    char_u\t\t*arg;\n    char_u\t\t*p;\n    int\t\t\tallocated;\n\n    // check for valid regname; also accept special characters for CTRL-R in\n    // the command line\n    if (regname != Ctrl_F && regname != Ctrl_P && regname != Ctrl_W\n\t    && regname != Ctrl_A && regname != Ctrl_L\n\t    && !valid_yank_reg(regname, FALSE))\n\treturn FAIL;\n\n    // A register containing CTRL-R can cause an endless loop.  Allow using\n    // CTRL-C to break the loop.\n    line_breakcheck();\n    if (got_int)\n\treturn FAIL;\n\n#ifdef FEAT_CLIPBOARD\n    regname = may_get_selection(regname);\n#endif\n\n    // Need to set \"textlock\" to avoid nasty things like going to another\n    // buffer when evaluating an expression.\n    ++textlock;\n    i = get_spec_reg(regname, &arg, &allocated, TRUE);\n    --textlock;\n\n    if (i)\n    {\n\t// Got the value of a special register in \"arg\".\n\tif (arg == NULL)\n\t    return FAIL;\n\n\t// When 'incsearch' is set and CTRL-R CTRL-W used: skip the duplicate\n\t// part of the word.\n\tp = arg;\n\tif (p_is && regname == Ctrl_W)\n\t{\n\t    char_u  *w;\n\t    int\t    len;\n\n\t    // Locate start of last word in the cmd buffer.\n\t    for (w = ccline.cmdbuff + ccline.cmdpos; w > ccline.cmdbuff; )\n\t    {\n\t\tif (has_mbyte)\n\t\t{\n\t\t    len = (*mb_head_off)(ccline.cmdbuff, w - 1) + 1;\n\t\t    if (!vim_iswordc(mb_ptr2char(w - len)))\n\t\t\tbreak;\n\t\t    w -= len;\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (!vim_iswordc(w[-1]))\n\t\t\tbreak;\n\t\t    --w;\n\t\t}\n\t    }\n\t    len = (int)((ccline.cmdbuff + ccline.cmdpos) - w);\n\t    if (p_ic ? STRNICMP(w, arg, len) == 0 : STRNCMP(w, arg, len) == 0)\n\t\tp += len;\n\t}\n\n\tcmdline_paste_str(p, literally);\n\tif (allocated)\n\t    vim_free(arg);\n\treturn OK;\n    }\n\n    return cmdline_paste_reg(regname, literally, remcr);\n}\n\n/*\n * Put a string on the command line.\n * When \"literally\" is TRUE, insert literally.\n * When \"literally\" is FALSE, insert as typed, but don't leave the command\n * line.\n */\n    void\ncmdline_paste_str(char_u *s, int literally)\n{\n    int\t\tc, cv;\n\n    if (literally)\n\tput_on_cmdline(s, -1, TRUE);\n    else\n\twhile (*s != NUL)\n\t{\n\t    cv = *s;\n\t    if (cv == Ctrl_V && s[1])\n\t\t++s;\n\t    if (has_mbyte)\n\t\tc = mb_cptr2char_adv(&s);\n\t    else\n\t\tc = *s++;\n\t    if (cv == Ctrl_V || c == ESC || c == Ctrl_C\n\t\t    || c == CAR || c == NL || c == Ctrl_L\n#ifdef UNIX\n\t\t    || c == intr_char\n#endif\n\t\t    || (c == Ctrl_BSL && *s == Ctrl_N))\n\t\tstuffcharReadbuff(Ctrl_V);\n\t    stuffcharReadbuff(c);\n\t}\n}\n\n/*\n * This function is called when the screen size changes and with incremental\n * search and in other situations where the command line may have been\n * overwritten.\n */\n    void\nredrawcmdline(void)\n{\n    redrawcmdline_ex(TRUE);\n}\n\n/*\n * When \"do_compute_cmdrow\" is TRUE the command line is redrawn at the bottom.\n * If FALSE cmdline_row is used, which should redraw in the same place.\n */\n    void\nredrawcmdline_ex(int do_compute_cmdrow)\n{\n    if (cmd_silent)\n\treturn;\n    need_wait_return = FALSE;\n    if (do_compute_cmdrow)\n\tcompute_cmdrow();\n    redrawcmd();\n    cursorcmd();\n}\n\n    static void\nredrawcmdprompt(void)\n{\n    int\t\ti;\n\n    if (cmd_silent)\n\treturn;\n    if (ccline.cmdfirstc != NUL)\n\tmsg_putchar(ccline.cmdfirstc);\n    if (ccline.cmdprompt != NULL)\n    {\n\tmsg_puts_attr((char *)ccline.cmdprompt, ccline.cmdattr);\n\tccline.cmdindent = msg_col + (msg_row - cmdline_row) * Columns;\n\t// do the reverse of set_cmdspos()\n\tif (ccline.cmdfirstc != NUL)\n\t    --ccline.cmdindent;\n    }\n    else\n\tfor (i = ccline.cmdindent; i > 0; --i)\n\t    msg_putchar(' ');\n}\n\n/*\n * Redraw what is currently on the command line.\n */\n    void\nredrawcmd(void)\n{\n    int save_in_echowindow = in_echowindow;\n\n    if (cmd_silent)\n\treturn;\n\n    // when 'incsearch' is set there may be no command line while redrawing\n    if (ccline.cmdbuff == NULL)\n    {\n\twindgoto(cmdline_row, 0);\n\tmsg_clr_eos();\n\treturn;\n    }\n\n    // Do not put this in the message window.\n    in_echowindow = FALSE;\n\n    sb_text_restart_cmdline();\n    msg_start();\n    redrawcmdprompt();\n\n    // Don't use more prompt, truncate the cmdline if it doesn't fit.\n    msg_no_more = TRUE;\n    draw_cmdline(0, ccline.cmdlen);\n    msg_clr_eos();\n    msg_no_more = FALSE;\n\n    set_cmdspos_cursor();\n    if (extra_char != NUL)\n\tputcmdline(extra_char, extra_char_shift);\n\n    /*\n     * An emsg() before may have set msg_scroll. This is used in normal mode,\n     * in cmdline mode we can reset them now.\n     */\n    msg_scroll = FALSE;\t\t// next message overwrites cmdline\n\n    // Typing ':' at the more prompt may set skip_redraw.  We don't want this\n    // in cmdline mode\n    skip_redraw = FALSE;\n\n    in_echowindow = save_in_echowindow;\n}\n\n    void\ncompute_cmdrow(void)\n{\n    // ignore \"msg_scrolled\" in update_screen(), it will be reset soon.\n    if (exmode_active || (msg_scrolled != 0 && !updating_screen))\n\tcmdline_row = Rows - 1;\n    else\n\tcmdline_row = W_WINROW(lastwin) + lastwin->w_height\n\t\t\t\t\t\t    + lastwin->w_status_height;\n}\n\n    void\ncursorcmd(void)\n{\n    if (cmd_silent)\n\treturn;\n\n#ifdef FEAT_RIGHTLEFT\n    if (cmdmsg_rl)\n    {\n\tmsg_row = cmdline_row  + (ccline.cmdspos / (int)(Columns - 1));\n\tmsg_col = (int)Columns - (ccline.cmdspos % (int)(Columns - 1)) - 1;\n\tif (msg_row <= 0)\n\t    msg_row = Rows - 1;\n    }\n    else\n#endif\n    {\n\tmsg_row = cmdline_row + (ccline.cmdspos / (int)Columns);\n\tmsg_col = ccline.cmdspos % (int)Columns;\n\tif (msg_row >= Rows)\n\t    msg_row = Rows - 1;\n    }\n\n    windgoto(msg_row, msg_col);\n#if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)\n    if (p_imst == IM_ON_THE_SPOT)\n\tredrawcmd_preedit();\n#endif\n#ifdef MCH_CURSOR_SHAPE\n    mch_update_cursor();\n#endif\n}\n\n    void\ngotocmdline(int clr)\n{\n    msg_start();\n#ifdef FEAT_RIGHTLEFT\n    if (cmdmsg_rl)\n\tmsg_col = Columns - 1;\n    else\n#endif\n\tmsg_col = 0;\t    // always start in column 0\n    if (clr)\t\t    // clear the bottom line(s)\n\tmsg_clr_eos();\t    // will reset clear_cmdline\n    windgoto(cmdline_row, 0);\n}\n\n/*\n * Check the word in front of the cursor for an abbreviation.\n * Called when the non-id character \"c\" has been entered.\n * When an abbreviation is recognized it is removed from the text with\n * backspaces and the replacement string is inserted, followed by \"c\".\n */\n    static int\nccheck_abbr(int c)\n{\n    int spos = 0;\n\n    if (p_paste || no_abbr)\t    // no abbreviations or in paste mode\n\treturn FALSE;\n\n    // Do not consider '<,'> be part of the mapping, skip leading whitespace.\n    // Actually accepts any mark.\n    while (VIM_ISWHITE(ccline.cmdbuff[spos]) && spos < ccline.cmdlen)\n\tspos++;\n    if (ccline.cmdlen - spos > 5\n\t    && ccline.cmdbuff[spos] == '\\''\n\t    && ccline.cmdbuff[spos + 2] == ','\n\t    && ccline.cmdbuff[spos + 3] == '\\'')\n\tspos += 5;\n    else\n\t// check abbreviation from the beginning of the commandline\n\tspos = 0;\n\n    return check_abbr(c, ccline.cmdbuff, ccline.cmdpos, spos);\n}\n\n/*\n * Escape special characters in \"fname\", depending on \"what\":\n * VSE_NONE: for when used as a file name argument after a Vim command.\n * VSE_SHELL: for a shell command.\n * VSE_BUFFER: for the \":buffer\" command.\n * Returns the result in allocated memory.\n */\n    char_u *\nvim_strsave_fnameescape(char_u *fname, int what)\n{\n    char_u\t*p;\n#ifdef BACKSLASH_IN_FILENAME\n    char_u\tbuf[20];\n    int\t\tj = 0;\n\n    // Don't escape '[', '{' and '!' if they are in 'isfname' and for the\n    // \":buffer\" command.\n    for (p = what == VSE_BUFFER ? BUFFER_ESC_CHARS : PATH_ESC_CHARS;\n\t\t\t\t\t\t\t\t*p != NUL; ++p)\n\tif ((*p != '[' && *p != '{' && *p != '!') || !vim_isfilec(*p))\n\t    buf[j++] = *p;\n    buf[j] = NUL;\n    p = vim_strsave_escaped(fname, buf);\n#else\n    p = vim_strsave_escaped(fname, what == VSE_SHELL ? SHELL_ESC_CHARS\n\t\t    : what == VSE_BUFFER ? BUFFER_ESC_CHARS : PATH_ESC_CHARS);\n    if (what == VSE_SHELL && csh_like_shell() && p != NULL)\n    {\n\tchar_u\t    *s;\n\n\t// For csh and similar shells need to put two backslashes before '!'.\n\t// One is taken by Vim, one by the shell.\n\ts = vim_strsave_escaped(p, (char_u *)\"!\");\n\tvim_free(p);\n\tp = s;\n    }\n#endif\n\n    // '>' and '+' are special at the start of some commands, e.g. \":edit\" and\n    // \":write\".  \"cd -\" has a special meaning.\n    if (p != NULL && (*p == '>' || *p == '+' || (*p == '-' && p[1] == NUL)))\n\tescape_fname(&p);\n\n    return p;\n}\n\n/*\n * Put a backslash before the file name in \"pp\", which is in allocated memory.\n */\n    void\nescape_fname(char_u **pp)\n{\n    char_u\t*p;\n\n    p = alloc(STRLEN(*pp) + 2);\n    if (p == NULL)\n\treturn;\n\n    p[0] = '\\\\';\n    STRCPY(p + 1, *pp);\n    vim_free(*pp);\n    *pp = p;\n}\n\n/*\n * For each file name in files[num_files]:\n * If 'orig_pat' starts with \"~/\", replace the home directory with \"~\".\n */\n    void\ntilde_replace(\n    char_u  *orig_pat,\n    int\t    num_files,\n    char_u  **files)\n{\n    int\t    i;\n    char_u  *p;\n\n    if (orig_pat[0] == '~' && vim_ispathsep(orig_pat[1]))\n    {\n\tfor (i = 0; i < num_files; ++i)\n\t{\n\t    p = home_replace_save(NULL, files[i]);\n\t    if (p != NULL)\n\t    {\n\t\tvim_free(files[i]);\n\t\tfiles[i] = p;\n\t    }\n\t}\n    }\n}\n\n/*\n * Get a pointer to the current command line info.\n */\n    cmdline_info_T *\nget_cmdline_info(void)\n{\n    return &ccline;\n}\n\n/*\n * Get pointer to the command line info to use. save_cmdline() may clear\n * ccline and put the previous value in prev_ccline.\n */\n    static cmdline_info_T *\nget_ccline_ptr(void)\n{\n    if ((State & MODE_CMDLINE) == 0)\n\treturn NULL;\n    if (ccline.cmdbuff != NULL)\n\treturn &ccline;\n    if (prev_ccline_used && prev_ccline.cmdbuff != NULL)\n\treturn &prev_ccline;\n    return NULL;\n}\n\n/*\n * Get the current command-line type.\n * Returns ':' or '/' or '?' or '@' or '>' or '-'\n * Only works when the command line is being edited.\n * Returns NUL when something is wrong.\n */\n    static int\nget_cmdline_type(void)\n{\n    cmdline_info_T *p = get_ccline_ptr();\n\n    if (p == NULL)\n\treturn NUL;\n    if (p->cmdfirstc == NUL)\n\treturn\n# ifdef FEAT_EVAL\n\t    (p->input_fn) ? '@' :\n# endif\n\t    '-';\n    return p->cmdfirstc;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Get the current command line in allocated memory.\n * Only works when the command line is being edited.\n * Returns NULL when something is wrong.\n */\n    static char_u *\nget_cmdline_str(void)\n{\n    cmdline_info_T *p;\n\n    if (cmdline_star > 0)\n\treturn NULL;\n    p = get_ccline_ptr();\n    if (p == NULL)\n\treturn NULL;\n    return vim_strnsave(p->cmdbuff, p->cmdlen);\n}\n\n/*\n * Get the current command-line completion type.\n */\n    static char_u *\nget_cmdline_completion(void)\n{\n    cmdline_info_T *p;\n    char_u\t*buffer;\n\n    if (cmdline_star > 0)\n\treturn NULL;\n\n    p = get_ccline_ptr();\n    if (p == NULL || p->xpc == NULL)\n\treturn NULL;\n\n    set_expand_context(p->xpc);\n    if (p->xpc->xp_context == EXPAND_UNSUCCESSFUL)\n\treturn NULL;\n\n    char_u *cmd_compl = cmdcomplete_type_to_str(p->xpc->xp_context);\n    if (cmd_compl == NULL)\n\treturn NULL;\n\n    if (p->xpc->xp_context == EXPAND_USER_LIST || p->xpc->xp_context == EXPAND_USER_DEFINED)\n    {\n\tbuffer = alloc(STRLEN(cmd_compl) + STRLEN(p->xpc->xp_arg) + 2);\n\tif (buffer == NULL)\n\t    return NULL;\n\tsprintf((char *)buffer, \"%s,%s\", cmd_compl, p->xpc->xp_arg);\n\treturn buffer;\n    }\n\n    return vim_strsave(cmd_compl);\n}\n\n/*\n * \"getcmdcompltype()\" function\n */\n    void\nf_getcmdcompltype(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = get_cmdline_completion();\n}\n\n/*\n * \"getcmdline()\" function\n */\n    void\nf_getcmdline(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = get_cmdline_str();\n}\n\n/*\n * \"getcmdpos()\" function\n */\n    void\nf_getcmdpos(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    cmdline_info_T *p = get_ccline_ptr();\n\n    rettv->vval.v_number = p != NULL ? p->cmdpos + 1 : 0;\n}\n\n/*\n * \"getcmdscreenpos()\" function\n */\n    void\nf_getcmdscreenpos(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    cmdline_info_T *p = get_ccline_ptr();\n\n    rettv->vval.v_number = p != NULL ? p->cmdspos + 1 : 0;\n}\n\n/*\n * \"getcmdtype()\" function\n */\n    void\nf_getcmdtype(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = alloc(2);\n    if (rettv->vval.v_string == NULL)\n\treturn;\n\n    rettv->vval.v_string[0] = get_cmdline_type();\n    rettv->vval.v_string[1] = NUL;\n}\n\n// Set the command line str to \"str\".\n// Returns 1 when failed, 0 when OK.\n    static int\nset_cmdline_str(char_u *str, int pos)\n{\n    cmdline_info_T  *p = get_ccline_ptr();\n    int\t\t    len;\n\n    if (p == NULL)\n\treturn 1;\n\n    len = (int)STRLEN(str);\n    realloc_cmdbuff(len + 1);\n    p->cmdlen = len;\n    STRCPY(p->cmdbuff, str);\n\n    p->cmdpos = pos < 0 || pos > p->cmdlen ? p->cmdlen : pos;\n    new_cmdpos = p->cmdpos;\n\n    redrawcmd();\n\n    // Trigger CmdlineChanged autocommands.\n    trigger_cmd_autocmd(get_cmdline_type(), EVENT_CMDLINECHANGED);\n\n    return 0;\n}\n\n/*\n * Set the command line byte position to \"pos\".  Zero is the first position.\n * Only works when the command line is being edited.\n * Returns 1 when failed, 0 when OK.\n */\n    static int\nset_cmdline_pos(\n    int\t\tpos)\n{\n    cmdline_info_T *p = get_ccline_ptr();\n\n    if (p == NULL)\n\treturn 1;\n\n    // The position is not set directly but after CTRL-\\ e or CTRL-R = has\n    // changed the command line.\n    if (pos < 0)\n\tnew_cmdpos = 0;\n    else\n\tnew_cmdpos = pos;\n    return 0;\n}\n\n// \"setcmdline()\" function\n    void\nf_setcmdline(typval_T *argvars, typval_T *rettv)\n{\n    int pos = -1;\n\n    if (check_for_string_arg(argvars, 0) == FAIL\n\t    || check_for_opt_number_arg(argvars, 1) == FAIL)\n\treturn;\n\n    if (argvars[1].v_type != VAR_UNKNOWN)\n    {\n\tint error = FALSE;\n\n\tpos = (int)tv_get_number_chk(&argvars[1], &error) - 1;\n\tif (error)\n\t    return;\n\tif (pos < 0)\n\t{\n\t    emsg(_(e_argument_must_be_positive));\n\t    return;\n\t}\n    }\n\n    // Use tv_get_string() to handle a NULL string like an empty string.\n    rettv->vval.v_number = set_cmdline_str(tv_get_string(&argvars[0]), pos);\n}\n\n/*\n * \"setcmdpos()\" function\n */\n    void\nf_setcmdpos(typval_T *argvars, typval_T *rettv)\n{\n    int\t\tpos;\n\n    if (in_vim9script() && check_for_number_arg(argvars, 0) == FAIL)\n\treturn;\n\n    pos = (int)tv_get_number(&argvars[0]) - 1;\n    if (pos >= 0)\n\trettv->vval.v_number = set_cmdline_pos(pos);\n}\n#endif\n\n/*\n * Return the first character of the current command line.\n */\n    int\nget_cmdline_firstc(void)\n{\n    return ccline.cmdfirstc;\n}\n\n/*\n * Get indices \"num1,num2\" that specify a range within a list (not a range of\n * text lines in a buffer!) from a string.  Used for \":history\" and \":clist\".\n * Returns OK if parsed successfully, otherwise FAIL.\n */\n    int\nget_list_range(char_u **str, int *num1, int *num2)\n{\n    int\t\tlen;\n    int\t\tfirst = FALSE;\n    varnumber_T\tnum;\n\n    *str = skipwhite(*str);\n    if (**str == '-' || vim_isdigit(**str))  // parse \"from\" part of range\n    {\n\tvim_str2nr(*str, NULL, &len, 0, &num, NULL, 0, FALSE, NULL);\n\t*str += len;\n\t// overflow\n\tif (num > INT_MAX)\n\t    return FAIL;\n\n\t*num1 = (int)num;\n\tfirst = TRUE;\n    }\n    *str = skipwhite(*str);\n    if (**str == ',')\t\t\t// parse \"to\" part of range\n    {\n\t*str = skipwhite(*str + 1);\n\tvim_str2nr(*str, NULL, &len, 0, &num, NULL, 0, FALSE, NULL);\n\tif (len > 0)\n\t{\n\t    *str = skipwhite(*str + len);\n\t    // overflow\n\t    if (num > INT_MAX)\n\t\treturn FAIL;\n\n\t    *num2 = (int)num;\n\t}\n\telse if (!first)\t\t// no number given at all\n\t    return FAIL;\n    }\n    else if (first)\t\t\t// only one number given\n\t*num2 = *num1;\n    return OK;\n}\n\n/*\n * Check value of 'cedit' and set cedit_key.\n * Returns NULL if value is OK, error message otherwise.\n */\n    char *\ndid_set_cedit(optset_T *args UNUSED)\n{\n    int n;\n\n    if (*p_cedit == NUL)\n\tcedit_key = -1;\n    else\n    {\n\tn = string_to_key(p_cedit, FALSE);\n\tif (vim_isprintc(n))\n\t    return e_invalid_argument;\n\tcedit_key = n;\n    }\n    return NULL;\n}\n\n/*\n * Open a window on the current command line and history.  Allow editing in\n * the window.  Returns when the window is closed.\n * Returns:\n *\tCR\t if the command is to be executed\n *\tCtrl_C\t if it is to be abandoned\n *\tK_IGNORE if editing continues\n */\n    static int\nopen_cmdwin(void)\n{\n    bufref_T\t\told_curbuf;\n    win_T\t\t*old_curwin = curwin;\n    bufref_T\t\tbufref;\n    win_T\t\t*wp;\n    int\t\t\ti;\n    linenr_T\t\tlnum;\n    int\t\t\thisttype;\n    garray_T\t\twinsizes;\n    int\t\t\tsave_restart_edit = restart_edit;\n    int\t\t\tsave_State = State;\n    int\t\t\tsave_exmode = exmode_active;\n#ifdef FEAT_RIGHTLEFT\n    int\t\t\tsave_cmdmsg_rl = cmdmsg_rl;\n#endif\n#ifdef FEAT_FOLDING\n    int\t\t\tsave_KeyTyped;\n#endif\n\n    // Can't do this when text or buffer is locked.\n    // Can't do this recursively.  Can't do it when typing a password.\n    if (text_or_buf_locked()\n\t    || cmdwin_type != 0\n# if defined(FEAT_CRYPT) || defined(FEAT_EVAL)\n\t    || cmdline_star > 0\n# endif\n\t    )\n    {\n\tbeep_flush();\n\treturn K_IGNORE;\n    }\n    set_bufref(&old_curbuf, curbuf);\n\n    // Save current window sizes.\n    win_size_save(&winsizes);\n\n    // When using completion in Insert mode with <C-R>=<C-F> one can open the\n    // command line window, but we don't want the popup menu then.\n    pum_undisplay();\n\n    // don't use a new tab page\n    cmdmod.cmod_tab = 0;\n    cmdmod.cmod_flags |= CMOD_NOSWAPFILE;\n\n    // Create a window for the command-line buffer.\n    if (win_split((int)p_cwh, WSP_BOT) == FAIL)\n    {\n\tbeep_flush();\n\tga_clear(&winsizes);\n\treturn K_IGNORE;\n    }\n    // Don't let quitting the More prompt make this fail.\n    got_int = FALSE;\n\n    // Set \"cmdwin_type\" before any autocommands may mess things up.\n    cmdwin_type = get_cmdline_type();\n\n    // Create the command-line buffer empty.\n    if (do_ecmd(0, NULL, NULL, NULL, ECMD_ONE, ECMD_HIDE, NULL) == FAIL)\n    {\n\t// Some autocommand messed it up?\n\twin_close(curwin, TRUE);\n\tga_clear(&winsizes);\n\tcmdwin_type = 0;\n\treturn Ctrl_C;\n    }\n\n    apply_autocmds(EVENT_BUFFILEPRE, NULL, NULL, FALSE, curbuf);\n    (void)setfname(curbuf, (char_u *)_(\"[Command Line]\"), NULL, TRUE);\n    apply_autocmds(EVENT_BUFFILEPOST, NULL, NULL, FALSE, curbuf);\n    set_option_value_give_err((char_u *)\"bt\",\n\t\t\t\t\t    0L, (char_u *)\"nofile\", OPT_LOCAL);\n    curbuf->b_p_ma = TRUE;\n#ifdef FEAT_FOLDING\n    curwin->w_p_fen = FALSE;\n#endif\n# ifdef FEAT_RIGHTLEFT\n    curwin->w_p_rl = cmdmsg_rl;\n    cmdmsg_rl = FALSE;\n# endif\n    RESET_BINDING(curwin);\n\n    // Don't allow switching to another buffer.\n    ++curbuf_lock;\n\n    // Showing the prompt may have set need_wait_return, reset it.\n    need_wait_return = FALSE;\n\n    histtype = hist_char2type(cmdwin_type);\n    if (histtype == HIST_CMD || histtype == HIST_DEBUG)\n    {\n\tif (p_wc == TAB)\n\t{\n\t    // Make Tab start command-line completion: CTRL-X CTRL-V\n\t    add_map((char_u *)\"<buffer> <Tab> <C-X><C-V>\", MODE_INSERT, TRUE);\n\t    add_map((char_u *)\"<buffer> <Tab> a<C-X><C-V>\", MODE_NORMAL, TRUE);\n\n\t    // Make S-Tab work like CTRL-P in command-line completion\n\t    add_map((char_u *)\"<buffer> <S-Tab> <C-P>\", MODE_INSERT, TRUE);\n\t}\n\tset_option_value_give_err((char_u *)\"ft\",\n\t\t\t\t\t       0L, (char_u *)\"vim\", OPT_LOCAL);\n    }\n    --curbuf_lock;\n\n    // Reset 'textwidth' after setting 'filetype' (the Vim filetype plugin\n    // sets 'textwidth' to 78).\n    curbuf->b_p_tw = 0;\n\n    // Fill the buffer with the history.\n    init_history();\n    if (get_hislen() > 0)\n    {\n\ti = *get_hisidx(histtype);\n\tif (i >= 0)\n\t{\n\t    lnum = 0;\n\t    do\n\t    {\n\t\tif (++i == get_hislen())\n\t\t    i = 0;\n\t\tif (get_histentry(histtype)[i].hisstr != NULL)\n\t\t    ml_append(lnum++, get_histentry(histtype)[i].hisstr,\n\t\t\t\t\t\t\t   (colnr_T)0, FALSE);\n\t    }\n\t    while (i != *get_hisidx(histtype));\n\t}\n    }\n\n    // Replace the empty last line with the current command-line and put the\n    // cursor there.\n    ml_replace(curbuf->b_ml.ml_line_count, ccline.cmdbuff, TRUE);\n    curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n    curwin->w_cursor.col = ccline.cmdpos;\n    changed_line_abv_curs();\n    invalidate_botline();\n    redraw_later(UPD_SOME_VALID);\n\n    // No Ex mode here!\n    exmode_active = 0;\n\n    State = MODE_NORMAL;\n    setmouse();\n\n    // Reset here so it can be set by a CmdWinEnter autocommand.\n    cmdwin_result = 0;\n\n    // Trigger CmdwinEnter autocommands.\n    trigger_cmd_autocmd(cmdwin_type, EVENT_CMDWINENTER);\n    if (restart_edit != 0)\t// autocmd with \":startinsert\"\n\tstuffcharReadbuff(K_NOP);\n\n    int save_RedrawingDisabled = RedrawingDisabled;\n    RedrawingDisabled = 0;\n\n    /*\n     * Call the main loop until <CR> or CTRL-C is typed.\n     */\n    main_loop(TRUE, FALSE);\n\n    RedrawingDisabled = save_RedrawingDisabled;\n\n# ifdef FEAT_FOLDING\n    save_KeyTyped = KeyTyped;\n# endif\n\n    // Trigger CmdwinLeave autocommands.\n    trigger_cmd_autocmd(cmdwin_type, EVENT_CMDWINLEAVE);\n\n# ifdef FEAT_FOLDING\n    // Restore KeyTyped in case it is modified by autocommands\n    KeyTyped = save_KeyTyped;\n# endif\n\n    cmdwin_type = 0;\n    exmode_active = save_exmode;\n\n    // Safety check: The old window or buffer was deleted: It's a bug when\n    // this happens!\n    if (!win_valid(old_curwin) || !bufref_valid(&old_curbuf))\n    {\n\tcmdwin_result = Ctrl_C;\n\temsg(_(e_active_window_or_buffer_deleted));\n    }\n    else\n    {\n# if defined(FEAT_EVAL)\n\t// autocmds may abort script processing\n\tif (aborting() && cmdwin_result != K_IGNORE)\n\t    cmdwin_result = Ctrl_C;\n# endif\n\t// Set the new command line from the cmdline buffer.\n\tvim_free(ccline.cmdbuff);\n\tif (cmdwin_result == K_XF1 || cmdwin_result == K_XF2) // :qa[!] typed\n\t{\n\t    char *p = (cmdwin_result == K_XF2) ? \"qa\" : \"qa!\";\n\n\t    if (histtype == HIST_CMD)\n\t    {\n\t\t// Execute the command directly.\n\t\tccline.cmdbuff = vim_strsave((char_u *)p);\n\t\tcmdwin_result = CAR;\n\t    }\n\t    else\n\t    {\n\t\t// First need to cancel what we were doing.\n\t\tccline.cmdbuff = NULL;\n\t\tstuffcharReadbuff(':');\n\t\tstuffReadbuff((char_u *)p);\n\t\tstuffcharReadbuff(CAR);\n\t    }\n\t}\n\telse if (cmdwin_result == Ctrl_C)\n\t{\n\t    // :q or :close, don't execute any command\n\t    // and don't modify the cmd window.\n\t    ccline.cmdbuff = NULL;\n\t}\n\telse\n\t    ccline.cmdbuff = vim_strsave(ml_get_curline());\n\tif (ccline.cmdbuff == NULL)\n\t{\n\t    ccline.cmdbuff = vim_strsave((char_u *)\"\");\n\t    ccline.cmdlen = 0;\n\t    ccline.cmdbufflen = 1;\n\t    ccline.cmdpos = 0;\n\t    cmdwin_result = Ctrl_C;\n\t}\n\telse\n\t{\n\t    ccline.cmdlen = (int)STRLEN(ccline.cmdbuff);\n\t    ccline.cmdbufflen = ccline.cmdlen + 1;\n\t    ccline.cmdpos = curwin->w_cursor.col;\n\t    // If the cursor is on the last character, it probably should be\n\t    // after it.\n\t    if (ccline.cmdpos == ccline.cmdlen - 1\n\t\t    || ccline.cmdpos > ccline.cmdlen)\n\t\tccline.cmdpos = ccline.cmdlen;\n\t}\n\n# ifdef FEAT_CONCEAL\n\t// Avoid command-line window first character being concealed.\n\tcurwin->w_p_cole = 0;\n# endif\n\t// First go back to the original window.\n\twp = curwin;\n\tset_bufref(&bufref, curbuf);\n\n\tskip_win_fix_cursor = TRUE;\n\twin_goto(old_curwin);\n\n\t// win_goto() may trigger an autocommand that already closes the\n\t// cmdline window.\n\tif (win_valid(wp) && wp != curwin)\n\t    win_close(wp, TRUE);\n\n\t// win_close() may have already wiped the buffer when 'bh' is\n\t// set to 'wipe', autocommands may have closed other windows\n\tif (bufref_valid(&bufref) && bufref.br_buf != curbuf)\n\t    close_buffer(NULL, bufref.br_buf, DOBUF_WIPE, FALSE, FALSE);\n\n\t// Restore window sizes.\n\twin_size_restore(&winsizes);\n\tskip_win_fix_cursor = FALSE;\n\n\tif (cmdwin_result == K_IGNORE)\n\t{\n\t    // It can be confusing that the cmdwin still shows, redraw the\n\t    // screen.\n\t    update_screen(UPD_VALID);\n\t    set_cmdspos_cursor();\n\t    redrawcmd();\n\t}\n    }\n\n    ga_clear(&winsizes);\n    restart_edit = save_restart_edit;\n# ifdef FEAT_RIGHTLEFT\n    cmdmsg_rl = save_cmdmsg_rl;\n# endif\n\n    State = save_State;\n    may_trigger_modechanged();\n    setmouse();\n\n    return cmdwin_result;\n}\n\n/*\n * Return TRUE if in the cmdwin, not editing the command line.\n */\n    int\nis_in_cmdwin(void)\n{\n    return cmdwin_type != 0 && get_cmdline_type() == NUL;\n}\n\n/*\n * Used for commands that either take a simple command string argument, or:\n *\tcmd << endmarker\n *\t  {script}\n *\tendmarker\n * Returns a pointer to allocated memory with {script} or NULL.\n */\n    char_u *\nscript_get(exarg_T *eap UNUSED, char_u *cmd UNUSED)\n{\n#ifdef FEAT_EVAL\n    list_T\t*l;\n    listitem_T\t*li;\n    char_u\t*s;\n    garray_T\tga;\n\n    if (cmd[0] != '<' || cmd[1] != '<' || eap->getline == NULL)\n\treturn NULL;\n    cmd += 2;\n\n    l = heredoc_get(eap, cmd, TRUE, FALSE);\n    if (l == NULL)\n\treturn NULL;\n\n    ga_init2(&ga, 1, 0x400);\n\n    FOR_ALL_LIST_ITEMS(l, li)\n    {\n\ts = tv_get_string(&li->li_tv);\n\tga_concat(&ga, s);\n\tga_append(&ga, '\\n');\n    }\n    ga_append(&ga, NUL);\n\n    list_free(l);\n    return (char_u *)ga.ga_data;\n#else\n    return NULL;\n#endif\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * This function is used by f_input() and f_inputdialog() functions. The third\n * argument to f_input() specifies the type of completion to use at the\n * prompt. The third argument to f_inputdialog() specifies the value to return\n * when the user cancels the prompt.\n */\n    void\nget_user_input(\n    typval_T\t*argvars,\n    typval_T\t*rettv,\n    int\t\tinputdialog,\n    int\t\tsecret)\n{\n    char_u\t*prompt;\n    char_u\t*p = NULL;\n    int\t\tc;\n    char_u\tbuf[NUMBUFLEN];\n    int\t\tcmd_silent_save = cmd_silent;\n    char_u\t*defstr = (char_u *)\"\";\n    int\t\txp_type = EXPAND_NOTHING;\n    char_u\t*xp_arg = NULL;\n\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = NULL;\n    if (input_busy)\n\treturn;  // this doesn't work recursively.\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_opt_string_arg(argvars, 1) == FAIL\n\t\t|| (argvars[1].v_type != VAR_UNKNOWN\n\t\t    && check_for_opt_string_arg(argvars, 2) == FAIL)))\n\treturn;\n\n    prompt = tv_get_string_chk(&argvars[0]);\n\n#ifdef NO_CONSOLE_INPUT\n    // While starting up, there is no place to enter text. When running tests\n    // with --not-a-term we assume feedkeys() will be used.\n    if (no_console_input() && !is_not_a_term())\n\treturn;\n#endif\n\n    cmd_silent = FALSE;\t\t// Want to see the prompt.\n    if (prompt != NULL)\n    {\n\t// Only the part of the message after the last NL is considered as\n\t// prompt for the command line\n\tp = vim_strrchr(prompt, '\\n');\n\tif (p == NULL)\n\t    p = prompt;\n\telse\n\t{\n\t    ++p;\n\t    c = *p;\n\t    *p = NUL;\n\t    msg_start();\n\t    msg_clr_eos();\n\t    msg_puts_attr((char *)prompt, get_echo_attr());\n\t    msg_didout = FALSE;\n\t    msg_starthere();\n\t    *p = c;\n\t}\n\tcmdline_row = msg_row;\n\n\tif (argvars[1].v_type != VAR_UNKNOWN)\n\t{\n\t    defstr = tv_get_string_buf_chk(&argvars[1], buf);\n\t    if (defstr != NULL)\n\t\tstuffReadbuffSpec(defstr);\n\n\t    if (!inputdialog && argvars[2].v_type != VAR_UNKNOWN)\n\t    {\n\t\tchar_u\t*xp_name;\n\t\tint\txp_namelen;\n\t\tlong\targt = 0;\n\n\t\t// input() with a third argument: completion\n\t\trettv->vval.v_string = NULL;\n\n\t\txp_name = tv_get_string_buf_chk(&argvars[2], buf);\n\t\tif (xp_name == NULL)\n\t\t    return;\n\n\t\txp_namelen = (int)STRLEN(xp_name);\n\n\t\tif (parse_compl_arg(xp_name, xp_namelen, &xp_type, &argt,\n\t\t\t\t\t\t\t     &xp_arg) == FAIL)\n\t\t    return;\n\t    }\n\t}\n\n\tif (defstr != NULL)\n\t{\n\t    int save_ex_normal_busy = ex_normal_busy;\n\t    int save_vgetc_busy = vgetc_busy;\n\t    int save_input_busy = input_busy;\n\n\t    input_busy |= vgetc_busy;\n\t    ex_normal_busy = 0;\n\t    vgetc_busy = 0;\n\t    rettv->vval.v_string =\n\t\tgetcmdline_prompt(secret ? NUL : '@', p, get_echo_attr(),\n\t\t\t\t\t\t\t      xp_type, xp_arg);\n\t    ex_normal_busy = save_ex_normal_busy;\n\t    vgetc_busy = save_vgetc_busy;\n\t    input_busy = save_input_busy;\n\t}\n\tif (inputdialog && rettv->vval.v_string == NULL\n\t\t&& argvars[1].v_type != VAR_UNKNOWN\n\t\t&& argvars[2].v_type != VAR_UNKNOWN)\n\t    rettv->vval.v_string = vim_strsave(tv_get_string_buf(\n\t\t\t\t\t\t\t   &argvars[2], buf));\n\n\tvim_free(xp_arg);\n\n\t// since the user typed this, no need to wait for return\n\tneed_wait_return = FALSE;\n\tmsg_didout = FALSE;\n    }\n    cmd_silent = cmd_silent_save;\n}\n#endif\n", "\" Tests for the history functions\n\nsource check.vim\nCheckFeature cmdline_hist\n\nset history=7\n\nfunction History_Tests(hist)\n  \" First clear the history\n  call histadd(a:hist, 'dummy')\n  call assert_true(histdel(a:hist))\n  call assert_equal(-1, histnr(a:hist))\n  call assert_equal('', histget(a:hist))\n\n  call assert_true('ls'->histadd(a:hist))\n  call assert_true(histadd(a:hist, 'buffers'))\n  call assert_equal('buffers', histget(a:hist))\n  call assert_equal('ls', histget(a:hist, -2))\n  call assert_equal('ls', histget(a:hist, 1))\n  call assert_equal('', histget(a:hist, 5))\n  call assert_equal('', histget(a:hist, -5))\n  call assert_equal(2, histnr(a:hist))\n  call assert_true(histdel(a:hist, 2))\n  call assert_false(a:hist->histdel(7))\n  call assert_equal(1, histnr(a:hist))\n  call assert_equal('ls', histget(a:hist, -1))\n\n  call assert_true(histadd(a:hist, 'buffers'))\n  call assert_true(histadd(a:hist, 'ls'))\n  call assert_equal('ls', a:hist->histget(-1))\n  call assert_equal(4, a:hist->histnr())\n\n  let a=execute('history ' . a:hist)\n  call assert_match(\"^\\n      #  \\\\S* history\\n      3  buffers\\n>     4  ls$\", a)\n  let a=execute('history all')\n  call assert_match(\"^\\n      #  .* history\\n      3  buffers\\n>     4  ls\", a)\n\n  if len(a:hist) > 0\n    let a=execute('history ' . a:hist . ' 2')\n    call assert_match(\"^\\n      #  \\\\S* history$\", a)\n    let a=execute('history ' . a:hist . ' 3')\n    call assert_match(\"^\\n      #  \\\\S* history\\n      3  buffers$\", a)\n    let a=execute('history ' . a:hist . ' 4')\n    call assert_match(\"^\\n      #  \\\\S* history\\n>     4  ls$\", a)\n    let a=execute('history ' . a:hist . ' 3,4')\n    call assert_match(\"^\\n      #  \\\\S* history\\n      3  buffers\\n>     4  ls$\", a)\n    let a=execute('history ' . a:hist . ' -1')\n    call assert_match(\"^\\n      #  \\\\S* history\\n>     4  ls$\", a)\n    let a=execute('history ' . a:hist . ' -2')\n    call assert_match(\"^\\n      #  \\\\S* history\\n      3  buffers$\", a)\n    let a=execute('history ' . a:hist . ' -2,')\n    call assert_match(\"^\\n      #  \\\\S* history\\n      3  buffers\\n>     4  ls$\", a)\n    let a=execute('history ' . a:hist . ' -3')\n    call assert_match(\"^\\n      #  \\\\S* history$\", a)\n  endif\n\n  \" Test for removing entries matching a pattern\n  for i in range(1, 3)\n      call histadd(a:hist, 'text_' . i)\n  endfor\n  call assert_true(histdel(a:hist, 'text_\\d\\+'))\n  call assert_equal('ls', histget(a:hist, -1))\n\n  \" Test for freeing the entire history list\n  for i in range(1, 7)\n      call histadd(a:hist, 'text_' . i)\n  endfor\n  call histdel(a:hist)\n  for i in range(1, 7)\n    call assert_equal('', histget(a:hist, i))\n    call assert_equal('', histget(a:hist, i - 7 - 1))\n  endfor\n\n  \" Test for freeing an entry at the beginning of the history list\n  for i in range(1, 4)\n      call histadd(a:hist, 'text_' . i)\n  endfor\n  call histdel(a:hist, 1)\n  call assert_equal('', histget(a:hist, 1))\n  call assert_equal('text_4', histget(a:hist, 4))\nendfunction\n\nfunction Test_History()\n  for h in ['cmd', ':', '', 'search', '/', '?', 'expr', '=', 'input', '@', 'debug', '>']\n    call History_Tests(h)\n  endfor\n\n  \" Negative tests\n  call assert_false(histdel('abc'))\n  call assert_equal('', histget('abc'))\n  call assert_fails('call histdel([])', 'E730:')\n  call assert_equal('', histget(10))\n  call assert_fails('call histget([])', 'E730:')\n  call assert_equal(-1, histnr('abc'))\n  call assert_fails('call histnr([])', 'E730:')\n  call assert_fails('history xyz', 'E488:')\n  call assert_fails('history ,abc', 'E488:')\n  call assert_fails('call histdel(\":\", \"\\\\%(\")', 'E53:')\nendfunction\n\nfunction Test_history_truncates_long_entry()\n  \" History entry short enough to fit on the screen should not be truncated.\n  call histadd(':', 'echo x' .. repeat('y', &columns - 17) .. 'z')\n  let a = execute('history : -1')\n\n  call assert_match(\"^\\n      #  cmd history\\n\"\n        \\        .. \"> *\\\\d\\\\+  echo x\" .. repeat('y', &columns - 17) ..  'z$', a)\n\n  \" Long history entry should be truncated to fit on the screen, with, '...'\n  \" inserted in the string to indicate the that there is truncation.\n  call histadd(':', 'echo x' .. repeat('y', &columns - 16) .. 'z')\n  let a = execute('history : -1')\n  call assert_match(\"^\\n      #  cmd history\\n\"\n        \\        .. \">  *\\\\d\\\\+  echo xy\\\\+\\.\\.\\.y\\\\+z$\", a)\nendfunction\n\nfunction Test_Search_history_window()\n  new\n  call setline(1, ['a', 'b', 'a', 'b'])\n  1\n  call feedkeys(\"/a\\<CR>\", 'xt')\n  call assert_equal('a', getline('.'))\n  1\n  call feedkeys(\"/b\\<CR>\", 'xt')\n  call assert_equal('b', getline('.'))\n  1\n  \" select the previous /a command\n  call feedkeys(\"q/kk\\<CR>\", 'x!')\n  call assert_equal('a', getline('.'))\n  call assert_equal('a', @/)\n  bwipe!\nendfunc\n\n\" Test for :history command option completion\nfunction Test_history_completion()\n  call feedkeys(\":history \\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"history / : = > ? @ all cmd debug expr input search', @:)\nendfunc\n\n\" Test for increasing the 'history' option value\nfunc Test_history_size()\n  let save_histsz = &history\n  set history=10\n  call histadd(':', 'ls')\n  call histdel(':')\n  for i in range(1, 5)\n    call histadd(':', 'cmd' .. i)\n  endfor\n  call assert_equal(5, histnr(':'))\n  call assert_equal('cmd5', histget(':', -1))\n\n  set history=15\n  for i in range(6, 10)\n    call histadd(':', 'cmd' .. i)\n  endfor\n  call assert_equal(10, histnr(':'))\n  call assert_equal('cmd1', histget(':', 1))\n  call assert_equal('cmd10', histget(':', -1))\n\n  set history=5\n  call histadd(':', 'abc')\n  call assert_equal('', histget(':', 6))\n  call assert_equal('', histget(':', 12))\n  call assert_equal('cmd7', histget(':', 7))\n  call assert_equal('abc', histget(':', -1))\n\n  \" This test works only when the language is English\n  if v:lang == \"C\" || v:lang =~ '^[Ee]n'\n    set history=0\n    redir => v\n    call feedkeys(\":history\\<CR>\", 'xt')\n    redir END\n    call assert_equal([\"'history' option is zero\"], split(v, \"\\n\"))\n  endif\n\n  let &history=save_histsz\nendfunc\n\n\" Test for recalling old search patterns in /\nfunc Test_history_search()\n  call histdel('/')\n  let g:pat = []\n  func SavePat()\n    call add(g:pat, getcmdline())\n    return ''\n  endfunc\n  cnoremap <F2> <C-\\>eSavePat()<CR>\n  call histadd('/', 'pat1')\n  call histadd('/', 'pat2')\n  let @/ = ''\n  call feedkeys(\"/\\<Up>\\<F2>\\<Up>\\<F2>\\<Down>\\<Down>\\<F2>\\<Esc>\", 'xt')\n  call assert_equal(['pat2', 'pat1', ''], g:pat)\n  cunmap <F2>\n  delfunc SavePat\n\n  \" Search for a pattern that is not present in the history\n  call assert_beeps('call feedkeys(\"/a1b2\\<Up>\\<CR>\", \"xt\")')\n\n  \" Recall patterns with 'history' set to 0\n  set history=0\n  let @/ = 'abc'\n  let cmd = 'call feedkeys(\"/\\<Up>\\<Down>\\<S-Up>\\<S-Down>\\<CR>\", \"xt\")'\n  call assert_fails(cmd, 'E486:')\n  set history&\n\n  \" Recall patterns till the end of history\n  set history=4\n  call histadd('/', 'pat')\n  call histdel('/')\n  call histadd('/', 'pat1')\n  call histadd('/', 'pat2')\n  call assert_beeps('call feedkeys(\"/\\<Up>\\<Up>\\<Up>\\<C-U>\\<cr>\", \"xt\")')\n  call assert_beeps('call feedkeys(\"/\\<Down><cr>\", \"xt\")')\n\n  \" Test for wrapping around the history list\n  for i in range(3, 7)\n    call histadd('/', 'pat' .. i)\n  endfor\n  let upcmd = \"\\<up>\\<up>\\<up>\\<up>\\<up>\"\n  let downcmd = \"\\<down>\\<down>\\<down>\\<down>\\<down>\"\n  try\n    call feedkeys(\"/\" .. upcmd .. \"\\<cr>\", 'xt')\n  catch /E486:/\n  endtry\n  call assert_equal('pat4', @/)\n  try\n    call feedkeys(\"/\" .. upcmd .. downcmd .. \"\\<cr>\", 'xt')\n  catch /E486:/\n  endtry\n  call assert_equal('pat4', @/)\n\n  \" Test for changing the search command separator in the history\n  call assert_fails('call feedkeys(\"/def/\\<cr>\", \"xt\")', 'E486:')\n  call assert_fails('call feedkeys(\"?\\<up>\\<cr>\", \"xt\")', 'E486:')\n  call assert_equal('def?', histget('/', -1))\n\n  call assert_fails('call feedkeys(\"/ghi?\\<cr>\", \"xt\")', 'E486:')\n  call assert_fails('call feedkeys(\"?\\<up>\\<cr>\", \"xt\")', 'E486:')\n  call assert_equal('ghi\\?', histget('/', -1))\n\n  set history&\nendfunc\n\n\" Test for making sure the key value is not stored in history\nfunc Test_history_crypt_key()\n  CheckFeature cryptv\n\n  call feedkeys(\":set bs=2 key=abc ts=8\\<CR>\", 'xt')\n  call assert_equal('set bs=2 key= ts=8', histget(':'))\n\n  call assert_fails(\"call feedkeys(':set bs=2 key-=abc ts=8\\<CR>', 'xt')\")\n  call assert_equal('set bs=2 key-= ts=8', histget(':'))\n\n  set key& bs& ts&\nendfunc\n\n\" The following used to overflow and causing an use-after-free\nfunc Test_history_max_val()\n\n  set history=10\n  call assert_fails(':history 2147483648', 'E1510:')\n  set history&\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion != NULL)\n\treturn;\n\n#ifdef BUILD_DATE\n    char *date_time = BUILD_DATE;\n#else\n    char *date_time = __DATE__ \" \" __TIME__;\n#endif\n    char *msg = _(\"%s (%s, compiled %s)\");\n    size_t len = strlen(msg)\n\t+ strlen(VIM_VERSION_LONG_ONLY)\n\t+ strlen(VIM_VERSION_DATE_ONLY)\n\t+ strlen(date_time);\n\n    longVersion = alloc(len);\n    if (longVersion == NULL)\n\tlongVersion = VIM_VERSION_LONG;\n    else\n\tvim_snprintf(longVersion, len, msg,\n\t\tVIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n\t\"++builtin_terms\",\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n\t\"+cmdline_info\",\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n\t\"+file_in_path\",\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n\t\"+float\",\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n\t\"-footer\",\n\t// only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n\t\"+path_extra\",\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n#  ifdef DYNAMIC_PYTHON3_STABLE_ABI\n\t\"+python3/dyn-stable\",\n#  else\n\t\"+python3/dyn\",\n#  endif\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n\t\"+wildignore\",\n\t\"+wildmenu\",\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n# ifdef FEAT_XATTR\n\t\"+xattr\",\n# else\n\t\"-xattr\",\n# endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "filenames": ["src/cmdhist.c", "src/errors.h", "src/ex_getln.c", "src/testdir/test_history.vim", "src/version.c"], "buggy_code_start_loc": [745, 3562, 4379, 256, 706], "buggy_code_end_loc": [746, 3562, 4392, 256, 706], "fixing_code_start_loc": [745, 3563, 4380, 257, 707], "fixing_code_end_loc": [749, 3565, 4399, 265, 709], "type": "CWE-190", "message": "Vim is an improved version of the good old UNIX editor Vi. Heap-use-after-free in memory allocated in the function `ga_grow_inner` in in the file `src/alloc.c` at line 748, which is freed in the file `src/ex_docmd.c` in the function `do_cmdline` at line 1010 and then used again in `src/cmdhist.c` at line 759. When using the `:history` command, it's possible that the provided argument overflows the accepted value. Causing an Integer Overflow and potentially later an use-after-free. This vulnerability has been patched in version 9.0.2068.\n", "other": {"cve": {"id": "CVE-2023-46246", "sourceIdentifier": "security-advisories@github.com", "published": "2023-10-27T19:15:41.417", "lastModified": "2023-12-17T03:15:07.530", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Vim is an improved version of the good old UNIX editor Vi. Heap-use-after-free in memory allocated in the function `ga_grow_inner` in in the file `src/alloc.c` at line 748, which is freed in the file `src/ex_docmd.c` in the function `do_cmdline` at line 1010 and then used again in `src/cmdhist.c` at line 759. When using the `:history` command, it's possible that the provided argument overflows the accepted value. Causing an Integer Overflow and potentially later an use-after-free. This vulnerability has been patched in version 9.0.2068.\n"}, {"lang": "es", "value": "Vim es una versi\u00f3n mejorada del antiguo editor de UNIX Vi. Heap-use-after-free en la memoria asignada en la funci\u00f3n `ga_grow_inner` en el archivo `src/alloc.c` en la l\u00ednea 748, que se libera en el archivo `src/ex_docmd.c` en la funci\u00f3n `do_cmdline` en la l\u00ednea 1010 y luego se usa nuevamente en `src/cmdhist.c` en la l\u00ednea 759. Cuando se usa el comando `:history`, es posible que el argumento proporcionado desborde el valor aceptado. Provocando un desbordamiento de enteros y potencialmente m\u00e1s tarde un use-after-free. Esta vulnerabilidad ha sido parcheada en la versi\u00f3n 9.0.2068."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 4.0, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.5, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}, {"lang": "en", "value": "CWE-416"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-190"}, {"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.0.2068", "matchCriteriaId": "C9577B78-DCA1-4A14-897A-6AB4B07A0D35"}]}]}], "references": [{"url": "https://github.com/vim/vim/commit/9198c1f2b1ddecde22af918541e0de2a32f0f45a", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/vim/vim/security/advisories/GHSA-q22m-h7m2-9mgm", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/DNMFS3IH74KEMMESOA3EOB6MZ56TWGFF/", "source": "security-advisories@github.com"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/IVA7K73WHQH4KVFDJQ7ELIUD2WK5ZT5E/", "source": "security-advisories@github.com"}, {"url": "https://security.netapp.com/advisory/ntap-20231208-0006/", "source": "security-advisories@github.com"}]}, "github_commit_url": "https://github.com/vim/vim/commit/9198c1f2b1ddecde22af918541e0de2a32f0f45a"}}