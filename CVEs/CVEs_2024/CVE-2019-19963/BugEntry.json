{"buggy_code": ["/* dsa.c\n *\n * Copyright (C) 2006-2019 wolfSSL Inc.\n *\n * This file is part of wolfSSL.\n *\n * wolfSSL is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * wolfSSL is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335, USA\n */\n\n\n#ifdef HAVE_CONFIG_H\n    #include <config.h>\n#endif\n\n#include <wolfssl/wolfcrypt/settings.h>\n\n#ifndef NO_DSA\n\n#include <wolfssl/wolfcrypt/random.h>\n#include <wolfssl/wolfcrypt/integer.h>\n#include <wolfssl/wolfcrypt/error-crypt.h>\n#include <wolfssl/wolfcrypt/logging.h>\n#include <wolfssl/wolfcrypt/sha.h>\n#include <wolfssl/wolfcrypt/dsa.h>\n\n#ifdef NO_INLINE\n    #include <wolfssl/wolfcrypt/misc.h>\n#else\n    #define WOLFSSL_MISC_INCLUDED\n    #include <wolfcrypt/src/misc.c>\n#endif\n\n\nenum {\n    DSA_HALF_SIZE = 20,   /* r and s size  */\n    DSA_SIG_SIZE  = 40    /* signature size */\n};\n\n\n\nint wc_InitDsaKey(DsaKey* key)\n{\n    if (key == NULL)\n        return BAD_FUNC_ARG;\n\n    key->type = -1;  /* haven't decided yet */\n    key->heap = NULL;\n\n    return mp_init_multi(\n        /* public  alloc parts */\n        &key->p,\n        &key->q,\n        &key->g,\n        &key->y,\n\n        /* private alloc parts */\n        &key->x,\n        NULL\n    );\n}\n\n\nint wc_InitDsaKey_h(DsaKey* key, void* h)\n{\n    int ret = wc_InitDsaKey(key);\n    if (ret == 0)\n        key->heap = h;\n\n    return ret;\n}\n\n\nvoid wc_FreeDsaKey(DsaKey* key)\n{\n    if (key == NULL)\n        return;\n\n    if (key->type == DSA_PRIVATE)\n        mp_forcezero(&key->x);\n\n    mp_clear(&key->x);\n    mp_clear(&key->y);\n    mp_clear(&key->g);\n    mp_clear(&key->q);\n    mp_clear(&key->p);\n}\n\n\n/* validate that (L,N) match allowed sizes from FIPS 186-4, Section 4.2.\n * modLen - represents L, the size of p (prime modulus) in bits\n * divLen - represents N, the size of q (prime divisor) in bits\n * return 0 on success, -1 on error */\nstatic int CheckDsaLN(int modLen, int divLen)\n{\n    int ret = -1;\n\n    switch (modLen) {\n        case 1024:\n            if (divLen == 160)\n                ret = 0;\n            break;\n        case 2048:\n            if (divLen == 224 || divLen == 256)\n                ret = 0;\n            break;\n        case 3072:\n            if (divLen == 256)\n                ret = 0;\n            break;\n        default:\n            break;\n    }\n\n    return ret;\n}\n\n\n#ifdef WOLFSSL_KEY_GEN\n\n/* Create DSA key pair (&dsa->x, &dsa->y)\n *\n * Based on NIST FIPS 186-4,\n * \"B.1.1 Key Pair Generation Using Extra Random Bits\"\n *\n * rng - pointer to initialized WC_RNG structure\n * dsa - pointer to initialized DsaKey structure, will hold generated key\n *\n * return 0 on success, negative on error */\nint wc_MakeDsaKey(WC_RNG *rng, DsaKey *dsa)\n{\n    byte* cBuf;\n    int qSz, pSz, cSz, err;\n    mp_int tmpQ;\n\n    if (rng == NULL || dsa == NULL)\n        return BAD_FUNC_ARG;\n\n    qSz = mp_unsigned_bin_size(&dsa->q);\n    pSz = mp_unsigned_bin_size(&dsa->p);\n\n    /* verify (L,N) pair bit lengths */\n    if (CheckDsaLN(pSz * WOLFSSL_BIT_SIZE, qSz * WOLFSSL_BIT_SIZE) != 0)\n        return BAD_FUNC_ARG;\n\n    /* generate extra 64 bits so that bias from mod function is negligible */\n    cSz = qSz + (64 / WOLFSSL_BIT_SIZE);\n    cBuf = (byte*)XMALLOC(cSz, dsa->heap, DYNAMIC_TYPE_TMP_BUFFER);\n    if (cBuf == NULL) {\n        return MEMORY_E;\n    }\n\n    if ((err = mp_init_multi(&dsa->x, &dsa->y, &tmpQ, NULL, NULL, NULL))\n                   != MP_OKAY) {\n        XFREE(cBuf, dsa->heap, DYNAMIC_TYPE_TMP_BUFFER);\n        return err;\n    }\n\n    do {\n        /* generate N+64 bits (c) from RBG into &dsa->x, making sure positive.\n         * Hash_DRBG uses SHA-256 which matches maximum\n         * requested_security_strength of (L,N) */\n        err = wc_RNG_GenerateBlock(rng, cBuf, cSz);\n        if (err != MP_OKAY) {\n            mp_clear(&dsa->x);\n            mp_clear(&dsa->y);\n            mp_clear(&tmpQ);\n            XFREE(cBuf, dsa->heap, DYNAMIC_TYPE_TMP_BUFFER);\n            return err;\n        }\n\n        err = mp_read_unsigned_bin(&dsa->x, cBuf, cSz);\n        if (err != MP_OKAY) {\n            mp_clear(&dsa->x);\n            mp_clear(&dsa->y);\n            mp_clear(&tmpQ);\n            XFREE(cBuf, dsa->heap, DYNAMIC_TYPE_TMP_BUFFER);\n            return err;\n        }\n    } while (mp_cmp_d(&dsa->x, 1) != MP_GT);\n\n    XFREE(cBuf, dsa->heap, DYNAMIC_TYPE_TMP_BUFFER);\n\n    /* tmpQ = q - 1 */\n    if (err == MP_OKAY)\n        err = mp_copy(&dsa->q, &tmpQ);\n\n    if (err == MP_OKAY)\n        err = mp_sub_d(&tmpQ, 1, &tmpQ);\n\n    /* x = c mod (q-1), &dsa->x holds c */\n    if (err == MP_OKAY)\n        err = mp_mod(&dsa->x, &tmpQ, &dsa->x);\n\n    /* x = c mod (q-1) + 1 */\n    if (err == MP_OKAY)\n        err = mp_add_d(&dsa->x, 1, &dsa->x);\n\n    /* public key : y = g^x mod p */\n    if (err == MP_OKAY)\n        err = mp_exptmod_ex(&dsa->g, &dsa->x, dsa->q.used, &dsa->p, &dsa->y);\n\n    if (err == MP_OKAY)\n        dsa->type = DSA_PRIVATE;\n\n    if (err != MP_OKAY) {\n        mp_clear(&dsa->x);\n        mp_clear(&dsa->y);\n    }\n    mp_clear(&tmpQ);\n\n    return err;\n}\n\n\n/* modulus_size in bits */\nint wc_MakeDsaParameters(WC_RNG *rng, int modulus_size, DsaKey *dsa)\n{\n    mp_int  tmp, tmp2;\n    int     err, msize, qsize,\n            loop_check_prime = 0,\n            check_prime = MP_NO;\n    unsigned char   *buf;\n\n    if (rng == NULL || dsa == NULL)\n        return BAD_FUNC_ARG;\n\n    /* set group size in bytes from modulus size\n     * FIPS 186-4 defines valid values (1024, 160) (2048, 256) (3072, 256)\n     */\n    switch (modulus_size) {\n        case 1024:\n            qsize = 20;\n            break;\n        case 2048:\n        case 3072:\n            qsize = 32;\n            break;\n        default:\n            return BAD_FUNC_ARG;\n    }\n\n    /* modulus size in bytes */\n    msize = modulus_size / WOLFSSL_BIT_SIZE;\n\n    /* allocate ram */\n    buf = (unsigned char *)XMALLOC(msize - qsize,\n                                   dsa->heap, DYNAMIC_TYPE_TMP_BUFFER);\n    if (buf == NULL) {\n        return MEMORY_E;\n    }\n\n    /* make a random string that will be multplied against q */\n    err = wc_RNG_GenerateBlock(rng, buf, msize - qsize);\n    if (err != MP_OKAY) {\n        XFREE(buf, dsa->heap, DYNAMIC_TYPE_TMP_BUFFER);\n        return err;\n    }\n\n    /* force magnitude */\n    buf[0] |= 0xC0;\n\n    /* force even */\n    buf[msize - qsize - 1] &= ~1;\n\n    if (mp_init_multi(&tmp2, &dsa->p, &dsa->q, 0, 0, 0) != MP_OKAY) {\n        mp_clear(&dsa->q);\n        XFREE(buf, dsa->heap, DYNAMIC_TYPE_TMP_BUFFER);\n        return MP_INIT_E;\n    }\n\n    err = mp_read_unsigned_bin(&tmp2, buf, msize - qsize);\n    if (err != MP_OKAY) {\n        mp_clear(&dsa->q);\n        mp_clear(&dsa->p);\n        mp_clear(&tmp2);\n        XFREE(buf, dsa->heap, DYNAMIC_TYPE_TMP_BUFFER);\n        return err;\n    }\n    XFREE(buf, dsa->heap, DYNAMIC_TYPE_TMP_BUFFER);\n\n    /* make our prime q */\n    err = mp_rand_prime(&dsa->q, qsize, rng, NULL);\n    if (err != MP_OKAY) {\n        mp_clear(&dsa->q);\n        mp_clear(&dsa->p);\n        mp_clear(&tmp2);\n        return err;\n    }\n\n    /* p = random * q */\n    err = mp_mul(&dsa->q, &tmp2, &dsa->p);\n    if (err != MP_OKAY) {\n        mp_clear(&dsa->q);\n        mp_clear(&dsa->p);\n        mp_clear(&tmp2);\n        return err;\n    }\n\n    /* p = random * q + 1, so q is a prime divisor of p-1 */\n    err = mp_add_d(&dsa->p, 1, &dsa->p);\n    if (err != MP_OKAY) {\n        mp_clear(&dsa->q);\n        mp_clear(&dsa->p);\n        mp_clear(&tmp2);\n        return err;\n    }\n\n    if (mp_init(&tmp) != MP_OKAY) {\n        mp_clear(&dsa->q);\n        mp_clear(&dsa->p);\n        mp_clear(&tmp2);\n        return MP_INIT_E;\n    }\n\n    /* tmp = 2q  */\n    err = mp_add(&dsa->q, &dsa->q, &tmp);\n    if (err != MP_OKAY) {\n        mp_clear(&dsa->q);\n        mp_clear(&dsa->p);\n        mp_clear(&tmp);\n        mp_clear(&tmp2);\n        return err;\n    }\n\n    /* loop until p is prime */\n    while (check_prime == MP_NO) {\n        err = mp_prime_is_prime_ex(&dsa->p, 8, &check_prime, rng);\n        if (err != MP_OKAY) {\n            mp_clear(&dsa->q);\n            mp_clear(&dsa->p);\n            mp_clear(&tmp);\n            mp_clear(&tmp2);\n            return err;\n        }\n\n        if (check_prime != MP_YES) {\n            /* p += 2q */\n            err = mp_add(&tmp, &dsa->p, &dsa->p);\n            if (err != MP_OKAY) {\n                mp_clear(&dsa->q);\n                mp_clear(&dsa->p);\n                mp_clear(&tmp);\n                mp_clear(&tmp2);\n                return err;\n            }\n\n            loop_check_prime++;\n        }\n    }\n\n    /* tmp2 += (2*loop_check_prime)\n     * to have p = (q * tmp2) + 1 prime\n     */\n    if (loop_check_prime) {\n        err = mp_add_d(&tmp2, 2*loop_check_prime, &tmp2);\n        if (err != MP_OKAY) {\n            mp_clear(&dsa->q);\n            mp_clear(&dsa->p);\n            mp_clear(&tmp);\n            mp_clear(&tmp2);\n            return err;\n        }\n    }\n\n    if (mp_init(&dsa->g) != MP_OKAY) {\n        mp_clear(&dsa->q);\n        mp_clear(&dsa->p);\n        mp_clear(&tmp);\n        mp_clear(&tmp2);\n        return MP_INIT_E;\n    }\n\n    /* find a value g for which g^tmp2 != 1 */\n    if (mp_set(&dsa->g, 1) != MP_OKAY) {\n        mp_clear(&dsa->q);\n        mp_clear(&dsa->p);\n        mp_clear(&tmp);\n        mp_clear(&tmp2);\n        return MP_INIT_E;\n    }\n\n    do {\n        err = mp_add_d(&dsa->g, 1, &dsa->g);\n        if (err != MP_OKAY) {\n            mp_clear(&dsa->q);\n            mp_clear(&dsa->p);\n            mp_clear(&dsa->g);\n            mp_clear(&tmp);\n            mp_clear(&tmp2);\n            return err;\n        }\n\n        err = mp_exptmod(&dsa->g, &tmp2, &dsa->p, &tmp);\n        if (err != MP_OKAY) {\n            mp_clear(&dsa->q);\n            mp_clear(&dsa->p);\n            mp_clear(&dsa->g);\n            mp_clear(&tmp);\n            mp_clear(&tmp2);\n            return err;\n        }\n\n    } while (mp_cmp_d(&tmp, 1) == MP_EQ);\n\n    /* at this point tmp generates a group of order q mod p */\n    mp_exch(&tmp, &dsa->g);\n\n    mp_clear(&tmp);\n    mp_clear(&tmp2);\n\n    return MP_OKAY;\n}\n#endif /* WOLFSSL_KEY_GEN */\n\n\nstatic int _DsaImportParamsRaw(DsaKey* dsa, const char* p, const char* q,\n                          const char* g, int trusted, WC_RNG* rng)\n{\n    int err;\n    word32 pSz, qSz;\n\n    if (dsa == NULL || p == NULL || q == NULL || g == NULL)\n        return BAD_FUNC_ARG;\n\n    /* read p */\n    err = mp_read_radix(&dsa->p, p, MP_RADIX_HEX);\n    if (err == MP_OKAY && !trusted) {\n        int isPrime = 1;\n        if (rng == NULL)\n            err = mp_prime_is_prime(&dsa->p, 8, &isPrime);\n        else\n            err = mp_prime_is_prime_ex(&dsa->p, 8, &isPrime, rng);\n\n        if (err == MP_OKAY) {\n            if (!isPrime)\n                err = DH_CHECK_PUB_E;\n        }\n    }\n\n    /* read q */\n    if (err == MP_OKAY)\n        err = mp_read_radix(&dsa->q, q, MP_RADIX_HEX);\n\n    /* read g */\n    if (err == MP_OKAY)\n        err = mp_read_radix(&dsa->g, g, MP_RADIX_HEX);\n\n    /* verify (L,N) pair bit lengths */\n    pSz = mp_unsigned_bin_size(&dsa->p);\n    qSz = mp_unsigned_bin_size(&dsa->q);\n\n    if (CheckDsaLN(pSz * WOLFSSL_BIT_SIZE, qSz * WOLFSSL_BIT_SIZE) != 0) {\n        WOLFSSL_MSG(\"Invalid DSA p or q parameter size\");\n        err = BAD_FUNC_ARG;\n    }\n\n    if (err != MP_OKAY) {\n        mp_clear(&dsa->p);\n        mp_clear(&dsa->q);\n        mp_clear(&dsa->g);\n    }\n\n    return err;\n}\n\n\n/* Import raw DSA parameters into DsaKey structure for use with wc_MakeDsaKey(),\n * input parameters (p,q,g) should be represented as ASCII hex values.\n *\n * dsa  - pointer to initialized DsaKey structure\n * p    - DSA (p) parameter, ASCII hex string\n * pSz  - length of p\n * q    - DSA (q) parameter, ASCII hex string\n * qSz  - length of q\n * g    - DSA (g) parameter, ASCII hex string\n * gSz  - length of g\n *\n * returns 0 on success, negative upon failure\n */\nint wc_DsaImportParamsRaw(DsaKey* dsa, const char* p, const char* q,\n                          const char* g)\n{\n    return _DsaImportParamsRaw(dsa, p, q, g, 1, NULL);\n}\n\n\n/* Import raw DSA parameters into DsaKey structure for use with wc_MakeDsaKey(),\n * input parameters (p,q,g) should be represented as ASCII hex values. Check\n * that the p value is probably prime.\n *\n * dsa  - pointer to initialized DsaKey structure\n * p    - DSA (p) parameter, ASCII hex string\n * pSz  - length of p\n * q    - DSA (q) parameter, ASCII hex string\n * qSz  - length of q\n * g    - DSA (g) parameter, ASCII hex string\n * gSz  - length of g\n * trusted - trust that p is OK\n * rng  - random number generator for the prime test\n *\n * returns 0 on success, negative upon failure\n */\nint wc_DsaImportParamsRawCheck(DsaKey* dsa, const char* p, const char* q,\n                          const char* g, int trusted, WC_RNG* rng)\n{\n    return _DsaImportParamsRaw(dsa, p, q, g, trusted, rng);\n}\n\n\n/* Export raw DSA parameters from DsaKey structure\n *\n * dsa  - pointer to initialized DsaKey structure\n * p    - output location for DSA (p) parameter\n * pSz  - [IN/OUT] size of output buffer for p, size of p\n * q    - output location for DSA (q) parameter\n * qSz  - [IN/OUT] size of output buffer for q, size of q\n * g    - output location for DSA (g) parameter\n * gSz  - [IN/OUT] size of output buffer for g, size of g\n *\n * If p, q, and g pointers are all passed in as NULL, the function\n * will set pSz, qSz, and gSz to the required output buffer sizes for p,\n * q, and g. In this case, the function will return LENGTH_ONLY_E.\n *\n * returns 0 on success, negative upon failure\n */\nint wc_DsaExportParamsRaw(DsaKey* dsa, byte* p, word32* pSz,\n                          byte* q, word32* qSz, byte* g, word32* gSz)\n{\n    int err;\n    word32 pLen, qLen, gLen;\n\n    if (dsa == NULL || pSz == NULL || qSz == NULL || gSz == NULL)\n        return BAD_FUNC_ARG;\n\n    /* get required output buffer sizes */\n    pLen = mp_unsigned_bin_size(&dsa->p);\n    qLen = mp_unsigned_bin_size(&dsa->q);\n    gLen = mp_unsigned_bin_size(&dsa->g);\n\n    /* return buffer sizes and LENGTH_ONLY_E if buffers are NULL */\n    if (p == NULL && q == NULL && g == NULL) {\n        *pSz = pLen;\n        *qSz = qLen;\n        *gSz = gLen;\n        return LENGTH_ONLY_E;\n    }\n\n    if (p == NULL || q == NULL || g == NULL)\n        return BAD_FUNC_ARG;\n\n    /* export p */\n    if (*pSz < pLen) {\n        WOLFSSL_MSG(\"Output buffer for DSA p parameter too small, \"\n                    \"required size placed into pSz\");\n        *pSz = pLen;\n        return BUFFER_E;\n    }\n    *pSz = pLen;\n    err = mp_to_unsigned_bin(&dsa->p, p);\n\n    /* export q */\n    if (err == MP_OKAY) {\n        if (*qSz < qLen) {\n            WOLFSSL_MSG(\"Output buffer for DSA q parameter too small, \"\n                        \"required size placed into qSz\");\n            *qSz = qLen;\n            return BUFFER_E;\n        }\n        *qSz = qLen;\n        err = mp_to_unsigned_bin(&dsa->q, q);\n    }\n\n    /* export g */\n    if (err == MP_OKAY) {\n        if (*gSz < gLen) {\n            WOLFSSL_MSG(\"Output buffer for DSA g parameter too small, \"\n                        \"required size placed into gSz\");\n            *gSz = gLen;\n            return BUFFER_E;\n        }\n        *gSz = gLen;\n        err = mp_to_unsigned_bin(&dsa->g, g);\n    }\n\n    return err;\n}\n\n\n/* Export raw DSA key (x, y) from DsaKey structure\n *\n * dsa  - pointer to initialized DsaKey structure\n * x    - output location for private key\n * xSz  - [IN/OUT] size of output buffer for x, size of x\n * y    - output location for public key\n * ySz  - [IN/OUT] size of output buffer for y, size of y\n *\n * If x and y pointers are all passed in as NULL, the function\n * will set xSz and ySz to the required output buffer sizes for x\n * and y. In this case, the function will return LENGTH_ONLY_E.\n *\n * returns 0 on success, negative upon failure\n */\nint wc_DsaExportKeyRaw(DsaKey* dsa, byte* x, word32* xSz, byte* y, word32* ySz)\n{\n    int err;\n    word32 xLen, yLen;\n\n    if (dsa == NULL || xSz == NULL || ySz == NULL)\n        return BAD_FUNC_ARG;\n\n    /* get required output buffer sizes */\n    xLen = mp_unsigned_bin_size(&dsa->x);\n    yLen = mp_unsigned_bin_size(&dsa->y);\n\n    /* return buffer sizes and LENGTH_ONLY_E if buffers are NULL */\n    if (x == NULL && y == NULL) {\n        *xSz = xLen;\n        *ySz = yLen;\n        return LENGTH_ONLY_E;\n    }\n\n    if (x == NULL || y == NULL)\n        return BAD_FUNC_ARG;\n\n    /* export x */\n    if (*xSz < xLen) {\n        WOLFSSL_MSG(\"Output buffer for DSA private key (x) too small, \"\n                    \"required size placed into xSz\");\n        *xSz = xLen;\n        return BUFFER_E;\n    }\n    *xSz = xLen;\n    err = mp_to_unsigned_bin(&dsa->x, x);\n\n    /* export y */\n    if (err == MP_OKAY) {\n        if (*ySz < yLen) {\n            WOLFSSL_MSG(\"Output buffer to DSA public key (y) too small, \"\n                        \"required size placed into ySz\");\n            *ySz = yLen;\n            return BUFFER_E;\n        }\n        *ySz = yLen;\n        err = mp_to_unsigned_bin(&dsa->y, y);\n    }\n\n    return err;\n}\n\n\nint wc_DsaSign(const byte* digest, byte* out, DsaKey* key, WC_RNG* rng)\n{\n    mp_int  k, kInv, r, s, H;\n    mp_int* qMinus1;\n    int     ret = 0, sz;\n    byte    buffer[DSA_HALF_SIZE];\n    byte*   tmp;  /* initial output pointer */\n\n    if (digest == NULL || out == NULL || key == NULL || rng == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    tmp = out;\n\n    sz = min((int)sizeof(buffer), mp_unsigned_bin_size(&key->q));\n\n    if (mp_init_multi(&k, &kInv, &r, &s, &H, 0) != MP_OKAY)\n        return MP_INIT_E;\n    qMinus1 = &kInv;\n\n    /* NIST FIPS 186-4: B.2.2\n     * Per-Message Secret Number Generation by Testing Candidates\n     * Generate k in range [1, q-1].\n     *   Check that k is less than q-1: range [0, q-2].\n     *   Add 1 to k: range [1, q-1].\n     */\n    if (mp_sub_d(&key->q, 1, qMinus1))\n        ret = MP_SUB_E;\n\n    if (ret == 0) {\n        do {\n            /* Step 4: generate k */\n            ret = wc_RNG_GenerateBlock(rng, buffer, sz);\n\n            /* Step 5 */\n            if (ret == 0 && mp_read_unsigned_bin(&k, buffer, sz) != MP_OKAY)\n                ret = MP_READ_E;\n\n            /* k is a random numnber and it should be less than q-1\n             * if k greater than repeat\n             */\n        /* Step 6 */\n        } while (ret == 0 && mp_cmp(&k, qMinus1) != MP_LT);\n    }\n    /* Step 7 */\n    if (ret == 0 && mp_add_d(&k, 1, &k) != MP_OKAY)\n        ret = MP_MOD_E;\n\n    /* inverse k mod q */\n    if (ret == 0 && mp_invmod(&k, &key->q, &kInv) != MP_OKAY)\n        ret = MP_INVMOD_E;\n\n    /* generate r, r = (g exp k mod p) mod q */\n    if (ret == 0 && mp_exptmod_ex(&key->g, &k, key->q.used, &key->p,\n                                                               &r) != MP_OKAY) {\n        ret = MP_EXPTMOD_E;\n    }\n\n    if (ret == 0 && mp_mod(&r, &key->q, &r) != MP_OKAY)\n        ret = MP_MOD_E;\n\n    /* generate H from sha digest */\n    if (ret == 0 && mp_read_unsigned_bin(&H, digest,WC_SHA_DIGEST_SIZE) != MP_OKAY)\n        ret = MP_READ_E;\n\n    /* generate s, s = (kInv * (H + x*r)) % q */\n    if (ret == 0 && mp_mul(&key->x, &r, &s) != MP_OKAY)\n        ret = MP_MUL_E;\n\n    if (ret == 0 && mp_add(&s, &H, &s) != MP_OKAY)\n        ret = MP_ADD_E;\n\n    if (ret == 0 && mp_mulmod(&s, &kInv, &key->q, &s) != MP_OKAY)\n        ret = MP_MULMOD_E;\n\n    /* detect zero r or s */\n    if (ret == 0 && (mp_iszero(&r) == MP_YES || mp_iszero(&s) == MP_YES))\n        ret = MP_ZERO_E;\n\n    /* write out */\n    if (ret == 0)  {\n        int rSz = mp_unsigned_bin_size(&r);\n        int sSz = mp_unsigned_bin_size(&s);\n\n        while (rSz++ < DSA_HALF_SIZE) {\n            *out++ = 0x00;  /* pad front with zeros */\n        }\n\n        if (mp_to_unsigned_bin(&r, out) != MP_OKAY)\n            ret = MP_TO_E;\n        else {\n            out = tmp + DSA_HALF_SIZE;  /* advance to s in output */\n            while (sSz++ < DSA_HALF_SIZE) {\n                *out++ = 0x00;  /* pad front with zeros */\n            }\n            ret = mp_to_unsigned_bin(&s, out);\n        }\n    }\n\n    mp_clear(&H);\n    mp_clear(&s);\n    mp_clear(&r);\n    mp_clear(&kInv);\n    mp_clear(&k);\n\n    return ret;\n}\n\n\nint wc_DsaVerify(const byte* digest, const byte* sig, DsaKey* key, int* answer)\n{\n    mp_int w, u1, u2, v, r, s;\n    int    ret = 0;\n\n    if (digest == NULL || sig == NULL || key == NULL || answer == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    if (mp_init_multi(&w, &u1, &u2, &v, &r, &s) != MP_OKAY)\n        return MP_INIT_E;\n\n    /* set r and s from signature */\n    if (mp_read_unsigned_bin(&r, sig, DSA_HALF_SIZE) != MP_OKAY ||\n        mp_read_unsigned_bin(&s, sig + DSA_HALF_SIZE, DSA_HALF_SIZE) != MP_OKAY)\n        ret = MP_READ_E;\n\n    /* sanity checks */\n    if (ret == 0) {\n        if (mp_iszero(&r) == MP_YES || mp_iszero(&s) == MP_YES ||\n                mp_cmp(&r, &key->q) != MP_LT || mp_cmp(&s, &key->q) != MP_LT) {\n            ret = MP_ZERO_E;\n        }\n    }\n\n    /* put H into u1 from sha digest */\n    if (ret == 0 && mp_read_unsigned_bin(&u1,digest,WC_SHA_DIGEST_SIZE) != MP_OKAY)\n        ret = MP_READ_E;\n\n    /* w = s invmod q */\n    if (ret == 0 && mp_invmod(&s, &key->q, &w) != MP_OKAY)\n        ret = MP_INVMOD_E;\n\n    /* u1 = (H * w) % q */\n    if (ret == 0 && mp_mulmod(&u1, &w, &key->q, &u1) != MP_OKAY)\n        ret = MP_MULMOD_E;\n\n    /* u2 = (r * w) % q */\n    if (ret == 0 && mp_mulmod(&r, &w, &key->q, &u2) != MP_OKAY)\n        ret = MP_MULMOD_E;\n\n    /* verify v = ((g^u1 * y^u2) mod p) mod q */\n    if (ret == 0 && mp_exptmod(&key->g, &u1, &key->p, &u1) != MP_OKAY)\n        ret = MP_EXPTMOD_E;\n\n    if (ret == 0 && mp_exptmod(&key->y, &u2, &key->p, &u2) != MP_OKAY)\n        ret = MP_EXPTMOD_E;\n\n    if (ret == 0 && mp_mulmod(&u1, &u2, &key->p, &v) != MP_OKAY)\n        ret = MP_MULMOD_E;\n\n    if (ret == 0 && mp_mod(&v, &key->q, &v) != MP_OKAY)\n        ret = MP_MULMOD_E;\n\n    /* do they match */\n    if (ret == 0 && mp_cmp(&r, &v) == MP_EQ)\n        *answer = 1;\n    else\n        *answer = 0;\n\n    mp_clear(&s);\n    mp_clear(&r);\n    mp_clear(&u1);\n    mp_clear(&u2);\n    mp_clear(&w);\n    mp_clear(&v);\n\n    return ret;\n}\n\n\n#endif /* NO_DSA */\n\n"], "fixing_code": ["/* dsa.c\n *\n * Copyright (C) 2006-2019 wolfSSL Inc.\n *\n * This file is part of wolfSSL.\n *\n * wolfSSL is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * wolfSSL is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335, USA\n */\n\n\n#ifdef HAVE_CONFIG_H\n    #include <config.h>\n#endif\n\n#include <wolfssl/wolfcrypt/settings.h>\n\n#ifndef NO_DSA\n\n#include <wolfssl/wolfcrypt/random.h>\n#include <wolfssl/wolfcrypt/integer.h>\n#include <wolfssl/wolfcrypt/error-crypt.h>\n#include <wolfssl/wolfcrypt/logging.h>\n#include <wolfssl/wolfcrypt/sha.h>\n#include <wolfssl/wolfcrypt/dsa.h>\n\n#ifdef NO_INLINE\n    #include <wolfssl/wolfcrypt/misc.h>\n#else\n    #define WOLFSSL_MISC_INCLUDED\n    #include <wolfcrypt/src/misc.c>\n#endif\n\n\nenum {\n    DSA_HALF_SIZE = 20,   /* r and s size  */\n    DSA_SIG_SIZE  = 40    /* signature size */\n};\n\n\n\nint wc_InitDsaKey(DsaKey* key)\n{\n    if (key == NULL)\n        return BAD_FUNC_ARG;\n\n    key->type = -1;  /* haven't decided yet */\n    key->heap = NULL;\n\n    return mp_init_multi(\n        /* public  alloc parts */\n        &key->p,\n        &key->q,\n        &key->g,\n        &key->y,\n\n        /* private alloc parts */\n        &key->x,\n        NULL\n    );\n}\n\n\nint wc_InitDsaKey_h(DsaKey* key, void* h)\n{\n    int ret = wc_InitDsaKey(key);\n    if (ret == 0)\n        key->heap = h;\n\n    return ret;\n}\n\n\nvoid wc_FreeDsaKey(DsaKey* key)\n{\n    if (key == NULL)\n        return;\n\n    if (key->type == DSA_PRIVATE)\n        mp_forcezero(&key->x);\n\n    mp_clear(&key->x);\n    mp_clear(&key->y);\n    mp_clear(&key->g);\n    mp_clear(&key->q);\n    mp_clear(&key->p);\n}\n\n\n/* validate that (L,N) match allowed sizes from FIPS 186-4, Section 4.2.\n * modLen - represents L, the size of p (prime modulus) in bits\n * divLen - represents N, the size of q (prime divisor) in bits\n * return 0 on success, -1 on error */\nstatic int CheckDsaLN(int modLen, int divLen)\n{\n    int ret = -1;\n\n    switch (modLen) {\n        case 1024:\n            if (divLen == 160)\n                ret = 0;\n            break;\n        case 2048:\n            if (divLen == 224 || divLen == 256)\n                ret = 0;\n            break;\n        case 3072:\n            if (divLen == 256)\n                ret = 0;\n            break;\n        default:\n            break;\n    }\n\n    return ret;\n}\n\n\n#ifdef WOLFSSL_KEY_GEN\n\n/* Create DSA key pair (&dsa->x, &dsa->y)\n *\n * Based on NIST FIPS 186-4,\n * \"B.1.1 Key Pair Generation Using Extra Random Bits\"\n *\n * rng - pointer to initialized WC_RNG structure\n * dsa - pointer to initialized DsaKey structure, will hold generated key\n *\n * return 0 on success, negative on error */\nint wc_MakeDsaKey(WC_RNG *rng, DsaKey *dsa)\n{\n    byte* cBuf;\n    int qSz, pSz, cSz, err;\n    mp_int tmpQ;\n\n    if (rng == NULL || dsa == NULL)\n        return BAD_FUNC_ARG;\n\n    qSz = mp_unsigned_bin_size(&dsa->q);\n    pSz = mp_unsigned_bin_size(&dsa->p);\n\n    /* verify (L,N) pair bit lengths */\n    if (CheckDsaLN(pSz * WOLFSSL_BIT_SIZE, qSz * WOLFSSL_BIT_SIZE) != 0)\n        return BAD_FUNC_ARG;\n\n    /* generate extra 64 bits so that bias from mod function is negligible */\n    cSz = qSz + (64 / WOLFSSL_BIT_SIZE);\n    cBuf = (byte*)XMALLOC(cSz, dsa->heap, DYNAMIC_TYPE_TMP_BUFFER);\n    if (cBuf == NULL) {\n        return MEMORY_E;\n    }\n\n    if ((err = mp_init_multi(&dsa->x, &dsa->y, &tmpQ, NULL, NULL, NULL))\n                   != MP_OKAY) {\n        XFREE(cBuf, dsa->heap, DYNAMIC_TYPE_TMP_BUFFER);\n        return err;\n    }\n\n    do {\n        /* generate N+64 bits (c) from RBG into &dsa->x, making sure positive.\n         * Hash_DRBG uses SHA-256 which matches maximum\n         * requested_security_strength of (L,N) */\n        err = wc_RNG_GenerateBlock(rng, cBuf, cSz);\n        if (err != MP_OKAY) {\n            mp_clear(&dsa->x);\n            mp_clear(&dsa->y);\n            mp_clear(&tmpQ);\n            XFREE(cBuf, dsa->heap, DYNAMIC_TYPE_TMP_BUFFER);\n            return err;\n        }\n\n        err = mp_read_unsigned_bin(&dsa->x, cBuf, cSz);\n        if (err != MP_OKAY) {\n            mp_clear(&dsa->x);\n            mp_clear(&dsa->y);\n            mp_clear(&tmpQ);\n            XFREE(cBuf, dsa->heap, DYNAMIC_TYPE_TMP_BUFFER);\n            return err;\n        }\n    } while (mp_cmp_d(&dsa->x, 1) != MP_GT);\n\n    XFREE(cBuf, dsa->heap, DYNAMIC_TYPE_TMP_BUFFER);\n\n    /* tmpQ = q - 1 */\n    if (err == MP_OKAY)\n        err = mp_copy(&dsa->q, &tmpQ);\n\n    if (err == MP_OKAY)\n        err = mp_sub_d(&tmpQ, 1, &tmpQ);\n\n    /* x = c mod (q-1), &dsa->x holds c */\n    if (err == MP_OKAY)\n        err = mp_mod(&dsa->x, &tmpQ, &dsa->x);\n\n    /* x = c mod (q-1) + 1 */\n    if (err == MP_OKAY)\n        err = mp_add_d(&dsa->x, 1, &dsa->x);\n\n    /* public key : y = g^x mod p */\n    if (err == MP_OKAY)\n        err = mp_exptmod_ex(&dsa->g, &dsa->x, dsa->q.used, &dsa->p, &dsa->y);\n\n    if (err == MP_OKAY)\n        dsa->type = DSA_PRIVATE;\n\n    if (err != MP_OKAY) {\n        mp_clear(&dsa->x);\n        mp_clear(&dsa->y);\n    }\n    mp_clear(&tmpQ);\n\n    return err;\n}\n\n\n/* modulus_size in bits */\nint wc_MakeDsaParameters(WC_RNG *rng, int modulus_size, DsaKey *dsa)\n{\n    mp_int  tmp, tmp2;\n    int     err, msize, qsize,\n            loop_check_prime = 0,\n            check_prime = MP_NO;\n    unsigned char   *buf;\n\n    if (rng == NULL || dsa == NULL)\n        return BAD_FUNC_ARG;\n\n    /* set group size in bytes from modulus size\n     * FIPS 186-4 defines valid values (1024, 160) (2048, 256) (3072, 256)\n     */\n    switch (modulus_size) {\n        case 1024:\n            qsize = 20;\n            break;\n        case 2048:\n        case 3072:\n            qsize = 32;\n            break;\n        default:\n            return BAD_FUNC_ARG;\n    }\n\n    /* modulus size in bytes */\n    msize = modulus_size / WOLFSSL_BIT_SIZE;\n\n    /* allocate ram */\n    buf = (unsigned char *)XMALLOC(msize - qsize,\n                                   dsa->heap, DYNAMIC_TYPE_TMP_BUFFER);\n    if (buf == NULL) {\n        return MEMORY_E;\n    }\n\n    /* make a random string that will be multplied against q */\n    err = wc_RNG_GenerateBlock(rng, buf, msize - qsize);\n    if (err != MP_OKAY) {\n        XFREE(buf, dsa->heap, DYNAMIC_TYPE_TMP_BUFFER);\n        return err;\n    }\n\n    /* force magnitude */\n    buf[0] |= 0xC0;\n\n    /* force even */\n    buf[msize - qsize - 1] &= ~1;\n\n    if (mp_init_multi(&tmp2, &dsa->p, &dsa->q, 0, 0, 0) != MP_OKAY) {\n        mp_clear(&dsa->q);\n        XFREE(buf, dsa->heap, DYNAMIC_TYPE_TMP_BUFFER);\n        return MP_INIT_E;\n    }\n\n    err = mp_read_unsigned_bin(&tmp2, buf, msize - qsize);\n    if (err != MP_OKAY) {\n        mp_clear(&dsa->q);\n        mp_clear(&dsa->p);\n        mp_clear(&tmp2);\n        XFREE(buf, dsa->heap, DYNAMIC_TYPE_TMP_BUFFER);\n        return err;\n    }\n    XFREE(buf, dsa->heap, DYNAMIC_TYPE_TMP_BUFFER);\n\n    /* make our prime q */\n    err = mp_rand_prime(&dsa->q, qsize, rng, NULL);\n    if (err != MP_OKAY) {\n        mp_clear(&dsa->q);\n        mp_clear(&dsa->p);\n        mp_clear(&tmp2);\n        return err;\n    }\n\n    /* p = random * q */\n    err = mp_mul(&dsa->q, &tmp2, &dsa->p);\n    if (err != MP_OKAY) {\n        mp_clear(&dsa->q);\n        mp_clear(&dsa->p);\n        mp_clear(&tmp2);\n        return err;\n    }\n\n    /* p = random * q + 1, so q is a prime divisor of p-1 */\n    err = mp_add_d(&dsa->p, 1, &dsa->p);\n    if (err != MP_OKAY) {\n        mp_clear(&dsa->q);\n        mp_clear(&dsa->p);\n        mp_clear(&tmp2);\n        return err;\n    }\n\n    if (mp_init(&tmp) != MP_OKAY) {\n        mp_clear(&dsa->q);\n        mp_clear(&dsa->p);\n        mp_clear(&tmp2);\n        return MP_INIT_E;\n    }\n\n    /* tmp = 2q  */\n    err = mp_add(&dsa->q, &dsa->q, &tmp);\n    if (err != MP_OKAY) {\n        mp_clear(&dsa->q);\n        mp_clear(&dsa->p);\n        mp_clear(&tmp);\n        mp_clear(&tmp2);\n        return err;\n    }\n\n    /* loop until p is prime */\n    while (check_prime == MP_NO) {\n        err = mp_prime_is_prime_ex(&dsa->p, 8, &check_prime, rng);\n        if (err != MP_OKAY) {\n            mp_clear(&dsa->q);\n            mp_clear(&dsa->p);\n            mp_clear(&tmp);\n            mp_clear(&tmp2);\n            return err;\n        }\n\n        if (check_prime != MP_YES) {\n            /* p += 2q */\n            err = mp_add(&tmp, &dsa->p, &dsa->p);\n            if (err != MP_OKAY) {\n                mp_clear(&dsa->q);\n                mp_clear(&dsa->p);\n                mp_clear(&tmp);\n                mp_clear(&tmp2);\n                return err;\n            }\n\n            loop_check_prime++;\n        }\n    }\n\n    /* tmp2 += (2*loop_check_prime)\n     * to have p = (q * tmp2) + 1 prime\n     */\n    if (loop_check_prime) {\n        err = mp_add_d(&tmp2, 2*loop_check_prime, &tmp2);\n        if (err != MP_OKAY) {\n            mp_clear(&dsa->q);\n            mp_clear(&dsa->p);\n            mp_clear(&tmp);\n            mp_clear(&tmp2);\n            return err;\n        }\n    }\n\n    if (mp_init(&dsa->g) != MP_OKAY) {\n        mp_clear(&dsa->q);\n        mp_clear(&dsa->p);\n        mp_clear(&tmp);\n        mp_clear(&tmp2);\n        return MP_INIT_E;\n    }\n\n    /* find a value g for which g^tmp2 != 1 */\n    if (mp_set(&dsa->g, 1) != MP_OKAY) {\n        mp_clear(&dsa->q);\n        mp_clear(&dsa->p);\n        mp_clear(&tmp);\n        mp_clear(&tmp2);\n        return MP_INIT_E;\n    }\n\n    do {\n        err = mp_add_d(&dsa->g, 1, &dsa->g);\n        if (err != MP_OKAY) {\n            mp_clear(&dsa->q);\n            mp_clear(&dsa->p);\n            mp_clear(&dsa->g);\n            mp_clear(&tmp);\n            mp_clear(&tmp2);\n            return err;\n        }\n\n        err = mp_exptmod(&dsa->g, &tmp2, &dsa->p, &tmp);\n        if (err != MP_OKAY) {\n            mp_clear(&dsa->q);\n            mp_clear(&dsa->p);\n            mp_clear(&dsa->g);\n            mp_clear(&tmp);\n            mp_clear(&tmp2);\n            return err;\n        }\n\n    } while (mp_cmp_d(&tmp, 1) == MP_EQ);\n\n    /* at this point tmp generates a group of order q mod p */\n    mp_exch(&tmp, &dsa->g);\n\n    mp_clear(&tmp);\n    mp_clear(&tmp2);\n\n    return MP_OKAY;\n}\n#endif /* WOLFSSL_KEY_GEN */\n\n\nstatic int _DsaImportParamsRaw(DsaKey* dsa, const char* p, const char* q,\n                          const char* g, int trusted, WC_RNG* rng)\n{\n    int err;\n    word32 pSz, qSz;\n\n    if (dsa == NULL || p == NULL || q == NULL || g == NULL)\n        return BAD_FUNC_ARG;\n\n    /* read p */\n    err = mp_read_radix(&dsa->p, p, MP_RADIX_HEX);\n    if (err == MP_OKAY && !trusted) {\n        int isPrime = 1;\n        if (rng == NULL)\n            err = mp_prime_is_prime(&dsa->p, 8, &isPrime);\n        else\n            err = mp_prime_is_prime_ex(&dsa->p, 8, &isPrime, rng);\n\n        if (err == MP_OKAY) {\n            if (!isPrime)\n                err = DH_CHECK_PUB_E;\n        }\n    }\n\n    /* read q */\n    if (err == MP_OKAY)\n        err = mp_read_radix(&dsa->q, q, MP_RADIX_HEX);\n\n    /* read g */\n    if (err == MP_OKAY)\n        err = mp_read_radix(&dsa->g, g, MP_RADIX_HEX);\n\n    /* verify (L,N) pair bit lengths */\n    pSz = mp_unsigned_bin_size(&dsa->p);\n    qSz = mp_unsigned_bin_size(&dsa->q);\n\n    if (CheckDsaLN(pSz * WOLFSSL_BIT_SIZE, qSz * WOLFSSL_BIT_SIZE) != 0) {\n        WOLFSSL_MSG(\"Invalid DSA p or q parameter size\");\n        err = BAD_FUNC_ARG;\n    }\n\n    if (err != MP_OKAY) {\n        mp_clear(&dsa->p);\n        mp_clear(&dsa->q);\n        mp_clear(&dsa->g);\n    }\n\n    return err;\n}\n\n\n/* Import raw DSA parameters into DsaKey structure for use with wc_MakeDsaKey(),\n * input parameters (p,q,g) should be represented as ASCII hex values.\n *\n * dsa  - pointer to initialized DsaKey structure\n * p    - DSA (p) parameter, ASCII hex string\n * pSz  - length of p\n * q    - DSA (q) parameter, ASCII hex string\n * qSz  - length of q\n * g    - DSA (g) parameter, ASCII hex string\n * gSz  - length of g\n *\n * returns 0 on success, negative upon failure\n */\nint wc_DsaImportParamsRaw(DsaKey* dsa, const char* p, const char* q,\n                          const char* g)\n{\n    return _DsaImportParamsRaw(dsa, p, q, g, 1, NULL);\n}\n\n\n/* Import raw DSA parameters into DsaKey structure for use with wc_MakeDsaKey(),\n * input parameters (p,q,g) should be represented as ASCII hex values. Check\n * that the p value is probably prime.\n *\n * dsa  - pointer to initialized DsaKey structure\n * p    - DSA (p) parameter, ASCII hex string\n * pSz  - length of p\n * q    - DSA (q) parameter, ASCII hex string\n * qSz  - length of q\n * g    - DSA (g) parameter, ASCII hex string\n * gSz  - length of g\n * trusted - trust that p is OK\n * rng  - random number generator for the prime test\n *\n * returns 0 on success, negative upon failure\n */\nint wc_DsaImportParamsRawCheck(DsaKey* dsa, const char* p, const char* q,\n                          const char* g, int trusted, WC_RNG* rng)\n{\n    return _DsaImportParamsRaw(dsa, p, q, g, trusted, rng);\n}\n\n\n/* Export raw DSA parameters from DsaKey structure\n *\n * dsa  - pointer to initialized DsaKey structure\n * p    - output location for DSA (p) parameter\n * pSz  - [IN/OUT] size of output buffer for p, size of p\n * q    - output location for DSA (q) parameter\n * qSz  - [IN/OUT] size of output buffer for q, size of q\n * g    - output location for DSA (g) parameter\n * gSz  - [IN/OUT] size of output buffer for g, size of g\n *\n * If p, q, and g pointers are all passed in as NULL, the function\n * will set pSz, qSz, and gSz to the required output buffer sizes for p,\n * q, and g. In this case, the function will return LENGTH_ONLY_E.\n *\n * returns 0 on success, negative upon failure\n */\nint wc_DsaExportParamsRaw(DsaKey* dsa, byte* p, word32* pSz,\n                          byte* q, word32* qSz, byte* g, word32* gSz)\n{\n    int err;\n    word32 pLen, qLen, gLen;\n\n    if (dsa == NULL || pSz == NULL || qSz == NULL || gSz == NULL)\n        return BAD_FUNC_ARG;\n\n    /* get required output buffer sizes */\n    pLen = mp_unsigned_bin_size(&dsa->p);\n    qLen = mp_unsigned_bin_size(&dsa->q);\n    gLen = mp_unsigned_bin_size(&dsa->g);\n\n    /* return buffer sizes and LENGTH_ONLY_E if buffers are NULL */\n    if (p == NULL && q == NULL && g == NULL) {\n        *pSz = pLen;\n        *qSz = qLen;\n        *gSz = gLen;\n        return LENGTH_ONLY_E;\n    }\n\n    if (p == NULL || q == NULL || g == NULL)\n        return BAD_FUNC_ARG;\n\n    /* export p */\n    if (*pSz < pLen) {\n        WOLFSSL_MSG(\"Output buffer for DSA p parameter too small, \"\n                    \"required size placed into pSz\");\n        *pSz = pLen;\n        return BUFFER_E;\n    }\n    *pSz = pLen;\n    err = mp_to_unsigned_bin(&dsa->p, p);\n\n    /* export q */\n    if (err == MP_OKAY) {\n        if (*qSz < qLen) {\n            WOLFSSL_MSG(\"Output buffer for DSA q parameter too small, \"\n                        \"required size placed into qSz\");\n            *qSz = qLen;\n            return BUFFER_E;\n        }\n        *qSz = qLen;\n        err = mp_to_unsigned_bin(&dsa->q, q);\n    }\n\n    /* export g */\n    if (err == MP_OKAY) {\n        if (*gSz < gLen) {\n            WOLFSSL_MSG(\"Output buffer for DSA g parameter too small, \"\n                        \"required size placed into gSz\");\n            *gSz = gLen;\n            return BUFFER_E;\n        }\n        *gSz = gLen;\n        err = mp_to_unsigned_bin(&dsa->g, g);\n    }\n\n    return err;\n}\n\n\n/* Export raw DSA key (x, y) from DsaKey structure\n *\n * dsa  - pointer to initialized DsaKey structure\n * x    - output location for private key\n * xSz  - [IN/OUT] size of output buffer for x, size of x\n * y    - output location for public key\n * ySz  - [IN/OUT] size of output buffer for y, size of y\n *\n * If x and y pointers are all passed in as NULL, the function\n * will set xSz and ySz to the required output buffer sizes for x\n * and y. In this case, the function will return LENGTH_ONLY_E.\n *\n * returns 0 on success, negative upon failure\n */\nint wc_DsaExportKeyRaw(DsaKey* dsa, byte* x, word32* xSz, byte* y, word32* ySz)\n{\n    int err;\n    word32 xLen, yLen;\n\n    if (dsa == NULL || xSz == NULL || ySz == NULL)\n        return BAD_FUNC_ARG;\n\n    /* get required output buffer sizes */\n    xLen = mp_unsigned_bin_size(&dsa->x);\n    yLen = mp_unsigned_bin_size(&dsa->y);\n\n    /* return buffer sizes and LENGTH_ONLY_E if buffers are NULL */\n    if (x == NULL && y == NULL) {\n        *xSz = xLen;\n        *ySz = yLen;\n        return LENGTH_ONLY_E;\n    }\n\n    if (x == NULL || y == NULL)\n        return BAD_FUNC_ARG;\n\n    /* export x */\n    if (*xSz < xLen) {\n        WOLFSSL_MSG(\"Output buffer for DSA private key (x) too small, \"\n                    \"required size placed into xSz\");\n        *xSz = xLen;\n        return BUFFER_E;\n    }\n    *xSz = xLen;\n    err = mp_to_unsigned_bin(&dsa->x, x);\n\n    /* export y */\n    if (err == MP_OKAY) {\n        if (*ySz < yLen) {\n            WOLFSSL_MSG(\"Output buffer to DSA public key (y) too small, \"\n                        \"required size placed into ySz\");\n            *ySz = yLen;\n            return BUFFER_E;\n        }\n        *ySz = yLen;\n        err = mp_to_unsigned_bin(&dsa->y, y);\n    }\n\n    return err;\n}\n\n\nint wc_DsaSign(const byte* digest, byte* out, DsaKey* key, WC_RNG* rng)\n{\n    mp_int  k, kInv, r, s, H;\n#ifndef WOLFSSL_MP_INVMOD_CONSTANT_TIME\n    mp_int  b;\n#endif\n    mp_int* qMinus1;\n    int     ret = 0, sz;\n    byte    buffer[DSA_HALF_SIZE];\n    byte*   tmp;  /* initial output pointer */\n\n    if (digest == NULL || out == NULL || key == NULL || rng == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    tmp = out;\n\n    sz = min((int)sizeof(buffer), mp_unsigned_bin_size(&key->q));\n\n#ifdef WOLFSSL_MP_INVMOD_CONSTANT_TIME\n    if (mp_init_multi(&k, &kInv, &r, &s, &H, 0) != MP_OKAY)\n#else\n    if (mp_init_multi(&k, &kInv, &r, &s, &H, &b) != MP_OKAY)\n#endif\n    {\n        return MP_INIT_E;\n    }\n    qMinus1 = &kInv;\n\n    /* NIST FIPS 186-4: B.2.2\n     * Per-Message Secret Number Generation by Testing Candidates\n     * Generate k in range [1, q-1].\n     *   Check that k is less than q-1: range [0, q-2].\n     *   Add 1 to k: range [1, q-1].\n     */\n    if (mp_sub_d(&key->q, 1, qMinus1))\n        ret = MP_SUB_E;\n\n    if (ret == 0) {\n        do {\n            /* Step 4: generate k */\n            ret = wc_RNG_GenerateBlock(rng, buffer, sz);\n\n            /* Step 5 */\n            if (ret == 0 && mp_read_unsigned_bin(&k, buffer, sz) != MP_OKAY)\n                ret = MP_READ_E;\n\n            /* k is a random numnber and it should be less than q-1\n             * if k greater than repeat\n             */\n        /* Step 6 */\n        } while (ret == 0 && mp_cmp(&k, qMinus1) != MP_LT);\n    }\n    /* Step 7 */\n    if (ret == 0 && mp_add_d(&k, 1, &k) != MP_OKAY)\n        ret = MP_MOD_E;\n\n#ifdef WOLFSSL_MP_INVMOD_CONSTANT_TIME\n    /* inverse k mod q */\n    if (ret == 0 && mp_invmod(&k, &key->q, &kInv) != MP_OKAY)\n        ret = MP_INVMOD_E;\n\n    /* generate r, r = (g exp k mod p) mod q */\n    if (ret == 0 && mp_exptmod_ex(&key->g, &k, key->q.used, &key->p,\n                                                               &r) != MP_OKAY) {\n        ret = MP_EXPTMOD_E;\n    }\n\n    if (ret == 0 && mp_mod(&r, &key->q, &r) != MP_OKAY)\n        ret = MP_MOD_E;\n\n    /* generate H from sha digest */\n    if (ret == 0 && mp_read_unsigned_bin(&H, digest,WC_SHA_DIGEST_SIZE) != MP_OKAY)\n        ret = MP_READ_E;\n\n    /* generate s, s = (kInv * (H + x*r)) % q */\n    if (ret == 0 && mp_mul(&key->x, &r, &s) != MP_OKAY)\n        ret = MP_MUL_E;\n\n    if (ret == 0 && mp_add(&s, &H, &s) != MP_OKAY)\n        ret = MP_ADD_E;\n\n    if (ret == 0 && mp_mulmod(&s, &kInv, &key->q, &s) != MP_OKAY)\n        ret = MP_MULMOD_E;\n#else\n    /* Blinding value\n     * Generate b in range [1, q-1].\n     */\n    if (ret == 0) {\n        do {\n            ret = wc_RNG_GenerateBlock(rng, buffer, sz);\n            if (ret == 0 && mp_read_unsigned_bin(&b, buffer, sz) != MP_OKAY)\n                ret = MP_READ_E;\n        } while (ret == 0 && mp_cmp(&b, qMinus1) != MP_LT);\n    }\n    if (ret == 0 && mp_add_d(&b, 1, &b) != MP_OKAY)\n        ret = MP_MOD_E;\n\n    /* set H from sha digest */\n    if (ret == 0 && mp_read_unsigned_bin(&H, digest,\n                                               WC_SHA_DIGEST_SIZE) != MP_OKAY) {\n        ret = MP_READ_E;\n    }\n\n    /* generate r, r = (g exp k mod p) mod q */\n    if (ret == 0 && mp_exptmod_ex(&key->g, &k, key->q.used, &key->p,\n                                                               &r) != MP_OKAY) {\n        ret = MP_EXPTMOD_E;\n    }\n\n    /* calculate s = (H + xr)/k\n                   = b.(H/k.b + x.r/k.b) */\n\n    /* k = k.b */\n    if (ret == 0 && mp_mulmod(&k, &b, &key->q, &k) != MP_OKAY)\n        ret = MP_MULMOD_E;\n\n    /* kInv = 1/k.b mod q */\n    if (ret == 0 && mp_invmod(&k, &key->q, &kInv) != MP_OKAY)\n        ret = MP_INVMOD_E;\n\n    if (ret == 0 && mp_mod(&r, &key->q, &r) != MP_OKAY)\n        ret = MP_MOD_E;\n\n    /* s = x.r */\n    if (ret == 0 && mp_mul(&key->x, &r, &s) != MP_OKAY)\n        ret = MP_MUL_E;\n\n    /* s = x.r/k.b */\n    if (ret == 0 && mp_mulmod(&s, &kInv, &key->q, &s) != MP_OKAY)\n        ret = MP_MULMOD_E;\n\n    /* H = H/k.b */\n    if (ret == 0 && mp_mulmod(&H, &kInv, &key->q, &H) != MP_OKAY)\n        ret = MP_MULMOD_E;\n\n    /* s = H/k.b + x.r/k.b\n         = (H + x.r)/k.b */\n    if (ret == 0 && mp_add(&s, &H, &s) != MP_OKAY)\n        ret = MP_ADD_E;\n\n    /* s = b.(e + x.r)/k.b\n         = (e + x.r)/k */\n    if (ret == 0 && mp_mulmod(&s, &b, &key->q, &s) != MP_OKAY)\n        ret = MP_MULMOD_E;\n\n    /* s = (e + x.r)/k */\n    if (ret == 0 && mp_mod(&s, &key->q, &s) != MP_OKAY)\n        ret = MP_MOD_E;\n#endif\n\n    /* detect zero r or s */\n    if (ret == 0 && (mp_iszero(&r) == MP_YES || mp_iszero(&s) == MP_YES))\n        ret = MP_ZERO_E;\n\n    /* write out */\n    if (ret == 0)  {\n        int rSz = mp_unsigned_bin_size(&r);\n        int sSz = mp_unsigned_bin_size(&s);\n\n        while (rSz++ < DSA_HALF_SIZE) {\n            *out++ = 0x00;  /* pad front with zeros */\n        }\n\n        if (mp_to_unsigned_bin(&r, out) != MP_OKAY)\n            ret = MP_TO_E;\n        else {\n            out = tmp + DSA_HALF_SIZE;  /* advance to s in output */\n            while (sSz++ < DSA_HALF_SIZE) {\n                *out++ = 0x00;  /* pad front with zeros */\n            }\n            ret = mp_to_unsigned_bin(&s, out);\n        }\n    }\n\n    ForceZero(buffer, sz);\n    mp_forcezero(&kInv);\n    mp_forcezero(&k);\n#ifndef WOLFSSL_MP_INVMOD_CONSTANT_TIME\n    mp_forcezero(&b);\n\n    mp_clear(&b);\n#endif\n    mp_clear(&H);\n    mp_clear(&s);\n    mp_clear(&r);\n    mp_clear(&kInv);\n    mp_clear(&k);\n\n    return ret;\n}\n\n\nint wc_DsaVerify(const byte* digest, const byte* sig, DsaKey* key, int* answer)\n{\n    mp_int w, u1, u2, v, r, s;\n    int    ret = 0;\n\n    if (digest == NULL || sig == NULL || key == NULL || answer == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    if (mp_init_multi(&w, &u1, &u2, &v, &r, &s) != MP_OKAY)\n        return MP_INIT_E;\n\n    /* set r and s from signature */\n    if (mp_read_unsigned_bin(&r, sig, DSA_HALF_SIZE) != MP_OKAY ||\n        mp_read_unsigned_bin(&s, sig + DSA_HALF_SIZE, DSA_HALF_SIZE) != MP_OKAY)\n        ret = MP_READ_E;\n\n    /* sanity checks */\n    if (ret == 0) {\n        if (mp_iszero(&r) == MP_YES || mp_iszero(&s) == MP_YES ||\n                mp_cmp(&r, &key->q) != MP_LT || mp_cmp(&s, &key->q) != MP_LT) {\n            ret = MP_ZERO_E;\n        }\n    }\n\n    /* put H into u1 from sha digest */\n    if (ret == 0 && mp_read_unsigned_bin(&u1,digest,WC_SHA_DIGEST_SIZE) != MP_OKAY)\n        ret = MP_READ_E;\n\n    /* w = s invmod q */\n    if (ret == 0 && mp_invmod(&s, &key->q, &w) != MP_OKAY)\n        ret = MP_INVMOD_E;\n\n    /* u1 = (H * w) % q */\n    if (ret == 0 && mp_mulmod(&u1, &w, &key->q, &u1) != MP_OKAY)\n        ret = MP_MULMOD_E;\n\n    /* u2 = (r * w) % q */\n    if (ret == 0 && mp_mulmod(&r, &w, &key->q, &u2) != MP_OKAY)\n        ret = MP_MULMOD_E;\n\n    /* verify v = ((g^u1 * y^u2) mod p) mod q */\n    if (ret == 0 && mp_exptmod(&key->g, &u1, &key->p, &u1) != MP_OKAY)\n        ret = MP_EXPTMOD_E;\n\n    if (ret == 0 && mp_exptmod(&key->y, &u2, &key->p, &u2) != MP_OKAY)\n        ret = MP_EXPTMOD_E;\n\n    if (ret == 0 && mp_mulmod(&u1, &u2, &key->p, &v) != MP_OKAY)\n        ret = MP_MULMOD_E;\n\n    if (ret == 0 && mp_mod(&v, &key->q, &v) != MP_OKAY)\n        ret = MP_MULMOD_E;\n\n    /* do they match */\n    if (ret == 0 && mp_cmp(&r, &v) == MP_EQ)\n        *answer = 1;\n    else\n        *answer = 0;\n\n    mp_clear(&s);\n    mp_clear(&r);\n    mp_clear(&u1);\n    mp_clear(&u2);\n    mp_clear(&w);\n    mp_clear(&v);\n\n    return ret;\n}\n\n\n#endif /* NO_DSA */\n\n"], "filenames": ["wolfcrypt/src/dsa.c"], "buggy_code_start_loc": [665], "buggy_code_end_loc": [761], "fixing_code_start_loc": [666], "fixing_code_end_loc": [846], "type": "NVD-CWE-Other", "message": "An issue was discovered in wolfSSL before 4.3.0 in a non-default configuration where DSA is enabled. DSA signing uses the BEEA algorithm during modular inversion of the nonce, leading to a side-channel attack against the nonce.", "other": {"cve": {"id": "CVE-2019-19963", "sourceIdentifier": "cve@mitre.org", "published": "2019-12-25T00:15:10.913", "lastModified": "2020-01-02T19:48:34.747", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in wolfSSL before 4.3.0 in a non-default configuration where DSA is enabled. DSA signing uses the BEEA algorithm during modular inversion of the nonce, leading to a side-channel attack against the nonce."}, {"lang": "es", "value": "Se detect\u00f3 un problema en wolfSSL versiones anteriores a 4.3.0, en una configuraci\u00f3n no predeterminada donde DSA est\u00e1 habilitado. La firma DSA utiliza el algoritmo BEEA durante la inversi\u00f3n modular del nonce, conllevando a un ataque de canal lateral contra el nonce."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:wolfssl:wolfssl:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.3.0", "matchCriteriaId": "0D85F9EA-33EB-4A71-81FF-A54ABDFABA01"}]}]}], "references": [{"url": "https://github.com/wolfSSL/wolfssl/commit/7e391f0fd57f2ef375b1174d752a56ce34b2b190", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/wolfSSL/wolfssl/releases/tag/v4.3.0-stable", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/wolfSSL/wolfssl/commit/7e391f0fd57f2ef375b1174d752a56ce34b2b190"}}