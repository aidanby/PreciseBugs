{"buggy_code": ["# -*- coding: utf-8 -*-\n\n# Copyright 2014 OpenMarket Ltd\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nfrom __future__ import absolute_import\n\nfrom twisted.web.resource import Resource\n\nfrom sydent.util.stringutils import is_valid_client_secret\nfrom sydent.util.emailutils import EmailAddressException, EmailSendException\nfrom sydent.validators import (\n    IncorrectClientSecretException,\n    InvalidSessionIdException,\n    IncorrectSessionTokenException,\n    SessionExpiredException,\n)\n\n\nfrom sydent.http.servlets import get_args, jsonwrap, send_cors\nfrom sydent.http.auth import authV2\n\n\nclass EmailRequestCodeServlet(Resource):\n    isLeaf = True\n\n    def __init__(self, syd, require_auth=False):\n        self.sydent = syd\n        self.require_auth = require_auth\n\n    @jsonwrap\n    def render_POST(self, request):\n        send_cors(request)\n\n        if self.require_auth:\n            authV2(self.sydent, request)\n\n        args = get_args(request, ('email', 'client_secret', 'send_attempt'))\n\n        email = args['email']\n        sendAttempt = args['send_attempt']\n        clientSecret = args['client_secret']\n\n        if not is_valid_client_secret(clientSecret):\n            request.setResponseCode(400)\n            return {\n                'errcode': 'M_INVALID_PARAM',\n                'error': 'Invalid client_secret provided'\n            }\n\n        ipaddress = self.sydent.ip_from_request(request)\n        brand = self.sydent.brand_from_request(request)\n\n        nextLink = None\n        if 'next_link' in args and not args['next_link'].startswith(\"file:///\"):\n            nextLink = args['next_link']\n\n        try:\n            sid = self.sydent.validators.email.requestToken(\n                email, clientSecret, sendAttempt, nextLink, ipaddress=ipaddress, brand=brand,\n            )\n            resp = {'sid': str(sid)}\n        except EmailAddressException:\n            request.setResponseCode(400)\n            resp = {'errcode': 'M_INVALID_EMAIL', 'error': 'Invalid email address'}\n        except EmailSendException:\n            request.setResponseCode(500)\n            resp = {'errcode': 'M_EMAIL_SEND_ERROR', 'error': 'Failed to send email'}\n\n        return resp\n\n    def render_OPTIONS(self, request):\n        send_cors(request)\n        return b''\n\n\nclass EmailValidateCodeServlet(Resource):\n    isLeaf = True\n\n    def __init__(self, syd, require_auth=False):\n        self.sydent = syd\n        self.require_auth = require_auth\n\n    def render_GET(self, request):\n        args = get_args(request, ('nextLink',), required=False)\n\n        resp = None\n        try:\n            resp = self.do_validate_request(request)\n        except:\n            pass\n        if resp and 'success' in resp and resp['success']:\n            msg = \"Verification successful! Please return to your Matrix client to continue.\"\n            if 'nextLink' in args:\n                next_link = args['nextLink']\n                if not next_link.startswith(\"file:///\"):\n                    request.setResponseCode(302)\n                    request.setHeader(\"Location\", next_link)\n        else:\n            msg = \"Verification failed: you may need to request another verification email\"\n\n        brand = self.sydent.brand_from_request(request)\n        templateFile = self.sydent.get_branded_template(\n            brand,\n            \"verify_response_template.html\",\n            ('http', 'verify_response_template'),\n        )\n\n        request.setHeader(\"Content-Type\", \"text/html\")\n        res = open(templateFile).read() % {'message': msg}\n        return res.encode(\"UTF-8\")\n\n    @jsonwrap\n    def render_POST(self, request):\n        send_cors(request)\n\n        if self.require_auth:\n            authV2(self.sydent, request)\n\n        return self.do_validate_request(request)\n\n    def do_validate_request(self, request):\n        \"\"\"\n        Extracts information about a validation session from the request and\n        attempts to validate that session.\n\n        :param request: The request to extract information about the session from.\n        :type request: twisted.web.server.Request\n\n        :return: A dict with a \"success\" key which value indicates whether the\n            validation succeeded. If the validation failed, this dict also includes\n            a \"errcode\" and a \"error\" keys which include information about the failure.\n        :rtype: dict[str, bool or str]\n        \"\"\"\n        args = get_args(request, ('token', 'sid', 'client_secret'))\n\n        sid = args['sid']\n        tokenString = args['token']\n        clientSecret = args['client_secret']\n\n        if not is_valid_client_secret(clientSecret):\n            request.setResponseCode(400)\n            return {\n                'errcode': 'M_INVALID_PARAM',\n                'error': 'Invalid client_secret provided'\n            }\n\n        try:\n            return self.sydent.validators.email.validateSessionWithToken(sid, clientSecret, tokenString)\n        except IncorrectClientSecretException:\n            return {'success': False, 'errcode': 'M_INVALID_PARAM',\n                    'error': \"Client secret does not match the one given when requesting the token\"}\n        except SessionExpiredException:\n            return {'success': False, 'errcode': 'M_SESSION_EXPIRED',\n                    'error': \"This validation session has expired: call requestToken again\"}\n        except InvalidSessionIdException:\n            return {'success': False, 'errcode': 'M_INVALID_PARAM',\n                    'error': \"The token doesn't match\"}\n        except IncorrectSessionTokenException:\n            return {'success': False, 'errcode': 'M_NO_VALID_SESSION',\n                    'error': \"No session could be found with this sid\"}\n\n    def render_OPTIONS(self, request):\n        send_cors(request)\n        return b''\n", "# -*- coding: utf-8 -*-\n\n# Copyright 2015 OpenMarket Ltd\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nfrom __future__ import absolute_import\n\nimport nacl.signing\nimport random\nimport string\nfrom email.header import Header\n\nfrom six import string_types\nfrom twisted.web.resource import Resource\nfrom unpaddedbase64 import encode_base64\n\nfrom sydent.db.invite_tokens import JoinTokenStore\nfrom sydent.db.threepid_associations import GlobalAssociationStore\n\nfrom sydent.http.servlets import get_args, send_cors, jsonwrap, MatrixRestError\nfrom sydent.http.auth import authV2\nfrom sydent.util.emailutils import sendEmail\n\nclass StoreInviteServlet(Resource):\n    def __init__(self, syd, require_auth=False):\n        self.sydent = syd\n        self.random = random.SystemRandom()\n        self.require_auth = require_auth\n\n    @jsonwrap\n    def render_POST(self, request):\n        send_cors(request)\n\n        args = get_args(request, (\"medium\", \"address\", \"room_id\", \"sender\",))\n        medium = args[\"medium\"]\n        address = args[\"address\"]\n        roomId = args[\"room_id\"]\n        sender = args[\"sender\"]\n\n        verified_sender = None\n        if self.require_auth:\n            account = authV2(self.sydent, request)\n            verified_sender = sender\n            if account.userId != sender:\n                raise MatrixRestError(403, \"M_UNAUTHORIZED\", \"'sender' doesn't match\")\n\n        globalAssocStore = GlobalAssociationStore(self.sydent)\n        mxid = globalAssocStore.getMxid(medium, address)\n        if mxid:\n            request.setResponseCode(400)\n            return {\n                \"errcode\": \"M_THREEPID_IN_USE\",\n                \"error\": \"Binding already known\",\n                \"mxid\": mxid,\n            }\n\n        if medium != \"email\":\n            request.setResponseCode(400)\n            return {\n                \"errcode\": \"M_UNRECOGNIZED\",\n                \"error\": \"Didn't understand medium '%s'\" % (medium,),\n            }\n\n        token = self._randomString(128)\n\n        tokenStore = JoinTokenStore(self.sydent)\n\n        ephemeralPrivateKey = nacl.signing.SigningKey.generate()\n        ephemeralPublicKey = ephemeralPrivateKey.verify_key\n\n        ephemeralPrivateKeyBase64 = encode_base64(ephemeralPrivateKey.encode(), True)\n        ephemeralPublicKeyBase64 = encode_base64(ephemeralPublicKey.encode(), True)\n\n        tokenStore.storeEphemeralPublicKey(ephemeralPublicKeyBase64)\n        tokenStore.storeToken(medium, address, roomId, sender, token)\n\n        # Variables to substitute in the template.\n        substitutions = {}\n        # Include all arguments sent via the request.\n        for k, v in args.items():\n            if isinstance(v, string_types):\n                substitutions[k] = v\n        substitutions[\"token\"] = token\n\n        # Substitutions that the template requires, but are optional to provide\n        # to the API.\n        extra_substitutions = [\n            'sender_display_name',\n            'token',\n            'room_name',\n            'bracketed_room_name',\n            'room_avatar_url',\n            'sender_avatar_url',\n            'guest_user_id',\n            'guest_access_token',\n        ]\n        for k in extra_substitutions:\n            substitutions.setdefault(k, '')\n\n        substitutions[\"bracketed_verified_sender\"] = \"\"\n        if verified_sender:\n            substitutions[\"bracketed_verified_sender\"] = \"(%s) \" % (verified_sender,)\n\n        substitutions[\"ephemeral_private_key\"] = ephemeralPrivateKeyBase64\n        if substitutions[\"room_name\"] != '':\n            substitutions[\"bracketed_room_name\"] = \"(%s) \" % substitutions[\"room_name\"]\n\n        substitutions[\"web_client_location\"] = self.sydent.default_web_client_location\n        if 'org.matrix.web_client_location' in substitutions:\n            substitutions[\"web_client_location\"] = substitutions.pop(\"org.matrix.web_client_location\")\n\n        subject_header = Header(self.sydent.cfg.get('email', 'email.invite.subject', raw=True) % substitutions, 'utf8')\n        substitutions[\"subject_header_value\"] = subject_header.encode()\n\n        brand = self.sydent.brand_from_request(request)\n        templateFile = self.sydent.get_branded_template(\n            brand,\n            \"invite_template.eml\",\n            ('email', 'email.invite_template'),\n        )\n\n        sendEmail(self.sydent, templateFile, address, substitutions)\n\n        pubKey = self.sydent.keyring.ed25519.verify_key\n        pubKeyBase64 = encode_base64(pubKey.encode())\n\n        baseUrl = \"%s/_matrix/identity/api/v1\" % (self.sydent.cfg.get('http', 'client_http_base'),)\n\n        keysToReturn = []\n        keysToReturn.append({\n            \"public_key\": pubKeyBase64,\n            \"key_validity_url\": baseUrl + \"/pubkey/isvalid\",\n        })\n        keysToReturn.append({\n            \"public_key\": ephemeralPublicKeyBase64,\n            \"key_validity_url\": baseUrl + \"/pubkey/ephemeral/isvalid\",\n        })\n\n        resp = {\n            \"token\": token,\n            \"public_key\": pubKeyBase64,\n            \"public_keys\": keysToReturn,\n            \"display_name\": self.redact_email_address(address),\n        }\n\n        return resp\n\n    def redact_email_address(self, address):\n        \"\"\"\n        Redacts the content of a 3PID address. Redacts both the email's username and\n        domain independently.\n\n        :param address: The address to redact.\n        :type address: unicode\n\n        :return: The redacted address.\n        :rtype: unicode\n        \"\"\"\n        # Extract strings from the address\n        username, domain = address.split(u\"@\", 1)\n\n        # Obfuscate strings\n        redacted_username = self._redact(username, self.sydent.username_obfuscate_characters)\n        redacted_domain = self._redact(domain, self.sydent.domain_obfuscate_characters)\n\n        return redacted_username + u\"@\" + redacted_domain\n\n    def _redact(self, s, characters_to_reveal):\n        \"\"\"\n        Redacts the content of a string, using a given amount of characters to reveal.\n        If the string is shorter than the given threshold, redact it based on length.\n\n        :param s: The string to redact.\n        :type s: unicode\n\n        :param characters_to_reveal: How many characters of the string to leave before\n            the '...'\n        :type characters_to_reveal: int\n\n        :return: The redacted string.\n        :rtype: unicode\n        \"\"\"\n        # If the string is shorter than the defined threshold, redact based on length\n        if len(s) <= characters_to_reveal:\n            if len(s) > 5:\n                return s[:3] + u\"...\"\n            if len(s) > 1:\n                return s[0] + u\"...\"\n            return u\"...\"\n\n        # Otherwise truncate it and add an ellipses\n        return s[:characters_to_reveal] + u\"...\"\n\n    def _randomString(self, length):\n        \"\"\"\n        Generate a random string of the given length.\n\n        :param length: The length of the string to generate.\n        :type length: int\n\n        :return: The generated string.\n        :rtype: unicode\n        \"\"\"\n        return u''.join(self.random.choice(string.ascii_letters) for _ in range(length))\n", "# -*- coding: utf-8 -*-\n# Copyright 2020 The Matrix.org Foundation C.I.C.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport re\nfrom typing import Optional, Tuple\n\nfrom twisted.internet.abstract import isIPAddress, isIPv6Address\n\n# https://matrix.org/docs/spec/client_server/r0.6.0#post-matrix-client-r0-register-email-requesttoken\nclient_secret_regex = re.compile(r\"^[0-9a-zA-Z\\.\\=\\_\\-]+$\")\n\n# hostname/domain name\n# https://regex101.com/r/OyN1lg/2\nhostname_regex = re.compile(\n    r\"^(?:[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)(?:\\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$\",\n    flags=re.IGNORECASE)\n\n\ndef is_valid_client_secret(client_secret):\n    \"\"\"Validate that a given string matches the client_secret regex defined by the spec\n\n    :param client_secret: The client_secret to validate\n    :type client_secret: str\n\n    :return: Whether the client_secret is valid\n    :rtype: bool\n    \"\"\"\n    return client_secret_regex.match(client_secret) is not None\n\n\ndef is_valid_hostname(string: str) -> bool:\n    \"\"\"Validate that a given string is a valid hostname or domain name.\n\n    For domain names, this only validates that the form is right (for\n    instance, it doesn't check that the TLD is valid).\n\n    :param string: The string to validate\n    :type string: str\n\n    :return: Whether the input is a valid hostname\n    :rtype: bool\n    \"\"\"\n\n    return hostname_regex.match(string) is not None\n\n\ndef parse_server_name(server_name: str) -> Tuple[str, Optional[int]]:\n    \"\"\"Split a server name into host/port parts.\n\n    No validation is done on the host part. The port part is validated to be\n    a valid port number.\n\n    Args:\n        server_name: server name to parse\n\n    Returns:\n        host/port parts.\n\n    Raises:\n        ValueError if the server name could not be parsed.\n    \"\"\"\n    try:\n        if server_name[-1] == \"]\":\n            # ipv6 literal, hopefully\n            return server_name, None\n\n        host_port = server_name.rsplit(\":\", 1)\n        host = host_port[0]\n        port = host_port[1] if host_port[1:] else None\n\n        if port:\n            port_num = int(port)\n\n            # exclude things like '08090' or ' 8090'\n            if port != str(port_num) or not (1 <= port_num < 65536):\n                raise ValueError(\"Invalid port\")\n\n        return host, port\n    except Exception:\n        raise ValueError(\"Invalid server name '%s'\" % server_name)\n\n\ndef is_valid_matrix_server_name(string: str) -> bool:\n    \"\"\"Validate that the given string is a valid Matrix server name.\n\n    A string is a valid Matrix server name if it is one of the following, plus\n    an optional port:\n\n    a. IPv4 address\n    b. IPv6 literal (`[IPV6_ADDRESS]`)\n    c. A valid hostname\n\n    :param string: The string to validate\n    :type string: str\n\n    :return: Whether the input is a valid Matrix server name\n    :rtype: bool\n    \"\"\"\n\n    try:\n        host, port = parse_server_name(string)\n    except ValueError:\n        return False\n\n    valid_ipv4_addr = isIPAddress(host)\n    valid_ipv6_literal = host[0] == \"[\" and host[-1] == \"]\" and isIPv6Address(host[1:-1])\n\n    return valid_ipv4_addr or valid_ipv6_literal or is_valid_hostname(host)\n"], "fixing_code": ["# -*- coding: utf-8 -*-\n\n# Copyright 2014 OpenMarket Ltd\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nfrom __future__ import absolute_import\n\nfrom twisted.web.resource import Resource\n\nfrom sydent.util.stringutils import is_valid_client_secret, MAX_EMAIL_ADDRESS_LENGTH\nfrom sydent.util.emailutils import EmailAddressException, EmailSendException\nfrom sydent.validators import (\n    IncorrectClientSecretException,\n    InvalidSessionIdException,\n    IncorrectSessionTokenException,\n    SessionExpiredException,\n)\n\n\nfrom sydent.http.servlets import get_args, jsonwrap, send_cors\nfrom sydent.http.auth import authV2\n\n\nclass EmailRequestCodeServlet(Resource):\n    isLeaf = True\n\n    def __init__(self, syd, require_auth=False):\n        self.sydent = syd\n        self.require_auth = require_auth\n\n    @jsonwrap\n    def render_POST(self, request):\n        send_cors(request)\n\n        if self.require_auth:\n            authV2(self.sydent, request)\n\n        args = get_args(request, ('email', 'client_secret', 'send_attempt'))\n\n        email = args['email']\n        sendAttempt = args['send_attempt']\n        clientSecret = args['client_secret']\n\n        if not is_valid_client_secret(clientSecret):\n            request.setResponseCode(400)\n            return {\n                'errcode': 'M_INVALID_PARAM',\n                'error': 'Invalid client_secret provided'\n            }\n\n        if not (0 < len(email) <= MAX_EMAIL_ADDRESS_LENGTH):\n            request.setResponseCode(400)\n            return {\n                'errcode': 'M_INVALID_PARAM',\n                'error': 'Invalid email provided'\n            }\n\n        ipaddress = self.sydent.ip_from_request(request)\n        brand = self.sydent.brand_from_request(request)\n\n        nextLink = None\n        if 'next_link' in args and not args['next_link'].startswith(\"file:///\"):\n            nextLink = args['next_link']\n\n        try:\n            sid = self.sydent.validators.email.requestToken(\n                email, clientSecret, sendAttempt, nextLink, ipaddress=ipaddress, brand=brand,\n            )\n            resp = {'sid': str(sid)}\n        except EmailAddressException:\n            request.setResponseCode(400)\n            resp = {'errcode': 'M_INVALID_EMAIL', 'error': 'Invalid email address'}\n        except EmailSendException:\n            request.setResponseCode(500)\n            resp = {'errcode': 'M_EMAIL_SEND_ERROR', 'error': 'Failed to send email'}\n\n        return resp\n\n    def render_OPTIONS(self, request):\n        send_cors(request)\n        return b''\n\n\nclass EmailValidateCodeServlet(Resource):\n    isLeaf = True\n\n    def __init__(self, syd, require_auth=False):\n        self.sydent = syd\n        self.require_auth = require_auth\n\n    def render_GET(self, request):\n        args = get_args(request, ('nextLink',), required=False)\n\n        resp = None\n        try:\n            resp = self.do_validate_request(request)\n        except:\n            pass\n        if resp and 'success' in resp and resp['success']:\n            msg = \"Verification successful! Please return to your Matrix client to continue.\"\n            if 'nextLink' in args:\n                next_link = args['nextLink']\n                if not next_link.startswith(\"file:///\"):\n                    request.setResponseCode(302)\n                    request.setHeader(\"Location\", next_link)\n        else:\n            msg = \"Verification failed: you may need to request another verification email\"\n\n        brand = self.sydent.brand_from_request(request)\n        templateFile = self.sydent.get_branded_template(\n            brand,\n            \"verify_response_template.html\",\n            ('http', 'verify_response_template'),\n        )\n\n        request.setHeader(\"Content-Type\", \"text/html\")\n        res = open(templateFile).read() % {'message': msg}\n        return res.encode(\"UTF-8\")\n\n    @jsonwrap\n    def render_POST(self, request):\n        send_cors(request)\n\n        if self.require_auth:\n            authV2(self.sydent, request)\n\n        return self.do_validate_request(request)\n\n    def do_validate_request(self, request):\n        \"\"\"\n        Extracts information about a validation session from the request and\n        attempts to validate that session.\n\n        :param request: The request to extract information about the session from.\n        :type request: twisted.web.server.Request\n\n        :return: A dict with a \"success\" key which value indicates whether the\n            validation succeeded. If the validation failed, this dict also includes\n            a \"errcode\" and a \"error\" keys which include information about the failure.\n        :rtype: dict[str, bool or str]\n        \"\"\"\n        args = get_args(request, ('token', 'sid', 'client_secret'))\n\n        sid = args['sid']\n        tokenString = args['token']\n        clientSecret = args['client_secret']\n\n        if not is_valid_client_secret(clientSecret):\n            request.setResponseCode(400)\n            return {\n                'errcode': 'M_INVALID_PARAM',\n                'error': 'Invalid client_secret provided'\n            }\n\n        try:\n            return self.sydent.validators.email.validateSessionWithToken(sid, clientSecret, tokenString)\n        except IncorrectClientSecretException:\n            return {'success': False, 'errcode': 'M_INVALID_PARAM',\n                    'error': \"Client secret does not match the one given when requesting the token\"}\n        except SessionExpiredException:\n            return {'success': False, 'errcode': 'M_SESSION_EXPIRED',\n                    'error': \"This validation session has expired: call requestToken again\"}\n        except InvalidSessionIdException:\n            return {'success': False, 'errcode': 'M_INVALID_PARAM',\n                    'error': \"The token doesn't match\"}\n        except IncorrectSessionTokenException:\n            return {'success': False, 'errcode': 'M_NO_VALID_SESSION',\n                    'error': \"No session could be found with this sid\"}\n\n    def render_OPTIONS(self, request):\n        send_cors(request)\n        return b''\n", "# -*- coding: utf-8 -*-\n\n# Copyright 2015 OpenMarket Ltd\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nfrom __future__ import absolute_import\n\nimport nacl.signing\nimport random\nimport string\nfrom email.header import Header\n\nfrom six import string_types\nfrom twisted.web.resource import Resource\nfrom unpaddedbase64 import encode_base64\n\nfrom sydent.db.invite_tokens import JoinTokenStore\nfrom sydent.db.threepid_associations import GlobalAssociationStore\n\nfrom sydent.http.servlets import get_args, send_cors, jsonwrap, MatrixRestError\nfrom sydent.http.auth import authV2\nfrom sydent.util.emailutils import sendEmail\nfrom sydent.util.stringutils import MAX_EMAIL_ADDRESS_LENGTH\n\n\nclass StoreInviteServlet(Resource):\n    def __init__(self, syd, require_auth=False):\n        self.sydent = syd\n        self.random = random.SystemRandom()\n        self.require_auth = require_auth\n\n    @jsonwrap\n    def render_POST(self, request):\n        send_cors(request)\n\n        args = get_args(request, (\"medium\", \"address\", \"room_id\", \"sender\",))\n        medium = args[\"medium\"]\n        address = args[\"address\"]\n        roomId = args[\"room_id\"]\n        sender = args[\"sender\"]\n\n        verified_sender = None\n        if self.require_auth:\n            account = authV2(self.sydent, request)\n            verified_sender = sender\n            if account.userId != sender:\n                raise MatrixRestError(403, \"M_UNAUTHORIZED\", \"'sender' doesn't match\")\n\n        globalAssocStore = GlobalAssociationStore(self.sydent)\n        mxid = globalAssocStore.getMxid(medium, address)\n        if mxid:\n            request.setResponseCode(400)\n            return {\n                \"errcode\": \"M_THREEPID_IN_USE\",\n                \"error\": \"Binding already known\",\n                \"mxid\": mxid,\n            }\n\n        if medium != \"email\":\n            request.setResponseCode(400)\n            return {\n                \"errcode\": \"M_UNRECOGNIZED\",\n                \"error\": \"Didn't understand medium '%s'\" % (medium,),\n            }\n\n        if not (0 < len(address) <= MAX_EMAIL_ADDRESS_LENGTH):\n            request.setResponseCode(400)\n            return {\n                'errcode': 'M_INVALID_PARAM',\n                'error': 'Invalid email provided'\n            }\n\n        token = self._randomString(128)\n\n        tokenStore = JoinTokenStore(self.sydent)\n\n        ephemeralPrivateKey = nacl.signing.SigningKey.generate()\n        ephemeralPublicKey = ephemeralPrivateKey.verify_key\n\n        ephemeralPrivateKeyBase64 = encode_base64(ephemeralPrivateKey.encode(), True)\n        ephemeralPublicKeyBase64 = encode_base64(ephemeralPublicKey.encode(), True)\n\n        tokenStore.storeEphemeralPublicKey(ephemeralPublicKeyBase64)\n        tokenStore.storeToken(medium, address, roomId, sender, token)\n\n        # Variables to substitute in the template.\n        substitutions = {}\n        # Include all arguments sent via the request.\n        for k, v in args.items():\n            if isinstance(v, string_types):\n                substitutions[k] = v\n        substitutions[\"token\"] = token\n\n        # Substitutions that the template requires, but are optional to provide\n        # to the API.\n        extra_substitutions = [\n            'sender_display_name',\n            'token',\n            'room_name',\n            'bracketed_room_name',\n            'room_avatar_url',\n            'sender_avatar_url',\n            'guest_user_id',\n            'guest_access_token',\n        ]\n        for k in extra_substitutions:\n            substitutions.setdefault(k, '')\n\n        substitutions[\"bracketed_verified_sender\"] = \"\"\n        if verified_sender:\n            substitutions[\"bracketed_verified_sender\"] = \"(%s) \" % (verified_sender,)\n\n        substitutions[\"ephemeral_private_key\"] = ephemeralPrivateKeyBase64\n        if substitutions[\"room_name\"] != '':\n            substitutions[\"bracketed_room_name\"] = \"(%s) \" % substitutions[\"room_name\"]\n\n        substitutions[\"web_client_location\"] = self.sydent.default_web_client_location\n        if 'org.matrix.web_client_location' in substitutions:\n            substitutions[\"web_client_location\"] = substitutions.pop(\"org.matrix.web_client_location\")\n\n        subject_header = Header(self.sydent.cfg.get('email', 'email.invite.subject', raw=True) % substitutions, 'utf8')\n        substitutions[\"subject_header_value\"] = subject_header.encode()\n\n        brand = self.sydent.brand_from_request(request)\n        templateFile = self.sydent.get_branded_template(\n            brand,\n            \"invite_template.eml\",\n            ('email', 'email.invite_template'),\n        )\n\n        sendEmail(self.sydent, templateFile, address, substitutions)\n\n        pubKey = self.sydent.keyring.ed25519.verify_key\n        pubKeyBase64 = encode_base64(pubKey.encode())\n\n        baseUrl = \"%s/_matrix/identity/api/v1\" % (self.sydent.cfg.get('http', 'client_http_base'),)\n\n        keysToReturn = []\n        keysToReturn.append({\n            \"public_key\": pubKeyBase64,\n            \"key_validity_url\": baseUrl + \"/pubkey/isvalid\",\n        })\n        keysToReturn.append({\n            \"public_key\": ephemeralPublicKeyBase64,\n            \"key_validity_url\": baseUrl + \"/pubkey/ephemeral/isvalid\",\n        })\n\n        resp = {\n            \"token\": token,\n            \"public_key\": pubKeyBase64,\n            \"public_keys\": keysToReturn,\n            \"display_name\": self.redact_email_address(address),\n        }\n\n        return resp\n\n    def redact_email_address(self, address):\n        \"\"\"\n        Redacts the content of a 3PID address. Redacts both the email's username and\n        domain independently.\n\n        :param address: The address to redact.\n        :type address: unicode\n\n        :return: The redacted address.\n        :rtype: unicode\n        \"\"\"\n        # Extract strings from the address\n        username, domain = address.split(u\"@\", 1)\n\n        # Obfuscate strings\n        redacted_username = self._redact(username, self.sydent.username_obfuscate_characters)\n        redacted_domain = self._redact(domain, self.sydent.domain_obfuscate_characters)\n\n        return redacted_username + u\"@\" + redacted_domain\n\n    def _redact(self, s, characters_to_reveal):\n        \"\"\"\n        Redacts the content of a string, using a given amount of characters to reveal.\n        If the string is shorter than the given threshold, redact it based on length.\n\n        :param s: The string to redact.\n        :type s: unicode\n\n        :param characters_to_reveal: How many characters of the string to leave before\n            the '...'\n        :type characters_to_reveal: int\n\n        :return: The redacted string.\n        :rtype: unicode\n        \"\"\"\n        # If the string is shorter than the defined threshold, redact based on length\n        if len(s) <= characters_to_reveal:\n            if len(s) > 5:\n                return s[:3] + u\"...\"\n            if len(s) > 1:\n                return s[0] + u\"...\"\n            return u\"...\"\n\n        # Otherwise truncate it and add an ellipses\n        return s[:characters_to_reveal] + u\"...\"\n\n    def _randomString(self, length):\n        \"\"\"\n        Generate a random string of the given length.\n\n        :param length: The length of the string to generate.\n        :type length: int\n\n        :return: The generated string.\n        :rtype: unicode\n        \"\"\"\n        return u''.join(self.random.choice(string.ascii_letters) for _ in range(length))\n", "# -*- coding: utf-8 -*-\n# Copyright 2020 The Matrix.org Foundation C.I.C.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport re\nfrom typing import Optional, Tuple\n\nfrom twisted.internet.abstract import isIPAddress, isIPv6Address\n\n# https://matrix.org/docs/spec/client_server/r0.6.0#post-matrix-client-r0-register-email-requesttoken\nCLIENT_SECRET_REGEX = re.compile(r\"^[0-9a-zA-Z\\.=_\\-]+$\")\n\n# hostname/domain name\n# https://regex101.com/r/OyN1lg/2\nhostname_regex = re.compile(\n    r\"^(?:[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)(?:\\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$\",\n    flags=re.IGNORECASE)\n\n# it's unclear what the maximum length of an email address is. RFC3696 (as corrected\n# by errata) says:\n#    the upper limit on address lengths should normally be considered to be 254.\n#\n# In practice, mail servers appear to be more tolerant and allow 400 characters\n# or so. Let's allow 500, which should be plenty for everyone.\n#\nMAX_EMAIL_ADDRESS_LENGTH = 500\n\n\ndef is_valid_client_secret(client_secret):\n    \"\"\"Validate that a given string matches the client_secret regex defined by the spec\n\n    :param client_secret: The client_secret to validate\n    :type client_secret: str\n\n    :return: Whether the client_secret is valid\n    :rtype: bool\n    \"\"\"\n    return (\n        0 < len(client_secret) <= 255\n        and CLIENT_SECRET_REGEX.match(client_secret) is not None\n    )\n\n\ndef is_valid_hostname(string: str) -> bool:\n    \"\"\"Validate that a given string is a valid hostname or domain name.\n\n    For domain names, this only validates that the form is right (for\n    instance, it doesn't check that the TLD is valid).\n\n    :param string: The string to validate\n    :type string: str\n\n    :return: Whether the input is a valid hostname\n    :rtype: bool\n    \"\"\"\n\n    return hostname_regex.match(string) is not None\n\n\ndef parse_server_name(server_name: str) -> Tuple[str, Optional[int]]:\n    \"\"\"Split a server name into host/port parts.\n\n    No validation is done on the host part. The port part is validated to be\n    a valid port number.\n\n    Args:\n        server_name: server name to parse\n\n    Returns:\n        host/port parts.\n\n    Raises:\n        ValueError if the server name could not be parsed.\n    \"\"\"\n    try:\n        if server_name[-1] == \"]\":\n            # ipv6 literal, hopefully\n            return server_name, None\n\n        host_port = server_name.rsplit(\":\", 1)\n        host = host_port[0]\n        port = host_port[1] if host_port[1:] else None\n\n        if port:\n            port_num = int(port)\n\n            # exclude things like '08090' or ' 8090'\n            if port != str(port_num) or not (1 <= port_num < 65536):\n                raise ValueError(\"Invalid port\")\n\n        return host, port\n    except Exception:\n        raise ValueError(\"Invalid server name '%s'\" % server_name)\n\n\ndef is_valid_matrix_server_name(string: str) -> bool:\n    \"\"\"Validate that the given string is a valid Matrix server name.\n\n    A string is a valid Matrix server name if it is one of the following, plus\n    an optional port:\n\n    a. IPv4 address\n    b. IPv6 literal (`[IPV6_ADDRESS]`)\n    c. A valid hostname\n\n    :param string: The string to validate\n    :type string: str\n\n    :return: Whether the input is a valid Matrix server name\n    :rtype: bool\n    \"\"\"\n\n    try:\n        host, port = parse_server_name(string)\n    except ValueError:\n        return False\n\n    valid_ipv4_addr = isIPAddress(host)\n    valid_ipv6_literal = host[0] == \"[\" and host[-1] == \"]\" and isIPv6Address(host[1:-1])\n\n    return valid_ipv4_addr or valid_ipv6_literal or is_valid_hostname(host)\n"], "filenames": ["sydent/http/servlets/emailservlet.py", "sydent/http/servlets/store_invite_servlet.py", "sydent/util/stringutils.py"], "buggy_code_start_loc": [20, 32, 21], "buggy_code_end_loc": [58, 71, 40], "fixing_code_start_loc": [20, 33, 21], "fixing_code_end_loc": [66, 81, 52], "type": "CWE-20", "message": "Sydent is a reference Matrix identity server. In Sydent versions 2.2.0 and prior, sissing input validation of some parameters on the endpoints used to confirm third-party identifiers could cause excessive use of disk space and memory leading to resource exhaustion. A patch for the vulnerability is in version 2.3.0. No workarounds are known to exist.", "other": {"cve": {"id": "CVE-2021-29433", "sourceIdentifier": "security-advisories@github.com", "published": "2021-04-15T18:15:12.497", "lastModified": "2022-08-02T16:01:36.987", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Sydent is a reference Matrix identity server. In Sydent versions 2.2.0 and prior, sissing input validation of some parameters on the endpoints used to confirm third-party identifiers could cause excessive use of disk space and memory leading to resource exhaustion. A patch for the vulnerability is in version 2.3.0. No workarounds are known to exist."}, {"lang": "es", "value": "Sydent es un servidor de identidad de Matrix de referencia. En las versiones 2.2.0 y anteriores de Sydent, la falta de validaci\u00f3n de la entrada de algunos par\u00e1metros en los puntos finales utilizados para confirmar los identificadores de terceros podr\u00eda causar un uso excesivo de espacio en disco y memoria, lo que llevar\u00eda al agotamiento de los recursos. La versi\u00f3n 2.3.0 contiene un parche para esta vulnerabilidad. No se conoce la existencia de soluciones"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:matrix:sydent:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.3.0", "matchCriteriaId": "C77C5A80-7302-49F8-8DAA-37B269691C9C"}]}]}], "references": [{"url": "https://github.com/matrix-org/sydent/commit/3175fd358ebc2c310eab7a3dbf296ce2bd54c1da", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/matrix-org/sydent/security/advisories/GHSA-pw4v-gr34-2553", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/matrix-org/sydent/commit/3175fd358ebc2c310eab7a3dbf296ce2bd54c1da"}}