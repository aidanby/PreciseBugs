{"buggy_code": ["// Copyright (c) 2015-2021 MinIO, Inc.\n//\n// This file is part of MinIO Object Storage stack\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npackage cmd\n\nimport (\n\t\"bufio\"\n\t\"crypto\"\n\t\"crypto/tls\"\n\t\"encoding/hex\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strings\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\txhttp \"github.com/minio/minio/internal/http\"\n\t\"github.com/minio/minio/internal/logger\"\n\t\"github.com/minio/pkg/env\"\n\txnet \"github.com/minio/pkg/net\"\n\t\"github.com/minio/selfupdate\"\n)\n\nconst (\n\tminioReleaseTagTimeLayout = \"2006-01-02T15-04-05Z\"\n\tminioOSARCH               = runtime.GOOS + \"-\" + runtime.GOARCH\n\tminioReleaseURL           = \"https://dl.min.io/server/minio/release/\" + minioOSARCH + SlashSeparator\n\n\tenvMinisignPubKey = \"MINIO_UPDATE_MINISIGN_PUBKEY\"\n\tupdateTimeout     = 10 * time.Second\n)\n\n// For windows our files have .exe additionally.\nvar minioReleaseWindowsInfoURL = minioReleaseURL + \"minio.exe.sha256sum\"\n\n// minioVersionToReleaseTime - parses a standard official release\n// MinIO version string.\n//\n// An official binary's version string is the release time formatted\n// with RFC3339 (in UTC) - e.g. `2017-09-29T19:16:56Z`\nfunc minioVersionToReleaseTime(version string) (releaseTime time.Time, err error) {\n\treturn time.Parse(time.RFC3339, version)\n}\n\n// releaseTimeToReleaseTag - converts a time to a string formatted as\n// an official MinIO release tag.\n//\n// An official minio release tag looks like:\n// `RELEASE.2017-09-29T19-16-56Z`\nfunc releaseTimeToReleaseTag(releaseTime time.Time) string {\n\treturn \"RELEASE.\" + releaseTime.Format(minioReleaseTagTimeLayout)\n}\n\n// releaseTagToReleaseTime - reverse of `releaseTimeToReleaseTag()`\nfunc releaseTagToReleaseTime(releaseTag string) (releaseTime time.Time, err error) {\n\tfields := strings.Split(releaseTag, \".\")\n\tif len(fields) < 2 || len(fields) > 4 {\n\t\treturn releaseTime, fmt.Errorf(\"%s is not a valid release tag\", releaseTag)\n\t}\n\tif fields[0] != \"RELEASE\" {\n\t\treturn releaseTime, fmt.Errorf(\"%s is not a valid release tag\", releaseTag)\n\t}\n\treturn time.Parse(minioReleaseTagTimeLayout, fields[1])\n}\n\n// getModTime - get the file modification time of `path`\nfunc getModTime(path string) (t time.Time, err error) {\n\t// Convert to absolute path\n\tabsPath, err := filepath.Abs(path)\n\tif err != nil {\n\t\treturn t, fmt.Errorf(\"Unable to get absolute path of %s. %w\", path, err)\n\t}\n\n\t// Version is minio non-standard, we will use minio binary's\n\t// ModTime as release time.\n\tfi, err := Stat(absPath)\n\tif err != nil {\n\t\treturn t, fmt.Errorf(\"Unable to get ModTime of %s. %w\", absPath, err)\n\t}\n\n\t// Return the ModTime\n\treturn fi.ModTime().UTC(), nil\n}\n\n// GetCurrentReleaseTime - returns this process's release time.  If it\n// is official minio version, parsed version is returned else minio\n// binary's mod time is returned.\nfunc GetCurrentReleaseTime() (releaseTime time.Time, err error) {\n\tif releaseTime, err = minioVersionToReleaseTime(Version); err == nil {\n\t\treturn releaseTime, err\n\t}\n\n\t// Looks like version is minio non-standard, we use minio\n\t// binary's ModTime as release time:\n\treturn getModTime(os.Args[0])\n}\n\n// IsDocker - returns if the environment minio is running in docker or\n// not. The check is a simple file existence check.\n//\n// https://github.com/moby/moby/blob/master/daemon/initlayer/setup_unix.go#L25\n//\n//     \"/.dockerenv\":      \"file\",\n//\nfunc IsDocker() bool {\n\tif !globalIsCICD {\n\t\t_, err := os.Stat(\"/.dockerenv\")\n\t\tif osIsNotExist(err) {\n\t\t\treturn false\n\t\t}\n\n\t\t// Log error, as we will not propagate it to caller\n\t\tlogger.LogIf(GlobalContext, err)\n\n\t\treturn err == nil\n\t}\n\treturn false\n}\n\n// IsDCOS returns true if minio is running in DCOS.\nfunc IsDCOS() bool {\n\tif !globalIsCICD {\n\t\t// http://mesos.apache.org/documentation/latest/docker-containerizer/\n\t\t// Mesos docker containerizer sets this value\n\t\treturn env.Get(\"MESOS_CONTAINER_NAME\", \"\") != \"\"\n\t}\n\treturn false\n}\n\n// IsKubernetes returns true if minio is running in kubernetes.\nfunc IsKubernetes() bool {\n\tif !globalIsCICD {\n\t\t// Kubernetes env used to validate if we are\n\t\t// indeed running inside a kubernetes pod\n\t\t// is KUBERNETES_SERVICE_HOST\n\t\t// https://github.com/kubernetes/kubernetes/blob/master/pkg/kubelet/kubelet_pods.go#L541\n\t\treturn env.Get(\"KUBERNETES_SERVICE_HOST\", \"\") != \"\"\n\t}\n\treturn false\n}\n\n// IsBOSH returns true if minio is deployed from a bosh package\nfunc IsBOSH() bool {\n\t// \"/var/vcap/bosh\" exists in BOSH deployed instance.\n\t_, err := os.Stat(\"/var/vcap/bosh\")\n\tif osIsNotExist(err) {\n\t\treturn false\n\t}\n\n\t// Log error, as we will not propagate it to caller\n\tlogger.LogIf(GlobalContext, err)\n\n\treturn err == nil\n}\n\n// MinIO Helm chart uses DownwardAPIFile to write pod label info to /podinfo/labels\n// More info: https://kubernetes.io/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/#store-pod-fields\n// Check if this is Helm package installation and report helm chart version\nfunc getHelmVersion(helmInfoFilePath string) string {\n\t// Read the file exists.\n\thelmInfoFile, err := os.Open(helmInfoFilePath)\n\tif err != nil {\n\t\t// Log errors and return \"\" as MinIO can be deployed\n\t\t// without Helm charts as well.\n\t\tif !osIsNotExist(err) {\n\t\t\treqInfo := (&logger.ReqInfo{}).AppendTags(\"helmInfoFilePath\", helmInfoFilePath)\n\t\t\tctx := logger.SetReqInfo(GlobalContext, reqInfo)\n\t\t\tlogger.LogIf(ctx, err)\n\t\t}\n\t\treturn \"\"\n\t}\n\n\tscanner := bufio.NewScanner(helmInfoFile)\n\tfor scanner.Scan() {\n\t\tif strings.Contains(scanner.Text(), \"chart=\") {\n\t\t\thelmChartVersion := strings.TrimPrefix(scanner.Text(), \"chart=\")\n\t\t\t// remove quotes from the chart version\n\t\t\treturn strings.Trim(helmChartVersion, `\"`)\n\t\t}\n\t}\n\n\treturn \"\"\n}\n\n// IsSourceBuild - returns if this binary is a non-official build from\n// source code.\nfunc IsSourceBuild() bool {\n\t_, err := minioVersionToReleaseTime(Version)\n\treturn err != nil\n}\n\n// IsPCFTile returns if server is running in PCF\nfunc IsPCFTile() bool {\n\treturn env.Get(\"MINIO_PCF_TILE_VERSION\", \"\") != \"\"\n}\n\n// DO NOT CHANGE USER AGENT STYLE.\n// The style should be\n//\n//   MinIO (<OS>; <ARCH>[; <MODE>][; dcos][; kubernetes][; docker][; source]) MinIO/<VERSION> MinIO/<RELEASE-TAG> MinIO/<COMMIT-ID> [MinIO/universe-<PACKAGE-NAME>] [MinIO/helm-<HELM-VERSION>]\n//\n// Any change here should be discussed by opening an issue at\n// https://github.com/minio/minio/issues.\nfunc getUserAgent(mode string) string {\n\tuserAgentParts := []string{}\n\t// Helper function to concisely append a pair of strings to a\n\t// the user-agent slice.\n\tuaAppend := func(p, q string) {\n\t\tuserAgentParts = append(userAgentParts, p, q)\n\t}\n\n\tuaAppend(\"MinIO (\", runtime.GOOS)\n\tuaAppend(\"; \", runtime.GOARCH)\n\tif mode != \"\" {\n\t\tuaAppend(\"; \", mode)\n\t}\n\tif IsDCOS() {\n\t\tuaAppend(\"; \", \"dcos\")\n\t}\n\tif IsKubernetes() {\n\t\tuaAppend(\"; \", \"kubernetes\")\n\t}\n\tif IsDocker() {\n\t\tuaAppend(\"; \", \"docker\")\n\t}\n\tif IsBOSH() {\n\t\tuaAppend(\"; \", \"bosh\")\n\t}\n\tif IsSourceBuild() {\n\t\tuaAppend(\"; \", \"source\")\n\t}\n\n\tuaAppend(\") MinIO/\", Version)\n\tuaAppend(\" MinIO/\", ReleaseTag)\n\tuaAppend(\" MinIO/\", CommitID)\n\tif IsDCOS() {\n\t\tuniversePkgVersion := env.Get(\"MARATHON_APP_LABEL_DCOS_PACKAGE_VERSION\", \"\")\n\t\t// On DC/OS environment try to the get universe package version.\n\t\tif universePkgVersion != \"\" {\n\t\t\tuaAppend(\" MinIO/universe-\", universePkgVersion)\n\t\t}\n\t}\n\n\tif IsKubernetes() {\n\t\t// In Kubernetes environment, try to fetch the helm package version\n\t\thelmChartVersion := getHelmVersion(\"/podinfo/labels\")\n\t\tif helmChartVersion != \"\" {\n\t\t\tuaAppend(\" MinIO/helm-\", helmChartVersion)\n\t\t}\n\t\t// In Kubernetes environment, try to fetch the Operator, VSPHERE plugin version\n\t\topVersion := env.Get(\"MINIO_OPERATOR_VERSION\", \"\")\n\t\tif opVersion != \"\" {\n\t\t\tuaAppend(\" MinIO/operator-\", opVersion)\n\t\t}\n\t\tvsphereVersion := env.Get(\"MINIO_VSPHERE_PLUGIN_VERSION\", \"\")\n\t\tif vsphereVersion != \"\" {\n\t\t\tuaAppend(\" MinIO/vsphere-plugin-\", vsphereVersion)\n\t\t}\n\t}\n\n\tif IsPCFTile() {\n\t\tpcfTileVersion := env.Get(\"MINIO_PCF_TILE_VERSION\", \"\")\n\t\tif pcfTileVersion != \"\" {\n\t\t\tuaAppend(\" MinIO/pcf-tile-\", pcfTileVersion)\n\t\t}\n\t}\n\n\treturn strings.Join(userAgentParts, \"\")\n}\n\nfunc downloadReleaseURL(u *url.URL, timeout time.Duration, mode string) (content string, err error) {\n\tvar reader io.ReadCloser\n\tif u.Scheme == \"https\" || u.Scheme == \"http\" {\n\t\treq, err := http.NewRequest(http.MethodGet, u.String(), nil)\n\t\tif err != nil {\n\t\t\treturn content, AdminError{\n\t\t\t\tCode:       AdminUpdateUnexpectedFailure,\n\t\t\t\tMessage:    err.Error(),\n\t\t\t\tStatusCode: http.StatusInternalServerError,\n\t\t\t}\n\t\t}\n\t\treq.Header.Set(\"User-Agent\", getUserAgent(mode))\n\n\t\tclient := &http.Client{Transport: getUpdateTransport(timeout)}\n\t\tresp, err := client.Do(req)\n\t\tif err != nil {\n\t\t\tif xnet.IsNetworkOrHostDown(err, false) {\n\t\t\t\treturn content, AdminError{\n\t\t\t\t\tCode:       AdminUpdateURLNotReachable,\n\t\t\t\t\tMessage:    err.Error(),\n\t\t\t\t\tStatusCode: http.StatusServiceUnavailable,\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn content, AdminError{\n\t\t\t\tCode:       AdminUpdateUnexpectedFailure,\n\t\t\t\tMessage:    err.Error(),\n\t\t\t\tStatusCode: http.StatusInternalServerError,\n\t\t\t}\n\t\t}\n\t\tif resp == nil {\n\t\t\treturn content, AdminError{\n\t\t\t\tCode:       AdminUpdateUnexpectedFailure,\n\t\t\t\tMessage:    fmt.Sprintf(\"No response from server to download URL %s\", u),\n\t\t\t\tStatusCode: http.StatusInternalServerError,\n\t\t\t}\n\t\t}\n\t\treader = resp.Body\n\t\tdefer xhttp.DrainBody(resp.Body)\n\n\t\tif resp.StatusCode != http.StatusOK {\n\t\t\treturn content, AdminError{\n\t\t\t\tCode:       AdminUpdateUnexpectedFailure,\n\t\t\t\tMessage:    fmt.Sprintf(\"Error downloading URL %s. Response: %v\", u, resp.Status),\n\t\t\t\tStatusCode: resp.StatusCode,\n\t\t\t}\n\t\t}\n\t} else {\n\t\treader, err = os.Open(u.Path)\n\t\tif err != nil {\n\t\t\treturn content, AdminError{\n\t\t\t\tCode:       AdminUpdateURLNotReachable,\n\t\t\t\tMessage:    err.Error(),\n\t\t\t\tStatusCode: http.StatusServiceUnavailable,\n\t\t\t}\n\t\t}\n\t}\n\n\tcontentBytes, err := ioutil.ReadAll(reader)\n\tif err != nil {\n\t\treturn content, AdminError{\n\t\t\tCode:       AdminUpdateUnexpectedFailure,\n\t\t\tMessage:    fmt.Sprintf(\"Error reading response. %s\", err),\n\t\t\tStatusCode: http.StatusInternalServerError,\n\t\t}\n\t}\n\n\treturn string(contentBytes), nil\n}\n\n// parseReleaseData - parses release info file content fetched from\n// official minio download server.\n//\n// The expected format is a single line with two words like:\n//\n// fbe246edbd382902db9a4035df7dce8cb441357d minio.RELEASE.2016-10-07T01-16-39Z.<hotfix_optional>\n//\n// The second word must be `minio.` appended to a standard release tag.\nfunc parseReleaseData(data string) (sha256Sum []byte, releaseTime time.Time, releaseInfo string, err error) {\n\tdefer func() {\n\t\tif err != nil {\n\t\t\terr = AdminError{\n\t\t\t\tCode:       AdminUpdateUnexpectedFailure,\n\t\t\t\tMessage:    err.Error(),\n\t\t\t\tStatusCode: http.StatusInternalServerError,\n\t\t\t}\n\t\t}\n\t}()\n\n\tfields := strings.Fields(data)\n\tif len(fields) != 2 {\n\t\terr = fmt.Errorf(\"Unknown release data `%s`\", data)\n\t\treturn sha256Sum, releaseTime, releaseInfo, err\n\t}\n\n\tsha256Sum, err = hex.DecodeString(fields[0])\n\tif err != nil {\n\t\treturn sha256Sum, releaseTime, releaseInfo, err\n\t}\n\n\treleaseInfo = fields[1]\n\n\t// Split release of style minio.RELEASE.2019-08-21T19-40-07Z.<hotfix>\n\tnfields := strings.SplitN(releaseInfo, \".\", 2)\n\tif len(nfields) != 2 {\n\t\terr = fmt.Errorf(\"Unknown release information `%s`\", releaseInfo)\n\t\treturn sha256Sum, releaseTime, releaseInfo, err\n\t}\n\tif nfields[0] != \"minio\" {\n\t\terr = fmt.Errorf(\"Unknown release `%s`\", releaseInfo)\n\t\treturn sha256Sum, releaseTime, releaseInfo, err\n\t}\n\n\treleaseTime, err = releaseTagToReleaseTime(nfields[1])\n\tif err != nil {\n\t\terr = fmt.Errorf(\"Unknown release tag format. %w\", err)\n\t}\n\n\treturn sha256Sum, releaseTime, releaseInfo, err\n}\n\nfunc getUpdateTransport(timeout time.Duration) http.RoundTripper {\n\tvar updateTransport http.RoundTripper = &http.Transport{\n\t\tProxy:                 http.ProxyFromEnvironment,\n\t\tDialContext:           xhttp.NewCustomDialContext(timeout),\n\t\tIdleConnTimeout:       timeout,\n\t\tTLSHandshakeTimeout:   timeout,\n\t\tExpectContinueTimeout: timeout,\n\t\tTLSClientConfig: &tls.Config{\n\t\t\tRootCAs:            globalRootCAs,\n\t\t\tClientSessionCache: tls.NewLRUClientSessionCache(tlsClientSessionCacheSize),\n\t\t},\n\t\tDisableCompression: true,\n\t}\n\treturn updateTransport\n}\n\nfunc getLatestReleaseTime(u *url.URL, timeout time.Duration, mode string) (sha256Sum []byte, releaseTime time.Time, err error) {\n\tdata, err := downloadReleaseURL(u, timeout, mode)\n\tif err != nil {\n\t\treturn sha256Sum, releaseTime, err\n\t}\n\n\tsha256Sum, releaseTime, _, err = parseReleaseData(data)\n\treturn\n}\n\nconst (\n\t// Kubernetes deployment doc link.\n\tkubernetesDeploymentDoc = \"https://docs.min.io/docs/deploy-minio-on-kubernetes\"\n\n\t// Mesos deployment doc link.\n\tmesosDeploymentDoc = \"https://docs.min.io/docs/deploy-minio-on-dc-os\"\n)\n\nfunc getDownloadURL(releaseTag string) (downloadURL string) {\n\t// Check if we are in DCOS environment, return\n\t// deployment guide for update procedures.\n\tif IsDCOS() {\n\t\treturn mesosDeploymentDoc\n\t}\n\n\t// Check if we are in kubernetes environment, return\n\t// deployment guide for update procedures.\n\tif IsKubernetes() {\n\t\treturn kubernetesDeploymentDoc\n\t}\n\n\t// Check if we are docker environment, return docker update command\n\tif IsDocker() {\n\t\t// Construct release tag name.\n\t\treturn fmt.Sprintf(\"podman pull quay.io/minio/minio:%s\", releaseTag)\n\t}\n\n\t// For binary only installations, we return link to the latest binary.\n\tif runtime.GOOS == \"windows\" {\n\t\treturn minioReleaseURL + \"minio.exe\"\n\t}\n\n\treturn minioReleaseURL + \"minio\"\n}\n\nfunc getUpdateReaderFromFile(u *url.URL) (io.ReadCloser, error) {\n\tr, err := os.Open(u.Path)\n\tif err != nil {\n\t\treturn nil, AdminError{\n\t\t\tCode:       AdminUpdateUnexpectedFailure,\n\t\t\tMessage:    err.Error(),\n\t\t\tStatusCode: http.StatusInternalServerError,\n\t\t}\n\t}\n\treturn r, nil\n}\n\nfunc getUpdateReaderFromURL(u *url.URL, transport http.RoundTripper, mode string) (io.ReadCloser, error) {\n\tclnt := &http.Client{\n\t\tTransport: transport,\n\t}\n\treq, err := http.NewRequest(http.MethodGet, u.String(), nil)\n\tif err != nil {\n\t\treturn nil, AdminError{\n\t\t\tCode:       AdminUpdateUnexpectedFailure,\n\t\t\tMessage:    err.Error(),\n\t\t\tStatusCode: http.StatusInternalServerError,\n\t\t}\n\t}\n\n\treq.Header.Set(\"User-Agent\", getUserAgent(mode))\n\n\tresp, err := clnt.Do(req)\n\tif err != nil {\n\t\tif xnet.IsNetworkOrHostDown(err, false) {\n\t\t\treturn nil, AdminError{\n\t\t\t\tCode:       AdminUpdateURLNotReachable,\n\t\t\t\tMessage:    err.Error(),\n\t\t\t\tStatusCode: http.StatusServiceUnavailable,\n\t\t\t}\n\t\t}\n\t\treturn nil, AdminError{\n\t\t\tCode:       AdminUpdateUnexpectedFailure,\n\t\t\tMessage:    err.Error(),\n\t\t\tStatusCode: http.StatusInternalServerError,\n\t\t}\n\t}\n\treturn resp.Body, nil\n}\n\nvar updateInProgress uint32\n\nfunc downloadBinary(u *url.URL, sha256Sum []byte, releaseInfo string, mode string) (err error) {\n\tif !atomic.CompareAndSwapUint32(&updateInProgress, 0, 1) {\n\t\treturn errors.New(\"update already in progress\")\n\t}\n\tdefer atomic.StoreUint32(&updateInProgress, 0)\n\n\ttransport := getUpdateTransport(30 * time.Second)\n\tvar reader io.ReadCloser\n\tif u.Scheme == \"https\" || u.Scheme == \"http\" {\n\t\treader, err = getUpdateReaderFromURL(u, transport, mode)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\treader, err = getUpdateReaderFromFile(u)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\topts := selfupdate.Options{\n\t\tHash:     crypto.SHA256,\n\t\tChecksum: sha256Sum,\n\t}\n\n\tif err := opts.CheckPermissions(); err != nil {\n\t\treturn AdminError{\n\t\t\tCode:       AdminUpdateApplyFailure,\n\t\t\tMessage:    fmt.Sprintf(\"server update failed with: %s, do not restart the servers yet\", err),\n\t\t\tStatusCode: http.StatusInternalServerError,\n\t\t}\n\t}\n\n\tminisignPubkey := env.Get(envMinisignPubKey, \"\")\n\tif minisignPubkey != \"\" {\n\t\tv := selfupdate.NewVerifier()\n\t\tu.Path = path.Dir(u.Path) + slashSeparator + releaseInfo + \".minisig\"\n\t\tif err = v.LoadFromURL(u.String(), minisignPubkey, transport); err != nil {\n\t\t\treturn AdminError{\n\t\t\t\tCode:       AdminUpdateApplyFailure,\n\t\t\t\tMessage:    fmt.Sprintf(\"signature loading failed for %v with %v\", u, err),\n\t\t\t\tStatusCode: http.StatusInternalServerError,\n\t\t\t}\n\t\t}\n\t\topts.Verifier = v\n\t}\n\n\tif err = selfupdate.PrepareAndCheckBinary(reader, opts); err != nil {\n\t\tvar pathErr *os.PathError\n\t\tif errors.As(err, &pathErr) {\n\t\t\treturn AdminError{\n\t\t\t\tCode: AdminUpdateApplyFailure,\n\t\t\t\tMessage: fmt.Sprintf(\"Unable to update the binary at %s: %v\",\n\t\t\t\t\tfilepath.Dir(pathErr.Path), pathErr.Err),\n\t\t\t\tStatusCode: http.StatusForbidden,\n\t\t\t}\n\t\t}\n\t\treturn AdminError{\n\t\t\tCode:       AdminUpdateApplyFailure,\n\t\t\tMessage:    err.Error(),\n\t\t\tStatusCode: http.StatusInternalServerError,\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc commitBinary() (err error) {\n\tif !atomic.CompareAndSwapUint32(&updateInProgress, 0, 1) {\n\t\treturn errors.New(\"update already in progress\")\n\t}\n\tdefer atomic.StoreUint32(&updateInProgress, 0)\n\n\topts := selfupdate.Options{}\n\n\tif err = selfupdate.CommitBinary(opts); err != nil {\n\t\tif rerr := selfupdate.RollbackError(err); rerr != nil {\n\t\t\treturn AdminError{\n\t\t\t\tCode:       AdminUpdateApplyFailure,\n\t\t\t\tMessage:    fmt.Sprintf(\"Failed to rollback from bad update: %v\", rerr),\n\t\t\t\tStatusCode: http.StatusInternalServerError,\n\t\t\t}\n\t\t}\n\t\tvar pathErr *os.PathError\n\t\tif errors.As(err, &pathErr) {\n\t\t\treturn AdminError{\n\t\t\t\tCode: AdminUpdateApplyFailure,\n\t\t\t\tMessage: fmt.Sprintf(\"Unable to update the binary at %s: %v\",\n\t\t\t\t\tfilepath.Dir(pathErr.Path), pathErr.Err),\n\t\t\t\tStatusCode: http.StatusForbidden,\n\t\t\t}\n\t\t}\n\t\treturn AdminError{\n\t\t\tCode:       AdminUpdateApplyFailure,\n\t\t\tMessage:    err.Error(),\n\t\t\tStatusCode: http.StatusInternalServerError,\n\t\t}\n\t}\n\n\treturn nil\n}\n"], "fixing_code": ["// Copyright (c) 2015-2021 MinIO, Inc.\n//\n// This file is part of MinIO Object Storage stack\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npackage cmd\n\nimport (\n\t\"bufio\"\n\t\"crypto\"\n\t\"crypto/tls\"\n\t\"encoding/hex\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strings\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\txhttp \"github.com/minio/minio/internal/http\"\n\t\"github.com/minio/minio/internal/logger\"\n\t\"github.com/minio/pkg/env\"\n\txnet \"github.com/minio/pkg/net\"\n\t\"github.com/minio/selfupdate\"\n)\n\nconst (\n\tminioReleaseTagTimeLayout = \"2006-01-02T15-04-05Z\"\n\tminioOSARCH               = runtime.GOOS + \"-\" + runtime.GOARCH\n\tminioReleaseURL           = \"https://dl.min.io/server/minio/release/\" + minioOSARCH + SlashSeparator\n\n\tenvMinisignPubKey = \"MINIO_UPDATE_MINISIGN_PUBKEY\"\n\tupdateTimeout     = 10 * time.Second\n)\n\n// For windows our files have .exe additionally.\nvar minioReleaseWindowsInfoURL = minioReleaseURL + \"minio.exe.sha256sum\"\n\n// minioVersionToReleaseTime - parses a standard official release\n// MinIO version string.\n//\n// An official binary's version string is the release time formatted\n// with RFC3339 (in UTC) - e.g. `2017-09-29T19:16:56Z`\nfunc minioVersionToReleaseTime(version string) (releaseTime time.Time, err error) {\n\treturn time.Parse(time.RFC3339, version)\n}\n\n// releaseTimeToReleaseTag - converts a time to a string formatted as\n// an official MinIO release tag.\n//\n// An official minio release tag looks like:\n// `RELEASE.2017-09-29T19-16-56Z`\nfunc releaseTimeToReleaseTag(releaseTime time.Time) string {\n\treturn \"RELEASE.\" + releaseTime.Format(minioReleaseTagTimeLayout)\n}\n\n// releaseTagToReleaseTime - reverse of `releaseTimeToReleaseTag()`\nfunc releaseTagToReleaseTime(releaseTag string) (releaseTime time.Time, err error) {\n\tfields := strings.Split(releaseTag, \".\")\n\tif len(fields) < 2 || len(fields) > 4 {\n\t\treturn releaseTime, fmt.Errorf(\"%s is not a valid release tag\", releaseTag)\n\t}\n\tif fields[0] != \"RELEASE\" {\n\t\treturn releaseTime, fmt.Errorf(\"%s is not a valid release tag\", releaseTag)\n\t}\n\treturn time.Parse(minioReleaseTagTimeLayout, fields[1])\n}\n\n// getModTime - get the file modification time of `path`\nfunc getModTime(path string) (t time.Time, err error) {\n\t// Convert to absolute path\n\tabsPath, err := filepath.Abs(path)\n\tif err != nil {\n\t\treturn t, fmt.Errorf(\"Unable to get absolute path of %s. %w\", path, err)\n\t}\n\n\t// Version is minio non-standard, we will use minio binary's\n\t// ModTime as release time.\n\tfi, err := Stat(absPath)\n\tif err != nil {\n\t\treturn t, fmt.Errorf(\"Unable to get ModTime of %s. %w\", absPath, err)\n\t}\n\n\t// Return the ModTime\n\treturn fi.ModTime().UTC(), nil\n}\n\n// GetCurrentReleaseTime - returns this process's release time.  If it\n// is official minio version, parsed version is returned else minio\n// binary's mod time is returned.\nfunc GetCurrentReleaseTime() (releaseTime time.Time, err error) {\n\tif releaseTime, err = minioVersionToReleaseTime(Version); err == nil {\n\t\treturn releaseTime, err\n\t}\n\n\t// Looks like version is minio non-standard, we use minio\n\t// binary's ModTime as release time:\n\treturn getModTime(os.Args[0])\n}\n\n// IsDocker - returns if the environment minio is running in docker or\n// not. The check is a simple file existence check.\n//\n// https://github.com/moby/moby/blob/master/daemon/initlayer/setup_unix.go#L25\n//\n//     \"/.dockerenv\":      \"file\",\n//\nfunc IsDocker() bool {\n\tif !globalIsCICD {\n\t\t_, err := os.Stat(\"/.dockerenv\")\n\t\tif osIsNotExist(err) {\n\t\t\treturn false\n\t\t}\n\n\t\t// Log error, as we will not propagate it to caller\n\t\tlogger.LogIf(GlobalContext, err)\n\n\t\treturn err == nil\n\t}\n\treturn false\n}\n\n// IsDCOS returns true if minio is running in DCOS.\nfunc IsDCOS() bool {\n\tif !globalIsCICD {\n\t\t// http://mesos.apache.org/documentation/latest/docker-containerizer/\n\t\t// Mesos docker containerizer sets this value\n\t\treturn env.Get(\"MESOS_CONTAINER_NAME\", \"\") != \"\"\n\t}\n\treturn false\n}\n\n// IsKubernetes returns true if minio is running in kubernetes.\nfunc IsKubernetes() bool {\n\tif !globalIsCICD {\n\t\t// Kubernetes env used to validate if we are\n\t\t// indeed running inside a kubernetes pod\n\t\t// is KUBERNETES_SERVICE_HOST\n\t\t// https://github.com/kubernetes/kubernetes/blob/master/pkg/kubelet/kubelet_pods.go#L541\n\t\treturn env.Get(\"KUBERNETES_SERVICE_HOST\", \"\") != \"\"\n\t}\n\treturn false\n}\n\n// IsBOSH returns true if minio is deployed from a bosh package\nfunc IsBOSH() bool {\n\t// \"/var/vcap/bosh\" exists in BOSH deployed instance.\n\t_, err := os.Stat(\"/var/vcap/bosh\")\n\tif osIsNotExist(err) {\n\t\treturn false\n\t}\n\n\t// Log error, as we will not propagate it to caller\n\tlogger.LogIf(GlobalContext, err)\n\n\treturn err == nil\n}\n\n// MinIO Helm chart uses DownwardAPIFile to write pod label info to /podinfo/labels\n// More info: https://kubernetes.io/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/#store-pod-fields\n// Check if this is Helm package installation and report helm chart version\nfunc getHelmVersion(helmInfoFilePath string) string {\n\t// Read the file exists.\n\thelmInfoFile, err := os.Open(helmInfoFilePath)\n\tif err != nil {\n\t\t// Log errors and return \"\" as MinIO can be deployed\n\t\t// without Helm charts as well.\n\t\tif !osIsNotExist(err) {\n\t\t\treqInfo := (&logger.ReqInfo{}).AppendTags(\"helmInfoFilePath\", helmInfoFilePath)\n\t\t\tctx := logger.SetReqInfo(GlobalContext, reqInfo)\n\t\t\tlogger.LogIf(ctx, err)\n\t\t}\n\t\treturn \"\"\n\t}\n\n\tscanner := bufio.NewScanner(helmInfoFile)\n\tfor scanner.Scan() {\n\t\tif strings.Contains(scanner.Text(), \"chart=\") {\n\t\t\thelmChartVersion := strings.TrimPrefix(scanner.Text(), \"chart=\")\n\t\t\t// remove quotes from the chart version\n\t\t\treturn strings.Trim(helmChartVersion, `\"`)\n\t\t}\n\t}\n\n\treturn \"\"\n}\n\n// IsSourceBuild - returns if this binary is a non-official build from\n// source code.\nfunc IsSourceBuild() bool {\n\t_, err := minioVersionToReleaseTime(Version)\n\treturn err != nil\n}\n\n// IsPCFTile returns if server is running in PCF\nfunc IsPCFTile() bool {\n\treturn env.Get(\"MINIO_PCF_TILE_VERSION\", \"\") != \"\"\n}\n\n// DO NOT CHANGE USER AGENT STYLE.\n// The style should be\n//\n//   MinIO (<OS>; <ARCH>[; <MODE>][; dcos][; kubernetes][; docker][; source]) MinIO/<VERSION> MinIO/<RELEASE-TAG> MinIO/<COMMIT-ID> [MinIO/universe-<PACKAGE-NAME>] [MinIO/helm-<HELM-VERSION>]\n//\n// Any change here should be discussed by opening an issue at\n// https://github.com/minio/minio/issues.\nfunc getUserAgent(mode string) string {\n\tuserAgentParts := []string{}\n\t// Helper function to concisely append a pair of strings to a\n\t// the user-agent slice.\n\tuaAppend := func(p, q string) {\n\t\tuserAgentParts = append(userAgentParts, p, q)\n\t}\n\n\tuaAppend(\"MinIO (\", runtime.GOOS)\n\tuaAppend(\"; \", runtime.GOARCH)\n\tif mode != \"\" {\n\t\tuaAppend(\"; \", mode)\n\t}\n\tif IsDCOS() {\n\t\tuaAppend(\"; \", \"dcos\")\n\t}\n\tif IsKubernetes() {\n\t\tuaAppend(\"; \", \"kubernetes\")\n\t}\n\tif IsDocker() {\n\t\tuaAppend(\"; \", \"docker\")\n\t}\n\tif IsBOSH() {\n\t\tuaAppend(\"; \", \"bosh\")\n\t}\n\tif IsSourceBuild() {\n\t\tuaAppend(\"; \", \"source\")\n\t}\n\n\tuaAppend(\") MinIO/\", Version)\n\tuaAppend(\" MinIO/\", ReleaseTag)\n\tuaAppend(\" MinIO/\", CommitID)\n\tif IsDCOS() {\n\t\tuniversePkgVersion := env.Get(\"MARATHON_APP_LABEL_DCOS_PACKAGE_VERSION\", \"\")\n\t\t// On DC/OS environment try to the get universe package version.\n\t\tif universePkgVersion != \"\" {\n\t\t\tuaAppend(\" MinIO/universe-\", universePkgVersion)\n\t\t}\n\t}\n\n\tif IsKubernetes() {\n\t\t// In Kubernetes environment, try to fetch the helm package version\n\t\thelmChartVersion := getHelmVersion(\"/podinfo/labels\")\n\t\tif helmChartVersion != \"\" {\n\t\t\tuaAppend(\" MinIO/helm-\", helmChartVersion)\n\t\t}\n\t\t// In Kubernetes environment, try to fetch the Operator, VSPHERE plugin version\n\t\topVersion := env.Get(\"MINIO_OPERATOR_VERSION\", \"\")\n\t\tif opVersion != \"\" {\n\t\t\tuaAppend(\" MinIO/operator-\", opVersion)\n\t\t}\n\t\tvsphereVersion := env.Get(\"MINIO_VSPHERE_PLUGIN_VERSION\", \"\")\n\t\tif vsphereVersion != \"\" {\n\t\t\tuaAppend(\" MinIO/vsphere-plugin-\", vsphereVersion)\n\t\t}\n\t}\n\n\tif IsPCFTile() {\n\t\tpcfTileVersion := env.Get(\"MINIO_PCF_TILE_VERSION\", \"\")\n\t\tif pcfTileVersion != \"\" {\n\t\t\tuaAppend(\" MinIO/pcf-tile-\", pcfTileVersion)\n\t\t}\n\t}\n\n\treturn strings.Join(userAgentParts, \"\")\n}\n\nfunc downloadReleaseURL(u *url.URL, timeout time.Duration, mode string) (content string, err error) {\n\treq, err := http.NewRequest(http.MethodGet, u.String(), nil)\n\tif err != nil {\n\t\treturn content, AdminError{\n\t\t\tCode:       AdminUpdateUnexpectedFailure,\n\t\t\tMessage:    err.Error(),\n\t\t\tStatusCode: http.StatusInternalServerError,\n\t\t}\n\t}\n\treq.Header.Set(\"User-Agent\", getUserAgent(mode))\n\n\tclient := &http.Client{Transport: getUpdateTransport(timeout)}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\tif xnet.IsNetworkOrHostDown(err, false) {\n\t\t\treturn content, AdminError{\n\t\t\t\tCode:       AdminUpdateURLNotReachable,\n\t\t\t\tMessage:    err.Error(),\n\t\t\t\tStatusCode: http.StatusServiceUnavailable,\n\t\t\t}\n\t\t}\n\t\treturn content, AdminError{\n\t\t\tCode:       AdminUpdateUnexpectedFailure,\n\t\t\tMessage:    err.Error(),\n\t\t\tStatusCode: http.StatusInternalServerError,\n\t\t}\n\t}\n\tif resp == nil {\n\t\treturn content, AdminError{\n\t\t\tCode:       AdminUpdateUnexpectedFailure,\n\t\t\tMessage:    fmt.Sprintf(\"No response from server to download URL %s\", u),\n\t\t\tStatusCode: http.StatusInternalServerError,\n\t\t}\n\t}\n\tdefer xhttp.DrainBody(resp.Body)\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn content, AdminError{\n\t\t\tCode:       AdminUpdateUnexpectedFailure,\n\t\t\tMessage:    fmt.Sprintf(\"Error downloading URL %s. Response: %v\", u, resp.Status),\n\t\t\tStatusCode: resp.StatusCode,\n\t\t}\n\t}\n\n\tcontentBytes, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn content, AdminError{\n\t\t\tCode:       AdminUpdateUnexpectedFailure,\n\t\t\tMessage:    fmt.Sprintf(\"Error reading response. %s\", err),\n\t\t\tStatusCode: http.StatusInternalServerError,\n\t\t}\n\t}\n\n\treturn string(contentBytes), nil\n}\n\n// parseReleaseData - parses release info file content fetched from\n// official minio download server.\n//\n// The expected format is a single line with two words like:\n//\n// fbe246edbd382902db9a4035df7dce8cb441357d minio.RELEASE.2016-10-07T01-16-39Z.<hotfix_optional>\n//\n// The second word must be `minio.` appended to a standard release tag.\nfunc parseReleaseData(data string) (sha256Sum []byte, releaseTime time.Time, releaseInfo string, err error) {\n\tdefer func() {\n\t\tif err != nil {\n\t\t\terr = AdminError{\n\t\t\t\tCode:       AdminUpdateUnexpectedFailure,\n\t\t\t\tMessage:    err.Error(),\n\t\t\t\tStatusCode: http.StatusInternalServerError,\n\t\t\t}\n\t\t}\n\t}()\n\n\tfields := strings.Fields(data)\n\tif len(fields) != 2 {\n\t\terr = fmt.Errorf(\"Unknown release data `%s`\", data)\n\t\treturn sha256Sum, releaseTime, releaseInfo, err\n\t}\n\n\tsha256Sum, err = hex.DecodeString(fields[0])\n\tif err != nil {\n\t\treturn sha256Sum, releaseTime, releaseInfo, err\n\t}\n\n\treleaseInfo = fields[1]\n\n\t// Split release of style minio.RELEASE.2019-08-21T19-40-07Z.<hotfix>\n\tnfields := strings.SplitN(releaseInfo, \".\", 2)\n\tif len(nfields) != 2 {\n\t\terr = fmt.Errorf(\"Unknown release information `%s`\", releaseInfo)\n\t\treturn sha256Sum, releaseTime, releaseInfo, err\n\t}\n\tif nfields[0] != \"minio\" {\n\t\terr = fmt.Errorf(\"Unknown release `%s`\", releaseInfo)\n\t\treturn sha256Sum, releaseTime, releaseInfo, err\n\t}\n\n\treleaseTime, err = releaseTagToReleaseTime(nfields[1])\n\tif err != nil {\n\t\terr = fmt.Errorf(\"Unknown release tag format. %w\", err)\n\t}\n\n\treturn sha256Sum, releaseTime, releaseInfo, err\n}\n\nfunc getUpdateTransport(timeout time.Duration) http.RoundTripper {\n\tvar updateTransport http.RoundTripper = &http.Transport{\n\t\tProxy:                 http.ProxyFromEnvironment,\n\t\tDialContext:           xhttp.NewCustomDialContext(timeout),\n\t\tIdleConnTimeout:       timeout,\n\t\tTLSHandshakeTimeout:   timeout,\n\t\tExpectContinueTimeout: timeout,\n\t\tTLSClientConfig: &tls.Config{\n\t\t\tRootCAs:            globalRootCAs,\n\t\t\tClientSessionCache: tls.NewLRUClientSessionCache(tlsClientSessionCacheSize),\n\t\t},\n\t\tDisableCompression: true,\n\t}\n\treturn updateTransport\n}\n\nfunc getLatestReleaseTime(u *url.URL, timeout time.Duration, mode string) (sha256Sum []byte, releaseTime time.Time, err error) {\n\tdata, err := downloadReleaseURL(u, timeout, mode)\n\tif err != nil {\n\t\treturn sha256Sum, releaseTime, err\n\t}\n\n\tsha256Sum, releaseTime, _, err = parseReleaseData(data)\n\treturn\n}\n\nconst (\n\t// Kubernetes deployment doc link.\n\tkubernetesDeploymentDoc = \"https://docs.min.io/docs/deploy-minio-on-kubernetes\"\n\n\t// Mesos deployment doc link.\n\tmesosDeploymentDoc = \"https://docs.min.io/docs/deploy-minio-on-dc-os\"\n)\n\nfunc getDownloadURL(releaseTag string) (downloadURL string) {\n\t// Check if we are in DCOS environment, return\n\t// deployment guide for update procedures.\n\tif IsDCOS() {\n\t\treturn mesosDeploymentDoc\n\t}\n\n\t// Check if we are in kubernetes environment, return\n\t// deployment guide for update procedures.\n\tif IsKubernetes() {\n\t\treturn kubernetesDeploymentDoc\n\t}\n\n\t// Check if we are docker environment, return docker update command\n\tif IsDocker() {\n\t\t// Construct release tag name.\n\t\treturn fmt.Sprintf(\"podman pull quay.io/minio/minio:%s\", releaseTag)\n\t}\n\n\t// For binary only installations, we return link to the latest binary.\n\tif runtime.GOOS == \"windows\" {\n\t\treturn minioReleaseURL + \"minio.exe\"\n\t}\n\n\treturn minioReleaseURL + \"minio\"\n}\n\nfunc getUpdateReaderFromFile(u *url.URL) (io.ReadCloser, error) {\n\tr, err := os.Open(u.Path)\n\tif err != nil {\n\t\treturn nil, AdminError{\n\t\t\tCode:       AdminUpdateUnexpectedFailure,\n\t\t\tMessage:    err.Error(),\n\t\t\tStatusCode: http.StatusInternalServerError,\n\t\t}\n\t}\n\treturn r, nil\n}\n\nfunc getUpdateReaderFromURL(u *url.URL, transport http.RoundTripper, mode string) (io.ReadCloser, error) {\n\tclnt := &http.Client{\n\t\tTransport: transport,\n\t}\n\treq, err := http.NewRequest(http.MethodGet, u.String(), nil)\n\tif err != nil {\n\t\treturn nil, AdminError{\n\t\t\tCode:       AdminUpdateUnexpectedFailure,\n\t\t\tMessage:    err.Error(),\n\t\t\tStatusCode: http.StatusInternalServerError,\n\t\t}\n\t}\n\n\treq.Header.Set(\"User-Agent\", getUserAgent(mode))\n\n\tresp, err := clnt.Do(req)\n\tif err != nil {\n\t\tif xnet.IsNetworkOrHostDown(err, false) {\n\t\t\treturn nil, AdminError{\n\t\t\t\tCode:       AdminUpdateURLNotReachable,\n\t\t\t\tMessage:    err.Error(),\n\t\t\t\tStatusCode: http.StatusServiceUnavailable,\n\t\t\t}\n\t\t}\n\t\treturn nil, AdminError{\n\t\t\tCode:       AdminUpdateUnexpectedFailure,\n\t\t\tMessage:    err.Error(),\n\t\t\tStatusCode: http.StatusInternalServerError,\n\t\t}\n\t}\n\treturn resp.Body, nil\n}\n\nvar updateInProgress uint32\n\nfunc downloadBinary(u *url.URL, sha256Sum []byte, releaseInfo string, mode string) (err error) {\n\tif !atomic.CompareAndSwapUint32(&updateInProgress, 0, 1) {\n\t\treturn errors.New(\"update already in progress\")\n\t}\n\tdefer atomic.StoreUint32(&updateInProgress, 0)\n\n\ttransport := getUpdateTransport(30 * time.Second)\n\tvar reader io.ReadCloser\n\tif u.Scheme == \"https\" || u.Scheme == \"http\" {\n\t\treader, err = getUpdateReaderFromURL(u, transport, mode)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\treader, err = getUpdateReaderFromFile(u)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\topts := selfupdate.Options{\n\t\tHash:     crypto.SHA256,\n\t\tChecksum: sha256Sum,\n\t}\n\n\tif err := opts.CheckPermissions(); err != nil {\n\t\treturn AdminError{\n\t\t\tCode:       AdminUpdateApplyFailure,\n\t\t\tMessage:    fmt.Sprintf(\"server update failed with: %s, do not restart the servers yet\", err),\n\t\t\tStatusCode: http.StatusInternalServerError,\n\t\t}\n\t}\n\n\tminisignPubkey := env.Get(envMinisignPubKey, \"\")\n\tif minisignPubkey != \"\" {\n\t\tv := selfupdate.NewVerifier()\n\t\tu.Path = path.Dir(u.Path) + slashSeparator + releaseInfo + \".minisig\"\n\t\tif err = v.LoadFromURL(u.String(), minisignPubkey, transport); err != nil {\n\t\t\treturn AdminError{\n\t\t\t\tCode:       AdminUpdateApplyFailure,\n\t\t\t\tMessage:    fmt.Sprintf(\"signature loading failed for %v with %v\", u, err),\n\t\t\t\tStatusCode: http.StatusInternalServerError,\n\t\t\t}\n\t\t}\n\t\topts.Verifier = v\n\t}\n\n\tif err = selfupdate.PrepareAndCheckBinary(reader, opts); err != nil {\n\t\tvar pathErr *os.PathError\n\t\tif errors.As(err, &pathErr) {\n\t\t\treturn AdminError{\n\t\t\t\tCode: AdminUpdateApplyFailure,\n\t\t\t\tMessage: fmt.Sprintf(\"Unable to update the binary at %s: %v\",\n\t\t\t\t\tfilepath.Dir(pathErr.Path), pathErr.Err),\n\t\t\t\tStatusCode: http.StatusForbidden,\n\t\t\t}\n\t\t}\n\t\treturn AdminError{\n\t\t\tCode:       AdminUpdateApplyFailure,\n\t\t\tMessage:    err.Error(),\n\t\t\tStatusCode: http.StatusInternalServerError,\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc commitBinary() (err error) {\n\tif !atomic.CompareAndSwapUint32(&updateInProgress, 0, 1) {\n\t\treturn errors.New(\"update already in progress\")\n\t}\n\tdefer atomic.StoreUint32(&updateInProgress, 0)\n\n\topts := selfupdate.Options{}\n\n\tif err = selfupdate.CommitBinary(opts); err != nil {\n\t\tif rerr := selfupdate.RollbackError(err); rerr != nil {\n\t\t\treturn AdminError{\n\t\t\t\tCode:       AdminUpdateApplyFailure,\n\t\t\t\tMessage:    fmt.Sprintf(\"Failed to rollback from bad update: %v\", rerr),\n\t\t\t\tStatusCode: http.StatusInternalServerError,\n\t\t\t}\n\t\t}\n\t\tvar pathErr *os.PathError\n\t\tif errors.As(err, &pathErr) {\n\t\t\treturn AdminError{\n\t\t\t\tCode: AdminUpdateApplyFailure,\n\t\t\t\tMessage: fmt.Sprintf(\"Unable to update the binary at %s: %v\",\n\t\t\t\t\tfilepath.Dir(pathErr.Path), pathErr.Err),\n\t\t\t\tStatusCode: http.StatusForbidden,\n\t\t\t}\n\t\t}\n\t\treturn AdminError{\n\t\t\tCode:       AdminUpdateApplyFailure,\n\t\t\tMessage:    err.Error(),\n\t\t\tStatusCode: http.StatusInternalServerError,\n\t\t}\n\t}\n\n\treturn nil\n}\n"], "filenames": ["cmd/update.go"], "buggy_code_start_loc": [294], "buggy_code_end_loc": [351], "fixing_code_start_loc": [294], "fixing_code_end_loc": [338], "type": "CWE-22", "message": "MinIO is a High Performance Object Storage released under GNU Affero General Public License v3.0. In affected versions all 'admin' users authorized for `admin:ServerUpdate` can selectively trigger an error that in response, returns the content of the path requested. Any normal OS system would allow access to contents at any arbitrary paths that are readable by MinIO process. Users are advised to upgrade. Users unable to upgrade may disable ServerUpdate API by denying the `admin:ServerUpdate` action for your admin users via IAM policies.", "other": {"cve": {"id": "CVE-2022-35919", "sourceIdentifier": "security-advisories@github.com", "published": "2022-08-01T22:15:10.280", "lastModified": "2022-08-10T16:24:04.247", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "MinIO is a High Performance Object Storage released under GNU Affero General Public License v3.0. In affected versions all 'admin' users authorized for `admin:ServerUpdate` can selectively trigger an error that in response, returns the content of the path requested. Any normal OS system would allow access to contents at any arbitrary paths that are readable by MinIO process. Users are advised to upgrade. Users unable to upgrade may disable ServerUpdate API by denying the `admin:ServerUpdate` action for your admin users via IAM policies."}, {"lang": "es", "value": "MinIO es un almacenamiento de objetos de alto rendimiento publicado bajo la licencia p\u00fablica general Affero de GNU versi\u00f3n v3.0. En versiones afectadas, todos los usuarios \"admin\" autorizados para \"admin:ServerUpdate\" pueden provocar selectivamente un error que, en respuesta, devuelva el contenido de la ruta solicitada. Cualquier sistema operativo normal permitir\u00eda el acceso a contenidos en cualquier ruta arbitraria que sea legible por el proceso MinIO. Es recomendado a usuarios actualizar. Los usuarios que no puedan actualizar pueden deshabilitar la API ServerUpdate denegando la acci\u00f3n \"admin:ServerUpdate\" para sus usuarios administradores por medio de pol\u00edticas IAM"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.7, "baseSeverity": "LOW"}, "exploitabilityScore": 1.2, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 7.4, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.1, "impactScore": 3.7}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:minio:minio:*:*:*:*:*:*:*:*", "versionEndExcluding": "2022-07-29t19-40-48z", "matchCriteriaId": "43154FF8-4DBD-4414-9B01-6F05392A3AFD"}]}]}], "references": [{"url": "https://github.com/minio/minio/commit/bc72e4226e669d98c8e0f3eccc9297be9251c692", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/minio/minio/pull/15429", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/minio/minio/security/advisories/GHSA-gr9v-6pcm-rqvg", "source": "security-advisories@github.com", "tags": ["Exploit", "Mitigation", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/minio/minio/commit/bc72e4226e669d98c8e0f3eccc9297be9251c692"}}