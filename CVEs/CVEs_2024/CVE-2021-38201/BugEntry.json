{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n * linux/net/sunrpc/xdr.c\n *\n * Generic XDR support.\n *\n * Copyright (C) 1995, 1996 Olaf Kirch <okir@monad.swb.de>\n */\n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/pagemap.h>\n#include <linux/errno.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/sunrpc/msg_prot.h>\n#include <linux/bvec.h>\n#include <trace/events/sunrpc.h>\n\nstatic void _copy_to_pages(struct page **, size_t, const char *, size_t);\n\n\n/*\n * XDR functions for basic NFS types\n */\n__be32 *\nxdr_encode_netobj(__be32 *p, const struct xdr_netobj *obj)\n{\n\tunsigned int\tquadlen = XDR_QUADLEN(obj->len);\n\n\tp[quadlen] = 0;\t\t/* zero trailing bytes */\n\t*p++ = cpu_to_be32(obj->len);\n\tmemcpy(p, obj->data, obj->len);\n\treturn p + XDR_QUADLEN(obj->len);\n}\nEXPORT_SYMBOL_GPL(xdr_encode_netobj);\n\n__be32 *\nxdr_decode_netobj(__be32 *p, struct xdr_netobj *obj)\n{\n\tunsigned int\tlen;\n\n\tif ((len = be32_to_cpu(*p++)) > XDR_MAX_NETOBJ)\n\t\treturn NULL;\n\tobj->len  = len;\n\tobj->data = (u8 *) p;\n\treturn p + XDR_QUADLEN(len);\n}\nEXPORT_SYMBOL_GPL(xdr_decode_netobj);\n\n/**\n * xdr_encode_opaque_fixed - Encode fixed length opaque data\n * @p: pointer to current position in XDR buffer.\n * @ptr: pointer to data to encode (or NULL)\n * @nbytes: size of data.\n *\n * Copy the array of data of length nbytes at ptr to the XDR buffer\n * at position p, then align to the next 32-bit boundary by padding\n * with zero bytes (see RFC1832).\n * Note: if ptr is NULL, only the padding is performed.\n *\n * Returns the updated current XDR buffer position\n *\n */\n__be32 *xdr_encode_opaque_fixed(__be32 *p, const void *ptr, unsigned int nbytes)\n{\n\tif (likely(nbytes != 0)) {\n\t\tunsigned int quadlen = XDR_QUADLEN(nbytes);\n\t\tunsigned int padding = (quadlen << 2) - nbytes;\n\n\t\tif (ptr != NULL)\n\t\t\tmemcpy(p, ptr, nbytes);\n\t\tif (padding != 0)\n\t\t\tmemset((char *)p + nbytes, 0, padding);\n\t\tp += quadlen;\n\t}\n\treturn p;\n}\nEXPORT_SYMBOL_GPL(xdr_encode_opaque_fixed);\n\n/**\n * xdr_encode_opaque - Encode variable length opaque data\n * @p: pointer to current position in XDR buffer.\n * @ptr: pointer to data to encode (or NULL)\n * @nbytes: size of data.\n *\n * Returns the updated current XDR buffer position\n */\n__be32 *xdr_encode_opaque(__be32 *p, const void *ptr, unsigned int nbytes)\n{\n\t*p++ = cpu_to_be32(nbytes);\n\treturn xdr_encode_opaque_fixed(p, ptr, nbytes);\n}\nEXPORT_SYMBOL_GPL(xdr_encode_opaque);\n\n__be32 *\nxdr_encode_string(__be32 *p, const char *string)\n{\n\treturn xdr_encode_array(p, string, strlen(string));\n}\nEXPORT_SYMBOL_GPL(xdr_encode_string);\n\n__be32 *\nxdr_decode_string_inplace(__be32 *p, char **sp,\n\t\t\t  unsigned int *lenp, unsigned int maxlen)\n{\n\tu32 len;\n\n\tlen = be32_to_cpu(*p++);\n\tif (len > maxlen)\n\t\treturn NULL;\n\t*lenp = len;\n\t*sp = (char *) p;\n\treturn p + XDR_QUADLEN(len);\n}\nEXPORT_SYMBOL_GPL(xdr_decode_string_inplace);\n\n/**\n * xdr_terminate_string - '\\0'-terminate a string residing in an xdr_buf\n * @buf: XDR buffer where string resides\n * @len: length of string, in bytes\n *\n */\nvoid xdr_terminate_string(const struct xdr_buf *buf, const u32 len)\n{\n\tchar *kaddr;\n\n\tkaddr = kmap_atomic(buf->pages[0]);\n\tkaddr[buf->page_base + len] = '\\0';\n\tkunmap_atomic(kaddr);\n}\nEXPORT_SYMBOL_GPL(xdr_terminate_string);\n\nsize_t xdr_buf_pagecount(const struct xdr_buf *buf)\n{\n\tif (!buf->page_len)\n\t\treturn 0;\n\treturn (buf->page_base + buf->page_len + PAGE_SIZE - 1) >> PAGE_SHIFT;\n}\n\nint\nxdr_alloc_bvec(struct xdr_buf *buf, gfp_t gfp)\n{\n\tsize_t i, n = xdr_buf_pagecount(buf);\n\n\tif (n != 0 && buf->bvec == NULL) {\n\t\tbuf->bvec = kmalloc_array(n, sizeof(buf->bvec[0]), gfp);\n\t\tif (!buf->bvec)\n\t\t\treturn -ENOMEM;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tbuf->bvec[i].bv_page = buf->pages[i];\n\t\t\tbuf->bvec[i].bv_len = PAGE_SIZE;\n\t\t\tbuf->bvec[i].bv_offset = 0;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid\nxdr_free_bvec(struct xdr_buf *buf)\n{\n\tkfree(buf->bvec);\n\tbuf->bvec = NULL;\n}\n\n/**\n * xdr_inline_pages - Prepare receive buffer for a large reply\n * @xdr: xdr_buf into which reply will be placed\n * @offset: expected offset where data payload will start, in bytes\n * @pages: vector of struct page pointers\n * @base: offset in first page where receive should start, in bytes\n * @len: expected size of the upper layer data payload, in bytes\n *\n */\nvoid\nxdr_inline_pages(struct xdr_buf *xdr, unsigned int offset,\n\t\t struct page **pages, unsigned int base, unsigned int len)\n{\n\tstruct kvec *head = xdr->head;\n\tstruct kvec *tail = xdr->tail;\n\tchar *buf = (char *)head->iov_base;\n\tunsigned int buflen = head->iov_len;\n\n\thead->iov_len  = offset;\n\n\txdr->pages = pages;\n\txdr->page_base = base;\n\txdr->page_len = len;\n\n\ttail->iov_base = buf + offset;\n\ttail->iov_len = buflen - offset;\n\txdr->buflen += len;\n}\nEXPORT_SYMBOL_GPL(xdr_inline_pages);\n\n/*\n * Helper routines for doing 'memmove' like operations on a struct xdr_buf\n */\n\n/**\n * _shift_data_left_pages\n * @pages: vector of pages containing both the source and dest memory area.\n * @pgto_base: page vector address of destination\n * @pgfrom_base: page vector address of source\n * @len: number of bytes to copy\n *\n * Note: the addresses pgto_base and pgfrom_base are both calculated in\n *       the same way:\n *            if a memory area starts at byte 'base' in page 'pages[i]',\n *            then its address is given as (i << PAGE_CACHE_SHIFT) + base\n * Alse note: pgto_base must be < pgfrom_base, but the memory areas\n * \tthey point to may overlap.\n */\nstatic void\n_shift_data_left_pages(struct page **pages, size_t pgto_base,\n\t\t\tsize_t pgfrom_base, size_t len)\n{\n\tstruct page **pgfrom, **pgto;\n\tchar *vfrom, *vto;\n\tsize_t copy;\n\n\tBUG_ON(pgfrom_base <= pgto_base);\n\n\tif (!len)\n\t\treturn;\n\n\tpgto = pages + (pgto_base >> PAGE_SHIFT);\n\tpgfrom = pages + (pgfrom_base >> PAGE_SHIFT);\n\n\tpgto_base &= ~PAGE_MASK;\n\tpgfrom_base &= ~PAGE_MASK;\n\n\tdo {\n\t\tif (pgto_base >= PAGE_SIZE) {\n\t\t\tpgto_base = 0;\n\t\t\tpgto++;\n\t\t}\n\t\tif (pgfrom_base >= PAGE_SIZE){\n\t\t\tpgfrom_base = 0;\n\t\t\tpgfrom++;\n\t\t}\n\n\t\tcopy = len;\n\t\tif (copy > (PAGE_SIZE - pgto_base))\n\t\t\tcopy = PAGE_SIZE - pgto_base;\n\t\tif (copy > (PAGE_SIZE - pgfrom_base))\n\t\t\tcopy = PAGE_SIZE - pgfrom_base;\n\n\t\tvto = kmap_atomic(*pgto);\n\t\tif (*pgto != *pgfrom) {\n\t\t\tvfrom = kmap_atomic(*pgfrom);\n\t\t\tmemcpy(vto + pgto_base, vfrom + pgfrom_base, copy);\n\t\t\tkunmap_atomic(vfrom);\n\t\t} else\n\t\t\tmemmove(vto + pgto_base, vto + pgfrom_base, copy);\n\t\tflush_dcache_page(*pgto);\n\t\tkunmap_atomic(vto);\n\n\t\tpgto_base += copy;\n\t\tpgfrom_base += copy;\n\n\t} while ((len -= copy) != 0);\n}\n\n/**\n * _shift_data_right_pages\n * @pages: vector of pages containing both the source and dest memory area.\n * @pgto_base: page vector address of destination\n * @pgfrom_base: page vector address of source\n * @len: number of bytes to copy\n *\n * Note: the addresses pgto_base and pgfrom_base are both calculated in\n *       the same way:\n *            if a memory area starts at byte 'base' in page 'pages[i]',\n *            then its address is given as (i << PAGE_SHIFT) + base\n * Also note: pgfrom_base must be < pgto_base, but the memory areas\n * \tthey point to may overlap.\n */\nstatic void\n_shift_data_right_pages(struct page **pages, size_t pgto_base,\n\t\tsize_t pgfrom_base, size_t len)\n{\n\tstruct page **pgfrom, **pgto;\n\tchar *vfrom, *vto;\n\tsize_t copy;\n\n\tBUG_ON(pgto_base <= pgfrom_base);\n\n\tif (!len)\n\t\treturn;\n\n\tpgto_base += len;\n\tpgfrom_base += len;\n\n\tpgto = pages + (pgto_base >> PAGE_SHIFT);\n\tpgfrom = pages + (pgfrom_base >> PAGE_SHIFT);\n\n\tpgto_base &= ~PAGE_MASK;\n\tpgfrom_base &= ~PAGE_MASK;\n\n\tdo {\n\t\t/* Are any pointers crossing a page boundary? */\n\t\tif (pgto_base == 0) {\n\t\t\tpgto_base = PAGE_SIZE;\n\t\t\tpgto--;\n\t\t}\n\t\tif (pgfrom_base == 0) {\n\t\t\tpgfrom_base = PAGE_SIZE;\n\t\t\tpgfrom--;\n\t\t}\n\n\t\tcopy = len;\n\t\tif (copy > pgto_base)\n\t\t\tcopy = pgto_base;\n\t\tif (copy > pgfrom_base)\n\t\t\tcopy = pgfrom_base;\n\t\tpgto_base -= copy;\n\t\tpgfrom_base -= copy;\n\n\t\tvto = kmap_atomic(*pgto);\n\t\tif (*pgto != *pgfrom) {\n\t\t\tvfrom = kmap_atomic(*pgfrom);\n\t\t\tmemcpy(vto + pgto_base, vfrom + pgfrom_base, copy);\n\t\t\tkunmap_atomic(vfrom);\n\t\t} else\n\t\t\tmemmove(vto + pgto_base, vto + pgfrom_base, copy);\n\t\tflush_dcache_page(*pgto);\n\t\tkunmap_atomic(vto);\n\n\t} while ((len -= copy) != 0);\n}\n\n/**\n * _copy_to_pages\n * @pages: array of pages\n * @pgbase: page vector address of destination\n * @p: pointer to source data\n * @len: length\n *\n * Copies data from an arbitrary memory location into an array of pages\n * The copy is assumed to be non-overlapping.\n */\nstatic void\n_copy_to_pages(struct page **pages, size_t pgbase, const char *p, size_t len)\n{\n\tstruct page **pgto;\n\tchar *vto;\n\tsize_t copy;\n\n\tif (!len)\n\t\treturn;\n\n\tpgto = pages + (pgbase >> PAGE_SHIFT);\n\tpgbase &= ~PAGE_MASK;\n\n\tfor (;;) {\n\t\tcopy = PAGE_SIZE - pgbase;\n\t\tif (copy > len)\n\t\t\tcopy = len;\n\n\t\tvto = kmap_atomic(*pgto);\n\t\tmemcpy(vto + pgbase, p, copy);\n\t\tkunmap_atomic(vto);\n\n\t\tlen -= copy;\n\t\tif (len == 0)\n\t\t\tbreak;\n\n\t\tpgbase += copy;\n\t\tif (pgbase == PAGE_SIZE) {\n\t\t\tflush_dcache_page(*pgto);\n\t\t\tpgbase = 0;\n\t\t\tpgto++;\n\t\t}\n\t\tp += copy;\n\t}\n\tflush_dcache_page(*pgto);\n}\n\n/**\n * _copy_from_pages\n * @p: pointer to destination\n * @pages: array of pages\n * @pgbase: offset of source data\n * @len: length\n *\n * Copies data into an arbitrary memory location from an array of pages\n * The copy is assumed to be non-overlapping.\n */\nvoid\n_copy_from_pages(char *p, struct page **pages, size_t pgbase, size_t len)\n{\n\tstruct page **pgfrom;\n\tchar *vfrom;\n\tsize_t copy;\n\n\tif (!len)\n\t\treturn;\n\n\tpgfrom = pages + (pgbase >> PAGE_SHIFT);\n\tpgbase &= ~PAGE_MASK;\n\n\tdo {\n\t\tcopy = PAGE_SIZE - pgbase;\n\t\tif (copy > len)\n\t\t\tcopy = len;\n\n\t\tvfrom = kmap_atomic(*pgfrom);\n\t\tmemcpy(p, vfrom + pgbase, copy);\n\t\tkunmap_atomic(vfrom);\n\n\t\tpgbase += copy;\n\t\tif (pgbase == PAGE_SIZE) {\n\t\t\tpgbase = 0;\n\t\t\tpgfrom++;\n\t\t}\n\t\tp += copy;\n\n\t} while ((len -= copy) != 0);\n}\nEXPORT_SYMBOL_GPL(_copy_from_pages);\n\nstatic void xdr_buf_iov_zero(const struct kvec *iov, unsigned int base,\n\t\t\t     unsigned int len)\n{\n\tif (base >= iov->iov_len)\n\t\treturn;\n\tif (len > iov->iov_len - base)\n\t\tlen = iov->iov_len - base;\n\tmemset(iov->iov_base + base, 0, len);\n}\n\n/**\n * xdr_buf_pages_zero\n * @buf: xdr_buf\n * @pgbase: beginning offset\n * @len: length\n */\nstatic void xdr_buf_pages_zero(const struct xdr_buf *buf, unsigned int pgbase,\n\t\t\t       unsigned int len)\n{\n\tstruct page **pages = buf->pages;\n\tstruct page **page;\n\tchar *vpage;\n\tunsigned int zero;\n\n\tif (!len)\n\t\treturn;\n\tif (pgbase >= buf->page_len) {\n\t\txdr_buf_iov_zero(buf->tail, pgbase - buf->page_len, len);\n\t\treturn;\n\t}\n\tif (pgbase + len > buf->page_len) {\n\t\txdr_buf_iov_zero(buf->tail, 0, pgbase + len - buf->page_len);\n\t\tlen = buf->page_len - pgbase;\n\t}\n\n\tpgbase += buf->page_base;\n\n\tpage = pages + (pgbase >> PAGE_SHIFT);\n\tpgbase &= ~PAGE_MASK;\n\n\tdo {\n\t\tzero = PAGE_SIZE - pgbase;\n\t\tif (zero > len)\n\t\t\tzero = len;\n\n\t\tvpage = kmap_atomic(*page);\n\t\tmemset(vpage + pgbase, 0, zero);\n\t\tkunmap_atomic(vpage);\n\n\t\tflush_dcache_page(*page);\n\t\tpgbase = 0;\n\t\tpage++;\n\n\t} while ((len -= zero) != 0);\n}\n\nstatic unsigned int xdr_buf_pages_fill_sparse(const struct xdr_buf *buf,\n\t\t\t\t\t      unsigned int buflen, gfp_t gfp)\n{\n\tunsigned int i, npages, pagelen;\n\n\tif (!(buf->flags & XDRBUF_SPARSE_PAGES))\n\t\treturn buflen;\n\tif (buflen <= buf->head->iov_len)\n\t\treturn buflen;\n\tpagelen = buflen - buf->head->iov_len;\n\tif (pagelen > buf->page_len)\n\t\tpagelen = buf->page_len;\n\tnpages = (pagelen + buf->page_base + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tfor (i = 0; i < npages; i++) {\n\t\tif (!buf->pages[i])\n\t\t\tcontinue;\n\t\tbuf->pages[i] = alloc_page(gfp);\n\t\tif (likely(buf->pages[i]))\n\t\t\tcontinue;\n\t\tbuflen -= pagelen;\n\t\tpagelen = i << PAGE_SHIFT;\n\t\tif (pagelen > buf->page_base)\n\t\t\tbuflen += pagelen - buf->page_base;\n\t\tbreak;\n\t}\n\treturn buflen;\n}\n\nstatic void xdr_buf_try_expand(struct xdr_buf *buf, unsigned int len)\n{\n\tstruct kvec *head = buf->head;\n\tstruct kvec *tail = buf->tail;\n\tunsigned int sum = head->iov_len + buf->page_len + tail->iov_len;\n\tunsigned int free_space, newlen;\n\n\tif (sum > buf->len) {\n\t\tfree_space = min_t(unsigned int, sum - buf->len, len);\n\t\tnewlen = xdr_buf_pages_fill_sparse(buf, buf->len + free_space,\n\t\t\t\t\t\t   GFP_KERNEL);\n\t\tfree_space = newlen - buf->len;\n\t\tbuf->len = newlen;\n\t\tlen -= free_space;\n\t\tif (!len)\n\t\t\treturn;\n\t}\n\n\tif (buf->buflen > sum) {\n\t\t/* Expand the tail buffer */\n\t\tfree_space = min_t(unsigned int, buf->buflen - sum, len);\n\t\ttail->iov_len += free_space;\n\t\tbuf->len += free_space;\n\t}\n}\n\nstatic void xdr_buf_tail_copy_right(const struct xdr_buf *buf,\n\t\t\t\t    unsigned int base, unsigned int len,\n\t\t\t\t    unsigned int shift)\n{\n\tconst struct kvec *tail = buf->tail;\n\tunsigned int to = base + shift;\n\n\tif (to >= tail->iov_len)\n\t\treturn;\n\tif (len + to > tail->iov_len)\n\t\tlen = tail->iov_len - to;\n\tmemmove(tail->iov_base + to, tail->iov_base + base, len);\n}\n\nstatic void xdr_buf_pages_copy_right(const struct xdr_buf *buf,\n\t\t\t\t     unsigned int base, unsigned int len,\n\t\t\t\t     unsigned int shift)\n{\n\tconst struct kvec *tail = buf->tail;\n\tunsigned int to = base + shift;\n\tunsigned int pglen = 0;\n\tunsigned int talen = 0, tato = 0;\n\n\tif (base >= buf->page_len)\n\t\treturn;\n\tif (len > buf->page_len - base)\n\t\tlen = buf->page_len - base;\n\tif (to >= buf->page_len) {\n\t\ttato = to - buf->page_len;\n\t\tif (tail->iov_len >= len + tato)\n\t\t\ttalen = len;\n\t\telse if (tail->iov_len > tato)\n\t\t\ttalen = tail->iov_len - tato;\n\t} else if (len + to >= buf->page_len) {\n\t\tpglen = buf->page_len - to;\n\t\ttalen = len - pglen;\n\t\tif (talen > tail->iov_len)\n\t\t\ttalen = tail->iov_len;\n\t} else\n\t\tpglen = len;\n\n\t_copy_from_pages(tail->iov_base + tato, buf->pages,\n\t\t\t buf->page_base + base + pglen, talen);\n\t_shift_data_right_pages(buf->pages, buf->page_base + to,\n\t\t\t\tbuf->page_base + base, pglen);\n}\n\nstatic void xdr_buf_head_copy_right(const struct xdr_buf *buf,\n\t\t\t\t    unsigned int base, unsigned int len,\n\t\t\t\t    unsigned int shift)\n{\n\tconst struct kvec *head = buf->head;\n\tconst struct kvec *tail = buf->tail;\n\tunsigned int to = base + shift;\n\tunsigned int pglen = 0, pgto = 0;\n\tunsigned int talen = 0, tato = 0;\n\n\tif (base >= head->iov_len)\n\t\treturn;\n\tif (len > head->iov_len - base)\n\t\tlen = head->iov_len - base;\n\tif (to >= buf->page_len + head->iov_len) {\n\t\ttato = to - buf->page_len - head->iov_len;\n\t\ttalen = len;\n\t} else if (to >= head->iov_len) {\n\t\tpgto = to - head->iov_len;\n\t\tpglen = len;\n\t\tif (pgto + pglen > buf->page_len) {\n\t\t\ttalen = pgto + pglen - buf->page_len;\n\t\t\tpglen -= talen;\n\t\t}\n\t} else {\n\t\tpglen = len - to;\n\t\tif (pglen > buf->page_len) {\n\t\t\ttalen = pglen - buf->page_len;\n\t\t\tpglen = buf->page_len;\n\t\t}\n\t}\n\n\tlen -= talen;\n\tbase += len;\n\tif (talen + tato > tail->iov_len)\n\t\ttalen = tail->iov_len > tato ? tail->iov_len - tato : 0;\n\tmemcpy(tail->iov_base + tato, head->iov_base + base, talen);\n\n\tlen -= pglen;\n\tbase -= pglen;\n\t_copy_to_pages(buf->pages, buf->page_base + pgto, head->iov_base + base,\n\t\t       pglen);\n\n\tbase -= len;\n\tmemmove(head->iov_base + to, head->iov_base + base, len);\n}\n\nstatic void xdr_buf_tail_shift_right(const struct xdr_buf *buf,\n\t\t\t\t     unsigned int base, unsigned int len,\n\t\t\t\t     unsigned int shift)\n{\n\tconst struct kvec *tail = buf->tail;\n\n\tif (base >= tail->iov_len || !shift || !len)\n\t\treturn;\n\txdr_buf_tail_copy_right(buf, base, len, shift);\n}\n\nstatic void xdr_buf_pages_shift_right(const struct xdr_buf *buf,\n\t\t\t\t      unsigned int base, unsigned int len,\n\t\t\t\t      unsigned int shift)\n{\n\tif (!shift || !len)\n\t\treturn;\n\tif (base >= buf->page_len) {\n\t\txdr_buf_tail_shift_right(buf, base - buf->page_len, len, shift);\n\t\treturn;\n\t}\n\tif (base + len > buf->page_len)\n\t\txdr_buf_tail_shift_right(buf, 0, base + len - buf->page_len,\n\t\t\t\t\t shift);\n\txdr_buf_pages_copy_right(buf, base, len, shift);\n}\n\nstatic void xdr_buf_head_shift_right(const struct xdr_buf *buf,\n\t\t\t\t     unsigned int base, unsigned int len,\n\t\t\t\t     unsigned int shift)\n{\n\tconst struct kvec *head = buf->head;\n\n\tif (!shift)\n\t\treturn;\n\tif (base >= head->iov_len) {\n\t\txdr_buf_pages_shift_right(buf, head->iov_len - base, len,\n\t\t\t\t\t  shift);\n\t\treturn;\n\t}\n\tif (base + len > head->iov_len)\n\t\txdr_buf_pages_shift_right(buf, 0, base + len - head->iov_len,\n\t\t\t\t\t  shift);\n\txdr_buf_head_copy_right(buf, base, len, shift);\n}\n\nstatic void xdr_buf_tail_copy_left(const struct xdr_buf *buf, unsigned int base,\n\t\t\t\t   unsigned int len, unsigned int shift)\n{\n\tconst struct kvec *tail = buf->tail;\n\n\tif (base >= tail->iov_len)\n\t\treturn;\n\tif (len > tail->iov_len - base)\n\t\tlen = tail->iov_len - base;\n\t/* Shift data into head */\n\tif (shift > buf->page_len + base) {\n\t\tconst struct kvec *head = buf->head;\n\t\tunsigned int hdto =\n\t\t\thead->iov_len + buf->page_len + base - shift;\n\t\tunsigned int hdlen = len;\n\n\t\tif (WARN_ONCE(shift > head->iov_len + buf->page_len + base,\n\t\t\t      \"SUNRPC: Misaligned data.\\n\"))\n\t\t\treturn;\n\t\tif (hdto + hdlen > head->iov_len)\n\t\t\thdlen = head->iov_len - hdto;\n\t\tmemcpy(head->iov_base + hdto, tail->iov_base + base, hdlen);\n\t\tbase += hdlen;\n\t\tlen -= hdlen;\n\t\tif (!len)\n\t\t\treturn;\n\t}\n\t/* Shift data into pages */\n\tif (shift > base) {\n\t\tunsigned int pgto = buf->page_len + base - shift;\n\t\tunsigned int pglen = len;\n\n\t\tif (pgto + pglen > buf->page_len)\n\t\t\tpglen = buf->page_len - pgto;\n\t\t_copy_to_pages(buf->pages, buf->page_base + pgto,\n\t\t\t       tail->iov_base + base, pglen);\n\t\tbase += pglen;\n\t\tlen -= pglen;\n\t\tif (!len)\n\t\t\treturn;\n\t}\n\tmemmove(tail->iov_base + base - shift, tail->iov_base + base, len);\n}\n\nstatic void xdr_buf_pages_copy_left(const struct xdr_buf *buf,\n\t\t\t\t    unsigned int base, unsigned int len,\n\t\t\t\t    unsigned int shift)\n{\n\tunsigned int pgto;\n\n\tif (base >= buf->page_len)\n\t\treturn;\n\tif (len > buf->page_len - base)\n\t\tlen = buf->page_len - base;\n\t/* Shift data into head */\n\tif (shift > base) {\n\t\tconst struct kvec *head = buf->head;\n\t\tunsigned int hdto = head->iov_len + base - shift;\n\t\tunsigned int hdlen = len;\n\n\t\tif (WARN_ONCE(shift > head->iov_len + base,\n\t\t\t      \"SUNRPC: Misaligned data.\\n\"))\n\t\t\treturn;\n\t\tif (hdto + hdlen > head->iov_len)\n\t\t\thdlen = head->iov_len - hdto;\n\t\t_copy_from_pages(head->iov_base + hdto, buf->pages,\n\t\t\t\t buf->page_base + base, hdlen);\n\t\tbase += hdlen;\n\t\tlen -= hdlen;\n\t\tif (!len)\n\t\t\treturn;\n\t}\n\tpgto = base - shift;\n\t_shift_data_left_pages(buf->pages, buf->page_base + pgto,\n\t\t\t       buf->page_base + base, len);\n}\n\nstatic void xdr_buf_tail_shift_left(const struct xdr_buf *buf,\n\t\t\t\t    unsigned int base, unsigned int len,\n\t\t\t\t    unsigned int shift)\n{\n\tif (!shift || !len)\n\t\treturn;\n\txdr_buf_tail_copy_left(buf, base, len, shift);\n}\n\nstatic void xdr_buf_pages_shift_left(const struct xdr_buf *buf,\n\t\t\t\t     unsigned int base, unsigned int len,\n\t\t\t\t     unsigned int shift)\n{\n\tif (!shift || !len)\n\t\treturn;\n\tif (base >= buf->page_len) {\n\t\txdr_buf_tail_shift_left(buf, base - buf->page_len, len, shift);\n\t\treturn;\n\t}\n\txdr_buf_pages_copy_left(buf, base, len, shift);\n\tlen += base;\n\tif (len <= buf->page_len)\n\t\treturn;\n\txdr_buf_tail_copy_left(buf, 0, len - buf->page_len, shift);\n}\n\n/**\n * xdr_shrink_bufhead\n * @buf: xdr_buf\n * @len: new length of buf->head[0]\n *\n * Shrinks XDR buffer's header kvec buf->head[0], setting it to\n * 'len' bytes. The extra data is not lost, but is instead\n * moved into the inlined pages and/or the tail.\n */\nstatic unsigned int xdr_shrink_bufhead(struct xdr_buf *buf, unsigned int len)\n{\n\tstruct kvec *head = buf->head;\n\tunsigned int shift, buflen = max(buf->len, len);\n\n\tWARN_ON_ONCE(len > head->iov_len);\n\tif (head->iov_len > buflen) {\n\t\tbuf->buflen -= head->iov_len - buflen;\n\t\thead->iov_len = buflen;\n\t}\n\tif (len >= head->iov_len)\n\t\treturn 0;\n\tshift = head->iov_len - len;\n\txdr_buf_try_expand(buf, shift);\n\txdr_buf_head_shift_right(buf, len, buflen - len, shift);\n\thead->iov_len = len;\n\tbuf->buflen -= shift;\n\tbuf->len -= shift;\n\treturn shift;\n}\n\n/**\n * xdr_shrink_pagelen - shrinks buf->pages to @len bytes\n * @buf: xdr_buf\n * @len: new page buffer length\n *\n * The extra data is not lost, but is instead moved into buf->tail.\n * Returns the actual number of bytes moved.\n */\nstatic unsigned int xdr_shrink_pagelen(struct xdr_buf *buf, unsigned int len)\n{\n\tunsigned int shift, buflen = buf->len - buf->head->iov_len;\n\n\tWARN_ON_ONCE(len > buf->page_len);\n\tif (buf->head->iov_len >= buf->len || len > buflen)\n\t\tbuflen = len;\n\tif (buf->page_len > buflen) {\n\t\tbuf->buflen -= buf->page_len - buflen;\n\t\tbuf->page_len = buflen;\n\t}\n\tif (len >= buf->page_len)\n\t\treturn 0;\n\tshift = buf->page_len - len;\n\txdr_buf_try_expand(buf, shift);\n\txdr_buf_pages_shift_right(buf, len, buflen - len, shift);\n\tbuf->page_len = len;\n\tbuf->len -= shift;\n\tbuf->buflen -= shift;\n\treturn shift;\n}\n\nvoid\nxdr_shift_buf(struct xdr_buf *buf, size_t len)\n{\n\txdr_shrink_bufhead(buf, buf->head->iov_len - len);\n}\nEXPORT_SYMBOL_GPL(xdr_shift_buf);\n\n/**\n * xdr_stream_pos - Return the current offset from the start of the xdr_stream\n * @xdr: pointer to struct xdr_stream\n */\nunsigned int xdr_stream_pos(const struct xdr_stream *xdr)\n{\n\treturn (unsigned int)(XDR_QUADLEN(xdr->buf->len) - xdr->nwords) << 2;\n}\nEXPORT_SYMBOL_GPL(xdr_stream_pos);\n\nstatic void xdr_stream_set_pos(struct xdr_stream *xdr, unsigned int pos)\n{\n\tunsigned int blen = xdr->buf->len;\n\n\txdr->nwords = blen > pos ? XDR_QUADLEN(blen) - XDR_QUADLEN(pos) : 0;\n}\n\nstatic void xdr_stream_page_set_pos(struct xdr_stream *xdr, unsigned int pos)\n{\n\txdr_stream_set_pos(xdr, pos + xdr->buf->head[0].iov_len);\n}\n\n/**\n * xdr_page_pos - Return the current offset from the start of the xdr pages\n * @xdr: pointer to struct xdr_stream\n */\nunsigned int xdr_page_pos(const struct xdr_stream *xdr)\n{\n\tunsigned int pos = xdr_stream_pos(xdr);\n\n\tWARN_ON(pos < xdr->buf->head[0].iov_len);\n\treturn pos - xdr->buf->head[0].iov_len;\n}\nEXPORT_SYMBOL_GPL(xdr_page_pos);\n\n/**\n * xdr_init_encode - Initialize a struct xdr_stream for sending data.\n * @xdr: pointer to xdr_stream struct\n * @buf: pointer to XDR buffer in which to encode data\n * @p: current pointer inside XDR buffer\n * @rqst: pointer to controlling rpc_rqst, for debugging\n *\n * Note: at the moment the RPC client only passes the length of our\n *\t scratch buffer in the xdr_buf's header kvec. Previously this\n *\t meant we needed to call xdr_adjust_iovec() after encoding the\n *\t data. With the new scheme, the xdr_stream manages the details\n *\t of the buffer length, and takes care of adjusting the kvec\n *\t length for us.\n */\nvoid xdr_init_encode(struct xdr_stream *xdr, struct xdr_buf *buf, __be32 *p,\n\t\t     struct rpc_rqst *rqst)\n{\n\tstruct kvec *iov = buf->head;\n\tint scratch_len = buf->buflen - buf->page_len - buf->tail[0].iov_len;\n\n\txdr_reset_scratch_buffer(xdr);\n\tBUG_ON(scratch_len < 0);\n\txdr->buf = buf;\n\txdr->iov = iov;\n\txdr->p = (__be32 *)((char *)iov->iov_base + iov->iov_len);\n\txdr->end = (__be32 *)((char *)iov->iov_base + scratch_len);\n\tBUG_ON(iov->iov_len > scratch_len);\n\n\tif (p != xdr->p && p != NULL) {\n\t\tsize_t len;\n\n\t\tBUG_ON(p < xdr->p || p > xdr->end);\n\t\tlen = (char *)p - (char *)xdr->p;\n\t\txdr->p = p;\n\t\tbuf->len += len;\n\t\tiov->iov_len += len;\n\t}\n\txdr->rqst = rqst;\n}\nEXPORT_SYMBOL_GPL(xdr_init_encode);\n\n/**\n * xdr_commit_encode - Ensure all data is written to buffer\n * @xdr: pointer to xdr_stream\n *\n * We handle encoding across page boundaries by giving the caller a\n * temporary location to write to, then later copying the data into\n * place; xdr_commit_encode does that copying.\n *\n * Normally the caller doesn't need to call this directly, as the\n * following xdr_reserve_space will do it.  But an explicit call may be\n * required at the end of encoding, or any other time when the xdr_buf\n * data might be read.\n */\ninline void xdr_commit_encode(struct xdr_stream *xdr)\n{\n\tint shift = xdr->scratch.iov_len;\n\tvoid *page;\n\n\tif (shift == 0)\n\t\treturn;\n\tpage = page_address(*xdr->page_ptr);\n\tmemcpy(xdr->scratch.iov_base, page, shift);\n\tmemmove(page, page + shift, (void *)xdr->p - page);\n\txdr_reset_scratch_buffer(xdr);\n}\nEXPORT_SYMBOL_GPL(xdr_commit_encode);\n\nstatic __be32 *xdr_get_next_encode_buffer(struct xdr_stream *xdr,\n\t\tsize_t nbytes)\n{\n\t__be32 *p;\n\tint space_left;\n\tint frag1bytes, frag2bytes;\n\n\tif (nbytes > PAGE_SIZE)\n\t\tgoto out_overflow; /* Bigger buffers require special handling */\n\tif (xdr->buf->len + nbytes > xdr->buf->buflen)\n\t\tgoto out_overflow; /* Sorry, we're totally out of space */\n\tfrag1bytes = (xdr->end - xdr->p) << 2;\n\tfrag2bytes = nbytes - frag1bytes;\n\tif (xdr->iov)\n\t\txdr->iov->iov_len += frag1bytes;\n\telse\n\t\txdr->buf->page_len += frag1bytes;\n\txdr->page_ptr++;\n\txdr->iov = NULL;\n\t/*\n\t * If the last encode didn't end exactly on a page boundary, the\n\t * next one will straddle boundaries.  Encode into the next\n\t * page, then copy it back later in xdr_commit_encode.  We use\n\t * the \"scratch\" iov to track any temporarily unused fragment of\n\t * space at the end of the previous buffer:\n\t */\n\txdr_set_scratch_buffer(xdr, xdr->p, frag1bytes);\n\tp = page_address(*xdr->page_ptr);\n\t/*\n\t * Note this is where the next encode will start after we've\n\t * shifted this one back:\n\t */\n\txdr->p = (void *)p + frag2bytes;\n\tspace_left = xdr->buf->buflen - xdr->buf->len;\n\txdr->end = (void *)p + min_t(int, space_left, PAGE_SIZE);\n\txdr->buf->page_len += frag2bytes;\n\txdr->buf->len += nbytes;\n\treturn p;\nout_overflow:\n\ttrace_rpc_xdr_overflow(xdr, nbytes);\n\treturn NULL;\n}\n\n/**\n * xdr_reserve_space - Reserve buffer space for sending\n * @xdr: pointer to xdr_stream\n * @nbytes: number of bytes to reserve\n *\n * Checks that we have enough buffer space to encode 'nbytes' more\n * bytes of data. If so, update the total xdr_buf length, and\n * adjust the length of the current kvec.\n */\n__be32 * xdr_reserve_space(struct xdr_stream *xdr, size_t nbytes)\n{\n\t__be32 *p = xdr->p;\n\t__be32 *q;\n\n\txdr_commit_encode(xdr);\n\t/* align nbytes on the next 32-bit boundary */\n\tnbytes += 3;\n\tnbytes &= ~3;\n\tq = p + (nbytes >> 2);\n\tif (unlikely(q > xdr->end || q < p))\n\t\treturn xdr_get_next_encode_buffer(xdr, nbytes);\n\txdr->p = q;\n\tif (xdr->iov)\n\t\txdr->iov->iov_len += nbytes;\n\telse\n\t\txdr->buf->page_len += nbytes;\n\txdr->buf->len += nbytes;\n\treturn p;\n}\nEXPORT_SYMBOL_GPL(xdr_reserve_space);\n\n\n/**\n * xdr_reserve_space_vec - Reserves a large amount of buffer space for sending\n * @xdr: pointer to xdr_stream\n * @vec: pointer to a kvec array\n * @nbytes: number of bytes to reserve\n *\n * Reserves enough buffer space to encode 'nbytes' of data and stores the\n * pointers in 'vec'. The size argument passed to xdr_reserve_space() is\n * determined based on the number of bytes remaining in the current page to\n * avoid invalidating iov_base pointers when xdr_commit_encode() is called.\n */\nint xdr_reserve_space_vec(struct xdr_stream *xdr, struct kvec *vec, size_t nbytes)\n{\n\tint thislen;\n\tint v = 0;\n\t__be32 *p;\n\n\t/*\n\t * svcrdma requires every READ payload to start somewhere\n\t * in xdr->pages.\n\t */\n\tif (xdr->iov == xdr->buf->head) {\n\t\txdr->iov = NULL;\n\t\txdr->end = xdr->p;\n\t}\n\n\twhile (nbytes) {\n\t\tthislen = xdr->buf->page_len % PAGE_SIZE;\n\t\tthislen = min_t(size_t, nbytes, PAGE_SIZE - thislen);\n\n\t\tp = xdr_reserve_space(xdr, thislen);\n\t\tif (!p)\n\t\t\treturn -EIO;\n\n\t\tvec[v].iov_base = p;\n\t\tvec[v].iov_len = thislen;\n\t\tv++;\n\t\tnbytes -= thislen;\n\t}\n\n\treturn v;\n}\nEXPORT_SYMBOL_GPL(xdr_reserve_space_vec);\n\n/**\n * xdr_truncate_encode - truncate an encode buffer\n * @xdr: pointer to xdr_stream\n * @len: new length of buffer\n *\n * Truncates the xdr stream, so that xdr->buf->len == len,\n * and xdr->p points at offset len from the start of the buffer, and\n * head, tail, and page lengths are adjusted to correspond.\n *\n * If this means moving xdr->p to a different buffer, we assume that\n * the end pointer should be set to the end of the current page,\n * except in the case of the head buffer when we assume the head\n * buffer's current length represents the end of the available buffer.\n *\n * This is *not* safe to use on a buffer that already has inlined page\n * cache pages (as in a zero-copy server read reply), except for the\n * simple case of truncating from one position in the tail to another.\n *\n */\nvoid xdr_truncate_encode(struct xdr_stream *xdr, size_t len)\n{\n\tstruct xdr_buf *buf = xdr->buf;\n\tstruct kvec *head = buf->head;\n\tstruct kvec *tail = buf->tail;\n\tint fraglen;\n\tint new;\n\n\tif (len > buf->len) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn;\n\t}\n\txdr_commit_encode(xdr);\n\n\tfraglen = min_t(int, buf->len - len, tail->iov_len);\n\ttail->iov_len -= fraglen;\n\tbuf->len -= fraglen;\n\tif (tail->iov_len) {\n\t\txdr->p = tail->iov_base + tail->iov_len;\n\t\tWARN_ON_ONCE(!xdr->end);\n\t\tWARN_ON_ONCE(!xdr->iov);\n\t\treturn;\n\t}\n\tWARN_ON_ONCE(fraglen);\n\tfraglen = min_t(int, buf->len - len, buf->page_len);\n\tbuf->page_len -= fraglen;\n\tbuf->len -= fraglen;\n\n\tnew = buf->page_base + buf->page_len;\n\n\txdr->page_ptr = buf->pages + (new >> PAGE_SHIFT);\n\n\tif (buf->page_len) {\n\t\txdr->p = page_address(*xdr->page_ptr);\n\t\txdr->end = (void *)xdr->p + PAGE_SIZE;\n\t\txdr->p = (void *)xdr->p + (new % PAGE_SIZE);\n\t\tWARN_ON_ONCE(xdr->iov);\n\t\treturn;\n\t}\n\tif (fraglen)\n\t\txdr->end = head->iov_base + head->iov_len;\n\t/* (otherwise assume xdr->end is already set) */\n\txdr->page_ptr--;\n\thead->iov_len = len;\n\tbuf->len = len;\n\txdr->p = head->iov_base + head->iov_len;\n\txdr->iov = buf->head;\n}\nEXPORT_SYMBOL(xdr_truncate_encode);\n\n/**\n * xdr_restrict_buflen - decrease available buffer space\n * @xdr: pointer to xdr_stream\n * @newbuflen: new maximum number of bytes available\n *\n * Adjust our idea of how much space is available in the buffer.\n * If we've already used too much space in the buffer, returns -1.\n * If the available space is already smaller than newbuflen, returns 0\n * and does nothing.  Otherwise, adjusts xdr->buf->buflen to newbuflen\n * and ensures xdr->end is set at most offset newbuflen from the start\n * of the buffer.\n */\nint xdr_restrict_buflen(struct xdr_stream *xdr, int newbuflen)\n{\n\tstruct xdr_buf *buf = xdr->buf;\n\tint left_in_this_buf = (void *)xdr->end - (void *)xdr->p;\n\tint end_offset = buf->len + left_in_this_buf;\n\n\tif (newbuflen < 0 || newbuflen < buf->len)\n\t\treturn -1;\n\tif (newbuflen > buf->buflen)\n\t\treturn 0;\n\tif (newbuflen < end_offset)\n\t\txdr->end = (void *)xdr->end + newbuflen - end_offset;\n\tbuf->buflen = newbuflen;\n\treturn 0;\n}\nEXPORT_SYMBOL(xdr_restrict_buflen);\n\n/**\n * xdr_write_pages - Insert a list of pages into an XDR buffer for sending\n * @xdr: pointer to xdr_stream\n * @pages: list of pages\n * @base: offset of first byte\n * @len: length of data in bytes\n *\n */\nvoid xdr_write_pages(struct xdr_stream *xdr, struct page **pages, unsigned int base,\n\t\t unsigned int len)\n{\n\tstruct xdr_buf *buf = xdr->buf;\n\tstruct kvec *iov = buf->tail;\n\tbuf->pages = pages;\n\tbuf->page_base = base;\n\tbuf->page_len = len;\n\n\tiov->iov_base = (char *)xdr->p;\n\tiov->iov_len  = 0;\n\txdr->iov = iov;\n\n\tif (len & 3) {\n\t\tunsigned int pad = 4 - (len & 3);\n\n\t\tBUG_ON(xdr->p >= xdr->end);\n\t\tiov->iov_base = (char *)xdr->p + (len & 3);\n\t\tiov->iov_len  += pad;\n\t\tlen += pad;\n\t\t*xdr->p++ = 0;\n\t}\n\tbuf->buflen += len;\n\tbuf->len += len;\n}\nEXPORT_SYMBOL_GPL(xdr_write_pages);\n\nstatic unsigned int xdr_set_iov(struct xdr_stream *xdr, struct kvec *iov,\n\t\t\t\tunsigned int base, unsigned int len)\n{\n\tif (len > iov->iov_len)\n\t\tlen = iov->iov_len;\n\tif (unlikely(base > len))\n\t\tbase = len;\n\txdr->p = (__be32*)(iov->iov_base + base);\n\txdr->end = (__be32*)(iov->iov_base + len);\n\txdr->iov = iov;\n\txdr->page_ptr = NULL;\n\treturn len - base;\n}\n\nstatic unsigned int xdr_set_tail_base(struct xdr_stream *xdr,\n\t\t\t\t      unsigned int base, unsigned int len)\n{\n\tstruct xdr_buf *buf = xdr->buf;\n\n\txdr_stream_set_pos(xdr, base + buf->page_len + buf->head->iov_len);\n\treturn xdr_set_iov(xdr, buf->tail, base, len);\n}\n\nstatic unsigned int xdr_set_page_base(struct xdr_stream *xdr,\n\t\t\t\t      unsigned int base, unsigned int len)\n{\n\tunsigned int pgnr;\n\tunsigned int maxlen;\n\tunsigned int pgoff;\n\tunsigned int pgend;\n\tvoid *kaddr;\n\n\tmaxlen = xdr->buf->page_len;\n\tif (base >= maxlen) {\n\t\tbase = maxlen;\n\t\tmaxlen = 0;\n\t} else\n\t\tmaxlen -= base;\n\tif (len > maxlen)\n\t\tlen = maxlen;\n\n\txdr_stream_page_set_pos(xdr, base);\n\tbase += xdr->buf->page_base;\n\n\tpgnr = base >> PAGE_SHIFT;\n\txdr->page_ptr = &xdr->buf->pages[pgnr];\n\tkaddr = page_address(*xdr->page_ptr);\n\n\tpgoff = base & ~PAGE_MASK;\n\txdr->p = (__be32*)(kaddr + pgoff);\n\n\tpgend = pgoff + len;\n\tif (pgend > PAGE_SIZE)\n\t\tpgend = PAGE_SIZE;\n\txdr->end = (__be32*)(kaddr + pgend);\n\txdr->iov = NULL;\n\treturn len;\n}\n\nstatic void xdr_set_page(struct xdr_stream *xdr, unsigned int base,\n\t\t\t unsigned int len)\n{\n\tif (xdr_set_page_base(xdr, base, len) == 0) {\n\t\tbase -= xdr->buf->page_len;\n\t\txdr_set_tail_base(xdr, base, len);\n\t}\n}\n\nstatic void xdr_set_next_page(struct xdr_stream *xdr)\n{\n\tunsigned int newbase;\n\n\tnewbase = (1 + xdr->page_ptr - xdr->buf->pages) << PAGE_SHIFT;\n\tnewbase -= xdr->buf->page_base;\n\tif (newbase < xdr->buf->page_len)\n\t\txdr_set_page_base(xdr, newbase, xdr_stream_remaining(xdr));\n\telse\n\t\txdr_set_tail_base(xdr, 0, xdr_stream_remaining(xdr));\n}\n\nstatic bool xdr_set_next_buffer(struct xdr_stream *xdr)\n{\n\tif (xdr->page_ptr != NULL)\n\t\txdr_set_next_page(xdr);\n\telse if (xdr->iov == xdr->buf->head)\n\t\txdr_set_page(xdr, 0, xdr_stream_remaining(xdr));\n\treturn xdr->p != xdr->end;\n}\n\n/**\n * xdr_init_decode - Initialize an xdr_stream for decoding data.\n * @xdr: pointer to xdr_stream struct\n * @buf: pointer to XDR buffer from which to decode data\n * @p: current pointer inside XDR buffer\n * @rqst: pointer to controlling rpc_rqst, for debugging\n */\nvoid xdr_init_decode(struct xdr_stream *xdr, struct xdr_buf *buf, __be32 *p,\n\t\t     struct rpc_rqst *rqst)\n{\n\txdr->buf = buf;\n\txdr_reset_scratch_buffer(xdr);\n\txdr->nwords = XDR_QUADLEN(buf->len);\n\tif (xdr_set_iov(xdr, buf->head, 0, buf->len) == 0 &&\n\t    xdr_set_page_base(xdr, 0, buf->len) == 0)\n\t\txdr_set_iov(xdr, buf->tail, 0, buf->len);\n\tif (p != NULL && p > xdr->p && xdr->end >= p) {\n\t\txdr->nwords -= p - xdr->p;\n\t\txdr->p = p;\n\t}\n\txdr->rqst = rqst;\n}\nEXPORT_SYMBOL_GPL(xdr_init_decode);\n\n/**\n * xdr_init_decode_pages - Initialize an xdr_stream for decoding into pages\n * @xdr: pointer to xdr_stream struct\n * @buf: pointer to XDR buffer from which to decode data\n * @pages: list of pages to decode into\n * @len: length in bytes of buffer in pages\n */\nvoid xdr_init_decode_pages(struct xdr_stream *xdr, struct xdr_buf *buf,\n\t\t\t   struct page **pages, unsigned int len)\n{\n\tmemset(buf, 0, sizeof(*buf));\n\tbuf->pages =  pages;\n\tbuf->page_len =  len;\n\tbuf->buflen =  len;\n\tbuf->len = len;\n\txdr_init_decode(xdr, buf, NULL, NULL);\n}\nEXPORT_SYMBOL_GPL(xdr_init_decode_pages);\n\nstatic __be32 * __xdr_inline_decode(struct xdr_stream *xdr, size_t nbytes)\n{\n\tunsigned int nwords = XDR_QUADLEN(nbytes);\n\t__be32 *p = xdr->p;\n\t__be32 *q = p + nwords;\n\n\tif (unlikely(nwords > xdr->nwords || q > xdr->end || q < p))\n\t\treturn NULL;\n\txdr->p = q;\n\txdr->nwords -= nwords;\n\treturn p;\n}\n\nstatic __be32 *xdr_copy_to_scratch(struct xdr_stream *xdr, size_t nbytes)\n{\n\t__be32 *p;\n\tchar *cpdest = xdr->scratch.iov_base;\n\tsize_t cplen = (char *)xdr->end - (char *)xdr->p;\n\n\tif (nbytes > xdr->scratch.iov_len)\n\t\tgoto out_overflow;\n\tp = __xdr_inline_decode(xdr, cplen);\n\tif (p == NULL)\n\t\treturn NULL;\n\tmemcpy(cpdest, p, cplen);\n\tif (!xdr_set_next_buffer(xdr))\n\t\tgoto out_overflow;\n\tcpdest += cplen;\n\tnbytes -= cplen;\n\tp = __xdr_inline_decode(xdr, nbytes);\n\tif (p == NULL)\n\t\treturn NULL;\n\tmemcpy(cpdest, p, nbytes);\n\treturn xdr->scratch.iov_base;\nout_overflow:\n\ttrace_rpc_xdr_overflow(xdr, nbytes);\n\treturn NULL;\n}\n\n/**\n * xdr_inline_decode - Retrieve XDR data to decode\n * @xdr: pointer to xdr_stream struct\n * @nbytes: number of bytes of data to decode\n *\n * Check if the input buffer is long enough to enable us to decode\n * 'nbytes' more bytes of data starting at the current position.\n * If so return the current pointer, then update the current\n * pointer position.\n */\n__be32 * xdr_inline_decode(struct xdr_stream *xdr, size_t nbytes)\n{\n\t__be32 *p;\n\n\tif (unlikely(nbytes == 0))\n\t\treturn xdr->p;\n\tif (xdr->p == xdr->end && !xdr_set_next_buffer(xdr))\n\t\tgoto out_overflow;\n\tp = __xdr_inline_decode(xdr, nbytes);\n\tif (p != NULL)\n\t\treturn p;\n\treturn xdr_copy_to_scratch(xdr, nbytes);\nout_overflow:\n\ttrace_rpc_xdr_overflow(xdr, nbytes);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(xdr_inline_decode);\n\nstatic void xdr_realign_pages(struct xdr_stream *xdr)\n{\n\tstruct xdr_buf *buf = xdr->buf;\n\tstruct kvec *iov = buf->head;\n\tunsigned int cur = xdr_stream_pos(xdr);\n\tunsigned int copied;\n\n\t/* Realign pages to current pointer position */\n\tif (iov->iov_len > cur) {\n\t\tcopied = xdr_shrink_bufhead(buf, cur);\n\t\ttrace_rpc_xdr_alignment(xdr, cur, copied);\n\t\txdr_set_page(xdr, 0, buf->page_len);\n\t}\n}\n\nstatic unsigned int xdr_align_pages(struct xdr_stream *xdr, unsigned int len)\n{\n\tstruct xdr_buf *buf = xdr->buf;\n\tunsigned int nwords = XDR_QUADLEN(len);\n\tunsigned int copied;\n\n\tif (xdr->nwords == 0)\n\t\treturn 0;\n\n\txdr_realign_pages(xdr);\n\tif (nwords > xdr->nwords) {\n\t\tnwords = xdr->nwords;\n\t\tlen = nwords << 2;\n\t}\n\tif (buf->page_len <= len)\n\t\tlen = buf->page_len;\n\telse if (nwords < xdr->nwords) {\n\t\t/* Truncate page data and move it into the tail */\n\t\tcopied = xdr_shrink_pagelen(buf, len);\n\t\ttrace_rpc_xdr_alignment(xdr, len, copied);\n\t}\n\treturn len;\n}\n\n/**\n * xdr_read_pages - align page-based XDR data to current pointer position\n * @xdr: pointer to xdr_stream struct\n * @len: number of bytes of page data\n *\n * Moves data beyond the current pointer position from the XDR head[] buffer\n * into the page list. Any data that lies beyond current position + @len\n * bytes is moved into the XDR tail[]. The xdr_stream current position is\n * then advanced past that data to align to the next XDR object in the tail.\n *\n * Returns the number of XDR encoded bytes now contained in the pages\n */\nunsigned int xdr_read_pages(struct xdr_stream *xdr, unsigned int len)\n{\n\tunsigned int nwords = XDR_QUADLEN(len);\n\tunsigned int base, end, pglen;\n\n\tpglen = xdr_align_pages(xdr, nwords << 2);\n\tif (pglen == 0)\n\t\treturn 0;\n\n\tbase = (nwords << 2) - pglen;\n\tend = xdr_stream_remaining(xdr) - pglen;\n\n\txdr_set_tail_base(xdr, base, end);\n\treturn len <= pglen ? len : pglen;\n}\nEXPORT_SYMBOL_GPL(xdr_read_pages);\n\nunsigned int xdr_align_data(struct xdr_stream *xdr, unsigned int offset,\n\t\t\t    unsigned int length)\n{\n\tstruct xdr_buf *buf = xdr->buf;\n\tunsigned int from, bytes, len;\n\tunsigned int shift;\n\n\txdr_realign_pages(xdr);\n\tfrom = xdr_page_pos(xdr);\n\n\tif (from >= buf->page_len + buf->tail->iov_len)\n\t\treturn 0;\n\tif (from + buf->head->iov_len >= buf->len)\n\t\treturn 0;\n\n\tlen = buf->len - buf->head->iov_len;\n\n\t/* We only shift data left! */\n\tif (WARN_ONCE(from < offset, \"SUNRPC: misaligned data src=%u dst=%u\\n\",\n\t\t      from, offset))\n\t\treturn 0;\n\tif (WARN_ONCE(offset > buf->page_len,\n\t\t      \"SUNRPC: buffer overflow. offset=%u, page_len=%u\\n\",\n\t\t      offset, buf->page_len))\n\t\treturn 0;\n\n\t/* Move page data to the left */\n\tshift = from - offset;\n\txdr_buf_pages_shift_left(buf, from, len, shift);\n\n\tbytes = xdr_stream_remaining(xdr);\n\tif (length > bytes)\n\t\tlength = bytes;\n\tbytes -= length;\n\n\txdr->buf->len -= shift;\n\txdr_set_page(xdr, offset + length, bytes);\n\treturn length;\n}\nEXPORT_SYMBOL_GPL(xdr_align_data);\n\nunsigned int xdr_expand_hole(struct xdr_stream *xdr, unsigned int offset,\n\t\t\t     unsigned int length)\n{\n\tstruct xdr_buf *buf = xdr->buf;\n\tunsigned int from, to, shift;\n\n\txdr_realign_pages(xdr);\n\tfrom = xdr_page_pos(xdr);\n\tto = xdr_align_size(offset + length);\n\n\t/* Could the hole be behind us? */\n\tif (to > from) {\n\t\tunsigned int buflen = buf->len - buf->head->iov_len;\n\t\tshift = to - from;\n\t\txdr_buf_try_expand(buf, shift);\n\t\txdr_buf_pages_shift_right(buf, from, buflen, shift);\n\t\txdr_set_page(xdr, to, xdr_stream_remaining(xdr));\n\t} else if (to != from)\n\t\txdr_align_data(xdr, to, 0);\n\txdr_buf_pages_zero(buf, offset, length);\n\n\treturn length;\n}\nEXPORT_SYMBOL_GPL(xdr_expand_hole);\n\n/**\n * xdr_enter_page - decode data from the XDR page\n * @xdr: pointer to xdr_stream struct\n * @len: number of bytes of page data\n *\n * Moves data beyond the current pointer position from the XDR head[] buffer\n * into the page list. Any data that lies beyond current position + \"len\"\n * bytes is moved into the XDR tail[]. The current pointer is then\n * repositioned at the beginning of the first XDR page.\n */\nvoid xdr_enter_page(struct xdr_stream *xdr, unsigned int len)\n{\n\tlen = xdr_align_pages(xdr, len);\n\t/*\n\t * Position current pointer at beginning of tail, and\n\t * set remaining message length.\n\t */\n\tif (len != 0)\n\t\txdr_set_page_base(xdr, 0, len);\n}\nEXPORT_SYMBOL_GPL(xdr_enter_page);\n\nstatic const struct kvec empty_iov = {.iov_base = NULL, .iov_len = 0};\n\nvoid xdr_buf_from_iov(const struct kvec *iov, struct xdr_buf *buf)\n{\n\tbuf->head[0] = *iov;\n\tbuf->tail[0] = empty_iov;\n\tbuf->page_len = 0;\n\tbuf->buflen = buf->len = iov->iov_len;\n}\nEXPORT_SYMBOL_GPL(xdr_buf_from_iov);\n\n/**\n * xdr_buf_subsegment - set subbuf to a portion of buf\n * @buf: an xdr buffer\n * @subbuf: the result buffer\n * @base: beginning of range in bytes\n * @len: length of range in bytes\n *\n * sets @subbuf to an xdr buffer representing the portion of @buf of\n * length @len starting at offset @base.\n *\n * @buf and @subbuf may be pointers to the same struct xdr_buf.\n *\n * Returns -1 if base of length are out of bounds.\n */\nint xdr_buf_subsegment(const struct xdr_buf *buf, struct xdr_buf *subbuf,\n\t\t       unsigned int base, unsigned int len)\n{\n\tsubbuf->buflen = subbuf->len = len;\n\tif (base < buf->head[0].iov_len) {\n\t\tsubbuf->head[0].iov_base = buf->head[0].iov_base + base;\n\t\tsubbuf->head[0].iov_len = min_t(unsigned int, len,\n\t\t\t\t\t\tbuf->head[0].iov_len - base);\n\t\tlen -= subbuf->head[0].iov_len;\n\t\tbase = 0;\n\t} else {\n\t\tbase -= buf->head[0].iov_len;\n\t\tsubbuf->head[0].iov_base = buf->head[0].iov_base;\n\t\tsubbuf->head[0].iov_len = 0;\n\t}\n\n\tif (base < buf->page_len) {\n\t\tsubbuf->page_len = min(buf->page_len - base, len);\n\t\tbase += buf->page_base;\n\t\tsubbuf->page_base = base & ~PAGE_MASK;\n\t\tsubbuf->pages = &buf->pages[base >> PAGE_SHIFT];\n\t\tlen -= subbuf->page_len;\n\t\tbase = 0;\n\t} else {\n\t\tbase -= buf->page_len;\n\t\tsubbuf->pages = buf->pages;\n\t\tsubbuf->page_base = 0;\n\t\tsubbuf->page_len = 0;\n\t}\n\n\tif (base < buf->tail[0].iov_len) {\n\t\tsubbuf->tail[0].iov_base = buf->tail[0].iov_base + base;\n\t\tsubbuf->tail[0].iov_len = min_t(unsigned int, len,\n\t\t\t\t\t\tbuf->tail[0].iov_len - base);\n\t\tlen -= subbuf->tail[0].iov_len;\n\t\tbase = 0;\n\t} else {\n\t\tbase -= buf->tail[0].iov_len;\n\t\tsubbuf->tail[0].iov_base = buf->tail[0].iov_base;\n\t\tsubbuf->tail[0].iov_len = 0;\n\t}\n\n\tif (base || len)\n\t\treturn -1;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(xdr_buf_subsegment);\n\n/**\n * xdr_stream_subsegment - set @subbuf to a portion of @xdr\n * @xdr: an xdr_stream set up for decoding\n * @subbuf: the result buffer\n * @nbytes: length of @xdr to extract, in bytes\n *\n * Sets up @subbuf to represent a portion of @xdr. The portion\n * starts at the current offset in @xdr, and extends for a length\n * of @nbytes. If this is successful, @xdr is advanced to the next\n * position following that portion.\n *\n * Return values:\n *   %true: @subbuf has been initialized, and @xdr has been advanced.\n *   %false: a bounds error has occurred\n */\nbool xdr_stream_subsegment(struct xdr_stream *xdr, struct xdr_buf *subbuf,\n\t\t\t   unsigned int nbytes)\n{\n\tunsigned int remaining, offset, len;\n\n\tif (xdr_buf_subsegment(xdr->buf, subbuf, xdr_stream_pos(xdr), nbytes))\n\t\treturn false;\n\n\tif (subbuf->head[0].iov_len)\n\t\tif (!__xdr_inline_decode(xdr, subbuf->head[0].iov_len))\n\t\t\treturn false;\n\n\tremaining = subbuf->page_len;\n\toffset = subbuf->page_base;\n\twhile (remaining) {\n\t\tlen = min_t(unsigned int, remaining, PAGE_SIZE) - offset;\n\n\t\tif (xdr->p == xdr->end && !xdr_set_next_buffer(xdr))\n\t\t\treturn false;\n\t\tif (!__xdr_inline_decode(xdr, len))\n\t\t\treturn false;\n\n\t\tremaining -= len;\n\t\toffset = 0;\n\t}\n\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(xdr_stream_subsegment);\n\n/**\n * xdr_buf_trim - lop at most \"len\" bytes off the end of \"buf\"\n * @buf: buf to be trimmed\n * @len: number of bytes to reduce \"buf\" by\n *\n * Trim an xdr_buf by the given number of bytes by fixing up the lengths. Note\n * that it's possible that we'll trim less than that amount if the xdr_buf is\n * too small, or if (for instance) it's all in the head and the parser has\n * already read too far into it.\n */\nvoid xdr_buf_trim(struct xdr_buf *buf, unsigned int len)\n{\n\tsize_t cur;\n\tunsigned int trim = len;\n\n\tif (buf->tail[0].iov_len) {\n\t\tcur = min_t(size_t, buf->tail[0].iov_len, trim);\n\t\tbuf->tail[0].iov_len -= cur;\n\t\ttrim -= cur;\n\t\tif (!trim)\n\t\t\tgoto fix_len;\n\t}\n\n\tif (buf->page_len) {\n\t\tcur = min_t(unsigned int, buf->page_len, trim);\n\t\tbuf->page_len -= cur;\n\t\ttrim -= cur;\n\t\tif (!trim)\n\t\t\tgoto fix_len;\n\t}\n\n\tif (buf->head[0].iov_len) {\n\t\tcur = min_t(size_t, buf->head[0].iov_len, trim);\n\t\tbuf->head[0].iov_len -= cur;\n\t\ttrim -= cur;\n\t}\nfix_len:\n\tbuf->len -= (len - trim);\n}\nEXPORT_SYMBOL_GPL(xdr_buf_trim);\n\nstatic void __read_bytes_from_xdr_buf(const struct xdr_buf *subbuf,\n\t\t\t\t      void *obj, unsigned int len)\n{\n\tunsigned int this_len;\n\n\tthis_len = min_t(unsigned int, len, subbuf->head[0].iov_len);\n\tmemcpy(obj, subbuf->head[0].iov_base, this_len);\n\tlen -= this_len;\n\tobj += this_len;\n\tthis_len = min_t(unsigned int, len, subbuf->page_len);\n\t_copy_from_pages(obj, subbuf->pages, subbuf->page_base, this_len);\n\tlen -= this_len;\n\tobj += this_len;\n\tthis_len = min_t(unsigned int, len, subbuf->tail[0].iov_len);\n\tmemcpy(obj, subbuf->tail[0].iov_base, this_len);\n}\n\n/* obj is assumed to point to allocated memory of size at least len: */\nint read_bytes_from_xdr_buf(const struct xdr_buf *buf, unsigned int base,\n\t\t\t    void *obj, unsigned int len)\n{\n\tstruct xdr_buf subbuf;\n\tint status;\n\n\tstatus = xdr_buf_subsegment(buf, &subbuf, base, len);\n\tif (status != 0)\n\t\treturn status;\n\t__read_bytes_from_xdr_buf(&subbuf, obj, len);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(read_bytes_from_xdr_buf);\n\nstatic void __write_bytes_to_xdr_buf(const struct xdr_buf *subbuf,\n\t\t\t\t     void *obj, unsigned int len)\n{\n\tunsigned int this_len;\n\n\tthis_len = min_t(unsigned int, len, subbuf->head[0].iov_len);\n\tmemcpy(subbuf->head[0].iov_base, obj, this_len);\n\tlen -= this_len;\n\tobj += this_len;\n\tthis_len = min_t(unsigned int, len, subbuf->page_len);\n\t_copy_to_pages(subbuf->pages, subbuf->page_base, obj, this_len);\n\tlen -= this_len;\n\tobj += this_len;\n\tthis_len = min_t(unsigned int, len, subbuf->tail[0].iov_len);\n\tmemcpy(subbuf->tail[0].iov_base, obj, this_len);\n}\n\n/* obj is assumed to point to allocated memory of size at least len: */\nint write_bytes_to_xdr_buf(const struct xdr_buf *buf, unsigned int base,\n\t\t\t   void *obj, unsigned int len)\n{\n\tstruct xdr_buf subbuf;\n\tint status;\n\n\tstatus = xdr_buf_subsegment(buf, &subbuf, base, len);\n\tif (status != 0)\n\t\treturn status;\n\t__write_bytes_to_xdr_buf(&subbuf, obj, len);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(write_bytes_to_xdr_buf);\n\nint xdr_decode_word(const struct xdr_buf *buf, unsigned int base, u32 *obj)\n{\n\t__be32\traw;\n\tint\tstatus;\n\n\tstatus = read_bytes_from_xdr_buf(buf, base, &raw, sizeof(*obj));\n\tif (status)\n\t\treturn status;\n\t*obj = be32_to_cpu(raw);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(xdr_decode_word);\n\nint xdr_encode_word(const struct xdr_buf *buf, unsigned int base, u32 obj)\n{\n\t__be32\traw = cpu_to_be32(obj);\n\n\treturn write_bytes_to_xdr_buf(buf, base, &raw, sizeof(obj));\n}\nEXPORT_SYMBOL_GPL(xdr_encode_word);\n\n/* Returns 0 on success, or else a negative error code. */\nstatic int xdr_xcode_array2(const struct xdr_buf *buf, unsigned int base,\n\t\t\t    struct xdr_array2_desc *desc, int encode)\n{\n\tchar *elem = NULL, *c;\n\tunsigned int copied = 0, todo, avail_here;\n\tstruct page **ppages = NULL;\n\tint err;\n\n\tif (encode) {\n\t\tif (xdr_encode_word(buf, base, desc->array_len) != 0)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (xdr_decode_word(buf, base, &desc->array_len) != 0 ||\n\t\t    desc->array_len > desc->array_maxlen ||\n\t\t    (unsigned long) base + 4 + desc->array_len *\n\t\t\t\t    desc->elem_size > buf->len)\n\t\t\treturn -EINVAL;\n\t}\n\tbase += 4;\n\n\tif (!desc->xcode)\n\t\treturn 0;\n\n\ttodo = desc->array_len * desc->elem_size;\n\n\t/* process head */\n\tif (todo && base < buf->head->iov_len) {\n\t\tc = buf->head->iov_base + base;\n\t\tavail_here = min_t(unsigned int, todo,\n\t\t\t\t   buf->head->iov_len - base);\n\t\ttodo -= avail_here;\n\n\t\twhile (avail_here >= desc->elem_size) {\n\t\t\terr = desc->xcode(desc, c);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tc += desc->elem_size;\n\t\t\tavail_here -= desc->elem_size;\n\t\t}\n\t\tif (avail_here) {\n\t\t\tif (!elem) {\n\t\t\t\telem = kmalloc(desc->elem_size, GFP_KERNEL);\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tif (!elem)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (encode) {\n\t\t\t\terr = desc->xcode(desc, elem);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out;\n\t\t\t\tmemcpy(c, elem, avail_here);\n\t\t\t} else\n\t\t\t\tmemcpy(elem, c, avail_here);\n\t\t\tcopied = avail_here;\n\t\t}\n\t\tbase = buf->head->iov_len;  /* align to start of pages */\n\t}\n\n\t/* process pages array */\n\tbase -= buf->head->iov_len;\n\tif (todo && base < buf->page_len) {\n\t\tunsigned int avail_page;\n\n\t\tavail_here = min(todo, buf->page_len - base);\n\t\ttodo -= avail_here;\n\n\t\tbase += buf->page_base;\n\t\tppages = buf->pages + (base >> PAGE_SHIFT);\n\t\tbase &= ~PAGE_MASK;\n\t\tavail_page = min_t(unsigned int, PAGE_SIZE - base,\n\t\t\t\t\tavail_here);\n\t\tc = kmap(*ppages) + base;\n\n\t\twhile (avail_here) {\n\t\t\tavail_here -= avail_page;\n\t\t\tif (copied || avail_page < desc->elem_size) {\n\t\t\t\tunsigned int l = min(avail_page,\n\t\t\t\t\tdesc->elem_size - copied);\n\t\t\t\tif (!elem) {\n\t\t\t\t\telem = kmalloc(desc->elem_size,\n\t\t\t\t\t\t       GFP_KERNEL);\n\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\tif (!elem)\n\t\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (encode) {\n\t\t\t\t\tif (!copied) {\n\t\t\t\t\t\terr = desc->xcode(desc, elem);\n\t\t\t\t\t\tif (err)\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\tmemcpy(c, elem + copied, l);\n\t\t\t\t\tcopied += l;\n\t\t\t\t\tif (copied == desc->elem_size)\n\t\t\t\t\t\tcopied = 0;\n\t\t\t\t} else {\n\t\t\t\t\tmemcpy(elem + copied, c, l);\n\t\t\t\t\tcopied += l;\n\t\t\t\t\tif (copied == desc->elem_size) {\n\t\t\t\t\t\terr = desc->xcode(desc, elem);\n\t\t\t\t\t\tif (err)\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\tcopied = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tavail_page -= l;\n\t\t\t\tc += l;\n\t\t\t}\n\t\t\twhile (avail_page >= desc->elem_size) {\n\t\t\t\terr = desc->xcode(desc, c);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out;\n\t\t\t\tc += desc->elem_size;\n\t\t\t\tavail_page -= desc->elem_size;\n\t\t\t}\n\t\t\tif (avail_page) {\n\t\t\t\tunsigned int l = min(avail_page,\n\t\t\t\t\t    desc->elem_size - copied);\n\t\t\t\tif (!elem) {\n\t\t\t\t\telem = kmalloc(desc->elem_size,\n\t\t\t\t\t\t       GFP_KERNEL);\n\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\tif (!elem)\n\t\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (encode) {\n\t\t\t\t\tif (!copied) {\n\t\t\t\t\t\terr = desc->xcode(desc, elem);\n\t\t\t\t\t\tif (err)\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\tmemcpy(c, elem + copied, l);\n\t\t\t\t\tcopied += l;\n\t\t\t\t\tif (copied == desc->elem_size)\n\t\t\t\t\t\tcopied = 0;\n\t\t\t\t} else {\n\t\t\t\t\tmemcpy(elem + copied, c, l);\n\t\t\t\t\tcopied += l;\n\t\t\t\t\tif (copied == desc->elem_size) {\n\t\t\t\t\t\terr = desc->xcode(desc, elem);\n\t\t\t\t\t\tif (err)\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\tcopied = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (avail_here) {\n\t\t\t\tkunmap(*ppages);\n\t\t\t\tppages++;\n\t\t\t\tc = kmap(*ppages);\n\t\t\t}\n\n\t\t\tavail_page = min(avail_here,\n\t\t\t\t (unsigned int) PAGE_SIZE);\n\t\t}\n\t\tbase = buf->page_len;  /* align to start of tail */\n\t}\n\n\t/* process tail */\n\tbase -= buf->page_len;\n\tif (todo) {\n\t\tc = buf->tail->iov_base + base;\n\t\tif (copied) {\n\t\t\tunsigned int l = desc->elem_size - copied;\n\n\t\t\tif (encode)\n\t\t\t\tmemcpy(c, elem + copied, l);\n\t\t\telse {\n\t\t\t\tmemcpy(elem + copied, c, l);\n\t\t\t\terr = desc->xcode(desc, elem);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\ttodo -= l;\n\t\t\tc += l;\n\t\t}\n\t\twhile (todo) {\n\t\t\terr = desc->xcode(desc, c);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tc += desc->elem_size;\n\t\t\ttodo -= desc->elem_size;\n\t\t}\n\t}\n\terr = 0;\n\nout:\n\tkfree(elem);\n\tif (ppages)\n\t\tkunmap(*ppages);\n\treturn err;\n}\n\nint xdr_decode_array2(const struct xdr_buf *buf, unsigned int base,\n\t\t      struct xdr_array2_desc *desc)\n{\n\tif (base >= buf->len)\n\t\treturn -EINVAL;\n\n\treturn xdr_xcode_array2(buf, base, desc, 0);\n}\nEXPORT_SYMBOL_GPL(xdr_decode_array2);\n\nint xdr_encode_array2(const struct xdr_buf *buf, unsigned int base,\n\t\t      struct xdr_array2_desc *desc)\n{\n\tif ((unsigned long) base + 4 + desc->array_len * desc->elem_size >\n\t    buf->head->iov_len + buf->page_len + buf->tail->iov_len)\n\t\treturn -EINVAL;\n\n\treturn xdr_xcode_array2(buf, base, desc, 1);\n}\nEXPORT_SYMBOL_GPL(xdr_encode_array2);\n\nint xdr_process_buf(const struct xdr_buf *buf, unsigned int offset,\n\t\t    unsigned int len,\n\t\t    int (*actor)(struct scatterlist *, void *), void *data)\n{\n\tint i, ret = 0;\n\tunsigned int page_len, thislen, page_offset;\n\tstruct scatterlist      sg[1];\n\n\tsg_init_table(sg, 1);\n\n\tif (offset >= buf->head[0].iov_len) {\n\t\toffset -= buf->head[0].iov_len;\n\t} else {\n\t\tthislen = buf->head[0].iov_len - offset;\n\t\tif (thislen > len)\n\t\t\tthislen = len;\n\t\tsg_set_buf(sg, buf->head[0].iov_base + offset, thislen);\n\t\tret = actor(sg, data);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\toffset = 0;\n\t\tlen -= thislen;\n\t}\n\tif (len == 0)\n\t\tgoto out;\n\n\tif (offset >= buf->page_len) {\n\t\toffset -= buf->page_len;\n\t} else {\n\t\tpage_len = buf->page_len - offset;\n\t\tif (page_len > len)\n\t\t\tpage_len = len;\n\t\tlen -= page_len;\n\t\tpage_offset = (offset + buf->page_base) & (PAGE_SIZE - 1);\n\t\ti = (offset + buf->page_base) >> PAGE_SHIFT;\n\t\tthislen = PAGE_SIZE - page_offset;\n\t\tdo {\n\t\t\tif (thislen > page_len)\n\t\t\t\tthislen = page_len;\n\t\t\tsg_set_page(sg, buf->pages[i], thislen, page_offset);\n\t\t\tret = actor(sg, data);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tpage_len -= thislen;\n\t\t\ti++;\n\t\t\tpage_offset = 0;\n\t\t\tthislen = PAGE_SIZE;\n\t\t} while (page_len != 0);\n\t\toffset = 0;\n\t}\n\tif (len == 0)\n\t\tgoto out;\n\tif (offset < buf->tail[0].iov_len) {\n\t\tthislen = buf->tail[0].iov_len - offset;\n\t\tif (thislen > len)\n\t\t\tthislen = len;\n\t\tsg_set_buf(sg, buf->tail[0].iov_base + offset, thislen);\n\t\tret = actor(sg, data);\n\t\tlen -= thislen;\n\t}\n\tif (len != 0)\n\t\tret = -EINVAL;\nout:\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(xdr_process_buf);\n\n/**\n * xdr_stream_decode_opaque - Decode variable length opaque\n * @xdr: pointer to xdr_stream\n * @ptr: location to store opaque data\n * @size: size of storage buffer @ptr\n *\n * Return values:\n *   On success, returns size of object stored in *@ptr\n *   %-EBADMSG on XDR buffer overflow\n *   %-EMSGSIZE on overflow of storage buffer @ptr\n */\nssize_t xdr_stream_decode_opaque(struct xdr_stream *xdr, void *ptr, size_t size)\n{\n\tssize_t ret;\n\tvoid *p;\n\n\tret = xdr_stream_decode_opaque_inline(xdr, &p, size);\n\tif (ret <= 0)\n\t\treturn ret;\n\tmemcpy(ptr, p, ret);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(xdr_stream_decode_opaque);\n\n/**\n * xdr_stream_decode_opaque_dup - Decode and duplicate variable length opaque\n * @xdr: pointer to xdr_stream\n * @ptr: location to store pointer to opaque data\n * @maxlen: maximum acceptable object size\n * @gfp_flags: GFP mask to use\n *\n * Return values:\n *   On success, returns size of object stored in *@ptr\n *   %-EBADMSG on XDR buffer overflow\n *   %-EMSGSIZE if the size of the object would exceed @maxlen\n *   %-ENOMEM on memory allocation failure\n */\nssize_t xdr_stream_decode_opaque_dup(struct xdr_stream *xdr, void **ptr,\n\t\tsize_t maxlen, gfp_t gfp_flags)\n{\n\tssize_t ret;\n\tvoid *p;\n\n\tret = xdr_stream_decode_opaque_inline(xdr, &p, maxlen);\n\tif (ret > 0) {\n\t\t*ptr = kmemdup(p, ret, gfp_flags);\n\t\tif (*ptr != NULL)\n\t\t\treturn ret;\n\t\tret = -ENOMEM;\n\t}\n\t*ptr = NULL;\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(xdr_stream_decode_opaque_dup);\n\n/**\n * xdr_stream_decode_string - Decode variable length string\n * @xdr: pointer to xdr_stream\n * @str: location to store string\n * @size: size of storage buffer @str\n *\n * Return values:\n *   On success, returns length of NUL-terminated string stored in *@str\n *   %-EBADMSG on XDR buffer overflow\n *   %-EMSGSIZE on overflow of storage buffer @str\n */\nssize_t xdr_stream_decode_string(struct xdr_stream *xdr, char *str, size_t size)\n{\n\tssize_t ret;\n\tvoid *p;\n\n\tret = xdr_stream_decode_opaque_inline(xdr, &p, size);\n\tif (ret > 0) {\n\t\tmemcpy(str, p, ret);\n\t\tstr[ret] = '\\0';\n\t\treturn strlen(str);\n\t}\n\t*str = '\\0';\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(xdr_stream_decode_string);\n\n/**\n * xdr_stream_decode_string_dup - Decode and duplicate variable length string\n * @xdr: pointer to xdr_stream\n * @str: location to store pointer to string\n * @maxlen: maximum acceptable string length\n * @gfp_flags: GFP mask to use\n *\n * Return values:\n *   On success, returns length of NUL-terminated string stored in *@ptr\n *   %-EBADMSG on XDR buffer overflow\n *   %-EMSGSIZE if the size of the string would exceed @maxlen\n *   %-ENOMEM on memory allocation failure\n */\nssize_t xdr_stream_decode_string_dup(struct xdr_stream *xdr, char **str,\n\t\tsize_t maxlen, gfp_t gfp_flags)\n{\n\tvoid *p;\n\tssize_t ret;\n\n\tret = xdr_stream_decode_opaque_inline(xdr, &p, maxlen);\n\tif (ret > 0) {\n\t\tchar *s = kmemdup_nul(p, ret, gfp_flags);\n\t\tif (s != NULL) {\n\t\t\t*str = s;\n\t\t\treturn strlen(s);\n\t\t}\n\t\tret = -ENOMEM;\n\t}\n\t*str = NULL;\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(xdr_stream_decode_string_dup);\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n * linux/net/sunrpc/xdr.c\n *\n * Generic XDR support.\n *\n * Copyright (C) 1995, 1996 Olaf Kirch <okir@monad.swb.de>\n */\n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/pagemap.h>\n#include <linux/errno.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/sunrpc/msg_prot.h>\n#include <linux/bvec.h>\n#include <trace/events/sunrpc.h>\n\nstatic void _copy_to_pages(struct page **, size_t, const char *, size_t);\n\n\n/*\n * XDR functions for basic NFS types\n */\n__be32 *\nxdr_encode_netobj(__be32 *p, const struct xdr_netobj *obj)\n{\n\tunsigned int\tquadlen = XDR_QUADLEN(obj->len);\n\n\tp[quadlen] = 0;\t\t/* zero trailing bytes */\n\t*p++ = cpu_to_be32(obj->len);\n\tmemcpy(p, obj->data, obj->len);\n\treturn p + XDR_QUADLEN(obj->len);\n}\nEXPORT_SYMBOL_GPL(xdr_encode_netobj);\n\n__be32 *\nxdr_decode_netobj(__be32 *p, struct xdr_netobj *obj)\n{\n\tunsigned int\tlen;\n\n\tif ((len = be32_to_cpu(*p++)) > XDR_MAX_NETOBJ)\n\t\treturn NULL;\n\tobj->len  = len;\n\tobj->data = (u8 *) p;\n\treturn p + XDR_QUADLEN(len);\n}\nEXPORT_SYMBOL_GPL(xdr_decode_netobj);\n\n/**\n * xdr_encode_opaque_fixed - Encode fixed length opaque data\n * @p: pointer to current position in XDR buffer.\n * @ptr: pointer to data to encode (or NULL)\n * @nbytes: size of data.\n *\n * Copy the array of data of length nbytes at ptr to the XDR buffer\n * at position p, then align to the next 32-bit boundary by padding\n * with zero bytes (see RFC1832).\n * Note: if ptr is NULL, only the padding is performed.\n *\n * Returns the updated current XDR buffer position\n *\n */\n__be32 *xdr_encode_opaque_fixed(__be32 *p, const void *ptr, unsigned int nbytes)\n{\n\tif (likely(nbytes != 0)) {\n\t\tunsigned int quadlen = XDR_QUADLEN(nbytes);\n\t\tunsigned int padding = (quadlen << 2) - nbytes;\n\n\t\tif (ptr != NULL)\n\t\t\tmemcpy(p, ptr, nbytes);\n\t\tif (padding != 0)\n\t\t\tmemset((char *)p + nbytes, 0, padding);\n\t\tp += quadlen;\n\t}\n\treturn p;\n}\nEXPORT_SYMBOL_GPL(xdr_encode_opaque_fixed);\n\n/**\n * xdr_encode_opaque - Encode variable length opaque data\n * @p: pointer to current position in XDR buffer.\n * @ptr: pointer to data to encode (or NULL)\n * @nbytes: size of data.\n *\n * Returns the updated current XDR buffer position\n */\n__be32 *xdr_encode_opaque(__be32 *p, const void *ptr, unsigned int nbytes)\n{\n\t*p++ = cpu_to_be32(nbytes);\n\treturn xdr_encode_opaque_fixed(p, ptr, nbytes);\n}\nEXPORT_SYMBOL_GPL(xdr_encode_opaque);\n\n__be32 *\nxdr_encode_string(__be32 *p, const char *string)\n{\n\treturn xdr_encode_array(p, string, strlen(string));\n}\nEXPORT_SYMBOL_GPL(xdr_encode_string);\n\n__be32 *\nxdr_decode_string_inplace(__be32 *p, char **sp,\n\t\t\t  unsigned int *lenp, unsigned int maxlen)\n{\n\tu32 len;\n\n\tlen = be32_to_cpu(*p++);\n\tif (len > maxlen)\n\t\treturn NULL;\n\t*lenp = len;\n\t*sp = (char *) p;\n\treturn p + XDR_QUADLEN(len);\n}\nEXPORT_SYMBOL_GPL(xdr_decode_string_inplace);\n\n/**\n * xdr_terminate_string - '\\0'-terminate a string residing in an xdr_buf\n * @buf: XDR buffer where string resides\n * @len: length of string, in bytes\n *\n */\nvoid xdr_terminate_string(const struct xdr_buf *buf, const u32 len)\n{\n\tchar *kaddr;\n\n\tkaddr = kmap_atomic(buf->pages[0]);\n\tkaddr[buf->page_base + len] = '\\0';\n\tkunmap_atomic(kaddr);\n}\nEXPORT_SYMBOL_GPL(xdr_terminate_string);\n\nsize_t xdr_buf_pagecount(const struct xdr_buf *buf)\n{\n\tif (!buf->page_len)\n\t\treturn 0;\n\treturn (buf->page_base + buf->page_len + PAGE_SIZE - 1) >> PAGE_SHIFT;\n}\n\nint\nxdr_alloc_bvec(struct xdr_buf *buf, gfp_t gfp)\n{\n\tsize_t i, n = xdr_buf_pagecount(buf);\n\n\tif (n != 0 && buf->bvec == NULL) {\n\t\tbuf->bvec = kmalloc_array(n, sizeof(buf->bvec[0]), gfp);\n\t\tif (!buf->bvec)\n\t\t\treturn -ENOMEM;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tbuf->bvec[i].bv_page = buf->pages[i];\n\t\t\tbuf->bvec[i].bv_len = PAGE_SIZE;\n\t\t\tbuf->bvec[i].bv_offset = 0;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid\nxdr_free_bvec(struct xdr_buf *buf)\n{\n\tkfree(buf->bvec);\n\tbuf->bvec = NULL;\n}\n\n/**\n * xdr_inline_pages - Prepare receive buffer for a large reply\n * @xdr: xdr_buf into which reply will be placed\n * @offset: expected offset where data payload will start, in bytes\n * @pages: vector of struct page pointers\n * @base: offset in first page where receive should start, in bytes\n * @len: expected size of the upper layer data payload, in bytes\n *\n */\nvoid\nxdr_inline_pages(struct xdr_buf *xdr, unsigned int offset,\n\t\t struct page **pages, unsigned int base, unsigned int len)\n{\n\tstruct kvec *head = xdr->head;\n\tstruct kvec *tail = xdr->tail;\n\tchar *buf = (char *)head->iov_base;\n\tunsigned int buflen = head->iov_len;\n\n\thead->iov_len  = offset;\n\n\txdr->pages = pages;\n\txdr->page_base = base;\n\txdr->page_len = len;\n\n\ttail->iov_base = buf + offset;\n\ttail->iov_len = buflen - offset;\n\txdr->buflen += len;\n}\nEXPORT_SYMBOL_GPL(xdr_inline_pages);\n\n/*\n * Helper routines for doing 'memmove' like operations on a struct xdr_buf\n */\n\n/**\n * _shift_data_left_pages\n * @pages: vector of pages containing both the source and dest memory area.\n * @pgto_base: page vector address of destination\n * @pgfrom_base: page vector address of source\n * @len: number of bytes to copy\n *\n * Note: the addresses pgto_base and pgfrom_base are both calculated in\n *       the same way:\n *            if a memory area starts at byte 'base' in page 'pages[i]',\n *            then its address is given as (i << PAGE_CACHE_SHIFT) + base\n * Alse note: pgto_base must be < pgfrom_base, but the memory areas\n * \tthey point to may overlap.\n */\nstatic void\n_shift_data_left_pages(struct page **pages, size_t pgto_base,\n\t\t\tsize_t pgfrom_base, size_t len)\n{\n\tstruct page **pgfrom, **pgto;\n\tchar *vfrom, *vto;\n\tsize_t copy;\n\n\tBUG_ON(pgfrom_base <= pgto_base);\n\n\tif (!len)\n\t\treturn;\n\n\tpgto = pages + (pgto_base >> PAGE_SHIFT);\n\tpgfrom = pages + (pgfrom_base >> PAGE_SHIFT);\n\n\tpgto_base &= ~PAGE_MASK;\n\tpgfrom_base &= ~PAGE_MASK;\n\n\tdo {\n\t\tif (pgto_base >= PAGE_SIZE) {\n\t\t\tpgto_base = 0;\n\t\t\tpgto++;\n\t\t}\n\t\tif (pgfrom_base >= PAGE_SIZE){\n\t\t\tpgfrom_base = 0;\n\t\t\tpgfrom++;\n\t\t}\n\n\t\tcopy = len;\n\t\tif (copy > (PAGE_SIZE - pgto_base))\n\t\t\tcopy = PAGE_SIZE - pgto_base;\n\t\tif (copy > (PAGE_SIZE - pgfrom_base))\n\t\t\tcopy = PAGE_SIZE - pgfrom_base;\n\n\t\tvto = kmap_atomic(*pgto);\n\t\tif (*pgto != *pgfrom) {\n\t\t\tvfrom = kmap_atomic(*pgfrom);\n\t\t\tmemcpy(vto + pgto_base, vfrom + pgfrom_base, copy);\n\t\t\tkunmap_atomic(vfrom);\n\t\t} else\n\t\t\tmemmove(vto + pgto_base, vto + pgfrom_base, copy);\n\t\tflush_dcache_page(*pgto);\n\t\tkunmap_atomic(vto);\n\n\t\tpgto_base += copy;\n\t\tpgfrom_base += copy;\n\n\t} while ((len -= copy) != 0);\n}\n\n/**\n * _shift_data_right_pages\n * @pages: vector of pages containing both the source and dest memory area.\n * @pgto_base: page vector address of destination\n * @pgfrom_base: page vector address of source\n * @len: number of bytes to copy\n *\n * Note: the addresses pgto_base and pgfrom_base are both calculated in\n *       the same way:\n *            if a memory area starts at byte 'base' in page 'pages[i]',\n *            then its address is given as (i << PAGE_SHIFT) + base\n * Also note: pgfrom_base must be < pgto_base, but the memory areas\n * \tthey point to may overlap.\n */\nstatic void\n_shift_data_right_pages(struct page **pages, size_t pgto_base,\n\t\tsize_t pgfrom_base, size_t len)\n{\n\tstruct page **pgfrom, **pgto;\n\tchar *vfrom, *vto;\n\tsize_t copy;\n\n\tBUG_ON(pgto_base <= pgfrom_base);\n\n\tif (!len)\n\t\treturn;\n\n\tpgto_base += len;\n\tpgfrom_base += len;\n\n\tpgto = pages + (pgto_base >> PAGE_SHIFT);\n\tpgfrom = pages + (pgfrom_base >> PAGE_SHIFT);\n\n\tpgto_base &= ~PAGE_MASK;\n\tpgfrom_base &= ~PAGE_MASK;\n\n\tdo {\n\t\t/* Are any pointers crossing a page boundary? */\n\t\tif (pgto_base == 0) {\n\t\t\tpgto_base = PAGE_SIZE;\n\t\t\tpgto--;\n\t\t}\n\t\tif (pgfrom_base == 0) {\n\t\t\tpgfrom_base = PAGE_SIZE;\n\t\t\tpgfrom--;\n\t\t}\n\n\t\tcopy = len;\n\t\tif (copy > pgto_base)\n\t\t\tcopy = pgto_base;\n\t\tif (copy > pgfrom_base)\n\t\t\tcopy = pgfrom_base;\n\t\tpgto_base -= copy;\n\t\tpgfrom_base -= copy;\n\n\t\tvto = kmap_atomic(*pgto);\n\t\tif (*pgto != *pgfrom) {\n\t\t\tvfrom = kmap_atomic(*pgfrom);\n\t\t\tmemcpy(vto + pgto_base, vfrom + pgfrom_base, copy);\n\t\t\tkunmap_atomic(vfrom);\n\t\t} else\n\t\t\tmemmove(vto + pgto_base, vto + pgfrom_base, copy);\n\t\tflush_dcache_page(*pgto);\n\t\tkunmap_atomic(vto);\n\n\t} while ((len -= copy) != 0);\n}\n\n/**\n * _copy_to_pages\n * @pages: array of pages\n * @pgbase: page vector address of destination\n * @p: pointer to source data\n * @len: length\n *\n * Copies data from an arbitrary memory location into an array of pages\n * The copy is assumed to be non-overlapping.\n */\nstatic void\n_copy_to_pages(struct page **pages, size_t pgbase, const char *p, size_t len)\n{\n\tstruct page **pgto;\n\tchar *vto;\n\tsize_t copy;\n\n\tif (!len)\n\t\treturn;\n\n\tpgto = pages + (pgbase >> PAGE_SHIFT);\n\tpgbase &= ~PAGE_MASK;\n\n\tfor (;;) {\n\t\tcopy = PAGE_SIZE - pgbase;\n\t\tif (copy > len)\n\t\t\tcopy = len;\n\n\t\tvto = kmap_atomic(*pgto);\n\t\tmemcpy(vto + pgbase, p, copy);\n\t\tkunmap_atomic(vto);\n\n\t\tlen -= copy;\n\t\tif (len == 0)\n\t\t\tbreak;\n\n\t\tpgbase += copy;\n\t\tif (pgbase == PAGE_SIZE) {\n\t\t\tflush_dcache_page(*pgto);\n\t\t\tpgbase = 0;\n\t\t\tpgto++;\n\t\t}\n\t\tp += copy;\n\t}\n\tflush_dcache_page(*pgto);\n}\n\n/**\n * _copy_from_pages\n * @p: pointer to destination\n * @pages: array of pages\n * @pgbase: offset of source data\n * @len: length\n *\n * Copies data into an arbitrary memory location from an array of pages\n * The copy is assumed to be non-overlapping.\n */\nvoid\n_copy_from_pages(char *p, struct page **pages, size_t pgbase, size_t len)\n{\n\tstruct page **pgfrom;\n\tchar *vfrom;\n\tsize_t copy;\n\n\tif (!len)\n\t\treturn;\n\n\tpgfrom = pages + (pgbase >> PAGE_SHIFT);\n\tpgbase &= ~PAGE_MASK;\n\n\tdo {\n\t\tcopy = PAGE_SIZE - pgbase;\n\t\tif (copy > len)\n\t\t\tcopy = len;\n\n\t\tvfrom = kmap_atomic(*pgfrom);\n\t\tmemcpy(p, vfrom + pgbase, copy);\n\t\tkunmap_atomic(vfrom);\n\n\t\tpgbase += copy;\n\t\tif (pgbase == PAGE_SIZE) {\n\t\t\tpgbase = 0;\n\t\t\tpgfrom++;\n\t\t}\n\t\tp += copy;\n\n\t} while ((len -= copy) != 0);\n}\nEXPORT_SYMBOL_GPL(_copy_from_pages);\n\nstatic void xdr_buf_iov_zero(const struct kvec *iov, unsigned int base,\n\t\t\t     unsigned int len)\n{\n\tif (base >= iov->iov_len)\n\t\treturn;\n\tif (len > iov->iov_len - base)\n\t\tlen = iov->iov_len - base;\n\tmemset(iov->iov_base + base, 0, len);\n}\n\n/**\n * xdr_buf_pages_zero\n * @buf: xdr_buf\n * @pgbase: beginning offset\n * @len: length\n */\nstatic void xdr_buf_pages_zero(const struct xdr_buf *buf, unsigned int pgbase,\n\t\t\t       unsigned int len)\n{\n\tstruct page **pages = buf->pages;\n\tstruct page **page;\n\tchar *vpage;\n\tunsigned int zero;\n\n\tif (!len)\n\t\treturn;\n\tif (pgbase >= buf->page_len) {\n\t\txdr_buf_iov_zero(buf->tail, pgbase - buf->page_len, len);\n\t\treturn;\n\t}\n\tif (pgbase + len > buf->page_len) {\n\t\txdr_buf_iov_zero(buf->tail, 0, pgbase + len - buf->page_len);\n\t\tlen = buf->page_len - pgbase;\n\t}\n\n\tpgbase += buf->page_base;\n\n\tpage = pages + (pgbase >> PAGE_SHIFT);\n\tpgbase &= ~PAGE_MASK;\n\n\tdo {\n\t\tzero = PAGE_SIZE - pgbase;\n\t\tif (zero > len)\n\t\t\tzero = len;\n\n\t\tvpage = kmap_atomic(*page);\n\t\tmemset(vpage + pgbase, 0, zero);\n\t\tkunmap_atomic(vpage);\n\n\t\tflush_dcache_page(*page);\n\t\tpgbase = 0;\n\t\tpage++;\n\n\t} while ((len -= zero) != 0);\n}\n\nstatic unsigned int xdr_buf_pages_fill_sparse(const struct xdr_buf *buf,\n\t\t\t\t\t      unsigned int buflen, gfp_t gfp)\n{\n\tunsigned int i, npages, pagelen;\n\n\tif (!(buf->flags & XDRBUF_SPARSE_PAGES))\n\t\treturn buflen;\n\tif (buflen <= buf->head->iov_len)\n\t\treturn buflen;\n\tpagelen = buflen - buf->head->iov_len;\n\tif (pagelen > buf->page_len)\n\t\tpagelen = buf->page_len;\n\tnpages = (pagelen + buf->page_base + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tfor (i = 0; i < npages; i++) {\n\t\tif (!buf->pages[i])\n\t\t\tcontinue;\n\t\tbuf->pages[i] = alloc_page(gfp);\n\t\tif (likely(buf->pages[i]))\n\t\t\tcontinue;\n\t\tbuflen -= pagelen;\n\t\tpagelen = i << PAGE_SHIFT;\n\t\tif (pagelen > buf->page_base)\n\t\t\tbuflen += pagelen - buf->page_base;\n\t\tbreak;\n\t}\n\treturn buflen;\n}\n\nstatic void xdr_buf_try_expand(struct xdr_buf *buf, unsigned int len)\n{\n\tstruct kvec *head = buf->head;\n\tstruct kvec *tail = buf->tail;\n\tunsigned int sum = head->iov_len + buf->page_len + tail->iov_len;\n\tunsigned int free_space, newlen;\n\n\tif (sum > buf->len) {\n\t\tfree_space = min_t(unsigned int, sum - buf->len, len);\n\t\tnewlen = xdr_buf_pages_fill_sparse(buf, buf->len + free_space,\n\t\t\t\t\t\t   GFP_KERNEL);\n\t\tfree_space = newlen - buf->len;\n\t\tbuf->len = newlen;\n\t\tlen -= free_space;\n\t\tif (!len)\n\t\t\treturn;\n\t}\n\n\tif (buf->buflen > sum) {\n\t\t/* Expand the tail buffer */\n\t\tfree_space = min_t(unsigned int, buf->buflen - sum, len);\n\t\ttail->iov_len += free_space;\n\t\tbuf->len += free_space;\n\t}\n}\n\nstatic void xdr_buf_tail_copy_right(const struct xdr_buf *buf,\n\t\t\t\t    unsigned int base, unsigned int len,\n\t\t\t\t    unsigned int shift)\n{\n\tconst struct kvec *tail = buf->tail;\n\tunsigned int to = base + shift;\n\n\tif (to >= tail->iov_len)\n\t\treturn;\n\tif (len + to > tail->iov_len)\n\t\tlen = tail->iov_len - to;\n\tmemmove(tail->iov_base + to, tail->iov_base + base, len);\n}\n\nstatic void xdr_buf_pages_copy_right(const struct xdr_buf *buf,\n\t\t\t\t     unsigned int base, unsigned int len,\n\t\t\t\t     unsigned int shift)\n{\n\tconst struct kvec *tail = buf->tail;\n\tunsigned int to = base + shift;\n\tunsigned int pglen = 0;\n\tunsigned int talen = 0, tato = 0;\n\n\tif (base >= buf->page_len)\n\t\treturn;\n\tif (len > buf->page_len - base)\n\t\tlen = buf->page_len - base;\n\tif (to >= buf->page_len) {\n\t\ttato = to - buf->page_len;\n\t\tif (tail->iov_len >= len + tato)\n\t\t\ttalen = len;\n\t\telse if (tail->iov_len > tato)\n\t\t\ttalen = tail->iov_len - tato;\n\t} else if (len + to >= buf->page_len) {\n\t\tpglen = buf->page_len - to;\n\t\ttalen = len - pglen;\n\t\tif (talen > tail->iov_len)\n\t\t\ttalen = tail->iov_len;\n\t} else\n\t\tpglen = len;\n\n\t_copy_from_pages(tail->iov_base + tato, buf->pages,\n\t\t\t buf->page_base + base + pglen, talen);\n\t_shift_data_right_pages(buf->pages, buf->page_base + to,\n\t\t\t\tbuf->page_base + base, pglen);\n}\n\nstatic void xdr_buf_head_copy_right(const struct xdr_buf *buf,\n\t\t\t\t    unsigned int base, unsigned int len,\n\t\t\t\t    unsigned int shift)\n{\n\tconst struct kvec *head = buf->head;\n\tconst struct kvec *tail = buf->tail;\n\tunsigned int to = base + shift;\n\tunsigned int pglen = 0, pgto = 0;\n\tunsigned int talen = 0, tato = 0;\n\n\tif (base >= head->iov_len)\n\t\treturn;\n\tif (len > head->iov_len - base)\n\t\tlen = head->iov_len - base;\n\tif (to >= buf->page_len + head->iov_len) {\n\t\ttato = to - buf->page_len - head->iov_len;\n\t\ttalen = len;\n\t} else if (to >= head->iov_len) {\n\t\tpgto = to - head->iov_len;\n\t\tpglen = len;\n\t\tif (pgto + pglen > buf->page_len) {\n\t\t\ttalen = pgto + pglen - buf->page_len;\n\t\t\tpglen -= talen;\n\t\t}\n\t} else {\n\t\tpglen = len - to;\n\t\tif (pglen > buf->page_len) {\n\t\t\ttalen = pglen - buf->page_len;\n\t\t\tpglen = buf->page_len;\n\t\t}\n\t}\n\n\tlen -= talen;\n\tbase += len;\n\tif (talen + tato > tail->iov_len)\n\t\ttalen = tail->iov_len > tato ? tail->iov_len - tato : 0;\n\tmemcpy(tail->iov_base + tato, head->iov_base + base, talen);\n\n\tlen -= pglen;\n\tbase -= pglen;\n\t_copy_to_pages(buf->pages, buf->page_base + pgto, head->iov_base + base,\n\t\t       pglen);\n\n\tbase -= len;\n\tmemmove(head->iov_base + to, head->iov_base + base, len);\n}\n\nstatic void xdr_buf_tail_shift_right(const struct xdr_buf *buf,\n\t\t\t\t     unsigned int base, unsigned int len,\n\t\t\t\t     unsigned int shift)\n{\n\tconst struct kvec *tail = buf->tail;\n\n\tif (base >= tail->iov_len || !shift || !len)\n\t\treturn;\n\txdr_buf_tail_copy_right(buf, base, len, shift);\n}\n\nstatic void xdr_buf_pages_shift_right(const struct xdr_buf *buf,\n\t\t\t\t      unsigned int base, unsigned int len,\n\t\t\t\t      unsigned int shift)\n{\n\tif (!shift || !len)\n\t\treturn;\n\tif (base >= buf->page_len) {\n\t\txdr_buf_tail_shift_right(buf, base - buf->page_len, len, shift);\n\t\treturn;\n\t}\n\tif (base + len > buf->page_len)\n\t\txdr_buf_tail_shift_right(buf, 0, base + len - buf->page_len,\n\t\t\t\t\t shift);\n\txdr_buf_pages_copy_right(buf, base, len, shift);\n}\n\nstatic void xdr_buf_head_shift_right(const struct xdr_buf *buf,\n\t\t\t\t     unsigned int base, unsigned int len,\n\t\t\t\t     unsigned int shift)\n{\n\tconst struct kvec *head = buf->head;\n\n\tif (!shift)\n\t\treturn;\n\tif (base >= head->iov_len) {\n\t\txdr_buf_pages_shift_right(buf, head->iov_len - base, len,\n\t\t\t\t\t  shift);\n\t\treturn;\n\t}\n\tif (base + len > head->iov_len)\n\t\txdr_buf_pages_shift_right(buf, 0, base + len - head->iov_len,\n\t\t\t\t\t  shift);\n\txdr_buf_head_copy_right(buf, base, len, shift);\n}\n\nstatic void xdr_buf_tail_copy_left(const struct xdr_buf *buf, unsigned int base,\n\t\t\t\t   unsigned int len, unsigned int shift)\n{\n\tconst struct kvec *tail = buf->tail;\n\n\tif (base >= tail->iov_len)\n\t\treturn;\n\tif (len > tail->iov_len - base)\n\t\tlen = tail->iov_len - base;\n\t/* Shift data into head */\n\tif (shift > buf->page_len + base) {\n\t\tconst struct kvec *head = buf->head;\n\t\tunsigned int hdto =\n\t\t\thead->iov_len + buf->page_len + base - shift;\n\t\tunsigned int hdlen = len;\n\n\t\tif (WARN_ONCE(shift > head->iov_len + buf->page_len + base,\n\t\t\t      \"SUNRPC: Misaligned data.\\n\"))\n\t\t\treturn;\n\t\tif (hdto + hdlen > head->iov_len)\n\t\t\thdlen = head->iov_len - hdto;\n\t\tmemcpy(head->iov_base + hdto, tail->iov_base + base, hdlen);\n\t\tbase += hdlen;\n\t\tlen -= hdlen;\n\t\tif (!len)\n\t\t\treturn;\n\t}\n\t/* Shift data into pages */\n\tif (shift > base) {\n\t\tunsigned int pgto = buf->page_len + base - shift;\n\t\tunsigned int pglen = len;\n\n\t\tif (pgto + pglen > buf->page_len)\n\t\t\tpglen = buf->page_len - pgto;\n\t\t_copy_to_pages(buf->pages, buf->page_base + pgto,\n\t\t\t       tail->iov_base + base, pglen);\n\t\tbase += pglen;\n\t\tlen -= pglen;\n\t\tif (!len)\n\t\t\treturn;\n\t}\n\tmemmove(tail->iov_base + base - shift, tail->iov_base + base, len);\n}\n\nstatic void xdr_buf_pages_copy_left(const struct xdr_buf *buf,\n\t\t\t\t    unsigned int base, unsigned int len,\n\t\t\t\t    unsigned int shift)\n{\n\tunsigned int pgto;\n\n\tif (base >= buf->page_len)\n\t\treturn;\n\tif (len > buf->page_len - base)\n\t\tlen = buf->page_len - base;\n\t/* Shift data into head */\n\tif (shift > base) {\n\t\tconst struct kvec *head = buf->head;\n\t\tunsigned int hdto = head->iov_len + base - shift;\n\t\tunsigned int hdlen = len;\n\n\t\tif (WARN_ONCE(shift > head->iov_len + base,\n\t\t\t      \"SUNRPC: Misaligned data.\\n\"))\n\t\t\treturn;\n\t\tif (hdto + hdlen > head->iov_len)\n\t\t\thdlen = head->iov_len - hdto;\n\t\t_copy_from_pages(head->iov_base + hdto, buf->pages,\n\t\t\t\t buf->page_base + base, hdlen);\n\t\tbase += hdlen;\n\t\tlen -= hdlen;\n\t\tif (!len)\n\t\t\treturn;\n\t}\n\tpgto = base - shift;\n\t_shift_data_left_pages(buf->pages, buf->page_base + pgto,\n\t\t\t       buf->page_base + base, len);\n}\n\nstatic void xdr_buf_tail_shift_left(const struct xdr_buf *buf,\n\t\t\t\t    unsigned int base, unsigned int len,\n\t\t\t\t    unsigned int shift)\n{\n\tif (!shift || !len)\n\t\treturn;\n\txdr_buf_tail_copy_left(buf, base, len, shift);\n}\n\nstatic void xdr_buf_pages_shift_left(const struct xdr_buf *buf,\n\t\t\t\t     unsigned int base, unsigned int len,\n\t\t\t\t     unsigned int shift)\n{\n\tif (!shift || !len)\n\t\treturn;\n\tif (base >= buf->page_len) {\n\t\txdr_buf_tail_shift_left(buf, base - buf->page_len, len, shift);\n\t\treturn;\n\t}\n\txdr_buf_pages_copy_left(buf, base, len, shift);\n\tlen += base;\n\tif (len <= buf->page_len)\n\t\treturn;\n\txdr_buf_tail_copy_left(buf, 0, len - buf->page_len, shift);\n}\n\n/**\n * xdr_shrink_bufhead\n * @buf: xdr_buf\n * @len: new length of buf->head[0]\n *\n * Shrinks XDR buffer's header kvec buf->head[0], setting it to\n * 'len' bytes. The extra data is not lost, but is instead\n * moved into the inlined pages and/or the tail.\n */\nstatic unsigned int xdr_shrink_bufhead(struct xdr_buf *buf, unsigned int len)\n{\n\tstruct kvec *head = buf->head;\n\tunsigned int shift, buflen = max(buf->len, len);\n\n\tWARN_ON_ONCE(len > head->iov_len);\n\tif (head->iov_len > buflen) {\n\t\tbuf->buflen -= head->iov_len - buflen;\n\t\thead->iov_len = buflen;\n\t}\n\tif (len >= head->iov_len)\n\t\treturn 0;\n\tshift = head->iov_len - len;\n\txdr_buf_try_expand(buf, shift);\n\txdr_buf_head_shift_right(buf, len, buflen - len, shift);\n\thead->iov_len = len;\n\tbuf->buflen -= shift;\n\tbuf->len -= shift;\n\treturn shift;\n}\n\n/**\n * xdr_shrink_pagelen - shrinks buf->pages to @len bytes\n * @buf: xdr_buf\n * @len: new page buffer length\n *\n * The extra data is not lost, but is instead moved into buf->tail.\n * Returns the actual number of bytes moved.\n */\nstatic unsigned int xdr_shrink_pagelen(struct xdr_buf *buf, unsigned int len)\n{\n\tunsigned int shift, buflen = buf->len - buf->head->iov_len;\n\n\tWARN_ON_ONCE(len > buf->page_len);\n\tif (buf->head->iov_len >= buf->len || len > buflen)\n\t\tbuflen = len;\n\tif (buf->page_len > buflen) {\n\t\tbuf->buflen -= buf->page_len - buflen;\n\t\tbuf->page_len = buflen;\n\t}\n\tif (len >= buf->page_len)\n\t\treturn 0;\n\tshift = buf->page_len - len;\n\txdr_buf_try_expand(buf, shift);\n\txdr_buf_pages_shift_right(buf, len, buflen - len, shift);\n\tbuf->page_len = len;\n\tbuf->len -= shift;\n\tbuf->buflen -= shift;\n\treturn shift;\n}\n\nvoid\nxdr_shift_buf(struct xdr_buf *buf, size_t len)\n{\n\txdr_shrink_bufhead(buf, buf->head->iov_len - len);\n}\nEXPORT_SYMBOL_GPL(xdr_shift_buf);\n\n/**\n * xdr_stream_pos - Return the current offset from the start of the xdr_stream\n * @xdr: pointer to struct xdr_stream\n */\nunsigned int xdr_stream_pos(const struct xdr_stream *xdr)\n{\n\treturn (unsigned int)(XDR_QUADLEN(xdr->buf->len) - xdr->nwords) << 2;\n}\nEXPORT_SYMBOL_GPL(xdr_stream_pos);\n\nstatic void xdr_stream_set_pos(struct xdr_stream *xdr, unsigned int pos)\n{\n\tunsigned int blen = xdr->buf->len;\n\n\txdr->nwords = blen > pos ? XDR_QUADLEN(blen) - XDR_QUADLEN(pos) : 0;\n}\n\nstatic void xdr_stream_page_set_pos(struct xdr_stream *xdr, unsigned int pos)\n{\n\txdr_stream_set_pos(xdr, pos + xdr->buf->head[0].iov_len);\n}\n\n/**\n * xdr_page_pos - Return the current offset from the start of the xdr pages\n * @xdr: pointer to struct xdr_stream\n */\nunsigned int xdr_page_pos(const struct xdr_stream *xdr)\n{\n\tunsigned int pos = xdr_stream_pos(xdr);\n\n\tWARN_ON(pos < xdr->buf->head[0].iov_len);\n\treturn pos - xdr->buf->head[0].iov_len;\n}\nEXPORT_SYMBOL_GPL(xdr_page_pos);\n\n/**\n * xdr_init_encode - Initialize a struct xdr_stream for sending data.\n * @xdr: pointer to xdr_stream struct\n * @buf: pointer to XDR buffer in which to encode data\n * @p: current pointer inside XDR buffer\n * @rqst: pointer to controlling rpc_rqst, for debugging\n *\n * Note: at the moment the RPC client only passes the length of our\n *\t scratch buffer in the xdr_buf's header kvec. Previously this\n *\t meant we needed to call xdr_adjust_iovec() after encoding the\n *\t data. With the new scheme, the xdr_stream manages the details\n *\t of the buffer length, and takes care of adjusting the kvec\n *\t length for us.\n */\nvoid xdr_init_encode(struct xdr_stream *xdr, struct xdr_buf *buf, __be32 *p,\n\t\t     struct rpc_rqst *rqst)\n{\n\tstruct kvec *iov = buf->head;\n\tint scratch_len = buf->buflen - buf->page_len - buf->tail[0].iov_len;\n\n\txdr_reset_scratch_buffer(xdr);\n\tBUG_ON(scratch_len < 0);\n\txdr->buf = buf;\n\txdr->iov = iov;\n\txdr->p = (__be32 *)((char *)iov->iov_base + iov->iov_len);\n\txdr->end = (__be32 *)((char *)iov->iov_base + scratch_len);\n\tBUG_ON(iov->iov_len > scratch_len);\n\n\tif (p != xdr->p && p != NULL) {\n\t\tsize_t len;\n\n\t\tBUG_ON(p < xdr->p || p > xdr->end);\n\t\tlen = (char *)p - (char *)xdr->p;\n\t\txdr->p = p;\n\t\tbuf->len += len;\n\t\tiov->iov_len += len;\n\t}\n\txdr->rqst = rqst;\n}\nEXPORT_SYMBOL_GPL(xdr_init_encode);\n\n/**\n * xdr_commit_encode - Ensure all data is written to buffer\n * @xdr: pointer to xdr_stream\n *\n * We handle encoding across page boundaries by giving the caller a\n * temporary location to write to, then later copying the data into\n * place; xdr_commit_encode does that copying.\n *\n * Normally the caller doesn't need to call this directly, as the\n * following xdr_reserve_space will do it.  But an explicit call may be\n * required at the end of encoding, or any other time when the xdr_buf\n * data might be read.\n */\ninline void xdr_commit_encode(struct xdr_stream *xdr)\n{\n\tint shift = xdr->scratch.iov_len;\n\tvoid *page;\n\n\tif (shift == 0)\n\t\treturn;\n\tpage = page_address(*xdr->page_ptr);\n\tmemcpy(xdr->scratch.iov_base, page, shift);\n\tmemmove(page, page + shift, (void *)xdr->p - page);\n\txdr_reset_scratch_buffer(xdr);\n}\nEXPORT_SYMBOL_GPL(xdr_commit_encode);\n\nstatic __be32 *xdr_get_next_encode_buffer(struct xdr_stream *xdr,\n\t\tsize_t nbytes)\n{\n\t__be32 *p;\n\tint space_left;\n\tint frag1bytes, frag2bytes;\n\n\tif (nbytes > PAGE_SIZE)\n\t\tgoto out_overflow; /* Bigger buffers require special handling */\n\tif (xdr->buf->len + nbytes > xdr->buf->buflen)\n\t\tgoto out_overflow; /* Sorry, we're totally out of space */\n\tfrag1bytes = (xdr->end - xdr->p) << 2;\n\tfrag2bytes = nbytes - frag1bytes;\n\tif (xdr->iov)\n\t\txdr->iov->iov_len += frag1bytes;\n\telse\n\t\txdr->buf->page_len += frag1bytes;\n\txdr->page_ptr++;\n\txdr->iov = NULL;\n\t/*\n\t * If the last encode didn't end exactly on a page boundary, the\n\t * next one will straddle boundaries.  Encode into the next\n\t * page, then copy it back later in xdr_commit_encode.  We use\n\t * the \"scratch\" iov to track any temporarily unused fragment of\n\t * space at the end of the previous buffer:\n\t */\n\txdr_set_scratch_buffer(xdr, xdr->p, frag1bytes);\n\tp = page_address(*xdr->page_ptr);\n\t/*\n\t * Note this is where the next encode will start after we've\n\t * shifted this one back:\n\t */\n\txdr->p = (void *)p + frag2bytes;\n\tspace_left = xdr->buf->buflen - xdr->buf->len;\n\txdr->end = (void *)p + min_t(int, space_left, PAGE_SIZE);\n\txdr->buf->page_len += frag2bytes;\n\txdr->buf->len += nbytes;\n\treturn p;\nout_overflow:\n\ttrace_rpc_xdr_overflow(xdr, nbytes);\n\treturn NULL;\n}\n\n/**\n * xdr_reserve_space - Reserve buffer space for sending\n * @xdr: pointer to xdr_stream\n * @nbytes: number of bytes to reserve\n *\n * Checks that we have enough buffer space to encode 'nbytes' more\n * bytes of data. If so, update the total xdr_buf length, and\n * adjust the length of the current kvec.\n */\n__be32 * xdr_reserve_space(struct xdr_stream *xdr, size_t nbytes)\n{\n\t__be32 *p = xdr->p;\n\t__be32 *q;\n\n\txdr_commit_encode(xdr);\n\t/* align nbytes on the next 32-bit boundary */\n\tnbytes += 3;\n\tnbytes &= ~3;\n\tq = p + (nbytes >> 2);\n\tif (unlikely(q > xdr->end || q < p))\n\t\treturn xdr_get_next_encode_buffer(xdr, nbytes);\n\txdr->p = q;\n\tif (xdr->iov)\n\t\txdr->iov->iov_len += nbytes;\n\telse\n\t\txdr->buf->page_len += nbytes;\n\txdr->buf->len += nbytes;\n\treturn p;\n}\nEXPORT_SYMBOL_GPL(xdr_reserve_space);\n\n\n/**\n * xdr_reserve_space_vec - Reserves a large amount of buffer space for sending\n * @xdr: pointer to xdr_stream\n * @vec: pointer to a kvec array\n * @nbytes: number of bytes to reserve\n *\n * Reserves enough buffer space to encode 'nbytes' of data and stores the\n * pointers in 'vec'. The size argument passed to xdr_reserve_space() is\n * determined based on the number of bytes remaining in the current page to\n * avoid invalidating iov_base pointers when xdr_commit_encode() is called.\n */\nint xdr_reserve_space_vec(struct xdr_stream *xdr, struct kvec *vec, size_t nbytes)\n{\n\tint thislen;\n\tint v = 0;\n\t__be32 *p;\n\n\t/*\n\t * svcrdma requires every READ payload to start somewhere\n\t * in xdr->pages.\n\t */\n\tif (xdr->iov == xdr->buf->head) {\n\t\txdr->iov = NULL;\n\t\txdr->end = xdr->p;\n\t}\n\n\twhile (nbytes) {\n\t\tthislen = xdr->buf->page_len % PAGE_SIZE;\n\t\tthislen = min_t(size_t, nbytes, PAGE_SIZE - thislen);\n\n\t\tp = xdr_reserve_space(xdr, thislen);\n\t\tif (!p)\n\t\t\treturn -EIO;\n\n\t\tvec[v].iov_base = p;\n\t\tvec[v].iov_len = thislen;\n\t\tv++;\n\t\tnbytes -= thislen;\n\t}\n\n\treturn v;\n}\nEXPORT_SYMBOL_GPL(xdr_reserve_space_vec);\n\n/**\n * xdr_truncate_encode - truncate an encode buffer\n * @xdr: pointer to xdr_stream\n * @len: new length of buffer\n *\n * Truncates the xdr stream, so that xdr->buf->len == len,\n * and xdr->p points at offset len from the start of the buffer, and\n * head, tail, and page lengths are adjusted to correspond.\n *\n * If this means moving xdr->p to a different buffer, we assume that\n * the end pointer should be set to the end of the current page,\n * except in the case of the head buffer when we assume the head\n * buffer's current length represents the end of the available buffer.\n *\n * This is *not* safe to use on a buffer that already has inlined page\n * cache pages (as in a zero-copy server read reply), except for the\n * simple case of truncating from one position in the tail to another.\n *\n */\nvoid xdr_truncate_encode(struct xdr_stream *xdr, size_t len)\n{\n\tstruct xdr_buf *buf = xdr->buf;\n\tstruct kvec *head = buf->head;\n\tstruct kvec *tail = buf->tail;\n\tint fraglen;\n\tint new;\n\n\tif (len > buf->len) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn;\n\t}\n\txdr_commit_encode(xdr);\n\n\tfraglen = min_t(int, buf->len - len, tail->iov_len);\n\ttail->iov_len -= fraglen;\n\tbuf->len -= fraglen;\n\tif (tail->iov_len) {\n\t\txdr->p = tail->iov_base + tail->iov_len;\n\t\tWARN_ON_ONCE(!xdr->end);\n\t\tWARN_ON_ONCE(!xdr->iov);\n\t\treturn;\n\t}\n\tWARN_ON_ONCE(fraglen);\n\tfraglen = min_t(int, buf->len - len, buf->page_len);\n\tbuf->page_len -= fraglen;\n\tbuf->len -= fraglen;\n\n\tnew = buf->page_base + buf->page_len;\n\n\txdr->page_ptr = buf->pages + (new >> PAGE_SHIFT);\n\n\tif (buf->page_len) {\n\t\txdr->p = page_address(*xdr->page_ptr);\n\t\txdr->end = (void *)xdr->p + PAGE_SIZE;\n\t\txdr->p = (void *)xdr->p + (new % PAGE_SIZE);\n\t\tWARN_ON_ONCE(xdr->iov);\n\t\treturn;\n\t}\n\tif (fraglen)\n\t\txdr->end = head->iov_base + head->iov_len;\n\t/* (otherwise assume xdr->end is already set) */\n\txdr->page_ptr--;\n\thead->iov_len = len;\n\tbuf->len = len;\n\txdr->p = head->iov_base + head->iov_len;\n\txdr->iov = buf->head;\n}\nEXPORT_SYMBOL(xdr_truncate_encode);\n\n/**\n * xdr_restrict_buflen - decrease available buffer space\n * @xdr: pointer to xdr_stream\n * @newbuflen: new maximum number of bytes available\n *\n * Adjust our idea of how much space is available in the buffer.\n * If we've already used too much space in the buffer, returns -1.\n * If the available space is already smaller than newbuflen, returns 0\n * and does nothing.  Otherwise, adjusts xdr->buf->buflen to newbuflen\n * and ensures xdr->end is set at most offset newbuflen from the start\n * of the buffer.\n */\nint xdr_restrict_buflen(struct xdr_stream *xdr, int newbuflen)\n{\n\tstruct xdr_buf *buf = xdr->buf;\n\tint left_in_this_buf = (void *)xdr->end - (void *)xdr->p;\n\tint end_offset = buf->len + left_in_this_buf;\n\n\tif (newbuflen < 0 || newbuflen < buf->len)\n\t\treturn -1;\n\tif (newbuflen > buf->buflen)\n\t\treturn 0;\n\tif (newbuflen < end_offset)\n\t\txdr->end = (void *)xdr->end + newbuflen - end_offset;\n\tbuf->buflen = newbuflen;\n\treturn 0;\n}\nEXPORT_SYMBOL(xdr_restrict_buflen);\n\n/**\n * xdr_write_pages - Insert a list of pages into an XDR buffer for sending\n * @xdr: pointer to xdr_stream\n * @pages: list of pages\n * @base: offset of first byte\n * @len: length of data in bytes\n *\n */\nvoid xdr_write_pages(struct xdr_stream *xdr, struct page **pages, unsigned int base,\n\t\t unsigned int len)\n{\n\tstruct xdr_buf *buf = xdr->buf;\n\tstruct kvec *iov = buf->tail;\n\tbuf->pages = pages;\n\tbuf->page_base = base;\n\tbuf->page_len = len;\n\n\tiov->iov_base = (char *)xdr->p;\n\tiov->iov_len  = 0;\n\txdr->iov = iov;\n\n\tif (len & 3) {\n\t\tunsigned int pad = 4 - (len & 3);\n\n\t\tBUG_ON(xdr->p >= xdr->end);\n\t\tiov->iov_base = (char *)xdr->p + (len & 3);\n\t\tiov->iov_len  += pad;\n\t\tlen += pad;\n\t\t*xdr->p++ = 0;\n\t}\n\tbuf->buflen += len;\n\tbuf->len += len;\n}\nEXPORT_SYMBOL_GPL(xdr_write_pages);\n\nstatic unsigned int xdr_set_iov(struct xdr_stream *xdr, struct kvec *iov,\n\t\t\t\tunsigned int base, unsigned int len)\n{\n\tif (len > iov->iov_len)\n\t\tlen = iov->iov_len;\n\tif (unlikely(base > len))\n\t\tbase = len;\n\txdr->p = (__be32*)(iov->iov_base + base);\n\txdr->end = (__be32*)(iov->iov_base + len);\n\txdr->iov = iov;\n\txdr->page_ptr = NULL;\n\treturn len - base;\n}\n\nstatic unsigned int xdr_set_tail_base(struct xdr_stream *xdr,\n\t\t\t\t      unsigned int base, unsigned int len)\n{\n\tstruct xdr_buf *buf = xdr->buf;\n\n\txdr_stream_set_pos(xdr, base + buf->page_len + buf->head->iov_len);\n\treturn xdr_set_iov(xdr, buf->tail, base, len);\n}\n\nstatic unsigned int xdr_set_page_base(struct xdr_stream *xdr,\n\t\t\t\t      unsigned int base, unsigned int len)\n{\n\tunsigned int pgnr;\n\tunsigned int maxlen;\n\tunsigned int pgoff;\n\tunsigned int pgend;\n\tvoid *kaddr;\n\n\tmaxlen = xdr->buf->page_len;\n\tif (base >= maxlen)\n\t\treturn 0;\n\telse\n\t\tmaxlen -= base;\n\tif (len > maxlen)\n\t\tlen = maxlen;\n\n\txdr_stream_page_set_pos(xdr, base);\n\tbase += xdr->buf->page_base;\n\n\tpgnr = base >> PAGE_SHIFT;\n\txdr->page_ptr = &xdr->buf->pages[pgnr];\n\tkaddr = page_address(*xdr->page_ptr);\n\n\tpgoff = base & ~PAGE_MASK;\n\txdr->p = (__be32*)(kaddr + pgoff);\n\n\tpgend = pgoff + len;\n\tif (pgend > PAGE_SIZE)\n\t\tpgend = PAGE_SIZE;\n\txdr->end = (__be32*)(kaddr + pgend);\n\txdr->iov = NULL;\n\treturn len;\n}\n\nstatic void xdr_set_page(struct xdr_stream *xdr, unsigned int base,\n\t\t\t unsigned int len)\n{\n\tif (xdr_set_page_base(xdr, base, len) == 0) {\n\t\tbase -= xdr->buf->page_len;\n\t\txdr_set_tail_base(xdr, base, len);\n\t}\n}\n\nstatic void xdr_set_next_page(struct xdr_stream *xdr)\n{\n\tunsigned int newbase;\n\n\tnewbase = (1 + xdr->page_ptr - xdr->buf->pages) << PAGE_SHIFT;\n\tnewbase -= xdr->buf->page_base;\n\tif (newbase < xdr->buf->page_len)\n\t\txdr_set_page_base(xdr, newbase, xdr_stream_remaining(xdr));\n\telse\n\t\txdr_set_tail_base(xdr, 0, xdr_stream_remaining(xdr));\n}\n\nstatic bool xdr_set_next_buffer(struct xdr_stream *xdr)\n{\n\tif (xdr->page_ptr != NULL)\n\t\txdr_set_next_page(xdr);\n\telse if (xdr->iov == xdr->buf->head)\n\t\txdr_set_page(xdr, 0, xdr_stream_remaining(xdr));\n\treturn xdr->p != xdr->end;\n}\n\n/**\n * xdr_init_decode - Initialize an xdr_stream for decoding data.\n * @xdr: pointer to xdr_stream struct\n * @buf: pointer to XDR buffer from which to decode data\n * @p: current pointer inside XDR buffer\n * @rqst: pointer to controlling rpc_rqst, for debugging\n */\nvoid xdr_init_decode(struct xdr_stream *xdr, struct xdr_buf *buf, __be32 *p,\n\t\t     struct rpc_rqst *rqst)\n{\n\txdr->buf = buf;\n\txdr_reset_scratch_buffer(xdr);\n\txdr->nwords = XDR_QUADLEN(buf->len);\n\tif (xdr_set_iov(xdr, buf->head, 0, buf->len) == 0 &&\n\t    xdr_set_page_base(xdr, 0, buf->len) == 0)\n\t\txdr_set_iov(xdr, buf->tail, 0, buf->len);\n\tif (p != NULL && p > xdr->p && xdr->end >= p) {\n\t\txdr->nwords -= p - xdr->p;\n\t\txdr->p = p;\n\t}\n\txdr->rqst = rqst;\n}\nEXPORT_SYMBOL_GPL(xdr_init_decode);\n\n/**\n * xdr_init_decode_pages - Initialize an xdr_stream for decoding into pages\n * @xdr: pointer to xdr_stream struct\n * @buf: pointer to XDR buffer from which to decode data\n * @pages: list of pages to decode into\n * @len: length in bytes of buffer in pages\n */\nvoid xdr_init_decode_pages(struct xdr_stream *xdr, struct xdr_buf *buf,\n\t\t\t   struct page **pages, unsigned int len)\n{\n\tmemset(buf, 0, sizeof(*buf));\n\tbuf->pages =  pages;\n\tbuf->page_len =  len;\n\tbuf->buflen =  len;\n\tbuf->len = len;\n\txdr_init_decode(xdr, buf, NULL, NULL);\n}\nEXPORT_SYMBOL_GPL(xdr_init_decode_pages);\n\nstatic __be32 * __xdr_inline_decode(struct xdr_stream *xdr, size_t nbytes)\n{\n\tunsigned int nwords = XDR_QUADLEN(nbytes);\n\t__be32 *p = xdr->p;\n\t__be32 *q = p + nwords;\n\n\tif (unlikely(nwords > xdr->nwords || q > xdr->end || q < p))\n\t\treturn NULL;\n\txdr->p = q;\n\txdr->nwords -= nwords;\n\treturn p;\n}\n\nstatic __be32 *xdr_copy_to_scratch(struct xdr_stream *xdr, size_t nbytes)\n{\n\t__be32 *p;\n\tchar *cpdest = xdr->scratch.iov_base;\n\tsize_t cplen = (char *)xdr->end - (char *)xdr->p;\n\n\tif (nbytes > xdr->scratch.iov_len)\n\t\tgoto out_overflow;\n\tp = __xdr_inline_decode(xdr, cplen);\n\tif (p == NULL)\n\t\treturn NULL;\n\tmemcpy(cpdest, p, cplen);\n\tif (!xdr_set_next_buffer(xdr))\n\t\tgoto out_overflow;\n\tcpdest += cplen;\n\tnbytes -= cplen;\n\tp = __xdr_inline_decode(xdr, nbytes);\n\tif (p == NULL)\n\t\treturn NULL;\n\tmemcpy(cpdest, p, nbytes);\n\treturn xdr->scratch.iov_base;\nout_overflow:\n\ttrace_rpc_xdr_overflow(xdr, nbytes);\n\treturn NULL;\n}\n\n/**\n * xdr_inline_decode - Retrieve XDR data to decode\n * @xdr: pointer to xdr_stream struct\n * @nbytes: number of bytes of data to decode\n *\n * Check if the input buffer is long enough to enable us to decode\n * 'nbytes' more bytes of data starting at the current position.\n * If so return the current pointer, then update the current\n * pointer position.\n */\n__be32 * xdr_inline_decode(struct xdr_stream *xdr, size_t nbytes)\n{\n\t__be32 *p;\n\n\tif (unlikely(nbytes == 0))\n\t\treturn xdr->p;\n\tif (xdr->p == xdr->end && !xdr_set_next_buffer(xdr))\n\t\tgoto out_overflow;\n\tp = __xdr_inline_decode(xdr, nbytes);\n\tif (p != NULL)\n\t\treturn p;\n\treturn xdr_copy_to_scratch(xdr, nbytes);\nout_overflow:\n\ttrace_rpc_xdr_overflow(xdr, nbytes);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(xdr_inline_decode);\n\nstatic void xdr_realign_pages(struct xdr_stream *xdr)\n{\n\tstruct xdr_buf *buf = xdr->buf;\n\tstruct kvec *iov = buf->head;\n\tunsigned int cur = xdr_stream_pos(xdr);\n\tunsigned int copied;\n\n\t/* Realign pages to current pointer position */\n\tif (iov->iov_len > cur) {\n\t\tcopied = xdr_shrink_bufhead(buf, cur);\n\t\ttrace_rpc_xdr_alignment(xdr, cur, copied);\n\t\txdr_set_page(xdr, 0, buf->page_len);\n\t}\n}\n\nstatic unsigned int xdr_align_pages(struct xdr_stream *xdr, unsigned int len)\n{\n\tstruct xdr_buf *buf = xdr->buf;\n\tunsigned int nwords = XDR_QUADLEN(len);\n\tunsigned int copied;\n\n\tif (xdr->nwords == 0)\n\t\treturn 0;\n\n\txdr_realign_pages(xdr);\n\tif (nwords > xdr->nwords) {\n\t\tnwords = xdr->nwords;\n\t\tlen = nwords << 2;\n\t}\n\tif (buf->page_len <= len)\n\t\tlen = buf->page_len;\n\telse if (nwords < xdr->nwords) {\n\t\t/* Truncate page data and move it into the tail */\n\t\tcopied = xdr_shrink_pagelen(buf, len);\n\t\ttrace_rpc_xdr_alignment(xdr, len, copied);\n\t}\n\treturn len;\n}\n\n/**\n * xdr_read_pages - align page-based XDR data to current pointer position\n * @xdr: pointer to xdr_stream struct\n * @len: number of bytes of page data\n *\n * Moves data beyond the current pointer position from the XDR head[] buffer\n * into the page list. Any data that lies beyond current position + @len\n * bytes is moved into the XDR tail[]. The xdr_stream current position is\n * then advanced past that data to align to the next XDR object in the tail.\n *\n * Returns the number of XDR encoded bytes now contained in the pages\n */\nunsigned int xdr_read_pages(struct xdr_stream *xdr, unsigned int len)\n{\n\tunsigned int nwords = XDR_QUADLEN(len);\n\tunsigned int base, end, pglen;\n\n\tpglen = xdr_align_pages(xdr, nwords << 2);\n\tif (pglen == 0)\n\t\treturn 0;\n\n\tbase = (nwords << 2) - pglen;\n\tend = xdr_stream_remaining(xdr) - pglen;\n\n\txdr_set_tail_base(xdr, base, end);\n\treturn len <= pglen ? len : pglen;\n}\nEXPORT_SYMBOL_GPL(xdr_read_pages);\n\nunsigned int xdr_align_data(struct xdr_stream *xdr, unsigned int offset,\n\t\t\t    unsigned int length)\n{\n\tstruct xdr_buf *buf = xdr->buf;\n\tunsigned int from, bytes, len;\n\tunsigned int shift;\n\n\txdr_realign_pages(xdr);\n\tfrom = xdr_page_pos(xdr);\n\n\tif (from >= buf->page_len + buf->tail->iov_len)\n\t\treturn 0;\n\tif (from + buf->head->iov_len >= buf->len)\n\t\treturn 0;\n\n\tlen = buf->len - buf->head->iov_len;\n\n\t/* We only shift data left! */\n\tif (WARN_ONCE(from < offset, \"SUNRPC: misaligned data src=%u dst=%u\\n\",\n\t\t      from, offset))\n\t\treturn 0;\n\tif (WARN_ONCE(offset > buf->page_len,\n\t\t      \"SUNRPC: buffer overflow. offset=%u, page_len=%u\\n\",\n\t\t      offset, buf->page_len))\n\t\treturn 0;\n\n\t/* Move page data to the left */\n\tshift = from - offset;\n\txdr_buf_pages_shift_left(buf, from, len, shift);\n\n\tbytes = xdr_stream_remaining(xdr);\n\tif (length > bytes)\n\t\tlength = bytes;\n\tbytes -= length;\n\n\txdr->buf->len -= shift;\n\txdr_set_page(xdr, offset + length, bytes);\n\treturn length;\n}\nEXPORT_SYMBOL_GPL(xdr_align_data);\n\nunsigned int xdr_expand_hole(struct xdr_stream *xdr, unsigned int offset,\n\t\t\t     unsigned int length)\n{\n\tstruct xdr_buf *buf = xdr->buf;\n\tunsigned int from, to, shift;\n\n\txdr_realign_pages(xdr);\n\tfrom = xdr_page_pos(xdr);\n\tto = xdr_align_size(offset + length);\n\n\t/* Could the hole be behind us? */\n\tif (to > from) {\n\t\tunsigned int buflen = buf->len - buf->head->iov_len;\n\t\tshift = to - from;\n\t\txdr_buf_try_expand(buf, shift);\n\t\txdr_buf_pages_shift_right(buf, from, buflen, shift);\n\t\txdr_set_page(xdr, to, xdr_stream_remaining(xdr));\n\t} else if (to != from)\n\t\txdr_align_data(xdr, to, 0);\n\txdr_buf_pages_zero(buf, offset, length);\n\n\treturn length;\n}\nEXPORT_SYMBOL_GPL(xdr_expand_hole);\n\n/**\n * xdr_enter_page - decode data from the XDR page\n * @xdr: pointer to xdr_stream struct\n * @len: number of bytes of page data\n *\n * Moves data beyond the current pointer position from the XDR head[] buffer\n * into the page list. Any data that lies beyond current position + \"len\"\n * bytes is moved into the XDR tail[]. The current pointer is then\n * repositioned at the beginning of the first XDR page.\n */\nvoid xdr_enter_page(struct xdr_stream *xdr, unsigned int len)\n{\n\tlen = xdr_align_pages(xdr, len);\n\t/*\n\t * Position current pointer at beginning of tail, and\n\t * set remaining message length.\n\t */\n\tif (len != 0)\n\t\txdr_set_page_base(xdr, 0, len);\n}\nEXPORT_SYMBOL_GPL(xdr_enter_page);\n\nstatic const struct kvec empty_iov = {.iov_base = NULL, .iov_len = 0};\n\nvoid xdr_buf_from_iov(const struct kvec *iov, struct xdr_buf *buf)\n{\n\tbuf->head[0] = *iov;\n\tbuf->tail[0] = empty_iov;\n\tbuf->page_len = 0;\n\tbuf->buflen = buf->len = iov->iov_len;\n}\nEXPORT_SYMBOL_GPL(xdr_buf_from_iov);\n\n/**\n * xdr_buf_subsegment - set subbuf to a portion of buf\n * @buf: an xdr buffer\n * @subbuf: the result buffer\n * @base: beginning of range in bytes\n * @len: length of range in bytes\n *\n * sets @subbuf to an xdr buffer representing the portion of @buf of\n * length @len starting at offset @base.\n *\n * @buf and @subbuf may be pointers to the same struct xdr_buf.\n *\n * Returns -1 if base of length are out of bounds.\n */\nint xdr_buf_subsegment(const struct xdr_buf *buf, struct xdr_buf *subbuf,\n\t\t       unsigned int base, unsigned int len)\n{\n\tsubbuf->buflen = subbuf->len = len;\n\tif (base < buf->head[0].iov_len) {\n\t\tsubbuf->head[0].iov_base = buf->head[0].iov_base + base;\n\t\tsubbuf->head[0].iov_len = min_t(unsigned int, len,\n\t\t\t\t\t\tbuf->head[0].iov_len - base);\n\t\tlen -= subbuf->head[0].iov_len;\n\t\tbase = 0;\n\t} else {\n\t\tbase -= buf->head[0].iov_len;\n\t\tsubbuf->head[0].iov_base = buf->head[0].iov_base;\n\t\tsubbuf->head[0].iov_len = 0;\n\t}\n\n\tif (base < buf->page_len) {\n\t\tsubbuf->page_len = min(buf->page_len - base, len);\n\t\tbase += buf->page_base;\n\t\tsubbuf->page_base = base & ~PAGE_MASK;\n\t\tsubbuf->pages = &buf->pages[base >> PAGE_SHIFT];\n\t\tlen -= subbuf->page_len;\n\t\tbase = 0;\n\t} else {\n\t\tbase -= buf->page_len;\n\t\tsubbuf->pages = buf->pages;\n\t\tsubbuf->page_base = 0;\n\t\tsubbuf->page_len = 0;\n\t}\n\n\tif (base < buf->tail[0].iov_len) {\n\t\tsubbuf->tail[0].iov_base = buf->tail[0].iov_base + base;\n\t\tsubbuf->tail[0].iov_len = min_t(unsigned int, len,\n\t\t\t\t\t\tbuf->tail[0].iov_len - base);\n\t\tlen -= subbuf->tail[0].iov_len;\n\t\tbase = 0;\n\t} else {\n\t\tbase -= buf->tail[0].iov_len;\n\t\tsubbuf->tail[0].iov_base = buf->tail[0].iov_base;\n\t\tsubbuf->tail[0].iov_len = 0;\n\t}\n\n\tif (base || len)\n\t\treturn -1;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(xdr_buf_subsegment);\n\n/**\n * xdr_stream_subsegment - set @subbuf to a portion of @xdr\n * @xdr: an xdr_stream set up for decoding\n * @subbuf: the result buffer\n * @nbytes: length of @xdr to extract, in bytes\n *\n * Sets up @subbuf to represent a portion of @xdr. The portion\n * starts at the current offset in @xdr, and extends for a length\n * of @nbytes. If this is successful, @xdr is advanced to the next\n * position following that portion.\n *\n * Return values:\n *   %true: @subbuf has been initialized, and @xdr has been advanced.\n *   %false: a bounds error has occurred\n */\nbool xdr_stream_subsegment(struct xdr_stream *xdr, struct xdr_buf *subbuf,\n\t\t\t   unsigned int nbytes)\n{\n\tunsigned int remaining, offset, len;\n\n\tif (xdr_buf_subsegment(xdr->buf, subbuf, xdr_stream_pos(xdr), nbytes))\n\t\treturn false;\n\n\tif (subbuf->head[0].iov_len)\n\t\tif (!__xdr_inline_decode(xdr, subbuf->head[0].iov_len))\n\t\t\treturn false;\n\n\tremaining = subbuf->page_len;\n\toffset = subbuf->page_base;\n\twhile (remaining) {\n\t\tlen = min_t(unsigned int, remaining, PAGE_SIZE) - offset;\n\n\t\tif (xdr->p == xdr->end && !xdr_set_next_buffer(xdr))\n\t\t\treturn false;\n\t\tif (!__xdr_inline_decode(xdr, len))\n\t\t\treturn false;\n\n\t\tremaining -= len;\n\t\toffset = 0;\n\t}\n\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(xdr_stream_subsegment);\n\n/**\n * xdr_buf_trim - lop at most \"len\" bytes off the end of \"buf\"\n * @buf: buf to be trimmed\n * @len: number of bytes to reduce \"buf\" by\n *\n * Trim an xdr_buf by the given number of bytes by fixing up the lengths. Note\n * that it's possible that we'll trim less than that amount if the xdr_buf is\n * too small, or if (for instance) it's all in the head and the parser has\n * already read too far into it.\n */\nvoid xdr_buf_trim(struct xdr_buf *buf, unsigned int len)\n{\n\tsize_t cur;\n\tunsigned int trim = len;\n\n\tif (buf->tail[0].iov_len) {\n\t\tcur = min_t(size_t, buf->tail[0].iov_len, trim);\n\t\tbuf->tail[0].iov_len -= cur;\n\t\ttrim -= cur;\n\t\tif (!trim)\n\t\t\tgoto fix_len;\n\t}\n\n\tif (buf->page_len) {\n\t\tcur = min_t(unsigned int, buf->page_len, trim);\n\t\tbuf->page_len -= cur;\n\t\ttrim -= cur;\n\t\tif (!trim)\n\t\t\tgoto fix_len;\n\t}\n\n\tif (buf->head[0].iov_len) {\n\t\tcur = min_t(size_t, buf->head[0].iov_len, trim);\n\t\tbuf->head[0].iov_len -= cur;\n\t\ttrim -= cur;\n\t}\nfix_len:\n\tbuf->len -= (len - trim);\n}\nEXPORT_SYMBOL_GPL(xdr_buf_trim);\n\nstatic void __read_bytes_from_xdr_buf(const struct xdr_buf *subbuf,\n\t\t\t\t      void *obj, unsigned int len)\n{\n\tunsigned int this_len;\n\n\tthis_len = min_t(unsigned int, len, subbuf->head[0].iov_len);\n\tmemcpy(obj, subbuf->head[0].iov_base, this_len);\n\tlen -= this_len;\n\tobj += this_len;\n\tthis_len = min_t(unsigned int, len, subbuf->page_len);\n\t_copy_from_pages(obj, subbuf->pages, subbuf->page_base, this_len);\n\tlen -= this_len;\n\tobj += this_len;\n\tthis_len = min_t(unsigned int, len, subbuf->tail[0].iov_len);\n\tmemcpy(obj, subbuf->tail[0].iov_base, this_len);\n}\n\n/* obj is assumed to point to allocated memory of size at least len: */\nint read_bytes_from_xdr_buf(const struct xdr_buf *buf, unsigned int base,\n\t\t\t    void *obj, unsigned int len)\n{\n\tstruct xdr_buf subbuf;\n\tint status;\n\n\tstatus = xdr_buf_subsegment(buf, &subbuf, base, len);\n\tif (status != 0)\n\t\treturn status;\n\t__read_bytes_from_xdr_buf(&subbuf, obj, len);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(read_bytes_from_xdr_buf);\n\nstatic void __write_bytes_to_xdr_buf(const struct xdr_buf *subbuf,\n\t\t\t\t     void *obj, unsigned int len)\n{\n\tunsigned int this_len;\n\n\tthis_len = min_t(unsigned int, len, subbuf->head[0].iov_len);\n\tmemcpy(subbuf->head[0].iov_base, obj, this_len);\n\tlen -= this_len;\n\tobj += this_len;\n\tthis_len = min_t(unsigned int, len, subbuf->page_len);\n\t_copy_to_pages(subbuf->pages, subbuf->page_base, obj, this_len);\n\tlen -= this_len;\n\tobj += this_len;\n\tthis_len = min_t(unsigned int, len, subbuf->tail[0].iov_len);\n\tmemcpy(subbuf->tail[0].iov_base, obj, this_len);\n}\n\n/* obj is assumed to point to allocated memory of size at least len: */\nint write_bytes_to_xdr_buf(const struct xdr_buf *buf, unsigned int base,\n\t\t\t   void *obj, unsigned int len)\n{\n\tstruct xdr_buf subbuf;\n\tint status;\n\n\tstatus = xdr_buf_subsegment(buf, &subbuf, base, len);\n\tif (status != 0)\n\t\treturn status;\n\t__write_bytes_to_xdr_buf(&subbuf, obj, len);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(write_bytes_to_xdr_buf);\n\nint xdr_decode_word(const struct xdr_buf *buf, unsigned int base, u32 *obj)\n{\n\t__be32\traw;\n\tint\tstatus;\n\n\tstatus = read_bytes_from_xdr_buf(buf, base, &raw, sizeof(*obj));\n\tif (status)\n\t\treturn status;\n\t*obj = be32_to_cpu(raw);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(xdr_decode_word);\n\nint xdr_encode_word(const struct xdr_buf *buf, unsigned int base, u32 obj)\n{\n\t__be32\traw = cpu_to_be32(obj);\n\n\treturn write_bytes_to_xdr_buf(buf, base, &raw, sizeof(obj));\n}\nEXPORT_SYMBOL_GPL(xdr_encode_word);\n\n/* Returns 0 on success, or else a negative error code. */\nstatic int xdr_xcode_array2(const struct xdr_buf *buf, unsigned int base,\n\t\t\t    struct xdr_array2_desc *desc, int encode)\n{\n\tchar *elem = NULL, *c;\n\tunsigned int copied = 0, todo, avail_here;\n\tstruct page **ppages = NULL;\n\tint err;\n\n\tif (encode) {\n\t\tif (xdr_encode_word(buf, base, desc->array_len) != 0)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (xdr_decode_word(buf, base, &desc->array_len) != 0 ||\n\t\t    desc->array_len > desc->array_maxlen ||\n\t\t    (unsigned long) base + 4 + desc->array_len *\n\t\t\t\t    desc->elem_size > buf->len)\n\t\t\treturn -EINVAL;\n\t}\n\tbase += 4;\n\n\tif (!desc->xcode)\n\t\treturn 0;\n\n\ttodo = desc->array_len * desc->elem_size;\n\n\t/* process head */\n\tif (todo && base < buf->head->iov_len) {\n\t\tc = buf->head->iov_base + base;\n\t\tavail_here = min_t(unsigned int, todo,\n\t\t\t\t   buf->head->iov_len - base);\n\t\ttodo -= avail_here;\n\n\t\twhile (avail_here >= desc->elem_size) {\n\t\t\terr = desc->xcode(desc, c);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tc += desc->elem_size;\n\t\t\tavail_here -= desc->elem_size;\n\t\t}\n\t\tif (avail_here) {\n\t\t\tif (!elem) {\n\t\t\t\telem = kmalloc(desc->elem_size, GFP_KERNEL);\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tif (!elem)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (encode) {\n\t\t\t\terr = desc->xcode(desc, elem);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out;\n\t\t\t\tmemcpy(c, elem, avail_here);\n\t\t\t} else\n\t\t\t\tmemcpy(elem, c, avail_here);\n\t\t\tcopied = avail_here;\n\t\t}\n\t\tbase = buf->head->iov_len;  /* align to start of pages */\n\t}\n\n\t/* process pages array */\n\tbase -= buf->head->iov_len;\n\tif (todo && base < buf->page_len) {\n\t\tunsigned int avail_page;\n\n\t\tavail_here = min(todo, buf->page_len - base);\n\t\ttodo -= avail_here;\n\n\t\tbase += buf->page_base;\n\t\tppages = buf->pages + (base >> PAGE_SHIFT);\n\t\tbase &= ~PAGE_MASK;\n\t\tavail_page = min_t(unsigned int, PAGE_SIZE - base,\n\t\t\t\t\tavail_here);\n\t\tc = kmap(*ppages) + base;\n\n\t\twhile (avail_here) {\n\t\t\tavail_here -= avail_page;\n\t\t\tif (copied || avail_page < desc->elem_size) {\n\t\t\t\tunsigned int l = min(avail_page,\n\t\t\t\t\tdesc->elem_size - copied);\n\t\t\t\tif (!elem) {\n\t\t\t\t\telem = kmalloc(desc->elem_size,\n\t\t\t\t\t\t       GFP_KERNEL);\n\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\tif (!elem)\n\t\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (encode) {\n\t\t\t\t\tif (!copied) {\n\t\t\t\t\t\terr = desc->xcode(desc, elem);\n\t\t\t\t\t\tif (err)\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\tmemcpy(c, elem + copied, l);\n\t\t\t\t\tcopied += l;\n\t\t\t\t\tif (copied == desc->elem_size)\n\t\t\t\t\t\tcopied = 0;\n\t\t\t\t} else {\n\t\t\t\t\tmemcpy(elem + copied, c, l);\n\t\t\t\t\tcopied += l;\n\t\t\t\t\tif (copied == desc->elem_size) {\n\t\t\t\t\t\terr = desc->xcode(desc, elem);\n\t\t\t\t\t\tif (err)\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\tcopied = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tavail_page -= l;\n\t\t\t\tc += l;\n\t\t\t}\n\t\t\twhile (avail_page >= desc->elem_size) {\n\t\t\t\terr = desc->xcode(desc, c);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out;\n\t\t\t\tc += desc->elem_size;\n\t\t\t\tavail_page -= desc->elem_size;\n\t\t\t}\n\t\t\tif (avail_page) {\n\t\t\t\tunsigned int l = min(avail_page,\n\t\t\t\t\t    desc->elem_size - copied);\n\t\t\t\tif (!elem) {\n\t\t\t\t\telem = kmalloc(desc->elem_size,\n\t\t\t\t\t\t       GFP_KERNEL);\n\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\tif (!elem)\n\t\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (encode) {\n\t\t\t\t\tif (!copied) {\n\t\t\t\t\t\terr = desc->xcode(desc, elem);\n\t\t\t\t\t\tif (err)\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\tmemcpy(c, elem + copied, l);\n\t\t\t\t\tcopied += l;\n\t\t\t\t\tif (copied == desc->elem_size)\n\t\t\t\t\t\tcopied = 0;\n\t\t\t\t} else {\n\t\t\t\t\tmemcpy(elem + copied, c, l);\n\t\t\t\t\tcopied += l;\n\t\t\t\t\tif (copied == desc->elem_size) {\n\t\t\t\t\t\terr = desc->xcode(desc, elem);\n\t\t\t\t\t\tif (err)\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\tcopied = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (avail_here) {\n\t\t\t\tkunmap(*ppages);\n\t\t\t\tppages++;\n\t\t\t\tc = kmap(*ppages);\n\t\t\t}\n\n\t\t\tavail_page = min(avail_here,\n\t\t\t\t (unsigned int) PAGE_SIZE);\n\t\t}\n\t\tbase = buf->page_len;  /* align to start of tail */\n\t}\n\n\t/* process tail */\n\tbase -= buf->page_len;\n\tif (todo) {\n\t\tc = buf->tail->iov_base + base;\n\t\tif (copied) {\n\t\t\tunsigned int l = desc->elem_size - copied;\n\n\t\t\tif (encode)\n\t\t\t\tmemcpy(c, elem + copied, l);\n\t\t\telse {\n\t\t\t\tmemcpy(elem + copied, c, l);\n\t\t\t\terr = desc->xcode(desc, elem);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\ttodo -= l;\n\t\t\tc += l;\n\t\t}\n\t\twhile (todo) {\n\t\t\terr = desc->xcode(desc, c);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tc += desc->elem_size;\n\t\t\ttodo -= desc->elem_size;\n\t\t}\n\t}\n\terr = 0;\n\nout:\n\tkfree(elem);\n\tif (ppages)\n\t\tkunmap(*ppages);\n\treturn err;\n}\n\nint xdr_decode_array2(const struct xdr_buf *buf, unsigned int base,\n\t\t      struct xdr_array2_desc *desc)\n{\n\tif (base >= buf->len)\n\t\treturn -EINVAL;\n\n\treturn xdr_xcode_array2(buf, base, desc, 0);\n}\nEXPORT_SYMBOL_GPL(xdr_decode_array2);\n\nint xdr_encode_array2(const struct xdr_buf *buf, unsigned int base,\n\t\t      struct xdr_array2_desc *desc)\n{\n\tif ((unsigned long) base + 4 + desc->array_len * desc->elem_size >\n\t    buf->head->iov_len + buf->page_len + buf->tail->iov_len)\n\t\treturn -EINVAL;\n\n\treturn xdr_xcode_array2(buf, base, desc, 1);\n}\nEXPORT_SYMBOL_GPL(xdr_encode_array2);\n\nint xdr_process_buf(const struct xdr_buf *buf, unsigned int offset,\n\t\t    unsigned int len,\n\t\t    int (*actor)(struct scatterlist *, void *), void *data)\n{\n\tint i, ret = 0;\n\tunsigned int page_len, thislen, page_offset;\n\tstruct scatterlist      sg[1];\n\n\tsg_init_table(sg, 1);\n\n\tif (offset >= buf->head[0].iov_len) {\n\t\toffset -= buf->head[0].iov_len;\n\t} else {\n\t\tthislen = buf->head[0].iov_len - offset;\n\t\tif (thislen > len)\n\t\t\tthislen = len;\n\t\tsg_set_buf(sg, buf->head[0].iov_base + offset, thislen);\n\t\tret = actor(sg, data);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\toffset = 0;\n\t\tlen -= thislen;\n\t}\n\tif (len == 0)\n\t\tgoto out;\n\n\tif (offset >= buf->page_len) {\n\t\toffset -= buf->page_len;\n\t} else {\n\t\tpage_len = buf->page_len - offset;\n\t\tif (page_len > len)\n\t\t\tpage_len = len;\n\t\tlen -= page_len;\n\t\tpage_offset = (offset + buf->page_base) & (PAGE_SIZE - 1);\n\t\ti = (offset + buf->page_base) >> PAGE_SHIFT;\n\t\tthislen = PAGE_SIZE - page_offset;\n\t\tdo {\n\t\t\tif (thislen > page_len)\n\t\t\t\tthislen = page_len;\n\t\t\tsg_set_page(sg, buf->pages[i], thislen, page_offset);\n\t\t\tret = actor(sg, data);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tpage_len -= thislen;\n\t\t\ti++;\n\t\t\tpage_offset = 0;\n\t\t\tthislen = PAGE_SIZE;\n\t\t} while (page_len != 0);\n\t\toffset = 0;\n\t}\n\tif (len == 0)\n\t\tgoto out;\n\tif (offset < buf->tail[0].iov_len) {\n\t\tthislen = buf->tail[0].iov_len - offset;\n\t\tif (thislen > len)\n\t\t\tthislen = len;\n\t\tsg_set_buf(sg, buf->tail[0].iov_base + offset, thislen);\n\t\tret = actor(sg, data);\n\t\tlen -= thislen;\n\t}\n\tif (len != 0)\n\t\tret = -EINVAL;\nout:\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(xdr_process_buf);\n\n/**\n * xdr_stream_decode_opaque - Decode variable length opaque\n * @xdr: pointer to xdr_stream\n * @ptr: location to store opaque data\n * @size: size of storage buffer @ptr\n *\n * Return values:\n *   On success, returns size of object stored in *@ptr\n *   %-EBADMSG on XDR buffer overflow\n *   %-EMSGSIZE on overflow of storage buffer @ptr\n */\nssize_t xdr_stream_decode_opaque(struct xdr_stream *xdr, void *ptr, size_t size)\n{\n\tssize_t ret;\n\tvoid *p;\n\n\tret = xdr_stream_decode_opaque_inline(xdr, &p, size);\n\tif (ret <= 0)\n\t\treturn ret;\n\tmemcpy(ptr, p, ret);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(xdr_stream_decode_opaque);\n\n/**\n * xdr_stream_decode_opaque_dup - Decode and duplicate variable length opaque\n * @xdr: pointer to xdr_stream\n * @ptr: location to store pointer to opaque data\n * @maxlen: maximum acceptable object size\n * @gfp_flags: GFP mask to use\n *\n * Return values:\n *   On success, returns size of object stored in *@ptr\n *   %-EBADMSG on XDR buffer overflow\n *   %-EMSGSIZE if the size of the object would exceed @maxlen\n *   %-ENOMEM on memory allocation failure\n */\nssize_t xdr_stream_decode_opaque_dup(struct xdr_stream *xdr, void **ptr,\n\t\tsize_t maxlen, gfp_t gfp_flags)\n{\n\tssize_t ret;\n\tvoid *p;\n\n\tret = xdr_stream_decode_opaque_inline(xdr, &p, maxlen);\n\tif (ret > 0) {\n\t\t*ptr = kmemdup(p, ret, gfp_flags);\n\t\tif (*ptr != NULL)\n\t\t\treturn ret;\n\t\tret = -ENOMEM;\n\t}\n\t*ptr = NULL;\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(xdr_stream_decode_opaque_dup);\n\n/**\n * xdr_stream_decode_string - Decode variable length string\n * @xdr: pointer to xdr_stream\n * @str: location to store string\n * @size: size of storage buffer @str\n *\n * Return values:\n *   On success, returns length of NUL-terminated string stored in *@str\n *   %-EBADMSG on XDR buffer overflow\n *   %-EMSGSIZE on overflow of storage buffer @str\n */\nssize_t xdr_stream_decode_string(struct xdr_stream *xdr, char *str, size_t size)\n{\n\tssize_t ret;\n\tvoid *p;\n\n\tret = xdr_stream_decode_opaque_inline(xdr, &p, size);\n\tif (ret > 0) {\n\t\tmemcpy(str, p, ret);\n\t\tstr[ret] = '\\0';\n\t\treturn strlen(str);\n\t}\n\t*str = '\\0';\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(xdr_stream_decode_string);\n\n/**\n * xdr_stream_decode_string_dup - Decode and duplicate variable length string\n * @xdr: pointer to xdr_stream\n * @str: location to store pointer to string\n * @maxlen: maximum acceptable string length\n * @gfp_flags: GFP mask to use\n *\n * Return values:\n *   On success, returns length of NUL-terminated string stored in *@ptr\n *   %-EBADMSG on XDR buffer overflow\n *   %-EMSGSIZE if the size of the string would exceed @maxlen\n *   %-ENOMEM on memory allocation failure\n */\nssize_t xdr_stream_decode_string_dup(struct xdr_stream *xdr, char **str,\n\t\tsize_t maxlen, gfp_t gfp_flags)\n{\n\tvoid *p;\n\tssize_t ret;\n\n\tret = xdr_stream_decode_opaque_inline(xdr, &p, maxlen);\n\tif (ret > 0) {\n\t\tchar *s = kmemdup_nul(p, ret, gfp_flags);\n\t\tif (s != NULL) {\n\t\t\t*str = s;\n\t\t\treturn strlen(s);\n\t\t}\n\t\tret = -ENOMEM;\n\t}\n\t*str = NULL;\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(xdr_stream_decode_string_dup);\n"], "filenames": ["net/sunrpc/xdr.c"], "buggy_code_start_loc": [1233], "buggy_code_end_loc": [1237], "fixing_code_start_loc": [1233], "fixing_code_end_loc": [1236], "type": "CWE-119", "message": "net/sunrpc/xdr.c in the Linux kernel before 5.13.4 allows remote attackers to cause a denial of service (xdr_set_page_base slab-out-of-bounds access) by performing many NFS 4.2 READ_PLUS operations.", "other": {"cve": {"id": "CVE-2021-38201", "sourceIdentifier": "cve@mitre.org", "published": "2021-08-08T20:15:07.147", "lastModified": "2021-10-07T20:39:38.217", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "net/sunrpc/xdr.c in the Linux kernel before 5.13.4 allows remote attackers to cause a denial of service (xdr_set_page_base slab-out-of-bounds access) by performing many NFS 4.2 READ_PLUS operations."}, {"lang": "es", "value": "El archivo net/sunrpc/xdr.c en el kernel de Linux versiones anteriores a 5.13.4, permite a atacantes remotos causar una denegaci\u00f3n de servicio (acceso fuera de los l\u00edmites de xdr_set_page_base) al llevar a cabo muchas operaciones NFS 4.2 READ_PLUS"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.13.4", "matchCriteriaId": "4C85356F-2C6C-4FB9-B0CA-949711182223"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:hci_bootstrap_os:-:*:*:*:*:*:*:*", "matchCriteriaId": "1C767AA1-88B7-48F0-9F31-A89D16DCD52C"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:hci_compute_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "AD7447BC-F315-4298-A822-549942FC118B"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:hci_management_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "A3C19813-E823-456A-B1CE-EC0684CE1953"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:solidfire:-:*:*:*:*:*:*:*", "matchCriteriaId": "A6E9EF0C-AFA8-4F7B-9FDC-1E0F7C26E737"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:element_software:-:*:*:*:*:*:*:*", "matchCriteriaId": "85DF4B3F-4BBC-42B7-B729-096934523D63"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:hci_storage_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "02DEB4FB-A21D-4CB1-B522-EEE5093E8521"}]}]}], "references": [{"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.13.4", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/6d1c0f3d28f98ea2736128ed3e46821496dc3a8c", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20210902-0010/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/6d1c0f3d28f98ea2736128ed3e46821496dc3a8c"}}