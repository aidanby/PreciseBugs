{"buggy_code": ["/*\n// Copyright (c) 2018 Intel Corporation\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n*/\n\n#include \"passwd_mgr.hpp\"\n\n#include \"file.hpp\"\n#include \"shadowlock.hpp\"\n\n#include <openssl/hmac.h>\n#include <openssl/rand.h>\n#include <openssl/sha.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\n#include <cerrno>\n#include <cstring>\n#include <fstream>\n#include <iomanip>\n#include <phosphor-logging/log.hpp>\n\nnamespace ipmi\n{\n\nstatic const char* passwdFileName = \"/etc/ipmi_pass\";\nstatic const char* encryptKeyFileName = \"/etc/key_file\";\nstatic const size_t maxKeySize = 8;\n\n#define META_PASSWD_SIG \"=OPENBMC=\"\n\n/*\n * Meta data struct for encrypted password file\n */\nstruct MetaPassStruct\n{\n    char signature[10];\n    unsigned char reseved[2];\n    size_t hashSize;\n    size_t ivSize;\n    size_t dataSize;\n    size_t padSize;\n    size_t macSize;\n};\n\nusing namespace phosphor::logging;\n\nPasswdMgr::PasswdMgr()\n{\n    initPasswordMap();\n}\n\nstd::string PasswdMgr::getPasswdByUserName(const std::string& userName)\n{\n    checkAndReload();\n    auto iter = passwdMapList.find(userName);\n    if (iter == passwdMapList.end())\n    {\n        return std::string();\n    }\n    return iter->second;\n}\n\nint PasswdMgr::updateUserEntry(const std::string& userName,\n                               const std::string& newUserName)\n{\n    std::time_t updatedTime = getUpdatedFileTime();\n    // Check file time stamp to know passwdMapList is up-to-date.\n    // If not up-to-date, then updatePasswdSpecialFile will read and\n    // check the user entry existance.\n    if (fileLastUpdatedTime == updatedTime && updatedTime != -EIO)\n    {\n        if (passwdMapList.find(userName) == passwdMapList.end())\n        {\n            log<level::DEBUG>(\"User not found\");\n            return 0;\n        }\n    }\n\n    // Write passwdMap to Encryted file\n    if (updatePasswdSpecialFile(userName, newUserName) != 0)\n    {\n        log<level::DEBUG>(\"Passwd file update failed\");\n        return -EIO;\n    }\n\n    log<level::DEBUG>(\"Passwd file updated successfully\");\n    return 0;\n}\n\nvoid PasswdMgr::checkAndReload(void)\n{\n    std::time_t updatedTime = getUpdatedFileTime();\n    if (fileLastUpdatedTime != updatedTime && updatedTime != -1)\n    {\n        log<level::DEBUG>(\"Reloading password map list\");\n        passwdMapList.clear();\n        initPasswordMap();\n    }\n}\n\nint PasswdMgr::encryptDecryptData(bool doEncrypt, const EVP_CIPHER* cipher,\n                                  uint8_t* key, size_t keyLen, uint8_t* iv,\n                                  size_t ivLen, uint8_t* inBytes,\n                                  size_t inBytesLen, uint8_t* mac,\n                                  size_t* macLen, unsigned char* outBytes,\n                                  size_t* outBytesLen)\n{\n    if (cipher == NULL || key == NULL || iv == NULL || inBytes == NULL ||\n        outBytes == NULL || mac == NULL || inBytesLen == 0 ||\n        (size_t)EVP_CIPHER_key_length(cipher) > keyLen ||\n        (size_t)EVP_CIPHER_iv_length(cipher) > ivLen)\n    {\n        log<level::DEBUG>(\"Error Invalid Inputs\");\n        return -EINVAL;\n    }\n\n    if (!doEncrypt)\n    {\n        // verify MAC before decrypting the data.\n        std::array<uint8_t, EVP_MAX_MD_SIZE> calMac;\n        size_t calMacLen = calMac.size();\n        // calculate MAC for the encrypted message.\n        if (NULL == HMAC(EVP_sha256(), key, keyLen, inBytes, inBytesLen,\n                         calMac.data(),\n                         reinterpret_cast<unsigned int*>(&calMacLen)))\n        {\n            log<level::DEBUG>(\"Error: Failed to calculate MAC\");\n            return -EIO;\n        }\n        if (!((calMacLen == *macLen) &&\n              (std::memcmp(calMac.data(), mac, calMacLen) == 0)))\n        {\n            log<level::DEBUG>(\"Authenticated message doesn't match\");\n            return -EBADMSG;\n        }\n    }\n\n    std::unique_ptr<EVP_CIPHER_CTX, decltype(&::EVP_CIPHER_CTX_free)> ctx(\n        EVP_CIPHER_CTX_new(), ::EVP_CIPHER_CTX_free);\n    EVP_CIPHER_CTX_set_padding(ctx.get(), 1);\n\n    // Set key & IV\n    int retval = EVP_CipherInit_ex(ctx.get(), cipher, NULL, key, iv,\n                                   static_cast<int>(doEncrypt));\n    if (!retval)\n    {\n        log<level::DEBUG>(\"EVP_CipherInit_ex failed\",\n                          entry(\"RET_VAL=%d\", retval));\n        return -EIO;\n    }\n\n    int outLen = 0, outEVPLen = 0;\n    if ((retval = EVP_CipherUpdate(ctx.get(), outBytes + outLen, &outEVPLen,\n                                   inBytes, inBytesLen)))\n    {\n        outLen += outEVPLen;\n        if ((retval =\n                 EVP_CipherFinal(ctx.get(), outBytes + outLen, &outEVPLen)))\n        {\n            outLen += outEVPLen;\n            *outBytesLen = outLen;\n        }\n        else\n        {\n            log<level::DEBUG>(\"EVP_CipherFinal fails\",\n                              entry(\"RET_VAL=%d\", retval));\n            return -EIO;\n        }\n    }\n    else\n    {\n        log<level::DEBUG>(\"EVP_CipherUpdate fails\",\n                          entry(\"RET_VAL=%d\", retval));\n        return -EIO;\n    }\n\n    if (doEncrypt)\n    {\n        // Create MAC for the encrypted message\n        if (NULL == HMAC(EVP_sha256(), key, keyLen, outBytes, *outBytesLen, mac,\n                         reinterpret_cast<unsigned int*>(macLen)))\n        {\n            log<level::DEBUG>(\"Failed to create authentication\");\n            return -EIO;\n        }\n    }\n    return 0;\n}\n\nvoid PasswdMgr::initPasswordMap(void)\n{\n    phosphor::user::shadow::Lock lock();\n    std::vector<uint8_t> dataBuf;\n\n    if (readPasswdFileData(dataBuf) != 0)\n    {\n        log<level::DEBUG>(\"Error in reading the encrypted pass file\");\n        return;\n    }\n\n    if (dataBuf.size() != 0)\n    {\n        // populate the user list with password\n        char* outPtr = reinterpret_cast<char*>(dataBuf.data());\n        char* nToken = NULL;\n        char* linePtr = strtok_r(outPtr, \"\\n\", &nToken);\n        size_t lineSize = 0;\n        while (linePtr != NULL)\n        {\n            size_t userEPos = 0;\n            std::string lineStr(linePtr);\n            if ((userEPos = lineStr.find(\":\")) != std::string::npos)\n            {\n                lineSize = lineStr.size();\n                passwdMapList.emplace(\n                    lineStr.substr(0, userEPos),\n                    lineStr.substr(userEPos + 1, lineSize - (userEPos + 1)));\n            }\n            linePtr = strtok_r(NULL, \"\\n\", &nToken);\n        }\n    }\n\n    // Update the timestamp\n    fileLastUpdatedTime = getUpdatedFileTime();\n    return;\n}\n\nint PasswdMgr::readPasswdFileData(std::vector<uint8_t>& outBytes)\n{\n    std::array<uint8_t, maxKeySize> keyBuff;\n    std::ifstream keyFile(encryptKeyFileName, std::ios::in | std::ios::binary);\n    if (!keyFile.is_open())\n    {\n        log<level::DEBUG>(\"Error in opening encryption key file\");\n        return -EIO;\n    }\n    keyFile.read(reinterpret_cast<char*>(keyBuff.data()), keyBuff.size());\n    if (keyFile.fail())\n    {\n        log<level::DEBUG>(\"Error in reading encryption key file\");\n        return -EIO;\n    }\n\n    std::ifstream passwdFile(passwdFileName, std::ios::in | std::ios::binary);\n    if (!passwdFile.is_open())\n    {\n        log<level::DEBUG>(\"Error in opening ipmi password file\");\n        return -EIO;\n    }\n\n    // calculate file size and read the data\n    passwdFile.seekg(0, std::ios::end);\n    ssize_t fileSize = passwdFile.tellg();\n    passwdFile.seekg(0, std::ios::beg);\n    std::vector<uint8_t> input(fileSize);\n    passwdFile.read(reinterpret_cast<char*>(input.data()), fileSize);\n    if (passwdFile.fail())\n    {\n        log<level::DEBUG>(\"Error in reading encryption key file\");\n        return -EIO;\n    }\n\n    // verify the signature first\n    MetaPassStruct* metaData = reinterpret_cast<MetaPassStruct*>(input.data());\n    if (std::strncmp(metaData->signature, META_PASSWD_SIG,\n                     sizeof(metaData->signature)))\n    {\n        log<level::DEBUG>(\"Error signature mismatch in password file\");\n        return -EBADMSG;\n    }\n\n    size_t inBytesLen = metaData->dataSize + metaData->padSize;\n    // If data is empty i.e no password map then return success\n    if (inBytesLen == 0)\n    {\n        log<level::DEBUG>(\"Empty password file\");\n        return 0;\n    }\n\n    // compute the key needed to decrypt\n    std::array<uint8_t, EVP_MAX_KEY_LENGTH> key;\n    auto keyLen = key.size();\n    if (NULL == HMAC(EVP_sha256(), keyBuff.data(), keyBuff.size(),\n                     input.data() + sizeof(*metaData), metaData->hashSize,\n                     key.data(), reinterpret_cast<unsigned int*>(&keyLen)))\n    {\n        log<level::DEBUG>(\"Failed to create MAC for authentication\");\n        return -EIO;\n    }\n\n    // decrypt the data\n    uint8_t* iv = input.data() + sizeof(*metaData) + metaData->hashSize;\n    size_t ivLen = metaData->ivSize;\n    uint8_t* inBytes = iv + ivLen;\n    uint8_t* mac = inBytes + inBytesLen;\n    size_t macLen = metaData->macSize;\n\n    size_t outBytesLen = 0;\n    // Resize to actual data size\n    outBytes.resize(inBytesLen + EVP_MAX_BLOCK_LENGTH);\n    if (encryptDecryptData(false, EVP_aes_128_cbc(), key.data(), keyLen, iv,\n                           ivLen, inBytes, inBytesLen, mac, &macLen,\n                           outBytes.data(), &outBytesLen) != 0)\n    {\n        log<level::DEBUG>(\"Error in decryption\");\n        return -EIO;\n    }\n    // Resize the vector to outBytesLen\n    outBytes.resize(outBytesLen);\n\n    OPENSSL_cleanse(key.data(), keyLen);\n    OPENSSL_cleanse(iv, ivLen);\n\n    return 0;\n}\n\nint PasswdMgr::updatePasswdSpecialFile(const std::string& userName,\n                                       const std::string& newUserName)\n{\n    phosphor::user::shadow::Lock lock();\n\n    size_t bytesWritten = 0;\n    size_t inBytesLen = 0;\n    size_t isUsrFound = false;\n    const EVP_CIPHER* cipher = EVP_aes_128_cbc();\n    std::vector<uint8_t> dataBuf;\n\n    // Read the encrypted file and get the file data\n    // Check user existance and return if not exist.\n    if (readPasswdFileData(dataBuf) != 0)\n    {\n        log<level::DEBUG>(\"Error in reading the encrypted pass file\");\n        return -EIO;\n    }\n\n    if (dataBuf.size() != 0)\n    {\n        inBytesLen =\n            dataBuf.size() + newUserName.size() + EVP_CIPHER_block_size(cipher);\n    }\n\n    std::vector<uint8_t> inBytes(inBytesLen);\n    if (inBytesLen != 0)\n    {\n        char* outPtr = reinterpret_cast<char*>(dataBuf.data());\n        char* nToken = NULL;\n        char* linePtr = strtok_r(outPtr, \"\\n\", &nToken);\n        while (linePtr != NULL)\n        {\n            size_t userEPos = 0;\n\n            std::string lineStr(linePtr);\n            if ((userEPos = lineStr.find(\":\")) != std::string::npos)\n            {\n                if (userName.compare(lineStr.substr(0, userEPos)) == 0)\n                {\n                    isUsrFound = true;\n                    if (!newUserName.empty())\n                    {\n                        bytesWritten += std::snprintf(\n                            reinterpret_cast<char*>(&inBytes[0]) + bytesWritten,\n                            (inBytesLen - bytesWritten), \"%s%s\\n\",\n                            newUserName.c_str(),\n                            lineStr.substr(userEPos, lineStr.size()).data());\n                    }\n                }\n                else\n                {\n                    bytesWritten += std::snprintf(\n                        reinterpret_cast<char*>(&inBytes[0]) + bytesWritten,\n                        (inBytesLen - bytesWritten), \"%s\\n\", lineStr.data());\n                }\n            }\n            linePtr = strtok_r(NULL, \"\\n\", &nToken);\n        }\n        inBytesLen = bytesWritten;\n    }\n    if (!isUsrFound)\n    {\n        log<level::DEBUG>(\"User doesn't exist\");\n        return 0;\n    }\n\n    // Read the key buff from key file\n    std::array<uint8_t, maxKeySize> keyBuff;\n    std::ifstream keyFile(encryptKeyFileName, std::ios::in | std::ios::binary);\n    if (!keyFile.good())\n    {\n        log<level::DEBUG>(\"Error in opening encryption key file\");\n        return -EIO;\n    }\n    keyFile.read(reinterpret_cast<char*>(keyBuff.data()), keyBuff.size());\n    if (keyFile.fail())\n    {\n        log<level::DEBUG>(\"Error in reading encryption key file\");\n        return -EIO;\n    }\n    keyFile.close();\n\n    // Read the original passwd file mode\n    struct stat st = {};\n    if (stat(passwdFileName, &st) != 0)\n    {\n        log<level::DEBUG>(\"Error in getting password file fstat()\");\n        return -EIO;\n    }\n\n    // Create temporary file for write\n    std::string pwdFile(passwdFileName);\n    std::vector<char> tempFileName(pwdFile.begin(), pwdFile.end());\n    std::vector<char> fileTemplate = {'_', '_', 'X', 'X', 'X',\n                                      'X', 'X', 'X', '\\0'};\n    tempFileName.insert(tempFileName.end(), fileTemplate.begin(),\n                        fileTemplate.end());\n    int fd = mkstemp((char*)tempFileName.data());\n    if (fd == -1)\n    {\n        log<level::DEBUG>(\"Error creating temp file\");\n        return -EIO;\n    }\n\n    std::string strTempFileName(tempFileName.data());\n    // Open the temp file for writing from provided fd\n    // By \"true\", remove it at exit if still there.\n    // This is needed to cleanup the temp file at exception\n    phosphor::user::File temp(fd, strTempFileName, \"w\", true);\n    if ((temp)() == NULL)\n    {\n        close(fd);\n        log<level::DEBUG>(\"Error creating temp file\");\n        return -EIO;\n    }\n\n    // Set the file mode as of actual ipmi-pass file.\n    if (fchmod(fileno((temp)()), st.st_mode) < 0)\n    {\n        log<level::DEBUG>(\"Error setting fchmod for temp file\");\n        return -EIO;\n    }\n\n    const EVP_MD* digest = EVP_sha256();\n    size_t hashLen = EVP_MD_block_size(digest);\n    std::vector<uint8_t> hash(hashLen);\n    size_t ivLen = EVP_CIPHER_iv_length(cipher);\n    std::vector<uint8_t> iv(ivLen);\n    std::array<uint8_t, EVP_MAX_KEY_LENGTH> key;\n    size_t keyLen = key.size();\n    std::array<uint8_t, EVP_MAX_MD_SIZE> mac;\n    size_t macLen = mac.size();\n\n    // Create random hash and generate hash key which will be used for\n    // encryption.\n    if (RAND_bytes(hash.data(), hashLen) != 1)\n    {\n        log<level::DEBUG>(\"Hash genertion failed, bailing out\");\n        return -EIO;\n    }\n    if (NULL == HMAC(digest, keyBuff.data(), keyBuff.size(), hash.data(),\n                     hashLen, key.data(),\n                     reinterpret_cast<unsigned int*>(&keyLen)))\n    {\n        log<level::DEBUG>(\"Failed to create MAC for authentication\");\n        return -EIO;\n    }\n\n    // Generate IV values\n    if (RAND_bytes(iv.data(), ivLen) != 1)\n    {\n        log<level::DEBUG>(\"UV genertion failed, bailing out\");\n        return -EIO;\n    }\n\n    // Encrypt the input data\n    std::vector<uint8_t> outBytes(inBytesLen + EVP_MAX_BLOCK_LENGTH);\n    size_t outBytesLen = 0;\n    if (inBytesLen != 0)\n    {\n        if (encryptDecryptData(true, EVP_aes_128_cbc(), key.data(), keyLen,\n                               iv.data(), ivLen, inBytes.data(), inBytesLen,\n                               mac.data(), &macLen, outBytes.data(),\n                               &outBytesLen) != 0)\n        {\n            log<level::DEBUG>(\"Error while encrypting the data\");\n            return -EIO;\n        }\n        outBytes[outBytesLen] = 0;\n    }\n    OPENSSL_cleanse(key.data(), keyLen);\n\n    // Update the meta password structure.\n    MetaPassStruct metaData = {META_PASSWD_SIG, {0, 0}, 0, 0, 0, 0, 0};\n    metaData.hashSize = hashLen;\n    metaData.ivSize = ivLen;\n    metaData.dataSize = bytesWritten;\n    metaData.padSize = outBytesLen - bytesWritten;\n    metaData.macSize = macLen;\n\n    if (fwrite(&metaData, 1, sizeof(metaData), (temp)()) != sizeof(metaData))\n    {\n        log<level::DEBUG>(\"Error in writing meta data\");\n        return -EIO;\n    }\n\n    if (fwrite(&hash[0], 1, hashLen, (temp)()) != hashLen)\n    {\n        log<level::DEBUG>(\"Error in writing hash data\");\n        return -EIO;\n    }\n\n    if (fwrite(&iv[0], 1, ivLen, (temp)()) != ivLen)\n    {\n        log<level::DEBUG>(\"Error in writing IV data\");\n        return -EIO;\n    }\n\n    if (fwrite(&outBytes[0], 1, outBytesLen, (temp)()) != outBytesLen)\n    {\n        log<level::DEBUG>(\"Error in writing encrypted data\");\n        return -EIO;\n    }\n\n    if (fwrite(&mac[0], 1, macLen, (temp)()) != macLen)\n    {\n        log<level::DEBUG>(\"Error in writing MAC data\");\n        return -EIO;\n    }\n\n    if (fflush((temp)()))\n    {\n        log<level::DEBUG>(\n            \"File fflush error while writing entries to special file\");\n        return -EIO;\n    }\n\n    OPENSSL_cleanse(iv.data(), ivLen);\n\n    // Rename the tmp  file to actual file\n    if (std::rename(strTempFileName.data(), passwdFileName) != 0)\n    {\n        log<level::DEBUG>(\"Failed to rename tmp file to ipmi-pass\");\n        return -EIO;\n    }\n\n    return 0;\n}\n\nstd::time_t PasswdMgr::getUpdatedFileTime()\n{\n    struct stat fileStat = {};\n    if (stat(passwdFileName, &fileStat) != 0)\n    {\n        log<level::DEBUG>(\"Error - Getting passwd file time stamp\");\n        return -EIO;\n    }\n    return fileStat.st_mtime;\n}\n\n} // namespace ipmi\n"], "fixing_code": ["/*\n// Copyright (c) 2018 Intel Corporation\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n*/\n\n#include \"passwd_mgr.hpp\"\n\n#include \"file.hpp\"\n#include \"shadowlock.hpp\"\n\n#include <openssl/hmac.h>\n#include <openssl/rand.h>\n#include <openssl/sha.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\n#include <cerrno>\n#include <cstring>\n#include <fstream>\n#include <iomanip>\n#include <phosphor-logging/log.hpp>\n\nnamespace ipmi\n{\n\nstatic const char* passwdFileName = \"/etc/ipmi_pass\";\nstatic const char* encryptKeyFileName = \"/etc/key_file\";\nstatic const size_t maxKeySize = 8;\n\n#define META_PASSWD_SIG \"=OPENBMC=\"\n\n/*\n * Meta data struct for encrypted password file\n */\nstruct MetaPassStruct\n{\n    char signature[10];\n    unsigned char reseved[2];\n    size_t hashSize;\n    size_t ivSize;\n    size_t dataSize;\n    size_t padSize;\n    size_t macSize;\n};\n\nusing namespace phosphor::logging;\n\nPasswdMgr::PasswdMgr()\n{\n    initPasswordMap();\n}\n\nstd::string PasswdMgr::getPasswdByUserName(const std::string& userName)\n{\n    checkAndReload();\n    auto iter = passwdMapList.find(userName);\n    if (iter == passwdMapList.end())\n    {\n        return std::string();\n    }\n    return iter->second;\n}\n\nint PasswdMgr::updateUserEntry(const std::string& userName,\n                               const std::string& newUserName)\n{\n    std::time_t updatedTime = getUpdatedFileTime();\n    // Check file time stamp to know passwdMapList is up-to-date.\n    // If not up-to-date, then updatePasswdSpecialFile will read and\n    // check the user entry existance.\n    if (fileLastUpdatedTime == updatedTime && updatedTime != -EIO)\n    {\n        if (passwdMapList.find(userName) == passwdMapList.end())\n        {\n            log<level::DEBUG>(\"User not found\");\n            return 0;\n        }\n    }\n\n    // Write passwdMap to Encryted file\n    if (updatePasswdSpecialFile(userName, newUserName) != 0)\n    {\n        log<level::DEBUG>(\"Passwd file update failed\");\n        return -EIO;\n    }\n\n    log<level::DEBUG>(\"Passwd file updated successfully\");\n    return 0;\n}\n\nvoid PasswdMgr::checkAndReload(void)\n{\n    std::time_t updatedTime = getUpdatedFileTime();\n    if (fileLastUpdatedTime != updatedTime && updatedTime != -1)\n    {\n        log<level::DEBUG>(\"Reloading password map list\");\n        passwdMapList.clear();\n        initPasswordMap();\n    }\n}\n\nint PasswdMgr::encryptDecryptData(bool doEncrypt, const EVP_CIPHER* cipher,\n                                  uint8_t* key, size_t keyLen, uint8_t* iv,\n                                  size_t ivLen, uint8_t* inBytes,\n                                  size_t inBytesLen, uint8_t* mac,\n                                  size_t* macLen, unsigned char* outBytes,\n                                  size_t* outBytesLen)\n{\n    if (cipher == NULL || key == NULL || iv == NULL || inBytes == NULL ||\n        outBytes == NULL || mac == NULL || inBytesLen == 0 ||\n        (size_t)EVP_CIPHER_key_length(cipher) > keyLen ||\n        (size_t)EVP_CIPHER_iv_length(cipher) > ivLen)\n    {\n        log<level::DEBUG>(\"Error Invalid Inputs\");\n        return -EINVAL;\n    }\n\n    if (!doEncrypt)\n    {\n        // verify MAC before decrypting the data.\n        std::array<uint8_t, EVP_MAX_MD_SIZE> calMac;\n        size_t calMacLen = calMac.size();\n        // calculate MAC for the encrypted message.\n        if (NULL == HMAC(EVP_sha256(), key, keyLen, inBytes, inBytesLen,\n                         calMac.data(),\n                         reinterpret_cast<unsigned int*>(&calMacLen)))\n        {\n            log<level::DEBUG>(\"Error: Failed to calculate MAC\");\n            return -EIO;\n        }\n        if (!((calMacLen == *macLen) &&\n              (std::memcmp(calMac.data(), mac, calMacLen) == 0)))\n        {\n            log<level::DEBUG>(\"Authenticated message doesn't match\");\n            return -EBADMSG;\n        }\n    }\n\n    std::unique_ptr<EVP_CIPHER_CTX, decltype(&::EVP_CIPHER_CTX_free)> ctx(\n        EVP_CIPHER_CTX_new(), ::EVP_CIPHER_CTX_free);\n    EVP_CIPHER_CTX_set_padding(ctx.get(), 1);\n\n    // Set key & IV\n    int retval = EVP_CipherInit_ex(ctx.get(), cipher, NULL, key, iv,\n                                   static_cast<int>(doEncrypt));\n    if (!retval)\n    {\n        log<level::DEBUG>(\"EVP_CipherInit_ex failed\",\n                          entry(\"RET_VAL=%d\", retval));\n        return -EIO;\n    }\n\n    int outLen = 0, outEVPLen = 0;\n    if ((retval = EVP_CipherUpdate(ctx.get(), outBytes + outLen, &outEVPLen,\n                                   inBytes, inBytesLen)))\n    {\n        outLen += outEVPLen;\n        if ((retval =\n                 EVP_CipherFinal(ctx.get(), outBytes + outLen, &outEVPLen)))\n        {\n            outLen += outEVPLen;\n            *outBytesLen = outLen;\n        }\n        else\n        {\n            log<level::DEBUG>(\"EVP_CipherFinal fails\",\n                              entry(\"RET_VAL=%d\", retval));\n            return -EIO;\n        }\n    }\n    else\n    {\n        log<level::DEBUG>(\"EVP_CipherUpdate fails\",\n                          entry(\"RET_VAL=%d\", retval));\n        return -EIO;\n    }\n\n    if (doEncrypt)\n    {\n        // Create MAC for the encrypted message\n        if (NULL == HMAC(EVP_sha256(), key, keyLen, outBytes, *outBytesLen, mac,\n                         reinterpret_cast<unsigned int*>(macLen)))\n        {\n            log<level::DEBUG>(\"Failed to create authentication\");\n            return -EIO;\n        }\n    }\n    return 0;\n}\n\nvoid PasswdMgr::initPasswordMap(void)\n{\n    phosphor::user::shadow::Lock lock();\n    std::vector<uint8_t> dataBuf;\n\n    if (readPasswdFileData(dataBuf) != 0)\n    {\n        log<level::DEBUG>(\"Error in reading the encrypted pass file\");\n        return;\n    }\n\n    if (dataBuf.size() != 0)\n    {\n        // populate the user list with password\n        char* outPtr = reinterpret_cast<char*>(dataBuf.data());\n        char* nToken = NULL;\n        char* linePtr = strtok_r(outPtr, \"\\n\", &nToken);\n        size_t lineSize = 0;\n        while (linePtr != NULL)\n        {\n            size_t userEPos = 0;\n            std::string lineStr(linePtr);\n            if ((userEPos = lineStr.find(\":\")) != std::string::npos)\n            {\n                lineSize = lineStr.size();\n                passwdMapList.emplace(\n                    lineStr.substr(0, userEPos),\n                    lineStr.substr(userEPos + 1, lineSize - (userEPos + 1)));\n            }\n            linePtr = strtok_r(NULL, \"\\n\", &nToken);\n        }\n    }\n\n    // Update the timestamp\n    fileLastUpdatedTime = getUpdatedFileTime();\n    return;\n}\n\nint PasswdMgr::readPasswdFileData(std::vector<uint8_t>& outBytes)\n{\n    std::array<uint8_t, maxKeySize> keyBuff;\n    std::ifstream keyFile(encryptKeyFileName, std::ios::in | std::ios::binary);\n    if (!keyFile.is_open())\n    {\n        log<level::DEBUG>(\"Error in opening encryption key file\");\n        return -EIO;\n    }\n    keyFile.read(reinterpret_cast<char*>(keyBuff.data()), keyBuff.size());\n    if (keyFile.fail())\n    {\n        log<level::DEBUG>(\"Error in reading encryption key file\");\n        return -EIO;\n    }\n\n    std::ifstream passwdFile(passwdFileName, std::ios::in | std::ios::binary);\n    if (!passwdFile.is_open())\n    {\n        log<level::DEBUG>(\"Error in opening ipmi password file\");\n        return -EIO;\n    }\n\n    // calculate file size and read the data\n    passwdFile.seekg(0, std::ios::end);\n    ssize_t fileSize = passwdFile.tellg();\n    passwdFile.seekg(0, std::ios::beg);\n    std::vector<uint8_t> input(fileSize);\n    passwdFile.read(reinterpret_cast<char*>(input.data()), fileSize);\n    if (passwdFile.fail())\n    {\n        log<level::DEBUG>(\"Error in reading encryption key file\");\n        return -EIO;\n    }\n\n    // verify the signature first\n    MetaPassStruct* metaData = reinterpret_cast<MetaPassStruct*>(input.data());\n    if (std::strncmp(metaData->signature, META_PASSWD_SIG,\n                     sizeof(metaData->signature)))\n    {\n        log<level::DEBUG>(\"Error signature mismatch in password file\");\n        return -EBADMSG;\n    }\n\n    size_t inBytesLen = metaData->dataSize + metaData->padSize;\n    // If data is empty i.e no password map then return success\n    if (inBytesLen == 0)\n    {\n        log<level::DEBUG>(\"Empty password file\");\n        return 0;\n    }\n\n    // compute the key needed to decrypt\n    std::array<uint8_t, EVP_MAX_KEY_LENGTH> key;\n    auto keyLen = key.size();\n    if (NULL == HMAC(EVP_sha256(), keyBuff.data(), keyBuff.size(),\n                     input.data() + sizeof(*metaData), metaData->hashSize,\n                     key.data(), reinterpret_cast<unsigned int*>(&keyLen)))\n    {\n        log<level::DEBUG>(\"Failed to create MAC for authentication\");\n        return -EIO;\n    }\n\n    // decrypt the data\n    uint8_t* iv = input.data() + sizeof(*metaData) + metaData->hashSize;\n    size_t ivLen = metaData->ivSize;\n    uint8_t* inBytes = iv + ivLen;\n    uint8_t* mac = inBytes + inBytesLen;\n    size_t macLen = metaData->macSize;\n\n    size_t outBytesLen = 0;\n    // Resize to actual data size\n    outBytes.resize(inBytesLen + EVP_MAX_BLOCK_LENGTH);\n    if (encryptDecryptData(false, EVP_aes_128_cbc(), key.data(), keyLen, iv,\n                           ivLen, inBytes, inBytesLen, mac, &macLen,\n                           outBytes.data(), &outBytesLen) != 0)\n    {\n        log<level::DEBUG>(\"Error in decryption\");\n        return -EIO;\n    }\n    // Resize the vector to outBytesLen\n    outBytes.resize(outBytesLen);\n\n    OPENSSL_cleanse(key.data(), keyLen);\n    OPENSSL_cleanse(iv, ivLen);\n\n    return 0;\n}\n\nint PasswdMgr::updatePasswdSpecialFile(const std::string& userName,\n                                       const std::string& newUserName)\n{\n    phosphor::user::shadow::Lock lock();\n\n    size_t bytesWritten = 0;\n    size_t inBytesLen = 0;\n    size_t isUsrFound = false;\n    const EVP_CIPHER* cipher = EVP_aes_128_cbc();\n    std::vector<uint8_t> dataBuf;\n\n    // Read the encrypted file and get the file data\n    // Check user existance and return if not exist.\n    if (readPasswdFileData(dataBuf) != 0)\n    {\n        log<level::DEBUG>(\"Error in reading the encrypted pass file\");\n        return -EIO;\n    }\n\n    if (dataBuf.size() != 0)\n    {\n        inBytesLen =\n            dataBuf.size() + newUserName.size() + EVP_CIPHER_block_size(cipher);\n    }\n\n    std::vector<uint8_t> inBytes(inBytesLen);\n    if (inBytesLen != 0)\n    {\n        char* outPtr = reinterpret_cast<char*>(dataBuf.data());\n        char* nToken = NULL;\n        char* linePtr = strtok_r(outPtr, \"\\n\", &nToken);\n        while (linePtr != NULL)\n        {\n            size_t userEPos = 0;\n\n            std::string lineStr(linePtr);\n            if ((userEPos = lineStr.find(\":\")) != std::string::npos)\n            {\n                if (userName.compare(lineStr.substr(0, userEPos)) == 0)\n                {\n                    isUsrFound = true;\n                    if (!newUserName.empty())\n                    {\n                        bytesWritten += std::snprintf(\n                            reinterpret_cast<char*>(&inBytes[0]) + bytesWritten,\n                            (inBytesLen - bytesWritten), \"%s%s\\n\",\n                            newUserName.c_str(),\n                            lineStr.substr(userEPos, lineStr.size()).data());\n                    }\n                }\n                else\n                {\n                    bytesWritten += std::snprintf(\n                        reinterpret_cast<char*>(&inBytes[0]) + bytesWritten,\n                        (inBytesLen - bytesWritten), \"%s\\n\", lineStr.data());\n                }\n            }\n            linePtr = strtok_r(NULL, \"\\n\", &nToken);\n        }\n        inBytesLen = bytesWritten;\n    }\n    if (!isUsrFound)\n    {\n        log<level::DEBUG>(\"User doesn't exist\");\n        return 0;\n    }\n\n    // Read the key buff from key file\n    std::array<uint8_t, maxKeySize> keyBuff;\n    std::ifstream keyFile(encryptKeyFileName, std::ios::in | std::ios::binary);\n    if (!keyFile.good())\n    {\n        log<level::DEBUG>(\"Error in opening encryption key file\");\n        return -EIO;\n    }\n    keyFile.read(reinterpret_cast<char*>(keyBuff.data()), keyBuff.size());\n    if (keyFile.fail())\n    {\n        log<level::DEBUG>(\"Error in reading encryption key file\");\n        return -EIO;\n    }\n    keyFile.close();\n\n    // Read the original passwd file mode\n    struct stat st = {};\n    if (stat(passwdFileName, &st) != 0)\n    {\n        log<level::DEBUG>(\"Error in getting password file fstat()\");\n        return -EIO;\n    }\n\n    // Create temporary file for write\n    std::string pwdFile(passwdFileName);\n    std::vector<char> tempFileName(pwdFile.begin(), pwdFile.end());\n    std::vector<char> fileTemplate = {'_', '_', 'X', 'X', 'X',\n                                      'X', 'X', 'X', '\\0'};\n    tempFileName.insert(tempFileName.end(), fileTemplate.begin(),\n                        fileTemplate.end());\n    int fd = mkstemp((char*)tempFileName.data());\n    if (fd == -1)\n    {\n        log<level::DEBUG>(\"Error creating temp file\");\n        return -EIO;\n    }\n\n    std::string strTempFileName(tempFileName.data());\n    // Open the temp file for writing from provided fd\n    // By \"true\", remove it at exit if still there.\n    // This is needed to cleanup the temp file at exception\n    phosphor::user::File temp(fd, strTempFileName, \"w\", true);\n    if ((temp)() == NULL)\n    {\n        close(fd);\n        log<level::DEBUG>(\"Error creating temp file\");\n        return -EIO;\n    }\n\n    // Set the file mode as read-write for owner only\n    if (fchmod(fileno((temp)()), S_IRUSR | S_IWUSR) < 0)\n    {\n        log<level::DEBUG>(\"Error setting fchmod for temp file\");\n        return -EIO;\n    }\n\n    const EVP_MD* digest = EVP_sha256();\n    size_t hashLen = EVP_MD_block_size(digest);\n    std::vector<uint8_t> hash(hashLen);\n    size_t ivLen = EVP_CIPHER_iv_length(cipher);\n    std::vector<uint8_t> iv(ivLen);\n    std::array<uint8_t, EVP_MAX_KEY_LENGTH> key;\n    size_t keyLen = key.size();\n    std::array<uint8_t, EVP_MAX_MD_SIZE> mac;\n    size_t macLen = mac.size();\n\n    // Create random hash and generate hash key which will be used for\n    // encryption.\n    if (RAND_bytes(hash.data(), hashLen) != 1)\n    {\n        log<level::DEBUG>(\"Hash genertion failed, bailing out\");\n        return -EIO;\n    }\n    if (NULL == HMAC(digest, keyBuff.data(), keyBuff.size(), hash.data(),\n                     hashLen, key.data(),\n                     reinterpret_cast<unsigned int*>(&keyLen)))\n    {\n        log<level::DEBUG>(\"Failed to create MAC for authentication\");\n        return -EIO;\n    }\n\n    // Generate IV values\n    if (RAND_bytes(iv.data(), ivLen) != 1)\n    {\n        log<level::DEBUG>(\"UV genertion failed, bailing out\");\n        return -EIO;\n    }\n\n    // Encrypt the input data\n    std::vector<uint8_t> outBytes(inBytesLen + EVP_MAX_BLOCK_LENGTH);\n    size_t outBytesLen = 0;\n    if (inBytesLen != 0)\n    {\n        if (encryptDecryptData(true, EVP_aes_128_cbc(), key.data(), keyLen,\n                               iv.data(), ivLen, inBytes.data(), inBytesLen,\n                               mac.data(), &macLen, outBytes.data(),\n                               &outBytesLen) != 0)\n        {\n            log<level::DEBUG>(\"Error while encrypting the data\");\n            return -EIO;\n        }\n        outBytes[outBytesLen] = 0;\n    }\n    OPENSSL_cleanse(key.data(), keyLen);\n\n    // Update the meta password structure.\n    MetaPassStruct metaData = {META_PASSWD_SIG, {0, 0}, 0, 0, 0, 0, 0};\n    metaData.hashSize = hashLen;\n    metaData.ivSize = ivLen;\n    metaData.dataSize = bytesWritten;\n    metaData.padSize = outBytesLen - bytesWritten;\n    metaData.macSize = macLen;\n\n    if (fwrite(&metaData, 1, sizeof(metaData), (temp)()) != sizeof(metaData))\n    {\n        log<level::DEBUG>(\"Error in writing meta data\");\n        return -EIO;\n    }\n\n    if (fwrite(&hash[0], 1, hashLen, (temp)()) != hashLen)\n    {\n        log<level::DEBUG>(\"Error in writing hash data\");\n        return -EIO;\n    }\n\n    if (fwrite(&iv[0], 1, ivLen, (temp)()) != ivLen)\n    {\n        log<level::DEBUG>(\"Error in writing IV data\");\n        return -EIO;\n    }\n\n    if (fwrite(&outBytes[0], 1, outBytesLen, (temp)()) != outBytesLen)\n    {\n        log<level::DEBUG>(\"Error in writing encrypted data\");\n        return -EIO;\n    }\n\n    if (fwrite(&mac[0], 1, macLen, (temp)()) != macLen)\n    {\n        log<level::DEBUG>(\"Error in writing MAC data\");\n        return -EIO;\n    }\n\n    if (fflush((temp)()))\n    {\n        log<level::DEBUG>(\n            \"File fflush error while writing entries to special file\");\n        return -EIO;\n    }\n\n    OPENSSL_cleanse(iv.data(), ivLen);\n\n    // Rename the tmp  file to actual file\n    if (std::rename(strTempFileName.data(), passwdFileName) != 0)\n    {\n        log<level::DEBUG>(\"Failed to rename tmp file to ipmi-pass\");\n        return -EIO;\n    }\n\n    return 0;\n}\n\nstd::time_t PasswdMgr::getUpdatedFileTime()\n{\n    struct stat fileStat = {};\n    if (stat(passwdFileName, &fileStat) != 0)\n    {\n        log<level::DEBUG>(\"Error - Getting passwd file time stamp\");\n        return -EIO;\n    }\n    return fileStat.st_mtime;\n}\n\n} // namespace ipmi\n"], "filenames": ["user_channel/passwd_mgr.cpp"], "buggy_code_start_loc": [447], "buggy_code_end_loc": [449], "fixing_code_start_loc": [447], "fixing_code_end_loc": [449], "type": "CWE-276", "message": "user_channel/passwd_mgr.cpp in OpenBMC phosphor-host-ipmid before 2020-04-03 does not ensure that /etc/ipmi-pass has strong file permissions.", "other": {"cve": {"id": "CVE-2020-14156", "sourceIdentifier": "cve@mitre.org", "published": "2020-06-15T18:15:15.207", "lastModified": "2020-06-22T18:33:42.990", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "user_channel/passwd_mgr.cpp in OpenBMC phosphor-host-ipmid before 2020-04-03 does not ensure that /etc/ipmi-pass has strong file permissions."}, {"lang": "es", "value": "el archivo user_channel/passwd_mgr.cpp en OpenBMC phosphor-host-ipmid antes del 03-04-2020 no garantiza que /etc/ipmi-pass tenga permisos de archivo s\u00f3lidos"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-276"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openbmc-project:openbmc:*:*:*:*:*:*:*:*", "versionEndExcluding": "2020-04-03", "matchCriteriaId": "AE58FF9E-003C-46AB-9FCE-2A21807009C7"}]}]}], "references": [{"url": "https://github.com/openbmc/openbmc/issues/3670", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/openbmc/phosphor-host-ipmid/commit/b265455a2518ece7c004b43c144199ec980fc620", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.ozlabs.org/pipermail/openbmc/2020-June/022020.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/openbmc/phosphor-host-ipmid/commit/b265455a2518ece7c004b43c144199ec980fc620"}}