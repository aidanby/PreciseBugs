{"buggy_code": ["Changelog\n=========\n\n2.1.1 (unreleased)\n------------------\n\n- Enforce access control on setup tool log files\n  (`#101 <https://github.com/zopefoundation/Products.GenericSetup/issues/101>`_)\n\n\n2.1.0 (2021-01-26)\n------------------\n\n- Add support for Python 3.9.\n\n\n2.0.3 (2020-09-28)\n------------------\n\n- When logging an upgrade, print the version tuple joined by dots.\n\n- Renamed ``xml`` dir to ``xml_templates``.\n  This avoids an import warning on Python 2.7.\n\n\n2.0.2 (2020-01-29)\n------------------\n\n- Remove Zope 2.13 fossils to stay compatible with Zope 5\n\n- Force saving unpersisted changes in toolset registry.\n  (`#86 <https://github.com/zopefoundation/Products.GenericSetup/issues/86>`_)\n\n\n2.0.1 (2019-10-12)\n------------------\n\n- Fix the sorting of upgrade steps.  [vanderbauwhede]\n\n\n2.0 (2019-05-10)\n----------------\n\n- no changes since 2.0b6\n\n\n2.0b6 (2019-04-09)\n------------------\n\n- Zope 4 ZMI: Added icon\n\n- Zope 4 ZMI: declare that creating a GS tool does not need an add dialog\n  (`#80 <https://github.com/zopefoundation/Products.GenericSetup/issues/80>`_)\n\n- clean up ``setup.py`` and remove support for ``setup.py test``\n  (`#73 <https://github.com/zopefoundation/Products.GenericSetup/issues/73>`_)\n\n- add support for unicode data in ``writeDataFile``\n  (`#79 <https://github.com/zopefoundation/Products.GenericSetup/issues/79>`_)\n\n- Specify supported Python versions using ``python_requires`` in setup.py\n\n- Adding suport for Python 3.8\n\n\n2.0b5 (2018-12-14)\n------------------\n\n- Fix deprecation warnings for ``cgi.escape`` by using ``html.escape``\n  (`#76 <https://github.com/zopefoundation/Products.GenericSetup/issues/76>`_)\n\n\n2.0b4 (2018-11-22)\n------------------\n\n- Convert input from xml configuration with correct encoding before passing to\n  type_converter.\n  (`#77 <https://github.com/zopefoundation/Products.GenericSetup/pull/77>`_)\n  [sallner]\n\n\n2.0b3 (2018-11-07)\n------------------\n\n- Do not turn ulines and multiple selection into bytes.\n  [davisagli]\n\n- Set body of PythonScripts as text in py3.\n  [pbauer]\n\n- Compare encodings so that UTF-8 and utf-8 are the same.\n  [pbauer]\n\n- Compare DOM as text in py3.\n  [pbauer]\n\n\n2.0b2 (2018-10-17)\n------------------\n\nNew features:\n\n- Add Python 3.7 support.\n\n- Support `zope.configuration >= 4.2`.\n\nBug fixes:\n\n- Proper string/bytes handling for _createObjectByType.\n  In Python2 everything is written as bytes,\n  while on Python3 everything is written as text except files and images\n  which are stored as bytes\n  [ale-rt]\n\n\n2.0b1 (2018-05-16)\n------------------\n\nBreaking changes:\n\n- Require Zope 4.0b4 as minimum supported Zope version and drop\n  explicit ``Zope2`` egg dependency.\n\n- Drop Python 3.4 support\n\nNew features:\n\n- Fixed tests with ``Products.ZCatalog 4.1``.  [maurits]\n\n- When ``metadata.xml`` parsing fails, show the filename in the ``ExpatError``.\n  Fixes `Plone issue 2303 <https://github.com/plone/Products.CMFPlone/issues/2303>`_.\n\n- Prevent AttributeError 'NoneType' object has no attribute 'decode'.\n  [maurits]\n\n- Finished compatibility with Python 3.5 and 3.6\n\n- Made the code PEP-8 compliant\n\nBug fixes:\n\n- Do not mask KeyError in 'getProfileDependencies' from missing\n  dependency profiles.\n  Refs: https://github.com/plone/Products.CMFPlone/issues/2228\n  [ida]\n\n\n1.10.0 (2017-12-07)\n-------------------\n\nBreaking changes:\n\n- Require Zope 4.0a6 as minimum supported Zope version.\n\n- Moved support for `MailHost` import/export into the\n  ``Products.MailHost`` package to cut the hard dependency.\n\nNew features:\n\n- Added ``tox`` testing configuration.\n\n- Pushed documentation to RTD: https://productsgenericsetup.readthedocs.io/.\n\n1.9.1 (2017-05-06)\n------------------\n\nBug fixes:\n\n- Fixed ``upgradeStep`` discriminator so that similar steps\n  for different profiles will not conflict.\n\n- Fixed ``upgradeDepends`` discriminator so that steps inside\n  ``upgradeSteps`` will conflict with steps outside if they\n  have the same ``checker``.\n\n- Fix import of UnrestrictedUser.\n\n1.9.0 (2017-05-04)\n------------------\n\nBreaking changes:\n\n- Drop support for Python 2.6.\n\n- Require Zope 4.0a3 as minimum supported Zope version.\n\n1.8.7 (2017-03-26)\n------------------\n\n- Allow registering the same profile twice if it really is the same.\n  This is mostly for tests where the registry may not be cleaned up\n  correctly in case of problems in test teardown.\n  If you register the same profile twice in zcml, you still get a\n  conflict from ``zope.configuration`` during Zope startup.\n  [maurits]\n\n\n1.8.6 (2016-12-30)\n------------------\n\n- Added a ``purge_old`` option to the tarball import form.\n  By default this option is checked, which matches the previous behavior.\n  If you uncheck it, this avoids purging old settings for any import step\n  that is run.  [maurits]\n\n\n1.8.5 (2016-11-01)\n------------------\n\n- Stopped using a form library to render the components form.\n\n1.8.4 (2016-09-21)\n------------------\n\n- Made ``_profile_upgrade_versions`` a PersistentMapping.  When\n  ``(un)setLastVersionForProfile`` is called, we migrate the original\n  Python dictionary.  This makes some code easier and plays nicer with\n  transactions, which may especially help during tests.  [maurits]\n\n\n1.8.3 (2016-04-28)\n------------------\n\n- Allowed overriding required and forbidden tools in ``toolset.xml``.\n  If a tool is currently required and you import a ``toolset.xml``\n  where it is forbidden, we remove the tool from the required list and\n  add it to the forbidden list.  And the other way around.  The\n  previous behavior was to raise an exception, which left no way in\n  xml to remove a tool.  Fail with a ValueError when the ``remove``\n  keyword is used.  The expected behavior is unclear.  [maurits]\n\n\n1.8.2 (2016-02-24)\n------------------\n\n- Added optional ``pre_handler`` and ``post_handler`` to\n  ``registerProfile`` directive.  When set, these dotted names are\n  resolved to a function and are passed the setup tool as single\n  argument.  They are called before and after applying all import\n  steps of the profile they are registered for.  [maurits]\n\n- Sorted import profiles alphabetically lowercase.  Allow selecting a\n  profile by title or id.  [maurits]\n\n- Do not show dependency options on the full import tab when there are\n  no dependencies.  [maurits]\n\n- Do not select a profile by default in the import tabs.  [maurits]\n\n- Added simple toggle for all steps on the advanced import tab.\n  Also added this on the export tab.\n  [maurits]\n\n- Fixed importing a tarball.  This got an AttributeError: \"'NoneType'\n  object has no attribute 'startswith'\".\n  [maurits]\n\n- Split overly complex Import tab into three tabs: Import (for\n  importing a full profile), Advanced Import (the original\n  ``manage_importSteps`` url leads to this tab), and Tarball Import.\n  [maurits]\n\n- Show note on import tab when there are pending upgrades.  Especially\n  show this for the currently selected profile.\n  [maurits]\n\n- Upgrades tab: show profiles with pending upgrades separately.  These\n  are the most important ones.  This avoids the need to manually go\n  through the whole list in order to find profiles that may need\n  action.  This uses new methods on the setup tool:\n  ``hasPendingUpgrades``, ``listProfilesWithPendingUpgrades``,\n  ``listUptodateProfiles``.\n  [maurits]\n\n\n1.8.1 (2015-12-16)\n------------------\n\n- Purge the profile upgrade versions before applying a base profile.\n\n- Added ``purgeProfileVersions`` method to ``portal_setup``.  This\n  removes the all profiles profile upgrade versions.\n\n- Added ``unsetLastVersionForProfile`` method to ``portal_setup``.  This\n  removes the profile id from the profile upgrade versions.  Calling\n  ``setLastVersionForProfile`` with ``unknown`` as version now has the\n  same effect.\n\n\n1.8.0 (2015-09-21)\n------------------\n\n- Be more forgiving when dealing with profile ids with or without\n  ``profile-`` at the start.  All functions that accept a profile id\n  argument and only work when the id does *not* have this string at\n  the start, will now strip it off if it is there.  For example,\n  ``getLastVersionForProfile`` will give the same answer whether you\n  ask it for the version of profile id ``foo`` or ``profile-foo``.\n\n- Dependency profiles from ``metadata.xml`` that are already applied,\n  are not applied again.  Instead, its upgrade steps, if any, are\n  applied.  In code you can choose the old behavior of always applying\n  the dependencies, by calling ``runAllImportStepsFromProfile`` with\n  ``dependency_strategy=DEPENDENCY_STRATEGY_REAPPLY``.  There are four\n  strategies, which you can choose in the ZMI.\n\n\n1.7.7 (2015-08-11)\n------------------\n\n- Fix: when the last applied upgrade step had a checker, the profile\n  version was not updated.  Now we no longer look at the checker of\n  the last applied step when deciding whether to set the profile\n  version.  The checker, if any is set, normally returns True before\n  running the step (it can be applied), and False afterwards (it\n  was already applied).\n\n- Add ``upgradeProfile`` method to setup tool.  This method applies all\n  upgrades steps for the given profile, or updates it to the optional\n  given version.  If the profile does not exist, or if there is no upgrade\n  step to go to the specified version, the method warns and does nothing.\n\n- Check the boolean value of the ``remove`` option when importing\n  objects.  Previously we only checked if the ``remove`` option was\n  given, regardless of its value.  Supported are ``True``, ``Yes``,\n  and ``1``, where case does not matter.  The syntax for removing\n  objects, properties, and elements is now the same.\n\n- Support ``remove=\"True\"`` for properties.\n\n\n1.7.6 (2015-07-15)\n------------------\n\n- Enable testing under Travis.\n\n- Fix compatibility with Setuptools 8.0 and later.  Upgrade steps\n  could get sorted in the wrong order, especially an empty version\n  string (upgrade step from any source version) sorted last instead of\n  first.\n\n\n1.7.5 (2014-10-23)\n------------------\n\n- Allow skipping certain steps on ``runAllImportStepsFromProfile``.\n\n\n1.7.4 (2013-06-12)\n------------------\n\n- On import, avoid clearing indexes whose state is unchanged.\n\n\n1.7.3 (2012-10-16)\n------------------\n\n- Sort profiles on Upgrade form.\n\n- Use clickable labels with checkboxes on import, export and upgrade forms\n  to improve usability.\n\n\n1.7.2 (2012-07-23)\n------------------\n\n- Avoid using ``manage_FTPGet`` on snapshot exports: that method messes\n  up the response headers.\n\n- ZopePageTemplate handler:  Fix export encoding: since 1.7.0, exports\n  must be UTF-8 strings\n\n\n1.7.1 (2012-02-28)\n------------------\n\n- Restore the ability to make the setup tool use only import / export\n  steps explicitly called out by the current profile, ignoring any which\n  might be globally registered.  This is particularly useful for configuring\n  sites with baseline profiles, where arbitrary add-on steps are not only\n  useless, but potentially damaging.\n\n\n1.7.0 (2012-01-27)\n------------------\n\n- While importing ``toolset.xml``, print a warning when the class of a\n  required tool is not found and continue with the next tool.  The\n  previous behaviour could break the install or uninstall of any\n  add-on, as the missing class may easily be from a different\n  unrelated add-on that is no longer available in the zope instance.\n\n- Exporters now explicitly only understand strings. The provided\n  registry handlers encode and decode data automatically to and from\n  UTF-8. Their default encoding changed from None to UTF-8.\n  If you have custom registry handlers, ensure that you encode your unicode.\n  Check especially if you use a page template to generate xml. They return\n  unicode and their output must also encoded.\n  If you choose to encode your strings with UTF-8, you can be sure that\n  your code will also work with GenericSetup < 1.7\n", "##############################################################################\n#\n# Copyright (c) 2004 Zope Foundation and Contributors.\n#\n# This software is subject to the provisions of the Zope Public License,\n# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.\n# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED\n# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS\n# FOR A PARTICULAR PURPOSE.\n#\n##############################################################################\n\"\"\" Various context implementations for export / import of configurations.\n\nWrappers representing the state of an import / export operation.\n\"\"\"\n\nimport logging\nimport os\nimport time\nfrom io import BytesIO\nfrom tarfile import DIRTYPE\nfrom tarfile import TarFile\nfrom tarfile import TarInfo\n\nimport six\n\nfrom AccessControl.class_init import InitializeClass\nfrom AccessControl.SecurityInfo import ClassSecurityInfo\nfrom Acquisition import Implicit\nfrom Acquisition import aq_base\nfrom Acquisition import aq_inner\nfrom Acquisition import aq_parent\nfrom Acquisition import aq_self\nfrom DateTime.DateTime import DateTime\nfrom OFS.DTMLDocument import DTMLDocument\nfrom OFS.Folder import Folder\nfrom OFS.Image import File\nfrom OFS.Image import Image\nfrom Products.PageTemplates.ZopePageTemplate import ZopePageTemplate\nfrom Products.PythonScripts.PythonScript import PythonScript\nfrom zope.interface import implementer\n\nfrom .interfaces import SKIPPED_FILES\nfrom .interfaces import SKIPPED_SUFFIXES\nfrom .interfaces import IChunkableExportContext\nfrom .interfaces import IChunkableImportContext\nfrom .interfaces import IExportContext\nfrom .interfaces import IImportContext\nfrom .interfaces import ISetupEnviron\nfrom .interfaces import IWriteLogger\nfrom .permissions import ManagePortal\n\n\n@implementer(IWriteLogger)\nclass Logger:\n\n    def __init__(self, id, messages):\n        \"\"\"Initialize the logger with a name and an optional level.\n        \"\"\"\n        self._id = id\n        self._messages = messages\n        self._logger = logging.getLogger('GenericSetup.%s' % id)\n\n    def debug(self, msg, *args, **kwargs):\n        \"\"\"Log 'msg % args' with severity 'DEBUG'.\n        \"\"\"\n        self.log(logging.DEBUG, msg, *args, **kwargs)\n\n    def info(self, msg, *args, **kwargs):\n        \"\"\"Log 'msg % args' with severity 'INFO'.\n        \"\"\"\n        self.log(logging.INFO, msg, *args, **kwargs)\n\n    def warning(self, msg, *args, **kwargs):\n        \"\"\"Log 'msg % args' with severity 'WARNING'.\n        \"\"\"\n        self.log(logging.WARNING, msg, *args, **kwargs)\n\n    def error(self, msg, *args, **kwargs):\n        \"\"\"Log 'msg % args' with severity 'ERROR'.\n        \"\"\"\n        self.log(logging.ERROR, msg, *args, **kwargs)\n\n    def exception(self, msg, *args):\n        \"\"\"Convenience method for logging an ERROR with exception information.\n        \"\"\"\n        self.error(msg, *args, **{'exc_info': 1})\n\n    def critical(self, msg, *args, **kwargs):\n        \"\"\"Log 'msg % args' with severity 'CRITICAL'.\n        \"\"\"\n        self.log(logging.CRITICAL, msg, *args, **kwargs)\n\n    def log(self, level, msg, *args, **kwargs):\n        \"\"\"Log 'msg % args' with the integer severity 'level'.\n        \"\"\"\n        self._messages.append((level, self._id, msg))\n        self._logger.log(level, msg, *args, **kwargs)\n\n\n@implementer(ISetupEnviron)\nclass SetupEnviron(Implicit):\n\n    \"\"\"Context for body im- and exporter.\n    \"\"\"\n\n    security = ClassSecurityInfo()\n\n    def __init__(self):\n        self._should_purge = True\n\n    @security.protected(ManagePortal)\n    def getLogger(self, name):\n        \"\"\"Get a logger with the specified name, creating it if necessary.\n        \"\"\"\n        return logging.getLogger('GenericSetup.%s' % name)\n\n    @security.protected(ManagePortal)\n    def shouldPurge(self):\n        \"\"\"When installing, should the existing setup be purged?\n        \"\"\"\n        return self._should_purge\n\n\nInitializeClass(SetupEnviron)\n\n\nclass BaseContext(SetupEnviron):\n\n    security = ClassSecurityInfo()\n\n    def __init__(self, tool, encoding):\n\n        self._tool = tool\n        self._site = aq_parent(aq_inner(tool))\n        self._loggers = {}\n        self._messages = []\n        self._encoding = encoding\n        self._should_purge = True\n\n    @security.protected(ManagePortal)\n    def getSite(self):\n        \"\"\" See ISetupContext.\n        \"\"\"\n        return aq_self(self._site)\n\n    @security.protected(ManagePortal)\n    def getSetupTool(self):\n        \"\"\" See ISetupContext.\n        \"\"\"\n        return self._tool\n\n    @security.protected(ManagePortal)\n    def getEncoding(self):\n        \"\"\" See ISetupContext.\n        \"\"\"\n        return self._encoding\n\n    @security.protected(ManagePortal)\n    def getLogger(self, name):\n        \"\"\" See ISetupContext.\n        \"\"\"\n        return self._loggers.setdefault(name, Logger(name, self._messages))\n\n    @security.protected(ManagePortal)\n    def listNotes(self):\n        \"\"\" See ISetupContext.\n        \"\"\"\n        return self._messages[:]\n\n    @security.protected(ManagePortal)\n    def clearNotes(self):\n        \"\"\" See ISetupContext.\n        \"\"\"\n        self._messages[:] = []\n\n\nInitializeClass(BaseContext)\n\n\n@implementer(IChunkableImportContext)\nclass DirectoryImportContext(BaseContext):\n\n    security = ClassSecurityInfo()\n\n    def __init__(self, tool, profile_path, should_purge=False,\n                 encoding=None):\n\n        BaseContext.__init__(self, tool, encoding)\n        self._profile_path = profile_path\n        self._should_purge = bool(should_purge)\n\n    @security.protected(ManagePortal)\n    def openDataFile(self, filename, subdir=None):\n        \"\"\" See IImportContext.\n        \"\"\"\n        if subdir is None:\n            full_path = os.path.join(self._profile_path, filename)\n        else:\n            full_path = os.path.join(self._profile_path, subdir, filename)\n\n        if not os.path.exists(full_path):\n            return None\n\n        return open(full_path, 'rb')\n\n    @security.protected(ManagePortal)\n    def readDataFile(self, filename, subdir=None):\n        \"\"\" See IImportContext.\n        \"\"\"\n        result = None\n        file = self.openDataFile(filename, subdir)\n        if file is not None:\n            result = file.read()\n            file.close()\n        return result\n\n    @security.protected(ManagePortal)\n    def getLastModified(self, path):\n        \"\"\" See IImportContext.\n        \"\"\"\n        full_path = os.path.join(self._profile_path, path)\n\n        if not os.path.exists(full_path):\n            return None\n\n        return DateTime(os.path.getmtime(full_path))\n\n    @security.protected(ManagePortal)\n    def isDirectory(self, path):\n        \"\"\" See IImportContext.\n        \"\"\"\n        full_path = os.path.join(self._profile_path, path)\n\n        if not os.path.exists(full_path):\n            return None\n\n        return os.path.isdir(full_path)\n\n    @security.protected(ManagePortal)\n    def listDirectory(self, path, skip=SKIPPED_FILES,\n                      skip_suffixes=SKIPPED_SUFFIXES):\n        \"\"\" See IImportContext.\n        \"\"\"\n        if path is None:\n            path = ''\n\n        full_path = os.path.join(self._profile_path, path)\n\n        if not os.path.exists(full_path) or not os.path.isdir(full_path):\n            return None\n\n        names = []\n        for name in os.listdir(full_path):\n            if name in skip:\n                continue\n            if [s for s in skip_suffixes if name.endswith(s)]:\n                continue\n            names.append(name)\n\n        return names\n\n\nInitializeClass(DirectoryImportContext)\n\n\n@implementer(IChunkableExportContext)\nclass DirectoryExportContext(BaseContext):\n\n    security = ClassSecurityInfo()\n\n    def __init__(self, tool, profile_path, encoding=None):\n\n        BaseContext.__init__(self, tool, encoding)\n        self._profile_path = profile_path\n\n    @security.protected(ManagePortal)\n    def openDataFile(self, filename, content_type, subdir=None):\n        \"\"\" See IChunkableExportContext.\n        \"\"\"\n        if subdir is None:\n            prefix = self._profile_path\n        else:\n            prefix = os.path.join(self._profile_path, subdir)\n\n        full_path = os.path.join(prefix, filename)\n\n        if not os.path.exists(prefix):\n            os.makedirs(prefix)\n\n        return open(full_path, 'wb')\n\n    @security.protected(ManagePortal)\n    def writeDataFile(self, filename, text, content_type, subdir=None):\n        \"\"\" See IExportContext.\n        \"\"\"\n        if isinstance(text, six.text_type):\n            encoding = self.getEncoding() or 'utf-8'\n            text = text.encode(encoding)\n        file = self.openDataFile(filename, content_type, subdir)\n        file.write(text)\n        file.close()\n\n\nInitializeClass(DirectoryExportContext)\n\n\n@implementer(IImportContext)\nclass TarballImportContext(BaseContext):\n\n    security = ClassSecurityInfo()\n\n    def __init__(self, tool, archive_bits, encoding=None, should_purge=False):\n        BaseContext.__init__(self, tool, encoding)\n        self._archive_stream = BytesIO(archive_bits)\n        self._archive = TarFile.open('foo.bar', 'r:gz', self._archive_stream)\n        self._should_purge = bool(should_purge)\n\n    def readDataFile(self, filename, subdir=None):\n        \"\"\" See IImportContext.\n        \"\"\"\n        if subdir is not None:\n            filename = '/'.join((subdir, filename))\n\n        try:\n            file = self._archive.extractfile(filename)\n        except KeyError:\n            return None\n\n        return file.read()\n\n    def getLastModified(self, path):\n        \"\"\" See IImportContext.\n        \"\"\"\n        info = self._getTarInfo(path)\n        return info and DateTime(info.mtime) or None\n\n    def isDirectory(self, path):\n        \"\"\" See IImportContext.\n        \"\"\"\n        info = self._getTarInfo(path)\n\n        if info is not None:\n            return info.isdir()\n\n    def listDirectory(self, path, skip=SKIPPED_FILES,\n                      skip_suffixes=SKIPPED_SUFFIXES):\n        \"\"\" See IImportContext.\n        \"\"\"\n        if path is None:  # root is special case:  no leading '/'\n            path = ''\n        else:\n            if not self.isDirectory(path):\n                return None\n\n            if not path.endswith('/'):\n                path = path + '/'\n\n        pfx_len = len(path)\n\n        names = []\n        for info in self._archive.getmembers():\n            name = info.name.rstrip('/')\n            if name == path or not name.startswith(path):\n                continue\n            name = name[pfx_len:]\n            if '/' in name:\n                # filter out items in subdirs\n                continue\n            if name in skip:\n                continue\n            if [s for s in skip_suffixes if name.endswith(s)]:\n                continue\n            names.append(name)\n\n        return names\n\n    def shouldPurge(self):\n        \"\"\" See IImportContext.\n        \"\"\"\n        return self._should_purge\n\n    def _getTarInfo(self, path):\n        if path.endswith('/'):\n            path = path[:-1]\n        try:\n            return self._archive.getmember(path)\n        except KeyError:\n            pass\n        try:\n            return self._archive.getmember(path + '/')\n        except KeyError:\n            return None\n\n\nInitializeClass(TarballImportContext)\n\n\n@implementer(IExportContext)\nclass TarballExportContext(BaseContext):\n\n    security = ClassSecurityInfo()\n\n    def __init__(self, tool, encoding=None):\n\n        BaseContext.__init__(self, tool, encoding)\n\n        timestamp = time.gmtime()\n        archive_name = ('setup_tool-%4d%02d%02d%02d%02d%02d.tar.gz'\n                        % timestamp[:6])\n\n        self._archive_stream = BytesIO()\n        self._archive_filename = archive_name\n        self._archive = TarFile.open(archive_name, 'w:gz',\n                                     self._archive_stream)\n\n    @security.protected(ManagePortal)\n    def writeDataFile(self, filename, text, content_type, subdir=None):\n        \"\"\" See IExportContext.\n        \"\"\"\n        if subdir is not None:\n            filename = '/'.join((subdir, filename))\n\n        parents = filename.split('/')[:-1]\n        while parents:\n            path = '/'.join(parents) + '/'\n            if path not in self._archive.getnames():\n                info = TarInfo(path)\n                info.type = DIRTYPE\n                # tarfile.filemode(0o755) == '-rwxr-xr-x'\n                info.mode = 0o755\n                info.mtime = time.time()\n                self._archive.addfile(info)\n            parents.pop()\n\n        info = TarInfo(filename)\n        if isinstance(text, six.text_type):\n            encoding = self.getEncoding() or 'utf-8'\n            text = text.encode(encoding)\n\n        if isinstance(text, six.binary_type):\n            stream = BytesIO(text)\n            info.size = len(text)\n        else:\n            # Assume text is a an instance of a class like\n            # Products.Archetypes.WebDAVSupport.PdataStreamIterator,\n            # as in the case of ATFile\n            stream = text.file\n            info.size = text.size\n        info.mtime = time.time()\n        self._archive.addfile(info, stream)\n\n    @security.protected(ManagePortal)\n    def getArchive(self):\n        \"\"\" Close the archive, and return it as a big string.\n        \"\"\"\n        self._archive.close()\n        return self._archive_stream.getvalue()\n\n    @security.protected(ManagePortal)\n    def getArchiveFilename(self):\n        \"\"\" Close the archive, and return it as a big string.\n        \"\"\"\n        return self._archive_filename\n\n\nInitializeClass(TarballExportContext)\n\n\n@implementer(IExportContext)\nclass SnapshotExportContext(BaseContext):\n\n    security = ClassSecurityInfo()\n\n    def __init__(self, tool, snapshot_id, encoding=None):\n\n        BaseContext.__init__(self, tool, encoding)\n        self._snapshot_id = snapshot_id\n\n    @security.protected(ManagePortal)\n    def writeDataFile(self, filename, text, content_type, subdir=None):\n        \"\"\" See IExportContext.\n        \"\"\"\n        if subdir is not None:\n            filename = '/'.join((subdir, filename))\n\n        sep = filename.rfind('/')\n        if sep != -1:\n            subdir = filename[:sep]\n            filename = filename[sep+1:]\n\n        if six.PY2 and isinstance(text, six.text_type):\n            encoding = self.getEncoding() or 'utf-8'\n            text = text.encode(encoding)\n\n        folder = self._ensureSnapshotsFolder(subdir)\n\n        # MISSING: switch on content_type\n        ob = self._createObjectByType(filename, text, content_type)\n        folder._setObject(str(filename), ob)  # No Unicode IDs!\n\n    @security.protected(ManagePortal)\n    def getSnapshotURL(self):\n        \"\"\" See IExportContext.\n        \"\"\"\n        return '%s/%s' % (self._tool.absolute_url(), self._snapshot_id)\n\n    @security.protected(ManagePortal)\n    def getSnapshotFolder(self):\n        \"\"\" See IExportContext.\n        \"\"\"\n        return self._ensureSnapshotsFolder()\n\n    #\n    #   Helper methods\n    #\n    @security.private\n    def _createObjectByType(self, name, body, content_type):\n        encoding = self.getEncoding() or 'utf-8'\n\n        if six.PY2 and isinstance(body, six.text_type):\n            body = body.encode(encoding)\n\n        if name.endswith('.py'):\n            ob = PythonScript(name)\n            ob.write(body)\n            return ob\n\n        if name.endswith('.dtml'):\n            ob = DTMLDocument('', __name__=name)\n            ob.munge(body)\n            return ob\n\n        if content_type in ('text/html', 'text/xml'):\n            return ZopePageTemplate(name, body, content_type=content_type)\n\n        if isinstance(body, six.text_type):\n            body = body.encode(encoding)\n\n        if content_type[:6] == 'image/':\n            return Image(name, '', body, content_type=content_type)\n\n        return File(name, '', body, content_type=content_type)\n\n    @security.private\n    def _ensureSnapshotsFolder(self, subdir=None):\n        \"\"\" Ensure that the appropriate snapshot folder exists.\n        \"\"\"\n        path = ['snapshots', self._snapshot_id]\n\n        if subdir is not None:\n            path.extend(subdir.split('/'))\n\n        current = self._tool\n\n        for element in path:\n\n            if element not in current.objectIds():\n                # No Unicode IDs!\n                current._setObject(str(element), Folder(element))\n\n            current = current._getOb(element)\n\n        return current\n\n\nInitializeClass(SnapshotExportContext)\n\n\n@implementer(IImportContext)\nclass SnapshotImportContext(BaseContext):\n\n    security = ClassSecurityInfo()\n\n    def __init__(self, tool, snapshot_id, should_purge=False, encoding=None):\n        BaseContext.__init__(self, tool, encoding)\n        self._snapshot_id = snapshot_id\n        self._encoding = encoding\n        self._should_purge = bool(should_purge)\n\n    @security.protected(ManagePortal)\n    def readDataFile(self, filename, subdir=None):\n        \"\"\" See IImportContext.\n        \"\"\"\n        if subdir is not None:\n            filename = '/'.join((subdir, filename))\n\n        sep = filename.rfind('/')\n        if sep != -1:\n            subdir = filename[:sep]\n            filename = filename[sep+1:]\n        try:\n            snapshot = self._getSnapshotFolder(subdir)\n            object = snapshot._getOb(filename)\n        except (AttributeError, KeyError):\n            return None\n\n        if isinstance(object, File):\n            # OFS File Object have only one way to access the raw\n            # data directly, __str__. The code explicitly forbids\n            # to store unicode, so str() is safe here\n            data = six.binary_type(aq_base(object.data))\n        else:\n            data = object.read()\n        if isinstance(data, six.text_type):\n            data = data.encode('utf-8')\n        return data\n\n    @security.protected(ManagePortal)\n    def getLastModified(self, path):\n        \"\"\" See IImportContext.\n        \"\"\"\n        try:\n            snapshot = self._getSnapshotFolder()\n            object = snapshot.restrictedTraverse(path)\n        except (AttributeError, KeyError):\n            return None\n        else:\n            mtime = getattr(object, '_p_mtime', None)\n            if mtime is None:\n                # test hook\n                mtime = getattr(object, '_faux_mod_time', None)\n                if mtime is None:\n                    return DateTime()\n            return DateTime(mtime)\n\n    @security.protected(ManagePortal)\n    def isDirectory(self, path):\n        \"\"\" See IImportContext.\n        \"\"\"\n        try:\n            snapshot = self._getSnapshotFolder()\n            object = snapshot.restrictedTraverse(str(path))\n        except (AttributeError, KeyError):\n            return None\n        else:\n            folderish = getattr(object, 'isPrincipiaFolderish', False)\n            return bool(folderish)\n\n    @security.protected(ManagePortal)\n    def listDirectory(self, path, skip=(), skip_suffixes=()):\n        \"\"\" See IImportContext.\n        \"\"\"\n        try:\n            snapshot = self._getSnapshotFolder()\n            subdir = snapshot.restrictedTraverse(path)\n        except (AttributeError, KeyError):\n            return None\n        else:\n            if not getattr(subdir, 'isPrincipiaFolderish', False):\n                return None\n\n            names = []\n            for name in subdir.objectIds():\n                if name in skip:\n                    continue\n                if [s for s in skip_suffixes if name.endswith(s)]:\n                    continue\n                names.append(name)\n\n            return names\n\n    @security.protected(ManagePortal)\n    def shouldPurge(self):\n        \"\"\" See IImportContext.\n        \"\"\"\n        return self._should_purge\n\n    #\n    #   Helper methods\n    #\n    @security.private\n    def _getSnapshotFolder(self, subdir=None):\n        \"\"\" Return the appropriate snapshot (sub)folder.\n        \"\"\"\n        path = ['snapshots', self._snapshot_id]\n\n        if subdir is not None:\n            path.extend(subdir.split('/'))\n\n        return self._tool.restrictedTraverse(path)\n\n\nInitializeClass(SnapshotImportContext)\n", "##############################################################################\n#\n# Copyright (c) 2004 Zope Foundation and Contributors.\n#\n# This software is subject to the provisions of the Zope Public License,\n# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.\n# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED\n# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS\n# FOR A PARTICULAR PURPOSE.\n#\n##############################################################################\n\"\"\" Unit tests for GenericSetup tool.\n\"\"\"\n\nimport os\nimport tempfile\nimport unittest\n\nimport six\nfrom six import BytesIO\n\nimport transaction\nfrom AccessControl.Permissions import view\nfrom AccessControl.SecurityManagement import newSecurityManager\nfrom AccessControl.SecurityManagement import noSecurityManager\nfrom AccessControl.users import UnrestrictedUser\nfrom Acquisition import aq_base\nfrom OFS.Folder import Folder\nfrom zope.component import adapter\nfrom zope.component import provideHandler\nfrom zope.component.globalregistry import base as base_registry\n\nfrom Products.GenericSetup import profile_registry\n\nfrom ..context import TarballExportContext\nfrom ..interfaces import IBeforeProfileImportEvent\nfrom ..interfaces import IProfileImportedEvent\nfrom ..testing import ExportImportZCMLLayer\nfrom ..upgrade import UpgradeStep\nfrom ..upgrade import _registerUpgradeStep\nfrom ..upgrade import listUpgradeSteps\nfrom .common import BaseRegistryTests\nfrom .common import DummyExportContext\nfrom .common import DummyImportContext\nfrom .common import FilesystemTestBase\nfrom .common import TarballTester\nfrom .common import _makeTestFile\nfrom .conformance import ConformsToISetupTool\nfrom .test_registry import _EMPTY_EXPORT_XML\nfrom .test_registry import _EMPTY_IMPORT_XML\nfrom .test_registry import _EMPTY_TOOLSET_XML\nfrom .test_registry import _NORMAL_TOOLSET_XML\nfrom .test_registry import _SINGLE_EXPORT_XML\nfrom .test_registry import _SINGLE_IMPORT_XML\nfrom .test_registry import ONE_FUNC\nfrom .test_registry import IAnotherSite\nfrom .test_registry import IDerivedSite\nfrom .test_registry import ISite\nfrom .test_zcml import dummy_upgrade\n\n\n_before_import_events = []\n\n\n@adapter(IBeforeProfileImportEvent)\ndef handleBeforeProfileImportEvent(event):\n    _before_import_events.append(event)\n\n\n_after_import_events = []\n\n\n@adapter(IProfileImportedEvent)\ndef handleProfileImportedEvent(event):\n    _after_import_events.append(event)\n\n\n_METADATA_XML = \"\"\"<?xml version=\"1.0\"?>\n<metadata>\n  <version>1.0</version>\n  <dependencies>\n    <dependency>profile-other:bar</dependency>\n  </dependencies>\n</metadata>\n\"\"\"\n_DOUBLE_METADATA_XML = \"\"\"<?xml version=\"1.0\"?>\n<metadata>\n  <version>1.0</version>\n  <dependencies>\n    <dependency>profile-other:bar</dependency>\n    <dependency>profile-other:ham</dependency>\n  </dependencies>\n</metadata>\n\"\"\"\n_PLAIN_METADATA_XML = \"\"\"<?xml version=\"1.0\"?>\n<metadata>\n  <version>1.0</version>\n</metadata>\n\"\"\"\n_BROKEN_METADATA_XML = \"\"\"<?xml version=\"1.0\"?>\n<metadata>\n  <version>1.0</version>\n  <dependencies>\n    <dependency>profile-other:non-existing-profile</dependency>\n  </dependencies>\n</metadata>\n\"\"\"\n\n\nclass SetupToolTests(FilesystemTestBase, TarballTester, ConformsToISetupTool):\n\n    layer = ExportImportZCMLLayer\n\n    _PROFILE_PATH = tempfile.mkdtemp(prefix='STT_test')\n    _PROFILE_PATH2 = tempfile.mkdtemp(prefix='STT_test2')\n    _PROFILE_PATH3 = tempfile.mkdtemp(prefix='STT_test3')\n\n    def afterSetUp(self):\n        from ..upgrade import _upgrade_registry\n        _upgrade_registry.clear()\n        profile_registry.clear()\n        global _before_import_events\n        global _after_import_events\n        _before_import_events = []\n        provideHandler(handleBeforeProfileImportEvent)\n        _after_import_events = []\n        provideHandler(handleProfileImportedEvent)\n\n    def beforeTearDown(self):\n        base_registry.unregisterHandler(handleBeforeProfileImportEvent)\n        base_registry.unregisterHandler(handleProfileImportedEvent)\n        FilesystemTestBase.beforeTearDown(self)\n        from ..upgrade import _upgrade_registry\n        profile_registry.clear()\n        _upgrade_registry.clear()\n        noSecurityManager()\n\n    def _getTargetClass(self):\n        from ..tool import SetupTool\n\n        return SetupTool\n\n    def _makeSite(self, title=\"Don't care\"):\n\n        site = Folder()\n        site._setId('site')\n        site.title = title\n\n        self.app._setObject('site', site)\n        self.app.acl_users.userFolderAddUser('admin', '', ['Manager'], [])\n        newSecurityManager(None, self.app.acl_users.getUser('admin'))\n        return self.app._getOb('site')\n\n    def test_empty(self):\n\n        tool = self._makeOne('setup_tool')\n\n        self.assertEqual(tool.getBaselineContextID(), '')\n\n        import_registry = tool.getImportStepRegistry()\n        self.assertEqual(len(import_registry.listSteps()), 0)\n\n        export_registry = tool.getExportStepRegistry()\n        export_steps = export_registry.listSteps()\n        self.assertEqual(len(export_steps), 0)\n\n        toolset_registry = tool.getToolsetRegistry()\n        self.assertEqual(len(toolset_registry.listForbiddenTools()), 0)\n        self.assertEqual(len(toolset_registry.listRequiredTools()), 0)\n\n    def test_getBaselineContextID(self):\n        from ..tool import EXPORT_STEPS_XML\n        from ..tool import IMPORT_STEPS_XML\n        from ..tool import TOOLSET_XML\n\n        tool = self._makeOne('setup_tool')\n\n        self._makeFile(IMPORT_STEPS_XML, _EMPTY_IMPORT_XML)\n        self._makeFile(EXPORT_STEPS_XML, _EMPTY_EXPORT_XML)\n        self._makeFile(TOOLSET_XML, _EMPTY_TOOLSET_XML)\n\n        profile_registry.registerProfile('foo', 'Foo', '', self._PROFILE_PATH)\n        tool.setBaselineContext('profile-other:foo')\n\n        self.assertEqual(tool.getBaselineContextID(), 'profile-other:foo')\n\n    def test_setBaselineContext_invalid(self):\n\n        tool = self._makeOne('setup_tool')\n\n        self.assertRaises(KeyError, tool.setBaselineContext, 'profile-foo')\n\n    def test_setBaselineContext_empty_string(self):\n\n        tool = self._makeOne('setup_tool')\n\n        self.assertRaises(KeyError, tool.setBaselineContext, '')\n\n    def test_setBaselineContext(self):\n        from ..tool import EXPORT_STEPS_XML\n        from ..tool import IMPORT_STEPS_XML\n        from ..tool import TOOLSET_XML\n\n        tool = self._makeOne('setup_tool')\n        tool.getExportStepRegistry().clear()\n\n        self._makeFile(IMPORT_STEPS_XML, _SINGLE_IMPORT_XML)\n        self._makeFile(EXPORT_STEPS_XML, _SINGLE_EXPORT_XML)\n        self._makeFile(TOOLSET_XML, _NORMAL_TOOLSET_XML)\n\n        profile_registry.registerProfile('foo', 'Foo', '', self._PROFILE_PATH)\n        tool.setBaselineContext('profile-other:foo')\n\n        self.assertEqual(tool.getBaselineContextID(), 'profile-other:foo')\n\n        import_registry = tool.getImportStepRegistry()\n        self.assertEqual(len(import_registry.listSteps()), 1)\n        self.assertTrue('one' in import_registry.listSteps())\n        info = import_registry.getStepMetadata('one')\n        self.assertEqual(info['id'], 'one')\n        self.assertEqual(info['title'], 'One Step')\n        self.assertEqual(info['version'], '1')\n        self.assertTrue('One small step' in info['description'])\n        self.assertEqual(info['handler'],\n                         'Products.GenericSetup.tests.test_registry.ONE_FUNC')\n\n        self.assertEqual(import_registry.getStep('one'), ONE_FUNC)\n\n        export_registry = tool.getExportStepRegistry()\n        self.assertEqual(len(export_registry.listSteps()), 1)\n        self.assertTrue('one' in import_registry.listSteps())\n        info = export_registry.getStepMetadata('one')\n        self.assertEqual(info['id'], 'one')\n        self.assertEqual(info['title'], 'One Step')\n        self.assertTrue('One small step' in info['description'])\n        self.assertEqual(info['handler'],\n                         'Products.GenericSetup.tests.test_registry.ONE_FUNC')\n\n        self.assertEqual(export_registry.getStep('one'), ONE_FUNC)\n\n    def test_runImportStepFromProfile_nonesuch(self):\n\n        site = self._makeSite()\n\n        tool = self._makeOne('setup_tool').__of__(site)\n\n        self.assertRaises(KeyError, tool.runImportStepFromProfile,\n                          '', 'nonesuch')\n\n    def test_runImportStepFromProfile_simple(self):\n\n        TITLE = 'original title'\n        site = self._makeSite(TITLE)\n\n        tool = self._makeOne('setup_tool').__of__(site)\n\n        registry = tool.getImportStepRegistry()\n        registry.registerStep('simple', '1', _uppercaseSiteTitle)\n\n        result = tool.runImportStepFromProfile('snapshot-dummy', 'simple')\n\n        self.assertEqual(len(result['steps']), 1)\n\n        self.assertEqual(result['steps'][0], 'simple')\n        self.assertEqual(result['messages']['simple'], 'Uppercased title')\n\n        self.assertEqual(site.title, TITLE.upper())\n\n        global _before_import_events\n        self.assertEqual(len(_before_import_events), 1)\n        self.assertEqual(_before_import_events[0].profile_id, 'snapshot-dummy')\n        self.assertEqual(_before_import_events[0].steps, ['simple'])\n        self.assertEqual(_before_import_events[0].full_import, False)\n\n        global _after_import_events\n        self.assertEqual(len(_after_import_events), 1)\n        self.assertEqual(_after_import_events[0].profile_id, 'snapshot-dummy')\n        self.assertEqual(_after_import_events[0].steps, ['simple'])\n        self.assertEqual(_after_import_events[0].full_import, False)\n\n    def test_runImportStepFromProfile_dependencies(self):\n\n        TITLE = 'original title'\n        site = self._makeSite(TITLE)\n\n        tool = self._makeOne('setup_tool').__of__(site)\n\n        registry = tool.getImportStepRegistry()\n        registry.registerStep('dependable', '1', _underscoreSiteTitle)\n        registry.registerStep(\n            'dependent', '1', _uppercaseSiteTitle, ('dependable', ))\n\n        result = tool.runImportStepFromProfile('snapshot-dummy', 'dependent')\n\n        self.assertEqual(len(result['steps']), 2)\n\n        self.assertEqual(result['steps'][0], 'dependable')\n        self.assertEqual(result['messages']['dependable'], 'Underscored title')\n\n        self.assertEqual(result['steps'][1], 'dependent')\n        self.assertEqual(result['messages']['dependent'], 'Uppercased title')\n        self.assertEqual(site.title, TITLE.replace(' ', '_').upper())\n\n        global _before_import_events\n        self.assertEqual(len(_before_import_events), 1)\n        self.assertEqual(_before_import_events[0].profile_id, 'snapshot-dummy')\n        self.assertEqual(_before_import_events[0].steps,\n                         ['dependable', 'dependent'])\n        self.assertEqual(_before_import_events[0].full_import, False)\n\n        global _after_import_events\n        self.assertEqual(len(_after_import_events), 1)\n        self.assertEqual(_after_import_events[0].profile_id, 'snapshot-dummy')\n        self.assertEqual(_after_import_events[0].steps,\n                         ['dependable', 'dependent'])\n        self.assertEqual(_after_import_events[0].full_import, False)\n\n    def test_runImportStepFromProfile_skip_dependencies(self):\n\n        TITLE = 'original title'\n        site = self._makeSite(TITLE)\n\n        tool = self._makeOne('setup_tool').__of__(site)\n\n        registry = tool.getImportStepRegistry()\n        registry.registerStep('dependable', '1', _underscoreSiteTitle)\n        registry.registerStep(\n            'dependent', '1', _uppercaseSiteTitle, ('dependable', ))\n\n        result = tool.runImportStepFromProfile('snapshot-dummy', 'dependent',\n                                               run_dependencies=False)\n\n        self.assertEqual(len(result['steps']), 1)\n\n        self.assertEqual(result['steps'][0], 'dependent')\n        self.assertEqual(result['messages']['dependent'], 'Uppercased title')\n\n        self.assertEqual(site.title, TITLE.upper())\n\n        global _before_import_events\n        self.assertEqual(len(_before_import_events), 1)\n        self.assertEqual(_before_import_events[0].profile_id, 'snapshot-dummy')\n        self.assertEqual(_before_import_events[0].steps, ['dependent'])\n        self.assertEqual(_before_import_events[0].full_import, False)\n\n        global _after_import_events\n        self.assertEqual(len(_after_import_events), 1)\n        self.assertEqual(_after_import_events[0].profile_id, 'snapshot-dummy')\n        self.assertEqual(_after_import_events[0].steps, ['dependent'])\n        self.assertEqual(_after_import_events[0].full_import, False)\n\n    def test_runImportStepFromProfile_default_purge(self):\n\n        site = self._makeSite()\n\n        tool = self._makeOne('setup_tool').__of__(site)\n        registry = tool.getImportStepRegistry()\n        registry.registerStep('purging', '1', _purgeIfRequired)\n\n        result = tool.runImportStepFromProfile('snapshot-dummy', 'purging')\n\n        self.assertEqual(len(result['steps']), 1)\n        self.assertEqual(result['steps'][0], 'purging')\n        self.assertEqual(result['messages']['purging'], 'Purged')\n        self.assertTrue(site.purged)\n\n    def test_runImportStepFromProfile_explicit_purge(self):\n\n        site = self._makeSite()\n\n        tool = self._makeOne('setup_tool').__of__(site)\n        registry = tool.getImportStepRegistry()\n        registry.registerStep('purging', '1', _purgeIfRequired)\n\n        result = tool.runImportStepFromProfile('snapshot-dummy', 'purging',\n                                               purge_old=True)\n\n        self.assertEqual(len(result['steps']), 1)\n        self.assertEqual(result['steps'][0], 'purging')\n        self.assertEqual(result['messages']['purging'], 'Purged')\n        self.assertTrue(site.purged)\n\n    def test_runImportStepFromProfile_skip_purge(self):\n\n        site = self._makeSite()\n\n        tool = self._makeOne('setup_tool').__of__(site)\n        registry = tool.getImportStepRegistry()\n        registry.registerStep('purging', '1', _purgeIfRequired)\n\n        result = tool.runImportStepFromProfile('snapshot-dummy', 'purging',\n                                               purge_old=False)\n\n        self.assertEqual(len(result['steps']), 1)\n        self.assertEqual(result['steps'][0], 'purging')\n        self.assertEqual(result['messages']['purging'], 'Unpurged')\n        self.assertFalse(site.purged)\n\n    def test_runImportStepFromProfile_consistent_context(self):\n\n        site = self._makeSite()\n\n        tool = self._makeOne('setup_tool').__of__(site)\n\n        registry = tool.getImportStepRegistry()\n        registry.registerStep('purging', '1', _purgeIfRequired)\n        registry.registerStep(\n            'dependent', '1', _uppercaseSiteTitle, ('purging', ))\n\n        tool.runImportStepFromProfile('snapshot-dummy', 'dependent',\n                                      purge_old=False)\n        self.assertFalse(site.purged)\n\n    def test_runAllImportStepsFromProfile_empty(self):\n\n        site = self._makeSite()\n        tool = self._makeOne('setup_tool').__of__(site)\n\n        result = tool.runAllImportStepsFromProfile('snapshot-dummy')\n\n        self.assertEqual(len(result['steps']), 3)\n\n    def test_runAllImportStepsFromProfile_inquicksuccession(self):\n        \"\"\"\n        This test provokes an issue that only appears in testing.\n        There it can happen that profiles get run multiple times within\n        a second. As of 1.6.3, genericsetup does not handle this.\n        \"\"\"\n\n        site = self._makeSite()\n        tool = self._makeOne('setup_tool').__of__(site)\n\n        tool.runAllImportStepsFromProfile('snapshot-dummy')\n        tool.runAllImportStepsFromProfile('snapshot-dummy')\n        # For good measurement\n        tool.runAllImportStepsFromProfile('snapshot-dummy')\n\n        self.assertTrue(\"No exception thrown\")\n\n    def test_runAllImportStepsFromProfile_sorted_default_purge(self):\n\n        TITLE = 'original title'\n        PROFILE_ID = 'snapshot-testing'\n        site = self._makeSite(TITLE)\n        tool = self._makeOne('setup_tool').__of__(site)\n        tool._exclude_global_steps = True\n\n        registry = tool.getImportStepRegistry()\n        registry.registerStep(\n            'dependable', '1', _underscoreSiteTitle, ('purging', ))\n        registry.registerStep(\n            'dependent', '1', _uppercaseSiteTitle, ('dependable', ))\n        registry.registerStep('purging', '1', _purgeIfRequired)\n\n        result = tool.runAllImportStepsFromProfile(PROFILE_ID)\n\n        self.assertEqual(len(result['steps']), 3)\n\n        self.assertEqual(result['steps'][0], 'purging')\n        self.assertEqual(result['messages']['purging'], 'Purged')\n\n        self.assertEqual(result['steps'][1], 'dependable')\n        self.assertEqual(result['messages']['dependable'], 'Underscored title')\n\n        self.assertEqual(result['steps'][2], 'dependent')\n        self.assertEqual(result['messages']['dependent'], 'Uppercased title')\n\n        self.assertEqual(site.title, TITLE.replace(' ', '_').upper())\n        self.assertTrue(site.purged)\n\n        prefix = 'import-all-%s' % PROFILE_ID\n        logged = [x for x in tool.objectIds('File') if x.startswith(prefix)]\n        self.assertEqual(len(logged), 1)\n\n    def test_runAllImportStepsFromProfile_unicode_id_creates_reports(self):\n\n        TITLE = 'original title'\n        PROFILE_ID = u'snapshot-testing'\n        site = self._makeSite(TITLE)\n        tool = self._makeOne('setup_tool').__of__(site)\n\n        registry = tool.getImportStepRegistry()\n        registry.registerStep(\n            'dependable', '1', _underscoreSiteTitle, ('purging', ))\n        registry.registerStep(\n            'dependent', '1', _uppercaseSiteTitle, ('dependable', ))\n        registry.registerStep('purging', '1', _purgeIfRequired)\n\n        tool.runAllImportStepsFromProfile(PROFILE_ID)\n\n        prefix = str('import-all-%s' % PROFILE_ID)\n        logged = [x for x in tool.objectIds('File') if x.startswith(prefix)]\n        self.assertEqual(len(logged), 1)\n\n        # Check acess restriction on log files\n        logged = [x for x in tool.objectIds('File')]\n        for file_id in logged:\n            file_ob = tool._getOb(file_id)\n            rop_info = file_ob.rolesOfPermission(view)\n            allowed_roles = sorted([x['name'] for x in rop_info\n                                    if x['selected']])\n            self.assertEqual(allowed_roles, ['Manager', 'Owner'])\n            self.assertFalse(file_ob.acquiredRolesAreUsedBy(view))\n\n    def test_runAllImportStepsFromProfile_sorted_explicit_purge(self):\n\n        site = self._makeSite()\n        tool = self._makeOne('setup_tool').__of__(site)\n        tool._exclude_global_steps = True\n\n        registry = tool.getImportStepRegistry()\n        registry.registerStep(\n            'dependable', '1', _underscoreSiteTitle, ('purging', ))\n        registry.registerStep(\n            'dependent', '1', _uppercaseSiteTitle, ('dependable', ))\n        registry.registerStep('purging', '1', _purgeIfRequired)\n\n        result = tool.runAllImportStepsFromProfile('snapshot-dummy',\n                                                   purge_old=True)\n\n        self.assertEqual(len(result['steps']), 3)\n\n        self.assertEqual(result['steps'][0], 'purging')\n        self.assertEqual(result['messages']['purging'], 'Purged')\n\n        self.assertEqual(result['steps'][1], 'dependable')\n        self.assertEqual(result['steps'][2], 'dependent')\n        self.assertTrue(site.purged)\n\n    def test_runAllImportStepsFromProfile_sorted_skip_purge(self):\n\n        site = self._makeSite()\n        tool = self._makeOne('setup_tool').__of__(site)\n        tool._exclude_global_steps = True\n\n        registry = tool.getImportStepRegistry()\n        registry.registerStep(\n            'dependable', '1', _underscoreSiteTitle, ('purging', ))\n        registry.registerStep(\n            'dependent', '1', _uppercaseSiteTitle, ('dependable', ))\n        registry.registerStep('purging', '1', _purgeIfRequired)\n\n        result = tool.runAllImportStepsFromProfile('snapshot-dummy',\n                                                   purge_old=False)\n\n        self.assertEqual(len(result['steps']), 3)\n\n        self.assertEqual(result['steps'][0], 'purging')\n        self.assertEqual(result['messages']['purging'], 'Unpurged')\n\n        self.assertEqual(result['steps'][1], 'dependable')\n        self.assertEqual(result['steps'][2], 'dependent')\n        self.assertFalse(site.purged)\n\n    def test_runAllImportStepsFromProfile_without_depends(self):\n        from ..metadata import METADATA_XML\n\n        self._makeFile(METADATA_XML, _METADATA_XML)\n\n        site = self._makeSite()\n        tool = self._makeOne('setup_tool').__of__(site)\n\n        profile_registry.registerProfile('foo', 'Foo', '', self._PROFILE_PATH)\n\n        _imported = []\n\n        def applyContext(context):\n            _imported.append(context._profile_path)\n\n        tool.applyContext = applyContext\n        tool.runAllImportStepsFromProfile('profile-other:foo',\n                                          ignore_dependencies=True)\n        self.assertEqual(_imported, [self._PROFILE_PATH])\n\n    def test_runAllImportStepsFromProfile_with_depends(self):\n        from ..metadata import METADATA_XML\n\n        self._makeFile(METADATA_XML, _METADATA_XML)\n\n        site = self._makeSite()\n        tool = self._makeOne('setup_tool').__of__(site)\n\n        profile_registry.registerProfile('foo', 'Foo', '', self._PROFILE_PATH)\n        profile_registry.registerProfile('bar', 'Bar', '', self._PROFILE_PATH2)\n\n        _imported = []\n\n        def applyContext(context):\n            _imported.append(context._profile_path)\n\n        tool.applyContext = applyContext\n        tool.runAllImportStepsFromProfile('profile-other:foo',\n                                          ignore_dependencies=False)\n        self.assertEqual(_imported, [self._PROFILE_PATH2, self._PROFILE_PATH])\n\n    def _setup_dependency_strategy_test_tool(self):\n        # If we add a dependency profile in our metadata.xml, and this\n        # dependency was already applied, then we do not need to apply\n        # it yet again.  Once is quite enough, thank you.  Running any\n        # upgrade steps would be nice though.  There are options.\n        # Setup a tool and profiles for testing dependency strategies.\n        from ..interfaces import EXTENSION\n        from ..metadata import METADATA_XML\n        self._makeFile(METADATA_XML, _DOUBLE_METADATA_XML)\n        _makeTestFile(METADATA_XML, self._PROFILE_PATH2, _PLAIN_METADATA_XML)\n        _makeTestFile(METADATA_XML, self._PROFILE_PATH3, _PLAIN_METADATA_XML)\n        site = self._makeSite()\n        tool = self._makeOne('setup_tool').__of__(site)\n\n        # Register main profile and two dependency profiles.\n        profile_registry.registerProfile('foo', 'Foo', '', self._PROFILE_PATH,\n                                         profile_type=EXTENSION)\n        profile_registry.registerProfile('bar', 'Bar', '', self._PROFILE_PATH2,\n                                         profile_type=EXTENSION)\n        profile_registry.registerProfile('ham', 'Ham', '', self._PROFILE_PATH3,\n                                         profile_type=EXTENSION)\n\n        # Apply the second profile.\n        tool.runAllImportStepsFromProfile('profile-other:bar')\n\n        # Register an upgrade step.  Note that applying this step will\n        # set the profile version to 1.1, even though the metadata of\n        # the profile really says 1.0.  We will use this to check\n        # whether the upgrade step has been applied (version is 1.1)\n        # or the full profile has been applied (version is 1.0).\n        step_bar = UpgradeStep(\n            \"Upgrade\", \"other:bar\", '1.0', '1.1', '', dummy_upgrade, None, \"1\")\n        _registerUpgradeStep(step_bar)\n        # And another one.\n        step_ham = UpgradeStep(\n            \"Upgrade\", \"other:ham\", '1.0', '1.1', '', dummy_upgrade, None, \"1\")\n        _registerUpgradeStep(step_ham)\n\n        # Gather list of imported profiles.\n        tool._imported = []\n\n        def applyContext(context):\n            tool._imported.append(context._profile_path)\n\n        tool.applyContext = applyContext\n\n        return tool\n\n    def test_runAllImportStepsFromProfile_with_default_strategy(self):\n        # Default strategy: apply new profiles, upgrade old profiles.\n        tool = self._setup_dependency_strategy_test_tool()\n\n        # Run the main profile.\n        tool.runAllImportStepsFromProfile('profile-other:foo')\n        # The main and third profile have been applied.\n        self.assertEqual(tool._imported,\n                         [self._PROFILE_PATH3, self._PROFILE_PATH])\n        # The upgrade step of the second profile has been applied,\n        # pushing it to version 1.1.\n        self.assertEqual(tool.getLastVersionForProfile('other:bar'),\n                         ('1', '1'))\n        # Third profile is at 1.0.\n        self.assertEqual(tool.getLastVersionForProfile('other:ham'),\n                         ('1', '0'))\n\n    def test_runAllImportStepsFromProfile_with_reapply_strategy(self):\n        # You can choose the old behavior of always applying the\n        # dependencies.  This ignores any upgrade steps.\n        tool = self._setup_dependency_strategy_test_tool()\n\n        # Run the main profile.\n        from ..tool import DEPENDENCY_STRATEGY_REAPPLY\n        tool.runAllImportStepsFromProfile(\n            'profile-other:foo',\n            dependency_strategy=DEPENDENCY_STRATEGY_REAPPLY)\n        # All three profiles have been applied.\n        self.assertEqual(tool._imported,\n                         [self._PROFILE_PATH2, self._PROFILE_PATH3,\n                          self._PROFILE_PATH])\n        self.assertEqual(tool.getLastVersionForProfile('other:bar'),\n                         ('1', '0'))\n        self.assertEqual(tool.getLastVersionForProfile('other:ham'),\n                         ('1', '0'))\n\n    def test_runAllImportStepsFromProfile_with_new_strategy(self):\n        # You can choose to be happy with any applied version and\n        # ignore any upgrade steps.\n        tool = self._setup_dependency_strategy_test_tool()\n\n        # Run the main profile.\n        from ..tool import DEPENDENCY_STRATEGY_NEW\n        tool.runAllImportStepsFromProfile(\n            'profile-other:foo',\n            dependency_strategy=DEPENDENCY_STRATEGY_NEW)\n        # The main and third profile have been applied.\n        self.assertEqual(tool._imported,\n                         [self._PROFILE_PATH3, self._PROFILE_PATH])\n        # Second profile stays at 1.0.\n        self.assertEqual(tool.getLastVersionForProfile('other:bar'),\n                         ('1', '0'))\n        self.assertEqual(tool.getLastVersionForProfile('other:ham'),\n                         ('1', '0'))\n\n    def test_runAllImportStepsFromProfile_with_ignore_strategy(self):\n        # You can choose to be ignore all dependency profiles.\n        tool = self._setup_dependency_strategy_test_tool()\n\n        # Run the main profile.\n        from ..tool import DEPENDENCY_STRATEGY_IGNORE\n        tool.runAllImportStepsFromProfile(\n            'profile-other:foo',\n            dependency_strategy=DEPENDENCY_STRATEGY_IGNORE)\n        # Only the main profile has been applied.\n        self.assertEqual(tool._imported,\n                         [self._PROFILE_PATH])\n        # Second profile stays at 1.0.\n        self.assertEqual(tool.getLastVersionForProfile('other:bar'),\n                         ('1', '0'))\n        # Third profile is not applied.\n        self.assertEqual(tool.getLastVersionForProfile('other:ham'),\n                         ('unknown'))\n\n    def test_runAllImportStepsFromProfile_unknown_strategy(self):\n        site = self._makeSite()\n        tool = self._makeOne('setup_tool').__of__(site)\n        profile_registry.registerProfile('foo', 'Foo', '', self._PROFILE_PATH)\n        self.assertRaises(ValueError, tool.runAllImportStepsFromProfile,\n                          'profile-other:foo', dependency_strategy='random')\n\n    def test_runAllImportStepsFromProfile_set_last_profile_version(self):\n        from ..metadata import METADATA_XML\n\n        self._makeFile(METADATA_XML, _METADATA_XML)\n\n        site = self._makeSite()\n        tool = self._makeOne('setup_tool').__of__(site)\n\n        profile_registry.registerProfile('foo', 'Foo', '', self._PROFILE_PATH)\n\n        # test initial states\n        profile_id = \"other:foo\"\n        self.assertEqual(tool.getVersionForProfile(profile_id), '1.0')\n        self.assertEqual(tool.getLastVersionForProfile(profile_id),\n                         'unknown')\n\n        # run all imports steps\n        tool.runAllImportStepsFromProfile('profile-other:foo',\n                                          ignore_dependencies=True)\n\n        # events.handleProfileImportedEvent should set last profile version\n        self.assertEqual(tool.getLastVersionForProfile(profile_id),\n                         ('1', '0'))\n\n    def test_runAllImportStepsFromProfile_step_registration_with_depends(self):\n        from ..metadata import METADATA_XML\n\n        self._makeFile(METADATA_XML, _METADATA_XML)\n\n        _IMPORT_STEPS_XML = \"\"\"<?xml version=\"1.0\"?>\n<import-steps>\n <import-step id=\"one\"\n             version=\"1\"\n             handler=\"Products.GenericSetup.tests.common.dummy_handler\"\n             title=\"One Step\">\n  One small step\n </import-step>\n</import-steps>\n\"\"\"\n        self._makeFile('import_steps.xml', _IMPORT_STEPS_XML)\n\n        site = self._makeSite()\n        tool = self._makeOne('setup_tool').__of__(site)\n\n        profile_registry.registerProfile('foo', 'Foo', '', self._PROFILE_PATH)\n        profile_registry.registerProfile('bar', 'Bar', '', self._PROFILE_PATH2)\n\n        result = tool.runAllImportStepsFromProfile('profile-other:foo',\n                                                   ignore_dependencies=False)\n\n        # ensure the additional step on foo was imported\n        self.assertTrue('one' in result['steps'])\n\n    def test_runAllImportStepsFromProfile_skipStep(self):\n\n        site = self._makeSite()\n        tool = self._makeOne('setup_tool').__of__(site)\n        result = tool.runAllImportStepsFromProfile(\n            'snapshot-dummy',\n            blacklisted_steps=['toolset'],\n        )\n\n        self.assertEqual((result['messages']['toolset']), 'step skipped')\n\n    def test_runAllImportStepsFromProfile_with_base_profile(self):\n        # Applying a base profile should clear the profile upgrade\n        # versions.\n        from ..interfaces import BASE\n        from ..interfaces import EXTENSION\n        from ..metadata import METADATA_XML\n        site = self._makeSite()\n        site.setup_tool = self._makeOne('setup_tool')\n        tool = site.setup_tool\n        self._makeFile(METADATA_XML, _METADATA_XML)\n        _makeTestFile(METADATA_XML, self._PROFILE_PATH2, _PLAIN_METADATA_XML)\n        _makeTestFile(METADATA_XML, self._PROFILE_PATH3, _PLAIN_METADATA_XML)\n\n        # Register a base and two extension profile.  The base profile\n        # 'foo' has a dependency 'bar'.  This might not make sense,\n        # but it will serve to check that we clear the profile\n        # versions right before we apply the base profile, which means\n        # right after any dependency profiles.\n        profile_registry.registerProfile(\n            'foo', 'Foo', '', self._PROFILE_PATH, profile_type=BASE)\n        profile_registry.registerProfile(\n            'bar', 'Bar', '', self._PROFILE_PATH2, profile_type=EXTENSION)\n        profile_registry.registerProfile(\n            'ham', 'Ham', '', self._PROFILE_PATH3, profile_type=EXTENSION)\n        # Apply the extension profile.\n        tool.runAllImportStepsFromProfile('profile-other:ham')\n        self.assertEqual(tool._profile_upgrade_versions,\n                         {u'other:ham': (u'1', u'0')})\n        # Apply the base profile.\n        tool.runAllImportStepsFromProfile('profile-other:foo')\n        self.assertEqual(tool._profile_upgrade_versions,\n                         {u'other:foo': (u'1', u'0')})\n\n    def test_runAllImportStepsFromProfile_with_unknown_pre_handler(self):\n        # Registering already fails.\n        self.assertRaises(\n            ValueError, profile_registry.registerProfile,\n            'foo', 'Foo', '', self._PROFILE_PATH,\n            pre_handler='Products.GenericSetup.tests.test_tool.foo_handler')\n\n    def test_runAllImportStepsFromProfile_with_unknown_post_handler(self):\n        # Registering already fails.\n        self.assertRaises(\n            ValueError, profile_registry.registerProfile,\n            'foo', 'Foo', '', self._PROFILE_PATH,\n            post_handler='Products.GenericSetup.tests.test_tool.foo_handler')\n\n    def test_runAllImportStepsFromProfile_pre_post_handlers_dotted_names(self):\n        site = self._makeSite()\n        tool = self._makeOne('setup_tool').__of__(site)\n        profile_registry.registerProfile(\n            'foo', 'Foo', '', self._PROFILE_PATH,\n            pre_handler='Products.GenericSetup.tests.test_tool.pre_handler',\n            post_handler='Products.GenericSetup.tests.test_tool.post_handler')\n        tool.runAllImportStepsFromProfile('profile-other:foo')\n        self.assertEqual(tool.pre_handler_called, 1)\n        self.assertEqual(tool.post_handler_called, 1)\n        tool.runAllImportStepsFromProfile('profile-other:foo')\n        self.assertEqual(tool.pre_handler_called, 2)\n        self.assertEqual(tool.post_handler_called, 2)\n\n    def test_runAllImportStepsFromProfile_pre_post_handlers_functions(self):\n        # When you register a profile with pre/post handlers in zcml, you do\n        # not get dotted names (strings) but an actual function.\n        site = self._makeSite()\n        tool = self._makeOne('setup_tool').__of__(site)\n        profile_registry.registerProfile(\n            'foo', 'Foo', '', self._PROFILE_PATH,\n            pre_handler=pre_handler,\n            post_handler=post_handler)\n        tool.runAllImportStepsFromProfile('profile-other:foo')\n        self.assertEqual(tool.pre_handler_called, 1)\n        self.assertEqual(tool.post_handler_called, 1)\n        tool.runAllImportStepsFromProfile('profile-other:foo')\n        self.assertEqual(tool.pre_handler_called, 2)\n        self.assertEqual(tool.post_handler_called, 2)\n\n    def test_runExportStep_nonesuch(self):\n        site = self._makeSite()\n        tool = self._makeOne('setup_tool').__of__(site)\n\n        self.assertRaises(ValueError, tool.runExportStep, 'nonesuch')\n\n    def test_runExportStep_step_registry_empty(self):\n        site = self._makeSite()\n        site.setup_tool = self._makeOne('setup_tool')\n        tool = site.setup_tool\n\n        result = tool.runExportStep('step_registries')\n\n        self.assertEqual(len(result['steps']), 1)\n        self.assertEqual(result['steps'][0], 'step_registries')\n        self.assertEqual(result['messages']['step_registries'], None)\n\n    def test_runExportStep_step_registry_default(self):\n        site = self._makeSite()\n        site.setup_tool = self._makeOne('setup_tool')\n        tool = site.setup_tool\n        tool._import_registry.registerStep('foo', handler='foo.bar')\n        steps = 'Products.GenericSetup.tool.exportStepRegistries'\n        tool._export_registry.registerStep('step_registries', steps,\n                                           'Export import / export steps.')\n\n        result = tool.runExportStep('step_registries')\n\n        self.assertEqual(len(result['steps']), 1)\n        self.assertEqual(result['steps'][0], 'step_registries')\n        self.assertEqual(result['messages']['step_registries'], None)\n        fileish = BytesIO(result['tarball'])\n\n        self._verifyTarballContents(fileish,\n                                    ['import_steps.xml', 'export_steps.xml'])\n        self._verifyTarballEntryXML(\n            fileish, 'import_steps.xml', _DEFAULT_STEP_REGISTRIES_IMPORT_XML)\n        self._verifyTarballEntryXML(\n            fileish, 'export_steps.xml', _DEFAULT_STEP_REGISTRIES_EXPORT_XML)\n\n    def test_runAllExportSteps_empty(self):\n        site = self._makeSite()\n        site.setup_tool = self._makeOne('setup_tool')\n        tool = site.setup_tool\n\n        result = tool.runAllExportSteps()\n\n        self.assertEqual(\n            sorted(result['steps']),\n            ['componentregistry', 'rolemap', 'step_registries', 'toolset'])\n        self.assertEqual(result['messages']['step_registries'], None)\n\n    def test_runAllExportSteps_default(self):\n        site = self._makeSite()\n        site.setup_tool = self._makeOne('setup_tool')\n        tool = site.setup_tool\n        tool._import_registry.registerStep('foo', handler='foo.bar')\n        steps = 'Products.GenericSetup.tool.exportStepRegistries'\n        tool._export_registry.registerStep('step_registries', steps,\n                                           'Export import / export steps.')\n\n        result = tool.runAllExportSteps()\n\n        self.assertEqual(sorted(result['steps']),\n                         ['componentregistry', 'rolemap',\n                          'step_registries', 'toolset'])\n        self.assertEqual(result['messages']['step_registries'], None)\n        fileish = BytesIO(result['tarball'])\n\n        self._verifyTarballContents(fileish,\n                                    ['import_steps.xml', 'export_steps.xml',\n                                     'rolemap.xml', 'toolset.xml'])\n        self._verifyTarballEntryXML(\n            fileish, 'import_steps.xml', _DEFAULT_STEP_REGISTRIES_IMPORT_XML)\n        self._verifyTarballEntryXML(\n            fileish, 'export_steps.xml', _DEFAULT_STEP_REGISTRIES_EXPORT_XML)\n\n    def test_runAllExportSteps_extras(self):\n        site = self._makeSite()\n        site.setup_tool = self._makeOne('setup_tool')\n        tool = site.setup_tool\n        steps = 'Products.GenericSetup.tool.exportStepRegistries'\n        tool._export_registry.registerStep('step_registries', steps,\n                                           'Export import / export steps.')\n\n        import_reg = tool.getImportStepRegistry()\n        import_reg.registerStep(\n            'dependable', '1', _underscoreSiteTitle, ('purging', ))\n        import_reg.registerStep(\n            'dependent', '1', _uppercaseSiteTitle, ('dependable', ))\n        import_reg.registerStep('purging', '1', _purgeIfRequired)\n\n        export_reg = tool.getExportStepRegistry()\n        export_reg.registerStep('properties', _exportPropertiesINI)\n\n        result = tool.runAllExportSteps()\n\n        self.assertEqual(len(result['steps']), 5)\n        self.assertEqual(sorted(result['steps']),\n                         ['componentregistry', 'properties', 'rolemap',\n                          'step_registries', 'toolset'])\n\n        self.assertEqual(result['messages']['properties'],\n                         'Exported properties')\n        self.assertEqual(result['messages']['step_registries'], None)\n\n        fileish = BytesIO(result['tarball'])\n\n        self._verifyTarballContents(fileish,\n                                    ['import_steps.xml', 'export_steps.xml',\n                                     'properties.ini', 'rolemap.xml',\n                                     'toolset.xml'])\n        self._verifyTarballEntryXML(\n            fileish, 'import_steps.xml', _EXTRAS_STEP_REGISTRIES_IMPORT_XML)\n        self._verifyTarballEntryXML(\n            fileish, 'export_steps.xml', _EXTRAS_STEP_REGISTRIES_EXPORT_XML)\n        ini_string = _PROPERTIES_INI % site.title\n        self._verifyTarballEntry(fileish, 'properties.ini',\n                                 ini_string.encode('utf-8'))\n\n    def test_manage_importTarball(self):\n        # Tests for importing a tarball with GenericSetup files.\n        # We are especially interested to see if old settings get purged.\n        site = self._makeSite()\n        site.setup_tool = self._makeOne('setup_tool')\n        tool = site.setup_tool\n        # We need to be Manager to see the result of calling\n        # manage_importTarball.\n        newSecurityManager(None, UnrestrictedUser('root', '', ['Manager'], ''))\n\n        ROLEMAP_XML = \"\"\"<?xml version=\"1.0\"?>\n<rolemap>\n  <roles>\n    <role name=\"%s\" />\n  </roles>\n  <permissions />\n</rolemap>\n\"\"\"\n\n        def rolemap_tarball(name):\n            # Create a tarball archive with rolemap.xml containing 'name' as\n            # role.\n            context = TarballExportContext(tool)\n            contents = ROLEMAP_XML % name\n            if isinstance(contents, six.text_type):\n                contents = contents.encode('utf-8')\n            context.writeDataFile('rolemap.xml', contents, 'text/xml')\n            return context.getArchive()\n\n        # Import first role.\n        tool.manage_importTarball(rolemap_tarball('First'))\n        self.assertTrue('First' in site.valid_roles())\n\n        # Import second role.\n        tool.manage_importTarball(rolemap_tarball('Second'))\n        self.assertTrue('Second' in site.valid_roles())\n        # The first role has been purged, because that is the default.\n        self.assertFalse('First' in site.valid_roles())\n        # A few standard roles are never removed, probably because they are\n        # defined one level higher.\n        self.assertTrue('Anonymous' in site.valid_roles())\n        self.assertTrue('Authenticated' in site.valid_roles())\n        self.assertTrue('Manager' in site.valid_roles())\n        self.assertTrue('Owner' in site.valid_roles())\n\n        # Import third role in non-purge mode.\n        tool.manage_importTarball(rolemap_tarball('Third'), purge_old=False)\n        self.assertTrue('Third' in site.valid_roles())\n        # The second role is still there.\n        self.assertTrue('Second' in site.valid_roles())\n\n        # When you use the form, and uncheck the purge_old checkbox, then the\n        # browser does not send the purge_old parameter in the request.  To\n        # work around this, the form always passes a hidden 'submitted'\n        # parameter.\n        # Import fourth role in non-purge mode with a form submit.\n        tool.manage_importTarball(rolemap_tarball('Fourth'), submitted='yes')\n        self.assertTrue('Fourth' in site.valid_roles())\n        # The other roles are still there.\n        self.assertTrue('Second' in site.valid_roles())\n        self.assertTrue('Third' in site.valid_roles())\n        self.assertTrue('Manager' in site.valid_roles())\n\n    def test_createSnapshot_default(self):\n        _EXPECTED = [\n            ('import_steps.xml', _DEFAULT_STEP_REGISTRIES_IMPORT_XML),\n            ('export_steps.xml', _DEFAULT_STEP_REGISTRIES_EXPORT_XML),\n            ('rolemap.xml', 'dummy'),\n            ('toolset.xml', 'dummy'),\n        ]\n\n        site = self._makeSite()\n        site.setup_tool = self._makeOne('setup_tool')\n        tool = site.setup_tool\n        tool._import_registry.registerStep('foo', handler='foo.bar')\n        tool._export_registry.registerStep(\n            'step_registries',\n            'Products.GenericSetup.tool.exportStepRegistries',\n            'Export import / export steps.')\n\n        self.assertEqual(len(tool.listSnapshotInfo()), 0)\n\n        result = tool.createSnapshot('default')\n\n        self.assertEqual(\n            sorted(result['steps']),\n            ['componentregistry', 'rolemap', 'step_registries', 'toolset'])\n        self.assertEqual(result['messages']['step_registries'], None)\n\n        snapshot = result['snapshot']\n\n        self.assertEqual(len(snapshot.objectIds()), len(_EXPECTED))\n\n        for id in [x[0] for x in _EXPECTED]:\n            self.assertTrue(id in snapshot.objectIds())\n\n        def normalize_xml(xml):\n            # using this might mask a real problem on windows, but so far the\n            # different newlines just caused problems in this test\n            lines = [line.strip() for line in xml.splitlines() if line.strip()]\n            return ' '.join(lines)\n\n        fileobj = snapshot._getOb('import_steps.xml')\n        self.assertEqual(normalize_xml(fileobj.read()),\n                         normalize_xml(_DEFAULT_STEP_REGISTRIES_IMPORT_XML))\n\n        fileobj = snapshot._getOb('export_steps.xml')\n        self.assertEqual(normalize_xml(fileobj.read()),\n                         normalize_xml(_DEFAULT_STEP_REGISTRIES_EXPORT_XML))\n\n        self.assertEqual(len(tool.listSnapshotInfo()), 1)\n\n        info = tool.listSnapshotInfo()[0]\n\n        self.assertEqual(info['id'], 'default')\n        self.assertEqual(info['title'], 'default')\n\n    def test_applyContext(self):\n        from ..tool import EXPORT_STEPS_XML\n        from ..tool import IMPORT_STEPS_XML\n        from ..tool import TOOLSET_XML\n\n        site = self._makeSite()\n        tool = self._makeOne('setup_tool').__of__(site)\n        tool.getImportStepRegistry().clear()\n        tool.getExportStepRegistry().clear()\n        tool.getToolsetRegistry().clear()\n\n        context = DummyImportContext(site, tool=tool)\n        context._files[IMPORT_STEPS_XML] = _SINGLE_IMPORT_XML\n        context._files[EXPORT_STEPS_XML] = _SINGLE_EXPORT_XML\n        context._files[TOOLSET_XML] = _NORMAL_TOOLSET_XML\n\n        tool.applyContext(context)\n\n        import_registry = tool.getImportStepRegistry()\n        self.assertEqual(len(import_registry.listSteps()), 1)\n        self.assertTrue('one' in import_registry.listSteps())\n        info = import_registry.getStepMetadata('one')\n\n        self.assertEqual(info['id'], 'one')\n        self.assertEqual(info['title'], 'One Step')\n        self.assertEqual(info['version'], '1')\n        self.assertTrue('One small step' in info['description'])\n        self.assertEqual(info['handler'],\n                         'Products.GenericSetup.tests.test_registry.ONE_FUNC')\n\n        self.assertEqual(import_registry.getStep('one'), ONE_FUNC)\n\n        export_registry = tool.getExportStepRegistry()\n        self.assertEqual(len(export_registry.listSteps()), 1)\n        self.assertTrue('one' in import_registry.listSteps())\n        info = export_registry.getStepMetadata('one')\n        self.assertEqual(info['id'], 'one')\n        self.assertEqual(info['title'], 'One Step')\n        self.assertTrue('One small step' in info['description'])\n        self.assertEqual(info['handler'],\n                         'Products.GenericSetup.tests.test_registry.ONE_FUNC')\n\n        self.assertEqual(export_registry.getStep('one'), ONE_FUNC)\n\n    def test_listContextInfos_empty(self):\n        site = self._makeSite()\n        site.setup_tool = self._makeOne('setup_tool')\n        tool = site.setup_tool\n        infos = tool.listContextInfos()\n        self.assertEqual(len(infos), 0)\n\n    def test_listContextInfos_with_snapshot(self):\n        site = self._makeSite()\n        site.setup_tool = self._makeOne('setup_tool')\n        tool = site.setup_tool\n        tool.createSnapshot('testing')\n        infos = tool.listContextInfos()\n        self.assertEqual(len(infos), 1)\n        info = infos[0]\n        self.assertEqual(info['id'], 'snapshot-testing')\n        self.assertEqual(info['title'], 'testing')\n        self.assertEqual(info['type'], 'snapshot')\n\n    def test_listContextInfos_with_registered_base_profile(self):\n        from ..interfaces import BASE\n\n        profile_registry.registerProfile('foo', 'Foo', '', self._PROFILE_PATH,\n                                         'Foo', BASE)\n        site = self._makeSite()\n        site.setup_tool = self._makeOne('setup_tool')\n        tool = site.setup_tool\n        infos = tool.listContextInfos()\n        self.assertEqual(len(infos), 1)\n        info = infos[0]\n        self.assertEqual(info['id'], 'profile-Foo:foo')\n        self.assertEqual(info['title'], 'Foo')\n        self.assertEqual(info['type'], 'base')\n\n    def test_listContextInfos_with_registered_extension_profile(self):\n        from ..interfaces import EXTENSION\n\n        profile_registry.registerProfile('foo', 'Foo', '', self._PROFILE_PATH,\n                                         'Foo', EXTENSION)\n        site = self._makeSite()\n        site.setup_tool = self._makeOne('setup_tool')\n        tool = site.setup_tool\n        infos = tool.listContextInfos()\n        self.assertEqual(len(infos), 1)\n        info = infos[0]\n        self.assertEqual(info['id'], 'profile-Foo:foo')\n        self.assertEqual(info['title'], 'Foo')\n        self.assertEqual(info['type'], 'extension')\n\n    def test_listContextInfos_with_ordering(self):\n        from ..interfaces import BASE\n        from ..interfaces import EXTENSION\n\n        # three extension profiles\n        profile_registry.registerProfile(\n            'bar', 'bar', '', self._PROFILE_PATH, 'bar', EXTENSION)\n        profile_registry.registerProfile(\n            'foo', 'foo', '', self._PROFILE_PATH, 'foo', EXTENSION)\n        profile_registry.registerProfile(\n            'upper', 'UPPER', '', self._PROFILE_PATH, 'UPPER', EXTENSION)\n        # one base profile\n        profile_registry.registerProfile(\n            'base', 'base', '', self._PROFILE_PATH, 'base', BASE)\n\n        site = self._makeSite()\n        site.setup_tool = self._makeOne('setup_tool')\n        tool = site.setup_tool\n        tool.createSnapshot('UPPER')\n        tool.createSnapshot('lower')\n        infos = tool.listContextInfos()\n        self.assertEqual(len(infos), 6)\n        # We sort case insensitively, so by lowercase.\n        # First snapshots.\n        self.assertEqual(infos[0]['id'], 'snapshot-lower')\n        self.assertEqual(infos[1]['id'], 'snapshot-UPPER')\n        # Then base and extension profiles\n        self.assertEqual(infos[2]['id'], 'profile-bar:bar')\n        self.assertEqual(infos[3]['id'], 'profile-base:base')\n        self.assertEqual(infos[4]['id'], 'profile-foo:foo')\n        self.assertEqual(infos[5]['id'], 'profile-UPPER:upper')\n\n    def test_getProfileImportDate_nonesuch(self):\n        site = self._makeSite()\n        site.setup_tool = self._makeOne('setup_tool')\n        tool = site.setup_tool\n        self.assertEqual(tool.getProfileImportDate('nonesuch'), None)\n\n    def test_getProfileImportDate_simple_id(self):\n        from OFS.Image import File\n\n        site = self._makeSite()\n        site.setup_tool = self._makeOne('setup_tool')\n        tool = site.setup_tool\n        filename = 'import-all-foo-20070315123456.log'\n        tool._setObject(filename, File(filename, '', b''))\n        self.assertEqual(tool.getProfileImportDate('foo'),\n                         '2007-03-15T12:34:56Z')\n\n    def test_getProfileImportDate_id_with_colon(self):\n        from OFS.Image import File\n\n        site = self._makeSite()\n        site.setup_tool = self._makeOne('setup_tool')\n        tool = site.setup_tool\n        filename = 'import-all-foo_bar-20070315123456.log'\n        tool._setObject(filename, File(filename, '', b''))\n        self.assertEqual(tool.getProfileImportDate('foo:bar'),\n                         '2007-03-15T12:34:56Z')\n\n    def test_getProfileImportDate_id_with_prefix(self):\n        # Test if getProfileImportDate does not fail if there is another\n        # item id with id with a longer id which starts with the same\n        # prefix\n        from OFS.Image import File\n\n        site = self._makeSite()\n        site.setup_tool = self._makeOne('setup_tool')\n        tool = site.setup_tool\n        filename = 'import-all-foo_bar-20070315123456.log'\n        tool._setObject(filename, File(filename, '', b''))\n        filename2 = 'import-all-foo_bar-boo-20070315123456.log'\n        tool._setObject(filename2, File(filename2, '', b''))\n        self.assertEqual(tool.getProfileImportDate('foo:bar'),\n                         '2007-03-15T12:34:56Z')\n\n    def test_profileVersioning(self):\n        site = self._makeSite()\n        site.setup_tool = self._makeOne('setup_tool')\n        tool = site.setup_tool\n        profile_id = 'dummy_profile'\n        product_name = 'GenericSetup'\n        directory = os.path.split(__file__)[0]\n        path = os.path.join(directory, 'versioned_profile')\n\n        # register profile\n        profile_registry.registerProfile(profile_id,\n                                         'Dummy Profile',\n                                         'This is a dummy profile',\n                                         path,\n                                         product=product_name)\n\n        # register upgrade step\n        step = UpgradeStep(\"Upgrade\",\n                           \"GenericSetup:dummy_profile\", '*', '1.1', '',\n                           dummy_upgrade,\n                           None, \"1\")\n        _registerUpgradeStep(step)\n\n        # test initial states\n        profile_id = ':'.join((product_name, profile_id))\n        self.assertEqual(tool.getVersionForProfile(profile_id), '1.1')\n        self.assertEqual(tool.getLastVersionForProfile(profile_id),\n                         'unknown')\n\n        # run upgrade steps\n        request = site.REQUEST\n        request.form['profile_id'] = profile_id\n        steps = listUpgradeSteps(tool, profile_id, '1.0')\n        step_id = steps[0]['id']\n        request.form['upgrades'] = [step_id]\n        tool.manage_doUpgrades()\n        self.assertEqual(tool.getLastVersionForProfile(profile_id),\n                         ('1', '1'))\n\n    def test_get_and_setLastVersionForProfile(self):\n        site = self._makeSite()\n        site.setup_tool = self._makeOne('setup_tool')\n        tool = site.setup_tool\n        self.assertEqual(tool._profile_upgrade_versions, {})\n        # Any 'profile-' is stripped off in these calls.\n        self.assertEqual(tool.getLastVersionForProfile('foo'), 'unknown')\n        self.assertEqual(tool.getLastVersionForProfile(\n            'profile-foo'), 'unknown')\n        tool.setLastVersionForProfile('foo', '1.0')\n        self.assertEqual(tool.getLastVersionForProfile('foo'), ('1', '0'))\n        self.assertEqual(tool.getLastVersionForProfile(\n            'profile-foo'), ('1', '0'))\n        tool.setLastVersionForProfile('profile-foo', '2.0')\n        self.assertEqual(tool.getLastVersionForProfile('foo'), ('2', '0'))\n        self.assertEqual(tool.getLastVersionForProfile(\n            'profile-foo'), ('2', '0'))\n\n        # Setting the profile to unknown, removes it from the versions.\n        self.assertEqual(tool._profile_upgrade_versions, {'foo': ('2', '0')})\n        tool.setLastVersionForProfile('profile-foo', 'unknown')\n        self.assertEqual(tool._profile_upgrade_versions, {})\n\n    def test_unsetLastVersionForProfile(self):\n        site = self._makeSite()\n        site.setup_tool = self._makeOne('setup_tool')\n        tool = site.setup_tool\n        tool.setLastVersionForProfile('foo', '1.0')\n        tool.setLastVersionForProfile('bar', '2.0')\n        self.assertEqual(tool._profile_upgrade_versions,\n                         {'foo': ('1', '0'), 'bar': ('2', '0')})\n\n        # Any 'profile-' is stripped off in these calls.\n        tool.unsetLastVersionForProfile('profile-foo')\n        self.assertEqual(tool._profile_upgrade_versions,\n                         {'bar': ('2', '0')})\n        tool.unsetLastVersionForProfile('bar')\n        self.assertEqual(tool._profile_upgrade_versions, {})\n\n    def test_purgeProfileVersions(self):\n        site = self._makeSite()\n        site.setup_tool = self._makeOne('setup_tool')\n        tool = site.setup_tool\n        tool.setLastVersionForProfile('foo', '1.0')\n        tool.setLastVersionForProfile('bar', '2.0')\n        self.assertEqual(tool._profile_upgrade_versions,\n                         {'foo': ('1', '0'), 'bar': ('2', '0')})\n        tool.purgeProfileVersions()\n        self.assertEqual(tool._profile_upgrade_versions, {})\n\n    def test_listProfilesWithUpgrades(self):\n        site = self._makeSite()\n        site.setup_tool = self._makeOne('setup_tool')\n        tool = site.setup_tool\n        self.assertEqual(tool.listProfilesWithUpgrades(), [])\n        self.assertEqual(tool.listProfilesWithPendingUpgrades(), [])\n        self.assertEqual(tool.listUptodateProfiles(), [])\n        self.assertEqual(tool.hasPendingUpgrades(), False)\n        profile_id = 'dummy_profile'\n        product_name = 'GenericSetup'\n        directory = os.path.split(__file__)[0]\n        path = os.path.join(directory, 'versioned_profile')\n\n        # register profile\n        profile_registry.registerProfile(profile_id,\n                                         'Dummy Profile',\n                                         'This is a dummy profile',\n                                         path,\n                                         product=product_name)\n        self.assertEqual(tool.listProfilesWithUpgrades(), [])\n        self.assertEqual(tool.listProfilesWithPendingUpgrades(), [])\n        self.assertEqual(tool.listUptodateProfiles(), [])\n        self.assertEqual(tool.hasPendingUpgrades(), False)\n\n        # register upgrade step\n        step1 = UpgradeStep(\"Upgrade 1\",\n                            \"GenericSetup:dummy_profile\", '*', '1.1', '',\n                            dummy_upgrade,\n                            None, \"1\")\n        _registerUpgradeStep(step1)\n        self.assertEqual(tool.listProfilesWithUpgrades(),\n                         [u'GenericSetup:dummy_profile'])\n        self.assertEqual(tool.listProfilesWithPendingUpgrades(), [])\n        self.assertEqual(tool.listUptodateProfiles(), [])\n        self.assertEqual(tool.hasPendingUpgrades(), False)\n\n        # register another upgrade step\n        step2 = UpgradeStep(\"Upgrade 2\",\n                            \"GenericSetup:dummy_profile\", '1.1', '1.2', '',\n                            dummy_upgrade,\n                            None, \"1\")\n        _registerUpgradeStep(step2)\n        self.assertEqual(tool.listProfilesWithUpgrades(),\n                         [u'GenericSetup:dummy_profile'])\n        self.assertEqual(tool.listProfilesWithPendingUpgrades(), [])\n        self.assertEqual(tool.listUptodateProfiles(), [])\n        self.assertEqual(tool.hasPendingUpgrades(), False)\n\n        # get full profile id\n        profile_id = ':'.join((product_name, profile_id))\n\n        # Pretend the profile was installed\n        tool.setLastVersionForProfile(profile_id, '1.0')\n        self.assertEqual(tool.listProfilesWithUpgrades(),\n                         [u'GenericSetup:dummy_profile'])\n        self.assertEqual(tool.listProfilesWithPendingUpgrades(),\n                         [u'GenericSetup:dummy_profile'])\n        self.assertEqual(tool.listUptodateProfiles(), [])\n        self.assertEqual(tool.hasPendingUpgrades(), True)\n\n        # run first upgrade step\n        request = site.REQUEST\n        request.form['profile_id'] = profile_id\n        steps = listUpgradeSteps(tool, profile_id, '1.0')\n        step_id = steps[0]['id']\n        request.form['upgrades'] = [step_id]\n        tool.manage_doUpgrades()\n        self.assertEqual(tool.getLastVersionForProfile(profile_id),\n                         ('1', '1'))\n        self.assertEqual(tool.listProfilesWithUpgrades(),\n                         [u'GenericSetup:dummy_profile'])\n        self.assertEqual(tool.listProfilesWithPendingUpgrades(),\n                         [u'GenericSetup:dummy_profile'])\n        self.assertEqual(tool.listUptodateProfiles(), [])\n        self.assertEqual(tool.hasPendingUpgrades(), True)\n\n        # run second upgrade step\n        request = site.REQUEST\n        request.form['profile_id'] = profile_id\n        steps = listUpgradeSteps(tool, profile_id, '1.1')\n        step_id = steps[0]['id']\n        request.form['upgrades'] = [step_id]\n        tool.manage_doUpgrades()\n        self.assertEqual(tool.getLastVersionForProfile(profile_id),\n                         ('1', '2'))\n        self.assertEqual(tool.listProfilesWithUpgrades(),\n                         [u'GenericSetup:dummy_profile'])\n        self.assertEqual(tool.listProfilesWithPendingUpgrades(), [])\n        self.assertEqual(tool.listUptodateProfiles(),\n                         [u'GenericSetup:dummy_profile'])\n        self.assertEqual(tool.hasPendingUpgrades(), False)\n\n        # Pretend the profile was never installed.\n        tool.unsetLastVersionForProfile(profile_id)\n        self.assertEqual(tool.listProfilesWithPendingUpgrades(), [])\n        self.assertEqual(tool.listUptodateProfiles(), [])\n        self.assertEqual(tool.hasPendingUpgrades(), False)\n\n    def test_hasPendingUpgrades(self):\n        site = self._makeSite()\n        site.setup_tool = self._makeOne('setup_tool')\n        tool = site.setup_tool\n        profile_id_1 = 'dummy_profile1'\n        profile_id_2 = 'dummy_profile2'\n        product_name = 'GenericSetup'\n        directory = os.path.split(__file__)[0]\n        path = os.path.join(directory, 'versioned_profile')\n\n        # register profiles\n        profile_registry.registerProfile(profile_id_1,\n                                         'Dummy Profile 1',\n                                         'This is dummy profile 1',\n                                         path,\n                                         product=product_name)\n        profile_registry.registerProfile(profile_id_2,\n                                         'Dummy Profile 2',\n                                         'This is dummy profile 2',\n                                         path,\n                                         product=product_name)\n\n        # get full profile ids\n        profile_id_1 = ':'.join((product_name, profile_id_1))\n        profile_id_2 = ':'.join((product_name, profile_id_2))\n\n        # test\n        self.assertEqual(tool.hasPendingUpgrades(), False)\n        self.assertEqual(tool.hasPendingUpgrades(profile_id_1), False)\n        self.assertEqual(tool.hasPendingUpgrades(profile_id_2), False)\n        self.assertEqual(tool.hasPendingUpgrades('non-existing'), False)\n\n        # register upgrade steps\n        step1 = UpgradeStep(\"Upgrade 1\",\n                            profile_id_1, '*', '1.1', '',\n                            dummy_upgrade,\n                            None, \"1\")\n        _registerUpgradeStep(step1)\n        step2 = UpgradeStep(\"Upgrade 2\",\n                            profile_id_2, '*', '2.2', '',\n                            dummy_upgrade,\n                            None, \"2\")\n        _registerUpgradeStep(step2)\n        # No profile has been applied, so no upgrade is pending.\n        self.assertEqual(tool.hasPendingUpgrades(), False)\n        self.assertEqual(tool.hasPendingUpgrades(profile_id_1), False)\n        self.assertEqual(tool.hasPendingUpgrades(profile_id_2), False)\n\n        # Pretend profile 1 was installed to an earlier version.\n        tool.setLastVersionForProfile(profile_id_1, '1.0')\n        self.assertEqual(tool.hasPendingUpgrades(), True)\n        self.assertEqual(tool.hasPendingUpgrades(profile_id_1), True)\n        self.assertEqual(tool.hasPendingUpgrades(profile_id_2), False)\n\n        # Pretend profile 2 was installed to an earlier version.\n        tool.setLastVersionForProfile(profile_id_2, '2.0')\n        self.assertEqual(tool.hasPendingUpgrades(), True)\n        self.assertEqual(tool.hasPendingUpgrades(profile_id_1), True)\n        self.assertEqual(tool.hasPendingUpgrades(profile_id_2), True)\n\n        # Pretend profile 1 was installed to the final version.\n        tool.setLastVersionForProfile(profile_id_1, '1.1')\n        self.assertEqual(tool.hasPendingUpgrades(), True)\n        self.assertEqual(tool.hasPendingUpgrades(profile_id_1), False)\n        self.assertEqual(tool.hasPendingUpgrades(profile_id_2), True)\n\n        # Pretend profile 2 was installed to the final version.\n        tool.setLastVersionForProfile(profile_id_2, '2.2')\n        self.assertEqual(tool.hasPendingUpgrades(), False)\n        self.assertEqual(tool.hasPendingUpgrades(profile_id_1), False)\n        self.assertEqual(tool.hasPendingUpgrades(profile_id_2), False)\n\n    def test_manage_doUpgrades_no_profile_id_or_updates(self):\n        site = self._makeSite()\n        site.setup_tool = self._makeOne('setup_tool')\n        tool = site.setup_tool\n        tool.manage_doUpgrades()\n        self.assertEqual(tool._profile_upgrade_versions, {})\n\n    def test_manage_doUpgrades_upgrade_w_no_target_version(self):\n        def notool():\n            return None\n        step = UpgradeStep('TITLE', 'foo', '*', '*', 'DESC', notool)\n        _registerUpgradeStep(step)\n        site = self._makeSite()\n        site.setup_tool = self._makeOne('setup_tool')\n        tool = site.setup_tool\n        request = site.REQUEST\n        request['profile_id'] = ['foo']\n        request['upgrade'] = [step.id]\n        tool.manage_doUpgrades()\n        self.assertEqual(tool._profile_upgrade_versions, {})\n\n    def test_upgradeProfile_no_profile_id_or_updates(self):\n        site = self._makeSite()\n        site.setup_tool = self._makeOne('setup_tool')\n        tool = site.setup_tool\n        # Mostly this checks to see if we can call this without an\n        # exception.\n        tool.upgradeProfile('no.such.profile:default')\n        self.assertEqual(tool._profile_upgrade_versions, {})\n        tool.upgradeProfile('no.such.profile:default', dest='42')\n        self.assertEqual(tool._profile_upgrade_versions, {})\n\n    def test_persistent_profile_upgrade_versions(self):\n        site = self._makeSite()\n        site.setup_tool = self._makeOne('setup_tool')\n        tool = site.setup_tool\n        savepoint1 = transaction.savepoint()\n        tool.setLastVersionForProfile('foo', '1.0')\n        savepoint2 = transaction.savepoint()\n        tool.setLastVersionForProfile('bar', '2.0')\n        self.assertEqual(tool._profile_upgrade_versions,\n                         {'foo': ('1', '0'), 'bar': ('2', '0')})\n        savepoint2.rollback()\n        self.assertEqual(tool._profile_upgrade_versions,\n                         {'foo': ('1', '0')})\n        savepoint1.rollback()\n        self.assertEqual(tool._profile_upgrade_versions, {})\n\n    def test_separate_profile_upgrade_versions(self):\n        # _profile_upgrade_versions used to be a class property.  That is fine\n        # as long as we only work on copies, otherwise state is shared between\n        # two instances.  We now create the property in the __init__ method,\n        # but let's test it to avoid a regression.\n        site = self._makeSite()\n        site.setup_tool1 = self._makeOne('setup_tool1')\n        tool1 = site.setup_tool1\n        site.setup_tool2 = self._makeOne('setup_tool2')\n        tool2 = site.setup_tool2\n        tool1._profile_upgrade_versions['foo'] = '1.0'\n        self.assertEqual(tool2._profile_upgrade_versions, {})\n        tool2.setLastVersionForProfile('bar', '2.0')\n        self.assertEqual(self._makeOne('t')._profile_upgrade_versions, {})\n\n    def test_upgradeProfile(self):\n        def dummy_handler(tool):\n            return None\n\n        def step3_handler(tool):\n            tool._step3_applied = 'just a marker'\n\n        def step3_checker(tool):\n            # False means already applied or does not apply.\n            # True means can be applied.\n            return not hasattr(tool, '_step3_applied')\n\n        step1 = UpgradeStep('Step 1', 'foo', '0', '1', 'DESC',\n                            dummy_handler)\n        step2 = UpgradeStep('Step 2', 'foo', '1', '2', 'DESC',\n                            dummy_handler)\n        step3 = UpgradeStep('Step 3', 'foo', '2', '3', 'DESC',\n                            step3_handler, checker=step3_checker)\n        step4 = UpgradeStep('Step 4', 'foo', '3', '4', 'DESC',\n                            dummy_handler)\n        _registerUpgradeStep(step1)\n        _registerUpgradeStep(step2)\n        _registerUpgradeStep(step3)\n        _registerUpgradeStep(step4)\n        site = self._makeSite()\n        site.setup_tool = self._makeOne('setup_tool')\n        tool = site.setup_tool\n        self.assertEqual(tool.getLastVersionForProfile('foo'), 'unknown')\n        tool.setLastVersionForProfile('foo', '0')\n        self.assertEqual(tool.getLastVersionForProfile('foo'), ('0',))\n        # Upgrade the profile one step to version 1.\n        tool.upgradeProfile('foo', '1')\n        self.assertEqual(tool.getLastVersionForProfile('foo'), ('1',))\n        # Upgrade the profile two steps to version 3.  This one has a\n        # checker.  The profile version must be correctly updated.\n        tool.upgradeProfile('foo', '3')\n        self.assertEqual(tool.getLastVersionForProfile('foo'), ('3',))\n        # Upgrade the profile to a non existing version.  Nothing\n        # should happen.\n        tool.upgradeProfile('foo', '5')\n        self.assertEqual(tool.getLastVersionForProfile('foo'), ('3',))\n        # Upgrade the profile to the latest version.\n        tool.upgradeProfile('foo')\n        self.assertEqual(tool.getLastVersionForProfile('foo'), ('4',))\n\n    def test_listExportSteps(self):\n        site = self._makeSite()\n        site.setup_tool = self._makeOne('setup_tool')\n        tool = site.setup_tool\n        result = tool.listExportSteps()\n        self.assertEqual(len(result), 4)\n        self.assertTrue(u'componentregistry' in result)\n        self.assertTrue(u'rolemap' in result)\n        self.assertTrue(u'step_registries' in result)\n        self.assertTrue(u'toolset' in result)\n\n        tool._export_registry.registerStep(u'foo', handler='foo.export')\n        tool._export_registry.registerStep(u'toolset',\n                                           handler='toolset.export')\n        result = tool.listExportSteps()\n        self.assertEqual(len(result), 5)\n        self.assertTrue(u'componentregistry' in result)\n        self.assertTrue(u'foo' in result)\n        self.assertTrue(u'rolemap' in result)\n        self.assertTrue(u'step_registries' in result)\n        self.assertTrue(u'toolset' in result)\n\n    def test_getSortedImportSteps(self):\n        site = self._makeSite()\n        site.setup_tool = self._makeOne('setup_tool')\n        tool = site.setup_tool\n        result = tool.getSortedImportSteps()\n        self.assertEqual(len(result), 3)\n        self.assertTrue(u'componentregistry' in result)\n        self.assertTrue(u'rolemap' in result)\n        self.assertTrue(u'toolset' in result)\n        self.assertTrue(list(result).index(u'componentregistry') >\n                        list(result).index(u'toolset'))\n\n        tool._import_registry.registerStep(u'foo', handler='foo.import')\n        tool._import_registry.registerStep(u'toolset',\n                                           handler='toolset.import')\n        result = tool.getSortedImportSteps()\n        self.assertEqual(len(result), 4)\n        self.assertTrue(u'componentregistry' in result)\n        self.assertTrue(u'foo' in result)\n        self.assertTrue(u'rolemap' in result)\n        self.assertTrue(u'toolset' in result)\n        self.assertTrue(list(result).index(u'componentregistry') >\n                        list(result).index(u'toolset'))\n\n    def test_listProfileInfo_for_parameter(self):\n        from ..metadata import METADATA_XML\n\n        self._makeFile(METADATA_XML, _METADATA_XML)\n\n        site = self._makeSite()\n        tool = self._makeOne('setup_tool').__of__(site)\n\n        profile_registry.registerProfile('foo', 'Foo', '', self._PROFILE_PATH,\n                                         for_=ISite)\n        # tool.listProfileInfo should call registry.listProfileInfo\n        # with the for_ parameter\n        self.assertEqual(len(tool.listProfileInfo()), 1)\n        self.assertEqual(len(tool.listProfileInfo(for_=ISite)), 1)\n        self.assertEqual(len(tool.listProfileInfo(for_=IDerivedSite)), 1)\n        self.assertEqual(len(tool.listProfileInfo(for_=IAnotherSite)), 0)\n\n    def test_profileExists(self):\n        from ..interfaces import EXTENSION\n        from ..metadata import METADATA_XML\n        site = self._makeSite()\n        tool = self._makeOne('setup_tool').__of__(site)\n\n        # Register two extension profiles.  Profile 'foo' has a dependency\n        # 'bar'.\n        self._makeFile(METADATA_XML, _METADATA_XML)\n        _makeTestFile(METADATA_XML, self._PROFILE_PATH2, _PLAIN_METADATA_XML)\n        profile_registry.registerProfile(\n            'foo', 'Foo', '', self._PROFILE_PATH, profile_type=EXTENSION)\n        profile_registry.registerProfile(\n            'bar', 'Bar', '', self._PROFILE_PATH2, profile_type=EXTENSION)\n\n        self.assertTrue(tool.profileExists('other:foo'))\n        self.assertTrue(tool.profileExists('other:bar'))\n        self.assertFalse(tool.profileExists('snapshot-something'))\n        self.assertFalse(tool.profileExists(None))\n        self.assertFalse(tool.profileExists('nonesuch'))\n\n    def test_getDependenciesForProfile(self):\n        from ..interfaces import EXTENSION\n        from ..metadata import METADATA_XML\n        site = self._makeSite()\n        tool = self._makeOne('setup_tool').__of__(site)\n\n        # Register three extension profiles.  Profile 'foo' has a dependency\n        # 'bar', and 'baz' contains non-existing dependency-profiles.\n        self._makeFile(METADATA_XML, _METADATA_XML)\n        _makeTestFile(METADATA_XML, self._PROFILE_PATH2, _PLAIN_METADATA_XML)\n        _makeTestFile(METADATA_XML, self._PROFILE_PATH3, _BROKEN_METADATA_XML)\n        profile_registry.registerProfile(\n            'foo', 'Foo', '', self._PROFILE_PATH, profile_type=EXTENSION)\n        profile_registry.registerProfile(\n            'bar', 'Bar', '', self._PROFILE_PATH2, profile_type=EXTENSION)\n        profile_registry.registerProfile(\n            'baz', 'Baz', '', self._PROFILE_PATH3, profile_type=EXTENSION)\n\n        self.assertEqual(tool.getDependenciesForProfile('other:foo'),\n                         (u'profile-other:bar', ))\n        self.assertEqual(tool.getDependenciesForProfile('other:bar'), ())\n        self.assertEqual(tool.getDependenciesForProfile('snapshot-some'), ())\n        self.assertEqual(tool.getDependenciesForProfile(None), ())\n        self.assertRaises(KeyError, tool.getDependenciesForProfile, 'nonesuch')\n\n    def test_getBrokenDependencies(self):\n        from ..interfaces import EXTENSION\n        from ..metadata import METADATA_XML\n        site = self._makeSite()\n        tool = self._makeOne('setup_tool').__of__(site)\n\n        # Register three extension profiles.  Profile 'foo' has a dependency\n        # 'bar' and 'baz' contains non-existing dependency-profiles.\n        self._makeFile(METADATA_XML, _METADATA_XML)\n        _makeTestFile(METADATA_XML, self._PROFILE_PATH2, _PLAIN_METADATA_XML)\n        _makeTestFile(METADATA_XML, self._PROFILE_PATH3, _BROKEN_METADATA_XML)\n        profile_registry.registerProfile(\n            'foo', 'Foo', '', self._PROFILE_PATH, profile_type=EXTENSION)\n        profile_registry.registerProfile(\n            'bar', 'Bar', '', self._PROFILE_PATH2, profile_type=EXTENSION)\n        profile_registry.registerProfile(\n            'baz', 'Baz', '', self._PROFILE_PATH3, profile_type=EXTENSION)\n\n        # profile has dependencies and none of them is broken:\n        self.assertFalse(tool.hasBrokenDependencies('other:foo'))\n        # profile has no dependencies, therfore nothing can be broken:\n        self.assertFalse(tool.hasBrokenDependencies('other:bar'))\n        # profile has dependencies and at least one of them is broken:\n        self.assertTrue(tool.hasBrokenDependencies('other:baz'))\n\n\n_DEFAULT_STEP_REGISTRIES_EXPORT_XML = (\"\"\"\\\n<?xml version=\"1.0\"?>\n<export-steps>\n <export-step id=\"step_registries\"\n              handler=\"Products.GenericSetup.tool.exportStepRegistries\"\n              title=\"Export import / export steps.\">\n\"\"\" + \"  \" + \"\"\"\n </export-step>\n</export-steps>\n\"\"\")\n\n_EXTRAS_STEP_REGISTRIES_EXPORT_XML = \"\"\"\\\n<?xml version=\"1.0\"?>\n<export-steps>\n <export-step\n    id=\"properties\"\n    handler=\"Products.GenericSetup.tests.test_tool._exportPropertiesINI\"\n    title=\"properties\">\n\n </export-step>\n <export-step\n    id=\"step_registries\"\n    handler=\"Products.GenericSetup.tool.exportStepRegistries\"\n    title=\"Export import / export steps.\">\n\n </export-step>\n</export-steps>\n\"\"\"\n\n_DEFAULT_STEP_REGISTRIES_IMPORT_XML = (\"\"\"\\\n<?xml version=\"1.0\"?>\n<import-steps>\n <import-step id=\"foo\" handler=\"foo.bar\" title=\"foo\">\n\"\"\" + \"  \" + \"\"\"\n </import-step>\n</import-steps>\n\"\"\")\n\n_EXTRAS_STEP_REGISTRIES_IMPORT_XML = \"\"\"\\\n<?xml version=\"1.0\"?>\n<import-steps>\n <import-step\n    id=\"dependable\"\n    version=\"1\"\n    handler=\"Products.GenericSetup.tests.test_tool._underscoreSiteTitle\"\n    title=\"dependable\">\n  <dependency step=\"purging\" />\n\n </import-step>\n <import-step\n    id=\"dependent\"\n    version=\"1\"\n    handler=\"Products.GenericSetup.tests.test_tool._uppercaseSiteTitle\"\n    title=\"dependent\">\n  <dependency step=\"dependable\" />\n\n </import-step>\n <import-step\n    id=\"purging\"\n    version=\"1\"\n    handler=\"Products.GenericSetup.tests.test_tool._purgeIfRequired\"\n    title=\"purging\">\n\n </import-step>\n</import-steps>\n\"\"\"\n\n_PROPERTIES_INI = \"\"\"\\\n[Default]\nTitle=%s\n\"\"\"\n\n\ndef _underscoreSiteTitle(context):\n\n    site = context.getSite()\n    site.title = site.title.replace(' ', '_')\n    return 'Underscored title'\n\n\ndef _uppercaseSiteTitle(context):\n\n    site = context.getSite()\n    site.title = site.title.upper()\n    return 'Uppercased title'\n\n\ndef _purgeIfRequired(context):\n\n    site = context.getSite()\n    purged = site.purged = context.shouldPurge()\n    return purged and 'Purged' or 'Unpurged'\n\n\ndef _exportPropertiesINI(context):\n\n    site = context.getSite()\n    text = _PROPERTIES_INI % site.title\n\n    context.writeDataFile('properties.ini', text.encode('utf-8'), 'text/plain')\n\n    return 'Exported properties'\n\n\nclass _ToolsetSetup(BaseRegistryTests):\n\n    def _initSite(self):\n        from ..tool import SetupTool\n\n        site = Folder()\n        site._setId('site')\n        self.app._setObject('site', site)\n        site = self.app._getOb('site')\n        site._setObject('setup_tool', SetupTool('setup_tool'))\n        return site\n\n\nclass Test_exportToolset(_ToolsetSetup):\n\n    layer = ExportImportZCMLLayer\n\n    def test_empty(self):\n        from ..tool import TOOLSET_XML\n        from ..tool import exportToolset\n\n        site = self._initSite()\n        context = DummyExportContext(site, tool=site.setup_tool)\n\n        exportToolset(context)\n\n        self.assertEqual(len(context._wrote), 1)\n        filename, text, content_type = context._wrote[0]\n        self.assertEqual(filename, TOOLSET_XML)\n        self._compareDOM(text.decode('utf-8'), _EMPTY_TOOLSET_XML)\n        self.assertEqual(content_type, 'text/xml')\n\n    def test_normal(self):\n        from ..tool import TOOLSET_XML\n        from ..tool import exportToolset\n\n        site = self._initSite()\n        toolset = site.setup_tool.getToolsetRegistry()\n        toolset.addForbiddenTool('doomed')\n        toolset.addRequiredTool('mandatory', 'path.to.one')\n        toolset.addRequiredTool('obligatory', 'path.to.another')\n\n        context = DummyExportContext(site, tool=site.setup_tool)\n\n        exportToolset(context)\n\n        self.assertEqual(len(context._wrote), 1)\n        filename, text, content_type = context._wrote[0]\n        self.assertEqual(filename, TOOLSET_XML)\n        self._compareDOM(text.decode('utf-8'), _NORMAL_TOOLSET_XML)\n        self.assertEqual(content_type, 'text/xml')\n\n\nclass Test_importToolset(_ToolsetSetup):\n\n    layer = ExportImportZCMLLayer\n\n    def test_import_updates_registry(self):\n        from ..tool import TOOLSET_XML\n        from ..tool import importToolset\n\n        site = self._initSite()\n        context = DummyImportContext(site, tool=site.setup_tool)\n\n        # Import forbidden\n        context._files[TOOLSET_XML] = _FORBIDDEN_TOOLSET_XML\n        importToolset(context)\n\n        tool = context.getSetupTool()\n        toolset = tool.getToolsetRegistry()\n\n        self.assertEqual(len(toolset.listForbiddenTools()), 3)\n        self.assertTrue('doomed' in toolset.listForbiddenTools())\n        self.assertTrue('damned' in toolset.listForbiddenTools())\n        self.assertTrue('blasted' in toolset.listForbiddenTools())\n\n        # Import required\n        context._files[TOOLSET_XML] = _REQUIRED_TOOLSET_XML\n        importToolset(context)\n\n        self.assertEqual(len(toolset.listRequiredTools()), 2)\n        self.assertTrue('mandatory' in toolset.listRequiredTools())\n        info = toolset.getRequiredToolInfo('mandatory')\n        self.assertEqual(info['class'],\n                         'Products.GenericSetup.tests.test_tool.DummyTool')\n        self.assertTrue('obligatory' in toolset.listRequiredTools())\n        info = toolset.getRequiredToolInfo('obligatory')\n        self.assertEqual(info['class'],\n                         'Products.GenericSetup.tests.test_tool.DummyTool')\n\n    def test_tool_ids(self):\n        # The tool import mechanism used to rely on the fact that all tools\n        # have unique IDs set at the class level and that you can call their\n        # constructor with no arguments. However, there might be tools\n        # that need IDs set.\n        from ..tool import TOOLSET_XML\n        from ..tool import importToolset\n\n        site = self._initSite()\n        context = DummyImportContext(site, tool=site.setup_tool)\n        context._files[TOOLSET_XML] = _REQUIRED_TOOLSET_XML\n\n        importToolset(context)\n\n        for tool_id in ('mandatory', 'obligatory'):\n            tool = getattr(site, tool_id)\n            self.assertEqual(tool.getId(), tool_id)\n\n    def test_tool_id_required(self):\n        # Tests that tool creation will still work when an id is required\n        # by the tool constructor.\n        from ..tool import TOOLSET_XML\n        from ..tool import importToolset\n\n        site = self._initSite()\n        context = DummyImportContext(site, tool=site.setup_tool)\n        context._files[TOOLSET_XML] = _WITH_ID_TOOLSET_XML\n\n        importToolset(context)\n\n        for tool_id in ('mandatory', 'requires_id', 'immutable_id'):\n            tool = getattr(site, tool_id)\n            self.assertEqual(tool.getId(), tool_id)\n\n    def test_forbidden_tools(self):\n        from ..tool import TOOLSET_XML\n        from ..tool import importToolset\n\n        TOOL_IDS = ('doomed', 'blasted', 'saved')\n\n        site = self._initSite()\n\n        for tool_id in TOOL_IDS:\n            pseudo = Folder()\n            pseudo._setId(tool_id)\n            site._setObject(tool_id, pseudo)\n\n        self.assertEqual(len(site.objectIds()), len(TOOL_IDS) + 1)\n\n        for tool_id in TOOL_IDS:\n            self.assertTrue(tool_id in site.objectIds())\n\n        context = DummyImportContext(site, tool=site.setup_tool)\n        context._files[TOOLSET_XML] = _FORBIDDEN_TOOLSET_XML\n\n        importToolset(context)\n\n        self.assertEqual(len(site.objectIds()), 2)\n        self.assertTrue('setup_tool' in site.objectIds())\n        self.assertTrue('saved' in site.objectIds())\n\n    def test_required_tools_missing(self):\n        from ..tool import TOOLSET_XML\n        from ..tool import importToolset\n\n        site = self._initSite()\n        self.assertEqual(len(site.objectIds()), 1)\n\n        context = DummyImportContext(site, tool=site.setup_tool)\n        context._files[TOOLSET_XML] = _REQUIRED_TOOLSET_XML\n\n        importToolset(context)\n\n        self.assertEqual(len(site.objectIds()), 3)\n        self.assertTrue(isinstance(\n            aq_base(site._getOb('mandatory')), DummyTool))\n        self.assertTrue(isinstance(\n            aq_base(site._getOb('obligatory')), DummyTool))\n\n    def test_required_tools_no_replacement(self):\n        from ..tool import TOOLSET_XML\n        from ..tool import importToolset\n\n        site = self._initSite()\n\n        mandatory = DummyTool()\n        mandatory._setId('mandatory')\n        site._setObject('mandatory', mandatory)\n\n        obligatory = DummyTool()\n        obligatory._setId('obligatory')\n        site._setObject('obligatory', obligatory)\n\n        self.assertEqual(len(site.objectIds()), 3)\n\n        context = DummyImportContext(site, tool=site.setup_tool)\n        context._files[TOOLSET_XML] = _REQUIRED_TOOLSET_XML\n\n        importToolset(context)\n\n        self.assertEqual(len(site.objectIds()), 3)\n        self.assertTrue(aq_base(site._getOb('mandatory')) is mandatory)\n        self.assertTrue(aq_base(site._getOb('obligatory')) is obligatory)\n\n    def test_required_tools_with_replacement(self):\n        from ..tool import TOOLSET_XML\n        from ..tool import importToolset\n\n        site = self._initSite()\n\n        mandatory = AnotherDummyTool()\n        mandatory._setId('mandatory')\n        site._setObject('mandatory', mandatory)\n\n        obligatory = SubclassedDummyTool()\n        obligatory._setId('obligatory')\n        site._setObject('obligatory', obligatory)\n\n        self.assertEqual(len(site.objectIds()), 3)\n\n        context = DummyImportContext(site, tool=site.setup_tool)\n        context._files[TOOLSET_XML] = _REQUIRED_TOOLSET_XML\n\n        importToolset(context)\n\n        self.assertEqual(len(site.objectIds()), 3)\n\n        self.assertFalse(aq_base(site._getOb('mandatory')) is mandatory)\n        self.assertTrue(isinstance(\n            aq_base(site._getOb('mandatory')), DummyTool))\n\n        self.assertFalse(aq_base(site._getOb('obligatory')) is obligatory)\n        self.assertTrue(isinstance(\n            aq_base(site._getOb('obligatory')), DummyTool))\n\n    def test_required_tools_missing_acquired_nofail(self):\n        from ..tool import TOOLSET_XML\n        from ..tool import importToolset\n\n        site = self._initSite()\n        parent_site = Folder()\n\n        mandatory = AnotherDummyTool()\n        mandatory._setId('mandatory')\n        parent_site._setObject('mandatory', mandatory)\n\n        obligatory = AnotherDummyTool()\n        obligatory._setId('obligatory')\n        parent_site._setObject('obligatory', obligatory)\n\n        site = site.__of__(parent_site)\n\n        # acquiring subobjects of a different class during import\n        # should not prevent new objects from being created if they\n        # don't exist in the site\n\n        context = DummyImportContext(site, tool=site.setup_tool)\n        context._files[TOOLSET_XML] = _REQUIRED_TOOLSET_XML\n\n        importToolset(context)\n\n        self.assertFalse(aq_base(site._getOb('mandatory')) is mandatory)\n        self.assertTrue(isinstance(\n            aq_base(site._getOb('mandatory')), DummyTool))\n\n        self.assertFalse(aq_base(site._getOb('obligatory')) is obligatory)\n        self.assertTrue(isinstance(\n            aq_base(site._getOb('obligatory')), DummyTool))\n\n    def test_required_tools_missing_class_with_replacement(self):\n        from ..tool import TOOLSET_XML\n        from ..tool import importToolset\n\n        site = self._initSite()\n\n        obligatory = AnotherDummyTool()\n        obligatory._setId('obligatory')\n        site._setObject('obligatory', obligatory)\n\n        self.assertEqual(len(site.objectIds()), 2)\n\n        context = DummyImportContext(site, tool=site.setup_tool)\n        context._files[TOOLSET_XML] = _BAD_CLASS_TOOLSET_XML\n\n        importToolset(context)\n\n        self.assertEqual(len(site.objectIds()), 2)\n\n\nclass DummyTool(Folder):\n\n    pass\n\n\nclass AnotherDummyTool(Folder):\n\n    pass\n\n\nclass SubclassedDummyTool(DummyTool):\n\n    pass\n\n\nclass DummyToolRequiresId(Folder):\n\n    def __init__(self, id):\n        Folder.__init__(self)\n        self._setId(id)\n\n\nclass DummyToolImmutableId(Folder):\n\n    id = 'immutable_id'\n\n    def _setId(self, id):\n        if id != self.getId():\n            raise ValueError()\n\n\ndef pre_handler(tool):\n    try:\n        tool.pre_handler_called += 1\n    except AttributeError:\n        tool.pre_handler_called = 1\n\n\ndef post_handler(tool):\n    try:\n        tool.post_handler_called += 1\n    except AttributeError:\n        tool.post_handler_called = 1\n\n\n_FORBIDDEN_TOOLSET_XML = \"\"\"\\\n<?xml version=\"1.0\"?>\n<tool-setup>\n <forbidden tool_id=\"doomed\" />\n <forbidden tool_id=\"damned\" />\n <forbidden tool_id=\"blasted\" />\n</tool-setup>\n\"\"\"\n\n_REQUIRED_TOOLSET_XML = \"\"\"\\\n<?xml version=\"1.0\"?>\n<tool-setup>\n <required\n    tool_id=\"mandatory\"\n    class=\"Products.GenericSetup.tests.test_tool.DummyTool\" />\n <required\n    tool_id=\"obligatory\"\n    class=\"Products.GenericSetup.tests.test_tool.DummyTool\" />\n</tool-setup>\n\"\"\"\n\n_WITH_ID_TOOLSET_XML = \"\"\"\\\n<?xml version=\"1.0\"?>\n<tool-setup>\n  <required\n    tool_id=\"mandatory\"\n    class=\"Products.GenericSetup.tests.test_tool.DummyTool\" />\n  <required\n    tool_id=\"requires_id\"\n    class=\"Products.GenericSetup.tests.test_tool.DummyToolRequiresId\" />\n  <required\n    tool_id=\"immutable_id\"\n    class=\"Products.GenericSetup.tests.test_tool.DummyToolImmutableId\" />\n</tool-setup>\n\"\"\"\n\n_BAD_CLASS_TOOLSET_XML = \"\"\"\\\n<?xml version=\"1.0\"?>\n<tool-setup>\n <required\n    tool_id=\"obligatory\"\n    class=\"foobar\" />\n</tool-setup>\n\"\"\"\n\n\ndef test_suite():\n    return unittest.TestSuite((\n        unittest.makeSuite(SetupToolTests),\n        unittest.makeSuite(Test_exportToolset),\n        unittest.makeSuite(Test_importToolset),\n    ))\n"], "fixing_code": ["Changelog\n=========\n\n2.1.1 (unreleased)\n------------------\n\n- Enforce access control on setup tool log files and snapshot files and folders.\n  (`#101 <https://github.com/zopefoundation/Products.GenericSetup/issues/101>`_)\n\n\n2.1.0 (2021-01-26)\n------------------\n\n- Add support for Python 3.9.\n\n\n2.0.3 (2020-09-28)\n------------------\n\n- When logging an upgrade, print the version tuple joined by dots.\n\n- Renamed ``xml`` dir to ``xml_templates``.\n  This avoids an import warning on Python 2.7.\n\n\n2.0.2 (2020-01-29)\n------------------\n\n- Remove Zope 2.13 fossils to stay compatible with Zope 5\n\n- Force saving unpersisted changes in toolset registry.\n  (`#86 <https://github.com/zopefoundation/Products.GenericSetup/issues/86>`_)\n\n\n2.0.1 (2019-10-12)\n------------------\n\n- Fix the sorting of upgrade steps.  [vanderbauwhede]\n\n\n2.0 (2019-05-10)\n----------------\n\n- no changes since 2.0b6\n\n\n2.0b6 (2019-04-09)\n------------------\n\n- Zope 4 ZMI: Added icon\n\n- Zope 4 ZMI: declare that creating a GS tool does not need an add dialog\n  (`#80 <https://github.com/zopefoundation/Products.GenericSetup/issues/80>`_)\n\n- clean up ``setup.py`` and remove support for ``setup.py test``\n  (`#73 <https://github.com/zopefoundation/Products.GenericSetup/issues/73>`_)\n\n- add support for unicode data in ``writeDataFile``\n  (`#79 <https://github.com/zopefoundation/Products.GenericSetup/issues/79>`_)\n\n- Specify supported Python versions using ``python_requires`` in setup.py\n\n- Adding suport for Python 3.8\n\n\n2.0b5 (2018-12-14)\n------------------\n\n- Fix deprecation warnings for ``cgi.escape`` by using ``html.escape``\n  (`#76 <https://github.com/zopefoundation/Products.GenericSetup/issues/76>`_)\n\n\n2.0b4 (2018-11-22)\n------------------\n\n- Convert input from xml configuration with correct encoding before passing to\n  type_converter.\n  (`#77 <https://github.com/zopefoundation/Products.GenericSetup/pull/77>`_)\n  [sallner]\n\n\n2.0b3 (2018-11-07)\n------------------\n\n- Do not turn ulines and multiple selection into bytes.\n  [davisagli]\n\n- Set body of PythonScripts as text in py3.\n  [pbauer]\n\n- Compare encodings so that UTF-8 and utf-8 are the same.\n  [pbauer]\n\n- Compare DOM as text in py3.\n  [pbauer]\n\n\n2.0b2 (2018-10-17)\n------------------\n\nNew features:\n\n- Add Python 3.7 support.\n\n- Support `zope.configuration >= 4.2`.\n\nBug fixes:\n\n- Proper string/bytes handling for _createObjectByType.\n  In Python2 everything is written as bytes,\n  while on Python3 everything is written as text except files and images\n  which are stored as bytes\n  [ale-rt]\n\n\n2.0b1 (2018-05-16)\n------------------\n\nBreaking changes:\n\n- Require Zope 4.0b4 as minimum supported Zope version and drop\n  explicit ``Zope2`` egg dependency.\n\n- Drop Python 3.4 support\n\nNew features:\n\n- Fixed tests with ``Products.ZCatalog 4.1``.  [maurits]\n\n- When ``metadata.xml`` parsing fails, show the filename in the ``ExpatError``.\n  Fixes `Plone issue 2303 <https://github.com/plone/Products.CMFPlone/issues/2303>`_.\n\n- Prevent AttributeError 'NoneType' object has no attribute 'decode'.\n  [maurits]\n\n- Finished compatibility with Python 3.5 and 3.6\n\n- Made the code PEP-8 compliant\n\nBug fixes:\n\n- Do not mask KeyError in 'getProfileDependencies' from missing\n  dependency profiles.\n  Refs: https://github.com/plone/Products.CMFPlone/issues/2228\n  [ida]\n\n\n1.10.0 (2017-12-07)\n-------------------\n\nBreaking changes:\n\n- Require Zope 4.0a6 as minimum supported Zope version.\n\n- Moved support for `MailHost` import/export into the\n  ``Products.MailHost`` package to cut the hard dependency.\n\nNew features:\n\n- Added ``tox`` testing configuration.\n\n- Pushed documentation to RTD: https://productsgenericsetup.readthedocs.io/.\n\n1.9.1 (2017-05-06)\n------------------\n\nBug fixes:\n\n- Fixed ``upgradeStep`` discriminator so that similar steps\n  for different profiles will not conflict.\n\n- Fixed ``upgradeDepends`` discriminator so that steps inside\n  ``upgradeSteps`` will conflict with steps outside if they\n  have the same ``checker``.\n\n- Fix import of UnrestrictedUser.\n\n1.9.0 (2017-05-04)\n------------------\n\nBreaking changes:\n\n- Drop support for Python 2.6.\n\n- Require Zope 4.0a3 as minimum supported Zope version.\n\n1.8.7 (2017-03-26)\n------------------\n\n- Allow registering the same profile twice if it really is the same.\n  This is mostly for tests where the registry may not be cleaned up\n  correctly in case of problems in test teardown.\n  If you register the same profile twice in zcml, you still get a\n  conflict from ``zope.configuration`` during Zope startup.\n  [maurits]\n\n\n1.8.6 (2016-12-30)\n------------------\n\n- Added a ``purge_old`` option to the tarball import form.\n  By default this option is checked, which matches the previous behavior.\n  If you uncheck it, this avoids purging old settings for any import step\n  that is run.  [maurits]\n\n\n1.8.5 (2016-11-01)\n------------------\n\n- Stopped using a form library to render the components form.\n\n1.8.4 (2016-09-21)\n------------------\n\n- Made ``_profile_upgrade_versions`` a PersistentMapping.  When\n  ``(un)setLastVersionForProfile`` is called, we migrate the original\n  Python dictionary.  This makes some code easier and plays nicer with\n  transactions, which may especially help during tests.  [maurits]\n\n\n1.8.3 (2016-04-28)\n------------------\n\n- Allowed overriding required and forbidden tools in ``toolset.xml``.\n  If a tool is currently required and you import a ``toolset.xml``\n  where it is forbidden, we remove the tool from the required list and\n  add it to the forbidden list.  And the other way around.  The\n  previous behavior was to raise an exception, which left no way in\n  xml to remove a tool.  Fail with a ValueError when the ``remove``\n  keyword is used.  The expected behavior is unclear.  [maurits]\n\n\n1.8.2 (2016-02-24)\n------------------\n\n- Added optional ``pre_handler`` and ``post_handler`` to\n  ``registerProfile`` directive.  When set, these dotted names are\n  resolved to a function and are passed the setup tool as single\n  argument.  They are called before and after applying all import\n  steps of the profile they are registered for.  [maurits]\n\n- Sorted import profiles alphabetically lowercase.  Allow selecting a\n  profile by title or id.  [maurits]\n\n- Do not show dependency options on the full import tab when there are\n  no dependencies.  [maurits]\n\n- Do not select a profile by default in the import tabs.  [maurits]\n\n- Added simple toggle for all steps on the advanced import tab.\n  Also added this on the export tab.\n  [maurits]\n\n- Fixed importing a tarball.  This got an AttributeError: \"'NoneType'\n  object has no attribute 'startswith'\".\n  [maurits]\n\n- Split overly complex Import tab into three tabs: Import (for\n  importing a full profile), Advanced Import (the original\n  ``manage_importSteps`` url leads to this tab), and Tarball Import.\n  [maurits]\n\n- Show note on import tab when there are pending upgrades.  Especially\n  show this for the currently selected profile.\n  [maurits]\n\n- Upgrades tab: show profiles with pending upgrades separately.  These\n  are the most important ones.  This avoids the need to manually go\n  through the whole list in order to find profiles that may need\n  action.  This uses new methods on the setup tool:\n  ``hasPendingUpgrades``, ``listProfilesWithPendingUpgrades``,\n  ``listUptodateProfiles``.\n  [maurits]\n\n\n1.8.1 (2015-12-16)\n------------------\n\n- Purge the profile upgrade versions before applying a base profile.\n\n- Added ``purgeProfileVersions`` method to ``portal_setup``.  This\n  removes the all profiles profile upgrade versions.\n\n- Added ``unsetLastVersionForProfile`` method to ``portal_setup``.  This\n  removes the profile id from the profile upgrade versions.  Calling\n  ``setLastVersionForProfile`` with ``unknown`` as version now has the\n  same effect.\n\n\n1.8.0 (2015-09-21)\n------------------\n\n- Be more forgiving when dealing with profile ids with or without\n  ``profile-`` at the start.  All functions that accept a profile id\n  argument and only work when the id does *not* have this string at\n  the start, will now strip it off if it is there.  For example,\n  ``getLastVersionForProfile`` will give the same answer whether you\n  ask it for the version of profile id ``foo`` or ``profile-foo``.\n\n- Dependency profiles from ``metadata.xml`` that are already applied,\n  are not applied again.  Instead, its upgrade steps, if any, are\n  applied.  In code you can choose the old behavior of always applying\n  the dependencies, by calling ``runAllImportStepsFromProfile`` with\n  ``dependency_strategy=DEPENDENCY_STRATEGY_REAPPLY``.  There are four\n  strategies, which you can choose in the ZMI.\n\n\n1.7.7 (2015-08-11)\n------------------\n\n- Fix: when the last applied upgrade step had a checker, the profile\n  version was not updated.  Now we no longer look at the checker of\n  the last applied step when deciding whether to set the profile\n  version.  The checker, if any is set, normally returns True before\n  running the step (it can be applied), and False afterwards (it\n  was already applied).\n\n- Add ``upgradeProfile`` method to setup tool.  This method applies all\n  upgrades steps for the given profile, or updates it to the optional\n  given version.  If the profile does not exist, or if there is no upgrade\n  step to go to the specified version, the method warns and does nothing.\n\n- Check the boolean value of the ``remove`` option when importing\n  objects.  Previously we only checked if the ``remove`` option was\n  given, regardless of its value.  Supported are ``True``, ``Yes``,\n  and ``1``, where case does not matter.  The syntax for removing\n  objects, properties, and elements is now the same.\n\n- Support ``remove=\"True\"`` for properties.\n\n\n1.7.6 (2015-07-15)\n------------------\n\n- Enable testing under Travis.\n\n- Fix compatibility with Setuptools 8.0 and later.  Upgrade steps\n  could get sorted in the wrong order, especially an empty version\n  string (upgrade step from any source version) sorted last instead of\n  first.\n\n\n1.7.5 (2014-10-23)\n------------------\n\n- Allow skipping certain steps on ``runAllImportStepsFromProfile``.\n\n\n1.7.4 (2013-06-12)\n------------------\n\n- On import, avoid clearing indexes whose state is unchanged.\n\n\n1.7.3 (2012-10-16)\n------------------\n\n- Sort profiles on Upgrade form.\n\n- Use clickable labels with checkboxes on import, export and upgrade forms\n  to improve usability.\n\n\n1.7.2 (2012-07-23)\n------------------\n\n- Avoid using ``manage_FTPGet`` on snapshot exports: that method messes\n  up the response headers.\n\n- ZopePageTemplate handler:  Fix export encoding: since 1.7.0, exports\n  must be UTF-8 strings\n\n\n1.7.1 (2012-02-28)\n------------------\n\n- Restore the ability to make the setup tool use only import / export\n  steps explicitly called out by the current profile, ignoring any which\n  might be globally registered.  This is particularly useful for configuring\n  sites with baseline profiles, where arbitrary add-on steps are not only\n  useless, but potentially damaging.\n\n\n1.7.0 (2012-01-27)\n------------------\n\n- While importing ``toolset.xml``, print a warning when the class of a\n  required tool is not found and continue with the next tool.  The\n  previous behaviour could break the install or uninstall of any\n  add-on, as the missing class may easily be from a different\n  unrelated add-on that is no longer available in the zope instance.\n\n- Exporters now explicitly only understand strings. The provided\n  registry handlers encode and decode data automatically to and from\n  UTF-8. Their default encoding changed from None to UTF-8.\n  If you have custom registry handlers, ensure that you encode your unicode.\n  Check especially if you use a page template to generate xml. They return\n  unicode and their output must also encoded.\n  If you choose to encode your strings with UTF-8, you can be sure that\n  your code will also work with GenericSetup < 1.7\n", "##############################################################################\n#\n# Copyright (c) 2004 Zope Foundation and Contributors.\n#\n# This software is subject to the provisions of the Zope Public License,\n# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.\n# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED\n# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS\n# FOR A PARTICULAR PURPOSE.\n#\n##############################################################################\n\"\"\" Various context implementations for export / import of configurations.\n\nWrappers representing the state of an import / export operation.\n\"\"\"\n\nimport logging\nimport os\nimport time\nfrom io import BytesIO\nfrom tarfile import DIRTYPE\nfrom tarfile import TarFile\nfrom tarfile import TarInfo\n\nimport six\n\nfrom AccessControl.class_init import InitializeClass\nfrom AccessControl.Permissions import view\nfrom AccessControl.SecurityInfo import ClassSecurityInfo\nfrom Acquisition import Implicit\nfrom Acquisition import aq_base\nfrom Acquisition import aq_inner\nfrom Acquisition import aq_parent\nfrom Acquisition import aq_self\nfrom DateTime.DateTime import DateTime\nfrom OFS.DTMLDocument import DTMLDocument\nfrom OFS.Folder import Folder\nfrom OFS.Image import File\nfrom OFS.Image import Image\nfrom Products.PageTemplates.ZopePageTemplate import ZopePageTemplate\nfrom Products.PythonScripts.PythonScript import PythonScript\nfrom zope.interface import implementer\n\nfrom .interfaces import SKIPPED_FILES\nfrom .interfaces import SKIPPED_SUFFIXES\nfrom .interfaces import IChunkableExportContext\nfrom .interfaces import IChunkableImportContext\nfrom .interfaces import IExportContext\nfrom .interfaces import IImportContext\nfrom .interfaces import ISetupEnviron\nfrom .interfaces import IWriteLogger\nfrom .permissions import ManagePortal\n\n\n@implementer(IWriteLogger)\nclass Logger:\n\n    def __init__(self, id, messages):\n        \"\"\"Initialize the logger with a name and an optional level.\n        \"\"\"\n        self._id = id\n        self._messages = messages\n        self._logger = logging.getLogger('GenericSetup.%s' % id)\n\n    def debug(self, msg, *args, **kwargs):\n        \"\"\"Log 'msg % args' with severity 'DEBUG'.\n        \"\"\"\n        self.log(logging.DEBUG, msg, *args, **kwargs)\n\n    def info(self, msg, *args, **kwargs):\n        \"\"\"Log 'msg % args' with severity 'INFO'.\n        \"\"\"\n        self.log(logging.INFO, msg, *args, **kwargs)\n\n    def warning(self, msg, *args, **kwargs):\n        \"\"\"Log 'msg % args' with severity 'WARNING'.\n        \"\"\"\n        self.log(logging.WARNING, msg, *args, **kwargs)\n\n    def error(self, msg, *args, **kwargs):\n        \"\"\"Log 'msg % args' with severity 'ERROR'.\n        \"\"\"\n        self.log(logging.ERROR, msg, *args, **kwargs)\n\n    def exception(self, msg, *args):\n        \"\"\"Convenience method for logging an ERROR with exception information.\n        \"\"\"\n        self.error(msg, *args, **{'exc_info': 1})\n\n    def critical(self, msg, *args, **kwargs):\n        \"\"\"Log 'msg % args' with severity 'CRITICAL'.\n        \"\"\"\n        self.log(logging.CRITICAL, msg, *args, **kwargs)\n\n    def log(self, level, msg, *args, **kwargs):\n        \"\"\"Log 'msg % args' with the integer severity 'level'.\n        \"\"\"\n        self._messages.append((level, self._id, msg))\n        self._logger.log(level, msg, *args, **kwargs)\n\n\n@implementer(ISetupEnviron)\nclass SetupEnviron(Implicit):\n\n    \"\"\"Context for body im- and exporter.\n    \"\"\"\n\n    security = ClassSecurityInfo()\n\n    def __init__(self):\n        self._should_purge = True\n\n    @security.protected(ManagePortal)\n    def getLogger(self, name):\n        \"\"\"Get a logger with the specified name, creating it if necessary.\n        \"\"\"\n        return logging.getLogger('GenericSetup.%s' % name)\n\n    @security.protected(ManagePortal)\n    def shouldPurge(self):\n        \"\"\"When installing, should the existing setup be purged?\n        \"\"\"\n        return self._should_purge\n\n\nInitializeClass(SetupEnviron)\n\n\nclass BaseContext(SetupEnviron):\n\n    security = ClassSecurityInfo()\n\n    def __init__(self, tool, encoding):\n\n        self._tool = tool\n        self._site = aq_parent(aq_inner(tool))\n        self._loggers = {}\n        self._messages = []\n        self._encoding = encoding\n        self._should_purge = True\n\n    @security.protected(ManagePortal)\n    def getSite(self):\n        \"\"\" See ISetupContext.\n        \"\"\"\n        return aq_self(self._site)\n\n    @security.protected(ManagePortal)\n    def getSetupTool(self):\n        \"\"\" See ISetupContext.\n        \"\"\"\n        return self._tool\n\n    @security.protected(ManagePortal)\n    def getEncoding(self):\n        \"\"\" See ISetupContext.\n        \"\"\"\n        return self._encoding\n\n    @security.protected(ManagePortal)\n    def getLogger(self, name):\n        \"\"\" See ISetupContext.\n        \"\"\"\n        return self._loggers.setdefault(name, Logger(name, self._messages))\n\n    @security.protected(ManagePortal)\n    def listNotes(self):\n        \"\"\" See ISetupContext.\n        \"\"\"\n        return self._messages[:]\n\n    @security.protected(ManagePortal)\n    def clearNotes(self):\n        \"\"\" See ISetupContext.\n        \"\"\"\n        self._messages[:] = []\n\n\nInitializeClass(BaseContext)\n\n\n@implementer(IChunkableImportContext)\nclass DirectoryImportContext(BaseContext):\n\n    security = ClassSecurityInfo()\n\n    def __init__(self, tool, profile_path, should_purge=False,\n                 encoding=None):\n\n        BaseContext.__init__(self, tool, encoding)\n        self._profile_path = profile_path\n        self._should_purge = bool(should_purge)\n\n    @security.protected(ManagePortal)\n    def openDataFile(self, filename, subdir=None):\n        \"\"\" See IImportContext.\n        \"\"\"\n        if subdir is None:\n            full_path = os.path.join(self._profile_path, filename)\n        else:\n            full_path = os.path.join(self._profile_path, subdir, filename)\n\n        if not os.path.exists(full_path):\n            return None\n\n        return open(full_path, 'rb')\n\n    @security.protected(ManagePortal)\n    def readDataFile(self, filename, subdir=None):\n        \"\"\" See IImportContext.\n        \"\"\"\n        result = None\n        file = self.openDataFile(filename, subdir)\n        if file is not None:\n            result = file.read()\n            file.close()\n        return result\n\n    @security.protected(ManagePortal)\n    def getLastModified(self, path):\n        \"\"\" See IImportContext.\n        \"\"\"\n        full_path = os.path.join(self._profile_path, path)\n\n        if not os.path.exists(full_path):\n            return None\n\n        return DateTime(os.path.getmtime(full_path))\n\n    @security.protected(ManagePortal)\n    def isDirectory(self, path):\n        \"\"\" See IImportContext.\n        \"\"\"\n        full_path = os.path.join(self._profile_path, path)\n\n        if not os.path.exists(full_path):\n            return None\n\n        return os.path.isdir(full_path)\n\n    @security.protected(ManagePortal)\n    def listDirectory(self, path, skip=SKIPPED_FILES,\n                      skip_suffixes=SKIPPED_SUFFIXES):\n        \"\"\" See IImportContext.\n        \"\"\"\n        if path is None:\n            path = ''\n\n        full_path = os.path.join(self._profile_path, path)\n\n        if not os.path.exists(full_path) or not os.path.isdir(full_path):\n            return None\n\n        names = []\n        for name in os.listdir(full_path):\n            if name in skip:\n                continue\n            if [s for s in skip_suffixes if name.endswith(s)]:\n                continue\n            names.append(name)\n\n        return names\n\n\nInitializeClass(DirectoryImportContext)\n\n\n@implementer(IChunkableExportContext)\nclass DirectoryExportContext(BaseContext):\n\n    security = ClassSecurityInfo()\n\n    def __init__(self, tool, profile_path, encoding=None):\n\n        BaseContext.__init__(self, tool, encoding)\n        self._profile_path = profile_path\n\n    @security.protected(ManagePortal)\n    def openDataFile(self, filename, content_type, subdir=None):\n        \"\"\" See IChunkableExportContext.\n        \"\"\"\n        if subdir is None:\n            prefix = self._profile_path\n        else:\n            prefix = os.path.join(self._profile_path, subdir)\n\n        full_path = os.path.join(prefix, filename)\n\n        if not os.path.exists(prefix):\n            os.makedirs(prefix)\n\n        return open(full_path, 'wb')\n\n    @security.protected(ManagePortal)\n    def writeDataFile(self, filename, text, content_type, subdir=None):\n        \"\"\" See IExportContext.\n        \"\"\"\n        if isinstance(text, six.text_type):\n            encoding = self.getEncoding() or 'utf-8'\n            text = text.encode(encoding)\n        file = self.openDataFile(filename, content_type, subdir)\n        file.write(text)\n        file.close()\n\n\nInitializeClass(DirectoryExportContext)\n\n\n@implementer(IImportContext)\nclass TarballImportContext(BaseContext):\n\n    security = ClassSecurityInfo()\n\n    def __init__(self, tool, archive_bits, encoding=None, should_purge=False):\n        BaseContext.__init__(self, tool, encoding)\n        self._archive_stream = BytesIO(archive_bits)\n        self._archive = TarFile.open('foo.bar', 'r:gz', self._archive_stream)\n        self._should_purge = bool(should_purge)\n\n    def readDataFile(self, filename, subdir=None):\n        \"\"\" See IImportContext.\n        \"\"\"\n        if subdir is not None:\n            filename = '/'.join((subdir, filename))\n\n        try:\n            file = self._archive.extractfile(filename)\n        except KeyError:\n            return None\n\n        return file.read()\n\n    def getLastModified(self, path):\n        \"\"\" See IImportContext.\n        \"\"\"\n        info = self._getTarInfo(path)\n        return info and DateTime(info.mtime) or None\n\n    def isDirectory(self, path):\n        \"\"\" See IImportContext.\n        \"\"\"\n        info = self._getTarInfo(path)\n\n        if info is not None:\n            return info.isdir()\n\n    def listDirectory(self, path, skip=SKIPPED_FILES,\n                      skip_suffixes=SKIPPED_SUFFIXES):\n        \"\"\" See IImportContext.\n        \"\"\"\n        if path is None:  # root is special case:  no leading '/'\n            path = ''\n        else:\n            if not self.isDirectory(path):\n                return None\n\n            if not path.endswith('/'):\n                path = path + '/'\n\n        pfx_len = len(path)\n\n        names = []\n        for info in self._archive.getmembers():\n            name = info.name.rstrip('/')\n            if name == path or not name.startswith(path):\n                continue\n            name = name[pfx_len:]\n            if '/' in name:\n                # filter out items in subdirs\n                continue\n            if name in skip:\n                continue\n            if [s for s in skip_suffixes if name.endswith(s)]:\n                continue\n            names.append(name)\n\n        return names\n\n    def shouldPurge(self):\n        \"\"\" See IImportContext.\n        \"\"\"\n        return self._should_purge\n\n    def _getTarInfo(self, path):\n        if path.endswith('/'):\n            path = path[:-1]\n        try:\n            return self._archive.getmember(path)\n        except KeyError:\n            pass\n        try:\n            return self._archive.getmember(path + '/')\n        except KeyError:\n            return None\n\n\nInitializeClass(TarballImportContext)\n\n\n@implementer(IExportContext)\nclass TarballExportContext(BaseContext):\n\n    security = ClassSecurityInfo()\n\n    def __init__(self, tool, encoding=None):\n\n        BaseContext.__init__(self, tool, encoding)\n\n        timestamp = time.gmtime()\n        archive_name = ('setup_tool-%4d%02d%02d%02d%02d%02d.tar.gz'\n                        % timestamp[:6])\n\n        self._archive_stream = BytesIO()\n        self._archive_filename = archive_name\n        self._archive = TarFile.open(archive_name, 'w:gz',\n                                     self._archive_stream)\n\n    @security.protected(ManagePortal)\n    def writeDataFile(self, filename, text, content_type, subdir=None):\n        \"\"\" See IExportContext.\n        \"\"\"\n        if subdir is not None:\n            filename = '/'.join((subdir, filename))\n\n        parents = filename.split('/')[:-1]\n        while parents:\n            path = '/'.join(parents) + '/'\n            if path not in self._archive.getnames():\n                info = TarInfo(path)\n                info.type = DIRTYPE\n                # tarfile.filemode(0o755) == '-rwxr-xr-x'\n                info.mode = 0o755\n                info.mtime = time.time()\n                self._archive.addfile(info)\n            parents.pop()\n\n        info = TarInfo(filename)\n        if isinstance(text, six.text_type):\n            encoding = self.getEncoding() or 'utf-8'\n            text = text.encode(encoding)\n\n        if isinstance(text, six.binary_type):\n            stream = BytesIO(text)\n            info.size = len(text)\n        else:\n            # Assume text is a an instance of a class like\n            # Products.Archetypes.WebDAVSupport.PdataStreamIterator,\n            # as in the case of ATFile\n            stream = text.file\n            info.size = text.size\n        info.mtime = time.time()\n        self._archive.addfile(info, stream)\n\n    @security.protected(ManagePortal)\n    def getArchive(self):\n        \"\"\" Close the archive, and return it as a big string.\n        \"\"\"\n        self._archive.close()\n        return self._archive_stream.getvalue()\n\n    @security.protected(ManagePortal)\n    def getArchiveFilename(self):\n        \"\"\" Close the archive, and return it as a big string.\n        \"\"\"\n        return self._archive_filename\n\n\nInitializeClass(TarballExportContext)\n\n\n@implementer(IExportContext)\nclass SnapshotExportContext(BaseContext):\n\n    security = ClassSecurityInfo()\n\n    def __init__(self, tool, snapshot_id, encoding=None):\n\n        BaseContext.__init__(self, tool, encoding)\n        self._snapshot_id = snapshot_id\n\n    @security.protected(ManagePortal)\n    def writeDataFile(self, filename, text, content_type, subdir=None):\n        \"\"\" See IExportContext.\n        \"\"\"\n        if subdir is not None:\n            filename = '/'.join((subdir, filename))\n\n        sep = filename.rfind('/')\n        if sep != -1:\n            subdir = filename[:sep]\n            filename = filename[sep+1:]\n\n        if six.PY2 and isinstance(text, six.text_type):\n            encoding = self.getEncoding() or 'utf-8'\n            text = text.encode(encoding)\n\n        folder = self._ensureSnapshotsFolder(subdir)\n\n        # MISSING: switch on content_type\n        ob = self._createObjectByType(filename, text, content_type)\n        folder._setObject(str(filename), ob)  # No Unicode IDs!\n        # Tighten the View permission on the new object.\n        # Only the owner and Manager users may view the log.\n        # file_ob = self._getOb(name)\n        ob.manage_permission(view, ('Manager', 'Owner'), 0)\n\n    @security.protected(ManagePortal)\n    def getSnapshotURL(self):\n        \"\"\" See IExportContext.\n        \"\"\"\n        return '%s/%s' % (self._tool.absolute_url(), self._snapshot_id)\n\n    @security.protected(ManagePortal)\n    def getSnapshotFolder(self):\n        \"\"\" See IExportContext.\n        \"\"\"\n        return self._ensureSnapshotsFolder()\n\n    #\n    #   Helper methods\n    #\n    @security.private\n    def _createObjectByType(self, name, body, content_type):\n        encoding = self.getEncoding() or 'utf-8'\n\n        if six.PY2 and isinstance(body, six.text_type):\n            body = body.encode(encoding)\n\n        if name.endswith('.py'):\n            ob = PythonScript(name)\n            ob.write(body)\n            return ob\n\n        if name.endswith('.dtml'):\n            ob = DTMLDocument('', __name__=name)\n            ob.munge(body)\n            return ob\n\n        if content_type in ('text/html', 'text/xml'):\n            return ZopePageTemplate(name, body, content_type=content_type)\n\n        if isinstance(body, six.text_type):\n            body = body.encode(encoding)\n\n        if content_type[:6] == 'image/':\n            return Image(name, '', body, content_type=content_type)\n\n        return File(name, '', body, content_type=content_type)\n\n    @security.private\n    def _ensureSnapshotsFolder(self, subdir=None):\n        \"\"\" Ensure that the appropriate snapshot folder exists.\n        \"\"\"\n        path = ['snapshots', self._snapshot_id]\n\n        if subdir is not None:\n            path.extend(subdir.split('/'))\n\n        current = self._tool\n\n        for element in path:\n\n            if element not in current.objectIds():\n                # No Unicode IDs!\n                current._setObject(str(element), Folder(element))\n                current = current._getOb(element)\n                current.manage_permission(view, ('Manager', 'Owner'), 0)\n            else:\n                current = current._getOb(element)\n\n        return current\n\n\nInitializeClass(SnapshotExportContext)\n\n\n@implementer(IImportContext)\nclass SnapshotImportContext(BaseContext):\n\n    security = ClassSecurityInfo()\n\n    def __init__(self, tool, snapshot_id, should_purge=False, encoding=None):\n        BaseContext.__init__(self, tool, encoding)\n        self._snapshot_id = snapshot_id\n        self._encoding = encoding\n        self._should_purge = bool(should_purge)\n\n    @security.protected(ManagePortal)\n    def readDataFile(self, filename, subdir=None):\n        \"\"\" See IImportContext.\n        \"\"\"\n        if subdir is not None:\n            filename = '/'.join((subdir, filename))\n\n        sep = filename.rfind('/')\n        if sep != -1:\n            subdir = filename[:sep]\n            filename = filename[sep+1:]\n        try:\n            snapshot = self._getSnapshotFolder(subdir)\n            object = snapshot._getOb(filename)\n        except (AttributeError, KeyError):\n            return None\n\n        if isinstance(object, File):\n            # OFS File Object have only one way to access the raw\n            # data directly, __str__. The code explicitly forbids\n            # to store unicode, so str() is safe here\n            data = six.binary_type(aq_base(object.data))\n        else:\n            data = object.read()\n        if isinstance(data, six.text_type):\n            data = data.encode('utf-8')\n        return data\n\n    @security.protected(ManagePortal)\n    def getLastModified(self, path):\n        \"\"\" See IImportContext.\n        \"\"\"\n        try:\n            snapshot = self._getSnapshotFolder()\n            object = snapshot.restrictedTraverse(path)\n        except (AttributeError, KeyError):\n            return None\n        else:\n            mtime = getattr(object, '_p_mtime', None)\n            if mtime is None:\n                # test hook\n                mtime = getattr(object, '_faux_mod_time', None)\n                if mtime is None:\n                    return DateTime()\n            return DateTime(mtime)\n\n    @security.protected(ManagePortal)\n    def isDirectory(self, path):\n        \"\"\" See IImportContext.\n        \"\"\"\n        try:\n            snapshot = self._getSnapshotFolder()\n            object = snapshot.restrictedTraverse(str(path))\n        except (AttributeError, KeyError):\n            return None\n        else:\n            folderish = getattr(object, 'isPrincipiaFolderish', False)\n            return bool(folderish)\n\n    @security.protected(ManagePortal)\n    def listDirectory(self, path, skip=(), skip_suffixes=()):\n        \"\"\" See IImportContext.\n        \"\"\"\n        try:\n            snapshot = self._getSnapshotFolder()\n            subdir = snapshot.restrictedTraverse(path)\n        except (AttributeError, KeyError):\n            return None\n        else:\n            if not getattr(subdir, 'isPrincipiaFolderish', False):\n                return None\n\n            names = []\n            for name in subdir.objectIds():\n                if name in skip:\n                    continue\n                if [s for s in skip_suffixes if name.endswith(s)]:\n                    continue\n                names.append(name)\n\n            return names\n\n    @security.protected(ManagePortal)\n    def shouldPurge(self):\n        \"\"\" See IImportContext.\n        \"\"\"\n        return self._should_purge\n\n    #\n    #   Helper methods\n    #\n    @security.private\n    def _getSnapshotFolder(self, subdir=None):\n        \"\"\" Return the appropriate snapshot (sub)folder.\n        \"\"\"\n        path = ['snapshots', self._snapshot_id]\n\n        if subdir is not None:\n            path.extend(subdir.split('/'))\n\n        return self._tool.restrictedTraverse(path)\n\n\nInitializeClass(SnapshotImportContext)\n", "##############################################################################\n#\n# Copyright (c) 2004 Zope Foundation and Contributors.\n#\n# This software is subject to the provisions of the Zope Public License,\n# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.\n# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED\n# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS\n# FOR A PARTICULAR PURPOSE.\n#\n##############################################################################\n\"\"\" Unit tests for GenericSetup tool.\n\"\"\"\n\nimport os\nimport tempfile\nimport unittest\n\nimport six\nfrom six import BytesIO\n\nimport transaction\nfrom AccessControl.Permissions import view\nfrom AccessControl.SecurityManagement import newSecurityManager\nfrom AccessControl.SecurityManagement import noSecurityManager\nfrom AccessControl.users import UnrestrictedUser\nfrom Acquisition import aq_base\nfrom OFS.Folder import Folder\nfrom zope.component import adapter\nfrom zope.component import provideHandler\nfrom zope.component.globalregistry import base as base_registry\n\nfrom Products.GenericSetup import profile_registry\n\nfrom ..context import TarballExportContext\nfrom ..interfaces import IBeforeProfileImportEvent\nfrom ..interfaces import IProfileImportedEvent\nfrom ..testing import ExportImportZCMLLayer\nfrom ..upgrade import UpgradeStep\nfrom ..upgrade import _registerUpgradeStep\nfrom ..upgrade import listUpgradeSteps\nfrom .common import BaseRegistryTests\nfrom .common import DummyExportContext\nfrom .common import DummyImportContext\nfrom .common import FilesystemTestBase\nfrom .common import TarballTester\nfrom .common import _makeTestFile\nfrom .conformance import ConformsToISetupTool\nfrom .test_registry import _EMPTY_EXPORT_XML\nfrom .test_registry import _EMPTY_IMPORT_XML\nfrom .test_registry import _EMPTY_TOOLSET_XML\nfrom .test_registry import _NORMAL_TOOLSET_XML\nfrom .test_registry import _SINGLE_EXPORT_XML\nfrom .test_registry import _SINGLE_IMPORT_XML\nfrom .test_registry import ONE_FUNC\nfrom .test_registry import IAnotherSite\nfrom .test_registry import IDerivedSite\nfrom .test_registry import ISite\nfrom .test_zcml import dummy_upgrade\n\n\n_before_import_events = []\n\n\n@adapter(IBeforeProfileImportEvent)\ndef handleBeforeProfileImportEvent(event):\n    _before_import_events.append(event)\n\n\n_after_import_events = []\n\n\n@adapter(IProfileImportedEvent)\ndef handleProfileImportedEvent(event):\n    _after_import_events.append(event)\n\n\n_METADATA_XML = \"\"\"<?xml version=\"1.0\"?>\n<metadata>\n  <version>1.0</version>\n  <dependencies>\n    <dependency>profile-other:bar</dependency>\n  </dependencies>\n</metadata>\n\"\"\"\n_DOUBLE_METADATA_XML = \"\"\"<?xml version=\"1.0\"?>\n<metadata>\n  <version>1.0</version>\n  <dependencies>\n    <dependency>profile-other:bar</dependency>\n    <dependency>profile-other:ham</dependency>\n  </dependencies>\n</metadata>\n\"\"\"\n_PLAIN_METADATA_XML = \"\"\"<?xml version=\"1.0\"?>\n<metadata>\n  <version>1.0</version>\n</metadata>\n\"\"\"\n_BROKEN_METADATA_XML = \"\"\"<?xml version=\"1.0\"?>\n<metadata>\n  <version>1.0</version>\n  <dependencies>\n    <dependency>profile-other:non-existing-profile</dependency>\n  </dependencies>\n</metadata>\n\"\"\"\n\n\nclass SetupToolTests(FilesystemTestBase, TarballTester, ConformsToISetupTool):\n\n    layer = ExportImportZCMLLayer\n\n    _PROFILE_PATH = tempfile.mkdtemp(prefix='STT_test')\n    _PROFILE_PATH2 = tempfile.mkdtemp(prefix='STT_test2')\n    _PROFILE_PATH3 = tempfile.mkdtemp(prefix='STT_test3')\n\n    def afterSetUp(self):\n        from ..upgrade import _upgrade_registry\n        _upgrade_registry.clear()\n        profile_registry.clear()\n        global _before_import_events\n        global _after_import_events\n        _before_import_events = []\n        provideHandler(handleBeforeProfileImportEvent)\n        _after_import_events = []\n        provideHandler(handleProfileImportedEvent)\n\n    def beforeTearDown(self):\n        base_registry.unregisterHandler(handleBeforeProfileImportEvent)\n        base_registry.unregisterHandler(handleProfileImportedEvent)\n        FilesystemTestBase.beforeTearDown(self)\n        from ..upgrade import _upgrade_registry\n        profile_registry.clear()\n        _upgrade_registry.clear()\n        noSecurityManager()\n\n    def _getTargetClass(self):\n        from ..tool import SetupTool\n\n        return SetupTool\n\n    def _makeSite(self, title=\"Don't care\"):\n\n        site = Folder()\n        site._setId('site')\n        site.title = title\n\n        self.app._setObject('site', site)\n        self.app.acl_users.userFolderAddUser('admin', '', ['Manager'], [])\n        newSecurityManager(None, self.app.acl_users.getUser('admin'))\n        return self.app._getOb('site')\n\n    def test_empty(self):\n\n        tool = self._makeOne('setup_tool')\n\n        self.assertEqual(tool.getBaselineContextID(), '')\n\n        import_registry = tool.getImportStepRegistry()\n        self.assertEqual(len(import_registry.listSteps()), 0)\n\n        export_registry = tool.getExportStepRegistry()\n        export_steps = export_registry.listSteps()\n        self.assertEqual(len(export_steps), 0)\n\n        toolset_registry = tool.getToolsetRegistry()\n        self.assertEqual(len(toolset_registry.listForbiddenTools()), 0)\n        self.assertEqual(len(toolset_registry.listRequiredTools()), 0)\n\n    def test_getBaselineContextID(self):\n        from ..tool import EXPORT_STEPS_XML\n        from ..tool import IMPORT_STEPS_XML\n        from ..tool import TOOLSET_XML\n\n        tool = self._makeOne('setup_tool')\n\n        self._makeFile(IMPORT_STEPS_XML, _EMPTY_IMPORT_XML)\n        self._makeFile(EXPORT_STEPS_XML, _EMPTY_EXPORT_XML)\n        self._makeFile(TOOLSET_XML, _EMPTY_TOOLSET_XML)\n\n        profile_registry.registerProfile('foo', 'Foo', '', self._PROFILE_PATH)\n        tool.setBaselineContext('profile-other:foo')\n\n        self.assertEqual(tool.getBaselineContextID(), 'profile-other:foo')\n\n    def test_setBaselineContext_invalid(self):\n\n        tool = self._makeOne('setup_tool')\n\n        self.assertRaises(KeyError, tool.setBaselineContext, 'profile-foo')\n\n    def test_setBaselineContext_empty_string(self):\n\n        tool = self._makeOne('setup_tool')\n\n        self.assertRaises(KeyError, tool.setBaselineContext, '')\n\n    def test_setBaselineContext(self):\n        from ..tool import EXPORT_STEPS_XML\n        from ..tool import IMPORT_STEPS_XML\n        from ..tool import TOOLSET_XML\n\n        tool = self._makeOne('setup_tool')\n        tool.getExportStepRegistry().clear()\n\n        self._makeFile(IMPORT_STEPS_XML, _SINGLE_IMPORT_XML)\n        self._makeFile(EXPORT_STEPS_XML, _SINGLE_EXPORT_XML)\n        self._makeFile(TOOLSET_XML, _NORMAL_TOOLSET_XML)\n\n        profile_registry.registerProfile('foo', 'Foo', '', self._PROFILE_PATH)\n        tool.setBaselineContext('profile-other:foo')\n\n        self.assertEqual(tool.getBaselineContextID(), 'profile-other:foo')\n\n        import_registry = tool.getImportStepRegistry()\n        self.assertEqual(len(import_registry.listSteps()), 1)\n        self.assertTrue('one' in import_registry.listSteps())\n        info = import_registry.getStepMetadata('one')\n        self.assertEqual(info['id'], 'one')\n        self.assertEqual(info['title'], 'One Step')\n        self.assertEqual(info['version'], '1')\n        self.assertTrue('One small step' in info['description'])\n        self.assertEqual(info['handler'],\n                         'Products.GenericSetup.tests.test_registry.ONE_FUNC')\n\n        self.assertEqual(import_registry.getStep('one'), ONE_FUNC)\n\n        export_registry = tool.getExportStepRegistry()\n        self.assertEqual(len(export_registry.listSteps()), 1)\n        self.assertTrue('one' in import_registry.listSteps())\n        info = export_registry.getStepMetadata('one')\n        self.assertEqual(info['id'], 'one')\n        self.assertEqual(info['title'], 'One Step')\n        self.assertTrue('One small step' in info['description'])\n        self.assertEqual(info['handler'],\n                         'Products.GenericSetup.tests.test_registry.ONE_FUNC')\n\n        self.assertEqual(export_registry.getStep('one'), ONE_FUNC)\n\n    def test_runImportStepFromProfile_nonesuch(self):\n\n        site = self._makeSite()\n\n        tool = self._makeOne('setup_tool').__of__(site)\n\n        self.assertRaises(KeyError, tool.runImportStepFromProfile,\n                          '', 'nonesuch')\n\n    def test_runImportStepFromProfile_simple(self):\n\n        TITLE = 'original title'\n        site = self._makeSite(TITLE)\n\n        tool = self._makeOne('setup_tool').__of__(site)\n\n        registry = tool.getImportStepRegistry()\n        registry.registerStep('simple', '1', _uppercaseSiteTitle)\n\n        result = tool.runImportStepFromProfile('snapshot-dummy', 'simple')\n\n        self.assertEqual(len(result['steps']), 1)\n\n        self.assertEqual(result['steps'][0], 'simple')\n        self.assertEqual(result['messages']['simple'], 'Uppercased title')\n\n        self.assertEqual(site.title, TITLE.upper())\n\n        global _before_import_events\n        self.assertEqual(len(_before_import_events), 1)\n        self.assertEqual(_before_import_events[0].profile_id, 'snapshot-dummy')\n        self.assertEqual(_before_import_events[0].steps, ['simple'])\n        self.assertEqual(_before_import_events[0].full_import, False)\n\n        global _after_import_events\n        self.assertEqual(len(_after_import_events), 1)\n        self.assertEqual(_after_import_events[0].profile_id, 'snapshot-dummy')\n        self.assertEqual(_after_import_events[0].steps, ['simple'])\n        self.assertEqual(_after_import_events[0].full_import, False)\n\n    def test_runImportStepFromProfile_dependencies(self):\n\n        TITLE = 'original title'\n        site = self._makeSite(TITLE)\n\n        tool = self._makeOne('setup_tool').__of__(site)\n\n        registry = tool.getImportStepRegistry()\n        registry.registerStep('dependable', '1', _underscoreSiteTitle)\n        registry.registerStep(\n            'dependent', '1', _uppercaseSiteTitle, ('dependable', ))\n\n        result = tool.runImportStepFromProfile('snapshot-dummy', 'dependent')\n\n        self.assertEqual(len(result['steps']), 2)\n\n        self.assertEqual(result['steps'][0], 'dependable')\n        self.assertEqual(result['messages']['dependable'], 'Underscored title')\n\n        self.assertEqual(result['steps'][1], 'dependent')\n        self.assertEqual(result['messages']['dependent'], 'Uppercased title')\n        self.assertEqual(site.title, TITLE.replace(' ', '_').upper())\n\n        global _before_import_events\n        self.assertEqual(len(_before_import_events), 1)\n        self.assertEqual(_before_import_events[0].profile_id, 'snapshot-dummy')\n        self.assertEqual(_before_import_events[0].steps,\n                         ['dependable', 'dependent'])\n        self.assertEqual(_before_import_events[0].full_import, False)\n\n        global _after_import_events\n        self.assertEqual(len(_after_import_events), 1)\n        self.assertEqual(_after_import_events[0].profile_id, 'snapshot-dummy')\n        self.assertEqual(_after_import_events[0].steps,\n                         ['dependable', 'dependent'])\n        self.assertEqual(_after_import_events[0].full_import, False)\n\n    def test_runImportStepFromProfile_skip_dependencies(self):\n\n        TITLE = 'original title'\n        site = self._makeSite(TITLE)\n\n        tool = self._makeOne('setup_tool').__of__(site)\n\n        registry = tool.getImportStepRegistry()\n        registry.registerStep('dependable', '1', _underscoreSiteTitle)\n        registry.registerStep(\n            'dependent', '1', _uppercaseSiteTitle, ('dependable', ))\n\n        result = tool.runImportStepFromProfile('snapshot-dummy', 'dependent',\n                                               run_dependencies=False)\n\n        self.assertEqual(len(result['steps']), 1)\n\n        self.assertEqual(result['steps'][0], 'dependent')\n        self.assertEqual(result['messages']['dependent'], 'Uppercased title')\n\n        self.assertEqual(site.title, TITLE.upper())\n\n        global _before_import_events\n        self.assertEqual(len(_before_import_events), 1)\n        self.assertEqual(_before_import_events[0].profile_id, 'snapshot-dummy')\n        self.assertEqual(_before_import_events[0].steps, ['dependent'])\n        self.assertEqual(_before_import_events[0].full_import, False)\n\n        global _after_import_events\n        self.assertEqual(len(_after_import_events), 1)\n        self.assertEqual(_after_import_events[0].profile_id, 'snapshot-dummy')\n        self.assertEqual(_after_import_events[0].steps, ['dependent'])\n        self.assertEqual(_after_import_events[0].full_import, False)\n\n    def test_runImportStepFromProfile_default_purge(self):\n\n        site = self._makeSite()\n\n        tool = self._makeOne('setup_tool').__of__(site)\n        registry = tool.getImportStepRegistry()\n        registry.registerStep('purging', '1', _purgeIfRequired)\n\n        result = tool.runImportStepFromProfile('snapshot-dummy', 'purging')\n\n        self.assertEqual(len(result['steps']), 1)\n        self.assertEqual(result['steps'][0], 'purging')\n        self.assertEqual(result['messages']['purging'], 'Purged')\n        self.assertTrue(site.purged)\n\n    def test_runImportStepFromProfile_explicit_purge(self):\n\n        site = self._makeSite()\n\n        tool = self._makeOne('setup_tool').__of__(site)\n        registry = tool.getImportStepRegistry()\n        registry.registerStep('purging', '1', _purgeIfRequired)\n\n        result = tool.runImportStepFromProfile('snapshot-dummy', 'purging',\n                                               purge_old=True)\n\n        self.assertEqual(len(result['steps']), 1)\n        self.assertEqual(result['steps'][0], 'purging')\n        self.assertEqual(result['messages']['purging'], 'Purged')\n        self.assertTrue(site.purged)\n\n    def test_runImportStepFromProfile_skip_purge(self):\n\n        site = self._makeSite()\n\n        tool = self._makeOne('setup_tool').__of__(site)\n        registry = tool.getImportStepRegistry()\n        registry.registerStep('purging', '1', _purgeIfRequired)\n\n        result = tool.runImportStepFromProfile('snapshot-dummy', 'purging',\n                                               purge_old=False)\n\n        self.assertEqual(len(result['steps']), 1)\n        self.assertEqual(result['steps'][0], 'purging')\n        self.assertEqual(result['messages']['purging'], 'Unpurged')\n        self.assertFalse(site.purged)\n\n    def test_runImportStepFromProfile_consistent_context(self):\n\n        site = self._makeSite()\n\n        tool = self._makeOne('setup_tool').__of__(site)\n\n        registry = tool.getImportStepRegistry()\n        registry.registerStep('purging', '1', _purgeIfRequired)\n        registry.registerStep(\n            'dependent', '1', _uppercaseSiteTitle, ('purging', ))\n\n        tool.runImportStepFromProfile('snapshot-dummy', 'dependent',\n                                      purge_old=False)\n        self.assertFalse(site.purged)\n\n    def test_runAllImportStepsFromProfile_empty(self):\n\n        site = self._makeSite()\n        tool = self._makeOne('setup_tool').__of__(site)\n\n        result = tool.runAllImportStepsFromProfile('snapshot-dummy')\n\n        self.assertEqual(len(result['steps']), 3)\n\n    def test_runAllImportStepsFromProfile_inquicksuccession(self):\n        \"\"\"\n        This test provokes an issue that only appears in testing.\n        There it can happen that profiles get run multiple times within\n        a second. As of 1.6.3, genericsetup does not handle this.\n        \"\"\"\n\n        site = self._makeSite()\n        tool = self._makeOne('setup_tool').__of__(site)\n\n        tool.runAllImportStepsFromProfile('snapshot-dummy')\n        tool.runAllImportStepsFromProfile('snapshot-dummy')\n        # For good measurement\n        tool.runAllImportStepsFromProfile('snapshot-dummy')\n\n        self.assertTrue(\"No exception thrown\")\n\n    def test_runAllImportStepsFromProfile_sorted_default_purge(self):\n\n        TITLE = 'original title'\n        PROFILE_ID = 'snapshot-testing'\n        site = self._makeSite(TITLE)\n        tool = self._makeOne('setup_tool').__of__(site)\n        tool._exclude_global_steps = True\n\n        registry = tool.getImportStepRegistry()\n        registry.registerStep(\n            'dependable', '1', _underscoreSiteTitle, ('purging', ))\n        registry.registerStep(\n            'dependent', '1', _uppercaseSiteTitle, ('dependable', ))\n        registry.registerStep('purging', '1', _purgeIfRequired)\n\n        result = tool.runAllImportStepsFromProfile(PROFILE_ID)\n\n        self.assertEqual(len(result['steps']), 3)\n\n        self.assertEqual(result['steps'][0], 'purging')\n        self.assertEqual(result['messages']['purging'], 'Purged')\n\n        self.assertEqual(result['steps'][1], 'dependable')\n        self.assertEqual(result['messages']['dependable'], 'Underscored title')\n\n        self.assertEqual(result['steps'][2], 'dependent')\n        self.assertEqual(result['messages']['dependent'], 'Uppercased title')\n\n        self.assertEqual(site.title, TITLE.replace(' ', '_').upper())\n        self.assertTrue(site.purged)\n\n        prefix = 'import-all-%s' % PROFILE_ID\n        logged = [x for x in tool.objectIds('File') if x.startswith(prefix)]\n        self.assertEqual(len(logged), 1)\n\n    def check_restricted_access(self, obj):\n        # For most objects that we create, we do not want ordinary users to\n        # see it, also not when they have View permission on a higher level.\n        rop_info = obj.rolesOfPermission(view)\n        allowed_roles = sorted([x['name'] for x in rop_info\n                                if x['selected']])\n        self.assertEqual(allowed_roles, ['Manager', 'Owner'])\n        self.assertFalse(obj.acquiredRolesAreUsedBy(view))\n\n    def test_runAllImportStepsFromProfile_unicode_id_creates_reports(self):\n\n        TITLE = 'original title'\n        PROFILE_ID = u'snapshot-testing'\n        site = self._makeSite(TITLE)\n        tool = self._makeOne('setup_tool').__of__(site)\n\n        registry = tool.getImportStepRegistry()\n        registry.registerStep(\n            'dependable', '1', _underscoreSiteTitle, ('purging', ))\n        registry.registerStep(\n            'dependent', '1', _uppercaseSiteTitle, ('dependable', ))\n        registry.registerStep('purging', '1', _purgeIfRequired)\n\n        tool.runAllImportStepsFromProfile(PROFILE_ID)\n\n        prefix = str('import-all-%s' % PROFILE_ID)\n        logged = [x for x in tool.objectIds('File') if x.startswith(prefix)]\n        self.assertEqual(len(logged), 1)\n\n        # Check acess restriction on log files\n        logged = [x for x in tool.objectIds('File')]\n        for file_id in logged:\n            file_ob = tool._getOb(file_id)\n            self.check_restricted_access(file_ob)\n\n    def test_runAllImportStepsFromProfile_sorted_explicit_purge(self):\n\n        site = self._makeSite()\n        tool = self._makeOne('setup_tool').__of__(site)\n        tool._exclude_global_steps = True\n\n        registry = tool.getImportStepRegistry()\n        registry.registerStep(\n            'dependable', '1', _underscoreSiteTitle, ('purging', ))\n        registry.registerStep(\n            'dependent', '1', _uppercaseSiteTitle, ('dependable', ))\n        registry.registerStep('purging', '1', _purgeIfRequired)\n\n        result = tool.runAllImportStepsFromProfile('snapshot-dummy',\n                                                   purge_old=True)\n\n        self.assertEqual(len(result['steps']), 3)\n\n        self.assertEqual(result['steps'][0], 'purging')\n        self.assertEqual(result['messages']['purging'], 'Purged')\n\n        self.assertEqual(result['steps'][1], 'dependable')\n        self.assertEqual(result['steps'][2], 'dependent')\n        self.assertTrue(site.purged)\n\n    def test_runAllImportStepsFromProfile_sorted_skip_purge(self):\n\n        site = self._makeSite()\n        tool = self._makeOne('setup_tool').__of__(site)\n        tool._exclude_global_steps = True\n\n        registry = tool.getImportStepRegistry()\n        registry.registerStep(\n            'dependable', '1', _underscoreSiteTitle, ('purging', ))\n        registry.registerStep(\n            'dependent', '1', _uppercaseSiteTitle, ('dependable', ))\n        registry.registerStep('purging', '1', _purgeIfRequired)\n\n        result = tool.runAllImportStepsFromProfile('snapshot-dummy',\n                                                   purge_old=False)\n\n        self.assertEqual(len(result['steps']), 3)\n\n        self.assertEqual(result['steps'][0], 'purging')\n        self.assertEqual(result['messages']['purging'], 'Unpurged')\n\n        self.assertEqual(result['steps'][1], 'dependable')\n        self.assertEqual(result['steps'][2], 'dependent')\n        self.assertFalse(site.purged)\n\n    def test_runAllImportStepsFromProfile_without_depends(self):\n        from ..metadata import METADATA_XML\n\n        self._makeFile(METADATA_XML, _METADATA_XML)\n\n        site = self._makeSite()\n        tool = self._makeOne('setup_tool').__of__(site)\n\n        profile_registry.registerProfile('foo', 'Foo', '', self._PROFILE_PATH)\n\n        _imported = []\n\n        def applyContext(context):\n            _imported.append(context._profile_path)\n\n        tool.applyContext = applyContext\n        tool.runAllImportStepsFromProfile('profile-other:foo',\n                                          ignore_dependencies=True)\n        self.assertEqual(_imported, [self._PROFILE_PATH])\n\n    def test_runAllImportStepsFromProfile_with_depends(self):\n        from ..metadata import METADATA_XML\n\n        self._makeFile(METADATA_XML, _METADATA_XML)\n\n        site = self._makeSite()\n        tool = self._makeOne('setup_tool').__of__(site)\n\n        profile_registry.registerProfile('foo', 'Foo', '', self._PROFILE_PATH)\n        profile_registry.registerProfile('bar', 'Bar', '', self._PROFILE_PATH2)\n\n        _imported = []\n\n        def applyContext(context):\n            _imported.append(context._profile_path)\n\n        tool.applyContext = applyContext\n        tool.runAllImportStepsFromProfile('profile-other:foo',\n                                          ignore_dependencies=False)\n        self.assertEqual(_imported, [self._PROFILE_PATH2, self._PROFILE_PATH])\n\n    def _setup_dependency_strategy_test_tool(self):\n        # If we add a dependency profile in our metadata.xml, and this\n        # dependency was already applied, then we do not need to apply\n        # it yet again.  Once is quite enough, thank you.  Running any\n        # upgrade steps would be nice though.  There are options.\n        # Setup a tool and profiles for testing dependency strategies.\n        from ..interfaces import EXTENSION\n        from ..metadata import METADATA_XML\n        self._makeFile(METADATA_XML, _DOUBLE_METADATA_XML)\n        _makeTestFile(METADATA_XML, self._PROFILE_PATH2, _PLAIN_METADATA_XML)\n        _makeTestFile(METADATA_XML, self._PROFILE_PATH3, _PLAIN_METADATA_XML)\n        site = self._makeSite()\n        tool = self._makeOne('setup_tool').__of__(site)\n\n        # Register main profile and two dependency profiles.\n        profile_registry.registerProfile('foo', 'Foo', '', self._PROFILE_PATH,\n                                         profile_type=EXTENSION)\n        profile_registry.registerProfile('bar', 'Bar', '', self._PROFILE_PATH2,\n                                         profile_type=EXTENSION)\n        profile_registry.registerProfile('ham', 'Ham', '', self._PROFILE_PATH3,\n                                         profile_type=EXTENSION)\n\n        # Apply the second profile.\n        tool.runAllImportStepsFromProfile('profile-other:bar')\n\n        # Register an upgrade step.  Note that applying this step will\n        # set the profile version to 1.1, even though the metadata of\n        # the profile really says 1.0.  We will use this to check\n        # whether the upgrade step has been applied (version is 1.1)\n        # or the full profile has been applied (version is 1.0).\n        step_bar = UpgradeStep(\n            \"Upgrade\", \"other:bar\", '1.0', '1.1', '', dummy_upgrade, None, \"1\")\n        _registerUpgradeStep(step_bar)\n        # And another one.\n        step_ham = UpgradeStep(\n            \"Upgrade\", \"other:ham\", '1.0', '1.1', '', dummy_upgrade, None, \"1\")\n        _registerUpgradeStep(step_ham)\n\n        # Gather list of imported profiles.\n        tool._imported = []\n\n        def applyContext(context):\n            tool._imported.append(context._profile_path)\n\n        tool.applyContext = applyContext\n\n        return tool\n\n    def test_runAllImportStepsFromProfile_with_default_strategy(self):\n        # Default strategy: apply new profiles, upgrade old profiles.\n        tool = self._setup_dependency_strategy_test_tool()\n\n        # Run the main profile.\n        tool.runAllImportStepsFromProfile('profile-other:foo')\n        # The main and third profile have been applied.\n        self.assertEqual(tool._imported,\n                         [self._PROFILE_PATH3, self._PROFILE_PATH])\n        # The upgrade step of the second profile has been applied,\n        # pushing it to version 1.1.\n        self.assertEqual(tool.getLastVersionForProfile('other:bar'),\n                         ('1', '1'))\n        # Third profile is at 1.0.\n        self.assertEqual(tool.getLastVersionForProfile('other:ham'),\n                         ('1', '0'))\n\n    def test_runAllImportStepsFromProfile_with_reapply_strategy(self):\n        # You can choose the old behavior of always applying the\n        # dependencies.  This ignores any upgrade steps.\n        tool = self._setup_dependency_strategy_test_tool()\n\n        # Run the main profile.\n        from ..tool import DEPENDENCY_STRATEGY_REAPPLY\n        tool.runAllImportStepsFromProfile(\n            'profile-other:foo',\n            dependency_strategy=DEPENDENCY_STRATEGY_REAPPLY)\n        # All three profiles have been applied.\n        self.assertEqual(tool._imported,\n                         [self._PROFILE_PATH2, self._PROFILE_PATH3,\n                          self._PROFILE_PATH])\n        self.assertEqual(tool.getLastVersionForProfile('other:bar'),\n                         ('1', '0'))\n        self.assertEqual(tool.getLastVersionForProfile('other:ham'),\n                         ('1', '0'))\n\n    def test_runAllImportStepsFromProfile_with_new_strategy(self):\n        # You can choose to be happy with any applied version and\n        # ignore any upgrade steps.\n        tool = self._setup_dependency_strategy_test_tool()\n\n        # Run the main profile.\n        from ..tool import DEPENDENCY_STRATEGY_NEW\n        tool.runAllImportStepsFromProfile(\n            'profile-other:foo',\n            dependency_strategy=DEPENDENCY_STRATEGY_NEW)\n        # The main and third profile have been applied.\n        self.assertEqual(tool._imported,\n                         [self._PROFILE_PATH3, self._PROFILE_PATH])\n        # Second profile stays at 1.0.\n        self.assertEqual(tool.getLastVersionForProfile('other:bar'),\n                         ('1', '0'))\n        self.assertEqual(tool.getLastVersionForProfile('other:ham'),\n                         ('1', '0'))\n\n    def test_runAllImportStepsFromProfile_with_ignore_strategy(self):\n        # You can choose to be ignore all dependency profiles.\n        tool = self._setup_dependency_strategy_test_tool()\n\n        # Run the main profile.\n        from ..tool import DEPENDENCY_STRATEGY_IGNORE\n        tool.runAllImportStepsFromProfile(\n            'profile-other:foo',\n            dependency_strategy=DEPENDENCY_STRATEGY_IGNORE)\n        # Only the main profile has been applied.\n        self.assertEqual(tool._imported,\n                         [self._PROFILE_PATH])\n        # Second profile stays at 1.0.\n        self.assertEqual(tool.getLastVersionForProfile('other:bar'),\n                         ('1', '0'))\n        # Third profile is not applied.\n        self.assertEqual(tool.getLastVersionForProfile('other:ham'),\n                         ('unknown'))\n\n    def test_runAllImportStepsFromProfile_unknown_strategy(self):\n        site = self._makeSite()\n        tool = self._makeOne('setup_tool').__of__(site)\n        profile_registry.registerProfile('foo', 'Foo', '', self._PROFILE_PATH)\n        self.assertRaises(ValueError, tool.runAllImportStepsFromProfile,\n                          'profile-other:foo', dependency_strategy='random')\n\n    def test_runAllImportStepsFromProfile_set_last_profile_version(self):\n        from ..metadata import METADATA_XML\n\n        self._makeFile(METADATA_XML, _METADATA_XML)\n\n        site = self._makeSite()\n        tool = self._makeOne('setup_tool').__of__(site)\n\n        profile_registry.registerProfile('foo', 'Foo', '', self._PROFILE_PATH)\n\n        # test initial states\n        profile_id = \"other:foo\"\n        self.assertEqual(tool.getVersionForProfile(profile_id), '1.0')\n        self.assertEqual(tool.getLastVersionForProfile(profile_id),\n                         'unknown')\n\n        # run all imports steps\n        tool.runAllImportStepsFromProfile('profile-other:foo',\n                                          ignore_dependencies=True)\n\n        # events.handleProfileImportedEvent should set last profile version\n        self.assertEqual(tool.getLastVersionForProfile(profile_id),\n                         ('1', '0'))\n\n    def test_runAllImportStepsFromProfile_step_registration_with_depends(self):\n        from ..metadata import METADATA_XML\n\n        self._makeFile(METADATA_XML, _METADATA_XML)\n\n        _IMPORT_STEPS_XML = \"\"\"<?xml version=\"1.0\"?>\n<import-steps>\n <import-step id=\"one\"\n             version=\"1\"\n             handler=\"Products.GenericSetup.tests.common.dummy_handler\"\n             title=\"One Step\">\n  One small step\n </import-step>\n</import-steps>\n\"\"\"\n        self._makeFile('import_steps.xml', _IMPORT_STEPS_XML)\n\n        site = self._makeSite()\n        tool = self._makeOne('setup_tool').__of__(site)\n\n        profile_registry.registerProfile('foo', 'Foo', '', self._PROFILE_PATH)\n        profile_registry.registerProfile('bar', 'Bar', '', self._PROFILE_PATH2)\n\n        result = tool.runAllImportStepsFromProfile('profile-other:foo',\n                                                   ignore_dependencies=False)\n\n        # ensure the additional step on foo was imported\n        self.assertTrue('one' in result['steps'])\n\n    def test_runAllImportStepsFromProfile_skipStep(self):\n\n        site = self._makeSite()\n        tool = self._makeOne('setup_tool').__of__(site)\n        result = tool.runAllImportStepsFromProfile(\n            'snapshot-dummy',\n            blacklisted_steps=['toolset'],\n        )\n\n        self.assertEqual((result['messages']['toolset']), 'step skipped')\n\n    def test_runAllImportStepsFromProfile_with_base_profile(self):\n        # Applying a base profile should clear the profile upgrade\n        # versions.\n        from ..interfaces import BASE\n        from ..interfaces import EXTENSION\n        from ..metadata import METADATA_XML\n        site = self._makeSite()\n        site.setup_tool = self._makeOne('setup_tool')\n        tool = site.setup_tool\n        self._makeFile(METADATA_XML, _METADATA_XML)\n        _makeTestFile(METADATA_XML, self._PROFILE_PATH2, _PLAIN_METADATA_XML)\n        _makeTestFile(METADATA_XML, self._PROFILE_PATH3, _PLAIN_METADATA_XML)\n\n        # Register a base and two extension profile.  The base profile\n        # 'foo' has a dependency 'bar'.  This might not make sense,\n        # but it will serve to check that we clear the profile\n        # versions right before we apply the base profile, which means\n        # right after any dependency profiles.\n        profile_registry.registerProfile(\n            'foo', 'Foo', '', self._PROFILE_PATH, profile_type=BASE)\n        profile_registry.registerProfile(\n            'bar', 'Bar', '', self._PROFILE_PATH2, profile_type=EXTENSION)\n        profile_registry.registerProfile(\n            'ham', 'Ham', '', self._PROFILE_PATH3, profile_type=EXTENSION)\n        # Apply the extension profile.\n        tool.runAllImportStepsFromProfile('profile-other:ham')\n        self.assertEqual(tool._profile_upgrade_versions,\n                         {u'other:ham': (u'1', u'0')})\n        # Apply the base profile.\n        tool.runAllImportStepsFromProfile('profile-other:foo')\n        self.assertEqual(tool._profile_upgrade_versions,\n                         {u'other:foo': (u'1', u'0')})\n\n    def test_runAllImportStepsFromProfile_with_unknown_pre_handler(self):\n        # Registering already fails.\n        self.assertRaises(\n            ValueError, profile_registry.registerProfile,\n            'foo', 'Foo', '', self._PROFILE_PATH,\n            pre_handler='Products.GenericSetup.tests.test_tool.foo_handler')\n\n    def test_runAllImportStepsFromProfile_with_unknown_post_handler(self):\n        # Registering already fails.\n        self.assertRaises(\n            ValueError, profile_registry.registerProfile,\n            'foo', 'Foo', '', self._PROFILE_PATH,\n            post_handler='Products.GenericSetup.tests.test_tool.foo_handler')\n\n    def test_runAllImportStepsFromProfile_pre_post_handlers_dotted_names(self):\n        site = self._makeSite()\n        tool = self._makeOne('setup_tool').__of__(site)\n        profile_registry.registerProfile(\n            'foo', 'Foo', '', self._PROFILE_PATH,\n            pre_handler='Products.GenericSetup.tests.test_tool.pre_handler',\n            post_handler='Products.GenericSetup.tests.test_tool.post_handler')\n        tool.runAllImportStepsFromProfile('profile-other:foo')\n        self.assertEqual(tool.pre_handler_called, 1)\n        self.assertEqual(tool.post_handler_called, 1)\n        tool.runAllImportStepsFromProfile('profile-other:foo')\n        self.assertEqual(tool.pre_handler_called, 2)\n        self.assertEqual(tool.post_handler_called, 2)\n\n    def test_runAllImportStepsFromProfile_pre_post_handlers_functions(self):\n        # When you register a profile with pre/post handlers in zcml, you do\n        # not get dotted names (strings) but an actual function.\n        site = self._makeSite()\n        tool = self._makeOne('setup_tool').__of__(site)\n        profile_registry.registerProfile(\n            'foo', 'Foo', '', self._PROFILE_PATH,\n            pre_handler=pre_handler,\n            post_handler=post_handler)\n        tool.runAllImportStepsFromProfile('profile-other:foo')\n        self.assertEqual(tool.pre_handler_called, 1)\n        self.assertEqual(tool.post_handler_called, 1)\n        tool.runAllImportStepsFromProfile('profile-other:foo')\n        self.assertEqual(tool.pre_handler_called, 2)\n        self.assertEqual(tool.post_handler_called, 2)\n\n    def test_runExportStep_nonesuch(self):\n        site = self._makeSite()\n        tool = self._makeOne('setup_tool').__of__(site)\n\n        self.assertRaises(ValueError, tool.runExportStep, 'nonesuch')\n\n    def test_runExportStep_step_registry_empty(self):\n        site = self._makeSite()\n        site.setup_tool = self._makeOne('setup_tool')\n        tool = site.setup_tool\n\n        result = tool.runExportStep('step_registries')\n\n        self.assertEqual(len(result['steps']), 1)\n        self.assertEqual(result['steps'][0], 'step_registries')\n        self.assertEqual(result['messages']['step_registries'], None)\n\n    def test_runExportStep_step_registry_default(self):\n        site = self._makeSite()\n        site.setup_tool = self._makeOne('setup_tool')\n        tool = site.setup_tool\n        tool._import_registry.registerStep('foo', handler='foo.bar')\n        steps = 'Products.GenericSetup.tool.exportStepRegistries'\n        tool._export_registry.registerStep('step_registries', steps,\n                                           'Export import / export steps.')\n\n        result = tool.runExportStep('step_registries')\n\n        self.assertEqual(len(result['steps']), 1)\n        self.assertEqual(result['steps'][0], 'step_registries')\n        self.assertEqual(result['messages']['step_registries'], None)\n        fileish = BytesIO(result['tarball'])\n\n        self._verifyTarballContents(fileish,\n                                    ['import_steps.xml', 'export_steps.xml'])\n        self._verifyTarballEntryXML(\n            fileish, 'import_steps.xml', _DEFAULT_STEP_REGISTRIES_IMPORT_XML)\n        self._verifyTarballEntryXML(\n            fileish, 'export_steps.xml', _DEFAULT_STEP_REGISTRIES_EXPORT_XML)\n\n    def test_runAllExportSteps_empty(self):\n        site = self._makeSite()\n        site.setup_tool = self._makeOne('setup_tool')\n        tool = site.setup_tool\n\n        result = tool.runAllExportSteps()\n\n        self.assertEqual(\n            sorted(result['steps']),\n            ['componentregistry', 'rolemap', 'step_registries', 'toolset'])\n        self.assertEqual(result['messages']['step_registries'], None)\n\n    def test_runAllExportSteps_default(self):\n        site = self._makeSite()\n        site.setup_tool = self._makeOne('setup_tool')\n        tool = site.setup_tool\n        tool._import_registry.registerStep('foo', handler='foo.bar')\n        steps = 'Products.GenericSetup.tool.exportStepRegistries'\n        tool._export_registry.registerStep('step_registries', steps,\n                                           'Export import / export steps.')\n\n        result = tool.runAllExportSteps()\n\n        self.assertEqual(sorted(result['steps']),\n                         ['componentregistry', 'rolemap',\n                          'step_registries', 'toolset'])\n        self.assertEqual(result['messages']['step_registries'], None)\n        fileish = BytesIO(result['tarball'])\n\n        self._verifyTarballContents(fileish,\n                                    ['import_steps.xml', 'export_steps.xml',\n                                     'rolemap.xml', 'toolset.xml'])\n        self._verifyTarballEntryXML(\n            fileish, 'import_steps.xml', _DEFAULT_STEP_REGISTRIES_IMPORT_XML)\n        self._verifyTarballEntryXML(\n            fileish, 'export_steps.xml', _DEFAULT_STEP_REGISTRIES_EXPORT_XML)\n\n    def test_runAllExportSteps_extras(self):\n        site = self._makeSite()\n        site.setup_tool = self._makeOne('setup_tool')\n        tool = site.setup_tool\n        steps = 'Products.GenericSetup.tool.exportStepRegistries'\n        tool._export_registry.registerStep('step_registries', steps,\n                                           'Export import / export steps.')\n\n        import_reg = tool.getImportStepRegistry()\n        import_reg.registerStep(\n            'dependable', '1', _underscoreSiteTitle, ('purging', ))\n        import_reg.registerStep(\n            'dependent', '1', _uppercaseSiteTitle, ('dependable', ))\n        import_reg.registerStep('purging', '1', _purgeIfRequired)\n\n        export_reg = tool.getExportStepRegistry()\n        export_reg.registerStep('properties', _exportPropertiesINI)\n\n        result = tool.runAllExportSteps()\n\n        self.assertEqual(len(result['steps']), 5)\n        self.assertEqual(sorted(result['steps']),\n                         ['componentregistry', 'properties', 'rolemap',\n                          'step_registries', 'toolset'])\n\n        self.assertEqual(result['messages']['properties'],\n                         'Exported properties')\n        self.assertEqual(result['messages']['step_registries'], None)\n\n        fileish = BytesIO(result['tarball'])\n\n        self._verifyTarballContents(fileish,\n                                    ['import_steps.xml', 'export_steps.xml',\n                                     'properties.ini', 'rolemap.xml',\n                                     'toolset.xml'])\n        self._verifyTarballEntryXML(\n            fileish, 'import_steps.xml', _EXTRAS_STEP_REGISTRIES_IMPORT_XML)\n        self._verifyTarballEntryXML(\n            fileish, 'export_steps.xml', _EXTRAS_STEP_REGISTRIES_EXPORT_XML)\n        ini_string = _PROPERTIES_INI % site.title\n        self._verifyTarballEntry(fileish, 'properties.ini',\n                                 ini_string.encode('utf-8'))\n\n    def test_manage_importTarball(self):\n        # Tests for importing a tarball with GenericSetup files.\n        # We are especially interested to see if old settings get purged.\n        site = self._makeSite()\n        site.setup_tool = self._makeOne('setup_tool')\n        tool = site.setup_tool\n        # We need to be Manager to see the result of calling\n        # manage_importTarball.\n        newSecurityManager(None, UnrestrictedUser('root', '', ['Manager'], ''))\n\n        ROLEMAP_XML = \"\"\"<?xml version=\"1.0\"?>\n<rolemap>\n  <roles>\n    <role name=\"%s\" />\n  </roles>\n  <permissions />\n</rolemap>\n\"\"\"\n\n        def rolemap_tarball(name):\n            # Create a tarball archive with rolemap.xml containing 'name' as\n            # role.\n            context = TarballExportContext(tool)\n            contents = ROLEMAP_XML % name\n            if isinstance(contents, six.text_type):\n                contents = contents.encode('utf-8')\n            context.writeDataFile('rolemap.xml', contents, 'text/xml')\n            return context.getArchive()\n\n        # Import first role.\n        tool.manage_importTarball(rolemap_tarball('First'))\n        self.assertTrue('First' in site.valid_roles())\n\n        # Import second role.\n        tool.manage_importTarball(rolemap_tarball('Second'))\n        self.assertTrue('Second' in site.valid_roles())\n        # The first role has been purged, because that is the default.\n        self.assertFalse('First' in site.valid_roles())\n        # A few standard roles are never removed, probably because they are\n        # defined one level higher.\n        self.assertTrue('Anonymous' in site.valid_roles())\n        self.assertTrue('Authenticated' in site.valid_roles())\n        self.assertTrue('Manager' in site.valid_roles())\n        self.assertTrue('Owner' in site.valid_roles())\n\n        # Import third role in non-purge mode.\n        tool.manage_importTarball(rolemap_tarball('Third'), purge_old=False)\n        self.assertTrue('Third' in site.valid_roles())\n        # The second role is still there.\n        self.assertTrue('Second' in site.valid_roles())\n\n        # When you use the form, and uncheck the purge_old checkbox, then the\n        # browser does not send the purge_old parameter in the request.  To\n        # work around this, the form always passes a hidden 'submitted'\n        # parameter.\n        # Import fourth role in non-purge mode with a form submit.\n        tool.manage_importTarball(rolemap_tarball('Fourth'), submitted='yes')\n        self.assertTrue('Fourth' in site.valid_roles())\n        # The other roles are still there.\n        self.assertTrue('Second' in site.valid_roles())\n        self.assertTrue('Third' in site.valid_roles())\n        self.assertTrue('Manager' in site.valid_roles())\n\n    def test_createSnapshot_default(self):\n        _EXPECTED = [\n            ('import_steps.xml', _DEFAULT_STEP_REGISTRIES_IMPORT_XML),\n            ('export_steps.xml', _DEFAULT_STEP_REGISTRIES_EXPORT_XML),\n            ('rolemap.xml', 'dummy'),\n            ('toolset.xml', 'dummy'),\n        ]\n\n        site = self._makeSite()\n        site.setup_tool = self._makeOne('setup_tool')\n        tool = site.setup_tool\n        tool._import_registry.registerStep('foo', handler='foo.bar')\n        tool._export_registry.registerStep(\n            'step_registries',\n            'Products.GenericSetup.tool.exportStepRegistries',\n            'Export import / export steps.')\n\n        self.assertEqual(len(tool.listSnapshotInfo()), 0)\n\n        result = tool.createSnapshot('default')\n\n        self.assertEqual(\n            sorted(result['steps']),\n            ['componentregistry', 'rolemap', 'step_registries', 'toolset'])\n        self.assertEqual(result['messages']['step_registries'], None)\n\n        snapshot = result['snapshot']\n\n        self.assertEqual(len(snapshot.objectIds()), len(_EXPECTED))\n\n        for id in [x[0] for x in _EXPECTED]:\n            self.assertTrue(id in snapshot.objectIds())\n\n        def normalize_xml(xml):\n            # using this might mask a real problem on windows, but so far the\n            # different newlines just caused problems in this test\n            lines = [line.strip() for line in xml.splitlines() if line.strip()]\n            return ' '.join(lines)\n\n        fileobj = snapshot._getOb('import_steps.xml')\n        self.assertEqual(normalize_xml(fileobj.read()),\n                         normalize_xml(_DEFAULT_STEP_REGISTRIES_IMPORT_XML))\n\n        fileobj = snapshot._getOb('export_steps.xml')\n        self.assertEqual(normalize_xml(fileobj.read()),\n                         normalize_xml(_DEFAULT_STEP_REGISTRIES_EXPORT_XML))\n\n        self.assertEqual(len(tool.listSnapshotInfo()), 1)\n\n        info = tool.listSnapshotInfo()[0]\n\n        self.assertEqual(info['id'], 'default')\n        self.assertEqual(info['title'], 'default')\n\n        # Check access restriction on snapshot files and folders\n        self.check_restricted_access(tool.snapshots)\n        self.check_restricted_access(snapshot)\n        for obj in snapshot.objectValues():\n            self.check_restricted_access(obj)\n            if hasattr(aq_base(obj), 'objectValues'):\n                for child in obj.objectValues():\n                    self.check_restricted_access(child)\n\n    def test_applyContext(self):\n        from ..tool import EXPORT_STEPS_XML\n        from ..tool import IMPORT_STEPS_XML\n        from ..tool import TOOLSET_XML\n\n        site = self._makeSite()\n        tool = self._makeOne('setup_tool').__of__(site)\n        tool.getImportStepRegistry().clear()\n        tool.getExportStepRegistry().clear()\n        tool.getToolsetRegistry().clear()\n\n        context = DummyImportContext(site, tool=tool)\n        context._files[IMPORT_STEPS_XML] = _SINGLE_IMPORT_XML\n        context._files[EXPORT_STEPS_XML] = _SINGLE_EXPORT_XML\n        context._files[TOOLSET_XML] = _NORMAL_TOOLSET_XML\n\n        tool.applyContext(context)\n\n        import_registry = tool.getImportStepRegistry()\n        self.assertEqual(len(import_registry.listSteps()), 1)\n        self.assertTrue('one' in import_registry.listSteps())\n        info = import_registry.getStepMetadata('one')\n\n        self.assertEqual(info['id'], 'one')\n        self.assertEqual(info['title'], 'One Step')\n        self.assertEqual(info['version'], '1')\n        self.assertTrue('One small step' in info['description'])\n        self.assertEqual(info['handler'],\n                         'Products.GenericSetup.tests.test_registry.ONE_FUNC')\n\n        self.assertEqual(import_registry.getStep('one'), ONE_FUNC)\n\n        export_registry = tool.getExportStepRegistry()\n        self.assertEqual(len(export_registry.listSteps()), 1)\n        self.assertTrue('one' in import_registry.listSteps())\n        info = export_registry.getStepMetadata('one')\n        self.assertEqual(info['id'], 'one')\n        self.assertEqual(info['title'], 'One Step')\n        self.assertTrue('One small step' in info['description'])\n        self.assertEqual(info['handler'],\n                         'Products.GenericSetup.tests.test_registry.ONE_FUNC')\n\n        self.assertEqual(export_registry.getStep('one'), ONE_FUNC)\n\n    def test_listContextInfos_empty(self):\n        site = self._makeSite()\n        site.setup_tool = self._makeOne('setup_tool')\n        tool = site.setup_tool\n        infos = tool.listContextInfos()\n        self.assertEqual(len(infos), 0)\n\n    def test_listContextInfos_with_snapshot(self):\n        site = self._makeSite()\n        site.setup_tool = self._makeOne('setup_tool')\n        tool = site.setup_tool\n        tool.createSnapshot('testing')\n        infos = tool.listContextInfos()\n        self.assertEqual(len(infos), 1)\n        info = infos[0]\n        self.assertEqual(info['id'], 'snapshot-testing')\n        self.assertEqual(info['title'], 'testing')\n        self.assertEqual(info['type'], 'snapshot')\n\n    def test_listContextInfos_with_registered_base_profile(self):\n        from ..interfaces import BASE\n\n        profile_registry.registerProfile('foo', 'Foo', '', self._PROFILE_PATH,\n                                         'Foo', BASE)\n        site = self._makeSite()\n        site.setup_tool = self._makeOne('setup_tool')\n        tool = site.setup_tool\n        infos = tool.listContextInfos()\n        self.assertEqual(len(infos), 1)\n        info = infos[0]\n        self.assertEqual(info['id'], 'profile-Foo:foo')\n        self.assertEqual(info['title'], 'Foo')\n        self.assertEqual(info['type'], 'base')\n\n    def test_listContextInfos_with_registered_extension_profile(self):\n        from ..interfaces import EXTENSION\n\n        profile_registry.registerProfile('foo', 'Foo', '', self._PROFILE_PATH,\n                                         'Foo', EXTENSION)\n        site = self._makeSite()\n        site.setup_tool = self._makeOne('setup_tool')\n        tool = site.setup_tool\n        infos = tool.listContextInfos()\n        self.assertEqual(len(infos), 1)\n        info = infos[0]\n        self.assertEqual(info['id'], 'profile-Foo:foo')\n        self.assertEqual(info['title'], 'Foo')\n        self.assertEqual(info['type'], 'extension')\n\n    def test_listContextInfos_with_ordering(self):\n        from ..interfaces import BASE\n        from ..interfaces import EXTENSION\n\n        # three extension profiles\n        profile_registry.registerProfile(\n            'bar', 'bar', '', self._PROFILE_PATH, 'bar', EXTENSION)\n        profile_registry.registerProfile(\n            'foo', 'foo', '', self._PROFILE_PATH, 'foo', EXTENSION)\n        profile_registry.registerProfile(\n            'upper', 'UPPER', '', self._PROFILE_PATH, 'UPPER', EXTENSION)\n        # one base profile\n        profile_registry.registerProfile(\n            'base', 'base', '', self._PROFILE_PATH, 'base', BASE)\n\n        site = self._makeSite()\n        site.setup_tool = self._makeOne('setup_tool')\n        tool = site.setup_tool\n        tool.createSnapshot('UPPER')\n        tool.createSnapshot('lower')\n        infos = tool.listContextInfos()\n        self.assertEqual(len(infos), 6)\n        # We sort case insensitively, so by lowercase.\n        # First snapshots.\n        self.assertEqual(infos[0]['id'], 'snapshot-lower')\n        self.assertEqual(infos[1]['id'], 'snapshot-UPPER')\n        # Then base and extension profiles\n        self.assertEqual(infos[2]['id'], 'profile-bar:bar')\n        self.assertEqual(infos[3]['id'], 'profile-base:base')\n        self.assertEqual(infos[4]['id'], 'profile-foo:foo')\n        self.assertEqual(infos[5]['id'], 'profile-UPPER:upper')\n\n    def test_getProfileImportDate_nonesuch(self):\n        site = self._makeSite()\n        site.setup_tool = self._makeOne('setup_tool')\n        tool = site.setup_tool\n        self.assertEqual(tool.getProfileImportDate('nonesuch'), None)\n\n    def test_getProfileImportDate_simple_id(self):\n        from OFS.Image import File\n\n        site = self._makeSite()\n        site.setup_tool = self._makeOne('setup_tool')\n        tool = site.setup_tool\n        filename = 'import-all-foo-20070315123456.log'\n        tool._setObject(filename, File(filename, '', b''))\n        self.assertEqual(tool.getProfileImportDate('foo'),\n                         '2007-03-15T12:34:56Z')\n\n    def test_getProfileImportDate_id_with_colon(self):\n        from OFS.Image import File\n\n        site = self._makeSite()\n        site.setup_tool = self._makeOne('setup_tool')\n        tool = site.setup_tool\n        filename = 'import-all-foo_bar-20070315123456.log'\n        tool._setObject(filename, File(filename, '', b''))\n        self.assertEqual(tool.getProfileImportDate('foo:bar'),\n                         '2007-03-15T12:34:56Z')\n\n    def test_getProfileImportDate_id_with_prefix(self):\n        # Test if getProfileImportDate does not fail if there is another\n        # item id with id with a longer id which starts with the same\n        # prefix\n        from OFS.Image import File\n\n        site = self._makeSite()\n        site.setup_tool = self._makeOne('setup_tool')\n        tool = site.setup_tool\n        filename = 'import-all-foo_bar-20070315123456.log'\n        tool._setObject(filename, File(filename, '', b''))\n        filename2 = 'import-all-foo_bar-boo-20070315123456.log'\n        tool._setObject(filename2, File(filename2, '', b''))\n        self.assertEqual(tool.getProfileImportDate('foo:bar'),\n                         '2007-03-15T12:34:56Z')\n\n    def test_profileVersioning(self):\n        site = self._makeSite()\n        site.setup_tool = self._makeOne('setup_tool')\n        tool = site.setup_tool\n        profile_id = 'dummy_profile'\n        product_name = 'GenericSetup'\n        directory = os.path.split(__file__)[0]\n        path = os.path.join(directory, 'versioned_profile')\n\n        # register profile\n        profile_registry.registerProfile(profile_id,\n                                         'Dummy Profile',\n                                         'This is a dummy profile',\n                                         path,\n                                         product=product_name)\n\n        # register upgrade step\n        step = UpgradeStep(\"Upgrade\",\n                           \"GenericSetup:dummy_profile\", '*', '1.1', '',\n                           dummy_upgrade,\n                           None, \"1\")\n        _registerUpgradeStep(step)\n\n        # test initial states\n        profile_id = ':'.join((product_name, profile_id))\n        self.assertEqual(tool.getVersionForProfile(profile_id), '1.1')\n        self.assertEqual(tool.getLastVersionForProfile(profile_id),\n                         'unknown')\n\n        # run upgrade steps\n        request = site.REQUEST\n        request.form['profile_id'] = profile_id\n        steps = listUpgradeSteps(tool, profile_id, '1.0')\n        step_id = steps[0]['id']\n        request.form['upgrades'] = [step_id]\n        tool.manage_doUpgrades()\n        self.assertEqual(tool.getLastVersionForProfile(profile_id),\n                         ('1', '1'))\n\n    def test_get_and_setLastVersionForProfile(self):\n        site = self._makeSite()\n        site.setup_tool = self._makeOne('setup_tool')\n        tool = site.setup_tool\n        self.assertEqual(tool._profile_upgrade_versions, {})\n        # Any 'profile-' is stripped off in these calls.\n        self.assertEqual(tool.getLastVersionForProfile('foo'), 'unknown')\n        self.assertEqual(tool.getLastVersionForProfile(\n            'profile-foo'), 'unknown')\n        tool.setLastVersionForProfile('foo', '1.0')\n        self.assertEqual(tool.getLastVersionForProfile('foo'), ('1', '0'))\n        self.assertEqual(tool.getLastVersionForProfile(\n            'profile-foo'), ('1', '0'))\n        tool.setLastVersionForProfile('profile-foo', '2.0')\n        self.assertEqual(tool.getLastVersionForProfile('foo'), ('2', '0'))\n        self.assertEqual(tool.getLastVersionForProfile(\n            'profile-foo'), ('2', '0'))\n\n        # Setting the profile to unknown, removes it from the versions.\n        self.assertEqual(tool._profile_upgrade_versions, {'foo': ('2', '0')})\n        tool.setLastVersionForProfile('profile-foo', 'unknown')\n        self.assertEqual(tool._profile_upgrade_versions, {})\n\n    def test_unsetLastVersionForProfile(self):\n        site = self._makeSite()\n        site.setup_tool = self._makeOne('setup_tool')\n        tool = site.setup_tool\n        tool.setLastVersionForProfile('foo', '1.0')\n        tool.setLastVersionForProfile('bar', '2.0')\n        self.assertEqual(tool._profile_upgrade_versions,\n                         {'foo': ('1', '0'), 'bar': ('2', '0')})\n\n        # Any 'profile-' is stripped off in these calls.\n        tool.unsetLastVersionForProfile('profile-foo')\n        self.assertEqual(tool._profile_upgrade_versions,\n                         {'bar': ('2', '0')})\n        tool.unsetLastVersionForProfile('bar')\n        self.assertEqual(tool._profile_upgrade_versions, {})\n\n    def test_purgeProfileVersions(self):\n        site = self._makeSite()\n        site.setup_tool = self._makeOne('setup_tool')\n        tool = site.setup_tool\n        tool.setLastVersionForProfile('foo', '1.0')\n        tool.setLastVersionForProfile('bar', '2.0')\n        self.assertEqual(tool._profile_upgrade_versions,\n                         {'foo': ('1', '0'), 'bar': ('2', '0')})\n        tool.purgeProfileVersions()\n        self.assertEqual(tool._profile_upgrade_versions, {})\n\n    def test_listProfilesWithUpgrades(self):\n        site = self._makeSite()\n        site.setup_tool = self._makeOne('setup_tool')\n        tool = site.setup_tool\n        self.assertEqual(tool.listProfilesWithUpgrades(), [])\n        self.assertEqual(tool.listProfilesWithPendingUpgrades(), [])\n        self.assertEqual(tool.listUptodateProfiles(), [])\n        self.assertEqual(tool.hasPendingUpgrades(), False)\n        profile_id = 'dummy_profile'\n        product_name = 'GenericSetup'\n        directory = os.path.split(__file__)[0]\n        path = os.path.join(directory, 'versioned_profile')\n\n        # register profile\n        profile_registry.registerProfile(profile_id,\n                                         'Dummy Profile',\n                                         'This is a dummy profile',\n                                         path,\n                                         product=product_name)\n        self.assertEqual(tool.listProfilesWithUpgrades(), [])\n        self.assertEqual(tool.listProfilesWithPendingUpgrades(), [])\n        self.assertEqual(tool.listUptodateProfiles(), [])\n        self.assertEqual(tool.hasPendingUpgrades(), False)\n\n        # register upgrade step\n        step1 = UpgradeStep(\"Upgrade 1\",\n                            \"GenericSetup:dummy_profile\", '*', '1.1', '',\n                            dummy_upgrade,\n                            None, \"1\")\n        _registerUpgradeStep(step1)\n        self.assertEqual(tool.listProfilesWithUpgrades(),\n                         [u'GenericSetup:dummy_profile'])\n        self.assertEqual(tool.listProfilesWithPendingUpgrades(), [])\n        self.assertEqual(tool.listUptodateProfiles(), [])\n        self.assertEqual(tool.hasPendingUpgrades(), False)\n\n        # register another upgrade step\n        step2 = UpgradeStep(\"Upgrade 2\",\n                            \"GenericSetup:dummy_profile\", '1.1', '1.2', '',\n                            dummy_upgrade,\n                            None, \"1\")\n        _registerUpgradeStep(step2)\n        self.assertEqual(tool.listProfilesWithUpgrades(),\n                         [u'GenericSetup:dummy_profile'])\n        self.assertEqual(tool.listProfilesWithPendingUpgrades(), [])\n        self.assertEqual(tool.listUptodateProfiles(), [])\n        self.assertEqual(tool.hasPendingUpgrades(), False)\n\n        # get full profile id\n        profile_id = ':'.join((product_name, profile_id))\n\n        # Pretend the profile was installed\n        tool.setLastVersionForProfile(profile_id, '1.0')\n        self.assertEqual(tool.listProfilesWithUpgrades(),\n                         [u'GenericSetup:dummy_profile'])\n        self.assertEqual(tool.listProfilesWithPendingUpgrades(),\n                         [u'GenericSetup:dummy_profile'])\n        self.assertEqual(tool.listUptodateProfiles(), [])\n        self.assertEqual(tool.hasPendingUpgrades(), True)\n\n        # run first upgrade step\n        request = site.REQUEST\n        request.form['profile_id'] = profile_id\n        steps = listUpgradeSteps(tool, profile_id, '1.0')\n        step_id = steps[0]['id']\n        request.form['upgrades'] = [step_id]\n        tool.manage_doUpgrades()\n        self.assertEqual(tool.getLastVersionForProfile(profile_id),\n                         ('1', '1'))\n        self.assertEqual(tool.listProfilesWithUpgrades(),\n                         [u'GenericSetup:dummy_profile'])\n        self.assertEqual(tool.listProfilesWithPendingUpgrades(),\n                         [u'GenericSetup:dummy_profile'])\n        self.assertEqual(tool.listUptodateProfiles(), [])\n        self.assertEqual(tool.hasPendingUpgrades(), True)\n\n        # run second upgrade step\n        request = site.REQUEST\n        request.form['profile_id'] = profile_id\n        steps = listUpgradeSteps(tool, profile_id, '1.1')\n        step_id = steps[0]['id']\n        request.form['upgrades'] = [step_id]\n        tool.manage_doUpgrades()\n        self.assertEqual(tool.getLastVersionForProfile(profile_id),\n                         ('1', '2'))\n        self.assertEqual(tool.listProfilesWithUpgrades(),\n                         [u'GenericSetup:dummy_profile'])\n        self.assertEqual(tool.listProfilesWithPendingUpgrades(), [])\n        self.assertEqual(tool.listUptodateProfiles(),\n                         [u'GenericSetup:dummy_profile'])\n        self.assertEqual(tool.hasPendingUpgrades(), False)\n\n        # Pretend the profile was never installed.\n        tool.unsetLastVersionForProfile(profile_id)\n        self.assertEqual(tool.listProfilesWithPendingUpgrades(), [])\n        self.assertEqual(tool.listUptodateProfiles(), [])\n        self.assertEqual(tool.hasPendingUpgrades(), False)\n\n    def test_hasPendingUpgrades(self):\n        site = self._makeSite()\n        site.setup_tool = self._makeOne('setup_tool')\n        tool = site.setup_tool\n        profile_id_1 = 'dummy_profile1'\n        profile_id_2 = 'dummy_profile2'\n        product_name = 'GenericSetup'\n        directory = os.path.split(__file__)[0]\n        path = os.path.join(directory, 'versioned_profile')\n\n        # register profiles\n        profile_registry.registerProfile(profile_id_1,\n                                         'Dummy Profile 1',\n                                         'This is dummy profile 1',\n                                         path,\n                                         product=product_name)\n        profile_registry.registerProfile(profile_id_2,\n                                         'Dummy Profile 2',\n                                         'This is dummy profile 2',\n                                         path,\n                                         product=product_name)\n\n        # get full profile ids\n        profile_id_1 = ':'.join((product_name, profile_id_1))\n        profile_id_2 = ':'.join((product_name, profile_id_2))\n\n        # test\n        self.assertEqual(tool.hasPendingUpgrades(), False)\n        self.assertEqual(tool.hasPendingUpgrades(profile_id_1), False)\n        self.assertEqual(tool.hasPendingUpgrades(profile_id_2), False)\n        self.assertEqual(tool.hasPendingUpgrades('non-existing'), False)\n\n        # register upgrade steps\n        step1 = UpgradeStep(\"Upgrade 1\",\n                            profile_id_1, '*', '1.1', '',\n                            dummy_upgrade,\n                            None, \"1\")\n        _registerUpgradeStep(step1)\n        step2 = UpgradeStep(\"Upgrade 2\",\n                            profile_id_2, '*', '2.2', '',\n                            dummy_upgrade,\n                            None, \"2\")\n        _registerUpgradeStep(step2)\n        # No profile has been applied, so no upgrade is pending.\n        self.assertEqual(tool.hasPendingUpgrades(), False)\n        self.assertEqual(tool.hasPendingUpgrades(profile_id_1), False)\n        self.assertEqual(tool.hasPendingUpgrades(profile_id_2), False)\n\n        # Pretend profile 1 was installed to an earlier version.\n        tool.setLastVersionForProfile(profile_id_1, '1.0')\n        self.assertEqual(tool.hasPendingUpgrades(), True)\n        self.assertEqual(tool.hasPendingUpgrades(profile_id_1), True)\n        self.assertEqual(tool.hasPendingUpgrades(profile_id_2), False)\n\n        # Pretend profile 2 was installed to an earlier version.\n        tool.setLastVersionForProfile(profile_id_2, '2.0')\n        self.assertEqual(tool.hasPendingUpgrades(), True)\n        self.assertEqual(tool.hasPendingUpgrades(profile_id_1), True)\n        self.assertEqual(tool.hasPendingUpgrades(profile_id_2), True)\n\n        # Pretend profile 1 was installed to the final version.\n        tool.setLastVersionForProfile(profile_id_1, '1.1')\n        self.assertEqual(tool.hasPendingUpgrades(), True)\n        self.assertEqual(tool.hasPendingUpgrades(profile_id_1), False)\n        self.assertEqual(tool.hasPendingUpgrades(profile_id_2), True)\n\n        # Pretend profile 2 was installed to the final version.\n        tool.setLastVersionForProfile(profile_id_2, '2.2')\n        self.assertEqual(tool.hasPendingUpgrades(), False)\n        self.assertEqual(tool.hasPendingUpgrades(profile_id_1), False)\n        self.assertEqual(tool.hasPendingUpgrades(profile_id_2), False)\n\n    def test_manage_doUpgrades_no_profile_id_or_updates(self):\n        site = self._makeSite()\n        site.setup_tool = self._makeOne('setup_tool')\n        tool = site.setup_tool\n        tool.manage_doUpgrades()\n        self.assertEqual(tool._profile_upgrade_versions, {})\n\n    def test_manage_doUpgrades_upgrade_w_no_target_version(self):\n        def notool():\n            return None\n        step = UpgradeStep('TITLE', 'foo', '*', '*', 'DESC', notool)\n        _registerUpgradeStep(step)\n        site = self._makeSite()\n        site.setup_tool = self._makeOne('setup_tool')\n        tool = site.setup_tool\n        request = site.REQUEST\n        request['profile_id'] = ['foo']\n        request['upgrade'] = [step.id]\n        tool.manage_doUpgrades()\n        self.assertEqual(tool._profile_upgrade_versions, {})\n\n    def test_upgradeProfile_no_profile_id_or_updates(self):\n        site = self._makeSite()\n        site.setup_tool = self._makeOne('setup_tool')\n        tool = site.setup_tool\n        # Mostly this checks to see if we can call this without an\n        # exception.\n        tool.upgradeProfile('no.such.profile:default')\n        self.assertEqual(tool._profile_upgrade_versions, {})\n        tool.upgradeProfile('no.such.profile:default', dest='42')\n        self.assertEqual(tool._profile_upgrade_versions, {})\n\n    def test_persistent_profile_upgrade_versions(self):\n        site = self._makeSite()\n        site.setup_tool = self._makeOne('setup_tool')\n        tool = site.setup_tool\n        savepoint1 = transaction.savepoint()\n        tool.setLastVersionForProfile('foo', '1.0')\n        savepoint2 = transaction.savepoint()\n        tool.setLastVersionForProfile('bar', '2.0')\n        self.assertEqual(tool._profile_upgrade_versions,\n                         {'foo': ('1', '0'), 'bar': ('2', '0')})\n        savepoint2.rollback()\n        self.assertEqual(tool._profile_upgrade_versions,\n                         {'foo': ('1', '0')})\n        savepoint1.rollback()\n        self.assertEqual(tool._profile_upgrade_versions, {})\n\n    def test_separate_profile_upgrade_versions(self):\n        # _profile_upgrade_versions used to be a class property.  That is fine\n        # as long as we only work on copies, otherwise state is shared between\n        # two instances.  We now create the property in the __init__ method,\n        # but let's test it to avoid a regression.\n        site = self._makeSite()\n        site.setup_tool1 = self._makeOne('setup_tool1')\n        tool1 = site.setup_tool1\n        site.setup_tool2 = self._makeOne('setup_tool2')\n        tool2 = site.setup_tool2\n        tool1._profile_upgrade_versions['foo'] = '1.0'\n        self.assertEqual(tool2._profile_upgrade_versions, {})\n        tool2.setLastVersionForProfile('bar', '2.0')\n        self.assertEqual(self._makeOne('t')._profile_upgrade_versions, {})\n\n    def test_upgradeProfile(self):\n        def dummy_handler(tool):\n            return None\n\n        def step3_handler(tool):\n            tool._step3_applied = 'just a marker'\n\n        def step3_checker(tool):\n            # False means already applied or does not apply.\n            # True means can be applied.\n            return not hasattr(tool, '_step3_applied')\n\n        step1 = UpgradeStep('Step 1', 'foo', '0', '1', 'DESC',\n                            dummy_handler)\n        step2 = UpgradeStep('Step 2', 'foo', '1', '2', 'DESC',\n                            dummy_handler)\n        step3 = UpgradeStep('Step 3', 'foo', '2', '3', 'DESC',\n                            step3_handler, checker=step3_checker)\n        step4 = UpgradeStep('Step 4', 'foo', '3', '4', 'DESC',\n                            dummy_handler)\n        _registerUpgradeStep(step1)\n        _registerUpgradeStep(step2)\n        _registerUpgradeStep(step3)\n        _registerUpgradeStep(step4)\n        site = self._makeSite()\n        site.setup_tool = self._makeOne('setup_tool')\n        tool = site.setup_tool\n        self.assertEqual(tool.getLastVersionForProfile('foo'), 'unknown')\n        tool.setLastVersionForProfile('foo', '0')\n        self.assertEqual(tool.getLastVersionForProfile('foo'), ('0',))\n        # Upgrade the profile one step to version 1.\n        tool.upgradeProfile('foo', '1')\n        self.assertEqual(tool.getLastVersionForProfile('foo'), ('1',))\n        # Upgrade the profile two steps to version 3.  This one has a\n        # checker.  The profile version must be correctly updated.\n        tool.upgradeProfile('foo', '3')\n        self.assertEqual(tool.getLastVersionForProfile('foo'), ('3',))\n        # Upgrade the profile to a non existing version.  Nothing\n        # should happen.\n        tool.upgradeProfile('foo', '5')\n        self.assertEqual(tool.getLastVersionForProfile('foo'), ('3',))\n        # Upgrade the profile to the latest version.\n        tool.upgradeProfile('foo')\n        self.assertEqual(tool.getLastVersionForProfile('foo'), ('4',))\n\n    def test_listExportSteps(self):\n        site = self._makeSite()\n        site.setup_tool = self._makeOne('setup_tool')\n        tool = site.setup_tool\n        result = tool.listExportSteps()\n        self.assertEqual(len(result), 4)\n        self.assertTrue(u'componentregistry' in result)\n        self.assertTrue(u'rolemap' in result)\n        self.assertTrue(u'step_registries' in result)\n        self.assertTrue(u'toolset' in result)\n\n        tool._export_registry.registerStep(u'foo', handler='foo.export')\n        tool._export_registry.registerStep(u'toolset',\n                                           handler='toolset.export')\n        result = tool.listExportSteps()\n        self.assertEqual(len(result), 5)\n        self.assertTrue(u'componentregistry' in result)\n        self.assertTrue(u'foo' in result)\n        self.assertTrue(u'rolemap' in result)\n        self.assertTrue(u'step_registries' in result)\n        self.assertTrue(u'toolset' in result)\n\n    def test_getSortedImportSteps(self):\n        site = self._makeSite()\n        site.setup_tool = self._makeOne('setup_tool')\n        tool = site.setup_tool\n        result = tool.getSortedImportSteps()\n        self.assertEqual(len(result), 3)\n        self.assertTrue(u'componentregistry' in result)\n        self.assertTrue(u'rolemap' in result)\n        self.assertTrue(u'toolset' in result)\n        self.assertTrue(list(result).index(u'componentregistry') >\n                        list(result).index(u'toolset'))\n\n        tool._import_registry.registerStep(u'foo', handler='foo.import')\n        tool._import_registry.registerStep(u'toolset',\n                                           handler='toolset.import')\n        result = tool.getSortedImportSteps()\n        self.assertEqual(len(result), 4)\n        self.assertTrue(u'componentregistry' in result)\n        self.assertTrue(u'foo' in result)\n        self.assertTrue(u'rolemap' in result)\n        self.assertTrue(u'toolset' in result)\n        self.assertTrue(list(result).index(u'componentregistry') >\n                        list(result).index(u'toolset'))\n\n    def test_listProfileInfo_for_parameter(self):\n        from ..metadata import METADATA_XML\n\n        self._makeFile(METADATA_XML, _METADATA_XML)\n\n        site = self._makeSite()\n        tool = self._makeOne('setup_tool').__of__(site)\n\n        profile_registry.registerProfile('foo', 'Foo', '', self._PROFILE_PATH,\n                                         for_=ISite)\n        # tool.listProfileInfo should call registry.listProfileInfo\n        # with the for_ parameter\n        self.assertEqual(len(tool.listProfileInfo()), 1)\n        self.assertEqual(len(tool.listProfileInfo(for_=ISite)), 1)\n        self.assertEqual(len(tool.listProfileInfo(for_=IDerivedSite)), 1)\n        self.assertEqual(len(tool.listProfileInfo(for_=IAnotherSite)), 0)\n\n    def test_profileExists(self):\n        from ..interfaces import EXTENSION\n        from ..metadata import METADATA_XML\n        site = self._makeSite()\n        tool = self._makeOne('setup_tool').__of__(site)\n\n        # Register two extension profiles.  Profile 'foo' has a dependency\n        # 'bar'.\n        self._makeFile(METADATA_XML, _METADATA_XML)\n        _makeTestFile(METADATA_XML, self._PROFILE_PATH2, _PLAIN_METADATA_XML)\n        profile_registry.registerProfile(\n            'foo', 'Foo', '', self._PROFILE_PATH, profile_type=EXTENSION)\n        profile_registry.registerProfile(\n            'bar', 'Bar', '', self._PROFILE_PATH2, profile_type=EXTENSION)\n\n        self.assertTrue(tool.profileExists('other:foo'))\n        self.assertTrue(tool.profileExists('other:bar'))\n        self.assertFalse(tool.profileExists('snapshot-something'))\n        self.assertFalse(tool.profileExists(None))\n        self.assertFalse(tool.profileExists('nonesuch'))\n\n    def test_getDependenciesForProfile(self):\n        from ..interfaces import EXTENSION\n        from ..metadata import METADATA_XML\n        site = self._makeSite()\n        tool = self._makeOne('setup_tool').__of__(site)\n\n        # Register three extension profiles.  Profile 'foo' has a dependency\n        # 'bar', and 'baz' contains non-existing dependency-profiles.\n        self._makeFile(METADATA_XML, _METADATA_XML)\n        _makeTestFile(METADATA_XML, self._PROFILE_PATH2, _PLAIN_METADATA_XML)\n        _makeTestFile(METADATA_XML, self._PROFILE_PATH3, _BROKEN_METADATA_XML)\n        profile_registry.registerProfile(\n            'foo', 'Foo', '', self._PROFILE_PATH, profile_type=EXTENSION)\n        profile_registry.registerProfile(\n            'bar', 'Bar', '', self._PROFILE_PATH2, profile_type=EXTENSION)\n        profile_registry.registerProfile(\n            'baz', 'Baz', '', self._PROFILE_PATH3, profile_type=EXTENSION)\n\n        self.assertEqual(tool.getDependenciesForProfile('other:foo'),\n                         (u'profile-other:bar', ))\n        self.assertEqual(tool.getDependenciesForProfile('other:bar'), ())\n        self.assertEqual(tool.getDependenciesForProfile('snapshot-some'), ())\n        self.assertEqual(tool.getDependenciesForProfile(None), ())\n        self.assertRaises(KeyError, tool.getDependenciesForProfile, 'nonesuch')\n\n    def test_getBrokenDependencies(self):\n        from ..interfaces import EXTENSION\n        from ..metadata import METADATA_XML\n        site = self._makeSite()\n        tool = self._makeOne('setup_tool').__of__(site)\n\n        # Register three extension profiles.  Profile 'foo' has a dependency\n        # 'bar' and 'baz' contains non-existing dependency-profiles.\n        self._makeFile(METADATA_XML, _METADATA_XML)\n        _makeTestFile(METADATA_XML, self._PROFILE_PATH2, _PLAIN_METADATA_XML)\n        _makeTestFile(METADATA_XML, self._PROFILE_PATH3, _BROKEN_METADATA_XML)\n        profile_registry.registerProfile(\n            'foo', 'Foo', '', self._PROFILE_PATH, profile_type=EXTENSION)\n        profile_registry.registerProfile(\n            'bar', 'Bar', '', self._PROFILE_PATH2, profile_type=EXTENSION)\n        profile_registry.registerProfile(\n            'baz', 'Baz', '', self._PROFILE_PATH3, profile_type=EXTENSION)\n\n        # profile has dependencies and none of them is broken:\n        self.assertFalse(tool.hasBrokenDependencies('other:foo'))\n        # profile has no dependencies, therfore nothing can be broken:\n        self.assertFalse(tool.hasBrokenDependencies('other:bar'))\n        # profile has dependencies and at least one of them is broken:\n        self.assertTrue(tool.hasBrokenDependencies('other:baz'))\n\n\n_DEFAULT_STEP_REGISTRIES_EXPORT_XML = (\"\"\"\\\n<?xml version=\"1.0\"?>\n<export-steps>\n <export-step id=\"step_registries\"\n              handler=\"Products.GenericSetup.tool.exportStepRegistries\"\n              title=\"Export import / export steps.\">\n\"\"\" + \"  \" + \"\"\"\n </export-step>\n</export-steps>\n\"\"\")\n\n_EXTRAS_STEP_REGISTRIES_EXPORT_XML = \"\"\"\\\n<?xml version=\"1.0\"?>\n<export-steps>\n <export-step\n    id=\"properties\"\n    handler=\"Products.GenericSetup.tests.test_tool._exportPropertiesINI\"\n    title=\"properties\">\n\n </export-step>\n <export-step\n    id=\"step_registries\"\n    handler=\"Products.GenericSetup.tool.exportStepRegistries\"\n    title=\"Export import / export steps.\">\n\n </export-step>\n</export-steps>\n\"\"\"\n\n_DEFAULT_STEP_REGISTRIES_IMPORT_XML = (\"\"\"\\\n<?xml version=\"1.0\"?>\n<import-steps>\n <import-step id=\"foo\" handler=\"foo.bar\" title=\"foo\">\n\"\"\" + \"  \" + \"\"\"\n </import-step>\n</import-steps>\n\"\"\")\n\n_EXTRAS_STEP_REGISTRIES_IMPORT_XML = \"\"\"\\\n<?xml version=\"1.0\"?>\n<import-steps>\n <import-step\n    id=\"dependable\"\n    version=\"1\"\n    handler=\"Products.GenericSetup.tests.test_tool._underscoreSiteTitle\"\n    title=\"dependable\">\n  <dependency step=\"purging\" />\n\n </import-step>\n <import-step\n    id=\"dependent\"\n    version=\"1\"\n    handler=\"Products.GenericSetup.tests.test_tool._uppercaseSiteTitle\"\n    title=\"dependent\">\n  <dependency step=\"dependable\" />\n\n </import-step>\n <import-step\n    id=\"purging\"\n    version=\"1\"\n    handler=\"Products.GenericSetup.tests.test_tool._purgeIfRequired\"\n    title=\"purging\">\n\n </import-step>\n</import-steps>\n\"\"\"\n\n_PROPERTIES_INI = \"\"\"\\\n[Default]\nTitle=%s\n\"\"\"\n\n\ndef _underscoreSiteTitle(context):\n\n    site = context.getSite()\n    site.title = site.title.replace(' ', '_')\n    return 'Underscored title'\n\n\ndef _uppercaseSiteTitle(context):\n\n    site = context.getSite()\n    site.title = site.title.upper()\n    return 'Uppercased title'\n\n\ndef _purgeIfRequired(context):\n\n    site = context.getSite()\n    purged = site.purged = context.shouldPurge()\n    return purged and 'Purged' or 'Unpurged'\n\n\ndef _exportPropertiesINI(context):\n\n    site = context.getSite()\n    text = _PROPERTIES_INI % site.title\n\n    context.writeDataFile('properties.ini', text.encode('utf-8'), 'text/plain')\n\n    return 'Exported properties'\n\n\nclass _ToolsetSetup(BaseRegistryTests):\n\n    def _initSite(self):\n        from ..tool import SetupTool\n\n        site = Folder()\n        site._setId('site')\n        self.app._setObject('site', site)\n        site = self.app._getOb('site')\n        site._setObject('setup_tool', SetupTool('setup_tool'))\n        return site\n\n\nclass Test_exportToolset(_ToolsetSetup):\n\n    layer = ExportImportZCMLLayer\n\n    def test_empty(self):\n        from ..tool import TOOLSET_XML\n        from ..tool import exportToolset\n\n        site = self._initSite()\n        context = DummyExportContext(site, tool=site.setup_tool)\n\n        exportToolset(context)\n\n        self.assertEqual(len(context._wrote), 1)\n        filename, text, content_type = context._wrote[0]\n        self.assertEqual(filename, TOOLSET_XML)\n        self._compareDOM(text.decode('utf-8'), _EMPTY_TOOLSET_XML)\n        self.assertEqual(content_type, 'text/xml')\n\n    def test_normal(self):\n        from ..tool import TOOLSET_XML\n        from ..tool import exportToolset\n\n        site = self._initSite()\n        toolset = site.setup_tool.getToolsetRegistry()\n        toolset.addForbiddenTool('doomed')\n        toolset.addRequiredTool('mandatory', 'path.to.one')\n        toolset.addRequiredTool('obligatory', 'path.to.another')\n\n        context = DummyExportContext(site, tool=site.setup_tool)\n\n        exportToolset(context)\n\n        self.assertEqual(len(context._wrote), 1)\n        filename, text, content_type = context._wrote[0]\n        self.assertEqual(filename, TOOLSET_XML)\n        self._compareDOM(text.decode('utf-8'), _NORMAL_TOOLSET_XML)\n        self.assertEqual(content_type, 'text/xml')\n\n\nclass Test_importToolset(_ToolsetSetup):\n\n    layer = ExportImportZCMLLayer\n\n    def test_import_updates_registry(self):\n        from ..tool import TOOLSET_XML\n        from ..tool import importToolset\n\n        site = self._initSite()\n        context = DummyImportContext(site, tool=site.setup_tool)\n\n        # Import forbidden\n        context._files[TOOLSET_XML] = _FORBIDDEN_TOOLSET_XML\n        importToolset(context)\n\n        tool = context.getSetupTool()\n        toolset = tool.getToolsetRegistry()\n\n        self.assertEqual(len(toolset.listForbiddenTools()), 3)\n        self.assertTrue('doomed' in toolset.listForbiddenTools())\n        self.assertTrue('damned' in toolset.listForbiddenTools())\n        self.assertTrue('blasted' in toolset.listForbiddenTools())\n\n        # Import required\n        context._files[TOOLSET_XML] = _REQUIRED_TOOLSET_XML\n        importToolset(context)\n\n        self.assertEqual(len(toolset.listRequiredTools()), 2)\n        self.assertTrue('mandatory' in toolset.listRequiredTools())\n        info = toolset.getRequiredToolInfo('mandatory')\n        self.assertEqual(info['class'],\n                         'Products.GenericSetup.tests.test_tool.DummyTool')\n        self.assertTrue('obligatory' in toolset.listRequiredTools())\n        info = toolset.getRequiredToolInfo('obligatory')\n        self.assertEqual(info['class'],\n                         'Products.GenericSetup.tests.test_tool.DummyTool')\n\n    def test_tool_ids(self):\n        # The tool import mechanism used to rely on the fact that all tools\n        # have unique IDs set at the class level and that you can call their\n        # constructor with no arguments. However, there might be tools\n        # that need IDs set.\n        from ..tool import TOOLSET_XML\n        from ..tool import importToolset\n\n        site = self._initSite()\n        context = DummyImportContext(site, tool=site.setup_tool)\n        context._files[TOOLSET_XML] = _REQUIRED_TOOLSET_XML\n\n        importToolset(context)\n\n        for tool_id in ('mandatory', 'obligatory'):\n            tool = getattr(site, tool_id)\n            self.assertEqual(tool.getId(), tool_id)\n\n    def test_tool_id_required(self):\n        # Tests that tool creation will still work when an id is required\n        # by the tool constructor.\n        from ..tool import TOOLSET_XML\n        from ..tool import importToolset\n\n        site = self._initSite()\n        context = DummyImportContext(site, tool=site.setup_tool)\n        context._files[TOOLSET_XML] = _WITH_ID_TOOLSET_XML\n\n        importToolset(context)\n\n        for tool_id in ('mandatory', 'requires_id', 'immutable_id'):\n            tool = getattr(site, tool_id)\n            self.assertEqual(tool.getId(), tool_id)\n\n    def test_forbidden_tools(self):\n        from ..tool import TOOLSET_XML\n        from ..tool import importToolset\n\n        TOOL_IDS = ('doomed', 'blasted', 'saved')\n\n        site = self._initSite()\n\n        for tool_id in TOOL_IDS:\n            pseudo = Folder()\n            pseudo._setId(tool_id)\n            site._setObject(tool_id, pseudo)\n\n        self.assertEqual(len(site.objectIds()), len(TOOL_IDS) + 1)\n\n        for tool_id in TOOL_IDS:\n            self.assertTrue(tool_id in site.objectIds())\n\n        context = DummyImportContext(site, tool=site.setup_tool)\n        context._files[TOOLSET_XML] = _FORBIDDEN_TOOLSET_XML\n\n        importToolset(context)\n\n        self.assertEqual(len(site.objectIds()), 2)\n        self.assertTrue('setup_tool' in site.objectIds())\n        self.assertTrue('saved' in site.objectIds())\n\n    def test_required_tools_missing(self):\n        from ..tool import TOOLSET_XML\n        from ..tool import importToolset\n\n        site = self._initSite()\n        self.assertEqual(len(site.objectIds()), 1)\n\n        context = DummyImportContext(site, tool=site.setup_tool)\n        context._files[TOOLSET_XML] = _REQUIRED_TOOLSET_XML\n\n        importToolset(context)\n\n        self.assertEqual(len(site.objectIds()), 3)\n        self.assertTrue(isinstance(\n            aq_base(site._getOb('mandatory')), DummyTool))\n        self.assertTrue(isinstance(\n            aq_base(site._getOb('obligatory')), DummyTool))\n\n    def test_required_tools_no_replacement(self):\n        from ..tool import TOOLSET_XML\n        from ..tool import importToolset\n\n        site = self._initSite()\n\n        mandatory = DummyTool()\n        mandatory._setId('mandatory')\n        site._setObject('mandatory', mandatory)\n\n        obligatory = DummyTool()\n        obligatory._setId('obligatory')\n        site._setObject('obligatory', obligatory)\n\n        self.assertEqual(len(site.objectIds()), 3)\n\n        context = DummyImportContext(site, tool=site.setup_tool)\n        context._files[TOOLSET_XML] = _REQUIRED_TOOLSET_XML\n\n        importToolset(context)\n\n        self.assertEqual(len(site.objectIds()), 3)\n        self.assertTrue(aq_base(site._getOb('mandatory')) is mandatory)\n        self.assertTrue(aq_base(site._getOb('obligatory')) is obligatory)\n\n    def test_required_tools_with_replacement(self):\n        from ..tool import TOOLSET_XML\n        from ..tool import importToolset\n\n        site = self._initSite()\n\n        mandatory = AnotherDummyTool()\n        mandatory._setId('mandatory')\n        site._setObject('mandatory', mandatory)\n\n        obligatory = SubclassedDummyTool()\n        obligatory._setId('obligatory')\n        site._setObject('obligatory', obligatory)\n\n        self.assertEqual(len(site.objectIds()), 3)\n\n        context = DummyImportContext(site, tool=site.setup_tool)\n        context._files[TOOLSET_XML] = _REQUIRED_TOOLSET_XML\n\n        importToolset(context)\n\n        self.assertEqual(len(site.objectIds()), 3)\n\n        self.assertFalse(aq_base(site._getOb('mandatory')) is mandatory)\n        self.assertTrue(isinstance(\n            aq_base(site._getOb('mandatory')), DummyTool))\n\n        self.assertFalse(aq_base(site._getOb('obligatory')) is obligatory)\n        self.assertTrue(isinstance(\n            aq_base(site._getOb('obligatory')), DummyTool))\n\n    def test_required_tools_missing_acquired_nofail(self):\n        from ..tool import TOOLSET_XML\n        from ..tool import importToolset\n\n        site = self._initSite()\n        parent_site = Folder()\n\n        mandatory = AnotherDummyTool()\n        mandatory._setId('mandatory')\n        parent_site._setObject('mandatory', mandatory)\n\n        obligatory = AnotherDummyTool()\n        obligatory._setId('obligatory')\n        parent_site._setObject('obligatory', obligatory)\n\n        site = site.__of__(parent_site)\n\n        # acquiring subobjects of a different class during import\n        # should not prevent new objects from being created if they\n        # don't exist in the site\n\n        context = DummyImportContext(site, tool=site.setup_tool)\n        context._files[TOOLSET_XML] = _REQUIRED_TOOLSET_XML\n\n        importToolset(context)\n\n        self.assertFalse(aq_base(site._getOb('mandatory')) is mandatory)\n        self.assertTrue(isinstance(\n            aq_base(site._getOb('mandatory')), DummyTool))\n\n        self.assertFalse(aq_base(site._getOb('obligatory')) is obligatory)\n        self.assertTrue(isinstance(\n            aq_base(site._getOb('obligatory')), DummyTool))\n\n    def test_required_tools_missing_class_with_replacement(self):\n        from ..tool import TOOLSET_XML\n        from ..tool import importToolset\n\n        site = self._initSite()\n\n        obligatory = AnotherDummyTool()\n        obligatory._setId('obligatory')\n        site._setObject('obligatory', obligatory)\n\n        self.assertEqual(len(site.objectIds()), 2)\n\n        context = DummyImportContext(site, tool=site.setup_tool)\n        context._files[TOOLSET_XML] = _BAD_CLASS_TOOLSET_XML\n\n        importToolset(context)\n\n        self.assertEqual(len(site.objectIds()), 2)\n\n\nclass DummyTool(Folder):\n\n    pass\n\n\nclass AnotherDummyTool(Folder):\n\n    pass\n\n\nclass SubclassedDummyTool(DummyTool):\n\n    pass\n\n\nclass DummyToolRequiresId(Folder):\n\n    def __init__(self, id):\n        Folder.__init__(self)\n        self._setId(id)\n\n\nclass DummyToolImmutableId(Folder):\n\n    id = 'immutable_id'\n\n    def _setId(self, id):\n        if id != self.getId():\n            raise ValueError()\n\n\ndef pre_handler(tool):\n    try:\n        tool.pre_handler_called += 1\n    except AttributeError:\n        tool.pre_handler_called = 1\n\n\ndef post_handler(tool):\n    try:\n        tool.post_handler_called += 1\n    except AttributeError:\n        tool.post_handler_called = 1\n\n\n_FORBIDDEN_TOOLSET_XML = \"\"\"\\\n<?xml version=\"1.0\"?>\n<tool-setup>\n <forbidden tool_id=\"doomed\" />\n <forbidden tool_id=\"damned\" />\n <forbidden tool_id=\"blasted\" />\n</tool-setup>\n\"\"\"\n\n_REQUIRED_TOOLSET_XML = \"\"\"\\\n<?xml version=\"1.0\"?>\n<tool-setup>\n <required\n    tool_id=\"mandatory\"\n    class=\"Products.GenericSetup.tests.test_tool.DummyTool\" />\n <required\n    tool_id=\"obligatory\"\n    class=\"Products.GenericSetup.tests.test_tool.DummyTool\" />\n</tool-setup>\n\"\"\"\n\n_WITH_ID_TOOLSET_XML = \"\"\"\\\n<?xml version=\"1.0\"?>\n<tool-setup>\n  <required\n    tool_id=\"mandatory\"\n    class=\"Products.GenericSetup.tests.test_tool.DummyTool\" />\n  <required\n    tool_id=\"requires_id\"\n    class=\"Products.GenericSetup.tests.test_tool.DummyToolRequiresId\" />\n  <required\n    tool_id=\"immutable_id\"\n    class=\"Products.GenericSetup.tests.test_tool.DummyToolImmutableId\" />\n</tool-setup>\n\"\"\"\n\n_BAD_CLASS_TOOLSET_XML = \"\"\"\\\n<?xml version=\"1.0\"?>\n<tool-setup>\n <required\n    tool_id=\"obligatory\"\n    class=\"foobar\" />\n</tool-setup>\n\"\"\"\n\n\ndef test_suite():\n    return unittest.TestSuite((\n        unittest.makeSuite(SetupToolTests),\n        unittest.makeSuite(Test_exportToolset),\n        unittest.makeSuite(Test_importToolset),\n    ))\n"], "filenames": ["CHANGES.rst", "src/Products/GenericSetup/context.py", "src/Products/GenericSetup/tests/test_tool.py"], "buggy_code_start_loc": [7, 28, 475], "buggy_code_end_loc": [8, 564, 1103], "fixing_code_start_loc": [7, 29, 476], "fixing_code_end_loc": [8, 571, 1118], "type": "CWE-200", "message": "Products.GenericSetup is a mini-framework for expressing the configured state of a Zope Site as a set of filesystem artifacts. In Products.GenericSetup before version 2.1.1 there is an information disclosure vulnerability - anonymous visitors may view log and snapshot files generated by the Generic Setup Tool. The problem has been fixed in version 2.1.1. Depending on how you have installed Products.GenericSetup, you should change the buildout version pin to 2.1.1 and re-run the buildout, or if you used pip simply do pip install `\"Products.GenericSetup>=2.1.1\"`.", "other": {"cve": {"id": "CVE-2021-21360", "sourceIdentifier": "security-advisories@github.com", "published": "2021-03-09T01:15:13.120", "lastModified": "2022-01-01T18:02:34.637", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Products.GenericSetup is a mini-framework for expressing the configured state of a Zope Site as a set of filesystem artifacts. In Products.GenericSetup before version 2.1.1 there is an information disclosure vulnerability - anonymous visitors may view log and snapshot files generated by the Generic Setup Tool. The problem has been fixed in version 2.1.1. Depending on how you have installed Products.GenericSetup, you should change the buildout version pin to 2.1.1 and re-run the buildout, or if you used pip simply do pip install `\"Products.GenericSetup>=2.1.1\"`."}, {"lang": "es", "value": "Products.GenericSetup es un mini framework para expresar el estado configurado de un sitio Zope como un conjunto de artefactos del sistema de archivos.&#xa0;En Products.GenericSetup anterior a versi\u00f3n 2.1.1, se presenta una vulnerabilidad de divulgaci\u00f3n de informaci\u00f3n: los visitantes an\u00f3nimos pueden visualizar archivos de registro e instant\u00e1neas generadas por la Generic Setup Tool.&#xa0;El problema se ha corregido en la versi\u00f3n 2.1.1.&#xa0;Dependiendo de c\u00f3mo haya instalado Products.GenericSetup, debe cambiar el pin de la versi\u00f3n de compilaci\u00f3n a 2.1.1 y volver a ejecutar la compilaci\u00f3n, o si us\u00f3 pip simplemente haga la instalaci\u00f3n de pip \"Products.GenericSetup versiones posteriores o iguales a 2.1.1\"`"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:zope:products.genericsetup:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.1.1", "matchCriteriaId": "344C85D3-5FB3-4860-B4EC-881E1DC94A20"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2021/05/21/1", "source": "security-advisories@github.com", "tags": ["Mailing List"]}, {"url": "http://www.openwall.com/lists/oss-security/2021/05/22/1", "source": "security-advisories@github.com", "tags": ["Mailing List"]}, {"url": "https://github.com/zopefoundation/Products.GenericSetup/commit/700319512b3615b3871a1f24e096cf66dc488c57", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/zopefoundation/Products.GenericSetup/security/advisories/GHSA-jff3-mwp3-f8cw", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://pypi.org/project/Products.GenericSetup/", "source": "security-advisories@github.com", "tags": ["Product", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/zopefoundation/Products.GenericSetup/commit/700319512b3615b3871a1f24e096cf66dc488c57"}}