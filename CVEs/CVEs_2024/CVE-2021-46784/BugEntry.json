{"buggy_code": ["/*\n * Copyright (C) 1996-2022 The Squid Software Foundation and contributors\n *\n * Squid software is distributed under GPLv2+ license and includes\n * contributions from numerous individuals and organizations.\n * Please see the COPYING and CONTRIBUTORS files for details.\n */\n\n/* DEBUG: section 10    Gopher */\n\n#include \"squid.h\"\n#include \"comm.h\"\n#include \"comm/Read.h\"\n#include \"comm/Write.h\"\n#include \"errorpage.h\"\n#include \"fd.h\"\n#include \"FwdState.h\"\n#include \"globals.h\"\n#include \"gopher.h\"\n#include \"html_quote.h\"\n#include \"HttpReply.h\"\n#include \"HttpRequest.h\"\n#include \"MemBuf.h\"\n#include \"mime.h\"\n#include \"parser/Tokenizer.h\"\n#include \"rfc1738.h\"\n#include \"SquidConfig.h\"\n#include \"StatCounters.h\"\n#include \"Store.h\"\n#include \"tools.h\"\n\n#if USE_DELAY_POOLS\n#include \"DelayPools.h\"\n#include \"MemObject.h\"\n#endif\n\n// RFC 1436 section 3.8 gopher item-type codes\n#define GOPHER_FILE         '0'\n#define GOPHER_DIRECTORY    '1'\n#define GOPHER_CSO          '2'\n#define GOPHER_ERROR        '3'\n#define GOPHER_MACBINHEX    '4'\n#define GOPHER_DOSBIN       '5'\n#define GOPHER_UUENCODED    '6'\n#define GOPHER_INDEX        '7'\n#define GOPHER_TELNET       '8'\n#define GOPHER_BIN          '9'\n#define GOPHER_REDUNT       '+'\n#define GOPHER_3270         'T'\n#define GOPHER_GIF          'g'\n#define GOPHER_IMAGE        'I'\n\n// Gopher+ section 2.9 extension types\n// https://github.com/jgoerzen/pygopherd/blob/master/doc/standards/Gopher%2B.txt\n#define GOPHER_PLUS_IMAGE   ':'\n#define GOPHER_PLUS_MOVIE   ';'\n#define GOPHER_PLUS_SOUND   '<'\n\n// non-standard item-type codes\n#define GOPHER_HTML         'h'\n#define GOPHER_INFO         'i'\n#define GOPHER_WWW          'w'\n#define GOPHER_SOUND        's'\n\n#define GOPHER_PORT         70\n\n#define TAB                 '\\t'\n\n// TODO CODE: should this be a protocol-specific thing?\n#define TEMP_BUF_SIZE       4096\n\n#define MAX_CSO_RESULT      1024\n\n/**\n * Gopher Gateway Internals\n *\n * Gopher is somewhat complex and gross because it must convert from\n * the Gopher protocol to HTTP.\n */\nclass GopherStateData\n{\n    CBDATA_CLASS(GopherStateData);\n\npublic:\n    GopherStateData(FwdState *aFwd) :\n        entry(aFwd->entry),\n        conversion(NORMAL),\n        HTML_header_added(0),\n        HTML_pre(0),\n        type_id(GOPHER_FILE /* '0' */),\n        overflowed(false),\n        cso_recno(0),\n        len(0),\n        buf(NULL),\n        fwd(aFwd)\n    {\n        *request = 0;\n        buf = (char *)memAllocate(MEM_4K_BUF);\n        entry->lock(\"gopherState\");\n        *replybuf = 0;\n    }\n\n    ~GopherStateData();\n\npublic:\n    StoreEntry *entry;\n    enum {\n        NORMAL,\n        HTML_DIR,\n        HTML_INDEX_RESULT,\n        HTML_CSO_RESULT,\n        HTML_INDEX_PAGE,\n        HTML_CSO_PAGE\n    } conversion;\n    int HTML_header_added;\n    int HTML_pre;\n    char type_id;\n    char request[MAX_URL];\n\n    /// some received bytes ignored due to internal buffer capacity limits\n    bool overflowed;\n\n    int cso_recno;\n\n    /// the number of not-yet-parsed Gopher line bytes in this->buf\n    int len;\n\n    char *buf;          /* pts to a 4k page */\n    Comm::ConnectionPointer serverConn;\n    FwdState::Pointer fwd;\n    HttpReply::Pointer reply_;\n    char replybuf[BUFSIZ];\n};\n\nCBDATA_CLASS_INIT(GopherStateData);\n\nstatic CLCB gopherStateFree;\nstatic void gopherMimeCreate(GopherStateData *);\nstatic void gopher_request_parse(const HttpRequest * req,\n                                 char *type_id,\n                                 char *request);\nstatic void gopherEndHTML(GopherStateData *);\nstatic void gopherToHTML(GopherStateData *, char *inbuf, int len);\nstatic CTCB gopherTimeout;\nstatic IOCB gopherReadReply;\nstatic IOCB gopherSendComplete;\nstatic PF gopherSendRequest;\n\nstatic char def_gopher_bin[] = \"www/unknown\";\n\nstatic char def_gopher_text[] = \"text/plain\";\n\nstatic void\ngopherStateFree(const CommCloseCbParams &params)\n{\n    GopherStateData *gopherState = (GopherStateData *)params.data;\n    // Assume that FwdState is monitoring and calls noteClosure(). See XXX about\n    // Connection sharing with FwdState in gopherStart().\n    delete gopherState;\n}\n\nGopherStateData::~GopherStateData()\n{\n    if (entry)\n        entry->unlock(\"gopherState\");\n\n    if (buf)\n        memFree(buf, MEM_4K_BUF);\n}\n\n/**\n * Create MIME Header for Gopher Data\n */\nstatic void\ngopherMimeCreate(GopherStateData * gopherState)\n{\n    StoreEntry *entry = gopherState->entry;\n    const char *mime_type = NULL;\n    const char *mime_enc = NULL;\n\n    switch (gopherState->type_id) {\n\n    case GOPHER_DIRECTORY:\n\n    case GOPHER_INDEX:\n\n    case GOPHER_HTML:\n\n    case GOPHER_WWW:\n\n    case GOPHER_CSO:\n        mime_type = \"text/html\";\n        break;\n\n    case GOPHER_GIF:\n\n    case GOPHER_IMAGE:\n\n    case GOPHER_PLUS_IMAGE:\n        mime_type = \"image/gif\";\n        break;\n\n    case GOPHER_SOUND:\n\n    case GOPHER_PLUS_SOUND:\n        mime_type = \"audio/basic\";\n        break;\n\n    case GOPHER_PLUS_MOVIE:\n        mime_type = \"video/mpeg\";\n        break;\n\n    case GOPHER_MACBINHEX:\n\n    case GOPHER_DOSBIN:\n\n    case GOPHER_UUENCODED:\n\n    case GOPHER_BIN:\n        /* Rightnow We have no idea what it is. */\n        mime_enc = mimeGetContentEncoding(gopherState->request);\n        mime_type = mimeGetContentType(gopherState->request);\n        if (!mime_type)\n            mime_type = def_gopher_bin;\n        break;\n\n    case GOPHER_FILE:\n\n    default:\n        mime_enc = mimeGetContentEncoding(gopherState->request);\n        mime_type = mimeGetContentType(gopherState->request);\n        if (!mime_type)\n            mime_type = def_gopher_text;\n        break;\n    }\n\n    assert(entry->isEmpty());\n\n    HttpReply *reply = new HttpReply;\n    entry->buffer();\n    reply->setHeaders(Http::scOkay, \"Gatewaying\", mime_type, -1, -1, -2);\n    if (mime_enc)\n        reply->header.putStr(Http::HdrType::CONTENT_ENCODING, mime_enc);\n\n    entry->replaceHttpReply(reply);\n    gopherState->reply_ = reply;\n}\n\n/**\n * Parse a gopher request into components.  By Anawat.\n */\nstatic void\ngopher_request_parse(const HttpRequest * req, char *type_id, char *request)\n{\n    ::Parser::Tokenizer tok(req->url.path());\n\n    if (request)\n        *request = 0;\n\n    tok.skip('/'); // ignore failures? path could be ab-empty\n\n    if (tok.atEnd()) {\n        *type_id = GOPHER_DIRECTORY;\n        return;\n    }\n\n    static const CharacterSet anyByte(\"UTF-8\",0x00, 0xFF);\n\n    SBuf typeId;\n    (void)tok.prefix(typeId, anyByte, 1); // never fails since !atEnd()\n    *type_id = typeId[0];\n\n    if (request) {\n        SBufToCstring(request, tok.remaining().substr(0, MAX_URL-1));\n        /* convert %xx to char */\n        rfc1738_unescape(request);\n    }\n}\n\n/**\n * Parse the request to determine whether it is cachable.\n *\n * \\param req   Request data.\n * \\retval 0    Not cachable.\n * \\retval 1    Cachable.\n */\nint\ngopherCachable(const HttpRequest * req)\n{\n    int cachable = 1;\n    char type_id;\n    /* parse to see type */\n    gopher_request_parse(req,\n                         &type_id,\n                         NULL);\n\n    switch (type_id) {\n\n    case GOPHER_INDEX:\n\n    case GOPHER_CSO:\n\n    case GOPHER_TELNET:\n\n    case GOPHER_3270:\n        cachable = 0;\n        break;\n\n    default:\n        cachable = 1;\n    }\n\n    return cachable;\n}\n\nstatic void\ngopherHTMLHeader(StoreEntry * e, const char *title, const char *substring)\n{\n    storeAppendPrintf(e, \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.01 Transitional//EN\\\" \\\"http://www.w3.org/TR/html4/loose.dtd\\\">\\n\");\n    storeAppendPrintf(e, \"<HTML><HEAD><TITLE>\");\n    storeAppendPrintf(e, title, substring);\n    storeAppendPrintf(e, \"</TITLE>\");\n    storeAppendPrintf(e, \"<STYLE type=\\\"text/css\\\"><!--BODY{background-color:#ffffff;font-family:verdana,sans-serif}--></STYLE>\\n\");\n    storeAppendPrintf(e, \"</HEAD>\\n<BODY><H1>\");\n    storeAppendPrintf(e, title, substring);\n    storeAppendPrintf(e, \"</H1>\\n\");\n}\n\nstatic void\ngopherHTMLFooter(StoreEntry * e)\n{\n    storeAppendPrintf(e, \"<HR noshade size=\\\"1px\\\">\\n\");\n    storeAppendPrintf(e, \"<ADDRESS>\\n\");\n    storeAppendPrintf(e, \"Generated %s by %s (%s)\\n\",\n                      Time::FormatRfc1123(squid_curtime),\n                      getMyHostname(),\n                      visible_appname_string);\n    storeAppendPrintf(e, \"</ADDRESS></BODY></HTML>\\n\");\n}\n\nstatic void\ngopherEndHTML(GopherStateData * gopherState)\n{\n    StoreEntry *e = gopherState->entry;\n\n    if (!gopherState->HTML_header_added) {\n        gopherHTMLHeader(e, \"Server Return Nothing\", NULL);\n        storeAppendPrintf(e, \"<P>The Gopher query resulted in a blank response</P>\");\n    } else if (gopherState->HTML_pre) {\n        storeAppendPrintf(e, \"</PRE>\\n\");\n    }\n\n    gopherHTMLFooter(e);\n}\n\n/**\n * Convert Gopher to HTML.\n *\n * Borrow part of code from libwww2 came with Mosaic distribution.\n */\nstatic void\ngopherToHTML(GopherStateData * gopherState, char *inbuf, int len)\n{\n    char *pos = inbuf;\n    char *lpos = NULL;\n    char *tline = NULL;\n    LOCAL_ARRAY(char, line, TEMP_BUF_SIZE);\n    LOCAL_ARRAY(char, tmpbuf, TEMP_BUF_SIZE);\n    char *name = NULL;\n    char *selector = NULL;\n    char *host = NULL;\n    char *port = NULL;\n    char *escaped_selector = NULL;\n    const char *icon_url = NULL;\n    char gtype;\n    StoreEntry *entry = NULL;\n\n    memset(tmpbuf, '\\0', TEMP_BUF_SIZE);\n    memset(line, '\\0', TEMP_BUF_SIZE);\n\n    entry = gopherState->entry;\n\n    if (gopherState->conversion == GopherStateData::HTML_INDEX_PAGE) {\n        char *html_url = html_quote(entry->url());\n        gopherHTMLHeader(entry, \"Gopher Index %s\", html_url);\n        storeAppendPrintf(entry,\n                          \"<p>This is a searchable Gopher index. Use the search\\n\"\n                          \"function of your browser to enter search terms.\\n\"\n                          \"<ISINDEX>\\n\");\n        gopherHTMLFooter(entry);\n        /* now let start sending stuff to client */\n        entry->flush();\n        gopherState->HTML_header_added = 1;\n\n        return;\n    }\n\n    if (gopherState->conversion == GopherStateData::HTML_CSO_PAGE) {\n        char *html_url = html_quote(entry->url());\n        gopherHTMLHeader(entry, \"CSO Search of %s\", html_url);\n        storeAppendPrintf(entry,\n                          \"<P>A CSO database usually contains a phonebook or\\n\"\n                          \"directory.  Use the search function of your browser to enter\\n\"\n                          \"search terms.</P><ISINDEX>\\n\");\n        gopherHTMLFooter(entry);\n        /* now let start sending stuff to client */\n        entry->flush();\n        gopherState->HTML_header_added = 1;\n\n        return;\n    }\n\n    String outbuf;\n\n    if (!gopherState->HTML_header_added) {\n        if (gopherState->conversion == GopherStateData::HTML_CSO_RESULT)\n            gopherHTMLHeader(entry, \"CSO Search Result\", NULL);\n        else\n            gopherHTMLHeader(entry, \"Gopher Menu\", NULL);\n\n        outbuf.append (\"<PRE>\");\n\n        gopherState->HTML_header_added = 1;\n\n        gopherState->HTML_pre = 1;\n    }\n\n    while (pos < inbuf + len) {\n        int llen;\n        int left = len - (pos - inbuf);\n        lpos = (char *)memchr(pos, '\\n', left);\n        if (lpos) {\n            ++lpos;             /* Next line is after \\n */\n            llen = lpos - pos;\n        } else {\n            llen = left;\n        }\n        if (gopherState->len + llen >= TEMP_BUF_SIZE) {\n            debugs(10, DBG_IMPORTANT, \"GopherHTML: Buffer overflow. Lost some data on URL: \" << entry->url()  );\n            llen = TEMP_BUF_SIZE - gopherState->len - 1;\n            gopherState->overflowed = true; // may already be true\n        }\n        if (!lpos) {\n            /* there is no complete line in inbuf */\n            /* copy it to temp buffer */\n            /* note: llen is adjusted above */\n            memcpy(gopherState->buf + gopherState->len, pos, llen);\n            gopherState->len += llen;\n            break;\n        }\n        if (gopherState->len != 0) {\n            /* there is something left from last tx. */\n            memcpy(line, gopherState->buf, gopherState->len);\n            memcpy(line + gopherState->len, pos, llen);\n            llen += gopherState->len;\n            gopherState->len = 0;\n        } else {\n            memcpy(line, pos, llen);\n        }\n        line[llen + 1] = '\\0';\n        /* move input to next line */\n        pos = lpos;\n\n        /* at this point. We should have one line in buffer to process */\n\n        if (*line == '.') {\n            /* skip it */\n            memset(line, '\\0', TEMP_BUF_SIZE);\n            continue;\n        }\n\n        switch (gopherState->conversion) {\n\n        case GopherStateData::HTML_INDEX_RESULT:\n\n        case GopherStateData::HTML_DIR: {\n            tline = line;\n            gtype = *tline;\n            ++tline;\n            name = tline;\n            selector = strchr(tline, TAB);\n\n            if (selector) {\n                *selector = '\\0';\n                ++selector;\n                host = strchr(selector, TAB);\n\n                if (host) {\n                    *host = '\\0';\n                    ++host;\n                    port = strchr(host, TAB);\n\n                    if (port) {\n                        char *junk;\n                        port[0] = ':';\n                        junk = strchr(host, TAB);\n\n                        if (junk)\n                            *junk++ = 0;    /* Chop port */\n                        else {\n                            junk = strchr(host, '\\r');\n\n                            if (junk)\n                                *junk++ = 0;    /* Chop port */\n                            else {\n                                junk = strchr(host, '\\n');\n\n                                if (junk)\n                                    *junk++ = 0;    /* Chop port */\n                            }\n                        }\n\n                        if ((port[1] == '0') && (!port[2]))\n                            port[0] = 0;    /* 0 means none */\n                    }\n\n                    /* escape a selector here */\n                    escaped_selector = xstrdup(rfc1738_escape_part(selector));\n\n                    switch (gtype) {\n\n                    case GOPHER_DIRECTORY:\n                        icon_url = mimeGetIconURL(\"internal-menu\");\n                        break;\n\n                    case GOPHER_HTML:\n\n                    case GOPHER_FILE:\n                        icon_url = mimeGetIconURL(\"internal-text\");\n                        break;\n\n                    case GOPHER_INDEX:\n\n                    case GOPHER_CSO:\n                        icon_url = mimeGetIconURL(\"internal-index\");\n                        break;\n\n                    case GOPHER_IMAGE:\n\n                    case GOPHER_GIF:\n\n                    case GOPHER_PLUS_IMAGE:\n                        icon_url = mimeGetIconURL(\"internal-image\");\n                        break;\n\n                    case GOPHER_SOUND:\n\n                    case GOPHER_PLUS_SOUND:\n                        icon_url = mimeGetIconURL(\"internal-sound\");\n                        break;\n\n                    case GOPHER_PLUS_MOVIE:\n                        icon_url = mimeGetIconURL(\"internal-movie\");\n                        break;\n\n                    case GOPHER_TELNET:\n\n                    case GOPHER_3270:\n                        icon_url = mimeGetIconURL(\"internal-telnet\");\n                        break;\n\n                    case GOPHER_BIN:\n\n                    case GOPHER_MACBINHEX:\n\n                    case GOPHER_DOSBIN:\n\n                    case GOPHER_UUENCODED:\n                        icon_url = mimeGetIconURL(\"internal-binary\");\n                        break;\n\n                    case GOPHER_INFO:\n                        icon_url = NULL;\n                        break;\n\n                    case GOPHER_WWW:\n                        icon_url = mimeGetIconURL(\"internal-link\");\n                        break;\n\n                    default:\n                        icon_url = mimeGetIconURL(\"internal-unknown\");\n                        break;\n                    }\n\n                    memset(tmpbuf, '\\0', TEMP_BUF_SIZE);\n\n                    if ((gtype == GOPHER_TELNET) || (gtype == GOPHER_3270)) {\n                        if (strlen(escaped_selector) != 0)\n                            snprintf(tmpbuf, TEMP_BUF_SIZE, \"<IMG border=\\\"0\\\" SRC=\\\"%s\\\"> <A HREF=\\\"telnet://%s@%s%s%s/\\\">%s</A>\\n\",\n                                     icon_url, escaped_selector, rfc1738_escape_part(host),\n                                     *port ? \":\" : \"\", port, html_quote(name));\n                        else\n                            snprintf(tmpbuf, TEMP_BUF_SIZE, \"<IMG border=\\\"0\\\" SRC=\\\"%s\\\"> <A HREF=\\\"telnet://%s%s%s/\\\">%s</A>\\n\",\n                                     icon_url, rfc1738_escape_part(host), *port ? \":\" : \"\",\n                                     port, html_quote(name));\n\n                    } else if (gtype == GOPHER_INFO) {\n                        snprintf(tmpbuf, TEMP_BUF_SIZE, \"\\t%s\\n\", html_quote(name));\n                    } else {\n                        if (strncmp(selector, \"GET /\", 5) == 0) {\n                            /* WWW link */\n                            snprintf(tmpbuf, TEMP_BUF_SIZE, \"<IMG border=\\\"0\\\" SRC=\\\"%s\\\"> <A HREF=\\\"http://%s/%s\\\">%s</A>\\n\",\n                                     icon_url, host, rfc1738_escape_unescaped(selector + 5), html_quote(name));\n                        } else if (gtype == GOPHER_WWW) {\n                            snprintf(tmpbuf, TEMP_BUF_SIZE, \"<IMG border=\\\"0\\\" SRC=\\\"%s\\\"> <A HREF=\\\"%s\\\">%s</A>\\n\",\n                                     icon_url, rfc1738_escape_unescaped(selector), html_quote(name));\n                        } else {\n                            /* Standard link */\n                            snprintf(tmpbuf, TEMP_BUF_SIZE, \"<IMG border=\\\"0\\\" SRC=\\\"%s\\\"> <A HREF=\\\"gopher://%s/%c%s\\\">%s</A>\\n\",\n                                     icon_url, host, gtype, escaped_selector, html_quote(name));\n                        }\n                    }\n\n                    safe_free(escaped_selector);\n                    outbuf.append(tmpbuf);\n                } else {\n                    memset(line, '\\0', TEMP_BUF_SIZE);\n                    continue;\n                }\n            } else {\n                memset(line, '\\0', TEMP_BUF_SIZE);\n                continue;\n            }\n\n            break;\n            }           /* HTML_DIR, HTML_INDEX_RESULT */\n\n        case GopherStateData::HTML_CSO_RESULT: {\n            if (line[0] == '-') {\n                int code, recno;\n                char *s_code, *s_recno, *result;\n\n                s_code = strtok(line + 1, \":\\n\");\n                s_recno = strtok(NULL, \":\\n\");\n                result = strtok(NULL, \"\\n\");\n\n                if (!result)\n                    break;\n\n                code = atoi(s_code);\n\n                recno = atoi(s_recno);\n\n                if (code != 200)\n                    break;\n\n                if (gopherState->cso_recno != recno) {\n                    snprintf(tmpbuf, TEMP_BUF_SIZE, \"</PRE><HR noshade size=\\\"1px\\\"><H2>Record# %d<br><i>%s</i></H2>\\n<PRE>\", recno, html_quote(result));\n                    gopherState->cso_recno = recno;\n                } else {\n                    snprintf(tmpbuf, TEMP_BUF_SIZE, \"%s\\n\", html_quote(result));\n                }\n\n                outbuf.append(tmpbuf);\n                break;\n            } else {\n                int code;\n                char *s_code, *result;\n\n                s_code = strtok(line, \":\");\n                result = strtok(NULL, \"\\n\");\n\n                if (!result)\n                    break;\n\n                code = atoi(s_code);\n\n                switch (code) {\n\n                case 200: {\n                    /* OK */\n                    /* Do nothing here */\n                    break;\n                }\n\n                case 102:   /* Number of matches */\n\n                case 501:   /* No Match */\n\n                case 502: { /* Too Many Matches */\n                    /* Print the message the server returns */\n                    snprintf(tmpbuf, TEMP_BUF_SIZE, \"</PRE><HR noshade size=\\\"1px\\\"><H2>%s</H2>\\n<PRE>\", html_quote(result));\n                    outbuf.append(tmpbuf);\n                    break;\n                }\n\n                }\n            }\n\n            break;\n            }           /* HTML_CSO_RESULT */\n        default:\n            break;      /* do nothing */\n\n        }           /* switch */\n\n    }               /* while loop */\n\n    if (outbuf.size() > 0) {\n        entry->append(outbuf.rawBuf(), outbuf.size());\n        /* now let start sending stuff to client */\n        entry->flush();\n    }\n\n    outbuf.clean();\n    return;\n}\n\nstatic void\ngopherTimeout(const CommTimeoutCbParams &io)\n{\n    GopherStateData *gopherState = static_cast<GopherStateData *>(io.data);\n    debugs(10, 4, io.conn << \": '\" << gopherState->entry->url() << \"'\" );\n\n    gopherState->fwd->fail(new ErrorState(ERR_READ_TIMEOUT, Http::scGatewayTimeout, gopherState->fwd->request, gopherState->fwd->al));\n\n    if (Comm::IsConnOpen(io.conn))\n        io.conn->close();\n}\n\n/**\n * This will be called when data is ready to be read from fd.\n * Read until error or connection closed.\n */\nstatic void\ngopherReadReply(const Comm::ConnectionPointer &conn, char *buf, size_t len, Comm::Flag flag, int xerrno, void *data)\n{\n    GopherStateData *gopherState = (GopherStateData *)data;\n    StoreEntry *entry = gopherState->entry;\n    int clen;\n    int bin;\n    size_t read_sz = BUFSIZ;\n#if USE_DELAY_POOLS\n    DelayId delayId = entry->mem_obj->mostBytesAllowed();\n#endif\n\n    /* Bail out early on Comm::ERR_CLOSING - close handlers will tidy up for us */\n\n    if (flag == Comm::ERR_CLOSING) {\n        return;\n    }\n\n    assert(buf == gopherState->replybuf);\n\n    // XXX: Should update delayId, statCounter, etc. before bailing\n    if (!entry->isAccepting()) {\n        debugs(10, 3, \"terminating due to bad \" << *entry);\n        // TODO: Do not abuse connection for triggering cleanup.\n        gopherState->serverConn->close();\n        return;\n    }\n\n#if USE_DELAY_POOLS\n    read_sz = delayId.bytesWanted(1, read_sz);\n#endif\n\n    /* leave one space for \\0 in gopherToHTML */\n\n    if (flag == Comm::OK && len > 0) {\n#if USE_DELAY_POOLS\n        delayId.bytesIn(len);\n#endif\n\n        statCounter.server.all.kbytes_in += len;\n        statCounter.server.other.kbytes_in += len;\n    }\n\n    debugs(10, 5, conn << \" read len=\" << len);\n\n    if (flag == Comm::OK && len > 0) {\n        AsyncCall::Pointer nil;\n        commSetConnTimeout(conn, Config.Timeout.read, nil);\n        ++IOStats.Gopher.reads;\n\n        for (clen = len - 1, bin = 0; clen; ++bin)\n            clen >>= 1;\n\n        ++IOStats.Gopher.read_hist[bin];\n\n        HttpRequest *req = gopherState->fwd->request;\n        if (req->hier.bodyBytesRead < 0) {\n            req->hier.bodyBytesRead = 0;\n            // first bytes read, update Reply flags:\n            gopherState->reply_->sources |= Http::Message::srcGopher;\n        }\n\n        req->hier.bodyBytesRead += len;\n    }\n\n    if (flag != Comm::OK) {\n        debugs(50, DBG_IMPORTANT, \"ERROR: \" << MYNAME << \"reading: \" << xstrerr(xerrno));\n\n        if (ignoreErrno(xerrno)) {\n            AsyncCall::Pointer call = commCbCall(5,4, \"gopherReadReply\",\n                                                 CommIoCbPtrFun(gopherReadReply, gopherState));\n            comm_read(conn, buf, read_sz, call);\n        } else {\n            const auto err = new ErrorState(ERR_READ_ERROR, Http::scInternalServerError, gopherState->fwd->request, gopherState->fwd->al);\n            err->xerrno = xerrno;\n            gopherState->fwd->fail(err);\n            gopherState->serverConn->close();\n        }\n    } else if (len == 0 && entry->isEmpty()) {\n        gopherState->fwd->fail(new ErrorState(ERR_ZERO_SIZE_OBJECT, Http::scServiceUnavailable, gopherState->fwd->request, gopherState->fwd->al));\n        gopherState->serverConn->close();\n    } else if (len == 0) {\n        /* Connection closed; retrieval done. */\n        /* flush the rest of data in temp buf if there is one. */\n\n        if (gopherState->conversion != GopherStateData::NORMAL)\n            gopherEndHTML(gopherState);\n\n        entry->timestampsSet();\n        entry->flush();\n\n        if (!gopherState->len && !gopherState->overflowed)\n            gopherState->fwd->markStoredReplyAsWhole(\"gopher EOF after receiving/storing some bytes\");\n\n        gopherState->fwd->complete();\n        gopherState->serverConn->close();\n    } else {\n        if (gopherState->conversion != GopherStateData::NORMAL) {\n            gopherToHTML(gopherState, buf, len);\n        } else {\n            entry->append(buf, len);\n        }\n        AsyncCall::Pointer call = commCbCall(5,4, \"gopherReadReply\",\n                                             CommIoCbPtrFun(gopherReadReply, gopherState));\n        comm_read(conn, buf, read_sz, call);\n    }\n}\n\n/**\n * This will be called when request write is complete. Schedule read of reply.\n */\nstatic void\ngopherSendComplete(const Comm::ConnectionPointer &conn, char *, size_t size, Comm::Flag errflag, int xerrno, void *data)\n{\n    GopherStateData *gopherState = (GopherStateData *) data;\n    StoreEntry *entry = gopherState->entry;\n    debugs(10, 5, conn << \" size: \" << size << \" errflag: \" << errflag);\n\n    if (size > 0) {\n        fd_bytes(conn->fd, size, FD_WRITE);\n        statCounter.server.all.kbytes_out += size;\n        statCounter.server.other.kbytes_out += size;\n    }\n\n    if (!entry->isAccepting()) {\n        debugs(10, 3, \"terminating due to bad \" << *entry);\n        // TODO: Do not abuse connection for triggering cleanup.\n        gopherState->serverConn->close();\n        return;\n    }\n\n    if (errflag) {\n        const auto err = new ErrorState(ERR_WRITE_ERROR, Http::scServiceUnavailable, gopherState->fwd->request, gopherState->fwd->al);\n        err->xerrno = xerrno;\n        err->port = gopherState->fwd->request->url.port();\n        err->url = xstrdup(entry->url());\n        gopherState->fwd->fail(err);\n        gopherState->serverConn->close();\n        return;\n    }\n\n    /*\n     * OK. We successfully reach remote site.  Start MIME typing\n     * stuff.  Do it anyway even though request is not HTML type.\n     */\n    entry->buffer();\n\n    gopherMimeCreate(gopherState);\n\n    switch (gopherState->type_id) {\n\n    case GOPHER_DIRECTORY:\n        /* we got to convert it first */\n        gopherState->conversion = GopherStateData::HTML_DIR;\n        gopherState->HTML_header_added = 0;\n        break;\n\n    case GOPHER_INDEX:\n        /* we got to convert it first */\n        gopherState->conversion = GopherStateData::HTML_INDEX_RESULT;\n        gopherState->HTML_header_added = 0;\n        break;\n\n    case GOPHER_CSO:\n        /* we got to convert it first */\n        gopherState->conversion = GopherStateData::HTML_CSO_RESULT;\n        gopherState->cso_recno = 0;\n        gopherState->HTML_header_added = 0;\n        break;\n\n    default:\n        gopherState->conversion = GopherStateData::NORMAL;\n        entry->flush();\n    }\n\n    /* Schedule read reply. */\n    AsyncCall::Pointer call =  commCbCall(5,5, \"gopherReadReply\",\n                                          CommIoCbPtrFun(gopherReadReply, gopherState));\n    entry->delayAwareRead(conn, gopherState->replybuf, BUFSIZ, call);\n}\n\n/**\n * This will be called when connect completes. Write request.\n */\nstatic void\ngopherSendRequest(int, void *data)\n{\n    GopherStateData *gopherState = (GopherStateData *)data;\n    MemBuf mb;\n    mb.init();\n\n    if (gopherState->type_id == GOPHER_CSO) {\n        const char *t = strchr(gopherState->request, '?');\n\n        if (t)\n            ++t;        /* skip the ? */\n        else\n            t = \"\";\n\n        mb.appendf(\"query %s\\r\\nquit\", t);\n    } else {\n        if (gopherState->type_id == GOPHER_INDEX) {\n            if (char *t = strchr(gopherState->request, '?'))\n                *t = '\\t';\n        }\n        mb.append(gopherState->request, strlen(gopherState->request));\n    }\n    mb.append(\"\\r\\n\", 2);\n\n    debugs(10, 5, gopherState->serverConn);\n    AsyncCall::Pointer call = commCbCall(5,5, \"gopherSendComplete\",\n                                         CommIoCbPtrFun(gopherSendComplete, gopherState));\n    Comm::Write(gopherState->serverConn, &mb, call);\n\n    if (!gopherState->entry->makePublic())\n        gopherState->entry->makePrivate(true);\n}\n\nvoid\ngopherStart(FwdState * fwd)\n{\n    GopherStateData *gopherState = new GopherStateData(fwd);\n\n    debugs(10, 3, gopherState->entry->url());\n\n    ++ statCounter.server.all.requests;\n\n    ++ statCounter.server.other.requests;\n\n    /* Parse url. */\n    gopher_request_parse(fwd->request,\n                         &gopherState->type_id, gopherState->request);\n\n    comm_add_close_handler(fwd->serverConnection()->fd, gopherStateFree, gopherState);\n\n    if (((gopherState->type_id == GOPHER_INDEX) || (gopherState->type_id == GOPHER_CSO))\n            && (strchr(gopherState->request, '?') == NULL)) {\n        /* Index URL without query word */\n        /* We have to generate search page back to client. No need for connection */\n        gopherMimeCreate(gopherState);\n\n        if (gopherState->type_id == GOPHER_INDEX) {\n            gopherState->conversion = GopherStateData::HTML_INDEX_PAGE;\n        } else {\n            if (gopherState->type_id == GOPHER_CSO) {\n                gopherState->conversion = GopherStateData::HTML_CSO_PAGE;\n            } else {\n                gopherState->conversion = GopherStateData::HTML_INDEX_PAGE;\n            }\n        }\n\n        gopherToHTML(gopherState, (char *) NULL, 0);\n        fwd->markStoredReplyAsWhole(\"gopher instant internal request satisfaction\");\n        fwd->complete();\n        return;\n    }\n\n    // XXX: Sharing open Connection with FwdState that has its own handlers/etc.\n    gopherState->serverConn = fwd->serverConnection();\n    gopherSendRequest(fwd->serverConnection()->fd, gopherState);\n    AsyncCall::Pointer timeoutCall = commCbCall(5, 4, \"gopherTimeout\",\n                                     CommTimeoutCbPtrFun(gopherTimeout, gopherState));\n    commSetConnTimeout(fwd->serverConnection(), Config.Timeout.read, timeoutCall);\n}\n\n"], "fixing_code": ["/*\n * Copyright (C) 1996-2022 The Squid Software Foundation and contributors\n *\n * Squid software is distributed under GPLv2+ license and includes\n * contributions from numerous individuals and organizations.\n * Please see the COPYING and CONTRIBUTORS files for details.\n */\n\n/* DEBUG: section 10    Gopher */\n\n#include \"squid.h\"\n#include \"comm.h\"\n#include \"comm/Read.h\"\n#include \"comm/Write.h\"\n#include \"errorpage.h\"\n#include \"fd.h\"\n#include \"FwdState.h\"\n#include \"globals.h\"\n#include \"gopher.h\"\n#include \"html_quote.h\"\n#include \"HttpReply.h\"\n#include \"HttpRequest.h\"\n#include \"MemBuf.h\"\n#include \"mime.h\"\n#include \"parser/Tokenizer.h\"\n#include \"rfc1738.h\"\n#include \"SquidConfig.h\"\n#include \"StatCounters.h\"\n#include \"Store.h\"\n#include \"tools.h\"\n\n#if USE_DELAY_POOLS\n#include \"DelayPools.h\"\n#include \"MemObject.h\"\n#endif\n\n// RFC 1436 section 3.8 gopher item-type codes\n#define GOPHER_FILE         '0'\n#define GOPHER_DIRECTORY    '1'\n#define GOPHER_CSO          '2'\n#define GOPHER_ERROR        '3'\n#define GOPHER_MACBINHEX    '4'\n#define GOPHER_DOSBIN       '5'\n#define GOPHER_UUENCODED    '6'\n#define GOPHER_INDEX        '7'\n#define GOPHER_TELNET       '8'\n#define GOPHER_BIN          '9'\n#define GOPHER_REDUNT       '+'\n#define GOPHER_3270         'T'\n#define GOPHER_GIF          'g'\n#define GOPHER_IMAGE        'I'\n\n// Gopher+ section 2.9 extension types\n// https://github.com/jgoerzen/pygopherd/blob/master/doc/standards/Gopher%2B.txt\n#define GOPHER_PLUS_IMAGE   ':'\n#define GOPHER_PLUS_MOVIE   ';'\n#define GOPHER_PLUS_SOUND   '<'\n\n// non-standard item-type codes\n#define GOPHER_HTML         'h'\n#define GOPHER_INFO         'i'\n#define GOPHER_WWW          'w'\n#define GOPHER_SOUND        's'\n\n#define GOPHER_PORT         70\n\n#define TAB                 '\\t'\n\n// TODO CODE: should this be a protocol-specific thing?\n#define TEMP_BUF_SIZE       4096\n\n#define MAX_CSO_RESULT      1024\n\n/**\n * Gopher Gateway Internals\n *\n * Gopher is somewhat complex and gross because it must convert from\n * the Gopher protocol to HTTP.\n */\nclass GopherStateData\n{\n    CBDATA_CLASS(GopherStateData);\n\npublic:\n    GopherStateData(FwdState *aFwd) :\n        entry(aFwd->entry),\n        conversion(NORMAL),\n        HTML_header_added(0),\n        HTML_pre(0),\n        type_id(GOPHER_FILE /* '0' */),\n        overflowed(false),\n        cso_recno(0),\n        len(0),\n        buf(NULL),\n        fwd(aFwd)\n    {\n        *request = 0;\n        buf = (char *)memAllocate(MEM_4K_BUF);\n        entry->lock(\"gopherState\");\n        *replybuf = 0;\n    }\n\n    ~GopherStateData();\n\npublic:\n    StoreEntry *entry;\n    enum {\n        NORMAL,\n        HTML_DIR,\n        HTML_INDEX_RESULT,\n        HTML_CSO_RESULT,\n        HTML_INDEX_PAGE,\n        HTML_CSO_PAGE\n    } conversion;\n    int HTML_header_added;\n    int HTML_pre;\n    char type_id;\n    char request[MAX_URL];\n\n    /// some received bytes ignored due to internal buffer capacity limits\n    bool overflowed;\n\n    int cso_recno;\n\n    /// the number of not-yet-parsed Gopher line bytes in this->buf\n    int len;\n\n    char *buf;          /* pts to a 4k page */\n    Comm::ConnectionPointer serverConn;\n    FwdState::Pointer fwd;\n    HttpReply::Pointer reply_;\n    char replybuf[BUFSIZ];\n};\n\nCBDATA_CLASS_INIT(GopherStateData);\n\nstatic CLCB gopherStateFree;\nstatic void gopherMimeCreate(GopherStateData *);\nstatic void gopher_request_parse(const HttpRequest * req,\n                                 char *type_id,\n                                 char *request);\nstatic void gopherEndHTML(GopherStateData *);\nstatic void gopherToHTML(GopherStateData *, char *inbuf, int len);\nstatic CTCB gopherTimeout;\nstatic IOCB gopherReadReply;\nstatic IOCB gopherSendComplete;\nstatic PF gopherSendRequest;\n\nstatic char def_gopher_bin[] = \"www/unknown\";\n\nstatic char def_gopher_text[] = \"text/plain\";\n\nstatic void\ngopherStateFree(const CommCloseCbParams &params)\n{\n    GopherStateData *gopherState = (GopherStateData *)params.data;\n    // Assume that FwdState is monitoring and calls noteClosure(). See XXX about\n    // Connection sharing with FwdState in gopherStart().\n    delete gopherState;\n}\n\nGopherStateData::~GopherStateData()\n{\n    if (entry)\n        entry->unlock(\"gopherState\");\n\n    if (buf)\n        memFree(buf, MEM_4K_BUF);\n}\n\n/**\n * Create MIME Header for Gopher Data\n */\nstatic void\ngopherMimeCreate(GopherStateData * gopherState)\n{\n    StoreEntry *entry = gopherState->entry;\n    const char *mime_type = NULL;\n    const char *mime_enc = NULL;\n\n    switch (gopherState->type_id) {\n\n    case GOPHER_DIRECTORY:\n\n    case GOPHER_INDEX:\n\n    case GOPHER_HTML:\n\n    case GOPHER_WWW:\n\n    case GOPHER_CSO:\n        mime_type = \"text/html\";\n        break;\n\n    case GOPHER_GIF:\n\n    case GOPHER_IMAGE:\n\n    case GOPHER_PLUS_IMAGE:\n        mime_type = \"image/gif\";\n        break;\n\n    case GOPHER_SOUND:\n\n    case GOPHER_PLUS_SOUND:\n        mime_type = \"audio/basic\";\n        break;\n\n    case GOPHER_PLUS_MOVIE:\n        mime_type = \"video/mpeg\";\n        break;\n\n    case GOPHER_MACBINHEX:\n\n    case GOPHER_DOSBIN:\n\n    case GOPHER_UUENCODED:\n\n    case GOPHER_BIN:\n        /* Rightnow We have no idea what it is. */\n        mime_enc = mimeGetContentEncoding(gopherState->request);\n        mime_type = mimeGetContentType(gopherState->request);\n        if (!mime_type)\n            mime_type = def_gopher_bin;\n        break;\n\n    case GOPHER_FILE:\n\n    default:\n        mime_enc = mimeGetContentEncoding(gopherState->request);\n        mime_type = mimeGetContentType(gopherState->request);\n        if (!mime_type)\n            mime_type = def_gopher_text;\n        break;\n    }\n\n    assert(entry->isEmpty());\n\n    HttpReply *reply = new HttpReply;\n    entry->buffer();\n    reply->setHeaders(Http::scOkay, \"Gatewaying\", mime_type, -1, -1, -2);\n    if (mime_enc)\n        reply->header.putStr(Http::HdrType::CONTENT_ENCODING, mime_enc);\n\n    entry->replaceHttpReply(reply);\n    gopherState->reply_ = reply;\n}\n\n/**\n * Parse a gopher request into components.  By Anawat.\n */\nstatic void\ngopher_request_parse(const HttpRequest * req, char *type_id, char *request)\n{\n    ::Parser::Tokenizer tok(req->url.path());\n\n    if (request)\n        *request = 0;\n\n    tok.skip('/'); // ignore failures? path could be ab-empty\n\n    if (tok.atEnd()) {\n        *type_id = GOPHER_DIRECTORY;\n        return;\n    }\n\n    static const CharacterSet anyByte(\"UTF-8\",0x00, 0xFF);\n\n    SBuf typeId;\n    (void)tok.prefix(typeId, anyByte, 1); // never fails since !atEnd()\n    *type_id = typeId[0];\n\n    if (request) {\n        SBufToCstring(request, tok.remaining().substr(0, MAX_URL-1));\n        /* convert %xx to char */\n        rfc1738_unescape(request);\n    }\n}\n\n/**\n * Parse the request to determine whether it is cachable.\n *\n * \\param req   Request data.\n * \\retval 0    Not cachable.\n * \\retval 1    Cachable.\n */\nint\ngopherCachable(const HttpRequest * req)\n{\n    int cachable = 1;\n    char type_id;\n    /* parse to see type */\n    gopher_request_parse(req,\n                         &type_id,\n                         NULL);\n\n    switch (type_id) {\n\n    case GOPHER_INDEX:\n\n    case GOPHER_CSO:\n\n    case GOPHER_TELNET:\n\n    case GOPHER_3270:\n        cachable = 0;\n        break;\n\n    default:\n        cachable = 1;\n    }\n\n    return cachable;\n}\n\nstatic void\ngopherHTMLHeader(StoreEntry * e, const char *title, const char *substring)\n{\n    storeAppendPrintf(e, \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.01 Transitional//EN\\\" \\\"http://www.w3.org/TR/html4/loose.dtd\\\">\\n\");\n    storeAppendPrintf(e, \"<HTML><HEAD><TITLE>\");\n    storeAppendPrintf(e, title, substring);\n    storeAppendPrintf(e, \"</TITLE>\");\n    storeAppendPrintf(e, \"<STYLE type=\\\"text/css\\\"><!--BODY{background-color:#ffffff;font-family:verdana,sans-serif}--></STYLE>\\n\");\n    storeAppendPrintf(e, \"</HEAD>\\n<BODY><H1>\");\n    storeAppendPrintf(e, title, substring);\n    storeAppendPrintf(e, \"</H1>\\n\");\n}\n\nstatic void\ngopherHTMLFooter(StoreEntry * e)\n{\n    storeAppendPrintf(e, \"<HR noshade size=\\\"1px\\\">\\n\");\n    storeAppendPrintf(e, \"<ADDRESS>\\n\");\n    storeAppendPrintf(e, \"Generated %s by %s (%s)\\n\",\n                      Time::FormatRfc1123(squid_curtime),\n                      getMyHostname(),\n                      visible_appname_string);\n    storeAppendPrintf(e, \"</ADDRESS></BODY></HTML>\\n\");\n}\n\nstatic void\ngopherEndHTML(GopherStateData * gopherState)\n{\n    StoreEntry *e = gopherState->entry;\n\n    if (!gopherState->HTML_header_added) {\n        gopherHTMLHeader(e, \"Server Return Nothing\", NULL);\n        storeAppendPrintf(e, \"<P>The Gopher query resulted in a blank response</P>\");\n    } else if (gopherState->HTML_pre) {\n        storeAppendPrintf(e, \"</PRE>\\n\");\n    }\n\n    gopherHTMLFooter(e);\n}\n\n/**\n * Convert Gopher to HTML.\n *\n * Borrow part of code from libwww2 came with Mosaic distribution.\n */\nstatic void\ngopherToHTML(GopherStateData * gopherState, char *inbuf, int len)\n{\n    char *pos = inbuf;\n    char *lpos = NULL;\n    char *tline = NULL;\n    LOCAL_ARRAY(char, line, TEMP_BUF_SIZE);\n    char *name = NULL;\n    char *selector = NULL;\n    char *host = NULL;\n    char *port = NULL;\n    char *escaped_selector = NULL;\n    const char *icon_url = NULL;\n    char gtype;\n    StoreEntry *entry = NULL;\n\n    memset(line, '\\0', TEMP_BUF_SIZE);\n\n    entry = gopherState->entry;\n\n    if (gopherState->conversion == GopherStateData::HTML_INDEX_PAGE) {\n        char *html_url = html_quote(entry->url());\n        gopherHTMLHeader(entry, \"Gopher Index %s\", html_url);\n        storeAppendPrintf(entry,\n                          \"<p>This is a searchable Gopher index. Use the search\\n\"\n                          \"function of your browser to enter search terms.\\n\"\n                          \"<ISINDEX>\\n\");\n        gopherHTMLFooter(entry);\n        /* now let start sending stuff to client */\n        entry->flush();\n        gopherState->HTML_header_added = 1;\n\n        return;\n    }\n\n    if (gopherState->conversion == GopherStateData::HTML_CSO_PAGE) {\n        char *html_url = html_quote(entry->url());\n        gopherHTMLHeader(entry, \"CSO Search of %s\", html_url);\n        storeAppendPrintf(entry,\n                          \"<P>A CSO database usually contains a phonebook or\\n\"\n                          \"directory.  Use the search function of your browser to enter\\n\"\n                          \"search terms.</P><ISINDEX>\\n\");\n        gopherHTMLFooter(entry);\n        /* now let start sending stuff to client */\n        entry->flush();\n        gopherState->HTML_header_added = 1;\n\n        return;\n    }\n\n    SBuf outbuf;\n\n    if (!gopherState->HTML_header_added) {\n        if (gopherState->conversion == GopherStateData::HTML_CSO_RESULT)\n            gopherHTMLHeader(entry, \"CSO Search Result\", NULL);\n        else\n            gopherHTMLHeader(entry, \"Gopher Menu\", NULL);\n\n        outbuf.append (\"<PRE>\");\n\n        gopherState->HTML_header_added = 1;\n\n        gopherState->HTML_pre = 1;\n    }\n\n    while (pos < inbuf + len) {\n        int llen;\n        int left = len - (pos - inbuf);\n        lpos = (char *)memchr(pos, '\\n', left);\n        if (lpos) {\n            ++lpos;             /* Next line is after \\n */\n            llen = lpos - pos;\n        } else {\n            llen = left;\n        }\n        if (gopherState->len + llen >= TEMP_BUF_SIZE) {\n            debugs(10, DBG_IMPORTANT, \"GopherHTML: Buffer overflow. Lost some data on URL: \" << entry->url()  );\n            llen = TEMP_BUF_SIZE - gopherState->len - 1;\n            gopherState->overflowed = true; // may already be true\n        }\n        if (!lpos) {\n            /* there is no complete line in inbuf */\n            /* copy it to temp buffer */\n            /* note: llen is adjusted above */\n            memcpy(gopherState->buf + gopherState->len, pos, llen);\n            gopherState->len += llen;\n            break;\n        }\n        if (gopherState->len != 0) {\n            /* there is something left from last tx. */\n            memcpy(line, gopherState->buf, gopherState->len);\n            memcpy(line + gopherState->len, pos, llen);\n            llen += gopherState->len;\n            gopherState->len = 0;\n        } else {\n            memcpy(line, pos, llen);\n        }\n        line[llen + 1] = '\\0';\n        /* move input to next line */\n        pos = lpos;\n\n        /* at this point. We should have one line in buffer to process */\n\n        if (*line == '.') {\n            /* skip it */\n            memset(line, '\\0', TEMP_BUF_SIZE);\n            continue;\n        }\n\n        switch (gopherState->conversion) {\n\n        case GopherStateData::HTML_INDEX_RESULT:\n\n        case GopherStateData::HTML_DIR: {\n            tline = line;\n            gtype = *tline;\n            ++tline;\n            name = tline;\n            selector = strchr(tline, TAB);\n\n            if (selector) {\n                *selector = '\\0';\n                ++selector;\n                host = strchr(selector, TAB);\n\n                if (host) {\n                    *host = '\\0';\n                    ++host;\n                    port = strchr(host, TAB);\n\n                    if (port) {\n                        char *junk;\n                        port[0] = ':';\n                        junk = strchr(host, TAB);\n\n                        if (junk)\n                            *junk++ = 0;    /* Chop port */\n                        else {\n                            junk = strchr(host, '\\r');\n\n                            if (junk)\n                                *junk++ = 0;    /* Chop port */\n                            else {\n                                junk = strchr(host, '\\n');\n\n                                if (junk)\n                                    *junk++ = 0;    /* Chop port */\n                            }\n                        }\n\n                        if ((port[1] == '0') && (!port[2]))\n                            port[0] = 0;    /* 0 means none */\n                    }\n\n                    /* escape a selector here */\n                    escaped_selector = xstrdup(rfc1738_escape_part(selector));\n\n                    switch (gtype) {\n\n                    case GOPHER_DIRECTORY:\n                        icon_url = mimeGetIconURL(\"internal-menu\");\n                        break;\n\n                    case GOPHER_HTML:\n\n                    case GOPHER_FILE:\n                        icon_url = mimeGetIconURL(\"internal-text\");\n                        break;\n\n                    case GOPHER_INDEX:\n\n                    case GOPHER_CSO:\n                        icon_url = mimeGetIconURL(\"internal-index\");\n                        break;\n\n                    case GOPHER_IMAGE:\n\n                    case GOPHER_GIF:\n\n                    case GOPHER_PLUS_IMAGE:\n                        icon_url = mimeGetIconURL(\"internal-image\");\n                        break;\n\n                    case GOPHER_SOUND:\n\n                    case GOPHER_PLUS_SOUND:\n                        icon_url = mimeGetIconURL(\"internal-sound\");\n                        break;\n\n                    case GOPHER_PLUS_MOVIE:\n                        icon_url = mimeGetIconURL(\"internal-movie\");\n                        break;\n\n                    case GOPHER_TELNET:\n\n                    case GOPHER_3270:\n                        icon_url = mimeGetIconURL(\"internal-telnet\");\n                        break;\n\n                    case GOPHER_BIN:\n\n                    case GOPHER_MACBINHEX:\n\n                    case GOPHER_DOSBIN:\n\n                    case GOPHER_UUENCODED:\n                        icon_url = mimeGetIconURL(\"internal-binary\");\n                        break;\n\n                    case GOPHER_INFO:\n                        icon_url = NULL;\n                        break;\n\n                    case GOPHER_WWW:\n                        icon_url = mimeGetIconURL(\"internal-link\");\n                        break;\n\n                    default:\n                        icon_url = mimeGetIconURL(\"internal-unknown\");\n                        break;\n                    }\n\n                    if ((gtype == GOPHER_TELNET) || (gtype == GOPHER_3270)) {\n                        if (strlen(escaped_selector) != 0)\n                            outbuf.appendf(\"<IMG border=\\\"0\\\" SRC=\\\"%s\\\"> <A HREF=\\\"telnet://%s@%s%s%s/\\\">%s</A>\\n\",\n                                     icon_url, escaped_selector, rfc1738_escape_part(host),\n                                     *port ? \":\" : \"\", port, html_quote(name));\n                        else\n                            outbuf.appendf(\"<IMG border=\\\"0\\\" SRC=\\\"%s\\\"> <A HREF=\\\"telnet://%s%s%s/\\\">%s</A>\\n\",\n                                     icon_url, rfc1738_escape_part(host), *port ? \":\" : \"\",\n                                     port, html_quote(name));\n\n                    } else if (gtype == GOPHER_INFO) {\n                        outbuf.appendf(\"\\t%s\\n\", html_quote(name));\n                    } else {\n                        if (strncmp(selector, \"GET /\", 5) == 0) {\n                            /* WWW link */\n                            outbuf.appendf(\"<IMG border=\\\"0\\\" SRC=\\\"%s\\\"> <A HREF=\\\"http://%s/%s\\\">%s</A>\\n\",\n                                     icon_url, host, rfc1738_escape_unescaped(selector + 5), html_quote(name));\n                        } else if (gtype == GOPHER_WWW) {\n                            outbuf.appendf(\"<IMG border=\\\"0\\\" SRC=\\\"%s\\\"> <A HREF=\\\"gopher://%s/%c%s\\\">%s</A>\\n\",\n                                     icon_url, rfc1738_escape_unescaped(selector), html_quote(name));\n                        } else {\n                            /* Standard link */\n                            outbuf.appendf(\"<IMG border=\\\"0\\\" SRC=\\\"%s\\\"> <A HREF=\\\"gopher://%s/%c%s\\\">%s</A>\\n\",\n                                     icon_url, host, gtype, escaped_selector, html_quote(name));\n                        }\n                    }\n\n                    safe_free(escaped_selector);\n                } else {\n                    memset(line, '\\0', TEMP_BUF_SIZE);\n                    continue;\n                }\n            } else {\n                memset(line, '\\0', TEMP_BUF_SIZE);\n                continue;\n            }\n\n            break;\n            }           /* HTML_DIR, HTML_INDEX_RESULT */\n\n        case GopherStateData::HTML_CSO_RESULT: {\n            if (line[0] == '-') {\n                int code, recno;\n                char *s_code, *s_recno, *result;\n\n                s_code = strtok(line + 1, \":\\n\");\n                s_recno = strtok(NULL, \":\\n\");\n                result = strtok(NULL, \"\\n\");\n\n                if (!result)\n                    break;\n\n                code = atoi(s_code);\n\n                recno = atoi(s_recno);\n\n                if (code != 200)\n                    break;\n\n                if (gopherState->cso_recno != recno) {\n                    outbuf.appendf(\"</PRE><HR noshade size=\\\"1px\\\"><H2>Record# %d<br><i>%s</i></H2>\\n<PRE>\", recno, html_quote(result));\n                    gopherState->cso_recno = recno;\n                } else {\n                    outbuf.appendf(\"%s\\n\", html_quote(result));\n                }\n\n                break;\n            } else {\n                int code;\n                char *s_code, *result;\n\n                s_code = strtok(line, \":\");\n                result = strtok(NULL, \"\\n\");\n\n                if (!result)\n                    break;\n\n                code = atoi(s_code);\n\n                switch (code) {\n\n                case 200: {\n                    /* OK */\n                    /* Do nothing here */\n                    break;\n                }\n\n                case 102:   /* Number of matches */\n\n                case 501:   /* No Match */\n\n                case 502: { /* Too Many Matches */\n                    /* Print the message the server returns */\n                    outbuf.appendf(\"</PRE><HR noshade size=\\\"1px\\\"><H2>%s</H2>\\n<PRE>\", html_quote(result));\n                    break;\n                }\n\n                }\n            }\n\n            break;\n            }           /* HTML_CSO_RESULT */\n        default:\n            break;      /* do nothing */\n\n        }           /* switch */\n\n    }               /* while loop */\n\n    if (outbuf.length() > 0) {\n        entry->append(outbuf.rawContent(), outbuf.length());\n        /* now let start sending stuff to client */\n        entry->flush();\n    }\n\n    return;\n}\n\nstatic void\ngopherTimeout(const CommTimeoutCbParams &io)\n{\n    GopherStateData *gopherState = static_cast<GopherStateData *>(io.data);\n    debugs(10, 4, io.conn << \": '\" << gopherState->entry->url() << \"'\" );\n\n    gopherState->fwd->fail(new ErrorState(ERR_READ_TIMEOUT, Http::scGatewayTimeout, gopherState->fwd->request, gopherState->fwd->al));\n\n    if (Comm::IsConnOpen(io.conn))\n        io.conn->close();\n}\n\n/**\n * This will be called when data is ready to be read from fd.\n * Read until error or connection closed.\n */\nstatic void\ngopherReadReply(const Comm::ConnectionPointer &conn, char *buf, size_t len, Comm::Flag flag, int xerrno, void *data)\n{\n    GopherStateData *gopherState = (GopherStateData *)data;\n    StoreEntry *entry = gopherState->entry;\n    int clen;\n    int bin;\n    size_t read_sz = BUFSIZ;\n#if USE_DELAY_POOLS\n    DelayId delayId = entry->mem_obj->mostBytesAllowed();\n#endif\n\n    /* Bail out early on Comm::ERR_CLOSING - close handlers will tidy up for us */\n\n    if (flag == Comm::ERR_CLOSING) {\n        return;\n    }\n\n    assert(buf == gopherState->replybuf);\n\n    // XXX: Should update delayId, statCounter, etc. before bailing\n    if (!entry->isAccepting()) {\n        debugs(10, 3, \"terminating due to bad \" << *entry);\n        // TODO: Do not abuse connection for triggering cleanup.\n        gopherState->serverConn->close();\n        return;\n    }\n\n#if USE_DELAY_POOLS\n    read_sz = delayId.bytesWanted(1, read_sz);\n#endif\n\n    /* leave one space for \\0 in gopherToHTML */\n\n    if (flag == Comm::OK && len > 0) {\n#if USE_DELAY_POOLS\n        delayId.bytesIn(len);\n#endif\n\n        statCounter.server.all.kbytes_in += len;\n        statCounter.server.other.kbytes_in += len;\n    }\n\n    debugs(10, 5, conn << \" read len=\" << len);\n\n    if (flag == Comm::OK && len > 0) {\n        AsyncCall::Pointer nil;\n        commSetConnTimeout(conn, Config.Timeout.read, nil);\n        ++IOStats.Gopher.reads;\n\n        for (clen = len - 1, bin = 0; clen; ++bin)\n            clen >>= 1;\n\n        ++IOStats.Gopher.read_hist[bin];\n\n        HttpRequest *req = gopherState->fwd->request;\n        if (req->hier.bodyBytesRead < 0) {\n            req->hier.bodyBytesRead = 0;\n            // first bytes read, update Reply flags:\n            gopherState->reply_->sources |= Http::Message::srcGopher;\n        }\n\n        req->hier.bodyBytesRead += len;\n    }\n\n    if (flag != Comm::OK) {\n        debugs(50, DBG_IMPORTANT, \"ERROR: \" << MYNAME << \"reading: \" << xstrerr(xerrno));\n\n        if (ignoreErrno(xerrno)) {\n            AsyncCall::Pointer call = commCbCall(5,4, \"gopherReadReply\",\n                                                 CommIoCbPtrFun(gopherReadReply, gopherState));\n            comm_read(conn, buf, read_sz, call);\n        } else {\n            const auto err = new ErrorState(ERR_READ_ERROR, Http::scInternalServerError, gopherState->fwd->request, gopherState->fwd->al);\n            err->xerrno = xerrno;\n            gopherState->fwd->fail(err);\n            gopherState->serverConn->close();\n        }\n    } else if (len == 0 && entry->isEmpty()) {\n        gopherState->fwd->fail(new ErrorState(ERR_ZERO_SIZE_OBJECT, Http::scServiceUnavailable, gopherState->fwd->request, gopherState->fwd->al));\n        gopherState->serverConn->close();\n    } else if (len == 0) {\n        /* Connection closed; retrieval done. */\n        /* flush the rest of data in temp buf if there is one. */\n\n        if (gopherState->conversion != GopherStateData::NORMAL)\n            gopherEndHTML(gopherState);\n\n        entry->timestampsSet();\n        entry->flush();\n\n        if (!gopherState->len && !gopherState->overflowed)\n            gopherState->fwd->markStoredReplyAsWhole(\"gopher EOF after receiving/storing some bytes\");\n\n        gopherState->fwd->complete();\n        gopherState->serverConn->close();\n    } else {\n        if (gopherState->conversion != GopherStateData::NORMAL) {\n            gopherToHTML(gopherState, buf, len);\n        } else {\n            entry->append(buf, len);\n        }\n        AsyncCall::Pointer call = commCbCall(5,4, \"gopherReadReply\",\n                                             CommIoCbPtrFun(gopherReadReply, gopherState));\n        comm_read(conn, buf, read_sz, call);\n    }\n}\n\n/**\n * This will be called when request write is complete. Schedule read of reply.\n */\nstatic void\ngopherSendComplete(const Comm::ConnectionPointer &conn, char *, size_t size, Comm::Flag errflag, int xerrno, void *data)\n{\n    GopherStateData *gopherState = (GopherStateData *) data;\n    StoreEntry *entry = gopherState->entry;\n    debugs(10, 5, conn << \" size: \" << size << \" errflag: \" << errflag);\n\n    if (size > 0) {\n        fd_bytes(conn->fd, size, FD_WRITE);\n        statCounter.server.all.kbytes_out += size;\n        statCounter.server.other.kbytes_out += size;\n    }\n\n    if (!entry->isAccepting()) {\n        debugs(10, 3, \"terminating due to bad \" << *entry);\n        // TODO: Do not abuse connection for triggering cleanup.\n        gopherState->serverConn->close();\n        return;\n    }\n\n    if (errflag) {\n        const auto err = new ErrorState(ERR_WRITE_ERROR, Http::scServiceUnavailable, gopherState->fwd->request, gopherState->fwd->al);\n        err->xerrno = xerrno;\n        err->port = gopherState->fwd->request->url.port();\n        err->url = xstrdup(entry->url());\n        gopherState->fwd->fail(err);\n        gopherState->serverConn->close();\n        return;\n    }\n\n    /*\n     * OK. We successfully reach remote site.  Start MIME typing\n     * stuff.  Do it anyway even though request is not HTML type.\n     */\n    entry->buffer();\n\n    gopherMimeCreate(gopherState);\n\n    switch (gopherState->type_id) {\n\n    case GOPHER_DIRECTORY:\n        /* we got to convert it first */\n        gopherState->conversion = GopherStateData::HTML_DIR;\n        gopherState->HTML_header_added = 0;\n        break;\n\n    case GOPHER_INDEX:\n        /* we got to convert it first */\n        gopherState->conversion = GopherStateData::HTML_INDEX_RESULT;\n        gopherState->HTML_header_added = 0;\n        break;\n\n    case GOPHER_CSO:\n        /* we got to convert it first */\n        gopherState->conversion = GopherStateData::HTML_CSO_RESULT;\n        gopherState->cso_recno = 0;\n        gopherState->HTML_header_added = 0;\n        break;\n\n    default:\n        gopherState->conversion = GopherStateData::NORMAL;\n        entry->flush();\n    }\n\n    /* Schedule read reply. */\n    AsyncCall::Pointer call =  commCbCall(5,5, \"gopherReadReply\",\n                                          CommIoCbPtrFun(gopherReadReply, gopherState));\n    entry->delayAwareRead(conn, gopherState->replybuf, BUFSIZ, call);\n}\n\n/**\n * This will be called when connect completes. Write request.\n */\nstatic void\ngopherSendRequest(int, void *data)\n{\n    GopherStateData *gopherState = (GopherStateData *)data;\n    MemBuf mb;\n    mb.init();\n\n    if (gopherState->type_id == GOPHER_CSO) {\n        const char *t = strchr(gopherState->request, '?');\n\n        if (t)\n            ++t;        /* skip the ? */\n        else\n            t = \"\";\n\n        mb.appendf(\"query %s\\r\\nquit\", t);\n    } else {\n        if (gopherState->type_id == GOPHER_INDEX) {\n            if (char *t = strchr(gopherState->request, '?'))\n                *t = '\\t';\n        }\n        mb.append(gopherState->request, strlen(gopherState->request));\n    }\n    mb.append(\"\\r\\n\", 2);\n\n    debugs(10, 5, gopherState->serverConn);\n    AsyncCall::Pointer call = commCbCall(5,5, \"gopherSendComplete\",\n                                         CommIoCbPtrFun(gopherSendComplete, gopherState));\n    Comm::Write(gopherState->serverConn, &mb, call);\n\n    if (!gopherState->entry->makePublic())\n        gopherState->entry->makePrivate(true);\n}\n\nvoid\ngopherStart(FwdState * fwd)\n{\n    GopherStateData *gopherState = new GopherStateData(fwd);\n\n    debugs(10, 3, gopherState->entry->url());\n\n    ++ statCounter.server.all.requests;\n\n    ++ statCounter.server.other.requests;\n\n    /* Parse url. */\n    gopher_request_parse(fwd->request,\n                         &gopherState->type_id, gopherState->request);\n\n    comm_add_close_handler(fwd->serverConnection()->fd, gopherStateFree, gopherState);\n\n    if (((gopherState->type_id == GOPHER_INDEX) || (gopherState->type_id == GOPHER_CSO))\n            && (strchr(gopherState->request, '?') == NULL)) {\n        /* Index URL without query word */\n        /* We have to generate search page back to client. No need for connection */\n        gopherMimeCreate(gopherState);\n\n        if (gopherState->type_id == GOPHER_INDEX) {\n            gopherState->conversion = GopherStateData::HTML_INDEX_PAGE;\n        } else {\n            if (gopherState->type_id == GOPHER_CSO) {\n                gopherState->conversion = GopherStateData::HTML_CSO_PAGE;\n            } else {\n                gopherState->conversion = GopherStateData::HTML_INDEX_PAGE;\n            }\n        }\n\n        gopherToHTML(gopherState, (char *) NULL, 0);\n        fwd->markStoredReplyAsWhole(\"gopher instant internal request satisfaction\");\n        fwd->complete();\n        return;\n    }\n\n    // XXX: Sharing open Connection with FwdState that has its own handlers/etc.\n    gopherState->serverConn = fwd->serverConnection();\n    gopherSendRequest(fwd->serverConnection()->fd, gopherState);\n    AsyncCall::Pointer timeoutCall = commCbCall(5, 4, \"gopherTimeout\",\n                                     CommTimeoutCbPtrFun(gopherTimeout, gopherState));\n    commSetConnTimeout(fwd->serverConnection(), Config.Timeout.read, timeoutCall);\n}\n\n"], "filenames": ["src/gopher.cc"], "buggy_code_start_loc": [368], "buggy_code_end_loc": [706], "fixing_code_start_loc": [367], "fixing_code_end_loc": [697], "type": "CWE-400", "message": "In Squid 3.x through 3.5.28, 4.x through 4.17, and 5.x before 5.6, due to improper buffer management, a Denial of Service can occur when processing long Gopher server responses.", "other": {"cve": {"id": "CVE-2021-46784", "sourceIdentifier": "cve@mitre.org", "published": "2022-07-17T22:15:08.737", "lastModified": "2023-01-19T20:28:13.237", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Squid 3.x through 3.5.28, 4.x through 4.17, and 5.x before 5.6, due to improper buffer management, a Denial of Service can occur when processing long Gopher server responses."}, {"lang": "es", "value": "En Squid versiones 3.x hasta 3.5.28, versiones 4.x hasta 4.17 y versiones 5.x anteriores a 5.6, debido a una administraci\u00f3n inapropiada del b\u00fafer, puede producirse una denegaci\u00f3n de servicio cuando son procesadas respuestas largas del servidor Gopher"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:squid-cache:squid:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0", "versionEndIncluding": "3.5.28", "matchCriteriaId": "FC9F2659-B37B-4E7B-AE40-B91BF3CE4E88"}, {"vulnerable": true, "criteria": "cpe:2.3:a:squid-cache:squid:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.0", "versionEndIncluding": "4.17", "matchCriteriaId": "AD4A9EF2-CA36-4C09-8A67-6AE01B16E04E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:squid-cache:squid:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.0", "versionEndExcluding": "5.6", "matchCriteriaId": "56C44696-C2E8-42DC-877F-B97943F8DD87"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA6FEEC2-9F11-4643-8827-749718254FED"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:12.0:*:*:*:*:*:*:*", "matchCriteriaId": "46D69DCC-AE4D-4EA5-861C-D60951444C6C"}]}]}], "references": [{"url": "http://www.squid-cache.org/Versions/v4/changesets/SQUID-2021_7.patch", "source": "cve@mitre.org", "tags": ["Broken Link"]}, {"url": "http://www.squid-cache.org/Versions/v5/changesets/SQUID-2021_7.patch", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/squid-cache/squid/commit/5e2ea2b13bd98f53e29964ca26bb0d602a8a12b9", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/squid-cache/squid/security/advisories/GHSA-f5cp-6rh3-284w", "source": "cve@mitre.org", "tags": ["Mitigation", "Patch", "Third Party Advisory"]}, {"url": "https://security-tracker.debian.org/tracker/CVE-2021-46784", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20221223-0007/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/squid-cache/squid/commit/5e2ea2b13bd98f53e29964ca26bb0d602a8a12b9"}}