{"buggy_code": ["/*\n * Marvell Wireless LAN device driver: WMM\n *\n * Copyright (C) 2011-2014, Marvell International Ltd.\n *\n * This software file (the \"File\") is distributed by Marvell International\n * Ltd. under the terms of the GNU General Public License Version 2, June 1991\n * (the \"License\").  You may use, redistribute and/or modify this File in\n * accordance with the terms and conditions of the License, a copy of which\n * is available by writing to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the\n * worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n *\n * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE\n * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about\n * this warranty disclaimer.\n */\n\n#include \"decl.h\"\n#include \"ioctl.h\"\n#include \"util.h\"\n#include \"fw.h\"\n#include \"main.h\"\n#include \"wmm.h\"\n#include \"11n.h\"\n\n\n/* Maximum value FW can accept for driver delay in packet transmission */\n#define DRV_PKT_DELAY_TO_FW_MAX   512\n\n\n#define WMM_QUEUED_PACKET_LOWER_LIMIT   180\n\n#define WMM_QUEUED_PACKET_UPPER_LIMIT   200\n\n/* Offset for TOS field in the IP header */\n#define IPTOS_OFFSET 5\n\nstatic bool disable_tx_amsdu;\nmodule_param(disable_tx_amsdu, bool, 0644);\n\n/* WMM information IE */\nstatic const u8 wmm_info_ie[] = { WLAN_EID_VENDOR_SPECIFIC, 0x07,\n\t0x00, 0x50, 0xf2, 0x02,\n\t0x00, 0x01, 0x00\n};\n\nstatic const u8 wmm_aci_to_qidx_map[] = { WMM_AC_BE,\n\tWMM_AC_BK,\n\tWMM_AC_VI,\n\tWMM_AC_VO\n};\n\nstatic u8 tos_to_tid[] = {\n\t/* TID DSCP_P2 DSCP_P1 DSCP_P0 WMM_AC */\n\t0x01,\t\t\t/* 0 1 0 AC_BK */\n\t0x02,\t\t\t/* 0 0 0 AC_BK */\n\t0x00,\t\t\t/* 0 0 1 AC_BE */\n\t0x03,\t\t\t/* 0 1 1 AC_BE */\n\t0x04,\t\t\t/* 1 0 0 AC_VI */\n\t0x05,\t\t\t/* 1 0 1 AC_VI */\n\t0x06,\t\t\t/* 1 1 0 AC_VO */\n\t0x07\t\t\t/* 1 1 1 AC_VO */\n};\n\nstatic u8 ac_to_tid[4][2] = { {1, 2}, {0, 3}, {4, 5}, {6, 7} };\n\n/*\n * This function debug prints the priority parameters for a WMM AC.\n */\nstatic void\nmwifiex_wmm_ac_debug_print(const struct ieee_types_wmm_ac_parameters *ac_param)\n{\n\tconst char *ac_str[] = { \"BK\", \"BE\", \"VI\", \"VO\" };\n\n\tpr_debug(\"info: WMM AC_%s: ACI=%d, ACM=%d, Aifsn=%d, \"\n\t\t \"EcwMin=%d, EcwMax=%d, TxopLimit=%d\\n\",\n\t\t ac_str[wmm_aci_to_qidx_map[(ac_param->aci_aifsn_bitmap\n\t\t\t\t\t     & MWIFIEX_ACI) >> 5]],\n\t\t (ac_param->aci_aifsn_bitmap & MWIFIEX_ACI) >> 5,\n\t\t (ac_param->aci_aifsn_bitmap & MWIFIEX_ACM) >> 4,\n\t\t ac_param->aci_aifsn_bitmap & MWIFIEX_AIFSN,\n\t\t ac_param->ecw_bitmap & MWIFIEX_ECW_MIN,\n\t\t (ac_param->ecw_bitmap & MWIFIEX_ECW_MAX) >> 4,\n\t\t le16_to_cpu(ac_param->tx_op_limit));\n}\n\n/*\n * This function allocates a route address list.\n *\n * The function also initializes the list with the provided RA.\n */\nstatic struct mwifiex_ra_list_tbl *\nmwifiex_wmm_allocate_ralist_node(struct mwifiex_adapter *adapter, const u8 *ra)\n{\n\tstruct mwifiex_ra_list_tbl *ra_list;\n\n\tra_list = kzalloc(sizeof(struct mwifiex_ra_list_tbl), GFP_ATOMIC);\n\tif (!ra_list)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&ra_list->list);\n\tskb_queue_head_init(&ra_list->skb_head);\n\n\tmemcpy(ra_list->ra, ra, ETH_ALEN);\n\n\tra_list->total_pkt_count = 0;\n\n\tmwifiex_dbg(adapter, INFO, \"info: allocated ra_list %p\\n\", ra_list);\n\n\treturn ra_list;\n}\n\n/* This function returns random no between 16 and 32 to be used as threshold\n * for no of packets after which BA setup is initiated.\n */\nstatic u8 mwifiex_get_random_ba_threshold(void)\n{\n\tu64 ns;\n\t/* setup ba_packet_threshold here random number between\n\t * [BA_SETUP_PACKET_OFFSET,\n\t * BA_SETUP_PACKET_OFFSET+BA_SETUP_MAX_PACKET_THRESHOLD-1]\n\t */\n\tns = ktime_get_ns();\n\tns += (ns >> 32) + (ns >> 16);\n\n\treturn ((u8)ns % BA_SETUP_MAX_PACKET_THRESHOLD) + BA_SETUP_PACKET_OFFSET;\n}\n\n/*\n * This function allocates and adds a RA list for all TIDs\n * with the given RA.\n */\nvoid mwifiex_ralist_add(struct mwifiex_private *priv, const u8 *ra)\n{\n\tint i;\n\tstruct mwifiex_ra_list_tbl *ra_list;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct mwifiex_sta_node *node;\n\n\n\tfor (i = 0; i < MAX_NUM_TID; ++i) {\n\t\tra_list = mwifiex_wmm_allocate_ralist_node(adapter, ra);\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"info: created ra_list %p\\n\", ra_list);\n\n\t\tif (!ra_list)\n\t\t\tbreak;\n\n\t\tra_list->is_11n_enabled = 0;\n\t\tra_list->tdls_link = false;\n\t\tra_list->ba_status = BA_SETUP_NONE;\n\t\tra_list->amsdu_in_ampdu = false;\n\t\tif (!mwifiex_queuing_ra_based(priv)) {\n\t\t\tif (mwifiex_is_tdls_link_setup\n\t\t\t\t(mwifiex_get_tdls_link_status(priv, ra))) {\n\t\t\t\tra_list->tdls_link = true;\n\t\t\t\tra_list->is_11n_enabled =\n\t\t\t\t\tmwifiex_tdls_peer_11n_enabled(priv, ra);\n\t\t\t} else {\n\t\t\t\tra_list->is_11n_enabled = IS_11N_ENABLED(priv);\n\t\t\t}\n\t\t} else {\n\t\t\tspin_lock_bh(&priv->sta_list_spinlock);\n\t\t\tnode = mwifiex_get_sta_entry(priv, ra);\n\t\t\tif (node)\n\t\t\t\tra_list->tx_paused = node->tx_pause;\n\t\t\tra_list->is_11n_enabled =\n\t\t\t\t      mwifiex_is_sta_11n_enabled(priv, node);\n\t\t\tif (ra_list->is_11n_enabled)\n\t\t\t\tra_list->max_amsdu = node->max_amsdu;\n\t\t\tspin_unlock_bh(&priv->sta_list_spinlock);\n\t\t}\n\n\t\tmwifiex_dbg(adapter, DATA, \"data: ralist %p: is_11n_enabled=%d\\n\",\n\t\t\t    ra_list, ra_list->is_11n_enabled);\n\n\t\tif (ra_list->is_11n_enabled) {\n\t\t\tra_list->ba_pkt_count = 0;\n\t\t\tra_list->ba_packet_thr =\n\t\t\t\t\t      mwifiex_get_random_ba_threshold();\n\t\t}\n\t\tlist_add_tail(&ra_list->list,\n\t\t\t      &priv->wmm.tid_tbl_ptr[i].ra_list);\n\t}\n}\n\n/*\n * This function sets the WMM queue priorities to their default values.\n */\nstatic void mwifiex_wmm_default_queue_priorities(struct mwifiex_private *priv)\n{\n\t/* Default queue priorities: VO->VI->BE->BK */\n\tpriv->wmm.queue_priority[0] = WMM_AC_VO;\n\tpriv->wmm.queue_priority[1] = WMM_AC_VI;\n\tpriv->wmm.queue_priority[2] = WMM_AC_BE;\n\tpriv->wmm.queue_priority[3] = WMM_AC_BK;\n}\n\n/*\n * This function map ACs to TIDs.\n */\nstatic void\nmwifiex_wmm_queue_priorities_tid(struct mwifiex_private *priv)\n{\n\tstruct mwifiex_wmm_desc *wmm = &priv->wmm;\n\tu8 *queue_priority = wmm->queue_priority;\n\tint i;\n\n\tfor (i = 0; i < 4; ++i) {\n\t\ttos_to_tid[7 - (i * 2)] = ac_to_tid[queue_priority[i]][1];\n\t\ttos_to_tid[6 - (i * 2)] = ac_to_tid[queue_priority[i]][0];\n\t}\n\n\tfor (i = 0; i < MAX_NUM_TID; ++i)\n\t\tpriv->tos_to_tid_inv[tos_to_tid[i]] = (u8)i;\n\n\tatomic_set(&wmm->highest_queued_prio, HIGH_PRIO_TID);\n}\n\n/*\n * This function initializes WMM priority queues.\n */\nvoid\nmwifiex_wmm_setup_queue_priorities(struct mwifiex_private *priv,\n\t\t\t\t   struct ieee_types_wmm_parameter *wmm_ie)\n{\n\tu16 cw_min, avg_back_off, tmp[4];\n\tu32 i, j, num_ac;\n\tu8 ac_idx;\n\n\tif (!wmm_ie || !priv->wmm_enabled) {\n\t\t/* WMM is not enabled, just set the defaults and return */\n\t\tmwifiex_wmm_default_queue_priorities(priv);\n\t\treturn;\n\t}\n\n\tmwifiex_dbg(priv->adapter, INFO,\n\t\t    \"info: WMM Parameter IE: version=%d,\\t\"\n\t\t    \"qos_info Parameter Set Count=%d, Reserved=%#x\\n\",\n\t\t    wmm_ie->version, wmm_ie->qos_info_bitmap &\n\t\t    IEEE80211_WMM_IE_AP_QOSINFO_PARAM_SET_CNT_MASK,\n\t\t    wmm_ie->reserved);\n\n\tfor (num_ac = 0; num_ac < ARRAY_SIZE(wmm_ie->ac_params); num_ac++) {\n\t\tu8 ecw = wmm_ie->ac_params[num_ac].ecw_bitmap;\n\t\tu8 aci_aifsn = wmm_ie->ac_params[num_ac].aci_aifsn_bitmap;\n\t\tcw_min = (1 << (ecw & MWIFIEX_ECW_MIN)) - 1;\n\t\tavg_back_off = (cw_min >> 1) + (aci_aifsn & MWIFIEX_AIFSN);\n\n\t\tac_idx = wmm_aci_to_qidx_map[(aci_aifsn & MWIFIEX_ACI) >> 5];\n\t\tpriv->wmm.queue_priority[ac_idx] = ac_idx;\n\t\ttmp[ac_idx] = avg_back_off;\n\n\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t    \"info: WMM: CWmax=%d CWmin=%d Avg Back-off=%d\\n\",\n\t\t\t    (1 << ((ecw & MWIFIEX_ECW_MAX) >> 4)) - 1,\n\t\t\t    cw_min, avg_back_off);\n\t\tmwifiex_wmm_ac_debug_print(&wmm_ie->ac_params[num_ac]);\n\t}\n\n\t/* Bubble sort */\n\tfor (i = 0; i < num_ac; i++) {\n\t\tfor (j = 1; j < num_ac - i; j++) {\n\t\t\tif (tmp[j - 1] > tmp[j]) {\n\t\t\t\tswap(tmp[j - 1], tmp[j]);\n\t\t\t\tswap(priv->wmm.queue_priority[j - 1],\n\t\t\t\t     priv->wmm.queue_priority[j]);\n\t\t\t} else if (tmp[j - 1] == tmp[j]) {\n\t\t\t\tif (priv->wmm.queue_priority[j - 1]\n\t\t\t\t    < priv->wmm.queue_priority[j])\n\t\t\t\t\tswap(priv->wmm.queue_priority[j - 1],\n\t\t\t\t\t     priv->wmm.queue_priority[j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tmwifiex_wmm_queue_priorities_tid(priv);\n}\n\n/*\n * This function evaluates whether or not an AC is to be downgraded.\n *\n * In case the AC is not enabled, the highest AC is returned that is\n * enabled and does not require admission control.\n */\nstatic enum mwifiex_wmm_ac_e\nmwifiex_wmm_eval_downgrade_ac(struct mwifiex_private *priv,\n\t\t\t      enum mwifiex_wmm_ac_e eval_ac)\n{\n\tint down_ac;\n\tenum mwifiex_wmm_ac_e ret_ac;\n\tstruct mwifiex_wmm_ac_status *ac_status;\n\n\tac_status = &priv->wmm.ac_status[eval_ac];\n\n\tif (!ac_status->disabled)\n\t\t/* Okay to use this AC, its enabled */\n\t\treturn eval_ac;\n\n\t/* Setup a default return value of the lowest priority */\n\tret_ac = WMM_AC_BK;\n\n\t/*\n\t *  Find the highest AC that is enabled and does not require\n\t *  admission control. The spec disallows downgrading to an AC,\n\t *  which is enabled due to a completed admission control.\n\t *  Unadmitted traffic is not to be sent on an AC with admitted\n\t *  traffic.\n\t */\n\tfor (down_ac = WMM_AC_BK; down_ac < eval_ac; down_ac++) {\n\t\tac_status = &priv->wmm.ac_status[down_ac];\n\n\t\tif (!ac_status->disabled && !ac_status->flow_required)\n\t\t\t/* AC is enabled and does not require admission\n\t\t\t   control */\n\t\t\tret_ac = (enum mwifiex_wmm_ac_e) down_ac;\n\t}\n\n\treturn ret_ac;\n}\n\n/*\n * This function downgrades WMM priority queue.\n */\nvoid\nmwifiex_wmm_setup_ac_downgrade(struct mwifiex_private *priv)\n{\n\tint ac_val;\n\n\tmwifiex_dbg(priv->adapter, INFO, \"info: WMM: AC Priorities:\\t\"\n\t\t    \"BK(0), BE(1), VI(2), VO(3)\\n\");\n\n\tif (!priv->wmm_enabled) {\n\t\t/* WMM is not enabled, default priorities */\n\t\tfor (ac_val = WMM_AC_BK; ac_val <= WMM_AC_VO; ac_val++)\n\t\t\tpriv->wmm.ac_down_graded_vals[ac_val] =\n\t\t\t\t\t\t(enum mwifiex_wmm_ac_e) ac_val;\n\t} else {\n\t\tfor (ac_val = WMM_AC_BK; ac_val <= WMM_AC_VO; ac_val++) {\n\t\t\tpriv->wmm.ac_down_graded_vals[ac_val]\n\t\t\t\t= mwifiex_wmm_eval_downgrade_ac(priv,\n\t\t\t\t\t\t(enum mwifiex_wmm_ac_e) ac_val);\n\t\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t\t    \"info: WMM: AC PRIO %d maps to %d\\n\",\n\t\t\t\t    ac_val,\n\t\t\t\t    priv->wmm.ac_down_graded_vals[ac_val]);\n\t\t}\n\t}\n}\n\n/*\n * This function converts the IP TOS field to an WMM AC\n * Queue assignment.\n */\nstatic enum mwifiex_wmm_ac_e\nmwifiex_wmm_convert_tos_to_ac(struct mwifiex_adapter *adapter, u32 tos)\n{\n\t/* Map of TOS UP values to WMM AC */\n\tstatic const enum mwifiex_wmm_ac_e tos_to_ac[] = {\n\t\tWMM_AC_BE,\n\t\tWMM_AC_BK,\n\t\tWMM_AC_BK,\n\t\tWMM_AC_BE,\n\t\tWMM_AC_VI,\n\t\tWMM_AC_VI,\n\t\tWMM_AC_VO,\n\t\tWMM_AC_VO\n\t};\n\n\tif (tos >= ARRAY_SIZE(tos_to_ac))\n\t\treturn WMM_AC_BE;\n\n\treturn tos_to_ac[tos];\n}\n\n/*\n * This function evaluates a given TID and downgrades it to a lower\n * TID if the WMM Parameter IE received from the AP indicates that the\n * AP is disabled (due to call admission control (ACM bit). Mapping\n * of TID to AC is taken care of internally.\n */\nu8 mwifiex_wmm_downgrade_tid(struct mwifiex_private *priv, u32 tid)\n{\n\tenum mwifiex_wmm_ac_e ac, ac_down;\n\tu8 new_tid;\n\n\tac = mwifiex_wmm_convert_tos_to_ac(priv->adapter, tid);\n\tac_down = priv->wmm.ac_down_graded_vals[ac];\n\n\t/* Send the index to tid array, picking from the array will be\n\t * taken care by dequeuing function\n\t */\n\tnew_tid = ac_to_tid[ac_down][tid % 2];\n\n\treturn new_tid;\n}\n\n/*\n * This function initializes the WMM state information and the\n * WMM data path queues.\n */\nvoid\nmwifiex_wmm_init(struct mwifiex_adapter *adapter)\n{\n\tint i, j;\n\tstruct mwifiex_private *priv;\n\n\tfor (j = 0; j < adapter->priv_num; ++j) {\n\t\tpriv = adapter->priv[j];\n\t\tif (!priv)\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < MAX_NUM_TID; ++i) {\n\t\t\tif (!disable_tx_amsdu &&\n\t\t\t    adapter->tx_buf_size > MWIFIEX_TX_DATA_BUF_SIZE_2K)\n\t\t\t\tpriv->aggr_prio_tbl[i].amsdu =\n\t\t\t\t\t\t\tpriv->tos_to_tid_inv[i];\n\t\t\telse\n\t\t\t\tpriv->aggr_prio_tbl[i].amsdu =\n\t\t\t\t\t\t\tBA_STREAM_NOT_ALLOWED;\n\t\t\tpriv->aggr_prio_tbl[i].ampdu_ap =\n\t\t\t\t\t\t\tpriv->tos_to_tid_inv[i];\n\t\t\tpriv->aggr_prio_tbl[i].ampdu_user =\n\t\t\t\t\t\t\tpriv->tos_to_tid_inv[i];\n\t\t}\n\n\t\tpriv->aggr_prio_tbl[6].amsdu\n\t\t\t\t\t= priv->aggr_prio_tbl[6].ampdu_ap\n\t\t\t\t\t= priv->aggr_prio_tbl[6].ampdu_user\n\t\t\t\t\t= BA_STREAM_NOT_ALLOWED;\n\n\t\tpriv->aggr_prio_tbl[7].amsdu = priv->aggr_prio_tbl[7].ampdu_ap\n\t\t\t\t\t= priv->aggr_prio_tbl[7].ampdu_user\n\t\t\t\t\t= BA_STREAM_NOT_ALLOWED;\n\n\t\tmwifiex_set_ba_params(priv);\n\t\tmwifiex_reset_11n_rx_seq_num(priv);\n\n\t\tpriv->wmm.drv_pkt_delay_max = MWIFIEX_WMM_DRV_DELAY_MAX;\n\t\tatomic_set(&priv->wmm.tx_pkts_queued, 0);\n\t\tatomic_set(&priv->wmm.highest_queued_prio, HIGH_PRIO_TID);\n\t}\n}\n\nint mwifiex_bypass_txlist_empty(struct mwifiex_adapter *adapter)\n{\n\tstruct mwifiex_private *priv;\n\tint i;\n\n\tfor (i = 0; i < adapter->priv_num; i++) {\n\t\tpriv = adapter->priv[i];\n\t\tif (!priv)\n\t\t\tcontinue;\n\t\tif (adapter->if_ops.is_port_ready &&\n\t\t    !adapter->if_ops.is_port_ready(priv))\n\t\t\tcontinue;\n\t\tif (!skb_queue_empty(&priv->bypass_txq))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n/*\n * This function checks if WMM Tx queue is empty.\n */\nint\nmwifiex_wmm_lists_empty(struct mwifiex_adapter *adapter)\n{\n\tint i;\n\tstruct mwifiex_private *priv;\n\n\tfor (i = 0; i < adapter->priv_num; ++i) {\n\t\tpriv = adapter->priv[i];\n\t\tif (!priv)\n\t\t\tcontinue;\n\t\tif (!priv->port_open &&\n\t\t    (priv->bss_mode != NL80211_IFTYPE_ADHOC))\n\t\t\tcontinue;\n\t\tif (adapter->if_ops.is_port_ready &&\n\t\t    !adapter->if_ops.is_port_ready(priv))\n\t\t\tcontinue;\n\t\tif (atomic_read(&priv->wmm.tx_pkts_queued))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n/*\n * This function deletes all packets in an RA list node.\n *\n * The packet sent completion callback handler are called with\n * status failure, after they are dequeued to ensure proper\n * cleanup. The RA list node itself is freed at the end.\n */\nstatic void\nmwifiex_wmm_del_pkts_in_ralist_node(struct mwifiex_private *priv,\n\t\t\t\t    struct mwifiex_ra_list_tbl *ra_list)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct sk_buff *skb, *tmp;\n\n\tskb_queue_walk_safe(&ra_list->skb_head, skb, tmp) {\n\t\tskb_unlink(skb, &ra_list->skb_head);\n\t\tmwifiex_write_data_complete(adapter, skb, 0, -1);\n\t}\n}\n\n/*\n * This function deletes all packets in an RA list.\n *\n * Each nodes in the RA list are freed individually first, and then\n * the RA list itself is freed.\n */\nstatic void\nmwifiex_wmm_del_pkts_in_ralist(struct mwifiex_private *priv,\n\t\t\t       struct list_head *ra_list_head)\n{\n\tstruct mwifiex_ra_list_tbl *ra_list;\n\n\tlist_for_each_entry(ra_list, ra_list_head, list)\n\t\tmwifiex_wmm_del_pkts_in_ralist_node(priv, ra_list);\n}\n\n/*\n * This function deletes all packets in all RA lists.\n */\nstatic void mwifiex_wmm_cleanup_queues(struct mwifiex_private *priv)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_NUM_TID; i++)\n\t\tmwifiex_wmm_del_pkts_in_ralist(priv, &priv->wmm.tid_tbl_ptr[i].\n\t\t\t\t\t\t\t\t       ra_list);\n\n\tatomic_set(&priv->wmm.tx_pkts_queued, 0);\n\tatomic_set(&priv->wmm.highest_queued_prio, HIGH_PRIO_TID);\n}\n\n/*\n * This function deletes all route addresses from all RA lists.\n */\nstatic void mwifiex_wmm_delete_all_ralist(struct mwifiex_private *priv)\n{\n\tstruct mwifiex_ra_list_tbl *ra_list, *tmp_node;\n\tint i;\n\n\tfor (i = 0; i < MAX_NUM_TID; ++i) {\n\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t    \"info: ra_list: freeing buf for tid %d\\n\", i);\n\t\tlist_for_each_entry_safe(ra_list, tmp_node,\n\t\t\t\t\t &priv->wmm.tid_tbl_ptr[i].ra_list,\n\t\t\t\t\t list) {\n\t\t\tlist_del(&ra_list->list);\n\t\t\tkfree(ra_list);\n\t\t}\n\n\t\tINIT_LIST_HEAD(&priv->wmm.tid_tbl_ptr[i].ra_list);\n\t}\n}\n\nstatic int mwifiex_free_ack_frame(int id, void *p, void *data)\n{\n\tpr_warn(\"Have pending ack frames!\\n\");\n\tkfree_skb(p);\n\treturn 0;\n}\n\n/*\n * This function cleans up the Tx and Rx queues.\n *\n * Cleanup includes -\n *      - All packets in RA lists\n *      - All entries in Rx reorder table\n *      - All entries in Tx BA stream table\n *      - MPA buffer (if required)\n *      - All RA lists\n */\nvoid\nmwifiex_clean_txrx(struct mwifiex_private *priv)\n{\n\tstruct sk_buff *skb, *tmp;\n\n\tmwifiex_11n_cleanup_reorder_tbl(priv);\n\tspin_lock_bh(&priv->wmm.ra_list_spinlock);\n\n\tmwifiex_wmm_cleanup_queues(priv);\n\tmwifiex_11n_delete_all_tx_ba_stream_tbl(priv);\n\n\tif (priv->adapter->if_ops.cleanup_mpa_buf)\n\t\tpriv->adapter->if_ops.cleanup_mpa_buf(priv->adapter);\n\n\tmwifiex_wmm_delete_all_ralist(priv);\n\tmemcpy(tos_to_tid, ac_to_tid, sizeof(tos_to_tid));\n\n\tif (priv->adapter->if_ops.clean_pcie_ring &&\n\t    !test_bit(MWIFIEX_SURPRISE_REMOVED, &priv->adapter->work_flags))\n\t\tpriv->adapter->if_ops.clean_pcie_ring(priv->adapter);\n\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n\n\tskb_queue_walk_safe(&priv->tdls_txq, skb, tmp) {\n\t\tskb_unlink(skb, &priv->tdls_txq);\n\t\tmwifiex_write_data_complete(priv->adapter, skb, 0, -1);\n\t}\n\n\tskb_queue_walk_safe(&priv->bypass_txq, skb, tmp) {\n\t\tskb_unlink(skb, &priv->bypass_txq);\n\t\tmwifiex_write_data_complete(priv->adapter, skb, 0, -1);\n\t}\n\tatomic_set(&priv->adapter->bypass_tx_pending, 0);\n\n\tidr_for_each(&priv->ack_status_frames, mwifiex_free_ack_frame, NULL);\n\tidr_destroy(&priv->ack_status_frames);\n}\n\n/*\n * This function retrieves a particular RA list node, matching with the\n * given TID and RA address.\n */\nstruct mwifiex_ra_list_tbl *\nmwifiex_wmm_get_ralist_node(struct mwifiex_private *priv, u8 tid,\n\t\t\t    const u8 *ra_addr)\n{\n\tstruct mwifiex_ra_list_tbl *ra_list;\n\n\tlist_for_each_entry(ra_list, &priv->wmm.tid_tbl_ptr[tid].ra_list,\n\t\t\t    list) {\n\t\tif (!memcmp(ra_list->ra, ra_addr, ETH_ALEN))\n\t\t\treturn ra_list;\n\t}\n\n\treturn NULL;\n}\n\nvoid mwifiex_update_ralist_tx_pause(struct mwifiex_private *priv, u8 *mac,\n\t\t\t\t    u8 tx_pause)\n{\n\tstruct mwifiex_ra_list_tbl *ra_list;\n\tu32 pkt_cnt = 0, tx_pkts_queued;\n\tint i;\n\n\tspin_lock_bh(&priv->wmm.ra_list_spinlock);\n\n\tfor (i = 0; i < MAX_NUM_TID; ++i) {\n\t\tra_list = mwifiex_wmm_get_ralist_node(priv, i, mac);\n\t\tif (ra_list && ra_list->tx_paused != tx_pause) {\n\t\t\tpkt_cnt += ra_list->total_pkt_count;\n\t\t\tra_list->tx_paused = tx_pause;\n\t\t\tif (tx_pause)\n\t\t\t\tpriv->wmm.pkts_paused[i] +=\n\t\t\t\t\tra_list->total_pkt_count;\n\t\t\telse\n\t\t\t\tpriv->wmm.pkts_paused[i] -=\n\t\t\t\t\tra_list->total_pkt_count;\n\t\t}\n\t}\n\n\tif (pkt_cnt) {\n\t\ttx_pkts_queued = atomic_read(&priv->wmm.tx_pkts_queued);\n\t\tif (tx_pause)\n\t\t\ttx_pkts_queued -= pkt_cnt;\n\t\telse\n\t\t\ttx_pkts_queued += pkt_cnt;\n\n\t\tatomic_set(&priv->wmm.tx_pkts_queued, tx_pkts_queued);\n\t\tatomic_set(&priv->wmm.highest_queued_prio, HIGH_PRIO_TID);\n\t}\n\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n}\n\n/* This function updates non-tdls peer ralist tx_pause while\n * tdls channel switching\n */\nvoid mwifiex_update_ralist_tx_pause_in_tdls_cs(struct mwifiex_private *priv,\n\t\t\t\t\t       u8 *mac, u8 tx_pause)\n{\n\tstruct mwifiex_ra_list_tbl *ra_list;\n\tu32 pkt_cnt = 0, tx_pkts_queued;\n\tint i;\n\n\tspin_lock_bh(&priv->wmm.ra_list_spinlock);\n\n\tfor (i = 0; i < MAX_NUM_TID; ++i) {\n\t\tlist_for_each_entry(ra_list, &priv->wmm.tid_tbl_ptr[i].ra_list,\n\t\t\t\t    list) {\n\t\t\tif (!memcmp(ra_list->ra, mac, ETH_ALEN))\n\t\t\t\tcontinue;\n\n\t\t\tif (ra_list->tx_paused != tx_pause) {\n\t\t\t\tpkt_cnt += ra_list->total_pkt_count;\n\t\t\t\tra_list->tx_paused = tx_pause;\n\t\t\t\tif (tx_pause)\n\t\t\t\t\tpriv->wmm.pkts_paused[i] +=\n\t\t\t\t\t\tra_list->total_pkt_count;\n\t\t\t\telse\n\t\t\t\t\tpriv->wmm.pkts_paused[i] -=\n\t\t\t\t\t\tra_list->total_pkt_count;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (pkt_cnt) {\n\t\ttx_pkts_queued = atomic_read(&priv->wmm.tx_pkts_queued);\n\t\tif (tx_pause)\n\t\t\ttx_pkts_queued -= pkt_cnt;\n\t\telse\n\t\t\ttx_pkts_queued += pkt_cnt;\n\n\t\tatomic_set(&priv->wmm.tx_pkts_queued, tx_pkts_queued);\n\t\tatomic_set(&priv->wmm.highest_queued_prio, HIGH_PRIO_TID);\n\t}\n\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n}\n\n/*\n * This function retrieves an RA list node for a given TID and\n * RA address pair.\n *\n * If no such node is found, a new node is added first and then\n * retrieved.\n */\nstruct mwifiex_ra_list_tbl *\nmwifiex_wmm_get_queue_raptr(struct mwifiex_private *priv, u8 tid,\n\t\t\t    const u8 *ra_addr)\n{\n\tstruct mwifiex_ra_list_tbl *ra_list;\n\n\tra_list = mwifiex_wmm_get_ralist_node(priv, tid, ra_addr);\n\tif (ra_list)\n\t\treturn ra_list;\n\tmwifiex_ralist_add(priv, ra_addr);\n\n\treturn mwifiex_wmm_get_ralist_node(priv, tid, ra_addr);\n}\n\n/*\n * This function deletes RA list nodes for given mac for all TIDs.\n * Function also decrements TX pending count accordingly.\n */\nvoid\nmwifiex_wmm_del_peer_ra_list(struct mwifiex_private *priv, const u8 *ra_addr)\n{\n\tstruct mwifiex_ra_list_tbl *ra_list;\n\tint i;\n\n\tspin_lock_bh(&priv->wmm.ra_list_spinlock);\n\n\tfor (i = 0; i < MAX_NUM_TID; ++i) {\n\t\tra_list = mwifiex_wmm_get_ralist_node(priv, i, ra_addr);\n\n\t\tif (!ra_list)\n\t\t\tcontinue;\n\t\tmwifiex_wmm_del_pkts_in_ralist_node(priv, ra_list);\n\t\tif (ra_list->tx_paused)\n\t\t\tpriv->wmm.pkts_paused[i] -= ra_list->total_pkt_count;\n\t\telse\n\t\t\tatomic_sub(ra_list->total_pkt_count,\n\t\t\t\t   &priv->wmm.tx_pkts_queued);\n\t\tlist_del(&ra_list->list);\n\t\tkfree(ra_list);\n\t}\n\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n}\n\n/*\n * This function checks if a particular RA list node exists in a given TID\n * table index.\n */\nint\nmwifiex_is_ralist_valid(struct mwifiex_private *priv,\n\t\t\tstruct mwifiex_ra_list_tbl *ra_list, int ptr_index)\n{\n\tstruct mwifiex_ra_list_tbl *rlist;\n\n\tlist_for_each_entry(rlist, &priv->wmm.tid_tbl_ptr[ptr_index].ra_list,\n\t\t\t    list) {\n\t\tif (rlist == ra_list)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/*\n * This function adds a packet to bypass TX queue.\n * This is special TX queue for packets which can be sent even when port_open\n * is false.\n */\nvoid\nmwifiex_wmm_add_buf_bypass_txqueue(struct mwifiex_private *priv,\n\t\t\t\t   struct sk_buff *skb)\n{\n\tskb_queue_tail(&priv->bypass_txq, skb);\n}\n\n/*\n * This function adds a packet to WMM queue.\n *\n * In disconnected state the packet is immediately dropped and the\n * packet send completion callback is called with status failure.\n *\n * Otherwise, the correct RA list node is located and the packet\n * is queued at the list tail.\n */\nvoid\nmwifiex_wmm_add_buf_txqueue(struct mwifiex_private *priv,\n\t\t\t    struct sk_buff *skb)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tu32 tid;\n\tstruct mwifiex_ra_list_tbl *ra_list;\n\tu8 ra[ETH_ALEN], tid_down;\n\tstruct list_head list_head;\n\tint tdls_status = TDLS_NOT_SETUP;\n\tstruct ethhdr *eth_hdr = (struct ethhdr *)skb->data;\n\tstruct mwifiex_txinfo *tx_info = MWIFIEX_SKB_TXCB(skb);\n\n\tmemcpy(ra, eth_hdr->h_dest, ETH_ALEN);\n\n\tif (GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA &&\n\t    ISSUPP_TDLS_ENABLED(adapter->fw_cap_info)) {\n\t\tif (ntohs(eth_hdr->h_proto) == ETH_P_TDLS)\n\t\t\tmwifiex_dbg(adapter, DATA,\n\t\t\t\t    \"TDLS setup packet for %pM.\\t\"\n\t\t\t\t    \"Don't block\\n\", ra);\n\t\telse if (memcmp(priv->cfg_bssid, ra, ETH_ALEN))\n\t\t\ttdls_status = mwifiex_get_tdls_link_status(priv, ra);\n\t}\n\n\tif (!priv->media_connected && !mwifiex_is_skb_mgmt_frame(skb)) {\n\t\tmwifiex_dbg(adapter, DATA, \"data: drop packet in disconnect\\n\");\n\t\tmwifiex_write_data_complete(adapter, skb, 0, -1);\n\t\treturn;\n\t}\n\n\ttid = skb->priority;\n\n\tspin_lock_bh(&priv->wmm.ra_list_spinlock);\n\n\ttid_down = mwifiex_wmm_downgrade_tid(priv, tid);\n\n\t/* In case of infra as we have already created the list during\n\t   association we just don't have to call get_queue_raptr, we will\n\t   have only 1 raptr for a tid in case of infra */\n\tif (!mwifiex_queuing_ra_based(priv) &&\n\t    !mwifiex_is_skb_mgmt_frame(skb)) {\n\t\tswitch (tdls_status) {\n\t\tcase TDLS_SETUP_COMPLETE:\n\t\tcase TDLS_CHAN_SWITCHING:\n\t\tcase TDLS_IN_BASE_CHAN:\n\t\tcase TDLS_IN_OFF_CHAN:\n\t\t\tra_list = mwifiex_wmm_get_queue_raptr(priv, tid_down,\n\t\t\t\t\t\t\t      ra);\n\t\t\ttx_info->flags |= MWIFIEX_BUF_FLAG_TDLS_PKT;\n\t\t\tbreak;\n\t\tcase TDLS_SETUP_INPROGRESS:\n\t\t\tskb_queue_tail(&priv->tdls_txq, skb);\n\t\t\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n\t\t\treturn;\n\t\tdefault:\n\t\t\tlist_head = priv->wmm.tid_tbl_ptr[tid_down].ra_list;\n\t\t\tra_list = list_first_entry_or_null(&list_head,\n\t\t\t\t\tstruct mwifiex_ra_list_tbl, list);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tmemcpy(ra, skb->data, ETH_ALEN);\n\t\tif (ra[0] & 0x01 || mwifiex_is_skb_mgmt_frame(skb))\n\t\t\teth_broadcast_addr(ra);\n\t\tra_list = mwifiex_wmm_get_queue_raptr(priv, tid_down, ra);\n\t}\n\n\tif (!ra_list) {\n\t\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n\t\tmwifiex_write_data_complete(adapter, skb, 0, -1);\n\t\treturn;\n\t}\n\n\tskb_queue_tail(&ra_list->skb_head, skb);\n\n\tra_list->ba_pkt_count++;\n\tra_list->total_pkt_count++;\n\n\tif (atomic_read(&priv->wmm.highest_queued_prio) <\n\t\t\t\t\t\tpriv->tos_to_tid_inv[tid_down])\n\t\tatomic_set(&priv->wmm.highest_queued_prio,\n\t\t\t   priv->tos_to_tid_inv[tid_down]);\n\n\tif (ra_list->tx_paused)\n\t\tpriv->wmm.pkts_paused[tid_down]++;\n\telse\n\t\tatomic_inc(&priv->wmm.tx_pkts_queued);\n\n\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n}\n\n/*\n * This function processes the get WMM status command response from firmware.\n *\n * The response may contain multiple TLVs -\n *      - AC Queue status TLVs\n *      - Current WMM Parameter IE TLV\n *      - Admission Control action frame TLVs\n *\n * This function parses the TLVs and then calls further specific functions\n * to process any changes in the queue prioritize or state.\n */\nint mwifiex_ret_wmm_get_status(struct mwifiex_private *priv,\n\t\t\t       const struct host_cmd_ds_command *resp)\n{\n\tu8 *curr = (u8 *) &resp->params.get_wmm_status;\n\tuint16_t resp_len = le16_to_cpu(resp->size), tlv_len;\n\tint mask = IEEE80211_WMM_IE_AP_QOSINFO_PARAM_SET_CNT_MASK;\n\tbool valid = true;\n\n\tstruct mwifiex_ie_types_data *tlv_hdr;\n\tstruct mwifiex_ie_types_wmm_queue_status *tlv_wmm_qstatus;\n\tstruct ieee_types_wmm_parameter *wmm_param_ie = NULL;\n\tstruct mwifiex_wmm_ac_status *ac_status;\n\n\tmwifiex_dbg(priv->adapter, INFO,\n\t\t    \"info: WMM: WMM_GET_STATUS cmdresp received: %d\\n\",\n\t\t    resp_len);\n\n\twhile ((resp_len >= sizeof(tlv_hdr->header)) && valid) {\n\t\ttlv_hdr = (struct mwifiex_ie_types_data *) curr;\n\t\ttlv_len = le16_to_cpu(tlv_hdr->header.len);\n\n\t\tif (resp_len < tlv_len + sizeof(tlv_hdr->header))\n\t\t\tbreak;\n\n\t\tswitch (le16_to_cpu(tlv_hdr->header.type)) {\n\t\tcase TLV_TYPE_WMMQSTATUS:\n\t\t\ttlv_wmm_qstatus =\n\t\t\t\t(struct mwifiex_ie_types_wmm_queue_status *)\n\t\t\t\ttlv_hdr;\n\t\t\tmwifiex_dbg(priv->adapter, CMD,\n\t\t\t\t    \"info: CMD_RESP: WMM_GET_STATUS:\\t\"\n\t\t\t\t    \"QSTATUS TLV: %d, %d, %d\\n\",\n\t\t\t\t    tlv_wmm_qstatus->queue_index,\n\t\t\t\t    tlv_wmm_qstatus->flow_required,\n\t\t\t\t    tlv_wmm_qstatus->disabled);\n\n\t\t\tac_status = &priv->wmm.ac_status[tlv_wmm_qstatus->\n\t\t\t\t\t\t\t queue_index];\n\t\t\tac_status->disabled = tlv_wmm_qstatus->disabled;\n\t\t\tac_status->flow_required =\n\t\t\t\t\t\ttlv_wmm_qstatus->flow_required;\n\t\t\tac_status->flow_created = tlv_wmm_qstatus->flow_created;\n\t\t\tbreak;\n\n\t\tcase WLAN_EID_VENDOR_SPECIFIC:\n\t\t\t/*\n\t\t\t * Point the regular IEEE IE 2 bytes into the Marvell IE\n\t\t\t *   and setup the IEEE IE type and length byte fields\n\t\t\t */\n\n\t\t\twmm_param_ie =\n\t\t\t\t(struct ieee_types_wmm_parameter *) (curr +\n\t\t\t\t\t\t\t\t    2);\n\t\t\twmm_param_ie->vend_hdr.len = (u8) tlv_len;\n\t\t\twmm_param_ie->vend_hdr.element_id =\n\t\t\t\t\t\tWLAN_EID_VENDOR_SPECIFIC;\n\n\t\t\tmwifiex_dbg(priv->adapter, CMD,\n\t\t\t\t    \"info: CMD_RESP: WMM_GET_STATUS:\\t\"\n\t\t\t\t    \"WMM Parameter Set Count: %d\\n\",\n\t\t\t\t    wmm_param_ie->qos_info_bitmap & mask);\n\n\t\t\tmemcpy((u8 *) &priv->curr_bss_params.bss_descriptor.\n\t\t\t       wmm_ie, wmm_param_ie,\n\t\t\t       wmm_param_ie->vend_hdr.len + 2);\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tvalid = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tcurr += (tlv_len + sizeof(tlv_hdr->header));\n\t\tresp_len -= (tlv_len + sizeof(tlv_hdr->header));\n\t}\n\n\tmwifiex_wmm_setup_queue_priorities(priv, wmm_param_ie);\n\tmwifiex_wmm_setup_ac_downgrade(priv);\n\n\treturn 0;\n}\n\n/*\n * Callback handler from the command module to allow insertion of a WMM TLV.\n *\n * If the BSS we are associating to supports WMM, this function adds the\n * required WMM Information IE to the association request command buffer in\n * the form of a Marvell extended IEEE IE.\n */\nu32\nmwifiex_wmm_process_association_req(struct mwifiex_private *priv,\n\t\t\t\t    u8 **assoc_buf,\n\t\t\t\t    struct ieee_types_wmm_parameter *wmm_ie,\n\t\t\t\t    struct ieee80211_ht_cap *ht_cap)\n{\n\tstruct mwifiex_ie_types_wmm_param_set *wmm_tlv;\n\tu32 ret_len = 0;\n\n\t/* Null checks */\n\tif (!assoc_buf)\n\t\treturn 0;\n\tif (!(*assoc_buf))\n\t\treturn 0;\n\n\tif (!wmm_ie)\n\t\treturn 0;\n\n\tmwifiex_dbg(priv->adapter, INFO,\n\t\t    \"info: WMM: process assoc req: bss->wmm_ie=%#x\\n\",\n\t\t    wmm_ie->vend_hdr.element_id);\n\n\tif ((priv->wmm_required ||\n\t     (ht_cap && (priv->adapter->config_bands & BAND_GN ||\n\t     priv->adapter->config_bands & BAND_AN))) &&\n\t    wmm_ie->vend_hdr.element_id == WLAN_EID_VENDOR_SPECIFIC) {\n\t\twmm_tlv = (struct mwifiex_ie_types_wmm_param_set *) *assoc_buf;\n\t\twmm_tlv->header.type = cpu_to_le16((u16) wmm_info_ie[0]);\n\t\twmm_tlv->header.len = cpu_to_le16((u16) wmm_info_ie[1]);\n\t\tmemcpy(wmm_tlv->wmm_ie, &wmm_info_ie[2],\n\t\t       le16_to_cpu(wmm_tlv->header.len));\n\t\tif (wmm_ie->qos_info_bitmap & IEEE80211_WMM_IE_AP_QOSINFO_UAPSD)\n\t\t\tmemcpy((u8 *) (wmm_tlv->wmm_ie\n\t\t\t\t       + le16_to_cpu(wmm_tlv->header.len)\n\t\t\t\t       - sizeof(priv->wmm_qosinfo)),\n\t\t\t       &priv->wmm_qosinfo, sizeof(priv->wmm_qosinfo));\n\n\t\tret_len = sizeof(wmm_tlv->header)\n\t\t\t  + le16_to_cpu(wmm_tlv->header.len);\n\n\t\t*assoc_buf += ret_len;\n\t}\n\n\treturn ret_len;\n}\n\n/*\n * This function computes the time delay in the driver queues for a\n * given packet.\n *\n * When the packet is received at the OS/Driver interface, the current\n * time is set in the packet structure. The difference between the present\n * time and that received time is computed in this function and limited\n * based on pre-compiled limits in the driver.\n */\nu8\nmwifiex_wmm_compute_drv_pkt_delay(struct mwifiex_private *priv,\n\t\t\t\t  const struct sk_buff *skb)\n{\n\tu32 queue_delay = ktime_to_ms(net_timedelta(skb->tstamp));\n\tu8 ret_val;\n\n\t/*\n\t * Queue delay is passed as a uint8 in units of 2ms (ms shifted\n\t *  by 1). Min value (other than 0) is therefore 2ms, max is 510ms.\n\t *\n\t * Pass max value if queue_delay is beyond the uint8 range\n\t */\n\tret_val = (u8) (min(queue_delay, priv->wmm.drv_pkt_delay_max) >> 1);\n\n\tmwifiex_dbg(priv->adapter, DATA, \"data: WMM: Pkt Delay: %d ms,\\t\"\n\t\t    \"%d ms sent to FW\\n\", queue_delay, ret_val);\n\n\treturn ret_val;\n}\n\n/*\n * This function retrieves the highest priority RA list table pointer.\n */\nstatic struct mwifiex_ra_list_tbl *\nmwifiex_wmm_get_highest_priolist_ptr(struct mwifiex_adapter *adapter,\n\t\t\t\t     struct mwifiex_private **priv, int *tid)\n{\n\tstruct mwifiex_private *priv_tmp;\n\tstruct mwifiex_ra_list_tbl *ptr;\n\tstruct mwifiex_tid_tbl *tid_ptr;\n\tatomic_t *hqp;\n\tint i, j;\n\n\t/* check the BSS with highest priority first */\n\tfor (j = adapter->priv_num - 1; j >= 0; --j) {\n\t\t/* iterate over BSS with the equal priority */\n\t\tlist_for_each_entry(adapter->bss_prio_tbl[j].bss_prio_cur,\n\t\t\t\t    &adapter->bss_prio_tbl[j].bss_prio_head,\n\t\t\t\t    list) {\n\ntry_again:\n\t\t\tpriv_tmp = adapter->bss_prio_tbl[j].bss_prio_cur->priv;\n\n\t\t\tif (((priv_tmp->bss_mode != NL80211_IFTYPE_ADHOC) &&\n\t\t\t     !priv_tmp->port_open) ||\n\t\t\t    (atomic_read(&priv_tmp->wmm.tx_pkts_queued) == 0))\n\t\t\t\tcontinue;\n\n\t\t\tif (adapter->if_ops.is_port_ready &&\n\t\t\t    !adapter->if_ops.is_port_ready(priv_tmp))\n\t\t\t\tcontinue;\n\n\t\t\t/* iterate over the WMM queues of the BSS */\n\t\t\thqp = &priv_tmp->wmm.highest_queued_prio;\n\t\t\tfor (i = atomic_read(hqp); i >= LOW_PRIO_TID; --i) {\n\n\t\t\t\tspin_lock_bh(&priv_tmp->wmm.ra_list_spinlock);\n\n\t\t\t\ttid_ptr = &(priv_tmp)->wmm.\n\t\t\t\t\ttid_tbl_ptr[tos_to_tid[i]];\n\n\t\t\t\t/* iterate over receiver addresses */\n\t\t\t\tlist_for_each_entry(ptr, &tid_ptr->ra_list,\n\t\t\t\t\t\t    list) {\n\n\t\t\t\t\tif (!ptr->tx_paused &&\n\t\t\t\t\t    !skb_queue_empty(&ptr->skb_head))\n\t\t\t\t\t\t/* holds both locks */\n\t\t\t\t\t\tgoto found;\n\t\t\t\t}\n\n\t\t\t\tspin_unlock_bh(&priv_tmp->wmm.ra_list_spinlock);\n\t\t\t}\n\n\t\t\tif (atomic_read(&priv_tmp->wmm.tx_pkts_queued) != 0) {\n\t\t\t\tatomic_set(&priv_tmp->wmm.highest_queued_prio,\n\t\t\t\t\t   HIGH_PRIO_TID);\n\t\t\t\t/* Iterate current private once more, since\n\t\t\t\t * there still exist packets in data queue\n\t\t\t\t */\n\t\t\t\tgoto try_again;\n\t\t\t} else\n\t\t\t\tatomic_set(&priv_tmp->wmm.highest_queued_prio,\n\t\t\t\t\t   NO_PKT_PRIO_TID);\n\t\t}\n\t}\n\n\treturn NULL;\n\nfound:\n\t/* holds ra_list_spinlock */\n\tif (atomic_read(hqp) > i)\n\t\tatomic_set(hqp, i);\n\tspin_unlock_bh(&priv_tmp->wmm.ra_list_spinlock);\n\n\t*priv = priv_tmp;\n\t*tid = tos_to_tid[i];\n\n\treturn ptr;\n}\n\n/* This functions rotates ra and bss lists so packets are picked round robin.\n *\n * After a packet is successfully transmitted, rotate the ra list, so the ra\n * next to the one transmitted, will come first in the list. This way we pick\n * the ra' in a round robin fashion. Same applies to bss nodes of equal\n * priority.\n *\n * Function also increments wmm.packets_out counter.\n */\nvoid mwifiex_rotate_priolists(struct mwifiex_private *priv,\n\t\t\t\t struct mwifiex_ra_list_tbl *ra,\n\t\t\t\t int tid)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct mwifiex_bss_prio_tbl *tbl = adapter->bss_prio_tbl;\n\tstruct mwifiex_tid_tbl *tid_ptr = &priv->wmm.tid_tbl_ptr[tid];\n\n\tspin_lock_bh(&tbl[priv->bss_priority].bss_prio_lock);\n\t/*\n\t * dirty trick: we remove 'head' temporarily and reinsert it after\n\t * curr bss node. imagine list to stay fixed while head is moved\n\t */\n\tlist_move(&tbl[priv->bss_priority].bss_prio_head,\n\t\t  &tbl[priv->bss_priority].bss_prio_cur->list);\n\tspin_unlock_bh(&tbl[priv->bss_priority].bss_prio_lock);\n\n\tspin_lock_bh(&priv->wmm.ra_list_spinlock);\n\tif (mwifiex_is_ralist_valid(priv, ra, tid)) {\n\t\tpriv->wmm.packets_out[tid]++;\n\t\t/* same as above */\n\t\tlist_move(&tid_ptr->ra_list, &ra->list);\n\t}\n\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n}\n\n/*\n * This function checks if 11n aggregation is possible.\n */\nstatic int\nmwifiex_is_11n_aggragation_possible(struct mwifiex_private *priv,\n\t\t\t\t    struct mwifiex_ra_list_tbl *ptr,\n\t\t\t\t    int max_buf_size)\n{\n\tint count = 0, total_size = 0;\n\tstruct sk_buff *skb, *tmp;\n\tint max_amsdu_size;\n\n\tif (priv->bss_role == MWIFIEX_BSS_ROLE_UAP && priv->ap_11n_enabled &&\n\t    ptr->is_11n_enabled)\n\t\tmax_amsdu_size = min_t(int, ptr->max_amsdu, max_buf_size);\n\telse\n\t\tmax_amsdu_size = max_buf_size;\n\n\tskb_queue_walk_safe(&ptr->skb_head, skb, tmp) {\n\t\ttotal_size += skb->len;\n\t\tif (total_size >= max_amsdu_size)\n\t\t\tbreak;\n\t\tif (++count >= MIN_NUM_AMSDU)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/*\n * This function sends a single packet to firmware for transmission.\n */\nstatic void\nmwifiex_send_single_packet(struct mwifiex_private *priv,\n\t\t\t   struct mwifiex_ra_list_tbl *ptr, int ptr_index)\n\t\t\t   __releases(&priv->wmm.ra_list_spinlock)\n{\n\tstruct sk_buff *skb, *skb_next;\n\tstruct mwifiex_tx_param tx_param;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct mwifiex_txinfo *tx_info;\n\n\tif (skb_queue_empty(&ptr->skb_head)) {\n\t\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n\t\tmwifiex_dbg(adapter, DATA, \"data: nothing to send\\n\");\n\t\treturn;\n\t}\n\n\tskb = skb_dequeue(&ptr->skb_head);\n\n\ttx_info = MWIFIEX_SKB_TXCB(skb);\n\tmwifiex_dbg(adapter, DATA,\n\t\t    \"data: dequeuing the packet %p %p\\n\", ptr, skb);\n\n\tptr->total_pkt_count--;\n\n\tif (!skb_queue_empty(&ptr->skb_head))\n\t\tskb_next = skb_peek(&ptr->skb_head);\n\telse\n\t\tskb_next = NULL;\n\n\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n\n\ttx_param.next_pkt_len = ((skb_next) ? skb_next->len +\n\t\t\t\tsizeof(struct txpd) : 0);\n\n\tif (mwifiex_process_tx(priv, skb, &tx_param) == -EBUSY) {\n\t\t/* Queue the packet back at the head */\n\t\tspin_lock_bh(&priv->wmm.ra_list_spinlock);\n\n\t\tif (!mwifiex_is_ralist_valid(priv, ptr, ptr_index)) {\n\t\t\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n\t\t\tmwifiex_write_data_complete(adapter, skb, 0, -1);\n\t\t\treturn;\n\t\t}\n\n\t\tskb_queue_tail(&ptr->skb_head, skb);\n\n\t\tptr->total_pkt_count++;\n\t\tptr->ba_pkt_count++;\n\t\ttx_info->flags |= MWIFIEX_BUF_FLAG_REQUEUED_PKT;\n\t\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n\t} else {\n\t\tmwifiex_rotate_priolists(priv, ptr, ptr_index);\n\t\tatomic_dec(&priv->wmm.tx_pkts_queued);\n\t}\n}\n\n/*\n * This function checks if the first packet in the given RA list\n * is already processed or not.\n */\nstatic int\nmwifiex_is_ptr_processed(struct mwifiex_private *priv,\n\t\t\t struct mwifiex_ra_list_tbl *ptr)\n{\n\tstruct sk_buff *skb;\n\tstruct mwifiex_txinfo *tx_info;\n\n\tif (skb_queue_empty(&ptr->skb_head))\n\t\treturn false;\n\n\tskb = skb_peek(&ptr->skb_head);\n\n\ttx_info = MWIFIEX_SKB_TXCB(skb);\n\tif (tx_info->flags & MWIFIEX_BUF_FLAG_REQUEUED_PKT)\n\t\treturn true;\n\n\treturn false;\n}\n\n/*\n * This function sends a single processed packet to firmware for\n * transmission.\n */\nstatic void\nmwifiex_send_processed_packet(struct mwifiex_private *priv,\n\t\t\t      struct mwifiex_ra_list_tbl *ptr, int ptr_index)\n\t\t\t\t__releases(&priv->wmm.ra_list_spinlock)\n{\n\tstruct mwifiex_tx_param tx_param;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tint ret = -1;\n\tstruct sk_buff *skb, *skb_next;\n\tstruct mwifiex_txinfo *tx_info;\n\n\tif (skb_queue_empty(&ptr->skb_head)) {\n\t\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n\t\treturn;\n\t}\n\n\tskb = skb_dequeue(&ptr->skb_head);\n\n\tif (adapter->data_sent || adapter->tx_lock_flag) {\n\t\tptr->total_pkt_count--;\n\t\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n\t\tskb_queue_tail(&adapter->tx_data_q, skb);\n\t\tatomic_dec(&priv->wmm.tx_pkts_queued);\n\t\tatomic_inc(&adapter->tx_queued);\n\t\treturn;\n\t}\n\n\tif (!skb_queue_empty(&ptr->skb_head))\n\t\tskb_next = skb_peek(&ptr->skb_head);\n\telse\n\t\tskb_next = NULL;\n\n\ttx_info = MWIFIEX_SKB_TXCB(skb);\n\n\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n\n\ttx_param.next_pkt_len =\n\t\t((skb_next) ? skb_next->len +\n\t\t sizeof(struct txpd) : 0);\n\tif (adapter->iface_type == MWIFIEX_USB) {\n\t\tret = adapter->if_ops.host_to_card(adapter, priv->usb_port,\n\t\t\t\t\t\t   skb, &tx_param);\n\t} else {\n\t\tret = adapter->if_ops.host_to_card(adapter, MWIFIEX_TYPE_DATA,\n\t\t\t\t\t\t   skb, &tx_param);\n\t}\n\n\tswitch (ret) {\n\tcase -EBUSY:\n\t\tmwifiex_dbg(adapter, ERROR, \"data: -EBUSY is returned\\n\");\n\t\tspin_lock_bh(&priv->wmm.ra_list_spinlock);\n\n\t\tif (!mwifiex_is_ralist_valid(priv, ptr, ptr_index)) {\n\t\t\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n\t\t\tmwifiex_write_data_complete(adapter, skb, 0, -1);\n\t\t\treturn;\n\t\t}\n\n\t\tskb_queue_tail(&ptr->skb_head, skb);\n\n\t\ttx_info->flags |= MWIFIEX_BUF_FLAG_REQUEUED_PKT;\n\t\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n\t\tbreak;\n\tcase -1:\n\t\tmwifiex_dbg(adapter, ERROR, \"host_to_card failed: %#x\\n\", ret);\n\t\tadapter->dbg.num_tx_host_to_card_failure++;\n\t\tmwifiex_write_data_complete(adapter, skb, 0, ret);\n\t\tbreak;\n\tcase -EINPROGRESS:\n\t\tbreak;\n\tcase 0:\n\t\tmwifiex_write_data_complete(adapter, skb, 0, ret);\n\tdefault:\n\t\tbreak;\n\t}\n\tif (ret != -EBUSY) {\n\t\tmwifiex_rotate_priolists(priv, ptr, ptr_index);\n\t\tatomic_dec(&priv->wmm.tx_pkts_queued);\n\t\tspin_lock_bh(&priv->wmm.ra_list_spinlock);\n\t\tptr->total_pkt_count--;\n\t\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n\t}\n}\n\n/*\n * This function dequeues a packet from the highest priority list\n * and transmits it.\n */\nstatic int\nmwifiex_dequeue_tx_packet(struct mwifiex_adapter *adapter)\n{\n\tstruct mwifiex_ra_list_tbl *ptr;\n\tstruct mwifiex_private *priv = NULL;\n\tint ptr_index = 0;\n\tu8 ra[ETH_ALEN];\n\tint tid_del = 0, tid = 0;\n\n\tptr = mwifiex_wmm_get_highest_priolist_ptr(adapter, &priv, &ptr_index);\n\tif (!ptr)\n\t\treturn -1;\n\n\ttid = mwifiex_get_tid(ptr);\n\n\tmwifiex_dbg(adapter, DATA, \"data: tid=%d\\n\", tid);\n\n\tspin_lock_bh(&priv->wmm.ra_list_spinlock);\n\tif (!mwifiex_is_ralist_valid(priv, ptr, ptr_index)) {\n\t\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n\t\treturn -1;\n\t}\n\n\tif (mwifiex_is_ptr_processed(priv, ptr)) {\n\t\tmwifiex_send_processed_packet(priv, ptr, ptr_index);\n\t\t/* ra_list_spinlock has been freed in\n\t\t   mwifiex_send_processed_packet() */\n\t\treturn 0;\n\t}\n\n\tif (!ptr->is_11n_enabled ||\n\t\tptr->ba_status ||\n\t\tpriv->wps.session_enable) {\n\t\tif (ptr->is_11n_enabled &&\n\t\t\tptr->ba_status &&\n\t\t\tptr->amsdu_in_ampdu &&\n\t\t\tmwifiex_is_amsdu_allowed(priv, tid) &&\n\t\t\tmwifiex_is_11n_aggragation_possible(priv, ptr,\n\t\t\t\t\t\t\tadapter->tx_buf_size))\n\t\t\tmwifiex_11n_aggregate_pkt(priv, ptr, ptr_index);\n\t\t\t/* ra_list_spinlock has been freed in\n\t\t\t * mwifiex_11n_aggregate_pkt()\n\t\t\t */\n\t\telse\n\t\t\tmwifiex_send_single_packet(priv, ptr, ptr_index);\n\t\t\t/* ra_list_spinlock has been freed in\n\t\t\t * mwifiex_send_single_packet()\n\t\t\t */\n\t} else {\n\t\tif (mwifiex_is_ampdu_allowed(priv, ptr, tid) &&\n\t\t    ptr->ba_pkt_count > ptr->ba_packet_thr) {\n\t\t\tif (mwifiex_space_avail_for_new_ba_stream(adapter)) {\n\t\t\t\tmwifiex_create_ba_tbl(priv, ptr->ra, tid,\n\t\t\t\t\t\t      BA_SETUP_INPROGRESS);\n\t\t\t\tmwifiex_send_addba(priv, tid, ptr->ra);\n\t\t\t} else if (mwifiex_find_stream_to_delete\n\t\t\t\t   (priv, tid, &tid_del, ra)) {\n\t\t\t\tmwifiex_create_ba_tbl(priv, ptr->ra, tid,\n\t\t\t\t\t\t      BA_SETUP_INPROGRESS);\n\t\t\t\tmwifiex_send_delba(priv, tid_del, ra, 1);\n\t\t\t}\n\t\t}\n\t\tif (mwifiex_is_amsdu_allowed(priv, tid) &&\n\t\t    mwifiex_is_11n_aggragation_possible(priv, ptr,\n\t\t\t\t\t\t\tadapter->tx_buf_size))\n\t\t\tmwifiex_11n_aggregate_pkt(priv, ptr, ptr_index);\n\t\t\t/* ra_list_spinlock has been freed in\n\t\t\t   mwifiex_11n_aggregate_pkt() */\n\t\telse\n\t\t\tmwifiex_send_single_packet(priv, ptr, ptr_index);\n\t\t\t/* ra_list_spinlock has been freed in\n\t\t\t   mwifiex_send_single_packet() */\n\t}\n\treturn 0;\n}\n\nvoid mwifiex_process_bypass_tx(struct mwifiex_adapter *adapter)\n{\n\tstruct mwifiex_tx_param tx_param;\n\tstruct sk_buff *skb;\n\tstruct mwifiex_txinfo *tx_info;\n\tstruct mwifiex_private *priv;\n\tint i;\n\n\tif (adapter->data_sent || adapter->tx_lock_flag)\n\t\treturn;\n\n\tfor (i = 0; i < adapter->priv_num; ++i) {\n\t\tpriv = adapter->priv[i];\n\n\t\tif (!priv)\n\t\t\tcontinue;\n\n\t\tif (adapter->if_ops.is_port_ready &&\n\t\t    !adapter->if_ops.is_port_ready(priv))\n\t\t\tcontinue;\n\n\t\tif (skb_queue_empty(&priv->bypass_txq))\n\t\t\tcontinue;\n\n\t\tskb = skb_dequeue(&priv->bypass_txq);\n\t\ttx_info = MWIFIEX_SKB_TXCB(skb);\n\n\t\t/* no aggregation for bypass packets */\n\t\ttx_param.next_pkt_len = 0;\n\n\t\tif (mwifiex_process_tx(priv, skb, &tx_param) == -EBUSY) {\n\t\t\tskb_queue_head(&priv->bypass_txq, skb);\n\t\t\ttx_info->flags |= MWIFIEX_BUF_FLAG_REQUEUED_PKT;\n\t\t} else {\n\t\t\tatomic_dec(&adapter->bypass_tx_pending);\n\t\t}\n\t}\n}\n\n/*\n * This function transmits the highest priority packet awaiting in the\n * WMM Queues.\n */\nvoid\nmwifiex_wmm_process_tx(struct mwifiex_adapter *adapter)\n{\n\tdo {\n\t\tif (mwifiex_dequeue_tx_packet(adapter))\n\t\t\tbreak;\n\t\tif (adapter->iface_type != MWIFIEX_SDIO) {\n\t\t\tif (adapter->data_sent ||\n\t\t\t    adapter->tx_lock_flag)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (atomic_read(&adapter->tx_queued) >=\n\t\t\t    MWIFIEX_MAX_PKTS_TXQ)\n\t\t\t\tbreak;\n\t\t}\n\t} while (!mwifiex_wmm_lists_empty(adapter));\n}\n"], "fixing_code": ["/*\n * Marvell Wireless LAN device driver: WMM\n *\n * Copyright (C) 2011-2014, Marvell International Ltd.\n *\n * This software file (the \"File\") is distributed by Marvell International\n * Ltd. under the terms of the GNU General Public License Version 2, June 1991\n * (the \"License\").  You may use, redistribute and/or modify this File in\n * accordance with the terms and conditions of the License, a copy of which\n * is available by writing to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the\n * worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n *\n * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE\n * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about\n * this warranty disclaimer.\n */\n\n#include \"decl.h\"\n#include \"ioctl.h\"\n#include \"util.h\"\n#include \"fw.h\"\n#include \"main.h\"\n#include \"wmm.h\"\n#include \"11n.h\"\n\n\n/* Maximum value FW can accept for driver delay in packet transmission */\n#define DRV_PKT_DELAY_TO_FW_MAX   512\n\n\n#define WMM_QUEUED_PACKET_LOWER_LIMIT   180\n\n#define WMM_QUEUED_PACKET_UPPER_LIMIT   200\n\n/* Offset for TOS field in the IP header */\n#define IPTOS_OFFSET 5\n\nstatic bool disable_tx_amsdu;\nmodule_param(disable_tx_amsdu, bool, 0644);\n\n/* WMM information IE */\nstatic const u8 wmm_info_ie[] = { WLAN_EID_VENDOR_SPECIFIC, 0x07,\n\t0x00, 0x50, 0xf2, 0x02,\n\t0x00, 0x01, 0x00\n};\n\nstatic const u8 wmm_aci_to_qidx_map[] = { WMM_AC_BE,\n\tWMM_AC_BK,\n\tWMM_AC_VI,\n\tWMM_AC_VO\n};\n\nstatic u8 tos_to_tid[] = {\n\t/* TID DSCP_P2 DSCP_P1 DSCP_P0 WMM_AC */\n\t0x01,\t\t\t/* 0 1 0 AC_BK */\n\t0x02,\t\t\t/* 0 0 0 AC_BK */\n\t0x00,\t\t\t/* 0 0 1 AC_BE */\n\t0x03,\t\t\t/* 0 1 1 AC_BE */\n\t0x04,\t\t\t/* 1 0 0 AC_VI */\n\t0x05,\t\t\t/* 1 0 1 AC_VI */\n\t0x06,\t\t\t/* 1 1 0 AC_VO */\n\t0x07\t\t\t/* 1 1 1 AC_VO */\n};\n\nstatic u8 ac_to_tid[4][2] = { {1, 2}, {0, 3}, {4, 5}, {6, 7} };\n\n/*\n * This function debug prints the priority parameters for a WMM AC.\n */\nstatic void\nmwifiex_wmm_ac_debug_print(const struct ieee_types_wmm_ac_parameters *ac_param)\n{\n\tconst char *ac_str[] = { \"BK\", \"BE\", \"VI\", \"VO\" };\n\n\tpr_debug(\"info: WMM AC_%s: ACI=%d, ACM=%d, Aifsn=%d, \"\n\t\t \"EcwMin=%d, EcwMax=%d, TxopLimit=%d\\n\",\n\t\t ac_str[wmm_aci_to_qidx_map[(ac_param->aci_aifsn_bitmap\n\t\t\t\t\t     & MWIFIEX_ACI) >> 5]],\n\t\t (ac_param->aci_aifsn_bitmap & MWIFIEX_ACI) >> 5,\n\t\t (ac_param->aci_aifsn_bitmap & MWIFIEX_ACM) >> 4,\n\t\t ac_param->aci_aifsn_bitmap & MWIFIEX_AIFSN,\n\t\t ac_param->ecw_bitmap & MWIFIEX_ECW_MIN,\n\t\t (ac_param->ecw_bitmap & MWIFIEX_ECW_MAX) >> 4,\n\t\t le16_to_cpu(ac_param->tx_op_limit));\n}\n\n/*\n * This function allocates a route address list.\n *\n * The function also initializes the list with the provided RA.\n */\nstatic struct mwifiex_ra_list_tbl *\nmwifiex_wmm_allocate_ralist_node(struct mwifiex_adapter *adapter, const u8 *ra)\n{\n\tstruct mwifiex_ra_list_tbl *ra_list;\n\n\tra_list = kzalloc(sizeof(struct mwifiex_ra_list_tbl), GFP_ATOMIC);\n\tif (!ra_list)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&ra_list->list);\n\tskb_queue_head_init(&ra_list->skb_head);\n\n\tmemcpy(ra_list->ra, ra, ETH_ALEN);\n\n\tra_list->total_pkt_count = 0;\n\n\tmwifiex_dbg(adapter, INFO, \"info: allocated ra_list %p\\n\", ra_list);\n\n\treturn ra_list;\n}\n\n/* This function returns random no between 16 and 32 to be used as threshold\n * for no of packets after which BA setup is initiated.\n */\nstatic u8 mwifiex_get_random_ba_threshold(void)\n{\n\tu64 ns;\n\t/* setup ba_packet_threshold here random number between\n\t * [BA_SETUP_PACKET_OFFSET,\n\t * BA_SETUP_PACKET_OFFSET+BA_SETUP_MAX_PACKET_THRESHOLD-1]\n\t */\n\tns = ktime_get_ns();\n\tns += (ns >> 32) + (ns >> 16);\n\n\treturn ((u8)ns % BA_SETUP_MAX_PACKET_THRESHOLD) + BA_SETUP_PACKET_OFFSET;\n}\n\n/*\n * This function allocates and adds a RA list for all TIDs\n * with the given RA.\n */\nvoid mwifiex_ralist_add(struct mwifiex_private *priv, const u8 *ra)\n{\n\tint i;\n\tstruct mwifiex_ra_list_tbl *ra_list;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct mwifiex_sta_node *node;\n\n\n\tfor (i = 0; i < MAX_NUM_TID; ++i) {\n\t\tra_list = mwifiex_wmm_allocate_ralist_node(adapter, ra);\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"info: created ra_list %p\\n\", ra_list);\n\n\t\tif (!ra_list)\n\t\t\tbreak;\n\n\t\tra_list->is_11n_enabled = 0;\n\t\tra_list->tdls_link = false;\n\t\tra_list->ba_status = BA_SETUP_NONE;\n\t\tra_list->amsdu_in_ampdu = false;\n\t\tif (!mwifiex_queuing_ra_based(priv)) {\n\t\t\tif (mwifiex_is_tdls_link_setup\n\t\t\t\t(mwifiex_get_tdls_link_status(priv, ra))) {\n\t\t\t\tra_list->tdls_link = true;\n\t\t\t\tra_list->is_11n_enabled =\n\t\t\t\t\tmwifiex_tdls_peer_11n_enabled(priv, ra);\n\t\t\t} else {\n\t\t\t\tra_list->is_11n_enabled = IS_11N_ENABLED(priv);\n\t\t\t}\n\t\t} else {\n\t\t\tspin_lock_bh(&priv->sta_list_spinlock);\n\t\t\tnode = mwifiex_get_sta_entry(priv, ra);\n\t\t\tif (node)\n\t\t\t\tra_list->tx_paused = node->tx_pause;\n\t\t\tra_list->is_11n_enabled =\n\t\t\t\t      mwifiex_is_sta_11n_enabled(priv, node);\n\t\t\tif (ra_list->is_11n_enabled)\n\t\t\t\tra_list->max_amsdu = node->max_amsdu;\n\t\t\tspin_unlock_bh(&priv->sta_list_spinlock);\n\t\t}\n\n\t\tmwifiex_dbg(adapter, DATA, \"data: ralist %p: is_11n_enabled=%d\\n\",\n\t\t\t    ra_list, ra_list->is_11n_enabled);\n\n\t\tif (ra_list->is_11n_enabled) {\n\t\t\tra_list->ba_pkt_count = 0;\n\t\t\tra_list->ba_packet_thr =\n\t\t\t\t\t      mwifiex_get_random_ba_threshold();\n\t\t}\n\t\tlist_add_tail(&ra_list->list,\n\t\t\t      &priv->wmm.tid_tbl_ptr[i].ra_list);\n\t}\n}\n\n/*\n * This function sets the WMM queue priorities to their default values.\n */\nstatic void mwifiex_wmm_default_queue_priorities(struct mwifiex_private *priv)\n{\n\t/* Default queue priorities: VO->VI->BE->BK */\n\tpriv->wmm.queue_priority[0] = WMM_AC_VO;\n\tpriv->wmm.queue_priority[1] = WMM_AC_VI;\n\tpriv->wmm.queue_priority[2] = WMM_AC_BE;\n\tpriv->wmm.queue_priority[3] = WMM_AC_BK;\n}\n\n/*\n * This function map ACs to TIDs.\n */\nstatic void\nmwifiex_wmm_queue_priorities_tid(struct mwifiex_private *priv)\n{\n\tstruct mwifiex_wmm_desc *wmm = &priv->wmm;\n\tu8 *queue_priority = wmm->queue_priority;\n\tint i;\n\n\tfor (i = 0; i < 4; ++i) {\n\t\ttos_to_tid[7 - (i * 2)] = ac_to_tid[queue_priority[i]][1];\n\t\ttos_to_tid[6 - (i * 2)] = ac_to_tid[queue_priority[i]][0];\n\t}\n\n\tfor (i = 0; i < MAX_NUM_TID; ++i)\n\t\tpriv->tos_to_tid_inv[tos_to_tid[i]] = (u8)i;\n\n\tatomic_set(&wmm->highest_queued_prio, HIGH_PRIO_TID);\n}\n\n/*\n * This function initializes WMM priority queues.\n */\nvoid\nmwifiex_wmm_setup_queue_priorities(struct mwifiex_private *priv,\n\t\t\t\t   struct ieee_types_wmm_parameter *wmm_ie)\n{\n\tu16 cw_min, avg_back_off, tmp[4];\n\tu32 i, j, num_ac;\n\tu8 ac_idx;\n\n\tif (!wmm_ie || !priv->wmm_enabled) {\n\t\t/* WMM is not enabled, just set the defaults and return */\n\t\tmwifiex_wmm_default_queue_priorities(priv);\n\t\treturn;\n\t}\n\n\tmwifiex_dbg(priv->adapter, INFO,\n\t\t    \"info: WMM Parameter IE: version=%d,\\t\"\n\t\t    \"qos_info Parameter Set Count=%d, Reserved=%#x\\n\",\n\t\t    wmm_ie->version, wmm_ie->qos_info_bitmap &\n\t\t    IEEE80211_WMM_IE_AP_QOSINFO_PARAM_SET_CNT_MASK,\n\t\t    wmm_ie->reserved);\n\n\tfor (num_ac = 0; num_ac < ARRAY_SIZE(wmm_ie->ac_params); num_ac++) {\n\t\tu8 ecw = wmm_ie->ac_params[num_ac].ecw_bitmap;\n\t\tu8 aci_aifsn = wmm_ie->ac_params[num_ac].aci_aifsn_bitmap;\n\t\tcw_min = (1 << (ecw & MWIFIEX_ECW_MIN)) - 1;\n\t\tavg_back_off = (cw_min >> 1) + (aci_aifsn & MWIFIEX_AIFSN);\n\n\t\tac_idx = wmm_aci_to_qidx_map[(aci_aifsn & MWIFIEX_ACI) >> 5];\n\t\tpriv->wmm.queue_priority[ac_idx] = ac_idx;\n\t\ttmp[ac_idx] = avg_back_off;\n\n\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t    \"info: WMM: CWmax=%d CWmin=%d Avg Back-off=%d\\n\",\n\t\t\t    (1 << ((ecw & MWIFIEX_ECW_MAX) >> 4)) - 1,\n\t\t\t    cw_min, avg_back_off);\n\t\tmwifiex_wmm_ac_debug_print(&wmm_ie->ac_params[num_ac]);\n\t}\n\n\t/* Bubble sort */\n\tfor (i = 0; i < num_ac; i++) {\n\t\tfor (j = 1; j < num_ac - i; j++) {\n\t\t\tif (tmp[j - 1] > tmp[j]) {\n\t\t\t\tswap(tmp[j - 1], tmp[j]);\n\t\t\t\tswap(priv->wmm.queue_priority[j - 1],\n\t\t\t\t     priv->wmm.queue_priority[j]);\n\t\t\t} else if (tmp[j - 1] == tmp[j]) {\n\t\t\t\tif (priv->wmm.queue_priority[j - 1]\n\t\t\t\t    < priv->wmm.queue_priority[j])\n\t\t\t\t\tswap(priv->wmm.queue_priority[j - 1],\n\t\t\t\t\t     priv->wmm.queue_priority[j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tmwifiex_wmm_queue_priorities_tid(priv);\n}\n\n/*\n * This function evaluates whether or not an AC is to be downgraded.\n *\n * In case the AC is not enabled, the highest AC is returned that is\n * enabled and does not require admission control.\n */\nstatic enum mwifiex_wmm_ac_e\nmwifiex_wmm_eval_downgrade_ac(struct mwifiex_private *priv,\n\t\t\t      enum mwifiex_wmm_ac_e eval_ac)\n{\n\tint down_ac;\n\tenum mwifiex_wmm_ac_e ret_ac;\n\tstruct mwifiex_wmm_ac_status *ac_status;\n\n\tac_status = &priv->wmm.ac_status[eval_ac];\n\n\tif (!ac_status->disabled)\n\t\t/* Okay to use this AC, its enabled */\n\t\treturn eval_ac;\n\n\t/* Setup a default return value of the lowest priority */\n\tret_ac = WMM_AC_BK;\n\n\t/*\n\t *  Find the highest AC that is enabled and does not require\n\t *  admission control. The spec disallows downgrading to an AC,\n\t *  which is enabled due to a completed admission control.\n\t *  Unadmitted traffic is not to be sent on an AC with admitted\n\t *  traffic.\n\t */\n\tfor (down_ac = WMM_AC_BK; down_ac < eval_ac; down_ac++) {\n\t\tac_status = &priv->wmm.ac_status[down_ac];\n\n\t\tif (!ac_status->disabled && !ac_status->flow_required)\n\t\t\t/* AC is enabled and does not require admission\n\t\t\t   control */\n\t\t\tret_ac = (enum mwifiex_wmm_ac_e) down_ac;\n\t}\n\n\treturn ret_ac;\n}\n\n/*\n * This function downgrades WMM priority queue.\n */\nvoid\nmwifiex_wmm_setup_ac_downgrade(struct mwifiex_private *priv)\n{\n\tint ac_val;\n\n\tmwifiex_dbg(priv->adapter, INFO, \"info: WMM: AC Priorities:\\t\"\n\t\t    \"BK(0), BE(1), VI(2), VO(3)\\n\");\n\n\tif (!priv->wmm_enabled) {\n\t\t/* WMM is not enabled, default priorities */\n\t\tfor (ac_val = WMM_AC_BK; ac_val <= WMM_AC_VO; ac_val++)\n\t\t\tpriv->wmm.ac_down_graded_vals[ac_val] =\n\t\t\t\t\t\t(enum mwifiex_wmm_ac_e) ac_val;\n\t} else {\n\t\tfor (ac_val = WMM_AC_BK; ac_val <= WMM_AC_VO; ac_val++) {\n\t\t\tpriv->wmm.ac_down_graded_vals[ac_val]\n\t\t\t\t= mwifiex_wmm_eval_downgrade_ac(priv,\n\t\t\t\t\t\t(enum mwifiex_wmm_ac_e) ac_val);\n\t\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t\t    \"info: WMM: AC PRIO %d maps to %d\\n\",\n\t\t\t\t    ac_val,\n\t\t\t\t    priv->wmm.ac_down_graded_vals[ac_val]);\n\t\t}\n\t}\n}\n\n/*\n * This function converts the IP TOS field to an WMM AC\n * Queue assignment.\n */\nstatic enum mwifiex_wmm_ac_e\nmwifiex_wmm_convert_tos_to_ac(struct mwifiex_adapter *adapter, u32 tos)\n{\n\t/* Map of TOS UP values to WMM AC */\n\tstatic const enum mwifiex_wmm_ac_e tos_to_ac[] = {\n\t\tWMM_AC_BE,\n\t\tWMM_AC_BK,\n\t\tWMM_AC_BK,\n\t\tWMM_AC_BE,\n\t\tWMM_AC_VI,\n\t\tWMM_AC_VI,\n\t\tWMM_AC_VO,\n\t\tWMM_AC_VO\n\t};\n\n\tif (tos >= ARRAY_SIZE(tos_to_ac))\n\t\treturn WMM_AC_BE;\n\n\treturn tos_to_ac[tos];\n}\n\n/*\n * This function evaluates a given TID and downgrades it to a lower\n * TID if the WMM Parameter IE received from the AP indicates that the\n * AP is disabled (due to call admission control (ACM bit). Mapping\n * of TID to AC is taken care of internally.\n */\nu8 mwifiex_wmm_downgrade_tid(struct mwifiex_private *priv, u32 tid)\n{\n\tenum mwifiex_wmm_ac_e ac, ac_down;\n\tu8 new_tid;\n\n\tac = mwifiex_wmm_convert_tos_to_ac(priv->adapter, tid);\n\tac_down = priv->wmm.ac_down_graded_vals[ac];\n\n\t/* Send the index to tid array, picking from the array will be\n\t * taken care by dequeuing function\n\t */\n\tnew_tid = ac_to_tid[ac_down][tid % 2];\n\n\treturn new_tid;\n}\n\n/*\n * This function initializes the WMM state information and the\n * WMM data path queues.\n */\nvoid\nmwifiex_wmm_init(struct mwifiex_adapter *adapter)\n{\n\tint i, j;\n\tstruct mwifiex_private *priv;\n\n\tfor (j = 0; j < adapter->priv_num; ++j) {\n\t\tpriv = adapter->priv[j];\n\t\tif (!priv)\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < MAX_NUM_TID; ++i) {\n\t\t\tif (!disable_tx_amsdu &&\n\t\t\t    adapter->tx_buf_size > MWIFIEX_TX_DATA_BUF_SIZE_2K)\n\t\t\t\tpriv->aggr_prio_tbl[i].amsdu =\n\t\t\t\t\t\t\tpriv->tos_to_tid_inv[i];\n\t\t\telse\n\t\t\t\tpriv->aggr_prio_tbl[i].amsdu =\n\t\t\t\t\t\t\tBA_STREAM_NOT_ALLOWED;\n\t\t\tpriv->aggr_prio_tbl[i].ampdu_ap =\n\t\t\t\t\t\t\tpriv->tos_to_tid_inv[i];\n\t\t\tpriv->aggr_prio_tbl[i].ampdu_user =\n\t\t\t\t\t\t\tpriv->tos_to_tid_inv[i];\n\t\t}\n\n\t\tpriv->aggr_prio_tbl[6].amsdu\n\t\t\t\t\t= priv->aggr_prio_tbl[6].ampdu_ap\n\t\t\t\t\t= priv->aggr_prio_tbl[6].ampdu_user\n\t\t\t\t\t= BA_STREAM_NOT_ALLOWED;\n\n\t\tpriv->aggr_prio_tbl[7].amsdu = priv->aggr_prio_tbl[7].ampdu_ap\n\t\t\t\t\t= priv->aggr_prio_tbl[7].ampdu_user\n\t\t\t\t\t= BA_STREAM_NOT_ALLOWED;\n\n\t\tmwifiex_set_ba_params(priv);\n\t\tmwifiex_reset_11n_rx_seq_num(priv);\n\n\t\tpriv->wmm.drv_pkt_delay_max = MWIFIEX_WMM_DRV_DELAY_MAX;\n\t\tatomic_set(&priv->wmm.tx_pkts_queued, 0);\n\t\tatomic_set(&priv->wmm.highest_queued_prio, HIGH_PRIO_TID);\n\t}\n}\n\nint mwifiex_bypass_txlist_empty(struct mwifiex_adapter *adapter)\n{\n\tstruct mwifiex_private *priv;\n\tint i;\n\n\tfor (i = 0; i < adapter->priv_num; i++) {\n\t\tpriv = adapter->priv[i];\n\t\tif (!priv)\n\t\t\tcontinue;\n\t\tif (adapter->if_ops.is_port_ready &&\n\t\t    !adapter->if_ops.is_port_ready(priv))\n\t\t\tcontinue;\n\t\tif (!skb_queue_empty(&priv->bypass_txq))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n/*\n * This function checks if WMM Tx queue is empty.\n */\nint\nmwifiex_wmm_lists_empty(struct mwifiex_adapter *adapter)\n{\n\tint i;\n\tstruct mwifiex_private *priv;\n\n\tfor (i = 0; i < adapter->priv_num; ++i) {\n\t\tpriv = adapter->priv[i];\n\t\tif (!priv)\n\t\t\tcontinue;\n\t\tif (!priv->port_open &&\n\t\t    (priv->bss_mode != NL80211_IFTYPE_ADHOC))\n\t\t\tcontinue;\n\t\tif (adapter->if_ops.is_port_ready &&\n\t\t    !adapter->if_ops.is_port_ready(priv))\n\t\t\tcontinue;\n\t\tif (atomic_read(&priv->wmm.tx_pkts_queued))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n/*\n * This function deletes all packets in an RA list node.\n *\n * The packet sent completion callback handler are called with\n * status failure, after they are dequeued to ensure proper\n * cleanup. The RA list node itself is freed at the end.\n */\nstatic void\nmwifiex_wmm_del_pkts_in_ralist_node(struct mwifiex_private *priv,\n\t\t\t\t    struct mwifiex_ra_list_tbl *ra_list)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct sk_buff *skb, *tmp;\n\n\tskb_queue_walk_safe(&ra_list->skb_head, skb, tmp) {\n\t\tskb_unlink(skb, &ra_list->skb_head);\n\t\tmwifiex_write_data_complete(adapter, skb, 0, -1);\n\t}\n}\n\n/*\n * This function deletes all packets in an RA list.\n *\n * Each nodes in the RA list are freed individually first, and then\n * the RA list itself is freed.\n */\nstatic void\nmwifiex_wmm_del_pkts_in_ralist(struct mwifiex_private *priv,\n\t\t\t       struct list_head *ra_list_head)\n{\n\tstruct mwifiex_ra_list_tbl *ra_list;\n\n\tlist_for_each_entry(ra_list, ra_list_head, list)\n\t\tmwifiex_wmm_del_pkts_in_ralist_node(priv, ra_list);\n}\n\n/*\n * This function deletes all packets in all RA lists.\n */\nstatic void mwifiex_wmm_cleanup_queues(struct mwifiex_private *priv)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_NUM_TID; i++)\n\t\tmwifiex_wmm_del_pkts_in_ralist(priv, &priv->wmm.tid_tbl_ptr[i].\n\t\t\t\t\t\t\t\t       ra_list);\n\n\tatomic_set(&priv->wmm.tx_pkts_queued, 0);\n\tatomic_set(&priv->wmm.highest_queued_prio, HIGH_PRIO_TID);\n}\n\n/*\n * This function deletes all route addresses from all RA lists.\n */\nstatic void mwifiex_wmm_delete_all_ralist(struct mwifiex_private *priv)\n{\n\tstruct mwifiex_ra_list_tbl *ra_list, *tmp_node;\n\tint i;\n\n\tfor (i = 0; i < MAX_NUM_TID; ++i) {\n\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t    \"info: ra_list: freeing buf for tid %d\\n\", i);\n\t\tlist_for_each_entry_safe(ra_list, tmp_node,\n\t\t\t\t\t &priv->wmm.tid_tbl_ptr[i].ra_list,\n\t\t\t\t\t list) {\n\t\t\tlist_del(&ra_list->list);\n\t\t\tkfree(ra_list);\n\t\t}\n\n\t\tINIT_LIST_HEAD(&priv->wmm.tid_tbl_ptr[i].ra_list);\n\t}\n}\n\nstatic int mwifiex_free_ack_frame(int id, void *p, void *data)\n{\n\tpr_warn(\"Have pending ack frames!\\n\");\n\tkfree_skb(p);\n\treturn 0;\n}\n\n/*\n * This function cleans up the Tx and Rx queues.\n *\n * Cleanup includes -\n *      - All packets in RA lists\n *      - All entries in Rx reorder table\n *      - All entries in Tx BA stream table\n *      - MPA buffer (if required)\n *      - All RA lists\n */\nvoid\nmwifiex_clean_txrx(struct mwifiex_private *priv)\n{\n\tstruct sk_buff *skb, *tmp;\n\n\tmwifiex_11n_cleanup_reorder_tbl(priv);\n\tspin_lock_bh(&priv->wmm.ra_list_spinlock);\n\n\tmwifiex_wmm_cleanup_queues(priv);\n\tmwifiex_11n_delete_all_tx_ba_stream_tbl(priv);\n\n\tif (priv->adapter->if_ops.cleanup_mpa_buf)\n\t\tpriv->adapter->if_ops.cleanup_mpa_buf(priv->adapter);\n\n\tmwifiex_wmm_delete_all_ralist(priv);\n\tmemcpy(tos_to_tid, ac_to_tid, sizeof(tos_to_tid));\n\n\tif (priv->adapter->if_ops.clean_pcie_ring &&\n\t    !test_bit(MWIFIEX_SURPRISE_REMOVED, &priv->adapter->work_flags))\n\t\tpriv->adapter->if_ops.clean_pcie_ring(priv->adapter);\n\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n\n\tskb_queue_walk_safe(&priv->tdls_txq, skb, tmp) {\n\t\tskb_unlink(skb, &priv->tdls_txq);\n\t\tmwifiex_write_data_complete(priv->adapter, skb, 0, -1);\n\t}\n\n\tskb_queue_walk_safe(&priv->bypass_txq, skb, tmp) {\n\t\tskb_unlink(skb, &priv->bypass_txq);\n\t\tmwifiex_write_data_complete(priv->adapter, skb, 0, -1);\n\t}\n\tatomic_set(&priv->adapter->bypass_tx_pending, 0);\n\n\tidr_for_each(&priv->ack_status_frames, mwifiex_free_ack_frame, NULL);\n\tidr_destroy(&priv->ack_status_frames);\n}\n\n/*\n * This function retrieves a particular RA list node, matching with the\n * given TID and RA address.\n */\nstruct mwifiex_ra_list_tbl *\nmwifiex_wmm_get_ralist_node(struct mwifiex_private *priv, u8 tid,\n\t\t\t    const u8 *ra_addr)\n{\n\tstruct mwifiex_ra_list_tbl *ra_list;\n\n\tlist_for_each_entry(ra_list, &priv->wmm.tid_tbl_ptr[tid].ra_list,\n\t\t\t    list) {\n\t\tif (!memcmp(ra_list->ra, ra_addr, ETH_ALEN))\n\t\t\treturn ra_list;\n\t}\n\n\treturn NULL;\n}\n\nvoid mwifiex_update_ralist_tx_pause(struct mwifiex_private *priv, u8 *mac,\n\t\t\t\t    u8 tx_pause)\n{\n\tstruct mwifiex_ra_list_tbl *ra_list;\n\tu32 pkt_cnt = 0, tx_pkts_queued;\n\tint i;\n\n\tspin_lock_bh(&priv->wmm.ra_list_spinlock);\n\n\tfor (i = 0; i < MAX_NUM_TID; ++i) {\n\t\tra_list = mwifiex_wmm_get_ralist_node(priv, i, mac);\n\t\tif (ra_list && ra_list->tx_paused != tx_pause) {\n\t\t\tpkt_cnt += ra_list->total_pkt_count;\n\t\t\tra_list->tx_paused = tx_pause;\n\t\t\tif (tx_pause)\n\t\t\t\tpriv->wmm.pkts_paused[i] +=\n\t\t\t\t\tra_list->total_pkt_count;\n\t\t\telse\n\t\t\t\tpriv->wmm.pkts_paused[i] -=\n\t\t\t\t\tra_list->total_pkt_count;\n\t\t}\n\t}\n\n\tif (pkt_cnt) {\n\t\ttx_pkts_queued = atomic_read(&priv->wmm.tx_pkts_queued);\n\t\tif (tx_pause)\n\t\t\ttx_pkts_queued -= pkt_cnt;\n\t\telse\n\t\t\ttx_pkts_queued += pkt_cnt;\n\n\t\tatomic_set(&priv->wmm.tx_pkts_queued, tx_pkts_queued);\n\t\tatomic_set(&priv->wmm.highest_queued_prio, HIGH_PRIO_TID);\n\t}\n\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n}\n\n/* This function updates non-tdls peer ralist tx_pause while\n * tdls channel switching\n */\nvoid mwifiex_update_ralist_tx_pause_in_tdls_cs(struct mwifiex_private *priv,\n\t\t\t\t\t       u8 *mac, u8 tx_pause)\n{\n\tstruct mwifiex_ra_list_tbl *ra_list;\n\tu32 pkt_cnt = 0, tx_pkts_queued;\n\tint i;\n\n\tspin_lock_bh(&priv->wmm.ra_list_spinlock);\n\n\tfor (i = 0; i < MAX_NUM_TID; ++i) {\n\t\tlist_for_each_entry(ra_list, &priv->wmm.tid_tbl_ptr[i].ra_list,\n\t\t\t\t    list) {\n\t\t\tif (!memcmp(ra_list->ra, mac, ETH_ALEN))\n\t\t\t\tcontinue;\n\n\t\t\tif (ra_list->tx_paused != tx_pause) {\n\t\t\t\tpkt_cnt += ra_list->total_pkt_count;\n\t\t\t\tra_list->tx_paused = tx_pause;\n\t\t\t\tif (tx_pause)\n\t\t\t\t\tpriv->wmm.pkts_paused[i] +=\n\t\t\t\t\t\tra_list->total_pkt_count;\n\t\t\t\telse\n\t\t\t\t\tpriv->wmm.pkts_paused[i] -=\n\t\t\t\t\t\tra_list->total_pkt_count;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (pkt_cnt) {\n\t\ttx_pkts_queued = atomic_read(&priv->wmm.tx_pkts_queued);\n\t\tif (tx_pause)\n\t\t\ttx_pkts_queued -= pkt_cnt;\n\t\telse\n\t\t\ttx_pkts_queued += pkt_cnt;\n\n\t\tatomic_set(&priv->wmm.tx_pkts_queued, tx_pkts_queued);\n\t\tatomic_set(&priv->wmm.highest_queued_prio, HIGH_PRIO_TID);\n\t}\n\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n}\n\n/*\n * This function retrieves an RA list node for a given TID and\n * RA address pair.\n *\n * If no such node is found, a new node is added first and then\n * retrieved.\n */\nstruct mwifiex_ra_list_tbl *\nmwifiex_wmm_get_queue_raptr(struct mwifiex_private *priv, u8 tid,\n\t\t\t    const u8 *ra_addr)\n{\n\tstruct mwifiex_ra_list_tbl *ra_list;\n\n\tra_list = mwifiex_wmm_get_ralist_node(priv, tid, ra_addr);\n\tif (ra_list)\n\t\treturn ra_list;\n\tmwifiex_ralist_add(priv, ra_addr);\n\n\treturn mwifiex_wmm_get_ralist_node(priv, tid, ra_addr);\n}\n\n/*\n * This function deletes RA list nodes for given mac for all TIDs.\n * Function also decrements TX pending count accordingly.\n */\nvoid\nmwifiex_wmm_del_peer_ra_list(struct mwifiex_private *priv, const u8 *ra_addr)\n{\n\tstruct mwifiex_ra_list_tbl *ra_list;\n\tint i;\n\n\tspin_lock_bh(&priv->wmm.ra_list_spinlock);\n\n\tfor (i = 0; i < MAX_NUM_TID; ++i) {\n\t\tra_list = mwifiex_wmm_get_ralist_node(priv, i, ra_addr);\n\n\t\tif (!ra_list)\n\t\t\tcontinue;\n\t\tmwifiex_wmm_del_pkts_in_ralist_node(priv, ra_list);\n\t\tif (ra_list->tx_paused)\n\t\t\tpriv->wmm.pkts_paused[i] -= ra_list->total_pkt_count;\n\t\telse\n\t\t\tatomic_sub(ra_list->total_pkt_count,\n\t\t\t\t   &priv->wmm.tx_pkts_queued);\n\t\tlist_del(&ra_list->list);\n\t\tkfree(ra_list);\n\t}\n\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n}\n\n/*\n * This function checks if a particular RA list node exists in a given TID\n * table index.\n */\nint\nmwifiex_is_ralist_valid(struct mwifiex_private *priv,\n\t\t\tstruct mwifiex_ra_list_tbl *ra_list, int ptr_index)\n{\n\tstruct mwifiex_ra_list_tbl *rlist;\n\n\tlist_for_each_entry(rlist, &priv->wmm.tid_tbl_ptr[ptr_index].ra_list,\n\t\t\t    list) {\n\t\tif (rlist == ra_list)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/*\n * This function adds a packet to bypass TX queue.\n * This is special TX queue for packets which can be sent even when port_open\n * is false.\n */\nvoid\nmwifiex_wmm_add_buf_bypass_txqueue(struct mwifiex_private *priv,\n\t\t\t\t   struct sk_buff *skb)\n{\n\tskb_queue_tail(&priv->bypass_txq, skb);\n}\n\n/*\n * This function adds a packet to WMM queue.\n *\n * In disconnected state the packet is immediately dropped and the\n * packet send completion callback is called with status failure.\n *\n * Otherwise, the correct RA list node is located and the packet\n * is queued at the list tail.\n */\nvoid\nmwifiex_wmm_add_buf_txqueue(struct mwifiex_private *priv,\n\t\t\t    struct sk_buff *skb)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tu32 tid;\n\tstruct mwifiex_ra_list_tbl *ra_list;\n\tu8 ra[ETH_ALEN], tid_down;\n\tstruct list_head list_head;\n\tint tdls_status = TDLS_NOT_SETUP;\n\tstruct ethhdr *eth_hdr = (struct ethhdr *)skb->data;\n\tstruct mwifiex_txinfo *tx_info = MWIFIEX_SKB_TXCB(skb);\n\n\tmemcpy(ra, eth_hdr->h_dest, ETH_ALEN);\n\n\tif (GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA &&\n\t    ISSUPP_TDLS_ENABLED(adapter->fw_cap_info)) {\n\t\tif (ntohs(eth_hdr->h_proto) == ETH_P_TDLS)\n\t\t\tmwifiex_dbg(adapter, DATA,\n\t\t\t\t    \"TDLS setup packet for %pM.\\t\"\n\t\t\t\t    \"Don't block\\n\", ra);\n\t\telse if (memcmp(priv->cfg_bssid, ra, ETH_ALEN))\n\t\t\ttdls_status = mwifiex_get_tdls_link_status(priv, ra);\n\t}\n\n\tif (!priv->media_connected && !mwifiex_is_skb_mgmt_frame(skb)) {\n\t\tmwifiex_dbg(adapter, DATA, \"data: drop packet in disconnect\\n\");\n\t\tmwifiex_write_data_complete(adapter, skb, 0, -1);\n\t\treturn;\n\t}\n\n\ttid = skb->priority;\n\n\tspin_lock_bh(&priv->wmm.ra_list_spinlock);\n\n\ttid_down = mwifiex_wmm_downgrade_tid(priv, tid);\n\n\t/* In case of infra as we have already created the list during\n\t   association we just don't have to call get_queue_raptr, we will\n\t   have only 1 raptr for a tid in case of infra */\n\tif (!mwifiex_queuing_ra_based(priv) &&\n\t    !mwifiex_is_skb_mgmt_frame(skb)) {\n\t\tswitch (tdls_status) {\n\t\tcase TDLS_SETUP_COMPLETE:\n\t\tcase TDLS_CHAN_SWITCHING:\n\t\tcase TDLS_IN_BASE_CHAN:\n\t\tcase TDLS_IN_OFF_CHAN:\n\t\t\tra_list = mwifiex_wmm_get_queue_raptr(priv, tid_down,\n\t\t\t\t\t\t\t      ra);\n\t\t\ttx_info->flags |= MWIFIEX_BUF_FLAG_TDLS_PKT;\n\t\t\tbreak;\n\t\tcase TDLS_SETUP_INPROGRESS:\n\t\t\tskb_queue_tail(&priv->tdls_txq, skb);\n\t\t\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n\t\t\treturn;\n\t\tdefault:\n\t\t\tlist_head = priv->wmm.tid_tbl_ptr[tid_down].ra_list;\n\t\t\tra_list = list_first_entry_or_null(&list_head,\n\t\t\t\t\tstruct mwifiex_ra_list_tbl, list);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tmemcpy(ra, skb->data, ETH_ALEN);\n\t\tif (ra[0] & 0x01 || mwifiex_is_skb_mgmt_frame(skb))\n\t\t\teth_broadcast_addr(ra);\n\t\tra_list = mwifiex_wmm_get_queue_raptr(priv, tid_down, ra);\n\t}\n\n\tif (!ra_list) {\n\t\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n\t\tmwifiex_write_data_complete(adapter, skb, 0, -1);\n\t\treturn;\n\t}\n\n\tskb_queue_tail(&ra_list->skb_head, skb);\n\n\tra_list->ba_pkt_count++;\n\tra_list->total_pkt_count++;\n\n\tif (atomic_read(&priv->wmm.highest_queued_prio) <\n\t\t\t\t\t\tpriv->tos_to_tid_inv[tid_down])\n\t\tatomic_set(&priv->wmm.highest_queued_prio,\n\t\t\t   priv->tos_to_tid_inv[tid_down]);\n\n\tif (ra_list->tx_paused)\n\t\tpriv->wmm.pkts_paused[tid_down]++;\n\telse\n\t\tatomic_inc(&priv->wmm.tx_pkts_queued);\n\n\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n}\n\n/*\n * This function processes the get WMM status command response from firmware.\n *\n * The response may contain multiple TLVs -\n *      - AC Queue status TLVs\n *      - Current WMM Parameter IE TLV\n *      - Admission Control action frame TLVs\n *\n * This function parses the TLVs and then calls further specific functions\n * to process any changes in the queue prioritize or state.\n */\nint mwifiex_ret_wmm_get_status(struct mwifiex_private *priv,\n\t\t\t       const struct host_cmd_ds_command *resp)\n{\n\tu8 *curr = (u8 *) &resp->params.get_wmm_status;\n\tuint16_t resp_len = le16_to_cpu(resp->size), tlv_len;\n\tint mask = IEEE80211_WMM_IE_AP_QOSINFO_PARAM_SET_CNT_MASK;\n\tbool valid = true;\n\n\tstruct mwifiex_ie_types_data *tlv_hdr;\n\tstruct mwifiex_ie_types_wmm_queue_status *tlv_wmm_qstatus;\n\tstruct ieee_types_wmm_parameter *wmm_param_ie = NULL;\n\tstruct mwifiex_wmm_ac_status *ac_status;\n\n\tmwifiex_dbg(priv->adapter, INFO,\n\t\t    \"info: WMM: WMM_GET_STATUS cmdresp received: %d\\n\",\n\t\t    resp_len);\n\n\twhile ((resp_len >= sizeof(tlv_hdr->header)) && valid) {\n\t\ttlv_hdr = (struct mwifiex_ie_types_data *) curr;\n\t\ttlv_len = le16_to_cpu(tlv_hdr->header.len);\n\n\t\tif (resp_len < tlv_len + sizeof(tlv_hdr->header))\n\t\t\tbreak;\n\n\t\tswitch (le16_to_cpu(tlv_hdr->header.type)) {\n\t\tcase TLV_TYPE_WMMQSTATUS:\n\t\t\ttlv_wmm_qstatus =\n\t\t\t\t(struct mwifiex_ie_types_wmm_queue_status *)\n\t\t\t\ttlv_hdr;\n\t\t\tmwifiex_dbg(priv->adapter, CMD,\n\t\t\t\t    \"info: CMD_RESP: WMM_GET_STATUS:\\t\"\n\t\t\t\t    \"QSTATUS TLV: %d, %d, %d\\n\",\n\t\t\t\t    tlv_wmm_qstatus->queue_index,\n\t\t\t\t    tlv_wmm_qstatus->flow_required,\n\t\t\t\t    tlv_wmm_qstatus->disabled);\n\n\t\t\tac_status = &priv->wmm.ac_status[tlv_wmm_qstatus->\n\t\t\t\t\t\t\t queue_index];\n\t\t\tac_status->disabled = tlv_wmm_qstatus->disabled;\n\t\t\tac_status->flow_required =\n\t\t\t\t\t\ttlv_wmm_qstatus->flow_required;\n\t\t\tac_status->flow_created = tlv_wmm_qstatus->flow_created;\n\t\t\tbreak;\n\n\t\tcase WLAN_EID_VENDOR_SPECIFIC:\n\t\t\t/*\n\t\t\t * Point the regular IEEE IE 2 bytes into the Marvell IE\n\t\t\t *   and setup the IEEE IE type and length byte fields\n\t\t\t */\n\n\t\t\twmm_param_ie =\n\t\t\t\t(struct ieee_types_wmm_parameter *) (curr +\n\t\t\t\t\t\t\t\t    2);\n\t\t\twmm_param_ie->vend_hdr.len = (u8) tlv_len;\n\t\t\twmm_param_ie->vend_hdr.element_id =\n\t\t\t\t\t\tWLAN_EID_VENDOR_SPECIFIC;\n\n\t\t\tmwifiex_dbg(priv->adapter, CMD,\n\t\t\t\t    \"info: CMD_RESP: WMM_GET_STATUS:\\t\"\n\t\t\t\t    \"WMM Parameter Set Count: %d\\n\",\n\t\t\t\t    wmm_param_ie->qos_info_bitmap & mask);\n\n\t\t\tif (wmm_param_ie->vend_hdr.len + 2 >\n\t\t\t\tsizeof(struct ieee_types_wmm_parameter))\n\t\t\t\tbreak;\n\n\t\t\tmemcpy((u8 *) &priv->curr_bss_params.bss_descriptor.\n\t\t\t       wmm_ie, wmm_param_ie,\n\t\t\t       wmm_param_ie->vend_hdr.len + 2);\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tvalid = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tcurr += (tlv_len + sizeof(tlv_hdr->header));\n\t\tresp_len -= (tlv_len + sizeof(tlv_hdr->header));\n\t}\n\n\tmwifiex_wmm_setup_queue_priorities(priv, wmm_param_ie);\n\tmwifiex_wmm_setup_ac_downgrade(priv);\n\n\treturn 0;\n}\n\n/*\n * Callback handler from the command module to allow insertion of a WMM TLV.\n *\n * If the BSS we are associating to supports WMM, this function adds the\n * required WMM Information IE to the association request command buffer in\n * the form of a Marvell extended IEEE IE.\n */\nu32\nmwifiex_wmm_process_association_req(struct mwifiex_private *priv,\n\t\t\t\t    u8 **assoc_buf,\n\t\t\t\t    struct ieee_types_wmm_parameter *wmm_ie,\n\t\t\t\t    struct ieee80211_ht_cap *ht_cap)\n{\n\tstruct mwifiex_ie_types_wmm_param_set *wmm_tlv;\n\tu32 ret_len = 0;\n\n\t/* Null checks */\n\tif (!assoc_buf)\n\t\treturn 0;\n\tif (!(*assoc_buf))\n\t\treturn 0;\n\n\tif (!wmm_ie)\n\t\treturn 0;\n\n\tmwifiex_dbg(priv->adapter, INFO,\n\t\t    \"info: WMM: process assoc req: bss->wmm_ie=%#x\\n\",\n\t\t    wmm_ie->vend_hdr.element_id);\n\n\tif ((priv->wmm_required ||\n\t     (ht_cap && (priv->adapter->config_bands & BAND_GN ||\n\t     priv->adapter->config_bands & BAND_AN))) &&\n\t    wmm_ie->vend_hdr.element_id == WLAN_EID_VENDOR_SPECIFIC) {\n\t\twmm_tlv = (struct mwifiex_ie_types_wmm_param_set *) *assoc_buf;\n\t\twmm_tlv->header.type = cpu_to_le16((u16) wmm_info_ie[0]);\n\t\twmm_tlv->header.len = cpu_to_le16((u16) wmm_info_ie[1]);\n\t\tmemcpy(wmm_tlv->wmm_ie, &wmm_info_ie[2],\n\t\t       le16_to_cpu(wmm_tlv->header.len));\n\t\tif (wmm_ie->qos_info_bitmap & IEEE80211_WMM_IE_AP_QOSINFO_UAPSD)\n\t\t\tmemcpy((u8 *) (wmm_tlv->wmm_ie\n\t\t\t\t       + le16_to_cpu(wmm_tlv->header.len)\n\t\t\t\t       - sizeof(priv->wmm_qosinfo)),\n\t\t\t       &priv->wmm_qosinfo, sizeof(priv->wmm_qosinfo));\n\n\t\tret_len = sizeof(wmm_tlv->header)\n\t\t\t  + le16_to_cpu(wmm_tlv->header.len);\n\n\t\t*assoc_buf += ret_len;\n\t}\n\n\treturn ret_len;\n}\n\n/*\n * This function computes the time delay in the driver queues for a\n * given packet.\n *\n * When the packet is received at the OS/Driver interface, the current\n * time is set in the packet structure. The difference between the present\n * time and that received time is computed in this function and limited\n * based on pre-compiled limits in the driver.\n */\nu8\nmwifiex_wmm_compute_drv_pkt_delay(struct mwifiex_private *priv,\n\t\t\t\t  const struct sk_buff *skb)\n{\n\tu32 queue_delay = ktime_to_ms(net_timedelta(skb->tstamp));\n\tu8 ret_val;\n\n\t/*\n\t * Queue delay is passed as a uint8 in units of 2ms (ms shifted\n\t *  by 1). Min value (other than 0) is therefore 2ms, max is 510ms.\n\t *\n\t * Pass max value if queue_delay is beyond the uint8 range\n\t */\n\tret_val = (u8) (min(queue_delay, priv->wmm.drv_pkt_delay_max) >> 1);\n\n\tmwifiex_dbg(priv->adapter, DATA, \"data: WMM: Pkt Delay: %d ms,\\t\"\n\t\t    \"%d ms sent to FW\\n\", queue_delay, ret_val);\n\n\treturn ret_val;\n}\n\n/*\n * This function retrieves the highest priority RA list table pointer.\n */\nstatic struct mwifiex_ra_list_tbl *\nmwifiex_wmm_get_highest_priolist_ptr(struct mwifiex_adapter *adapter,\n\t\t\t\t     struct mwifiex_private **priv, int *tid)\n{\n\tstruct mwifiex_private *priv_tmp;\n\tstruct mwifiex_ra_list_tbl *ptr;\n\tstruct mwifiex_tid_tbl *tid_ptr;\n\tatomic_t *hqp;\n\tint i, j;\n\n\t/* check the BSS with highest priority first */\n\tfor (j = adapter->priv_num - 1; j >= 0; --j) {\n\t\t/* iterate over BSS with the equal priority */\n\t\tlist_for_each_entry(adapter->bss_prio_tbl[j].bss_prio_cur,\n\t\t\t\t    &adapter->bss_prio_tbl[j].bss_prio_head,\n\t\t\t\t    list) {\n\ntry_again:\n\t\t\tpriv_tmp = adapter->bss_prio_tbl[j].bss_prio_cur->priv;\n\n\t\t\tif (((priv_tmp->bss_mode != NL80211_IFTYPE_ADHOC) &&\n\t\t\t     !priv_tmp->port_open) ||\n\t\t\t    (atomic_read(&priv_tmp->wmm.tx_pkts_queued) == 0))\n\t\t\t\tcontinue;\n\n\t\t\tif (adapter->if_ops.is_port_ready &&\n\t\t\t    !adapter->if_ops.is_port_ready(priv_tmp))\n\t\t\t\tcontinue;\n\n\t\t\t/* iterate over the WMM queues of the BSS */\n\t\t\thqp = &priv_tmp->wmm.highest_queued_prio;\n\t\t\tfor (i = atomic_read(hqp); i >= LOW_PRIO_TID; --i) {\n\n\t\t\t\tspin_lock_bh(&priv_tmp->wmm.ra_list_spinlock);\n\n\t\t\t\ttid_ptr = &(priv_tmp)->wmm.\n\t\t\t\t\ttid_tbl_ptr[tos_to_tid[i]];\n\n\t\t\t\t/* iterate over receiver addresses */\n\t\t\t\tlist_for_each_entry(ptr, &tid_ptr->ra_list,\n\t\t\t\t\t\t    list) {\n\n\t\t\t\t\tif (!ptr->tx_paused &&\n\t\t\t\t\t    !skb_queue_empty(&ptr->skb_head))\n\t\t\t\t\t\t/* holds both locks */\n\t\t\t\t\t\tgoto found;\n\t\t\t\t}\n\n\t\t\t\tspin_unlock_bh(&priv_tmp->wmm.ra_list_spinlock);\n\t\t\t}\n\n\t\t\tif (atomic_read(&priv_tmp->wmm.tx_pkts_queued) != 0) {\n\t\t\t\tatomic_set(&priv_tmp->wmm.highest_queued_prio,\n\t\t\t\t\t   HIGH_PRIO_TID);\n\t\t\t\t/* Iterate current private once more, since\n\t\t\t\t * there still exist packets in data queue\n\t\t\t\t */\n\t\t\t\tgoto try_again;\n\t\t\t} else\n\t\t\t\tatomic_set(&priv_tmp->wmm.highest_queued_prio,\n\t\t\t\t\t   NO_PKT_PRIO_TID);\n\t\t}\n\t}\n\n\treturn NULL;\n\nfound:\n\t/* holds ra_list_spinlock */\n\tif (atomic_read(hqp) > i)\n\t\tatomic_set(hqp, i);\n\tspin_unlock_bh(&priv_tmp->wmm.ra_list_spinlock);\n\n\t*priv = priv_tmp;\n\t*tid = tos_to_tid[i];\n\n\treturn ptr;\n}\n\n/* This functions rotates ra and bss lists so packets are picked round robin.\n *\n * After a packet is successfully transmitted, rotate the ra list, so the ra\n * next to the one transmitted, will come first in the list. This way we pick\n * the ra' in a round robin fashion. Same applies to bss nodes of equal\n * priority.\n *\n * Function also increments wmm.packets_out counter.\n */\nvoid mwifiex_rotate_priolists(struct mwifiex_private *priv,\n\t\t\t\t struct mwifiex_ra_list_tbl *ra,\n\t\t\t\t int tid)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct mwifiex_bss_prio_tbl *tbl = adapter->bss_prio_tbl;\n\tstruct mwifiex_tid_tbl *tid_ptr = &priv->wmm.tid_tbl_ptr[tid];\n\n\tspin_lock_bh(&tbl[priv->bss_priority].bss_prio_lock);\n\t/*\n\t * dirty trick: we remove 'head' temporarily and reinsert it after\n\t * curr bss node. imagine list to stay fixed while head is moved\n\t */\n\tlist_move(&tbl[priv->bss_priority].bss_prio_head,\n\t\t  &tbl[priv->bss_priority].bss_prio_cur->list);\n\tspin_unlock_bh(&tbl[priv->bss_priority].bss_prio_lock);\n\n\tspin_lock_bh(&priv->wmm.ra_list_spinlock);\n\tif (mwifiex_is_ralist_valid(priv, ra, tid)) {\n\t\tpriv->wmm.packets_out[tid]++;\n\t\t/* same as above */\n\t\tlist_move(&tid_ptr->ra_list, &ra->list);\n\t}\n\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n}\n\n/*\n * This function checks if 11n aggregation is possible.\n */\nstatic int\nmwifiex_is_11n_aggragation_possible(struct mwifiex_private *priv,\n\t\t\t\t    struct mwifiex_ra_list_tbl *ptr,\n\t\t\t\t    int max_buf_size)\n{\n\tint count = 0, total_size = 0;\n\tstruct sk_buff *skb, *tmp;\n\tint max_amsdu_size;\n\n\tif (priv->bss_role == MWIFIEX_BSS_ROLE_UAP && priv->ap_11n_enabled &&\n\t    ptr->is_11n_enabled)\n\t\tmax_amsdu_size = min_t(int, ptr->max_amsdu, max_buf_size);\n\telse\n\t\tmax_amsdu_size = max_buf_size;\n\n\tskb_queue_walk_safe(&ptr->skb_head, skb, tmp) {\n\t\ttotal_size += skb->len;\n\t\tif (total_size >= max_amsdu_size)\n\t\t\tbreak;\n\t\tif (++count >= MIN_NUM_AMSDU)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/*\n * This function sends a single packet to firmware for transmission.\n */\nstatic void\nmwifiex_send_single_packet(struct mwifiex_private *priv,\n\t\t\t   struct mwifiex_ra_list_tbl *ptr, int ptr_index)\n\t\t\t   __releases(&priv->wmm.ra_list_spinlock)\n{\n\tstruct sk_buff *skb, *skb_next;\n\tstruct mwifiex_tx_param tx_param;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct mwifiex_txinfo *tx_info;\n\n\tif (skb_queue_empty(&ptr->skb_head)) {\n\t\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n\t\tmwifiex_dbg(adapter, DATA, \"data: nothing to send\\n\");\n\t\treturn;\n\t}\n\n\tskb = skb_dequeue(&ptr->skb_head);\n\n\ttx_info = MWIFIEX_SKB_TXCB(skb);\n\tmwifiex_dbg(adapter, DATA,\n\t\t    \"data: dequeuing the packet %p %p\\n\", ptr, skb);\n\n\tptr->total_pkt_count--;\n\n\tif (!skb_queue_empty(&ptr->skb_head))\n\t\tskb_next = skb_peek(&ptr->skb_head);\n\telse\n\t\tskb_next = NULL;\n\n\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n\n\ttx_param.next_pkt_len = ((skb_next) ? skb_next->len +\n\t\t\t\tsizeof(struct txpd) : 0);\n\n\tif (mwifiex_process_tx(priv, skb, &tx_param) == -EBUSY) {\n\t\t/* Queue the packet back at the head */\n\t\tspin_lock_bh(&priv->wmm.ra_list_spinlock);\n\n\t\tif (!mwifiex_is_ralist_valid(priv, ptr, ptr_index)) {\n\t\t\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n\t\t\tmwifiex_write_data_complete(adapter, skb, 0, -1);\n\t\t\treturn;\n\t\t}\n\n\t\tskb_queue_tail(&ptr->skb_head, skb);\n\n\t\tptr->total_pkt_count++;\n\t\tptr->ba_pkt_count++;\n\t\ttx_info->flags |= MWIFIEX_BUF_FLAG_REQUEUED_PKT;\n\t\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n\t} else {\n\t\tmwifiex_rotate_priolists(priv, ptr, ptr_index);\n\t\tatomic_dec(&priv->wmm.tx_pkts_queued);\n\t}\n}\n\n/*\n * This function checks if the first packet in the given RA list\n * is already processed or not.\n */\nstatic int\nmwifiex_is_ptr_processed(struct mwifiex_private *priv,\n\t\t\t struct mwifiex_ra_list_tbl *ptr)\n{\n\tstruct sk_buff *skb;\n\tstruct mwifiex_txinfo *tx_info;\n\n\tif (skb_queue_empty(&ptr->skb_head))\n\t\treturn false;\n\n\tskb = skb_peek(&ptr->skb_head);\n\n\ttx_info = MWIFIEX_SKB_TXCB(skb);\n\tif (tx_info->flags & MWIFIEX_BUF_FLAG_REQUEUED_PKT)\n\t\treturn true;\n\n\treturn false;\n}\n\n/*\n * This function sends a single processed packet to firmware for\n * transmission.\n */\nstatic void\nmwifiex_send_processed_packet(struct mwifiex_private *priv,\n\t\t\t      struct mwifiex_ra_list_tbl *ptr, int ptr_index)\n\t\t\t\t__releases(&priv->wmm.ra_list_spinlock)\n{\n\tstruct mwifiex_tx_param tx_param;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tint ret = -1;\n\tstruct sk_buff *skb, *skb_next;\n\tstruct mwifiex_txinfo *tx_info;\n\n\tif (skb_queue_empty(&ptr->skb_head)) {\n\t\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n\t\treturn;\n\t}\n\n\tskb = skb_dequeue(&ptr->skb_head);\n\n\tif (adapter->data_sent || adapter->tx_lock_flag) {\n\t\tptr->total_pkt_count--;\n\t\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n\t\tskb_queue_tail(&adapter->tx_data_q, skb);\n\t\tatomic_dec(&priv->wmm.tx_pkts_queued);\n\t\tatomic_inc(&adapter->tx_queued);\n\t\treturn;\n\t}\n\n\tif (!skb_queue_empty(&ptr->skb_head))\n\t\tskb_next = skb_peek(&ptr->skb_head);\n\telse\n\t\tskb_next = NULL;\n\n\ttx_info = MWIFIEX_SKB_TXCB(skb);\n\n\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n\n\ttx_param.next_pkt_len =\n\t\t((skb_next) ? skb_next->len +\n\t\t sizeof(struct txpd) : 0);\n\tif (adapter->iface_type == MWIFIEX_USB) {\n\t\tret = adapter->if_ops.host_to_card(adapter, priv->usb_port,\n\t\t\t\t\t\t   skb, &tx_param);\n\t} else {\n\t\tret = adapter->if_ops.host_to_card(adapter, MWIFIEX_TYPE_DATA,\n\t\t\t\t\t\t   skb, &tx_param);\n\t}\n\n\tswitch (ret) {\n\tcase -EBUSY:\n\t\tmwifiex_dbg(adapter, ERROR, \"data: -EBUSY is returned\\n\");\n\t\tspin_lock_bh(&priv->wmm.ra_list_spinlock);\n\n\t\tif (!mwifiex_is_ralist_valid(priv, ptr, ptr_index)) {\n\t\t\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n\t\t\tmwifiex_write_data_complete(adapter, skb, 0, -1);\n\t\t\treturn;\n\t\t}\n\n\t\tskb_queue_tail(&ptr->skb_head, skb);\n\n\t\ttx_info->flags |= MWIFIEX_BUF_FLAG_REQUEUED_PKT;\n\t\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n\t\tbreak;\n\tcase -1:\n\t\tmwifiex_dbg(adapter, ERROR, \"host_to_card failed: %#x\\n\", ret);\n\t\tadapter->dbg.num_tx_host_to_card_failure++;\n\t\tmwifiex_write_data_complete(adapter, skb, 0, ret);\n\t\tbreak;\n\tcase -EINPROGRESS:\n\t\tbreak;\n\tcase 0:\n\t\tmwifiex_write_data_complete(adapter, skb, 0, ret);\n\tdefault:\n\t\tbreak;\n\t}\n\tif (ret != -EBUSY) {\n\t\tmwifiex_rotate_priolists(priv, ptr, ptr_index);\n\t\tatomic_dec(&priv->wmm.tx_pkts_queued);\n\t\tspin_lock_bh(&priv->wmm.ra_list_spinlock);\n\t\tptr->total_pkt_count--;\n\t\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n\t}\n}\n\n/*\n * This function dequeues a packet from the highest priority list\n * and transmits it.\n */\nstatic int\nmwifiex_dequeue_tx_packet(struct mwifiex_adapter *adapter)\n{\n\tstruct mwifiex_ra_list_tbl *ptr;\n\tstruct mwifiex_private *priv = NULL;\n\tint ptr_index = 0;\n\tu8 ra[ETH_ALEN];\n\tint tid_del = 0, tid = 0;\n\n\tptr = mwifiex_wmm_get_highest_priolist_ptr(adapter, &priv, &ptr_index);\n\tif (!ptr)\n\t\treturn -1;\n\n\ttid = mwifiex_get_tid(ptr);\n\n\tmwifiex_dbg(adapter, DATA, \"data: tid=%d\\n\", tid);\n\n\tspin_lock_bh(&priv->wmm.ra_list_spinlock);\n\tif (!mwifiex_is_ralist_valid(priv, ptr, ptr_index)) {\n\t\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n\t\treturn -1;\n\t}\n\n\tif (mwifiex_is_ptr_processed(priv, ptr)) {\n\t\tmwifiex_send_processed_packet(priv, ptr, ptr_index);\n\t\t/* ra_list_spinlock has been freed in\n\t\t   mwifiex_send_processed_packet() */\n\t\treturn 0;\n\t}\n\n\tif (!ptr->is_11n_enabled ||\n\t\tptr->ba_status ||\n\t\tpriv->wps.session_enable) {\n\t\tif (ptr->is_11n_enabled &&\n\t\t\tptr->ba_status &&\n\t\t\tptr->amsdu_in_ampdu &&\n\t\t\tmwifiex_is_amsdu_allowed(priv, tid) &&\n\t\t\tmwifiex_is_11n_aggragation_possible(priv, ptr,\n\t\t\t\t\t\t\tadapter->tx_buf_size))\n\t\t\tmwifiex_11n_aggregate_pkt(priv, ptr, ptr_index);\n\t\t\t/* ra_list_spinlock has been freed in\n\t\t\t * mwifiex_11n_aggregate_pkt()\n\t\t\t */\n\t\telse\n\t\t\tmwifiex_send_single_packet(priv, ptr, ptr_index);\n\t\t\t/* ra_list_spinlock has been freed in\n\t\t\t * mwifiex_send_single_packet()\n\t\t\t */\n\t} else {\n\t\tif (mwifiex_is_ampdu_allowed(priv, ptr, tid) &&\n\t\t    ptr->ba_pkt_count > ptr->ba_packet_thr) {\n\t\t\tif (mwifiex_space_avail_for_new_ba_stream(adapter)) {\n\t\t\t\tmwifiex_create_ba_tbl(priv, ptr->ra, tid,\n\t\t\t\t\t\t      BA_SETUP_INPROGRESS);\n\t\t\t\tmwifiex_send_addba(priv, tid, ptr->ra);\n\t\t\t} else if (mwifiex_find_stream_to_delete\n\t\t\t\t   (priv, tid, &tid_del, ra)) {\n\t\t\t\tmwifiex_create_ba_tbl(priv, ptr->ra, tid,\n\t\t\t\t\t\t      BA_SETUP_INPROGRESS);\n\t\t\t\tmwifiex_send_delba(priv, tid_del, ra, 1);\n\t\t\t}\n\t\t}\n\t\tif (mwifiex_is_amsdu_allowed(priv, tid) &&\n\t\t    mwifiex_is_11n_aggragation_possible(priv, ptr,\n\t\t\t\t\t\t\tadapter->tx_buf_size))\n\t\t\tmwifiex_11n_aggregate_pkt(priv, ptr, ptr_index);\n\t\t\t/* ra_list_spinlock has been freed in\n\t\t\t   mwifiex_11n_aggregate_pkt() */\n\t\telse\n\t\t\tmwifiex_send_single_packet(priv, ptr, ptr_index);\n\t\t\t/* ra_list_spinlock has been freed in\n\t\t\t   mwifiex_send_single_packet() */\n\t}\n\treturn 0;\n}\n\nvoid mwifiex_process_bypass_tx(struct mwifiex_adapter *adapter)\n{\n\tstruct mwifiex_tx_param tx_param;\n\tstruct sk_buff *skb;\n\tstruct mwifiex_txinfo *tx_info;\n\tstruct mwifiex_private *priv;\n\tint i;\n\n\tif (adapter->data_sent || adapter->tx_lock_flag)\n\t\treturn;\n\n\tfor (i = 0; i < adapter->priv_num; ++i) {\n\t\tpriv = adapter->priv[i];\n\n\t\tif (!priv)\n\t\t\tcontinue;\n\n\t\tif (adapter->if_ops.is_port_ready &&\n\t\t    !adapter->if_ops.is_port_ready(priv))\n\t\t\tcontinue;\n\n\t\tif (skb_queue_empty(&priv->bypass_txq))\n\t\t\tcontinue;\n\n\t\tskb = skb_dequeue(&priv->bypass_txq);\n\t\ttx_info = MWIFIEX_SKB_TXCB(skb);\n\n\t\t/* no aggregation for bypass packets */\n\t\ttx_param.next_pkt_len = 0;\n\n\t\tif (mwifiex_process_tx(priv, skb, &tx_param) == -EBUSY) {\n\t\t\tskb_queue_head(&priv->bypass_txq, skb);\n\t\t\ttx_info->flags |= MWIFIEX_BUF_FLAG_REQUEUED_PKT;\n\t\t} else {\n\t\t\tatomic_dec(&adapter->bypass_tx_pending);\n\t\t}\n\t}\n}\n\n/*\n * This function transmits the highest priority packet awaiting in the\n * WMM Queues.\n */\nvoid\nmwifiex_wmm_process_tx(struct mwifiex_adapter *adapter)\n{\n\tdo {\n\t\tif (mwifiex_dequeue_tx_packet(adapter))\n\t\t\tbreak;\n\t\tif (adapter->iface_type != MWIFIEX_SDIO) {\n\t\t\tif (adapter->data_sent ||\n\t\t\t    adapter->tx_lock_flag)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (atomic_read(&adapter->tx_queued) >=\n\t\t\t    MWIFIEX_MAX_PKTS_TXQ)\n\t\t\t\tbreak;\n\t\t}\n\t} while (!mwifiex_wmm_lists_empty(adapter));\n}\n"], "filenames": ["drivers/net/wireless/marvell/mwifiex/wmm.c"], "buggy_code_start_loc": [971], "buggy_code_end_loc": [971], "fixing_code_start_loc": [972], "fixing_code_end_loc": [976], "type": "CWE-787", "message": "An issue was found in Linux kernel before 5.5.4. mwifiex_ret_wmm_get_status() in drivers/net/wireless/marvell/mwifiex/wmm.c allows a remote AP to trigger a heap-based buffer overflow because of an incorrect memcpy, aka CID-3a9b153c5591.", "other": {"cve": {"id": "CVE-2020-12654", "sourceIdentifier": "cve@mitre.org", "published": "2020-05-05T05:15:11.300", "lastModified": "2020-06-16T20:15:13.287", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An issue was found in Linux kernel before 5.5.4. mwifiex_ret_wmm_get_status() in drivers/net/wireless/marvell/mwifiex/wmm.c allows a remote AP to trigger a heap-based buffer overflow because of an incorrect memcpy, aka CID-3a9b153c5591."}, {"lang": "es", "value": "Se detect\u00f3 un problema en el kernel de Linux versiones anteriores a 5.5.4. En la funci\u00f3n mwifiex_ret_wmm_get_status() en el archivo drivers/net/wireless/marvell/mwifiex/wmm.c permite a un AP remoto desencadenar un desbordamiento del b\u00fafer en la regi\u00f3n heap de la memoria debido a una memcpy incorrecta, tambi\u00e9n se conoce como CID-3a9b153c5591."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:A/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.2, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:A/AC:H/Au:N/C:P/I:P/A:P", "accessVector": "ADJACENT_NETWORK", "accessComplexity": "HIGH", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.2, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.5.4", "matchCriteriaId": "25611CC0-E1DB-4D7B-82DF-D16CB8355844"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-06/msg00022.html", "source": "cve@mitre.org"}, {"url": "http://www.openwall.com/lists/oss-security/2020/05/08/2", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.5.4", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=3a9b153c5591548612c3955c9600a98150c81875", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/3a9b153c5591548612c3955c9600a98150c81875", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/06/msg00011.html", "source": "cve@mitre.org"}, {"url": "https://lists.debian.org/debian-lts-announce/2020/06/msg00012.html", "source": "cve@mitre.org"}, {"url": "https://lists.debian.org/debian-lts-announce/2020/06/msg00013.html", "source": "cve@mitre.org"}, {"url": "https://security.netapp.com/advisory/ntap-20200608-0001/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4392-1/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4393-1/", "source": "cve@mitre.org"}, {"url": "https://www.debian.org/security/2020/dsa-4698", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/3a9b153c5591548612c3955c9600a98150c81875"}}