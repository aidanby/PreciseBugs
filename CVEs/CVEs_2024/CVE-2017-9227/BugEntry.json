{"buggy_code": ["/**********************************************************************\n  regexec.c -  Oniguruma (regular expression library)\n**********************************************************************/\n/*-\n * Copyright (c) 2002-2016  K.Kosako  <sndgk393 AT ybb DOT ne DOT jp>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#include \"regint.h\"\n\n#define USE_MATCH_RANGE_MUST_BE_INSIDE_OF_SPECIFIED_RANGE\n\n#ifdef USE_CRNL_AS_LINE_TERMINATOR\n#define ONIGENC_IS_MBC_CRNL(enc,p,end) \\\n  (ONIGENC_MBC_TO_CODE(enc,p,end) == 13 && \\\n   ONIGENC_IS_MBC_NEWLINE(enc,(p+enclen(enc,p)),end))\n#endif\n\n#ifdef USE_CAPTURE_HISTORY\nstatic void history_tree_free(OnigCaptureTreeNode* node);\n\nstatic void\nhistory_tree_clear(OnigCaptureTreeNode* node)\n{\n  int i;\n\n  if (IS_NOT_NULL(node)) {\n    for (i = 0; i < node->num_childs; i++) {\n      if (IS_NOT_NULL(node->childs[i])) {\n        history_tree_free(node->childs[i]);\n      }\n    }\n    for (i = 0; i < node->allocated; i++) {\n      node->childs[i] = (OnigCaptureTreeNode* )0;\n    }\n    node->num_childs = 0;\n    node->beg = ONIG_REGION_NOTPOS;\n    node->end = ONIG_REGION_NOTPOS;\n    node->group = -1;\n  }\n}\n\nstatic void\nhistory_tree_free(OnigCaptureTreeNode* node)\n{\n  history_tree_clear(node);\n  xfree(node);\n}\n\nstatic void\nhistory_root_free(OnigRegion* r)\n{\n  if (IS_NOT_NULL(r->history_root)) {\n    history_tree_free(r->history_root);\n    r->history_root = (OnigCaptureTreeNode* )0;\n  }\n}\n\nstatic OnigCaptureTreeNode*\nhistory_node_new(void)\n{\n  OnigCaptureTreeNode* node;\n\n  node = (OnigCaptureTreeNode* )xmalloc(sizeof(OnigCaptureTreeNode));\n  CHECK_NULL_RETURN(node);\n  node->childs     = (OnigCaptureTreeNode** )0;\n  node->allocated  = 0;\n  node->num_childs = 0;\n  node->group      = -1;\n  node->beg        = ONIG_REGION_NOTPOS;\n  node->end        = ONIG_REGION_NOTPOS;\n\n  return node;\n}\n\nstatic int\nhistory_tree_add_child(OnigCaptureTreeNode* parent, OnigCaptureTreeNode* child)\n{\n#define HISTORY_TREE_INIT_ALLOC_SIZE  8\n\n  if (parent->num_childs >= parent->allocated) {\n    int n, i;\n\n    if (IS_NULL(parent->childs)) {\n      n = HISTORY_TREE_INIT_ALLOC_SIZE;\n      parent->childs =\n        (OnigCaptureTreeNode** )xmalloc(sizeof(OnigCaptureTreeNode*) * n);\n    }\n    else {\n      n = parent->allocated * 2;\n      parent->childs =\n        (OnigCaptureTreeNode** )xrealloc(parent->childs,\n                                         sizeof(OnigCaptureTreeNode*) * n);\n    }\n    CHECK_NULL_RETURN_MEMERR(parent->childs);\n    for (i = parent->allocated; i < n; i++) {\n      parent->childs[i] = (OnigCaptureTreeNode* )0;\n    }\n    parent->allocated = n;\n  }\n\n  parent->childs[parent->num_childs] = child;\n  parent->num_childs++;\n  return 0;\n}\n\nstatic OnigCaptureTreeNode*\nhistory_tree_clone(OnigCaptureTreeNode* node)\n{\n  int i;\n  OnigCaptureTreeNode *clone, *child;\n\n  clone = history_node_new();\n  CHECK_NULL_RETURN(clone);\n\n  clone->beg = node->beg;\n  clone->end = node->end;\n  for (i = 0; i < node->num_childs; i++) {\n    child = history_tree_clone(node->childs[i]);\n    if (IS_NULL(child)) {\n      history_tree_free(clone);\n      return (OnigCaptureTreeNode* )0;\n    }\n    history_tree_add_child(clone, child);\n  }\n\n  return clone;\n}\n\nextern  OnigCaptureTreeNode*\nonig_get_capture_tree(OnigRegion* region)\n{\n  return region->history_root;\n}\n#endif /* USE_CAPTURE_HISTORY */\n\nextern void\nonig_region_clear(OnigRegion* region)\n{\n  int i;\n\n  for (i = 0; i < region->num_regs; i++) {\n    region->beg[i] = region->end[i] = ONIG_REGION_NOTPOS;\n  }\n#ifdef USE_CAPTURE_HISTORY\n  history_root_free(region);\n#endif\n}\n\nextern int\nonig_region_resize(OnigRegion* region, int n)\n{\n  region->num_regs = n;\n\n  if (n < ONIG_NREGION)\n    n = ONIG_NREGION;\n\n  if (region->allocated == 0) {\n    region->beg = (int* )xmalloc(n * sizeof(int));\n    region->end = (int* )xmalloc(n * sizeof(int));\n\n    if (region->beg == 0 || region->end == 0)\n      return ONIGERR_MEMORY;\n\n    region->allocated = n;\n  }\n  else if (region->allocated < n) {\n    region->beg = (int* )xrealloc(region->beg, n * sizeof(int));\n    region->end = (int* )xrealloc(region->end, n * sizeof(int));\n\n    if (region->beg == 0 || region->end == 0)\n      return ONIGERR_MEMORY;\n\n    region->allocated = n;\n  }\n\n  return 0;\n}\n\nstatic int\nonig_region_resize_clear(OnigRegion* region, int n)\n{\n  int r;\n  \n  r = onig_region_resize(region, n);\n  if (r != 0) return r;\n  onig_region_clear(region);\n  return 0;\n}\n    \nextern int\nonig_region_set(OnigRegion* region, int at, int beg, int end)\n{\n  if (at < 0) return ONIGERR_INVALID_ARGUMENT;\n\n  if (at >= region->allocated) {\n    int r = onig_region_resize(region, at + 1);\n    if (r < 0) return r;\n  }\n  \n  region->beg[at] = beg;\n  region->end[at] = end;\n  return 0;\n}\n\nextern void\nonig_region_init(OnigRegion* region)\n{\n  region->num_regs     = 0;\n  region->allocated    = 0;\n  region->beg          = (int* )0;\n  region->end          = (int* )0;\n  region->history_root = (OnigCaptureTreeNode* )0;\n}\n\nextern OnigRegion*\nonig_region_new(void)\n{\n  OnigRegion* r;\n\n  r = (OnigRegion* )xmalloc(sizeof(OnigRegion));\n  onig_region_init(r);\n  return r;\n}\n\nextern void\nonig_region_free(OnigRegion* r, int free_self)\n{\n  if (r) {\n    if (r->allocated > 0) {\n      if (r->beg) xfree(r->beg);\n      if (r->end) xfree(r->end);\n      r->allocated = 0;\n    }\n#ifdef USE_CAPTURE_HISTORY\n    history_root_free(r);\n#endif\n    if (free_self) xfree(r);\n  }\n}\n\nextern void\nonig_region_copy(OnigRegion* to, OnigRegion* from)\n{\n#define RREGC_SIZE   (sizeof(int) * from->num_regs)\n  int i;\n\n  if (to == from) return;\n\n  if (to->allocated == 0) {\n    if (from->num_regs > 0) {\n      to->beg = (int* )xmalloc(RREGC_SIZE);\n      to->end = (int* )xmalloc(RREGC_SIZE);\n      to->allocated = from->num_regs;\n    }\n  }\n  else if (to->allocated < from->num_regs) {\n    to->beg = (int* )xrealloc(to->beg, RREGC_SIZE);\n    to->end = (int* )xrealloc(to->end, RREGC_SIZE);\n    to->allocated = from->num_regs;\n  }\n\n  for (i = 0; i < from->num_regs; i++) {\n    to->beg[i] = from->beg[i];\n    to->end[i] = from->end[i];\n  }\n  to->num_regs = from->num_regs;\n\n#ifdef USE_CAPTURE_HISTORY\n  history_root_free(to);\n\n  if (IS_NOT_NULL(from->history_root)) {\n    to->history_root = history_tree_clone(from->history_root);\n  }\n#endif\n}\n\n\n/** stack **/\n#define INVALID_STACK_INDEX   -1\n\n/* stack type */\n/* used by normal-POP */\n#define STK_ALT                    0x0001\n#define STK_LOOK_BEHIND_NOT        0x0002\n#define STK_POS_NOT                0x0003\n/* handled by normal-POP */\n#define STK_MEM_START              0x0100\n#define STK_MEM_END                0x8200\n#define STK_REPEAT_INC             0x0300\n#define STK_STATE_CHECK_MARK       0x1000\n/* avoided by normal-POP */\n#define STK_NULL_CHECK_START       0x3000\n#define STK_NULL_CHECK_END         0x5000  /* for recursive call */\n#define STK_MEM_END_MARK           0x8400\n#define STK_POS                    0x0500  /* used when POP-POS */\n#define STK_STOP_BT                0x0600  /* mark for \"(?>...)\" */\n#define STK_REPEAT                 0x0700\n#define STK_CALL_FRAME             0x0800\n#define STK_RETURN                 0x0900\n#define STK_VOID                   0x0a00  /* for fill a blank */\n\n/* stack type check mask */\n#define STK_MASK_POP_USED          0x00ff\n#define STK_MASK_TO_VOID_TARGET    0x10ff\n#define STK_MASK_MEM_END_OR_MARK   0x8000  /* MEM_END or MEM_END_MARK */\n\n#ifdef USE_FIND_LONGEST_SEARCH_ALL_OF_RANGE\n#define MATCH_ARG_INIT(msa, reg, arg_option, arg_region, arg_start) do {\\\n  (msa).stack_p  = (void* )0;\\\n  (msa).options  = (arg_option);\\\n  (msa).region   = (arg_region);\\\n  (msa).start    = (arg_start);\\\n  (msa).best_len = ONIG_MISMATCH;\\\n  (msa).ptr_num  = (reg)->num_repeat + (reg)->num_mem * 2;\\\n} while(0)\n#else\n#define MATCH_ARG_INIT(msa, reg, arg_option, arg_region, arg_start) do {\\\n  (msa).stack_p  = (void* )0;\\\n  (msa).options  = (arg_option);\\\n  (msa).region   = (arg_region);\\\n  (msa).start    = (arg_start);\\\n  (msa).ptr_num  = (reg)->num_repeat + (reg)->num_mem * 2;\\\n} while(0)\n#endif\n\n#ifdef USE_COMBINATION_EXPLOSION_CHECK\n\n#define STATE_CHECK_BUFF_MALLOC_THRESHOLD_SIZE  16\n\n#define STATE_CHECK_BUFF_INIT(msa, str_len, offset, state_num) do {\t\\\n  if ((state_num) > 0 && str_len >= STATE_CHECK_STRING_THRESHOLD_LEN) {\\\n    unsigned int size = (unsigned int )(((str_len) + 1) * (state_num) + 7) >> 3;\\\n    offset = ((offset) * (state_num)) >> 3;\\\n    if (size > 0 && offset < size && size < STATE_CHECK_BUFF_MAX_SIZE) {\\\n      if (size >= STATE_CHECK_BUFF_MALLOC_THRESHOLD_SIZE) \\\n        (msa).state_check_buff = (void* )xmalloc(size);\\\n      else \\\n        (msa).state_check_buff = (void* )xalloca(size);\\\n      xmemset(((char* )((msa).state_check_buff)+(offset)), 0, \\\n              (size_t )(size - (offset))); \\\n      (msa).state_check_buff_size = size;\\\n    }\\\n    else {\\\n      (msa).state_check_buff = (void* )0;\\\n      (msa).state_check_buff_size = 0;\\\n    }\\\n  }\\\n  else {\\\n    (msa).state_check_buff = (void* )0;\\\n    (msa).state_check_buff_size = 0;\\\n  }\\\n} while(0)\n\n#define MATCH_ARG_FREE(msa) do {\\\n  if ((msa).stack_p) xfree((msa).stack_p);\\\n  if ((msa).state_check_buff_size >= STATE_CHECK_BUFF_MALLOC_THRESHOLD_SIZE) { \\\n    if ((msa).state_check_buff) xfree((msa).state_check_buff);\\\n  }\\\n} while(0)\n#else\n#define STATE_CHECK_BUFF_INIT(msa, str_len, offset, state_num)\n#define MATCH_ARG_FREE(msa)  if ((msa).stack_p) xfree((msa).stack_p)\n#endif\n\n\n#define ALLOCA_PTR_NUM_LIMIT   50\n\n#define STACK_INIT(stack_num)  do {\\\n  if (msa->stack_p) {\\\n    is_alloca  = 0;\\\n    alloc_base = msa->stack_p;\\\n    stk_base   = (OnigStackType* )(alloc_base\\\n                 + (sizeof(OnigStackIndex) * msa->ptr_num));\\\n    stk        = stk_base;\\\n    stk_end    = stk_base + msa->stack_n;\\\n  }\\\n  else if (msa->ptr_num > ALLOCA_PTR_NUM_LIMIT) {\\\n    is_alloca  = 0;\\\n    alloc_base = (char* )xmalloc(sizeof(OnigStackIndex) * msa->ptr_num\\\n                  + sizeof(OnigStackType) * (stack_num));\\\n    stk_base   = (OnigStackType* )(alloc_base\\\n                 + (sizeof(OnigStackIndex) * msa->ptr_num));\\\n    stk        = stk_base;\\\n    stk_end    = stk_base + (stack_num);\\\n  }\\\n  else {\\\n    is_alloca  = 1;\\\n    alloc_base = (char* )xalloca(sizeof(OnigStackIndex) * msa->ptr_num\\\n                 + sizeof(OnigStackType) * (stack_num));\\\n    stk_base   = (OnigStackType* )(alloc_base\\\n                 + (sizeof(OnigStackIndex) * msa->ptr_num));\\\n    stk        = stk_base;\\\n    stk_end    = stk_base + (stack_num);\\\n  }\\\n} while(0);\n\n\n#define STACK_SAVE do{\\\n  msa->stack_n = stk_end - stk_base;\\\n  if (is_alloca != 0) {\\\n    size_t size = sizeof(OnigStackIndex) * msa->ptr_num \\\n                + sizeof(OnigStackType) * msa->stack_n;\\\n    msa->stack_p = xmalloc(size);\\\n    xmemcpy(msa->stack_p, alloc_base, size);\\\n  }\\\n  else {\\\n    msa->stack_p = alloc_base;\\\n  };\\\n} while(0)\n\n#define UPDATE_FOR_STACK_REALLOC do{\\\n  repeat_stk = (OnigStackIndex* )alloc_base;\\\n  mem_start_stk = (OnigStackIndex* )(repeat_stk + reg->num_repeat);\\\n  mem_end_stk   = mem_start_stk + num_mem;\\\n  mem_start_stk--; /* for index start from 1 */\\\n  mem_end_stk--;   /* for index start from 1 */\\\n} while(0)\n\nstatic unsigned int MatchStackLimitSize = DEFAULT_MATCH_STACK_LIMIT_SIZE;\n\nextern unsigned int\nonig_get_match_stack_limit_size(void)\n{\n  return MatchStackLimitSize;\n}\n\nextern int\nonig_set_match_stack_limit_size(unsigned int size)\n{\n  MatchStackLimitSize = size;\n  return 0;\n}\n\nstatic int\nstack_double(int is_alloca, char** arg_alloc_base,\n\t     OnigStackType** arg_stk_base,\n\t     OnigStackType** arg_stk_end, OnigStackType** arg_stk,\n\t     OnigMatchArg* msa)\n{\n  unsigned int n;\n  int used;\n  size_t size;\n  size_t new_size;\n  char* alloc_base;\n  char* new_alloc_base;\n  OnigStackType *stk_base, *stk_end, *stk;\n\n  alloc_base = *arg_alloc_base;\n  stk_base = *arg_stk_base;\n  stk_end  = *arg_stk_end;\n  stk      = *arg_stk;\n\n  n = stk_end - stk_base;\n  size = sizeof(OnigStackIndex) * msa->ptr_num + sizeof(OnigStackType) * n;\n  n *= 2;\n  new_size = sizeof(OnigStackIndex) * msa->ptr_num + sizeof(OnigStackType) * n;\n  if (is_alloca != 0) {\n    new_alloc_base = (char* )xmalloc(new_size);\n    if (IS_NULL(new_alloc_base)) {\n      STACK_SAVE;\n      return ONIGERR_MEMORY;\n    }\n    xmemcpy(new_alloc_base, alloc_base, size);\n  }\n  else {\n    if (MatchStackLimitSize != 0 && n > MatchStackLimitSize) {\n      if ((unsigned int )(stk_end - stk_base) == MatchStackLimitSize)\n        return ONIGERR_MATCH_STACK_LIMIT_OVER;\n      else\n        n = MatchStackLimitSize;\n    }\n    new_alloc_base = (char* )xrealloc(alloc_base, new_size);\n    if (IS_NULL(new_alloc_base)) {\n      STACK_SAVE;\n      return ONIGERR_MEMORY;\n    }\n  }\n\n  alloc_base = new_alloc_base;\n  used = stk - stk_base;\n  *arg_alloc_base = alloc_base;\n  *arg_stk_base   = (OnigStackType* )(alloc_base\n\t\t       + (sizeof(OnigStackIndex) * msa->ptr_num));\n  *arg_stk      = *arg_stk_base + used;\n  *arg_stk_end  = *arg_stk_base + n;\n  return 0;\n}\n\n#define STACK_ENSURE(n)\tdo {\\\n  if (stk_end - stk < (n)) {\\\n    int r = stack_double(is_alloca, &alloc_base, &stk_base, &stk_end, &stk,\\\n                         msa);\\\n    if (r != 0) { STACK_SAVE; return r; } \\\n    is_alloca = 0;\\\n    UPDATE_FOR_STACK_REALLOC;\\\n  }\\\n} while(0)\n\n#define STACK_AT(index)        (stk_base + (index))\n#define GET_STACK_INDEX(stk)   ((stk) - stk_base)\n\n#define STACK_PUSH_TYPE(stack_type) do {\\\n  STACK_ENSURE(1);\\\n  stk->type = (stack_type);\\\n  STACK_INC;\\\n} while(0)\n\n#define IS_TO_VOID_TARGET(stk) (((stk)->type & STK_MASK_TO_VOID_TARGET) != 0)\n\n#ifdef USE_COMBINATION_EXPLOSION_CHECK\n#define STATE_CHECK_POS(s,snum) \\\n  (((s) - str) * num_comb_exp_check + ((snum) - 1))\n#define STATE_CHECK_VAL(v,snum) do {\\\n  if (state_check_buff != NULL) {\\\n    int x = STATE_CHECK_POS(s,snum);\\\n    (v) = state_check_buff[x/8] & (1<<(x%8));\\\n  }\\\n  else (v) = 0;\\\n} while(0)\n\n\n#define ELSE_IF_STATE_CHECK_MARK(stk) \\\n  else if ((stk)->type == STK_STATE_CHECK_MARK) { \\\n    int x = STATE_CHECK_POS(stk->u.state.pstr, stk->u.state.state_check);\\\n    state_check_buff[x/8] |= (1<<(x%8));\t\t\t\t\\\n  }\n\n#define STACK_PUSH(stack_type,pat,s,sprev) do {\\\n  STACK_ENSURE(1);\\\n  stk->type = (stack_type);\\\n  stk->u.state.pcode     = (pat);\\\n  stk->u.state.pstr      = (s);\\\n  stk->u.state.pstr_prev = (sprev);\\\n  stk->u.state.state_check = 0;\\\n  STACK_INC;\\\n} while(0)\n\n#define STACK_PUSH_ENSURED(stack_type,pat) do {\\\n  stk->type = (stack_type);\\\n  stk->u.state.pcode = (pat);\\\n  stk->u.state.state_check = 0;\\\n  STACK_INC;\\\n} while(0)\n\n#define STACK_PUSH_ALT_WITH_STATE_CHECK(pat,s,sprev,snum) do {\\\n  STACK_ENSURE(1);\\\n  stk->type = STK_ALT;\\\n  stk->u.state.pcode     = (pat);\\\n  stk->u.state.pstr      = (s);\\\n  stk->u.state.pstr_prev = (sprev);\\\n  stk->u.state.state_check = ((state_check_buff != NULL) ? (snum) : 0);\\\n  STACK_INC;\\\n} while(0)\n\n#define STACK_PUSH_STATE_CHECK(s,snum) do {\\\n  if (state_check_buff != NULL) {\\\n    STACK_ENSURE(1);\\\n    stk->type = STK_STATE_CHECK_MARK;\\\n    stk->u.state.pstr = (s);\\\n    stk->u.state.state_check = (snum);\\\n    STACK_INC;\\\n  }\\\n} while(0)\n\n#else /* USE_COMBINATION_EXPLOSION_CHECK */\n\n#define ELSE_IF_STATE_CHECK_MARK(stk)\n\n#define STACK_PUSH(stack_type,pat,s,sprev) do {\\\n  STACK_ENSURE(1);\\\n  stk->type = (stack_type);\\\n  stk->u.state.pcode     = (pat);\\\n  stk->u.state.pstr      = (s);\\\n  stk->u.state.pstr_prev = (sprev);\\\n  STACK_INC;\\\n} while(0)\n\n#define STACK_PUSH_ENSURED(stack_type,pat) do {\\\n  stk->type = (stack_type);\\\n  stk->u.state.pcode = (pat);\\\n  STACK_INC;\\\n} while(0)\n#endif /* USE_COMBINATION_EXPLOSION_CHECK */\n\n#define STACK_PUSH_ALT(pat,s,sprev)     STACK_PUSH(STK_ALT,pat,s,sprev)\n#define STACK_PUSH_POS(s,sprev)         STACK_PUSH(STK_POS,NULL_UCHARP,s,sprev)\n#define STACK_PUSH_POS_NOT(pat,s,sprev) STACK_PUSH(STK_POS_NOT,pat,s,sprev)\n#define STACK_PUSH_STOP_BT              STACK_PUSH_TYPE(STK_STOP_BT)\n#define STACK_PUSH_LOOK_BEHIND_NOT(pat,s,sprev) \\\n        STACK_PUSH(STK_LOOK_BEHIND_NOT,pat,s,sprev)\n\n#define STACK_PUSH_REPEAT(id, pat) do {\\\n  STACK_ENSURE(1);\\\n  stk->type = STK_REPEAT;\\\n  stk->u.repeat.num    = (id);\\\n  stk->u.repeat.pcode  = (pat);\\\n  stk->u.repeat.count  = 0;\\\n  STACK_INC;\\\n} while(0)\n\n#define STACK_PUSH_REPEAT_INC(sindex) do {\\\n  STACK_ENSURE(1);\\\n  stk->type = STK_REPEAT_INC;\\\n  stk->u.repeat_inc.si  = (sindex);\\\n  STACK_INC;\\\n} while(0)\n\n#define STACK_PUSH_MEM_START(mnum, s) do {\\\n  STACK_ENSURE(1);\\\n  stk->type = STK_MEM_START;\\\n  stk->u.mem.num      = (mnum);\\\n  stk->u.mem.pstr     = (s);\\\n  stk->u.mem.start    = mem_start_stk[mnum];\\\n  stk->u.mem.end      = mem_end_stk[mnum];\\\n  mem_start_stk[mnum] = GET_STACK_INDEX(stk);\\\n  mem_end_stk[mnum]   = INVALID_STACK_INDEX;\\\n  STACK_INC;\\\n} while(0)\n\n#define STACK_PUSH_MEM_END(mnum, s) do {\\\n  STACK_ENSURE(1);\\\n  stk->type = STK_MEM_END;\\\n  stk->u.mem.num    = (mnum);\\\n  stk->u.mem.pstr   = (s);\\\n  stk->u.mem.start  = mem_start_stk[mnum];\\\n  stk->u.mem.end    = mem_end_stk[mnum];\\\n  mem_end_stk[mnum] = GET_STACK_INDEX(stk);\\\n  STACK_INC;\\\n} while(0)\n\n#define STACK_PUSH_MEM_END_MARK(mnum) do {\\\n  STACK_ENSURE(1);\\\n  stk->type = STK_MEM_END_MARK;\\\n  stk->u.mem.num = (mnum);\\\n  STACK_INC;\\\n} while(0)\n\n#define STACK_GET_MEM_START(mnum, k) do {\\\n  int level = 0;\\\n  k = stk;\\\n  while (k > stk_base) {\\\n    k--;\\\n    if ((k->type & STK_MASK_MEM_END_OR_MARK) != 0 \\\n      && k->u.mem.num == (mnum)) {\\\n      level++;\\\n    }\\\n    else if (k->type == STK_MEM_START && k->u.mem.num == (mnum)) {\\\n      if (level == 0) break;\\\n      level--;\\\n    }\\\n  }\\\n} while(0)\n\n#define STACK_GET_MEM_RANGE(k, mnum, start, end) do {\\\n  int level = 0;\\\n  while (k < stk) {\\\n    if (k->type == STK_MEM_START && k->u.mem.num == (mnum)) {\\\n      if (level == 0) (start) = k->u.mem.pstr;\\\n      level++;\\\n    }\\\n    else if (k->type == STK_MEM_END && k->u.mem.num == (mnum)) {\\\n      level--;\\\n      if (level == 0) {\\\n        (end) = k->u.mem.pstr;\\\n        break;\\\n      }\\\n    }\\\n    k++;\\\n  }\\\n} while(0)\n\n#define STACK_PUSH_NULL_CHECK_START(cnum, s) do {\\\n  STACK_ENSURE(1);\\\n  stk->type = STK_NULL_CHECK_START;\\\n  stk->u.null_check.num  = (cnum);\\\n  stk->u.null_check.pstr = (s);\\\n  STACK_INC;\\\n} while(0)\n\n#define STACK_PUSH_NULL_CHECK_END(cnum) do {\\\n  STACK_ENSURE(1);\\\n  stk->type = STK_NULL_CHECK_END;\\\n  stk->u.null_check.num  = (cnum);\\\n  STACK_INC;\\\n} while(0)\n\n#define STACK_PUSH_CALL_FRAME(pat) do {\\\n  STACK_ENSURE(1);\\\n  stk->type = STK_CALL_FRAME;\\\n  stk->u.call_frame.ret_addr = (pat);\\\n  STACK_INC;\\\n} while(0)\n\n#define STACK_PUSH_RETURN do {\\\n  STACK_ENSURE(1);\\\n  stk->type = STK_RETURN;\\\n  STACK_INC;\\\n} while(0)\n\n\n#ifdef ONIG_DEBUG\n#define STACK_BASE_CHECK(p, at) \\\n  if ((p) < stk_base) {\\\n    fprintf(stderr, \"at %s\\n\", at);\\\n    goto stack_error;\\\n  }\n#else\n#define STACK_BASE_CHECK(p, at)\n#endif\n\n#define STACK_POP_ONE do {\\\n  stk--;\\\n  STACK_BASE_CHECK(stk, \"STACK_POP_ONE\"); \\\n} while(0)\n\n#define STACK_POP  do {\\\n  switch (pop_level) {\\\n  case STACK_POP_LEVEL_FREE:\\\n    while (1) {\\\n      stk--;\\\n      STACK_BASE_CHECK(stk, \"STACK_POP\"); \\\n      if ((stk->type & STK_MASK_POP_USED) != 0)  break;\\\n      ELSE_IF_STATE_CHECK_MARK(stk);\\\n    }\\\n    break;\\\n  case STACK_POP_LEVEL_MEM_START:\\\n    while (1) {\\\n      stk--;\\\n      STACK_BASE_CHECK(stk, \"STACK_POP 2\"); \\\n      if ((stk->type & STK_MASK_POP_USED) != 0)  break;\\\n      else if (stk->type == STK_MEM_START) {\\\n        mem_start_stk[stk->u.mem.num] = stk->u.mem.start;\\\n        mem_end_stk[stk->u.mem.num]   = stk->u.mem.end;\\\n      }\\\n      ELSE_IF_STATE_CHECK_MARK(stk);\\\n    }\\\n    break;\\\n  default:\\\n    while (1) {\\\n      stk--;\\\n      STACK_BASE_CHECK(stk, \"STACK_POP 3\"); \\\n      if ((stk->type & STK_MASK_POP_USED) != 0)  break;\\\n      else if (stk->type == STK_MEM_START) {\\\n        mem_start_stk[stk->u.mem.num] = stk->u.mem.start;\\\n        mem_end_stk[stk->u.mem.num]   = stk->u.mem.end;\\\n      }\\\n      else if (stk->type == STK_REPEAT_INC) {\\\n        STACK_AT(stk->u.repeat_inc.si)->u.repeat.count--;\\\n      }\\\n      else if (stk->type == STK_MEM_END) {\\\n        mem_start_stk[stk->u.mem.num] = stk->u.mem.start;\\\n        mem_end_stk[stk->u.mem.num]   = stk->u.mem.end;\\\n      }\\\n      ELSE_IF_STATE_CHECK_MARK(stk);\\\n    }\\\n    break;\\\n  }\\\n} while(0)\n\n#define STACK_POP_TIL_POS_NOT  do {\\\n  while (1) {\\\n    stk--;\\\n    STACK_BASE_CHECK(stk, \"STACK_POP_TIL_POS_NOT\"); \\\n    if (stk->type == STK_POS_NOT) break;\\\n    else if (stk->type == STK_MEM_START) {\\\n      mem_start_stk[stk->u.mem.num] = stk->u.mem.start;\\\n      mem_end_stk[stk->u.mem.num]   = stk->u.mem.end;\\\n    }\\\n    else if (stk->type == STK_REPEAT_INC) {\\\n      STACK_AT(stk->u.repeat_inc.si)->u.repeat.count--;\\\n    }\\\n    else if (stk->type == STK_MEM_END) {\\\n      mem_start_stk[stk->u.mem.num] = stk->u.mem.start;\\\n      mem_end_stk[stk->u.mem.num]   = stk->u.mem.end;\\\n    }\\\n    ELSE_IF_STATE_CHECK_MARK(stk);\\\n  }\\\n} while(0)\n\n#define STACK_POP_TIL_LOOK_BEHIND_NOT  do {\\\n  while (1) {\\\n    stk--;\\\n    STACK_BASE_CHECK(stk, \"STACK_POP_TIL_LOOK_BEHIND_NOT\"); \\\n    if (stk->type == STK_LOOK_BEHIND_NOT) break;\\\n    else if (stk->type == STK_MEM_START) {\\\n      mem_start_stk[stk->u.mem.num] = stk->u.mem.start;\\\n      mem_end_stk[stk->u.mem.num]   = stk->u.mem.end;\\\n    }\\\n    else if (stk->type == STK_REPEAT_INC) {\\\n      STACK_AT(stk->u.repeat_inc.si)->u.repeat.count--;\\\n    }\\\n    else if (stk->type == STK_MEM_END) {\\\n      mem_start_stk[stk->u.mem.num] = stk->u.mem.start;\\\n      mem_end_stk[stk->u.mem.num]   = stk->u.mem.end;\\\n    }\\\n    ELSE_IF_STATE_CHECK_MARK(stk);\\\n  }\\\n} while(0)\n\n#define STACK_POS_END(k) do {\\\n  k = stk;\\\n  while (1) {\\\n    k--;\\\n    STACK_BASE_CHECK(k, \"STACK_POS_END\"); \\\n    if (IS_TO_VOID_TARGET(k)) {\\\n      k->type = STK_VOID;\\\n    }\\\n    else if (k->type == STK_POS) {\\\n      k->type = STK_VOID;\\\n      break;\\\n    }\\\n  }\\\n} while(0)\n\n#define STACK_STOP_BT_END do {\\\n  OnigStackType *k = stk;\\\n  while (1) {\\\n    k--;\\\n    STACK_BASE_CHECK(k, \"STACK_STOP_BT_END\"); \\\n    if (IS_TO_VOID_TARGET(k)) {\\\n      k->type = STK_VOID;\\\n    }\\\n    else if (k->type == STK_STOP_BT) {\\\n      k->type = STK_VOID;\\\n      break;\\\n    }\\\n  }\\\n} while(0)\n\n#define STACK_NULL_CHECK(isnull,id,s) do {\\\n  OnigStackType* k = stk;\\\n  while (1) {\\\n    k--;\\\n    STACK_BASE_CHECK(k, \"STACK_NULL_CHECK\"); \\\n    if (k->type == STK_NULL_CHECK_START) {\\\n      if (k->u.null_check.num == (id)) {\\\n        (isnull) = (k->u.null_check.pstr == (s));\\\n        break;\\\n      }\\\n    }\\\n  }\\\n} while(0)\n\n#define STACK_NULL_CHECK_REC(isnull,id,s) do {\\\n  int level = 0;\\\n  OnigStackType* k = stk;\\\n  while (1) {\\\n    k--;\\\n    STACK_BASE_CHECK(k, \"STACK_NULL_CHECK_REC\"); \\\n    if (k->type == STK_NULL_CHECK_START) {\\\n      if (k->u.null_check.num == (id)) {\\\n        if (level == 0) {\\\n          (isnull) = (k->u.null_check.pstr == (s));\\\n          break;\\\n        }\\\n        else level--;\\\n      }\\\n    }\\\n    else if (k->type == STK_NULL_CHECK_END) {\\\n      level++;\\\n    }\\\n  }\\\n} while(0)\n\n#define STACK_NULL_CHECK_MEMST(isnull,id,s,reg) do {\\\n  OnigStackType* k = stk;\\\n  while (1) {\\\n    k--;\\\n    STACK_BASE_CHECK(k, \"STACK_NULL_CHECK_MEMST\"); \\\n    if (k->type == STK_NULL_CHECK_START) {\\\n      if (k->u.null_check.num == (id)) {\\\n        if (k->u.null_check.pstr != (s)) {\\\n          (isnull) = 0;\\\n          break;\\\n        }\\\n        else {\\\n          UChar* endp;\\\n          (isnull) = 1;\\\n          while (k < stk) {\\\n            if (k->type == STK_MEM_START) {\\\n              if (k->u.mem.end == INVALID_STACK_INDEX) {\\\n                (isnull) = 0; break;\\\n              }\\\n              if (BIT_STATUS_AT(reg->bt_mem_end, k->u.mem.num))\\\n                endp = STACK_AT(k->u.mem.end)->u.mem.pstr;\\\n              else\\\n                endp = (UChar* )k->u.mem.end;\\\n              if (STACK_AT(k->u.mem.start)->u.mem.pstr != endp) {\\\n                (isnull) = 0; break;\\\n              }\\\n              else if (endp != s) {\\\n                (isnull) = -1; /* empty, but position changed */ \\\n              }\\\n            }\\\n            k++;\\\n          }\\\n  \t  break;\\\n        }\\\n      }\\\n    }\\\n  }\\\n} while(0)\n\n#define STACK_NULL_CHECK_MEMST_REC(isnull,id,s,reg) do {\\\n  int level = 0;\\\n  OnigStackType* k = stk;\\\n  while (1) {\\\n    k--;\\\n    STACK_BASE_CHECK(k, \"STACK_NULL_CHECK_MEMST_REC\"); \\\n    if (k->type == STK_NULL_CHECK_START) {\\\n      if (k->u.null_check.num == (id)) {\\\n        if (level == 0) {\\\n          if (k->u.null_check.pstr != (s)) {\\\n            (isnull) = 0;\\\n            break;\\\n          }\\\n          else {\\\n            UChar* endp;\\\n            (isnull) = 1;\\\n            while (k < stk) {\\\n              if (k->type == STK_MEM_START) {\\\n                if (k->u.mem.end == INVALID_STACK_INDEX) {\\\n                  (isnull) = 0; break;\\\n                }\\\n                if (BIT_STATUS_AT(reg->bt_mem_end, k->u.mem.num))\\\n                  endp = STACK_AT(k->u.mem.end)->u.mem.pstr;\\\n                else\\\n                  endp = (UChar* )k->u.mem.end;\\\n                if (STACK_AT(k->u.mem.start)->u.mem.pstr != endp) {\\\n                  (isnull) = 0; break;\\\n                }\\\n                else if (endp != s) {\\\n                  (isnull) = -1; /* empty, but position changed */ \\\n                }\\\n              }\\\n              k++;\\\n            }\\\n  \t    break;\\\n          }\\\n        }\\\n        else {\\\n          level--;\\\n        }\\\n      }\\\n    }\\\n    else if (k->type == STK_NULL_CHECK_END) {\\\n      if (k->u.null_check.num == (id)) level++;\\\n    }\\\n  }\\\n} while(0)\n\n#define STACK_GET_REPEAT(id, k) do {\\\n  int level = 0;\\\n  k = stk;\\\n  while (1) {\\\n    k--;\\\n    STACK_BASE_CHECK(k, \"STACK_GET_REPEAT\"); \\\n    if (k->type == STK_REPEAT) {\\\n      if (level == 0) {\\\n        if (k->u.repeat.num == (id)) {\\\n          break;\\\n        }\\\n      }\\\n    }\\\n    else if (k->type == STK_CALL_FRAME) level--;\\\n    else if (k->type == STK_RETURN)     level++;\\\n  }\\\n} while(0)\n\n#define STACK_RETURN(addr)  do {\\\n  int level = 0;\\\n  OnigStackType* k = stk;\\\n  while (1) {\\\n    k--;\\\n    STACK_BASE_CHECK(k, \"STACK_RETURN\"); \\\n    if (k->type == STK_CALL_FRAME) {\\\n      if (level == 0) {\\\n        (addr) = k->u.call_frame.ret_addr;\\\n        break;\\\n      }\\\n      else level--;\\\n    }\\\n    else if (k->type == STK_RETURN)\\\n      level++;\\\n  }\\\n} while(0)\n\n\n#define STRING_CMP(s1,s2,len) do {\\\n  while (len-- > 0) {\\\n    if (*s1++ != *s2++) goto fail;\\\n  }\\\n} while(0)\n\n#define STRING_CMP_IC(case_fold_flag,s1,ps2,len) do {\\\n  if (string_cmp_ic(encode, case_fold_flag, s1, ps2, len) == 0) \\\n    goto fail; \\\n} while(0)\n\nstatic int string_cmp_ic(OnigEncoding enc, int case_fold_flag,\n\t\t\t UChar* s1, UChar** ps2, int mblen)\n{\n  UChar buf1[ONIGENC_MBC_CASE_FOLD_MAXLEN];\n  UChar buf2[ONIGENC_MBC_CASE_FOLD_MAXLEN];\n  UChar *p1, *p2, *end1, *s2, *end2;\n  int len1, len2;\n\n  s2   = *ps2;\n  end1 = s1 + mblen;\n  end2 = s2 + mblen;\n  while (s1 < end1) {\n    len1 = ONIGENC_MBC_CASE_FOLD(enc, case_fold_flag, &s1, end1, buf1);\n    len2 = ONIGENC_MBC_CASE_FOLD(enc, case_fold_flag, &s2, end2, buf2);\n    if (len1 != len2) return 0;\n    p1 = buf1;\n    p2 = buf2;\n    while (len1-- > 0) {\n      if (*p1 != *p2) return 0;\n      p1++;\n      p2++;\n    }\n  }\n\n  *ps2 = s2;\n  return 1;\n}\n\n#define STRING_CMP_VALUE(s1,s2,len,is_fail) do {\\\n  is_fail = 0;\\\n  while (len-- > 0) {\\\n    if (*s1++ != *s2++) {\\\n      is_fail = 1; break;\\\n    }\\\n  }\\\n} while(0)\n\n#define STRING_CMP_VALUE_IC(case_fold_flag,s1,ps2,len,is_fail) do {\\\n  if (string_cmp_ic(encode, case_fold_flag, s1, ps2, len) == 0) \\\n    is_fail = 1; \\\n  else \\\n    is_fail = 0; \\\n} while(0)\n\n\n#define IS_EMPTY_STR           (str == end)\n#define ON_STR_BEGIN(s)       ((s) == str)\n#define ON_STR_END(s)         ((s) == end)\n#ifdef USE_MATCH_RANGE_MUST_BE_INSIDE_OF_SPECIFIED_RANGE\n#define DATA_ENSURE_CHECK1     (s < right_range)\n#define DATA_ENSURE_CHECK(n)   (s + (n) <= right_range)\n#define DATA_ENSURE(n)         if (s + (n) > right_range) goto fail\n#else\n#define DATA_ENSURE_CHECK1     (s < end)\n#define DATA_ENSURE_CHECK(n)   (s + (n) <= end)\n#define DATA_ENSURE(n)         if (s + (n) > end) goto fail\n#endif /* USE_MATCH_RANGE_MUST_BE_INSIDE_OF_SPECIFIED_RANGE */\n\n\n#ifdef USE_CAPTURE_HISTORY\nstatic int\nmake_capture_history_tree(OnigCaptureTreeNode* node, OnigStackType** kp,\n                          OnigStackType* stk_top, UChar* str, regex_t* reg)\n{\n  int n, r;\n  OnigCaptureTreeNode* child;\n  OnigStackType* k = *kp;\n\n  while (k < stk_top) {\n    if (k->type == STK_MEM_START) {\n      n = k->u.mem.num;\n      if (n <= ONIG_MAX_CAPTURE_HISTORY_GROUP &&\n          BIT_STATUS_AT(reg->capture_history, n) != 0) {\n        child = history_node_new();\n        CHECK_NULL_RETURN_MEMERR(child);\n        child->group = n;\n        child->beg = (int )(k->u.mem.pstr - str);\n        r = history_tree_add_child(node, child);\n        if (r != 0) return r;\n        *kp = (k + 1);\n        r = make_capture_history_tree(child, kp, stk_top, str, reg);\n        if (r != 0) return r;\n\n        k = *kp;\n        child->end = (int )(k->u.mem.pstr - str);\n      }\n    }\n    else if (k->type == STK_MEM_END) {\n      if (k->u.mem.num == node->group) {\n        node->end = (int )(k->u.mem.pstr - str);\n        *kp = k;\n        return 0;\n      }\n    }\n    k++;\n  }\n\n  return 1; /* 1: root node ending. */\n}\n#endif\n\n#ifdef USE_BACKREF_WITH_LEVEL\nstatic int mem_is_in_memp(int mem, int num, UChar* memp)\n{\n  int i;\n  MemNumType m;\n\n  for (i = 0; i < num; i++) {\n    GET_MEMNUM_INC(m, memp);\n    if (mem == (int )m) return 1;\n  }\n  return 0;\n}\n\nstatic int backref_match_at_nested_level(regex_t* reg\n\t , OnigStackType* top, OnigStackType* stk_base\n\t , int ignore_case, int case_fold_flag\n\t , int nest, int mem_num, UChar* memp, UChar** s, const UChar* send)\n{\n  UChar *ss, *p, *pstart, *pend = NULL_UCHARP;\n  int level;\n  OnigStackType* k;\n\n  level = 0;\n  k = top;\n  k--;\n  while (k >= stk_base) {\n    if (k->type == STK_CALL_FRAME) {\n      level--;\n    }\n    else if (k->type == STK_RETURN) {\n      level++;\n    }\n    else if (level == nest) {\n      if (k->type == STK_MEM_START) {\n        if (mem_is_in_memp(k->u.mem.num, mem_num, memp)) {\n          pstart = k->u.mem.pstr;\n          if (pend != NULL_UCHARP) {\n            if (pend - pstart > send - *s) return 0; /* or goto next_mem; */\n            p  = pstart;\n            ss = *s;\n\n            if (ignore_case != 0) {\n              if (string_cmp_ic(reg->enc, case_fold_flag,\n                                pstart, &ss, (int )(pend - pstart)) == 0)\n                return 0; /* or goto next_mem; */\n            }\n            else {\n              while (p < pend) {\n                if (*p++ != *ss++) return 0; /* or goto next_mem; */\n              }\n            }\n\n            *s = ss;\n            return 1;\n          }\n        }\n      }\n      else if (k->type == STK_MEM_END) {\n        if (mem_is_in_memp(k->u.mem.num, mem_num, memp)) {\n          pend = k->u.mem.pstr;\n        }\n      }\n    }\n    k--;\n  }\n\n  return 0;\n}\n#endif /* USE_BACKREF_WITH_LEVEL */\n\n\n#ifdef ONIG_DEBUG_STATISTICS\n\n#define USE_TIMEOFDAY\n\n#ifdef USE_TIMEOFDAY\n#ifdef HAVE_SYS_TIME_H\n#include <sys/time.h>\n#endif\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\nstatic struct timeval ts, te;\n#define GETTIME(t)        gettimeofday(&(t), (struct timezone* )0)\n#define TIMEDIFF(te,ts)   (((te).tv_usec - (ts).tv_usec) + \\\n                           (((te).tv_sec - (ts).tv_sec)*1000000))\n#else\n#ifdef HAVE_SYS_TIMES_H\n#include <sys/times.h>\n#endif\nstatic struct tms ts, te;\n#define GETTIME(t)         times(&(t))\n#define TIMEDIFF(te,ts)   ((te).tms_utime - (ts).tms_utime)\n#endif\n\nstatic int OpCounter[256];\nstatic int OpPrevCounter[256];\nstatic unsigned long OpTime[256];\nstatic int OpCurr = OP_FINISH;\nstatic int OpPrevTarget = OP_FAIL;\nstatic int MaxStackDepth = 0;\n\n#define MOP_IN(opcode) do {\\\n  if (opcode == OpPrevTarget) OpPrevCounter[OpCurr]++;\\\n  OpCurr = opcode;\\\n  OpCounter[opcode]++;\\\n  GETTIME(ts);\\\n} while(0)\n\n#define MOP_OUT do {\\\n  GETTIME(te);\\\n  OpTime[OpCurr] += TIMEDIFF(te, ts);\\\n} while(0)\n\nextern void\nonig_statistics_init(void)\n{\n  int i;\n  for (i = 0; i < 256; i++) {\n    OpCounter[i] = OpPrevCounter[i] = 0; OpTime[i] = 0;\n  }\n  MaxStackDepth = 0;\n}\n\nextern int\nonig_print_statistics(FILE* f)\n{\n  int r;\n  int i;\n\n  r = fprintf(f, \"   count      prev        time\\n\");\n  if (r < 0) return -1;\n\n  for (i = 0; OnigOpInfo[i].opcode >= 0; i++) {\n    r = fprintf(f, \"%8d: %8d: %10ld: %s\\n\",\n                OpCounter[i], OpPrevCounter[i], OpTime[i], OnigOpInfo[i].name);\n    if (r < 0) return -1;\n  }\n  r = fprintf(f, \"\\nmax stack depth: %d\\n\", MaxStackDepth);\n  if (r < 0) return -1;\n\n  return 0;\n}\n\n#define STACK_INC do {\\\n  stk++;\\\n  if (stk - stk_base > MaxStackDepth) \\\n    MaxStackDepth = stk - stk_base;\\\n} while(0)\n\n#else\n#define STACK_INC     stk++\n\n#define MOP_IN(opcode)\n#define MOP_OUT\n#endif\n\n\n/* matching region of POSIX API */\ntypedef int regoff_t;\n\ntypedef struct {\n  regoff_t  rm_so;\n  regoff_t  rm_eo;\n} posix_regmatch_t;\n\n/* match data(str - end) from position (sstart). */\n/* if sstart == str then set sprev to NULL. */\nstatic int\nmatch_at(regex_t* reg, const UChar* str, const UChar* end,\n#ifdef USE_MATCH_RANGE_MUST_BE_INSIDE_OF_SPECIFIED_RANGE\n\t const UChar* right_range,\n#endif\n\t const UChar* sstart, UChar* sprev, OnigMatchArg* msa)\n{\n  static UChar FinishCode[] = { OP_FINISH };\n\n  int i, n, num_mem, best_len, pop_level;\n  LengthType tlen, tlen2;\n  MemNumType mem;\n  RelAddrType addr;\n  UChar *s, *q, *sbegin;\n  int is_alloca;\n  char *alloc_base;\n  OnigStackType *stk_base, *stk, *stk_end;\n  OnigStackType *stkp; /* used as any purpose. */\n  OnigStackIndex si;\n  OnigStackIndex *repeat_stk;\n  OnigStackIndex *mem_start_stk, *mem_end_stk;\n#ifdef USE_COMBINATION_EXPLOSION_CHECK\n  int scv;\n  unsigned char* state_check_buff = msa->state_check_buff;\n  int num_comb_exp_check = reg->num_comb_exp_check;\n#endif\n  UChar *p = reg->p;\n  OnigOptionType option = reg->options;\n  OnigEncoding encode = reg->enc;\n  OnigCaseFoldType case_fold_flag = reg->case_fold_flag;\n\n  //n = reg->num_repeat + reg->num_mem * 2;\n  pop_level = reg->stack_pop_level;\n  num_mem = reg->num_mem;\n  STACK_INIT(INIT_MATCH_STACK_SIZE);\n  UPDATE_FOR_STACK_REALLOC;\n  for (i = 1; i <= num_mem; i++) {\n    mem_start_stk[i] = mem_end_stk[i] = INVALID_STACK_INDEX;\n  }\n\n#ifdef ONIG_DEBUG_MATCH\n  fprintf(stderr, \"match_at: str: %d, end: %d, start: %d, sprev: %d\\n\",\n\t  (int )str, (int )end, (int )sstart, (int )sprev);\n  fprintf(stderr, \"size: %d, start offset: %d\\n\",\n\t  (int )(end - str), (int )(sstart - str));\n#endif\n\n  STACK_PUSH_ENSURED(STK_ALT, FinishCode);  /* bottom stack */\n  best_len = ONIG_MISMATCH;\n  s = (UChar* )sstart;\n  while (1) {\n#ifdef ONIG_DEBUG_MATCH\n    {\n      UChar *q, *bp, buf[50];\n      int len;\n      fprintf(stderr, \"%4d> \\\"\", (int )(s - str));\n      bp = buf;\n      for (i = 0, q = s; i < 7 && q < end; i++) {\n\tlen = enclen(encode, q);\n\twhile (len-- > 0) *bp++ = *q++;\n      }\n      if (q < end) { xmemcpy(bp, \"...\\\"\", 4); bp += 4; }\n      else         { xmemcpy(bp, \"\\\"\",    1); bp += 1; }\n      *bp = 0;\n      fputs((char* )buf, stderr);\n      for (i = 0; i < 20 - (bp - buf); i++) fputc(' ', stderr);\n      onig_print_compiled_byte_code(stderr, p, NULL, encode);\n      fprintf(stderr, \"\\n\");\n    }\n#endif\n\n    sbegin = s;\n    switch (*p++) {\n    case OP_END:  MOP_IN(OP_END);\n      n = s - sstart;\n      if (n > best_len) {\n        OnigRegion* region;\n#ifdef USE_FIND_LONGEST_SEARCH_ALL_OF_RANGE\n        if (IS_FIND_LONGEST(option)) {\n          if (n > msa->best_len) {\n            msa->best_len = n;\n            msa->best_s   = (UChar* )sstart;\n          }\n          else\n            goto end_best_len;\n        }\n#endif\n        best_len = n;\n        region = msa->region;\n        if (region) {\n#ifdef USE_POSIX_API_REGION_OPTION\n          if (IS_POSIX_REGION(msa->options)) {\n            posix_regmatch_t* rmt = (posix_regmatch_t* )region;\n\n            rmt[0].rm_so = sstart - str;\n            rmt[0].rm_eo = s      - str;\n            for (i = 1; i <= num_mem; i++) {\n              if (mem_end_stk[i] != INVALID_STACK_INDEX) {\n                if (BIT_STATUS_AT(reg->bt_mem_start, i))\n                  rmt[i].rm_so = STACK_AT(mem_start_stk[i])->u.mem.pstr - str;\n                else\n                  rmt[i].rm_so = (UChar* )((void* )(mem_start_stk[i])) - str;\n\n                rmt[i].rm_eo = (BIT_STATUS_AT(reg->bt_mem_end, i)\n                                ? STACK_AT(mem_end_stk[i])->u.mem.pstr\n                                : (UChar* )((void* )mem_end_stk[i])) - str;\n              }\n              else {\n                rmt[i].rm_so = rmt[i].rm_eo = ONIG_REGION_NOTPOS;\n              }\n            }\n          }\n          else {\n#endif /* USE_POSIX_API_REGION_OPTION */\n            region->beg[0] = sstart - str;\n            region->end[0] = s      - str;\n            for (i = 1; i <= num_mem; i++) {\n              if (mem_end_stk[i] != INVALID_STACK_INDEX) {\n                if (BIT_STATUS_AT(reg->bt_mem_start, i))\n                  region->beg[i] = STACK_AT(mem_start_stk[i])->u.mem.pstr - str;\n                else\n                  region->beg[i] = (UChar* )((void* )mem_start_stk[i]) - str;\n\n                region->end[i] = (BIT_STATUS_AT(reg->bt_mem_end, i)\n                                  ? STACK_AT(mem_end_stk[i])->u.mem.pstr\n                                  : (UChar* )((void* )mem_end_stk[i])) - str;\n              }\n              else {\n                region->beg[i] = region->end[i] = ONIG_REGION_NOTPOS;\n              }\n            }\n\n#ifdef USE_CAPTURE_HISTORY\n            if (reg->capture_history != 0) {\n              int r;\n              OnigCaptureTreeNode* node;\n\n              if (IS_NULL(region->history_root)) {\n                region->history_root = node = history_node_new();\n                CHECK_NULL_RETURN_MEMERR(node);\n              }\n              else {\n                node = region->history_root;\n                history_tree_clear(node);\n              }\n\n              node->group = 0;\n              node->beg   = sstart - str;\n              node->end   = s      - str;\n\n              stkp = stk_base;\n              r = make_capture_history_tree(region->history_root, &stkp,\n                                            stk, (UChar* )str, reg);\n              if (r < 0) {\n                best_len = r; /* error code */\n                goto finish;\n              }\n            }\n#endif /* USE_CAPTURE_HISTORY */\n#ifdef USE_POSIX_API_REGION_OPTION\n          } /* else IS_POSIX_REGION() */\n#endif\n        } /* if (region) */\n      } /* n > best_len */\n\n#ifdef USE_FIND_LONGEST_SEARCH_ALL_OF_RANGE\n    end_best_len:\n#endif\n      MOP_OUT;\n\n      if (IS_FIND_CONDITION(option)) {\n        if (IS_FIND_NOT_EMPTY(option) && s == sstart) {\n          best_len = ONIG_MISMATCH;\n          goto fail; /* for retry */\n        }\n        if (IS_FIND_LONGEST(option) && DATA_ENSURE_CHECK1) {\n          goto fail; /* for retry */\n        }\n      }\n\n      /* default behavior: return first-matching result. */\n      goto finish;\n      break;\n\n    case OP_EXACT1:  MOP_IN(OP_EXACT1);\n      DATA_ENSURE(1);\n      if (*p != *s) goto fail;\n      p++; s++;\n      MOP_OUT;\n      break;\n\n    case OP_EXACT1_IC:  MOP_IN(OP_EXACT1_IC);\n      {\n        int len;\n        UChar *q, lowbuf[ONIGENC_MBC_CASE_FOLD_MAXLEN];\n\n        DATA_ENSURE(1);\n        len = ONIGENC_MBC_CASE_FOLD(encode,\n                 /* DISABLE_CASE_FOLD_MULTI_CHAR(case_fold_flag), */\n                                    case_fold_flag,\n                                    &s, end, lowbuf);\n        DATA_ENSURE(0);\n        q = lowbuf;\n        while (len-- > 0) {\n          if (*p != *q) {\n            goto fail;\n          }\n          p++; q++;\n        }\n      }\n      MOP_OUT;\n      break;\n\n    case OP_EXACT2:  MOP_IN(OP_EXACT2);\n      DATA_ENSURE(2);\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      sprev = s;\n      p++; s++;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_EXACT3:  MOP_IN(OP_EXACT3);\n      DATA_ENSURE(3);\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      sprev = s;\n      p++; s++;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_EXACT4:  MOP_IN(OP_EXACT4);\n      DATA_ENSURE(4);\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      sprev = s;\n      p++; s++;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_EXACT5:  MOP_IN(OP_EXACT5);\n      DATA_ENSURE(5);\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      sprev = s;\n      p++; s++;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_EXACTN:  MOP_IN(OP_EXACTN);\n      GET_LENGTH_INC(tlen, p);\n      DATA_ENSURE(tlen);\n      while (tlen-- > 0) {\n        if (*p++ != *s++) goto fail;\n      }\n      sprev = s - 1;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_EXACTN_IC:  MOP_IN(OP_EXACTN_IC);\n      {\n        int len;\n        UChar *q, *endp, lowbuf[ONIGENC_MBC_CASE_FOLD_MAXLEN];\n\n        GET_LENGTH_INC(tlen, p);\n        endp = p + tlen;\n\n        while (p < endp) {\n          sprev = s;\n          DATA_ENSURE(1);\n          len = ONIGENC_MBC_CASE_FOLD(encode,\n                        /* DISABLE_CASE_FOLD_MULTI_CHAR(case_fold_flag), */\n                                      case_fold_flag,\n                                      &s, end, lowbuf);\n          DATA_ENSURE(0);\n          q = lowbuf;\n          while (len-- > 0) {\n            if (*p != *q) goto fail;\n            p++; q++;\n          }\n        }\n      }\n\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_EXACTMB2N1:  MOP_IN(OP_EXACTMB2N1);\n      DATA_ENSURE(2);\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      p++; s++;\n      MOP_OUT;\n      break;\n\n    case OP_EXACTMB2N2:  MOP_IN(OP_EXACTMB2N2);\n      DATA_ENSURE(4);\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      p++; s++;\n      sprev = s;\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      p++; s++;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_EXACTMB2N3:  MOP_IN(OP_EXACTMB2N3);\n      DATA_ENSURE(6);\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      p++; s++;\n      sprev = s;\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      p++; s++;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_EXACTMB2N:  MOP_IN(OP_EXACTMB2N);\n      GET_LENGTH_INC(tlen, p);\n      DATA_ENSURE(tlen * 2);\n      while (tlen-- > 0) {\n        if (*p != *s) goto fail;\n        p++; s++;\n        if (*p != *s) goto fail;\n        p++; s++;\n      }\n      sprev = s - 2;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_EXACTMB3N:  MOP_IN(OP_EXACTMB3N);\n      GET_LENGTH_INC(tlen, p);\n      DATA_ENSURE(tlen * 3);\n      while (tlen-- > 0) {\n        if (*p != *s) goto fail;\n        p++; s++;\n        if (*p != *s) goto fail;\n        p++; s++;\n        if (*p != *s) goto fail;\n        p++; s++;\n      }\n      sprev = s - 3;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_EXACTMBN:  MOP_IN(OP_EXACTMBN);\n      GET_LENGTH_INC(tlen,  p);  /* mb-len */\n      GET_LENGTH_INC(tlen2, p);  /* string len */\n      tlen2 *= tlen;\n      DATA_ENSURE(tlen2);\n      while (tlen2-- > 0) {\n        if (*p != *s) goto fail;\n        p++; s++;\n      }\n      sprev = s - tlen;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_CCLASS:  MOP_IN(OP_CCLASS);\n      DATA_ENSURE(1);\n      if (BITSET_AT(((BitSetRef )p), *s) == 0) goto fail;\n      p += SIZE_BITSET;\n      s += enclen(encode, s);   /* OP_CCLASS can match mb-code. \\D, \\S */\n      MOP_OUT;\n      break;\n\n    case OP_CCLASS_MB:  MOP_IN(OP_CCLASS_MB);\n      if (! ONIGENC_IS_MBC_HEAD(encode, s)) goto fail;\n\n    cclass_mb:\n      GET_LENGTH_INC(tlen, p);\n      {\n        OnigCodePoint code;\n        UChar *ss;\n        int mb_len;\n\n        DATA_ENSURE(1);\n        mb_len = enclen(encode, s);\n        DATA_ENSURE(mb_len);\n        ss = s;\n        s += mb_len;\n        code = ONIGENC_MBC_TO_CODE(encode, ss, s);\n\n#ifdef PLATFORM_UNALIGNED_WORD_ACCESS\n        if (! onig_is_in_code_range(p, code)) goto fail;\n#else\n        q = p;\n        ALIGNMENT_RIGHT(q);\n        if (! onig_is_in_code_range(q, code)) goto fail;\n#endif\n      }\n      p += tlen;\n      MOP_OUT;\n      break;\n\n    case OP_CCLASS_MIX:  MOP_IN(OP_CCLASS_MIX);\n      DATA_ENSURE(1);\n      if (ONIGENC_IS_MBC_HEAD(encode, s)) {\n        p += SIZE_BITSET;\n        goto cclass_mb;\n      }\n      else {\n        if (BITSET_AT(((BitSetRef )p), *s) == 0)\n          goto fail;\n\n        p += SIZE_BITSET;\n        GET_LENGTH_INC(tlen, p);\n        p += tlen;\n        s++;\n      }\n      MOP_OUT;\n      break;\n\n    case OP_CCLASS_NOT:  MOP_IN(OP_CCLASS_NOT);\n      DATA_ENSURE(1);\n      if (BITSET_AT(((BitSetRef )p), *s) != 0) goto fail;\n      p += SIZE_BITSET;\n      s += enclen(encode, s);\n      MOP_OUT;\n      break;\n\n    case OP_CCLASS_MB_NOT:  MOP_IN(OP_CCLASS_MB_NOT);\n      DATA_ENSURE(1);\n      if (! ONIGENC_IS_MBC_HEAD(encode, s)) {\n        s++;\n        GET_LENGTH_INC(tlen, p);\n        p += tlen;\n        goto cc_mb_not_success;\n      }\n\n    cclass_mb_not:\n      GET_LENGTH_INC(tlen, p);\n      {\n        OnigCodePoint code;\n        UChar *ss;\n        int mb_len = enclen(encode, s);\n\n        if (! DATA_ENSURE_CHECK(mb_len)) {\n          DATA_ENSURE(1);\n          s = (UChar* )end;\n          p += tlen;\n          goto cc_mb_not_success;\n        }\n\n        ss = s;\n        s += mb_len;\n        code = ONIGENC_MBC_TO_CODE(encode, ss, s);\n\n#ifdef PLATFORM_UNALIGNED_WORD_ACCESS\n        if (onig_is_in_code_range(p, code)) goto fail;\n#else\n        q = p;\n        ALIGNMENT_RIGHT(q);\n        if (onig_is_in_code_range(q, code)) goto fail;\n#endif\n      }\n      p += tlen;\n\n    cc_mb_not_success:\n      MOP_OUT;\n      break;\n\n    case OP_CCLASS_MIX_NOT:  MOP_IN(OP_CCLASS_MIX_NOT);\n      DATA_ENSURE(1);\n      if (ONIGENC_IS_MBC_HEAD(encode, s)) {\n        p += SIZE_BITSET;\n        goto cclass_mb_not;\n      }\n      else {\n        if (BITSET_AT(((BitSetRef )p), *s) != 0)\n          goto fail;\n\n        p += SIZE_BITSET;\n        GET_LENGTH_INC(tlen, p);\n        p += tlen;\n        s++;\n      }\n      MOP_OUT;\n      break;\n\n    case OP_CCLASS_NODE:  MOP_IN(OP_CCLASS_NODE);\n      {\n        OnigCodePoint code;\n        void *node;\n        int mb_len;\n        UChar *ss;\n\n        DATA_ENSURE(1);\n        GET_POINTER_INC(node, p);\n        mb_len = enclen(encode, s);\n        ss = s;\n        s += mb_len;\n        DATA_ENSURE(0);\n        code = ONIGENC_MBC_TO_CODE(encode, ss, s);\n        if (onig_is_code_in_cc_len(mb_len, code, node) == 0) goto fail;\n      }\n      MOP_OUT;\n      break;\n\n    case OP_ANYCHAR:  MOP_IN(OP_ANYCHAR);\n      DATA_ENSURE(1);\n      n = enclen(encode, s);\n      DATA_ENSURE(n);\n      if (ONIGENC_IS_MBC_NEWLINE(encode, s, end)) goto fail;\n      s += n;\n      MOP_OUT;\n      break;\n\n    case OP_ANYCHAR_ML:  MOP_IN(OP_ANYCHAR_ML);\n      DATA_ENSURE(1);\n      n = enclen(encode, s);\n      DATA_ENSURE(n);\n      s += n;\n      MOP_OUT;\n      break;\n\n    case OP_ANYCHAR_STAR:  MOP_IN(OP_ANYCHAR_STAR);\n      while (DATA_ENSURE_CHECK1) {\n        STACK_PUSH_ALT(p, s, sprev);\n        n = enclen(encode, s);\n        DATA_ENSURE(n);\n        if (ONIGENC_IS_MBC_NEWLINE(encode, s, end))  goto fail;\n        sprev = s;\n        s += n;\n      }\n      MOP_OUT;\n      break;\n\n    case OP_ANYCHAR_ML_STAR:  MOP_IN(OP_ANYCHAR_ML_STAR);\n      while (DATA_ENSURE_CHECK1) {\n        STACK_PUSH_ALT(p, s, sprev);\n        n = enclen(encode, s);\n        if (n > 1) {\n          DATA_ENSURE(n);\n          sprev = s;\n          s += n;\n        }\n        else {\n          sprev = s;\n          s++;\n        }\n      }\n      MOP_OUT;\n      break;\n\n    case OP_ANYCHAR_STAR_PEEK_NEXT:  MOP_IN(OP_ANYCHAR_STAR_PEEK_NEXT);\n      while (DATA_ENSURE_CHECK1) {\n        if (*p == *s) {\n          STACK_PUSH_ALT(p + 1, s, sprev);\n        }\n        n = enclen(encode, s);\n        DATA_ENSURE(n);\n        if (ONIGENC_IS_MBC_NEWLINE(encode, s, end))  goto fail;\n        sprev = s;\n        s += n;\n      }\n      p++;\n      MOP_OUT;\n      break;\n\n    case OP_ANYCHAR_ML_STAR_PEEK_NEXT:MOP_IN(OP_ANYCHAR_ML_STAR_PEEK_NEXT);\n      while (DATA_ENSURE_CHECK1) {\n        if (*p == *s) {\n          STACK_PUSH_ALT(p + 1, s, sprev);\n        }\n        n = enclen(encode, s);\n        if (n > 1) {\n          DATA_ENSURE(n);\n          sprev = s;\n          s += n;\n        }\n        else {\n          sprev = s;\n          s++;\n        }\n      }\n      p++;\n      MOP_OUT;\n      break;\n\n#ifdef USE_COMBINATION_EXPLOSION_CHECK\n    case OP_STATE_CHECK_ANYCHAR_STAR:  MOP_IN(OP_STATE_CHECK_ANYCHAR_STAR);\n      GET_STATE_CHECK_NUM_INC(mem, p);\n      while (DATA_ENSURE_CHECK1) {\n        STATE_CHECK_VAL(scv, mem);\n        if (scv) goto fail;\n\n        STACK_PUSH_ALT_WITH_STATE_CHECK(p, s, sprev, mem);\n        n = enclen(encode, s);\n        DATA_ENSURE(n);\n        if (ONIGENC_IS_MBC_NEWLINE(encode, s, end))  goto fail;\n        sprev = s;\n        s += n;\n      }\n      MOP_OUT;\n      break;\n\n    case OP_STATE_CHECK_ANYCHAR_ML_STAR:\n      MOP_IN(OP_STATE_CHECK_ANYCHAR_ML_STAR);\n\n      GET_STATE_CHECK_NUM_INC(mem, p);\n      while (DATA_ENSURE_CHECK1) {\n        STATE_CHECK_VAL(scv, mem);\n        if (scv) goto fail;\n\n        STACK_PUSH_ALT_WITH_STATE_CHECK(p, s, sprev, mem);\n        n = enclen(encode, s);\n        if (n > 1) {\n          DATA_ENSURE(n);\n          sprev = s;\n          s += n;\n        }\n        else {\n          sprev = s;\n          s++;\n        }\n      }\n      MOP_OUT;\n      break;\n#endif /* USE_COMBINATION_EXPLOSION_CHECK */\n\n    case OP_WORD:  MOP_IN(OP_WORD);\n      DATA_ENSURE(1);\n      if (! ONIGENC_IS_MBC_WORD(encode, s, end))\n        goto fail;\n\n      s += enclen(encode, s);\n      MOP_OUT;\n      break;\n\n    case OP_NOT_WORD:  MOP_IN(OP_NOT_WORD);\n      DATA_ENSURE(1);\n      if (ONIGENC_IS_MBC_WORD(encode, s, end))\n        goto fail;\n\n      s += enclen(encode, s);\n      MOP_OUT;\n      break;\n\n    case OP_WORD_BOUND:  MOP_IN(OP_WORD_BOUND);\n      if (ON_STR_BEGIN(s)) {\n        DATA_ENSURE(1);\n        if (! ONIGENC_IS_MBC_WORD(encode, s, end))\n          goto fail;\n      }\n      else if (ON_STR_END(s)) {\n        if (! ONIGENC_IS_MBC_WORD(encode, sprev, end))\n          goto fail;\n      }\n      else {\n        if (ONIGENC_IS_MBC_WORD(encode, s, end)\n            == ONIGENC_IS_MBC_WORD(encode, sprev, end))\n          goto fail;\n      }\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_NOT_WORD_BOUND:  MOP_IN(OP_NOT_WORD_BOUND);\n      if (ON_STR_BEGIN(s)) {\n        if (DATA_ENSURE_CHECK1 && ONIGENC_IS_MBC_WORD(encode, s, end))\n          goto fail;\n      }\n      else if (ON_STR_END(s)) {\n        if (ONIGENC_IS_MBC_WORD(encode, sprev, end))\n          goto fail;\n      }\n      else {\n        if (ONIGENC_IS_MBC_WORD(encode, s, end)\n            != ONIGENC_IS_MBC_WORD(encode, sprev, end))\n          goto fail;\n      }\n      MOP_OUT;\n      continue;\n      break;\n\n#ifdef USE_WORD_BEGIN_END\n    case OP_WORD_BEGIN:  MOP_IN(OP_WORD_BEGIN);\n      if (DATA_ENSURE_CHECK1 && ONIGENC_IS_MBC_WORD(encode, s, end)) {\n        if (ON_STR_BEGIN(s) || !ONIGENC_IS_MBC_WORD(encode, sprev, end)) {\n          MOP_OUT;\n          continue;\n        }\n      }\n      goto fail;\n      break;\n\n    case OP_WORD_END:  MOP_IN(OP_WORD_END);\n      if (!ON_STR_BEGIN(s) && ONIGENC_IS_MBC_WORD(encode, sprev, end)) {\n        if (ON_STR_END(s) || !ONIGENC_IS_MBC_WORD(encode, s, end)) {\n          MOP_OUT;\n          continue;\n        }\n      }\n      goto fail;\n      break;\n#endif\n\n    case OP_BEGIN_BUF:  MOP_IN(OP_BEGIN_BUF);\n      if (! ON_STR_BEGIN(s)) goto fail;\n\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_END_BUF:  MOP_IN(OP_END_BUF);\n      if (! ON_STR_END(s)) goto fail;\n\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_BEGIN_LINE:  MOP_IN(OP_BEGIN_LINE);\n      if (ON_STR_BEGIN(s)) {\n        if (IS_NOTBOL(msa->options)) goto fail;\n        MOP_OUT;\n        continue;\n      }\n      else if (ONIGENC_IS_MBC_NEWLINE(encode, sprev, end) && !ON_STR_END(s)) {\n        MOP_OUT;\n        continue;\n      }\n      goto fail;\n      break;\n\n    case OP_END_LINE:  MOP_IN(OP_END_LINE);\n      if (ON_STR_END(s)) {\n#ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE\n        if (IS_EMPTY_STR || !ONIGENC_IS_MBC_NEWLINE(encode, sprev, end)) {\n#endif\n          if (IS_NOTEOL(msa->options)) goto fail;\n          MOP_OUT;\n          continue;\n#ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE\n        }\n#endif\n      }\n      else if (ONIGENC_IS_MBC_NEWLINE(encode, s, end)) {\n        MOP_OUT;\n        continue;\n      }\n#ifdef USE_CRNL_AS_LINE_TERMINATOR\n      else if (ONIGENC_IS_MBC_CRNL(encode, s, end)) {\n        MOP_OUT;\n        continue;\n      }\n#endif\n      goto fail;\n      break;\n\n    case OP_SEMI_END_BUF:  MOP_IN(OP_SEMI_END_BUF);\n      if (ON_STR_END(s)) {\n#ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE\n        if (IS_EMPTY_STR || !ONIGENC_IS_MBC_NEWLINE(encode, sprev, end)) {\n#endif\n          if (IS_NOTEOL(msa->options)) goto fail;\n          MOP_OUT;\n          continue;\n#ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE\n        }\n#endif\n      }\n      else if (ONIGENC_IS_MBC_NEWLINE(encode, s, end) &&\n               ON_STR_END(s + enclen(encode, s))) {\n        MOP_OUT;\n        continue;\n      }\n#ifdef USE_CRNL_AS_LINE_TERMINATOR\n      else if (ONIGENC_IS_MBC_CRNL(encode, s, end)) {\n        UChar* ss = s + enclen(encode, s);\n        ss += enclen(encode, ss);\n        if (ON_STR_END(ss)) {\n          MOP_OUT;\n          continue;\n        }\n      }\n#endif\n      goto fail;\n      break;\n\n    case OP_BEGIN_POSITION:  MOP_IN(OP_BEGIN_POSITION);\n      if (s != msa->start)\n        goto fail;\n\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_MEMORY_START_PUSH:  MOP_IN(OP_MEMORY_START_PUSH);\n      GET_MEMNUM_INC(mem, p);\n      STACK_PUSH_MEM_START(mem, s);\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_MEMORY_START:  MOP_IN(OP_MEMORY_START);\n      GET_MEMNUM_INC(mem, p);\n      mem_start_stk[mem] = (OnigStackIndex )((void* )s);\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_MEMORY_END_PUSH:  MOP_IN(OP_MEMORY_END_PUSH);\n      GET_MEMNUM_INC(mem, p);\n      STACK_PUSH_MEM_END(mem, s);\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_MEMORY_END:  MOP_IN(OP_MEMORY_END);\n      GET_MEMNUM_INC(mem, p);\n      mem_end_stk[mem] = (OnigStackIndex )((void* )s);\n      MOP_OUT;\n      continue;\n      break;\n\n#ifdef USE_SUBEXP_CALL\n    case OP_MEMORY_END_PUSH_REC:  MOP_IN(OP_MEMORY_END_PUSH_REC);\n      GET_MEMNUM_INC(mem, p);\n      STACK_GET_MEM_START(mem, stkp); /* should be before push mem-end. */\n      STACK_PUSH_MEM_END(mem, s);\n      mem_start_stk[mem] = GET_STACK_INDEX(stkp);\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_MEMORY_END_REC:  MOP_IN(OP_MEMORY_END_REC);\n      GET_MEMNUM_INC(mem, p);\n      mem_end_stk[mem] = (OnigStackIndex )((void* )s);\n      STACK_GET_MEM_START(mem, stkp);\n\n      if (BIT_STATUS_AT(reg->bt_mem_start, mem))\n        mem_start_stk[mem] = GET_STACK_INDEX(stkp);\n      else\n        mem_start_stk[mem] = (OnigStackIndex )((void* )stkp->u.mem.pstr);\n\n      STACK_PUSH_MEM_END_MARK(mem);\n      MOP_OUT;\n      continue;\n      break;\n#endif\n\n    case OP_BACKREF1:  MOP_IN(OP_BACKREF1);\n      mem = 1;\n      goto backref;\n      break;\n\n    case OP_BACKREF2:  MOP_IN(OP_BACKREF2);\n      mem = 2;\n      goto backref;\n      break;\n\n    case OP_BACKREFN:  MOP_IN(OP_BACKREFN);\n      GET_MEMNUM_INC(mem, p);\n    backref:\n      {\n        int len;\n        UChar *pstart, *pend;\n\n        /* if you want to remove following line, \n           you should check in parse and compile time. */\n        if (mem > num_mem) goto fail;\n        if (mem_end_stk[mem]   == INVALID_STACK_INDEX) goto fail;\n        if (mem_start_stk[mem] == INVALID_STACK_INDEX) goto fail;\n\n        if (BIT_STATUS_AT(reg->bt_mem_start, mem))\n          pstart = STACK_AT(mem_start_stk[mem])->u.mem.pstr;\n        else\n          pstart = (UChar* )((void* )mem_start_stk[mem]);\n\n        pend = (BIT_STATUS_AT(reg->bt_mem_end, mem)\n                ? STACK_AT(mem_end_stk[mem])->u.mem.pstr\n                : (UChar* )((void* )mem_end_stk[mem]));\n        n = pend - pstart;\n        DATA_ENSURE(n);\n        sprev = s;\n        STRING_CMP(pstart, s, n);\n        while (sprev + (len = enclen(encode, sprev)) < s)\n          sprev += len;\n\n        MOP_OUT;\n        continue;\n      }\n      break;\n\n    case OP_BACKREFN_IC:  MOP_IN(OP_BACKREFN_IC);\n      GET_MEMNUM_INC(mem, p);\n      {\n        int len;\n        UChar *pstart, *pend;\n\n        /* if you want to remove following line, \n           you should check in parse and compile time. */\n        if (mem > num_mem) goto fail;\n        if (mem_end_stk[mem]   == INVALID_STACK_INDEX) goto fail;\n        if (mem_start_stk[mem] == INVALID_STACK_INDEX) goto fail;\n\n        if (BIT_STATUS_AT(reg->bt_mem_start, mem))\n          pstart = STACK_AT(mem_start_stk[mem])->u.mem.pstr;\n        else\n          pstart = (UChar* )((void* )mem_start_stk[mem]);\n\n        pend = (BIT_STATUS_AT(reg->bt_mem_end, mem)\n                ? STACK_AT(mem_end_stk[mem])->u.mem.pstr\n                : (UChar* )((void* )mem_end_stk[mem]));\n        n = pend - pstart;\n        DATA_ENSURE(n);\n        sprev = s;\n        STRING_CMP_IC(case_fold_flag, pstart, &s, n);\n        while (sprev + (len = enclen(encode, sprev)) < s)\n          sprev += len;\n\n        MOP_OUT;\n        continue;\n      }\n      break;\n\n    case OP_BACKREF_MULTI:  MOP_IN(OP_BACKREF_MULTI);\n      {\n        int len, is_fail;\n        UChar *pstart, *pend, *swork;\n\n        GET_LENGTH_INC(tlen, p);\n        for (i = 0; i < tlen; i++) {\n          GET_MEMNUM_INC(mem, p);\n\n          if (mem_end_stk[mem]   == INVALID_STACK_INDEX) continue;\n          if (mem_start_stk[mem] == INVALID_STACK_INDEX) continue;\n\n          if (BIT_STATUS_AT(reg->bt_mem_start, mem))\n            pstart = STACK_AT(mem_start_stk[mem])->u.mem.pstr;\n          else\n            pstart = (UChar* )((void* )mem_start_stk[mem]);\n\n          pend = (BIT_STATUS_AT(reg->bt_mem_end, mem)\n                  ? STACK_AT(mem_end_stk[mem])->u.mem.pstr\n                  : (UChar* )((void* )mem_end_stk[mem]));\n          n = pend - pstart;\n          DATA_ENSURE(n);\n          sprev = s;\n          swork = s;\n          STRING_CMP_VALUE(pstart, swork, n, is_fail);\n          if (is_fail) continue;\n          s = swork;\n          while (sprev + (len = enclen(encode, sprev)) < s)\n            sprev += len;\n\n          p += (SIZE_MEMNUM * (tlen - i - 1));\n          break; /* success */\n        }\n        if (i == tlen) goto fail;\n        MOP_OUT;\n        continue;\n      }\n      break;\n\n    case OP_BACKREF_MULTI_IC:  MOP_IN(OP_BACKREF_MULTI_IC);\n      {\n        int len, is_fail;\n        UChar *pstart, *pend, *swork;\n\n        GET_LENGTH_INC(tlen, p);\n        for (i = 0; i < tlen; i++) {\n          GET_MEMNUM_INC(mem, p);\n\n          if (mem_end_stk[mem]   == INVALID_STACK_INDEX) continue;\n          if (mem_start_stk[mem] == INVALID_STACK_INDEX) continue;\n\n          if (BIT_STATUS_AT(reg->bt_mem_start, mem))\n            pstart = STACK_AT(mem_start_stk[mem])->u.mem.pstr;\n          else\n            pstart = (UChar* )((void* )mem_start_stk[mem]);\n\n          pend = (BIT_STATUS_AT(reg->bt_mem_end, mem)\n                  ? STACK_AT(mem_end_stk[mem])->u.mem.pstr\n                  : (UChar* )((void* )mem_end_stk[mem]));\n          n = pend - pstart;\n          DATA_ENSURE(n);\n          sprev = s;\n          swork = s;\n          STRING_CMP_VALUE_IC(case_fold_flag, pstart, &swork, n, is_fail);\n          if (is_fail) continue;\n          s = swork;\n          while (sprev + (len = enclen(encode, sprev)) < s)\n            sprev += len;\n\n          p += (SIZE_MEMNUM * (tlen - i - 1));\n          break; /* success */\n        }\n        if (i == tlen) goto fail;\n        MOP_OUT;\n        continue;\n      }\n      break;\n\n#ifdef USE_BACKREF_WITH_LEVEL\n    case OP_BACKREF_WITH_LEVEL:\n      {\n        int len;\n        OnigOptionType ic;\n        LengthType level;\n\n        GET_OPTION_INC(ic,    p);\n        GET_LENGTH_INC(level, p);\n        GET_LENGTH_INC(tlen,  p);\n\n        sprev = s;\n        if (backref_match_at_nested_level(reg, stk, stk_base, ic\n                     , case_fold_flag, (int )level, (int )tlen, p, &s, end)) {\n          while (sprev + (len = enclen(encode, sprev)) < s)\n            sprev += len;\n\n          p += (SIZE_MEMNUM * tlen);\n        }\n        else\n          goto fail;\n\n        MOP_OUT;\n        continue;\n      }\n      break;\n#endif\n\n#if 0   /* no need: IS_DYNAMIC_OPTION() == 0 */\n    case OP_SET_OPTION_PUSH:  MOP_IN(OP_SET_OPTION_PUSH);\n      GET_OPTION_INC(option, p);\n      STACK_PUSH_ALT(p, s, sprev);\n      p += SIZE_OP_SET_OPTION + SIZE_OP_FAIL;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_SET_OPTION:  MOP_IN(OP_SET_OPTION);\n      GET_OPTION_INC(option, p);\n      MOP_OUT;\n      continue;\n      break;\n#endif\n\n    case OP_NULL_CHECK_START:  MOP_IN(OP_NULL_CHECK_START);\n      GET_MEMNUM_INC(mem, p);    /* mem: null check id */\n      STACK_PUSH_NULL_CHECK_START(mem, s);\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_NULL_CHECK_END:  MOP_IN(OP_NULL_CHECK_END);\n      {\n        int isnull;\n\n        GET_MEMNUM_INC(mem, p); /* mem: null check id */\n        STACK_NULL_CHECK(isnull, mem, s);\n        if (isnull) {\n#ifdef ONIG_DEBUG_MATCH\n          fprintf(stderr, \"NULL_CHECK_END: skip  id:%d, s:%d\\n\",\n                  (int )mem, (int )s);\n#endif\n        null_check_found:\n          /* empty loop founded, skip next instruction */\n          switch (*p++) {\n          case OP_JUMP:\n          case OP_PUSH:\n            p += SIZE_RELADDR;\n            break;\n          case OP_REPEAT_INC:\n          case OP_REPEAT_INC_NG:\n          case OP_REPEAT_INC_SG:\n          case OP_REPEAT_INC_NG_SG:\n            p += SIZE_MEMNUM;\n            break;\n          default:\n            goto unexpected_bytecode_error;\n            break;\n          }\n        }\n      }\n      MOP_OUT;\n      continue;\n      break;\n\n#ifdef USE_MONOMANIAC_CHECK_CAPTURES_IN_ENDLESS_REPEAT\n    case OP_NULL_CHECK_END_MEMST:  MOP_IN(OP_NULL_CHECK_END_MEMST);\n      {\n        int isnull;\n\n        GET_MEMNUM_INC(mem, p); /* mem: null check id */\n        STACK_NULL_CHECK_MEMST(isnull, mem, s, reg);\n        if (isnull) {\n#ifdef ONIG_DEBUG_MATCH\n          fprintf(stderr, \"NULL_CHECK_END_MEMST: skip  id:%d, s:%d\\n\",\n                  (int )mem, (int )s);\n#endif\n          if (isnull == -1) goto fail;\n          goto \tnull_check_found;\n        }\n      }\n      MOP_OUT;\n      continue;\n      break;\n#endif\n\n#ifdef USE_SUBEXP_CALL\n    case OP_NULL_CHECK_END_MEMST_PUSH:\n      MOP_IN(OP_NULL_CHECK_END_MEMST_PUSH);\n      {\n        int isnull;\n\n        GET_MEMNUM_INC(mem, p); /* mem: null check id */\n#ifdef USE_MONOMANIAC_CHECK_CAPTURES_IN_ENDLESS_REPEAT\n        STACK_NULL_CHECK_MEMST_REC(isnull, mem, s, reg);\n#else\n        STACK_NULL_CHECK_REC(isnull, mem, s);\n#endif\n        if (isnull) {\n#ifdef ONIG_DEBUG_MATCH\n          fprintf(stderr, \"NULL_CHECK_END_MEMST_PUSH: skip  id:%d, s:%d\\n\",\n                  (int )mem, (int )s);\n#endif\n          if (isnull == -1) goto fail;\n          goto \tnull_check_found;\n        }\n        else {\n          STACK_PUSH_NULL_CHECK_END(mem);\n        }\n      }\n      MOP_OUT;\n      continue;\n      break;\n#endif\n\n    case OP_JUMP:  MOP_IN(OP_JUMP);\n      GET_RELADDR_INC(addr, p);\n      p += addr;\n      MOP_OUT;\n      CHECK_INTERRUPT_IN_MATCH_AT;\n      continue;\n      break;\n\n    case OP_PUSH:  MOP_IN(OP_PUSH);\n      GET_RELADDR_INC(addr, p);\n      STACK_PUSH_ALT(p + addr, s, sprev);\n      MOP_OUT;\n      continue;\n      break;\n\n#ifdef USE_COMBINATION_EXPLOSION_CHECK\n    case OP_STATE_CHECK_PUSH:  MOP_IN(OP_STATE_CHECK_PUSH);\n      GET_STATE_CHECK_NUM_INC(mem, p);\n      STATE_CHECK_VAL(scv, mem);\n      if (scv) goto fail;\n\n      GET_RELADDR_INC(addr, p);\n      STACK_PUSH_ALT_WITH_STATE_CHECK(p + addr, s, sprev, mem);\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_STATE_CHECK_PUSH_OR_JUMP:  MOP_IN(OP_STATE_CHECK_PUSH_OR_JUMP);\n      GET_STATE_CHECK_NUM_INC(mem, p);\n      GET_RELADDR_INC(addr, p);\n      STATE_CHECK_VAL(scv, mem);\n      if (scv) {\n        p += addr;\n      }\n      else {\n        STACK_PUSH_ALT_WITH_STATE_CHECK(p + addr, s, sprev, mem);\n      }\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_STATE_CHECK:  MOP_IN(OP_STATE_CHECK);\n      GET_STATE_CHECK_NUM_INC(mem, p);\n      STATE_CHECK_VAL(scv, mem);\n      if (scv) goto fail;\n\n      STACK_PUSH_STATE_CHECK(s, mem);\n      MOP_OUT;\n      continue;\n      break;\n#endif /* USE_COMBINATION_EXPLOSION_CHECK */\n\n    case OP_POP:  MOP_IN(OP_POP);\n      STACK_POP_ONE;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_PUSH_OR_JUMP_EXACT1:  MOP_IN(OP_PUSH_OR_JUMP_EXACT1);\n      GET_RELADDR_INC(addr, p);\n      if (*p == *s && DATA_ENSURE_CHECK1) {\n        p++;\n        STACK_PUSH_ALT(p + addr, s, sprev);\n        MOP_OUT;\n        continue;\n      }\n      p += (addr + 1);\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_PUSH_IF_PEEK_NEXT:  MOP_IN(OP_PUSH_IF_PEEK_NEXT);\n      GET_RELADDR_INC(addr, p);\n      if (*p == *s) {\n        p++;\n        STACK_PUSH_ALT(p + addr, s, sprev);\n        MOP_OUT;\n        continue;\n      }\n      p++;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_REPEAT:  MOP_IN(OP_REPEAT);\n      {\n        GET_MEMNUM_INC(mem, p);    /* mem: OP_REPEAT ID */\n        GET_RELADDR_INC(addr, p);\n\n        STACK_ENSURE(1);\n        repeat_stk[mem] = GET_STACK_INDEX(stk);\n        STACK_PUSH_REPEAT(mem, p);\n\n        if (reg->repeat_range[mem].lower == 0) {\n          STACK_PUSH_ALT(p + addr, s, sprev);\n        }\n      }\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_REPEAT_NG:  MOP_IN(OP_REPEAT_NG);\n      {\n        GET_MEMNUM_INC(mem, p);    /* mem: OP_REPEAT ID */\n        GET_RELADDR_INC(addr, p);\n\n        STACK_ENSURE(1);\n        repeat_stk[mem] = GET_STACK_INDEX(stk);\n        STACK_PUSH_REPEAT(mem, p);\n\n        if (reg->repeat_range[mem].lower == 0) {\n          STACK_PUSH_ALT(p, s, sprev);\n          p += addr;\n        }\n      }\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_REPEAT_INC:  MOP_IN(OP_REPEAT_INC);\n      GET_MEMNUM_INC(mem, p); /* mem: OP_REPEAT ID */\n      si = repeat_stk[mem];\n      stkp = STACK_AT(si);\n\n    repeat_inc:\n      stkp->u.repeat.count++;\n      if (stkp->u.repeat.count >= reg->repeat_range[mem].upper) {\n        /* end of repeat. Nothing to do. */\n      }\n      else if (stkp->u.repeat.count >= reg->repeat_range[mem].lower) {\n        STACK_PUSH_ALT(p, s, sprev);\n        p = STACK_AT(si)->u.repeat.pcode; /* Don't use stkp after PUSH. */\n      }\n      else {\n        p = stkp->u.repeat.pcode;\n      }\n      STACK_PUSH_REPEAT_INC(si);\n      MOP_OUT;\n      CHECK_INTERRUPT_IN_MATCH_AT;\n      continue;\n      break;\n\n    case OP_REPEAT_INC_SG:  MOP_IN(OP_REPEAT_INC_SG);\n      GET_MEMNUM_INC(mem, p); /* mem: OP_REPEAT ID */\n      STACK_GET_REPEAT(mem, stkp);\n      si = GET_STACK_INDEX(stkp);\n      goto repeat_inc;\n      break;\n\n    case OP_REPEAT_INC_NG:  MOP_IN(OP_REPEAT_INC_NG);\n      GET_MEMNUM_INC(mem, p); /* mem: OP_REPEAT ID */\n      si = repeat_stk[mem];\n      stkp = STACK_AT(si);\n\n    repeat_inc_ng:\n      stkp->u.repeat.count++;\n      if (stkp->u.repeat.count < reg->repeat_range[mem].upper) {\n        if (stkp->u.repeat.count >= reg->repeat_range[mem].lower) {\n          UChar* pcode = stkp->u.repeat.pcode;\n\n          STACK_PUSH_REPEAT_INC(si);\n          STACK_PUSH_ALT(pcode, s, sprev);\n        }\n        else {\n          p = stkp->u.repeat.pcode;\n          STACK_PUSH_REPEAT_INC(si);\n        }\n      }\n      else if (stkp->u.repeat.count == reg->repeat_range[mem].upper) {\n        STACK_PUSH_REPEAT_INC(si);\n      }\n      MOP_OUT;\n      CHECK_INTERRUPT_IN_MATCH_AT;\n      continue;\n      break;\n\n    case OP_REPEAT_INC_NG_SG:  MOP_IN(OP_REPEAT_INC_NG_SG);\n      GET_MEMNUM_INC(mem, p); /* mem: OP_REPEAT ID */\n      STACK_GET_REPEAT(mem, stkp);\n      si = GET_STACK_INDEX(stkp);\n      goto repeat_inc_ng;\n      break;\n\n    case OP_PUSH_POS:  MOP_IN(OP_PUSH_POS);\n      STACK_PUSH_POS(s, sprev);\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_POP_POS:  MOP_IN(OP_POP_POS);\n      {\n        STACK_POS_END(stkp);\n        s     = stkp->u.state.pstr;\n        sprev = stkp->u.state.pstr_prev;\n      }\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_PUSH_POS_NOT:  MOP_IN(OP_PUSH_POS_NOT);\n      GET_RELADDR_INC(addr, p);\n      STACK_PUSH_POS_NOT(p + addr, s, sprev);\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_FAIL_POS:  MOP_IN(OP_FAIL_POS);\n      STACK_POP_TIL_POS_NOT;\n      goto fail;\n      break;\n\n    case OP_PUSH_STOP_BT:  MOP_IN(OP_PUSH_STOP_BT);\n      STACK_PUSH_STOP_BT;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_POP_STOP_BT:  MOP_IN(OP_POP_STOP_BT);\n      STACK_STOP_BT_END;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_LOOK_BEHIND:  MOP_IN(OP_LOOK_BEHIND);\n      GET_LENGTH_INC(tlen, p);\n      s = (UChar* )ONIGENC_STEP_BACK(encode, str, s, (int )tlen);\n      if (IS_NULL(s)) goto fail;\n      sprev = (UChar* )onigenc_get_prev_char_head(encode, str, s);\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_PUSH_LOOK_BEHIND_NOT:  MOP_IN(OP_PUSH_LOOK_BEHIND_NOT);\n      GET_RELADDR_INC(addr, p);\n      GET_LENGTH_INC(tlen, p);\n      q = (UChar* )ONIGENC_STEP_BACK(encode, str, s, (int )tlen);\n      if (IS_NULL(q)) {\n        /* too short case -> success. ex. /(?<!XXX)a/.match(\"a\")\n           If you want to change to fail, replace following line. */\n        p += addr;\n        /* goto fail; */\n      }\n      else {\n        STACK_PUSH_LOOK_BEHIND_NOT(p + addr, s, sprev);\n        s = q;\n        sprev = (UChar* )onigenc_get_prev_char_head(encode, str, s);\n      }\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_FAIL_LOOK_BEHIND_NOT:  MOP_IN(OP_FAIL_LOOK_BEHIND_NOT);\n      STACK_POP_TIL_LOOK_BEHIND_NOT;\n      goto fail;\n      break;\n\n#ifdef USE_SUBEXP_CALL\n    case OP_CALL:  MOP_IN(OP_CALL);\n      GET_ABSADDR_INC(addr, p);\n      STACK_PUSH_CALL_FRAME(p);\n      p = reg->p + addr;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_RETURN:  MOP_IN(OP_RETURN);\n      STACK_RETURN(p);\n      STACK_PUSH_RETURN;\n      MOP_OUT;\n      continue;\n      break;\n#endif\n\n    case OP_FINISH:\n      goto finish;\n      break;\n\n    fail:\n      MOP_OUT;\n      /* fall */\n    case OP_FAIL:  MOP_IN(OP_FAIL);\n      STACK_POP;\n      p     = stk->u.state.pcode;\n      s     = stk->u.state.pstr;\n      sprev = stk->u.state.pstr_prev;\n\n#ifdef USE_COMBINATION_EXPLOSION_CHECK\n      if (stk->u.state.state_check != 0) {\n        stk->type = STK_STATE_CHECK_MARK;\n        stk++;\n      }\n#endif\n\n      MOP_OUT;\n      continue;\n      break;\n\n    default:\n      goto bytecode_error;\n\n    } /* end of switch */\n    sprev = sbegin;\n  } /* end of while(1) */\n\n finish:\n  STACK_SAVE;\n  return best_len;\n\n#ifdef ONIG_DEBUG\n stack_error:\n  STACK_SAVE;\n  return ONIGERR_STACK_BUG;\n#endif\n\n bytecode_error:\n  STACK_SAVE;\n  return ONIGERR_UNDEFINED_BYTECODE;\n\n unexpected_bytecode_error:\n  STACK_SAVE;\n  return ONIGERR_UNEXPECTED_BYTECODE;\n}\n\n\nstatic UChar*\nslow_search(OnigEncoding enc, UChar* target, UChar* target_end,\n\t    const UChar* text, const UChar* text_end, UChar* text_range)\n{\n  UChar *t, *p, *s, *end;\n\n  end = (UChar* )text_end;\n  end -= target_end - target - 1;\n  if (end > text_range)\n    end = text_range;\n\n  s = (UChar* )text;\n\n  while (s < end) {\n    if (*s == *target) {\n      p = s + 1;\n      t = target + 1;\n      while (t < target_end) {\n        if (*t != *p++)\n          break;\n        t++;\n      }\n      if (t == target_end)\n        return s;\n    }\n    s += enclen(enc, s);\n  }\n\n  return (UChar* )NULL;\n}\n\nstatic int\nstr_lower_case_match(OnigEncoding enc, int case_fold_flag,\n                     const UChar* t, const UChar* tend,\n\t\t     const UChar* p, const UChar* end)\n{\n  int lowlen;\n  UChar *q, lowbuf[ONIGENC_MBC_CASE_FOLD_MAXLEN];\n\n  while (t < tend) {\n    lowlen = ONIGENC_MBC_CASE_FOLD(enc, case_fold_flag, &p, end, lowbuf);\n    q = lowbuf;\n    while (lowlen > 0) {\n      if (*t++ != *q++)\treturn 0;\n      lowlen--;\n    }\n  }\n\n  return 1;\n}\n\nstatic UChar*\nslow_search_ic(OnigEncoding enc, int case_fold_flag,\n\t       UChar* target, UChar* target_end,\n\t       const UChar* text, const UChar* text_end, UChar* text_range)\n{\n  UChar *s, *end;\n\n  end = (UChar* )text_end;\n  end -= target_end - target - 1;\n  if (end > text_range)\n    end = text_range;\n\n  s = (UChar* )text;\n\n  while (s < end) {\n    if (str_lower_case_match(enc, case_fold_flag, target, target_end,\n\t\t\t     s, text_end))\n      return s;\n\n    s += enclen(enc, s);\n  }\n\n  return (UChar* )NULL;\n}\n\nstatic UChar*\nslow_search_backward(OnigEncoding enc, UChar* target, UChar* target_end,\n\t\t     const UChar* text, const UChar* adjust_text,\n\t\t     const UChar* text_end, const UChar* text_start)\n{\n  UChar *t, *p, *s;\n\n  s = (UChar* )text_end;\n  s -= (target_end - target);\n  if (s > text_start)\n    s = (UChar* )text_start;\n  else\n    s = ONIGENC_LEFT_ADJUST_CHAR_HEAD(enc, adjust_text, s);\n\n  while (s >= text) {\n    if (*s == *target) {\n      p = s + 1;\n      t = target + 1;\n      while (t < target_end) {\n        if (*t != *p++)\n          break;\n        t++;\n      }\n      if (t == target_end)\n        return s;\n    }\n    s = (UChar* )onigenc_get_prev_char_head(enc, adjust_text, s);\n  }\n\n  return (UChar* )NULL;\n}\n\nstatic UChar*\nslow_search_backward_ic(OnigEncoding enc, int case_fold_flag,\n\t\t\tUChar* target, UChar* target_end,\n\t\t\tconst UChar* text, const UChar* adjust_text,\n\t\t\tconst UChar* text_end, const UChar* text_start)\n{\n  UChar *s;\n\n  s = (UChar* )text_end;\n  s -= (target_end - target);\n  if (s > text_start)\n    s = (UChar* )text_start;\n  else\n    s = ONIGENC_LEFT_ADJUST_CHAR_HEAD(enc, adjust_text, s);\n\n  while (s >= text) {\n    if (str_lower_case_match(enc, case_fold_flag,\n                             target, target_end, s, text_end))\n      return s;\n\n    s = (UChar* )onigenc_get_prev_char_head(enc, adjust_text, s);\n  }\n\n  return (UChar* )NULL;\n}\n\nstatic UChar*\nbm_search_notrev(regex_t* reg, const UChar* target, const UChar* target_end,\n\t\t const UChar* text, const UChar* text_end,\n\t\t const UChar* text_range)\n{\n  const UChar *s, *se, *t, *p, *end;\n  const UChar *tail;\n  int skip, tlen1;\n\n#ifdef ONIG_DEBUG_SEARCH\n  fprintf(stderr, \"bm_search_notrev: text: %d, text_end: %d, text_range: %d\\n\",\n\t  (int )text, (int )text_end, (int )text_range);\n#endif\n\n  tail = target_end - 1;\n  tlen1 = tail - target;\n  end = text_range;\n  if (end + tlen1 > text_end)\n    end = text_end - tlen1;\n\n  s = text;\n\n  if (IS_NULL(reg->int_map)) {\n    while (s < end) {\n      p = se = s + tlen1;\n      t = tail;\n      while (*p == *t) {\n        if (t == target) return (UChar* )s;\n        p--; t--;\n      }\n      skip = reg->map[*se];\n      t = s;\n      do {\n        s += enclen(reg->enc, s);\n      } while ((s - t) < skip && s < end);\n    }\n  }\n  else {\n    while (s < end) {\n      p = se = s + tlen1;\n      t = tail;\n      while (*p == *t) {\n        if (t == target) return (UChar* )s;\n        p--; t--;\n      }\n      skip = reg->int_map[*se];\n      t = s;\n      do {\n        s += enclen(reg->enc, s);\n      } while ((s - t) < skip && s < end);\n    }\n  }\n\n  return (UChar* )NULL;\n}\n\nstatic UChar*\nbm_search(regex_t* reg, const UChar* target, const UChar* target_end,\n\t  const UChar* text, const UChar* text_end, const UChar* text_range)\n{\n  const UChar *s, *t, *p, *end;\n  const UChar *tail;\n\n  end = text_range + (target_end - target) - 1;\n  if (end > text_end)\n    end = text_end;\n\n  tail = target_end - 1;\n  s = text + (target_end - target) - 1;\n  if (IS_NULL(reg->int_map)) {\n    while (s < end) {\n      p = s;\n      t = tail;\n      while (*p == *t) {\n        if (t == target) return (UChar* )p;\n        p--; t--;\n      }\n      s += reg->map[*s];\n    }\n  }\n  else { /* see int_map[] */\n    while (s < end) {\n      p = s;\n      t = tail;\n      while (*p == *t) {\n        if (t == target) return (UChar* )p;\n        p--; t--;\n      }\n      s += reg->int_map[*s];\n    }\n  }\n  return (UChar* )NULL;\n}\n\n#ifdef USE_INT_MAP_BACKWARD\nstatic int\nset_bm_backward_skip(UChar* s, UChar* end, OnigEncoding enc ARG_UNUSED,\n\t\t     int** skip)\n\t\t     \n{\n  int i, len;\n\n  if (IS_NULL(*skip)) {\n    *skip = (int* )xmalloc(sizeof(int) * ONIG_CHAR_TABLE_SIZE);\n    if (IS_NULL(*skip)) return ONIGERR_MEMORY;\n  }\n\n  len = end - s;\n  for (i = 0; i < ONIG_CHAR_TABLE_SIZE; i++)\n    (*skip)[i] = len;\n\n  for (i = len - 1; i > 0; i--)\n    (*skip)[s[i]] = i;\n\n  return 0;\n}\n\nstatic UChar*\nbm_search_backward(regex_t* reg, const UChar* target, const UChar* target_end,\n\t\t   const UChar* text, const UChar* adjust_text,\n\t\t   const UChar* text_end, const UChar* text_start)\n{\n  const UChar *s, *t, *p;\n\n  s = text_end - (target_end - target);\n  if (text_start < s)\n    s = text_start;\n  else\n    s = ONIGENC_LEFT_ADJUST_CHAR_HEAD(reg->enc, adjust_text, s);\n\n  while (s >= text) {\n    p = s;\n    t = target;\n    while (t < target_end && *p == *t) {\n      p++; t++;\n    }\n    if (t == target_end)\n      return (UChar* )s;\n\n    s -= reg->int_map_backward[*s];\n    s = ONIGENC_LEFT_ADJUST_CHAR_HEAD(reg->enc, adjust_text, s);\n  }\n\n  return (UChar* )NULL;\n}\n#endif\n\nstatic UChar*\nmap_search(OnigEncoding enc, UChar map[],\n\t   const UChar* text, const UChar* text_range)\n{\n  const UChar *s = text;\n\n  while (s < text_range) {\n    if (map[*s]) return (UChar* )s;\n\n    s += enclen(enc, s);\n  }\n  return (UChar* )NULL;\n}\n\nstatic UChar*\nmap_search_backward(OnigEncoding enc, UChar map[],\n\t\t    const UChar* text, const UChar* adjust_text,\n\t\t    const UChar* text_start)\n{\n  const UChar *s = text_start;\n\n  while (s >= text) {\n    if (map[*s]) return (UChar* )s;\n\n    s = onigenc_get_prev_char_head(enc, adjust_text, s);\n  }\n  return (UChar* )NULL;\n}\n\nextern int\nonig_match(regex_t* reg, const UChar* str, const UChar* end, const UChar* at, OnigRegion* region,\n\t    OnigOptionType option)\n{\n  int r;\n  UChar *prev;\n  OnigMatchArg msa;\n\n  MATCH_ARG_INIT(msa, reg, option, region, at);\n#ifdef USE_COMBINATION_EXPLOSION_CHECK\n  {\n    int offset = at - str;\n    STATE_CHECK_BUFF_INIT(msa, end - str, offset, reg->num_comb_exp_check);\n  }\n#endif\n\n  if (region\n#ifdef USE_POSIX_API_REGION_OPTION\n      && !IS_POSIX_REGION(option)\n#endif\n      ) {\n    r = onig_region_resize_clear(region, reg->num_mem + 1);\n  }\n  else\n    r = 0;\n\n  if (r == 0) {\n    if (ONIG_IS_OPTION_ON(option, ONIG_OPTION_CHECK_VALIDITY_OF_STRING)) {\n      if (! ONIGENC_IS_VALID_MBC_STRING(reg->enc, str, end)) {\n        r = ONIGERR_INVALID_WIDE_CHAR_VALUE;\n        goto end;\n      }\n    }\n\n    prev = (UChar* )onigenc_get_prev_char_head(reg->enc, str, at);\n    r = match_at(reg, str, end,\n#ifdef USE_MATCH_RANGE_MUST_BE_INSIDE_OF_SPECIFIED_RANGE\n\t\t end,\n#endif\n\t\t at, prev, &msa);\n  }\n\n end:\n  MATCH_ARG_FREE(msa);\n  return r;\n}\n\nstatic int\nforward_search_range(regex_t* reg, const UChar* str, const UChar* end, UChar* s,\n\t\t     UChar* range, UChar** low, UChar** high, UChar** low_prev)\n{\n  UChar *p, *pprev = (UChar* )NULL;\n\n#ifdef ONIG_DEBUG_SEARCH\n  fprintf(stderr, \"forward_search_range: str: %d, end: %d, s: %d, range: %d\\n\",\n\t  (int )str, (int )end, (int )s, (int )range);\n#endif\n\n  p = s;\n  if (reg->dmin > 0) {\n    if (ONIGENC_IS_SINGLEBYTE(reg->enc)) {\n      p += reg->dmin;\n    }\n    else {\n      UChar *q = p + reg->dmin;\n      while (p < q) p += enclen(reg->enc, p);\n    }\n  }\n\n retry:\n  switch (reg->optimize) {\n  case ONIG_OPTIMIZE_EXACT:\n    p = slow_search(reg->enc, reg->exact, reg->exact_end, p, end, range);\n    break;\n  case ONIG_OPTIMIZE_EXACT_IC:\n    p = slow_search_ic(reg->enc, reg->case_fold_flag,\n                       reg->exact, reg->exact_end, p, end, range);\n    break;\n\n  case ONIG_OPTIMIZE_EXACT_BM:\n    p = bm_search(reg, reg->exact, reg->exact_end, p, end, range);\n    break;\n\n  case ONIG_OPTIMIZE_EXACT_BM_NOT_REV:\n    p = bm_search_notrev(reg, reg->exact, reg->exact_end, p, end, range);\n    break;\n\n  case ONIG_OPTIMIZE_MAP:\n    p = map_search(reg->enc, reg->map, p, range);\n    break;\n  }\n\n  if (p && p < range) {\n    if (p - reg->dmin < s) {\n    retry_gate:\n      pprev = p;\n      p += enclen(reg->enc, p);\n      goto retry;\n    }\n\n    if (reg->sub_anchor) {\n      UChar* prev;\n\n      switch (reg->sub_anchor) {\n      case ANCHOR_BEGIN_LINE:\n        if (!ON_STR_BEGIN(p)) {\n          prev = onigenc_get_prev_char_head(reg->enc,\n                                            (pprev ? pprev : str), p);\n          if (!ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end))\n            goto retry_gate;\n        }\n        break;\n\n      case ANCHOR_END_LINE:\n        if (ON_STR_END(p)) {\n#ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE\n          prev = (UChar* )onigenc_get_prev_char_head(reg->enc,\n                                                     (pprev ? pprev : str), p);\n          if (prev && ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end))\n            goto retry_gate;\n#endif\n        }\n        else if (! ONIGENC_IS_MBC_NEWLINE(reg->enc, p, end)\n#ifdef USE_CRNL_AS_LINE_TERMINATOR\n                 && ! ONIGENC_IS_MBC_CRNL(reg->enc, p, end)\n#endif\n                 )\n          goto retry_gate;\n        break;\n      }\n    }\n\n    if (reg->dmax == 0) {\n      *low = p;\n      if (low_prev) {\n        if (*low > s)\n          *low_prev = onigenc_get_prev_char_head(reg->enc, s, p);\n        else\n          *low_prev = onigenc_get_prev_char_head(reg->enc,\n                                                 (pprev ? pprev : str), p);\n      }\n    }\n    else {\n      if (reg->dmax != ONIG_INFINITE_DISTANCE) {\n        *low = p - reg->dmax;\n        if (*low > s) {\n          *low = onigenc_get_right_adjust_char_head_with_prev(reg->enc, s,\n                                          *low, (const UChar** )low_prev);\n          if (low_prev && IS_NULL(*low_prev))\n            *low_prev = onigenc_get_prev_char_head(reg->enc,\n                                                   (pprev ? pprev : s), *low);\n        }\n        else {\n          if (low_prev)\n            *low_prev = onigenc_get_prev_char_head(reg->enc,\n                                                   (pprev ? pprev : str), *low);\n        }\n      }\n    }\n    /* no needs to adjust *high, *high is used as range check only */\n    *high = p - reg->dmin;\n\n#ifdef ONIG_DEBUG_SEARCH\n    fprintf(stderr,\n    \"forward_search_range success: low: %d, high: %d, dmin: %d, dmax: %d\\n\",\n\t    (int )(*low - str), (int )(*high - str), reg->dmin, reg->dmax);\n#endif\n    return 1; /* success */\n  }\n\n  return 0; /* fail */\n}\n\n\n#define BM_BACKWARD_SEARCH_LENGTH_THRESHOLD   100\n\nstatic int\nbackward_search_range(regex_t* reg, const UChar* str, const UChar* end,\n\t\t      UChar* s, const UChar* range, UChar* adjrange,\n\t\t      UChar** low, UChar** high)\n{\n  UChar *p;\n\n  range += reg->dmin;\n  p = s;\n\n retry:\n  switch (reg->optimize) {\n  case ONIG_OPTIMIZE_EXACT:\n  exact_method:\n    p = slow_search_backward(reg->enc, reg->exact, reg->exact_end,\n\t\t\t     range, adjrange, end, p);\n    break;\n\n  case ONIG_OPTIMIZE_EXACT_IC:\n    p = slow_search_backward_ic(reg->enc, reg->case_fold_flag,\n                                reg->exact, reg->exact_end,\n                                range, adjrange, end, p);\n    break;\n\n  case ONIG_OPTIMIZE_EXACT_BM:\n  case ONIG_OPTIMIZE_EXACT_BM_NOT_REV:\n#ifdef USE_INT_MAP_BACKWARD\n    if (IS_NULL(reg->int_map_backward)) {\n      int r;\n\n      if (s - range < BM_BACKWARD_SEARCH_LENGTH_THRESHOLD)\n        goto exact_method;\n\n      r = set_bm_backward_skip(reg->exact, reg->exact_end, reg->enc,\n                               &(reg->int_map_backward));\n      if (r) return r;\n    }\n    p = bm_search_backward(reg, reg->exact, reg->exact_end, range, adjrange,\n                           end, p);\n#else\n    goto exact_method;\n#endif\n    break;\n\n  case ONIG_OPTIMIZE_MAP:\n    p = map_search_backward(reg->enc, reg->map, range, adjrange, p);\n    break;\n  }\n\n  if (p) {\n    if (reg->sub_anchor) {\n      UChar* prev;\n\n      switch (reg->sub_anchor) {\n      case ANCHOR_BEGIN_LINE:\n        if (!ON_STR_BEGIN(p)) {\n          prev = onigenc_get_prev_char_head(reg->enc, str, p);\n          if (!ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end)) {\n            p = prev;\n            goto retry;\n          }\n        }\n        break;\n\n      case ANCHOR_END_LINE:\n        if (ON_STR_END(p)) {\n#ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE\n          prev = onigenc_get_prev_char_head(reg->enc, adjrange, p);\n          if (IS_NULL(prev)) goto fail;\n          if (ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end)) {\n            p = prev;\n            goto retry;\n          }\n#endif\n        }\n        else if (! ONIGENC_IS_MBC_NEWLINE(reg->enc, p, end)\n#ifdef USE_CRNL_AS_LINE_TERMINATOR\n                 && ! ONIGENC_IS_MBC_CRNL(reg->enc, p, end)\n#endif\n                 ) {\n          p = onigenc_get_prev_char_head(reg->enc, adjrange, p);\n          if (IS_NULL(p)) goto fail;\n          goto retry;\n        }\n        break;\n      }\n    }\n\n    /* no needs to adjust *high, *high is used as range check only */\n    if (reg->dmax != ONIG_INFINITE_DISTANCE) {\n      *low  = p - reg->dmax;\n      *high = p - reg->dmin;\n      *high = onigenc_get_right_adjust_char_head(reg->enc, adjrange, *high);\n    }\n\n#ifdef ONIG_DEBUG_SEARCH\n    fprintf(stderr, \"backward_search_range: low: %d, high: %d\\n\",\n\t    (int )(*low - str), (int )(*high - str));\n#endif\n    return 1; /* success */\n  }\n\n fail:\n#ifdef ONIG_DEBUG_SEARCH\n  fprintf(stderr, \"backward_search_range: fail.\\n\");\n#endif\n  return 0; /* fail */\n}\n\n\nextern int\nonig_search(regex_t* reg, const UChar* str, const UChar* end,\n\t    const UChar* start, const UChar* range, OnigRegion* region, OnigOptionType option)\n{\n  int r;\n  UChar *s, *prev;\n  OnigMatchArg msa;\n  const UChar *orig_start = start;\n#ifdef USE_MATCH_RANGE_MUST_BE_INSIDE_OF_SPECIFIED_RANGE\n  const UChar *orig_range = range;\n#endif\n\n#ifdef ONIG_DEBUG_SEARCH\n  fprintf(stderr,\n     \"onig_search (entry point): str: %d, end: %d, start: %d, range: %d\\n\",\n     (int )str, (int )(end - str), (int )(start - str), (int )(range - str));\n#endif\n\n  if (region\n#ifdef USE_POSIX_API_REGION_OPTION\n      && !IS_POSIX_REGION(option)\n#endif\n      ) {\n    r = onig_region_resize_clear(region, reg->num_mem + 1);\n    if (r) goto finish_no_msa;\n  }\n\n  if (start > end || start < str) goto mismatch_no_msa;\n\n  if (ONIG_IS_OPTION_ON(option, ONIG_OPTION_CHECK_VALIDITY_OF_STRING)) {\n    if (! ONIGENC_IS_VALID_MBC_STRING(reg->enc, str, end)) {\n      r = ONIGERR_INVALID_WIDE_CHAR_VALUE;\n      goto finish_no_msa;\n    }\n  }\n\n\n#ifdef USE_MATCH_RANGE_MUST_BE_INSIDE_OF_SPECIFIED_RANGE\n#ifdef USE_FIND_LONGEST_SEARCH_ALL_OF_RANGE\n#define MATCH_AND_RETURN_CHECK(upper_range) \\\n  r = match_at(reg, str, end, (upper_range), s, prev, &msa); \\\n  if (r != ONIG_MISMATCH) {\\\n    if (r >= 0) {\\\n      if (! IS_FIND_LONGEST(reg->options)) {\\\n        goto match;\\\n      }\\\n    }\\\n    else goto finish; /* error */ \\\n  }\n#else\n#define MATCH_AND_RETURN_CHECK(upper_range) \\\n  r = match_at(reg, str, end, (upper_range), s, prev, &msa); \\\n  if (r != ONIG_MISMATCH) {\\\n    if (r >= 0) {\\\n      goto match;\\\n    }\\\n    else goto finish; /* error */ \\\n  }\n#endif /* USE_FIND_LONGEST_SEARCH_ALL_OF_RANGE */\n#else\n#ifdef USE_FIND_LONGEST_SEARCH_ALL_OF_RANGE\n#define MATCH_AND_RETURN_CHECK(none) \\\n  r = match_at(reg, str, end, s, prev, &msa);\\\n  if (r != ONIG_MISMATCH) {\\\n    if (r >= 0) {\\\n      if (! IS_FIND_LONGEST(reg->options)) {\\\n        goto match;\\\n      }\\\n    }\\\n    else goto finish; /* error */ \\\n  }\n#else\n#define MATCH_AND_RETURN_CHECK(none) \\\n  r = match_at(reg, str, end, s, prev, &msa);\\\n  if (r != ONIG_MISMATCH) {\\\n    if (r >= 0) {\\\n      goto match;\\\n    }\\\n    else goto finish; /* error */ \\\n  }\n#endif /* USE_FIND_LONGEST_SEARCH_ALL_OF_RANGE */\n#endif /* USE_MATCH_RANGE_MUST_BE_INSIDE_OF_SPECIFIED_RANGE */\n\n\n  /* anchor optimize: resume search range */\n  if (reg->anchor != 0 && str < end) {\n    UChar *min_semi_end, *max_semi_end;\n\n    if (reg->anchor & ANCHOR_BEGIN_POSITION) {\n      /* search start-position only */\n    begin_position:\n      if (range > start)\n        range = start + 1;\n      else\n        range = start;\n    }\n    else if (reg->anchor & ANCHOR_BEGIN_BUF) {\n      /* search str-position only */\n      if (range > start) {\n        if (start != str) goto mismatch_no_msa;\n        range = str + 1;\n      }\n      else {\n        if (range <= str) {\n          start = str;\n          range = str;\n        }\n        else\n          goto mismatch_no_msa;\n      }\n    }\n    else if (reg->anchor & ANCHOR_END_BUF) {\n      min_semi_end = max_semi_end = (UChar* )end;\n\n    end_buf:\n      if ((OnigLen )(max_semi_end - str) < reg->anchor_dmin)\n\tgoto mismatch_no_msa;\n\n      if (range > start) {\n        if ((OnigLen )(min_semi_end - start) > reg->anchor_dmax) {\n          start = min_semi_end - reg->anchor_dmax;\n          if (start < end)\n            start = onigenc_get_right_adjust_char_head(reg->enc, str, start);\n        }\n        if ((OnigLen )(max_semi_end - (range - 1)) < reg->anchor_dmin) {\n          range = max_semi_end - reg->anchor_dmin + 1;\n        }\n\n        if (start > range) goto mismatch_no_msa;\n        /* If start == range, match with empty at end.\n           Backward search is used. */\n      }\n      else {\n        if ((OnigLen )(min_semi_end - range) > reg->anchor_dmax) {\n          range = min_semi_end - reg->anchor_dmax;\n        }\n        if ((OnigLen )(max_semi_end - start) < reg->anchor_dmin) {\n          start = max_semi_end - reg->anchor_dmin;\n          start = ONIGENC_LEFT_ADJUST_CHAR_HEAD(reg->enc, str, start);\n        }\n        if (range > start) goto mismatch_no_msa;\n      }\n    }\n    else if (reg->anchor & ANCHOR_SEMI_END_BUF) {\n      UChar* pre_end = ONIGENC_STEP_BACK(reg->enc, str, end, 1);\n\n      max_semi_end = (UChar* )end;\n      if (ONIGENC_IS_MBC_NEWLINE(reg->enc, pre_end, end)) {\n        min_semi_end = pre_end;\n\n#ifdef USE_CRNL_AS_LINE_TERMINATOR\n        pre_end = ONIGENC_STEP_BACK(reg->enc, str, pre_end, 1);\n        if (IS_NOT_NULL(pre_end) &&\n            ONIGENC_IS_MBC_CRNL(reg->enc, pre_end, end)) {\n          min_semi_end = pre_end;\n        }\n#endif\n        if (min_semi_end > str && start <= min_semi_end) {\n          goto end_buf;\n        }\n      }\n      else {\n        min_semi_end = (UChar* )end;\n        goto end_buf;\n      }\n    }\n    else if ((reg->anchor & ANCHOR_ANYCHAR_STAR_ML)) {\n      goto begin_position;\n    }\n  }\n  else if (str == end) { /* empty string */\n    static const UChar* address_for_empty_string = (UChar* )\"\";\n\n#ifdef ONIG_DEBUG_SEARCH\n    fprintf(stderr, \"onig_search: empty string.\\n\");\n#endif\n\n    if (reg->threshold_len == 0) {\n      start = end = str = address_for_empty_string;\n      s = (UChar* )start;\n      prev = (UChar* )NULL;\n\n      MATCH_ARG_INIT(msa, reg, option, region, start);\n#ifdef USE_COMBINATION_EXPLOSION_CHECK\n      msa.state_check_buff = (void* )0;\n      msa.state_check_buff_size = 0;   /* NO NEED, for valgrind */\n#endif\n      MATCH_AND_RETURN_CHECK(end);\n      goto mismatch;\n    }\n    goto mismatch_no_msa;\n  }\n\n#ifdef ONIG_DEBUG_SEARCH\n  fprintf(stderr, \"onig_search(apply anchor): end: %d, start: %d, range: %d\\n\",\n\t  (int )(end - str), (int )(start - str), (int )(range - str));\n#endif\n\n  MATCH_ARG_INIT(msa, reg, option, region, orig_start);\n#ifdef USE_COMBINATION_EXPLOSION_CHECK\n  {\n    int offset = (MIN(start, range) - str);\n    STATE_CHECK_BUFF_INIT(msa, end - str, offset, reg->num_comb_exp_check);\n  }\n#endif\n\n  s = (UChar* )start;\n  if (range > start) {   /* forward search */\n    if (s > str)\n      prev = onigenc_get_prev_char_head(reg->enc, str, s);\n    else\n      prev = (UChar* )NULL;\n\n    if (reg->optimize != ONIG_OPTIMIZE_NONE) {\n      UChar *sch_range, *low, *high, *low_prev;\n\n      sch_range = (UChar* )range;\n      if (reg->dmax != 0) {\n        if (reg->dmax == ONIG_INFINITE_DISTANCE)\n          sch_range = (UChar* )end;\n        else {\n          sch_range += reg->dmax;\n          if (sch_range > end) sch_range = (UChar* )end;\n        }\n      }\n\n      if ((end - start) < reg->threshold_len)\n        goto mismatch;\n\n      if (reg->dmax != ONIG_INFINITE_DISTANCE) {\n        do {\n          if (! forward_search_range(reg, str, end, s, sch_range,\n                                     &low, &high, &low_prev)) goto mismatch;\n          if (s < low) {\n            s    = low;\n            prev = low_prev;\n          }\n          while (s <= high) {\n            MATCH_AND_RETURN_CHECK(orig_range);\n            prev = s;\n            s += enclen(reg->enc, s);\n          }\n        } while (s < range);\n        goto mismatch;\n      }\n      else { /* check only. */\n        if (! forward_search_range(reg, str, end, s, sch_range,\n                                   &low, &high, (UChar** )NULL)) goto mismatch;\n\n        if ((reg->anchor & ANCHOR_ANYCHAR_STAR) != 0) {\n          do {\n            MATCH_AND_RETURN_CHECK(orig_range);\n            prev = s;\n            s += enclen(reg->enc, s);\n\n            if ((reg->anchor & (ANCHOR_LOOK_BEHIND | ANCHOR_PREC_READ_NOT)) == 0) {\n              while (!ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end) && s < range) {\n                prev = s;\n                s += enclen(reg->enc, s);\n              }\n            }\n          } while (s < range);\n          goto mismatch;\n        }\n      }\n    }\n\n    do {\n      MATCH_AND_RETURN_CHECK(orig_range);\n      prev = s;\n      s += enclen(reg->enc, s);\n    } while (s < range);\n\n    if (s == range) { /* because empty match with /$/. */\n      MATCH_AND_RETURN_CHECK(orig_range);\n    }\n  }\n  else {  /* backward search */\n#ifdef USE_MATCH_RANGE_MUST_BE_INSIDE_OF_SPECIFIED_RANGE\n    if (orig_start < end)\n      orig_start += enclen(reg->enc, orig_start); /* is upper range */\n#endif\n\n    if (reg->optimize != ONIG_OPTIMIZE_NONE) {\n      UChar *low, *high, *adjrange, *sch_start;\n\n      if (range < end)\n        adjrange = ONIGENC_LEFT_ADJUST_CHAR_HEAD(reg->enc, str, range);\n      else\n        adjrange = (UChar* )end;\n\n      if (reg->dmax != ONIG_INFINITE_DISTANCE &&\n          (end - range) >= reg->threshold_len) {\n        do {\n          sch_start = s + reg->dmax;\n          if (sch_start > end) sch_start = (UChar* )end;\n          if (backward_search_range(reg, str, end, sch_start, range, adjrange,\n                                    &low, &high) <= 0)\n            goto mismatch;\n\n          if (s > high)\n            s = high;\n\n          while (s >= low) {\n            prev = onigenc_get_prev_char_head(reg->enc, str, s);\n            MATCH_AND_RETURN_CHECK(orig_start);\n            s = prev;\n          }\n        } while (s >= range);\n        goto mismatch;\n      }\n      else { /* check only. */\n        if ((end - range) < reg->threshold_len) goto mismatch;\n\n        sch_start = s;\n        if (reg->dmax != 0) {\n          if (reg->dmax == ONIG_INFINITE_DISTANCE)\n            sch_start = (UChar* )end;\n          else {\n            sch_start += reg->dmax;\n            if (sch_start > end) sch_start = (UChar* )end;\n            else\n              sch_start = ONIGENC_LEFT_ADJUST_CHAR_HEAD(reg->enc,\n                                                        start, sch_start);\n          }\n        }\n        if (backward_search_range(reg, str, end, sch_start, range, adjrange,\n                                  &low, &high) <= 0) goto mismatch;\n      }\n    }\n\n    do {\n      prev = onigenc_get_prev_char_head(reg->enc, str, s);\n      MATCH_AND_RETURN_CHECK(orig_start);\n      s = prev;\n    } while (s >= range);\n  }\n\n mismatch:\n#ifdef USE_FIND_LONGEST_SEARCH_ALL_OF_RANGE\n  if (IS_FIND_LONGEST(reg->options)) {\n    if (msa.best_len >= 0) {\n      s = msa.best_s;\n      goto match;\n    }\n  }\n#endif\n  r = ONIG_MISMATCH;\n\n finish:\n  MATCH_ARG_FREE(msa);\n\n  /* If result is mismatch and no FIND_NOT_EMPTY option,\n     then the region is not set in match_at(). */\n  if (IS_FIND_NOT_EMPTY(reg->options) && region\n#ifdef USE_POSIX_API_REGION_OPTION\n      && !IS_POSIX_REGION(option)\n#endif\n      ) {\n    onig_region_clear(region);\n  }\n\n#ifdef ONIG_DEBUG\n  if (r != ONIG_MISMATCH)\n    fprintf(stderr, \"onig_search: error %d\\n\", r);\n#endif\n  return r;\n\n mismatch_no_msa:\n  r = ONIG_MISMATCH;\n finish_no_msa:\n#ifdef ONIG_DEBUG\n  if (r != ONIG_MISMATCH)\n    fprintf(stderr, \"onig_search: error %d\\n\", r);\n#endif\n  return r;\n\n match:\n  MATCH_ARG_FREE(msa);\n  return s - str;\n}\n\nextern int\nonig_scan(regex_t* reg, const UChar* str, const UChar* end,\n\t  OnigRegion* region, OnigOptionType option,\n\t  int (*scan_callback)(int, int, OnigRegion*, void*),\n\t  void* callback_arg)\n{\n  int r;\n  int n;\n  int rs;\n  const UChar* start;\n\n  if (ONIG_IS_OPTION_ON(option, ONIG_OPTION_CHECK_VALIDITY_OF_STRING)) {\n    if (! ONIGENC_IS_VALID_MBC_STRING(reg->enc, str, end))\n      return ONIGERR_INVALID_WIDE_CHAR_VALUE;\n\n    ONIG_OPTION_OFF(option, ONIG_OPTION_CHECK_VALIDITY_OF_STRING);\n  }\n\n  n = 0;\n  start = str;\n  while (1) {\n    r = onig_search(reg, str, end, start, end, region, option);\n    if (r >= 0) {\n      rs = scan_callback(n, r, region, callback_arg);\n      n++;\n      if (rs != 0)\n        return rs;\n\n      if (region->end[0] == start - str)\n        start++;\n      else\n        start = str + region->end[0];\n\n      if (start > end)\n        break;\n    }\n    else if (r == ONIG_MISMATCH) {\n      break;\n    }\n    else { /* error */\n      return r;\n    }\n  }\n\n  return n;\n}\n\nextern OnigEncoding\nonig_get_encoding(regex_t* reg)\n{\n  return reg->enc;\n}\n\nextern OnigOptionType\nonig_get_options(regex_t* reg)\n{\n  return reg->options;\n}\n\nextern  OnigCaseFoldType\nonig_get_case_fold_flag(regex_t* reg)\n{\n  return reg->case_fold_flag;\n}\n\nextern OnigSyntaxType*\nonig_get_syntax(regex_t* reg)\n{\n  return reg->syntax;\n}\n\nextern int\nonig_number_of_captures(regex_t* reg)\n{\n  return reg->num_mem;\n}\n\nextern int\nonig_number_of_capture_histories(regex_t* reg)\n{\n#ifdef USE_CAPTURE_HISTORY\n  int i, n;\n\n  n = 0;\n  for (i = 0; i <= ONIG_MAX_CAPTURE_HISTORY_GROUP; i++) {\n    if (BIT_STATUS_AT(reg->capture_history, i) != 0)\n      n++;\n  }\n  return n;\n#else\n  return 0;\n#endif\n}\n\nextern void\nonig_copy_encoding(OnigEncoding to, OnigEncoding from)\n{\n  *to = *from;\n}\n\n"], "fixing_code": ["/**********************************************************************\n  regexec.c -  Oniguruma (regular expression library)\n**********************************************************************/\n/*-\n * Copyright (c) 2002-2016  K.Kosako  <sndgk393 AT ybb DOT ne DOT jp>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#include \"regint.h\"\n\n#define USE_MATCH_RANGE_MUST_BE_INSIDE_OF_SPECIFIED_RANGE\n\n#ifdef USE_CRNL_AS_LINE_TERMINATOR\n#define ONIGENC_IS_MBC_CRNL(enc,p,end) \\\n  (ONIGENC_MBC_TO_CODE(enc,p,end) == 13 && \\\n   ONIGENC_IS_MBC_NEWLINE(enc,(p+enclen(enc,p)),end))\n#endif\n\n#ifdef USE_CAPTURE_HISTORY\nstatic void history_tree_free(OnigCaptureTreeNode* node);\n\nstatic void\nhistory_tree_clear(OnigCaptureTreeNode* node)\n{\n  int i;\n\n  if (IS_NOT_NULL(node)) {\n    for (i = 0; i < node->num_childs; i++) {\n      if (IS_NOT_NULL(node->childs[i])) {\n        history_tree_free(node->childs[i]);\n      }\n    }\n    for (i = 0; i < node->allocated; i++) {\n      node->childs[i] = (OnigCaptureTreeNode* )0;\n    }\n    node->num_childs = 0;\n    node->beg = ONIG_REGION_NOTPOS;\n    node->end = ONIG_REGION_NOTPOS;\n    node->group = -1;\n  }\n}\n\nstatic void\nhistory_tree_free(OnigCaptureTreeNode* node)\n{\n  history_tree_clear(node);\n  xfree(node);\n}\n\nstatic void\nhistory_root_free(OnigRegion* r)\n{\n  if (IS_NOT_NULL(r->history_root)) {\n    history_tree_free(r->history_root);\n    r->history_root = (OnigCaptureTreeNode* )0;\n  }\n}\n\nstatic OnigCaptureTreeNode*\nhistory_node_new(void)\n{\n  OnigCaptureTreeNode* node;\n\n  node = (OnigCaptureTreeNode* )xmalloc(sizeof(OnigCaptureTreeNode));\n  CHECK_NULL_RETURN(node);\n  node->childs     = (OnigCaptureTreeNode** )0;\n  node->allocated  = 0;\n  node->num_childs = 0;\n  node->group      = -1;\n  node->beg        = ONIG_REGION_NOTPOS;\n  node->end        = ONIG_REGION_NOTPOS;\n\n  return node;\n}\n\nstatic int\nhistory_tree_add_child(OnigCaptureTreeNode* parent, OnigCaptureTreeNode* child)\n{\n#define HISTORY_TREE_INIT_ALLOC_SIZE  8\n\n  if (parent->num_childs >= parent->allocated) {\n    int n, i;\n\n    if (IS_NULL(parent->childs)) {\n      n = HISTORY_TREE_INIT_ALLOC_SIZE;\n      parent->childs =\n        (OnigCaptureTreeNode** )xmalloc(sizeof(OnigCaptureTreeNode*) * n);\n    }\n    else {\n      n = parent->allocated * 2;\n      parent->childs =\n        (OnigCaptureTreeNode** )xrealloc(parent->childs,\n                                         sizeof(OnigCaptureTreeNode*) * n);\n    }\n    CHECK_NULL_RETURN_MEMERR(parent->childs);\n    for (i = parent->allocated; i < n; i++) {\n      parent->childs[i] = (OnigCaptureTreeNode* )0;\n    }\n    parent->allocated = n;\n  }\n\n  parent->childs[parent->num_childs] = child;\n  parent->num_childs++;\n  return 0;\n}\n\nstatic OnigCaptureTreeNode*\nhistory_tree_clone(OnigCaptureTreeNode* node)\n{\n  int i;\n  OnigCaptureTreeNode *clone, *child;\n\n  clone = history_node_new();\n  CHECK_NULL_RETURN(clone);\n\n  clone->beg = node->beg;\n  clone->end = node->end;\n  for (i = 0; i < node->num_childs; i++) {\n    child = history_tree_clone(node->childs[i]);\n    if (IS_NULL(child)) {\n      history_tree_free(clone);\n      return (OnigCaptureTreeNode* )0;\n    }\n    history_tree_add_child(clone, child);\n  }\n\n  return clone;\n}\n\nextern  OnigCaptureTreeNode*\nonig_get_capture_tree(OnigRegion* region)\n{\n  return region->history_root;\n}\n#endif /* USE_CAPTURE_HISTORY */\n\nextern void\nonig_region_clear(OnigRegion* region)\n{\n  int i;\n\n  for (i = 0; i < region->num_regs; i++) {\n    region->beg[i] = region->end[i] = ONIG_REGION_NOTPOS;\n  }\n#ifdef USE_CAPTURE_HISTORY\n  history_root_free(region);\n#endif\n}\n\nextern int\nonig_region_resize(OnigRegion* region, int n)\n{\n  region->num_regs = n;\n\n  if (n < ONIG_NREGION)\n    n = ONIG_NREGION;\n\n  if (region->allocated == 0) {\n    region->beg = (int* )xmalloc(n * sizeof(int));\n    region->end = (int* )xmalloc(n * sizeof(int));\n\n    if (region->beg == 0 || region->end == 0)\n      return ONIGERR_MEMORY;\n\n    region->allocated = n;\n  }\n  else if (region->allocated < n) {\n    region->beg = (int* )xrealloc(region->beg, n * sizeof(int));\n    region->end = (int* )xrealloc(region->end, n * sizeof(int));\n\n    if (region->beg == 0 || region->end == 0)\n      return ONIGERR_MEMORY;\n\n    region->allocated = n;\n  }\n\n  return 0;\n}\n\nstatic int\nonig_region_resize_clear(OnigRegion* region, int n)\n{\n  int r;\n  \n  r = onig_region_resize(region, n);\n  if (r != 0) return r;\n  onig_region_clear(region);\n  return 0;\n}\n    \nextern int\nonig_region_set(OnigRegion* region, int at, int beg, int end)\n{\n  if (at < 0) return ONIGERR_INVALID_ARGUMENT;\n\n  if (at >= region->allocated) {\n    int r = onig_region_resize(region, at + 1);\n    if (r < 0) return r;\n  }\n  \n  region->beg[at] = beg;\n  region->end[at] = end;\n  return 0;\n}\n\nextern void\nonig_region_init(OnigRegion* region)\n{\n  region->num_regs     = 0;\n  region->allocated    = 0;\n  region->beg          = (int* )0;\n  region->end          = (int* )0;\n  region->history_root = (OnigCaptureTreeNode* )0;\n}\n\nextern OnigRegion*\nonig_region_new(void)\n{\n  OnigRegion* r;\n\n  r = (OnigRegion* )xmalloc(sizeof(OnigRegion));\n  onig_region_init(r);\n  return r;\n}\n\nextern void\nonig_region_free(OnigRegion* r, int free_self)\n{\n  if (r) {\n    if (r->allocated > 0) {\n      if (r->beg) xfree(r->beg);\n      if (r->end) xfree(r->end);\n      r->allocated = 0;\n    }\n#ifdef USE_CAPTURE_HISTORY\n    history_root_free(r);\n#endif\n    if (free_self) xfree(r);\n  }\n}\n\nextern void\nonig_region_copy(OnigRegion* to, OnigRegion* from)\n{\n#define RREGC_SIZE   (sizeof(int) * from->num_regs)\n  int i;\n\n  if (to == from) return;\n\n  if (to->allocated == 0) {\n    if (from->num_regs > 0) {\n      to->beg = (int* )xmalloc(RREGC_SIZE);\n      to->end = (int* )xmalloc(RREGC_SIZE);\n      to->allocated = from->num_regs;\n    }\n  }\n  else if (to->allocated < from->num_regs) {\n    to->beg = (int* )xrealloc(to->beg, RREGC_SIZE);\n    to->end = (int* )xrealloc(to->end, RREGC_SIZE);\n    to->allocated = from->num_regs;\n  }\n\n  for (i = 0; i < from->num_regs; i++) {\n    to->beg[i] = from->beg[i];\n    to->end[i] = from->end[i];\n  }\n  to->num_regs = from->num_regs;\n\n#ifdef USE_CAPTURE_HISTORY\n  history_root_free(to);\n\n  if (IS_NOT_NULL(from->history_root)) {\n    to->history_root = history_tree_clone(from->history_root);\n  }\n#endif\n}\n\n\n/** stack **/\n#define INVALID_STACK_INDEX   -1\n\n/* stack type */\n/* used by normal-POP */\n#define STK_ALT                    0x0001\n#define STK_LOOK_BEHIND_NOT        0x0002\n#define STK_POS_NOT                0x0003\n/* handled by normal-POP */\n#define STK_MEM_START              0x0100\n#define STK_MEM_END                0x8200\n#define STK_REPEAT_INC             0x0300\n#define STK_STATE_CHECK_MARK       0x1000\n/* avoided by normal-POP */\n#define STK_NULL_CHECK_START       0x3000\n#define STK_NULL_CHECK_END         0x5000  /* for recursive call */\n#define STK_MEM_END_MARK           0x8400\n#define STK_POS                    0x0500  /* used when POP-POS */\n#define STK_STOP_BT                0x0600  /* mark for \"(?>...)\" */\n#define STK_REPEAT                 0x0700\n#define STK_CALL_FRAME             0x0800\n#define STK_RETURN                 0x0900\n#define STK_VOID                   0x0a00  /* for fill a blank */\n\n/* stack type check mask */\n#define STK_MASK_POP_USED          0x00ff\n#define STK_MASK_TO_VOID_TARGET    0x10ff\n#define STK_MASK_MEM_END_OR_MARK   0x8000  /* MEM_END or MEM_END_MARK */\n\n#ifdef USE_FIND_LONGEST_SEARCH_ALL_OF_RANGE\n#define MATCH_ARG_INIT(msa, reg, arg_option, arg_region, arg_start) do {\\\n  (msa).stack_p  = (void* )0;\\\n  (msa).options  = (arg_option);\\\n  (msa).region   = (arg_region);\\\n  (msa).start    = (arg_start);\\\n  (msa).best_len = ONIG_MISMATCH;\\\n  (msa).ptr_num  = (reg)->num_repeat + (reg)->num_mem * 2;\\\n} while(0)\n#else\n#define MATCH_ARG_INIT(msa, reg, arg_option, arg_region, arg_start) do {\\\n  (msa).stack_p  = (void* )0;\\\n  (msa).options  = (arg_option);\\\n  (msa).region   = (arg_region);\\\n  (msa).start    = (arg_start);\\\n  (msa).ptr_num  = (reg)->num_repeat + (reg)->num_mem * 2;\\\n} while(0)\n#endif\n\n#ifdef USE_COMBINATION_EXPLOSION_CHECK\n\n#define STATE_CHECK_BUFF_MALLOC_THRESHOLD_SIZE  16\n\n#define STATE_CHECK_BUFF_INIT(msa, str_len, offset, state_num) do {\t\\\n  if ((state_num) > 0 && str_len >= STATE_CHECK_STRING_THRESHOLD_LEN) {\\\n    unsigned int size = (unsigned int )(((str_len) + 1) * (state_num) + 7) >> 3;\\\n    offset = ((offset) * (state_num)) >> 3;\\\n    if (size > 0 && offset < size && size < STATE_CHECK_BUFF_MAX_SIZE) {\\\n      if (size >= STATE_CHECK_BUFF_MALLOC_THRESHOLD_SIZE) \\\n        (msa).state_check_buff = (void* )xmalloc(size);\\\n      else \\\n        (msa).state_check_buff = (void* )xalloca(size);\\\n      xmemset(((char* )((msa).state_check_buff)+(offset)), 0, \\\n              (size_t )(size - (offset))); \\\n      (msa).state_check_buff_size = size;\\\n    }\\\n    else {\\\n      (msa).state_check_buff = (void* )0;\\\n      (msa).state_check_buff_size = 0;\\\n    }\\\n  }\\\n  else {\\\n    (msa).state_check_buff = (void* )0;\\\n    (msa).state_check_buff_size = 0;\\\n  }\\\n} while(0)\n\n#define MATCH_ARG_FREE(msa) do {\\\n  if ((msa).stack_p) xfree((msa).stack_p);\\\n  if ((msa).state_check_buff_size >= STATE_CHECK_BUFF_MALLOC_THRESHOLD_SIZE) { \\\n    if ((msa).state_check_buff) xfree((msa).state_check_buff);\\\n  }\\\n} while(0)\n#else\n#define STATE_CHECK_BUFF_INIT(msa, str_len, offset, state_num)\n#define MATCH_ARG_FREE(msa)  if ((msa).stack_p) xfree((msa).stack_p)\n#endif\n\n\n#define ALLOCA_PTR_NUM_LIMIT   50\n\n#define STACK_INIT(stack_num)  do {\\\n  if (msa->stack_p) {\\\n    is_alloca  = 0;\\\n    alloc_base = msa->stack_p;\\\n    stk_base   = (OnigStackType* )(alloc_base\\\n                 + (sizeof(OnigStackIndex) * msa->ptr_num));\\\n    stk        = stk_base;\\\n    stk_end    = stk_base + msa->stack_n;\\\n  }\\\n  else if (msa->ptr_num > ALLOCA_PTR_NUM_LIMIT) {\\\n    is_alloca  = 0;\\\n    alloc_base = (char* )xmalloc(sizeof(OnigStackIndex) * msa->ptr_num\\\n                  + sizeof(OnigStackType) * (stack_num));\\\n    stk_base   = (OnigStackType* )(alloc_base\\\n                 + (sizeof(OnigStackIndex) * msa->ptr_num));\\\n    stk        = stk_base;\\\n    stk_end    = stk_base + (stack_num);\\\n  }\\\n  else {\\\n    is_alloca  = 1;\\\n    alloc_base = (char* )xalloca(sizeof(OnigStackIndex) * msa->ptr_num\\\n                 + sizeof(OnigStackType) * (stack_num));\\\n    stk_base   = (OnigStackType* )(alloc_base\\\n                 + (sizeof(OnigStackIndex) * msa->ptr_num));\\\n    stk        = stk_base;\\\n    stk_end    = stk_base + (stack_num);\\\n  }\\\n} while(0);\n\n\n#define STACK_SAVE do{\\\n  msa->stack_n = stk_end - stk_base;\\\n  if (is_alloca != 0) {\\\n    size_t size = sizeof(OnigStackIndex) * msa->ptr_num \\\n                + sizeof(OnigStackType) * msa->stack_n;\\\n    msa->stack_p = xmalloc(size);\\\n    xmemcpy(msa->stack_p, alloc_base, size);\\\n  }\\\n  else {\\\n    msa->stack_p = alloc_base;\\\n  };\\\n} while(0)\n\n#define UPDATE_FOR_STACK_REALLOC do{\\\n  repeat_stk = (OnigStackIndex* )alloc_base;\\\n  mem_start_stk = (OnigStackIndex* )(repeat_stk + reg->num_repeat);\\\n  mem_end_stk   = mem_start_stk + num_mem;\\\n  mem_start_stk--; /* for index start from 1 */\\\n  mem_end_stk--;   /* for index start from 1 */\\\n} while(0)\n\nstatic unsigned int MatchStackLimitSize = DEFAULT_MATCH_STACK_LIMIT_SIZE;\n\nextern unsigned int\nonig_get_match_stack_limit_size(void)\n{\n  return MatchStackLimitSize;\n}\n\nextern int\nonig_set_match_stack_limit_size(unsigned int size)\n{\n  MatchStackLimitSize = size;\n  return 0;\n}\n\nstatic int\nstack_double(int is_alloca, char** arg_alloc_base,\n\t     OnigStackType** arg_stk_base,\n\t     OnigStackType** arg_stk_end, OnigStackType** arg_stk,\n\t     OnigMatchArg* msa)\n{\n  unsigned int n;\n  int used;\n  size_t size;\n  size_t new_size;\n  char* alloc_base;\n  char* new_alloc_base;\n  OnigStackType *stk_base, *stk_end, *stk;\n\n  alloc_base = *arg_alloc_base;\n  stk_base = *arg_stk_base;\n  stk_end  = *arg_stk_end;\n  stk      = *arg_stk;\n\n  n = stk_end - stk_base;\n  size = sizeof(OnigStackIndex) * msa->ptr_num + sizeof(OnigStackType) * n;\n  n *= 2;\n  new_size = sizeof(OnigStackIndex) * msa->ptr_num + sizeof(OnigStackType) * n;\n  if (is_alloca != 0) {\n    new_alloc_base = (char* )xmalloc(new_size);\n    if (IS_NULL(new_alloc_base)) {\n      STACK_SAVE;\n      return ONIGERR_MEMORY;\n    }\n    xmemcpy(new_alloc_base, alloc_base, size);\n  }\n  else {\n    if (MatchStackLimitSize != 0 && n > MatchStackLimitSize) {\n      if ((unsigned int )(stk_end - stk_base) == MatchStackLimitSize)\n        return ONIGERR_MATCH_STACK_LIMIT_OVER;\n      else\n        n = MatchStackLimitSize;\n    }\n    new_alloc_base = (char* )xrealloc(alloc_base, new_size);\n    if (IS_NULL(new_alloc_base)) {\n      STACK_SAVE;\n      return ONIGERR_MEMORY;\n    }\n  }\n\n  alloc_base = new_alloc_base;\n  used = stk - stk_base;\n  *arg_alloc_base = alloc_base;\n  *arg_stk_base   = (OnigStackType* )(alloc_base\n\t\t       + (sizeof(OnigStackIndex) * msa->ptr_num));\n  *arg_stk      = *arg_stk_base + used;\n  *arg_stk_end  = *arg_stk_base + n;\n  return 0;\n}\n\n#define STACK_ENSURE(n)\tdo {\\\n  if (stk_end - stk < (n)) {\\\n    int r = stack_double(is_alloca, &alloc_base, &stk_base, &stk_end, &stk,\\\n                         msa);\\\n    if (r != 0) { STACK_SAVE; return r; } \\\n    is_alloca = 0;\\\n    UPDATE_FOR_STACK_REALLOC;\\\n  }\\\n} while(0)\n\n#define STACK_AT(index)        (stk_base + (index))\n#define GET_STACK_INDEX(stk)   ((stk) - stk_base)\n\n#define STACK_PUSH_TYPE(stack_type) do {\\\n  STACK_ENSURE(1);\\\n  stk->type = (stack_type);\\\n  STACK_INC;\\\n} while(0)\n\n#define IS_TO_VOID_TARGET(stk) (((stk)->type & STK_MASK_TO_VOID_TARGET) != 0)\n\n#ifdef USE_COMBINATION_EXPLOSION_CHECK\n#define STATE_CHECK_POS(s,snum) \\\n  (((s) - str) * num_comb_exp_check + ((snum) - 1))\n#define STATE_CHECK_VAL(v,snum) do {\\\n  if (state_check_buff != NULL) {\\\n    int x = STATE_CHECK_POS(s,snum);\\\n    (v) = state_check_buff[x/8] & (1<<(x%8));\\\n  }\\\n  else (v) = 0;\\\n} while(0)\n\n\n#define ELSE_IF_STATE_CHECK_MARK(stk) \\\n  else if ((stk)->type == STK_STATE_CHECK_MARK) { \\\n    int x = STATE_CHECK_POS(stk->u.state.pstr, stk->u.state.state_check);\\\n    state_check_buff[x/8] |= (1<<(x%8));\t\t\t\t\\\n  }\n\n#define STACK_PUSH(stack_type,pat,s,sprev) do {\\\n  STACK_ENSURE(1);\\\n  stk->type = (stack_type);\\\n  stk->u.state.pcode     = (pat);\\\n  stk->u.state.pstr      = (s);\\\n  stk->u.state.pstr_prev = (sprev);\\\n  stk->u.state.state_check = 0;\\\n  STACK_INC;\\\n} while(0)\n\n#define STACK_PUSH_ENSURED(stack_type,pat) do {\\\n  stk->type = (stack_type);\\\n  stk->u.state.pcode = (pat);\\\n  stk->u.state.state_check = 0;\\\n  STACK_INC;\\\n} while(0)\n\n#define STACK_PUSH_ALT_WITH_STATE_CHECK(pat,s,sprev,snum) do {\\\n  STACK_ENSURE(1);\\\n  stk->type = STK_ALT;\\\n  stk->u.state.pcode     = (pat);\\\n  stk->u.state.pstr      = (s);\\\n  stk->u.state.pstr_prev = (sprev);\\\n  stk->u.state.state_check = ((state_check_buff != NULL) ? (snum) : 0);\\\n  STACK_INC;\\\n} while(0)\n\n#define STACK_PUSH_STATE_CHECK(s,snum) do {\\\n  if (state_check_buff != NULL) {\\\n    STACK_ENSURE(1);\\\n    stk->type = STK_STATE_CHECK_MARK;\\\n    stk->u.state.pstr = (s);\\\n    stk->u.state.state_check = (snum);\\\n    STACK_INC;\\\n  }\\\n} while(0)\n\n#else /* USE_COMBINATION_EXPLOSION_CHECK */\n\n#define ELSE_IF_STATE_CHECK_MARK(stk)\n\n#define STACK_PUSH(stack_type,pat,s,sprev) do {\\\n  STACK_ENSURE(1);\\\n  stk->type = (stack_type);\\\n  stk->u.state.pcode     = (pat);\\\n  stk->u.state.pstr      = (s);\\\n  stk->u.state.pstr_prev = (sprev);\\\n  STACK_INC;\\\n} while(0)\n\n#define STACK_PUSH_ENSURED(stack_type,pat) do {\\\n  stk->type = (stack_type);\\\n  stk->u.state.pcode = (pat);\\\n  STACK_INC;\\\n} while(0)\n#endif /* USE_COMBINATION_EXPLOSION_CHECK */\n\n#define STACK_PUSH_ALT(pat,s,sprev)     STACK_PUSH(STK_ALT,pat,s,sprev)\n#define STACK_PUSH_POS(s,sprev)         STACK_PUSH(STK_POS,NULL_UCHARP,s,sprev)\n#define STACK_PUSH_POS_NOT(pat,s,sprev) STACK_PUSH(STK_POS_NOT,pat,s,sprev)\n#define STACK_PUSH_STOP_BT              STACK_PUSH_TYPE(STK_STOP_BT)\n#define STACK_PUSH_LOOK_BEHIND_NOT(pat,s,sprev) \\\n        STACK_PUSH(STK_LOOK_BEHIND_NOT,pat,s,sprev)\n\n#define STACK_PUSH_REPEAT(id, pat) do {\\\n  STACK_ENSURE(1);\\\n  stk->type = STK_REPEAT;\\\n  stk->u.repeat.num    = (id);\\\n  stk->u.repeat.pcode  = (pat);\\\n  stk->u.repeat.count  = 0;\\\n  STACK_INC;\\\n} while(0)\n\n#define STACK_PUSH_REPEAT_INC(sindex) do {\\\n  STACK_ENSURE(1);\\\n  stk->type = STK_REPEAT_INC;\\\n  stk->u.repeat_inc.si  = (sindex);\\\n  STACK_INC;\\\n} while(0)\n\n#define STACK_PUSH_MEM_START(mnum, s) do {\\\n  STACK_ENSURE(1);\\\n  stk->type = STK_MEM_START;\\\n  stk->u.mem.num      = (mnum);\\\n  stk->u.mem.pstr     = (s);\\\n  stk->u.mem.start    = mem_start_stk[mnum];\\\n  stk->u.mem.end      = mem_end_stk[mnum];\\\n  mem_start_stk[mnum] = GET_STACK_INDEX(stk);\\\n  mem_end_stk[mnum]   = INVALID_STACK_INDEX;\\\n  STACK_INC;\\\n} while(0)\n\n#define STACK_PUSH_MEM_END(mnum, s) do {\\\n  STACK_ENSURE(1);\\\n  stk->type = STK_MEM_END;\\\n  stk->u.mem.num    = (mnum);\\\n  stk->u.mem.pstr   = (s);\\\n  stk->u.mem.start  = mem_start_stk[mnum];\\\n  stk->u.mem.end    = mem_end_stk[mnum];\\\n  mem_end_stk[mnum] = GET_STACK_INDEX(stk);\\\n  STACK_INC;\\\n} while(0)\n\n#define STACK_PUSH_MEM_END_MARK(mnum) do {\\\n  STACK_ENSURE(1);\\\n  stk->type = STK_MEM_END_MARK;\\\n  stk->u.mem.num = (mnum);\\\n  STACK_INC;\\\n} while(0)\n\n#define STACK_GET_MEM_START(mnum, k) do {\\\n  int level = 0;\\\n  k = stk;\\\n  while (k > stk_base) {\\\n    k--;\\\n    if ((k->type & STK_MASK_MEM_END_OR_MARK) != 0 \\\n      && k->u.mem.num == (mnum)) {\\\n      level++;\\\n    }\\\n    else if (k->type == STK_MEM_START && k->u.mem.num == (mnum)) {\\\n      if (level == 0) break;\\\n      level--;\\\n    }\\\n  }\\\n} while(0)\n\n#define STACK_GET_MEM_RANGE(k, mnum, start, end) do {\\\n  int level = 0;\\\n  while (k < stk) {\\\n    if (k->type == STK_MEM_START && k->u.mem.num == (mnum)) {\\\n      if (level == 0) (start) = k->u.mem.pstr;\\\n      level++;\\\n    }\\\n    else if (k->type == STK_MEM_END && k->u.mem.num == (mnum)) {\\\n      level--;\\\n      if (level == 0) {\\\n        (end) = k->u.mem.pstr;\\\n        break;\\\n      }\\\n    }\\\n    k++;\\\n  }\\\n} while(0)\n\n#define STACK_PUSH_NULL_CHECK_START(cnum, s) do {\\\n  STACK_ENSURE(1);\\\n  stk->type = STK_NULL_CHECK_START;\\\n  stk->u.null_check.num  = (cnum);\\\n  stk->u.null_check.pstr = (s);\\\n  STACK_INC;\\\n} while(0)\n\n#define STACK_PUSH_NULL_CHECK_END(cnum) do {\\\n  STACK_ENSURE(1);\\\n  stk->type = STK_NULL_CHECK_END;\\\n  stk->u.null_check.num  = (cnum);\\\n  STACK_INC;\\\n} while(0)\n\n#define STACK_PUSH_CALL_FRAME(pat) do {\\\n  STACK_ENSURE(1);\\\n  stk->type = STK_CALL_FRAME;\\\n  stk->u.call_frame.ret_addr = (pat);\\\n  STACK_INC;\\\n} while(0)\n\n#define STACK_PUSH_RETURN do {\\\n  STACK_ENSURE(1);\\\n  stk->type = STK_RETURN;\\\n  STACK_INC;\\\n} while(0)\n\n\n#ifdef ONIG_DEBUG\n#define STACK_BASE_CHECK(p, at) \\\n  if ((p) < stk_base) {\\\n    fprintf(stderr, \"at %s\\n\", at);\\\n    goto stack_error;\\\n  }\n#else\n#define STACK_BASE_CHECK(p, at)\n#endif\n\n#define STACK_POP_ONE do {\\\n  stk--;\\\n  STACK_BASE_CHECK(stk, \"STACK_POP_ONE\"); \\\n} while(0)\n\n#define STACK_POP  do {\\\n  switch (pop_level) {\\\n  case STACK_POP_LEVEL_FREE:\\\n    while (1) {\\\n      stk--;\\\n      STACK_BASE_CHECK(stk, \"STACK_POP\"); \\\n      if ((stk->type & STK_MASK_POP_USED) != 0)  break;\\\n      ELSE_IF_STATE_CHECK_MARK(stk);\\\n    }\\\n    break;\\\n  case STACK_POP_LEVEL_MEM_START:\\\n    while (1) {\\\n      stk--;\\\n      STACK_BASE_CHECK(stk, \"STACK_POP 2\"); \\\n      if ((stk->type & STK_MASK_POP_USED) != 0)  break;\\\n      else if (stk->type == STK_MEM_START) {\\\n        mem_start_stk[stk->u.mem.num] = stk->u.mem.start;\\\n        mem_end_stk[stk->u.mem.num]   = stk->u.mem.end;\\\n      }\\\n      ELSE_IF_STATE_CHECK_MARK(stk);\\\n    }\\\n    break;\\\n  default:\\\n    while (1) {\\\n      stk--;\\\n      STACK_BASE_CHECK(stk, \"STACK_POP 3\"); \\\n      if ((stk->type & STK_MASK_POP_USED) != 0)  break;\\\n      else if (stk->type == STK_MEM_START) {\\\n        mem_start_stk[stk->u.mem.num] = stk->u.mem.start;\\\n        mem_end_stk[stk->u.mem.num]   = stk->u.mem.end;\\\n      }\\\n      else if (stk->type == STK_REPEAT_INC) {\\\n        STACK_AT(stk->u.repeat_inc.si)->u.repeat.count--;\\\n      }\\\n      else if (stk->type == STK_MEM_END) {\\\n        mem_start_stk[stk->u.mem.num] = stk->u.mem.start;\\\n        mem_end_stk[stk->u.mem.num]   = stk->u.mem.end;\\\n      }\\\n      ELSE_IF_STATE_CHECK_MARK(stk);\\\n    }\\\n    break;\\\n  }\\\n} while(0)\n\n#define STACK_POP_TIL_POS_NOT  do {\\\n  while (1) {\\\n    stk--;\\\n    STACK_BASE_CHECK(stk, \"STACK_POP_TIL_POS_NOT\"); \\\n    if (stk->type == STK_POS_NOT) break;\\\n    else if (stk->type == STK_MEM_START) {\\\n      mem_start_stk[stk->u.mem.num] = stk->u.mem.start;\\\n      mem_end_stk[stk->u.mem.num]   = stk->u.mem.end;\\\n    }\\\n    else if (stk->type == STK_REPEAT_INC) {\\\n      STACK_AT(stk->u.repeat_inc.si)->u.repeat.count--;\\\n    }\\\n    else if (stk->type == STK_MEM_END) {\\\n      mem_start_stk[stk->u.mem.num] = stk->u.mem.start;\\\n      mem_end_stk[stk->u.mem.num]   = stk->u.mem.end;\\\n    }\\\n    ELSE_IF_STATE_CHECK_MARK(stk);\\\n  }\\\n} while(0)\n\n#define STACK_POP_TIL_LOOK_BEHIND_NOT  do {\\\n  while (1) {\\\n    stk--;\\\n    STACK_BASE_CHECK(stk, \"STACK_POP_TIL_LOOK_BEHIND_NOT\"); \\\n    if (stk->type == STK_LOOK_BEHIND_NOT) break;\\\n    else if (stk->type == STK_MEM_START) {\\\n      mem_start_stk[stk->u.mem.num] = stk->u.mem.start;\\\n      mem_end_stk[stk->u.mem.num]   = stk->u.mem.end;\\\n    }\\\n    else if (stk->type == STK_REPEAT_INC) {\\\n      STACK_AT(stk->u.repeat_inc.si)->u.repeat.count--;\\\n    }\\\n    else if (stk->type == STK_MEM_END) {\\\n      mem_start_stk[stk->u.mem.num] = stk->u.mem.start;\\\n      mem_end_stk[stk->u.mem.num]   = stk->u.mem.end;\\\n    }\\\n    ELSE_IF_STATE_CHECK_MARK(stk);\\\n  }\\\n} while(0)\n\n#define STACK_POS_END(k) do {\\\n  k = stk;\\\n  while (1) {\\\n    k--;\\\n    STACK_BASE_CHECK(k, \"STACK_POS_END\"); \\\n    if (IS_TO_VOID_TARGET(k)) {\\\n      k->type = STK_VOID;\\\n    }\\\n    else if (k->type == STK_POS) {\\\n      k->type = STK_VOID;\\\n      break;\\\n    }\\\n  }\\\n} while(0)\n\n#define STACK_STOP_BT_END do {\\\n  OnigStackType *k = stk;\\\n  while (1) {\\\n    k--;\\\n    STACK_BASE_CHECK(k, \"STACK_STOP_BT_END\"); \\\n    if (IS_TO_VOID_TARGET(k)) {\\\n      k->type = STK_VOID;\\\n    }\\\n    else if (k->type == STK_STOP_BT) {\\\n      k->type = STK_VOID;\\\n      break;\\\n    }\\\n  }\\\n} while(0)\n\n#define STACK_NULL_CHECK(isnull,id,s) do {\\\n  OnigStackType* k = stk;\\\n  while (1) {\\\n    k--;\\\n    STACK_BASE_CHECK(k, \"STACK_NULL_CHECK\"); \\\n    if (k->type == STK_NULL_CHECK_START) {\\\n      if (k->u.null_check.num == (id)) {\\\n        (isnull) = (k->u.null_check.pstr == (s));\\\n        break;\\\n      }\\\n    }\\\n  }\\\n} while(0)\n\n#define STACK_NULL_CHECK_REC(isnull,id,s) do {\\\n  int level = 0;\\\n  OnigStackType* k = stk;\\\n  while (1) {\\\n    k--;\\\n    STACK_BASE_CHECK(k, \"STACK_NULL_CHECK_REC\"); \\\n    if (k->type == STK_NULL_CHECK_START) {\\\n      if (k->u.null_check.num == (id)) {\\\n        if (level == 0) {\\\n          (isnull) = (k->u.null_check.pstr == (s));\\\n          break;\\\n        }\\\n        else level--;\\\n      }\\\n    }\\\n    else if (k->type == STK_NULL_CHECK_END) {\\\n      level++;\\\n    }\\\n  }\\\n} while(0)\n\n#define STACK_NULL_CHECK_MEMST(isnull,id,s,reg) do {\\\n  OnigStackType* k = stk;\\\n  while (1) {\\\n    k--;\\\n    STACK_BASE_CHECK(k, \"STACK_NULL_CHECK_MEMST\"); \\\n    if (k->type == STK_NULL_CHECK_START) {\\\n      if (k->u.null_check.num == (id)) {\\\n        if (k->u.null_check.pstr != (s)) {\\\n          (isnull) = 0;\\\n          break;\\\n        }\\\n        else {\\\n          UChar* endp;\\\n          (isnull) = 1;\\\n          while (k < stk) {\\\n            if (k->type == STK_MEM_START) {\\\n              if (k->u.mem.end == INVALID_STACK_INDEX) {\\\n                (isnull) = 0; break;\\\n              }\\\n              if (BIT_STATUS_AT(reg->bt_mem_end, k->u.mem.num))\\\n                endp = STACK_AT(k->u.mem.end)->u.mem.pstr;\\\n              else\\\n                endp = (UChar* )k->u.mem.end;\\\n              if (STACK_AT(k->u.mem.start)->u.mem.pstr != endp) {\\\n                (isnull) = 0; break;\\\n              }\\\n              else if (endp != s) {\\\n                (isnull) = -1; /* empty, but position changed */ \\\n              }\\\n            }\\\n            k++;\\\n          }\\\n  \t  break;\\\n        }\\\n      }\\\n    }\\\n  }\\\n} while(0)\n\n#define STACK_NULL_CHECK_MEMST_REC(isnull,id,s,reg) do {\\\n  int level = 0;\\\n  OnigStackType* k = stk;\\\n  while (1) {\\\n    k--;\\\n    STACK_BASE_CHECK(k, \"STACK_NULL_CHECK_MEMST_REC\"); \\\n    if (k->type == STK_NULL_CHECK_START) {\\\n      if (k->u.null_check.num == (id)) {\\\n        if (level == 0) {\\\n          if (k->u.null_check.pstr != (s)) {\\\n            (isnull) = 0;\\\n            break;\\\n          }\\\n          else {\\\n            UChar* endp;\\\n            (isnull) = 1;\\\n            while (k < stk) {\\\n              if (k->type == STK_MEM_START) {\\\n                if (k->u.mem.end == INVALID_STACK_INDEX) {\\\n                  (isnull) = 0; break;\\\n                }\\\n                if (BIT_STATUS_AT(reg->bt_mem_end, k->u.mem.num))\\\n                  endp = STACK_AT(k->u.mem.end)->u.mem.pstr;\\\n                else\\\n                  endp = (UChar* )k->u.mem.end;\\\n                if (STACK_AT(k->u.mem.start)->u.mem.pstr != endp) {\\\n                  (isnull) = 0; break;\\\n                }\\\n                else if (endp != s) {\\\n                  (isnull) = -1; /* empty, but position changed */ \\\n                }\\\n              }\\\n              k++;\\\n            }\\\n  \t    break;\\\n          }\\\n        }\\\n        else {\\\n          level--;\\\n        }\\\n      }\\\n    }\\\n    else if (k->type == STK_NULL_CHECK_END) {\\\n      if (k->u.null_check.num == (id)) level++;\\\n    }\\\n  }\\\n} while(0)\n\n#define STACK_GET_REPEAT(id, k) do {\\\n  int level = 0;\\\n  k = stk;\\\n  while (1) {\\\n    k--;\\\n    STACK_BASE_CHECK(k, \"STACK_GET_REPEAT\"); \\\n    if (k->type == STK_REPEAT) {\\\n      if (level == 0) {\\\n        if (k->u.repeat.num == (id)) {\\\n          break;\\\n        }\\\n      }\\\n    }\\\n    else if (k->type == STK_CALL_FRAME) level--;\\\n    else if (k->type == STK_RETURN)     level++;\\\n  }\\\n} while(0)\n\n#define STACK_RETURN(addr)  do {\\\n  int level = 0;\\\n  OnigStackType* k = stk;\\\n  while (1) {\\\n    k--;\\\n    STACK_BASE_CHECK(k, \"STACK_RETURN\"); \\\n    if (k->type == STK_CALL_FRAME) {\\\n      if (level == 0) {\\\n        (addr) = k->u.call_frame.ret_addr;\\\n        break;\\\n      }\\\n      else level--;\\\n    }\\\n    else if (k->type == STK_RETURN)\\\n      level++;\\\n  }\\\n} while(0)\n\n\n#define STRING_CMP(s1,s2,len) do {\\\n  while (len-- > 0) {\\\n    if (*s1++ != *s2++) goto fail;\\\n  }\\\n} while(0)\n\n#define STRING_CMP_IC(case_fold_flag,s1,ps2,len) do {\\\n  if (string_cmp_ic(encode, case_fold_flag, s1, ps2, len) == 0) \\\n    goto fail; \\\n} while(0)\n\nstatic int string_cmp_ic(OnigEncoding enc, int case_fold_flag,\n\t\t\t UChar* s1, UChar** ps2, int mblen)\n{\n  UChar buf1[ONIGENC_MBC_CASE_FOLD_MAXLEN];\n  UChar buf2[ONIGENC_MBC_CASE_FOLD_MAXLEN];\n  UChar *p1, *p2, *end1, *s2, *end2;\n  int len1, len2;\n\n  s2   = *ps2;\n  end1 = s1 + mblen;\n  end2 = s2 + mblen;\n  while (s1 < end1) {\n    len1 = ONIGENC_MBC_CASE_FOLD(enc, case_fold_flag, &s1, end1, buf1);\n    len2 = ONIGENC_MBC_CASE_FOLD(enc, case_fold_flag, &s2, end2, buf2);\n    if (len1 != len2) return 0;\n    p1 = buf1;\n    p2 = buf2;\n    while (len1-- > 0) {\n      if (*p1 != *p2) return 0;\n      p1++;\n      p2++;\n    }\n  }\n\n  *ps2 = s2;\n  return 1;\n}\n\n#define STRING_CMP_VALUE(s1,s2,len,is_fail) do {\\\n  is_fail = 0;\\\n  while (len-- > 0) {\\\n    if (*s1++ != *s2++) {\\\n      is_fail = 1; break;\\\n    }\\\n  }\\\n} while(0)\n\n#define STRING_CMP_VALUE_IC(case_fold_flag,s1,ps2,len,is_fail) do {\\\n  if (string_cmp_ic(encode, case_fold_flag, s1, ps2, len) == 0) \\\n    is_fail = 1; \\\n  else \\\n    is_fail = 0; \\\n} while(0)\n\n\n#define IS_EMPTY_STR           (str == end)\n#define ON_STR_BEGIN(s)       ((s) == str)\n#define ON_STR_END(s)         ((s) == end)\n#ifdef USE_MATCH_RANGE_MUST_BE_INSIDE_OF_SPECIFIED_RANGE\n#define DATA_ENSURE_CHECK1     (s < right_range)\n#define DATA_ENSURE_CHECK(n)   (s + (n) <= right_range)\n#define DATA_ENSURE(n)         if (s + (n) > right_range) goto fail\n#else\n#define DATA_ENSURE_CHECK1     (s < end)\n#define DATA_ENSURE_CHECK(n)   (s + (n) <= end)\n#define DATA_ENSURE(n)         if (s + (n) > end) goto fail\n#endif /* USE_MATCH_RANGE_MUST_BE_INSIDE_OF_SPECIFIED_RANGE */\n\n\n#ifdef USE_CAPTURE_HISTORY\nstatic int\nmake_capture_history_tree(OnigCaptureTreeNode* node, OnigStackType** kp,\n                          OnigStackType* stk_top, UChar* str, regex_t* reg)\n{\n  int n, r;\n  OnigCaptureTreeNode* child;\n  OnigStackType* k = *kp;\n\n  while (k < stk_top) {\n    if (k->type == STK_MEM_START) {\n      n = k->u.mem.num;\n      if (n <= ONIG_MAX_CAPTURE_HISTORY_GROUP &&\n          BIT_STATUS_AT(reg->capture_history, n) != 0) {\n        child = history_node_new();\n        CHECK_NULL_RETURN_MEMERR(child);\n        child->group = n;\n        child->beg = (int )(k->u.mem.pstr - str);\n        r = history_tree_add_child(node, child);\n        if (r != 0) return r;\n        *kp = (k + 1);\n        r = make_capture_history_tree(child, kp, stk_top, str, reg);\n        if (r != 0) return r;\n\n        k = *kp;\n        child->end = (int )(k->u.mem.pstr - str);\n      }\n    }\n    else if (k->type == STK_MEM_END) {\n      if (k->u.mem.num == node->group) {\n        node->end = (int )(k->u.mem.pstr - str);\n        *kp = k;\n        return 0;\n      }\n    }\n    k++;\n  }\n\n  return 1; /* 1: root node ending. */\n}\n#endif\n\n#ifdef USE_BACKREF_WITH_LEVEL\nstatic int mem_is_in_memp(int mem, int num, UChar* memp)\n{\n  int i;\n  MemNumType m;\n\n  for (i = 0; i < num; i++) {\n    GET_MEMNUM_INC(m, memp);\n    if (mem == (int )m) return 1;\n  }\n  return 0;\n}\n\nstatic int backref_match_at_nested_level(regex_t* reg\n\t , OnigStackType* top, OnigStackType* stk_base\n\t , int ignore_case, int case_fold_flag\n\t , int nest, int mem_num, UChar* memp, UChar** s, const UChar* send)\n{\n  UChar *ss, *p, *pstart, *pend = NULL_UCHARP;\n  int level;\n  OnigStackType* k;\n\n  level = 0;\n  k = top;\n  k--;\n  while (k >= stk_base) {\n    if (k->type == STK_CALL_FRAME) {\n      level--;\n    }\n    else if (k->type == STK_RETURN) {\n      level++;\n    }\n    else if (level == nest) {\n      if (k->type == STK_MEM_START) {\n        if (mem_is_in_memp(k->u.mem.num, mem_num, memp)) {\n          pstart = k->u.mem.pstr;\n          if (pend != NULL_UCHARP) {\n            if (pend - pstart > send - *s) return 0; /* or goto next_mem; */\n            p  = pstart;\n            ss = *s;\n\n            if (ignore_case != 0) {\n              if (string_cmp_ic(reg->enc, case_fold_flag,\n                                pstart, &ss, (int )(pend - pstart)) == 0)\n                return 0; /* or goto next_mem; */\n            }\n            else {\n              while (p < pend) {\n                if (*p++ != *ss++) return 0; /* or goto next_mem; */\n              }\n            }\n\n            *s = ss;\n            return 1;\n          }\n        }\n      }\n      else if (k->type == STK_MEM_END) {\n        if (mem_is_in_memp(k->u.mem.num, mem_num, memp)) {\n          pend = k->u.mem.pstr;\n        }\n      }\n    }\n    k--;\n  }\n\n  return 0;\n}\n#endif /* USE_BACKREF_WITH_LEVEL */\n\n\n#ifdef ONIG_DEBUG_STATISTICS\n\n#define USE_TIMEOFDAY\n\n#ifdef USE_TIMEOFDAY\n#ifdef HAVE_SYS_TIME_H\n#include <sys/time.h>\n#endif\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\nstatic struct timeval ts, te;\n#define GETTIME(t)        gettimeofday(&(t), (struct timezone* )0)\n#define TIMEDIFF(te,ts)   (((te).tv_usec - (ts).tv_usec) + \\\n                           (((te).tv_sec - (ts).tv_sec)*1000000))\n#else\n#ifdef HAVE_SYS_TIMES_H\n#include <sys/times.h>\n#endif\nstatic struct tms ts, te;\n#define GETTIME(t)         times(&(t))\n#define TIMEDIFF(te,ts)   ((te).tms_utime - (ts).tms_utime)\n#endif\n\nstatic int OpCounter[256];\nstatic int OpPrevCounter[256];\nstatic unsigned long OpTime[256];\nstatic int OpCurr = OP_FINISH;\nstatic int OpPrevTarget = OP_FAIL;\nstatic int MaxStackDepth = 0;\n\n#define MOP_IN(opcode) do {\\\n  if (opcode == OpPrevTarget) OpPrevCounter[OpCurr]++;\\\n  OpCurr = opcode;\\\n  OpCounter[opcode]++;\\\n  GETTIME(ts);\\\n} while(0)\n\n#define MOP_OUT do {\\\n  GETTIME(te);\\\n  OpTime[OpCurr] += TIMEDIFF(te, ts);\\\n} while(0)\n\nextern void\nonig_statistics_init(void)\n{\n  int i;\n  for (i = 0; i < 256; i++) {\n    OpCounter[i] = OpPrevCounter[i] = 0; OpTime[i] = 0;\n  }\n  MaxStackDepth = 0;\n}\n\nextern int\nonig_print_statistics(FILE* f)\n{\n  int r;\n  int i;\n\n  r = fprintf(f, \"   count      prev        time\\n\");\n  if (r < 0) return -1;\n\n  for (i = 0; OnigOpInfo[i].opcode >= 0; i++) {\n    r = fprintf(f, \"%8d: %8d: %10ld: %s\\n\",\n                OpCounter[i], OpPrevCounter[i], OpTime[i], OnigOpInfo[i].name);\n    if (r < 0) return -1;\n  }\n  r = fprintf(f, \"\\nmax stack depth: %d\\n\", MaxStackDepth);\n  if (r < 0) return -1;\n\n  return 0;\n}\n\n#define STACK_INC do {\\\n  stk++;\\\n  if (stk - stk_base > MaxStackDepth) \\\n    MaxStackDepth = stk - stk_base;\\\n} while(0)\n\n#else\n#define STACK_INC     stk++\n\n#define MOP_IN(opcode)\n#define MOP_OUT\n#endif\n\n\n/* matching region of POSIX API */\ntypedef int regoff_t;\n\ntypedef struct {\n  regoff_t  rm_so;\n  regoff_t  rm_eo;\n} posix_regmatch_t;\n\n/* match data(str - end) from position (sstart). */\n/* if sstart == str then set sprev to NULL. */\nstatic int\nmatch_at(regex_t* reg, const UChar* str, const UChar* end,\n#ifdef USE_MATCH_RANGE_MUST_BE_INSIDE_OF_SPECIFIED_RANGE\n\t const UChar* right_range,\n#endif\n\t const UChar* sstart, UChar* sprev, OnigMatchArg* msa)\n{\n  static UChar FinishCode[] = { OP_FINISH };\n\n  int i, n, num_mem, best_len, pop_level;\n  LengthType tlen, tlen2;\n  MemNumType mem;\n  RelAddrType addr;\n  UChar *s, *q, *sbegin;\n  int is_alloca;\n  char *alloc_base;\n  OnigStackType *stk_base, *stk, *stk_end;\n  OnigStackType *stkp; /* used as any purpose. */\n  OnigStackIndex si;\n  OnigStackIndex *repeat_stk;\n  OnigStackIndex *mem_start_stk, *mem_end_stk;\n#ifdef USE_COMBINATION_EXPLOSION_CHECK\n  int scv;\n  unsigned char* state_check_buff = msa->state_check_buff;\n  int num_comb_exp_check = reg->num_comb_exp_check;\n#endif\n  UChar *p = reg->p;\n  OnigOptionType option = reg->options;\n  OnigEncoding encode = reg->enc;\n  OnigCaseFoldType case_fold_flag = reg->case_fold_flag;\n\n  //n = reg->num_repeat + reg->num_mem * 2;\n  pop_level = reg->stack_pop_level;\n  num_mem = reg->num_mem;\n  STACK_INIT(INIT_MATCH_STACK_SIZE);\n  UPDATE_FOR_STACK_REALLOC;\n  for (i = 1; i <= num_mem; i++) {\n    mem_start_stk[i] = mem_end_stk[i] = INVALID_STACK_INDEX;\n  }\n\n#ifdef ONIG_DEBUG_MATCH\n  fprintf(stderr, \"match_at: str: %d, end: %d, start: %d, sprev: %d\\n\",\n\t  (int )str, (int )end, (int )sstart, (int )sprev);\n  fprintf(stderr, \"size: %d, start offset: %d\\n\",\n\t  (int )(end - str), (int )(sstart - str));\n#endif\n\n  STACK_PUSH_ENSURED(STK_ALT, FinishCode);  /* bottom stack */\n  best_len = ONIG_MISMATCH;\n  s = (UChar* )sstart;\n  while (1) {\n#ifdef ONIG_DEBUG_MATCH\n    {\n      UChar *q, *bp, buf[50];\n      int len;\n      fprintf(stderr, \"%4d> \\\"\", (int )(s - str));\n      bp = buf;\n      for (i = 0, q = s; i < 7 && q < end; i++) {\n\tlen = enclen(encode, q);\n\twhile (len-- > 0) *bp++ = *q++;\n      }\n      if (q < end) { xmemcpy(bp, \"...\\\"\", 4); bp += 4; }\n      else         { xmemcpy(bp, \"\\\"\",    1); bp += 1; }\n      *bp = 0;\n      fputs((char* )buf, stderr);\n      for (i = 0; i < 20 - (bp - buf); i++) fputc(' ', stderr);\n      onig_print_compiled_byte_code(stderr, p, NULL, encode);\n      fprintf(stderr, \"\\n\");\n    }\n#endif\n\n    sbegin = s;\n    switch (*p++) {\n    case OP_END:  MOP_IN(OP_END);\n      n = s - sstart;\n      if (n > best_len) {\n        OnigRegion* region;\n#ifdef USE_FIND_LONGEST_SEARCH_ALL_OF_RANGE\n        if (IS_FIND_LONGEST(option)) {\n          if (n > msa->best_len) {\n            msa->best_len = n;\n            msa->best_s   = (UChar* )sstart;\n          }\n          else\n            goto end_best_len;\n        }\n#endif\n        best_len = n;\n        region = msa->region;\n        if (region) {\n#ifdef USE_POSIX_API_REGION_OPTION\n          if (IS_POSIX_REGION(msa->options)) {\n            posix_regmatch_t* rmt = (posix_regmatch_t* )region;\n\n            rmt[0].rm_so = sstart - str;\n            rmt[0].rm_eo = s      - str;\n            for (i = 1; i <= num_mem; i++) {\n              if (mem_end_stk[i] != INVALID_STACK_INDEX) {\n                if (BIT_STATUS_AT(reg->bt_mem_start, i))\n                  rmt[i].rm_so = STACK_AT(mem_start_stk[i])->u.mem.pstr - str;\n                else\n                  rmt[i].rm_so = (UChar* )((void* )(mem_start_stk[i])) - str;\n\n                rmt[i].rm_eo = (BIT_STATUS_AT(reg->bt_mem_end, i)\n                                ? STACK_AT(mem_end_stk[i])->u.mem.pstr\n                                : (UChar* )((void* )mem_end_stk[i])) - str;\n              }\n              else {\n                rmt[i].rm_so = rmt[i].rm_eo = ONIG_REGION_NOTPOS;\n              }\n            }\n          }\n          else {\n#endif /* USE_POSIX_API_REGION_OPTION */\n            region->beg[0] = sstart - str;\n            region->end[0] = s      - str;\n            for (i = 1; i <= num_mem; i++) {\n              if (mem_end_stk[i] != INVALID_STACK_INDEX) {\n                if (BIT_STATUS_AT(reg->bt_mem_start, i))\n                  region->beg[i] = STACK_AT(mem_start_stk[i])->u.mem.pstr - str;\n                else\n                  region->beg[i] = (UChar* )((void* )mem_start_stk[i]) - str;\n\n                region->end[i] = (BIT_STATUS_AT(reg->bt_mem_end, i)\n                                  ? STACK_AT(mem_end_stk[i])->u.mem.pstr\n                                  : (UChar* )((void* )mem_end_stk[i])) - str;\n              }\n              else {\n                region->beg[i] = region->end[i] = ONIG_REGION_NOTPOS;\n              }\n            }\n\n#ifdef USE_CAPTURE_HISTORY\n            if (reg->capture_history != 0) {\n              int r;\n              OnigCaptureTreeNode* node;\n\n              if (IS_NULL(region->history_root)) {\n                region->history_root = node = history_node_new();\n                CHECK_NULL_RETURN_MEMERR(node);\n              }\n              else {\n                node = region->history_root;\n                history_tree_clear(node);\n              }\n\n              node->group = 0;\n              node->beg   = sstart - str;\n              node->end   = s      - str;\n\n              stkp = stk_base;\n              r = make_capture_history_tree(region->history_root, &stkp,\n                                            stk, (UChar* )str, reg);\n              if (r < 0) {\n                best_len = r; /* error code */\n                goto finish;\n              }\n            }\n#endif /* USE_CAPTURE_HISTORY */\n#ifdef USE_POSIX_API_REGION_OPTION\n          } /* else IS_POSIX_REGION() */\n#endif\n        } /* if (region) */\n      } /* n > best_len */\n\n#ifdef USE_FIND_LONGEST_SEARCH_ALL_OF_RANGE\n    end_best_len:\n#endif\n      MOP_OUT;\n\n      if (IS_FIND_CONDITION(option)) {\n        if (IS_FIND_NOT_EMPTY(option) && s == sstart) {\n          best_len = ONIG_MISMATCH;\n          goto fail; /* for retry */\n        }\n        if (IS_FIND_LONGEST(option) && DATA_ENSURE_CHECK1) {\n          goto fail; /* for retry */\n        }\n      }\n\n      /* default behavior: return first-matching result. */\n      goto finish;\n      break;\n\n    case OP_EXACT1:  MOP_IN(OP_EXACT1);\n      DATA_ENSURE(1);\n      if (*p != *s) goto fail;\n      p++; s++;\n      MOP_OUT;\n      break;\n\n    case OP_EXACT1_IC:  MOP_IN(OP_EXACT1_IC);\n      {\n        int len;\n        UChar *q, lowbuf[ONIGENC_MBC_CASE_FOLD_MAXLEN];\n\n        DATA_ENSURE(1);\n        len = ONIGENC_MBC_CASE_FOLD(encode,\n                 /* DISABLE_CASE_FOLD_MULTI_CHAR(case_fold_flag), */\n                                    case_fold_flag,\n                                    &s, end, lowbuf);\n        DATA_ENSURE(0);\n        q = lowbuf;\n        while (len-- > 0) {\n          if (*p != *q) {\n            goto fail;\n          }\n          p++; q++;\n        }\n      }\n      MOP_OUT;\n      break;\n\n    case OP_EXACT2:  MOP_IN(OP_EXACT2);\n      DATA_ENSURE(2);\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      sprev = s;\n      p++; s++;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_EXACT3:  MOP_IN(OP_EXACT3);\n      DATA_ENSURE(3);\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      sprev = s;\n      p++; s++;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_EXACT4:  MOP_IN(OP_EXACT4);\n      DATA_ENSURE(4);\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      sprev = s;\n      p++; s++;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_EXACT5:  MOP_IN(OP_EXACT5);\n      DATA_ENSURE(5);\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      sprev = s;\n      p++; s++;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_EXACTN:  MOP_IN(OP_EXACTN);\n      GET_LENGTH_INC(tlen, p);\n      DATA_ENSURE(tlen);\n      while (tlen-- > 0) {\n        if (*p++ != *s++) goto fail;\n      }\n      sprev = s - 1;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_EXACTN_IC:  MOP_IN(OP_EXACTN_IC);\n      {\n        int len;\n        UChar *q, *endp, lowbuf[ONIGENC_MBC_CASE_FOLD_MAXLEN];\n\n        GET_LENGTH_INC(tlen, p);\n        endp = p + tlen;\n\n        while (p < endp) {\n          sprev = s;\n          DATA_ENSURE(1);\n          len = ONIGENC_MBC_CASE_FOLD(encode,\n                        /* DISABLE_CASE_FOLD_MULTI_CHAR(case_fold_flag), */\n                                      case_fold_flag,\n                                      &s, end, lowbuf);\n          DATA_ENSURE(0);\n          q = lowbuf;\n          while (len-- > 0) {\n            if (*p != *q) goto fail;\n            p++; q++;\n          }\n        }\n      }\n\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_EXACTMB2N1:  MOP_IN(OP_EXACTMB2N1);\n      DATA_ENSURE(2);\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      p++; s++;\n      MOP_OUT;\n      break;\n\n    case OP_EXACTMB2N2:  MOP_IN(OP_EXACTMB2N2);\n      DATA_ENSURE(4);\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      p++; s++;\n      sprev = s;\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      p++; s++;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_EXACTMB2N3:  MOP_IN(OP_EXACTMB2N3);\n      DATA_ENSURE(6);\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      p++; s++;\n      sprev = s;\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      p++; s++;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_EXACTMB2N:  MOP_IN(OP_EXACTMB2N);\n      GET_LENGTH_INC(tlen, p);\n      DATA_ENSURE(tlen * 2);\n      while (tlen-- > 0) {\n        if (*p != *s) goto fail;\n        p++; s++;\n        if (*p != *s) goto fail;\n        p++; s++;\n      }\n      sprev = s - 2;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_EXACTMB3N:  MOP_IN(OP_EXACTMB3N);\n      GET_LENGTH_INC(tlen, p);\n      DATA_ENSURE(tlen * 3);\n      while (tlen-- > 0) {\n        if (*p != *s) goto fail;\n        p++; s++;\n        if (*p != *s) goto fail;\n        p++; s++;\n        if (*p != *s) goto fail;\n        p++; s++;\n      }\n      sprev = s - 3;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_EXACTMBN:  MOP_IN(OP_EXACTMBN);\n      GET_LENGTH_INC(tlen,  p);  /* mb-len */\n      GET_LENGTH_INC(tlen2, p);  /* string len */\n      tlen2 *= tlen;\n      DATA_ENSURE(tlen2);\n      while (tlen2-- > 0) {\n        if (*p != *s) goto fail;\n        p++; s++;\n      }\n      sprev = s - tlen;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_CCLASS:  MOP_IN(OP_CCLASS);\n      DATA_ENSURE(1);\n      if (BITSET_AT(((BitSetRef )p), *s) == 0) goto fail;\n      p += SIZE_BITSET;\n      s += enclen(encode, s);   /* OP_CCLASS can match mb-code. \\D, \\S */\n      MOP_OUT;\n      break;\n\n    case OP_CCLASS_MB:  MOP_IN(OP_CCLASS_MB);\n      if (! ONIGENC_IS_MBC_HEAD(encode, s)) goto fail;\n\n    cclass_mb:\n      GET_LENGTH_INC(tlen, p);\n      {\n        OnigCodePoint code;\n        UChar *ss;\n        int mb_len;\n\n        DATA_ENSURE(1);\n        mb_len = enclen(encode, s);\n        DATA_ENSURE(mb_len);\n        ss = s;\n        s += mb_len;\n        code = ONIGENC_MBC_TO_CODE(encode, ss, s);\n\n#ifdef PLATFORM_UNALIGNED_WORD_ACCESS\n        if (! onig_is_in_code_range(p, code)) goto fail;\n#else\n        q = p;\n        ALIGNMENT_RIGHT(q);\n        if (! onig_is_in_code_range(q, code)) goto fail;\n#endif\n      }\n      p += tlen;\n      MOP_OUT;\n      break;\n\n    case OP_CCLASS_MIX:  MOP_IN(OP_CCLASS_MIX);\n      DATA_ENSURE(1);\n      if (ONIGENC_IS_MBC_HEAD(encode, s)) {\n        p += SIZE_BITSET;\n        goto cclass_mb;\n      }\n      else {\n        if (BITSET_AT(((BitSetRef )p), *s) == 0)\n          goto fail;\n\n        p += SIZE_BITSET;\n        GET_LENGTH_INC(tlen, p);\n        p += tlen;\n        s++;\n      }\n      MOP_OUT;\n      break;\n\n    case OP_CCLASS_NOT:  MOP_IN(OP_CCLASS_NOT);\n      DATA_ENSURE(1);\n      if (BITSET_AT(((BitSetRef )p), *s) != 0) goto fail;\n      p += SIZE_BITSET;\n      s += enclen(encode, s);\n      MOP_OUT;\n      break;\n\n    case OP_CCLASS_MB_NOT:  MOP_IN(OP_CCLASS_MB_NOT);\n      DATA_ENSURE(1);\n      if (! ONIGENC_IS_MBC_HEAD(encode, s)) {\n        s++;\n        GET_LENGTH_INC(tlen, p);\n        p += tlen;\n        goto cc_mb_not_success;\n      }\n\n    cclass_mb_not:\n      GET_LENGTH_INC(tlen, p);\n      {\n        OnigCodePoint code;\n        UChar *ss;\n        int mb_len = enclen(encode, s);\n\n        if (! DATA_ENSURE_CHECK(mb_len)) {\n          DATA_ENSURE(1);\n          s = (UChar* )end;\n          p += tlen;\n          goto cc_mb_not_success;\n        }\n\n        ss = s;\n        s += mb_len;\n        code = ONIGENC_MBC_TO_CODE(encode, ss, s);\n\n#ifdef PLATFORM_UNALIGNED_WORD_ACCESS\n        if (onig_is_in_code_range(p, code)) goto fail;\n#else\n        q = p;\n        ALIGNMENT_RIGHT(q);\n        if (onig_is_in_code_range(q, code)) goto fail;\n#endif\n      }\n      p += tlen;\n\n    cc_mb_not_success:\n      MOP_OUT;\n      break;\n\n    case OP_CCLASS_MIX_NOT:  MOP_IN(OP_CCLASS_MIX_NOT);\n      DATA_ENSURE(1);\n      if (ONIGENC_IS_MBC_HEAD(encode, s)) {\n        p += SIZE_BITSET;\n        goto cclass_mb_not;\n      }\n      else {\n        if (BITSET_AT(((BitSetRef )p), *s) != 0)\n          goto fail;\n\n        p += SIZE_BITSET;\n        GET_LENGTH_INC(tlen, p);\n        p += tlen;\n        s++;\n      }\n      MOP_OUT;\n      break;\n\n    case OP_CCLASS_NODE:  MOP_IN(OP_CCLASS_NODE);\n      {\n        OnigCodePoint code;\n        void *node;\n        int mb_len;\n        UChar *ss;\n\n        DATA_ENSURE(1);\n        GET_POINTER_INC(node, p);\n        mb_len = enclen(encode, s);\n        ss = s;\n        s += mb_len;\n        DATA_ENSURE(0);\n        code = ONIGENC_MBC_TO_CODE(encode, ss, s);\n        if (onig_is_code_in_cc_len(mb_len, code, node) == 0) goto fail;\n      }\n      MOP_OUT;\n      break;\n\n    case OP_ANYCHAR:  MOP_IN(OP_ANYCHAR);\n      DATA_ENSURE(1);\n      n = enclen(encode, s);\n      DATA_ENSURE(n);\n      if (ONIGENC_IS_MBC_NEWLINE(encode, s, end)) goto fail;\n      s += n;\n      MOP_OUT;\n      break;\n\n    case OP_ANYCHAR_ML:  MOP_IN(OP_ANYCHAR_ML);\n      DATA_ENSURE(1);\n      n = enclen(encode, s);\n      DATA_ENSURE(n);\n      s += n;\n      MOP_OUT;\n      break;\n\n    case OP_ANYCHAR_STAR:  MOP_IN(OP_ANYCHAR_STAR);\n      while (DATA_ENSURE_CHECK1) {\n        STACK_PUSH_ALT(p, s, sprev);\n        n = enclen(encode, s);\n        DATA_ENSURE(n);\n        if (ONIGENC_IS_MBC_NEWLINE(encode, s, end))  goto fail;\n        sprev = s;\n        s += n;\n      }\n      MOP_OUT;\n      break;\n\n    case OP_ANYCHAR_ML_STAR:  MOP_IN(OP_ANYCHAR_ML_STAR);\n      while (DATA_ENSURE_CHECK1) {\n        STACK_PUSH_ALT(p, s, sprev);\n        n = enclen(encode, s);\n        if (n > 1) {\n          DATA_ENSURE(n);\n          sprev = s;\n          s += n;\n        }\n        else {\n          sprev = s;\n          s++;\n        }\n      }\n      MOP_OUT;\n      break;\n\n    case OP_ANYCHAR_STAR_PEEK_NEXT:  MOP_IN(OP_ANYCHAR_STAR_PEEK_NEXT);\n      while (DATA_ENSURE_CHECK1) {\n        if (*p == *s) {\n          STACK_PUSH_ALT(p + 1, s, sprev);\n        }\n        n = enclen(encode, s);\n        DATA_ENSURE(n);\n        if (ONIGENC_IS_MBC_NEWLINE(encode, s, end))  goto fail;\n        sprev = s;\n        s += n;\n      }\n      p++;\n      MOP_OUT;\n      break;\n\n    case OP_ANYCHAR_ML_STAR_PEEK_NEXT:MOP_IN(OP_ANYCHAR_ML_STAR_PEEK_NEXT);\n      while (DATA_ENSURE_CHECK1) {\n        if (*p == *s) {\n          STACK_PUSH_ALT(p + 1, s, sprev);\n        }\n        n = enclen(encode, s);\n        if (n > 1) {\n          DATA_ENSURE(n);\n          sprev = s;\n          s += n;\n        }\n        else {\n          sprev = s;\n          s++;\n        }\n      }\n      p++;\n      MOP_OUT;\n      break;\n\n#ifdef USE_COMBINATION_EXPLOSION_CHECK\n    case OP_STATE_CHECK_ANYCHAR_STAR:  MOP_IN(OP_STATE_CHECK_ANYCHAR_STAR);\n      GET_STATE_CHECK_NUM_INC(mem, p);\n      while (DATA_ENSURE_CHECK1) {\n        STATE_CHECK_VAL(scv, mem);\n        if (scv) goto fail;\n\n        STACK_PUSH_ALT_WITH_STATE_CHECK(p, s, sprev, mem);\n        n = enclen(encode, s);\n        DATA_ENSURE(n);\n        if (ONIGENC_IS_MBC_NEWLINE(encode, s, end))  goto fail;\n        sprev = s;\n        s += n;\n      }\n      MOP_OUT;\n      break;\n\n    case OP_STATE_CHECK_ANYCHAR_ML_STAR:\n      MOP_IN(OP_STATE_CHECK_ANYCHAR_ML_STAR);\n\n      GET_STATE_CHECK_NUM_INC(mem, p);\n      while (DATA_ENSURE_CHECK1) {\n        STATE_CHECK_VAL(scv, mem);\n        if (scv) goto fail;\n\n        STACK_PUSH_ALT_WITH_STATE_CHECK(p, s, sprev, mem);\n        n = enclen(encode, s);\n        if (n > 1) {\n          DATA_ENSURE(n);\n          sprev = s;\n          s += n;\n        }\n        else {\n          sprev = s;\n          s++;\n        }\n      }\n      MOP_OUT;\n      break;\n#endif /* USE_COMBINATION_EXPLOSION_CHECK */\n\n    case OP_WORD:  MOP_IN(OP_WORD);\n      DATA_ENSURE(1);\n      if (! ONIGENC_IS_MBC_WORD(encode, s, end))\n        goto fail;\n\n      s += enclen(encode, s);\n      MOP_OUT;\n      break;\n\n    case OP_NOT_WORD:  MOP_IN(OP_NOT_WORD);\n      DATA_ENSURE(1);\n      if (ONIGENC_IS_MBC_WORD(encode, s, end))\n        goto fail;\n\n      s += enclen(encode, s);\n      MOP_OUT;\n      break;\n\n    case OP_WORD_BOUND:  MOP_IN(OP_WORD_BOUND);\n      if (ON_STR_BEGIN(s)) {\n        DATA_ENSURE(1);\n        if (! ONIGENC_IS_MBC_WORD(encode, s, end))\n          goto fail;\n      }\n      else if (ON_STR_END(s)) {\n        if (! ONIGENC_IS_MBC_WORD(encode, sprev, end))\n          goto fail;\n      }\n      else {\n        if (ONIGENC_IS_MBC_WORD(encode, s, end)\n            == ONIGENC_IS_MBC_WORD(encode, sprev, end))\n          goto fail;\n      }\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_NOT_WORD_BOUND:  MOP_IN(OP_NOT_WORD_BOUND);\n      if (ON_STR_BEGIN(s)) {\n        if (DATA_ENSURE_CHECK1 && ONIGENC_IS_MBC_WORD(encode, s, end))\n          goto fail;\n      }\n      else if (ON_STR_END(s)) {\n        if (ONIGENC_IS_MBC_WORD(encode, sprev, end))\n          goto fail;\n      }\n      else {\n        if (ONIGENC_IS_MBC_WORD(encode, s, end)\n            != ONIGENC_IS_MBC_WORD(encode, sprev, end))\n          goto fail;\n      }\n      MOP_OUT;\n      continue;\n      break;\n\n#ifdef USE_WORD_BEGIN_END\n    case OP_WORD_BEGIN:  MOP_IN(OP_WORD_BEGIN);\n      if (DATA_ENSURE_CHECK1 && ONIGENC_IS_MBC_WORD(encode, s, end)) {\n        if (ON_STR_BEGIN(s) || !ONIGENC_IS_MBC_WORD(encode, sprev, end)) {\n          MOP_OUT;\n          continue;\n        }\n      }\n      goto fail;\n      break;\n\n    case OP_WORD_END:  MOP_IN(OP_WORD_END);\n      if (!ON_STR_BEGIN(s) && ONIGENC_IS_MBC_WORD(encode, sprev, end)) {\n        if (ON_STR_END(s) || !ONIGENC_IS_MBC_WORD(encode, s, end)) {\n          MOP_OUT;\n          continue;\n        }\n      }\n      goto fail;\n      break;\n#endif\n\n    case OP_BEGIN_BUF:  MOP_IN(OP_BEGIN_BUF);\n      if (! ON_STR_BEGIN(s)) goto fail;\n\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_END_BUF:  MOP_IN(OP_END_BUF);\n      if (! ON_STR_END(s)) goto fail;\n\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_BEGIN_LINE:  MOP_IN(OP_BEGIN_LINE);\n      if (ON_STR_BEGIN(s)) {\n        if (IS_NOTBOL(msa->options)) goto fail;\n        MOP_OUT;\n        continue;\n      }\n      else if (ONIGENC_IS_MBC_NEWLINE(encode, sprev, end) && !ON_STR_END(s)) {\n        MOP_OUT;\n        continue;\n      }\n      goto fail;\n      break;\n\n    case OP_END_LINE:  MOP_IN(OP_END_LINE);\n      if (ON_STR_END(s)) {\n#ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE\n        if (IS_EMPTY_STR || !ONIGENC_IS_MBC_NEWLINE(encode, sprev, end)) {\n#endif\n          if (IS_NOTEOL(msa->options)) goto fail;\n          MOP_OUT;\n          continue;\n#ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE\n        }\n#endif\n      }\n      else if (ONIGENC_IS_MBC_NEWLINE(encode, s, end)) {\n        MOP_OUT;\n        continue;\n      }\n#ifdef USE_CRNL_AS_LINE_TERMINATOR\n      else if (ONIGENC_IS_MBC_CRNL(encode, s, end)) {\n        MOP_OUT;\n        continue;\n      }\n#endif\n      goto fail;\n      break;\n\n    case OP_SEMI_END_BUF:  MOP_IN(OP_SEMI_END_BUF);\n      if (ON_STR_END(s)) {\n#ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE\n        if (IS_EMPTY_STR || !ONIGENC_IS_MBC_NEWLINE(encode, sprev, end)) {\n#endif\n          if (IS_NOTEOL(msa->options)) goto fail;\n          MOP_OUT;\n          continue;\n#ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE\n        }\n#endif\n      }\n      else if (ONIGENC_IS_MBC_NEWLINE(encode, s, end) &&\n               ON_STR_END(s + enclen(encode, s))) {\n        MOP_OUT;\n        continue;\n      }\n#ifdef USE_CRNL_AS_LINE_TERMINATOR\n      else if (ONIGENC_IS_MBC_CRNL(encode, s, end)) {\n        UChar* ss = s + enclen(encode, s);\n        ss += enclen(encode, ss);\n        if (ON_STR_END(ss)) {\n          MOP_OUT;\n          continue;\n        }\n      }\n#endif\n      goto fail;\n      break;\n\n    case OP_BEGIN_POSITION:  MOP_IN(OP_BEGIN_POSITION);\n      if (s != msa->start)\n        goto fail;\n\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_MEMORY_START_PUSH:  MOP_IN(OP_MEMORY_START_PUSH);\n      GET_MEMNUM_INC(mem, p);\n      STACK_PUSH_MEM_START(mem, s);\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_MEMORY_START:  MOP_IN(OP_MEMORY_START);\n      GET_MEMNUM_INC(mem, p);\n      mem_start_stk[mem] = (OnigStackIndex )((void* )s);\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_MEMORY_END_PUSH:  MOP_IN(OP_MEMORY_END_PUSH);\n      GET_MEMNUM_INC(mem, p);\n      STACK_PUSH_MEM_END(mem, s);\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_MEMORY_END:  MOP_IN(OP_MEMORY_END);\n      GET_MEMNUM_INC(mem, p);\n      mem_end_stk[mem] = (OnigStackIndex )((void* )s);\n      MOP_OUT;\n      continue;\n      break;\n\n#ifdef USE_SUBEXP_CALL\n    case OP_MEMORY_END_PUSH_REC:  MOP_IN(OP_MEMORY_END_PUSH_REC);\n      GET_MEMNUM_INC(mem, p);\n      STACK_GET_MEM_START(mem, stkp); /* should be before push mem-end. */\n      STACK_PUSH_MEM_END(mem, s);\n      mem_start_stk[mem] = GET_STACK_INDEX(stkp);\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_MEMORY_END_REC:  MOP_IN(OP_MEMORY_END_REC);\n      GET_MEMNUM_INC(mem, p);\n      mem_end_stk[mem] = (OnigStackIndex )((void* )s);\n      STACK_GET_MEM_START(mem, stkp);\n\n      if (BIT_STATUS_AT(reg->bt_mem_start, mem))\n        mem_start_stk[mem] = GET_STACK_INDEX(stkp);\n      else\n        mem_start_stk[mem] = (OnigStackIndex )((void* )stkp->u.mem.pstr);\n\n      STACK_PUSH_MEM_END_MARK(mem);\n      MOP_OUT;\n      continue;\n      break;\n#endif\n\n    case OP_BACKREF1:  MOP_IN(OP_BACKREF1);\n      mem = 1;\n      goto backref;\n      break;\n\n    case OP_BACKREF2:  MOP_IN(OP_BACKREF2);\n      mem = 2;\n      goto backref;\n      break;\n\n    case OP_BACKREFN:  MOP_IN(OP_BACKREFN);\n      GET_MEMNUM_INC(mem, p);\n    backref:\n      {\n        int len;\n        UChar *pstart, *pend;\n\n        /* if you want to remove following line, \n           you should check in parse and compile time. */\n        if (mem > num_mem) goto fail;\n        if (mem_end_stk[mem]   == INVALID_STACK_INDEX) goto fail;\n        if (mem_start_stk[mem] == INVALID_STACK_INDEX) goto fail;\n\n        if (BIT_STATUS_AT(reg->bt_mem_start, mem))\n          pstart = STACK_AT(mem_start_stk[mem])->u.mem.pstr;\n        else\n          pstart = (UChar* )((void* )mem_start_stk[mem]);\n\n        pend = (BIT_STATUS_AT(reg->bt_mem_end, mem)\n                ? STACK_AT(mem_end_stk[mem])->u.mem.pstr\n                : (UChar* )((void* )mem_end_stk[mem]));\n        n = pend - pstart;\n        DATA_ENSURE(n);\n        sprev = s;\n        STRING_CMP(pstart, s, n);\n        while (sprev + (len = enclen(encode, sprev)) < s)\n          sprev += len;\n\n        MOP_OUT;\n        continue;\n      }\n      break;\n\n    case OP_BACKREFN_IC:  MOP_IN(OP_BACKREFN_IC);\n      GET_MEMNUM_INC(mem, p);\n      {\n        int len;\n        UChar *pstart, *pend;\n\n        /* if you want to remove following line, \n           you should check in parse and compile time. */\n        if (mem > num_mem) goto fail;\n        if (mem_end_stk[mem]   == INVALID_STACK_INDEX) goto fail;\n        if (mem_start_stk[mem] == INVALID_STACK_INDEX) goto fail;\n\n        if (BIT_STATUS_AT(reg->bt_mem_start, mem))\n          pstart = STACK_AT(mem_start_stk[mem])->u.mem.pstr;\n        else\n          pstart = (UChar* )((void* )mem_start_stk[mem]);\n\n        pend = (BIT_STATUS_AT(reg->bt_mem_end, mem)\n                ? STACK_AT(mem_end_stk[mem])->u.mem.pstr\n                : (UChar* )((void* )mem_end_stk[mem]));\n        n = pend - pstart;\n        DATA_ENSURE(n);\n        sprev = s;\n        STRING_CMP_IC(case_fold_flag, pstart, &s, n);\n        while (sprev + (len = enclen(encode, sprev)) < s)\n          sprev += len;\n\n        MOP_OUT;\n        continue;\n      }\n      break;\n\n    case OP_BACKREF_MULTI:  MOP_IN(OP_BACKREF_MULTI);\n      {\n        int len, is_fail;\n        UChar *pstart, *pend, *swork;\n\n        GET_LENGTH_INC(tlen, p);\n        for (i = 0; i < tlen; i++) {\n          GET_MEMNUM_INC(mem, p);\n\n          if (mem_end_stk[mem]   == INVALID_STACK_INDEX) continue;\n          if (mem_start_stk[mem] == INVALID_STACK_INDEX) continue;\n\n          if (BIT_STATUS_AT(reg->bt_mem_start, mem))\n            pstart = STACK_AT(mem_start_stk[mem])->u.mem.pstr;\n          else\n            pstart = (UChar* )((void* )mem_start_stk[mem]);\n\n          pend = (BIT_STATUS_AT(reg->bt_mem_end, mem)\n                  ? STACK_AT(mem_end_stk[mem])->u.mem.pstr\n                  : (UChar* )((void* )mem_end_stk[mem]));\n          n = pend - pstart;\n          DATA_ENSURE(n);\n          sprev = s;\n          swork = s;\n          STRING_CMP_VALUE(pstart, swork, n, is_fail);\n          if (is_fail) continue;\n          s = swork;\n          while (sprev + (len = enclen(encode, sprev)) < s)\n            sprev += len;\n\n          p += (SIZE_MEMNUM * (tlen - i - 1));\n          break; /* success */\n        }\n        if (i == tlen) goto fail;\n        MOP_OUT;\n        continue;\n      }\n      break;\n\n    case OP_BACKREF_MULTI_IC:  MOP_IN(OP_BACKREF_MULTI_IC);\n      {\n        int len, is_fail;\n        UChar *pstart, *pend, *swork;\n\n        GET_LENGTH_INC(tlen, p);\n        for (i = 0; i < tlen; i++) {\n          GET_MEMNUM_INC(mem, p);\n\n          if (mem_end_stk[mem]   == INVALID_STACK_INDEX) continue;\n          if (mem_start_stk[mem] == INVALID_STACK_INDEX) continue;\n\n          if (BIT_STATUS_AT(reg->bt_mem_start, mem))\n            pstart = STACK_AT(mem_start_stk[mem])->u.mem.pstr;\n          else\n            pstart = (UChar* )((void* )mem_start_stk[mem]);\n\n          pend = (BIT_STATUS_AT(reg->bt_mem_end, mem)\n                  ? STACK_AT(mem_end_stk[mem])->u.mem.pstr\n                  : (UChar* )((void* )mem_end_stk[mem]));\n          n = pend - pstart;\n          DATA_ENSURE(n);\n          sprev = s;\n          swork = s;\n          STRING_CMP_VALUE_IC(case_fold_flag, pstart, &swork, n, is_fail);\n          if (is_fail) continue;\n          s = swork;\n          while (sprev + (len = enclen(encode, sprev)) < s)\n            sprev += len;\n\n          p += (SIZE_MEMNUM * (tlen - i - 1));\n          break; /* success */\n        }\n        if (i == tlen) goto fail;\n        MOP_OUT;\n        continue;\n      }\n      break;\n\n#ifdef USE_BACKREF_WITH_LEVEL\n    case OP_BACKREF_WITH_LEVEL:\n      {\n        int len;\n        OnigOptionType ic;\n        LengthType level;\n\n        GET_OPTION_INC(ic,    p);\n        GET_LENGTH_INC(level, p);\n        GET_LENGTH_INC(tlen,  p);\n\n        sprev = s;\n        if (backref_match_at_nested_level(reg, stk, stk_base, ic\n                     , case_fold_flag, (int )level, (int )tlen, p, &s, end)) {\n          while (sprev + (len = enclen(encode, sprev)) < s)\n            sprev += len;\n\n          p += (SIZE_MEMNUM * tlen);\n        }\n        else\n          goto fail;\n\n        MOP_OUT;\n        continue;\n      }\n      break;\n#endif\n\n#if 0   /* no need: IS_DYNAMIC_OPTION() == 0 */\n    case OP_SET_OPTION_PUSH:  MOP_IN(OP_SET_OPTION_PUSH);\n      GET_OPTION_INC(option, p);\n      STACK_PUSH_ALT(p, s, sprev);\n      p += SIZE_OP_SET_OPTION + SIZE_OP_FAIL;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_SET_OPTION:  MOP_IN(OP_SET_OPTION);\n      GET_OPTION_INC(option, p);\n      MOP_OUT;\n      continue;\n      break;\n#endif\n\n    case OP_NULL_CHECK_START:  MOP_IN(OP_NULL_CHECK_START);\n      GET_MEMNUM_INC(mem, p);    /* mem: null check id */\n      STACK_PUSH_NULL_CHECK_START(mem, s);\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_NULL_CHECK_END:  MOP_IN(OP_NULL_CHECK_END);\n      {\n        int isnull;\n\n        GET_MEMNUM_INC(mem, p); /* mem: null check id */\n        STACK_NULL_CHECK(isnull, mem, s);\n        if (isnull) {\n#ifdef ONIG_DEBUG_MATCH\n          fprintf(stderr, \"NULL_CHECK_END: skip  id:%d, s:%d\\n\",\n                  (int )mem, (int )s);\n#endif\n        null_check_found:\n          /* empty loop founded, skip next instruction */\n          switch (*p++) {\n          case OP_JUMP:\n          case OP_PUSH:\n            p += SIZE_RELADDR;\n            break;\n          case OP_REPEAT_INC:\n          case OP_REPEAT_INC_NG:\n          case OP_REPEAT_INC_SG:\n          case OP_REPEAT_INC_NG_SG:\n            p += SIZE_MEMNUM;\n            break;\n          default:\n            goto unexpected_bytecode_error;\n            break;\n          }\n        }\n      }\n      MOP_OUT;\n      continue;\n      break;\n\n#ifdef USE_MONOMANIAC_CHECK_CAPTURES_IN_ENDLESS_REPEAT\n    case OP_NULL_CHECK_END_MEMST:  MOP_IN(OP_NULL_CHECK_END_MEMST);\n      {\n        int isnull;\n\n        GET_MEMNUM_INC(mem, p); /* mem: null check id */\n        STACK_NULL_CHECK_MEMST(isnull, mem, s, reg);\n        if (isnull) {\n#ifdef ONIG_DEBUG_MATCH\n          fprintf(stderr, \"NULL_CHECK_END_MEMST: skip  id:%d, s:%d\\n\",\n                  (int )mem, (int )s);\n#endif\n          if (isnull == -1) goto fail;\n          goto \tnull_check_found;\n        }\n      }\n      MOP_OUT;\n      continue;\n      break;\n#endif\n\n#ifdef USE_SUBEXP_CALL\n    case OP_NULL_CHECK_END_MEMST_PUSH:\n      MOP_IN(OP_NULL_CHECK_END_MEMST_PUSH);\n      {\n        int isnull;\n\n        GET_MEMNUM_INC(mem, p); /* mem: null check id */\n#ifdef USE_MONOMANIAC_CHECK_CAPTURES_IN_ENDLESS_REPEAT\n        STACK_NULL_CHECK_MEMST_REC(isnull, mem, s, reg);\n#else\n        STACK_NULL_CHECK_REC(isnull, mem, s);\n#endif\n        if (isnull) {\n#ifdef ONIG_DEBUG_MATCH\n          fprintf(stderr, \"NULL_CHECK_END_MEMST_PUSH: skip  id:%d, s:%d\\n\",\n                  (int )mem, (int )s);\n#endif\n          if (isnull == -1) goto fail;\n          goto \tnull_check_found;\n        }\n        else {\n          STACK_PUSH_NULL_CHECK_END(mem);\n        }\n      }\n      MOP_OUT;\n      continue;\n      break;\n#endif\n\n    case OP_JUMP:  MOP_IN(OP_JUMP);\n      GET_RELADDR_INC(addr, p);\n      p += addr;\n      MOP_OUT;\n      CHECK_INTERRUPT_IN_MATCH_AT;\n      continue;\n      break;\n\n    case OP_PUSH:  MOP_IN(OP_PUSH);\n      GET_RELADDR_INC(addr, p);\n      STACK_PUSH_ALT(p + addr, s, sprev);\n      MOP_OUT;\n      continue;\n      break;\n\n#ifdef USE_COMBINATION_EXPLOSION_CHECK\n    case OP_STATE_CHECK_PUSH:  MOP_IN(OP_STATE_CHECK_PUSH);\n      GET_STATE_CHECK_NUM_INC(mem, p);\n      STATE_CHECK_VAL(scv, mem);\n      if (scv) goto fail;\n\n      GET_RELADDR_INC(addr, p);\n      STACK_PUSH_ALT_WITH_STATE_CHECK(p + addr, s, sprev, mem);\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_STATE_CHECK_PUSH_OR_JUMP:  MOP_IN(OP_STATE_CHECK_PUSH_OR_JUMP);\n      GET_STATE_CHECK_NUM_INC(mem, p);\n      GET_RELADDR_INC(addr, p);\n      STATE_CHECK_VAL(scv, mem);\n      if (scv) {\n        p += addr;\n      }\n      else {\n        STACK_PUSH_ALT_WITH_STATE_CHECK(p + addr, s, sprev, mem);\n      }\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_STATE_CHECK:  MOP_IN(OP_STATE_CHECK);\n      GET_STATE_CHECK_NUM_INC(mem, p);\n      STATE_CHECK_VAL(scv, mem);\n      if (scv) goto fail;\n\n      STACK_PUSH_STATE_CHECK(s, mem);\n      MOP_OUT;\n      continue;\n      break;\n#endif /* USE_COMBINATION_EXPLOSION_CHECK */\n\n    case OP_POP:  MOP_IN(OP_POP);\n      STACK_POP_ONE;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_PUSH_OR_JUMP_EXACT1:  MOP_IN(OP_PUSH_OR_JUMP_EXACT1);\n      GET_RELADDR_INC(addr, p);\n      if (*p == *s && DATA_ENSURE_CHECK1) {\n        p++;\n        STACK_PUSH_ALT(p + addr, s, sprev);\n        MOP_OUT;\n        continue;\n      }\n      p += (addr + 1);\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_PUSH_IF_PEEK_NEXT:  MOP_IN(OP_PUSH_IF_PEEK_NEXT);\n      GET_RELADDR_INC(addr, p);\n      if (*p == *s) {\n        p++;\n        STACK_PUSH_ALT(p + addr, s, sprev);\n        MOP_OUT;\n        continue;\n      }\n      p++;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_REPEAT:  MOP_IN(OP_REPEAT);\n      {\n        GET_MEMNUM_INC(mem, p);    /* mem: OP_REPEAT ID */\n        GET_RELADDR_INC(addr, p);\n\n        STACK_ENSURE(1);\n        repeat_stk[mem] = GET_STACK_INDEX(stk);\n        STACK_PUSH_REPEAT(mem, p);\n\n        if (reg->repeat_range[mem].lower == 0) {\n          STACK_PUSH_ALT(p + addr, s, sprev);\n        }\n      }\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_REPEAT_NG:  MOP_IN(OP_REPEAT_NG);\n      {\n        GET_MEMNUM_INC(mem, p);    /* mem: OP_REPEAT ID */\n        GET_RELADDR_INC(addr, p);\n\n        STACK_ENSURE(1);\n        repeat_stk[mem] = GET_STACK_INDEX(stk);\n        STACK_PUSH_REPEAT(mem, p);\n\n        if (reg->repeat_range[mem].lower == 0) {\n          STACK_PUSH_ALT(p, s, sprev);\n          p += addr;\n        }\n      }\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_REPEAT_INC:  MOP_IN(OP_REPEAT_INC);\n      GET_MEMNUM_INC(mem, p); /* mem: OP_REPEAT ID */\n      si = repeat_stk[mem];\n      stkp = STACK_AT(si);\n\n    repeat_inc:\n      stkp->u.repeat.count++;\n      if (stkp->u.repeat.count >= reg->repeat_range[mem].upper) {\n        /* end of repeat. Nothing to do. */\n      }\n      else if (stkp->u.repeat.count >= reg->repeat_range[mem].lower) {\n        STACK_PUSH_ALT(p, s, sprev);\n        p = STACK_AT(si)->u.repeat.pcode; /* Don't use stkp after PUSH. */\n      }\n      else {\n        p = stkp->u.repeat.pcode;\n      }\n      STACK_PUSH_REPEAT_INC(si);\n      MOP_OUT;\n      CHECK_INTERRUPT_IN_MATCH_AT;\n      continue;\n      break;\n\n    case OP_REPEAT_INC_SG:  MOP_IN(OP_REPEAT_INC_SG);\n      GET_MEMNUM_INC(mem, p); /* mem: OP_REPEAT ID */\n      STACK_GET_REPEAT(mem, stkp);\n      si = GET_STACK_INDEX(stkp);\n      goto repeat_inc;\n      break;\n\n    case OP_REPEAT_INC_NG:  MOP_IN(OP_REPEAT_INC_NG);\n      GET_MEMNUM_INC(mem, p); /* mem: OP_REPEAT ID */\n      si = repeat_stk[mem];\n      stkp = STACK_AT(si);\n\n    repeat_inc_ng:\n      stkp->u.repeat.count++;\n      if (stkp->u.repeat.count < reg->repeat_range[mem].upper) {\n        if (stkp->u.repeat.count >= reg->repeat_range[mem].lower) {\n          UChar* pcode = stkp->u.repeat.pcode;\n\n          STACK_PUSH_REPEAT_INC(si);\n          STACK_PUSH_ALT(pcode, s, sprev);\n        }\n        else {\n          p = stkp->u.repeat.pcode;\n          STACK_PUSH_REPEAT_INC(si);\n        }\n      }\n      else if (stkp->u.repeat.count == reg->repeat_range[mem].upper) {\n        STACK_PUSH_REPEAT_INC(si);\n      }\n      MOP_OUT;\n      CHECK_INTERRUPT_IN_MATCH_AT;\n      continue;\n      break;\n\n    case OP_REPEAT_INC_NG_SG:  MOP_IN(OP_REPEAT_INC_NG_SG);\n      GET_MEMNUM_INC(mem, p); /* mem: OP_REPEAT ID */\n      STACK_GET_REPEAT(mem, stkp);\n      si = GET_STACK_INDEX(stkp);\n      goto repeat_inc_ng;\n      break;\n\n    case OP_PUSH_POS:  MOP_IN(OP_PUSH_POS);\n      STACK_PUSH_POS(s, sprev);\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_POP_POS:  MOP_IN(OP_POP_POS);\n      {\n        STACK_POS_END(stkp);\n        s     = stkp->u.state.pstr;\n        sprev = stkp->u.state.pstr_prev;\n      }\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_PUSH_POS_NOT:  MOP_IN(OP_PUSH_POS_NOT);\n      GET_RELADDR_INC(addr, p);\n      STACK_PUSH_POS_NOT(p + addr, s, sprev);\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_FAIL_POS:  MOP_IN(OP_FAIL_POS);\n      STACK_POP_TIL_POS_NOT;\n      goto fail;\n      break;\n\n    case OP_PUSH_STOP_BT:  MOP_IN(OP_PUSH_STOP_BT);\n      STACK_PUSH_STOP_BT;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_POP_STOP_BT:  MOP_IN(OP_POP_STOP_BT);\n      STACK_STOP_BT_END;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_LOOK_BEHIND:  MOP_IN(OP_LOOK_BEHIND);\n      GET_LENGTH_INC(tlen, p);\n      s = (UChar* )ONIGENC_STEP_BACK(encode, str, s, (int )tlen);\n      if (IS_NULL(s)) goto fail;\n      sprev = (UChar* )onigenc_get_prev_char_head(encode, str, s);\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_PUSH_LOOK_BEHIND_NOT:  MOP_IN(OP_PUSH_LOOK_BEHIND_NOT);\n      GET_RELADDR_INC(addr, p);\n      GET_LENGTH_INC(tlen, p);\n      q = (UChar* )ONIGENC_STEP_BACK(encode, str, s, (int )tlen);\n      if (IS_NULL(q)) {\n        /* too short case -> success. ex. /(?<!XXX)a/.match(\"a\")\n           If you want to change to fail, replace following line. */\n        p += addr;\n        /* goto fail; */\n      }\n      else {\n        STACK_PUSH_LOOK_BEHIND_NOT(p + addr, s, sprev);\n        s = q;\n        sprev = (UChar* )onigenc_get_prev_char_head(encode, str, s);\n      }\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_FAIL_LOOK_BEHIND_NOT:  MOP_IN(OP_FAIL_LOOK_BEHIND_NOT);\n      STACK_POP_TIL_LOOK_BEHIND_NOT;\n      goto fail;\n      break;\n\n#ifdef USE_SUBEXP_CALL\n    case OP_CALL:  MOP_IN(OP_CALL);\n      GET_ABSADDR_INC(addr, p);\n      STACK_PUSH_CALL_FRAME(p);\n      p = reg->p + addr;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_RETURN:  MOP_IN(OP_RETURN);\n      STACK_RETURN(p);\n      STACK_PUSH_RETURN;\n      MOP_OUT;\n      continue;\n      break;\n#endif\n\n    case OP_FINISH:\n      goto finish;\n      break;\n\n    fail:\n      MOP_OUT;\n      /* fall */\n    case OP_FAIL:  MOP_IN(OP_FAIL);\n      STACK_POP;\n      p     = stk->u.state.pcode;\n      s     = stk->u.state.pstr;\n      sprev = stk->u.state.pstr_prev;\n\n#ifdef USE_COMBINATION_EXPLOSION_CHECK\n      if (stk->u.state.state_check != 0) {\n        stk->type = STK_STATE_CHECK_MARK;\n        stk++;\n      }\n#endif\n\n      MOP_OUT;\n      continue;\n      break;\n\n    default:\n      goto bytecode_error;\n\n    } /* end of switch */\n    sprev = sbegin;\n  } /* end of while(1) */\n\n finish:\n  STACK_SAVE;\n  return best_len;\n\n#ifdef ONIG_DEBUG\n stack_error:\n  STACK_SAVE;\n  return ONIGERR_STACK_BUG;\n#endif\n\n bytecode_error:\n  STACK_SAVE;\n  return ONIGERR_UNDEFINED_BYTECODE;\n\n unexpected_bytecode_error:\n  STACK_SAVE;\n  return ONIGERR_UNEXPECTED_BYTECODE;\n}\n\n\nstatic UChar*\nslow_search(OnigEncoding enc, UChar* target, UChar* target_end,\n\t    const UChar* text, const UChar* text_end, UChar* text_range)\n{\n  UChar *t, *p, *s, *end;\n\n  end = (UChar* )text_end;\n  end -= target_end - target - 1;\n  if (end > text_range)\n    end = text_range;\n\n  s = (UChar* )text;\n\n  while (s < end) {\n    if (*s == *target) {\n      p = s + 1;\n      t = target + 1;\n      while (t < target_end) {\n        if (*t != *p++)\n          break;\n        t++;\n      }\n      if (t == target_end)\n        return s;\n    }\n    s += enclen(enc, s);\n  }\n\n  return (UChar* )NULL;\n}\n\nstatic int\nstr_lower_case_match(OnigEncoding enc, int case_fold_flag,\n                     const UChar* t, const UChar* tend,\n\t\t     const UChar* p, const UChar* end)\n{\n  int lowlen;\n  UChar *q, lowbuf[ONIGENC_MBC_CASE_FOLD_MAXLEN];\n\n  while (t < tend) {\n    lowlen = ONIGENC_MBC_CASE_FOLD(enc, case_fold_flag, &p, end, lowbuf);\n    q = lowbuf;\n    while (lowlen > 0) {\n      if (*t++ != *q++)\treturn 0;\n      lowlen--;\n    }\n  }\n\n  return 1;\n}\n\nstatic UChar*\nslow_search_ic(OnigEncoding enc, int case_fold_flag,\n\t       UChar* target, UChar* target_end,\n\t       const UChar* text, const UChar* text_end, UChar* text_range)\n{\n  UChar *s, *end;\n\n  end = (UChar* )text_end;\n  end -= target_end - target - 1;\n  if (end > text_range)\n    end = text_range;\n\n  s = (UChar* )text;\n\n  while (s < end) {\n    if (str_lower_case_match(enc, case_fold_flag, target, target_end,\n\t\t\t     s, text_end))\n      return s;\n\n    s += enclen(enc, s);\n  }\n\n  return (UChar* )NULL;\n}\n\nstatic UChar*\nslow_search_backward(OnigEncoding enc, UChar* target, UChar* target_end,\n\t\t     const UChar* text, const UChar* adjust_text,\n\t\t     const UChar* text_end, const UChar* text_start)\n{\n  UChar *t, *p, *s;\n\n  s = (UChar* )text_end;\n  s -= (target_end - target);\n  if (s > text_start)\n    s = (UChar* )text_start;\n  else\n    s = ONIGENC_LEFT_ADJUST_CHAR_HEAD(enc, adjust_text, s);\n\n  while (s >= text) {\n    if (*s == *target) {\n      p = s + 1;\n      t = target + 1;\n      while (t < target_end) {\n        if (*t != *p++)\n          break;\n        t++;\n      }\n      if (t == target_end)\n        return s;\n    }\n    s = (UChar* )onigenc_get_prev_char_head(enc, adjust_text, s);\n  }\n\n  return (UChar* )NULL;\n}\n\nstatic UChar*\nslow_search_backward_ic(OnigEncoding enc, int case_fold_flag,\n\t\t\tUChar* target, UChar* target_end,\n\t\t\tconst UChar* text, const UChar* adjust_text,\n\t\t\tconst UChar* text_end, const UChar* text_start)\n{\n  UChar *s;\n\n  s = (UChar* )text_end;\n  s -= (target_end - target);\n  if (s > text_start)\n    s = (UChar* )text_start;\n  else\n    s = ONIGENC_LEFT_ADJUST_CHAR_HEAD(enc, adjust_text, s);\n\n  while (s >= text) {\n    if (str_lower_case_match(enc, case_fold_flag,\n                             target, target_end, s, text_end))\n      return s;\n\n    s = (UChar* )onigenc_get_prev_char_head(enc, adjust_text, s);\n  }\n\n  return (UChar* )NULL;\n}\n\nstatic UChar*\nbm_search_notrev(regex_t* reg, const UChar* target, const UChar* target_end,\n\t\t const UChar* text, const UChar* text_end,\n\t\t const UChar* text_range)\n{\n  const UChar *s, *se, *t, *p, *end;\n  const UChar *tail;\n  int skip, tlen1;\n\n#ifdef ONIG_DEBUG_SEARCH\n  fprintf(stderr, \"bm_search_notrev: text: %d, text_end: %d, text_range: %d\\n\",\n\t  (int )text, (int )text_end, (int )text_range);\n#endif\n\n  tail = target_end - 1;\n  tlen1 = tail - target;\n  end = text_range;\n  if (end + tlen1 > text_end)\n    end = text_end - tlen1;\n\n  s = text;\n\n  if (IS_NULL(reg->int_map)) {\n    while (s < end) {\n      p = se = s + tlen1;\n      t = tail;\n      while (*p == *t) {\n        if (t == target) return (UChar* )s;\n        p--; t--;\n      }\n      skip = reg->map[*se];\n      t = s;\n      do {\n        s += enclen(reg->enc, s);\n      } while ((s - t) < skip && s < end);\n    }\n  }\n  else {\n    while (s < end) {\n      p = se = s + tlen1;\n      t = tail;\n      while (*p == *t) {\n        if (t == target) return (UChar* )s;\n        p--; t--;\n      }\n      skip = reg->int_map[*se];\n      t = s;\n      do {\n        s += enclen(reg->enc, s);\n      } while ((s - t) < skip && s < end);\n    }\n  }\n\n  return (UChar* )NULL;\n}\n\nstatic UChar*\nbm_search(regex_t* reg, const UChar* target, const UChar* target_end,\n\t  const UChar* text, const UChar* text_end, const UChar* text_range)\n{\n  const UChar *s, *t, *p, *end;\n  const UChar *tail;\n\n  end = text_range + (target_end - target) - 1;\n  if (end > text_end)\n    end = text_end;\n\n  tail = target_end - 1;\n  s = text + (target_end - target) - 1;\n  if (IS_NULL(reg->int_map)) {\n    while (s < end) {\n      p = s;\n      t = tail;\n      while (*p == *t) {\n        if (t == target) return (UChar* )p;\n        p--; t--;\n      }\n      s += reg->map[*s];\n    }\n  }\n  else { /* see int_map[] */\n    while (s < end) {\n      p = s;\n      t = tail;\n      while (*p == *t) {\n        if (t == target) return (UChar* )p;\n        p--; t--;\n      }\n      s += reg->int_map[*s];\n    }\n  }\n  return (UChar* )NULL;\n}\n\n#ifdef USE_INT_MAP_BACKWARD\nstatic int\nset_bm_backward_skip(UChar* s, UChar* end, OnigEncoding enc ARG_UNUSED,\n\t\t     int** skip)\n\t\t     \n{\n  int i, len;\n\n  if (IS_NULL(*skip)) {\n    *skip = (int* )xmalloc(sizeof(int) * ONIG_CHAR_TABLE_SIZE);\n    if (IS_NULL(*skip)) return ONIGERR_MEMORY;\n  }\n\n  len = end - s;\n  for (i = 0; i < ONIG_CHAR_TABLE_SIZE; i++)\n    (*skip)[i] = len;\n\n  for (i = len - 1; i > 0; i--)\n    (*skip)[s[i]] = i;\n\n  return 0;\n}\n\nstatic UChar*\nbm_search_backward(regex_t* reg, const UChar* target, const UChar* target_end,\n\t\t   const UChar* text, const UChar* adjust_text,\n\t\t   const UChar* text_end, const UChar* text_start)\n{\n  const UChar *s, *t, *p;\n\n  s = text_end - (target_end - target);\n  if (text_start < s)\n    s = text_start;\n  else\n    s = ONIGENC_LEFT_ADJUST_CHAR_HEAD(reg->enc, adjust_text, s);\n\n  while (s >= text) {\n    p = s;\n    t = target;\n    while (t < target_end && *p == *t) {\n      p++; t++;\n    }\n    if (t == target_end)\n      return (UChar* )s;\n\n    s -= reg->int_map_backward[*s];\n    s = ONIGENC_LEFT_ADJUST_CHAR_HEAD(reg->enc, adjust_text, s);\n  }\n\n  return (UChar* )NULL;\n}\n#endif\n\nstatic UChar*\nmap_search(OnigEncoding enc, UChar map[],\n\t   const UChar* text, const UChar* text_range)\n{\n  const UChar *s = text;\n\n  while (s < text_range) {\n    if (map[*s]) return (UChar* )s;\n\n    s += enclen(enc, s);\n  }\n  return (UChar* )NULL;\n}\n\nstatic UChar*\nmap_search_backward(OnigEncoding enc, UChar map[],\n\t\t    const UChar* text, const UChar* adjust_text,\n\t\t    const UChar* text_start)\n{\n  const UChar *s = text_start;\n\n  while (s >= text) {\n    if (map[*s]) return (UChar* )s;\n\n    s = onigenc_get_prev_char_head(enc, adjust_text, s);\n  }\n  return (UChar* )NULL;\n}\n\nextern int\nonig_match(regex_t* reg, const UChar* str, const UChar* end, const UChar* at, OnigRegion* region,\n\t    OnigOptionType option)\n{\n  int r;\n  UChar *prev;\n  OnigMatchArg msa;\n\n  MATCH_ARG_INIT(msa, reg, option, region, at);\n#ifdef USE_COMBINATION_EXPLOSION_CHECK\n  {\n    int offset = at - str;\n    STATE_CHECK_BUFF_INIT(msa, end - str, offset, reg->num_comb_exp_check);\n  }\n#endif\n\n  if (region\n#ifdef USE_POSIX_API_REGION_OPTION\n      && !IS_POSIX_REGION(option)\n#endif\n      ) {\n    r = onig_region_resize_clear(region, reg->num_mem + 1);\n  }\n  else\n    r = 0;\n\n  if (r == 0) {\n    if (ONIG_IS_OPTION_ON(option, ONIG_OPTION_CHECK_VALIDITY_OF_STRING)) {\n      if (! ONIGENC_IS_VALID_MBC_STRING(reg->enc, str, end)) {\n        r = ONIGERR_INVALID_WIDE_CHAR_VALUE;\n        goto end;\n      }\n    }\n\n    prev = (UChar* )onigenc_get_prev_char_head(reg->enc, str, at);\n    r = match_at(reg, str, end,\n#ifdef USE_MATCH_RANGE_MUST_BE_INSIDE_OF_SPECIFIED_RANGE\n\t\t end,\n#endif\n\t\t at, prev, &msa);\n  }\n\n end:\n  MATCH_ARG_FREE(msa);\n  return r;\n}\n\nstatic int\nforward_search_range(regex_t* reg, const UChar* str, const UChar* end, UChar* s,\n\t\t     UChar* range, UChar** low, UChar** high, UChar** low_prev)\n{\n  UChar *p, *pprev = (UChar* )NULL;\n\n#ifdef ONIG_DEBUG_SEARCH\n  fprintf(stderr, \"forward_search_range: str: %d, end: %d, s: %d, range: %d\\n\",\n\t  (int )str, (int )end, (int )s, (int )range);\n#endif\n\n  p = s;\n  if (reg->dmin > 0) {\n    if (ONIGENC_IS_SINGLEBYTE(reg->enc)) {\n      p += reg->dmin;\n    }\n    else {\n      UChar *q = p + reg->dmin;\n\n      if (q >= end) return 0; /* fail */\n      while (p < q) p += enclen(reg->enc, p);\n    }\n  }\n\n retry:\n  switch (reg->optimize) {\n  case ONIG_OPTIMIZE_EXACT:\n    p = slow_search(reg->enc, reg->exact, reg->exact_end, p, end, range);\n    break;\n  case ONIG_OPTIMIZE_EXACT_IC:\n    p = slow_search_ic(reg->enc, reg->case_fold_flag,\n                       reg->exact, reg->exact_end, p, end, range);\n    break;\n\n  case ONIG_OPTIMIZE_EXACT_BM:\n    p = bm_search(reg, reg->exact, reg->exact_end, p, end, range);\n    break;\n\n  case ONIG_OPTIMIZE_EXACT_BM_NOT_REV:\n    p = bm_search_notrev(reg, reg->exact, reg->exact_end, p, end, range);\n    break;\n\n  case ONIG_OPTIMIZE_MAP:\n    p = map_search(reg->enc, reg->map, p, range);\n    break;\n  }\n\n  if (p && p < range) {\n    if (p - reg->dmin < s) {\n    retry_gate:\n      pprev = p;\n      p += enclen(reg->enc, p);\n      goto retry;\n    }\n\n    if (reg->sub_anchor) {\n      UChar* prev;\n\n      switch (reg->sub_anchor) {\n      case ANCHOR_BEGIN_LINE:\n        if (!ON_STR_BEGIN(p)) {\n          prev = onigenc_get_prev_char_head(reg->enc,\n                                            (pprev ? pprev : str), p);\n          if (!ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end))\n            goto retry_gate;\n        }\n        break;\n\n      case ANCHOR_END_LINE:\n        if (ON_STR_END(p)) {\n#ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE\n          prev = (UChar* )onigenc_get_prev_char_head(reg->enc,\n                                                     (pprev ? pprev : str), p);\n          if (prev && ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end))\n            goto retry_gate;\n#endif\n        }\n        else if (! ONIGENC_IS_MBC_NEWLINE(reg->enc, p, end)\n#ifdef USE_CRNL_AS_LINE_TERMINATOR\n                 && ! ONIGENC_IS_MBC_CRNL(reg->enc, p, end)\n#endif\n                 )\n          goto retry_gate;\n        break;\n      }\n    }\n\n    if (reg->dmax == 0) {\n      *low = p;\n      if (low_prev) {\n        if (*low > s)\n          *low_prev = onigenc_get_prev_char_head(reg->enc, s, p);\n        else\n          *low_prev = onigenc_get_prev_char_head(reg->enc,\n                                                 (pprev ? pprev : str), p);\n      }\n    }\n    else {\n      if (reg->dmax != ONIG_INFINITE_DISTANCE) {\n        *low = p - reg->dmax;\n        if (*low > s) {\n          *low = onigenc_get_right_adjust_char_head_with_prev(reg->enc, s,\n                                          *low, (const UChar** )low_prev);\n          if (low_prev && IS_NULL(*low_prev))\n            *low_prev = onigenc_get_prev_char_head(reg->enc,\n                                                   (pprev ? pprev : s), *low);\n        }\n        else {\n          if (low_prev)\n            *low_prev = onigenc_get_prev_char_head(reg->enc,\n                                                   (pprev ? pprev : str), *low);\n        }\n      }\n    }\n    /* no needs to adjust *high, *high is used as range check only */\n    *high = p - reg->dmin;\n\n#ifdef ONIG_DEBUG_SEARCH\n    fprintf(stderr,\n    \"forward_search_range success: low: %d, high: %d, dmin: %d, dmax: %d\\n\",\n\t    (int )(*low - str), (int )(*high - str), reg->dmin, reg->dmax);\n#endif\n    return 1; /* success */\n  }\n\n  return 0; /* fail */\n}\n\n\n#define BM_BACKWARD_SEARCH_LENGTH_THRESHOLD   100\n\nstatic int\nbackward_search_range(regex_t* reg, const UChar* str, const UChar* end,\n\t\t      UChar* s, const UChar* range, UChar* adjrange,\n\t\t      UChar** low, UChar** high)\n{\n  UChar *p;\n\n  range += reg->dmin;\n  p = s;\n\n retry:\n  switch (reg->optimize) {\n  case ONIG_OPTIMIZE_EXACT:\n  exact_method:\n    p = slow_search_backward(reg->enc, reg->exact, reg->exact_end,\n\t\t\t     range, adjrange, end, p);\n    break;\n\n  case ONIG_OPTIMIZE_EXACT_IC:\n    p = slow_search_backward_ic(reg->enc, reg->case_fold_flag,\n                                reg->exact, reg->exact_end,\n                                range, adjrange, end, p);\n    break;\n\n  case ONIG_OPTIMIZE_EXACT_BM:\n  case ONIG_OPTIMIZE_EXACT_BM_NOT_REV:\n#ifdef USE_INT_MAP_BACKWARD\n    if (IS_NULL(reg->int_map_backward)) {\n      int r;\n\n      if (s - range < BM_BACKWARD_SEARCH_LENGTH_THRESHOLD)\n        goto exact_method;\n\n      r = set_bm_backward_skip(reg->exact, reg->exact_end, reg->enc,\n                               &(reg->int_map_backward));\n      if (r) return r;\n    }\n    p = bm_search_backward(reg, reg->exact, reg->exact_end, range, adjrange,\n                           end, p);\n#else\n    goto exact_method;\n#endif\n    break;\n\n  case ONIG_OPTIMIZE_MAP:\n    p = map_search_backward(reg->enc, reg->map, range, adjrange, p);\n    break;\n  }\n\n  if (p) {\n    if (reg->sub_anchor) {\n      UChar* prev;\n\n      switch (reg->sub_anchor) {\n      case ANCHOR_BEGIN_LINE:\n        if (!ON_STR_BEGIN(p)) {\n          prev = onigenc_get_prev_char_head(reg->enc, str, p);\n          if (!ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end)) {\n            p = prev;\n            goto retry;\n          }\n        }\n        break;\n\n      case ANCHOR_END_LINE:\n        if (ON_STR_END(p)) {\n#ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE\n          prev = onigenc_get_prev_char_head(reg->enc, adjrange, p);\n          if (IS_NULL(prev)) goto fail;\n          if (ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end)) {\n            p = prev;\n            goto retry;\n          }\n#endif\n        }\n        else if (! ONIGENC_IS_MBC_NEWLINE(reg->enc, p, end)\n#ifdef USE_CRNL_AS_LINE_TERMINATOR\n                 && ! ONIGENC_IS_MBC_CRNL(reg->enc, p, end)\n#endif\n                 ) {\n          p = onigenc_get_prev_char_head(reg->enc, adjrange, p);\n          if (IS_NULL(p)) goto fail;\n          goto retry;\n        }\n        break;\n      }\n    }\n\n    /* no needs to adjust *high, *high is used as range check only */\n    if (reg->dmax != ONIG_INFINITE_DISTANCE) {\n      *low  = p - reg->dmax;\n      *high = p - reg->dmin;\n      *high = onigenc_get_right_adjust_char_head(reg->enc, adjrange, *high);\n    }\n\n#ifdef ONIG_DEBUG_SEARCH\n    fprintf(stderr, \"backward_search_range: low: %d, high: %d\\n\",\n\t    (int )(*low - str), (int )(*high - str));\n#endif\n    return 1; /* success */\n  }\n\n fail:\n#ifdef ONIG_DEBUG_SEARCH\n  fprintf(stderr, \"backward_search_range: fail.\\n\");\n#endif\n  return 0; /* fail */\n}\n\n\nextern int\nonig_search(regex_t* reg, const UChar* str, const UChar* end,\n\t    const UChar* start, const UChar* range, OnigRegion* region, OnigOptionType option)\n{\n  int r;\n  UChar *s, *prev;\n  OnigMatchArg msa;\n  const UChar *orig_start = start;\n#ifdef USE_MATCH_RANGE_MUST_BE_INSIDE_OF_SPECIFIED_RANGE\n  const UChar *orig_range = range;\n#endif\n\n#ifdef ONIG_DEBUG_SEARCH\n  fprintf(stderr,\n     \"onig_search (entry point): str: %d, end: %d, start: %d, range: %d\\n\",\n     (int )str, (int )(end - str), (int )(start - str), (int )(range - str));\n#endif\n\n  if (region\n#ifdef USE_POSIX_API_REGION_OPTION\n      && !IS_POSIX_REGION(option)\n#endif\n      ) {\n    r = onig_region_resize_clear(region, reg->num_mem + 1);\n    if (r) goto finish_no_msa;\n  }\n\n  if (start > end || start < str) goto mismatch_no_msa;\n\n  if (ONIG_IS_OPTION_ON(option, ONIG_OPTION_CHECK_VALIDITY_OF_STRING)) {\n    if (! ONIGENC_IS_VALID_MBC_STRING(reg->enc, str, end)) {\n      r = ONIGERR_INVALID_WIDE_CHAR_VALUE;\n      goto finish_no_msa;\n    }\n  }\n\n\n#ifdef USE_MATCH_RANGE_MUST_BE_INSIDE_OF_SPECIFIED_RANGE\n#ifdef USE_FIND_LONGEST_SEARCH_ALL_OF_RANGE\n#define MATCH_AND_RETURN_CHECK(upper_range) \\\n  r = match_at(reg, str, end, (upper_range), s, prev, &msa); \\\n  if (r != ONIG_MISMATCH) {\\\n    if (r >= 0) {\\\n      if (! IS_FIND_LONGEST(reg->options)) {\\\n        goto match;\\\n      }\\\n    }\\\n    else goto finish; /* error */ \\\n  }\n#else\n#define MATCH_AND_RETURN_CHECK(upper_range) \\\n  r = match_at(reg, str, end, (upper_range), s, prev, &msa); \\\n  if (r != ONIG_MISMATCH) {\\\n    if (r >= 0) {\\\n      goto match;\\\n    }\\\n    else goto finish; /* error */ \\\n  }\n#endif /* USE_FIND_LONGEST_SEARCH_ALL_OF_RANGE */\n#else\n#ifdef USE_FIND_LONGEST_SEARCH_ALL_OF_RANGE\n#define MATCH_AND_RETURN_CHECK(none) \\\n  r = match_at(reg, str, end, s, prev, &msa);\\\n  if (r != ONIG_MISMATCH) {\\\n    if (r >= 0) {\\\n      if (! IS_FIND_LONGEST(reg->options)) {\\\n        goto match;\\\n      }\\\n    }\\\n    else goto finish; /* error */ \\\n  }\n#else\n#define MATCH_AND_RETURN_CHECK(none) \\\n  r = match_at(reg, str, end, s, prev, &msa);\\\n  if (r != ONIG_MISMATCH) {\\\n    if (r >= 0) {\\\n      goto match;\\\n    }\\\n    else goto finish; /* error */ \\\n  }\n#endif /* USE_FIND_LONGEST_SEARCH_ALL_OF_RANGE */\n#endif /* USE_MATCH_RANGE_MUST_BE_INSIDE_OF_SPECIFIED_RANGE */\n\n\n  /* anchor optimize: resume search range */\n  if (reg->anchor != 0 && str < end) {\n    UChar *min_semi_end, *max_semi_end;\n\n    if (reg->anchor & ANCHOR_BEGIN_POSITION) {\n      /* search start-position only */\n    begin_position:\n      if (range > start)\n        range = start + 1;\n      else\n        range = start;\n    }\n    else if (reg->anchor & ANCHOR_BEGIN_BUF) {\n      /* search str-position only */\n      if (range > start) {\n        if (start != str) goto mismatch_no_msa;\n        range = str + 1;\n      }\n      else {\n        if (range <= str) {\n          start = str;\n          range = str;\n        }\n        else\n          goto mismatch_no_msa;\n      }\n    }\n    else if (reg->anchor & ANCHOR_END_BUF) {\n      min_semi_end = max_semi_end = (UChar* )end;\n\n    end_buf:\n      if ((OnigLen )(max_semi_end - str) < reg->anchor_dmin)\n\tgoto mismatch_no_msa;\n\n      if (range > start) {\n        if ((OnigLen )(min_semi_end - start) > reg->anchor_dmax) {\n          start = min_semi_end - reg->anchor_dmax;\n          if (start < end)\n            start = onigenc_get_right_adjust_char_head(reg->enc, str, start);\n        }\n        if ((OnigLen )(max_semi_end - (range - 1)) < reg->anchor_dmin) {\n          range = max_semi_end - reg->anchor_dmin + 1;\n        }\n\n        if (start > range) goto mismatch_no_msa;\n        /* If start == range, match with empty at end.\n           Backward search is used. */\n      }\n      else {\n        if ((OnigLen )(min_semi_end - range) > reg->anchor_dmax) {\n          range = min_semi_end - reg->anchor_dmax;\n        }\n        if ((OnigLen )(max_semi_end - start) < reg->anchor_dmin) {\n          start = max_semi_end - reg->anchor_dmin;\n          start = ONIGENC_LEFT_ADJUST_CHAR_HEAD(reg->enc, str, start);\n        }\n        if (range > start) goto mismatch_no_msa;\n      }\n    }\n    else if (reg->anchor & ANCHOR_SEMI_END_BUF) {\n      UChar* pre_end = ONIGENC_STEP_BACK(reg->enc, str, end, 1);\n\n      max_semi_end = (UChar* )end;\n      if (ONIGENC_IS_MBC_NEWLINE(reg->enc, pre_end, end)) {\n        min_semi_end = pre_end;\n\n#ifdef USE_CRNL_AS_LINE_TERMINATOR\n        pre_end = ONIGENC_STEP_BACK(reg->enc, str, pre_end, 1);\n        if (IS_NOT_NULL(pre_end) &&\n            ONIGENC_IS_MBC_CRNL(reg->enc, pre_end, end)) {\n          min_semi_end = pre_end;\n        }\n#endif\n        if (min_semi_end > str && start <= min_semi_end) {\n          goto end_buf;\n        }\n      }\n      else {\n        min_semi_end = (UChar* )end;\n        goto end_buf;\n      }\n    }\n    else if ((reg->anchor & ANCHOR_ANYCHAR_STAR_ML)) {\n      goto begin_position;\n    }\n  }\n  else if (str == end) { /* empty string */\n    static const UChar* address_for_empty_string = (UChar* )\"\";\n\n#ifdef ONIG_DEBUG_SEARCH\n    fprintf(stderr, \"onig_search: empty string.\\n\");\n#endif\n\n    if (reg->threshold_len == 0) {\n      start = end = str = address_for_empty_string;\n      s = (UChar* )start;\n      prev = (UChar* )NULL;\n\n      MATCH_ARG_INIT(msa, reg, option, region, start);\n#ifdef USE_COMBINATION_EXPLOSION_CHECK\n      msa.state_check_buff = (void* )0;\n      msa.state_check_buff_size = 0;   /* NO NEED, for valgrind */\n#endif\n      MATCH_AND_RETURN_CHECK(end);\n      goto mismatch;\n    }\n    goto mismatch_no_msa;\n  }\n\n#ifdef ONIG_DEBUG_SEARCH\n  fprintf(stderr, \"onig_search(apply anchor): end: %d, start: %d, range: %d\\n\",\n\t  (int )(end - str), (int )(start - str), (int )(range - str));\n#endif\n\n  MATCH_ARG_INIT(msa, reg, option, region, orig_start);\n#ifdef USE_COMBINATION_EXPLOSION_CHECK\n  {\n    int offset = (MIN(start, range) - str);\n    STATE_CHECK_BUFF_INIT(msa, end - str, offset, reg->num_comb_exp_check);\n  }\n#endif\n\n  s = (UChar* )start;\n  if (range > start) {   /* forward search */\n    if (s > str)\n      prev = onigenc_get_prev_char_head(reg->enc, str, s);\n    else\n      prev = (UChar* )NULL;\n\n    if (reg->optimize != ONIG_OPTIMIZE_NONE) {\n      UChar *sch_range, *low, *high, *low_prev;\n\n      sch_range = (UChar* )range;\n      if (reg->dmax != 0) {\n        if (reg->dmax == ONIG_INFINITE_DISTANCE)\n          sch_range = (UChar* )end;\n        else {\n          sch_range += reg->dmax;\n          if (sch_range > end) sch_range = (UChar* )end;\n        }\n      }\n\n      if ((end - start) < reg->threshold_len)\n        goto mismatch;\n\n      if (reg->dmax != ONIG_INFINITE_DISTANCE) {\n        do {\n          if (! forward_search_range(reg, str, end, s, sch_range,\n                                     &low, &high, &low_prev)) goto mismatch;\n          if (s < low) {\n            s    = low;\n            prev = low_prev;\n          }\n          while (s <= high) {\n            MATCH_AND_RETURN_CHECK(orig_range);\n            prev = s;\n            s += enclen(reg->enc, s);\n          }\n        } while (s < range);\n        goto mismatch;\n      }\n      else { /* check only. */\n        if (! forward_search_range(reg, str, end, s, sch_range,\n                                   &low, &high, (UChar** )NULL)) goto mismatch;\n\n        if ((reg->anchor & ANCHOR_ANYCHAR_STAR) != 0) {\n          do {\n            MATCH_AND_RETURN_CHECK(orig_range);\n            prev = s;\n            s += enclen(reg->enc, s);\n\n            if ((reg->anchor & (ANCHOR_LOOK_BEHIND | ANCHOR_PREC_READ_NOT)) == 0) {\n              while (!ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end) && s < range) {\n                prev = s;\n                s += enclen(reg->enc, s);\n              }\n            }\n          } while (s < range);\n          goto mismatch;\n        }\n      }\n    }\n\n    do {\n      MATCH_AND_RETURN_CHECK(orig_range);\n      prev = s;\n      s += enclen(reg->enc, s);\n    } while (s < range);\n\n    if (s == range) { /* because empty match with /$/. */\n      MATCH_AND_RETURN_CHECK(orig_range);\n    }\n  }\n  else {  /* backward search */\n#ifdef USE_MATCH_RANGE_MUST_BE_INSIDE_OF_SPECIFIED_RANGE\n    if (orig_start < end)\n      orig_start += enclen(reg->enc, orig_start); /* is upper range */\n#endif\n\n    if (reg->optimize != ONIG_OPTIMIZE_NONE) {\n      UChar *low, *high, *adjrange, *sch_start;\n\n      if (range < end)\n        adjrange = ONIGENC_LEFT_ADJUST_CHAR_HEAD(reg->enc, str, range);\n      else\n        adjrange = (UChar* )end;\n\n      if (reg->dmax != ONIG_INFINITE_DISTANCE &&\n          (end - range) >= reg->threshold_len) {\n        do {\n          sch_start = s + reg->dmax;\n          if (sch_start > end) sch_start = (UChar* )end;\n          if (backward_search_range(reg, str, end, sch_start, range, adjrange,\n                                    &low, &high) <= 0)\n            goto mismatch;\n\n          if (s > high)\n            s = high;\n\n          while (s >= low) {\n            prev = onigenc_get_prev_char_head(reg->enc, str, s);\n            MATCH_AND_RETURN_CHECK(orig_start);\n            s = prev;\n          }\n        } while (s >= range);\n        goto mismatch;\n      }\n      else { /* check only. */\n        if ((end - range) < reg->threshold_len) goto mismatch;\n\n        sch_start = s;\n        if (reg->dmax != 0) {\n          if (reg->dmax == ONIG_INFINITE_DISTANCE)\n            sch_start = (UChar* )end;\n          else {\n            sch_start += reg->dmax;\n            if (sch_start > end) sch_start = (UChar* )end;\n            else\n              sch_start = ONIGENC_LEFT_ADJUST_CHAR_HEAD(reg->enc,\n                                                        start, sch_start);\n          }\n        }\n        if (backward_search_range(reg, str, end, sch_start, range, adjrange,\n                                  &low, &high) <= 0) goto mismatch;\n      }\n    }\n\n    do {\n      prev = onigenc_get_prev_char_head(reg->enc, str, s);\n      MATCH_AND_RETURN_CHECK(orig_start);\n      s = prev;\n    } while (s >= range);\n  }\n\n mismatch:\n#ifdef USE_FIND_LONGEST_SEARCH_ALL_OF_RANGE\n  if (IS_FIND_LONGEST(reg->options)) {\n    if (msa.best_len >= 0) {\n      s = msa.best_s;\n      goto match;\n    }\n  }\n#endif\n  r = ONIG_MISMATCH;\n\n finish:\n  MATCH_ARG_FREE(msa);\n\n  /* If result is mismatch and no FIND_NOT_EMPTY option,\n     then the region is not set in match_at(). */\n  if (IS_FIND_NOT_EMPTY(reg->options) && region\n#ifdef USE_POSIX_API_REGION_OPTION\n      && !IS_POSIX_REGION(option)\n#endif\n      ) {\n    onig_region_clear(region);\n  }\n\n#ifdef ONIG_DEBUG\n  if (r != ONIG_MISMATCH)\n    fprintf(stderr, \"onig_search: error %d\\n\", r);\n#endif\n  return r;\n\n mismatch_no_msa:\n  r = ONIG_MISMATCH;\n finish_no_msa:\n#ifdef ONIG_DEBUG\n  if (r != ONIG_MISMATCH)\n    fprintf(stderr, \"onig_search: error %d\\n\", r);\n#endif\n  return r;\n\n match:\n  MATCH_ARG_FREE(msa);\n  return s - str;\n}\n\nextern int\nonig_scan(regex_t* reg, const UChar* str, const UChar* end,\n\t  OnigRegion* region, OnigOptionType option,\n\t  int (*scan_callback)(int, int, OnigRegion*, void*),\n\t  void* callback_arg)\n{\n  int r;\n  int n;\n  int rs;\n  const UChar* start;\n\n  if (ONIG_IS_OPTION_ON(option, ONIG_OPTION_CHECK_VALIDITY_OF_STRING)) {\n    if (! ONIGENC_IS_VALID_MBC_STRING(reg->enc, str, end))\n      return ONIGERR_INVALID_WIDE_CHAR_VALUE;\n\n    ONIG_OPTION_OFF(option, ONIG_OPTION_CHECK_VALIDITY_OF_STRING);\n  }\n\n  n = 0;\n  start = str;\n  while (1) {\n    r = onig_search(reg, str, end, start, end, region, option);\n    if (r >= 0) {\n      rs = scan_callback(n, r, region, callback_arg);\n      n++;\n      if (rs != 0)\n        return rs;\n\n      if (region->end[0] == start - str)\n        start++;\n      else\n        start = str + region->end[0];\n\n      if (start > end)\n        break;\n    }\n    else if (r == ONIG_MISMATCH) {\n      break;\n    }\n    else { /* error */\n      return r;\n    }\n  }\n\n  return n;\n}\n\nextern OnigEncoding\nonig_get_encoding(regex_t* reg)\n{\n  return reg->enc;\n}\n\nextern OnigOptionType\nonig_get_options(regex_t* reg)\n{\n  return reg->options;\n}\n\nextern  OnigCaseFoldType\nonig_get_case_fold_flag(regex_t* reg)\n{\n  return reg->case_fold_flag;\n}\n\nextern OnigSyntaxType*\nonig_get_syntax(regex_t* reg)\n{\n  return reg->syntax;\n}\n\nextern int\nonig_number_of_captures(regex_t* reg)\n{\n  return reg->num_mem;\n}\n\nextern int\nonig_number_of_capture_histories(regex_t* reg)\n{\n#ifdef USE_CAPTURE_HISTORY\n  int i, n;\n\n  n = 0;\n  for (i = 0; i <= ONIG_MAX_CAPTURE_HISTORY_GROUP; i++) {\n    if (BIT_STATUS_AT(reg->capture_history, i) != 0)\n      n++;\n  }\n  return n;\n#else\n  return 0;\n#endif\n}\n\nextern void\nonig_copy_encoding(OnigEncoding to, OnigEncoding from)\n{\n  *to = *from;\n}\n\n"], "filenames": ["src/regexec.c"], "buggy_code_start_loc": [3156], "buggy_code_end_loc": [3156], "fixing_code_start_loc": [3157], "fixing_code_end_loc": [3159], "type": "CWE-125", "message": "An issue was discovered in Oniguruma 6.2.0, as used in Oniguruma-mod in Ruby through 2.4.1 and mbstring in PHP through 7.1.5. A stack out-of-bounds read occurs in mbc_enc_len() during regular expression searching. Invalid handling of reg->dmin in forward_search_range() could result in an invalid pointer dereference, as an out-of-bounds read from a stack buffer.", "other": {"cve": {"id": "CVE-2017-9227", "sourceIdentifier": "cve@mitre.org", "published": "2017-05-24T15:29:00.323", "lastModified": "2022-07-20T16:34:01.827", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in Oniguruma 6.2.0, as used in Oniguruma-mod in Ruby through 2.4.1 and mbstring in PHP through 7.1.5. A stack out-of-bounds read occurs in mbc_enc_len() during regular expression searching. Invalid handling of reg->dmin in forward_search_range() could result in an invalid pointer dereference, as an out-of-bounds read from a stack buffer."}, {"lang": "es", "value": "Se ha descubierto un problema en Oniguruma 6.2.0, como se empleaba en Oniguruma-mod en Ruby hasta la versi\u00f3n 2.4.1 y en mbstring en PHP hasta la versi\u00f3n 7.1.5. Una lectura de pila fuera de l\u00edmites tiene lugar en mbc_enc_len() durante una b\u00fasqueda de expresi\u00f3n regular. El manejo incorrecto de reg->dmin en forward_search_range() podr\u00eda dar lugar a una desreferencia de puntero no v\u00e1lida, como una lectura fuera de l\u00edmites desde un b\u00fafer de pila."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oniguruma_project:oniguruma:6.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "71A9EC32-B30C-40DF-9937-654BC977DCC4"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:php:php:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.6.0", "versionEndExcluding": "5.6.31", "matchCriteriaId": "00E9E5A8-4C71-471D-97E9-FDE368D1EB71"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.0.0", "versionEndExcluding": "7.0.21", "matchCriteriaId": "ABE3BCB8-C2C7-4E44-A4D2-AA1DAE9555DB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.1.0", "versionEndExcluding": "7.1.7", "matchCriteriaId": "5799FA9F-8C0B-4B86-9D2C-558DFF64AA6C"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/100538", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:1296", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/kkos/oniguruma/commit/9690d3ab1f9bcd2db8cbe1fe3ee4a5da606b8814", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/kkos/oniguruma/issues/58", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/kkos/oniguruma/commit/9690d3ab1f9bcd2db8cbe1fe3ee4a5da606b8814"}}