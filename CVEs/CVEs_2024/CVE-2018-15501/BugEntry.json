{"buggy_code": ["/*\n * Copyright (C) the libgit2 contributors. All rights reserved.\n *\n * This file is part of libgit2, distributed under the GNU GPL v2 with\n * a Linking Exception. For full terms see the included COPYING file.\n */\n\n#include \"common.h\"\n\n#include \"git2/types.h\"\n#include \"git2/errors.h\"\n#include \"git2/refs.h\"\n#include \"git2/revwalk.h\"\n\n#include \"smart.h\"\n#include \"util.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\n#include <ctype.h>\n\n#define PKT_LEN_SIZE 4\nstatic const char pkt_done_str[] = \"0009done\\n\";\nstatic const char pkt_flush_str[] = \"0000\";\nstatic const char pkt_have_prefix[] = \"0032have \";\nstatic const char pkt_want_prefix[] = \"0032want \";\n\nstatic int flush_pkt(git_pkt **out)\n{\n\tgit_pkt *pkt;\n\n\tpkt = git__malloc(sizeof(git_pkt));\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_FLUSH;\n\t*out = pkt;\n\n\treturn 0;\n}\n\n/* the rest of the line will be useful for multi_ack and multi_ack_detailed */\nstatic int ack_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_ack *pkt;\n\tGIT_UNUSED(line);\n\tGIT_UNUSED(len);\n\n\tpkt = git__calloc(1, sizeof(git_pkt_ack));\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_ACK;\n\tline += 3;\n\tlen -= 3;\n\n\tif (len >= GIT_OID_HEXSZ) {\n\t\tgit_oid_fromstr(&pkt->oid, line + 1);\n\t\tline += GIT_OID_HEXSZ + 1;\n\t\tlen -= GIT_OID_HEXSZ + 1;\n\t}\n\n\tif (len >= 7) {\n\t\tif (!git__prefixcmp(line + 1, \"continue\"))\n\t\t\tpkt->status = GIT_ACK_CONTINUE;\n\t\tif (!git__prefixcmp(line + 1, \"common\"))\n\t\t\tpkt->status = GIT_ACK_COMMON;\n\t\tif (!git__prefixcmp(line + 1, \"ready\"))\n\t\t\tpkt->status = GIT_ACK_READY;\n\t}\n\n\t*out = (git_pkt *) pkt;\n\n\treturn 0;\n}\n\nstatic int nak_pkt(git_pkt **out)\n{\n\tgit_pkt *pkt;\n\n\tpkt = git__malloc(sizeof(git_pkt));\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_NAK;\n\t*out = pkt;\n\n\treturn 0;\n}\n\nstatic int pack_pkt(git_pkt **out)\n{\n\tgit_pkt *pkt;\n\n\tpkt = git__malloc(sizeof(git_pkt));\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_PACK;\n\t*out = pkt;\n\n\treturn 0;\n}\n\nstatic int comment_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_comment *pkt;\n\tsize_t alloclen;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, sizeof(git_pkt_comment), len);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, 1);\n\tpkt = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_COMMENT;\n\tmemcpy(pkt->comment, line, len);\n\tpkt->comment[len] = '\\0';\n\n\t*out = (git_pkt *) pkt;\n\n\treturn 0;\n}\n\nstatic int err_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_err *pkt;\n\tsize_t alloclen;\n\n\t/* Remove \"ERR \" from the line */\n\tline += 4;\n\tlen -= 4;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, sizeof(git_pkt_progress), len);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, 1);\n\tpkt = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_ERR;\n\tpkt->len = (int)len;\n\tmemcpy(pkt->error, line, len);\n\tpkt->error[len] = '\\0';\n\n\t*out = (git_pkt *) pkt;\n\n\treturn 0;\n}\n\nstatic int data_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_data *pkt;\n\tsize_t alloclen;\n\n\tline++;\n\tlen--;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, sizeof(git_pkt_progress), len);\n\tpkt = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_DATA;\n\tpkt->len = (int) len;\n\tmemcpy(pkt->data, line, len);\n\n\t*out = (git_pkt *) pkt;\n\n\treturn 0;\n}\n\nstatic int sideband_progress_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_progress *pkt;\n\tsize_t alloclen;\n\n\tline++;\n\tlen--;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, sizeof(git_pkt_progress), len);\n\tpkt = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_PROGRESS;\n\tpkt->len = (int) len;\n\tmemcpy(pkt->data, line, len);\n\n\t*out = (git_pkt *) pkt;\n\n\treturn 0;\n}\n\nstatic int sideband_error_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_err *pkt;\n\tsize_t alloc_len;\n\n\tline++;\n\tlen--;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, sizeof(git_pkt_err), len);\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, alloc_len, 1);\n\tpkt = git__malloc(alloc_len);\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_ERR;\n\tpkt->len = (int)len;\n\tmemcpy(pkt->error, line, len);\n\tpkt->error[len] = '\\0';\n\n\t*out = (git_pkt *)pkt;\n\n\treturn 0;\n}\n\n/*\n * Parse an other-ref line.\n */\nstatic int ref_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tint error;\n\tgit_pkt_ref *pkt;\n\tsize_t alloclen;\n\n\tpkt = git__malloc(sizeof(git_pkt_ref));\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tmemset(pkt, 0x0, sizeof(git_pkt_ref));\n\tpkt->type = GIT_PKT_REF;\n\tif ((error = git_oid_fromstr(&pkt->head.oid, line)) < 0)\n\t\tgoto error_out;\n\n\t/* Check for a bit of consistency */\n\tif (line[GIT_OID_HEXSZ] != ' ') {\n\t\tgiterr_set(GITERR_NET, \"error parsing pkt-line\");\n\t\terror = -1;\n\t\tgoto error_out;\n\t}\n\n\t/* Jump from the name */\n\tline += GIT_OID_HEXSZ + 1;\n\tlen -= (GIT_OID_HEXSZ + 1);\n\n\tif (line[len - 1] == '\\n')\n\t\t--len;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\tpkt->head.name = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt->head.name);\n\n\tmemcpy(pkt->head.name, line, len);\n\tpkt->head.name[len] = '\\0';\n\n\tif (strlen(pkt->head.name) < len) {\n\t\tpkt->capabilities = strchr(pkt->head.name, '\\0') + 1;\n\t}\n\n\t*out = (git_pkt *)pkt;\n\treturn 0;\n\nerror_out:\n\tgit__free(pkt);\n\treturn error;\n}\n\nstatic int ok_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_ok *pkt;\n\tconst char *ptr;\n\tsize_t alloc_len;\n\n\tpkt = git__malloc(sizeof(*pkt));\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_OK;\n\n\tline += 3; /* skip \"ok \" */\n\tif (!(ptr = strchr(line, '\\n'))) {\n\t\tgiterr_set(GITERR_NET, \"invalid packet line\");\n\t\tgit__free(pkt);\n\t\treturn -1;\n\t}\n\tlen = ptr - line;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, len, 1);\n\tpkt->ref = git__malloc(alloc_len);\n\tGITERR_CHECK_ALLOC(pkt->ref);\n\n\tmemcpy(pkt->ref, line, len);\n\tpkt->ref[len] = '\\0';\n\n\t*out = (git_pkt *)pkt;\n\treturn 0;\n}\n\nstatic int ng_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_ng *pkt;\n\tconst char *ptr;\n\tsize_t alloclen;\n\n\tpkt = git__malloc(sizeof(*pkt));\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->ref = NULL;\n\tpkt->type = GIT_PKT_NG;\n\n\tline += 3; /* skip \"ng \" */\n\tif (!(ptr = strchr(line, ' ')))\n\t\tgoto out_err;\n\tlen = ptr - line;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\tpkt->ref = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt->ref);\n\n\tmemcpy(pkt->ref, line, len);\n\tpkt->ref[len] = '\\0';\n\n\tline = ptr + 1;\n\tif (!(ptr = strchr(line, '\\n')))\n\t\tgoto out_err;\n\tlen = ptr - line;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\tpkt->msg = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt->msg);\n\n\tmemcpy(pkt->msg, line, len);\n\tpkt->msg[len] = '\\0';\n\n\t*out = (git_pkt *)pkt;\n\treturn 0;\n\nout_err:\n\tgiterr_set(GITERR_NET, \"invalid packet line\");\n\tgit__free(pkt->ref);\n\tgit__free(pkt);\n\treturn -1;\n}\n\nstatic int unpack_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_unpack *pkt;\n\n\tGIT_UNUSED(len);\n\n\tpkt = git__malloc(sizeof(*pkt));\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_UNPACK;\n\tif (!git__prefixcmp(line, \"unpack ok\"))\n\t\tpkt->unpack_ok = 1;\n\telse\n\t\tpkt->unpack_ok = 0;\n\n\t*out = (git_pkt *)pkt;\n\treturn 0;\n}\n\nstatic int32_t parse_len(const char *line)\n{\n\tchar num[PKT_LEN_SIZE + 1];\n\tint i, k, error;\n\tint32_t len;\n\tconst char *num_end;\n\n\tmemcpy(num, line, PKT_LEN_SIZE);\n\tnum[PKT_LEN_SIZE] = '\\0';\n\n\tfor (i = 0; i < PKT_LEN_SIZE; ++i) {\n\t\tif (!isxdigit(num[i])) {\n\t\t\t/* Make sure there are no special characters before passing to error message */\n\t\t\tfor (k = 0; k < PKT_LEN_SIZE; ++k) {\n\t\t\t\tif(!isprint(num[k])) {\n\t\t\t\t\tnum[k] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tgiterr_set(GITERR_NET, \"invalid hex digit in length: '%s'\", num);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif ((error = git__strtol32(&len, num, &num_end, 16)) < 0)\n\t\treturn error;\n\n\treturn len;\n}\n\n/*\n * As per the documentation, the syntax is:\n *\n * pkt-line\t= data-pkt / flush-pkt\n * data-pkt\t= pkt-len pkt-payload\n * pkt-len\t\t= 4*(HEXDIG)\n * pkt-payload = (pkt-len -4)*(OCTET)\n * flush-pkt\t= \"0000\"\n *\n * Which means that the first four bytes are the length of the line,\n * in ASCII hexadecimal (including itself)\n */\n\nint git_pkt_parse_line(\n\tgit_pkt **head, const char *line, const char **out, size_t bufflen)\n{\n\tint ret;\n\tint32_t len;\n\n\t/* Not even enough for the length */\n\tif (bufflen > 0 && bufflen < PKT_LEN_SIZE)\n\t\treturn GIT_EBUFS;\n\n\tlen = parse_len(line);\n\tif (len < 0) {\n\t\t/*\n\t\t * If we fail to parse the length, it might be because the\n\t\t * server is trying to send us the packfile already.\n\t\t */\n\t\tif (bufflen >= 4 && !git__prefixcmp(line, \"PACK\")) {\n\t\t\tgiterr_clear();\n\t\t\t*out = line;\n\t\t\treturn pack_pkt(head);\n\t\t}\n\n\t\treturn (int)len;\n\t}\n\n\t/*\n\t * If we were given a buffer length, then make sure there is\n\t * enough in the buffer to satisfy this line\n\t */\n\tif (bufflen > 0 && bufflen < (size_t)len)\n\t\treturn GIT_EBUFS;\n\n\t/*\n\t * The length has to be exactly 0 in case of a flush\n\t * packet or greater than PKT_LEN_SIZE, as the decoded\n\t * length includes its own encoded length of four bytes.\n\t */\n\tif (len != 0 && len < PKT_LEN_SIZE)\n\t\treturn GIT_ERROR;\n\n\tline += PKT_LEN_SIZE;\n\t/*\n\t * The Git protocol does not specify empty lines as part\n\t * of the protocol. Not knowing what to do with an empty\n\t * line, we should return an error upon hitting one.\n\t */\n\tif (len == PKT_LEN_SIZE) {\n\t\tgiterr_set_str(GITERR_NET, \"Invalid empty packet\");\n\t\treturn GIT_ERROR;\n\t}\n\n\tif (len == 0) { /* Flush pkt */\n\t\t*out = line;\n\t\treturn flush_pkt(head);\n\t}\n\n\tlen -= PKT_LEN_SIZE; /* the encoded length includes its own size */\n\n\tif (*line == GIT_SIDE_BAND_DATA)\n\t\tret = data_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_PROGRESS)\n\t\tret = sideband_progress_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_ERROR)\n\t\tret = sideband_error_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ACK\"))\n\t\tret = ack_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"NAK\"))\n\t\tret = nak_pkt(head);\n\telse if (!git__prefixcmp(line, \"ERR \"))\n\t\tret = err_pkt(head, line, len);\n\telse if (*line == '#')\n\t\tret = comment_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ok\"))\n\t\tret = ok_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ng\"))\n\t\tret = ng_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"unpack\"))\n\t\tret = unpack_pkt(head, line, len);\n\telse\n\t\tret = ref_pkt(head, line, len);\n\n\t*out = line + len;\n\n\treturn ret;\n}\n\nvoid git_pkt_free(git_pkt *pkt)\n{\n\tif (pkt->type == GIT_PKT_REF) {\n\t\tgit_pkt_ref *p = (git_pkt_ref *) pkt;\n\t\tgit__free(p->head.name);\n\t\tgit__free(p->head.symref_target);\n\t}\n\n\tif (pkt->type == GIT_PKT_OK) {\n\t\tgit_pkt_ok *p = (git_pkt_ok *) pkt;\n\t\tgit__free(p->ref);\n\t}\n\n\tif (pkt->type == GIT_PKT_NG) {\n\t\tgit_pkt_ng *p = (git_pkt_ng *) pkt;\n\t\tgit__free(p->ref);\n\t\tgit__free(p->msg);\n\t}\n\n\tgit__free(pkt);\n}\n\nint git_pkt_buffer_flush(git_buf *buf)\n{\n\treturn git_buf_put(buf, pkt_flush_str, strlen(pkt_flush_str));\n}\n\nstatic int buffer_want_with_caps(const git_remote_head *head, transport_smart_caps *caps, git_buf *buf)\n{\n\tgit_buf str = GIT_BUF_INIT;\n\tchar oid[GIT_OID_HEXSZ +1] = {0};\n\tsize_t len;\n\n\t/* Prefer multi_ack_detailed */\n\tif (caps->multi_ack_detailed)\n\t\tgit_buf_puts(&str, GIT_CAP_MULTI_ACK_DETAILED \" \");\n\telse if (caps->multi_ack)\n\t\tgit_buf_puts(&str, GIT_CAP_MULTI_ACK \" \");\n\n\t/* Prefer side-band-64k if the server supports both */\n\tif (caps->side_band_64k)\n\t\tgit_buf_printf(&str, \"%s \", GIT_CAP_SIDE_BAND_64K);\n\telse if (caps->side_band)\n\t\tgit_buf_printf(&str, \"%s \", GIT_CAP_SIDE_BAND);\n\n\tif (caps->include_tag)\n\t\tgit_buf_puts(&str, GIT_CAP_INCLUDE_TAG \" \");\n\n\tif (caps->thin_pack)\n\t\tgit_buf_puts(&str, GIT_CAP_THIN_PACK \" \");\n\n\tif (caps->ofs_delta)\n\t\tgit_buf_puts(&str, GIT_CAP_OFS_DELTA \" \");\n\n\tif (git_buf_oom(&str))\n\t\treturn -1;\n\n\tlen = strlen(\"XXXXwant \") + GIT_OID_HEXSZ + 1 /* NUL */ +\n\t\t git_buf_len(&str) + 1 /* LF */;\n\n\tif (len > 0xffff) {\n\t\tgiterr_set(GITERR_NET,\n\t\t\t\"tried to produce packet with invalid length %\" PRIuZ, len);\n\t\treturn -1;\n\t}\n\n\tgit_buf_grow_by(buf, len);\n\tgit_oid_fmt(oid, &head->oid);\n\tgit_buf_printf(buf,\n\t\t\"%04xwant %s %s\\n\", (unsigned int)len, oid, git_buf_cstr(&str));\n\tgit_buf_free(&str);\n\n\tGITERR_CHECK_ALLOC_BUF(buf);\n\n\treturn 0;\n}\n\n/*\n * All \"want\" packets have the same length and format, so what we do\n * is overwrite the OID each time.\n */\n\nint git_pkt_buffer_wants(\n\tconst git_remote_head * const *refs,\n\tsize_t count,\n\ttransport_smart_caps *caps,\n\tgit_buf *buf)\n{\n\tsize_t i = 0;\n\tconst git_remote_head *head;\n\n\tif (caps->common) {\n\t\tfor (; i < count; ++i) {\n\t\t\thead = refs[i];\n\t\t\tif (!head->local)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (buffer_want_with_caps(refs[i], caps, buf) < 0)\n\t\t\treturn -1;\n\n\t\ti++;\n\t}\n\n\tfor (; i < count; ++i) {\n\t\tchar oid[GIT_OID_HEXSZ];\n\n\t\thead = refs[i];\n\t\tif (head->local)\n\t\t\tcontinue;\n\n\t\tgit_oid_fmt(oid, &head->oid);\n\t\tgit_buf_put(buf, pkt_want_prefix, strlen(pkt_want_prefix));\n\t\tgit_buf_put(buf, oid, GIT_OID_HEXSZ);\n\t\tgit_buf_putc(buf, '\\n');\n\t\tif (git_buf_oom(buf))\n\t\t\treturn -1;\n\t}\n\n\treturn git_pkt_buffer_flush(buf);\n}\n\nint git_pkt_buffer_have(git_oid *oid, git_buf *buf)\n{\n\tchar oidhex[GIT_OID_HEXSZ + 1];\n\n\tmemset(oidhex, 0x0, sizeof(oidhex));\n\tgit_oid_fmt(oidhex, oid);\n\treturn git_buf_printf(buf, \"%s%s\\n\", pkt_have_prefix, oidhex);\n}\n\nint git_pkt_buffer_done(git_buf *buf)\n{\n\treturn git_buf_puts(buf, pkt_done_str);\n}\n"], "fixing_code": ["/*\n * Copyright (C) the libgit2 contributors. All rights reserved.\n *\n * This file is part of libgit2, distributed under the GNU GPL v2 with\n * a Linking Exception. For full terms see the included COPYING file.\n */\n\n#include \"common.h\"\n\n#include \"git2/types.h\"\n#include \"git2/errors.h\"\n#include \"git2/refs.h\"\n#include \"git2/revwalk.h\"\n\n#include \"smart.h\"\n#include \"util.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\n#include <ctype.h>\n\n#define PKT_LEN_SIZE 4\nstatic const char pkt_done_str[] = \"0009done\\n\";\nstatic const char pkt_flush_str[] = \"0000\";\nstatic const char pkt_have_prefix[] = \"0032have \";\nstatic const char pkt_want_prefix[] = \"0032want \";\n\nstatic int flush_pkt(git_pkt **out)\n{\n\tgit_pkt *pkt;\n\n\tpkt = git__malloc(sizeof(git_pkt));\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_FLUSH;\n\t*out = pkt;\n\n\treturn 0;\n}\n\n/* the rest of the line will be useful for multi_ack and multi_ack_detailed */\nstatic int ack_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_ack *pkt;\n\tGIT_UNUSED(line);\n\tGIT_UNUSED(len);\n\n\tpkt = git__calloc(1, sizeof(git_pkt_ack));\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_ACK;\n\tline += 3;\n\tlen -= 3;\n\n\tif (len >= GIT_OID_HEXSZ) {\n\t\tgit_oid_fromstr(&pkt->oid, line + 1);\n\t\tline += GIT_OID_HEXSZ + 1;\n\t\tlen -= GIT_OID_HEXSZ + 1;\n\t}\n\n\tif (len >= 7) {\n\t\tif (!git__prefixcmp(line + 1, \"continue\"))\n\t\t\tpkt->status = GIT_ACK_CONTINUE;\n\t\tif (!git__prefixcmp(line + 1, \"common\"))\n\t\t\tpkt->status = GIT_ACK_COMMON;\n\t\tif (!git__prefixcmp(line + 1, \"ready\"))\n\t\t\tpkt->status = GIT_ACK_READY;\n\t}\n\n\t*out = (git_pkt *) pkt;\n\n\treturn 0;\n}\n\nstatic int nak_pkt(git_pkt **out)\n{\n\tgit_pkt *pkt;\n\n\tpkt = git__malloc(sizeof(git_pkt));\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_NAK;\n\t*out = pkt;\n\n\treturn 0;\n}\n\nstatic int pack_pkt(git_pkt **out)\n{\n\tgit_pkt *pkt;\n\n\tpkt = git__malloc(sizeof(git_pkt));\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_PACK;\n\t*out = pkt;\n\n\treturn 0;\n}\n\nstatic int comment_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_comment *pkt;\n\tsize_t alloclen;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, sizeof(git_pkt_comment), len);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, 1);\n\tpkt = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_COMMENT;\n\tmemcpy(pkt->comment, line, len);\n\tpkt->comment[len] = '\\0';\n\n\t*out = (git_pkt *) pkt;\n\n\treturn 0;\n}\n\nstatic int err_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_err *pkt;\n\tsize_t alloclen;\n\n\t/* Remove \"ERR \" from the line */\n\tline += 4;\n\tlen -= 4;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, sizeof(git_pkt_progress), len);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, 1);\n\tpkt = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_ERR;\n\tpkt->len = (int)len;\n\tmemcpy(pkt->error, line, len);\n\tpkt->error[len] = '\\0';\n\n\t*out = (git_pkt *) pkt;\n\n\treturn 0;\n}\n\nstatic int data_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_data *pkt;\n\tsize_t alloclen;\n\n\tline++;\n\tlen--;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, sizeof(git_pkt_progress), len);\n\tpkt = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_DATA;\n\tpkt->len = (int) len;\n\tmemcpy(pkt->data, line, len);\n\n\t*out = (git_pkt *) pkt;\n\n\treturn 0;\n}\n\nstatic int sideband_progress_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_progress *pkt;\n\tsize_t alloclen;\n\n\tline++;\n\tlen--;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, sizeof(git_pkt_progress), len);\n\tpkt = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_PROGRESS;\n\tpkt->len = (int) len;\n\tmemcpy(pkt->data, line, len);\n\n\t*out = (git_pkt *) pkt;\n\n\treturn 0;\n}\n\nstatic int sideband_error_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_err *pkt;\n\tsize_t alloc_len;\n\n\tline++;\n\tlen--;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, sizeof(git_pkt_err), len);\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, alloc_len, 1);\n\tpkt = git__malloc(alloc_len);\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_ERR;\n\tpkt->len = (int)len;\n\tmemcpy(pkt->error, line, len);\n\tpkt->error[len] = '\\0';\n\n\t*out = (git_pkt *)pkt;\n\n\treturn 0;\n}\n\n/*\n * Parse an other-ref line.\n */\nstatic int ref_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tint error;\n\tgit_pkt_ref *pkt;\n\tsize_t alloclen;\n\n\tpkt = git__malloc(sizeof(git_pkt_ref));\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tmemset(pkt, 0x0, sizeof(git_pkt_ref));\n\tpkt->type = GIT_PKT_REF;\n\tif ((error = git_oid_fromstr(&pkt->head.oid, line)) < 0)\n\t\tgoto error_out;\n\n\t/* Check for a bit of consistency */\n\tif (line[GIT_OID_HEXSZ] != ' ') {\n\t\tgiterr_set(GITERR_NET, \"error parsing pkt-line\");\n\t\terror = -1;\n\t\tgoto error_out;\n\t}\n\n\t/* Jump from the name */\n\tline += GIT_OID_HEXSZ + 1;\n\tlen -= (GIT_OID_HEXSZ + 1);\n\n\tif (line[len - 1] == '\\n')\n\t\t--len;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\tpkt->head.name = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt->head.name);\n\n\tmemcpy(pkt->head.name, line, len);\n\tpkt->head.name[len] = '\\0';\n\n\tif (strlen(pkt->head.name) < len) {\n\t\tpkt->capabilities = strchr(pkt->head.name, '\\0') + 1;\n\t}\n\n\t*out = (git_pkt *)pkt;\n\treturn 0;\n\nerror_out:\n\tgit__free(pkt);\n\treturn error;\n}\n\nstatic int ok_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_ok *pkt;\n\tconst char *ptr;\n\tsize_t alloc_len;\n\n\tpkt = git__malloc(sizeof(*pkt));\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_OK;\n\n\tline += 3; /* skip \"ok \" */\n\tif (!(ptr = strchr(line, '\\n'))) {\n\t\tgiterr_set(GITERR_NET, \"invalid packet line\");\n\t\tgit__free(pkt);\n\t\treturn -1;\n\t}\n\tlen = ptr - line;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, len, 1);\n\tpkt->ref = git__malloc(alloc_len);\n\tGITERR_CHECK_ALLOC(pkt->ref);\n\n\tmemcpy(pkt->ref, line, len);\n\tpkt->ref[len] = '\\0';\n\n\t*out = (git_pkt *)pkt;\n\treturn 0;\n}\n\nstatic int ng_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_ng *pkt;\n\tconst char *ptr;\n\tsize_t alloclen;\n\n\tpkt = git__malloc(sizeof(*pkt));\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->ref = NULL;\n\tpkt->type = GIT_PKT_NG;\n\n\tif (len < 3)\n\t\tgoto out_err;\n\tline += 3; /* skip \"ng \" */\n\tlen -= 3;\n\tif (!(ptr = memchr(line, ' ', len)))\n\t\tgoto out_err;\n\tlen = ptr - line;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\tpkt->ref = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt->ref);\n\n\tmemcpy(pkt->ref, line, len);\n\tpkt->ref[len] = '\\0';\n\n\tif (len < 1)\n\t\tgoto out_err;\n\tline = ptr + 1;\n\tlen -= 1;\n\tif (!(ptr = memchr(line, '\\n', len)))\n\t\tgoto out_err;\n\tlen = ptr - line;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\tpkt->msg = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt->msg);\n\n\tmemcpy(pkt->msg, line, len);\n\tpkt->msg[len] = '\\0';\n\n\t*out = (git_pkt *)pkt;\n\treturn 0;\n\nout_err:\n\tgiterr_set(GITERR_NET, \"invalid packet line\");\n\tgit__free(pkt->ref);\n\tgit__free(pkt);\n\treturn -1;\n}\n\nstatic int unpack_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_unpack *pkt;\n\n\tGIT_UNUSED(len);\n\n\tpkt = git__malloc(sizeof(*pkt));\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_UNPACK;\n\tif (!git__prefixcmp(line, \"unpack ok\"))\n\t\tpkt->unpack_ok = 1;\n\telse\n\t\tpkt->unpack_ok = 0;\n\n\t*out = (git_pkt *)pkt;\n\treturn 0;\n}\n\nstatic int32_t parse_len(const char *line)\n{\n\tchar num[PKT_LEN_SIZE + 1];\n\tint i, k, error;\n\tint32_t len;\n\tconst char *num_end;\n\n\tmemcpy(num, line, PKT_LEN_SIZE);\n\tnum[PKT_LEN_SIZE] = '\\0';\n\n\tfor (i = 0; i < PKT_LEN_SIZE; ++i) {\n\t\tif (!isxdigit(num[i])) {\n\t\t\t/* Make sure there are no special characters before passing to error message */\n\t\t\tfor (k = 0; k < PKT_LEN_SIZE; ++k) {\n\t\t\t\tif(!isprint(num[k])) {\n\t\t\t\t\tnum[k] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tgiterr_set(GITERR_NET, \"invalid hex digit in length: '%s'\", num);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif ((error = git__strtol32(&len, num, &num_end, 16)) < 0)\n\t\treturn error;\n\n\treturn len;\n}\n\n/*\n * As per the documentation, the syntax is:\n *\n * pkt-line\t= data-pkt / flush-pkt\n * data-pkt\t= pkt-len pkt-payload\n * pkt-len\t\t= 4*(HEXDIG)\n * pkt-payload = (pkt-len -4)*(OCTET)\n * flush-pkt\t= \"0000\"\n *\n * Which means that the first four bytes are the length of the line,\n * in ASCII hexadecimal (including itself)\n */\n\nint git_pkt_parse_line(\n\tgit_pkt **head, const char *line, const char **out, size_t bufflen)\n{\n\tint ret;\n\tint32_t len;\n\n\t/* Not even enough for the length */\n\tif (bufflen > 0 && bufflen < PKT_LEN_SIZE)\n\t\treturn GIT_EBUFS;\n\n\tlen = parse_len(line);\n\tif (len < 0) {\n\t\t/*\n\t\t * If we fail to parse the length, it might be because the\n\t\t * server is trying to send us the packfile already.\n\t\t */\n\t\tif (bufflen >= 4 && !git__prefixcmp(line, \"PACK\")) {\n\t\t\tgiterr_clear();\n\t\t\t*out = line;\n\t\t\treturn pack_pkt(head);\n\t\t}\n\n\t\treturn (int)len;\n\t}\n\n\t/*\n\t * If we were given a buffer length, then make sure there is\n\t * enough in the buffer to satisfy this line\n\t */\n\tif (bufflen > 0 && bufflen < (size_t)len)\n\t\treturn GIT_EBUFS;\n\n\t/*\n\t * The length has to be exactly 0 in case of a flush\n\t * packet or greater than PKT_LEN_SIZE, as the decoded\n\t * length includes its own encoded length of four bytes.\n\t */\n\tif (len != 0 && len < PKT_LEN_SIZE)\n\t\treturn GIT_ERROR;\n\n\tline += PKT_LEN_SIZE;\n\t/*\n\t * The Git protocol does not specify empty lines as part\n\t * of the protocol. Not knowing what to do with an empty\n\t * line, we should return an error upon hitting one.\n\t */\n\tif (len == PKT_LEN_SIZE) {\n\t\tgiterr_set_str(GITERR_NET, \"Invalid empty packet\");\n\t\treturn GIT_ERROR;\n\t}\n\n\tif (len == 0) { /* Flush pkt */\n\t\t*out = line;\n\t\treturn flush_pkt(head);\n\t}\n\n\tlen -= PKT_LEN_SIZE; /* the encoded length includes its own size */\n\n\tif (*line == GIT_SIDE_BAND_DATA)\n\t\tret = data_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_PROGRESS)\n\t\tret = sideband_progress_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_ERROR)\n\t\tret = sideband_error_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ACK\"))\n\t\tret = ack_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"NAK\"))\n\t\tret = nak_pkt(head);\n\telse if (!git__prefixcmp(line, \"ERR \"))\n\t\tret = err_pkt(head, line, len);\n\telse if (*line == '#')\n\t\tret = comment_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ok\"))\n\t\tret = ok_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ng\"))\n\t\tret = ng_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"unpack\"))\n\t\tret = unpack_pkt(head, line, len);\n\telse\n\t\tret = ref_pkt(head, line, len);\n\n\t*out = line + len;\n\n\treturn ret;\n}\n\nvoid git_pkt_free(git_pkt *pkt)\n{\n\tif (pkt->type == GIT_PKT_REF) {\n\t\tgit_pkt_ref *p = (git_pkt_ref *) pkt;\n\t\tgit__free(p->head.name);\n\t\tgit__free(p->head.symref_target);\n\t}\n\n\tif (pkt->type == GIT_PKT_OK) {\n\t\tgit_pkt_ok *p = (git_pkt_ok *) pkt;\n\t\tgit__free(p->ref);\n\t}\n\n\tif (pkt->type == GIT_PKT_NG) {\n\t\tgit_pkt_ng *p = (git_pkt_ng *) pkt;\n\t\tgit__free(p->ref);\n\t\tgit__free(p->msg);\n\t}\n\n\tgit__free(pkt);\n}\n\nint git_pkt_buffer_flush(git_buf *buf)\n{\n\treturn git_buf_put(buf, pkt_flush_str, strlen(pkt_flush_str));\n}\n\nstatic int buffer_want_with_caps(const git_remote_head *head, transport_smart_caps *caps, git_buf *buf)\n{\n\tgit_buf str = GIT_BUF_INIT;\n\tchar oid[GIT_OID_HEXSZ +1] = {0};\n\tsize_t len;\n\n\t/* Prefer multi_ack_detailed */\n\tif (caps->multi_ack_detailed)\n\t\tgit_buf_puts(&str, GIT_CAP_MULTI_ACK_DETAILED \" \");\n\telse if (caps->multi_ack)\n\t\tgit_buf_puts(&str, GIT_CAP_MULTI_ACK \" \");\n\n\t/* Prefer side-band-64k if the server supports both */\n\tif (caps->side_band_64k)\n\t\tgit_buf_printf(&str, \"%s \", GIT_CAP_SIDE_BAND_64K);\n\telse if (caps->side_band)\n\t\tgit_buf_printf(&str, \"%s \", GIT_CAP_SIDE_BAND);\n\n\tif (caps->include_tag)\n\t\tgit_buf_puts(&str, GIT_CAP_INCLUDE_TAG \" \");\n\n\tif (caps->thin_pack)\n\t\tgit_buf_puts(&str, GIT_CAP_THIN_PACK \" \");\n\n\tif (caps->ofs_delta)\n\t\tgit_buf_puts(&str, GIT_CAP_OFS_DELTA \" \");\n\n\tif (git_buf_oom(&str))\n\t\treturn -1;\n\n\tlen = strlen(\"XXXXwant \") + GIT_OID_HEXSZ + 1 /* NUL */ +\n\t\t git_buf_len(&str) + 1 /* LF */;\n\n\tif (len > 0xffff) {\n\t\tgiterr_set(GITERR_NET,\n\t\t\t\"tried to produce packet with invalid length %\" PRIuZ, len);\n\t\treturn -1;\n\t}\n\n\tgit_buf_grow_by(buf, len);\n\tgit_oid_fmt(oid, &head->oid);\n\tgit_buf_printf(buf,\n\t\t\"%04xwant %s %s\\n\", (unsigned int)len, oid, git_buf_cstr(&str));\n\tgit_buf_free(&str);\n\n\tGITERR_CHECK_ALLOC_BUF(buf);\n\n\treturn 0;\n}\n\n/*\n * All \"want\" packets have the same length and format, so what we do\n * is overwrite the OID each time.\n */\n\nint git_pkt_buffer_wants(\n\tconst git_remote_head * const *refs,\n\tsize_t count,\n\ttransport_smart_caps *caps,\n\tgit_buf *buf)\n{\n\tsize_t i = 0;\n\tconst git_remote_head *head;\n\n\tif (caps->common) {\n\t\tfor (; i < count; ++i) {\n\t\t\thead = refs[i];\n\t\t\tif (!head->local)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (buffer_want_with_caps(refs[i], caps, buf) < 0)\n\t\t\treturn -1;\n\n\t\ti++;\n\t}\n\n\tfor (; i < count; ++i) {\n\t\tchar oid[GIT_OID_HEXSZ];\n\n\t\thead = refs[i];\n\t\tif (head->local)\n\t\t\tcontinue;\n\n\t\tgit_oid_fmt(oid, &head->oid);\n\t\tgit_buf_put(buf, pkt_want_prefix, strlen(pkt_want_prefix));\n\t\tgit_buf_put(buf, oid, GIT_OID_HEXSZ);\n\t\tgit_buf_putc(buf, '\\n');\n\t\tif (git_buf_oom(buf))\n\t\t\treturn -1;\n\t}\n\n\treturn git_pkt_buffer_flush(buf);\n}\n\nint git_pkt_buffer_have(git_oid *oid, git_buf *buf)\n{\n\tchar oidhex[GIT_OID_HEXSZ + 1];\n\n\tmemset(oidhex, 0x0, sizeof(oidhex));\n\tgit_oid_fmt(oidhex, oid);\n\treturn git_buf_printf(buf, \"%s%s\\n\", pkt_have_prefix, oidhex);\n}\n\nint git_pkt_buffer_done(git_buf *buf)\n{\n\treturn git_buf_puts(buf, pkt_done_str);\n}\n"], "filenames": ["src/transports/smart_pkt.c"], "buggy_code_start_loc": [301], "buggy_code_end_loc": [316], "fixing_code_start_loc": [302], "fixing_code_end_loc": [322], "type": "CWE-125", "message": "In ng_pkt in transports/smart_pkt.c in libgit2 before 0.26.6 and 0.27.x before 0.27.4, a remote attacker can send a crafted smart-protocol \"ng\" packet that lacks a '\\0' byte to trigger an out-of-bounds read that leads to DoS.", "other": {"cve": {"id": "CVE-2018-15501", "sourceIdentifier": "cve@mitre.org", "published": "2018-08-18T02:29:01.713", "lastModified": "2022-05-11T20:59:02.783", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In ng_pkt in transports/smart_pkt.c in libgit2 before 0.26.6 and 0.27.x before 0.27.4, a remote attacker can send a crafted smart-protocol \"ng\" packet that lacks a '\\0' byte to trigger an out-of-bounds read that leads to DoS."}, {"lang": "es", "value": "En ng_pkt en transports/smart_pkt.c en libgit2 antes de 0.26.6 y 0.27.x antes de 0.27.4, un atacante remoto puede enviar un paquete \"ng\" de protocolo inteligente manipulado que le falte un byte \"\\0\" para activar una lectura fuera de l\u00edmites que conduzca a una denegaci\u00f3n de servicio (DoS)."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libgit2:libgit2:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.26.6", "matchCriteriaId": "89FF27DE-63AA-49F8-942C-D55095953C5E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libgit2:libgit2:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.27.0", "versionEndExcluding": "0.27.4", "matchCriteriaId": "5A27D980-CE50-4F8E-ACF8-F87D4A924FF5"}]}]}], "references": [{"url": "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=9406", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://bugzilla.suse.com/show_bug.cgi?id=1104641", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/libgit2/libgit2/commit/1f9a8510e1d2f20ed7334eeeddb92c4dd8e7c649", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/libgit2/libgit2/releases/tag/v0.26.6", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/libgit2/libgit2/releases/tag/v0.27.4", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/08/msg00024.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/03/msg00031.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://www.pro-linux.de/sicherheit/2/44650/denial-of-service-in-libgit2.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/libgit2/libgit2/commit/1f9a8510e1d2f20ed7334eeeddb92c4dd8e7c649"}}