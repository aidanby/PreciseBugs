{"buggy_code": ["<?php\n/**\n * This file is part of the Cockpit project.\n *\n * (c) Artur Heinze - \ud83c\udd70\ud83c\udd76\ud83c\udd74\ud83c\udd7d\ud83c\udd83\ud83c\udd74\ud83c\udd79\ud83c\udd7e, http://agentejo.com\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace MongoLite;\n\n/**\n * Database object.\n */\nclass Database {\n\n    /**\n     * @var string - DSN path form memory database\n     */\n    public const DSN_PATH_MEMORY = ':memory:';\n\n    /**\n     * @var PDO object\n     */\n    public $connection;\n\n    /**\n     * @var array\n     */\n    protected $collections = [];\n\n    /**\n     * @var string\n     */\n    protected $path;\n\n    /**\n     * @var array\n     */\n    protected $document_criterias = [];\n\n    /**\n     * Constructor\n     *\n     * @param string $path\n     * @param array  $options\n     */\n    public function __construct($path = self::DSN_PATH_MEMORY, $options = []) {\n\n        $dns = \"sqlite:{$path}\";\n\n        $this->path = $path;\n        $this->connection = new \\PDO($dns, null, null, $options);\n\n        $database = $this;\n\n        $this->connection->sqliteCreateFunction('document_key', function($key, $document){\n\n            $document = \\json_decode($document, true);\n            $val      = '';\n\n            if (strpos($key, '.') !== false) {\n\n                $keys = \\explode('.', $key);\n\n                switch (\\count($keys)) {\n                    case 2:\n                        $val = isset($document[$keys[0]][$keys[1]]) ? $document[$keys[0]][$keys[1]] : '';\n                        break;\n                    case 3:\n                        $val = isset($document[$keys[0]][$keys[1]][$keys[2]]) ? $document[$keys[0]][$keys[1]][$keys[2]] : '';\n                        break;\n                    default:\n                        $val = isset($document[$keys[0]]) ? $document[$keys[0]] : '';\n                }\n\n            } else {\n                $val = isset($document[$key]) ? $document[$key] : '';\n            }\n\n            return \\is_array($val) || \\is_object($val) ? \\json_encode($val) : $val;\n        }, 2);\n\n        $this->connection->sqliteCreateFunction('document_criteria', function($funcid, $document) use($database) {\n\n            $document = \\json_decode($document, true);\n\n            return $database->callCriteriaFunction($funcid, $document);\n        }, 2);\n\n        $this->connection->exec('PRAGMA journal_mode = MEMORY');\n        $this->connection->exec('PRAGMA synchronous = OFF');\n        $this->connection->exec('PRAGMA PAGE_SIZE = 4096');\n    }\n\n    /**\n     * Register Criteria function\n     *\n     * @param  mixed $criteria\n     * @return mixed\n     */\n    public function registerCriteriaFunction($criteria) {\n\n        $id = \\uniqid('criteria');\n\n        if (\\is_callable($criteria)) {\n           $this->document_criterias[$id] = $criteria;\n           return $id;\n        }\n\n        if (is_array($criteria)) {\n\n            $fn = null;\n\n            eval('$fn = function($document) { return '.UtilArrayQuery::buildCondition($criteria).'; };');\n\n            $this->document_criterias[$id] = $fn;\n\n            return $id;\n        }\n\n        return null;\n    }\n\n    /**\n     * Execute registred criteria function\n     *\n     * @param  string $id\n     * @param  array $document\n     * @return boolean\n     */\n    public function callCriteriaFunction($id, $document) {\n\n        return isset($this->document_criterias[$id]) ? $this->document_criterias[$id]($document):false;\n    }\n\n    /**\n     * Vacuum database\n     */\n    public function vacuum() {\n        $this->connection->query('VACUUM');\n    }\n\n    /**\n     * Drop database\n     */\n    public function drop() {\n        if ($this->path != static::DSN_PATH_MEMORY) {\n            \\unlink($this->path);\n        }\n    }\n\n    /**\n     * Create a collection\n     *\n     * @param  string $name\n     */\n    public function createCollection($name) {\n        $this->connection->exec(\"CREATE TABLE `{$name}` ( id INTEGER PRIMARY KEY AUTOINCREMENT, document TEXT )\");\n    }\n\n    /**\n     * Drop a collection\n     *\n     * @param  string $name\n     */\n    public function dropCollection($name) {\n        $this->connection->exec(\"DROP TABLE `{$name}`\");\n\n        // Remove collection from cache\n        unset($this->collections[$name]);\n    }\n\n    /**\n     * Get all collection names in the database\n     *\n     * @return array\n     */\n    public function getCollectionNames() {\n\n        $stmt   = $this->connection->query(\"SELECT name FROM sqlite_master WHERE type='table' AND name!='sqlite_sequence';\");\n        $tables = $stmt->fetchAll( \\PDO::FETCH_ASSOC);\n        $names  = [];\n\n        foreach ($tables as $table) {\n            $names[] = $table['name'];\n        }\n\n        return $names;\n    }\n\n    /**\n     * Get all collections in the database\n     *\n     * @return array\n     */\n    public function listCollections() {\n\n        foreach ($this->getCollectionNames() as $name) {\n            if(!isset($this->collections[$name])) {\n                $this->collections[$name] = new Collection($name, $this);\n            }\n        }\n\n        return $this->collections;\n    }\n\n    /**\n     * Select collection\n     *\n     * @param  string $name\n     * @return object\n     */\n    public function selectCollection($name) {\n\n        if (!isset($this->collections[$name])) {\n\n            if (!in_array($name, $this->getCollectionNames())) {\n                $this->createCollection($name);\n            }\n\n            $this->collections[$name] = new Collection($name, $this);\n        }\n\n        return $this->collections[$name];\n    }\n\n    public function __get($collection) {\n\n        return $this->selectCollection($collection);\n    }\n}\n\n\nclass UtilArrayQuery {\n\n    public static function buildCondition($criteria, $concat = ' && ') {\n\n        $fn = [];\n\n        foreach ($criteria as $key => $value) {\n\n            switch($key) {\n\n                case '$and':\n\n                    $_fn = [];\n\n                    foreach ($value as $v) {\n                        $_fn[] = self::buildCondition($v, ' && ');\n                    }\n\n                    $fn[] = '('.\\implode(' && ', $_fn).')';\n\n                    break;\n                case '$or':\n\n                    $_fn = [];\n\n                    foreach ($value as $v) {\n                        $_fn[] = self::buildCondition($v, ' && ');\n                    }\n\n                    $fn[] = '('.\\implode(' || ', $_fn).')';\n\n                    break;\n\n                case '$where':\n\n                    if (\\is_callable($value)) {\n\n                        // need implementation\n                    }\n\n                    break;\n\n                default:\n\n                    $d = '$document';\n\n                    if (\\strpos($key, '.') !== false) {\n\n                        $keys = \\explode('.', $key);\n\n                        foreach ($keys as $k) {\n                            $d .= '[\\''.$k.'\\']';\n                        }\n\n                    } else {\n                        $d .= '[\\''.$key.'\\']';\n                    }\n\n                    if (\\is_array($value)) {\n                        $fn[] = \"\\\\MongoLite\\\\UtilArrayQuery::check((isset({$d}) ? {$d} : null), \".\\var_export($value, true).')';\n                    } else {\n\n                        if (is_null($value)) {\n\n                            $fn[] = \"(!isset({$d}))\";\n\n                        } else {\n\n                            $_value = \\var_export($value, true);\n\n                            $fn[] = \"(isset({$d}) && (\n                                is_array({$d}) && is_string({$_value})\n                                    ? in_array({$_value}, {$d})\n                                    : {$d}=={$_value}\n                                )\n                            )\";\n                        }\n                    }\n            }\n        }\n\n        return \\count($fn) ? \\trim(\\implode($concat, $fn)) : 'true';\n    }\n\n\n    public static function check($value, $condition) {\n\n        $keys = \\array_keys($condition);\n\n        foreach ($keys as &$key) {\n\n            if ($key == '$options') continue;\n\n            if (!self::evaluate($key, $value, $condition[$key])) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    private static function evaluate($func, $a, $b) {\n\n        $r = false;\n\n        if (\\is_null($a) && $func != '$exists') {\n            return false;\n        }\n\n        switch ($func) {\n            case '$eq' :\n                $r = $a == $b;\n                break;\n\n            case '$ne' :\n                $r = $a != $b;\n                break;\n\n            case '$gte' :\n                if ( (\\is_numeric($a) && \\is_numeric($b)) || (\\is_string($a) && \\is_string($b)) ) {\n                    $r = $a >= $b;\n                }\n                break;\n\n            case '$gt' :\n                if ( (\\is_numeric($a) && \\is_numeric($b)) || (\\is_string($a) && \\is_string($b)) ) {\n                    $r = $a > $b;\n                }\n                break;\n\n            case '$lte' :\n                if ( (\\is_numeric($a) && \\is_numeric($b)) || (\\is_string($a) && \\is_string($b)) ) {\n                    $r = $a <= $b;\n                }\n                break;\n\n            case '$lt' :\n                if ( (\\is_numeric($a) && \\is_numeric($b)) || (\\is_string($a) && \\is_string($b)) ) {\n                    $r = $a < $b;\n                }\n                break;\n\n            case '$in' :\n                if (\\is_array($a)) {\n                    $r = \\is_array($b) ? \\count(\\array_intersect($a, $b)) : false;\n                } else {\n                    $r = \\is_array($b) ? \\in_array($a, $b) : false;\n                }\n                break;\n\n            case '$nin' :\n                if (\\is_array($a)) {\n                    $r = \\is_array($b) ? (\\count(\\array_intersect($a, $b)) === 0) : false;\n                } else {\n                    $r = \\is_array($b) ? (\\in_array($a, $b) === false) : false;\n                }\n                break;\n\n            case '$has' :\n                if (\\is_array($b))\n                    throw new \\InvalidArgumentException('Invalid argument for $has array not supported');\n                if (!\\is_array($a)) $a = @\\json_decode($a, true) ?  : [];\n                $r = \\in_array($b, $a);\n                break;\n\n            case '$all' :\n                if (!\\is_array($a)) $a = @\\json_decode($a, true) ?  : [];\n                if (!\\is_array($b))\n                    throw new \\InvalidArgumentException('Invalid argument for $all option must be array');\n                $r = \\count(\\array_intersect_key($a, $b)) == \\count($b);\n                break;\n\n            case '$regex' :\n            case '$preg' :\n            case '$match' :\n            case '$not':\n                $r = (boolean) @\\preg_match(isset($b[0]) && $b[0]=='/' ? $b : '/'.$b.'/iu', $a, $match);\n                if ($func === '$not') {\n                    $r = !$r;\n                }\n                break;\n\n            case '$size' :\n                if (!\\is_array($a)) $a = @\\json_decode($a, true) ?  : [];\n                $r = (int) $b == \\count($a);\n                break;\n\n            case '$mod' :\n                if (! \\is_array($b))\n                    throw new \\InvalidArgumentException('Invalid argument for $mod option must be array');\n                $r = $a % $b[0] == $b[1] ?? 0;\n                break;\n\n            case '$func' :\n            case '$fn' :\n            case '$f' :\n                if (\\is_string($b) || !\\is_callable($b))\n                    throw new \\InvalidArgumentException('Function should be callable');\n                $r = $b($a);\n                break;\n\n            case '$exists':\n                $r = $b ? !\\is_null($a) : \\is_null($a);\n                break;\n\n            case '$fuzzy':\n            case '$text':\n\n                $distance = 3;\n                $minScore = 0.7;\n\n                if (\\is_array($b) && isset($b['$search'])) {\n\n                    if (isset($b['$minScore']) && \\is_numeric($b['$minScore'])) $minScore = $b['$minScore'];\n                    if (isset($b['$distance']) && \\is_numeric($b['$distance'])) $distance = $b['$distance'];\n\n                    $b = $b['search'];\n                }\n\n                $r = fuzzy_search($b, $a, $distance) >= $minScore;\n                break;\n\n            default :\n                throw new \\ErrorException(\"Condition not valid ... Use {$func} for custom operations\");\n                break;\n        }\n\n        return $r;\n    }\n}\n\n\n// Helper Functions\nfunction levenshtein_utf8($s1, $s2) {\n\n    $map = [];\n    $utf8_to_extended_ascii = function($str) use($map) {\n\n        // find all multibyte characters (cf. utf-8 encoding specs)\n        $matches = [];\n\n        if (!\\preg_match_all('/[\\xC0-\\xF7][\\x80-\\xBF]+/', $str, $matches)) return $str; // plain ascii string\n\n        // update the encoding map with the characters not already met\n        foreach ($matches[0] as $mbc) {\n            if (!isset($map[$mbc])) $map[$mbc] = \\chr(128 + \\count($map));\n        }\n\n        // finally remap non-ascii characters\n        return \\strtr($str, $map);\n    };\n\n    return levenshtein($utf8_to_extended_ascii($s1), $utf8_to_extended_ascii($s2));\n}\n\nfunction fuzzy_search($search, $text, $distance = 3){\n\n    $needles = \\explode(' ', \\mb_strtolower($search, 'UTF-8'));\n    $tokens  = \\explode(' ', \\mb_strtolower($text, 'UTF-8'));\n    $score   = 0;\n\n    foreach ($needles as $needle){\n\n        foreach ($tokens as $token) {\n\n            if (\\strpos($token, $needle) !== false) {\n                $score += 1;\n            } else {\n\n                $d = levenshtein_utf8($needle, $token);\n\n                if ($d <= $distance) {\n                    $l       = \\mb_strlen($token, 'UTF-8');\n                    $matches = $l - $d;\n                    $score  += ($matches / $l);\n                }\n            }\n        }\n\n    }\n\n    return $score / \\count($needles);\n}\n\nfunction createMongoDbLikeId() {\n\n    // use native MongoDB ObjectId if available\n    if (class_exists('MongoDB\\\\BSON\\\\ObjectId')) {\n        $objId = new \\MongoDB\\BSON\\ObjectId();\n        return (string)$objId;\n    }\n\n    // based on https://gist.github.com/h4cc/9b716dc05869296c1be6\n\n    $timestamp = \\microtime(true);\n    $processId = \\random_int(10000, 99999);\n    $id        = \\random_int(10, 1000);\n    $result    = '';\n\n    // Building binary data.\n    $bin = \\sprintf(\n        '%s%s%s%s',\n        \\pack('N', $timestamp),\n        \\substr(md5(uniqid()), 0, 3),\n        \\pack('n', $processId),\n        \\substr(\\pack('N', $id), 1, 3)\n    );\n\n    // Convert binary to hex.\n    for ($i = 0; $i < 12; $i++) {\n        $result .= \\sprintf('%02x', ord($bin[$i]));\n    }\n\n    return $result;\n}\n"], "fixing_code": ["<?php\n/**\n * This file is part of the Cockpit project.\n *\n * (c) Artur Heinze - \ud83c\udd70\ud83c\udd76\ud83c\udd74\ud83c\udd7d\ud83c\udd83\ud83c\udd74\ud83c\udd79\ud83c\udd7e, http://agentejo.com\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace MongoLite;\n\n/**\n * Database object.\n */\nclass Database {\n\n    /**\n     * @var string - DSN path form memory database\n     */\n    public const DSN_PATH_MEMORY = ':memory:';\n\n    /**\n     * @var PDO object\n     */\n    public $connection;\n\n    /**\n     * @var array\n     */\n    protected $collections = [];\n\n    /**\n     * @var string\n     */\n    protected $path;\n\n    /**\n     * @var array\n     */\n    protected $document_criterias = [];\n\n    /**\n     * Constructor\n     *\n     * @param string $path\n     * @param array  $options\n     */\n    public function __construct($path = self::DSN_PATH_MEMORY, $options = []) {\n\n        $dns = \"sqlite:{$path}\";\n\n        $this->path = $path;\n        $this->connection = new \\PDO($dns, null, null, $options);\n\n        $database = $this;\n\n        $this->connection->sqliteCreateFunction('document_key', function($key, $document){\n\n            $document = \\json_decode($document, true);\n            $val      = '';\n\n            if (strpos($key, '.') !== false) {\n\n                $keys = \\explode('.', $key);\n\n                switch (\\count($keys)) {\n                    case 2:\n                        $val = isset($document[$keys[0]][$keys[1]]) ? $document[$keys[0]][$keys[1]] : '';\n                        break;\n                    case 3:\n                        $val = isset($document[$keys[0]][$keys[1]][$keys[2]]) ? $document[$keys[0]][$keys[1]][$keys[2]] : '';\n                        break;\n                    default:\n                        $val = isset($document[$keys[0]]) ? $document[$keys[0]] : '';\n                }\n\n            } else {\n                $val = isset($document[$key]) ? $document[$key] : '';\n            }\n\n            return \\is_array($val) || \\is_object($val) ? \\json_encode($val) : $val;\n        }, 2);\n\n        $this->connection->sqliteCreateFunction('document_criteria', function($funcid, $document) use($database) {\n\n            $document = \\json_decode($document, true);\n\n            return $database->callCriteriaFunction($funcid, $document);\n        }, 2);\n\n        $this->connection->exec('PRAGMA journal_mode = MEMORY');\n        $this->connection->exec('PRAGMA synchronous = OFF');\n        $this->connection->exec('PRAGMA PAGE_SIZE = 4096');\n    }\n\n    /**\n     * Register Criteria function\n     *\n     * @param  mixed $criteria\n     * @return mixed\n     */\n    public function registerCriteriaFunction($criteria) {\n\n        $id = \\uniqid('criteria');\n\n        if (\\is_callable($criteria)) {\n           $this->document_criterias[$id] = $criteria;\n           return $id;\n        }\n\n        if (is_array($criteria)) {\n\n            $fn = null;\n\n            eval('$fn = function($document) { return '.UtilArrayQuery::buildCondition($criteria).'; };');\n\n            $this->document_criterias[$id] = $fn;\n\n            return $id;\n        }\n\n        return null;\n    }\n\n    /**\n     * Execute registred criteria function\n     *\n     * @param  string $id\n     * @param  array $document\n     * @return boolean\n     */\n    public function callCriteriaFunction($id, $document) {\n\n        return isset($this->document_criterias[$id]) ? $this->document_criterias[$id]($document):false;\n    }\n\n    /**\n     * Vacuum database\n     */\n    public function vacuum() {\n        $this->connection->query('VACUUM');\n    }\n\n    /**\n     * Drop database\n     */\n    public function drop() {\n        if ($this->path != static::DSN_PATH_MEMORY) {\n            \\unlink($this->path);\n        }\n    }\n\n    /**\n     * Create a collection\n     *\n     * @param  string $name\n     */\n    public function createCollection($name) {\n        $this->connection->exec(\"CREATE TABLE `{$name}` ( id INTEGER PRIMARY KEY AUTOINCREMENT, document TEXT )\");\n    }\n\n    /**\n     * Drop a collection\n     *\n     * @param  string $name\n     */\n    public function dropCollection($name) {\n        $this->connection->exec(\"DROP TABLE `{$name}`\");\n\n        // Remove collection from cache\n        unset($this->collections[$name]);\n    }\n\n    /**\n     * Get all collection names in the database\n     *\n     * @return array\n     */\n    public function getCollectionNames() {\n\n        $stmt   = $this->connection->query(\"SELECT name FROM sqlite_master WHERE type='table' AND name!='sqlite_sequence';\");\n        $tables = $stmt->fetchAll( \\PDO::FETCH_ASSOC);\n        $names  = [];\n\n        foreach ($tables as $table) {\n            $names[] = $table['name'];\n        }\n\n        return $names;\n    }\n\n    /**\n     * Get all collections in the database\n     *\n     * @return array\n     */\n    public function listCollections() {\n\n        foreach ($this->getCollectionNames() as $name) {\n            if(!isset($this->collections[$name])) {\n                $this->collections[$name] = new Collection($name, $this);\n            }\n        }\n\n        return $this->collections;\n    }\n\n    /**\n     * Select collection\n     *\n     * @param  string $name\n     * @return object\n     */\n    public function selectCollection($name) {\n\n        if (!isset($this->collections[$name])) {\n\n            if (!in_array($name, $this->getCollectionNames())) {\n                $this->createCollection($name);\n            }\n\n            $this->collections[$name] = new Collection($name, $this);\n        }\n\n        return $this->collections[$name];\n    }\n\n    public function __get($collection) {\n\n        return $this->selectCollection($collection);\n    }\n}\n\n\nclass UtilArrayQuery {\n\n    protected static $closures = [];\n\n    public static function closureCall($uid, $doc) {\n        return call_user_func_array(self::$closures[$uid], [$doc]);\n    }\n\n    public static function buildCondition($criteria, $concat = ' && ') {\n\n        $fn = [];\n\n        foreach ($criteria as $key => $value) {\n\n            switch($key) {\n\n                case '$and':\n\n                    $_fn = [];\n\n                    foreach ($value as $v) {\n                        $_fn[] = self::buildCondition($v, ' && ');\n                    }\n\n                    $fn[] = '('.\\implode(' && ', $_fn).')';\n\n                    break;\n                case '$or':\n\n                    $_fn = [];\n\n                    foreach ($value as $v) {\n                        $_fn[] = self::buildCondition($v, ' && ');\n                    }\n\n                    $fn[] = '('.\\implode(' || ', $_fn).')';\n\n                    break;\n\n                case '$where':\n\n                    if (\\is_string($value) || !\\is_callable($value)) {\n                        throw new \\InvalidArgumentException($key.' Function should be callable');\n                    }\n\n                    $uid = \\uniqid('mongoliteCallable').bin2hex(random_bytes(5));\n\n                    self::$closures[$uid] = $value;\n\n                    $fn[] = '\\\\MongoLite\\\\UtilArrayQuery::closureCall(\"'.$uid.'\", $document)';\n\n                    break;\n\n                default:\n\n                    $d = '$document';\n\n                    if (\\strpos($key, '.') !== false) {\n\n                        $keys = \\explode('.', $key);\n\n                        foreach ($keys as $k) {\n                            $d .= '[\\''.$k.'\\']';\n                        }\n\n                    } else {\n                        $d .= '[\\''.$key.'\\']';\n                    }\n\n                    if (\\is_array($value)) {\n                        $fn[] = \"\\\\MongoLite\\\\UtilArrayQuery::check((isset({$d}) ? {$d} : null), \".\\var_export($value, true).')';\n                    } else {\n\n                        if (is_null($value)) {\n\n                            $fn[] = \"(!isset({$d}))\";\n\n                        } else {\n\n                            $_value = \\var_export($value, true);\n\n                            $fn[] = \"(isset({$d}) && (\n                                is_array({$d}) && is_string({$_value})\n                                    ? in_array({$_value}, {$d})\n                                    : {$d}=={$_value}\n                                )\n                            )\";\n                        }\n                    }\n            }\n        }\n\n        return \\count($fn) ? \\trim(\\implode($concat, $fn)) : 'true';\n    }\n\n\n    public static function check($value, $condition) {\n\n        $keys = \\array_keys($condition);\n\n        foreach ($keys as &$key) {\n\n            if ($key == '$options') continue;\n\n            if (!self::evaluate($key, $value, $condition[$key])) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    private static function evaluate($func, $a, $b) {\n\n        $r = false;\n\n        if (\\is_null($a) && $func != '$exists') {\n            return false;\n        }\n\n        switch ($func) {\n            case '$eq' :\n                $r = $a == $b;\n                break;\n\n            case '$ne' :\n                $r = $a != $b;\n                break;\n\n            case '$gte' :\n                if ( (\\is_numeric($a) && \\is_numeric($b)) || (\\is_string($a) && \\is_string($b)) ) {\n                    $r = $a >= $b;\n                }\n                break;\n\n            case '$gt' :\n                if ( (\\is_numeric($a) && \\is_numeric($b)) || (\\is_string($a) && \\is_string($b)) ) {\n                    $r = $a > $b;\n                }\n                break;\n\n            case '$lte' :\n                if ( (\\is_numeric($a) && \\is_numeric($b)) || (\\is_string($a) && \\is_string($b)) ) {\n                    $r = $a <= $b;\n                }\n                break;\n\n            case '$lt' :\n                if ( (\\is_numeric($a) && \\is_numeric($b)) || (\\is_string($a) && \\is_string($b)) ) {\n                    $r = $a < $b;\n                }\n                break;\n\n            case '$in' :\n                if (\\is_array($a)) {\n                    $r = \\is_array($b) ? \\count(\\array_intersect($a, $b)) : false;\n                } else {\n                    $r = \\is_array($b) ? \\in_array($a, $b) : false;\n                }\n                break;\n\n            case '$nin' :\n                if (\\is_array($a)) {\n                    $r = \\is_array($b) ? (\\count(\\array_intersect($a, $b)) === 0) : false;\n                } else {\n                    $r = \\is_array($b) ? (\\in_array($a, $b) === false) : false;\n                }\n                break;\n\n            case '$has' :\n                if (\\is_array($b))\n                    throw new \\InvalidArgumentException('Invalid argument for $has array not supported');\n                if (!\\is_array($a)) $a = @\\json_decode($a, true) ?  : [];\n                $r = \\in_array($b, $a);\n                break;\n\n            case '$all' :\n                if (!\\is_array($a)) $a = @\\json_decode($a, true) ?  : [];\n                if (!\\is_array($b))\n                    throw new \\InvalidArgumentException('Invalid argument for $all option must be array');\n                $r = \\count(\\array_intersect_key($a, $b)) == \\count($b);\n                break;\n\n            case '$regex' :\n            case '$preg' :\n            case '$match' :\n            case '$not':\n                $r = (boolean) @\\preg_match(isset($b[0]) && $b[0]=='/' ? $b : '/'.$b.'/iu', $a, $match);\n                if ($func === '$not') {\n                    $r = !$r;\n                }\n                break;\n\n            case '$size' :\n                if (!\\is_array($a)) $a = @\\json_decode($a, true) ?  : [];\n                $r = (int) $b == \\count($a);\n                break;\n\n            case '$mod' :\n                if (! \\is_array($b))\n                    throw new \\InvalidArgumentException('Invalid argument for $mod option must be array');\n                $r = $a % $b[0] == $b[1] ?? 0;\n                break;\n\n            case '$exists':\n                $r = $b ? !\\is_null($a) : \\is_null($a);\n                break;\n\n            case '$fuzzy':\n            case '$text':\n\n                $distance = 3;\n                $minScore = 0.7;\n\n                if (\\is_array($b) && isset($b['$search'])) {\n\n                    if (isset($b['$minScore']) && \\is_numeric($b['$minScore'])) $minScore = $b['$minScore'];\n                    if (isset($b['$distance']) && \\is_numeric($b['$distance'])) $distance = $b['$distance'];\n\n                    $b = $b['search'];\n                }\n\n                $r = fuzzy_search($b, $a, $distance) >= $minScore;\n                break;\n\n            default :\n                throw new \\ErrorException(\"Condition not valid ... Use {$func} for custom operations\");\n                break;\n        }\n\n        return $r;\n    }\n}\n\n\n// Helper Functions\nfunction levenshtein_utf8($s1, $s2) {\n\n    $map = [];\n    $utf8_to_extended_ascii = function($str) use($map) {\n\n        // find all multibyte characters (cf. utf-8 encoding specs)\n        $matches = [];\n\n        if (!\\preg_match_all('/[\\xC0-\\xF7][\\x80-\\xBF]+/', $str, $matches)) return $str; // plain ascii string\n\n        // update the encoding map with the characters not already met\n        foreach ($matches[0] as $mbc) {\n            if (!isset($map[$mbc])) $map[$mbc] = \\chr(128 + \\count($map));\n        }\n\n        // finally remap non-ascii characters\n        return \\strtr($str, $map);\n    };\n\n    return levenshtein($utf8_to_extended_ascii($s1), $utf8_to_extended_ascii($s2));\n}\n\nfunction fuzzy_search($search, $text, $distance = 3){\n\n    $needles = \\explode(' ', \\mb_strtolower($search, 'UTF-8'));\n    $tokens  = \\explode(' ', \\mb_strtolower($text, 'UTF-8'));\n    $score   = 0;\n\n    foreach ($needles as $needle){\n\n        foreach ($tokens as $token) {\n\n            if (\\strpos($token, $needle) !== false) {\n                $score += 1;\n            } else {\n\n                $d = levenshtein_utf8($needle, $token);\n\n                if ($d <= $distance) {\n                    $l       = \\mb_strlen($token, 'UTF-8');\n                    $matches = $l - $d;\n                    $score  += ($matches / $l);\n                }\n            }\n        }\n\n    }\n\n    return $score / \\count($needles);\n}\n\nfunction createMongoDbLikeId() {\n\n    // use native MongoDB ObjectId if available\n    if (class_exists('MongoDB\\\\BSON\\\\ObjectId')) {\n        $objId = new \\MongoDB\\BSON\\ObjectId();\n        return (string)$objId;\n    }\n\n    // based on https://gist.github.com/h4cc/9b716dc05869296c1be6\n\n    $timestamp = \\microtime(true);\n    $processId = \\random_int(10000, 99999);\n    $id        = \\random_int(10, 1000);\n    $result    = '';\n\n    // Building binary data.\n    $bin = \\sprintf(\n        '%s%s%s%s',\n        \\pack('N', $timestamp),\n        \\substr(md5(uniqid()), 0, 3),\n        \\pack('n', $processId),\n        \\substr(\\pack('N', $id), 1, 3)\n    );\n\n    // Convert binary to hex.\n    for ($i = 0; $i < 12; $i++) {\n        $result .= \\sprintf('%02x', ord($bin[$i]));\n    }\n\n    return $result;\n}\n"], "filenames": ["lib/MongoLite/Database.php"], "buggy_code_start_loc": [237], "buggy_code_end_loc": [437], "fixing_code_start_loc": [238], "fixing_code_end_loc": [439], "type": "CWE-89", "message": "Agentejo Cockpit before 0.11.2 allows NoSQL injection via the Controller/Auth.php check function.", "other": {"cve": {"id": "CVE-2020-35846", "sourceIdentifier": "cve@mitre.org", "published": "2020-12-30T01:15:12.497", "lastModified": "2022-09-02T15:43:52.990", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Agentejo Cockpit before 0.11.2 allows NoSQL injection via the Controller/Auth.php check function."}, {"lang": "es", "value": "Agentejo Cockpit versiones anteriores a  0.11.2, permite una inyecci\u00f3n NoSQL por medio de la funci\u00f3n check del archivo Controller/Auth.php."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:agentejo:cockpit:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.11.2", "matchCriteriaId": "C8B1C7E7-483D-4B0B-9227-F5E9B1D94E68"}]}]}], "references": [{"url": "http://packetstormsecurity.com/files/162282/Cockpit-CMS-0.11.1-NoSQL-Injection-Remote-Command-Execution.html", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}, {"url": "https://getcockpit.com/", "source": "cve@mitre.org", "tags": ["Product", "Vendor Advisory"]}, {"url": "https://github.com/agentejo/cockpit/commit/2a385af8d80ed60d40d386ed813c1039db00c466", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/agentejo/cockpit/commit/33e7199575631ba1f74cba6b16b10c820bec59af", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/agentejo/cockpit/commit/79fc9631ffa29146e3124ceaf99879b92e1ef24b", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/agentejo/cockpit/commit/2a385af8d80ed60d40d386ed813c1039db00c466"}}