{"buggy_code": ["package command\n\nimport (\n\t\"context\"\n\t\"errors\"\n\n\t\"github.com/zitadel/logging\"\n\t\"github.com/zitadel/passwap\"\n\n\t\"github.com/zitadel/zitadel/internal/crypto\"\n\t\"github.com/zitadel/zitadel/internal/domain\"\n\tcaos_errs \"github.com/zitadel/zitadel/internal/errors\"\n\t\"github.com/zitadel/zitadel/internal/eventstore\"\n\t\"github.com/zitadel/zitadel/internal/repository/user\"\n\t\"github.com/zitadel/zitadel/internal/telemetry/tracing\"\n)\n\nfunc (c *Commands) SetPassword(ctx context.Context, orgID, userID, password string, oneTime bool) (objectDetails *domain.ObjectDetails, err error) {\n\tctx, span := tracing.NewSpan(ctx)\n\tdefer func() { span.EndWithError(err) }()\n\tif userID == \"\" {\n\t\treturn nil, caos_errs.ThrowInvalidArgument(nil, \"COMMAND-3M0fs\", \"Errors.IDMissing\")\n\t}\n\twm, err := c.passwordWriteModel(ctx, userID, orgID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !wm.UserState.Exists() {\n\t\treturn nil, caos_errs.ThrowPreconditionFailed(nil, \"COMMAND-3M0fs\", \"Errors.User.NotFound\")\n\t}\n\tif err = c.checkPermission(ctx, domain.PermissionUserWrite, wm.ResourceOwner, userID); err != nil {\n\t\treturn nil, err\n\t}\n\treturn c.setPassword(ctx, wm, password, oneTime)\n}\n\nfunc (c *Commands) SetPasswordWithVerifyCode(ctx context.Context, orgID, userID, code, password, userAgentID string) (objectDetails *domain.ObjectDetails, err error) {\n\tctx, span := tracing.NewSpan(ctx)\n\tdefer func() { span.EndWithError(err) }()\n\n\tif userID == \"\" {\n\t\treturn nil, caos_errs.ThrowInvalidArgument(nil, \"COMMAND-3M9fs\", \"Errors.IDMissing\")\n\t}\n\tif password == \"\" {\n\t\treturn nil, caos_errs.ThrowInvalidArgument(nil, \"COMMAND-Mf0sd\", \"Errors.User.Password.Empty\")\n\t}\n\twm, err := c.passwordWriteModel(ctx, userID, orgID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif wm.Code == nil || wm.UserState == domain.UserStateUnspecified || wm.UserState == domain.UserStateDeleted {\n\t\treturn nil, caos_errs.ThrowPreconditionFailed(nil, \"COMMAND-2M9fs\", \"Errors.User.Code.NotFound\")\n\t}\n\n\terr = crypto.VerifyCodeWithAlgorithm(wm.CodeCreationDate, wm.CodeExpiry, wm.Code, code, c.userEncryption)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn c.setPassword(ctx, wm, password, false)\n}\n\nfunc (c *Commands) setPassword(ctx context.Context, wm *HumanPasswordWriteModel, password string, changeRequired bool) (objectDetails *domain.ObjectDetails, err error) {\n\tcommand, err := c.setPasswordCommand(ctx, wm, password, changeRequired)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\terr = c.pushAppendAndReduce(ctx, wm, command)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn writeModelToObjectDetails(&wm.WriteModel), nil\n}\n\nfunc (c *Commands) setPasswordCommand(ctx context.Context, wm *HumanPasswordWriteModel, password string, changeRequired bool) (_ eventstore.Command, err error) {\n\tif err = c.canUpdatePassword(ctx, password, wm); err != nil {\n\t\treturn nil, err\n\t}\n\tctx, span := tracing.NewNamedSpan(ctx, \"passwap.Hash\")\n\tencoded, err := c.userPasswordHasher.Hash(password)\n\tspan.EndWithError(err)\n\tif err = convertPasswapErr(err); err != nil {\n\t\treturn nil, err\n\t}\n\treturn user.NewHumanPasswordChangedEvent(ctx, UserAggregateFromWriteModel(&wm.WriteModel), encoded, changeRequired, \"\"), nil\n}\n\nfunc (c *Commands) ChangePassword(ctx context.Context, orgID, userID, oldPassword, newPassword, userAgentID string) (objectDetails *domain.ObjectDetails, err error) {\n\tctx, span := tracing.NewSpan(ctx)\n\tdefer func() { span.EndWithError(err) }()\n\n\tif userID == \"\" {\n\t\treturn nil, caos_errs.ThrowInvalidArgument(nil, \"COMMAND-3M0fs\", \"Errors.IDMissing\")\n\t}\n\tif oldPassword == \"\" || newPassword == \"\" {\n\t\treturn nil, caos_errs.ThrowInvalidArgument(nil, \"COMMAND-3M0fs\", \"Errors.User.Password.Empty\")\n\t}\n\twm, err := c.passwordWriteModel(ctx, userID, orgID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif wm.EncodedHash == \"\" {\n\t\treturn nil, caos_errs.ThrowPreconditionFailed(nil, \"COMMAND-Fds3s\", \"Errors.User.Password.Empty\")\n\t}\n\tif err = c.canUpdatePassword(ctx, newPassword, wm); err != nil {\n\t\treturn nil, err\n\t}\n\n\tctx, spanPasswap := tracing.NewNamedSpan(ctx, \"passwap.VerifyAndUpdate\")\n\tupdated, err := c.userPasswordHasher.VerifyAndUpdate(wm.EncodedHash, oldPassword, newPassword)\n\tspanPasswap.EndWithError(err)\n\tif err = convertPasswapErr(err); err != nil {\n\t\treturn nil, err\n\t}\n\terr = c.pushAppendAndReduce(ctx, wm,\n\t\tuser.NewHumanPasswordChangedEvent(ctx, UserAggregateFromWriteModel(&wm.WriteModel), updated, false, userAgentID))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn writeModelToObjectDetails(&wm.WriteModel), nil\n}\n\nfunc (c *Commands) canUpdatePassword(ctx context.Context, newPassword string, wm *HumanPasswordWriteModel) (err error) {\n\tctx, span := tracing.NewSpan(ctx)\n\tdefer func() { span.EndWithError(err) }()\n\n\tif wm.UserState == domain.UserStateUnspecified || wm.UserState == domain.UserStateDeleted {\n\t\treturn caos_errs.ThrowNotFound(nil, \"COMMAND-G8dh3\", \"Errors.User.Password.NotFound\")\n\t}\n\tif wm.UserState == domain.UserStateInitial {\n\t\treturn caos_errs.ThrowPreconditionFailed(nil, \"COMMAND-M9dse\", \"Errors.User.NotInitialised\")\n\t}\n\tpolicy, err := c.getOrgPasswordComplexityPolicy(ctx, wm.ResourceOwner)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := policy.Check(newPassword); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (c *Commands) RequestSetPassword(ctx context.Context, userID, resourceOwner string, notifyType domain.NotificationType, passwordVerificationCode crypto.Generator) (objectDetails *domain.ObjectDetails, err error) {\n\tif userID == \"\" {\n\t\treturn nil, caos_errs.ThrowInvalidArgument(nil, \"COMMAND-M00oL\", \"Errors.User.UserIDMissing\")\n\t}\n\n\texistingHuman, err := c.userWriteModelByID(ctx, userID, resourceOwner)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif existingHuman.UserState == domain.UserStateUnspecified || existingHuman.UserState == domain.UserStateDeleted {\n\t\treturn nil, caos_errs.ThrowPreconditionFailed(nil, \"COMMAND-Hj9ds\", \"Errors.User.NotFound\")\n\t}\n\tif existingHuman.UserState == domain.UserStateInitial {\n\t\treturn nil, caos_errs.ThrowPreconditionFailed(nil, \"COMMAND-2M9sd\", \"Errors.User.NotInitialised\")\n\t}\n\tuserAgg := UserAggregateFromWriteModel(&existingHuman.WriteModel)\n\tpasswordCode, err := domain.NewPasswordCode(passwordVerificationCode)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpushedEvents, err := c.eventstore.Push(ctx, user.NewHumanPasswordCodeAddedEvent(ctx, userAgg, passwordCode.Code, passwordCode.Expiry, notifyType))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\terr = AppendAndReduce(existingHuman, pushedEvents...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn writeModelToObjectDetails(&existingHuman.WriteModel), nil\n}\n\nfunc (c *Commands) PasswordCodeSent(ctx context.Context, orgID, userID string) (err error) {\n\tif userID == \"\" {\n\t\treturn caos_errs.ThrowInvalidArgument(nil, \"COMMAND-meEfe\", \"Errors.User.UserIDMissing\")\n\t}\n\n\texistingPassword, err := c.passwordWriteModel(ctx, userID, orgID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif existingPassword.UserState == domain.UserStateUnspecified || existingPassword.UserState == domain.UserStateDeleted {\n\t\treturn caos_errs.ThrowPreconditionFailed(nil, \"COMMAND-3n77z\", \"Errors.User.NotFound\")\n\t}\n\tuserAgg := UserAggregateFromWriteModel(&existingPassword.WriteModel)\n\t_, err = c.eventstore.Push(ctx, user.NewHumanPasswordCodeSentEvent(ctx, userAgg))\n\treturn err\n}\n\nfunc (c *Commands) PasswordChangeSent(ctx context.Context, orgID, userID string) (err error) {\n\tif userID == \"\" {\n\t\treturn caos_errs.ThrowInvalidArgument(nil, \"COMMAND-pqlm2n\", \"Errors.User.UserIDMissing\")\n\t}\n\n\texistingPassword, err := c.passwordWriteModel(ctx, userID, orgID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif existingPassword.UserState == domain.UserStateUnspecified || existingPassword.UserState == domain.UserStateDeleted {\n\t\treturn caos_errs.ThrowPreconditionFailed(nil, \"COMMAND-x902b2v\", \"Errors.User.NotFound\")\n\t}\n\tuserAgg := UserAggregateFromWriteModel(&existingPassword.WriteModel)\n\t_, err = c.eventstore.Push(ctx, user.NewHumanPasswordChangeSentEvent(ctx, userAgg))\n\treturn err\n}\n\nfunc (c *Commands) HumanCheckPassword(ctx context.Context, orgID, userID, password string, authRequest *domain.AuthRequest, lockoutPolicy *domain.LockoutPolicy) (err error) {\n\tctx, span := tracing.NewSpan(ctx)\n\tdefer func() { span.EndWithError(err) }()\n\n\tif userID == \"\" {\n\t\treturn caos_errs.ThrowInvalidArgument(nil, \"COMMAND-4Mfsf\", \"Errors.User.UserIDMissing\")\n\t}\n\tif password == \"\" {\n\t\treturn caos_errs.ThrowInvalidArgument(nil, \"COMMAND-3n8fs\", \"Errors.User.Password.Empty\")\n\t}\n\n\tloginPolicy, err := c.getOrgLoginPolicy(ctx, orgID)\n\tif err != nil {\n\t\treturn caos_errs.ThrowPreconditionFailed(err, \"COMMAND-Edf3g\", \"Errors.Org.LoginPolicy.NotFound\")\n\t}\n\tif !loginPolicy.AllowUsernamePassword {\n\t\treturn caos_errs.ThrowPreconditionFailed(err, \"COMMAND-Dft32\", \"Errors.Org.LoginPolicy.UsernamePasswordNotAllowed\")\n\t}\n\n\twm, err := c.passwordWriteModel(ctx, userID, orgID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif wm.UserState == domain.UserStateUnspecified || wm.UserState == domain.UserStateDeleted {\n\t\treturn caos_errs.ThrowPreconditionFailed(nil, \"COMMAND-3n77z\", \"Errors.User.NotFound\")\n\t}\n\n\tif wm.EncodedHash == \"\" {\n\t\treturn caos_errs.ThrowPreconditionFailed(nil, \"COMMAND-3n77z\", \"Errors.User.Password.NotSet\")\n\t}\n\n\tuserAgg := UserAggregateFromWriteModel(&wm.WriteModel)\n\tctx, spanPasswordComparison := tracing.NewNamedSpan(ctx, \"passwap.Verify\")\n\tupdated, err := c.userPasswordHasher.Verify(wm.EncodedHash, password)\n\tspanPasswordComparison.EndWithError(err)\n\terr = convertPasswapErr(err)\n\n\tcommands := make([]eventstore.Command, 0, 2)\n\tif err == nil {\n\t\tcommands = append(commands, user.NewHumanPasswordCheckSucceededEvent(ctx, userAgg, authRequestDomainToAuthRequestInfo(authRequest)))\n\t\tif updated != \"\" {\n\t\t\tcommands = append(commands, user.NewHumanPasswordHashUpdatedEvent(ctx, userAgg, updated))\n\t\t}\n\t\t_, err = c.eventstore.Push(ctx, commands...)\n\t\treturn err\n\t}\n\n\tcommands = append(commands, user.NewHumanPasswordCheckFailedEvent(ctx, userAgg, authRequestDomainToAuthRequestInfo(authRequest)))\n\tif lockoutPolicy != nil && lockoutPolicy.MaxPasswordAttempts > 0 {\n\t\tif wm.PasswordCheckFailedCount+1 >= lockoutPolicy.MaxPasswordAttempts {\n\t\t\tcommands = append(commands, user.NewUserLockedEvent(ctx, userAgg))\n\t\t}\n\n\t}\n\t_, pushErr := c.eventstore.Push(ctx, commands...)\n\tlogging.OnError(pushErr).Error(\"error create password check failed event\")\n\treturn err\n}\n\nfunc (c *Commands) passwordWriteModel(ctx context.Context, userID, resourceOwner string) (writeModel *HumanPasswordWriteModel, err error) {\n\tctx, span := tracing.NewSpan(ctx)\n\tdefer func() { span.EndWithError(err) }()\n\n\twriteModel = NewHumanPasswordWriteModel(userID, resourceOwner)\n\terr = c.eventstore.FilterToQueryReducer(ctx, writeModel)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn writeModel, nil\n}\n\nfunc convertPasswapErr(err error) error {\n\tif err == nil {\n\t\treturn nil\n\t}\n\tif errors.Is(err, passwap.ErrPasswordMismatch) {\n\t\treturn caos_errs.ThrowInvalidArgument(err, \"COMMAND-3M0fs\", \"Errors.User.Password.Invalid\")\n\t}\n\tif errors.Is(err, passwap.ErrPasswordNoChange) {\n\t\treturn caos_errs.ThrowPreconditionFailed(err, \"COMMAND-Aesh5\", \"Errors.User.Password.NotChanged\")\n\t}\n\treturn caos_errs.ThrowInternal(err, \"COMMAND-CahN2\", \"Errors.Internal\")\n}\n", "package command\n\nimport (\n\t\"time\"\n\n\t\"github.com/zitadel/zitadel/internal/eventstore\"\n\n\t\"github.com/zitadel/zitadel/internal/crypto\"\n\t\"github.com/zitadel/zitadel/internal/domain\"\n\t\"github.com/zitadel/zitadel/internal/repository/user\"\n)\n\ntype HumanPasswordWriteModel struct {\n\teventstore.WriteModel\n\n\tEncodedHash          string\n\tSecretChangeRequired bool\n\n\tCode                     *crypto.CryptoValue\n\tCodeCreationDate         time.Time\n\tCodeExpiry               time.Duration\n\tPasswordCheckFailedCount uint64\n\n\tUserState domain.UserState\n}\n\nfunc NewHumanPasswordWriteModel(userID, resourceOwner string) *HumanPasswordWriteModel {\n\treturn &HumanPasswordWriteModel{\n\t\tWriteModel: eventstore.WriteModel{\n\t\t\tAggregateID:   userID,\n\t\t\tResourceOwner: resourceOwner,\n\t\t},\n\t}\n}\n\nfunc (wm *HumanPasswordWriteModel) Reduce() error {\n\tfor _, event := range wm.Events {\n\t\tswitch e := event.(type) {\n\t\tcase *user.HumanAddedEvent:\n\t\t\twm.EncodedHash = user.SecretOrEncodedHash(e.Secret, e.EncodedHash)\n\t\t\twm.SecretChangeRequired = e.ChangeRequired\n\t\t\twm.UserState = domain.UserStateActive\n\t\tcase *user.HumanRegisteredEvent:\n\t\t\twm.EncodedHash = user.SecretOrEncodedHash(e.Secret, e.EncodedHash)\n\t\t\twm.SecretChangeRequired = e.ChangeRequired\n\t\t\twm.UserState = domain.UserStateActive\n\t\tcase *user.HumanInitialCodeAddedEvent:\n\t\t\twm.UserState = domain.UserStateInitial\n\t\tcase *user.HumanInitializedCheckSucceededEvent:\n\t\t\twm.UserState = domain.UserStateActive\n\t\tcase *user.HumanPasswordChangedEvent:\n\t\t\twm.EncodedHash = user.SecretOrEncodedHash(e.Secret, e.EncodedHash)\n\t\t\twm.SecretChangeRequired = e.ChangeRequired\n\t\t\twm.Code = nil\n\t\t\twm.PasswordCheckFailedCount = 0\n\t\tcase *user.HumanPasswordCodeAddedEvent:\n\t\t\twm.Code = e.Code\n\t\t\twm.CodeCreationDate = e.CreationDate()\n\t\t\twm.CodeExpiry = e.Expiry\n\t\tcase *user.HumanEmailVerifiedEvent:\n\t\t\tif wm.UserState == domain.UserStateInitial {\n\t\t\t\twm.UserState = domain.UserStateActive\n\t\t\t}\n\t\tcase *user.HumanPasswordCheckFailedEvent:\n\t\t\twm.PasswordCheckFailedCount += 1\n\t\tcase *user.HumanPasswordCheckSucceededEvent:\n\t\t\twm.PasswordCheckFailedCount = 0\n\t\tcase *user.UserUnlockedEvent:\n\t\t\twm.PasswordCheckFailedCount = 0\n\t\tcase *user.UserRemovedEvent:\n\t\t\twm.UserState = domain.UserStateDeleted\n\t\tcase *user.HumanPasswordHashUpdatedEvent:\n\t\t\twm.EncodedHash = e.EncodedHash\n\t\t}\n\t}\n\treturn wm.WriteModel.Reduce()\n}\n\nfunc (wm *HumanPasswordWriteModel) Query() *eventstore.SearchQueryBuilder {\n\tquery := eventstore.NewSearchQueryBuilder(eventstore.ColumnsEvent).\n\t\tAddQuery().\n\t\tAggregateTypes(user.AggregateType).\n\t\tAggregateIDs(wm.AggregateID).\n\t\tEventTypes(user.HumanAddedType,\n\t\t\tuser.HumanRegisteredType,\n\t\t\tuser.HumanInitialCodeAddedType,\n\t\t\tuser.HumanInitializedCheckSucceededType,\n\t\t\tuser.HumanPasswordChangedType,\n\t\t\tuser.HumanPasswordCodeAddedType,\n\t\t\tuser.HumanEmailVerifiedType,\n\t\t\tuser.HumanPasswordCheckFailedType,\n\t\t\tuser.HumanPasswordCheckSucceededType,\n\t\t\tuser.HumanPasswordHashUpdatedType,\n\t\t\tuser.UserRemovedType,\n\t\t\tuser.UserUnlockedType,\n\t\t\tuser.UserV1AddedType,\n\t\t\tuser.UserV1RegisteredType,\n\t\t\tuser.UserV1InitialCodeAddedType,\n\t\t\tuser.UserV1InitializedCheckSucceededType,\n\t\t\tuser.UserV1PasswordChangedType,\n\t\t\tuser.UserV1PasswordCodeAddedType,\n\t\t\tuser.UserV1EmailVerifiedType,\n\t\t\tuser.UserV1PasswordCheckFailedType,\n\t\t\tuser.UserV1PasswordCheckSucceededType,\n\t\t).\n\t\tBuilder()\n\n\tif wm.ResourceOwner != \"\" {\n\t\tquery.ResourceOwner(wm.ResourceOwner)\n\t}\n\treturn query\n}\n", "package command\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"io\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/golang/mock/gomock\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/zitadel/passwap\"\n\t\"golang.org/x/text/language\"\n\n\t\"github.com/zitadel/zitadel/internal/crypto\"\n\t\"github.com/zitadel/zitadel/internal/domain\"\n\tcaos_errs \"github.com/zitadel/zitadel/internal/errors\"\n\t\"github.com/zitadel/zitadel/internal/eventstore\"\n\t\"github.com/zitadel/zitadel/internal/repository/org\"\n\t\"github.com/zitadel/zitadel/internal/repository/user\"\n)\n\nfunc TestCommandSide_SetOneTimePassword(t *testing.T) {\n\ttype fields struct {\n\t\teventstore         *eventstore.Eventstore\n\t\tuserPasswordHasher *crypto.PasswordHasher\n\t\tcheckPermission    domain.PermissionCheck\n\t}\n\ttype args struct {\n\t\tctx           context.Context\n\t\tuserID        string\n\t\tresourceOwner string\n\t\tpassword      string\n\t\toneTime       bool\n\t}\n\ttype res struct {\n\t\twant *domain.ObjectDetails\n\t\terr  func(error) bool\n\t}\n\ttests := []struct {\n\t\tname   string\n\t\tfields fields\n\t\targs   args\n\t\tres    res\n\t}{\n\t\t{\n\t\t\tname: \"userid missing, invalid argument error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(\n\t\t\t\t\tt,\n\t\t\t\t),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsErrorInvalidArgument,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"user not existing, precondition error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(\n\t\t\t\t\tt,\n\t\t\t\t\texpectFilter(),\n\t\t\t\t),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tuserID:        \"user1\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsPreconditionFailed,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"missing permission, error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(\n\t\t\t\t\tt,\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanAddedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\t\"username\",\n\t\t\t\t\t\t\t\t\"firstname\",\n\t\t\t\t\t\t\t\t\"lastname\",\n\t\t\t\t\t\t\t\t\"nickname\",\n\t\t\t\t\t\t\t\t\"displayname\",\n\t\t\t\t\t\t\t\tlanguage.German,\n\t\t\t\t\t\t\t\tdomain.GenderUnspecified,\n\t\t\t\t\t\t\t\t\"email@test.ch\",\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanEmailVerifiedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\tuserPasswordHasher: mockPasswordHasher(\"x\"),\n\t\t\t\tcheckPermission:    newMockPermissionCheckNotAllowed(),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tuserID:        \"user1\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t\tpassword:      \"password\",\n\t\t\t\toneTime:       true,\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: func(err error) bool {\n\t\t\t\t\treturn errors.Is(err, caos_errs.ThrowPermissionDenied(nil, \"AUTHZ-HKJD33\", \"Errors.PermissionDenied\"))\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"change password onetime, ok\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(\n\t\t\t\t\tt,\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanAddedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\t\"username\",\n\t\t\t\t\t\t\t\t\"firstname\",\n\t\t\t\t\t\t\t\t\"lastname\",\n\t\t\t\t\t\t\t\t\"nickname\",\n\t\t\t\t\t\t\t\t\"displayname\",\n\t\t\t\t\t\t\t\tlanguage.German,\n\t\t\t\t\t\t\t\tdomain.GenderUnspecified,\n\t\t\t\t\t\t\t\t\"email@test.ch\",\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanEmailVerifiedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\torg.NewPasswordComplexityPolicyAddedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t\texpectPush(\n\t\t\t\t\t\tuser.NewHumanPasswordChangedEvent(context.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\"$plain$x$password\",\n\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t\"\",\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\tuserPasswordHasher: mockPasswordHasher(\"x\"),\n\t\t\t\tcheckPermission:    newMockPermissionCheckAllowed(),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tuserID:        \"user1\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t\tpassword:      \"password\",\n\t\t\t\toneTime:       true,\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\twant: &domain.ObjectDetails{\n\t\t\t\t\tResourceOwner: \"org1\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"change password no one time, ok\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(\n\t\t\t\t\tt,\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanAddedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\t\"username\",\n\t\t\t\t\t\t\t\t\"firstname\",\n\t\t\t\t\t\t\t\t\"lastname\",\n\t\t\t\t\t\t\t\t\"nickname\",\n\t\t\t\t\t\t\t\t\"displayname\",\n\t\t\t\t\t\t\t\tlanguage.German,\n\t\t\t\t\t\t\t\tdomain.GenderUnspecified,\n\t\t\t\t\t\t\t\t\"email@test.ch\",\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanEmailVerifiedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\torg.NewPasswordComplexityPolicyAddedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t\texpectPush(\n\t\t\t\t\t\tuser.NewHumanPasswordChangedEvent(context.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\"$plain$x$password\",\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\"\",\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\tuserPasswordHasher: mockPasswordHasher(\"x\"),\n\t\t\t\tcheckPermission:    newMockPermissionCheckAllowed(),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tuserID:        \"user1\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t\tpassword:      \"password\",\n\t\t\t\toneTime:       false,\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\twant: &domain.ObjectDetails{\n\t\t\t\t\tResourceOwner: \"org1\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tr := &Commands{\n\t\t\t\teventstore:         tt.fields.eventstore,\n\t\t\t\tuserPasswordHasher: tt.fields.userPasswordHasher,\n\t\t\t\tcheckPermission:    tt.fields.checkPermission,\n\t\t\t}\n\t\t\tgot, err := r.SetPassword(tt.args.ctx, tt.args.resourceOwner, tt.args.userID, tt.args.password, tt.args.oneTime)\n\t\t\tif tt.res.err == nil {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t\tif tt.res.err != nil && !tt.res.err(err) {\n\t\t\t\tt.Errorf(\"got wrong err: %v \", err)\n\t\t\t}\n\t\t\tif tt.res.err == nil {\n\t\t\t\tassert.Equal(t, tt.res.want, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestCommandSide_SetPasswordWithVerifyCode(t *testing.T) {\n\ttype fields struct {\n\t\teventstore         *eventstore.Eventstore\n\t\tuserEncryption     crypto.EncryptionAlgorithm\n\t\tuserPasswordHasher *crypto.PasswordHasher\n\t}\n\ttype args struct {\n\t\tctx           context.Context\n\t\tuserID        string\n\t\tcode          string\n\t\tresourceOwner string\n\t\tpassword      string\n\t\tagentID       string\n\t}\n\ttype res struct {\n\t\twant *domain.ObjectDetails\n\t\terr  func(error) bool\n\t}\n\ttests := []struct {\n\t\tname   string\n\t\tfields fields\n\t\targs   args\n\t\tres    res\n\t}{\n\t\t{\n\t\t\tname: \"userid missing, invalid argument error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(\n\t\t\t\t\tt,\n\t\t\t\t),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsErrorInvalidArgument,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"password missing, invalid argument error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(\n\t\t\t\t\tt,\n\t\t\t\t),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tuserID:        \"user1\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsErrorInvalidArgument,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"user not existing, precondition error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(\n\t\t\t\t\tt,\n\t\t\t\t\texpectFilter(),\n\t\t\t\t),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tuserID:        \"user1\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t\tpassword:      \"password\",\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsPreconditionFailed,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"code not existing, precondition error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(\n\t\t\t\t\tt,\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanAddedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\t\"username\",\n\t\t\t\t\t\t\t\t\"firstname\",\n\t\t\t\t\t\t\t\t\"lastname\",\n\t\t\t\t\t\t\t\t\"nickname\",\n\t\t\t\t\t\t\t\t\"displayname\",\n\t\t\t\t\t\t\t\tlanguage.German,\n\t\t\t\t\t\t\t\tdomain.GenderUnspecified,\n\t\t\t\t\t\t\t\t\"email@test.ch\",\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tuserID:        \"user1\",\n\t\t\t\tcode:          \"aa\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t\tpassword:      \"string\",\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsPreconditionFailed,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"invalid code, invalid argument error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(\n\t\t\t\t\tt,\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanAddedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\t\"username\",\n\t\t\t\t\t\t\t\t\"firstname\",\n\t\t\t\t\t\t\t\t\"lastname\",\n\t\t\t\t\t\t\t\t\"nickname\",\n\t\t\t\t\t\t\t\t\"displayname\",\n\t\t\t\t\t\t\t\tlanguage.German,\n\t\t\t\t\t\t\t\tdomain.GenderUnspecified,\n\t\t\t\t\t\t\t\t\"email@test.ch\",\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanPasswordCodeAddedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\t&crypto.CryptoValue{\n\t\t\t\t\t\t\t\t\tCryptoType: crypto.TypeEncryption,\n\t\t\t\t\t\t\t\t\tAlgorithm:  \"enc\",\n\t\t\t\t\t\t\t\t\tKeyID:      \"id\",\n\t\t\t\t\t\t\t\t\tCrypted:    []byte(\"a\"),\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\ttime.Hour*1,\n\t\t\t\t\t\t\t\tdomain.NotificationTypeEmail,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\tuserEncryption: crypto.CreateMockEncryptionAlg(gomock.NewController(t)),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tuserID:        \"user1\",\n\t\t\t\tcode:          \"test\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t\tpassword:      \"password\",\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsPreconditionFailed,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"set password, ok\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(\n\t\t\t\t\tt,\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanAddedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\t\"username\",\n\t\t\t\t\t\t\t\t\"firstname\",\n\t\t\t\t\t\t\t\t\"lastname\",\n\t\t\t\t\t\t\t\t\"nickname\",\n\t\t\t\t\t\t\t\t\"displayname\",\n\t\t\t\t\t\t\t\tlanguage.German,\n\t\t\t\t\t\t\t\tdomain.GenderUnspecified,\n\t\t\t\t\t\t\t\t\"email@test.ch\",\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanEmailVerifiedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\teventFromEventPusherWithCreationDateNow(\n\t\t\t\t\t\t\tuser.NewHumanPasswordCodeAddedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\t&crypto.CryptoValue{\n\t\t\t\t\t\t\t\t\tCryptoType: crypto.TypeEncryption,\n\t\t\t\t\t\t\t\t\tAlgorithm:  \"enc\",\n\t\t\t\t\t\t\t\t\tKeyID:      \"id\",\n\t\t\t\t\t\t\t\t\tCrypted:    []byte(\"a\"),\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\ttime.Hour*1,\n\t\t\t\t\t\t\t\tdomain.NotificationTypeEmail,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\torg.NewPasswordComplexityPolicyAddedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t\texpectPush(\n\t\t\t\t\t\tuser.NewHumanPasswordChangedEvent(context.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\"$plain$x$password\",\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\"\",\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\tuserPasswordHasher: mockPasswordHasher(\"x\"),\n\t\t\t\tuserEncryption:     crypto.CreateMockEncryptionAlg(gomock.NewController(t)),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tuserID:        \"user1\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t\tpassword:      \"password\",\n\t\t\t\tcode:          \"a\",\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\twant: &domain.ObjectDetails{\n\t\t\t\t\tResourceOwner: \"org1\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tr := &Commands{\n\t\t\t\teventstore:         tt.fields.eventstore,\n\t\t\t\tuserPasswordHasher: tt.fields.userPasswordHasher,\n\t\t\t\tuserEncryption:     tt.fields.userEncryption,\n\t\t\t}\n\t\t\tgot, err := r.SetPasswordWithVerifyCode(tt.args.ctx, tt.args.resourceOwner, tt.args.userID, tt.args.code, tt.args.password, tt.args.agentID)\n\t\t\tif tt.res.err == nil {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t\tif tt.res.err != nil && !tt.res.err(err) {\n\t\t\t\tt.Errorf(\"got wrong err: %v \", err)\n\t\t\t}\n\t\t\tif tt.res.err == nil {\n\t\t\t\tassert.Equal(t, tt.res.want, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestCommandSide_ChangePassword(t *testing.T) {\n\ttype fields struct {\n\t\tuserPasswordHasher *crypto.PasswordHasher\n\t}\n\ttype args struct {\n\t\tctx           context.Context\n\t\tuserID        string\n\t\tresourceOwner string\n\t\toldPassword   string\n\t\tnewPassword   string\n\t\tagentID       string\n\t}\n\ttype res struct {\n\t\twant *domain.ObjectDetails\n\t\terr  func(error) bool\n\t}\n\ttests := []struct {\n\t\tname   string\n\t\tfields fields\n\t\targs   args\n\t\texpect []expect\n\t\tres    res\n\t}{\n\t\t{\n\t\t\tname:   \"userid missing, invalid argument error\",\n\t\t\tfields: fields{},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\toldPassword:   \"password\",\n\t\t\t\tnewPassword:   \"password1\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t},\n\t\t\texpect: []expect{},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsErrorInvalidArgument,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:   \"old password missing, invalid argument error\",\n\t\t\tfields: fields{},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tuserID:        \"user1\",\n\t\t\t\tnewPassword:   \"password1\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t},\n\t\t\texpect: []expect{},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsErrorInvalidArgument,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:   \"new password missing, invalid argument error\",\n\t\t\tfields: fields{},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tuserID:        \"user1\",\n\t\t\t\toldPassword:   \"password\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t},\n\t\t\texpect: []expect{},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsErrorInvalidArgument,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:   \"user not existing, precondition error\",\n\t\t\tfields: fields{},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tuserID:        \"user1\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t\toldPassword:   \"password\",\n\t\t\t\tnewPassword:   \"password1\",\n\t\t\t},\n\t\t\texpect: []expect{\n\t\t\t\texpectFilter(),\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsPreconditionFailed,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"existing password empty, precondition error\",\n\t\t\tfields: fields{\n\t\t\t\tuserPasswordHasher: mockPasswordHasher(\"x\"),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tuserID:        \"user1\",\n\t\t\t\toldPassword:   \"password\",\n\t\t\t\tnewPassword:   \"password1\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t},\n\t\t\texpect: []expect{\n\t\t\t\texpectFilter(\n\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\tuser.NewHumanAddedEvent(context.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\"username\",\n\t\t\t\t\t\t\t\"firstname\",\n\t\t\t\t\t\t\t\"lastname\",\n\t\t\t\t\t\t\t\"nickname\",\n\t\t\t\t\t\t\t\"displayname\",\n\t\t\t\t\t\t\tlanguage.German,\n\t\t\t\t\t\t\tdomain.GenderUnspecified,\n\t\t\t\t\t\t\t\"email@test.ch\",\n\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsPreconditionFailed,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"password not matching, invalid argument error\",\n\t\t\tfields: fields{\n\t\t\t\tuserPasswordHasher: mockPasswordHasher(\"x\"),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tuserID:        \"user1\",\n\t\t\t\toldPassword:   \"password-old\",\n\t\t\t\tnewPassword:   \"password1\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t},\n\t\t\texpect: []expect{\n\t\t\t\texpectFilter(\n\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\tuser.NewHumanAddedEvent(context.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\"username\",\n\t\t\t\t\t\t\t\"firstname\",\n\t\t\t\t\t\t\t\"lastname\",\n\t\t\t\t\t\t\t\"nickname\",\n\t\t\t\t\t\t\t\"displayname\",\n\t\t\t\t\t\t\tlanguage.German,\n\t\t\t\t\t\t\tdomain.GenderUnspecified,\n\t\t\t\t\t\t\t\"email@test.ch\",\n\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\tuser.NewHumanEmailVerifiedEvent(context.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\tuser.NewHumanPasswordChangedEvent(context.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\"$plain$x$password\",\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\"\")),\n\t\t\t\t),\n\t\t\t\texpectFilter(\n\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\torg.NewPasswordComplexityPolicyAddedEvent(context.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsErrorInvalidArgument,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"change password, ok\",\n\t\t\tfields: fields{\n\t\t\t\tuserPasswordHasher: mockPasswordHasher(\"x\"),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tuserID:        \"user1\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t\toldPassword:   \"password\",\n\t\t\t\tnewPassword:   \"password1\",\n\t\t\t},\n\t\t\texpect: []expect{\n\t\t\t\texpectFilter(\n\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\tuser.NewHumanAddedEvent(context.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\"username\",\n\t\t\t\t\t\t\t\"firstname\",\n\t\t\t\t\t\t\t\"lastname\",\n\t\t\t\t\t\t\t\"nickname\",\n\t\t\t\t\t\t\t\"displayname\",\n\t\t\t\t\t\t\tlanguage.German,\n\t\t\t\t\t\t\tdomain.GenderUnspecified,\n\t\t\t\t\t\t\t\"email@test.ch\",\n\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\tuser.NewHumanEmailVerifiedEvent(context.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\tuser.NewHumanPasswordChangedEvent(context.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\"$plain$x$password\",\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\"\")),\n\t\t\t\t),\n\t\t\t\texpectFilter(\n\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\torg.NewPasswordComplexityPolicyAddedEvent(context.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\texpectPush(\n\t\t\t\t\tuser.NewHumanPasswordChangedEvent(context.Background(),\n\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\"$plain$x$password1\",\n\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\"\",\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\twant: &domain.ObjectDetails{\n\t\t\t\t\tResourceOwner: \"org1\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tr := &Commands{\n\t\t\t\teventstore:         eventstoreExpect(t, tt.expect...),\n\t\t\t\tuserPasswordHasher: tt.fields.userPasswordHasher,\n\t\t\t}\n\t\t\tgot, err := r.ChangePassword(tt.args.ctx, tt.args.resourceOwner, tt.args.userID, tt.args.oldPassword, tt.args.newPassword, tt.args.agentID)\n\t\t\tif tt.res.err == nil {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t\tif tt.res.err != nil && !tt.res.err(err) {\n\t\t\t\tt.Errorf(\"got wrong err: %v \", err)\n\t\t\t}\n\t\t\tif tt.res.err == nil {\n\t\t\t\tassert.Equal(t, tt.res.want, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestCommandSide_RequestSetPassword(t *testing.T) {\n\ttype fields struct {\n\t\teventstore *eventstore.Eventstore\n\t}\n\ttype args struct {\n\t\tctx             context.Context\n\t\tuserID          string\n\t\tresourceOwner   string\n\t\tnotifyType      domain.NotificationType\n\t\tsecretGenerator crypto.Generator\n\t}\n\ttype res struct {\n\t\twant *domain.ObjectDetails\n\t\terr  func(error) bool\n\t}\n\ttests := []struct {\n\t\tname   string\n\t\tfields fields\n\t\targs   args\n\t\tres    res\n\t}{\n\t\t{\n\t\t\tname: \"userid missing, invalid argument error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(\n\t\t\t\t\tt,\n\t\t\t\t),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsErrorInvalidArgument,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"user not existing, precondition error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(\n\t\t\t\t\tt,\n\t\t\t\t\texpectFilter(),\n\t\t\t\t),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tuserID:        \"user1\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsPreconditionFailed,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"user initial, precondition error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(\n\t\t\t\t\tt,\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanAddedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\t\"username\",\n\t\t\t\t\t\t\t\t\"firstname\",\n\t\t\t\t\t\t\t\t\"lastname\",\n\t\t\t\t\t\t\t\t\"nickname\",\n\t\t\t\t\t\t\t\t\"displayname\",\n\t\t\t\t\t\t\t\tlanguage.German,\n\t\t\t\t\t\t\t\tdomain.GenderUnspecified,\n\t\t\t\t\t\t\t\t\"email@test.ch\",\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanInitialCodeAddedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\tnil, time.Hour*1,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanPhoneChangedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\t\"+411234567\",\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanPhoneVerifiedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tuserID:        \"user1\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsPreconditionFailed,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"new code, ok\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(\n\t\t\t\t\tt,\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanAddedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\t\"username\",\n\t\t\t\t\t\t\t\t\"firstname\",\n\t\t\t\t\t\t\t\t\"lastname\",\n\t\t\t\t\t\t\t\t\"nickname\",\n\t\t\t\t\t\t\t\t\"displayname\",\n\t\t\t\t\t\t\t\tlanguage.German,\n\t\t\t\t\t\t\t\tdomain.GenderUnspecified,\n\t\t\t\t\t\t\t\t\"email@test.ch\",\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanEmailVerifiedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanInitializedCheckSucceededEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate)),\n\t\t\t\t\t),\n\t\t\t\t\texpectPush(\n\t\t\t\t\t\tuser.NewHumanPasswordCodeAddedEvent(context.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t&crypto.CryptoValue{\n\t\t\t\t\t\t\t\tCryptoType: crypto.TypeEncryption,\n\t\t\t\t\t\t\t\tAlgorithm:  \"enc\",\n\t\t\t\t\t\t\t\tKeyID:      \"id\",\n\t\t\t\t\t\t\t\tCrypted:    []byte(\"a\"),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\ttime.Hour*1,\n\t\t\t\t\t\t\tdomain.NotificationTypeEmail,\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:             context.Background(),\n\t\t\t\tuserID:          \"user1\",\n\t\t\t\tresourceOwner:   \"org1\",\n\t\t\t\tsecretGenerator: GetMockSecretGenerator(t),\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\twant: &domain.ObjectDetails{\n\t\t\t\t\tResourceOwner: \"org1\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tr := &Commands{\n\t\t\t\teventstore: tt.fields.eventstore,\n\t\t\t}\n\t\t\tgot, err := r.RequestSetPassword(tt.args.ctx, tt.args.userID, tt.args.resourceOwner, tt.args.notifyType, tt.args.secretGenerator)\n\t\t\tif tt.res.err == nil {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t\tif tt.res.err != nil && !tt.res.err(err) {\n\t\t\t\tt.Errorf(\"got wrong err: %v \", err)\n\t\t\t}\n\t\t\tif tt.res.err == nil {\n\t\t\t\tassert.Equal(t, tt.res.want, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestCommandSide_PasswordCodeSent(t *testing.T) {\n\ttype fields struct {\n\t\teventstore *eventstore.Eventstore\n\t}\n\ttype args struct {\n\t\tctx           context.Context\n\t\tuserID        string\n\t\tresourceOwner string\n\t}\n\ttype res struct {\n\t\terr func(error) bool\n\t}\n\ttests := []struct {\n\t\tname   string\n\t\tfields fields\n\t\targs   args\n\t\tres    res\n\t}{\n\t\t{\n\t\t\tname: \"userid missing, invalid argument error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(\n\t\t\t\t\tt,\n\t\t\t\t),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsErrorInvalidArgument,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"user not existing, precondition error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(\n\t\t\t\t\tt,\n\t\t\t\t\texpectFilter(),\n\t\t\t\t),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tuserID:        \"user1\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsPreconditionFailed,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"code sent, ok\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(\n\t\t\t\t\tt,\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanAddedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\t\"username\",\n\t\t\t\t\t\t\t\t\"firstname\",\n\t\t\t\t\t\t\t\t\"lastname\",\n\t\t\t\t\t\t\t\t\"nickname\",\n\t\t\t\t\t\t\t\t\"displayname\",\n\t\t\t\t\t\t\t\tlanguage.German,\n\t\t\t\t\t\t\t\tdomain.GenderUnspecified,\n\t\t\t\t\t\t\t\t\"email@test.ch\",\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanPhoneChangedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\t\"+411234567\",\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t\texpectPush(\n\t\t\t\t\t\tuser.NewHumanPasswordCodeSentEvent(context.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tuserID:        \"user1\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t},\n\t\t\tres: res{},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tr := &Commands{\n\t\t\t\teventstore: tt.fields.eventstore,\n\t\t\t}\n\t\t\terr := r.PasswordCodeSent(tt.args.ctx, tt.args.resourceOwner, tt.args.userID)\n\t\t\tif tt.res.err == nil {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t\tif tt.res.err != nil && !tt.res.err(err) {\n\t\t\t\tt.Errorf(\"got wrong err: %v \", err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestCommandSide_CheckPassword(t *testing.T) {\n\ttype fields struct {\n\t\teventstore         *eventstore.Eventstore\n\t\tuserPasswordHasher *crypto.PasswordHasher\n\t}\n\ttype args struct {\n\t\tctx           context.Context\n\t\tuserID        string\n\t\tresourceOwner string\n\t\tpassword      string\n\t\tauthReq       *domain.AuthRequest\n\t\tlockoutPolicy *domain.LockoutPolicy\n\t}\n\ttype res struct {\n\t\terr func(error) bool\n\t}\n\ttests := []struct {\n\t\tname   string\n\t\tfields fields\n\t\targs   args\n\t\tres    res\n\t}{\n\t\t{\n\t\t\tname: \"userid missing, invalid argument error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(\n\t\t\t\t\tt,\n\t\t\t\t),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tpassword:      \"password\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsErrorInvalidArgument,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"password missing, invalid argument error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(\n\t\t\t\t\tt,\n\t\t\t\t),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tuserID:        \"user1\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsErrorInvalidArgument,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"login policy not found, precondition error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(\n\t\t\t\t\tt,\n\t\t\t\t\texpectFilter(),\n\t\t\t\t\texpectFilter(),\n\t\t\t\t),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tuserID:        \"user1\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t\tpassword:      \"password\",\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsPreconditionFailed,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"login policy login password not allowed, precondition error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(\n\t\t\t\t\tt,\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\torg.NewLoginPolicyAddedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&org.NewAggregate(\"org1\").Aggregate,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tdomain.PasswordlessTypeNotAllowed,\n\t\t\t\t\t\t\t\t\"\",\n\t\t\t\t\t\t\t\ttime.Hour*1,\n\t\t\t\t\t\t\t\ttime.Hour*2,\n\t\t\t\t\t\t\t\ttime.Hour*3,\n\t\t\t\t\t\t\t\ttime.Hour*4,\n\t\t\t\t\t\t\t\ttime.Hour*5,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tuserID:        \"user1\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t\tpassword:      \"password\",\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsPreconditionFailed,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"user not existing, precondition error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(\n\t\t\t\t\tt,\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\torg.NewLoginPolicyAddedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&org.NewAggregate(\"org1\").Aggregate,\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tdomain.PasswordlessTypeNotAllowed,\n\t\t\t\t\t\t\t\t\"\",\n\t\t\t\t\t\t\t\ttime.Hour*1,\n\t\t\t\t\t\t\t\ttime.Hour*2,\n\t\t\t\t\t\t\t\ttime.Hour*3,\n\t\t\t\t\t\t\t\ttime.Hour*4,\n\t\t\t\t\t\t\t\ttime.Hour*5,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t\texpectFilter(),\n\t\t\t\t),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tuserID:        \"user1\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t\tpassword:      \"password\",\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsPreconditionFailed,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"existing password empty, precondition error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(\n\t\t\t\t\tt,\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\torg.NewLoginPolicyAddedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&org.NewAggregate(\"org1\").Aggregate,\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tdomain.PasswordlessTypeNotAllowed,\n\t\t\t\t\t\t\t\t\"\",\n\t\t\t\t\t\t\t\ttime.Hour*1,\n\t\t\t\t\t\t\t\ttime.Hour*2,\n\t\t\t\t\t\t\t\ttime.Hour*3,\n\t\t\t\t\t\t\t\ttime.Hour*4,\n\t\t\t\t\t\t\t\ttime.Hour*5,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanAddedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\t\"username\",\n\t\t\t\t\t\t\t\t\"firstname\",\n\t\t\t\t\t\t\t\t\"lastname\",\n\t\t\t\t\t\t\t\t\"nickname\",\n\t\t\t\t\t\t\t\t\"displayname\",\n\t\t\t\t\t\t\t\tlanguage.German,\n\t\t\t\t\t\t\t\tdomain.GenderUnspecified,\n\t\t\t\t\t\t\t\t\"email@test.ch\",\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\tuserPasswordHasher: mockPasswordHasher(\"x\"),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tuserID:        \"user1\",\n\t\t\t\tpassword:      \"password\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsPreconditionFailed,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"password not matching lockout policy not relevant, precondition error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(\n\t\t\t\t\tt,\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\torg.NewLoginPolicyAddedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&org.NewAggregate(\"org1\").Aggregate,\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tdomain.PasswordlessTypeNotAllowed,\n\t\t\t\t\t\t\t\t\"\",\n\t\t\t\t\t\t\t\ttime.Hour*1,\n\t\t\t\t\t\t\t\ttime.Hour*2,\n\t\t\t\t\t\t\t\ttime.Hour*3,\n\t\t\t\t\t\t\t\ttime.Hour*4,\n\t\t\t\t\t\t\t\ttime.Hour*5,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanAddedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\t\"username\",\n\t\t\t\t\t\t\t\t\"firstname\",\n\t\t\t\t\t\t\t\t\"lastname\",\n\t\t\t\t\t\t\t\t\"nickname\",\n\t\t\t\t\t\t\t\t\"displayname\",\n\t\t\t\t\t\t\t\tlanguage.German,\n\t\t\t\t\t\t\t\tdomain.GenderUnspecified,\n\t\t\t\t\t\t\t\t\"email@test.ch\",\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanEmailVerifiedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanPasswordChangedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\t\"$plain$x$password\",\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\t\"\")),\n\t\t\t\t\t),\n\t\t\t\t\texpectPush(\n\t\t\t\t\t\tuser.NewHumanPasswordCheckFailedEvent(context.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t&user.AuthRequestInfo{\n\t\t\t\t\t\t\t\tID:          \"request1\",\n\t\t\t\t\t\t\t\tUserAgentID: \"agent1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\tuserPasswordHasher: mockPasswordHasher(\"x\"),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tuserID:        \"user1\",\n\t\t\t\tpassword:      \"password1\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t\tauthReq: &domain.AuthRequest{\n\t\t\t\t\tID:      \"request1\",\n\t\t\t\t\tAgentID: \"agent1\",\n\t\t\t\t},\n\t\t\t\tlockoutPolicy: &domain.LockoutPolicy{},\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsErrorInvalidArgument,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"password not matching, max password attempts reached - user locked, precondition error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(\n\t\t\t\t\tt,\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\torg.NewLoginPolicyAddedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&org.NewAggregate(\"org1\").Aggregate,\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tdomain.PasswordlessTypeNotAllowed,\n\t\t\t\t\t\t\t\t\"\",\n\t\t\t\t\t\t\t\ttime.Hour*1,\n\t\t\t\t\t\t\t\ttime.Hour*2,\n\t\t\t\t\t\t\t\ttime.Hour*3,\n\t\t\t\t\t\t\t\ttime.Hour*4,\n\t\t\t\t\t\t\t\ttime.Hour*5,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanAddedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\t\"username\",\n\t\t\t\t\t\t\t\t\"firstname\",\n\t\t\t\t\t\t\t\t\"lastname\",\n\t\t\t\t\t\t\t\t\"nickname\",\n\t\t\t\t\t\t\t\t\"displayname\",\n\t\t\t\t\t\t\t\tlanguage.German,\n\t\t\t\t\t\t\t\tdomain.GenderUnspecified,\n\t\t\t\t\t\t\t\t\"email@test.ch\",\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanEmailVerifiedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanPasswordChangedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\t\"$plain$x$password\",\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\t\"\")),\n\t\t\t\t\t),\n\t\t\t\t\texpectPush(\n\t\t\t\t\t\tuser.NewHumanPasswordCheckFailedEvent(context.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t&user.AuthRequestInfo{\n\t\t\t\t\t\t\t\tID:          \"request1\",\n\t\t\t\t\t\t\t\tUserAgentID: \"agent1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t),\n\t\t\t\t\t\tuser.NewUserLockedEvent(context.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\tuserPasswordHasher: mockPasswordHasher(\"x\"),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tuserID:        \"user1\",\n\t\t\t\tpassword:      \"password1\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t\tauthReq: &domain.AuthRequest{\n\t\t\t\t\tID:      \"request1\",\n\t\t\t\t\tAgentID: \"agent1\",\n\t\t\t\t},\n\t\t\t\tlockoutPolicy: &domain.LockoutPolicy{\n\t\t\t\t\tMaxPasswordAttempts: 1,\n\t\t\t\t},\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsErrorInvalidArgument,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"check password, ok\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(\n\t\t\t\t\tt,\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\torg.NewLoginPolicyAddedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&org.NewAggregate(\"org1\").Aggregate,\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tdomain.PasswordlessTypeNotAllowed,\n\t\t\t\t\t\t\t\t\"\",\n\t\t\t\t\t\t\t\ttime.Hour*1,\n\t\t\t\t\t\t\t\ttime.Hour*2,\n\t\t\t\t\t\t\t\ttime.Hour*3,\n\t\t\t\t\t\t\t\ttime.Hour*4,\n\t\t\t\t\t\t\t\ttime.Hour*5,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanAddedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\t\"username\",\n\t\t\t\t\t\t\t\t\"firstname\",\n\t\t\t\t\t\t\t\t\"lastname\",\n\t\t\t\t\t\t\t\t\"nickname\",\n\t\t\t\t\t\t\t\t\"displayname\",\n\t\t\t\t\t\t\t\tlanguage.German,\n\t\t\t\t\t\t\t\tdomain.GenderUnspecified,\n\t\t\t\t\t\t\t\t\"email@test.ch\",\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanEmailVerifiedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanPasswordChangedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\t\"$plain$x$password\",\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\t\"\")),\n\t\t\t\t\t),\n\t\t\t\t\texpectPush(\n\t\t\t\t\t\tuser.NewHumanPasswordCheckSucceededEvent(context.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t&user.AuthRequestInfo{\n\t\t\t\t\t\t\t\tID:          \"request1\",\n\t\t\t\t\t\t\t\tUserAgentID: \"agent1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\tuserPasswordHasher: mockPasswordHasher(\"x\"),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tuserID:        \"user1\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t\tpassword:      \"password\",\n\t\t\t\tauthReq: &domain.AuthRequest{\n\t\t\t\t\tID:      \"request1\",\n\t\t\t\t\tAgentID: \"agent1\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tres: res{},\n\t\t},\n\t\t{\n\t\t\tname: \"check password, ok, updated hash\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(\n\t\t\t\t\tt,\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\torg.NewLoginPolicyAddedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&org.NewAggregate(\"org1\").Aggregate,\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tdomain.PasswordlessTypeNotAllowed,\n\t\t\t\t\t\t\t\t\"\",\n\t\t\t\t\t\t\t\ttime.Hour*1,\n\t\t\t\t\t\t\t\ttime.Hour*2,\n\t\t\t\t\t\t\t\ttime.Hour*3,\n\t\t\t\t\t\t\t\ttime.Hour*4,\n\t\t\t\t\t\t\t\ttime.Hour*5,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanAddedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\t\"username\",\n\t\t\t\t\t\t\t\t\"firstname\",\n\t\t\t\t\t\t\t\t\"lastname\",\n\t\t\t\t\t\t\t\t\"nickname\",\n\t\t\t\t\t\t\t\t\"displayname\",\n\t\t\t\t\t\t\t\tlanguage.German,\n\t\t\t\t\t\t\t\tdomain.GenderUnspecified,\n\t\t\t\t\t\t\t\t\"email@test.ch\",\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanEmailVerifiedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanPasswordChangedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\t\"$plain$v$password\",\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\t\"\")),\n\t\t\t\t\t),\n\t\t\t\t\texpectPush(\n\t\t\t\t\t\tuser.NewHumanPasswordCheckSucceededEvent(\n\t\t\t\t\t\t\tcontext.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t&user.AuthRequestInfo{\n\t\t\t\t\t\t\t\tID:          \"request1\",\n\t\t\t\t\t\t\t\tUserAgentID: \"agent1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t),\n\t\t\t\t\t\tuser.NewHumanPasswordHashUpdatedEvent(context.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\"$plain$x$password\",\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\tuserPasswordHasher: mockPasswordHasher(\"x\"),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tuserID:        \"user1\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t\tpassword:      \"password\",\n\t\t\t\tauthReq: &domain.AuthRequest{\n\t\t\t\t\tID:      \"request1\",\n\t\t\t\t\tAgentID: \"agent1\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tres: res{},\n\t\t},\n\t\t{\n\t\t\tname: \"regression test old version event\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(\n\t\t\t\t\tt,\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\torg.NewLoginPolicyAddedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&org.NewAggregate(\"org1\").Aggregate,\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tdomain.PasswordlessTypeNotAllowed,\n\t\t\t\t\t\t\t\t\"\",\n\t\t\t\t\t\t\t\ttime.Hour*1,\n\t\t\t\t\t\t\t\ttime.Hour*2,\n\t\t\t\t\t\t\t\ttime.Hour*3,\n\t\t\t\t\t\t\t\ttime.Hour*4,\n\t\t\t\t\t\t\t\ttime.Hour*5,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanAddedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\t\"username\",\n\t\t\t\t\t\t\t\t\"firstname\",\n\t\t\t\t\t\t\t\t\"lastname\",\n\t\t\t\t\t\t\t\t\"nickname\",\n\t\t\t\t\t\t\t\t\"displayname\",\n\t\t\t\t\t\t\t\tlanguage.German,\n\t\t\t\t\t\t\t\tdomain.GenderUnspecified,\n\t\t\t\t\t\t\t\t\"email@test.ch\",\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanEmailVerifiedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\t&user.HumanPasswordChangedEvent{\n\t\t\t\t\t\t\t\tBaseEvent: *eventstore.NewBaseEventForPush(\n\t\t\t\t\t\t\t\t\tcontext.Background(),\n\t\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\t\tuser.HumanPasswordChangedType,\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\tSecret: &crypto.CryptoValue{\n\t\t\t\t\t\t\t\t\tCryptoType: crypto.TypeHash,\n\t\t\t\t\t\t\t\t\tAlgorithm:  \"plain\",\n\t\t\t\t\t\t\t\t\tKeyID:      \"\",\n\t\t\t\t\t\t\t\t\tCrypted:    []byte(\"$plain$v$password\"),\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tChangeRequired: false,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t\texpectPush(\n\t\t\t\t\t\tuser.NewHumanPasswordCheckSucceededEvent(context.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t&user.AuthRequestInfo{\n\t\t\t\t\t\t\t\tID:          \"request1\",\n\t\t\t\t\t\t\t\tUserAgentID: \"agent1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t),\n\t\t\t\t\t\tuser.NewHumanPasswordHashUpdatedEvent(context.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\"$plain$x$password\",\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\tuserPasswordHasher: mockPasswordHasher(\"x\"),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tuserID:        \"user1\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t\tpassword:      \"password\",\n\t\t\t\tauthReq: &domain.AuthRequest{\n\t\t\t\t\tID:      \"request1\",\n\t\t\t\t\tAgentID: \"agent1\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tres: res{},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tr := &Commands{\n\t\t\t\teventstore:         tt.fields.eventstore,\n\t\t\t\tuserPasswordHasher: tt.fields.userPasswordHasher,\n\t\t\t}\n\t\t\terr := r.HumanCheckPassword(tt.args.ctx, tt.args.resourceOwner, tt.args.userID, tt.args.password, tt.args.authReq, tt.args.lockoutPolicy)\n\t\t\tif tt.res.err == nil {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t\tif tt.res.err != nil && !tt.res.err(err) {\n\t\t\t\tt.Errorf(\"got wrong err: %v \", err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_convertPasswapErr(t *testing.T) {\n\ttype args struct {\n\t\terr error\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantErr error\n\t}{\n\t\t{\n\t\t\tname:    \"nil\",\n\t\t\targs:    args{nil},\n\t\t\twantErr: nil,\n\t\t},\n\t\t{\n\t\t\tname:    \"mismatch\",\n\t\t\targs:    args{passwap.ErrPasswordMismatch},\n\t\t\twantErr: caos_errs.ThrowInvalidArgument(passwap.ErrPasswordMismatch, \"COMMAND-3M0fs\", \"Errors.User.Password.Invalid\"),\n\t\t},\n\t\t{\n\t\t\tname:    \"no change\",\n\t\t\targs:    args{passwap.ErrPasswordNoChange},\n\t\t\twantErr: caos_errs.ThrowPreconditionFailed(passwap.ErrPasswordNoChange, \"COMMAND-Aesh5\", \"Errors.User.Password.NotChanged\"),\n\t\t},\n\t\t{\n\t\t\tname:    \"other\",\n\t\t\targs:    args{io.ErrClosedPipe},\n\t\t\twantErr: caos_errs.ThrowInternal(io.ErrClosedPipe, \"COMMAND-CahN2\", \"Errors.Internal\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\terr := convertPasswapErr(tt.args.err)\n\t\t\tassert.ErrorIs(t, err, tt.wantErr)\n\t\t})\n\t}\n}\n", "package query\n\nimport (\n\t\"context\"\n\t\"time\"\n\n\t\"github.com/zitadel/zitadel/internal/crypto\"\n\t\"github.com/zitadel/zitadel/internal/domain\"\n\t\"github.com/zitadel/zitadel/internal/errors\"\n\t\"github.com/zitadel/zitadel/internal/eventstore\"\n\t\"github.com/zitadel/zitadel/internal/repository/user\"\n\t\"github.com/zitadel/zitadel/internal/telemetry/tracing\"\n)\n\ntype HumanPasswordReadModel struct {\n\t*eventstore.ReadModel\n\n\tEncodedHash          string\n\tSecretChangeRequired bool\n\n\tCode                     *crypto.CryptoValue\n\tCodeCreationDate         time.Time\n\tCodeExpiry               time.Duration\n\tPasswordCheckFailedCount uint64\n\n\tUserState domain.UserState\n}\n\nfunc (q *Queries) GetHumanPassword(ctx context.Context, orgID, userID string) (encodedHash string, err error) {\n\tctx, span := tracing.NewSpan(ctx)\n\tdefer func() { span.EndWithError(err) }()\n\n\tif userID == \"\" {\n\t\treturn \"\", errors.ThrowInvalidArgument(nil, \"QUERY-4Mfsf\", \"Errors.User.UserIDMissing\")\n\t}\n\texistingPassword, err := q.passwordReadModel(ctx, userID, orgID)\n\tif err != nil {\n\t\treturn \"\", errors.ThrowInternal(nil, \"QUERY-p1k1n2i\", \"Errors.User.NotFound\")\n\t}\n\tif existingPassword.UserState == domain.UserStateUnspecified || existingPassword.UserState == domain.UserStateDeleted {\n\t\treturn \"\", errors.ThrowPreconditionFailed(nil, \"QUERY-3n77z\", \"Errors.User.NotFound\")\n\t}\n\treturn existingPassword.EncodedHash, nil\n}\n\nfunc (q *Queries) passwordReadModel(ctx context.Context, userID, resourceOwner string) (readModel *HumanPasswordReadModel, err error) {\n\tctx, span := tracing.NewSpan(ctx)\n\tdefer func() { span.EndWithError(err) }()\n\n\treadModel = NewHumanPasswordReadModel(userID, resourceOwner)\n\terr = q.eventstore.FilterToQueryReducer(ctx, readModel)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn readModel, nil\n}\n\nfunc NewHumanPasswordReadModel(userID, resourceOwner string) *HumanPasswordReadModel {\n\treturn &HumanPasswordReadModel{\n\t\tReadModel: &eventstore.ReadModel{\n\t\t\tAggregateID:   userID,\n\t\t\tResourceOwner: resourceOwner,\n\t\t},\n\t}\n}\n\nfunc (rm *HumanPasswordReadModel) AppendEvents(events ...eventstore.Event) {\n\trm.ReadModel.AppendEvents(events...)\n}\n\nfunc (wm *HumanPasswordReadModel) Reduce() error {\n\tfor _, event := range wm.Events {\n\t\tswitch e := event.(type) {\n\t\tcase *user.HumanAddedEvent:\n\t\t\twm.EncodedHash = user.SecretOrEncodedHash(e.Secret, e.EncodedHash)\n\t\t\twm.SecretChangeRequired = e.ChangeRequired\n\t\t\twm.UserState = domain.UserStateActive\n\t\tcase *user.HumanRegisteredEvent:\n\t\t\twm.EncodedHash = user.SecretOrEncodedHash(e.Secret, e.EncodedHash)\n\t\t\twm.SecretChangeRequired = e.ChangeRequired\n\t\t\twm.UserState = domain.UserStateActive\n\t\tcase *user.HumanInitialCodeAddedEvent:\n\t\t\twm.UserState = domain.UserStateInitial\n\t\tcase *user.HumanInitializedCheckSucceededEvent:\n\t\t\twm.UserState = domain.UserStateActive\n\t\tcase *user.HumanPasswordChangedEvent:\n\t\t\twm.EncodedHash = user.SecretOrEncodedHash(e.Secret, e.EncodedHash)\n\t\t\twm.SecretChangeRequired = e.ChangeRequired\n\t\t\twm.Code = nil\n\t\t\twm.PasswordCheckFailedCount = 0\n\t\tcase *user.HumanPasswordCodeAddedEvent:\n\t\t\twm.Code = e.Code\n\t\t\twm.CodeCreationDate = e.CreationDate()\n\t\t\twm.CodeExpiry = e.Expiry\n\t\tcase *user.HumanEmailVerifiedEvent:\n\t\t\tif wm.UserState == domain.UserStateInitial {\n\t\t\t\twm.UserState = domain.UserStateActive\n\t\t\t}\n\t\tcase *user.HumanPasswordCheckFailedEvent:\n\t\t\twm.PasswordCheckFailedCount += 1\n\t\tcase *user.HumanPasswordCheckSucceededEvent:\n\t\t\twm.PasswordCheckFailedCount = 0\n\t\tcase *user.UserUnlockedEvent:\n\t\t\twm.PasswordCheckFailedCount = 0\n\t\tcase *user.UserRemovedEvent:\n\t\t\twm.UserState = domain.UserStateDeleted\n\t\tcase *user.HumanPasswordHashUpdatedEvent:\n\t\t\twm.EncodedHash = e.EncodedHash\n\t\t}\n\t}\n\treturn wm.ReadModel.Reduce()\n}\n\nfunc (wm *HumanPasswordReadModel) Query() *eventstore.SearchQueryBuilder {\n\tquery := eventstore.NewSearchQueryBuilder(eventstore.ColumnsEvent).\n\t\tAwaitOpenTransactions().\n\t\tAllowTimeTravel().\n\t\tAddQuery().\n\t\tAggregateTypes(user.AggregateType).\n\t\tAggregateIDs(wm.AggregateID).\n\t\tEventTypes(user.HumanAddedType,\n\t\t\tuser.HumanRegisteredType,\n\t\t\tuser.HumanInitialCodeAddedType,\n\t\t\tuser.HumanInitializedCheckSucceededType,\n\t\t\tuser.HumanPasswordChangedType,\n\t\t\tuser.HumanPasswordCodeAddedType,\n\t\t\tuser.HumanEmailVerifiedType,\n\t\t\tuser.HumanPasswordCheckFailedType,\n\t\t\tuser.HumanPasswordCheckSucceededType,\n\t\t\tuser.HumanPasswordHashUpdatedType,\n\t\t\tuser.UserRemovedType,\n\t\t\tuser.UserUnlockedType,\n\t\t\tuser.UserV1AddedType,\n\t\t\tuser.UserV1RegisteredType,\n\t\t\tuser.UserV1InitialCodeAddedType,\n\t\t\tuser.UserV1InitializedCheckSucceededType,\n\t\t\tuser.UserV1PasswordChangedType,\n\t\t\tuser.UserV1PasswordCodeAddedType,\n\t\t\tuser.UserV1EmailVerifiedType,\n\t\t\tuser.UserV1PasswordCheckFailedType,\n\t\t\tuser.UserV1PasswordCheckSucceededType,\n\t\t).\n\t\tBuilder()\n\n\tif wm.ResourceOwner != \"\" {\n\t\tquery.ResourceOwner(wm.ResourceOwner)\n\t}\n\treturn query\n}\n"], "fixing_code": ["package command\n\nimport (\n\t\"context\"\n\t\"errors\"\n\n\t\"github.com/zitadel/logging\"\n\t\"github.com/zitadel/passwap\"\n\n\t\"github.com/zitadel/zitadel/internal/crypto\"\n\t\"github.com/zitadel/zitadel/internal/domain\"\n\tcaos_errs \"github.com/zitadel/zitadel/internal/errors\"\n\t\"github.com/zitadel/zitadel/internal/eventstore\"\n\t\"github.com/zitadel/zitadel/internal/repository/user\"\n\t\"github.com/zitadel/zitadel/internal/telemetry/tracing\"\n)\n\nfunc (c *Commands) SetPassword(ctx context.Context, orgID, userID, password string, oneTime bool) (objectDetails *domain.ObjectDetails, err error) {\n\tctx, span := tracing.NewSpan(ctx)\n\tdefer func() { span.EndWithError(err) }()\n\tif userID == \"\" {\n\t\treturn nil, caos_errs.ThrowInvalidArgument(nil, \"COMMAND-3M0fs\", \"Errors.IDMissing\")\n\t}\n\twm, err := c.passwordWriteModel(ctx, userID, orgID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !wm.UserState.Exists() {\n\t\treturn nil, caos_errs.ThrowPreconditionFailed(nil, \"COMMAND-3M0fs\", \"Errors.User.NotFound\")\n\t}\n\tif err = c.checkPermission(ctx, domain.PermissionUserWrite, wm.ResourceOwner, userID); err != nil {\n\t\treturn nil, err\n\t}\n\treturn c.setPassword(ctx, wm, password, oneTime)\n}\n\nfunc (c *Commands) SetPasswordWithVerifyCode(ctx context.Context, orgID, userID, code, password, userAgentID string) (objectDetails *domain.ObjectDetails, err error) {\n\tctx, span := tracing.NewSpan(ctx)\n\tdefer func() { span.EndWithError(err) }()\n\n\tif userID == \"\" {\n\t\treturn nil, caos_errs.ThrowInvalidArgument(nil, \"COMMAND-3M9fs\", \"Errors.IDMissing\")\n\t}\n\tif password == \"\" {\n\t\treturn nil, caos_errs.ThrowInvalidArgument(nil, \"COMMAND-Mf0sd\", \"Errors.User.Password.Empty\")\n\t}\n\twm, err := c.passwordWriteModel(ctx, userID, orgID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif wm.Code == nil || wm.UserState == domain.UserStateUnspecified || wm.UserState == domain.UserStateDeleted {\n\t\treturn nil, caos_errs.ThrowPreconditionFailed(nil, \"COMMAND-2M9fs\", \"Errors.User.Code.NotFound\")\n\t}\n\n\terr = crypto.VerifyCodeWithAlgorithm(wm.CodeCreationDate, wm.CodeExpiry, wm.Code, code, c.userEncryption)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn c.setPassword(ctx, wm, password, false)\n}\n\nfunc (c *Commands) setPassword(ctx context.Context, wm *HumanPasswordWriteModel, password string, changeRequired bool) (objectDetails *domain.ObjectDetails, err error) {\n\tcommand, err := c.setPasswordCommand(ctx, wm, password, changeRequired)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\terr = c.pushAppendAndReduce(ctx, wm, command)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn writeModelToObjectDetails(&wm.WriteModel), nil\n}\n\nfunc (c *Commands) setPasswordCommand(ctx context.Context, wm *HumanPasswordWriteModel, password string, changeRequired bool) (_ eventstore.Command, err error) {\n\tif err = c.canUpdatePassword(ctx, password, wm); err != nil {\n\t\treturn nil, err\n\t}\n\tctx, span := tracing.NewNamedSpan(ctx, \"passwap.Hash\")\n\tencoded, err := c.userPasswordHasher.Hash(password)\n\tspan.EndWithError(err)\n\tif err = convertPasswapErr(err); err != nil {\n\t\treturn nil, err\n\t}\n\treturn user.NewHumanPasswordChangedEvent(ctx, UserAggregateFromWriteModel(&wm.WriteModel), encoded, changeRequired, \"\"), nil\n}\n\nfunc (c *Commands) ChangePassword(ctx context.Context, orgID, userID, oldPassword, newPassword, userAgentID string) (objectDetails *domain.ObjectDetails, err error) {\n\tctx, span := tracing.NewSpan(ctx)\n\tdefer func() { span.EndWithError(err) }()\n\n\tif userID == \"\" {\n\t\treturn nil, caos_errs.ThrowInvalidArgument(nil, \"COMMAND-3M0fs\", \"Errors.IDMissing\")\n\t}\n\tif oldPassword == \"\" || newPassword == \"\" {\n\t\treturn nil, caos_errs.ThrowInvalidArgument(nil, \"COMMAND-3M0fs\", \"Errors.User.Password.Empty\")\n\t}\n\twm, err := c.passwordWriteModel(ctx, userID, orgID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif wm.EncodedHash == \"\" {\n\t\treturn nil, caos_errs.ThrowPreconditionFailed(nil, \"COMMAND-Fds3s\", \"Errors.User.Password.Empty\")\n\t}\n\tif err = c.canUpdatePassword(ctx, newPassword, wm); err != nil {\n\t\treturn nil, err\n\t}\n\n\tctx, spanPasswap := tracing.NewNamedSpan(ctx, \"passwap.VerifyAndUpdate\")\n\tupdated, err := c.userPasswordHasher.VerifyAndUpdate(wm.EncodedHash, oldPassword, newPassword)\n\tspanPasswap.EndWithError(err)\n\tif err = convertPasswapErr(err); err != nil {\n\t\treturn nil, err\n\t}\n\terr = c.pushAppendAndReduce(ctx, wm,\n\t\tuser.NewHumanPasswordChangedEvent(ctx, UserAggregateFromWriteModel(&wm.WriteModel), updated, false, userAgentID))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn writeModelToObjectDetails(&wm.WriteModel), nil\n}\n\nfunc (c *Commands) canUpdatePassword(ctx context.Context, newPassword string, wm *HumanPasswordWriteModel) (err error) {\n\tctx, span := tracing.NewSpan(ctx)\n\tdefer func() { span.EndWithError(err) }()\n\n\tif wm.UserState == domain.UserStateUnspecified || wm.UserState == domain.UserStateDeleted {\n\t\treturn caos_errs.ThrowNotFound(nil, \"COMMAND-G8dh3\", \"Errors.User.Password.NotFound\")\n\t}\n\tif wm.UserState == domain.UserStateInitial {\n\t\treturn caos_errs.ThrowPreconditionFailed(nil, \"COMMAND-M9dse\", \"Errors.User.NotInitialised\")\n\t}\n\tpolicy, err := c.getOrgPasswordComplexityPolicy(ctx, wm.ResourceOwner)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := policy.Check(newPassword); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (c *Commands) RequestSetPassword(ctx context.Context, userID, resourceOwner string, notifyType domain.NotificationType, passwordVerificationCode crypto.Generator) (objectDetails *domain.ObjectDetails, err error) {\n\tif userID == \"\" {\n\t\treturn nil, caos_errs.ThrowInvalidArgument(nil, \"COMMAND-M00oL\", \"Errors.User.UserIDMissing\")\n\t}\n\n\texistingHuman, err := c.userWriteModelByID(ctx, userID, resourceOwner)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif existingHuman.UserState == domain.UserStateUnspecified || existingHuman.UserState == domain.UserStateDeleted {\n\t\treturn nil, caos_errs.ThrowPreconditionFailed(nil, \"COMMAND-Hj9ds\", \"Errors.User.NotFound\")\n\t}\n\tif existingHuman.UserState == domain.UserStateInitial {\n\t\treturn nil, caos_errs.ThrowPreconditionFailed(nil, \"COMMAND-2M9sd\", \"Errors.User.NotInitialised\")\n\t}\n\tuserAgg := UserAggregateFromWriteModel(&existingHuman.WriteModel)\n\tpasswordCode, err := domain.NewPasswordCode(passwordVerificationCode)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpushedEvents, err := c.eventstore.Push(ctx, user.NewHumanPasswordCodeAddedEvent(ctx, userAgg, passwordCode.Code, passwordCode.Expiry, notifyType))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\terr = AppendAndReduce(existingHuman, pushedEvents...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn writeModelToObjectDetails(&existingHuman.WriteModel), nil\n}\n\nfunc (c *Commands) PasswordCodeSent(ctx context.Context, orgID, userID string) (err error) {\n\tif userID == \"\" {\n\t\treturn caos_errs.ThrowInvalidArgument(nil, \"COMMAND-meEfe\", \"Errors.User.UserIDMissing\")\n\t}\n\n\texistingPassword, err := c.passwordWriteModel(ctx, userID, orgID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif existingPassword.UserState == domain.UserStateUnspecified || existingPassword.UserState == domain.UserStateDeleted {\n\t\treturn caos_errs.ThrowPreconditionFailed(nil, \"COMMAND-3n77z\", \"Errors.User.NotFound\")\n\t}\n\tuserAgg := UserAggregateFromWriteModel(&existingPassword.WriteModel)\n\t_, err = c.eventstore.Push(ctx, user.NewHumanPasswordCodeSentEvent(ctx, userAgg))\n\treturn err\n}\n\nfunc (c *Commands) PasswordChangeSent(ctx context.Context, orgID, userID string) (err error) {\n\tif userID == \"\" {\n\t\treturn caos_errs.ThrowInvalidArgument(nil, \"COMMAND-pqlm2n\", \"Errors.User.UserIDMissing\")\n\t}\n\n\texistingPassword, err := c.passwordWriteModel(ctx, userID, orgID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif existingPassword.UserState == domain.UserStateUnspecified || existingPassword.UserState == domain.UserStateDeleted {\n\t\treturn caos_errs.ThrowPreconditionFailed(nil, \"COMMAND-x902b2v\", \"Errors.User.NotFound\")\n\t}\n\tuserAgg := UserAggregateFromWriteModel(&existingPassword.WriteModel)\n\t_, err = c.eventstore.Push(ctx, user.NewHumanPasswordChangeSentEvent(ctx, userAgg))\n\treturn err\n}\n\nfunc (c *Commands) HumanCheckPassword(ctx context.Context, orgID, userID, password string, authRequest *domain.AuthRequest, lockoutPolicy *domain.LockoutPolicy) (err error) {\n\tctx, span := tracing.NewSpan(ctx)\n\tdefer func() { span.EndWithError(err) }()\n\n\tif userID == \"\" {\n\t\treturn caos_errs.ThrowInvalidArgument(nil, \"COMMAND-4Mfsf\", \"Errors.User.UserIDMissing\")\n\t}\n\tif password == \"\" {\n\t\treturn caos_errs.ThrowInvalidArgument(nil, \"COMMAND-3n8fs\", \"Errors.User.Password.Empty\")\n\t}\n\n\tloginPolicy, err := c.getOrgLoginPolicy(ctx, orgID)\n\tif err != nil {\n\t\treturn caos_errs.ThrowPreconditionFailed(err, \"COMMAND-Edf3g\", \"Errors.Org.LoginPolicy.NotFound\")\n\t}\n\tif !loginPolicy.AllowUsernamePassword {\n\t\treturn caos_errs.ThrowPreconditionFailed(err, \"COMMAND-Dft32\", \"Errors.Org.LoginPolicy.UsernamePasswordNotAllowed\")\n\t}\n\n\twm, err := c.passwordWriteModel(ctx, userID, orgID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif wm.UserState == domain.UserStateUnspecified || wm.UserState == domain.UserStateDeleted {\n\t\treturn caos_errs.ThrowPreconditionFailed(nil, \"COMMAND-3n77z\", \"Errors.User.NotFound\")\n\t}\n\tif wm.UserState == domain.UserStateLocked {\n\t\treturn caos_errs.ThrowPreconditionFailed(nil, \"COMMAND-JLK35\", \"Errors.User.Locked\")\n\t}\n\n\tif wm.EncodedHash == \"\" {\n\t\treturn caos_errs.ThrowPreconditionFailed(nil, \"COMMAND-3nJ4t\", \"Errors.User.Password.NotSet\")\n\t}\n\n\tuserAgg := UserAggregateFromWriteModel(&wm.WriteModel)\n\tctx, spanPasswordComparison := tracing.NewNamedSpan(ctx, \"passwap.Verify\")\n\tupdated, err := c.userPasswordHasher.Verify(wm.EncodedHash, password)\n\tspanPasswordComparison.EndWithError(err)\n\terr = convertPasswapErr(err)\n\tcommands := make([]eventstore.Command, 0, 2)\n\n\t// recheck for additional events (failed password checks or locks)\n\trecheckErr := c.eventstore.FilterToQueryReducer(ctx, wm)\n\tif recheckErr != nil {\n\t\treturn recheckErr\n\t}\n\tif wm.UserState == domain.UserStateLocked {\n\t\treturn caos_errs.ThrowPreconditionFailed(nil, \"COMMAND-SFA3t\", \"Errors.User.Locked\")\n\t}\n\n\tif err == nil {\n\t\tcommands = append(commands, user.NewHumanPasswordCheckSucceededEvent(ctx, userAgg, authRequestDomainToAuthRequestInfo(authRequest)))\n\t\tif updated != \"\" {\n\t\t\tcommands = append(commands, user.NewHumanPasswordHashUpdatedEvent(ctx, userAgg, updated))\n\t\t}\n\t\t_, err = c.eventstore.Push(ctx, commands...)\n\t\treturn err\n\t}\n\n\tcommands = append(commands, user.NewHumanPasswordCheckFailedEvent(ctx, userAgg, authRequestDomainToAuthRequestInfo(authRequest)))\n\tif lockoutPolicy != nil && lockoutPolicy.MaxPasswordAttempts > 0 {\n\t\tif wm.PasswordCheckFailedCount+1 >= lockoutPolicy.MaxPasswordAttempts {\n\t\t\tcommands = append(commands, user.NewUserLockedEvent(ctx, userAgg))\n\t\t}\n\t}\n\t_, pushErr := c.eventstore.Push(ctx, commands...)\n\tlogging.OnError(pushErr).Error(\"error create password check failed event\")\n\treturn err\n}\n\nfunc (c *Commands) passwordWriteModel(ctx context.Context, userID, resourceOwner string) (writeModel *HumanPasswordWriteModel, err error) {\n\tctx, span := tracing.NewSpan(ctx)\n\tdefer func() { span.EndWithError(err) }()\n\n\twriteModel = NewHumanPasswordWriteModel(userID, resourceOwner)\n\terr = c.eventstore.FilterToQueryReducer(ctx, writeModel)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn writeModel, nil\n}\n\nfunc convertPasswapErr(err error) error {\n\tif err == nil {\n\t\treturn nil\n\t}\n\tif errors.Is(err, passwap.ErrPasswordMismatch) {\n\t\treturn caos_errs.ThrowInvalidArgument(err, \"COMMAND-3M0fs\", \"Errors.User.Password.Invalid\")\n\t}\n\tif errors.Is(err, passwap.ErrPasswordNoChange) {\n\t\treturn caos_errs.ThrowPreconditionFailed(err, \"COMMAND-Aesh5\", \"Errors.User.Password.NotChanged\")\n\t}\n\treturn caos_errs.ThrowInternal(err, \"COMMAND-CahN2\", \"Errors.Internal\")\n}\n", "package command\n\nimport (\n\t\"time\"\n\n\t\"github.com/zitadel/zitadel/internal/eventstore\"\n\n\t\"github.com/zitadel/zitadel/internal/crypto\"\n\t\"github.com/zitadel/zitadel/internal/domain\"\n\t\"github.com/zitadel/zitadel/internal/repository/user\"\n)\n\ntype HumanPasswordWriteModel struct {\n\teventstore.WriteModel\n\n\tEncodedHash          string\n\tSecretChangeRequired bool\n\n\tCode                     *crypto.CryptoValue\n\tCodeCreationDate         time.Time\n\tCodeExpiry               time.Duration\n\tPasswordCheckFailedCount uint64\n\n\tUserState domain.UserState\n}\n\nfunc NewHumanPasswordWriteModel(userID, resourceOwner string) *HumanPasswordWriteModel {\n\treturn &HumanPasswordWriteModel{\n\t\tWriteModel: eventstore.WriteModel{\n\t\t\tAggregateID:   userID,\n\t\t\tResourceOwner: resourceOwner,\n\t\t},\n\t}\n}\n\nfunc (wm *HumanPasswordWriteModel) Reduce() error {\n\tfor _, event := range wm.Events {\n\t\tswitch e := event.(type) {\n\t\tcase *user.HumanAddedEvent:\n\t\t\twm.EncodedHash = user.SecretOrEncodedHash(e.Secret, e.EncodedHash)\n\t\t\twm.SecretChangeRequired = e.ChangeRequired\n\t\t\twm.UserState = domain.UserStateActive\n\t\tcase *user.HumanRegisteredEvent:\n\t\t\twm.EncodedHash = user.SecretOrEncodedHash(e.Secret, e.EncodedHash)\n\t\t\twm.SecretChangeRequired = e.ChangeRequired\n\t\t\twm.UserState = domain.UserStateActive\n\t\tcase *user.HumanInitialCodeAddedEvent:\n\t\t\twm.UserState = domain.UserStateInitial\n\t\tcase *user.HumanInitializedCheckSucceededEvent:\n\t\t\twm.UserState = domain.UserStateActive\n\t\tcase *user.HumanPasswordChangedEvent:\n\t\t\twm.EncodedHash = user.SecretOrEncodedHash(e.Secret, e.EncodedHash)\n\t\t\twm.SecretChangeRequired = e.ChangeRequired\n\t\t\twm.Code = nil\n\t\t\twm.PasswordCheckFailedCount = 0\n\t\tcase *user.HumanPasswordCodeAddedEvent:\n\t\t\twm.Code = e.Code\n\t\t\twm.CodeCreationDate = e.CreationDate()\n\t\t\twm.CodeExpiry = e.Expiry\n\t\tcase *user.HumanEmailVerifiedEvent:\n\t\t\tif wm.UserState == domain.UserStateInitial {\n\t\t\t\twm.UserState = domain.UserStateActive\n\t\t\t}\n\t\tcase *user.HumanPasswordCheckFailedEvent:\n\t\t\twm.PasswordCheckFailedCount += 1\n\t\tcase *user.HumanPasswordCheckSucceededEvent:\n\t\t\twm.PasswordCheckFailedCount = 0\n\t\tcase *user.UserLockedEvent:\n\t\t\twm.UserState = domain.UserStateLocked\n\t\tcase *user.UserUnlockedEvent:\n\t\t\twm.PasswordCheckFailedCount = 0\n\t\t\tif wm.UserState != domain.UserStateDeleted {\n\t\t\t\twm.UserState = domain.UserStateActive\n\t\t\t}\n\t\tcase *user.UserRemovedEvent:\n\t\t\twm.UserState = domain.UserStateDeleted\n\t\tcase *user.HumanPasswordHashUpdatedEvent:\n\t\t\twm.EncodedHash = e.EncodedHash\n\t\t}\n\t}\n\treturn wm.WriteModel.Reduce()\n}\n\nfunc (wm *HumanPasswordWriteModel) Query() *eventstore.SearchQueryBuilder {\n\tquery := eventstore.NewSearchQueryBuilder(eventstore.ColumnsEvent).\n\t\tAddQuery().\n\t\tAggregateTypes(user.AggregateType).\n\t\tAggregateIDs(wm.AggregateID).\n\t\tEventTypes(user.HumanAddedType,\n\t\t\tuser.HumanRegisteredType,\n\t\t\tuser.HumanInitialCodeAddedType,\n\t\t\tuser.HumanInitializedCheckSucceededType,\n\t\t\tuser.HumanPasswordChangedType,\n\t\t\tuser.HumanPasswordCodeAddedType,\n\t\t\tuser.HumanEmailVerifiedType,\n\t\t\tuser.HumanPasswordCheckFailedType,\n\t\t\tuser.HumanPasswordCheckSucceededType,\n\t\t\tuser.HumanPasswordHashUpdatedType,\n\t\t\tuser.UserRemovedType,\n\t\t\tuser.UserLockedType,\n\t\t\tuser.UserUnlockedType,\n\t\t\tuser.UserV1AddedType,\n\t\t\tuser.UserV1RegisteredType,\n\t\t\tuser.UserV1InitialCodeAddedType,\n\t\t\tuser.UserV1InitializedCheckSucceededType,\n\t\t\tuser.UserV1PasswordChangedType,\n\t\t\tuser.UserV1PasswordCodeAddedType,\n\t\t\tuser.UserV1EmailVerifiedType,\n\t\t\tuser.UserV1PasswordCheckFailedType,\n\t\t\tuser.UserV1PasswordCheckSucceededType,\n\t\t).\n\t\tBuilder()\n\n\tif wm.ResourceOwner != \"\" {\n\t\tquery.ResourceOwner(wm.ResourceOwner)\n\t}\n\tif wm.WriteModel.ProcessedSequence != 0 {\n\t\tquery.SequenceGreater(wm.WriteModel.ProcessedSequence)\n\t}\n\treturn query\n}\n", "package command\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"io\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/golang/mock/gomock\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/zitadel/passwap\"\n\t\"golang.org/x/text/language\"\n\n\t\"github.com/zitadel/zitadel/internal/crypto\"\n\t\"github.com/zitadel/zitadel/internal/domain\"\n\tcaos_errs \"github.com/zitadel/zitadel/internal/errors\"\n\t\"github.com/zitadel/zitadel/internal/eventstore\"\n\t\"github.com/zitadel/zitadel/internal/repository/org\"\n\t\"github.com/zitadel/zitadel/internal/repository/user\"\n)\n\nfunc TestCommandSide_SetOneTimePassword(t *testing.T) {\n\ttype fields struct {\n\t\teventstore         *eventstore.Eventstore\n\t\tuserPasswordHasher *crypto.PasswordHasher\n\t\tcheckPermission    domain.PermissionCheck\n\t}\n\ttype args struct {\n\t\tctx           context.Context\n\t\tuserID        string\n\t\tresourceOwner string\n\t\tpassword      string\n\t\toneTime       bool\n\t}\n\ttype res struct {\n\t\twant *domain.ObjectDetails\n\t\terr  func(error) bool\n\t}\n\ttests := []struct {\n\t\tname   string\n\t\tfields fields\n\t\targs   args\n\t\tres    res\n\t}{\n\t\t{\n\t\t\tname: \"userid missing, invalid argument error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(\n\t\t\t\t\tt,\n\t\t\t\t),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsErrorInvalidArgument,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"user not existing, precondition error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(\n\t\t\t\t\tt,\n\t\t\t\t\texpectFilter(),\n\t\t\t\t),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tuserID:        \"user1\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsPreconditionFailed,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"missing permission, error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(\n\t\t\t\t\tt,\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanAddedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\t\"username\",\n\t\t\t\t\t\t\t\t\"firstname\",\n\t\t\t\t\t\t\t\t\"lastname\",\n\t\t\t\t\t\t\t\t\"nickname\",\n\t\t\t\t\t\t\t\t\"displayname\",\n\t\t\t\t\t\t\t\tlanguage.German,\n\t\t\t\t\t\t\t\tdomain.GenderUnspecified,\n\t\t\t\t\t\t\t\t\"email@test.ch\",\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanEmailVerifiedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\tuserPasswordHasher: mockPasswordHasher(\"x\"),\n\t\t\t\tcheckPermission:    newMockPermissionCheckNotAllowed(),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tuserID:        \"user1\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t\tpassword:      \"password\",\n\t\t\t\toneTime:       true,\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: func(err error) bool {\n\t\t\t\t\treturn errors.Is(err, caos_errs.ThrowPermissionDenied(nil, \"AUTHZ-HKJD33\", \"Errors.PermissionDenied\"))\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"change password onetime, ok\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(\n\t\t\t\t\tt,\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanAddedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\t\"username\",\n\t\t\t\t\t\t\t\t\"firstname\",\n\t\t\t\t\t\t\t\t\"lastname\",\n\t\t\t\t\t\t\t\t\"nickname\",\n\t\t\t\t\t\t\t\t\"displayname\",\n\t\t\t\t\t\t\t\tlanguage.German,\n\t\t\t\t\t\t\t\tdomain.GenderUnspecified,\n\t\t\t\t\t\t\t\t\"email@test.ch\",\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanEmailVerifiedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\torg.NewPasswordComplexityPolicyAddedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t\texpectPush(\n\t\t\t\t\t\tuser.NewHumanPasswordChangedEvent(context.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\"$plain$x$password\",\n\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t\"\",\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\tuserPasswordHasher: mockPasswordHasher(\"x\"),\n\t\t\t\tcheckPermission:    newMockPermissionCheckAllowed(),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tuserID:        \"user1\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t\tpassword:      \"password\",\n\t\t\t\toneTime:       true,\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\twant: &domain.ObjectDetails{\n\t\t\t\t\tResourceOwner: \"org1\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"change password no one time, ok\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(\n\t\t\t\t\tt,\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanAddedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\t\"username\",\n\t\t\t\t\t\t\t\t\"firstname\",\n\t\t\t\t\t\t\t\t\"lastname\",\n\t\t\t\t\t\t\t\t\"nickname\",\n\t\t\t\t\t\t\t\t\"displayname\",\n\t\t\t\t\t\t\t\tlanguage.German,\n\t\t\t\t\t\t\t\tdomain.GenderUnspecified,\n\t\t\t\t\t\t\t\t\"email@test.ch\",\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanEmailVerifiedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\torg.NewPasswordComplexityPolicyAddedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t\texpectPush(\n\t\t\t\t\t\tuser.NewHumanPasswordChangedEvent(context.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\"$plain$x$password\",\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\"\",\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\tuserPasswordHasher: mockPasswordHasher(\"x\"),\n\t\t\t\tcheckPermission:    newMockPermissionCheckAllowed(),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tuserID:        \"user1\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t\tpassword:      \"password\",\n\t\t\t\toneTime:       false,\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\twant: &domain.ObjectDetails{\n\t\t\t\t\tResourceOwner: \"org1\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tr := &Commands{\n\t\t\t\teventstore:         tt.fields.eventstore,\n\t\t\t\tuserPasswordHasher: tt.fields.userPasswordHasher,\n\t\t\t\tcheckPermission:    tt.fields.checkPermission,\n\t\t\t}\n\t\t\tgot, err := r.SetPassword(tt.args.ctx, tt.args.resourceOwner, tt.args.userID, tt.args.password, tt.args.oneTime)\n\t\t\tif tt.res.err == nil {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t\tif tt.res.err != nil && !tt.res.err(err) {\n\t\t\t\tt.Errorf(\"got wrong err: %v \", err)\n\t\t\t}\n\t\t\tif tt.res.err == nil {\n\t\t\t\tassert.Equal(t, tt.res.want, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestCommandSide_SetPasswordWithVerifyCode(t *testing.T) {\n\ttype fields struct {\n\t\teventstore         *eventstore.Eventstore\n\t\tuserEncryption     crypto.EncryptionAlgorithm\n\t\tuserPasswordHasher *crypto.PasswordHasher\n\t}\n\ttype args struct {\n\t\tctx           context.Context\n\t\tuserID        string\n\t\tcode          string\n\t\tresourceOwner string\n\t\tpassword      string\n\t\tagentID       string\n\t}\n\ttype res struct {\n\t\twant *domain.ObjectDetails\n\t\terr  func(error) bool\n\t}\n\ttests := []struct {\n\t\tname   string\n\t\tfields fields\n\t\targs   args\n\t\tres    res\n\t}{\n\t\t{\n\t\t\tname: \"userid missing, invalid argument error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(\n\t\t\t\t\tt,\n\t\t\t\t),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsErrorInvalidArgument,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"password missing, invalid argument error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(\n\t\t\t\t\tt,\n\t\t\t\t),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tuserID:        \"user1\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsErrorInvalidArgument,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"user not existing, precondition error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(\n\t\t\t\t\tt,\n\t\t\t\t\texpectFilter(),\n\t\t\t\t),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tuserID:        \"user1\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t\tpassword:      \"password\",\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsPreconditionFailed,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"code not existing, precondition error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(\n\t\t\t\t\tt,\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanAddedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\t\"username\",\n\t\t\t\t\t\t\t\t\"firstname\",\n\t\t\t\t\t\t\t\t\"lastname\",\n\t\t\t\t\t\t\t\t\"nickname\",\n\t\t\t\t\t\t\t\t\"displayname\",\n\t\t\t\t\t\t\t\tlanguage.German,\n\t\t\t\t\t\t\t\tdomain.GenderUnspecified,\n\t\t\t\t\t\t\t\t\"email@test.ch\",\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tuserID:        \"user1\",\n\t\t\t\tcode:          \"aa\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t\tpassword:      \"string\",\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsPreconditionFailed,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"invalid code, invalid argument error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(\n\t\t\t\t\tt,\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanAddedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\t\"username\",\n\t\t\t\t\t\t\t\t\"firstname\",\n\t\t\t\t\t\t\t\t\"lastname\",\n\t\t\t\t\t\t\t\t\"nickname\",\n\t\t\t\t\t\t\t\t\"displayname\",\n\t\t\t\t\t\t\t\tlanguage.German,\n\t\t\t\t\t\t\t\tdomain.GenderUnspecified,\n\t\t\t\t\t\t\t\t\"email@test.ch\",\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanPasswordCodeAddedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\t&crypto.CryptoValue{\n\t\t\t\t\t\t\t\t\tCryptoType: crypto.TypeEncryption,\n\t\t\t\t\t\t\t\t\tAlgorithm:  \"enc\",\n\t\t\t\t\t\t\t\t\tKeyID:      \"id\",\n\t\t\t\t\t\t\t\t\tCrypted:    []byte(\"a\"),\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\ttime.Hour*1,\n\t\t\t\t\t\t\t\tdomain.NotificationTypeEmail,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\tuserEncryption: crypto.CreateMockEncryptionAlg(gomock.NewController(t)),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tuserID:        \"user1\",\n\t\t\t\tcode:          \"test\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t\tpassword:      \"password\",\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsPreconditionFailed,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"set password, ok\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(\n\t\t\t\t\tt,\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanAddedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\t\"username\",\n\t\t\t\t\t\t\t\t\"firstname\",\n\t\t\t\t\t\t\t\t\"lastname\",\n\t\t\t\t\t\t\t\t\"nickname\",\n\t\t\t\t\t\t\t\t\"displayname\",\n\t\t\t\t\t\t\t\tlanguage.German,\n\t\t\t\t\t\t\t\tdomain.GenderUnspecified,\n\t\t\t\t\t\t\t\t\"email@test.ch\",\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanEmailVerifiedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\teventFromEventPusherWithCreationDateNow(\n\t\t\t\t\t\t\tuser.NewHumanPasswordCodeAddedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\t&crypto.CryptoValue{\n\t\t\t\t\t\t\t\t\tCryptoType: crypto.TypeEncryption,\n\t\t\t\t\t\t\t\t\tAlgorithm:  \"enc\",\n\t\t\t\t\t\t\t\t\tKeyID:      \"id\",\n\t\t\t\t\t\t\t\t\tCrypted:    []byte(\"a\"),\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\ttime.Hour*1,\n\t\t\t\t\t\t\t\tdomain.NotificationTypeEmail,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\torg.NewPasswordComplexityPolicyAddedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t\texpectPush(\n\t\t\t\t\t\tuser.NewHumanPasswordChangedEvent(context.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\"$plain$x$password\",\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\"\",\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\tuserPasswordHasher: mockPasswordHasher(\"x\"),\n\t\t\t\tuserEncryption:     crypto.CreateMockEncryptionAlg(gomock.NewController(t)),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tuserID:        \"user1\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t\tpassword:      \"password\",\n\t\t\t\tcode:          \"a\",\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\twant: &domain.ObjectDetails{\n\t\t\t\t\tResourceOwner: \"org1\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tr := &Commands{\n\t\t\t\teventstore:         tt.fields.eventstore,\n\t\t\t\tuserPasswordHasher: tt.fields.userPasswordHasher,\n\t\t\t\tuserEncryption:     tt.fields.userEncryption,\n\t\t\t}\n\t\t\tgot, err := r.SetPasswordWithVerifyCode(tt.args.ctx, tt.args.resourceOwner, tt.args.userID, tt.args.code, tt.args.password, tt.args.agentID)\n\t\t\tif tt.res.err == nil {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t\tif tt.res.err != nil && !tt.res.err(err) {\n\t\t\t\tt.Errorf(\"got wrong err: %v \", err)\n\t\t\t}\n\t\t\tif tt.res.err == nil {\n\t\t\t\tassert.Equal(t, tt.res.want, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestCommandSide_ChangePassword(t *testing.T) {\n\ttype fields struct {\n\t\tuserPasswordHasher *crypto.PasswordHasher\n\t}\n\ttype args struct {\n\t\tctx           context.Context\n\t\tuserID        string\n\t\tresourceOwner string\n\t\toldPassword   string\n\t\tnewPassword   string\n\t\tagentID       string\n\t}\n\ttype res struct {\n\t\twant *domain.ObjectDetails\n\t\terr  func(error) bool\n\t}\n\ttests := []struct {\n\t\tname   string\n\t\tfields fields\n\t\targs   args\n\t\texpect []expect\n\t\tres    res\n\t}{\n\t\t{\n\t\t\tname:   \"userid missing, invalid argument error\",\n\t\t\tfields: fields{},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\toldPassword:   \"password\",\n\t\t\t\tnewPassword:   \"password1\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t},\n\t\t\texpect: []expect{},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsErrorInvalidArgument,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:   \"old password missing, invalid argument error\",\n\t\t\tfields: fields{},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tuserID:        \"user1\",\n\t\t\t\tnewPassword:   \"password1\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t},\n\t\t\texpect: []expect{},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsErrorInvalidArgument,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:   \"new password missing, invalid argument error\",\n\t\t\tfields: fields{},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tuserID:        \"user1\",\n\t\t\t\toldPassword:   \"password\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t},\n\t\t\texpect: []expect{},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsErrorInvalidArgument,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:   \"user not existing, precondition error\",\n\t\t\tfields: fields{},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tuserID:        \"user1\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t\toldPassword:   \"password\",\n\t\t\t\tnewPassword:   \"password1\",\n\t\t\t},\n\t\t\texpect: []expect{\n\t\t\t\texpectFilter(),\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsPreconditionFailed,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"existing password empty, precondition error\",\n\t\t\tfields: fields{\n\t\t\t\tuserPasswordHasher: mockPasswordHasher(\"x\"),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tuserID:        \"user1\",\n\t\t\t\toldPassword:   \"password\",\n\t\t\t\tnewPassword:   \"password1\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t},\n\t\t\texpect: []expect{\n\t\t\t\texpectFilter(\n\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\tuser.NewHumanAddedEvent(context.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\"username\",\n\t\t\t\t\t\t\t\"firstname\",\n\t\t\t\t\t\t\t\"lastname\",\n\t\t\t\t\t\t\t\"nickname\",\n\t\t\t\t\t\t\t\"displayname\",\n\t\t\t\t\t\t\tlanguage.German,\n\t\t\t\t\t\t\tdomain.GenderUnspecified,\n\t\t\t\t\t\t\t\"email@test.ch\",\n\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsPreconditionFailed,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"password not matching, invalid argument error\",\n\t\t\tfields: fields{\n\t\t\t\tuserPasswordHasher: mockPasswordHasher(\"x\"),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tuserID:        \"user1\",\n\t\t\t\toldPassword:   \"password-old\",\n\t\t\t\tnewPassword:   \"password1\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t},\n\t\t\texpect: []expect{\n\t\t\t\texpectFilter(\n\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\tuser.NewHumanAddedEvent(context.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\"username\",\n\t\t\t\t\t\t\t\"firstname\",\n\t\t\t\t\t\t\t\"lastname\",\n\t\t\t\t\t\t\t\"nickname\",\n\t\t\t\t\t\t\t\"displayname\",\n\t\t\t\t\t\t\tlanguage.German,\n\t\t\t\t\t\t\tdomain.GenderUnspecified,\n\t\t\t\t\t\t\t\"email@test.ch\",\n\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\tuser.NewHumanEmailVerifiedEvent(context.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\tuser.NewHumanPasswordChangedEvent(context.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\"$plain$x$password\",\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\"\")),\n\t\t\t\t),\n\t\t\t\texpectFilter(\n\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\torg.NewPasswordComplexityPolicyAddedEvent(context.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsErrorInvalidArgument,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"change password, ok\",\n\t\t\tfields: fields{\n\t\t\t\tuserPasswordHasher: mockPasswordHasher(\"x\"),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tuserID:        \"user1\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t\toldPassword:   \"password\",\n\t\t\t\tnewPassword:   \"password1\",\n\t\t\t},\n\t\t\texpect: []expect{\n\t\t\t\texpectFilter(\n\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\tuser.NewHumanAddedEvent(context.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\"username\",\n\t\t\t\t\t\t\t\"firstname\",\n\t\t\t\t\t\t\t\"lastname\",\n\t\t\t\t\t\t\t\"nickname\",\n\t\t\t\t\t\t\t\"displayname\",\n\t\t\t\t\t\t\tlanguage.German,\n\t\t\t\t\t\t\tdomain.GenderUnspecified,\n\t\t\t\t\t\t\t\"email@test.ch\",\n\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\tuser.NewHumanEmailVerifiedEvent(context.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\tuser.NewHumanPasswordChangedEvent(context.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\"$plain$x$password\",\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\"\")),\n\t\t\t\t),\n\t\t\t\texpectFilter(\n\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\torg.NewPasswordComplexityPolicyAddedEvent(context.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\texpectPush(\n\t\t\t\t\tuser.NewHumanPasswordChangedEvent(context.Background(),\n\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\"$plain$x$password1\",\n\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\"\",\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\twant: &domain.ObjectDetails{\n\t\t\t\t\tResourceOwner: \"org1\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tr := &Commands{\n\t\t\t\teventstore:         eventstoreExpect(t, tt.expect...),\n\t\t\t\tuserPasswordHasher: tt.fields.userPasswordHasher,\n\t\t\t}\n\t\t\tgot, err := r.ChangePassword(tt.args.ctx, tt.args.resourceOwner, tt.args.userID, tt.args.oldPassword, tt.args.newPassword, tt.args.agentID)\n\t\t\tif tt.res.err == nil {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t\tif tt.res.err != nil && !tt.res.err(err) {\n\t\t\t\tt.Errorf(\"got wrong err: %v \", err)\n\t\t\t}\n\t\t\tif tt.res.err == nil {\n\t\t\t\tassert.Equal(t, tt.res.want, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestCommandSide_RequestSetPassword(t *testing.T) {\n\ttype fields struct {\n\t\teventstore *eventstore.Eventstore\n\t}\n\ttype args struct {\n\t\tctx             context.Context\n\t\tuserID          string\n\t\tresourceOwner   string\n\t\tnotifyType      domain.NotificationType\n\t\tsecretGenerator crypto.Generator\n\t}\n\ttype res struct {\n\t\twant *domain.ObjectDetails\n\t\terr  func(error) bool\n\t}\n\ttests := []struct {\n\t\tname   string\n\t\tfields fields\n\t\targs   args\n\t\tres    res\n\t}{\n\t\t{\n\t\t\tname: \"userid missing, invalid argument error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(\n\t\t\t\t\tt,\n\t\t\t\t),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsErrorInvalidArgument,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"user not existing, precondition error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(\n\t\t\t\t\tt,\n\t\t\t\t\texpectFilter(),\n\t\t\t\t),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tuserID:        \"user1\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsPreconditionFailed,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"user initial, precondition error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(\n\t\t\t\t\tt,\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanAddedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\t\"username\",\n\t\t\t\t\t\t\t\t\"firstname\",\n\t\t\t\t\t\t\t\t\"lastname\",\n\t\t\t\t\t\t\t\t\"nickname\",\n\t\t\t\t\t\t\t\t\"displayname\",\n\t\t\t\t\t\t\t\tlanguage.German,\n\t\t\t\t\t\t\t\tdomain.GenderUnspecified,\n\t\t\t\t\t\t\t\t\"email@test.ch\",\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanInitialCodeAddedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\tnil, time.Hour*1,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanPhoneChangedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\t\"+411234567\",\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanPhoneVerifiedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tuserID:        \"user1\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsPreconditionFailed,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"new code, ok\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(\n\t\t\t\t\tt,\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanAddedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\t\"username\",\n\t\t\t\t\t\t\t\t\"firstname\",\n\t\t\t\t\t\t\t\t\"lastname\",\n\t\t\t\t\t\t\t\t\"nickname\",\n\t\t\t\t\t\t\t\t\"displayname\",\n\t\t\t\t\t\t\t\tlanguage.German,\n\t\t\t\t\t\t\t\tdomain.GenderUnspecified,\n\t\t\t\t\t\t\t\t\"email@test.ch\",\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanEmailVerifiedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanInitializedCheckSucceededEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate)),\n\t\t\t\t\t),\n\t\t\t\t\texpectPush(\n\t\t\t\t\t\tuser.NewHumanPasswordCodeAddedEvent(context.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t&crypto.CryptoValue{\n\t\t\t\t\t\t\t\tCryptoType: crypto.TypeEncryption,\n\t\t\t\t\t\t\t\tAlgorithm:  \"enc\",\n\t\t\t\t\t\t\t\tKeyID:      \"id\",\n\t\t\t\t\t\t\t\tCrypted:    []byte(\"a\"),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\ttime.Hour*1,\n\t\t\t\t\t\t\tdomain.NotificationTypeEmail,\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:             context.Background(),\n\t\t\t\tuserID:          \"user1\",\n\t\t\t\tresourceOwner:   \"org1\",\n\t\t\t\tsecretGenerator: GetMockSecretGenerator(t),\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\twant: &domain.ObjectDetails{\n\t\t\t\t\tResourceOwner: \"org1\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tr := &Commands{\n\t\t\t\teventstore: tt.fields.eventstore,\n\t\t\t}\n\t\t\tgot, err := r.RequestSetPassword(tt.args.ctx, tt.args.userID, tt.args.resourceOwner, tt.args.notifyType, tt.args.secretGenerator)\n\t\t\tif tt.res.err == nil {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t\tif tt.res.err != nil && !tt.res.err(err) {\n\t\t\t\tt.Errorf(\"got wrong err: %v \", err)\n\t\t\t}\n\t\t\tif tt.res.err == nil {\n\t\t\t\tassert.Equal(t, tt.res.want, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestCommandSide_PasswordCodeSent(t *testing.T) {\n\ttype fields struct {\n\t\teventstore *eventstore.Eventstore\n\t}\n\ttype args struct {\n\t\tctx           context.Context\n\t\tuserID        string\n\t\tresourceOwner string\n\t}\n\ttype res struct {\n\t\terr func(error) bool\n\t}\n\ttests := []struct {\n\t\tname   string\n\t\tfields fields\n\t\targs   args\n\t\tres    res\n\t}{\n\t\t{\n\t\t\tname: \"userid missing, invalid argument error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(\n\t\t\t\t\tt,\n\t\t\t\t),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsErrorInvalidArgument,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"user not existing, precondition error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(\n\t\t\t\t\tt,\n\t\t\t\t\texpectFilter(),\n\t\t\t\t),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tuserID:        \"user1\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsPreconditionFailed,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"code sent, ok\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(\n\t\t\t\t\tt,\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanAddedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\t\"username\",\n\t\t\t\t\t\t\t\t\"firstname\",\n\t\t\t\t\t\t\t\t\"lastname\",\n\t\t\t\t\t\t\t\t\"nickname\",\n\t\t\t\t\t\t\t\t\"displayname\",\n\t\t\t\t\t\t\t\tlanguage.German,\n\t\t\t\t\t\t\t\tdomain.GenderUnspecified,\n\t\t\t\t\t\t\t\t\"email@test.ch\",\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanPhoneChangedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\t\"+411234567\",\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t\texpectPush(\n\t\t\t\t\t\tuser.NewHumanPasswordCodeSentEvent(context.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tuserID:        \"user1\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t},\n\t\t\tres: res{},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tr := &Commands{\n\t\t\t\teventstore: tt.fields.eventstore,\n\t\t\t}\n\t\t\terr := r.PasswordCodeSent(tt.args.ctx, tt.args.resourceOwner, tt.args.userID)\n\t\t\tif tt.res.err == nil {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t\tif tt.res.err != nil && !tt.res.err(err) {\n\t\t\t\tt.Errorf(\"got wrong err: %v \", err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestCommandSide_CheckPassword(t *testing.T) {\n\ttype fields struct {\n\t\teventstore         *eventstore.Eventstore\n\t\tuserPasswordHasher *crypto.PasswordHasher\n\t}\n\ttype args struct {\n\t\tctx           context.Context\n\t\tuserID        string\n\t\tresourceOwner string\n\t\tpassword      string\n\t\tauthReq       *domain.AuthRequest\n\t\tlockoutPolicy *domain.LockoutPolicy\n\t}\n\ttype res struct {\n\t\terr func(error) bool\n\t}\n\ttests := []struct {\n\t\tname   string\n\t\tfields fields\n\t\targs   args\n\t\tres    res\n\t}{\n\t\t{\n\t\t\tname: \"userid missing, invalid argument error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(\n\t\t\t\t\tt,\n\t\t\t\t),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tpassword:      \"password\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsErrorInvalidArgument,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"password missing, invalid argument error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(\n\t\t\t\t\tt,\n\t\t\t\t),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tuserID:        \"user1\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsErrorInvalidArgument,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"login policy not found, precondition error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(\n\t\t\t\t\tt,\n\t\t\t\t\texpectFilter(),\n\t\t\t\t\texpectFilter(),\n\t\t\t\t),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tuserID:        \"user1\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t\tpassword:      \"password\",\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsPreconditionFailed,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"login policy login password not allowed, precondition error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(\n\t\t\t\t\tt,\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\torg.NewLoginPolicyAddedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&org.NewAggregate(\"org1\").Aggregate,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tdomain.PasswordlessTypeNotAllowed,\n\t\t\t\t\t\t\t\t\"\",\n\t\t\t\t\t\t\t\ttime.Hour*1,\n\t\t\t\t\t\t\t\ttime.Hour*2,\n\t\t\t\t\t\t\t\ttime.Hour*3,\n\t\t\t\t\t\t\t\ttime.Hour*4,\n\t\t\t\t\t\t\t\ttime.Hour*5,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tuserID:        \"user1\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t\tpassword:      \"password\",\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsPreconditionFailed,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"user not existing, precondition error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(\n\t\t\t\t\tt,\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\torg.NewLoginPolicyAddedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&org.NewAggregate(\"org1\").Aggregate,\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tdomain.PasswordlessTypeNotAllowed,\n\t\t\t\t\t\t\t\t\"\",\n\t\t\t\t\t\t\t\ttime.Hour*1,\n\t\t\t\t\t\t\t\ttime.Hour*2,\n\t\t\t\t\t\t\t\ttime.Hour*3,\n\t\t\t\t\t\t\t\ttime.Hour*4,\n\t\t\t\t\t\t\t\ttime.Hour*5,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t\texpectFilter(),\n\t\t\t\t),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tuserID:        \"user1\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t\tpassword:      \"password\",\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsPreconditionFailed,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"user locked, precondition error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(\n\t\t\t\t\tt,\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\torg.NewLoginPolicyAddedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&org.NewAggregate(\"org1\").Aggregate,\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tdomain.PasswordlessTypeNotAllowed,\n\t\t\t\t\t\t\t\t\"\",\n\t\t\t\t\t\t\t\ttime.Hour*1,\n\t\t\t\t\t\t\t\ttime.Hour*2,\n\t\t\t\t\t\t\t\ttime.Hour*3,\n\t\t\t\t\t\t\t\ttime.Hour*4,\n\t\t\t\t\t\t\t\ttime.Hour*5,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanAddedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\t\"username\",\n\t\t\t\t\t\t\t\t\"firstname\",\n\t\t\t\t\t\t\t\t\"lastname\",\n\t\t\t\t\t\t\t\t\"nickname\",\n\t\t\t\t\t\t\t\t\"displayname\",\n\t\t\t\t\t\t\t\tlanguage.German,\n\t\t\t\t\t\t\t\tdomain.GenderUnspecified,\n\t\t\t\t\t\t\t\t\"email@test.ch\",\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewUserLockedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tuserID:        \"user1\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t\tpassword:      \"password\",\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsPreconditionFailed,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"existing password empty, precondition error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(\n\t\t\t\t\tt,\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\torg.NewLoginPolicyAddedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&org.NewAggregate(\"org1\").Aggregate,\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tdomain.PasswordlessTypeNotAllowed,\n\t\t\t\t\t\t\t\t\"\",\n\t\t\t\t\t\t\t\ttime.Hour*1,\n\t\t\t\t\t\t\t\ttime.Hour*2,\n\t\t\t\t\t\t\t\ttime.Hour*3,\n\t\t\t\t\t\t\t\ttime.Hour*4,\n\t\t\t\t\t\t\t\ttime.Hour*5,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanAddedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\t\"username\",\n\t\t\t\t\t\t\t\t\"firstname\",\n\t\t\t\t\t\t\t\t\"lastname\",\n\t\t\t\t\t\t\t\t\"nickname\",\n\t\t\t\t\t\t\t\t\"displayname\",\n\t\t\t\t\t\t\t\tlanguage.German,\n\t\t\t\t\t\t\t\tdomain.GenderUnspecified,\n\t\t\t\t\t\t\t\t\"email@test.ch\",\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\tuserPasswordHasher: mockPasswordHasher(\"x\"),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tuserID:        \"user1\",\n\t\t\t\tpassword:      \"password\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsPreconditionFailed,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"password not matching lockout policy not relevant, precondition error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(\n\t\t\t\t\tt,\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\torg.NewLoginPolicyAddedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&org.NewAggregate(\"org1\").Aggregate,\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tdomain.PasswordlessTypeNotAllowed,\n\t\t\t\t\t\t\t\t\"\",\n\t\t\t\t\t\t\t\ttime.Hour*1,\n\t\t\t\t\t\t\t\ttime.Hour*2,\n\t\t\t\t\t\t\t\ttime.Hour*3,\n\t\t\t\t\t\t\t\ttime.Hour*4,\n\t\t\t\t\t\t\t\ttime.Hour*5,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanAddedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\t\"username\",\n\t\t\t\t\t\t\t\t\"firstname\",\n\t\t\t\t\t\t\t\t\"lastname\",\n\t\t\t\t\t\t\t\t\"nickname\",\n\t\t\t\t\t\t\t\t\"displayname\",\n\t\t\t\t\t\t\t\tlanguage.German,\n\t\t\t\t\t\t\t\tdomain.GenderUnspecified,\n\t\t\t\t\t\t\t\t\"email@test.ch\",\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanEmailVerifiedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanPasswordChangedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\t\"$plain$x$password\",\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\t\"\")),\n\t\t\t\t\t),\n\t\t\t\t\texpectFilter(),\n\t\t\t\t\texpectPush(\n\t\t\t\t\t\tuser.NewHumanPasswordCheckFailedEvent(context.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t&user.AuthRequestInfo{\n\t\t\t\t\t\t\t\tID:          \"request1\",\n\t\t\t\t\t\t\t\tUserAgentID: \"agent1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\tuserPasswordHasher: mockPasswordHasher(\"x\"),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tuserID:        \"user1\",\n\t\t\t\tpassword:      \"password1\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t\tauthReq: &domain.AuthRequest{\n\t\t\t\t\tID:      \"request1\",\n\t\t\t\t\tAgentID: \"agent1\",\n\t\t\t\t},\n\t\t\t\tlockoutPolicy: &domain.LockoutPolicy{},\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsErrorInvalidArgument,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"password not matching, max password attempts reached - user locked, precondition error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(\n\t\t\t\t\tt,\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\torg.NewLoginPolicyAddedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&org.NewAggregate(\"org1\").Aggregate,\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tdomain.PasswordlessTypeNotAllowed,\n\t\t\t\t\t\t\t\t\"\",\n\t\t\t\t\t\t\t\ttime.Hour*1,\n\t\t\t\t\t\t\t\ttime.Hour*2,\n\t\t\t\t\t\t\t\ttime.Hour*3,\n\t\t\t\t\t\t\t\ttime.Hour*4,\n\t\t\t\t\t\t\t\ttime.Hour*5,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanAddedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\t\"username\",\n\t\t\t\t\t\t\t\t\"firstname\",\n\t\t\t\t\t\t\t\t\"lastname\",\n\t\t\t\t\t\t\t\t\"nickname\",\n\t\t\t\t\t\t\t\t\"displayname\",\n\t\t\t\t\t\t\t\tlanguage.German,\n\t\t\t\t\t\t\t\tdomain.GenderUnspecified,\n\t\t\t\t\t\t\t\t\"email@test.ch\",\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanEmailVerifiedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanPasswordChangedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\t\"$plain$x$password\",\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\t\"\"),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t\texpectFilter(),\n\t\t\t\t\texpectPush(\n\t\t\t\t\t\tuser.NewHumanPasswordCheckFailedEvent(context.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t&user.AuthRequestInfo{\n\t\t\t\t\t\t\t\tID:          \"request1\",\n\t\t\t\t\t\t\t\tUserAgentID: \"agent1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t),\n\t\t\t\t\t\tuser.NewUserLockedEvent(context.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\tuserPasswordHasher: mockPasswordHasher(\"x\"),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tuserID:        \"user1\",\n\t\t\t\tpassword:      \"password1\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t\tauthReq: &domain.AuthRequest{\n\t\t\t\t\tID:      \"request1\",\n\t\t\t\t\tAgentID: \"agent1\",\n\t\t\t\t},\n\t\t\t\tlockoutPolicy: &domain.LockoutPolicy{\n\t\t\t\t\tMaxPasswordAttempts: 1,\n\t\t\t\t},\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsErrorInvalidArgument,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"check password, ok\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(\n\t\t\t\t\tt,\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\torg.NewLoginPolicyAddedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&org.NewAggregate(\"org1\").Aggregate,\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tdomain.PasswordlessTypeNotAllowed,\n\t\t\t\t\t\t\t\t\"\",\n\t\t\t\t\t\t\t\ttime.Hour*1,\n\t\t\t\t\t\t\t\ttime.Hour*2,\n\t\t\t\t\t\t\t\ttime.Hour*3,\n\t\t\t\t\t\t\t\ttime.Hour*4,\n\t\t\t\t\t\t\t\ttime.Hour*5,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanAddedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\t\"username\",\n\t\t\t\t\t\t\t\t\"firstname\",\n\t\t\t\t\t\t\t\t\"lastname\",\n\t\t\t\t\t\t\t\t\"nickname\",\n\t\t\t\t\t\t\t\t\"displayname\",\n\t\t\t\t\t\t\t\tlanguage.German,\n\t\t\t\t\t\t\t\tdomain.GenderUnspecified,\n\t\t\t\t\t\t\t\t\"email@test.ch\",\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanEmailVerifiedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanPasswordChangedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\t\"$plain$x$password\",\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\t\"\")),\n\t\t\t\t\t),\n\t\t\t\t\texpectFilter(),\n\t\t\t\t\texpectPush(\n\t\t\t\t\t\tuser.NewHumanPasswordCheckSucceededEvent(context.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t&user.AuthRequestInfo{\n\t\t\t\t\t\t\t\tID:          \"request1\",\n\t\t\t\t\t\t\t\tUserAgentID: \"agent1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\tuserPasswordHasher: mockPasswordHasher(\"x\"),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tuserID:        \"user1\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t\tpassword:      \"password\",\n\t\t\t\tauthReq: &domain.AuthRequest{\n\t\t\t\t\tID:      \"request1\",\n\t\t\t\t\tAgentID: \"agent1\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tres: res{},\n\t\t},\n\t\t{\n\t\t\tname: \"check password, ok, updated hash\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(\n\t\t\t\t\tt,\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\torg.NewLoginPolicyAddedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&org.NewAggregate(\"org1\").Aggregate,\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tdomain.PasswordlessTypeNotAllowed,\n\t\t\t\t\t\t\t\t\"\",\n\t\t\t\t\t\t\t\ttime.Hour*1,\n\t\t\t\t\t\t\t\ttime.Hour*2,\n\t\t\t\t\t\t\t\ttime.Hour*3,\n\t\t\t\t\t\t\t\ttime.Hour*4,\n\t\t\t\t\t\t\t\ttime.Hour*5,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanAddedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\t\"username\",\n\t\t\t\t\t\t\t\t\"firstname\",\n\t\t\t\t\t\t\t\t\"lastname\",\n\t\t\t\t\t\t\t\t\"nickname\",\n\t\t\t\t\t\t\t\t\"displayname\",\n\t\t\t\t\t\t\t\tlanguage.German,\n\t\t\t\t\t\t\t\tdomain.GenderUnspecified,\n\t\t\t\t\t\t\t\t\"email@test.ch\",\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanEmailVerifiedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanPasswordChangedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\t\"$plain$v$password\",\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\t\"\")),\n\t\t\t\t\t),\n\t\t\t\t\texpectFilter(),\n\t\t\t\t\texpectPush(\n\t\t\t\t\t\tuser.NewHumanPasswordCheckSucceededEvent(\n\t\t\t\t\t\t\tcontext.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t&user.AuthRequestInfo{\n\t\t\t\t\t\t\t\tID:          \"request1\",\n\t\t\t\t\t\t\t\tUserAgentID: \"agent1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t),\n\t\t\t\t\t\tuser.NewHumanPasswordHashUpdatedEvent(context.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\"$plain$x$password\",\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\tuserPasswordHasher: mockPasswordHasher(\"x\"),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tuserID:        \"user1\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t\tpassword:      \"password\",\n\t\t\t\tauthReq: &domain.AuthRequest{\n\t\t\t\t\tID:      \"request1\",\n\t\t\t\t\tAgentID: \"agent1\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tres: res{},\n\t\t},\n\t\t{\n\t\t\tname: \"check password ok, locked in the mean time\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(\n\t\t\t\t\tt,\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\torg.NewLoginPolicyAddedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&org.NewAggregate(\"org1\").Aggregate,\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tdomain.PasswordlessTypeNotAllowed,\n\t\t\t\t\t\t\t\t\"\",\n\t\t\t\t\t\t\t\ttime.Hour*1,\n\t\t\t\t\t\t\t\ttime.Hour*2,\n\t\t\t\t\t\t\t\ttime.Hour*3,\n\t\t\t\t\t\t\t\ttime.Hour*4,\n\t\t\t\t\t\t\t\ttime.Hour*5,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanAddedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\t\"username\",\n\t\t\t\t\t\t\t\t\"firstname\",\n\t\t\t\t\t\t\t\t\"lastname\",\n\t\t\t\t\t\t\t\t\"nickname\",\n\t\t\t\t\t\t\t\t\"displayname\",\n\t\t\t\t\t\t\t\tlanguage.German,\n\t\t\t\t\t\t\t\tdomain.GenderUnspecified,\n\t\t\t\t\t\t\t\t\"email@test.ch\",\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanEmailVerifiedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanPasswordChangedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\t\"$plain$x$password\",\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\t\"\")),\n\t\t\t\t\t),\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewUserLockedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\tuserPasswordHasher: mockPasswordHasher(\"x\"),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tuserID:        \"user1\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t\tpassword:      \"password\",\n\t\t\t\tauthReq: &domain.AuthRequest{\n\t\t\t\t\tID:      \"request1\",\n\t\t\t\t\tAgentID: \"agent1\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsPreconditionFailed,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"regression test old version event\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(\n\t\t\t\t\tt,\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\torg.NewLoginPolicyAddedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&org.NewAggregate(\"org1\").Aggregate,\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tdomain.PasswordlessTypeNotAllowed,\n\t\t\t\t\t\t\t\t\"\",\n\t\t\t\t\t\t\t\ttime.Hour*1,\n\t\t\t\t\t\t\t\ttime.Hour*2,\n\t\t\t\t\t\t\t\ttime.Hour*3,\n\t\t\t\t\t\t\t\ttime.Hour*4,\n\t\t\t\t\t\t\t\ttime.Hour*5,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanAddedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\t\"username\",\n\t\t\t\t\t\t\t\t\"firstname\",\n\t\t\t\t\t\t\t\t\"lastname\",\n\t\t\t\t\t\t\t\t\"nickname\",\n\t\t\t\t\t\t\t\t\"displayname\",\n\t\t\t\t\t\t\t\tlanguage.German,\n\t\t\t\t\t\t\t\tdomain.GenderUnspecified,\n\t\t\t\t\t\t\t\t\"email@test.ch\",\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanEmailVerifiedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\t&user.HumanPasswordChangedEvent{\n\t\t\t\t\t\t\t\tBaseEvent: *eventstore.NewBaseEventForPush(\n\t\t\t\t\t\t\t\t\tcontext.Background(),\n\t\t\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\t\tuser.HumanPasswordChangedType,\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\tSecret: &crypto.CryptoValue{\n\t\t\t\t\t\t\t\t\tCryptoType: crypto.TypeHash,\n\t\t\t\t\t\t\t\t\tAlgorithm:  \"plain\",\n\t\t\t\t\t\t\t\t\tKeyID:      \"\",\n\t\t\t\t\t\t\t\t\tCrypted:    []byte(\"$plain$v$password\"),\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tChangeRequired: false,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t\texpectFilter(),\n\t\t\t\t\texpectPush(\n\t\t\t\t\t\tuser.NewHumanPasswordCheckSucceededEvent(context.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t&user.AuthRequestInfo{\n\t\t\t\t\t\t\t\tID:          \"request1\",\n\t\t\t\t\t\t\t\tUserAgentID: \"agent1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t),\n\t\t\t\t\t\tuser.NewHumanPasswordHashUpdatedEvent(context.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"user1\", \"org1\").Aggregate,\n\t\t\t\t\t\t\t\"$plain$x$password\",\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\tuserPasswordHasher: mockPasswordHasher(\"x\"),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:           context.Background(),\n\t\t\t\tuserID:        \"user1\",\n\t\t\t\tresourceOwner: \"org1\",\n\t\t\t\tpassword:      \"password\",\n\t\t\t\tauthReq: &domain.AuthRequest{\n\t\t\t\t\tID:      \"request1\",\n\t\t\t\t\tAgentID: \"agent1\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tres: res{},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tr := &Commands{\n\t\t\t\teventstore:         tt.fields.eventstore,\n\t\t\t\tuserPasswordHasher: tt.fields.userPasswordHasher,\n\t\t\t}\n\t\t\terr := r.HumanCheckPassword(tt.args.ctx, tt.args.resourceOwner, tt.args.userID, tt.args.password, tt.args.authReq, tt.args.lockoutPolicy)\n\t\t\tif tt.res.err == nil {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t\tif tt.res.err != nil && !tt.res.err(err) {\n\t\t\t\tt.Errorf(\"got wrong err: %v \", err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_convertPasswapErr(t *testing.T) {\n\ttype args struct {\n\t\terr error\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantErr error\n\t}{\n\t\t{\n\t\t\tname:    \"nil\",\n\t\t\targs:    args{nil},\n\t\t\twantErr: nil,\n\t\t},\n\t\t{\n\t\t\tname:    \"mismatch\",\n\t\t\targs:    args{passwap.ErrPasswordMismatch},\n\t\t\twantErr: caos_errs.ThrowInvalidArgument(passwap.ErrPasswordMismatch, \"COMMAND-3M0fs\", \"Errors.User.Password.Invalid\"),\n\t\t},\n\t\t{\n\t\t\tname:    \"no change\",\n\t\t\targs:    args{passwap.ErrPasswordNoChange},\n\t\t\twantErr: caos_errs.ThrowPreconditionFailed(passwap.ErrPasswordNoChange, \"COMMAND-Aesh5\", \"Errors.User.Password.NotChanged\"),\n\t\t},\n\t\t{\n\t\t\tname:    \"other\",\n\t\t\targs:    args{io.ErrClosedPipe},\n\t\t\twantErr: caos_errs.ThrowInternal(io.ErrClosedPipe, \"COMMAND-CahN2\", \"Errors.Internal\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\terr := convertPasswapErr(tt.args.err)\n\t\t\tassert.ErrorIs(t, err, tt.wantErr)\n\t\t})\n\t}\n}\n", "package query\n\nimport (\n\t\"context\"\n\t\"time\"\n\n\t\"github.com/zitadel/zitadel/internal/crypto\"\n\t\"github.com/zitadel/zitadel/internal/domain\"\n\t\"github.com/zitadel/zitadel/internal/errors\"\n\t\"github.com/zitadel/zitadel/internal/eventstore\"\n\t\"github.com/zitadel/zitadel/internal/repository/user\"\n\t\"github.com/zitadel/zitadel/internal/telemetry/tracing\"\n)\n\ntype HumanPasswordReadModel struct {\n\t*eventstore.ReadModel\n\n\tEncodedHash          string\n\tSecretChangeRequired bool\n\n\tCode                     *crypto.CryptoValue\n\tCodeCreationDate         time.Time\n\tCodeExpiry               time.Duration\n\tPasswordCheckFailedCount uint64\n\n\tUserState domain.UserState\n}\n\nfunc (q *Queries) GetHumanPassword(ctx context.Context, orgID, userID string) (encodedHash string, err error) {\n\tctx, span := tracing.NewSpan(ctx)\n\tdefer func() { span.EndWithError(err) }()\n\n\tif userID == \"\" {\n\t\treturn \"\", errors.ThrowInvalidArgument(nil, \"QUERY-4Mfsf\", \"Errors.User.UserIDMissing\")\n\t}\n\texistingPassword, err := q.passwordReadModel(ctx, userID, orgID)\n\tif err != nil {\n\t\treturn \"\", errors.ThrowInternal(nil, \"QUERY-p1k1n2i\", \"Errors.User.NotFound\")\n\t}\n\tif existingPassword.UserState == domain.UserStateUnspecified || existingPassword.UserState == domain.UserStateDeleted {\n\t\treturn \"\", errors.ThrowPreconditionFailed(nil, \"QUERY-3n77z\", \"Errors.User.NotFound\")\n\t}\n\treturn existingPassword.EncodedHash, nil\n}\n\nfunc (q *Queries) passwordReadModel(ctx context.Context, userID, resourceOwner string) (readModel *HumanPasswordReadModel, err error) {\n\tctx, span := tracing.NewSpan(ctx)\n\tdefer func() { span.EndWithError(err) }()\n\n\treadModel = NewHumanPasswordReadModel(userID, resourceOwner)\n\terr = q.eventstore.FilterToQueryReducer(ctx, readModel)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn readModel, nil\n}\n\nfunc NewHumanPasswordReadModel(userID, resourceOwner string) *HumanPasswordReadModel {\n\treturn &HumanPasswordReadModel{\n\t\tReadModel: &eventstore.ReadModel{\n\t\t\tAggregateID:   userID,\n\t\t\tResourceOwner: resourceOwner,\n\t\t},\n\t}\n}\n\nfunc (rm *HumanPasswordReadModel) AppendEvents(events ...eventstore.Event) {\n\trm.ReadModel.AppendEvents(events...)\n}\n\nfunc (wm *HumanPasswordReadModel) Reduce() error {\n\tfor _, event := range wm.Events {\n\t\tswitch e := event.(type) {\n\t\tcase *user.HumanAddedEvent:\n\t\t\twm.EncodedHash = user.SecretOrEncodedHash(e.Secret, e.EncodedHash)\n\t\t\twm.SecretChangeRequired = e.ChangeRequired\n\t\t\twm.UserState = domain.UserStateActive\n\t\tcase *user.HumanRegisteredEvent:\n\t\t\twm.EncodedHash = user.SecretOrEncodedHash(e.Secret, e.EncodedHash)\n\t\t\twm.SecretChangeRequired = e.ChangeRequired\n\t\t\twm.UserState = domain.UserStateActive\n\t\tcase *user.HumanInitialCodeAddedEvent:\n\t\t\twm.UserState = domain.UserStateInitial\n\t\tcase *user.HumanInitializedCheckSucceededEvent:\n\t\t\twm.UserState = domain.UserStateActive\n\t\tcase *user.HumanPasswordChangedEvent:\n\t\t\twm.EncodedHash = user.SecretOrEncodedHash(e.Secret, e.EncodedHash)\n\t\t\twm.SecretChangeRequired = e.ChangeRequired\n\t\t\twm.Code = nil\n\t\t\twm.PasswordCheckFailedCount = 0\n\t\tcase *user.HumanPasswordCodeAddedEvent:\n\t\t\twm.Code = e.Code\n\t\t\twm.CodeCreationDate = e.CreationDate()\n\t\t\twm.CodeExpiry = e.Expiry\n\t\tcase *user.HumanEmailVerifiedEvent:\n\t\t\tif wm.UserState == domain.UserStateInitial {\n\t\t\t\twm.UserState = domain.UserStateActive\n\t\t\t}\n\t\tcase *user.HumanPasswordCheckFailedEvent:\n\t\t\twm.PasswordCheckFailedCount += 1\n\t\tcase *user.HumanPasswordCheckSucceededEvent:\n\t\t\twm.PasswordCheckFailedCount = 0\n\t\tcase *user.UserLockedEvent:\n\t\t\twm.UserState = domain.UserStateLocked\n\t\tcase *user.UserUnlockedEvent:\n\t\t\twm.PasswordCheckFailedCount = 0\n\t\t\tif wm.UserState != domain.UserStateDeleted {\n\t\t\t\twm.UserState = domain.UserStateActive\n\t\t\t}\n\t\tcase *user.UserRemovedEvent:\n\t\t\twm.UserState = domain.UserStateDeleted\n\t\tcase *user.HumanPasswordHashUpdatedEvent:\n\t\t\twm.EncodedHash = e.EncodedHash\n\t\t}\n\t}\n\treturn wm.ReadModel.Reduce()\n}\n\nfunc (wm *HumanPasswordReadModel) Query() *eventstore.SearchQueryBuilder {\n\tquery := eventstore.NewSearchQueryBuilder(eventstore.ColumnsEvent).\n\t\tAwaitOpenTransactions().\n\t\tAllowTimeTravel().\n\t\tAddQuery().\n\t\tAggregateTypes(user.AggregateType).\n\t\tAggregateIDs(wm.AggregateID).\n\t\tEventTypes(user.HumanAddedType,\n\t\t\tuser.HumanRegisteredType,\n\t\t\tuser.HumanInitialCodeAddedType,\n\t\t\tuser.HumanInitializedCheckSucceededType,\n\t\t\tuser.HumanPasswordChangedType,\n\t\t\tuser.HumanPasswordCodeAddedType,\n\t\t\tuser.HumanEmailVerifiedType,\n\t\t\tuser.HumanPasswordCheckFailedType,\n\t\t\tuser.HumanPasswordCheckSucceededType,\n\t\t\tuser.HumanPasswordHashUpdatedType,\n\t\t\tuser.UserRemovedType,\n\t\t\tuser.UserLockedType,\n\t\t\tuser.UserUnlockedType,\n\t\t\tuser.UserV1AddedType,\n\t\t\tuser.UserV1RegisteredType,\n\t\t\tuser.UserV1InitialCodeAddedType,\n\t\t\tuser.UserV1InitializedCheckSucceededType,\n\t\t\tuser.UserV1PasswordChangedType,\n\t\t\tuser.UserV1PasswordCodeAddedType,\n\t\t\tuser.UserV1EmailVerifiedType,\n\t\t\tuser.UserV1PasswordCheckFailedType,\n\t\t\tuser.UserV1PasswordCheckSucceededType,\n\t\t).\n\t\tBuilder()\n\n\tif wm.ResourceOwner != \"\" {\n\t\tquery.ResourceOwner(wm.ResourceOwner)\n\t}\n\treturn query\n}\n"], "filenames": ["internal/command/user_human_password.go", "internal/command/user_human_password_model.go", "internal/command/user_human_password_test.go", "internal/query/user_password.go"], "buggy_code_start_loc": [235, 67, 1226, 102], "buggy_code_end_loc": [263, 110, 1684, 131], "fixing_code_start_loc": [236, 68, 1226, 103], "fixing_code_end_loc": [273, 120, 1833, 138], "type": "CWE-362", "message": "ZITADEL provides identity infrastructure. ZITADEL provides administrators the possibility to define a `Lockout Policy` with a maximum amount of failed password check attempts. On every failed password check, the amount of failed checks is compared against the configured maximum. Exceeding the limit, will lock the user and prevent further authentication. In the affected implementation it was possible for an attacker to start multiple parallel password checks, giving him the possibility to try out more combinations than configured in the `Lockout Policy`. This vulnerability has been patched in versions 2.40.5 and 2.38.3.\n", "other": {"cve": {"id": "CVE-2023-47111", "sourceIdentifier": "security-advisories@github.com", "published": "2023-11-08T22:15:10.657", "lastModified": "2023-11-16T17:33:53.937", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "ZITADEL provides identity infrastructure. ZITADEL provides administrators the possibility to define a `Lockout Policy` with a maximum amount of failed password check attempts. On every failed password check, the amount of failed checks is compared against the configured maximum. Exceeding the limit, will lock the user and prevent further authentication. In the affected implementation it was possible for an attacker to start multiple parallel password checks, giving him the possibility to try out more combinations than configured in the `Lockout Policy`. This vulnerability has been patched in versions 2.40.5 and 2.38.3.\n"}, {"lang": "es", "value": "ZITADEL proporciona infraestructura de identidad. ZITADEL brinda a los administradores la posibilidad de definir una \"Pol\u00edtica de bloqueo\" con una cantidad m\u00e1xima de intentos fallidos de verificaci\u00f3n de contrase\u00f1a. En cada verificaci\u00f3n de contrase\u00f1a fallida, la cantidad de comprobaciones fallidas se compara con el m\u00e1ximo configurado. Exceder el l\u00edmite bloquear\u00e1 al usuario y evitar\u00e1 una mayor autenticaci\u00f3n. En la implementaci\u00f3n afectada, un atacante pod\u00eda iniciar m\u00faltiples comprobaciones de contrase\u00f1as en paralelo, d\u00e1ndole la posibilidad de probar m\u00e1s combinaciones de las configuradas en la \"Pol\u00edtica de bloqueo\". Esta vulnerabilidad ha sido parcheada en las versiones 2.40.5 y 2.38.3."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 3.7, "baseSeverity": "LOW"}, "exploitabilityScore": 2.2, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-362"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:zitadel:zitadel:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.38.3", "matchCriteriaId": "CF7331E5-9891-4D72-B9D1-71620A21A006"}, {"vulnerable": true, "criteria": "cpe:2.3:a:zitadel:zitadel:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.39.0", "versionEndExcluding": "2.40.5", "matchCriteriaId": "8EA4342D-C972-4980-8E06-4F19EA76E69E"}]}]}], "references": [{"url": "https://github.com/zitadel/zitadel/commit/22e2d5599918864877e054ebe82fb834a5aa1077", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/zitadel/zitadel/releases/tag/v2.38.3", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/zitadel/zitadel/releases/tag/v2.40.5", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/zitadel/zitadel/security/advisories/GHSA-7h8m-vrxx-vr4m", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/zitadel/zitadel/commit/22e2d5599918864877e054ebe82fb834a5aa1077"}}