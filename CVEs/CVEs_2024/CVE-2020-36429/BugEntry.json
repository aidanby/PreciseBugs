{"buggy_code": ["/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. \n *\n *    Copyright 2014-2018 (c) Fraunhofer IOSB (Author: Julius Pfrommer)\n *    Copyright 2018 (c) Fraunhofer IOSB (Author: Lukas Meling)\n */\n\n#include \"ua_types_encoding_json.h\"\n\n#include <open62541/types_generated.h>\n#include <open62541/types_generated_handling.h>\n\n#include \"ua_types_encoding_binary.h\"\n\n#include <float.h>\n#include <math.h>\n\n#ifdef UA_ENABLE_CUSTOM_LIBC\n#include \"../deps/musl/floatscan.h\"\n#include \"../deps/musl/vfprintf.h\"\n#endif\n\n#include \"../deps/itoa.h\"\n#include \"../deps/atoi.h\"\n#include \"../deps/string_escape.h\"\n#include \"../deps/base64.h\"\n\n#include \"../deps/libc_time.h\"\n\n#if defined(_MSC_VER)\n# define strtoll _strtoi64\n# define strtoull _strtoui64\n#endif\n\n/* vs2008 does not have INFINITY and NAN defined */\n#ifndef INFINITY\n# define INFINITY ((UA_Double)(DBL_MAX+DBL_MAX))\n#endif\n#ifndef NAN\n# define NAN ((UA_Double)(INFINITY-INFINITY))\n#endif\n\n#if defined(_MSC_VER)\n# pragma warning(disable: 4756)\n# pragma warning(disable: 4056)\n#endif\n\n#define UA_NODEIDTYPE_NUMERIC_TWOBYTE 0\n#define UA_NODEIDTYPE_NUMERIC_FOURBYTE 1\n#define UA_NODEIDTYPE_NUMERIC_COMPLETE 2\n\n#define UA_EXPANDEDNODEID_SERVERINDEX_FLAG 0x40\n#define UA_EXPANDEDNODEID_NAMESPACEURI_FLAG 0x80\n\n#define UA_JSON_DATETIME_LENGTH 30\n\n/* Max length of numbers for the allocation of temp buffers. Don't forget that\n * printf adds an additional \\0 at the end!\n *\n * Sources:\n * https://www.exploringbinary.com/maximum-number-of-decimal-digits-in-binary-floating-point-numbers/\n *\n * UInt16: 3 + 1\n * SByte: 3 + 1\n * UInt32:\n * Int32:\n * UInt64:\n * Int64:\n * Float: 149 + 1\n * Double: 767 + 1\n */\n\n/************/\n/* Encoding */\n/************/\n\n#define ENCODE_JSON(TYPE) static status \\\n    TYPE##_encodeJson(const UA_##TYPE *src, const UA_DataType *type, CtxJson *ctx)\n\n#define ENCODE_DIRECT_JSON(SRC, TYPE) \\\n    TYPE##_encodeJson((const UA_##TYPE*)SRC, NULL, ctx)\n\nextern const encodeJsonSignature encodeJsonJumpTable[UA_DATATYPEKINDS];\nextern const decodeJsonSignature decodeJsonJumpTable[UA_DATATYPEKINDS];\n\n/* Forward declarations */\nUA_String UA_DateTime_toJSON(UA_DateTime t);\nENCODE_JSON(ByteString);\n\nstatic status UA_FUNC_ATTR_WARN_UNUSED_RESULT\nwriteChar(CtxJson *ctx, char c) {\n    if(ctx->pos >= ctx->end)\n        return UA_STATUSCODE_BADENCODINGLIMITSEXCEEDED;\n    if(!ctx->calcOnly)\n        *ctx->pos = (UA_Byte)c;\n    ctx->pos++;\n    return UA_STATUSCODE_GOOD;\n}\n\n#define WRITE_JSON_ELEMENT(ELEM)                            \\\n    UA_FUNC_ATTR_WARN_UNUSED_RESULT status                  \\\n    writeJson##ELEM(CtxJson *ctx)\n\nstatic WRITE_JSON_ELEMENT(Quote) {\n    return writeChar(ctx, '\\\"');\n}\n\nWRITE_JSON_ELEMENT(ObjStart) {\n    /* increase depth, save: before first key-value no comma needed. */\n    ctx->depth++;\n    ctx->commaNeeded[ctx->depth] = false;\n    return writeChar(ctx, '{');\n}\n\nWRITE_JSON_ELEMENT(ObjEnd) {\n    ctx->depth--; //decrease depth\n    ctx->commaNeeded[ctx->depth] = true;\n    return writeChar(ctx, '}');\n}\n\nWRITE_JSON_ELEMENT(ArrStart) {\n    /* increase depth, save: before first array entry no comma needed. */\n    ctx->commaNeeded[++ctx->depth] = false;\n    return writeChar(ctx, '[');\n}\n\nWRITE_JSON_ELEMENT(ArrEnd) {\n    ctx->depth--; //decrease depth\n    ctx->commaNeeded[ctx->depth] = true;\n    return writeChar(ctx, ']');\n}\n\nWRITE_JSON_ELEMENT(CommaIfNeeded) {\n    if(ctx->commaNeeded[ctx->depth])\n        return writeChar(ctx, ',');\n    return UA_STATUSCODE_GOOD;\n}\n\nstatus\nwriteJsonArrElm(CtxJson *ctx, const void *value,\n                const UA_DataType *type) {\n    status ret = writeJsonCommaIfNeeded(ctx);\n    ctx->commaNeeded[ctx->depth] = true;\n    ret |= encodeJsonInternal(value, type, ctx);\n    return ret;\n}\n\nstatus writeJsonObjElm(CtxJson *ctx, const char *key,\n                       const void *value, const UA_DataType *type){\n    return writeJsonKey(ctx, key) | encodeJsonInternal(value, type, ctx);\n}\n\nstatus writeJsonNull(CtxJson *ctx) {\n    if(ctx->pos + 4 > ctx->end)\n        return UA_STATUSCODE_BADENCODINGLIMITSEXCEEDED;\n    if(ctx->calcOnly) {\n        ctx->pos += 4;\n    } else {\n        *(ctx->pos++) = 'n';\n        *(ctx->pos++) = 'u';\n        *(ctx->pos++) = 'l';\n        *(ctx->pos++) = 'l';\n    }\n    return UA_STATUSCODE_GOOD;\n}\n\n/* Keys for JSON */\n\n/* LocalizedText */\nstatic const char* UA_JSONKEY_LOCALE = \"Locale\";\nstatic const char* UA_JSONKEY_TEXT = \"Text\";\n\n/* QualifiedName */\nstatic const char* UA_JSONKEY_NAME = \"Name\";\nstatic const char* UA_JSONKEY_URI = \"Uri\";\n\n/* NodeId */\nstatic const char* UA_JSONKEY_ID = \"Id\";\nstatic const char* UA_JSONKEY_IDTYPE = \"IdType\";\nstatic const char* UA_JSONKEY_NAMESPACE = \"Namespace\";\n\n/* ExpandedNodeId */\nstatic const char* UA_JSONKEY_SERVERURI = \"ServerUri\";\n\n/* Variant */\nstatic const char* UA_JSONKEY_TYPE = \"Type\";\nstatic const char* UA_JSONKEY_BODY = \"Body\";\nstatic const char* UA_JSONKEY_DIMENSION = \"Dimension\";\n\n/* DataValue */\nstatic const char* UA_JSONKEY_VALUE = \"Value\";\nstatic const char* UA_JSONKEY_STATUS = \"Status\";\nstatic const char* UA_JSONKEY_SOURCETIMESTAMP = \"SourceTimestamp\";\nstatic const char* UA_JSONKEY_SOURCEPICOSECONDS = \"SourcePicoseconds\";\nstatic const char* UA_JSONKEY_SERVERTIMESTAMP = \"ServerTimestamp\";\nstatic const char* UA_JSONKEY_SERVERPICOSECONDS = \"ServerPicoseconds\";\n\n/* ExtensionObject */\nstatic const char* UA_JSONKEY_ENCODING = \"Encoding\";\nstatic const char* UA_JSONKEY_TYPEID = \"TypeId\";\n\n/* StatusCode */\nstatic const char* UA_JSONKEY_CODE = \"Code\";\nstatic const char* UA_JSONKEY_SYMBOL = \"Symbol\";\n\n/* DiagnosticInfo */\nstatic const char* UA_JSONKEY_SYMBOLICID = \"SymbolicId\";\nstatic const char* UA_JSONKEY_NAMESPACEURI = \"NamespaceUri\";\nstatic const char* UA_JSONKEY_LOCALIZEDTEXT = \"LocalizedText\";\nstatic const char* UA_JSONKEY_ADDITIONALINFO = \"AdditionalInfo\";\nstatic const char* UA_JSONKEY_INNERSTATUSCODE = \"InnerStatusCode\";\nstatic const char* UA_JSONKEY_INNERDIAGNOSTICINFO = \"InnerDiagnosticInfo\";\n\n/* Writes null terminated string to output buffer (current ctx->pos). Writes\n * comma in front of key if needed. Encapsulates key in quotes. */\nstatus UA_FUNC_ATTR_WARN_UNUSED_RESULT\nwriteJsonKey(CtxJson *ctx, const char* key) {\n    size_t size = strlen(key);\n    if(ctx->pos + size + 4 > ctx->end) /* +4 because of \" \" : and , */\n        return UA_STATUSCODE_BADENCODINGLIMITSEXCEEDED;\n    status ret = writeJsonCommaIfNeeded(ctx);\n    ctx->commaNeeded[ctx->depth] = true;\n    if(ctx->calcOnly) {\n        ctx->commaNeeded[ctx->depth] = true;\n        ctx->pos += 3;\n        ctx->pos += size;\n        return ret;\n    }\n\n    ret |= writeChar(ctx, '\\\"');\n    for(size_t i = 0; i < size; i++) {\n        *(ctx->pos++) = (u8)key[i];\n    }\n    ret |= writeChar(ctx, '\\\"');\n    ret |= writeChar(ctx, ':');\n    return ret;\n}\n\n/* Boolean */\nENCODE_JSON(Boolean) {\n    size_t sizeOfJSONBool;\n    if(*src == true) {\n        sizeOfJSONBool = 4; /*\"true\"*/\n    } else {\n        sizeOfJSONBool = 5; /*\"false\"*/\n    }\n\n    if(ctx->calcOnly) {\n        ctx->pos += sizeOfJSONBool;\n        return UA_STATUSCODE_GOOD;\n    }\n\n    if(ctx->pos + sizeOfJSONBool > ctx->end)\n        return UA_STATUSCODE_BADENCODINGLIMITSEXCEEDED;\n\n    if(*src) {\n        *(ctx->pos++) = 't';\n        *(ctx->pos++) = 'r';\n        *(ctx->pos++) = 'u';\n        *(ctx->pos++) = 'e';\n    } else {\n        *(ctx->pos++) = 'f';\n        *(ctx->pos++) = 'a';\n        *(ctx->pos++) = 'l';\n        *(ctx->pos++) = 's';\n        *(ctx->pos++) = 'e';\n    }\n    return UA_STATUSCODE_GOOD;\n}\n\n/*****************/\n/* Integer Types */\n/*****************/\n\n/* Byte */\nENCODE_JSON(Byte) {\n    char buf[4];\n    UA_UInt16 digits = itoaUnsigned(*src, buf, 10);\n\n    /* Ensure destination can hold the data- */\n    if(ctx->pos + digits > ctx->end)\n        return UA_STATUSCODE_BADENCODINGLIMITSEXCEEDED;\n\n    /* Copy digits to the output string/buffer. */\n    if(!ctx->calcOnly)\n        memcpy(ctx->pos, buf, digits);\n    ctx->pos += digits;\n    return UA_STATUSCODE_GOOD;\n}\n\n/* signed Byte */\nENCODE_JSON(SByte) {\n    char buf[5];\n    UA_UInt16 digits = itoaSigned(*src, buf);\n    if(ctx->pos + digits > ctx->end)\n        return UA_STATUSCODE_BADENCODINGLIMITSEXCEEDED;\n    if(!ctx->calcOnly)\n        memcpy(ctx->pos, buf, digits);\n    ctx->pos += digits;\n    return UA_STATUSCODE_GOOD;\n}\n\n/* UInt16 */\nENCODE_JSON(UInt16) {\n    char buf[6];\n    UA_UInt16 digits = itoaUnsigned(*src, buf, 10);\n\n    if(ctx->pos + digits > ctx->end)\n        return UA_STATUSCODE_BADENCODINGLIMITSEXCEEDED;\n\n    if(!ctx->calcOnly)\n        memcpy(ctx->pos, buf, digits);\n    ctx->pos += digits;\n    return UA_STATUSCODE_GOOD;\n}\n\n/* Int16 */\nENCODE_JSON(Int16) {\n    char buf[7];\n    UA_UInt16 digits = itoaSigned(*src, buf);\n\n    if(ctx->pos + digits > ctx->end)\n        return UA_STATUSCODE_BADENCODINGLIMITSEXCEEDED;\n\n    if(!ctx->calcOnly)\n        memcpy(ctx->pos, buf, digits);\n    ctx->pos += digits;\n    return UA_STATUSCODE_GOOD;\n}\n\n/* UInt32 */\nENCODE_JSON(UInt32) {\n    char buf[11];\n    UA_UInt16 digits = itoaUnsigned(*src, buf, 10);\n\n    if(ctx->pos + digits > ctx->end)\n        return UA_STATUSCODE_BADENCODINGLIMITSEXCEEDED;\n\n    if(!ctx->calcOnly)\n        memcpy(ctx->pos, buf, digits);\n    ctx->pos += digits;\n    return UA_STATUSCODE_GOOD;\n}\n\n/* Int32 */\nENCODE_JSON(Int32) {\n    char buf[12];\n    UA_UInt16 digits = itoaSigned(*src, buf);\n\n    if(ctx->pos + digits > ctx->end)\n        return UA_STATUSCODE_BADENCODINGLIMITSEXCEEDED;\n\n    if(!ctx->calcOnly)\n        memcpy(ctx->pos, buf, digits);\n    ctx->pos += digits;\n    return UA_STATUSCODE_GOOD;\n}\n\n/* UInt64 */\nENCODE_JSON(UInt64) {\n    char buf[23];\n    buf[0] = '\\\"';\n    UA_UInt16 digits = itoaUnsigned(*src, buf + 1, 10);\n    buf[digits + 1] = '\\\"';\n    UA_UInt16 length = (UA_UInt16)(digits + 2);\n\n    if(ctx->pos + length > ctx->end)\n        return UA_STATUSCODE_BADENCODINGLIMITSEXCEEDED;\n\n    if(!ctx->calcOnly)\n        memcpy(ctx->pos, buf, length);\n\n    ctx->pos += length;\n    return UA_STATUSCODE_GOOD;\n}\n\n/* Int64 */\nENCODE_JSON(Int64) {\n    char buf[23];\n    buf[0] = '\\\"';\n    UA_UInt16 digits = itoaSigned(*src, buf + 1);\n    buf[digits + 1] = '\\\"';\n    UA_UInt16 length = (UA_UInt16)(digits + 2);\n\n    if(ctx->pos + length > ctx->end)\n        return UA_STATUSCODE_BADENCODINGLIMITSEXCEEDED;\n\n    if(!ctx->calcOnly)\n        memcpy(ctx->pos, buf, length);\n    ctx->pos += length;\n    return UA_STATUSCODE_GOOD;\n}\n\n/************************/\n/* Floating Point Types */\n/************************/\n\n/* Convert special numbers to string\n * - fmt_fp gives NAN, nan,-NAN, -nan, inf, INF, -inf, -INF\n * - Special floating-point numbers such as positive infinity (INF), negative\n *   infinity (-INF) and not-a-number (NaN) shall be represented by the values\n *   \u201cInfinity\u201d, \u201c-Infinity\u201d and \u201cNaN\u201d encoded as a JSON string. */\nstatic status\ncheckAndEncodeSpecialFloatingPoint(char *buffer, size_t *len) {\n    /*nan and NaN*/\n    if(*len == 3 && \n            (buffer[0] == 'n' || buffer[0] == 'N') && \n            (buffer[1] == 'a' || buffer[1] == 'A') && \n            (buffer[2] == 'n' || buffer[2] == 'N')) {\n        *len = 5;\n        memcpy(buffer, \"\\\"NaN\\\"\", *len);\n        return UA_STATUSCODE_GOOD;\n    }\n\n    /*-nan and -NaN*/\n    if(*len == 4 && buffer[0] == '-' && \n            (buffer[1] == 'n' || buffer[1] == 'N') && \n            (buffer[2] == 'a' || buffer[2] == 'A') && \n            (buffer[3] == 'n' || buffer[3] == 'N')) {\n        *len = 6;\n        memcpy(buffer, \"\\\"-NaN\\\"\", *len);\n        return UA_STATUSCODE_GOOD;\n    }\n\n    /*inf*/\n    if(*len == 3 && \n            (buffer[0] == 'i' || buffer[0] == 'I') && \n            (buffer[1] == 'n' || buffer[1] == 'N') && \n            (buffer[2] == 'f' || buffer[2] == 'F')) {\n        *len = 10;\n        memcpy(buffer, \"\\\"Infinity\\\"\", *len);\n        return UA_STATUSCODE_GOOD;\n    }\n\n    /*-inf*/\n    if(*len == 4 && buffer[0] == '-' && \n            (buffer[1] == 'i' || buffer[1] == 'I') && \n            (buffer[2] == 'n' || buffer[2] == 'N') && \n            (buffer[3] == 'f' || buffer[3] == 'F')) {\n        *len = 11;\n        memcpy(buffer, \"\\\"-Infinity\\\"\", *len);\n        return UA_STATUSCODE_GOOD;\n    }\n    return UA_STATUSCODE_GOOD;\n}\n\nENCODE_JSON(Float) {\n    char buffer[200];\n    if(*src == *src) {\n#ifdef UA_ENABLE_CUSTOM_LIBC\n        fmt_fp(buffer, *src, 0, -1, 0, 'g');\n#else\n        UA_snprintf(buffer, 200, \"%.149g\", (UA_Double)*src);\n#endif\n    } else {\n        strcpy(buffer, \"NaN\");\n    }\n\n    size_t len = strlen(buffer);\n    if(len == 0)\n        return UA_STATUSCODE_BADENCODINGERROR;\n    \n    checkAndEncodeSpecialFloatingPoint(buffer, &len);\n    \n    if(ctx->pos + len > ctx->end)\n        return UA_STATUSCODE_BADENCODINGLIMITSEXCEEDED;\n\n    if(!ctx->calcOnly)\n        memcpy(ctx->pos, buffer, len);\n\n    ctx->pos += len;\n    return UA_STATUSCODE_GOOD;\n}\n\nENCODE_JSON(Double) {\n    char buffer[2000];\n    if(*src == *src) {\n#ifdef UA_ENABLE_CUSTOM_LIBC\n        fmt_fp(buffer, *src, 0, 17, 0, 'g');\n#else\n        UA_snprintf(buffer, 2000, \"%.1074g\", *src);\n#endif\n    } else {\n        strcpy(buffer, \"NaN\");\n    }\n\n    size_t len = strlen(buffer);\n    checkAndEncodeSpecialFloatingPoint(buffer, &len);    \n\n    if(ctx->pos + len > ctx->end)\n        return UA_STATUSCODE_BADENCODINGLIMITSEXCEEDED;\n\n    if(!ctx->calcOnly)\n        memcpy(ctx->pos, buffer, len);\n\n    ctx->pos += len;\n    return UA_STATUSCODE_GOOD;\n}\n\nstatic status\nencodeJsonArray(CtxJson *ctx, const void *ptr, size_t length,\n                const UA_DataType *type) {\n    encodeJsonSignature encodeType = encodeJsonJumpTable[type->typeKind];\n    status ret = writeJsonArrStart(ctx);\n    uintptr_t uptr = (uintptr_t)ptr;\n    for(size_t i = 0; i < length && ret == UA_STATUSCODE_GOOD; ++i) {\n        ret |= writeJsonCommaIfNeeded(ctx);\n        ret |= encodeType((const void*)uptr, type, ctx);\n        ctx->commaNeeded[ctx->depth] = true;\n        uptr += type->memSize;\n    }\n    ret |= writeJsonArrEnd(ctx);\n    return ret;\n}\n\n/*****************/\n/* Builtin Types */\n/*****************/\n\nstatic const u8 hexmapLower[16] =\n    {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};\nstatic const u8 hexmapUpper[16] =\n    {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};\n\nENCODE_JSON(String) {\n    if(!src->data)\n        return writeJsonNull(ctx);\n\n    if(src->length == 0) {\n        status retval = writeJsonQuote(ctx);\n        retval |= writeJsonQuote(ctx);\n        return  retval;\n    }\n\n    UA_StatusCode ret = writeJsonQuote(ctx);\n    \n    /* Escaping adapted from https://github.com/akheron/jansson dump.c */\n\n    const char *str = (char*)src->data;\n    const char *pos = str;\n    const char *end = str;\n    const char *lim = str + src->length;\n    UA_UInt32 codepoint = 0;\n    while(1) {\n        const char *text;\n        u8 seq[13];\n        size_t length;\n\n        while(end < lim) {\n            end = utf8_iterate(pos, (size_t)(lim - pos), (int32_t *)&codepoint);\n            if(!end)\n                return UA_STATUSCODE_BADENCODINGERROR;\n\n            /* mandatory escape or control char */\n            if(codepoint == '\\\\' || codepoint == '\"' || codepoint < 0x20)\n                break;\n\n            /* TODO: Why is this commented? */\n            /* slash \n            if((flags & JSON_ESCAPE_SLASH) && codepoint == '/')\n                break;*/\n\n            /* non-ASCII\n            if((flags & JSON_ENSURE_ASCII) && codepoint > 0x7F)\n                break;*/\n\n            pos = end;\n        }\n\n        if(pos != str) {\n            if(ctx->pos + (pos - str) > ctx->end)\n                return UA_STATUSCODE_BADENCODINGLIMITSEXCEEDED;\n            if(!ctx->calcOnly)\n                memcpy(ctx->pos, str, (size_t)(pos - str));\n            ctx->pos += pos - str;\n        }\n\n        if(end == pos)\n            break;\n\n        /* handle \\, /, \", and control codes */\n        length = 2;\n        switch(codepoint) {\n        case '\\\\': text = \"\\\\\\\\\"; break;\n        case '\\\"': text = \"\\\\\\\"\"; break;\n        case '\\b': text = \"\\\\b\"; break;\n        case '\\f': text = \"\\\\f\"; break;\n        case '\\n': text = \"\\\\n\"; break;\n        case '\\r': text = \"\\\\r\"; break;\n        case '\\t': text = \"\\\\t\"; break;\n        case '/':  text = \"\\\\/\"; break;\n        default:\n            if(codepoint < 0x10000) {\n                /* codepoint is in BMP */\n                seq[0] = '\\\\';\n                seq[1] = 'u';\n                UA_Byte b1 = (UA_Byte)(codepoint >> 8u);\n                UA_Byte b2 = (UA_Byte)(codepoint >> 0u);\n                seq[2] = hexmapLower[(b1 & 0xF0u) >> 4u];\n                seq[3] = hexmapLower[b1 & 0x0Fu];\n                seq[4] = hexmapLower[(b2 & 0xF0u) >> 4u];\n                seq[5] = hexmapLower[b2 & 0x0Fu];\n                length = 6;\n            } else {\n                /* not in BMP -> construct a UTF-16 surrogate pair */\n                codepoint -= 0x10000;\n                UA_UInt32 first = 0xD800u | ((codepoint & 0xffc00u) >> 10u);\n                UA_UInt32 last = 0xDC00u | (codepoint & 0x003ffu);\n\n                UA_Byte fb1 = (UA_Byte)(first >> 8u);\n                UA_Byte fb2 = (UA_Byte)(first >> 0u);\n                    \n                UA_Byte lb1 = (UA_Byte)(last >> 8u);\n                UA_Byte lb2 = (UA_Byte)(last >> 0u);\n                    \n                seq[0] = '\\\\';\n                seq[1] = 'u';\n                seq[2] = hexmapLower[(fb1 & 0xF0u) >> 4u];\n                seq[3] = hexmapLower[fb1 & 0x0Fu];\n                seq[4] = hexmapLower[(fb2 & 0xF0u) >> 4u];\n                seq[5] = hexmapLower[fb2 & 0x0Fu];\n                    \n                seq[6] = '\\\\';\n                seq[7] = 'u';\n                seq[8] = hexmapLower[(lb1 & 0xF0u) >> 4u];\n                seq[9] = hexmapLower[lb1 & 0x0Fu];\n                seq[10] = hexmapLower[(lb2 & 0xF0u) >> 4u];\n                seq[11] = hexmapLower[lb2 & 0x0Fu];\n                length = 12;\n            }\n            text = (char*)seq;\n            break;\n        }\n\n        if(ctx->pos + length > ctx->end)\n            return UA_STATUSCODE_BADENCODINGLIMITSEXCEEDED;\n        if(!ctx->calcOnly)\n            memcpy(ctx->pos, text, length);\n        ctx->pos += length;\n        str = pos = end;\n    }\n\n    ret |= writeJsonQuote(ctx);\n    return ret;\n}\n    \nENCODE_JSON(ByteString) {\n    if(!src->data)\n        return writeJsonNull(ctx);\n\n    if(src->length == 0) {\n        status retval = writeJsonQuote(ctx);\n        retval |= writeJsonQuote(ctx);\n        return retval;\n    }\n\n    status ret = writeJsonQuote(ctx);\n    size_t flen = 0;\n    unsigned char *ba64 = UA_base64(src->data, src->length, &flen);\n    \n    /* Not converted, no mem */\n    if(!ba64)\n        return UA_STATUSCODE_BADENCODINGERROR;\n\n    if(ctx->pos + flen > ctx->end) {\n        UA_free(ba64);\n        return UA_STATUSCODE_BADENCODINGLIMITSEXCEEDED;\n    }\n    \n    /* Copy flen bytes to output stream. */\n    if(!ctx->calcOnly)\n        memcpy(ctx->pos, ba64, flen);\n    ctx->pos += flen;\n\n    /* Base64 result no longer needed */\n    UA_free(ba64);\n    \n    ret |= writeJsonQuote(ctx);\n    return ret;\n}\n\n/* Converts Guid to a hexadecimal represenation */\nstatic void UA_Guid_to_hex(const UA_Guid *guid, u8* out) {\n    /*\n                          16 byte\n       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n       |   data1   |data2|data3|          data4        |\n       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n       |aa aa aa aa-bb bb-cc cc-dd dd-ee ee ee ee ee ee|\n       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n                          36 character\n    */\n\n#ifdef hexCharlowerCase\n    const u8 *hexmap = hexmapLower;\n#else\n    const u8 *hexmap = hexmapUpper;\n#endif\n    size_t i = 0, j = 28;\n    for(; i<8;i++,j-=4)         /* pos 0-7, 4byte, (a) */\n        out[i] = hexmap[(guid->data1 >> j) & 0x0Fu];\n    out[i++] = '-';             /* pos 8 */\n    for(j=12; i<13;i++,j-=4)    /* pos 9-12, 2byte, (b) */\n        out[i] = hexmap[(uint16_t)(guid->data2 >> j) & 0x0Fu];\n    out[i++] = '-';             /* pos 13 */\n    for(j=12; i<18;i++,j-=4)    /* pos 14-17, 2byte (c) */\n        out[i] = hexmap[(uint16_t)(guid->data3 >> j) & 0x0Fu];\n    out[i++] = '-';             /* pos 18 */\n    for(j=0;i<23;i+=2,j++) {     /* pos 19-22, 2byte (d) */\n        out[i] = hexmap[(guid->data4[j] & 0xF0u) >> 4u];\n        out[i+1] = hexmap[guid->data4[j] & 0x0Fu];\n    }\n    out[i++] = '-';             /* pos 23 */\n    for(j=2; i<36;i+=2,j++) {    /* pos 24-35, 6byte (e) */\n        out[i] = hexmap[(guid->data4[j] & 0xF0u) >> 4u];\n        out[i+1] = hexmap[guid->data4[j] & 0x0Fu];\n    }\n}\n\n/* Guid */\nENCODE_JSON(Guid) {\n    if(ctx->pos + 38 > ctx->end) /* 36 + 2 (\") */\n        return UA_STATUSCODE_BADENCODINGLIMITSEXCEEDED;\n    status ret = writeJsonQuote(ctx);\n    u8 *buf = ctx->pos;\n    if(!ctx->calcOnly)\n        UA_Guid_to_hex(src, buf);\n    ctx->pos += 36;\n    ret |= writeJsonQuote(ctx);\n    return ret;\n}\n\nstatic void\nprintNumber(u16 n, u8 *pos, size_t digits) {\n    for(size_t i = digits; i > 0; --i) {\n        pos[i - 1] = (u8) ((n % 10) + '0');\n        n = n / 10;\n    }\n}\n\nENCODE_JSON(DateTime) {\n    UA_DateTimeStruct tSt = UA_DateTime_toStruct(*src);\n\n    /* Format: yyyy-MM-dd'T'HH:mm:ss.SSSSSSSSS'Z' is used. max 30 bytes.*/\n    UA_Byte buffer[UA_JSON_DATETIME_LENGTH];\n\n    printNumber(tSt.year, &buffer[0], 4);\n    buffer[4] = '-';\n    printNumber(tSt.month, &buffer[5], 2);\n    buffer[7] = '-';\n    printNumber(tSt.day, &buffer[8], 2);\n    buffer[10] = 'T';\n    printNumber(tSt.hour, &buffer[11], 2);\n    buffer[13] = ':';\n    printNumber(tSt.min, &buffer[14], 2);\n    buffer[16] = ':';\n    printNumber(tSt.sec, &buffer[17], 2);\n    buffer[19] = '.';\n    printNumber(tSt.milliSec, &buffer[20], 3);\n    printNumber(tSt.microSec, &buffer[23], 3);\n    printNumber(tSt.nanoSec, &buffer[26], 3);\n\n    size_t length = 28;\n    while (buffer[length] == '0')\n        length--;\n    if (length != 19)\n         length++;\n\n    buffer[length] = 'Z';\n    UA_String str = {length + 1, buffer};\n    return ENCODE_DIRECT_JSON(&str, String);\n}\n\n/* NodeId */\nstatic status\nNodeId_encodeJsonInternal(UA_NodeId const *src, CtxJson *ctx) {\n    status ret = UA_STATUSCODE_GOOD;\n    switch (src->identifierType) {\n    case UA_NODEIDTYPE_NUMERIC:\n        ret |= writeJsonKey(ctx, UA_JSONKEY_ID);\n        ret |= ENCODE_DIRECT_JSON(&src->identifier.numeric, UInt32);\n        break;\n    case UA_NODEIDTYPE_STRING:\n        ret |= writeJsonKey(ctx, UA_JSONKEY_IDTYPE);\n        ret |= writeChar(ctx, '1');\n        ret |= writeJsonKey(ctx, UA_JSONKEY_ID);\n        ret |= ENCODE_DIRECT_JSON(&src->identifier.string, String);\n        break;\n    case UA_NODEIDTYPE_GUID:\n        ret |= writeJsonKey(ctx, UA_JSONKEY_IDTYPE);\n        ret |= writeChar(ctx, '2');\n        ret |= writeJsonKey(ctx, UA_JSONKEY_ID); /* Id */\n        ret |= ENCODE_DIRECT_JSON(&src->identifier.guid, Guid);\n        break;\n    case UA_NODEIDTYPE_BYTESTRING:\n        ret |= writeJsonKey(ctx, UA_JSONKEY_IDTYPE);\n        ret |= writeChar(ctx, '3');\n        ret |= writeJsonKey(ctx, UA_JSONKEY_ID); /* Id */\n        ret |= ENCODE_DIRECT_JSON(&src->identifier.byteString, ByteString);\n        break;\n    default:\n        return UA_STATUSCODE_BADINTERNALERROR;\n    }\n    return ret;\n}\n\nENCODE_JSON(NodeId) {\n    UA_StatusCode ret = writeJsonObjStart(ctx);\n    ret |= NodeId_encodeJsonInternal(src, ctx);\n    if(ctx->useReversible) {\n        if(src->namespaceIndex > 0) {\n            ret |= writeJsonKey(ctx, UA_JSONKEY_NAMESPACE);\n            ret |= ENCODE_DIRECT_JSON(&src->namespaceIndex, UInt16);\n        }\n    } else {\n        /* For the non-reversible encoding, the field is the NamespaceUri \n         * associated with the NamespaceIndex, encoded as a JSON string.\n         * A NamespaceIndex of 1 is always encoded as a JSON number. */\n        if(src->namespaceIndex == 1) {\n            ret |= writeJsonKey(ctx, UA_JSONKEY_NAMESPACE);\n            ret |= ENCODE_DIRECT_JSON(&src->namespaceIndex, UInt16);\n        } else {\n            ret |= writeJsonKey(ctx, UA_JSONKEY_NAMESPACE);\n            \n            /* Check if Namespace given and in range */\n            if(src->namespaceIndex < ctx->namespacesSize && ctx->namespaces != NULL) {\n                UA_String namespaceEntry = ctx->namespaces[src->namespaceIndex];\n                ret |= ENCODE_DIRECT_JSON(&namespaceEntry, String);\n            } else {\n                return UA_STATUSCODE_BADNOTFOUND;\n            }\n        }\n    }\n\n    ret |= writeJsonObjEnd(ctx);\n    return ret;\n}\n\n/* ExpandedNodeId */\nENCODE_JSON(ExpandedNodeId) {\n    status ret = writeJsonObjStart(ctx);\n    /* Encode the NodeId */\n    ret |= NodeId_encodeJsonInternal(&src->nodeId, ctx);\n    \n    if(ctx->useReversible) {\n        if(src->namespaceUri.data != NULL && src->namespaceUri.length != 0 && \n           (void*) src->namespaceUri.data > UA_EMPTY_ARRAY_SENTINEL) {\n            /* If the NamespaceUri is specified it is encoded as a JSON string in this field. */ \n            ret |= writeJsonKey(ctx, UA_JSONKEY_NAMESPACE);\n            ret |= ENCODE_DIRECT_JSON(&src->namespaceUri, String);\n        } else {\n            /* If the NamespaceUri is not specified, the NamespaceIndex is encoded with these rules:\n             * The field is encoded as a JSON number for the reversible encoding.\n             * The field is omitted if the NamespaceIndex equals 0. */\n            if(src->nodeId.namespaceIndex > 0) {\n                ret |= writeJsonKey(ctx, UA_JSONKEY_NAMESPACE);\n                ret |= ENCODE_DIRECT_JSON(&src->nodeId.namespaceIndex, UInt16);\n            }\n        }\n\n        /* Encode the serverIndex/Url \n         * This field is encoded as a JSON number for the reversible encoding.\n         * This field is omitted if the ServerIndex equals 0. */\n        if(src->serverIndex > 0) {\n            ret |= writeJsonKey(ctx, UA_JSONKEY_SERVERURI);\n            ret |= ENCODE_DIRECT_JSON(&src->serverIndex, UInt32);\n        }\n\n        ret |= writeJsonObjEnd(ctx);\n        return ret;\n    }\n    \n    \n    /* NON-Reversible Case */\n\n    /* If the NamespaceUri is not specified, the NamespaceIndex is encoded with these rules:\n     * For the non-reversible encoding the field is the NamespaceUri associated with the\n     * NamespaceIndex encoded as a JSON string.\n     * A NamespaceIndex of 1 is always encoded as a JSON number. */\n\n    if(src->namespaceUri.data != NULL && src->namespaceUri.length != 0) {\n        ret |= writeJsonKey(ctx, UA_JSONKEY_NAMESPACE);\n        ret |= ENCODE_DIRECT_JSON(&src->namespaceUri, String);\n        if(ret != UA_STATUSCODE_GOOD)\n            return ret;\n    } else {\n        if(src->nodeId.namespaceIndex == 1) {\n            ret |= writeJsonKey(ctx, UA_JSONKEY_NAMESPACE);\n            ret |= ENCODE_DIRECT_JSON(&src->nodeId.namespaceIndex, UInt16);\n            if(ret != UA_STATUSCODE_GOOD)\n                return ret;\n        } else {\n            ret |= writeJsonKey(ctx, UA_JSONKEY_NAMESPACE);\n\n            /* Check if Namespace given and in range */\n            if(src->nodeId.namespaceIndex < ctx->namespacesSize \n                    && ctx->namespaces != NULL) {\n\n                UA_String namespaceEntry = ctx->namespaces[src->nodeId.namespaceIndex];\n                ret |= ENCODE_DIRECT_JSON(&namespaceEntry, String);\n                if(ret != UA_STATUSCODE_GOOD)\n                    return ret;\n            } else {\n                return UA_STATUSCODE_BADNOTFOUND;\n            }\n        }\n    }\n\n    /* For the non-reversible encoding, this field is the ServerUri associated\n     * with the ServerIndex portion of the ExpandedNodeId, encoded as a JSON\n     * string. */\n\n    /* Check if Namespace given and in range */\n    if(src->serverIndex < ctx->serverUrisSize && ctx->serverUris != NULL) {\n        UA_String serverUriEntry = ctx->serverUris[src->serverIndex];\n        ret |= writeJsonKey(ctx, UA_JSONKEY_SERVERURI);\n        ret |= ENCODE_DIRECT_JSON(&serverUriEntry, String);\n    } else {\n        return UA_STATUSCODE_BADNOTFOUND;\n    }\n    ret |= writeJsonObjEnd(ctx);\n    return ret;\n}\n\n/* LocalizedText */\nENCODE_JSON(LocalizedText) {\n    if(ctx->useReversible) {\n        status ret = writeJsonObjStart(ctx);\n        ret |= writeJsonKey(ctx, UA_JSONKEY_LOCALE);\n        ret |= ENCODE_DIRECT_JSON(&src->locale, String);\n        ret |= writeJsonKey(ctx, UA_JSONKEY_TEXT);\n        ret |= ENCODE_DIRECT_JSON(&src->text, String);\n        ret |= writeJsonObjEnd(ctx);\n        return ret;\n    }\n    \n    /* For the non-reversible form, LocalizedText value shall be encoded as a\n     * JSON string containing the Text component.*/\n    return ENCODE_DIRECT_JSON(&src->text, String);\n}\n\nENCODE_JSON(QualifiedName) {\n    status ret = writeJsonObjStart(ctx);\n    ret |= writeJsonKey(ctx, UA_JSONKEY_NAME);\n    ret |= ENCODE_DIRECT_JSON(&src->name, String);\n\n    if(ctx->useReversible) {\n        if(src->namespaceIndex != 0) {\n            ret |= writeJsonKey(ctx, UA_JSONKEY_URI);\n            ret |= ENCODE_DIRECT_JSON(&src->namespaceIndex, UInt16);\n        }\n    } else {\n        /* For the non-reversible form, the NamespaceUri associated with the\n         * NamespaceIndex portion of the QualifiedName is encoded as JSON string\n         * unless the NamespaceIndex is 1 or if NamespaceUri is unknown. In\n         * these cases, the NamespaceIndex is encoded as a JSON number. */\n        if(src->namespaceIndex == 1) {\n            ret |= writeJsonKey(ctx, UA_JSONKEY_URI);\n            ret |= ENCODE_DIRECT_JSON(&src->namespaceIndex, UInt16);\n        } else {\n            ret |= writeJsonKey(ctx, UA_JSONKEY_URI);\n\n             /* Check if Namespace given and in range */\n            if(src->namespaceIndex < ctx->namespacesSize && ctx->namespaces != NULL) {\n                UA_String namespaceEntry = ctx->namespaces[src->namespaceIndex];\n                ret |= ENCODE_DIRECT_JSON(&namespaceEntry, String);\n            } else {\n                /* If not encode as number */\n                ret |= ENCODE_DIRECT_JSON(&src->namespaceIndex, UInt16);\n            }\n        }\n    }\n\n    return ret | writeJsonObjEnd(ctx);\n}\n\nENCODE_JSON(StatusCode) {\n    if(!src)\n        return writeJsonNull(ctx);\n\n    if(ctx->useReversible)\n        return ENCODE_DIRECT_JSON(src, UInt32);\n\n    if(*src == UA_STATUSCODE_GOOD)\n        return writeJsonNull(ctx);\n\n    status ret = UA_STATUSCODE_GOOD;\n    ret |= writeJsonObjStart(ctx);\n    ret |= writeJsonKey(ctx, UA_JSONKEY_CODE);\n    ret |= ENCODE_DIRECT_JSON(src, UInt32);\n    ret |= writeJsonKey(ctx, UA_JSONKEY_SYMBOL);\n    const char *codename = UA_StatusCode_name(*src);\n    UA_String statusDescription = UA_STRING((char*)(uintptr_t)codename);\n    ret |= ENCODE_DIRECT_JSON(&statusDescription, String);\n    ret |= writeJsonObjEnd(ctx);\n    return ret;\n}\n\n/* ExtensionObject */\nENCODE_JSON(ExtensionObject) {\n    u8 encoding = (u8) src->encoding;\n    if(encoding == UA_EXTENSIONOBJECT_ENCODED_NOBODY)\n        return writeJsonNull(ctx);\n    \n    status ret = UA_STATUSCODE_GOOD;\n    /* already encoded content.*/\n    if(encoding <= UA_EXTENSIONOBJECT_ENCODED_XML) {\n        ret |= writeJsonObjStart(ctx);\n        if(ctx->useReversible) {\n            ret |= writeJsonKey(ctx, UA_JSONKEY_TYPEID);\n            ret |= ENCODE_DIRECT_JSON(&src->content.encoded.typeId, NodeId);\n            if(ret != UA_STATUSCODE_GOOD)\n                return ret;\n        }\n        \n        switch (src->encoding) {\n            case UA_EXTENSIONOBJECT_ENCODED_BYTESTRING:\n            {\n                if(ctx->useReversible) {\n                    ret |= writeJsonKey(ctx, UA_JSONKEY_ENCODING);\n                    ret |= writeChar(ctx, '1');\n                }\n                ret |= writeJsonKey(ctx, UA_JSONKEY_BODY);\n                ret |= ENCODE_DIRECT_JSON(&src->content.encoded.body, String);\n                break;\n            }\n            case UA_EXTENSIONOBJECT_ENCODED_XML:\n            {\n                if(ctx->useReversible) {\n                    ret |= writeJsonKey(ctx, UA_JSONKEY_ENCODING);\n                    ret |= writeChar(ctx, '2');\n                }\n                ret |= writeJsonKey(ctx, UA_JSONKEY_BODY);\n                ret |= ENCODE_DIRECT_JSON(&src->content.encoded.body, String);\n                break;\n            }\n            default:\n                ret = UA_STATUSCODE_BADINTERNALERROR;\n        }\n\n        ret |= writeJsonObjEnd(ctx);\n        return ret;\n    } /* encoding <= UA_EXTENSIONOBJECT_ENCODED_XML */\n         \n    /* Cannot encode with no type description */\n    if(!src->content.decoded.type)\n        return UA_STATUSCODE_BADENCODINGERROR;\n\n    if(!src->content.decoded.data)\n        return writeJsonNull(ctx);\n\n    UA_NodeId typeId = src->content.decoded.type->typeId;\n    if(typeId.identifierType != UA_NODEIDTYPE_NUMERIC)\n        return UA_STATUSCODE_BADENCODINGERROR;\n\n    ret |= writeJsonObjStart(ctx);\n    const UA_DataType *contentType = src->content.decoded.type;\n    if(ctx->useReversible) {\n        /* REVERSIBLE */\n        ret |= writeJsonKey(ctx, UA_JSONKEY_TYPEID);\n        ret |= ENCODE_DIRECT_JSON(&typeId, NodeId);\n\n        /* Encode the content */\n        ret |= writeJsonKey(ctx, UA_JSONKEY_BODY);\n        ret |= encodeJsonInternal(src->content.decoded.data, contentType, ctx);\n    } else {\n        /* NON-REVERSIBLE\n         * For the non-reversible form, ExtensionObject values \n         * shall be encoded as a JSON object containing only the \n         * value of the Body field. The TypeId and Encoding fields are dropped.\n         * \n         * TODO: UA_JSONKEY_BODY key in the ExtensionObject?\n         */\n        ret |= writeJsonKey(ctx, UA_JSONKEY_BODY);\n        ret |= encodeJsonInternal(src->content.decoded.data, contentType, ctx);\n    }\n\n    ret |= writeJsonObjEnd(ctx);\n    return ret;\n}\n\nstatic status\nVariant_encodeJsonWrapExtensionObject(const UA_Variant *src, const bool isArray, CtxJson *ctx) {\n    size_t length = 1;\n\n    status ret = UA_STATUSCODE_GOOD;\n    if(isArray) {\n        if(src->arrayLength > UA_INT32_MAX)\n            return UA_STATUSCODE_BADENCODINGERROR;\n        \n        length = src->arrayLength;\n    }\n\n    /* Set up the ExtensionObject */\n    UA_ExtensionObject eo;\n    UA_ExtensionObject_init(&eo);\n    eo.encoding = UA_EXTENSIONOBJECT_DECODED;\n    eo.content.decoded.type = src->type;\n    const u16 memSize = src->type->memSize;\n    uintptr_t ptr = (uintptr_t) src->data;\n\n    if(isArray) {\n        ret |= writeJsonArrStart(ctx);\n        ctx->commaNeeded[ctx->depth] = false;\n\n        /* Iterate over the array */\n        for(size_t i = 0; i <  length && ret == UA_STATUSCODE_GOOD; ++i) {\n            eo.content.decoded.data = (void*) ptr;\n            ret |= writeJsonArrElm(ctx, &eo, &UA_TYPES[UA_TYPES_EXTENSIONOBJECT]);\n            ptr += memSize;\n        }\n    \n        ret |= writeJsonArrEnd(ctx);\n        return ret;\n    }\n\n    eo.content.decoded.data = (void*) ptr;\n    return encodeJsonInternal(&eo, &UA_TYPES[UA_TYPES_EXTENSIONOBJECT], ctx);\n}\n\nstatic status\naddMultiArrayContentJSON(CtxJson *ctx, void* array, const UA_DataType *type, \n                         size_t *index, UA_UInt32 *arrayDimensions, size_t dimensionIndex, \n                         size_t dimensionSize) {\n    /* Check the recursion limit */\n    if(ctx->depth > UA_JSON_ENCODING_MAX_RECURSION)\n        return UA_STATUSCODE_BADENCODINGERROR;\n    \n    /* Stop recursion: The inner Arrays are written */\n    status ret;\n    if(dimensionIndex == (dimensionSize - 1)) {\n        ret = encodeJsonArray(ctx, ((u8*)array) + (type->memSize * *index),\n                              arrayDimensions[dimensionIndex], type);\n        (*index) += arrayDimensions[dimensionIndex];\n        return ret;\n    }\n\n    /* Recurse to the next dimension */\n    ret = writeJsonArrStart(ctx);\n    for(size_t i = 0; i < arrayDimensions[dimensionIndex]; i++) {\n        ret |= writeJsonCommaIfNeeded(ctx);\n        ret |= addMultiArrayContentJSON(ctx, array, type, index, arrayDimensions,\n                                        dimensionIndex + 1, dimensionSize);\n        ctx->commaNeeded[ctx->depth] = true;\n        if(ret != UA_STATUSCODE_GOOD)\n            return ret;\n    }\n    ret |= writeJsonArrEnd(ctx);\n    return ret;\n}\n\nENCODE_JSON(Variant) {\n    /* If type is 0 (NULL) the Variant contains a NULL value and the containing\n     * JSON object shall be omitted or replaced by the JSON literal \u2018null\u2019 (when\n     * an element of a JSON array). */\n    if(!src->type) {\n        return writeJsonNull(ctx);\n    }\n        \n    /* Set the content type in the encoding mask */\n    const UA_Boolean isBuiltin = (src->type->typeKind <= UA_DATATYPEKIND_DIAGNOSTICINFO);\n    const UA_Boolean isEnum = (src->type->typeKind == UA_DATATYPEKIND_ENUM);\n    \n    /* Set the array type in the encoding mask */\n    const bool isArray = src->arrayLength > 0 || src->data <= UA_EMPTY_ARRAY_SENTINEL;\n    const bool hasDimensions = isArray && src->arrayDimensionsSize > 0;\n    status ret = UA_STATUSCODE_GOOD;\n    \n    if(ctx->useReversible) {\n        ret |= writeJsonObjStart(ctx);\n        if(ret != UA_STATUSCODE_GOOD)\n            return ret;\n\n        /* Encode the content */\n        if(!isBuiltin && !isEnum) {\n            /* REVERSIBLE:  NOT BUILTIN, can it be encoded? Wrap in extension object.*/\n            ret |= writeJsonKey(ctx, UA_JSONKEY_TYPE);\n            ret |= ENCODE_DIRECT_JSON(&UA_TYPES[UA_TYPES_EXTENSIONOBJECT].typeId.identifier.numeric, UInt32);\n            ret |= writeJsonKey(ctx, UA_JSONKEY_BODY);\n            ret |= Variant_encodeJsonWrapExtensionObject(src, isArray, ctx);\n        } else if(!isArray) {\n            /*REVERSIBLE:  BUILTIN, single value.*/\n            ret |= writeJsonKey(ctx, UA_JSONKEY_TYPE);\n            ret |= ENCODE_DIRECT_JSON(&src->type->typeId.identifier.numeric, UInt32);\n            ret |= writeJsonKey(ctx, UA_JSONKEY_BODY);\n            ret |= encodeJsonInternal(src->data, src->type, ctx);\n        } else {\n            /*REVERSIBLE:   BUILTIN, array.*/\n            ret |= writeJsonKey(ctx, UA_JSONKEY_TYPE);\n            ret |= ENCODE_DIRECT_JSON(&src->type->typeId.identifier.numeric, UInt32);\n            ret |= writeJsonKey(ctx, UA_JSONKEY_BODY);\n            ret |= encodeJsonArray(ctx, src->data, src->arrayLength, src->type);\n        }\n        \n        if(ret != UA_STATUSCODE_GOOD)\n            return ret;\n        \n        /* REVERSIBLE:  Encode the array dimensions */\n        if(hasDimensions && ret == UA_STATUSCODE_GOOD) {\n            ret |= writeJsonKey(ctx, UA_JSONKEY_DIMENSION);\n            ret |= encodeJsonArray(ctx, src->arrayDimensions, src->arrayDimensionsSize, \n                                   &UA_TYPES[UA_TYPES_INT32]);\n            if(ret != UA_STATUSCODE_GOOD)\n                return ret;\n        }\n\n        ret |= writeJsonObjEnd(ctx);\n        return ret;\n    } /* reversible */\n\n    \n    /* NON-REVERSIBLE\n     * For the non-reversible form, Variant values shall be encoded as a JSON object containing only\n     * the value of the Body field. The Type and Dimensions fields are dropped. Multi-dimensional\n     * arrays are encoded as a multi dimensional JSON array as described in 5.4.5.\n     */\n\n    ret |= writeJsonObjStart(ctx);\n    if(!isBuiltin && !isEnum) {\n        /*NON REVERSIBLE:  NOT BUILTIN, can it be encoded? Wrap in extension object.*/\n        if(src->arrayDimensionsSize > 1) {\n            return UA_STATUSCODE_BADNOTIMPLEMENTED;\n        }\n\n        ret |= writeJsonKey(ctx, UA_JSONKEY_BODY);\n        ret |= Variant_encodeJsonWrapExtensionObject(src, isArray, ctx);\n    } else if(!isArray) {\n        /*NON REVERSIBLE:   BUILTIN, single value.*/\n        ret |= writeJsonKey(ctx, UA_JSONKEY_BODY);\n        ret |= encodeJsonInternal(src->data, src->type, ctx);\n    } else {\n        /*NON REVERSIBLE:   BUILTIN, array.*/\n        ret |= writeJsonKey(ctx, UA_JSONKEY_BODY);\n\n        size_t dimensionSize = src->arrayDimensionsSize;\n        if(dimensionSize > 1) {\n            /*nonreversible multidimensional array*/\n            size_t index = 0;  size_t dimensionIndex = 0;\n            void *ptr = src->data;\n            const UA_DataType *arraytype = src->type;\n            ret |= addMultiArrayContentJSON(ctx, ptr, arraytype, &index, \n                    src->arrayDimensions, dimensionIndex, dimensionSize);\n        } else {\n            /*nonreversible simple array*/\n            ret |= encodeJsonArray(ctx, src->data, src->arrayLength, src->type);\n        }\n    }\n\n    ret |= writeJsonObjEnd(ctx);\n    return ret;\n}\n\n/* DataValue */\nENCODE_JSON(DataValue) {\n    UA_Boolean hasValue = src->hasValue && src->value.type != NULL;\n    UA_Boolean hasStatus = src->hasStatus && src->status;\n    UA_Boolean hasSourceTimestamp = src->hasSourceTimestamp && src->sourceTimestamp;\n    UA_Boolean hasSourcePicoseconds = src->hasSourcePicoseconds && src->sourcePicoseconds;\n    UA_Boolean hasServerTimestamp = src->hasServerTimestamp && src->serverTimestamp;\n    UA_Boolean hasServerPicoseconds = src->hasServerPicoseconds && src->serverPicoseconds;\n\n    if(!hasValue && !hasStatus && !hasSourceTimestamp && !hasSourcePicoseconds &&\n       !hasServerTimestamp && !hasServerPicoseconds) {\n        return writeJsonNull(ctx); /*no element, encode as null*/\n    }\n\n    status ret = UA_STATUSCODE_GOOD;\n    ret |= writeJsonObjStart(ctx);\n\n    if(hasValue) {\n        ret |= writeJsonKey(ctx, UA_JSONKEY_VALUE);\n        ret |= ENCODE_DIRECT_JSON(&src->value, Variant);\n        if(ret != UA_STATUSCODE_GOOD)\n            return ret;\n    }\n\n    if(hasStatus) {\n        ret |= writeJsonKey(ctx, UA_JSONKEY_STATUS);\n        ret |= ENCODE_DIRECT_JSON(&src->status, StatusCode);\n        if(ret != UA_STATUSCODE_GOOD)\n            return ret;\n    }\n\n    if(hasSourceTimestamp) {\n        ret |= writeJsonKey(ctx, UA_JSONKEY_SOURCETIMESTAMP);\n        ret |= ENCODE_DIRECT_JSON(&src->sourceTimestamp, DateTime);\n        if(ret != UA_STATUSCODE_GOOD)\n            return ret;\n    }\n\n    if(hasSourcePicoseconds) {\n        ret |= writeJsonKey(ctx, UA_JSONKEY_SOURCEPICOSECONDS);\n        ret |= ENCODE_DIRECT_JSON(&src->sourcePicoseconds, UInt16);\n        if(ret != UA_STATUSCODE_GOOD)\n            return ret;\n    }\n\n    if(hasServerTimestamp) {\n        ret |= writeJsonKey(ctx, UA_JSONKEY_SERVERTIMESTAMP);\n        ret |= ENCODE_DIRECT_JSON(&src->serverTimestamp, DateTime);\n        if(ret != UA_STATUSCODE_GOOD)\n            return ret;\n    }\n\n    if(hasServerPicoseconds) {\n        ret |= writeJsonKey(ctx, UA_JSONKEY_SERVERPICOSECONDS);\n        ret |= ENCODE_DIRECT_JSON(&src->serverPicoseconds, UInt16);\n        if(ret != UA_STATUSCODE_GOOD)\n            return ret;\n    }\n\n    ret |= writeJsonObjEnd(ctx);\n    return ret;\n}\n\n/* DiagnosticInfo */\nENCODE_JSON(DiagnosticInfo) {\n    status ret = UA_STATUSCODE_GOOD;\n    if(!src->hasSymbolicId && !src->hasNamespaceUri && !src->hasLocalizedText &&\n       !src->hasLocale && !src->hasAdditionalInfo && !src->hasInnerDiagnosticInfo &&\n       !src->hasInnerStatusCode) {\n        return writeJsonNull(ctx); /*no element present, encode as null.*/\n    }\n    \n    ret |= writeJsonObjStart(ctx);\n    \n    if(src->hasSymbolicId) {\n        ret |= writeJsonKey(ctx, UA_JSONKEY_SYMBOLICID);\n        ret |= ENCODE_DIRECT_JSON(&src->symbolicId, UInt32);\n        if(ret != UA_STATUSCODE_GOOD)\n            return ret;\n    }\n\n    if(src->hasNamespaceUri) {\n        ret |= writeJsonKey(ctx, UA_JSONKEY_NAMESPACEURI);\n        ret |= ENCODE_DIRECT_JSON(&src->namespaceUri, UInt32);\n        if(ret != UA_STATUSCODE_GOOD)\n            return ret;\n    }\n    \n    if(src->hasLocalizedText) {\n        ret |= writeJsonKey(ctx, UA_JSONKEY_LOCALIZEDTEXT);\n        ret |= ENCODE_DIRECT_JSON(&src->localizedText, UInt32);\n        if(ret != UA_STATUSCODE_GOOD)\n            return ret;\n    }\n    \n    if(src->hasLocale) {\n        ret |= writeJsonKey(ctx, UA_JSONKEY_LOCALE);\n        ret |= ENCODE_DIRECT_JSON(&src->locale, UInt32);\n        if(ret != UA_STATUSCODE_GOOD)\n            return ret;\n    }\n    \n    if(src->hasAdditionalInfo) {\n        ret |= writeJsonKey(ctx, UA_JSONKEY_ADDITIONALINFO);\n        ret |= ENCODE_DIRECT_JSON(&src->additionalInfo, String);\n        if(ret != UA_STATUSCODE_GOOD)\n            return ret;\n    }\n\n    if(src->hasInnerStatusCode) {\n        ret |= writeJsonKey(ctx, UA_JSONKEY_INNERSTATUSCODE);\n        ret |= ENCODE_DIRECT_JSON(&src->innerStatusCode, StatusCode);\n        if(ret != UA_STATUSCODE_GOOD)\n            return ret;\n    }\n\n    if(src->hasInnerDiagnosticInfo && src->innerDiagnosticInfo) {\n        ret |= writeJsonKey(ctx, UA_JSONKEY_INNERDIAGNOSTICINFO);\n        /* Check recursion depth in encodeJsonInternal */\n        ret |= encodeJsonInternal(src->innerDiagnosticInfo, &UA_TYPES[UA_TYPES_DIAGNOSTICINFO], ctx);\n        if(ret != UA_STATUSCODE_GOOD)\n            return ret;\n    }\n\n    ret |= writeJsonObjEnd(ctx);\n    return ret;\n}\n\nstatic status\nencodeJsonStructure(const void *src, const UA_DataType *type, CtxJson *ctx) {\n    /* Check the recursion limit */\n    if(ctx->depth > UA_JSON_ENCODING_MAX_RECURSION)\n        return UA_STATUSCODE_BADENCODINGERROR;\n    ctx->depth++;\n\n    status ret = writeJsonObjStart(ctx);\n\n    uintptr_t ptr = (uintptr_t) src;\n    u8 membersSize = type->membersSize;\n    const UA_DataType * typelists[2] = {UA_TYPES, &type[-type->typeIndex]};\n    for(size_t i = 0; i < membersSize && ret == UA_STATUSCODE_GOOD; ++i) {\n        const UA_DataTypeMember *m = &type->members[i];\n        const UA_DataType *mt = &typelists[!m->namespaceZero][m->memberTypeIndex];\n\n        if(m->memberName != NULL && *m->memberName != 0)\n            ret |= writeJsonKey(ctx, m->memberName);\n\n        if(!m->isArray) {\n            ptr += m->padding;\n            size_t memSize = mt->memSize;\n            ret |= encodeJsonJumpTable[mt->typeKind]((const void*) ptr, mt, ctx);\n            ptr += memSize;\n        } else {\n            ptr += m->padding;\n            const size_t length = *((const size_t*) ptr);\n            ptr += sizeof (size_t);\n            ret |= encodeJsonArray(ctx, *(void * const *)ptr, length, mt);\n            ptr += sizeof (void*);\n        }\n    }\n\n    ret |= writeJsonObjEnd(ctx);\n\n    ctx->depth--;\n    return ret;\n}\n\nstatic status\nencodeJsonNotImplemented(const void *src, const UA_DataType *type, CtxJson *ctx) {\n    (void) src, (void) type, (void)ctx;\n    return UA_STATUSCODE_BADNOTIMPLEMENTED;\n}\n\nconst encodeJsonSignature encodeJsonJumpTable[UA_DATATYPEKINDS] = {\n    (encodeJsonSignature)Boolean_encodeJson,\n    (encodeJsonSignature)SByte_encodeJson, /* SByte */\n    (encodeJsonSignature)Byte_encodeJson,\n    (encodeJsonSignature)Int16_encodeJson, /* Int16 */\n    (encodeJsonSignature)UInt16_encodeJson,\n    (encodeJsonSignature)Int32_encodeJson, /* Int32 */\n    (encodeJsonSignature)UInt32_encodeJson,\n    (encodeJsonSignature)Int64_encodeJson, /* Int64 */\n    (encodeJsonSignature)UInt64_encodeJson,\n    (encodeJsonSignature)Float_encodeJson,\n    (encodeJsonSignature)Double_encodeJson,\n    (encodeJsonSignature)String_encodeJson,\n    (encodeJsonSignature)DateTime_encodeJson, /* DateTime */\n    (encodeJsonSignature)Guid_encodeJson,\n    (encodeJsonSignature)ByteString_encodeJson, /* ByteString */\n    (encodeJsonSignature)String_encodeJson, /* XmlElement */\n    (encodeJsonSignature)NodeId_encodeJson,\n    (encodeJsonSignature)ExpandedNodeId_encodeJson,\n    (encodeJsonSignature)StatusCode_encodeJson, /* StatusCode */\n    (encodeJsonSignature)QualifiedName_encodeJson, /* QualifiedName */\n    (encodeJsonSignature)LocalizedText_encodeJson,\n    (encodeJsonSignature)ExtensionObject_encodeJson,\n    (encodeJsonSignature)DataValue_encodeJson,\n    (encodeJsonSignature)Variant_encodeJson,\n    (encodeJsonSignature)DiagnosticInfo_encodeJson,\n    (encodeJsonSignature)encodeJsonNotImplemented, /* Decimal */\n    (encodeJsonSignature)Int32_encodeJson, /* Enum */\n    (encodeJsonSignature)encodeJsonStructure,\n    (encodeJsonSignature)encodeJsonNotImplemented, /* Structure with optional fields */\n    (encodeJsonSignature)encodeJsonNotImplemented, /* Union */\n    (encodeJsonSignature)encodeJsonNotImplemented /* BitfieldCluster */\n};\n\nstatus\nencodeJsonInternal(const void *src, const UA_DataType *type, CtxJson *ctx) {\n    return encodeJsonJumpTable[type->typeKind](src, type, ctx);\n}\n\nstatus UA_FUNC_ATTR_WARN_UNUSED_RESULT\nUA_encodeJson(const void *src, const UA_DataType *type,\n              u8 **bufPos, const u8 **bufEnd, UA_String *namespaces, \n              size_t namespaceSize, UA_String *serverUris, \n              size_t serverUriSize, UA_Boolean useReversible) {\n    if(!src || !type)\n        return UA_STATUSCODE_BADINTERNALERROR;\n    \n    /* Set up the context */\n    CtxJson ctx;\n    memset(&ctx, 0, sizeof(ctx));\n    ctx.pos = *bufPos;\n    ctx.end = *bufEnd;\n    ctx.depth = 0;\n    ctx.namespaces = namespaces;\n    ctx.namespacesSize = namespaceSize;\n    ctx.serverUris = serverUris;\n    ctx.serverUrisSize = serverUriSize;\n    ctx.useReversible = useReversible;\n    ctx.calcOnly = false;\n    \n    /* Encode */\n    status ret = encodeJsonJumpTable[type->typeKind](src, type, &ctx);\n    \n    *bufPos = ctx.pos;\n    *bufEnd = ctx.end;\n    return ret;\n}\n\n/************/\n/* CalcSize */\n/************/\nsize_t\nUA_calcSizeJson(const void *src, const UA_DataType *type,\n                UA_String *namespaces, size_t namespaceSize,\n                UA_String *serverUris, size_t serverUriSize,\n                UA_Boolean useReversible) {\n    if(!src || !type)\n        return UA_STATUSCODE_BADINTERNALERROR;\n\n    /* Set up the context */\n    CtxJson ctx;\n    memset(&ctx, 0, sizeof(ctx));\n    ctx.pos = 0;\n    ctx.end = (const UA_Byte*)(uintptr_t)SIZE_MAX;\n    ctx.depth = 0;\n    ctx.namespaces = namespaces;\n    ctx.namespacesSize = namespaceSize;\n    ctx.serverUris = serverUris;\n    ctx.serverUrisSize = serverUriSize;\n    ctx.useReversible = useReversible;\n    ctx.calcOnly = true;\n\n    /* Encode */\n    status ret = encodeJsonJumpTable[type->typeKind](src, type, &ctx);\n    if(ret != UA_STATUSCODE_GOOD)\n        return 0;\n    return (size_t)ctx.pos;\n}\n\n/**********/\n/* Decode */\n/**********/\n\n/* Macro which gets current size and char pointer of current Token. Needs\n * ParseCtx (parseCtx) and CtxJson (ctx). Does NOT increment index of Token. */\n#define GET_TOKEN(data, size) do {                                               \\\n    (size) = (size_t)(parseCtx->tokenArray[parseCtx->index].end - parseCtx->tokenArray[parseCtx->index].start); \\\n    (data) = (char*)(ctx->pos + parseCtx->tokenArray[parseCtx->index].start); } while(0)\n\n#define ALLOW_NULL do {             \\\n    if(isJsonNull(ctx, parseCtx)) { \\\n        parseCtx->index++;          \\\n        return UA_STATUSCODE_GOOD;  \\\n    }} while(0)\n\n#define CHECK_TOKEN_BOUNDS do {                   \\\n    if(parseCtx->index >= parseCtx->tokenCount)   \\\n        return UA_STATUSCODE_BADDECODINGERROR;    \\\n    } while(0)\n\n#define CHECK_PRIMITIVE do {                      \\\n    if(getJsmnType(parseCtx) != JSMN_PRIMITIVE) { \\\n        return UA_STATUSCODE_BADDECODINGERROR;    \\\n    }} while(0)\n\n#define CHECK_STRING do {                      \\\n    if(getJsmnType(parseCtx) != JSMN_STRING) { \\\n        return UA_STATUSCODE_BADDECODINGERROR; \\\n    }} while(0)\n\n#define CHECK_OBJECT do {                      \\\n    if(getJsmnType(parseCtx) != JSMN_OBJECT) { \\\n        return UA_STATUSCODE_BADDECODINGERROR; \\\n    }} while(0)\n\n/* Forward declarations*/\n#define DECODE_JSON(TYPE) static status                        \\\n    TYPE##_decodeJson(UA_##TYPE *dst, const UA_DataType *type, \\\n                      CtxJson *ctx, ParseCtx *parseCtx, UA_Boolean moveToken)\n\n/* decode without moving the token index */\n#define DECODE_DIRECT_JSON(DST, TYPE) TYPE##_decodeJson((UA_##TYPE*)DST, NULL, ctx, parseCtx, false)\n\n/* If parseCtx->index points to the beginning of an object, move the index to\n * the next token after this object. Attention! The index can be moved after the\n * last parsed token. So the array length has to be checked afterwards. */\nstatic void\nskipObject(ParseCtx *parseCtx) {\n    int end = parseCtx->tokenArray[parseCtx->index].end;\n    do {\n        parseCtx->index++;\n    } while(parseCtx->index < parseCtx->tokenCount &&\n            parseCtx->tokenArray[parseCtx->index].start < end);\n}\n\nstatic status\nArray_decodeJson(void *dst, const UA_DataType *type, CtxJson *ctx, \n        ParseCtx *parseCtx, UA_Boolean moveToken);\n\nstatic status\nArray_decodeJson_internal(void **dst, const UA_DataType *type, \n        CtxJson *ctx, ParseCtx *parseCtx, UA_Boolean moveToken);\n\nstatic status\nVariant_decodeJsonUnwrapExtensionObject(UA_Variant *dst, const UA_DataType *type, \n        CtxJson *ctx, ParseCtx *parseCtx, UA_Boolean moveToken);\n\n/* Json decode Helper */\njsmntype_t\ngetJsmnType(const ParseCtx *parseCtx) {\n    if(parseCtx->index >= parseCtx->tokenCount)\n        return JSMN_UNDEFINED;\n    return parseCtx->tokenArray[parseCtx->index].type;\n}\n\nUA_Boolean\nisJsonNull(const CtxJson *ctx, const ParseCtx *parseCtx) {\n    if(parseCtx->index >= parseCtx->tokenCount)\n        return false;\n\n    if(parseCtx->tokenArray[parseCtx->index].type != JSMN_PRIMITIVE) {\n        return false;\n    }\n    char* elem = (char*)(ctx->pos + parseCtx->tokenArray[parseCtx->index].start);\n    return (elem[0] == 'n' && elem[1] == 'u' && elem[2] == 'l' && elem[3] == 'l');\n}\n\nstatic UA_SByte jsoneq(const char *json, jsmntok_t *tok, const char *searchKey) {\n    /* TODO: necessary?\n       if(json == NULL\n            || tok == NULL \n            || searchKey == NULL) {\n        return -1;\n    } */\n    \n    if(tok->type == JSMN_STRING) {\n         if(strlen(searchKey) == (size_t)(tok->end - tok->start) ) {\n             if(strncmp(json + tok->start,\n                        (const char*)searchKey, (size_t)(tok->end - tok->start)) == 0) {\n                 return 0;\n             }   \n         }\n    }\n    return -1;\n}\n\nDECODE_JSON(Boolean) {\n    CHECK_PRIMITIVE;\n    CHECK_TOKEN_BOUNDS;\n    size_t tokenSize;\n    char* tokenData;\n    GET_TOKEN(tokenData, tokenSize);\n\n    if(tokenSize == 4 &&\n       tokenData[0] == 't' && tokenData[1] == 'r' &&\n       tokenData[2] == 'u' && tokenData[3] == 'e') {\n        *dst = true;\n    } else if(tokenSize == 5 &&\n              tokenData[0] == 'f' && tokenData[1] == 'a' &&\n              tokenData[2] == 'l' && tokenData[3] == 's' &&\n              tokenData[4] == 'e') {\n        *dst = false;\n    } else {\n        return UA_STATUSCODE_BADDECODINGERROR;\n    }\n    \n    if(moveToken)\n        parseCtx->index++;\n    return UA_STATUSCODE_GOOD;\n}\n\n#ifdef UA_ENABLE_CUSTOM_LIBC\nstatic UA_StatusCode\nparseUnsignedInteger(char* inputBuffer, size_t sizeOfBuffer,\n                     UA_UInt64 *destinationOfNumber) {\n    UA_UInt64 d = 0;\n    atoiUnsigned(inputBuffer, sizeOfBuffer, &d);\n    if(!destinationOfNumber)\n        return UA_STATUSCODE_BADDECODINGERROR;\n    *destinationOfNumber = d;\n    return UA_STATUSCODE_GOOD;\n}\n\nstatic UA_StatusCode\nparseSignedInteger(char* inputBuffer, size_t sizeOfBuffer,\n                   UA_Int64 *destinationOfNumber) {\n    UA_Int64 d = 0;\n    atoiSigned(inputBuffer, sizeOfBuffer, &d);\n    if(!destinationOfNumber)\n        return UA_STATUSCODE_BADDECODINGERROR;\n    *destinationOfNumber = d;\n    return UA_STATUSCODE_GOOD;\n}\n#else\n/* Safe strtol variant of unsigned string conversion.\n * Returns UA_STATUSCODE_BADDECODINGERROR in case of overflows.\n * Buffer limit is 20 digits. */\nstatic UA_StatusCode\nparseUnsignedInteger(char* inputBuffer, size_t sizeOfBuffer,\n                     UA_UInt64 *destinationOfNumber) {\n    /* Check size to avoid huge malicious stack allocation.\n     * No UInt64 can have more digits than 20. */\n    if(sizeOfBuffer > 20) {\n        return UA_STATUSCODE_BADDECODINGERROR;\n    }\n\n    /* convert to null terminated string  */\n    UA_STACKARRAY(char, string, sizeOfBuffer+1);\n    memcpy(string, inputBuffer, sizeOfBuffer);\n    string[sizeOfBuffer] = 0;\n\n    /* Conversion */\n    char *endptr, *str;\n    str = string;\n    errno = 0;    /* To distinguish success/failure after call */\n    UA_UInt64 val = strtoull(str, &endptr, 10);\n\n    /* Check for various possible errors */\n    if((errno == ERANGE && (val == LLONG_MAX || val == 0))\n          || (errno != 0 )) {\n        return UA_STATUSCODE_BADDECODINGERROR;\n    }\n\n    /* Check if no digits were found */\n    if(endptr == str)\n        return UA_STATUSCODE_BADDECODINGERROR;\n\n    /* copy to destination */\n    *destinationOfNumber = val;\n    return UA_STATUSCODE_GOOD;\n}\n\n/* Safe strtol variant of unsigned string conversion.\n * Returns UA_STATUSCODE_BADDECODINGERROR in case of overflows.\n * Buffer limit is 20 digits. */\nstatic UA_StatusCode\nparseSignedInteger(char* inputBuffer, size_t sizeOfBuffer,\n                   UA_Int64 *destinationOfNumber) {\n    /* Check size to avoid huge malicious stack allocation.\n     * No UInt64 can have more digits than 20. */\n    if(sizeOfBuffer > 20)\n        return UA_STATUSCODE_BADDECODINGERROR;\n\n    /* convert to null terminated string  */\n    UA_STACKARRAY(char, string, sizeOfBuffer + 1);\n    memcpy(string, inputBuffer, sizeOfBuffer);\n    string[sizeOfBuffer] = 0;\n\n    /* Conversion */\n    char *endptr, *str;\n    str = string;\n    errno = 0;    /* To distinguish success/failure after call */\n    UA_Int64 val = strtoll(str, &endptr, 10);\n\n    /* Check for various possible errors */\n    if((errno == ERANGE && (val == LONG_MAX || val == LONG_MIN))\n          || (errno != 0 )) {\n        return UA_STATUSCODE_BADDECODINGERROR;\n    }\n\n    /* Check if no digits were found */\n    if(endptr == str)\n        return UA_STATUSCODE_BADDECODINGERROR;\n\n    /* copy to destination */\n    *destinationOfNumber = val;\n    return UA_STATUSCODE_GOOD;\n}\n#endif\n\nDECODE_JSON(Byte) {\n    CHECK_TOKEN_BOUNDS;\n    CHECK_PRIMITIVE;\n    size_t tokenSize;\n    char* tokenData;\n    GET_TOKEN(tokenData, tokenSize);\n\n    UA_UInt64 out = 0;\n    UA_StatusCode s = parseUnsignedInteger(tokenData, tokenSize, &out);\n    *dst = (UA_Byte)out;\n\n    if(moveToken)\n        parseCtx->index++;\n    return s;\n}\n\nDECODE_JSON(UInt16) {\n    CHECK_TOKEN_BOUNDS;\n    CHECK_PRIMITIVE;\n    size_t tokenSize;\n    char* tokenData;\n    GET_TOKEN(tokenData, tokenSize);\n\n    UA_UInt64 out = 0;\n    UA_StatusCode s = parseUnsignedInteger(tokenData, tokenSize, &out);\n    *dst = (UA_UInt16)out;\n\n    if(moveToken)\n        parseCtx->index++;\n    return s;\n}\n\nDECODE_JSON(UInt32) {\n    CHECK_TOKEN_BOUNDS;\n    CHECK_PRIMITIVE;\n    size_t tokenSize;\n    char* tokenData;\n    GET_TOKEN(tokenData, tokenSize);\n\n    UA_UInt64 out = 0;\n    UA_StatusCode s = parseUnsignedInteger(tokenData, tokenSize, &out);\n    *dst = (UA_UInt32)out;\n\n    if(moveToken)\n        parseCtx->index++;\n    return s;\n}\n\nDECODE_JSON(UInt64) {\n    CHECK_TOKEN_BOUNDS;\n    CHECK_STRING;\n    size_t tokenSize;\n    char* tokenData;\n    GET_TOKEN(tokenData, tokenSize);\n\n    UA_UInt64 out = 0;\n    UA_StatusCode s = parseUnsignedInteger(tokenData, tokenSize, &out);\n    *dst = (UA_UInt64)out;\n\n    if(moveToken)\n        parseCtx->index++;\n    return s;\n}\n\nDECODE_JSON(SByte) {\n    CHECK_TOKEN_BOUNDS;\n    CHECK_PRIMITIVE;\n    size_t tokenSize;\n    char* tokenData;\n    GET_TOKEN(tokenData, tokenSize);\n\n    UA_Int64 out = 0;\n    UA_StatusCode s = parseSignedInteger(tokenData, tokenSize, &out);\n    *dst = (UA_SByte)out;\n\n    if(moveToken)\n        parseCtx->index++;\n    return s;\n}\n\nDECODE_JSON(Int16) {\n    CHECK_TOKEN_BOUNDS;\n    CHECK_PRIMITIVE;\n    size_t tokenSize;\n    char* tokenData;\n    GET_TOKEN(tokenData, tokenSize);\n\n    UA_Int64 out = 0;\n    UA_StatusCode s = parseSignedInteger(tokenData, tokenSize, &out);\n    *dst = (UA_Int16)out;\n\n    if(moveToken)\n        parseCtx->index++;\n    return s;\n}\n\nDECODE_JSON(Int32) {\n    CHECK_TOKEN_BOUNDS;\n    CHECK_PRIMITIVE;\n    size_t tokenSize;\n    char* tokenData;\n    GET_TOKEN(tokenData, tokenSize);\n\n    UA_Int64 out = 0;\n    UA_StatusCode s = parseSignedInteger(tokenData, tokenSize, &out);\n    *dst = (UA_Int32)out;\n\n    if(moveToken)\n        parseCtx->index++;\n    return s;\n}\n\nDECODE_JSON(Int64) {\n    CHECK_TOKEN_BOUNDS;\n    CHECK_STRING;\n    size_t tokenSize;\n    char* tokenData;\n    GET_TOKEN(tokenData, tokenSize);\n\n    UA_Int64 out = 0;\n    UA_StatusCode s = parseSignedInteger(tokenData, tokenSize, &out);\n    *dst = (UA_Int64)out;\n\n    if(moveToken)\n        parseCtx->index++;\n    return s;\n}\n\nstatic UA_UInt32 hex2int(char ch) {\n    if(ch >= '0' && ch <= '9')\n        return (UA_UInt32)(ch - '0');\n    if(ch >= 'A' && ch <= 'F')\n        return (UA_UInt32)(ch - 'A' + 10);\n    if(ch >= 'a' && ch <= 'f')\n        return (UA_UInt32)(ch - 'a' + 10);\n    return 0;\n}\n\n/* Float\n* Either a JSMN_STRING or JSMN_PRIMITIVE\n*/\nDECODE_JSON(Float) {\n    CHECK_TOKEN_BOUNDS;\n    size_t tokenSize;\n    char* tokenData;\n    GET_TOKEN(tokenData, tokenSize);\n    \n    /* https://www.exploringbinary.com/maximum-number-of-decimal-digits-in-binary-floating-point-numbers/\n     * Maximum digit counts for select IEEE floating-point formats: 149\n     * Sanity check. */\n    if(tokenSize > 150)\n        return UA_STATUSCODE_BADDECODINGERROR;\n\n    jsmntype_t tokenType = getJsmnType(parseCtx);\n    if(tokenType == JSMN_STRING) {\n        /*It could be a String with Nan, Infinity*/\n        if(tokenSize == 8 && memcmp(tokenData, \"Infinity\", 8) == 0) {\n            *dst = (UA_Float)INFINITY;\n            return UA_STATUSCODE_GOOD;\n        }\n        \n        if(tokenSize == 9 && memcmp(tokenData, \"-Infinity\", 9) == 0) {\n            /* workaround an MSVC 2013 issue */\n            *dst = (UA_Float)-INFINITY;\n            return UA_STATUSCODE_GOOD;\n        }\n        \n        if(tokenSize == 3 && memcmp(tokenData, \"NaN\", 3) == 0) {\n            *dst = (UA_Float)NAN;\n            return UA_STATUSCODE_GOOD;\n        }\n        \n        if(tokenSize == 4 && memcmp(tokenData, \"-NaN\", 4) == 0) {\n            *dst = (UA_Float)NAN;\n            return UA_STATUSCODE_GOOD;\n        }\n        return UA_STATUSCODE_BADDECODINGERROR;\n    }\n    \n    if(tokenType != JSMN_PRIMITIVE)\n        return UA_STATUSCODE_BADDECODINGERROR;\n\n    /* Null-Terminate for sscanf. */\n    UA_STACKARRAY(char, string, tokenSize+1);\n    memcpy(string, tokenData, tokenSize);\n    string[tokenSize] = 0;\n    \n    UA_Float d = 0;\n#ifdef UA_ENABLE_CUSTOM_LIBC\n    d = (UA_Float)__floatscan(string, 1, 0);\n#else\n    char c = 0;\n    /* On success, the function returns the number of variables filled.\n     * In the case of an input failure before any data could be successfully read, EOF is returned. */\n    int ret = sscanf(string, \"%f%c\", &d, &c);\n\n    /* Exactly one var must be filled. %c acts as a guard for wrong input which is accepted by sscanf.\n    E.g. 1.23.45 is not accepted. */\n    if(ret == EOF || (ret != 1))\n        return UA_STATUSCODE_BADDECODINGERROR;\n#endif\n    \n    *dst = d;\n\n    parseCtx->index++;\n    return UA_STATUSCODE_GOOD;\n}\n\n/* Either a JSMN_STRING or JSMN_PRIMITIVE */\nDECODE_JSON(Double) {\n    CHECK_TOKEN_BOUNDS;\n    size_t tokenSize;\n    char* tokenData;\n    GET_TOKEN(tokenData, tokenSize);\n    \n    /* https://www.exploringbinary.com/maximum-number-of-decimal-digits-in-binary-floating-point-numbers/\n     * Maximum digit counts for select IEEE floating-point formats: 1074\n     * Sanity check.\n     */\n    if(tokenSize > 1075)\n        return UA_STATUSCODE_BADDECODINGERROR;\n\n    jsmntype_t tokenType = getJsmnType(parseCtx);\n    if(tokenType == JSMN_STRING) {\n        /*It could be a String with Nan, Infinity*/\n        if(tokenSize == 8 && memcmp(tokenData, \"Infinity\", 8) == 0) {\n            *dst = INFINITY;\n            return UA_STATUSCODE_GOOD;\n        }\n        \n        if(tokenSize == 9 && memcmp(tokenData, \"-Infinity\", 9) == 0) {\n            /* workaround an MSVC 2013 issue */\n            *dst = -INFINITY;\n            return UA_STATUSCODE_GOOD;\n        }\n        \n        if(tokenSize == 3 && memcmp(tokenData, \"NaN\", 3) == 0) {\n            *dst = NAN;\n            return UA_STATUSCODE_GOOD;\n        }\n        \n        if(tokenSize == 4 && memcmp(tokenData, \"-NaN\", 4) == 0) {\n            *dst = NAN;\n            return UA_STATUSCODE_GOOD;\n        }\n        return UA_STATUSCODE_BADDECODINGERROR;\n    }\n    \n    if(tokenType != JSMN_PRIMITIVE)\n        return UA_STATUSCODE_BADDECODINGERROR;\n\n    /* Null-Terminate for sscanf. Should this better be handled on heap? Max\n     * 1075 input chars allowed. Not using heap. */\n    UA_STACKARRAY(char, string, tokenSize+1);\n    memcpy(string, tokenData, tokenSize);\n    string[tokenSize] = 0;\n    \n    UA_Double d = 0;\n#ifdef UA_ENABLE_CUSTOM_LIBC\n    d = (UA_Double)__floatscan(string, 2, 0);\n#else\n    char c = 0;\n    /* On success, the function returns the number of variables filled.\n     * In the case of an input failure before any data could be successfully read, EOF is returned. */\n    int ret = sscanf(string, \"%lf%c\", &d, &c);\n\n    /* Exactly one var must be filled. %c acts as a guard for wrong input which is accepted by sscanf.\n    E.g. 1.23.45 is not accepted. */\n    if(ret == EOF || (ret != 1))\n        return UA_STATUSCODE_BADDECODINGERROR;\n#endif\n    \n    *dst = d;\n\n    parseCtx->index++;\n    return UA_STATUSCODE_GOOD;\n}\n\n/*\n  Expects 36 chars in format    00000003-0009-000A-0807-060504030201\n                                | data1| |d2| |d3| |d4| |  data4   |\n*/\nstatic UA_Guid UA_Guid_fromChars(const char* chars) {\n    UA_Guid dst;\n    UA_Guid_init(&dst);\n    for(size_t i = 0; i < 8; i++)\n        dst.data1 |= (UA_UInt32)(hex2int(chars[i]) << (28 - (i*4)));\n    for(size_t i = 0; i < 4; i++) {\n        dst.data2 |= (UA_UInt16)(hex2int(chars[9+i]) << (12 - (i*4)));\n        dst.data3 |= (UA_UInt16)(hex2int(chars[14+i]) << (12 - (i*4)));\n    }\n    dst.data4[0] |= (UA_Byte)(hex2int(chars[19]) << 4u);\n    dst.data4[0] |= (UA_Byte)(hex2int(chars[20]) << 0u);\n    dst.data4[1] |= (UA_Byte)(hex2int(chars[21]) << 4u);\n    dst.data4[1] |= (UA_Byte)(hex2int(chars[22]) << 0u);\n    for(size_t i = 0; i < 6; i++) {\n        dst.data4[2+i] |= (UA_Byte)(hex2int(chars[24 + i*2]) << 4u);\n        dst.data4[2+i] |= (UA_Byte)(hex2int(chars[25 + i*2]) << 0u);\n    }\n    return dst;\n}\n\nDECODE_JSON(Guid) {\n    CHECK_STRING;\n    CHECK_TOKEN_BOUNDS;\n    size_t tokenSize;\n    char* tokenData;\n    GET_TOKEN(tokenData, tokenSize);\n\n    if(tokenSize != 36)\n        return UA_STATUSCODE_BADDECODINGERROR;\n\n    /* check if incorrect chars are present */\n    for(size_t i = 0; i < tokenSize; i++) {\n        if(!(tokenData[i] == '-'\n                || (tokenData[i] >= '0' && tokenData[i] <= '9')\n                || (tokenData[i] >= 'A' && tokenData[i] <= 'F')\n                || (tokenData[i] >= 'a' && tokenData[i] <= 'f'))) {\n            return UA_STATUSCODE_BADDECODINGERROR;\n        }\n    }\n\n    *dst = UA_Guid_fromChars(tokenData);\n\n    if(moveToken)\n        parseCtx->index++;\n    return UA_STATUSCODE_GOOD;\n}\n\nDECODE_JSON(String) {\n    ALLOW_NULL;\n    CHECK_STRING;\n    CHECK_TOKEN_BOUNDS;\n    size_t tokenSize;\n    char* tokenData;\n    GET_TOKEN(tokenData, tokenSize);\n\n    /* Empty string? */\n    if(tokenSize == 0) {\n        dst->data = (UA_Byte*)UA_EMPTY_ARRAY_SENTINEL;\n        dst->length = 0;\n        if(moveToken)\n            parseCtx->index++;\n        return UA_STATUSCODE_GOOD;\n    }\n    \n    /* The actual value is at most of the same length as the source string:\n     * - Shortcut escapes (e.g. \"\\t\") (length 2) are converted to 1 byte\n     * - A single \\uXXXX escape (length 6) is converted to at most 3 bytes\n     * - Two \\uXXXX escapes (length 12) forming an UTF-16 surrogate pair are\n     *   converted to 4 bytes */\n    char *outputBuffer = (char*)UA_malloc(tokenSize);\n    if(!outputBuffer)\n        return UA_STATUSCODE_BADOUTOFMEMORY;\n    \n    const char *p = (char*)tokenData;\n    const char *end = (char*)&tokenData[tokenSize];\n    char *pos = outputBuffer;\n    while(p < end) {\n        /* No escaping */\n        if(*p != '\\\\') {\n            *(pos++) = *(p++);\n            continue;\n        }\n\n        /* Escape character */\n        p++;\n        if(p == end)\n            goto cleanup;\n        \n        if(*p != 'u') {\n            switch(*p) {\n            case '\"': case '\\\\': case '/': *pos = *p; break;\n            case 'b': *pos = '\\b'; break;\n            case 'f': *pos = '\\f'; break;\n            case 'n': *pos = '\\n'; break;\n            case 'r': *pos = '\\r'; break;\n            case 't': *pos = '\\t'; break;\n            default: goto cleanup;\n            }\n            pos++;\n            p++;\n            continue;\n        }\n            \n        /* Unicode */\n        if(p + 4 >= end)\n            goto cleanup;\n        int32_t value_signed = decode_unicode_escape(p);\n        if(value_signed < 0)\n            goto cleanup;\n        uint32_t value = (uint32_t)value_signed;\n        p += 5;\n\n        if(0xD800 <= value && value <= 0xDBFF) {\n            /* Surrogate pair */\n            if(p + 5 >= end)\n                goto cleanup;\n            if(*p != '\\\\' || *(p + 1) != 'u')\n                goto cleanup;\n            int32_t value2 = decode_unicode_escape(p + 1);\n            if(value2 < 0xDC00 || value2 > 0xDFFF)\n                goto cleanup;\n            value = ((value - 0xD800u) << 10u) + (uint32_t)((value2 - 0xDC00) + 0x10000);\n            p += 6;\n        } else if(0xDC00 <= value && value <= 0xDFFF) {\n            /* Invalid Unicode '\\\\u%04X' */\n            goto cleanup;\n        }\n\n        size_t length;\n        if(utf8_encode((int32_t)value, pos, &length))\n            goto cleanup;\n\n        pos += length;\n    }\n\n    dst->length = (size_t)(pos - outputBuffer);\n    if(dst->length > 0) {\n        dst->data = (UA_Byte*)outputBuffer;\n    } else {\n        dst->data = (UA_Byte*)UA_EMPTY_ARRAY_SENTINEL;\n        UA_free(outputBuffer);\n    }\n\n    if(moveToken)\n        parseCtx->index++;\n    return UA_STATUSCODE_GOOD;\n    \ncleanup:\n    UA_free(outputBuffer);  \n    return UA_STATUSCODE_BADDECODINGERROR;\n}\n\nDECODE_JSON(ByteString) {\n    ALLOW_NULL;\n    CHECK_STRING;\n    CHECK_TOKEN_BOUNDS;\n    size_t tokenSize;\n    char* tokenData;\n    GET_TOKEN(tokenData, tokenSize);\n\n    /* Empty bytestring? */\n    if(tokenSize == 0) {\n        dst->data = (UA_Byte*)UA_EMPTY_ARRAY_SENTINEL;\n        dst->length = 0;\n        return UA_STATUSCODE_GOOD;\n    }\n\n    size_t flen = 0;\n    unsigned char* unB64 = UA_unbase64((unsigned char*)tokenData, tokenSize, &flen);\n    if(unB64 == 0)\n        return UA_STATUSCODE_BADDECODINGERROR;\n\n    dst->data = (u8*)unB64;\n    dst->length = flen;\n    \n    if(moveToken)\n        parseCtx->index++;\n    return UA_STATUSCODE_GOOD;\n}\n\nDECODE_JSON(LocalizedText) {\n    ALLOW_NULL;\n    CHECK_OBJECT;\n\n    DecodeEntry entries[2] = {\n        {UA_JSONKEY_LOCALE, &dst->locale, (decodeJsonSignature) String_decodeJson, false, NULL},\n        {UA_JSONKEY_TEXT, &dst->text, (decodeJsonSignature) String_decodeJson, false, NULL}\n    };\n\n    return decodeFields(ctx, parseCtx, entries, 2, type);\n}\n\nDECODE_JSON(QualifiedName) {\n    ALLOW_NULL;\n    CHECK_OBJECT;\n\n    DecodeEntry entries[2] = {\n        {UA_JSONKEY_NAME, &dst->name, (decodeJsonSignature) String_decodeJson, false, NULL},\n        {UA_JSONKEY_URI, &dst->namespaceIndex, (decodeJsonSignature) UInt16_decodeJson, false, NULL}\n    };\n\n    return decodeFields(ctx, parseCtx, entries, 2, type);\n}\n\n/* Function for searching ahead of the current token. Used for retrieving the\n * OPC UA type of a token */\nstatic status\nsearchObjectForKeyRec(const char *searchKey, CtxJson *ctx, \n                      ParseCtx *parseCtx, size_t *resultIndex, UA_UInt16 depth) {\n    UA_StatusCode ret = UA_STATUSCODE_BADNOTFOUND;\n    \n    CHECK_TOKEN_BOUNDS;\n    \n    if(parseCtx->tokenArray[parseCtx->index].type == JSMN_OBJECT) {\n        size_t objectCount = (size_t)parseCtx->tokenArray[parseCtx->index].size;\n        parseCtx->index++; /*Object to first Key*/\n        \n        for(size_t i = 0; i < objectCount; i++) {\n            CHECK_TOKEN_BOUNDS;\n            if(depth == 0) { /* we search only on first layer */\n                if(jsoneq((char*)ctx->pos, &parseCtx->tokenArray[parseCtx->index], searchKey) == 0) {\n                    /*found*/\n                    parseCtx->index++; /*We give back a pointer to the value of the searched key!*/\n                    if (parseCtx->index >= parseCtx->tokenCount)\n                        /* We got invalid json. See https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=14620 */\n                        return UA_STATUSCODE_BADOUTOFRANGE;\n                    *resultIndex = parseCtx->index;\n                    return UA_STATUSCODE_GOOD;\n                }\n            }\n               \n            parseCtx->index++; /* value */\n            CHECK_TOKEN_BOUNDS;\n            \n            if(parseCtx->tokenArray[parseCtx->index].type == JSMN_OBJECT) {\n               ret = searchObjectForKeyRec(searchKey, ctx, parseCtx, resultIndex,\n                                           (UA_UInt16)(depth + 1));\n            } else if(parseCtx->tokenArray[parseCtx->index].type == JSMN_ARRAY) {\n               ret = searchObjectForKeyRec(searchKey, ctx, parseCtx, resultIndex,\n                                           (UA_UInt16)(depth + 1));\n            } else {\n                /* Only Primitive or string */\n                parseCtx->index++;\n            }\n        }\n    } else if(parseCtx->tokenArray[parseCtx->index].type == JSMN_ARRAY) {\n        size_t arraySize = (size_t)parseCtx->tokenArray[parseCtx->index].size;\n        parseCtx->index++; /*Object to first element*/\n        \n        for(size_t i = 0; i < arraySize; i++) {\n            CHECK_TOKEN_BOUNDS;\n            if(parseCtx->tokenArray[parseCtx->index].type == JSMN_OBJECT) {\n               ret = searchObjectForKeyRec(searchKey, ctx, parseCtx, resultIndex,\n                                           (UA_UInt16)(depth + 1));\n            } else if(parseCtx->tokenArray[parseCtx->index].type == JSMN_ARRAY) {\n               ret = searchObjectForKeyRec(searchKey, ctx, parseCtx, resultIndex,\n                                           (UA_UInt16)(depth + 1));\n            } else {\n                /* Only Primitive or string */\n                parseCtx->index++;\n            }\n        }\n    }\n    return ret;\n}\n\nUA_FUNC_ATTR_WARN_UNUSED_RESULT status\nlookAheadForKey(const char* search, CtxJson *ctx,\n                ParseCtx *parseCtx, size_t *resultIndex) {\n    UA_UInt16 oldIndex = parseCtx->index; /* Save index for later restore */\n    \n    UA_UInt16 depth = 0;\n    UA_StatusCode ret  = searchObjectForKeyRec(search, ctx, parseCtx, resultIndex, depth);\n\n    parseCtx->index = oldIndex; /* Restore index */\n    return ret;\n}\n\n/* Function used to jump over an object which cannot be parsed */\nstatic status\njumpOverRec(CtxJson *ctx, ParseCtx *parseCtx,\n            size_t *resultIndex, UA_UInt16 depth) {\n    UA_StatusCode ret = UA_STATUSCODE_BADDECODINGERROR;\n    CHECK_TOKEN_BOUNDS;\n    \n    if(parseCtx->tokenArray[parseCtx->index].type == JSMN_OBJECT) {\n        size_t objectCount = (size_t)(parseCtx->tokenArray[parseCtx->index].size);\n        \n        parseCtx->index++; /*Object to first Key*/\n        CHECK_TOKEN_BOUNDS;\n        \n        size_t i;\n        for(i = 0; i < objectCount; i++) {\n            CHECK_TOKEN_BOUNDS;\n             \n            parseCtx->index++; /*value*/\n            CHECK_TOKEN_BOUNDS;\n            \n            if(parseCtx->tokenArray[parseCtx->index].type == JSMN_OBJECT) {\n               jumpOverRec(ctx, parseCtx, resultIndex, (UA_UInt16)(depth + 1));\n            } else if(parseCtx->tokenArray[parseCtx->index].type == JSMN_ARRAY) {\n               jumpOverRec(ctx, parseCtx, resultIndex, (UA_UInt16)(depth + 1));\n            } else {\n                /*Only Primitive or string*/\n                parseCtx->index++;\n            }\n        }\n    } else if(parseCtx->tokenArray[parseCtx->index].type == JSMN_ARRAY) {\n        size_t arraySize = (size_t)(parseCtx->tokenArray[parseCtx->index].size);\n        \n        parseCtx->index++; /*Object to first element*/\n        CHECK_TOKEN_BOUNDS;\n        \n        size_t i;\n        for(i = 0; i < arraySize; i++) {\n            if(parseCtx->tokenArray[parseCtx->index].type == JSMN_OBJECT) {\n               jumpOverRec(ctx, parseCtx, resultIndex, (UA_UInt16)(depth + 1));\n            } else if(parseCtx->tokenArray[parseCtx->index].type == JSMN_ARRAY) {\n               jumpOverRec(ctx, parseCtx, resultIndex, (UA_UInt16)(depth + 1));\n            } else {\n                /*Only Primitive or string*/\n                parseCtx->index++;\n            }\n        }\n    }\n    return ret;\n}\n\nstatic status\njumpOverObject(CtxJson *ctx, ParseCtx *parseCtx, size_t *resultIndex) {\n    UA_UInt16 oldIndex = parseCtx->index; /* Save index for later restore */\n    UA_UInt16 depth = 0;\n    jumpOverRec(ctx, parseCtx, resultIndex, depth);\n    *resultIndex = parseCtx->index;\n    parseCtx->index = oldIndex; /* Restore index */\n    return UA_STATUSCODE_GOOD;\n}\n\nstatic status\nprepareDecodeNodeIdJson(UA_NodeId *dst, CtxJson *ctx, ParseCtx *parseCtx, \n                        u8 *fieldCount, DecodeEntry *entries) {\n    /* possible keys: Id, IdType*/\n    /* Id must always be present */\n    entries[*fieldCount].fieldName = UA_JSONKEY_ID;\n    entries[*fieldCount].found = false;\n    entries[*fieldCount].type = NULL;\n    \n    /* IdType */\n    UA_Boolean hasIdType = false;\n    size_t searchResult = 0; \n    status ret = lookAheadForKey(UA_JSONKEY_IDTYPE, ctx, parseCtx, &searchResult);\n    if(ret == UA_STATUSCODE_GOOD) { /*found*/\n         hasIdType = true;\n    }\n    \n    if(hasIdType) {\n        size_t size = (size_t)(parseCtx->tokenArray[searchResult].end -\n                               parseCtx->tokenArray[searchResult].start);\n        if(size < 1) {\n            return UA_STATUSCODE_BADDECODINGERROR;\n        }\n\n        char *idType = (char*)(ctx->pos + parseCtx->tokenArray[searchResult].start);\n      \n        if(idType[0] == '2') {\n            dst->identifierType = UA_NODEIDTYPE_GUID;\n            entries[*fieldCount].fieldPointer = &dst->identifier.guid;\n            entries[*fieldCount].function = (decodeJsonSignature) Guid_decodeJson;\n        } else if(idType[0] == '1') {\n            dst->identifierType = UA_NODEIDTYPE_STRING;\n            entries[*fieldCount].fieldPointer = &dst->identifier.string;\n            entries[*fieldCount].function = (decodeJsonSignature) String_decodeJson;\n        } else if(idType[0] == '3') {\n            dst->identifierType = UA_NODEIDTYPE_BYTESTRING;\n            entries[*fieldCount].fieldPointer = &dst->identifier.byteString;\n            entries[*fieldCount].function = (decodeJsonSignature) ByteString_decodeJson;\n        } else {\n            return UA_STATUSCODE_BADDECODINGERROR;\n        }\n        \n        /* Id always present */\n        (*fieldCount)++;\n        \n        entries[*fieldCount].fieldName = UA_JSONKEY_IDTYPE;\n        entries[*fieldCount].fieldPointer = NULL;\n        entries[*fieldCount].function = NULL;\n        entries[*fieldCount].found = false;\n        entries[*fieldCount].type = NULL;\n        \n        /* IdType */\n        (*fieldCount)++;\n    } else {\n        dst->identifierType = UA_NODEIDTYPE_NUMERIC;\n        entries[*fieldCount].fieldPointer = &dst->identifier.numeric;\n        entries[*fieldCount].function = (decodeJsonSignature) UInt32_decodeJson;\n        entries[*fieldCount].type = NULL;\n        (*fieldCount)++;\n    }\n    \n    return UA_STATUSCODE_GOOD;\n}\n\nDECODE_JSON(NodeId) {\n    ALLOW_NULL;\n    CHECK_OBJECT;\n\n    /* NameSpace */\n    UA_Boolean hasNamespace = false;\n    size_t searchResultNamespace = 0;\n    status ret = lookAheadForKey(UA_JSONKEY_NAMESPACE, ctx, parseCtx, &searchResultNamespace);\n    if(ret != UA_STATUSCODE_GOOD) {\n        dst->namespaceIndex = 0;\n    } else {\n        hasNamespace = true;\n    }\n    \n    /* Keep track over number of keys present, incremented if key found */\n    u8 fieldCount = 0;\n    DecodeEntry entries[3];\n    ret = prepareDecodeNodeIdJson(dst, ctx, parseCtx, &fieldCount, entries);\n    if(ret != UA_STATUSCODE_GOOD)\n        return ret;\n\n    if(hasNamespace) {\n        entries[fieldCount].fieldName = UA_JSONKEY_NAMESPACE;\n        entries[fieldCount].fieldPointer = &dst->namespaceIndex;\n        entries[fieldCount].function = (decodeJsonSignature) UInt16_decodeJson;\n        entries[fieldCount].found = false;\n        entries[fieldCount].type = NULL;\n        fieldCount++;\n    } else {\n        dst->namespaceIndex = 0;\n    }\n    ret = decodeFields(ctx, parseCtx, entries, fieldCount, type);\n    return ret;\n}\n\nDECODE_JSON(ExpandedNodeId) {\n    ALLOW_NULL;\n    CHECK_OBJECT;\n\n    /* Keep track over number of keys present, incremented if key found */\n    u8 fieldCount = 0;\n    \n    /* ServerUri */\n    UA_Boolean hasServerUri = false;\n    size_t searchResultServerUri = 0;\n    status ret = lookAheadForKey(UA_JSONKEY_SERVERURI, ctx, parseCtx, &searchResultServerUri);\n    if(ret != UA_STATUSCODE_GOOD) {\n        dst->serverIndex = 0; \n    } else {\n        hasServerUri = true;\n    }\n    \n    /* NameSpace */\n    UA_Boolean hasNamespace = false;\n    UA_Boolean isNamespaceString = false;\n    size_t searchResultNamespace = 0;\n    ret = lookAheadForKey(UA_JSONKEY_NAMESPACE, ctx, parseCtx, &searchResultNamespace);\n    if(ret != UA_STATUSCODE_GOOD) {\n        dst->namespaceUri = UA_STRING_NULL;\n    } else {\n        hasNamespace = true;\n        jsmntok_t nsToken = parseCtx->tokenArray[searchResultNamespace];\n        if(nsToken.type == JSMN_STRING)\n            isNamespaceString = true;\n    }\n\n    DecodeEntry entries[4];\n    ret = prepareDecodeNodeIdJson(&dst->nodeId, ctx, parseCtx, &fieldCount, entries);\n    if(ret != UA_STATUSCODE_GOOD)\n        return ret;\n\n    if(hasNamespace) {\n        entries[fieldCount].fieldName = UA_JSONKEY_NAMESPACE;\n        if(isNamespaceString) {\n            entries[fieldCount].fieldPointer = &dst->namespaceUri;\n            entries[fieldCount].function = (decodeJsonSignature) String_decodeJson;\n        } else {\n            entries[fieldCount].fieldPointer = &dst->nodeId.namespaceIndex;\n            entries[fieldCount].function = (decodeJsonSignature) UInt16_decodeJson;\n        }\n        entries[fieldCount].found = false;\n        entries[fieldCount].type = NULL;\n        fieldCount++; \n    }\n    \n    if(hasServerUri) {\n        entries[fieldCount].fieldName = UA_JSONKEY_SERVERURI;\n        entries[fieldCount].fieldPointer = &dst->serverIndex;\n        entries[fieldCount].function = (decodeJsonSignature) UInt32_decodeJson;\n        entries[fieldCount].found = false;\n        entries[fieldCount].type = NULL;\n        fieldCount++;  \n    } else {\n        dst->serverIndex = 0;\n    }\n    \n    return decodeFields(ctx, parseCtx, entries, fieldCount, type);\n}\n\nDECODE_JSON(DateTime) {\n    CHECK_STRING;\n    CHECK_TOKEN_BOUNDS;\n    size_t tokenSize;\n    char* tokenData;\n    GET_TOKEN(tokenData, tokenSize);\n    \n    /* TODO: proper ISO 8601:2004 parsing, musl strptime!*/\n    /* DateTime  ISO 8601:2004 without milli is 20 Characters, with millis 24 */\n    if(tokenSize != 20 && tokenSize != 24) {\n        return UA_STATUSCODE_BADDECODINGERROR;\n    }\n    \n    /* sanity check */\n    if(tokenData[4] != '-' || tokenData[7] != '-' || tokenData[10] != 'T' ||\n       tokenData[13] != ':' || tokenData[16] != ':' ||\n       !(tokenData[19] == 'Z' || tokenData[19] == '.')) {\n        return UA_STATUSCODE_BADDECODINGERROR;\n    }\n    \n    struct mytm dts;\n    memset(&dts, 0, sizeof(dts));\n    \n    UA_UInt64 year = 0;\n    atoiUnsigned(&tokenData[0], 4, &year);\n    dts.tm_year = (UA_UInt16)year - 1900;\n    UA_UInt64 month = 0;\n    atoiUnsigned(&tokenData[5], 2, &month);\n    dts.tm_mon = (UA_UInt16)month - 1;\n    UA_UInt64 day = 0;\n    atoiUnsigned(&tokenData[8], 2, &day);\n    dts.tm_mday = (UA_UInt16)day;\n    UA_UInt64 hour = 0;\n    atoiUnsigned(&tokenData[11], 2, &hour);\n    dts.tm_hour = (UA_UInt16)hour;\n    UA_UInt64 min = 0;\n    atoiUnsigned(&tokenData[14], 2, &min);\n    dts.tm_min = (UA_UInt16)min;\n    UA_UInt64 sec = 0;\n    atoiUnsigned(&tokenData[17], 2, &sec);\n    dts.tm_sec = (UA_UInt16)sec;\n    \n    UA_UInt64 msec = 0;\n    if(tokenSize == 24) {\n        atoiUnsigned(&tokenData[20], 3, &msec);\n    }\n    \n    long long sinceunix = __tm_to_secs(&dts);\n    UA_DateTime dt = (UA_DateTime)((UA_UInt64)(sinceunix*UA_DATETIME_SEC +\n                                               UA_DATETIME_UNIX_EPOCH) +\n                                   (UA_UInt64)(UA_DATETIME_MSEC * msec)); \n    *dst = dt;\n  \n    if(moveToken)\n        parseCtx->index++;\n    return UA_STATUSCODE_GOOD;\n}\n\nDECODE_JSON(StatusCode) {\n    status ret = DECODE_DIRECT_JSON(dst, UInt32);\n    if(ret != UA_STATUSCODE_GOOD)\n        return ret;\n\n    if(moveToken)\n        parseCtx->index++;\n    return UA_STATUSCODE_GOOD;\n}\n\nstatic status\nVariantDimension_decodeJson(void * dst, const UA_DataType *type, \n                            CtxJson *ctx, ParseCtx *parseCtx, UA_Boolean moveToken) {\n    (void) type;\n    const UA_DataType *dimType = &UA_TYPES[UA_TYPES_UINT32];\n    return Array_decodeJson_internal((void**)dst, dimType, ctx, parseCtx, moveToken);\n}\n\nDECODE_JSON(Variant) {\n    ALLOW_NULL;\n    CHECK_OBJECT;\n\n    /* First search for the variant type in the json object. */\n    size_t searchResultType = 0;\n    status ret = lookAheadForKey(UA_JSONKEY_TYPE, ctx, parseCtx, &searchResultType);\n    if(ret != UA_STATUSCODE_GOOD) {\n        skipObject(parseCtx);\n        return UA_STATUSCODE_GOOD;\n    }\n\n    size_t size = ((size_t)parseCtx->tokenArray[searchResultType].end -\n                   (size_t)parseCtx->tokenArray[searchResultType].start);\n\n    /* check if size is zero or the type is not a number */\n    if(size < 1 || parseCtx->tokenArray[searchResultType].type != JSMN_PRIMITIVE)\n        return UA_STATUSCODE_BADDECODINGERROR;\n    \n    /* Parse the type */\n    UA_UInt64 idTypeDecoded = 0;\n    char *idTypeEncoded = (char*)(ctx->pos + parseCtx->tokenArray[searchResultType].start);\n    status typeDecodeStatus = atoiUnsigned(idTypeEncoded, size, &idTypeDecoded);\n    if(typeDecodeStatus != UA_STATUSCODE_GOOD)\n        return typeDecodeStatus;\n\n    /* A NULL Variant */\n    if(idTypeDecoded == 0) {\n        skipObject(parseCtx);\n        return UA_STATUSCODE_GOOD;\n    }\n\n    /* Set the type */\n    UA_NodeId typeNodeId = UA_NODEID_NUMERIC(0, (UA_UInt32)idTypeDecoded);\n    dst->type = UA_findDataType(&typeNodeId);\n    if(!dst->type)\n        return UA_STATUSCODE_BADDECODINGERROR;\n    \n    /* Search for body */\n    size_t searchResultBody = 0;\n    ret = lookAheadForKey(UA_JSONKEY_BODY, ctx, parseCtx, &searchResultBody);\n    if(ret != UA_STATUSCODE_GOOD) {\n        /*TODO: no body? set value NULL?*/\n        return UA_STATUSCODE_BADDECODINGERROR;\n    }\n\n    /* value is an array? */\n    UA_Boolean isArray = false;\n    if(parseCtx->tokenArray[searchResultBody].type == JSMN_ARRAY) {\n        isArray = true;\n        dst->arrayLength = (size_t)parseCtx->tokenArray[searchResultBody].size;\n    }\n\n    /* Has the variant dimension? */\n    UA_Boolean hasDimension = false;\n    size_t searchResultDim = 0;\n    ret = lookAheadForKey(UA_JSONKEY_DIMENSION, ctx, parseCtx, &searchResultDim);\n    if(ret == UA_STATUSCODE_GOOD) {\n        hasDimension = true;\n        dst->arrayDimensionsSize = (size_t)parseCtx->tokenArray[searchResultDim].size;\n    }\n    \n    /* no array but has dimension. error? */\n    if(!isArray && hasDimension)\n        return UA_STATUSCODE_BADDECODINGERROR;\n    \n    /* Get the datatype of the content. The type must be a builtin data type.\n     * All not-builtin types are wrapped in an ExtensionObject. */\n    if(dst->type->typeKind > UA_TYPES_DIAGNOSTICINFO)\n        return UA_STATUSCODE_BADDECODINGERROR;\n\n    /* A variant cannot contain a variant. But it can contain an array of\n     * variants */\n    if(dst->type->typeKind == UA_DATATYPEKIND_VARIANT && !isArray)\n        return UA_STATUSCODE_BADDECODINGERROR;\n    \n    /* Decode an array */\n    if(isArray) {\n        DecodeEntry entries[3] = {\n            {UA_JSONKEY_TYPE, NULL, NULL, false, NULL},\n            {UA_JSONKEY_BODY, &dst->data, (decodeJsonSignature) Array_decodeJson, false, NULL},\n            {UA_JSONKEY_DIMENSION, &dst->arrayDimensions,\n             (decodeJsonSignature) VariantDimension_decodeJson, false, NULL}};\n        if(!hasDimension) {\n            ret = decodeFields(ctx, parseCtx, entries, 2, dst->type); /*use first 2 fields*/\n        } else {\n            ret = decodeFields(ctx, parseCtx, entries, 3, dst->type); /*use all fields*/\n        }      \n        return ret;\n    }\n\n    /* Decode a value wrapped in an ExtensionObject */\n    if(dst->type->typeKind == UA_DATATYPEKIND_EXTENSIONOBJECT) {\n        DecodeEntry entries[2] =\n            {{UA_JSONKEY_TYPE, NULL, NULL, false, NULL},\n             {UA_JSONKEY_BODY, dst,\n              (decodeJsonSignature)Variant_decodeJsonUnwrapExtensionObject, false, NULL}};\n        return decodeFields(ctx, parseCtx, entries, 2, dst->type);\n    }\n\n    /* Allocate Memory for Body */\n    dst->data = UA_new(dst->type);\n    if(!dst->data)\n        return UA_STATUSCODE_BADOUTOFMEMORY;\n    DecodeEntry entries[2] =\n        {{UA_JSONKEY_TYPE, NULL, NULL, false, NULL},\n         {UA_JSONKEY_BODY, dst->data, (decodeJsonSignature) decodeJsonInternal, false, NULL}};\n    return decodeFields(ctx, parseCtx, entries, 2, dst->type);\n}\n\nDECODE_JSON(DataValue) {\n    ALLOW_NULL;\n    CHECK_OBJECT;\n\n    DecodeEntry entries[6] = {\n       {UA_JSONKEY_VALUE, &dst->value, (decodeJsonSignature) Variant_decodeJson, false, NULL},\n       {UA_JSONKEY_STATUS, &dst->status, (decodeJsonSignature) StatusCode_decodeJson, false, NULL},\n       {UA_JSONKEY_SOURCETIMESTAMP, &dst->sourceTimestamp, (decodeJsonSignature) DateTime_decodeJson, false, NULL},\n       {UA_JSONKEY_SOURCEPICOSECONDS, &dst->sourcePicoseconds, (decodeJsonSignature) UInt16_decodeJson, false, NULL},\n       {UA_JSONKEY_SERVERTIMESTAMP, &dst->serverTimestamp, (decodeJsonSignature) DateTime_decodeJson, false, NULL},\n       {UA_JSONKEY_SERVERPICOSECONDS, &dst->serverPicoseconds, (decodeJsonSignature) UInt16_decodeJson, false, NULL}};\n\n    status ret = decodeFields(ctx, parseCtx, entries, 6, type);\n    dst->hasValue = entries[0].found; dst->hasStatus = entries[1].found;\n    dst->hasSourceTimestamp = entries[2].found; dst->hasSourcePicoseconds = entries[3].found;\n    dst->hasServerTimestamp = entries[4].found; dst->hasServerPicoseconds = entries[5].found;\n    return ret;\n}\n\nDECODE_JSON(ExtensionObject) {\n    ALLOW_NULL;\n    CHECK_OBJECT;\n\n    /* Search for Encoding */\n    size_t searchEncodingResult = 0;\n    status ret = lookAheadForKey(UA_JSONKEY_ENCODING, ctx, parseCtx, &searchEncodingResult);\n    \n    /* If no encoding found it is structure encoding */\n    if(ret != UA_STATUSCODE_GOOD) {\n        UA_NodeId typeId;\n        UA_NodeId_init(&typeId);\n\n        size_t searchTypeIdResult = 0;\n        ret = lookAheadForKey(UA_JSONKEY_TYPEID, ctx, parseCtx, &searchTypeIdResult);\n        if(ret != UA_STATUSCODE_GOOD) {\n            /* TYPEID not found, abort */\n            return UA_STATUSCODE_BADENCODINGERROR;\n        }\n\n        /* parse the nodeid */\n        /*for restore*/\n        UA_UInt16 index = parseCtx->index;\n        parseCtx->index = (UA_UInt16)searchTypeIdResult;\n        ret = NodeId_decodeJson(&typeId, &UA_TYPES[UA_TYPES_NODEID], ctx, parseCtx, true);\n        if(ret != UA_STATUSCODE_GOOD)\n            return ret;\n        \n        /*restore*/\n        parseCtx->index = index;\n        const UA_DataType *typeOfBody = UA_findDataType(&typeId);\n        if(!typeOfBody) {\n            /*dont decode body: 1. save as bytestring, 2. jump over*/\n            dst->encoding = UA_EXTENSIONOBJECT_ENCODED_BYTESTRING;\n            UA_NodeId_copy(&typeId, &dst->content.encoded.typeId);\n            \n            /*Check if Object in Extentionobject*/\n            if(getJsmnType(parseCtx) != JSMN_OBJECT) {\n                UA_NodeId_deleteMembers(&typeId);\n                return UA_STATUSCODE_BADDECODINGERROR;\n            }\n            \n            /*Search for Body to save*/\n            size_t searchBodyResult = 0;\n            ret = lookAheadForKey(UA_JSONKEY_BODY, ctx, parseCtx, &searchBodyResult);\n            if(ret != UA_STATUSCODE_GOOD) {\n                /*No Body*/\n                UA_NodeId_deleteMembers(&typeId);\n                return UA_STATUSCODE_BADDECODINGERROR;\n            }\n            \n            if(searchBodyResult >= (size_t)parseCtx->tokenCount) {\n                /*index not in Tokenarray*/\n                UA_NodeId_deleteMembers(&typeId);\n                return UA_STATUSCODE_BADDECODINGERROR;\n            }\n\n            /* Get the size of the Object as a string, not the Object key count! */\n            UA_Int64 sizeOfJsonString =(parseCtx->tokenArray[searchBodyResult].end -\n                    parseCtx->tokenArray[searchBodyResult].start);\n            \n            char* bodyJsonString = (char*)(ctx->pos + parseCtx->tokenArray[searchBodyResult].start);\n            \n            if(sizeOfJsonString <= 0) {\n                UA_NodeId_deleteMembers(&typeId);\n                return UA_STATUSCODE_BADDECODINGERROR;\n            }\n            \n            /* Save encoded as bytestring. */\n            ret = UA_ByteString_allocBuffer(&dst->content.encoded.body, (size_t)sizeOfJsonString);\n            if(ret != UA_STATUSCODE_GOOD) {\n                UA_NodeId_deleteMembers(&typeId);\n                return ret;\n            }\n\n            memcpy(dst->content.encoded.body.data, bodyJsonString, (size_t)sizeOfJsonString);\n            \n            size_t tokenAfteExtensionObject = 0;\n            jumpOverObject(ctx, parseCtx, &tokenAfteExtensionObject);\n            \n            if(tokenAfteExtensionObject == 0) {\n                /*next object token not found*/\n                UA_NodeId_deleteMembers(&typeId);\n                UA_ByteString_deleteMembers(&dst->content.encoded.body);\n                return UA_STATUSCODE_BADDECODINGERROR;\n            }\n            \n            parseCtx->index = (UA_UInt16)tokenAfteExtensionObject;\n            \n            return UA_STATUSCODE_GOOD;\n        }\n        \n        /*Type id not used anymore, typeOfBody has type*/\n        UA_NodeId_deleteMembers(&typeId);\n        \n        /*Set Found Type*/\n        dst->content.decoded.type = typeOfBody;\n        dst->encoding = UA_EXTENSIONOBJECT_DECODED;\n        \n        if(searchTypeIdResult != 0) {\n            dst->content.decoded.data = UA_new(typeOfBody);\n            if(!dst->content.decoded.data)\n                return UA_STATUSCODE_BADOUTOFMEMORY;\n\n            UA_NodeId typeId_dummy;\n            DecodeEntry entries[2] = {\n                {UA_JSONKEY_TYPEID, &typeId_dummy, (decodeJsonSignature) NodeId_decodeJson, false, NULL},\n                {UA_JSONKEY_BODY, dst->content.decoded.data,\n                 (decodeJsonSignature) decodeJsonJumpTable[typeOfBody->typeKind], false, NULL}\n            };\n\n            return decodeFields(ctx, parseCtx, entries, 2, typeOfBody);\n        } else {\n           return UA_STATUSCODE_BADDECODINGERROR;\n        }\n    } else { /* UA_JSONKEY_ENCODING found */\n        /*Parse the encoding*/\n        UA_UInt64 encoding = 0;\n        char *extObjEncoding = (char*)(ctx->pos + parseCtx->tokenArray[searchEncodingResult].start);\n        size_t size = (size_t)(parseCtx->tokenArray[searchEncodingResult].end - parseCtx->tokenArray[searchEncodingResult].start);\n        atoiUnsigned(extObjEncoding, size, &encoding);\n\n        if(encoding == 1) {\n            /* BYTESTRING in Json Body */\n            dst->encoding = UA_EXTENSIONOBJECT_ENCODED_BYTESTRING;\n            UA_UInt16 encodingTypeJson;\n            DecodeEntry entries[3] = {\n                {UA_JSONKEY_ENCODING, &encodingTypeJson, (decodeJsonSignature) UInt16_decodeJson, false, NULL},\n                {UA_JSONKEY_BODY, &dst->content.encoded.body, (decodeJsonSignature) String_decodeJson, false, NULL},\n                {UA_JSONKEY_TYPEID, &dst->content.encoded.typeId, (decodeJsonSignature) NodeId_decodeJson, false, NULL}\n            };\n\n            return decodeFields(ctx, parseCtx, entries, 3, type);\n        } else if(encoding == 2) {\n            /* XmlElement in Json Body */\n            dst->encoding = UA_EXTENSIONOBJECT_ENCODED_XML;\n            UA_UInt16 encodingTypeJson;\n            DecodeEntry entries[3] = {\n                {UA_JSONKEY_ENCODING, &encodingTypeJson, (decodeJsonSignature) UInt16_decodeJson, false, NULL},\n                {UA_JSONKEY_BODY, &dst->content.encoded.body, (decodeJsonSignature) String_decodeJson, false, NULL},\n                {UA_JSONKEY_TYPEID, &dst->content.encoded.typeId, (decodeJsonSignature) NodeId_decodeJson, false, NULL}\n            };\n            return decodeFields(ctx, parseCtx, entries, 3, type);\n        } else {\n            return UA_STATUSCODE_BADDECODINGERROR;\n        }\n    }\n    return UA_STATUSCODE_BADNOTIMPLEMENTED;\n}\n\nstatic status\nVariant_decodeJsonUnwrapExtensionObject(UA_Variant *dst, const UA_DataType *type, \n                                        CtxJson *ctx, ParseCtx *parseCtx, UA_Boolean moveToken) {\n    (void) type, (void) moveToken;\n    /*EXTENSIONOBJECT POSITION!*/\n    UA_UInt16 old_index = parseCtx->index;\n    UA_Boolean typeIdFound;\n    \n    /* Decode the DataType */\n    UA_NodeId typeId;\n    UA_NodeId_init(&typeId);\n\n    size_t searchTypeIdResult = 0;\n    status ret = lookAheadForKey(UA_JSONKEY_TYPEID, ctx, parseCtx, &searchTypeIdResult);\n\n    if(ret != UA_STATUSCODE_GOOD) {\n        /*No Typeid found*/\n        typeIdFound = false;\n        /*return UA_STATUSCODE_BADDECODINGERROR;*/\n    } else {\n        typeIdFound = true;\n        /* parse the nodeid */\n        parseCtx->index = (UA_UInt16)searchTypeIdResult;\n        ret = NodeId_decodeJson(&typeId, &UA_TYPES[UA_TYPES_NODEID], ctx, parseCtx, true);\n        if(ret != UA_STATUSCODE_GOOD) {\n            UA_NodeId_deleteMembers(&typeId);\n            return ret;\n        }\n\n        /*restore index, ExtensionObject position*/\n        parseCtx->index = old_index;\n    }\n\n    /* ---Decode the EncodingByte--- */\n    if(!typeIdFound)\n        return UA_STATUSCODE_BADDECODINGERROR;\n\n    UA_Boolean encodingFound = false;\n    /*Search for Encoding*/\n    size_t searchEncodingResult = 0;\n    ret = lookAheadForKey(UA_JSONKEY_ENCODING, ctx, parseCtx, &searchEncodingResult);\n\n    UA_UInt64 encoding = 0;\n    /*If no encoding found it is Structure encoding*/\n    if(ret == UA_STATUSCODE_GOOD) { /*FOUND*/\n        encodingFound = true;\n        char *extObjEncoding = (char*)(ctx->pos + parseCtx->tokenArray[searchEncodingResult].start);\n        size_t size = (size_t)(parseCtx->tokenArray[searchEncodingResult].end \n                               - parseCtx->tokenArray[searchEncodingResult].start);\n        atoiUnsigned(extObjEncoding, size, &encoding);\n    }\n        \n    const UA_DataType *typeOfBody = UA_findDataType(&typeId);\n        \n    if(encoding == 0 || typeOfBody != NULL) {\n        /*This value is 0 if the body is Structure encoded as a JSON object (see 5.4.6).*/\n        /* Found a valid type and it is structure encoded so it can be unwrapped */\n        if (typeOfBody == NULL)\n            return UA_STATUSCODE_BADDECODINGERROR;\n\n        dst->type = typeOfBody;\n\n        /* Allocate memory for type*/\n        dst->data = UA_new(dst->type);\n        if(!dst->data) {\n            UA_NodeId_deleteMembers(&typeId);\n            return UA_STATUSCODE_BADOUTOFMEMORY;\n        }\n\n        /* Decode the content */\n        UA_NodeId nodeIddummy;\n        DecodeEntry entries[3] =\n            {\n             {UA_JSONKEY_TYPEID, &nodeIddummy, (decodeJsonSignature) NodeId_decodeJson, false, NULL},\n             {UA_JSONKEY_BODY, dst->data,\n              (decodeJsonSignature) decodeJsonJumpTable[dst->type->typeKind], false, NULL},\n             {UA_JSONKEY_ENCODING, NULL, NULL, false, NULL}};\n\n        ret = decodeFields(ctx, parseCtx, entries, encodingFound ? 3:2, typeOfBody);\n        if(ret != UA_STATUSCODE_GOOD) {\n            UA_free(dst->data);\n            dst->data = NULL;\n        }\n    } else if(encoding == 1 || encoding == 2 || typeOfBody == NULL) {\n        UA_NodeId_deleteMembers(&typeId);\n            \n        /* decode as ExtensionObject */\n        dst->type = &UA_TYPES[UA_TYPES_EXTENSIONOBJECT];\n\n        /* Allocate memory for extensionobject*/\n        dst->data = UA_new(dst->type);\n        if(!dst->data)\n            return UA_STATUSCODE_BADOUTOFMEMORY;\n\n        /* decode: Does not move tokenindex. */\n        ret = DECODE_DIRECT_JSON(dst->data, ExtensionObject);\n        if(ret != UA_STATUSCODE_GOOD) {\n            UA_free(dst->data);\n            dst->data = NULL;\n        }\n    } else {\n        /*no recognized encoding type*/\n        return UA_STATUSCODE_BADDECODINGERROR;\n    }\n    return ret;\n}\nstatus DiagnosticInfoInner_decodeJson(void* dst, const UA_DataType* type, \n        CtxJson* ctx, ParseCtx* parseCtx, UA_Boolean moveToken);\n\nDECODE_JSON(DiagnosticInfo) {\n    ALLOW_NULL;\n    CHECK_OBJECT;\n\n    DecodeEntry entries[7] = {\n       {UA_JSONKEY_SYMBOLICID, &dst->symbolicId, (decodeJsonSignature) Int32_decodeJson, false, NULL},\n       {UA_JSONKEY_NAMESPACEURI, &dst->namespaceUri, (decodeJsonSignature) Int32_decodeJson, false, NULL},\n       {UA_JSONKEY_LOCALIZEDTEXT, &dst->localizedText, (decodeJsonSignature) Int32_decodeJson, false, NULL},\n       {UA_JSONKEY_LOCALE, &dst->locale, (decodeJsonSignature) Int32_decodeJson, false, NULL},\n       {UA_JSONKEY_ADDITIONALINFO, &dst->additionalInfo, (decodeJsonSignature) String_decodeJson, false, NULL},\n       {UA_JSONKEY_INNERSTATUSCODE, &dst->innerStatusCode, (decodeJsonSignature) StatusCode_decodeJson, false, NULL},\n       {UA_JSONKEY_INNERDIAGNOSTICINFO, &dst->innerDiagnosticInfo, (decodeJsonSignature) DiagnosticInfoInner_decodeJson, false, NULL}};\n    status ret = decodeFields(ctx, parseCtx, entries, 7, type);\n\n    dst->hasSymbolicId = entries[0].found; dst->hasNamespaceUri = entries[1].found;\n    dst->hasLocalizedText = entries[2].found; dst->hasLocale = entries[3].found;\n    dst->hasAdditionalInfo = entries[4].found; dst->hasInnerStatusCode = entries[5].found;\n    dst->hasInnerDiagnosticInfo = entries[6].found;\n    return ret;\n}\n\nstatus\nDiagnosticInfoInner_decodeJson(void* dst, const UA_DataType* type, \n                               CtxJson* ctx, ParseCtx* parseCtx, UA_Boolean moveToken) {\n    UA_DiagnosticInfo *inner = (UA_DiagnosticInfo*)UA_calloc(1, sizeof(UA_DiagnosticInfo));\n    if(inner == NULL) {\n        return UA_STATUSCODE_BADOUTOFMEMORY;\n    }\n    memcpy(dst, &inner, sizeof(UA_DiagnosticInfo*)); /* Copy new Pointer do dest */\n    return DiagnosticInfo_decodeJson(inner, type, ctx, parseCtx, moveToken);\n}\n\nstatus \ndecodeFields(CtxJson *ctx, ParseCtx *parseCtx, DecodeEntry *entries,\n             size_t entryCount, const UA_DataType *type) {\n    CHECK_TOKEN_BOUNDS;\n    size_t objectCount = (size_t)(parseCtx->tokenArray[parseCtx->index].size);\n    status ret = UA_STATUSCODE_GOOD;\n\n    if(entryCount == 1) {\n        if(*(entries[0].fieldName) == 0) { /*No MemberName*/\n            return entries[0].function(entries[0].fieldPointer, type,\n                                       ctx, parseCtx, true); /*ENCODE DIRECT*/\n        }\n    } else if(entryCount == 0) {\n        return UA_STATUSCODE_BADDECODINGERROR;\n    }\n\n    parseCtx->index++; /*go to first key*/\n    CHECK_TOKEN_BOUNDS;\n    \n    for (size_t currentObjectCount = 0; currentObjectCount < objectCount &&\n             parseCtx->index < parseCtx->tokenCount; currentObjectCount++) {\n\n        /* start searching at the index of currentObjectCount */\n        for (size_t i = currentObjectCount; i < entryCount + currentObjectCount; i++) {\n            /* Search for KEY, if found outer loop will be one less. Best case\n             * is objectCount if in order! */\n            size_t index = i % entryCount;\n            \n            CHECK_TOKEN_BOUNDS;\n            if(jsoneq((char*) ctx->pos, &parseCtx->tokenArray[parseCtx->index], \n                       entries[index].fieldName) != 0)\n                continue;\n\n            if(entries[index].found) {\n                /*Duplicate Key found, abort.*/\n                return UA_STATUSCODE_BADDECODINGERROR;\n            }\n\n            entries[index].found = true;\n\n            parseCtx->index++; /*goto value*/\n            CHECK_TOKEN_BOUNDS;\n            \n            /* Find the data type.\n             * TODO: get rid of parameter type. Only forward via DecodeEntry.\n             */\n            const UA_DataType *membertype = type;\n            if(entries[index].type)\n                membertype = entries[index].type;\n\n            if(entries[index].function != NULL) {\n                ret = entries[index].function(entries[index].fieldPointer,\n                                              membertype, ctx, parseCtx, true); /*Move Token True*/\n                if(ret != UA_STATUSCODE_GOOD)\n                    return ret;\n            } else {\n                /*overstep single value, this will not work if object or array\n                 Only used not to double parse pre looked up type, but it has to be overstepped*/\n                parseCtx->index++;\n            }\n            break;\n        }\n    }\n    return ret;\n}\n\nstatic status\nArray_decodeJson_internal(void **dst, const UA_DataType *type, \n        CtxJson *ctx, ParseCtx *parseCtx, UA_Boolean moveToken) {\n    (void) moveToken;\n    status ret;\n    \n    if(parseCtx->tokenArray[parseCtx->index].type != JSMN_ARRAY)\n        return UA_STATUSCODE_BADDECODINGERROR;\n    \n    size_t length = (size_t)parseCtx->tokenArray[parseCtx->index].size;\n\n    /* Save the length of the array */\n    size_t *p = (size_t*) dst - 1;\n    *p = length;\n\n    /* Return early for empty arrays */\n    if(length == 0) {\n        *dst = UA_EMPTY_ARRAY_SENTINEL;\n        return UA_STATUSCODE_GOOD;\n    }\n\n    /* Allocate memory */\n    *dst = UA_calloc(length, type->memSize);\n    if(*dst == NULL)\n        return UA_STATUSCODE_BADOUTOFMEMORY;\n    \n    parseCtx->index++; /* We go to first Array member!*/\n    \n    /* Decode array members */\n    uintptr_t ptr = (uintptr_t)*dst;\n    for(size_t i = 0; i < length; ++i) {\n        ret = decodeJsonJumpTable[type->typeKind]((void*)ptr, type, ctx, parseCtx, true);\n        if(ret != UA_STATUSCODE_GOOD) {\n            UA_Array_delete(*dst, i+1, type);\n            *dst = NULL;\n            return ret;\n        }\n        ptr += type->memSize;\n    }\n    return UA_STATUSCODE_GOOD;\n}\n\n/*Wrapper for array with valid decodingStructure.*/\nstatic status\nArray_decodeJson(void * dst, const UA_DataType *type, CtxJson *ctx, \n        ParseCtx *parseCtx, UA_Boolean moveToken) {\n    return Array_decodeJson_internal((void **)dst, type, ctx, parseCtx, moveToken);\n}\n\nstatic status\ndecodeJsonStructure(void *dst, const UA_DataType *type, CtxJson *ctx, \n                    ParseCtx *parseCtx, UA_Boolean moveToken) {\n    (void) moveToken;\n    /* Check the recursion limit */\n    if(ctx->depth > UA_JSON_ENCODING_MAX_RECURSION)\n        return UA_STATUSCODE_BADENCODINGERROR;\n    ctx->depth++;\n\n    uintptr_t ptr = (uintptr_t)dst;\n    status ret = UA_STATUSCODE_GOOD;\n    u8 membersSize = type->membersSize;\n    const UA_DataType *typelists[2] = { UA_TYPES, &type[-type->typeIndex] };\n    \n    UA_STACKARRAY(DecodeEntry, entries, membersSize);\n\n    for(size_t i = 0; i < membersSize && ret == UA_STATUSCODE_GOOD; ++i) {\n        const UA_DataTypeMember *m = &type->members[i];\n        const UA_DataType *mt = &typelists[!m->namespaceZero][m->memberTypeIndex];\n\n        entries[i].type = mt;\n        if(!m->isArray) {\n            ptr += m->padding;\n            entries[i].fieldName = m->memberName;\n            entries[i].fieldPointer = (void*)ptr;\n            entries[i].function = decodeJsonJumpTable[mt->typeKind];\n            entries[i].found = false;\n            ptr += mt->memSize;\n        } else {\n            ptr += m->padding;\n            ptr += sizeof(size_t);\n            entries[i].fieldName = m->memberName;\n            entries[i].fieldPointer = (void*)ptr;\n            entries[i].function = (decodeJsonSignature)Array_decodeJson;\n            entries[i].found = false;\n            ptr += sizeof(void*);\n        }\n    }\n    \n    ret = decodeFields(ctx, parseCtx, entries, membersSize, type);\n\n    ctx->depth--;\n    return ret;\n}\n\nstatic status\ndecodeJsonNotImplemented(void *dst, const UA_DataType *type, CtxJson *ctx, \n                         ParseCtx *parseCtx, UA_Boolean moveToken) {\n    (void)dst, (void)type, (void)ctx, (void)parseCtx, (void)moveToken;\n    return UA_STATUSCODE_BADNOTIMPLEMENTED;\n}\n\nconst decodeJsonSignature decodeJsonJumpTable[UA_DATATYPEKINDS] = {\n    (decodeJsonSignature)Boolean_decodeJson,\n    (decodeJsonSignature)SByte_decodeJson, /* SByte */\n    (decodeJsonSignature)Byte_decodeJson,\n    (decodeJsonSignature)Int16_decodeJson, /* Int16 */\n    (decodeJsonSignature)UInt16_decodeJson,\n    (decodeJsonSignature)Int32_decodeJson, /* Int32 */\n    (decodeJsonSignature)UInt32_decodeJson,\n    (decodeJsonSignature)Int64_decodeJson, /* Int64 */\n    (decodeJsonSignature)UInt64_decodeJson,\n    (decodeJsonSignature)Float_decodeJson,\n    (decodeJsonSignature)Double_decodeJson,\n    (decodeJsonSignature)String_decodeJson,\n    (decodeJsonSignature)DateTime_decodeJson, /* DateTime */\n    (decodeJsonSignature)Guid_decodeJson,\n    (decodeJsonSignature)ByteString_decodeJson, /* ByteString */\n    (decodeJsonSignature)String_decodeJson, /* XmlElement */\n    (decodeJsonSignature)NodeId_decodeJson,\n    (decodeJsonSignature)ExpandedNodeId_decodeJson,\n    (decodeJsonSignature)StatusCode_decodeJson, /* StatusCode */\n    (decodeJsonSignature)QualifiedName_decodeJson, /* QualifiedName */\n    (decodeJsonSignature)LocalizedText_decodeJson,\n    (decodeJsonSignature)ExtensionObject_decodeJson,\n    (decodeJsonSignature)DataValue_decodeJson,\n    (decodeJsonSignature)Variant_decodeJson,\n    (decodeJsonSignature)DiagnosticInfo_decodeJson,\n    (decodeJsonSignature)decodeJsonNotImplemented, /* Decimal */\n    (decodeJsonSignature)Int32_decodeJson, /* Enum */\n    (decodeJsonSignature)decodeJsonStructure,\n    (decodeJsonSignature)decodeJsonNotImplemented, /* Structure with optional fields */\n    (decodeJsonSignature)decodeJsonNotImplemented, /* Union */\n    (decodeJsonSignature)decodeJsonNotImplemented /* BitfieldCluster */\n};\n\ndecodeJsonSignature getDecodeSignature(u8 index) {\n    return decodeJsonJumpTable[index];\n}\n\nstatus\ntokenize(ParseCtx *parseCtx, CtxJson *ctx, const UA_ByteString *src) {\n    /* Set up the context */\n    ctx->pos = &src->data[0];\n    ctx->end = &src->data[src->length];\n    ctx->depth = 0;\n    parseCtx->tokenCount = 0;\n    parseCtx->index = 0;\n\n    /*Set up tokenizer jsmn*/\n    jsmn_parser p;\n    jsmn_init(&p);\n    parseCtx->tokenCount = (UA_Int32)\n        jsmn_parse(&p, (char*)src->data, src->length,\n                   parseCtx->tokenArray, UA_JSON_MAXTOKENCOUNT);\n    \n    if(parseCtx->tokenCount < 0) {\n        if(parseCtx->tokenCount == JSMN_ERROR_NOMEM)\n            return UA_STATUSCODE_BADOUTOFMEMORY;\n        return UA_STATUSCODE_BADDECODINGERROR;\n    }\n    \n    return UA_STATUSCODE_GOOD;\n}\n\nUA_StatusCode\ndecodeJsonInternal(void *dst, const UA_DataType *type,\n                   CtxJson *ctx, ParseCtx *parseCtx, UA_Boolean moveToken) {\n\n    return decodeJsonJumpTable[type->typeKind](dst, type, ctx, parseCtx, moveToken);\n}\n\nstatus UA_FUNC_ATTR_WARN_UNUSED_RESULT\nUA_decodeJson(const UA_ByteString *src, void *dst, const UA_DataType *type) {\n    \n#ifndef UA_ENABLE_TYPEDESCRIPTION\n    return UA_STATUSCODE_BADNOTSUPPORTED;\n#endif\n    \n    if(dst == NULL || src == NULL || type == NULL) {\n        return UA_STATUSCODE_BADARGUMENTSMISSING;\n    }\n    \n    /* Set up the context */\n    CtxJson ctx;\n    ParseCtx parseCtx;\n    parseCtx.tokenArray = (jsmntok_t*)UA_malloc(sizeof(jsmntok_t) * UA_JSON_MAXTOKENCOUNT);\n    if(!parseCtx.tokenArray)\n        return UA_STATUSCODE_BADOUTOFMEMORY;\n    \n    status ret = tokenize(&parseCtx, &ctx, src);\n    if(ret != UA_STATUSCODE_GOOD)\n        goto cleanup;\n\n    /* Assume the top-level element is an object */\n    if(parseCtx.tokenCount < 1 || parseCtx.tokenArray[0].type != JSMN_OBJECT) {\n        if(parseCtx.tokenCount == 1) {\n            if(parseCtx.tokenArray[0].type == JSMN_PRIMITIVE ||\n               parseCtx.tokenArray[0].type == JSMN_STRING) {\n               /* Only a primitive to parse. Do it directly. */\n               memset(dst, 0, type->memSize); /* Initialize the value */\n               ret = decodeJsonJumpTable[type->typeKind](dst, type, &ctx, &parseCtx, true);\n               goto cleanup;\n            }\n        }\n        ret = UA_STATUSCODE_BADDECODINGERROR;\n        goto cleanup;\n    }\n\n    /* Decode */\n    memset(dst, 0, type->memSize); /* Initialize the value */\n    ret = decodeJsonJumpTable[type->typeKind](dst, type, &ctx, &parseCtx, true);\n\n    cleanup:\n    UA_free(parseCtx.tokenArray);\n    \n    /* sanity check if all Tokens were processed */\n    if(!(parseCtx.index == parseCtx.tokenCount ||\n         parseCtx.index == parseCtx.tokenCount-1)) {\n        ret = UA_STATUSCODE_BADDECODINGERROR;\n    }\n    \n    if(ret != UA_STATUSCODE_GOOD)\n        UA_deleteMembers(dst, type); /* Clean up */\n    return ret;\n}\n"], "fixing_code": ["/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. \n *\n *    Copyright 2014-2018 (c) Fraunhofer IOSB (Author: Julius Pfrommer)\n *    Copyright 2018 (c) Fraunhofer IOSB (Author: Lukas Meling)\n */\n\n#include \"ua_types_encoding_json.h\"\n\n#include <open62541/types_generated.h>\n#include <open62541/types_generated_handling.h>\n\n#include \"ua_types_encoding_binary.h\"\n\n#include <float.h>\n#include <math.h>\n\n#ifdef UA_ENABLE_CUSTOM_LIBC\n#include \"../deps/musl/floatscan.h\"\n#include \"../deps/musl/vfprintf.h\"\n#endif\n\n#include \"../deps/itoa.h\"\n#include \"../deps/atoi.h\"\n#include \"../deps/string_escape.h\"\n#include \"../deps/base64.h\"\n\n#include \"../deps/libc_time.h\"\n\n#if defined(_MSC_VER)\n# define strtoll _strtoi64\n# define strtoull _strtoui64\n#endif\n\n/* vs2008 does not have INFINITY and NAN defined */\n#ifndef INFINITY\n# define INFINITY ((UA_Double)(DBL_MAX+DBL_MAX))\n#endif\n#ifndef NAN\n# define NAN ((UA_Double)(INFINITY-INFINITY))\n#endif\n\n#if defined(_MSC_VER)\n# pragma warning(disable: 4756)\n# pragma warning(disable: 4056)\n#endif\n\n#define UA_NODEIDTYPE_NUMERIC_TWOBYTE 0\n#define UA_NODEIDTYPE_NUMERIC_FOURBYTE 1\n#define UA_NODEIDTYPE_NUMERIC_COMPLETE 2\n\n#define UA_EXPANDEDNODEID_SERVERINDEX_FLAG 0x40\n#define UA_EXPANDEDNODEID_NAMESPACEURI_FLAG 0x80\n\n#define UA_JSON_DATETIME_LENGTH 30\n\n/* Max length of numbers for the allocation of temp buffers. Don't forget that\n * printf adds an additional \\0 at the end!\n *\n * Sources:\n * https://www.exploringbinary.com/maximum-number-of-decimal-digits-in-binary-floating-point-numbers/\n *\n * UInt16: 3 + 1\n * SByte: 3 + 1\n * UInt32:\n * Int32:\n * UInt64:\n * Int64:\n * Float: 149 + 1\n * Double: 767 + 1\n */\n\n/************/\n/* Encoding */\n/************/\n\n#define ENCODE_JSON(TYPE) static status \\\n    TYPE##_encodeJson(const UA_##TYPE *src, const UA_DataType *type, CtxJson *ctx)\n\n#define ENCODE_DIRECT_JSON(SRC, TYPE) \\\n    TYPE##_encodeJson((const UA_##TYPE*)SRC, NULL, ctx)\n\nextern const encodeJsonSignature encodeJsonJumpTable[UA_DATATYPEKINDS];\nextern const decodeJsonSignature decodeJsonJumpTable[UA_DATATYPEKINDS];\n\n/* Forward declarations */\nUA_String UA_DateTime_toJSON(UA_DateTime t);\nENCODE_JSON(ByteString);\n\nstatic status UA_FUNC_ATTR_WARN_UNUSED_RESULT\nwriteChar(CtxJson *ctx, char c) {\n    if(ctx->pos >= ctx->end)\n        return UA_STATUSCODE_BADENCODINGLIMITSEXCEEDED;\n    if(!ctx->calcOnly)\n        *ctx->pos = (UA_Byte)c;\n    ctx->pos++;\n    return UA_STATUSCODE_GOOD;\n}\n\n#define WRITE_JSON_ELEMENT(ELEM)                            \\\n    UA_FUNC_ATTR_WARN_UNUSED_RESULT status                  \\\n    writeJson##ELEM(CtxJson *ctx)\n\nstatic WRITE_JSON_ELEMENT(Quote) {\n    return writeChar(ctx, '\\\"');\n}\n\nWRITE_JSON_ELEMENT(ObjStart) {\n    /* increase depth, save: before first key-value no comma needed. */\n    if(ctx->depth >= UA_JSON_ENCODING_MAX_RECURSION)\n        return UA_STATUSCODE_BADENCODINGERROR;\n    ctx->depth++;\n    ctx->commaNeeded[ctx->depth] = false;\n    return writeChar(ctx, '{');\n}\n\nWRITE_JSON_ELEMENT(ObjEnd) {\n    ctx->depth--; //decrease depth\n    ctx->commaNeeded[ctx->depth] = true;\n    return writeChar(ctx, '}');\n}\n\nWRITE_JSON_ELEMENT(ArrStart) {\n    /* increase depth, save: before first array entry no comma needed. */\n    if(ctx->depth >= UA_JSON_ENCODING_MAX_RECURSION)\n        return UA_STATUSCODE_BADENCODINGERROR;\n    ctx->depth++;\n    ctx->commaNeeded[ctx->depth] = false;\n    return writeChar(ctx, '[');\n}\n\nWRITE_JSON_ELEMENT(ArrEnd) {\n    ctx->depth--; //decrease depth\n    ctx->commaNeeded[ctx->depth] = true;\n    return writeChar(ctx, ']');\n}\n\nWRITE_JSON_ELEMENT(CommaIfNeeded) {\n    if(ctx->commaNeeded[ctx->depth])\n        return writeChar(ctx, ',');\n    return UA_STATUSCODE_GOOD;\n}\n\nstatus\nwriteJsonArrElm(CtxJson *ctx, const void *value,\n                const UA_DataType *type) {\n    status ret = writeJsonCommaIfNeeded(ctx);\n    ctx->commaNeeded[ctx->depth] = true;\n    ret |= encodeJsonInternal(value, type, ctx);\n    return ret;\n}\n\nstatus writeJsonObjElm(CtxJson *ctx, const char *key,\n                       const void *value, const UA_DataType *type){\n    return writeJsonKey(ctx, key) | encodeJsonInternal(value, type, ctx);\n}\n\nstatus writeJsonNull(CtxJson *ctx) {\n    if(ctx->pos + 4 > ctx->end)\n        return UA_STATUSCODE_BADENCODINGLIMITSEXCEEDED;\n    if(ctx->calcOnly) {\n        ctx->pos += 4;\n    } else {\n        *(ctx->pos++) = 'n';\n        *(ctx->pos++) = 'u';\n        *(ctx->pos++) = 'l';\n        *(ctx->pos++) = 'l';\n    }\n    return UA_STATUSCODE_GOOD;\n}\n\n/* Keys for JSON */\n\n/* LocalizedText */\nstatic const char* UA_JSONKEY_LOCALE = \"Locale\";\nstatic const char* UA_JSONKEY_TEXT = \"Text\";\n\n/* QualifiedName */\nstatic const char* UA_JSONKEY_NAME = \"Name\";\nstatic const char* UA_JSONKEY_URI = \"Uri\";\n\n/* NodeId */\nstatic const char* UA_JSONKEY_ID = \"Id\";\nstatic const char* UA_JSONKEY_IDTYPE = \"IdType\";\nstatic const char* UA_JSONKEY_NAMESPACE = \"Namespace\";\n\n/* ExpandedNodeId */\nstatic const char* UA_JSONKEY_SERVERURI = \"ServerUri\";\n\n/* Variant */\nstatic const char* UA_JSONKEY_TYPE = \"Type\";\nstatic const char* UA_JSONKEY_BODY = \"Body\";\nstatic const char* UA_JSONKEY_DIMENSION = \"Dimension\";\n\n/* DataValue */\nstatic const char* UA_JSONKEY_VALUE = \"Value\";\nstatic const char* UA_JSONKEY_STATUS = \"Status\";\nstatic const char* UA_JSONKEY_SOURCETIMESTAMP = \"SourceTimestamp\";\nstatic const char* UA_JSONKEY_SOURCEPICOSECONDS = \"SourcePicoseconds\";\nstatic const char* UA_JSONKEY_SERVERTIMESTAMP = \"ServerTimestamp\";\nstatic const char* UA_JSONKEY_SERVERPICOSECONDS = \"ServerPicoseconds\";\n\n/* ExtensionObject */\nstatic const char* UA_JSONKEY_ENCODING = \"Encoding\";\nstatic const char* UA_JSONKEY_TYPEID = \"TypeId\";\n\n/* StatusCode */\nstatic const char* UA_JSONKEY_CODE = \"Code\";\nstatic const char* UA_JSONKEY_SYMBOL = \"Symbol\";\n\n/* DiagnosticInfo */\nstatic const char* UA_JSONKEY_SYMBOLICID = \"SymbolicId\";\nstatic const char* UA_JSONKEY_NAMESPACEURI = \"NamespaceUri\";\nstatic const char* UA_JSONKEY_LOCALIZEDTEXT = \"LocalizedText\";\nstatic const char* UA_JSONKEY_ADDITIONALINFO = \"AdditionalInfo\";\nstatic const char* UA_JSONKEY_INNERSTATUSCODE = \"InnerStatusCode\";\nstatic const char* UA_JSONKEY_INNERDIAGNOSTICINFO = \"InnerDiagnosticInfo\";\n\n/* Writes null terminated string to output buffer (current ctx->pos). Writes\n * comma in front of key if needed. Encapsulates key in quotes. */\nstatus UA_FUNC_ATTR_WARN_UNUSED_RESULT\nwriteJsonKey(CtxJson *ctx, const char* key) {\n    size_t size = strlen(key);\n    if(ctx->pos + size + 4 > ctx->end) /* +4 because of \" \" : and , */\n        return UA_STATUSCODE_BADENCODINGLIMITSEXCEEDED;\n    status ret = writeJsonCommaIfNeeded(ctx);\n    ctx->commaNeeded[ctx->depth] = true;\n    if(ctx->calcOnly) {\n        ctx->commaNeeded[ctx->depth] = true;\n        ctx->pos += 3;\n        ctx->pos += size;\n        return ret;\n    }\n\n    ret |= writeChar(ctx, '\\\"');\n    for(size_t i = 0; i < size; i++) {\n        *(ctx->pos++) = (u8)key[i];\n    }\n    ret |= writeChar(ctx, '\\\"');\n    ret |= writeChar(ctx, ':');\n    return ret;\n}\n\n/* Boolean */\nENCODE_JSON(Boolean) {\n    size_t sizeOfJSONBool;\n    if(*src == true) {\n        sizeOfJSONBool = 4; /*\"true\"*/\n    } else {\n        sizeOfJSONBool = 5; /*\"false\"*/\n    }\n\n    if(ctx->calcOnly) {\n        ctx->pos += sizeOfJSONBool;\n        return UA_STATUSCODE_GOOD;\n    }\n\n    if(ctx->pos + sizeOfJSONBool > ctx->end)\n        return UA_STATUSCODE_BADENCODINGLIMITSEXCEEDED;\n\n    if(*src) {\n        *(ctx->pos++) = 't';\n        *(ctx->pos++) = 'r';\n        *(ctx->pos++) = 'u';\n        *(ctx->pos++) = 'e';\n    } else {\n        *(ctx->pos++) = 'f';\n        *(ctx->pos++) = 'a';\n        *(ctx->pos++) = 'l';\n        *(ctx->pos++) = 's';\n        *(ctx->pos++) = 'e';\n    }\n    return UA_STATUSCODE_GOOD;\n}\n\n/*****************/\n/* Integer Types */\n/*****************/\n\n/* Byte */\nENCODE_JSON(Byte) {\n    char buf[4];\n    UA_UInt16 digits = itoaUnsigned(*src, buf, 10);\n\n    /* Ensure destination can hold the data- */\n    if(ctx->pos + digits > ctx->end)\n        return UA_STATUSCODE_BADENCODINGLIMITSEXCEEDED;\n\n    /* Copy digits to the output string/buffer. */\n    if(!ctx->calcOnly)\n        memcpy(ctx->pos, buf, digits);\n    ctx->pos += digits;\n    return UA_STATUSCODE_GOOD;\n}\n\n/* signed Byte */\nENCODE_JSON(SByte) {\n    char buf[5];\n    UA_UInt16 digits = itoaSigned(*src, buf);\n    if(ctx->pos + digits > ctx->end)\n        return UA_STATUSCODE_BADENCODINGLIMITSEXCEEDED;\n    if(!ctx->calcOnly)\n        memcpy(ctx->pos, buf, digits);\n    ctx->pos += digits;\n    return UA_STATUSCODE_GOOD;\n}\n\n/* UInt16 */\nENCODE_JSON(UInt16) {\n    char buf[6];\n    UA_UInt16 digits = itoaUnsigned(*src, buf, 10);\n\n    if(ctx->pos + digits > ctx->end)\n        return UA_STATUSCODE_BADENCODINGLIMITSEXCEEDED;\n\n    if(!ctx->calcOnly)\n        memcpy(ctx->pos, buf, digits);\n    ctx->pos += digits;\n    return UA_STATUSCODE_GOOD;\n}\n\n/* Int16 */\nENCODE_JSON(Int16) {\n    char buf[7];\n    UA_UInt16 digits = itoaSigned(*src, buf);\n\n    if(ctx->pos + digits > ctx->end)\n        return UA_STATUSCODE_BADENCODINGLIMITSEXCEEDED;\n\n    if(!ctx->calcOnly)\n        memcpy(ctx->pos, buf, digits);\n    ctx->pos += digits;\n    return UA_STATUSCODE_GOOD;\n}\n\n/* UInt32 */\nENCODE_JSON(UInt32) {\n    char buf[11];\n    UA_UInt16 digits = itoaUnsigned(*src, buf, 10);\n\n    if(ctx->pos + digits > ctx->end)\n        return UA_STATUSCODE_BADENCODINGLIMITSEXCEEDED;\n\n    if(!ctx->calcOnly)\n        memcpy(ctx->pos, buf, digits);\n    ctx->pos += digits;\n    return UA_STATUSCODE_GOOD;\n}\n\n/* Int32 */\nENCODE_JSON(Int32) {\n    char buf[12];\n    UA_UInt16 digits = itoaSigned(*src, buf);\n\n    if(ctx->pos + digits > ctx->end)\n        return UA_STATUSCODE_BADENCODINGLIMITSEXCEEDED;\n\n    if(!ctx->calcOnly)\n        memcpy(ctx->pos, buf, digits);\n    ctx->pos += digits;\n    return UA_STATUSCODE_GOOD;\n}\n\n/* UInt64 */\nENCODE_JSON(UInt64) {\n    char buf[23];\n    buf[0] = '\\\"';\n    UA_UInt16 digits = itoaUnsigned(*src, buf + 1, 10);\n    buf[digits + 1] = '\\\"';\n    UA_UInt16 length = (UA_UInt16)(digits + 2);\n\n    if(ctx->pos + length > ctx->end)\n        return UA_STATUSCODE_BADENCODINGLIMITSEXCEEDED;\n\n    if(!ctx->calcOnly)\n        memcpy(ctx->pos, buf, length);\n\n    ctx->pos += length;\n    return UA_STATUSCODE_GOOD;\n}\n\n/* Int64 */\nENCODE_JSON(Int64) {\n    char buf[23];\n    buf[0] = '\\\"';\n    UA_UInt16 digits = itoaSigned(*src, buf + 1);\n    buf[digits + 1] = '\\\"';\n    UA_UInt16 length = (UA_UInt16)(digits + 2);\n\n    if(ctx->pos + length > ctx->end)\n        return UA_STATUSCODE_BADENCODINGLIMITSEXCEEDED;\n\n    if(!ctx->calcOnly)\n        memcpy(ctx->pos, buf, length);\n    ctx->pos += length;\n    return UA_STATUSCODE_GOOD;\n}\n\n/************************/\n/* Floating Point Types */\n/************************/\n\n/* Convert special numbers to string\n * - fmt_fp gives NAN, nan,-NAN, -nan, inf, INF, -inf, -INF\n * - Special floating-point numbers such as positive infinity (INF), negative\n *   infinity (-INF) and not-a-number (NaN) shall be represented by the values\n *   \u201cInfinity\u201d, \u201c-Infinity\u201d and \u201cNaN\u201d encoded as a JSON string. */\nstatic status\ncheckAndEncodeSpecialFloatingPoint(char *buffer, size_t *len) {\n    /*nan and NaN*/\n    if(*len == 3 && \n            (buffer[0] == 'n' || buffer[0] == 'N') && \n            (buffer[1] == 'a' || buffer[1] == 'A') && \n            (buffer[2] == 'n' || buffer[2] == 'N')) {\n        *len = 5;\n        memcpy(buffer, \"\\\"NaN\\\"\", *len);\n        return UA_STATUSCODE_GOOD;\n    }\n\n    /*-nan and -NaN*/\n    if(*len == 4 && buffer[0] == '-' && \n            (buffer[1] == 'n' || buffer[1] == 'N') && \n            (buffer[2] == 'a' || buffer[2] == 'A') && \n            (buffer[3] == 'n' || buffer[3] == 'N')) {\n        *len = 6;\n        memcpy(buffer, \"\\\"-NaN\\\"\", *len);\n        return UA_STATUSCODE_GOOD;\n    }\n\n    /*inf*/\n    if(*len == 3 && \n            (buffer[0] == 'i' || buffer[0] == 'I') && \n            (buffer[1] == 'n' || buffer[1] == 'N') && \n            (buffer[2] == 'f' || buffer[2] == 'F')) {\n        *len = 10;\n        memcpy(buffer, \"\\\"Infinity\\\"\", *len);\n        return UA_STATUSCODE_GOOD;\n    }\n\n    /*-inf*/\n    if(*len == 4 && buffer[0] == '-' && \n            (buffer[1] == 'i' || buffer[1] == 'I') && \n            (buffer[2] == 'n' || buffer[2] == 'N') && \n            (buffer[3] == 'f' || buffer[3] == 'F')) {\n        *len = 11;\n        memcpy(buffer, \"\\\"-Infinity\\\"\", *len);\n        return UA_STATUSCODE_GOOD;\n    }\n    return UA_STATUSCODE_GOOD;\n}\n\nENCODE_JSON(Float) {\n    char buffer[200];\n    if(*src == *src) {\n#ifdef UA_ENABLE_CUSTOM_LIBC\n        fmt_fp(buffer, *src, 0, -1, 0, 'g');\n#else\n        UA_snprintf(buffer, 200, \"%.149g\", (UA_Double)*src);\n#endif\n    } else {\n        strcpy(buffer, \"NaN\");\n    }\n\n    size_t len = strlen(buffer);\n    if(len == 0)\n        return UA_STATUSCODE_BADENCODINGERROR;\n    \n    checkAndEncodeSpecialFloatingPoint(buffer, &len);\n    \n    if(ctx->pos + len > ctx->end)\n        return UA_STATUSCODE_BADENCODINGLIMITSEXCEEDED;\n\n    if(!ctx->calcOnly)\n        memcpy(ctx->pos, buffer, len);\n\n    ctx->pos += len;\n    return UA_STATUSCODE_GOOD;\n}\n\nENCODE_JSON(Double) {\n    char buffer[2000];\n    if(*src == *src) {\n#ifdef UA_ENABLE_CUSTOM_LIBC\n        fmt_fp(buffer, *src, 0, 17, 0, 'g');\n#else\n        UA_snprintf(buffer, 2000, \"%.1074g\", *src);\n#endif\n    } else {\n        strcpy(buffer, \"NaN\");\n    }\n\n    size_t len = strlen(buffer);\n    checkAndEncodeSpecialFloatingPoint(buffer, &len);    \n\n    if(ctx->pos + len > ctx->end)\n        return UA_STATUSCODE_BADENCODINGLIMITSEXCEEDED;\n\n    if(!ctx->calcOnly)\n        memcpy(ctx->pos, buffer, len);\n\n    ctx->pos += len;\n    return UA_STATUSCODE_GOOD;\n}\n\nstatic status\nencodeJsonArray(CtxJson *ctx, const void *ptr, size_t length,\n                const UA_DataType *type) {\n    encodeJsonSignature encodeType = encodeJsonJumpTable[type->typeKind];\n    status ret = writeJsonArrStart(ctx);\n    uintptr_t uptr = (uintptr_t)ptr;\n    for(size_t i = 0; i < length && ret == UA_STATUSCODE_GOOD; ++i) {\n        ret |= writeJsonCommaIfNeeded(ctx);\n        ret |= encodeType((const void*)uptr, type, ctx);\n        ctx->commaNeeded[ctx->depth] = true;\n        uptr += type->memSize;\n    }\n    ret |= writeJsonArrEnd(ctx);\n    return ret;\n}\n\n/*****************/\n/* Builtin Types */\n/*****************/\n\nstatic const u8 hexmapLower[16] =\n    {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};\nstatic const u8 hexmapUpper[16] =\n    {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};\n\nENCODE_JSON(String) {\n    if(!src->data)\n        return writeJsonNull(ctx);\n\n    if(src->length == 0) {\n        status retval = writeJsonQuote(ctx);\n        retval |= writeJsonQuote(ctx);\n        return  retval;\n    }\n\n    UA_StatusCode ret = writeJsonQuote(ctx);\n    \n    /* Escaping adapted from https://github.com/akheron/jansson dump.c */\n\n    const char *str = (char*)src->data;\n    const char *pos = str;\n    const char *end = str;\n    const char *lim = str + src->length;\n    UA_UInt32 codepoint = 0;\n    while(1) {\n        const char *text;\n        u8 seq[13];\n        size_t length;\n\n        while(end < lim) {\n            end = utf8_iterate(pos, (size_t)(lim - pos), (int32_t *)&codepoint);\n            if(!end)\n                return UA_STATUSCODE_BADENCODINGERROR;\n\n            /* mandatory escape or control char */\n            if(codepoint == '\\\\' || codepoint == '\"' || codepoint < 0x20)\n                break;\n\n            /* TODO: Why is this commented? */\n            /* slash \n            if((flags & JSON_ESCAPE_SLASH) && codepoint == '/')\n                break;*/\n\n            /* non-ASCII\n            if((flags & JSON_ENSURE_ASCII) && codepoint > 0x7F)\n                break;*/\n\n            pos = end;\n        }\n\n        if(pos != str) {\n            if(ctx->pos + (pos - str) > ctx->end)\n                return UA_STATUSCODE_BADENCODINGLIMITSEXCEEDED;\n            if(!ctx->calcOnly)\n                memcpy(ctx->pos, str, (size_t)(pos - str));\n            ctx->pos += pos - str;\n        }\n\n        if(end == pos)\n            break;\n\n        /* handle \\, /, \", and control codes */\n        length = 2;\n        switch(codepoint) {\n        case '\\\\': text = \"\\\\\\\\\"; break;\n        case '\\\"': text = \"\\\\\\\"\"; break;\n        case '\\b': text = \"\\\\b\"; break;\n        case '\\f': text = \"\\\\f\"; break;\n        case '\\n': text = \"\\\\n\"; break;\n        case '\\r': text = \"\\\\r\"; break;\n        case '\\t': text = \"\\\\t\"; break;\n        case '/':  text = \"\\\\/\"; break;\n        default:\n            if(codepoint < 0x10000) {\n                /* codepoint is in BMP */\n                seq[0] = '\\\\';\n                seq[1] = 'u';\n                UA_Byte b1 = (UA_Byte)(codepoint >> 8u);\n                UA_Byte b2 = (UA_Byte)(codepoint >> 0u);\n                seq[2] = hexmapLower[(b1 & 0xF0u) >> 4u];\n                seq[3] = hexmapLower[b1 & 0x0Fu];\n                seq[4] = hexmapLower[(b2 & 0xF0u) >> 4u];\n                seq[5] = hexmapLower[b2 & 0x0Fu];\n                length = 6;\n            } else {\n                /* not in BMP -> construct a UTF-16 surrogate pair */\n                codepoint -= 0x10000;\n                UA_UInt32 first = 0xD800u | ((codepoint & 0xffc00u) >> 10u);\n                UA_UInt32 last = 0xDC00u | (codepoint & 0x003ffu);\n\n                UA_Byte fb1 = (UA_Byte)(first >> 8u);\n                UA_Byte fb2 = (UA_Byte)(first >> 0u);\n                    \n                UA_Byte lb1 = (UA_Byte)(last >> 8u);\n                UA_Byte lb2 = (UA_Byte)(last >> 0u);\n                    \n                seq[0] = '\\\\';\n                seq[1] = 'u';\n                seq[2] = hexmapLower[(fb1 & 0xF0u) >> 4u];\n                seq[3] = hexmapLower[fb1 & 0x0Fu];\n                seq[4] = hexmapLower[(fb2 & 0xF0u) >> 4u];\n                seq[5] = hexmapLower[fb2 & 0x0Fu];\n                    \n                seq[6] = '\\\\';\n                seq[7] = 'u';\n                seq[8] = hexmapLower[(lb1 & 0xF0u) >> 4u];\n                seq[9] = hexmapLower[lb1 & 0x0Fu];\n                seq[10] = hexmapLower[(lb2 & 0xF0u) >> 4u];\n                seq[11] = hexmapLower[lb2 & 0x0Fu];\n                length = 12;\n            }\n            text = (char*)seq;\n            break;\n        }\n\n        if(ctx->pos + length > ctx->end)\n            return UA_STATUSCODE_BADENCODINGLIMITSEXCEEDED;\n        if(!ctx->calcOnly)\n            memcpy(ctx->pos, text, length);\n        ctx->pos += length;\n        str = pos = end;\n    }\n\n    ret |= writeJsonQuote(ctx);\n    return ret;\n}\n    \nENCODE_JSON(ByteString) {\n    if(!src->data)\n        return writeJsonNull(ctx);\n\n    if(src->length == 0) {\n        status retval = writeJsonQuote(ctx);\n        retval |= writeJsonQuote(ctx);\n        return retval;\n    }\n\n    status ret = writeJsonQuote(ctx);\n    size_t flen = 0;\n    unsigned char *ba64 = UA_base64(src->data, src->length, &flen);\n    \n    /* Not converted, no mem */\n    if(!ba64)\n        return UA_STATUSCODE_BADENCODINGERROR;\n\n    if(ctx->pos + flen > ctx->end) {\n        UA_free(ba64);\n        return UA_STATUSCODE_BADENCODINGLIMITSEXCEEDED;\n    }\n    \n    /* Copy flen bytes to output stream. */\n    if(!ctx->calcOnly)\n        memcpy(ctx->pos, ba64, flen);\n    ctx->pos += flen;\n\n    /* Base64 result no longer needed */\n    UA_free(ba64);\n    \n    ret |= writeJsonQuote(ctx);\n    return ret;\n}\n\n/* Converts Guid to a hexadecimal represenation */\nstatic void UA_Guid_to_hex(const UA_Guid *guid, u8* out) {\n    /*\n                          16 byte\n       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n       |   data1   |data2|data3|          data4        |\n       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n       |aa aa aa aa-bb bb-cc cc-dd dd-ee ee ee ee ee ee|\n       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n                          36 character\n    */\n\n#ifdef hexCharlowerCase\n    const u8 *hexmap = hexmapLower;\n#else\n    const u8 *hexmap = hexmapUpper;\n#endif\n    size_t i = 0, j = 28;\n    for(; i<8;i++,j-=4)         /* pos 0-7, 4byte, (a) */\n        out[i] = hexmap[(guid->data1 >> j) & 0x0Fu];\n    out[i++] = '-';             /* pos 8 */\n    for(j=12; i<13;i++,j-=4)    /* pos 9-12, 2byte, (b) */\n        out[i] = hexmap[(uint16_t)(guid->data2 >> j) & 0x0Fu];\n    out[i++] = '-';             /* pos 13 */\n    for(j=12; i<18;i++,j-=4)    /* pos 14-17, 2byte (c) */\n        out[i] = hexmap[(uint16_t)(guid->data3 >> j) & 0x0Fu];\n    out[i++] = '-';             /* pos 18 */\n    for(j=0;i<23;i+=2,j++) {     /* pos 19-22, 2byte (d) */\n        out[i] = hexmap[(guid->data4[j] & 0xF0u) >> 4u];\n        out[i+1] = hexmap[guid->data4[j] & 0x0Fu];\n    }\n    out[i++] = '-';             /* pos 23 */\n    for(j=2; i<36;i+=2,j++) {    /* pos 24-35, 6byte (e) */\n        out[i] = hexmap[(guid->data4[j] & 0xF0u) >> 4u];\n        out[i+1] = hexmap[guid->data4[j] & 0x0Fu];\n    }\n}\n\n/* Guid */\nENCODE_JSON(Guid) {\n    if(ctx->pos + 38 > ctx->end) /* 36 + 2 (\") */\n        return UA_STATUSCODE_BADENCODINGLIMITSEXCEEDED;\n    status ret = writeJsonQuote(ctx);\n    u8 *buf = ctx->pos;\n    if(!ctx->calcOnly)\n        UA_Guid_to_hex(src, buf);\n    ctx->pos += 36;\n    ret |= writeJsonQuote(ctx);\n    return ret;\n}\n\nstatic void\nprintNumber(u16 n, u8 *pos, size_t digits) {\n    for(size_t i = digits; i > 0; --i) {\n        pos[i - 1] = (u8) ((n % 10) + '0');\n        n = n / 10;\n    }\n}\n\nENCODE_JSON(DateTime) {\n    UA_DateTimeStruct tSt = UA_DateTime_toStruct(*src);\n\n    /* Format: yyyy-MM-dd'T'HH:mm:ss.SSSSSSSSS'Z' is used. max 30 bytes.*/\n    UA_Byte buffer[UA_JSON_DATETIME_LENGTH];\n\n    printNumber(tSt.year, &buffer[0], 4);\n    buffer[4] = '-';\n    printNumber(tSt.month, &buffer[5], 2);\n    buffer[7] = '-';\n    printNumber(tSt.day, &buffer[8], 2);\n    buffer[10] = 'T';\n    printNumber(tSt.hour, &buffer[11], 2);\n    buffer[13] = ':';\n    printNumber(tSt.min, &buffer[14], 2);\n    buffer[16] = ':';\n    printNumber(tSt.sec, &buffer[17], 2);\n    buffer[19] = '.';\n    printNumber(tSt.milliSec, &buffer[20], 3);\n    printNumber(tSt.microSec, &buffer[23], 3);\n    printNumber(tSt.nanoSec, &buffer[26], 3);\n\n    size_t length = 28;\n    while (buffer[length] == '0')\n        length--;\n    if (length != 19)\n         length++;\n\n    buffer[length] = 'Z';\n    UA_String str = {length + 1, buffer};\n    return ENCODE_DIRECT_JSON(&str, String);\n}\n\n/* NodeId */\nstatic status\nNodeId_encodeJsonInternal(UA_NodeId const *src, CtxJson *ctx) {\n    status ret = UA_STATUSCODE_GOOD;\n    switch (src->identifierType) {\n    case UA_NODEIDTYPE_NUMERIC:\n        ret |= writeJsonKey(ctx, UA_JSONKEY_ID);\n        ret |= ENCODE_DIRECT_JSON(&src->identifier.numeric, UInt32);\n        break;\n    case UA_NODEIDTYPE_STRING:\n        ret |= writeJsonKey(ctx, UA_JSONKEY_IDTYPE);\n        ret |= writeChar(ctx, '1');\n        ret |= writeJsonKey(ctx, UA_JSONKEY_ID);\n        ret |= ENCODE_DIRECT_JSON(&src->identifier.string, String);\n        break;\n    case UA_NODEIDTYPE_GUID:\n        ret |= writeJsonKey(ctx, UA_JSONKEY_IDTYPE);\n        ret |= writeChar(ctx, '2');\n        ret |= writeJsonKey(ctx, UA_JSONKEY_ID); /* Id */\n        ret |= ENCODE_DIRECT_JSON(&src->identifier.guid, Guid);\n        break;\n    case UA_NODEIDTYPE_BYTESTRING:\n        ret |= writeJsonKey(ctx, UA_JSONKEY_IDTYPE);\n        ret |= writeChar(ctx, '3');\n        ret |= writeJsonKey(ctx, UA_JSONKEY_ID); /* Id */\n        ret |= ENCODE_DIRECT_JSON(&src->identifier.byteString, ByteString);\n        break;\n    default:\n        return UA_STATUSCODE_BADINTERNALERROR;\n    }\n    return ret;\n}\n\nENCODE_JSON(NodeId) {\n    UA_StatusCode ret = writeJsonObjStart(ctx);\n    ret |= NodeId_encodeJsonInternal(src, ctx);\n    if(ctx->useReversible) {\n        if(src->namespaceIndex > 0) {\n            ret |= writeJsonKey(ctx, UA_JSONKEY_NAMESPACE);\n            ret |= ENCODE_DIRECT_JSON(&src->namespaceIndex, UInt16);\n        }\n    } else {\n        /* For the non-reversible encoding, the field is the NamespaceUri \n         * associated with the NamespaceIndex, encoded as a JSON string.\n         * A NamespaceIndex of 1 is always encoded as a JSON number. */\n        if(src->namespaceIndex == 1) {\n            ret |= writeJsonKey(ctx, UA_JSONKEY_NAMESPACE);\n            ret |= ENCODE_DIRECT_JSON(&src->namespaceIndex, UInt16);\n        } else {\n            ret |= writeJsonKey(ctx, UA_JSONKEY_NAMESPACE);\n            \n            /* Check if Namespace given and in range */\n            if(src->namespaceIndex < ctx->namespacesSize && ctx->namespaces != NULL) {\n                UA_String namespaceEntry = ctx->namespaces[src->namespaceIndex];\n                ret |= ENCODE_DIRECT_JSON(&namespaceEntry, String);\n            } else {\n                return UA_STATUSCODE_BADNOTFOUND;\n            }\n        }\n    }\n\n    ret |= writeJsonObjEnd(ctx);\n    return ret;\n}\n\n/* ExpandedNodeId */\nENCODE_JSON(ExpandedNodeId) {\n    status ret = writeJsonObjStart(ctx);\n    /* Encode the NodeId */\n    ret |= NodeId_encodeJsonInternal(&src->nodeId, ctx);\n    \n    if(ctx->useReversible) {\n        if(src->namespaceUri.data != NULL && src->namespaceUri.length != 0 && \n           (void*) src->namespaceUri.data > UA_EMPTY_ARRAY_SENTINEL) {\n            /* If the NamespaceUri is specified it is encoded as a JSON string in this field. */ \n            ret |= writeJsonKey(ctx, UA_JSONKEY_NAMESPACE);\n            ret |= ENCODE_DIRECT_JSON(&src->namespaceUri, String);\n        } else {\n            /* If the NamespaceUri is not specified, the NamespaceIndex is encoded with these rules:\n             * The field is encoded as a JSON number for the reversible encoding.\n             * The field is omitted if the NamespaceIndex equals 0. */\n            if(src->nodeId.namespaceIndex > 0) {\n                ret |= writeJsonKey(ctx, UA_JSONKEY_NAMESPACE);\n                ret |= ENCODE_DIRECT_JSON(&src->nodeId.namespaceIndex, UInt16);\n            }\n        }\n\n        /* Encode the serverIndex/Url \n         * This field is encoded as a JSON number for the reversible encoding.\n         * This field is omitted if the ServerIndex equals 0. */\n        if(src->serverIndex > 0) {\n            ret |= writeJsonKey(ctx, UA_JSONKEY_SERVERURI);\n            ret |= ENCODE_DIRECT_JSON(&src->serverIndex, UInt32);\n        }\n\n        ret |= writeJsonObjEnd(ctx);\n        return ret;\n    }\n    \n    \n    /* NON-Reversible Case */\n\n    /* If the NamespaceUri is not specified, the NamespaceIndex is encoded with these rules:\n     * For the non-reversible encoding the field is the NamespaceUri associated with the\n     * NamespaceIndex encoded as a JSON string.\n     * A NamespaceIndex of 1 is always encoded as a JSON number. */\n\n    if(src->namespaceUri.data != NULL && src->namespaceUri.length != 0) {\n        ret |= writeJsonKey(ctx, UA_JSONKEY_NAMESPACE);\n        ret |= ENCODE_DIRECT_JSON(&src->namespaceUri, String);\n        if(ret != UA_STATUSCODE_GOOD)\n            return ret;\n    } else {\n        if(src->nodeId.namespaceIndex == 1) {\n            ret |= writeJsonKey(ctx, UA_JSONKEY_NAMESPACE);\n            ret |= ENCODE_DIRECT_JSON(&src->nodeId.namespaceIndex, UInt16);\n            if(ret != UA_STATUSCODE_GOOD)\n                return ret;\n        } else {\n            ret |= writeJsonKey(ctx, UA_JSONKEY_NAMESPACE);\n\n            /* Check if Namespace given and in range */\n            if(src->nodeId.namespaceIndex < ctx->namespacesSize \n                    && ctx->namespaces != NULL) {\n\n                UA_String namespaceEntry = ctx->namespaces[src->nodeId.namespaceIndex];\n                ret |= ENCODE_DIRECT_JSON(&namespaceEntry, String);\n                if(ret != UA_STATUSCODE_GOOD)\n                    return ret;\n            } else {\n                return UA_STATUSCODE_BADNOTFOUND;\n            }\n        }\n    }\n\n    /* For the non-reversible encoding, this field is the ServerUri associated\n     * with the ServerIndex portion of the ExpandedNodeId, encoded as a JSON\n     * string. */\n\n    /* Check if Namespace given and in range */\n    if(src->serverIndex < ctx->serverUrisSize && ctx->serverUris != NULL) {\n        UA_String serverUriEntry = ctx->serverUris[src->serverIndex];\n        ret |= writeJsonKey(ctx, UA_JSONKEY_SERVERURI);\n        ret |= ENCODE_DIRECT_JSON(&serverUriEntry, String);\n    } else {\n        return UA_STATUSCODE_BADNOTFOUND;\n    }\n    ret |= writeJsonObjEnd(ctx);\n    return ret;\n}\n\n/* LocalizedText */\nENCODE_JSON(LocalizedText) {\n    if(ctx->useReversible) {\n        status ret = writeJsonObjStart(ctx);\n        ret |= writeJsonKey(ctx, UA_JSONKEY_LOCALE);\n        ret |= ENCODE_DIRECT_JSON(&src->locale, String);\n        ret |= writeJsonKey(ctx, UA_JSONKEY_TEXT);\n        ret |= ENCODE_DIRECT_JSON(&src->text, String);\n        ret |= writeJsonObjEnd(ctx);\n        return ret;\n    }\n    \n    /* For the non-reversible form, LocalizedText value shall be encoded as a\n     * JSON string containing the Text component.*/\n    return ENCODE_DIRECT_JSON(&src->text, String);\n}\n\nENCODE_JSON(QualifiedName) {\n    status ret = writeJsonObjStart(ctx);\n    ret |= writeJsonKey(ctx, UA_JSONKEY_NAME);\n    ret |= ENCODE_DIRECT_JSON(&src->name, String);\n\n    if(ctx->useReversible) {\n        if(src->namespaceIndex != 0) {\n            ret |= writeJsonKey(ctx, UA_JSONKEY_URI);\n            ret |= ENCODE_DIRECT_JSON(&src->namespaceIndex, UInt16);\n        }\n    } else {\n        /* For the non-reversible form, the NamespaceUri associated with the\n         * NamespaceIndex portion of the QualifiedName is encoded as JSON string\n         * unless the NamespaceIndex is 1 or if NamespaceUri is unknown. In\n         * these cases, the NamespaceIndex is encoded as a JSON number. */\n        if(src->namespaceIndex == 1) {\n            ret |= writeJsonKey(ctx, UA_JSONKEY_URI);\n            ret |= ENCODE_DIRECT_JSON(&src->namespaceIndex, UInt16);\n        } else {\n            ret |= writeJsonKey(ctx, UA_JSONKEY_URI);\n\n             /* Check if Namespace given and in range */\n            if(src->namespaceIndex < ctx->namespacesSize && ctx->namespaces != NULL) {\n                UA_String namespaceEntry = ctx->namespaces[src->namespaceIndex];\n                ret |= ENCODE_DIRECT_JSON(&namespaceEntry, String);\n            } else {\n                /* If not encode as number */\n                ret |= ENCODE_DIRECT_JSON(&src->namespaceIndex, UInt16);\n            }\n        }\n    }\n\n    return ret | writeJsonObjEnd(ctx);\n}\n\nENCODE_JSON(StatusCode) {\n    if(!src)\n        return writeJsonNull(ctx);\n\n    if(ctx->useReversible)\n        return ENCODE_DIRECT_JSON(src, UInt32);\n\n    if(*src == UA_STATUSCODE_GOOD)\n        return writeJsonNull(ctx);\n\n    status ret = UA_STATUSCODE_GOOD;\n    ret |= writeJsonObjStart(ctx);\n    ret |= writeJsonKey(ctx, UA_JSONKEY_CODE);\n    ret |= ENCODE_DIRECT_JSON(src, UInt32);\n    ret |= writeJsonKey(ctx, UA_JSONKEY_SYMBOL);\n    const char *codename = UA_StatusCode_name(*src);\n    UA_String statusDescription = UA_STRING((char*)(uintptr_t)codename);\n    ret |= ENCODE_DIRECT_JSON(&statusDescription, String);\n    ret |= writeJsonObjEnd(ctx);\n    return ret;\n}\n\n/* ExtensionObject */\nENCODE_JSON(ExtensionObject) {\n    u8 encoding = (u8) src->encoding;\n    if(encoding == UA_EXTENSIONOBJECT_ENCODED_NOBODY)\n        return writeJsonNull(ctx);\n    \n    status ret = UA_STATUSCODE_GOOD;\n    /* already encoded content.*/\n    if(encoding <= UA_EXTENSIONOBJECT_ENCODED_XML) {\n        ret |= writeJsonObjStart(ctx);\n        if(ctx->useReversible) {\n            ret |= writeJsonKey(ctx, UA_JSONKEY_TYPEID);\n            ret |= ENCODE_DIRECT_JSON(&src->content.encoded.typeId, NodeId);\n            if(ret != UA_STATUSCODE_GOOD)\n                return ret;\n        }\n        \n        switch (src->encoding) {\n            case UA_EXTENSIONOBJECT_ENCODED_BYTESTRING:\n            {\n                if(ctx->useReversible) {\n                    ret |= writeJsonKey(ctx, UA_JSONKEY_ENCODING);\n                    ret |= writeChar(ctx, '1');\n                }\n                ret |= writeJsonKey(ctx, UA_JSONKEY_BODY);\n                ret |= ENCODE_DIRECT_JSON(&src->content.encoded.body, String);\n                break;\n            }\n            case UA_EXTENSIONOBJECT_ENCODED_XML:\n            {\n                if(ctx->useReversible) {\n                    ret |= writeJsonKey(ctx, UA_JSONKEY_ENCODING);\n                    ret |= writeChar(ctx, '2');\n                }\n                ret |= writeJsonKey(ctx, UA_JSONKEY_BODY);\n                ret |= ENCODE_DIRECT_JSON(&src->content.encoded.body, String);\n                break;\n            }\n            default:\n                ret = UA_STATUSCODE_BADINTERNALERROR;\n        }\n\n        ret |= writeJsonObjEnd(ctx);\n        return ret;\n    } /* encoding <= UA_EXTENSIONOBJECT_ENCODED_XML */\n         \n    /* Cannot encode with no type description */\n    if(!src->content.decoded.type)\n        return UA_STATUSCODE_BADENCODINGERROR;\n\n    if(!src->content.decoded.data)\n        return writeJsonNull(ctx);\n\n    UA_NodeId typeId = src->content.decoded.type->typeId;\n    if(typeId.identifierType != UA_NODEIDTYPE_NUMERIC)\n        return UA_STATUSCODE_BADENCODINGERROR;\n\n    ret |= writeJsonObjStart(ctx);\n    const UA_DataType *contentType = src->content.decoded.type;\n    if(ctx->useReversible) {\n        /* REVERSIBLE */\n        ret |= writeJsonKey(ctx, UA_JSONKEY_TYPEID);\n        ret |= ENCODE_DIRECT_JSON(&typeId, NodeId);\n\n        /* Encode the content */\n        ret |= writeJsonKey(ctx, UA_JSONKEY_BODY);\n        ret |= encodeJsonInternal(src->content.decoded.data, contentType, ctx);\n    } else {\n        /* NON-REVERSIBLE\n         * For the non-reversible form, ExtensionObject values \n         * shall be encoded as a JSON object containing only the \n         * value of the Body field. The TypeId and Encoding fields are dropped.\n         * \n         * TODO: UA_JSONKEY_BODY key in the ExtensionObject?\n         */\n        ret |= writeJsonKey(ctx, UA_JSONKEY_BODY);\n        ret |= encodeJsonInternal(src->content.decoded.data, contentType, ctx);\n    }\n\n    ret |= writeJsonObjEnd(ctx);\n    return ret;\n}\n\nstatic status\nVariant_encodeJsonWrapExtensionObject(const UA_Variant *src, const bool isArray, CtxJson *ctx) {\n    size_t length = 1;\n\n    status ret = UA_STATUSCODE_GOOD;\n    if(isArray) {\n        if(src->arrayLength > UA_INT32_MAX)\n            return UA_STATUSCODE_BADENCODINGERROR;\n        \n        length = src->arrayLength;\n    }\n\n    /* Set up the ExtensionObject */\n    UA_ExtensionObject eo;\n    UA_ExtensionObject_init(&eo);\n    eo.encoding = UA_EXTENSIONOBJECT_DECODED;\n    eo.content.decoded.type = src->type;\n    const u16 memSize = src->type->memSize;\n    uintptr_t ptr = (uintptr_t) src->data;\n\n    if(isArray) {\n        ret |= writeJsonArrStart(ctx);\n        ctx->commaNeeded[ctx->depth] = false;\n\n        /* Iterate over the array */\n        for(size_t i = 0; i <  length && ret == UA_STATUSCODE_GOOD; ++i) {\n            eo.content.decoded.data = (void*) ptr;\n            ret |= writeJsonArrElm(ctx, &eo, &UA_TYPES[UA_TYPES_EXTENSIONOBJECT]);\n            ptr += memSize;\n        }\n    \n        ret |= writeJsonArrEnd(ctx);\n        return ret;\n    }\n\n    eo.content.decoded.data = (void*) ptr;\n    return encodeJsonInternal(&eo, &UA_TYPES[UA_TYPES_EXTENSIONOBJECT], ctx);\n}\n\nstatic status\naddMultiArrayContentJSON(CtxJson *ctx, void* array, const UA_DataType *type, \n                         size_t *index, UA_UInt32 *arrayDimensions, size_t dimensionIndex, \n                         size_t dimensionSize) {\n    /* Check the recursion limit */\n    if(ctx->depth >= UA_JSON_ENCODING_MAX_RECURSION)\n        return UA_STATUSCODE_BADENCODINGERROR;\n    \n    /* Stop recursion: The inner Arrays are written */\n    status ret;\n    if(dimensionIndex == (dimensionSize - 1)) {\n        ret = encodeJsonArray(ctx, ((u8*)array) + (type->memSize * *index),\n                              arrayDimensions[dimensionIndex], type);\n        (*index) += arrayDimensions[dimensionIndex];\n        return ret;\n    }\n\n    /* Recurse to the next dimension */\n    ret = writeJsonArrStart(ctx);\n    for(size_t i = 0; i < arrayDimensions[dimensionIndex]; i++) {\n        ret |= writeJsonCommaIfNeeded(ctx);\n        ret |= addMultiArrayContentJSON(ctx, array, type, index, arrayDimensions,\n                                        dimensionIndex + 1, dimensionSize);\n        ctx->commaNeeded[ctx->depth] = true;\n        if(ret != UA_STATUSCODE_GOOD)\n            return ret;\n    }\n    ret |= writeJsonArrEnd(ctx);\n    return ret;\n}\n\nENCODE_JSON(Variant) {\n    /* If type is 0 (NULL) the Variant contains a NULL value and the containing\n     * JSON object shall be omitted or replaced by the JSON literal \u2018null\u2019 (when\n     * an element of a JSON array). */\n    if(!src->type) {\n        return writeJsonNull(ctx);\n    }\n        \n    /* Set the content type in the encoding mask */\n    const UA_Boolean isBuiltin = (src->type->typeKind <= UA_DATATYPEKIND_DIAGNOSTICINFO);\n    const UA_Boolean isEnum = (src->type->typeKind == UA_DATATYPEKIND_ENUM);\n    \n    /* Set the array type in the encoding mask */\n    const bool isArray = src->arrayLength > 0 || src->data <= UA_EMPTY_ARRAY_SENTINEL;\n    const bool hasDimensions = isArray && src->arrayDimensionsSize > 0;\n    status ret = UA_STATUSCODE_GOOD;\n    \n    if(ctx->useReversible) {\n        ret |= writeJsonObjStart(ctx);\n        if(ret != UA_STATUSCODE_GOOD)\n            return ret;\n\n        /* Encode the content */\n        if(!isBuiltin && !isEnum) {\n            /* REVERSIBLE:  NOT BUILTIN, can it be encoded? Wrap in extension object.*/\n            ret |= writeJsonKey(ctx, UA_JSONKEY_TYPE);\n            ret |= ENCODE_DIRECT_JSON(&UA_TYPES[UA_TYPES_EXTENSIONOBJECT].typeId.identifier.numeric, UInt32);\n            ret |= writeJsonKey(ctx, UA_JSONKEY_BODY);\n            ret |= Variant_encodeJsonWrapExtensionObject(src, isArray, ctx);\n        } else if(!isArray) {\n            /*REVERSIBLE:  BUILTIN, single value.*/\n            ret |= writeJsonKey(ctx, UA_JSONKEY_TYPE);\n            ret |= ENCODE_DIRECT_JSON(&src->type->typeId.identifier.numeric, UInt32);\n            ret |= writeJsonKey(ctx, UA_JSONKEY_BODY);\n            ret |= encodeJsonInternal(src->data, src->type, ctx);\n        } else {\n            /*REVERSIBLE:   BUILTIN, array.*/\n            ret |= writeJsonKey(ctx, UA_JSONKEY_TYPE);\n            ret |= ENCODE_DIRECT_JSON(&src->type->typeId.identifier.numeric, UInt32);\n            ret |= writeJsonKey(ctx, UA_JSONKEY_BODY);\n            ret |= encodeJsonArray(ctx, src->data, src->arrayLength, src->type);\n        }\n        \n        if(ret != UA_STATUSCODE_GOOD)\n            return ret;\n        \n        /* REVERSIBLE:  Encode the array dimensions */\n        if(hasDimensions && ret == UA_STATUSCODE_GOOD) {\n            ret |= writeJsonKey(ctx, UA_JSONKEY_DIMENSION);\n            ret |= encodeJsonArray(ctx, src->arrayDimensions, src->arrayDimensionsSize, \n                                   &UA_TYPES[UA_TYPES_INT32]);\n            if(ret != UA_STATUSCODE_GOOD)\n                return ret;\n        }\n\n        ret |= writeJsonObjEnd(ctx);\n        return ret;\n    } /* reversible */\n\n    \n    /* NON-REVERSIBLE\n     * For the non-reversible form, Variant values shall be encoded as a JSON object containing only\n     * the value of the Body field. The Type and Dimensions fields are dropped. Multi-dimensional\n     * arrays are encoded as a multi dimensional JSON array as described in 5.4.5.\n     */\n\n    ret |= writeJsonObjStart(ctx);\n    if(!isBuiltin && !isEnum) {\n        /*NON REVERSIBLE:  NOT BUILTIN, can it be encoded? Wrap in extension object.*/\n        if(src->arrayDimensionsSize > 1) {\n            return UA_STATUSCODE_BADNOTIMPLEMENTED;\n        }\n\n        ret |= writeJsonKey(ctx, UA_JSONKEY_BODY);\n        ret |= Variant_encodeJsonWrapExtensionObject(src, isArray, ctx);\n    } else if(!isArray) {\n        /*NON REVERSIBLE:   BUILTIN, single value.*/\n        ret |= writeJsonKey(ctx, UA_JSONKEY_BODY);\n        ret |= encodeJsonInternal(src->data, src->type, ctx);\n    } else {\n        /*NON REVERSIBLE:   BUILTIN, array.*/\n        ret |= writeJsonKey(ctx, UA_JSONKEY_BODY);\n\n        size_t dimensionSize = src->arrayDimensionsSize;\n        if(dimensionSize > 1) {\n            /*nonreversible multidimensional array*/\n            size_t index = 0;  size_t dimensionIndex = 0;\n            void *ptr = src->data;\n            const UA_DataType *arraytype = src->type;\n            ret |= addMultiArrayContentJSON(ctx, ptr, arraytype, &index, \n                    src->arrayDimensions, dimensionIndex, dimensionSize);\n        } else {\n            /*nonreversible simple array*/\n            ret |= encodeJsonArray(ctx, src->data, src->arrayLength, src->type);\n        }\n    }\n\n    ret |= writeJsonObjEnd(ctx);\n    return ret;\n}\n\n/* DataValue */\nENCODE_JSON(DataValue) {\n    UA_Boolean hasValue = src->hasValue && src->value.type != NULL;\n    UA_Boolean hasStatus = src->hasStatus && src->status;\n    UA_Boolean hasSourceTimestamp = src->hasSourceTimestamp && src->sourceTimestamp;\n    UA_Boolean hasSourcePicoseconds = src->hasSourcePicoseconds && src->sourcePicoseconds;\n    UA_Boolean hasServerTimestamp = src->hasServerTimestamp && src->serverTimestamp;\n    UA_Boolean hasServerPicoseconds = src->hasServerPicoseconds && src->serverPicoseconds;\n\n    if(!hasValue && !hasStatus && !hasSourceTimestamp && !hasSourcePicoseconds &&\n       !hasServerTimestamp && !hasServerPicoseconds) {\n        return writeJsonNull(ctx); /*no element, encode as null*/\n    }\n\n    status ret = UA_STATUSCODE_GOOD;\n    ret |= writeJsonObjStart(ctx);\n\n    if(hasValue) {\n        ret |= writeJsonKey(ctx, UA_JSONKEY_VALUE);\n        ret |= ENCODE_DIRECT_JSON(&src->value, Variant);\n        if(ret != UA_STATUSCODE_GOOD)\n            return ret;\n    }\n\n    if(hasStatus) {\n        ret |= writeJsonKey(ctx, UA_JSONKEY_STATUS);\n        ret |= ENCODE_DIRECT_JSON(&src->status, StatusCode);\n        if(ret != UA_STATUSCODE_GOOD)\n            return ret;\n    }\n\n    if(hasSourceTimestamp) {\n        ret |= writeJsonKey(ctx, UA_JSONKEY_SOURCETIMESTAMP);\n        ret |= ENCODE_DIRECT_JSON(&src->sourceTimestamp, DateTime);\n        if(ret != UA_STATUSCODE_GOOD)\n            return ret;\n    }\n\n    if(hasSourcePicoseconds) {\n        ret |= writeJsonKey(ctx, UA_JSONKEY_SOURCEPICOSECONDS);\n        ret |= ENCODE_DIRECT_JSON(&src->sourcePicoseconds, UInt16);\n        if(ret != UA_STATUSCODE_GOOD)\n            return ret;\n    }\n\n    if(hasServerTimestamp) {\n        ret |= writeJsonKey(ctx, UA_JSONKEY_SERVERTIMESTAMP);\n        ret |= ENCODE_DIRECT_JSON(&src->serverTimestamp, DateTime);\n        if(ret != UA_STATUSCODE_GOOD)\n            return ret;\n    }\n\n    if(hasServerPicoseconds) {\n        ret |= writeJsonKey(ctx, UA_JSONKEY_SERVERPICOSECONDS);\n        ret |= ENCODE_DIRECT_JSON(&src->serverPicoseconds, UInt16);\n        if(ret != UA_STATUSCODE_GOOD)\n            return ret;\n    }\n\n    ret |= writeJsonObjEnd(ctx);\n    return ret;\n}\n\n/* DiagnosticInfo */\nENCODE_JSON(DiagnosticInfo) {\n    status ret = UA_STATUSCODE_GOOD;\n    if(!src->hasSymbolicId && !src->hasNamespaceUri && !src->hasLocalizedText &&\n       !src->hasLocale && !src->hasAdditionalInfo && !src->hasInnerDiagnosticInfo &&\n       !src->hasInnerStatusCode) {\n        return writeJsonNull(ctx); /*no element present, encode as null.*/\n    }\n    \n    ret |= writeJsonObjStart(ctx);\n    \n    if(src->hasSymbolicId) {\n        ret |= writeJsonKey(ctx, UA_JSONKEY_SYMBOLICID);\n        ret |= ENCODE_DIRECT_JSON(&src->symbolicId, UInt32);\n        if(ret != UA_STATUSCODE_GOOD)\n            return ret;\n    }\n\n    if(src->hasNamespaceUri) {\n        ret |= writeJsonKey(ctx, UA_JSONKEY_NAMESPACEURI);\n        ret |= ENCODE_DIRECT_JSON(&src->namespaceUri, UInt32);\n        if(ret != UA_STATUSCODE_GOOD)\n            return ret;\n    }\n    \n    if(src->hasLocalizedText) {\n        ret |= writeJsonKey(ctx, UA_JSONKEY_LOCALIZEDTEXT);\n        ret |= ENCODE_DIRECT_JSON(&src->localizedText, UInt32);\n        if(ret != UA_STATUSCODE_GOOD)\n            return ret;\n    }\n    \n    if(src->hasLocale) {\n        ret |= writeJsonKey(ctx, UA_JSONKEY_LOCALE);\n        ret |= ENCODE_DIRECT_JSON(&src->locale, UInt32);\n        if(ret != UA_STATUSCODE_GOOD)\n            return ret;\n    }\n    \n    if(src->hasAdditionalInfo) {\n        ret |= writeJsonKey(ctx, UA_JSONKEY_ADDITIONALINFO);\n        ret |= ENCODE_DIRECT_JSON(&src->additionalInfo, String);\n        if(ret != UA_STATUSCODE_GOOD)\n            return ret;\n    }\n\n    if(src->hasInnerStatusCode) {\n        ret |= writeJsonKey(ctx, UA_JSONKEY_INNERSTATUSCODE);\n        ret |= ENCODE_DIRECT_JSON(&src->innerStatusCode, StatusCode);\n        if(ret != UA_STATUSCODE_GOOD)\n            return ret;\n    }\n\n    if(src->hasInnerDiagnosticInfo && src->innerDiagnosticInfo) {\n        ret |= writeJsonKey(ctx, UA_JSONKEY_INNERDIAGNOSTICINFO);\n        /* Check recursion depth in encodeJsonInternal */\n        ret |= encodeJsonInternal(src->innerDiagnosticInfo, &UA_TYPES[UA_TYPES_DIAGNOSTICINFO], ctx);\n        if(ret != UA_STATUSCODE_GOOD)\n            return ret;\n    }\n\n    ret |= writeJsonObjEnd(ctx);\n    return ret;\n}\n\nstatic status\nencodeJsonStructure(const void *src, const UA_DataType *type, CtxJson *ctx) {\n    /* Check the recursion limit */\n    if(ctx->depth >= UA_JSON_ENCODING_MAX_RECURSION)\n        return UA_STATUSCODE_BADENCODINGERROR;\n    ctx->depth++;\n\n    status ret = writeJsonObjStart(ctx);\n\n    uintptr_t ptr = (uintptr_t) src;\n    u8 membersSize = type->membersSize;\n    const UA_DataType * typelists[2] = {UA_TYPES, &type[-type->typeIndex]};\n    for(size_t i = 0; i < membersSize && ret == UA_STATUSCODE_GOOD; ++i) {\n        const UA_DataTypeMember *m = &type->members[i];\n        const UA_DataType *mt = &typelists[!m->namespaceZero][m->memberTypeIndex];\n\n        if(m->memberName != NULL && *m->memberName != 0)\n            ret |= writeJsonKey(ctx, m->memberName);\n\n        if(!m->isArray) {\n            ptr += m->padding;\n            size_t memSize = mt->memSize;\n            ret |= encodeJsonJumpTable[mt->typeKind]((const void*) ptr, mt, ctx);\n            ptr += memSize;\n        } else {\n            ptr += m->padding;\n            const size_t length = *((const size_t*) ptr);\n            ptr += sizeof (size_t);\n            ret |= encodeJsonArray(ctx, *(void * const *)ptr, length, mt);\n            ptr += sizeof (void*);\n        }\n    }\n\n    ret |= writeJsonObjEnd(ctx);\n\n    ctx->depth--;\n    return ret;\n}\n\nstatic status\nencodeJsonNotImplemented(const void *src, const UA_DataType *type, CtxJson *ctx) {\n    (void) src, (void) type, (void)ctx;\n    return UA_STATUSCODE_BADNOTIMPLEMENTED;\n}\n\nconst encodeJsonSignature encodeJsonJumpTable[UA_DATATYPEKINDS] = {\n    (encodeJsonSignature)Boolean_encodeJson,\n    (encodeJsonSignature)SByte_encodeJson, /* SByte */\n    (encodeJsonSignature)Byte_encodeJson,\n    (encodeJsonSignature)Int16_encodeJson, /* Int16 */\n    (encodeJsonSignature)UInt16_encodeJson,\n    (encodeJsonSignature)Int32_encodeJson, /* Int32 */\n    (encodeJsonSignature)UInt32_encodeJson,\n    (encodeJsonSignature)Int64_encodeJson, /* Int64 */\n    (encodeJsonSignature)UInt64_encodeJson,\n    (encodeJsonSignature)Float_encodeJson,\n    (encodeJsonSignature)Double_encodeJson,\n    (encodeJsonSignature)String_encodeJson,\n    (encodeJsonSignature)DateTime_encodeJson, /* DateTime */\n    (encodeJsonSignature)Guid_encodeJson,\n    (encodeJsonSignature)ByteString_encodeJson, /* ByteString */\n    (encodeJsonSignature)String_encodeJson, /* XmlElement */\n    (encodeJsonSignature)NodeId_encodeJson,\n    (encodeJsonSignature)ExpandedNodeId_encodeJson,\n    (encodeJsonSignature)StatusCode_encodeJson, /* StatusCode */\n    (encodeJsonSignature)QualifiedName_encodeJson, /* QualifiedName */\n    (encodeJsonSignature)LocalizedText_encodeJson,\n    (encodeJsonSignature)ExtensionObject_encodeJson,\n    (encodeJsonSignature)DataValue_encodeJson,\n    (encodeJsonSignature)Variant_encodeJson,\n    (encodeJsonSignature)DiagnosticInfo_encodeJson,\n    (encodeJsonSignature)encodeJsonNotImplemented, /* Decimal */\n    (encodeJsonSignature)Int32_encodeJson, /* Enum */\n    (encodeJsonSignature)encodeJsonStructure,\n    (encodeJsonSignature)encodeJsonNotImplemented, /* Structure with optional fields */\n    (encodeJsonSignature)encodeJsonNotImplemented, /* Union */\n    (encodeJsonSignature)encodeJsonNotImplemented /* BitfieldCluster */\n};\n\nstatus\nencodeJsonInternal(const void *src, const UA_DataType *type, CtxJson *ctx) {\n    return encodeJsonJumpTable[type->typeKind](src, type, ctx);\n}\n\nstatus UA_FUNC_ATTR_WARN_UNUSED_RESULT\nUA_encodeJson(const void *src, const UA_DataType *type,\n              u8 **bufPos, const u8 **bufEnd, UA_String *namespaces, \n              size_t namespaceSize, UA_String *serverUris, \n              size_t serverUriSize, UA_Boolean useReversible) {\n    if(!src || !type)\n        return UA_STATUSCODE_BADINTERNALERROR;\n    \n    /* Set up the context */\n    CtxJson ctx;\n    memset(&ctx, 0, sizeof(ctx));\n    ctx.pos = *bufPos;\n    ctx.end = *bufEnd;\n    ctx.depth = 0;\n    ctx.namespaces = namespaces;\n    ctx.namespacesSize = namespaceSize;\n    ctx.serverUris = serverUris;\n    ctx.serverUrisSize = serverUriSize;\n    ctx.useReversible = useReversible;\n    ctx.calcOnly = false;\n    \n    /* Encode */\n    status ret = encodeJsonJumpTable[type->typeKind](src, type, &ctx);\n    \n    *bufPos = ctx.pos;\n    *bufEnd = ctx.end;\n    return ret;\n}\n\n/************/\n/* CalcSize */\n/************/\nsize_t\nUA_calcSizeJson(const void *src, const UA_DataType *type,\n                UA_String *namespaces, size_t namespaceSize,\n                UA_String *serverUris, size_t serverUriSize,\n                UA_Boolean useReversible) {\n    if(!src || !type)\n        return UA_STATUSCODE_BADINTERNALERROR;\n\n    /* Set up the context */\n    CtxJson ctx;\n    memset(&ctx, 0, sizeof(ctx));\n    ctx.pos = 0;\n    ctx.end = (const UA_Byte*)(uintptr_t)SIZE_MAX;\n    ctx.depth = 0;\n    ctx.namespaces = namespaces;\n    ctx.namespacesSize = namespaceSize;\n    ctx.serverUris = serverUris;\n    ctx.serverUrisSize = serverUriSize;\n    ctx.useReversible = useReversible;\n    ctx.calcOnly = true;\n\n    /* Encode */\n    status ret = encodeJsonJumpTable[type->typeKind](src, type, &ctx);\n    if(ret != UA_STATUSCODE_GOOD)\n        return 0;\n    return (size_t)ctx.pos;\n}\n\n/**********/\n/* Decode */\n/**********/\n\n/* Macro which gets current size and char pointer of current Token. Needs\n * ParseCtx (parseCtx) and CtxJson (ctx). Does NOT increment index of Token. */\n#define GET_TOKEN(data, size) do {                                               \\\n    (size) = (size_t)(parseCtx->tokenArray[parseCtx->index].end - parseCtx->tokenArray[parseCtx->index].start); \\\n    (data) = (char*)(ctx->pos + parseCtx->tokenArray[parseCtx->index].start); } while(0)\n\n#define ALLOW_NULL do {             \\\n    if(isJsonNull(ctx, parseCtx)) { \\\n        parseCtx->index++;          \\\n        return UA_STATUSCODE_GOOD;  \\\n    }} while(0)\n\n#define CHECK_TOKEN_BOUNDS do {                   \\\n    if(parseCtx->index >= parseCtx->tokenCount)   \\\n        return UA_STATUSCODE_BADDECODINGERROR;    \\\n    } while(0)\n\n#define CHECK_PRIMITIVE do {                      \\\n    if(getJsmnType(parseCtx) != JSMN_PRIMITIVE) { \\\n        return UA_STATUSCODE_BADDECODINGERROR;    \\\n    }} while(0)\n\n#define CHECK_STRING do {                      \\\n    if(getJsmnType(parseCtx) != JSMN_STRING) { \\\n        return UA_STATUSCODE_BADDECODINGERROR; \\\n    }} while(0)\n\n#define CHECK_OBJECT do {                      \\\n    if(getJsmnType(parseCtx) != JSMN_OBJECT) { \\\n        return UA_STATUSCODE_BADDECODINGERROR; \\\n    }} while(0)\n\n/* Forward declarations*/\n#define DECODE_JSON(TYPE) static status                        \\\n    TYPE##_decodeJson(UA_##TYPE *dst, const UA_DataType *type, \\\n                      CtxJson *ctx, ParseCtx *parseCtx, UA_Boolean moveToken)\n\n/* decode without moving the token index */\n#define DECODE_DIRECT_JSON(DST, TYPE) TYPE##_decodeJson((UA_##TYPE*)DST, NULL, ctx, parseCtx, false)\n\n/* If parseCtx->index points to the beginning of an object, move the index to\n * the next token after this object. Attention! The index can be moved after the\n * last parsed token. So the array length has to be checked afterwards. */\nstatic void\nskipObject(ParseCtx *parseCtx) {\n    int end = parseCtx->tokenArray[parseCtx->index].end;\n    do {\n        parseCtx->index++;\n    } while(parseCtx->index < parseCtx->tokenCount &&\n            parseCtx->tokenArray[parseCtx->index].start < end);\n}\n\nstatic status\nArray_decodeJson(void *dst, const UA_DataType *type, CtxJson *ctx, \n        ParseCtx *parseCtx, UA_Boolean moveToken);\n\nstatic status\nArray_decodeJson_internal(void **dst, const UA_DataType *type, \n        CtxJson *ctx, ParseCtx *parseCtx, UA_Boolean moveToken);\n\nstatic status\nVariant_decodeJsonUnwrapExtensionObject(UA_Variant *dst, const UA_DataType *type, \n        CtxJson *ctx, ParseCtx *parseCtx, UA_Boolean moveToken);\n\n/* Json decode Helper */\njsmntype_t\ngetJsmnType(const ParseCtx *parseCtx) {\n    if(parseCtx->index >= parseCtx->tokenCount)\n        return JSMN_UNDEFINED;\n    return parseCtx->tokenArray[parseCtx->index].type;\n}\n\nUA_Boolean\nisJsonNull(const CtxJson *ctx, const ParseCtx *parseCtx) {\n    if(parseCtx->index >= parseCtx->tokenCount)\n        return false;\n\n    if(parseCtx->tokenArray[parseCtx->index].type != JSMN_PRIMITIVE) {\n        return false;\n    }\n    char* elem = (char*)(ctx->pos + parseCtx->tokenArray[parseCtx->index].start);\n    return (elem[0] == 'n' && elem[1] == 'u' && elem[2] == 'l' && elem[3] == 'l');\n}\n\nstatic UA_SByte jsoneq(const char *json, jsmntok_t *tok, const char *searchKey) {\n    /* TODO: necessary?\n       if(json == NULL\n            || tok == NULL \n            || searchKey == NULL) {\n        return -1;\n    } */\n    \n    if(tok->type == JSMN_STRING) {\n         if(strlen(searchKey) == (size_t)(tok->end - tok->start) ) {\n             if(strncmp(json + tok->start,\n                        (const char*)searchKey, (size_t)(tok->end - tok->start)) == 0) {\n                 return 0;\n             }   \n         }\n    }\n    return -1;\n}\n\nDECODE_JSON(Boolean) {\n    CHECK_PRIMITIVE;\n    CHECK_TOKEN_BOUNDS;\n    size_t tokenSize;\n    char* tokenData;\n    GET_TOKEN(tokenData, tokenSize);\n\n    if(tokenSize == 4 &&\n       tokenData[0] == 't' && tokenData[1] == 'r' &&\n       tokenData[2] == 'u' && tokenData[3] == 'e') {\n        *dst = true;\n    } else if(tokenSize == 5 &&\n              tokenData[0] == 'f' && tokenData[1] == 'a' &&\n              tokenData[2] == 'l' && tokenData[3] == 's' &&\n              tokenData[4] == 'e') {\n        *dst = false;\n    } else {\n        return UA_STATUSCODE_BADDECODINGERROR;\n    }\n    \n    if(moveToken)\n        parseCtx->index++;\n    return UA_STATUSCODE_GOOD;\n}\n\n#ifdef UA_ENABLE_CUSTOM_LIBC\nstatic UA_StatusCode\nparseUnsignedInteger(char* inputBuffer, size_t sizeOfBuffer,\n                     UA_UInt64 *destinationOfNumber) {\n    UA_UInt64 d = 0;\n    atoiUnsigned(inputBuffer, sizeOfBuffer, &d);\n    if(!destinationOfNumber)\n        return UA_STATUSCODE_BADDECODINGERROR;\n    *destinationOfNumber = d;\n    return UA_STATUSCODE_GOOD;\n}\n\nstatic UA_StatusCode\nparseSignedInteger(char* inputBuffer, size_t sizeOfBuffer,\n                   UA_Int64 *destinationOfNumber) {\n    UA_Int64 d = 0;\n    atoiSigned(inputBuffer, sizeOfBuffer, &d);\n    if(!destinationOfNumber)\n        return UA_STATUSCODE_BADDECODINGERROR;\n    *destinationOfNumber = d;\n    return UA_STATUSCODE_GOOD;\n}\n#else\n/* Safe strtol variant of unsigned string conversion.\n * Returns UA_STATUSCODE_BADDECODINGERROR in case of overflows.\n * Buffer limit is 20 digits. */\nstatic UA_StatusCode\nparseUnsignedInteger(char* inputBuffer, size_t sizeOfBuffer,\n                     UA_UInt64 *destinationOfNumber) {\n    /* Check size to avoid huge malicious stack allocation.\n     * No UInt64 can have more digits than 20. */\n    if(sizeOfBuffer > 20) {\n        return UA_STATUSCODE_BADDECODINGERROR;\n    }\n\n    /* convert to null terminated string  */\n    UA_STACKARRAY(char, string, sizeOfBuffer+1);\n    memcpy(string, inputBuffer, sizeOfBuffer);\n    string[sizeOfBuffer] = 0;\n\n    /* Conversion */\n    char *endptr, *str;\n    str = string;\n    errno = 0;    /* To distinguish success/failure after call */\n    UA_UInt64 val = strtoull(str, &endptr, 10);\n\n    /* Check for various possible errors */\n    if((errno == ERANGE && (val == LLONG_MAX || val == 0))\n          || (errno != 0 )) {\n        return UA_STATUSCODE_BADDECODINGERROR;\n    }\n\n    /* Check if no digits were found */\n    if(endptr == str)\n        return UA_STATUSCODE_BADDECODINGERROR;\n\n    /* copy to destination */\n    *destinationOfNumber = val;\n    return UA_STATUSCODE_GOOD;\n}\n\n/* Safe strtol variant of unsigned string conversion.\n * Returns UA_STATUSCODE_BADDECODINGERROR in case of overflows.\n * Buffer limit is 20 digits. */\nstatic UA_StatusCode\nparseSignedInteger(char* inputBuffer, size_t sizeOfBuffer,\n                   UA_Int64 *destinationOfNumber) {\n    /* Check size to avoid huge malicious stack allocation.\n     * No UInt64 can have more digits than 20. */\n    if(sizeOfBuffer > 20)\n        return UA_STATUSCODE_BADDECODINGERROR;\n\n    /* convert to null terminated string  */\n    UA_STACKARRAY(char, string, sizeOfBuffer + 1);\n    memcpy(string, inputBuffer, sizeOfBuffer);\n    string[sizeOfBuffer] = 0;\n\n    /* Conversion */\n    char *endptr, *str;\n    str = string;\n    errno = 0;    /* To distinguish success/failure after call */\n    UA_Int64 val = strtoll(str, &endptr, 10);\n\n    /* Check for various possible errors */\n    if((errno == ERANGE && (val == LONG_MAX || val == LONG_MIN))\n          || (errno != 0 )) {\n        return UA_STATUSCODE_BADDECODINGERROR;\n    }\n\n    /* Check if no digits were found */\n    if(endptr == str)\n        return UA_STATUSCODE_BADDECODINGERROR;\n\n    /* copy to destination */\n    *destinationOfNumber = val;\n    return UA_STATUSCODE_GOOD;\n}\n#endif\n\nDECODE_JSON(Byte) {\n    CHECK_TOKEN_BOUNDS;\n    CHECK_PRIMITIVE;\n    size_t tokenSize;\n    char* tokenData;\n    GET_TOKEN(tokenData, tokenSize);\n\n    UA_UInt64 out = 0;\n    UA_StatusCode s = parseUnsignedInteger(tokenData, tokenSize, &out);\n    *dst = (UA_Byte)out;\n\n    if(moveToken)\n        parseCtx->index++;\n    return s;\n}\n\nDECODE_JSON(UInt16) {\n    CHECK_TOKEN_BOUNDS;\n    CHECK_PRIMITIVE;\n    size_t tokenSize;\n    char* tokenData;\n    GET_TOKEN(tokenData, tokenSize);\n\n    UA_UInt64 out = 0;\n    UA_StatusCode s = parseUnsignedInteger(tokenData, tokenSize, &out);\n    *dst = (UA_UInt16)out;\n\n    if(moveToken)\n        parseCtx->index++;\n    return s;\n}\n\nDECODE_JSON(UInt32) {\n    CHECK_TOKEN_BOUNDS;\n    CHECK_PRIMITIVE;\n    size_t tokenSize;\n    char* tokenData;\n    GET_TOKEN(tokenData, tokenSize);\n\n    UA_UInt64 out = 0;\n    UA_StatusCode s = parseUnsignedInteger(tokenData, tokenSize, &out);\n    *dst = (UA_UInt32)out;\n\n    if(moveToken)\n        parseCtx->index++;\n    return s;\n}\n\nDECODE_JSON(UInt64) {\n    CHECK_TOKEN_BOUNDS;\n    CHECK_STRING;\n    size_t tokenSize;\n    char* tokenData;\n    GET_TOKEN(tokenData, tokenSize);\n\n    UA_UInt64 out = 0;\n    UA_StatusCode s = parseUnsignedInteger(tokenData, tokenSize, &out);\n    *dst = (UA_UInt64)out;\n\n    if(moveToken)\n        parseCtx->index++;\n    return s;\n}\n\nDECODE_JSON(SByte) {\n    CHECK_TOKEN_BOUNDS;\n    CHECK_PRIMITIVE;\n    size_t tokenSize;\n    char* tokenData;\n    GET_TOKEN(tokenData, tokenSize);\n\n    UA_Int64 out = 0;\n    UA_StatusCode s = parseSignedInteger(tokenData, tokenSize, &out);\n    *dst = (UA_SByte)out;\n\n    if(moveToken)\n        parseCtx->index++;\n    return s;\n}\n\nDECODE_JSON(Int16) {\n    CHECK_TOKEN_BOUNDS;\n    CHECK_PRIMITIVE;\n    size_t tokenSize;\n    char* tokenData;\n    GET_TOKEN(tokenData, tokenSize);\n\n    UA_Int64 out = 0;\n    UA_StatusCode s = parseSignedInteger(tokenData, tokenSize, &out);\n    *dst = (UA_Int16)out;\n\n    if(moveToken)\n        parseCtx->index++;\n    return s;\n}\n\nDECODE_JSON(Int32) {\n    CHECK_TOKEN_BOUNDS;\n    CHECK_PRIMITIVE;\n    size_t tokenSize;\n    char* tokenData;\n    GET_TOKEN(tokenData, tokenSize);\n\n    UA_Int64 out = 0;\n    UA_StatusCode s = parseSignedInteger(tokenData, tokenSize, &out);\n    *dst = (UA_Int32)out;\n\n    if(moveToken)\n        parseCtx->index++;\n    return s;\n}\n\nDECODE_JSON(Int64) {\n    CHECK_TOKEN_BOUNDS;\n    CHECK_STRING;\n    size_t tokenSize;\n    char* tokenData;\n    GET_TOKEN(tokenData, tokenSize);\n\n    UA_Int64 out = 0;\n    UA_StatusCode s = parseSignedInteger(tokenData, tokenSize, &out);\n    *dst = (UA_Int64)out;\n\n    if(moveToken)\n        parseCtx->index++;\n    return s;\n}\n\nstatic UA_UInt32 hex2int(char ch) {\n    if(ch >= '0' && ch <= '9')\n        return (UA_UInt32)(ch - '0');\n    if(ch >= 'A' && ch <= 'F')\n        return (UA_UInt32)(ch - 'A' + 10);\n    if(ch >= 'a' && ch <= 'f')\n        return (UA_UInt32)(ch - 'a' + 10);\n    return 0;\n}\n\n/* Float\n* Either a JSMN_STRING or JSMN_PRIMITIVE\n*/\nDECODE_JSON(Float) {\n    CHECK_TOKEN_BOUNDS;\n    size_t tokenSize;\n    char* tokenData;\n    GET_TOKEN(tokenData, tokenSize);\n    \n    /* https://www.exploringbinary.com/maximum-number-of-decimal-digits-in-binary-floating-point-numbers/\n     * Maximum digit counts for select IEEE floating-point formats: 149\n     * Sanity check. */\n    if(tokenSize > 150)\n        return UA_STATUSCODE_BADDECODINGERROR;\n\n    jsmntype_t tokenType = getJsmnType(parseCtx);\n    if(tokenType == JSMN_STRING) {\n        /*It could be a String with Nan, Infinity*/\n        if(tokenSize == 8 && memcmp(tokenData, \"Infinity\", 8) == 0) {\n            *dst = (UA_Float)INFINITY;\n            return UA_STATUSCODE_GOOD;\n        }\n        \n        if(tokenSize == 9 && memcmp(tokenData, \"-Infinity\", 9) == 0) {\n            /* workaround an MSVC 2013 issue */\n            *dst = (UA_Float)-INFINITY;\n            return UA_STATUSCODE_GOOD;\n        }\n        \n        if(tokenSize == 3 && memcmp(tokenData, \"NaN\", 3) == 0) {\n            *dst = (UA_Float)NAN;\n            return UA_STATUSCODE_GOOD;\n        }\n        \n        if(tokenSize == 4 && memcmp(tokenData, \"-NaN\", 4) == 0) {\n            *dst = (UA_Float)NAN;\n            return UA_STATUSCODE_GOOD;\n        }\n        return UA_STATUSCODE_BADDECODINGERROR;\n    }\n    \n    if(tokenType != JSMN_PRIMITIVE)\n        return UA_STATUSCODE_BADDECODINGERROR;\n\n    /* Null-Terminate for sscanf. */\n    UA_STACKARRAY(char, string, tokenSize+1);\n    memcpy(string, tokenData, tokenSize);\n    string[tokenSize] = 0;\n    \n    UA_Float d = 0;\n#ifdef UA_ENABLE_CUSTOM_LIBC\n    d = (UA_Float)__floatscan(string, 1, 0);\n#else\n    char c = 0;\n    /* On success, the function returns the number of variables filled.\n     * In the case of an input failure before any data could be successfully read, EOF is returned. */\n    int ret = sscanf(string, \"%f%c\", &d, &c);\n\n    /* Exactly one var must be filled. %c acts as a guard for wrong input which is accepted by sscanf.\n    E.g. 1.23.45 is not accepted. */\n    if(ret == EOF || (ret != 1))\n        return UA_STATUSCODE_BADDECODINGERROR;\n#endif\n    \n    *dst = d;\n\n    parseCtx->index++;\n    return UA_STATUSCODE_GOOD;\n}\n\n/* Either a JSMN_STRING or JSMN_PRIMITIVE */\nDECODE_JSON(Double) {\n    CHECK_TOKEN_BOUNDS;\n    size_t tokenSize;\n    char* tokenData;\n    GET_TOKEN(tokenData, tokenSize);\n    \n    /* https://www.exploringbinary.com/maximum-number-of-decimal-digits-in-binary-floating-point-numbers/\n     * Maximum digit counts for select IEEE floating-point formats: 1074\n     * Sanity check.\n     */\n    if(tokenSize > 1075)\n        return UA_STATUSCODE_BADDECODINGERROR;\n\n    jsmntype_t tokenType = getJsmnType(parseCtx);\n    if(tokenType == JSMN_STRING) {\n        /*It could be a String with Nan, Infinity*/\n        if(tokenSize == 8 && memcmp(tokenData, \"Infinity\", 8) == 0) {\n            *dst = INFINITY;\n            return UA_STATUSCODE_GOOD;\n        }\n        \n        if(tokenSize == 9 && memcmp(tokenData, \"-Infinity\", 9) == 0) {\n            /* workaround an MSVC 2013 issue */\n            *dst = -INFINITY;\n            return UA_STATUSCODE_GOOD;\n        }\n        \n        if(tokenSize == 3 && memcmp(tokenData, \"NaN\", 3) == 0) {\n            *dst = NAN;\n            return UA_STATUSCODE_GOOD;\n        }\n        \n        if(tokenSize == 4 && memcmp(tokenData, \"-NaN\", 4) == 0) {\n            *dst = NAN;\n            return UA_STATUSCODE_GOOD;\n        }\n        return UA_STATUSCODE_BADDECODINGERROR;\n    }\n    \n    if(tokenType != JSMN_PRIMITIVE)\n        return UA_STATUSCODE_BADDECODINGERROR;\n\n    /* Null-Terminate for sscanf. Should this better be handled on heap? Max\n     * 1075 input chars allowed. Not using heap. */\n    UA_STACKARRAY(char, string, tokenSize+1);\n    memcpy(string, tokenData, tokenSize);\n    string[tokenSize] = 0;\n    \n    UA_Double d = 0;\n#ifdef UA_ENABLE_CUSTOM_LIBC\n    d = (UA_Double)__floatscan(string, 2, 0);\n#else\n    char c = 0;\n    /* On success, the function returns the number of variables filled.\n     * In the case of an input failure before any data could be successfully read, EOF is returned. */\n    int ret = sscanf(string, \"%lf%c\", &d, &c);\n\n    /* Exactly one var must be filled. %c acts as a guard for wrong input which is accepted by sscanf.\n    E.g. 1.23.45 is not accepted. */\n    if(ret == EOF || (ret != 1))\n        return UA_STATUSCODE_BADDECODINGERROR;\n#endif\n    \n    *dst = d;\n\n    parseCtx->index++;\n    return UA_STATUSCODE_GOOD;\n}\n\n/*\n  Expects 36 chars in format    00000003-0009-000A-0807-060504030201\n                                | data1| |d2| |d3| |d4| |  data4   |\n*/\nstatic UA_Guid UA_Guid_fromChars(const char* chars) {\n    UA_Guid dst;\n    UA_Guid_init(&dst);\n    for(size_t i = 0; i < 8; i++)\n        dst.data1 |= (UA_UInt32)(hex2int(chars[i]) << (28 - (i*4)));\n    for(size_t i = 0; i < 4; i++) {\n        dst.data2 |= (UA_UInt16)(hex2int(chars[9+i]) << (12 - (i*4)));\n        dst.data3 |= (UA_UInt16)(hex2int(chars[14+i]) << (12 - (i*4)));\n    }\n    dst.data4[0] |= (UA_Byte)(hex2int(chars[19]) << 4u);\n    dst.data4[0] |= (UA_Byte)(hex2int(chars[20]) << 0u);\n    dst.data4[1] |= (UA_Byte)(hex2int(chars[21]) << 4u);\n    dst.data4[1] |= (UA_Byte)(hex2int(chars[22]) << 0u);\n    for(size_t i = 0; i < 6; i++) {\n        dst.data4[2+i] |= (UA_Byte)(hex2int(chars[24 + i*2]) << 4u);\n        dst.data4[2+i] |= (UA_Byte)(hex2int(chars[25 + i*2]) << 0u);\n    }\n    return dst;\n}\n\nDECODE_JSON(Guid) {\n    CHECK_STRING;\n    CHECK_TOKEN_BOUNDS;\n    size_t tokenSize;\n    char* tokenData;\n    GET_TOKEN(tokenData, tokenSize);\n\n    if(tokenSize != 36)\n        return UA_STATUSCODE_BADDECODINGERROR;\n\n    /* check if incorrect chars are present */\n    for(size_t i = 0; i < tokenSize; i++) {\n        if(!(tokenData[i] == '-'\n                || (tokenData[i] >= '0' && tokenData[i] <= '9')\n                || (tokenData[i] >= 'A' && tokenData[i] <= 'F')\n                || (tokenData[i] >= 'a' && tokenData[i] <= 'f'))) {\n            return UA_STATUSCODE_BADDECODINGERROR;\n        }\n    }\n\n    *dst = UA_Guid_fromChars(tokenData);\n\n    if(moveToken)\n        parseCtx->index++;\n    return UA_STATUSCODE_GOOD;\n}\n\nDECODE_JSON(String) {\n    ALLOW_NULL;\n    CHECK_STRING;\n    CHECK_TOKEN_BOUNDS;\n    size_t tokenSize;\n    char* tokenData;\n    GET_TOKEN(tokenData, tokenSize);\n\n    /* Empty string? */\n    if(tokenSize == 0) {\n        dst->data = (UA_Byte*)UA_EMPTY_ARRAY_SENTINEL;\n        dst->length = 0;\n        if(moveToken)\n            parseCtx->index++;\n        return UA_STATUSCODE_GOOD;\n    }\n    \n    /* The actual value is at most of the same length as the source string:\n     * - Shortcut escapes (e.g. \"\\t\") (length 2) are converted to 1 byte\n     * - A single \\uXXXX escape (length 6) is converted to at most 3 bytes\n     * - Two \\uXXXX escapes (length 12) forming an UTF-16 surrogate pair are\n     *   converted to 4 bytes */\n    char *outputBuffer = (char*)UA_malloc(tokenSize);\n    if(!outputBuffer)\n        return UA_STATUSCODE_BADOUTOFMEMORY;\n    \n    const char *p = (char*)tokenData;\n    const char *end = (char*)&tokenData[tokenSize];\n    char *pos = outputBuffer;\n    while(p < end) {\n        /* No escaping */\n        if(*p != '\\\\') {\n            *(pos++) = *(p++);\n            continue;\n        }\n\n        /* Escape character */\n        p++;\n        if(p == end)\n            goto cleanup;\n        \n        if(*p != 'u') {\n            switch(*p) {\n            case '\"': case '\\\\': case '/': *pos = *p; break;\n            case 'b': *pos = '\\b'; break;\n            case 'f': *pos = '\\f'; break;\n            case 'n': *pos = '\\n'; break;\n            case 'r': *pos = '\\r'; break;\n            case 't': *pos = '\\t'; break;\n            default: goto cleanup;\n            }\n            pos++;\n            p++;\n            continue;\n        }\n            \n        /* Unicode */\n        if(p + 4 >= end)\n            goto cleanup;\n        int32_t value_signed = decode_unicode_escape(p);\n        if(value_signed < 0)\n            goto cleanup;\n        uint32_t value = (uint32_t)value_signed;\n        p += 5;\n\n        if(0xD800 <= value && value <= 0xDBFF) {\n            /* Surrogate pair */\n            if(p + 5 >= end)\n                goto cleanup;\n            if(*p != '\\\\' || *(p + 1) != 'u')\n                goto cleanup;\n            int32_t value2 = decode_unicode_escape(p + 1);\n            if(value2 < 0xDC00 || value2 > 0xDFFF)\n                goto cleanup;\n            value = ((value - 0xD800u) << 10u) + (uint32_t)((value2 - 0xDC00) + 0x10000);\n            p += 6;\n        } else if(0xDC00 <= value && value <= 0xDFFF) {\n            /* Invalid Unicode '\\\\u%04X' */\n            goto cleanup;\n        }\n\n        size_t length;\n        if(utf8_encode((int32_t)value, pos, &length))\n            goto cleanup;\n\n        pos += length;\n    }\n\n    dst->length = (size_t)(pos - outputBuffer);\n    if(dst->length > 0) {\n        dst->data = (UA_Byte*)outputBuffer;\n    } else {\n        dst->data = (UA_Byte*)UA_EMPTY_ARRAY_SENTINEL;\n        UA_free(outputBuffer);\n    }\n\n    if(moveToken)\n        parseCtx->index++;\n    return UA_STATUSCODE_GOOD;\n    \ncleanup:\n    UA_free(outputBuffer);  \n    return UA_STATUSCODE_BADDECODINGERROR;\n}\n\nDECODE_JSON(ByteString) {\n    ALLOW_NULL;\n    CHECK_STRING;\n    CHECK_TOKEN_BOUNDS;\n    size_t tokenSize;\n    char* tokenData;\n    GET_TOKEN(tokenData, tokenSize);\n\n    /* Empty bytestring? */\n    if(tokenSize == 0) {\n        dst->data = (UA_Byte*)UA_EMPTY_ARRAY_SENTINEL;\n        dst->length = 0;\n        return UA_STATUSCODE_GOOD;\n    }\n\n    size_t flen = 0;\n    unsigned char* unB64 = UA_unbase64((unsigned char*)tokenData, tokenSize, &flen);\n    if(unB64 == 0)\n        return UA_STATUSCODE_BADDECODINGERROR;\n\n    dst->data = (u8*)unB64;\n    dst->length = flen;\n    \n    if(moveToken)\n        parseCtx->index++;\n    return UA_STATUSCODE_GOOD;\n}\n\nDECODE_JSON(LocalizedText) {\n    ALLOW_NULL;\n    CHECK_OBJECT;\n\n    DecodeEntry entries[2] = {\n        {UA_JSONKEY_LOCALE, &dst->locale, (decodeJsonSignature) String_decodeJson, false, NULL},\n        {UA_JSONKEY_TEXT, &dst->text, (decodeJsonSignature) String_decodeJson, false, NULL}\n    };\n\n    return decodeFields(ctx, parseCtx, entries, 2, type);\n}\n\nDECODE_JSON(QualifiedName) {\n    ALLOW_NULL;\n    CHECK_OBJECT;\n\n    DecodeEntry entries[2] = {\n        {UA_JSONKEY_NAME, &dst->name, (decodeJsonSignature) String_decodeJson, false, NULL},\n        {UA_JSONKEY_URI, &dst->namespaceIndex, (decodeJsonSignature) UInt16_decodeJson, false, NULL}\n    };\n\n    return decodeFields(ctx, parseCtx, entries, 2, type);\n}\n\n/* Function for searching ahead of the current token. Used for retrieving the\n * OPC UA type of a token */\nstatic status\nsearchObjectForKeyRec(const char *searchKey, CtxJson *ctx, \n                      ParseCtx *parseCtx, size_t *resultIndex, UA_UInt16 depth) {\n    UA_StatusCode ret = UA_STATUSCODE_BADNOTFOUND;\n    \n    CHECK_TOKEN_BOUNDS;\n    \n    if(parseCtx->tokenArray[parseCtx->index].type == JSMN_OBJECT) {\n        size_t objectCount = (size_t)parseCtx->tokenArray[parseCtx->index].size;\n        parseCtx->index++; /*Object to first Key*/\n        \n        for(size_t i = 0; i < objectCount; i++) {\n            CHECK_TOKEN_BOUNDS;\n            if(depth == 0) { /* we search only on first layer */\n                if(jsoneq((char*)ctx->pos, &parseCtx->tokenArray[parseCtx->index], searchKey) == 0) {\n                    /*found*/\n                    parseCtx->index++; /*We give back a pointer to the value of the searched key!*/\n                    if (parseCtx->index >= parseCtx->tokenCount)\n                        /* We got invalid json. See https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=14620 */\n                        return UA_STATUSCODE_BADOUTOFRANGE;\n                    *resultIndex = parseCtx->index;\n                    return UA_STATUSCODE_GOOD;\n                }\n            }\n               \n            parseCtx->index++; /* value */\n            CHECK_TOKEN_BOUNDS;\n            \n            if(parseCtx->tokenArray[parseCtx->index].type == JSMN_OBJECT) {\n               ret = searchObjectForKeyRec(searchKey, ctx, parseCtx, resultIndex,\n                                           (UA_UInt16)(depth + 1));\n            } else if(parseCtx->tokenArray[parseCtx->index].type == JSMN_ARRAY) {\n               ret = searchObjectForKeyRec(searchKey, ctx, parseCtx, resultIndex,\n                                           (UA_UInt16)(depth + 1));\n            } else {\n                /* Only Primitive or string */\n                parseCtx->index++;\n            }\n        }\n    } else if(parseCtx->tokenArray[parseCtx->index].type == JSMN_ARRAY) {\n        size_t arraySize = (size_t)parseCtx->tokenArray[parseCtx->index].size;\n        parseCtx->index++; /*Object to first element*/\n        \n        for(size_t i = 0; i < arraySize; i++) {\n            CHECK_TOKEN_BOUNDS;\n            if(parseCtx->tokenArray[parseCtx->index].type == JSMN_OBJECT) {\n               ret = searchObjectForKeyRec(searchKey, ctx, parseCtx, resultIndex,\n                                           (UA_UInt16)(depth + 1));\n            } else if(parseCtx->tokenArray[parseCtx->index].type == JSMN_ARRAY) {\n               ret = searchObjectForKeyRec(searchKey, ctx, parseCtx, resultIndex,\n                                           (UA_UInt16)(depth + 1));\n            } else {\n                /* Only Primitive or string */\n                parseCtx->index++;\n            }\n        }\n    }\n    return ret;\n}\n\nUA_FUNC_ATTR_WARN_UNUSED_RESULT status\nlookAheadForKey(const char* search, CtxJson *ctx,\n                ParseCtx *parseCtx, size_t *resultIndex) {\n    UA_UInt16 oldIndex = parseCtx->index; /* Save index for later restore */\n    \n    UA_UInt16 depth = 0;\n    UA_StatusCode ret  = searchObjectForKeyRec(search, ctx, parseCtx, resultIndex, depth);\n\n    parseCtx->index = oldIndex; /* Restore index */\n    return ret;\n}\n\n/* Function used to jump over an object which cannot be parsed */\nstatic status\njumpOverRec(CtxJson *ctx, ParseCtx *parseCtx,\n            size_t *resultIndex, UA_UInt16 depth) {\n    UA_StatusCode ret = UA_STATUSCODE_BADDECODINGERROR;\n    CHECK_TOKEN_BOUNDS;\n    \n    if(parseCtx->tokenArray[parseCtx->index].type == JSMN_OBJECT) {\n        size_t objectCount = (size_t)(parseCtx->tokenArray[parseCtx->index].size);\n        \n        parseCtx->index++; /*Object to first Key*/\n        CHECK_TOKEN_BOUNDS;\n        \n        size_t i;\n        for(i = 0; i < objectCount; i++) {\n            CHECK_TOKEN_BOUNDS;\n             \n            parseCtx->index++; /*value*/\n            CHECK_TOKEN_BOUNDS;\n            \n            if(parseCtx->tokenArray[parseCtx->index].type == JSMN_OBJECT) {\n               jumpOverRec(ctx, parseCtx, resultIndex, (UA_UInt16)(depth + 1));\n            } else if(parseCtx->tokenArray[parseCtx->index].type == JSMN_ARRAY) {\n               jumpOverRec(ctx, parseCtx, resultIndex, (UA_UInt16)(depth + 1));\n            } else {\n                /*Only Primitive or string*/\n                parseCtx->index++;\n            }\n        }\n    } else if(parseCtx->tokenArray[parseCtx->index].type == JSMN_ARRAY) {\n        size_t arraySize = (size_t)(parseCtx->tokenArray[parseCtx->index].size);\n        \n        parseCtx->index++; /*Object to first element*/\n        CHECK_TOKEN_BOUNDS;\n        \n        size_t i;\n        for(i = 0; i < arraySize; i++) {\n            if(parseCtx->tokenArray[parseCtx->index].type == JSMN_OBJECT) {\n               jumpOverRec(ctx, parseCtx, resultIndex, (UA_UInt16)(depth + 1));\n            } else if(parseCtx->tokenArray[parseCtx->index].type == JSMN_ARRAY) {\n               jumpOverRec(ctx, parseCtx, resultIndex, (UA_UInt16)(depth + 1));\n            } else {\n                /*Only Primitive or string*/\n                parseCtx->index++;\n            }\n        }\n    }\n    return ret;\n}\n\nstatic status\njumpOverObject(CtxJson *ctx, ParseCtx *parseCtx, size_t *resultIndex) {\n    UA_UInt16 oldIndex = parseCtx->index; /* Save index for later restore */\n    UA_UInt16 depth = 0;\n    jumpOverRec(ctx, parseCtx, resultIndex, depth);\n    *resultIndex = parseCtx->index;\n    parseCtx->index = oldIndex; /* Restore index */\n    return UA_STATUSCODE_GOOD;\n}\n\nstatic status\nprepareDecodeNodeIdJson(UA_NodeId *dst, CtxJson *ctx, ParseCtx *parseCtx, \n                        u8 *fieldCount, DecodeEntry *entries) {\n    /* possible keys: Id, IdType*/\n    /* Id must always be present */\n    entries[*fieldCount].fieldName = UA_JSONKEY_ID;\n    entries[*fieldCount].found = false;\n    entries[*fieldCount].type = NULL;\n    \n    /* IdType */\n    UA_Boolean hasIdType = false;\n    size_t searchResult = 0; \n    status ret = lookAheadForKey(UA_JSONKEY_IDTYPE, ctx, parseCtx, &searchResult);\n    if(ret == UA_STATUSCODE_GOOD) { /*found*/\n         hasIdType = true;\n    }\n    \n    if(hasIdType) {\n        size_t size = (size_t)(parseCtx->tokenArray[searchResult].end -\n                               parseCtx->tokenArray[searchResult].start);\n        if(size < 1) {\n            return UA_STATUSCODE_BADDECODINGERROR;\n        }\n\n        char *idType = (char*)(ctx->pos + parseCtx->tokenArray[searchResult].start);\n      \n        if(idType[0] == '2') {\n            dst->identifierType = UA_NODEIDTYPE_GUID;\n            entries[*fieldCount].fieldPointer = &dst->identifier.guid;\n            entries[*fieldCount].function = (decodeJsonSignature) Guid_decodeJson;\n        } else if(idType[0] == '1') {\n            dst->identifierType = UA_NODEIDTYPE_STRING;\n            entries[*fieldCount].fieldPointer = &dst->identifier.string;\n            entries[*fieldCount].function = (decodeJsonSignature) String_decodeJson;\n        } else if(idType[0] == '3') {\n            dst->identifierType = UA_NODEIDTYPE_BYTESTRING;\n            entries[*fieldCount].fieldPointer = &dst->identifier.byteString;\n            entries[*fieldCount].function = (decodeJsonSignature) ByteString_decodeJson;\n        } else {\n            return UA_STATUSCODE_BADDECODINGERROR;\n        }\n        \n        /* Id always present */\n        (*fieldCount)++;\n        \n        entries[*fieldCount].fieldName = UA_JSONKEY_IDTYPE;\n        entries[*fieldCount].fieldPointer = NULL;\n        entries[*fieldCount].function = NULL;\n        entries[*fieldCount].found = false;\n        entries[*fieldCount].type = NULL;\n        \n        /* IdType */\n        (*fieldCount)++;\n    } else {\n        dst->identifierType = UA_NODEIDTYPE_NUMERIC;\n        entries[*fieldCount].fieldPointer = &dst->identifier.numeric;\n        entries[*fieldCount].function = (decodeJsonSignature) UInt32_decodeJson;\n        entries[*fieldCount].type = NULL;\n        (*fieldCount)++;\n    }\n    \n    return UA_STATUSCODE_GOOD;\n}\n\nDECODE_JSON(NodeId) {\n    ALLOW_NULL;\n    CHECK_OBJECT;\n\n    /* NameSpace */\n    UA_Boolean hasNamespace = false;\n    size_t searchResultNamespace = 0;\n    status ret = lookAheadForKey(UA_JSONKEY_NAMESPACE, ctx, parseCtx, &searchResultNamespace);\n    if(ret != UA_STATUSCODE_GOOD) {\n        dst->namespaceIndex = 0;\n    } else {\n        hasNamespace = true;\n    }\n    \n    /* Keep track over number of keys present, incremented if key found */\n    u8 fieldCount = 0;\n    DecodeEntry entries[3];\n    ret = prepareDecodeNodeIdJson(dst, ctx, parseCtx, &fieldCount, entries);\n    if(ret != UA_STATUSCODE_GOOD)\n        return ret;\n\n    if(hasNamespace) {\n        entries[fieldCount].fieldName = UA_JSONKEY_NAMESPACE;\n        entries[fieldCount].fieldPointer = &dst->namespaceIndex;\n        entries[fieldCount].function = (decodeJsonSignature) UInt16_decodeJson;\n        entries[fieldCount].found = false;\n        entries[fieldCount].type = NULL;\n        fieldCount++;\n    } else {\n        dst->namespaceIndex = 0;\n    }\n    ret = decodeFields(ctx, parseCtx, entries, fieldCount, type);\n    return ret;\n}\n\nDECODE_JSON(ExpandedNodeId) {\n    ALLOW_NULL;\n    CHECK_OBJECT;\n\n    /* Keep track over number of keys present, incremented if key found */\n    u8 fieldCount = 0;\n    \n    /* ServerUri */\n    UA_Boolean hasServerUri = false;\n    size_t searchResultServerUri = 0;\n    status ret = lookAheadForKey(UA_JSONKEY_SERVERURI, ctx, parseCtx, &searchResultServerUri);\n    if(ret != UA_STATUSCODE_GOOD) {\n        dst->serverIndex = 0; \n    } else {\n        hasServerUri = true;\n    }\n    \n    /* NameSpace */\n    UA_Boolean hasNamespace = false;\n    UA_Boolean isNamespaceString = false;\n    size_t searchResultNamespace = 0;\n    ret = lookAheadForKey(UA_JSONKEY_NAMESPACE, ctx, parseCtx, &searchResultNamespace);\n    if(ret != UA_STATUSCODE_GOOD) {\n        dst->namespaceUri = UA_STRING_NULL;\n    } else {\n        hasNamespace = true;\n        jsmntok_t nsToken = parseCtx->tokenArray[searchResultNamespace];\n        if(nsToken.type == JSMN_STRING)\n            isNamespaceString = true;\n    }\n\n    DecodeEntry entries[4];\n    ret = prepareDecodeNodeIdJson(&dst->nodeId, ctx, parseCtx, &fieldCount, entries);\n    if(ret != UA_STATUSCODE_GOOD)\n        return ret;\n\n    if(hasNamespace) {\n        entries[fieldCount].fieldName = UA_JSONKEY_NAMESPACE;\n        if(isNamespaceString) {\n            entries[fieldCount].fieldPointer = &dst->namespaceUri;\n            entries[fieldCount].function = (decodeJsonSignature) String_decodeJson;\n        } else {\n            entries[fieldCount].fieldPointer = &dst->nodeId.namespaceIndex;\n            entries[fieldCount].function = (decodeJsonSignature) UInt16_decodeJson;\n        }\n        entries[fieldCount].found = false;\n        entries[fieldCount].type = NULL;\n        fieldCount++; \n    }\n    \n    if(hasServerUri) {\n        entries[fieldCount].fieldName = UA_JSONKEY_SERVERURI;\n        entries[fieldCount].fieldPointer = &dst->serverIndex;\n        entries[fieldCount].function = (decodeJsonSignature) UInt32_decodeJson;\n        entries[fieldCount].found = false;\n        entries[fieldCount].type = NULL;\n        fieldCount++;  \n    } else {\n        dst->serverIndex = 0;\n    }\n    \n    return decodeFields(ctx, parseCtx, entries, fieldCount, type);\n}\n\nDECODE_JSON(DateTime) {\n    CHECK_STRING;\n    CHECK_TOKEN_BOUNDS;\n    size_t tokenSize;\n    char* tokenData;\n    GET_TOKEN(tokenData, tokenSize);\n    \n    /* TODO: proper ISO 8601:2004 parsing, musl strptime!*/\n    /* DateTime  ISO 8601:2004 without milli is 20 Characters, with millis 24 */\n    if(tokenSize != 20 && tokenSize != 24) {\n        return UA_STATUSCODE_BADDECODINGERROR;\n    }\n    \n    /* sanity check */\n    if(tokenData[4] != '-' || tokenData[7] != '-' || tokenData[10] != 'T' ||\n       tokenData[13] != ':' || tokenData[16] != ':' ||\n       !(tokenData[19] == 'Z' || tokenData[19] == '.')) {\n        return UA_STATUSCODE_BADDECODINGERROR;\n    }\n    \n    struct mytm dts;\n    memset(&dts, 0, sizeof(dts));\n    \n    UA_UInt64 year = 0;\n    atoiUnsigned(&tokenData[0], 4, &year);\n    dts.tm_year = (UA_UInt16)year - 1900;\n    UA_UInt64 month = 0;\n    atoiUnsigned(&tokenData[5], 2, &month);\n    dts.tm_mon = (UA_UInt16)month - 1;\n    UA_UInt64 day = 0;\n    atoiUnsigned(&tokenData[8], 2, &day);\n    dts.tm_mday = (UA_UInt16)day;\n    UA_UInt64 hour = 0;\n    atoiUnsigned(&tokenData[11], 2, &hour);\n    dts.tm_hour = (UA_UInt16)hour;\n    UA_UInt64 min = 0;\n    atoiUnsigned(&tokenData[14], 2, &min);\n    dts.tm_min = (UA_UInt16)min;\n    UA_UInt64 sec = 0;\n    atoiUnsigned(&tokenData[17], 2, &sec);\n    dts.tm_sec = (UA_UInt16)sec;\n    \n    UA_UInt64 msec = 0;\n    if(tokenSize == 24) {\n        atoiUnsigned(&tokenData[20], 3, &msec);\n    }\n    \n    long long sinceunix = __tm_to_secs(&dts);\n    UA_DateTime dt = (UA_DateTime)((UA_UInt64)(sinceunix*UA_DATETIME_SEC +\n                                               UA_DATETIME_UNIX_EPOCH) +\n                                   (UA_UInt64)(UA_DATETIME_MSEC * msec)); \n    *dst = dt;\n  \n    if(moveToken)\n        parseCtx->index++;\n    return UA_STATUSCODE_GOOD;\n}\n\nDECODE_JSON(StatusCode) {\n    status ret = DECODE_DIRECT_JSON(dst, UInt32);\n    if(ret != UA_STATUSCODE_GOOD)\n        return ret;\n\n    if(moveToken)\n        parseCtx->index++;\n    return UA_STATUSCODE_GOOD;\n}\n\nstatic status\nVariantDimension_decodeJson(void * dst, const UA_DataType *type, \n                            CtxJson *ctx, ParseCtx *parseCtx, UA_Boolean moveToken) {\n    (void) type;\n    const UA_DataType *dimType = &UA_TYPES[UA_TYPES_UINT32];\n    return Array_decodeJson_internal((void**)dst, dimType, ctx, parseCtx, moveToken);\n}\n\nDECODE_JSON(Variant) {\n    ALLOW_NULL;\n    CHECK_OBJECT;\n\n    /* First search for the variant type in the json object. */\n    size_t searchResultType = 0;\n    status ret = lookAheadForKey(UA_JSONKEY_TYPE, ctx, parseCtx, &searchResultType);\n    if(ret != UA_STATUSCODE_GOOD) {\n        skipObject(parseCtx);\n        return UA_STATUSCODE_GOOD;\n    }\n\n    size_t size = ((size_t)parseCtx->tokenArray[searchResultType].end -\n                   (size_t)parseCtx->tokenArray[searchResultType].start);\n\n    /* check if size is zero or the type is not a number */\n    if(size < 1 || parseCtx->tokenArray[searchResultType].type != JSMN_PRIMITIVE)\n        return UA_STATUSCODE_BADDECODINGERROR;\n    \n    /* Parse the type */\n    UA_UInt64 idTypeDecoded = 0;\n    char *idTypeEncoded = (char*)(ctx->pos + parseCtx->tokenArray[searchResultType].start);\n    status typeDecodeStatus = atoiUnsigned(idTypeEncoded, size, &idTypeDecoded);\n    if(typeDecodeStatus != UA_STATUSCODE_GOOD)\n        return typeDecodeStatus;\n\n    /* A NULL Variant */\n    if(idTypeDecoded == 0) {\n        skipObject(parseCtx);\n        return UA_STATUSCODE_GOOD;\n    }\n\n    /* Set the type */\n    UA_NodeId typeNodeId = UA_NODEID_NUMERIC(0, (UA_UInt32)idTypeDecoded);\n    dst->type = UA_findDataType(&typeNodeId);\n    if(!dst->type)\n        return UA_STATUSCODE_BADDECODINGERROR;\n    \n    /* Search for body */\n    size_t searchResultBody = 0;\n    ret = lookAheadForKey(UA_JSONKEY_BODY, ctx, parseCtx, &searchResultBody);\n    if(ret != UA_STATUSCODE_GOOD) {\n        /*TODO: no body? set value NULL?*/\n        return UA_STATUSCODE_BADDECODINGERROR;\n    }\n\n    /* value is an array? */\n    UA_Boolean isArray = false;\n    if(parseCtx->tokenArray[searchResultBody].type == JSMN_ARRAY) {\n        isArray = true;\n        dst->arrayLength = (size_t)parseCtx->tokenArray[searchResultBody].size;\n    }\n\n    /* Has the variant dimension? */\n    UA_Boolean hasDimension = false;\n    size_t searchResultDim = 0;\n    ret = lookAheadForKey(UA_JSONKEY_DIMENSION, ctx, parseCtx, &searchResultDim);\n    if(ret == UA_STATUSCODE_GOOD) {\n        hasDimension = true;\n        dst->arrayDimensionsSize = (size_t)parseCtx->tokenArray[searchResultDim].size;\n    }\n    \n    /* no array but has dimension. error? */\n    if(!isArray && hasDimension)\n        return UA_STATUSCODE_BADDECODINGERROR;\n    \n    /* Get the datatype of the content. The type must be a builtin data type.\n     * All not-builtin types are wrapped in an ExtensionObject. */\n    if(dst->type->typeKind > UA_TYPES_DIAGNOSTICINFO)\n        return UA_STATUSCODE_BADDECODINGERROR;\n\n    /* A variant cannot contain a variant. But it can contain an array of\n     * variants */\n    if(dst->type->typeKind == UA_DATATYPEKIND_VARIANT && !isArray)\n        return UA_STATUSCODE_BADDECODINGERROR;\n    \n    /* Decode an array */\n    if(isArray) {\n        DecodeEntry entries[3] = {\n            {UA_JSONKEY_TYPE, NULL, NULL, false, NULL},\n            {UA_JSONKEY_BODY, &dst->data, (decodeJsonSignature) Array_decodeJson, false, NULL},\n            {UA_JSONKEY_DIMENSION, &dst->arrayDimensions,\n             (decodeJsonSignature) VariantDimension_decodeJson, false, NULL}};\n        if(!hasDimension) {\n            ret = decodeFields(ctx, parseCtx, entries, 2, dst->type); /*use first 2 fields*/\n        } else {\n            ret = decodeFields(ctx, parseCtx, entries, 3, dst->type); /*use all fields*/\n        }      \n        return ret;\n    }\n\n    /* Decode a value wrapped in an ExtensionObject */\n    if(dst->type->typeKind == UA_DATATYPEKIND_EXTENSIONOBJECT) {\n        DecodeEntry entries[2] =\n            {{UA_JSONKEY_TYPE, NULL, NULL, false, NULL},\n             {UA_JSONKEY_BODY, dst,\n              (decodeJsonSignature)Variant_decodeJsonUnwrapExtensionObject, false, NULL}};\n        return decodeFields(ctx, parseCtx, entries, 2, dst->type);\n    }\n\n    /* Allocate Memory for Body */\n    dst->data = UA_new(dst->type);\n    if(!dst->data)\n        return UA_STATUSCODE_BADOUTOFMEMORY;\n    DecodeEntry entries[2] =\n        {{UA_JSONKEY_TYPE, NULL, NULL, false, NULL},\n         {UA_JSONKEY_BODY, dst->data, (decodeJsonSignature) decodeJsonInternal, false, NULL}};\n    return decodeFields(ctx, parseCtx, entries, 2, dst->type);\n}\n\nDECODE_JSON(DataValue) {\n    ALLOW_NULL;\n    CHECK_OBJECT;\n\n    DecodeEntry entries[6] = {\n       {UA_JSONKEY_VALUE, &dst->value, (decodeJsonSignature) Variant_decodeJson, false, NULL},\n       {UA_JSONKEY_STATUS, &dst->status, (decodeJsonSignature) StatusCode_decodeJson, false, NULL},\n       {UA_JSONKEY_SOURCETIMESTAMP, &dst->sourceTimestamp, (decodeJsonSignature) DateTime_decodeJson, false, NULL},\n       {UA_JSONKEY_SOURCEPICOSECONDS, &dst->sourcePicoseconds, (decodeJsonSignature) UInt16_decodeJson, false, NULL},\n       {UA_JSONKEY_SERVERTIMESTAMP, &dst->serverTimestamp, (decodeJsonSignature) DateTime_decodeJson, false, NULL},\n       {UA_JSONKEY_SERVERPICOSECONDS, &dst->serverPicoseconds, (decodeJsonSignature) UInt16_decodeJson, false, NULL}};\n\n    status ret = decodeFields(ctx, parseCtx, entries, 6, type);\n    dst->hasValue = entries[0].found; dst->hasStatus = entries[1].found;\n    dst->hasSourceTimestamp = entries[2].found; dst->hasSourcePicoseconds = entries[3].found;\n    dst->hasServerTimestamp = entries[4].found; dst->hasServerPicoseconds = entries[5].found;\n    return ret;\n}\n\nDECODE_JSON(ExtensionObject) {\n    ALLOW_NULL;\n    CHECK_OBJECT;\n\n    /* Search for Encoding */\n    size_t searchEncodingResult = 0;\n    status ret = lookAheadForKey(UA_JSONKEY_ENCODING, ctx, parseCtx, &searchEncodingResult);\n    \n    /* If no encoding found it is structure encoding */\n    if(ret != UA_STATUSCODE_GOOD) {\n        UA_NodeId typeId;\n        UA_NodeId_init(&typeId);\n\n        size_t searchTypeIdResult = 0;\n        ret = lookAheadForKey(UA_JSONKEY_TYPEID, ctx, parseCtx, &searchTypeIdResult);\n        if(ret != UA_STATUSCODE_GOOD) {\n            /* TYPEID not found, abort */\n            return UA_STATUSCODE_BADENCODINGERROR;\n        }\n\n        /* parse the nodeid */\n        /*for restore*/\n        UA_UInt16 index = parseCtx->index;\n        parseCtx->index = (UA_UInt16)searchTypeIdResult;\n        ret = NodeId_decodeJson(&typeId, &UA_TYPES[UA_TYPES_NODEID], ctx, parseCtx, true);\n        if(ret != UA_STATUSCODE_GOOD)\n            return ret;\n        \n        /*restore*/\n        parseCtx->index = index;\n        const UA_DataType *typeOfBody = UA_findDataType(&typeId);\n        if(!typeOfBody) {\n            /*dont decode body: 1. save as bytestring, 2. jump over*/\n            dst->encoding = UA_EXTENSIONOBJECT_ENCODED_BYTESTRING;\n            UA_NodeId_copy(&typeId, &dst->content.encoded.typeId);\n            \n            /*Check if Object in Extentionobject*/\n            if(getJsmnType(parseCtx) != JSMN_OBJECT) {\n                UA_NodeId_deleteMembers(&typeId);\n                return UA_STATUSCODE_BADDECODINGERROR;\n            }\n            \n            /*Search for Body to save*/\n            size_t searchBodyResult = 0;\n            ret = lookAheadForKey(UA_JSONKEY_BODY, ctx, parseCtx, &searchBodyResult);\n            if(ret != UA_STATUSCODE_GOOD) {\n                /*No Body*/\n                UA_NodeId_deleteMembers(&typeId);\n                return UA_STATUSCODE_BADDECODINGERROR;\n            }\n            \n            if(searchBodyResult >= (size_t)parseCtx->tokenCount) {\n                /*index not in Tokenarray*/\n                UA_NodeId_deleteMembers(&typeId);\n                return UA_STATUSCODE_BADDECODINGERROR;\n            }\n\n            /* Get the size of the Object as a string, not the Object key count! */\n            UA_Int64 sizeOfJsonString =(parseCtx->tokenArray[searchBodyResult].end -\n                    parseCtx->tokenArray[searchBodyResult].start);\n            \n            char* bodyJsonString = (char*)(ctx->pos + parseCtx->tokenArray[searchBodyResult].start);\n            \n            if(sizeOfJsonString <= 0) {\n                UA_NodeId_deleteMembers(&typeId);\n                return UA_STATUSCODE_BADDECODINGERROR;\n            }\n            \n            /* Save encoded as bytestring. */\n            ret = UA_ByteString_allocBuffer(&dst->content.encoded.body, (size_t)sizeOfJsonString);\n            if(ret != UA_STATUSCODE_GOOD) {\n                UA_NodeId_deleteMembers(&typeId);\n                return ret;\n            }\n\n            memcpy(dst->content.encoded.body.data, bodyJsonString, (size_t)sizeOfJsonString);\n            \n            size_t tokenAfteExtensionObject = 0;\n            jumpOverObject(ctx, parseCtx, &tokenAfteExtensionObject);\n            \n            if(tokenAfteExtensionObject == 0) {\n                /*next object token not found*/\n                UA_NodeId_deleteMembers(&typeId);\n                UA_ByteString_deleteMembers(&dst->content.encoded.body);\n                return UA_STATUSCODE_BADDECODINGERROR;\n            }\n            \n            parseCtx->index = (UA_UInt16)tokenAfteExtensionObject;\n            \n            return UA_STATUSCODE_GOOD;\n        }\n        \n        /*Type id not used anymore, typeOfBody has type*/\n        UA_NodeId_deleteMembers(&typeId);\n        \n        /*Set Found Type*/\n        dst->content.decoded.type = typeOfBody;\n        dst->encoding = UA_EXTENSIONOBJECT_DECODED;\n        \n        if(searchTypeIdResult != 0) {\n            dst->content.decoded.data = UA_new(typeOfBody);\n            if(!dst->content.decoded.data)\n                return UA_STATUSCODE_BADOUTOFMEMORY;\n\n            UA_NodeId typeId_dummy;\n            DecodeEntry entries[2] = {\n                {UA_JSONKEY_TYPEID, &typeId_dummy, (decodeJsonSignature) NodeId_decodeJson, false, NULL},\n                {UA_JSONKEY_BODY, dst->content.decoded.data,\n                 (decodeJsonSignature) decodeJsonJumpTable[typeOfBody->typeKind], false, NULL}\n            };\n\n            return decodeFields(ctx, parseCtx, entries, 2, typeOfBody);\n        } else {\n           return UA_STATUSCODE_BADDECODINGERROR;\n        }\n    } else { /* UA_JSONKEY_ENCODING found */\n        /*Parse the encoding*/\n        UA_UInt64 encoding = 0;\n        char *extObjEncoding = (char*)(ctx->pos + parseCtx->tokenArray[searchEncodingResult].start);\n        size_t size = (size_t)(parseCtx->tokenArray[searchEncodingResult].end - parseCtx->tokenArray[searchEncodingResult].start);\n        atoiUnsigned(extObjEncoding, size, &encoding);\n\n        if(encoding == 1) {\n            /* BYTESTRING in Json Body */\n            dst->encoding = UA_EXTENSIONOBJECT_ENCODED_BYTESTRING;\n            UA_UInt16 encodingTypeJson;\n            DecodeEntry entries[3] = {\n                {UA_JSONKEY_ENCODING, &encodingTypeJson, (decodeJsonSignature) UInt16_decodeJson, false, NULL},\n                {UA_JSONKEY_BODY, &dst->content.encoded.body, (decodeJsonSignature) String_decodeJson, false, NULL},\n                {UA_JSONKEY_TYPEID, &dst->content.encoded.typeId, (decodeJsonSignature) NodeId_decodeJson, false, NULL}\n            };\n\n            return decodeFields(ctx, parseCtx, entries, 3, type);\n        } else if(encoding == 2) {\n            /* XmlElement in Json Body */\n            dst->encoding = UA_EXTENSIONOBJECT_ENCODED_XML;\n            UA_UInt16 encodingTypeJson;\n            DecodeEntry entries[3] = {\n                {UA_JSONKEY_ENCODING, &encodingTypeJson, (decodeJsonSignature) UInt16_decodeJson, false, NULL},\n                {UA_JSONKEY_BODY, &dst->content.encoded.body, (decodeJsonSignature) String_decodeJson, false, NULL},\n                {UA_JSONKEY_TYPEID, &dst->content.encoded.typeId, (decodeJsonSignature) NodeId_decodeJson, false, NULL}\n            };\n            return decodeFields(ctx, parseCtx, entries, 3, type);\n        } else {\n            return UA_STATUSCODE_BADDECODINGERROR;\n        }\n    }\n    return UA_STATUSCODE_BADNOTIMPLEMENTED;\n}\n\nstatic status\nVariant_decodeJsonUnwrapExtensionObject(UA_Variant *dst, const UA_DataType *type, \n                                        CtxJson *ctx, ParseCtx *parseCtx, UA_Boolean moveToken) {\n    (void) type, (void) moveToken;\n    /*EXTENSIONOBJECT POSITION!*/\n    UA_UInt16 old_index = parseCtx->index;\n    UA_Boolean typeIdFound;\n    \n    /* Decode the DataType */\n    UA_NodeId typeId;\n    UA_NodeId_init(&typeId);\n\n    size_t searchTypeIdResult = 0;\n    status ret = lookAheadForKey(UA_JSONKEY_TYPEID, ctx, parseCtx, &searchTypeIdResult);\n\n    if(ret != UA_STATUSCODE_GOOD) {\n        /*No Typeid found*/\n        typeIdFound = false;\n        /*return UA_STATUSCODE_BADDECODINGERROR;*/\n    } else {\n        typeIdFound = true;\n        /* parse the nodeid */\n        parseCtx->index = (UA_UInt16)searchTypeIdResult;\n        ret = NodeId_decodeJson(&typeId, &UA_TYPES[UA_TYPES_NODEID], ctx, parseCtx, true);\n        if(ret != UA_STATUSCODE_GOOD) {\n            UA_NodeId_deleteMembers(&typeId);\n            return ret;\n        }\n\n        /*restore index, ExtensionObject position*/\n        parseCtx->index = old_index;\n    }\n\n    /* ---Decode the EncodingByte--- */\n    if(!typeIdFound)\n        return UA_STATUSCODE_BADDECODINGERROR;\n\n    UA_Boolean encodingFound = false;\n    /*Search for Encoding*/\n    size_t searchEncodingResult = 0;\n    ret = lookAheadForKey(UA_JSONKEY_ENCODING, ctx, parseCtx, &searchEncodingResult);\n\n    UA_UInt64 encoding = 0;\n    /*If no encoding found it is Structure encoding*/\n    if(ret == UA_STATUSCODE_GOOD) { /*FOUND*/\n        encodingFound = true;\n        char *extObjEncoding = (char*)(ctx->pos + parseCtx->tokenArray[searchEncodingResult].start);\n        size_t size = (size_t)(parseCtx->tokenArray[searchEncodingResult].end \n                               - parseCtx->tokenArray[searchEncodingResult].start);\n        atoiUnsigned(extObjEncoding, size, &encoding);\n    }\n        \n    const UA_DataType *typeOfBody = UA_findDataType(&typeId);\n        \n    if(encoding == 0 || typeOfBody != NULL) {\n        /*This value is 0 if the body is Structure encoded as a JSON object (see 5.4.6).*/\n        /* Found a valid type and it is structure encoded so it can be unwrapped */\n        if (typeOfBody == NULL)\n            return UA_STATUSCODE_BADDECODINGERROR;\n\n        dst->type = typeOfBody;\n\n        /* Allocate memory for type*/\n        dst->data = UA_new(dst->type);\n        if(!dst->data) {\n            UA_NodeId_deleteMembers(&typeId);\n            return UA_STATUSCODE_BADOUTOFMEMORY;\n        }\n\n        /* Decode the content */\n        UA_NodeId nodeIddummy;\n        DecodeEntry entries[3] =\n            {\n             {UA_JSONKEY_TYPEID, &nodeIddummy, (decodeJsonSignature) NodeId_decodeJson, false, NULL},\n             {UA_JSONKEY_BODY, dst->data,\n              (decodeJsonSignature) decodeJsonJumpTable[dst->type->typeKind], false, NULL},\n             {UA_JSONKEY_ENCODING, NULL, NULL, false, NULL}};\n\n        ret = decodeFields(ctx, parseCtx, entries, encodingFound ? 3:2, typeOfBody);\n        if(ret != UA_STATUSCODE_GOOD) {\n            UA_free(dst->data);\n            dst->data = NULL;\n        }\n    } else if(encoding == 1 || encoding == 2 || typeOfBody == NULL) {\n        UA_NodeId_deleteMembers(&typeId);\n            \n        /* decode as ExtensionObject */\n        dst->type = &UA_TYPES[UA_TYPES_EXTENSIONOBJECT];\n\n        /* Allocate memory for extensionobject*/\n        dst->data = UA_new(dst->type);\n        if(!dst->data)\n            return UA_STATUSCODE_BADOUTOFMEMORY;\n\n        /* decode: Does not move tokenindex. */\n        ret = DECODE_DIRECT_JSON(dst->data, ExtensionObject);\n        if(ret != UA_STATUSCODE_GOOD) {\n            UA_free(dst->data);\n            dst->data = NULL;\n        }\n    } else {\n        /*no recognized encoding type*/\n        return UA_STATUSCODE_BADDECODINGERROR;\n    }\n    return ret;\n}\nstatus DiagnosticInfoInner_decodeJson(void* dst, const UA_DataType* type, \n        CtxJson* ctx, ParseCtx* parseCtx, UA_Boolean moveToken);\n\nDECODE_JSON(DiagnosticInfo) {\n    ALLOW_NULL;\n    CHECK_OBJECT;\n\n    DecodeEntry entries[7] = {\n       {UA_JSONKEY_SYMBOLICID, &dst->symbolicId, (decodeJsonSignature) Int32_decodeJson, false, NULL},\n       {UA_JSONKEY_NAMESPACEURI, &dst->namespaceUri, (decodeJsonSignature) Int32_decodeJson, false, NULL},\n       {UA_JSONKEY_LOCALIZEDTEXT, &dst->localizedText, (decodeJsonSignature) Int32_decodeJson, false, NULL},\n       {UA_JSONKEY_LOCALE, &dst->locale, (decodeJsonSignature) Int32_decodeJson, false, NULL},\n       {UA_JSONKEY_ADDITIONALINFO, &dst->additionalInfo, (decodeJsonSignature) String_decodeJson, false, NULL},\n       {UA_JSONKEY_INNERSTATUSCODE, &dst->innerStatusCode, (decodeJsonSignature) StatusCode_decodeJson, false, NULL},\n       {UA_JSONKEY_INNERDIAGNOSTICINFO, &dst->innerDiagnosticInfo, (decodeJsonSignature) DiagnosticInfoInner_decodeJson, false, NULL}};\n    status ret = decodeFields(ctx, parseCtx, entries, 7, type);\n\n    dst->hasSymbolicId = entries[0].found; dst->hasNamespaceUri = entries[1].found;\n    dst->hasLocalizedText = entries[2].found; dst->hasLocale = entries[3].found;\n    dst->hasAdditionalInfo = entries[4].found; dst->hasInnerStatusCode = entries[5].found;\n    dst->hasInnerDiagnosticInfo = entries[6].found;\n    return ret;\n}\n\nstatus\nDiagnosticInfoInner_decodeJson(void* dst, const UA_DataType* type, \n                               CtxJson* ctx, ParseCtx* parseCtx, UA_Boolean moveToken) {\n    UA_DiagnosticInfo *inner = (UA_DiagnosticInfo*)UA_calloc(1, sizeof(UA_DiagnosticInfo));\n    if(inner == NULL) {\n        return UA_STATUSCODE_BADOUTOFMEMORY;\n    }\n    memcpy(dst, &inner, sizeof(UA_DiagnosticInfo*)); /* Copy new Pointer do dest */\n    return DiagnosticInfo_decodeJson(inner, type, ctx, parseCtx, moveToken);\n}\n\nstatus \ndecodeFields(CtxJson *ctx, ParseCtx *parseCtx, DecodeEntry *entries,\n             size_t entryCount, const UA_DataType *type) {\n    CHECK_TOKEN_BOUNDS;\n    size_t objectCount = (size_t)(parseCtx->tokenArray[parseCtx->index].size);\n    status ret = UA_STATUSCODE_GOOD;\n\n    if(entryCount == 1) {\n        if(*(entries[0].fieldName) == 0) { /*No MemberName*/\n            return entries[0].function(entries[0].fieldPointer, type,\n                                       ctx, parseCtx, true); /*ENCODE DIRECT*/\n        }\n    } else if(entryCount == 0) {\n        return UA_STATUSCODE_BADDECODINGERROR;\n    }\n\n    parseCtx->index++; /*go to first key*/\n    CHECK_TOKEN_BOUNDS;\n    \n    for (size_t currentObjectCount = 0; currentObjectCount < objectCount &&\n             parseCtx->index < parseCtx->tokenCount; currentObjectCount++) {\n\n        /* start searching at the index of currentObjectCount */\n        for (size_t i = currentObjectCount; i < entryCount + currentObjectCount; i++) {\n            /* Search for KEY, if found outer loop will be one less. Best case\n             * is objectCount if in order! */\n            size_t index = i % entryCount;\n            \n            CHECK_TOKEN_BOUNDS;\n            if(jsoneq((char*) ctx->pos, &parseCtx->tokenArray[parseCtx->index], \n                       entries[index].fieldName) != 0)\n                continue;\n\n            if(entries[index].found) {\n                /*Duplicate Key found, abort.*/\n                return UA_STATUSCODE_BADDECODINGERROR;\n            }\n\n            entries[index].found = true;\n\n            parseCtx->index++; /*goto value*/\n            CHECK_TOKEN_BOUNDS;\n            \n            /* Find the data type.\n             * TODO: get rid of parameter type. Only forward via DecodeEntry.\n             */\n            const UA_DataType *membertype = type;\n            if(entries[index].type)\n                membertype = entries[index].type;\n\n            if(entries[index].function != NULL) {\n                ret = entries[index].function(entries[index].fieldPointer,\n                                              membertype, ctx, parseCtx, true); /*Move Token True*/\n                if(ret != UA_STATUSCODE_GOOD)\n                    return ret;\n            } else {\n                /*overstep single value, this will not work if object or array\n                 Only used not to double parse pre looked up type, but it has to be overstepped*/\n                parseCtx->index++;\n            }\n            break;\n        }\n    }\n    return ret;\n}\n\nstatic status\nArray_decodeJson_internal(void **dst, const UA_DataType *type, \n        CtxJson *ctx, ParseCtx *parseCtx, UA_Boolean moveToken) {\n    (void) moveToken;\n    status ret;\n    \n    if(parseCtx->tokenArray[parseCtx->index].type != JSMN_ARRAY)\n        return UA_STATUSCODE_BADDECODINGERROR;\n    \n    size_t length = (size_t)parseCtx->tokenArray[parseCtx->index].size;\n\n    /* Save the length of the array */\n    size_t *p = (size_t*) dst - 1;\n    *p = length;\n\n    /* Return early for empty arrays */\n    if(length == 0) {\n        *dst = UA_EMPTY_ARRAY_SENTINEL;\n        return UA_STATUSCODE_GOOD;\n    }\n\n    /* Allocate memory */\n    *dst = UA_calloc(length, type->memSize);\n    if(*dst == NULL)\n        return UA_STATUSCODE_BADOUTOFMEMORY;\n    \n    parseCtx->index++; /* We go to first Array member!*/\n    \n    /* Decode array members */\n    uintptr_t ptr = (uintptr_t)*dst;\n    for(size_t i = 0; i < length; ++i) {\n        ret = decodeJsonJumpTable[type->typeKind]((void*)ptr, type, ctx, parseCtx, true);\n        if(ret != UA_STATUSCODE_GOOD) {\n            UA_Array_delete(*dst, i+1, type);\n            *dst = NULL;\n            return ret;\n        }\n        ptr += type->memSize;\n    }\n    return UA_STATUSCODE_GOOD;\n}\n\n/*Wrapper for array with valid decodingStructure.*/\nstatic status\nArray_decodeJson(void * dst, const UA_DataType *type, CtxJson *ctx, \n        ParseCtx *parseCtx, UA_Boolean moveToken) {\n    return Array_decodeJson_internal((void **)dst, type, ctx, parseCtx, moveToken);\n}\n\nstatic status\ndecodeJsonStructure(void *dst, const UA_DataType *type, CtxJson *ctx, \n                    ParseCtx *parseCtx, UA_Boolean moveToken) {\n    (void) moveToken;\n    /* Check the recursion limit */\n    if(ctx->depth >= UA_JSON_ENCODING_MAX_RECURSION)\n        return UA_STATUSCODE_BADENCODINGERROR;\n    ctx->depth++;\n\n    uintptr_t ptr = (uintptr_t)dst;\n    status ret = UA_STATUSCODE_GOOD;\n    u8 membersSize = type->membersSize;\n    const UA_DataType *typelists[2] = { UA_TYPES, &type[-type->typeIndex] };\n    \n    UA_STACKARRAY(DecodeEntry, entries, membersSize);\n\n    for(size_t i = 0; i < membersSize && ret == UA_STATUSCODE_GOOD; ++i) {\n        const UA_DataTypeMember *m = &type->members[i];\n        const UA_DataType *mt = &typelists[!m->namespaceZero][m->memberTypeIndex];\n\n        entries[i].type = mt;\n        if(!m->isArray) {\n            ptr += m->padding;\n            entries[i].fieldName = m->memberName;\n            entries[i].fieldPointer = (void*)ptr;\n            entries[i].function = decodeJsonJumpTable[mt->typeKind];\n            entries[i].found = false;\n            ptr += mt->memSize;\n        } else {\n            ptr += m->padding;\n            ptr += sizeof(size_t);\n            entries[i].fieldName = m->memberName;\n            entries[i].fieldPointer = (void*)ptr;\n            entries[i].function = (decodeJsonSignature)Array_decodeJson;\n            entries[i].found = false;\n            ptr += sizeof(void*);\n        }\n    }\n    \n    ret = decodeFields(ctx, parseCtx, entries, membersSize, type);\n\n    ctx->depth--;\n    return ret;\n}\n\nstatic status\ndecodeJsonNotImplemented(void *dst, const UA_DataType *type, CtxJson *ctx, \n                         ParseCtx *parseCtx, UA_Boolean moveToken) {\n    (void)dst, (void)type, (void)ctx, (void)parseCtx, (void)moveToken;\n    return UA_STATUSCODE_BADNOTIMPLEMENTED;\n}\n\nconst decodeJsonSignature decodeJsonJumpTable[UA_DATATYPEKINDS] = {\n    (decodeJsonSignature)Boolean_decodeJson,\n    (decodeJsonSignature)SByte_decodeJson, /* SByte */\n    (decodeJsonSignature)Byte_decodeJson,\n    (decodeJsonSignature)Int16_decodeJson, /* Int16 */\n    (decodeJsonSignature)UInt16_decodeJson,\n    (decodeJsonSignature)Int32_decodeJson, /* Int32 */\n    (decodeJsonSignature)UInt32_decodeJson,\n    (decodeJsonSignature)Int64_decodeJson, /* Int64 */\n    (decodeJsonSignature)UInt64_decodeJson,\n    (decodeJsonSignature)Float_decodeJson,\n    (decodeJsonSignature)Double_decodeJson,\n    (decodeJsonSignature)String_decodeJson,\n    (decodeJsonSignature)DateTime_decodeJson, /* DateTime */\n    (decodeJsonSignature)Guid_decodeJson,\n    (decodeJsonSignature)ByteString_decodeJson, /* ByteString */\n    (decodeJsonSignature)String_decodeJson, /* XmlElement */\n    (decodeJsonSignature)NodeId_decodeJson,\n    (decodeJsonSignature)ExpandedNodeId_decodeJson,\n    (decodeJsonSignature)StatusCode_decodeJson, /* StatusCode */\n    (decodeJsonSignature)QualifiedName_decodeJson, /* QualifiedName */\n    (decodeJsonSignature)LocalizedText_decodeJson,\n    (decodeJsonSignature)ExtensionObject_decodeJson,\n    (decodeJsonSignature)DataValue_decodeJson,\n    (decodeJsonSignature)Variant_decodeJson,\n    (decodeJsonSignature)DiagnosticInfo_decodeJson,\n    (decodeJsonSignature)decodeJsonNotImplemented, /* Decimal */\n    (decodeJsonSignature)Int32_decodeJson, /* Enum */\n    (decodeJsonSignature)decodeJsonStructure,\n    (decodeJsonSignature)decodeJsonNotImplemented, /* Structure with optional fields */\n    (decodeJsonSignature)decodeJsonNotImplemented, /* Union */\n    (decodeJsonSignature)decodeJsonNotImplemented /* BitfieldCluster */\n};\n\ndecodeJsonSignature getDecodeSignature(u8 index) {\n    return decodeJsonJumpTable[index];\n}\n\nstatus\ntokenize(ParseCtx *parseCtx, CtxJson *ctx, const UA_ByteString *src) {\n    /* Set up the context */\n    ctx->pos = &src->data[0];\n    ctx->end = &src->data[src->length];\n    ctx->depth = 0;\n    parseCtx->tokenCount = 0;\n    parseCtx->index = 0;\n\n    /*Set up tokenizer jsmn*/\n    jsmn_parser p;\n    jsmn_init(&p);\n    parseCtx->tokenCount = (UA_Int32)\n        jsmn_parse(&p, (char*)src->data, src->length,\n                   parseCtx->tokenArray, UA_JSON_MAXTOKENCOUNT);\n    \n    if(parseCtx->tokenCount < 0) {\n        if(parseCtx->tokenCount == JSMN_ERROR_NOMEM)\n            return UA_STATUSCODE_BADOUTOFMEMORY;\n        return UA_STATUSCODE_BADDECODINGERROR;\n    }\n    \n    return UA_STATUSCODE_GOOD;\n}\n\nUA_StatusCode\ndecodeJsonInternal(void *dst, const UA_DataType *type,\n                   CtxJson *ctx, ParseCtx *parseCtx, UA_Boolean moveToken) {\n\n    return decodeJsonJumpTable[type->typeKind](dst, type, ctx, parseCtx, moveToken);\n}\n\nstatus UA_FUNC_ATTR_WARN_UNUSED_RESULT\nUA_decodeJson(const UA_ByteString *src, void *dst, const UA_DataType *type) {\n    \n#ifndef UA_ENABLE_TYPEDESCRIPTION\n    return UA_STATUSCODE_BADNOTSUPPORTED;\n#endif\n    \n    if(dst == NULL || src == NULL || type == NULL) {\n        return UA_STATUSCODE_BADARGUMENTSMISSING;\n    }\n    \n    /* Set up the context */\n    CtxJson ctx;\n    ParseCtx parseCtx;\n    parseCtx.tokenArray = (jsmntok_t*)UA_malloc(sizeof(jsmntok_t) * UA_JSON_MAXTOKENCOUNT);\n    if(!parseCtx.tokenArray)\n        return UA_STATUSCODE_BADOUTOFMEMORY;\n    \n    status ret = tokenize(&parseCtx, &ctx, src);\n    if(ret != UA_STATUSCODE_GOOD)\n        goto cleanup;\n\n    /* Assume the top-level element is an object */\n    if(parseCtx.tokenCount < 1 || parseCtx.tokenArray[0].type != JSMN_OBJECT) {\n        if(parseCtx.tokenCount == 1) {\n            if(parseCtx.tokenArray[0].type == JSMN_PRIMITIVE ||\n               parseCtx.tokenArray[0].type == JSMN_STRING) {\n               /* Only a primitive to parse. Do it directly. */\n               memset(dst, 0, type->memSize); /* Initialize the value */\n               ret = decodeJsonJumpTable[type->typeKind](dst, type, &ctx, &parseCtx, true);\n               goto cleanup;\n            }\n        }\n        ret = UA_STATUSCODE_BADDECODINGERROR;\n        goto cleanup;\n    }\n\n    /* Decode */\n    memset(dst, 0, type->memSize); /* Initialize the value */\n    ret = decodeJsonJumpTable[type->typeKind](dst, type, &ctx, &parseCtx, true);\n\n    cleanup:\n    UA_free(parseCtx.tokenArray);\n    \n    /* sanity check if all Tokens were processed */\n    if(!(parseCtx.index == parseCtx.tokenCount ||\n         parseCtx.index == parseCtx.tokenCount-1)) {\n        ret = UA_STATUSCODE_BADDECODINGERROR;\n    }\n    \n    if(ret != UA_STATUSCODE_GOOD)\n        UA_deleteMembers(dst, type); /* Clean up */\n    return ret;\n}\n"], "filenames": ["src/ua_types_encoding_json.c"], "buggy_code_start_loc": [110], "buggy_code_end_loc": [3157], "fixing_code_start_loc": [111], "fixing_code_end_loc": [3162], "type": "CWE-787", "message": "Variant_encodeJson in open62541 1.x before 1.0.4 has an out-of-bounds write for a large recursion depth.", "other": {"cve": {"id": "CVE-2020-36429", "sourceIdentifier": "cve@mitre.org", "published": "2021-07-20T07:15:07.773", "lastModified": "2021-07-28T19:28:28.297", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Variant_encodeJson in open62541 1.x before 1.0.4 has an out-of-bounds write for a large recursion depth."}, {"lang": "es", "value": "Una funci\u00f3n Variant_encodeJson en open62541 versiones 1.x anteriores a 1.0.4, presenta una escritura fuera de l\u00edmites para una gran recursi\u00f3n depth"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:open62541:open62541:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.0.0", "versionEndExcluding": "1.0.4", "matchCriteriaId": "E4D8D5D0-EEF1-4B54-9F8C-568F21CEA354"}]}]}], "references": [{"url": "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=20578", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/google/oss-fuzz-vulns/blob/main/vulns/open62541/OSV-2020-153.yaml", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/open62541/open62541/commit/c800e2987b10bb3af6ef644b515b5d6392f8861d", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/open62541/open62541/compare/v1.0.3...v1.0.4", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/open62541/open62541/commit/c800e2987b10bb3af6ef644b515b5d6392f8861d"}}