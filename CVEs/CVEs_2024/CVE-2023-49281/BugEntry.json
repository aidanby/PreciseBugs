{"buggy_code": ["from django.contrib.sites.shortcuts import get_current_site\nfrom django.shortcuts import render\nfrom django.template import loader\nfrom django.http import HttpResponseRedirect\nfrom .models import Employee, OTP\nfrom .forms import *\nfrom django.views.decorators.csrf import csrf_exempt  # To Disable CSRF\nfrom django.contrib.auth import authenticate, login, logout\nfrom django.urls import reverse\nfrom django.contrib import messages\nfrom django.contrib.auth.decorators import login_required\nfrom django.core.mail import EmailMessage\nfrom django.contrib.auth.forms import PasswordResetForm\nfrom django.utils.http import url_has_allowed_host_and_scheme\nimport logging\nfrom django.conf import settings\nfrom .email import send_forget_password_OTP\nfrom threading import Thread\n\n# Get an instance of a logger\nlogger = logging.getLogger(__name__)\n\n\n\ndef loginForm(request, next=''):\n    # if this is a POST request we need to process the form data\n    if request.method == 'POST':\n        # create a form instance and populate it with data from the request:\n        form = Login_Form(request.POST)\n        # check whether it's valid:\n        if form.is_valid():\n            username = request.POST.get('username')\n            password = request.POST.get('password')\n            user = user = authenticate(username=username, password=password)\n            if user and user.is_active:\n                login(request, user)\n                next_url = request.POST.get('next', '')\n                if (next_url and url_has_allowed_host_and_scheme(next_url, settings.ALLOWED_HOSTS)):\n                    print(\"Good People\")\n                    return HttpResponseRedirect(next_url)\n                else:\n                    print(\"fucking bad shit\")\n                    return HttpResponseRedirect(reverse('CalendarinhoApp:Dashboard'))\n            else:\n                messages.error(request, \"Invalid login details given\")\n                form = Login_Form()\n                return render(request, 'CalendarinhoApp/login.html', {'form': form})\n\n    # if a GET (or any other method) we'll create a blank form\n    else:\n        form = Login_Form()\n        return render(request, 'CalendarinhoApp/login.html', {'form': form})\n\n\n@login_required\ndef logout_view(request):\n    logout(request)\n    return HttpResponseRedirect(reverse('CalendarinhoApp:login'))\n\ndef reset_password(email, from_email,\n        template='CalendarinhoApp/emails/new_user_password_reset_email.html'):\n    \"\"\"\n    Reset the password for an (active) user with given E-Mail address\n    \"\"\"\n    form = PasswordResetForm({'email': email})\n    if form.is_valid():\n        return form.save(from_email=from_email, html_email_template_name=template,email_template_name=template, domain_override=settings.DOMAIN, use_https=settings.USE_HTTPS)\n\n\ndef forgetPasswordInit(request):\n    form = passwordforgetInitForm()\n    return render(request,\"CalendarinhoApp/forgetpasswordInit.html\",{\"form\": form})\n\ndef forgetpasswordOTP(request):\n    if (request.method == 'POST'):\n        #A thread to send an email in the background. Otherwise we will have an email enumeration using time-based attack.\n        thread = Thread(target = send_forget_password_OTP, args= (request,))\n        thread.start()\n        form = passwordforgetEndForm()\n        emp_mail = request.POST.get(\"email\")\n        return render(request,\"CalendarinhoApp/forgetpasswordOTP.html\",{\"form\":form,\"emp_mail\":emp_mail})\n    else:\n        return HttpResponseRedirect(\"/login/\")\n\ndef forgetpasswordEnd(request):\n    if (request.method == 'POST'):\n        emp_mail = request.POST.get(\"emp_mail\")\n        form = passwordforgetEndForm(request.POST)\n\n        fromDatabase = OTP.objects.filter(Email=emp_mail).first()\n        if(not fromDatabase):\n            messages.error(request, \"Something is Wrong!\")\n            return render(request,\"CalendarinhoApp/forgetpasswordOTP.html\",{\"form\":form,\"emp_mail\":emp_mail})\n\n        if(fromDatabase.OTP == request.POST.get(\"OTP\") and int(fromDatabase.Tries) <= 5 and fromDatabase.now_diff() < 300):\n            if form.is_valid():\n                emp = Employee.objects.filter(email=emp_mail).first()\n                emp.set_password(request.POST.get(\"new_Password\"))\n                emp.save()\n\n                fromDatabase.delete()\n\n\n                notifyAfterPasswordReset(emp)\n\n                messages.success(request, \"Password Changed Successfully!\")\n                Login_form = Login_Form()\n                return render(request,\"CalendarinhoApp/login.html\",{\"form\":Login_form})\n            else:\n                return render(request,\"CalendarinhoApp/forgetpasswordOTP.html\",{\"form\":form,\"emp_mail\":emp_mail})\n        else:\n            messages.error(request, \"Something went wrong!\")\n\n            #Increase number of tries:\n            fromDatabase.Tries = str(int(fromDatabase.Tries)+1)\n\n            fromDatabase.save()\n            return render(request,\"CalendarinhoApp/forgetpasswordOTP.html\",{\"form\":form,\"emp_mail\":emp_mail})\n    else:\n        return HttpResponseRedirect(\"/login/\")\n\ndef notifyAfterPasswordReset(user):\n    \"\"\"Send email to the user after password reset.\"\"\"\n\n    context = {\n                'username': user.username,\n                'protocol': 'https' if settings.USE_HTTPS == True else 'http',\n                'domain' : settings.DOMAIN,\n            }\n    email_body = loader.render_to_string(\n            'CalendarinhoApp/emails/password_reset_complete_email.html', context)\n    email = EmailMessage('Calendarinho password reset', email_body, to=[user.email])\n    email.content_subtype = \"html\"\n    try:\n        thread = Thread(target = email.send, args= ())\n        thread.start()\n    except ConnectionRefusedError as e:\n        logger.error(\"Failed to send emails: \\n\" + str(e))"], "fixing_code": ["from django.contrib.sites.shortcuts import get_current_site\nfrom django.shortcuts import render\nfrom django.template import loader\nfrom django.http import HttpResponseRedirect\nfrom .models import Employee, OTP\nfrom .forms import *\nfrom django.views.decorators.csrf import csrf_exempt  # To Disable CSRF\nfrom django.contrib.auth import authenticate, login, logout\nfrom django.urls import reverse\nfrom django.contrib import messages\nfrom django.contrib.auth.decorators import login_required\nfrom django.core.mail import EmailMessage\nfrom django.contrib.auth.forms import PasswordResetForm\nfrom django.utils.http import url_has_allowed_host_and_scheme\nimport logging\nfrom django.conf import settings\nfrom .email import send_forget_password_OTP\nfrom threading import Thread\n\n# Get an instance of a logger\nlogger = logging.getLogger(__name__)\n\n\n\ndef loginForm(request, next=''):\n    # if this is a POST request we need to process the form data\n    if request.method == 'POST':\n        # create a form instance and populate it with data from the request:\n        form = Login_Form(request.POST)\n        # check whether it's valid:\n        if form.is_valid():\n            username = request.POST.get('username')\n            password = request.POST.get('password')\n            user = user = authenticate(username=username, password=password)\n            if user and user.is_active:\n                login(request, user)\n                next_url = request.POST.get('next', '')\n                if (next_url and url_has_allowed_host_and_scheme(next_url, settings.ALLOWED_HOSTS)):\n                    return HttpResponseRedirect(next_url)\n                else:\n                    return HttpResponseRedirect(reverse('CalendarinhoApp:Dashboard'))\n            else:\n                messages.error(request, \"Invalid login details given\")\n                form = Login_Form()\n                return render(request, 'CalendarinhoApp/login.html', {'form': form})\n\n    # if a GET (or any other method) we'll create a blank form\n    else:\n        form = Login_Form()\n        return render(request, 'CalendarinhoApp/login.html', {'form': form})\n\n\n@login_required\ndef logout_view(request):\n    logout(request)\n    return HttpResponseRedirect(reverse('CalendarinhoApp:login'))\n\ndef reset_password(email, from_email,\n        template='CalendarinhoApp/emails/new_user_password_reset_email.html'):\n    \"\"\"\n    Reset the password for an (active) user with given E-Mail address\n    \"\"\"\n    form = PasswordResetForm({'email': email})\n    if form.is_valid():\n        return form.save(from_email=from_email, html_email_template_name=template,email_template_name=template, domain_override=settings.DOMAIN, use_https=settings.USE_HTTPS)\n\n\ndef forgetPasswordInit(request):\n    form = passwordforgetInitForm()\n    return render(request,\"CalendarinhoApp/forgetpasswordInit.html\",{\"form\": form})\n\ndef forgetpasswordOTP(request):\n    if (request.method == 'POST'):\n        #A thread to send an email in the background. Otherwise we will have an email enumeration using time-based attack.\n        thread = Thread(target = send_forget_password_OTP, args= (request,))\n        thread.start()\n        form = passwordforgetEndForm()\n        emp_mail = request.POST.get(\"email\")\n        return render(request,\"CalendarinhoApp/forgetpasswordOTP.html\",{\"form\":form,\"emp_mail\":emp_mail})\n    else:\n        return HttpResponseRedirect(\"/login/\")\n\ndef forgetpasswordEnd(request):\n    if (request.method == 'POST'):\n        emp_mail = request.POST.get(\"emp_mail\")\n        form = passwordforgetEndForm(request.POST)\n\n        fromDatabase = OTP.objects.filter(Email=emp_mail).first()\n        if(not fromDatabase):\n            messages.error(request, \"Something is Wrong!\")\n            return render(request,\"CalendarinhoApp/forgetpasswordOTP.html\",{\"form\":form,\"emp_mail\":emp_mail})\n\n        if(fromDatabase.OTP == request.POST.get(\"OTP\") and int(fromDatabase.Tries) <= 5 and fromDatabase.now_diff() < 300):\n            if form.is_valid():\n                emp = Employee.objects.filter(email=emp_mail).first()\n                emp.set_password(request.POST.get(\"new_Password\"))\n                emp.save()\n\n                fromDatabase.delete()\n\n\n                notifyAfterPasswordReset(emp)\n\n                messages.success(request, \"Password Changed Successfully!\")\n                Login_form = Login_Form()\n                return render(request,\"CalendarinhoApp/login.html\",{\"form\":Login_form})\n            else:\n                return render(request,\"CalendarinhoApp/forgetpasswordOTP.html\",{\"form\":form,\"emp_mail\":emp_mail})\n        else:\n            messages.error(request, \"Something went wrong!\")\n\n            #Increase number of tries:\n            fromDatabase.Tries = str(int(fromDatabase.Tries)+1)\n\n            fromDatabase.save()\n            return render(request,\"CalendarinhoApp/forgetpasswordOTP.html\",{\"form\":form,\"emp_mail\":emp_mail})\n    else:\n        return HttpResponseRedirect(\"/login/\")\n\ndef notifyAfterPasswordReset(user):\n    \"\"\"Send email to the user after password reset.\"\"\"\n\n    context = {\n                'username': user.username,\n                'protocol': 'https' if settings.USE_HTTPS == True else 'http',\n                'domain' : settings.DOMAIN,\n            }\n    email_body = loader.render_to_string(\n            'CalendarinhoApp/emails/password_reset_complete_email.html', context)\n    email = EmailMessage('Calendarinho password reset', email_body, to=[user.email])\n    email.content_subtype = \"html\"\n    try:\n        thread = Thread(target = email.send, args= ())\n        thread.start()\n    except ConnectionRefusedError as e:\n        logger.error(\"Failed to send emails: \\n\" + str(e))"], "filenames": ["CalendarinhoApp/authentication.py"], "buggy_code_start_loc": [39], "buggy_code_end_loc": [43], "fixing_code_start_loc": [38], "fixing_code_end_loc": [40], "type": "CWE-601", "message": "Calendarinho is an open source calendaring application to manage large teams of consultants. An Open Redirect issue occurs when a web application redirects users to external URLs without proper validation. This can lead to phishing attacks, where users are tricked into visiting malicious sites, potentially leading to information theft and reputational damage to the website used for redirection. The problem is has been patched in commit `15b2393`. Users are advised to update to a commit after `15b2393`. There are no known workarounds for this vulnerability. ", "other": {"cve": {"id": "CVE-2023-49281", "sourceIdentifier": "security-advisories@github.com", "published": "2023-12-01T22:15:10.760", "lastModified": "2023-12-06T20:27:26.550", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Calendarinho is an open source calendaring application to manage large teams of consultants. An Open Redirect issue occurs when a web application redirects users to external URLs without proper validation. This can lead to phishing attacks, where users are tricked into visiting malicious sites, potentially leading to information theft and reputational damage to the website used for redirection. The problem is has been patched in commit `15b2393`. Users are advised to update to a commit after `15b2393`. There are no known workarounds for this vulnerability. "}, {"lang": "es", "value": "Calendarinho es una aplicaci\u00f3n de calendario de c\u00f3digo abierto para gestionar grandes equipos de consultores. Se produce un problema de Open Redirect cuando una aplicaci\u00f3n web redirige a los usuarios a URL externas sin la validaci\u00f3n adecuada. Esto puede provocar ataques de phishing, en los que se enga\u00f1a a los usuarios para que visiten sitios maliciosos, lo que podr\u00eda provocar robo de informaci\u00f3n y da\u00f1os a la reputaci\u00f3n del sitio web utilizado para la redirecci\u00f3n. El problema se solucion\u00f3 en el commit `15b2393`. Se recomienda a los usuarios que actualicen a un commit posterior a `15b2393`. No se conocen workarounds para esta vulnerabilidad."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-601"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:cainor:calendarinho:*:*:*:*:*:*:*:*", "versionEndExcluding": "2023-10-11", "matchCriteriaId": "8D975889-305E-45BB-9FB9-C48AB8019E9B"}]}]}], "references": [{"url": "https://github.com/Cainor/Calendarinho/commit/15b2393efd69101727d27a4e710880ce46e84d70", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/Cainor/Calendarinho/commit/9a0174bef939565a76cbe7762996ecddca9ba55e", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/Cainor/Calendarinho/commit/c77defeb0103c1f7a4709799b8751aaeb0d09eed", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/Cainor/Calendarinho/security/advisories/GHSA-g2gp-x888-6xrj", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/Cainor/Calendarinho/commit/15b2393efd69101727d27a4e710880ce46e84d70"}}