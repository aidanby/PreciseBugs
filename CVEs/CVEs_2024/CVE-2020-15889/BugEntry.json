{"buggy_code": ["/*\n** $Id: lgc.c $\n** Garbage Collector\n** See Copyright Notice in lua.h\n*/\n\n#define lgc_c\n#define LUA_CORE\n\n#include \"lprefix.h\"\n\n#include <stdio.h>\n#include <string.h>\n\n\n#include \"lua.h\"\n\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lfunc.h\"\n#include \"lgc.h\"\n#include \"lmem.h\"\n#include \"lobject.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n#include \"ltm.h\"\n\n\n/*\n** Maximum number of elements to sweep in each single step.\n** (Large enough to dissipate fixed overheads but small enough\n** to allow small steps for the collector.)\n*/\n#define GCSWEEPMAX\t100\n\n/*\n** Maximum number of finalizers to call in each single step.\n*/\n#define GCFINMAX\t10\n\n\n/*\n** Cost of calling one finalizer.\n*/\n#define GCFINALIZECOST\t50\n\n\n/*\n** The equivalent, in bytes, of one unit of \"work\" (visiting a slot,\n** sweeping an object, etc.)\n*/\n#define WORK2MEM\tsizeof(TValue)\n\n\n/*\n** macro to adjust 'pause': 'pause' is actually used like\n** 'pause / PAUSEADJ' (value chosen by tests)\n*/\n#define PAUSEADJ\t\t100\n\n\n/* mask to erase all color bits (plus gen. related stuff) */\n#define maskcolors\t(~(bitmask(BLACKBIT) | WHITEBITS | AGEBITS))\n\n\n/* macro to erase all color bits then sets only the current white bit */\n#define makewhite(g,x)\t\\\n (x->marked = cast_byte((x->marked & maskcolors) | luaC_white(g)))\n\n#define white2gray(x)\tresetbits(x->marked, WHITEBITS)\n#define black2gray(x)\tresetbit(x->marked, BLACKBIT)\n\n\n#define valiswhite(x)   (iscollectable(x) && iswhite(gcvalue(x)))\n\n#define keyiswhite(n)   (keyiscollectable(n) && iswhite(gckey(n)))\n\n\n#define checkconsistency(obj)  \\\n  lua_longassert(!iscollectable(obj) || righttt(obj))\n\n/*\n** Protected access to objects in values\n*/\n#define gcvalueN(o)     (iscollectable(o) ? gcvalue(o) : NULL)\n\n\n#define markvalue(g,o) { checkconsistency(o); \\\n  if (valiswhite(o)) reallymarkobject(g,gcvalue(o)); }\n\n#define markkey(g, n)\t{ if keyiswhite(n) reallymarkobject(g,gckey(n)); }\n\n#define markobject(g,t)\t{ if (iswhite(t)) reallymarkobject(g, obj2gco(t)); }\n\n/*\n** mark an object that can be NULL (either because it is really optional,\n** or it was stripped as debug info, or inside an uncompleted structure)\n*/\n#define markobjectN(g,t)\t{ if (t) markobject(g,t); }\n\nstatic void reallymarkobject (global_State *g, GCObject *o);\nstatic lu_mem atomic (lua_State *L);\nstatic void entersweep (lua_State *L);\n\n\n/*\n** {======================================================\n** Generic functions\n** =======================================================\n*/\n\n\n/*\n** one after last element in a hash array\n*/\n#define gnodelast(h)\tgnode(h, cast_sizet(sizenode(h)))\n\n\nstatic GCObject **getgclist (GCObject *o) {\n  switch (o->tt) {\n    case LUA_VTABLE: return &gco2t(o)->gclist;\n    case LUA_VLCL: return &gco2lcl(o)->gclist;\n    case LUA_VCCL: return &gco2ccl(o)->gclist;\n    case LUA_VTHREAD: return &gco2th(o)->gclist;\n    case LUA_VPROTO: return &gco2p(o)->gclist;\n    case LUA_VUSERDATA: {\n      Udata *u = gco2u(o);\n      lua_assert(u->nuvalue > 0);\n      return &u->gclist;\n    }\n    default: lua_assert(0); return 0;\n  }\n}\n\n\n/*\n** Link a collectable object 'o' with a known type into list pointed by 'p'.\n*/\n#define linkgclist(o,p)\t((o)->gclist = (p), (p) = obj2gco(o))\n\n\n/*\n** Link a generic collectable object 'o' into list pointed by 'p'.\n*/\n#define linkobjgclist(o,p) (*getgclist(o) = (p), (p) = obj2gco(o))\n\n\n\n/*\n** Clear keys for empty entries in tables. If entry is empty\n** and its key is not marked, mark its entry as dead. This allows the\n** collection of the key, but keeps its entry in the table (its removal\n** could break a chain). The main feature of a dead key is that it must\n** be different from any other value, to do not disturb searches.\n** Other places never manipulate dead keys, because its associated empty\n** value is enough to signal that the entry is logically empty.\n*/\nstatic void clearkey (Node *n) {\n  lua_assert(isempty(gval(n)));\n  if (keyiswhite(n))\n    setdeadkey(n);  /* unused and unmarked key; remove it */\n}\n\n\n/*\n** tells whether a key or value can be cleared from a weak\n** table. Non-collectable objects are never removed from weak\n** tables. Strings behave as 'values', so are never removed too. for\n** other objects: if really collected, cannot keep them; for objects\n** being finalized, keep them in keys, but not in values\n*/\nstatic int iscleared (global_State *g, const GCObject *o) {\n  if (o == NULL) return 0;  /* non-collectable value */\n  else if (novariant(o->tt) == LUA_TSTRING) {\n    markobject(g, o);  /* strings are 'values', so are never weak */\n    return 0;\n  }\n  else return iswhite(o);\n}\n\n\n/*\n** barrier that moves collector forward, that is, mark the white object\n** 'v' being pointed by the black object 'o'. (If in sweep phase, clear\n** the black object to white [sweep it] to avoid other barrier calls for\n** this same object.) In the generational mode, 'v' must also become\n** old, if 'o' is old; however, it cannot be changed directly to OLD,\n** because it may still point to non-old objects. So, it is marked as\n** OLD0. In the next cycle it will become OLD1, and in the next it\n** will finally become OLD (regular old).\n*/\nvoid luaC_barrier_ (lua_State *L, GCObject *o, GCObject *v) {\n  global_State *g = G(L);\n  lua_assert(isblack(o) && iswhite(v) && !isdead(g, v) && !isdead(g, o));\n  if (keepinvariant(g)) {  /* must keep invariant? */\n    reallymarkobject(g, v);  /* restore invariant */\n    if (isold(o)) {\n      lua_assert(!isold(v));  /* white object could not be old */\n      setage(v, G_OLD0);  /* restore generational invariant */\n    }\n  }\n  else {  /* sweep phase */\n    lua_assert(issweepphase(g));\n    makewhite(g, o);  /* mark main obj. as white to avoid other barriers */\n  }\n}\n\n\n/*\n** barrier that moves collector backward, that is, mark the black object\n** pointing to a white object as gray again.\n*/\nvoid luaC_barrierback_ (lua_State *L, GCObject *o) {\n  global_State *g = G(L);\n  lua_assert(isblack(o) && !isdead(g, o));\n  lua_assert(g->gckind != KGC_GEN || (isold(o) && getage(o) != G_TOUCHED1));\n  if (getage(o) != G_TOUCHED2)  /* not already in gray list? */\n    linkobjgclist(o, g->grayagain);  /* link it in 'grayagain' */\n  black2gray(o);  /* make object gray (again) */\n  setage(o, G_TOUCHED1);  /* touched in current cycle */\n}\n\n\nvoid luaC_fix (lua_State *L, GCObject *o) {\n  global_State *g = G(L);\n  lua_assert(g->allgc == o);  /* object must be 1st in 'allgc' list! */\n  white2gray(o);  /* they will be gray forever */\n  setage(o, G_OLD);  /* and old forever */\n  g->allgc = o->next;  /* remove object from 'allgc' list */\n  o->next = g->fixedgc;  /* link it to 'fixedgc' list */\n  g->fixedgc = o;\n}\n\n\n/*\n** create a new collectable object (with given type and size) and link\n** it to 'allgc' list.\n*/\nGCObject *luaC_newobj (lua_State *L, int tt, size_t sz) {\n  global_State *g = G(L);\n  GCObject *o = cast(GCObject *, luaM_newobject(L, novariant(tt), sz));\n  o->marked = luaC_white(g);\n  o->tt = tt;\n  o->next = g->allgc;\n  g->allgc = o;\n  return o;\n}\n\n/* }====================================================== */\n\n\n\n/*\n** {======================================================\n** Mark functions\n** =======================================================\n*/\n\n\n/*\n** Mark an object. Userdata, strings, and closed upvalues are visited\n** and turned black here. Other objects are marked gray and added\n** to appropriate list to be visited (and turned black) later. (Open\n** upvalues are already linked in 'headuv' list. They are kept gray\n** to avoid barriers, as their values will be revisited by the thread.)\n*/\nstatic void reallymarkobject (global_State *g, GCObject *o) {\n  white2gray(o);\n  switch (o->tt) {\n    case LUA_VSHRSTR:\n    case LUA_VLNGSTR: {\n      gray2black(o);\n      break;\n    }\n    case LUA_VUPVAL: {\n      UpVal *uv = gco2upv(o);\n      if (!upisopen(uv))  /* open upvalues are kept gray */\n        gray2black(o);\n      markvalue(g, uv->v);  /* mark its content */\n      break;\n    }\n    case LUA_VUSERDATA: {\n      Udata *u = gco2u(o);\n      if (u->nuvalue == 0) {  /* no user values? */\n        markobjectN(g, u->metatable);  /* mark its metatable */\n        gray2black(o);  /* nothing else to mark */\n        break;\n      }\n      /* else... */\n    }  /* FALLTHROUGH */\n    case LUA_VLCL: case LUA_VCCL: case LUA_VTABLE:\n    case LUA_VTHREAD: case LUA_VPROTO: {\n      linkobjgclist(o, g->gray);\n      break;\n    }\n    default: lua_assert(0); break;\n  }\n}\n\n\n/*\n** mark metamethods for basic types\n*/\nstatic void markmt (global_State *g) {\n  int i;\n  for (i=0; i < LUA_NUMTAGS; i++)\n    markobjectN(g, g->mt[i]);\n}\n\n\n/*\n** mark all objects in list of being-finalized\n*/\nstatic lu_mem markbeingfnz (global_State *g) {\n  GCObject *o;\n  lu_mem count = 0;\n  for (o = g->tobefnz; o != NULL; o = o->next) {\n    count++;\n    markobject(g, o);\n  }\n  return count;\n}\n\n\n/*\n** Mark all values stored in marked open upvalues from non-marked threads.\n** (Values from marked threads were already marked when traversing the\n** thread.) Remove from the list threads that no longer have upvalues and\n** not-marked threads.\n*/\nstatic int remarkupvals (global_State *g) {\n  lua_State *thread;\n  lua_State **p = &g->twups;\n  int work = 0;\n  while ((thread = *p) != NULL) {\n    work++;\n    lua_assert(!isblack(thread));  /* threads are never black */\n    if (isgray(thread) && thread->openupval != NULL)\n      p = &thread->twups;  /* keep marked thread with upvalues in the list */\n    else {  /* thread is not marked or without upvalues */\n      UpVal *uv;\n      *p = thread->twups;  /* remove thread from the list */\n      thread->twups = thread;  /* mark that it is out of list */\n      for (uv = thread->openupval; uv != NULL; uv = uv->u.open.next) {\n        work++;\n        if (!iswhite(uv))  /* upvalue already visited? */\n          markvalue(g, uv->v);  /* mark its value */\n      }\n    }\n  }\n  return work;\n}\n\n\n/*\n** mark root set and reset all gray lists, to start a new collection\n*/\nstatic void restartcollection (global_State *g) {\n  g->gray = g->grayagain = NULL;\n  g->weak = g->allweak = g->ephemeron = NULL;\n  markobject(g, g->mainthread);\n  markvalue(g, &g->l_registry);\n  markmt(g);\n  markbeingfnz(g);  /* mark any finalizing object left from previous cycle */\n}\n\n/* }====================================================== */\n\n\n/*\n** {======================================================\n** Traverse functions\n** =======================================================\n*/\n\n/*\n** Traverse a table with weak values and link it to proper list. During\n** propagate phase, keep it in 'grayagain' list, to be revisited in the\n** atomic phase. In the atomic phase, if table has any white value,\n** put it in 'weak' list, to be cleared.\n*/\nstatic void traverseweakvalue (global_State *g, Table *h) {\n  Node *n, *limit = gnodelast(h);\n  /* if there is array part, assume it may have white values (it is not\n     worth traversing it now just to check) */\n  int hasclears = (h->alimit > 0);\n  for (n = gnode(h, 0); n < limit; n++) {  /* traverse hash part */\n    if (isempty(gval(n)))  /* entry is empty? */\n      clearkey(n);  /* clear its key */\n    else {\n      lua_assert(!keyisnil(n));\n      markkey(g, n);\n      if (!hasclears && iscleared(g, gcvalueN(gval(n))))  /* a white value? */\n        hasclears = 1;  /* table will have to be cleared */\n    }\n  }\n  if (g->gcstate == GCSatomic && hasclears)\n    linkgclist(h, g->weak);  /* has to be cleared later */\n  else\n    linkgclist(h, g->grayagain);  /* must retraverse it in atomic phase */\n}\n\n\n/*\n** Traverse an ephemeron table and link it to proper list. Returns true\n** iff any object was marked during this traversal (which implies that\n** convergence has to continue). During propagation phase, keep table\n** in 'grayagain' list, to be visited again in the atomic phase. In\n** the atomic phase, if table has any white->white entry, it has to\n** be revisited during ephemeron convergence (as that key may turn\n** black). Otherwise, if it has any white key, table has to be cleared\n** (in the atomic phase). In generational mode, it (like all visited\n** tables) must be kept in some gray list for post-processing.\n*/\nstatic int traverseephemeron (global_State *g, Table *h, int inv) {\n  int marked = 0;  /* true if an object is marked in this traversal */\n  int hasclears = 0;  /* true if table has white keys */\n  int hasww = 0;  /* true if table has entry \"white-key -> white-value\" */\n  unsigned int i;\n  unsigned int asize = luaH_realasize(h);\n  unsigned int nsize = sizenode(h);\n  /* traverse array part */\n  for (i = 0; i < asize; i++) {\n    if (valiswhite(&h->array[i])) {\n      marked = 1;\n      reallymarkobject(g, gcvalue(&h->array[i]));\n    }\n  }\n  /* traverse hash part; if 'inv', traverse descending\n     (see 'convergeephemerons') */\n  for (i = 0; i < nsize; i++) {\n    Node *n = inv ? gnode(h, nsize - 1 - i) : gnode(h, i);\n    if (isempty(gval(n)))  /* entry is empty? */\n      clearkey(n);  /* clear its key */\n    else if (iscleared(g, gckeyN(n))) {  /* key is not marked (yet)? */\n      hasclears = 1;  /* table must be cleared */\n      if (valiswhite(gval(n)))  /* value not marked yet? */\n        hasww = 1;  /* white-white entry */\n    }\n    else if (valiswhite(gval(n))) {  /* value not marked yet? */\n      marked = 1;\n      reallymarkobject(g, gcvalue(gval(n)));  /* mark it now */\n    }\n  }\n  /* link table into proper list */\n  if (g->gcstate == GCSpropagate)\n    linkgclist(h, g->grayagain);  /* must retraverse it in atomic phase */\n  else if (hasww)  /* table has white->white entries? */\n    linkgclist(h, g->ephemeron);  /* have to propagate again */\n  else if (hasclears)  /* table has white keys? */\n    linkgclist(h, g->allweak);  /* may have to clean white keys */\n  else if (g->gckind == KGC_GEN)\n    linkgclist(h, g->grayagain);  /* keep it in some list */\n  else\n    gray2black(h);\n  return marked;\n}\n\n\nstatic void traversestrongtable (global_State *g, Table *h) {\n  Node *n, *limit = gnodelast(h);\n  unsigned int i;\n  unsigned int asize = luaH_realasize(h);\n  for (i = 0; i < asize; i++)  /* traverse array part */\n    markvalue(g, &h->array[i]);\n  for (n = gnode(h, 0); n < limit; n++) {  /* traverse hash part */\n    if (isempty(gval(n)))  /* entry is empty? */\n      clearkey(n);  /* clear its key */\n    else {\n      lua_assert(!keyisnil(n));\n      markkey(g, n);\n      markvalue(g, gval(n));\n    }\n  }\n  if (g->gckind == KGC_GEN) {\n    linkgclist(h, g->grayagain);  /* keep it in some gray list */\n    black2gray(h);\n  }\n}\n\n\nstatic lu_mem traversetable (global_State *g, Table *h) {\n  const char *weakkey, *weakvalue;\n  const TValue *mode = gfasttm(g, h->metatable, TM_MODE);\n  markobjectN(g, h->metatable);\n  if (mode && ttisstring(mode) &&  /* is there a weak mode? */\n      (cast_void(weakkey = strchr(svalue(mode), 'k')),\n       cast_void(weakvalue = strchr(svalue(mode), 'v')),\n       (weakkey || weakvalue))) {  /* is really weak? */\n    black2gray(h);  /* keep table gray */\n    if (!weakkey)  /* strong keys? */\n      traverseweakvalue(g, h);\n    else if (!weakvalue)  /* strong values? */\n      traverseephemeron(g, h, 0);\n    else  /* all weak */\n      linkgclist(h, g->allweak);  /* nothing to traverse now */\n  }\n  else  /* not weak */\n    traversestrongtable(g, h);\n  return 1 + h->alimit + 2 * allocsizenode(h);\n}\n\n\nstatic int traverseudata (global_State *g, Udata *u) {\n  int i;\n  markobjectN(g, u->metatable);  /* mark its metatable */\n  for (i = 0; i < u->nuvalue; i++)\n    markvalue(g, &u->uv[i].uv);\n  if (g->gckind == KGC_GEN) {\n    linkgclist(u, g->grayagain);  /* keep it in some gray list */\n    black2gray(u);\n  }\n  return 1 + u->nuvalue;\n}\n\n\n/*\n** Traverse a prototype. (While a prototype is being build, its\n** arrays can be larger than needed; the extra slots are filled with\n** NULL, so the use of 'markobjectN')\n*/\nstatic int traverseproto (global_State *g, Proto *f) {\n  int i;\n  markobjectN(g, f->source);\n  for (i = 0; i < f->sizek; i++)  /* mark literals */\n    markvalue(g, &f->k[i]);\n  for (i = 0; i < f->sizeupvalues; i++)  /* mark upvalue names */\n    markobjectN(g, f->upvalues[i].name);\n  for (i = 0; i < f->sizep; i++)  /* mark nested protos */\n    markobjectN(g, f->p[i]);\n  for (i = 0; i < f->sizelocvars; i++)  /* mark local-variable names */\n    markobjectN(g, f->locvars[i].varname);\n  return 1 + f->sizek + f->sizeupvalues + f->sizep + f->sizelocvars;\n}\n\n\nstatic int traverseCclosure (global_State *g, CClosure *cl) {\n  int i;\n  for (i = 0; i < cl->nupvalues; i++)  /* mark its upvalues */\n    markvalue(g, &cl->upvalue[i]);\n  return 1 + cl->nupvalues;\n}\n\n/*\n** Traverse a Lua closure, marking its prototype and its upvalues.\n** (Both can be NULL while closure is being created.)\n*/\nstatic int traverseLclosure (global_State *g, LClosure *cl) {\n  int i;\n  markobjectN(g, cl->p);  /* mark its prototype */\n  for (i = 0; i < cl->nupvalues; i++) {  /* visit its upvalues */\n    UpVal *uv = cl->upvals[i];\n    markobjectN(g, uv);  /* mark upvalue */\n  }\n  return 1 + cl->nupvalues;\n}\n\n\n/*\n** Traverse a thread, marking the elements in the stack up to its top\n** and cleaning the rest of the stack in the final traversal.\n** That ensures that the entire stack have valid (non-dead) objects.\n*/\nstatic int traversethread (global_State *g, lua_State *th) {\n  UpVal *uv;\n  StkId o = th->stack;\n  if (o == NULL)\n    return 1;  /* stack not completely built yet */\n  lua_assert(g->gcstate == GCSatomic ||\n             th->openupval == NULL || isintwups(th));\n  for (; o < th->top; o++)  /* mark live elements in the stack */\n    markvalue(g, s2v(o));\n  for (uv = th->openupval; uv != NULL; uv = uv->u.open.next)\n    markobject(g, uv);  /* open upvalues cannot be collected */\n  if (g->gcstate == GCSatomic) {  /* final traversal? */\n    StkId lim = th->stack + th->stacksize;  /* real end of stack */\n    for (; o < lim; o++)  /* clear not-marked stack slice */\n      setnilvalue(s2v(o));\n    /* 'remarkupvals' may have removed thread from 'twups' list */\n    if (!isintwups(th) && th->openupval != NULL) {\n      th->twups = g->twups;  /* link it back to the list */\n      g->twups = th;\n    }\n  }\n  else if (!g->gcemergency)\n    luaD_shrinkstack(th); /* do not change stack in emergency cycle */\n  return 1 + th->stacksize;\n}\n\n\n/*\n** traverse one gray object, turning it to black (except for threads,\n** which are always gray).\n*/\nstatic lu_mem propagatemark (global_State *g) {\n  GCObject *o = g->gray;\n  gray2black(o);\n  g->gray = *getgclist(o);  /* remove from 'gray' list */\n  switch (o->tt) {\n    case LUA_VTABLE: return traversetable(g, gco2t(o));\n    case LUA_VUSERDATA: return traverseudata(g, gco2u(o));\n    case LUA_VLCL: return traverseLclosure(g, gco2lcl(o));\n    case LUA_VCCL: return traverseCclosure(g, gco2ccl(o));\n    case LUA_VPROTO: return traverseproto(g, gco2p(o));\n    case LUA_VTHREAD: {\n      lua_State *th = gco2th(o);\n      linkgclist(th, g->grayagain);  /* insert into 'grayagain' list */\n      black2gray(o);\n      return traversethread(g, th);\n    }\n    default: lua_assert(0); return 0;\n  }\n}\n\n\nstatic lu_mem propagateall (global_State *g) {\n  lu_mem tot = 0;\n  while (g->gray)\n    tot += propagatemark(g);\n  return tot;\n}\n\n\n/*\n** Traverse all ephemeron tables propagating marks from keys to values.\n** Repeat until it converges, that is, nothing new is marked. 'dir'\n** inverts the direction of the traversals, trying to speed up\n** convergence on chains in the same table.\n**\n*/\nstatic void convergeephemerons (global_State *g) {\n  int changed;\n  int dir = 0;\n  do {\n    GCObject *w;\n    GCObject *next = g->ephemeron;  /* get ephemeron list */\n    g->ephemeron = NULL;  /* tables may return to this list when traversed */\n    changed = 0;\n    while ((w = next) != NULL) {  /* for each ephemeron table */\n      next = gco2t(w)->gclist;  /* list is rebuilt during loop */\n      if (traverseephemeron(g, gco2t(w), dir)) {  /* marked some value? */\n        propagateall(g);  /* propagate changes */\n        changed = 1;  /* will have to revisit all ephemeron tables */\n      }\n    }\n    dir = !dir;  /* invert direction next time */\n  } while (changed);  /* repeat until no more changes */\n}\n\n/* }====================================================== */\n\n\n/*\n** {======================================================\n** Sweep Functions\n** =======================================================\n*/\n\n\n/*\n** clear entries with unmarked keys from all weaktables in list 'l'\n*/\nstatic void clearbykeys (global_State *g, GCObject *l) {\n  for (; l; l = gco2t(l)->gclist) {\n    Table *h = gco2t(l);\n    Node *limit = gnodelast(h);\n    Node *n;\n    for (n = gnode(h, 0); n < limit; n++) {\n      if (iscleared(g, gckeyN(n)))  /* unmarked key? */\n        setempty(gval(n));  /* remove entry */\n      if (isempty(gval(n)))  /* is entry empty? */\n        clearkey(n);  /* clear its key */\n    }\n  }\n}\n\n\n/*\n** clear entries with unmarked values from all weaktables in list 'l' up\n** to element 'f'\n*/\nstatic void clearbyvalues (global_State *g, GCObject *l, GCObject *f) {\n  for (; l != f; l = gco2t(l)->gclist) {\n    Table *h = gco2t(l);\n    Node *n, *limit = gnodelast(h);\n    unsigned int i;\n    unsigned int asize = luaH_realasize(h);\n    for (i = 0; i < asize; i++) {\n      TValue *o = &h->array[i];\n      if (iscleared(g, gcvalueN(o)))  /* value was collected? */\n        setempty(o);  /* remove entry */\n    }\n    for (n = gnode(h, 0); n < limit; n++) {\n      if (iscleared(g, gcvalueN(gval(n))))  /* unmarked value? */\n        setempty(gval(n));  /* remove entry */\n      if (isempty(gval(n)))  /* is entry empty? */\n        clearkey(n);  /* clear its key */\n    }\n  }\n}\n\n\nstatic void freeupval (lua_State *L, UpVal *uv) {\n  if (upisopen(uv))\n    luaF_unlinkupval(uv);\n  luaM_free(L, uv);\n}\n\n\nstatic void freeobj (lua_State *L, GCObject *o) {\n  switch (o->tt) {\n    case LUA_VPROTO:\n      luaF_freeproto(L, gco2p(o));\n      break;\n    case LUA_VUPVAL:\n      freeupval(L, gco2upv(o));\n      break;\n    case LUA_VLCL:\n      luaM_freemem(L, o, sizeLclosure(gco2lcl(o)->nupvalues));\n      break;\n    case LUA_VCCL:\n      luaM_freemem(L, o, sizeCclosure(gco2ccl(o)->nupvalues));\n      break;\n    case LUA_VTABLE:\n      luaH_free(L, gco2t(o));\n      break;\n    case LUA_VTHREAD:\n      luaE_freethread(L, gco2th(o));\n      break;\n    case LUA_VUSERDATA: {\n      Udata *u = gco2u(o);\n      luaM_freemem(L, o, sizeudata(u->nuvalue, u->len));\n      break;\n    }\n    case LUA_VSHRSTR:\n      luaS_remove(L, gco2ts(o));  /* remove it from hash table */\n      luaM_freemem(L, o, sizelstring(gco2ts(o)->shrlen));\n      break;\n    case LUA_VLNGSTR:\n      luaM_freemem(L, o, sizelstring(gco2ts(o)->u.lnglen));\n      break;\n    default: lua_assert(0);\n  }\n}\n\n\n/*\n** sweep at most 'countin' elements from a list of GCObjects erasing dead\n** objects, where a dead object is one marked with the old (non current)\n** white; change all non-dead objects back to white, preparing for next\n** collection cycle. Return where to continue the traversal or NULL if\n** list is finished. ('*countout' gets the number of elements traversed.)\n*/\nstatic GCObject **sweeplist (lua_State *L, GCObject **p, int countin,\n                             int *countout) {\n  global_State *g = G(L);\n  int ow = otherwhite(g);\n  int i;\n  int white = luaC_white(g);  /* current white */\n  for (i = 0; *p != NULL && i < countin; i++) {\n    GCObject *curr = *p;\n    int marked = curr->marked;\n    if (isdeadm(ow, marked)) {  /* is 'curr' dead? */\n      *p = curr->next;  /* remove 'curr' from list */\n      freeobj(L, curr);  /* erase 'curr' */\n    }\n    else {  /* change mark to 'white' */\n      curr->marked = cast_byte((marked & maskcolors) | white);\n      p = &curr->next;  /* go to next element */\n    }\n  }\n  if (countout)\n    *countout = i;  /* number of elements traversed */\n  return (*p == NULL) ? NULL : p;\n}\n\n\n/*\n** sweep a list until a live object (or end of list)\n*/\nstatic GCObject **sweeptolive (lua_State *L, GCObject **p) {\n  GCObject **old = p;\n  do {\n    p = sweeplist(L, p, 1, NULL);\n  } while (p == old);\n  return p;\n}\n\n/* }====================================================== */\n\n\n/*\n** {======================================================\n** Finalization\n** =======================================================\n*/\n\n/*\n** If possible, shrink string table.\n*/\nstatic void checkSizes (lua_State *L, global_State *g) {\n  if (!g->gcemergency) {\n    if (g->strt.nuse < g->strt.size / 4) {  /* string table too big? */\n      l_mem olddebt = g->GCdebt;\n      luaS_resize(L, g->strt.size / 2);\n      g->GCestimate += g->GCdebt - olddebt;  /* correct estimate */\n    }\n  }\n}\n\n\n/*\n** Get the next udata to be finalized from the 'tobefnz' list, and\n** link it back into the 'allgc' list.\n*/\nstatic GCObject *udata2finalize (global_State *g) {\n  GCObject *o = g->tobefnz;  /* get first element */\n  lua_assert(tofinalize(o));\n  g->tobefnz = o->next;  /* remove it from 'tobefnz' list */\n  o->next = g->allgc;  /* return it to 'allgc' list */\n  g->allgc = o;\n  resetbit(o->marked, FINALIZEDBIT);  /* object is \"normal\" again */\n  if (issweepphase(g))\n    makewhite(g, o);  /* \"sweep\" object */\n  return o;\n}\n\n\nstatic void dothecall (lua_State *L, void *ud) {\n  UNUSED(ud);\n  luaD_callnoyield(L, L->top - 2, 0);\n}\n\n\nstatic void GCTM (lua_State *L) {\n  global_State *g = G(L);\n  const TValue *tm;\n  TValue v;\n  lua_assert(!g->gcemergency);\n  setgcovalue(L, &v, udata2finalize(g));\n  tm = luaT_gettmbyobj(L, &v, TM_GC);\n  if (!notm(tm)) {  /* is there a finalizer? */\n    int status;\n    lu_byte oldah = L->allowhook;\n    int running  = g->gcrunning;\n    L->allowhook = 0;  /* stop debug hooks during GC metamethod */\n    g->gcrunning = 0;  /* avoid GC steps */\n    setobj2s(L, L->top++, tm);  /* push finalizer... */\n    setobj2s(L, L->top++, &v);  /* ... and its argument */\n    L->ci->callstatus |= CIST_FIN;  /* will run a finalizer */\n    status = luaD_pcall(L, dothecall, NULL, savestack(L, L->top - 2), 0);\n    L->ci->callstatus &= ~CIST_FIN;  /* not running a finalizer anymore */\n    L->allowhook = oldah;  /* restore hooks */\n    g->gcrunning = running;  /* restore state */\n    if (unlikely(status != LUA_OK)) {  /* error while running __gc? */\n      luaE_warnerror(L, \"__gc metamethod\");\n      L->top--;  /* pops error object */\n    }\n  }\n}\n\n\n/*\n** Call a few finalizers\n*/\nstatic int runafewfinalizers (lua_State *L, int n) {\n  global_State *g = G(L);\n  int i;\n  for (i = 0; i < n && g->tobefnz; i++)\n    GCTM(L);  /* call one finalizer */\n  return i;\n}\n\n\n/*\n** call all pending finalizers\n*/\nstatic void callallpendingfinalizers (lua_State *L) {\n  global_State *g = G(L);\n  while (g->tobefnz)\n    GCTM(L);\n}\n\n\n/*\n** find last 'next' field in list 'p' list (to add elements in its end)\n*/\nstatic GCObject **findlast (GCObject **p) {\n  while (*p != NULL)\n    p = &(*p)->next;\n  return p;\n}\n\n\n/*\n** Move all unreachable objects (or 'all' objects) that need\n** finalization from list 'finobj' to list 'tobefnz' (to be finalized).\n** (Note that objects after 'finobjold' cannot be white, so they\n** don't need to be traversed. In incremental mode, 'finobjold' is NULL,\n** so the whole list is traversed.)\n*/\nstatic void separatetobefnz (global_State *g, int all) {\n  GCObject *curr;\n  GCObject **p = &g->finobj;\n  GCObject **lastnext = findlast(&g->tobefnz);\n  while ((curr = *p) != g->finobjold) {  /* traverse all finalizable objects */\n    lua_assert(tofinalize(curr));\n    if (!(iswhite(curr) || all))  /* not being collected? */\n      p = &curr->next;  /* don't bother with it */\n    else {\n      if (curr == g->finobjsur)  /* removing 'finobjsur'? */\n        g->finobjsur = curr->next;  /* correct it */\n      *p = curr->next;  /* remove 'curr' from 'finobj' list */\n      curr->next = *lastnext;  /* link at the end of 'tobefnz' list */\n      *lastnext = curr;\n      lastnext = &curr->next;\n    }\n  }\n}\n\n\n/*\n** if object 'o' has a finalizer, remove it from 'allgc' list (must\n** search the list to find it) and link it in 'finobj' list.\n*/\nvoid luaC_checkfinalizer (lua_State *L, GCObject *o, Table *mt) {\n  global_State *g = G(L);\n  if (tofinalize(o) ||                 /* obj. is already marked... */\n      gfasttm(g, mt, TM_GC) == NULL)   /* or has no finalizer? */\n    return;  /* nothing to be done */\n  else {  /* move 'o' to 'finobj' list */\n    GCObject **p;\n    if (issweepphase(g)) {\n      makewhite(g, o);  /* \"sweep\" object 'o' */\n      if (g->sweepgc == &o->next)  /* should not remove 'sweepgc' object */\n        g->sweepgc = sweeptolive(L, g->sweepgc);  /* change 'sweepgc' */\n    }\n    else {  /* correct pointers into 'allgc' list, if needed */\n      if (o == g->survival)\n        g->survival = o->next;\n      if (o == g->old)\n        g->old = o->next;\n      if (o == g->reallyold)\n        g->reallyold = o->next;\n    }\n    /* search for pointer pointing to 'o' */\n    for (p = &g->allgc; *p != o; p = &(*p)->next) { /* empty */ }\n    *p = o->next;  /* remove 'o' from 'allgc' list */\n    o->next = g->finobj;  /* link it in 'finobj' list */\n    g->finobj = o;\n    l_setbit(o->marked, FINALIZEDBIT);  /* mark it as such */\n  }\n}\n\n/* }====================================================== */\n\n\n/*\n** {======================================================\n** Generational Collector\n** =======================================================\n*/\n\nstatic void setpause (global_State *g);\n\n\n/* mask to erase all color bits, not changing gen-related stuff */\n#define maskgencolors\t(~(bitmask(BLACKBIT) | WHITEBITS))\n\n\n/*\n** Sweep a list of objects, deleting dead ones and turning\n** the non dead to old (without changing their colors).\n*/\nstatic void sweep2old (lua_State *L, GCObject **p) {\n  GCObject *curr;\n  while ((curr = *p) != NULL) {\n    if (iswhite(curr)) {  /* is 'curr' dead? */\n      lua_assert(isdead(G(L), curr));\n      *p = curr->next;  /* remove 'curr' from list */\n      freeobj(L, curr);  /* erase 'curr' */\n    }\n    else {  /* all surviving objects become old */\n      setage(curr, G_OLD);\n      p = &curr->next;  /* go to next element */\n    }\n  }\n}\n\n\n/*\n** Sweep for generational mode. Delete dead objects. (Because the\n** collection is not incremental, there are no \"new white\" objects\n** during the sweep. So, any white object must be dead.) For\n** non-dead objects, advance their ages and clear the color of\n** new objects. (Old objects keep their colors.)\n*/\nstatic GCObject **sweepgen (lua_State *L, global_State *g, GCObject **p,\n                            GCObject *limit) {\n  static const lu_byte nextage[] = {\n    G_SURVIVAL,  /* from G_NEW */\n    G_OLD1,      /* from G_SURVIVAL */\n    G_OLD1,      /* from G_OLD0 */\n    G_OLD,       /* from G_OLD1 */\n    G_OLD,       /* from G_OLD (do not change) */\n    G_TOUCHED1,  /* from G_TOUCHED1 (do not change) */\n    G_TOUCHED2   /* from G_TOUCHED2 (do not change) */\n  };\n  int white = luaC_white(g);\n  GCObject *curr;\n  while ((curr = *p) != limit) {\n    if (iswhite(curr)) {  /* is 'curr' dead? */\n      lua_assert(!isold(curr) && isdead(g, curr));\n      *p = curr->next;  /* remove 'curr' from list */\n      freeobj(L, curr);  /* erase 'curr' */\n    }\n    else {  /* correct mark and age */\n      if (getage(curr) == G_NEW)\n        curr->marked = cast_byte((curr->marked & maskgencolors) | white);\n      setage(curr, nextage[getage(curr)]);\n      p = &curr->next;  /* go to next element */\n    }\n  }\n  return p;\n}\n\n\n/*\n** Traverse a list making all its elements white and clearing their\n** age.\n*/\nstatic void whitelist (global_State *g, GCObject *p) {\n  int white = luaC_white(g);\n  for (; p != NULL; p = p->next)\n    p->marked = cast_byte((p->marked & maskcolors) | white);\n}\n\n\n/*\n** Correct a list of gray objects.\n** Because this correction is done after sweeping, young objects might\n** be turned white and still be in the list. They are only removed.\n** For tables and userdata, advance 'touched1' to 'touched2'; 'touched2'\n** objects become regular old and are removed from the list.\n** For threads, just remove white ones from the list.\n*/\nstatic GCObject **correctgraylist (GCObject **p) {\n  GCObject *curr;\n  while ((curr = *p) != NULL) {\n    switch (curr->tt) {\n      case LUA_VTABLE: case LUA_VUSERDATA: {\n        GCObject **next = getgclist(curr);\n        if (getage(curr) == G_TOUCHED1) {  /* touched in this cycle? */\n          lua_assert(isgray(curr));\n          gray2black(curr);  /* make it black, for next barrier */\n          changeage(curr, G_TOUCHED1, G_TOUCHED2);\n          p = next;  /* go to next element */\n        }\n        else {  /* not touched in this cycle */\n          if (!iswhite(curr)) {  /* not white? */\n            lua_assert(isold(curr));\n            if (getage(curr) == G_TOUCHED2)  /* advance from G_TOUCHED2... */\n              changeage(curr, G_TOUCHED2, G_OLD);  /* ... to G_OLD */\n            gray2black(curr);  /* make it black */\n          }\n          /* else, object is white: just remove it from this list */\n          *p = *next;  /* remove 'curr' from gray list */\n        }\n        break;\n      }\n      case LUA_VTHREAD: {\n        lua_State *th = gco2th(curr);\n        lua_assert(!isblack(th));\n        if (iswhite(th))  /* new object? */\n          *p = th->gclist;  /* remove from gray list */\n        else  /* old threads remain gray */\n          p = &th->gclist;  /* go to next element */\n        break;\n      }\n      default: lua_assert(0);  /* nothing more could be gray here */\n    }\n  }\n  return p;\n}\n\n\n/*\n** Correct all gray lists, coalescing them into 'grayagain'.\n*/\nstatic void correctgraylists (global_State *g) {\n  GCObject **list = correctgraylist(&g->grayagain);\n  *list = g->weak; g->weak = NULL;\n  list = correctgraylist(list);\n  *list = g->allweak; g->allweak = NULL;\n  list = correctgraylist(list);\n  *list = g->ephemeron; g->ephemeron = NULL;\n  correctgraylist(list);\n}\n\n\n/*\n** Mark 'OLD1' objects when starting a new young collection.\n** Gray objects are already in some gray list, and so will be visited\n** in the atomic step.\n*/\nstatic void markold (global_State *g, GCObject *from, GCObject *to) {\n  GCObject *p;\n  for (p = from; p != to; p = p->next) {\n    if (getage(p) == G_OLD1) {\n      lua_assert(!iswhite(p));\n      if (isblack(p)) {\n        black2gray(p);  /* should be '2white', but gray works too */\n        reallymarkobject(g, p);\n      }\n    }\n  }\n}\n\n\n/*\n** Finish a young-generation collection.\n*/\nstatic void finishgencycle (lua_State *L, global_State *g) {\n  correctgraylists(g);\n  checkSizes(L, g);\n  g->gcstate = GCSpropagate;  /* skip restart */\n  if (!g->gcemergency)\n    callallpendingfinalizers(L);\n}\n\n\n/*\n** Does a young collection. First, mark 'OLD1' objects.  (Only survival\n** and \"recent old\" lists can contain 'OLD1' objects. New lists cannot\n** contain 'OLD1' objects, at most 'OLD0' objects that were already\n** visited when marked old.) Then does the atomic step. Then,\n** sweep all lists and advance pointers. Finally, finish the collection.\n*/\nstatic void youngcollection (lua_State *L, global_State *g) {\n  GCObject **psurvival;  /* to point to first non-dead survival object */\n  lua_assert(g->gcstate == GCSpropagate);\n  markold(g, g->survival, g->reallyold);\n  markold(g, g->finobj, g->finobjrold);\n  atomic(L);\n\n  /* sweep nursery and get a pointer to its last live element */\n  psurvival = sweepgen(L, g, &g->allgc, g->survival);\n  /* sweep 'survival' and 'old' */\n  sweepgen(L, g, psurvival, g->reallyold);\n  g->reallyold = g->old;\n  g->old = *psurvival;  /* 'survival' survivals are old now */\n  g->survival = g->allgc;  /* all news are survivals */\n\n  /* repeat for 'finobj' lists */\n  psurvival = sweepgen(L, g, &g->finobj, g->finobjsur);\n  /* sweep 'survival' and 'old' */\n  sweepgen(L, g, psurvival, g->finobjrold);\n  g->finobjrold = g->finobjold;\n  g->finobjold = *psurvival;  /* 'survival' survivals are old now */\n  g->finobjsur = g->finobj;  /* all news are survivals */\n\n  sweepgen(L, g, &g->tobefnz, NULL);\n\n  finishgencycle(L, g);\n}\n\n\nstatic void atomic2gen (lua_State *L, global_State *g) {\n  /* sweep all elements making them old */\n  sweep2old(L, &g->allgc);\n  /* everything alive now is old */\n  g->reallyold = g->old = g->survival = g->allgc;\n\n  /* repeat for 'finobj' lists */\n  sweep2old(L, &g->finobj);\n  g->finobjrold = g->finobjold = g->finobjsur = g->finobj;\n\n  sweep2old(L, &g->tobefnz);\n\n  g->gckind = KGC_GEN;\n  g->lastatomic = 0;\n  g->GCestimate = gettotalbytes(g);  /* base for memory control */\n  finishgencycle(L, g);\n}\n\n\n/*\n** Enter generational mode. Must go until the end of an atomic cycle\n** to ensure that all threads and weak tables are in the gray lists.\n** Then, turn all objects into old and finishes the collection.\n*/\nstatic lu_mem entergen (lua_State *L, global_State *g) {\n  lu_mem numobjs;\n  luaC_runtilstate(L, bitmask(GCSpause));  /* prepare to start a new cycle */\n  luaC_runtilstate(L, bitmask(GCSpropagate));  /* start new cycle */\n  numobjs = atomic(L);  /* propagates all and then do the atomic stuff */\n  atomic2gen(L, g);\n  return numobjs;\n}\n\n\n/*\n** Enter incremental mode. Turn all objects white, make all\n** intermediate lists point to NULL (to avoid invalid pointers),\n** and go to the pause state.\n*/\nstatic void enterinc (global_State *g) {\n  whitelist(g, g->allgc);\n  g->reallyold = g->old = g->survival = NULL;\n  whitelist(g, g->finobj);\n  whitelist(g, g->tobefnz);\n  g->finobjrold = g->finobjold = g->finobjsur = NULL;\n  g->gcstate = GCSpause;\n  g->gckind = KGC_INC;\n  g->lastatomic = 0;\n}\n\n\n/*\n** Change collector mode to 'newmode'.\n*/\nvoid luaC_changemode (lua_State *L, int newmode) {\n  global_State *g = G(L);\n  if (newmode != g->gckind) {\n    if (newmode == KGC_GEN)  /* entering generational mode? */\n      entergen(L, g);\n    else\n      enterinc(g);  /* entering incremental mode */\n  }\n  g->lastatomic = 0;\n}\n\n\n/*\n** Does a full collection in generational mode.\n*/\nstatic lu_mem fullgen (lua_State *L, global_State *g) {\n  enterinc(g);\n  return entergen(L, g);\n}\n\n\n/*\n** Set debt for the next minor collection, which will happen when\n** memory grows 'genminormul'%.\n*/\nstatic void setminordebt (global_State *g) {\n  luaE_setdebt(g, -(cast(l_mem, (gettotalbytes(g) / 100)) * g->genminormul));\n}\n\n\n/*\n** Does a major collection after last collection was a \"bad collection\".\n**\n** When the program is building a big structure, it allocates lots of\n** memory but generates very little garbage. In those scenarios,\n** the generational mode just wastes time doing small collections, and\n** major collections are frequently what we call a \"bad collection\", a\n** collection that frees too few objects. To avoid the cost of switching\n** between generational mode and the incremental mode needed for full\n** (major) collections, the collector tries to stay in incremental mode\n** after a bad collection, and to switch back to generational mode only\n** after a \"good\" collection (one that traverses less than 9/8 objects\n** of the previous one).\n** The collector must choose whether to stay in incremental mode or to\n** switch back to generational mode before sweeping. At this point, it\n** does not know the real memory in use, so it cannot use memory to\n** decide whether to return to generational mode. Instead, it uses the\n** number of objects traversed (returned by 'atomic') as a proxy. The\n** field 'g->lastatomic' keeps this count from the last collection.\n** ('g->lastatomic != 0' also means that the last collection was bad.)\n*/\nstatic void stepgenfull (lua_State *L, global_State *g) {\n  lu_mem newatomic;  /* count of traversed objects */\n  lu_mem lastatomic = g->lastatomic;  /* count from last collection */\n  if (g->gckind == KGC_GEN)  /* still in generational mode? */\n    enterinc(g);  /* enter incremental mode */\n  luaC_runtilstate(L, bitmask(GCSpropagate));  /* start new cycle */\n  newatomic = atomic(L);  /* mark everybody */\n  if (newatomic < lastatomic + (lastatomic >> 3)) {  /* good collection? */\n    atomic2gen(L, g);  /* return to generational mode */\n    setminordebt(g);\n  }\n  else {  /* another bad collection; stay in incremental mode */\n    g->GCestimate = gettotalbytes(g);  /* first estimate */;\n    entersweep(L);\n    luaC_runtilstate(L, bitmask(GCSpause));  /* finish collection */\n    setpause(g);\n    g->lastatomic = newatomic;\n  }\n}\n\n\n/*\n** Does a generational \"step\".\n** Usually, this means doing a minor collection and setting the debt to\n** make another collection when memory grows 'genminormul'% larger.\n**\n** However, there are exceptions.  If memory grows 'genmajormul'%\n** larger than it was at the end of the last major collection (kept\n** in 'g->GCestimate'), the function does a major collection. At the\n** end, it checks whether the major collection was able to free a\n** decent amount of memory (at least half the growth in memory since\n** previous major collection). If so, the collector keeps its state,\n** and the next collection will probably be minor again. Otherwise,\n** we have what we call a \"bad collection\". In that case, set the field\n** 'g->lastatomic' to signal that fact, so that the next collection will\n** go to 'stepgenfull'.\n**\n** 'GCdebt <= 0' means an explicit call to GC step with \"size\" zero;\n** in that case, do a minor collection.\n*/\nstatic void genstep (lua_State *L, global_State *g) {\n  if (g->lastatomic != 0)  /* last collection was a bad one? */\n    stepgenfull(L, g);  /* do a full step */\n  else {\n    lu_mem majorbase = g->GCestimate;  /* memory after last major collection */\n    lu_mem majorinc = (majorbase / 100) * getgcparam(g->genmajormul);\n    if (g->GCdebt > 0 && gettotalbytes(g) > majorbase + majorinc) {\n      lu_mem numobjs = fullgen(L, g);  /* do a major collection */\n      if (gettotalbytes(g) < majorbase + (majorinc / 2)) {\n        /* collected at least half of memory growth since last major\n           collection; keep doing minor collections */\n        setminordebt(g);\n      }\n      else {  /* bad collection */\n        g->lastatomic = numobjs;  /* signal that last collection was bad */\n        setpause(g);  /* do a long wait for next (major) collection */\n      }\n    }\n    else {  /* regular case; do a minor collection */\n      youngcollection(L, g);\n      setminordebt(g);\n      g->GCestimate = majorbase;  /* preserve base value */\n    }\n  }\n  lua_assert(isdecGCmodegen(g));\n}\n\n/* }====================================================== */\n\n\n/*\n** {======================================================\n** GC control\n** =======================================================\n*/\n\n\n/*\n** Set the \"time\" to wait before starting a new GC cycle; cycle will\n** start when memory use hits the threshold of ('estimate' * pause /\n** PAUSEADJ). (Division by 'estimate' should be OK: it cannot be zero,\n** because Lua cannot even start with less than PAUSEADJ bytes).\n*/\nstatic void setpause (global_State *g) {\n  l_mem threshold, debt;\n  int pause = getgcparam(g->gcpause);\n  l_mem estimate = g->GCestimate / PAUSEADJ;  /* adjust 'estimate' */\n  lua_assert(estimate > 0);\n  threshold = (pause < MAX_LMEM / estimate)  /* overflow? */\n            ? estimate * pause  /* no overflow */\n            : MAX_LMEM;  /* overflow; truncate to maximum */\n  debt = gettotalbytes(g) - threshold;\n  if (debt > 0) debt = 0;\n  luaE_setdebt(g, debt);\n}\n\n\n/*\n** Enter first sweep phase.\n** The call to 'sweeptolive' makes the pointer point to an object\n** inside the list (instead of to the header), so that the real sweep do\n** not need to skip objects created between \"now\" and the start of the\n** real sweep.\n*/\nstatic void entersweep (lua_State *L) {\n  global_State *g = G(L);\n  g->gcstate = GCSswpallgc;\n  lua_assert(g->sweepgc == NULL);\n  g->sweepgc = sweeptolive(L, &g->allgc);\n}\n\n\n/*\n** Delete all objects in list 'p' until (but not including) object\n** 'limit'.\n*/\nstatic void deletelist (lua_State *L, GCObject *p, GCObject *limit) {\n  while (p != limit) {\n    GCObject *next = p->next;\n    freeobj(L, p);\n    p = next;\n  }\n}\n\n\n/*\n** Call all finalizers of the objects in the given Lua state, and\n** then free all objects, except for the main thread.\n*/\nvoid luaC_freeallobjects (lua_State *L) {\n  global_State *g = G(L);\n  luaC_changemode(L, KGC_INC);\n  separatetobefnz(g, 1);  /* separate all objects with finalizers */\n  lua_assert(g->finobj == NULL);\n  callallpendingfinalizers(L);\n  deletelist(L, g->allgc, obj2gco(g->mainthread));\n  deletelist(L, g->finobj, NULL);\n  deletelist(L, g->fixedgc, NULL);  /* collect fixed objects */\n  lua_assert(g->strt.nuse == 0);\n}\n\n\nstatic lu_mem atomic (lua_State *L) {\n  global_State *g = G(L);\n  lu_mem work = 0;\n  GCObject *origweak, *origall;\n  GCObject *grayagain = g->grayagain;  /* save original list */\n  g->grayagain = NULL;\n  lua_assert(g->ephemeron == NULL && g->weak == NULL);\n  lua_assert(!iswhite(g->mainthread));\n  g->gcstate = GCSatomic;\n  markobject(g, L);  /* mark running thread */\n  /* registry and global metatables may be changed by API */\n  markvalue(g, &g->l_registry);\n  markmt(g);  /* mark global metatables */\n  work += propagateall(g);  /* empties 'gray' list */\n  /* remark occasional upvalues of (maybe) dead threads */\n  work += remarkupvals(g);\n  work += propagateall(g);  /* propagate changes */\n  g->gray = grayagain;\n  work += propagateall(g);  /* traverse 'grayagain' list */\n  convergeephemerons(g);\n  /* at this point, all strongly accessible objects are marked. */\n  /* Clear values from weak tables, before checking finalizers */\n  clearbyvalues(g, g->weak, NULL);\n  clearbyvalues(g, g->allweak, NULL);\n  origweak = g->weak; origall = g->allweak;\n  separatetobefnz(g, 0);  /* separate objects to be finalized */\n  work += markbeingfnz(g);  /* mark objects that will be finalized */\n  work += propagateall(g);  /* remark, to propagate 'resurrection' */\n  convergeephemerons(g);\n  /* at this point, all resurrected objects are marked. */\n  /* remove dead objects from weak tables */\n  clearbykeys(g, g->ephemeron);  /* clear keys from all ephemeron tables */\n  clearbykeys(g, g->allweak);  /* clear keys from all 'allweak' tables */\n  /* clear values from resurrected weak tables */\n  clearbyvalues(g, g->weak, origweak);\n  clearbyvalues(g, g->allweak, origall);\n  luaS_clearcache(g);\n  g->currentwhite = cast_byte(otherwhite(g));  /* flip current white */\n  lua_assert(g->gray == NULL);\n  return work;  /* estimate of slots marked by 'atomic' */\n}\n\n\nstatic int sweepstep (lua_State *L, global_State *g,\n                      int nextstate, GCObject **nextlist) {\n  if (g->sweepgc) {\n    l_mem olddebt = g->GCdebt;\n    int count;\n    g->sweepgc = sweeplist(L, g->sweepgc, GCSWEEPMAX, &count);\n    g->GCestimate += g->GCdebt - olddebt;  /* update estimate */\n    return count;\n  }\n  else {  /* enter next state */\n    g->gcstate = nextstate;\n    g->sweepgc = nextlist;\n    return 0;  /* no work done */\n  }\n}\n\n\nstatic lu_mem singlestep (lua_State *L) {\n  global_State *g = G(L);\n  switch (g->gcstate) {\n    case GCSpause: {\n      restartcollection(g);\n      g->gcstate = GCSpropagate;\n      return 1;\n    }\n    case GCSpropagate: {\n      if (g->gray == NULL) {  /* no more gray objects? */\n        g->gcstate = GCSenteratomic;  /* finish propagate phase */\n        return 0;\n      }\n      else\n        return propagatemark(g);  /* traverse one gray object */\n    }\n    case GCSenteratomic: {\n      lu_mem work = atomic(L);  /* work is what was traversed by 'atomic' */\n      entersweep(L);\n      g->GCestimate = gettotalbytes(g);  /* first estimate */;\n      return work;\n    }\n    case GCSswpallgc: {  /* sweep \"regular\" objects */\n      return sweepstep(L, g, GCSswpfinobj, &g->finobj);\n    }\n    case GCSswpfinobj: {  /* sweep objects with finalizers */\n      return sweepstep(L, g, GCSswptobefnz, &g->tobefnz);\n    }\n    case GCSswptobefnz: {  /* sweep objects to be finalized */\n      return sweepstep(L, g, GCSswpend, NULL);\n    }\n    case GCSswpend: {  /* finish sweeps */\n      checkSizes(L, g);\n      g->gcstate = GCScallfin;\n      return 0;\n    }\n    case GCScallfin: {  /* call remaining finalizers */\n      if (g->tobefnz && !g->gcemergency) {\n        int n = runafewfinalizers(L, GCFINMAX);\n        return n * GCFINALIZECOST;\n      }\n      else {  /* emergency mode or no more finalizers */\n        g->gcstate = GCSpause;  /* finish collection */\n        return 0;\n      }\n    }\n    default: lua_assert(0); return 0;\n  }\n}\n\n\n/*\n** advances the garbage collector until it reaches a state allowed\n** by 'statemask'\n*/\nvoid luaC_runtilstate (lua_State *L, int statesmask) {\n  global_State *g = G(L);\n  while (!testbit(statesmask, g->gcstate))\n    singlestep(L);\n}\n\n\n/*\n** Performs a basic incremental step. The debt and step size are\n** converted from bytes to \"units of work\"; then the function loops\n** running single steps until adding that many units of work or\n** finishing a cycle (pause state). Finally, it sets the debt that\n** controls when next step will be performed.\n*/\nstatic void incstep (lua_State *L, global_State *g) {\n  int stepmul = (getgcparam(g->gcstepmul) | 1);  /* avoid division by 0 */\n  l_mem debt = (g->GCdebt / WORK2MEM) * stepmul;\n  l_mem stepsize = (g->gcstepsize <= log2maxs(l_mem))\n                 ? ((cast(l_mem, 1) << g->gcstepsize) / WORK2MEM) * stepmul\n                 : MAX_LMEM;  /* overflow; keep maximum value */\n  do {  /* repeat until pause or enough \"credit\" (negative debt) */\n    lu_mem work = singlestep(L);  /* perform one single step */\n    debt -= work;\n  } while (debt > -stepsize && g->gcstate != GCSpause);\n  if (g->gcstate == GCSpause)\n    setpause(g);  /* pause until next cycle */\n  else {\n    debt = (debt / stepmul) * WORK2MEM;  /* convert 'work units' to bytes */\n    luaE_setdebt(g, debt);\n  }\n}\n\n/*\n** performs a basic GC step if collector is running\n*/\nvoid luaC_step (lua_State *L) {\n  global_State *g = G(L);\n  lua_assert(!g->gcemergency);\n  if (g->gcrunning) {  /* running? */\n    if(isdecGCmodegen(g))\n      genstep(L, g);\n    else\n      incstep(L, g);\n  }\n}\n\n\n/*\n** Perform a full collection in incremental mode.\n** Before running the collection, check 'keepinvariant'; if it is true,\n** there may be some objects marked as black, so the collector has\n** to sweep all objects to turn them back to white (as white has not\n** changed, nothing will be collected).\n*/\nstatic void fullinc (lua_State *L, global_State *g) {\n  if (keepinvariant(g))  /* black objects? */\n    entersweep(L); /* sweep everything to turn them back to white */\n  /* finish any pending sweep phase to start a new cycle */\n  luaC_runtilstate(L, bitmask(GCSpause));\n  luaC_runtilstate(L, bitmask(GCScallfin));  /* run up to finalizers */\n  /* estimate must be correct after a full GC cycle */\n  lua_assert(g->GCestimate == gettotalbytes(g));\n  luaC_runtilstate(L, bitmask(GCSpause));  /* finish collection */\n  setpause(g);\n}\n\n\n/*\n** Performs a full GC cycle; if 'isemergency', set a flag to avoid\n** some operations which could change the interpreter state in some\n** unexpected ways (running finalizers and shrinking some structures).\n*/\nvoid luaC_fullgc (lua_State *L, int isemergency) {\n  global_State *g = G(L);\n  lua_assert(!g->gcemergency);\n  g->gcemergency = isemergency;  /* set flag */\n  if (g->gckind == KGC_INC)\n    fullinc(L, g);\n  else\n    fullgen(L, g);\n  g->gcemergency = 0;\n}\n\n/* }====================================================== */\n\n\n"], "fixing_code": ["/*\n** $Id: lgc.c $\n** Garbage Collector\n** See Copyright Notice in lua.h\n*/\n\n#define lgc_c\n#define LUA_CORE\n\n#include \"lprefix.h\"\n\n#include <stdio.h>\n#include <string.h>\n\n\n#include \"lua.h\"\n\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lfunc.h\"\n#include \"lgc.h\"\n#include \"lmem.h\"\n#include \"lobject.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n#include \"ltm.h\"\n\n\n/*\n** Maximum number of elements to sweep in each single step.\n** (Large enough to dissipate fixed overheads but small enough\n** to allow small steps for the collector.)\n*/\n#define GCSWEEPMAX\t100\n\n/*\n** Maximum number of finalizers to call in each single step.\n*/\n#define GCFINMAX\t10\n\n\n/*\n** Cost of calling one finalizer.\n*/\n#define GCFINALIZECOST\t50\n\n\n/*\n** The equivalent, in bytes, of one unit of \"work\" (visiting a slot,\n** sweeping an object, etc.)\n*/\n#define WORK2MEM\tsizeof(TValue)\n\n\n/*\n** macro to adjust 'pause': 'pause' is actually used like\n** 'pause / PAUSEADJ' (value chosen by tests)\n*/\n#define PAUSEADJ\t\t100\n\n\n/* mask to erase all color bits (plus gen. related stuff) */\n#define maskcolors\t(~(bitmask(BLACKBIT) | WHITEBITS | AGEBITS))\n\n\n/* macro to erase all color bits then sets only the current white bit */\n#define makewhite(g,x)\t\\\n (x->marked = cast_byte((x->marked & maskcolors) | luaC_white(g)))\n\n#define white2gray(x)\tresetbits(x->marked, WHITEBITS)\n#define black2gray(x)\tresetbit(x->marked, BLACKBIT)\n\n\n#define valiswhite(x)   (iscollectable(x) && iswhite(gcvalue(x)))\n\n#define keyiswhite(n)   (keyiscollectable(n) && iswhite(gckey(n)))\n\n\n#define checkconsistency(obj)  \\\n  lua_longassert(!iscollectable(obj) || righttt(obj))\n\n/*\n** Protected access to objects in values\n*/\n#define gcvalueN(o)     (iscollectable(o) ? gcvalue(o) : NULL)\n\n\n#define markvalue(g,o) { checkconsistency(o); \\\n  if (valiswhite(o)) reallymarkobject(g,gcvalue(o)); }\n\n#define markkey(g, n)\t{ if keyiswhite(n) reallymarkobject(g,gckey(n)); }\n\n#define markobject(g,t)\t{ if (iswhite(t)) reallymarkobject(g, obj2gco(t)); }\n\n/*\n** mark an object that can be NULL (either because it is really optional,\n** or it was stripped as debug info, or inside an uncompleted structure)\n*/\n#define markobjectN(g,t)\t{ if (t) markobject(g,t); }\n\nstatic void reallymarkobject (global_State *g, GCObject *o);\nstatic lu_mem atomic (lua_State *L);\nstatic void entersweep (lua_State *L);\n\n\n/*\n** {======================================================\n** Generic functions\n** =======================================================\n*/\n\n\n/*\n** one after last element in a hash array\n*/\n#define gnodelast(h)\tgnode(h, cast_sizet(sizenode(h)))\n\n\nstatic GCObject **getgclist (GCObject *o) {\n  switch (o->tt) {\n    case LUA_VTABLE: return &gco2t(o)->gclist;\n    case LUA_VLCL: return &gco2lcl(o)->gclist;\n    case LUA_VCCL: return &gco2ccl(o)->gclist;\n    case LUA_VTHREAD: return &gco2th(o)->gclist;\n    case LUA_VPROTO: return &gco2p(o)->gclist;\n    case LUA_VUSERDATA: {\n      Udata *u = gco2u(o);\n      lua_assert(u->nuvalue > 0);\n      return &u->gclist;\n    }\n    default: lua_assert(0); return 0;\n  }\n}\n\n\n/*\n** Link a collectable object 'o' with a known type into list pointed by 'p'.\n*/\n#define linkgclist(o,p)\t((o)->gclist = (p), (p) = obj2gco(o))\n\n\n/*\n** Link a generic collectable object 'o' into list pointed by 'p'.\n*/\n#define linkobjgclist(o,p) (*getgclist(o) = (p), (p) = obj2gco(o))\n\n\n\n/*\n** Clear keys for empty entries in tables. If entry is empty\n** and its key is not marked, mark its entry as dead. This allows the\n** collection of the key, but keeps its entry in the table (its removal\n** could break a chain). The main feature of a dead key is that it must\n** be different from any other value, to do not disturb searches.\n** Other places never manipulate dead keys, because its associated empty\n** value is enough to signal that the entry is logically empty.\n*/\nstatic void clearkey (Node *n) {\n  lua_assert(isempty(gval(n)));\n  if (keyiswhite(n))\n    setdeadkey(n);  /* unused and unmarked key; remove it */\n}\n\n\n/*\n** tells whether a key or value can be cleared from a weak\n** table. Non-collectable objects are never removed from weak\n** tables. Strings behave as 'values', so are never removed too. for\n** other objects: if really collected, cannot keep them; for objects\n** being finalized, keep them in keys, but not in values\n*/\nstatic int iscleared (global_State *g, const GCObject *o) {\n  if (o == NULL) return 0;  /* non-collectable value */\n  else if (novariant(o->tt) == LUA_TSTRING) {\n    markobject(g, o);  /* strings are 'values', so are never weak */\n    return 0;\n  }\n  else return iswhite(o);\n}\n\n\n/*\n** barrier that moves collector forward, that is, mark the white object\n** 'v' being pointed by the black object 'o'. (If in sweep phase, clear\n** the black object to white [sweep it] to avoid other barrier calls for\n** this same object.) In the generational mode, 'v' must also become\n** old, if 'o' is old; however, it cannot be changed directly to OLD,\n** because it may still point to non-old objects. So, it is marked as\n** OLD0. In the next cycle it will become OLD1, and in the next it\n** will finally become OLD (regular old).\n*/\nvoid luaC_barrier_ (lua_State *L, GCObject *o, GCObject *v) {\n  global_State *g = G(L);\n  lua_assert(isblack(o) && iswhite(v) && !isdead(g, v) && !isdead(g, o));\n  if (keepinvariant(g)) {  /* must keep invariant? */\n    reallymarkobject(g, v);  /* restore invariant */\n    if (isold(o)) {\n      lua_assert(!isold(v));  /* white object could not be old */\n      setage(v, G_OLD0);  /* restore generational invariant */\n    }\n  }\n  else {  /* sweep phase */\n    lua_assert(issweepphase(g));\n    makewhite(g, o);  /* mark main obj. as white to avoid other barriers */\n  }\n}\n\n\n/*\n** barrier that moves collector backward, that is, mark the black object\n** pointing to a white object as gray again.\n*/\nvoid luaC_barrierback_ (lua_State *L, GCObject *o) {\n  global_State *g = G(L);\n  lua_assert(isblack(o) && !isdead(g, o));\n  lua_assert(g->gckind != KGC_GEN || (isold(o) && getage(o) != G_TOUCHED1));\n  if (getage(o) != G_TOUCHED2)  /* not already in gray list? */\n    linkobjgclist(o, g->grayagain);  /* link it in 'grayagain' */\n  black2gray(o);  /* make object gray (again) */\n  setage(o, G_TOUCHED1);  /* touched in current cycle */\n}\n\n\nvoid luaC_fix (lua_State *L, GCObject *o) {\n  global_State *g = G(L);\n  lua_assert(g->allgc == o);  /* object must be 1st in 'allgc' list! */\n  white2gray(o);  /* they will be gray forever */\n  setage(o, G_OLD);  /* and old forever */\n  g->allgc = o->next;  /* remove object from 'allgc' list */\n  o->next = g->fixedgc;  /* link it to 'fixedgc' list */\n  g->fixedgc = o;\n}\n\n\n/*\n** create a new collectable object (with given type and size) and link\n** it to 'allgc' list.\n*/\nGCObject *luaC_newobj (lua_State *L, int tt, size_t sz) {\n  global_State *g = G(L);\n  GCObject *o = cast(GCObject *, luaM_newobject(L, novariant(tt), sz));\n  o->marked = luaC_white(g);\n  o->tt = tt;\n  o->next = g->allgc;\n  g->allgc = o;\n  return o;\n}\n\n/* }====================================================== */\n\n\n\n/*\n** {======================================================\n** Mark functions\n** =======================================================\n*/\n\n\n/*\n** Mark an object. Userdata, strings, and closed upvalues are visited\n** and turned black here. Other objects are marked gray and added\n** to appropriate list to be visited (and turned black) later. (Open\n** upvalues are already linked in 'headuv' list. They are kept gray\n** to avoid barriers, as their values will be revisited by the thread.)\n*/\nstatic void reallymarkobject (global_State *g, GCObject *o) {\n  white2gray(o);\n  switch (o->tt) {\n    case LUA_VSHRSTR:\n    case LUA_VLNGSTR: {\n      gray2black(o);\n      break;\n    }\n    case LUA_VUPVAL: {\n      UpVal *uv = gco2upv(o);\n      if (!upisopen(uv))  /* open upvalues are kept gray */\n        gray2black(o);\n      markvalue(g, uv->v);  /* mark its content */\n      break;\n    }\n    case LUA_VUSERDATA: {\n      Udata *u = gco2u(o);\n      if (u->nuvalue == 0) {  /* no user values? */\n        markobjectN(g, u->metatable);  /* mark its metatable */\n        gray2black(o);  /* nothing else to mark */\n        break;\n      }\n      /* else... */\n    }  /* FALLTHROUGH */\n    case LUA_VLCL: case LUA_VCCL: case LUA_VTABLE:\n    case LUA_VTHREAD: case LUA_VPROTO: {\n      linkobjgclist(o, g->gray);\n      break;\n    }\n    default: lua_assert(0); break;\n  }\n}\n\n\n/*\n** mark metamethods for basic types\n*/\nstatic void markmt (global_State *g) {\n  int i;\n  for (i=0; i < LUA_NUMTAGS; i++)\n    markobjectN(g, g->mt[i]);\n}\n\n\n/*\n** mark all objects in list of being-finalized\n*/\nstatic lu_mem markbeingfnz (global_State *g) {\n  GCObject *o;\n  lu_mem count = 0;\n  for (o = g->tobefnz; o != NULL; o = o->next) {\n    count++;\n    markobject(g, o);\n  }\n  return count;\n}\n\n\n/*\n** Mark all values stored in marked open upvalues from non-marked threads.\n** (Values from marked threads were already marked when traversing the\n** thread.) Remove from the list threads that no longer have upvalues and\n** not-marked threads.\n*/\nstatic int remarkupvals (global_State *g) {\n  lua_State *thread;\n  lua_State **p = &g->twups;\n  int work = 0;\n  while ((thread = *p) != NULL) {\n    work++;\n    lua_assert(!isblack(thread));  /* threads are never black */\n    if (isgray(thread) && thread->openupval != NULL)\n      p = &thread->twups;  /* keep marked thread with upvalues in the list */\n    else {  /* thread is not marked or without upvalues */\n      UpVal *uv;\n      *p = thread->twups;  /* remove thread from the list */\n      thread->twups = thread;  /* mark that it is out of list */\n      for (uv = thread->openupval; uv != NULL; uv = uv->u.open.next) {\n        work++;\n        if (!iswhite(uv))  /* upvalue already visited? */\n          markvalue(g, uv->v);  /* mark its value */\n      }\n    }\n  }\n  return work;\n}\n\n\n/*\n** mark root set and reset all gray lists, to start a new collection\n*/\nstatic void restartcollection (global_State *g) {\n  g->gray = g->grayagain = NULL;\n  g->weak = g->allweak = g->ephemeron = NULL;\n  markobject(g, g->mainthread);\n  markvalue(g, &g->l_registry);\n  markmt(g);\n  markbeingfnz(g);  /* mark any finalizing object left from previous cycle */\n}\n\n/* }====================================================== */\n\n\n/*\n** {======================================================\n** Traverse functions\n** =======================================================\n*/\n\n/*\n** Traverse a table with weak values and link it to proper list. During\n** propagate phase, keep it in 'grayagain' list, to be revisited in the\n** atomic phase. In the atomic phase, if table has any white value,\n** put it in 'weak' list, to be cleared.\n*/\nstatic void traverseweakvalue (global_State *g, Table *h) {\n  Node *n, *limit = gnodelast(h);\n  /* if there is array part, assume it may have white values (it is not\n     worth traversing it now just to check) */\n  int hasclears = (h->alimit > 0);\n  for (n = gnode(h, 0); n < limit; n++) {  /* traverse hash part */\n    if (isempty(gval(n)))  /* entry is empty? */\n      clearkey(n);  /* clear its key */\n    else {\n      lua_assert(!keyisnil(n));\n      markkey(g, n);\n      if (!hasclears && iscleared(g, gcvalueN(gval(n))))  /* a white value? */\n        hasclears = 1;  /* table will have to be cleared */\n    }\n  }\n  if (g->gcstate == GCSatomic && hasclears)\n    linkgclist(h, g->weak);  /* has to be cleared later */\n  else\n    linkgclist(h, g->grayagain);  /* must retraverse it in atomic phase */\n}\n\n\n/*\n** Traverse an ephemeron table and link it to proper list. Returns true\n** iff any object was marked during this traversal (which implies that\n** convergence has to continue). During propagation phase, keep table\n** in 'grayagain' list, to be visited again in the atomic phase. In\n** the atomic phase, if table has any white->white entry, it has to\n** be revisited during ephemeron convergence (as that key may turn\n** black). Otherwise, if it has any white key, table has to be cleared\n** (in the atomic phase). In generational mode, it (like all visited\n** tables) must be kept in some gray list for post-processing.\n*/\nstatic int traverseephemeron (global_State *g, Table *h, int inv) {\n  int marked = 0;  /* true if an object is marked in this traversal */\n  int hasclears = 0;  /* true if table has white keys */\n  int hasww = 0;  /* true if table has entry \"white-key -> white-value\" */\n  unsigned int i;\n  unsigned int asize = luaH_realasize(h);\n  unsigned int nsize = sizenode(h);\n  /* traverse array part */\n  for (i = 0; i < asize; i++) {\n    if (valiswhite(&h->array[i])) {\n      marked = 1;\n      reallymarkobject(g, gcvalue(&h->array[i]));\n    }\n  }\n  /* traverse hash part; if 'inv', traverse descending\n     (see 'convergeephemerons') */\n  for (i = 0; i < nsize; i++) {\n    Node *n = inv ? gnode(h, nsize - 1 - i) : gnode(h, i);\n    if (isempty(gval(n)))  /* entry is empty? */\n      clearkey(n);  /* clear its key */\n    else if (iscleared(g, gckeyN(n))) {  /* key is not marked (yet)? */\n      hasclears = 1;  /* table must be cleared */\n      if (valiswhite(gval(n)))  /* value not marked yet? */\n        hasww = 1;  /* white-white entry */\n    }\n    else if (valiswhite(gval(n))) {  /* value not marked yet? */\n      marked = 1;\n      reallymarkobject(g, gcvalue(gval(n)));  /* mark it now */\n    }\n  }\n  /* link table into proper list */\n  if (g->gcstate == GCSpropagate)\n    linkgclist(h, g->grayagain);  /* must retraverse it in atomic phase */\n  else if (hasww)  /* table has white->white entries? */\n    linkgclist(h, g->ephemeron);  /* have to propagate again */\n  else if (hasclears)  /* table has white keys? */\n    linkgclist(h, g->allweak);  /* may have to clean white keys */\n  else if (g->gckind == KGC_GEN)\n    linkgclist(h, g->grayagain);  /* keep it in some list */\n  else\n    gray2black(h);\n  return marked;\n}\n\n\nstatic void traversestrongtable (global_State *g, Table *h) {\n  Node *n, *limit = gnodelast(h);\n  unsigned int i;\n  unsigned int asize = luaH_realasize(h);\n  for (i = 0; i < asize; i++)  /* traverse array part */\n    markvalue(g, &h->array[i]);\n  for (n = gnode(h, 0); n < limit; n++) {  /* traverse hash part */\n    if (isempty(gval(n)))  /* entry is empty? */\n      clearkey(n);  /* clear its key */\n    else {\n      lua_assert(!keyisnil(n));\n      markkey(g, n);\n      markvalue(g, gval(n));\n    }\n  }\n  if (g->gckind == KGC_GEN) {\n    linkgclist(h, g->grayagain);  /* keep it in some gray list */\n    black2gray(h);\n  }\n}\n\n\nstatic lu_mem traversetable (global_State *g, Table *h) {\n  const char *weakkey, *weakvalue;\n  const TValue *mode = gfasttm(g, h->metatable, TM_MODE);\n  markobjectN(g, h->metatable);\n  if (mode && ttisstring(mode) &&  /* is there a weak mode? */\n      (cast_void(weakkey = strchr(svalue(mode), 'k')),\n       cast_void(weakvalue = strchr(svalue(mode), 'v')),\n       (weakkey || weakvalue))) {  /* is really weak? */\n    black2gray(h);  /* keep table gray */\n    if (!weakkey)  /* strong keys? */\n      traverseweakvalue(g, h);\n    else if (!weakvalue)  /* strong values? */\n      traverseephemeron(g, h, 0);\n    else  /* all weak */\n      linkgclist(h, g->allweak);  /* nothing to traverse now */\n  }\n  else  /* not weak */\n    traversestrongtable(g, h);\n  return 1 + h->alimit + 2 * allocsizenode(h);\n}\n\n\nstatic int traverseudata (global_State *g, Udata *u) {\n  int i;\n  markobjectN(g, u->metatable);  /* mark its metatable */\n  for (i = 0; i < u->nuvalue; i++)\n    markvalue(g, &u->uv[i].uv);\n  if (g->gckind == KGC_GEN) {\n    linkgclist(u, g->grayagain);  /* keep it in some gray list */\n    black2gray(u);\n  }\n  return 1 + u->nuvalue;\n}\n\n\n/*\n** Traverse a prototype. (While a prototype is being build, its\n** arrays can be larger than needed; the extra slots are filled with\n** NULL, so the use of 'markobjectN')\n*/\nstatic int traverseproto (global_State *g, Proto *f) {\n  int i;\n  markobjectN(g, f->source);\n  for (i = 0; i < f->sizek; i++)  /* mark literals */\n    markvalue(g, &f->k[i]);\n  for (i = 0; i < f->sizeupvalues; i++)  /* mark upvalue names */\n    markobjectN(g, f->upvalues[i].name);\n  for (i = 0; i < f->sizep; i++)  /* mark nested protos */\n    markobjectN(g, f->p[i]);\n  for (i = 0; i < f->sizelocvars; i++)  /* mark local-variable names */\n    markobjectN(g, f->locvars[i].varname);\n  return 1 + f->sizek + f->sizeupvalues + f->sizep + f->sizelocvars;\n}\n\n\nstatic int traverseCclosure (global_State *g, CClosure *cl) {\n  int i;\n  for (i = 0; i < cl->nupvalues; i++)  /* mark its upvalues */\n    markvalue(g, &cl->upvalue[i]);\n  return 1 + cl->nupvalues;\n}\n\n/*\n** Traverse a Lua closure, marking its prototype and its upvalues.\n** (Both can be NULL while closure is being created.)\n*/\nstatic int traverseLclosure (global_State *g, LClosure *cl) {\n  int i;\n  markobjectN(g, cl->p);  /* mark its prototype */\n  for (i = 0; i < cl->nupvalues; i++) {  /* visit its upvalues */\n    UpVal *uv = cl->upvals[i];\n    markobjectN(g, uv);  /* mark upvalue */\n  }\n  return 1 + cl->nupvalues;\n}\n\n\n/*\n** Traverse a thread, marking the elements in the stack up to its top\n** and cleaning the rest of the stack in the final traversal.\n** That ensures that the entire stack have valid (non-dead) objects.\n*/\nstatic int traversethread (global_State *g, lua_State *th) {\n  UpVal *uv;\n  StkId o = th->stack;\n  if (o == NULL)\n    return 1;  /* stack not completely built yet */\n  lua_assert(g->gcstate == GCSatomic ||\n             th->openupval == NULL || isintwups(th));\n  for (; o < th->top; o++)  /* mark live elements in the stack */\n    markvalue(g, s2v(o));\n  for (uv = th->openupval; uv != NULL; uv = uv->u.open.next)\n    markobject(g, uv);  /* open upvalues cannot be collected */\n  if (g->gcstate == GCSatomic) {  /* final traversal? */\n    StkId lim = th->stack + th->stacksize;  /* real end of stack */\n    for (; o < lim; o++)  /* clear not-marked stack slice */\n      setnilvalue(s2v(o));\n    /* 'remarkupvals' may have removed thread from 'twups' list */\n    if (!isintwups(th) && th->openupval != NULL) {\n      th->twups = g->twups;  /* link it back to the list */\n      g->twups = th;\n    }\n  }\n  else if (!g->gcemergency)\n    luaD_shrinkstack(th); /* do not change stack in emergency cycle */\n  return 1 + th->stacksize;\n}\n\n\n/*\n** traverse one gray object, turning it to black (except for threads,\n** which are always gray).\n*/\nstatic lu_mem propagatemark (global_State *g) {\n  GCObject *o = g->gray;\n  gray2black(o);\n  g->gray = *getgclist(o);  /* remove from 'gray' list */\n  switch (o->tt) {\n    case LUA_VTABLE: return traversetable(g, gco2t(o));\n    case LUA_VUSERDATA: return traverseudata(g, gco2u(o));\n    case LUA_VLCL: return traverseLclosure(g, gco2lcl(o));\n    case LUA_VCCL: return traverseCclosure(g, gco2ccl(o));\n    case LUA_VPROTO: return traverseproto(g, gco2p(o));\n    case LUA_VTHREAD: {\n      lua_State *th = gco2th(o);\n      linkgclist(th, g->grayagain);  /* insert into 'grayagain' list */\n      black2gray(o);\n      return traversethread(g, th);\n    }\n    default: lua_assert(0); return 0;\n  }\n}\n\n\nstatic lu_mem propagateall (global_State *g) {\n  lu_mem tot = 0;\n  while (g->gray)\n    tot += propagatemark(g);\n  return tot;\n}\n\n\n/*\n** Traverse all ephemeron tables propagating marks from keys to values.\n** Repeat until it converges, that is, nothing new is marked. 'dir'\n** inverts the direction of the traversals, trying to speed up\n** convergence on chains in the same table.\n**\n*/\nstatic void convergeephemerons (global_State *g) {\n  int changed;\n  int dir = 0;\n  do {\n    GCObject *w;\n    GCObject *next = g->ephemeron;  /* get ephemeron list */\n    g->ephemeron = NULL;  /* tables may return to this list when traversed */\n    changed = 0;\n    while ((w = next) != NULL) {  /* for each ephemeron table */\n      next = gco2t(w)->gclist;  /* list is rebuilt during loop */\n      if (traverseephemeron(g, gco2t(w), dir)) {  /* marked some value? */\n        propagateall(g);  /* propagate changes */\n        changed = 1;  /* will have to revisit all ephemeron tables */\n      }\n    }\n    dir = !dir;  /* invert direction next time */\n  } while (changed);  /* repeat until no more changes */\n}\n\n/* }====================================================== */\n\n\n/*\n** {======================================================\n** Sweep Functions\n** =======================================================\n*/\n\n\n/*\n** clear entries with unmarked keys from all weaktables in list 'l'\n*/\nstatic void clearbykeys (global_State *g, GCObject *l) {\n  for (; l; l = gco2t(l)->gclist) {\n    Table *h = gco2t(l);\n    Node *limit = gnodelast(h);\n    Node *n;\n    for (n = gnode(h, 0); n < limit; n++) {\n      if (iscleared(g, gckeyN(n)))  /* unmarked key? */\n        setempty(gval(n));  /* remove entry */\n      if (isempty(gval(n)))  /* is entry empty? */\n        clearkey(n);  /* clear its key */\n    }\n  }\n}\n\n\n/*\n** clear entries with unmarked values from all weaktables in list 'l' up\n** to element 'f'\n*/\nstatic void clearbyvalues (global_State *g, GCObject *l, GCObject *f) {\n  for (; l != f; l = gco2t(l)->gclist) {\n    Table *h = gco2t(l);\n    Node *n, *limit = gnodelast(h);\n    unsigned int i;\n    unsigned int asize = luaH_realasize(h);\n    for (i = 0; i < asize; i++) {\n      TValue *o = &h->array[i];\n      if (iscleared(g, gcvalueN(o)))  /* value was collected? */\n        setempty(o);  /* remove entry */\n    }\n    for (n = gnode(h, 0); n < limit; n++) {\n      if (iscleared(g, gcvalueN(gval(n))))  /* unmarked value? */\n        setempty(gval(n));  /* remove entry */\n      if (isempty(gval(n)))  /* is entry empty? */\n        clearkey(n);  /* clear its key */\n    }\n  }\n}\n\n\nstatic void freeupval (lua_State *L, UpVal *uv) {\n  if (upisopen(uv))\n    luaF_unlinkupval(uv);\n  luaM_free(L, uv);\n}\n\n\nstatic void freeobj (lua_State *L, GCObject *o) {\n  switch (o->tt) {\n    case LUA_VPROTO:\n      luaF_freeproto(L, gco2p(o));\n      break;\n    case LUA_VUPVAL:\n      freeupval(L, gco2upv(o));\n      break;\n    case LUA_VLCL:\n      luaM_freemem(L, o, sizeLclosure(gco2lcl(o)->nupvalues));\n      break;\n    case LUA_VCCL:\n      luaM_freemem(L, o, sizeCclosure(gco2ccl(o)->nupvalues));\n      break;\n    case LUA_VTABLE:\n      luaH_free(L, gco2t(o));\n      break;\n    case LUA_VTHREAD:\n      luaE_freethread(L, gco2th(o));\n      break;\n    case LUA_VUSERDATA: {\n      Udata *u = gco2u(o);\n      luaM_freemem(L, o, sizeudata(u->nuvalue, u->len));\n      break;\n    }\n    case LUA_VSHRSTR:\n      luaS_remove(L, gco2ts(o));  /* remove it from hash table */\n      luaM_freemem(L, o, sizelstring(gco2ts(o)->shrlen));\n      break;\n    case LUA_VLNGSTR:\n      luaM_freemem(L, o, sizelstring(gco2ts(o)->u.lnglen));\n      break;\n    default: lua_assert(0);\n  }\n}\n\n\n/*\n** sweep at most 'countin' elements from a list of GCObjects erasing dead\n** objects, where a dead object is one marked with the old (non current)\n** white; change all non-dead objects back to white, preparing for next\n** collection cycle. Return where to continue the traversal or NULL if\n** list is finished. ('*countout' gets the number of elements traversed.)\n*/\nstatic GCObject **sweeplist (lua_State *L, GCObject **p, int countin,\n                             int *countout) {\n  global_State *g = G(L);\n  int ow = otherwhite(g);\n  int i;\n  int white = luaC_white(g);  /* current white */\n  for (i = 0; *p != NULL && i < countin; i++) {\n    GCObject *curr = *p;\n    int marked = curr->marked;\n    if (isdeadm(ow, marked)) {  /* is 'curr' dead? */\n      *p = curr->next;  /* remove 'curr' from list */\n      freeobj(L, curr);  /* erase 'curr' */\n    }\n    else {  /* change mark to 'white' */\n      curr->marked = cast_byte((marked & maskcolors) | white);\n      p = &curr->next;  /* go to next element */\n    }\n  }\n  if (countout)\n    *countout = i;  /* number of elements traversed */\n  return (*p == NULL) ? NULL : p;\n}\n\n\n/*\n** sweep a list until a live object (or end of list)\n*/\nstatic GCObject **sweeptolive (lua_State *L, GCObject **p) {\n  GCObject **old = p;\n  do {\n    p = sweeplist(L, p, 1, NULL);\n  } while (p == old);\n  return p;\n}\n\n/* }====================================================== */\n\n\n/*\n** {======================================================\n** Finalization\n** =======================================================\n*/\n\n/*\n** If possible, shrink string table.\n*/\nstatic void checkSizes (lua_State *L, global_State *g) {\n  if (!g->gcemergency) {\n    if (g->strt.nuse < g->strt.size / 4) {  /* string table too big? */\n      l_mem olddebt = g->GCdebt;\n      luaS_resize(L, g->strt.size / 2);\n      g->GCestimate += g->GCdebt - olddebt;  /* correct estimate */\n    }\n  }\n}\n\n\n/*\n** Get the next udata to be finalized from the 'tobefnz' list, and\n** link it back into the 'allgc' list.\n*/\nstatic GCObject *udata2finalize (global_State *g) {\n  GCObject *o = g->tobefnz;  /* get first element */\n  lua_assert(tofinalize(o));\n  g->tobefnz = o->next;  /* remove it from 'tobefnz' list */\n  o->next = g->allgc;  /* return it to 'allgc' list */\n  g->allgc = o;\n  resetbit(o->marked, FINALIZEDBIT);  /* object is \"normal\" again */\n  if (issweepphase(g))\n    makewhite(g, o);  /* \"sweep\" object */\n  return o;\n}\n\n\nstatic void dothecall (lua_State *L, void *ud) {\n  UNUSED(ud);\n  luaD_callnoyield(L, L->top - 2, 0);\n}\n\n\nstatic void GCTM (lua_State *L) {\n  global_State *g = G(L);\n  const TValue *tm;\n  TValue v;\n  lua_assert(!g->gcemergency);\n  setgcovalue(L, &v, udata2finalize(g));\n  tm = luaT_gettmbyobj(L, &v, TM_GC);\n  if (!notm(tm)) {  /* is there a finalizer? */\n    int status;\n    lu_byte oldah = L->allowhook;\n    int running  = g->gcrunning;\n    L->allowhook = 0;  /* stop debug hooks during GC metamethod */\n    g->gcrunning = 0;  /* avoid GC steps */\n    setobj2s(L, L->top++, tm);  /* push finalizer... */\n    setobj2s(L, L->top++, &v);  /* ... and its argument */\n    L->ci->callstatus |= CIST_FIN;  /* will run a finalizer */\n    status = luaD_pcall(L, dothecall, NULL, savestack(L, L->top - 2), 0);\n    L->ci->callstatus &= ~CIST_FIN;  /* not running a finalizer anymore */\n    L->allowhook = oldah;  /* restore hooks */\n    g->gcrunning = running;  /* restore state */\n    if (unlikely(status != LUA_OK)) {  /* error while running __gc? */\n      luaE_warnerror(L, \"__gc metamethod\");\n      L->top--;  /* pops error object */\n    }\n  }\n}\n\n\n/*\n** Call a few finalizers\n*/\nstatic int runafewfinalizers (lua_State *L, int n) {\n  global_State *g = G(L);\n  int i;\n  for (i = 0; i < n && g->tobefnz; i++)\n    GCTM(L);  /* call one finalizer */\n  return i;\n}\n\n\n/*\n** call all pending finalizers\n*/\nstatic void callallpendingfinalizers (lua_State *L) {\n  global_State *g = G(L);\n  while (g->tobefnz)\n    GCTM(L);\n}\n\n\n/*\n** find last 'next' field in list 'p' list (to add elements in its end)\n*/\nstatic GCObject **findlast (GCObject **p) {\n  while (*p != NULL)\n    p = &(*p)->next;\n  return p;\n}\n\n\n/*\n** Move all unreachable objects (or 'all' objects) that need\n** finalization from list 'finobj' to list 'tobefnz' (to be finalized).\n** (Note that objects after 'finobjold' cannot be white, so they\n** don't need to be traversed. In incremental mode, 'finobjold' is NULL,\n** so the whole list is traversed.)\n*/\nstatic void separatetobefnz (global_State *g, int all) {\n  GCObject *curr;\n  GCObject **p = &g->finobj;\n  GCObject **lastnext = findlast(&g->tobefnz);\n  while ((curr = *p) != g->finobjold) {  /* traverse all finalizable objects */\n    lua_assert(tofinalize(curr));\n    if (!(iswhite(curr) || all))  /* not being collected? */\n      p = &curr->next;  /* don't bother with it */\n    else {\n      if (curr == g->finobjsur)  /* removing 'finobjsur'? */\n        g->finobjsur = curr->next;  /* correct it */\n      *p = curr->next;  /* remove 'curr' from 'finobj' list */\n      curr->next = *lastnext;  /* link at the end of 'tobefnz' list */\n      *lastnext = curr;\n      lastnext = &curr->next;\n    }\n  }\n}\n\n\n/*\n** if object 'o' has a finalizer, remove it from 'allgc' list (must\n** search the list to find it) and link it in 'finobj' list.\n*/\nvoid luaC_checkfinalizer (lua_State *L, GCObject *o, Table *mt) {\n  global_State *g = G(L);\n  if (tofinalize(o) ||                 /* obj. is already marked... */\n      gfasttm(g, mt, TM_GC) == NULL)   /* or has no finalizer? */\n    return;  /* nothing to be done */\n  else {  /* move 'o' to 'finobj' list */\n    GCObject **p;\n    if (issweepphase(g)) {\n      makewhite(g, o);  /* \"sweep\" object 'o' */\n      if (g->sweepgc == &o->next)  /* should not remove 'sweepgc' object */\n        g->sweepgc = sweeptolive(L, g->sweepgc);  /* change 'sweepgc' */\n    }\n    else {  /* correct pointers into 'allgc' list, if needed */\n      if (o == g->survival)\n        g->survival = o->next;\n      if (o == g->old)\n        g->old = o->next;\n      if (o == g->reallyold)\n        g->reallyold = o->next;\n    }\n    /* search for pointer pointing to 'o' */\n    for (p = &g->allgc; *p != o; p = &(*p)->next) { /* empty */ }\n    *p = o->next;  /* remove 'o' from 'allgc' list */\n    o->next = g->finobj;  /* link it in 'finobj' list */\n    g->finobj = o;\n    l_setbit(o->marked, FINALIZEDBIT);  /* mark it as such */\n  }\n}\n\n/* }====================================================== */\n\n\n/*\n** {======================================================\n** Generational Collector\n** =======================================================\n*/\n\nstatic void setpause (global_State *g);\n\n\n/* mask to erase all color bits, not changing gen-related stuff */\n#define maskgencolors\t(~(bitmask(BLACKBIT) | WHITEBITS))\n\n\n/*\n** Sweep a list of objects, deleting dead ones and turning\n** the non dead to old (without changing their colors).\n*/\nstatic void sweep2old (lua_State *L, GCObject **p) {\n  GCObject *curr;\n  while ((curr = *p) != NULL) {\n    if (iswhite(curr)) {  /* is 'curr' dead? */\n      lua_assert(isdead(G(L), curr));\n      *p = curr->next;  /* remove 'curr' from list */\n      freeobj(L, curr);  /* erase 'curr' */\n    }\n    else {  /* all surviving objects become old */\n      setage(curr, G_OLD);\n      p = &curr->next;  /* go to next element */\n    }\n  }\n}\n\n\n/*\n** Sweep for generational mode. Delete dead objects. (Because the\n** collection is not incremental, there are no \"new white\" objects\n** during the sweep. So, any white object must be dead.) For\n** non-dead objects, advance their ages and clear the color of\n** new objects. (Old objects keep their colors.)\n*/\nstatic GCObject **sweepgen (lua_State *L, global_State *g, GCObject **p,\n                            GCObject *limit) {\n  static const lu_byte nextage[] = {\n    G_SURVIVAL,  /* from G_NEW */\n    G_OLD1,      /* from G_SURVIVAL */\n    G_OLD1,      /* from G_OLD0 */\n    G_OLD,       /* from G_OLD1 */\n    G_OLD,       /* from G_OLD (do not change) */\n    G_TOUCHED1,  /* from G_TOUCHED1 (do not change) */\n    G_TOUCHED2   /* from G_TOUCHED2 (do not change) */\n  };\n  int white = luaC_white(g);\n  GCObject *curr;\n  while ((curr = *p) != limit) {\n    if (iswhite(curr)) {  /* is 'curr' dead? */\n      lua_assert(!isold(curr) && isdead(g, curr));\n      *p = curr->next;  /* remove 'curr' from list */\n      freeobj(L, curr);  /* erase 'curr' */\n    }\n    else {  /* correct mark and age */\n      if (getage(curr) == G_NEW)\n        curr->marked = cast_byte((curr->marked & maskgencolors) | white);\n      setage(curr, nextage[getage(curr)]);\n      p = &curr->next;  /* go to next element */\n    }\n  }\n  return p;\n}\n\n\n/*\n** Traverse a list making all its elements white and clearing their\n** age.\n*/\nstatic void whitelist (global_State *g, GCObject *p) {\n  int white = luaC_white(g);\n  for (; p != NULL; p = p->next)\n    p->marked = cast_byte((p->marked & maskcolors) | white);\n}\n\n\n/*\n** Correct a list of gray objects.\n** Because this correction is done after sweeping, young objects might\n** be turned white and still be in the list. They are only removed.\n** For tables and userdata, advance 'touched1' to 'touched2'; 'touched2'\n** objects become regular old and are removed from the list.\n** For threads, just remove white ones from the list.\n*/\nstatic GCObject **correctgraylist (GCObject **p) {\n  GCObject *curr;\n  while ((curr = *p) != NULL) {\n    switch (curr->tt) {\n      case LUA_VTABLE: case LUA_VUSERDATA: {\n        GCObject **next = getgclist(curr);\n        if (getage(curr) == G_TOUCHED1) {  /* touched in this cycle? */\n          lua_assert(isgray(curr));\n          gray2black(curr);  /* make it black, for next barrier */\n          changeage(curr, G_TOUCHED1, G_TOUCHED2);\n          p = next;  /* go to next element */\n        }\n        else {  /* not touched in this cycle */\n          if (!iswhite(curr)) {  /* not white? */\n            lua_assert(isold(curr));\n            if (getage(curr) == G_TOUCHED2)  /* advance from G_TOUCHED2... */\n              changeage(curr, G_TOUCHED2, G_OLD);  /* ... to G_OLD */\n            gray2black(curr);  /* make it black */\n          }\n          /* else, object is white: just remove it from this list */\n          *p = *next;  /* remove 'curr' from gray list */\n        }\n        break;\n      }\n      case LUA_VTHREAD: {\n        lua_State *th = gco2th(curr);\n        lua_assert(!isblack(th));\n        if (iswhite(th))  /* new object? */\n          *p = th->gclist;  /* remove from gray list */\n        else  /* old threads remain gray */\n          p = &th->gclist;  /* go to next element */\n        break;\n      }\n      default: lua_assert(0);  /* nothing more could be gray here */\n    }\n  }\n  return p;\n}\n\n\n/*\n** Correct all gray lists, coalescing them into 'grayagain'.\n*/\nstatic void correctgraylists (global_State *g) {\n  GCObject **list = correctgraylist(&g->grayagain);\n  *list = g->weak; g->weak = NULL;\n  list = correctgraylist(list);\n  *list = g->allweak; g->allweak = NULL;\n  list = correctgraylist(list);\n  *list = g->ephemeron; g->ephemeron = NULL;\n  correctgraylist(list);\n}\n\n\n/*\n** Mark 'OLD1' objects when starting a new young collection.\n** Gray objects are already in some gray list, and so will be visited\n** in the atomic step.\n*/\nstatic void markold (global_State *g, GCObject *from, GCObject *to) {\n  GCObject *p;\n  for (p = from; p != to; p = p->next) {\n    if (getage(p) == G_OLD1) {\n      lua_assert(!iswhite(p));\n      if (isblack(p)) {\n        black2gray(p);  /* should be '2white', but gray works too */\n        reallymarkobject(g, p);\n      }\n    }\n  }\n}\n\n\n/*\n** Finish a young-generation collection.\n*/\nstatic void finishgencycle (lua_State *L, global_State *g) {\n  correctgraylists(g);\n  checkSizes(L, g);\n  g->gcstate = GCSpropagate;  /* skip restart */\n  if (!g->gcemergency)\n    callallpendingfinalizers(L);\n}\n\n\n/*\n** Does a young collection. First, mark 'OLD1' objects. Then does the\n** atomic step. Then, sweep all lists and advance pointers. Finally,\n** finish the collection.\n*/\nstatic void youngcollection (lua_State *L, global_State *g) {\n  GCObject **psurvival;  /* to point to first non-dead survival object */\n  lua_assert(g->gcstate == GCSpropagate);\n  markold(g, g->allgc, g->reallyold);\n  markold(g, g->finobj, g->finobjrold);\n  atomic(L);\n\n  /* sweep nursery and get a pointer to its last live element */\n  psurvival = sweepgen(L, g, &g->allgc, g->survival);\n  /* sweep 'survival' and 'old' */\n  sweepgen(L, g, psurvival, g->reallyold);\n  g->reallyold = g->old;\n  g->old = *psurvival;  /* 'survival' survivals are old now */\n  g->survival = g->allgc;  /* all news are survivals */\n\n  /* repeat for 'finobj' lists */\n  psurvival = sweepgen(L, g, &g->finobj, g->finobjsur);\n  /* sweep 'survival' and 'old' */\n  sweepgen(L, g, psurvival, g->finobjrold);\n  g->finobjrold = g->finobjold;\n  g->finobjold = *psurvival;  /* 'survival' survivals are old now */\n  g->finobjsur = g->finobj;  /* all news are survivals */\n\n  sweepgen(L, g, &g->tobefnz, NULL);\n\n  finishgencycle(L, g);\n}\n\n\nstatic void atomic2gen (lua_State *L, global_State *g) {\n  /* sweep all elements making them old */\n  sweep2old(L, &g->allgc);\n  /* everything alive now is old */\n  g->reallyold = g->old = g->survival = g->allgc;\n\n  /* repeat for 'finobj' lists */\n  sweep2old(L, &g->finobj);\n  g->finobjrold = g->finobjold = g->finobjsur = g->finobj;\n\n  sweep2old(L, &g->tobefnz);\n\n  g->gckind = KGC_GEN;\n  g->lastatomic = 0;\n  g->GCestimate = gettotalbytes(g);  /* base for memory control */\n  finishgencycle(L, g);\n}\n\n\n/*\n** Enter generational mode. Must go until the end of an atomic cycle\n** to ensure that all threads and weak tables are in the gray lists.\n** Then, turn all objects into old and finishes the collection.\n*/\nstatic lu_mem entergen (lua_State *L, global_State *g) {\n  lu_mem numobjs;\n  luaC_runtilstate(L, bitmask(GCSpause));  /* prepare to start a new cycle */\n  luaC_runtilstate(L, bitmask(GCSpropagate));  /* start new cycle */\n  numobjs = atomic(L);  /* propagates all and then do the atomic stuff */\n  atomic2gen(L, g);\n  return numobjs;\n}\n\n\n/*\n** Enter incremental mode. Turn all objects white, make all\n** intermediate lists point to NULL (to avoid invalid pointers),\n** and go to the pause state.\n*/\nstatic void enterinc (global_State *g) {\n  whitelist(g, g->allgc);\n  g->reallyold = g->old = g->survival = NULL;\n  whitelist(g, g->finobj);\n  whitelist(g, g->tobefnz);\n  g->finobjrold = g->finobjold = g->finobjsur = NULL;\n  g->gcstate = GCSpause;\n  g->gckind = KGC_INC;\n  g->lastatomic = 0;\n}\n\n\n/*\n** Change collector mode to 'newmode'.\n*/\nvoid luaC_changemode (lua_State *L, int newmode) {\n  global_State *g = G(L);\n  if (newmode != g->gckind) {\n    if (newmode == KGC_GEN)  /* entering generational mode? */\n      entergen(L, g);\n    else\n      enterinc(g);  /* entering incremental mode */\n  }\n  g->lastatomic = 0;\n}\n\n\n/*\n** Does a full collection in generational mode.\n*/\nstatic lu_mem fullgen (lua_State *L, global_State *g) {\n  enterinc(g);\n  return entergen(L, g);\n}\n\n\n/*\n** Set debt for the next minor collection, which will happen when\n** memory grows 'genminormul'%.\n*/\nstatic void setminordebt (global_State *g) {\n  luaE_setdebt(g, -(cast(l_mem, (gettotalbytes(g) / 100)) * g->genminormul));\n}\n\n\n/*\n** Does a major collection after last collection was a \"bad collection\".\n**\n** When the program is building a big structure, it allocates lots of\n** memory but generates very little garbage. In those scenarios,\n** the generational mode just wastes time doing small collections, and\n** major collections are frequently what we call a \"bad collection\", a\n** collection that frees too few objects. To avoid the cost of switching\n** between generational mode and the incremental mode needed for full\n** (major) collections, the collector tries to stay in incremental mode\n** after a bad collection, and to switch back to generational mode only\n** after a \"good\" collection (one that traverses less than 9/8 objects\n** of the previous one).\n** The collector must choose whether to stay in incremental mode or to\n** switch back to generational mode before sweeping. At this point, it\n** does not know the real memory in use, so it cannot use memory to\n** decide whether to return to generational mode. Instead, it uses the\n** number of objects traversed (returned by 'atomic') as a proxy. The\n** field 'g->lastatomic' keeps this count from the last collection.\n** ('g->lastatomic != 0' also means that the last collection was bad.)\n*/\nstatic void stepgenfull (lua_State *L, global_State *g) {\n  lu_mem newatomic;  /* count of traversed objects */\n  lu_mem lastatomic = g->lastatomic;  /* count from last collection */\n  if (g->gckind == KGC_GEN)  /* still in generational mode? */\n    enterinc(g);  /* enter incremental mode */\n  luaC_runtilstate(L, bitmask(GCSpropagate));  /* start new cycle */\n  newatomic = atomic(L);  /* mark everybody */\n  if (newatomic < lastatomic + (lastatomic >> 3)) {  /* good collection? */\n    atomic2gen(L, g);  /* return to generational mode */\n    setminordebt(g);\n  }\n  else {  /* another bad collection; stay in incremental mode */\n    g->GCestimate = gettotalbytes(g);  /* first estimate */;\n    entersweep(L);\n    luaC_runtilstate(L, bitmask(GCSpause));  /* finish collection */\n    setpause(g);\n    g->lastatomic = newatomic;\n  }\n}\n\n\n/*\n** Does a generational \"step\".\n** Usually, this means doing a minor collection and setting the debt to\n** make another collection when memory grows 'genminormul'% larger.\n**\n** However, there are exceptions.  If memory grows 'genmajormul'%\n** larger than it was at the end of the last major collection (kept\n** in 'g->GCestimate'), the function does a major collection. At the\n** end, it checks whether the major collection was able to free a\n** decent amount of memory (at least half the growth in memory since\n** previous major collection). If so, the collector keeps its state,\n** and the next collection will probably be minor again. Otherwise,\n** we have what we call a \"bad collection\". In that case, set the field\n** 'g->lastatomic' to signal that fact, so that the next collection will\n** go to 'stepgenfull'.\n**\n** 'GCdebt <= 0' means an explicit call to GC step with \"size\" zero;\n** in that case, do a minor collection.\n*/\nstatic void genstep (lua_State *L, global_State *g) {\n  if (g->lastatomic != 0)  /* last collection was a bad one? */\n    stepgenfull(L, g);  /* do a full step */\n  else {\n    lu_mem majorbase = g->GCestimate;  /* memory after last major collection */\n    lu_mem majorinc = (majorbase / 100) * getgcparam(g->genmajormul);\n    if (g->GCdebt > 0 && gettotalbytes(g) > majorbase + majorinc) {\n      lu_mem numobjs = fullgen(L, g);  /* do a major collection */\n      if (gettotalbytes(g) < majorbase + (majorinc / 2)) {\n        /* collected at least half of memory growth since last major\n           collection; keep doing minor collections */\n        setminordebt(g);\n      }\n      else {  /* bad collection */\n        g->lastatomic = numobjs;  /* signal that last collection was bad */\n        setpause(g);  /* do a long wait for next (major) collection */\n      }\n    }\n    else {  /* regular case; do a minor collection */\n      youngcollection(L, g);\n      setminordebt(g);\n      g->GCestimate = majorbase;  /* preserve base value */\n    }\n  }\n  lua_assert(isdecGCmodegen(g));\n}\n\n/* }====================================================== */\n\n\n/*\n** {======================================================\n** GC control\n** =======================================================\n*/\n\n\n/*\n** Set the \"time\" to wait before starting a new GC cycle; cycle will\n** start when memory use hits the threshold of ('estimate' * pause /\n** PAUSEADJ). (Division by 'estimate' should be OK: it cannot be zero,\n** because Lua cannot even start with less than PAUSEADJ bytes).\n*/\nstatic void setpause (global_State *g) {\n  l_mem threshold, debt;\n  int pause = getgcparam(g->gcpause);\n  l_mem estimate = g->GCestimate / PAUSEADJ;  /* adjust 'estimate' */\n  lua_assert(estimate > 0);\n  threshold = (pause < MAX_LMEM / estimate)  /* overflow? */\n            ? estimate * pause  /* no overflow */\n            : MAX_LMEM;  /* overflow; truncate to maximum */\n  debt = gettotalbytes(g) - threshold;\n  if (debt > 0) debt = 0;\n  luaE_setdebt(g, debt);\n}\n\n\n/*\n** Enter first sweep phase.\n** The call to 'sweeptolive' makes the pointer point to an object\n** inside the list (instead of to the header), so that the real sweep do\n** not need to skip objects created between \"now\" and the start of the\n** real sweep.\n*/\nstatic void entersweep (lua_State *L) {\n  global_State *g = G(L);\n  g->gcstate = GCSswpallgc;\n  lua_assert(g->sweepgc == NULL);\n  g->sweepgc = sweeptolive(L, &g->allgc);\n}\n\n\n/*\n** Delete all objects in list 'p' until (but not including) object\n** 'limit'.\n*/\nstatic void deletelist (lua_State *L, GCObject *p, GCObject *limit) {\n  while (p != limit) {\n    GCObject *next = p->next;\n    freeobj(L, p);\n    p = next;\n  }\n}\n\n\n/*\n** Call all finalizers of the objects in the given Lua state, and\n** then free all objects, except for the main thread.\n*/\nvoid luaC_freeallobjects (lua_State *L) {\n  global_State *g = G(L);\n  luaC_changemode(L, KGC_INC);\n  separatetobefnz(g, 1);  /* separate all objects with finalizers */\n  lua_assert(g->finobj == NULL);\n  callallpendingfinalizers(L);\n  deletelist(L, g->allgc, obj2gco(g->mainthread));\n  deletelist(L, g->finobj, NULL);\n  deletelist(L, g->fixedgc, NULL);  /* collect fixed objects */\n  lua_assert(g->strt.nuse == 0);\n}\n\n\nstatic lu_mem atomic (lua_State *L) {\n  global_State *g = G(L);\n  lu_mem work = 0;\n  GCObject *origweak, *origall;\n  GCObject *grayagain = g->grayagain;  /* save original list */\n  g->grayagain = NULL;\n  lua_assert(g->ephemeron == NULL && g->weak == NULL);\n  lua_assert(!iswhite(g->mainthread));\n  g->gcstate = GCSatomic;\n  markobject(g, L);  /* mark running thread */\n  /* registry and global metatables may be changed by API */\n  markvalue(g, &g->l_registry);\n  markmt(g);  /* mark global metatables */\n  work += propagateall(g);  /* empties 'gray' list */\n  /* remark occasional upvalues of (maybe) dead threads */\n  work += remarkupvals(g);\n  work += propagateall(g);  /* propagate changes */\n  g->gray = grayagain;\n  work += propagateall(g);  /* traverse 'grayagain' list */\n  convergeephemerons(g);\n  /* at this point, all strongly accessible objects are marked. */\n  /* Clear values from weak tables, before checking finalizers */\n  clearbyvalues(g, g->weak, NULL);\n  clearbyvalues(g, g->allweak, NULL);\n  origweak = g->weak; origall = g->allweak;\n  separatetobefnz(g, 0);  /* separate objects to be finalized */\n  work += markbeingfnz(g);  /* mark objects that will be finalized */\n  work += propagateall(g);  /* remark, to propagate 'resurrection' */\n  convergeephemerons(g);\n  /* at this point, all resurrected objects are marked. */\n  /* remove dead objects from weak tables */\n  clearbykeys(g, g->ephemeron);  /* clear keys from all ephemeron tables */\n  clearbykeys(g, g->allweak);  /* clear keys from all 'allweak' tables */\n  /* clear values from resurrected weak tables */\n  clearbyvalues(g, g->weak, origweak);\n  clearbyvalues(g, g->allweak, origall);\n  luaS_clearcache(g);\n  g->currentwhite = cast_byte(otherwhite(g));  /* flip current white */\n  lua_assert(g->gray == NULL);\n  return work;  /* estimate of slots marked by 'atomic' */\n}\n\n\nstatic int sweepstep (lua_State *L, global_State *g,\n                      int nextstate, GCObject **nextlist) {\n  if (g->sweepgc) {\n    l_mem olddebt = g->GCdebt;\n    int count;\n    g->sweepgc = sweeplist(L, g->sweepgc, GCSWEEPMAX, &count);\n    g->GCestimate += g->GCdebt - olddebt;  /* update estimate */\n    return count;\n  }\n  else {  /* enter next state */\n    g->gcstate = nextstate;\n    g->sweepgc = nextlist;\n    return 0;  /* no work done */\n  }\n}\n\n\nstatic lu_mem singlestep (lua_State *L) {\n  global_State *g = G(L);\n  switch (g->gcstate) {\n    case GCSpause: {\n      restartcollection(g);\n      g->gcstate = GCSpropagate;\n      return 1;\n    }\n    case GCSpropagate: {\n      if (g->gray == NULL) {  /* no more gray objects? */\n        g->gcstate = GCSenteratomic;  /* finish propagate phase */\n        return 0;\n      }\n      else\n        return propagatemark(g);  /* traverse one gray object */\n    }\n    case GCSenteratomic: {\n      lu_mem work = atomic(L);  /* work is what was traversed by 'atomic' */\n      entersweep(L);\n      g->GCestimate = gettotalbytes(g);  /* first estimate */;\n      return work;\n    }\n    case GCSswpallgc: {  /* sweep \"regular\" objects */\n      return sweepstep(L, g, GCSswpfinobj, &g->finobj);\n    }\n    case GCSswpfinobj: {  /* sweep objects with finalizers */\n      return sweepstep(L, g, GCSswptobefnz, &g->tobefnz);\n    }\n    case GCSswptobefnz: {  /* sweep objects to be finalized */\n      return sweepstep(L, g, GCSswpend, NULL);\n    }\n    case GCSswpend: {  /* finish sweeps */\n      checkSizes(L, g);\n      g->gcstate = GCScallfin;\n      return 0;\n    }\n    case GCScallfin: {  /* call remaining finalizers */\n      if (g->tobefnz && !g->gcemergency) {\n        int n = runafewfinalizers(L, GCFINMAX);\n        return n * GCFINALIZECOST;\n      }\n      else {  /* emergency mode or no more finalizers */\n        g->gcstate = GCSpause;  /* finish collection */\n        return 0;\n      }\n    }\n    default: lua_assert(0); return 0;\n  }\n}\n\n\n/*\n** advances the garbage collector until it reaches a state allowed\n** by 'statemask'\n*/\nvoid luaC_runtilstate (lua_State *L, int statesmask) {\n  global_State *g = G(L);\n  while (!testbit(statesmask, g->gcstate))\n    singlestep(L);\n}\n\n\n/*\n** Performs a basic incremental step. The debt and step size are\n** converted from bytes to \"units of work\"; then the function loops\n** running single steps until adding that many units of work or\n** finishing a cycle (pause state). Finally, it sets the debt that\n** controls when next step will be performed.\n*/\nstatic void incstep (lua_State *L, global_State *g) {\n  int stepmul = (getgcparam(g->gcstepmul) | 1);  /* avoid division by 0 */\n  l_mem debt = (g->GCdebt / WORK2MEM) * stepmul;\n  l_mem stepsize = (g->gcstepsize <= log2maxs(l_mem))\n                 ? ((cast(l_mem, 1) << g->gcstepsize) / WORK2MEM) * stepmul\n                 : MAX_LMEM;  /* overflow; keep maximum value */\n  do {  /* repeat until pause or enough \"credit\" (negative debt) */\n    lu_mem work = singlestep(L);  /* perform one single step */\n    debt -= work;\n  } while (debt > -stepsize && g->gcstate != GCSpause);\n  if (g->gcstate == GCSpause)\n    setpause(g);  /* pause until next cycle */\n  else {\n    debt = (debt / stepmul) * WORK2MEM;  /* convert 'work units' to bytes */\n    luaE_setdebt(g, debt);\n  }\n}\n\n/*\n** performs a basic GC step if collector is running\n*/\nvoid luaC_step (lua_State *L) {\n  global_State *g = G(L);\n  lua_assert(!g->gcemergency);\n  if (g->gcrunning) {  /* running? */\n    if(isdecGCmodegen(g))\n      genstep(L, g);\n    else\n      incstep(L, g);\n  }\n}\n\n\n/*\n** Perform a full collection in incremental mode.\n** Before running the collection, check 'keepinvariant'; if it is true,\n** there may be some objects marked as black, so the collector has\n** to sweep all objects to turn them back to white (as white has not\n** changed, nothing will be collected).\n*/\nstatic void fullinc (lua_State *L, global_State *g) {\n  if (keepinvariant(g))  /* black objects? */\n    entersweep(L); /* sweep everything to turn them back to white */\n  /* finish any pending sweep phase to start a new cycle */\n  luaC_runtilstate(L, bitmask(GCSpause));\n  luaC_runtilstate(L, bitmask(GCScallfin));  /* run up to finalizers */\n  /* estimate must be correct after a full GC cycle */\n  lua_assert(g->GCestimate == gettotalbytes(g));\n  luaC_runtilstate(L, bitmask(GCSpause));  /* finish collection */\n  setpause(g);\n}\n\n\n/*\n** Performs a full GC cycle; if 'isemergency', set a flag to avoid\n** some operations which could change the interpreter state in some\n** unexpected ways (running finalizers and shrinking some structures).\n*/\nvoid luaC_fullgc (lua_State *L, int isemergency) {\n  global_State *g = G(L);\n  lua_assert(!g->gcemergency);\n  g->gcemergency = isemergency;  /* set flag */\n  if (g->gckind == KGC_INC)\n    fullinc(L, g);\n  else\n    fullgen(L, g);\n  g->gcemergency = 0;\n}\n\n/* }====================================================== */\n\n\n"], "filenames": ["lgc.c"], "buggy_code_start_loc": [1134], "buggy_code_end_loc": [1144], "fixing_code_start_loc": [1134], "fixing_code_end_loc": [1142], "type": "CWE-125", "message": "Lua 5.4.0 has a getobjname heap-based buffer over-read because youngcollection in lgc.c uses markold for an insufficient number of list members.", "other": {"cve": {"id": "CVE-2020-15889", "sourceIdentifier": "cve@mitre.org", "published": "2020-07-21T22:15:12.150", "lastModified": "2020-12-23T17:41:54.713", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Lua 5.4.0 has a getobjname heap-based buffer over-read because youngcollection in lgc.c uses markold for an insufficient number of list members."}, {"lang": "es", "value": "Lua versi\u00f3n 5.4.0, presenta una lectura excesiva del b\u00fafer en la regi\u00f3n heap de la memoria de getobjname porque la funci\u00f3n youngcollection en el archivo lgc.c utiliza markold para un n\u00famero insuficiente de miembros de la lista"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:lua:lua:5.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "4066DFAE-B20D-44C9-BC34-694748ABE2CA"}]}]}], "references": [{"url": "http://lua-users.org/lists/lua-l/2020-07/msg00078.html", "source": "cve@mitre.org", "tags": ["Exploit", "Mailing List", "Third Party Advisory"]}, {"url": "http://lua-users.org/lists/lua-l/2020-12/msg00157.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/lua/lua/commit/127e7a6c8942b362aa3c6627f44d660a4fb75312", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/lua/lua/commit/127e7a6c8942b362aa3c6627f44d660a4fb75312"}}