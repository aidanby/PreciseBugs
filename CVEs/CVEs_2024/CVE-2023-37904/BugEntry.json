{"buggy_code": ["# frozen_string_literal: true\n\nrequire \"csv\"\n\nclass InvitesController < ApplicationController\n  requires_login only: %i[\n                   create\n                   retrieve\n                   destroy\n                   destroy_all_expired\n                   resend_invite\n                   resend_all_invites\n                   upload_csv\n                 ]\n\n  skip_before_action :check_xhr, except: [:perform_accept_invitation]\n  skip_before_action :preload_json, except: [:show]\n  skip_before_action :redirect_to_login_if_required\n\n  before_action :ensure_invites_allowed, only: %i[show perform_accept_invitation]\n  before_action :ensure_new_registrations_allowed, only: %i[show perform_accept_invitation]\n\n  def show\n    expires_now\n\n    RateLimiter.new(nil, \"invites-show-#{request.remote_ip}\", 100, 1.minute).performed!\n\n    invite = Invite.find_by(invite_key: params[:id])\n\n    if invite.present? && invite.redeemable?\n      show_invite(invite)\n    else\n      show_irredeemable_invite(invite)\n    end\n  rescue RateLimiter::LimitExceeded => e\n    flash.now[:error] = e.description\n    render layout: \"no_ember\"\n  end\n\n  def create\n    if params[:topic_id].present?\n      topic = Topic.find_by(id: params[:topic_id])\n      raise Discourse::InvalidParameters.new(:topic_id) if topic.blank?\n      guardian.ensure_can_invite_to!(topic)\n    end\n\n    if params[:group_ids].present? || params[:group_names].present?\n      groups = Group.lookup_groups(group_ids: params[:group_ids], group_names: params[:group_names])\n    end\n\n    guardian.ensure_can_invite_to_forum!(groups)\n\n    if !groups_can_see_topic?(groups, topic)\n      editable_topic_groups = topic.category.groups.filter { |g| guardian.can_edit_group?(g) }\n      return(\n        render_json_error(\n          I18n.t(\"invite.requires_groups\", groups: editable_topic_groups.pluck(:name).join(\", \")),\n        )\n      )\n    end\n\n    invite =\n      Invite.generate(\n        current_user,\n        email: params[:email],\n        domain: params[:domain],\n        skip_email: params[:skip_email],\n        invited_by: current_user,\n        custom_message: params[:custom_message],\n        max_redemptions_allowed: params[:max_redemptions_allowed],\n        topic_id: topic&.id,\n        group_ids: groups&.map(&:id),\n        expires_at: params[:expires_at],\n        invite_to_topic: params[:invite_to_topic],\n      )\n\n    if invite.present?\n      render_serialized(\n        invite,\n        InviteSerializer,\n        scope: guardian,\n        root: nil,\n        show_emails: params.has_key?(:email),\n        show_warnings: true,\n      )\n    else\n      render json: failed_json, status: 422\n    end\n  rescue Invite::UserExists => e\n    render_json_error(e.message)\n  rescue ActiveRecord::RecordInvalid => e\n    render_json_error(e.record.errors.full_messages.first)\n  end\n\n  def retrieve\n    params.require(:email)\n\n    invite = Invite.find_by(invited_by: current_user, email: params[:email])\n    raise Discourse::InvalidParameters.new(:email) if invite.blank?\n\n    guardian.ensure_can_invite_to_forum!(nil)\n\n    render_serialized(\n      invite,\n      InviteSerializer,\n      scope: guardian,\n      root: nil,\n      show_emails: params.has_key?(:email),\n      show_warnings: true,\n    )\n  end\n\n  def update\n    invite = Invite.find_by(invited_by: current_user, id: params[:id])\n    raise Discourse::InvalidParameters.new(:id) if invite.blank?\n\n    if params[:topic_id].present?\n      topic = Topic.find_by(id: params[:topic_id])\n      raise Discourse::InvalidParameters.new(:topic_id) if topic.blank?\n      guardian.ensure_can_invite_to!(topic)\n    end\n\n    if params[:group_ids].present? || params[:group_names].present?\n      groups = Group.lookup_groups(group_ids: params[:group_ids], group_names: params[:group_names])\n    end\n\n    guardian.ensure_can_invite_to_forum!(groups)\n\n    Invite.transaction do\n      if params.has_key?(:topic_id)\n        invite.topic_invites.destroy_all\n        invite.topic_invites.create!(topic_id: topic.id) if topic.present?\n      end\n\n      if params.has_key?(:group_ids) || params.has_key?(:group_names)\n        invite.invited_groups.destroy_all\n        if groups.present?\n          groups.each { |group| invite.invited_groups.find_or_create_by!(group_id: group.id) }\n        end\n      end\n\n      if !groups_can_see_topic?(invite.groups, invite.topics.first)\n        editable_topic_groups =\n          invite.topics.first.category.groups.filter { |g| guardian.can_edit_group?(g) }\n        return(\n          render_json_error(\n            I18n.t(\"invite.requires_groups\", groups: editable_topic_groups.pluck(:name).join(\", \")),\n          )\n        )\n      end\n\n      if params.has_key?(:email)\n        old_email = invite.email.presence\n        new_email = params[:email].presence\n\n        if new_email\n          if Invite\n               .where.not(id: invite.id)\n               .find_by(email: new_email.downcase, invited_by_id: current_user.id)\n               &.redeemable?\n            return(\n              render_json_error(\n                I18n.t(\"invite.invite_exists\", email: CGI.escapeHTML(new_email)),\n                status: 409,\n              )\n            )\n          end\n        end\n\n        if old_email != new_email\n          invite.emailed_status =\n            if new_email && !params[:skip_email]\n              Invite.emailed_status_types[:pending]\n            else\n              Invite.emailed_status_types[:not_required]\n            end\n        end\n\n        invite.domain = nil if invite.email.present?\n      end\n\n      if params.has_key?(:domain)\n        invite.domain = params[:domain]\n\n        if invite.domain.present?\n          invite.email = nil\n          invite.emailed_status = Invite.emailed_status_types[:not_required]\n        end\n      end\n\n      if params[:send_email]\n        if invite.emailed_status != Invite.emailed_status_types[:pending]\n          begin\n            RateLimiter.new(current_user, \"resend-invite-per-hour\", 10, 1.hour).performed!\n          rescue RateLimiter::LimitExceeded\n            return render_json_error(I18n.t(\"rate_limiter.slow_down\"))\n          end\n        end\n\n        invite.emailed_status = Invite.emailed_status_types[:pending]\n      end\n\n      begin\n        invite.update!(\n          params.permit(:email, :custom_message, :max_redemptions_allowed, :expires_at),\n        )\n      rescue ActiveRecord::RecordInvalid => e\n        return render_json_error(e.record.errors.full_messages.first)\n      end\n    end\n\n    if invite.emailed_status == Invite.emailed_status_types[:pending]\n      invite.update_column(:emailed_status, Invite.emailed_status_types[:sending])\n      Jobs.enqueue(:invite_email, invite_id: invite.id, invite_to_topic: params[:invite_to_topic])\n    end\n\n    render_serialized(\n      invite,\n      InviteSerializer,\n      scope: guardian,\n      root: nil,\n      show_emails: params.has_key?(:email),\n      show_warnings: true,\n    )\n  end\n\n  def destroy\n    params.require(:id)\n\n    invite = Invite.find_by(invited_by_id: current_user.id, id: params[:id])\n    raise Discourse::InvalidParameters.new(:id) if invite.blank?\n\n    invite.trash!(current_user)\n\n    render json: success_json\n  end\n\n  # For DiscourseConnect SSO, all invite acceptance is done\n  # via the SessionController#sso_login route\n  def perform_accept_invitation\n    params.require(:id)\n    params.permit(\n      :email,\n      :username,\n      :name,\n      :password,\n      :timezone,\n      :email_token,\n      user_custom_fields: {\n      },\n    )\n\n    invite = Invite.find_by(invite_key: params[:id])\n    redeeming_user = current_user\n\n    if invite.present?\n      begin\n        attrs = { ip_address: request.remote_ip, session: session }\n\n        if redeeming_user\n          attrs[:redeeming_user] = redeeming_user\n        else\n          attrs[:username] = params[:username]\n          attrs[:name] = params[:name]\n          attrs[:password] = params[:password]\n          attrs[:user_custom_fields] = params[:user_custom_fields]\n\n          # If the invite is not scoped to an email then we allow the\n          # user to provide it themselves\n          if invite.is_invite_link?\n            params.require(:email)\n            attrs[:email] = params[:email]\n          else\n            # Otherwise we always use the email from the invitation.\n            attrs[:email] = invite.email\n            attrs[:email_token] = params[:email_token] if params[:email_token].present?\n          end\n        end\n\n        user = invite.redeem(**attrs)\n      rescue ActiveRecord::RecordInvalid, ActiveRecord::RecordNotSaved, Invite::UserExists => e\n        return render json: failed_json.merge(message: e.message), status: 412\n      end\n\n      if user.blank?\n        return render json: failed_json.merge(message: I18n.t(\"invite.not_found_json\")), status: 404\n      end\n\n      log_on_user(user) if !redeeming_user && user.active? && user.guardian.can_access_forum?\n\n      user.update_timezone_if_missing(params[:timezone])\n      post_process_invite(user)\n      create_topic_invite_notifications(invite, user)\n\n      topic = invite.topics.first\n      response = {}\n\n      if user.present?\n        if user.active? && user.guardian.can_access_forum?\n          response[:message] = I18n.t(\"invite.existing_user_success\") if redeeming_user\n\n          if user.guardian.can_see?(topic)\n            response[:redirect_to] = path(topic.relative_url)\n          else\n            response[:redirect_to] = path(\"/\")\n          end\n        else\n          response[:message] = if user.active?\n            I18n.t(\"activation.approval_required\")\n          else\n            I18n.t(\"invite.confirm_email\")\n          end\n\n          cookies[:destination_url] = path(topic.relative_url) if user.guardian.can_see?(topic)\n        end\n      end\n\n      render json: success_json.merge(response)\n    else\n      render json: failed_json.merge(message: I18n.t(\"invite.not_found_json\")), status: 404\n    end\n  end\n\n  def destroy_all_expired\n    guardian.ensure_can_destroy_all_invites!(current_user)\n\n    Invite\n      .where(invited_by: current_user)\n      .where(\"expires_at < ?\", Time.zone.now)\n      .find_each { |invite| invite.trash!(current_user) }\n\n    render json: success_json\n  end\n\n  def resend_invite\n    params.require(:email)\n    RateLimiter.new(current_user, \"resend-invite-per-hour\", 10, 1.hour).performed!\n\n    invite = Invite.find_by(invited_by_id: current_user.id, email: params[:email])\n    raise Discourse::InvalidParameters.new(:email) if invite.blank?\n    invite.resend_invite\n    render json: success_json\n  rescue RateLimiter::LimitExceeded\n    render_json_error(I18n.t(\"rate_limiter.slow_down\"))\n  end\n\n  def resend_all_invites\n    guardian.ensure_can_resend_all_invites!(current_user)\n\n    begin\n      RateLimiter.new(\n        current_user,\n        \"bulk-reinvite-per-day\",\n        1,\n        1.day,\n        apply_limit_to_staff: true,\n      ).performed!\n    rescue RateLimiter::LimitExceeded\n      return render_json_error(I18n.t(\"rate_limiter.slow_down\"))\n    end\n\n    Invite\n      .pending(current_user)\n      .where(\"invites.email IS NOT NULL\")\n      .find_each { |invite| invite.resend_invite }\n\n    render json: success_json\n  end\n\n  def upload_csv\n    guardian.ensure_can_bulk_invite_to_forum!(current_user)\n\n    hijack do\n      begin\n        file = params[:file] || params[:files].first\n\n        csv_header = nil\n        invites = []\n\n        CSV.foreach(file.tempfile, encoding: \"bom|utf-8\") do |row|\n          # Try to extract a CSV header, if it exists\n          if csv_header.nil?\n            if row[0] == \"email\"\n              csv_header = row\n              next\n            else\n              csv_header = %w[email groups topic_id]\n            end\n          end\n\n          invites.push(csv_header.zip(row).map.to_h.filter { |k, v| v.present? }) if row[0].present?\n\n          break if invites.count >= SiteSetting.max_bulk_invites\n        end\n\n        if invites.present?\n          Jobs.enqueue(:bulk_invite, invites: invites, current_user_id: current_user.id)\n\n          if invites.count >= SiteSetting.max_bulk_invites\n            render json:\n                     failed_json.merge(\n                       errors: [\n                         I18n.t(\n                           \"bulk_invite.max_rows\",\n                           max_bulk_invites: SiteSetting.max_bulk_invites,\n                         ),\n                       ],\n                     ),\n                   status: 422\n          else\n            render json: success_json\n          end\n        else\n          render json: failed_json.merge(errors: [I18n.t(\"bulk_invite.error\")]), status: 422\n        end\n      end\n    end\n  end\n\n  private\n\n  def show_invite(invite)\n    email = Email.obfuscate(invite.email)\n\n    # Show email if the user already authenticated their email\n    different_external_email = false\n\n    if session[:authentication]\n      auth_result = Auth::Result.from_session_data(session[:authentication], user: nil)\n      if invite.email == auth_result.email\n        email = invite.email\n      else\n        different_external_email = true\n      end\n    end\n\n    email_verified_by_link = invite.email_token.present? && params[:t] == invite.email_token\n\n    email = invite.email if email_verified_by_link\n\n    hidden_email = email != invite.email\n\n    if hidden_email || invite.email.nil?\n      username = \"\"\n    else\n      username = UserNameSuggester.suggest(invite.email)\n    end\n\n    info = {\n      invited_by: UserNameSerializer.new(invite.invited_by, scope: guardian, root: false),\n      email: email,\n      hidden_email: hidden_email,\n      username: username,\n      is_invite_link: invite.is_invite_link?,\n      email_verified_by_link: email_verified_by_link,\n    }\n\n    info[:different_external_email] = true if different_external_email\n\n    if staged_user = User.where(staged: true).with_email(invite.email).first\n      info[:username] = staged_user.username\n      info[:user_fields] = staged_user.user_fields\n    end\n\n    if current_user\n      info[:existing_user_id] = current_user.id\n      info[:existing_user_can_redeem] = invite.can_be_redeemed_by?(current_user)\n      info[:existing_user_can_redeem_error] = existing_user_can_redeem_error(invite)\n      info[:email] = current_user.email\n      info[:username] = current_user.username\n    end\n\n    store_preloaded(\"invite_info\", MultiJson.dump(info))\n\n    secure_session[\"invite-key\"] = invite.invite_key\n\n    render layout: \"application\"\n  end\n\n  def show_irredeemable_invite(invite)\n    flash.now[:error] = if invite.blank?\n      I18n.t(\"invite.not_found\", base_url: Discourse.base_url)\n    elsif invite.redeemed?\n      if invite.is_invite_link?\n        I18n.t(\n          \"invite.not_found_template_link\",\n          site_name: SiteSetting.title,\n          base_url: Discourse.base_url,\n        )\n      else\n        I18n.t(\n          \"invite.not_found_template\",\n          site_name: SiteSetting.title,\n          base_url: Discourse.base_url,\n        )\n      end\n    elsif invite.expired?\n      I18n.t(\"invite.expired\", base_url: Discourse.base_url)\n    end\n\n    render layout: \"no_ember\"\n  end\n\n  def ensure_invites_allowed\n    if (\n         !SiteSetting.enable_local_logins && Discourse.enabled_auth_providers.count == 0 &&\n           !SiteSetting.enable_discourse_connect\n       )\n      raise Discourse::NotFound\n    end\n  end\n\n  def ensure_new_registrations_allowed\n    unless SiteSetting.allow_new_registrations\n      flash[:error] = I18n.t(\"login.new_registrations_disabled\")\n      render layout: \"no_ember\"\n      false\n    end\n  end\n\n  def groups_can_see_topic?(groups, topic)\n    if topic&.read_restricted_category?\n      topic_groups = topic.category.groups\n      return false if (groups & topic_groups).blank?\n    end\n\n    true\n  end\n\n  def post_process_invite(user)\n    user.enqueue_welcome_message(\"welcome_invite\") if user.send_welcome_message\n\n    Group.refresh_automatic_groups!(:admins, :moderators, :staff) if user.staff?\n\n    if user.has_password?\n      if !user.active\n        email_token =\n          user.email_tokens.create!(email: user.email, scope: EmailToken.scopes[:signup])\n        EmailToken.enqueue_signup_email(email_token)\n      end\n    elsif !SiteSetting.enable_discourse_connect && SiteSetting.enable_local_logins\n      Jobs.enqueue(:invite_password_instructions_email, username: user.username)\n    end\n  end\n\n  def create_topic_invite_notifications(invite, user)\n    invite.topics.each do |topic|\n      if user.guardian.can_see?(topic)\n        last_notification =\n          user\n            .notifications\n            .where(notification_type: Notification.types[:invited_to_topic])\n            .where(topic_id: topic.id)\n            .where(post_number: 1)\n            .where(\"created_at > ?\", 1.hour.ago)\n\n        if !last_notification.exists?\n          topic.create_invite_notification!(\n            user,\n            Notification.types[:invited_to_topic],\n            invite.invited_by,\n          )\n        end\n      end\n    end\n  end\n\n  def existing_user_can_redeem_error(invite)\n    return if invite.can_be_redeemed_by?(current_user)\n    if invite.invited_users.exists?(user: current_user)\n      I18n.t(\"invite.existing_user_already_redemeed\")\n    else\n      I18n.t(\"invite.existing_user_cannot_redeem\")\n    end\n  end\nend\n", "# frozen_string_literal: true\n\n# NOTE: There are a _lot_ of complicated rules and conditions for our\n# invite system, and the code is spread out through a lot of places.\n# Tread lightly and read carefully when modifying this code. You may\n# also want to look at:\n#\n# * InvitesController\n# * SessionController\n# * Invite model\n# * User model\n#\n# Invites that are scoped to a specific email (email IS NOT NULL on the Invite\n# model) have different rules to invites that are considered an \"invite link\",\n# (email IS NULL) on the Invite model.\nclass InviteRedeemer\n  attr_reader :invite,\n              :email,\n              :username,\n              :name,\n              :password,\n              :user_custom_fields,\n              :ip_address,\n              :session,\n              :email_token,\n              :redeeming_user\n\n  def initialize(\n    invite:,\n    email: nil,\n    username: nil,\n    name: nil,\n    password: nil,\n    user_custom_fields: nil,\n    ip_address: nil,\n    session: nil,\n    email_token: nil,\n    redeeming_user: nil\n  )\n    @invite = invite\n    @username = username\n    @name = name\n    @password = password\n    @user_custom_fields = user_custom_fields\n    @ip_address = ip_address\n    @session = session\n    @email_token = email_token\n    @redeeming_user = redeeming_user\n\n    ensure_email_is_present!(email)\n  end\n\n  def redeem\n    Invite.transaction do\n      if can_redeem_invite? && mark_invite_redeemed\n        process_invitation\n        invited_user\n      end\n    end\n  end\n\n  # The email must be present in some form since many of the methods\n  # for processing + redemption rely on it. If it's still nil after\n  # these checks then we have hit an edge case and should not proceed!\n  def ensure_email_is_present!(email)\n    if email.blank?\n      Rails.logger.warn(\n        \"email param was blank in InviteRedeemer for invite ID #{@invite.id}. The `redeeming_user` was #{@redeeming_user.present? ? \"(ID: #{@redeeming_user.id})\" : \"not\"} present.\",\n      )\n    end\n\n    if email.blank? && @invite.is_email_invite?\n      @email = @invite.email\n    elsif @redeeming_user.present?\n      @email = @redeeming_user.email\n    else\n      @email = email\n    end\n\n    raise Discourse::InvalidParameters if @email.blank?\n  end\n\n  # This will _never_ be called if there is a redeeming_user being passed\n  # in to InviteRedeemer -- see invited_user below.\n  def self.create_user_from_invite(\n    email:,\n    invite:,\n    username: nil,\n    name: nil,\n    password: nil,\n    user_custom_fields: nil,\n    ip_address: nil,\n    session: nil,\n    email_token: nil\n  )\n    if username && UsernameValidator.new(username).valid_format? &&\n         User.username_available?(username, email)\n      available_username = username\n    else\n      available_username = UserNameSuggester.suggest(email)\n    end\n\n    user = User.where(staged: true).with_email(email.strip.downcase).first\n    user.unstage! if user\n    user ||= User.new\n\n    user.attributes = {\n      email: email,\n      username: available_username,\n      name: name || available_username,\n      active: false,\n      trust_level: SiteSetting.default_invitee_trust_level,\n      ip_address: ip_address,\n      registration_ip_address: ip_address,\n    }\n\n    if (!SiteSetting.must_approve_users && SiteSetting.invite_only) ||\n         (SiteSetting.must_approve_users? && EmailValidator.can_auto_approve_user?(user.email))\n      ReviewableUser.set_approved_fields!(user, Discourse.system_user)\n    end\n\n    user_fields = UserField.all\n    if user_custom_fields.present? && user_fields.present?\n      field_params = user_custom_fields || {}\n      fields = user.custom_fields\n\n      user_fields.each do |f|\n        field_val = field_params[f.id.to_s]\n        fields[\"#{User::USER_FIELD_PREFIX}#{f.id}\"] = field_val[\n          0...UserField.max_length\n        ] unless field_val.blank?\n      end\n      user.custom_fields = fields\n    end\n\n    user.moderator = true if invite.moderator? && invite.invited_by.staff?\n\n    if password\n      user.password = password\n      user.password_required!\n    end\n\n    authenticator = UserAuthenticator.new(user, session, require_password: false)\n\n    if !authenticator.has_authenticator? && !SiteSetting.enable_local_logins\n      raise ActiveRecord::RecordNotSaved.new(I18n.t(\"login.incorrect_username_email_or_password\"))\n    end\n\n    authenticator.start\n\n    if authenticator.email_valid? && !authenticator.authenticated?\n      raise ActiveRecord::RecordNotSaved.new(I18n.t(\"login.incorrect_username_email_or_password\"))\n    end\n\n    user.save!\n    authenticator.finish\n\n    if invite.emailed_status != Invite.emailed_status_types[:not_required] &&\n         email == invite.email && invite.email_token.present? && email_token == invite.email_token\n      user.activate\n    end\n\n    User.find(user.id)\n  end\n\n  private\n\n  def can_redeem_invite?\n    return false if !invite.redeemable?\n    return false if email.blank?\n\n    # Invite scoped to email has already been redeemed by anyone.\n    return false if invite.is_email_invite? && InvitedUser.exists?(invite_id: invite.id)\n\n    # The email will be present for either an invite link (where the user provides\n    # us the email manually) or for an invite scoped to an email, where we\n    # prefill the email and do not let the user modify it.\n    #\n    # Note that an invite link can also have a domain scope which must be checked.\n    email_to_check = redeeming_user&.email || email\n\n    if invite.email.present? && !invite.email_matches?(email_to_check)\n      raise ActiveRecord::RecordNotSaved.new(I18n.t(\"invite.not_matching_email\"))\n    end\n\n    if invite.domain.present? && !invite.domain_matches?(email_to_check)\n      raise ActiveRecord::RecordNotSaved.new(I18n.t(\"invite.domain_not_allowed\"))\n    end\n\n    # Anon user is trying to redeem an invitation, if an existing user already\n    # redeemed it then we cannot redeem now.\n    redeeming_user ||= User.where(admin: false, staged: false).find_by_email(email)\n    if redeeming_user.present? &&\n         InvitedUser.exists?(user_id: redeeming_user.id, invite_id: invite.id)\n      return false\n    end\n\n    true\n  end\n\n  # Note that the invited_user is returned by #redeemed, so other places\n  # (e.g. the InvitesController) can perform further actions on it, this\n  # is why things like send_welcome_message are set without being saved\n  # on the model.\n  def invited_user\n    return @invited_user if defined?(@invited_user)\n\n    # The redeeming user is an already logged in user or a user who is\n    # activating their account who is redeeming the invite,\n    # which is valid for existing users to be invited to topics or groups.\n    if redeeming_user.present?\n      @invited_user = redeeming_user\n      return @invited_user\n    end\n\n    # If there was no logged in user then we must attempt to create\n    # one based on the provided params.\n    invited_user ||=\n      InviteRedeemer.create_user_from_invite(\n        email: email,\n        invite: invite,\n        username: username,\n        name: name,\n        password: password,\n        user_custom_fields: user_custom_fields,\n        ip_address: ip_address,\n        session: session,\n        email_token: email_token,\n      )\n    invited_user.send_welcome_message = false\n    @invited_user = invited_user\n    @invited_user\n  end\n\n  def process_invitation\n    add_to_private_topics_if_invited\n    add_user_to_groups\n    send_welcome_message\n    notify_invitee\n  end\n\n  def mark_invite_redeemed\n    @invited_user_record = InvitedUser.create!(invite_id: invite.id, redeemed_at: Time.zone.now)\n\n    if @invited_user_record.present?\n      Invite.increment_counter(:redemption_count, invite.id)\n      delete_duplicate_invites\n    end\n\n    @invited_user_record.present?\n  end\n\n  def add_to_private_topics_if_invited\n    # Should not happen because of ensure_email_is_present!, but better to cover bases.\n    return if email.blank?\n\n    topic_ids =\n      TopicInvite\n        .joins(:invite)\n        .joins(:topic)\n        .where(\"topics.archetype = ?\", Archetype.private_message)\n        .where(\"invites.email = ?\", email)\n        .pluck(:topic_id)\n    topic_ids.each do |id|\n      if !TopicAllowedUser.exists?(user_id: invited_user.id, topic_id: id)\n        TopicAllowedUser.create!(user_id: invited_user.id, topic_id: id)\n      end\n    end\n  end\n\n  def add_user_to_groups\n    guardian = Guardian.new(invite.invited_by)\n    new_group_ids = invite.groups.pluck(:id) - invited_user.group_users.pluck(:group_id)\n    new_group_ids.each do |id|\n      group = Group.find_by(id: id)\n      if guardian.can_edit_group?(group)\n        invited_user.group_users.create!(group_id: group.id)\n        GroupActionLogger.new(invite.invited_by, group).log_add_user_to_group(invited_user)\n        DiscourseEvent.trigger(:user_added_to_group, invited_user, group, automatic: false)\n      end\n    end\n  end\n\n  def send_welcome_message\n    @invited_user_record.update!(user_id: invited_user.id)\n    invited_user.send_welcome_message = true\n  end\n\n  def notify_invitee\n    return if invite.invited_by.blank?\n    invite.invited_by.notifications.create!(\n      notification_type: Notification.types[:invitee_accepted],\n      data: { display_username: invited_user.username }.to_json,\n    )\n  end\n\n  def delete_duplicate_invites\n    # Should not happen because of ensure_email_is_present!, but better to cover bases.\n    return if email.blank?\n\n    Invite\n      .where(\"invites.max_redemptions_allowed = 1\")\n      .joins(\"LEFT JOIN invited_users ON invites.id = invited_users.invite_id\")\n      .where(\"invited_users.user_id IS NULL\")\n      .where(\"invites.email = ? AND invites.id != ?\", email, invite.id)\n      .delete_all\n  end\nend\n", "# frozen_string_literal: true\n\nRSpec.describe InvitesController do\n  fab!(:admin) { Fabricate(:admin) }\n  fab!(:user) { Fabricate(:user, trust_level: SiteSetting.min_trust_level_to_allow_invite) }\n\n  describe \"#show\" do\n    fab!(:invite) { Fabricate(:invite) }\n\n    it \"shows the accept invite page\" do\n      get \"/invites/#{invite.invite_key}\"\n      expect(response.status).to eq(200)\n      expect(response.body).to have_tag(:script, with: { src: \"/assets/discourse.js\" })\n      expect(response.body).not_to include(invite.email)\n      expect(response.body).to_not include(\n        I18n.t(\n          \"invite.not_found_template\",\n          site_name: SiteSetting.title,\n          base_url: Discourse.base_url,\n        ),\n      )\n\n      expect(response.body).to have_tag(\"div#data-preloaded\") do |element|\n        json = JSON.parse(element.current_scope.attribute(\"data-preloaded\").value)\n        invite_info = JSON.parse(json[\"invite_info\"])\n        expect(invite_info[\"username\"]).to eq(\"\")\n        expect(invite_info[\"email\"]).to eq(\"i*****g@a***********e.ooo\")\n      end\n    end\n\n    context \"when email data is present in authentication data\" do\n      let(:store) { ActionDispatch::Session::CookieStore.new({}) }\n      let(:session_stub) do\n        ActionDispatch::Request::Session.create(store, ActionDispatch::TestRequest.create, {})\n      end\n\n      before do\n        session_stub[:authentication] = { email: invite.email }\n        ActionDispatch::Request.any_instance.stubs(:session).returns(session_stub)\n      end\n\n      it \"shows unobfuscated email\" do\n        get \"/invites/#{invite.invite_key}\"\n        expect(response.status).to eq(200)\n        expect(response.body).to have_tag(:script, with: { src: \"/assets/discourse.js\" })\n        expect(response.body).to include(invite.email)\n        expect(response.body).not_to include(\"i*****g@a***********e.ooo\")\n      end\n    end\n\n    it \"shows default user fields\" do\n      user_field = Fabricate(:user_field)\n      staged_user = Fabricate(:user, staged: true, email: invite.email)\n      staged_user.set_user_field(user_field.id, \"some value\")\n      staged_user.save_custom_fields\n\n      get \"/invites/#{invite.invite_key}\"\n      expect(response.body).to have_tag(\"div#data-preloaded\") do |element|\n        json = JSON.parse(element.current_scope.attribute(\"data-preloaded\").value)\n        invite_info = JSON.parse(json[\"invite_info\"])\n        expect(invite_info[\"username\"]).to eq(staged_user.username)\n        expect(invite_info[\"user_fields\"][user_field.id.to_s]).to eq(\"some value\")\n      end\n    end\n\n    it \"includes token validity boolean\" do\n      get \"/invites/#{invite.invite_key}\"\n      expect(response.body).to have_tag(\"div#data-preloaded\") do |element|\n        json = JSON.parse(element.current_scope.attribute(\"data-preloaded\").value)\n        invite_info = JSON.parse(json[\"invite_info\"])\n        expect(invite_info[\"email_verified_by_link\"]).to eq(false)\n      end\n\n      get \"/invites/#{invite.invite_key}?t=#{invite.email_token}\"\n      expect(response.body).to have_tag(\"div#data-preloaded\") do |element|\n        json = JSON.parse(element.current_scope.attribute(\"data-preloaded\").value)\n        invite_info = JSON.parse(json[\"invite_info\"])\n        expect(invite_info[\"email_verified_by_link\"]).to eq(true)\n      end\n    end\n\n    describe \"logged in user viewing an invite\" do\n      fab!(:group) { Fabricate(:group) }\n\n      before { sign_in(user) }\n\n      it \"shows the accept invite page when user's email matches the invite email\" do\n        invite.update_columns(email: user.email)\n\n        get \"/invites/#{invite.invite_key}\"\n        expect(response.status).to eq(200)\n        expect(response.body).to have_tag(:script, with: { src: \"/assets/discourse.js\" })\n        expect(response.body).not_to include(\n          I18n.t(\n            \"invite.not_found_template\",\n            site_name: SiteSetting.title,\n            base_url: Discourse.base_url,\n          ),\n        )\n\n        expect(response.body).to have_tag(\"div#data-preloaded\") do |element|\n          json = JSON.parse(element.current_scope.attribute(\"data-preloaded\").value)\n          invite_info = JSON.parse(json[\"invite_info\"])\n          expect(invite_info[\"username\"]).to eq(user.username)\n          expect(invite_info[\"email\"]).to eq(user.email)\n          expect(invite_info[\"existing_user_id\"]).to eq(user.id)\n          expect(invite_info[\"existing_user_can_redeem\"]).to eq(true)\n        end\n      end\n\n      it \"shows the accept invite page when user's email domain matches the domain an invite link is restricted to\" do\n        invite.update!(email: nil, domain: \"discourse.org\")\n        user.update!(email: \"someguy@discourse.org\")\n\n        get \"/invites/#{invite.invite_key}\"\n        expect(response.status).to eq(200)\n        expect(response.body).to have_tag(:script, with: { src: \"/assets/discourse.js\" })\n        expect(response.body).not_to include(\n          I18n.t(\n            \"invite.not_found_template\",\n            site_name: SiteSetting.title,\n            base_url: Discourse.base_url,\n          ),\n        )\n\n        expect(response.body).to have_tag(\"div#data-preloaded\") do |element|\n          json = JSON.parse(element.current_scope.attribute(\"data-preloaded\").value)\n          invite_info = JSON.parse(json[\"invite_info\"])\n          expect(invite_info[\"username\"]).to eq(user.username)\n          expect(invite_info[\"email\"]).to eq(user.email)\n          expect(invite_info[\"existing_user_id\"]).to eq(user.id)\n          expect(invite_info[\"existing_user_can_redeem\"]).to eq(true)\n        end\n      end\n\n      it \"does not allow the user to accept the invite when their email domain does not match the domain of the invite\" do\n        user.update!(email: \"someguy@discourse.com\")\n        invite.update!(email: nil, domain: \"discourse.org\")\n\n        get \"/invites/#{invite.invite_key}\"\n        expect(response.status).to eq(200)\n\n        expect(response.body).to have_tag(\"div#data-preloaded\") do |element|\n          json = JSON.parse(element.current_scope.attribute(\"data-preloaded\").value)\n          invite_info = JSON.parse(json[\"invite_info\"])\n          expect(invite_info[\"existing_user_can_redeem\"]).to eq(false)\n          expect(invite_info[\"existing_user_can_redeem_error\"]).to eq(\n            I18n.t(\"invite.existing_user_cannot_redeem\"),\n          )\n        end\n      end\n\n      it \"does not allow the user to accept the invite when their email does not match the invite\" do\n        invite.update_columns(email: \"notuseremail@discourse.org\")\n\n        get \"/invites/#{invite.invite_key}\"\n        expect(response.status).to eq(200)\n\n        expect(response.body).to have_tag(\"div#data-preloaded\") do |element|\n          json = JSON.parse(element.current_scope.attribute(\"data-preloaded\").value)\n          invite_info = JSON.parse(json[\"invite_info\"])\n          expect(invite_info[\"existing_user_can_redeem\"]).to eq(false)\n        end\n      end\n\n      it \"does not allow the user to accept the invite when a multi-use invite link has already been redeemed by the user\" do\n        invite.update!(email: nil, max_redemptions_allowed: 10)\n        expect(invite.redeem(redeeming_user: user)).not_to eq(nil)\n\n        get \"/invites/#{invite.invite_key}\"\n        expect(response.status).to eq(200)\n\n        expect(response.body).to have_tag(\"div#data-preloaded\") do |element|\n          json = JSON.parse(element.current_scope.attribute(\"data-preloaded\").value)\n          invite_info = JSON.parse(json[\"invite_info\"])\n          expect(invite_info[\"existing_user_id\"]).to eq(user.id)\n          expect(invite_info[\"existing_user_can_redeem\"]).to eq(false)\n          expect(invite_info[\"existing_user_can_redeem_error\"]).to eq(\n            I18n.t(\"invite.existing_user_already_redemeed\"),\n          )\n        end\n      end\n\n      it \"allows the user to accept the invite when its an invite link that they have not redeemed\" do\n        invite.update!(email: nil, max_redemptions_allowed: 10)\n\n        get \"/invites/#{invite.invite_key}\"\n        expect(response.status).to eq(200)\n\n        expect(response.body).to have_tag(\"div#data-preloaded\") do |element|\n          json = JSON.parse(element.current_scope.attribute(\"data-preloaded\").value)\n          invite_info = JSON.parse(json[\"invite_info\"])\n          expect(invite_info[\"existing_user_id\"]).to eq(user.id)\n          expect(invite_info[\"existing_user_can_redeem\"]).to eq(true)\n        end\n      end\n    end\n\n    it \"fails if invite does not exist\" do\n      get \"/invites/missing\"\n      expect(response.status).to eq(200)\n      expect(response.body).to_not have_tag(:script, with: { src: \"/assets/application.js\" })\n      expect(response.body).to include(I18n.t(\"invite.not_found\", base_url: Discourse.base_url))\n    end\n\n    it \"fails if invite expired\" do\n      invite.update(expires_at: 1.day.ago)\n\n      get \"/invites/#{invite.invite_key}\"\n      expect(response.status).to eq(200)\n      expect(response.body).to_not have_tag(:script, with: { src: \"/assets/application.js\" })\n      expect(response.body).to include(I18n.t(\"invite.expired\", base_url: Discourse.base_url))\n    end\n\n    it \"stores the invite key in the secure session if invite exists\" do\n      get \"/invites/#{invite.invite_key}\"\n      expect(response.status).to eq(200)\n      invite_key = read_secure_session[\"invite-key\"]\n      expect(invite_key).to eq(invite.invite_key)\n    end\n\n    it \"returns error if invite has already been redeemed\" do\n      expect(invite.redeem).not_to eq(nil)\n\n      get \"/invites/#{invite.invite_key}\"\n      expect(response.status).to eq(200)\n      expect(response.body).to_not have_tag(:script, with: { src: \"/assets/application.js\" })\n      expect(response.body).to include(\n        I18n.t(\n          \"invite.not_found_template\",\n          site_name: SiteSetting.title,\n          base_url: Discourse.base_url,\n        ),\n      )\n\n      invite.update!(email: nil) # convert to email invite\n\n      get \"/invites/#{invite.invite_key}\"\n      expect(response.status).to eq(200)\n      expect(response.body).to_not have_tag(:script, with: { src: \"/assets/application.js\" })\n      expect(response.body).to include(\n        I18n.t(\n          \"invite.not_found_template_link\",\n          site_name: SiteSetting.title,\n          base_url: Discourse.base_url,\n        ),\n      )\n    end\n  end\n\n  describe \"#create\" do\n    it \"requires to be logged in\" do\n      post \"/invites.json\", params: { email: \"test@example.com\" }\n      expect(response.status).to eq(403)\n    end\n\n    context \"while logged in\" do\n      before { sign_in(user) }\n\n      it \"fails if you cannot invite to the forum\" do\n        sign_in(Fabricate(:user))\n\n        post \"/invites.json\", params: { email: \"test@example.com\" }\n        expect(response).to be_forbidden\n      end\n    end\n\n    context \"with invite to topic\" do\n      fab!(:topic) { Fabricate(:topic) }\n\n      it \"works\" do\n        sign_in(user)\n\n        post \"/invites.json\",\n             params: {\n               email: \"test@example.com\",\n               topic_id: topic.id,\n               invite_to_topic: true,\n             }\n        expect(response.status).to eq(200)\n        expect(Jobs::InviteEmail.jobs.first[\"args\"].first[\"invite_to_topic\"]).to be_truthy\n      end\n\n      it \"fails when topic_id is invalid\" do\n        sign_in(user)\n\n        post \"/invites.json\", params: { email: \"test@example.com\", topic_id: -9999 }\n        expect(response.status).to eq(400)\n      end\n\n      context \"when topic is private\" do\n        fab!(:group) { Fabricate(:group) }\n\n        fab!(:secured_category) do |category|\n          category = Fabricate(:category)\n          category.permissions = { group.name => :full }\n          category.save!\n          category\n        end\n\n        fab!(:topic) { Fabricate(:topic, category: secured_category) }\n\n        it \"does not work and returns a list of required groups\" do\n          sign_in(admin)\n\n          post \"/invites.json\", params: { email: \"test@example.com\", topic_id: topic.id }\n          expect(response.status).to eq(422)\n          expect(response.parsed_body[\"errors\"]).to contain_exactly(\n            I18n.t(\"invite.requires_groups\", groups: group.name),\n          )\n        end\n\n        it \"does not work if user cannot edit groups\" do\n          group.add(user)\n          sign_in(user)\n\n          post \"/invites.json\", params: { email: \"test@example.com\", topic_id: topic.id }\n          expect(response.status).to eq(403)\n        end\n      end\n    end\n\n    context \"with invite to group\" do\n      fab!(:group) { Fabricate(:group) }\n\n      it \"works for admins\" do\n        sign_in(admin)\n\n        post \"/invites.json\", params: { email: \"test@example.com\", group_ids: [group.id] }\n        expect(response.status).to eq(200)\n        expect(Invite.find_by(email: \"test@example.com\").invited_groups.count).to eq(1)\n      end\n\n      it \"works for group owners\" do\n        sign_in(user)\n        group.add_owner(user)\n\n        post \"/invites.json\", params: { email: \"test@example.com\", group_ids: [group.id] }\n        expect(response.status).to eq(200)\n        expect(Invite.find_by(email: \"test@example.com\").invited_groups.count).to eq(1)\n      end\n\n      it \"works with multiple groups\" do\n        sign_in(admin)\n        group2 = Fabricate(:group)\n\n        post \"/invites.json\",\n             params: {\n               email: \"test@example.com\",\n               group_names: \"#{group.name},#{group2.name}\",\n             }\n        expect(response.status).to eq(200)\n        expect(Invite.find_by(email: \"test@example.com\").invited_groups.count).to eq(2)\n      end\n\n      it \"fails for group members\" do\n        sign_in(user)\n        group.add(user)\n\n        post \"/invites.json\", params: { email: \"test@example.com\", group_ids: [group.id] }\n        expect(response.status).to eq(403)\n      end\n\n      it \"fails for other users\" do\n        sign_in(user)\n\n        post \"/invites.json\", params: { email: \"test@example.com\", group_ids: [group.id] }\n        expect(response.status).to eq(403)\n      end\n\n      it \"fails to invite new user to a group-private topic\" do\n        sign_in(user)\n        private_category = Fabricate(:private_category, group: group)\n        group_private_topic = Fabricate(:topic, category: private_category)\n\n        post \"/invites.json\",\n             params: {\n               email: \"test@example.com\",\n               topic_id: group_private_topic.id,\n             }\n        expect(response.status).to eq(403)\n      end\n    end\n\n    context \"with email invite\" do\n      subject(:create_invite) { post \"/invites.json\", params: params }\n\n      let(:params) { { email: email } }\n      let(:email) { \"test@example.com\" }\n\n      before { sign_in(user) }\n\n      context \"when doing successive calls\" do\n        let(:invite) { Invite.last }\n\n        it \"creates invite once and updates it after\" do\n          create_invite\n          expect(response).to have_http_status :ok\n          expect(Jobs::InviteEmail.jobs.size).to eq(1)\n\n          create_invite\n          expect(response).to have_http_status :ok\n          expect(response.parsed_body[\"id\"]).to eq(invite.id)\n        end\n      end\n\n      context 'when \"skip_email\" parameter is provided' do\n        before { params[:skip_email] = true }\n\n        it \"accepts the parameter\" do\n          create_invite\n          expect(response).to have_http_status :ok\n          expect(Jobs::InviteEmail.jobs.size).to eq(0)\n        end\n      end\n\n      context \"when validations fail\" do\n        let(:email) { \"test@mailinator.com\" }\n\n        it \"fails\" do\n          create_invite\n          expect(response).to have_http_status :unprocessable_entity\n          expect(response.parsed_body[\"errors\"]).to be_present\n        end\n      end\n\n      context \"when providing an email belonging to an existing user\" do\n        let(:email) { user.email }\n\n        before { SiteSetting.hide_email_address_taken = hide_email_address_taken }\n\n        context 'when \"hide_email_address_taken\" setting is disabled' do\n          let(:hide_email_address_taken) { false }\n\n          it \"returns an error\" do\n            create_invite\n            expect(response).to have_http_status :unprocessable_entity\n            expect(body).to match(/no need to invite/)\n          end\n        end\n\n        context 'when \"hide_email_address_taken\" setting is enabled' do\n          let(:hide_email_address_taken) { true }\n\n          it \"doesn\u2019t inform the user\" do\n            create_invite\n            expect(response).to have_http_status :unprocessable_entity\n            expect(body).to match(/There was a problem with your request./)\n          end\n        end\n      end\n    end\n\n    context \"with link invite\" do\n      it \"works\" do\n        sign_in(admin)\n\n        post \"/invites.json\"\n        expect(response.status).to eq(200)\n        expect(Invite.last.email).to eq(nil)\n        expect(Invite.last.invited_by).to eq(admin)\n        expect(Invite.last.max_redemptions_allowed).to eq(1)\n      end\n\n      it \"fails if over invite_link_max_redemptions_limit\" do\n        sign_in(admin)\n\n        post \"/invites.json\",\n             params: {\n               max_redemptions_allowed: SiteSetting.invite_link_max_redemptions_limit - 1,\n             }\n        expect(response.status).to eq(200)\n\n        post \"/invites.json\",\n             params: {\n               max_redemptions_allowed: SiteSetting.invite_link_max_redemptions_limit + 1,\n             }\n        expect(response.status).to eq(422)\n      end\n\n      it \"fails if over invite_link_max_redemptions_limit_users\" do\n        sign_in(user)\n\n        post \"/invites.json\",\n             params: {\n               max_redemptions_allowed: SiteSetting.invite_link_max_redemptions_limit_users - 1,\n             }\n        expect(response.status).to eq(200)\n\n        post \"/invites.json\",\n             params: {\n               max_redemptions_allowed: SiteSetting.invite_link_max_redemptions_limit_users + 1,\n             }\n        expect(response.status).to eq(422)\n      end\n    end\n  end\n\n  describe \"#retrieve\" do\n    it \"requires to be logged in\" do\n      get \"/invites/retrieve.json\", params: { email: \"test@example.com\" }\n      expect(response.status).to eq(403)\n    end\n\n    context \"while logged in\" do\n      before { sign_in(user) }\n\n      fab!(:invite) { Fabricate(:invite, invited_by: user, email: \"test@example.com\") }\n\n      it \"raises an error when the email is missing\" do\n        get \"/invites/retrieve.json\"\n        expect(response.status).to eq(400)\n      end\n\n      it \"raises an error when the email cannot be found\" do\n        get \"/invites/retrieve.json\", params: { email: \"test2@example.com\" }\n        expect(response.status).to eq(400)\n      end\n\n      it \"can retrieve the invite\" do\n        get \"/invites/retrieve.json\", params: { email: \"test@example.com\" }\n        expect(response.status).to eq(200)\n      end\n    end\n  end\n\n  describe \"#update\" do\n    fab!(:invite) { Fabricate(:invite, invited_by: admin, email: \"test@example.com\") }\n\n    it \"requires to be logged in\" do\n      put \"/invites/#{invite.id}\", params: { email: \"test2@example.com\" }\n      expect(response.status).to eq(400)\n    end\n\n    context \"while logged in\" do\n      before { sign_in(admin) }\n\n      it \"resends invite email if updating email address\" do\n        put \"/invites/#{invite.id}\", params: { email: \"test2@example.com\" }\n        expect(response.status).to eq(200)\n        expect(Jobs::InviteEmail.jobs.size).to eq(1)\n      end\n\n      it \"does not resend invite email if skip_email if updating email address\" do\n        put \"/invites/#{invite.id}\", params: { email: \"test2@example.com\", skip_email: true }\n        expect(response.status).to eq(200)\n        expect(Jobs::InviteEmail.jobs.size).to eq(0)\n      end\n\n      it \"does not resend invite email when updating other fields\" do\n        put \"/invites/#{invite.id}\", params: { custom_message: \"new message\" }\n        expect(response.status).to eq(200)\n        expect(invite.reload.custom_message).to eq(\"new message\")\n        expect(Jobs::InviteEmail.jobs.size).to eq(0)\n      end\n\n      it \"cannot create duplicated invites\" do\n        Fabricate(:invite, invited_by: admin, email: \"test2@example.com\")\n\n        put \"/invites/#{invite.id}.json\", params: { email: \"test2@example.com\" }\n        expect(response.status).to eq(409)\n      end\n\n      describe \"rate limiting\" do\n        before { RateLimiter.enable }\n\n        use_redis_snapshotting\n\n        it \"can send invite email\" do\n          sign_in(user)\n\n          invite = Fabricate(:invite, invited_by: user, email: \"test@example.com\")\n\n          expect { put \"/invites/#{invite.id}\", params: { send_email: true } }.to change {\n            RateLimiter.new(user, \"resend-invite-per-hour\", 10, 1.hour).remaining\n          }.by(-1)\n          expect(response.status).to eq(200)\n          expect(Jobs::InviteEmail.jobs.size).to eq(1)\n        end\n      end\n\n      context \"when providing an email belonging to an existing user\" do\n        subject(:update_invite) { put \"/invites/#{invite.id}.json\", params: { email: admin.email } }\n\n        before { SiteSetting.hide_email_address_taken = hide_email_address_taken }\n\n        context \"when 'hide_email_address_taken' setting is disabled\" do\n          let(:hide_email_address_taken) { false }\n\n          it \"returns an error\" do\n            update_invite\n            expect(response).to have_http_status :unprocessable_entity\n            expect(body).to match(/no need to invite/)\n          end\n        end\n\n        context \"when 'hide_email_address_taken' setting is enabled\" do\n          let(:hide_email_address_taken) { true }\n\n          it \"doesn't inform the user\" do\n            update_invite\n            expect(response).to have_http_status :unprocessable_entity\n            expect(body).to match(/There was a problem with your request./)\n          end\n        end\n      end\n    end\n  end\n\n  describe \"#destroy\" do\n    it \"requires to be logged in\" do\n      delete \"/invites.json\", params: { email: \"test@example.com\" }\n      expect(response.status).to eq(403)\n    end\n\n    context \"while logged in\" do\n      fab!(:invite) { Fabricate(:invite, invited_by: user) }\n\n      before { sign_in(user) }\n\n      it \"raises an error when id is missing\" do\n        delete \"/invites.json\"\n        expect(response.status).to eq(400)\n      end\n\n      it \"raises an error when invite does not exist\" do\n        delete \"/invites.json\", params: { id: 848 }\n        expect(response.status).to eq(400)\n      end\n\n      it \"raises an error when invite is not created by user\" do\n        another_invite = Fabricate(:invite, email: \"test2@example.com\")\n\n        delete \"/invites.json\", params: { id: another_invite.id }\n        expect(response.status).to eq(400)\n      end\n\n      it \"destroys the invite\" do\n        delete \"/invites.json\", params: { id: invite.id }\n        expect(response.status).to eq(200)\n        expect(invite.reload.trashed?).to be_truthy\n      end\n    end\n  end\n\n  describe \"#perform_accept_invitation\" do\n    context \"with an invalid invite\" do\n      it \"redirects to the root\" do\n        put \"/invites/show/doesntexist.json\"\n        expect(response.status).to eq(404)\n        expect(response.parsed_body[\"message\"]).to eq(I18n.t(\"invite.not_found_json\"))\n        expect(session[:current_user_id]).to be_blank\n      end\n    end\n\n    context \"with a deleted invite\" do\n      fab!(:invite) { Fabricate(:invite) }\n\n      before { invite.trash! }\n\n      it \"redirects to the root\" do\n        put \"/invites/show/#{invite.invite_key}.json\"\n        expect(response.status).to eq(404)\n        expect(response.parsed_body[\"message\"]).to eq(I18n.t(\"invite.not_found_json\"))\n        expect(session[:current_user_id]).to be_blank\n      end\n    end\n\n    context \"with an expired invite\" do\n      fab!(:invite) { Fabricate(:invite, expires_at: 1.day.ago) }\n\n      it \"response is not successful\" do\n        put \"/invites/show/#{invite.invite_key}.json\"\n        expect(response.status).to eq(404)\n        expect(response.parsed_body[\"message\"]).to eq(I18n.t(\"invite.not_found_json\"))\n        expect(session[:current_user_id]).to be_blank\n      end\n    end\n\n    context \"with an email invite\" do\n      let(:topic) { Fabricate(:topic) }\n      let(:invite) { Invite.generate(topic.user, email: \"iceking@adventuretime.ooo\", topic: topic) }\n\n      it \"redeems the invite\" do\n        put \"/invites/show/#{invite.invite_key}.json\"\n        expect(invite.reload.redeemed?).to be_truthy\n      end\n\n      it \"logs in the user\" do\n        events =\n          DiscourseEvent.track_events do\n            put \"/invites/show/#{invite.invite_key}.json\",\n                params: {\n                  email_token: invite.email_token,\n                }\n          end\n\n        expect(events.map { |event| event[:event_name] }).to include(\n          :user_logged_in,\n          :user_first_logged_in,\n        )\n        expect(response.status).to eq(200)\n        expect(session[:current_user_id]).to eq(invite.invited_users.first.user_id)\n        expect(invite.reload.redeemed?).to be_truthy\n        user = User.find(invite.invited_users.first.user_id)\n        expect(user.ip_address).to be_present\n        expect(user.registration_ip_address).to be_present\n      end\n\n      it \"redirects to the first topic the user was invited to\" do\n        put \"/invites/show/#{invite.invite_key}.json\", params: { email_token: invite.email_token }\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"redirect_to\"]).to eq(topic.relative_url)\n        expect(\n          Notification.where(\n            notification_type: Notification.types[:invited_to_topic],\n            topic: topic,\n          ).count,\n        ).to eq(1)\n      end\n\n      it \"sets the timezone of the user in user_options\" do\n        put \"/invites/show/#{invite.invite_key}.json\", params: { timezone: \"Australia/Melbourne\" }\n        expect(response.status).to eq(200)\n        invite.reload\n        user = User.find(invite.invited_users.first.user_id)\n        expect(user.user_option.timezone).to eq(\"Australia/Melbourne\")\n      end\n\n      it \"does not log in the user if there are validation errors\" do\n        put \"/invites/show/#{invite.invite_key}.json\", params: { password: \"password\" }\n\n        expect(response.status).to eq(412)\n        expect(session[:current_user_id]).to eq(nil)\n      end\n\n      it \"does not log in the user if they were not approved\" do\n        SiteSetting.must_approve_users = true\n\n        put \"/invites/show/#{invite.invite_key}.json\",\n            params: {\n              password: SecureRandom.hex,\n              email_token: invite.email_token,\n            }\n\n        expect(session[:current_user_id]).to eq(nil)\n        expect(response.parsed_body[\"message\"]).to eq(I18n.t(\"activation.approval_required\"))\n      end\n\n      it \"does not log in the user if they were not activated\" do\n        put \"/invites/show/#{invite.invite_key}.json\", params: { password: SecureRandom.hex }\n\n        expect(session[:current_user_id]).to eq(nil)\n        expect(response.parsed_body[\"message\"]).to eq(I18n.t(\"invite.confirm_email\"))\n      end\n\n      it \"fails when local login is disabled and no external auth is configured\" do\n        SiteSetting.enable_local_logins = false\n\n        put \"/invites/show/#{invite.invite_key}.json\"\n        expect(response.status).to eq(404)\n      end\n\n      context \"with OmniAuth provider\" do\n        fab!(:authenticated_email) { \"test@example.com\" }\n\n        before do\n          OmniAuth.config.test_mode = true\n\n          OmniAuth.config.mock_auth[:google_oauth2] = OmniAuth::AuthHash.new(\n            provider: \"google_oauth2\",\n            uid: \"12345\",\n            info: OmniAuth::AuthHash::InfoHash.new(email: authenticated_email, name: \"First Last\"),\n            extra: {\n              raw_info:\n                OmniAuth::AuthHash.new(\n                  email_verified: true,\n                  email: authenticated_email,\n                  family_name: \"Last\",\n                  given_name: \"First\",\n                  gender: \"male\",\n                  name: \"First Last\",\n                ),\n            },\n          )\n\n          Rails.application.env_config[\"omniauth.auth\"] = OmniAuth.config.mock_auth[:google_oauth2]\n          SiteSetting.enable_google_oauth2_logins = true\n\n          get \"/auth/google_oauth2/callback.json\"\n          expect(response.status).to eq(302)\n        end\n\n        after do\n          Rails.application.env_config[\"omniauth.auth\"] = OmniAuth.config.mock_auth[\n            :google_oauth2\n          ] = nil\n          OmniAuth.config.test_mode = false\n        end\n\n        it \"should associate the invited user with authenticator records\" do\n          SiteSetting.auth_overrides_name = true\n          invite.update!(email: authenticated_email)\n\n          expect {\n            put \"/invites/show/#{invite.invite_key}.json\", params: { name: \"somename\" }\n          }.to change { User.with_email(authenticated_email).exists? }.to(true)\n          expect(response.status).to eq(200)\n\n          user = User.find_by_email(authenticated_email)\n          expect(user.name).to eq(\"First Last\")\n          expect(user.user_associated_accounts.first.provider_name).to eq(\"google_oauth2\")\n        end\n\n        it \"returns the right response even if local logins has been disabled\" do\n          SiteSetting.enable_local_logins = false\n          invite.update!(email: authenticated_email)\n\n          put \"/invites/show/#{invite.invite_key}.json\"\n          expect(response.status).to eq(200)\n        end\n\n        it \"returns the right response if authenticated email does not match invite email\" do\n          put \"/invites/show/#{invite.invite_key}.json\"\n          expect(response.status).to eq(412)\n        end\n      end\n\n      describe \".post_process_invite\" do\n        it \"sends a welcome message if set\" do\n          SiteSetting.send_welcome_message = true\n          user.send_welcome_message = true\n          put \"/invites/show/#{invite.invite_key}.json\"\n          expect(response.status).to eq(200)\n\n          expect(Jobs::SendSystemMessage.jobs.size).to eq(1)\n        end\n\n        it \"refreshes automatic groups if staff\" do\n          topic.user.grant_admin!\n          invite.update!(moderator: true)\n\n          put \"/invites/show/#{invite.invite_key}.json\"\n          expect(response.status).to eq(200)\n\n          expect(invite.invited_users.first.user.groups.pluck(:name)).to contain_exactly(\n            \"moderators\",\n            \"staff\",\n          )\n        end\n\n        context \"without password\" do\n          it \"sends password reset email\" do\n            put \"/invites/show/#{invite.invite_key}.json\"\n            expect(response.status).to eq(200)\n\n            expect(Jobs::InvitePasswordInstructionsEmail.jobs.size).to eq(1)\n            expect(Jobs::CriticalUserEmail.jobs.size).to eq(0)\n          end\n        end\n\n        context \"with password\" do\n          context \"when user was invited via email\" do\n            before { invite.update_column(:emailed_status, Invite.emailed_status_types[:pending]) }\n\n            it \"does not send an activation email and activates the user\" do\n              expect do\n                put \"/invites/show/#{invite.invite_key}.json\",\n                    params: {\n                      password: \"verystrongpassword\",\n                      email_token: invite.email_token,\n                    }\n              end.to change { UserAuthToken.count }.by(1)\n\n              expect(response.status).to eq(200)\n\n              expect(Jobs::InvitePasswordInstructionsEmail.jobs.size).to eq(0)\n              expect(Jobs::CriticalUserEmail.jobs.size).to eq(0)\n\n              invited_user = User.find_by_email(invite.email)\n              expect(invited_user.active).to eq(true)\n              expect(invited_user.email_confirmed?).to eq(true)\n            end\n\n            it \"does not activate user if email token is missing\" do\n              expect do\n                put \"/invites/show/#{invite.invite_key}.json\",\n                    params: {\n                      password: \"verystrongpassword\",\n                    }\n              end.not_to change { UserAuthToken.count }\n\n              expect(response.status).to eq(200)\n\n              expect(Jobs::InvitePasswordInstructionsEmail.jobs.size).to eq(0)\n              expect(Jobs::CriticalUserEmail.jobs.size).to eq(1)\n\n              invited_user = User.find_by_email(invite.email)\n              expect(invited_user.active).to eq(false)\n              expect(invited_user.email_confirmed?).to eq(false)\n            end\n          end\n\n          context \"when user was invited via link\" do\n            before do\n              invite.update_column(:emailed_status, Invite.emailed_status_types[:not_required])\n            end\n\n            it \"sends an activation email and does not activate the user\" do\n              expect do\n                put \"/invites/show/#{invite.invite_key}.json\",\n                    params: {\n                      password: \"verystrongpassword\",\n                    }\n              end.not_to change { UserAuthToken.count }\n\n              expect(response.status).to eq(200)\n              expect(response.parsed_body[\"message\"]).to eq(I18n.t(\"invite.confirm_email\"))\n\n              invited_user = User.find_by_email(invite.email)\n              expect(invited_user.active).to eq(false)\n              expect(invited_user.email_confirmed?).to eq(false)\n\n              expect(Jobs::InvitePasswordInstructionsEmail.jobs.size).to eq(0)\n              expect(Jobs::CriticalUserEmail.jobs.size).to eq(1)\n\n              tokens = EmailToken.where(user_id: invited_user.id, confirmed: false, expired: false)\n              expect(tokens.size).to eq(1)\n\n              job_args = Jobs::CriticalUserEmail.jobs.first[\"args\"].first\n              expect(job_args[\"type\"]).to eq(\"signup\")\n              expect(job_args[\"user_id\"]).to eq(invited_user.id)\n              expect(EmailToken.hash_token(job_args[\"email_token\"])).to eq(tokens.first.token_hash)\n            end\n          end\n        end\n      end\n    end\n\n    context \"with a domain invite\" do\n      fab!(:invite) do\n        Fabricate(\n          :invite,\n          email: nil,\n          emailed_status: Invite.emailed_status_types[:not_required],\n          domain: \"example.com\",\n        )\n      end\n\n      it \"creates an user if email matches domain\" do\n        expect {\n          put \"/invites/show/#{invite.invite_key}.json\",\n              params: {\n                email: \"test@example.com\",\n                password: \"verystrongpassword\",\n              }\n        }.to change { User.count }\n\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"message\"]).to eq(I18n.t(\"invite.confirm_email\"))\n        expect(invite.reload.redemption_count).to eq(1)\n\n        invited_user = User.find_by_email(\"test@example.com\")\n        expect(invited_user).to be_present\n      end\n\n      it \"does not create an user if email does not match domain\" do\n        expect {\n          put \"/invites/show/#{invite.invite_key}.json\",\n              params: {\n                email: \"test@example2.com\",\n                password: \"verystrongpassword\",\n              }\n        }.not_to change { User.count }\n\n        expect(response.status).to eq(412)\n        expect(response.parsed_body[\"message\"]).to eq(I18n.t(\"invite.domain_not_allowed\"))\n        expect(invite.reload.redemption_count).to eq(0)\n      end\n    end\n\n    context \"with an invite link\" do\n      fab!(:invite) do\n        Fabricate(:invite, email: nil, emailed_status: Invite.emailed_status_types[:not_required])\n      end\n\n      it \"sends an activation email and does not activate the user\" do\n        expect {\n          put \"/invites/show/#{invite.invite_key}.json\",\n              params: {\n                email: \"test@example.com\",\n                password: \"verystrongpassword\",\n              }\n        }.not_to change { UserAuthToken.count }\n\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"message\"]).to eq(I18n.t(\"invite.confirm_email\"))\n        expect(invite.reload.redemption_count).to eq(1)\n\n        invited_user = User.find_by_email(\"test@example.com\")\n        expect(invited_user.active).to eq(false)\n        expect(invited_user.email_confirmed?).to eq(false)\n\n        expect(Jobs::InvitePasswordInstructionsEmail.jobs.size).to eq(0)\n        expect(Jobs::CriticalUserEmail.jobs.size).to eq(1)\n\n        tokens = EmailToken.where(user_id: invited_user.id, confirmed: false, expired: false)\n        expect(tokens.size).to eq(1)\n\n        job_args = Jobs::CriticalUserEmail.jobs.first[\"args\"].first\n        expect(job_args[\"type\"]).to eq(\"signup\")\n        expect(job_args[\"user_id\"]).to eq(invited_user.id)\n        expect(EmailToken.hash_token(job_args[\"email_token\"])).to eq(tokens.first.token_hash)\n      end\n\n      it \"does not automatically log in the user if their email matches an existing user's and shows an error\" do\n        Fabricate(:user, email: \"test@example.com\")\n        put \"/invites/show/#{invite.invite_key}.json\",\n            params: {\n              email: \"test@example.com\",\n              password: \"verystrongpassword\",\n            }\n        expect(session[:current_user_id]).to be_blank\n        expect(response.status).to eq(412)\n        expect(response.parsed_body[\"message\"]).to include(\"Primary email has already been taken\")\n        expect(invite.reload.redemption_count).to eq(0)\n      end\n\n      it \"does not automatically log in the user if their email matches an existing admin's and shows an error\" do\n        Fabricate(:admin, email: \"test@example.com\")\n        put \"/invites/show/#{invite.invite_key}.json\",\n            params: {\n              email: \"test@example.com\",\n              password: \"verystrongpassword\",\n            }\n        expect(session[:current_user_id]).to be_blank\n        expect(response.status).to eq(412)\n        expect(response.parsed_body[\"message\"]).to include(\"Primary email has already been taken\")\n        expect(invite.reload.redemption_count).to eq(0)\n      end\n    end\n\n    context \"when new registrations are disabled\" do\n      fab!(:topic) { Fabricate(:topic) }\n      fab!(:invite) { Invite.generate(topic.user, email: \"test@example.com\", topic: topic) }\n\n      before { SiteSetting.allow_new_registrations = false }\n\n      it \"does not redeem the invite\" do\n        put \"/invites/show/#{invite.invite_key}.json\"\n        expect(response.status).to eq(200)\n        expect(invite.reload.invited_users).to be_blank\n        expect(invite.redeemed?).to be_falsey\n        expect(response.body).to include(I18n.t(\"login.new_registrations_disabled\"))\n      end\n    end\n\n    context \"when user is already logged in\" do\n      before { sign_in(user) }\n\n      context \"for an email invite\" do\n        fab!(:invite) { Fabricate(:invite, email: \"test@example.com\") }\n        fab!(:user) { Fabricate(:user, email: \"test@example.com\") }\n        fab!(:group) { Fabricate(:group) }\n\n        it \"redeems the invitation and creates the invite accepted notification\" do\n          put \"/invites/show/#{invite.invite_key}.json\", params: { id: invite.invite_key }\n          expect(response.status).to eq(200)\n          expect(response.parsed_body[\"message\"]).to eq(I18n.t(\"invite.existing_user_success\"))\n          invite.reload\n          expect(invite.invited_users.first.user).to eq(user)\n          expect(invite.redeemed?).to be_truthy\n          expect(\n            Notification.exists?(\n              user: invite.invited_by,\n              notification_type: Notification.types[:invitee_accepted],\n            ),\n          ).to eq(true)\n        end\n\n        it \"redirects to the first topic the user was invited to and creates the topic notification\" do\n          topic = Fabricate(:topic)\n          TopicInvite.create!(invite: invite, topic: topic)\n          put \"/invites/show/#{invite.invite_key}.json\", params: { id: invite.invite_key }\n          expect(response.status).to eq(200)\n          expect(response.parsed_body[\"redirect_to\"]).to eq(topic.relative_url)\n          expect(\n            Notification.where(\n              notification_type: Notification.types[:invited_to_topic],\n              topic: topic,\n            ).count,\n          ).to eq(1)\n        end\n\n        it \"adds the user to the private topic\" do\n          topic = Fabricate(:private_message_topic)\n          TopicInvite.create!(invite: invite, topic: topic)\n          put \"/invites/show/#{invite.invite_key}.json\", params: { id: invite.invite_key }\n          expect(response.status).to eq(200)\n          expect(response.parsed_body[\"redirect_to\"]).to eq(topic.relative_url)\n          expect(TopicAllowedUser.exists?(user: user, topic: topic)).to eq(true)\n        end\n\n        it \"adds the user to the groups specified on the invite and allows them to access the secure topic\" do\n          group.add_owner(invite.invited_by)\n          secured_category = Fabricate(:category)\n          secured_category.permissions = { group.name => :full }\n          secured_category.save!\n\n          topic = Fabricate(:topic, category: secured_category)\n          TopicInvite.create!(invite: invite, topic: topic)\n          InvitedGroup.create!(invite: invite, group: group)\n\n          put \"/invites/show/#{invite.invite_key}.json\", params: { id: invite.invite_key }\n          expect(response.status).to eq(200)\n          expect(response.parsed_body[\"message\"]).to eq(I18n.t(\"invite.existing_user_success\"))\n          expect(response.parsed_body[\"redirect_to\"]).to eq(topic.relative_url)\n          invite.reload\n          expect(invite.redeemed?).to be_truthy\n          expect(user.reload.groups).to include(group)\n          expect(\n            Notification.where(\n              notification_type: Notification.types[:invited_to_topic],\n              topic: topic,\n            ).count,\n          ).to eq(1)\n        end\n\n        it \"does not try to log in the user automatically\" do\n          expect do\n            put \"/invites/show/#{invite.invite_key}.json\", params: { id: invite.invite_key }\n          end.not_to change { UserAuthToken.count }\n          expect(response.status).to eq(200)\n          expect(response.parsed_body[\"message\"]).to eq(I18n.t(\"invite.existing_user_success\"))\n        end\n\n        it \"errors if the user's email doesn't match the invite email\" do\n          user.update!(email: \"blah@test.com\")\n          put \"/invites/show/#{invite.invite_key}.json\", params: { id: invite.invite_key }\n          expect(response.status).to eq(412)\n          expect(response.parsed_body[\"message\"]).to eq(I18n.t(\"invite.not_matching_email\"))\n        end\n\n        it \"errors if the user's email domain doesn't match the invite domain\" do\n          user.update!(email: \"blah@test.com\")\n          invite.update!(email: nil, domain: \"example.com\")\n          put \"/invites/show/#{invite.invite_key}.json\", params: { id: invite.invite_key }\n          expect(response.status).to eq(412)\n          expect(response.parsed_body[\"message\"]).to eq(I18n.t(\"invite.domain_not_allowed\"))\n        end\n      end\n\n      context \"for an invite link\" do\n        fab!(:invite) { Fabricate(:invite, email: nil) }\n        fab!(:user) { Fabricate(:user, email: \"test@example.com\") }\n        fab!(:group) { Fabricate(:group) }\n\n        it \"redeems the invitation and creates the invite accepted notification\" do\n          put \"/invites/show/#{invite.invite_key}.json\", params: { id: invite.invite_key }\n          expect(response.status).to eq(200)\n          expect(response.parsed_body[\"message\"]).to eq(I18n.t(\"invite.existing_user_success\"))\n          invite.reload\n          expect(invite.invited_users.first.user).to eq(user)\n          expect(invite.redeemed?).to be_truthy\n          expect(\n            Notification.exists?(\n              user: invite.invited_by,\n              notification_type: Notification.types[:invitee_accepted],\n            ),\n          ).to eq(true)\n        end\n\n        it \"redirects to the first topic the user was invited to and creates the topic notification\" do\n          topic = Fabricate(:topic)\n          TopicInvite.create!(invite: invite, topic: topic)\n          put \"/invites/show/#{invite.invite_key}.json\", params: { id: invite.invite_key }\n          expect(response.status).to eq(200)\n          expect(response.parsed_body[\"redirect_to\"]).to eq(topic.relative_url)\n          expect(\n            Notification.where(\n              notification_type: Notification.types[:invited_to_topic],\n              topic: topic,\n            ).count,\n          ).to eq(1)\n        end\n\n        it \"adds the user to the groups specified on the invite and allows them to access the secure topic\" do\n          group.add_owner(invite.invited_by)\n          secured_category = Fabricate(:category)\n          secured_category.permissions = { group.name => :full }\n          secured_category.save!\n\n          topic = Fabricate(:topic, category: secured_category)\n          TopicInvite.create!(invite: invite, topic: topic)\n          InvitedGroup.create!(invite: invite, group: group)\n\n          put \"/invites/show/#{invite.invite_key}.json\", params: { id: invite.invite_key }\n          expect(response.status).to eq(200)\n          expect(response.parsed_body[\"message\"]).to eq(I18n.t(\"invite.existing_user_success\"))\n          expect(response.parsed_body[\"redirect_to\"]).to eq(topic.relative_url)\n          invite.reload\n          expect(invite.redeemed?).to be_truthy\n          expect(user.reload.groups).to include(group)\n          expect(\n            Notification.where(\n              notification_type: Notification.types[:invited_to_topic],\n              topic: topic,\n            ).count,\n          ).to eq(1)\n        end\n\n        it \"does not try to log in the user automatically\" do\n          expect do\n            put \"/invites/show/#{invite.invite_key}.json\", params: { id: invite.invite_key }\n          end.not_to change { UserAuthToken.count }\n          expect(response.status).to eq(200)\n          expect(response.parsed_body[\"message\"]).to eq(I18n.t(\"invite.existing_user_success\"))\n        end\n      end\n    end\n\n    context \"with topic invites\" do\n      fab!(:invite) { Fabricate(:invite, email: \"test@example.com\") }\n\n      fab!(:secured_category) do\n        secured_category = Fabricate(:category)\n        secured_category.permissions = { staff: :full }\n        secured_category.save!\n        secured_category\n      end\n\n      it \"redirects user to topic if activated\" do\n        topic = Fabricate(:topic)\n        TopicInvite.create!(invite: invite, topic: topic)\n\n        put \"/invites/show/#{invite.invite_key}.json\", params: { email_token: invite.email_token }\n        expect(response.parsed_body[\"redirect_to\"]).to eq(topic.relative_url)\n        expect(\n          Notification.where(\n            notification_type: Notification.types[:invited_to_topic],\n            topic: topic,\n          ).count,\n        ).to eq(1)\n      end\n\n      it \"sets destination_url cookie if user is not activated\" do\n        topic = Fabricate(:topic)\n        TopicInvite.create!(invite: invite, topic: topic)\n\n        put \"/invites/show/#{invite.invite_key}.json\"\n        expect(cookies[\"destination_url\"]).to eq(topic.relative_url)\n        expect(\n          Notification.where(\n            notification_type: Notification.types[:invited_to_topic],\n            topic: topic,\n          ).count,\n        ).to eq(1)\n      end\n\n      it \"does not redirect user if they cannot see topic\" do\n        topic = Fabricate(:topic, category: secured_category)\n        TopicInvite.create!(invite: invite, topic: topic)\n\n        put \"/invites/show/#{invite.invite_key}.json\", params: { email_token: invite.email_token }\n        expect(response.parsed_body[\"redirect_to\"]).to eq(\"/\")\n        expect(\n          Notification.where(\n            notification_type: Notification.types[:invited_to_topic],\n            topic: topic,\n          ).count,\n        ).to eq(0)\n      end\n    end\n\n    context \"with staged user\" do\n      fab!(:invite) { Fabricate(:invite) }\n      fab!(:staged_user) { Fabricate(:user, staged: true, email: invite.email) }\n\n      it \"can keep the old username\" do\n        old_username = staged_user.username\n\n        put \"/invites/show/#{invite.invite_key}.json\",\n            params: {\n              username: staged_user.username,\n              password: \"Password123456\",\n              email_token: invite.email_token,\n            }\n\n        expect(response.status).to eq(200)\n        expect(invite.reload.redeemed?).to be_truthy\n        user = invite.invited_users.first.user\n        expect(user.username).to eq(old_username)\n      end\n\n      it \"can change the username\" do\n        put \"/invites/show/#{invite.invite_key}.json\",\n            params: {\n              username: \"new_username\",\n              password: \"Password123456\",\n              email_token: invite.email_token,\n            }\n\n        expect(response.status).to eq(200)\n        expect(invite.reload.redeemed?).to be_truthy\n        user = invite.invited_users.first.user\n        expect(user.username).to eq(\"new_username\")\n      end\n    end\n  end\n\n  describe \"#destroy_all_expired\" do\n    it \"removes all expired invites sent by a user\" do\n      SiteSetting.invite_expiry_days = 1\n\n      user = Fabricate(:admin)\n      invite_1 = Fabricate(:invite, invited_by: user)\n      invite_2 = Fabricate(:invite, invited_by: user)\n      expired_invite = Fabricate(:invite, invited_by: user)\n      expired_invite.update!(expires_at: 2.days.ago)\n\n      sign_in(user)\n      post \"/invites/destroy-all-expired\"\n\n      expect(response.status).to eq(200)\n      expect(invite_1.reload.deleted_at).to eq(nil)\n      expect(invite_2.reload.deleted_at).to eq(nil)\n      expect(expired_invite.reload.deleted_at).to be_present\n    end\n  end\n\n  describe \"#resend_invite\" do\n    it \"requires to be logged in\" do\n      post \"/invites/reinvite.json\", params: { email: \"first_name@example.com\" }\n      expect(response.status).to eq(403)\n    end\n\n    context \"while logged in\" do\n      fab!(:user) { sign_in(Fabricate(:user)) }\n      fab!(:invite) { Fabricate(:invite, invited_by: user) }\n      fab!(:another_invite) { Fabricate(:invite, email: \"last_name@example.com\") }\n\n      it \"raises an error when the email is missing\" do\n        post \"/invites/reinvite.json\"\n        expect(response.status).to eq(400)\n      end\n\n      it \"raises an error when the email cannot be found\" do\n        post \"/invites/reinvite.json\", params: { email: \"first_name@example.com\" }\n        expect(response.status).to eq(400)\n      end\n\n      it \"raises an error when the invite is not yours\" do\n        post \"/invites/reinvite.json\", params: { email: another_invite.email }\n        expect(response.status).to eq(400)\n      end\n\n      it \"resends the invite\" do\n        post \"/invites/reinvite.json\", params: { email: invite.email }\n        expect(response.status).to eq(200)\n        expect(Jobs::InviteEmail.jobs.size).to eq(1)\n      end\n    end\n  end\n\n  describe \"#resend_all_invites\" do\n    let(:admin) { Fabricate(:admin) }\n\n    before do\n      SiteSetting.invite_expiry_days = 30\n      RateLimiter.enable\n    end\n\n    use_redis_snapshotting\n\n    it \"resends all non-redeemed invites by a user\" do\n      freeze_time\n\n      new_invite = Fabricate(:invite, invited_by: admin)\n      expired_invite = Fabricate(:invite, invited_by: admin)\n      expired_invite.update!(expires_at: 2.days.ago)\n      redeemed_invite = Fabricate(:invite, invited_by: admin)\n      Fabricate(:invited_user, invite: redeemed_invite, user: Fabricate(:user))\n      redeemed_invite.update!(expires_at: 5.days.ago)\n\n      sign_in(admin)\n      post \"/invites/reinvite-all\"\n\n      expect(response.status).to eq(200)\n      expect(new_invite.reload.expires_at).to eq_time(30.days.from_now)\n      expect(expired_invite.reload.expires_at).to eq_time(2.days.ago)\n      expect(redeemed_invite.reload.expires_at).to eq_time(5.days.ago)\n    end\n\n    it \"errors if admins try to exceed limit of one bulk invite per day\" do\n      sign_in(admin)\n      start = Time.now\n\n      freeze_time(start)\n      post \"/invites/reinvite-all\"\n      expect(response.parsed_body[\"errors\"]).to_not be_present\n\n      freeze_time(start + 10.minutes)\n      post \"/invites/reinvite-all\"\n      expect(response.parsed_body[\"errors\"][0]).to eq(I18n.t(\"rate_limiter.slow_down\"))\n    end\n  end\n\n  describe \"#upload_csv\" do\n    it \"requires to be logged in\" do\n      post \"/invites/upload_csv.json\"\n      expect(response.status).to eq(403)\n    end\n\n    context \"while logged in\" do\n      let(:csv_file) { File.new(\"#{Rails.root}/spec/fixtures/csv/discourse.csv\") }\n      let(:file) { Rack::Test::UploadedFile.new(File.open(csv_file)) }\n\n      let(:csv_file_with_headers) do\n        File.new(\"#{Rails.root}/spec/fixtures/csv/discourse_headers.csv\")\n      end\n      let(:file_with_headers) { Rack::Test::UploadedFile.new(File.open(csv_file_with_headers)) }\n      let(:csv_file_with_locales) do\n        File.new(\"#{Rails.root}/spec/fixtures/csv/invites_with_locales.csv\")\n      end\n      let(:file_with_locales) { Rack::Test::UploadedFile.new(File.open(csv_file_with_locales)) }\n\n      it \"fails if you cannot bulk invite to the forum\" do\n        sign_in(Fabricate(:user))\n        post \"/invites/upload_csv.json\", params: { file: file, name: \"discourse.csv\" }\n        expect(response.status).to eq(403)\n      end\n\n      it \"allows admin to bulk invite\" do\n        sign_in(admin)\n        post \"/invites/upload_csv.json\", params: { file: file, name: \"discourse.csv\" }\n        expect(response.status).to eq(200)\n        expect(Jobs::BulkInvite.jobs.size).to eq(1)\n      end\n\n      it \"allows admin to bulk invite when DiscourseConnect enabled\" do\n        SiteSetting.discourse_connect_url = \"https://example.com\"\n        SiteSetting.enable_discourse_connect = true\n\n        sign_in(admin)\n        post \"/invites/upload_csv.json\", params: { file: file, name: \"discourse.csv\" }\n        expect(response.status).to eq(200)\n        expect(Jobs::BulkInvite.jobs.size).to eq(1)\n      end\n\n      it \"sends limited invites at a time\" do\n        SiteSetting.max_bulk_invites = 3\n        sign_in(admin)\n        post \"/invites/upload_csv.json\", params: { file: file, name: \"discourse.csv\" }\n\n        expect(response.status).to eq(422)\n        expect(Jobs::BulkInvite.jobs.size).to eq(1)\n        expect(response.parsed_body[\"errors\"][0]).to eq(\n          I18n.t(\"bulk_invite.max_rows\", max_bulk_invites: SiteSetting.max_bulk_invites),\n        )\n      end\n\n      it \"can import user fields\" do\n        Jobs.run_immediately!\n        user_field = Fabricate(:user_field, name: \"location\")\n        Fabricate(:group, name: \"discourse\")\n        Fabricate(:group, name: \"ubuntu\")\n\n        sign_in(admin)\n\n        post \"/invites/upload_csv.json\",\n             params: {\n               file: file_with_headers,\n               name: \"discourse_headers.csv\",\n             }\n        expect(response.status).to eq(200)\n\n        user = User.where(staged: true).find_by_email(\"test@example.com\")\n        expect(user.user_fields[user_field.id.to_s]).to eq(\"usa\")\n\n        user2 = User.where(staged: true).find_by_email(\"test2@example.com\")\n        expect(user2.user_fields[user_field.id.to_s]).to eq(\"europe\")\n      end\n\n      it \"can pre-set user locales\" do\n        Jobs.run_immediately!\n        sign_in(admin)\n\n        post \"/invites/upload_csv.json\",\n             params: {\n               file: file_with_locales,\n               name: \"discourse_headers.csv\",\n             }\n        expect(response.status).to eq(200)\n\n        user = User.where(staged: true).find_by_email(\"test@example.com\")\n        expect(user.locale).to eq(\"de\")\n\n        user2 = User.where(staged: true).find_by_email(\"test2@example.com\")\n        expect(user2.locale).to eq(\"pl\")\n      end\n    end\n  end\nend\n"], "fixing_code": ["# frozen_string_literal: true\n\nrequire \"csv\"\n\nclass InvitesController < ApplicationController\n  requires_login only: %i[\n                   create\n                   retrieve\n                   destroy\n                   destroy_all_expired\n                   resend_invite\n                   resend_all_invites\n                   upload_csv\n                 ]\n\n  skip_before_action :check_xhr, except: [:perform_accept_invitation]\n  skip_before_action :preload_json, except: [:show]\n  skip_before_action :redirect_to_login_if_required\n\n  before_action :ensure_invites_allowed, only: %i[show perform_accept_invitation]\n  before_action :ensure_new_registrations_allowed, only: %i[show perform_accept_invitation]\n\n  def show\n    expires_now\n\n    RateLimiter.new(nil, \"invites-show-#{request.remote_ip}\", 100, 1.minute).performed!\n\n    invite = Invite.find_by(invite_key: params[:id])\n\n    if invite.present? && invite.redeemable?\n      show_invite(invite)\n    else\n      show_irredeemable_invite(invite)\n    end\n  rescue RateLimiter::LimitExceeded => e\n    flash.now[:error] = e.description\n    render layout: \"no_ember\"\n  end\n\n  def create\n    if params[:topic_id].present?\n      topic = Topic.find_by(id: params[:topic_id])\n      raise Discourse::InvalidParameters.new(:topic_id) if topic.blank?\n      guardian.ensure_can_invite_to!(topic)\n    end\n\n    if params[:group_ids].present? || params[:group_names].present?\n      groups = Group.lookup_groups(group_ids: params[:group_ids], group_names: params[:group_names])\n    end\n\n    guardian.ensure_can_invite_to_forum!(groups)\n\n    if !groups_can_see_topic?(groups, topic)\n      editable_topic_groups = topic.category.groups.filter { |g| guardian.can_edit_group?(g) }\n      return(\n        render_json_error(\n          I18n.t(\"invite.requires_groups\", groups: editable_topic_groups.pluck(:name).join(\", \")),\n        )\n      )\n    end\n\n    invite =\n      Invite.generate(\n        current_user,\n        email: params[:email],\n        domain: params[:domain],\n        skip_email: params[:skip_email],\n        invited_by: current_user,\n        custom_message: params[:custom_message],\n        max_redemptions_allowed: params[:max_redemptions_allowed],\n        topic_id: topic&.id,\n        group_ids: groups&.map(&:id),\n        expires_at: params[:expires_at],\n        invite_to_topic: params[:invite_to_topic],\n      )\n\n    if invite.present?\n      render_serialized(\n        invite,\n        InviteSerializer,\n        scope: guardian,\n        root: nil,\n        show_emails: params.has_key?(:email),\n        show_warnings: true,\n      )\n    else\n      render json: failed_json, status: 422\n    end\n  rescue Invite::UserExists => e\n    render_json_error(e.message)\n  rescue ActiveRecord::RecordInvalid => e\n    render_json_error(e.record.errors.full_messages.first)\n  end\n\n  def retrieve\n    params.require(:email)\n\n    invite = Invite.find_by(invited_by: current_user, email: params[:email])\n    raise Discourse::InvalidParameters.new(:email) if invite.blank?\n\n    guardian.ensure_can_invite_to_forum!(nil)\n\n    render_serialized(\n      invite,\n      InviteSerializer,\n      scope: guardian,\n      root: nil,\n      show_emails: params.has_key?(:email),\n      show_warnings: true,\n    )\n  end\n\n  def update\n    invite = Invite.find_by(invited_by: current_user, id: params[:id])\n    raise Discourse::InvalidParameters.new(:id) if invite.blank?\n\n    if params[:topic_id].present?\n      topic = Topic.find_by(id: params[:topic_id])\n      raise Discourse::InvalidParameters.new(:topic_id) if topic.blank?\n      guardian.ensure_can_invite_to!(topic)\n    end\n\n    if params[:group_ids].present? || params[:group_names].present?\n      groups = Group.lookup_groups(group_ids: params[:group_ids], group_names: params[:group_names])\n    end\n\n    guardian.ensure_can_invite_to_forum!(groups)\n\n    Invite.transaction do\n      if params.has_key?(:topic_id)\n        invite.topic_invites.destroy_all\n        invite.topic_invites.create!(topic_id: topic.id) if topic.present?\n      end\n\n      if params.has_key?(:group_ids) || params.has_key?(:group_names)\n        invite.invited_groups.destroy_all\n        if groups.present?\n          groups.each { |group| invite.invited_groups.find_or_create_by!(group_id: group.id) }\n        end\n      end\n\n      if !groups_can_see_topic?(invite.groups, invite.topics.first)\n        editable_topic_groups =\n          invite.topics.first.category.groups.filter { |g| guardian.can_edit_group?(g) }\n        return(\n          render_json_error(\n            I18n.t(\"invite.requires_groups\", groups: editable_topic_groups.pluck(:name).join(\", \")),\n          )\n        )\n      end\n\n      if params.has_key?(:email)\n        old_email = invite.email.presence\n        new_email = params[:email].presence\n\n        if new_email\n          if Invite\n               .where.not(id: invite.id)\n               .find_by(email: new_email.downcase, invited_by_id: current_user.id)\n               &.redeemable?\n            return(\n              render_json_error(\n                I18n.t(\"invite.invite_exists\", email: CGI.escapeHTML(new_email)),\n                status: 409,\n              )\n            )\n          end\n        end\n\n        if old_email != new_email\n          invite.emailed_status =\n            if new_email && !params[:skip_email]\n              Invite.emailed_status_types[:pending]\n            else\n              Invite.emailed_status_types[:not_required]\n            end\n        end\n\n        invite.domain = nil if invite.email.present?\n      end\n\n      if params.has_key?(:domain)\n        invite.domain = params[:domain]\n\n        if invite.domain.present?\n          invite.email = nil\n          invite.emailed_status = Invite.emailed_status_types[:not_required]\n        end\n      end\n\n      if params[:send_email]\n        if invite.emailed_status != Invite.emailed_status_types[:pending]\n          begin\n            RateLimiter.new(current_user, \"resend-invite-per-hour\", 10, 1.hour).performed!\n          rescue RateLimiter::LimitExceeded\n            return render_json_error(I18n.t(\"rate_limiter.slow_down\"))\n          end\n        end\n\n        invite.emailed_status = Invite.emailed_status_types[:pending]\n      end\n\n      begin\n        invite.update!(\n          params.permit(:email, :custom_message, :max_redemptions_allowed, :expires_at),\n        )\n      rescue ActiveRecord::RecordInvalid => e\n        return render_json_error(e.record.errors.full_messages.first)\n      end\n    end\n\n    if invite.emailed_status == Invite.emailed_status_types[:pending]\n      invite.update_column(:emailed_status, Invite.emailed_status_types[:sending])\n      Jobs.enqueue(:invite_email, invite_id: invite.id, invite_to_topic: params[:invite_to_topic])\n    end\n\n    render_serialized(\n      invite,\n      InviteSerializer,\n      scope: guardian,\n      root: nil,\n      show_emails: params.has_key?(:email),\n      show_warnings: true,\n    )\n  end\n\n  def destroy\n    params.require(:id)\n\n    invite = Invite.find_by(invited_by_id: current_user.id, id: params[:id])\n    raise Discourse::InvalidParameters.new(:id) if invite.blank?\n\n    invite.trash!(current_user)\n\n    render json: success_json\n  end\n\n  # For DiscourseConnect SSO, all invite acceptance is done\n  # via the SessionController#sso_login route\n  def perform_accept_invitation\n    params.require(:id)\n    params.permit(\n      :email,\n      :username,\n      :name,\n      :password,\n      :timezone,\n      :email_token,\n      user_custom_fields: {\n      },\n    )\n\n    invite = Invite.find_by(invite_key: params[:id])\n    redeeming_user = current_user\n\n    if invite.present?\n      begin\n        attrs = { ip_address: request.remote_ip, session: session }\n\n        if redeeming_user\n          attrs[:redeeming_user] = redeeming_user\n        else\n          attrs[:username] = params[:username]\n          attrs[:name] = params[:name]\n          attrs[:password] = params[:password]\n          attrs[:user_custom_fields] = params[:user_custom_fields]\n\n          # If the invite is not scoped to an email then we allow the\n          # user to provide it themselves\n          if invite.is_invite_link?\n            params.require(:email)\n            attrs[:email] = params[:email]\n          else\n            # Otherwise we always use the email from the invitation.\n            attrs[:email] = invite.email\n            attrs[:email_token] = params[:email_token] if params[:email_token].present?\n          end\n        end\n\n        user = invite.redeem(**attrs)\n      rescue ActiveRecord::RecordInvalid,\n             ActiveRecord::RecordNotSaved,\n             ActiveRecord::LockWaitTimeout,\n             Invite::UserExists => e\n        return render json: failed_json.merge(message: e.message), status: 412\n      end\n\n      if user.blank?\n        return render json: failed_json.merge(message: I18n.t(\"invite.not_found_json\")), status: 404\n      end\n\n      log_on_user(user) if !redeeming_user && user.active? && user.guardian.can_access_forum?\n\n      user.update_timezone_if_missing(params[:timezone])\n      post_process_invite(user)\n      create_topic_invite_notifications(invite, user)\n\n      topic = invite.topics.first\n      response = {}\n\n      if user.present?\n        if user.active? && user.guardian.can_access_forum?\n          response[:message] = I18n.t(\"invite.existing_user_success\") if redeeming_user\n\n          if user.guardian.can_see?(topic)\n            response[:redirect_to] = path(topic.relative_url)\n          else\n            response[:redirect_to] = path(\"/\")\n          end\n        else\n          response[:message] = if user.active?\n            I18n.t(\"activation.approval_required\")\n          else\n            I18n.t(\"invite.confirm_email\")\n          end\n\n          cookies[:destination_url] = path(topic.relative_url) if user.guardian.can_see?(topic)\n        end\n      end\n\n      render json: success_json.merge(response)\n    else\n      render json: failed_json.merge(message: I18n.t(\"invite.not_found_json\")), status: 404\n    end\n  end\n\n  def destroy_all_expired\n    guardian.ensure_can_destroy_all_invites!(current_user)\n\n    Invite\n      .where(invited_by: current_user)\n      .where(\"expires_at < ?\", Time.zone.now)\n      .find_each { |invite| invite.trash!(current_user) }\n\n    render json: success_json\n  end\n\n  def resend_invite\n    params.require(:email)\n    RateLimiter.new(current_user, \"resend-invite-per-hour\", 10, 1.hour).performed!\n\n    invite = Invite.find_by(invited_by_id: current_user.id, email: params[:email])\n    raise Discourse::InvalidParameters.new(:email) if invite.blank?\n    invite.resend_invite\n    render json: success_json\n  rescue RateLimiter::LimitExceeded\n    render_json_error(I18n.t(\"rate_limiter.slow_down\"))\n  end\n\n  def resend_all_invites\n    guardian.ensure_can_resend_all_invites!(current_user)\n\n    begin\n      RateLimiter.new(\n        current_user,\n        \"bulk-reinvite-per-day\",\n        1,\n        1.day,\n        apply_limit_to_staff: true,\n      ).performed!\n    rescue RateLimiter::LimitExceeded\n      return render_json_error(I18n.t(\"rate_limiter.slow_down\"))\n    end\n\n    Invite\n      .pending(current_user)\n      .where(\"invites.email IS NOT NULL\")\n      .find_each { |invite| invite.resend_invite }\n\n    render json: success_json\n  end\n\n  def upload_csv\n    guardian.ensure_can_bulk_invite_to_forum!(current_user)\n\n    hijack do\n      begin\n        file = params[:file] || params[:files].first\n\n        csv_header = nil\n        invites = []\n\n        CSV.foreach(file.tempfile, encoding: \"bom|utf-8\") do |row|\n          # Try to extract a CSV header, if it exists\n          if csv_header.nil?\n            if row[0] == \"email\"\n              csv_header = row\n              next\n            else\n              csv_header = %w[email groups topic_id]\n            end\n          end\n\n          invites.push(csv_header.zip(row).map.to_h.filter { |k, v| v.present? }) if row[0].present?\n\n          break if invites.count >= SiteSetting.max_bulk_invites\n        end\n\n        if invites.present?\n          Jobs.enqueue(:bulk_invite, invites: invites, current_user_id: current_user.id)\n\n          if invites.count >= SiteSetting.max_bulk_invites\n            render json:\n                     failed_json.merge(\n                       errors: [\n                         I18n.t(\n                           \"bulk_invite.max_rows\",\n                           max_bulk_invites: SiteSetting.max_bulk_invites,\n                         ),\n                       ],\n                     ),\n                   status: 422\n          else\n            render json: success_json\n          end\n        else\n          render json: failed_json.merge(errors: [I18n.t(\"bulk_invite.error\")]), status: 422\n        end\n      end\n    end\n  end\n\n  private\n\n  def show_invite(invite)\n    email = Email.obfuscate(invite.email)\n\n    # Show email if the user already authenticated their email\n    different_external_email = false\n\n    if session[:authentication]\n      auth_result = Auth::Result.from_session_data(session[:authentication], user: nil)\n      if invite.email == auth_result.email\n        email = invite.email\n      else\n        different_external_email = true\n      end\n    end\n\n    email_verified_by_link = invite.email_token.present? && params[:t] == invite.email_token\n\n    email = invite.email if email_verified_by_link\n\n    hidden_email = email != invite.email\n\n    if hidden_email || invite.email.nil?\n      username = \"\"\n    else\n      username = UserNameSuggester.suggest(invite.email)\n    end\n\n    info = {\n      invited_by: UserNameSerializer.new(invite.invited_by, scope: guardian, root: false),\n      email: email,\n      hidden_email: hidden_email,\n      username: username,\n      is_invite_link: invite.is_invite_link?,\n      email_verified_by_link: email_verified_by_link,\n    }\n\n    info[:different_external_email] = true if different_external_email\n\n    if staged_user = User.where(staged: true).with_email(invite.email).first\n      info[:username] = staged_user.username\n      info[:user_fields] = staged_user.user_fields\n    end\n\n    if current_user\n      info[:existing_user_id] = current_user.id\n      info[:existing_user_can_redeem] = invite.can_be_redeemed_by?(current_user)\n      info[:existing_user_can_redeem_error] = existing_user_can_redeem_error(invite)\n      info[:email] = current_user.email\n      info[:username] = current_user.username\n    end\n\n    store_preloaded(\"invite_info\", MultiJson.dump(info))\n\n    secure_session[\"invite-key\"] = invite.invite_key\n\n    render layout: \"application\"\n  end\n\n  def show_irredeemable_invite(invite)\n    flash.now[:error] = if invite.blank?\n      I18n.t(\"invite.not_found\", base_url: Discourse.base_url)\n    elsif invite.redeemed?\n      if invite.is_invite_link?\n        I18n.t(\n          \"invite.not_found_template_link\",\n          site_name: SiteSetting.title,\n          base_url: Discourse.base_url,\n        )\n      else\n        I18n.t(\n          \"invite.not_found_template\",\n          site_name: SiteSetting.title,\n          base_url: Discourse.base_url,\n        )\n      end\n    elsif invite.expired?\n      I18n.t(\"invite.expired\", base_url: Discourse.base_url)\n    end\n\n    render layout: \"no_ember\"\n  end\n\n  def ensure_invites_allowed\n    if (\n         !SiteSetting.enable_local_logins && Discourse.enabled_auth_providers.count == 0 &&\n           !SiteSetting.enable_discourse_connect\n       )\n      raise Discourse::NotFound\n    end\n  end\n\n  def ensure_new_registrations_allowed\n    unless SiteSetting.allow_new_registrations\n      flash[:error] = I18n.t(\"login.new_registrations_disabled\")\n      render layout: \"no_ember\"\n      false\n    end\n  end\n\n  def groups_can_see_topic?(groups, topic)\n    if topic&.read_restricted_category?\n      topic_groups = topic.category.groups\n      return false if (groups & topic_groups).blank?\n    end\n\n    true\n  end\n\n  def post_process_invite(user)\n    user.enqueue_welcome_message(\"welcome_invite\") if user.send_welcome_message\n\n    Group.refresh_automatic_groups!(:admins, :moderators, :staff) if user.staff?\n\n    if user.has_password?\n      if !user.active\n        email_token =\n          user.email_tokens.create!(email: user.email, scope: EmailToken.scopes[:signup])\n        EmailToken.enqueue_signup_email(email_token)\n      end\n    elsif !SiteSetting.enable_discourse_connect && SiteSetting.enable_local_logins\n      Jobs.enqueue(:invite_password_instructions_email, username: user.username)\n    end\n  end\n\n  def create_topic_invite_notifications(invite, user)\n    invite.topics.each do |topic|\n      if user.guardian.can_see?(topic)\n        last_notification =\n          user\n            .notifications\n            .where(notification_type: Notification.types[:invited_to_topic])\n            .where(topic_id: topic.id)\n            .where(post_number: 1)\n            .where(\"created_at > ?\", 1.hour.ago)\n\n        if !last_notification.exists?\n          topic.create_invite_notification!(\n            user,\n            Notification.types[:invited_to_topic],\n            invite.invited_by,\n          )\n        end\n      end\n    end\n  end\n\n  def existing_user_can_redeem_error(invite)\n    return if invite.can_be_redeemed_by?(current_user)\n    if invite.invited_users.exists?(user: current_user)\n      I18n.t(\"invite.existing_user_already_redemeed\")\n    else\n      I18n.t(\"invite.existing_user_cannot_redeem\")\n    end\n  end\nend\n", "# frozen_string_literal: true\n\n# NOTE: There are a _lot_ of complicated rules and conditions for our\n# invite system, and the code is spread out through a lot of places.\n# Tread lightly and read carefully when modifying this code. You may\n# also want to look at:\n#\n# * InvitesController\n# * SessionController\n# * Invite model\n# * User model\n#\n# Invites that are scoped to a specific email (email IS NOT NULL on the Invite\n# model) have different rules to invites that are considered an \"invite link\",\n# (email IS NULL) on the Invite model.\nclass InviteRedeemer\n  attr_reader :invite,\n              :email,\n              :username,\n              :name,\n              :password,\n              :user_custom_fields,\n              :ip_address,\n              :session,\n              :email_token,\n              :redeeming_user\n\n  def initialize(\n    invite:,\n    email: nil,\n    username: nil,\n    name: nil,\n    password: nil,\n    user_custom_fields: nil,\n    ip_address: nil,\n    session: nil,\n    email_token: nil,\n    redeeming_user: nil\n  )\n    @invite = invite\n    @username = username\n    @name = name\n    @password = password\n    @user_custom_fields = user_custom_fields\n    @ip_address = ip_address\n    @session = session\n    @email_token = email_token\n    @redeeming_user = redeeming_user\n\n    ensure_email_is_present!(email)\n  end\n\n  def redeem\n    Invite.transaction do\n      if can_redeem_invite? && mark_invite_redeemed\n        process_invitation\n        invited_user\n      end\n    end\n  end\n\n  # The email must be present in some form since many of the methods\n  # for processing + redemption rely on it. If it's still nil after\n  # these checks then we have hit an edge case and should not proceed!\n  def ensure_email_is_present!(email)\n    if email.blank?\n      Rails.logger.warn(\n        \"email param was blank in InviteRedeemer for invite ID #{@invite.id}. The `redeeming_user` was #{@redeeming_user.present? ? \"(ID: #{@redeeming_user.id})\" : \"not\"} present.\",\n      )\n    end\n\n    if email.blank? && @invite.is_email_invite?\n      @email = @invite.email\n    elsif @redeeming_user.present?\n      @email = @redeeming_user.email\n    else\n      @email = email\n    end\n\n    raise Discourse::InvalidParameters if @email.blank?\n  end\n\n  # This will _never_ be called if there is a redeeming_user being passed\n  # in to InviteRedeemer -- see invited_user below.\n  def self.create_user_from_invite(\n    email:,\n    invite:,\n    username: nil,\n    name: nil,\n    password: nil,\n    user_custom_fields: nil,\n    ip_address: nil,\n    session: nil,\n    email_token: nil\n  )\n    if username && UsernameValidator.new(username).valid_format? &&\n         User.username_available?(username, email)\n      available_username = username\n    else\n      available_username = UserNameSuggester.suggest(email)\n    end\n\n    user = User.where(staged: true).with_email(email.strip.downcase).first\n    user.unstage! if user\n    user ||= User.new\n\n    user.attributes = {\n      email: email,\n      username: available_username,\n      name: name || available_username,\n      active: false,\n      trust_level: SiteSetting.default_invitee_trust_level,\n      ip_address: ip_address,\n      registration_ip_address: ip_address,\n    }\n\n    if (!SiteSetting.must_approve_users && SiteSetting.invite_only) ||\n         (SiteSetting.must_approve_users? && EmailValidator.can_auto_approve_user?(user.email))\n      ReviewableUser.set_approved_fields!(user, Discourse.system_user)\n    end\n\n    user_fields = UserField.all\n    if user_custom_fields.present? && user_fields.present?\n      field_params = user_custom_fields || {}\n      fields = user.custom_fields\n\n      user_fields.each do |f|\n        field_val = field_params[f.id.to_s]\n        fields[\"#{User::USER_FIELD_PREFIX}#{f.id}\"] = field_val[\n          0...UserField.max_length\n        ] unless field_val.blank?\n      end\n      user.custom_fields = fields\n    end\n\n    user.moderator = true if invite.moderator? && invite.invited_by.staff?\n\n    if password\n      user.password = password\n      user.password_required!\n    end\n\n    authenticator = UserAuthenticator.new(user, session, require_password: false)\n\n    if !authenticator.has_authenticator? && !SiteSetting.enable_local_logins\n      raise ActiveRecord::RecordNotSaved.new(I18n.t(\"login.incorrect_username_email_or_password\"))\n    end\n\n    authenticator.start\n\n    if authenticator.email_valid? && !authenticator.authenticated?\n      raise ActiveRecord::RecordNotSaved.new(I18n.t(\"login.incorrect_username_email_or_password\"))\n    end\n\n    user.save!\n    authenticator.finish\n\n    if invite.emailed_status != Invite.emailed_status_types[:not_required] &&\n         email == invite.email && invite.email_token.present? && email_token == invite.email_token\n      user.activate\n    end\n\n    User.find(user.id)\n  end\n\n  private\n\n  def can_redeem_invite?\n    return false if !invite.redeemable?\n    return false if email.blank?\n\n    # Invite scoped to email has already been redeemed by anyone.\n    return false if invite.is_email_invite? && InvitedUser.exists?(invite_id: invite.id)\n\n    # The email will be present for either an invite link (where the user provides\n    # us the email manually) or for an invite scoped to an email, where we\n    # prefill the email and do not let the user modify it.\n    #\n    # Note that an invite link can also have a domain scope which must be checked.\n    email_to_check = redeeming_user&.email || email\n\n    if invite.email.present? && !invite.email_matches?(email_to_check)\n      raise ActiveRecord::RecordNotSaved.new(I18n.t(\"invite.not_matching_email\"))\n    end\n\n    if invite.domain.present? && !invite.domain_matches?(email_to_check)\n      raise ActiveRecord::RecordNotSaved.new(I18n.t(\"invite.domain_not_allowed\"))\n    end\n\n    # Anon user is trying to redeem an invitation, if an existing user already\n    # redeemed it then we cannot redeem now.\n    redeeming_user ||= User.where(admin: false, staged: false).find_by_email(email)\n    if redeeming_user.present? &&\n         InvitedUser.exists?(user_id: redeeming_user.id, invite_id: invite.id)\n      return false\n    end\n\n    true\n  end\n\n  # Note that the invited_user is returned by #redeemed, so other places\n  # (e.g. the InvitesController) can perform further actions on it, this\n  # is why things like send_welcome_message are set without being saved\n  # on the model.\n  def invited_user\n    return @invited_user if defined?(@invited_user)\n\n    # The redeeming user is an already logged in user or a user who is\n    # activating their account who is redeeming the invite,\n    # which is valid for existing users to be invited to topics or groups.\n    if redeeming_user.present?\n      @invited_user = redeeming_user\n      return @invited_user\n    end\n\n    # If there was no logged in user then we must attempt to create\n    # one based on the provided params.\n    invited_user ||=\n      InviteRedeemer.create_user_from_invite(\n        email: email,\n        invite: invite,\n        username: username,\n        name: name,\n        password: password,\n        user_custom_fields: user_custom_fields,\n        ip_address: ip_address,\n        session: session,\n        email_token: email_token,\n      )\n    invited_user.send_welcome_message = false\n    @invited_user = invited_user\n    @invited_user\n  end\n\n  def process_invitation\n    add_to_private_topics_if_invited\n    add_user_to_groups\n    send_welcome_message\n    notify_invitee\n  end\n\n  def mark_invite_redeemed\n    @invited_user_record = InvitedUser.create!(invite_id: invite.id, redeemed_at: Time.zone.now)\n\n    if @invited_user_record.present?\n      invite.with_lock(\"FOR UPDATE NOWAIT\") do\n        Invite.increment_counter(:redemption_count, invite.id)\n        invite.save!\n      end\n      delete_duplicate_invites\n    end\n\n    @invited_user_record.present?\n  end\n\n  def add_to_private_topics_if_invited\n    # Should not happen because of ensure_email_is_present!, but better to cover bases.\n    return if email.blank?\n\n    topic_ids =\n      TopicInvite\n        .joins(:invite)\n        .joins(:topic)\n        .where(\"topics.archetype = ?\", Archetype.private_message)\n        .where(\"invites.email = ?\", email)\n        .pluck(:topic_id)\n    topic_ids.each do |id|\n      if !TopicAllowedUser.exists?(user_id: invited_user.id, topic_id: id)\n        TopicAllowedUser.create!(user_id: invited_user.id, topic_id: id)\n      end\n    end\n  end\n\n  def add_user_to_groups\n    guardian = Guardian.new(invite.invited_by)\n    new_group_ids = invite.groups.pluck(:id) - invited_user.group_users.pluck(:group_id)\n    new_group_ids.each do |id|\n      group = Group.find_by(id: id)\n      if guardian.can_edit_group?(group)\n        invited_user.group_users.create!(group_id: group.id)\n        GroupActionLogger.new(invite.invited_by, group).log_add_user_to_group(invited_user)\n        DiscourseEvent.trigger(:user_added_to_group, invited_user, group, automatic: false)\n      end\n    end\n  end\n\n  def send_welcome_message\n    @invited_user_record.update!(user_id: invited_user.id)\n    invited_user.send_welcome_message = true\n  end\n\n  def notify_invitee\n    return if invite.invited_by.blank?\n    invite.invited_by.notifications.create!(\n      notification_type: Notification.types[:invitee_accepted],\n      data: { display_username: invited_user.username }.to_json,\n    )\n  end\n\n  def delete_duplicate_invites\n    # Should not happen because of ensure_email_is_present!, but better to cover bases.\n    return if email.blank?\n\n    Invite\n      .where(\"invites.max_redemptions_allowed = 1\")\n      .joins(\"LEFT JOIN invited_users ON invites.id = invited_users.invite_id\")\n      .where(\"invited_users.user_id IS NULL\")\n      .where(\"invites.email = ? AND invites.id != ?\", email, invite.id)\n      .delete_all\n  end\nend\n", "# frozen_string_literal: true\n\nRSpec.describe InvitesController do\n  fab!(:admin) { Fabricate(:admin) }\n  fab!(:user) { Fabricate(:user, trust_level: SiteSetting.min_trust_level_to_allow_invite) }\n\n  describe \"#show\" do\n    fab!(:invite) { Fabricate(:invite) }\n\n    it \"shows the accept invite page\" do\n      get \"/invites/#{invite.invite_key}\"\n      expect(response.status).to eq(200)\n      expect(response.body).to have_tag(:script, with: { src: \"/assets/discourse.js\" })\n      expect(response.body).not_to include(invite.email)\n      expect(response.body).to_not include(\n        I18n.t(\n          \"invite.not_found_template\",\n          site_name: SiteSetting.title,\n          base_url: Discourse.base_url,\n        ),\n      )\n\n      expect(response.body).to have_tag(\"div#data-preloaded\") do |element|\n        json = JSON.parse(element.current_scope.attribute(\"data-preloaded\").value)\n        invite_info = JSON.parse(json[\"invite_info\"])\n        expect(invite_info[\"username\"]).to eq(\"\")\n        expect(invite_info[\"email\"]).to eq(\"i*****g@a***********e.ooo\")\n      end\n    end\n\n    context \"when email data is present in authentication data\" do\n      let(:store) { ActionDispatch::Session::CookieStore.new({}) }\n      let(:session_stub) do\n        ActionDispatch::Request::Session.create(store, ActionDispatch::TestRequest.create, {})\n      end\n\n      before do\n        session_stub[:authentication] = { email: invite.email }\n        ActionDispatch::Request.any_instance.stubs(:session).returns(session_stub)\n      end\n\n      it \"shows unobfuscated email\" do\n        get \"/invites/#{invite.invite_key}\"\n        expect(response.status).to eq(200)\n        expect(response.body).to have_tag(:script, with: { src: \"/assets/discourse.js\" })\n        expect(response.body).to include(invite.email)\n        expect(response.body).not_to include(\"i*****g@a***********e.ooo\")\n      end\n    end\n\n    it \"shows default user fields\" do\n      user_field = Fabricate(:user_field)\n      staged_user = Fabricate(:user, staged: true, email: invite.email)\n      staged_user.set_user_field(user_field.id, \"some value\")\n      staged_user.save_custom_fields\n\n      get \"/invites/#{invite.invite_key}\"\n      expect(response.body).to have_tag(\"div#data-preloaded\") do |element|\n        json = JSON.parse(element.current_scope.attribute(\"data-preloaded\").value)\n        invite_info = JSON.parse(json[\"invite_info\"])\n        expect(invite_info[\"username\"]).to eq(staged_user.username)\n        expect(invite_info[\"user_fields\"][user_field.id.to_s]).to eq(\"some value\")\n      end\n    end\n\n    it \"includes token validity boolean\" do\n      get \"/invites/#{invite.invite_key}\"\n      expect(response.body).to have_tag(\"div#data-preloaded\") do |element|\n        json = JSON.parse(element.current_scope.attribute(\"data-preloaded\").value)\n        invite_info = JSON.parse(json[\"invite_info\"])\n        expect(invite_info[\"email_verified_by_link\"]).to eq(false)\n      end\n\n      get \"/invites/#{invite.invite_key}?t=#{invite.email_token}\"\n      expect(response.body).to have_tag(\"div#data-preloaded\") do |element|\n        json = JSON.parse(element.current_scope.attribute(\"data-preloaded\").value)\n        invite_info = JSON.parse(json[\"invite_info\"])\n        expect(invite_info[\"email_verified_by_link\"]).to eq(true)\n      end\n    end\n\n    describe \"logged in user viewing an invite\" do\n      fab!(:group) { Fabricate(:group) }\n\n      before { sign_in(user) }\n\n      it \"shows the accept invite page when user's email matches the invite email\" do\n        invite.update_columns(email: user.email)\n\n        get \"/invites/#{invite.invite_key}\"\n        expect(response.status).to eq(200)\n        expect(response.body).to have_tag(:script, with: { src: \"/assets/discourse.js\" })\n        expect(response.body).not_to include(\n          I18n.t(\n            \"invite.not_found_template\",\n            site_name: SiteSetting.title,\n            base_url: Discourse.base_url,\n          ),\n        )\n\n        expect(response.body).to have_tag(\"div#data-preloaded\") do |element|\n          json = JSON.parse(element.current_scope.attribute(\"data-preloaded\").value)\n          invite_info = JSON.parse(json[\"invite_info\"])\n          expect(invite_info[\"username\"]).to eq(user.username)\n          expect(invite_info[\"email\"]).to eq(user.email)\n          expect(invite_info[\"existing_user_id\"]).to eq(user.id)\n          expect(invite_info[\"existing_user_can_redeem\"]).to eq(true)\n        end\n      end\n\n      it \"shows the accept invite page when user's email domain matches the domain an invite link is restricted to\" do\n        invite.update!(email: nil, domain: \"discourse.org\")\n        user.update!(email: \"someguy@discourse.org\")\n\n        get \"/invites/#{invite.invite_key}\"\n        expect(response.status).to eq(200)\n        expect(response.body).to have_tag(:script, with: { src: \"/assets/discourse.js\" })\n        expect(response.body).not_to include(\n          I18n.t(\n            \"invite.not_found_template\",\n            site_name: SiteSetting.title,\n            base_url: Discourse.base_url,\n          ),\n        )\n\n        expect(response.body).to have_tag(\"div#data-preloaded\") do |element|\n          json = JSON.parse(element.current_scope.attribute(\"data-preloaded\").value)\n          invite_info = JSON.parse(json[\"invite_info\"])\n          expect(invite_info[\"username\"]).to eq(user.username)\n          expect(invite_info[\"email\"]).to eq(user.email)\n          expect(invite_info[\"existing_user_id\"]).to eq(user.id)\n          expect(invite_info[\"existing_user_can_redeem\"]).to eq(true)\n        end\n      end\n\n      it \"does not allow the user to accept the invite when their email domain does not match the domain of the invite\" do\n        user.update!(email: \"someguy@discourse.com\")\n        invite.update!(email: nil, domain: \"discourse.org\")\n\n        get \"/invites/#{invite.invite_key}\"\n        expect(response.status).to eq(200)\n\n        expect(response.body).to have_tag(\"div#data-preloaded\") do |element|\n          json = JSON.parse(element.current_scope.attribute(\"data-preloaded\").value)\n          invite_info = JSON.parse(json[\"invite_info\"])\n          expect(invite_info[\"existing_user_can_redeem\"]).to eq(false)\n          expect(invite_info[\"existing_user_can_redeem_error\"]).to eq(\n            I18n.t(\"invite.existing_user_cannot_redeem\"),\n          )\n        end\n      end\n\n      it \"does not allow the user to accept the invite when their email does not match the invite\" do\n        invite.update_columns(email: \"notuseremail@discourse.org\")\n\n        get \"/invites/#{invite.invite_key}\"\n        expect(response.status).to eq(200)\n\n        expect(response.body).to have_tag(\"div#data-preloaded\") do |element|\n          json = JSON.parse(element.current_scope.attribute(\"data-preloaded\").value)\n          invite_info = JSON.parse(json[\"invite_info\"])\n          expect(invite_info[\"existing_user_can_redeem\"]).to eq(false)\n        end\n      end\n\n      it \"does not allow the user to accept the invite when a multi-use invite link has already been redeemed by the user\" do\n        invite.update!(email: nil, max_redemptions_allowed: 10)\n        expect(invite.redeem(redeeming_user: user)).not_to eq(nil)\n\n        get \"/invites/#{invite.invite_key}\"\n        expect(response.status).to eq(200)\n\n        expect(response.body).to have_tag(\"div#data-preloaded\") do |element|\n          json = JSON.parse(element.current_scope.attribute(\"data-preloaded\").value)\n          invite_info = JSON.parse(json[\"invite_info\"])\n          expect(invite_info[\"existing_user_id\"]).to eq(user.id)\n          expect(invite_info[\"existing_user_can_redeem\"]).to eq(false)\n          expect(invite_info[\"existing_user_can_redeem_error\"]).to eq(\n            I18n.t(\"invite.existing_user_already_redemeed\"),\n          )\n        end\n      end\n\n      it \"allows the user to accept the invite when its an invite link that they have not redeemed\" do\n        invite.update!(email: nil, max_redemptions_allowed: 10)\n\n        get \"/invites/#{invite.invite_key}\"\n        expect(response.status).to eq(200)\n\n        expect(response.body).to have_tag(\"div#data-preloaded\") do |element|\n          json = JSON.parse(element.current_scope.attribute(\"data-preloaded\").value)\n          invite_info = JSON.parse(json[\"invite_info\"])\n          expect(invite_info[\"existing_user_id\"]).to eq(user.id)\n          expect(invite_info[\"existing_user_can_redeem\"]).to eq(true)\n        end\n      end\n    end\n\n    it \"fails if invite does not exist\" do\n      get \"/invites/missing\"\n      expect(response.status).to eq(200)\n      expect(response.body).to_not have_tag(:script, with: { src: \"/assets/application.js\" })\n      expect(response.body).to include(I18n.t(\"invite.not_found\", base_url: Discourse.base_url))\n    end\n\n    it \"fails if invite expired\" do\n      invite.update(expires_at: 1.day.ago)\n\n      get \"/invites/#{invite.invite_key}\"\n      expect(response.status).to eq(200)\n      expect(response.body).to_not have_tag(:script, with: { src: \"/assets/application.js\" })\n      expect(response.body).to include(I18n.t(\"invite.expired\", base_url: Discourse.base_url))\n    end\n\n    it \"stores the invite key in the secure session if invite exists\" do\n      get \"/invites/#{invite.invite_key}\"\n      expect(response.status).to eq(200)\n      invite_key = read_secure_session[\"invite-key\"]\n      expect(invite_key).to eq(invite.invite_key)\n    end\n\n    it \"returns error if invite has already been redeemed\" do\n      expect(invite.redeem).not_to eq(nil)\n\n      get \"/invites/#{invite.invite_key}\"\n      expect(response.status).to eq(200)\n      expect(response.body).to_not have_tag(:script, with: { src: \"/assets/application.js\" })\n      expect(response.body).to include(\n        I18n.t(\n          \"invite.not_found_template\",\n          site_name: SiteSetting.title,\n          base_url: Discourse.base_url,\n        ),\n      )\n\n      invite.update!(email: nil) # convert to email invite\n\n      get \"/invites/#{invite.invite_key}\"\n      expect(response.status).to eq(200)\n      expect(response.body).to_not have_tag(:script, with: { src: \"/assets/application.js\" })\n      expect(response.body).to include(\n        I18n.t(\n          \"invite.not_found_template_link\",\n          site_name: SiteSetting.title,\n          base_url: Discourse.base_url,\n        ),\n      )\n    end\n  end\n\n  describe \"#create\" do\n    it \"requires to be logged in\" do\n      post \"/invites.json\", params: { email: \"test@example.com\" }\n      expect(response.status).to eq(403)\n    end\n\n    context \"while logged in\" do\n      before { sign_in(user) }\n\n      it \"fails if you cannot invite to the forum\" do\n        sign_in(Fabricate(:user))\n\n        post \"/invites.json\", params: { email: \"test@example.com\" }\n        expect(response).to be_forbidden\n      end\n    end\n\n    context \"with invite to topic\" do\n      fab!(:topic) { Fabricate(:topic) }\n\n      it \"works\" do\n        sign_in(user)\n\n        post \"/invites.json\",\n             params: {\n               email: \"test@example.com\",\n               topic_id: topic.id,\n               invite_to_topic: true,\n             }\n        expect(response.status).to eq(200)\n        expect(Jobs::InviteEmail.jobs.first[\"args\"].first[\"invite_to_topic\"]).to be_truthy\n      end\n\n      it \"fails when topic_id is invalid\" do\n        sign_in(user)\n\n        post \"/invites.json\", params: { email: \"test@example.com\", topic_id: -9999 }\n        expect(response.status).to eq(400)\n      end\n\n      context \"when topic is private\" do\n        fab!(:group) { Fabricate(:group) }\n\n        fab!(:secured_category) do |category|\n          category = Fabricate(:category)\n          category.permissions = { group.name => :full }\n          category.save!\n          category\n        end\n\n        fab!(:topic) { Fabricate(:topic, category: secured_category) }\n\n        it \"does not work and returns a list of required groups\" do\n          sign_in(admin)\n\n          post \"/invites.json\", params: { email: \"test@example.com\", topic_id: topic.id }\n          expect(response.status).to eq(422)\n          expect(response.parsed_body[\"errors\"]).to contain_exactly(\n            I18n.t(\"invite.requires_groups\", groups: group.name),\n          )\n        end\n\n        it \"does not work if user cannot edit groups\" do\n          group.add(user)\n          sign_in(user)\n\n          post \"/invites.json\", params: { email: \"test@example.com\", topic_id: topic.id }\n          expect(response.status).to eq(403)\n        end\n      end\n    end\n\n    context \"with invite to group\" do\n      fab!(:group) { Fabricate(:group) }\n\n      it \"works for admins\" do\n        sign_in(admin)\n\n        post \"/invites.json\", params: { email: \"test@example.com\", group_ids: [group.id] }\n        expect(response.status).to eq(200)\n        expect(Invite.find_by(email: \"test@example.com\").invited_groups.count).to eq(1)\n      end\n\n      it \"works for group owners\" do\n        sign_in(user)\n        group.add_owner(user)\n\n        post \"/invites.json\", params: { email: \"test@example.com\", group_ids: [group.id] }\n        expect(response.status).to eq(200)\n        expect(Invite.find_by(email: \"test@example.com\").invited_groups.count).to eq(1)\n      end\n\n      it \"works with multiple groups\" do\n        sign_in(admin)\n        group2 = Fabricate(:group)\n\n        post \"/invites.json\",\n             params: {\n               email: \"test@example.com\",\n               group_names: \"#{group.name},#{group2.name}\",\n             }\n        expect(response.status).to eq(200)\n        expect(Invite.find_by(email: \"test@example.com\").invited_groups.count).to eq(2)\n      end\n\n      it \"fails for group members\" do\n        sign_in(user)\n        group.add(user)\n\n        post \"/invites.json\", params: { email: \"test@example.com\", group_ids: [group.id] }\n        expect(response.status).to eq(403)\n      end\n\n      it \"fails for other users\" do\n        sign_in(user)\n\n        post \"/invites.json\", params: { email: \"test@example.com\", group_ids: [group.id] }\n        expect(response.status).to eq(403)\n      end\n\n      it \"fails to invite new user to a group-private topic\" do\n        sign_in(user)\n        private_category = Fabricate(:private_category, group: group)\n        group_private_topic = Fabricate(:topic, category: private_category)\n\n        post \"/invites.json\",\n             params: {\n               email: \"test@example.com\",\n               topic_id: group_private_topic.id,\n             }\n        expect(response.status).to eq(403)\n      end\n    end\n\n    context \"with email invite\" do\n      subject(:create_invite) { post \"/invites.json\", params: params }\n\n      let(:params) { { email: email } }\n      let(:email) { \"test@example.com\" }\n\n      before { sign_in(user) }\n\n      context \"when doing successive calls\" do\n        let(:invite) { Invite.last }\n\n        it \"creates invite once and updates it after\" do\n          create_invite\n          expect(response).to have_http_status :ok\n          expect(Jobs::InviteEmail.jobs.size).to eq(1)\n\n          create_invite\n          expect(response).to have_http_status :ok\n          expect(response.parsed_body[\"id\"]).to eq(invite.id)\n        end\n      end\n\n      context 'when \"skip_email\" parameter is provided' do\n        before { params[:skip_email] = true }\n\n        it \"accepts the parameter\" do\n          create_invite\n          expect(response).to have_http_status :ok\n          expect(Jobs::InviteEmail.jobs.size).to eq(0)\n        end\n      end\n\n      context \"when validations fail\" do\n        let(:email) { \"test@mailinator.com\" }\n\n        it \"fails\" do\n          create_invite\n          expect(response).to have_http_status :unprocessable_entity\n          expect(response.parsed_body[\"errors\"]).to be_present\n        end\n      end\n\n      context \"when providing an email belonging to an existing user\" do\n        let(:email) { user.email }\n\n        before { SiteSetting.hide_email_address_taken = hide_email_address_taken }\n\n        context 'when \"hide_email_address_taken\" setting is disabled' do\n          let(:hide_email_address_taken) { false }\n\n          it \"returns an error\" do\n            create_invite\n            expect(response).to have_http_status :unprocessable_entity\n            expect(body).to match(/no need to invite/)\n          end\n        end\n\n        context 'when \"hide_email_address_taken\" setting is enabled' do\n          let(:hide_email_address_taken) { true }\n\n          it \"doesn\u2019t inform the user\" do\n            create_invite\n            expect(response).to have_http_status :unprocessable_entity\n            expect(body).to match(/There was a problem with your request./)\n          end\n        end\n      end\n    end\n\n    context \"with link invite\" do\n      it \"works\" do\n        sign_in(admin)\n\n        post \"/invites.json\"\n        expect(response.status).to eq(200)\n        expect(Invite.last.email).to eq(nil)\n        expect(Invite.last.invited_by).to eq(admin)\n        expect(Invite.last.max_redemptions_allowed).to eq(1)\n      end\n\n      it \"fails if over invite_link_max_redemptions_limit\" do\n        sign_in(admin)\n\n        post \"/invites.json\",\n             params: {\n               max_redemptions_allowed: SiteSetting.invite_link_max_redemptions_limit - 1,\n             }\n        expect(response.status).to eq(200)\n\n        post \"/invites.json\",\n             params: {\n               max_redemptions_allowed: SiteSetting.invite_link_max_redemptions_limit + 1,\n             }\n        expect(response.status).to eq(422)\n      end\n\n      it \"fails if over invite_link_max_redemptions_limit_users\" do\n        sign_in(user)\n\n        post \"/invites.json\",\n             params: {\n               max_redemptions_allowed: SiteSetting.invite_link_max_redemptions_limit_users - 1,\n             }\n        expect(response.status).to eq(200)\n\n        post \"/invites.json\",\n             params: {\n               max_redemptions_allowed: SiteSetting.invite_link_max_redemptions_limit_users + 1,\n             }\n        expect(response.status).to eq(422)\n      end\n    end\n  end\n\n  describe \"#retrieve\" do\n    it \"requires to be logged in\" do\n      get \"/invites/retrieve.json\", params: { email: \"test@example.com\" }\n      expect(response.status).to eq(403)\n    end\n\n    context \"while logged in\" do\n      before { sign_in(user) }\n\n      fab!(:invite) { Fabricate(:invite, invited_by: user, email: \"test@example.com\") }\n\n      it \"raises an error when the email is missing\" do\n        get \"/invites/retrieve.json\"\n        expect(response.status).to eq(400)\n      end\n\n      it \"raises an error when the email cannot be found\" do\n        get \"/invites/retrieve.json\", params: { email: \"test2@example.com\" }\n        expect(response.status).to eq(400)\n      end\n\n      it \"can retrieve the invite\" do\n        get \"/invites/retrieve.json\", params: { email: \"test@example.com\" }\n        expect(response.status).to eq(200)\n      end\n    end\n  end\n\n  describe \"#update\" do\n    fab!(:invite) { Fabricate(:invite, invited_by: admin, email: \"test@example.com\") }\n\n    it \"requires to be logged in\" do\n      put \"/invites/#{invite.id}\", params: { email: \"test2@example.com\" }\n      expect(response.status).to eq(400)\n    end\n\n    context \"while logged in\" do\n      before { sign_in(admin) }\n\n      it \"resends invite email if updating email address\" do\n        put \"/invites/#{invite.id}\", params: { email: \"test2@example.com\" }\n        expect(response.status).to eq(200)\n        expect(Jobs::InviteEmail.jobs.size).to eq(1)\n      end\n\n      it \"does not resend invite email if skip_email if updating email address\" do\n        put \"/invites/#{invite.id}\", params: { email: \"test2@example.com\", skip_email: true }\n        expect(response.status).to eq(200)\n        expect(Jobs::InviteEmail.jobs.size).to eq(0)\n      end\n\n      it \"does not resend invite email when updating other fields\" do\n        put \"/invites/#{invite.id}\", params: { custom_message: \"new message\" }\n        expect(response.status).to eq(200)\n        expect(invite.reload.custom_message).to eq(\"new message\")\n        expect(Jobs::InviteEmail.jobs.size).to eq(0)\n      end\n\n      it \"cannot create duplicated invites\" do\n        Fabricate(:invite, invited_by: admin, email: \"test2@example.com\")\n\n        put \"/invites/#{invite.id}.json\", params: { email: \"test2@example.com\" }\n        expect(response.status).to eq(409)\n      end\n\n      describe \"rate limiting\" do\n        before { RateLimiter.enable }\n\n        use_redis_snapshotting\n\n        it \"can send invite email\" do\n          sign_in(user)\n\n          invite = Fabricate(:invite, invited_by: user, email: \"test@example.com\")\n\n          expect { put \"/invites/#{invite.id}\", params: { send_email: true } }.to change {\n            RateLimiter.new(user, \"resend-invite-per-hour\", 10, 1.hour).remaining\n          }.by(-1)\n          expect(response.status).to eq(200)\n          expect(Jobs::InviteEmail.jobs.size).to eq(1)\n        end\n      end\n\n      context \"when providing an email belonging to an existing user\" do\n        subject(:update_invite) { put \"/invites/#{invite.id}.json\", params: { email: admin.email } }\n\n        before { SiteSetting.hide_email_address_taken = hide_email_address_taken }\n\n        context \"when 'hide_email_address_taken' setting is disabled\" do\n          let(:hide_email_address_taken) { false }\n\n          it \"returns an error\" do\n            update_invite\n            expect(response).to have_http_status :unprocessable_entity\n            expect(body).to match(/no need to invite/)\n          end\n        end\n\n        context \"when 'hide_email_address_taken' setting is enabled\" do\n          let(:hide_email_address_taken) { true }\n\n          it \"doesn't inform the user\" do\n            update_invite\n            expect(response).to have_http_status :unprocessable_entity\n            expect(body).to match(/There was a problem with your request./)\n          end\n        end\n      end\n    end\n  end\n\n  describe \"#destroy\" do\n    it \"requires to be logged in\" do\n      delete \"/invites.json\", params: { email: \"test@example.com\" }\n      expect(response.status).to eq(403)\n    end\n\n    context \"while logged in\" do\n      fab!(:invite) { Fabricate(:invite, invited_by: user) }\n\n      before { sign_in(user) }\n\n      it \"raises an error when id is missing\" do\n        delete \"/invites.json\"\n        expect(response.status).to eq(400)\n      end\n\n      it \"raises an error when invite does not exist\" do\n        delete \"/invites.json\", params: { id: 848 }\n        expect(response.status).to eq(400)\n      end\n\n      it \"raises an error when invite is not created by user\" do\n        another_invite = Fabricate(:invite, email: \"test2@example.com\")\n\n        delete \"/invites.json\", params: { id: another_invite.id }\n        expect(response.status).to eq(400)\n      end\n\n      it \"destroys the invite\" do\n        delete \"/invites.json\", params: { id: invite.id }\n        expect(response.status).to eq(200)\n        expect(invite.reload.trashed?).to be_truthy\n      end\n    end\n  end\n\n  describe \"#perform_accept_invitation\" do\n    context \"with an invalid invite\" do\n      it \"redirects to the root\" do\n        put \"/invites/show/doesntexist.json\"\n        expect(response.status).to eq(404)\n        expect(response.parsed_body[\"message\"]).to eq(I18n.t(\"invite.not_found_json\"))\n        expect(session[:current_user_id]).to be_blank\n      end\n    end\n\n    context \"with a deleted invite\" do\n      fab!(:invite) { Fabricate(:invite) }\n\n      before { invite.trash! }\n\n      it \"redirects to the root\" do\n        put \"/invites/show/#{invite.invite_key}.json\"\n        expect(response.status).to eq(404)\n        expect(response.parsed_body[\"message\"]).to eq(I18n.t(\"invite.not_found_json\"))\n        expect(session[:current_user_id]).to be_blank\n      end\n    end\n\n    context \"with an expired invite\" do\n      fab!(:invite) { Fabricate(:invite, expires_at: 1.day.ago) }\n\n      it \"response is not successful\" do\n        put \"/invites/show/#{invite.invite_key}.json\"\n        expect(response.status).to eq(404)\n        expect(response.parsed_body[\"message\"]).to eq(I18n.t(\"invite.not_found_json\"))\n        expect(session[:current_user_id]).to be_blank\n      end\n    end\n\n    context \"with an email invite\" do\n      let(:topic) { Fabricate(:topic) }\n      let(:invite) { Invite.generate(topic.user, email: \"iceking@adventuretime.ooo\", topic: topic) }\n\n      it \"redeems the invite\" do\n        put \"/invites/show/#{invite.invite_key}.json\"\n        expect(invite.reload.redeemed?).to be_truthy\n      end\n\n      it \"logs in the user\" do\n        events =\n          DiscourseEvent.track_events do\n            put \"/invites/show/#{invite.invite_key}.json\",\n                params: {\n                  email_token: invite.email_token,\n                }\n          end\n\n        expect(events.map { |event| event[:event_name] }).to include(\n          :user_logged_in,\n          :user_first_logged_in,\n        )\n        expect(response.status).to eq(200)\n        expect(session[:current_user_id]).to eq(invite.invited_users.first.user_id)\n        expect(invite.reload.redeemed?).to be_truthy\n        user = User.find(invite.invited_users.first.user_id)\n        expect(user.ip_address).to be_present\n        expect(user.registration_ip_address).to be_present\n      end\n\n      it \"redirects to the first topic the user was invited to\" do\n        put \"/invites/show/#{invite.invite_key}.json\", params: { email_token: invite.email_token }\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"redirect_to\"]).to eq(topic.relative_url)\n        expect(\n          Notification.where(\n            notification_type: Notification.types[:invited_to_topic],\n            topic: topic,\n          ).count,\n        ).to eq(1)\n      end\n\n      it \"sets the timezone of the user in user_options\" do\n        put \"/invites/show/#{invite.invite_key}.json\", params: { timezone: \"Australia/Melbourne\" }\n        expect(response.status).to eq(200)\n        invite.reload\n        user = User.find(invite.invited_users.first.user_id)\n        expect(user.user_option.timezone).to eq(\"Australia/Melbourne\")\n      end\n\n      it \"does not log in the user if there are validation errors\" do\n        put \"/invites/show/#{invite.invite_key}.json\", params: { password: \"password\" }\n\n        expect(response.status).to eq(412)\n        expect(session[:current_user_id]).to eq(nil)\n      end\n\n      it \"does not log in the user if they were not approved\" do\n        SiteSetting.must_approve_users = true\n\n        put \"/invites/show/#{invite.invite_key}.json\",\n            params: {\n              password: SecureRandom.hex,\n              email_token: invite.email_token,\n            }\n\n        expect(session[:current_user_id]).to eq(nil)\n        expect(response.parsed_body[\"message\"]).to eq(I18n.t(\"activation.approval_required\"))\n      end\n\n      it \"does not log in the user if they were not activated\" do\n        put \"/invites/show/#{invite.invite_key}.json\", params: { password: SecureRandom.hex }\n\n        expect(session[:current_user_id]).to eq(nil)\n        expect(response.parsed_body[\"message\"]).to eq(I18n.t(\"invite.confirm_email\"))\n      end\n\n      it \"fails when local login is disabled and no external auth is configured\" do\n        SiteSetting.enable_local_logins = false\n\n        put \"/invites/show/#{invite.invite_key}.json\"\n        expect(response.status).to eq(404)\n      end\n\n      context \"with OmniAuth provider\" do\n        fab!(:authenticated_email) { \"test@example.com\" }\n\n        before do\n          OmniAuth.config.test_mode = true\n\n          OmniAuth.config.mock_auth[:google_oauth2] = OmniAuth::AuthHash.new(\n            provider: \"google_oauth2\",\n            uid: \"12345\",\n            info: OmniAuth::AuthHash::InfoHash.new(email: authenticated_email, name: \"First Last\"),\n            extra: {\n              raw_info:\n                OmniAuth::AuthHash.new(\n                  email_verified: true,\n                  email: authenticated_email,\n                  family_name: \"Last\",\n                  given_name: \"First\",\n                  gender: \"male\",\n                  name: \"First Last\",\n                ),\n            },\n          )\n\n          Rails.application.env_config[\"omniauth.auth\"] = OmniAuth.config.mock_auth[:google_oauth2]\n          SiteSetting.enable_google_oauth2_logins = true\n\n          get \"/auth/google_oauth2/callback.json\"\n          expect(response.status).to eq(302)\n        end\n\n        after do\n          Rails.application.env_config[\"omniauth.auth\"] = OmniAuth.config.mock_auth[\n            :google_oauth2\n          ] = nil\n          OmniAuth.config.test_mode = false\n        end\n\n        it \"should associate the invited user with authenticator records\" do\n          SiteSetting.auth_overrides_name = true\n          invite.update!(email: authenticated_email)\n\n          expect {\n            put \"/invites/show/#{invite.invite_key}.json\", params: { name: \"somename\" }\n          }.to change { User.with_email(authenticated_email).exists? }.to(true)\n          expect(response.status).to eq(200)\n\n          user = User.find_by_email(authenticated_email)\n          expect(user.name).to eq(\"First Last\")\n          expect(user.user_associated_accounts.first.provider_name).to eq(\"google_oauth2\")\n        end\n\n        it \"returns the right response even if local logins has been disabled\" do\n          SiteSetting.enable_local_logins = false\n          invite.update!(email: authenticated_email)\n\n          put \"/invites/show/#{invite.invite_key}.json\"\n          expect(response.status).to eq(200)\n        end\n\n        it \"returns the right response if authenticated email does not match invite email\" do\n          put \"/invites/show/#{invite.invite_key}.json\"\n          expect(response.status).to eq(412)\n        end\n      end\n\n      describe \".post_process_invite\" do\n        it \"sends a welcome message if set\" do\n          SiteSetting.send_welcome_message = true\n          user.send_welcome_message = true\n          put \"/invites/show/#{invite.invite_key}.json\"\n          expect(response.status).to eq(200)\n\n          expect(Jobs::SendSystemMessage.jobs.size).to eq(1)\n        end\n\n        it \"refreshes automatic groups if staff\" do\n          topic.user.grant_admin!\n          invite.update!(moderator: true)\n\n          put \"/invites/show/#{invite.invite_key}.json\"\n          expect(response.status).to eq(200)\n\n          expect(invite.invited_users.first.user.groups.pluck(:name)).to contain_exactly(\n            \"moderators\",\n            \"staff\",\n          )\n        end\n\n        context \"without password\" do\n          it \"sends password reset email\" do\n            put \"/invites/show/#{invite.invite_key}.json\"\n            expect(response.status).to eq(200)\n\n            expect(Jobs::InvitePasswordInstructionsEmail.jobs.size).to eq(1)\n            expect(Jobs::CriticalUserEmail.jobs.size).to eq(0)\n          end\n        end\n\n        context \"with password\" do\n          context \"when user was invited via email\" do\n            before { invite.update_column(:emailed_status, Invite.emailed_status_types[:pending]) }\n\n            it \"does not send an activation email and activates the user\" do\n              expect do\n                put \"/invites/show/#{invite.invite_key}.json\",\n                    params: {\n                      password: \"verystrongpassword\",\n                      email_token: invite.email_token,\n                    }\n              end.to change { UserAuthToken.count }.by(1)\n\n              expect(response.status).to eq(200)\n\n              expect(Jobs::InvitePasswordInstructionsEmail.jobs.size).to eq(0)\n              expect(Jobs::CriticalUserEmail.jobs.size).to eq(0)\n\n              invited_user = User.find_by_email(invite.email)\n              expect(invited_user.active).to eq(true)\n              expect(invited_user.email_confirmed?).to eq(true)\n            end\n\n            it \"does not activate user if email token is missing\" do\n              expect do\n                put \"/invites/show/#{invite.invite_key}.json\",\n                    params: {\n                      password: \"verystrongpassword\",\n                    }\n              end.not_to change { UserAuthToken.count }\n\n              expect(response.status).to eq(200)\n\n              expect(Jobs::InvitePasswordInstructionsEmail.jobs.size).to eq(0)\n              expect(Jobs::CriticalUserEmail.jobs.size).to eq(1)\n\n              invited_user = User.find_by_email(invite.email)\n              expect(invited_user.active).to eq(false)\n              expect(invited_user.email_confirmed?).to eq(false)\n            end\n          end\n\n          context \"when user was invited via link\" do\n            before do\n              invite.update_column(:emailed_status, Invite.emailed_status_types[:not_required])\n            end\n\n            it \"sends an activation email and does not activate the user\" do\n              expect do\n                put \"/invites/show/#{invite.invite_key}.json\",\n                    params: {\n                      password: \"verystrongpassword\",\n                    }\n              end.not_to change { UserAuthToken.count }\n\n              expect(response.status).to eq(200)\n              expect(response.parsed_body[\"message\"]).to eq(I18n.t(\"invite.confirm_email\"))\n\n              invited_user = User.find_by_email(invite.email)\n              expect(invited_user.active).to eq(false)\n              expect(invited_user.email_confirmed?).to eq(false)\n\n              expect(Jobs::InvitePasswordInstructionsEmail.jobs.size).to eq(0)\n              expect(Jobs::CriticalUserEmail.jobs.size).to eq(1)\n\n              tokens = EmailToken.where(user_id: invited_user.id, confirmed: false, expired: false)\n              expect(tokens.size).to eq(1)\n\n              job_args = Jobs::CriticalUserEmail.jobs.first[\"args\"].first\n              expect(job_args[\"type\"]).to eq(\"signup\")\n              expect(job_args[\"user_id\"]).to eq(invited_user.id)\n              expect(EmailToken.hash_token(job_args[\"email_token\"])).to eq(tokens.first.token_hash)\n            end\n          end\n        end\n      end\n    end\n\n    context \"with a domain invite\" do\n      fab!(:invite) do\n        Fabricate(\n          :invite,\n          email: nil,\n          emailed_status: Invite.emailed_status_types[:not_required],\n          domain: \"example.com\",\n        )\n      end\n\n      it \"creates an user if email matches domain\" do\n        expect {\n          put \"/invites/show/#{invite.invite_key}.json\",\n              params: {\n                email: \"test@example.com\",\n                password: \"verystrongpassword\",\n              }\n        }.to change { User.count }\n\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"message\"]).to eq(I18n.t(\"invite.confirm_email\"))\n        expect(invite.reload.redemption_count).to eq(1)\n\n        invited_user = User.find_by_email(\"test@example.com\")\n        expect(invited_user).to be_present\n      end\n\n      it \"does not create an user if email does not match domain\" do\n        expect {\n          put \"/invites/show/#{invite.invite_key}.json\",\n              params: {\n                email: \"test@example2.com\",\n                password: \"verystrongpassword\",\n              }\n        }.not_to change { User.count }\n\n        expect(response.status).to eq(412)\n        expect(response.parsed_body[\"message\"]).to eq(I18n.t(\"invite.domain_not_allowed\"))\n        expect(invite.reload.redemption_count).to eq(0)\n      end\n    end\n\n    context \"with an invite link\" do\n      fab!(:invite) do\n        Fabricate(:invite, email: nil, emailed_status: Invite.emailed_status_types[:not_required])\n      end\n\n      it \"does not create multiple users for a single use invite\" do\n        user_count = User.count\n\n        2\n          .times\n          .map do\n            Thread.new do\n              put \"/invites/show/#{invite.invite_key}.json\",\n                  params: {\n                    email: \"test@example.com\",\n                    password: \"verystrongpassword\",\n                  }\n            end\n          end\n          .each(&:join)\n\n        expect(invite.reload.max_redemptions_allowed).to eq(1)\n        expect(invite.reload.redemption_count).to eq(1)\n        expect(User.count).to eq(user_count + 1)\n      end\n\n      it \"sends an activation email and does not activate the user\" do\n        expect {\n          put \"/invites/show/#{invite.invite_key}.json\",\n              params: {\n                email: \"test@example.com\",\n                password: \"verystrongpassword\",\n              }\n        }.not_to change { UserAuthToken.count }\n\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"message\"]).to eq(I18n.t(\"invite.confirm_email\"))\n        expect(invite.reload.redemption_count).to eq(1)\n\n        invited_user = User.find_by_email(\"test@example.com\")\n        expect(invited_user.active).to eq(false)\n        expect(invited_user.email_confirmed?).to eq(false)\n\n        expect(Jobs::InvitePasswordInstructionsEmail.jobs.size).to eq(0)\n        expect(Jobs::CriticalUserEmail.jobs.size).to eq(1)\n\n        tokens = EmailToken.where(user_id: invited_user.id, confirmed: false, expired: false)\n        expect(tokens.size).to eq(1)\n\n        job_args = Jobs::CriticalUserEmail.jobs.first[\"args\"].first\n        expect(job_args[\"type\"]).to eq(\"signup\")\n        expect(job_args[\"user_id\"]).to eq(invited_user.id)\n        expect(EmailToken.hash_token(job_args[\"email_token\"])).to eq(tokens.first.token_hash)\n      end\n\n      it \"does not automatically log in the user if their email matches an existing user's and shows an error\" do\n        Fabricate(:user, email: \"test@example.com\")\n        put \"/invites/show/#{invite.invite_key}.json\",\n            params: {\n              email: \"test@example.com\",\n              password: \"verystrongpassword\",\n            }\n        expect(session[:current_user_id]).to be_blank\n        expect(response.status).to eq(412)\n        expect(response.parsed_body[\"message\"]).to include(\"Primary email has already been taken\")\n        expect(invite.reload.redemption_count).to eq(0)\n      end\n\n      it \"does not automatically log in the user if their email matches an existing admin's and shows an error\" do\n        Fabricate(:admin, email: \"test@example.com\")\n        put \"/invites/show/#{invite.invite_key}.json\",\n            params: {\n              email: \"test@example.com\",\n              password: \"verystrongpassword\",\n            }\n        expect(session[:current_user_id]).to be_blank\n        expect(response.status).to eq(412)\n        expect(response.parsed_body[\"message\"]).to include(\"Primary email has already been taken\")\n        expect(invite.reload.redemption_count).to eq(0)\n      end\n    end\n\n    context \"when new registrations are disabled\" do\n      fab!(:topic) { Fabricate(:topic) }\n      fab!(:invite) { Invite.generate(topic.user, email: \"test@example.com\", topic: topic) }\n\n      before { SiteSetting.allow_new_registrations = false }\n\n      it \"does not redeem the invite\" do\n        put \"/invites/show/#{invite.invite_key}.json\"\n        expect(response.status).to eq(200)\n        expect(invite.reload.invited_users).to be_blank\n        expect(invite.redeemed?).to be_falsey\n        expect(response.body).to include(I18n.t(\"login.new_registrations_disabled\"))\n      end\n    end\n\n    context \"when user is already logged in\" do\n      before { sign_in(user) }\n\n      context \"for an email invite\" do\n        fab!(:invite) { Fabricate(:invite, email: \"test@example.com\") }\n        fab!(:user) { Fabricate(:user, email: \"test@example.com\") }\n        fab!(:group) { Fabricate(:group) }\n\n        it \"redeems the invitation and creates the invite accepted notification\" do\n          put \"/invites/show/#{invite.invite_key}.json\", params: { id: invite.invite_key }\n          expect(response.status).to eq(200)\n          expect(response.parsed_body[\"message\"]).to eq(I18n.t(\"invite.existing_user_success\"))\n          invite.reload\n          expect(invite.invited_users.first.user).to eq(user)\n          expect(invite.redeemed?).to be_truthy\n          expect(\n            Notification.exists?(\n              user: invite.invited_by,\n              notification_type: Notification.types[:invitee_accepted],\n            ),\n          ).to eq(true)\n        end\n\n        it \"redirects to the first topic the user was invited to and creates the topic notification\" do\n          topic = Fabricate(:topic)\n          TopicInvite.create!(invite: invite, topic: topic)\n          put \"/invites/show/#{invite.invite_key}.json\", params: { id: invite.invite_key }\n          expect(response.status).to eq(200)\n          expect(response.parsed_body[\"redirect_to\"]).to eq(topic.relative_url)\n          expect(\n            Notification.where(\n              notification_type: Notification.types[:invited_to_topic],\n              topic: topic,\n            ).count,\n          ).to eq(1)\n        end\n\n        it \"adds the user to the private topic\" do\n          topic = Fabricate(:private_message_topic)\n          TopicInvite.create!(invite: invite, topic: topic)\n          put \"/invites/show/#{invite.invite_key}.json\", params: { id: invite.invite_key }\n          expect(response.status).to eq(200)\n          expect(response.parsed_body[\"redirect_to\"]).to eq(topic.relative_url)\n          expect(TopicAllowedUser.exists?(user: user, topic: topic)).to eq(true)\n        end\n\n        it \"adds the user to the groups specified on the invite and allows them to access the secure topic\" do\n          group.add_owner(invite.invited_by)\n          secured_category = Fabricate(:category)\n          secured_category.permissions = { group.name => :full }\n          secured_category.save!\n\n          topic = Fabricate(:topic, category: secured_category)\n          TopicInvite.create!(invite: invite, topic: topic)\n          InvitedGroup.create!(invite: invite, group: group)\n\n          put \"/invites/show/#{invite.invite_key}.json\", params: { id: invite.invite_key }\n          expect(response.status).to eq(200)\n          expect(response.parsed_body[\"message\"]).to eq(I18n.t(\"invite.existing_user_success\"))\n          expect(response.parsed_body[\"redirect_to\"]).to eq(topic.relative_url)\n          invite.reload\n          expect(invite.redeemed?).to be_truthy\n          expect(user.reload.groups).to include(group)\n          expect(\n            Notification.where(\n              notification_type: Notification.types[:invited_to_topic],\n              topic: topic,\n            ).count,\n          ).to eq(1)\n        end\n\n        it \"does not try to log in the user automatically\" do\n          expect do\n            put \"/invites/show/#{invite.invite_key}.json\", params: { id: invite.invite_key }\n          end.not_to change { UserAuthToken.count }\n          expect(response.status).to eq(200)\n          expect(response.parsed_body[\"message\"]).to eq(I18n.t(\"invite.existing_user_success\"))\n        end\n\n        it \"errors if the user's email doesn't match the invite email\" do\n          user.update!(email: \"blah@test.com\")\n          put \"/invites/show/#{invite.invite_key}.json\", params: { id: invite.invite_key }\n          expect(response.status).to eq(412)\n          expect(response.parsed_body[\"message\"]).to eq(I18n.t(\"invite.not_matching_email\"))\n        end\n\n        it \"errors if the user's email domain doesn't match the invite domain\" do\n          user.update!(email: \"blah@test.com\")\n          invite.update!(email: nil, domain: \"example.com\")\n          put \"/invites/show/#{invite.invite_key}.json\", params: { id: invite.invite_key }\n          expect(response.status).to eq(412)\n          expect(response.parsed_body[\"message\"]).to eq(I18n.t(\"invite.domain_not_allowed\"))\n        end\n      end\n\n      context \"for an invite link\" do\n        fab!(:invite) { Fabricate(:invite, email: nil) }\n        fab!(:user) { Fabricate(:user, email: \"test@example.com\") }\n        fab!(:group) { Fabricate(:group) }\n\n        it \"redeems the invitation and creates the invite accepted notification\" do\n          put \"/invites/show/#{invite.invite_key}.json\", params: { id: invite.invite_key }\n          expect(response.status).to eq(200)\n          expect(response.parsed_body[\"message\"]).to eq(I18n.t(\"invite.existing_user_success\"))\n          invite.reload\n          expect(invite.invited_users.first.user).to eq(user)\n          expect(invite.redeemed?).to be_truthy\n          expect(\n            Notification.exists?(\n              user: invite.invited_by,\n              notification_type: Notification.types[:invitee_accepted],\n            ),\n          ).to eq(true)\n        end\n\n        it \"redirects to the first topic the user was invited to and creates the topic notification\" do\n          topic = Fabricate(:topic)\n          TopicInvite.create!(invite: invite, topic: topic)\n          put \"/invites/show/#{invite.invite_key}.json\", params: { id: invite.invite_key }\n          expect(response.status).to eq(200)\n          expect(response.parsed_body[\"redirect_to\"]).to eq(topic.relative_url)\n          expect(\n            Notification.where(\n              notification_type: Notification.types[:invited_to_topic],\n              topic: topic,\n            ).count,\n          ).to eq(1)\n        end\n\n        it \"adds the user to the groups specified on the invite and allows them to access the secure topic\" do\n          group.add_owner(invite.invited_by)\n          secured_category = Fabricate(:category)\n          secured_category.permissions = { group.name => :full }\n          secured_category.save!\n\n          topic = Fabricate(:topic, category: secured_category)\n          TopicInvite.create!(invite: invite, topic: topic)\n          InvitedGroup.create!(invite: invite, group: group)\n\n          put \"/invites/show/#{invite.invite_key}.json\", params: { id: invite.invite_key }\n          expect(response.status).to eq(200)\n          expect(response.parsed_body[\"message\"]).to eq(I18n.t(\"invite.existing_user_success\"))\n          expect(response.parsed_body[\"redirect_to\"]).to eq(topic.relative_url)\n          invite.reload\n          expect(invite.redeemed?).to be_truthy\n          expect(user.reload.groups).to include(group)\n          expect(\n            Notification.where(\n              notification_type: Notification.types[:invited_to_topic],\n              topic: topic,\n            ).count,\n          ).to eq(1)\n        end\n\n        it \"does not try to log in the user automatically\" do\n          expect do\n            put \"/invites/show/#{invite.invite_key}.json\", params: { id: invite.invite_key }\n          end.not_to change { UserAuthToken.count }\n          expect(response.status).to eq(200)\n          expect(response.parsed_body[\"message\"]).to eq(I18n.t(\"invite.existing_user_success\"))\n        end\n      end\n    end\n\n    context \"with topic invites\" do\n      fab!(:invite) { Fabricate(:invite, email: \"test@example.com\") }\n\n      fab!(:secured_category) do\n        secured_category = Fabricate(:category)\n        secured_category.permissions = { staff: :full }\n        secured_category.save!\n        secured_category\n      end\n\n      it \"redirects user to topic if activated\" do\n        topic = Fabricate(:topic)\n        TopicInvite.create!(invite: invite, topic: topic)\n\n        put \"/invites/show/#{invite.invite_key}.json\", params: { email_token: invite.email_token }\n        expect(response.parsed_body[\"redirect_to\"]).to eq(topic.relative_url)\n        expect(\n          Notification.where(\n            notification_type: Notification.types[:invited_to_topic],\n            topic: topic,\n          ).count,\n        ).to eq(1)\n      end\n\n      it \"sets destination_url cookie if user is not activated\" do\n        topic = Fabricate(:topic)\n        TopicInvite.create!(invite: invite, topic: topic)\n\n        put \"/invites/show/#{invite.invite_key}.json\"\n        expect(cookies[\"destination_url\"]).to eq(topic.relative_url)\n        expect(\n          Notification.where(\n            notification_type: Notification.types[:invited_to_topic],\n            topic: topic,\n          ).count,\n        ).to eq(1)\n      end\n\n      it \"does not redirect user if they cannot see topic\" do\n        topic = Fabricate(:topic, category: secured_category)\n        TopicInvite.create!(invite: invite, topic: topic)\n\n        put \"/invites/show/#{invite.invite_key}.json\", params: { email_token: invite.email_token }\n        expect(response.parsed_body[\"redirect_to\"]).to eq(\"/\")\n        expect(\n          Notification.where(\n            notification_type: Notification.types[:invited_to_topic],\n            topic: topic,\n          ).count,\n        ).to eq(0)\n      end\n    end\n\n    context \"with staged user\" do\n      fab!(:invite) { Fabricate(:invite) }\n      fab!(:staged_user) { Fabricate(:user, staged: true, email: invite.email) }\n\n      it \"can keep the old username\" do\n        old_username = staged_user.username\n\n        put \"/invites/show/#{invite.invite_key}.json\",\n            params: {\n              username: staged_user.username,\n              password: \"Password123456\",\n              email_token: invite.email_token,\n            }\n\n        expect(response.status).to eq(200)\n        expect(invite.reload.redeemed?).to be_truthy\n        user = invite.invited_users.first.user\n        expect(user.username).to eq(old_username)\n      end\n\n      it \"can change the username\" do\n        put \"/invites/show/#{invite.invite_key}.json\",\n            params: {\n              username: \"new_username\",\n              password: \"Password123456\",\n              email_token: invite.email_token,\n            }\n\n        expect(response.status).to eq(200)\n        expect(invite.reload.redeemed?).to be_truthy\n        user = invite.invited_users.first.user\n        expect(user.username).to eq(\"new_username\")\n      end\n    end\n  end\n\n  describe \"#destroy_all_expired\" do\n    it \"removes all expired invites sent by a user\" do\n      SiteSetting.invite_expiry_days = 1\n\n      user = Fabricate(:admin)\n      invite_1 = Fabricate(:invite, invited_by: user)\n      invite_2 = Fabricate(:invite, invited_by: user)\n      expired_invite = Fabricate(:invite, invited_by: user)\n      expired_invite.update!(expires_at: 2.days.ago)\n\n      sign_in(user)\n      post \"/invites/destroy-all-expired\"\n\n      expect(response.status).to eq(200)\n      expect(invite_1.reload.deleted_at).to eq(nil)\n      expect(invite_2.reload.deleted_at).to eq(nil)\n      expect(expired_invite.reload.deleted_at).to be_present\n    end\n  end\n\n  describe \"#resend_invite\" do\n    it \"requires to be logged in\" do\n      post \"/invites/reinvite.json\", params: { email: \"first_name@example.com\" }\n      expect(response.status).to eq(403)\n    end\n\n    context \"while logged in\" do\n      fab!(:user) { sign_in(Fabricate(:user)) }\n      fab!(:invite) { Fabricate(:invite, invited_by: user) }\n      fab!(:another_invite) { Fabricate(:invite, email: \"last_name@example.com\") }\n\n      it \"raises an error when the email is missing\" do\n        post \"/invites/reinvite.json\"\n        expect(response.status).to eq(400)\n      end\n\n      it \"raises an error when the email cannot be found\" do\n        post \"/invites/reinvite.json\", params: { email: \"first_name@example.com\" }\n        expect(response.status).to eq(400)\n      end\n\n      it \"raises an error when the invite is not yours\" do\n        post \"/invites/reinvite.json\", params: { email: another_invite.email }\n        expect(response.status).to eq(400)\n      end\n\n      it \"resends the invite\" do\n        post \"/invites/reinvite.json\", params: { email: invite.email }\n        expect(response.status).to eq(200)\n        expect(Jobs::InviteEmail.jobs.size).to eq(1)\n      end\n    end\n  end\n\n  describe \"#resend_all_invites\" do\n    let(:admin) { Fabricate(:admin) }\n\n    before do\n      SiteSetting.invite_expiry_days = 30\n      RateLimiter.enable\n    end\n\n    use_redis_snapshotting\n\n    it \"resends all non-redeemed invites by a user\" do\n      freeze_time\n\n      new_invite = Fabricate(:invite, invited_by: admin)\n      expired_invite = Fabricate(:invite, invited_by: admin)\n      expired_invite.update!(expires_at: 2.days.ago)\n      redeemed_invite = Fabricate(:invite, invited_by: admin)\n      Fabricate(:invited_user, invite: redeemed_invite, user: Fabricate(:user))\n      redeemed_invite.update!(expires_at: 5.days.ago)\n\n      sign_in(admin)\n      post \"/invites/reinvite-all\"\n\n      expect(response.status).to eq(200)\n      expect(new_invite.reload.expires_at).to eq_time(30.days.from_now)\n      expect(expired_invite.reload.expires_at).to eq_time(2.days.ago)\n      expect(redeemed_invite.reload.expires_at).to eq_time(5.days.ago)\n    end\n\n    it \"errors if admins try to exceed limit of one bulk invite per day\" do\n      sign_in(admin)\n      start = Time.now\n\n      freeze_time(start)\n      post \"/invites/reinvite-all\"\n      expect(response.parsed_body[\"errors\"]).to_not be_present\n\n      freeze_time(start + 10.minutes)\n      post \"/invites/reinvite-all\"\n      expect(response.parsed_body[\"errors\"][0]).to eq(I18n.t(\"rate_limiter.slow_down\"))\n    end\n  end\n\n  describe \"#upload_csv\" do\n    it \"requires to be logged in\" do\n      post \"/invites/upload_csv.json\"\n      expect(response.status).to eq(403)\n    end\n\n    context \"while logged in\" do\n      let(:csv_file) { File.new(\"#{Rails.root}/spec/fixtures/csv/discourse.csv\") }\n      let(:file) { Rack::Test::UploadedFile.new(File.open(csv_file)) }\n\n      let(:csv_file_with_headers) do\n        File.new(\"#{Rails.root}/spec/fixtures/csv/discourse_headers.csv\")\n      end\n      let(:file_with_headers) { Rack::Test::UploadedFile.new(File.open(csv_file_with_headers)) }\n      let(:csv_file_with_locales) do\n        File.new(\"#{Rails.root}/spec/fixtures/csv/invites_with_locales.csv\")\n      end\n      let(:file_with_locales) { Rack::Test::UploadedFile.new(File.open(csv_file_with_locales)) }\n\n      it \"fails if you cannot bulk invite to the forum\" do\n        sign_in(Fabricate(:user))\n        post \"/invites/upload_csv.json\", params: { file: file, name: \"discourse.csv\" }\n        expect(response.status).to eq(403)\n      end\n\n      it \"allows admin to bulk invite\" do\n        sign_in(admin)\n        post \"/invites/upload_csv.json\", params: { file: file, name: \"discourse.csv\" }\n        expect(response.status).to eq(200)\n        expect(Jobs::BulkInvite.jobs.size).to eq(1)\n      end\n\n      it \"allows admin to bulk invite when DiscourseConnect enabled\" do\n        SiteSetting.discourse_connect_url = \"https://example.com\"\n        SiteSetting.enable_discourse_connect = true\n\n        sign_in(admin)\n        post \"/invites/upload_csv.json\", params: { file: file, name: \"discourse.csv\" }\n        expect(response.status).to eq(200)\n        expect(Jobs::BulkInvite.jobs.size).to eq(1)\n      end\n\n      it \"sends limited invites at a time\" do\n        SiteSetting.max_bulk_invites = 3\n        sign_in(admin)\n        post \"/invites/upload_csv.json\", params: { file: file, name: \"discourse.csv\" }\n\n        expect(response.status).to eq(422)\n        expect(Jobs::BulkInvite.jobs.size).to eq(1)\n        expect(response.parsed_body[\"errors\"][0]).to eq(\n          I18n.t(\"bulk_invite.max_rows\", max_bulk_invites: SiteSetting.max_bulk_invites),\n        )\n      end\n\n      it \"can import user fields\" do\n        Jobs.run_immediately!\n        user_field = Fabricate(:user_field, name: \"location\")\n        Fabricate(:group, name: \"discourse\")\n        Fabricate(:group, name: \"ubuntu\")\n\n        sign_in(admin)\n\n        post \"/invites/upload_csv.json\",\n             params: {\n               file: file_with_headers,\n               name: \"discourse_headers.csv\",\n             }\n        expect(response.status).to eq(200)\n\n        user = User.where(staged: true).find_by_email(\"test@example.com\")\n        expect(user.user_fields[user_field.id.to_s]).to eq(\"usa\")\n\n        user2 = User.where(staged: true).find_by_email(\"test2@example.com\")\n        expect(user2.user_fields[user_field.id.to_s]).to eq(\"europe\")\n      end\n\n      it \"can pre-set user locales\" do\n        Jobs.run_immediately!\n        sign_in(admin)\n\n        post \"/invites/upload_csv.json\",\n             params: {\n               file: file_with_locales,\n               name: \"discourse_headers.csv\",\n             }\n        expect(response.status).to eq(200)\n\n        user = User.where(staged: true).find_by_email(\"test@example.com\")\n        expect(user.locale).to eq(\"de\")\n\n        user2 = User.where(staged: true).find_by_email(\"test2@example.com\")\n        expect(user2.locale).to eq(\"pl\")\n      end\n    end\n  end\nend\n"], "filenames": ["app/controllers/invites_controller.rb", "app/models/invite_redeemer.rb", "spec/requests/invites_controller_spec.rb"], "buggy_code_start_loc": [281, 246, 986], "buggy_code_end_loc": [282, 247, 986], "fixing_code_start_loc": [281, 246, 987], "fixing_code_end_loc": [285, 250, 1008], "type": "CWE-362", "message": "Discourse is an open source discussion platform. Prior to version 3.0.6 of the `stable` branch and version 3.1.0.beta7 of the `beta` and `tests-passed` branches, more users than permitted could be created from invite links. The issue is patched in version 3.0.6 of the `stable` branch and version 3.1.0.beta7 of the `beta` and `tests-passed` branches. As a workaround, use restrict to email address invites.", "other": {"cve": {"id": "CVE-2023-37904", "sourceIdentifier": "security-advisories@github.com", "published": "2023-07-28T16:15:11.617", "lastModified": "2023-08-03T17:51:20.897", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Discourse is an open source discussion platform. Prior to version 3.0.6 of the `stable` branch and version 3.1.0.beta7 of the `beta` and `tests-passed` branches, more users than permitted could be created from invite links. The issue is patched in version 3.0.6 of the `stable` branch and version 3.1.0.beta7 of the `beta` and `tests-passed` branches. As a workaround, use restrict to email address invites."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.1, "baseSeverity": "LOW"}, "exploitabilityScore": 1.6, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.6, "baseSeverity": "LOW"}, "exploitabilityScore": 1.2, "impactScore": 1.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-362"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:*:*:*:*:stable:*:*:*", "versionEndExcluding": "3.0.6", "matchCriteriaId": "8706E13A-141F-4E47-AA17-8DA913CE2020"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.1.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "BF272688-1B08-4ABC-8002-66B59690F9A5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.1.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "A29A2465-B21D-4147-8292-DCF864D385B4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.1.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "BBC3511E-3D68-42E2-B521-966FB429B640"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.1.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "EC8B99C2-E267-4EC2-AF09-C9AD1EEE76D9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.1.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "F21A22EE-081A-4489-A7F8-22E2DBC5B00E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.1.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "6E6C8FB3-4B19-4510-B9A8-BCF9ED8ED7C9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.1.0:beta6b:*:*:beta:*:*:*", "matchCriteriaId": "5B827291-6483-4BB7-AF76-530B669B3ED5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.1.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "551E70ED-34FF-4989-91C9-6312DE4AB4DF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.1.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "204FB99A-8F11-4F04-9ED9-D94551790116"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.2.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "46A8705C-0DF6-45D7-A38C-D2AB69194C59"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.2.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "F59B0D8E-CFFB-4EBA-9D6A-526F9541BA17"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.2.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "D801A898-27D0-4076-8AF9-2B574FA11723"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.2.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "E7CBBD4A-4FDB-49E0-A5B6-22701C12BDF2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.2.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "9E7328DF-1924-4D0D-AC6B-1BA2D9CF1D4D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.2.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "9421CE10-F226-4F2C-9DA7-EBB44B73C304"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.2.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "1E71FBB6-ECAD-4581-9982-4C330D55FEAF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.2.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "1B631CCC-D456-49FF-B626-59C40BD4E167"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.2.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "BE83F98D-F7AA-434B-8438-5B1FB96681B9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.3.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "EB93F19B-9087-44CE-B884-45F434B7906F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.3.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "5A88A5A3-EF1A-4E86-B074-CE0AC4325484"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.3.0:beta11:*:*:beta:*:*:*", "matchCriteriaId": "0650B4C7-BCFE-4180-8FEF-4170A67E8BD3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.3.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "388F376E-46C9-4163-992D-95E3E4548D0F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.3.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "D661090A-DA61-4BBE-85C3-6F48C053C84B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.3.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "4A458242-D6DD-46E3-AF09-66BC87C5D7A6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.3.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "A8FACCBA-0D3B-4E6F-85A0-1CBD2B367F71"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.3.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "F1D83D80-A0BE-4794-91A1-599AF558FB67"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.3.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "BD15B6B2-BFB3-4271-A507-48E9B827FA02"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.3.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "E0003042-9B14-4E1B-800F-3D154FFE8A1A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.3.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "E449EA29-81C8-4477-977E-746EACDBED86"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.4.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "6FC6D4DF-8686-4054-A0C1-784E194171E6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.4.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "C574C37D-3D99-4430-A3D5-199883556B64"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.4.0:beta11:*:*:beta:*:*:*", "matchCriteriaId": "F344E950-EFF9-4405-99D7-0B615C32873F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.4.0:beta12:*:*:beta:*:*:*", "matchCriteriaId": "0A50DE1B-29EB-4014-B5B6-46CF493485F2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.4.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "638B3E17-9F0A-4A96-B8D3-DDFEA518DBE9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.4.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "6D3E3AEB-8CD4-4EE7-9C81-2F74512071DD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.4.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "254FF9D9-E696-41C8-B15B-DA089D2C6597"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.4.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "2A5001E1-E716-43AA-8093-E0EED9E07909"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.4.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "7FD16B13-516A-4D03-B1EF-A11156471A06"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.4.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "E886D9EF-7FBD-4A24-A8B6-54E4B15403C6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.4.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "369A83D1-AB7E-488D-9D74-26A69DFC1AD9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.4.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "3189CAC1-8970-4A33-B1E4-EB9EC3C19A25"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "A8733438-7625-400E-8237-BAE3D9F147AB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "E87F1ED0-FD0D-4767-8E7C-325D920B79BD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta11:*:*:beta:*:*:*", "matchCriteriaId": "97811266-A13C-4441-A1B5-BFA4B0862DFE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta12:*:*:beta:*:*:*", "matchCriteriaId": "3D09D157-4B19-4561-AB20-952F2EA9BA0C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta13:*:*:beta:*:*:*", "matchCriteriaId": "789087AF-0011-4E8F-A5AB-432A5F91BBA8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta13b:*:*:beta:*:*:*", "matchCriteriaId": "8EC9DC8C-56DC-482B-8847-BD0CFACA6F8D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta14:*:*:beta:*:*:*", "matchCriteriaId": "F63B3D13-24F6-4EFA-9528-DBF59D973A9A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "7F3A2388-18DE-46B0-BC13-7714E25D1B1C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "940B11CB-053F-4D60-8BC4-81CA659D2F7B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "83684DCB-B201-43B8-8B6E-6D0B13B7E437"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "DF92E1FD-9B41-4A41-8B13-9D789C5729D6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "351D224A-E67C-454C-AF43-8AD6CD44C685"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "E058CA6D-A295-4CAD-8C85-E8C83BAFEBD2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "FF99C114-1BCA-4400-BC7E-EDA1F55559CE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "BBA1EFBA-5A26-46A0-B2A6-53B9924253BF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.6.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "FE5B90B0-B6CC-4189-9C98-CF29017A47B5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.6.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "A1818628-5F4E-4E5D-974A-0BEBCE821209"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.6.0:beta11:*:*:beta:*:*:*", "matchCriteriaId": "14785840-3BC0-4030-AE44-E3013DF19AD7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.6.0:beta12:*:*:beta:*:*:*", "matchCriteriaId": "90444209-684C-4BF8-9BCF-6B29EA0A0593"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.6.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "668E15DE-8CF2-4AF3-B13A-9080046B1E03"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.6.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "1191861C-1B2C-4762-805D-FCDC20F84D05"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.6.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "3CB518E5-CCC0-46B8-848E-C492BCF7E9BB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.6.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "CA1F68FE-67EA-4408-8E0F-558B0FAFFF32"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.6.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "66E9F05C-799A-43D3-9367-FCA86166BD65"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.6.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "85DB4097-6EFC-4017-ADFD-56EE49BB2F34"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.6.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "AD283EA2-9026-497F-A7DE-E16CE0764ED0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.6.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "ED19DDDF-A29E-4C3F-A818-23D7E37B6974"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.7.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "508D0052-B7D7-4A08-8BB0-7D7A1EDAB96D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.7.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "3E50BFB0-67D3-4EDE-93FE-85EAF605461E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.7.0:beta11:*:*:beta:*:*:*", "matchCriteriaId": "D7EE0134-6AD7-4695-B536-1959FE3A9672"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.7.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "25DFFB5C-277F-4436-9BCE-643E98721C5A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.7.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "B8B80EB2-0B48-4AFA-8A09-26006CCDB022"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.7.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "AC8705E0-23ED-4817-8B69-21A4963C27F8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.7.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "BAA156A9-A9FB-4D03-B0EE-4AA303D7A9CF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.7.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "F733E585-075C-402A-9B34-1FE79DE4137E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.7.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "05C43439-C694-47AA-90AF-0AC2277E3D3B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.7.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "B391F8A1-F102-4C88-864C-1386452CDAB0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.7.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "0BC33C93-9947-4983-96A3-7DE223929817"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "B46DE141-1224-499E-AAE0-6CC0D5249B2C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "D8D07501-A07E-4743-A188-2E5BBC3C8F97"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta11:*:*:beta:*:*:*", "matchCriteriaId": "64FD2A30-EE33-4680-9DCF-29283DBA3C4F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta12:*:*:beta:*:*:*", "matchCriteriaId": "B517F7A2-6FD1-4A7B-80E7-1167EC296591"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta13:*:*:beta:*:*:*", "matchCriteriaId": "E6CA6EA5-DDAD-4882-AD1B-634C0CD741BE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "F14DCB07-9464-4DDE-98A1-FAE85DD60FBC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "6EDFD679-4710-4A62-B254-E658EED4295B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "A1B81072-08A5-4EC6-B737-E35C505C1E47"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "A0748A9E-5737-48F9-BB66-6576AFE16198"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "453E51D9-89A1-4A91-B218-05C45CC4E329"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "51542BA7-8151-4FC9-9C86-36CEB476B912"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "5F95391C-0B75-47D2-9770-561E05414CEF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "10384675-B949-4B50-AF42-B5A3EE27250B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "7C0DB1C0-5749-4508-A265-C2138F7852E9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "CA9977CF-575C-4A19-84C8-EBB68EBE88C9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta11:*:*:beta:*:*:*", "matchCriteriaId": "87C525C5-E282-4EC6-956F-0C94DC11FC69"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta12:*:*:beta:*:*:*", "matchCriteriaId": "7F02A2A8-6312-4F6D-ABBF-952CA4C5E02E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta13:*:*:beta:*:*:*", "matchCriteriaId": "DE54D1A3-FC2A-40DE-9177-50332208B0B2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta14:*:*:beta:*:*:*", "matchCriteriaId": "170AE3DA-92C1-4D1D-9CAC-543C01FFF479"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta15:*:*:beta:*:*:*", "matchCriteriaId": "2130C3C5-E4A5-41C3-89F0-C6FB4E47D096"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta16:*:*:beta:*:*:*", "matchCriteriaId": "74248527-B884-4134-95C8-DEAF3D774A9A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta17:*:*:beta:*:*:*", "matchCriteriaId": "01A8AF9C-8BF6-4ADC-A85A-A5C1F9FFB2C7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "B4038D09-467C-4815-A429-F0E1E3E545E7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "6F273237-7223-4047-83B7-16A49B7E554A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "CF26EE13-554C-4180-98A2-238D84E40927"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "12688C9C-291D-4BF2-93F9-09AA323C52A9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "A7F7A437-D538-4B44-AC41-C95641A11A35"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "9BB61DCF-52DB-498D-8779-D565E548C285"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "EE56BB77-B7F7-4BE7-AD9C-33888C5D01FE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "9DB49E1D-BCC8-4984-A81D-5DAC5E3DF168"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.0.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "F775EA72-CCE3-4230-A666-EFDAA61F71FE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.0.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "5E65BDEE-850A-41C6-8CFB-BD8B3A105CD1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.0.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "AF196429-FDED-4C3F-9F7D-0A2BF7DCAD1E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.0.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "64B84326-5397-4C60-8007-F7E7D81DC661"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.0.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "9A0A526A-9662-4E39-8BF6-E464BE1A2B6F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.0.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "712DACC2-A21E-429F-8A7B-86D8F7CE3468"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.0.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "6E93F9F6-5B03-4F77-B8B4-AEC9E4011692"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.0.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "C5B2B98E-804F-4525-B726-3F1DF2693F79"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.0.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "582E339F-678A-4377-8EE0-8F4208E3EF78"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.0.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "1BF1D945-6EAA-4FA7-8252-2FED079587F0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.1.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "9325DFF5-EA7B-4B8D-A227-4B1A59449CE1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.1.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "0ECB28DA-3CA1-4011-9170-BFBF2ED3E091"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.1.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "2A6399B0-471B-4B26-859C-3836F2A6B7D1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.1.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "131E2AE4-E35D-495D-8907-3B899BB8AC41"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.1.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "83601528-0DD9-4835-B6C0-0F341871CC15"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.1.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "4AEB5AAF-73EB-4356-8C53-10E22B2F910E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.2.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "9EB199D6-E253-4EC2-BF0B-059F7B6662ED"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.2.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "94A586EB-B0E0-4190-88DF-3BCC04E5EF84"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.2.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "0BF27B44-9AA7-4B91-9B4B-0E84418F5632"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.2.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "461744BD-3974-4C33-8514-0A917DC90C6C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.2.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "6A86FB2B-6915-49C0-B993-0711AAECA5FE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.2.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "9EF3DD36-2776-4CD2-A3F1-88872024D223"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.2.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "D91D71ED-F08F-4DB5-B7DD-062E7C11435F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.2.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "62B5812A-FB52-4F4B-9A15-3AA5CD6562E3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.2.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "83231EC0-E3F7-4E35-B165-487C2725B4F1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.2.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "A53AFFA6-7B98-47F2-9BD7-71C83A69CE26"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.3.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "A42D3FB9-9197-4101-A729-876C490BD572"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.3.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "A5DE0C47-0C66-4EFE-AF82-1B22F4F54A44"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.3.0:beta11:*:*:beta:*:*:*", "matchCriteriaId": "E587D10F-BEF8-4923-AF76-6DC3172880EE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.3.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "155568EF-6A7E-423A-B5EA-D20E407B271B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.3.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "7E94B119-8C75-43DF-A2DF-A5B3E04F0778"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.3.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "5348F94F-F6AE-4400-8AC7-036111EF43D9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.3.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "57948A73-C9C5-4C24-947D-0A4659C7002E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.3.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "3532EE37-2D0F-496C-B5A8-F9315FFB4552"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.3.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "2CAE7CC9-B91D-494C-B91A-497D6FE6B14B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.3.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "623BBBF8-4121-466A-82C8-D179B02B3E34"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.3.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "648D010A-8B8D-42AA-8888-09E4E0FAA954"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.4.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "8ADC7613-25E3-4CB8-A962-2775C20E4D4F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.4.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "1B0099F0-A275-4C65-9B79-041374F183DF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.4.0:beta11:*:*:beta:*:*:*", "matchCriteriaId": "FE69800E-5CB5-4916-879C-51DE5E94489F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.4.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "8C64EAFE-2B60-4D95-869F-4A2FC98B99C8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.4.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "AB2045F1-AC39-4738-B3F0-33F00D23C921"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.4.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "E32589F8-2E87-40D2-BAD3-E6C1C088CA60"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.4.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "4868BAFD-BFE5-4361-855A-644B040E7233"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.4.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "4B6C25BF-5B2A-43C4-8918-E32BA9DD8A22"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.4.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "EB9917D3-D848-4D2B-8A44-B3723BA377DA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.4.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "7046D95B-73CE-406B-ACC3-FD71F7DEC7CE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.4.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "D3BA5033-2C06-42FF-962E-48EBA2EBB469"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.5.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "630D29DE-0FD7-4306-BA80-20D0791D334B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.5.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "08F94E42-07A1-480D-B6DD-D96AE38F1EBA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.5.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "FA4B3DE5-21DA-4185-AF74-AAA6DD89FB3D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.5.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "E602BEF9-E89D-40F7-BC6F-5C6F9F25BA97"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.5.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "C06A8627-683D-4328-BE7A-4A33A4B736F2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.5.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "E3EF8240-D3F5-422C-B70A-90C6CBA4E622"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.5.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "93CC792D-AE0B-498E-8374-5D09EF4E28FF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.6.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "093D4EA8-B002-4AB4-97C9-CEE4D70BF3C8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.6.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "4C778180-E7BF-4EF2-8B19-0388E23E1424"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.6.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "0C0B2BC1-35F1-4A1D-B9B2-54426B4ADF34"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.6.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "6BCAB620-465A-41FF-A064-FB638DD3A557"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.6.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "6AFCB802-A275-444C-8245-D0397322125F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.6.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "9F9B70E2-AAAD-4E61-AEB2-E5F635F6AAD5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.7.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "6182074E-C467-448C-9299-B92CFE4EEBE0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.7.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "09EA8F36-7647-42D0-8675-34C002E0754D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.7.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "9CE2276A-9680-4B14-9636-806F7E4C1669"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.7.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "AD150166-4C8D-47E3-989A-1A71A46C36A1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.7.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "CF5CA6AD-FA4D-47DF-A684-5DAD7662EA13"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.7.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "B94F75B8-7C84-4727-9D18-114A815E1906"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.7.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "4D94E03A-32EE-408F-81FA-4B9C25AA7DDF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.7.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "AD495875-007C-4A90-B940-B62E6FA492CC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.7.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "05F1B84E-8AF8-46E8-9DE9-00D1DE348C2C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "BCCEFDFB-61E6-4846-8093-B5CEB0D8450C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "0BC63647-B692-4BB9-9A3D-6F8DF19C3494"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta11:*:*:beta:*:*:*", "matchCriteriaId": "05F0ED55-C8C6-47C1-859A-60046838B6F7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "6A2D59BC-2EE8-4F9C-AB5B-B9D01B44F7CD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "933DFEBC-5568-431B-809D-AFAEFD08E985"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "BE920E80-C02B-4EC8-982F-ADE89C936684"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "CDAE3441-12BA-41F4-8A5A-B2EE844C86BF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "1443EA1B-D210-4219-8452-CBFD5FACBC77"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "948A4B4A-A11F-477E-BEC5-0D60C7E3570C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "98B2A052-5427-4B72-9F59-82F430836CB4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "CB6D636E-B51F-4648-A637-62B2603BA18F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "3DA17871-7ED7-4D68-A46D-D15DC5B3235F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "705FE965-0415-4382-8CA1-A19DF3B5EF35"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta11:*:*:beta:*:*:*", "matchCriteriaId": "BC6EDCE3-D564-434F-9A7F-D4A6D579F8F7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta12:*:*:beta:*:*:*", "matchCriteriaId": "FB05E54B-9CF6-45A7-8D47-C98DB6D19E7E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta13:*:*:beta:*:*:*", "matchCriteriaId": "03CD1C5E-18F5-4C6D-B92C-C511C8C12D0B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta14:*:*:beta:*:*:*", "matchCriteriaId": "FF4ABB9D-69DF-42D5-AD60-F9CEEC1B6730"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "7B4DCCF5-E290-4BDA-AAB9-DF362A2EB7B3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "3AE1F3A2-8340-4ED7-B943-ACDA9617DF64"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "5E033AB7-9987-4C30-849F-2495376CA4F2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "D87E9338-C7F6-43BA-886F-C30987ADBA1D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "E24EB90F-FE81-4746-8741-8DC9346F79C1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "D237956F-FC90-467E-A493-24EFDA1A9F2D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "F7AA9AB8-AB6F-43E2-B3E5-685EE9BFE7D4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "5BC240A1-431E-4A50-88DC-7AC9BC674254"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:3.0.0:beta15:*:*:beta:*:*:*", "matchCriteriaId": "3F85AFD4-D397-4FDB-B762-521BD5FF14C1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:3.0.0:beta16:*:*:beta:*:*:*", "matchCriteriaId": "D40CDCE1-3462-4D6C-A3C7-487F175264CA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:3.1.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "B9BBED17-A6BA-4F17-8814-8D8521F28375"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:3.1.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "888B8ECF-EBE0-4821-82F6-B0026E95E407"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:3.1.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "FD0302B1-C0BA-49EE-8E1B-E8A43879BFC2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:3.1.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "9FE11D4E-32EE-48F4-8082-B37D2F804450"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:3.1.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "9D797DA5-1AE5-4D49-B133-AF45D7FB0A4A"}]}]}], "references": [{"url": "https://github.com/discourse/discourse/commit/62a609ea2d0645a27ee8adbb01ce10a5e03a600b", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/discourse/discourse/security/advisories/GHSA-6wj5-4ph2-c7qg", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/discourse/discourse/commit/62a609ea2d0645a27ee8adbb01ce10a5e03a600b"}}