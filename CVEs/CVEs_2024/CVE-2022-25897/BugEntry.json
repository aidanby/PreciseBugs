{"buggy_code": ["/*\n * Copyright (c) 2022 the Eclipse Milo Authors\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\n\npackage org.eclipse.milo.opcua.sdk.server.api.config;\n\nimport java.util.concurrent.TimeUnit;\n\nimport org.eclipse.milo.opcua.stack.core.channel.EncodingLimits;\nimport org.eclipse.milo.opcua.stack.core.types.builtin.unsigned.UInteger;\nimport org.eclipse.milo.opcua.stack.core.types.builtin.unsigned.UShort;\n\nimport static org.eclipse.milo.opcua.stack.core.types.builtin.unsigned.Unsigned.uint;\nimport static org.eclipse.milo.opcua.stack.core.types.builtin.unsigned.Unsigned.ushort;\n\npublic interface OpcUaServerConfigLimits {\n\n    /**\n     * Get the maximum number of sessions that can be open at any given time.\n     *\n     * @return the maximum number of sessions that can be open at any given time.\n     */\n    default UInteger getMaxSessionCount() {\n        return uint(100);\n    }\n\n    /**\n     * Get the maximum session timeout, in milliseconds, allowed by the server.\n     * <p>\n     * Requests by clients for larger timeouts will be revised down to this limit.\n     *\n     * @return the maximum session timeout, in milliseconds, allowed by the server.\n     */\n    default Double getMaxSessionTimeout() {\n        return 2d * 60_000d;\n    }\n\n    /**\n     * Get the minimum allowed publishing interval.\n     *\n     * @return the minimum allowed publishing interval.\n     */\n    default Double getMinPublishingInterval() {\n        return 10.0;\n    }\n\n    /**\n     * Get the maximum allowed publishing interval.\n     *\n     * @return the maximum allowed publishing interval.\n     */\n    default Double getMaxPublishingInterval() {\n        return (double) TimeUnit.MILLISECONDS.convert(8, TimeUnit.HOURS);\n    }\n\n    /**\n     * Get the default publishing interval, used when the requested interval is either invalid or below the minimum.\n     *\n     * @return the default publishing interval.\n     */\n    default Double getDefaultPublishingInterval() {\n        return 250.0;\n    }\n\n    /**\n     * Get the minimum subscription lifetime, in milliseconds.\n     * <p>\n     * This value should be larger than the configured minimum publishing interval.\n     *\n     * @return the minimum subscription lifetime, in milliseconds.\n     */\n    default Double getMinSubscriptionLifetime() {\n        return 10_000.0;\n    }\n\n    /**\n     * Get the maximum subscription lifetime, in milliseconds.\n     * <p>\n     * This value should be larger than the configured maximum publishing interval.\n     *\n     * @return the maximum subscription lifetime, in milliseconds.\n     */\n    default Double getMaxSubscriptionLifetime() {\n        return (double) TimeUnit.MILLISECONDS.convert(24, TimeUnit.HOURS);\n    }\n\n    default Double getMaxSupportedSampleRate() {\n        return (double) TimeUnit.MILLISECONDS.convert(24, TimeUnit.HOURS);\n    }\n\n    /**\n     * Get the maximum allowed password length.\n     *\n     * @return the maximum allowed password length.\n     */\n    default UInteger getMaxPasswordLength() {\n        return uint(1024);\n    }\n\n    /**\n     * Get the maximum number of MonitoredItems, across all Sessions, that can be created.\n     *\n     * @return the maximum number of MonitoredItems, across all Sessions, that can be created.\n     */\n    default UInteger getMaxMonitoredItems() {\n        return uint(Integer.MAX_VALUE);\n    }\n\n    //region ServerCapabilities\n\n    default Double getMinSupportedSampleRate() {\n        return 0.0;\n    }\n\n    default UInteger getMaxArrayLength() {\n        return uint(EncodingLimits.DEFAULT_MAX_MESSAGE_SIZE / 2);\n    }\n\n    default UInteger getMaxStringLength() {\n        return uint(EncodingLimits.DEFAULT_MAX_MESSAGE_SIZE / 2);\n    }\n\n    default UInteger getMaxByteStringLength() {\n        return uint(EncodingLimits.DEFAULT_MAX_MESSAGE_SIZE / 2);\n    }\n\n    default UShort getMaxBrowseContinuationPoints() {\n        return ushort(250);\n    }\n\n    default UShort getMaxQueryContinuationPoints() {\n        return ushort(250);\n    }\n\n    default UShort getMaxHistoryContinuationPoints() {\n        return ushort(250);\n    }\n\n    //endregion\n\n    //region OperationLimits\n\n    default UInteger getMaxNodesPerRead() {\n        return uint(10_000);\n    }\n\n    default UInteger getMaxNodesPerWrite() {\n        return uint(10_000);\n    }\n\n    default UInteger getMaxMonitoredItemsPerCall() {\n        return uint(10_000);\n    }\n\n    default UInteger getMaxNodesPerRegisterNodes() {\n        return uint(250);\n    }\n\n    default UInteger getMaxNodesPerHistoryReadData() {\n        return uint(250);\n    }\n\n    default UInteger getMaxNodesPerHistoryReadEvents() {\n        return uint(250);\n    }\n\n    default UInteger getMaxNodesPerHistoryUpdateData() {\n        return uint(250);\n    }\n\n    default UInteger getMaxNodesPerHistoryUpdateEvents() {\n        return uint(250);\n    }\n\n    default UInteger getMaxNodesPerMethodCall() {\n        return uint(250);\n    }\n\n    default UInteger getMaxNodesPerBrowse() {\n        return uint(250);\n    }\n\n    default UInteger getMaxNodesPerTranslateBrowsePathsToNodeIds() {\n        return uint(250);\n    }\n\n    default UInteger getMaxNodesPerNodeManagement() {\n        return uint(250);\n    }\n\n    //endregion\n\n}\n", "/*\n * Copyright (c) 2022 the Eclipse Milo Authors\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\n\npackage org.eclipse.milo.opcua.sdk.server.subscriptions;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.EnumSet;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.atomic.AtomicLong;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.stream.Stream;\n\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport io.netty.util.AttributeKey;\nimport org.eclipse.milo.opcua.sdk.core.AccessLevel;\nimport org.eclipse.milo.opcua.sdk.core.NumericRange;\nimport org.eclipse.milo.opcua.sdk.core.Reference;\nimport org.eclipse.milo.opcua.sdk.server.OpcUaServer;\nimport org.eclipse.milo.opcua.sdk.server.Session;\nimport org.eclipse.milo.opcua.sdk.server.api.DataItem;\nimport org.eclipse.milo.opcua.sdk.server.api.EventItem;\nimport org.eclipse.milo.opcua.sdk.server.api.MonitoredItem;\nimport org.eclipse.milo.opcua.sdk.server.api.services.AttributeServices.ReadContext;\nimport org.eclipse.milo.opcua.sdk.server.items.BaseMonitoredItem;\nimport org.eclipse.milo.opcua.sdk.server.items.MonitoredDataItem;\nimport org.eclipse.milo.opcua.sdk.server.items.MonitoredEventItem;\nimport org.eclipse.milo.opcua.sdk.server.nodes.UaNode;\nimport org.eclipse.milo.opcua.sdk.server.subscriptions.Subscription.State;\nimport org.eclipse.milo.opcua.stack.core.AttributeId;\nimport org.eclipse.milo.opcua.stack.core.Identifiers;\nimport org.eclipse.milo.opcua.stack.core.StatusCodes;\nimport org.eclipse.milo.opcua.stack.core.UaException;\nimport org.eclipse.milo.opcua.stack.core.UaSerializationException;\nimport org.eclipse.milo.opcua.stack.core.types.builtin.DataValue;\nimport org.eclipse.milo.opcua.stack.core.types.builtin.DiagnosticInfo;\nimport org.eclipse.milo.opcua.stack.core.types.builtin.ExtensionObject;\nimport org.eclipse.milo.opcua.stack.core.types.builtin.NodeId;\nimport org.eclipse.milo.opcua.stack.core.types.builtin.QualifiedName;\nimport org.eclipse.milo.opcua.stack.core.types.builtin.StatusCode;\nimport org.eclipse.milo.opcua.stack.core.types.builtin.unsigned.UByte;\nimport org.eclipse.milo.opcua.stack.core.types.builtin.unsigned.UInteger;\nimport org.eclipse.milo.opcua.stack.core.types.enumerated.DeadbandType;\nimport org.eclipse.milo.opcua.stack.core.types.enumerated.MonitoringMode;\nimport org.eclipse.milo.opcua.stack.core.types.enumerated.TimestampsToReturn;\nimport org.eclipse.milo.opcua.stack.core.types.structured.CreateMonitoredItemsRequest;\nimport org.eclipse.milo.opcua.stack.core.types.structured.CreateMonitoredItemsResponse;\nimport org.eclipse.milo.opcua.stack.core.types.structured.CreateSubscriptionRequest;\nimport org.eclipse.milo.opcua.stack.core.types.structured.CreateSubscriptionResponse;\nimport org.eclipse.milo.opcua.stack.core.types.structured.DataChangeFilter;\nimport org.eclipse.milo.opcua.stack.core.types.structured.DeleteMonitoredItemsRequest;\nimport org.eclipse.milo.opcua.stack.core.types.structured.DeleteMonitoredItemsResponse;\nimport org.eclipse.milo.opcua.stack.core.types.structured.DeleteSubscriptionsRequest;\nimport org.eclipse.milo.opcua.stack.core.types.structured.DeleteSubscriptionsResponse;\nimport org.eclipse.milo.opcua.stack.core.types.structured.EventFilter;\nimport org.eclipse.milo.opcua.stack.core.types.structured.ModifyMonitoredItemsRequest;\nimport org.eclipse.milo.opcua.stack.core.types.structured.ModifyMonitoredItemsResponse;\nimport org.eclipse.milo.opcua.stack.core.types.structured.ModifySubscriptionRequest;\nimport org.eclipse.milo.opcua.stack.core.types.structured.ModifySubscriptionResponse;\nimport org.eclipse.milo.opcua.stack.core.types.structured.MonitoredItemCreateRequest;\nimport org.eclipse.milo.opcua.stack.core.types.structured.MonitoredItemCreateResult;\nimport org.eclipse.milo.opcua.stack.core.types.structured.MonitoredItemModifyRequest;\nimport org.eclipse.milo.opcua.stack.core.types.structured.MonitoredItemModifyResult;\nimport org.eclipse.milo.opcua.stack.core.types.structured.MonitoringFilter;\nimport org.eclipse.milo.opcua.stack.core.types.structured.MonitoringParameters;\nimport org.eclipse.milo.opcua.stack.core.types.structured.NotificationMessage;\nimport org.eclipse.milo.opcua.stack.core.types.structured.PublishRequest;\nimport org.eclipse.milo.opcua.stack.core.types.structured.ReadValueId;\nimport org.eclipse.milo.opcua.stack.core.types.structured.RepublishRequest;\nimport org.eclipse.milo.opcua.stack.core.types.structured.RepublishResponse;\nimport org.eclipse.milo.opcua.stack.core.types.structured.ResponseHeader;\nimport org.eclipse.milo.opcua.stack.core.types.structured.SetMonitoringModeRequest;\nimport org.eclipse.milo.opcua.stack.core.types.structured.SetMonitoringModeResponse;\nimport org.eclipse.milo.opcua.stack.core.types.structured.SetPublishingModeRequest;\nimport org.eclipse.milo.opcua.stack.core.types.structured.SetPublishingModeResponse;\nimport org.eclipse.milo.opcua.stack.core.types.structured.SetTriggeringRequest;\nimport org.eclipse.milo.opcua.stack.core.types.structured.SetTriggeringResponse;\nimport org.eclipse.milo.opcua.stack.core.types.structured.SubscriptionAcknowledgement;\nimport org.eclipse.milo.opcua.stack.server.services.ServiceRequest;\nimport org.jetbrains.annotations.Nullable;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport static com.google.common.collect.Lists.newArrayListWithCapacity;\nimport static java.util.stream.Collectors.toList;\nimport static org.eclipse.milo.opcua.sdk.core.util.StreamUtil.opt2stream;\nimport static org.eclipse.milo.opcua.stack.core.types.builtin.unsigned.Unsigned.ubyte;\nimport static org.eclipse.milo.opcua.stack.core.types.builtin.unsigned.Unsigned.uint;\nimport static org.eclipse.milo.opcua.stack.core.util.ConversionUtil.l;\n\npublic class SubscriptionManager {\n\n    static final AttributeKey<StatusCode[]> KEY_ACK_RESULTS = AttributeKey.valueOf(\"ackResults\");\n\n    private static final QualifiedName DEFAULT_BINARY_ENCODING = new QualifiedName(0, \"DefaultBinary\");\n    private static final QualifiedName DEFAULT_XML_ENCODING = new QualifiedName(0, \"DefaultXML\");\n\n    private static final AtomicLong SUBSCRIPTION_IDS = new AtomicLong(0L);\n\n    private static UInteger nextSubscriptionId() {\n        return uint(SUBSCRIPTION_IDS.incrementAndGet());\n    }\n\n    private final Logger logger = LoggerFactory.getLogger(getClass());\n\n    private final PublishQueue publishQueue = new PublishQueue();\n\n    private final Map<UInteger, Subscription> subscriptions = Maps.newConcurrentMap();\n    private final List<Subscription> transferred = Lists.newCopyOnWriteArrayList();\n\n    private final Session session;\n    private final OpcUaServer server;\n\n    public SubscriptionManager(Session session, OpcUaServer server) {\n        this.session = session;\n        this.server = server;\n    }\n\n    public Session getSession() {\n        return session;\n    }\n\n    public PublishQueue getPublishQueue() {\n        return publishQueue;\n    }\n\n    public OpcUaServer getServer() {\n        return server;\n    }\n\n    @Nullable\n    public Subscription getSubscription(UInteger subscriptionId) {\n        return subscriptions.get(subscriptionId);\n    }\n\n    public List<Subscription> getSubscriptions() {\n        return new ArrayList<>(subscriptions.values());\n    }\n\n    public void createSubscription(ServiceRequest service) {\n        CreateSubscriptionRequest request = (CreateSubscriptionRequest) service.getRequest();\n\n        UInteger subscriptionId = nextSubscriptionId();\n\n        Subscription subscription = new Subscription(\n            this,\n            subscriptionId,\n            request.getRequestedPublishingInterval(),\n            request.getRequestedMaxKeepAliveCount().longValue(),\n            request.getRequestedLifetimeCount().longValue(),\n            request.getMaxNotificationsPerPublish().longValue(),\n            request.getPublishingEnabled(),\n            request.getPriority().intValue()\n        );\n\n        subscriptions.put(subscriptionId, subscription);\n        server.getSubscriptions().put(subscriptionId, subscription);\n        server.getDiagnosticsSummary().getCumulatedSubscriptionCount().increment();\n        server.getEventBus().post(new SubscriptionCreatedEvent(subscription));\n\n        subscription.setStateListener((s, ps, cs) -> {\n            if (cs == State.Closing) {\n                subscriptions.remove(s.getId());\n                server.getSubscriptions().remove(s.getId());\n                server.getEventBus().post(new SubscriptionDeletedEvent(s));\n\n                /*\n                 * Notify AddressSpaces the items for this subscription are deleted.\n                 */\n\n                Map<UInteger, BaseMonitoredItem<?>> monitoredItems = s.getMonitoredItems();\n\n                byMonitoredItemType(\n                    monitoredItems.values(),\n                    dataItems -> server.getAddressSpaceManager().onDataItemsDeleted(dataItems),\n                    eventItems -> server.getAddressSpaceManager().onEventItemsDeleted(eventItems)\n                );\n\n                server.getMonitoredItemCount().getAndUpdate(count -> count - monitoredItems.size());\n\n                monitoredItems.clear();\n            }\n        });\n\n        subscription.startPublishingTimer();\n\n        ResponseHeader header = service.createResponseHeader();\n\n        CreateSubscriptionResponse response = new CreateSubscriptionResponse(\n            header, subscriptionId,\n            subscription.getPublishingInterval(),\n            uint(subscription.getLifetimeCount()),\n            uint(subscription.getMaxKeepAliveCount())\n        );\n\n        service.setResponse(response);\n    }\n\n    public void modifySubscription(ServiceRequest service) throws UaException {\n        ModifySubscriptionRequest request = (ModifySubscriptionRequest) service.getRequest();\n\n        UInteger subscriptionId = request.getSubscriptionId();\n        Subscription subscription = subscriptions.get(subscriptionId);\n\n        if (subscription == null) {\n            throw new UaException(StatusCodes.Bad_SubscriptionIdInvalid);\n        }\n\n        subscription.modifySubscription(request);\n\n        ResponseHeader header = service.createResponseHeader();\n\n        ModifySubscriptionResponse response = new ModifySubscriptionResponse(\n            header,\n            subscription.getPublishingInterval(),\n            uint(subscription.getLifetimeCount()),\n            uint(subscription.getMaxKeepAliveCount())\n        );\n\n        service.setResponse(response);\n    }\n\n    public void deleteSubscription(ServiceRequest service) throws UaException {\n        DeleteSubscriptionsRequest request = (DeleteSubscriptionsRequest) service.getRequest();\n\n        List<UInteger> subscriptionIds = l(request.getSubscriptionIds());\n\n        if (subscriptionIds.isEmpty()) {\n            throw new UaException(StatusCodes.Bad_NothingToDo);\n        }\n\n        StatusCode[] results = new StatusCode[subscriptionIds.size()];\n\n        for (int i = 0; i < subscriptionIds.size(); i++) {\n            UInteger subscriptionId = subscriptionIds.get(i);\n            Subscription subscription = subscriptions.remove(subscriptionId);\n\n            if (subscription != null) {\n                server.getSubscriptions().remove(subscription.getId());\n                server.getEventBus().post(new SubscriptionDeletedEvent(subscription));\n\n                List<BaseMonitoredItem<?>> deletedItems = subscription.deleteSubscription();\n\n                /*\n                 * Notify AddressSpaces of the items we just deleted.\n                 */\n\n                byMonitoredItemType(\n                    deletedItems,\n                    dataItems -> server.getAddressSpaceManager().onDataItemsDeleted(dataItems),\n                    eventItems -> server.getAddressSpaceManager().onEventItemsDeleted(eventItems)\n                );\n\n                results[i] = StatusCode.GOOD;\n\n                server.getMonitoredItemCount().getAndUpdate(count -> count - deletedItems.size());\n            } else {\n                results[i] = new StatusCode(StatusCodes.Bad_SubscriptionIdInvalid);\n            }\n        }\n\n        ResponseHeader header = service.createResponseHeader();\n\n        DeleteSubscriptionsResponse response = new DeleteSubscriptionsResponse(\n            header,\n            results,\n            new DiagnosticInfo[0]\n        );\n\n        service.setResponse(response);\n\n        while (subscriptions.isEmpty() && publishQueue.isNotEmpty()) {\n            ServiceRequest publishService = publishQueue.poll();\n            if (publishService != null) {\n                publishService.setServiceFault(StatusCodes.Bad_NoSubscription);\n            }\n        }\n    }\n\n    public void setPublishingMode(ServiceRequest service) {\n        SetPublishingModeRequest request = (SetPublishingModeRequest) service.getRequest();\n        List<UInteger> subscriptionIds = l(request.getSubscriptionIds());\n\n        StatusCode[] results = new StatusCode[subscriptionIds.size()];\n\n        for (int i = 0; i < subscriptionIds.size(); i++) {\n            Subscription subscription = subscriptions.get(subscriptionIds.get(i));\n            if (subscription == null) {\n                results[i] = new StatusCode(StatusCodes.Bad_SubscriptionIdInvalid);\n            } else {\n                subscription.setPublishingMode(request);\n                results[i] = StatusCode.GOOD;\n            }\n        }\n\n        ResponseHeader header = service.createResponseHeader();\n\n        SetPublishingModeResponse response = new SetPublishingModeResponse(\n            header,\n            results,\n            new DiagnosticInfo[0]\n        );\n\n        service.setResponse(response);\n    }\n\n    public void createMonitoredItems(ServiceRequest service) throws UaException {\n        CreateMonitoredItemsRequest request = (CreateMonitoredItemsRequest) service.getRequest();\n\n        UInteger subscriptionId = request.getSubscriptionId();\n        Subscription subscription = subscriptions.get(subscriptionId);\n        TimestampsToReturn timestamps = request.getTimestampsToReturn();\n        List<MonitoredItemCreateRequest> itemsToCreate = l(request.getItemsToCreate());\n\n        if (subscription == null) {\n            throw new UaException(StatusCodes.Bad_SubscriptionIdInvalid);\n        }\n        if (timestamps == null) {\n            throw new UaException(StatusCodes.Bad_TimestampsToReturnInvalid);\n        }\n        if (itemsToCreate.isEmpty()) {\n            throw new UaException(StatusCodes.Bad_NothingToDo);\n        }\n\n        List<NodeId> distinctNodeIds = itemsToCreate.stream()\n            .map(item -> item.getItemToMonitor().getNodeId())\n            .distinct()\n            .collect(toList());\n\n        CompletableFuture<Map<NodeId, AttributeGroup>> attributesFuture = readMonitoringAttributes(distinctNodeIds);\n\n        attributesFuture.thenAccept(attributeGroups -> {\n            MonitoredItemCreateResult[] createResults = new MonitoredItemCreateResult[itemsToCreate.size()];\n\n            List<BaseMonitoredItem<?>> monitoredItems = new ArrayList<>();\n\n            for (int i = 0; i < itemsToCreate.size(); i++) {\n                MonitoredItemCreateRequest createRequest = itemsToCreate.get(i);\n\n                try {\n                    long maxMonitoredItems = server.getConfig().getLimits().getMaxMonitoredItems().longValue();\n\n                    if (server.getMonitoredItemCount().incrementAndGet() <= maxMonitoredItems) {\n                        BaseMonitoredItem<?> monitoredItem = createMonitoredItem(\n                            createRequest,\n                            subscription,\n                            timestamps,\n                            attributeGroups\n                        );\n\n                        monitoredItems.add(monitoredItem);\n\n                        createResults[i] = new MonitoredItemCreateResult(\n                            StatusCode.GOOD,\n                            monitoredItem.getId(),\n                            monitoredItem.getSamplingInterval(),\n                            uint(monitoredItem.getQueueSize()),\n                            monitoredItem.getFilterResult()\n                        );\n                    } else {\n                        throw new UaException(StatusCodes.Bad_TooManyMonitoredItems);\n                    }\n                } catch (UaException e) {\n                    server.getMonitoredItemCount().decrementAndGet();\n\n                    createResults[i] = new MonitoredItemCreateResult(\n                        e.getStatusCode(),\n                        UInteger.MIN,\n                        0.0,\n                        UInteger.MIN,\n                        null\n                    );\n                }\n            }\n\n            subscription.addMonitoredItems(monitoredItems);\n\n            // Notify AddressSpaces of the items we just created.\n\n            byMonitoredItemType(\n                monitoredItems,\n                dataItems -> server.getAddressSpaceManager().onDataItemsCreated(dataItems),\n                eventItems -> server.getAddressSpaceManager().onEventItemsCreated(eventItems)\n            );\n\n            ResponseHeader header = service.createResponseHeader();\n\n            CreateMonitoredItemsResponse response = new CreateMonitoredItemsResponse(\n                header,\n                createResults,\n                new DiagnosticInfo[0]\n            );\n\n            service.setResponse(response);\n        });\n    }\n\n    private BaseMonitoredItem<?> createMonitoredItem(\n        MonitoredItemCreateRequest request,\n        Subscription subscription,\n        TimestampsToReturn timestamps,\n        Map<NodeId, AttributeGroup> attributeGroups\n    ) throws UaException {\n\n        NodeId nodeId = request.getItemToMonitor().getNodeId();\n        UInteger attributeId = request.getItemToMonitor().getAttributeId();\n        QualifiedName dataEncoding = request.getItemToMonitor().getDataEncoding();\n\n        if (!AttributeId.isValid(attributeId)) {\n            throw new UaException(StatusCodes.Bad_AttributeIdInvalid);\n        }\n\n        if (dataEncoding.isNotNull()) {\n            if (!AttributeId.Value.isEqual(attributeId)) {\n                throw new UaException(StatusCodes.Bad_DataEncodingInvalid);\n            }\n\n            if (!dataEncoding.equals(DEFAULT_BINARY_ENCODING) &&\n                !dataEncoding.equals(DEFAULT_XML_ENCODING)) {\n\n                throw new UaException(StatusCodes.Bad_DataEncodingUnsupported);\n            }\n        }\n\n        AttributeGroup attributeGroup = attributeGroups.get(nodeId);\n\n        if (attributeId.equals(AttributeId.EventNotifier.uid())) {\n            UByte eventNotifier = attributeGroup.getEventNotifier();\n\n            // Verify that the SubscribeToEvents bit is set\n            if (eventNotifier == null || (eventNotifier.intValue() & 1) == 0) {\n                throw new UaException(StatusCodes.Bad_AttributeIdInvalid);\n            }\n\n            Object filterObject = request.getRequestedParameters()\n                .getFilter()\n                .decode(server.getSerializationContext());\n\n            MonitoringFilter filter = validateEventItemFilter(filterObject, attributeGroup);\n\n            UInteger requestedQueueSize = request.getRequestedParameters().getQueueSize();\n            AtomicReference<UInteger> revisedQueueSize = new AtomicReference<>(requestedQueueSize);\n\n            try {\n                server.getAddressSpaceManager().onCreateEventItem(\n                    request.getItemToMonitor(),\n                    requestedQueueSize,\n                    revisedQueueSize::set\n                );\n            } catch (Throwable t) {\n                throw new UaException(StatusCodes.Bad_InternalError, t);\n            }\n\n            MonitoredEventItem monitoredEventItem = new MonitoredEventItem(\n                server,\n                session,\n                uint(subscription.nextItemId()),\n                subscription.getId(),\n                request.getItemToMonitor(),\n                request.getMonitoringMode(),\n                timestamps,\n                request.getRequestedParameters().getClientHandle(),\n                0.0,\n                revisedQueueSize.get(),\n                request.getRequestedParameters().getDiscardOldest()\n            );\n\n            monitoredEventItem.installFilter(filter);\n\n            return monitoredEventItem;\n        } else {\n            if (attributeId.equals(AttributeId.Value.uid())) {\n                UByte accessLevel = attributeGroup.getAccessLevel();\n                if (accessLevel == null) accessLevel = ubyte(0);\n\n                UByte userAccessLevel = attributeGroup.getUserAccessLevel();\n                if (userAccessLevel == null) userAccessLevel = ubyte(0);\n\n                EnumSet<AccessLevel> accessLevels = AccessLevel.fromValue(accessLevel);\n                EnumSet<AccessLevel> userAccessLevels = AccessLevel.fromValue(userAccessLevel);\n\n                if (!accessLevels.contains(AccessLevel.CurrentRead)) {\n                    throw new UaException(StatusCodes.Bad_NotReadable);\n                }\n                if (!userAccessLevels.contains(AccessLevel.CurrentRead)) {\n                    throw new UaException(StatusCodes.Bad_UserAccessDenied);\n                }\n            }\n\n            // Validate the requested index range by parsing it.\n            String indexRange = request.getItemToMonitor().getIndexRange();\n            if (indexRange != null) NumericRange.parse(indexRange);\n\n            Double minimumSamplingInterval = -1.0;\n            try {\n                minimumSamplingInterval = attributeGroup.getMinimumSamplingInterval();\n                if (minimumSamplingInterval == null) {\n                    minimumSamplingInterval = server.getConfig().getLimits().getMinSupportedSampleRate();\n                }\n            } catch (UaException e) {\n                if (e.getStatusCode().getValue() != StatusCodes.Bad_AttributeIdInvalid) {\n                    throw e;\n                }\n            }\n\n            MonitoringFilter filter = MonitoredDataItem.DEFAULT_FILTER;\n\n            try {\n                ExtensionObject filterXo = request.getRequestedParameters().getFilter();\n\n                if (filterXo != null && !filterXo.isNull()) {\n                    Object filterObject = filterXo\n                        .decode(server.getSerializationContext());\n\n                    filter = validateDataItemFilter(filterObject, attributeId, attributeGroup);\n                }\n            } catch (UaSerializationException e) {\n                logger.debug(\"error decoding MonitoringFilter\", e);\n\n                throw new UaException(StatusCodes.Bad_MonitoredItemFilterInvalid, e);\n            }\n\n            double requestedSamplingInterval = getSamplingInterval(\n                subscription,\n                minimumSamplingInterval,\n                request.getRequestedParameters().getSamplingInterval()\n            );\n\n            UInteger requestedQueueSize = request.getRequestedParameters().getQueueSize();\n\n            AtomicReference<Double> revisedSamplingInterval = new AtomicReference<>(requestedSamplingInterval);\n            AtomicReference<UInteger> revisedQueueSize = new AtomicReference<>(requestedQueueSize);\n\n            try {\n                server.getAddressSpaceManager().onCreateDataItem(\n                    request.getItemToMonitor(),\n                    requestedSamplingInterval,\n                    requestedQueueSize,\n                    (rsi, rqs) -> {\n                        revisedSamplingInterval.set(rsi);\n                        revisedQueueSize.set(rqs);\n                    }\n                );\n            } catch (Throwable t) {\n                throw new UaException(StatusCodes.Bad_InternalError, t);\n            }\n\n            MonitoredDataItem monitoredDataItem = new MonitoredDataItem(\n                server,\n                session,\n                uint(subscription.nextItemId()),\n                subscription.getId(),\n                request.getItemToMonitor(),\n                request.getMonitoringMode(),\n                timestamps,\n                request.getRequestedParameters().getClientHandle(),\n                revisedSamplingInterval.get(),\n                revisedQueueSize.get(),\n                request.getRequestedParameters().getDiscardOldest()\n            );\n\n            monitoredDataItem.installFilter(filter);\n\n            return monitoredDataItem;\n        }\n    }\n\n    private MonitoringFilter validateDataItemFilter(\n        Object filterObject,\n        UInteger attributeId,\n        AttributeGroup attributeGroup\n    ) throws UaException {\n\n        if (filterObject instanceof MonitoringFilter) {\n            if (filterObject instanceof DataChangeFilter) {\n                DataChangeFilter filter = (DataChangeFilter) filterObject;\n\n                DeadbandType deadbandType = DeadbandType.from(filter.getDeadbandType().intValue());\n\n                if (deadbandType == null) {\n                    throw new UaException(StatusCodes.Bad_DeadbandFilterInvalid);\n                }\n\n                if (deadbandType == DeadbandType.Percent) {\n                    // Percent deadband is not currently implemented\n                    throw new UaException(StatusCodes.Bad_MonitoredItemFilterUnsupported);\n                }\n\n                if (deadbandType == DeadbandType.Absolute &&\n                    !AttributeId.Value.isEqual(attributeId)) {\n\n                    // Absolute deadband is only allowed for Value attributes\n                    throw new UaException(StatusCodes.Bad_FilterNotAllowed);\n                }\n\n                if (deadbandType != DeadbandType.None) {\n                    NodeId dataTypeId = null;\n                    try {\n                        dataTypeId = attributeGroup.getDataType();\n                    } catch (UaException ignored) {\n                        // noop\n                    }\n                    if (dataTypeId == null) {\n                        dataTypeId = NodeId.NULL_VALUE;\n                    }\n\n                    if (!Identifiers.Number.equals(dataTypeId) && !subtypeOf(server, dataTypeId, Identifiers.Number)) {\n                        throw new UaException(StatusCodes.Bad_FilterNotAllowed);\n                    }\n                }\n\n                return filter;\n            } else if (filterObject instanceof EventFilter) {\n                throw new UaException(StatusCodes.Bad_FilterNotAllowed);\n            } else {\n                // AggregateFilter or some future unimplemented filter\n                throw new UaException(StatusCodes.Bad_MonitoredItemFilterUnsupported);\n            }\n        } else {\n            throw new UaException(StatusCodes.Bad_MonitoredItemFilterInvalid);\n        }\n    }\n\n    private MonitoringFilter validateEventItemFilter(\n        Object filterObject,\n        AttributeGroup attributeGroup\n    ) throws UaException {\n\n        if (filterObject instanceof MonitoringFilter) {\n            if (!(filterObject instanceof EventFilter)) {\n                throw new UaException(StatusCodes.Bad_FilterNotAllowed);\n            }\n            return (EventFilter) filterObject;\n        } else {\n            throw new UaException(StatusCodes.Bad_MonitoredItemFilterInvalid);\n        }\n    }\n\n    public void modifyMonitoredItems(ServiceRequest service) throws UaException {\n        ModifyMonitoredItemsRequest request = (ModifyMonitoredItemsRequest) service.getRequest();\n\n        UInteger subscriptionId = request.getSubscriptionId();\n        Subscription subscription = subscriptions.get(subscriptionId);\n        TimestampsToReturn timestamps = request.getTimestampsToReturn();\n        List<MonitoredItemModifyRequest> itemsToModify = l(request.getItemsToModify());\n\n        if (subscription == null) {\n            throw new UaException(StatusCodes.Bad_SubscriptionIdInvalid);\n        }\n        if (timestamps == null) {\n            throw new UaException(StatusCodes.Bad_TimestampsToReturnInvalid);\n        }\n        if (itemsToModify.isEmpty()) {\n            throw new UaException(StatusCodes.Bad_NothingToDo);\n        }\n\n        List<NodeId> distinctNodeIds = itemsToModify.stream()\n            .map(item -> {\n                UInteger itemId = item.getMonitoredItemId();\n                BaseMonitoredItem<?> monitoredItem = subscription.getMonitoredItems().get(itemId);\n                return monitoredItem != null ? monitoredItem.getReadValueId().getNodeId() : NodeId.NULL_VALUE;\n            })\n            .filter(NodeId::isNotNull)\n            .distinct()\n            .collect(toList());\n\n        CompletableFuture<Map<NodeId, AttributeGroup>> attributesFuture = readMonitoringAttributes(distinctNodeIds);\n\n        attributesFuture.thenAccept(attributeGroups -> {\n            MonitoredItemModifyResult[] modifyResults = new MonitoredItemModifyResult[itemsToModify.size()];\n\n            List<BaseMonitoredItem<?>> monitoredItems = new ArrayList<>();\n\n            for (int i = 0; i < itemsToModify.size(); i++) {\n                MonitoredItemModifyRequest modifyRequest = itemsToModify.get(i);\n\n                try {\n                    BaseMonitoredItem<?> monitoredItem = modifyMonitoredItem(\n                        modifyRequest,\n                        timestamps,\n                        subscription,\n                        attributeGroups\n                    );\n\n                    monitoredItems.add(monitoredItem);\n\n                    modifyResults[i] = new MonitoredItemModifyResult(\n                        StatusCode.GOOD,\n                        monitoredItem.getSamplingInterval(),\n                        uint(monitoredItem.getQueueSize()),\n                        monitoredItem.getFilterResult()\n                    );\n                } catch (UaException e) {\n                    modifyResults[i] = new MonitoredItemModifyResult(\n                        e.getStatusCode(),\n                        0.0,\n                        UInteger.MIN,\n                        null\n                    );\n                }\n            }\n\n            subscription.resetLifetimeCounter();\n\n            /*\n             * Notify AddressSpaces of the items we just modified.\n             */\n\n            byMonitoredItemType(\n                monitoredItems,\n                dataItems -> server.getAddressSpaceManager().onDataItemsModified(dataItems),\n                eventItems -> server.getAddressSpaceManager().onEventItemsModified(eventItems)\n            );\n\n            /*\n             * AddressSpaces have been notified; send response.\n             */\n\n            ResponseHeader header = service.createResponseHeader();\n\n            ModifyMonitoredItemsResponse response = new ModifyMonitoredItemsResponse(\n                header,\n                modifyResults,\n                new DiagnosticInfo[0]\n            );\n\n            service.setResponse(response);\n        });\n    }\n\n    private BaseMonitoredItem<?> modifyMonitoredItem(\n        MonitoredItemModifyRequest request,\n        TimestampsToReturn timestamps,\n        Subscription subscription,\n        Map<NodeId, AttributeGroup> attributeGroups\n    ) throws UaException {\n\n        UInteger itemId = request.getMonitoredItemId();\n        MonitoringParameters parameters = request.getRequestedParameters();\n\n        BaseMonitoredItem<?> monitoredItem = subscription.getMonitoredItems().get(itemId);\n\n        if (monitoredItem == null) {\n            throw new UaException(StatusCodes.Bad_MonitoredItemIdInvalid);\n        }\n\n        NodeId nodeId = monitoredItem.getReadValueId().getNodeId();\n        UInteger attributeId = monitoredItem.getReadValueId().getAttributeId();\n        AttributeGroup attributeGroup = attributeGroups.get(nodeId);\n\n        if (attributeId.equals(AttributeId.EventNotifier.uid())) {\n            Object filterObject = request.getRequestedParameters()\n                .getFilter()\n                .decode(server.getSerializationContext());\n\n            MonitoringFilter filter = validateEventItemFilter(filterObject, attributeGroup);\n\n            UInteger requestedQueueSize = parameters.getQueueSize();\n            AtomicReference<UInteger> revisedQueueSize = new AtomicReference<>(requestedQueueSize);\n\n            try {\n                server.getAddressSpaceManager().onModifyEventItem(\n                    monitoredItem.getReadValueId(),\n                    requestedQueueSize,\n                    revisedQueueSize::set\n                );\n            } catch (Throwable t) {\n                throw new UaException(StatusCodes.Bad_InternalError, t);\n            }\n\n            monitoredItem.modify(\n                timestamps,\n                parameters.getClientHandle(),\n                monitoredItem.getSamplingInterval(),\n                filter,\n                revisedQueueSize.get(),\n                parameters.getDiscardOldest()\n            );\n        } else {\n            MonitoringFilter filter = MonitoredDataItem.DEFAULT_FILTER;\n\n            try {\n                ExtensionObject filterXo = request.getRequestedParameters().getFilter();\n\n                if (filterXo != null && !filterXo.isNull()) {\n                    Object filterObject = filterXo\n                        .decode(server.getSerializationContext());\n\n                    filter = validateDataItemFilter(filterObject, attributeId, attributeGroup);\n                }\n            } catch (UaSerializationException e) {\n                logger.debug(\"error decoding MonitoringFilter\", e);\n\n                throw new UaException(StatusCodes.Bad_MonitoredItemFilterInvalid, e);\n            }\n\n            Double minimumSamplingInterval = -1.0;\n            try {\n                minimumSamplingInterval = attributeGroup.getMinimumSamplingInterval();\n                if (minimumSamplingInterval == null) {\n                    minimumSamplingInterval = server.getConfig().getLimits().getMinSupportedSampleRate();\n                }\n            } catch (UaException e) {\n                long statusCodeValue = e.getStatusCode().getValue();\n\n                if (statusCodeValue != StatusCodes.Bad_AttributeIdInvalid &&\n                    statusCodeValue != StatusCodes.Bad_NodeIdUnknown) {\n\n                    throw e;\n                }\n            }\n\n            double requestedSamplingInterval = getSamplingInterval(\n                subscription,\n                minimumSamplingInterval,\n                request.getRequestedParameters().getSamplingInterval()\n            );\n\n            UInteger requestedQueueSize = parameters.getQueueSize();\n\n            AtomicReference<Double> revisedSamplingInterval = new AtomicReference<>(requestedSamplingInterval);\n            AtomicReference<UInteger> revisedQueueSize = new AtomicReference<>(requestedQueueSize);\n\n            try {\n                server.getAddressSpaceManager().onModifyDataItem(\n                    monitoredItem.getReadValueId(),\n                    requestedSamplingInterval,\n                    requestedQueueSize,\n                    (rsi, rqs) -> {\n                        revisedSamplingInterval.set(rsi);\n                        revisedQueueSize.set(rqs);\n                    }\n                );\n            } catch (Throwable t) {\n                throw new UaException(StatusCodes.Bad_InternalError, t);\n            }\n\n            monitoredItem.modify(\n                timestamps,\n                parameters.getClientHandle(),\n                revisedSamplingInterval.get(),\n                filter,\n                revisedQueueSize.get(),\n                parameters.getDiscardOldest()\n            );\n        }\n\n        return monitoredItem;\n    }\n\n    private double getSamplingInterval(\n        Subscription subscription,\n        Double minimumSamplingInterval,\n        Double requestedSamplingInterval\n    ) {\n\n        double samplingInterval = requestedSamplingInterval;\n\n        if (requestedSamplingInterval < 0) {\n            samplingInterval = subscription.getPublishingInterval();\n        } else if (requestedSamplingInterval == 0) {\n            if (minimumSamplingInterval < 0) {\n                // Node has no opinion on sampling interval (indeterminate)\n                samplingInterval = subscription.getPublishingInterval();\n            } else if (minimumSamplingInterval == 0) {\n                // Node allows report-by-exception\n                samplingInterval = minimumSamplingInterval;\n            } else if (minimumSamplingInterval > 0) {\n                // Node has a defined minimum sampling interval, use that\n                // because requested rate of 0 means \"fastest practical rate\"\n                samplingInterval = minimumSamplingInterval;\n            }\n        } else {\n            if (requestedSamplingInterval < minimumSamplingInterval) {\n                samplingInterval = minimumSamplingInterval;\n            }\n        }\n\n        double minSupportedSampleRate = server.getConfig().getLimits().getMinSupportedSampleRate();\n        double maxSupportedSampleRate = server.getConfig().getLimits().getMaxSupportedSampleRate();\n\n        if (samplingInterval < minSupportedSampleRate) {\n            samplingInterval = minSupportedSampleRate;\n        }\n        if (samplingInterval > maxSupportedSampleRate) {\n            samplingInterval = maxSupportedSampleRate;\n        }\n\n        return samplingInterval;\n    }\n\n    private CompletableFuture<Map<NodeId, AttributeGroup>> readMonitoringAttributes(List<NodeId> nodeIds) {\n        List<ReadValueId> attributesToRead = nodeIds.stream()\n            .flatMap(nodeId -> {\n                Function<AttributeId, ReadValueId> f = id -> new ReadValueId(\n                    nodeId,\n                    id.uid(),\n                    null,\n                    QualifiedName.NULL_VALUE\n                );\n\n                return Stream.of(\n                    f.apply(AttributeId.AccessLevel),\n                    f.apply(AttributeId.UserAccessLevel),\n                    f.apply(AttributeId.EventNotifier),\n                    f.apply(AttributeId.MinimumSamplingInterval),\n                    f.apply(AttributeId.DataType)\n                );\n            })\n            .collect(toList());\n\n        ReadContext context = new ReadContext(server, session);\n\n        server.getAddressSpaceManager().read(\n            context,\n            0.0,\n            TimestampsToReturn.Neither,\n            attributesToRead\n        );\n\n        return context.getFuture().thenApply(attributeValues -> {\n            Map<NodeId, AttributeGroup> monitoringAttributes = new HashMap<>();\n\n            for (int nodeIdx = 0, attrIdx = 0; nodeIdx < nodeIds.size(); nodeIdx++, attrIdx += 5) {\n                monitoringAttributes.put(nodeIds.get(nodeIdx), new AttributeGroup(\n                    attributeValues.get(attrIdx),\n                    attributeValues.get(attrIdx + 1),\n                    attributeValues.get(attrIdx + 2),\n                    attributeValues.get(attrIdx + 3),\n                    attributeValues.get(attrIdx + 4)\n                ));\n            }\n\n            return monitoringAttributes;\n        });\n    }\n\n\n    public void deleteMonitoredItems(ServiceRequest service) throws UaException {\n        DeleteMonitoredItemsRequest request = (DeleteMonitoredItemsRequest) service.getRequest();\n\n        UInteger subscriptionId = request.getSubscriptionId();\n        Subscription subscription = subscriptions.get(subscriptionId);\n        List<UInteger> itemsToDelete = l(request.getMonitoredItemIds());\n\n        if (subscription == null) {\n            throw new UaException(StatusCodes.Bad_SubscriptionIdInvalid);\n        }\n        if (itemsToDelete.isEmpty()) {\n            throw new UaException(StatusCodes.Bad_NothingToDo);\n        }\n\n        StatusCode[] deleteResults = new StatusCode[itemsToDelete.size()];\n        List<BaseMonitoredItem<?>> deletedItems = newArrayListWithCapacity(itemsToDelete.size());\n\n        synchronized (subscription) {\n            for (int i = 0; i < itemsToDelete.size(); i++) {\n                UInteger itemId = itemsToDelete.get(i);\n                BaseMonitoredItem<?> item = subscription.getMonitoredItems().get(itemId);\n\n                if (item == null) {\n                    deleteResults[i] = new StatusCode(StatusCodes.Bad_MonitoredItemIdInvalid);\n                } else {\n                    deletedItems.add(item);\n\n                    deleteResults[i] = StatusCode.GOOD;\n\n                    server.getMonitoredItemCount().decrementAndGet();\n                }\n            }\n\n            subscription.removeMonitoredItems(deletedItems);\n        }\n\n        /*\n         * Notify AddressSpaces of the items that have been deleted.\n         */\n\n        byMonitoredItemType(\n            deletedItems,\n            dataItems -> server.getAddressSpaceManager().onDataItemsDeleted(dataItems),\n            eventItems -> server.getAddressSpaceManager().onEventItemsDeleted(eventItems)\n        );\n\n        /*\n         * Build and return results.\n         */\n        ResponseHeader header = service.createResponseHeader();\n\n        DeleteMonitoredItemsResponse response = new DeleteMonitoredItemsResponse(\n            header,\n            deleteResults,\n            new DiagnosticInfo[0]\n        );\n\n        service.setResponse(response);\n    }\n\n    public void setMonitoringMode(ServiceRequest service) {\n        SetMonitoringModeRequest request = (SetMonitoringModeRequest) service.getRequest();\n        UInteger subscriptionId = request.getSubscriptionId();\n\n        try {\n            Subscription subscription = subscriptions.get(subscriptionId);\n            List<UInteger> itemsToModify = l(request.getMonitoredItemIds());\n\n            if (subscription == null) {\n                throw new UaException(StatusCodes.Bad_SubscriptionIdInvalid);\n            }\n            if (itemsToModify.isEmpty()) {\n                throw new UaException(StatusCodes.Bad_NothingToDo);\n            }\n\n            /*\n             * Set MonitoringMode on each monitored item, if it exists.\n             */\n\n            MonitoringMode monitoringMode = request.getMonitoringMode();\n            StatusCode[] results = new StatusCode[itemsToModify.size()];\n            List<MonitoredItem> modified = newArrayListWithCapacity(itemsToModify.size());\n\n            for (int i = 0; i < itemsToModify.size(); i++) {\n                UInteger itemId = itemsToModify.get(i);\n                BaseMonitoredItem<?> item = subscription.getMonitoredItems().get(itemId);\n\n                if (item != null) {\n                    item.setMonitoringMode(monitoringMode);\n\n                    modified.add(item);\n\n                    results[i] = StatusCode.GOOD;\n                } else {\n                    results[i] = new StatusCode(StatusCodes.Bad_MonitoredItemIdInvalid);\n                }\n            }\n\n            /*\n             * Notify AddressSpace of the items whose MonitoringMode has been modified.\n             */\n\n            server.getAddressSpaceManager().onMonitoringModeChanged(modified);\n\n            /*\n             * Build and return results.\n             */\n\n            ResponseHeader header = service.createResponseHeader();\n            SetMonitoringModeResponse response = new SetMonitoringModeResponse(\n                header,\n                results,\n                new DiagnosticInfo[0]\n            );\n\n            service.setResponse(response);\n        } catch (UaException e) {\n            service.setServiceFault(e);\n        }\n    }\n\n    public void publish(ServiceRequest service) {\n        PublishRequest request = (PublishRequest) service.getRequest();\n\n        SubscriptionAcknowledgement[] acknowledgements = request.getSubscriptionAcknowledgements();\n\n        if (acknowledgements != null) {\n            StatusCode[] results = new StatusCode[acknowledgements.length];\n\n            for (int i = 0; i < acknowledgements.length; i++) {\n                SubscriptionAcknowledgement acknowledgement = acknowledgements[i];\n\n                UInteger sequenceNumber = acknowledgement.getSequenceNumber();\n                UInteger subscriptionId = acknowledgement.getSubscriptionId();\n\n                Subscription subscription = subscriptions.get(subscriptionId);\n\n                if (subscription == null) {\n                    logger.debug(\n                        \"Can't acknowledge sequenceNumber={} on subscriptionId={}; id not valid for this session\",\n                        sequenceNumber,\n                        subscriptionId\n                    );\n                    results[i] = new StatusCode(StatusCodes.Bad_SubscriptionIdInvalid);\n                } else {\n                    logger.debug(\"Acknowledging sequenceNumber={} on subscriptionId={}\",\n                        sequenceNumber,\n                        subscriptionId\n                    );\n                    results[i] = subscription.acknowledge(sequenceNumber);\n                }\n            }\n\n            service.attr(KEY_ACK_RESULTS).set(results);\n        }\n\n        if (!transferred.isEmpty()) {\n            Subscription subscription = transferred.remove(0);\n            subscription.returnStatusChangeNotification(\n                service,\n                new StatusCode(StatusCodes.Good_SubscriptionTransferred)\n            );\n            return;\n        }\n\n        // waitList must also be empty because the last remaining subscription could have\n        // expired, which removes it from bookkeeping, but leaves it in the PublishQueue\n        // waitList if there were no available requests to send Bad_Timeout.\n        if (subscriptions.isEmpty() && publishQueue.isWaitListEmpty()) {\n            service.setServiceFault(StatusCodes.Bad_NoSubscription);\n            return;\n        }\n\n        publishQueue.addRequest(service);\n    }\n\n    public void republish(ServiceRequest service) {\n        RepublishRequest request = (RepublishRequest) service.getRequest();\n\n        if (subscriptions.isEmpty()) {\n            service.setServiceFault(StatusCodes.Bad_SubscriptionIdInvalid);\n            return;\n        }\n\n        UInteger subscriptionId = request.getSubscriptionId();\n        Subscription subscription = subscriptions.get(subscriptionId);\n\n        if (subscription == null) {\n            service.setServiceFault(StatusCodes.Bad_SubscriptionIdInvalid);\n            return;\n        }\n\n        UInteger sequenceNumber = request.getRetransmitSequenceNumber();\n        NotificationMessage notificationMessage = subscription.republish(sequenceNumber);\n\n        if (notificationMessage == null) {\n            service.setServiceFault(StatusCodes.Bad_MessageNotAvailable);\n            return;\n        }\n\n        ResponseHeader header = service.createResponseHeader();\n        RepublishResponse response = new RepublishResponse(header, notificationMessage);\n\n        service.setResponse(response);\n    }\n\n    public void setTriggering(ServiceRequest service) {\n        SetTriggeringRequest request = (SetTriggeringRequest) service.getRequest();\n\n        UInteger subscriptionId = request.getSubscriptionId();\n        Subscription subscription = subscriptions.get(subscriptionId);\n\n        if (subscription == null) {\n            service.setServiceFault(StatusCodes.Bad_SubscriptionIdInvalid);\n            return;\n        }\n\n        UInteger triggerId = request.getTriggeringItemId();\n        List<UInteger> linksToAdd = l(request.getLinksToAdd());\n        List<UInteger> linksToRemove = l(request.getLinksToRemove());\n\n        if (linksToAdd.isEmpty() && linksToRemove.isEmpty()) {\n            service.setServiceFault(StatusCodes.Bad_NothingToDo);\n            return;\n        }\n\n        StatusCode[] addResults;\n        StatusCode[] removeResults;\n\n        synchronized (subscription) {\n            Map<UInteger, BaseMonitoredItem<?>> itemsById = subscription.getMonitoredItems();\n\n            BaseMonitoredItem<?> triggerItem = itemsById.get(triggerId);\n            if (triggerItem == null) {\n                service.setServiceFault(StatusCodes.Bad_MonitoredItemIdInvalid);\n                return;\n            }\n\n            removeResults = linksToRemove.stream()\n                .map(linkedItemId -> {\n                    BaseMonitoredItem<?> item = itemsById.get(linkedItemId);\n                    if (item != null) {\n                        if (triggerItem.getTriggeredItems().remove(linkedItemId) != null) {\n                            return StatusCode.GOOD;\n                        } else {\n                            return new StatusCode(StatusCodes.Bad_MonitoredItemIdInvalid);\n                        }\n                    } else {\n                        return new StatusCode(StatusCodes.Bad_MonitoredItemIdInvalid);\n                    }\n                })\n                .toArray(StatusCode[]::new);\n\n            addResults = linksToAdd.stream()\n                .map(linkedItemId -> {\n                    BaseMonitoredItem<?> linkedItem = itemsById.get(linkedItemId);\n                    if (linkedItem != null) {\n                        triggerItem.getTriggeredItems().put(linkedItemId, linkedItem);\n                        return StatusCode.GOOD;\n                    } else {\n                        return new StatusCode(StatusCodes.Bad_MonitoredItemIdInvalid);\n                    }\n                })\n                .toArray(StatusCode[]::new);\n        }\n\n        SetTriggeringResponse response = new SetTriggeringResponse(\n            service.createResponseHeader(),\n            addResults,\n            new DiagnosticInfo[0],\n            removeResults,\n            new DiagnosticInfo[0]\n        );\n\n        service.setResponse(response);\n    }\n\n    public void sessionClosed(boolean deleteSubscriptions) {\n        Iterator<Subscription> iterator = subscriptions.values().iterator();\n\n        while (iterator.hasNext()) {\n            Subscription s = iterator.next();\n            s.setStateListener(null);\n\n            if (deleteSubscriptions) {\n                server.getSubscriptions().remove(s.getId());\n                server.getEventBus().post(new SubscriptionDeletedEvent(s));\n\n                List<BaseMonitoredItem<?>> deletedItems = s.deleteSubscription();\n\n                /*\n                 * Notify AddressSpaces the items for this subscription are deleted.\n                 */\n\n                byMonitoredItemType(\n                    deletedItems,\n                    dataItems -> server.getAddressSpaceManager().onDataItemsDeleted(dataItems),\n                    eventItems -> server.getAddressSpaceManager().onEventItemsDeleted(eventItems)\n                );\n\n                server.getMonitoredItemCount().getAndUpdate(count -> count - deletedItems.size());\n            }\n\n            iterator.remove();\n        }\n\n        if (deleteSubscriptions) {\n            while (publishQueue.isNotEmpty()) {\n                ServiceRequest publishService = publishQueue.poll();\n                if (publishService != null) {\n                    publishService.setServiceFault(StatusCodes.Bad_SessionClosed);\n                }\n            }\n        }\n    }\n\n    /**\n     * Add (transfer) {@code subscription} to this {@link SubscriptionManager}.\n     *\n     * @param subscription the {@link Subscription} to add.\n     */\n    public void addSubscription(Subscription subscription) {\n        subscriptions.put(subscription.getId(), subscription);\n        server.getEventBus().post(new SubscriptionCreatedEvent(subscription));\n\n        subscription.setStateListener((s, ps, cs) -> {\n            if (cs == State.Closing) {\n                subscriptions.remove(s.getId());\n                server.getSubscriptions().remove(s.getId());\n                server.getEventBus().post(new SubscriptionDeletedEvent(s));\n\n                /*\n                 * Notify AddressSpaces the items for this subscription are deleted.\n                 */\n\n                Map<UInteger, BaseMonitoredItem<?>> monitoredItems = s.getMonitoredItems();\n\n                byMonitoredItemType(\n                    monitoredItems.values(),\n                    dataItems -> server.getAddressSpaceManager().onDataItemsDeleted(dataItems),\n                    eventItems -> server.getAddressSpaceManager().onEventItemsDeleted(eventItems)\n                );\n\n                server.getMonitoredItemCount().getAndUpdate(count -> count - monitoredItems.size());\n\n                monitoredItems.clear();\n            }\n        });\n    }\n\n    /**\n     * Remove (transfer from) the Subscription by {@code subscriptionId} from this {@link SubscriptionManager}.\n     *\n     * @param subscriptionId the id of the {@link Subscription} to remove.\n     * @return the removed {@link Subscription}.\n     */\n    public Subscription removeSubscription(UInteger subscriptionId) {\n        Subscription subscription = subscriptions.remove(subscriptionId);\n        server.getEventBus().post(new SubscriptionDeletedEvent(subscription));\n\n        if (subscription != null) {\n            subscription.setStateListener(null);\n        }\n\n        return subscription;\n    }\n\n    public void sendStatusChangeNotification(Subscription subscription, StatusCode status) {\n        ServiceRequest service = publishQueue.poll();\n\n        if (service != null) {\n            subscription.returnStatusChangeNotification(service, status);\n        } else {\n            transferred.add(subscription);\n        }\n    }\n\n    /**\n     * Split {@code monitoredItems} into a list of {@link DataItem}s and a list of {@link EventItem}s and invoke the\n     * corresponding {@link Consumer} for each list if non-empty.\n     *\n     * @param monitoredItems    the list of MonitoredItems to group.\n     * @param dataItemConsumer  a {@link Consumer} that accepts a non-empty list of {@link DataItem}s.\n     * @param eventItemConsumer a {@link Consumer} that accepts a non-empty list of {@link EventItem}s.\n     */\n    private static void byMonitoredItemType(\n        Collection<BaseMonitoredItem<?>> monitoredItems,\n        Consumer<List<DataItem>> dataItemConsumer,\n        Consumer<List<EventItem>> eventItemConsumer\n    ) {\n\n        List<DataItem> dataItems = Lists.newArrayList();\n        List<EventItem> eventItems = Lists.newArrayList();\n\n        for (BaseMonitoredItem<?> item : monitoredItems) {\n            if (item instanceof MonitoredDataItem) {\n                dataItems.add((DataItem) item);\n            } else if (item instanceof MonitoredEventItem) {\n                eventItems.add((EventItem) item);\n            }\n        }\n\n        try {\n            if (!dataItems.isEmpty()) {\n                dataItemConsumer.accept(dataItems);\n            }\n        } catch (Throwable t) {\n            LoggerFactory.getLogger(SubscriptionManager.class)\n                .error(\"Uncaught Throwable in dataItemConsumer\", t);\n        }\n\n        try {\n            if (!eventItems.isEmpty()) {\n                eventItemConsumer.accept(eventItems);\n            }\n        } catch (Throwable t) {\n            LoggerFactory.getLogger(SubscriptionManager.class)\n                .error(\"Uncaught Throwable in eventItemConsumer\", t);\n        }\n    }\n\n    /**\n     * @return {@code true} if {@code dataTypeId} is a subtype of {@code potentialSuperTypeId}.\n     */\n    private static boolean subtypeOf(OpcUaServer server, NodeId dataTypeId, NodeId potentialSuperTypeId) {\n        UaNode dataTypeNode = server.getAddressSpaceManager()\n            .getManagedNode(dataTypeId)\n            .orElse(null);\n\n        if (dataTypeNode != null) {\n            NodeId superTypeId = getSuperTypeId(server, dataTypeId);\n\n            if (superTypeId != null) {\n                return superTypeId.equals(potentialSuperTypeId) ||\n                    subtypeOf(server, superTypeId, potentialSuperTypeId);\n            } else {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    }\n\n    @Nullable\n    private static NodeId getSuperTypeId(OpcUaServer server, NodeId dataTypeId) {\n        UaNode dataTypeNode = server.getAddressSpaceManager()\n            .getManagedNode(dataTypeId)\n            .orElse(null);\n\n        if (dataTypeNode != null) {\n            return dataTypeNode.getReferences()\n                .stream()\n                .filter(Reference.SUBTYPE_OF)\n                .flatMap(r -> opt2stream(r.getTargetNodeId().toNodeId(server.getNamespaceTable())))\n                .findFirst()\n                .orElse(null);\n        } else {\n            return null;\n        }\n    }\n\n    private static class AttributeGroup {\n        final DataValue accessLevelValue;\n        final DataValue userAccessLevelValue;\n        final DataValue eventNotifierValue;\n        final DataValue minimumSamplingIntervalValue;\n        final DataValue dataType;\n\n        AttributeGroup(\n            DataValue accessLevelValue,\n            DataValue userAccessLevelValue,\n            DataValue eventNotifierValue,\n            DataValue minimumSamplingIntervalValue,\n            DataValue dataType\n        ) {\n\n            this.accessLevelValue = accessLevelValue;\n            this.userAccessLevelValue = userAccessLevelValue;\n            this.eventNotifierValue = eventNotifierValue;\n            this.minimumSamplingIntervalValue = minimumSamplingIntervalValue;\n            this.dataType = dataType;\n        }\n\n        @Nullable\n        UByte getAccessLevel() throws UaException {\n            Object value = getValue(accessLevelValue);\n\n            if (value instanceof UByte) {\n                return (UByte) value;\n            } else {\n                return null;\n            }\n        }\n\n        @Nullable\n        UByte getUserAccessLevel() throws UaException {\n            Object value = getValue(userAccessLevelValue);\n\n            if (value instanceof UByte) {\n                return (UByte) value;\n            } else {\n                return null;\n            }\n        }\n\n        @Nullable\n        UByte getEventNotifier() throws UaException {\n            Object value = getValue(eventNotifierValue);\n\n            if (value instanceof UByte) {\n                return (UByte) value;\n            } else {\n                return null;\n            }\n        }\n\n        @Nullable\n        Double getMinimumSamplingInterval() throws UaException {\n            Object value = getValue(minimumSamplingIntervalValue);\n\n            if (value instanceof Double) {\n                return (Double) value;\n            } else {\n                return null;\n            }\n        }\n\n        @Nullable\n        NodeId getDataType() throws UaException {\n            Object value = getValue(dataType);\n\n            if (value instanceof NodeId) {\n                return (NodeId) value;\n            } else {\n                return null;\n            }\n        }\n\n        private Object getValue(DataValue dataValue) throws UaException {\n            StatusCode statusCode = dataValue.getStatusCode();\n\n            if (statusCode == null) {\n                throw new UaException(StatusCode.BAD);\n            }\n\n            if (statusCode.isBad()) {\n                throw new UaException(statusCode);\n            }\n\n            return dataValue.getValue().getValue();\n        }\n    }\n\n}\n\n\n\n\n\n\n"], "fixing_code": ["/*\n * Copyright (c) 2022 the Eclipse Milo Authors\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\n\npackage org.eclipse.milo.opcua.sdk.server.api.config;\n\nimport java.util.concurrent.TimeUnit;\n\nimport org.eclipse.milo.opcua.stack.core.channel.EncodingLimits;\nimport org.eclipse.milo.opcua.stack.core.types.builtin.unsigned.UInteger;\nimport org.eclipse.milo.opcua.stack.core.types.builtin.unsigned.UShort;\n\nimport static org.eclipse.milo.opcua.stack.core.types.builtin.unsigned.Unsigned.uint;\nimport static org.eclipse.milo.opcua.stack.core.types.builtin.unsigned.Unsigned.ushort;\n\npublic interface OpcUaServerConfigLimits {\n\n    /**\n     * Get the maximum number of sessions that can be open at any given time.\n     *\n     * @return the maximum number of sessions that can be open at any given time.\n     */\n    default UInteger getMaxSessionCount() {\n        return uint(100);\n    }\n\n    /**\n     * Get the maximum session timeout, in milliseconds, allowed by the server.\n     * <p>\n     * Requests by clients for larger timeouts will be revised down to this limit.\n     *\n     * @return the maximum session timeout, in milliseconds, allowed by the server.\n     */\n    default Double getMaxSessionTimeout() {\n        return 2d * 60_000d;\n    }\n\n    /**\n     * Get the minimum allowed publishing interval.\n     *\n     * @return the minimum allowed publishing interval.\n     */\n    default Double getMinPublishingInterval() {\n        return 10.0;\n    }\n\n    /**\n     * Get the maximum allowed publishing interval.\n     *\n     * @return the maximum allowed publishing interval.\n     */\n    default Double getMaxPublishingInterval() {\n        return (double) TimeUnit.MILLISECONDS.convert(8, TimeUnit.HOURS);\n    }\n\n    /**\n     * Get the default publishing interval, used when the requested interval is either invalid or below the minimum.\n     *\n     * @return the default publishing interval.\n     */\n    default Double getDefaultPublishingInterval() {\n        return 250.0;\n    }\n\n    /**\n     * Get the minimum subscription lifetime, in milliseconds.\n     * <p>\n     * This value should be larger than the configured minimum publishing interval.\n     *\n     * @return the minimum subscription lifetime, in milliseconds.\n     */\n    default Double getMinSubscriptionLifetime() {\n        return 10_000.0;\n    }\n\n    /**\n     * Get the maximum subscription lifetime, in milliseconds.\n     * <p>\n     * This value should be larger than the configured maximum publishing interval.\n     *\n     * @return the maximum subscription lifetime, in milliseconds.\n     */\n    default Double getMaxSubscriptionLifetime() {\n        return (double) TimeUnit.MILLISECONDS.convert(24, TimeUnit.HOURS);\n    }\n\n    default Double getMaxSupportedSampleRate() {\n        return (double) TimeUnit.MILLISECONDS.convert(24, TimeUnit.HOURS);\n    }\n\n    /**\n     * Get the maximum allowed password length.\n     *\n     * @return the maximum allowed password length.\n     */\n    default UInteger getMaxPasswordLength() {\n        return uint(1024);\n    }\n\n    /**\n     * Get the maximum number of MonitoredItems, across all Sessions, that can be created.\n     *\n     * @return the maximum number of MonitoredItems, across all Sessions, that can be created.\n     */\n    default UInteger getMaxMonitoredItems() {\n        return uint(Integer.MAX_VALUE);\n    }\n\n    /**\n     * Get the maximum number of MonitoredItems, per Session, that can be created.\n     *\n     * @return the maximum number of MonitoredItems, per Session, that can be created.\n     */\n    default UInteger getMaxMonitoredItemsPerSession() {\n        return uint(Integer.MAX_VALUE);\n    }\n\n    //region ServerCapabilities\n\n    default Double getMinSupportedSampleRate() {\n        return 0.0;\n    }\n\n    default UInteger getMaxArrayLength() {\n        return uint(EncodingLimits.DEFAULT_MAX_MESSAGE_SIZE / 2);\n    }\n\n    default UInteger getMaxStringLength() {\n        return uint(EncodingLimits.DEFAULT_MAX_MESSAGE_SIZE / 2);\n    }\n\n    default UInteger getMaxByteStringLength() {\n        return uint(EncodingLimits.DEFAULT_MAX_MESSAGE_SIZE / 2);\n    }\n\n    default UShort getMaxBrowseContinuationPoints() {\n        return ushort(250);\n    }\n\n    default UShort getMaxQueryContinuationPoints() {\n        return ushort(250);\n    }\n\n    default UShort getMaxHistoryContinuationPoints() {\n        return ushort(250);\n    }\n\n    //endregion\n\n    //region OperationLimits\n\n    default UInteger getMaxNodesPerRead() {\n        return uint(10_000);\n    }\n\n    default UInteger getMaxNodesPerWrite() {\n        return uint(10_000);\n    }\n\n    default UInteger getMaxMonitoredItemsPerCall() {\n        return uint(10_000);\n    }\n\n    default UInteger getMaxNodesPerRegisterNodes() {\n        return uint(250);\n    }\n\n    default UInteger getMaxNodesPerHistoryReadData() {\n        return uint(250);\n    }\n\n    default UInteger getMaxNodesPerHistoryReadEvents() {\n        return uint(250);\n    }\n\n    default UInteger getMaxNodesPerHistoryUpdateData() {\n        return uint(250);\n    }\n\n    default UInteger getMaxNodesPerHistoryUpdateEvents() {\n        return uint(250);\n    }\n\n    default UInteger getMaxNodesPerMethodCall() {\n        return uint(250);\n    }\n\n    default UInteger getMaxNodesPerBrowse() {\n        return uint(250);\n    }\n\n    default UInteger getMaxNodesPerTranslateBrowsePathsToNodeIds() {\n        return uint(250);\n    }\n\n    default UInteger getMaxNodesPerNodeManagement() {\n        return uint(250);\n    }\n\n    //endregion\n\n}\n", "/*\n * Copyright (c) 2022 the Eclipse Milo Authors\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\n\npackage org.eclipse.milo.opcua.sdk.server.subscriptions;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.EnumSet;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.atomic.AtomicLong;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.stream.Stream;\n\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport io.netty.util.AttributeKey;\nimport org.eclipse.milo.opcua.sdk.core.AccessLevel;\nimport org.eclipse.milo.opcua.sdk.core.NumericRange;\nimport org.eclipse.milo.opcua.sdk.core.Reference;\nimport org.eclipse.milo.opcua.sdk.server.OpcUaServer;\nimport org.eclipse.milo.opcua.sdk.server.Session;\nimport org.eclipse.milo.opcua.sdk.server.api.DataItem;\nimport org.eclipse.milo.opcua.sdk.server.api.EventItem;\nimport org.eclipse.milo.opcua.sdk.server.api.MonitoredItem;\nimport org.eclipse.milo.opcua.sdk.server.api.services.AttributeServices.ReadContext;\nimport org.eclipse.milo.opcua.sdk.server.items.BaseMonitoredItem;\nimport org.eclipse.milo.opcua.sdk.server.items.MonitoredDataItem;\nimport org.eclipse.milo.opcua.sdk.server.items.MonitoredEventItem;\nimport org.eclipse.milo.opcua.sdk.server.nodes.UaNode;\nimport org.eclipse.milo.opcua.sdk.server.subscriptions.Subscription.State;\nimport org.eclipse.milo.opcua.stack.core.AttributeId;\nimport org.eclipse.milo.opcua.stack.core.Identifiers;\nimport org.eclipse.milo.opcua.stack.core.StatusCodes;\nimport org.eclipse.milo.opcua.stack.core.UaException;\nimport org.eclipse.milo.opcua.stack.core.UaSerializationException;\nimport org.eclipse.milo.opcua.stack.core.types.builtin.DataValue;\nimport org.eclipse.milo.opcua.stack.core.types.builtin.DiagnosticInfo;\nimport org.eclipse.milo.opcua.stack.core.types.builtin.ExtensionObject;\nimport org.eclipse.milo.opcua.stack.core.types.builtin.NodeId;\nimport org.eclipse.milo.opcua.stack.core.types.builtin.QualifiedName;\nimport org.eclipse.milo.opcua.stack.core.types.builtin.StatusCode;\nimport org.eclipse.milo.opcua.stack.core.types.builtin.unsigned.UByte;\nimport org.eclipse.milo.opcua.stack.core.types.builtin.unsigned.UInteger;\nimport org.eclipse.milo.opcua.stack.core.types.enumerated.DeadbandType;\nimport org.eclipse.milo.opcua.stack.core.types.enumerated.MonitoringMode;\nimport org.eclipse.milo.opcua.stack.core.types.enumerated.TimestampsToReturn;\nimport org.eclipse.milo.opcua.stack.core.types.structured.CreateMonitoredItemsRequest;\nimport org.eclipse.milo.opcua.stack.core.types.structured.CreateMonitoredItemsResponse;\nimport org.eclipse.milo.opcua.stack.core.types.structured.CreateSubscriptionRequest;\nimport org.eclipse.milo.opcua.stack.core.types.structured.CreateSubscriptionResponse;\nimport org.eclipse.milo.opcua.stack.core.types.structured.DataChangeFilter;\nimport org.eclipse.milo.opcua.stack.core.types.structured.DeleteMonitoredItemsRequest;\nimport org.eclipse.milo.opcua.stack.core.types.structured.DeleteMonitoredItemsResponse;\nimport org.eclipse.milo.opcua.stack.core.types.structured.DeleteSubscriptionsRequest;\nimport org.eclipse.milo.opcua.stack.core.types.structured.DeleteSubscriptionsResponse;\nimport org.eclipse.milo.opcua.stack.core.types.structured.EventFilter;\nimport org.eclipse.milo.opcua.stack.core.types.structured.ModifyMonitoredItemsRequest;\nimport org.eclipse.milo.opcua.stack.core.types.structured.ModifyMonitoredItemsResponse;\nimport org.eclipse.milo.opcua.stack.core.types.structured.ModifySubscriptionRequest;\nimport org.eclipse.milo.opcua.stack.core.types.structured.ModifySubscriptionResponse;\nimport org.eclipse.milo.opcua.stack.core.types.structured.MonitoredItemCreateRequest;\nimport org.eclipse.milo.opcua.stack.core.types.structured.MonitoredItemCreateResult;\nimport org.eclipse.milo.opcua.stack.core.types.structured.MonitoredItemModifyRequest;\nimport org.eclipse.milo.opcua.stack.core.types.structured.MonitoredItemModifyResult;\nimport org.eclipse.milo.opcua.stack.core.types.structured.MonitoringFilter;\nimport org.eclipse.milo.opcua.stack.core.types.structured.MonitoringParameters;\nimport org.eclipse.milo.opcua.stack.core.types.structured.NotificationMessage;\nimport org.eclipse.milo.opcua.stack.core.types.structured.PublishRequest;\nimport org.eclipse.milo.opcua.stack.core.types.structured.ReadValueId;\nimport org.eclipse.milo.opcua.stack.core.types.structured.RepublishRequest;\nimport org.eclipse.milo.opcua.stack.core.types.structured.RepublishResponse;\nimport org.eclipse.milo.opcua.stack.core.types.structured.ResponseHeader;\nimport org.eclipse.milo.opcua.stack.core.types.structured.SetMonitoringModeRequest;\nimport org.eclipse.milo.opcua.stack.core.types.structured.SetMonitoringModeResponse;\nimport org.eclipse.milo.opcua.stack.core.types.structured.SetPublishingModeRequest;\nimport org.eclipse.milo.opcua.stack.core.types.structured.SetPublishingModeResponse;\nimport org.eclipse.milo.opcua.stack.core.types.structured.SetTriggeringRequest;\nimport org.eclipse.milo.opcua.stack.core.types.structured.SetTriggeringResponse;\nimport org.eclipse.milo.opcua.stack.core.types.structured.SubscriptionAcknowledgement;\nimport org.eclipse.milo.opcua.stack.server.services.ServiceRequest;\nimport org.jetbrains.annotations.Nullable;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport static com.google.common.collect.Lists.newArrayListWithCapacity;\nimport static java.util.stream.Collectors.toList;\nimport static org.eclipse.milo.opcua.sdk.core.util.StreamUtil.opt2stream;\nimport static org.eclipse.milo.opcua.stack.core.types.builtin.unsigned.Unsigned.ubyte;\nimport static org.eclipse.milo.opcua.stack.core.types.builtin.unsigned.Unsigned.uint;\nimport static org.eclipse.milo.opcua.stack.core.util.ConversionUtil.l;\n\npublic class SubscriptionManager {\n\n    static final AttributeKey<StatusCode[]> KEY_ACK_RESULTS = AttributeKey.valueOf(\"ackResults\");\n\n    private static final QualifiedName DEFAULT_BINARY_ENCODING = new QualifiedName(0, \"DefaultBinary\");\n    private static final QualifiedName DEFAULT_XML_ENCODING = new QualifiedName(0, \"DefaultXML\");\n\n    private static final AtomicLong SUBSCRIPTION_IDS = new AtomicLong(0L);\n\n    private static UInteger nextSubscriptionId() {\n        return uint(SUBSCRIPTION_IDS.incrementAndGet());\n    }\n\n    private final Logger logger = LoggerFactory.getLogger(getClass());\n\n    private final PublishQueue publishQueue = new PublishQueue();\n\n    private final Map<UInteger, Subscription> subscriptions = Maps.newConcurrentMap();\n    private final List<Subscription> transferred = Lists.newCopyOnWriteArrayList();\n\n    private final AtomicLong monitoredItemCount = new AtomicLong(0L);\n\n    private final Session session;\n    private final OpcUaServer server;\n\n    public SubscriptionManager(Session session, OpcUaServer server) {\n        this.session = session;\n        this.server = server;\n    }\n\n    public Session getSession() {\n        return session;\n    }\n\n    public PublishQueue getPublishQueue() {\n        return publishQueue;\n    }\n\n    public OpcUaServer getServer() {\n        return server;\n    }\n\n    @Nullable\n    public Subscription getSubscription(UInteger subscriptionId) {\n        return subscriptions.get(subscriptionId);\n    }\n\n    public List<Subscription> getSubscriptions() {\n        return new ArrayList<>(subscriptions.values());\n    }\n\n    public void createSubscription(ServiceRequest service) {\n        CreateSubscriptionRequest request = (CreateSubscriptionRequest) service.getRequest();\n\n        UInteger subscriptionId = nextSubscriptionId();\n\n        Subscription subscription = new Subscription(\n            this,\n            subscriptionId,\n            request.getRequestedPublishingInterval(),\n            request.getRequestedMaxKeepAliveCount().longValue(),\n            request.getRequestedLifetimeCount().longValue(),\n            request.getMaxNotificationsPerPublish().longValue(),\n            request.getPublishingEnabled(),\n            request.getPriority().intValue()\n        );\n\n        subscriptions.put(subscriptionId, subscription);\n        server.getSubscriptions().put(subscriptionId, subscription);\n        server.getDiagnosticsSummary().getCumulatedSubscriptionCount().increment();\n        server.getEventBus().post(new SubscriptionCreatedEvent(subscription));\n\n        subscription.setStateListener((s, ps, cs) -> {\n            if (cs == State.Closing) {\n                subscriptions.remove(s.getId());\n                server.getSubscriptions().remove(s.getId());\n                server.getEventBus().post(new SubscriptionDeletedEvent(s));\n\n                /*\n                 * Notify AddressSpaces the items for this subscription are deleted.\n                 */\n\n                Map<UInteger, BaseMonitoredItem<?>> monitoredItems = s.getMonitoredItems();\n\n                byMonitoredItemType(\n                    monitoredItems.values(),\n                    dataItems -> server.getAddressSpaceManager().onDataItemsDeleted(dataItems),\n                    eventItems -> server.getAddressSpaceManager().onEventItemsDeleted(eventItems)\n                );\n\n                monitoredItemCount.getAndUpdate(count -> count - monitoredItems.size());\n                server.getMonitoredItemCount().getAndUpdate(count -> count - monitoredItems.size());\n\n                monitoredItems.clear();\n            }\n        });\n\n        subscription.startPublishingTimer();\n\n        ResponseHeader header = service.createResponseHeader();\n\n        CreateSubscriptionResponse response = new CreateSubscriptionResponse(\n            header, subscriptionId,\n            subscription.getPublishingInterval(),\n            uint(subscription.getLifetimeCount()),\n            uint(subscription.getMaxKeepAliveCount())\n        );\n\n        service.setResponse(response);\n    }\n\n    public void modifySubscription(ServiceRequest service) throws UaException {\n        ModifySubscriptionRequest request = (ModifySubscriptionRequest) service.getRequest();\n\n        UInteger subscriptionId = request.getSubscriptionId();\n        Subscription subscription = subscriptions.get(subscriptionId);\n\n        if (subscription == null) {\n            throw new UaException(StatusCodes.Bad_SubscriptionIdInvalid);\n        }\n\n        subscription.modifySubscription(request);\n\n        ResponseHeader header = service.createResponseHeader();\n\n        ModifySubscriptionResponse response = new ModifySubscriptionResponse(\n            header,\n            subscription.getPublishingInterval(),\n            uint(subscription.getLifetimeCount()),\n            uint(subscription.getMaxKeepAliveCount())\n        );\n\n        service.setResponse(response);\n    }\n\n    public void deleteSubscription(ServiceRequest service) throws UaException {\n        DeleteSubscriptionsRequest request = (DeleteSubscriptionsRequest) service.getRequest();\n\n        List<UInteger> subscriptionIds = l(request.getSubscriptionIds());\n\n        if (subscriptionIds.isEmpty()) {\n            throw new UaException(StatusCodes.Bad_NothingToDo);\n        }\n\n        StatusCode[] results = new StatusCode[subscriptionIds.size()];\n\n        for (int i = 0; i < subscriptionIds.size(); i++) {\n            UInteger subscriptionId = subscriptionIds.get(i);\n            Subscription subscription = subscriptions.remove(subscriptionId);\n\n            if (subscription != null) {\n                server.getSubscriptions().remove(subscription.getId());\n                server.getEventBus().post(new SubscriptionDeletedEvent(subscription));\n\n                List<BaseMonitoredItem<?>> deletedItems = subscription.deleteSubscription();\n\n                /*\n                 * Notify AddressSpaces of the items we just deleted.\n                 */\n\n                byMonitoredItemType(\n                    deletedItems,\n                    dataItems -> server.getAddressSpaceManager().onDataItemsDeleted(dataItems),\n                    eventItems -> server.getAddressSpaceManager().onEventItemsDeleted(eventItems)\n                );\n\n                results[i] = StatusCode.GOOD;\n\n                monitoredItemCount.getAndUpdate(count -> count - deletedItems.size());\n                server.getMonitoredItemCount().getAndUpdate(count -> count - deletedItems.size());\n            } else {\n                results[i] = new StatusCode(StatusCodes.Bad_SubscriptionIdInvalid);\n            }\n        }\n\n        ResponseHeader header = service.createResponseHeader();\n\n        DeleteSubscriptionsResponse response = new DeleteSubscriptionsResponse(\n            header,\n            results,\n            new DiagnosticInfo[0]\n        );\n\n        service.setResponse(response);\n\n        while (subscriptions.isEmpty() && publishQueue.isNotEmpty()) {\n            ServiceRequest publishService = publishQueue.poll();\n            if (publishService != null) {\n                publishService.setServiceFault(StatusCodes.Bad_NoSubscription);\n            }\n        }\n    }\n\n    public void setPublishingMode(ServiceRequest service) {\n        SetPublishingModeRequest request = (SetPublishingModeRequest) service.getRequest();\n        List<UInteger> subscriptionIds = l(request.getSubscriptionIds());\n\n        StatusCode[] results = new StatusCode[subscriptionIds.size()];\n\n        for (int i = 0; i < subscriptionIds.size(); i++) {\n            Subscription subscription = subscriptions.get(subscriptionIds.get(i));\n            if (subscription == null) {\n                results[i] = new StatusCode(StatusCodes.Bad_SubscriptionIdInvalid);\n            } else {\n                subscription.setPublishingMode(request);\n                results[i] = StatusCode.GOOD;\n            }\n        }\n\n        ResponseHeader header = service.createResponseHeader();\n\n        SetPublishingModeResponse response = new SetPublishingModeResponse(\n            header,\n            results,\n            new DiagnosticInfo[0]\n        );\n\n        service.setResponse(response);\n    }\n\n    public void createMonitoredItems(ServiceRequest service) throws UaException {\n        CreateMonitoredItemsRequest request = (CreateMonitoredItemsRequest) service.getRequest();\n\n        UInteger subscriptionId = request.getSubscriptionId();\n        Subscription subscription = subscriptions.get(subscriptionId);\n        TimestampsToReturn timestamps = request.getTimestampsToReturn();\n        List<MonitoredItemCreateRequest> itemsToCreate = l(request.getItemsToCreate());\n\n        if (subscription == null) {\n            throw new UaException(StatusCodes.Bad_SubscriptionIdInvalid);\n        }\n        if (timestamps == null) {\n            throw new UaException(StatusCodes.Bad_TimestampsToReturnInvalid);\n        }\n        if (itemsToCreate.isEmpty()) {\n            throw new UaException(StatusCodes.Bad_NothingToDo);\n        }\n\n        List<NodeId> distinctNodeIds = itemsToCreate.stream()\n            .map(item -> item.getItemToMonitor().getNodeId())\n            .distinct()\n            .collect(toList());\n\n        CompletableFuture<Map<NodeId, AttributeGroup>> attributesFuture = readMonitoringAttributes(distinctNodeIds);\n\n        attributesFuture.thenAccept(attributeGroups -> {\n            MonitoredItemCreateResult[] createResults = new MonitoredItemCreateResult[itemsToCreate.size()];\n\n            List<BaseMonitoredItem<?>> monitoredItems = new ArrayList<>();\n\n            long globalMax = server.getConfig()\n                .getLimits().getMaxMonitoredItems().longValue();\n\n            long sessionMax = server.getConfig()\n                .getLimits().getMaxMonitoredItemsPerSession().longValue();\n\n            for (int i = 0; i < itemsToCreate.size(); i++) {\n                MonitoredItemCreateRequest createRequest = itemsToCreate.get(i);\n\n                try {\n                    long globalCount = server.getMonitoredItemCount().incrementAndGet();\n                    long sessionCount = monitoredItemCount.incrementAndGet();\n\n                    if (globalCount <= globalMax && sessionCount <= sessionMax) {\n                        BaseMonitoredItem<?> monitoredItem = createMonitoredItem(\n                            createRequest,\n                            subscription,\n                            timestamps,\n                            attributeGroups\n                        );\n\n                        monitoredItems.add(monitoredItem);\n\n                        createResults[i] = new MonitoredItemCreateResult(\n                            StatusCode.GOOD,\n                            monitoredItem.getId(),\n                            monitoredItem.getSamplingInterval(),\n                            uint(monitoredItem.getQueueSize()),\n                            monitoredItem.getFilterResult()\n                        );\n                    } else {\n                        throw new UaException(StatusCodes.Bad_TooManyMonitoredItems);\n                    }\n                } catch (UaException e) {\n                    monitoredItemCount.decrementAndGet();\n                    server.getMonitoredItemCount().decrementAndGet();\n\n                    createResults[i] = new MonitoredItemCreateResult(\n                        e.getStatusCode(),\n                        UInteger.MIN,\n                        0.0,\n                        UInteger.MIN,\n                        null\n                    );\n                }\n            }\n\n            subscription.addMonitoredItems(monitoredItems);\n\n            // Notify AddressSpaces of the items we just created.\n\n            byMonitoredItemType(\n                monitoredItems,\n                dataItems -> server.getAddressSpaceManager().onDataItemsCreated(dataItems),\n                eventItems -> server.getAddressSpaceManager().onEventItemsCreated(eventItems)\n            );\n\n            ResponseHeader header = service.createResponseHeader();\n\n            CreateMonitoredItemsResponse response = new CreateMonitoredItemsResponse(\n                header,\n                createResults,\n                new DiagnosticInfo[0]\n            );\n\n            service.setResponse(response);\n        });\n    }\n\n    private BaseMonitoredItem<?> createMonitoredItem(\n        MonitoredItemCreateRequest request,\n        Subscription subscription,\n        TimestampsToReturn timestamps,\n        Map<NodeId, AttributeGroup> attributeGroups\n    ) throws UaException {\n\n        NodeId nodeId = request.getItemToMonitor().getNodeId();\n        UInteger attributeId = request.getItemToMonitor().getAttributeId();\n        QualifiedName dataEncoding = request.getItemToMonitor().getDataEncoding();\n\n        if (!AttributeId.isValid(attributeId)) {\n            throw new UaException(StatusCodes.Bad_AttributeIdInvalid);\n        }\n\n        if (dataEncoding.isNotNull()) {\n            if (!AttributeId.Value.isEqual(attributeId)) {\n                throw new UaException(StatusCodes.Bad_DataEncodingInvalid);\n            }\n\n            if (!dataEncoding.equals(DEFAULT_BINARY_ENCODING) &&\n                !dataEncoding.equals(DEFAULT_XML_ENCODING)) {\n\n                throw new UaException(StatusCodes.Bad_DataEncodingUnsupported);\n            }\n        }\n\n        AttributeGroup attributeGroup = attributeGroups.get(nodeId);\n\n        if (attributeId.equals(AttributeId.EventNotifier.uid())) {\n            UByte eventNotifier = attributeGroup.getEventNotifier();\n\n            // Verify that the SubscribeToEvents bit is set\n            if (eventNotifier == null || (eventNotifier.intValue() & 1) == 0) {\n                throw new UaException(StatusCodes.Bad_AttributeIdInvalid);\n            }\n\n            Object filterObject = request.getRequestedParameters()\n                .getFilter()\n                .decode(server.getSerializationContext());\n\n            MonitoringFilter filter = validateEventItemFilter(filterObject, attributeGroup);\n\n            UInteger requestedQueueSize = request.getRequestedParameters().getQueueSize();\n            AtomicReference<UInteger> revisedQueueSize = new AtomicReference<>(requestedQueueSize);\n\n            try {\n                server.getAddressSpaceManager().onCreateEventItem(\n                    request.getItemToMonitor(),\n                    requestedQueueSize,\n                    revisedQueueSize::set\n                );\n            } catch (Throwable t) {\n                throw new UaException(StatusCodes.Bad_InternalError, t);\n            }\n\n            MonitoredEventItem monitoredEventItem = new MonitoredEventItem(\n                server,\n                session,\n                uint(subscription.nextItemId()),\n                subscription.getId(),\n                request.getItemToMonitor(),\n                request.getMonitoringMode(),\n                timestamps,\n                request.getRequestedParameters().getClientHandle(),\n                0.0,\n                revisedQueueSize.get(),\n                request.getRequestedParameters().getDiscardOldest()\n            );\n\n            monitoredEventItem.installFilter(filter);\n\n            return monitoredEventItem;\n        } else {\n            if (attributeId.equals(AttributeId.Value.uid())) {\n                UByte accessLevel = attributeGroup.getAccessLevel();\n                if (accessLevel == null) accessLevel = ubyte(0);\n\n                UByte userAccessLevel = attributeGroup.getUserAccessLevel();\n                if (userAccessLevel == null) userAccessLevel = ubyte(0);\n\n                EnumSet<AccessLevel> accessLevels = AccessLevel.fromValue(accessLevel);\n                EnumSet<AccessLevel> userAccessLevels = AccessLevel.fromValue(userAccessLevel);\n\n                if (!accessLevels.contains(AccessLevel.CurrentRead)) {\n                    throw new UaException(StatusCodes.Bad_NotReadable);\n                }\n                if (!userAccessLevels.contains(AccessLevel.CurrentRead)) {\n                    throw new UaException(StatusCodes.Bad_UserAccessDenied);\n                }\n            }\n\n            // Validate the requested index range by parsing it.\n            String indexRange = request.getItemToMonitor().getIndexRange();\n            if (indexRange != null) NumericRange.parse(indexRange);\n\n            Double minimumSamplingInterval = -1.0;\n            try {\n                minimumSamplingInterval = attributeGroup.getMinimumSamplingInterval();\n                if (minimumSamplingInterval == null) {\n                    minimumSamplingInterval = server.getConfig().getLimits().getMinSupportedSampleRate();\n                }\n            } catch (UaException e) {\n                if (e.getStatusCode().getValue() != StatusCodes.Bad_AttributeIdInvalid) {\n                    throw e;\n                }\n            }\n\n            MonitoringFilter filter = MonitoredDataItem.DEFAULT_FILTER;\n\n            try {\n                ExtensionObject filterXo = request.getRequestedParameters().getFilter();\n\n                if (filterXo != null && !filterXo.isNull()) {\n                    Object filterObject = filterXo\n                        .decode(server.getSerializationContext());\n\n                    filter = validateDataItemFilter(filterObject, attributeId, attributeGroup);\n                }\n            } catch (UaSerializationException e) {\n                logger.debug(\"error decoding MonitoringFilter\", e);\n\n                throw new UaException(StatusCodes.Bad_MonitoredItemFilterInvalid, e);\n            }\n\n            double requestedSamplingInterval = getSamplingInterval(\n                subscription,\n                minimumSamplingInterval,\n                request.getRequestedParameters().getSamplingInterval()\n            );\n\n            UInteger requestedQueueSize = request.getRequestedParameters().getQueueSize();\n\n            AtomicReference<Double> revisedSamplingInterval = new AtomicReference<>(requestedSamplingInterval);\n            AtomicReference<UInteger> revisedQueueSize = new AtomicReference<>(requestedQueueSize);\n\n            try {\n                server.getAddressSpaceManager().onCreateDataItem(\n                    request.getItemToMonitor(),\n                    requestedSamplingInterval,\n                    requestedQueueSize,\n                    (rsi, rqs) -> {\n                        revisedSamplingInterval.set(rsi);\n                        revisedQueueSize.set(rqs);\n                    }\n                );\n            } catch (Throwable t) {\n                throw new UaException(StatusCodes.Bad_InternalError, t);\n            }\n\n            MonitoredDataItem monitoredDataItem = new MonitoredDataItem(\n                server,\n                session,\n                uint(subscription.nextItemId()),\n                subscription.getId(),\n                request.getItemToMonitor(),\n                request.getMonitoringMode(),\n                timestamps,\n                request.getRequestedParameters().getClientHandle(),\n                revisedSamplingInterval.get(),\n                revisedQueueSize.get(),\n                request.getRequestedParameters().getDiscardOldest()\n            );\n\n            monitoredDataItem.installFilter(filter);\n\n            return monitoredDataItem;\n        }\n    }\n\n    private MonitoringFilter validateDataItemFilter(\n        Object filterObject,\n        UInteger attributeId,\n        AttributeGroup attributeGroup\n    ) throws UaException {\n\n        if (filterObject instanceof MonitoringFilter) {\n            if (filterObject instanceof DataChangeFilter) {\n                DataChangeFilter filter = (DataChangeFilter) filterObject;\n\n                DeadbandType deadbandType = DeadbandType.from(filter.getDeadbandType().intValue());\n\n                if (deadbandType == null) {\n                    throw new UaException(StatusCodes.Bad_DeadbandFilterInvalid);\n                }\n\n                if (deadbandType == DeadbandType.Percent) {\n                    // Percent deadband is not currently implemented\n                    throw new UaException(StatusCodes.Bad_MonitoredItemFilterUnsupported);\n                }\n\n                if (deadbandType == DeadbandType.Absolute &&\n                    !AttributeId.Value.isEqual(attributeId)) {\n\n                    // Absolute deadband is only allowed for Value attributes\n                    throw new UaException(StatusCodes.Bad_FilterNotAllowed);\n                }\n\n                if (deadbandType != DeadbandType.None) {\n                    NodeId dataTypeId = null;\n                    try {\n                        dataTypeId = attributeGroup.getDataType();\n                    } catch (UaException ignored) {\n                        // noop\n                    }\n                    if (dataTypeId == null) {\n                        dataTypeId = NodeId.NULL_VALUE;\n                    }\n\n                    if (!Identifiers.Number.equals(dataTypeId) && !subtypeOf(server, dataTypeId, Identifiers.Number)) {\n                        throw new UaException(StatusCodes.Bad_FilterNotAllowed);\n                    }\n                }\n\n                return filter;\n            } else if (filterObject instanceof EventFilter) {\n                throw new UaException(StatusCodes.Bad_FilterNotAllowed);\n            } else {\n                // AggregateFilter or some future unimplemented filter\n                throw new UaException(StatusCodes.Bad_MonitoredItemFilterUnsupported);\n            }\n        } else {\n            throw new UaException(StatusCodes.Bad_MonitoredItemFilterInvalid);\n        }\n    }\n\n    private MonitoringFilter validateEventItemFilter(\n        Object filterObject,\n        AttributeGroup attributeGroup\n    ) throws UaException {\n\n        if (filterObject instanceof MonitoringFilter) {\n            if (!(filterObject instanceof EventFilter)) {\n                throw new UaException(StatusCodes.Bad_FilterNotAllowed);\n            }\n            return (EventFilter) filterObject;\n        } else {\n            throw new UaException(StatusCodes.Bad_MonitoredItemFilterInvalid);\n        }\n    }\n\n    public void modifyMonitoredItems(ServiceRequest service) throws UaException {\n        ModifyMonitoredItemsRequest request = (ModifyMonitoredItemsRequest) service.getRequest();\n\n        UInteger subscriptionId = request.getSubscriptionId();\n        Subscription subscription = subscriptions.get(subscriptionId);\n        TimestampsToReturn timestamps = request.getTimestampsToReturn();\n        List<MonitoredItemModifyRequest> itemsToModify = l(request.getItemsToModify());\n\n        if (subscription == null) {\n            throw new UaException(StatusCodes.Bad_SubscriptionIdInvalid);\n        }\n        if (timestamps == null) {\n            throw new UaException(StatusCodes.Bad_TimestampsToReturnInvalid);\n        }\n        if (itemsToModify.isEmpty()) {\n            throw new UaException(StatusCodes.Bad_NothingToDo);\n        }\n\n        List<NodeId> distinctNodeIds = itemsToModify.stream()\n            .map(item -> {\n                UInteger itemId = item.getMonitoredItemId();\n                BaseMonitoredItem<?> monitoredItem = subscription.getMonitoredItems().get(itemId);\n                return monitoredItem != null ? monitoredItem.getReadValueId().getNodeId() : NodeId.NULL_VALUE;\n            })\n            .filter(NodeId::isNotNull)\n            .distinct()\n            .collect(toList());\n\n        CompletableFuture<Map<NodeId, AttributeGroup>> attributesFuture = readMonitoringAttributes(distinctNodeIds);\n\n        attributesFuture.thenAccept(attributeGroups -> {\n            MonitoredItemModifyResult[] modifyResults = new MonitoredItemModifyResult[itemsToModify.size()];\n\n            List<BaseMonitoredItem<?>> monitoredItems = new ArrayList<>();\n\n            for (int i = 0; i < itemsToModify.size(); i++) {\n                MonitoredItemModifyRequest modifyRequest = itemsToModify.get(i);\n\n                try {\n                    BaseMonitoredItem<?> monitoredItem = modifyMonitoredItem(\n                        modifyRequest,\n                        timestamps,\n                        subscription,\n                        attributeGroups\n                    );\n\n                    monitoredItems.add(monitoredItem);\n\n                    modifyResults[i] = new MonitoredItemModifyResult(\n                        StatusCode.GOOD,\n                        monitoredItem.getSamplingInterval(),\n                        uint(monitoredItem.getQueueSize()),\n                        monitoredItem.getFilterResult()\n                    );\n                } catch (UaException e) {\n                    modifyResults[i] = new MonitoredItemModifyResult(\n                        e.getStatusCode(),\n                        0.0,\n                        UInteger.MIN,\n                        null\n                    );\n                }\n            }\n\n            subscription.resetLifetimeCounter();\n\n            /*\n             * Notify AddressSpaces of the items we just modified.\n             */\n\n            byMonitoredItemType(\n                monitoredItems,\n                dataItems -> server.getAddressSpaceManager().onDataItemsModified(dataItems),\n                eventItems -> server.getAddressSpaceManager().onEventItemsModified(eventItems)\n            );\n\n            /*\n             * AddressSpaces have been notified; send response.\n             */\n\n            ResponseHeader header = service.createResponseHeader();\n\n            ModifyMonitoredItemsResponse response = new ModifyMonitoredItemsResponse(\n                header,\n                modifyResults,\n                new DiagnosticInfo[0]\n            );\n\n            service.setResponse(response);\n        });\n    }\n\n    private BaseMonitoredItem<?> modifyMonitoredItem(\n        MonitoredItemModifyRequest request,\n        TimestampsToReturn timestamps,\n        Subscription subscription,\n        Map<NodeId, AttributeGroup> attributeGroups\n    ) throws UaException {\n\n        UInteger itemId = request.getMonitoredItemId();\n        MonitoringParameters parameters = request.getRequestedParameters();\n\n        BaseMonitoredItem<?> monitoredItem = subscription.getMonitoredItems().get(itemId);\n\n        if (monitoredItem == null) {\n            throw new UaException(StatusCodes.Bad_MonitoredItemIdInvalid);\n        }\n\n        NodeId nodeId = monitoredItem.getReadValueId().getNodeId();\n        UInteger attributeId = monitoredItem.getReadValueId().getAttributeId();\n        AttributeGroup attributeGroup = attributeGroups.get(nodeId);\n\n        if (attributeId.equals(AttributeId.EventNotifier.uid())) {\n            Object filterObject = request.getRequestedParameters()\n                .getFilter()\n                .decode(server.getSerializationContext());\n\n            MonitoringFilter filter = validateEventItemFilter(filterObject, attributeGroup);\n\n            UInteger requestedQueueSize = parameters.getQueueSize();\n            AtomicReference<UInteger> revisedQueueSize = new AtomicReference<>(requestedQueueSize);\n\n            try {\n                server.getAddressSpaceManager().onModifyEventItem(\n                    monitoredItem.getReadValueId(),\n                    requestedQueueSize,\n                    revisedQueueSize::set\n                );\n            } catch (Throwable t) {\n                throw new UaException(StatusCodes.Bad_InternalError, t);\n            }\n\n            monitoredItem.modify(\n                timestamps,\n                parameters.getClientHandle(),\n                monitoredItem.getSamplingInterval(),\n                filter,\n                revisedQueueSize.get(),\n                parameters.getDiscardOldest()\n            );\n        } else {\n            MonitoringFilter filter = MonitoredDataItem.DEFAULT_FILTER;\n\n            try {\n                ExtensionObject filterXo = request.getRequestedParameters().getFilter();\n\n                if (filterXo != null && !filterXo.isNull()) {\n                    Object filterObject = filterXo\n                        .decode(server.getSerializationContext());\n\n                    filter = validateDataItemFilter(filterObject, attributeId, attributeGroup);\n                }\n            } catch (UaSerializationException e) {\n                logger.debug(\"error decoding MonitoringFilter\", e);\n\n                throw new UaException(StatusCodes.Bad_MonitoredItemFilterInvalid, e);\n            }\n\n            Double minimumSamplingInterval = -1.0;\n            try {\n                minimumSamplingInterval = attributeGroup.getMinimumSamplingInterval();\n                if (minimumSamplingInterval == null) {\n                    minimumSamplingInterval = server.getConfig().getLimits().getMinSupportedSampleRate();\n                }\n            } catch (UaException e) {\n                long statusCodeValue = e.getStatusCode().getValue();\n\n                if (statusCodeValue != StatusCodes.Bad_AttributeIdInvalid &&\n                    statusCodeValue != StatusCodes.Bad_NodeIdUnknown) {\n\n                    throw e;\n                }\n            }\n\n            double requestedSamplingInterval = getSamplingInterval(\n                subscription,\n                minimumSamplingInterval,\n                request.getRequestedParameters().getSamplingInterval()\n            );\n\n            UInteger requestedQueueSize = parameters.getQueueSize();\n\n            AtomicReference<Double> revisedSamplingInterval = new AtomicReference<>(requestedSamplingInterval);\n            AtomicReference<UInteger> revisedQueueSize = new AtomicReference<>(requestedQueueSize);\n\n            try {\n                server.getAddressSpaceManager().onModifyDataItem(\n                    monitoredItem.getReadValueId(),\n                    requestedSamplingInterval,\n                    requestedQueueSize,\n                    (rsi, rqs) -> {\n                        revisedSamplingInterval.set(rsi);\n                        revisedQueueSize.set(rqs);\n                    }\n                );\n            } catch (Throwable t) {\n                throw new UaException(StatusCodes.Bad_InternalError, t);\n            }\n\n            monitoredItem.modify(\n                timestamps,\n                parameters.getClientHandle(),\n                revisedSamplingInterval.get(),\n                filter,\n                revisedQueueSize.get(),\n                parameters.getDiscardOldest()\n            );\n        }\n\n        return monitoredItem;\n    }\n\n    private double getSamplingInterval(\n        Subscription subscription,\n        Double minimumSamplingInterval,\n        Double requestedSamplingInterval\n    ) {\n\n        double samplingInterval = requestedSamplingInterval;\n\n        if (requestedSamplingInterval < 0) {\n            samplingInterval = subscription.getPublishingInterval();\n        } else if (requestedSamplingInterval == 0) {\n            if (minimumSamplingInterval < 0) {\n                // Node has no opinion on sampling interval (indeterminate)\n                samplingInterval = subscription.getPublishingInterval();\n            } else if (minimumSamplingInterval == 0) {\n                // Node allows report-by-exception\n                samplingInterval = minimumSamplingInterval;\n            } else if (minimumSamplingInterval > 0) {\n                // Node has a defined minimum sampling interval, use that\n                // because requested rate of 0 means \"fastest practical rate\"\n                samplingInterval = minimumSamplingInterval;\n            }\n        } else {\n            if (requestedSamplingInterval < minimumSamplingInterval) {\n                samplingInterval = minimumSamplingInterval;\n            }\n        }\n\n        double minSupportedSampleRate = server.getConfig().getLimits().getMinSupportedSampleRate();\n        double maxSupportedSampleRate = server.getConfig().getLimits().getMaxSupportedSampleRate();\n\n        if (samplingInterval < minSupportedSampleRate) {\n            samplingInterval = minSupportedSampleRate;\n        }\n        if (samplingInterval > maxSupportedSampleRate) {\n            samplingInterval = maxSupportedSampleRate;\n        }\n\n        return samplingInterval;\n    }\n\n    private CompletableFuture<Map<NodeId, AttributeGroup>> readMonitoringAttributes(List<NodeId> nodeIds) {\n        List<ReadValueId> attributesToRead = nodeIds.stream()\n            .flatMap(nodeId -> {\n                Function<AttributeId, ReadValueId> f = id -> new ReadValueId(\n                    nodeId,\n                    id.uid(),\n                    null,\n                    QualifiedName.NULL_VALUE\n                );\n\n                return Stream.of(\n                    f.apply(AttributeId.AccessLevel),\n                    f.apply(AttributeId.UserAccessLevel),\n                    f.apply(AttributeId.EventNotifier),\n                    f.apply(AttributeId.MinimumSamplingInterval),\n                    f.apply(AttributeId.DataType)\n                );\n            })\n            .collect(toList());\n\n        ReadContext context = new ReadContext(server, session);\n\n        server.getAddressSpaceManager().read(\n            context,\n            0.0,\n            TimestampsToReturn.Neither,\n            attributesToRead\n        );\n\n        return context.getFuture().thenApply(attributeValues -> {\n            Map<NodeId, AttributeGroup> monitoringAttributes = new HashMap<>();\n\n            for (int nodeIdx = 0, attrIdx = 0; nodeIdx < nodeIds.size(); nodeIdx++, attrIdx += 5) {\n                monitoringAttributes.put(nodeIds.get(nodeIdx), new AttributeGroup(\n                    attributeValues.get(attrIdx),\n                    attributeValues.get(attrIdx + 1),\n                    attributeValues.get(attrIdx + 2),\n                    attributeValues.get(attrIdx + 3),\n                    attributeValues.get(attrIdx + 4)\n                ));\n            }\n\n            return monitoringAttributes;\n        });\n    }\n\n\n    public void deleteMonitoredItems(ServiceRequest service) throws UaException {\n        DeleteMonitoredItemsRequest request = (DeleteMonitoredItemsRequest) service.getRequest();\n\n        UInteger subscriptionId = request.getSubscriptionId();\n        Subscription subscription = subscriptions.get(subscriptionId);\n        List<UInteger> itemsToDelete = l(request.getMonitoredItemIds());\n\n        if (subscription == null) {\n            throw new UaException(StatusCodes.Bad_SubscriptionIdInvalid);\n        }\n        if (itemsToDelete.isEmpty()) {\n            throw new UaException(StatusCodes.Bad_NothingToDo);\n        }\n\n        StatusCode[] deleteResults = new StatusCode[itemsToDelete.size()];\n        List<BaseMonitoredItem<?>> deletedItems = newArrayListWithCapacity(itemsToDelete.size());\n\n        synchronized (subscription) {\n            for (int i = 0; i < itemsToDelete.size(); i++) {\n                UInteger itemId = itemsToDelete.get(i);\n                BaseMonitoredItem<?> item = subscription.getMonitoredItems().get(itemId);\n\n                if (item == null) {\n                    deleteResults[i] = new StatusCode(StatusCodes.Bad_MonitoredItemIdInvalid);\n                } else {\n                    deletedItems.add(item);\n\n                    deleteResults[i] = StatusCode.GOOD;\n\n                    monitoredItemCount.decrementAndGet();\n                    server.getMonitoredItemCount().decrementAndGet();\n                }\n            }\n\n            subscription.removeMonitoredItems(deletedItems);\n        }\n\n        /*\n         * Notify AddressSpaces of the items that have been deleted.\n         */\n\n        byMonitoredItemType(\n            deletedItems,\n            dataItems -> server.getAddressSpaceManager().onDataItemsDeleted(dataItems),\n            eventItems -> server.getAddressSpaceManager().onEventItemsDeleted(eventItems)\n        );\n\n        /*\n         * Build and return results.\n         */\n        ResponseHeader header = service.createResponseHeader();\n\n        DeleteMonitoredItemsResponse response = new DeleteMonitoredItemsResponse(\n            header,\n            deleteResults,\n            new DiagnosticInfo[0]\n        );\n\n        service.setResponse(response);\n    }\n\n    public void setMonitoringMode(ServiceRequest service) {\n        SetMonitoringModeRequest request = (SetMonitoringModeRequest) service.getRequest();\n        UInteger subscriptionId = request.getSubscriptionId();\n\n        try {\n            Subscription subscription = subscriptions.get(subscriptionId);\n            List<UInteger> itemsToModify = l(request.getMonitoredItemIds());\n\n            if (subscription == null) {\n                throw new UaException(StatusCodes.Bad_SubscriptionIdInvalid);\n            }\n            if (itemsToModify.isEmpty()) {\n                throw new UaException(StatusCodes.Bad_NothingToDo);\n            }\n\n            /*\n             * Set MonitoringMode on each monitored item, if it exists.\n             */\n\n            MonitoringMode monitoringMode = request.getMonitoringMode();\n            StatusCode[] results = new StatusCode[itemsToModify.size()];\n            List<MonitoredItem> modified = newArrayListWithCapacity(itemsToModify.size());\n\n            for (int i = 0; i < itemsToModify.size(); i++) {\n                UInteger itemId = itemsToModify.get(i);\n                BaseMonitoredItem<?> item = subscription.getMonitoredItems().get(itemId);\n\n                if (item != null) {\n                    item.setMonitoringMode(monitoringMode);\n\n                    modified.add(item);\n\n                    results[i] = StatusCode.GOOD;\n                } else {\n                    results[i] = new StatusCode(StatusCodes.Bad_MonitoredItemIdInvalid);\n                }\n            }\n\n            /*\n             * Notify AddressSpace of the items whose MonitoringMode has been modified.\n             */\n\n            server.getAddressSpaceManager().onMonitoringModeChanged(modified);\n\n            /*\n             * Build and return results.\n             */\n\n            ResponseHeader header = service.createResponseHeader();\n            SetMonitoringModeResponse response = new SetMonitoringModeResponse(\n                header,\n                results,\n                new DiagnosticInfo[0]\n            );\n\n            service.setResponse(response);\n        } catch (UaException e) {\n            service.setServiceFault(e);\n        }\n    }\n\n    public void publish(ServiceRequest service) {\n        PublishRequest request = (PublishRequest) service.getRequest();\n\n        SubscriptionAcknowledgement[] acknowledgements = request.getSubscriptionAcknowledgements();\n\n        if (acknowledgements != null) {\n            StatusCode[] results = new StatusCode[acknowledgements.length];\n\n            for (int i = 0; i < acknowledgements.length; i++) {\n                SubscriptionAcknowledgement acknowledgement = acknowledgements[i];\n\n                UInteger sequenceNumber = acknowledgement.getSequenceNumber();\n                UInteger subscriptionId = acknowledgement.getSubscriptionId();\n\n                Subscription subscription = subscriptions.get(subscriptionId);\n\n                if (subscription == null) {\n                    logger.debug(\n                        \"Can't acknowledge sequenceNumber={} on subscriptionId={}; id not valid for this session\",\n                        sequenceNumber,\n                        subscriptionId\n                    );\n                    results[i] = new StatusCode(StatusCodes.Bad_SubscriptionIdInvalid);\n                } else {\n                    logger.debug(\"Acknowledging sequenceNumber={} on subscriptionId={}\",\n                        sequenceNumber,\n                        subscriptionId\n                    );\n                    results[i] = subscription.acknowledge(sequenceNumber);\n                }\n            }\n\n            service.attr(KEY_ACK_RESULTS).set(results);\n        }\n\n        if (!transferred.isEmpty()) {\n            Subscription subscription = transferred.remove(0);\n            subscription.returnStatusChangeNotification(\n                service,\n                new StatusCode(StatusCodes.Good_SubscriptionTransferred)\n            );\n            return;\n        }\n\n        // waitList must also be empty because the last remaining subscription could have\n        // expired, which removes it from bookkeeping, but leaves it in the PublishQueue\n        // waitList if there were no available requests to send Bad_Timeout.\n        if (subscriptions.isEmpty() && publishQueue.isWaitListEmpty()) {\n            service.setServiceFault(StatusCodes.Bad_NoSubscription);\n            return;\n        }\n\n        publishQueue.addRequest(service);\n    }\n\n    public void republish(ServiceRequest service) {\n        RepublishRequest request = (RepublishRequest) service.getRequest();\n\n        if (subscriptions.isEmpty()) {\n            service.setServiceFault(StatusCodes.Bad_SubscriptionIdInvalid);\n            return;\n        }\n\n        UInteger subscriptionId = request.getSubscriptionId();\n        Subscription subscription = subscriptions.get(subscriptionId);\n\n        if (subscription == null) {\n            service.setServiceFault(StatusCodes.Bad_SubscriptionIdInvalid);\n            return;\n        }\n\n        UInteger sequenceNumber = request.getRetransmitSequenceNumber();\n        NotificationMessage notificationMessage = subscription.republish(sequenceNumber);\n\n        if (notificationMessage == null) {\n            service.setServiceFault(StatusCodes.Bad_MessageNotAvailable);\n            return;\n        }\n\n        ResponseHeader header = service.createResponseHeader();\n        RepublishResponse response = new RepublishResponse(header, notificationMessage);\n\n        service.setResponse(response);\n    }\n\n    public void setTriggering(ServiceRequest service) {\n        SetTriggeringRequest request = (SetTriggeringRequest) service.getRequest();\n\n        UInteger subscriptionId = request.getSubscriptionId();\n        Subscription subscription = subscriptions.get(subscriptionId);\n\n        if (subscription == null) {\n            service.setServiceFault(StatusCodes.Bad_SubscriptionIdInvalid);\n            return;\n        }\n\n        UInteger triggerId = request.getTriggeringItemId();\n        List<UInteger> linksToAdd = l(request.getLinksToAdd());\n        List<UInteger> linksToRemove = l(request.getLinksToRemove());\n\n        if (linksToAdd.isEmpty() && linksToRemove.isEmpty()) {\n            service.setServiceFault(StatusCodes.Bad_NothingToDo);\n            return;\n        }\n\n        StatusCode[] addResults;\n        StatusCode[] removeResults;\n\n        synchronized (subscription) {\n            Map<UInteger, BaseMonitoredItem<?>> itemsById = subscription.getMonitoredItems();\n\n            BaseMonitoredItem<?> triggerItem = itemsById.get(triggerId);\n            if (triggerItem == null) {\n                service.setServiceFault(StatusCodes.Bad_MonitoredItemIdInvalid);\n                return;\n            }\n\n            removeResults = linksToRemove.stream()\n                .map(linkedItemId -> {\n                    BaseMonitoredItem<?> item = itemsById.get(linkedItemId);\n                    if (item != null) {\n                        if (triggerItem.getTriggeredItems().remove(linkedItemId) != null) {\n                            return StatusCode.GOOD;\n                        } else {\n                            return new StatusCode(StatusCodes.Bad_MonitoredItemIdInvalid);\n                        }\n                    } else {\n                        return new StatusCode(StatusCodes.Bad_MonitoredItemIdInvalid);\n                    }\n                })\n                .toArray(StatusCode[]::new);\n\n            addResults = linksToAdd.stream()\n                .map(linkedItemId -> {\n                    BaseMonitoredItem<?> linkedItem = itemsById.get(linkedItemId);\n                    if (linkedItem != null) {\n                        triggerItem.getTriggeredItems().put(linkedItemId, linkedItem);\n                        return StatusCode.GOOD;\n                    } else {\n                        return new StatusCode(StatusCodes.Bad_MonitoredItemIdInvalid);\n                    }\n                })\n                .toArray(StatusCode[]::new);\n        }\n\n        SetTriggeringResponse response = new SetTriggeringResponse(\n            service.createResponseHeader(),\n            addResults,\n            new DiagnosticInfo[0],\n            removeResults,\n            new DiagnosticInfo[0]\n        );\n\n        service.setResponse(response);\n    }\n\n    public void sessionClosed(boolean deleteSubscriptions) {\n        Iterator<Subscription> iterator = subscriptions.values().iterator();\n\n        while (iterator.hasNext()) {\n            Subscription s = iterator.next();\n            s.setStateListener(null);\n\n            if (deleteSubscriptions) {\n                server.getSubscriptions().remove(s.getId());\n                server.getEventBus().post(new SubscriptionDeletedEvent(s));\n\n                List<BaseMonitoredItem<?>> deletedItems = s.deleteSubscription();\n\n                /*\n                 * Notify AddressSpaces the items for this subscription are deleted.\n                 */\n\n                byMonitoredItemType(\n                    deletedItems,\n                    dataItems -> server.getAddressSpaceManager().onDataItemsDeleted(dataItems),\n                    eventItems -> server.getAddressSpaceManager().onEventItemsDeleted(eventItems)\n                );\n\n                monitoredItemCount.getAndUpdate(count -> count - deletedItems.size());\n                server.getMonitoredItemCount().getAndUpdate(count -> count - deletedItems.size());\n            }\n\n            iterator.remove();\n        }\n\n        if (deleteSubscriptions) {\n            while (publishQueue.isNotEmpty()) {\n                ServiceRequest publishService = publishQueue.poll();\n                if (publishService != null) {\n                    publishService.setServiceFault(StatusCodes.Bad_SessionClosed);\n                }\n            }\n        }\n    }\n\n    /**\n     * Add (transfer) {@code subscription} to this {@link SubscriptionManager}.\n     *\n     * @param subscription the {@link Subscription} to add.\n     */\n    public void addSubscription(Subscription subscription) {\n        subscriptions.put(subscription.getId(), subscription);\n        server.getEventBus().post(new SubscriptionCreatedEvent(subscription));\n\n        subscription.setStateListener((s, ps, cs) -> {\n            if (cs == State.Closing) {\n                subscriptions.remove(s.getId());\n                server.getSubscriptions().remove(s.getId());\n                server.getEventBus().post(new SubscriptionDeletedEvent(s));\n\n                /*\n                 * Notify AddressSpaces the items for this subscription are deleted.\n                 */\n\n                Map<UInteger, BaseMonitoredItem<?>> monitoredItems = s.getMonitoredItems();\n\n                byMonitoredItemType(\n                    monitoredItems.values(),\n                    dataItems -> server.getAddressSpaceManager().onDataItemsDeleted(dataItems),\n                    eventItems -> server.getAddressSpaceManager().onEventItemsDeleted(eventItems)\n                );\n\n                monitoredItemCount.getAndUpdate(count -> count - monitoredItems.size());\n                server.getMonitoredItemCount().getAndUpdate(count -> count - monitoredItems.size());\n\n                monitoredItems.clear();\n            }\n        });\n    }\n\n    /**\n     * Remove (transfer from) the Subscription by {@code subscriptionId} from this {@link SubscriptionManager}.\n     *\n     * @param subscriptionId the id of the {@link Subscription} to remove.\n     * @return the removed {@link Subscription}.\n     */\n    public Subscription removeSubscription(UInteger subscriptionId) {\n        Subscription subscription = subscriptions.remove(subscriptionId);\n        server.getEventBus().post(new SubscriptionDeletedEvent(subscription));\n\n        if (subscription != null) {\n            subscription.setStateListener(null);\n\n            monitoredItemCount.getAndUpdate(count -> count - subscription.getMonitoredItems().size());\n        }\n\n        return subscription;\n    }\n\n    public void sendStatusChangeNotification(Subscription subscription, StatusCode status) {\n        ServiceRequest service = publishQueue.poll();\n\n        if (service != null) {\n            subscription.returnStatusChangeNotification(service, status);\n        } else {\n            transferred.add(subscription);\n        }\n    }\n\n    /**\n     * Split {@code monitoredItems} into a list of {@link DataItem}s and a list of {@link EventItem}s and invoke the\n     * corresponding {@link Consumer} for each list if non-empty.\n     *\n     * @param monitoredItems    the list of MonitoredItems to group.\n     * @param dataItemConsumer  a {@link Consumer} that accepts a non-empty list of {@link DataItem}s.\n     * @param eventItemConsumer a {@link Consumer} that accepts a non-empty list of {@link EventItem}s.\n     */\n    private static void byMonitoredItemType(\n        Collection<BaseMonitoredItem<?>> monitoredItems,\n        Consumer<List<DataItem>> dataItemConsumer,\n        Consumer<List<EventItem>> eventItemConsumer\n    ) {\n\n        List<DataItem> dataItems = Lists.newArrayList();\n        List<EventItem> eventItems = Lists.newArrayList();\n\n        for (BaseMonitoredItem<?> item : monitoredItems) {\n            if (item instanceof MonitoredDataItem) {\n                dataItems.add((DataItem) item);\n            } else if (item instanceof MonitoredEventItem) {\n                eventItems.add((EventItem) item);\n            }\n        }\n\n        try {\n            if (!dataItems.isEmpty()) {\n                dataItemConsumer.accept(dataItems);\n            }\n        } catch (Throwable t) {\n            LoggerFactory.getLogger(SubscriptionManager.class)\n                .error(\"Uncaught Throwable in dataItemConsumer\", t);\n        }\n\n        try {\n            if (!eventItems.isEmpty()) {\n                eventItemConsumer.accept(eventItems);\n            }\n        } catch (Throwable t) {\n            LoggerFactory.getLogger(SubscriptionManager.class)\n                .error(\"Uncaught Throwable in eventItemConsumer\", t);\n        }\n    }\n\n    /**\n     * @return {@code true} if {@code dataTypeId} is a subtype of {@code potentialSuperTypeId}.\n     */\n    private static boolean subtypeOf(OpcUaServer server, NodeId dataTypeId, NodeId potentialSuperTypeId) {\n        UaNode dataTypeNode = server.getAddressSpaceManager()\n            .getManagedNode(dataTypeId)\n            .orElse(null);\n\n        if (dataTypeNode != null) {\n            NodeId superTypeId = getSuperTypeId(server, dataTypeId);\n\n            if (superTypeId != null) {\n                return superTypeId.equals(potentialSuperTypeId) ||\n                    subtypeOf(server, superTypeId, potentialSuperTypeId);\n            } else {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    }\n\n    @Nullable\n    private static NodeId getSuperTypeId(OpcUaServer server, NodeId dataTypeId) {\n        UaNode dataTypeNode = server.getAddressSpaceManager()\n            .getManagedNode(dataTypeId)\n            .orElse(null);\n\n        if (dataTypeNode != null) {\n            return dataTypeNode.getReferences()\n                .stream()\n                .filter(Reference.SUBTYPE_OF)\n                .flatMap(r -> opt2stream(r.getTargetNodeId().toNodeId(server.getNamespaceTable())))\n                .findFirst()\n                .orElse(null);\n        } else {\n            return null;\n        }\n    }\n\n    private static class AttributeGroup {\n        final DataValue accessLevelValue;\n        final DataValue userAccessLevelValue;\n        final DataValue eventNotifierValue;\n        final DataValue minimumSamplingIntervalValue;\n        final DataValue dataType;\n\n        AttributeGroup(\n            DataValue accessLevelValue,\n            DataValue userAccessLevelValue,\n            DataValue eventNotifierValue,\n            DataValue minimumSamplingIntervalValue,\n            DataValue dataType\n        ) {\n\n            this.accessLevelValue = accessLevelValue;\n            this.userAccessLevelValue = userAccessLevelValue;\n            this.eventNotifierValue = eventNotifierValue;\n            this.minimumSamplingIntervalValue = minimumSamplingIntervalValue;\n            this.dataType = dataType;\n        }\n\n        @Nullable\n        UByte getAccessLevel() throws UaException {\n            Object value = getValue(accessLevelValue);\n\n            if (value instanceof UByte) {\n                return (UByte) value;\n            } else {\n                return null;\n            }\n        }\n\n        @Nullable\n        UByte getUserAccessLevel() throws UaException {\n            Object value = getValue(userAccessLevelValue);\n\n            if (value instanceof UByte) {\n                return (UByte) value;\n            } else {\n                return null;\n            }\n        }\n\n        @Nullable\n        UByte getEventNotifier() throws UaException {\n            Object value = getValue(eventNotifierValue);\n\n            if (value instanceof UByte) {\n                return (UByte) value;\n            } else {\n                return null;\n            }\n        }\n\n        @Nullable\n        Double getMinimumSamplingInterval() throws UaException {\n            Object value = getValue(minimumSamplingIntervalValue);\n\n            if (value instanceof Double) {\n                return (Double) value;\n            } else {\n                return null;\n            }\n        }\n\n        @Nullable\n        NodeId getDataType() throws UaException {\n            Object value = getValue(dataType);\n\n            if (value instanceof NodeId) {\n                return (NodeId) value;\n            } else {\n                return null;\n            }\n        }\n\n        private Object getValue(DataValue dataValue) throws UaException {\n            StatusCode statusCode = dataValue.getStatusCode();\n\n            if (statusCode == null) {\n                throw new UaException(StatusCode.BAD);\n            }\n\n            if (statusCode.isBad()) {\n                throw new UaException(statusCode);\n            }\n\n            return dataValue.getValue().getValue();\n        }\n    }\n\n}\n\n\n\n\n\n\n"], "filenames": ["opc-ua-sdk/sdk-server/src/main/java/org/eclipse/milo/opcua/sdk/server/api/config/OpcUaServerConfigLimits.java", "opc-ua-sdk/sdk-server/src/main/java/org/eclipse/milo/opcua/sdk/server/subscriptions/SubscriptionManager.java"], "buggy_code_start_loc": [114, 124], "buggy_code_end_loc": [114, 1314], "fixing_code_start_loc": [115, 125], "fixing_code_end_loc": [124, 1332], "type": "CWE-770", "message": "The package org.eclipse.milo:sdk-server before 0.6.8 are vulnerable to Denial of Service (DoS) when bypassing the limitations for excessive memory consumption by sending multiple CloseSession requests with the deleteSubscription parameter equal to False.", "other": {"cve": {"id": "CVE-2022-25897", "sourceIdentifier": "report@snyk.io", "published": "2022-09-08T05:15:07.410", "lastModified": "2022-09-13T20:17:37.290", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The package org.eclipse.milo:sdk-server before 0.6.8 are vulnerable to Denial of Service (DoS) when bypassing the limitations for excessive memory consumption by sending multiple CloseSession requests with the deleteSubscription parameter equal to False."}, {"lang": "es", "value": "El paquete org.eclipse.milo:sdk-server versiones anteriores a 0.6.8, es vulnerable a una Denegaci\u00f3n de Servicio (DoS) al omitir las limitaciones por consumo excesivo de memoria mediante el env\u00edo de varias peticiones CloseSession con el par\u00e1metro deleteSubscription igual a False"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-770"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:eclipse:milo:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.6.8", "matchCriteriaId": "21638D30-0B3C-4457-BEBC-022ACACE81A5"}]}]}], "references": [{"url": "https://github.com/eclipse/milo/commit/4534381760d7d9f0bf00cbf6a8449bb0d13c6ce5", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/eclipse/milo/issues/1030", "source": "report@snyk.io", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/eclipse/milo/pull/1031", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.snyk.io/vuln/SNYK-JAVA-ORGECLIPSEMILO-2990191", "source": "report@snyk.io", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/eclipse/milo/commit/4534381760d7d9f0bf00cbf6a8449bb0d13c6ce5"}}