{"buggy_code": ["{\n\t\"name\": \"git-interface\",\n\t\"version\": \"2.1.1\",\n\t\"description\": \"some interfaces for work with git repository\",\n\t\"main\": \"dist/index\",\n\t\"typings\": \"dist/index\",\n\t\"scripts\": {\n\t\t\"clean\": \"rm -rf ./dist\",\n\t\t\"build\": \"npm run clean && npm run ts\",\n\t\t\"dev\": \"npm run clean &&  ./node_modules/.bin/tsc -w\",\n\t\t\"ts\": \"./node_modules/.bin/tsc\",\n\t\t\"prepublish\": \"npm run build\"\n\t},\n\t\"repository\": {\n\t\t\"type\": \"git\",\n\t\t\"url\": \"git://github.com/yarkeev/git-interface.git\"\n\t},\n\t\"keywords\": [\n\t\t\"git\",\n\t\t\"hash\",\n\t\t\"pull\",\n\t\t\"push\",\n\t\t\"commit\",\n\t\t\"last changes\",\n\t\t\"checkout\",\n\t\t\"merge\",\n\t\t\"conflicts\",\n\t\t\"cvs\"\n\t],\n\t\"author\": \"Yarkeev Denis <denis.yarkeev@gmail.com>\",\n\t\"license\": \"MIT\",\n\t\"bugs\": {\n\t\t\"url\": \"https://github.com/yarkeev/git-interface/issues\"\n\t},\n\t\"homepage\": \"https://github.com/yarkeev/git-interface\",\n\t\"devDependencies\": {\n\t\t\"@types/node\": \"^10.10.3\",\n\t\t\"typescript\": \"^3.0.3\"\n\t}\n}\n", "import { EventEmitter } from 'events';\nimport { spawn } from 'child_process';\n\nexport interface IGitOptions {\n\tdir: string;\n}\n\nexport class Git extends EventEmitter{\n\n\tprotected options: IGitOptions;\n\tprotected dir: string = '.';\n\n\tconstructor(options: IGitOptions) {\n\t\tsuper();\n\n\t\tthis.options = options;\n\n\t\tthis.setDir(this.options.dir);\n\t}\n\n\tprotected async gitExec(cmd: string): Promise<string> {\n\t\treturn new Promise<string>((resolve, reject) => {\n\t\t\tconst splitRegex = /'[^']+'|[^\\s]+/g;\n\t\t\tconst commandArgs = cmd.match(splitRegex).map(e => e.replace(/'(.+)'/, \"'$1'\"));\n\t\t\tconst child = spawn('git', commandArgs, { cwd: this.dir });\n\t\t\tlet out = '';\n\n\t\t\tchild.stdout.on('data', (data) => { out += data.toString(); this.emit('out', data.toString()); });\n\t\t\tchild.stdout.on('error', (data) => { out += data.toString(); this.emit('out', data.toString()); });\n\t\t\tchild.stderr.on('data', (data) => { out += data.toString(); this.emit('out', data.toString()); });\n\t\t\tchild.stderr.on('error', (data) => { out += data.toString(); this.emit('out', data.toString()); });\n\n\t\t\tchild.on('close', (code: number, signal: string) => {\n\t\t\t\tif (code === 0) {\n\t\t\t\t\tresolve(out);\n\t\t\t\t} else {\n\t\t\t\t\treject(new Error(out));\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\tprotected getDiffFileList(diffOptions: string = ''): Promise<string[]> {\n\t\treturn new Promise(async (resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tconst conflicts = await this.gitExec(`diff ${diffOptions}`);\n\n\t\t\t\tresolve(conflicts.split('\\n').filter(item => item.trim().length > 0));\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic init(): Promise<string> {\n\t\treturn this.gitExec('init');\n\t}\n\n\tpublic setDir(dir: string) {\n\t\tthis.dir = dir;\n\t}\n\n\tpublic clone(repository: string, dest: string, options?: { depth?: number}) {\n\n\t\tconst opt = options || { depth: Infinity }\n\n\t\tconst depthOption = opt.depth !== Infinity ? ` --depth=${opt.depth}` : '';\n\n\t\treturn this.gitExec(`clone ${repository} ${dest}${depthOption}`);\n\t}\n\n\tpublic checkout(branchName: string) {\n\t\treturn this.gitExec(`checkout ${branchName}`);\n\t}\n\n\t/**\n\t * Updates the git submodules.\n\t *\n\t * @param init initialize not-yet initialized submodules (--init), true by default\n\t * @param recursive whether to update the nested submodules (--recursive), true by default\n\t */\n\tpublic updateSubmodules(init: boolean = true, recursive: boolean = true) {\n\t\tlet command = `submodule update`;\n\t\tif (init) {\n\t\t\tcommand += ` --init`;\n\t\t}\n\t\tif (recursive) {\n\t\t\tcommand += ` --recursive`;\n\t\t}\n\t\treturn this.gitExec(command);\n\t}\n\n\tpublic commit(message: string, all: boolean = false) {\n\t\tconst escapedMessage = message.replace(/'/g, \"\\\\'\");\n\t\tconst allOption = all ? 'a' : ''\n\t\treturn this.gitExec(`commit -${allOption}m '${escapedMessage}'`);\n\t}\n\n\tpublic pull(remote = 'origin', options?: { branch?: string, rebase?: boolean }) {\n\t\treturn new Promise(async (resolve, reject) => {\n\t\t\tconst opts = options || {};\n\t\t\ttry {\n\t\t\t\tlet branch;\n\t\t\t\tif(opts.branch){\n\t\t\t\t\tbranch = opts.branch\n\t\t\t\t}else{\n\t\t\t\t\tbranch = await this.getBranchName();\n\t\t\t\t}\n\n\t\t\t\tconst rebaseOpt = opts.rebase ? ' -r' : '';\n\n\t\t\t\tawait this.gitExec(`pull ${remote} ${branch}${rebaseOpt}`);\n\n\t\t\t\tresolve()\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic push(remote?: string) {\n\t\treturn new Promise(async (resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tconst branch = await this.getBranchName();\n\n\t\t\t\tawait this.gitExec(`push ${remote || 'origin'} ${branch}`);\n\n\t\t\t\tresolve()\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic add() {\n\t\treturn this.gitExec(`add -A`);\n\t}\n\n\tpublic addRemote(name: string, url: string) {\n\t\treturn this.gitExec(`remote add ${name} ${url}`);\n\t}\n\n\tpublic setRemote(name: string, url: string){\n\t\treturn this.gitExec(`remote set-url ${name} ${url}`);\n\t}\n\n\tpublic merge(branchName: string, mergeOptions?: string) {\n\t\treturn this.gitExec(`merge ${branchName} ${mergeOptions}`)\n\t}\n\n\tpublic fetch() {\n\t\treturn this.gitExec(`fetch`);\n\t}\n\n\tpublic reset() {\n\t\treturn this.gitExec(`reset --hard HEAD`);\n\t}\n\n\tpublic getHash(fileName: string) {\n\t\treturn new Promise(async (resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tconst result = await this.gitExec(`log -n 1 --pretty=\"%H\" -- ${fileName}`);\n\n\t\t\t\tresolve(result.replace(/\"/g, ''));\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic diffMaster(fileName: string) {\n\t\treturn this.gitExec(`diff master -- ${fileName}`);\n\t}\n\n\tpublic getBranchName() {\n\t\treturn new Promise(async (resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tconst result: string = await this.gitExec(`branch`);\n\n\t\t\t\tresolve(result.split('\\n').find(item => item.indexOf('*') === 0).replace(/\\*/g, '').trim());\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic createBranch(branchName: string) {\n\t\treturn this.gitExec(`checkout -b ${branchName}`);\n\t}\n\n\tpublic deleteBranch(branchName: string) {\n\t\treturn this.gitExec(`branch -D ${branchName}`);\n\t}\n\n\tpublic getDiffByRevisionFileList(revision: string): Promise<string[]> {\n\t\treturn this.getDiffFileList(`${revision} --name-only`);\n\t}\n\n\tpublic getConflictList(): Promise<string[]> {\n\t\treturn this.getDiffFileList(`--name-only --diff-filter=U`);\n\t}\n\n\tpublic getUncommittedList(): Promise<string[]> {\n\t\treturn this.getDiffFileList(`--name-only`);\n\t}\n\n\tpublic getLastChanges() {\n\t\treturn new Promise(async (resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tconst hash = await this.gitExec(`log -n 2 --pretty=\"%H\"`);\n\t\t\t\tlet lastOtherHash = hash.split('\\n')[1];\n\n\t\t\t\tif (!lastOtherHash) {\n\t\t\t\t\tlastOtherHash = hash.slice(hash.length / 2);\n\t\t\t\t}\n\n\t\t\t\tlastOtherHash = lastOtherHash.replace(/\"/g, '');\n\n\t\t\t\tconst lastChanges = await this.gitExec(`difftool ${lastOtherHash} --name-status`);\n\n\t\t\t\tresolve(lastChanges);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic removeLocalBranch(branchName: string) {\n\t\treturn this.gitExec(`branch -D ${branchName}`);\n\t}\n\n\tpublic removeRemoteBranch(branchName: string) {\n\t\treturn this.gitExec(`push origin --delete ${branchName}`);\n\t}\n\n\tpublic getLocalBranchList() {\n\t\treturn new Promise(async (resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tconst result = await this.gitExec(`branch`);\n\t\t\t\tconst branches = result.split('\\n')\n\t\t\t\t\t.map((item: string) => item.replace(/^\\s*\\*/, '').trim())\n\t\t\t\t\t.filter((item: string) => item.length > 0);\n\n\t\t\t\tresolve(branches);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic getRemoteBranchList() {\n\t\treturn new Promise(async (resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tconst result = await this.gitExec(`branch -r`);\n\t\t\t\tconst branches = result.split('\\n')\n\t\t\t\t\t.filter((item: string) => item.length > 0 && item.indexOf('origin/HEAD') === -1)\n\t\t\t\t\t.map((item: string) => item.replace(/^\\s*\\*/, '').replace('origin/', '').trim());\n\n\t\t\t\tresolve(branches);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic getRemotes(): Promise<string[]> {\n\t\treturn new Promise(async (resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tconst result = await this.gitExec(`remote`);\n\t\t\t\tconst remoteNames = result\n\t\t\t\t\t.split('\\n')\n\t\t\t\t\t.map((item: string) => item.trim());\n\n\t\t\t\tresolve(remoteNames);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic async getRemoteUrl(name: string): Promise<string> {\n\t\tconst result = await this.gitExec(`remote get-url ${name}`);\n\t\treturn result.trim();\n\t}\n\n\tpublic getTimeOfLastCommit(branchName: string) {\n\t\treturn new Promise(async (resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tconst result = await this.gitExec(`show --format='%ci' ${branchName}`);\n\t\t\t\tconst dateTimeStr = result.split('\\n')[0].split(' ');\n\t\t\t\tconst date = new Date(`${dateTimeStr[0]} ${dateTimeStr[1]} ${dateTimeStr[2]}`);\n\n\t\t\t\tresolve(date.getTime());\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic getHashOfLastCommit(branchName: string) {\n\t\treturn new Promise(async (resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tconst result = await this.gitExec(`log ${branchName} --pretty=\"%H\"`);\n\n\t\t\t\tresolve(result.split('\\n')[0].replace(/\"/g, ''));\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t}\n\n}"], "fixing_code": ["{\n\t\"name\": \"git-interface\",\n\t\"version\": \"2.1.2\",\n\t\"description\": \"some interfaces for work with git repository\",\n\t\"main\": \"dist/index\",\n\t\"typings\": \"dist/index\",\n\t\"scripts\": {\n\t\t\"clean\": \"rm -rf ./dist\",\n\t\t\"build\": \"npm run clean && npm run ts\",\n\t\t\"dev\": \"npm run clean &&  ./node_modules/.bin/tsc -w\",\n\t\t\"ts\": \"./node_modules/.bin/tsc\",\n\t\t\"prepublishOnly\": \"npm run build && bump\"\n\t},\n\t\"repository\": {\n\t\t\"type\": \"git\",\n\t\t\"url\": \"git://github.com/yarkeev/git-interface.git\"\n\t},\n\t\"keywords\": [\n\t\t\"git\",\n\t\t\"hash\",\n\t\t\"pull\",\n\t\t\"push\",\n\t\t\"commit\",\n\t\t\"last changes\",\n\t\t\"checkout\",\n\t\t\"merge\",\n\t\t\"conflicts\",\n\t\t\"cvs\"\n\t],\n\t\"author\": \"Yarkeev Denis <denis.yarkeev@gmail.com>\",\n\t\"license\": \"MIT\",\n\t\"bugs\": {\n\t\t\"url\": \"https://github.com/yarkeev/git-interface/issues\"\n\t},\n\t\"homepage\": \"https://github.com/yarkeev/git-interface\",\n\t\"devDependencies\": {\n\t\t\"@types/node\": \"^10.10.3\",\n\t\t\"typescript\": \"^3.0.3\",\n\t\t\"version-bump-prompt\": \"^6.1.0\"\n\t}\n}\n", "import { EventEmitter } from 'events';\nimport { spawn } from 'child_process';\n\nexport interface IGitOptions {\n\tdir: string;\n}\n\nexport class Git extends EventEmitter{\n\n\tprotected options: IGitOptions;\n\tprotected dir: string = '.';\n\n\tconstructor(options: IGitOptions) {\n\t\tsuper();\n\n\t\tthis.options = options;\n\n\t\tthis.setDir(this.options.dir);\n\t}\n\n\tprotected async gitExec(cmd: string): Promise<string> {\n\t\treturn new Promise<string>((resolve, reject) => {\n\t\t\tconst splitRegex = /'[^']+'|[^\\s]+/g;\n\t\t\tconst commandArgs = cmd.match(splitRegex).map(e => e.replace(/'(.+)'/, \"'$1'\"));\n\t\t\tconst child = spawn('git', commandArgs, { cwd: this.dir });\n\t\t\tlet out = '';\n\n\t\t\tchild.stdout.on('data', (data) => { out += data.toString(); this.emit('out', data.toString()); });\n\t\t\tchild.stdout.on('error', (data) => { out += data.toString(); this.emit('out', data.toString()); });\n\t\t\tchild.stderr.on('data', (data) => { out += data.toString(); this.emit('out', data.toString()); });\n\t\t\tchild.stderr.on('error', (data) => { out += data.toString(); this.emit('out', data.toString()); });\n\n\t\t\tchild.on('close', (code: number, signal: string) => {\n\t\t\t\tif (code === 0) {\n\t\t\t\t\tresolve(out);\n\t\t\t\t} else {\n\t\t\t\t\treject(new Error(out));\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\tprotected getDiffFileList(diffOptions: string = ''): Promise<string[]> {\n\t\treturn new Promise(async (resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tconst conflicts = await this.gitExec(`diff ${diffOptions}`);\n\n\t\t\t\tresolve(conflicts.split('\\n').filter(item => item.trim().length > 0));\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic init(): Promise<string> {\n\t\treturn this.gitExec('init');\n\t}\n\n\tpublic setDir(dir: string) {\n\t\tthis.dir = dir;\n\t}\n\n\tpublic clone(repository: string, dest: string, options?: { depth?: number}) {\n\t\tconst opt = options || { depth: Infinity }\n\t\tconst depthOption = opt.depth !== Infinity ? `--depth=${opt.depth}` : '';\n\n\t\treturn this.gitExec(`clone ${depthOption} -- ${repository} ${dest}`);\n\t}\n\n\tpublic checkout(branchName: string) {\n\t\treturn this.gitExec(`checkout ${branchName}`);\n\t}\n\n\t/**\n\t * Updates the git submodules.\n\t *\n\t * @param init initialize not-yet initialized submodules (--init), true by default\n\t * @param recursive whether to update the nested submodules (--recursive), true by default\n\t */\n\tpublic updateSubmodules(init: boolean = true, recursive: boolean = true) {\n\t\tlet command = `submodule update`;\n\t\tif (init) {\n\t\t\tcommand += ` --init`;\n\t\t}\n\t\tif (recursive) {\n\t\t\tcommand += ` --recursive`;\n\t\t}\n\t\treturn this.gitExec(command);\n\t}\n\n\tpublic commit(message: string, all: boolean = false) {\n\t\tconst escapedMessage = message.replace(/'/g, \"\\\\'\");\n\t\tconst allOption = all ? 'a' : ''\n\t\treturn this.gitExec(`commit -${allOption}m '${escapedMessage}'`);\n\t}\n\n\tpublic pull(remote = 'origin', options?: { branch?: string, rebase?: boolean }) {\n\t\treturn new Promise(async (resolve, reject) => {\n\t\t\tconst opts = options || {};\n\t\t\ttry {\n\t\t\t\tlet branch;\n\t\t\t\tif(opts.branch){\n\t\t\t\t\tbranch = opts.branch\n\t\t\t\t}else{\n\t\t\t\t\tbranch = await this.getBranchName();\n\t\t\t\t}\n\n\t\t\t\tconst rebaseOpt = opts.rebase ? ' -r' : '';\n\n\t\t\t\tawait this.gitExec(`pull ${remote} ${branch}${rebaseOpt}`);\n\n\t\t\t\tresolve()\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic push(remote?: string) {\n\t\treturn new Promise(async (resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tconst branch = await this.getBranchName();\n\n\t\t\t\tawait this.gitExec(`push ${remote || 'origin'} ${branch}`);\n\n\t\t\t\tresolve()\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic add() {\n\t\treturn this.gitExec(`add -A`);\n\t}\n\n\tpublic addRemote(name: string, url: string) {\n\t\treturn this.gitExec(`remote add ${name} ${url}`);\n\t}\n\n\tpublic setRemote(name: string, url: string){\n\t\treturn this.gitExec(`remote set-url ${name} ${url}`);\n\t}\n\n\tpublic merge(branchName: string, mergeOptions?: string) {\n\t\treturn this.gitExec(`merge ${branchName} ${mergeOptions}`)\n\t}\n\n\tpublic fetch() {\n\t\treturn this.gitExec(`fetch`);\n\t}\n\n\tpublic reset() {\n\t\treturn this.gitExec(`reset --hard HEAD`);\n\t}\n\n\tpublic getHash(fileName: string) {\n\t\treturn new Promise(async (resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tconst result = await this.gitExec(`log -n 1 --pretty=\"%H\" -- ${fileName}`);\n\n\t\t\t\tresolve(result.replace(/\"/g, ''));\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic diffMaster(fileName: string) {\n\t\treturn this.gitExec(`diff master -- ${fileName}`);\n\t}\n\n\tpublic getBranchName() {\n\t\treturn new Promise(async (resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tconst result: string = await this.gitExec(`branch`);\n\n\t\t\t\tresolve(result.split('\\n').find(item => item.indexOf('*') === 0).replace(/\\*/g, '').trim());\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic createBranch(branchName: string) {\n\t\treturn this.gitExec(`checkout -b ${branchName}`);\n\t}\n\n\tpublic deleteBranch(branchName: string) {\n\t\treturn this.gitExec(`branch -D ${branchName}`);\n\t}\n\n\tpublic getDiffByRevisionFileList(revision: string): Promise<string[]> {\n\t\treturn this.getDiffFileList(`${revision} --name-only`);\n\t}\n\n\tpublic getConflictList(): Promise<string[]> {\n\t\treturn this.getDiffFileList(`--name-only --diff-filter=U`);\n\t}\n\n\tpublic getUncommittedList(): Promise<string[]> {\n\t\treturn this.getDiffFileList(`--name-only`);\n\t}\n\n\tpublic getLastChanges() {\n\t\treturn new Promise(async (resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tconst hash = await this.gitExec(`log -n 2 --pretty=\"%H\"`);\n\t\t\t\tlet lastOtherHash = hash.split('\\n')[1];\n\n\t\t\t\tif (!lastOtherHash) {\n\t\t\t\t\tlastOtherHash = hash.slice(hash.length / 2);\n\t\t\t\t}\n\n\t\t\t\tlastOtherHash = lastOtherHash.replace(/\"/g, '');\n\n\t\t\t\tconst lastChanges = await this.gitExec(`difftool ${lastOtherHash} --name-status`);\n\n\t\t\t\tresolve(lastChanges);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic removeLocalBranch(branchName: string) {\n\t\treturn this.gitExec(`branch -D ${branchName}`);\n\t}\n\n\tpublic removeRemoteBranch(branchName: string) {\n\t\treturn this.gitExec(`push origin --delete ${branchName}`);\n\t}\n\n\tpublic getLocalBranchList() {\n\t\treturn new Promise(async (resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tconst result = await this.gitExec(`branch`);\n\t\t\t\tconst branches = result.split('\\n')\n\t\t\t\t\t.map((item: string) => item.replace(/^\\s*\\*/, '').trim())\n\t\t\t\t\t.filter((item: string) => item.length > 0);\n\n\t\t\t\tresolve(branches);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic getRemoteBranchList() {\n\t\treturn new Promise(async (resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tconst result = await this.gitExec(`branch -r`);\n\t\t\t\tconst branches = result.split('\\n')\n\t\t\t\t\t.filter((item: string) => item.length > 0 && item.indexOf('origin/HEAD') === -1)\n\t\t\t\t\t.map((item: string) => item.replace(/^\\s*\\*/, '').replace('origin/', '').trim());\n\n\t\t\t\tresolve(branches);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic getRemotes(): Promise<string[]> {\n\t\treturn new Promise(async (resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tconst result = await this.gitExec(`remote`);\n\t\t\t\tconst remoteNames = result\n\t\t\t\t\t.split('\\n')\n\t\t\t\t\t.map((item: string) => item.trim());\n\n\t\t\t\tresolve(remoteNames);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic async getRemoteUrl(name: string): Promise<string> {\n\t\tconst result = await this.gitExec(`remote get-url ${name}`);\n\t\treturn result.trim();\n\t}\n\n\tpublic getTimeOfLastCommit(branchName: string) {\n\t\treturn new Promise(async (resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tconst result = await this.gitExec(`show --format='%ci' ${branchName}`);\n\t\t\t\tconst dateTimeStr = result.split('\\n')[0].split(' ');\n\t\t\t\tconst date = new Date(`${dateTimeStr[0]} ${dateTimeStr[1]} ${dateTimeStr[2]}`);\n\n\t\t\t\tresolve(date.getTime());\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic getHashOfLastCommit(branchName: string) {\n\t\treturn new Promise(async (resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tconst result = await this.gitExec(`log ${branchName} --pretty=\"%H\"`);\n\n\t\t\t\tresolve(result.split('\\n')[0].replace(/\"/g, ''));\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t}\n\n}\n"], "filenames": ["package.json", "src/index.ts"], "buggy_code_start_loc": [3, 64], "buggy_code_end_loc": [39, 313], "fixing_code_start_loc": [3, 63], "fixing_code_end_loc": [40, 311], "type": "CWE-78", "message": "Command Injection vulnerability in git-interface@2.1.1 in GitHub repository yarkeev/git-interface prior to 2.1.2. If both are provided by user input, then the use of a `--upload-pack` command-line argument feature of git is also supported for `git clone`, which would then allow for any operating system command to be spawned by the attacker.", "other": {"cve": {"id": "CVE-2022-1440", "sourceIdentifier": "security@huntr.dev", "published": "2022-04-22T18:15:07.917", "lastModified": "2022-05-04T16:27:47.323", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Command Injection vulnerability in git-interface@2.1.1 in GitHub repository yarkeev/git-interface prior to 2.1.2. If both are provided by user input, then the use of a `--upload-pack` command-line argument feature of git is also supported for `git clone`, which would then allow for any operating system command to be spawned by the attacker."}, {"lang": "es", "value": "Una vulnerabilidad de inyecci\u00f3n de comandos en git-interface@2.1.1 en el repositorio de GitHub yarkeev/git-interface versiones anteriores a 2.1.2. Si ambos son proporcionados por la entrada del usuario, entonces el uso de una caracter\u00edstica de argumento de l\u00ednea de comandos \"--upload-pack\" de git tambi\u00e9n es compatible con \"git clone\", lo que permitir\u00eda entonces que cualquier comando del sistema operativo sea generado por el atacante"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 10.0}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-78"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-78"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:git-interface_project:git-interface:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "2.1.2", "matchCriteriaId": "93E7C8D7-20AB-4765-A009-84DFF68FE96E"}]}]}], "references": [{"url": "https://github.com/yarkeev/git-interface/commit/f828aa790016fee3aa667f7b44cf94bf0aa8c60d", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/cdc25408-d3c1-4a9d-bb45-33b12a715ca1", "source": "security@huntr.dev", "tags": ["Exploit", "Mitigation", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/yarkeev/git-interface/commit/f828aa790016fee3aa667f7b44cf94bf0aa8c60d"}}