{"buggy_code": ["/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) 1998 - 2021, Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n ***************************************************************************/\n\n#include \"curl_setup.h\"\n\n#ifndef CURL_DISABLE_TELNET\n\n#ifdef HAVE_NETINET_IN_H\n#include <netinet/in.h>\n#endif\n#ifdef HAVE_NETDB_H\n#include <netdb.h>\n#endif\n#ifdef HAVE_ARPA_INET_H\n#include <arpa/inet.h>\n#endif\n#ifdef HAVE_NET_IF_H\n#include <net/if.h>\n#endif\n#ifdef HAVE_SYS_IOCTL_H\n#include <sys/ioctl.h>\n#endif\n\n#ifdef HAVE_SYS_PARAM_H\n#include <sys/param.h>\n#endif\n\n#include \"urldata.h\"\n#include <curl/curl.h>\n#include \"transfer.h\"\n#include \"sendf.h\"\n#include \"telnet.h\"\n#include \"connect.h\"\n#include \"progress.h\"\n#include \"system_win32.h\"\n#include \"arpa_telnet.h\"\n#include \"select.h\"\n#include \"strcase.h\"\n#include \"warnless.h\"\n\n/* The last 3 #include files should be in this order */\n#include \"curl_printf.h\"\n#include \"curl_memory.h\"\n#include \"memdebug.h\"\n\n#define SUBBUFSIZE 512\n\n#define CURL_SB_CLEAR(x)  x->subpointer = x->subbuffer\n#define CURL_SB_TERM(x)                                 \\\n  do {                                                  \\\n    x->subend = x->subpointer;                          \\\n    CURL_SB_CLEAR(x);                                   \\\n  } while(0)\n#define CURL_SB_ACCUM(x,c)                                      \\\n  do {                                                          \\\n    if(x->subpointer < (x->subbuffer + sizeof(x->subbuffer)))   \\\n      *x->subpointer++ = (c);                                   \\\n  } while(0)\n\n#define  CURL_SB_GET(x) ((*x->subpointer++)&0xff)\n#define  CURL_SB_LEN(x) (x->subend - x->subpointer)\n\n/* For posterity:\n#define  CURL_SB_PEEK(x) ((*x->subpointer)&0xff)\n#define  CURL_SB_EOF(x) (x->subpointer >= x->subend) */\n\n#ifdef CURL_DISABLE_VERBOSE_STRINGS\n#define printoption(a,b,c,d)  Curl_nop_stmt\n#endif\n\nstatic\nCURLcode telrcv(struct Curl_easy *data,\n                const unsigned char *inbuf, /* Data received from socket */\n                ssize_t count);             /* Number of bytes received */\n\n#ifndef CURL_DISABLE_VERBOSE_STRINGS\nstatic void printoption(struct Curl_easy *data,\n                        const char *direction,\n                        int cmd, int option);\n#endif\n\nstatic void negotiate(struct Curl_easy *data);\nstatic void send_negotiation(struct Curl_easy *data, int cmd, int option);\nstatic void set_local_option(struct Curl_easy *data,\n                             int option, int newstate);\nstatic void set_remote_option(struct Curl_easy *data,\n                              int option, int newstate);\n\nstatic void printsub(struct Curl_easy *data,\n                     int direction, unsigned char *pointer,\n                     size_t length);\nstatic void suboption(struct Curl_easy *data);\nstatic void sendsuboption(struct Curl_easy *data, int option);\n\nstatic CURLcode telnet_do(struct Curl_easy *data, bool *done);\nstatic CURLcode telnet_done(struct Curl_easy *data,\n                                 CURLcode, bool premature);\nstatic CURLcode send_telnet_data(struct Curl_easy *data,\n                                 char *buffer, ssize_t nread);\n\n/* For negotiation compliant to RFC 1143 */\n#define CURL_NO          0\n#define CURL_YES         1\n#define CURL_WANTYES     2\n#define CURL_WANTNO      3\n\n#define CURL_EMPTY       0\n#define CURL_OPPOSITE    1\n\n/*\n * Telnet receiver states for fsm\n */\ntypedef enum\n{\n   CURL_TS_DATA = 0,\n   CURL_TS_IAC,\n   CURL_TS_WILL,\n   CURL_TS_WONT,\n   CURL_TS_DO,\n   CURL_TS_DONT,\n   CURL_TS_CR,\n   CURL_TS_SB,   /* sub-option collection */\n   CURL_TS_SE   /* looking for sub-option end */\n} TelnetReceive;\n\nstruct TELNET {\n  int please_negotiate;\n  int already_negotiated;\n  int us[256];\n  int usq[256];\n  int us_preferred[256];\n  int him[256];\n  int himq[256];\n  int him_preferred[256];\n  int subnegotiation[256];\n  char subopt_ttype[32];             /* Set with suboption TTYPE */\n  char subopt_xdisploc[128];         /* Set with suboption XDISPLOC */\n  unsigned short subopt_wsx;         /* Set with suboption NAWS */\n  unsigned short subopt_wsy;         /* Set with suboption NAWS */\n  TelnetReceive telrcv_state;\n  struct curl_slist *telnet_vars;    /* Environment variables */\n\n  /* suboptions */\n  unsigned char subbuffer[SUBBUFSIZE];\n  unsigned char *subpointer, *subend;      /* buffer for sub-options */\n};\n\n\n/*\n * TELNET protocol handler.\n */\n\nconst struct Curl_handler Curl_handler_telnet = {\n  \"TELNET\",                             /* scheme */\n  ZERO_NULL,                            /* setup_connection */\n  telnet_do,                            /* do_it */\n  telnet_done,                          /* done */\n  ZERO_NULL,                            /* do_more */\n  ZERO_NULL,                            /* connect_it */\n  ZERO_NULL,                            /* connecting */\n  ZERO_NULL,                            /* doing */\n  ZERO_NULL,                            /* proto_getsock */\n  ZERO_NULL,                            /* doing_getsock */\n  ZERO_NULL,                            /* domore_getsock */\n  ZERO_NULL,                            /* perform_getsock */\n  ZERO_NULL,                            /* disconnect */\n  ZERO_NULL,                            /* readwrite */\n  ZERO_NULL,                            /* connection_check */\n  ZERO_NULL,                            /* attach connection */\n  PORT_TELNET,                          /* defport */\n  CURLPROTO_TELNET,                     /* protocol */\n  CURLPROTO_TELNET,                     /* family */\n  PROTOPT_NONE | PROTOPT_NOURLQUERY     /* flags */\n};\n\n\nstatic\nCURLcode init_telnet(struct Curl_easy *data)\n{\n  struct TELNET *tn;\n\n  tn = calloc(1, sizeof(struct TELNET));\n  if(!tn)\n    return CURLE_OUT_OF_MEMORY;\n\n  data->req.p.telnet = tn; /* make us known */\n\n  tn->telrcv_state = CURL_TS_DATA;\n\n  /* Init suboptions */\n  CURL_SB_CLEAR(tn);\n\n  /* Set the options we want by default */\n  tn->us_preferred[CURL_TELOPT_SGA] = CURL_YES;\n  tn->him_preferred[CURL_TELOPT_SGA] = CURL_YES;\n\n  /* To be compliant with previous releases of libcurl\n     we enable this option by default. This behavior\n         can be changed thanks to the \"BINARY\" option in\n         CURLOPT_TELNETOPTIONS\n  */\n  tn->us_preferred[CURL_TELOPT_BINARY] = CURL_YES;\n  tn->him_preferred[CURL_TELOPT_BINARY] = CURL_YES;\n\n  /* We must allow the server to echo what we sent\n         but it is not necessary to request the server\n         to do so (it might forces the server to close\n         the connection). Hence, we ignore ECHO in the\n         negotiate function\n  */\n  tn->him_preferred[CURL_TELOPT_ECHO] = CURL_YES;\n\n  /* Set the subnegotiation fields to send information\n    just after negotiation passed (do/will)\n\n     Default values are (0,0) initialized by calloc.\n     According to the RFC1013 it is valid:\n     A value equal to zero is acceptable for the width (or height),\n         and means that no character width (or height) is being sent.\n         In this case, the width (or height) that will be assumed by the\n         Telnet server is operating system specific (it will probably be\n         based upon the terminal type information that may have been sent\n         using the TERMINAL TYPE Telnet option). */\n  tn->subnegotiation[CURL_TELOPT_NAWS] = CURL_YES;\n  return CURLE_OK;\n}\n\nstatic void negotiate(struct Curl_easy *data)\n{\n  int i;\n  struct TELNET *tn = data->req.p.telnet;\n\n  for(i = 0; i < CURL_NTELOPTS; i++) {\n    if(i == CURL_TELOPT_ECHO)\n      continue;\n\n    if(tn->us_preferred[i] == CURL_YES)\n      set_local_option(data, i, CURL_YES);\n\n    if(tn->him_preferred[i] == CURL_YES)\n      set_remote_option(data, i, CURL_YES);\n  }\n}\n\n#ifndef CURL_DISABLE_VERBOSE_STRINGS\nstatic void printoption(struct Curl_easy *data,\n                        const char *direction, int cmd, int option)\n{\n  if(data->set.verbose) {\n    if(cmd == CURL_IAC) {\n      if(CURL_TELCMD_OK(option))\n        infof(data, \"%s IAC %s\\n\", direction, CURL_TELCMD(option));\n      else\n        infof(data, \"%s IAC %d\\n\", direction, option);\n    }\n    else {\n      const char *fmt = (cmd == CURL_WILL) ? \"WILL\" :\n                        (cmd == CURL_WONT) ? \"WONT\" :\n                        (cmd == CURL_DO) ? \"DO\" :\n                        (cmd == CURL_DONT) ? \"DONT\" : 0;\n      if(fmt) {\n        const char *opt;\n        if(CURL_TELOPT_OK(option))\n          opt = CURL_TELOPT(option);\n        else if(option == CURL_TELOPT_EXOPL)\n          opt = \"EXOPL\";\n        else\n          opt = NULL;\n\n        if(opt)\n          infof(data, \"%s %s %s\\n\", direction, fmt, opt);\n        else\n          infof(data, \"%s %s %d\\n\", direction, fmt, option);\n      }\n      else\n        infof(data, \"%s %d %d\\n\", direction, cmd, option);\n    }\n  }\n}\n#endif\n\nstatic void send_negotiation(struct Curl_easy *data, int cmd, int option)\n{\n  unsigned char buf[3];\n  ssize_t bytes_written;\n  struct connectdata *conn = data->conn;\n\n  buf[0] = CURL_IAC;\n  buf[1] = (unsigned char)cmd;\n  buf[2] = (unsigned char)option;\n\n  bytes_written = swrite(conn->sock[FIRSTSOCKET], buf, 3);\n  if(bytes_written < 0) {\n    int err = SOCKERRNO;\n    failf(data,\"Sending data failed (%d)\",err);\n  }\n\n  printoption(data, \"SENT\", cmd, option);\n}\n\nstatic\nvoid set_remote_option(struct Curl_easy *data, int option, int newstate)\n{\n  struct TELNET *tn = data->req.p.telnet;\n  if(newstate == CURL_YES) {\n    switch(tn->him[option]) {\n    case CURL_NO:\n      tn->him[option] = CURL_WANTYES;\n      send_negotiation(data, CURL_DO, option);\n      break;\n\n    case CURL_YES:\n      /* Already enabled */\n      break;\n\n    case CURL_WANTNO:\n      switch(tn->himq[option]) {\n      case CURL_EMPTY:\n        /* Already negotiating for CURL_YES, queue the request */\n        tn->himq[option] = CURL_OPPOSITE;\n        break;\n      case CURL_OPPOSITE:\n        /* Error: already queued an enable request */\n        break;\n      }\n      break;\n\n    case CURL_WANTYES:\n      switch(tn->himq[option]) {\n      case CURL_EMPTY:\n        /* Error: already negotiating for enable */\n        break;\n      case CURL_OPPOSITE:\n        tn->himq[option] = CURL_EMPTY;\n        break;\n      }\n      break;\n    }\n  }\n  else { /* NO */\n    switch(tn->him[option]) {\n    case CURL_NO:\n      /* Already disabled */\n      break;\n\n    case CURL_YES:\n      tn->him[option] = CURL_WANTNO;\n      send_negotiation(data, CURL_DONT, option);\n      break;\n\n    case CURL_WANTNO:\n      switch(tn->himq[option]) {\n      case CURL_EMPTY:\n        /* Already negotiating for NO */\n        break;\n      case CURL_OPPOSITE:\n        tn->himq[option] = CURL_EMPTY;\n        break;\n      }\n      break;\n\n    case CURL_WANTYES:\n      switch(tn->himq[option]) {\n      case CURL_EMPTY:\n        tn->himq[option] = CURL_OPPOSITE;\n        break;\n      case CURL_OPPOSITE:\n        break;\n      }\n      break;\n    }\n  }\n}\n\nstatic\nvoid rec_will(struct Curl_easy *data, int option)\n{\n  struct TELNET *tn = data->req.p.telnet;\n  switch(tn->him[option]) {\n  case CURL_NO:\n    if(tn->him_preferred[option] == CURL_YES) {\n      tn->him[option] = CURL_YES;\n      send_negotiation(data, CURL_DO, option);\n    }\n    else\n      send_negotiation(data, CURL_DONT, option);\n\n    break;\n\n  case CURL_YES:\n    /* Already enabled */\n    break;\n\n  case CURL_WANTNO:\n    switch(tn->himq[option]) {\n    case CURL_EMPTY:\n      /* Error: DONT answered by WILL */\n      tn->him[option] = CURL_NO;\n      break;\n    case CURL_OPPOSITE:\n      /* Error: DONT answered by WILL */\n      tn->him[option] = CURL_YES;\n      tn->himq[option] = CURL_EMPTY;\n      break;\n    }\n    break;\n\n  case CURL_WANTYES:\n    switch(tn->himq[option]) {\n    case CURL_EMPTY:\n      tn->him[option] = CURL_YES;\n      break;\n    case CURL_OPPOSITE:\n      tn->him[option] = CURL_WANTNO;\n      tn->himq[option] = CURL_EMPTY;\n      send_negotiation(data, CURL_DONT, option);\n      break;\n    }\n    break;\n  }\n}\n\nstatic\nvoid rec_wont(struct Curl_easy *data, int option)\n{\n  struct TELNET *tn = data->req.p.telnet;\n  switch(tn->him[option]) {\n  case CURL_NO:\n    /* Already disabled */\n    break;\n\n  case CURL_YES:\n    tn->him[option] = CURL_NO;\n    send_negotiation(data, CURL_DONT, option);\n    break;\n\n  case CURL_WANTNO:\n    switch(tn->himq[option]) {\n    case CURL_EMPTY:\n      tn->him[option] = CURL_NO;\n      break;\n\n    case CURL_OPPOSITE:\n      tn->him[option] = CURL_WANTYES;\n      tn->himq[option] = CURL_EMPTY;\n      send_negotiation(data, CURL_DO, option);\n      break;\n    }\n    break;\n\n  case CURL_WANTYES:\n    switch(tn->himq[option]) {\n    case CURL_EMPTY:\n      tn->him[option] = CURL_NO;\n      break;\n    case CURL_OPPOSITE:\n      tn->him[option] = CURL_NO;\n      tn->himq[option] = CURL_EMPTY;\n      break;\n    }\n    break;\n  }\n}\n\nstatic void\nset_local_option(struct Curl_easy *data, int option, int newstate)\n{\n  struct TELNET *tn = data->req.p.telnet;\n  if(newstate == CURL_YES) {\n    switch(tn->us[option]) {\n    case CURL_NO:\n      tn->us[option] = CURL_WANTYES;\n      send_negotiation(data, CURL_WILL, option);\n      break;\n\n    case CURL_YES:\n      /* Already enabled */\n      break;\n\n    case CURL_WANTNO:\n      switch(tn->usq[option]) {\n      case CURL_EMPTY:\n        /* Already negotiating for CURL_YES, queue the request */\n        tn->usq[option] = CURL_OPPOSITE;\n        break;\n      case CURL_OPPOSITE:\n        /* Error: already queued an enable request */\n        break;\n      }\n      break;\n\n    case CURL_WANTYES:\n      switch(tn->usq[option]) {\n      case CURL_EMPTY:\n        /* Error: already negotiating for enable */\n        break;\n      case CURL_OPPOSITE:\n        tn->usq[option] = CURL_EMPTY;\n        break;\n      }\n      break;\n    }\n  }\n  else { /* NO */\n    switch(tn->us[option]) {\n    case CURL_NO:\n      /* Already disabled */\n      break;\n\n    case CURL_YES:\n      tn->us[option] = CURL_WANTNO;\n      send_negotiation(data, CURL_WONT, option);\n      break;\n\n    case CURL_WANTNO:\n      switch(tn->usq[option]) {\n      case CURL_EMPTY:\n        /* Already negotiating for NO */\n        break;\n      case CURL_OPPOSITE:\n        tn->usq[option] = CURL_EMPTY;\n        break;\n      }\n      break;\n\n    case CURL_WANTYES:\n      switch(tn->usq[option]) {\n      case CURL_EMPTY:\n        tn->usq[option] = CURL_OPPOSITE;\n        break;\n      case CURL_OPPOSITE:\n        break;\n      }\n      break;\n    }\n  }\n}\n\nstatic\nvoid rec_do(struct Curl_easy *data, int option)\n{\n  struct TELNET *tn = data->req.p.telnet;\n  switch(tn->us[option]) {\n  case CURL_NO:\n    if(tn->us_preferred[option] == CURL_YES) {\n      tn->us[option] = CURL_YES;\n      send_negotiation(data, CURL_WILL, option);\n      if(tn->subnegotiation[option] == CURL_YES)\n        /* transmission of data option */\n        sendsuboption(data, option);\n    }\n    else if(tn->subnegotiation[option] == CURL_YES) {\n      /* send information to achieve this option*/\n      tn->us[option] = CURL_YES;\n      send_negotiation(data, CURL_WILL, option);\n      sendsuboption(data, option);\n    }\n    else\n      send_negotiation(data, CURL_WONT, option);\n    break;\n\n  case CURL_YES:\n    /* Already enabled */\n    break;\n\n  case CURL_WANTNO:\n    switch(tn->usq[option]) {\n    case CURL_EMPTY:\n      /* Error: DONT answered by WILL */\n      tn->us[option] = CURL_NO;\n      break;\n    case CURL_OPPOSITE:\n      /* Error: DONT answered by WILL */\n      tn->us[option] = CURL_YES;\n      tn->usq[option] = CURL_EMPTY;\n      break;\n    }\n    break;\n\n  case CURL_WANTYES:\n    switch(tn->usq[option]) {\n    case CURL_EMPTY:\n      tn->us[option] = CURL_YES;\n      if(tn->subnegotiation[option] == CURL_YES) {\n        /* transmission of data option */\n        sendsuboption(data, option);\n      }\n      break;\n    case CURL_OPPOSITE:\n      tn->us[option] = CURL_WANTNO;\n      tn->himq[option] = CURL_EMPTY;\n      send_negotiation(data, CURL_WONT, option);\n      break;\n    }\n    break;\n  }\n}\n\nstatic\nvoid rec_dont(struct Curl_easy *data, int option)\n{\n  struct TELNET *tn = data->req.p.telnet;\n  switch(tn->us[option]) {\n  case CURL_NO:\n    /* Already disabled */\n    break;\n\n  case CURL_YES:\n    tn->us[option] = CURL_NO;\n    send_negotiation(data, CURL_WONT, option);\n    break;\n\n  case CURL_WANTNO:\n    switch(tn->usq[option]) {\n    case CURL_EMPTY:\n      tn->us[option] = CURL_NO;\n      break;\n\n    case CURL_OPPOSITE:\n      tn->us[option] = CURL_WANTYES;\n      tn->usq[option] = CURL_EMPTY;\n      send_negotiation(data, CURL_WILL, option);\n      break;\n    }\n    break;\n\n  case CURL_WANTYES:\n    switch(tn->usq[option]) {\n    case CURL_EMPTY:\n      tn->us[option] = CURL_NO;\n      break;\n    case CURL_OPPOSITE:\n      tn->us[option] = CURL_NO;\n      tn->usq[option] = CURL_EMPTY;\n      break;\n    }\n    break;\n  }\n}\n\n\nstatic void printsub(struct Curl_easy *data,\n                     int direction,             /* '<' or '>' */\n                     unsigned char *pointer,    /* where suboption data is */\n                     size_t length)             /* length of suboption data */\n{\n  if(data->set.verbose) {\n    unsigned int i = 0;\n    if(direction) {\n      infof(data, \"%s IAC SB \", (direction == '<')? \"RCVD\":\"SENT\");\n      if(length >= 3) {\n        int j;\n\n        i = pointer[length-2];\n        j = pointer[length-1];\n\n        if(i != CURL_IAC || j != CURL_SE) {\n          infof(data, \"(terminated by \");\n          if(CURL_TELOPT_OK(i))\n            infof(data, \"%s \", CURL_TELOPT(i));\n          else if(CURL_TELCMD_OK(i))\n            infof(data, \"%s \", CURL_TELCMD(i));\n          else\n            infof(data, \"%u \", i);\n          if(CURL_TELOPT_OK(j))\n            infof(data, \"%s\", CURL_TELOPT(j));\n          else if(CURL_TELCMD_OK(j))\n            infof(data, \"%s\", CURL_TELCMD(j));\n          else\n            infof(data, \"%d\", j);\n          infof(data, \", not IAC SE!) \");\n        }\n      }\n      length -= 2;\n    }\n    if(length < 1) {\n      infof(data, \"(Empty suboption?)\");\n      return;\n    }\n\n    if(CURL_TELOPT_OK(pointer[0])) {\n      switch(pointer[0]) {\n      case CURL_TELOPT_TTYPE:\n      case CURL_TELOPT_XDISPLOC:\n      case CURL_TELOPT_NEW_ENVIRON:\n      case CURL_TELOPT_NAWS:\n        infof(data, \"%s\", CURL_TELOPT(pointer[0]));\n        break;\n      default:\n        infof(data, \"%s (unsupported)\", CURL_TELOPT(pointer[0]));\n        break;\n      }\n    }\n    else\n      infof(data, \"%d (unknown)\", pointer[i]);\n\n    switch(pointer[0]) {\n    case CURL_TELOPT_NAWS:\n      if(length > 4)\n        infof(data, \"Width: %d ; Height: %d\", (pointer[1]<<8) | pointer[2],\n              (pointer[3]<<8) | pointer[4]);\n      break;\n    default:\n      switch(pointer[1]) {\n      case CURL_TELQUAL_IS:\n        infof(data, \" IS\");\n        break;\n      case CURL_TELQUAL_SEND:\n        infof(data, \" SEND\");\n        break;\n      case CURL_TELQUAL_INFO:\n        infof(data, \" INFO/REPLY\");\n        break;\n      case CURL_TELQUAL_NAME:\n        infof(data, \" NAME\");\n        break;\n      }\n\n      switch(pointer[0]) {\n      case CURL_TELOPT_TTYPE:\n      case CURL_TELOPT_XDISPLOC:\n        pointer[length] = 0;\n        infof(data, \" \\\"%s\\\"\", &pointer[2]);\n        break;\n      case CURL_TELOPT_NEW_ENVIRON:\n        if(pointer[1] == CURL_TELQUAL_IS) {\n          infof(data, \" \");\n          for(i = 3; i < length; i++) {\n            switch(pointer[i]) {\n            case CURL_NEW_ENV_VAR:\n              infof(data, \", \");\n              break;\n            case CURL_NEW_ENV_VALUE:\n              infof(data, \" = \");\n              break;\n            default:\n              infof(data, \"%c\", pointer[i]);\n              break;\n            }\n          }\n        }\n        break;\n      default:\n        for(i = 2; i < length; i++)\n          infof(data, \" %.2x\", pointer[i]);\n        break;\n      }\n    }\n    if(direction)\n      infof(data, \"\\n\");\n  }\n}\n\nstatic CURLcode check_telnet_options(struct Curl_easy *data)\n{\n  struct curl_slist *head;\n  struct curl_slist *beg;\n  char option_keyword[128] = \"\";\n  char option_arg[256] = \"\";\n  struct TELNET *tn = data->req.p.telnet;\n  struct connectdata *conn = data->conn;\n  CURLcode result = CURLE_OK;\n  int binary_option;\n\n  /* Add the user name as an environment variable if it\n     was given on the command line */\n  if(conn->bits.user_passwd) {\n    msnprintf(option_arg, sizeof(option_arg), \"USER,%s\", conn->user);\n    beg = curl_slist_append(tn->telnet_vars, option_arg);\n    if(!beg) {\n      curl_slist_free_all(tn->telnet_vars);\n      tn->telnet_vars = NULL;\n      return CURLE_OUT_OF_MEMORY;\n    }\n    tn->telnet_vars = beg;\n    tn->us_preferred[CURL_TELOPT_NEW_ENVIRON] = CURL_YES;\n  }\n\n  for(head = data->set.telnet_options; head; head = head->next) {\n    if(sscanf(head->data, \"%127[^= ]%*[ =]%255s\",\n              option_keyword, option_arg) == 2) {\n\n      /* Terminal type */\n      if(strcasecompare(option_keyword, \"TTYPE\")) {\n        strncpy(tn->subopt_ttype, option_arg, 31);\n        tn->subopt_ttype[31] = 0; /* String termination */\n        tn->us_preferred[CURL_TELOPT_TTYPE] = CURL_YES;\n        continue;\n      }\n\n      /* Display variable */\n      if(strcasecompare(option_keyword, \"XDISPLOC\")) {\n        strncpy(tn->subopt_xdisploc, option_arg, 127);\n        tn->subopt_xdisploc[127] = 0; /* String termination */\n        tn->us_preferred[CURL_TELOPT_XDISPLOC] = CURL_YES;\n        continue;\n      }\n\n      /* Environment variable */\n      if(strcasecompare(option_keyword, \"NEW_ENV\")) {\n        beg = curl_slist_append(tn->telnet_vars, option_arg);\n        if(!beg) {\n          result = CURLE_OUT_OF_MEMORY;\n          break;\n        }\n        tn->telnet_vars = beg;\n        tn->us_preferred[CURL_TELOPT_NEW_ENVIRON] = CURL_YES;\n        continue;\n      }\n\n      /* Window Size */\n      if(strcasecompare(option_keyword, \"WS\")) {\n        if(sscanf(option_arg, \"%hu%*[xX]%hu\",\n                  &tn->subopt_wsx, &tn->subopt_wsy) == 2)\n          tn->us_preferred[CURL_TELOPT_NAWS] = CURL_YES;\n        else {\n          failf(data, \"Syntax error in telnet option: %s\", head->data);\n          result = CURLE_TELNET_OPTION_SYNTAX;\n          break;\n        }\n        continue;\n      }\n\n      /* To take care or not of the 8th bit in data exchange */\n      if(strcasecompare(option_keyword, \"BINARY\")) {\n        binary_option = atoi(option_arg);\n        if(binary_option != 1) {\n          tn->us_preferred[CURL_TELOPT_BINARY] = CURL_NO;\n          tn->him_preferred[CURL_TELOPT_BINARY] = CURL_NO;\n        }\n        continue;\n      }\n\n      failf(data, \"Unknown telnet option %s\", head->data);\n      result = CURLE_UNKNOWN_OPTION;\n      break;\n    }\n    failf(data, \"Syntax error in telnet option: %s\", head->data);\n    result = CURLE_TELNET_OPTION_SYNTAX;\n    break;\n  }\n\n  if(result) {\n    curl_slist_free_all(tn->telnet_vars);\n    tn->telnet_vars = NULL;\n  }\n\n  return result;\n}\n\n/*\n * suboption()\n *\n * Look at the sub-option buffer, and try to be helpful to the other\n * side.\n */\n\nstatic void suboption(struct Curl_easy *data)\n{\n  struct curl_slist *v;\n  unsigned char temp[2048];\n  ssize_t bytes_written;\n  size_t len;\n  int err;\n  char varname[128] = \"\";\n  char varval[128] = \"\";\n  struct TELNET *tn = data->req.p.telnet;\n  struct connectdata *conn = data->conn;\n\n  printsub(data, '<', (unsigned char *)tn->subbuffer, CURL_SB_LEN(tn) + 2);\n  switch(CURL_SB_GET(tn)) {\n    case CURL_TELOPT_TTYPE:\n      len = strlen(tn->subopt_ttype) + 4 + 2;\n      msnprintf((char *)temp, sizeof(temp),\n                \"%c%c%c%c%s%c%c\", CURL_IAC, CURL_SB, CURL_TELOPT_TTYPE,\n                CURL_TELQUAL_IS, tn->subopt_ttype, CURL_IAC, CURL_SE);\n      bytes_written = swrite(conn->sock[FIRSTSOCKET], temp, len);\n      if(bytes_written < 0) {\n        err = SOCKERRNO;\n        failf(data,\"Sending data failed (%d)\",err);\n      }\n      printsub(data, '>', &temp[2], len-2);\n      break;\n    case CURL_TELOPT_XDISPLOC:\n      len = strlen(tn->subopt_xdisploc) + 4 + 2;\n      msnprintf((char *)temp, sizeof(temp),\n                \"%c%c%c%c%s%c%c\", CURL_IAC, CURL_SB, CURL_TELOPT_XDISPLOC,\n                CURL_TELQUAL_IS, tn->subopt_xdisploc, CURL_IAC, CURL_SE);\n      bytes_written = swrite(conn->sock[FIRSTSOCKET], temp, len);\n      if(bytes_written < 0) {\n        err = SOCKERRNO;\n        failf(data,\"Sending data failed (%d)\",err);\n      }\n      printsub(data, '>', &temp[2], len-2);\n      break;\n    case CURL_TELOPT_NEW_ENVIRON:\n      msnprintf((char *)temp, sizeof(temp),\n                \"%c%c%c%c\", CURL_IAC, CURL_SB, CURL_TELOPT_NEW_ENVIRON,\n                CURL_TELQUAL_IS);\n      len = 4;\n\n      for(v = tn->telnet_vars; v; v = v->next) {\n        size_t tmplen = (strlen(v->data) + 1);\n        /* Add the variable only if it fits */\n        if(len + tmplen < (int)sizeof(temp)-6) {\n          if(sscanf(v->data, \"%127[^,],%127s\", varname, varval)) {\n            msnprintf((char *)&temp[len], sizeof(temp) - len,\n                      \"%c%s%c%s\", CURL_NEW_ENV_VAR, varname,\n                      CURL_NEW_ENV_VALUE, varval);\n            len += tmplen;\n          }\n        }\n      }\n      msnprintf((char *)&temp[len], sizeof(temp) - len,\n                \"%c%c\", CURL_IAC, CURL_SE);\n      len += 2;\n      bytes_written = swrite(conn->sock[FIRSTSOCKET], temp, len);\n      if(bytes_written < 0) {\n        err = SOCKERRNO;\n        failf(data,\"Sending data failed (%d)\",err);\n      }\n      printsub(data, '>', &temp[2], len-2);\n      break;\n  }\n  return;\n}\n\n\n/*\n * sendsuboption()\n *\n * Send suboption information to the server side.\n */\n\nstatic void sendsuboption(struct Curl_easy *data, int option)\n{\n  ssize_t bytes_written;\n  int err;\n  unsigned short x, y;\n  unsigned char *uc1, *uc2;\n  struct TELNET *tn = data->req.p.telnet;\n  struct connectdata *conn = data->conn;\n\n  switch(option) {\n  case CURL_TELOPT_NAWS:\n    /* We prepare data to be sent */\n    CURL_SB_CLEAR(tn);\n    CURL_SB_ACCUM(tn, CURL_IAC);\n    CURL_SB_ACCUM(tn, CURL_SB);\n    CURL_SB_ACCUM(tn, CURL_TELOPT_NAWS);\n    /* We must deal either with little or big endian processors */\n    /* Window size must be sent according to the 'network order' */\n    x = htons(tn->subopt_wsx);\n    y = htons(tn->subopt_wsy);\n    uc1 = (unsigned char *)&x;\n    uc2 = (unsigned char *)&y;\n    CURL_SB_ACCUM(tn, uc1[0]);\n    CURL_SB_ACCUM(tn, uc1[1]);\n    CURL_SB_ACCUM(tn, uc2[0]);\n    CURL_SB_ACCUM(tn, uc2[1]);\n\n    CURL_SB_ACCUM(tn, CURL_IAC);\n    CURL_SB_ACCUM(tn, CURL_SE);\n    CURL_SB_TERM(tn);\n    /* data suboption is now ready */\n\n    printsub(data, '>', (unsigned char *)tn->subbuffer + 2,\n             CURL_SB_LEN(tn)-2);\n\n    /* we send the header of the suboption... */\n    bytes_written = swrite(conn->sock[FIRSTSOCKET], tn->subbuffer, 3);\n    if(bytes_written < 0) {\n      err = SOCKERRNO;\n      failf(data, \"Sending data failed (%d)\", err);\n    }\n    /* ... then the window size with the send_telnet_data() function\n       to deal with 0xFF cases ... */\n    send_telnet_data(data, (char *)tn->subbuffer + 3, 4);\n    /* ... and the footer */\n    bytes_written = swrite(conn->sock[FIRSTSOCKET], tn->subbuffer + 7, 2);\n    if(bytes_written < 0) {\n      err = SOCKERRNO;\n      failf(data, \"Sending data failed (%d)\", err);\n    }\n    break;\n  }\n}\n\n\nstatic\nCURLcode telrcv(struct Curl_easy *data,\n                const unsigned char *inbuf, /* Data received from socket */\n                ssize_t count)              /* Number of bytes received */\n{\n  unsigned char c;\n  CURLcode result;\n  int in = 0;\n  int startwrite = -1;\n  struct TELNET *tn = data->req.p.telnet;\n\n#define startskipping()                                       \\\n  if(startwrite >= 0) {                                       \\\n    result = Curl_client_write(data,                          \\\n                               CLIENTWRITE_BODY,              \\\n                               (char *)&inbuf[startwrite],    \\\n                               in-startwrite);                \\\n    if(result)                                                \\\n      return result;                                          \\\n  }                                                           \\\n  startwrite = -1\n\n#define writebyte() \\\n    if(startwrite < 0) \\\n      startwrite = in\n\n#define bufferflush() startskipping()\n\n  while(count--) {\n    c = inbuf[in];\n\n    switch(tn->telrcv_state) {\n    case CURL_TS_CR:\n      tn->telrcv_state = CURL_TS_DATA;\n      if(c == '\\0') {\n        startskipping();\n        break;   /* Ignore \\0 after CR */\n      }\n      writebyte();\n      break;\n\n    case CURL_TS_DATA:\n      if(c == CURL_IAC) {\n        tn->telrcv_state = CURL_TS_IAC;\n        startskipping();\n        break;\n      }\n      else if(c == '\\r')\n        tn->telrcv_state = CURL_TS_CR;\n      writebyte();\n      break;\n\n    case CURL_TS_IAC:\n    process_iac:\n      DEBUGASSERT(startwrite < 0);\n      switch(c) {\n      case CURL_WILL:\n        tn->telrcv_state = CURL_TS_WILL;\n        break;\n      case CURL_WONT:\n        tn->telrcv_state = CURL_TS_WONT;\n        break;\n      case CURL_DO:\n        tn->telrcv_state = CURL_TS_DO;\n        break;\n      case CURL_DONT:\n        tn->telrcv_state = CURL_TS_DONT;\n        break;\n      case CURL_SB:\n        CURL_SB_CLEAR(tn);\n        tn->telrcv_state = CURL_TS_SB;\n        break;\n      case CURL_IAC:\n        tn->telrcv_state = CURL_TS_DATA;\n        writebyte();\n        break;\n      case CURL_DM:\n      case CURL_NOP:\n      case CURL_GA:\n      default:\n        tn->telrcv_state = CURL_TS_DATA;\n        printoption(data, \"RCVD\", CURL_IAC, c);\n        break;\n      }\n      break;\n\n      case CURL_TS_WILL:\n        printoption(data, \"RCVD\", CURL_WILL, c);\n        tn->please_negotiate = 1;\n        rec_will(data, c);\n        tn->telrcv_state = CURL_TS_DATA;\n        break;\n\n      case CURL_TS_WONT:\n        printoption(data, \"RCVD\", CURL_WONT, c);\n        tn->please_negotiate = 1;\n        rec_wont(data, c);\n        tn->telrcv_state = CURL_TS_DATA;\n        break;\n\n      case CURL_TS_DO:\n        printoption(data, \"RCVD\", CURL_DO, c);\n        tn->please_negotiate = 1;\n        rec_do(data, c);\n        tn->telrcv_state = CURL_TS_DATA;\n        break;\n\n      case CURL_TS_DONT:\n        printoption(data, \"RCVD\", CURL_DONT, c);\n        tn->please_negotiate = 1;\n        rec_dont(data, c);\n        tn->telrcv_state = CURL_TS_DATA;\n        break;\n\n      case CURL_TS_SB:\n        if(c == CURL_IAC)\n          tn->telrcv_state = CURL_TS_SE;\n        else\n          CURL_SB_ACCUM(tn, c);\n        break;\n\n      case CURL_TS_SE:\n        if(c != CURL_SE) {\n          if(c != CURL_IAC) {\n            /*\n             * This is an error.  We only expect to get \"IAC IAC\" or \"IAC SE\".\n             * Several things may have happened.  An IAC was not doubled, the\n             * IAC SE was left off, or another option got inserted into the\n             * suboption are all possibilities.  If we assume that the IAC was\n             * not doubled, and really the IAC SE was left off, we could get\n             * into an infinite loop here.  So, instead, we terminate the\n             * suboption, and process the partial suboption if we can.\n             */\n            CURL_SB_ACCUM(tn, CURL_IAC);\n            CURL_SB_ACCUM(tn, c);\n            tn->subpointer -= 2;\n            CURL_SB_TERM(tn);\n\n            printoption(data, \"In SUBOPTION processing, RCVD\", CURL_IAC, c);\n            suboption(data);   /* handle sub-option */\n            tn->telrcv_state = CURL_TS_IAC;\n            goto process_iac;\n          }\n          CURL_SB_ACCUM(tn, c);\n          tn->telrcv_state = CURL_TS_SB;\n        }\n        else {\n          CURL_SB_ACCUM(tn, CURL_IAC);\n          CURL_SB_ACCUM(tn, CURL_SE);\n          tn->subpointer -= 2;\n          CURL_SB_TERM(tn);\n          suboption(data);   /* handle sub-option */\n          tn->telrcv_state = CURL_TS_DATA;\n        }\n        break;\n    }\n    ++in;\n  }\n  bufferflush();\n  return CURLE_OK;\n}\n\n/* Escape and send a telnet data block */\nstatic CURLcode send_telnet_data(struct Curl_easy *data,\n                                 char *buffer, ssize_t nread)\n{\n  ssize_t escapes, i, outlen;\n  unsigned char *outbuf = NULL;\n  CURLcode result = CURLE_OK;\n  ssize_t bytes_written, total_written;\n  struct connectdata *conn = data->conn;\n\n  /* Determine size of new buffer after escaping */\n  escapes = 0;\n  for(i = 0; i < nread; i++)\n    if((unsigned char)buffer[i] == CURL_IAC)\n      escapes++;\n  outlen = nread + escapes;\n\n  if(outlen == nread)\n    outbuf = (unsigned char *)buffer;\n  else {\n    ssize_t j;\n    outbuf = malloc(nread + escapes + 1);\n    if(!outbuf)\n      return CURLE_OUT_OF_MEMORY;\n\n    j = 0;\n    for(i = 0; i < nread; i++) {\n      outbuf[j++] = buffer[i];\n      if((unsigned char)buffer[i] == CURL_IAC)\n        outbuf[j++] = CURL_IAC;\n    }\n    outbuf[j] = '\\0';\n  }\n\n  total_written = 0;\n  while(!result && total_written < outlen) {\n    /* Make sure socket is writable to avoid EWOULDBLOCK condition */\n    struct pollfd pfd[1];\n    pfd[0].fd = conn->sock[FIRSTSOCKET];\n    pfd[0].events = POLLOUT;\n    switch(Curl_poll(pfd, 1, -1)) {\n      case -1:                    /* error, abort writing */\n      case 0:                     /* timeout (will never happen) */\n        result = CURLE_SEND_ERROR;\n        break;\n      default:                    /* write! */\n        bytes_written = 0;\n        result = Curl_write(data, conn->sock[FIRSTSOCKET],\n                            outbuf + total_written,\n                            outlen - total_written,\n                            &bytes_written);\n        total_written += bytes_written;\n        break;\n    }\n  }\n\n  /* Free malloc copy if escaped */\n  if(outbuf != (unsigned char *)buffer)\n    free(outbuf);\n\n  return result;\n}\n\nstatic CURLcode telnet_done(struct Curl_easy *data,\n                            CURLcode status, bool premature)\n{\n  struct TELNET *tn = data->req.p.telnet;\n  (void)status; /* unused */\n  (void)premature; /* not used */\n\n  if(!tn)\n    return CURLE_OK;\n\n  curl_slist_free_all(tn->telnet_vars);\n  tn->telnet_vars = NULL;\n\n  Curl_safefree(data->req.p.telnet);\n\n  return CURLE_OK;\n}\n\nstatic CURLcode telnet_do(struct Curl_easy *data, bool *done)\n{\n  CURLcode result;\n  struct connectdata *conn = data->conn;\n  curl_socket_t sockfd = conn->sock[FIRSTSOCKET];\n#ifdef USE_WINSOCK\n  WSAEVENT event_handle;\n  WSANETWORKEVENTS events;\n  HANDLE stdin_handle;\n  HANDLE objs[2];\n  DWORD  obj_count;\n  DWORD  wait_timeout;\n  DWORD readfile_read;\n  int err;\n#else\n  timediff_t interval_ms;\n  struct pollfd pfd[2];\n  int poll_cnt;\n  curl_off_t total_dl = 0;\n  curl_off_t total_ul = 0;\n#endif\n  ssize_t nread;\n  struct curltime now;\n  bool keepon = TRUE;\n  char *buf = data->state.buffer;\n  struct TELNET *tn;\n\n  *done = TRUE; /* unconditionally */\n\n  result = init_telnet(data);\n  if(result)\n    return result;\n\n  tn = data->req.p.telnet;\n\n  result = check_telnet_options(data);\n  if(result)\n    return result;\n\n#ifdef USE_WINSOCK\n  /* We want to wait for both stdin and the socket. Since\n  ** the select() function in winsock only works on sockets\n  ** we have to use the WaitForMultipleObjects() call.\n  */\n\n  /* First, create a sockets event object */\n  event_handle = WSACreateEvent();\n  if(event_handle == WSA_INVALID_EVENT) {\n    failf(data, \"WSACreateEvent failed (%d)\", SOCKERRNO);\n    return CURLE_FAILED_INIT;\n  }\n\n  /* Tell winsock what events we want to listen to */\n  if(WSAEventSelect(sockfd, event_handle, FD_READ|FD_CLOSE) == SOCKET_ERROR) {\n    WSACloseEvent(event_handle);\n    return CURLE_OK;\n  }\n\n  /* The get the Windows file handle for stdin */\n  stdin_handle = GetStdHandle(STD_INPUT_HANDLE);\n\n  /* Create the list of objects to wait for */\n  objs[0] = event_handle;\n  objs[1] = stdin_handle;\n\n  /* If stdin_handle is a pipe, use PeekNamedPipe() method to check it,\n     else use the old WaitForMultipleObjects() way */\n  if(GetFileType(stdin_handle) == FILE_TYPE_PIPE ||\n     data->set.is_fread_set) {\n    /* Don't wait for stdin_handle, just wait for event_handle */\n    obj_count = 1;\n    /* Check stdin_handle per 100 milliseconds */\n    wait_timeout = 100;\n  }\n  else {\n    obj_count = 2;\n    wait_timeout = 1000;\n  }\n\n  /* Keep on listening and act on events */\n  while(keepon) {\n    const DWORD buf_size = (DWORD)data->set.buffer_size;\n    DWORD waitret = WaitForMultipleObjects(obj_count, objs,\n                                           FALSE, wait_timeout);\n    switch(waitret) {\n\n    case WAIT_TIMEOUT:\n    {\n      for(;;) {\n        if(data->set.is_fread_set) {\n          size_t n;\n          /* read from user-supplied method */\n          n = data->state.fread_func(buf, 1, buf_size, data->state.in);\n          if(n == CURL_READFUNC_ABORT) {\n            keepon = FALSE;\n            result = CURLE_READ_ERROR;\n            break;\n          }\n\n          if(n == CURL_READFUNC_PAUSE)\n            break;\n\n          if(n == 0)                        /* no bytes */\n            break;\n\n          /* fall through with number of bytes read */\n          readfile_read = (DWORD)n;\n        }\n        else {\n          /* read from stdin */\n          if(!PeekNamedPipe(stdin_handle, NULL, 0, NULL,\n                            &readfile_read, NULL)) {\n            keepon = FALSE;\n            result = CURLE_READ_ERROR;\n            break;\n          }\n\n          if(!readfile_read)\n            break;\n\n          if(!ReadFile(stdin_handle, buf, buf_size,\n                       &readfile_read, NULL)) {\n            keepon = FALSE;\n            result = CURLE_READ_ERROR;\n            break;\n          }\n        }\n\n        result = send_telnet_data(data, buf, readfile_read);\n        if(result) {\n          keepon = FALSE;\n          break;\n        }\n      }\n    }\n    break;\n\n    case WAIT_OBJECT_0 + 1:\n    {\n      if(!ReadFile(stdin_handle, buf, buf_size,\n                   &readfile_read, NULL)) {\n        keepon = FALSE;\n        result = CURLE_READ_ERROR;\n        break;\n      }\n\n      result = send_telnet_data(data, buf, readfile_read);\n      if(result) {\n        keepon = FALSE;\n        break;\n      }\n    }\n    break;\n\n    case WAIT_OBJECT_0:\n    {\n      events.lNetworkEvents = 0;\n      if(WSAEnumNetworkEvents(sockfd, event_handle, &events) == SOCKET_ERROR) {\n        err = SOCKERRNO;\n        if(err != EINPROGRESS) {\n          infof(data, \"WSAEnumNetworkEvents failed (%d)\", err);\n          keepon = FALSE;\n          result = CURLE_READ_ERROR;\n        }\n        break;\n      }\n      if(events.lNetworkEvents & FD_READ) {\n        /* read data from network */\n        result = Curl_read(data, sockfd, buf, data->set.buffer_size, &nread);\n        /* read would've blocked. Loop again */\n        if(result == CURLE_AGAIN)\n          break;\n        /* returned not-zero, this an error */\n        else if(result) {\n          keepon = FALSE;\n          break;\n        }\n        /* returned zero but actually received 0 or less here,\n           the server closed the connection and we bail out */\n        else if(nread <= 0) {\n          keepon = FALSE;\n          break;\n        }\n\n        result = telrcv(data, (unsigned char *) buf, nread);\n        if(result) {\n          keepon = FALSE;\n          break;\n        }\n\n        /* Negotiate if the peer has started negotiating,\n           otherwise don't. We don't want to speak telnet with\n           non-telnet servers, like POP or SMTP. */\n        if(tn->please_negotiate && !tn->already_negotiated) {\n          negotiate(data);\n          tn->already_negotiated = 1;\n        }\n      }\n      if(events.lNetworkEvents & FD_CLOSE) {\n        keepon = FALSE;\n      }\n    }\n    break;\n\n    }\n\n    if(data->set.timeout) {\n      now = Curl_now();\n      if(Curl_timediff(now, conn->created) >= data->set.timeout) {\n        failf(data, \"Time-out\");\n        result = CURLE_OPERATION_TIMEDOUT;\n        keepon = FALSE;\n      }\n    }\n  }\n\n  /* We called WSACreateEvent, so call WSACloseEvent */\n  if(!WSACloseEvent(event_handle)) {\n    infof(data, \"WSACloseEvent failed (%d)\", SOCKERRNO);\n  }\n#else\n  pfd[0].fd = sockfd;\n  pfd[0].events = POLLIN;\n\n  if(data->set.is_fread_set) {\n    poll_cnt = 1;\n    interval_ms = 100; /* poll user-supplied read function */\n  }\n  else {\n    /* really using fread, so infile is a FILE* */\n    pfd[1].fd = fileno((FILE *)data->state.in);\n    pfd[1].events = POLLIN;\n    poll_cnt = 2;\n    interval_ms = 1 * 1000;\n  }\n\n  while(keepon) {\n    switch(Curl_poll(pfd, poll_cnt, interval_ms)) {\n    case -1:                    /* error, stop reading */\n      keepon = FALSE;\n      continue;\n    case 0:                     /* timeout */\n      pfd[0].revents = 0;\n      pfd[1].revents = 0;\n      /* FALLTHROUGH */\n    default:                    /* read! */\n      if(pfd[0].revents & POLLIN) {\n        /* read data from network */\n        result = Curl_read(data, sockfd, buf, data->set.buffer_size, &nread);\n        /* read would've blocked. Loop again */\n        if(result == CURLE_AGAIN)\n          break;\n        /* returned not-zero, this an error */\n        if(result) {\n          keepon = FALSE;\n          break;\n        }\n        /* returned zero but actually received 0 or less here,\n           the server closed the connection and we bail out */\n        else if(nread <= 0) {\n          keepon = FALSE;\n          break;\n        }\n\n        total_dl += nread;\n        Curl_pgrsSetDownloadCounter(data, total_dl);\n        result = telrcv(data, (unsigned char *)buf, nread);\n        if(result) {\n          keepon = FALSE;\n          break;\n        }\n\n        /* Negotiate if the peer has started negotiating,\n           otherwise don't. We don't want to speak telnet with\n           non-telnet servers, like POP or SMTP. */\n        if(tn->please_negotiate && !tn->already_negotiated) {\n          negotiate(data);\n          tn->already_negotiated = 1;\n        }\n      }\n\n      nread = 0;\n      if(poll_cnt == 2) {\n        if(pfd[1].revents & POLLIN) { /* read from in file */\n          nread = read(pfd[1].fd, buf, data->set.buffer_size);\n        }\n      }\n      else {\n        /* read from user-supplied method */\n        nread = (int)data->state.fread_func(buf, 1, data->set.buffer_size,\n                                            data->state.in);\n        if(nread == CURL_READFUNC_ABORT) {\n          keepon = FALSE;\n          break;\n        }\n        if(nread == CURL_READFUNC_PAUSE)\n          break;\n      }\n\n      if(nread > 0) {\n        result = send_telnet_data(data, buf, nread);\n        if(result) {\n          keepon = FALSE;\n          break;\n        }\n        total_ul += nread;\n        Curl_pgrsSetUploadCounter(data, total_ul);\n      }\n      else if(nread < 0)\n        keepon = FALSE;\n\n      break;\n    } /* poll switch statement */\n\n    if(data->set.timeout) {\n      now = Curl_now();\n      if(Curl_timediff(now, conn->created) >= data->set.timeout) {\n        failf(data, \"Time-out\");\n        result = CURLE_OPERATION_TIMEDOUT;\n        keepon = FALSE;\n      }\n    }\n\n    if(Curl_pgrsUpdate(data)) {\n      result = CURLE_ABORTED_BY_CALLBACK;\n      break;\n    }\n  }\n#endif\n  /* mark this as \"no further transfer wanted\" */\n  Curl_setup_transfer(data, -1, -1, FALSE, -1);\n\n  return result;\n}\n#endif\n"], "fixing_code": ["/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) 1998 - 2021, Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n ***************************************************************************/\n\n#include \"curl_setup.h\"\n\n#ifndef CURL_DISABLE_TELNET\n\n#ifdef HAVE_NETINET_IN_H\n#include <netinet/in.h>\n#endif\n#ifdef HAVE_NETDB_H\n#include <netdb.h>\n#endif\n#ifdef HAVE_ARPA_INET_H\n#include <arpa/inet.h>\n#endif\n#ifdef HAVE_NET_IF_H\n#include <net/if.h>\n#endif\n#ifdef HAVE_SYS_IOCTL_H\n#include <sys/ioctl.h>\n#endif\n\n#ifdef HAVE_SYS_PARAM_H\n#include <sys/param.h>\n#endif\n\n#include \"urldata.h\"\n#include <curl/curl.h>\n#include \"transfer.h\"\n#include \"sendf.h\"\n#include \"telnet.h\"\n#include \"connect.h\"\n#include \"progress.h\"\n#include \"system_win32.h\"\n#include \"arpa_telnet.h\"\n#include \"select.h\"\n#include \"strcase.h\"\n#include \"warnless.h\"\n\n/* The last 3 #include files should be in this order */\n#include \"curl_printf.h\"\n#include \"curl_memory.h\"\n#include \"memdebug.h\"\n\n#define SUBBUFSIZE 512\n\n#define CURL_SB_CLEAR(x)  x->subpointer = x->subbuffer\n#define CURL_SB_TERM(x)                                 \\\n  do {                                                  \\\n    x->subend = x->subpointer;                          \\\n    CURL_SB_CLEAR(x);                                   \\\n  } while(0)\n#define CURL_SB_ACCUM(x,c)                                      \\\n  do {                                                          \\\n    if(x->subpointer < (x->subbuffer + sizeof(x->subbuffer)))   \\\n      *x->subpointer++ = (c);                                   \\\n  } while(0)\n\n#define  CURL_SB_GET(x) ((*x->subpointer++)&0xff)\n#define  CURL_SB_LEN(x) (x->subend - x->subpointer)\n\n/* For posterity:\n#define  CURL_SB_PEEK(x) ((*x->subpointer)&0xff)\n#define  CURL_SB_EOF(x) (x->subpointer >= x->subend) */\n\n#ifdef CURL_DISABLE_VERBOSE_STRINGS\n#define printoption(a,b,c,d)  Curl_nop_stmt\n#endif\n\nstatic\nCURLcode telrcv(struct Curl_easy *data,\n                const unsigned char *inbuf, /* Data received from socket */\n                ssize_t count);             /* Number of bytes received */\n\n#ifndef CURL_DISABLE_VERBOSE_STRINGS\nstatic void printoption(struct Curl_easy *data,\n                        const char *direction,\n                        int cmd, int option);\n#endif\n\nstatic void negotiate(struct Curl_easy *data);\nstatic void send_negotiation(struct Curl_easy *data, int cmd, int option);\nstatic void set_local_option(struct Curl_easy *data,\n                             int option, int newstate);\nstatic void set_remote_option(struct Curl_easy *data,\n                              int option, int newstate);\n\nstatic void printsub(struct Curl_easy *data,\n                     int direction, unsigned char *pointer,\n                     size_t length);\nstatic void suboption(struct Curl_easy *data);\nstatic void sendsuboption(struct Curl_easy *data, int option);\n\nstatic CURLcode telnet_do(struct Curl_easy *data, bool *done);\nstatic CURLcode telnet_done(struct Curl_easy *data,\n                                 CURLcode, bool premature);\nstatic CURLcode send_telnet_data(struct Curl_easy *data,\n                                 char *buffer, ssize_t nread);\n\n/* For negotiation compliant to RFC 1143 */\n#define CURL_NO          0\n#define CURL_YES         1\n#define CURL_WANTYES     2\n#define CURL_WANTNO      3\n\n#define CURL_EMPTY       0\n#define CURL_OPPOSITE    1\n\n/*\n * Telnet receiver states for fsm\n */\ntypedef enum\n{\n   CURL_TS_DATA = 0,\n   CURL_TS_IAC,\n   CURL_TS_WILL,\n   CURL_TS_WONT,\n   CURL_TS_DO,\n   CURL_TS_DONT,\n   CURL_TS_CR,\n   CURL_TS_SB,   /* sub-option collection */\n   CURL_TS_SE   /* looking for sub-option end */\n} TelnetReceive;\n\nstruct TELNET {\n  int please_negotiate;\n  int already_negotiated;\n  int us[256];\n  int usq[256];\n  int us_preferred[256];\n  int him[256];\n  int himq[256];\n  int him_preferred[256];\n  int subnegotiation[256];\n  char subopt_ttype[32];             /* Set with suboption TTYPE */\n  char subopt_xdisploc[128];         /* Set with suboption XDISPLOC */\n  unsigned short subopt_wsx;         /* Set with suboption NAWS */\n  unsigned short subopt_wsy;         /* Set with suboption NAWS */\n  TelnetReceive telrcv_state;\n  struct curl_slist *telnet_vars;    /* Environment variables */\n\n  /* suboptions */\n  unsigned char subbuffer[SUBBUFSIZE];\n  unsigned char *subpointer, *subend;      /* buffer for sub-options */\n};\n\n\n/*\n * TELNET protocol handler.\n */\n\nconst struct Curl_handler Curl_handler_telnet = {\n  \"TELNET\",                             /* scheme */\n  ZERO_NULL,                            /* setup_connection */\n  telnet_do,                            /* do_it */\n  telnet_done,                          /* done */\n  ZERO_NULL,                            /* do_more */\n  ZERO_NULL,                            /* connect_it */\n  ZERO_NULL,                            /* connecting */\n  ZERO_NULL,                            /* doing */\n  ZERO_NULL,                            /* proto_getsock */\n  ZERO_NULL,                            /* doing_getsock */\n  ZERO_NULL,                            /* domore_getsock */\n  ZERO_NULL,                            /* perform_getsock */\n  ZERO_NULL,                            /* disconnect */\n  ZERO_NULL,                            /* readwrite */\n  ZERO_NULL,                            /* connection_check */\n  ZERO_NULL,                            /* attach connection */\n  PORT_TELNET,                          /* defport */\n  CURLPROTO_TELNET,                     /* protocol */\n  CURLPROTO_TELNET,                     /* family */\n  PROTOPT_NONE | PROTOPT_NOURLQUERY     /* flags */\n};\n\n\nstatic\nCURLcode init_telnet(struct Curl_easy *data)\n{\n  struct TELNET *tn;\n\n  tn = calloc(1, sizeof(struct TELNET));\n  if(!tn)\n    return CURLE_OUT_OF_MEMORY;\n\n  data->req.p.telnet = tn; /* make us known */\n\n  tn->telrcv_state = CURL_TS_DATA;\n\n  /* Init suboptions */\n  CURL_SB_CLEAR(tn);\n\n  /* Set the options we want by default */\n  tn->us_preferred[CURL_TELOPT_SGA] = CURL_YES;\n  tn->him_preferred[CURL_TELOPT_SGA] = CURL_YES;\n\n  /* To be compliant with previous releases of libcurl\n     we enable this option by default. This behavior\n         can be changed thanks to the \"BINARY\" option in\n         CURLOPT_TELNETOPTIONS\n  */\n  tn->us_preferred[CURL_TELOPT_BINARY] = CURL_YES;\n  tn->him_preferred[CURL_TELOPT_BINARY] = CURL_YES;\n\n  /* We must allow the server to echo what we sent\n         but it is not necessary to request the server\n         to do so (it might forces the server to close\n         the connection). Hence, we ignore ECHO in the\n         negotiate function\n  */\n  tn->him_preferred[CURL_TELOPT_ECHO] = CURL_YES;\n\n  /* Set the subnegotiation fields to send information\n    just after negotiation passed (do/will)\n\n     Default values are (0,0) initialized by calloc.\n     According to the RFC1013 it is valid:\n     A value equal to zero is acceptable for the width (or height),\n         and means that no character width (or height) is being sent.\n         In this case, the width (or height) that will be assumed by the\n         Telnet server is operating system specific (it will probably be\n         based upon the terminal type information that may have been sent\n         using the TERMINAL TYPE Telnet option). */\n  tn->subnegotiation[CURL_TELOPT_NAWS] = CURL_YES;\n  return CURLE_OK;\n}\n\nstatic void negotiate(struct Curl_easy *data)\n{\n  int i;\n  struct TELNET *tn = data->req.p.telnet;\n\n  for(i = 0; i < CURL_NTELOPTS; i++) {\n    if(i == CURL_TELOPT_ECHO)\n      continue;\n\n    if(tn->us_preferred[i] == CURL_YES)\n      set_local_option(data, i, CURL_YES);\n\n    if(tn->him_preferred[i] == CURL_YES)\n      set_remote_option(data, i, CURL_YES);\n  }\n}\n\n#ifndef CURL_DISABLE_VERBOSE_STRINGS\nstatic void printoption(struct Curl_easy *data,\n                        const char *direction, int cmd, int option)\n{\n  if(data->set.verbose) {\n    if(cmd == CURL_IAC) {\n      if(CURL_TELCMD_OK(option))\n        infof(data, \"%s IAC %s\\n\", direction, CURL_TELCMD(option));\n      else\n        infof(data, \"%s IAC %d\\n\", direction, option);\n    }\n    else {\n      const char *fmt = (cmd == CURL_WILL) ? \"WILL\" :\n                        (cmd == CURL_WONT) ? \"WONT\" :\n                        (cmd == CURL_DO) ? \"DO\" :\n                        (cmd == CURL_DONT) ? \"DONT\" : 0;\n      if(fmt) {\n        const char *opt;\n        if(CURL_TELOPT_OK(option))\n          opt = CURL_TELOPT(option);\n        else if(option == CURL_TELOPT_EXOPL)\n          opt = \"EXOPL\";\n        else\n          opt = NULL;\n\n        if(opt)\n          infof(data, \"%s %s %s\\n\", direction, fmt, opt);\n        else\n          infof(data, \"%s %s %d\\n\", direction, fmt, option);\n      }\n      else\n        infof(data, \"%s %d %d\\n\", direction, cmd, option);\n    }\n  }\n}\n#endif\n\nstatic void send_negotiation(struct Curl_easy *data, int cmd, int option)\n{\n  unsigned char buf[3];\n  ssize_t bytes_written;\n  struct connectdata *conn = data->conn;\n\n  buf[0] = CURL_IAC;\n  buf[1] = (unsigned char)cmd;\n  buf[2] = (unsigned char)option;\n\n  bytes_written = swrite(conn->sock[FIRSTSOCKET], buf, 3);\n  if(bytes_written < 0) {\n    int err = SOCKERRNO;\n    failf(data,\"Sending data failed (%d)\",err);\n  }\n\n  printoption(data, \"SENT\", cmd, option);\n}\n\nstatic\nvoid set_remote_option(struct Curl_easy *data, int option, int newstate)\n{\n  struct TELNET *tn = data->req.p.telnet;\n  if(newstate == CURL_YES) {\n    switch(tn->him[option]) {\n    case CURL_NO:\n      tn->him[option] = CURL_WANTYES;\n      send_negotiation(data, CURL_DO, option);\n      break;\n\n    case CURL_YES:\n      /* Already enabled */\n      break;\n\n    case CURL_WANTNO:\n      switch(tn->himq[option]) {\n      case CURL_EMPTY:\n        /* Already negotiating for CURL_YES, queue the request */\n        tn->himq[option] = CURL_OPPOSITE;\n        break;\n      case CURL_OPPOSITE:\n        /* Error: already queued an enable request */\n        break;\n      }\n      break;\n\n    case CURL_WANTYES:\n      switch(tn->himq[option]) {\n      case CURL_EMPTY:\n        /* Error: already negotiating for enable */\n        break;\n      case CURL_OPPOSITE:\n        tn->himq[option] = CURL_EMPTY;\n        break;\n      }\n      break;\n    }\n  }\n  else { /* NO */\n    switch(tn->him[option]) {\n    case CURL_NO:\n      /* Already disabled */\n      break;\n\n    case CURL_YES:\n      tn->him[option] = CURL_WANTNO;\n      send_negotiation(data, CURL_DONT, option);\n      break;\n\n    case CURL_WANTNO:\n      switch(tn->himq[option]) {\n      case CURL_EMPTY:\n        /* Already negotiating for NO */\n        break;\n      case CURL_OPPOSITE:\n        tn->himq[option] = CURL_EMPTY;\n        break;\n      }\n      break;\n\n    case CURL_WANTYES:\n      switch(tn->himq[option]) {\n      case CURL_EMPTY:\n        tn->himq[option] = CURL_OPPOSITE;\n        break;\n      case CURL_OPPOSITE:\n        break;\n      }\n      break;\n    }\n  }\n}\n\nstatic\nvoid rec_will(struct Curl_easy *data, int option)\n{\n  struct TELNET *tn = data->req.p.telnet;\n  switch(tn->him[option]) {\n  case CURL_NO:\n    if(tn->him_preferred[option] == CURL_YES) {\n      tn->him[option] = CURL_YES;\n      send_negotiation(data, CURL_DO, option);\n    }\n    else\n      send_negotiation(data, CURL_DONT, option);\n\n    break;\n\n  case CURL_YES:\n    /* Already enabled */\n    break;\n\n  case CURL_WANTNO:\n    switch(tn->himq[option]) {\n    case CURL_EMPTY:\n      /* Error: DONT answered by WILL */\n      tn->him[option] = CURL_NO;\n      break;\n    case CURL_OPPOSITE:\n      /* Error: DONT answered by WILL */\n      tn->him[option] = CURL_YES;\n      tn->himq[option] = CURL_EMPTY;\n      break;\n    }\n    break;\n\n  case CURL_WANTYES:\n    switch(tn->himq[option]) {\n    case CURL_EMPTY:\n      tn->him[option] = CURL_YES;\n      break;\n    case CURL_OPPOSITE:\n      tn->him[option] = CURL_WANTNO;\n      tn->himq[option] = CURL_EMPTY;\n      send_negotiation(data, CURL_DONT, option);\n      break;\n    }\n    break;\n  }\n}\n\nstatic\nvoid rec_wont(struct Curl_easy *data, int option)\n{\n  struct TELNET *tn = data->req.p.telnet;\n  switch(tn->him[option]) {\n  case CURL_NO:\n    /* Already disabled */\n    break;\n\n  case CURL_YES:\n    tn->him[option] = CURL_NO;\n    send_negotiation(data, CURL_DONT, option);\n    break;\n\n  case CURL_WANTNO:\n    switch(tn->himq[option]) {\n    case CURL_EMPTY:\n      tn->him[option] = CURL_NO;\n      break;\n\n    case CURL_OPPOSITE:\n      tn->him[option] = CURL_WANTYES;\n      tn->himq[option] = CURL_EMPTY;\n      send_negotiation(data, CURL_DO, option);\n      break;\n    }\n    break;\n\n  case CURL_WANTYES:\n    switch(tn->himq[option]) {\n    case CURL_EMPTY:\n      tn->him[option] = CURL_NO;\n      break;\n    case CURL_OPPOSITE:\n      tn->him[option] = CURL_NO;\n      tn->himq[option] = CURL_EMPTY;\n      break;\n    }\n    break;\n  }\n}\n\nstatic void\nset_local_option(struct Curl_easy *data, int option, int newstate)\n{\n  struct TELNET *tn = data->req.p.telnet;\n  if(newstate == CURL_YES) {\n    switch(tn->us[option]) {\n    case CURL_NO:\n      tn->us[option] = CURL_WANTYES;\n      send_negotiation(data, CURL_WILL, option);\n      break;\n\n    case CURL_YES:\n      /* Already enabled */\n      break;\n\n    case CURL_WANTNO:\n      switch(tn->usq[option]) {\n      case CURL_EMPTY:\n        /* Already negotiating for CURL_YES, queue the request */\n        tn->usq[option] = CURL_OPPOSITE;\n        break;\n      case CURL_OPPOSITE:\n        /* Error: already queued an enable request */\n        break;\n      }\n      break;\n\n    case CURL_WANTYES:\n      switch(tn->usq[option]) {\n      case CURL_EMPTY:\n        /* Error: already negotiating for enable */\n        break;\n      case CURL_OPPOSITE:\n        tn->usq[option] = CURL_EMPTY;\n        break;\n      }\n      break;\n    }\n  }\n  else { /* NO */\n    switch(tn->us[option]) {\n    case CURL_NO:\n      /* Already disabled */\n      break;\n\n    case CURL_YES:\n      tn->us[option] = CURL_WANTNO;\n      send_negotiation(data, CURL_WONT, option);\n      break;\n\n    case CURL_WANTNO:\n      switch(tn->usq[option]) {\n      case CURL_EMPTY:\n        /* Already negotiating for NO */\n        break;\n      case CURL_OPPOSITE:\n        tn->usq[option] = CURL_EMPTY;\n        break;\n      }\n      break;\n\n    case CURL_WANTYES:\n      switch(tn->usq[option]) {\n      case CURL_EMPTY:\n        tn->usq[option] = CURL_OPPOSITE;\n        break;\n      case CURL_OPPOSITE:\n        break;\n      }\n      break;\n    }\n  }\n}\n\nstatic\nvoid rec_do(struct Curl_easy *data, int option)\n{\n  struct TELNET *tn = data->req.p.telnet;\n  switch(tn->us[option]) {\n  case CURL_NO:\n    if(tn->us_preferred[option] == CURL_YES) {\n      tn->us[option] = CURL_YES;\n      send_negotiation(data, CURL_WILL, option);\n      if(tn->subnegotiation[option] == CURL_YES)\n        /* transmission of data option */\n        sendsuboption(data, option);\n    }\n    else if(tn->subnegotiation[option] == CURL_YES) {\n      /* send information to achieve this option*/\n      tn->us[option] = CURL_YES;\n      send_negotiation(data, CURL_WILL, option);\n      sendsuboption(data, option);\n    }\n    else\n      send_negotiation(data, CURL_WONT, option);\n    break;\n\n  case CURL_YES:\n    /* Already enabled */\n    break;\n\n  case CURL_WANTNO:\n    switch(tn->usq[option]) {\n    case CURL_EMPTY:\n      /* Error: DONT answered by WILL */\n      tn->us[option] = CURL_NO;\n      break;\n    case CURL_OPPOSITE:\n      /* Error: DONT answered by WILL */\n      tn->us[option] = CURL_YES;\n      tn->usq[option] = CURL_EMPTY;\n      break;\n    }\n    break;\n\n  case CURL_WANTYES:\n    switch(tn->usq[option]) {\n    case CURL_EMPTY:\n      tn->us[option] = CURL_YES;\n      if(tn->subnegotiation[option] == CURL_YES) {\n        /* transmission of data option */\n        sendsuboption(data, option);\n      }\n      break;\n    case CURL_OPPOSITE:\n      tn->us[option] = CURL_WANTNO;\n      tn->himq[option] = CURL_EMPTY;\n      send_negotiation(data, CURL_WONT, option);\n      break;\n    }\n    break;\n  }\n}\n\nstatic\nvoid rec_dont(struct Curl_easy *data, int option)\n{\n  struct TELNET *tn = data->req.p.telnet;\n  switch(tn->us[option]) {\n  case CURL_NO:\n    /* Already disabled */\n    break;\n\n  case CURL_YES:\n    tn->us[option] = CURL_NO;\n    send_negotiation(data, CURL_WONT, option);\n    break;\n\n  case CURL_WANTNO:\n    switch(tn->usq[option]) {\n    case CURL_EMPTY:\n      tn->us[option] = CURL_NO;\n      break;\n\n    case CURL_OPPOSITE:\n      tn->us[option] = CURL_WANTYES;\n      tn->usq[option] = CURL_EMPTY;\n      send_negotiation(data, CURL_WILL, option);\n      break;\n    }\n    break;\n\n  case CURL_WANTYES:\n    switch(tn->usq[option]) {\n    case CURL_EMPTY:\n      tn->us[option] = CURL_NO;\n      break;\n    case CURL_OPPOSITE:\n      tn->us[option] = CURL_NO;\n      tn->usq[option] = CURL_EMPTY;\n      break;\n    }\n    break;\n  }\n}\n\n\nstatic void printsub(struct Curl_easy *data,\n                     int direction,             /* '<' or '>' */\n                     unsigned char *pointer,    /* where suboption data is */\n                     size_t length)             /* length of suboption data */\n{\n  if(data->set.verbose) {\n    unsigned int i = 0;\n    if(direction) {\n      infof(data, \"%s IAC SB \", (direction == '<')? \"RCVD\":\"SENT\");\n      if(length >= 3) {\n        int j;\n\n        i = pointer[length-2];\n        j = pointer[length-1];\n\n        if(i != CURL_IAC || j != CURL_SE) {\n          infof(data, \"(terminated by \");\n          if(CURL_TELOPT_OK(i))\n            infof(data, \"%s \", CURL_TELOPT(i));\n          else if(CURL_TELCMD_OK(i))\n            infof(data, \"%s \", CURL_TELCMD(i));\n          else\n            infof(data, \"%u \", i);\n          if(CURL_TELOPT_OK(j))\n            infof(data, \"%s\", CURL_TELOPT(j));\n          else if(CURL_TELCMD_OK(j))\n            infof(data, \"%s\", CURL_TELCMD(j));\n          else\n            infof(data, \"%d\", j);\n          infof(data, \", not IAC SE!) \");\n        }\n      }\n      length -= 2;\n    }\n    if(length < 1) {\n      infof(data, \"(Empty suboption?)\");\n      return;\n    }\n\n    if(CURL_TELOPT_OK(pointer[0])) {\n      switch(pointer[0]) {\n      case CURL_TELOPT_TTYPE:\n      case CURL_TELOPT_XDISPLOC:\n      case CURL_TELOPT_NEW_ENVIRON:\n      case CURL_TELOPT_NAWS:\n        infof(data, \"%s\", CURL_TELOPT(pointer[0]));\n        break;\n      default:\n        infof(data, \"%s (unsupported)\", CURL_TELOPT(pointer[0]));\n        break;\n      }\n    }\n    else\n      infof(data, \"%d (unknown)\", pointer[i]);\n\n    switch(pointer[0]) {\n    case CURL_TELOPT_NAWS:\n      if(length > 4)\n        infof(data, \"Width: %d ; Height: %d\", (pointer[1]<<8) | pointer[2],\n              (pointer[3]<<8) | pointer[4]);\n      break;\n    default:\n      switch(pointer[1]) {\n      case CURL_TELQUAL_IS:\n        infof(data, \" IS\");\n        break;\n      case CURL_TELQUAL_SEND:\n        infof(data, \" SEND\");\n        break;\n      case CURL_TELQUAL_INFO:\n        infof(data, \" INFO/REPLY\");\n        break;\n      case CURL_TELQUAL_NAME:\n        infof(data, \" NAME\");\n        break;\n      }\n\n      switch(pointer[0]) {\n      case CURL_TELOPT_TTYPE:\n      case CURL_TELOPT_XDISPLOC:\n        pointer[length] = 0;\n        infof(data, \" \\\"%s\\\"\", &pointer[2]);\n        break;\n      case CURL_TELOPT_NEW_ENVIRON:\n        if(pointer[1] == CURL_TELQUAL_IS) {\n          infof(data, \" \");\n          for(i = 3; i < length; i++) {\n            switch(pointer[i]) {\n            case CURL_NEW_ENV_VAR:\n              infof(data, \", \");\n              break;\n            case CURL_NEW_ENV_VALUE:\n              infof(data, \" = \");\n              break;\n            default:\n              infof(data, \"%c\", pointer[i]);\n              break;\n            }\n          }\n        }\n        break;\n      default:\n        for(i = 2; i < length; i++)\n          infof(data, \" %.2x\", pointer[i]);\n        break;\n      }\n    }\n    if(direction)\n      infof(data, \"\\n\");\n  }\n}\n\nstatic CURLcode check_telnet_options(struct Curl_easy *data)\n{\n  struct curl_slist *head;\n  struct curl_slist *beg;\n  char option_keyword[128] = \"\";\n  char option_arg[256] = \"\";\n  struct TELNET *tn = data->req.p.telnet;\n  struct connectdata *conn = data->conn;\n  CURLcode result = CURLE_OK;\n  int binary_option;\n\n  /* Add the user name as an environment variable if it\n     was given on the command line */\n  if(conn->bits.user_passwd) {\n    msnprintf(option_arg, sizeof(option_arg), \"USER,%s\", conn->user);\n    beg = curl_slist_append(tn->telnet_vars, option_arg);\n    if(!beg) {\n      curl_slist_free_all(tn->telnet_vars);\n      tn->telnet_vars = NULL;\n      return CURLE_OUT_OF_MEMORY;\n    }\n    tn->telnet_vars = beg;\n    tn->us_preferred[CURL_TELOPT_NEW_ENVIRON] = CURL_YES;\n  }\n\n  for(head = data->set.telnet_options; head; head = head->next) {\n    if(sscanf(head->data, \"%127[^= ]%*[ =]%255s\",\n              option_keyword, option_arg) == 2) {\n\n      /* Terminal type */\n      if(strcasecompare(option_keyword, \"TTYPE\")) {\n        strncpy(tn->subopt_ttype, option_arg, 31);\n        tn->subopt_ttype[31] = 0; /* String termination */\n        tn->us_preferred[CURL_TELOPT_TTYPE] = CURL_YES;\n        continue;\n      }\n\n      /* Display variable */\n      if(strcasecompare(option_keyword, \"XDISPLOC\")) {\n        strncpy(tn->subopt_xdisploc, option_arg, 127);\n        tn->subopt_xdisploc[127] = 0; /* String termination */\n        tn->us_preferred[CURL_TELOPT_XDISPLOC] = CURL_YES;\n        continue;\n      }\n\n      /* Environment variable */\n      if(strcasecompare(option_keyword, \"NEW_ENV\")) {\n        beg = curl_slist_append(tn->telnet_vars, option_arg);\n        if(!beg) {\n          result = CURLE_OUT_OF_MEMORY;\n          break;\n        }\n        tn->telnet_vars = beg;\n        tn->us_preferred[CURL_TELOPT_NEW_ENVIRON] = CURL_YES;\n        continue;\n      }\n\n      /* Window Size */\n      if(strcasecompare(option_keyword, \"WS\")) {\n        if(sscanf(option_arg, \"%hu%*[xX]%hu\",\n                  &tn->subopt_wsx, &tn->subopt_wsy) == 2)\n          tn->us_preferred[CURL_TELOPT_NAWS] = CURL_YES;\n        else {\n          failf(data, \"Syntax error in telnet option: %s\", head->data);\n          result = CURLE_TELNET_OPTION_SYNTAX;\n          break;\n        }\n        continue;\n      }\n\n      /* To take care or not of the 8th bit in data exchange */\n      if(strcasecompare(option_keyword, \"BINARY\")) {\n        binary_option = atoi(option_arg);\n        if(binary_option != 1) {\n          tn->us_preferred[CURL_TELOPT_BINARY] = CURL_NO;\n          tn->him_preferred[CURL_TELOPT_BINARY] = CURL_NO;\n        }\n        continue;\n      }\n\n      failf(data, \"Unknown telnet option %s\", head->data);\n      result = CURLE_UNKNOWN_OPTION;\n      break;\n    }\n    failf(data, \"Syntax error in telnet option: %s\", head->data);\n    result = CURLE_TELNET_OPTION_SYNTAX;\n    break;\n  }\n\n  if(result) {\n    curl_slist_free_all(tn->telnet_vars);\n    tn->telnet_vars = NULL;\n  }\n\n  return result;\n}\n\n/*\n * suboption()\n *\n * Look at the sub-option buffer, and try to be helpful to the other\n * side.\n */\n\nstatic void suboption(struct Curl_easy *data)\n{\n  struct curl_slist *v;\n  unsigned char temp[2048];\n  ssize_t bytes_written;\n  size_t len;\n  int err;\n  char varname[128] = \"\";\n  char varval[128] = \"\";\n  struct TELNET *tn = data->req.p.telnet;\n  struct connectdata *conn = data->conn;\n\n  printsub(data, '<', (unsigned char *)tn->subbuffer, CURL_SB_LEN(tn) + 2);\n  switch(CURL_SB_GET(tn)) {\n    case CURL_TELOPT_TTYPE:\n      len = strlen(tn->subopt_ttype) + 4 + 2;\n      msnprintf((char *)temp, sizeof(temp),\n                \"%c%c%c%c%s%c%c\", CURL_IAC, CURL_SB, CURL_TELOPT_TTYPE,\n                CURL_TELQUAL_IS, tn->subopt_ttype, CURL_IAC, CURL_SE);\n      bytes_written = swrite(conn->sock[FIRSTSOCKET], temp, len);\n      if(bytes_written < 0) {\n        err = SOCKERRNO;\n        failf(data,\"Sending data failed (%d)\",err);\n      }\n      printsub(data, '>', &temp[2], len-2);\n      break;\n    case CURL_TELOPT_XDISPLOC:\n      len = strlen(tn->subopt_xdisploc) + 4 + 2;\n      msnprintf((char *)temp, sizeof(temp),\n                \"%c%c%c%c%s%c%c\", CURL_IAC, CURL_SB, CURL_TELOPT_XDISPLOC,\n                CURL_TELQUAL_IS, tn->subopt_xdisploc, CURL_IAC, CURL_SE);\n      bytes_written = swrite(conn->sock[FIRSTSOCKET], temp, len);\n      if(bytes_written < 0) {\n        err = SOCKERRNO;\n        failf(data,\"Sending data failed (%d)\",err);\n      }\n      printsub(data, '>', &temp[2], len-2);\n      break;\n    case CURL_TELOPT_NEW_ENVIRON:\n      msnprintf((char *)temp, sizeof(temp),\n                \"%c%c%c%c\", CURL_IAC, CURL_SB, CURL_TELOPT_NEW_ENVIRON,\n                CURL_TELQUAL_IS);\n      len = 4;\n\n      for(v = tn->telnet_vars; v; v = v->next) {\n        size_t tmplen = (strlen(v->data) + 1);\n        /* Add the variable only if it fits */\n        if(len + tmplen < (int)sizeof(temp)-6) {\n          if(sscanf(v->data, \"%127[^,],%127s\", varname, varval) == 2) {\n            msnprintf((char *)&temp[len], sizeof(temp) - len,\n                      \"%c%s%c%s\", CURL_NEW_ENV_VAR, varname,\n                      CURL_NEW_ENV_VALUE, varval);\n            len += tmplen;\n          }\n        }\n      }\n      msnprintf((char *)&temp[len], sizeof(temp) - len,\n                \"%c%c\", CURL_IAC, CURL_SE);\n      len += 2;\n      bytes_written = swrite(conn->sock[FIRSTSOCKET], temp, len);\n      if(bytes_written < 0) {\n        err = SOCKERRNO;\n        failf(data,\"Sending data failed (%d)\",err);\n      }\n      printsub(data, '>', &temp[2], len-2);\n      break;\n  }\n  return;\n}\n\n\n/*\n * sendsuboption()\n *\n * Send suboption information to the server side.\n */\n\nstatic void sendsuboption(struct Curl_easy *data, int option)\n{\n  ssize_t bytes_written;\n  int err;\n  unsigned short x, y;\n  unsigned char *uc1, *uc2;\n  struct TELNET *tn = data->req.p.telnet;\n  struct connectdata *conn = data->conn;\n\n  switch(option) {\n  case CURL_TELOPT_NAWS:\n    /* We prepare data to be sent */\n    CURL_SB_CLEAR(tn);\n    CURL_SB_ACCUM(tn, CURL_IAC);\n    CURL_SB_ACCUM(tn, CURL_SB);\n    CURL_SB_ACCUM(tn, CURL_TELOPT_NAWS);\n    /* We must deal either with little or big endian processors */\n    /* Window size must be sent according to the 'network order' */\n    x = htons(tn->subopt_wsx);\n    y = htons(tn->subopt_wsy);\n    uc1 = (unsigned char *)&x;\n    uc2 = (unsigned char *)&y;\n    CURL_SB_ACCUM(tn, uc1[0]);\n    CURL_SB_ACCUM(tn, uc1[1]);\n    CURL_SB_ACCUM(tn, uc2[0]);\n    CURL_SB_ACCUM(tn, uc2[1]);\n\n    CURL_SB_ACCUM(tn, CURL_IAC);\n    CURL_SB_ACCUM(tn, CURL_SE);\n    CURL_SB_TERM(tn);\n    /* data suboption is now ready */\n\n    printsub(data, '>', (unsigned char *)tn->subbuffer + 2,\n             CURL_SB_LEN(tn)-2);\n\n    /* we send the header of the suboption... */\n    bytes_written = swrite(conn->sock[FIRSTSOCKET], tn->subbuffer, 3);\n    if(bytes_written < 0) {\n      err = SOCKERRNO;\n      failf(data, \"Sending data failed (%d)\", err);\n    }\n    /* ... then the window size with the send_telnet_data() function\n       to deal with 0xFF cases ... */\n    send_telnet_data(data, (char *)tn->subbuffer + 3, 4);\n    /* ... and the footer */\n    bytes_written = swrite(conn->sock[FIRSTSOCKET], tn->subbuffer + 7, 2);\n    if(bytes_written < 0) {\n      err = SOCKERRNO;\n      failf(data, \"Sending data failed (%d)\", err);\n    }\n    break;\n  }\n}\n\n\nstatic\nCURLcode telrcv(struct Curl_easy *data,\n                const unsigned char *inbuf, /* Data received from socket */\n                ssize_t count)              /* Number of bytes received */\n{\n  unsigned char c;\n  CURLcode result;\n  int in = 0;\n  int startwrite = -1;\n  struct TELNET *tn = data->req.p.telnet;\n\n#define startskipping()                                       \\\n  if(startwrite >= 0) {                                       \\\n    result = Curl_client_write(data,                          \\\n                               CLIENTWRITE_BODY,              \\\n                               (char *)&inbuf[startwrite],    \\\n                               in-startwrite);                \\\n    if(result)                                                \\\n      return result;                                          \\\n  }                                                           \\\n  startwrite = -1\n\n#define writebyte() \\\n    if(startwrite < 0) \\\n      startwrite = in\n\n#define bufferflush() startskipping()\n\n  while(count--) {\n    c = inbuf[in];\n\n    switch(tn->telrcv_state) {\n    case CURL_TS_CR:\n      tn->telrcv_state = CURL_TS_DATA;\n      if(c == '\\0') {\n        startskipping();\n        break;   /* Ignore \\0 after CR */\n      }\n      writebyte();\n      break;\n\n    case CURL_TS_DATA:\n      if(c == CURL_IAC) {\n        tn->telrcv_state = CURL_TS_IAC;\n        startskipping();\n        break;\n      }\n      else if(c == '\\r')\n        tn->telrcv_state = CURL_TS_CR;\n      writebyte();\n      break;\n\n    case CURL_TS_IAC:\n    process_iac:\n      DEBUGASSERT(startwrite < 0);\n      switch(c) {\n      case CURL_WILL:\n        tn->telrcv_state = CURL_TS_WILL;\n        break;\n      case CURL_WONT:\n        tn->telrcv_state = CURL_TS_WONT;\n        break;\n      case CURL_DO:\n        tn->telrcv_state = CURL_TS_DO;\n        break;\n      case CURL_DONT:\n        tn->telrcv_state = CURL_TS_DONT;\n        break;\n      case CURL_SB:\n        CURL_SB_CLEAR(tn);\n        tn->telrcv_state = CURL_TS_SB;\n        break;\n      case CURL_IAC:\n        tn->telrcv_state = CURL_TS_DATA;\n        writebyte();\n        break;\n      case CURL_DM:\n      case CURL_NOP:\n      case CURL_GA:\n      default:\n        tn->telrcv_state = CURL_TS_DATA;\n        printoption(data, \"RCVD\", CURL_IAC, c);\n        break;\n      }\n      break;\n\n      case CURL_TS_WILL:\n        printoption(data, \"RCVD\", CURL_WILL, c);\n        tn->please_negotiate = 1;\n        rec_will(data, c);\n        tn->telrcv_state = CURL_TS_DATA;\n        break;\n\n      case CURL_TS_WONT:\n        printoption(data, \"RCVD\", CURL_WONT, c);\n        tn->please_negotiate = 1;\n        rec_wont(data, c);\n        tn->telrcv_state = CURL_TS_DATA;\n        break;\n\n      case CURL_TS_DO:\n        printoption(data, \"RCVD\", CURL_DO, c);\n        tn->please_negotiate = 1;\n        rec_do(data, c);\n        tn->telrcv_state = CURL_TS_DATA;\n        break;\n\n      case CURL_TS_DONT:\n        printoption(data, \"RCVD\", CURL_DONT, c);\n        tn->please_negotiate = 1;\n        rec_dont(data, c);\n        tn->telrcv_state = CURL_TS_DATA;\n        break;\n\n      case CURL_TS_SB:\n        if(c == CURL_IAC)\n          tn->telrcv_state = CURL_TS_SE;\n        else\n          CURL_SB_ACCUM(tn, c);\n        break;\n\n      case CURL_TS_SE:\n        if(c != CURL_SE) {\n          if(c != CURL_IAC) {\n            /*\n             * This is an error.  We only expect to get \"IAC IAC\" or \"IAC SE\".\n             * Several things may have happened.  An IAC was not doubled, the\n             * IAC SE was left off, or another option got inserted into the\n             * suboption are all possibilities.  If we assume that the IAC was\n             * not doubled, and really the IAC SE was left off, we could get\n             * into an infinite loop here.  So, instead, we terminate the\n             * suboption, and process the partial suboption if we can.\n             */\n            CURL_SB_ACCUM(tn, CURL_IAC);\n            CURL_SB_ACCUM(tn, c);\n            tn->subpointer -= 2;\n            CURL_SB_TERM(tn);\n\n            printoption(data, \"In SUBOPTION processing, RCVD\", CURL_IAC, c);\n            suboption(data);   /* handle sub-option */\n            tn->telrcv_state = CURL_TS_IAC;\n            goto process_iac;\n          }\n          CURL_SB_ACCUM(tn, c);\n          tn->telrcv_state = CURL_TS_SB;\n        }\n        else {\n          CURL_SB_ACCUM(tn, CURL_IAC);\n          CURL_SB_ACCUM(tn, CURL_SE);\n          tn->subpointer -= 2;\n          CURL_SB_TERM(tn);\n          suboption(data);   /* handle sub-option */\n          tn->telrcv_state = CURL_TS_DATA;\n        }\n        break;\n    }\n    ++in;\n  }\n  bufferflush();\n  return CURLE_OK;\n}\n\n/* Escape and send a telnet data block */\nstatic CURLcode send_telnet_data(struct Curl_easy *data,\n                                 char *buffer, ssize_t nread)\n{\n  ssize_t escapes, i, outlen;\n  unsigned char *outbuf = NULL;\n  CURLcode result = CURLE_OK;\n  ssize_t bytes_written, total_written;\n  struct connectdata *conn = data->conn;\n\n  /* Determine size of new buffer after escaping */\n  escapes = 0;\n  for(i = 0; i < nread; i++)\n    if((unsigned char)buffer[i] == CURL_IAC)\n      escapes++;\n  outlen = nread + escapes;\n\n  if(outlen == nread)\n    outbuf = (unsigned char *)buffer;\n  else {\n    ssize_t j;\n    outbuf = malloc(nread + escapes + 1);\n    if(!outbuf)\n      return CURLE_OUT_OF_MEMORY;\n\n    j = 0;\n    for(i = 0; i < nread; i++) {\n      outbuf[j++] = buffer[i];\n      if((unsigned char)buffer[i] == CURL_IAC)\n        outbuf[j++] = CURL_IAC;\n    }\n    outbuf[j] = '\\0';\n  }\n\n  total_written = 0;\n  while(!result && total_written < outlen) {\n    /* Make sure socket is writable to avoid EWOULDBLOCK condition */\n    struct pollfd pfd[1];\n    pfd[0].fd = conn->sock[FIRSTSOCKET];\n    pfd[0].events = POLLOUT;\n    switch(Curl_poll(pfd, 1, -1)) {\n      case -1:                    /* error, abort writing */\n      case 0:                     /* timeout (will never happen) */\n        result = CURLE_SEND_ERROR;\n        break;\n      default:                    /* write! */\n        bytes_written = 0;\n        result = Curl_write(data, conn->sock[FIRSTSOCKET],\n                            outbuf + total_written,\n                            outlen - total_written,\n                            &bytes_written);\n        total_written += bytes_written;\n        break;\n    }\n  }\n\n  /* Free malloc copy if escaped */\n  if(outbuf != (unsigned char *)buffer)\n    free(outbuf);\n\n  return result;\n}\n\nstatic CURLcode telnet_done(struct Curl_easy *data,\n                            CURLcode status, bool premature)\n{\n  struct TELNET *tn = data->req.p.telnet;\n  (void)status; /* unused */\n  (void)premature; /* not used */\n\n  if(!tn)\n    return CURLE_OK;\n\n  curl_slist_free_all(tn->telnet_vars);\n  tn->telnet_vars = NULL;\n\n  Curl_safefree(data->req.p.telnet);\n\n  return CURLE_OK;\n}\n\nstatic CURLcode telnet_do(struct Curl_easy *data, bool *done)\n{\n  CURLcode result;\n  struct connectdata *conn = data->conn;\n  curl_socket_t sockfd = conn->sock[FIRSTSOCKET];\n#ifdef USE_WINSOCK\n  WSAEVENT event_handle;\n  WSANETWORKEVENTS events;\n  HANDLE stdin_handle;\n  HANDLE objs[2];\n  DWORD  obj_count;\n  DWORD  wait_timeout;\n  DWORD readfile_read;\n  int err;\n#else\n  timediff_t interval_ms;\n  struct pollfd pfd[2];\n  int poll_cnt;\n  curl_off_t total_dl = 0;\n  curl_off_t total_ul = 0;\n#endif\n  ssize_t nread;\n  struct curltime now;\n  bool keepon = TRUE;\n  char *buf = data->state.buffer;\n  struct TELNET *tn;\n\n  *done = TRUE; /* unconditionally */\n\n  result = init_telnet(data);\n  if(result)\n    return result;\n\n  tn = data->req.p.telnet;\n\n  result = check_telnet_options(data);\n  if(result)\n    return result;\n\n#ifdef USE_WINSOCK\n  /* We want to wait for both stdin and the socket. Since\n  ** the select() function in winsock only works on sockets\n  ** we have to use the WaitForMultipleObjects() call.\n  */\n\n  /* First, create a sockets event object */\n  event_handle = WSACreateEvent();\n  if(event_handle == WSA_INVALID_EVENT) {\n    failf(data, \"WSACreateEvent failed (%d)\", SOCKERRNO);\n    return CURLE_FAILED_INIT;\n  }\n\n  /* Tell winsock what events we want to listen to */\n  if(WSAEventSelect(sockfd, event_handle, FD_READ|FD_CLOSE) == SOCKET_ERROR) {\n    WSACloseEvent(event_handle);\n    return CURLE_OK;\n  }\n\n  /* The get the Windows file handle for stdin */\n  stdin_handle = GetStdHandle(STD_INPUT_HANDLE);\n\n  /* Create the list of objects to wait for */\n  objs[0] = event_handle;\n  objs[1] = stdin_handle;\n\n  /* If stdin_handle is a pipe, use PeekNamedPipe() method to check it,\n     else use the old WaitForMultipleObjects() way */\n  if(GetFileType(stdin_handle) == FILE_TYPE_PIPE ||\n     data->set.is_fread_set) {\n    /* Don't wait for stdin_handle, just wait for event_handle */\n    obj_count = 1;\n    /* Check stdin_handle per 100 milliseconds */\n    wait_timeout = 100;\n  }\n  else {\n    obj_count = 2;\n    wait_timeout = 1000;\n  }\n\n  /* Keep on listening and act on events */\n  while(keepon) {\n    const DWORD buf_size = (DWORD)data->set.buffer_size;\n    DWORD waitret = WaitForMultipleObjects(obj_count, objs,\n                                           FALSE, wait_timeout);\n    switch(waitret) {\n\n    case WAIT_TIMEOUT:\n    {\n      for(;;) {\n        if(data->set.is_fread_set) {\n          size_t n;\n          /* read from user-supplied method */\n          n = data->state.fread_func(buf, 1, buf_size, data->state.in);\n          if(n == CURL_READFUNC_ABORT) {\n            keepon = FALSE;\n            result = CURLE_READ_ERROR;\n            break;\n          }\n\n          if(n == CURL_READFUNC_PAUSE)\n            break;\n\n          if(n == 0)                        /* no bytes */\n            break;\n\n          /* fall through with number of bytes read */\n          readfile_read = (DWORD)n;\n        }\n        else {\n          /* read from stdin */\n          if(!PeekNamedPipe(stdin_handle, NULL, 0, NULL,\n                            &readfile_read, NULL)) {\n            keepon = FALSE;\n            result = CURLE_READ_ERROR;\n            break;\n          }\n\n          if(!readfile_read)\n            break;\n\n          if(!ReadFile(stdin_handle, buf, buf_size,\n                       &readfile_read, NULL)) {\n            keepon = FALSE;\n            result = CURLE_READ_ERROR;\n            break;\n          }\n        }\n\n        result = send_telnet_data(data, buf, readfile_read);\n        if(result) {\n          keepon = FALSE;\n          break;\n        }\n      }\n    }\n    break;\n\n    case WAIT_OBJECT_0 + 1:\n    {\n      if(!ReadFile(stdin_handle, buf, buf_size,\n                   &readfile_read, NULL)) {\n        keepon = FALSE;\n        result = CURLE_READ_ERROR;\n        break;\n      }\n\n      result = send_telnet_data(data, buf, readfile_read);\n      if(result) {\n        keepon = FALSE;\n        break;\n      }\n    }\n    break;\n\n    case WAIT_OBJECT_0:\n    {\n      events.lNetworkEvents = 0;\n      if(WSAEnumNetworkEvents(sockfd, event_handle, &events) == SOCKET_ERROR) {\n        err = SOCKERRNO;\n        if(err != EINPROGRESS) {\n          infof(data, \"WSAEnumNetworkEvents failed (%d)\", err);\n          keepon = FALSE;\n          result = CURLE_READ_ERROR;\n        }\n        break;\n      }\n      if(events.lNetworkEvents & FD_READ) {\n        /* read data from network */\n        result = Curl_read(data, sockfd, buf, data->set.buffer_size, &nread);\n        /* read would've blocked. Loop again */\n        if(result == CURLE_AGAIN)\n          break;\n        /* returned not-zero, this an error */\n        else if(result) {\n          keepon = FALSE;\n          break;\n        }\n        /* returned zero but actually received 0 or less here,\n           the server closed the connection and we bail out */\n        else if(nread <= 0) {\n          keepon = FALSE;\n          break;\n        }\n\n        result = telrcv(data, (unsigned char *) buf, nread);\n        if(result) {\n          keepon = FALSE;\n          break;\n        }\n\n        /* Negotiate if the peer has started negotiating,\n           otherwise don't. We don't want to speak telnet with\n           non-telnet servers, like POP or SMTP. */\n        if(tn->please_negotiate && !tn->already_negotiated) {\n          negotiate(data);\n          tn->already_negotiated = 1;\n        }\n      }\n      if(events.lNetworkEvents & FD_CLOSE) {\n        keepon = FALSE;\n      }\n    }\n    break;\n\n    }\n\n    if(data->set.timeout) {\n      now = Curl_now();\n      if(Curl_timediff(now, conn->created) >= data->set.timeout) {\n        failf(data, \"Time-out\");\n        result = CURLE_OPERATION_TIMEDOUT;\n        keepon = FALSE;\n      }\n    }\n  }\n\n  /* We called WSACreateEvent, so call WSACloseEvent */\n  if(!WSACloseEvent(event_handle)) {\n    infof(data, \"WSACloseEvent failed (%d)\", SOCKERRNO);\n  }\n#else\n  pfd[0].fd = sockfd;\n  pfd[0].events = POLLIN;\n\n  if(data->set.is_fread_set) {\n    poll_cnt = 1;\n    interval_ms = 100; /* poll user-supplied read function */\n  }\n  else {\n    /* really using fread, so infile is a FILE* */\n    pfd[1].fd = fileno((FILE *)data->state.in);\n    pfd[1].events = POLLIN;\n    poll_cnt = 2;\n    interval_ms = 1 * 1000;\n  }\n\n  while(keepon) {\n    switch(Curl_poll(pfd, poll_cnt, interval_ms)) {\n    case -1:                    /* error, stop reading */\n      keepon = FALSE;\n      continue;\n    case 0:                     /* timeout */\n      pfd[0].revents = 0;\n      pfd[1].revents = 0;\n      /* FALLTHROUGH */\n    default:                    /* read! */\n      if(pfd[0].revents & POLLIN) {\n        /* read data from network */\n        result = Curl_read(data, sockfd, buf, data->set.buffer_size, &nread);\n        /* read would've blocked. Loop again */\n        if(result == CURLE_AGAIN)\n          break;\n        /* returned not-zero, this an error */\n        if(result) {\n          keepon = FALSE;\n          break;\n        }\n        /* returned zero but actually received 0 or less here,\n           the server closed the connection and we bail out */\n        else if(nread <= 0) {\n          keepon = FALSE;\n          break;\n        }\n\n        total_dl += nread;\n        Curl_pgrsSetDownloadCounter(data, total_dl);\n        result = telrcv(data, (unsigned char *)buf, nread);\n        if(result) {\n          keepon = FALSE;\n          break;\n        }\n\n        /* Negotiate if the peer has started negotiating,\n           otherwise don't. We don't want to speak telnet with\n           non-telnet servers, like POP or SMTP. */\n        if(tn->please_negotiate && !tn->already_negotiated) {\n          negotiate(data);\n          tn->already_negotiated = 1;\n        }\n      }\n\n      nread = 0;\n      if(poll_cnt == 2) {\n        if(pfd[1].revents & POLLIN) { /* read from in file */\n          nread = read(pfd[1].fd, buf, data->set.buffer_size);\n        }\n      }\n      else {\n        /* read from user-supplied method */\n        nread = (int)data->state.fread_func(buf, 1, data->set.buffer_size,\n                                            data->state.in);\n        if(nread == CURL_READFUNC_ABORT) {\n          keepon = FALSE;\n          break;\n        }\n        if(nread == CURL_READFUNC_PAUSE)\n          break;\n      }\n\n      if(nread > 0) {\n        result = send_telnet_data(data, buf, nread);\n        if(result) {\n          keepon = FALSE;\n          break;\n        }\n        total_ul += nread;\n        Curl_pgrsSetUploadCounter(data, total_ul);\n      }\n      else if(nread < 0)\n        keepon = FALSE;\n\n      break;\n    } /* poll switch statement */\n\n    if(data->set.timeout) {\n      now = Curl_now();\n      if(Curl_timediff(now, conn->created) >= data->set.timeout) {\n        failf(data, \"Time-out\");\n        result = CURLE_OPERATION_TIMEDOUT;\n        keepon = FALSE;\n      }\n    }\n\n    if(Curl_pgrsUpdate(data)) {\n      result = CURLE_ABORTED_BY_CALLBACK;\n      break;\n    }\n  }\n#endif\n  /* mark this as \"no further transfer wanted\" */\n  Curl_setup_transfer(data, -1, -1, FALSE, -1);\n\n  return result;\n}\n#endif\n"], "filenames": ["lib/telnet.c"], "buggy_code_start_loc": [925], "buggy_code_end_loc": [926], "fixing_code_start_loc": [925], "fixing_code_end_loc": [926], "type": "CWE-909", "message": "curl 7.7 through 7.76.1 suffers from an information disclosure when the `-t` command line option, known as `CURLOPT_TELNETOPTIONS` in libcurl, is used to send variable=content pairs to TELNET servers. Due to a flaw in the option parser for sending NEW_ENV variables, libcurl could be made to pass on uninitialized data from a stack based buffer to the server, resulting in potentially revealing sensitive internal information to the server using a clear-text network protocol.", "other": {"cve": {"id": "CVE-2021-22898", "sourceIdentifier": "support@hackerone.com", "published": "2021-06-11T16:15:11.043", "lastModified": "2022-08-30T19:09:50.807", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "curl 7.7 through 7.76.1 suffers from an information disclosure when the `-t` command line option, known as `CURLOPT_TELNETOPTIONS` in libcurl, is used to send variable=content pairs to TELNET servers. Due to a flaw in the option parser for sending NEW_ENV variables, libcurl could be made to pass on uninitialized data from a stack based buffer to the server, resulting in potentially revealing sensitive internal information to the server using a clear-text network protocol."}, {"lang": "es", "value": "curl versiones 7.7 hasta 7.76.1 sufre de una divulgacion de informaci\u00f3n cuando la opci\u00f3n de l\u00ednea de comandos \"-t\", conocida como \"CURLOPT_TELNETOPTIONS\" en libcurl, se usa para enviar pares de variables=contenido a servidores TELNET. Debido a un fallo en el analizador de opciones para el env\u00edo de variables NEW_ENV, podr\u00eda hacer que libcurl pasara datos no inicializados de un b\u00fafer basado en la pila al servidor, resultando en una potencial divulgaci\u00f3n de informaci\u00f3n interna confidencial al servidor que usaba un protocolo de red de texto sin cifrar"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 3.1, "baseSeverity": "LOW"}, "exploitabilityScore": 1.6, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:H/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "HIGH", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.6}, "baseSeverity": "LOW", "exploitabilityScore": 4.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-909"}]}, {"source": "support@hackerone.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:haxx:curl:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.7", "versionEndIncluding": "7.76.1", "matchCriteriaId": "45116E63-5ED9-4CBC-85D9-D6E432C06AE3"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:33:*:*:*:*:*:*:*", "matchCriteriaId": "E460AA51-FCDA-46B9-AE97-E6676AA5E194"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_cloud_native_core_binding_support_function:1.11.0:*:*:*:*:*:*:*", "matchCriteriaId": "10323322-F6C0-4EA7-9344-736F7A80AA5F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_cloud_native_core_network_function_cloud_native_environment:1.10.0:*:*:*:*:*:*:*", "matchCriteriaId": "C2A5B24D-BDF2-423C-98EA-A40778C01A05"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_cloud_native_core_network_repository_function:1.15.0:*:*:*:*:*:*:*", "matchCriteriaId": "6F60E32F-0CA0-4C2D-9848-CB92765A9ACB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_cloud_native_core_network_repository_function:1.15.1:*:*:*:*:*:*:*", "matchCriteriaId": "DF616620-88CE-4A77-B904-C1728A2E6F9B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_cloud_native_core_network_slice_selection_function:1.8.0:*:*:*:*:*:*:*", "matchCriteriaId": "3AA09838-BF13-46AC-BB97-A69F48B73A8A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_cloud_native_core_service_communication_proxy:1.15.0:*:*:*:*:*:*:*", "matchCriteriaId": "175B97A7-0B00-4378-AD9F-C01B6D9FD570"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:essbase:*:*:*:*:*:*:*:*", "versionEndExcluding": "11.1.2.4.047", "matchCriteriaId": "6A0BD5BD-E2F8-4B4E-B5CF-9787E6F2E4AE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:essbase:*:*:*:*:*:*:*:*", "versionStartIncluding": "21.0", "versionEndExcluding": "21.3", "matchCriteriaId": "3197F464-F0A5-4BD4-9068-65CD448D8F4C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:mysql_server:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.7.34", "matchCriteriaId": "B029E259-2B7F-4491-9CB1-05FD3B8245C0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:mysql_server:*:*:*:*:*:*:*:*", "versionStartIncluding": "8.0.15", "versionEndExcluding": "8.0.25", "matchCriteriaId": "262D1BF5-6417-4977-8304-E1812E94F3C0"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:siemens:sinec_infrastructure_network_services:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.0.1.1", "matchCriteriaId": "B0F46497-4AB0-49A7-9453-CC26837BF253"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2021/07/21/4", "source": "support@hackerone.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://cert-portal.siemens.com/productcert/pdf/ssa-389290.pdf", "source": "support@hackerone.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://curl.se/docs/CVE-2021-22898.html", "source": "support@hackerone.com", "tags": ["Exploit", "Patch", "Vendor Advisory"]}, {"url": "https://github.com/curl/curl/commit/39ce47f219b09c380b81f89fe54ac586c8db6bde", "source": "support@hackerone.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://hackerone.com/reports/1176461", "source": "support@hackerone.com", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rc713534b10f9daeee2e0990239fa407e2118e4aa9e88a7041177497c@%3Cissues.guacamole.apache.org%3E", "source": "support@hackerone.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/08/msg00017.html", "source": "support@hackerone.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/08/msg00017.html", "source": "support@hackerone.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/FRUCW2UVNYUDZF72DQLFQR4PJEC6CF7V/", "source": "support@hackerone.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/POOC3UV7V6L4CJ5KA2PTWTNUV5Y72T3Q/", "source": "support@hackerone.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5197", "source": "support@hackerone.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.oracle.com//security-alerts/cpujul2021.html", "source": "support@hackerone.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpuapr2022.html", "source": "support@hackerone.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpujan2022.html", "source": "support@hackerone.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/curl/curl/commit/39ce47f219b09c380b81f89fe54ac586c8db6bde"}}