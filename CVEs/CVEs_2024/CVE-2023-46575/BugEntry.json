{"buggy_code": ["package handlers\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"path\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"github.com/layer5io/meshery/server/models\"\n\t\"github.com/layer5io/meshkit/utils\"\n\tmeshsyncmodel \"github.com/layer5io/meshsync/pkg/model\"\n\t\"gorm.io/gorm/clause\"\n)\n\n// swagger:route GET /api/system/database GetSystemDatabase idGetSystemDatabase\n// Handle GET request for getting summary about the system database.\n//\n// # Tables can be further filtered through query parameter\n//\n// ```?order={field}``` orders on the passed field\n//\n// ```?sort={[asc/desc]}``` Default behavior is asc\n//\n// ```?page={page-number}``` Default page number is 1\n//\n// ```?pagesize={pagesize}``` Default pagesize is 10. To return all results: ```pagesize=all```\n//\n// ```?search={tablename}``` If search is non empty then a greedy search is performed\n// responses:\n//\n//\t200: systemDatabaseResponseWrapper\nfunc (h *Handler) GetSystemDatabase(w http.ResponseWriter, r *http.Request, _ *models.Preference, _ *models.User, provider models.Provider) {\n\tvar tables []*models.SqliteSchema\n\tvar recordCount int\n\tvar totalTables int64\n\n\tlimitstr := r.URL.Query().Get(\"pagesize\")\n\tvar limit int\n\tif limitstr != \"all\" {\n\t\tlimit, _ = strconv.Atoi(limitstr)\n\t\tif limit <= 0 {\n\t\t\tlimit = defaultPageSize\n\t\t}\n\t}\n\tpagestr := r.URL.Query().Get(\"page\")\n\tpage, _ := strconv.Atoi(pagestr)\n\n\tif page <= 0 {\n\t\tpage = 1\n\t}\n\n\toffset := (page - 1) * limit\n\torder := r.URL.Query().Get(\"order\")\n\tsort := r.URL.Query().Get(\"sort\")\n\tsearch := r.URL.Query().Get(\"search\")\n\n\ttableFinder := h.dbHandler.DB.Table(\"sqlite_schema\").\n\t\tWhere(\"type = ?\", \"table\")\n\n\tif search != \"\" {\n\t\ttableFinder = tableFinder.Where(\"name LIKE ?\", \"%\"+search+\"%\")\n\t}\n\n\ttableFinder.Count(&totalTables)\n\n\tif limit != 0 {\n\t\ttableFinder = tableFinder.Limit(limit)\n\t}\n\tif offset != 0 {\n\t\ttableFinder = tableFinder.Offset(offset)\n\t}\n\tif order != \"\" {\n\t\tif sort == \"desc\" {\n\t\t\ttableFinder = tableFinder.Order(clause.OrderByColumn{Column: clause.Column{Name: order}, Desc: true})\n\t\t} else {\n\t\t\ttableFinder = tableFinder.Order(order)\n\t\t}\n\t}\n\n\ttableFinder.Find(&tables)\n\n\tfor _, table := range tables {\n\t\th.dbHandler.DB.Table(table.Name).Count(&table.Count)\n\t\trecordCount += int(table.Count)\n\t}\n\n\tdatabaseSummary := &models.DatabaseSummary{\n\t\tPage:        page,\n\t\tPageSize:    limit,\n\t\tTotalTables: int(totalTables),\n\t\tRecordCount: recordCount,\n\t\tTables:      tables,\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\n\tval, err := json.Marshal(databaseSummary)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tfmt.Fprint(w, string(val))\n}\n\n// swagger:route DELETE /api/system/database/reset ResetSystemDatabase\n// Reset the system database to its initial state.\n//\n// This endpoint resets the system database to its initial state by performing the following steps:\n// - Creates an archive of the current database contents.\n// - Drops all existing tables in the database.\n// - Applies auto migration to recreate the necessary tables.\n//\n// responses:\n//   200:\n//   500:\n\n// Reset the system database to its initial state.\nfunc (h *Handler) ResetSystemDatabase(w http.ResponseWriter, r *http.Request, _ *models.Preference, _ *models.User, provider models.Provider) {\n\n\tmesherydbPath := path.Join(utils.GetHome(), \".meshery/config\")\n\terr := os.Mkdir(path.Join(mesherydbPath, \".archive\"), os.ModePerm)\n\tif err != nil && os.IsNotExist(err) {\n\t\thttp.Error(w, \"Directory could not be created due to a non-existent path.\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\tsrc := path.Join(mesherydbPath, \"mesherydb.sql\")\n\tcurrentTime := time.Now().Format(\"20060102150407\")\n\tnewFileName := \".archive/mesherydb\" + currentTime + \".sql\"\n\tdst := path.Join(mesherydbPath, newFileName)\n\n\tfin, err := os.Open(src)\n\tif err != nil {\n\t\thttp.Error(w, \"The database does not exist or you don't have enough permission to access it\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\tdefer fin.Close()\n\n\tfout, err := os.Create(dst)\n\tif err != nil {\n\t\thttp.Error(w, \"Destination file can not be created\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\tdefer fout.Close()\n\n\t_, err = io.Copy(fout, fin)\n\tif err != nil {\n\t\thttp.Error(w, \"Can not copy file from source to destination\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tdbHandler := provider.GetGenericPersister()\n\tif dbHandler == nil {\n\t\thttp.Error(w, \"Failed to obtain database handler\", http.StatusInternalServerError)\n\t\treturn\n\t} else {\n\t\tdbHandler.Lock()\n\t\tdefer dbHandler.Unlock()\n\n\t\ttables, err := dbHandler.Migrator().GetTables()\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Can not access database tables\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tfor _, table := range tables {\n\t\t\terr = dbHandler.Migrator().DropTable(table)\n\t\t\tif err != nil {\n\t\t\t\thttp.Error(w, \"Cannot drop table from database\", http.StatusInternalServerError)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\terr = dbHandler.AutoMigrate(\n\t\t\t&meshsyncmodel.KubernetesKeyValue{},\n\t\t\t&meshsyncmodel.KubernetesResource{},\n\t\t\t&meshsyncmodel.KubernetesResourceSpec{},\n\t\t\t&meshsyncmodel.KubernetesResourceStatus{},\n\t\t\t&meshsyncmodel.KubernetesResourceObjectMeta{},\n\t\t\t&models.PerformanceProfile{},\n\t\t\t&models.MesheryResult{},\n\t\t\t&models.MesheryPattern{},\n\t\t\t&models.MesheryFilter{},\n\t\t\t&models.PatternResource{},\n\t\t\t&models.MesheryApplication{},\n\t\t\t&models.UserPreference{},\n\t\t\t&models.PerformanceTestConfig{},\n\t\t\t&models.SmiResultWithID{},\n\t\t\t&models.K8sContext{},\n\t\t)\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Can not migrate tables to database\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tfmt.Fprint(w, \"Database reset successful\")\n\n\t}\n}\n", "package models\n\nimport (\n\t\"encoding/json\"\n\t\"strings\"\n\n\t\"github.com/gofrs/uuid\"\n\t\"github.com/layer5io/meshkit/database\"\n)\n\n// MesheryApplicationPersister is the persister for persisting\n// applications on the database\ntype MesheryApplicationPersister struct {\n\tDB *database.Handler\n}\n\n// MesheryApplicationPage represents a page of applications\ntype MesheryApplicationPage struct {\n\tPage         uint64                `json:\"page\"`\n\tPageSize     uint64                `json:\"page_size\"`\n\tTotalCount   int                   `json:\"total_count\"`\n\tApplications []*MesheryApplication `json:\"applications\"`\n}\n\n// GetMesheryApplications returns all of the applications\nfunc (maap *MesheryApplicationPersister) GetMesheryApplications(search, order string, page, pageSize uint64, updatedAfter string) ([]byte, error) {\n\torder = sanitizeOrderInput(order, []string{\"created_at\", \"updated_at\", \"name\"})\n\n\tif order == \"\" {\n\t\torder = \"updated_at desc\"\n\t}\n\n\tcount := int64(0)\n\tapplications := []*MesheryApplication{}\n\n\tquery := maap.DB.Where(\"updated_at > ?\", updatedAfter).Order(order)\n\n\tif search != \"\" {\n\t\tlike := \"%\" + strings.ToLower(search) + \"%\"\n\t\tquery = query.Where(\"(lower(meshery_applications.name) like ?)\", like)\n\t}\n\n\tquery.Table(\"meshery_applications\").Count(&count)\n\n\tPaginate(uint(page), uint(pageSize))(query).Find(&applications)\n\n\tmesheryApplicationPage := &MesheryApplicationPage{\n\t\tPage:         page,\n\t\tPageSize:     pageSize,\n\t\tTotalCount:   int(count),\n\t\tApplications: applications,\n\t}\n\n\treturn marshalMesheryApplicationPage(mesheryApplicationPage), nil\n}\n\n// DeleteMesheryApplication takes in an application id and delete it if it already exists\nfunc (maap *MesheryApplicationPersister) DeleteMesheryApplication(id uuid.UUID) ([]byte, error) {\n\tapplication := MesheryApplication{ID: &id}\n\terr := maap.DB.Delete(&application).Error\n\n\treturn marshalMesheryApplication(&application), err\n}\n\nfunc (maap *MesheryApplicationPersister) SaveMesheryApplication(application *MesheryApplication) ([]byte, error) {\n\tif application.ID == nil {\n\t\tid, err := uuid.NewV4()\n\t\tif err != nil {\n\t\t\treturn nil, ErrGenerateUUID(err)\n\t\t}\n\n\t\tapplication.ID = &id\n\t}\n\n\treturn marshalMesheryApplications([]MesheryApplication{*application}), maap.DB.Save(application).Error\n}\n\n// SaveMesheryApplications batch inserts the given applications\nfunc (maap *MesheryApplicationPersister) SaveMesheryApplications(applications []MesheryApplication) ([]byte, error) {\n\tfinalApplications := []MesheryApplication{}\n\tfor _, application := range applications {\n\t\tif application.ID == nil {\n\t\t\tid, err := uuid.NewV4()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, ErrGenerateUUID(err)\n\t\t\t}\n\n\t\t\tapplication.ID = &id\n\t\t}\n\n\t\tfinalApplications = append(finalApplications, application)\n\t}\n\n\treturn marshalMesheryApplications(finalApplications), maap.DB.Create(finalApplications).Error\n}\n\nfunc (maap *MesheryApplicationPersister) GetMesheryApplication(id uuid.UUID) ([]byte, error) {\n\tvar mesheryApplication MesheryApplication\n\terr := maap.DB.First(&mesheryApplication, id).Error\n\treturn marshalMesheryApplication(&mesheryApplication), err\n}\n\nfunc (maap *MesheryApplicationPersister) GetMesheryApplicationSource(id uuid.UUID) ([]byte, error) {\n\tvar mesheryApplication MesheryApplication\n\terr := maap.DB.First(&mesheryApplication, id).Error\n\treturn mesheryApplication.SourceContent, err\n}\n\nfunc marshalMesheryApplicationPage(maap *MesheryApplicationPage) []byte {\n\tres, _ := json.Marshal(maap)\n\n\treturn res\n}\n\nfunc marshalMesheryApplication(ma *MesheryApplication) []byte {\n\tres, _ := json.Marshal(ma)\n\n\treturn res\n}\n\nfunc marshalMesheryApplications(mas []MesheryApplication) []byte {\n\tres, _ := json.Marshal(mas)\n\n\treturn res\n}\n", "package models\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/gofrs/uuid\"\n\t\"github.com/layer5io/meshkit/database\"\n\t\"gorm.io/gorm\"\n)\n\n// MesheryFilterPersister is the persister for persisting\n// wasm filters on the database\ntype MesheryFilterPersister struct {\n\tDB *database.Handler\n}\n\n// MesheryFilterPage represents a page of filters\ntype MesheryFilterPage struct {\n\tPage       uint64           `json:\"page\"`\n\tPageSize   uint64           `json:\"page_size\"`\n\tTotalCount int              `json:\"total_count\"`\n\tFilters    []*MesheryFilter `json:\"filters\"`\n}\n\n// GetMesheryFilters returns all of the 'private' filters. Though private has no meaning here since there is only\n// one local user. We make this distinction to be consistent with the remote provider\nfunc (mfp *MesheryFilterPersister) GetMesheryFilters(search, order string, page, pageSize uint64, visibility []string) ([]byte, error) {\n\torder = sanitizeOrderInput(order, []string{\"created_at\", \"updated_at\", \"name\"})\n\n\tif order == \"\" {\n\t\torder = \"updated_at desc\"\n\t}\n\n\tcount := int64(0)\n\tfilters := []*MesheryFilter{}\n\n\tvar query *gorm.DB\n\tif len(visibility) == 0 {\n\t\tquery = mfp.DB.Where(\"visibility in (?)\", visibility)\n\t}\n\tquery = query.Order(order)\n\n\tif search != \"\" {\n\t\tlike := \"%\" + strings.ToLower(search) + \"%\"\n\t\tquery = query.Where(\"(lower(meshery_filters.name) like ?)\", like)\n\t}\n\n\tquery.Table(\"meshery_filters\").Count(&count)\n\n\tPaginate(uint(page), uint(pageSize))(query).Find(&filters)\n\n\tmesheryFilterPage := &MesheryFilterPage{\n\t\tPage:       page,\n\t\tPageSize:   pageSize,\n\t\tTotalCount: int(count),\n\t\tFilters:    filters,\n\t}\n\n\treturn marshalMesheryFilterPage(mesheryFilterPage), nil\n}\n\n// GetMesheryCatalogFilters returns all of the published filters\nfunc (mfp *MesheryFilterPersister) GetMesheryCatalogFilters(page, pageSize, search, order string) ([]byte, error) {\n\tvar err error\n\torder = sanitizeOrderInput(order, []string{\"created_at\", \"updated_at\", \"name\"})\n\n\tif order == \"\" {\n\t\torder = \"updated_at desc\"\n\t}\n\n\tvar pg int\n\tif page != \"\" {\n\t\tpg, err = strconv.Atoi(page)\n\n\t\tif err != nil || pg < 0 {\n\t\t\tpg = 0\n\t\t}\n\t} else {\n\t\tpg = 0\n\t}\n\n\t// 0 page size is for all records\n\tvar pgSize int\n\tif pageSize != \"\" {\n\t\tpgSize, err = strconv.Atoi(pageSize)\n\n\t\tif err != nil || pgSize < 0 {\n\t\t\tpgSize = 0\n\t\t}\n\t} else {\n\t\tpgSize = 0\n\t}\n\n\tfilters := []MesheryFilter{}\n\n\tquery := mfp.DB.Where(\"visibility = ?\", Published).Order(order)\n\n\tif search != \"\" {\n\t\tlike := \"%\" + strings.ToLower(search) + \"%\"\n\t\tquery = query.Where(\"(lower(meshery_filters.name) like ?)\", like)\n\t}\n\n\tvar count int64\n\terr = query.Model(&MesheryFilter{}).Count(&count).Error\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif pgSize != 0 {\n\t\tPaginate(uint(pg), uint(pgSize))(query).Find(&filters)\n\t} else {\n\t\tquery.Find(&filters)\n\t}\n\n\tresponse := FiltersAPIResponse{\n\t\tPage:       uint(pg),\n\t\tPageSize:   uint(pgSize),\n\t\tTotalCount: uint(count),\n\t\tFilters:    filters,\n\t}\n\n\tmarshalledResponse, _ := json.Marshal(response)\n\treturn marshalledResponse, nil\n}\n\n// CloneMesheryFilter clones meshery filter to private\nfunc (mfp *MesheryFilterPersister) CloneMesheryFilter(filterID string, cloneFilterRequest *MesheryCloneFilterRequestBody) ([]byte, error) {\n\tvar mesheryFilter MesheryFilter\n\tfilterUUID, _ := uuid.FromString(filterID)\n\terr := mfp.DB.First(&mesheryFilter, filterUUID).Error\n\tif err != nil || *mesheryFilter.ID == uuid.Nil {\n\t\treturn nil, fmt.Errorf(\"unable to get filter: %w\", err)\n\t}\n\n\tid, err := uuid.NewV4()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tmesheryFilter.Visibility = Private\n\tmesheryFilter.ID = &id\n\tmesheryFilter.Name = cloneFilterRequest.Name\n\n\treturn mfp.SaveMesheryFilter(&mesheryFilter)\n}\n\n// DeleteMesheryFilter takes in a profile id and delete it if it already exists\nfunc (mfp *MesheryFilterPersister) DeleteMesheryFilter(id uuid.UUID) ([]byte, error) {\n\tfilter := MesheryFilter{ID: &id}\n\tmfp.DB.Delete(&filter)\n\n\treturn marshalMesheryFilter(&filter), nil\n}\n\nfunc (mfp *MesheryFilterPersister) SaveMesheryFilter(filter *MesheryFilter) ([]byte, error) {\n\tif filter.Visibility == \"\" {\n\t\tfilter.Visibility = Private\n\t}\n\tif filter.ID == nil {\n\t\tid, err := uuid.NewV4()\n\t\tif err != nil {\n\t\t\treturn nil, ErrGenerateUUID(err)\n\t\t}\n\n\t\tfilter.ID = &id\n\t}\n\n\treturn marshalMesheryFilters([]MesheryFilter{*filter}), mfp.DB.Save(filter).Error\n}\n\n// SaveMesheryFilters batch inserts the given filters\nfunc (mfp *MesheryFilterPersister) SaveMesheryFilters(filters []MesheryFilter) ([]byte, error) {\n\tfinalFilters := []MesheryFilter{}\n\tnilUserID := \"\"\n\tfor _, filter := range filters {\n\t\tif filter.Visibility == \"\" {\n\t\t\tfilter.Visibility = Private\n\t\t}\n\t\tfilter.UserID = &nilUserID\n\t\tif filter.ID == nil {\n\t\t\tid, err := uuid.NewV4()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, ErrGenerateUUID(err)\n\t\t\t}\n\n\t\t\tfilter.ID = &id\n\t\t}\n\n\t\tfinalFilters = append(finalFilters, filter)\n\t}\n\n\treturn marshalMesheryFilters(finalFilters), mfp.DB.Create(finalFilters).Error\n}\n\nfunc (mfp *MesheryFilterPersister) GetMesheryFilter(id uuid.UUID) ([]byte, error) {\n\tvar mesheryFilter MesheryFilter\n\n\terr := mfp.DB.First(&mesheryFilter, id).Error\n\treturn marshalMesheryFilter(&mesheryFilter), err\n}\n\nfunc (mfp *MesheryFilterPersister) GetMesheryFilterFile(id uuid.UUID) ([]byte, error) {\n\tvar mesheryFilter MesheryFilter\n\n\terr := mfp.DB.First(&mesheryFilter, id).Error\n\treturn []byte(mesheryFilter.FilterFile), err\n}\n\nfunc marshalMesheryFilterPage(mfp *MesheryFilterPage) []byte {\n\tres, _ := json.Marshal(mfp)\n\n\treturn res\n}\n\nfunc marshalMesheryFilter(mf *MesheryFilter) []byte {\n\tres, _ := json.Marshal(mf)\n\n\treturn res\n}\n\nfunc marshalMesheryFilters(mps []MesheryFilter) []byte {\n\tres, _ := json.Marshal(mps)\n\n\treturn res\n}\n", "package models\n\nimport (\n\t\"encoding/json\"\n\t\"strings\"\n\n\t\"github.com/layer5io/meshery/server/models/connections\"\n\t\"github.com/layer5io/meshkit/database\"\n\t\"gorm.io/gorm\"\n)\n\n// MesheryK8sContextPersister is the persister for persisting\n// applications on the database\ntype MesheryK8sContextPersister struct {\n\tDB *database.Handler\n}\n\n// MesheryK8sContextPage represents a page of contexts\ntype MesheryK8sContextPage struct {\n\tPage       uint64        `json:\"page\"`\n\tPageSize   uint64        `json:\"page_size\"`\n\tTotalCount int           `json:\"total_count\"`\n\tContexts   []*K8sContext `json:\"contexts\"`\n}\n\n// GetMesheryK8sContexts returns all of the contexts\nfunc (mkcp *MesheryK8sContextPersister) GetMesheryK8sContexts(search, order string, page, pageSize uint64) ([]byte, error) {\n\torder = sanitizeOrderInput(order, []string{\"created_at\", \"updated_at\", \"name\"})\n\n\tif order == \"\" {\n\t\torder = \"updated_at desc\"\n\t}\n\n\tcount := int64(0)\n\tcontexts := []*K8sContext{}\n\n\tquery := mkcp.DB.Order(order)\n\n\tif search != \"\" {\n\t\tlike := \"%\" + strings.ToLower(search) + \"%\"\n\t\tquery = query.Where(\"(lower(name) like ?)\", like)\n\t}\n\n\tquery.Model(K8sContext{}).Count(&count)\n\n\tPaginate(uint(page), uint(pageSize))(query).Find(&contexts)\n\n\tmesheryK8sContextPage := MesheryK8sContextPage{\n\t\tPage:       page,\n\t\tPageSize:   pageSize,\n\t\tTotalCount: int(count),\n\t\tContexts:   contexts,\n\t}\n\n\tresp, _ := json.Marshal(mesheryK8sContextPage)\n\treturn resp, nil\n}\n\n// DeleteMesheryK8sContext takes in an application id and delete it if it already exists\nfunc (mkcp *MesheryK8sContextPersister) DeleteMesheryK8sContext(id string) (K8sContext, error) {\n\tcontext := K8sContext{ID: id}\n\tmkcp.DB.Delete(&context)\n\n\treturn context, nil\n}\n\nfunc (mkcp *MesheryK8sContextPersister) SaveMesheryK8sContext(mkc K8sContext) (connections.Connection, error) {\n\tconn := connections.Connection{}\n\tif mkc.ID == \"\" {\n\t\tid, err := K8sContextGenerateID(mkc)\n\t\tif err != nil {\n\t\t\treturn conn, ErrContextID\n\t\t}\n\n\t\tmkc.ID = id\n\t}\n\n\t// Perform the operation in a transaction\n\terr := mkcp.DB.Transaction(func(tx *gorm.DB) error {\n\t\tvar mesheryK8sContext K8sContext\n\n\t\t// Check if there is already an entry for this context\n\t\tif err := tx.First(&mesheryK8sContext, \"id = ?\", mkc.ID).Error; err == nil {\n\t\t\treturn ErrContextAlreadyPersisted\n\t\t}\n\n\t\treturn tx.Save(&mkc).Error\n\t})\n\n\treturn conn, err\n}\n\nfunc (mkcp *MesheryK8sContextPersister) GetMesheryK8sContext(id string) (K8sContext, error) {\n\tvar mesheryK8sContext K8sContext\n\n\terr := mkcp.DB.First(&mesheryK8sContext, \"id = ?\", id).Error\n\treturn mesheryK8sContext, err\n}\n\n// func (mkcp *MesheryK8sContextPersister) SetMesheryK8sCurrentContext(id string) error {\n// \t// Perform the operation in a transaction\n// \treturn mkcp.DB.Transaction(func(tx *gorm.DB) error {\n// \t\tvar mesheryK8sContext K8sContext\n\n// \t\t// Get context which is currently in use\n// \t\tif err := tx.First(&mesheryK8sContext, \"is_current_context = true\").Error; err != nil {\n// \t\t\treturn err\n// \t\t}\n\n// \t\t// If the context id matches with the provided id then skip the next steps\n// \t\tif mesheryK8sContext.ID == id {\n// \t\t\treturn nil\n// \t\t}\n\n// \t\tif err := tx.Save(&mesheryK8sContext).Error; err != nil {\n// \t\t\treturn err\n// \t\t}\n\n// \t\t// Set the specified context as active\n// \t\treturn tx.Model(K8sContext{}).Where(\"id = ?\", id).Update(\"is_current_context\", true).Error\n// \t})\n// }\n\n// func (mkcp *MesheryK8sContextPersister) GetMesheryK8sCurrentContext() (K8sContext, error) {\n// \tvar mesheryK8sContext K8sContext\n\n// \terr := mkcp.DB.First(&mesheryK8sContext, \"is_current_context = true\").Error\n\n// \treturn mesheryK8sContext, err\n// }\n", "package models\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/gofrs/uuid\"\n\t\"gorm.io/gorm\"\n\n\t\"github.com/layer5io/meshkit/database\"\n)\n\n// MesheryPatternPersister is the persister for persisting\n// performance profiles on the database\ntype MesheryPatternPersister struct {\n\tDB *database.Handler\n}\n\n// MesheryPatternPage represents a page of performance profiles\ntype MesheryPatternPage struct {\n\tPage       uint64            `json:\"page\"`\n\tPageSize   uint64            `json:\"page_size\"`\n\tTotalCount int               `json:\"total_count\"`\n\tPatterns   []*MesheryPattern `json:\"patterns\"`\n}\n\n// GetMesheryPatterns returns all of the 'private' patterns. Though private has no meaning here since there is only\n// one local user. We make this distinction to be consistent with the remote provider\nfunc (mpp *MesheryPatternPersister) GetMesheryPatterns(search, order string, page, pageSize uint64, updatedAfter string, visibility []string) ([]byte, error) {\n\torder = sanitizeOrderInput(order, []string{\"created_at\", \"updated_at\", \"name\"})\n\n\tif order == \"\" {\n\t\torder = \"updated_at desc\"\n\t}\n\n\tcount := int64(0)\n\tpatterns := []*MesheryPattern{}\n\tvar query *gorm.DB\n\tif len(visibility) == 0 {\n\t\tquery = mpp.DB.Where(\"visibility in (?)\", visibility)\n\t}\n\tquery = query.Where(\"updated_at > ?\", updatedAfter).Order(order)\n\n\tif search != \"\" {\n\t\tlike := \"%\" + strings.ToLower(search) + \"%\"\n\t\tquery = query.Where(\"(lower(meshery_patterns.name) like ?)\", like)\n\t}\n\n\tquery.Table(\"meshery_patterns\").Count(&count)\n\n\tPaginate(uint(page), uint(pageSize))(query).Find(&patterns)\n\n\tmesheryPatternPage := &MesheryPatternPage{\n\t\tPage:       page,\n\t\tPageSize:   pageSize,\n\t\tTotalCount: int(count),\n\t\tPatterns:   patterns,\n\t}\n\n\treturn marshalMesheryPatternPage(mesheryPatternPage), nil\n}\n\n// GetMesheryCatalogPatterns returns all of the published patterns\nfunc (mpp *MesheryPatternPersister) GetMesheryCatalogPatterns(page, pageSize, search, order string) ([]byte, error) {\n\tvar err error\n\torder = sanitizeOrderInput(order, []string{\"created_at\", \"updated_at\", \"name\"})\n\n\tif order == \"\" {\n\t\torder = \"updated_at desc\"\n\t}\n\n\tvar pg int\n\tif page != \"\" {\n\t\tpg, err = strconv.Atoi(page)\n\n\t\tif err != nil || pg < 0 {\n\t\t\tpg = 0\n\t\t}\n\t} else {\n\t\tpg = 0\n\t}\n\n\t// 0 page size is for all records\n\tvar pgSize int\n\tif pageSize != \"\" {\n\t\tpgSize, err = strconv.Atoi(pageSize)\n\n\t\tif err != nil || pgSize < 0 {\n\t\t\tpgSize = 0\n\t\t}\n\t} else {\n\t\tpgSize = 0\n\t}\n\n\tpatterns := []MesheryPattern{}\n\n\tquery := mpp.DB.Where(\"visibility = ?\", Published).Order(order)\n\n\tif search != \"\" {\n\t\tlike := \"%\" + strings.ToLower(search) + \"%\"\n\t\tquery = query.Where(\"(lower(meshery_patterns.name) like ?)\", like)\n\t}\n\n\tvar count int64\n\terr = query.Model(&MesheryPattern{}).Count(&count).Error\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif pgSize != 0 {\n\t\tPaginate(uint(pg), uint(pgSize))(query).Find(&patterns)\n\t} else {\n\t\tquery.Find(&patterns)\n\t}\n\n\tresponse := PatternsAPIResponse{\n\t\tPage:       uint(pg),\n\t\tPageSize:   uint(pgSize),\n\t\tTotalCount: uint(count),\n\t\tPatterns:   patterns,\n\t}\n\n\tmarshalledResponse, _ := json.Marshal(response)\n\treturn marshalledResponse, nil\n}\n\n// CloneMesheryPattern clones meshery pattern to private\nfunc (mpp *MesheryPatternPersister) CloneMesheryPattern(patternID string, clonePatternRequest *MesheryClonePatternRequestBody) ([]byte, error) {\n\tvar mesheryPattern MesheryPattern\n\tpatternUUID, _ := uuid.FromString(patternID)\n\terr := mpp.DB.First(&mesheryPattern, patternUUID).Error\n\tif err != nil || *mesheryPattern.ID == uuid.Nil {\n\t\treturn nil, fmt.Errorf(\"unable to get design: %w\", err)\n\t}\n\n\tid, err := uuid.NewV4()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tmesheryPattern.Visibility = Private\n\tmesheryPattern.ID = &id\n\tmesheryPattern.Name = clonePatternRequest.Name\n\n\treturn mpp.SaveMesheryPattern(&mesheryPattern)\n}\n\n// DeleteMesheryPattern takes in a profile id and delete it if it already exists\nfunc (mpp *MesheryPatternPersister) DeleteMesheryPattern(id uuid.UUID) ([]byte, error) {\n\tpattern := MesheryPattern{ID: &id}\n\tmpp.DB.Delete(&pattern)\n\n\treturn marshalMesheryPattern(&pattern), nil\n}\n\n// DeleteMesheryPatterns takes in a meshery-patterns and delete those if exist\nfunc (mpp *MesheryPatternPersister) DeleteMesheryPatterns(patterns MesheryPatternDeleteRequestBody) ([]byte, error) {\n\tvar deletedMaptterns []MesheryPattern\n\tfor _, pObj := range patterns.Patterns {\n\t\tid := uuid.FromStringOrNil(pObj.ID)\n\t\tpattern := MesheryPattern{ID: &id}\n\t\tmpp.DB.Delete(&pattern)\n\t\tdeletedMaptterns = append(deletedMaptterns, pattern)\n\t}\n\n\treturn marshalMesheryPatterns(deletedMaptterns), nil\n}\n\nfunc (mpp *MesheryPatternPersister) SaveMesheryPattern(pattern *MesheryPattern) ([]byte, error) {\n\tif pattern.Visibility == \"\" {\n\t\tpattern.Visibility = Private\n\t}\n\tif pattern.ID == nil {\n\t\tid, err := uuid.NewV4()\n\t\tif err != nil {\n\t\t\treturn nil, ErrGenerateUUID(err)\n\t\t}\n\n\t\tpattern.ID = &id\n\t}\n\n\treturn marshalMesheryPatterns([]MesheryPattern{*pattern}), mpp.DB.Save(pattern).Error\n}\n\n// SaveMesheryPatterns batch inserts the given patterns\nfunc (mpp *MesheryPatternPersister) SaveMesheryPatterns(patterns []MesheryPattern) ([]byte, error) {\n\tfinalPatterns := []MesheryPattern{}\n\tnilUserID := \"\"\n\tfor _, pattern := range patterns {\n\t\tif pattern.Visibility == \"\" {\n\t\t\tpattern.Visibility = Private\n\t\t}\n\t\tpattern.UserID = &nilUserID\n\t\tif pattern.ID == nil {\n\t\t\tid, err := uuid.NewV4()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, ErrGenerateUUID(err)\n\t\t\t}\n\n\t\t\tpattern.ID = &id\n\t\t}\n\n\t\tfinalPatterns = append(finalPatterns, pattern)\n\t}\n\n\treturn marshalMesheryPatterns(finalPatterns), mpp.DB.Create(finalPatterns).Error\n}\n\nfunc (mpp *MesheryPatternPersister) GetMesheryPattern(id uuid.UUID) ([]byte, error) {\n\tvar mesheryPattern MesheryPattern\n\n\terr := mpp.DB.First(&mesheryPattern, id).Error\n\treturn marshalMesheryPattern(&mesheryPattern), err\n}\n\nfunc (mpp *MesheryPatternPersister) GetMesheryPatternSource(id uuid.UUID) ([]byte, error) {\n\tvar mesheryPattern MesheryPattern\n\terr := mpp.DB.First(&mesheryPattern, id).Error\n\treturn mesheryPattern.SourceContent, err\n}\n\nfunc marshalMesheryPatternPage(mpp *MesheryPatternPage) []byte {\n\tres, _ := json.Marshal(mpp)\n\n\treturn res\n}\n\nfunc marshalMesheryPattern(mp *MesheryPattern) []byte {\n\tres, _ := json.Marshal(mp)\n\n\treturn res\n}\n\nfunc marshalMesheryPatterns(mps []MesheryPattern) []byte {\n\tres, _ := json.Marshal(mps)\n\n\treturn res\n}\n", "package models\n\nimport (\n\t\"strings\"\n\n\t\"github.com/gofrs/uuid\"\n\t\"github.com/layer5io/meshkit/database\"\n)\n\ntype PatternResourcePersister struct {\n\tDB *database.Handler\n}\n\ntype PatternResourcePage struct {\n\tPage       uint64             `json:\"page,omitempty\"`\n\tPageSize   uint64             `json:\"page_size,omitempty\"`\n\tTotalCount int                `json:\"total_count,omitempty\"`\n\tResources  []*PatternResource `json:\"resources,omitempty\"`\n}\n\nfunc (prp *PatternResourcePersister) SavePatternResource(pr *PatternResource) (*PatternResource, error) {\n\tif pr.ID == nil {\n\t\tid, err := uuid.NewV4()\n\t\tif err != nil {\n\t\t\treturn nil, ErrGenerateUUID(err)\n\t\t}\n\n\t\tpr.ID = &id\n\t}\n\n\treturn pr, prp.DB.Create(pr).Error\n}\n\nfunc (prp *PatternResourcePersister) DeletePatternResource(id uuid.UUID) error {\n\treturn prp.DB.Model(&PatternResource{}).Where(\"id = ?\", id).Update(\"deleted\", true).Error\n}\n\nfunc (prp *PatternResourcePersister) GetPatternResource(id uuid.UUID) (*PatternResource, error) {\n\tvar pr PatternResource\n\n\terr := prp.DB.First(&pr, id).Error\n\treturn &pr, err\n}\n\nfunc (prp *PatternResourcePersister) GetPatternResourceByAttributes(name, namespace, typ, oamType string) (*PatternResource, error) {\n\tvar pr PatternResource\n\n\terr := Paginate(0, 1)(prp.DB.Model(&PatternResource{}).Where(\n\t\t\"name = ? AND namespace = ? AND type = ? AND oam_type = ? AND deleted = false\",\n\t\tname,\n\t\tnamespace,\n\t\ttyp,\n\t\toamType,\n\t)).Scan(&pr).Error\n\n\treturn &pr, err\n}\n\nfunc (prp *PatternResourcePersister) GetPatternResources(search, order, name, namespace, typ, oamType string, page, pageSize uint64) (*PatternResourcePage, error) {\n\torder = sanitizeOrderInput(order, []string{\"created_at\", \"updated_at\", \"name\"})\n\n\tif order == \"\" {\n\t\torder = \"updated_at desc\"\n\t}\n\n\tcount := int64(0)\n\tresources := []*PatternResource{}\n\n\tquery := prp.DB.Order(order).Where(\"deleted = false\")\n\n\tif search != \"\" {\n\t\tlike := \"%\" + strings.ToLower(search) + \"%\"\n\t\tquery = query.Where(\"(lower(pattern_resources.name) like ?)\", like)\n\t}\n\tif name != \"\" {\n\t\tquery = query.Where(\"name = ?\", name)\n\t}\n\tif namespace != \"\" {\n\t\tquery = query.Where(\"namespace = ?\", namespace)\n\t}\n\tif typ != \"\" {\n\t\tquery = query.Where(\"type = ?\", typ)\n\t}\n\tif oamType != \"\" {\n\t\tquery = query.Where(\"oam_type = ?\", oamType)\n\t}\n\n\tquery.Model(&PatternResource{}).Count(&count)\n\n\tPaginate(uint(page), uint(pageSize))(query).Find(&resources)\n\n\tpatternResourcePage := &PatternResourcePage{\n\t\tPage:       page,\n\t\tPageSize:   pageSize,\n\t\tTotalCount: int(count),\n\t\tResources:  resources,\n\t}\n\n\treturn patternResourcePage, nil\n}\n\nfunc (prp *PatternResourcePersister) Exists(name, namespace, typ, oamType string) bool {\n\tvar result struct {\n\t\tFound bool\n\t}\n\n\tprp.DB.\n\t\tRaw(`\n\tSELECT \n\t\tEXISTS(SELECT 1 FROM pattern_resources WHERE name = ? AND namespace = ? AND type = ? AND oam_type = ? AND deleted = false) AS \"found\"`,\n\t\t\tname,\n\t\t\tnamespace,\n\t\t\ttyp,\n\t\t\toamType,\n\t\t).\n\t\tScan(&result)\n\n\treturn result.Found\n}\n", "package models\n\nimport (\n\t\"encoding/json\"\n\t\"strings\"\n\n\t\"github.com/gofrs/uuid\"\n\t\"github.com/layer5io/meshkit/database\"\n)\n\n// PerformanceProfilePersister is the persister for persisting\n// performance profiles on the database\ntype PerformanceProfilePersister struct {\n\tDB *database.Handler\n}\n\n// PerformanceProfilePage represents a page of performance profiles\ntype PerformanceProfilePage struct {\n\tPage       uint64                `json:\"page\"`\n\tPageSize   uint64                `json:\"page_size\"`\n\tTotalCount int                   `json:\"total_count\"`\n\tProfiles   []*PerformanceProfile `json:\"profiles\"`\n}\n\n// GetPerformanceProfiles returns all of the performance profiles\nfunc (ppp *PerformanceProfilePersister) GetPerformanceProfiles(_, search, order string, page, pageSize uint64) ([]byte, error) {\n\torder = sanitizeOrderInput(order, []string{\"updated_at\", \"created_at\", \"name\", \"last_run\"})\n\tif order == \"\" {\n\t\torder = \"updated_at desc\"\n\t}\n\n\tcount := int64(0)\n\tprofiles := []*PerformanceProfile{}\n\n\tquery := ppp.DB.\n\t\tSelect(`\n\t\tid, name, load_generators,\n\t\tendpoints, qps, service_mesh,\n\t\tduration, request_headers, request_cookies,\n\t\trequest_body, content_type, created_at,\n\t\tupdated_at, (?) as last_run, (?) as total_results`,\n\t\t\tppp.DB.Table(\"meshery_results\").Select(\"DATETIME(MAX(meshery_results.test_start_time))\").Where(\"performance_profile = performance_profiles.id\"),\n\t\t\tppp.DB.Table(\"meshery_results\").Select(\"COUNT(meshery_results.name)\").Where(\"performance_profile = performance_profiles.id\"),\n\t\t).\n\t\tOrder(order)\n\n\tif search != \"\" {\n\t\tlike := \"%\" + strings.ToLower(search) + \"%\"\n\t\tquery = query.Where(\"(lower(performance_profiles.name) like ?)\", like)\n\t}\n\n\tquery.Table(\"performance_profiles\").Count(&count)\n\n\tPaginate(uint(page), uint(pageSize))(query).Find(&profiles)\n\n\tperformanceProfilePage := &PerformanceProfilePage{\n\t\tPage:       page,\n\t\tPageSize:   pageSize,\n\t\tTotalCount: int(count),\n\t\tProfiles:   profiles,\n\t}\n\n\treturn marshalPerformanceProfilePage(performanceProfilePage), nil\n}\n\n// DeletePerformanceProfile takes in a profile id and delete it if it already exists\nfunc (ppp *PerformanceProfilePersister) DeletePerformanceProfile(id uuid.UUID) ([]byte, error) {\n\tprofile := PerformanceProfile{ID: &id}\n\tppp.DB.Delete(profile)\n\n\treturn marshalPerformanceProfile(&profile), nil\n}\n\nfunc (ppp *PerformanceProfilePersister) SavePerformanceProfile(_ uuid.UUID, profile *PerformanceProfile) error {\n\treturn ppp.DB.Save(profile).Error\n}\n\nfunc (ppp *PerformanceProfilePersister) GetPerformanceProfile(id uuid.UUID) (*PerformanceProfile, error) {\n\tvar performanceProfile PerformanceProfile\n\n\terr := ppp.DB.First(&performanceProfile, id).Error\n\treturn &performanceProfile, err\n}\n\nfunc marshalPerformanceProfilePage(ppp *PerformanceProfilePage) []byte {\n\tres, _ := json.Marshal(ppp)\n\n\treturn res\n}\n\nfunc marshalPerformanceProfile(pp *PerformanceProfile) []byte {\n\tres, _ := json.Marshal(pp)\n\n\treturn res\n}\n", "package models\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/layer5io/meshkit/database\"\n\t\"github.com/layer5io/meshkit/logger\"\n\t\"github.com/sirupsen/logrus\"\n\t\"github.com/spf13/viper\"\n)\n\n// sanitizeOrderInput takes in the \"order by\" query, a validColums\n// string slice and returns a sanitized query\n//\n// it will allow to run order by query only on the columns that are present\n// in the validColumns string slice, if any other column is requested in the\n// query then it will be IGNORED and an empty query would be returned instead\n//\n// sanitizeOrderInput also expects the query to be no longer than two words, that is\n// the query may look like \"updated_at DESC\" or \"name ASC\"\nfunc sanitizeOrderInput(order string, validColumns []string) string {\n\tparsedOrderStr := strings.Split(order, \" \")\n\tif len(parsedOrderStr) != 2 {\n\t\treturn \"\"\n\t}\n\n\tinputCol := parsedOrderStr[0]\n\ttyp := strings.ToLower(parsedOrderStr[1])\n\tfor _, col := range validColumns {\n\t\tif col == inputCol {\n\t\t\tif typ == \"desc\" {\n\t\t\t\treturn fmt.Sprintf(\"%s desc\", col)\n\t\t\t}\n\n\t\t\treturn fmt.Sprintf(\"%s asc\", col)\n\t\t}\n\t}\n\n\treturn \"\"\n}\n\nvar (\n\tdbHandler database.Handler\n\tmx        sync.Mutex\n)\n\nfunc setNewDBInstance() {\n\tmx.Lock()\n\tdefer mx.Unlock()\n\n\t// Initialize Logger instance\n\tlog, err := logger.New(\"meshery\", logger.Options{\n\t\tFormat: logger.SyslogLogFormat,\n\t})\n\tif err != nil {\n\t\tlog.Error(err)\n\t\tos.Exit(1)\n\t}\n\n\tdbHandler, err = database.New(database.Options{\n\t\tFilename: fmt.Sprintf(\"file:%s/mesherydb.sql?cache=private&mode=rwc&_busy_timeout=10000&_journal_mode=WAL\", viper.GetString(\"USER_DATA_FOLDER\")),\n\t\tEngine:   database.SQLITE,\n\t\tLogger:   log,\n\t})\n\tif err != nil {\n\t\tlogrus.Fatal(err)\n\t}\n}\n\nfunc GetNewDBInstance() *database.Handler {\n\tsetNewDBInstance()\n\treturn &dbHandler\n}\n"], "fixing_code": ["package handlers\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"path\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"github.com/layer5io/meshery/server/models\"\n\t\"github.com/layer5io/meshkit/utils\"\n\tmeshsyncmodel \"github.com/layer5io/meshsync/pkg/model\"\n\t\"gorm.io/gorm/clause\"\n)\n\n// swagger:route GET /api/system/database GetSystemDatabase idGetSystemDatabase\n// Handle GET request for getting summary about the system database.\n//\n// # Tables can be further filtered through query parameter\n//\n// ```?order={field}``` orders on the passed field\n//\n// ```?sort={[asc/desc]}``` Default behavior is asc\n//\n// ```?page={page-number}``` Default page number is 1\n//\n// ```?pagesize={pagesize}``` Default pagesize is 10. To return all results: ```pagesize=all```\n//\n// ```?search={tablename}``` If search is non empty then a greedy search is performed\n// responses:\n//\n//\t200: systemDatabaseResponseWrapper\nfunc (h *Handler) GetSystemDatabase(w http.ResponseWriter, r *http.Request, _ *models.Preference, _ *models.User, provider models.Provider) {\n\tvar tables []*models.SqliteSchema\n\tvar recordCount int\n\tvar totalTables int64\n\n\tlimitstr := r.URL.Query().Get(\"pagesize\")\n\tvar limit int\n\tif limitstr != \"all\" {\n\t\tlimit, _ = strconv.Atoi(limitstr)\n\t\tif limit <= 0 {\n\t\t\tlimit = defaultPageSize\n\t\t}\n\t}\n\tpagestr := r.URL.Query().Get(\"page\")\n\tpage, _ := strconv.Atoi(pagestr)\n\n\tif page <= 0 {\n\t\tpage = 1\n\t}\n\n\toffset := (page - 1) * limit\n\torder := r.URL.Query().Get(\"order\")\n\tsort := r.URL.Query().Get(\"sort\")\n\tsearch := r.URL.Query().Get(\"search\")\n\n\ttableFinder := h.dbHandler.DB.Table(\"sqlite_schema\").\n\t\tWhere(\"type = ?\", \"table\")\n\n\tif search != \"\" {\n\t\ttableFinder = tableFinder.Where(\"name LIKE ?\", \"%\"+search+\"%\")\n\t}\n\n\ttableFinder.Count(&totalTables)\n\n\tif limit != 0 {\n\t\ttableFinder = tableFinder.Limit(limit)\n\t}\n\tif offset != 0 {\n\t\ttableFinder = tableFinder.Offset(offset)\n\t}\n\torder = models.SanitizeOrderInput(order, []string{\"created_at\", \"updated_at\", \"name\"})\n\tif order != \"\" {\n\t\tif sort == \"desc\" {\n\t\t\ttableFinder = tableFinder.Order(clause.OrderByColumn{Column: clause.Column{Name: order}, Desc: true})\n\t\t} else {\n\t\t\ttableFinder = tableFinder.Order(order)\n\t\t}\n\t}\n\n\ttableFinder.Find(&tables)\n\n\tfor _, table := range tables {\n\t\th.dbHandler.DB.Table(table.Name).Count(&table.Count)\n\t\trecordCount += int(table.Count)\n\t}\n\n\tdatabaseSummary := &models.DatabaseSummary{\n\t\tPage:        page,\n\t\tPageSize:    limit,\n\t\tTotalTables: int(totalTables),\n\t\tRecordCount: recordCount,\n\t\tTables:      tables,\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\n\tval, err := json.Marshal(databaseSummary)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tfmt.Fprint(w, string(val))\n}\n\n// swagger:route DELETE /api/system/database/reset ResetSystemDatabase\n// Reset the system database to its initial state.\n//\n// This endpoint resets the system database to its initial state by performing the following steps:\n// - Creates an archive of the current database contents.\n// - Drops all existing tables in the database.\n// - Applies auto migration to recreate the necessary tables.\n//\n// responses:\n//   200:\n//   500:\n\n// Reset the system database to its initial state.\nfunc (h *Handler) ResetSystemDatabase(w http.ResponseWriter, r *http.Request, _ *models.Preference, _ *models.User, provider models.Provider) {\n\n\tmesherydbPath := path.Join(utils.GetHome(), \".meshery/config\")\n\terr := os.Mkdir(path.Join(mesherydbPath, \".archive\"), os.ModePerm)\n\tif err != nil && os.IsNotExist(err) {\n\t\thttp.Error(w, \"Directory could not be created due to a non-existent path.\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\tsrc := path.Join(mesherydbPath, \"mesherydb.sql\")\n\tcurrentTime := time.Now().Format(\"20060102150407\")\n\tnewFileName := \".archive/mesherydb\" + currentTime + \".sql\"\n\tdst := path.Join(mesherydbPath, newFileName)\n\n\tfin, err := os.Open(src)\n\tif err != nil {\n\t\thttp.Error(w, \"The database does not exist or you don't have enough permission to access it\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\tdefer fin.Close()\n\n\tfout, err := os.Create(dst)\n\tif err != nil {\n\t\thttp.Error(w, \"Destination file can not be created\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\tdefer fout.Close()\n\n\t_, err = io.Copy(fout, fin)\n\tif err != nil {\n\t\thttp.Error(w, \"Can not copy file from source to destination\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tdbHandler := provider.GetGenericPersister()\n\tif dbHandler == nil {\n\t\thttp.Error(w, \"Failed to obtain database handler\", http.StatusInternalServerError)\n\t\treturn\n\t} else {\n\t\tdbHandler.Lock()\n\t\tdefer dbHandler.Unlock()\n\n\t\ttables, err := dbHandler.Migrator().GetTables()\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Can not access database tables\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tfor _, table := range tables {\n\t\t\terr = dbHandler.Migrator().DropTable(table)\n\t\t\tif err != nil {\n\t\t\t\thttp.Error(w, \"Cannot drop table from database\", http.StatusInternalServerError)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\terr = dbHandler.AutoMigrate(\n\t\t\t&meshsyncmodel.KubernetesKeyValue{},\n\t\t\t&meshsyncmodel.KubernetesResource{},\n\t\t\t&meshsyncmodel.KubernetesResourceSpec{},\n\t\t\t&meshsyncmodel.KubernetesResourceStatus{},\n\t\t\t&meshsyncmodel.KubernetesResourceObjectMeta{},\n\t\t\t&models.PerformanceProfile{},\n\t\t\t&models.MesheryResult{},\n\t\t\t&models.MesheryPattern{},\n\t\t\t&models.MesheryFilter{},\n\t\t\t&models.PatternResource{},\n\t\t\t&models.MesheryApplication{},\n\t\t\t&models.UserPreference{},\n\t\t\t&models.PerformanceTestConfig{},\n\t\t\t&models.SmiResultWithID{},\n\t\t\t&models.K8sContext{},\n\t\t)\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Can not migrate tables to database\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tfmt.Fprint(w, \"Database reset successful\")\n\n\t}\n}\n", "package models\n\nimport (\n\t\"encoding/json\"\n\t\"strings\"\n\n\t\"github.com/gofrs/uuid\"\n\t\"github.com/layer5io/meshkit/database\"\n)\n\n// MesheryApplicationPersister is the persister for persisting\n// applications on the database\ntype MesheryApplicationPersister struct {\n\tDB *database.Handler\n}\n\n// MesheryApplicationPage represents a page of applications\ntype MesheryApplicationPage struct {\n\tPage         uint64                `json:\"page\"`\n\tPageSize     uint64                `json:\"page_size\"`\n\tTotalCount   int                   `json:\"total_count\"`\n\tApplications []*MesheryApplication `json:\"applications\"`\n}\n\n// GetMesheryApplications returns all of the applications\nfunc (maap *MesheryApplicationPersister) GetMesheryApplications(search, order string, page, pageSize uint64, updatedAfter string) ([]byte, error) {\n\torder = SanitizeOrderInput(order, []string{\"created_at\", \"updated_at\", \"name\"})\n\n\tif order == \"\" {\n\t\torder = \"updated_at desc\"\n\t}\n\n\tcount := int64(0)\n\tapplications := []*MesheryApplication{}\n\n\tquery := maap.DB.Where(\"updated_at > ?\", updatedAfter).Order(order)\n\n\tif search != \"\" {\n\t\tlike := \"%\" + strings.ToLower(search) + \"%\"\n\t\tquery = query.Where(\"(lower(meshery_applications.name) like ?)\", like)\n\t}\n\n\tquery.Table(\"meshery_applications\").Count(&count)\n\n\tPaginate(uint(page), uint(pageSize))(query).Find(&applications)\n\n\tmesheryApplicationPage := &MesheryApplicationPage{\n\t\tPage:         page,\n\t\tPageSize:     pageSize,\n\t\tTotalCount:   int(count),\n\t\tApplications: applications,\n\t}\n\n\treturn marshalMesheryApplicationPage(mesheryApplicationPage), nil\n}\n\n// DeleteMesheryApplication takes in an application id and delete it if it already exists\nfunc (maap *MesheryApplicationPersister) DeleteMesheryApplication(id uuid.UUID) ([]byte, error) {\n\tapplication := MesheryApplication{ID: &id}\n\terr := maap.DB.Delete(&application).Error\n\n\treturn marshalMesheryApplication(&application), err\n}\n\nfunc (maap *MesheryApplicationPersister) SaveMesheryApplication(application *MesheryApplication) ([]byte, error) {\n\tif application.ID == nil {\n\t\tid, err := uuid.NewV4()\n\t\tif err != nil {\n\t\t\treturn nil, ErrGenerateUUID(err)\n\t\t}\n\n\t\tapplication.ID = &id\n\t}\n\n\treturn marshalMesheryApplications([]MesheryApplication{*application}), maap.DB.Save(application).Error\n}\n\n// SaveMesheryApplications batch inserts the given applications\nfunc (maap *MesheryApplicationPersister) SaveMesheryApplications(applications []MesheryApplication) ([]byte, error) {\n\tfinalApplications := []MesheryApplication{}\n\tfor _, application := range applications {\n\t\tif application.ID == nil {\n\t\t\tid, err := uuid.NewV4()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, ErrGenerateUUID(err)\n\t\t\t}\n\n\t\t\tapplication.ID = &id\n\t\t}\n\n\t\tfinalApplications = append(finalApplications, application)\n\t}\n\n\treturn marshalMesheryApplications(finalApplications), maap.DB.Create(finalApplications).Error\n}\n\nfunc (maap *MesheryApplicationPersister) GetMesheryApplication(id uuid.UUID) ([]byte, error) {\n\tvar mesheryApplication MesheryApplication\n\terr := maap.DB.First(&mesheryApplication, id).Error\n\treturn marshalMesheryApplication(&mesheryApplication), err\n}\n\nfunc (maap *MesheryApplicationPersister) GetMesheryApplicationSource(id uuid.UUID) ([]byte, error) {\n\tvar mesheryApplication MesheryApplication\n\terr := maap.DB.First(&mesheryApplication, id).Error\n\treturn mesheryApplication.SourceContent, err\n}\n\nfunc marshalMesheryApplicationPage(maap *MesheryApplicationPage) []byte {\n\tres, _ := json.Marshal(maap)\n\n\treturn res\n}\n\nfunc marshalMesheryApplication(ma *MesheryApplication) []byte {\n\tres, _ := json.Marshal(ma)\n\n\treturn res\n}\n\nfunc marshalMesheryApplications(mas []MesheryApplication) []byte {\n\tres, _ := json.Marshal(mas)\n\n\treturn res\n}\n", "package models\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/gofrs/uuid\"\n\t\"github.com/layer5io/meshkit/database\"\n\t\"gorm.io/gorm\"\n)\n\n// MesheryFilterPersister is the persister for persisting\n// wasm filters on the database\ntype MesheryFilterPersister struct {\n\tDB *database.Handler\n}\n\n// MesheryFilterPage represents a page of filters\ntype MesheryFilterPage struct {\n\tPage       uint64           `json:\"page\"`\n\tPageSize   uint64           `json:\"page_size\"`\n\tTotalCount int              `json:\"total_count\"`\n\tFilters    []*MesheryFilter `json:\"filters\"`\n}\n\n// GetMesheryFilters returns all of the 'private' filters. Though private has no meaning here since there is only\n// one local user. We make this distinction to be consistent with the remote provider\nfunc (mfp *MesheryFilterPersister) GetMesheryFilters(search, order string, page, pageSize uint64, visibility []string) ([]byte, error) {\n\torder = SanitizeOrderInput(order, []string{\"created_at\", \"updated_at\", \"name\"})\n\n\tif order == \"\" {\n\t\torder = \"updated_at desc\"\n\t}\n\n\tcount := int64(0)\n\tfilters := []*MesheryFilter{}\n\n\tvar query *gorm.DB\n\tif len(visibility) == 0 {\n\t\tquery = mfp.DB.Where(\"visibility in (?)\", visibility)\n\t}\n\tquery = query.Order(order)\n\n\tif search != \"\" {\n\t\tlike := \"%\" + strings.ToLower(search) + \"%\"\n\t\tquery = query.Where(\"(lower(meshery_filters.name) like ?)\", like)\n\t}\n\n\tquery.Table(\"meshery_filters\").Count(&count)\n\n\tPaginate(uint(page), uint(pageSize))(query).Find(&filters)\n\n\tmesheryFilterPage := &MesheryFilterPage{\n\t\tPage:       page,\n\t\tPageSize:   pageSize,\n\t\tTotalCount: int(count),\n\t\tFilters:    filters,\n\t}\n\n\treturn marshalMesheryFilterPage(mesheryFilterPage), nil\n}\n\n// GetMesheryCatalogFilters returns all of the published filters\nfunc (mfp *MesheryFilterPersister) GetMesheryCatalogFilters(page, pageSize, search, order string) ([]byte, error) {\n\tvar err error\n\torder = SanitizeOrderInput(order, []string{\"created_at\", \"updated_at\", \"name\"})\n\n\tif order == \"\" {\n\t\torder = \"updated_at desc\"\n\t}\n\n\tvar pg int\n\tif page != \"\" {\n\t\tpg, err = strconv.Atoi(page)\n\n\t\tif err != nil || pg < 0 {\n\t\t\tpg = 0\n\t\t}\n\t} else {\n\t\tpg = 0\n\t}\n\n\t// 0 page size is for all records\n\tvar pgSize int\n\tif pageSize != \"\" {\n\t\tpgSize, err = strconv.Atoi(pageSize)\n\n\t\tif err != nil || pgSize < 0 {\n\t\t\tpgSize = 0\n\t\t}\n\t} else {\n\t\tpgSize = 0\n\t}\n\n\tfilters := []MesheryFilter{}\n\n\tquery := mfp.DB.Where(\"visibility = ?\", Published).Order(order)\n\n\tif search != \"\" {\n\t\tlike := \"%\" + strings.ToLower(search) + \"%\"\n\t\tquery = query.Where(\"(lower(meshery_filters.name) like ?)\", like)\n\t}\n\n\tvar count int64\n\terr = query.Model(&MesheryFilter{}).Count(&count).Error\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif pgSize != 0 {\n\t\tPaginate(uint(pg), uint(pgSize))(query).Find(&filters)\n\t} else {\n\t\tquery.Find(&filters)\n\t}\n\n\tresponse := FiltersAPIResponse{\n\t\tPage:       uint(pg),\n\t\tPageSize:   uint(pgSize),\n\t\tTotalCount: uint(count),\n\t\tFilters:    filters,\n\t}\n\n\tmarshalledResponse, _ := json.Marshal(response)\n\treturn marshalledResponse, nil\n}\n\n// CloneMesheryFilter clones meshery filter to private\nfunc (mfp *MesheryFilterPersister) CloneMesheryFilter(filterID string, cloneFilterRequest *MesheryCloneFilterRequestBody) ([]byte, error) {\n\tvar mesheryFilter MesheryFilter\n\tfilterUUID, _ := uuid.FromString(filterID)\n\terr := mfp.DB.First(&mesheryFilter, filterUUID).Error\n\tif err != nil || *mesheryFilter.ID == uuid.Nil {\n\t\treturn nil, fmt.Errorf(\"unable to get filter: %w\", err)\n\t}\n\n\tid, err := uuid.NewV4()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tmesheryFilter.Visibility = Private\n\tmesheryFilter.ID = &id\n\tmesheryFilter.Name = cloneFilterRequest.Name\n\n\treturn mfp.SaveMesheryFilter(&mesheryFilter)\n}\n\n// DeleteMesheryFilter takes in a profile id and delete it if it already exists\nfunc (mfp *MesheryFilterPersister) DeleteMesheryFilter(id uuid.UUID) ([]byte, error) {\n\tfilter := MesheryFilter{ID: &id}\n\tmfp.DB.Delete(&filter)\n\n\treturn marshalMesheryFilter(&filter), nil\n}\n\nfunc (mfp *MesheryFilterPersister) SaveMesheryFilter(filter *MesheryFilter) ([]byte, error) {\n\tif filter.Visibility == \"\" {\n\t\tfilter.Visibility = Private\n\t}\n\tif filter.ID == nil {\n\t\tid, err := uuid.NewV4()\n\t\tif err != nil {\n\t\t\treturn nil, ErrGenerateUUID(err)\n\t\t}\n\n\t\tfilter.ID = &id\n\t}\n\n\treturn marshalMesheryFilters([]MesheryFilter{*filter}), mfp.DB.Save(filter).Error\n}\n\n// SaveMesheryFilters batch inserts the given filters\nfunc (mfp *MesheryFilterPersister) SaveMesheryFilters(filters []MesheryFilter) ([]byte, error) {\n\tfinalFilters := []MesheryFilter{}\n\tnilUserID := \"\"\n\tfor _, filter := range filters {\n\t\tif filter.Visibility == \"\" {\n\t\t\tfilter.Visibility = Private\n\t\t}\n\t\tfilter.UserID = &nilUserID\n\t\tif filter.ID == nil {\n\t\t\tid, err := uuid.NewV4()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, ErrGenerateUUID(err)\n\t\t\t}\n\n\t\t\tfilter.ID = &id\n\t\t}\n\n\t\tfinalFilters = append(finalFilters, filter)\n\t}\n\n\treturn marshalMesheryFilters(finalFilters), mfp.DB.Create(finalFilters).Error\n}\n\nfunc (mfp *MesheryFilterPersister) GetMesheryFilter(id uuid.UUID) ([]byte, error) {\n\tvar mesheryFilter MesheryFilter\n\n\terr := mfp.DB.First(&mesheryFilter, id).Error\n\treturn marshalMesheryFilter(&mesheryFilter), err\n}\n\nfunc (mfp *MesheryFilterPersister) GetMesheryFilterFile(id uuid.UUID) ([]byte, error) {\n\tvar mesheryFilter MesheryFilter\n\n\terr := mfp.DB.First(&mesheryFilter, id).Error\n\treturn []byte(mesheryFilter.FilterFile), err\n}\n\nfunc marshalMesheryFilterPage(mfp *MesheryFilterPage) []byte {\n\tres, _ := json.Marshal(mfp)\n\n\treturn res\n}\n\nfunc marshalMesheryFilter(mf *MesheryFilter) []byte {\n\tres, _ := json.Marshal(mf)\n\n\treturn res\n}\n\nfunc marshalMesheryFilters(mps []MesheryFilter) []byte {\n\tres, _ := json.Marshal(mps)\n\n\treturn res\n}\n", "package models\n\nimport (\n\t\"encoding/json\"\n\t\"strings\"\n\n\t\"github.com/layer5io/meshery/server/models/connections\"\n\t\"github.com/layer5io/meshkit/database\"\n\t\"gorm.io/gorm\"\n)\n\n// MesheryK8sContextPersister is the persister for persisting\n// applications on the database\ntype MesheryK8sContextPersister struct {\n\tDB *database.Handler\n}\n\n// MesheryK8sContextPage represents a page of contexts\ntype MesheryK8sContextPage struct {\n\tPage       uint64        `json:\"page\"`\n\tPageSize   uint64        `json:\"page_size\"`\n\tTotalCount int           `json:\"total_count\"`\n\tContexts   []*K8sContext `json:\"contexts\"`\n}\n\n// GetMesheryK8sContexts returns all of the contexts\nfunc (mkcp *MesheryK8sContextPersister) GetMesheryK8sContexts(search, order string, page, pageSize uint64) ([]byte, error) {\n\torder = SanitizeOrderInput(order, []string{\"created_at\", \"updated_at\", \"name\"})\n\n\tif order == \"\" {\n\t\torder = \"updated_at desc\"\n\t}\n\n\tcount := int64(0)\n\tcontexts := []*K8sContext{}\n\n\tquery := mkcp.DB.Order(order)\n\n\tif search != \"\" {\n\t\tlike := \"%\" + strings.ToLower(search) + \"%\"\n\t\tquery = query.Where(\"(lower(name) like ?)\", like)\n\t}\n\n\tquery.Model(K8sContext{}).Count(&count)\n\n\tPaginate(uint(page), uint(pageSize))(query).Find(&contexts)\n\n\tmesheryK8sContextPage := MesheryK8sContextPage{\n\t\tPage:       page,\n\t\tPageSize:   pageSize,\n\t\tTotalCount: int(count),\n\t\tContexts:   contexts,\n\t}\n\n\tresp, _ := json.Marshal(mesheryK8sContextPage)\n\treturn resp, nil\n}\n\n// DeleteMesheryK8sContext takes in an application id and delete it if it already exists\nfunc (mkcp *MesheryK8sContextPersister) DeleteMesheryK8sContext(id string) (K8sContext, error) {\n\tcontext := K8sContext{ID: id}\n\tmkcp.DB.Delete(&context)\n\n\treturn context, nil\n}\n\nfunc (mkcp *MesheryK8sContextPersister) SaveMesheryK8sContext(mkc K8sContext) (connections.Connection, error) {\n\tconn := connections.Connection{}\n\tif mkc.ID == \"\" {\n\t\tid, err := K8sContextGenerateID(mkc)\n\t\tif err != nil {\n\t\t\treturn conn, ErrContextID\n\t\t}\n\n\t\tmkc.ID = id\n\t}\n\n\t// Perform the operation in a transaction\n\terr := mkcp.DB.Transaction(func(tx *gorm.DB) error {\n\t\tvar mesheryK8sContext K8sContext\n\n\t\t// Check if there is already an entry for this context\n\t\tif err := tx.First(&mesheryK8sContext, \"id = ?\", mkc.ID).Error; err == nil {\n\t\t\treturn ErrContextAlreadyPersisted\n\t\t}\n\n\t\treturn tx.Save(&mkc).Error\n\t})\n\n\treturn conn, err\n}\n\nfunc (mkcp *MesheryK8sContextPersister) GetMesheryK8sContext(id string) (K8sContext, error) {\n\tvar mesheryK8sContext K8sContext\n\n\terr := mkcp.DB.First(&mesheryK8sContext, \"id = ?\", id).Error\n\treturn mesheryK8sContext, err\n}\n\n// func (mkcp *MesheryK8sContextPersister) SetMesheryK8sCurrentContext(id string) error {\n// \t// Perform the operation in a transaction\n// \treturn mkcp.DB.Transaction(func(tx *gorm.DB) error {\n// \t\tvar mesheryK8sContext K8sContext\n\n// \t\t// Get context which is currently in use\n// \t\tif err := tx.First(&mesheryK8sContext, \"is_current_context = true\").Error; err != nil {\n// \t\t\treturn err\n// \t\t}\n\n// \t\t// If the context id matches with the provided id then skip the next steps\n// \t\tif mesheryK8sContext.ID == id {\n// \t\t\treturn nil\n// \t\t}\n\n// \t\tif err := tx.Save(&mesheryK8sContext).Error; err != nil {\n// \t\t\treturn err\n// \t\t}\n\n// \t\t// Set the specified context as active\n// \t\treturn tx.Model(K8sContext{}).Where(\"id = ?\", id).Update(\"is_current_context\", true).Error\n// \t})\n// }\n\n// func (mkcp *MesheryK8sContextPersister) GetMesheryK8sCurrentContext() (K8sContext, error) {\n// \tvar mesheryK8sContext K8sContext\n\n// \terr := mkcp.DB.First(&mesheryK8sContext, \"is_current_context = true\").Error\n\n// \treturn mesheryK8sContext, err\n// }\n", "package models\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/gofrs/uuid\"\n\t\"gorm.io/gorm\"\n\n\t\"github.com/layer5io/meshkit/database\"\n)\n\n// MesheryPatternPersister is the persister for persisting\n// performance profiles on the database\ntype MesheryPatternPersister struct {\n\tDB *database.Handler\n}\n\n// MesheryPatternPage represents a page of performance profiles\ntype MesheryPatternPage struct {\n\tPage       uint64            `json:\"page\"`\n\tPageSize   uint64            `json:\"page_size\"`\n\tTotalCount int               `json:\"total_count\"`\n\tPatterns   []*MesheryPattern `json:\"patterns\"`\n}\n\n// GetMesheryPatterns returns all of the 'private' patterns. Though private has no meaning here since there is only\n// one local user. We make this distinction to be consistent with the remote provider\nfunc (mpp *MesheryPatternPersister) GetMesheryPatterns(search, order string, page, pageSize uint64, updatedAfter string, visibility []string) ([]byte, error) {\n\torder = SanitizeOrderInput(order, []string{\"created_at\", \"updated_at\", \"name\"})\n\n\tif order == \"\" {\n\t\torder = \"updated_at desc\"\n\t}\n\n\tcount := int64(0)\n\tpatterns := []*MesheryPattern{}\n\tvar query *gorm.DB\n\tif len(visibility) == 0 {\n\t\tquery = mpp.DB.Where(\"visibility in (?)\", visibility)\n\t}\n\tquery = query.Where(\"updated_at > ?\", updatedAfter).Order(order)\n\n\tif search != \"\" {\n\t\tlike := \"%\" + strings.ToLower(search) + \"%\"\n\t\tquery = query.Where(\"(lower(meshery_patterns.name) like ?)\", like)\n\t}\n\n\tquery.Table(\"meshery_patterns\").Count(&count)\n\n\tPaginate(uint(page), uint(pageSize))(query).Find(&patterns)\n\n\tmesheryPatternPage := &MesheryPatternPage{\n\t\tPage:       page,\n\t\tPageSize:   pageSize,\n\t\tTotalCount: int(count),\n\t\tPatterns:   patterns,\n\t}\n\n\treturn marshalMesheryPatternPage(mesheryPatternPage), nil\n}\n\n// GetMesheryCatalogPatterns returns all of the published patterns\nfunc (mpp *MesheryPatternPersister) GetMesheryCatalogPatterns(page, pageSize, search, order string) ([]byte, error) {\n\tvar err error\n\torder = SanitizeOrderInput(order, []string{\"created_at\", \"updated_at\", \"name\"})\n\n\tif order == \"\" {\n\t\torder = \"updated_at desc\"\n\t}\n\n\tvar pg int\n\tif page != \"\" {\n\t\tpg, err = strconv.Atoi(page)\n\n\t\tif err != nil || pg < 0 {\n\t\t\tpg = 0\n\t\t}\n\t} else {\n\t\tpg = 0\n\t}\n\n\t// 0 page size is for all records\n\tvar pgSize int\n\tif pageSize != \"\" {\n\t\tpgSize, err = strconv.Atoi(pageSize)\n\n\t\tif err != nil || pgSize < 0 {\n\t\t\tpgSize = 0\n\t\t}\n\t} else {\n\t\tpgSize = 0\n\t}\n\n\tpatterns := []MesheryPattern{}\n\n\tquery := mpp.DB.Where(\"visibility = ?\", Published).Order(order)\n\n\tif search != \"\" {\n\t\tlike := \"%\" + strings.ToLower(search) + \"%\"\n\t\tquery = query.Where(\"(lower(meshery_patterns.name) like ?)\", like)\n\t}\n\n\tvar count int64\n\terr = query.Model(&MesheryPattern{}).Count(&count).Error\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif pgSize != 0 {\n\t\tPaginate(uint(pg), uint(pgSize))(query).Find(&patterns)\n\t} else {\n\t\tquery.Find(&patterns)\n\t}\n\n\tresponse := PatternsAPIResponse{\n\t\tPage:       uint(pg),\n\t\tPageSize:   uint(pgSize),\n\t\tTotalCount: uint(count),\n\t\tPatterns:   patterns,\n\t}\n\n\tmarshalledResponse, _ := json.Marshal(response)\n\treturn marshalledResponse, nil\n}\n\n// CloneMesheryPattern clones meshery pattern to private\nfunc (mpp *MesheryPatternPersister) CloneMesheryPattern(patternID string, clonePatternRequest *MesheryClonePatternRequestBody) ([]byte, error) {\n\tvar mesheryPattern MesheryPattern\n\tpatternUUID, _ := uuid.FromString(patternID)\n\terr := mpp.DB.First(&mesheryPattern, patternUUID).Error\n\tif err != nil || *mesheryPattern.ID == uuid.Nil {\n\t\treturn nil, fmt.Errorf(\"unable to get design: %w\", err)\n\t}\n\n\tid, err := uuid.NewV4()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tmesheryPattern.Visibility = Private\n\tmesheryPattern.ID = &id\n\tmesheryPattern.Name = clonePatternRequest.Name\n\n\treturn mpp.SaveMesheryPattern(&mesheryPattern)\n}\n\n// DeleteMesheryPattern takes in a profile id and delete it if it already exists\nfunc (mpp *MesheryPatternPersister) DeleteMesheryPattern(id uuid.UUID) ([]byte, error) {\n\tpattern := MesheryPattern{ID: &id}\n\tmpp.DB.Delete(&pattern)\n\n\treturn marshalMesheryPattern(&pattern), nil\n}\n\n// DeleteMesheryPatterns takes in a meshery-patterns and delete those if exist\nfunc (mpp *MesheryPatternPersister) DeleteMesheryPatterns(patterns MesheryPatternDeleteRequestBody) ([]byte, error) {\n\tvar deletedMaptterns []MesheryPattern\n\tfor _, pObj := range patterns.Patterns {\n\t\tid := uuid.FromStringOrNil(pObj.ID)\n\t\tpattern := MesheryPattern{ID: &id}\n\t\tmpp.DB.Delete(&pattern)\n\t\tdeletedMaptterns = append(deletedMaptterns, pattern)\n\t}\n\n\treturn marshalMesheryPatterns(deletedMaptterns), nil\n}\n\nfunc (mpp *MesheryPatternPersister) SaveMesheryPattern(pattern *MesheryPattern) ([]byte, error) {\n\tif pattern.Visibility == \"\" {\n\t\tpattern.Visibility = Private\n\t}\n\tif pattern.ID == nil {\n\t\tid, err := uuid.NewV4()\n\t\tif err != nil {\n\t\t\treturn nil, ErrGenerateUUID(err)\n\t\t}\n\n\t\tpattern.ID = &id\n\t}\n\n\treturn marshalMesheryPatterns([]MesheryPattern{*pattern}), mpp.DB.Save(pattern).Error\n}\n\n// SaveMesheryPatterns batch inserts the given patterns\nfunc (mpp *MesheryPatternPersister) SaveMesheryPatterns(patterns []MesheryPattern) ([]byte, error) {\n\tfinalPatterns := []MesheryPattern{}\n\tnilUserID := \"\"\n\tfor _, pattern := range patterns {\n\t\tif pattern.Visibility == \"\" {\n\t\t\tpattern.Visibility = Private\n\t\t}\n\t\tpattern.UserID = &nilUserID\n\t\tif pattern.ID == nil {\n\t\t\tid, err := uuid.NewV4()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, ErrGenerateUUID(err)\n\t\t\t}\n\n\t\t\tpattern.ID = &id\n\t\t}\n\n\t\tfinalPatterns = append(finalPatterns, pattern)\n\t}\n\n\treturn marshalMesheryPatterns(finalPatterns), mpp.DB.Create(finalPatterns).Error\n}\n\nfunc (mpp *MesheryPatternPersister) GetMesheryPattern(id uuid.UUID) ([]byte, error) {\n\tvar mesheryPattern MesheryPattern\n\n\terr := mpp.DB.First(&mesheryPattern, id).Error\n\treturn marshalMesheryPattern(&mesheryPattern), err\n}\n\nfunc (mpp *MesheryPatternPersister) GetMesheryPatternSource(id uuid.UUID) ([]byte, error) {\n\tvar mesheryPattern MesheryPattern\n\terr := mpp.DB.First(&mesheryPattern, id).Error\n\treturn mesheryPattern.SourceContent, err\n}\n\nfunc marshalMesheryPatternPage(mpp *MesheryPatternPage) []byte {\n\tres, _ := json.Marshal(mpp)\n\n\treturn res\n}\n\nfunc marshalMesheryPattern(mp *MesheryPattern) []byte {\n\tres, _ := json.Marshal(mp)\n\n\treturn res\n}\n\nfunc marshalMesheryPatterns(mps []MesheryPattern) []byte {\n\tres, _ := json.Marshal(mps)\n\n\treturn res\n}\n", "package models\n\nimport (\n\t\"strings\"\n\n\t\"github.com/gofrs/uuid\"\n\t\"github.com/layer5io/meshkit/database\"\n)\n\ntype PatternResourcePersister struct {\n\tDB *database.Handler\n}\n\ntype PatternResourcePage struct {\n\tPage       uint64             `json:\"page,omitempty\"`\n\tPageSize   uint64             `json:\"page_size,omitempty\"`\n\tTotalCount int                `json:\"total_count,omitempty\"`\n\tResources  []*PatternResource `json:\"resources,omitempty\"`\n}\n\nfunc (prp *PatternResourcePersister) SavePatternResource(pr *PatternResource) (*PatternResource, error) {\n\tif pr.ID == nil {\n\t\tid, err := uuid.NewV4()\n\t\tif err != nil {\n\t\t\treturn nil, ErrGenerateUUID(err)\n\t\t}\n\n\t\tpr.ID = &id\n\t}\n\n\treturn pr, prp.DB.Create(pr).Error\n}\n\nfunc (prp *PatternResourcePersister) DeletePatternResource(id uuid.UUID) error {\n\treturn prp.DB.Model(&PatternResource{}).Where(\"id = ?\", id).Update(\"deleted\", true).Error\n}\n\nfunc (prp *PatternResourcePersister) GetPatternResource(id uuid.UUID) (*PatternResource, error) {\n\tvar pr PatternResource\n\n\terr := prp.DB.First(&pr, id).Error\n\treturn &pr, err\n}\n\nfunc (prp *PatternResourcePersister) GetPatternResourceByAttributes(name, namespace, typ, oamType string) (*PatternResource, error) {\n\tvar pr PatternResource\n\n\terr := Paginate(0, 1)(prp.DB.Model(&PatternResource{}).Where(\n\t\t\"name = ? AND namespace = ? AND type = ? AND oam_type = ? AND deleted = false\",\n\t\tname,\n\t\tnamespace,\n\t\ttyp,\n\t\toamType,\n\t)).Scan(&pr).Error\n\n\treturn &pr, err\n}\n\nfunc (prp *PatternResourcePersister) GetPatternResources(search, order, name, namespace, typ, oamType string, page, pageSize uint64) (*PatternResourcePage, error) {\n\torder = SanitizeOrderInput(order, []string{\"created_at\", \"updated_at\", \"name\"})\n\n\tif order == \"\" {\n\t\torder = \"updated_at desc\"\n\t}\n\n\tcount := int64(0)\n\tresources := []*PatternResource{}\n\n\tquery := prp.DB.Order(order).Where(\"deleted = false\")\n\n\tif search != \"\" {\n\t\tlike := \"%\" + strings.ToLower(search) + \"%\"\n\t\tquery = query.Where(\"(lower(pattern_resources.name) like ?)\", like)\n\t}\n\tif name != \"\" {\n\t\tquery = query.Where(\"name = ?\", name)\n\t}\n\tif namespace != \"\" {\n\t\tquery = query.Where(\"namespace = ?\", namespace)\n\t}\n\tif typ != \"\" {\n\t\tquery = query.Where(\"type = ?\", typ)\n\t}\n\tif oamType != \"\" {\n\t\tquery = query.Where(\"oam_type = ?\", oamType)\n\t}\n\n\tquery.Model(&PatternResource{}).Count(&count)\n\n\tPaginate(uint(page), uint(pageSize))(query).Find(&resources)\n\n\tpatternResourcePage := &PatternResourcePage{\n\t\tPage:       page,\n\t\tPageSize:   pageSize,\n\t\tTotalCount: int(count),\n\t\tResources:  resources,\n\t}\n\n\treturn patternResourcePage, nil\n}\n\nfunc (prp *PatternResourcePersister) Exists(name, namespace, typ, oamType string) bool {\n\tvar result struct {\n\t\tFound bool\n\t}\n\n\tprp.DB.\n\t\tRaw(`\n\tSELECT\n\t\tEXISTS(SELECT 1 FROM pattern_resources WHERE name = ? AND namespace = ? AND type = ? AND oam_type = ? AND deleted = false) AS \"found\"`,\n\t\t\tname,\n\t\t\tnamespace,\n\t\t\ttyp,\n\t\t\toamType,\n\t\t).\n\t\tScan(&result)\n\n\treturn result.Found\n}\n", "package models\n\nimport (\n\t\"encoding/json\"\n\t\"strings\"\n\n\t\"github.com/gofrs/uuid\"\n\t\"github.com/layer5io/meshkit/database\"\n)\n\n// PerformanceProfilePersister is the persister for persisting\n// performance profiles on the database\ntype PerformanceProfilePersister struct {\n\tDB *database.Handler\n}\n\n// PerformanceProfilePage represents a page of performance profiles\ntype PerformanceProfilePage struct {\n\tPage       uint64                `json:\"page\"`\n\tPageSize   uint64                `json:\"page_size\"`\n\tTotalCount int                   `json:\"total_count\"`\n\tProfiles   []*PerformanceProfile `json:\"profiles\"`\n}\n\n// GetPerformanceProfiles returns all of the performance profiles\nfunc (ppp *PerformanceProfilePersister) GetPerformanceProfiles(_, search, order string, page, pageSize uint64) ([]byte, error) {\n\torder = SanitizeOrderInput(order, []string{\"updated_at\", \"created_at\", \"name\", \"last_run\"})\n\tif order == \"\" {\n\t\torder = \"updated_at desc\"\n\t}\n\n\tcount := int64(0)\n\tprofiles := []*PerformanceProfile{}\n\n\tquery := ppp.DB.\n\t\tSelect(`\n\t\tid, name, load_generators,\n\t\tendpoints, qps, service_mesh,\n\t\tduration, request_headers, request_cookies,\n\t\trequest_body, content_type, created_at,\n\t\tupdated_at, (?) as last_run, (?) as total_results`,\n\t\t\tppp.DB.Table(\"meshery_results\").Select(\"DATETIME(MAX(meshery_results.test_start_time))\").Where(\"performance_profile = performance_profiles.id\"),\n\t\t\tppp.DB.Table(\"meshery_results\").Select(\"COUNT(meshery_results.name)\").Where(\"performance_profile = performance_profiles.id\"),\n\t\t).\n\t\tOrder(order)\n\n\tif search != \"\" {\n\t\tlike := \"%\" + strings.ToLower(search) + \"%\"\n\t\tquery = query.Where(\"(lower(performance_profiles.name) like ?)\", like)\n\t}\n\n\tquery.Table(\"performance_profiles\").Count(&count)\n\n\tPaginate(uint(page), uint(pageSize))(query).Find(&profiles)\n\n\tperformanceProfilePage := &PerformanceProfilePage{\n\t\tPage:       page,\n\t\tPageSize:   pageSize,\n\t\tTotalCount: int(count),\n\t\tProfiles:   profiles,\n\t}\n\n\treturn marshalPerformanceProfilePage(performanceProfilePage), nil\n}\n\n// DeletePerformanceProfile takes in a profile id and delete it if it already exists\nfunc (ppp *PerformanceProfilePersister) DeletePerformanceProfile(id uuid.UUID) ([]byte, error) {\n\tprofile := PerformanceProfile{ID: &id}\n\tppp.DB.Delete(profile)\n\n\treturn marshalPerformanceProfile(&profile), nil\n}\n\nfunc (ppp *PerformanceProfilePersister) SavePerformanceProfile(_ uuid.UUID, profile *PerformanceProfile) error {\n\treturn ppp.DB.Save(profile).Error\n}\n\nfunc (ppp *PerformanceProfilePersister) GetPerformanceProfile(id uuid.UUID) (*PerformanceProfile, error) {\n\tvar performanceProfile PerformanceProfile\n\n\terr := ppp.DB.First(&performanceProfile, id).Error\n\treturn &performanceProfile, err\n}\n\nfunc marshalPerformanceProfilePage(ppp *PerformanceProfilePage) []byte {\n\tres, _ := json.Marshal(ppp)\n\n\treturn res\n}\n\nfunc marshalPerformanceProfile(pp *PerformanceProfile) []byte {\n\tres, _ := json.Marshal(pp)\n\n\treturn res\n}\n", "package models\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/layer5io/meshkit/database\"\n\t\"github.com/layer5io/meshkit/logger\"\n\t\"github.com/sirupsen/logrus\"\n\t\"github.com/spf13/viper\"\n)\n\n// SanitizeOrderInput takes in the \"order by\" query, a validColums\n// string slice and returns a sanitized query\n//\n// it will allow to run order by query only on the columns that are present\n// in the validColumns string slice, if any other column is requested in the\n// query then it will be IGNORED and an empty query would be returned instead\n//\n// SanitizeOrderInput also expects the query to be no longer than two words, that is\n// the query may look like \"updated_at DESC\" or \"name ASC\"\nfunc SanitizeOrderInput(order string, validColumns []string) string {\n\tparsedOrderStr := strings.Split(order, \" \")\n\tif len(parsedOrderStr) != 2 {\n\t\treturn \"\"\n\t}\n\n\tinputCol := parsedOrderStr[0]\n\ttyp := strings.ToLower(parsedOrderStr[1])\n\tfor _, col := range validColumns {\n\t\tif col == inputCol {\n\t\t\tif typ == \"desc\" {\n\t\t\t\treturn fmt.Sprintf(\"%s desc\", col)\n\t\t\t}\n\n\t\t\treturn fmt.Sprintf(\"%s asc\", col)\n\t\t}\n\t}\n\n\treturn \"\"\n}\n\nvar (\n\tdbHandler database.Handler\n\tmx        sync.Mutex\n)\n\nfunc setNewDBInstance() {\n\tmx.Lock()\n\tdefer mx.Unlock()\n\n\t// Initialize Logger instance\n\tlog, err := logger.New(\"meshery\", logger.Options{\n\t\tFormat: logger.SyslogLogFormat,\n\t})\n\tif err != nil {\n\t\tlog.Error(err)\n\t\tos.Exit(1)\n\t}\n\n\tdbHandler, err = database.New(database.Options{\n\t\tFilename: fmt.Sprintf(\"file:%s/mesherydb.sql?cache=private&mode=rwc&_busy_timeout=10000&_journal_mode=WAL\", viper.GetString(\"USER_DATA_FOLDER\")),\n\t\tEngine:   database.SQLITE,\n\t\tLogger:   log,\n\t})\n\tif err != nil {\n\t\tlogrus.Fatal(err)\n\t}\n}\n\nfunc GetNewDBInstance() *database.Handler {\n\tsetNewDBInstance()\n\treturn &dbHandler\n}\n"], "filenames": ["server/handlers/database_handlers.go", "server/models/meshery_application_persister.go", "server/models/meshery_filter_persister.go", "server/models/meshery_k8scontext_persister.go", "server/models/meshery_pattern_persister.go", "server/models/pattern_resource_persister.go", "server/models/performance_profile_persister.go", "server/models/sql-utils.go"], "buggy_code_start_loc": [75, 27, 31, 28, 32, 60, 27, 15], "buggy_code_end_loc": [75, 28, 69, 29, 69, 110, 28, 25], "fixing_code_start_loc": [76, 27, 31, 28, 32, 60, 27, 15], "fixing_code_end_loc": [77, 28, 69, 29, 69, 110, 28, 25], "type": "CWE-89", "message": "A SQL injection vulnerability exists in Meshery prior to version v0.6.179, enabling a remote attacker to retrieve sensitive information and execute arbitrary code through the \u201corder\u201d parameter", "other": {"cve": {"id": "CVE-2023-46575", "sourceIdentifier": "cve@mitre.org", "published": "2023-11-24T14:15:08.337", "lastModified": "2023-12-08T03:15:07.340", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A SQL injection vulnerability exists in Meshery prior to version v0.6.179, enabling a remote attacker to retrieve sensitive information and execute arbitrary code through the \u201corder\u201d parameter"}, {"lang": "es", "value": "Una vulnerabilidad de inyecci\u00f3n SQL en Meshery anterior a 0.6.179 permite a un atacante remoto obtener informaci\u00f3n confidencial y ejecutar c\u00f3digo arbitrario a trav\u00e9s del par\u00e1metro de orden."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:layer5:meshery:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.6.179", "matchCriteriaId": "D47AB9D1-CEE4-4EAA-B7FD-CFBD680E4A72"}]}]}], "references": [{"url": "https://github.com/meshery/meshery/commit/ffe00967acfe4444a5db08ff3a4cafb9adf6013f", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/meshery/meshery/compare/v0.6.178...v0.6.179", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/meshery/meshery/pull/9372", "source": "cve@mitre.org", "tags": ["Issue Tracking"]}, {"url": "https://meshery.io", "source": "cve@mitre.org", "tags": ["Product"]}]}, "github_commit_url": "https://github.com/meshery/meshery/commit/ffe00967acfe4444a5db08ff3a4cafb9adf6013f"}}