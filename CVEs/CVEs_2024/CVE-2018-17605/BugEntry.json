{"buggy_code": ["package asset.pipeline\n\n\nimport asset.pipeline.grails.AssetAttributes\nimport asset.pipeline.grails.AssetProcessorService\nimport asset.pipeline.grails.ProductionAssetCache\nimport groovy.transform.CompileStatic\nimport groovy.util.logging.Commons\nimport javax.servlet.FilterChain\nimport javax.servlet.FilterConfig\nimport javax.servlet.ServletContext\nimport javax.servlet.ServletException\nimport javax.servlet.ServletOutputStream\nimport javax.servlet.http.HttpServletRequest\nimport javax.servlet.http.HttpServletResponse\nimport org.springframework.context.ApplicationContext\nimport org.springframework.core.io.Resource\nimport org.springframework.web.context.support.WebApplicationContextUtils\nimport org.springframework.web.filter.OncePerRequestFilter\n\n\n@Commons\n@CompileStatic\nclass AssetPipelineFilter extends OncePerRequestFilter {\n\n\tstatic final ProductionAssetCache fileCache = new ProductionAssetCache()\n\tstatic final indexFile = 'index.html'\n\n\tApplicationContext applicationContext\n\tServletContext     servletContext\n\n\n\t@Override\n\tvoid initFilterBean() throws ServletException {\n\t\tfinal FilterConfig config = filterConfig\n\t\tapplicationContext = WebApplicationContextUtils.getWebApplicationContext(config.servletContext)\n\t\tservletContext = config.servletContext\n\t}\n\n\t@Override\n\tvoid doFilterInternal(final HttpServletRequest request, final HttpServletResponse response, final FilterChain chain) throws IOException, ServletException {\n\t\tfinal boolean warDeployed = AssetPipelineConfigHolder.manifest ? true : false\n\t\tfinal boolean skipNotFound = AssetPipelineConfigHolder.config.skipNotFound || AssetPipelineConfigHolder.config.mapping == ''\n\t\tfinal String mapping = ((AssetProcessorService)(applicationContext.getBean('assetProcessorService', AssetProcessorService))).assetMapping\n\n\t\tString fileUri = new URI(request.requestURI).path\n\n\t\tfinal String baseAssetUrl = request.contextPath == \"/\" ? \"/$mapping\" : \"${request.contextPath}/${mapping}\"\n\n\t\tfinal String format       = servletContext.getMimeType(fileUri)\n\t\tfinal String encoding     = request.getParameter('encoding') ?: request.getCharacterEncoding()\n\n\t\tif(fileUri.startsWith(baseAssetUrl)) {\n\t\t\tfileUri = fileUri.substring(baseAssetUrl.length())\n\t\t}\n\n\t\tif(warDeployed) {\n\t\t\tfinal Properties manifest = AssetPipelineConfigHolder.manifest\n\t\t\tString manifestPath = fileUri\n\t\t\tif(fileUri == '' || fileUri.endsWith('/')) {\n\t\t\t\tfileUri += indexFile\n\t\t\t}\n\t\t\tif(fileUri.startsWith('/')) {\n\t\t\t\tmanifestPath = fileUri.substring(1) //Omit forward slash\n\t\t\t}\n\n\t\t\tfileUri = manifest?.getProperty(manifestPath, manifestPath)\n\n\n\n\t\t\tfinal AssetAttributes attributeCache = fileCache.get(fileUri)\n\n\t\t\tif(attributeCache) {\n\t\t\t\tif(attributeCache.exists()) {\n\t\t\t\t\tResource file = attributeCache.resource\n\t\t\t\t\tfinal AssetPipelineResponseBuilder responseBuilder = new AssetPipelineResponseBuilder(\n\t\t\t\t\t\tmanifestPath,\n\t\t\t\t\t\trequest.getHeader('If-None-Match'),\n\t\t\t\t\t\trequest.getHeader('If-Modified-Since'),\n\t\t\t\t\t\tattributeCache.getLastModified()\n\t\t\t\t\t)\n\n\t\t\t\t\tresponseBuilder.headers.each { final header ->\n\t\t\t\t\t\tresponse.setHeader(header.key, header.value)\n\t\t\t\t\t}\n\n\t\t\t\t\tif(responseBuilder.statusCode) {\n\t\t\t\t\t\tresponse.status = responseBuilder.statusCode\n\t\t\t\t\t}\n\n\t\t\t\t\tif(response.status != 304) {\n\t\t\t\t\t\tfinal String acceptsEncoding = request.getHeader(\"Accept-Encoding\")\n\t\t\t\t\t\tif(acceptsEncoding?.tokenize(\", \")?.contains(\"gzip\") && attributeCache.gzipExists()) {\n\t\t\t\t\t\t\tfile = attributeCache.getGzipResource()\n\t\t\t\t\t\t\tresponse.setHeader('Content-Encoding', 'gzip')\n\t\t\t\t\t\t\tresponse.setHeader('Content-Length', attributeCache.getGzipFileSize().toString())\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresponse.setHeader('Content-Length', attributeCache.getFileSize().toString())\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(encoding) {\n\t\t\t\t\t\t\tresponse.setCharacterEncoding(encoding)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tresponse.setContentType(format)\n\t\t\t\t\t\tfinal InputStream inputStream\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tfinal byte[] buffer = new byte[102400]\n\t\t\t\t\t\t\tint len\n\t\t\t\t\t\t\tinputStream = file.inputStream\n\t\t\t\t\t\t\tfinal ServletOutputStream out = response.outputStream\n\t\t\t\t\t\t\twhile((len = inputStream.read(buffer)) != -1) {\n\t\t\t\t\t\t\t\tout.write(buffer, 0, len)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresponse.flushBuffer()\n\t\t\t\t\t\t} catch(final e) {\n\t\t\t\t\t\t\tlog.debug(\"File Transfer Aborted (Probably by the user)\", e)\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\ttry { inputStream?.close() } catch(final ie) { /* silent fail */ }\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresponse.flushBuffer()\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif(!skipNotFound){\n\t\t\t\t\t\tresponse.status = 404\n\t\t\t\t\t\tresponse.flushBuffer()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tResource file = applicationContext.getResource(\"assets/${fileUri}\")\n\t\t\t\tif(!file.exists()) {\n\t\t\t\t\tfile = applicationContext.getResource(\"classpath:assets/${fileUri}\")\n\t\t\t\t}\n\n\t\t\t\tif(file.exists()) {\n\t\t\t\t\tfinal AssetPipelineResponseBuilder responseBuilder = new AssetPipelineResponseBuilder(\n\t\t\t\t\t\tmanifestPath,\n\t\t\t\t\t\trequest.getHeader('If-None-Match'),\n\t\t\t\t\t\trequest.getHeader('If-Modified-Since'),\n\t\t\t\t\t\tfile.lastModified() ? new Date(file.lastModified()) : null\n\t\t\t\t\t)\n\n\t\t\t\t\tif(responseBuilder.statusCode) {\n\t\t\t\t\t\tresponse.status = responseBuilder.statusCode\n\t\t\t\t\t}\n\t\t\t\t\tresponseBuilder.headers.each { final header ->\n\t\t\t\t\t\tresponse.setHeader(header.key, header.value)\n\t\t\t\t\t}\n\n\t\t\t\t\tResource gzipFile = applicationContext.getResource(\"assets/${fileUri}.gz\")\n\t\t\t\t\tif(!gzipFile.exists()) {\n\t\t\t\t\t\tgzipFile = applicationContext.getResource(\"classpath:assets/${fileUri}.gz\")\n\t\t\t\t\t}\n\t\t\t\t\tfinal Date lastModifiedDate = file.lastModified() ? new Date(file.lastModified()) : null\n\n\t\t\t\t\tfinal AssetAttributes newCache = new AssetAttributes(\n\t\t\t\t\t\ttrue,\n\t\t\t\t\t\tgzipFile.exists(),\n\t\t\t\t\t\tfalse,\n\t\t\t\t\t\tfile.contentLength(),\n\t\t\t\t\t\tgzipFile.exists() ? gzipFile.contentLength() : null,\n\t\t\t\t\t\tlastModifiedDate,\n\t\t\t\t\t\tfile,\n\t\t\t\t\t\tgzipFile\n\t\t\t\t\t)\n\t\t\t\t\tfileCache.put(fileUri, newCache)\n\n\t\t\t\t\tif(response.status != 304) {\n\t\t\t\t\t\t// Check for GZip\n\t\t\t\t\t\tfinal String acceptsEncoding = request.getHeader(\"Accept-Encoding\")\n\t\t\t\t\t\tif(acceptsEncoding?.tokenize(\",\")?.contains(\"gzip\")) {\n\t\t\t\t\t\t\tif(gzipFile.exists()) {\n\t\t\t\t\t\t\t\tfile = gzipFile\n\t\t\t\t\t\t\t\tresponse.setHeader('Content-Encoding', 'gzip')\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(encoding) {\n\t\t\t\t\t\t\tresponse.setCharacterEncoding(encoding)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresponse.setContentType(format)\n\t\t\t\t\t\tresponse.setHeader('Content-Length', String.valueOf(file.contentLength()))\n\t\t\t\t\t\tfinal InputStream inputStream\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tfinal byte[] buffer = new byte[102400]\n\t\t\t\t\t\t\tint len\n\t\t\t\t\t\t\tinputStream = file.inputStream\n\t\t\t\t\t\t\tfinal ServletOutputStream out = response.outputStream\n\t\t\t\t\t\t\twhile((len = inputStream.read(buffer)) != -1) {\n\t\t\t\t\t\t\t\tout.write(buffer, 0, len)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresponse.flushBuffer()\n\t\t\t\t\t\t} catch(final e) {\n\t\t\t\t\t\t\tlog.debug(\"File Transfer Aborted (Probably by the user)\", e)\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\ttry { inputStream?.close() } catch(final ie) { /* silent fail */ }\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresponse.flushBuffer()\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfinal AssetAttributes newCache = new AssetAttributes(false, false, false, null, null, null, null, null)\n\t\t\t\t\tfileCache.put(fileUri, newCache)\n\t\t\t\t\tif(!skipNotFound){\n\t\t\t\t\t\tresponse.status = 404\n\t\t\t\t\t\tresponse.flushBuffer()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif(fileUri == '' || fileUri.endsWith('/')) {\n\t\t\t\tfileUri += indexFile\n\t\t\t}\n\t\t\tfinal byte[] fileContents\n\t\t\tif(request.getParameter('compile') == 'false') {\n\t\t\t\tfileContents = AssetPipeline.serveUncompiledAsset(fileUri, format, null, encoding)\n\t\t\t} else {\n\t\t\t\tfileContents = AssetPipeline.serveAsset(fileUri, format, null, encoding)\n\t\t\t}\n\n\t\t\tif(fileContents != null) {\n\t\t\t\tresponse.setHeader(\"Cache-Control\", \"no-cache, no-store, must-revalidate\") // HTTP 1.1.\n\t\t\t\tresponse.setHeader(\"Pragma\", \"no-cache\") // HTTP 1.0.\n\t\t\t\tresponse.setDateHeader(\"Expires\", 0) // Proxies.\n\t\t\t\tresponse.setHeader('Content-Length', String.valueOf(fileContents.size()))\n\n\t\t\t\tresponse.setContentType(format)\n\t\t\t\ttry {\n\t\t\t\t\tresponse.outputStream << fileContents\n\t\t\t\t\tresponse.flushBuffer()\n\t\t\t\t} catch(final e) {\n\t\t\t\t\tlog.debug(\"File Transfer Aborted (Probably by the user)\", e)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif(!skipNotFound) {\n\t\t\t\t\tresponse.status = 404\n\t\t\t\t\tresponse.flushBuffer()\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t}\n\n\t\tif(!response.committed) {\n\t\t\tchain.doFilter(request, response)\n\t\t}\n\t}\n}\n", "package asset.pipeline.servlet\n\n\nimport asset.pipeline.AssetPipelineResponseBuilder\nimport asset.pipeline.AssetPipelineConfigHolder\nimport java.util.logging.Logger\nimport javax.servlet.FilterChain\nimport javax.servlet.ServletContext\nimport javax.servlet.ServletException\nimport javax.servlet.ServletOutputStream\nimport javax.servlet.ServletRequest\nimport javax.servlet.ServletResponse\nimport javax.servlet.http.HttpServletRequest\nimport javax.servlet.http.HttpServletResponse\n\n\nclass AssetPipelineFilterCore {\n\n\tprivate static final Logger log = Logger.getLogger(getClass().getName())\n\tstatic final String HTTP_DATE_FORMAT = \"EEE, dd MMM yyyy HH:mm:ss zzz\"\n\n\n\tString mapping = \"mapping\"\n\tAssetPipelineServletResourceRepository assetPipelineServletResourceRepository\n\tServletContext servletContext\n\n\n\tvoid doFilter(final ServletRequest request, final ServletResponse response, final FilterChain chain) throws IOException, ServletException {\n\t\tif(request instanceof HttpServletRequest) {\n\t\t\tdoFilterHttp(request, response, chain)\n\t\t} else {\n\t\t\tchain.doFilter(request, response)\n\t\t}\n\t}\n\n\tprivate void doFilterHttp(final HttpServletRequest request, final HttpServletResponse response, final FilterChain filterChain) {\n\t\tif(assetPipelineServletResourceRepository == null) {\n\t\t\tthrow new IllegalStateException(\"Property 'assetPipelineServletResourceRepository' is null\")\n\t\t}\n\n\t\tString fileUri = request.requestURI\n\t\tfinal String baseAssetUrl = request.contextPath == \"/\" ? \"/$mapping\" : \"${request.contextPath}/${mapping}\"\n\t\tif(fileUri.startsWith(baseAssetUrl)) {\n\t\t\tfileUri = fileUri.substring(baseAssetUrl.length())\n\t\t}\n\t\tfinal Properties manifest = AssetPipelineConfigHolder.manifest\n\t\tString manifestPath = fileUri\n\t\tif(fileUri.startsWith('/')) {\n\t\t\tmanifestPath = fileUri.substring(1) //Omit forward slash\n\t\t}\n\t\tif(manifest) {\n\t\t\tfileUri = manifest.getProperty(manifestPath, manifestPath)\t\n\t\t}\n\t\t\n\t\tAssetPipelineServletResource resource = assetPipelineServletResourceRepository.getResource(fileUri)\n\t\tif(resource) {\n\t\t\tfinal Date lastModifiedDate = resource.getLastModified() ? new Date(resource.getLastModified()) : null\n\t\t\tfinal AssetPipelineResponseBuilder responseBuilder = new AssetPipelineResponseBuilder(\n\t\t\t\tfileUri,\n\t\t\t\trequest.getHeader('If-None-Match'),\n\t\t\t\trequest.getHeader('If-Modified-Since'),\n\t\t\t\tlastModifiedDate\n\t\t\t)\n\n\t\t\tresponseBuilder.headers.each { final header ->\n\t\t\t\tresponse.setHeader(header.key, header.value)\n\t\t\t}\n\t\t\tif(responseBuilder.statusCode) {\n\t\t\t\tresponse.status = responseBuilder.statusCode\n\t\t\t}\n\n\t\t\tif(response.status != 304) {\n\t\t\t\t// Check for GZip\n\t\t\t\tfinal String acceptsEncoding = request.getHeader(\"Accept-Encoding\")\n\t\t\t\tif(acceptsEncoding?.tokenize(\", \")?.contains(\"gzip\")) {\n\t\t\t\t\tfinal AssetPipelineServletResource gzipResource = assetPipelineServletResourceRepository.getGzippedResource(fileUri)\n\t\t\t\t\tif(gzipResource) {\n\t\t\t\t\t\tresource = gzipResource\n\t\t\t\t\t\tresponse.setHeader('Content-Encoding', 'gzip')\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinal String format = servletContext.getMimeType(request.requestURI)\n\t\t\t\tfinal String encoding = request.getCharacterEncoding()\n\t\t\t\tif(encoding) {\n\t\t\t\t\tresponse.setCharacterEncoding(encoding)\n\t\t\t\t}\n\t\t\t\tresponse.setContentType(format)\n\t\t\t\tfinal InputStream inputStream\n\t\t\t\ttry {\n\t\t\t\t\tfinal byte[] buffer = new byte[102400]\n\t\t\t\t\tint len\n\t\t\t\t\tinputStream = resource.inputStream\n\t\t\t\t\tfinal ServletOutputStream out = response.outputStream\n\t\t\t\t\twhile((len = inputStream.read(buffer)) != -1) {\n\t\t\t\t\t\tout.write(buffer, 0, len)\n\t\t\t\t\t}\n\t\t\t\t\tresponse.flushBuffer()\n\t\t\t\t} catch(final e) {\n\t\t\t\t\tlog.fine(\"File Transfer Aborted (Probably by the user): ${e.getMessage()}\")\n\t\t\t\t} finally {\n\t\t\t\t\ttry { inputStream?.close() } catch(final ie) { /* silent fail */ }\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresponse.flushBuffer()\n\t\t\t}\n\t\t}\n\n\t\tif(!response.committed) {\n\t\t\tfilterChain.doFilter(request, response)\n\t\t}\n\t}\n}\n", "buildscript {\n\trepositories {\n\t\tmavenLocal()\n\t\tjcenter()\n\t}\n\tdependencies {\n\t}\n}\n\nsubprojects {\n\tversion = '3.0.3'\n}\n\napply plugin: 'groovy'\napply plugin: 'idea'\n\ngroup = 'com.bertramlabs.plugins'\n\nrepositories {\n\tjcenter()\n\tmavenCentral()\n}\n\n// groovydoc {\n// \tgroovyClasspath = configurations.doc\n// }\n\ndependencies {\n\tcompile 'org.codehaus.groovy:groovy:2.0.7'\n\tcompile 'org.codehaus.groovy:groovy-templates:2.0.7'\n\tcompile 'org.mozilla:rhino:1.7R4'\n\t// compile 'com.google.javascript:closure-compiler-unshaded:v20170124'\n\tcompile     'com.google.javascript:closure-compiler-unshaded:v20160713'\n\t// compile 'com.google.javascript:closure-compiler-unshaded:v20171112'\n\tcompile 'commons-logging:commons-logging:1.1.1'\n\ttestCompile 'org.spockframework:spock-core:0.7-groovy-2.0'\n}\n\ntest {\n\ttestLogging {\n\t\texceptionFormat = 'full'\n\t\tshowStandardStreams = true\n\t}\n}\n\ntask wrapper(type: Wrapper) {\n\tgradleVersion = '3.3'\n}\n"], "fixing_code": ["package asset.pipeline\n\n\nimport asset.pipeline.grails.AssetAttributes\nimport asset.pipeline.grails.AssetProcessorService\nimport asset.pipeline.grails.ProductionAssetCache\nimport asset.pipeline.AssetHelper\nimport groovy.transform.CompileStatic\nimport groovy.util.logging.Commons\nimport javax.servlet.FilterChain\nimport javax.servlet.FilterConfig\nimport javax.servlet.ServletContext\nimport javax.servlet.ServletException\nimport javax.servlet.ServletOutputStream\nimport javax.servlet.http.HttpServletRequest\nimport javax.servlet.http.HttpServletResponse\nimport org.springframework.context.ApplicationContext\nimport org.springframework.core.io.Resource\nimport org.springframework.web.context.support.WebApplicationContextUtils\nimport org.springframework.web.filter.OncePerRequestFilter\n\n\n@Commons\n@CompileStatic\nclass AssetPipelineFilter extends OncePerRequestFilter {\n\n\tstatic final ProductionAssetCache fileCache = new ProductionAssetCache()\n\tstatic final indexFile = 'index.html'\n\n\tApplicationContext applicationContext\n\tServletContext     servletContext\n\n\n\t@Override\n\tvoid initFilterBean() throws ServletException {\n\t\tfinal FilterConfig config = filterConfig\n\t\tapplicationContext = WebApplicationContextUtils.getWebApplicationContext(config.servletContext)\n\t\tservletContext = config.servletContext\n\t}\n\n\t@Override\n\tvoid doFilterInternal(final HttpServletRequest request, final HttpServletResponse response, final FilterChain chain) throws IOException, ServletException {\n\t\tfinal boolean warDeployed = AssetPipelineConfigHolder.manifest ? true : false\n\t\tfinal boolean skipNotFound = AssetPipelineConfigHolder.config.skipNotFound || AssetPipelineConfigHolder.config.mapping == ''\n\t\tfinal String mapping = ((AssetProcessorService)(applicationContext.getBean('assetProcessorService', AssetProcessorService))).assetMapping\n\n\t\tString fileUri = new URI(request.requestURI).path\n\n\t\tfinal String baseAssetUrl = request.contextPath == \"/\" ? \"/$mapping\" : \"${request.contextPath}/${mapping}\"\n\n\t\tfinal String format       = servletContext.getMimeType(fileUri)\n\t\tfinal String encoding     = request.getParameter('encoding') ?: request.getCharacterEncoding()\n\n\t\tif(fileUri.startsWith(baseAssetUrl)) {\n\t\t\tfileUri = fileUri.substring(baseAssetUrl.length())\n\t\t}\n\n\t\tif(warDeployed) {\n\t\t\tfinal Properties manifest = AssetPipelineConfigHolder.manifest\n\t\t\tString manifestPath = fileUri\n\t\t\tif(fileUri == '' || fileUri.endsWith('/')) {\n\t\t\t\tfileUri += indexFile\n\t\t\t}\n\t\t\tif(fileUri.startsWith('/')) {\n\t\t\t\tmanifestPath = fileUri.substring(1) //Omit forward slash\n\t\t\t}\n\t\t\tfileUri = AssetHelper.normalizePath(fileUri) //JETTY Security bug, we MUST prevent reverse traversal\n\t\t\tfileUri = manifest?.getProperty(manifestPath, manifestPath)\n\n\n\n\t\t\tfinal AssetAttributes attributeCache = fileCache.get(fileUri)\n\n\t\t\tif(attributeCache) {\n\t\t\t\tif(attributeCache.exists()) {\n\t\t\t\t\tResource file = attributeCache.resource\n\t\t\t\t\tfinal AssetPipelineResponseBuilder responseBuilder = new AssetPipelineResponseBuilder(\n\t\t\t\t\t\tmanifestPath,\n\t\t\t\t\t\trequest.getHeader('If-None-Match'),\n\t\t\t\t\t\trequest.getHeader('If-Modified-Since'),\n\t\t\t\t\t\tattributeCache.getLastModified()\n\t\t\t\t\t)\n\n\t\t\t\t\tresponseBuilder.headers.each { final header ->\n\t\t\t\t\t\tresponse.setHeader(header.key, header.value)\n\t\t\t\t\t}\n\n\t\t\t\t\tif(responseBuilder.statusCode) {\n\t\t\t\t\t\tresponse.status = responseBuilder.statusCode\n\t\t\t\t\t}\n\n\t\t\t\t\tif(response.status != 304) {\n\t\t\t\t\t\tfinal String acceptsEncoding = request.getHeader(\"Accept-Encoding\")\n\t\t\t\t\t\tif(acceptsEncoding?.tokenize(\", \")?.contains(\"gzip\") && attributeCache.gzipExists()) {\n\t\t\t\t\t\t\tfile = attributeCache.getGzipResource()\n\t\t\t\t\t\t\tresponse.setHeader('Content-Encoding', 'gzip')\n\t\t\t\t\t\t\tresponse.setHeader('Content-Length', attributeCache.getGzipFileSize().toString())\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresponse.setHeader('Content-Length', attributeCache.getFileSize().toString())\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(encoding) {\n\t\t\t\t\t\t\tresponse.setCharacterEncoding(encoding)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tresponse.setContentType(format)\n\t\t\t\t\t\tfinal InputStream inputStream\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tfinal byte[] buffer = new byte[102400]\n\t\t\t\t\t\t\tint len\n\t\t\t\t\t\t\tinputStream = file.inputStream\n\t\t\t\t\t\t\tfinal ServletOutputStream out = response.outputStream\n\t\t\t\t\t\t\twhile((len = inputStream.read(buffer)) != -1) {\n\t\t\t\t\t\t\t\tout.write(buffer, 0, len)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresponse.flushBuffer()\n\t\t\t\t\t\t} catch(final e) {\n\t\t\t\t\t\t\tlog.debug(\"File Transfer Aborted (Probably by the user)\", e)\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\ttry { inputStream?.close() } catch(final ie) { /* silent fail */ }\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresponse.flushBuffer()\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif(!skipNotFound){\n\t\t\t\t\t\tresponse.status = 404\n\t\t\t\t\t\tresponse.flushBuffer()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tResource file = applicationContext.getResource(\"assets/${fileUri}\")\n\t\t\t\tif(!file.exists()) {\n\t\t\t\t\tfile = applicationContext.getResource(\"classpath:assets/${fileUri}\")\n\t\t\t\t}\n\n\t\t\t\tif(file.exists()) {\n\t\t\t\t\tfinal AssetPipelineResponseBuilder responseBuilder = new AssetPipelineResponseBuilder(\n\t\t\t\t\t\tmanifestPath,\n\t\t\t\t\t\trequest.getHeader('If-None-Match'),\n\t\t\t\t\t\trequest.getHeader('If-Modified-Since'),\n\t\t\t\t\t\tfile.lastModified() ? new Date(file.lastModified()) : null\n\t\t\t\t\t)\n\n\t\t\t\t\tif(responseBuilder.statusCode) {\n\t\t\t\t\t\tresponse.status = responseBuilder.statusCode\n\t\t\t\t\t}\n\t\t\t\t\tresponseBuilder.headers.each { final header ->\n\t\t\t\t\t\tresponse.setHeader(header.key, header.value)\n\t\t\t\t\t}\n\n\t\t\t\t\tResource gzipFile = applicationContext.getResource(\"assets/${fileUri}.gz\")\n\t\t\t\t\tif(!gzipFile.exists()) {\n\t\t\t\t\t\tgzipFile = applicationContext.getResource(\"classpath:assets/${fileUri}.gz\")\n\t\t\t\t\t}\n\t\t\t\t\tfinal Date lastModifiedDate = file.lastModified() ? new Date(file.lastModified()) : null\n\n\t\t\t\t\tfinal AssetAttributes newCache = new AssetAttributes(\n\t\t\t\t\t\ttrue,\n\t\t\t\t\t\tgzipFile.exists(),\n\t\t\t\t\t\tfalse,\n\t\t\t\t\t\tfile.contentLength(),\n\t\t\t\t\t\tgzipFile.exists() ? gzipFile.contentLength() : null,\n\t\t\t\t\t\tlastModifiedDate,\n\t\t\t\t\t\tfile,\n\t\t\t\t\t\tgzipFile\n\t\t\t\t\t)\n\t\t\t\t\tfileCache.put(fileUri, newCache)\n\n\t\t\t\t\tif(response.status != 304) {\n\t\t\t\t\t\t// Check for GZip\n\t\t\t\t\t\tfinal String acceptsEncoding = request.getHeader(\"Accept-Encoding\")\n\t\t\t\t\t\tif(acceptsEncoding?.tokenize(\",\")?.contains(\"gzip\")) {\n\t\t\t\t\t\t\tif(gzipFile.exists()) {\n\t\t\t\t\t\t\t\tfile = gzipFile\n\t\t\t\t\t\t\t\tresponse.setHeader('Content-Encoding', 'gzip')\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(encoding) {\n\t\t\t\t\t\t\tresponse.setCharacterEncoding(encoding)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresponse.setContentType(format)\n\t\t\t\t\t\tresponse.setHeader('Content-Length', String.valueOf(file.contentLength()))\n\t\t\t\t\t\tfinal InputStream inputStream\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tfinal byte[] buffer = new byte[102400]\n\t\t\t\t\t\t\tint len\n\t\t\t\t\t\t\tinputStream = file.inputStream\n\t\t\t\t\t\t\tfinal ServletOutputStream out = response.outputStream\n\t\t\t\t\t\t\twhile((len = inputStream.read(buffer)) != -1) {\n\t\t\t\t\t\t\t\tout.write(buffer, 0, len)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresponse.flushBuffer()\n\t\t\t\t\t\t} catch(final e) {\n\t\t\t\t\t\t\tlog.debug(\"File Transfer Aborted (Probably by the user)\", e)\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\ttry { inputStream?.close() } catch(final ie) { /* silent fail */ }\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresponse.flushBuffer()\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfinal AssetAttributes newCache = new AssetAttributes(false, false, false, null, null, null, null, null)\n\t\t\t\t\tfileCache.put(fileUri, newCache)\n\t\t\t\t\tif(!skipNotFound){\n\t\t\t\t\t\tresponse.status = 404\n\t\t\t\t\t\tresponse.flushBuffer()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif(fileUri == '' || fileUri.endsWith('/')) {\n\t\t\t\tfileUri += indexFile\n\t\t\t}\n\t\t\tfinal byte[] fileContents\n\t\t\tif(request.getParameter('compile') == 'false') {\n\t\t\t\tfileContents = AssetPipeline.serveUncompiledAsset(fileUri, format, null, encoding)\n\t\t\t} else {\n\t\t\t\tfileContents = AssetPipeline.serveAsset(fileUri, format, null, encoding)\n\t\t\t}\n\n\t\t\tif(fileContents != null) {\n\t\t\t\tresponse.setHeader(\"Cache-Control\", \"no-cache, no-store, must-revalidate\") // HTTP 1.1.\n\t\t\t\tresponse.setHeader(\"Pragma\", \"no-cache\") // HTTP 1.0.\n\t\t\t\tresponse.setDateHeader(\"Expires\", 0) // Proxies.\n\t\t\t\tresponse.setHeader('Content-Length', String.valueOf(fileContents.size()))\n\n\t\t\t\tresponse.setContentType(format)\n\t\t\t\ttry {\n\t\t\t\t\tresponse.outputStream << fileContents\n\t\t\t\t\tresponse.flushBuffer()\n\t\t\t\t} catch(final e) {\n\t\t\t\t\tlog.debug(\"File Transfer Aborted (Probably by the user)\", e)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif(!skipNotFound) {\n\t\t\t\t\tresponse.status = 404\n\t\t\t\t\tresponse.flushBuffer()\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t}\n\n\t\tif(!response.committed) {\n\t\t\tchain.doFilter(request, response)\n\t\t}\n\t}\n}\n", "package asset.pipeline.servlet\n\n\nimport asset.pipeline.AssetPipelineResponseBuilder\nimport asset.pipeline.AssetPipelineConfigHolder\nimport asset.pipeline.AssetHelper\nimport java.util.logging.Logger\nimport javax.servlet.FilterChain\nimport javax.servlet.ServletContext\nimport javax.servlet.ServletException\nimport javax.servlet.ServletOutputStream\nimport javax.servlet.ServletRequest\nimport javax.servlet.ServletResponse\nimport javax.servlet.http.HttpServletRequest\nimport javax.servlet.http.HttpServletResponse\n\n\nclass AssetPipelineFilterCore {\n\n\tprivate static final Logger log = Logger.getLogger(getClass().getName())\n\tstatic final String HTTP_DATE_FORMAT = \"EEE, dd MMM yyyy HH:mm:ss zzz\"\n\n\n\tString mapping = \"mapping\"\n\tAssetPipelineServletResourceRepository assetPipelineServletResourceRepository\n\tServletContext servletContext\n\n\n\tvoid doFilter(final ServletRequest request, final ServletResponse response, final FilterChain chain) throws IOException, ServletException {\n\t\tif(request instanceof HttpServletRequest) {\n\t\t\tdoFilterHttp(request, response, chain)\n\t\t} else {\n\t\t\tchain.doFilter(request, response)\n\t\t}\n\t}\n\n\tprivate void doFilterHttp(final HttpServletRequest request, final HttpServletResponse response, final FilterChain filterChain) {\n\t\tif(assetPipelineServletResourceRepository == null) {\n\t\t\tthrow new IllegalStateException(\"Property 'assetPipelineServletResourceRepository' is null\")\n\t\t}\n\n\t\tString fileUri = request.requestURI\n\t\tfinal String baseAssetUrl = request.contextPath == \"/\" ? \"/$mapping\" : \"${request.contextPath}/${mapping}\"\n\t\tif(fileUri.startsWith(baseAssetUrl)) {\n\t\t\tfileUri = fileUri.substring(baseAssetUrl.length())\n\t\t}\n\t\tfileUri = AssetHelper.normalizePath(fileUri) //JETTY Security bug, we MUST prevent reverse \n\t\tfinal Properties manifest = AssetPipelineConfigHolder.manifest\n\t\tString manifestPath = fileUri\n\t\tif(fileUri.startsWith('/')) {\n\t\t\tmanifestPath = fileUri.substring(1) //Omit forward slash\n\t\t}\n\t\tif(manifest) {\n\t\t\tfileUri = manifest.getProperty(manifestPath, manifestPath)\t\n\t\t}\n\t\t\n\t\tAssetPipelineServletResource resource = assetPipelineServletResourceRepository.getResource(fileUri)\n\t\tif(resource) {\n\t\t\tfinal Date lastModifiedDate = resource.getLastModified() ? new Date(resource.getLastModified()) : null\n\t\t\tfinal AssetPipelineResponseBuilder responseBuilder = new AssetPipelineResponseBuilder(\n\t\t\t\tfileUri,\n\t\t\t\trequest.getHeader('If-None-Match'),\n\t\t\t\trequest.getHeader('If-Modified-Since'),\n\t\t\t\tlastModifiedDate\n\t\t\t)\n\n\t\t\tresponseBuilder.headers.each { final header ->\n\t\t\t\tresponse.setHeader(header.key, header.value)\n\t\t\t}\n\t\t\tif(responseBuilder.statusCode) {\n\t\t\t\tresponse.status = responseBuilder.statusCode\n\t\t\t}\n\n\t\t\tif(response.status != 304) {\n\t\t\t\t// Check for GZip\n\t\t\t\tfinal String acceptsEncoding = request.getHeader(\"Accept-Encoding\")\n\t\t\t\tif(acceptsEncoding?.tokenize(\", \")?.contains(\"gzip\")) {\n\t\t\t\t\tfinal AssetPipelineServletResource gzipResource = assetPipelineServletResourceRepository.getGzippedResource(fileUri)\n\t\t\t\t\tif(gzipResource) {\n\t\t\t\t\t\tresource = gzipResource\n\t\t\t\t\t\tresponse.setHeader('Content-Encoding', 'gzip')\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinal String format = servletContext.getMimeType(request.requestURI)\n\t\t\t\tfinal String encoding = request.getCharacterEncoding()\n\t\t\t\tif(encoding) {\n\t\t\t\t\tresponse.setCharacterEncoding(encoding)\n\t\t\t\t}\n\t\t\t\tresponse.setContentType(format)\n\t\t\t\tfinal InputStream inputStream\n\t\t\t\ttry {\n\t\t\t\t\tfinal byte[] buffer = new byte[102400]\n\t\t\t\t\tint len\n\t\t\t\t\tinputStream = resource.inputStream\n\t\t\t\t\tfinal ServletOutputStream out = response.outputStream\n\t\t\t\t\twhile((len = inputStream.read(buffer)) != -1) {\n\t\t\t\t\t\tout.write(buffer, 0, len)\n\t\t\t\t\t}\n\t\t\t\t\tresponse.flushBuffer()\n\t\t\t\t} catch(final e) {\n\t\t\t\t\tlog.fine(\"File Transfer Aborted (Probably by the user): ${e.getMessage()}\")\n\t\t\t\t} finally {\n\t\t\t\t\ttry { inputStream?.close() } catch(final ie) { /* silent fail */ }\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresponse.flushBuffer()\n\t\t\t}\n\t\t}\n\n\t\tif(!response.committed) {\n\t\t\tfilterChain.doFilter(request, response)\n\t\t}\n\t}\n}\n", "buildscript {\n\trepositories {\n\t\tmavenLocal()\n\t\tjcenter()\n\t}\n\tdependencies {\n\t}\n}\n\nsubprojects {\n\tversion = '3.0.4'\n}\n\napply plugin: 'groovy'\napply plugin: 'idea'\n\ngroup = 'com.bertramlabs.plugins'\n\nrepositories {\n\tjcenter()\n\tmavenCentral()\n}\n\n// groovydoc {\n// \tgroovyClasspath = configurations.doc\n// }\n\ndependencies {\n\tcompile 'org.codehaus.groovy:groovy:2.0.7'\n\tcompile 'org.codehaus.groovy:groovy-templates:2.0.7'\n\tcompile 'org.mozilla:rhino:1.7R4'\n\t// compile 'com.google.javascript:closure-compiler-unshaded:v20170124'\n\tcompile     'com.google.javascript:closure-compiler-unshaded:v20160713'\n\t// compile 'com.google.javascript:closure-compiler-unshaded:v20171112'\n\tcompile 'commons-logging:commons-logging:1.1.1'\n\ttestCompile 'org.spockframework:spock-core:0.7-groovy-2.0'\n}\n\ntest {\n\ttestLogging {\n\t\texceptionFormat = 'full'\n\t\tshowStandardStreams = true\n\t}\n}\n\ntask wrapper(type: Wrapper) {\n\tgradleVersion = '3.3'\n}\n"], "filenames": ["asset-pipeline-grails/src/main/groovy/asset/pipeline/AssetPipelineFilter.groovy", "asset-pipeline-servlet/src/main/groovy/asset/pipeline/servlet/AssetPipelineFilterCore.groovy", "build.gradle"], "buggy_code_start_loc": [6, 5, 11], "buggy_code_end_loc": [67, 45, 12], "fixing_code_start_loc": [7, 6, 11], "fixing_code_end_loc": [68, 48, 12], "type": "CWE-22", "message": "An issue was discovered in the Asset Pipeline plugin before 3.0.4 for Grails. An attacker can perform directory traversal via a crafted request when a servlet-based application is executed in Jetty, because there is a classloader vulnerability that can allow a reverse file traversal route in AssetPipelineFilter.groovy or AssetPipelineFilterCore.groovy.", "other": {"cve": {"id": "CVE-2018-17605", "sourceIdentifier": "cve@mitre.org", "published": "2018-09-28T09:29:01.213", "lastModified": "2018-12-28T15:24:06.603", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in the Asset Pipeline plugin before 3.0.4 for Grails. An attacker can perform directory traversal via a crafted request when a servlet-based application is executed in Jetty, because there is a classloader vulnerability that can allow a reverse file traversal route in AssetPipelineFilter.groovy or AssetPipelineFilterCore.groovy."}, {"lang": "es", "value": "Se ha descubierto un problema en el plugin Asset Pipeline en versiones anteriores a la 3.0.4 para Grails. Un atacante puede realizar un salto de directorio mediante una petici\u00f3n manipulada cuando una aplicaci\u00f3n basada en servlets se ejecuta en Jetty, debido a que hay una vulnerabilidad classloader que puede permitir una ruta de salto de archivos inverso en AssetPipelineFilter.groovy o AssetPipelineFilterCore.groovy."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:asset_pipeline_project:asset-pipeline:*:*:*:*:*:grails:*:*", "versionEndExcluding": "3.0.4", "matchCriteriaId": "6DA446E3-D96B-436C-99FF-57BFC65B8C0F"}]}]}], "references": [{"url": "https://github.com/bertramdev/asset-pipeline/commit/a29533c52e4b60e244082433e116d2a038d01017", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/grails/grails-core/issues/11068", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/bertramdev/asset-pipeline/commit/a29533c52e4b60e244082433e116d2a038d01017"}}