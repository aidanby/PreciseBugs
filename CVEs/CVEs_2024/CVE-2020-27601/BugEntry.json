{"buggy_code": ["import Users from '/imports/api/users';\nimport Meetings from '/imports/api/meetings';\nimport { GroupChatMsg } from '/imports/api/group-chat-msg';\nimport GroupChat from '/imports/api/group-chat';\nimport Auth from '/imports/ui/services/auth';\nimport UnreadMessages from '/imports/ui/services/unread-messages';\nimport Storage from '/imports/ui/services/storage/session';\nimport { makeCall } from '/imports/ui/services/api';\nimport _ from 'lodash';\n\nconst CHAT_CONFIG = Meteor.settings.public.chat;\nconst GROUPING_MESSAGES_WINDOW = CHAT_CONFIG.grouping_messages_window;\n\nconst SYSTEM_CHAT_TYPE = CHAT_CONFIG.type_system;\n\nconst PUBLIC_CHAT_ID = CHAT_CONFIG.public_id;\nconst PUBLIC_GROUP_CHAT_ID = CHAT_CONFIG.public_group_id;\nconst PRIVATE_CHAT_TYPE = CHAT_CONFIG.type_private;\nconst PUBLIC_CHAT_USER_ID = CHAT_CONFIG.system_userid;\nconst PUBLIC_CHAT_CLEAR = CHAT_CONFIG.system_messages_keys.chat_clear;\n\nconst ROLE_MODERATOR = Meteor.settings.public.user.role_moderator;\n\nconst CONNECTION_STATUS_ONLINE = 'online';\n\nconst ScrollCollection = new Mongo.Collection(null);\n\nconst UnsentMessagesCollection = new Mongo.Collection(null);\n\n// session for closed chat list\nconst CLOSED_CHAT_LIST_KEY = 'closedChatList';\n\nconst getUser = userId => Users.findOne({ userId });\n\nconst getWelcomeProp = () => Meetings.findOne({ meetingId: Auth.meetingID },\n  { fields: { welcomeProp: 1 } });\n\nconst mapGroupMessage = (message) => {\n  const mappedMessage = {\n    id: message._id,\n    content: message.content,\n    time: message.timestamp,\n    sender: null,\n  };\n\n  if (message.sender !== SYSTEM_CHAT_TYPE) {\n    const sender = Users.findOne({ userId: message.sender },\n      {\n        fields: {\n          color: 1, role: 1, name: 1, connectionStatus: 1,\n        },\n      });\n    const {\n      color,\n      role,\n      name,\n      connectionStatus,\n    } = sender;\n\n    const mappedSender = {\n      color,\n      isModerator: role === ROLE_MODERATOR,\n      name,\n      isOnline: connectionStatus === CONNECTION_STATUS_ONLINE,\n    };\n\n    mappedMessage.sender = mappedSender;\n  }\n\n  return mappedMessage;\n};\n\nconst reduceGroupMessages = (previous, current) => {\n  const lastMessage = previous[previous.length - 1];\n  const currentMessage = current;\n  currentMessage.content = [{\n    id: current.id,\n    text: current.message,\n    time: current.timestamp,\n  }];\n  if (!lastMessage || !currentMessage.chatId === PUBLIC_GROUP_CHAT_ID) {\n    return previous.concat(currentMessage);\n  }\n  // Check if the last message is from the same user and time discrepancy\n  // between the two messages exceeds window and then group current message\n  // with the last one\n  const timeOfLastMessage = lastMessage.content[lastMessage.content.length - 1].time;\n  if (lastMessage.sender === currentMessage.sender\n    && (currentMessage.timestamp - timeOfLastMessage) <= GROUPING_MESSAGES_WINDOW) {\n    lastMessage.content.push(currentMessage.content.pop());\n    return previous;\n  }\n\n  return previous.concat(currentMessage);\n};\n\nconst reduceAndMapGroupMessages = messages => (messages\n  .reduce(reduceGroupMessages, []).map(mapGroupMessage));\n\nconst getPublicGroupMessages = () => {\n  const publicGroupMessages = GroupChatMsg.find({\n    meetingId: Auth.meetingID,\n    chatId: PUBLIC_GROUP_CHAT_ID,\n  }, { sort: ['timestamp'] }).fetch();\n  return publicGroupMessages;\n};\n\nconst getPrivateGroupMessages = () => {\n  const chatID = Session.get('idChatOpen');\n  const senderId = Auth.userID;\n\n  const privateChat = GroupChat.findOne({\n    meetingId: Auth.meetingID,\n    users: { $all: [chatID, senderId] },\n    access: PRIVATE_CHAT_TYPE,\n  });\n\n  let messages = [];\n\n  if (privateChat) {\n    const {\n      chatId,\n    } = privateChat;\n\n    messages = GroupChatMsg.find({\n      meetingId: Auth.meetingID,\n      chatId,\n    }, { sort: ['timestamp'] }).fetch();\n  }\n\n  return reduceAndMapGroupMessages(messages, []);\n};\n\nconst isChatLocked = (receiverID) => {\n  const isPublic = receiverID === PUBLIC_CHAT_ID;\n\n  const meeting = Meetings.findOne({ meetingId: Auth.meetingID },\n    { fields: { 'lockSettingsProps.disablePublicChat': 1 } });\n  const user = Users.findOne({ meetingId: Auth.meetingID, userId: Auth.userID },\n    { fields: { locked: 1, role: 1 } });\n  const receiver = Users.findOne({ meetingId: Auth.meetingID, userId: receiverID },\n    { fields: { role: 1 } });\n  const isReceiverModerator = receiver && receiver.role === ROLE_MODERATOR;\n\n  if (meeting.lockSettingsProps !== undefined) {\n    if (user.locked && user.role !== ROLE_MODERATOR) {\n      if (isPublic) {\n        return meeting.lockSettingsProps.disablePublicChat;\n      }\n      return !isReceiverModerator\n        && meeting.lockSettingsProps.disablePrivateChat;\n    }\n  }\n\n  return false;\n};\n\nconst hasUnreadMessages = (receiverID) => {\n  const isPublic = receiverID === PUBLIC_CHAT_ID;\n  const chatType = isPublic ? PUBLIC_GROUP_CHAT_ID : receiverID;\n  return UnreadMessages.count(chatType) > 0;\n};\n\nconst lastReadMessageTime = (receiverID) => {\n  const isPublic = receiverID === PUBLIC_CHAT_ID;\n  const chatType = isPublic ? PUBLIC_GROUP_CHAT_ID : receiverID;\n\n  return UnreadMessages.get(chatType);\n};\n\nconst sendGroupMessage = (message) => {\n  const chatID = Session.get('idChatOpen');\n  const isPublicChat = chatID === PUBLIC_CHAT_ID;\n\n  let destinationChatId = PUBLIC_GROUP_CHAT_ID;\n\n  const { fullname: senderName, userID: senderUserId } = Auth;\n  const receiverId = { id: chatID };\n\n  if (!isPublicChat) {\n    const privateChat = GroupChat.findOne({ users: { $all: [chatID, senderUserId] } },\n      { fields: { chatId: 1 } });\n\n    if (privateChat) {\n      const { chatId: privateChatId } = privateChat;\n\n      destinationChatId = privateChatId;\n    }\n  }\n\n  const payload = {\n    color: '0',\n    correlationId: `${senderUserId}-${Date.now()}`,\n    sender: {\n      id: senderUserId,\n      name: senderName,\n    },\n    message,\n  };\n\n  const currentClosedChats = Storage.getItem(CLOSED_CHAT_LIST_KEY);\n\n  // Remove the chat that user send messages from the session.\n  if (_.indexOf(currentClosedChats, receiverId.id) > -1) {\n    Storage.setItem(CLOSED_CHAT_LIST_KEY, _.without(currentClosedChats, receiverId.id));\n  }\n\n  return makeCall('sendGroupChatMsg', destinationChatId, payload);\n};\n\nconst getScrollPosition = (receiverID) => {\n  const scroll = ScrollCollection.findOne({ receiver: receiverID },\n    { fields: { position: 1 } }) || { position: null };\n  return scroll.position;\n};\n\nconst updateScrollPosition = position => ScrollCollection.upsert(\n  { receiver: Session.get('idChatOpen') },\n  { $set: { position } },\n);\n\nconst updateUnreadMessage = (timestamp) => {\n  const chatID = Session.get('idChatOpen');\n  const isPublic = chatID === PUBLIC_CHAT_ID;\n  const chatType = isPublic ? PUBLIC_GROUP_CHAT_ID : chatID;\n  return UnreadMessages.update(chatType, timestamp);\n};\n\nconst clearPublicChatHistory = () => (makeCall('clearPublicChatHistory'));\n\nconst closePrivateChat = () => {\n  const chatID = Session.get('idChatOpen');\n  const currentClosedChats = Storage.getItem(CLOSED_CHAT_LIST_KEY) || [];\n\n  if (_.indexOf(currentClosedChats, chatID) < 0) {\n    currentClosedChats.push(chatID);\n\n    Storage.setItem(CLOSED_CHAT_LIST_KEY, currentClosedChats);\n  }\n};\n\n// if this private chat has been added to the list of closed ones, remove it\nconst removeFromClosedChatsSession = () => {\n  const chatID = Session.get('idChatOpen');\n  const currentClosedChats = Storage.getItem(CLOSED_CHAT_LIST_KEY);\n  if (_.indexOf(currentClosedChats, chatID) > -1) {\n    Storage.setItem(CLOSED_CHAT_LIST_KEY, _.without(currentClosedChats, chatID));\n  }\n};\n\n// We decode to prevent HTML5 escaped characters.\nconst htmlDecode = (input) => {\n  const e = document.createElement('div');\n  e.innerHTML = input;\n  const messages = Array.from(e.childNodes);\n  const message = messages.map(chatMessage => chatMessage.textContent);\n  return message.join('');\n};\n\n// Export the chat as [Hour:Min] user: message\nconst exportChat = (messageList) => {\n  const { welcomeProp } = getWelcomeProp();\n  const { loginTime } = Users.findOne({ userId: Auth.userID }, { fields: { loginTime: 1 } });\n  const { welcomeMsg } = welcomeProp;\n\n  const clearMessage = messageList.filter(message => message.message === PUBLIC_CHAT_CLEAR);\n\n  const hasClearMessage = clearMessage.length;\n\n  if (!hasClearMessage || (hasClearMessage && clearMessage[0].timestamp < loginTime)) {\n    messageList.push({\n      timestamp: loginTime,\n      message: welcomeMsg,\n      type: SYSTEM_CHAT_TYPE,\n      sender: PUBLIC_CHAT_USER_ID,\n    });\n  }\n\n  messageList.sort((a, b) => a.timestamp - b.timestamp);\n\n  return messageList.map((message) => {\n    const date = new Date(message.timestamp);\n    const hour = date.getHours().toString().padStart(2, 0);\n    const min = date.getMinutes().toString().padStart(2, 0);\n    const hourMin = `[${hour}:${min}]`;\n    if (message.type === SYSTEM_CHAT_TYPE) {\n      return `${hourMin} ${message.message}`;\n    }\n    const userName = message.sender === PUBLIC_CHAT_USER_ID\n      ? ''\n      : `${getUser(message.sender).name} :`;\n    return `${hourMin} ${userName} ${htmlDecode(message.message)}`;\n  }).join('\\n');\n};\n\nconst getAllMessages = (chatID) => {\n  const filter = {\n    sender: { $ne: Auth.userID },\n  };\n  if (chatID === PUBLIC_GROUP_CHAT_ID) {\n    filter.chatId = { $eq: chatID };\n  } else {\n    const privateChat = GroupChat.findOne({ users: { $all: [chatID, Auth.userID] } });\n\n    filter.chatId = { $ne: PUBLIC_GROUP_CHAT_ID };\n\n    if (privateChat) {\n      filter.chatId = privateChat.chatId;\n    }\n  }\n  const messages = GroupChatMsg.find(filter).fetch();\n  return messages;\n};\n\nconst maxTimestampReducer = (max, el) => ((el.timestamp > max) ? el.timestamp : max);\n\nconst maxNumberReducer = (max, el) => ((el > max) ? el : max);\n\nconst getLastMessageTimestampFromChatList = activeChats => activeChats\n  .map(chat => ((chat.userId === 'public') ? 'MAIN-PUBLIC-GROUP-CHAT' : chat.userId))\n  .map(chatId => getAllMessages(chatId).reduce(maxTimestampReducer, 0))\n  .reduce(maxNumberReducer, 0);\n\nexport default {\n  reduceAndMapGroupMessages,\n  getPublicGroupMessages,\n  getPrivateGroupMessages,\n  getUser,\n  getWelcomeProp,\n  getScrollPosition,\n  hasUnreadMessages,\n  lastReadMessageTime,\n  isChatLocked,\n  updateScrollPosition,\n  updateUnreadMessage,\n  sendGroupMessage,\n  closePrivateChat,\n  removeFromClosedChatsSession,\n  exportChat,\n  clearPublicChatHistory,\n  maxTimestampReducer,\n  getLastMessageTimestampFromChatList,\n  UnsentMessagesCollection,\n};\n"], "fixing_code": ["import Users from '/imports/api/users';\nimport Meetings from '/imports/api/meetings';\nimport { GroupChatMsg } from '/imports/api/group-chat-msg';\nimport GroupChat from '/imports/api/group-chat';\nimport Auth from '/imports/ui/services/auth';\nimport UnreadMessages from '/imports/ui/services/unread-messages';\nimport Storage from '/imports/ui/services/storage/session';\nimport { makeCall } from '/imports/ui/services/api';\nimport _ from 'lodash';\n\nconst CHAT_CONFIG = Meteor.settings.public.chat;\nconst GROUPING_MESSAGES_WINDOW = CHAT_CONFIG.grouping_messages_window;\n\nconst SYSTEM_CHAT_TYPE = CHAT_CONFIG.type_system;\n\nconst PUBLIC_CHAT_ID = CHAT_CONFIG.public_id;\nconst PUBLIC_GROUP_CHAT_ID = CHAT_CONFIG.public_group_id;\nconst PRIVATE_CHAT_TYPE = CHAT_CONFIG.type_private;\nconst PUBLIC_CHAT_USER_ID = CHAT_CONFIG.system_userid;\nconst PUBLIC_CHAT_CLEAR = CHAT_CONFIG.system_messages_keys.chat_clear;\n\nconst ROLE_MODERATOR = Meteor.settings.public.user.role_moderator;\n\nconst CONNECTION_STATUS_ONLINE = 'online';\n\nconst ScrollCollection = new Mongo.Collection(null);\n\nconst UnsentMessagesCollection = new Mongo.Collection(null);\n\n// session for closed chat list\nconst CLOSED_CHAT_LIST_KEY = 'closedChatList';\n\nconst getUser = userId => Users.findOne({ userId });\n\nconst getWelcomeProp = () => Meetings.findOne({ meetingId: Auth.meetingID },\n  { fields: { welcomeProp: 1 } });\n\nconst mapGroupMessage = (message) => {\n  const mappedMessage = {\n    id: message._id,\n    content: message.content,\n    time: message.timestamp,\n    sender: null,\n  };\n\n  if (message.sender !== SYSTEM_CHAT_TYPE) {\n    const sender = Users.findOne({ userId: message.sender },\n      {\n        fields: {\n          color: 1, role: 1, name: 1, connectionStatus: 1,\n        },\n      });\n    const {\n      color,\n      role,\n      name,\n      connectionStatus,\n    } = sender;\n\n    const mappedSender = {\n      color,\n      isModerator: role === ROLE_MODERATOR,\n      name,\n      isOnline: connectionStatus === CONNECTION_STATUS_ONLINE,\n    };\n\n    mappedMessage.sender = mappedSender;\n  }\n\n  return mappedMessage;\n};\n\nconst reduceGroupMessages = (previous, current) => {\n  const lastMessage = previous[previous.length - 1];\n  const currentMessage = current;\n  currentMessage.content = [{\n    id: current.id,\n    text: current.message,\n    time: current.timestamp,\n  }];\n  if (!lastMessage || !currentMessage.chatId === PUBLIC_GROUP_CHAT_ID) {\n    return previous.concat(currentMessage);\n  }\n  // Check if the last message is from the same user and time discrepancy\n  // between the two messages exceeds window and then group current message\n  // with the last one\n  const timeOfLastMessage = lastMessage.content[lastMessage.content.length - 1].time;\n  if (lastMessage.sender === currentMessage.sender\n    && (currentMessage.timestamp - timeOfLastMessage) <= GROUPING_MESSAGES_WINDOW) {\n    lastMessage.content.push(currentMessage.content.pop());\n    return previous;\n  }\n\n  return previous.concat(currentMessage);\n};\n\nconst reduceAndMapGroupMessages = messages => (messages\n  .reduce(reduceGroupMessages, []).map(mapGroupMessage));\n\nconst getPublicGroupMessages = () => {\n  const publicGroupMessages = GroupChatMsg.find({\n    meetingId: Auth.meetingID,\n    chatId: PUBLIC_GROUP_CHAT_ID,\n  }, { sort: ['timestamp'] }).fetch();\n  return publicGroupMessages;\n};\n\nconst getPrivateGroupMessages = () => {\n  const chatID = Session.get('idChatOpen');\n  const senderId = Auth.userID;\n\n  const privateChat = GroupChat.findOne({\n    meetingId: Auth.meetingID,\n    users: { $all: [chatID, senderId] },\n    access: PRIVATE_CHAT_TYPE,\n  });\n\n  let messages = [];\n\n  if (privateChat) {\n    const {\n      chatId,\n    } = privateChat;\n\n    messages = GroupChatMsg.find({\n      meetingId: Auth.meetingID,\n      chatId,\n    }, { sort: ['timestamp'] }).fetch();\n  }\n\n  return reduceAndMapGroupMessages(messages, []);\n};\n\nconst isChatLocked = (receiverID) => {\n  const isPublic = receiverID === PUBLIC_CHAT_ID;\n  const meeting = Meetings.findOne({ meetingId: Auth.meetingID },\n    { fields: { 'lockSettingsProps.disablePublicChat': 1, 'lockSettingsProps.disablePrivateChat': 1 } });\n  const user = Users.findOne({ meetingId: Auth.meetingID, userId: Auth.userID },\n    { fields: { locked: 1, role: 1 } });\n  const receiver = Users.findOne({ meetingId: Auth.meetingID, userId: receiverID },\n    { fields: { role: 1 } });\n  const isReceiverModerator = receiver && receiver.role === ROLE_MODERATOR;\n\n  if (meeting.lockSettingsProps !== undefined) {\n    if (user.locked && user.role !== ROLE_MODERATOR) {\n      if (isPublic) {\n        return meeting.lockSettingsProps.disablePublicChat;\n      }\n      return !isReceiverModerator\n        && meeting.lockSettingsProps.disablePrivateChat;\n    }\n  }\n\n  return false;\n};\n\nconst hasUnreadMessages = (receiverID) => {\n  const isPublic = receiverID === PUBLIC_CHAT_ID;\n  const chatType = isPublic ? PUBLIC_GROUP_CHAT_ID : receiverID;\n  return UnreadMessages.count(chatType) > 0;\n};\n\nconst lastReadMessageTime = (receiverID) => {\n  const isPublic = receiverID === PUBLIC_CHAT_ID;\n  const chatType = isPublic ? PUBLIC_GROUP_CHAT_ID : receiverID;\n\n  return UnreadMessages.get(chatType);\n};\n\nconst sendGroupMessage = (message) => {\n  const chatID = Session.get('idChatOpen');\n  const isPublicChat = chatID === PUBLIC_CHAT_ID;\n\n  let destinationChatId = PUBLIC_GROUP_CHAT_ID;\n\n  const { fullname: senderName, userID: senderUserId } = Auth;\n  const receiverId = { id: chatID };\n\n  if (!isPublicChat) {\n    const privateChat = GroupChat.findOne({ users: { $all: [chatID, senderUserId] } },\n      { fields: { chatId: 1 } });\n\n    if (privateChat) {\n      const { chatId: privateChatId } = privateChat;\n\n      destinationChatId = privateChatId;\n    }\n  }\n\n  const payload = {\n    color: '0',\n    correlationId: `${senderUserId}-${Date.now()}`,\n    sender: {\n      id: senderUserId,\n      name: senderName,\n    },\n    message,\n  };\n\n  const currentClosedChats = Storage.getItem(CLOSED_CHAT_LIST_KEY);\n\n  // Remove the chat that user send messages from the session.\n  if (_.indexOf(currentClosedChats, receiverId.id) > -1) {\n    Storage.setItem(CLOSED_CHAT_LIST_KEY, _.without(currentClosedChats, receiverId.id));\n  }\n\n  return makeCall('sendGroupChatMsg', destinationChatId, payload);\n};\n\nconst getScrollPosition = (receiverID) => {\n  const scroll = ScrollCollection.findOne({ receiver: receiverID },\n    { fields: { position: 1 } }) || { position: null };\n  return scroll.position;\n};\n\nconst updateScrollPosition = position => ScrollCollection.upsert(\n  { receiver: Session.get('idChatOpen') },\n  { $set: { position } },\n);\n\nconst updateUnreadMessage = (timestamp) => {\n  const chatID = Session.get('idChatOpen');\n  const isPublic = chatID === PUBLIC_CHAT_ID;\n  const chatType = isPublic ? PUBLIC_GROUP_CHAT_ID : chatID;\n  return UnreadMessages.update(chatType, timestamp);\n};\n\nconst clearPublicChatHistory = () => (makeCall('clearPublicChatHistory'));\n\nconst closePrivateChat = () => {\n  const chatID = Session.get('idChatOpen');\n  const currentClosedChats = Storage.getItem(CLOSED_CHAT_LIST_KEY) || [];\n\n  if (_.indexOf(currentClosedChats, chatID) < 0) {\n    currentClosedChats.push(chatID);\n\n    Storage.setItem(CLOSED_CHAT_LIST_KEY, currentClosedChats);\n  }\n};\n\n// if this private chat has been added to the list of closed ones, remove it\nconst removeFromClosedChatsSession = () => {\n  const chatID = Session.get('idChatOpen');\n  const currentClosedChats = Storage.getItem(CLOSED_CHAT_LIST_KEY);\n  if (_.indexOf(currentClosedChats, chatID) > -1) {\n    Storage.setItem(CLOSED_CHAT_LIST_KEY, _.without(currentClosedChats, chatID));\n  }\n};\n\n// We decode to prevent HTML5 escaped characters.\nconst htmlDecode = (input) => {\n  const e = document.createElement('div');\n  e.innerHTML = input;\n  const messages = Array.from(e.childNodes);\n  const message = messages.map(chatMessage => chatMessage.textContent);\n  return message.join('');\n};\n\n// Export the chat as [Hour:Min] user: message\nconst exportChat = (messageList) => {\n  const { welcomeProp } = getWelcomeProp();\n  const { loginTime } = Users.findOne({ userId: Auth.userID }, { fields: { loginTime: 1 } });\n  const { welcomeMsg } = welcomeProp;\n\n  const clearMessage = messageList.filter(message => message.message === PUBLIC_CHAT_CLEAR);\n\n  const hasClearMessage = clearMessage.length;\n\n  if (!hasClearMessage || (hasClearMessage && clearMessage[0].timestamp < loginTime)) {\n    messageList.push({\n      timestamp: loginTime,\n      message: welcomeMsg,\n      type: SYSTEM_CHAT_TYPE,\n      sender: PUBLIC_CHAT_USER_ID,\n    });\n  }\n\n  messageList.sort((a, b) => a.timestamp - b.timestamp);\n\n  return messageList.map((message) => {\n    const date = new Date(message.timestamp);\n    const hour = date.getHours().toString().padStart(2, 0);\n    const min = date.getMinutes().toString().padStart(2, 0);\n    const hourMin = `[${hour}:${min}]`;\n    if (message.type === SYSTEM_CHAT_TYPE) {\n      return `${hourMin} ${message.message}`;\n    }\n    const userName = message.sender === PUBLIC_CHAT_USER_ID\n      ? ''\n      : `${getUser(message.sender).name} :`;\n    return `${hourMin} ${userName} ${htmlDecode(message.message)}`;\n  }).join('\\n');\n};\n\nconst getAllMessages = (chatID) => {\n  const filter = {\n    sender: { $ne: Auth.userID },\n  };\n  if (chatID === PUBLIC_GROUP_CHAT_ID) {\n    filter.chatId = { $eq: chatID };\n  } else {\n    const privateChat = GroupChat.findOne({ users: { $all: [chatID, Auth.userID] } });\n\n    filter.chatId = { $ne: PUBLIC_GROUP_CHAT_ID };\n\n    if (privateChat) {\n      filter.chatId = privateChat.chatId;\n    }\n  }\n  const messages = GroupChatMsg.find(filter).fetch();\n  return messages;\n};\n\nconst maxTimestampReducer = (max, el) => ((el.timestamp > max) ? el.timestamp : max);\n\nconst maxNumberReducer = (max, el) => ((el > max) ? el : max);\n\nconst getLastMessageTimestampFromChatList = activeChats => activeChats\n  .map(chat => ((chat.userId === 'public') ? 'MAIN-PUBLIC-GROUP-CHAT' : chat.userId))\n  .map(chatId => getAllMessages(chatId).reduce(maxTimestampReducer, 0))\n  .reduce(maxNumberReducer, 0);\n\nexport default {\n  reduceAndMapGroupMessages,\n  getPublicGroupMessages,\n  getPrivateGroupMessages,\n  getUser,\n  getWelcomeProp,\n  getScrollPosition,\n  hasUnreadMessages,\n  lastReadMessageTime,\n  isChatLocked,\n  updateScrollPosition,\n  updateUnreadMessage,\n  sendGroupMessage,\n  closePrivateChat,\n  removeFromClosedChatsSession,\n  exportChat,\n  clearPublicChatHistory,\n  maxTimestampReducer,\n  getLastMessageTimestampFromChatList,\n  UnsentMessagesCollection,\n};\n"], "filenames": ["bigbluebutton-html5/imports/ui/components/chat/service.js"], "buggy_code_start_loc": [136], "buggy_code_end_loc": [139], "fixing_code_start_loc": [135], "fixing_code_end_loc": [138], "type": "CWE-668", "message": "In BigBlueButton before 2.2.7, lockSettingsProps.disablePrivateChat does not apply to already opened chats. This occurs in bigbluebutton-html5/imports/ui/components/chat/service.js.", "other": {"cve": {"id": "CVE-2020-27601", "sourceIdentifier": "cve@mitre.org", "published": "2022-09-29T03:15:14.023", "lastModified": "2022-10-03T17:31:17.320", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In BigBlueButton before 2.2.7, lockSettingsProps.disablePrivateChat does not apply to already opened chats. This occurs in bigbluebutton-html5/imports/ui/components/chat/service.js."}, {"lang": "es", "value": "En BigBlueButton versiones anteriores a 2.2.7, el archivo lockSettingsProps.disablePrivateChat no es aplicado a los chats ya abiertos. Esto ocurre en bigbluebutton-html5/imports/ui/components/chat/service.js"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 3.5, "baseSeverity": "LOW"}, "exploitabilityScore": 2.1, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-668"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:bigbluebutton:bigbluebutton:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.2.7", "matchCriteriaId": "65958351-4719-44DC-8032-96E259A03862"}]}]}], "references": [{"url": "https://github.com/bigbluebutton/bigbluebutton/commit/7dcdfb191373684bafa7b11cdd0128c9869040a1", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/bigbluebutton/bigbluebutton/compare/v2.2.6...v2.2.7", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/bigbluebutton/bigbluebutton/commit/7dcdfb191373684bafa7b11cdd0128c9869040a1"}}