{"buggy_code": ["/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#include <pjlib-util/dns.h>\n#include <pjlib-util/errno.h>\n#include <pj/assert.h>\n#include <pj/errno.h>\n#include <pj/pool.h>\n#include <pj/sock.h>\n#include <pj/string.h>\n\n\nPJ_DEF(const char *) pj_dns_get_type_name(int type)\n{\n    switch (type) {\n    case PJ_DNS_TYPE_A:     return \"A\";\n    case PJ_DNS_TYPE_AAAA:  return \"AAAA\";\n    case PJ_DNS_TYPE_SRV:   return \"SRV\";\n    case PJ_DNS_TYPE_NS:    return \"NS\";\n    case PJ_DNS_TYPE_CNAME: return \"CNAME\";\n    case PJ_DNS_TYPE_PTR:   return \"PTR\";\n    case PJ_DNS_TYPE_MX:    return \"MX\";\n    case PJ_DNS_TYPE_TXT:   return \"TXT\";\n    case PJ_DNS_TYPE_NAPTR: return \"NAPTR\";\n    }\n    return \"(Unknown)\";\n}\n\n\nstatic void write16(pj_uint8_t *p, pj_uint16_t val)\n{\n    p[0] = (pj_uint8_t)(val >> 8);\n    p[1] = (pj_uint8_t)(val & 0xFF);\n}\n\n\n/**\n * Initialize a DNS query transaction.\n */\nPJ_DEF(pj_status_t) pj_dns_make_query( void *packet,\n                                       unsigned *size,\n                                       pj_uint16_t id,\n                                       int qtype,\n                                       const pj_str_t *name)\n{\n    pj_uint8_t *p = (pj_uint8_t*)packet;\n    const char *startlabel, *endlabel, *endname;\n    pj_size_t d;\n\n    /* Sanity check */\n    PJ_ASSERT_RETURN(packet && size && qtype && name, PJ_EINVAL);\n\n    /* Calculate total number of bytes required. */\n    d = sizeof(pj_dns_hdr) + name->slen + 4;\n\n    /* Check that size is sufficient. */\n    PJ_ASSERT_RETURN(*size >= d, PJLIB_UTIL_EDNSQRYTOOSMALL);\n\n    /* Initialize header */\n    pj_assert(sizeof(pj_dns_hdr)==12);\n    pj_bzero(p, sizeof(struct pj_dns_hdr));\n    write16(p+0, id);\n    write16(p+2, (pj_uint16_t)PJ_DNS_SET_RD(1));\n    write16(p+4, (pj_uint16_t)1);\n\n    /* Initialize query */\n    p = ((pj_uint8_t*)packet)+sizeof(pj_dns_hdr);\n\n    /* Tokenize name */\n    startlabel = endlabel = name->ptr;\n    endname = name->ptr + name->slen;\n    while (endlabel != endname) {\n        while (endlabel != endname && *endlabel != '.')\n            ++endlabel;\n        *p++ = (pj_uint8_t)(endlabel - startlabel);\n        pj_memcpy(p, startlabel, endlabel-startlabel);\n        p += (endlabel-startlabel);\n        if (endlabel != endname && *endlabel == '.')\n            ++endlabel;\n        startlabel = endlabel;\n    }\n    *p++ = '\\0';\n\n    /* Set type */\n    write16(p, (pj_uint16_t)qtype);\n    p += 2;\n\n    /* Set class (IN=1) */\n    write16(p, 1);\n    p += 2;\n\n    /* Done, calculate length */\n    *size = (unsigned)(p - (pj_uint8_t*)packet);\n\n    return 0;\n}\n\n\n/* Get a name length (note: name consists of multiple labels and\n * it may contain pointers when name compression is applied) \n */\nstatic pj_status_t get_name_len(int rec_counter, const pj_uint8_t *pkt, \n                                const pj_uint8_t *start, const pj_uint8_t *max, \n                                int *parsed_len, int *name_len)\n{\n    const pj_uint8_t *p;\n    pj_status_t status;\n\n    /* Limit the number of recursion */\n    if (rec_counter > 10) {\n        /* Too many name recursion */\n        return PJLIB_UTIL_EDNSINNAMEPTR;\n    }\n\n    *name_len = *parsed_len = 0;\n    p = start;\n    while (*p) {\n        if ((*p & 0xc0) == 0xc0) {\n            /* Compression is found! */\n            int ptr_len = 0;\n            int dummy;\n            pj_uint16_t offset;\n\n            /* Get the 14bit offset */\n            pj_memcpy(&offset, p, 2);\n            offset ^= pj_htons((pj_uint16_t)(0xc0 << 8));\n            offset = pj_ntohs(offset);\n\n            /* Check that offset is valid */\n            if (offset >= max - pkt)\n                return PJLIB_UTIL_EDNSINNAMEPTR;\n\n            /* Get the name length from that offset. */\n            status = get_name_len(rec_counter+1, pkt, pkt + offset, max, \n                                  &dummy, &ptr_len);\n            if (status != PJ_SUCCESS)\n                return status;\n\n            *parsed_len += 2;\n            *name_len += ptr_len;\n\n            return PJ_SUCCESS;\n        } else {\n            unsigned label_len = *p;\n\n            /* Check that label length is valid.\n             * Each label consists of an octet length (of size 1) followed\n             * by the octet of the specified length (label_len). Then it\n             * must be followed by either another label's octet length or\n             * a zero length octet (that terminates the sequence).\n             */\n            if (p+1+label_len+1 > max)\n                return PJLIB_UTIL_EDNSINNAMEPTR;\n\n            p += (label_len + 1);\n            *parsed_len += (label_len + 1);\n\n            if (*p != 0)\n                ++label_len;\n            \n            *name_len += label_len;\n        }\n    }\n    ++p;\n    (*parsed_len)++;\n\n    return PJ_SUCCESS;\n}\n\n\n/* Parse and copy name (note: name consists of multiple labels and\n * it may contain pointers when compression is applied).\n */\nstatic pj_status_t get_name(int rec_counter, const pj_uint8_t *pkt, \n                            const pj_uint8_t *start, const pj_uint8_t *max,\n                            pj_str_t *name)\n{\n    const pj_uint8_t *p;\n    pj_status_t status;\n\n    /* Limit the number of recursion */\n    if (rec_counter > 10) {\n        /* Too many name recursion */\n        return PJLIB_UTIL_EDNSINNAMEPTR;\n    }\n\n    p = start;\n    while (*p) {\n        if ((*p & 0xc0) == 0xc0) {\n            /* Compression is found! */\n            pj_uint16_t offset;\n\n            /* Get the 14bit offset */\n            pj_memcpy(&offset, p, 2);\n            offset ^= pj_htons((pj_uint16_t)(0xc0 << 8));\n            offset = pj_ntohs(offset);\n\n            /* Check that offset is valid */\n            if (offset >= max - pkt)\n                return PJLIB_UTIL_EDNSINNAMEPTR;\n\n            /* Retrieve the name from that offset. */\n            status = get_name(rec_counter+1, pkt, pkt + offset, max, name);\n            if (status != PJ_SUCCESS)\n                return status;\n\n            return PJ_SUCCESS;\n        } else {\n            unsigned label_len = *p;\n\n            /* Check that label length is valid.\n             * Each label consists of an octet length (of size 1) followed\n             * by the octet of the specified length (label_len). Then it\n             * must be followed by either another label's octet length or\n             * a zero length octet (that terminates the sequence).\n             */\n            if (p+1+label_len+1 > max)\n                return PJLIB_UTIL_EDNSINNAMEPTR;\n\n            pj_memcpy(name->ptr + name->slen, p+1, label_len);\n            name->slen += label_len;\n\n            p += label_len + 1;\n            if (*p != 0) {\n                *(name->ptr + name->slen) = '.';\n                ++name->slen;\n            }\n        }\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/* Parse query records. */\nstatic pj_status_t parse_query(pj_dns_parsed_query *q, pj_pool_t *pool,\n                               const pj_uint8_t *pkt, const pj_uint8_t *start,\n                               const pj_uint8_t *max, int *parsed_len)\n{\n    const pj_uint8_t *p = start;\n    int name_len, name_part_len;\n    pj_status_t status;\n\n    /* Get the length of the name */\n    status = get_name_len(0, pkt, start, max, &name_part_len, &name_len);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    /* Allocate memory for the name */\n    q->name.ptr = (char*) pj_pool_alloc(pool, name_len+4);\n    q->name.slen = 0;\n\n    /* Get the name */\n    status = get_name(0, pkt, start, max, &q->name);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    p = (start + name_part_len);\n\n    /* Check the size can accomodate next few fields. */\n    if (p + 4 > max)\n        return PJLIB_UTIL_EDNSINSIZE;\n\n    /* Get the type */\n    pj_memcpy(&q->type, p, 2);\n    q->type = pj_ntohs(q->type);\n    p += 2;\n\n    /* Get the class */\n    pj_memcpy(&q->dnsclass, p, 2);\n    q->dnsclass = pj_ntohs(q->dnsclass);\n    p += 2;\n\n    *parsed_len = (int)(p - start);\n\n    return PJ_SUCCESS;\n}\n\n\n/* Parse RR records */\nstatic pj_status_t parse_rr(pj_dns_parsed_rr *rr, pj_pool_t *pool,\n                            const pj_uint8_t *pkt,\n                            const pj_uint8_t *start, const pj_uint8_t *max,\n                            int *parsed_len)\n{\n    const pj_uint8_t *p = start;\n    int name_len, name_part_len;\n    pj_status_t status;\n\n    /* Get the length of the name */\n    status = get_name_len(0, pkt, start, max, &name_part_len, &name_len);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    /* Allocate memory for the name */\n    rr->name.ptr = (char*) pj_pool_alloc(pool, name_len+4);\n    rr->name.slen = 0;\n\n    /* Get the name */\n    status = get_name(0, pkt, start, max, &rr->name);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    p = (start + name_part_len);\n\n    /* Check the size can accomodate next few fields. */\n    if (p+10 > max)\n        return PJLIB_UTIL_EDNSINSIZE;\n\n    /* Get the type */\n    pj_memcpy(&rr->type, p, 2);\n    rr->type = pj_ntohs(rr->type);\n    p += 2;\n    \n    /* Get the class */\n    pj_memcpy(&rr->dnsclass, p, 2);\n    rr->dnsclass = pj_ntohs(rr->dnsclass);\n    p += 2;\n\n    /* Class MUST be IN */\n    if (rr->dnsclass != 1) {\n        /* Class is not IN, return error only if type is known (see #1889) */\n        if (rr->type == PJ_DNS_TYPE_A     || rr->type == PJ_DNS_TYPE_AAAA  ||\n            rr->type == PJ_DNS_TYPE_CNAME || rr->type == PJ_DNS_TYPE_NS    ||\n            rr->type == PJ_DNS_TYPE_PTR   || rr->type == PJ_DNS_TYPE_SRV)\n        {\n            return PJLIB_UTIL_EDNSINCLASS;\n        }\n    }\n\n    /* Get TTL */\n    pj_memcpy(&rr->ttl, p, 4);\n    rr->ttl = pj_ntohl(rr->ttl);\n    p += 4;\n\n    /* Get rdlength */\n    pj_memcpy(&rr->rdlength, p, 2);\n    rr->rdlength = pj_ntohs(rr->rdlength);\n    p += 2;\n\n    /* Check that length is valid */\n    if (p + rr->rdlength > max)\n        return PJLIB_UTIL_EDNSINSIZE;\n\n    /* Parse some well known records */\n    if (rr->type == PJ_DNS_TYPE_A) {\n        pj_memcpy(&rr->rdata.a.ip_addr, p, 4);\n        p += 4;\n\n    } else if (rr->type == PJ_DNS_TYPE_AAAA) {\n        pj_memcpy(&rr->rdata.aaaa.ip_addr, p, 16);\n        p += 16;\n\n    } else if (rr->type == PJ_DNS_TYPE_CNAME ||\n               rr->type == PJ_DNS_TYPE_NS ||\n               rr->type == PJ_DNS_TYPE_PTR) \n    {\n\n        /* Get the length of the target name */\n        status = get_name_len(0, pkt, p, max, &name_part_len, &name_len);\n        if (status != PJ_SUCCESS)\n            return status;\n\n        /* Allocate memory for the name */\n        rr->rdata.cname.name.ptr = (char*) pj_pool_alloc(pool, name_len);\n        rr->rdata.cname.name.slen = 0;\n\n        /* Get the name */\n        status = get_name(0, pkt, p, max, &rr->rdata.cname.name);\n        if (status != PJ_SUCCESS)\n            return status;\n\n        p += name_part_len;\n\n    } else if (rr->type == PJ_DNS_TYPE_SRV) {\n\n        /* Priority */\n        pj_memcpy(&rr->rdata.srv.prio, p, 2);\n        rr->rdata.srv.prio = pj_ntohs(rr->rdata.srv.prio);\n        p += 2;\n\n        /* Weight */\n        pj_memcpy(&rr->rdata.srv.weight, p, 2);\n        rr->rdata.srv.weight = pj_ntohs(rr->rdata.srv.weight);\n        p += 2;\n\n        /* Port */\n        pj_memcpy(&rr->rdata.srv.port, p, 2);\n        rr->rdata.srv.port = pj_ntohs(rr->rdata.srv.port);\n        p += 2;\n        \n        /* Get the length of the target name */\n        status = get_name_len(0, pkt, p, max, &name_part_len, &name_len);\n        if (status != PJ_SUCCESS)\n            return status;\n\n        /* Allocate memory for the name */\n        rr->rdata.srv.target.ptr = (char*) pj_pool_alloc(pool, name_len);\n        rr->rdata.srv.target.slen = 0;\n\n        /* Get the name */\n        status = get_name(0, pkt, p, max, &rr->rdata.srv.target);\n        if (status != PJ_SUCCESS)\n            return status;\n        p += name_part_len;\n\n    } else {\n        /* Copy the raw data */\n        rr->data = pj_pool_alloc(pool, rr->rdlength);\n        pj_memcpy(rr->data, p, rr->rdlength);\n\n        p += rr->rdlength;\n    }\n\n    *parsed_len = (int)(p - start);\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Parse raw DNS packet into DNS packet structure.\n */\nPJ_DEF(pj_status_t) pj_dns_parse_packet( pj_pool_t *pool,\n                                         const void *packet,\n                                         unsigned size,\n                                         pj_dns_parsed_packet **p_res)\n{\n    pj_dns_parsed_packet *res;\n    const pj_uint8_t *start, *end;\n    pj_status_t status;\n    unsigned i;\n\n    /* Sanity checks */\n    PJ_ASSERT_RETURN(pool && packet && size && p_res, PJ_EINVAL);\n\n    /* Packet size must be at least as big as the header */\n    if (size < sizeof(pj_dns_hdr))\n        return PJLIB_UTIL_EDNSINSIZE;\n\n    /* Create the structure */\n    res = PJ_POOL_ZALLOC_T(pool, pj_dns_parsed_packet);\n\n    /* Copy the DNS header, and convert endianness to host byte order */\n    pj_memcpy(&res->hdr, packet, sizeof(pj_dns_hdr));\n    res->hdr.id       = pj_ntohs(res->hdr.id);\n    res->hdr.flags    = pj_ntohs(res->hdr.flags);\n    res->hdr.qdcount  = pj_ntohs(res->hdr.qdcount);\n    res->hdr.anscount = pj_ntohs(res->hdr.anscount);\n    res->hdr.nscount  = pj_ntohs(res->hdr.nscount);\n    res->hdr.arcount  = pj_ntohs(res->hdr.arcount);\n\n    /* Mark start and end of payload */\n    start = ((const pj_uint8_t*)packet) + sizeof(pj_dns_hdr);\n    end = ((const pj_uint8_t*)packet) + size;\n\n    /* Parse query records (if any).\n     */\n    if (res->hdr.qdcount) {\n        res->q = (pj_dns_parsed_query*)\n                 pj_pool_zalloc(pool, res->hdr.qdcount *\n                                      sizeof(pj_dns_parsed_query));\n        for (i=0; i<res->hdr.qdcount; ++i) {\n            int parsed_len = 0;\n            \n            status = parse_query(&res->q[i], pool, (const pj_uint8_t*)packet, \n                                 start, end, &parsed_len);\n            if (status != PJ_SUCCESS)\n                return status;\n\n            start += parsed_len;\n        }\n    }\n\n    /* Parse answer, if any */\n    if (res->hdr.anscount) {\n        res->ans = (pj_dns_parsed_rr*)\n                   pj_pool_zalloc(pool, res->hdr.anscount * \n                                        sizeof(pj_dns_parsed_rr));\n\n        for (i=0; i<res->hdr.anscount; ++i) {\n            int parsed_len;\n\n            status = parse_rr(&res->ans[i], pool, (const pj_uint8_t*)packet, \n                              start, end, &parsed_len);\n            if (status != PJ_SUCCESS)\n                return status;\n\n            start += parsed_len;\n        }\n    }\n\n    /* Parse authoritative NS records, if any */\n    if (res->hdr.nscount) {\n        res->ns = (pj_dns_parsed_rr*)\n                  pj_pool_zalloc(pool, res->hdr.nscount *\n                                       sizeof(pj_dns_parsed_rr));\n\n        for (i=0; i<res->hdr.nscount; ++i) {\n            int parsed_len;\n\n            status = parse_rr(&res->ns[i], pool, (const pj_uint8_t*)packet, \n                              start, end, &parsed_len);\n            if (status != PJ_SUCCESS)\n                return status;\n\n            start += parsed_len;\n        }\n    }\n\n    /* Parse additional RR answer, if any */\n    if (res->hdr.arcount) {\n        res->arr = (pj_dns_parsed_rr*)\n                   pj_pool_zalloc(pool, res->hdr.arcount *\n                                        sizeof(pj_dns_parsed_rr));\n\n        for (i=0; i<res->hdr.arcount; ++i) {\n            int parsed_len;\n\n            status = parse_rr(&res->arr[i], pool, (const pj_uint8_t*)packet, \n                              start, end, &parsed_len);\n            if (status != PJ_SUCCESS)\n                return status;\n\n            start += parsed_len;\n        }\n    }\n\n    /* Looks like everything is okay */\n    *p_res = res;\n\n    return PJ_SUCCESS;\n}\n\n\n/* Perform name compression scheme.\n * If a name is already in the nametable, when no need to duplicate\n * the string with the pool, but rather just use the pointer there.\n */\nstatic void apply_name_table( unsigned *count,\n                              pj_str_t nametable[],\n                              const pj_str_t *src,\n                              pj_pool_t *pool,\n                              pj_str_t *dst)\n{\n    unsigned i;\n\n    /* Scan strings in nametable */\n    for (i=0; i<*count; ++i) {\n        if (pj_stricmp(&nametable[i], src) == 0)\n            break;\n    }\n\n    /* If name is found in nametable, use the pointer in the nametable */\n    if (i != *count) {\n        dst->ptr = nametable[i].ptr;\n        dst->slen = nametable[i].slen;\n        return;\n    }\n\n    /* Otherwise duplicate the string, and insert new name in nametable */\n    pj_strdup(pool, dst, src);\n\n    if (*count < PJ_DNS_MAX_NAMES_IN_NAMETABLE) {\n        nametable[*count].ptr = dst->ptr;\n        nametable[*count].slen = dst->slen;\n\n        ++(*count);\n    }\n}\n\nstatic void copy_query(pj_pool_t *pool, pj_dns_parsed_query *dst,\n                       const pj_dns_parsed_query *src,\n                       unsigned *nametable_count,\n                       pj_str_t nametable[])\n{\n    pj_memcpy(dst, src, sizeof(*src));\n    apply_name_table(nametable_count, nametable, &src->name, pool, &dst->name);\n}\n\n\nstatic void copy_rr(pj_pool_t *pool, pj_dns_parsed_rr *dst,\n                    const pj_dns_parsed_rr *src,\n                    unsigned *nametable_count,\n                    pj_str_t nametable[])\n{\n    pj_memcpy(dst, src, sizeof(*src));\n    apply_name_table(nametable_count, nametable, &src->name, pool, &dst->name);\n\n    if (src->data) {\n        dst->data = pj_pool_alloc(pool, src->rdlength);\n        pj_memcpy(dst->data, src->data, src->rdlength);\n    }\n\n    if (src->type == PJ_DNS_TYPE_SRV) {\n        apply_name_table(nametable_count, nametable, &src->rdata.srv.target, \n                         pool, &dst->rdata.srv.target);\n    } else if (src->type == PJ_DNS_TYPE_A) {\n        dst->rdata.a.ip_addr.s_addr =  src->rdata.a.ip_addr.s_addr;\n    } else if (src->type == PJ_DNS_TYPE_AAAA) {\n        pj_memcpy(&dst->rdata.aaaa.ip_addr, &src->rdata.aaaa.ip_addr,\n                  sizeof(pj_in6_addr));\n    } else if (src->type == PJ_DNS_TYPE_CNAME) {\n        pj_strdup(pool, &dst->rdata.cname.name, &src->rdata.cname.name);\n    } else if (src->type == PJ_DNS_TYPE_NS) {\n        pj_strdup(pool, &dst->rdata.ns.name, &src->rdata.ns.name);\n    } else if (src->type == PJ_DNS_TYPE_PTR) {\n        pj_strdup(pool, &dst->rdata.ptr.name, &src->rdata.ptr.name);\n    }\n}\n\n/*\n * Duplicate DNS packet.\n */\nPJ_DEF(void) pj_dns_packet_dup(pj_pool_t *pool,\n                               const pj_dns_parsed_packet*p,\n                               unsigned options,\n                               pj_dns_parsed_packet **p_dst)\n{\n    pj_dns_parsed_packet *dst;\n    unsigned nametable_count = 0;\n#if PJ_DNS_MAX_NAMES_IN_NAMETABLE\n    pj_str_t nametable[PJ_DNS_MAX_NAMES_IN_NAMETABLE];\n#else\n    pj_str_t *nametable = NULL;\n#endif\n    unsigned i;\n\n    PJ_ASSERT_ON_FAIL(pool && p && p_dst, return);\n\n    /* Create packet and copy header */\n    *p_dst = dst = PJ_POOL_ZALLOC_T(pool, pj_dns_parsed_packet);\n    pj_memcpy(&dst->hdr, &p->hdr, sizeof(p->hdr));\n\n    /* Initialize section counts in the target packet to zero.\n     * If memory allocation fails during copying process, the target packet\n     * should have a correct section counts.\n     */\n    dst->hdr.qdcount = 0;\n    dst->hdr.anscount = 0;\n    dst->hdr.nscount = 0;\n    dst->hdr.arcount = 0;\n        \n\n    /* Copy query section */\n    if (p->hdr.qdcount && (options & PJ_DNS_NO_QD)==0) {\n        dst->q = (pj_dns_parsed_query*)\n                 pj_pool_alloc(pool, p->hdr.qdcount * \n                                     sizeof(pj_dns_parsed_query));\n        for (i=0; i<p->hdr.qdcount; ++i) {\n            copy_query(pool, &dst->q[i], &p->q[i], \n                       &nametable_count, nametable);\n            ++dst->hdr.qdcount;\n        }\n    }\n\n    /* Copy answer section */\n    if (p->hdr.anscount && (options & PJ_DNS_NO_ANS)==0) {\n        dst->ans = (pj_dns_parsed_rr*)\n                   pj_pool_alloc(pool, p->hdr.anscount * \n                                       sizeof(pj_dns_parsed_rr));\n        for (i=0; i<p->hdr.anscount; ++i) {\n            copy_rr(pool, &dst->ans[i], &p->ans[i],\n                    &nametable_count, nametable);\n            ++dst->hdr.anscount;\n        }\n    }\n\n    /* Copy NS section */\n    if (p->hdr.nscount && (options & PJ_DNS_NO_NS)==0) {\n        dst->ns = (pj_dns_parsed_rr*)\n                  pj_pool_alloc(pool, p->hdr.nscount * \n                                      sizeof(pj_dns_parsed_rr));\n        for (i=0; i<p->hdr.nscount; ++i) {\n            copy_rr(pool, &dst->ns[i], &p->ns[i],\n                    &nametable_count, nametable);\n            ++dst->hdr.nscount;\n        }\n    }\n\n    /* Copy additional info section */\n    if (p->hdr.arcount && (options & PJ_DNS_NO_AR)==0) {\n        dst->arr = (pj_dns_parsed_rr*)\n                   pj_pool_alloc(pool, p->hdr.arcount * \n                                       sizeof(pj_dns_parsed_rr));\n        for (i=0; i<p->hdr.arcount; ++i) {\n            copy_rr(pool, &dst->arr[i], &p->arr[i],\n                    &nametable_count, nametable);\n            ++dst->hdr.arcount;\n        }\n    }\n}\n\n\nPJ_DEF(void) pj_dns_init_srv_rr( pj_dns_parsed_rr *rec,\n                                 const pj_str_t *res_name,\n                                 unsigned dnsclass,\n                                 unsigned ttl,\n                                 unsigned prio,\n                                 unsigned weight,\n                                 unsigned port,\n                                 const pj_str_t *target)\n{\n    pj_bzero(rec, sizeof(*rec));\n    rec->name = *res_name;\n    rec->type = PJ_DNS_TYPE_SRV;\n    rec->dnsclass = (pj_uint16_t) dnsclass;\n    rec->ttl = ttl;\n    rec->rdata.srv.prio = (pj_uint16_t) prio;\n    rec->rdata.srv.weight = (pj_uint16_t) weight;\n    rec->rdata.srv.port = (pj_uint16_t) port;\n    rec->rdata.srv.target = *target;\n}\n\n\nPJ_DEF(void) pj_dns_init_cname_rr( pj_dns_parsed_rr *rec,\n                                   const pj_str_t *res_name,\n                                   unsigned dnsclass,\n                                   unsigned ttl,\n                                   const pj_str_t *name)\n{\n    pj_bzero(rec, sizeof(*rec));\n    rec->name = *res_name;\n    rec->type = PJ_DNS_TYPE_CNAME;\n    rec->dnsclass = (pj_uint16_t) dnsclass;\n    rec->ttl = ttl;\n    rec->rdata.cname.name = *name;\n}\n\n\nPJ_DEF(void) pj_dns_init_a_rr( pj_dns_parsed_rr *rec,\n                               const pj_str_t *res_name,\n                               unsigned dnsclass,\n                               unsigned ttl,\n                               const pj_in_addr *ip_addr)\n{\n    pj_bzero(rec, sizeof(*rec));\n    rec->name = *res_name;\n    rec->type = PJ_DNS_TYPE_A;\n    rec->dnsclass = (pj_uint16_t) dnsclass;\n    rec->ttl = ttl;\n    rec->rdata.a.ip_addr = *ip_addr;\n}\n\n\nPJ_DEF(void) pj_dns_init_aaaa_rr(pj_dns_parsed_rr *rec,\n                                 const pj_str_t *res_name,\n                                 unsigned dnsclass,\n                                 unsigned ttl,\n                                 const pj_in6_addr *ip_addr)\n{\n    pj_bzero(rec, sizeof(*rec));\n    rec->name = *res_name;\n    rec->type = PJ_DNS_TYPE_AAAA;\n    rec->dnsclass = (pj_uint16_t) dnsclass;\n    rec->ttl = ttl;\n    rec->rdata.aaaa.ip_addr = *ip_addr;\n}\n\n"], "fixing_code": ["/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#include <pjlib-util/dns.h>\n#include <pjlib-util/errno.h>\n#include <pj/assert.h>\n#include <pj/errno.h>\n#include <pj/pool.h>\n#include <pj/sock.h>\n#include <pj/string.h>\n\n\nPJ_DEF(const char *) pj_dns_get_type_name(int type)\n{\n    switch (type) {\n    case PJ_DNS_TYPE_A:     return \"A\";\n    case PJ_DNS_TYPE_AAAA:  return \"AAAA\";\n    case PJ_DNS_TYPE_SRV:   return \"SRV\";\n    case PJ_DNS_TYPE_NS:    return \"NS\";\n    case PJ_DNS_TYPE_CNAME: return \"CNAME\";\n    case PJ_DNS_TYPE_PTR:   return \"PTR\";\n    case PJ_DNS_TYPE_MX:    return \"MX\";\n    case PJ_DNS_TYPE_TXT:   return \"TXT\";\n    case PJ_DNS_TYPE_NAPTR: return \"NAPTR\";\n    }\n    return \"(Unknown)\";\n}\n\n\nstatic void write16(pj_uint8_t *p, pj_uint16_t val)\n{\n    p[0] = (pj_uint8_t)(val >> 8);\n    p[1] = (pj_uint8_t)(val & 0xFF);\n}\n\n\n/**\n * Initialize a DNS query transaction.\n */\nPJ_DEF(pj_status_t) pj_dns_make_query( void *packet,\n                                       unsigned *size,\n                                       pj_uint16_t id,\n                                       int qtype,\n                                       const pj_str_t *name)\n{\n    pj_uint8_t *p = (pj_uint8_t*)packet;\n    const char *startlabel, *endlabel, *endname;\n    pj_size_t d;\n\n    /* Sanity check */\n    PJ_ASSERT_RETURN(packet && size && qtype && name, PJ_EINVAL);\n\n    /* Calculate total number of bytes required. */\n    d = sizeof(pj_dns_hdr) + name->slen + 4;\n\n    /* Check that size is sufficient. */\n    PJ_ASSERT_RETURN(*size >= d, PJLIB_UTIL_EDNSQRYTOOSMALL);\n\n    /* Initialize header */\n    pj_assert(sizeof(pj_dns_hdr)==12);\n    pj_bzero(p, sizeof(struct pj_dns_hdr));\n    write16(p+0, id);\n    write16(p+2, (pj_uint16_t)PJ_DNS_SET_RD(1));\n    write16(p+4, (pj_uint16_t)1);\n\n    /* Initialize query */\n    p = ((pj_uint8_t*)packet)+sizeof(pj_dns_hdr);\n\n    /* Tokenize name */\n    startlabel = endlabel = name->ptr;\n    endname = name->ptr + name->slen;\n    while (endlabel != endname) {\n        while (endlabel != endname && *endlabel != '.')\n            ++endlabel;\n        *p++ = (pj_uint8_t)(endlabel - startlabel);\n        pj_memcpy(p, startlabel, endlabel-startlabel);\n        p += (endlabel-startlabel);\n        if (endlabel != endname && *endlabel == '.')\n            ++endlabel;\n        startlabel = endlabel;\n    }\n    *p++ = '\\0';\n\n    /* Set type */\n    write16(p, (pj_uint16_t)qtype);\n    p += 2;\n\n    /* Set class (IN=1) */\n    write16(p, 1);\n    p += 2;\n\n    /* Done, calculate length */\n    *size = (unsigned)(p - (pj_uint8_t*)packet);\n\n    return 0;\n}\n\n\n/* Get a name length (note: name consists of multiple labels and\n * it may contain pointers when name compression is applied) \n */\nstatic pj_status_t get_name_len(int rec_counter, const pj_uint8_t *pkt, \n                                const pj_uint8_t *start, const pj_uint8_t *max, \n                                int *parsed_len, int *name_len)\n{\n    const pj_uint8_t *p;\n    pj_status_t status;\n\n    /* Limit the number of recursion */\n    if (rec_counter > 10) {\n        /* Too many name recursion */\n        return PJLIB_UTIL_EDNSINNAMEPTR;\n    }\n\n    if (start >= max)\n        return PJLIB_UTIL_EDNSINNAMEPTR;\n\n    *name_len = *parsed_len = 0;\n    p = start;\n    while (*p) {\n        if ((*p & 0xc0) == 0xc0) {\n            /* Compression is found! */\n            int ptr_len = 0;\n            int dummy;\n            pj_uint16_t offset;\n\n            /* Get the 14bit offset */\n            pj_memcpy(&offset, p, 2);\n            offset ^= pj_htons((pj_uint16_t)(0xc0 << 8));\n            offset = pj_ntohs(offset);\n\n            /* Check that offset is valid */\n            if (offset >= max - pkt)\n                return PJLIB_UTIL_EDNSINNAMEPTR;\n\n            /* Get the name length from that offset. */\n            status = get_name_len(rec_counter+1, pkt, pkt + offset, max, \n                                  &dummy, &ptr_len);\n            if (status != PJ_SUCCESS)\n                return status;\n\n            *parsed_len += 2;\n            *name_len += ptr_len;\n\n            return PJ_SUCCESS;\n        } else {\n            unsigned label_len = *p;\n\n            /* Check that label length is valid.\n             * Each label consists of an octet length (of size 1) followed\n             * by the octet of the specified length (label_len). Then it\n             * must be followed by either another label's octet length or\n             * a zero length octet (that terminates the sequence).\n             */\n            if (p+1+label_len+1 > max)\n                return PJLIB_UTIL_EDNSINNAMEPTR;\n\n            p += (label_len + 1);\n            *parsed_len += (label_len + 1);\n\n            if (*p != 0)\n                ++label_len;\n            \n            *name_len += label_len;\n        }\n    }\n    ++p;\n    (*parsed_len)++;\n\n    return PJ_SUCCESS;\n}\n\n\n/* Parse and copy name (note: name consists of multiple labels and\n * it may contain pointers when compression is applied).\n */\nstatic pj_status_t get_name(int rec_counter, const pj_uint8_t *pkt, \n                            const pj_uint8_t *start, const pj_uint8_t *max,\n                            pj_str_t *name)\n{\n    const pj_uint8_t *p;\n    pj_status_t status;\n\n    /* Limit the number of recursion */\n    if (rec_counter > 10) {\n        /* Too many name recursion */\n        return PJLIB_UTIL_EDNSINNAMEPTR;\n    }\n\n    if (start >= max)\n        return PJLIB_UTIL_EDNSINNAMEPTR;\n\n    p = start;\n    while (*p) {\n        if ((*p & 0xc0) == 0xc0) {\n            /* Compression is found! */\n            pj_uint16_t offset;\n\n            /* Get the 14bit offset */\n            pj_memcpy(&offset, p, 2);\n            offset ^= pj_htons((pj_uint16_t)(0xc0 << 8));\n            offset = pj_ntohs(offset);\n\n            /* Check that offset is valid */\n            if (offset >= max - pkt)\n                return PJLIB_UTIL_EDNSINNAMEPTR;\n\n            /* Retrieve the name from that offset. */\n            status = get_name(rec_counter+1, pkt, pkt + offset, max, name);\n            if (status != PJ_SUCCESS)\n                return status;\n\n            return PJ_SUCCESS;\n        } else {\n            unsigned label_len = *p;\n\n            /* Check that label length is valid.\n             * Each label consists of an octet length (of size 1) followed\n             * by the octet of the specified length (label_len). Then it\n             * must be followed by either another label's octet length or\n             * a zero length octet (that terminates the sequence).\n             */\n            if (p+1+label_len+1 > max)\n                return PJLIB_UTIL_EDNSINNAMEPTR;\n\n            pj_memcpy(name->ptr + name->slen, p+1, label_len);\n            name->slen += label_len;\n\n            p += label_len + 1;\n            if (*p != 0) {\n                *(name->ptr + name->slen) = '.';\n                ++name->slen;\n            }\n        }\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/* Parse query records. */\nstatic pj_status_t parse_query(pj_dns_parsed_query *q, pj_pool_t *pool,\n                               const pj_uint8_t *pkt, const pj_uint8_t *start,\n                               const pj_uint8_t *max, int *parsed_len)\n{\n    const pj_uint8_t *p = start;\n    int name_len, name_part_len;\n    pj_status_t status;\n\n    /* Get the length of the name */\n    status = get_name_len(0, pkt, start, max, &name_part_len, &name_len);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    /* Allocate memory for the name */\n    q->name.ptr = (char*) pj_pool_alloc(pool, name_len+4);\n    q->name.slen = 0;\n\n    /* Get the name */\n    status = get_name(0, pkt, start, max, &q->name);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    p = (start + name_part_len);\n\n    /* Check the size can accomodate next few fields. */\n    if (p + 4 > max)\n        return PJLIB_UTIL_EDNSINSIZE;\n\n    /* Get the type */\n    pj_memcpy(&q->type, p, 2);\n    q->type = pj_ntohs(q->type);\n    p += 2;\n\n    /* Get the class */\n    pj_memcpy(&q->dnsclass, p, 2);\n    q->dnsclass = pj_ntohs(q->dnsclass);\n    p += 2;\n\n    *parsed_len = (int)(p - start);\n\n    return PJ_SUCCESS;\n}\n\n\n/* Parse RR records */\nstatic pj_status_t parse_rr(pj_dns_parsed_rr *rr, pj_pool_t *pool,\n                            const pj_uint8_t *pkt,\n                            const pj_uint8_t *start, const pj_uint8_t *max,\n                            int *parsed_len)\n{\n    const pj_uint8_t *p = start;\n    int name_len, name_part_len;\n    pj_status_t status;\n\n    /* Get the length of the name */\n    status = get_name_len(0, pkt, start, max, &name_part_len, &name_len);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    /* Allocate memory for the name */\n    rr->name.ptr = (char*) pj_pool_alloc(pool, name_len+4);\n    rr->name.slen = 0;\n\n    /* Get the name */\n    status = get_name(0, pkt, start, max, &rr->name);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    p = (start + name_part_len);\n\n    /* Check the size can accomodate next few fields. */\n    if (p+10 > max)\n        return PJLIB_UTIL_EDNSINSIZE;\n\n    /* Get the type */\n    pj_memcpy(&rr->type, p, 2);\n    rr->type = pj_ntohs(rr->type);\n    p += 2;\n    \n    /* Get the class */\n    pj_memcpy(&rr->dnsclass, p, 2);\n    rr->dnsclass = pj_ntohs(rr->dnsclass);\n    p += 2;\n\n    /* Class MUST be IN */\n    if (rr->dnsclass != 1) {\n        /* Class is not IN, return error only if type is known (see #1889) */\n        if (rr->type == PJ_DNS_TYPE_A     || rr->type == PJ_DNS_TYPE_AAAA  ||\n            rr->type == PJ_DNS_TYPE_CNAME || rr->type == PJ_DNS_TYPE_NS    ||\n            rr->type == PJ_DNS_TYPE_PTR   || rr->type == PJ_DNS_TYPE_SRV)\n        {\n            return PJLIB_UTIL_EDNSINCLASS;\n        }\n    }\n\n    /* Get TTL */\n    pj_memcpy(&rr->ttl, p, 4);\n    rr->ttl = pj_ntohl(rr->ttl);\n    p += 4;\n\n    /* Get rdlength */\n    pj_memcpy(&rr->rdlength, p, 2);\n    rr->rdlength = pj_ntohs(rr->rdlength);\n    p += 2;\n\n    /* Check that length is valid */\n    if (p + rr->rdlength > max)\n        return PJLIB_UTIL_EDNSINSIZE;\n\n    /* Parse some well known records */\n    if (rr->type == PJ_DNS_TYPE_A) {\n        if (p + 4 > max)\n            return PJLIB_UTIL_EDNSINSIZE;\n        pj_memcpy(&rr->rdata.a.ip_addr, p, 4);\n        p += 4;\n\n    } else if (rr->type == PJ_DNS_TYPE_AAAA) {\n        if (p + 16 > max)\n            return PJLIB_UTIL_EDNSINSIZE;\n        pj_memcpy(&rr->rdata.aaaa.ip_addr, p, 16);\n        p += 16;\n\n    } else if (rr->type == PJ_DNS_TYPE_CNAME ||\n               rr->type == PJ_DNS_TYPE_NS ||\n               rr->type == PJ_DNS_TYPE_PTR) \n    {\n\n        /* Get the length of the target name */\n        status = get_name_len(0, pkt, p, max, &name_part_len, &name_len);\n        if (status != PJ_SUCCESS)\n            return status;\n\n        /* Allocate memory for the name */\n        rr->rdata.cname.name.ptr = (char*) pj_pool_alloc(pool, name_len);\n        rr->rdata.cname.name.slen = 0;\n\n        /* Get the name */\n        status = get_name(0, pkt, p, max, &rr->rdata.cname.name);\n        if (status != PJ_SUCCESS)\n            return status;\n\n        p += name_part_len;\n\n    } else if (rr->type == PJ_DNS_TYPE_SRV) {\n        if (p + 6 > max)\n            return PJLIB_UTIL_EDNSINSIZE;\n\n        /* Priority */\n        pj_memcpy(&rr->rdata.srv.prio, p, 2);\n        rr->rdata.srv.prio = pj_ntohs(rr->rdata.srv.prio);\n        p += 2;\n\n        /* Weight */\n        pj_memcpy(&rr->rdata.srv.weight, p, 2);\n        rr->rdata.srv.weight = pj_ntohs(rr->rdata.srv.weight);\n        p += 2;\n\n        /* Port */\n        pj_memcpy(&rr->rdata.srv.port, p, 2);\n        rr->rdata.srv.port = pj_ntohs(rr->rdata.srv.port);\n        p += 2;\n        \n        /* Get the length of the target name */\n        status = get_name_len(0, pkt, p, max, &name_part_len, &name_len);\n        if (status != PJ_SUCCESS)\n            return status;\n\n        /* Allocate memory for the name */\n        rr->rdata.srv.target.ptr = (char*) pj_pool_alloc(pool, name_len);\n        rr->rdata.srv.target.slen = 0;\n\n        /* Get the name */\n        status = get_name(0, pkt, p, max, &rr->rdata.srv.target);\n        if (status != PJ_SUCCESS)\n            return status;\n        p += name_part_len;\n\n    } else {\n        /* Copy the raw data */\n        rr->data = pj_pool_alloc(pool, rr->rdlength);\n        pj_memcpy(rr->data, p, rr->rdlength);\n\n        p += rr->rdlength;\n    }\n\n    *parsed_len = (int)(p - start);\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Parse raw DNS packet into DNS packet structure.\n */\nPJ_DEF(pj_status_t) pj_dns_parse_packet( pj_pool_t *pool,\n                                         const void *packet,\n                                         unsigned size,\n                                         pj_dns_parsed_packet **p_res)\n{\n    pj_dns_parsed_packet *res;\n    const pj_uint8_t *start, *end;\n    pj_status_t status;\n    unsigned i;\n\n    /* Sanity checks */\n    PJ_ASSERT_RETURN(pool && packet && size && p_res, PJ_EINVAL);\n\n    /* Packet size must be at least as big as the header */\n    if (size < sizeof(pj_dns_hdr))\n        return PJLIB_UTIL_EDNSINSIZE;\n\n    /* Create the structure */\n    res = PJ_POOL_ZALLOC_T(pool, pj_dns_parsed_packet);\n\n    /* Copy the DNS header, and convert endianness to host byte order */\n    pj_memcpy(&res->hdr, packet, sizeof(pj_dns_hdr));\n    res->hdr.id       = pj_ntohs(res->hdr.id);\n    res->hdr.flags    = pj_ntohs(res->hdr.flags);\n    res->hdr.qdcount  = pj_ntohs(res->hdr.qdcount);\n    res->hdr.anscount = pj_ntohs(res->hdr.anscount);\n    res->hdr.nscount  = pj_ntohs(res->hdr.nscount);\n    res->hdr.arcount  = pj_ntohs(res->hdr.arcount);\n\n    /* Mark start and end of payload */\n    start = ((const pj_uint8_t*)packet) + sizeof(pj_dns_hdr);\n    end = ((const pj_uint8_t*)packet) + size;\n\n    /* Parse query records (if any).\n     */\n    if (res->hdr.qdcount) {\n        res->q = (pj_dns_parsed_query*)\n                 pj_pool_zalloc(pool, res->hdr.qdcount *\n                                      sizeof(pj_dns_parsed_query));\n        for (i=0; i<res->hdr.qdcount; ++i) {\n            int parsed_len = 0;\n            \n            status = parse_query(&res->q[i], pool, (const pj_uint8_t*)packet, \n                                 start, end, &parsed_len);\n            if (status != PJ_SUCCESS)\n                return status;\n\n            start += parsed_len;\n        }\n    }\n\n    /* Parse answer, if any */\n    if (res->hdr.anscount) {\n        res->ans = (pj_dns_parsed_rr*)\n                   pj_pool_zalloc(pool, res->hdr.anscount * \n                                        sizeof(pj_dns_parsed_rr));\n\n        for (i=0; i<res->hdr.anscount; ++i) {\n            int parsed_len;\n\n            status = parse_rr(&res->ans[i], pool, (const pj_uint8_t*)packet, \n                              start, end, &parsed_len);\n            if (status != PJ_SUCCESS)\n                return status;\n\n            start += parsed_len;\n        }\n    }\n\n    /* Parse authoritative NS records, if any */\n    if (res->hdr.nscount) {\n        res->ns = (pj_dns_parsed_rr*)\n                  pj_pool_zalloc(pool, res->hdr.nscount *\n                                       sizeof(pj_dns_parsed_rr));\n\n        for (i=0; i<res->hdr.nscount; ++i) {\n            int parsed_len;\n\n            status = parse_rr(&res->ns[i], pool, (const pj_uint8_t*)packet, \n                              start, end, &parsed_len);\n            if (status != PJ_SUCCESS)\n                return status;\n\n            start += parsed_len;\n        }\n    }\n\n    /* Parse additional RR answer, if any */\n    if (res->hdr.arcount) {\n        res->arr = (pj_dns_parsed_rr*)\n                   pj_pool_zalloc(pool, res->hdr.arcount *\n                                        sizeof(pj_dns_parsed_rr));\n\n        for (i=0; i<res->hdr.arcount; ++i) {\n            int parsed_len;\n\n            status = parse_rr(&res->arr[i], pool, (const pj_uint8_t*)packet, \n                              start, end, &parsed_len);\n            if (status != PJ_SUCCESS)\n                return status;\n\n            start += parsed_len;\n        }\n    }\n\n    /* Looks like everything is okay */\n    *p_res = res;\n\n    return PJ_SUCCESS;\n}\n\n\n/* Perform name compression scheme.\n * If a name is already in the nametable, when no need to duplicate\n * the string with the pool, but rather just use the pointer there.\n */\nstatic void apply_name_table( unsigned *count,\n                              pj_str_t nametable[],\n                              const pj_str_t *src,\n                              pj_pool_t *pool,\n                              pj_str_t *dst)\n{\n    unsigned i;\n\n    /* Scan strings in nametable */\n    for (i=0; i<*count; ++i) {\n        if (pj_stricmp(&nametable[i], src) == 0)\n            break;\n    }\n\n    /* If name is found in nametable, use the pointer in the nametable */\n    if (i != *count) {\n        dst->ptr = nametable[i].ptr;\n        dst->slen = nametable[i].slen;\n        return;\n    }\n\n    /* Otherwise duplicate the string, and insert new name in nametable */\n    pj_strdup(pool, dst, src);\n\n    if (*count < PJ_DNS_MAX_NAMES_IN_NAMETABLE) {\n        nametable[*count].ptr = dst->ptr;\n        nametable[*count].slen = dst->slen;\n\n        ++(*count);\n    }\n}\n\nstatic void copy_query(pj_pool_t *pool, pj_dns_parsed_query *dst,\n                       const pj_dns_parsed_query *src,\n                       unsigned *nametable_count,\n                       pj_str_t nametable[])\n{\n    pj_memcpy(dst, src, sizeof(*src));\n    apply_name_table(nametable_count, nametable, &src->name, pool, &dst->name);\n}\n\n\nstatic void copy_rr(pj_pool_t *pool, pj_dns_parsed_rr *dst,\n                    const pj_dns_parsed_rr *src,\n                    unsigned *nametable_count,\n                    pj_str_t nametable[])\n{\n    pj_memcpy(dst, src, sizeof(*src));\n    apply_name_table(nametable_count, nametable, &src->name, pool, &dst->name);\n\n    if (src->data) {\n        dst->data = pj_pool_alloc(pool, src->rdlength);\n        pj_memcpy(dst->data, src->data, src->rdlength);\n    }\n\n    if (src->type == PJ_DNS_TYPE_SRV) {\n        apply_name_table(nametable_count, nametable, &src->rdata.srv.target, \n                         pool, &dst->rdata.srv.target);\n    } else if (src->type == PJ_DNS_TYPE_A) {\n        dst->rdata.a.ip_addr.s_addr =  src->rdata.a.ip_addr.s_addr;\n    } else if (src->type == PJ_DNS_TYPE_AAAA) {\n        pj_memcpy(&dst->rdata.aaaa.ip_addr, &src->rdata.aaaa.ip_addr,\n                  sizeof(pj_in6_addr));\n    } else if (src->type == PJ_DNS_TYPE_CNAME) {\n        pj_strdup(pool, &dst->rdata.cname.name, &src->rdata.cname.name);\n    } else if (src->type == PJ_DNS_TYPE_NS) {\n        pj_strdup(pool, &dst->rdata.ns.name, &src->rdata.ns.name);\n    } else if (src->type == PJ_DNS_TYPE_PTR) {\n        pj_strdup(pool, &dst->rdata.ptr.name, &src->rdata.ptr.name);\n    }\n}\n\n/*\n * Duplicate DNS packet.\n */\nPJ_DEF(void) pj_dns_packet_dup(pj_pool_t *pool,\n                               const pj_dns_parsed_packet*p,\n                               unsigned options,\n                               pj_dns_parsed_packet **p_dst)\n{\n    pj_dns_parsed_packet *dst;\n    unsigned nametable_count = 0;\n#if PJ_DNS_MAX_NAMES_IN_NAMETABLE\n    pj_str_t nametable[PJ_DNS_MAX_NAMES_IN_NAMETABLE];\n#else\n    pj_str_t *nametable = NULL;\n#endif\n    unsigned i;\n\n    PJ_ASSERT_ON_FAIL(pool && p && p_dst, return);\n\n    /* Create packet and copy header */\n    *p_dst = dst = PJ_POOL_ZALLOC_T(pool, pj_dns_parsed_packet);\n    pj_memcpy(&dst->hdr, &p->hdr, sizeof(p->hdr));\n\n    /* Initialize section counts in the target packet to zero.\n     * If memory allocation fails during copying process, the target packet\n     * should have a correct section counts.\n     */\n    dst->hdr.qdcount = 0;\n    dst->hdr.anscount = 0;\n    dst->hdr.nscount = 0;\n    dst->hdr.arcount = 0;\n        \n\n    /* Copy query section */\n    if (p->hdr.qdcount && (options & PJ_DNS_NO_QD)==0) {\n        dst->q = (pj_dns_parsed_query*)\n                 pj_pool_alloc(pool, p->hdr.qdcount * \n                                     sizeof(pj_dns_parsed_query));\n        for (i=0; i<p->hdr.qdcount; ++i) {\n            copy_query(pool, &dst->q[i], &p->q[i], \n                       &nametable_count, nametable);\n            ++dst->hdr.qdcount;\n        }\n    }\n\n    /* Copy answer section */\n    if (p->hdr.anscount && (options & PJ_DNS_NO_ANS)==0) {\n        dst->ans = (pj_dns_parsed_rr*)\n                   pj_pool_alloc(pool, p->hdr.anscount * \n                                       sizeof(pj_dns_parsed_rr));\n        for (i=0; i<p->hdr.anscount; ++i) {\n            copy_rr(pool, &dst->ans[i], &p->ans[i],\n                    &nametable_count, nametable);\n            ++dst->hdr.anscount;\n        }\n    }\n\n    /* Copy NS section */\n    if (p->hdr.nscount && (options & PJ_DNS_NO_NS)==0) {\n        dst->ns = (pj_dns_parsed_rr*)\n                  pj_pool_alloc(pool, p->hdr.nscount * \n                                      sizeof(pj_dns_parsed_rr));\n        for (i=0; i<p->hdr.nscount; ++i) {\n            copy_rr(pool, &dst->ns[i], &p->ns[i],\n                    &nametable_count, nametable);\n            ++dst->hdr.nscount;\n        }\n    }\n\n    /* Copy additional info section */\n    if (p->hdr.arcount && (options & PJ_DNS_NO_AR)==0) {\n        dst->arr = (pj_dns_parsed_rr*)\n                   pj_pool_alloc(pool, p->hdr.arcount * \n                                       sizeof(pj_dns_parsed_rr));\n        for (i=0; i<p->hdr.arcount; ++i) {\n            copy_rr(pool, &dst->arr[i], &p->arr[i],\n                    &nametable_count, nametable);\n            ++dst->hdr.arcount;\n        }\n    }\n}\n\n\nPJ_DEF(void) pj_dns_init_srv_rr( pj_dns_parsed_rr *rec,\n                                 const pj_str_t *res_name,\n                                 unsigned dnsclass,\n                                 unsigned ttl,\n                                 unsigned prio,\n                                 unsigned weight,\n                                 unsigned port,\n                                 const pj_str_t *target)\n{\n    pj_bzero(rec, sizeof(*rec));\n    rec->name = *res_name;\n    rec->type = PJ_DNS_TYPE_SRV;\n    rec->dnsclass = (pj_uint16_t) dnsclass;\n    rec->ttl = ttl;\n    rec->rdata.srv.prio = (pj_uint16_t) prio;\n    rec->rdata.srv.weight = (pj_uint16_t) weight;\n    rec->rdata.srv.port = (pj_uint16_t) port;\n    rec->rdata.srv.target = *target;\n}\n\n\nPJ_DEF(void) pj_dns_init_cname_rr( pj_dns_parsed_rr *rec,\n                                   const pj_str_t *res_name,\n                                   unsigned dnsclass,\n                                   unsigned ttl,\n                                   const pj_str_t *name)\n{\n    pj_bzero(rec, sizeof(*rec));\n    rec->name = *res_name;\n    rec->type = PJ_DNS_TYPE_CNAME;\n    rec->dnsclass = (pj_uint16_t) dnsclass;\n    rec->ttl = ttl;\n    rec->rdata.cname.name = *name;\n}\n\n\nPJ_DEF(void) pj_dns_init_a_rr( pj_dns_parsed_rr *rec,\n                               const pj_str_t *res_name,\n                               unsigned dnsclass,\n                               unsigned ttl,\n                               const pj_in_addr *ip_addr)\n{\n    pj_bzero(rec, sizeof(*rec));\n    rec->name = *res_name;\n    rec->type = PJ_DNS_TYPE_A;\n    rec->dnsclass = (pj_uint16_t) dnsclass;\n    rec->ttl = ttl;\n    rec->rdata.a.ip_addr = *ip_addr;\n}\n\n\nPJ_DEF(void) pj_dns_init_aaaa_rr(pj_dns_parsed_rr *rec,\n                                 const pj_str_t *res_name,\n                                 unsigned dnsclass,\n                                 unsigned ttl,\n                                 const pj_in6_addr *ip_addr)\n{\n    pj_bzero(rec, sizeof(*rec));\n    rec->name = *res_name;\n    rec->type = PJ_DNS_TYPE_AAAA;\n    rec->dnsclass = (pj_uint16_t) dnsclass;\n    rec->ttl = ttl;\n    rec->rdata.aaaa.ip_addr = *ip_addr;\n}\n\n"], "filenames": ["pjlib-util/src/pjlib-util/dns.c"], "buggy_code_start_loc": [129], "buggy_code_end_loc": [390], "fixing_code_start_loc": [130], "fixing_code_end_loc": [403], "type": "CWE-120", "message": "PJSIP is a free and open source multimedia communication library written in C. A buffer overflow vulnerability in versions 2.13 and prior affects applications that use PJSIP DNS resolver. It doesn't affect PJSIP users who do not utilise PJSIP DNS resolver. This vulnerability is related to CVE-2022-24793. The difference is that this issue is in parsing the query record `parse_query()`, while the issue in CVE-2022-24793 is in `parse_rr()`. A patch is available as commit `d1c5e4d` in the `master` branch. A workaround is to disable DNS resolution in PJSIP config (by setting `nameserver_count` to zero) or use an external resolver implementation instead.", "other": {"cve": {"id": "CVE-2023-27585", "sourceIdentifier": "security-advisories@github.com", "published": "2023-03-14T17:15:19.587", "lastModified": "2023-04-19T01:15:07.200", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "PJSIP is a free and open source multimedia communication library written in C. A buffer overflow vulnerability in versions 2.13 and prior affects applications that use PJSIP DNS resolver. It doesn't affect PJSIP users who do not utilise PJSIP DNS resolver. This vulnerability is related to CVE-2022-24793. The difference is that this issue is in parsing the query record `parse_query()`, while the issue in CVE-2022-24793 is in `parse_rr()`. A patch is available as commit `d1c5e4d` in the `master` branch. A workaround is to disable DNS resolution in PJSIP config (by setting `nameserver_count` to zero) or use an external resolver implementation instead."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}, {"lang": "en", "value": "CWE-122"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:teluu:pjsip:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.13", "matchCriteriaId": "544B7D78-BF3B-4EBA-800A-E7537199615A"}]}]}], "references": [{"url": "https://github.com/pjsip/pjproject/commit/d1c5e4da5bae7f220bc30719888bb389c905c0c5", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/pjsip/pjproject/security/advisories/GHSA-p6g5-v97c-w5q4", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://github.com/pjsip/pjproject/security/advisories/GHSA-q9cp-8wcq-7pfr", "source": "security-advisories@github.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/04/msg00020.html", "source": "security-advisories@github.com"}, {"url": "https://www.pjsip.org/pjlib-util/docs/html/group__PJ__DNS__RESOLVER.htm", "source": "security-advisories@github.com", "tags": ["Product"]}]}, "github_commit_url": "https://github.com/pjsip/pjproject/commit/d1c5e4da5bae7f220bc30719888bb389c905c0c5"}}