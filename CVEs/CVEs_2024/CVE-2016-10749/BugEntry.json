{"buggy_code": ["/*\n  Copyright (c) 2009 Dave Gamble\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in\n  all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n  THE SOFTWARE.\n*/\n\n/* cJSON */\n/* JSON parser in C. */\n\n#include <string.h>\n#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"cJSON.h\"\n\nstatic const char *global_ep;\n\nconst char *cJSON_GetErrorPtr(void) {return global_ep;}\n\nstatic int cJSON_strcasecmp(const char *s1,const char *s2)\n{\n\tif (!s1) return (s1==s2)?0:1;if (!s2) return 1;\n\tfor(; tolower(*s1) == tolower(*s2); ++s1, ++s2)\tif(*s1 == 0)\treturn 0;\n\treturn tolower(*(const unsigned char *)s1) - tolower(*(const unsigned char *)s2);\n}\n\nstatic void *(*cJSON_malloc)(size_t sz) = malloc;\nstatic void (*cJSON_free)(void *ptr) = free;\n\nstatic char* cJSON_strdup(const char* str)\n{\n      size_t len;\n      char* copy;\n\n      len = strlen(str) + 1;\n      if (!(copy = (char*)cJSON_malloc(len))) return 0;\n      memcpy(copy,str,len);\n      return copy;\n}\n\nvoid cJSON_InitHooks(cJSON_Hooks* hooks)\n{\n    if (!hooks) { /* Reset hooks */\n        cJSON_malloc = malloc;\n        cJSON_free = free;\n        return;\n    }\n\n\tcJSON_malloc = (hooks->malloc_fn)?hooks->malloc_fn:malloc;\n\tcJSON_free\t = (hooks->free_fn)?hooks->free_fn:free;\n}\n\n/* Internal constructor. */\nstatic cJSON *cJSON_New_Item(void)\n{\n\tcJSON* node = (cJSON*)cJSON_malloc(sizeof(cJSON));\n\tif (node) memset(node,0,sizeof(cJSON));\n\treturn node;\n}\n\n/* Delete a cJSON structure. */\nvoid cJSON_Delete(cJSON *c)\n{\n\tcJSON *next;\n\twhile (c)\n\t{\n\t\tnext=c->next;\n\t\tif (!(c->type&cJSON_IsReference) && c->child) cJSON_Delete(c->child);\n\t\tif (!(c->type&cJSON_IsReference) && c->valuestring) cJSON_free(c->valuestring);\n\t\tif (!(c->type&cJSON_StringIsConst) && c->string) cJSON_free(c->string);\n\t\tcJSON_free(c);\n\t\tc=next;\n\t}\n}\n\n/* Parse the input text to generate a number, and populate the result into item. */\nstatic const char *parse_number(cJSON *item,const char *num)\n{\n\tdouble n=0,sign=1,scale=0;int subscale=0,signsubscale=1;\n\n\tif (*num=='-') sign=-1,num++;\t/* Has sign? */\n\tif (*num=='0') num++;\t\t\t/* is zero */\n\tif (*num>='1' && *num<='9')\tdo\tn=(n*10.0)+(*num++ -'0');\twhile (*num>='0' && *num<='9');\t/* Number? */\n\tif (*num=='.' && num[1]>='0' && num[1]<='9') {num++;\t\tdo\tn=(n*10.0)+(*num++ -'0'),scale--; while (*num>='0' && *num<='9');}\t/* Fractional part? */\n\tif (*num=='e' || *num=='E')\t\t/* Exponent? */\n\t{\tnum++;if (*num=='+') num++;\telse if (*num=='-') signsubscale=-1,num++;\t\t/* With sign? */\n\t\twhile (*num>='0' && *num<='9') subscale=(subscale*10)+(*num++ - '0');\t/* Number? */\n\t}\n\n\tn=sign*n*pow(10.0,(scale+subscale*signsubscale));\t/* number = +/- number.fraction * 10^+/- exponent */\n\t\n\titem->valuedouble=n;\n\titem->valueint=(int)n;\n\titem->type=cJSON_Number;\n\treturn num;\n}\n\nstatic int pow2gt (int x)\t{\t--x;\tx|=x>>1;\tx|=x>>2;\tx|=x>>4;\tx|=x>>8;\tx|=x>>16;\treturn x+1;\t}\n\ntypedef struct {char *buffer; int length; int offset; } printbuffer;\n\nstatic char* ensure(printbuffer *p,int needed)\n{\n\tchar *newbuffer;int newsize;\n\tif (!p || !p->buffer) return 0;\n\tneeded+=p->offset;\n\tif (needed<=p->length) return p->buffer+p->offset;\n\n\tnewsize=pow2gt(needed);\n\tnewbuffer=(char*)cJSON_malloc(newsize);\n\tif (!newbuffer) {cJSON_free(p->buffer);p->length=0,p->buffer=0;return 0;}\n\tif (newbuffer) memcpy(newbuffer,p->buffer,p->length);\n\tcJSON_free(p->buffer);\n\tp->length=newsize;\n\tp->buffer=newbuffer;\n\treturn newbuffer+p->offset;\n}\n\nstatic int update(printbuffer *p)\n{\n\tchar *str;\n\tif (!p || !p->buffer) return 0;\n\tstr=p->buffer+p->offset;\n\treturn p->offset+strlen(str);\n}\n\n/* Render the number nicely from the given item into a string. */\nstatic char *print_number(cJSON *item,printbuffer *p)\n{\n\tchar *str=0;\n\tdouble d=item->valuedouble;\n\tif (d==0)\n\t{\n\t\tif (p)\tstr=ensure(p,2);\n\t\telse\tstr=(char*)cJSON_malloc(2);\t/* special case for 0. */\n\t\tif (str) strcpy(str,\"0\");\n\t}\n\telse if (fabs(((double)item->valueint)-d)<=DBL_EPSILON && d<=INT_MAX && d>=INT_MIN)\n\t{\n\t\tif (p)\tstr=ensure(p,21);\n\t\telse\tstr=(char*)cJSON_malloc(21);\t/* 2^64+1 can be represented in 21 chars. */\n\t\tif (str)\tsprintf(str,\"%d\",item->valueint);\n\t}\n\telse\n\t{\n\t\tif (p)\tstr=ensure(p,64);\n\t\telse\tstr=(char*)cJSON_malloc(64);\t/* This is a nice tradeoff. */\n\t\tif (str)\n\t\t{\n\t\t\tif (d*0!=0)\t\t\t\t\t\t\t\t\t\t\t\t\tsprintf(str,\"null\");\t/* This checks for NaN and Infinity */\n\t\t\telse if (fabs(floor(d)-d)<=DBL_EPSILON && fabs(d)<1.0e60)\tsprintf(str,\"%.0f\",d);\n\t\t\telse if (fabs(d)<1.0e-6 || fabs(d)>1.0e9)\t\t\t\t\tsprintf(str,\"%e\",d);\n\t\t\telse\t\t\t\t\t\t\t\t\t\t\t\t\t\tsprintf(str,\"%f\",d);\n\t\t}\n\t}\n\treturn str;\n}\n\nstatic unsigned parse_hex4(const char *str)\n{\n\tunsigned h=0;\n\tif (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;\n\th=h<<4;str++;\n\tif (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;\n\th=h<<4;str++;\n\tif (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;\n\th=h<<4;str++;\n\tif (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;\n\treturn h;\n}\n\n/* Parse the input text into an unescaped cstring, and populate item. */\nstatic const unsigned char firstByteMark[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };\nstatic const char *parse_string(cJSON *item,const char *str,const char **ep)\n{\n\tconst char *ptr=str+1,*end_ptr=str+1;char *ptr2;char *out;int len=0;unsigned uc,uc2;\n\tif (*str!='\\\"') {*ep=str;return 0;}\t/* not a string! */\n\t\n\twhile (*end_ptr!='\\\"' && *end_ptr && ++len) if (*end_ptr++ == '\\\\') end_ptr++;\t/* Skip escaped quotes. */\n\t\n\tout=(char*)cJSON_malloc(len+1);\t/* This is how long we need for the string, roughly. */\n\tif (!out) return 0;\n\titem->valuestring=out; /* assign here so out will be deleted during cJSON_Delete() later */\n\titem->type=cJSON_String;\n\t\n\tptr=str+1;ptr2=out;\n\twhile (ptr < end_ptr)\n\t{\n\t\tif (*ptr!='\\\\') *ptr2++=*ptr++;\n\t\telse\n\t\t{\n\t\t\tptr++;\n\t\t\tswitch (*ptr)\n\t\t\t{\n\t\t\t\tcase 'b': *ptr2++='\\b';\tbreak;\n\t\t\t\tcase 'f': *ptr2++='\\f';\tbreak;\n\t\t\t\tcase 'n': *ptr2++='\\n';\tbreak;\n\t\t\t\tcase 'r': *ptr2++='\\r';\tbreak;\n\t\t\t\tcase 't': *ptr2++='\\t';\tbreak;\n\t\t\t\tcase 'u':\t /* transcode utf16 to utf8. */\n\t\t\t\t\tuc=parse_hex4(ptr+1);ptr+=4;\t/* get the unicode char. */\n\t\t\t\t\tif (ptr >= end_ptr) {*ep=str;return 0;}\t/* invalid */\n\t\t\t\t\t\n\t\t\t\t\tif ((uc>=0xDC00 && uc<=0xDFFF) || uc==0)    {*ep=str;return 0;}\t/* check for invalid.   */\n\t\t\t\t\t\n\t\t\t\t\tif (uc>=0xD800 && uc<=0xDBFF)\t/* UTF16 surrogate pairs.\t*/\n\t\t\t\t\t{\n\t\t\t\t\t\tif (ptr+6 > end_ptr)    {*ep=str;return 0;}\t/* invalid */\n\t\t\t\t\t\tif (ptr[1]!='\\\\' || ptr[2]!='u')    {*ep=str;return 0;}\t/* missing second-half of surrogate.    */\n\t\t\t\t\t\tuc2=parse_hex4(ptr+3);ptr+=6;\n\t\t\t\t\t\tif (uc2<0xDC00 || uc2>0xDFFF)       {*ep=str;return 0;}\t/* invalid second-half of surrogate.    */\n\t\t\t\t\t\tuc=0x10000 + (((uc&0x3FF)<<10) | (uc2&0x3FF));\n\t\t\t\t\t}\n\n\t\t\t\t\tlen=4;if (uc<0x80) len=1;else if (uc<0x800) len=2;else if (uc<0x10000) len=3; ptr2+=len;\n\t\t\t\t\t\n\t\t\t\t\tswitch (len) {\n\t\t\t\t\t\tcase 4: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;\n\t\t\t\t\t\tcase 3: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;\n\t\t\t\t\t\tcase 2: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;\n\t\t\t\t\t\tcase 1: *--ptr2 =(uc | firstByteMark[len]);\n\t\t\t\t\t}\n\t\t\t\t\tptr2+=len;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:  *ptr2++=*ptr; break;\n\t\t\t}\n\t\t\tptr++;\n\t\t}\n\t}\n\t*ptr2=0;\n\tif (*ptr=='\\\"') ptr++;\n\treturn ptr;\n}\n\n/* Render the cstring provided to an escaped version that can be printed. */\nstatic char *print_string_ptr(const char *str,printbuffer *p)\n{\n\tconst char *ptr;char *ptr2,*out;int len=0,flag=0;unsigned char token;\n\n\tif (!str)\n\t{\n\t\tif (p)\tout=ensure(p,3);\n\t\telse\tout=(char*)cJSON_malloc(3);\n\t\tif (!out) return 0;\n\t\tstrcpy(out,\"\\\"\\\"\");\n\t\treturn out;\n\t}\n\t\n\tfor (ptr=str;*ptr;ptr++) flag|=((*ptr>0 && *ptr<32)||(*ptr=='\\\"')||(*ptr=='\\\\'))?1:0;\n\tif (!flag)\n\t{\n\t\tlen=ptr-str;\n\t\tif (p) out=ensure(p,len+3);\n\t\telse\t\tout=(char*)cJSON_malloc(len+3);\n\t\tif (!out) return 0;\n\t\tptr2=out;*ptr2++='\\\"';\n\t\tstrcpy(ptr2,str);\n\t\tptr2[len]='\\\"';\n\t\tptr2[len+1]=0;\n\t\treturn out;\n\t}\n\t\n\tptr=str;while ((token=*ptr) && ++len) {if (strchr(\"\\\"\\\\\\b\\f\\n\\r\\t\",token)) len++; else if (token<32) len+=5;ptr++;}\n\t\n\tif (p)\tout=ensure(p,len+3);\n\telse\tout=(char*)cJSON_malloc(len+3);\n\tif (!out) return 0;\n\n\tptr2=out;ptr=str;\n\t*ptr2++='\\\"';\n\twhile (*ptr)\n\t{\n\t\tif ((unsigned char)*ptr>31 && *ptr!='\\\"' && *ptr!='\\\\') *ptr2++=*ptr++;\n\t\telse\n\t\t{\n\t\t\t*ptr2++='\\\\';\n\t\t\tswitch (token=*ptr++)\n\t\t\t{\n\t\t\t\tcase '\\\\':\t*ptr2++='\\\\';\tbreak;\n\t\t\t\tcase '\\\"':\t*ptr2++='\\\"';\tbreak;\n\t\t\t\tcase '\\b':\t*ptr2++='b';\tbreak;\n\t\t\t\tcase '\\f':\t*ptr2++='f';\tbreak;\n\t\t\t\tcase '\\n':\t*ptr2++='n';\tbreak;\n\t\t\t\tcase '\\r':\t*ptr2++='r';\tbreak;\n\t\t\t\tcase '\\t':\t*ptr2++='t';\tbreak;\n\t\t\t\tdefault: sprintf(ptr2,\"u%04x\",token);ptr2+=5;\tbreak;\t/* escape and print */\n\t\t\t}\n\t\t}\n\t}\n\t*ptr2++='\\\"';*ptr2++=0;\n\treturn out;\n}\n/* Invote print_string_ptr (which is useful) on an item. */\nstatic char *print_string(cJSON *item,printbuffer *p)\t{return print_string_ptr(item->valuestring,p);}\n\n/* Predeclare these prototypes. */\nstatic const char *parse_value(cJSON *item,const char *value,const char **ep);\nstatic char *print_value(cJSON *item,int depth,int fmt,printbuffer *p);\nstatic const char *parse_array(cJSON *item,const char *value,const char **ep);\nstatic char *print_array(cJSON *item,int depth,int fmt,printbuffer *p);\nstatic const char *parse_object(cJSON *item,const char *value,const char **ep);\nstatic char *print_object(cJSON *item,int depth,int fmt,printbuffer *p);\n\n/* Utility to jump whitespace and cr/lf */\nstatic const char *skip(const char *in) {while (in && *in && (unsigned char)*in<=32) in++; return in;}\n\n/* Parse an object - create a new root, and populate. */\ncJSON *cJSON_ParseWithOpts(const char *value,const char **return_parse_end,int require_null_terminated)\n{\n\tconst char *end=0,**ep=return_parse_end?return_parse_end:&global_ep;\n\tcJSON *c=cJSON_New_Item();\n\t*ep=0;\n\tif (!c) return 0;       /* memory fail */\n\n\tend=parse_value(c,skip(value),ep);\n\tif (!end)\t{cJSON_Delete(c);return 0;}\t/* parse failure. ep is set. */\n\n\t/* if we require null-terminated JSON without appended garbage, skip and then check for a null terminator */\n\tif (require_null_terminated) {end=skip(end);if (*end) {cJSON_Delete(c);*ep=end;return 0;}}\n\tif (return_parse_end) *return_parse_end=end;\n\treturn c;\n}\n/* Default options for cJSON_Parse */\ncJSON *cJSON_Parse(const char *value) {return cJSON_ParseWithOpts(value,0,0);}\n\n/* Render a cJSON item/entity/structure to text. */\nchar *cJSON_Print(cJSON *item)\t\t\t\t{return print_value(item,0,1,0);}\nchar *cJSON_PrintUnformatted(cJSON *item)\t{return print_value(item,0,0,0);}\n\nchar *cJSON_PrintBuffered(cJSON *item,int prebuffer,int fmt)\n{\n\tprintbuffer p;\n\tp.buffer=(char*)cJSON_malloc(prebuffer);\n\tp.length=prebuffer;\n\tp.offset=0;\n\treturn print_value(item,0,fmt,&p);\n}\n\n\n/* Parser core - when encountering text, process appropriately. */\nstatic const char *parse_value(cJSON *item,const char *value,const char **ep)\n{\n\tif (!value)\t\t\t\t\t\treturn 0;\t/* Fail on null. */\n\tif (!strncmp(value,\"null\",4))\t{ item->type=cJSON_NULL;  return value+4; }\n\tif (!strncmp(value,\"false\",5))\t{ item->type=cJSON_False; return value+5; }\n\tif (!strncmp(value,\"true\",4))\t{ item->type=cJSON_True; item->valueint=1;\treturn value+4; }\n\tif (*value=='\\\"')\t\t\t\t{ return parse_string(item,value,ep); }\n\tif (*value=='-' || (*value>='0' && *value<='9'))\t{ return parse_number(item,value); }\n\tif (*value=='[')\t\t\t\t{ return parse_array(item,value,ep); }\n\tif (*value=='{')\t\t\t\t{ return parse_object(item,value,ep); }\n\n\t*ep=value;return 0;\t/* failure. */\n}\n\n/* Render a value to text. */\nstatic char *print_value(cJSON *item,int depth,int fmt,printbuffer *p)\n{\n\tchar *out=0;\n\tif (!item) return 0;\n\tif (p)\n\t{\n\t\tswitch ((item->type)&255)\n\t\t{\n\t\t\tcase cJSON_NULL:\t{out=ensure(p,5);\tif (out) strcpy(out,\"null\");\tbreak;}\n\t\t\tcase cJSON_False:\t{out=ensure(p,6);\tif (out) strcpy(out,\"false\");\tbreak;}\n\t\t\tcase cJSON_True:\t{out=ensure(p,5);\tif (out) strcpy(out,\"true\");\tbreak;}\n\t\t\tcase cJSON_Number:\tout=print_number(item,p);break;\n\t\t\tcase cJSON_String:\tout=print_string(item,p);break;\n\t\t\tcase cJSON_Array:\tout=print_array(item,depth,fmt,p);break;\n\t\t\tcase cJSON_Object:\tout=print_object(item,depth,fmt,p);break;\n\t\t}\n\t}\n\telse\n\t{\n\t\tswitch ((item->type)&255)\n\t\t{\n\t\t\tcase cJSON_NULL:\tout=cJSON_strdup(\"null\");\tbreak;\n\t\t\tcase cJSON_False:\tout=cJSON_strdup(\"false\");break;\n\t\t\tcase cJSON_True:\tout=cJSON_strdup(\"true\"); break;\n\t\t\tcase cJSON_Number:\tout=print_number(item,0);break;\n\t\t\tcase cJSON_String:\tout=print_string(item,0);break;\n\t\t\tcase cJSON_Array:\tout=print_array(item,depth,fmt,0);break;\n\t\t\tcase cJSON_Object:\tout=print_object(item,depth,fmt,0);break;\n\t\t}\n\t}\n\treturn out;\n}\n\n/* Build an array from input text. */\nstatic const char *parse_array(cJSON *item,const char *value,const char **ep)\n{\n\tcJSON *child;\n\tif (*value!='[')\t{*ep=value;return 0;}\t/* not an array! */\n\n\titem->type=cJSON_Array;\n\tvalue=skip(value+1);\n\tif (*value==']') return value+1;\t/* empty array. */\n\n\titem->child=child=cJSON_New_Item();\n\tif (!item->child) return 0;\t\t /* memory fail */\n\tvalue=skip(parse_value(child,skip(value),ep));\t/* skip any spacing, get the value. */\n\tif (!value) return 0;\n\n\twhile (*value==',')\n\t{\n\t\tcJSON *new_item;\n\t\tif (!(new_item=cJSON_New_Item())) return 0; \t/* memory fail */\n\t\tchild->next=new_item;new_item->prev=child;child=new_item;\n\t\tvalue=skip(parse_value(child,skip(value+1),ep));\n\t\tif (!value) return 0;\t/* memory fail */\n\t}\n\n\tif (*value==']') return value+1;\t/* end of array */\n\t*ep=value;return 0;\t/* malformed. */\n}\n\n/* Render an array to text */\nstatic char *print_array(cJSON *item,int depth,int fmt,printbuffer *p)\n{\n\tchar **entries;\n\tchar *out=0,*ptr,*ret;int len=5;\n\tcJSON *child=item->child;\n\tint numentries=0,i=0,fail=0;\n\tsize_t tmplen=0;\n\t\n\t/* How many entries in the array? */\n\twhile (child) numentries++,child=child->next;\n\t/* Explicitly handle numentries==0 */\n\tif (!numentries)\n\t{\n\t\tif (p)\tout=ensure(p,3);\n\t\telse\tout=(char*)cJSON_malloc(3);\n\t\tif (out) strcpy(out,\"[]\");\n\t\treturn out;\n\t}\n\n\tif (p)\n\t{\n\t\t/* Compose the output array. */\n\t\ti=p->offset;\n\t\tptr=ensure(p,1);if (!ptr) return 0;\t*ptr='[';\tp->offset++;\n\t\tchild=item->child;\n\t\twhile (child && !fail)\n\t\t{\n\t\t\tprint_value(child,depth+1,fmt,p);\n\t\t\tp->offset=update(p);\n\t\t\tif (child->next) {len=fmt?2:1;ptr=ensure(p,len+1);if (!ptr) return 0;*ptr++=',';if(fmt)*ptr++=' ';*ptr=0;p->offset+=len;}\n\t\t\tchild=child->next;\n\t\t}\n\t\tptr=ensure(p,2);if (!ptr) return 0;\t*ptr++=']';*ptr=0;\n\t\tout=(p->buffer)+i;\n\t}\n\telse\n\t{\n\t\t/* Allocate an array to hold the values for each */\n\t\tentries=(char**)cJSON_malloc(numentries*sizeof(char*));\n\t\tif (!entries) return 0;\n\t\tmemset(entries,0,numentries*sizeof(char*));\n\t\t/* Retrieve all the results: */\n\t\tchild=item->child;\n\t\twhile (child && !fail)\n\t\t{\n\t\t\tret=print_value(child,depth+1,fmt,0);\n\t\t\tentries[i++]=ret;\n\t\t\tif (ret) len+=strlen(ret)+2+(fmt?1:0); else fail=1;\n\t\t\tchild=child->next;\n\t\t}\n\t\t\n\t\t/* If we didn't fail, try to malloc the output string */\n\t\tif (!fail)\tout=(char*)cJSON_malloc(len);\n\t\t/* If that fails, we fail. */\n\t\tif (!out) fail=1;\n\n\t\t/* Handle failure. */\n\t\tif (fail)\n\t\t{\n\t\t\tfor (i=0;i<numentries;i++) if (entries[i]) cJSON_free(entries[i]);\n\t\t\tcJSON_free(entries);\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\t/* Compose the output array. */\n\t\t*out='[';\n\t\tptr=out+1;*ptr=0;\n\t\tfor (i=0;i<numentries;i++)\n\t\t{\n\t\t\ttmplen=strlen(entries[i]);memcpy(ptr,entries[i],tmplen);ptr+=tmplen;\n\t\t\tif (i!=numentries-1) {*ptr++=',';if(fmt)*ptr++=' ';*ptr=0;}\n\t\t\tcJSON_free(entries[i]);\n\t\t}\n\t\tcJSON_free(entries);\n\t\t*ptr++=']';*ptr++=0;\n\t}\n\treturn out;\t\n}\n\n/* Build an object from the text. */\nstatic const char *parse_object(cJSON *item,const char *value,const char **ep)\n{\n\tcJSON *child;\n\tif (*value!='{')\t{*ep=value;return 0;}\t/* not an object! */\n\t\n\titem->type=cJSON_Object;\n\tvalue=skip(value+1);\n\tif (*value=='}') return value+1;\t/* empty array. */\n\t\n\titem->child=child=cJSON_New_Item();\n\tif (!item->child) return 0;\n\tvalue=skip(parse_string(child,skip(value),ep));\n\tif (!value) return 0;\n\tchild->string=child->valuestring;child->valuestring=0;\n\tif (*value!=':') {*ep=value;return 0;}\t/* fail! */\n\tvalue=skip(parse_value(child,skip(value+1),ep));\t/* skip any spacing, get the value. */\n\tif (!value) return 0;\n\t\n\twhile (*value==',')\n\t{\n\t\tcJSON *new_item;\n\t\tif (!(new_item=cJSON_New_Item()))\treturn 0; /* memory fail */\n\t\tchild->next=new_item;new_item->prev=child;child=new_item;\n\t\tvalue=skip(parse_string(child,skip(value+1),ep));\n\t\tif (!value) return 0;\n\t\tchild->string=child->valuestring;child->valuestring=0;\n\t\tif (*value!=':') {*ep=value;return 0;}\t/* fail! */\n\t\tvalue=skip(parse_value(child,skip(value+1),ep));\t/* skip any spacing, get the value. */\n\t\tif (!value) return 0;\n\t}\n\t\n\tif (*value=='}') return value+1;\t/* end of array */\n\t*ep=value;return 0;\t/* malformed. */\n}\n\n/* Render an object to text. */\nstatic char *print_object(cJSON *item,int depth,int fmt,printbuffer *p)\n{\n\tchar **entries=0,**names=0;\n\tchar *out=0,*ptr,*ret,*str;int len=7,i=0,j;\n\tcJSON *child=item->child;\n\tint numentries=0,fail=0;\n\tsize_t tmplen=0;\n\t/* Count the number of entries. */\n\twhile (child) numentries++,child=child->next;\n\t/* Explicitly handle empty object case */\n\tif (!numentries)\n\t{\n\t\tif (p) out=ensure(p,fmt?depth+4:3);\n\t\telse\tout=(char*)cJSON_malloc(fmt?depth+4:3);\n\t\tif (!out)\treturn 0;\n\t\tptr=out;*ptr++='{';\n\t\tif (fmt) {*ptr++='\\n';for (i=0;i<depth;i++) *ptr++='\\t';}\n\t\t*ptr++='}';*ptr++=0;\n\t\treturn out;\n\t}\n\tif (p)\n\t{\n\t\t/* Compose the output: */\n\t\ti=p->offset;\n\t\tlen=fmt?2:1;\tptr=ensure(p,len+1);\tif (!ptr) return 0;\n\t\t*ptr++='{';\tif (fmt) *ptr++='\\n';\t*ptr=0;\tp->offset+=len;\n\t\tchild=item->child;depth++;\n\t\twhile (child)\n\t\t{\n\t\t\tif (fmt)\n\t\t\t{\n\t\t\t\tptr=ensure(p,depth);\tif (!ptr) return 0;\n\t\t\t\tfor (j=0;j<depth;j++) *ptr++='\\t';\n\t\t\t\tp->offset+=depth;\n\t\t\t}\n\t\t\tprint_string_ptr(child->string,p);\n\t\t\tp->offset=update(p);\n\t\t\t\n\t\t\tlen=fmt?2:1;\n\t\t\tptr=ensure(p,len);\tif (!ptr) return 0;\n\t\t\t*ptr++=':';if (fmt) *ptr++='\\t';\n\t\t\tp->offset+=len;\n\t\t\t\n\t\t\tprint_value(child,depth,fmt,p);\n\t\t\tp->offset=update(p);\n\n\t\t\tlen=(fmt?1:0)+(child->next?1:0);\n\t\t\tptr=ensure(p,len+1); if (!ptr) return 0;\n\t\t\tif (child->next) *ptr++=',';\n\t\t\tif (fmt) *ptr++='\\n';*ptr=0;\n\t\t\tp->offset+=len;\n\t\t\tchild=child->next;\n\t\t}\n\t\tptr=ensure(p,fmt?(depth+1):2);\t if (!ptr) return 0;\n\t\tif (fmt)\tfor (i=0;i<depth-1;i++) *ptr++='\\t';\n\t\t*ptr++='}';*ptr=0;\n\t\tout=(p->buffer)+i;\n\t}\n\telse\n\t{\n\t\t/* Allocate space for the names and the objects */\n\t\tentries=(char**)cJSON_malloc(numentries*sizeof(char*));\n\t\tif (!entries) return 0;\n\t\tnames=(char**)cJSON_malloc(numentries*sizeof(char*));\n\t\tif (!names) {cJSON_free(entries);return 0;}\n\t\tmemset(entries,0,sizeof(char*)*numentries);\n\t\tmemset(names,0,sizeof(char*)*numentries);\n\n\t\t/* Collect all the results into our arrays: */\n\t\tchild=item->child;depth++;if (fmt) len+=depth;\n\t\twhile (child && !fail)\n\t\t{\n\t\t\tnames[i]=str=print_string_ptr(child->string,0);\n\t\t\tentries[i++]=ret=print_value(child,depth,fmt,0);\n\t\t\tif (str && ret) len+=strlen(ret)+strlen(str)+2+(fmt?2+depth:0); else fail=1;\n\t\t\tchild=child->next;\n\t\t}\n\t\t\n\t\t/* Try to allocate the output string */\n\t\tif (!fail)\tout=(char*)cJSON_malloc(len);\n\t\tif (!out) fail=1;\n\n\t\t/* Handle failure */\n\t\tif (fail)\n\t\t{\n\t\t\tfor (i=0;i<numentries;i++) {if (names[i]) cJSON_free(names[i]);if (entries[i]) cJSON_free(entries[i]);}\n\t\t\tcJSON_free(names);cJSON_free(entries);\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\t/* Compose the output: */\n\t\t*out='{';ptr=out+1;if (fmt)*ptr++='\\n';*ptr=0;\n\t\tfor (i=0;i<numentries;i++)\n\t\t{\n\t\t\tif (fmt) for (j=0;j<depth;j++) *ptr++='\\t';\n\t\t\ttmplen=strlen(names[i]);memcpy(ptr,names[i],tmplen);ptr+=tmplen;\n\t\t\t*ptr++=':';if (fmt) *ptr++='\\t';\n\t\t\tstrcpy(ptr,entries[i]);ptr+=strlen(entries[i]);\n\t\t\tif (i!=numentries-1) *ptr++=',';\n\t\t\tif (fmt) *ptr++='\\n';*ptr=0;\n\t\t\tcJSON_free(names[i]);cJSON_free(entries[i]);\n\t\t}\n\t\t\n\t\tcJSON_free(names);cJSON_free(entries);\n\t\tif (fmt) for (i=0;i<depth-1;i++) *ptr++='\\t';\n\t\t*ptr++='}';*ptr++=0;\n\t}\n\treturn out;\t\n}\n\n/* Get Array size/item / object item. */\nint    cJSON_GetArraySize(cJSON *array)\t\t\t\t\t\t\t{cJSON *c=array->child;int i=0;while(c)i++,c=c->next;return i;}\ncJSON *cJSON_GetArrayItem(cJSON *array,int item)\t\t\t\t{cJSON *c=array?array->child:0;while (c && item>0) item--,c=c->next; return c;}\ncJSON *cJSON_GetObjectItem(cJSON *object,const char *string)\t{cJSON *c=object?object->child:0;while (c && cJSON_strcasecmp(c->string,string)) c=c->next; return c;}\nint cJSON_HasObjectItem(cJSON *object,const char *string)\t\t{return cJSON_GetObjectItem(object,string)?1:0;}\n\n/* Utility for array list handling. */\nstatic void suffix_object(cJSON *prev,cJSON *item) {prev->next=item;item->prev=prev;}\n/* Utility for handling references. */\nstatic cJSON *create_reference(cJSON *item) {cJSON *ref=cJSON_New_Item();if (!ref) return 0;memcpy(ref,item,sizeof(cJSON));ref->string=0;ref->type|=cJSON_IsReference;ref->next=ref->prev=0;return ref;}\n\n/* Add item to array/object. */\nvoid   cJSON_AddItemToArray(cJSON *array, cJSON *item)\t\t\t\t\t\t{cJSON *c=array->child;if (!item) return; if (!c) {array->child=item;} else {while (c && c->next) c=c->next; suffix_object(c,item);}}\nvoid   cJSON_AddItemToObject(cJSON *object,const char *string,cJSON *item)\t{if (!item) return; if (item->string) cJSON_free(item->string);item->string=cJSON_strdup(string);cJSON_AddItemToArray(object,item);}\nvoid   cJSON_AddItemToObjectCS(cJSON *object,const char *string,cJSON *item)\t{if (!item) return; if (!(item->type&cJSON_StringIsConst) && item->string) cJSON_free(item->string);item->string=(char*)string;item->type|=cJSON_StringIsConst;cJSON_AddItemToArray(object,item);}\nvoid\tcJSON_AddItemReferenceToArray(cJSON *array, cJSON *item)\t\t\t\t\t\t{cJSON_AddItemToArray(array,create_reference(item));}\nvoid\tcJSON_AddItemReferenceToObject(cJSON *object,const char *string,cJSON *item)\t{cJSON_AddItemToObject(object,string,create_reference(item));}\n\ncJSON *cJSON_DetachItemFromArray(cJSON *array,int which)\t\t\t{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) return 0;\n\tif (c->prev) c->prev->next=c->next;if (c->next) c->next->prev=c->prev;if (c==array->child) array->child=c->next;c->prev=c->next=0;return c;}\nvoid   cJSON_DeleteItemFromArray(cJSON *array,int which)\t\t\t{cJSON_Delete(cJSON_DetachItemFromArray(array,which));}\ncJSON *cJSON_DetachItemFromObject(cJSON *object,const char *string) {int i=0;cJSON *c=object->child;while (c && cJSON_strcasecmp(c->string,string)) i++,c=c->next;if (c) return cJSON_DetachItemFromArray(object,i);return 0;}\nvoid   cJSON_DeleteItemFromObject(cJSON *object,const char *string) {cJSON_Delete(cJSON_DetachItemFromObject(object,string));}\n\n/* Replace array/object items with new ones. */\nvoid   cJSON_InsertItemInArray(cJSON *array,int which,cJSON *newitem)\t\t{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) {cJSON_AddItemToArray(array,newitem);return;}\n\tnewitem->next=c;newitem->prev=c->prev;c->prev=newitem;if (c==array->child) array->child=newitem; else newitem->prev->next=newitem;}\nvoid   cJSON_ReplaceItemInArray(cJSON *array,int which,cJSON *newitem)\t\t{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) return;\n\tnewitem->next=c->next;newitem->prev=c->prev;if (newitem->next) newitem->next->prev=newitem;\n\tif (c==array->child) array->child=newitem; else newitem->prev->next=newitem;c->next=c->prev=0;cJSON_Delete(c);}\nvoid   cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem){int i=0;cJSON *c=object->child;while(c && cJSON_strcasecmp(c->string,string))i++,c=c->next;if(c){newitem->string=cJSON_strdup(string);cJSON_ReplaceItemInArray(object,i,newitem);}}\n\n/* Create basic types: */\ncJSON *cJSON_CreateNull(void)\t\t\t\t\t{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_NULL;return item;}\ncJSON *cJSON_CreateTrue(void)\t\t\t\t\t{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_True;return item;}\ncJSON *cJSON_CreateFalse(void)\t\t\t\t\t{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_False;return item;}\ncJSON *cJSON_CreateBool(int b)\t\t\t\t\t{cJSON *item=cJSON_New_Item();if(item)item->type=b?cJSON_True:cJSON_False;return item;}\ncJSON *cJSON_CreateNumber(double num)\t\t\t{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_Number;item->valuedouble=num;item->valueint=(int)num;}return item;}\ncJSON *cJSON_CreateString(const char *string)\t{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_String;item->valuestring=cJSON_strdup(string);if(!item->valuestring){cJSON_Delete(item);return 0;}}return item;}\ncJSON *cJSON_CreateArray(void)\t\t\t\t\t{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Array;return item;}\ncJSON *cJSON_CreateObject(void)\t\t\t\t\t{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Object;return item;}\n\n/* Create Arrays: */\ncJSON *cJSON_CreateIntArray(const int *numbers,int count)\t\t{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!n){cJSON_Delete(a);return 0;}if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}\ncJSON *cJSON_CreateFloatArray(const float *numbers,int count)\t{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!n){cJSON_Delete(a);return 0;}if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}\ncJSON *cJSON_CreateDoubleArray(const double *numbers,int count)\t{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!n){cJSON_Delete(a);return 0;}if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}\ncJSON *cJSON_CreateStringArray(const char **strings,int count)\t{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateString(strings[i]);if(!n){cJSON_Delete(a);return 0;}if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}\n\n/* Duplication */\ncJSON *cJSON_Duplicate(cJSON *item,int recurse)\n{\n\tcJSON *newitem,*cptr,*nptr=0,*newchild;\n\t/* Bail on bad ptr */\n\tif (!item) return 0;\n\t/* Create new item */\n\tnewitem=cJSON_New_Item();\n\tif (!newitem) return 0;\n\t/* Copy over all vars */\n\tnewitem->type=item->type&(~cJSON_IsReference),newitem->valueint=item->valueint,newitem->valuedouble=item->valuedouble;\n\tif (item->valuestring)\t{newitem->valuestring=cJSON_strdup(item->valuestring);\tif (!newitem->valuestring)\t{cJSON_Delete(newitem);return 0;}}\n\tif (item->string)\t\t{newitem->string=cJSON_strdup(item->string);\t\t\tif (!newitem->string)\t\t{cJSON_Delete(newitem);return 0;}}\n\t/* If non-recursive, then we're done! */\n\tif (!recurse) return newitem;\n\t/* Walk the ->next chain for the child. */\n\tcptr=item->child;\n\twhile (cptr)\n\t{\n\t\tnewchild=cJSON_Duplicate(cptr,1);\t\t/* Duplicate (with recurse) each item in the ->next chain */\n\t\tif (!newchild) {cJSON_Delete(newitem);return 0;}\n\t\tif (nptr)\t{nptr->next=newchild,newchild->prev=nptr;nptr=newchild;}\t/* If newitem->child already set, then crosswire ->prev and ->next and move on */\n\t\telse\t\t{newitem->child=newchild;nptr=newchild;}\t\t\t\t\t/* Set newitem->child and move to it */\n\t\tcptr=cptr->next;\n\t}\n\treturn newitem;\n}\n\nvoid cJSON_Minify(char *json)\n{\n\tchar *into=json;\n\twhile (*json)\n\t{\n\t\tif (*json==' ') json++;\n\t\telse if (*json=='\\t') json++;\t/* Whitespace characters. */\n\t\telse if (*json=='\\r') json++;\n\t\telse if (*json=='\\n') json++;\n\t\telse if (*json=='/' && json[1]=='/')  while (*json && *json!='\\n') json++;\t/* double-slash comments, to end of line. */\n\t\telse if (*json=='/' && json[1]=='*') {while (*json && !(*json=='*' && json[1]=='/')) json++;json+=2;}\t/* multiline comments. */\n\t\telse if (*json=='\\\"'){*into++=*json++;while (*json && *json!='\\\"'){if (*json=='\\\\') *into++=*json++;*into++=*json++;}*into++=*json++;} /* string literals, which are \\\" sensitive. */\n\t\telse *into++=*json++;\t\t\t/* All other characters. */\n\t}\n\t*into=0;\t/* and null-terminate. */\n}\n"], "fixing_code": ["/*\n  Copyright (c) 2009 Dave Gamble\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in\n  all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n  THE SOFTWARE.\n*/\n\n/* cJSON */\n/* JSON parser in C. */\n\n#include <string.h>\n#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"cJSON.h\"\n\nstatic const char *global_ep;\n\nconst char *cJSON_GetErrorPtr(void) {return global_ep;}\n\nstatic int cJSON_strcasecmp(const char *s1,const char *s2)\n{\n\tif (!s1) return (s1==s2)?0:1;if (!s2) return 1;\n\tfor(; tolower(*s1) == tolower(*s2); ++s1, ++s2)\tif(*s1 == 0)\treturn 0;\n\treturn tolower(*(const unsigned char *)s1) - tolower(*(const unsigned char *)s2);\n}\n\nstatic void *(*cJSON_malloc)(size_t sz) = malloc;\nstatic void (*cJSON_free)(void *ptr) = free;\n\nstatic char* cJSON_strdup(const char* str)\n{\n      size_t len;\n      char* copy;\n\n      len = strlen(str) + 1;\n      if (!(copy = (char*)cJSON_malloc(len))) return 0;\n      memcpy(copy,str,len);\n      return copy;\n}\n\nvoid cJSON_InitHooks(cJSON_Hooks* hooks)\n{\n    if (!hooks) { /* Reset hooks */\n        cJSON_malloc = malloc;\n        cJSON_free = free;\n        return;\n    }\n\n\tcJSON_malloc = (hooks->malloc_fn)?hooks->malloc_fn:malloc;\n\tcJSON_free\t = (hooks->free_fn)?hooks->free_fn:free;\n}\n\n/* Internal constructor. */\nstatic cJSON *cJSON_New_Item(void)\n{\n\tcJSON* node = (cJSON*)cJSON_malloc(sizeof(cJSON));\n\tif (node) memset(node,0,sizeof(cJSON));\n\treturn node;\n}\n\n/* Delete a cJSON structure. */\nvoid cJSON_Delete(cJSON *c)\n{\n\tcJSON *next;\n\twhile (c)\n\t{\n\t\tnext=c->next;\n\t\tif (!(c->type&cJSON_IsReference) && c->child) cJSON_Delete(c->child);\n\t\tif (!(c->type&cJSON_IsReference) && c->valuestring) cJSON_free(c->valuestring);\n\t\tif (!(c->type&cJSON_StringIsConst) && c->string) cJSON_free(c->string);\n\t\tcJSON_free(c);\n\t\tc=next;\n\t}\n}\n\n/* Parse the input text to generate a number, and populate the result into item. */\nstatic const char *parse_number(cJSON *item,const char *num)\n{\n\tdouble n=0,sign=1,scale=0;int subscale=0,signsubscale=1;\n\n\tif (*num=='-') sign=-1,num++;\t/* Has sign? */\n\tif (*num=='0') num++;\t\t\t/* is zero */\n\tif (*num>='1' && *num<='9')\tdo\tn=(n*10.0)+(*num++ -'0');\twhile (*num>='0' && *num<='9');\t/* Number? */\n\tif (*num=='.' && num[1]>='0' && num[1]<='9') {num++;\t\tdo\tn=(n*10.0)+(*num++ -'0'),scale--; while (*num>='0' && *num<='9');}\t/* Fractional part? */\n\tif (*num=='e' || *num=='E')\t\t/* Exponent? */\n\t{\tnum++;if (*num=='+') num++;\telse if (*num=='-') signsubscale=-1,num++;\t\t/* With sign? */\n\t\twhile (*num>='0' && *num<='9') subscale=(subscale*10)+(*num++ - '0');\t/* Number? */\n\t}\n\n\tn=sign*n*pow(10.0,(scale+subscale*signsubscale));\t/* number = +/- number.fraction * 10^+/- exponent */\n\t\n\titem->valuedouble=n;\n\titem->valueint=(int)n;\n\titem->type=cJSON_Number;\n\treturn num;\n}\n\nstatic int pow2gt (int x)\t{\t--x;\tx|=x>>1;\tx|=x>>2;\tx|=x>>4;\tx|=x>>8;\tx|=x>>16;\treturn x+1;\t}\n\ntypedef struct {char *buffer; int length; int offset; } printbuffer;\n\nstatic char* ensure(printbuffer *p,int needed)\n{\n\tchar *newbuffer;int newsize;\n\tif (!p || !p->buffer) return 0;\n\tneeded+=p->offset;\n\tif (needed<=p->length) return p->buffer+p->offset;\n\n\tnewsize=pow2gt(needed);\n\tnewbuffer=(char*)cJSON_malloc(newsize);\n\tif (!newbuffer) {cJSON_free(p->buffer);p->length=0,p->buffer=0;return 0;}\n\tif (newbuffer) memcpy(newbuffer,p->buffer,p->length);\n\tcJSON_free(p->buffer);\n\tp->length=newsize;\n\tp->buffer=newbuffer;\n\treturn newbuffer+p->offset;\n}\n\nstatic int update(printbuffer *p)\n{\n\tchar *str;\n\tif (!p || !p->buffer) return 0;\n\tstr=p->buffer+p->offset;\n\treturn p->offset+strlen(str);\n}\n\n/* Render the number nicely from the given item into a string. */\nstatic char *print_number(cJSON *item,printbuffer *p)\n{\n\tchar *str=0;\n\tdouble d=item->valuedouble;\n\tif (d==0)\n\t{\n\t\tif (p)\tstr=ensure(p,2);\n\t\telse\tstr=(char*)cJSON_malloc(2);\t/* special case for 0. */\n\t\tif (str) strcpy(str,\"0\");\n\t}\n\telse if (fabs(((double)item->valueint)-d)<=DBL_EPSILON && d<=INT_MAX && d>=INT_MIN)\n\t{\n\t\tif (p)\tstr=ensure(p,21);\n\t\telse\tstr=(char*)cJSON_malloc(21);\t/* 2^64+1 can be represented in 21 chars. */\n\t\tif (str)\tsprintf(str,\"%d\",item->valueint);\n\t}\n\telse\n\t{\n\t\tif (p)\tstr=ensure(p,64);\n\t\telse\tstr=(char*)cJSON_malloc(64);\t/* This is a nice tradeoff. */\n\t\tif (str)\n\t\t{\n\t\t\tif (d*0!=0)\t\t\t\t\t\t\t\t\t\t\t\t\tsprintf(str,\"null\");\t/* This checks for NaN and Infinity */\n\t\t\telse if (fabs(floor(d)-d)<=DBL_EPSILON && fabs(d)<1.0e60)\tsprintf(str,\"%.0f\",d);\n\t\t\telse if (fabs(d)<1.0e-6 || fabs(d)>1.0e9)\t\t\t\t\tsprintf(str,\"%e\",d);\n\t\t\telse\t\t\t\t\t\t\t\t\t\t\t\t\t\tsprintf(str,\"%f\",d);\n\t\t}\n\t}\n\treturn str;\n}\n\nstatic unsigned parse_hex4(const char *str)\n{\n\tunsigned h=0;\n\tif (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;\n\th=h<<4;str++;\n\tif (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;\n\th=h<<4;str++;\n\tif (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;\n\th=h<<4;str++;\n\tif (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;\n\treturn h;\n}\n\n/* Parse the input text into an unescaped cstring, and populate item. */\nstatic const unsigned char firstByteMark[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };\nstatic const char *parse_string(cJSON *item,const char *str,const char **ep)\n{\n\tconst char *ptr=str+1,*end_ptr=str+1;char *ptr2;char *out;int len=0;unsigned uc,uc2;\n\tif (*str!='\\\"') {*ep=str;return 0;}\t/* not a string! */\n\n\twhile (*end_ptr!='\\\"' && *end_ptr && ++len)\n\t{\n\t    if (*end_ptr++ == '\\\\')\n\t    {\n\t\tif (*end_ptr == '\\0')\n\t\t{\n\t\t    /* prevent buffer overflow when last input character is a backslash */\n\t\t    return 0;\n\t\t}\n\t\tend_ptr++;\t/* Skip escaped quotes. */\n\t    }\n\t}\n\n\tout=(char*)cJSON_malloc(len+1);\t/* This is how long we need for the string, roughly. */\n\tif (!out) return 0;\n\titem->valuestring=out; /* assign here so out will be deleted during cJSON_Delete() later */\n\titem->type=cJSON_String;\n\t\n\tptr=str+1;ptr2=out;\n\twhile (ptr < end_ptr)\n\t{\n\t\tif (*ptr!='\\\\') *ptr2++=*ptr++;\n\t\telse\n\t\t{\n\t\t\tptr++;\n\t\t\tswitch (*ptr)\n\t\t\t{\n\t\t\t\tcase 'b': *ptr2++='\\b';\tbreak;\n\t\t\t\tcase 'f': *ptr2++='\\f';\tbreak;\n\t\t\t\tcase 'n': *ptr2++='\\n';\tbreak;\n\t\t\t\tcase 'r': *ptr2++='\\r';\tbreak;\n\t\t\t\tcase 't': *ptr2++='\\t';\tbreak;\n\t\t\t\tcase 'u':\t /* transcode utf16 to utf8. */\n\t\t\t\t\tuc=parse_hex4(ptr+1);ptr+=4;\t/* get the unicode char. */\n\t\t\t\t\tif (ptr >= end_ptr) {*ep=str;return 0;}\t/* invalid */\n\t\t\t\t\t\n\t\t\t\t\tif ((uc>=0xDC00 && uc<=0xDFFF) || uc==0)    {*ep=str;return 0;}\t/* check for invalid.   */\n\t\t\t\t\t\n\t\t\t\t\tif (uc>=0xD800 && uc<=0xDBFF)\t/* UTF16 surrogate pairs.\t*/\n\t\t\t\t\t{\n\t\t\t\t\t\tif (ptr+6 > end_ptr)    {*ep=str;return 0;}\t/* invalid */\n\t\t\t\t\t\tif (ptr[1]!='\\\\' || ptr[2]!='u')    {*ep=str;return 0;}\t/* missing second-half of surrogate.    */\n\t\t\t\t\t\tuc2=parse_hex4(ptr+3);ptr+=6;\n\t\t\t\t\t\tif (uc2<0xDC00 || uc2>0xDFFF)       {*ep=str;return 0;}\t/* invalid second-half of surrogate.    */\n\t\t\t\t\t\tuc=0x10000 + (((uc&0x3FF)<<10) | (uc2&0x3FF));\n\t\t\t\t\t}\n\n\t\t\t\t\tlen=4;if (uc<0x80) len=1;else if (uc<0x800) len=2;else if (uc<0x10000) len=3; ptr2+=len;\n\t\t\t\t\t\n\t\t\t\t\tswitch (len) {\n\t\t\t\t\t\tcase 4: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;\n\t\t\t\t\t\tcase 3: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;\n\t\t\t\t\t\tcase 2: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;\n\t\t\t\t\t\tcase 1: *--ptr2 =(uc | firstByteMark[len]);\n\t\t\t\t\t}\n\t\t\t\t\tptr2+=len;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:  *ptr2++=*ptr; break;\n\t\t\t}\n\t\t\tptr++;\n\t\t}\n\t}\n\t*ptr2=0;\n\tif (*ptr=='\\\"') ptr++;\n\treturn ptr;\n}\n\n/* Render the cstring provided to an escaped version that can be printed. */\nstatic char *print_string_ptr(const char *str,printbuffer *p)\n{\n\tconst char *ptr;char *ptr2,*out;int len=0,flag=0;unsigned char token;\n\n\tif (!str)\n\t{\n\t\tif (p)\tout=ensure(p,3);\n\t\telse\tout=(char*)cJSON_malloc(3);\n\t\tif (!out) return 0;\n\t\tstrcpy(out,\"\\\"\\\"\");\n\t\treturn out;\n\t}\n\t\n\tfor (ptr=str;*ptr;ptr++) flag|=((*ptr>0 && *ptr<32)||(*ptr=='\\\"')||(*ptr=='\\\\'))?1:0;\n\tif (!flag)\n\t{\n\t\tlen=ptr-str;\n\t\tif (p) out=ensure(p,len+3);\n\t\telse\t\tout=(char*)cJSON_malloc(len+3);\n\t\tif (!out) return 0;\n\t\tptr2=out;*ptr2++='\\\"';\n\t\tstrcpy(ptr2,str);\n\t\tptr2[len]='\\\"';\n\t\tptr2[len+1]=0;\n\t\treturn out;\n\t}\n\t\n\tptr=str;while ((token=*ptr) && ++len) {if (strchr(\"\\\"\\\\\\b\\f\\n\\r\\t\",token)) len++; else if (token<32) len+=5;ptr++;}\n\t\n\tif (p)\tout=ensure(p,len+3);\n\telse\tout=(char*)cJSON_malloc(len+3);\n\tif (!out) return 0;\n\n\tptr2=out;ptr=str;\n\t*ptr2++='\\\"';\n\twhile (*ptr)\n\t{\n\t\tif ((unsigned char)*ptr>31 && *ptr!='\\\"' && *ptr!='\\\\') *ptr2++=*ptr++;\n\t\telse\n\t\t{\n\t\t\t*ptr2++='\\\\';\n\t\t\tswitch (token=*ptr++)\n\t\t\t{\n\t\t\t\tcase '\\\\':\t*ptr2++='\\\\';\tbreak;\n\t\t\t\tcase '\\\"':\t*ptr2++='\\\"';\tbreak;\n\t\t\t\tcase '\\b':\t*ptr2++='b';\tbreak;\n\t\t\t\tcase '\\f':\t*ptr2++='f';\tbreak;\n\t\t\t\tcase '\\n':\t*ptr2++='n';\tbreak;\n\t\t\t\tcase '\\r':\t*ptr2++='r';\tbreak;\n\t\t\t\tcase '\\t':\t*ptr2++='t';\tbreak;\n\t\t\t\tdefault: sprintf(ptr2,\"u%04x\",token);ptr2+=5;\tbreak;\t/* escape and print */\n\t\t\t}\n\t\t}\n\t}\n\t*ptr2++='\\\"';*ptr2++=0;\n\treturn out;\n}\n/* Invote print_string_ptr (which is useful) on an item. */\nstatic char *print_string(cJSON *item,printbuffer *p)\t{return print_string_ptr(item->valuestring,p);}\n\n/* Predeclare these prototypes. */\nstatic const char *parse_value(cJSON *item,const char *value,const char **ep);\nstatic char *print_value(cJSON *item,int depth,int fmt,printbuffer *p);\nstatic const char *parse_array(cJSON *item,const char *value,const char **ep);\nstatic char *print_array(cJSON *item,int depth,int fmt,printbuffer *p);\nstatic const char *parse_object(cJSON *item,const char *value,const char **ep);\nstatic char *print_object(cJSON *item,int depth,int fmt,printbuffer *p);\n\n/* Utility to jump whitespace and cr/lf */\nstatic const char *skip(const char *in) {while (in && *in && (unsigned char)*in<=32) in++; return in;}\n\n/* Parse an object - create a new root, and populate. */\ncJSON *cJSON_ParseWithOpts(const char *value,const char **return_parse_end,int require_null_terminated)\n{\n\tconst char *end=0,**ep=return_parse_end?return_parse_end:&global_ep;\n\tcJSON *c=cJSON_New_Item();\n\t*ep=0;\n\tif (!c) return 0;       /* memory fail */\n\n\tend=parse_value(c,skip(value),ep);\n\tif (!end)\t{cJSON_Delete(c);return 0;}\t/* parse failure. ep is set. */\n\n\t/* if we require null-terminated JSON without appended garbage, skip and then check for a null terminator */\n\tif (require_null_terminated) {end=skip(end);if (*end) {cJSON_Delete(c);*ep=end;return 0;}}\n\tif (return_parse_end) *return_parse_end=end;\n\treturn c;\n}\n/* Default options for cJSON_Parse */\ncJSON *cJSON_Parse(const char *value) {return cJSON_ParseWithOpts(value,0,0);}\n\n/* Render a cJSON item/entity/structure to text. */\nchar *cJSON_Print(cJSON *item)\t\t\t\t{return print_value(item,0,1,0);}\nchar *cJSON_PrintUnformatted(cJSON *item)\t{return print_value(item,0,0,0);}\n\nchar *cJSON_PrintBuffered(cJSON *item,int prebuffer,int fmt)\n{\n\tprintbuffer p;\n\tp.buffer=(char*)cJSON_malloc(prebuffer);\n\tp.length=prebuffer;\n\tp.offset=0;\n\treturn print_value(item,0,fmt,&p);\n}\n\n\n/* Parser core - when encountering text, process appropriately. */\nstatic const char *parse_value(cJSON *item,const char *value,const char **ep)\n{\n\tif (!value)\t\t\t\t\t\treturn 0;\t/* Fail on null. */\n\tif (!strncmp(value,\"null\",4))\t{ item->type=cJSON_NULL;  return value+4; }\n\tif (!strncmp(value,\"false\",5))\t{ item->type=cJSON_False; return value+5; }\n\tif (!strncmp(value,\"true\",4))\t{ item->type=cJSON_True; item->valueint=1;\treturn value+4; }\n\tif (*value=='\\\"')\t\t\t\t{ return parse_string(item,value,ep); }\n\tif (*value=='-' || (*value>='0' && *value<='9'))\t{ return parse_number(item,value); }\n\tif (*value=='[')\t\t\t\t{ return parse_array(item,value,ep); }\n\tif (*value=='{')\t\t\t\t{ return parse_object(item,value,ep); }\n\n\t*ep=value;return 0;\t/* failure. */\n}\n\n/* Render a value to text. */\nstatic char *print_value(cJSON *item,int depth,int fmt,printbuffer *p)\n{\n\tchar *out=0;\n\tif (!item) return 0;\n\tif (p)\n\t{\n\t\tswitch ((item->type)&255)\n\t\t{\n\t\t\tcase cJSON_NULL:\t{out=ensure(p,5);\tif (out) strcpy(out,\"null\");\tbreak;}\n\t\t\tcase cJSON_False:\t{out=ensure(p,6);\tif (out) strcpy(out,\"false\");\tbreak;}\n\t\t\tcase cJSON_True:\t{out=ensure(p,5);\tif (out) strcpy(out,\"true\");\tbreak;}\n\t\t\tcase cJSON_Number:\tout=print_number(item,p);break;\n\t\t\tcase cJSON_String:\tout=print_string(item,p);break;\n\t\t\tcase cJSON_Array:\tout=print_array(item,depth,fmt,p);break;\n\t\t\tcase cJSON_Object:\tout=print_object(item,depth,fmt,p);break;\n\t\t}\n\t}\n\telse\n\t{\n\t\tswitch ((item->type)&255)\n\t\t{\n\t\t\tcase cJSON_NULL:\tout=cJSON_strdup(\"null\");\tbreak;\n\t\t\tcase cJSON_False:\tout=cJSON_strdup(\"false\");break;\n\t\t\tcase cJSON_True:\tout=cJSON_strdup(\"true\"); break;\n\t\t\tcase cJSON_Number:\tout=print_number(item,0);break;\n\t\t\tcase cJSON_String:\tout=print_string(item,0);break;\n\t\t\tcase cJSON_Array:\tout=print_array(item,depth,fmt,0);break;\n\t\t\tcase cJSON_Object:\tout=print_object(item,depth,fmt,0);break;\n\t\t}\n\t}\n\treturn out;\n}\n\n/* Build an array from input text. */\nstatic const char *parse_array(cJSON *item,const char *value,const char **ep)\n{\n\tcJSON *child;\n\tif (*value!='[')\t{*ep=value;return 0;}\t/* not an array! */\n\n\titem->type=cJSON_Array;\n\tvalue=skip(value+1);\n\tif (*value==']') return value+1;\t/* empty array. */\n\n\titem->child=child=cJSON_New_Item();\n\tif (!item->child) return 0;\t\t /* memory fail */\n\tvalue=skip(parse_value(child,skip(value),ep));\t/* skip any spacing, get the value. */\n\tif (!value) return 0;\n\n\twhile (*value==',')\n\t{\n\t\tcJSON *new_item;\n\t\tif (!(new_item=cJSON_New_Item())) return 0; \t/* memory fail */\n\t\tchild->next=new_item;new_item->prev=child;child=new_item;\n\t\tvalue=skip(parse_value(child,skip(value+1),ep));\n\t\tif (!value) return 0;\t/* memory fail */\n\t}\n\n\tif (*value==']') return value+1;\t/* end of array */\n\t*ep=value;return 0;\t/* malformed. */\n}\n\n/* Render an array to text */\nstatic char *print_array(cJSON *item,int depth,int fmt,printbuffer *p)\n{\n\tchar **entries;\n\tchar *out=0,*ptr,*ret;int len=5;\n\tcJSON *child=item->child;\n\tint numentries=0,i=0,fail=0;\n\tsize_t tmplen=0;\n\t\n\t/* How many entries in the array? */\n\twhile (child) numentries++,child=child->next;\n\t/* Explicitly handle numentries==0 */\n\tif (!numentries)\n\t{\n\t\tif (p)\tout=ensure(p,3);\n\t\telse\tout=(char*)cJSON_malloc(3);\n\t\tif (out) strcpy(out,\"[]\");\n\t\treturn out;\n\t}\n\n\tif (p)\n\t{\n\t\t/* Compose the output array. */\n\t\ti=p->offset;\n\t\tptr=ensure(p,1);if (!ptr) return 0;\t*ptr='[';\tp->offset++;\n\t\tchild=item->child;\n\t\twhile (child && !fail)\n\t\t{\n\t\t\tprint_value(child,depth+1,fmt,p);\n\t\t\tp->offset=update(p);\n\t\t\tif (child->next) {len=fmt?2:1;ptr=ensure(p,len+1);if (!ptr) return 0;*ptr++=',';if(fmt)*ptr++=' ';*ptr=0;p->offset+=len;}\n\t\t\tchild=child->next;\n\t\t}\n\t\tptr=ensure(p,2);if (!ptr) return 0;\t*ptr++=']';*ptr=0;\n\t\tout=(p->buffer)+i;\n\t}\n\telse\n\t{\n\t\t/* Allocate an array to hold the values for each */\n\t\tentries=(char**)cJSON_malloc(numentries*sizeof(char*));\n\t\tif (!entries) return 0;\n\t\tmemset(entries,0,numentries*sizeof(char*));\n\t\t/* Retrieve all the results: */\n\t\tchild=item->child;\n\t\twhile (child && !fail)\n\t\t{\n\t\t\tret=print_value(child,depth+1,fmt,0);\n\t\t\tentries[i++]=ret;\n\t\t\tif (ret) len+=strlen(ret)+2+(fmt?1:0); else fail=1;\n\t\t\tchild=child->next;\n\t\t}\n\t\t\n\t\t/* If we didn't fail, try to malloc the output string */\n\t\tif (!fail)\tout=(char*)cJSON_malloc(len);\n\t\t/* If that fails, we fail. */\n\t\tif (!out) fail=1;\n\n\t\t/* Handle failure. */\n\t\tif (fail)\n\t\t{\n\t\t\tfor (i=0;i<numentries;i++) if (entries[i]) cJSON_free(entries[i]);\n\t\t\tcJSON_free(entries);\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\t/* Compose the output array. */\n\t\t*out='[';\n\t\tptr=out+1;*ptr=0;\n\t\tfor (i=0;i<numentries;i++)\n\t\t{\n\t\t\ttmplen=strlen(entries[i]);memcpy(ptr,entries[i],tmplen);ptr+=tmplen;\n\t\t\tif (i!=numentries-1) {*ptr++=',';if(fmt)*ptr++=' ';*ptr=0;}\n\t\t\tcJSON_free(entries[i]);\n\t\t}\n\t\tcJSON_free(entries);\n\t\t*ptr++=']';*ptr++=0;\n\t}\n\treturn out;\t\n}\n\n/* Build an object from the text. */\nstatic const char *parse_object(cJSON *item,const char *value,const char **ep)\n{\n\tcJSON *child;\n\tif (*value!='{')\t{*ep=value;return 0;}\t/* not an object! */\n\t\n\titem->type=cJSON_Object;\n\tvalue=skip(value+1);\n\tif (*value=='}') return value+1;\t/* empty array. */\n\t\n\titem->child=child=cJSON_New_Item();\n\tif (!item->child) return 0;\n\tvalue=skip(parse_string(child,skip(value),ep));\n\tif (!value) return 0;\n\tchild->string=child->valuestring;child->valuestring=0;\n\tif (*value!=':') {*ep=value;return 0;}\t/* fail! */\n\tvalue=skip(parse_value(child,skip(value+1),ep));\t/* skip any spacing, get the value. */\n\tif (!value) return 0;\n\t\n\twhile (*value==',')\n\t{\n\t\tcJSON *new_item;\n\t\tif (!(new_item=cJSON_New_Item()))\treturn 0; /* memory fail */\n\t\tchild->next=new_item;new_item->prev=child;child=new_item;\n\t\tvalue=skip(parse_string(child,skip(value+1),ep));\n\t\tif (!value) return 0;\n\t\tchild->string=child->valuestring;child->valuestring=0;\n\t\tif (*value!=':') {*ep=value;return 0;}\t/* fail! */\n\t\tvalue=skip(parse_value(child,skip(value+1),ep));\t/* skip any spacing, get the value. */\n\t\tif (!value) return 0;\n\t}\n\t\n\tif (*value=='}') return value+1;\t/* end of array */\n\t*ep=value;return 0;\t/* malformed. */\n}\n\n/* Render an object to text. */\nstatic char *print_object(cJSON *item,int depth,int fmt,printbuffer *p)\n{\n\tchar **entries=0,**names=0;\n\tchar *out=0,*ptr,*ret,*str;int len=7,i=0,j;\n\tcJSON *child=item->child;\n\tint numentries=0,fail=0;\n\tsize_t tmplen=0;\n\t/* Count the number of entries. */\n\twhile (child) numentries++,child=child->next;\n\t/* Explicitly handle empty object case */\n\tif (!numentries)\n\t{\n\t\tif (p) out=ensure(p,fmt?depth+4:3);\n\t\telse\tout=(char*)cJSON_malloc(fmt?depth+4:3);\n\t\tif (!out)\treturn 0;\n\t\tptr=out;*ptr++='{';\n\t\tif (fmt) {*ptr++='\\n';for (i=0;i<depth;i++) *ptr++='\\t';}\n\t\t*ptr++='}';*ptr++=0;\n\t\treturn out;\n\t}\n\tif (p)\n\t{\n\t\t/* Compose the output: */\n\t\ti=p->offset;\n\t\tlen=fmt?2:1;\tptr=ensure(p,len+1);\tif (!ptr) return 0;\n\t\t*ptr++='{';\tif (fmt) *ptr++='\\n';\t*ptr=0;\tp->offset+=len;\n\t\tchild=item->child;depth++;\n\t\twhile (child)\n\t\t{\n\t\t\tif (fmt)\n\t\t\t{\n\t\t\t\tptr=ensure(p,depth);\tif (!ptr) return 0;\n\t\t\t\tfor (j=0;j<depth;j++) *ptr++='\\t';\n\t\t\t\tp->offset+=depth;\n\t\t\t}\n\t\t\tprint_string_ptr(child->string,p);\n\t\t\tp->offset=update(p);\n\t\t\t\n\t\t\tlen=fmt?2:1;\n\t\t\tptr=ensure(p,len);\tif (!ptr) return 0;\n\t\t\t*ptr++=':';if (fmt) *ptr++='\\t';\n\t\t\tp->offset+=len;\n\t\t\t\n\t\t\tprint_value(child,depth,fmt,p);\n\t\t\tp->offset=update(p);\n\n\t\t\tlen=(fmt?1:0)+(child->next?1:0);\n\t\t\tptr=ensure(p,len+1); if (!ptr) return 0;\n\t\t\tif (child->next) *ptr++=',';\n\t\t\tif (fmt) *ptr++='\\n';*ptr=0;\n\t\t\tp->offset+=len;\n\t\t\tchild=child->next;\n\t\t}\n\t\tptr=ensure(p,fmt?(depth+1):2);\t if (!ptr) return 0;\n\t\tif (fmt)\tfor (i=0;i<depth-1;i++) *ptr++='\\t';\n\t\t*ptr++='}';*ptr=0;\n\t\tout=(p->buffer)+i;\n\t}\n\telse\n\t{\n\t\t/* Allocate space for the names and the objects */\n\t\tentries=(char**)cJSON_malloc(numentries*sizeof(char*));\n\t\tif (!entries) return 0;\n\t\tnames=(char**)cJSON_malloc(numentries*sizeof(char*));\n\t\tif (!names) {cJSON_free(entries);return 0;}\n\t\tmemset(entries,0,sizeof(char*)*numentries);\n\t\tmemset(names,0,sizeof(char*)*numentries);\n\n\t\t/* Collect all the results into our arrays: */\n\t\tchild=item->child;depth++;if (fmt) len+=depth;\n\t\twhile (child && !fail)\n\t\t{\n\t\t\tnames[i]=str=print_string_ptr(child->string,0);\n\t\t\tentries[i++]=ret=print_value(child,depth,fmt,0);\n\t\t\tif (str && ret) len+=strlen(ret)+strlen(str)+2+(fmt?2+depth:0); else fail=1;\n\t\t\tchild=child->next;\n\t\t}\n\t\t\n\t\t/* Try to allocate the output string */\n\t\tif (!fail)\tout=(char*)cJSON_malloc(len);\n\t\tif (!out) fail=1;\n\n\t\t/* Handle failure */\n\t\tif (fail)\n\t\t{\n\t\t\tfor (i=0;i<numentries;i++) {if (names[i]) cJSON_free(names[i]);if (entries[i]) cJSON_free(entries[i]);}\n\t\t\tcJSON_free(names);cJSON_free(entries);\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\t/* Compose the output: */\n\t\t*out='{';ptr=out+1;if (fmt)*ptr++='\\n';*ptr=0;\n\t\tfor (i=0;i<numentries;i++)\n\t\t{\n\t\t\tif (fmt) for (j=0;j<depth;j++) *ptr++='\\t';\n\t\t\ttmplen=strlen(names[i]);memcpy(ptr,names[i],tmplen);ptr+=tmplen;\n\t\t\t*ptr++=':';if (fmt) *ptr++='\\t';\n\t\t\tstrcpy(ptr,entries[i]);ptr+=strlen(entries[i]);\n\t\t\tif (i!=numentries-1) *ptr++=',';\n\t\t\tif (fmt) *ptr++='\\n';*ptr=0;\n\t\t\tcJSON_free(names[i]);cJSON_free(entries[i]);\n\t\t}\n\t\t\n\t\tcJSON_free(names);cJSON_free(entries);\n\t\tif (fmt) for (i=0;i<depth-1;i++) *ptr++='\\t';\n\t\t*ptr++='}';*ptr++=0;\n\t}\n\treturn out;\t\n}\n\n/* Get Array size/item / object item. */\nint    cJSON_GetArraySize(cJSON *array)\t\t\t\t\t\t\t{cJSON *c=array->child;int i=0;while(c)i++,c=c->next;return i;}\ncJSON *cJSON_GetArrayItem(cJSON *array,int item)\t\t\t\t{cJSON *c=array?array->child:0;while (c && item>0) item--,c=c->next; return c;}\ncJSON *cJSON_GetObjectItem(cJSON *object,const char *string)\t{cJSON *c=object?object->child:0;while (c && cJSON_strcasecmp(c->string,string)) c=c->next; return c;}\nint cJSON_HasObjectItem(cJSON *object,const char *string)\t\t{return cJSON_GetObjectItem(object,string)?1:0;}\n\n/* Utility for array list handling. */\nstatic void suffix_object(cJSON *prev,cJSON *item) {prev->next=item;item->prev=prev;}\n/* Utility for handling references. */\nstatic cJSON *create_reference(cJSON *item) {cJSON *ref=cJSON_New_Item();if (!ref) return 0;memcpy(ref,item,sizeof(cJSON));ref->string=0;ref->type|=cJSON_IsReference;ref->next=ref->prev=0;return ref;}\n\n/* Add item to array/object. */\nvoid   cJSON_AddItemToArray(cJSON *array, cJSON *item)\t\t\t\t\t\t{cJSON *c=array->child;if (!item) return; if (!c) {array->child=item;} else {while (c && c->next) c=c->next; suffix_object(c,item);}}\nvoid   cJSON_AddItemToObject(cJSON *object,const char *string,cJSON *item)\t{if (!item) return; if (item->string) cJSON_free(item->string);item->string=cJSON_strdup(string);cJSON_AddItemToArray(object,item);}\nvoid   cJSON_AddItemToObjectCS(cJSON *object,const char *string,cJSON *item)\t{if (!item) return; if (!(item->type&cJSON_StringIsConst) && item->string) cJSON_free(item->string);item->string=(char*)string;item->type|=cJSON_StringIsConst;cJSON_AddItemToArray(object,item);}\nvoid\tcJSON_AddItemReferenceToArray(cJSON *array, cJSON *item)\t\t\t\t\t\t{cJSON_AddItemToArray(array,create_reference(item));}\nvoid\tcJSON_AddItemReferenceToObject(cJSON *object,const char *string,cJSON *item)\t{cJSON_AddItemToObject(object,string,create_reference(item));}\n\ncJSON *cJSON_DetachItemFromArray(cJSON *array,int which)\t\t\t{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) return 0;\n\tif (c->prev) c->prev->next=c->next;if (c->next) c->next->prev=c->prev;if (c==array->child) array->child=c->next;c->prev=c->next=0;return c;}\nvoid   cJSON_DeleteItemFromArray(cJSON *array,int which)\t\t\t{cJSON_Delete(cJSON_DetachItemFromArray(array,which));}\ncJSON *cJSON_DetachItemFromObject(cJSON *object,const char *string) {int i=0;cJSON *c=object->child;while (c && cJSON_strcasecmp(c->string,string)) i++,c=c->next;if (c) return cJSON_DetachItemFromArray(object,i);return 0;}\nvoid   cJSON_DeleteItemFromObject(cJSON *object,const char *string) {cJSON_Delete(cJSON_DetachItemFromObject(object,string));}\n\n/* Replace array/object items with new ones. */\nvoid   cJSON_InsertItemInArray(cJSON *array,int which,cJSON *newitem)\t\t{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) {cJSON_AddItemToArray(array,newitem);return;}\n\tnewitem->next=c;newitem->prev=c->prev;c->prev=newitem;if (c==array->child) array->child=newitem; else newitem->prev->next=newitem;}\nvoid   cJSON_ReplaceItemInArray(cJSON *array,int which,cJSON *newitem)\t\t{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) return;\n\tnewitem->next=c->next;newitem->prev=c->prev;if (newitem->next) newitem->next->prev=newitem;\n\tif (c==array->child) array->child=newitem; else newitem->prev->next=newitem;c->next=c->prev=0;cJSON_Delete(c);}\nvoid   cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem){int i=0;cJSON *c=object->child;while(c && cJSON_strcasecmp(c->string,string))i++,c=c->next;if(c){newitem->string=cJSON_strdup(string);cJSON_ReplaceItemInArray(object,i,newitem);}}\n\n/* Create basic types: */\ncJSON *cJSON_CreateNull(void)\t\t\t\t\t{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_NULL;return item;}\ncJSON *cJSON_CreateTrue(void)\t\t\t\t\t{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_True;return item;}\ncJSON *cJSON_CreateFalse(void)\t\t\t\t\t{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_False;return item;}\ncJSON *cJSON_CreateBool(int b)\t\t\t\t\t{cJSON *item=cJSON_New_Item();if(item)item->type=b?cJSON_True:cJSON_False;return item;}\ncJSON *cJSON_CreateNumber(double num)\t\t\t{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_Number;item->valuedouble=num;item->valueint=(int)num;}return item;}\ncJSON *cJSON_CreateString(const char *string)\t{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_String;item->valuestring=cJSON_strdup(string);if(!item->valuestring){cJSON_Delete(item);return 0;}}return item;}\ncJSON *cJSON_CreateArray(void)\t\t\t\t\t{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Array;return item;}\ncJSON *cJSON_CreateObject(void)\t\t\t\t\t{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Object;return item;}\n\n/* Create Arrays: */\ncJSON *cJSON_CreateIntArray(const int *numbers,int count)\t\t{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!n){cJSON_Delete(a);return 0;}if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}\ncJSON *cJSON_CreateFloatArray(const float *numbers,int count)\t{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!n){cJSON_Delete(a);return 0;}if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}\ncJSON *cJSON_CreateDoubleArray(const double *numbers,int count)\t{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!n){cJSON_Delete(a);return 0;}if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}\ncJSON *cJSON_CreateStringArray(const char **strings,int count)\t{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateString(strings[i]);if(!n){cJSON_Delete(a);return 0;}if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}\n\n/* Duplication */\ncJSON *cJSON_Duplicate(cJSON *item,int recurse)\n{\n\tcJSON *newitem,*cptr,*nptr=0,*newchild;\n\t/* Bail on bad ptr */\n\tif (!item) return 0;\n\t/* Create new item */\n\tnewitem=cJSON_New_Item();\n\tif (!newitem) return 0;\n\t/* Copy over all vars */\n\tnewitem->type=item->type&(~cJSON_IsReference),newitem->valueint=item->valueint,newitem->valuedouble=item->valuedouble;\n\tif (item->valuestring)\t{newitem->valuestring=cJSON_strdup(item->valuestring);\tif (!newitem->valuestring)\t{cJSON_Delete(newitem);return 0;}}\n\tif (item->string)\t\t{newitem->string=cJSON_strdup(item->string);\t\t\tif (!newitem->string)\t\t{cJSON_Delete(newitem);return 0;}}\n\t/* If non-recursive, then we're done! */\n\tif (!recurse) return newitem;\n\t/* Walk the ->next chain for the child. */\n\tcptr=item->child;\n\twhile (cptr)\n\t{\n\t\tnewchild=cJSON_Duplicate(cptr,1);\t\t/* Duplicate (with recurse) each item in the ->next chain */\n\t\tif (!newchild) {cJSON_Delete(newitem);return 0;}\n\t\tif (nptr)\t{nptr->next=newchild,newchild->prev=nptr;nptr=newchild;}\t/* If newitem->child already set, then crosswire ->prev and ->next and move on */\n\t\telse\t\t{newitem->child=newchild;nptr=newchild;}\t\t\t\t\t/* Set newitem->child and move to it */\n\t\tcptr=cptr->next;\n\t}\n\treturn newitem;\n}\n\nvoid cJSON_Minify(char *json)\n{\n\tchar *into=json;\n\twhile (*json)\n\t{\n\t\tif (*json==' ') json++;\n\t\telse if (*json=='\\t') json++;\t/* Whitespace characters. */\n\t\telse if (*json=='\\r') json++;\n\t\telse if (*json=='\\n') json++;\n\t\telse if (*json=='/' && json[1]=='/')  while (*json && *json!='\\n') json++;\t/* double-slash comments, to end of line. */\n\t\telse if (*json=='/' && json[1]=='*') {while (*json && !(*json=='*' && json[1]=='/')) json++;json+=2;}\t/* multiline comments. */\n\t\telse if (*json=='\\\"'){*into++=*json++;while (*json && *json!='\\\"'){if (*json=='\\\\') *into++=*json++;*into++=*json++;}*into++=*json++;} /* string literals, which are \\\" sensitive. */\n\t\telse *into++=*json++;\t\t\t/* All other characters. */\n\t}\n\t*into=0;\t/* and null-terminate. */\n}\n"], "filenames": ["cJSON.c"], "buggy_code_start_loc": [197], "buggy_code_end_loc": [200], "fixing_code_start_loc": [197], "fixing_code_end_loc": [211], "type": "CWE-125", "message": "parse_string in cJSON.c in cJSON before 2016-10-02 has a buffer over-read, as demonstrated by a string that begins with a \" character and ends with a \\ character.", "other": {"cve": {"id": "CVE-2016-10749", "sourceIdentifier": "cve@mitre.org", "published": "2019-04-29T14:29:00.363", "lastModified": "2019-12-27T15:45:05.817", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "parse_string in cJSON.c in cJSON before 2016-10-02 has a buffer over-read, as demonstrated by a string that begins with a \" character and ends with a \\ character."}, {"lang": "es", "value": "parse_string en cJSON.c en cJSON antes del 02/10/2016, tiene una sobre-lectura de b\u00fafer, como lo demuestra una cadena que comienza con un car\u00e1cter \" y termina con un car\u00e1cter \\."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:cjson_project:cjson:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.0.0", "matchCriteriaId": "A3541972-75F2-49E4-8BE8-938C3C6999FF"}]}]}], "references": [{"url": "https://github.com/DaveGamble/cJSON/commit/94df772485c92866ca417d92137747b2e3b0a917", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/DaveGamble/cJSON/issues/30", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://www.openwall.com/lists/oss-security/2016/11/07/2", "source": "cve@mitre.org", "tags": ["Exploit", "Mailing List", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/DaveGamble/cJSON/commit/94df772485c92866ca417d92137747b2e3b0a917"}}