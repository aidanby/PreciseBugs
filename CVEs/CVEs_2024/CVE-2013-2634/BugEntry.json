{"buggy_code": ["/*\n * Copyright (c) 2008-2011, Intel Corporation.\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms and conditions of the GNU General Public License,\n * version 2, as published by the Free Software Foundation.\n *\n * This program is distributed in the hope it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n * more details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program; if not, write to the Free Software Foundation, Inc., 59 Temple\n * Place - Suite 330, Boston, MA 02111-1307 USA.\n *\n * Author: Lucy Liu <lucy.liu@intel.com>\n */\n\n#include <linux/netdevice.h>\n#include <linux/netlink.h>\n#include <linux/slab.h>\n#include <net/netlink.h>\n#include <net/rtnetlink.h>\n#include <linux/dcbnl.h>\n#include <net/dcbevent.h>\n#include <linux/rtnetlink.h>\n#include <linux/module.h>\n#include <net/sock.h>\n\n/* Data Center Bridging (DCB) is a collection of Ethernet enhancements\n * intended to allow network traffic with differing requirements\n * (highly reliable, no drops vs. best effort vs. low latency) to operate\n * and co-exist on Ethernet.  Current DCB features are:\n *\n * Enhanced Transmission Selection (aka Priority Grouping [PG]) - provides a\n *   framework for assigning bandwidth guarantees to traffic classes.\n *\n * Priority-based Flow Control (PFC) - provides a flow control mechanism which\n *   can work independently for each 802.1p priority.\n *\n * Congestion Notification - provides a mechanism for end-to-end congestion\n *   control for protocols which do not have built-in congestion management.\n *\n * More information about the emerging standards for these Ethernet features\n * can be found at: http://www.ieee802.org/1/pages/dcbridges.html\n *\n * This file implements an rtnetlink interface to allow configuration of DCB\n * features for capable devices.\n */\n\nMODULE_AUTHOR(\"Lucy Liu, <lucy.liu@intel.com>\");\nMODULE_DESCRIPTION(\"Data Center Bridging netlink interface\");\nMODULE_LICENSE(\"GPL\");\n\n/**************** DCB attribute policies *************************************/\n\n/* DCB netlink attributes policy */\nstatic const struct nla_policy dcbnl_rtnl_policy[DCB_ATTR_MAX + 1] = {\n\t[DCB_ATTR_IFNAME]      = {.type = NLA_NUL_STRING, .len = IFNAMSIZ - 1},\n\t[DCB_ATTR_STATE]       = {.type = NLA_U8},\n\t[DCB_ATTR_PFC_CFG]     = {.type = NLA_NESTED},\n\t[DCB_ATTR_PG_CFG]      = {.type = NLA_NESTED},\n\t[DCB_ATTR_SET_ALL]     = {.type = NLA_U8},\n\t[DCB_ATTR_PERM_HWADDR] = {.type = NLA_FLAG},\n\t[DCB_ATTR_CAP]         = {.type = NLA_NESTED},\n\t[DCB_ATTR_PFC_STATE]   = {.type = NLA_U8},\n\t[DCB_ATTR_BCN]         = {.type = NLA_NESTED},\n\t[DCB_ATTR_APP]         = {.type = NLA_NESTED},\n\t[DCB_ATTR_IEEE]\t       = {.type = NLA_NESTED},\n\t[DCB_ATTR_DCBX]        = {.type = NLA_U8},\n\t[DCB_ATTR_FEATCFG]     = {.type = NLA_NESTED},\n};\n\n/* DCB priority flow control to User Priority nested attributes */\nstatic const struct nla_policy dcbnl_pfc_up_nest[DCB_PFC_UP_ATTR_MAX + 1] = {\n\t[DCB_PFC_UP_ATTR_0]   = {.type = NLA_U8},\n\t[DCB_PFC_UP_ATTR_1]   = {.type = NLA_U8},\n\t[DCB_PFC_UP_ATTR_2]   = {.type = NLA_U8},\n\t[DCB_PFC_UP_ATTR_3]   = {.type = NLA_U8},\n\t[DCB_PFC_UP_ATTR_4]   = {.type = NLA_U8},\n\t[DCB_PFC_UP_ATTR_5]   = {.type = NLA_U8},\n\t[DCB_PFC_UP_ATTR_6]   = {.type = NLA_U8},\n\t[DCB_PFC_UP_ATTR_7]   = {.type = NLA_U8},\n\t[DCB_PFC_UP_ATTR_ALL] = {.type = NLA_FLAG},\n};\n\n/* DCB priority grouping nested attributes */\nstatic const struct nla_policy dcbnl_pg_nest[DCB_PG_ATTR_MAX + 1] = {\n\t[DCB_PG_ATTR_TC_0]      = {.type = NLA_NESTED},\n\t[DCB_PG_ATTR_TC_1]      = {.type = NLA_NESTED},\n\t[DCB_PG_ATTR_TC_2]      = {.type = NLA_NESTED},\n\t[DCB_PG_ATTR_TC_3]      = {.type = NLA_NESTED},\n\t[DCB_PG_ATTR_TC_4]      = {.type = NLA_NESTED},\n\t[DCB_PG_ATTR_TC_5]      = {.type = NLA_NESTED},\n\t[DCB_PG_ATTR_TC_6]      = {.type = NLA_NESTED},\n\t[DCB_PG_ATTR_TC_7]      = {.type = NLA_NESTED},\n\t[DCB_PG_ATTR_TC_ALL]    = {.type = NLA_NESTED},\n\t[DCB_PG_ATTR_BW_ID_0]   = {.type = NLA_U8},\n\t[DCB_PG_ATTR_BW_ID_1]   = {.type = NLA_U8},\n\t[DCB_PG_ATTR_BW_ID_2]   = {.type = NLA_U8},\n\t[DCB_PG_ATTR_BW_ID_3]   = {.type = NLA_U8},\n\t[DCB_PG_ATTR_BW_ID_4]   = {.type = NLA_U8},\n\t[DCB_PG_ATTR_BW_ID_5]   = {.type = NLA_U8},\n\t[DCB_PG_ATTR_BW_ID_6]   = {.type = NLA_U8},\n\t[DCB_PG_ATTR_BW_ID_7]   = {.type = NLA_U8},\n\t[DCB_PG_ATTR_BW_ID_ALL] = {.type = NLA_FLAG},\n};\n\n/* DCB traffic class nested attributes. */\nstatic const struct nla_policy dcbnl_tc_param_nest[DCB_TC_ATTR_PARAM_MAX + 1] = {\n\t[DCB_TC_ATTR_PARAM_PGID]            = {.type = NLA_U8},\n\t[DCB_TC_ATTR_PARAM_UP_MAPPING]      = {.type = NLA_U8},\n\t[DCB_TC_ATTR_PARAM_STRICT_PRIO]     = {.type = NLA_U8},\n\t[DCB_TC_ATTR_PARAM_BW_PCT]          = {.type = NLA_U8},\n\t[DCB_TC_ATTR_PARAM_ALL]             = {.type = NLA_FLAG},\n};\n\n/* DCB capabilities nested attributes. */\nstatic const struct nla_policy dcbnl_cap_nest[DCB_CAP_ATTR_MAX + 1] = {\n\t[DCB_CAP_ATTR_ALL]     = {.type = NLA_FLAG},\n\t[DCB_CAP_ATTR_PG]      = {.type = NLA_U8},\n\t[DCB_CAP_ATTR_PFC]     = {.type = NLA_U8},\n\t[DCB_CAP_ATTR_UP2TC]   = {.type = NLA_U8},\n\t[DCB_CAP_ATTR_PG_TCS]  = {.type = NLA_U8},\n\t[DCB_CAP_ATTR_PFC_TCS] = {.type = NLA_U8},\n\t[DCB_CAP_ATTR_GSP]     = {.type = NLA_U8},\n\t[DCB_CAP_ATTR_BCN]     = {.type = NLA_U8},\n\t[DCB_CAP_ATTR_DCBX]    = {.type = NLA_U8},\n};\n\n/* DCB capabilities nested attributes. */\nstatic const struct nla_policy dcbnl_numtcs_nest[DCB_NUMTCS_ATTR_MAX + 1] = {\n\t[DCB_NUMTCS_ATTR_ALL]     = {.type = NLA_FLAG},\n\t[DCB_NUMTCS_ATTR_PG]      = {.type = NLA_U8},\n\t[DCB_NUMTCS_ATTR_PFC]     = {.type = NLA_U8},\n};\n\n/* DCB BCN nested attributes. */\nstatic const struct nla_policy dcbnl_bcn_nest[DCB_BCN_ATTR_MAX + 1] = {\n\t[DCB_BCN_ATTR_RP_0]         = {.type = NLA_U8},\n\t[DCB_BCN_ATTR_RP_1]         = {.type = NLA_U8},\n\t[DCB_BCN_ATTR_RP_2]         = {.type = NLA_U8},\n\t[DCB_BCN_ATTR_RP_3]         = {.type = NLA_U8},\n\t[DCB_BCN_ATTR_RP_4]         = {.type = NLA_U8},\n\t[DCB_BCN_ATTR_RP_5]         = {.type = NLA_U8},\n\t[DCB_BCN_ATTR_RP_6]         = {.type = NLA_U8},\n\t[DCB_BCN_ATTR_RP_7]         = {.type = NLA_U8},\n\t[DCB_BCN_ATTR_RP_ALL]       = {.type = NLA_FLAG},\n\t[DCB_BCN_ATTR_BCNA_0]       = {.type = NLA_U32},\n\t[DCB_BCN_ATTR_BCNA_1]       = {.type = NLA_U32},\n\t[DCB_BCN_ATTR_ALPHA]        = {.type = NLA_U32},\n\t[DCB_BCN_ATTR_BETA]         = {.type = NLA_U32},\n\t[DCB_BCN_ATTR_GD]           = {.type = NLA_U32},\n\t[DCB_BCN_ATTR_GI]           = {.type = NLA_U32},\n\t[DCB_BCN_ATTR_TMAX]         = {.type = NLA_U32},\n\t[DCB_BCN_ATTR_TD]           = {.type = NLA_U32},\n\t[DCB_BCN_ATTR_RMIN]         = {.type = NLA_U32},\n\t[DCB_BCN_ATTR_W]            = {.type = NLA_U32},\n\t[DCB_BCN_ATTR_RD]           = {.type = NLA_U32},\n\t[DCB_BCN_ATTR_RU]           = {.type = NLA_U32},\n\t[DCB_BCN_ATTR_WRTT]         = {.type = NLA_U32},\n\t[DCB_BCN_ATTR_RI]           = {.type = NLA_U32},\n\t[DCB_BCN_ATTR_C]            = {.type = NLA_U32},\n\t[DCB_BCN_ATTR_ALL]          = {.type = NLA_FLAG},\n};\n\n/* DCB APP nested attributes. */\nstatic const struct nla_policy dcbnl_app_nest[DCB_APP_ATTR_MAX + 1] = {\n\t[DCB_APP_ATTR_IDTYPE]       = {.type = NLA_U8},\n\t[DCB_APP_ATTR_ID]           = {.type = NLA_U16},\n\t[DCB_APP_ATTR_PRIORITY]     = {.type = NLA_U8},\n};\n\n/* IEEE 802.1Qaz nested attributes. */\nstatic const struct nla_policy dcbnl_ieee_policy[DCB_ATTR_IEEE_MAX + 1] = {\n\t[DCB_ATTR_IEEE_ETS]\t    = {.len = sizeof(struct ieee_ets)},\n\t[DCB_ATTR_IEEE_PFC]\t    = {.len = sizeof(struct ieee_pfc)},\n\t[DCB_ATTR_IEEE_APP_TABLE]   = {.type = NLA_NESTED},\n\t[DCB_ATTR_IEEE_MAXRATE]   = {.len = sizeof(struct ieee_maxrate)},\n};\n\nstatic const struct nla_policy dcbnl_ieee_app[DCB_ATTR_IEEE_APP_MAX + 1] = {\n\t[DCB_ATTR_IEEE_APP]\t    = {.len = sizeof(struct dcb_app)},\n};\n\n/* DCB number of traffic classes nested attributes. */\nstatic const struct nla_policy dcbnl_featcfg_nest[DCB_FEATCFG_ATTR_MAX + 1] = {\n\t[DCB_FEATCFG_ATTR_ALL]      = {.type = NLA_FLAG},\n\t[DCB_FEATCFG_ATTR_PG]       = {.type = NLA_U8},\n\t[DCB_FEATCFG_ATTR_PFC]      = {.type = NLA_U8},\n\t[DCB_FEATCFG_ATTR_APP]      = {.type = NLA_U8},\n};\n\nstatic LIST_HEAD(dcb_app_list);\nstatic DEFINE_SPINLOCK(dcb_lock);\n\nstatic struct sk_buff *dcbnl_newmsg(int type, u8 cmd, u32 port, u32 seq,\n\t\t\t\t    u32 flags, struct nlmsghdr **nlhp)\n{\n\tstruct sk_buff *skb;\n\tstruct dcbmsg *dcb;\n\tstruct nlmsghdr *nlh;\n\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!skb)\n\t\treturn NULL;\n\n\tnlh = nlmsg_put(skb, port, seq, type, sizeof(*dcb), flags);\n\tBUG_ON(!nlh);\n\n\tdcb = nlmsg_data(nlh);\n\tdcb->dcb_family = AF_UNSPEC;\n\tdcb->cmd = cmd;\n\tdcb->dcb_pad = 0;\n\n\tif (nlhp)\n\t\t*nlhp = nlh;\n\n\treturn skb;\n}\n\nstatic int dcbnl_getstate(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t  u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\t/* if (!tb[DCB_ATTR_STATE] || !netdev->dcbnl_ops->getstate) */\n\tif (!netdev->dcbnl_ops->getstate)\n\t\treturn -EOPNOTSUPP;\n\n\treturn nla_put_u8(skb, DCB_ATTR_STATE,\n\t\t\t  netdev->dcbnl_ops->getstate(netdev));\n}\n\nstatic int dcbnl_getpfccfg(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t   u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tstruct nlattr *data[DCB_PFC_UP_ATTR_MAX + 1], *nest;\n\tu8 value;\n\tint ret;\n\tint i;\n\tint getall = 0;\n\n\tif (!tb[DCB_ATTR_PFC_CFG])\n\t\treturn -EINVAL;\n\n\tif (!netdev->dcbnl_ops->getpfccfg)\n\t\treturn -EOPNOTSUPP;\n\n\tret = nla_parse_nested(data, DCB_PFC_UP_ATTR_MAX,\n\t                       tb[DCB_ATTR_PFC_CFG],\n\t                       dcbnl_pfc_up_nest);\n\tif (ret)\n\t\treturn ret;\n\n\tnest = nla_nest_start(skb, DCB_ATTR_PFC_CFG);\n\tif (!nest)\n\t\treturn -EMSGSIZE;\n\n\tif (data[DCB_PFC_UP_ATTR_ALL])\n\t\tgetall = 1;\n\n\tfor (i = DCB_PFC_UP_ATTR_0; i <= DCB_PFC_UP_ATTR_7; i++) {\n\t\tif (!getall && !data[i])\n\t\t\tcontinue;\n\n\t\tnetdev->dcbnl_ops->getpfccfg(netdev, i - DCB_PFC_UP_ATTR_0,\n\t\t                             &value);\n\t\tret = nla_put_u8(skb, i, value);\n\t\tif (ret) {\n\t\t\tnla_nest_cancel(skb, nest);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tnla_nest_end(skb, nest);\n\n\treturn 0;\n}\n\nstatic int dcbnl_getperm_hwaddr(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t\tu32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tu8 perm_addr[MAX_ADDR_LEN];\n\n\tif (!netdev->dcbnl_ops->getpermhwaddr)\n\t\treturn -EOPNOTSUPP;\n\n\tnetdev->dcbnl_ops->getpermhwaddr(netdev, perm_addr);\n\n\treturn nla_put(skb, DCB_ATTR_PERM_HWADDR, sizeof(perm_addr), perm_addr);\n}\n\nstatic int dcbnl_getcap(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\tu32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tstruct nlattr *data[DCB_CAP_ATTR_MAX + 1], *nest;\n\tu8 value;\n\tint ret;\n\tint i;\n\tint getall = 0;\n\n\tif (!tb[DCB_ATTR_CAP])\n\t\treturn -EINVAL;\n\n\tif (!netdev->dcbnl_ops->getcap)\n\t\treturn -EOPNOTSUPP;\n\n\tret = nla_parse_nested(data, DCB_CAP_ATTR_MAX, tb[DCB_ATTR_CAP],\n\t                       dcbnl_cap_nest);\n\tif (ret)\n\t\treturn ret;\n\n\tnest = nla_nest_start(skb, DCB_ATTR_CAP);\n\tif (!nest)\n\t\treturn -EMSGSIZE;\n\n\tif (data[DCB_CAP_ATTR_ALL])\n\t\tgetall = 1;\n\n\tfor (i = DCB_CAP_ATTR_ALL+1; i <= DCB_CAP_ATTR_MAX; i++) {\n\t\tif (!getall && !data[i])\n\t\t\tcontinue;\n\n\t\tif (!netdev->dcbnl_ops->getcap(netdev, i, &value)) {\n\t\t\tret = nla_put_u8(skb, i, value);\n\t\t\tif (ret) {\n\t\t\t\tnla_nest_cancel(skb, nest);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\tnla_nest_end(skb, nest);\n\n\treturn 0;\n}\n\nstatic int dcbnl_getnumtcs(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t   u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tstruct nlattr *data[DCB_NUMTCS_ATTR_MAX + 1], *nest;\n\tu8 value;\n\tint ret;\n\tint i;\n\tint getall = 0;\n\n\tif (!tb[DCB_ATTR_NUMTCS])\n\t\treturn -EINVAL;\n\n\tif (!netdev->dcbnl_ops->getnumtcs)\n\t\treturn -EOPNOTSUPP;\n\n\tret = nla_parse_nested(data, DCB_NUMTCS_ATTR_MAX, tb[DCB_ATTR_NUMTCS],\n\t                       dcbnl_numtcs_nest);\n\tif (ret)\n\t\treturn ret;\n\n\tnest = nla_nest_start(skb, DCB_ATTR_NUMTCS);\n\tif (!nest)\n\t\treturn -EMSGSIZE;\n\n\tif (data[DCB_NUMTCS_ATTR_ALL])\n\t\tgetall = 1;\n\n\tfor (i = DCB_NUMTCS_ATTR_ALL+1; i <= DCB_NUMTCS_ATTR_MAX; i++) {\n\t\tif (!getall && !data[i])\n\t\t\tcontinue;\n\n\t\tret = netdev->dcbnl_ops->getnumtcs(netdev, i, &value);\n\t\tif (!ret) {\n\t\t\tret = nla_put_u8(skb, i, value);\n\t\t\tif (ret) {\n\t\t\t\tnla_nest_cancel(skb, nest);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} else\n\t\t\treturn -EINVAL;\n\t}\n\tnla_nest_end(skb, nest);\n\n\treturn 0;\n}\n\nstatic int dcbnl_setnumtcs(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t   u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tstruct nlattr *data[DCB_NUMTCS_ATTR_MAX + 1];\n\tint ret;\n\tu8 value;\n\tint i;\n\n\tif (!tb[DCB_ATTR_NUMTCS])\n\t\treturn -EINVAL;\n\n\tif (!netdev->dcbnl_ops->setnumtcs)\n\t\treturn -EOPNOTSUPP;\n\n\tret = nla_parse_nested(data, DCB_NUMTCS_ATTR_MAX, tb[DCB_ATTR_NUMTCS],\n\t                       dcbnl_numtcs_nest);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = DCB_NUMTCS_ATTR_ALL+1; i <= DCB_NUMTCS_ATTR_MAX; i++) {\n\t\tif (data[i] == NULL)\n\t\t\tcontinue;\n\n\t\tvalue = nla_get_u8(data[i]);\n\n\t\tret = netdev->dcbnl_ops->setnumtcs(netdev, i, value);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn nla_put_u8(skb, DCB_ATTR_NUMTCS, !!ret);\n}\n\nstatic int dcbnl_getpfcstate(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t     u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tif (!netdev->dcbnl_ops->getpfcstate)\n\t\treturn -EOPNOTSUPP;\n\n\treturn nla_put_u8(skb, DCB_ATTR_PFC_STATE,\n\t\t\t  netdev->dcbnl_ops->getpfcstate(netdev));\n}\n\nstatic int dcbnl_setpfcstate(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t     u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tu8 value;\n\n\tif (!tb[DCB_ATTR_PFC_STATE])\n\t\treturn -EINVAL;\n\n\tif (!netdev->dcbnl_ops->setpfcstate)\n\t\treturn -EOPNOTSUPP;\n\n\tvalue = nla_get_u8(tb[DCB_ATTR_PFC_STATE]);\n\n\tnetdev->dcbnl_ops->setpfcstate(netdev, value);\n\n\treturn nla_put_u8(skb, DCB_ATTR_PFC_STATE, 0);\n}\n\nstatic int dcbnl_getapp(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\tu32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tstruct nlattr *app_nest;\n\tstruct nlattr *app_tb[DCB_APP_ATTR_MAX + 1];\n\tu16 id;\n\tu8 up, idtype;\n\tint ret;\n\n\tif (!tb[DCB_ATTR_APP])\n\t\treturn -EINVAL;\n\n\tret = nla_parse_nested(app_tb, DCB_APP_ATTR_MAX, tb[DCB_ATTR_APP],\n\t                       dcbnl_app_nest);\n\tif (ret)\n\t\treturn ret;\n\n\t/* all must be non-null */\n\tif ((!app_tb[DCB_APP_ATTR_IDTYPE]) ||\n\t    (!app_tb[DCB_APP_ATTR_ID]))\n\t\treturn -EINVAL;\n\n\t/* either by eth type or by socket number */\n\tidtype = nla_get_u8(app_tb[DCB_APP_ATTR_IDTYPE]);\n\tif ((idtype != DCB_APP_IDTYPE_ETHTYPE) &&\n\t    (idtype != DCB_APP_IDTYPE_PORTNUM))\n\t\treturn -EINVAL;\n\n\tid = nla_get_u16(app_tb[DCB_APP_ATTR_ID]);\n\n\tif (netdev->dcbnl_ops->getapp) {\n\t\tup = netdev->dcbnl_ops->getapp(netdev, idtype, id);\n\t} else {\n\t\tstruct dcb_app app = {\n\t\t\t\t\t.selector = idtype,\n\t\t\t\t\t.protocol = id,\n\t\t\t\t     };\n\t\tup = dcb_getapp(netdev, &app);\n\t}\n\n\tapp_nest = nla_nest_start(skb, DCB_ATTR_APP);\n\tif (!app_nest)\n\t\treturn -EMSGSIZE;\n\n\tret = nla_put_u8(skb, DCB_APP_ATTR_IDTYPE, idtype);\n\tif (ret)\n\t\tgoto out_cancel;\n\n\tret = nla_put_u16(skb, DCB_APP_ATTR_ID, id);\n\tif (ret)\n\t\tgoto out_cancel;\n\n\tret = nla_put_u8(skb, DCB_APP_ATTR_PRIORITY, up);\n\tif (ret)\n\t\tgoto out_cancel;\n\n\tnla_nest_end(skb, app_nest);\n\n\treturn 0;\n\nout_cancel:\n\tnla_nest_cancel(skb, app_nest);\n\treturn ret;\n}\n\nstatic int dcbnl_setapp(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\tu32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tint ret;\n\tu16 id;\n\tu8 up, idtype;\n\tstruct nlattr *app_tb[DCB_APP_ATTR_MAX + 1];\n\n\tif (!tb[DCB_ATTR_APP])\n\t\treturn -EINVAL;\n\n\tret = nla_parse_nested(app_tb, DCB_APP_ATTR_MAX, tb[DCB_ATTR_APP],\n\t                       dcbnl_app_nest);\n\tif (ret)\n\t\treturn ret;\n\n\t/* all must be non-null */\n\tif ((!app_tb[DCB_APP_ATTR_IDTYPE]) ||\n\t    (!app_tb[DCB_APP_ATTR_ID]) ||\n\t    (!app_tb[DCB_APP_ATTR_PRIORITY]))\n\t\treturn -EINVAL;\n\n\t/* either by eth type or by socket number */\n\tidtype = nla_get_u8(app_tb[DCB_APP_ATTR_IDTYPE]);\n\tif ((idtype != DCB_APP_IDTYPE_ETHTYPE) &&\n\t    (idtype != DCB_APP_IDTYPE_PORTNUM))\n\t\treturn -EINVAL;\n\n\tid = nla_get_u16(app_tb[DCB_APP_ATTR_ID]);\n\tup = nla_get_u8(app_tb[DCB_APP_ATTR_PRIORITY]);\n\n\tif (netdev->dcbnl_ops->setapp) {\n\t\tret = netdev->dcbnl_ops->setapp(netdev, idtype, id, up);\n\t} else {\n\t\tstruct dcb_app app;\n\t\tapp.selector = idtype;\n\t\tapp.protocol = id;\n\t\tapp.priority = up;\n\t\tret = dcb_setapp(netdev, &app);\n\t}\n\n\tret = nla_put_u8(skb, DCB_ATTR_APP, ret);\n\tdcbnl_cee_notify(netdev, RTM_SETDCB, DCB_CMD_SAPP, seq, 0);\n\n\treturn ret;\n}\n\nstatic int __dcbnl_pg_getcfg(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t     struct nlattr **tb, struct sk_buff *skb, int dir)\n{\n\tstruct nlattr *pg_nest, *param_nest, *data;\n\tstruct nlattr *pg_tb[DCB_PG_ATTR_MAX + 1];\n\tstruct nlattr *param_tb[DCB_TC_ATTR_PARAM_MAX + 1];\n\tu8 prio, pgid, tc_pct, up_map;\n\tint ret;\n\tint getall = 0;\n\tint i;\n\n\tif (!tb[DCB_ATTR_PG_CFG])\n\t\treturn -EINVAL;\n\n\tif (!netdev->dcbnl_ops->getpgtccfgtx ||\n\t    !netdev->dcbnl_ops->getpgtccfgrx ||\n\t    !netdev->dcbnl_ops->getpgbwgcfgtx ||\n\t    !netdev->dcbnl_ops->getpgbwgcfgrx)\n\t\treturn -EOPNOTSUPP;\n\n\tret = nla_parse_nested(pg_tb, DCB_PG_ATTR_MAX,\n\t                       tb[DCB_ATTR_PG_CFG], dcbnl_pg_nest);\n\tif (ret)\n\t\treturn ret;\n\n\tpg_nest = nla_nest_start(skb, DCB_ATTR_PG_CFG);\n\tif (!pg_nest)\n\t\treturn -EMSGSIZE;\n\n\tif (pg_tb[DCB_PG_ATTR_TC_ALL])\n\t\tgetall = 1;\n\n\tfor (i = DCB_PG_ATTR_TC_0; i <= DCB_PG_ATTR_TC_7; i++) {\n\t\tif (!getall && !pg_tb[i])\n\t\t\tcontinue;\n\n\t\tif (pg_tb[DCB_PG_ATTR_TC_ALL])\n\t\t\tdata = pg_tb[DCB_PG_ATTR_TC_ALL];\n\t\telse\n\t\t\tdata = pg_tb[i];\n\t\tret = nla_parse_nested(param_tb, DCB_TC_ATTR_PARAM_MAX,\n\t\t\t\t       data, dcbnl_tc_param_nest);\n\t\tif (ret)\n\t\t\tgoto err_pg;\n\n\t\tparam_nest = nla_nest_start(skb, i);\n\t\tif (!param_nest)\n\t\t\tgoto err_pg;\n\n\t\tpgid = DCB_ATTR_VALUE_UNDEFINED;\n\t\tprio = DCB_ATTR_VALUE_UNDEFINED;\n\t\ttc_pct = DCB_ATTR_VALUE_UNDEFINED;\n\t\tup_map = DCB_ATTR_VALUE_UNDEFINED;\n\n\t\tif (dir) {\n\t\t\t/* Rx */\n\t\t\tnetdev->dcbnl_ops->getpgtccfgrx(netdev,\n\t\t\t\t\t\ti - DCB_PG_ATTR_TC_0, &prio,\n\t\t\t\t\t\t&pgid, &tc_pct, &up_map);\n\t\t} else {\n\t\t\t/* Tx */\n\t\t\tnetdev->dcbnl_ops->getpgtccfgtx(netdev,\n\t\t\t\t\t\ti - DCB_PG_ATTR_TC_0, &prio,\n\t\t\t\t\t\t&pgid, &tc_pct, &up_map);\n\t\t}\n\n\t\tif (param_tb[DCB_TC_ATTR_PARAM_PGID] ||\n\t\t    param_tb[DCB_TC_ATTR_PARAM_ALL]) {\n\t\t\tret = nla_put_u8(skb,\n\t\t\t                 DCB_TC_ATTR_PARAM_PGID, pgid);\n\t\t\tif (ret)\n\t\t\t\tgoto err_param;\n\t\t}\n\t\tif (param_tb[DCB_TC_ATTR_PARAM_UP_MAPPING] ||\n\t\t    param_tb[DCB_TC_ATTR_PARAM_ALL]) {\n\t\t\tret = nla_put_u8(skb,\n\t\t\t                 DCB_TC_ATTR_PARAM_UP_MAPPING, up_map);\n\t\t\tif (ret)\n\t\t\t\tgoto err_param;\n\t\t}\n\t\tif (param_tb[DCB_TC_ATTR_PARAM_STRICT_PRIO] ||\n\t\t    param_tb[DCB_TC_ATTR_PARAM_ALL]) {\n\t\t\tret = nla_put_u8(skb,\n\t\t\t                 DCB_TC_ATTR_PARAM_STRICT_PRIO, prio);\n\t\t\tif (ret)\n\t\t\t\tgoto err_param;\n\t\t}\n\t\tif (param_tb[DCB_TC_ATTR_PARAM_BW_PCT] ||\n\t\t    param_tb[DCB_TC_ATTR_PARAM_ALL]) {\n\t\t\tret = nla_put_u8(skb, DCB_TC_ATTR_PARAM_BW_PCT,\n\t\t\t                 tc_pct);\n\t\t\tif (ret)\n\t\t\t\tgoto err_param;\n\t\t}\n\t\tnla_nest_end(skb, param_nest);\n\t}\n\n\tif (pg_tb[DCB_PG_ATTR_BW_ID_ALL])\n\t\tgetall = 1;\n\telse\n\t\tgetall = 0;\n\n\tfor (i = DCB_PG_ATTR_BW_ID_0; i <= DCB_PG_ATTR_BW_ID_7; i++) {\n\t\tif (!getall && !pg_tb[i])\n\t\t\tcontinue;\n\n\t\ttc_pct = DCB_ATTR_VALUE_UNDEFINED;\n\n\t\tif (dir) {\n\t\t\t/* Rx */\n\t\t\tnetdev->dcbnl_ops->getpgbwgcfgrx(netdev,\n\t\t\t\t\ti - DCB_PG_ATTR_BW_ID_0, &tc_pct);\n\t\t} else {\n\t\t\t/* Tx */\n\t\t\tnetdev->dcbnl_ops->getpgbwgcfgtx(netdev,\n\t\t\t\t\ti - DCB_PG_ATTR_BW_ID_0, &tc_pct);\n\t\t}\n\t\tret = nla_put_u8(skb, i, tc_pct);\n\t\tif (ret)\n\t\t\tgoto err_pg;\n\t}\n\n\tnla_nest_end(skb, pg_nest);\n\n\treturn 0;\n\nerr_param:\n\tnla_nest_cancel(skb, param_nest);\nerr_pg:\n\tnla_nest_cancel(skb, pg_nest);\n\n\treturn -EMSGSIZE;\n}\n\nstatic int dcbnl_pgtx_getcfg(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t     u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\treturn __dcbnl_pg_getcfg(netdev, nlh, tb, skb, 0);\n}\n\nstatic int dcbnl_pgrx_getcfg(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t     u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\treturn __dcbnl_pg_getcfg(netdev, nlh, tb, skb, 1);\n}\n\nstatic int dcbnl_setstate(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t  u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tu8 value;\n\n\tif (!tb[DCB_ATTR_STATE])\n\t\treturn -EINVAL;\n\n\tif (!netdev->dcbnl_ops->setstate)\n\t\treturn -EOPNOTSUPP;\n\n\tvalue = nla_get_u8(tb[DCB_ATTR_STATE]);\n\n\treturn nla_put_u8(skb, DCB_ATTR_STATE,\n\t\t\t  netdev->dcbnl_ops->setstate(netdev, value));\n}\n\nstatic int dcbnl_setpfccfg(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t   u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tstruct nlattr *data[DCB_PFC_UP_ATTR_MAX + 1];\n\tint i;\n\tint ret;\n\tu8 value;\n\n\tif (!tb[DCB_ATTR_PFC_CFG])\n\t\treturn -EINVAL;\n\n\tif (!netdev->dcbnl_ops->setpfccfg)\n\t\treturn -EOPNOTSUPP;\n\n\tret = nla_parse_nested(data, DCB_PFC_UP_ATTR_MAX,\n\t                       tb[DCB_ATTR_PFC_CFG],\n\t                       dcbnl_pfc_up_nest);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = DCB_PFC_UP_ATTR_0; i <= DCB_PFC_UP_ATTR_7; i++) {\n\t\tif (data[i] == NULL)\n\t\t\tcontinue;\n\t\tvalue = nla_get_u8(data[i]);\n\t\tnetdev->dcbnl_ops->setpfccfg(netdev,\n\t\t\tdata[i]->nla_type - DCB_PFC_UP_ATTR_0, value);\n\t}\n\n\treturn nla_put_u8(skb, DCB_ATTR_PFC_CFG, 0);\n}\n\nstatic int dcbnl_setall(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\tu32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tint ret;\n\n\tif (!tb[DCB_ATTR_SET_ALL])\n\t\treturn -EINVAL;\n\n\tif (!netdev->dcbnl_ops->setall)\n\t\treturn -EOPNOTSUPP;\n\n\tret = nla_put_u8(skb, DCB_ATTR_SET_ALL,\n\t\t\t netdev->dcbnl_ops->setall(netdev));\n\tdcbnl_cee_notify(netdev, RTM_SETDCB, DCB_CMD_SET_ALL, seq, 0);\n\n\treturn ret;\n}\n\nstatic int __dcbnl_pg_setcfg(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t     u32 seq, struct nlattr **tb, struct sk_buff *skb,\n\t\t\t     int dir)\n{\n\tstruct nlattr *pg_tb[DCB_PG_ATTR_MAX + 1];\n\tstruct nlattr *param_tb[DCB_TC_ATTR_PARAM_MAX + 1];\n\tint ret;\n\tint i;\n\tu8 pgid;\n\tu8 up_map;\n\tu8 prio;\n\tu8 tc_pct;\n\n\tif (!tb[DCB_ATTR_PG_CFG])\n\t\treturn -EINVAL;\n\n\tif (!netdev->dcbnl_ops->setpgtccfgtx ||\n\t    !netdev->dcbnl_ops->setpgtccfgrx ||\n\t    !netdev->dcbnl_ops->setpgbwgcfgtx ||\n\t    !netdev->dcbnl_ops->setpgbwgcfgrx)\n\t\treturn -EOPNOTSUPP;\n\n\tret = nla_parse_nested(pg_tb, DCB_PG_ATTR_MAX,\n\t                       tb[DCB_ATTR_PG_CFG], dcbnl_pg_nest);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = DCB_PG_ATTR_TC_0; i <= DCB_PG_ATTR_TC_7; i++) {\n\t\tif (!pg_tb[i])\n\t\t\tcontinue;\n\n\t\tret = nla_parse_nested(param_tb, DCB_TC_ATTR_PARAM_MAX,\n\t\t                       pg_tb[i], dcbnl_tc_param_nest);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tpgid = DCB_ATTR_VALUE_UNDEFINED;\n\t\tprio = DCB_ATTR_VALUE_UNDEFINED;\n\t\ttc_pct = DCB_ATTR_VALUE_UNDEFINED;\n\t\tup_map = DCB_ATTR_VALUE_UNDEFINED;\n\n\t\tif (param_tb[DCB_TC_ATTR_PARAM_STRICT_PRIO])\n\t\t\tprio =\n\t\t\t    nla_get_u8(param_tb[DCB_TC_ATTR_PARAM_STRICT_PRIO]);\n\n\t\tif (param_tb[DCB_TC_ATTR_PARAM_PGID])\n\t\t\tpgid = nla_get_u8(param_tb[DCB_TC_ATTR_PARAM_PGID]);\n\n\t\tif (param_tb[DCB_TC_ATTR_PARAM_BW_PCT])\n\t\t\ttc_pct = nla_get_u8(param_tb[DCB_TC_ATTR_PARAM_BW_PCT]);\n\n\t\tif (param_tb[DCB_TC_ATTR_PARAM_UP_MAPPING])\n\t\t\tup_map =\n\t\t\t     nla_get_u8(param_tb[DCB_TC_ATTR_PARAM_UP_MAPPING]);\n\n\t\t/* dir: Tx = 0, Rx = 1 */\n\t\tif (dir) {\n\t\t\t/* Rx */\n\t\t\tnetdev->dcbnl_ops->setpgtccfgrx(netdev,\n\t\t\t\ti - DCB_PG_ATTR_TC_0,\n\t\t\t\tprio, pgid, tc_pct, up_map);\n\t\t} else {\n\t\t\t/* Tx */\n\t\t\tnetdev->dcbnl_ops->setpgtccfgtx(netdev,\n\t\t\t\ti - DCB_PG_ATTR_TC_0,\n\t\t\t\tprio, pgid, tc_pct, up_map);\n\t\t}\n\t}\n\n\tfor (i = DCB_PG_ATTR_BW_ID_0; i <= DCB_PG_ATTR_BW_ID_7; i++) {\n\t\tif (!pg_tb[i])\n\t\t\tcontinue;\n\n\t\ttc_pct = nla_get_u8(pg_tb[i]);\n\n\t\t/* dir: Tx = 0, Rx = 1 */\n\t\tif (dir) {\n\t\t\t/* Rx */\n\t\t\tnetdev->dcbnl_ops->setpgbwgcfgrx(netdev,\n\t\t\t\t\t i - DCB_PG_ATTR_BW_ID_0, tc_pct);\n\t\t} else {\n\t\t\t/* Tx */\n\t\t\tnetdev->dcbnl_ops->setpgbwgcfgtx(netdev,\n\t\t\t\t\t i - DCB_PG_ATTR_BW_ID_0, tc_pct);\n\t\t}\n\t}\n\n\treturn nla_put_u8(skb, DCB_ATTR_PG_CFG, 0);\n}\n\nstatic int dcbnl_pgtx_setcfg(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t     u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\treturn __dcbnl_pg_setcfg(netdev, nlh, seq, tb, skb, 0);\n}\n\nstatic int dcbnl_pgrx_setcfg(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t     u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\treturn __dcbnl_pg_setcfg(netdev, nlh, seq, tb, skb, 1);\n}\n\nstatic int dcbnl_bcn_getcfg(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t    u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tstruct nlattr *bcn_nest;\n\tstruct nlattr *bcn_tb[DCB_BCN_ATTR_MAX + 1];\n\tu8 value_byte;\n\tu32 value_integer;\n\tint ret;\n\tbool getall = false;\n\tint i;\n\n\tif (!tb[DCB_ATTR_BCN])\n\t\treturn -EINVAL;\n\n\tif (!netdev->dcbnl_ops->getbcnrp ||\n\t    !netdev->dcbnl_ops->getbcncfg)\n\t\treturn -EOPNOTSUPP;\n\n\tret = nla_parse_nested(bcn_tb, DCB_BCN_ATTR_MAX,\n\t                       tb[DCB_ATTR_BCN], dcbnl_bcn_nest);\n\tif (ret)\n\t\treturn ret;\n\n\tbcn_nest = nla_nest_start(skb, DCB_ATTR_BCN);\n\tif (!bcn_nest)\n\t\treturn -EMSGSIZE;\n\n\tif (bcn_tb[DCB_BCN_ATTR_ALL])\n\t\tgetall = true;\n\n\tfor (i = DCB_BCN_ATTR_RP_0; i <= DCB_BCN_ATTR_RP_7; i++) {\n\t\tif (!getall && !bcn_tb[i])\n\t\t\tcontinue;\n\n\t\tnetdev->dcbnl_ops->getbcnrp(netdev, i - DCB_BCN_ATTR_RP_0,\n\t\t                            &value_byte);\n\t\tret = nla_put_u8(skb, i, value_byte);\n\t\tif (ret)\n\t\t\tgoto err_bcn;\n\t}\n\n\tfor (i = DCB_BCN_ATTR_BCNA_0; i <= DCB_BCN_ATTR_RI; i++) {\n\t\tif (!getall && !bcn_tb[i])\n\t\t\tcontinue;\n\n\t\tnetdev->dcbnl_ops->getbcncfg(netdev, i,\n\t\t                             &value_integer);\n\t\tret = nla_put_u32(skb, i, value_integer);\n\t\tif (ret)\n\t\t\tgoto err_bcn;\n\t}\n\n\tnla_nest_end(skb, bcn_nest);\n\n\treturn 0;\n\nerr_bcn:\n\tnla_nest_cancel(skb, bcn_nest);\n\treturn ret;\n}\n\nstatic int dcbnl_bcn_setcfg(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t    u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tstruct nlattr *data[DCB_BCN_ATTR_MAX + 1];\n\tint i;\n\tint ret;\n\tu8 value_byte;\n\tu32 value_int;\n\n\tif (!tb[DCB_ATTR_BCN])\n\t\treturn -EINVAL;\n\n\tif (!netdev->dcbnl_ops->setbcncfg ||\n\t    !netdev->dcbnl_ops->setbcnrp)\n\t\treturn -EOPNOTSUPP;\n\n\tret = nla_parse_nested(data, DCB_BCN_ATTR_MAX,\n\t                       tb[DCB_ATTR_BCN],\n\t                       dcbnl_pfc_up_nest);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = DCB_BCN_ATTR_RP_0; i <= DCB_BCN_ATTR_RP_7; i++) {\n\t\tif (data[i] == NULL)\n\t\t\tcontinue;\n\t\tvalue_byte = nla_get_u8(data[i]);\n\t\tnetdev->dcbnl_ops->setbcnrp(netdev,\n\t\t\tdata[i]->nla_type - DCB_BCN_ATTR_RP_0, value_byte);\n\t}\n\n\tfor (i = DCB_BCN_ATTR_BCNA_0; i <= DCB_BCN_ATTR_RI; i++) {\n\t\tif (data[i] == NULL)\n\t\t\tcontinue;\n\t\tvalue_int = nla_get_u32(data[i]);\n\t\tnetdev->dcbnl_ops->setbcncfg(netdev,\n\t                                     i, value_int);\n\t}\n\n\treturn nla_put_u8(skb, DCB_ATTR_BCN, 0);\n}\n\nstatic int dcbnl_build_peer_app(struct net_device *netdev, struct sk_buff* skb,\n\t\t\t\tint app_nested_type, int app_info_type,\n\t\t\t\tint app_entry_type)\n{\n\tstruct dcb_peer_app_info info;\n\tstruct dcb_app *table = NULL;\n\tconst struct dcbnl_rtnl_ops *ops = netdev->dcbnl_ops;\n\tu16 app_count;\n\tint err;\n\n\n\t/**\n\t * retrieve the peer app configuration form the driver. If the driver\n\t * handlers fail exit without doing anything\n\t */\n\terr = ops->peer_getappinfo(netdev, &info, &app_count);\n\tif (!err && app_count) {\n\t\ttable = kmalloc(sizeof(struct dcb_app) * app_count, GFP_KERNEL);\n\t\tif (!table)\n\t\t\treturn -ENOMEM;\n\n\t\terr = ops->peer_getapptable(netdev, table);\n\t}\n\n\tif (!err) {\n\t\tu16 i;\n\t\tstruct nlattr *app;\n\n\t\t/**\n\t\t * build the message, from here on the only possible failure\n\t\t * is due to the skb size\n\t\t */\n\t\terr = -EMSGSIZE;\n\n\t\tapp = nla_nest_start(skb, app_nested_type);\n\t\tif (!app)\n\t\t\tgoto nla_put_failure;\n\n\t\tif (app_info_type &&\n\t\t    nla_put(skb, app_info_type, sizeof(info), &info))\n\t\t\tgoto nla_put_failure;\n\n\t\tfor (i = 0; i < app_count; i++) {\n\t\t\tif (nla_put(skb, app_entry_type, sizeof(struct dcb_app),\n\t\t\t\t    &table[i]))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\t\tnla_nest_end(skb, app);\n\t}\n\terr = 0;\n\nnla_put_failure:\n\tkfree(table);\n\treturn err;\n}\n\n/* Handle IEEE 802.1Qaz GET commands. */\nstatic int dcbnl_ieee_fill(struct sk_buff *skb, struct net_device *netdev)\n{\n\tstruct nlattr *ieee, *app;\n\tstruct dcb_app_type *itr;\n\tconst struct dcbnl_rtnl_ops *ops = netdev->dcbnl_ops;\n\tint dcbx;\n\tint err;\n\n\tif (nla_put_string(skb, DCB_ATTR_IFNAME, netdev->name))\n\t\treturn -EMSGSIZE;\n\n\tieee = nla_nest_start(skb, DCB_ATTR_IEEE);\n\tif (!ieee)\n\t\treturn -EMSGSIZE;\n\n\tif (ops->ieee_getets) {\n\t\tstruct ieee_ets ets;\n\t\terr = ops->ieee_getets(netdev, &ets);\n\t\tif (!err &&\n\t\t    nla_put(skb, DCB_ATTR_IEEE_ETS, sizeof(ets), &ets))\n\t\t\treturn -EMSGSIZE;\n\t}\n\n\tif (ops->ieee_getmaxrate) {\n\t\tstruct ieee_maxrate maxrate;\n\t\terr = ops->ieee_getmaxrate(netdev, &maxrate);\n\t\tif (!err) {\n\t\t\terr = nla_put(skb, DCB_ATTR_IEEE_MAXRATE,\n\t\t\t\t      sizeof(maxrate), &maxrate);\n\t\t\tif (err)\n\t\t\t\treturn -EMSGSIZE;\n\t\t}\n\t}\n\n\tif (ops->ieee_getpfc) {\n\t\tstruct ieee_pfc pfc;\n\t\terr = ops->ieee_getpfc(netdev, &pfc);\n\t\tif (!err &&\n\t\t    nla_put(skb, DCB_ATTR_IEEE_PFC, sizeof(pfc), &pfc))\n\t\t\treturn -EMSGSIZE;\n\t}\n\n\tapp = nla_nest_start(skb, DCB_ATTR_IEEE_APP_TABLE);\n\tif (!app)\n\t\treturn -EMSGSIZE;\n\n\tspin_lock(&dcb_lock);\n\tlist_for_each_entry(itr, &dcb_app_list, list) {\n\t\tif (itr->ifindex == netdev->ifindex) {\n\t\t\terr = nla_put(skb, DCB_ATTR_IEEE_APP, sizeof(itr->app),\n\t\t\t\t\t &itr->app);\n\t\t\tif (err) {\n\t\t\t\tspin_unlock(&dcb_lock);\n\t\t\t\treturn -EMSGSIZE;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (netdev->dcbnl_ops->getdcbx)\n\t\tdcbx = netdev->dcbnl_ops->getdcbx(netdev);\n\telse\n\t\tdcbx = -EOPNOTSUPP;\n\n\tspin_unlock(&dcb_lock);\n\tnla_nest_end(skb, app);\n\n\t/* get peer info if available */\n\tif (ops->ieee_peer_getets) {\n\t\tstruct ieee_ets ets;\n\t\terr = ops->ieee_peer_getets(netdev, &ets);\n\t\tif (!err &&\n\t\t    nla_put(skb, DCB_ATTR_IEEE_PEER_ETS, sizeof(ets), &ets))\n\t\t\treturn -EMSGSIZE;\n\t}\n\n\tif (ops->ieee_peer_getpfc) {\n\t\tstruct ieee_pfc pfc;\n\t\terr = ops->ieee_peer_getpfc(netdev, &pfc);\n\t\tif (!err &&\n\t\t    nla_put(skb, DCB_ATTR_IEEE_PEER_PFC, sizeof(pfc), &pfc))\n\t\t\treturn -EMSGSIZE;\n\t}\n\n\tif (ops->peer_getappinfo && ops->peer_getapptable) {\n\t\terr = dcbnl_build_peer_app(netdev, skb,\n\t\t\t\t\t   DCB_ATTR_IEEE_PEER_APP,\n\t\t\t\t\t   DCB_ATTR_IEEE_APP_UNSPEC,\n\t\t\t\t\t   DCB_ATTR_IEEE_APP);\n\t\tif (err)\n\t\t\treturn -EMSGSIZE;\n\t}\n\n\tnla_nest_end(skb, ieee);\n\tif (dcbx >= 0) {\n\t\terr = nla_put_u8(skb, DCB_ATTR_DCBX, dcbx);\n\t\tif (err)\n\t\t\treturn -EMSGSIZE;\n\t}\n\n\treturn 0;\n}\n\nstatic int dcbnl_cee_pg_fill(struct sk_buff *skb, struct net_device *dev,\n\t\t\t     int dir)\n{\n\tu8 pgid, up_map, prio, tc_pct;\n\tconst struct dcbnl_rtnl_ops *ops = dev->dcbnl_ops;\n\tint i = dir ? DCB_ATTR_CEE_TX_PG : DCB_ATTR_CEE_RX_PG;\n\tstruct nlattr *pg = nla_nest_start(skb, i);\n\n\tif (!pg)\n\t\treturn -EMSGSIZE;\n\n\tfor (i = DCB_PG_ATTR_TC_0; i <= DCB_PG_ATTR_TC_7; i++) {\n\t\tstruct nlattr *tc_nest = nla_nest_start(skb, i);\n\n\t\tif (!tc_nest)\n\t\t\treturn -EMSGSIZE;\n\n\t\tpgid = DCB_ATTR_VALUE_UNDEFINED;\n\t\tprio = DCB_ATTR_VALUE_UNDEFINED;\n\t\ttc_pct = DCB_ATTR_VALUE_UNDEFINED;\n\t\tup_map = DCB_ATTR_VALUE_UNDEFINED;\n\n\t\tif (!dir)\n\t\t\tops->getpgtccfgrx(dev, i - DCB_PG_ATTR_TC_0,\n\t\t\t\t\t  &prio, &pgid, &tc_pct, &up_map);\n\t\telse\n\t\t\tops->getpgtccfgtx(dev, i - DCB_PG_ATTR_TC_0,\n\t\t\t\t\t  &prio, &pgid, &tc_pct, &up_map);\n\n\t\tif (nla_put_u8(skb, DCB_TC_ATTR_PARAM_PGID, pgid) ||\n\t\t    nla_put_u8(skb, DCB_TC_ATTR_PARAM_UP_MAPPING, up_map) ||\n\t\t    nla_put_u8(skb, DCB_TC_ATTR_PARAM_STRICT_PRIO, prio) ||\n\t\t    nla_put_u8(skb, DCB_TC_ATTR_PARAM_BW_PCT, tc_pct))\n\t\t\treturn -EMSGSIZE;\n\t\tnla_nest_end(skb, tc_nest);\n\t}\n\n\tfor (i = DCB_PG_ATTR_BW_ID_0; i <= DCB_PG_ATTR_BW_ID_7; i++) {\n\t\ttc_pct = DCB_ATTR_VALUE_UNDEFINED;\n\n\t\tif (!dir)\n\t\t\tops->getpgbwgcfgrx(dev, i - DCB_PG_ATTR_BW_ID_0,\n\t\t\t\t\t   &tc_pct);\n\t\telse\n\t\t\tops->getpgbwgcfgtx(dev, i - DCB_PG_ATTR_BW_ID_0,\n\t\t\t\t\t   &tc_pct);\n\t\tif (nla_put_u8(skb, i, tc_pct))\n\t\t\treturn -EMSGSIZE;\n\t}\n\tnla_nest_end(skb, pg);\n\treturn 0;\n}\n\nstatic int dcbnl_cee_fill(struct sk_buff *skb, struct net_device *netdev)\n{\n\tstruct nlattr *cee, *app;\n\tstruct dcb_app_type *itr;\n\tconst struct dcbnl_rtnl_ops *ops = netdev->dcbnl_ops;\n\tint dcbx, i, err = -EMSGSIZE;\n\tu8 value;\n\n\tif (nla_put_string(skb, DCB_ATTR_IFNAME, netdev->name))\n\t\tgoto nla_put_failure;\n\tcee = nla_nest_start(skb, DCB_ATTR_CEE);\n\tif (!cee)\n\t\tgoto nla_put_failure;\n\n\t/* local pg */\n\tif (ops->getpgtccfgtx && ops->getpgbwgcfgtx) {\n\t\terr = dcbnl_cee_pg_fill(skb, netdev, 1);\n\t\tif (err)\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (ops->getpgtccfgrx && ops->getpgbwgcfgrx) {\n\t\terr = dcbnl_cee_pg_fill(skb, netdev, 0);\n\t\tif (err)\n\t\t\tgoto nla_put_failure;\n\t}\n\n\t/* local pfc */\n\tif (ops->getpfccfg) {\n\t\tstruct nlattr *pfc_nest = nla_nest_start(skb, DCB_ATTR_CEE_PFC);\n\n\t\tif (!pfc_nest)\n\t\t\tgoto nla_put_failure;\n\n\t\tfor (i = DCB_PFC_UP_ATTR_0; i <= DCB_PFC_UP_ATTR_7; i++) {\n\t\t\tops->getpfccfg(netdev, i - DCB_PFC_UP_ATTR_0, &value);\n\t\t\tif (nla_put_u8(skb, i, value))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\t\tnla_nest_end(skb, pfc_nest);\n\t}\n\n\t/* local app */\n\tspin_lock(&dcb_lock);\n\tapp = nla_nest_start(skb, DCB_ATTR_CEE_APP_TABLE);\n\tif (!app)\n\t\tgoto dcb_unlock;\n\n\tlist_for_each_entry(itr, &dcb_app_list, list) {\n\t\tif (itr->ifindex == netdev->ifindex) {\n\t\t\tstruct nlattr *app_nest = nla_nest_start(skb,\n\t\t\t\t\t\t\t\t DCB_ATTR_APP);\n\t\t\tif (!app_nest)\n\t\t\t\tgoto dcb_unlock;\n\n\t\t\terr = nla_put_u8(skb, DCB_APP_ATTR_IDTYPE,\n\t\t\t\t\t itr->app.selector);\n\t\t\tif (err)\n\t\t\t\tgoto dcb_unlock;\n\n\t\t\terr = nla_put_u16(skb, DCB_APP_ATTR_ID,\n\t\t\t\t\t  itr->app.protocol);\n\t\t\tif (err)\n\t\t\t\tgoto dcb_unlock;\n\n\t\t\terr = nla_put_u8(skb, DCB_APP_ATTR_PRIORITY,\n\t\t\t\t\t itr->app.priority);\n\t\t\tif (err)\n\t\t\t\tgoto dcb_unlock;\n\n\t\t\tnla_nest_end(skb, app_nest);\n\t\t}\n\t}\n\tnla_nest_end(skb, app);\n\n\tif (netdev->dcbnl_ops->getdcbx)\n\t\tdcbx = netdev->dcbnl_ops->getdcbx(netdev);\n\telse\n\t\tdcbx = -EOPNOTSUPP;\n\n\tspin_unlock(&dcb_lock);\n\n\t/* features flags */\n\tif (ops->getfeatcfg) {\n\t\tstruct nlattr *feat = nla_nest_start(skb, DCB_ATTR_CEE_FEAT);\n\t\tif (!feat)\n\t\t\tgoto nla_put_failure;\n\n\t\tfor (i = DCB_FEATCFG_ATTR_ALL + 1; i <= DCB_FEATCFG_ATTR_MAX;\n\t\t     i++)\n\t\t\tif (!ops->getfeatcfg(netdev, i, &value) &&\n\t\t\t    nla_put_u8(skb, i, value))\n\t\t\t\tgoto nla_put_failure;\n\n\t\tnla_nest_end(skb, feat);\n\t}\n\n\t/* peer info if available */\n\tif (ops->cee_peer_getpg) {\n\t\tstruct cee_pg pg;\n\t\terr = ops->cee_peer_getpg(netdev, &pg);\n\t\tif (!err &&\n\t\t    nla_put(skb, DCB_ATTR_CEE_PEER_PG, sizeof(pg), &pg))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (ops->cee_peer_getpfc) {\n\t\tstruct cee_pfc pfc;\n\t\terr = ops->cee_peer_getpfc(netdev, &pfc);\n\t\tif (!err &&\n\t\t    nla_put(skb, DCB_ATTR_CEE_PEER_PFC, sizeof(pfc), &pfc))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (ops->peer_getappinfo && ops->peer_getapptable) {\n\t\terr = dcbnl_build_peer_app(netdev, skb,\n\t\t\t\t\t   DCB_ATTR_CEE_PEER_APP_TABLE,\n\t\t\t\t\t   DCB_ATTR_CEE_PEER_APP_INFO,\n\t\t\t\t\t   DCB_ATTR_CEE_PEER_APP);\n\t\tif (err)\n\t\t\tgoto nla_put_failure;\n\t}\n\tnla_nest_end(skb, cee);\n\n\t/* DCBX state */\n\tif (dcbx >= 0) {\n\t\terr = nla_put_u8(skb, DCB_ATTR_DCBX, dcbx);\n\t\tif (err)\n\t\t\tgoto nla_put_failure;\n\t}\n\treturn 0;\n\ndcb_unlock:\n\tspin_unlock(&dcb_lock);\nnla_put_failure:\n\treturn err;\n}\n\nstatic int dcbnl_notify(struct net_device *dev, int event, int cmd,\n\t\t\tu32 seq, u32 portid, int dcbx_ver)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\tconst struct dcbnl_rtnl_ops *ops = dev->dcbnl_ops;\n\tint err;\n\n\tif (!ops)\n\t\treturn -EOPNOTSUPP;\n\n\tskb = dcbnl_newmsg(event, cmd, portid, seq, 0, &nlh);\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\n\tif (dcbx_ver == DCB_CAP_DCBX_VER_IEEE)\n\t\terr = dcbnl_ieee_fill(skb, dev);\n\telse\n\t\terr = dcbnl_cee_fill(skb, dev);\n\n\tif (err < 0) {\n\t\t/* Report error to broadcast listeners */\n\t\tnlmsg_free(skb);\n\t\trtnl_set_sk_err(net, RTNLGRP_DCB, err);\n\t} else {\n\t\t/* End nlmsg and notify broadcast listeners */\n\t\tnlmsg_end(skb, nlh);\n\t\trtnl_notify(skb, net, 0, RTNLGRP_DCB, NULL, GFP_KERNEL);\n\t}\n\n\treturn err;\n}\n\nint dcbnl_ieee_notify(struct net_device *dev, int event, int cmd,\n\t\t      u32 seq, u32 portid)\n{\n\treturn dcbnl_notify(dev, event, cmd, seq, portid, DCB_CAP_DCBX_VER_IEEE);\n}\nEXPORT_SYMBOL(dcbnl_ieee_notify);\n\nint dcbnl_cee_notify(struct net_device *dev, int event, int cmd,\n\t\t     u32 seq, u32 portid)\n{\n\treturn dcbnl_notify(dev, event, cmd, seq, portid, DCB_CAP_DCBX_VER_CEE);\n}\nEXPORT_SYMBOL(dcbnl_cee_notify);\n\n/* Handle IEEE 802.1Qaz SET commands. If any requested operation can not\n * be completed the entire msg is aborted and error value is returned.\n * No attempt is made to reconcile the case where only part of the\n * cmd can be completed.\n */\nstatic int dcbnl_ieee_set(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t  u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tconst struct dcbnl_rtnl_ops *ops = netdev->dcbnl_ops;\n\tstruct nlattr *ieee[DCB_ATTR_IEEE_MAX + 1];\n\tint err;\n\n\tif (!ops)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!tb[DCB_ATTR_IEEE])\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested(ieee, DCB_ATTR_IEEE_MAX,\n\t\t\t       tb[DCB_ATTR_IEEE], dcbnl_ieee_policy);\n\tif (err)\n\t\treturn err;\n\n\tif (ieee[DCB_ATTR_IEEE_ETS] && ops->ieee_setets) {\n\t\tstruct ieee_ets *ets = nla_data(ieee[DCB_ATTR_IEEE_ETS]);\n\t\terr = ops->ieee_setets(netdev, ets);\n\t\tif (err)\n\t\t\tgoto err;\n\t}\n\n\tif (ieee[DCB_ATTR_IEEE_MAXRATE] && ops->ieee_setmaxrate) {\n\t\tstruct ieee_maxrate *maxrate =\n\t\t\tnla_data(ieee[DCB_ATTR_IEEE_MAXRATE]);\n\t\terr = ops->ieee_setmaxrate(netdev, maxrate);\n\t\tif (err)\n\t\t\tgoto err;\n\t}\n\n\tif (ieee[DCB_ATTR_IEEE_PFC] && ops->ieee_setpfc) {\n\t\tstruct ieee_pfc *pfc = nla_data(ieee[DCB_ATTR_IEEE_PFC]);\n\t\terr = ops->ieee_setpfc(netdev, pfc);\n\t\tif (err)\n\t\t\tgoto err;\n\t}\n\n\tif (ieee[DCB_ATTR_IEEE_APP_TABLE]) {\n\t\tstruct nlattr *attr;\n\t\tint rem;\n\n\t\tnla_for_each_nested(attr, ieee[DCB_ATTR_IEEE_APP_TABLE], rem) {\n\t\t\tstruct dcb_app *app_data;\n\t\t\tif (nla_type(attr) != DCB_ATTR_IEEE_APP)\n\t\t\t\tcontinue;\n\t\t\tapp_data = nla_data(attr);\n\t\t\tif (ops->ieee_setapp)\n\t\t\t\terr = ops->ieee_setapp(netdev, app_data);\n\t\t\telse\n\t\t\t\terr = dcb_ieee_setapp(netdev, app_data);\n\t\t\tif (err)\n\t\t\t\tgoto err;\n\t\t}\n\t}\n\nerr:\n\terr = nla_put_u8(skb, DCB_ATTR_IEEE, err);\n\tdcbnl_ieee_notify(netdev, RTM_SETDCB, DCB_CMD_IEEE_SET, seq, 0);\n\treturn err;\n}\n\nstatic int dcbnl_ieee_get(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t  u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tconst struct dcbnl_rtnl_ops *ops = netdev->dcbnl_ops;\n\n\tif (!ops)\n\t\treturn -EOPNOTSUPP;\n\n\treturn dcbnl_ieee_fill(skb, netdev);\n}\n\nstatic int dcbnl_ieee_del(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t  u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tconst struct dcbnl_rtnl_ops *ops = netdev->dcbnl_ops;\n\tstruct nlattr *ieee[DCB_ATTR_IEEE_MAX + 1];\n\tint err;\n\n\tif (!ops)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!tb[DCB_ATTR_IEEE])\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested(ieee, DCB_ATTR_IEEE_MAX,\n\t\t\t       tb[DCB_ATTR_IEEE], dcbnl_ieee_policy);\n\tif (err)\n\t\treturn err;\n\n\tif (ieee[DCB_ATTR_IEEE_APP_TABLE]) {\n\t\tstruct nlattr *attr;\n\t\tint rem;\n\n\t\tnla_for_each_nested(attr, ieee[DCB_ATTR_IEEE_APP_TABLE], rem) {\n\t\t\tstruct dcb_app *app_data;\n\n\t\t\tif (nla_type(attr) != DCB_ATTR_IEEE_APP)\n\t\t\t\tcontinue;\n\t\t\tapp_data = nla_data(attr);\n\t\t\tif (ops->ieee_delapp)\n\t\t\t\terr = ops->ieee_delapp(netdev, app_data);\n\t\t\telse\n\t\t\t\terr = dcb_ieee_delapp(netdev, app_data);\n\t\t\tif (err)\n\t\t\t\tgoto err;\n\t\t}\n\t}\n\nerr:\n\terr = nla_put_u8(skb, DCB_ATTR_IEEE, err);\n\tdcbnl_ieee_notify(netdev, RTM_SETDCB, DCB_CMD_IEEE_DEL, seq, 0);\n\treturn err;\n}\n\n\n/* DCBX configuration */\nstatic int dcbnl_getdcbx(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tif (!netdev->dcbnl_ops->getdcbx)\n\t\treturn -EOPNOTSUPP;\n\n\treturn nla_put_u8(skb, DCB_ATTR_DCBX,\n\t\t\t  netdev->dcbnl_ops->getdcbx(netdev));\n}\n\nstatic int dcbnl_setdcbx(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tu8 value;\n\n\tif (!netdev->dcbnl_ops->setdcbx)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!tb[DCB_ATTR_DCBX])\n\t\treturn -EINVAL;\n\n\tvalue = nla_get_u8(tb[DCB_ATTR_DCBX]);\n\n\treturn nla_put_u8(skb, DCB_ATTR_DCBX,\n\t\t\t  netdev->dcbnl_ops->setdcbx(netdev, value));\n}\n\nstatic int dcbnl_getfeatcfg(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t    u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tstruct nlattr *data[DCB_FEATCFG_ATTR_MAX + 1], *nest;\n\tu8 value;\n\tint ret, i;\n\tint getall = 0;\n\n\tif (!netdev->dcbnl_ops->getfeatcfg)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!tb[DCB_ATTR_FEATCFG])\n\t\treturn -EINVAL;\n\n\tret = nla_parse_nested(data, DCB_FEATCFG_ATTR_MAX, tb[DCB_ATTR_FEATCFG],\n\t\t\t       dcbnl_featcfg_nest);\n\tif (ret)\n\t\treturn ret;\n\n\tnest = nla_nest_start(skb, DCB_ATTR_FEATCFG);\n\tif (!nest)\n\t\treturn -EMSGSIZE;\n\n\tif (data[DCB_FEATCFG_ATTR_ALL])\n\t\tgetall = 1;\n\n\tfor (i = DCB_FEATCFG_ATTR_ALL+1; i <= DCB_FEATCFG_ATTR_MAX; i++) {\n\t\tif (!getall && !data[i])\n\t\t\tcontinue;\n\n\t\tret = netdev->dcbnl_ops->getfeatcfg(netdev, i, &value);\n\t\tif (!ret)\n\t\t\tret = nla_put_u8(skb, i, value);\n\n\t\tif (ret) {\n\t\t\tnla_nest_cancel(skb, nest);\n\t\t\tgoto nla_put_failure;\n\t\t}\n\t}\n\tnla_nest_end(skb, nest);\n\nnla_put_failure:\n\treturn ret;\n}\n\nstatic int dcbnl_setfeatcfg(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t    u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tstruct nlattr *data[DCB_FEATCFG_ATTR_MAX + 1];\n\tint ret, i;\n\tu8 value;\n\n\tif (!netdev->dcbnl_ops->setfeatcfg)\n\t\treturn -ENOTSUPP;\n\n\tif (!tb[DCB_ATTR_FEATCFG])\n\t\treturn -EINVAL;\n\n\tret = nla_parse_nested(data, DCB_FEATCFG_ATTR_MAX, tb[DCB_ATTR_FEATCFG],\n\t\t\t       dcbnl_featcfg_nest);\n\n\tif (ret)\n\t\tgoto err;\n\n\tfor (i = DCB_FEATCFG_ATTR_ALL+1; i <= DCB_FEATCFG_ATTR_MAX; i++) {\n\t\tif (data[i] == NULL)\n\t\t\tcontinue;\n\n\t\tvalue = nla_get_u8(data[i]);\n\n\t\tret = netdev->dcbnl_ops->setfeatcfg(netdev, i, value);\n\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\nerr:\n\tret = nla_put_u8(skb, DCB_ATTR_FEATCFG, ret);\n\n\treturn ret;\n}\n\n/* Handle CEE DCBX GET commands. */\nstatic int dcbnl_cee_get(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tconst struct dcbnl_rtnl_ops *ops = netdev->dcbnl_ops;\n\n\tif (!ops)\n\t\treturn -EOPNOTSUPP;\n\n\treturn dcbnl_cee_fill(skb, netdev);\n}\n\nstruct reply_func {\n\t/* reply netlink message type */\n\tint\ttype;\n\n\t/* function to fill message contents */\n\tint   (*cb)(struct net_device *, struct nlmsghdr *, u32,\n\t\t    struct nlattr **, struct sk_buff *);\n};\n\nstatic const struct reply_func reply_funcs[DCB_CMD_MAX+1] = {\n\t[DCB_CMD_GSTATE]\t= { RTM_GETDCB, dcbnl_getstate },\n\t[DCB_CMD_SSTATE]\t= { RTM_SETDCB, dcbnl_setstate },\n\t[DCB_CMD_PFC_GCFG]\t= { RTM_GETDCB, dcbnl_getpfccfg },\n\t[DCB_CMD_PFC_SCFG]\t= { RTM_SETDCB, dcbnl_setpfccfg },\n\t[DCB_CMD_GPERM_HWADDR]\t= { RTM_GETDCB, dcbnl_getperm_hwaddr },\n\t[DCB_CMD_GCAP]\t\t= { RTM_GETDCB, dcbnl_getcap },\n\t[DCB_CMD_GNUMTCS]\t= { RTM_GETDCB, dcbnl_getnumtcs },\n\t[DCB_CMD_SNUMTCS]\t= { RTM_SETDCB, dcbnl_setnumtcs },\n\t[DCB_CMD_PFC_GSTATE]\t= { RTM_GETDCB, dcbnl_getpfcstate },\n\t[DCB_CMD_PFC_SSTATE]\t= { RTM_SETDCB, dcbnl_setpfcstate },\n\t[DCB_CMD_GAPP]\t\t= { RTM_GETDCB, dcbnl_getapp },\n\t[DCB_CMD_SAPP]\t\t= { RTM_SETDCB, dcbnl_setapp },\n\t[DCB_CMD_PGTX_GCFG]\t= { RTM_GETDCB, dcbnl_pgtx_getcfg },\n\t[DCB_CMD_PGTX_SCFG]\t= { RTM_SETDCB, dcbnl_pgtx_setcfg },\n\t[DCB_CMD_PGRX_GCFG]\t= { RTM_GETDCB, dcbnl_pgrx_getcfg },\n\t[DCB_CMD_PGRX_SCFG]\t= { RTM_SETDCB, dcbnl_pgrx_setcfg },\n\t[DCB_CMD_SET_ALL]\t= { RTM_SETDCB, dcbnl_setall },\n\t[DCB_CMD_BCN_GCFG]\t= { RTM_GETDCB, dcbnl_bcn_getcfg },\n\t[DCB_CMD_BCN_SCFG]\t= { RTM_SETDCB, dcbnl_bcn_setcfg },\n\t[DCB_CMD_IEEE_GET]\t= { RTM_GETDCB, dcbnl_ieee_get },\n\t[DCB_CMD_IEEE_SET]\t= { RTM_SETDCB, dcbnl_ieee_set },\n\t[DCB_CMD_IEEE_DEL]\t= { RTM_SETDCB, dcbnl_ieee_del },\n\t[DCB_CMD_GDCBX]\t\t= { RTM_GETDCB, dcbnl_getdcbx },\n\t[DCB_CMD_SDCBX]\t\t= { RTM_SETDCB, dcbnl_setdcbx },\n\t[DCB_CMD_GFEATCFG]\t= { RTM_GETDCB, dcbnl_getfeatcfg },\n\t[DCB_CMD_SFEATCFG]\t= { RTM_SETDCB, dcbnl_setfeatcfg },\n\t[DCB_CMD_CEE_GET]\t= { RTM_GETDCB, dcbnl_cee_get },\n};\n\nstatic int dcb_doit(struct sk_buff *skb, struct nlmsghdr *nlh, void *arg)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct net_device *netdev;\n\tstruct dcbmsg *dcb = nlmsg_data(nlh);\n\tstruct nlattr *tb[DCB_ATTR_MAX + 1];\n\tu32 portid = skb ? NETLINK_CB(skb).portid : 0;\n\tint ret = -EINVAL;\n\tstruct sk_buff *reply_skb;\n\tstruct nlmsghdr *reply_nlh = NULL;\n\tconst struct reply_func *fn;\n\n\tif ((nlh->nlmsg_type == RTM_SETDCB) && !capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tret = nlmsg_parse(nlh, sizeof(*dcb), tb, DCB_ATTR_MAX,\n\t\t\t  dcbnl_rtnl_policy);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (dcb->cmd > DCB_CMD_MAX)\n\t\treturn -EINVAL;\n\n\t/* check if a reply function has been defined for the command */\n\tfn = &reply_funcs[dcb->cmd];\n\tif (!fn->cb)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!tb[DCB_ATTR_IFNAME])\n\t\treturn -EINVAL;\n\n\tnetdev = dev_get_by_name(net, nla_data(tb[DCB_ATTR_IFNAME]));\n\tif (!netdev)\n\t\treturn -ENODEV;\n\n\tif (!netdev->dcbnl_ops) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\treply_skb = dcbnl_newmsg(fn->type, dcb->cmd, portid, nlh->nlmsg_seq,\n\t\t\t\t nlh->nlmsg_flags, &reply_nlh);\n\tif (!reply_skb) {\n\t\tret = -ENOBUFS;\n\t\tgoto out;\n\t}\n\n\tret = fn->cb(netdev, nlh, nlh->nlmsg_seq, tb, reply_skb);\n\tif (ret < 0) {\n\t\tnlmsg_free(reply_skb);\n\t\tgoto out;\n\t}\n\n\tnlmsg_end(reply_skb, reply_nlh);\n\n\tret = rtnl_unicast(reply_skb, net, portid);\nout:\n\tdev_put(netdev);\n\treturn ret;\n}\n\nstatic struct dcb_app_type *dcb_app_lookup(const struct dcb_app *app,\n\t\t\t\t\t   int ifindex, int prio)\n{\n\tstruct dcb_app_type *itr;\n\n\tlist_for_each_entry(itr, &dcb_app_list, list) {\n\t\tif (itr->app.selector == app->selector &&\n\t\t    itr->app.protocol == app->protocol &&\n\t\t    itr->ifindex == ifindex &&\n\t\t    (!prio || itr->app.priority == prio))\n\t\t\treturn itr;\n\t}\n\n\treturn NULL;\n}\n\nstatic int dcb_app_add(const struct dcb_app *app, int ifindex)\n{\n\tstruct dcb_app_type *entry;\n\n\tentry = kmalloc(sizeof(*entry), GFP_ATOMIC);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tmemcpy(&entry->app, app, sizeof(*app));\n\tentry->ifindex = ifindex;\n\tlist_add(&entry->list, &dcb_app_list);\n\n\treturn 0;\n}\n\n/**\n * dcb_getapp - retrieve the DCBX application user priority\n *\n * On success returns a non-zero 802.1p user priority bitmap\n * otherwise returns 0 as the invalid user priority bitmap to\n * indicate an error.\n */\nu8 dcb_getapp(struct net_device *dev, struct dcb_app *app)\n{\n\tstruct dcb_app_type *itr;\n\tu8 prio = 0;\n\n\tspin_lock(&dcb_lock);\n\tif ((itr = dcb_app_lookup(app, dev->ifindex, 0)))\n\t\tprio = itr->app.priority;\n\tspin_unlock(&dcb_lock);\n\n\treturn prio;\n}\nEXPORT_SYMBOL(dcb_getapp);\n\n/**\n * dcb_setapp - add CEE dcb application data to app list\n *\n * Priority 0 is an invalid priority in CEE spec. This routine\n * removes applications from the app list if the priority is\n * set to zero.\n */\nint dcb_setapp(struct net_device *dev, struct dcb_app *new)\n{\n\tstruct dcb_app_type *itr;\n\tstruct dcb_app_type event;\n\tint err = 0;\n\n\tevent.ifindex = dev->ifindex;\n\tmemcpy(&event.app, new, sizeof(event.app));\n\tif (dev->dcbnl_ops->getdcbx)\n\t\tevent.dcbx = dev->dcbnl_ops->getdcbx(dev);\n\n\tspin_lock(&dcb_lock);\n\t/* Search for existing match and replace */\n\tif ((itr = dcb_app_lookup(new, dev->ifindex, 0))) {\n\t\tif (new->priority)\n\t\t\titr->app.priority = new->priority;\n\t\telse {\n\t\t\tlist_del(&itr->list);\n\t\t\tkfree(itr);\n\t\t}\n\t\tgoto out;\n\t}\n\t/* App type does not exist add new application type */\n\tif (new->priority)\n\t\terr = dcb_app_add(new, dev->ifindex);\nout:\n\tspin_unlock(&dcb_lock);\n\tif (!err)\n\t\tcall_dcbevent_notifiers(DCB_APP_EVENT, &event);\n\treturn err;\n}\nEXPORT_SYMBOL(dcb_setapp);\n\n/**\n * dcb_ieee_getapp_mask - retrieve the IEEE DCB application priority\n *\n * Helper routine which on success returns a non-zero 802.1Qaz user\n * priority bitmap otherwise returns 0 to indicate the dcb_app was\n * not found in APP list.\n */\nu8 dcb_ieee_getapp_mask(struct net_device *dev, struct dcb_app *app)\n{\n\tstruct dcb_app_type *itr;\n\tu8 prio = 0;\n\n\tspin_lock(&dcb_lock);\n\tif ((itr = dcb_app_lookup(app, dev->ifindex, 0)))\n\t\tprio |= 1 << itr->app.priority;\n\tspin_unlock(&dcb_lock);\n\n\treturn prio;\n}\nEXPORT_SYMBOL(dcb_ieee_getapp_mask);\n\n/**\n * dcb_ieee_setapp - add IEEE dcb application data to app list\n *\n * This adds Application data to the list. Multiple application\n * entries may exists for the same selector and protocol as long\n * as the priorities are different.\n */\nint dcb_ieee_setapp(struct net_device *dev, struct dcb_app *new)\n{\n\tstruct dcb_app_type event;\n\tint err = 0;\n\n\tevent.ifindex = dev->ifindex;\n\tmemcpy(&event.app, new, sizeof(event.app));\n\tif (dev->dcbnl_ops->getdcbx)\n\t\tevent.dcbx = dev->dcbnl_ops->getdcbx(dev);\n\n\tspin_lock(&dcb_lock);\n\t/* Search for existing match and abort if found */\n\tif (dcb_app_lookup(new, dev->ifindex, new->priority)) {\n\t\terr = -EEXIST;\n\t\tgoto out;\n\t}\n\n\terr = dcb_app_add(new, dev->ifindex);\nout:\n\tspin_unlock(&dcb_lock);\n\tif (!err)\n\t\tcall_dcbevent_notifiers(DCB_APP_EVENT, &event);\n\treturn err;\n}\nEXPORT_SYMBOL(dcb_ieee_setapp);\n\n/**\n * dcb_ieee_delapp - delete IEEE dcb application data from list\n *\n * This removes a matching APP data from the APP list\n */\nint dcb_ieee_delapp(struct net_device *dev, struct dcb_app *del)\n{\n\tstruct dcb_app_type *itr;\n\tstruct dcb_app_type event;\n\tint err = -ENOENT;\n\n\tevent.ifindex = dev->ifindex;\n\tmemcpy(&event.app, del, sizeof(event.app));\n\tif (dev->dcbnl_ops->getdcbx)\n\t\tevent.dcbx = dev->dcbnl_ops->getdcbx(dev);\n\n\tspin_lock(&dcb_lock);\n\t/* Search for existing match and remove it. */\n\tif ((itr = dcb_app_lookup(del, dev->ifindex, del->priority))) {\n\t\tlist_del(&itr->list);\n\t\tkfree(itr);\n\t\terr = 0;\n\t}\n\n\tspin_unlock(&dcb_lock);\n\tif (!err)\n\t\tcall_dcbevent_notifiers(DCB_APP_EVENT, &event);\n\treturn err;\n}\nEXPORT_SYMBOL(dcb_ieee_delapp);\n\nstatic void dcb_flushapp(void)\n{\n\tstruct dcb_app_type *app;\n\tstruct dcb_app_type *tmp;\n\n\tspin_lock(&dcb_lock);\n\tlist_for_each_entry_safe(app, tmp, &dcb_app_list, list) {\n\t\tlist_del(&app->list);\n\t\tkfree(app);\n\t}\n\tspin_unlock(&dcb_lock);\n}\n\nstatic int __init dcbnl_init(void)\n{\n\tINIT_LIST_HEAD(&dcb_app_list);\n\n\trtnl_register(PF_UNSPEC, RTM_GETDCB, dcb_doit, NULL, NULL);\n\trtnl_register(PF_UNSPEC, RTM_SETDCB, dcb_doit, NULL, NULL);\n\n\treturn 0;\n}\nmodule_init(dcbnl_init);\n\nstatic void __exit dcbnl_exit(void)\n{\n\trtnl_unregister(PF_UNSPEC, RTM_GETDCB);\n\trtnl_unregister(PF_UNSPEC, RTM_SETDCB);\n\tdcb_flushapp();\n}\nmodule_exit(dcbnl_exit);\n"], "fixing_code": ["/*\n * Copyright (c) 2008-2011, Intel Corporation.\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms and conditions of the GNU General Public License,\n * version 2, as published by the Free Software Foundation.\n *\n * This program is distributed in the hope it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n * more details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program; if not, write to the Free Software Foundation, Inc., 59 Temple\n * Place - Suite 330, Boston, MA 02111-1307 USA.\n *\n * Author: Lucy Liu <lucy.liu@intel.com>\n */\n\n#include <linux/netdevice.h>\n#include <linux/netlink.h>\n#include <linux/slab.h>\n#include <net/netlink.h>\n#include <net/rtnetlink.h>\n#include <linux/dcbnl.h>\n#include <net/dcbevent.h>\n#include <linux/rtnetlink.h>\n#include <linux/module.h>\n#include <net/sock.h>\n\n/* Data Center Bridging (DCB) is a collection of Ethernet enhancements\n * intended to allow network traffic with differing requirements\n * (highly reliable, no drops vs. best effort vs. low latency) to operate\n * and co-exist on Ethernet.  Current DCB features are:\n *\n * Enhanced Transmission Selection (aka Priority Grouping [PG]) - provides a\n *   framework for assigning bandwidth guarantees to traffic classes.\n *\n * Priority-based Flow Control (PFC) - provides a flow control mechanism which\n *   can work independently for each 802.1p priority.\n *\n * Congestion Notification - provides a mechanism for end-to-end congestion\n *   control for protocols which do not have built-in congestion management.\n *\n * More information about the emerging standards for these Ethernet features\n * can be found at: http://www.ieee802.org/1/pages/dcbridges.html\n *\n * This file implements an rtnetlink interface to allow configuration of DCB\n * features for capable devices.\n */\n\nMODULE_AUTHOR(\"Lucy Liu, <lucy.liu@intel.com>\");\nMODULE_DESCRIPTION(\"Data Center Bridging netlink interface\");\nMODULE_LICENSE(\"GPL\");\n\n/**************** DCB attribute policies *************************************/\n\n/* DCB netlink attributes policy */\nstatic const struct nla_policy dcbnl_rtnl_policy[DCB_ATTR_MAX + 1] = {\n\t[DCB_ATTR_IFNAME]      = {.type = NLA_NUL_STRING, .len = IFNAMSIZ - 1},\n\t[DCB_ATTR_STATE]       = {.type = NLA_U8},\n\t[DCB_ATTR_PFC_CFG]     = {.type = NLA_NESTED},\n\t[DCB_ATTR_PG_CFG]      = {.type = NLA_NESTED},\n\t[DCB_ATTR_SET_ALL]     = {.type = NLA_U8},\n\t[DCB_ATTR_PERM_HWADDR] = {.type = NLA_FLAG},\n\t[DCB_ATTR_CAP]         = {.type = NLA_NESTED},\n\t[DCB_ATTR_PFC_STATE]   = {.type = NLA_U8},\n\t[DCB_ATTR_BCN]         = {.type = NLA_NESTED},\n\t[DCB_ATTR_APP]         = {.type = NLA_NESTED},\n\t[DCB_ATTR_IEEE]\t       = {.type = NLA_NESTED},\n\t[DCB_ATTR_DCBX]        = {.type = NLA_U8},\n\t[DCB_ATTR_FEATCFG]     = {.type = NLA_NESTED},\n};\n\n/* DCB priority flow control to User Priority nested attributes */\nstatic const struct nla_policy dcbnl_pfc_up_nest[DCB_PFC_UP_ATTR_MAX + 1] = {\n\t[DCB_PFC_UP_ATTR_0]   = {.type = NLA_U8},\n\t[DCB_PFC_UP_ATTR_1]   = {.type = NLA_U8},\n\t[DCB_PFC_UP_ATTR_2]   = {.type = NLA_U8},\n\t[DCB_PFC_UP_ATTR_3]   = {.type = NLA_U8},\n\t[DCB_PFC_UP_ATTR_4]   = {.type = NLA_U8},\n\t[DCB_PFC_UP_ATTR_5]   = {.type = NLA_U8},\n\t[DCB_PFC_UP_ATTR_6]   = {.type = NLA_U8},\n\t[DCB_PFC_UP_ATTR_7]   = {.type = NLA_U8},\n\t[DCB_PFC_UP_ATTR_ALL] = {.type = NLA_FLAG},\n};\n\n/* DCB priority grouping nested attributes */\nstatic const struct nla_policy dcbnl_pg_nest[DCB_PG_ATTR_MAX + 1] = {\n\t[DCB_PG_ATTR_TC_0]      = {.type = NLA_NESTED},\n\t[DCB_PG_ATTR_TC_1]      = {.type = NLA_NESTED},\n\t[DCB_PG_ATTR_TC_2]      = {.type = NLA_NESTED},\n\t[DCB_PG_ATTR_TC_3]      = {.type = NLA_NESTED},\n\t[DCB_PG_ATTR_TC_4]      = {.type = NLA_NESTED},\n\t[DCB_PG_ATTR_TC_5]      = {.type = NLA_NESTED},\n\t[DCB_PG_ATTR_TC_6]      = {.type = NLA_NESTED},\n\t[DCB_PG_ATTR_TC_7]      = {.type = NLA_NESTED},\n\t[DCB_PG_ATTR_TC_ALL]    = {.type = NLA_NESTED},\n\t[DCB_PG_ATTR_BW_ID_0]   = {.type = NLA_U8},\n\t[DCB_PG_ATTR_BW_ID_1]   = {.type = NLA_U8},\n\t[DCB_PG_ATTR_BW_ID_2]   = {.type = NLA_U8},\n\t[DCB_PG_ATTR_BW_ID_3]   = {.type = NLA_U8},\n\t[DCB_PG_ATTR_BW_ID_4]   = {.type = NLA_U8},\n\t[DCB_PG_ATTR_BW_ID_5]   = {.type = NLA_U8},\n\t[DCB_PG_ATTR_BW_ID_6]   = {.type = NLA_U8},\n\t[DCB_PG_ATTR_BW_ID_7]   = {.type = NLA_U8},\n\t[DCB_PG_ATTR_BW_ID_ALL] = {.type = NLA_FLAG},\n};\n\n/* DCB traffic class nested attributes. */\nstatic const struct nla_policy dcbnl_tc_param_nest[DCB_TC_ATTR_PARAM_MAX + 1] = {\n\t[DCB_TC_ATTR_PARAM_PGID]            = {.type = NLA_U8},\n\t[DCB_TC_ATTR_PARAM_UP_MAPPING]      = {.type = NLA_U8},\n\t[DCB_TC_ATTR_PARAM_STRICT_PRIO]     = {.type = NLA_U8},\n\t[DCB_TC_ATTR_PARAM_BW_PCT]          = {.type = NLA_U8},\n\t[DCB_TC_ATTR_PARAM_ALL]             = {.type = NLA_FLAG},\n};\n\n/* DCB capabilities nested attributes. */\nstatic const struct nla_policy dcbnl_cap_nest[DCB_CAP_ATTR_MAX + 1] = {\n\t[DCB_CAP_ATTR_ALL]     = {.type = NLA_FLAG},\n\t[DCB_CAP_ATTR_PG]      = {.type = NLA_U8},\n\t[DCB_CAP_ATTR_PFC]     = {.type = NLA_U8},\n\t[DCB_CAP_ATTR_UP2TC]   = {.type = NLA_U8},\n\t[DCB_CAP_ATTR_PG_TCS]  = {.type = NLA_U8},\n\t[DCB_CAP_ATTR_PFC_TCS] = {.type = NLA_U8},\n\t[DCB_CAP_ATTR_GSP]     = {.type = NLA_U8},\n\t[DCB_CAP_ATTR_BCN]     = {.type = NLA_U8},\n\t[DCB_CAP_ATTR_DCBX]    = {.type = NLA_U8},\n};\n\n/* DCB capabilities nested attributes. */\nstatic const struct nla_policy dcbnl_numtcs_nest[DCB_NUMTCS_ATTR_MAX + 1] = {\n\t[DCB_NUMTCS_ATTR_ALL]     = {.type = NLA_FLAG},\n\t[DCB_NUMTCS_ATTR_PG]      = {.type = NLA_U8},\n\t[DCB_NUMTCS_ATTR_PFC]     = {.type = NLA_U8},\n};\n\n/* DCB BCN nested attributes. */\nstatic const struct nla_policy dcbnl_bcn_nest[DCB_BCN_ATTR_MAX + 1] = {\n\t[DCB_BCN_ATTR_RP_0]         = {.type = NLA_U8},\n\t[DCB_BCN_ATTR_RP_1]         = {.type = NLA_U8},\n\t[DCB_BCN_ATTR_RP_2]         = {.type = NLA_U8},\n\t[DCB_BCN_ATTR_RP_3]         = {.type = NLA_U8},\n\t[DCB_BCN_ATTR_RP_4]         = {.type = NLA_U8},\n\t[DCB_BCN_ATTR_RP_5]         = {.type = NLA_U8},\n\t[DCB_BCN_ATTR_RP_6]         = {.type = NLA_U8},\n\t[DCB_BCN_ATTR_RP_7]         = {.type = NLA_U8},\n\t[DCB_BCN_ATTR_RP_ALL]       = {.type = NLA_FLAG},\n\t[DCB_BCN_ATTR_BCNA_0]       = {.type = NLA_U32},\n\t[DCB_BCN_ATTR_BCNA_1]       = {.type = NLA_U32},\n\t[DCB_BCN_ATTR_ALPHA]        = {.type = NLA_U32},\n\t[DCB_BCN_ATTR_BETA]         = {.type = NLA_U32},\n\t[DCB_BCN_ATTR_GD]           = {.type = NLA_U32},\n\t[DCB_BCN_ATTR_GI]           = {.type = NLA_U32},\n\t[DCB_BCN_ATTR_TMAX]         = {.type = NLA_U32},\n\t[DCB_BCN_ATTR_TD]           = {.type = NLA_U32},\n\t[DCB_BCN_ATTR_RMIN]         = {.type = NLA_U32},\n\t[DCB_BCN_ATTR_W]            = {.type = NLA_U32},\n\t[DCB_BCN_ATTR_RD]           = {.type = NLA_U32},\n\t[DCB_BCN_ATTR_RU]           = {.type = NLA_U32},\n\t[DCB_BCN_ATTR_WRTT]         = {.type = NLA_U32},\n\t[DCB_BCN_ATTR_RI]           = {.type = NLA_U32},\n\t[DCB_BCN_ATTR_C]            = {.type = NLA_U32},\n\t[DCB_BCN_ATTR_ALL]          = {.type = NLA_FLAG},\n};\n\n/* DCB APP nested attributes. */\nstatic const struct nla_policy dcbnl_app_nest[DCB_APP_ATTR_MAX + 1] = {\n\t[DCB_APP_ATTR_IDTYPE]       = {.type = NLA_U8},\n\t[DCB_APP_ATTR_ID]           = {.type = NLA_U16},\n\t[DCB_APP_ATTR_PRIORITY]     = {.type = NLA_U8},\n};\n\n/* IEEE 802.1Qaz nested attributes. */\nstatic const struct nla_policy dcbnl_ieee_policy[DCB_ATTR_IEEE_MAX + 1] = {\n\t[DCB_ATTR_IEEE_ETS]\t    = {.len = sizeof(struct ieee_ets)},\n\t[DCB_ATTR_IEEE_PFC]\t    = {.len = sizeof(struct ieee_pfc)},\n\t[DCB_ATTR_IEEE_APP_TABLE]   = {.type = NLA_NESTED},\n\t[DCB_ATTR_IEEE_MAXRATE]   = {.len = sizeof(struct ieee_maxrate)},\n};\n\nstatic const struct nla_policy dcbnl_ieee_app[DCB_ATTR_IEEE_APP_MAX + 1] = {\n\t[DCB_ATTR_IEEE_APP]\t    = {.len = sizeof(struct dcb_app)},\n};\n\n/* DCB number of traffic classes nested attributes. */\nstatic const struct nla_policy dcbnl_featcfg_nest[DCB_FEATCFG_ATTR_MAX + 1] = {\n\t[DCB_FEATCFG_ATTR_ALL]      = {.type = NLA_FLAG},\n\t[DCB_FEATCFG_ATTR_PG]       = {.type = NLA_U8},\n\t[DCB_FEATCFG_ATTR_PFC]      = {.type = NLA_U8},\n\t[DCB_FEATCFG_ATTR_APP]      = {.type = NLA_U8},\n};\n\nstatic LIST_HEAD(dcb_app_list);\nstatic DEFINE_SPINLOCK(dcb_lock);\n\nstatic struct sk_buff *dcbnl_newmsg(int type, u8 cmd, u32 port, u32 seq,\n\t\t\t\t    u32 flags, struct nlmsghdr **nlhp)\n{\n\tstruct sk_buff *skb;\n\tstruct dcbmsg *dcb;\n\tstruct nlmsghdr *nlh;\n\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!skb)\n\t\treturn NULL;\n\n\tnlh = nlmsg_put(skb, port, seq, type, sizeof(*dcb), flags);\n\tBUG_ON(!nlh);\n\n\tdcb = nlmsg_data(nlh);\n\tdcb->dcb_family = AF_UNSPEC;\n\tdcb->cmd = cmd;\n\tdcb->dcb_pad = 0;\n\n\tif (nlhp)\n\t\t*nlhp = nlh;\n\n\treturn skb;\n}\n\nstatic int dcbnl_getstate(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t  u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\t/* if (!tb[DCB_ATTR_STATE] || !netdev->dcbnl_ops->getstate) */\n\tif (!netdev->dcbnl_ops->getstate)\n\t\treturn -EOPNOTSUPP;\n\n\treturn nla_put_u8(skb, DCB_ATTR_STATE,\n\t\t\t  netdev->dcbnl_ops->getstate(netdev));\n}\n\nstatic int dcbnl_getpfccfg(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t   u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tstruct nlattr *data[DCB_PFC_UP_ATTR_MAX + 1], *nest;\n\tu8 value;\n\tint ret;\n\tint i;\n\tint getall = 0;\n\n\tif (!tb[DCB_ATTR_PFC_CFG])\n\t\treturn -EINVAL;\n\n\tif (!netdev->dcbnl_ops->getpfccfg)\n\t\treturn -EOPNOTSUPP;\n\n\tret = nla_parse_nested(data, DCB_PFC_UP_ATTR_MAX,\n\t                       tb[DCB_ATTR_PFC_CFG],\n\t                       dcbnl_pfc_up_nest);\n\tif (ret)\n\t\treturn ret;\n\n\tnest = nla_nest_start(skb, DCB_ATTR_PFC_CFG);\n\tif (!nest)\n\t\treturn -EMSGSIZE;\n\n\tif (data[DCB_PFC_UP_ATTR_ALL])\n\t\tgetall = 1;\n\n\tfor (i = DCB_PFC_UP_ATTR_0; i <= DCB_PFC_UP_ATTR_7; i++) {\n\t\tif (!getall && !data[i])\n\t\t\tcontinue;\n\n\t\tnetdev->dcbnl_ops->getpfccfg(netdev, i - DCB_PFC_UP_ATTR_0,\n\t\t                             &value);\n\t\tret = nla_put_u8(skb, i, value);\n\t\tif (ret) {\n\t\t\tnla_nest_cancel(skb, nest);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tnla_nest_end(skb, nest);\n\n\treturn 0;\n}\n\nstatic int dcbnl_getperm_hwaddr(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t\tu32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tu8 perm_addr[MAX_ADDR_LEN];\n\n\tif (!netdev->dcbnl_ops->getpermhwaddr)\n\t\treturn -EOPNOTSUPP;\n\n\tmemset(perm_addr, 0, sizeof(perm_addr));\n\tnetdev->dcbnl_ops->getpermhwaddr(netdev, perm_addr);\n\n\treturn nla_put(skb, DCB_ATTR_PERM_HWADDR, sizeof(perm_addr), perm_addr);\n}\n\nstatic int dcbnl_getcap(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\tu32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tstruct nlattr *data[DCB_CAP_ATTR_MAX + 1], *nest;\n\tu8 value;\n\tint ret;\n\tint i;\n\tint getall = 0;\n\n\tif (!tb[DCB_ATTR_CAP])\n\t\treturn -EINVAL;\n\n\tif (!netdev->dcbnl_ops->getcap)\n\t\treturn -EOPNOTSUPP;\n\n\tret = nla_parse_nested(data, DCB_CAP_ATTR_MAX, tb[DCB_ATTR_CAP],\n\t                       dcbnl_cap_nest);\n\tif (ret)\n\t\treturn ret;\n\n\tnest = nla_nest_start(skb, DCB_ATTR_CAP);\n\tif (!nest)\n\t\treturn -EMSGSIZE;\n\n\tif (data[DCB_CAP_ATTR_ALL])\n\t\tgetall = 1;\n\n\tfor (i = DCB_CAP_ATTR_ALL+1; i <= DCB_CAP_ATTR_MAX; i++) {\n\t\tif (!getall && !data[i])\n\t\t\tcontinue;\n\n\t\tif (!netdev->dcbnl_ops->getcap(netdev, i, &value)) {\n\t\t\tret = nla_put_u8(skb, i, value);\n\t\t\tif (ret) {\n\t\t\t\tnla_nest_cancel(skb, nest);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\tnla_nest_end(skb, nest);\n\n\treturn 0;\n}\n\nstatic int dcbnl_getnumtcs(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t   u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tstruct nlattr *data[DCB_NUMTCS_ATTR_MAX + 1], *nest;\n\tu8 value;\n\tint ret;\n\tint i;\n\tint getall = 0;\n\n\tif (!tb[DCB_ATTR_NUMTCS])\n\t\treturn -EINVAL;\n\n\tif (!netdev->dcbnl_ops->getnumtcs)\n\t\treturn -EOPNOTSUPP;\n\n\tret = nla_parse_nested(data, DCB_NUMTCS_ATTR_MAX, tb[DCB_ATTR_NUMTCS],\n\t                       dcbnl_numtcs_nest);\n\tif (ret)\n\t\treturn ret;\n\n\tnest = nla_nest_start(skb, DCB_ATTR_NUMTCS);\n\tif (!nest)\n\t\treturn -EMSGSIZE;\n\n\tif (data[DCB_NUMTCS_ATTR_ALL])\n\t\tgetall = 1;\n\n\tfor (i = DCB_NUMTCS_ATTR_ALL+1; i <= DCB_NUMTCS_ATTR_MAX; i++) {\n\t\tif (!getall && !data[i])\n\t\t\tcontinue;\n\n\t\tret = netdev->dcbnl_ops->getnumtcs(netdev, i, &value);\n\t\tif (!ret) {\n\t\t\tret = nla_put_u8(skb, i, value);\n\t\t\tif (ret) {\n\t\t\t\tnla_nest_cancel(skb, nest);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} else\n\t\t\treturn -EINVAL;\n\t}\n\tnla_nest_end(skb, nest);\n\n\treturn 0;\n}\n\nstatic int dcbnl_setnumtcs(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t   u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tstruct nlattr *data[DCB_NUMTCS_ATTR_MAX + 1];\n\tint ret;\n\tu8 value;\n\tint i;\n\n\tif (!tb[DCB_ATTR_NUMTCS])\n\t\treturn -EINVAL;\n\n\tif (!netdev->dcbnl_ops->setnumtcs)\n\t\treturn -EOPNOTSUPP;\n\n\tret = nla_parse_nested(data, DCB_NUMTCS_ATTR_MAX, tb[DCB_ATTR_NUMTCS],\n\t                       dcbnl_numtcs_nest);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = DCB_NUMTCS_ATTR_ALL+1; i <= DCB_NUMTCS_ATTR_MAX; i++) {\n\t\tif (data[i] == NULL)\n\t\t\tcontinue;\n\n\t\tvalue = nla_get_u8(data[i]);\n\n\t\tret = netdev->dcbnl_ops->setnumtcs(netdev, i, value);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn nla_put_u8(skb, DCB_ATTR_NUMTCS, !!ret);\n}\n\nstatic int dcbnl_getpfcstate(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t     u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tif (!netdev->dcbnl_ops->getpfcstate)\n\t\treturn -EOPNOTSUPP;\n\n\treturn nla_put_u8(skb, DCB_ATTR_PFC_STATE,\n\t\t\t  netdev->dcbnl_ops->getpfcstate(netdev));\n}\n\nstatic int dcbnl_setpfcstate(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t     u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tu8 value;\n\n\tif (!tb[DCB_ATTR_PFC_STATE])\n\t\treturn -EINVAL;\n\n\tif (!netdev->dcbnl_ops->setpfcstate)\n\t\treturn -EOPNOTSUPP;\n\n\tvalue = nla_get_u8(tb[DCB_ATTR_PFC_STATE]);\n\n\tnetdev->dcbnl_ops->setpfcstate(netdev, value);\n\n\treturn nla_put_u8(skb, DCB_ATTR_PFC_STATE, 0);\n}\n\nstatic int dcbnl_getapp(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\tu32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tstruct nlattr *app_nest;\n\tstruct nlattr *app_tb[DCB_APP_ATTR_MAX + 1];\n\tu16 id;\n\tu8 up, idtype;\n\tint ret;\n\n\tif (!tb[DCB_ATTR_APP])\n\t\treturn -EINVAL;\n\n\tret = nla_parse_nested(app_tb, DCB_APP_ATTR_MAX, tb[DCB_ATTR_APP],\n\t                       dcbnl_app_nest);\n\tif (ret)\n\t\treturn ret;\n\n\t/* all must be non-null */\n\tif ((!app_tb[DCB_APP_ATTR_IDTYPE]) ||\n\t    (!app_tb[DCB_APP_ATTR_ID]))\n\t\treturn -EINVAL;\n\n\t/* either by eth type or by socket number */\n\tidtype = nla_get_u8(app_tb[DCB_APP_ATTR_IDTYPE]);\n\tif ((idtype != DCB_APP_IDTYPE_ETHTYPE) &&\n\t    (idtype != DCB_APP_IDTYPE_PORTNUM))\n\t\treturn -EINVAL;\n\n\tid = nla_get_u16(app_tb[DCB_APP_ATTR_ID]);\n\n\tif (netdev->dcbnl_ops->getapp) {\n\t\tup = netdev->dcbnl_ops->getapp(netdev, idtype, id);\n\t} else {\n\t\tstruct dcb_app app = {\n\t\t\t\t\t.selector = idtype,\n\t\t\t\t\t.protocol = id,\n\t\t\t\t     };\n\t\tup = dcb_getapp(netdev, &app);\n\t}\n\n\tapp_nest = nla_nest_start(skb, DCB_ATTR_APP);\n\tif (!app_nest)\n\t\treturn -EMSGSIZE;\n\n\tret = nla_put_u8(skb, DCB_APP_ATTR_IDTYPE, idtype);\n\tif (ret)\n\t\tgoto out_cancel;\n\n\tret = nla_put_u16(skb, DCB_APP_ATTR_ID, id);\n\tif (ret)\n\t\tgoto out_cancel;\n\n\tret = nla_put_u8(skb, DCB_APP_ATTR_PRIORITY, up);\n\tif (ret)\n\t\tgoto out_cancel;\n\n\tnla_nest_end(skb, app_nest);\n\n\treturn 0;\n\nout_cancel:\n\tnla_nest_cancel(skb, app_nest);\n\treturn ret;\n}\n\nstatic int dcbnl_setapp(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\tu32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tint ret;\n\tu16 id;\n\tu8 up, idtype;\n\tstruct nlattr *app_tb[DCB_APP_ATTR_MAX + 1];\n\n\tif (!tb[DCB_ATTR_APP])\n\t\treturn -EINVAL;\n\n\tret = nla_parse_nested(app_tb, DCB_APP_ATTR_MAX, tb[DCB_ATTR_APP],\n\t                       dcbnl_app_nest);\n\tif (ret)\n\t\treturn ret;\n\n\t/* all must be non-null */\n\tif ((!app_tb[DCB_APP_ATTR_IDTYPE]) ||\n\t    (!app_tb[DCB_APP_ATTR_ID]) ||\n\t    (!app_tb[DCB_APP_ATTR_PRIORITY]))\n\t\treturn -EINVAL;\n\n\t/* either by eth type or by socket number */\n\tidtype = nla_get_u8(app_tb[DCB_APP_ATTR_IDTYPE]);\n\tif ((idtype != DCB_APP_IDTYPE_ETHTYPE) &&\n\t    (idtype != DCB_APP_IDTYPE_PORTNUM))\n\t\treturn -EINVAL;\n\n\tid = nla_get_u16(app_tb[DCB_APP_ATTR_ID]);\n\tup = nla_get_u8(app_tb[DCB_APP_ATTR_PRIORITY]);\n\n\tif (netdev->dcbnl_ops->setapp) {\n\t\tret = netdev->dcbnl_ops->setapp(netdev, idtype, id, up);\n\t} else {\n\t\tstruct dcb_app app;\n\t\tapp.selector = idtype;\n\t\tapp.protocol = id;\n\t\tapp.priority = up;\n\t\tret = dcb_setapp(netdev, &app);\n\t}\n\n\tret = nla_put_u8(skb, DCB_ATTR_APP, ret);\n\tdcbnl_cee_notify(netdev, RTM_SETDCB, DCB_CMD_SAPP, seq, 0);\n\n\treturn ret;\n}\n\nstatic int __dcbnl_pg_getcfg(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t     struct nlattr **tb, struct sk_buff *skb, int dir)\n{\n\tstruct nlattr *pg_nest, *param_nest, *data;\n\tstruct nlattr *pg_tb[DCB_PG_ATTR_MAX + 1];\n\tstruct nlattr *param_tb[DCB_TC_ATTR_PARAM_MAX + 1];\n\tu8 prio, pgid, tc_pct, up_map;\n\tint ret;\n\tint getall = 0;\n\tint i;\n\n\tif (!tb[DCB_ATTR_PG_CFG])\n\t\treturn -EINVAL;\n\n\tif (!netdev->dcbnl_ops->getpgtccfgtx ||\n\t    !netdev->dcbnl_ops->getpgtccfgrx ||\n\t    !netdev->dcbnl_ops->getpgbwgcfgtx ||\n\t    !netdev->dcbnl_ops->getpgbwgcfgrx)\n\t\treturn -EOPNOTSUPP;\n\n\tret = nla_parse_nested(pg_tb, DCB_PG_ATTR_MAX,\n\t                       tb[DCB_ATTR_PG_CFG], dcbnl_pg_nest);\n\tif (ret)\n\t\treturn ret;\n\n\tpg_nest = nla_nest_start(skb, DCB_ATTR_PG_CFG);\n\tif (!pg_nest)\n\t\treturn -EMSGSIZE;\n\n\tif (pg_tb[DCB_PG_ATTR_TC_ALL])\n\t\tgetall = 1;\n\n\tfor (i = DCB_PG_ATTR_TC_0; i <= DCB_PG_ATTR_TC_7; i++) {\n\t\tif (!getall && !pg_tb[i])\n\t\t\tcontinue;\n\n\t\tif (pg_tb[DCB_PG_ATTR_TC_ALL])\n\t\t\tdata = pg_tb[DCB_PG_ATTR_TC_ALL];\n\t\telse\n\t\t\tdata = pg_tb[i];\n\t\tret = nla_parse_nested(param_tb, DCB_TC_ATTR_PARAM_MAX,\n\t\t\t\t       data, dcbnl_tc_param_nest);\n\t\tif (ret)\n\t\t\tgoto err_pg;\n\n\t\tparam_nest = nla_nest_start(skb, i);\n\t\tif (!param_nest)\n\t\t\tgoto err_pg;\n\n\t\tpgid = DCB_ATTR_VALUE_UNDEFINED;\n\t\tprio = DCB_ATTR_VALUE_UNDEFINED;\n\t\ttc_pct = DCB_ATTR_VALUE_UNDEFINED;\n\t\tup_map = DCB_ATTR_VALUE_UNDEFINED;\n\n\t\tif (dir) {\n\t\t\t/* Rx */\n\t\t\tnetdev->dcbnl_ops->getpgtccfgrx(netdev,\n\t\t\t\t\t\ti - DCB_PG_ATTR_TC_0, &prio,\n\t\t\t\t\t\t&pgid, &tc_pct, &up_map);\n\t\t} else {\n\t\t\t/* Tx */\n\t\t\tnetdev->dcbnl_ops->getpgtccfgtx(netdev,\n\t\t\t\t\t\ti - DCB_PG_ATTR_TC_0, &prio,\n\t\t\t\t\t\t&pgid, &tc_pct, &up_map);\n\t\t}\n\n\t\tif (param_tb[DCB_TC_ATTR_PARAM_PGID] ||\n\t\t    param_tb[DCB_TC_ATTR_PARAM_ALL]) {\n\t\t\tret = nla_put_u8(skb,\n\t\t\t                 DCB_TC_ATTR_PARAM_PGID, pgid);\n\t\t\tif (ret)\n\t\t\t\tgoto err_param;\n\t\t}\n\t\tif (param_tb[DCB_TC_ATTR_PARAM_UP_MAPPING] ||\n\t\t    param_tb[DCB_TC_ATTR_PARAM_ALL]) {\n\t\t\tret = nla_put_u8(skb,\n\t\t\t                 DCB_TC_ATTR_PARAM_UP_MAPPING, up_map);\n\t\t\tif (ret)\n\t\t\t\tgoto err_param;\n\t\t}\n\t\tif (param_tb[DCB_TC_ATTR_PARAM_STRICT_PRIO] ||\n\t\t    param_tb[DCB_TC_ATTR_PARAM_ALL]) {\n\t\t\tret = nla_put_u8(skb,\n\t\t\t                 DCB_TC_ATTR_PARAM_STRICT_PRIO, prio);\n\t\t\tif (ret)\n\t\t\t\tgoto err_param;\n\t\t}\n\t\tif (param_tb[DCB_TC_ATTR_PARAM_BW_PCT] ||\n\t\t    param_tb[DCB_TC_ATTR_PARAM_ALL]) {\n\t\t\tret = nla_put_u8(skb, DCB_TC_ATTR_PARAM_BW_PCT,\n\t\t\t                 tc_pct);\n\t\t\tif (ret)\n\t\t\t\tgoto err_param;\n\t\t}\n\t\tnla_nest_end(skb, param_nest);\n\t}\n\n\tif (pg_tb[DCB_PG_ATTR_BW_ID_ALL])\n\t\tgetall = 1;\n\telse\n\t\tgetall = 0;\n\n\tfor (i = DCB_PG_ATTR_BW_ID_0; i <= DCB_PG_ATTR_BW_ID_7; i++) {\n\t\tif (!getall && !pg_tb[i])\n\t\t\tcontinue;\n\n\t\ttc_pct = DCB_ATTR_VALUE_UNDEFINED;\n\n\t\tif (dir) {\n\t\t\t/* Rx */\n\t\t\tnetdev->dcbnl_ops->getpgbwgcfgrx(netdev,\n\t\t\t\t\ti - DCB_PG_ATTR_BW_ID_0, &tc_pct);\n\t\t} else {\n\t\t\t/* Tx */\n\t\t\tnetdev->dcbnl_ops->getpgbwgcfgtx(netdev,\n\t\t\t\t\ti - DCB_PG_ATTR_BW_ID_0, &tc_pct);\n\t\t}\n\t\tret = nla_put_u8(skb, i, tc_pct);\n\t\tif (ret)\n\t\t\tgoto err_pg;\n\t}\n\n\tnla_nest_end(skb, pg_nest);\n\n\treturn 0;\n\nerr_param:\n\tnla_nest_cancel(skb, param_nest);\nerr_pg:\n\tnla_nest_cancel(skb, pg_nest);\n\n\treturn -EMSGSIZE;\n}\n\nstatic int dcbnl_pgtx_getcfg(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t     u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\treturn __dcbnl_pg_getcfg(netdev, nlh, tb, skb, 0);\n}\n\nstatic int dcbnl_pgrx_getcfg(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t     u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\treturn __dcbnl_pg_getcfg(netdev, nlh, tb, skb, 1);\n}\n\nstatic int dcbnl_setstate(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t  u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tu8 value;\n\n\tif (!tb[DCB_ATTR_STATE])\n\t\treturn -EINVAL;\n\n\tif (!netdev->dcbnl_ops->setstate)\n\t\treturn -EOPNOTSUPP;\n\n\tvalue = nla_get_u8(tb[DCB_ATTR_STATE]);\n\n\treturn nla_put_u8(skb, DCB_ATTR_STATE,\n\t\t\t  netdev->dcbnl_ops->setstate(netdev, value));\n}\n\nstatic int dcbnl_setpfccfg(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t   u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tstruct nlattr *data[DCB_PFC_UP_ATTR_MAX + 1];\n\tint i;\n\tint ret;\n\tu8 value;\n\n\tif (!tb[DCB_ATTR_PFC_CFG])\n\t\treturn -EINVAL;\n\n\tif (!netdev->dcbnl_ops->setpfccfg)\n\t\treturn -EOPNOTSUPP;\n\n\tret = nla_parse_nested(data, DCB_PFC_UP_ATTR_MAX,\n\t                       tb[DCB_ATTR_PFC_CFG],\n\t                       dcbnl_pfc_up_nest);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = DCB_PFC_UP_ATTR_0; i <= DCB_PFC_UP_ATTR_7; i++) {\n\t\tif (data[i] == NULL)\n\t\t\tcontinue;\n\t\tvalue = nla_get_u8(data[i]);\n\t\tnetdev->dcbnl_ops->setpfccfg(netdev,\n\t\t\tdata[i]->nla_type - DCB_PFC_UP_ATTR_0, value);\n\t}\n\n\treturn nla_put_u8(skb, DCB_ATTR_PFC_CFG, 0);\n}\n\nstatic int dcbnl_setall(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\tu32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tint ret;\n\n\tif (!tb[DCB_ATTR_SET_ALL])\n\t\treturn -EINVAL;\n\n\tif (!netdev->dcbnl_ops->setall)\n\t\treturn -EOPNOTSUPP;\n\n\tret = nla_put_u8(skb, DCB_ATTR_SET_ALL,\n\t\t\t netdev->dcbnl_ops->setall(netdev));\n\tdcbnl_cee_notify(netdev, RTM_SETDCB, DCB_CMD_SET_ALL, seq, 0);\n\n\treturn ret;\n}\n\nstatic int __dcbnl_pg_setcfg(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t     u32 seq, struct nlattr **tb, struct sk_buff *skb,\n\t\t\t     int dir)\n{\n\tstruct nlattr *pg_tb[DCB_PG_ATTR_MAX + 1];\n\tstruct nlattr *param_tb[DCB_TC_ATTR_PARAM_MAX + 1];\n\tint ret;\n\tint i;\n\tu8 pgid;\n\tu8 up_map;\n\tu8 prio;\n\tu8 tc_pct;\n\n\tif (!tb[DCB_ATTR_PG_CFG])\n\t\treturn -EINVAL;\n\n\tif (!netdev->dcbnl_ops->setpgtccfgtx ||\n\t    !netdev->dcbnl_ops->setpgtccfgrx ||\n\t    !netdev->dcbnl_ops->setpgbwgcfgtx ||\n\t    !netdev->dcbnl_ops->setpgbwgcfgrx)\n\t\treturn -EOPNOTSUPP;\n\n\tret = nla_parse_nested(pg_tb, DCB_PG_ATTR_MAX,\n\t                       tb[DCB_ATTR_PG_CFG], dcbnl_pg_nest);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = DCB_PG_ATTR_TC_0; i <= DCB_PG_ATTR_TC_7; i++) {\n\t\tif (!pg_tb[i])\n\t\t\tcontinue;\n\n\t\tret = nla_parse_nested(param_tb, DCB_TC_ATTR_PARAM_MAX,\n\t\t                       pg_tb[i], dcbnl_tc_param_nest);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tpgid = DCB_ATTR_VALUE_UNDEFINED;\n\t\tprio = DCB_ATTR_VALUE_UNDEFINED;\n\t\ttc_pct = DCB_ATTR_VALUE_UNDEFINED;\n\t\tup_map = DCB_ATTR_VALUE_UNDEFINED;\n\n\t\tif (param_tb[DCB_TC_ATTR_PARAM_STRICT_PRIO])\n\t\t\tprio =\n\t\t\t    nla_get_u8(param_tb[DCB_TC_ATTR_PARAM_STRICT_PRIO]);\n\n\t\tif (param_tb[DCB_TC_ATTR_PARAM_PGID])\n\t\t\tpgid = nla_get_u8(param_tb[DCB_TC_ATTR_PARAM_PGID]);\n\n\t\tif (param_tb[DCB_TC_ATTR_PARAM_BW_PCT])\n\t\t\ttc_pct = nla_get_u8(param_tb[DCB_TC_ATTR_PARAM_BW_PCT]);\n\n\t\tif (param_tb[DCB_TC_ATTR_PARAM_UP_MAPPING])\n\t\t\tup_map =\n\t\t\t     nla_get_u8(param_tb[DCB_TC_ATTR_PARAM_UP_MAPPING]);\n\n\t\t/* dir: Tx = 0, Rx = 1 */\n\t\tif (dir) {\n\t\t\t/* Rx */\n\t\t\tnetdev->dcbnl_ops->setpgtccfgrx(netdev,\n\t\t\t\ti - DCB_PG_ATTR_TC_0,\n\t\t\t\tprio, pgid, tc_pct, up_map);\n\t\t} else {\n\t\t\t/* Tx */\n\t\t\tnetdev->dcbnl_ops->setpgtccfgtx(netdev,\n\t\t\t\ti - DCB_PG_ATTR_TC_0,\n\t\t\t\tprio, pgid, tc_pct, up_map);\n\t\t}\n\t}\n\n\tfor (i = DCB_PG_ATTR_BW_ID_0; i <= DCB_PG_ATTR_BW_ID_7; i++) {\n\t\tif (!pg_tb[i])\n\t\t\tcontinue;\n\n\t\ttc_pct = nla_get_u8(pg_tb[i]);\n\n\t\t/* dir: Tx = 0, Rx = 1 */\n\t\tif (dir) {\n\t\t\t/* Rx */\n\t\t\tnetdev->dcbnl_ops->setpgbwgcfgrx(netdev,\n\t\t\t\t\t i - DCB_PG_ATTR_BW_ID_0, tc_pct);\n\t\t} else {\n\t\t\t/* Tx */\n\t\t\tnetdev->dcbnl_ops->setpgbwgcfgtx(netdev,\n\t\t\t\t\t i - DCB_PG_ATTR_BW_ID_0, tc_pct);\n\t\t}\n\t}\n\n\treturn nla_put_u8(skb, DCB_ATTR_PG_CFG, 0);\n}\n\nstatic int dcbnl_pgtx_setcfg(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t     u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\treturn __dcbnl_pg_setcfg(netdev, nlh, seq, tb, skb, 0);\n}\n\nstatic int dcbnl_pgrx_setcfg(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t     u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\treturn __dcbnl_pg_setcfg(netdev, nlh, seq, tb, skb, 1);\n}\n\nstatic int dcbnl_bcn_getcfg(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t    u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tstruct nlattr *bcn_nest;\n\tstruct nlattr *bcn_tb[DCB_BCN_ATTR_MAX + 1];\n\tu8 value_byte;\n\tu32 value_integer;\n\tint ret;\n\tbool getall = false;\n\tint i;\n\n\tif (!tb[DCB_ATTR_BCN])\n\t\treturn -EINVAL;\n\n\tif (!netdev->dcbnl_ops->getbcnrp ||\n\t    !netdev->dcbnl_ops->getbcncfg)\n\t\treturn -EOPNOTSUPP;\n\n\tret = nla_parse_nested(bcn_tb, DCB_BCN_ATTR_MAX,\n\t                       tb[DCB_ATTR_BCN], dcbnl_bcn_nest);\n\tif (ret)\n\t\treturn ret;\n\n\tbcn_nest = nla_nest_start(skb, DCB_ATTR_BCN);\n\tif (!bcn_nest)\n\t\treturn -EMSGSIZE;\n\n\tif (bcn_tb[DCB_BCN_ATTR_ALL])\n\t\tgetall = true;\n\n\tfor (i = DCB_BCN_ATTR_RP_0; i <= DCB_BCN_ATTR_RP_7; i++) {\n\t\tif (!getall && !bcn_tb[i])\n\t\t\tcontinue;\n\n\t\tnetdev->dcbnl_ops->getbcnrp(netdev, i - DCB_BCN_ATTR_RP_0,\n\t\t                            &value_byte);\n\t\tret = nla_put_u8(skb, i, value_byte);\n\t\tif (ret)\n\t\t\tgoto err_bcn;\n\t}\n\n\tfor (i = DCB_BCN_ATTR_BCNA_0; i <= DCB_BCN_ATTR_RI; i++) {\n\t\tif (!getall && !bcn_tb[i])\n\t\t\tcontinue;\n\n\t\tnetdev->dcbnl_ops->getbcncfg(netdev, i,\n\t\t                             &value_integer);\n\t\tret = nla_put_u32(skb, i, value_integer);\n\t\tif (ret)\n\t\t\tgoto err_bcn;\n\t}\n\n\tnla_nest_end(skb, bcn_nest);\n\n\treturn 0;\n\nerr_bcn:\n\tnla_nest_cancel(skb, bcn_nest);\n\treturn ret;\n}\n\nstatic int dcbnl_bcn_setcfg(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t    u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tstruct nlattr *data[DCB_BCN_ATTR_MAX + 1];\n\tint i;\n\tint ret;\n\tu8 value_byte;\n\tu32 value_int;\n\n\tif (!tb[DCB_ATTR_BCN])\n\t\treturn -EINVAL;\n\n\tif (!netdev->dcbnl_ops->setbcncfg ||\n\t    !netdev->dcbnl_ops->setbcnrp)\n\t\treturn -EOPNOTSUPP;\n\n\tret = nla_parse_nested(data, DCB_BCN_ATTR_MAX,\n\t                       tb[DCB_ATTR_BCN],\n\t                       dcbnl_pfc_up_nest);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = DCB_BCN_ATTR_RP_0; i <= DCB_BCN_ATTR_RP_7; i++) {\n\t\tif (data[i] == NULL)\n\t\t\tcontinue;\n\t\tvalue_byte = nla_get_u8(data[i]);\n\t\tnetdev->dcbnl_ops->setbcnrp(netdev,\n\t\t\tdata[i]->nla_type - DCB_BCN_ATTR_RP_0, value_byte);\n\t}\n\n\tfor (i = DCB_BCN_ATTR_BCNA_0; i <= DCB_BCN_ATTR_RI; i++) {\n\t\tif (data[i] == NULL)\n\t\t\tcontinue;\n\t\tvalue_int = nla_get_u32(data[i]);\n\t\tnetdev->dcbnl_ops->setbcncfg(netdev,\n\t                                     i, value_int);\n\t}\n\n\treturn nla_put_u8(skb, DCB_ATTR_BCN, 0);\n}\n\nstatic int dcbnl_build_peer_app(struct net_device *netdev, struct sk_buff* skb,\n\t\t\t\tint app_nested_type, int app_info_type,\n\t\t\t\tint app_entry_type)\n{\n\tstruct dcb_peer_app_info info;\n\tstruct dcb_app *table = NULL;\n\tconst struct dcbnl_rtnl_ops *ops = netdev->dcbnl_ops;\n\tu16 app_count;\n\tint err;\n\n\n\t/**\n\t * retrieve the peer app configuration form the driver. If the driver\n\t * handlers fail exit without doing anything\n\t */\n\terr = ops->peer_getappinfo(netdev, &info, &app_count);\n\tif (!err && app_count) {\n\t\ttable = kmalloc(sizeof(struct dcb_app) * app_count, GFP_KERNEL);\n\t\tif (!table)\n\t\t\treturn -ENOMEM;\n\n\t\terr = ops->peer_getapptable(netdev, table);\n\t}\n\n\tif (!err) {\n\t\tu16 i;\n\t\tstruct nlattr *app;\n\n\t\t/**\n\t\t * build the message, from here on the only possible failure\n\t\t * is due to the skb size\n\t\t */\n\t\terr = -EMSGSIZE;\n\n\t\tapp = nla_nest_start(skb, app_nested_type);\n\t\tif (!app)\n\t\t\tgoto nla_put_failure;\n\n\t\tif (app_info_type &&\n\t\t    nla_put(skb, app_info_type, sizeof(info), &info))\n\t\t\tgoto nla_put_failure;\n\n\t\tfor (i = 0; i < app_count; i++) {\n\t\t\tif (nla_put(skb, app_entry_type, sizeof(struct dcb_app),\n\t\t\t\t    &table[i]))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\t\tnla_nest_end(skb, app);\n\t}\n\terr = 0;\n\nnla_put_failure:\n\tkfree(table);\n\treturn err;\n}\n\n/* Handle IEEE 802.1Qaz GET commands. */\nstatic int dcbnl_ieee_fill(struct sk_buff *skb, struct net_device *netdev)\n{\n\tstruct nlattr *ieee, *app;\n\tstruct dcb_app_type *itr;\n\tconst struct dcbnl_rtnl_ops *ops = netdev->dcbnl_ops;\n\tint dcbx;\n\tint err;\n\n\tif (nla_put_string(skb, DCB_ATTR_IFNAME, netdev->name))\n\t\treturn -EMSGSIZE;\n\n\tieee = nla_nest_start(skb, DCB_ATTR_IEEE);\n\tif (!ieee)\n\t\treturn -EMSGSIZE;\n\n\tif (ops->ieee_getets) {\n\t\tstruct ieee_ets ets;\n\t\tmemset(&ets, 0, sizeof(ets));\n\t\terr = ops->ieee_getets(netdev, &ets);\n\t\tif (!err &&\n\t\t    nla_put(skb, DCB_ATTR_IEEE_ETS, sizeof(ets), &ets))\n\t\t\treturn -EMSGSIZE;\n\t}\n\n\tif (ops->ieee_getmaxrate) {\n\t\tstruct ieee_maxrate maxrate;\n\t\tmemset(&maxrate, 0, sizeof(maxrate));\n\t\terr = ops->ieee_getmaxrate(netdev, &maxrate);\n\t\tif (!err) {\n\t\t\terr = nla_put(skb, DCB_ATTR_IEEE_MAXRATE,\n\t\t\t\t      sizeof(maxrate), &maxrate);\n\t\t\tif (err)\n\t\t\t\treturn -EMSGSIZE;\n\t\t}\n\t}\n\n\tif (ops->ieee_getpfc) {\n\t\tstruct ieee_pfc pfc;\n\t\tmemset(&pfc, 0, sizeof(pfc));\n\t\terr = ops->ieee_getpfc(netdev, &pfc);\n\t\tif (!err &&\n\t\t    nla_put(skb, DCB_ATTR_IEEE_PFC, sizeof(pfc), &pfc))\n\t\t\treturn -EMSGSIZE;\n\t}\n\n\tapp = nla_nest_start(skb, DCB_ATTR_IEEE_APP_TABLE);\n\tif (!app)\n\t\treturn -EMSGSIZE;\n\n\tspin_lock(&dcb_lock);\n\tlist_for_each_entry(itr, &dcb_app_list, list) {\n\t\tif (itr->ifindex == netdev->ifindex) {\n\t\t\terr = nla_put(skb, DCB_ATTR_IEEE_APP, sizeof(itr->app),\n\t\t\t\t\t &itr->app);\n\t\t\tif (err) {\n\t\t\t\tspin_unlock(&dcb_lock);\n\t\t\t\treturn -EMSGSIZE;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (netdev->dcbnl_ops->getdcbx)\n\t\tdcbx = netdev->dcbnl_ops->getdcbx(netdev);\n\telse\n\t\tdcbx = -EOPNOTSUPP;\n\n\tspin_unlock(&dcb_lock);\n\tnla_nest_end(skb, app);\n\n\t/* get peer info if available */\n\tif (ops->ieee_peer_getets) {\n\t\tstruct ieee_ets ets;\n\t\tmemset(&ets, 0, sizeof(ets));\n\t\terr = ops->ieee_peer_getets(netdev, &ets);\n\t\tif (!err &&\n\t\t    nla_put(skb, DCB_ATTR_IEEE_PEER_ETS, sizeof(ets), &ets))\n\t\t\treturn -EMSGSIZE;\n\t}\n\n\tif (ops->ieee_peer_getpfc) {\n\t\tstruct ieee_pfc pfc;\n\t\tmemset(&pfc, 0, sizeof(pfc));\n\t\terr = ops->ieee_peer_getpfc(netdev, &pfc);\n\t\tif (!err &&\n\t\t    nla_put(skb, DCB_ATTR_IEEE_PEER_PFC, sizeof(pfc), &pfc))\n\t\t\treturn -EMSGSIZE;\n\t}\n\n\tif (ops->peer_getappinfo && ops->peer_getapptable) {\n\t\terr = dcbnl_build_peer_app(netdev, skb,\n\t\t\t\t\t   DCB_ATTR_IEEE_PEER_APP,\n\t\t\t\t\t   DCB_ATTR_IEEE_APP_UNSPEC,\n\t\t\t\t\t   DCB_ATTR_IEEE_APP);\n\t\tif (err)\n\t\t\treturn -EMSGSIZE;\n\t}\n\n\tnla_nest_end(skb, ieee);\n\tif (dcbx >= 0) {\n\t\terr = nla_put_u8(skb, DCB_ATTR_DCBX, dcbx);\n\t\tif (err)\n\t\t\treturn -EMSGSIZE;\n\t}\n\n\treturn 0;\n}\n\nstatic int dcbnl_cee_pg_fill(struct sk_buff *skb, struct net_device *dev,\n\t\t\t     int dir)\n{\n\tu8 pgid, up_map, prio, tc_pct;\n\tconst struct dcbnl_rtnl_ops *ops = dev->dcbnl_ops;\n\tint i = dir ? DCB_ATTR_CEE_TX_PG : DCB_ATTR_CEE_RX_PG;\n\tstruct nlattr *pg = nla_nest_start(skb, i);\n\n\tif (!pg)\n\t\treturn -EMSGSIZE;\n\n\tfor (i = DCB_PG_ATTR_TC_0; i <= DCB_PG_ATTR_TC_7; i++) {\n\t\tstruct nlattr *tc_nest = nla_nest_start(skb, i);\n\n\t\tif (!tc_nest)\n\t\t\treturn -EMSGSIZE;\n\n\t\tpgid = DCB_ATTR_VALUE_UNDEFINED;\n\t\tprio = DCB_ATTR_VALUE_UNDEFINED;\n\t\ttc_pct = DCB_ATTR_VALUE_UNDEFINED;\n\t\tup_map = DCB_ATTR_VALUE_UNDEFINED;\n\n\t\tif (!dir)\n\t\t\tops->getpgtccfgrx(dev, i - DCB_PG_ATTR_TC_0,\n\t\t\t\t\t  &prio, &pgid, &tc_pct, &up_map);\n\t\telse\n\t\t\tops->getpgtccfgtx(dev, i - DCB_PG_ATTR_TC_0,\n\t\t\t\t\t  &prio, &pgid, &tc_pct, &up_map);\n\n\t\tif (nla_put_u8(skb, DCB_TC_ATTR_PARAM_PGID, pgid) ||\n\t\t    nla_put_u8(skb, DCB_TC_ATTR_PARAM_UP_MAPPING, up_map) ||\n\t\t    nla_put_u8(skb, DCB_TC_ATTR_PARAM_STRICT_PRIO, prio) ||\n\t\t    nla_put_u8(skb, DCB_TC_ATTR_PARAM_BW_PCT, tc_pct))\n\t\t\treturn -EMSGSIZE;\n\t\tnla_nest_end(skb, tc_nest);\n\t}\n\n\tfor (i = DCB_PG_ATTR_BW_ID_0; i <= DCB_PG_ATTR_BW_ID_7; i++) {\n\t\ttc_pct = DCB_ATTR_VALUE_UNDEFINED;\n\n\t\tif (!dir)\n\t\t\tops->getpgbwgcfgrx(dev, i - DCB_PG_ATTR_BW_ID_0,\n\t\t\t\t\t   &tc_pct);\n\t\telse\n\t\t\tops->getpgbwgcfgtx(dev, i - DCB_PG_ATTR_BW_ID_0,\n\t\t\t\t\t   &tc_pct);\n\t\tif (nla_put_u8(skb, i, tc_pct))\n\t\t\treturn -EMSGSIZE;\n\t}\n\tnla_nest_end(skb, pg);\n\treturn 0;\n}\n\nstatic int dcbnl_cee_fill(struct sk_buff *skb, struct net_device *netdev)\n{\n\tstruct nlattr *cee, *app;\n\tstruct dcb_app_type *itr;\n\tconst struct dcbnl_rtnl_ops *ops = netdev->dcbnl_ops;\n\tint dcbx, i, err = -EMSGSIZE;\n\tu8 value;\n\n\tif (nla_put_string(skb, DCB_ATTR_IFNAME, netdev->name))\n\t\tgoto nla_put_failure;\n\tcee = nla_nest_start(skb, DCB_ATTR_CEE);\n\tif (!cee)\n\t\tgoto nla_put_failure;\n\n\t/* local pg */\n\tif (ops->getpgtccfgtx && ops->getpgbwgcfgtx) {\n\t\terr = dcbnl_cee_pg_fill(skb, netdev, 1);\n\t\tif (err)\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (ops->getpgtccfgrx && ops->getpgbwgcfgrx) {\n\t\terr = dcbnl_cee_pg_fill(skb, netdev, 0);\n\t\tif (err)\n\t\t\tgoto nla_put_failure;\n\t}\n\n\t/* local pfc */\n\tif (ops->getpfccfg) {\n\t\tstruct nlattr *pfc_nest = nla_nest_start(skb, DCB_ATTR_CEE_PFC);\n\n\t\tif (!pfc_nest)\n\t\t\tgoto nla_put_failure;\n\n\t\tfor (i = DCB_PFC_UP_ATTR_0; i <= DCB_PFC_UP_ATTR_7; i++) {\n\t\t\tops->getpfccfg(netdev, i - DCB_PFC_UP_ATTR_0, &value);\n\t\t\tif (nla_put_u8(skb, i, value))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\t\tnla_nest_end(skb, pfc_nest);\n\t}\n\n\t/* local app */\n\tspin_lock(&dcb_lock);\n\tapp = nla_nest_start(skb, DCB_ATTR_CEE_APP_TABLE);\n\tif (!app)\n\t\tgoto dcb_unlock;\n\n\tlist_for_each_entry(itr, &dcb_app_list, list) {\n\t\tif (itr->ifindex == netdev->ifindex) {\n\t\t\tstruct nlattr *app_nest = nla_nest_start(skb,\n\t\t\t\t\t\t\t\t DCB_ATTR_APP);\n\t\t\tif (!app_nest)\n\t\t\t\tgoto dcb_unlock;\n\n\t\t\terr = nla_put_u8(skb, DCB_APP_ATTR_IDTYPE,\n\t\t\t\t\t itr->app.selector);\n\t\t\tif (err)\n\t\t\t\tgoto dcb_unlock;\n\n\t\t\terr = nla_put_u16(skb, DCB_APP_ATTR_ID,\n\t\t\t\t\t  itr->app.protocol);\n\t\t\tif (err)\n\t\t\t\tgoto dcb_unlock;\n\n\t\t\terr = nla_put_u8(skb, DCB_APP_ATTR_PRIORITY,\n\t\t\t\t\t itr->app.priority);\n\t\t\tif (err)\n\t\t\t\tgoto dcb_unlock;\n\n\t\t\tnla_nest_end(skb, app_nest);\n\t\t}\n\t}\n\tnla_nest_end(skb, app);\n\n\tif (netdev->dcbnl_ops->getdcbx)\n\t\tdcbx = netdev->dcbnl_ops->getdcbx(netdev);\n\telse\n\t\tdcbx = -EOPNOTSUPP;\n\n\tspin_unlock(&dcb_lock);\n\n\t/* features flags */\n\tif (ops->getfeatcfg) {\n\t\tstruct nlattr *feat = nla_nest_start(skb, DCB_ATTR_CEE_FEAT);\n\t\tif (!feat)\n\t\t\tgoto nla_put_failure;\n\n\t\tfor (i = DCB_FEATCFG_ATTR_ALL + 1; i <= DCB_FEATCFG_ATTR_MAX;\n\t\t     i++)\n\t\t\tif (!ops->getfeatcfg(netdev, i, &value) &&\n\t\t\t    nla_put_u8(skb, i, value))\n\t\t\t\tgoto nla_put_failure;\n\n\t\tnla_nest_end(skb, feat);\n\t}\n\n\t/* peer info if available */\n\tif (ops->cee_peer_getpg) {\n\t\tstruct cee_pg pg;\n\t\tmemset(&pg, 0, sizeof(pg));\n\t\terr = ops->cee_peer_getpg(netdev, &pg);\n\t\tif (!err &&\n\t\t    nla_put(skb, DCB_ATTR_CEE_PEER_PG, sizeof(pg), &pg))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (ops->cee_peer_getpfc) {\n\t\tstruct cee_pfc pfc;\n\t\tmemset(&pfc, 0, sizeof(pfc));\n\t\terr = ops->cee_peer_getpfc(netdev, &pfc);\n\t\tif (!err &&\n\t\t    nla_put(skb, DCB_ATTR_CEE_PEER_PFC, sizeof(pfc), &pfc))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (ops->peer_getappinfo && ops->peer_getapptable) {\n\t\terr = dcbnl_build_peer_app(netdev, skb,\n\t\t\t\t\t   DCB_ATTR_CEE_PEER_APP_TABLE,\n\t\t\t\t\t   DCB_ATTR_CEE_PEER_APP_INFO,\n\t\t\t\t\t   DCB_ATTR_CEE_PEER_APP);\n\t\tif (err)\n\t\t\tgoto nla_put_failure;\n\t}\n\tnla_nest_end(skb, cee);\n\n\t/* DCBX state */\n\tif (dcbx >= 0) {\n\t\terr = nla_put_u8(skb, DCB_ATTR_DCBX, dcbx);\n\t\tif (err)\n\t\t\tgoto nla_put_failure;\n\t}\n\treturn 0;\n\ndcb_unlock:\n\tspin_unlock(&dcb_lock);\nnla_put_failure:\n\treturn err;\n}\n\nstatic int dcbnl_notify(struct net_device *dev, int event, int cmd,\n\t\t\tu32 seq, u32 portid, int dcbx_ver)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\tconst struct dcbnl_rtnl_ops *ops = dev->dcbnl_ops;\n\tint err;\n\n\tif (!ops)\n\t\treturn -EOPNOTSUPP;\n\n\tskb = dcbnl_newmsg(event, cmd, portid, seq, 0, &nlh);\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\n\tif (dcbx_ver == DCB_CAP_DCBX_VER_IEEE)\n\t\terr = dcbnl_ieee_fill(skb, dev);\n\telse\n\t\terr = dcbnl_cee_fill(skb, dev);\n\n\tif (err < 0) {\n\t\t/* Report error to broadcast listeners */\n\t\tnlmsg_free(skb);\n\t\trtnl_set_sk_err(net, RTNLGRP_DCB, err);\n\t} else {\n\t\t/* End nlmsg and notify broadcast listeners */\n\t\tnlmsg_end(skb, nlh);\n\t\trtnl_notify(skb, net, 0, RTNLGRP_DCB, NULL, GFP_KERNEL);\n\t}\n\n\treturn err;\n}\n\nint dcbnl_ieee_notify(struct net_device *dev, int event, int cmd,\n\t\t      u32 seq, u32 portid)\n{\n\treturn dcbnl_notify(dev, event, cmd, seq, portid, DCB_CAP_DCBX_VER_IEEE);\n}\nEXPORT_SYMBOL(dcbnl_ieee_notify);\n\nint dcbnl_cee_notify(struct net_device *dev, int event, int cmd,\n\t\t     u32 seq, u32 portid)\n{\n\treturn dcbnl_notify(dev, event, cmd, seq, portid, DCB_CAP_DCBX_VER_CEE);\n}\nEXPORT_SYMBOL(dcbnl_cee_notify);\n\n/* Handle IEEE 802.1Qaz SET commands. If any requested operation can not\n * be completed the entire msg is aborted and error value is returned.\n * No attempt is made to reconcile the case where only part of the\n * cmd can be completed.\n */\nstatic int dcbnl_ieee_set(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t  u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tconst struct dcbnl_rtnl_ops *ops = netdev->dcbnl_ops;\n\tstruct nlattr *ieee[DCB_ATTR_IEEE_MAX + 1];\n\tint err;\n\n\tif (!ops)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!tb[DCB_ATTR_IEEE])\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested(ieee, DCB_ATTR_IEEE_MAX,\n\t\t\t       tb[DCB_ATTR_IEEE], dcbnl_ieee_policy);\n\tif (err)\n\t\treturn err;\n\n\tif (ieee[DCB_ATTR_IEEE_ETS] && ops->ieee_setets) {\n\t\tstruct ieee_ets *ets = nla_data(ieee[DCB_ATTR_IEEE_ETS]);\n\t\terr = ops->ieee_setets(netdev, ets);\n\t\tif (err)\n\t\t\tgoto err;\n\t}\n\n\tif (ieee[DCB_ATTR_IEEE_MAXRATE] && ops->ieee_setmaxrate) {\n\t\tstruct ieee_maxrate *maxrate =\n\t\t\tnla_data(ieee[DCB_ATTR_IEEE_MAXRATE]);\n\t\terr = ops->ieee_setmaxrate(netdev, maxrate);\n\t\tif (err)\n\t\t\tgoto err;\n\t}\n\n\tif (ieee[DCB_ATTR_IEEE_PFC] && ops->ieee_setpfc) {\n\t\tstruct ieee_pfc *pfc = nla_data(ieee[DCB_ATTR_IEEE_PFC]);\n\t\terr = ops->ieee_setpfc(netdev, pfc);\n\t\tif (err)\n\t\t\tgoto err;\n\t}\n\n\tif (ieee[DCB_ATTR_IEEE_APP_TABLE]) {\n\t\tstruct nlattr *attr;\n\t\tint rem;\n\n\t\tnla_for_each_nested(attr, ieee[DCB_ATTR_IEEE_APP_TABLE], rem) {\n\t\t\tstruct dcb_app *app_data;\n\t\t\tif (nla_type(attr) != DCB_ATTR_IEEE_APP)\n\t\t\t\tcontinue;\n\t\t\tapp_data = nla_data(attr);\n\t\t\tif (ops->ieee_setapp)\n\t\t\t\terr = ops->ieee_setapp(netdev, app_data);\n\t\t\telse\n\t\t\t\terr = dcb_ieee_setapp(netdev, app_data);\n\t\t\tif (err)\n\t\t\t\tgoto err;\n\t\t}\n\t}\n\nerr:\n\terr = nla_put_u8(skb, DCB_ATTR_IEEE, err);\n\tdcbnl_ieee_notify(netdev, RTM_SETDCB, DCB_CMD_IEEE_SET, seq, 0);\n\treturn err;\n}\n\nstatic int dcbnl_ieee_get(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t  u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tconst struct dcbnl_rtnl_ops *ops = netdev->dcbnl_ops;\n\n\tif (!ops)\n\t\treturn -EOPNOTSUPP;\n\n\treturn dcbnl_ieee_fill(skb, netdev);\n}\n\nstatic int dcbnl_ieee_del(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t  u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tconst struct dcbnl_rtnl_ops *ops = netdev->dcbnl_ops;\n\tstruct nlattr *ieee[DCB_ATTR_IEEE_MAX + 1];\n\tint err;\n\n\tif (!ops)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!tb[DCB_ATTR_IEEE])\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested(ieee, DCB_ATTR_IEEE_MAX,\n\t\t\t       tb[DCB_ATTR_IEEE], dcbnl_ieee_policy);\n\tif (err)\n\t\treturn err;\n\n\tif (ieee[DCB_ATTR_IEEE_APP_TABLE]) {\n\t\tstruct nlattr *attr;\n\t\tint rem;\n\n\t\tnla_for_each_nested(attr, ieee[DCB_ATTR_IEEE_APP_TABLE], rem) {\n\t\t\tstruct dcb_app *app_data;\n\n\t\t\tif (nla_type(attr) != DCB_ATTR_IEEE_APP)\n\t\t\t\tcontinue;\n\t\t\tapp_data = nla_data(attr);\n\t\t\tif (ops->ieee_delapp)\n\t\t\t\terr = ops->ieee_delapp(netdev, app_data);\n\t\t\telse\n\t\t\t\terr = dcb_ieee_delapp(netdev, app_data);\n\t\t\tif (err)\n\t\t\t\tgoto err;\n\t\t}\n\t}\n\nerr:\n\terr = nla_put_u8(skb, DCB_ATTR_IEEE, err);\n\tdcbnl_ieee_notify(netdev, RTM_SETDCB, DCB_CMD_IEEE_DEL, seq, 0);\n\treturn err;\n}\n\n\n/* DCBX configuration */\nstatic int dcbnl_getdcbx(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tif (!netdev->dcbnl_ops->getdcbx)\n\t\treturn -EOPNOTSUPP;\n\n\treturn nla_put_u8(skb, DCB_ATTR_DCBX,\n\t\t\t  netdev->dcbnl_ops->getdcbx(netdev));\n}\n\nstatic int dcbnl_setdcbx(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tu8 value;\n\n\tif (!netdev->dcbnl_ops->setdcbx)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!tb[DCB_ATTR_DCBX])\n\t\treturn -EINVAL;\n\n\tvalue = nla_get_u8(tb[DCB_ATTR_DCBX]);\n\n\treturn nla_put_u8(skb, DCB_ATTR_DCBX,\n\t\t\t  netdev->dcbnl_ops->setdcbx(netdev, value));\n}\n\nstatic int dcbnl_getfeatcfg(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t    u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tstruct nlattr *data[DCB_FEATCFG_ATTR_MAX + 1], *nest;\n\tu8 value;\n\tint ret, i;\n\tint getall = 0;\n\n\tif (!netdev->dcbnl_ops->getfeatcfg)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!tb[DCB_ATTR_FEATCFG])\n\t\treturn -EINVAL;\n\n\tret = nla_parse_nested(data, DCB_FEATCFG_ATTR_MAX, tb[DCB_ATTR_FEATCFG],\n\t\t\t       dcbnl_featcfg_nest);\n\tif (ret)\n\t\treturn ret;\n\n\tnest = nla_nest_start(skb, DCB_ATTR_FEATCFG);\n\tif (!nest)\n\t\treturn -EMSGSIZE;\n\n\tif (data[DCB_FEATCFG_ATTR_ALL])\n\t\tgetall = 1;\n\n\tfor (i = DCB_FEATCFG_ATTR_ALL+1; i <= DCB_FEATCFG_ATTR_MAX; i++) {\n\t\tif (!getall && !data[i])\n\t\t\tcontinue;\n\n\t\tret = netdev->dcbnl_ops->getfeatcfg(netdev, i, &value);\n\t\tif (!ret)\n\t\t\tret = nla_put_u8(skb, i, value);\n\n\t\tif (ret) {\n\t\t\tnla_nest_cancel(skb, nest);\n\t\t\tgoto nla_put_failure;\n\t\t}\n\t}\n\tnla_nest_end(skb, nest);\n\nnla_put_failure:\n\treturn ret;\n}\n\nstatic int dcbnl_setfeatcfg(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t    u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tstruct nlattr *data[DCB_FEATCFG_ATTR_MAX + 1];\n\tint ret, i;\n\tu8 value;\n\n\tif (!netdev->dcbnl_ops->setfeatcfg)\n\t\treturn -ENOTSUPP;\n\n\tif (!tb[DCB_ATTR_FEATCFG])\n\t\treturn -EINVAL;\n\n\tret = nla_parse_nested(data, DCB_FEATCFG_ATTR_MAX, tb[DCB_ATTR_FEATCFG],\n\t\t\t       dcbnl_featcfg_nest);\n\n\tif (ret)\n\t\tgoto err;\n\n\tfor (i = DCB_FEATCFG_ATTR_ALL+1; i <= DCB_FEATCFG_ATTR_MAX; i++) {\n\t\tif (data[i] == NULL)\n\t\t\tcontinue;\n\n\t\tvalue = nla_get_u8(data[i]);\n\n\t\tret = netdev->dcbnl_ops->setfeatcfg(netdev, i, value);\n\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\nerr:\n\tret = nla_put_u8(skb, DCB_ATTR_FEATCFG, ret);\n\n\treturn ret;\n}\n\n/* Handle CEE DCBX GET commands. */\nstatic int dcbnl_cee_get(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tconst struct dcbnl_rtnl_ops *ops = netdev->dcbnl_ops;\n\n\tif (!ops)\n\t\treturn -EOPNOTSUPP;\n\n\treturn dcbnl_cee_fill(skb, netdev);\n}\n\nstruct reply_func {\n\t/* reply netlink message type */\n\tint\ttype;\n\n\t/* function to fill message contents */\n\tint   (*cb)(struct net_device *, struct nlmsghdr *, u32,\n\t\t    struct nlattr **, struct sk_buff *);\n};\n\nstatic const struct reply_func reply_funcs[DCB_CMD_MAX+1] = {\n\t[DCB_CMD_GSTATE]\t= { RTM_GETDCB, dcbnl_getstate },\n\t[DCB_CMD_SSTATE]\t= { RTM_SETDCB, dcbnl_setstate },\n\t[DCB_CMD_PFC_GCFG]\t= { RTM_GETDCB, dcbnl_getpfccfg },\n\t[DCB_CMD_PFC_SCFG]\t= { RTM_SETDCB, dcbnl_setpfccfg },\n\t[DCB_CMD_GPERM_HWADDR]\t= { RTM_GETDCB, dcbnl_getperm_hwaddr },\n\t[DCB_CMD_GCAP]\t\t= { RTM_GETDCB, dcbnl_getcap },\n\t[DCB_CMD_GNUMTCS]\t= { RTM_GETDCB, dcbnl_getnumtcs },\n\t[DCB_CMD_SNUMTCS]\t= { RTM_SETDCB, dcbnl_setnumtcs },\n\t[DCB_CMD_PFC_GSTATE]\t= { RTM_GETDCB, dcbnl_getpfcstate },\n\t[DCB_CMD_PFC_SSTATE]\t= { RTM_SETDCB, dcbnl_setpfcstate },\n\t[DCB_CMD_GAPP]\t\t= { RTM_GETDCB, dcbnl_getapp },\n\t[DCB_CMD_SAPP]\t\t= { RTM_SETDCB, dcbnl_setapp },\n\t[DCB_CMD_PGTX_GCFG]\t= { RTM_GETDCB, dcbnl_pgtx_getcfg },\n\t[DCB_CMD_PGTX_SCFG]\t= { RTM_SETDCB, dcbnl_pgtx_setcfg },\n\t[DCB_CMD_PGRX_GCFG]\t= { RTM_GETDCB, dcbnl_pgrx_getcfg },\n\t[DCB_CMD_PGRX_SCFG]\t= { RTM_SETDCB, dcbnl_pgrx_setcfg },\n\t[DCB_CMD_SET_ALL]\t= { RTM_SETDCB, dcbnl_setall },\n\t[DCB_CMD_BCN_GCFG]\t= { RTM_GETDCB, dcbnl_bcn_getcfg },\n\t[DCB_CMD_BCN_SCFG]\t= { RTM_SETDCB, dcbnl_bcn_setcfg },\n\t[DCB_CMD_IEEE_GET]\t= { RTM_GETDCB, dcbnl_ieee_get },\n\t[DCB_CMD_IEEE_SET]\t= { RTM_SETDCB, dcbnl_ieee_set },\n\t[DCB_CMD_IEEE_DEL]\t= { RTM_SETDCB, dcbnl_ieee_del },\n\t[DCB_CMD_GDCBX]\t\t= { RTM_GETDCB, dcbnl_getdcbx },\n\t[DCB_CMD_SDCBX]\t\t= { RTM_SETDCB, dcbnl_setdcbx },\n\t[DCB_CMD_GFEATCFG]\t= { RTM_GETDCB, dcbnl_getfeatcfg },\n\t[DCB_CMD_SFEATCFG]\t= { RTM_SETDCB, dcbnl_setfeatcfg },\n\t[DCB_CMD_CEE_GET]\t= { RTM_GETDCB, dcbnl_cee_get },\n};\n\nstatic int dcb_doit(struct sk_buff *skb, struct nlmsghdr *nlh, void *arg)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct net_device *netdev;\n\tstruct dcbmsg *dcb = nlmsg_data(nlh);\n\tstruct nlattr *tb[DCB_ATTR_MAX + 1];\n\tu32 portid = skb ? NETLINK_CB(skb).portid : 0;\n\tint ret = -EINVAL;\n\tstruct sk_buff *reply_skb;\n\tstruct nlmsghdr *reply_nlh = NULL;\n\tconst struct reply_func *fn;\n\n\tif ((nlh->nlmsg_type == RTM_SETDCB) && !capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tret = nlmsg_parse(nlh, sizeof(*dcb), tb, DCB_ATTR_MAX,\n\t\t\t  dcbnl_rtnl_policy);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (dcb->cmd > DCB_CMD_MAX)\n\t\treturn -EINVAL;\n\n\t/* check if a reply function has been defined for the command */\n\tfn = &reply_funcs[dcb->cmd];\n\tif (!fn->cb)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!tb[DCB_ATTR_IFNAME])\n\t\treturn -EINVAL;\n\n\tnetdev = dev_get_by_name(net, nla_data(tb[DCB_ATTR_IFNAME]));\n\tif (!netdev)\n\t\treturn -ENODEV;\n\n\tif (!netdev->dcbnl_ops) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\treply_skb = dcbnl_newmsg(fn->type, dcb->cmd, portid, nlh->nlmsg_seq,\n\t\t\t\t nlh->nlmsg_flags, &reply_nlh);\n\tif (!reply_skb) {\n\t\tret = -ENOBUFS;\n\t\tgoto out;\n\t}\n\n\tret = fn->cb(netdev, nlh, nlh->nlmsg_seq, tb, reply_skb);\n\tif (ret < 0) {\n\t\tnlmsg_free(reply_skb);\n\t\tgoto out;\n\t}\n\n\tnlmsg_end(reply_skb, reply_nlh);\n\n\tret = rtnl_unicast(reply_skb, net, portid);\nout:\n\tdev_put(netdev);\n\treturn ret;\n}\n\nstatic struct dcb_app_type *dcb_app_lookup(const struct dcb_app *app,\n\t\t\t\t\t   int ifindex, int prio)\n{\n\tstruct dcb_app_type *itr;\n\n\tlist_for_each_entry(itr, &dcb_app_list, list) {\n\t\tif (itr->app.selector == app->selector &&\n\t\t    itr->app.protocol == app->protocol &&\n\t\t    itr->ifindex == ifindex &&\n\t\t    (!prio || itr->app.priority == prio))\n\t\t\treturn itr;\n\t}\n\n\treturn NULL;\n}\n\nstatic int dcb_app_add(const struct dcb_app *app, int ifindex)\n{\n\tstruct dcb_app_type *entry;\n\n\tentry = kmalloc(sizeof(*entry), GFP_ATOMIC);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tmemcpy(&entry->app, app, sizeof(*app));\n\tentry->ifindex = ifindex;\n\tlist_add(&entry->list, &dcb_app_list);\n\n\treturn 0;\n}\n\n/**\n * dcb_getapp - retrieve the DCBX application user priority\n *\n * On success returns a non-zero 802.1p user priority bitmap\n * otherwise returns 0 as the invalid user priority bitmap to\n * indicate an error.\n */\nu8 dcb_getapp(struct net_device *dev, struct dcb_app *app)\n{\n\tstruct dcb_app_type *itr;\n\tu8 prio = 0;\n\n\tspin_lock(&dcb_lock);\n\tif ((itr = dcb_app_lookup(app, dev->ifindex, 0)))\n\t\tprio = itr->app.priority;\n\tspin_unlock(&dcb_lock);\n\n\treturn prio;\n}\nEXPORT_SYMBOL(dcb_getapp);\n\n/**\n * dcb_setapp - add CEE dcb application data to app list\n *\n * Priority 0 is an invalid priority in CEE spec. This routine\n * removes applications from the app list if the priority is\n * set to zero.\n */\nint dcb_setapp(struct net_device *dev, struct dcb_app *new)\n{\n\tstruct dcb_app_type *itr;\n\tstruct dcb_app_type event;\n\tint err = 0;\n\n\tevent.ifindex = dev->ifindex;\n\tmemcpy(&event.app, new, sizeof(event.app));\n\tif (dev->dcbnl_ops->getdcbx)\n\t\tevent.dcbx = dev->dcbnl_ops->getdcbx(dev);\n\n\tspin_lock(&dcb_lock);\n\t/* Search for existing match and replace */\n\tif ((itr = dcb_app_lookup(new, dev->ifindex, 0))) {\n\t\tif (new->priority)\n\t\t\titr->app.priority = new->priority;\n\t\telse {\n\t\t\tlist_del(&itr->list);\n\t\t\tkfree(itr);\n\t\t}\n\t\tgoto out;\n\t}\n\t/* App type does not exist add new application type */\n\tif (new->priority)\n\t\terr = dcb_app_add(new, dev->ifindex);\nout:\n\tspin_unlock(&dcb_lock);\n\tif (!err)\n\t\tcall_dcbevent_notifiers(DCB_APP_EVENT, &event);\n\treturn err;\n}\nEXPORT_SYMBOL(dcb_setapp);\n\n/**\n * dcb_ieee_getapp_mask - retrieve the IEEE DCB application priority\n *\n * Helper routine which on success returns a non-zero 802.1Qaz user\n * priority bitmap otherwise returns 0 to indicate the dcb_app was\n * not found in APP list.\n */\nu8 dcb_ieee_getapp_mask(struct net_device *dev, struct dcb_app *app)\n{\n\tstruct dcb_app_type *itr;\n\tu8 prio = 0;\n\n\tspin_lock(&dcb_lock);\n\tif ((itr = dcb_app_lookup(app, dev->ifindex, 0)))\n\t\tprio |= 1 << itr->app.priority;\n\tspin_unlock(&dcb_lock);\n\n\treturn prio;\n}\nEXPORT_SYMBOL(dcb_ieee_getapp_mask);\n\n/**\n * dcb_ieee_setapp - add IEEE dcb application data to app list\n *\n * This adds Application data to the list. Multiple application\n * entries may exists for the same selector and protocol as long\n * as the priorities are different.\n */\nint dcb_ieee_setapp(struct net_device *dev, struct dcb_app *new)\n{\n\tstruct dcb_app_type event;\n\tint err = 0;\n\n\tevent.ifindex = dev->ifindex;\n\tmemcpy(&event.app, new, sizeof(event.app));\n\tif (dev->dcbnl_ops->getdcbx)\n\t\tevent.dcbx = dev->dcbnl_ops->getdcbx(dev);\n\n\tspin_lock(&dcb_lock);\n\t/* Search for existing match and abort if found */\n\tif (dcb_app_lookup(new, dev->ifindex, new->priority)) {\n\t\terr = -EEXIST;\n\t\tgoto out;\n\t}\n\n\terr = dcb_app_add(new, dev->ifindex);\nout:\n\tspin_unlock(&dcb_lock);\n\tif (!err)\n\t\tcall_dcbevent_notifiers(DCB_APP_EVENT, &event);\n\treturn err;\n}\nEXPORT_SYMBOL(dcb_ieee_setapp);\n\n/**\n * dcb_ieee_delapp - delete IEEE dcb application data from list\n *\n * This removes a matching APP data from the APP list\n */\nint dcb_ieee_delapp(struct net_device *dev, struct dcb_app *del)\n{\n\tstruct dcb_app_type *itr;\n\tstruct dcb_app_type event;\n\tint err = -ENOENT;\n\n\tevent.ifindex = dev->ifindex;\n\tmemcpy(&event.app, del, sizeof(event.app));\n\tif (dev->dcbnl_ops->getdcbx)\n\t\tevent.dcbx = dev->dcbnl_ops->getdcbx(dev);\n\n\tspin_lock(&dcb_lock);\n\t/* Search for existing match and remove it. */\n\tif ((itr = dcb_app_lookup(del, dev->ifindex, del->priority))) {\n\t\tlist_del(&itr->list);\n\t\tkfree(itr);\n\t\terr = 0;\n\t}\n\n\tspin_unlock(&dcb_lock);\n\tif (!err)\n\t\tcall_dcbevent_notifiers(DCB_APP_EVENT, &event);\n\treturn err;\n}\nEXPORT_SYMBOL(dcb_ieee_delapp);\n\nstatic void dcb_flushapp(void)\n{\n\tstruct dcb_app_type *app;\n\tstruct dcb_app_type *tmp;\n\n\tspin_lock(&dcb_lock);\n\tlist_for_each_entry_safe(app, tmp, &dcb_app_list, list) {\n\t\tlist_del(&app->list);\n\t\tkfree(app);\n\t}\n\tspin_unlock(&dcb_lock);\n}\n\nstatic int __init dcbnl_init(void)\n{\n\tINIT_LIST_HEAD(&dcb_app_list);\n\n\trtnl_register(PF_UNSPEC, RTM_GETDCB, dcb_doit, NULL, NULL);\n\trtnl_register(PF_UNSPEC, RTM_SETDCB, dcb_doit, NULL, NULL);\n\n\treturn 0;\n}\nmodule_init(dcbnl_init);\n\nstatic void __exit dcbnl_exit(void)\n{\n\trtnl_unregister(PF_UNSPEC, RTM_GETDCB);\n\trtnl_unregister(PF_UNSPEC, RTM_SETDCB);\n\tdcb_flushapp();\n}\nmodule_exit(dcbnl_exit);\n"], "filenames": ["net/dcb/dcbnl.c"], "buggy_code_start_loc": [286], "buggy_code_end_loc": [1290], "fixing_code_start_loc": [287], "fixing_code_end_loc": [1299], "type": "CWE-399", "message": "net/dcb/dcbnl.c in the Linux kernel before 3.8.4 does not initialize certain structures, which allows local users to obtain sensitive information from kernel stack memory via a crafted application.", "other": {"cve": {"id": "CVE-2013-2634", "sourceIdentifier": "cve@mitre.org", "published": "2013-03-22T11:59:11.973", "lastModified": "2014-02-07T04:47:16.467", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "net/dcb/dcbnl.c in the Linux kernel before 3.8.4 does not initialize certain structures, which allows local users to obtain sensitive information from kernel stack memory via a crafted application."}, {"lang": "es", "value": "net/dcb/dcbnl.c en el kernel de Linux anterior a v3.8.4 no inicializa determinadas estructuras, lo que permite a atacantes locales obtener informaci\u00f3n sensible desde la pila del kernel mediante una aplicaci\u00f3n especialmente dise\u00f1ada."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 1.9}, "baseSeverity": "LOW", "exploitabilityScore": 3.4, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-399"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.8.3", "matchCriteriaId": "7A40E2A8-BBC3-4763-B150-9193F30E9DF0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.0:*:*:*:*:*:*:*", "matchCriteriaId": "1A6E41FB-38CE-49F2-B796-9A5AA648E73F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.1:*:*:*:*:*:*:*", "matchCriteriaId": "93523FE1-5993-46CB-9299-7C8C1A04E873"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.2:*:*:*:*:*:*:*", "matchCriteriaId": "27ADC356-6BE9-43A3-9E0B-393DC4B1559A"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=29cd8ae0e1a39e239a3a7b67da1986add1199fc0", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2013-07/msg00018.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-updates/2013-12/msg00129.html", "source": "cve@mitre.org"}, {"url": "http://rhn.redhat.com/errata/RHSA-2013-1051.html", "source": "cve@mitre.org"}, {"url": "http://www.kernel.org/pub/linux/kernel/v3.x/ChangeLog-3.8.4", "source": "cve@mitre.org"}, {"url": "http://www.mandriva.com/security/advisories?name=MDVSA-2013:176", "source": "cve@mitre.org"}, {"url": "http://www.openwall.com/lists/oss-security/2013/03/20/1", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-1809-1", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-1811-1", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-1812-1", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-1813-1", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-1814-1", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-1829-1", "source": "cve@mitre.org"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=923652", "source": "cve@mitre.org"}, {"url": "https://github.com/torvalds/linux/commit/29cd8ae0e1a39e239a3a7b67da1986add1199fc0", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/29cd8ae0e1a39e239a3a7b67da1986add1199fc0"}}