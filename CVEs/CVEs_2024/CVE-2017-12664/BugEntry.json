{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%           QQQ   U   U   AAA   N   N  TTTTT  IIIII   ZZZZZ  EEEEE            %\n%          Q   Q  U   U  A   A  NN  N    T      I        ZZ  E                %\n%          Q   Q  U   U  AAAAA  N N N    T      I      ZZZ   EEEEE            %\n%          Q  QQ  U   U  A   A  N  NN    T      I     ZZ     E                %\n%           QQQQ   UUU   A   A  N   N    T    IIIII   ZZZZZ  EEEEE            %\n%                                                                             %\n%                                                                             %\n%    MagickCore Methods to Reduce the Number of Unique Colors in an Image     %\n%                                                                             %\n%                           Software Design                                   %\n%                                Cristy                                       %\n%                              July 1992                                      %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2017 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://www.imagemagick.org/script/license.php                           %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  Realism in computer graphics typically requires using 24 bits/pixel to\n%  generate an image.  Yet many graphic display devices do not contain the\n%  amount of memory necessary to match the spatial and color resolution of\n%  the human eye.  The Quantize methods takes a 24 bit image and reduces\n%  the number of colors so it can be displayed on raster device with less\n%  bits per pixel.  In most instances, the quantized image closely\n%  resembles the original reference image.\n%\n%  A reduction of colors in an image is also desirable for image\n%  transmission and real-time animation.\n%\n%  QuantizeImage() takes a standard RGB or monochrome images and quantizes\n%  them down to some fixed number of colors.\n%\n%  For purposes of color allocation, an image is a set of n pixels, where\n%  each pixel is a point in RGB space.  RGB space is a 3-dimensional\n%  vector space, and each pixel, Pi,  is defined by an ordered triple of\n%  red, green, and blue coordinates, (Ri, Gi, Bi).\n%\n%  Each primary color component (red, green, or blue) represents an\n%  intensity which varies linearly from 0 to a maximum value, Cmax, which\n%  corresponds to full saturation of that color.  Color allocation is\n%  defined over a domain consisting of the cube in RGB space with opposite\n%  vertices at (0,0,0) and (Cmax, Cmax, Cmax).  QUANTIZE requires Cmax =\n%  255.\n%\n%  The algorithm maps this domain onto a tree in which each node\n%  represents a cube within that domain.  In the following discussion\n%  these cubes are defined by the coordinate of two opposite vertices (vertex\n%  nearest the origin in RGB space and the vertex farthest from the origin).\n%\n%  The tree's root node represents the entire domain, (0,0,0) through\n%  (Cmax,Cmax,Cmax).  Each lower level in the tree is generated by\n%  subdividing one node's cube into eight smaller cubes of equal size.\n%  This corresponds to bisecting the parent cube with planes passing\n%  through the midpoints of each edge.\n%\n%  The basic algorithm operates in three phases: Classification,\n%  Reduction, and Assignment.  Classification builds a color description\n%  tree for the image.  Reduction collapses the tree until the number it\n%  represents, at most, the number of colors desired in the output image.\n%  Assignment defines the output image's color map and sets each pixel's\n%  color by restorage_class in the reduced tree.  Our goal is to minimize\n%  the numerical discrepancies between the original colors and quantized\n%  colors (quantization error).\n%\n%  Classification begins by initializing a color description tree of\n%  sufficient depth to represent each possible input color in a leaf.\n%  However, it is impractical to generate a fully-formed color description\n%  tree in the storage_class phase for realistic values of Cmax.  If\n%  colors components in the input image are quantized to k-bit precision,\n%  so that Cmax= 2k-1, the tree would need k levels below the root node to\n%  allow representing each possible input color in a leaf.  This becomes\n%  prohibitive because the tree's total number of nodes is 1 +\n%  sum(i=1, k, 8k).\n%\n%  A complete tree would require 19,173,961 nodes for k = 8, Cmax = 255.\n%  Therefore, to avoid building a fully populated tree, QUANTIZE: (1)\n%  Initializes data structures for nodes only as they are needed;  (2)\n%  Chooses a maximum depth for the tree as a function of the desired\n%  number of colors in the output image (currently log2(colormap size)).\n%\n%  For each pixel in the input image, storage_class scans downward from\n%  the root of the color description tree.  At each level of the tree it\n%  identifies the single node which represents a cube in RGB space\n%  containing the pixel's color.  It updates the following data for each\n%  such node:\n%\n%    n1: Number of pixels whose color is contained in the RGB cube which\n%    this node represents;\n%\n%    n2: Number of pixels whose color is not represented in a node at\n%    lower depth in the tree;  initially,  n2 = 0 for all nodes except\n%    leaves of the tree.\n%\n%    Sr, Sg, Sb: Sums of the red, green, and blue component values for all\n%    pixels not classified at a lower depth. The combination of these sums\n%    and n2 will ultimately characterize the mean color of a set of\n%    pixels represented by this node.\n%\n%    E: the distance squared in RGB space between each pixel contained\n%    within a node and the nodes' center.  This represents the\n%    quantization error for a node.\n%\n%  Reduction repeatedly prunes the tree until the number of nodes with n2\n%  > 0 is less than or equal to the maximum number of colors allowed in\n%  the output image.  On any given iteration over the tree, it selects\n%  those nodes whose E count is minimal for pruning and merges their color\n%  statistics upward. It uses a pruning threshold, Ep, to govern node\n%  selection as follows:\n%\n%    Ep = 0\n%    while number of nodes with (n2 > 0) > required maximum number of colors\n%      prune all nodes such that E <= Ep\n%      Set Ep to minimum E in remaining nodes\n%\n%  This has the effect of minimizing any quantization error when merging\n%  two nodes together.\n%\n%  When a node to be pruned has offspring, the pruning procedure invokes\n%  itself recursively in order to prune the tree from the leaves upward.\n%  n2,  Sr, Sg,  and  Sb in a node being pruned are always added to the\n%  corresponding data in that node's parent.  This retains the pruned\n%  node's color characteristics for later averaging.\n%\n%  For each node, n2 pixels exist for which that node represents the\n%  smallest volume in RGB space containing those pixel's colors.  When n2\n%  > 0 the node will uniquely define a color in the output image. At the\n%  beginning of reduction,  n2 = 0  for all nodes except a the leaves of\n%  the tree which represent colors present in the input image.\n%\n%  The other pixel count, n1, indicates the total number of colors within\n%  the cubic volume which the node represents.  This includes n1 - n2\n%  pixels whose colors should be defined by nodes at a lower level in the\n%  tree.\n%\n%  Assignment generates the output image from the pruned tree.  The output\n%  image consists of two parts: (1)  A color map, which is an array of\n%  color descriptions (RGB triples) for each color present in the output\n%  image;  (2)  A pixel array, which represents each pixel as an index\n%  into the color map array.\n%\n%  First, the assignment phase makes one pass over the pruned color\n%  description tree to establish the image's color map.  For each node\n%  with n2  > 0, it divides Sr, Sg, and Sb by n2 .  This produces the mean\n%  color of all pixels that classify no lower than this node.  Each of\n%  these colors becomes an entry in the color map.\n%\n%  Finally,  the assignment phase reclassifies each pixel in the pruned\n%  tree to identify the deepest node containing the pixel's color.  The\n%  pixel's value in the pixel array becomes the index of this node's mean\n%  color in the color map.\n%\n%  This method is based on a similar algorithm written by Paul Raveling.\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/cache-view.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/enhance.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/histogram.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/pixel-private.h\"\n#include \"MagickCore/quantize.h\"\n#include \"MagickCore/quantum.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/thread-private.h\"\n\f\n/*\n  Define declarations.\n*/\n#if !defined(__APPLE__) && !defined(TARGET_OS_IPHONE)\n#define CacheShift  2\n#else\n#define CacheShift  3\n#endif\n#define ErrorQueueLength  16\n#define MaxNodes  266817\n#define MaxTreeDepth  8\n#define NodesInAList  1920\n\f\n/*\n  Typdef declarations.\n*/\ntypedef struct _DoublePixelPacket\n{\n  double\n    red,\n    green,\n    blue,\n    alpha;\n} DoublePixelPacket;\n\ntypedef struct _NodeInfo\n{\n  struct _NodeInfo\n    *parent,\n    *child[16];\n\n  MagickSizeType\n    number_unique;\n\n  DoublePixelPacket\n    total_color;\n\n  double\n    quantize_error;\n\n  size_t\n    color_number,\n    id,\n    level;\n} NodeInfo;\n\ntypedef struct _Nodes\n{\n  NodeInfo\n    *nodes;\n\n  struct _Nodes\n    *next;\n} Nodes;\n\ntypedef struct _CubeInfo\n{\n  NodeInfo\n    *root;\n\n  size_t\n    colors,\n    maximum_colors;\n\n  ssize_t\n    transparent_index;\n\n  MagickSizeType\n    transparent_pixels;\n\n  DoublePixelPacket\n    target;\n\n  double\n    distance,\n    pruning_threshold,\n    next_threshold;\n\n  size_t\n    nodes,\n    free_nodes,\n    color_number;\n\n  NodeInfo\n    *next_node;\n\n  Nodes\n    *node_queue;\n\n  MemoryInfo\n    *memory_info;\n\n  ssize_t\n    *cache;\n\n  DoublePixelPacket\n    error[ErrorQueueLength];\n\n  double\n    weights[ErrorQueueLength];\n\n  QuantizeInfo\n    *quantize_info;\n\n  MagickBooleanType\n    associate_alpha;\n\n  ssize_t\n    x,\n    y;\n\n  size_t\n    depth;\n\n  MagickOffsetType\n    offset;\n\n  MagickSizeType\n    span;\n} CubeInfo;\n\f\n/*\n  Method prototypes.\n*/\nstatic CubeInfo\n  *GetCubeInfo(const QuantizeInfo *,const size_t,const size_t);\n\nstatic NodeInfo\n  *GetNodeInfo(CubeInfo *,const size_t,const size_t,NodeInfo *);\n\nstatic MagickBooleanType\n  AssignImageColors(Image *,CubeInfo *,ExceptionInfo *),\n  ClassifyImageColors(CubeInfo *,const Image *,ExceptionInfo *),\n  DitherImage(Image *,CubeInfo *,ExceptionInfo *),\n  SetGrayscaleImage(Image *,ExceptionInfo *);\n\nstatic size_t\n  DefineImageColormap(Image *,CubeInfo *,NodeInfo *);\n\nstatic void\n  ClosestColor(const Image *,CubeInfo *,const NodeInfo *),\n  DestroyCubeInfo(CubeInfo *),\n  PruneLevel(CubeInfo *,const NodeInfo *),\n  PruneToCubeDepth(CubeInfo *,const NodeInfo *),\n  ReduceImageColors(const Image *,CubeInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   A c q u i r e Q u a n t i z e I n f o                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquireQuantizeInfo() allocates the QuantizeInfo structure.\n%\n%  The format of the AcquireQuantizeInfo method is:\n%\n%      QuantizeInfo *AcquireQuantizeInfo(const ImageInfo *image_info)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n*/\nMagickExport QuantizeInfo *AcquireQuantizeInfo(const ImageInfo *image_info)\n{\n  QuantizeInfo\n    *quantize_info;\n\n  quantize_info=(QuantizeInfo *) AcquireMagickMemory(sizeof(*quantize_info));\n  if (quantize_info == (QuantizeInfo *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  GetQuantizeInfo(quantize_info);\n  if (image_info != (ImageInfo *) NULL)\n    {\n      const char\n        *option;\n\n      quantize_info->dither_method=image_info->dither == MagickFalse ?\n        NoDitherMethod : RiemersmaDitherMethod;\n      option=GetImageOption(image_info,\"dither\");\n      if (option != (const char *) NULL)\n        quantize_info->dither_method=(DitherMethod) ParseCommandOption(\n          MagickDitherOptions,MagickFalse,option);\n      quantize_info->measure_error=image_info->verbose;\n    }\n  return(quantize_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   A s s i g n I m a g e C o l o r s                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AssignImageColors() generates the output image from the pruned tree.  The\n%  output image consists of two parts: (1)  A color map, which is an array\n%  of color descriptions (RGB triples) for each color present in the\n%  output image;  (2)  A pixel array, which represents each pixel as an\n%  index into the color map array.\n%\n%  First, the assignment phase makes one pass over the pruned color\n%  description tree to establish the image's color map.  For each node\n%  with n2  > 0, it divides Sr, Sg, and Sb by n2 .  This produces the mean\n%  color of all pixels that classify no lower than this node.  Each of\n%  these colors becomes an entry in the color map.\n%\n%  Finally,  the assignment phase reclassifies each pixel in the pruned\n%  tree to identify the deepest node containing the pixel's color.  The\n%  pixel's value in the pixel array becomes the index of this node's mean\n%  color in the color map.\n%\n%  The format of the AssignImageColors() method is:\n%\n%      MagickBooleanType AssignImageColors(Image *image,CubeInfo *cube_info)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n%    o cube_info: A pointer to the Cube structure.\n%\n*/\n\nstatic inline void AssociateAlphaPixel(const Image *image,\n  const CubeInfo *cube_info,const Quantum *pixel,DoublePixelPacket *alpha_pixel)\n{\n  double\n    alpha;\n\n  if ((cube_info->associate_alpha == MagickFalse) ||\n      (GetPixelAlpha(image,pixel) == OpaqueAlpha))\n    {\n      alpha_pixel->red=(double) GetPixelRed(image,pixel);\n      alpha_pixel->green=(double) GetPixelGreen(image,pixel);\n      alpha_pixel->blue=(double) GetPixelBlue(image,pixel);\n      alpha_pixel->alpha=(double) GetPixelAlpha(image,pixel);\n      return;\n    }\n  alpha=(double) (QuantumScale*GetPixelAlpha(image,pixel));\n  alpha_pixel->red=alpha*GetPixelRed(image,pixel);\n  alpha_pixel->green=alpha*GetPixelGreen(image,pixel);\n  alpha_pixel->blue=alpha*GetPixelBlue(image,pixel);\n  alpha_pixel->alpha=(double) GetPixelAlpha(image,pixel);\n}\n\nstatic inline void AssociateAlphaPixelInfo(const CubeInfo *cube_info,\n  const PixelInfo *pixel,DoublePixelPacket *alpha_pixel)\n{\n  double\n    alpha;\n\n  if ((cube_info->associate_alpha == MagickFalse) ||\n      (pixel->alpha == OpaqueAlpha))\n    {\n      alpha_pixel->red=(double) pixel->red;\n      alpha_pixel->green=(double) pixel->green;\n      alpha_pixel->blue=(double) pixel->blue;\n      alpha_pixel->alpha=(double) pixel->alpha;\n      return;\n    }\n  alpha=(double) (QuantumScale*pixel->alpha);\n  alpha_pixel->red=alpha*pixel->red;\n  alpha_pixel->green=alpha*pixel->green;\n  alpha_pixel->blue=alpha*pixel->blue;\n  alpha_pixel->alpha=(double) pixel->alpha;\n}\n\nstatic inline size_t ColorToNodeId(const CubeInfo *cube_info,\n  const DoublePixelPacket *pixel,size_t index)\n{\n  size_t\n    id;\n\n  id=(size_t) (((ScaleQuantumToChar(ClampPixel(pixel->red)) >> index) & 0x01) |\n    ((ScaleQuantumToChar(ClampPixel(pixel->green)) >> index) & 0x01) << 1 |\n    ((ScaleQuantumToChar(ClampPixel(pixel->blue)) >> index) & 0x01) << 2);\n  if (cube_info->associate_alpha != MagickFalse)\n    id|=((ScaleQuantumToChar(ClampPixel(pixel->alpha)) >> index) & 0x1) << 3;\n  return(id);\n}\n\nstatic MagickBooleanType AssignImageColors(Image *image,CubeInfo *cube_info,\n  ExceptionInfo *exception)\n{\n#define AssignImageTag  \"Assign/Image\"\n\n  ssize_t\n    y;\n\n  /*\n    Allocate image colormap.\n  */\n  if ((cube_info->quantize_info->colorspace != UndefinedColorspace) &&\n      (cube_info->quantize_info->colorspace != CMYKColorspace))\n    (void) TransformImageColorspace(image,cube_info->quantize_info->colorspace,\n      exception);\n  else\n    if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n      (void) TransformImageColorspace(image,sRGBColorspace,exception);\n  if (AcquireImageColormap(image,cube_info->colors,exception) == MagickFalse)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);;\n  image->colors=0;\n  cube_info->transparent_pixels=0;\n  cube_info->transparent_index=(-1);\n  (void) DefineImageColormap(image,cube_info,cube_info->root);\n  /*\n    Create a reduced color image.\n  */\n  if (cube_info->quantize_info->dither_method != NoDitherMethod)\n    (void) DitherImage(image,cube_info,exception);\n  else\n    {\n      CacheView\n        *image_view;\n\n      MagickBooleanType\n        status;\n\n      status=MagickTrue;\n      image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n      #pragma omp parallel for schedule(static,4) shared(status) \\\n        magick_threads(image,image,image->rows,1)\n#endif\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        CubeInfo\n          cube;\n\n        register Quantum\n          *magick_restrict q;\n\n        register ssize_t\n          x;\n\n        ssize_t\n          count;\n\n        if (status == MagickFalse)\n          continue;\n        q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,\n          exception);\n        if (q == (Quantum *) NULL)\n          {\n            status=MagickFalse;\n            continue;\n          }\n        cube=(*cube_info);\n        for (x=0; x < (ssize_t) image->columns; x+=count)\n        {\n          DoublePixelPacket\n            pixel;\n\n          register const NodeInfo\n            *node_info;\n\n          register ssize_t\n            i;\n\n          size_t\n            id,\n            index;\n\n          /*\n            Identify the deepest node containing the pixel's color.\n          */\n          for (count=1; (x+count) < (ssize_t) image->columns; count++)\n          {\n            PixelInfo\n              packet;\n\n            GetPixelInfoPixel(image,q+count*GetPixelChannels(image),&packet);\n            if (IsPixelEquivalent(image,q,&packet) == MagickFalse)\n              break;\n          }\n          AssociateAlphaPixel(image,&cube,q,&pixel);\n          node_info=cube.root;\n          for (index=MaxTreeDepth-1; (ssize_t) index > 0; index--)\n          {\n            id=ColorToNodeId(&cube,&pixel,index);\n            if (node_info->child[id] == (NodeInfo *) NULL)\n              break;\n            node_info=node_info->child[id];\n          }\n          /*\n            Find closest color among siblings and their children.\n          */\n          cube.target=pixel;\n          cube.distance=(double) (4.0*(QuantumRange+1.0)*(QuantumRange+1.0)+\n            1.0);\n          ClosestColor(image,&cube,node_info->parent);\n          index=cube.color_number;\n          for (i=0; i < (ssize_t) count; i++)\n          {\n            if (image->storage_class == PseudoClass)\n              SetPixelIndex(image,(Quantum) index,q);\n            if (cube.quantize_info->measure_error == MagickFalse)\n              {\n                SetPixelRed(image,ClampToQuantum(\n                  image->colormap[index].red),q);\n                SetPixelGreen(image,ClampToQuantum(\n                  image->colormap[index].green),q);\n                SetPixelBlue(image,ClampToQuantum(\n                  image->colormap[index].blue),q);\n                if (cube.associate_alpha != MagickFalse)\n                  SetPixelAlpha(image,ClampToQuantum(\n                    image->colormap[index].alpha),q);\n              }\n            q+=GetPixelChannels(image);\n          }\n        }\n        if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n          status=MagickFalse;\n        if (image->progress_monitor != (MagickProgressMonitor) NULL)\n          {\n            MagickBooleanType\n              proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n            #pragma omp critical (MagickCore_AssignImageColors)\n#endif\n            proceed=SetImageProgress(image,AssignImageTag,(MagickOffsetType) y,\n              image->rows);\n            if (proceed == MagickFalse)\n              status=MagickFalse;\n          }\n      }\n      image_view=DestroyCacheView(image_view);\n    }\n  if (cube_info->quantize_info->measure_error != MagickFalse)\n    (void) GetImageQuantizeError(image,exception);\n  if ((cube_info->quantize_info->number_colors == 2) &&\n      (cube_info->quantize_info->colorspace == GRAYColorspace))\n    {\n      double\n        intensity;\n\n      /*\n        Monochrome image.\n      */\n      intensity=0.0;\n      if ((image->colors > 1) &&\n          (GetPixelInfoLuma(image->colormap+0) >\n           GetPixelInfoLuma(image->colormap+1)))\n        intensity=(double) QuantumRange;\n      image->colormap[0].red=intensity;\n      image->colormap[0].green=intensity;\n      image->colormap[0].blue=intensity;\n      if (image->colors > 1)\n        {\n          image->colormap[1].red=(double) QuantumRange-intensity;\n          image->colormap[1].green=(double) QuantumRange-intensity;\n          image->colormap[1].blue=(double) QuantumRange-intensity;\n        }\n    }\n  (void) SyncImage(image,exception);\n  if ((cube_info->quantize_info->colorspace != UndefinedColorspace) &&\n      (cube_info->quantize_info->colorspace != CMYKColorspace))\n    (void) TransformImageColorspace((Image *) image,sRGBColorspace,exception);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   C l a s s i f y I m a g e C o l o r s                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ClassifyImageColors() begins by initializing a color description tree\n%  of sufficient depth to represent each possible input color in a leaf.\n%  However, it is impractical to generate a fully-formed color\n%  description tree in the storage_class phase for realistic values of\n%  Cmax.  If colors components in the input image are quantized to k-bit\n%  precision, so that Cmax= 2k-1, the tree would need k levels below the\n%  root node to allow representing each possible input color in a leaf.\n%  This becomes prohibitive because the tree's total number of nodes is\n%  1 + sum(i=1,k,8k).\n%\n%  A complete tree would require 19,173,961 nodes for k = 8, Cmax = 255.\n%  Therefore, to avoid building a fully populated tree, QUANTIZE: (1)\n%  Initializes data structures for nodes only as they are needed;  (2)\n%  Chooses a maximum depth for the tree as a function of the desired\n%  number of colors in the output image (currently log2(colormap size)).\n%\n%  For each pixel in the input image, storage_class scans downward from\n%  the root of the color description tree.  At each level of the tree it\n%  identifies the single node which represents a cube in RGB space\n%  containing It updates the following data for each such node:\n%\n%    n1 : Number of pixels whose color is contained in the RGB cube\n%    which this node represents;\n%\n%    n2 : Number of pixels whose color is not represented in a node at\n%    lower depth in the tree;  initially,  n2 = 0 for all nodes except\n%    leaves of the tree.\n%\n%    Sr, Sg, Sb : Sums of the red, green, and blue component values for\n%    all pixels not classified at a lower depth. The combination of\n%    these sums and n2 will ultimately characterize the mean color of a\n%    set of pixels represented by this node.\n%\n%    E: the distance squared in RGB space between each pixel contained\n%    within a node and the nodes' center.  This represents the quantization\n%    error for a node.\n%\n%  The format of the ClassifyImageColors() method is:\n%\n%      MagickBooleanType ClassifyImageColors(CubeInfo *cube_info,\n%        const Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o cube_info: A pointer to the Cube structure.\n%\n%    o image: the image.\n%\n*/\n\nstatic inline void SetAssociatedAlpha(const Image *image,CubeInfo *cube_info)\n{\n  MagickBooleanType\n    associate_alpha;\n\n  associate_alpha=image->alpha_trait == BlendPixelTrait ? MagickTrue :\n    MagickFalse;\n  if ((cube_info->quantize_info->number_colors == 2) &&\n      (cube_info->quantize_info->colorspace == GRAYColorspace))\n    associate_alpha=MagickFalse;\n  cube_info->associate_alpha=associate_alpha;\n}\n\nstatic MagickBooleanType ClassifyImageColors(CubeInfo *cube_info,\n  const Image *image,ExceptionInfo *exception)\n{\n#define ClassifyImageTag  \"Classify/Image\"\n\n  CacheView\n    *image_view;\n\n  DoublePixelPacket\n    error,\n    mid,\n    midpoint,\n    pixel;\n\n  MagickBooleanType\n    proceed;\n\n  double\n    bisect;\n\n  NodeInfo\n    *node_info;\n\n  size_t\n    count,\n    id,\n    index,\n    level;\n\n  ssize_t\n    y;\n\n  /*\n    Classify the first cube_info->maximum_colors colors to a tree depth of 8.\n  */\n  SetAssociatedAlpha(image,cube_info);\n  if ((cube_info->quantize_info->colorspace != UndefinedColorspace) &&\n      (cube_info->quantize_info->colorspace != CMYKColorspace))\n    (void) TransformImageColorspace((Image *) image,\n      cube_info->quantize_info->colorspace,exception);\n  else\n    if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n      (void) TransformImageColorspace((Image *) image,sRGBColorspace,exception);\n  midpoint.red=(double) QuantumRange/2.0;\n  midpoint.green=(double) QuantumRange/2.0;\n  midpoint.blue=(double) QuantumRange/2.0;\n  midpoint.alpha=(double) QuantumRange/2.0;\n  error.alpha=0.0;\n  image_view=AcquireVirtualCacheView(image,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const Quantum\n      *magick_restrict p;\n\n    register ssize_t\n      x;\n\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    if (cube_info->nodes > MaxNodes)\n      {\n        /*\n          Prune one level if the color tree is too large.\n        */\n        PruneLevel(cube_info,cube_info->root);\n        cube_info->depth--;\n      }\n    for (x=0; x < (ssize_t) image->columns; x+=(ssize_t) count)\n    {\n      /*\n        Start at the root and descend the color cube tree.\n      */\n      for (count=1; (x+(ssize_t) count) < (ssize_t) image->columns; count++)\n      {\n        PixelInfo\n          packet;\n\n        GetPixelInfoPixel(image,p+count*GetPixelChannels(image),&packet);\n        if (IsPixelEquivalent(image,p,&packet) == MagickFalse)\n          break;\n      }\n      AssociateAlphaPixel(image,cube_info,p,&pixel);\n      index=MaxTreeDepth-1;\n      bisect=((double) QuantumRange+1.0)/2.0;\n      mid=midpoint;\n      node_info=cube_info->root;\n      for (level=1; level <= MaxTreeDepth; level++)\n      {\n        double\n          distance;\n\n        bisect*=0.5;\n        id=ColorToNodeId(cube_info,&pixel,index);\n        mid.red+=(id & 1) != 0 ? bisect : -bisect;\n        mid.green+=(id & 2) != 0 ? bisect : -bisect;\n        mid.blue+=(id & 4) != 0 ? bisect : -bisect;\n        mid.alpha+=(id & 8) != 0 ? bisect : -bisect;\n        if (node_info->child[id] == (NodeInfo *) NULL)\n          {\n            /*\n              Set colors of new node to contain pixel.\n            */\n            node_info->child[id]=GetNodeInfo(cube_info,id,level,node_info);\n            if (node_info->child[id] == (NodeInfo *) NULL)\n              {\n                (void) ThrowMagickException(exception,GetMagickModule(),\n                  ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\n                  image->filename);\n                continue;\n              }\n            if (level == MaxTreeDepth)\n              cube_info->colors++;\n          }\n        /*\n          Approximate the quantization error represented by this node.\n        */\n        node_info=node_info->child[id];\n        error.red=QuantumScale*(pixel.red-mid.red);\n        error.green=QuantumScale*(pixel.green-mid.green);\n        error.blue=QuantumScale*(pixel.blue-mid.blue);\n        if (cube_info->associate_alpha != MagickFalse)\n          error.alpha=QuantumScale*(pixel.alpha-mid.alpha);\n        distance=(double) (error.red*error.red+error.green*error.green+\n          error.blue*error.blue+error.alpha*error.alpha);\n        if (IsNaN(distance))\n          distance=0.0;\n        node_info->quantize_error+=count*sqrt(distance);\n        cube_info->root->quantize_error+=node_info->quantize_error;\n        index--;\n      }\n      /*\n        Sum RGB for this leaf for later derivation of the mean cube color.\n      */\n      node_info->number_unique+=count;\n      node_info->total_color.red+=count*QuantumScale*ClampPixel(pixel.red);\n      node_info->total_color.green+=count*QuantumScale*ClampPixel(pixel.green);\n      node_info->total_color.blue+=count*QuantumScale*ClampPixel(pixel.blue);\n      if (cube_info->associate_alpha != MagickFalse)\n        node_info->total_color.alpha+=count*QuantumScale*\n          ClampPixel(pixel.alpha);\n      else\n        node_info->total_color.alpha+=count*QuantumScale*\n          ClampPixel(OpaqueAlpha);\n      p+=count*GetPixelChannels(image);\n    }\n    if (cube_info->colors > cube_info->maximum_colors)\n      {\n        PruneToCubeDepth(cube_info,cube_info->root);\n        break;\n      }\n    proceed=SetImageProgress(image,ClassifyImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (proceed == MagickFalse)\n      break;\n  }\n  for (y++; y < (ssize_t) image->rows; y++)\n  {\n    register const Quantum\n      *magick_restrict p;\n\n    register ssize_t\n      x;\n\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    if (cube_info->nodes > MaxNodes)\n      {\n        /*\n          Prune one level if the color tree is too large.\n        */\n        PruneLevel(cube_info,cube_info->root);\n        cube_info->depth--;\n      }\n    for (x=0; x < (ssize_t) image->columns; x+=(ssize_t) count)\n    {\n      /*\n        Start at the root and descend the color cube tree.\n      */\n      for (count=1; (x+(ssize_t) count) < (ssize_t) image->columns; count++)\n      {\n        PixelInfo\n          packet;\n\n        GetPixelInfoPixel(image,p+count*GetPixelChannels(image),&packet);\n        if (IsPixelEquivalent(image,p,&packet) == MagickFalse)\n          break;\n      }\n      AssociateAlphaPixel(image,cube_info,p,&pixel);\n      index=MaxTreeDepth-1;\n      bisect=((double) QuantumRange+1.0)/2.0;\n      mid=midpoint;\n      node_info=cube_info->root;\n      for (level=1; level <= cube_info->depth; level++)\n      {\n        double\n          distance;\n\n        bisect*=0.5;\n        id=ColorToNodeId(cube_info,&pixel,index);\n        mid.red+=(id & 1) != 0 ? bisect : -bisect;\n        mid.green+=(id & 2) != 0 ? bisect : -bisect;\n        mid.blue+=(id & 4) != 0 ? bisect : -bisect;\n        mid.alpha+=(id & 8) != 0 ? bisect : -bisect;\n        if (node_info->child[id] == (NodeInfo *) NULL)\n          {\n            /*\n              Set colors of new node to contain pixel.\n            */\n            node_info->child[id]=GetNodeInfo(cube_info,id,level,node_info);\n            if (node_info->child[id] == (NodeInfo *) NULL)\n              {\n                (void) ThrowMagickException(exception,GetMagickModule(),\n                  ResourceLimitError,\"MemoryAllocationFailed\",\"%s\",\n                  image->filename);\n                continue;\n              }\n            if (level == cube_info->depth)\n              cube_info->colors++;\n          }\n        /*\n          Approximate the quantization error represented by this node.\n        */\n        node_info=node_info->child[id];\n        error.red=QuantumScale*(pixel.red-mid.red);\n        error.green=QuantumScale*(pixel.green-mid.green);\n        error.blue=QuantumScale*(pixel.blue-mid.blue);\n        if (cube_info->associate_alpha != MagickFalse)\n          error.alpha=QuantumScale*(pixel.alpha-mid.alpha);\n        distance=(double) (error.red*error.red+error.green*error.green+\n          error.blue*error.blue+error.alpha*error.alpha);\n        if (IsNaN(distance) != MagickFalse)\n          distance=0.0;\n        node_info->quantize_error+=count*sqrt(distance);\n        cube_info->root->quantize_error+=node_info->quantize_error;\n        index--;\n      }\n      /*\n        Sum RGB for this leaf for later derivation of the mean cube color.\n      */\n      node_info->number_unique+=count;\n      node_info->total_color.red+=count*QuantumScale*ClampPixel(pixel.red);\n      node_info->total_color.green+=count*QuantumScale*ClampPixel(pixel.green);\n      node_info->total_color.blue+=count*QuantumScale*ClampPixel(pixel.blue);\n      if (cube_info->associate_alpha != MagickFalse)\n        node_info->total_color.alpha+=count*QuantumScale*\n          ClampPixel(pixel.alpha);\n      else\n        node_info->total_color.alpha+=count*QuantumScale*\n          ClampPixel(OpaqueAlpha);\n      p+=count*GetPixelChannels(image);\n    }\n    proceed=SetImageProgress(image,ClassifyImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (proceed == MagickFalse)\n      break;\n  }\n  image_view=DestroyCacheView(image_view);\n  if ((cube_info->quantize_info->colorspace != UndefinedColorspace) &&\n      (cube_info->quantize_info->colorspace != CMYKColorspace))\n    (void) TransformImageColorspace((Image *) image,sRGBColorspace,exception);\n  return(y < (ssize_t) image->rows ? MagickFalse : MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C l o n e Q u a n t i z e I n f o                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CloneQuantizeInfo() makes a duplicate of the given quantize info structure,\n%  or if quantize info is NULL, a new one.\n%\n%  The format of the CloneQuantizeInfo method is:\n%\n%      QuantizeInfo *CloneQuantizeInfo(const QuantizeInfo *quantize_info)\n%\n%  A description of each parameter follows:\n%\n%    o clone_info: Method CloneQuantizeInfo returns a duplicate of the given\n%      quantize info, or if image info is NULL a new one.\n%\n%    o quantize_info: a structure of type info.\n%\n*/\nMagickExport QuantizeInfo *CloneQuantizeInfo(const QuantizeInfo *quantize_info)\n{\n  QuantizeInfo\n    *clone_info;\n\n  clone_info=(QuantizeInfo *) AcquireMagickMemory(sizeof(*clone_info));\n  if (clone_info == (QuantizeInfo *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  GetQuantizeInfo(clone_info);\n  if (quantize_info == (QuantizeInfo *) NULL)\n    return(clone_info);\n  clone_info->number_colors=quantize_info->number_colors;\n  clone_info->tree_depth=quantize_info->tree_depth;\n  clone_info->dither_method=quantize_info->dither_method;\n  clone_info->colorspace=quantize_info->colorspace;\n  clone_info->measure_error=quantize_info->measure_error;\n  return(clone_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   C l o s e s t C o l o r                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ClosestColor() traverses the color cube tree at a particular node and\n%  determines which colormap entry best represents the input color.\n%\n%  The format of the ClosestColor method is:\n%\n%      void ClosestColor(const Image *image,CubeInfo *cube_info,\n%        const NodeInfo *node_info)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n%    o cube_info: A pointer to the Cube structure.\n%\n%    o node_info: the address of a structure of type NodeInfo which points to a\n%      node in the color cube tree that is to be pruned.\n%\n*/\nstatic void ClosestColor(const Image *image,CubeInfo *cube_info,\n  const NodeInfo *node_info)\n{\n  register ssize_t\n    i;\n\n  size_t\n    number_children;\n\n  /*\n    Traverse any children.\n  */\n  number_children=cube_info->associate_alpha == MagickFalse ? 8UL : 16UL;\n  for (i=0; i < (ssize_t) number_children; i++)\n    if (node_info->child[i] != (NodeInfo *) NULL)\n      ClosestColor(image,cube_info,node_info->child[i]);\n  if (node_info->number_unique != 0)\n    {\n      double\n        pixel;\n\n      register double\n        alpha,\n        beta,\n        distance;\n\n      register DoublePixelPacket\n        *magick_restrict q;\n\n      register PixelInfo\n        *magick_restrict p;\n\n      /*\n        Determine if this color is \"closest\".\n      */\n      p=image->colormap+node_info->color_number;\n      q=(&cube_info->target);\n      alpha=1.0;\n      beta=1.0;\n      if (cube_info->associate_alpha != MagickFalse)\n        {\n          alpha=(double) (QuantumScale*p->alpha);\n          beta=(double) (QuantumScale*q->alpha);\n        }\n      pixel=alpha*p->red-beta*q->red;\n      distance=pixel*pixel;\n      if (distance <= cube_info->distance)\n        {\n          pixel=alpha*p->green-beta*q->green;\n          distance+=pixel*pixel;\n          if (distance <= cube_info->distance)\n            {\n              pixel=alpha*p->blue-beta*q->blue;\n              distance+=pixel*pixel;\n              if (distance <= cube_info->distance)\n                {\n                  if (cube_info->associate_alpha != MagickFalse)\n                    {\n                      pixel=p->alpha-q->alpha;\n                      distance+=pixel*pixel;\n                    }\n                  if (distance <= cube_info->distance)\n                    {\n                      cube_info->distance=distance;\n                      cube_info->color_number=node_info->color_number;\n                    }\n                }\n            }\n        }\n    }\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C o m p r e s s I m a g e C o l o r m a p                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CompressImageColormap() compresses an image colormap by removing any\n%  duplicate or unused color entries.\n%\n%  The format of the CompressImageColormap method is:\n%\n%      MagickBooleanType CompressImageColormap(Image *image,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType CompressImageColormap(Image *image,\n  ExceptionInfo *exception)\n{\n  QuantizeInfo\n    quantize_info;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->storage_class != PseudoClass)\n    return(MagickFalse);\n  GetQuantizeInfo(&quantize_info);\n  quantize_info.number_colors=image->colors;\n  quantize_info.tree_depth=MaxTreeDepth;\n  return(QuantizeImage(&quantize_info,image,exception));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   D e f i n e I m a g e C o l o r m a p                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DefineImageColormap() traverses the color cube tree and notes each colormap\n%  entry.  A colormap entry is any node in the color cube tree where the\n%  of unique colors is not zero.  DefineImageColormap() returns the number of\n%  colors in the image colormap.\n%\n%  The format of the DefineImageColormap method is:\n%\n%      size_t DefineImageColormap(Image *image,CubeInfo *cube_info,\n%        NodeInfo *node_info)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n%    o cube_info: A pointer to the Cube structure.\n%\n%    o node_info: the address of a structure of type NodeInfo which points to a\n%      node in the color cube tree that is to be pruned.\n%\n*/\nstatic size_t DefineImageColormap(Image *image,CubeInfo *cube_info,\n  NodeInfo *node_info)\n{\n  register ssize_t\n    i;\n\n  size_t\n    number_children;\n\n  /*\n    Traverse any children.\n  */\n  number_children=cube_info->associate_alpha == MagickFalse ? 8UL : 16UL;\n  for (i=0; i < (ssize_t) number_children; i++)\n    if (node_info->child[i] != (NodeInfo *) NULL)\n      (void) DefineImageColormap(image,cube_info,node_info->child[i]);\n  if (node_info->number_unique != 0)\n    {\n      register double\n        alpha;\n\n      register PixelInfo\n        *magick_restrict q;\n\n      /*\n        Colormap entry is defined by the mean color in this cube.\n      */\n      q=image->colormap+image->colors;\n      alpha=(double) ((MagickOffsetType) node_info->number_unique);\n      alpha=PerceptibleReciprocal(alpha);\n      if (cube_info->associate_alpha == MagickFalse)\n        {\n          q->red=(double) ClampToQuantum(alpha*QuantumRange*\n            node_info->total_color.red);\n          q->green=(double) ClampToQuantum(alpha*QuantumRange*\n            node_info->total_color.green);\n          q->blue=(double) ClampToQuantum(alpha*QuantumRange*\n            node_info->total_color.blue);\n          q->alpha=(double) OpaqueAlpha;\n        }\n      else\n        {\n          double\n            opacity;\n\n          opacity=(double) (alpha*QuantumRange*node_info->total_color.alpha);\n          q->alpha=(double) ClampToQuantum(opacity);\n          if (q->alpha == OpaqueAlpha)\n            {\n              q->red=(double) ClampToQuantum(alpha*QuantumRange*\n                node_info->total_color.red);\n              q->green=(double) ClampToQuantum(alpha*QuantumRange*\n                node_info->total_color.green);\n              q->blue=(double) ClampToQuantum(alpha*QuantumRange*\n                node_info->total_color.blue);\n            }\n          else\n            {\n              double\n                gamma;\n\n              gamma=(double) (QuantumScale*q->alpha);\n              gamma=PerceptibleReciprocal(gamma);\n              q->red=(double) ClampToQuantum(alpha*gamma*QuantumRange*\n                node_info->total_color.red);\n              q->green=(double) ClampToQuantum(alpha*gamma*QuantumRange*\n                node_info->total_color.green);\n              q->blue=(double) ClampToQuantum(alpha*gamma*QuantumRange*\n                node_info->total_color.blue);\n              if (node_info->number_unique > cube_info->transparent_pixels)\n                {\n                  cube_info->transparent_pixels=node_info->number_unique;\n                  cube_info->transparent_index=(ssize_t) image->colors;\n                }\n            }\n        }\n      node_info->color_number=image->colors++;\n    }\n  return(image->colors);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   D e s t r o y C u b e I n f o                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyCubeInfo() deallocates memory associated with an image.\n%\n%  The format of the DestroyCubeInfo method is:\n%\n%      DestroyCubeInfo(CubeInfo *cube_info)\n%\n%  A description of each parameter follows:\n%\n%    o cube_info: the address of a structure of type CubeInfo.\n%\n*/\nstatic void DestroyCubeInfo(CubeInfo *cube_info)\n{\n  register Nodes\n    *nodes;\n\n  /*\n    Release color cube tree storage.\n  */\n  do\n  {\n    nodes=cube_info->node_queue->next;\n    cube_info->node_queue->nodes=(NodeInfo *) RelinquishMagickMemory(\n      cube_info->node_queue->nodes);\n    cube_info->node_queue=(Nodes *) RelinquishMagickMemory(\n      cube_info->node_queue);\n    cube_info->node_queue=nodes;\n  } while (cube_info->node_queue != (Nodes *) NULL);\n  if (cube_info->memory_info != (MemoryInfo *) NULL)\n    cube_info->memory_info=RelinquishVirtualMemory(cube_info->memory_info);\n  cube_info->quantize_info=DestroyQuantizeInfo(cube_info->quantize_info);\n  cube_info=(CubeInfo *) RelinquishMagickMemory(cube_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e s t r o y Q u a n t i z e I n f o                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyQuantizeInfo() deallocates memory associated with an QuantizeInfo\n%  structure.\n%\n%  The format of the DestroyQuantizeInfo method is:\n%\n%      QuantizeInfo *DestroyQuantizeInfo(QuantizeInfo *quantize_info)\n%\n%  A description of each parameter follows:\n%\n%    o quantize_info: Specifies a pointer to an QuantizeInfo structure.\n%\n*/\nMagickExport QuantizeInfo *DestroyQuantizeInfo(QuantizeInfo *quantize_info)\n{\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(quantize_info != (QuantizeInfo *) NULL);\n  assert(quantize_info->signature == MagickCoreSignature);\n  quantize_info->signature=(~MagickCoreSignature);\n  quantize_info=(QuantizeInfo *) RelinquishMagickMemory(quantize_info);\n  return(quantize_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   D i t h e r I m a g e                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DitherImage() distributes the difference between an original image and\n%  the corresponding color reduced algorithm to neighboring pixels using\n%  serpentine-scan Floyd-Steinberg error diffusion. DitherImage returns\n%  MagickTrue if the image is dithered otherwise MagickFalse.\n%\n%  The format of the DitherImage method is:\n%\n%      MagickBooleanType DitherImage(Image *image,CubeInfo *cube_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n%    o cube_info: A pointer to the Cube structure.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic DoublePixelPacket **DestroyPixelThreadSet(DoublePixelPacket **pixels)\n{\n  register ssize_t\n    i;\n\n  assert(pixels != (DoublePixelPacket **) NULL);\n  for (i=0; i < (ssize_t) GetMagickResourceLimit(ThreadResource); i++)\n    if (pixels[i] != (DoublePixelPacket *) NULL)\n      pixels[i]=(DoublePixelPacket *) RelinquishMagickMemory(pixels[i]);\n  pixels=(DoublePixelPacket **) RelinquishMagickMemory(pixels);\n  return(pixels);\n}\n\nstatic DoublePixelPacket **AcquirePixelThreadSet(const size_t count)\n{\n  DoublePixelPacket\n    **pixels;\n\n  register ssize_t\n    i;\n\n  size_t\n    number_threads;\n\n  number_threads=(size_t) GetMagickResourceLimit(ThreadResource);\n  pixels=(DoublePixelPacket **) AcquireQuantumMemory(number_threads,\n    sizeof(*pixels));\n  if (pixels == (DoublePixelPacket **) NULL)\n    return((DoublePixelPacket **) NULL);\n  (void) ResetMagickMemory(pixels,0,number_threads*sizeof(*pixels));\n  for (i=0; i < (ssize_t) number_threads; i++)\n  {\n    pixels[i]=(DoublePixelPacket *) AcquireQuantumMemory(count,2*\n      sizeof(**pixels));\n    if (pixels[i] == (DoublePixelPacket *) NULL)\n      return(DestroyPixelThreadSet(pixels));\n  }\n  return(pixels);\n}\n\nstatic inline ssize_t CacheOffset(CubeInfo *cube_info,\n  const DoublePixelPacket *pixel)\n{\n#define RedShift(pixel) (((pixel) >> CacheShift) << (0*(8-CacheShift)))\n#define GreenShift(pixel) (((pixel) >> CacheShift) << (1*(8-CacheShift)))\n#define BlueShift(pixel) (((pixel) >> CacheShift) << (2*(8-CacheShift)))\n#define AlphaShift(pixel) (((pixel) >> CacheShift) << (3*(8-CacheShift)))\n\n  ssize_t\n    offset;\n\n  offset=(ssize_t) (RedShift(ScaleQuantumToChar(ClampPixel(pixel->red))) |\n    GreenShift(ScaleQuantumToChar(ClampPixel(pixel->green))) |\n    BlueShift(ScaleQuantumToChar(ClampPixel(pixel->blue))));\n  if (cube_info->associate_alpha != MagickFalse)\n    offset|=AlphaShift(ScaleQuantumToChar(ClampPixel(pixel->alpha)));\n  return(offset);\n}\n\nstatic MagickBooleanType FloydSteinbergDither(Image *image,CubeInfo *cube_info,\n  ExceptionInfo *exception)\n{\n#define DitherImageTag  \"Dither/Image\"\n\n  CacheView\n    *image_view;\n\n  DoublePixelPacket\n    **pixels;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  /*\n    Distribute quantization error using Floyd-Steinberg.\n  */\n  pixels=AcquirePixelThreadSet(image->columns);\n  if (pixels == (DoublePixelPacket **) NULL)\n    return(MagickFalse);\n  status=MagickTrue;\n  image_view=AcquireAuthenticCacheView(image,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    const int\n      id = GetOpenMPThreadId();\n\n    CubeInfo\n      cube;\n\n    DoublePixelPacket\n      *current,\n      *previous;\n\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    size_t\n      index;\n\n    ssize_t\n      v;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    cube=(*cube_info);\n    current=pixels[id]+(y & 0x01)*image->columns;\n    previous=pixels[id]+((y+1) & 0x01)*image->columns;\n    v=(ssize_t) ((y & 0x01) != 0 ? -1 : 1);\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      DoublePixelPacket\n        color,\n        pixel;\n\n      register ssize_t\n        i;\n\n      ssize_t\n        u;\n\n      u=(y & 0x01) != 0 ? (ssize_t) image->columns-1-x : x;\n      AssociateAlphaPixel(image,&cube,q+u*GetPixelChannels(image),&pixel);\n      if (x > 0)\n        {\n          pixel.red+=7*current[u-v].red/16;\n          pixel.green+=7*current[u-v].green/16;\n          pixel.blue+=7*current[u-v].blue/16;\n          if (cube.associate_alpha != MagickFalse)\n            pixel.alpha+=7*current[u-v].alpha/16;\n        }\n      if (y > 0)\n        {\n          if (x < (ssize_t) (image->columns-1))\n            {\n              pixel.red+=previous[u+v].red/16;\n              pixel.green+=previous[u+v].green/16;\n              pixel.blue+=previous[u+v].blue/16;\n              if (cube.associate_alpha != MagickFalse)\n                pixel.alpha+=previous[u+v].alpha/16;\n            }\n          pixel.red+=5*previous[u].red/16;\n          pixel.green+=5*previous[u].green/16;\n          pixel.blue+=5*previous[u].blue/16;\n          if (cube.associate_alpha != MagickFalse)\n            pixel.alpha+=5*previous[u].alpha/16;\n          if (x > 0)\n            {\n              pixel.red+=3*previous[u-v].red/16;\n              pixel.green+=3*previous[u-v].green/16;\n              pixel.blue+=3*previous[u-v].blue/16;\n              if (cube.associate_alpha != MagickFalse)\n                pixel.alpha+=3*previous[u-v].alpha/16;\n            }\n        }\n      pixel.red=(double) ClampPixel(pixel.red);\n      pixel.green=(double) ClampPixel(pixel.green);\n      pixel.blue=(double) ClampPixel(pixel.blue);\n      if (cube.associate_alpha != MagickFalse)\n        pixel.alpha=(double) ClampPixel(pixel.alpha);\n      i=CacheOffset(&cube,&pixel);\n      if (cube.cache[i] < 0)\n        {\n          register NodeInfo\n            *node_info;\n\n          register size_t\n            node_id;\n\n          /*\n            Identify the deepest node containing the pixel's color.\n          */\n          node_info=cube.root;\n          for (index=MaxTreeDepth-1; (ssize_t) index > 0; index--)\n          {\n            node_id=ColorToNodeId(&cube,&pixel,index);\n            if (node_info->child[node_id] == (NodeInfo *) NULL)\n              break;\n            node_info=node_info->child[node_id];\n          }\n          /*\n            Find closest color among siblings and their children.\n          */\n          cube.target=pixel;\n          cube.distance=(double) (4.0*(QuantumRange+1.0)*(QuantumRange+1.0)+\n            1.0);\n          ClosestColor(image,&cube,node_info->parent);\n          cube.cache[i]=(ssize_t) cube.color_number;\n        }\n      /*\n        Assign pixel to closest colormap entry.\n      */\n      index=(size_t) cube.cache[i];\n      if (image->storage_class == PseudoClass)\n        SetPixelIndex(image,(Quantum) index,q+u*GetPixelChannels(image));\n      if (cube.quantize_info->measure_error == MagickFalse)\n        {\n          SetPixelRed(image,ClampToQuantum(image->colormap[index].red),\n            q+u*GetPixelChannels(image));\n          SetPixelGreen(image,ClampToQuantum(image->colormap[index].green),\n            q+u*GetPixelChannels(image));\n          SetPixelBlue(image,ClampToQuantum(image->colormap[index].blue),\n            q+u*GetPixelChannels(image));\n          if (cube.associate_alpha != MagickFalse)\n            SetPixelAlpha(image,ClampToQuantum(image->colormap[index].alpha),\n              q+u*GetPixelChannels(image));\n        }\n      if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n        status=MagickFalse;\n      /*\n        Store the error.\n      */\n      AssociateAlphaPixelInfo(&cube,image->colormap+index,&color);\n      current[u].red=pixel.red-color.red;\n      current[u].green=pixel.green-color.green;\n      current[u].blue=pixel.blue-color.blue;\n      if (cube.associate_alpha != MagickFalse)\n        current[u].alpha=pixel.alpha-color.alpha;\n      if (image->progress_monitor != (MagickProgressMonitor) NULL)\n        {\n          MagickBooleanType\n            proceed;\n\n          proceed=SetImageProgress(image,DitherImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (proceed == MagickFalse)\n            status=MagickFalse;\n        }\n    }\n  }\n  image_view=DestroyCacheView(image_view);\n  pixels=DestroyPixelThreadSet(pixels);\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType\n  RiemersmaDither(Image *,CacheView *,CubeInfo *,const unsigned int,\n    ExceptionInfo *);\n\nstatic void Riemersma(Image *image,CacheView *image_view,CubeInfo *cube_info,\n  const size_t level,const unsigned int direction,ExceptionInfo *exception)\n{\n  if (level == 1)\n    switch (direction)\n    {\n      case WestGravity:\n      {\n        (void) RiemersmaDither(image,image_view,cube_info,EastGravity,\n          exception);\n        (void) RiemersmaDither(image,image_view,cube_info,SouthGravity,\n          exception);\n        (void) RiemersmaDither(image,image_view,cube_info,WestGravity,\n          exception);\n        break;\n      }\n      case EastGravity:\n      {\n        (void) RiemersmaDither(image,image_view,cube_info,WestGravity,\n          exception);\n        (void) RiemersmaDither(image,image_view,cube_info,NorthGravity,\n          exception);\n        (void) RiemersmaDither(image,image_view,cube_info,EastGravity,\n          exception);\n        break;\n      }\n      case NorthGravity:\n      {\n        (void) RiemersmaDither(image,image_view,cube_info,SouthGravity,\n          exception);\n        (void) RiemersmaDither(image,image_view,cube_info,EastGravity,\n          exception);\n        (void) RiemersmaDither(image,image_view,cube_info,NorthGravity,\n          exception);\n        break;\n      }\n      case SouthGravity:\n      {\n        (void) RiemersmaDither(image,image_view,cube_info,NorthGravity,\n          exception);\n        (void) RiemersmaDither(image,image_view,cube_info,WestGravity,\n          exception);\n        (void) RiemersmaDither(image,image_view,cube_info,SouthGravity,\n          exception);\n        break;\n      }\n      default:\n        break;\n    }\n  else\n    switch (direction)\n    {\n      case WestGravity:\n      {\n        Riemersma(image,image_view,cube_info,level-1,NorthGravity,\n          exception);\n        (void) RiemersmaDither(image,image_view,cube_info,EastGravity,\n          exception);\n        Riemersma(image,image_view,cube_info,level-1,WestGravity,\n          exception);\n        (void) RiemersmaDither(image,image_view,cube_info,SouthGravity,\n          exception);\n        Riemersma(image,image_view,cube_info,level-1,WestGravity,\n          exception);\n        (void) RiemersmaDither(image,image_view,cube_info,WestGravity,\n          exception);\n        Riemersma(image,image_view,cube_info,level-1,SouthGravity,\n          exception);\n        break;\n      }\n      case EastGravity:\n      {\n        Riemersma(image,image_view,cube_info,level-1,SouthGravity,\n          exception);\n        (void) RiemersmaDither(image,image_view,cube_info,WestGravity,\n          exception);\n        Riemersma(image,image_view,cube_info,level-1,EastGravity,\n          exception);\n        (void) RiemersmaDither(image,image_view,cube_info,NorthGravity,\n          exception);\n        Riemersma(image,image_view,cube_info,level-1,EastGravity,\n          exception);\n        (void) RiemersmaDither(image,image_view,cube_info,EastGravity,\n          exception);\n        Riemersma(image,image_view,cube_info,level-1,NorthGravity,\n          exception);\n        break;\n      }\n      case NorthGravity:\n      {\n        Riemersma(image,image_view,cube_info,level-1,WestGravity,\n          exception);\n        (void) RiemersmaDither(image,image_view,cube_info,SouthGravity,\n          exception);\n        Riemersma(image,image_view,cube_info,level-1,NorthGravity,\n          exception);\n        (void) RiemersmaDither(image,image_view,cube_info,EastGravity,\n          exception);\n        Riemersma(image,image_view,cube_info,level-1,NorthGravity,\n          exception);\n        (void) RiemersmaDither(image,image_view,cube_info,NorthGravity,\n          exception);\n        Riemersma(image,image_view,cube_info,level-1,EastGravity,\n          exception);\n        break;\n      }\n      case SouthGravity:\n      {\n        Riemersma(image,image_view,cube_info,level-1,EastGravity,\n          exception);\n        (void) RiemersmaDither(image,image_view,cube_info,NorthGravity,\n          exception);\n        Riemersma(image,image_view,cube_info,level-1,SouthGravity,\n          exception);\n        (void) RiemersmaDither(image,image_view,cube_info,WestGravity,\n          exception);\n        Riemersma(image,image_view,cube_info,level-1,SouthGravity,\n          exception);\n        (void) RiemersmaDither(image,image_view,cube_info,SouthGravity,\n          exception);\n        Riemersma(image,image_view,cube_info,level-1,WestGravity,\n          exception);\n        break;\n      }\n      default:\n        break;\n    }\n}\n\nstatic MagickBooleanType RiemersmaDither(Image *image,CacheView *image_view,\n  CubeInfo *cube_info,const unsigned int direction,ExceptionInfo *exception)\n{\n#define DitherImageTag  \"Dither/Image\"\n\n  DoublePixelPacket\n    color,\n    pixel;\n\n  MagickBooleanType\n    proceed;\n\n  register CubeInfo\n    *p;\n\n  size_t\n    index;\n\n  p=cube_info;\n  if ((p->x >= 0) && (p->x < (ssize_t) image->columns) &&\n      (p->y >= 0) && (p->y < (ssize_t) image->rows))\n    {\n      register Quantum\n        *magick_restrict q;\n\n      register ssize_t\n        i;\n\n      /*\n        Distribute error.\n      */\n      q=GetCacheViewAuthenticPixels(image_view,p->x,p->y,1,1,exception);\n      if (q == (Quantum *) NULL)\n        return(MagickFalse);\n      AssociateAlphaPixel(image,cube_info,q,&pixel);\n      for (i=0; i < ErrorQueueLength; i++)\n      {\n        pixel.red+=p->weights[i]*p->error[i].red;\n        pixel.green+=p->weights[i]*p->error[i].green;\n        pixel.blue+=p->weights[i]*p->error[i].blue;\n        if (cube_info->associate_alpha != MagickFalse)\n          pixel.alpha+=p->weights[i]*p->error[i].alpha;\n      }\n      pixel.red=(double) ClampPixel(pixel.red);\n      pixel.green=(double) ClampPixel(pixel.green);\n      pixel.blue=(double) ClampPixel(pixel.blue);\n      if (cube_info->associate_alpha != MagickFalse)\n        pixel.alpha=(double) ClampPixel(pixel.alpha);\n      i=CacheOffset(cube_info,&pixel);\n      if (p->cache[i] < 0)\n        {\n          register NodeInfo\n            *node_info;\n\n          register size_t\n            id;\n\n          /*\n            Identify the deepest node containing the pixel's color.\n          */\n          node_info=p->root;\n          for (index=MaxTreeDepth-1; (ssize_t) index > 0; index--)\n          {\n            id=ColorToNodeId(cube_info,&pixel,index);\n            if (node_info->child[id] == (NodeInfo *) NULL)\n              break;\n            node_info=node_info->child[id];\n          }\n          /*\n            Find closest color among siblings and their children.\n          */\n          p->target=pixel;\n          p->distance=(double) (4.0*(QuantumRange+1.0)*((double)\n            QuantumRange+1.0)+1.0);\n          ClosestColor(image,p,node_info->parent);\n          p->cache[i]=(ssize_t) p->color_number;\n        }\n      /*\n        Assign pixel to closest colormap entry.\n      */\n      index=(size_t) p->cache[i];\n      if (image->storage_class == PseudoClass)\n        SetPixelIndex(image,(Quantum) index,q);\n      if (cube_info->quantize_info->measure_error == MagickFalse)\n        {\n          SetPixelRed(image,ClampToQuantum(image->colormap[index].red),q);\n          SetPixelGreen(image,ClampToQuantum(image->colormap[index].green),q);\n          SetPixelBlue(image,ClampToQuantum(image->colormap[index].blue),q);\n          if (cube_info->associate_alpha != MagickFalse)\n            SetPixelAlpha(image,ClampToQuantum(image->colormap[index].alpha),q);\n        }\n      if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n        return(MagickFalse);\n      /*\n        Propagate the error as the last entry of the error queue.\n      */\n      (void) CopyMagickMemory(p->error,p->error+1,(ErrorQueueLength-1)*\n        sizeof(p->error[0]));\n      AssociateAlphaPixelInfo(cube_info,image->colormap+index,&color);\n      p->error[ErrorQueueLength-1].red=pixel.red-color.red;\n      p->error[ErrorQueueLength-1].green=pixel.green-color.green;\n      p->error[ErrorQueueLength-1].blue=pixel.blue-color.blue;\n      if (cube_info->associate_alpha != MagickFalse)\n        p->error[ErrorQueueLength-1].alpha=pixel.alpha-color.alpha;\n      proceed=SetImageProgress(image,DitherImageTag,p->offset,p->span);\n      if (proceed == MagickFalse)\n        return(MagickFalse);\n      p->offset++;\n    }\n  switch (direction)\n  {\n    case WestGravity: p->x--; break;\n    case EastGravity: p->x++; break;\n    case NorthGravity: p->y--; break;\n    case SouthGravity: p->y++; break;\n  }\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType DitherImage(Image *image,CubeInfo *cube_info,\n  ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  size_t\n    depth;\n\n  if (cube_info->quantize_info->dither_method != RiemersmaDitherMethod)\n    return(FloydSteinbergDither(image,cube_info,exception));\n  /*\n    Distribute quantization error along a Hilbert curve.\n  */\n  (void) ResetMagickMemory(cube_info->error,0,ErrorQueueLength*\n    sizeof(*cube_info->error));\n  cube_info->x=0;\n  cube_info->y=0;\n  i=MagickMax((ssize_t) image->columns,(ssize_t) image->rows);\n  for (depth=1; i != 0; depth++)\n    i>>=1;\n  if ((ssize_t) (1L << depth) < MagickMax((ssize_t) image->columns,(ssize_t) image->rows))\n    depth++;\n  cube_info->offset=0;\n  cube_info->span=(MagickSizeType) image->columns*image->rows;\n  image_view=AcquireAuthenticCacheView(image,exception);\n  if (depth > 1)\n    Riemersma(image,image_view,cube_info,depth-1,NorthGravity,exception);\n  status=RiemersmaDither(image,image_view,cube_info,ForgetGravity,exception);\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t C u b e I n f o                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetCubeInfo() initialize the Cube data structure.\n%\n%  The format of the GetCubeInfo method is:\n%\n%      CubeInfo GetCubeInfo(const QuantizeInfo *quantize_info,\n%        const size_t depth,const size_t maximum_colors)\n%\n%  A description of each parameter follows.\n%\n%    o quantize_info: Specifies a pointer to an QuantizeInfo structure.\n%\n%    o depth: Normally, this integer value is zero or one.  A zero or\n%      one tells Quantize to choose a optimal tree depth of Log4(number_colors).\n%      A tree of this depth generally allows the best representation of the\n%      reference image with the least amount of memory and the fastest\n%      computational speed.  In some cases, such as an image with low color\n%      dispersion (a few number of colors), a value other than\n%      Log4(number_colors) is required.  To expand the color tree completely,\n%      use a value of 8.\n%\n%    o maximum_colors: maximum colors.\n%\n*/\nstatic CubeInfo *GetCubeInfo(const QuantizeInfo *quantize_info,\n  const size_t depth,const size_t maximum_colors)\n{\n  CubeInfo\n    *cube_info;\n\n  double\n    sum,\n    weight;\n\n  register ssize_t\n    i;\n\n  size_t\n    length;\n\n  /*\n    Initialize tree to describe color cube_info.\n  */\n  cube_info=(CubeInfo *) AcquireMagickMemory(sizeof(*cube_info));\n  if (cube_info == (CubeInfo *) NULL)\n    return((CubeInfo *) NULL);\n  (void) ResetMagickMemory(cube_info,0,sizeof(*cube_info));\n  cube_info->depth=depth;\n  if (cube_info->depth > MaxTreeDepth)\n    cube_info->depth=MaxTreeDepth;\n  if (cube_info->depth < 2)\n    cube_info->depth=2;\n  cube_info->maximum_colors=maximum_colors;\n  /*\n    Initialize root node.\n  */\n  cube_info->root=GetNodeInfo(cube_info,0,0,(NodeInfo *) NULL);\n  if (cube_info->root == (NodeInfo *) NULL)\n    return((CubeInfo *) NULL);\n  cube_info->root->parent=cube_info->root;\n  cube_info->quantize_info=CloneQuantizeInfo(quantize_info);\n  if (cube_info->quantize_info->dither_method == NoDitherMethod)\n    return(cube_info);\n  /*\n    Initialize dither resources.\n  */\n  length=(size_t) (1UL << (4*(8-CacheShift)));\n  cube_info->memory_info=AcquireVirtualMemory(length,sizeof(*cube_info->cache));\n  if (cube_info->memory_info == (MemoryInfo *) NULL)\n    return((CubeInfo *) NULL);\n  cube_info->cache=(ssize_t *) GetVirtualMemoryBlob(cube_info->memory_info);\n  /*\n    Initialize color cache.\n  */\n  (void) ResetMagickMemory(cube_info->cache,(-1),sizeof(*cube_info->cache)*\n    length);\n  /*\n    Distribute weights along a curve of exponential decay.\n  */\n  weight=1.0;\n  for (i=0; i < ErrorQueueLength; i++)\n  {\n    cube_info->weights[ErrorQueueLength-i-1]=PerceptibleReciprocal(weight);\n    weight*=exp(log(((double) QuantumRange+1.0))/(ErrorQueueLength-1.0));\n  }\n  /*\n    Normalize the weighting factors.\n  */\n  weight=0.0;\n  for (i=0; i < ErrorQueueLength; i++)\n    weight+=cube_info->weights[i];\n  sum=0.0;\n  for (i=0; i < ErrorQueueLength; i++)\n  {\n    cube_info->weights[i]/=weight;\n    sum+=cube_info->weights[i];\n  }\n  cube_info->weights[0]+=1.0-sum;\n  return(cube_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t N o d e I n f o                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetNodeInfo() allocates memory for a new node in the color cube tree and\n%  presets all fields to zero.\n%\n%  The format of the GetNodeInfo method is:\n%\n%      NodeInfo *GetNodeInfo(CubeInfo *cube_info,const size_t id,\n%        const size_t level,NodeInfo *parent)\n%\n%  A description of each parameter follows.\n%\n%    o node: The GetNodeInfo method returns a pointer to a queue of nodes.\n%\n%    o id: Specifies the child number of the node.\n%\n%    o level: Specifies the level in the storage_class the node resides.\n%\n*/\nstatic NodeInfo *GetNodeInfo(CubeInfo *cube_info,const size_t id,\n  const size_t level,NodeInfo *parent)\n{\n  NodeInfo\n    *node_info;\n\n  if (cube_info->free_nodes == 0)\n    {\n      Nodes\n        *nodes;\n\n      /*\n        Allocate a new queue of nodes.\n      */\n      nodes=(Nodes *) AcquireMagickMemory(sizeof(*nodes));\n      if (nodes == (Nodes *) NULL)\n        return((NodeInfo *) NULL);\n      nodes->nodes=(NodeInfo *) AcquireQuantumMemory(NodesInAList,\n        sizeof(*nodes->nodes));\n      if (nodes->nodes == (NodeInfo *) NULL)\n        return((NodeInfo *) NULL);\n      nodes->next=cube_info->node_queue;\n      cube_info->node_queue=nodes;\n      cube_info->next_node=nodes->nodes;\n      cube_info->free_nodes=NodesInAList;\n    }\n  cube_info->nodes++;\n  cube_info->free_nodes--;\n  node_info=cube_info->next_node++;\n  (void) ResetMagickMemory(node_info,0,sizeof(*node_info));\n  node_info->parent=parent;\n  node_info->id=id;\n  node_info->level=level;\n  return(node_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%  G e t I m a g e Q u a n t i z e E r r o r                                  %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageQuantizeError() measures the difference between the original\n%  and quantized images.  This difference is the total quantization error.\n%  The error is computed by summing over all pixels in an image the distance\n%  squared in RGB space between each reference pixel value and its quantized\n%  value.  These values are computed:\n%\n%    o mean_error_per_pixel:  This value is the mean error for any single\n%      pixel in the image.\n%\n%    o normalized_mean_square_error:  This value is the normalized mean\n%      quantization error for any single pixel in the image.  This distance\n%      measure is normalized to a range between 0 and 1.  It is independent\n%      of the range of red, green, and blue values in the image.\n%\n%    o normalized_maximum_square_error:  Thsi value is the normalized\n%      maximum quantization error for any single pixel in the image.  This\n%      distance measure is normalized to a range between 0 and 1.  It is\n%      independent of the range of red, green, and blue values in your image.\n%\n%  The format of the GetImageQuantizeError method is:\n%\n%      MagickBooleanType GetImageQuantizeError(Image *image,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType GetImageQuantizeError(Image *image,\n  ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  double\n    alpha,\n    area,\n    beta,\n    distance,\n    maximum_error,\n    mean_error,\n    mean_error_per_pixel;\n\n  size_t\n    index;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  image->total_colors=GetNumberColors(image,(FILE *) NULL,exception);\n  (void) ResetMagickMemory(&image->error,0,sizeof(image->error));\n  if (image->storage_class == DirectClass)\n    return(MagickTrue);\n  alpha=1.0;\n  beta=1.0;\n  area=3.0*image->columns*image->rows;\n  maximum_error=0.0;\n  mean_error_per_pixel=0.0;\n  mean_error=0.0;\n  image_view=AcquireVirtualCacheView(image,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const Quantum\n      *magick_restrict p;\n\n    register ssize_t\n      x;\n\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      index=GetPixelIndex(image,p);\n      if (image->alpha_trait == BlendPixelTrait)\n        {\n          alpha=(double) (QuantumScale*GetPixelAlpha(image,p));\n          beta=(double) (QuantumScale*image->colormap[index].alpha);\n        }\n      distance=fabs((double) (alpha*GetPixelRed(image,p)-beta*\n        image->colormap[index].red));\n      mean_error_per_pixel+=distance;\n      mean_error+=distance*distance;\n      if (distance > maximum_error)\n        maximum_error=distance;\n      distance=fabs((double) (alpha*GetPixelGreen(image,p)-beta*\n        image->colormap[index].green));\n      mean_error_per_pixel+=distance;\n      mean_error+=distance*distance;\n      if (distance > maximum_error)\n        maximum_error=distance;\n      distance=fabs((double) (alpha*GetPixelBlue(image,p)-beta*\n        image->colormap[index].blue));\n      mean_error_per_pixel+=distance;\n      mean_error+=distance*distance;\n      if (distance > maximum_error)\n        maximum_error=distance;\n      p+=GetPixelChannels(image);\n    }\n  }\n  image_view=DestroyCacheView(image_view);\n  image->error.mean_error_per_pixel=(double) mean_error_per_pixel/area;\n  image->error.normalized_mean_error=(double) QuantumScale*QuantumScale*\n    mean_error/area;\n  image->error.normalized_maximum_error=(double) QuantumScale*maximum_error;\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t Q u a n t i z e I n f o                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetQuantizeInfo() initializes the QuantizeInfo structure.\n%\n%  The format of the GetQuantizeInfo method is:\n%\n%      GetQuantizeInfo(QuantizeInfo *quantize_info)\n%\n%  A description of each parameter follows:\n%\n%    o quantize_info: Specifies a pointer to a QuantizeInfo structure.\n%\n*/\nMagickExport void GetQuantizeInfo(QuantizeInfo *quantize_info)\n{\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(quantize_info != (QuantizeInfo *) NULL);\n  (void) ResetMagickMemory(quantize_info,0,sizeof(*quantize_info));\n  quantize_info->number_colors=256;\n  quantize_info->dither_method=RiemersmaDitherMethod;\n  quantize_info->colorspace=UndefinedColorspace;\n  quantize_info->measure_error=MagickFalse;\n  quantize_info->signature=MagickCoreSignature;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     P o s t e r i z e I m a g e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  PosterizeImage() reduces the image to a limited number of colors for a\n%  \"poster\" effect.\n%\n%  The format of the PosterizeImage method is:\n%\n%      MagickBooleanType PosterizeImage(Image *image,const size_t levels,\n%        const DitherMethod dither_method,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: Specifies a pointer to an Image structure.\n%\n%    o levels: Number of color levels allowed in each channel.  Very low values\n%      (2, 3, or 4) have the most visible effect.\n%\n%    o dither_method: choose from UndefinedDitherMethod, NoDitherMethod,\n%      RiemersmaDitherMethod, FloydSteinbergDitherMethod.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline double MagickRound(double x)\n{\n  /*\n    Round the fraction to nearest integer.\n  */\n  if ((x-floor(x)) < (ceil(x)-x))\n    return(floor(x));\n  return(ceil(x));\n}\n\nMagickExport MagickBooleanType PosterizeImage(Image *image,const size_t levels,\n  const DitherMethod dither_method,ExceptionInfo *exception)\n{\n#define PosterizeImageTag  \"Posterize/Image\"\n#define PosterizePixel(pixel) (Quantum) (QuantumRange*(MagickRound( \\\n  QuantumScale*pixel*(levels-1)))/MagickMax((ssize_t) levels-1,1))\n\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  QuantizeInfo\n    *quantize_info;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if (image->storage_class == PseudoClass)\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n    #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n      magick_threads(image,image,1,1)\n#endif\n    for (i=0; i < (ssize_t) image->colors; i++)\n    {\n      /*\n        Posterize colormap.\n      */\n      if ((GetPixelRedTraits(image) & UpdatePixelTrait) != 0)\n        image->colormap[i].red=(double)\n          PosterizePixel(image->colormap[i].red);\n      if ((GetPixelGreenTraits(image) & UpdatePixelTrait) != 0)\n        image->colormap[i].green=(double)\n          PosterizePixel(image->colormap[i].green);\n      if ((GetPixelBlueTraits(image) & UpdatePixelTrait) != 0)\n        image->colormap[i].blue=(double)\n          PosterizePixel(image->colormap[i].blue);\n      if ((GetPixelAlphaTraits(image) & UpdatePixelTrait) != 0)\n        image->colormap[i].alpha=(double)\n          PosterizePixel(image->colormap[i].alpha);\n    }\n  /*\n    Posterize image.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if ((GetPixelRedTraits(image) & UpdatePixelTrait) != 0)\n        SetPixelRed(image,PosterizePixel(GetPixelRed(image,q)),q);\n      if ((GetPixelGreenTraits(image) & UpdatePixelTrait) != 0)\n        SetPixelGreen(image,PosterizePixel(GetPixelGreen(image,q)),q);\n      if ((GetPixelBlueTraits(image) & UpdatePixelTrait) != 0)\n        SetPixelBlue(image,PosterizePixel(GetPixelBlue(image,q)),q);\n      if (((GetPixelBlackTraits(image) & UpdatePixelTrait) != 0) &&\n          (image->colorspace == CMYKColorspace))\n        SetPixelBlack(image,PosterizePixel(GetPixelBlack(image,q)),q);\n      if (((GetPixelAlphaTraits(image) & UpdatePixelTrait) != 0) &&\n          (image->alpha_trait == BlendPixelTrait))\n        SetPixelAlpha(image,PosterizePixel(GetPixelAlpha(image,q)),q);\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_PosterizeImage)\n#endif\n        proceed=SetImageProgress(image,PosterizeImageTag,progress++,\n          image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  quantize_info=AcquireQuantizeInfo((ImageInfo *) NULL);\n  quantize_info->number_colors=(size_t) MagickMin((ssize_t) levels*levels*\n    levels,MaxColormapSize+1);\n  quantize_info->dither_method=dither_method;\n  quantize_info->tree_depth=MaxTreeDepth;\n  status=QuantizeImage(quantize_info,image,exception);\n  quantize_info=DestroyQuantizeInfo(quantize_info);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   P r u n e C h i l d                                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  PruneChild() deletes the given node and merges its statistics into its\n%  parent.\n%\n%  The format of the PruneSubtree method is:\n%\n%      PruneChild(CubeInfo *cube_info,const NodeInfo *node_info)\n%\n%  A description of each parameter follows.\n%\n%    o cube_info: A pointer to the Cube structure.\n%\n%    o node_info: pointer to node in color cube tree that is to be pruned.\n%\n*/\nstatic void PruneChild(CubeInfo *cube_info,const NodeInfo *node_info)\n{\n  NodeInfo\n    *parent;\n\n  register ssize_t\n    i;\n\n  size_t\n    number_children;\n\n  /*\n    Traverse any children.\n  */\n  number_children=cube_info->associate_alpha == MagickFalse ? 8UL : 16UL;\n  for (i=0; i < (ssize_t) number_children; i++)\n    if (node_info->child[i] != (NodeInfo *) NULL)\n      PruneChild(cube_info,node_info->child[i]);\n  /*\n    Merge color statistics into parent.\n  */\n  parent=node_info->parent;\n  parent->number_unique+=node_info->number_unique;\n  parent->total_color.red+=node_info->total_color.red;\n  parent->total_color.green+=node_info->total_color.green;\n  parent->total_color.blue+=node_info->total_color.blue;\n  parent->total_color.alpha+=node_info->total_color.alpha;\n  parent->child[node_info->id]=(NodeInfo *) NULL;\n  cube_info->nodes--;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  P r u n e L e v e l                                                        %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  PruneLevel() deletes all nodes at the bottom level of the color tree merging\n%  their color statistics into their parent node.\n%\n%  The format of the PruneLevel method is:\n%\n%      PruneLevel(CubeInfo *cube_info,const NodeInfo *node_info)\n%\n%  A description of each parameter follows.\n%\n%    o cube_info: A pointer to the Cube structure.\n%\n%    o node_info: pointer to node in color cube tree that is to be pruned.\n%\n*/\nstatic void PruneLevel(CubeInfo *cube_info,const NodeInfo *node_info)\n{\n  register ssize_t\n    i;\n\n  size_t\n    number_children;\n\n  /*\n    Traverse any children.\n  */\n  number_children=cube_info->associate_alpha == MagickFalse ? 8UL : 16UL;\n  for (i=0; i < (ssize_t) number_children; i++)\n    if (node_info->child[i] != (NodeInfo *) NULL)\n      PruneLevel(cube_info,node_info->child[i]);\n  if (node_info->level == cube_info->depth)\n    PruneChild(cube_info,node_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  P r u n e T o C u b e D e p t h                                            %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  PruneToCubeDepth() deletes any nodes at a depth greater than\n%  cube_info->depth while merging their color statistics into their parent\n%  node.\n%\n%  The format of the PruneToCubeDepth method is:\n%\n%      PruneToCubeDepth(CubeInfo *cube_info,const NodeInfo *node_info)\n%\n%  A description of each parameter follows.\n%\n%    o cube_info: A pointer to the Cube structure.\n%\n%    o node_info: pointer to node in color cube tree that is to be pruned.\n%\n*/\nstatic void PruneToCubeDepth(CubeInfo *cube_info,const NodeInfo *node_info)\n{\n  register ssize_t\n    i;\n\n  size_t\n    number_children;\n\n  /*\n    Traverse any children.\n  */\n  number_children=cube_info->associate_alpha == MagickFalse ? 8UL : 16UL;\n  for (i=0; i < (ssize_t) number_children; i++)\n    if (node_info->child[i] != (NodeInfo *) NULL)\n      PruneToCubeDepth(cube_info,node_info->child[i]);\n  if (node_info->level > cube_info->depth)\n    PruneChild(cube_info,node_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%  Q u a n t i z e I m a g e                                                  %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  QuantizeImage() analyzes the colors within a reference image and chooses a\n%  fixed number of colors to represent the image.  The goal of the algorithm\n%  is to minimize the color difference between the input and output image while\n%  minimizing the processing time.\n%\n%  The format of the QuantizeImage method is:\n%\n%      MagickBooleanType QuantizeImage(const QuantizeInfo *quantize_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o quantize_info: Specifies a pointer to an QuantizeInfo structure.\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType QuantizeImage(const QuantizeInfo *quantize_info,\n  Image *image,ExceptionInfo *exception)\n{\n  CubeInfo\n    *cube_info;\n\n  MagickBooleanType\n    status;\n\n  size_t\n    depth,\n    maximum_colors;\n\n  assert(quantize_info != (const QuantizeInfo *) NULL);\n  assert(quantize_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  maximum_colors=quantize_info->number_colors;\n  if (maximum_colors == 0)\n    maximum_colors=MaxColormapSize;\n  if (maximum_colors > MaxColormapSize)\n    maximum_colors=MaxColormapSize;\n  if (image->alpha_trait != BlendPixelTrait)\n    {\n      if (SetImageGray(image,exception) != MagickFalse)\n        (void) SetGrayscaleImage(image,exception);\n    }\n  if ((image->storage_class == PseudoClass) &&\n      (image->colors <= maximum_colors))\n    {\n      if ((quantize_info->colorspace != UndefinedColorspace) &&\n          (quantize_info->colorspace != CMYKColorspace))\n        (void) TransformImageColorspace(image,quantize_info->colorspace,\n          exception);\n      return(MagickTrue);\n    }\n  depth=quantize_info->tree_depth;\n  if (depth == 0)\n    {\n      size_t\n        colors;\n\n      /*\n        Depth of color tree is: Log4(colormap size)+2.\n      */\n      colors=maximum_colors;\n      for (depth=1; colors != 0; depth++)\n        colors>>=2;\n      if ((quantize_info->dither_method != NoDitherMethod) && (depth > 2))\n        depth--;\n      if ((image->alpha_trait == BlendPixelTrait) && (depth > 5))\n        depth--;\n      if (SetImageGray(image,exception) != MagickFalse)\n        depth=MaxTreeDepth;\n    }\n  /*\n    Initialize color cube.\n  */\n  cube_info=GetCubeInfo(quantize_info,depth,maximum_colors);\n  if (cube_info == (CubeInfo *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  status=ClassifyImageColors(cube_info,image,exception);\n  if (status != MagickFalse)\n    {\n      /*\n        Reduce the number of colors in the image if it contains more than the\n        maximum, otherwise we can disable dithering to improve the performance.\n      */\n      if (cube_info->colors > cube_info->maximum_colors)\n        ReduceImageColors(image,cube_info);\n      else\n        cube_info->quantize_info->dither_method=NoDitherMethod;\n      status=AssignImageColors(image,cube_info,exception);\n    }\n  DestroyCubeInfo(cube_info);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   Q u a n t i z e I m a g e s                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  QuantizeImages() analyzes the colors within a set of reference images and\n%  chooses a fixed number of colors to represent the set.  The goal of the\n%  algorithm is to minimize the color difference between the input and output\n%  images while minimizing the processing time.\n%\n%  The format of the QuantizeImages method is:\n%\n%      MagickBooleanType QuantizeImages(const QuantizeInfo *quantize_info,\n%        Image *images,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o quantize_info: Specifies a pointer to an QuantizeInfo structure.\n%\n%    o images: Specifies a pointer to a list of Image structures.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType QuantizeImages(const QuantizeInfo *quantize_info,\n  Image *images,ExceptionInfo *exception)\n{\n  CubeInfo\n    *cube_info;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    proceed,\n    status;\n\n  MagickProgressMonitor\n    progress_monitor;\n\n  register ssize_t\n    i;\n\n  size_t\n    depth,\n    maximum_colors,\n    number_images;\n\n  assert(quantize_info != (const QuantizeInfo *) NULL);\n  assert(quantize_info->signature == MagickCoreSignature);\n  assert(images != (Image *) NULL);\n  assert(images->signature == MagickCoreSignature);\n  if (images->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",images->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if (GetNextImageInList(images) == (Image *) NULL)\n    {\n      /*\n        Handle a single image with QuantizeImage.\n      */\n      status=QuantizeImage(quantize_info,images,exception);\n      return(status);\n    }\n  status=MagickFalse;\n  maximum_colors=quantize_info->number_colors;\n  if (maximum_colors == 0)\n    maximum_colors=MaxColormapSize;\n  if (maximum_colors > MaxColormapSize)\n    maximum_colors=MaxColormapSize;\n  depth=quantize_info->tree_depth;\n  if (depth == 0)\n    {\n      size_t\n        colors;\n\n      /*\n        Depth of color tree is: Log4(colormap size)+2.\n      */\n      colors=maximum_colors;\n      for (depth=1; colors != 0; depth++)\n        colors>>=2;\n      if (quantize_info->dither_method != NoDitherMethod)\n        depth--;\n    }\n  /*\n    Initialize color cube.\n  */\n  cube_info=GetCubeInfo(quantize_info,depth,maximum_colors);\n  if (cube_info == (CubeInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",images->filename);\n      return(MagickFalse);\n    }\n  number_images=GetImageListLength(images);\n  image=images;\n  for (i=0; image != (Image *) NULL; i++)\n  {\n    progress_monitor=SetImageProgressMonitor(image,(MagickProgressMonitor) NULL,\n      image->client_data);\n    status=ClassifyImageColors(cube_info,image,exception);\n    if (status == MagickFalse)\n      break;\n    (void) SetImageProgressMonitor(image,progress_monitor,image->client_data);\n    proceed=SetImageProgress(image,AssignImageTag,(MagickOffsetType) i,\n      number_images);\n    if (proceed == MagickFalse)\n      break;\n    image=GetNextImageInList(image);\n  }\n  if (status != MagickFalse)\n    {\n      /*\n        Reduce the number of colors in an image sequence.\n      */\n      ReduceImageColors(images,cube_info);\n      image=images;\n      for (i=0; image != (Image *) NULL; i++)\n      {\n        progress_monitor=SetImageProgressMonitor(image,(MagickProgressMonitor)\n          NULL,image->client_data);\n        status=AssignImageColors(image,cube_info,exception);\n        if (status == MagickFalse)\n          break;\n        (void) SetImageProgressMonitor(image,progress_monitor,\n          image->client_data);\n        proceed=SetImageProgress(image,AssignImageTag,(MagickOffsetType) i,\n          number_images);\n        if (proceed == MagickFalse)\n          break;\n        image=GetNextImageInList(image);\n      }\n    }\n  DestroyCubeInfo(cube_info);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   Q u a n t i z e E r r o r F l a t t e n                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  QuantizeErrorFlatten() traverses the color cube and flattens the quantization\n%  error into a sorted 1D array.  This accelerates the color reduction process.\n%\n%  Contributed by Yoya.\n%\n%  The format of the QuantizeErrorFlatten method is:\n%\n%      size_t QuantizeErrorFlatten(const CubeInfo *cube_info,\n%        const NodeInfo *node_info,const ssize_t offset,\n%        double *quantize_error)\n%\n%  A description of each parameter follows.\n%\n%    o cube_info: A pointer to the Cube structure.\n%\n%    o node_info: pointer to node in color cube tree that is current pointer.\n%\n%    o offset: quantize error offset.\n%\n%    o quantize_error: the quantization error vector.\n%\n*/\nstatic size_t QuantizeErrorFlatten(const CubeInfo *cube_info,\n  const NodeInfo *node_info,const ssize_t offset,double *quantize_error)\n{\n  register ssize_t\n    i;\n\n  size_t\n    n,\n    number_children;\n\n  if (offset >= (ssize_t) cube_info->nodes)\n    return(0);\n  quantize_error[offset]=node_info->quantize_error;\n  n=1;\n  number_children=cube_info->associate_alpha == MagickFalse ? 8UL : 16UL;\n  for (i=0; i < (ssize_t) number_children ; i++)\n    if (node_info->child[i] != (NodeInfo *) NULL)\n      n+=QuantizeErrorFlatten(cube_info,node_info->child[i],offset+n,\n        quantize_error);\n  return(n);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   R e d u c e                                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  Reduce() traverses the color cube tree and prunes any node whose\n%  quantization error falls below a particular threshold.\n%\n%  The format of the Reduce method is:\n%\n%      Reduce(CubeInfo *cube_info,const NodeInfo *node_info)\n%\n%  A description of each parameter follows.\n%\n%    o cube_info: A pointer to the Cube structure.\n%\n%    o node_info: pointer to node in color cube tree that is to be pruned.\n%\n*/\nstatic void Reduce(CubeInfo *cube_info,const NodeInfo *node_info)\n{\n  register ssize_t\n    i;\n\n  size_t\n    number_children;\n\n  /*\n    Traverse any children.\n  */\n  number_children=cube_info->associate_alpha == MagickFalse ? 8UL : 16UL;\n  for (i=0; i < (ssize_t) number_children; i++)\n    if (node_info->child[i] != (NodeInfo *) NULL)\n      Reduce(cube_info,node_info->child[i]);\n  if (node_info->quantize_error <= cube_info->pruning_threshold)\n    PruneChild(cube_info,node_info);\n  else\n    {\n      /*\n        Find minimum pruning threshold.\n      */\n      if (node_info->number_unique > 0)\n        cube_info->colors++;\n      if (node_info->quantize_error < cube_info->next_threshold)\n        cube_info->next_threshold=node_info->quantize_error;\n    }\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   R e d u c e I m a g e C o l o r s                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReduceImageColors() repeatedly prunes the tree until the number of nodes\n%  with n2 > 0 is less than or equal to the maximum number of colors allowed\n%  in the output image.  On any given iteration over the tree, it selects\n%  those nodes whose E value is minimal for pruning and merges their\n%  color statistics upward. It uses a pruning threshold, Ep, to govern\n%  node selection as follows:\n%\n%    Ep = 0\n%    while number of nodes with (n2 > 0) > required maximum number of colors\n%      prune all nodes such that E <= Ep\n%      Set Ep to minimum E in remaining nodes\n%\n%  This has the effect of minimizing any quantization error when merging\n%  two nodes together.\n%\n%  When a node to be pruned has offspring, the pruning procedure invokes\n%  itself recursively in order to prune the tree from the leaves upward.\n%  n2,  Sr, Sg,  and  Sb in a node being pruned are always added to the\n%  corresponding data in that node's parent.  This retains the pruned\n%  node's color characteristics for later averaging.\n%\n%  For each node, n2 pixels exist for which that node represents the\n%  smallest volume in RGB space containing those pixel's colors.  When n2\n%  > 0 the node will uniquely define a color in the output image. At the\n%  beginning of reduction,  n2 = 0  for all nodes except a the leaves of\n%  the tree which represent colors present in the input image.\n%\n%  The other pixel count, n1, indicates the total number of colors\n%  within the cubic volume which the node represents.  This includes n1 -\n%  n2  pixels whose colors should be defined by nodes at a lower level in\n%  the tree.\n%\n%  The format of the ReduceImageColors method is:\n%\n%      ReduceImageColors(const Image *image,CubeInfo *cube_info)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n%    o cube_info: A pointer to the Cube structure.\n%\n*/\n\nstatic int QuantizeErrorCompare(const void *error_p,const void *error_q)\n{\n  double\n    *p,\n    *q;\n\n  p=(double *) error_p;\n  q=(double *) error_q;\n  if (*p > *q)\n    return(1);\n  if (fabs(*q-*p) <= MagickEpsilon)\n    return(0);\n  return(-1);\n}\n\nstatic void ReduceImageColors(const Image *image,CubeInfo *cube_info)\n{\n#define ReduceImageTag  \"Reduce/Image\"\n\n  MagickBooleanType\n    proceed;\n\n  MagickOffsetType\n    offset;\n\n  size_t\n    span;\n\n  cube_info->next_threshold=0.0;\n  if (cube_info->colors > cube_info->maximum_colors)\n    {\n      double\n        *quantize_error;\n\n      /*\n        Enable rapid reduction of the number of unique colors.\n      */\n      quantize_error=(double *) AcquireQuantumMemory(cube_info->nodes,\n        sizeof(*quantize_error));\n      if (quantize_error != (double *) NULL)\n        {\n          (void) QuantizeErrorFlatten(cube_info,cube_info->root,0,\n            quantize_error);\n          qsort(quantize_error,cube_info->nodes,sizeof(double),\n            QuantizeErrorCompare);\n          if (cube_info->nodes > (110*(cube_info->maximum_colors+1)/100))\n            cube_info->next_threshold=quantize_error[cube_info->nodes-110*\n              (cube_info->maximum_colors+1)/100];\n          quantize_error=(double *) RelinquishMagickMemory(quantize_error);\n        }\n  }\n  for (span=cube_info->colors; cube_info->colors > cube_info->maximum_colors; )\n  {\n    cube_info->pruning_threshold=cube_info->next_threshold;\n    cube_info->next_threshold=cube_info->root->quantize_error-1;\n    cube_info->colors=0;\n    Reduce(cube_info,cube_info->root);\n    offset=(MagickOffsetType) span-cube_info->colors;\n    proceed=SetImageProgress(image,ReduceImageTag,offset,span-\n      cube_info->maximum_colors+1);\n    if (proceed == MagickFalse)\n      break;\n  }\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e m a p I m a g e                                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RemapImage() replaces the colors of an image with the closest of the colors\n%  from the reference image.\n%\n%  The format of the RemapImage method is:\n%\n%      MagickBooleanType RemapImage(const QuantizeInfo *quantize_info,\n%        Image *image,const Image *remap_image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o quantize_info: Specifies a pointer to an QuantizeInfo structure.\n%\n%    o image: the image.\n%\n%    o remap_image: the reference image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType RemapImage(const QuantizeInfo *quantize_info,\n  Image *image,const Image *remap_image,ExceptionInfo *exception)\n{\n  CubeInfo\n    *cube_info;\n\n  MagickBooleanType\n    status;\n\n  /*\n    Initialize color cube.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(remap_image != (Image *) NULL);\n  assert(remap_image->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  cube_info=GetCubeInfo(quantize_info,MaxTreeDepth,\n    quantize_info->number_colors);\n  if (cube_info == (CubeInfo *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  status=ClassifyImageColors(cube_info,remap_image,exception);\n  if (status != MagickFalse)\n    {\n      /*\n        Classify image colors from the reference image.\n      */\n      cube_info->quantize_info->number_colors=cube_info->colors;\n      status=AssignImageColors(image,cube_info,exception);\n    }\n  DestroyCubeInfo(cube_info);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e m a p I m a g e s                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RemapImages() replaces the colors of a sequence of images with the\n%  closest color from a reference image.\n%\n%  The format of the RemapImage method is:\n%\n%      MagickBooleanType RemapImages(const QuantizeInfo *quantize_info,\n%        Image *images,Image *remap_image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o quantize_info: Specifies a pointer to an QuantizeInfo structure.\n%\n%    o images: the image sequence.\n%\n%    o remap_image: the reference image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType RemapImages(const QuantizeInfo *quantize_info,\n  Image *images,const Image *remap_image,ExceptionInfo *exception)\n{\n  CubeInfo\n    *cube_info;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  assert(images != (Image *) NULL);\n  assert(images->signature == MagickCoreSignature);\n  if (images->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",images->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=images;\n  if (remap_image == (Image *) NULL)\n    {\n      /*\n        Create a global colormap for an image sequence.\n      */\n      status=QuantizeImages(quantize_info,images,exception);\n      return(status);\n    }\n  /*\n    Classify image colors from the reference image.\n  */\n  cube_info=GetCubeInfo(quantize_info,MaxTreeDepth,\n    quantize_info->number_colors);\n  if (cube_info == (CubeInfo *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  status=ClassifyImageColors(cube_info,remap_image,exception);\n  if (status != MagickFalse)\n    {\n      /*\n        Classify image colors from the reference image.\n      */\n      cube_info->quantize_info->number_colors=cube_info->colors;\n      image=images;\n      for ( ; image != (Image *) NULL; image=GetNextImageInList(image))\n      {\n        status=AssignImageColors(image,cube_info,exception);\n        if (status == MagickFalse)\n          break;\n      }\n    }\n  DestroyCubeInfo(cube_info);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t G r a y s c a l e I m a g e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetGrayscaleImage() converts an image to a PseudoClass grayscale image.\n%\n%  The format of the SetGrayscaleImage method is:\n%\n%      MagickBooleanType SetGrayscaleImage(Image *image,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\nstatic int IntensityCompare(const void *x,const void *y)\n{\n  double\n    intensity;\n\n  PixelInfo\n    *color_1,\n    *color_2;\n\n  color_1=(PixelInfo *) x;\n  color_2=(PixelInfo *) y;\n  intensity=GetPixelInfoIntensity((const Image *) NULL,color_1)-\n    GetPixelInfoIntensity((const Image *) NULL,color_2);\n  return((int) intensity);\n}\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\nstatic MagickBooleanType SetGrayscaleImage(Image *image,\n  ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  PixelInfo\n    *colormap;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    *colormap_index,\n    j,\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->type != GrayscaleType)\n    (void) TransformImageColorspace(image,GRAYColorspace,exception);\n  colormap_index=(ssize_t *) AcquireQuantumMemory(MaxColormapSize,\n    sizeof(*colormap_index));\n  if (colormap_index == (ssize_t *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  if (image->storage_class != PseudoClass)\n    {\n      (void) ResetMagickMemory(colormap_index,(-1),MaxColormapSize*\n        sizeof(*colormap_index));\n      if (AcquireImageColormap(image,MaxColormapSize,exception) == MagickFalse)\n        ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n          image->filename);\n      image->colors=0;\n      status=MagickTrue;\n      image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n      #pragma omp parallel for schedule(static,4) shared(status) \\\n        magick_threads(image,image,image->rows,1)\n#endif\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        register Quantum\n          *magick_restrict q;\n\n        register ssize_t\n          x;\n\n        if (status == MagickFalse)\n          continue;\n        q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,\n          exception);\n        if (q == (Quantum *) NULL)\n          {\n            status=MagickFalse;\n            continue;\n          }\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          register size_t\n            intensity;\n\n          intensity=ScaleQuantumToMap(GetPixelRed(image,q));\n          if (colormap_index[intensity] < 0)\n            {\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n              #pragma omp critical (MagickCore_SetGrayscaleImage)\n#endif\n              if (colormap_index[intensity] < 0)\n                {\n                  colormap_index[intensity]=(ssize_t) image->colors;\n                  image->colormap[image->colors].red=(double)\n                    GetPixelRed(image,q);\n                  image->colormap[image->colors].green=(double)\n                    GetPixelGreen(image,q);\n                  image->colormap[image->colors].blue=(double)\n                    GetPixelBlue(image,q);\n                  image->colors++;\n               }\n            }\n          SetPixelIndex(image,(Quantum) colormap_index[intensity],q);\n          q+=GetPixelChannels(image);\n        }\n        if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n          status=MagickFalse;\n      }\n      image_view=DestroyCacheView(image_view);\n    }\n  for (i=0; i < (ssize_t) image->colors; i++)\n    image->colormap[i].alpha=(double) i;\n  qsort((void *) image->colormap,image->colors,sizeof(PixelInfo),\n    IntensityCompare);\n  colormap=(PixelInfo *) AcquireQuantumMemory(image->colors,sizeof(*colormap));\n  if (colormap == (PixelInfo *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  j=0;\n  colormap[j]=image->colormap[0];\n  for (i=0; i < (ssize_t) image->colors; i++)\n  {\n    if (IsPixelInfoEquivalent(&colormap[j],&image->colormap[i]) == MagickFalse)\n      {\n        j++;\n        colormap[j]=image->colormap[i];\n      }\n    colormap_index[(ssize_t) image->colormap[i].alpha]=j;\n  }\n  image->colors=(size_t) (j+1);\n  image->colormap=(PixelInfo *) RelinquishMagickMemory(image->colormap);\n  image->colormap=colormap;\n  status=MagickTrue;\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(status) \\\n    magick_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      SetPixelIndex(image,(Quantum) colormap_index[ScaleQuantumToMap(\n        GetPixelIndex(image,q))],q);\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  image_view=DestroyCacheView(image_view);\n  colormap_index=(ssize_t *) RelinquishMagickMemory(colormap_index);\n  image->type=GrayscaleType;\n  if (SetImageMonochrome(image,exception) != MagickFalse)\n    image->type=BilevelType;\n  return(status);\n}\n", "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                        PPPP    AAA   L      M   M                           %\n%                        P   P  A   A  L      MM MM                           %\n%                        PPPP   AAAAA  L      M M M                           %\n%                        P      A   A  L      M   M                           %\n%                        P      A   A  LLLLL  M   M                           %\n%                                                                             %\n%                                                                             %\n%                          Read/Write Palm Pixmap.                            %\n%                                                                             %\n%                                                                             %\n%                              Software Design                                %\n%                            Christopher R. Hawks                             %\n%                               December 2001                                 %\n%                                                                             %\n%  Copyright 1999-2004 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://www.imagemagick.org/script/license.php                           %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  Based on pnmtopalm by Bill Janssen and ppmtobmp by Ian Goldberg.\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colormap-private.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/histogram.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/paint.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantize.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/utility.h\"\n\f\n/*\n  Define declarations.\n*/\n#define PALM_IS_COMPRESSED_FLAG  0x8000\n#define PALM_HAS_COLORMAP_FLAG  0x4000\n#define PALM_HAS_FOUR_BYTE_FIELD  0x0200\n#define PALM_HAS_TRANSPARENCY_FLAG  0x2000\n#define PALM_IS_INDIRECT  0x1000\n#define PALM_IS_FOR_SCREEN  0x0800\n#define PALM_IS_DIRECT_COLOR  0x0400\n#define PALM_COMPRESSION_SCANLINE  0x00\n#define PALM_COMPRESSION_RLE  0x01\n#define PALM_COMPRESSION_NONE  0xFF\n\f\n/*\n The 256 color system palette for Palm Computing Devices.\n*/\nstatic const unsigned char\n  PalmPalette[256][3] =\n  {\n    {255, 255,255}, {255, 204,255}, {255, 153,255}, {255, 102,255},\n    {255,  51,255}, {255,   0,255}, {255, 255,204}, {255, 204,204},\n    {255, 153,204}, {255, 102,204}, {255,  51,204}, {255,   0,204},\n    {255, 255,153}, {255, 204,153}, {255, 153,153}, {255, 102,153},\n    {255,  51,153}, {255,   0,153}, {204, 255,255}, {204, 204,255},\n    {204, 153,255}, {204, 102,255}, {204,  51,255}, {204,   0,255},\n    {204, 255,204}, {204, 204,204}, {204, 153,204}, {204, 102,204},\n    {204,  51,204}, {204,   0,204}, {204, 255,153}, {204, 204,153},\n    {204, 153,153}, {204, 102,153}, {204,  51,153}, {204,   0,153},\n    {153, 255,255}, {153, 204,255}, {153, 153,255}, {153, 102,255},\n    {153,  51,255}, {153,   0,255}, {153, 255,204}, {153, 204,204},\n    {153, 153,204}, {153, 102,204}, {153,  51,204}, {153,   0,204},\n    {153, 255,153}, {153, 204,153}, {153, 153,153}, {153, 102,153},\n    {153,  51,153}, {153,   0,153}, {102, 255,255}, {102, 204,255},\n    {102, 153,255}, {102, 102,255}, {102,  51,255}, {102,   0,255},\n    {102, 255,204}, {102, 204,204}, {102, 153,204}, {102, 102,204},\n    {102,  51,204}, {102,   0,204}, {102, 255,153}, {102, 204,153},\n    {102, 153,153}, {102, 102,153}, {102,  51,153}, {102,   0,153},\n    { 51, 255,255}, { 51, 204,255}, { 51, 153,255}, { 51, 102,255},\n    { 51,  51,255}, { 51,   0,255}, { 51, 255,204}, { 51, 204,204},\n    { 51, 153,204}, { 51, 102,204}, { 51,  51,204}, { 51,   0,204},\n    { 51, 255,153}, { 51, 204,153}, { 51, 153,153}, { 51, 102,153},\n    { 51,  51,153}, { 51,   0,153}, {  0, 255,255}, {  0, 204,255},\n    {  0, 153,255}, {  0, 102,255}, {  0,  51,255}, {  0,   0,255},\n    {  0, 255,204}, {  0, 204,204}, {  0, 153,204}, {  0, 102,204},\n    {  0,  51,204}, {  0,   0,204}, {  0, 255,153}, {  0, 204,153},\n    {  0, 153,153}, {  0, 102,153}, {  0,  51,153}, {  0,   0,153},\n    {255, 255,102}, {255, 204,102}, {255, 153,102}, {255, 102,102},\n    {255,  51,102}, {255,   0,102}, {255, 255, 51}, {255, 204, 51},\n    {255, 153, 51}, {255, 102, 51}, {255,  51, 51}, {255,   0, 51},\n    {255, 255,  0}, {255, 204,  0}, {255, 153,  0}, {255, 102,  0},\n    {255,  51,  0}, {255,   0,  0}, {204, 255,102}, {204, 204,102},\n    {204, 153,102}, {204, 102,102}, {204,  51,102}, {204,   0,102},\n    {204, 255, 51}, {204, 204, 51}, {204, 153, 51}, {204, 102, 51},\n    {204,  51, 51}, {204,   0, 51}, {204, 255,  0}, {204, 204,  0},\n    {204, 153,  0}, {204, 102,  0}, {204,  51,  0}, {204,   0,  0},\n    {153, 255,102}, {153, 204,102}, {153, 153,102}, {153, 102,102},\n    {153,  51,102}, {153,   0,102}, {153, 255, 51}, {153, 204, 51},\n    {153, 153, 51}, {153, 102, 51}, {153,  51, 51}, {153,   0, 51},\n    {153, 255,  0}, {153, 204,  0}, {153, 153,  0}, {153, 102,  0},\n    {153,  51,  0}, {153,   0,  0}, {102, 255,102}, {102, 204,102},\n    {102, 153,102}, {102, 102,102}, {102,  51,102}, {102,   0,102},\n    {102, 255, 51}, {102, 204, 51}, {102, 153, 51}, {102, 102, 51},\n    {102,  51, 51}, {102,   0, 51}, {102, 255,  0}, {102, 204,  0},\n    {102, 153,  0}, {102, 102,  0}, {102,  51,  0}, {102,   0,  0},\n    { 51, 255,102}, { 51, 204,102}, { 51, 153,102}, { 51, 102,102},\n    { 51,  51,102}, { 51,   0,102}, { 51, 255, 51}, { 51, 204, 51},\n    { 51, 153, 51}, { 51, 102, 51}, { 51,  51, 51}, { 51,   0, 51},\n    { 51, 255,  0}, { 51, 204,  0}, { 51, 153,  0}, { 51, 102,  0},\n    { 51,  51,  0}, { 51,   0,  0}, {  0, 255,102}, {  0, 204,102},\n    {  0, 153,102}, {  0, 102,102}, {  0,  51,102}, {  0,   0,102},\n    {  0, 255, 51}, {  0, 204, 51}, {  0, 153, 51}, {  0, 102, 51},\n    {  0,  51, 51}, {  0,   0, 51}, {  0, 255,  0}, {  0, 204,  0},\n    {  0, 153,  0}, {  0, 102,  0}, {  0,  51,  0}, { 17,  17, 17},\n    { 34,  34, 34}, { 68,  68, 68}, { 85,  85, 85}, {119, 119,119},\n    {136, 136,136}, {170, 170,170}, {187, 187,187}, {221, 221,221},\n    {238, 238,238}, {192, 192,192}, {128,   0,  0}, {128,   0,128},\n    {  0, 128,  0}, {  0, 128,128}, {  0,   0,  0}, {  0,   0,  0},\n    {  0,   0,  0}, {  0,   0,  0}, {  0,   0,  0}, {  0,   0,  0},\n    {  0,   0,  0}, {  0,   0,  0}, {  0,   0,  0}, {  0,   0,  0},\n    {  0,   0,  0}, {  0,   0,  0}, {  0,   0,  0}, {  0,   0,  0},\n    {  0,   0,  0}, {  0,   0,  0}, {  0,   0,  0}, {  0,   0,  0},\n    {  0,   0,  0}, {  0,   0,  0}, {  0,   0,  0}, {  0,   0,  0},\n    {  0,   0,  0}, {  0,   0,  0}, {  0,   0,  0}, {  0,   0,  0}\n  };\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WritePALMImage(const ImageInfo *,Image *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   F i n d C o l o r                                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  FindColor() returns the index of the matching entry from PalmPalette for a\n%  given PixelInfo.\n%\n%  The format of the FindColor method is:\n%\n%      int FindColor(PixelInfo *pixel)\n%\n%  A description of each parameter follows:\n%\n%    o int: the index of the matching color or -1 if not found/\n%\n%    o pixel: a pointer to the PixelInfo to be matched.\n%\n*/\nstatic ssize_t FindColor(PixelInfo *packet)\n{\n  register ssize_t\n    i;\n\n  for (i=0; i < 256; i++)\n    if (ScaleQuantumToChar(ClampToQuantum(packet->red)) == PalmPalette[i][0] &&\n        ScaleQuantumToChar(ClampToQuantum(packet->green)) == PalmPalette[i][1] &&\n        ScaleQuantumToChar(ClampToQuantum(packet->blue)) == PalmPalette[i][2])\n      return(i);\n  return(-1);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d P A L M I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadPALMImage() reads an image of raw bites in LSB order and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadPALMImage method is:\n%\n%      Image *ReadPALMImage(const ImageInfo *image_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: Specifies a pointer to an ImageInfo structure.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadPALMImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    totalOffset,\n    seekNextDepth;\n\n  PixelInfo\n    transpix;\n\n  Quantum\n    index;\n\n  register ssize_t\n    i,\n    x;\n\n  register Quantum\n    *q;\n\n  size_t\n    bytes_per_row,\n    flags,\n    bits_per_pixel,\n    version,\n    nextDepthOffset,\n    transparentIndex,\n    compressionType,\n    byte,\n    mask,\n    redbits,\n    greenbits,\n    bluebits,\n    one,\n    pad,\n    size,\n    bit;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *lastrow,\n    *one_row,\n    *ptr;\n\n  unsigned short\n    color16;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      (void) DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  totalOffset=0;\n  do\n  {\n    image->columns=ReadBlobMSBShort(image);\n    image->rows=ReadBlobMSBShort(image);\n    if (EOFBlob(image) != MagickFalse)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((image->columns == 0) || (image->rows == 0))\n      ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    bytes_per_row=ReadBlobMSBShort(image);\n    flags=ReadBlobMSBShort(image);\n    bits_per_pixel=(size_t) ReadBlobByte(image);\n    if ((bits_per_pixel != 1) && (bits_per_pixel != 2) &&\n        (bits_per_pixel != 4) && (bits_per_pixel != 8) &&\n        (bits_per_pixel != 16))\n      ThrowReaderException(CorruptImageError,\"UnrecognizedBitsPerPixel\");\n    version=(size_t) ReadBlobByte(image);\n    if ((version != 0) && (version != 1) && (version != 2))\n      ThrowReaderException(CorruptImageError,\"FileFormatVersionMismatch\");\n    nextDepthOffset=(size_t) ReadBlobMSBShort(image);\n    transparentIndex=(size_t) ReadBlobByte(image);\n    compressionType=(size_t) ReadBlobByte(image);\n    if ((compressionType != PALM_COMPRESSION_NONE) &&\n        (compressionType != PALM_COMPRESSION_SCANLINE ) &&\n        (compressionType != PALM_COMPRESSION_RLE))\n      ThrowReaderException(CorruptImageError,\"UnrecognizedImageCompression\");\n    pad=ReadBlobMSBShort(image);\n    (void) pad;\n    /*\n      Initialize image colormap.\n    */\n    one=1;\n    if ((bits_per_pixel < 16) &&\n        (AcquireImageColormap(image,one << bits_per_pixel,exception) == MagickFalse))\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    GetPixelInfo(image,&transpix);\n    if (bits_per_pixel == 16)  /* Direct Color */\n      {\n        redbits=(size_t) ReadBlobByte(image);  /* # of bits of red */\n        (void) redbits;\n        greenbits=(size_t) ReadBlobByte(image);  /* # of bits of green */\n        (void) greenbits;\n        bluebits=(size_t) ReadBlobByte(image);  /* # of bits of blue */\n        (void) bluebits;\n        ReadBlobByte(image);  /* reserved by Palm */\n        ReadBlobByte(image);  /* reserved by Palm */\n        transpix.red=(double) (QuantumRange*ReadBlobByte(image)/31);\n        transpix.green=(double) (QuantumRange*ReadBlobByte(image)/63);\n        transpix.blue=(double) (QuantumRange*ReadBlobByte(image)/31);\n      }\n    if (bits_per_pixel == 8)\n      {\n        ssize_t\n          index;\n\n        if (flags & PALM_HAS_COLORMAP_FLAG)\n          {\n            count=(ssize_t) ReadBlobMSBShort(image);\n            for (i=0; i < (ssize_t) count; i++)\n            {\n              ReadBlobByte(image);\n              index=ConstrainColormapIndex(image,255-i,exception);\n              image->colormap[index].red=(MagickRealType)\n                ScaleCharToQuantum((unsigned char) ReadBlobByte(image));\n              image->colormap[index].green=(MagickRealType)\n                ScaleCharToQuantum((unsigned char) ReadBlobByte(image));\n              image->colormap[index].blue=(MagickRealType)\n                ScaleCharToQuantum((unsigned char) ReadBlobByte(image));\n          }\n        }\n      else\n        for (i=0; i < (ssize_t) (1L << bits_per_pixel); i++)\n        {\n          index=ConstrainColormapIndex(image,255-i,exception);\n          image->colormap[index].red=(MagickRealType)\n            ScaleCharToQuantum(PalmPalette[i][0]);\n          image->colormap[index].green=(MagickRealType)\n            ScaleCharToQuantum(PalmPalette[i][1]);\n          image->colormap[index].blue=(MagickRealType)\n            ScaleCharToQuantum(PalmPalette[i][2]);\n        }\n      }\n    if (flags & PALM_IS_COMPRESSED_FLAG)\n      size=ReadBlobMSBShort(image);\n    (void) size;\n    image->storage_class=DirectClass;\n    if (bits_per_pixel < 16)\n      {\n        image->storage_class=PseudoClass;\n        image->depth=8;\n      }\n    if (image_info->ping != MagickFalse)\n      {\n        (void) CloseBlob(image);\n        return(image);\n      }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    one_row=(unsigned char *) AcquireQuantumMemory(MagickMax(bytes_per_row,\n      2*image->columns),sizeof(*one_row));\n    if (one_row == (unsigned char *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    lastrow=(unsigned char *) NULL;\n    if (compressionType == PALM_COMPRESSION_SCANLINE)\n      {\n        lastrow=(unsigned char *) AcquireQuantumMemory(MagickMax(bytes_per_row,\n          2*image->columns),sizeof(*lastrow));\n        if (lastrow == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    mask=(size_t) (1U << bits_per_pixel)-1;\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      if ((flags & PALM_IS_COMPRESSED_FLAG) == 0)\n        {\n          /* TODO move out of loop! */\n          image->compression=NoCompression;\n          count=ReadBlob(image,bytes_per_row,one_row);\n          if (count != (ssize_t) bytes_per_row)\n            break;\n        }\n      else\n        {\n          if (compressionType == PALM_COMPRESSION_RLE)\n            { \n              /* TODO move out of loop! */\n              image->compression=RLECompression;\n              for (i=0; i < (ssize_t) bytes_per_row; )\n              {\n                count=(ssize_t) ReadBlobByte(image);\n                if (count < 0)\n                  break;\n                count=MagickMin(count,(ssize_t) bytes_per_row-i);\n                byte=(size_t) ReadBlobByte(image);\n                (void) ResetMagickMemory(one_row+i,(int) byte,(size_t) count);\n                i+=count;\n              }\n          }\n        else\n          if (compressionType == PALM_COMPRESSION_SCANLINE)\n            {\n              size_t\n                one;\n\n              /* TODO move out of loop! */\n              one=1;\n              image->compression=FaxCompression;\n              for (i=0; i < (ssize_t) bytes_per_row; i+=8)\n              {\n                count=(ssize_t) ReadBlobByte(image);\n                if (count < 0)\n                  break;\n                byte=(size_t) MagickMin((ssize_t) bytes_per_row-i,8);\n                for (bit=0; bit < byte; bit++)\n                {\n                  if ((y == 0) || (count & (one << (7 - bit))))\n                    one_row[i+bit]=(unsigned char) ReadBlobByte(image);\n                  else\n                    one_row[i+bit]=lastrow[i+bit];\n                }\n              }\n              (void) CopyMagickMemory(lastrow, one_row, bytes_per_row);\n            }\n        }\n      ptr=one_row;\n      q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n      if (q == (Quantum *) NULL)\n        break;\n      if (bits_per_pixel == 16)\n        {\n          if (image->columns > (2*bytes_per_row))\n            {\n              one_row=(unsigned char *) RelinquishMagickMemory(one_row);\n              if (compressionType == PALM_COMPRESSION_SCANLINE)\n                lastrow=(unsigned char *) RelinquishMagickMemory(lastrow);\n              ThrowReaderException(CorruptImageError,\"CorruptImage\");\n            }\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            color16=(*ptr++ << 8);\n            color16|=(*ptr++);\n            SetPixelRed(image,(Quantum) ((QuantumRange*((color16 >> 11) &\n              0x1f))/0x1f),q);\n            SetPixelGreen(image,(Quantum) ((QuantumRange*((color16 >> 5) &\n              0x3f))/0x3f),q);\n            SetPixelBlue(image,(Quantum) ((QuantumRange*((color16 >> 0) &\n              0x1f))/0x1f),q);\n            SetPixelAlpha(image,OpaqueAlpha,q);\n            q+=GetPixelChannels(image);\n          }\n        }\n      else\n        {\n          bit=8-bits_per_pixel;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            if ((size_t) (ptr-one_row) >= bytes_per_row)\n              {\n                one_row=(unsigned char *) RelinquishMagickMemory(one_row);\n                if (compressionType == PALM_COMPRESSION_SCANLINE)\n                  lastrow=(unsigned char *) RelinquishMagickMemory(lastrow);\n                ThrowReaderException(CorruptImageError,\"CorruptImage\");\n              }\n            index=(Quantum) (mask-(((*ptr) & (mask << bit)) >> bit));\n            SetPixelIndex(image,index,q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            if (bit)\n              bit-=bits_per_pixel;\n            else\n              {\n                ptr++;\n                bit=8-bits_per_pixel;\n              }\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n        }\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n      }\n    if (flags & PALM_HAS_TRANSPARENCY_FLAG)\n      {\n        ssize_t index=ConstrainColormapIndex(image,(ssize_t) (mask-\n          transparentIndex),exception);\n        if (bits_per_pixel != 16)\n          transpix=image->colormap[index];\n        (void) TransparentPaintImage(image,&transpix,(Quantum) TransparentAlpha,\n          MagickFalse,exception);\n      }\n    one_row=(unsigned char *) RelinquishMagickMemory(one_row);\n    if (compressionType == PALM_COMPRESSION_SCANLINE)\n      lastrow=(unsigned char *) RelinquishMagickMemory(lastrow);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image. Copied from coders/pnm.c\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if (nextDepthOffset != 0)\n      { \n        /*\n          Skip to next image. \n        */\n        totalOffset+=(MagickOffsetType) (nextDepthOffset*4);\n        if (totalOffset >= (MagickOffsetType) GetBlobSize(image))\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\")\n        else\n          seekNextDepth=SeekBlob(image,totalOffset,SEEK_SET);\n        if (seekNextDepth != totalOffset)\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        /*\n          Allocate next image structure. Copied from coders/pnm.c\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            (void) DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (nextDepthOffset != 0);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r P A L M I m a g e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterPALMImage() adds properties for the PALM image format to the list of\n%  supported formats.  The properties include the image format tag, a method to\n%  read and/or write the format, whether the format supports the saving of more\n%  than one frame to the same file or blob, whether the format supports native\n%  in-memory I/O, and a brief description of the format.\n%\n%  The format of the RegisterPALMImage method is:\n%\n%      size_t RegisterPALMImage(void)\n%\n*/\nModuleExport size_t RegisterPALMImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"PALM\",\"PALM\",\"Palm pixmap\");\n  entry->decoder=(DecodeImageHandler *) ReadPALMImage;\n  entry->encoder=(EncodeImageHandler *) WritePALMImage;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags|=CoderEncoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r P A L M I m a g e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterPALMImage() removes format registrations made by the PALM\n%  module from the list of supported formats.\n%\n%  The format of the UnregisterPALMImage method is:\n%\n%      UnregisterPALMImage(void)\n%\n*/\nModuleExport void UnregisterPALMImage(void)\n{\n  (void) UnregisterMagickInfo(\"PALM\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e P A L M I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WritePALMImage() writes an image of raw bits in LSB order to a file.\n%\n%  The format of the WritePALMImage method is:\n%\n%      MagickBooleanType WritePALMImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: Specifies a pointer to an ImageInfo structure.\n%\n%    o image:  A pointer to a Image structure.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WritePALMImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    currentOffset,\n    offset,\n    scene;\n\n  MagickSizeType\n    cc;\n\n  PixelInfo\n    transpix;\n\n  QuantizeInfo\n    *quantize_info;\n\n  register ssize_t\n    x;\n\n  register const Quantum\n    *p;\n\n  register Quantum\n    *q;\n\n  ssize_t\n    y;\n\n  size_t\n    count,\n    bits_per_pixel,\n    bytes_per_row,\n    nextDepthOffset,\n    one;\n\n  unsigned char\n    bit,\n    byte,\n    color,\n    *lastrow,\n    *one_row,\n    *ptr,\n    version;\n\n  unsigned int\n    transparentIndex;\n\n  unsigned short\n    color16,\n    flags;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  quantize_info=AcquireQuantizeInfo(image_info);\n  flags=0;\n  currentOffset=0;\n  transparentIndex=0;\n  transpix.red=0.0;\n  transpix.green=0.0;\n  transpix.blue=0.0;\n  transpix.alpha=0.0;\n  one=1;\n  version=0;\n  scene=0;\n  do\n  {\n    (void) TransformImageColorspace(image,sRGBColorspace,exception);\n    count=GetNumberColors(image,NULL,exception);\n    for (bits_per_pixel=1;  (one << bits_per_pixel) < count; bits_per_pixel*=2) ;\n    if (bits_per_pixel > 16)\n      bits_per_pixel=16;\n    else\n      if (bits_per_pixel < 16)\n        (void) TransformImageColorspace(image,image->colorspace,exception);\n    if (bits_per_pixel < 8)\n      {\n        (void) TransformImageColorspace(image,GRAYColorspace,exception);\n        (void) SetImageType(image,PaletteType,exception);\n        (void) SortColormapByIntensity(image,exception);\n      }\n    if ((image->storage_class == PseudoClass) && (image->colors > 256))\n      (void) SetImageStorageClass(image,DirectClass,exception);\n    if (image->storage_class == PseudoClass)\n      flags|=PALM_HAS_COLORMAP_FLAG;\n    else\n      flags|=PALM_IS_DIRECT_COLOR;\n    (void) WriteBlobMSBShort(image,(unsigned short) image->columns); /* width */\n    (void) WriteBlobMSBShort(image,(unsigned short) image->rows);  /* height */\n    bytes_per_row=((image->columns+(16/bits_per_pixel-1))/(16/\n      bits_per_pixel))*2;\n    (void) WriteBlobMSBShort(image,(unsigned short) bytes_per_row);\n    if ((image_info->compression == RLECompression) ||\n        (image_info->compression == FaxCompression))\n      flags|=PALM_IS_COMPRESSED_FLAG;\n    (void) WriteBlobMSBShort(image, flags);\n    (void) WriteBlobByte(image,(unsigned char) bits_per_pixel);\n    if (bits_per_pixel > 1)\n      version=1;\n    if ((image_info->compression == RLECompression) ||\n        (image_info->compression == FaxCompression))\n      version=2;\n    (void) WriteBlobByte(image,version);\n    (void) WriteBlobMSBShort(image,0);  /* nextDepthOffset */\n    (void) WriteBlobByte(image,(unsigned char) transparentIndex);\n    if (image_info->compression == RLECompression)\n      (void) WriteBlobByte(image,PALM_COMPRESSION_RLE);\n    else\n      if (image_info->compression == FaxCompression)\n        (void) WriteBlobByte(image,PALM_COMPRESSION_SCANLINE);\n      else\n        (void) WriteBlobByte(image,PALM_COMPRESSION_NONE);\n    (void) WriteBlobMSBShort(image,0);  /* reserved */\n    offset=16;\n    if (bits_per_pixel == 16)\n      {\n        (void) WriteBlobByte(image,5);  /* # of bits of red */\n        (void) WriteBlobByte(image,6);  /* # of bits of green */\n        (void) WriteBlobByte(image,5);  /* # of bits of blue */\n        (void) WriteBlobByte(image,0);  /* reserved by Palm */\n        (void) WriteBlobMSBLong(image,0);  /* no transparent color, YET */\n        offset+=8;\n      }\n    if (bits_per_pixel == 8)\n      {\n        if (flags & PALM_HAS_COLORMAP_FLAG)  /* Write out colormap */\n          {\n            quantize_info->dither_method=IdentifyPaletteImage(image,exception)\n              == MagickFalse ? RiemersmaDitherMethod : NoDitherMethod;\n            quantize_info->number_colors=image->colors;\n            (void) QuantizeImage(quantize_info,image,exception);\n            (void) WriteBlobMSBShort(image,(unsigned short) image->colors);\n            for (count = 0; count < image->colors; count++)\n            {\n              (void) WriteBlobByte(image,(unsigned char) count);\n              (void) WriteBlobByte(image,ScaleQuantumToChar(ClampToQuantum(\n                image->colormap[count].red)));\n              (void) WriteBlobByte(image,ScaleQuantumToChar(ClampToQuantum(\n                image->colormap[count].green)));\n              (void) WriteBlobByte(image,ScaleQuantumToChar(ClampToQuantum(\n                image->colormap[count].blue)));\n            }\n            offset+=2+count*4;\n          }\n      else  /* Map colors to Palm standard colormap */\n        {\n          Image\n            *affinity_image;\n\n          affinity_image=ConstituteImage(256,1,\"RGB\",CharPixel,&PalmPalette,\n            exception);\n          (void) TransformImageColorspace(affinity_image,\n            affinity_image->colorspace,exception);\n          (void) RemapImage(quantize_info,image,affinity_image,exception);\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelIndex(image,(Quantum) FindColor(&image->colormap[(ssize_t)\n                GetPixelIndex(image,q)]),q);\n              q+=GetPixelChannels(image);\n            }\n          }\n          affinity_image=DestroyImage(affinity_image);\n        }\n      }\n    if (flags & PALM_IS_COMPRESSED_FLAG)\n      (void) WriteBlobMSBShort(image,0);  /* fill in size later */\n    lastrow=(unsigned char *) NULL;\n    if (image_info->compression == FaxCompression)\n      lastrow=(unsigned char *) AcquireQuantumMemory(bytes_per_row,\n        sizeof(*lastrow));\n      /* TODO check whether memory really was acquired? */\n    one_row=(unsigned char *) AcquireQuantumMemory(bytes_per_row,\n      sizeof(*one_row));\n    if (one_row == (unsigned char *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      ptr=one_row;\n      (void) ResetMagickMemory(ptr,0,bytes_per_row);\n      p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n      if (p == (const Quantum *) NULL)\n        break;\n      if (bits_per_pixel == 16)\n        {\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            color16=(unsigned short) ((((31*(size_t) GetPixelRed(image,p))/\n              (size_t) QuantumRange) << 11) | (((63*(size_t)\n              GetPixelGreen(image,p))/(size_t) QuantumRange) << 5) |\n              ((31*(size_t) GetPixelBlue(image,p))/(size_t) QuantumRange));\n            if (GetPixelAlpha(image,p) == (Quantum) TransparentAlpha)\n              {\n                transpix.red=(MagickRealType) GetPixelRed(image,p);\n                transpix.green=(MagickRealType) GetPixelGreen(image,p);\n                transpix.blue=(MagickRealType) GetPixelBlue(image,p);\n                transpix.alpha=(MagickRealType) GetPixelAlpha(image,p);\n                flags|=PALM_HAS_TRANSPARENCY_FLAG;\n              }\n            *ptr++=(unsigned char) ((color16 >> 8) & 0xff);\n            *ptr++=(unsigned char) (color16 & 0xff);\n            p+=GetPixelChannels(image);\n          }\n        }\n      else\n        {\n          byte=0x00;\n          bit=(unsigned char) (8-bits_per_pixel);\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            if (bits_per_pixel >= 8)\n              color=(unsigned char) GetPixelIndex(image,p);\n            else\n              color=(unsigned char) (GetPixelIndex(image,p)*\n                ((one << bits_per_pixel)-1)/MagickMax(1*image->colors-1,1));\n            byte|=color << bit;\n            if (bit != 0)\n              bit-=(unsigned char) bits_per_pixel;\n            else\n              {\n                *ptr++=byte;\n                byte=0x00;\n                bit=(unsigned char) (8-bits_per_pixel);\n              }\n            p+=GetPixelChannels(image);\n          }\n          if ((image->columns % (8/bits_per_pixel)) != 0)\n            *ptr++=byte;\n        }\n      if (image_info->compression == RLECompression)\n        {\n          x=0;\n          while (x < (ssize_t) bytes_per_row)\n          {\n            byte=one_row[x];\n            count=1;\n            while ((one_row[++x] == byte) && (count < 255) &&\n                   (x < (ssize_t) bytes_per_row))\n              count++;\n            (void) WriteBlobByte(image,(unsigned char) count);\n            (void) WriteBlobByte(image,(unsigned char) byte);\n          }\n        }\n      else\n        if (image_info->compression == FaxCompression)\n          {\n            char\n              tmpbuf[8],\n              *tptr;\n  \n            for (x = 0;  x < (ssize_t) bytes_per_row;  x += 8)\n            {\n              tptr = tmpbuf;\n              for (bit=0, byte=0; bit < (unsigned char) MagickMin(8,(ssize_t) bytes_per_row-x); bit++)\n              {\n                if ((y == 0) || (lastrow[x + bit] != one_row[x + bit]))\n                  {\n                    byte |= (1 << (7 - bit));\n                    *tptr++ = (char) one_row[x + bit];\n                  }\n              }\n              (void) WriteBlobByte(image, byte);\n              (void) WriteBlob(image,tptr-tmpbuf,(unsigned char *) tmpbuf);\n            }\n            (void) CopyMagickMemory(lastrow,one_row,bytes_per_row);\n          }\n        else\n          (void) WriteBlob(image,bytes_per_row,one_row);\n      }\n    if (flags & PALM_HAS_TRANSPARENCY_FLAG)\n      {\n        offset=SeekBlob(image,currentOffset+6,SEEK_SET);\n        (void) WriteBlobMSBShort(image,flags);\n        offset=SeekBlob(image,currentOffset+12,SEEK_SET);\n        (void) WriteBlobByte(image,(unsigned char) transparentIndex);  /* trans index */\n      }\n    if (bits_per_pixel == 16)\n      {\n        offset=SeekBlob(image,currentOffset+20,SEEK_SET);\n        (void) WriteBlobByte(image,0);  /* reserved by Palm */\n        (void) WriteBlobByte(image,(unsigned char) ((31*transpix.red)/QuantumRange));\n        (void) WriteBlobByte(image,(unsigned char) ((63*transpix.green)/QuantumRange));\n        (void) WriteBlobByte(image,(unsigned char) ((31*transpix.blue)/QuantumRange));\n      }\n    if (flags & PALM_IS_COMPRESSED_FLAG)  /* fill in size now */\n      {\n        offset=SeekBlob(image,currentOffset+offset,SEEK_SET);\n        (void) WriteBlobMSBShort(image,(unsigned short) (GetBlobSize(image)-\n          currentOffset-offset));\n      }\n    if (one_row != (unsigned char *) NULL) \n      one_row=(unsigned char *) RelinquishMagickMemory(one_row);\n    if (lastrow != (unsigned char *) NULL) \n      lastrow=(unsigned char *) RelinquishMagickMemory(lastrow);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    /* padding to 4 byte word */\n    for (cc=(GetBlobSize(image)) % 4; cc > 0; cc--)\n      (void) WriteBlobByte(image,0);\n    /* write nextDepthOffset and return to end of image */\n    offset=SeekBlob(image,currentOffset+10,SEEK_SET);\n    nextDepthOffset=(size_t) ((GetBlobSize(image)-currentOffset)/4);\n    (void) WriteBlobMSBShort(image,(unsigned short) nextDepthOffset);\n    currentOffset=(MagickOffsetType) GetBlobSize(image);\n    offset=SeekBlob(image,currentOffset,SEEK_SET);\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  quantize_info=DestroyQuantizeInfo(quantize_info);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%           QQQ   U   U   AAA   N   N  TTTTT  IIIII   ZZZZZ  EEEEE            %\n%          Q   Q  U   U  A   A  NN  N    T      I        ZZ  E                %\n%          Q   Q  U   U  AAAAA  N N N    T      I      ZZZ   EEEEE            %\n%          Q  QQ  U   U  A   A  N  NN    T      I     ZZ     E                %\n%           QQQQ   UUU   A   A  N   N    T    IIIII   ZZZZZ  EEEEE            %\n%                                                                             %\n%                                                                             %\n%    MagickCore Methods to Reduce the Number of Unique Colors in an Image     %\n%                                                                             %\n%                           Software Design                                   %\n%                                Cristy                                       %\n%                              July 1992                                      %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2017 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://www.imagemagick.org/script/license.php                           %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  Realism in computer graphics typically requires using 24 bits/pixel to\n%  generate an image.  Yet many graphic display devices do not contain the\n%  amount of memory necessary to match the spatial and color resolution of\n%  the human eye.  The Quantize methods takes a 24 bit image and reduces\n%  the number of colors so it can be displayed on raster device with less\n%  bits per pixel.  In most instances, the quantized image closely\n%  resembles the original reference image.\n%\n%  A reduction of colors in an image is also desirable for image\n%  transmission and real-time animation.\n%\n%  QuantizeImage() takes a standard RGB or monochrome images and quantizes\n%  them down to some fixed number of colors.\n%\n%  For purposes of color allocation, an image is a set of n pixels, where\n%  each pixel is a point in RGB space.  RGB space is a 3-dimensional\n%  vector space, and each pixel, Pi,  is defined by an ordered triple of\n%  red, green, and blue coordinates, (Ri, Gi, Bi).\n%\n%  Each primary color component (red, green, or blue) represents an\n%  intensity which varies linearly from 0 to a maximum value, Cmax, which\n%  corresponds to full saturation of that color.  Color allocation is\n%  defined over a domain consisting of the cube in RGB space with opposite\n%  vertices at (0,0,0) and (Cmax, Cmax, Cmax).  QUANTIZE requires Cmax =\n%  255.\n%\n%  The algorithm maps this domain onto a tree in which each node\n%  represents a cube within that domain.  In the following discussion\n%  these cubes are defined by the coordinate of two opposite vertices (vertex\n%  nearest the origin in RGB space and the vertex farthest from the origin).\n%\n%  The tree's root node represents the entire domain, (0,0,0) through\n%  (Cmax,Cmax,Cmax).  Each lower level in the tree is generated by\n%  subdividing one node's cube into eight smaller cubes of equal size.\n%  This corresponds to bisecting the parent cube with planes passing\n%  through the midpoints of each edge.\n%\n%  The basic algorithm operates in three phases: Classification,\n%  Reduction, and Assignment.  Classification builds a color description\n%  tree for the image.  Reduction collapses the tree until the number it\n%  represents, at most, the number of colors desired in the output image.\n%  Assignment defines the output image's color map and sets each pixel's\n%  color by restorage_class in the reduced tree.  Our goal is to minimize\n%  the numerical discrepancies between the original colors and quantized\n%  colors (quantization error).\n%\n%  Classification begins by initializing a color description tree of\n%  sufficient depth to represent each possible input color in a leaf.\n%  However, it is impractical to generate a fully-formed color description\n%  tree in the storage_class phase for realistic values of Cmax.  If\n%  colors components in the input image are quantized to k-bit precision,\n%  so that Cmax= 2k-1, the tree would need k levels below the root node to\n%  allow representing each possible input color in a leaf.  This becomes\n%  prohibitive because the tree's total number of nodes is 1 +\n%  sum(i=1, k, 8k).\n%\n%  A complete tree would require 19,173,961 nodes for k = 8, Cmax = 255.\n%  Therefore, to avoid building a fully populated tree, QUANTIZE: (1)\n%  Initializes data structures for nodes only as they are needed;  (2)\n%  Chooses a maximum depth for the tree as a function of the desired\n%  number of colors in the output image (currently log2(colormap size)).\n%\n%  For each pixel in the input image, storage_class scans downward from\n%  the root of the color description tree.  At each level of the tree it\n%  identifies the single node which represents a cube in RGB space\n%  containing the pixel's color.  It updates the following data for each\n%  such node:\n%\n%    n1: Number of pixels whose color is contained in the RGB cube which\n%    this node represents;\n%\n%    n2: Number of pixels whose color is not represented in a node at\n%    lower depth in the tree;  initially,  n2 = 0 for all nodes except\n%    leaves of the tree.\n%\n%    Sr, Sg, Sb: Sums of the red, green, and blue component values for all\n%    pixels not classified at a lower depth. The combination of these sums\n%    and n2 will ultimately characterize the mean color of a set of\n%    pixels represented by this node.\n%\n%    E: the distance squared in RGB space between each pixel contained\n%    within a node and the nodes' center.  This represents the\n%    quantization error for a node.\n%\n%  Reduction repeatedly prunes the tree until the number of nodes with n2\n%  > 0 is less than or equal to the maximum number of colors allowed in\n%  the output image.  On any given iteration over the tree, it selects\n%  those nodes whose E count is minimal for pruning and merges their color\n%  statistics upward. It uses a pruning threshold, Ep, to govern node\n%  selection as follows:\n%\n%    Ep = 0\n%    while number of nodes with (n2 > 0) > required maximum number of colors\n%      prune all nodes such that E <= Ep\n%      Set Ep to minimum E in remaining nodes\n%\n%  This has the effect of minimizing any quantization error when merging\n%  two nodes together.\n%\n%  When a node to be pruned has offspring, the pruning procedure invokes\n%  itself recursively in order to prune the tree from the leaves upward.\n%  n2,  Sr, Sg,  and  Sb in a node being pruned are always added to the\n%  corresponding data in that node's parent.  This retains the pruned\n%  node's color characteristics for later averaging.\n%\n%  For each node, n2 pixels exist for which that node represents the\n%  smallest volume in RGB space containing those pixel's colors.  When n2\n%  > 0 the node will uniquely define a color in the output image. At the\n%  beginning of reduction,  n2 = 0  for all nodes except a the leaves of\n%  the tree which represent colors present in the input image.\n%\n%  The other pixel count, n1, indicates the total number of colors within\n%  the cubic volume which the node represents.  This includes n1 - n2\n%  pixels whose colors should be defined by nodes at a lower level in the\n%  tree.\n%\n%  Assignment generates the output image from the pruned tree.  The output\n%  image consists of two parts: (1)  A color map, which is an array of\n%  color descriptions (RGB triples) for each color present in the output\n%  image;  (2)  A pixel array, which represents each pixel as an index\n%  into the color map array.\n%\n%  First, the assignment phase makes one pass over the pruned color\n%  description tree to establish the image's color map.  For each node\n%  with n2  > 0, it divides Sr, Sg, and Sb by n2 .  This produces the mean\n%  color of all pixels that classify no lower than this node.  Each of\n%  these colors becomes an entry in the color map.\n%\n%  Finally,  the assignment phase reclassifies each pixel in the pruned\n%  tree to identify the deepest node containing the pixel's color.  The\n%  pixel's value in the pixel array becomes the index of this node's mean\n%  color in the color map.\n%\n%  This method is based on a similar algorithm written by Paul Raveling.\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/cache-view.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/enhance.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/histogram.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/pixel-private.h\"\n#include \"MagickCore/quantize.h\"\n#include \"MagickCore/quantum.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/thread-private.h\"\n\f\n/*\n  Define declarations.\n*/\n#if !defined(__APPLE__) && !defined(TARGET_OS_IPHONE)\n#define CacheShift  2\n#else\n#define CacheShift  3\n#endif\n#define ErrorQueueLength  16\n#define MaxNodes  266817\n#define MaxTreeDepth  8\n#define NodesInAList  1920\n\f\n/*\n  Typdef declarations.\n*/\ntypedef struct _DoublePixelPacket\n{\n  double\n    red,\n    green,\n    blue,\n    alpha;\n} DoublePixelPacket;\n\ntypedef struct _NodeInfo\n{\n  struct _NodeInfo\n    *parent,\n    *child[16];\n\n  MagickSizeType\n    number_unique;\n\n  DoublePixelPacket\n    total_color;\n\n  double\n    quantize_error;\n\n  size_t\n    color_number,\n    id,\n    level;\n} NodeInfo;\n\ntypedef struct _Nodes\n{\n  NodeInfo\n    *nodes;\n\n  struct _Nodes\n    *next;\n} Nodes;\n\ntypedef struct _CubeInfo\n{\n  NodeInfo\n    *root;\n\n  size_t\n    colors,\n    maximum_colors;\n\n  ssize_t\n    transparent_index;\n\n  MagickSizeType\n    transparent_pixels;\n\n  DoublePixelPacket\n    target;\n\n  double\n    distance,\n    pruning_threshold,\n    next_threshold;\n\n  size_t\n    nodes,\n    free_nodes,\n    color_number;\n\n  NodeInfo\n    *next_node;\n\n  Nodes\n    *node_queue;\n\n  MemoryInfo\n    *memory_info;\n\n  ssize_t\n    *cache;\n\n  DoublePixelPacket\n    error[ErrorQueueLength];\n\n  double\n    weights[ErrorQueueLength];\n\n  QuantizeInfo\n    *quantize_info;\n\n  MagickBooleanType\n    associate_alpha;\n\n  ssize_t\n    x,\n    y;\n\n  size_t\n    depth;\n\n  MagickOffsetType\n    offset;\n\n  MagickSizeType\n    span;\n} CubeInfo;\n\f\n/*\n  Method prototypes.\n*/\nstatic CubeInfo\n  *GetCubeInfo(const QuantizeInfo *,const size_t,const size_t);\n\nstatic NodeInfo\n  *GetNodeInfo(CubeInfo *,const size_t,const size_t,NodeInfo *);\n\nstatic MagickBooleanType\n  AssignImageColors(Image *,CubeInfo *,ExceptionInfo *),\n  ClassifyImageColors(CubeInfo *,const Image *,ExceptionInfo *),\n  DitherImage(Image *,CubeInfo *,ExceptionInfo *),\n  SetGrayscaleImage(Image *,ExceptionInfo *);\n\nstatic size_t\n  DefineImageColormap(Image *,CubeInfo *,NodeInfo *);\n\nstatic void\n  ClosestColor(const Image *,CubeInfo *,const NodeInfo *),\n  DestroyCubeInfo(CubeInfo *),\n  PruneLevel(CubeInfo *,const NodeInfo *),\n  PruneToCubeDepth(CubeInfo *,const NodeInfo *),\n  ReduceImageColors(const Image *,CubeInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   A c q u i r e Q u a n t i z e I n f o                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquireQuantizeInfo() allocates the QuantizeInfo structure.\n%\n%  The format of the AcquireQuantizeInfo method is:\n%\n%      QuantizeInfo *AcquireQuantizeInfo(const ImageInfo *image_info)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n*/\nMagickExport QuantizeInfo *AcquireQuantizeInfo(const ImageInfo *image_info)\n{\n  QuantizeInfo\n    *quantize_info;\n\n  quantize_info=(QuantizeInfo *) AcquireMagickMemory(sizeof(*quantize_info));\n  if (quantize_info == (QuantizeInfo *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  GetQuantizeInfo(quantize_info);\n  if (image_info != (ImageInfo *) NULL)\n    {\n      const char\n        *option;\n\n      quantize_info->dither_method=image_info->dither == MagickFalse ?\n        NoDitherMethod : RiemersmaDitherMethod;\n      option=GetImageOption(image_info,\"dither\");\n      if (option != (const char *) NULL)\n        quantize_info->dither_method=(DitherMethod) ParseCommandOption(\n          MagickDitherOptions,MagickFalse,option);\n      quantize_info->measure_error=image_info->verbose;\n    }\n  return(quantize_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   A s s i g n I m a g e C o l o r s                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AssignImageColors() generates the output image from the pruned tree.  The\n%  output image consists of two parts: (1)  A color map, which is an array\n%  of color descriptions (RGB triples) for each color present in the\n%  output image;  (2)  A pixel array, which represents each pixel as an\n%  index into the color map array.\n%\n%  First, the assignment phase makes one pass over the pruned color\n%  description tree to establish the image's color map.  For each node\n%  with n2  > 0, it divides Sr, Sg, and Sb by n2 .  This produces the mean\n%  color of all pixels that classify no lower than this node.  Each of\n%  these colors becomes an entry in the color map.\n%\n%  Finally,  the assignment phase reclassifies each pixel in the pruned\n%  tree to identify the deepest node containing the pixel's color.  The\n%  pixel's value in the pixel array becomes the index of this node's mean\n%  color in the color map.\n%\n%  The format of the AssignImageColors() method is:\n%\n%      MagickBooleanType AssignImageColors(Image *image,CubeInfo *cube_info)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n%    o cube_info: A pointer to the Cube structure.\n%\n*/\n\nstatic inline void AssociateAlphaPixel(const Image *image,\n  const CubeInfo *cube_info,const Quantum *pixel,DoublePixelPacket *alpha_pixel)\n{\n  double\n    alpha;\n\n  if ((cube_info->associate_alpha == MagickFalse) ||\n      (GetPixelAlpha(image,pixel) == OpaqueAlpha))\n    {\n      alpha_pixel->red=(double) GetPixelRed(image,pixel);\n      alpha_pixel->green=(double) GetPixelGreen(image,pixel);\n      alpha_pixel->blue=(double) GetPixelBlue(image,pixel);\n      alpha_pixel->alpha=(double) GetPixelAlpha(image,pixel);\n      return;\n    }\n  alpha=(double) (QuantumScale*GetPixelAlpha(image,pixel));\n  alpha_pixel->red=alpha*GetPixelRed(image,pixel);\n  alpha_pixel->green=alpha*GetPixelGreen(image,pixel);\n  alpha_pixel->blue=alpha*GetPixelBlue(image,pixel);\n  alpha_pixel->alpha=(double) GetPixelAlpha(image,pixel);\n}\n\nstatic inline void AssociateAlphaPixelInfo(const CubeInfo *cube_info,\n  const PixelInfo *pixel,DoublePixelPacket *alpha_pixel)\n{\n  double\n    alpha;\n\n  if ((cube_info->associate_alpha == MagickFalse) ||\n      (pixel->alpha == OpaqueAlpha))\n    {\n      alpha_pixel->red=(double) pixel->red;\n      alpha_pixel->green=(double) pixel->green;\n      alpha_pixel->blue=(double) pixel->blue;\n      alpha_pixel->alpha=(double) pixel->alpha;\n      return;\n    }\n  alpha=(double) (QuantumScale*pixel->alpha);\n  alpha_pixel->red=alpha*pixel->red;\n  alpha_pixel->green=alpha*pixel->green;\n  alpha_pixel->blue=alpha*pixel->blue;\n  alpha_pixel->alpha=(double) pixel->alpha;\n}\n\nstatic inline size_t ColorToNodeId(const CubeInfo *cube_info,\n  const DoublePixelPacket *pixel,size_t index)\n{\n  size_t\n    id;\n\n  id=(size_t) (((ScaleQuantumToChar(ClampPixel(pixel->red)) >> index) & 0x01) |\n    ((ScaleQuantumToChar(ClampPixel(pixel->green)) >> index) & 0x01) << 1 |\n    ((ScaleQuantumToChar(ClampPixel(pixel->blue)) >> index) & 0x01) << 2);\n  if (cube_info->associate_alpha != MagickFalse)\n    id|=((ScaleQuantumToChar(ClampPixel(pixel->alpha)) >> index) & 0x1) << 3;\n  return(id);\n}\n\nstatic MagickBooleanType AssignImageColors(Image *image,CubeInfo *cube_info,\n  ExceptionInfo *exception)\n{\n#define AssignImageTag  \"Assign/Image\"\n\n  ssize_t\n    y;\n\n  /*\n    Allocate image colormap.\n  */\n  if ((cube_info->quantize_info->colorspace != UndefinedColorspace) &&\n      (cube_info->quantize_info->colorspace != CMYKColorspace))\n    (void) TransformImageColorspace(image,cube_info->quantize_info->colorspace,\n      exception);\n  else\n    if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n      (void) TransformImageColorspace(image,sRGBColorspace,exception);\n  if (AcquireImageColormap(image,cube_info->colors,exception) == MagickFalse)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);;\n  image->colors=0;\n  cube_info->transparent_pixels=0;\n  cube_info->transparent_index=(-1);\n  (void) DefineImageColormap(image,cube_info,cube_info->root);\n  /*\n    Create a reduced color image.\n  */\n  if (cube_info->quantize_info->dither_method != NoDitherMethod)\n    (void) DitherImage(image,cube_info,exception);\n  else\n    {\n      CacheView\n        *image_view;\n\n      MagickBooleanType\n        status;\n\n      status=MagickTrue;\n      image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n      #pragma omp parallel for schedule(static,4) shared(status) \\\n        magick_threads(image,image,image->rows,1)\n#endif\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        CubeInfo\n          cube;\n\n        register Quantum\n          *magick_restrict q;\n\n        register ssize_t\n          x;\n\n        ssize_t\n          count;\n\n        if (status == MagickFalse)\n          continue;\n        q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,\n          exception);\n        if (q == (Quantum *) NULL)\n          {\n            status=MagickFalse;\n            continue;\n          }\n        cube=(*cube_info);\n        for (x=0; x < (ssize_t) image->columns; x+=count)\n        {\n          DoublePixelPacket\n            pixel;\n\n          register const NodeInfo\n            *node_info;\n\n          register ssize_t\n            i;\n\n          size_t\n            id,\n            index;\n\n          /*\n            Identify the deepest node containing the pixel's color.\n          */\n          for (count=1; (x+count) < (ssize_t) image->columns; count++)\n          {\n            PixelInfo\n              packet;\n\n            GetPixelInfoPixel(image,q+count*GetPixelChannels(image),&packet);\n            if (IsPixelEquivalent(image,q,&packet) == MagickFalse)\n              break;\n          }\n          AssociateAlphaPixel(image,&cube,q,&pixel);\n          node_info=cube.root;\n          for (index=MaxTreeDepth-1; (ssize_t) index > 0; index--)\n          {\n            id=ColorToNodeId(&cube,&pixel,index);\n            if (node_info->child[id] == (NodeInfo *) NULL)\n              break;\n            node_info=node_info->child[id];\n          }\n          /*\n            Find closest color among siblings and their children.\n          */\n          cube.target=pixel;\n          cube.distance=(double) (4.0*(QuantumRange+1.0)*(QuantumRange+1.0)+\n            1.0);\n          ClosestColor(image,&cube,node_info->parent);\n          index=cube.color_number;\n          for (i=0; i < (ssize_t) count; i++)\n          {\n            if (image->storage_class == PseudoClass)\n              SetPixelIndex(image,(Quantum) index,q);\n            if (cube.quantize_info->measure_error == MagickFalse)\n              {\n                SetPixelRed(image,ClampToQuantum(\n                  image->colormap[index].red),q);\n                SetPixelGreen(image,ClampToQuantum(\n                  image->colormap[index].green),q);\n                SetPixelBlue(image,ClampToQuantum(\n                  image->colormap[index].blue),q);\n                if (cube.associate_alpha != MagickFalse)\n                  SetPixelAlpha(image,ClampToQuantum(\n                    image->colormap[index].alpha),q);\n              }\n            q+=GetPixelChannels(image);\n          }\n        }\n        if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n          status=MagickFalse;\n        if (image->progress_monitor != (MagickProgressMonitor) NULL)\n          {\n            MagickBooleanType\n              proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n            #pragma omp critical (MagickCore_AssignImageColors)\n#endif\n            proceed=SetImageProgress(image,AssignImageTag,(MagickOffsetType) y,\n              image->rows);\n            if (proceed == MagickFalse)\n              status=MagickFalse;\n          }\n      }\n      image_view=DestroyCacheView(image_view);\n    }\n  if (cube_info->quantize_info->measure_error != MagickFalse)\n    (void) GetImageQuantizeError(image,exception);\n  if ((cube_info->quantize_info->number_colors == 2) &&\n      (cube_info->quantize_info->colorspace == GRAYColorspace))\n    {\n      double\n        intensity;\n\n      /*\n        Monochrome image.\n      */\n      intensity=0.0;\n      if ((image->colors > 1) &&\n          (GetPixelInfoLuma(image->colormap+0) >\n           GetPixelInfoLuma(image->colormap+1)))\n        intensity=(double) QuantumRange;\n      image->colormap[0].red=intensity;\n      image->colormap[0].green=intensity;\n      image->colormap[0].blue=intensity;\n      if (image->colors > 1)\n        {\n          image->colormap[1].red=(double) QuantumRange-intensity;\n          image->colormap[1].green=(double) QuantumRange-intensity;\n          image->colormap[1].blue=(double) QuantumRange-intensity;\n        }\n    }\n  (void) SyncImage(image,exception);\n  if ((cube_info->quantize_info->colorspace != UndefinedColorspace) &&\n      (cube_info->quantize_info->colorspace != CMYKColorspace))\n    (void) TransformImageColorspace((Image *) image,sRGBColorspace,exception);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   C l a s s i f y I m a g e C o l o r s                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ClassifyImageColors() begins by initializing a color description tree\n%  of sufficient depth to represent each possible input color in a leaf.\n%  However, it is impractical to generate a fully-formed color\n%  description tree in the storage_class phase for realistic values of\n%  Cmax.  If colors components in the input image are quantized to k-bit\n%  precision, so that Cmax= 2k-1, the tree would need k levels below the\n%  root node to allow representing each possible input color in a leaf.\n%  This becomes prohibitive because the tree's total number of nodes is\n%  1 + sum(i=1,k,8k).\n%\n%  A complete tree would require 19,173,961 nodes for k = 8, Cmax = 255.\n%  Therefore, to avoid building a fully populated tree, QUANTIZE: (1)\n%  Initializes data structures for nodes only as they are needed;  (2)\n%  Chooses a maximum depth for the tree as a function of the desired\n%  number of colors in the output image (currently log2(colormap size)).\n%\n%  For each pixel in the input image, storage_class scans downward from\n%  the root of the color description tree.  At each level of the tree it\n%  identifies the single node which represents a cube in RGB space\n%  containing It updates the following data for each such node:\n%\n%    n1 : Number of pixels whose color is contained in the RGB cube\n%    which this node represents;\n%\n%    n2 : Number of pixels whose color is not represented in a node at\n%    lower depth in the tree;  initially,  n2 = 0 for all nodes except\n%    leaves of the tree.\n%\n%    Sr, Sg, Sb : Sums of the red, green, and blue component values for\n%    all pixels not classified at a lower depth. The combination of\n%    these sums and n2 will ultimately characterize the mean color of a\n%    set of pixels represented by this node.\n%\n%    E: the distance squared in RGB space between each pixel contained\n%    within a node and the nodes' center.  This represents the quantization\n%    error for a node.\n%\n%  The format of the ClassifyImageColors() method is:\n%\n%      MagickBooleanType ClassifyImageColors(CubeInfo *cube_info,\n%        const Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o cube_info: A pointer to the Cube structure.\n%\n%    o image: the image.\n%\n*/\n\nstatic inline void SetAssociatedAlpha(const Image *image,CubeInfo *cube_info)\n{\n  MagickBooleanType\n    associate_alpha;\n\n  associate_alpha=image->alpha_trait == BlendPixelTrait ? MagickTrue :\n    MagickFalse;\n  if ((cube_info->quantize_info->number_colors == 2) &&\n      (cube_info->quantize_info->colorspace == GRAYColorspace))\n    associate_alpha=MagickFalse;\n  cube_info->associate_alpha=associate_alpha;\n}\n\nstatic MagickBooleanType ClassifyImageColors(CubeInfo *cube_info,\n  const Image *image,ExceptionInfo *exception)\n{\n#define ClassifyImageTag  \"Classify/Image\"\n\n  CacheView\n    *image_view;\n\n  DoublePixelPacket\n    error,\n    mid,\n    midpoint,\n    pixel;\n\n  MagickBooleanType\n    proceed;\n\n  double\n    bisect;\n\n  NodeInfo\n    *node_info;\n\n  size_t\n    count,\n    id,\n    index,\n    level;\n\n  ssize_t\n    y;\n\n  /*\n    Classify the first cube_info->maximum_colors colors to a tree depth of 8.\n  */\n  SetAssociatedAlpha(image,cube_info);\n  if ((cube_info->quantize_info->colorspace != UndefinedColorspace) &&\n      (cube_info->quantize_info->colorspace != CMYKColorspace))\n    (void) TransformImageColorspace((Image *) image,\n      cube_info->quantize_info->colorspace,exception);\n  else\n    if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n      (void) TransformImageColorspace((Image *) image,sRGBColorspace,exception);\n  midpoint.red=(double) QuantumRange/2.0;\n  midpoint.green=(double) QuantumRange/2.0;\n  midpoint.blue=(double) QuantumRange/2.0;\n  midpoint.alpha=(double) QuantumRange/2.0;\n  error.alpha=0.0;\n  image_view=AcquireVirtualCacheView(image,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const Quantum\n      *magick_restrict p;\n\n    register ssize_t\n      x;\n\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    if (cube_info->nodes > MaxNodes)\n      {\n        /*\n          Prune one level if the color tree is too large.\n        */\n        PruneLevel(cube_info,cube_info->root);\n        cube_info->depth--;\n      }\n    for (x=0; x < (ssize_t) image->columns; x+=(ssize_t) count)\n    {\n      /*\n        Start at the root and descend the color cube tree.\n      */\n      for (count=1; (x+(ssize_t) count) < (ssize_t) image->columns; count++)\n      {\n        PixelInfo\n          packet;\n\n        GetPixelInfoPixel(image,p+count*GetPixelChannels(image),&packet);\n        if (IsPixelEquivalent(image,p,&packet) == MagickFalse)\n          break;\n      }\n      AssociateAlphaPixel(image,cube_info,p,&pixel);\n      index=MaxTreeDepth-1;\n      bisect=((double) QuantumRange+1.0)/2.0;\n      mid=midpoint;\n      node_info=cube_info->root;\n      for (level=1; level <= MaxTreeDepth; level++)\n      {\n        double\n          distance;\n\n        bisect*=0.5;\n        id=ColorToNodeId(cube_info,&pixel,index);\n        mid.red+=(id & 1) != 0 ? bisect : -bisect;\n        mid.green+=(id & 2) != 0 ? bisect : -bisect;\n        mid.blue+=(id & 4) != 0 ? bisect : -bisect;\n        mid.alpha+=(id & 8) != 0 ? bisect : -bisect;\n        if (node_info->child[id] == (NodeInfo *) NULL)\n          {\n            /*\n              Set colors of new node to contain pixel.\n            */\n            node_info->child[id]=GetNodeInfo(cube_info,id,level,node_info);\n            if (node_info->child[id] == (NodeInfo *) NULL)\n              {\n                (void) ThrowMagickException(exception,GetMagickModule(),\n                  ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\n                  image->filename);\n                continue;\n              }\n            if (level == MaxTreeDepth)\n              cube_info->colors++;\n          }\n        /*\n          Approximate the quantization error represented by this node.\n        */\n        node_info=node_info->child[id];\n        error.red=QuantumScale*(pixel.red-mid.red);\n        error.green=QuantumScale*(pixel.green-mid.green);\n        error.blue=QuantumScale*(pixel.blue-mid.blue);\n        if (cube_info->associate_alpha != MagickFalse)\n          error.alpha=QuantumScale*(pixel.alpha-mid.alpha);\n        distance=(double) (error.red*error.red+error.green*error.green+\n          error.blue*error.blue+error.alpha*error.alpha);\n        if (IsNaN(distance))\n          distance=0.0;\n        node_info->quantize_error+=count*sqrt(distance);\n        cube_info->root->quantize_error+=node_info->quantize_error;\n        index--;\n      }\n      /*\n        Sum RGB for this leaf for later derivation of the mean cube color.\n      */\n      node_info->number_unique+=count;\n      node_info->total_color.red+=count*QuantumScale*ClampPixel(pixel.red);\n      node_info->total_color.green+=count*QuantumScale*ClampPixel(pixel.green);\n      node_info->total_color.blue+=count*QuantumScale*ClampPixel(pixel.blue);\n      if (cube_info->associate_alpha != MagickFalse)\n        node_info->total_color.alpha+=count*QuantumScale*\n          ClampPixel(pixel.alpha);\n      else\n        node_info->total_color.alpha+=count*QuantumScale*\n          ClampPixel(OpaqueAlpha);\n      p+=count*GetPixelChannels(image);\n    }\n    if (cube_info->colors > cube_info->maximum_colors)\n      {\n        PruneToCubeDepth(cube_info,cube_info->root);\n        break;\n      }\n    proceed=SetImageProgress(image,ClassifyImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (proceed == MagickFalse)\n      break;\n  }\n  for (y++; y < (ssize_t) image->rows; y++)\n  {\n    register const Quantum\n      *magick_restrict p;\n\n    register ssize_t\n      x;\n\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    if (cube_info->nodes > MaxNodes)\n      {\n        /*\n          Prune one level if the color tree is too large.\n        */\n        PruneLevel(cube_info,cube_info->root);\n        cube_info->depth--;\n      }\n    for (x=0; x < (ssize_t) image->columns; x+=(ssize_t) count)\n    {\n      /*\n        Start at the root and descend the color cube tree.\n      */\n      for (count=1; (x+(ssize_t) count) < (ssize_t) image->columns; count++)\n      {\n        PixelInfo\n          packet;\n\n        GetPixelInfoPixel(image,p+count*GetPixelChannels(image),&packet);\n        if (IsPixelEquivalent(image,p,&packet) == MagickFalse)\n          break;\n      }\n      AssociateAlphaPixel(image,cube_info,p,&pixel);\n      index=MaxTreeDepth-1;\n      bisect=((double) QuantumRange+1.0)/2.0;\n      mid=midpoint;\n      node_info=cube_info->root;\n      for (level=1; level <= cube_info->depth; level++)\n      {\n        double\n          distance;\n\n        bisect*=0.5;\n        id=ColorToNodeId(cube_info,&pixel,index);\n        mid.red+=(id & 1) != 0 ? bisect : -bisect;\n        mid.green+=(id & 2) != 0 ? bisect : -bisect;\n        mid.blue+=(id & 4) != 0 ? bisect : -bisect;\n        mid.alpha+=(id & 8) != 0 ? bisect : -bisect;\n        if (node_info->child[id] == (NodeInfo *) NULL)\n          {\n            /*\n              Set colors of new node to contain pixel.\n            */\n            node_info->child[id]=GetNodeInfo(cube_info,id,level,node_info);\n            if (node_info->child[id] == (NodeInfo *) NULL)\n              {\n                (void) ThrowMagickException(exception,GetMagickModule(),\n                  ResourceLimitError,\"MemoryAllocationFailed\",\"%s\",\n                  image->filename);\n                continue;\n              }\n            if (level == cube_info->depth)\n              cube_info->colors++;\n          }\n        /*\n          Approximate the quantization error represented by this node.\n        */\n        node_info=node_info->child[id];\n        error.red=QuantumScale*(pixel.red-mid.red);\n        error.green=QuantumScale*(pixel.green-mid.green);\n        error.blue=QuantumScale*(pixel.blue-mid.blue);\n        if (cube_info->associate_alpha != MagickFalse)\n          error.alpha=QuantumScale*(pixel.alpha-mid.alpha);\n        distance=(double) (error.red*error.red+error.green*error.green+\n          error.blue*error.blue+error.alpha*error.alpha);\n        if (IsNaN(distance) != MagickFalse)\n          distance=0.0;\n        node_info->quantize_error+=count*sqrt(distance);\n        cube_info->root->quantize_error+=node_info->quantize_error;\n        index--;\n      }\n      /*\n        Sum RGB for this leaf for later derivation of the mean cube color.\n      */\n      node_info->number_unique+=count;\n      node_info->total_color.red+=count*QuantumScale*ClampPixel(pixel.red);\n      node_info->total_color.green+=count*QuantumScale*ClampPixel(pixel.green);\n      node_info->total_color.blue+=count*QuantumScale*ClampPixel(pixel.blue);\n      if (cube_info->associate_alpha != MagickFalse)\n        node_info->total_color.alpha+=count*QuantumScale*\n          ClampPixel(pixel.alpha);\n      else\n        node_info->total_color.alpha+=count*QuantumScale*\n          ClampPixel(OpaqueAlpha);\n      p+=count*GetPixelChannels(image);\n    }\n    proceed=SetImageProgress(image,ClassifyImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (proceed == MagickFalse)\n      break;\n  }\n  image_view=DestroyCacheView(image_view);\n  if ((cube_info->quantize_info->colorspace != UndefinedColorspace) &&\n      (cube_info->quantize_info->colorspace != CMYKColorspace))\n    (void) TransformImageColorspace((Image *) image,sRGBColorspace,exception);\n  return(y < (ssize_t) image->rows ? MagickFalse : MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C l o n e Q u a n t i z e I n f o                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CloneQuantizeInfo() makes a duplicate of the given quantize info structure,\n%  or if quantize info is NULL, a new one.\n%\n%  The format of the CloneQuantizeInfo method is:\n%\n%      QuantizeInfo *CloneQuantizeInfo(const QuantizeInfo *quantize_info)\n%\n%  A description of each parameter follows:\n%\n%    o clone_info: Method CloneQuantizeInfo returns a duplicate of the given\n%      quantize info, or if image info is NULL a new one.\n%\n%    o quantize_info: a structure of type info.\n%\n*/\nMagickExport QuantizeInfo *CloneQuantizeInfo(const QuantizeInfo *quantize_info)\n{\n  QuantizeInfo\n    *clone_info;\n\n  clone_info=(QuantizeInfo *) AcquireMagickMemory(sizeof(*clone_info));\n  if (clone_info == (QuantizeInfo *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  GetQuantizeInfo(clone_info);\n  if (quantize_info == (QuantizeInfo *) NULL)\n    return(clone_info);\n  clone_info->number_colors=quantize_info->number_colors;\n  clone_info->tree_depth=quantize_info->tree_depth;\n  clone_info->dither_method=quantize_info->dither_method;\n  clone_info->colorspace=quantize_info->colorspace;\n  clone_info->measure_error=quantize_info->measure_error;\n  return(clone_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   C l o s e s t C o l o r                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ClosestColor() traverses the color cube tree at a particular node and\n%  determines which colormap entry best represents the input color.\n%\n%  The format of the ClosestColor method is:\n%\n%      void ClosestColor(const Image *image,CubeInfo *cube_info,\n%        const NodeInfo *node_info)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n%    o cube_info: A pointer to the Cube structure.\n%\n%    o node_info: the address of a structure of type NodeInfo which points to a\n%      node in the color cube tree that is to be pruned.\n%\n*/\nstatic void ClosestColor(const Image *image,CubeInfo *cube_info,\n  const NodeInfo *node_info)\n{\n  register ssize_t\n    i;\n\n  size_t\n    number_children;\n\n  /*\n    Traverse any children.\n  */\n  number_children=cube_info->associate_alpha == MagickFalse ? 8UL : 16UL;\n  for (i=0; i < (ssize_t) number_children; i++)\n    if (node_info->child[i] != (NodeInfo *) NULL)\n      ClosestColor(image,cube_info,node_info->child[i]);\n  if (node_info->number_unique != 0)\n    {\n      double\n        pixel;\n\n      register double\n        alpha,\n        beta,\n        distance;\n\n      register DoublePixelPacket\n        *magick_restrict q;\n\n      register PixelInfo\n        *magick_restrict p;\n\n      /*\n        Determine if this color is \"closest\".\n      */\n      p=image->colormap+node_info->color_number;\n      q=(&cube_info->target);\n      alpha=1.0;\n      beta=1.0;\n      if (cube_info->associate_alpha != MagickFalse)\n        {\n          alpha=(double) (QuantumScale*p->alpha);\n          beta=(double) (QuantumScale*q->alpha);\n        }\n      pixel=alpha*p->red-beta*q->red;\n      distance=pixel*pixel;\n      if (distance <= cube_info->distance)\n        {\n          pixel=alpha*p->green-beta*q->green;\n          distance+=pixel*pixel;\n          if (distance <= cube_info->distance)\n            {\n              pixel=alpha*p->blue-beta*q->blue;\n              distance+=pixel*pixel;\n              if (distance <= cube_info->distance)\n                {\n                  if (cube_info->associate_alpha != MagickFalse)\n                    {\n                      pixel=p->alpha-q->alpha;\n                      distance+=pixel*pixel;\n                    }\n                  if (distance <= cube_info->distance)\n                    {\n                      cube_info->distance=distance;\n                      cube_info->color_number=node_info->color_number;\n                    }\n                }\n            }\n        }\n    }\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C o m p r e s s I m a g e C o l o r m a p                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CompressImageColormap() compresses an image colormap by removing any\n%  duplicate or unused color entries.\n%\n%  The format of the CompressImageColormap method is:\n%\n%      MagickBooleanType CompressImageColormap(Image *image,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType CompressImageColormap(Image *image,\n  ExceptionInfo *exception)\n{\n  QuantizeInfo\n    quantize_info;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->storage_class != PseudoClass)\n    return(MagickFalse);\n  GetQuantizeInfo(&quantize_info);\n  quantize_info.number_colors=image->colors;\n  quantize_info.tree_depth=MaxTreeDepth;\n  return(QuantizeImage(&quantize_info,image,exception));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   D e f i n e I m a g e C o l o r m a p                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DefineImageColormap() traverses the color cube tree and notes each colormap\n%  entry.  A colormap entry is any node in the color cube tree where the\n%  of unique colors is not zero.  DefineImageColormap() returns the number of\n%  colors in the image colormap.\n%\n%  The format of the DefineImageColormap method is:\n%\n%      size_t DefineImageColormap(Image *image,CubeInfo *cube_info,\n%        NodeInfo *node_info)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n%    o cube_info: A pointer to the Cube structure.\n%\n%    o node_info: the address of a structure of type NodeInfo which points to a\n%      node in the color cube tree that is to be pruned.\n%\n*/\nstatic size_t DefineImageColormap(Image *image,CubeInfo *cube_info,\n  NodeInfo *node_info)\n{\n  register ssize_t\n    i;\n\n  size_t\n    number_children;\n\n  /*\n    Traverse any children.\n  */\n  number_children=cube_info->associate_alpha == MagickFalse ? 8UL : 16UL;\n  for (i=0; i < (ssize_t) number_children; i++)\n    if (node_info->child[i] != (NodeInfo *) NULL)\n      (void) DefineImageColormap(image,cube_info,node_info->child[i]);\n  if (node_info->number_unique != 0)\n    {\n      register double\n        alpha;\n\n      register PixelInfo\n        *magick_restrict q;\n\n      /*\n        Colormap entry is defined by the mean color in this cube.\n      */\n      q=image->colormap+image->colors;\n      alpha=(double) ((MagickOffsetType) node_info->number_unique);\n      alpha=PerceptibleReciprocal(alpha);\n      if (cube_info->associate_alpha == MagickFalse)\n        {\n          q->red=(double) ClampToQuantum(alpha*QuantumRange*\n            node_info->total_color.red);\n          q->green=(double) ClampToQuantum(alpha*QuantumRange*\n            node_info->total_color.green);\n          q->blue=(double) ClampToQuantum(alpha*QuantumRange*\n            node_info->total_color.blue);\n          q->alpha=(double) OpaqueAlpha;\n        }\n      else\n        {\n          double\n            opacity;\n\n          opacity=(double) (alpha*QuantumRange*node_info->total_color.alpha);\n          q->alpha=(double) ClampToQuantum(opacity);\n          if (q->alpha == OpaqueAlpha)\n            {\n              q->red=(double) ClampToQuantum(alpha*QuantumRange*\n                node_info->total_color.red);\n              q->green=(double) ClampToQuantum(alpha*QuantumRange*\n                node_info->total_color.green);\n              q->blue=(double) ClampToQuantum(alpha*QuantumRange*\n                node_info->total_color.blue);\n            }\n          else\n            {\n              double\n                gamma;\n\n              gamma=(double) (QuantumScale*q->alpha);\n              gamma=PerceptibleReciprocal(gamma);\n              q->red=(double) ClampToQuantum(alpha*gamma*QuantumRange*\n                node_info->total_color.red);\n              q->green=(double) ClampToQuantum(alpha*gamma*QuantumRange*\n                node_info->total_color.green);\n              q->blue=(double) ClampToQuantum(alpha*gamma*QuantumRange*\n                node_info->total_color.blue);\n              if (node_info->number_unique > cube_info->transparent_pixels)\n                {\n                  cube_info->transparent_pixels=node_info->number_unique;\n                  cube_info->transparent_index=(ssize_t) image->colors;\n                }\n            }\n        }\n      node_info->color_number=image->colors++;\n    }\n  return(image->colors);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   D e s t r o y C u b e I n f o                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyCubeInfo() deallocates memory associated with an image.\n%\n%  The format of the DestroyCubeInfo method is:\n%\n%      DestroyCubeInfo(CubeInfo *cube_info)\n%\n%  A description of each parameter follows:\n%\n%    o cube_info: the address of a structure of type CubeInfo.\n%\n*/\nstatic void DestroyCubeInfo(CubeInfo *cube_info)\n{\n  register Nodes\n    *nodes;\n\n  /*\n    Release color cube tree storage.\n  */\n  do\n  {\n    nodes=cube_info->node_queue->next;\n    cube_info->node_queue->nodes=(NodeInfo *) RelinquishMagickMemory(\n      cube_info->node_queue->nodes);\n    cube_info->node_queue=(Nodes *) RelinquishMagickMemory(\n      cube_info->node_queue);\n    cube_info->node_queue=nodes;\n  } while (cube_info->node_queue != (Nodes *) NULL);\n  if (cube_info->memory_info != (MemoryInfo *) NULL)\n    cube_info->memory_info=RelinquishVirtualMemory(cube_info->memory_info);\n  cube_info->quantize_info=DestroyQuantizeInfo(cube_info->quantize_info);\n  cube_info=(CubeInfo *) RelinquishMagickMemory(cube_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e s t r o y Q u a n t i z e I n f o                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyQuantizeInfo() deallocates memory associated with an QuantizeInfo\n%  structure.\n%\n%  The format of the DestroyQuantizeInfo method is:\n%\n%      QuantizeInfo *DestroyQuantizeInfo(QuantizeInfo *quantize_info)\n%\n%  A description of each parameter follows:\n%\n%    o quantize_info: Specifies a pointer to an QuantizeInfo structure.\n%\n*/\nMagickExport QuantizeInfo *DestroyQuantizeInfo(QuantizeInfo *quantize_info)\n{\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(quantize_info != (QuantizeInfo *) NULL);\n  assert(quantize_info->signature == MagickCoreSignature);\n  quantize_info->signature=(~MagickCoreSignature);\n  quantize_info=(QuantizeInfo *) RelinquishMagickMemory(quantize_info);\n  return(quantize_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   D i t h e r I m a g e                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DitherImage() distributes the difference between an original image and\n%  the corresponding color reduced algorithm to neighboring pixels using\n%  serpentine-scan Floyd-Steinberg error diffusion. DitherImage returns\n%  MagickTrue if the image is dithered otherwise MagickFalse.\n%\n%  The format of the DitherImage method is:\n%\n%      MagickBooleanType DitherImage(Image *image,CubeInfo *cube_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n%    o cube_info: A pointer to the Cube structure.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic DoublePixelPacket **DestroyPixelThreadSet(DoublePixelPacket **pixels)\n{\n  register ssize_t\n    i;\n\n  assert(pixels != (DoublePixelPacket **) NULL);\n  for (i=0; i < (ssize_t) GetMagickResourceLimit(ThreadResource); i++)\n    if (pixels[i] != (DoublePixelPacket *) NULL)\n      pixels[i]=(DoublePixelPacket *) RelinquishMagickMemory(pixels[i]);\n  pixels=(DoublePixelPacket **) RelinquishMagickMemory(pixels);\n  return(pixels);\n}\n\nstatic DoublePixelPacket **AcquirePixelThreadSet(const size_t count)\n{\n  DoublePixelPacket\n    **pixels;\n\n  register ssize_t\n    i;\n\n  size_t\n    number_threads;\n\n  number_threads=(size_t) GetMagickResourceLimit(ThreadResource);\n  pixels=(DoublePixelPacket **) AcquireQuantumMemory(number_threads,\n    sizeof(*pixels));\n  if (pixels == (DoublePixelPacket **) NULL)\n    return((DoublePixelPacket **) NULL);\n  (void) ResetMagickMemory(pixels,0,number_threads*sizeof(*pixels));\n  for (i=0; i < (ssize_t) number_threads; i++)\n  {\n    pixels[i]=(DoublePixelPacket *) AcquireQuantumMemory(count,2*\n      sizeof(**pixels));\n    if (pixels[i] == (DoublePixelPacket *) NULL)\n      return(DestroyPixelThreadSet(pixels));\n  }\n  return(pixels);\n}\n\nstatic inline ssize_t CacheOffset(CubeInfo *cube_info,\n  const DoublePixelPacket *pixel)\n{\n#define RedShift(pixel) (((pixel) >> CacheShift) << (0*(8-CacheShift)))\n#define GreenShift(pixel) (((pixel) >> CacheShift) << (1*(8-CacheShift)))\n#define BlueShift(pixel) (((pixel) >> CacheShift) << (2*(8-CacheShift)))\n#define AlphaShift(pixel) (((pixel) >> CacheShift) << (3*(8-CacheShift)))\n\n  ssize_t\n    offset;\n\n  offset=(ssize_t) (RedShift(ScaleQuantumToChar(ClampPixel(pixel->red))) |\n    GreenShift(ScaleQuantumToChar(ClampPixel(pixel->green))) |\n    BlueShift(ScaleQuantumToChar(ClampPixel(pixel->blue))));\n  if (cube_info->associate_alpha != MagickFalse)\n    offset|=AlphaShift(ScaleQuantumToChar(ClampPixel(pixel->alpha)));\n  return(offset);\n}\n\nstatic MagickBooleanType FloydSteinbergDither(Image *image,CubeInfo *cube_info,\n  ExceptionInfo *exception)\n{\n#define DitherImageTag  \"Dither/Image\"\n\n  CacheView\n    *image_view;\n\n  DoublePixelPacket\n    **pixels;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  /*\n    Distribute quantization error using Floyd-Steinberg.\n  */\n  pixels=AcquirePixelThreadSet(image->columns);\n  if (pixels == (DoublePixelPacket **) NULL)\n    return(MagickFalse);\n  status=MagickTrue;\n  image_view=AcquireAuthenticCacheView(image,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    const int\n      id = GetOpenMPThreadId();\n\n    CubeInfo\n      cube;\n\n    DoublePixelPacket\n      *current,\n      *previous;\n\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    size_t\n      index;\n\n    ssize_t\n      v;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    cube=(*cube_info);\n    current=pixels[id]+(y & 0x01)*image->columns;\n    previous=pixels[id]+((y+1) & 0x01)*image->columns;\n    v=(ssize_t) ((y & 0x01) != 0 ? -1 : 1);\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      DoublePixelPacket\n        color,\n        pixel;\n\n      register ssize_t\n        i;\n\n      ssize_t\n        u;\n\n      u=(y & 0x01) != 0 ? (ssize_t) image->columns-1-x : x;\n      AssociateAlphaPixel(image,&cube,q+u*GetPixelChannels(image),&pixel);\n      if (x > 0)\n        {\n          pixel.red+=7*current[u-v].red/16;\n          pixel.green+=7*current[u-v].green/16;\n          pixel.blue+=7*current[u-v].blue/16;\n          if (cube.associate_alpha != MagickFalse)\n            pixel.alpha+=7*current[u-v].alpha/16;\n        }\n      if (y > 0)\n        {\n          if (x < (ssize_t) (image->columns-1))\n            {\n              pixel.red+=previous[u+v].red/16;\n              pixel.green+=previous[u+v].green/16;\n              pixel.blue+=previous[u+v].blue/16;\n              if (cube.associate_alpha != MagickFalse)\n                pixel.alpha+=previous[u+v].alpha/16;\n            }\n          pixel.red+=5*previous[u].red/16;\n          pixel.green+=5*previous[u].green/16;\n          pixel.blue+=5*previous[u].blue/16;\n          if (cube.associate_alpha != MagickFalse)\n            pixel.alpha+=5*previous[u].alpha/16;\n          if (x > 0)\n            {\n              pixel.red+=3*previous[u-v].red/16;\n              pixel.green+=3*previous[u-v].green/16;\n              pixel.blue+=3*previous[u-v].blue/16;\n              if (cube.associate_alpha != MagickFalse)\n                pixel.alpha+=3*previous[u-v].alpha/16;\n            }\n        }\n      pixel.red=(double) ClampPixel(pixel.red);\n      pixel.green=(double) ClampPixel(pixel.green);\n      pixel.blue=(double) ClampPixel(pixel.blue);\n      if (cube.associate_alpha != MagickFalse)\n        pixel.alpha=(double) ClampPixel(pixel.alpha);\n      i=CacheOffset(&cube,&pixel);\n      if (cube.cache[i] < 0)\n        {\n          register NodeInfo\n            *node_info;\n\n          register size_t\n            node_id;\n\n          /*\n            Identify the deepest node containing the pixel's color.\n          */\n          node_info=cube.root;\n          for (index=MaxTreeDepth-1; (ssize_t) index > 0; index--)\n          {\n            node_id=ColorToNodeId(&cube,&pixel,index);\n            if (node_info->child[node_id] == (NodeInfo *) NULL)\n              break;\n            node_info=node_info->child[node_id];\n          }\n          /*\n            Find closest color among siblings and their children.\n          */\n          cube.target=pixel;\n          cube.distance=(double) (4.0*(QuantumRange+1.0)*(QuantumRange+1.0)+\n            1.0);\n          ClosestColor(image,&cube,node_info->parent);\n          cube.cache[i]=(ssize_t) cube.color_number;\n        }\n      /*\n        Assign pixel to closest colormap entry.\n      */\n      index=(size_t) cube.cache[i];\n      if (image->storage_class == PseudoClass)\n        SetPixelIndex(image,(Quantum) index,q+u*GetPixelChannels(image));\n      if (cube.quantize_info->measure_error == MagickFalse)\n        {\n          SetPixelRed(image,ClampToQuantum(image->colormap[index].red),\n            q+u*GetPixelChannels(image));\n          SetPixelGreen(image,ClampToQuantum(image->colormap[index].green),\n            q+u*GetPixelChannels(image));\n          SetPixelBlue(image,ClampToQuantum(image->colormap[index].blue),\n            q+u*GetPixelChannels(image));\n          if (cube.associate_alpha != MagickFalse)\n            SetPixelAlpha(image,ClampToQuantum(image->colormap[index].alpha),\n              q+u*GetPixelChannels(image));\n        }\n      if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n        status=MagickFalse;\n      /*\n        Store the error.\n      */\n      AssociateAlphaPixelInfo(&cube,image->colormap+index,&color);\n      current[u].red=pixel.red-color.red;\n      current[u].green=pixel.green-color.green;\n      current[u].blue=pixel.blue-color.blue;\n      if (cube.associate_alpha != MagickFalse)\n        current[u].alpha=pixel.alpha-color.alpha;\n      if (image->progress_monitor != (MagickProgressMonitor) NULL)\n        {\n          MagickBooleanType\n            proceed;\n\n          proceed=SetImageProgress(image,DitherImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (proceed == MagickFalse)\n            status=MagickFalse;\n        }\n    }\n  }\n  image_view=DestroyCacheView(image_view);\n  pixels=DestroyPixelThreadSet(pixels);\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType\n  RiemersmaDither(Image *,CacheView *,CubeInfo *,const unsigned int,\n    ExceptionInfo *);\n\nstatic void Riemersma(Image *image,CacheView *image_view,CubeInfo *cube_info,\n  const size_t level,const unsigned int direction,ExceptionInfo *exception)\n{\n  if (level == 1)\n    switch (direction)\n    {\n      case WestGravity:\n      {\n        (void) RiemersmaDither(image,image_view,cube_info,EastGravity,\n          exception);\n        (void) RiemersmaDither(image,image_view,cube_info,SouthGravity,\n          exception);\n        (void) RiemersmaDither(image,image_view,cube_info,WestGravity,\n          exception);\n        break;\n      }\n      case EastGravity:\n      {\n        (void) RiemersmaDither(image,image_view,cube_info,WestGravity,\n          exception);\n        (void) RiemersmaDither(image,image_view,cube_info,NorthGravity,\n          exception);\n        (void) RiemersmaDither(image,image_view,cube_info,EastGravity,\n          exception);\n        break;\n      }\n      case NorthGravity:\n      {\n        (void) RiemersmaDither(image,image_view,cube_info,SouthGravity,\n          exception);\n        (void) RiemersmaDither(image,image_view,cube_info,EastGravity,\n          exception);\n        (void) RiemersmaDither(image,image_view,cube_info,NorthGravity,\n          exception);\n        break;\n      }\n      case SouthGravity:\n      {\n        (void) RiemersmaDither(image,image_view,cube_info,NorthGravity,\n          exception);\n        (void) RiemersmaDither(image,image_view,cube_info,WestGravity,\n          exception);\n        (void) RiemersmaDither(image,image_view,cube_info,SouthGravity,\n          exception);\n        break;\n      }\n      default:\n        break;\n    }\n  else\n    switch (direction)\n    {\n      case WestGravity:\n      {\n        Riemersma(image,image_view,cube_info,level-1,NorthGravity,\n          exception);\n        (void) RiemersmaDither(image,image_view,cube_info,EastGravity,\n          exception);\n        Riemersma(image,image_view,cube_info,level-1,WestGravity,\n          exception);\n        (void) RiemersmaDither(image,image_view,cube_info,SouthGravity,\n          exception);\n        Riemersma(image,image_view,cube_info,level-1,WestGravity,\n          exception);\n        (void) RiemersmaDither(image,image_view,cube_info,WestGravity,\n          exception);\n        Riemersma(image,image_view,cube_info,level-1,SouthGravity,\n          exception);\n        break;\n      }\n      case EastGravity:\n      {\n        Riemersma(image,image_view,cube_info,level-1,SouthGravity,\n          exception);\n        (void) RiemersmaDither(image,image_view,cube_info,WestGravity,\n          exception);\n        Riemersma(image,image_view,cube_info,level-1,EastGravity,\n          exception);\n        (void) RiemersmaDither(image,image_view,cube_info,NorthGravity,\n          exception);\n        Riemersma(image,image_view,cube_info,level-1,EastGravity,\n          exception);\n        (void) RiemersmaDither(image,image_view,cube_info,EastGravity,\n          exception);\n        Riemersma(image,image_view,cube_info,level-1,NorthGravity,\n          exception);\n        break;\n      }\n      case NorthGravity:\n      {\n        Riemersma(image,image_view,cube_info,level-1,WestGravity,\n          exception);\n        (void) RiemersmaDither(image,image_view,cube_info,SouthGravity,\n          exception);\n        Riemersma(image,image_view,cube_info,level-1,NorthGravity,\n          exception);\n        (void) RiemersmaDither(image,image_view,cube_info,EastGravity,\n          exception);\n        Riemersma(image,image_view,cube_info,level-1,NorthGravity,\n          exception);\n        (void) RiemersmaDither(image,image_view,cube_info,NorthGravity,\n          exception);\n        Riemersma(image,image_view,cube_info,level-1,EastGravity,\n          exception);\n        break;\n      }\n      case SouthGravity:\n      {\n        Riemersma(image,image_view,cube_info,level-1,EastGravity,\n          exception);\n        (void) RiemersmaDither(image,image_view,cube_info,NorthGravity,\n          exception);\n        Riemersma(image,image_view,cube_info,level-1,SouthGravity,\n          exception);\n        (void) RiemersmaDither(image,image_view,cube_info,WestGravity,\n          exception);\n        Riemersma(image,image_view,cube_info,level-1,SouthGravity,\n          exception);\n        (void) RiemersmaDither(image,image_view,cube_info,SouthGravity,\n          exception);\n        Riemersma(image,image_view,cube_info,level-1,WestGravity,\n          exception);\n        break;\n      }\n      default:\n        break;\n    }\n}\n\nstatic MagickBooleanType RiemersmaDither(Image *image,CacheView *image_view,\n  CubeInfo *cube_info,const unsigned int direction,ExceptionInfo *exception)\n{\n#define DitherImageTag  \"Dither/Image\"\n\n  DoublePixelPacket\n    color,\n    pixel;\n\n  MagickBooleanType\n    proceed;\n\n  register CubeInfo\n    *p;\n\n  size_t\n    index;\n\n  p=cube_info;\n  if ((p->x >= 0) && (p->x < (ssize_t) image->columns) &&\n      (p->y >= 0) && (p->y < (ssize_t) image->rows))\n    {\n      register Quantum\n        *magick_restrict q;\n\n      register ssize_t\n        i;\n\n      /*\n        Distribute error.\n      */\n      q=GetCacheViewAuthenticPixels(image_view,p->x,p->y,1,1,exception);\n      if (q == (Quantum *) NULL)\n        return(MagickFalse);\n      AssociateAlphaPixel(image,cube_info,q,&pixel);\n      for (i=0; i < ErrorQueueLength; i++)\n      {\n        pixel.red+=p->weights[i]*p->error[i].red;\n        pixel.green+=p->weights[i]*p->error[i].green;\n        pixel.blue+=p->weights[i]*p->error[i].blue;\n        if (cube_info->associate_alpha != MagickFalse)\n          pixel.alpha+=p->weights[i]*p->error[i].alpha;\n      }\n      pixel.red=(double) ClampPixel(pixel.red);\n      pixel.green=(double) ClampPixel(pixel.green);\n      pixel.blue=(double) ClampPixel(pixel.blue);\n      if (cube_info->associate_alpha != MagickFalse)\n        pixel.alpha=(double) ClampPixel(pixel.alpha);\n      i=CacheOffset(cube_info,&pixel);\n      if (p->cache[i] < 0)\n        {\n          register NodeInfo\n            *node_info;\n\n          register size_t\n            id;\n\n          /*\n            Identify the deepest node containing the pixel's color.\n          */\n          node_info=p->root;\n          for (index=MaxTreeDepth-1; (ssize_t) index > 0; index--)\n          {\n            id=ColorToNodeId(cube_info,&pixel,index);\n            if (node_info->child[id] == (NodeInfo *) NULL)\n              break;\n            node_info=node_info->child[id];\n          }\n          /*\n            Find closest color among siblings and their children.\n          */\n          p->target=pixel;\n          p->distance=(double) (4.0*(QuantumRange+1.0)*((double)\n            QuantumRange+1.0)+1.0);\n          ClosestColor(image,p,node_info->parent);\n          p->cache[i]=(ssize_t) p->color_number;\n        }\n      /*\n        Assign pixel to closest colormap entry.\n      */\n      index=(size_t) p->cache[i];\n      if (image->storage_class == PseudoClass)\n        SetPixelIndex(image,(Quantum) index,q);\n      if (cube_info->quantize_info->measure_error == MagickFalse)\n        {\n          SetPixelRed(image,ClampToQuantum(image->colormap[index].red),q);\n          SetPixelGreen(image,ClampToQuantum(image->colormap[index].green),q);\n          SetPixelBlue(image,ClampToQuantum(image->colormap[index].blue),q);\n          if (cube_info->associate_alpha != MagickFalse)\n            SetPixelAlpha(image,ClampToQuantum(image->colormap[index].alpha),q);\n        }\n      if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n        return(MagickFalse);\n      /*\n        Propagate the error as the last entry of the error queue.\n      */\n      (void) CopyMagickMemory(p->error,p->error+1,(ErrorQueueLength-1)*\n        sizeof(p->error[0]));\n      AssociateAlphaPixelInfo(cube_info,image->colormap+index,&color);\n      p->error[ErrorQueueLength-1].red=pixel.red-color.red;\n      p->error[ErrorQueueLength-1].green=pixel.green-color.green;\n      p->error[ErrorQueueLength-1].blue=pixel.blue-color.blue;\n      if (cube_info->associate_alpha != MagickFalse)\n        p->error[ErrorQueueLength-1].alpha=pixel.alpha-color.alpha;\n      proceed=SetImageProgress(image,DitherImageTag,p->offset,p->span);\n      if (proceed == MagickFalse)\n        return(MagickFalse);\n      p->offset++;\n    }\n  switch (direction)\n  {\n    case WestGravity: p->x--; break;\n    case EastGravity: p->x++; break;\n    case NorthGravity: p->y--; break;\n    case SouthGravity: p->y++; break;\n  }\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType DitherImage(Image *image,CubeInfo *cube_info,\n  ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  size_t\n    depth;\n\n  if (cube_info->quantize_info->dither_method != RiemersmaDitherMethod)\n    return(FloydSteinbergDither(image,cube_info,exception));\n  /*\n    Distribute quantization error along a Hilbert curve.\n  */\n  (void) ResetMagickMemory(cube_info->error,0,ErrorQueueLength*\n    sizeof(*cube_info->error));\n  cube_info->x=0;\n  cube_info->y=0;\n  i=MagickMax((ssize_t) image->columns,(ssize_t) image->rows);\n  for (depth=1; i != 0; depth++)\n    i>>=1;\n  if ((ssize_t) (1L << depth) < MagickMax((ssize_t) image->columns,(ssize_t) image->rows))\n    depth++;\n  cube_info->offset=0;\n  cube_info->span=(MagickSizeType) image->columns*image->rows;\n  image_view=AcquireAuthenticCacheView(image,exception);\n  if (depth > 1)\n    Riemersma(image,image_view,cube_info,depth-1,NorthGravity,exception);\n  status=RiemersmaDither(image,image_view,cube_info,ForgetGravity,exception);\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t C u b e I n f o                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetCubeInfo() initialize the Cube data structure.\n%\n%  The format of the GetCubeInfo method is:\n%\n%      CubeInfo GetCubeInfo(const QuantizeInfo *quantize_info,\n%        const size_t depth,const size_t maximum_colors)\n%\n%  A description of each parameter follows.\n%\n%    o quantize_info: Specifies a pointer to an QuantizeInfo structure.\n%\n%    o depth: Normally, this integer value is zero or one.  A zero or\n%      one tells Quantize to choose a optimal tree depth of Log4(number_colors).\n%      A tree of this depth generally allows the best representation of the\n%      reference image with the least amount of memory and the fastest\n%      computational speed.  In some cases, such as an image with low color\n%      dispersion (a few number of colors), a value other than\n%      Log4(number_colors) is required.  To expand the color tree completely,\n%      use a value of 8.\n%\n%    o maximum_colors: maximum colors.\n%\n*/\nstatic CubeInfo *GetCubeInfo(const QuantizeInfo *quantize_info,\n  const size_t depth,const size_t maximum_colors)\n{\n  CubeInfo\n    *cube_info;\n\n  double\n    sum,\n    weight;\n\n  register ssize_t\n    i;\n\n  size_t\n    length;\n\n  /*\n    Initialize tree to describe color cube_info.\n  */\n  cube_info=(CubeInfo *) AcquireMagickMemory(sizeof(*cube_info));\n  if (cube_info == (CubeInfo *) NULL)\n    return((CubeInfo *) NULL);\n  (void) ResetMagickMemory(cube_info,0,sizeof(*cube_info));\n  cube_info->depth=depth;\n  if (cube_info->depth > MaxTreeDepth)\n    cube_info->depth=MaxTreeDepth;\n  if (cube_info->depth < 2)\n    cube_info->depth=2;\n  cube_info->maximum_colors=maximum_colors;\n  /*\n    Initialize root node.\n  */\n  cube_info->root=GetNodeInfo(cube_info,0,0,(NodeInfo *) NULL);\n  if (cube_info->root == (NodeInfo *) NULL)\n    return((CubeInfo *) NULL);\n  cube_info->root->parent=cube_info->root;\n  cube_info->quantize_info=CloneQuantizeInfo(quantize_info);\n  if (cube_info->quantize_info->dither_method == NoDitherMethod)\n    return(cube_info);\n  /*\n    Initialize dither resources.\n  */\n  length=(size_t) (1UL << (4*(8-CacheShift)));\n  cube_info->memory_info=AcquireVirtualMemory(length,sizeof(*cube_info->cache));\n  if (cube_info->memory_info == (MemoryInfo *) NULL)\n    return((CubeInfo *) NULL);\n  cube_info->cache=(ssize_t *) GetVirtualMemoryBlob(cube_info->memory_info);\n  /*\n    Initialize color cache.\n  */\n  (void) ResetMagickMemory(cube_info->cache,(-1),sizeof(*cube_info->cache)*\n    length);\n  /*\n    Distribute weights along a curve of exponential decay.\n  */\n  weight=1.0;\n  for (i=0; i < ErrorQueueLength; i++)\n  {\n    cube_info->weights[ErrorQueueLength-i-1]=PerceptibleReciprocal(weight);\n    weight*=exp(log(((double) QuantumRange+1.0))/(ErrorQueueLength-1.0));\n  }\n  /*\n    Normalize the weighting factors.\n  */\n  weight=0.0;\n  for (i=0; i < ErrorQueueLength; i++)\n    weight+=cube_info->weights[i];\n  sum=0.0;\n  for (i=0; i < ErrorQueueLength; i++)\n  {\n    cube_info->weights[i]/=weight;\n    sum+=cube_info->weights[i];\n  }\n  cube_info->weights[0]+=1.0-sum;\n  return(cube_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t N o d e I n f o                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetNodeInfo() allocates memory for a new node in the color cube tree and\n%  presets all fields to zero.\n%\n%  The format of the GetNodeInfo method is:\n%\n%      NodeInfo *GetNodeInfo(CubeInfo *cube_info,const size_t id,\n%        const size_t level,NodeInfo *parent)\n%\n%  A description of each parameter follows.\n%\n%    o node: The GetNodeInfo method returns a pointer to a queue of nodes.\n%\n%    o id: Specifies the child number of the node.\n%\n%    o level: Specifies the level in the storage_class the node resides.\n%\n*/\nstatic NodeInfo *GetNodeInfo(CubeInfo *cube_info,const size_t id,\n  const size_t level,NodeInfo *parent)\n{\n  NodeInfo\n    *node_info;\n\n  if (cube_info->free_nodes == 0)\n    {\n      Nodes\n        *nodes;\n\n      /*\n        Allocate a new queue of nodes.\n      */\n      nodes=(Nodes *) AcquireMagickMemory(sizeof(*nodes));\n      if (nodes == (Nodes *) NULL)\n        return((NodeInfo *) NULL);\n      nodes->nodes=(NodeInfo *) AcquireQuantumMemory(NodesInAList,\n        sizeof(*nodes->nodes));\n      if (nodes->nodes == (NodeInfo *) NULL)\n        return((NodeInfo *) NULL);\n      nodes->next=cube_info->node_queue;\n      cube_info->node_queue=nodes;\n      cube_info->next_node=nodes->nodes;\n      cube_info->free_nodes=NodesInAList;\n    }\n  cube_info->nodes++;\n  cube_info->free_nodes--;\n  node_info=cube_info->next_node++;\n  (void) ResetMagickMemory(node_info,0,sizeof(*node_info));\n  node_info->parent=parent;\n  node_info->id=id;\n  node_info->level=level;\n  return(node_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%  G e t I m a g e Q u a n t i z e E r r o r                                  %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageQuantizeError() measures the difference between the original\n%  and quantized images.  This difference is the total quantization error.\n%  The error is computed by summing over all pixels in an image the distance\n%  squared in RGB space between each reference pixel value and its quantized\n%  value.  These values are computed:\n%\n%    o mean_error_per_pixel:  This value is the mean error for any single\n%      pixel in the image.\n%\n%    o normalized_mean_square_error:  This value is the normalized mean\n%      quantization error for any single pixel in the image.  This distance\n%      measure is normalized to a range between 0 and 1.  It is independent\n%      of the range of red, green, and blue values in the image.\n%\n%    o normalized_maximum_square_error:  Thsi value is the normalized\n%      maximum quantization error for any single pixel in the image.  This\n%      distance measure is normalized to a range between 0 and 1.  It is\n%      independent of the range of red, green, and blue values in your image.\n%\n%  The format of the GetImageQuantizeError method is:\n%\n%      MagickBooleanType GetImageQuantizeError(Image *image,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType GetImageQuantizeError(Image *image,\n  ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  double\n    alpha,\n    area,\n    beta,\n    distance,\n    maximum_error,\n    mean_error,\n    mean_error_per_pixel;\n\n  size_t\n    index;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  image->total_colors=GetNumberColors(image,(FILE *) NULL,exception);\n  (void) ResetMagickMemory(&image->error,0,sizeof(image->error));\n  if (image->storage_class == DirectClass)\n    return(MagickTrue);\n  alpha=1.0;\n  beta=1.0;\n  area=3.0*image->columns*image->rows;\n  maximum_error=0.0;\n  mean_error_per_pixel=0.0;\n  mean_error=0.0;\n  image_view=AcquireVirtualCacheView(image,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const Quantum\n      *magick_restrict p;\n\n    register ssize_t\n      x;\n\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      index=GetPixelIndex(image,p);\n      if (image->alpha_trait == BlendPixelTrait)\n        {\n          alpha=(double) (QuantumScale*GetPixelAlpha(image,p));\n          beta=(double) (QuantumScale*image->colormap[index].alpha);\n        }\n      distance=fabs((double) (alpha*GetPixelRed(image,p)-beta*\n        image->colormap[index].red));\n      mean_error_per_pixel+=distance;\n      mean_error+=distance*distance;\n      if (distance > maximum_error)\n        maximum_error=distance;\n      distance=fabs((double) (alpha*GetPixelGreen(image,p)-beta*\n        image->colormap[index].green));\n      mean_error_per_pixel+=distance;\n      mean_error+=distance*distance;\n      if (distance > maximum_error)\n        maximum_error=distance;\n      distance=fabs((double) (alpha*GetPixelBlue(image,p)-beta*\n        image->colormap[index].blue));\n      mean_error_per_pixel+=distance;\n      mean_error+=distance*distance;\n      if (distance > maximum_error)\n        maximum_error=distance;\n      p+=GetPixelChannels(image);\n    }\n  }\n  image_view=DestroyCacheView(image_view);\n  image->error.mean_error_per_pixel=(double) mean_error_per_pixel/area;\n  image->error.normalized_mean_error=(double) QuantumScale*QuantumScale*\n    mean_error/area;\n  image->error.normalized_maximum_error=(double) QuantumScale*maximum_error;\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t Q u a n t i z e I n f o                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetQuantizeInfo() initializes the QuantizeInfo structure.\n%\n%  The format of the GetQuantizeInfo method is:\n%\n%      GetQuantizeInfo(QuantizeInfo *quantize_info)\n%\n%  A description of each parameter follows:\n%\n%    o quantize_info: Specifies a pointer to a QuantizeInfo structure.\n%\n*/\nMagickExport void GetQuantizeInfo(QuantizeInfo *quantize_info)\n{\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(quantize_info != (QuantizeInfo *) NULL);\n  (void) ResetMagickMemory(quantize_info,0,sizeof(*quantize_info));\n  quantize_info->number_colors=256;\n  quantize_info->dither_method=RiemersmaDitherMethod;\n  quantize_info->colorspace=UndefinedColorspace;\n  quantize_info->measure_error=MagickFalse;\n  quantize_info->signature=MagickCoreSignature;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     P o s t e r i z e I m a g e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  PosterizeImage() reduces the image to a limited number of colors for a\n%  \"poster\" effect.\n%\n%  The format of the PosterizeImage method is:\n%\n%      MagickBooleanType PosterizeImage(Image *image,const size_t levels,\n%        const DitherMethod dither_method,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: Specifies a pointer to an Image structure.\n%\n%    o levels: Number of color levels allowed in each channel.  Very low values\n%      (2, 3, or 4) have the most visible effect.\n%\n%    o dither_method: choose from UndefinedDitherMethod, NoDitherMethod,\n%      RiemersmaDitherMethod, FloydSteinbergDitherMethod.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline double MagickRound(double x)\n{\n  /*\n    Round the fraction to nearest integer.\n  */\n  if ((x-floor(x)) < (ceil(x)-x))\n    return(floor(x));\n  return(ceil(x));\n}\n\nMagickExport MagickBooleanType PosterizeImage(Image *image,const size_t levels,\n  const DitherMethod dither_method,ExceptionInfo *exception)\n{\n#define PosterizeImageTag  \"Posterize/Image\"\n#define PosterizePixel(pixel) (Quantum) (QuantumRange*(MagickRound( \\\n  QuantumScale*pixel*(levels-1)))/MagickMax((ssize_t) levels-1,1))\n\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  QuantizeInfo\n    *quantize_info;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if (image->storage_class == PseudoClass)\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n    #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n      magick_threads(image,image,1,1)\n#endif\n    for (i=0; i < (ssize_t) image->colors; i++)\n    {\n      /*\n        Posterize colormap.\n      */\n      if ((GetPixelRedTraits(image) & UpdatePixelTrait) != 0)\n        image->colormap[i].red=(double)\n          PosterizePixel(image->colormap[i].red);\n      if ((GetPixelGreenTraits(image) & UpdatePixelTrait) != 0)\n        image->colormap[i].green=(double)\n          PosterizePixel(image->colormap[i].green);\n      if ((GetPixelBlueTraits(image) & UpdatePixelTrait) != 0)\n        image->colormap[i].blue=(double)\n          PosterizePixel(image->colormap[i].blue);\n      if ((GetPixelAlphaTraits(image) & UpdatePixelTrait) != 0)\n        image->colormap[i].alpha=(double)\n          PosterizePixel(image->colormap[i].alpha);\n    }\n  /*\n    Posterize image.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if ((GetPixelRedTraits(image) & UpdatePixelTrait) != 0)\n        SetPixelRed(image,PosterizePixel(GetPixelRed(image,q)),q);\n      if ((GetPixelGreenTraits(image) & UpdatePixelTrait) != 0)\n        SetPixelGreen(image,PosterizePixel(GetPixelGreen(image,q)),q);\n      if ((GetPixelBlueTraits(image) & UpdatePixelTrait) != 0)\n        SetPixelBlue(image,PosterizePixel(GetPixelBlue(image,q)),q);\n      if (((GetPixelBlackTraits(image) & UpdatePixelTrait) != 0) &&\n          (image->colorspace == CMYKColorspace))\n        SetPixelBlack(image,PosterizePixel(GetPixelBlack(image,q)),q);\n      if (((GetPixelAlphaTraits(image) & UpdatePixelTrait) != 0) &&\n          (image->alpha_trait == BlendPixelTrait))\n        SetPixelAlpha(image,PosterizePixel(GetPixelAlpha(image,q)),q);\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_PosterizeImage)\n#endif\n        proceed=SetImageProgress(image,PosterizeImageTag,progress++,\n          image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  quantize_info=AcquireQuantizeInfo((ImageInfo *) NULL);\n  quantize_info->number_colors=(size_t) MagickMin((ssize_t) levels*levels*\n    levels,MaxColormapSize+1);\n  quantize_info->dither_method=dither_method;\n  quantize_info->tree_depth=MaxTreeDepth;\n  status=QuantizeImage(quantize_info,image,exception);\n  quantize_info=DestroyQuantizeInfo(quantize_info);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   P r u n e C h i l d                                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  PruneChild() deletes the given node and merges its statistics into its\n%  parent.\n%\n%  The format of the PruneSubtree method is:\n%\n%      PruneChild(CubeInfo *cube_info,const NodeInfo *node_info)\n%\n%  A description of each parameter follows.\n%\n%    o cube_info: A pointer to the Cube structure.\n%\n%    o node_info: pointer to node in color cube tree that is to be pruned.\n%\n*/\nstatic void PruneChild(CubeInfo *cube_info,const NodeInfo *node_info)\n{\n  NodeInfo\n    *parent;\n\n  register ssize_t\n    i;\n\n  size_t\n    number_children;\n\n  /*\n    Traverse any children.\n  */\n  number_children=cube_info->associate_alpha == MagickFalse ? 8UL : 16UL;\n  for (i=0; i < (ssize_t) number_children; i++)\n    if (node_info->child[i] != (NodeInfo *) NULL)\n      PruneChild(cube_info,node_info->child[i]);\n  /*\n    Merge color statistics into parent.\n  */\n  parent=node_info->parent;\n  parent->number_unique+=node_info->number_unique;\n  parent->total_color.red+=node_info->total_color.red;\n  parent->total_color.green+=node_info->total_color.green;\n  parent->total_color.blue+=node_info->total_color.blue;\n  parent->total_color.alpha+=node_info->total_color.alpha;\n  parent->child[node_info->id]=(NodeInfo *) NULL;\n  cube_info->nodes--;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  P r u n e L e v e l                                                        %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  PruneLevel() deletes all nodes at the bottom level of the color tree merging\n%  their color statistics into their parent node.\n%\n%  The format of the PruneLevel method is:\n%\n%      PruneLevel(CubeInfo *cube_info,const NodeInfo *node_info)\n%\n%  A description of each parameter follows.\n%\n%    o cube_info: A pointer to the Cube structure.\n%\n%    o node_info: pointer to node in color cube tree that is to be pruned.\n%\n*/\nstatic void PruneLevel(CubeInfo *cube_info,const NodeInfo *node_info)\n{\n  register ssize_t\n    i;\n\n  size_t\n    number_children;\n\n  /*\n    Traverse any children.\n  */\n  number_children=cube_info->associate_alpha == MagickFalse ? 8UL : 16UL;\n  for (i=0; i < (ssize_t) number_children; i++)\n    if (node_info->child[i] != (NodeInfo *) NULL)\n      PruneLevel(cube_info,node_info->child[i]);\n  if (node_info->level == cube_info->depth)\n    PruneChild(cube_info,node_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  P r u n e T o C u b e D e p t h                                            %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  PruneToCubeDepth() deletes any nodes at a depth greater than\n%  cube_info->depth while merging their color statistics into their parent\n%  node.\n%\n%  The format of the PruneToCubeDepth method is:\n%\n%      PruneToCubeDepth(CubeInfo *cube_info,const NodeInfo *node_info)\n%\n%  A description of each parameter follows.\n%\n%    o cube_info: A pointer to the Cube structure.\n%\n%    o node_info: pointer to node in color cube tree that is to be pruned.\n%\n*/\nstatic void PruneToCubeDepth(CubeInfo *cube_info,const NodeInfo *node_info)\n{\n  register ssize_t\n    i;\n\n  size_t\n    number_children;\n\n  /*\n    Traverse any children.\n  */\n  number_children=cube_info->associate_alpha == MagickFalse ? 8UL : 16UL;\n  for (i=0; i < (ssize_t) number_children; i++)\n    if (node_info->child[i] != (NodeInfo *) NULL)\n      PruneToCubeDepth(cube_info,node_info->child[i]);\n  if (node_info->level > cube_info->depth)\n    PruneChild(cube_info,node_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%  Q u a n t i z e I m a g e                                                  %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  QuantizeImage() analyzes the colors within a reference image and chooses a\n%  fixed number of colors to represent the image.  The goal of the algorithm\n%  is to minimize the color difference between the input and output image while\n%  minimizing the processing time.\n%\n%  The format of the QuantizeImage method is:\n%\n%      MagickBooleanType QuantizeImage(const QuantizeInfo *quantize_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o quantize_info: Specifies a pointer to an QuantizeInfo structure.\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType QuantizeImage(const QuantizeInfo *quantize_info,\n  Image *image,ExceptionInfo *exception)\n{\n  CubeInfo\n    *cube_info;\n\n  MagickBooleanType\n    status;\n\n  size_t\n    depth,\n    maximum_colors;\n\n  assert(quantize_info != (const QuantizeInfo *) NULL);\n  assert(quantize_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  maximum_colors=quantize_info->number_colors;\n  if (maximum_colors == 0)\n    maximum_colors=MaxColormapSize;\n  if (maximum_colors > MaxColormapSize)\n    maximum_colors=MaxColormapSize;\n  if (image->alpha_trait != BlendPixelTrait)\n    {\n      if (SetImageGray(image,exception) != MagickFalse)\n        (void) SetGrayscaleImage(image,exception);\n    }\n  if ((image->storage_class == PseudoClass) &&\n      (image->colors <= maximum_colors))\n    {\n      if ((quantize_info->colorspace != UndefinedColorspace) &&\n          (quantize_info->colorspace != CMYKColorspace))\n        (void) TransformImageColorspace(image,quantize_info->colorspace,\n          exception);\n      return(MagickTrue);\n    }\n  depth=quantize_info->tree_depth;\n  if (depth == 0)\n    {\n      size_t\n        colors;\n\n      /*\n        Depth of color tree is: Log4(colormap size)+2.\n      */\n      colors=maximum_colors;\n      for (depth=1; colors != 0; depth++)\n        colors>>=2;\n      if ((quantize_info->dither_method != NoDitherMethod) && (depth > 2))\n        depth--;\n      if ((image->alpha_trait == BlendPixelTrait) && (depth > 5))\n        depth--;\n      if (SetImageGray(image,exception) != MagickFalse)\n        depth=MaxTreeDepth;\n    }\n  /*\n    Initialize color cube.\n  */\n  cube_info=GetCubeInfo(quantize_info,depth,maximum_colors);\n  if (cube_info == (CubeInfo *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  status=ClassifyImageColors(cube_info,image,exception);\n  if (status != MagickFalse)\n    {\n      /*\n        Reduce the number of colors in the image if it contains more than the\n        maximum, otherwise we can disable dithering to improve the performance.\n      */\n      if (cube_info->colors > cube_info->maximum_colors)\n        ReduceImageColors(image,cube_info);\n      else\n        cube_info->quantize_info->dither_method=NoDitherMethod;\n      status=AssignImageColors(image,cube_info,exception);\n    }\n  DestroyCubeInfo(cube_info);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   Q u a n t i z e I m a g e s                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  QuantizeImages() analyzes the colors within a set of reference images and\n%  chooses a fixed number of colors to represent the set.  The goal of the\n%  algorithm is to minimize the color difference between the input and output\n%  images while minimizing the processing time.\n%\n%  The format of the QuantizeImages method is:\n%\n%      MagickBooleanType QuantizeImages(const QuantizeInfo *quantize_info,\n%        Image *images,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o quantize_info: Specifies a pointer to an QuantizeInfo structure.\n%\n%    o images: Specifies a pointer to a list of Image structures.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType QuantizeImages(const QuantizeInfo *quantize_info,\n  Image *images,ExceptionInfo *exception)\n{\n  CubeInfo\n    *cube_info;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    proceed,\n    status;\n\n  MagickProgressMonitor\n    progress_monitor;\n\n  register ssize_t\n    i;\n\n  size_t\n    depth,\n    maximum_colors,\n    number_images;\n\n  assert(quantize_info != (const QuantizeInfo *) NULL);\n  assert(quantize_info->signature == MagickCoreSignature);\n  assert(images != (Image *) NULL);\n  assert(images->signature == MagickCoreSignature);\n  if (images->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",images->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if (GetNextImageInList(images) == (Image *) NULL)\n    {\n      /*\n        Handle a single image with QuantizeImage.\n      */\n      status=QuantizeImage(quantize_info,images,exception);\n      return(status);\n    }\n  status=MagickFalse;\n  maximum_colors=quantize_info->number_colors;\n  if (maximum_colors == 0)\n    maximum_colors=MaxColormapSize;\n  if (maximum_colors > MaxColormapSize)\n    maximum_colors=MaxColormapSize;\n  depth=quantize_info->tree_depth;\n  if (depth == 0)\n    {\n      size_t\n        colors;\n\n      /*\n        Depth of color tree is: Log4(colormap size)+2.\n      */\n      colors=maximum_colors;\n      for (depth=1; colors != 0; depth++)\n        colors>>=2;\n      if (quantize_info->dither_method != NoDitherMethod)\n        depth--;\n    }\n  /*\n    Initialize color cube.\n  */\n  cube_info=GetCubeInfo(quantize_info,depth,maximum_colors);\n  if (cube_info == (CubeInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",images->filename);\n      return(MagickFalse);\n    }\n  number_images=GetImageListLength(images);\n  image=images;\n  for (i=0; image != (Image *) NULL; i++)\n  {\n    progress_monitor=SetImageProgressMonitor(image,(MagickProgressMonitor) NULL,\n      image->client_data);\n    status=ClassifyImageColors(cube_info,image,exception);\n    if (status == MagickFalse)\n      break;\n    (void) SetImageProgressMonitor(image,progress_monitor,image->client_data);\n    proceed=SetImageProgress(image,AssignImageTag,(MagickOffsetType) i,\n      number_images);\n    if (proceed == MagickFalse)\n      break;\n    image=GetNextImageInList(image);\n  }\n  if (status != MagickFalse)\n    {\n      /*\n        Reduce the number of colors in an image sequence.\n      */\n      ReduceImageColors(images,cube_info);\n      image=images;\n      for (i=0; image != (Image *) NULL; i++)\n      {\n        progress_monitor=SetImageProgressMonitor(image,(MagickProgressMonitor)\n          NULL,image->client_data);\n        status=AssignImageColors(image,cube_info,exception);\n        if (status == MagickFalse)\n          break;\n        (void) SetImageProgressMonitor(image,progress_monitor,\n          image->client_data);\n        proceed=SetImageProgress(image,AssignImageTag,(MagickOffsetType) i,\n          number_images);\n        if (proceed == MagickFalse)\n          break;\n        image=GetNextImageInList(image);\n      }\n    }\n  DestroyCubeInfo(cube_info);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   Q u a n t i z e E r r o r F l a t t e n                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  QuantizeErrorFlatten() traverses the color cube and flattens the quantization\n%  error into a sorted 1D array.  This accelerates the color reduction process.\n%\n%  Contributed by Yoya.\n%\n%  The format of the QuantizeErrorFlatten method is:\n%\n%      size_t QuantizeErrorFlatten(const CubeInfo *cube_info,\n%        const NodeInfo *node_info,const ssize_t offset,\n%        double *quantize_error)\n%\n%  A description of each parameter follows.\n%\n%    o cube_info: A pointer to the Cube structure.\n%\n%    o node_info: pointer to node in color cube tree that is current pointer.\n%\n%    o offset: quantize error offset.\n%\n%    o quantize_error: the quantization error vector.\n%\n*/\nstatic size_t QuantizeErrorFlatten(const CubeInfo *cube_info,\n  const NodeInfo *node_info,const ssize_t offset,double *quantize_error)\n{\n  register ssize_t\n    i;\n\n  size_t\n    n,\n    number_children;\n\n  if (offset >= (ssize_t) cube_info->nodes)\n    return(0);\n  quantize_error[offset]=node_info->quantize_error;\n  n=1;\n  number_children=cube_info->associate_alpha == MagickFalse ? 8UL : 16UL;\n  for (i=0; i < (ssize_t) number_children ; i++)\n    if (node_info->child[i] != (NodeInfo *) NULL)\n      n+=QuantizeErrorFlatten(cube_info,node_info->child[i],offset+n,\n        quantize_error);\n  return(n);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   R e d u c e                                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  Reduce() traverses the color cube tree and prunes any node whose\n%  quantization error falls below a particular threshold.\n%\n%  The format of the Reduce method is:\n%\n%      Reduce(CubeInfo *cube_info,const NodeInfo *node_info)\n%\n%  A description of each parameter follows.\n%\n%    o cube_info: A pointer to the Cube structure.\n%\n%    o node_info: pointer to node in color cube tree that is to be pruned.\n%\n*/\nstatic void Reduce(CubeInfo *cube_info,const NodeInfo *node_info)\n{\n  register ssize_t\n    i;\n\n  size_t\n    number_children;\n\n  /*\n    Traverse any children.\n  */\n  number_children=cube_info->associate_alpha == MagickFalse ? 8UL : 16UL;\n  for (i=0; i < (ssize_t) number_children; i++)\n    if (node_info->child[i] != (NodeInfo *) NULL)\n      Reduce(cube_info,node_info->child[i]);\n  if (node_info->quantize_error <= cube_info->pruning_threshold)\n    PruneChild(cube_info,node_info);\n  else\n    {\n      /*\n        Find minimum pruning threshold.\n      */\n      if (node_info->number_unique > 0)\n        cube_info->colors++;\n      if (node_info->quantize_error < cube_info->next_threshold)\n        cube_info->next_threshold=node_info->quantize_error;\n    }\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   R e d u c e I m a g e C o l o r s                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReduceImageColors() repeatedly prunes the tree until the number of nodes\n%  with n2 > 0 is less than or equal to the maximum number of colors allowed\n%  in the output image.  On any given iteration over the tree, it selects\n%  those nodes whose E value is minimal for pruning and merges their\n%  color statistics upward. It uses a pruning threshold, Ep, to govern\n%  node selection as follows:\n%\n%    Ep = 0\n%    while number of nodes with (n2 > 0) > required maximum number of colors\n%      prune all nodes such that E <= Ep\n%      Set Ep to minimum E in remaining nodes\n%\n%  This has the effect of minimizing any quantization error when merging\n%  two nodes together.\n%\n%  When a node to be pruned has offspring, the pruning procedure invokes\n%  itself recursively in order to prune the tree from the leaves upward.\n%  n2,  Sr, Sg,  and  Sb in a node being pruned are always added to the\n%  corresponding data in that node's parent.  This retains the pruned\n%  node's color characteristics for later averaging.\n%\n%  For each node, n2 pixels exist for which that node represents the\n%  smallest volume in RGB space containing those pixel's colors.  When n2\n%  > 0 the node will uniquely define a color in the output image. At the\n%  beginning of reduction,  n2 = 0  for all nodes except a the leaves of\n%  the tree which represent colors present in the input image.\n%\n%  The other pixel count, n1, indicates the total number of colors\n%  within the cubic volume which the node represents.  This includes n1 -\n%  n2  pixels whose colors should be defined by nodes at a lower level in\n%  the tree.\n%\n%  The format of the ReduceImageColors method is:\n%\n%      ReduceImageColors(const Image *image,CubeInfo *cube_info)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n%    o cube_info: A pointer to the Cube structure.\n%\n*/\n\nstatic int QuantizeErrorCompare(const void *error_p,const void *error_q)\n{\n  double\n    *p,\n    *q;\n\n  p=(double *) error_p;\n  q=(double *) error_q;\n  if (*p > *q)\n    return(1);\n  if (fabs(*q-*p) <= MagickEpsilon)\n    return(0);\n  return(-1);\n}\n\nstatic void ReduceImageColors(const Image *image,CubeInfo *cube_info)\n{\n#define ReduceImageTag  \"Reduce/Image\"\n\n  MagickBooleanType\n    proceed;\n\n  MagickOffsetType\n    offset;\n\n  size_t\n    span;\n\n  cube_info->next_threshold=0.0;\n  if (cube_info->colors > cube_info->maximum_colors)\n    {\n      double\n        *quantize_error;\n\n      /*\n        Enable rapid reduction of the number of unique colors.\n      */\n      quantize_error=(double *) AcquireQuantumMemory(cube_info->nodes,\n        sizeof(*quantize_error));\n      if (quantize_error != (double *) NULL)\n        {\n          (void) QuantizeErrorFlatten(cube_info,cube_info->root,0,\n            quantize_error);\n          qsort(quantize_error,cube_info->nodes,sizeof(double),\n            QuantizeErrorCompare);\n          if (cube_info->nodes > (110*(cube_info->maximum_colors+1)/100))\n            cube_info->next_threshold=quantize_error[cube_info->nodes-110*\n              (cube_info->maximum_colors+1)/100];\n          quantize_error=(double *) RelinquishMagickMemory(quantize_error);\n        }\n  }\n  for (span=cube_info->colors; cube_info->colors > cube_info->maximum_colors; )\n  {\n    cube_info->pruning_threshold=cube_info->next_threshold;\n    cube_info->next_threshold=cube_info->root->quantize_error-1;\n    cube_info->colors=0;\n    Reduce(cube_info,cube_info->root);\n    offset=(MagickOffsetType) span-cube_info->colors;\n    proceed=SetImageProgress(image,ReduceImageTag,offset,span-\n      cube_info->maximum_colors+1);\n    if (proceed == MagickFalse)\n      break;\n  }\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e m a p I m a g e                                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RemapImage() replaces the colors of an image with the closest of the colors\n%  from the reference image.\n%\n%  The format of the RemapImage method is:\n%\n%      MagickBooleanType RemapImage(const QuantizeInfo *quantize_info,\n%        Image *image,const Image *remap_image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o quantize_info: Specifies a pointer to an QuantizeInfo structure.\n%\n%    o image: the image.\n%\n%    o remap_image: the reference image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType RemapImage(const QuantizeInfo *quantize_info,\n  Image *image,const Image *remap_image,ExceptionInfo *exception)\n{\n  CubeInfo\n    *cube_info;\n\n  MagickBooleanType\n    status;\n\n  /*\n    Initialize color cube.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(remap_image != (Image *) NULL);\n  assert(remap_image->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  cube_info=GetCubeInfo(quantize_info,MaxTreeDepth,\n    quantize_info->number_colors);\n  if (cube_info == (CubeInfo *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  status=ClassifyImageColors(cube_info,remap_image,exception);\n  if (status != MagickFalse)\n    {\n      /*\n        Classify image colors from the reference image.\n      */\n      cube_info->quantize_info->number_colors=cube_info->colors;\n      status=AssignImageColors(image,cube_info,exception);\n    }\n  DestroyCubeInfo(cube_info);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e m a p I m a g e s                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RemapImages() replaces the colors of a sequence of images with the\n%  closest color from a reference image.\n%\n%  The format of the RemapImage method is:\n%\n%      MagickBooleanType RemapImages(const QuantizeInfo *quantize_info,\n%        Image *images,Image *remap_image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o quantize_info: Specifies a pointer to an QuantizeInfo structure.\n%\n%    o images: the image sequence.\n%\n%    o remap_image: the reference image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType RemapImages(const QuantizeInfo *quantize_info,\n  Image *images,const Image *remap_image,ExceptionInfo *exception)\n{\n  CubeInfo\n    *cube_info;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  assert(images != (Image *) NULL);\n  assert(images->signature == MagickCoreSignature);\n  if (images->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",images->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=images;\n  if (remap_image == (Image *) NULL)\n    {\n      /*\n        Create a global colormap for an image sequence.\n      */\n      status=QuantizeImages(quantize_info,images,exception);\n      return(status);\n    }\n  /*\n    Classify image colors from the reference image.\n  */\n  cube_info=GetCubeInfo(quantize_info,MaxTreeDepth,\n    quantize_info->number_colors);\n  if (cube_info == (CubeInfo *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  status=ClassifyImageColors(cube_info,remap_image,exception);\n  if (status != MagickFalse)\n    {\n      /*\n        Classify image colors from the reference image.\n      */\n      cube_info->quantize_info->number_colors=cube_info->colors;\n      image=images;\n      for ( ; image != (Image *) NULL; image=GetNextImageInList(image))\n      {\n        status=AssignImageColors(image,cube_info,exception);\n        if (status == MagickFalse)\n          break;\n      }\n    }\n  DestroyCubeInfo(cube_info);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t G r a y s c a l e I m a g e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetGrayscaleImage() converts an image to a PseudoClass grayscale image.\n%\n%  The format of the SetGrayscaleImage method is:\n%\n%      MagickBooleanType SetGrayscaleImage(Image *image,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\nstatic int IntensityCompare(const void *x,const void *y)\n{\n  double\n    intensity;\n\n  PixelInfo\n    *color_1,\n    *color_2;\n\n  color_1=(PixelInfo *) x;\n  color_2=(PixelInfo *) y;\n  intensity=GetPixelInfoIntensity((const Image *) NULL,color_1)-\n    GetPixelInfoIntensity((const Image *) NULL,color_2);\n  return((int) intensity);\n}\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\nstatic MagickBooleanType SetGrayscaleImage(Image *image,\n  ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  PixelInfo\n    *colormap;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    *colormap_index,\n    j,\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->type != GrayscaleType)\n    (void) TransformImageColorspace(image,GRAYColorspace,exception);\n  colormap_index=(ssize_t *) AcquireQuantumMemory(MaxColormapSize,\n    sizeof(*colormap_index));\n  if (colormap_index == (ssize_t *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  if (image->storage_class != PseudoClass)\n    {\n      (void) ResetMagickMemory(colormap_index,(-1),MaxColormapSize*\n        sizeof(*colormap_index));\n      if (AcquireImageColormap(image,MaxColormapSize,exception) == MagickFalse)\n        {\n          colormap_index=(ssize_t *) RelinquishMagickMemory(colormap_index);\n          ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n            image->filename);\n        }\n      image->colors=0;\n      status=MagickTrue;\n      image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n      #pragma omp parallel for schedule(static,4) shared(status) \\\n        magick_threads(image,image,image->rows,1)\n#endif\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        register Quantum\n          *magick_restrict q;\n\n        register ssize_t\n          x;\n\n        if (status == MagickFalse)\n          continue;\n        q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,\n          exception);\n        if (q == (Quantum *) NULL)\n          {\n            status=MagickFalse;\n            continue;\n          }\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          register size_t\n            intensity;\n\n          intensity=ScaleQuantumToMap(GetPixelRed(image,q));\n          if (colormap_index[intensity] < 0)\n            {\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n              #pragma omp critical (MagickCore_SetGrayscaleImage)\n#endif\n              if (colormap_index[intensity] < 0)\n                {\n                  colormap_index[intensity]=(ssize_t) image->colors;\n                  image->colormap[image->colors].red=(double)\n                    GetPixelRed(image,q);\n                  image->colormap[image->colors].green=(double)\n                    GetPixelGreen(image,q);\n                  image->colormap[image->colors].blue=(double)\n                    GetPixelBlue(image,q);\n                  image->colors++;\n               }\n            }\n          SetPixelIndex(image,(Quantum) colormap_index[intensity],q);\n          q+=GetPixelChannels(image);\n        }\n        if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n          status=MagickFalse;\n      }\n      image_view=DestroyCacheView(image_view);\n    }\n  for (i=0; i < (ssize_t) image->colors; i++)\n    image->colormap[i].alpha=(double) i;\n  qsort((void *) image->colormap,image->colors,sizeof(PixelInfo),\n    IntensityCompare);\n  colormap=(PixelInfo *) AcquireQuantumMemory(image->colors,sizeof(*colormap));\n  if (colormap == (PixelInfo *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  j=0;\n  colormap[j]=image->colormap[0];\n  for (i=0; i < (ssize_t) image->colors; i++)\n  {\n    if (IsPixelInfoEquivalent(&colormap[j],&image->colormap[i]) == MagickFalse)\n      {\n        j++;\n        colormap[j]=image->colormap[i];\n      }\n    colormap_index[(ssize_t) image->colormap[i].alpha]=j;\n  }\n  image->colors=(size_t) (j+1);\n  image->colormap=(PixelInfo *) RelinquishMagickMemory(image->colormap);\n  image->colormap=colormap;\n  status=MagickTrue;\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(status) \\\n    magick_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      SetPixelIndex(image,(Quantum) colormap_index[ScaleQuantumToMap(\n        GetPixelIndex(image,q))],q);\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  image_view=DestroyCacheView(image_view);\n  colormap_index=(ssize_t *) RelinquishMagickMemory(colormap_index);\n  image->type=GrayscaleType;\n  if (SetImageMonochrome(image,exception) != MagickFalse)\n    image->type=BilevelType;\n  return(status);\n}\n", "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                        PPPP    AAA   L      M   M                           %\n%                        P   P  A   A  L      MM MM                           %\n%                        PPPP   AAAAA  L      M M M                           %\n%                        P      A   A  L      M   M                           %\n%                        P      A   A  LLLLL  M   M                           %\n%                                                                             %\n%                                                                             %\n%                          Read/Write Palm Pixmap.                            %\n%                                                                             %\n%                                                                             %\n%                              Software Design                                %\n%                            Christopher R. Hawks                             %\n%                               December 2001                                 %\n%                                                                             %\n%  Copyright 1999-2004 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://www.imagemagick.org/script/license.php                           %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  Based on pnmtopalm by Bill Janssen and ppmtobmp by Ian Goldberg.\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colormap-private.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/histogram.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/paint.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantize.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/utility.h\"\n\f\n/*\n  Define declarations.\n*/\n#define PALM_IS_COMPRESSED_FLAG  0x8000\n#define PALM_HAS_COLORMAP_FLAG  0x4000\n#define PALM_HAS_FOUR_BYTE_FIELD  0x0200\n#define PALM_HAS_TRANSPARENCY_FLAG  0x2000\n#define PALM_IS_INDIRECT  0x1000\n#define PALM_IS_FOR_SCREEN  0x0800\n#define PALM_IS_DIRECT_COLOR  0x0400\n#define PALM_COMPRESSION_SCANLINE  0x00\n#define PALM_COMPRESSION_RLE  0x01\n#define PALM_COMPRESSION_NONE  0xFF\n\f\n/*\n The 256 color system palette for Palm Computing Devices.\n*/\nstatic const unsigned char\n  PalmPalette[256][3] =\n  {\n    {255, 255,255}, {255, 204,255}, {255, 153,255}, {255, 102,255},\n    {255,  51,255}, {255,   0,255}, {255, 255,204}, {255, 204,204},\n    {255, 153,204}, {255, 102,204}, {255,  51,204}, {255,   0,204},\n    {255, 255,153}, {255, 204,153}, {255, 153,153}, {255, 102,153},\n    {255,  51,153}, {255,   0,153}, {204, 255,255}, {204, 204,255},\n    {204, 153,255}, {204, 102,255}, {204,  51,255}, {204,   0,255},\n    {204, 255,204}, {204, 204,204}, {204, 153,204}, {204, 102,204},\n    {204,  51,204}, {204,   0,204}, {204, 255,153}, {204, 204,153},\n    {204, 153,153}, {204, 102,153}, {204,  51,153}, {204,   0,153},\n    {153, 255,255}, {153, 204,255}, {153, 153,255}, {153, 102,255},\n    {153,  51,255}, {153,   0,255}, {153, 255,204}, {153, 204,204},\n    {153, 153,204}, {153, 102,204}, {153,  51,204}, {153,   0,204},\n    {153, 255,153}, {153, 204,153}, {153, 153,153}, {153, 102,153},\n    {153,  51,153}, {153,   0,153}, {102, 255,255}, {102, 204,255},\n    {102, 153,255}, {102, 102,255}, {102,  51,255}, {102,   0,255},\n    {102, 255,204}, {102, 204,204}, {102, 153,204}, {102, 102,204},\n    {102,  51,204}, {102,   0,204}, {102, 255,153}, {102, 204,153},\n    {102, 153,153}, {102, 102,153}, {102,  51,153}, {102,   0,153},\n    { 51, 255,255}, { 51, 204,255}, { 51, 153,255}, { 51, 102,255},\n    { 51,  51,255}, { 51,   0,255}, { 51, 255,204}, { 51, 204,204},\n    { 51, 153,204}, { 51, 102,204}, { 51,  51,204}, { 51,   0,204},\n    { 51, 255,153}, { 51, 204,153}, { 51, 153,153}, { 51, 102,153},\n    { 51,  51,153}, { 51,   0,153}, {  0, 255,255}, {  0, 204,255},\n    {  0, 153,255}, {  0, 102,255}, {  0,  51,255}, {  0,   0,255},\n    {  0, 255,204}, {  0, 204,204}, {  0, 153,204}, {  0, 102,204},\n    {  0,  51,204}, {  0,   0,204}, {  0, 255,153}, {  0, 204,153},\n    {  0, 153,153}, {  0, 102,153}, {  0,  51,153}, {  0,   0,153},\n    {255, 255,102}, {255, 204,102}, {255, 153,102}, {255, 102,102},\n    {255,  51,102}, {255,   0,102}, {255, 255, 51}, {255, 204, 51},\n    {255, 153, 51}, {255, 102, 51}, {255,  51, 51}, {255,   0, 51},\n    {255, 255,  0}, {255, 204,  0}, {255, 153,  0}, {255, 102,  0},\n    {255,  51,  0}, {255,   0,  0}, {204, 255,102}, {204, 204,102},\n    {204, 153,102}, {204, 102,102}, {204,  51,102}, {204,   0,102},\n    {204, 255, 51}, {204, 204, 51}, {204, 153, 51}, {204, 102, 51},\n    {204,  51, 51}, {204,   0, 51}, {204, 255,  0}, {204, 204,  0},\n    {204, 153,  0}, {204, 102,  0}, {204,  51,  0}, {204,   0,  0},\n    {153, 255,102}, {153, 204,102}, {153, 153,102}, {153, 102,102},\n    {153,  51,102}, {153,   0,102}, {153, 255, 51}, {153, 204, 51},\n    {153, 153, 51}, {153, 102, 51}, {153,  51, 51}, {153,   0, 51},\n    {153, 255,  0}, {153, 204,  0}, {153, 153,  0}, {153, 102,  0},\n    {153,  51,  0}, {153,   0,  0}, {102, 255,102}, {102, 204,102},\n    {102, 153,102}, {102, 102,102}, {102,  51,102}, {102,   0,102},\n    {102, 255, 51}, {102, 204, 51}, {102, 153, 51}, {102, 102, 51},\n    {102,  51, 51}, {102,   0, 51}, {102, 255,  0}, {102, 204,  0},\n    {102, 153,  0}, {102, 102,  0}, {102,  51,  0}, {102,   0,  0},\n    { 51, 255,102}, { 51, 204,102}, { 51, 153,102}, { 51, 102,102},\n    { 51,  51,102}, { 51,   0,102}, { 51, 255, 51}, { 51, 204, 51},\n    { 51, 153, 51}, { 51, 102, 51}, { 51,  51, 51}, { 51,   0, 51},\n    { 51, 255,  0}, { 51, 204,  0}, { 51, 153,  0}, { 51, 102,  0},\n    { 51,  51,  0}, { 51,   0,  0}, {  0, 255,102}, {  0, 204,102},\n    {  0, 153,102}, {  0, 102,102}, {  0,  51,102}, {  0,   0,102},\n    {  0, 255, 51}, {  0, 204, 51}, {  0, 153, 51}, {  0, 102, 51},\n    {  0,  51, 51}, {  0,   0, 51}, {  0, 255,  0}, {  0, 204,  0},\n    {  0, 153,  0}, {  0, 102,  0}, {  0,  51,  0}, { 17,  17, 17},\n    { 34,  34, 34}, { 68,  68, 68}, { 85,  85, 85}, {119, 119,119},\n    {136, 136,136}, {170, 170,170}, {187, 187,187}, {221, 221,221},\n    {238, 238,238}, {192, 192,192}, {128,   0,  0}, {128,   0,128},\n    {  0, 128,  0}, {  0, 128,128}, {  0,   0,  0}, {  0,   0,  0},\n    {  0,   0,  0}, {  0,   0,  0}, {  0,   0,  0}, {  0,   0,  0},\n    {  0,   0,  0}, {  0,   0,  0}, {  0,   0,  0}, {  0,   0,  0},\n    {  0,   0,  0}, {  0,   0,  0}, {  0,   0,  0}, {  0,   0,  0},\n    {  0,   0,  0}, {  0,   0,  0}, {  0,   0,  0}, {  0,   0,  0},\n    {  0,   0,  0}, {  0,   0,  0}, {  0,   0,  0}, {  0,   0,  0},\n    {  0,   0,  0}, {  0,   0,  0}, {  0,   0,  0}, {  0,   0,  0}\n  };\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WritePALMImage(const ImageInfo *,Image *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   F i n d C o l o r                                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  FindColor() returns the index of the matching entry from PalmPalette for a\n%  given PixelInfo.\n%\n%  The format of the FindColor method is:\n%\n%      int FindColor(PixelInfo *pixel)\n%\n%  A description of each parameter follows:\n%\n%    o int: the index of the matching color or -1 if not found/\n%\n%    o pixel: a pointer to the PixelInfo to be matched.\n%\n*/\nstatic ssize_t FindColor(PixelInfo *packet)\n{\n  register ssize_t\n    i;\n\n  for (i=0; i < 256; i++)\n    if (ScaleQuantumToChar(ClampToQuantum(packet->red)) == PalmPalette[i][0] &&\n        ScaleQuantumToChar(ClampToQuantum(packet->green)) == PalmPalette[i][1] &&\n        ScaleQuantumToChar(ClampToQuantum(packet->blue)) == PalmPalette[i][2])\n      return(i);\n  return(-1);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d P A L M I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadPALMImage() reads an image of raw bites in LSB order and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadPALMImage method is:\n%\n%      Image *ReadPALMImage(const ImageInfo *image_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: Specifies a pointer to an ImageInfo structure.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadPALMImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    totalOffset,\n    seekNextDepth;\n\n  PixelInfo\n    transpix;\n\n  Quantum\n    index;\n\n  register ssize_t\n    i,\n    x;\n\n  register Quantum\n    *q;\n\n  size_t\n    bytes_per_row,\n    flags,\n    bits_per_pixel,\n    version,\n    nextDepthOffset,\n    transparentIndex,\n    compressionType,\n    byte,\n    mask,\n    redbits,\n    greenbits,\n    bluebits,\n    one,\n    pad,\n    size,\n    bit;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *last_row,\n    *one_row,\n    *ptr;\n\n  unsigned short\n    color16;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      (void) DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  totalOffset=0;\n  do\n  {\n    image->columns=ReadBlobMSBShort(image);\n    image->rows=ReadBlobMSBShort(image);\n    if (EOFBlob(image) != MagickFalse)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((image->columns == 0) || (image->rows == 0))\n      ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    bytes_per_row=ReadBlobMSBShort(image);\n    flags=ReadBlobMSBShort(image);\n    bits_per_pixel=(size_t) ReadBlobByte(image);\n    if ((bits_per_pixel != 1) && (bits_per_pixel != 2) &&\n        (bits_per_pixel != 4) && (bits_per_pixel != 8) &&\n        (bits_per_pixel != 16))\n      ThrowReaderException(CorruptImageError,\"UnrecognizedBitsPerPixel\");\n    version=(size_t) ReadBlobByte(image);\n    if ((version != 0) && (version != 1) && (version != 2))\n      ThrowReaderException(CorruptImageError,\"FileFormatVersionMismatch\");\n    nextDepthOffset=(size_t) ReadBlobMSBShort(image);\n    transparentIndex=(size_t) ReadBlobByte(image);\n    compressionType=(size_t) ReadBlobByte(image);\n    if ((compressionType != PALM_COMPRESSION_NONE) &&\n        (compressionType != PALM_COMPRESSION_SCANLINE ) &&\n        (compressionType != PALM_COMPRESSION_RLE))\n      ThrowReaderException(CorruptImageError,\"UnrecognizedImageCompression\");\n    pad=ReadBlobMSBShort(image);\n    (void) pad;\n    /*\n      Initialize image colormap.\n    */\n    one=1;\n    if ((bits_per_pixel < 16) &&\n        (AcquireImageColormap(image,one << bits_per_pixel,exception) == MagickFalse))\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    GetPixelInfo(image,&transpix);\n    if (bits_per_pixel == 16)  /* Direct Color */\n      {\n        redbits=(size_t) ReadBlobByte(image);  /* # of bits of red */\n        (void) redbits;\n        greenbits=(size_t) ReadBlobByte(image);  /* # of bits of green */\n        (void) greenbits;\n        bluebits=(size_t) ReadBlobByte(image);  /* # of bits of blue */\n        (void) bluebits;\n        ReadBlobByte(image);  /* reserved by Palm */\n        ReadBlobByte(image);  /* reserved by Palm */\n        transpix.red=(double) (QuantumRange*ReadBlobByte(image)/31);\n        transpix.green=(double) (QuantumRange*ReadBlobByte(image)/63);\n        transpix.blue=(double) (QuantumRange*ReadBlobByte(image)/31);\n      }\n    if (bits_per_pixel == 8)\n      {\n        ssize_t\n          index;\n\n        if (flags & PALM_HAS_COLORMAP_FLAG)\n          {\n            count=(ssize_t) ReadBlobMSBShort(image);\n            for (i=0; i < (ssize_t) count; i++)\n            {\n              ReadBlobByte(image);\n              index=ConstrainColormapIndex(image,255-i,exception);\n              image->colormap[index].red=(MagickRealType)\n                ScaleCharToQuantum((unsigned char) ReadBlobByte(image));\n              image->colormap[index].green=(MagickRealType)\n                ScaleCharToQuantum((unsigned char) ReadBlobByte(image));\n              image->colormap[index].blue=(MagickRealType)\n                ScaleCharToQuantum((unsigned char) ReadBlobByte(image));\n          }\n        }\n      else\n        for (i=0; i < (ssize_t) (1L << bits_per_pixel); i++)\n        {\n          index=ConstrainColormapIndex(image,255-i,exception);\n          image->colormap[index].red=(MagickRealType)\n            ScaleCharToQuantum(PalmPalette[i][0]);\n          image->colormap[index].green=(MagickRealType)\n            ScaleCharToQuantum(PalmPalette[i][1]);\n          image->colormap[index].blue=(MagickRealType)\n            ScaleCharToQuantum(PalmPalette[i][2]);\n        }\n      }\n    if (flags & PALM_IS_COMPRESSED_FLAG)\n      size=ReadBlobMSBShort(image);\n    (void) size;\n    image->storage_class=DirectClass;\n    if (bits_per_pixel < 16)\n      {\n        image->storage_class=PseudoClass;\n        image->depth=8;\n      }\n    if (image_info->ping != MagickFalse)\n      {\n        (void) CloseBlob(image);\n        return(image);\n      }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    one_row=(unsigned char *) AcquireQuantumMemory(MagickMax(bytes_per_row,\n      2*image->columns),sizeof(*one_row));\n    if (one_row == (unsigned char *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    last_row=(unsigned char *) NULL;\n    if (compressionType == PALM_COMPRESSION_SCANLINE)\n      {\n        last_row=(unsigned char *) AcquireQuantumMemory(MagickMax(bytes_per_row,\n          2*image->columns),sizeof(*last_row));\n        if (last_row == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    mask=(size_t) (1U << bits_per_pixel)-1;\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      if ((flags & PALM_IS_COMPRESSED_FLAG) == 0)\n        {\n          /* TODO move out of loop! */\n          image->compression=NoCompression;\n          count=ReadBlob(image,bytes_per_row,one_row);\n          if (count != (ssize_t) bytes_per_row)\n            break;\n        }\n      else\n        {\n          if (compressionType == PALM_COMPRESSION_RLE)\n            { \n              /* TODO move out of loop! */\n              image->compression=RLECompression;\n              for (i=0; i < (ssize_t) bytes_per_row; )\n              {\n                count=(ssize_t) ReadBlobByte(image);\n                if (count < 0)\n                  break;\n                count=MagickMin(count,(ssize_t) bytes_per_row-i);\n                byte=(size_t) ReadBlobByte(image);\n                (void) ResetMagickMemory(one_row+i,(int) byte,(size_t) count);\n                i+=count;\n              }\n          }\n        else\n          if (compressionType == PALM_COMPRESSION_SCANLINE)\n            {\n              size_t\n                one;\n\n              /* TODO move out of loop! */\n              one=1;\n              image->compression=FaxCompression;\n              for (i=0; i < (ssize_t) bytes_per_row; i+=8)\n              {\n                count=(ssize_t) ReadBlobByte(image);\n                if (count < 0)\n                  break;\n                byte=(size_t) MagickMin((ssize_t) bytes_per_row-i,8);\n                for (bit=0; bit < byte; bit++)\n                {\n                  if ((y == 0) || (count & (one << (7 - bit))))\n                    one_row[i+bit]=(unsigned char) ReadBlobByte(image);\n                  else\n                    one_row[i+bit]=last_row[i+bit];\n                }\n              }\n              (void) CopyMagickMemory(last_row, one_row, bytes_per_row);\n            }\n        }\n      ptr=one_row;\n      q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n      if (q == (Quantum *) NULL)\n        break;\n      if (bits_per_pixel == 16)\n        {\n          if (image->columns > (2*bytes_per_row))\n            {\n              one_row=(unsigned char *) RelinquishMagickMemory(one_row);\n              if (compressionType == PALM_COMPRESSION_SCANLINE)\n                last_row=(unsigned char *) RelinquishMagickMemory(last_row);\n              ThrowReaderException(CorruptImageError,\"CorruptImage\");\n            }\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            color16=(*ptr++ << 8);\n            color16|=(*ptr++);\n            SetPixelRed(image,(Quantum) ((QuantumRange*((color16 >> 11) &\n              0x1f))/0x1f),q);\n            SetPixelGreen(image,(Quantum) ((QuantumRange*((color16 >> 5) &\n              0x3f))/0x3f),q);\n            SetPixelBlue(image,(Quantum) ((QuantumRange*((color16 >> 0) &\n              0x1f))/0x1f),q);\n            SetPixelAlpha(image,OpaqueAlpha,q);\n            q+=GetPixelChannels(image);\n          }\n        }\n      else\n        {\n          bit=8-bits_per_pixel;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            if ((size_t) (ptr-one_row) >= bytes_per_row)\n              {\n                one_row=(unsigned char *) RelinquishMagickMemory(one_row);\n                if (compressionType == PALM_COMPRESSION_SCANLINE)\n                  last_row=(unsigned char *) RelinquishMagickMemory(last_row);\n                ThrowReaderException(CorruptImageError,\"CorruptImage\");\n              }\n            index=(Quantum) (mask-(((*ptr) & (mask << bit)) >> bit));\n            SetPixelIndex(image,index,q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            if (bit)\n              bit-=bits_per_pixel;\n            else\n              {\n                ptr++;\n                bit=8-bits_per_pixel;\n              }\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n        }\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n      }\n    if (flags & PALM_HAS_TRANSPARENCY_FLAG)\n      {\n        ssize_t index=ConstrainColormapIndex(image,(ssize_t) (mask-\n          transparentIndex),exception);\n        if (bits_per_pixel != 16)\n          transpix=image->colormap[index];\n        (void) TransparentPaintImage(image,&transpix,(Quantum) TransparentAlpha,\n          MagickFalse,exception);\n      }\n    one_row=(unsigned char *) RelinquishMagickMemory(one_row);\n    if (compressionType == PALM_COMPRESSION_SCANLINE)\n      last_row=(unsigned char *) RelinquishMagickMemory(last_row);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image. Copied from coders/pnm.c\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if (nextDepthOffset != 0)\n      { \n        /*\n          Skip to next image. \n        */\n        totalOffset+=(MagickOffsetType) (nextDepthOffset*4);\n        if (totalOffset >= (MagickOffsetType) GetBlobSize(image))\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\")\n        else\n          seekNextDepth=SeekBlob(image,totalOffset,SEEK_SET);\n        if (seekNextDepth != totalOffset)\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        /*\n          Allocate next image structure. Copied from coders/pnm.c\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            (void) DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (nextDepthOffset != 0);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r P A L M I m a g e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterPALMImage() adds properties for the PALM image format to the list of\n%  supported formats.  The properties include the image format tag, a method to\n%  read and/or write the format, whether the format supports the saving of more\n%  than one frame to the same file or blob, whether the format supports native\n%  in-memory I/O, and a brief description of the format.\n%\n%  The format of the RegisterPALMImage method is:\n%\n%      size_t RegisterPALMImage(void)\n%\n*/\nModuleExport size_t RegisterPALMImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"PALM\",\"PALM\",\"Palm pixmap\");\n  entry->decoder=(DecodeImageHandler *) ReadPALMImage;\n  entry->encoder=(EncodeImageHandler *) WritePALMImage;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags|=CoderEncoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r P A L M I m a g e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterPALMImage() removes format registrations made by the PALM\n%  module from the list of supported formats.\n%\n%  The format of the UnregisterPALMImage method is:\n%\n%      UnregisterPALMImage(void)\n%\n*/\nModuleExport void UnregisterPALMImage(void)\n{\n  (void) UnregisterMagickInfo(\"PALM\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e P A L M I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WritePALMImage() writes an image of raw bits in LSB order to a file.\n%\n%  The format of the WritePALMImage method is:\n%\n%      MagickBooleanType WritePALMImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: Specifies a pointer to an ImageInfo structure.\n%\n%    o image:  A pointer to a Image structure.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WritePALMImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    currentOffset,\n    offset,\n    scene;\n\n  MagickSizeType\n    cc;\n\n  PixelInfo\n    transpix;\n\n  QuantizeInfo\n    *quantize_info;\n\n  register ssize_t\n    x;\n\n  register const Quantum\n    *p;\n\n  register Quantum\n    *q;\n\n  ssize_t\n    y;\n\n  size_t\n    count,\n    bits_per_pixel,\n    bytes_per_row,\n    nextDepthOffset,\n    one;\n\n  unsigned char\n    bit,\n    byte,\n    color,\n    *last_row,\n    *one_row,\n    *ptr,\n    version;\n\n  unsigned int\n    transparentIndex;\n\n  unsigned short\n    color16,\n    flags;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  quantize_info=AcquireQuantizeInfo(image_info);\n  flags=0;\n  currentOffset=0;\n  transparentIndex=0;\n  transpix.red=0.0;\n  transpix.green=0.0;\n  transpix.blue=0.0;\n  transpix.alpha=0.0;\n  one=1;\n  version=0;\n  scene=0;\n  do\n  {\n    (void) TransformImageColorspace(image,sRGBColorspace,exception);\n    count=GetNumberColors(image,NULL,exception);\n    for (bits_per_pixel=1;  (one << bits_per_pixel) < count; bits_per_pixel*=2) ;\n    if (bits_per_pixel > 16)\n      bits_per_pixel=16;\n    else\n      if (bits_per_pixel < 16)\n        (void) TransformImageColorspace(image,image->colorspace,exception);\n    if (bits_per_pixel < 8)\n      {\n        (void) TransformImageColorspace(image,GRAYColorspace,exception);\n        (void) SetImageType(image,PaletteType,exception);\n        (void) SortColormapByIntensity(image,exception);\n      }\n    if ((image->storage_class == PseudoClass) && (image->colors > 256))\n      (void) SetImageStorageClass(image,DirectClass,exception);\n    if (image->storage_class == PseudoClass)\n      flags|=PALM_HAS_COLORMAP_FLAG;\n    else\n      flags|=PALM_IS_DIRECT_COLOR;\n    (void) WriteBlobMSBShort(image,(unsigned short) image->columns); /* width */\n    (void) WriteBlobMSBShort(image,(unsigned short) image->rows);  /* height */\n    bytes_per_row=((image->columns+(16/bits_per_pixel-1))/(16/\n      bits_per_pixel))*2;\n    (void) WriteBlobMSBShort(image,(unsigned short) bytes_per_row);\n    if ((image_info->compression == RLECompression) ||\n        (image_info->compression == FaxCompression))\n      flags|=PALM_IS_COMPRESSED_FLAG;\n    (void) WriteBlobMSBShort(image, flags);\n    (void) WriteBlobByte(image,(unsigned char) bits_per_pixel);\n    if (bits_per_pixel > 1)\n      version=1;\n    if ((image_info->compression == RLECompression) ||\n        (image_info->compression == FaxCompression))\n      version=2;\n    (void) WriteBlobByte(image,version);\n    (void) WriteBlobMSBShort(image,0);  /* nextDepthOffset */\n    (void) WriteBlobByte(image,(unsigned char) transparentIndex);\n    if (image_info->compression == RLECompression)\n      (void) WriteBlobByte(image,PALM_COMPRESSION_RLE);\n    else\n      if (image_info->compression == FaxCompression)\n        (void) WriteBlobByte(image,PALM_COMPRESSION_SCANLINE);\n      else\n        (void) WriteBlobByte(image,PALM_COMPRESSION_NONE);\n    (void) WriteBlobMSBShort(image,0);  /* reserved */\n    offset=16;\n    if (bits_per_pixel == 16)\n      {\n        (void) WriteBlobByte(image,5);  /* # of bits of red */\n        (void) WriteBlobByte(image,6);  /* # of bits of green */\n        (void) WriteBlobByte(image,5);  /* # of bits of blue */\n        (void) WriteBlobByte(image,0);  /* reserved by Palm */\n        (void) WriteBlobMSBLong(image,0);  /* no transparent color, YET */\n        offset+=8;\n      }\n    if (bits_per_pixel == 8)\n      {\n        if (flags & PALM_HAS_COLORMAP_FLAG)  /* Write out colormap */\n          {\n            quantize_info->dither_method=IdentifyPaletteImage(image,exception)\n              == MagickFalse ? RiemersmaDitherMethod : NoDitherMethod;\n            quantize_info->number_colors=image->colors;\n            (void) QuantizeImage(quantize_info,image,exception);\n            (void) WriteBlobMSBShort(image,(unsigned short) image->colors);\n            for (count = 0; count < image->colors; count++)\n            {\n              (void) WriteBlobByte(image,(unsigned char) count);\n              (void) WriteBlobByte(image,ScaleQuantumToChar(ClampToQuantum(\n                image->colormap[count].red)));\n              (void) WriteBlobByte(image,ScaleQuantumToChar(ClampToQuantum(\n                image->colormap[count].green)));\n              (void) WriteBlobByte(image,ScaleQuantumToChar(ClampToQuantum(\n                image->colormap[count].blue)));\n            }\n            offset+=2+count*4;\n          }\n      else  /* Map colors to Palm standard colormap */\n        {\n          Image\n            *affinity_image;\n\n          affinity_image=ConstituteImage(256,1,\"RGB\",CharPixel,&PalmPalette,\n            exception);\n          (void) TransformImageColorspace(affinity_image,\n            affinity_image->colorspace,exception);\n          (void) RemapImage(quantize_info,image,affinity_image,exception);\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelIndex(image,(Quantum) FindColor(&image->colormap[(ssize_t)\n                GetPixelIndex(image,q)]),q);\n              q+=GetPixelChannels(image);\n            }\n          }\n          affinity_image=DestroyImage(affinity_image);\n        }\n      }\n    if (flags & PALM_IS_COMPRESSED_FLAG)\n      (void) WriteBlobMSBShort(image,0);  /* fill in size later */\n    last_row=(unsigned char *) NULL;\n    if (image_info->compression == FaxCompression)\n      {\n        last_row=(unsigned char *) AcquireQuantumMemory(bytes_per_row,\n          sizeof(*last_row));\n        if (last_row == (unsigned char *) NULL)\n          {\n            quantize_info=DestroyQuantizeInfo(quantize_info);\n            ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n      }\n    one_row=(unsigned char *) AcquireQuantumMemory(bytes_per_row,\n      sizeof(*one_row));\n    if (one_row == (unsigned char *) NULL)\n      {\n        quantize_info=DestroyQuantizeInfo(quantize_info);\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      ptr=one_row;\n      (void) ResetMagickMemory(ptr,0,bytes_per_row);\n      p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n      if (p == (const Quantum *) NULL)\n        break;\n      if (bits_per_pixel == 16)\n        {\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            color16=(unsigned short) ((((31*(size_t) GetPixelRed(image,p))/\n              (size_t) QuantumRange) << 11) | (((63*(size_t)\n              GetPixelGreen(image,p))/(size_t) QuantumRange) << 5) |\n              ((31*(size_t) GetPixelBlue(image,p))/(size_t) QuantumRange));\n            if (GetPixelAlpha(image,p) == (Quantum) TransparentAlpha)\n              {\n                transpix.red=(MagickRealType) GetPixelRed(image,p);\n                transpix.green=(MagickRealType) GetPixelGreen(image,p);\n                transpix.blue=(MagickRealType) GetPixelBlue(image,p);\n                transpix.alpha=(MagickRealType) GetPixelAlpha(image,p);\n                flags|=PALM_HAS_TRANSPARENCY_FLAG;\n              }\n            *ptr++=(unsigned char) ((color16 >> 8) & 0xff);\n            *ptr++=(unsigned char) (color16 & 0xff);\n            p+=GetPixelChannels(image);\n          }\n        }\n      else\n        {\n          byte=0x00;\n          bit=(unsigned char) (8-bits_per_pixel);\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            if (bits_per_pixel >= 8)\n              color=(unsigned char) GetPixelIndex(image,p);\n            else\n              color=(unsigned char) (GetPixelIndex(image,p)*\n                ((one << bits_per_pixel)-1)/MagickMax(1*image->colors-1,1));\n            byte|=color << bit;\n            if (bit != 0)\n              bit-=(unsigned char) bits_per_pixel;\n            else\n              {\n                *ptr++=byte;\n                byte=0x00;\n                bit=(unsigned char) (8-bits_per_pixel);\n              }\n            p+=GetPixelChannels(image);\n          }\n          if ((image->columns % (8/bits_per_pixel)) != 0)\n            *ptr++=byte;\n        }\n      if (image_info->compression == RLECompression)\n        {\n          x=0;\n          while (x < (ssize_t) bytes_per_row)\n          {\n            byte=one_row[x];\n            count=1;\n            while ((one_row[++x] == byte) && (count < 255) &&\n                   (x < (ssize_t) bytes_per_row))\n              count++;\n            (void) WriteBlobByte(image,(unsigned char) count);\n            (void) WriteBlobByte(image,(unsigned char) byte);\n          }\n        }\n      else\n        if (image_info->compression == FaxCompression)\n          {\n            char\n              tmpbuf[8],\n              *tptr;\n  \n            for (x = 0;  x < (ssize_t) bytes_per_row;  x += 8)\n            {\n              tptr = tmpbuf;\n              for (bit=0, byte=0; bit < (unsigned char) MagickMin(8,(ssize_t) bytes_per_row-x); bit++)\n              {\n                if ((y == 0) || (last_row[x + bit] != one_row[x + bit]))\n                  {\n                    byte |= (1 << (7 - bit));\n                    *tptr++ = (char) one_row[x + bit];\n                  }\n              }\n              (void) WriteBlobByte(image, byte);\n              (void) WriteBlob(image,tptr-tmpbuf,(unsigned char *) tmpbuf);\n            }\n            (void) CopyMagickMemory(last_row,one_row,bytes_per_row);\n          }\n        else\n          (void) WriteBlob(image,bytes_per_row,one_row);\n      }\n    if (flags & PALM_HAS_TRANSPARENCY_FLAG)\n      {\n        offset=SeekBlob(image,currentOffset+6,SEEK_SET);\n        (void) WriteBlobMSBShort(image,flags);\n        offset=SeekBlob(image,currentOffset+12,SEEK_SET);\n        (void) WriteBlobByte(image,(unsigned char) transparentIndex);  /* trans index */\n      }\n    if (bits_per_pixel == 16)\n      {\n        offset=SeekBlob(image,currentOffset+20,SEEK_SET);\n        (void) WriteBlobByte(image,0);  /* reserved by Palm */\n        (void) WriteBlobByte(image,(unsigned char) ((31*transpix.red)/\n          QuantumRange));\n        (void) WriteBlobByte(image,(unsigned char) ((63*transpix.green)/\n          QuantumRange));\n        (void) WriteBlobByte(image,(unsigned char) ((31*transpix.blue)/\n          QuantumRange));\n      }\n    if (flags & PALM_IS_COMPRESSED_FLAG)  /* fill in size now */\n      {\n        offset=SeekBlob(image,currentOffset+offset,SEEK_SET);\n        (void) WriteBlobMSBShort(image,(unsigned short) (GetBlobSize(image)-\n          currentOffset-offset));\n      }\n    if (one_row != (unsigned char *) NULL) \n      one_row=(unsigned char *) RelinquishMagickMemory(one_row);\n    if (last_row != (unsigned char *) NULL) \n      last_row=(unsigned char *) RelinquishMagickMemory(last_row);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    /* padding to 4 byte word */\n    for (cc=(GetBlobSize(image)) % 4; cc > 0; cc--)\n      (void) WriteBlobByte(image,0);\n    /* write nextDepthOffset and return to end of image */\n    offset=SeekBlob(image,currentOffset+10,SEEK_SET);\n    nextDepthOffset=(size_t) ((GetBlobSize(image)-currentOffset)/4);\n    (void) WriteBlobMSBShort(image,(unsigned short) nextDepthOffset);\n    currentOffset=(MagickOffsetType) GetBlobSize(image);\n    offset=SeekBlob(image,currentOffset,SEEK_SET);\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  quantize_info=DestroyQuantizeInfo(quantize_info);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n"], "filenames": ["MagickCore/quantize.c", "coders/palm.c"], "buggy_code_start_loc": [3362, 287], "buggy_code_end_loc": [3364, 1000], "fixing_code_start_loc": [3362, 287], "fixing_code_end_loc": [3367, 1012], "type": "CWE-772", "message": "ImageMagick 7.0.6-2 has a memory leak vulnerability in WritePALMImage in coders/palm.c.", "other": {"cve": {"id": "CVE-2017-12664", "sourceIdentifier": "cve@mitre.org", "published": "2017-08-07T21:29:00.267", "lastModified": "2020-10-14T17:52:36.653", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "ImageMagick 7.0.6-2 has a memory leak vulnerability in WritePALMImage in coders/palm.c."}, {"lang": "es", "value": "ImageMagick 7.0.6-2 tiene una vulnerabilidad de filtrado de memoria en WritePALMImage en coders/palm.c."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-772"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.6-2:*:*:*:*:*:*:*", "matchCriteriaId": "7E47D35D-B2EB-4957-A0C8-7DE54233997F"}]}]}], "references": [{"url": "https://github.com/ImageMagick/ImageMagick/commit/0417cea1b6d72f90bd4f1f573f91e42a8ba66a89", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/issues/574", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/0417cea1b6d72f90bd4f1f573f91e42a8ba66a89"}}