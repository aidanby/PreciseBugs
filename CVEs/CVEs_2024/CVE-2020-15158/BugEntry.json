{"buggy_code": ["/*\n *  cotp.c\n *\n *  ISO 8073 Connection Oriented Transport Protocol over TCP (RFC1006)\n *\n *  Partial implementation of the ISO 8073 COTP (ISO TP0) protocol for MMS.\n *\n *  Copyright 2013-2018 Michael Zillgith\n *\n *  This file is part of libIEC61850.\n *\n *  libIEC61850 is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  libIEC61850 is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with libIEC61850.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  See COPYING file for the complete license text.\n */\n\n#include \"libiec61850_platform_includes.h\"\n#include \"stack_config.h\"\n#include \"cotp.h\"\n#include \"byte_buffer.h\"\n#include \"buffer_chain.h\"\n\n#define TPKT_RFC1006_HEADER_SIZE 4\n\n#define COTP_DATA_HEADER_SIZE 3\n\n#ifdef CONFIG_COTP_MAX_TPDU_SIZE\n#define COTP_MAX_TPDU_SIZE CONFIG_COTP_MAX_TPDU_SIZE\n#else\n#define COTP_MAX_TPDU_SIZE 8192\n#endif\n\n#ifndef DEBUG_COTP\n#define DEBUG_COTP 0\n#endif\n\nstatic bool\naddPayloadToBuffer(CotpConnection* self, uint8_t* buffer, int payloadLength);\n\nstatic uint16_t\ngetUint16(uint8_t* buffer)\n{\n    return (buffer[0] * 0x100) + buffer[1];\n}\n\nstatic uint8_t\ngetUint8(uint8_t* buffer)\n{\n    return buffer[0];\n}\n\nstatic void\nwriteOptions(CotpConnection* self)\n{\n    /* max size = 11 byte */\n    uint8_t* buffer = self->writeBuffer->buffer;\n    int bufPos = self->writeBuffer->size;\n\n    if (self->options.tpduSize != 0) {\n\n        if (DEBUG_COTP)\n            printf(\"COTP: send TPDU size: %i\\n\", CotpConnection_getTpduSize(self));\n\n        buffer[bufPos++] = 0xc0;\n        buffer[bufPos++] = 0x01;\n        buffer[bufPos++] = self->options.tpduSize;\n    }\n\n    if (self->options.tSelDst.size != 0) {\n        buffer[bufPos++] = 0xc2;\n        buffer[bufPos++] = (uint8_t) self->options.tSelDst.size;\n\n        int i;\n        for (i = 0; i < self->options.tSelDst.size; i++)\n            buffer[bufPos++] = (uint8_t) self->options.tSelDst.value[i];\n    }\n\n    if (self->options.tSelSrc.size != 0) {\n        buffer[bufPos++] = 0xc1;\n        buffer[bufPos++] = (uint8_t) self->options.tSelSrc.size;\n\n        int i;\n        for (i = 0; i < self->options.tSelSrc.size; i++)\n            buffer[bufPos++] = (uint8_t) self->options.tSelSrc.value[i];\n    }\n\n    self->writeBuffer->size = bufPos;\n}\n\nstatic int\ngetOptionsLength(CotpConnection* self)\n{\n    int optionsLength = 0;\n\n    if (self->options.tpduSize != 0)\n        optionsLength += 3;\n\n    if (self->options.tSelDst.size != 0)\n        optionsLength += (2 + self->options.tSelDst.size);\n\n    if (self->options.tSelSrc.size != 0)\n        optionsLength += (2 + self->options.tSelSrc.size);\n\n    return optionsLength;\n}\n\nstatic void\nwriteStaticConnectResponseHeader(CotpConnection* self, int optionsLength)\n{\n    /* always same size (7) and same position in buffer */\n    uint8_t* buffer = self->writeBuffer->buffer;\n\n    buffer[4] = 6 + optionsLength;\n    buffer[5] = 0xd0;\n    buffer[6] = (uint8_t) (self->remoteRef / 0x100);\n    buffer[7] = (uint8_t) (self->remoteRef & 0xff);\n    buffer[8] = (uint8_t) (self->localRef / 0x100);\n    buffer[9] = (uint8_t) (self->localRef & 0xff);\n    buffer[10] = (uint8_t) (self->protocolClass);\n\n    self->writeBuffer->size = 11;\n}\n\nstatic void\nwriteRfc1006Header(CotpConnection* self, int len)\n{\n    uint8_t* buffer = self->writeBuffer->buffer;\n\n    buffer[0] = 0x03;\n    buffer[1] = 0x00;\n    buffer[2] = (uint8_t) (len / 0x100);\n    buffer[3] = (uint8_t) (len & 0xff);\n\n    self->writeBuffer->size = 4;\n}\n\nstatic void\nwriteDataTpduHeader(CotpConnection* self, int isLastUnit)\n{\n    /* always 3 byte starting from byte 5 in buffer */\n    uint8_t* buffer = self->writeBuffer->buffer;\n\n    buffer[4] = 0x02;\n    buffer[5] = 0xf0;\n    if (isLastUnit)\n        buffer[6] = 0x80;\n    else\n        buffer[6] = 0x00;\n\n    self->writeBuffer->size = 7;\n}\n\nstatic int\nwriteToSocket(CotpConnection* self, uint8_t* buf, int size)\n{\n#if (CONFIG_MMS_SUPPORT_TLS == 1)\n    if (self->tlsSocket)\n        return TLSSocket_write(self->tlsSocket, buf, size);\n    else\n        return Socket_write(self->socket, buf, size);\n#else\n    return Socket_write(self->socket, buf, size);\n#endif\n}\n\n\nstatic bool\nsendBuffer(CotpConnection* self)\n{\n    int remainingSize = ByteBuffer_getSize(self->writeBuffer);\n    uint8_t* buffer = ByteBuffer_getBuffer(self->writeBuffer);\n\n    bool retVal = false;\n\n    do {\n        int sentBytes = writeToSocket(self, buffer, remainingSize);\n\n        if (sentBytes == -1)\n            goto exit_function;\n\n        buffer += sentBytes;\n        remainingSize -= sentBytes;\n\n    } while (remainingSize > 0);\n\n    retVal = true;\n\n    ByteBuffer_setSize(self->writeBuffer, 0);\n\nexit_function:\n    return retVal;\n}\n\nCotpIndication\nCotpConnection_sendDataMessage(CotpConnection* self, BufferChain payload)\n{\n    CotpIndication retValue = COTP_OK;\n\n    int fragments = 1;\n\n    int fragmentPayloadSize = CotpConnection_getTpduSize(self) - COTP_DATA_HEADER_SIZE;\n\n    if (payload->length > fragmentPayloadSize) { /* Check if segmentation is required? */\n        fragments = payload->length / fragmentPayloadSize;\n\n        if ((payload->length % fragmentPayloadSize) != 0)\n            fragments += 1;\n    }\n\n    int currentBufPos = 0;\n    int currentLimit;\n    int lastUnit;\n\n    BufferChain currentChain = payload;\n    int currentChainIndex = 0;\n\n    if (DEBUG_COTP)\n        printf(\"\\nCOTP: nextBufferPart: len:%i partLen:%i\\n\", currentChain->length, currentChain->partLength);\n\n    uint8_t* buffer = self->writeBuffer->buffer;\n\n    while (fragments > 0) {\n        if (fragments > 1) {\n            currentLimit = currentBufPos + fragmentPayloadSize;\n            lastUnit = 0;\n        }\n        else {\n            currentLimit = payload->length;\n            lastUnit = 1;\n        }\n\n        writeRfc1006Header(self, 7 + (currentLimit - currentBufPos));\n\n        writeDataTpduHeader(self, lastUnit);\n\n        int bufPos = 7;\n\n        int i;\n        for (i = currentBufPos; i < currentLimit; i++) {\n\n            if (currentChainIndex >= currentChain->partLength) {\n                currentChain = currentChain->nextPart;\n                if (DEBUG_COTP)\n                    printf(\"\\nCOTP: nextBufferPart: len:%i partLen:%i\\n\", currentChain->length, currentChain->partLength);\n                currentChainIndex = 0;\n            }\n\n            buffer[bufPos++] = currentChain->buffer[currentChainIndex];\n\n            currentChainIndex++;\n\n            currentBufPos++;\n        }\n\n        self->writeBuffer->size = bufPos;\n\n        if (DEBUG_COTP)\n            printf(\"COTP: Send COTP fragment %i bufpos: %i\\n\", fragments, currentBufPos);\n\n        if (!sendBuffer(self)) {\n            retValue = COTP_ERROR;\n\n            if (DEBUG_COTP)\n                printf(\"COTP: sending message failed!\\n\");\n\n            goto exit_function;\n        }\n\n\n        fragments--;\n    }\n\nexit_function:\n\n    if (DEBUG_COTP)\n        printf(\"COTP: message transmission finished (fragments=%i, return=%i)\\n\", fragments, retValue);\n\n    return retValue;\n}\n\nstatic void\nallocateWriteBuffer(CotpConnection* self)\n{\n    if (self->writeBuffer == NULL )\n        self->writeBuffer = ByteBuffer_create(NULL,\n                CotpConnection_getTpduSize(self) + TPKT_RFC1006_HEADER_SIZE);\n}\n\n/* client side */\nCotpIndication\nCotpConnection_sendConnectionRequestMessage(CotpConnection* self, IsoConnectionParameters isoParameters)\n{\n    allocateWriteBuffer(self);\n\n    self->options.tSelDst = isoParameters->remoteTSelector;\n    self->options.tSelSrc = isoParameters->localTSelector;\n\n    int cotpRequestSize = getOptionsLength(self) + 6;\n\n    int conRequestSize = cotpRequestSize + 5;\n\n    if(self->writeBuffer->maxSize < conRequestSize)\n        return COTP_ERROR;\n\n    uint8_t* buffer = self->writeBuffer->buffer;\n\n    writeRfc1006Header(self, conRequestSize);\n\n    /* LI */\n    buffer[4] = (uint8_t) cotpRequestSize;\n\n    /* TPDU CODE */\n    buffer[5] = 0xe0;\n\n    /* DST REF */\n    buffer[6] = 0x00;\n    buffer[7] = 0x00;\n\n    /* SRC REF */\n    buffer[8] = (uint8_t) (self->localRef / 0x100);\n    buffer[9] = (uint8_t) (self->localRef & 0xff);\n\n    /* Class */\n    buffer[10] = 0x00;\n\n    self->writeBuffer->size = 11;\n\n    writeOptions(self);\n\n    if (sendBuffer(self))\n        return COTP_OK;\n    else\n        return COTP_ERROR;\n}\n\nCotpIndication\nCotpConnection_sendConnectionResponseMessage(CotpConnection* self)\n{\n    allocateWriteBuffer(self);\n\n    int optionsLength = getOptionsLength(self);\n    int messageLength = 11 + optionsLength;\n\n    writeRfc1006Header(self, messageLength);\n\n    writeStaticConnectResponseHeader(self, optionsLength);\n\n    writeOptions(self);\n\n    if (sendBuffer(self))\n        return COTP_OK;\n    else\n        return COTP_ERROR;\n}\n\nstatic bool\nparseOptions(CotpConnection* self, uint8_t* buffer, int bufLen)\n{\n    int bufPos = 0;\n\n    while (bufPos < bufLen) {\n        uint8_t optionType = buffer[bufPos++];\n        uint8_t optionLen = buffer[bufPos++];\n\n        if (optionLen > (bufLen - bufPos)) {\n            if (DEBUG_COTP)\n                printf(\"COTP: option to long optionLen:%i bufPos:%i bufLen:%i\\n\", optionLen, bufPos, bufLen);\n            goto cpo_error;\n        }\n\n        if (DEBUG_COTP)\n            printf(\"COTP: option: %02x len: %02x\\n\", optionType, optionLen);\n\n        switch (optionType) {\n        case 0xc0:\n\t\t\tif (optionLen == 1) {\n\t\t\t\tint requestedTpduSize = (1 << buffer[bufPos++]);\n\n                CotpConnection_setTpduSize(self, requestedTpduSize);\n\n\t\t\t\tif (DEBUG_COTP)\n\t\t\t\t    printf(\"COTP: requested TPDU size: %i\\n\", requestedTpduSize);\n\t\t\t}\n\t\t\telse\n\t\t\t    goto cpo_error;\n            break;\n\n        case 0xc1: /* remote T-selector */\n            if (optionLen < 5) {\n                self->options.tSelSrc.size = optionLen;\n\n                int i;\n                for (i = 0; i < optionLen; i++)\n                    self->options.tSelSrc.value[i] = buffer[bufPos++];\n            }\n            else\n                goto cpo_error;\n            break;\n\n        case 0xc2: /* local T-selector */\n            if (optionLen < 5) {\n                self->options.tSelDst.size = optionLen;\n\n                int i;\n                for (i = 0; i < optionLen; i++)\n                    self->options.tSelDst.value[i] = buffer[bufPos++];\n            }\n            else\n                goto cpo_error;\n            break;\n\n        case 0xc6: /* additional option selection */\n            if (optionLen == 1)\n                bufPos++; /* ignore value */\n            else\n                goto cpo_error;\n            break;\n\n        default:\n            if (DEBUG_COTP)\n                printf(\"COTP: Unknown option %02x\\n\", optionType);\n\n            bufPos += optionLen; /* ignore value */\n\n            break;\n        }\n    }\n\n    return true;\n\ncpo_error:\n    if (DEBUG_COTP)\n        printf(\"COTP: cotp_parse_options: error parsing options!\\n\");\n    return false;\n}\n\nvoid\nCotpConnection_init(CotpConnection* self, Socket socket,\n        ByteBuffer* payloadBuffer, ByteBuffer* readBuffer, ByteBuffer* writeBuffer)\n{\n    self->state = 0;\n    self->socket = socket;\n#if (CONFIG_MMS_SUPPORT_TLS == 1)\n    self->tlsSocket = NULL;\n#endif\n    self->remoteRef = -1;\n    self->localRef = 1;\n    self->protocolClass = -1;\n\tself->options.tpduSize = 0;\n\n\tTSelector tsel;\n\ttsel.size = 2;\n\ttsel.value[0] = 0;\n\ttsel.value[1] = 1;\n\n\tself->options.tSelSrc = tsel;\n\tself->options.tSelDst = tsel;\n    self->payload = payloadBuffer;\n\n    CotpConnection_resetPayload(self);\n\n    /* default TPDU size is maximum size */\n    CotpConnection_setTpduSize(self, COTP_MAX_TPDU_SIZE);\n\n    self->writeBuffer = writeBuffer;\n    self->readBuffer = readBuffer;\n    self->packetSize = 0;\n}\n\nint /* in byte */\nCotpConnection_getTpduSize(CotpConnection* self)\n{\n    return (1 << self->options.tpduSize);\n}\n\nvoid\nCotpConnection_setTpduSize(CotpConnection* self, int tpduSize /* in byte */)\n{\n    int newTpduSize = 1;\n\n    if (tpduSize > COTP_MAX_TPDU_SIZE)\n        tpduSize = COTP_MAX_TPDU_SIZE;\n\n    while ((1 << newTpduSize) < tpduSize)\n        newTpduSize++;\n\n    if ((1 << newTpduSize) > tpduSize)\n        newTpduSize--;\n\n    self->options.tpduSize = newTpduSize;\n}\n\nByteBuffer*\nCotpConnection_getPayload(CotpConnection* self)\n{\n    return self->payload;\n}\n\nint\nCotpConnection_getRemoteRef(CotpConnection* self)\n{\n    return self->remoteRef;\n}\n\nint\nCotpConnection_getLocalRef(CotpConnection* self)\n{\n    return self->localRef;\n}\n\n/*\n CR TPDU (from RFC 0905):\n\n 1    2        3        4       5   6    7    8    p  p+1...end\n +--+------+---------+---------+---+---+------+-------+---------+\n |LI|CR CDT|     DST - REF     |SRC-REF|CLASS |VARIAB.|USER     |\n |  |1110  |0000 0000|0000 0000|   |   |OPTION|PART   |DATA     |\n +--+------+---------+---------+---+---+------+-------+---------+\n */\n\n\nstatic bool\nparseConnectRequestTpdu(CotpConnection* self, uint8_t* buffer, uint8_t len)\n{\n    if (len < 6)\n        return false;\n\n    self->remoteRef = getUint16(buffer + 2);\n    self->protocolClass = getUint8(buffer + 4);\n\n    return parseOptions(self, buffer + 5, len - 6);\n}\n\nstatic bool\nparseConnectConfirmTpdu(CotpConnection* self, uint8_t* buffer, uint8_t len)\n{\n    if (len < 6)\n        return false;\n\n    self->remoteRef = getUint16(buffer);\n    self->protocolClass = getUint8(buffer + 4);\n\n    return parseOptions(self, buffer + 5, len - 6);\n}\n\nstatic bool\nparseDataTpdu(CotpConnection* self, uint8_t* buffer, uint8_t len)\n{\n    if (len != 2)\n        return false;\n\n    uint8_t flowControl = getUint8(buffer);\n\n    if (flowControl & 0x80)\n        self->isLastDataUnit = true;\n    else\n        self->isLastDataUnit = false;\n\n    return true;\n}\n\nstatic bool\naddPayloadToBuffer(CotpConnection* self, uint8_t* buffer,  int payloadLength)\n{\n    if (payloadLength < 1) {\n        if (DEBUG_COTP)\n            printf(\"COTP: missing payload\\n\");\n\n        return false;\n    }\n\n    if (DEBUG_COTP)\n        printf(\"COTP: add to payload buffer (cur size: %i, len: %i)\\n\", self->payload->size, payloadLength);\n\n    if ((self->payload->size + payloadLength) > self->payload->maxSize)\n        return false;\n\n    memcpy(self->payload->buffer + self->payload->size, buffer, payloadLength);\n\n    self->payload->size += payloadLength;\n\n    return true;\n}\n\nstatic CotpIndication\nparseCotpMessage(CotpConnection* self)\n{\n    uint8_t* buffer = self->readBuffer->buffer + 4;\n    int tpduLength = self->readBuffer->size - 4;\n\n    uint8_t len;\n    uint8_t tpduType;\n\n    len = buffer[0];\n\n    if (len > tpduLength) {\n      if (DEBUG_COTP)\n          printf(\"COTP: parseCotpMessage: len=%d tpduLength=%d\\n\", len, tpduLength);\n\n      return COTP_ERROR;\n    }\n\n    tpduType = buffer[1];\n\n    switch (tpduType) {\n    case 0xe0:\n        if (parseConnectRequestTpdu(self, buffer + 2, len))\n            return COTP_CONNECT_INDICATION;\n        else\n            return COTP_ERROR;\n    case 0xd0:\n        if (parseConnectConfirmTpdu(self, buffer + 2, len))\n            return COTP_CONNECT_INDICATION;\n        else\n            return COTP_ERROR;\n    case 0xf0:\n        if (parseDataTpdu(self, buffer + 2, len)) {\n\n            if (addPayloadToBuffer(self, buffer + 3, tpduLength - 3) != 1)\n                return COTP_ERROR;\n\n            if (self->isLastDataUnit)\n                return COTP_DATA_INDICATION;\n            else\n                return COTP_MORE_FRAGMENTS_FOLLOW;\n        }\n        else\n            return COTP_ERROR;\n    default:\n        return COTP_ERROR;\n    }\n\n}\n\nCotpIndication\nCotpConnection_parseIncomingMessage(CotpConnection* self)\n{\n    CotpIndication indication = parseCotpMessage(self);\n\n    self->readBuffer->size = 0;\n    self->packetSize = 0;\n\n    return indication;\n}\n\nvoid\nCotpConnection_resetPayload(CotpConnection* self)\n{\n    self->payload->size = 0;\n}\n\n\nstatic int\nreadFromSocket(CotpConnection* self, uint8_t* buf, int size)\n{\n#if (CONFIG_MMS_SUPPORT_TLS == 1)\n    if (self->tlsSocket)\n        return TLSSocket_read(self->tlsSocket, buf, size);\n    else\n        return Socket_read(self->socket, buf, size);\n#else\n    return Socket_read(self->socket, buf, size);\n#endif\n}\n\nTpktState\nCotpConnection_readToTpktBuffer(CotpConnection* self)\n{\n    uint8_t* buffer = self->readBuffer->buffer;\n    int bufferSize = self->readBuffer->maxSize;\n    int bufPos = self->readBuffer->size;\n\n    assert (bufferSize > 4);\n\n    int readBytes;\n\n    if (bufPos < 4) {\n\n        readBytes = readFromSocket(self, buffer + bufPos, 4 - bufPos);\n\n        if (readBytes < 0)\n            goto exit_closed;\n\n        if (DEBUG_COTP) {\n            if (readBytes > 0)\n                printf(\"TPKT: read %i bytes from socket\\n\", readBytes);\n        }\n\n        bufPos += readBytes;\n\n        if (bufPos == 4) {\n            if ((buffer[0] == 3) && (buffer[1] == 0)) {\n                self->packetSize = (buffer[2] * 0x100) + buffer[3];\n\n                if (DEBUG_COTP)\n                    printf(\"TPKT: header complete (msg size = %i)\\n\", self->packetSize);\n\n                if (self->packetSize > bufferSize) {\n                    if (DEBUG_COTP) printf(\"TPKT: packet too large\\n\");\n                    goto exit_error;\n                }\n            }\n            else {\n                if (DEBUG_COTP) printf(\"TPKT: failed to decode TPKT header.\\n\");\n                goto exit_error;\n            }\n        }\n        else\n            goto exit_waiting;\n    }\n\n    readBytes = readFromSocket(self, buffer + bufPos, self->packetSize - bufPos);\n\n    if (readBytes < 0)\n        goto exit_closed;\n\n    bufPos += readBytes;\n\n    if (bufPos < self->packetSize)\n       goto exit_waiting;\n\n    if (DEBUG_COTP) printf(\"TPKT: message complete (size = %i)\\n\", self->packetSize);\n\n    self->readBuffer->size = bufPos;\n    return TPKT_PACKET_COMPLETE;\n\nexit_closed:\n    if (DEBUG_COTP) printf(\"TPKT: socket closed or socket error\\n\");\n    return TPKT_ERROR;\n\nexit_error:\n    if (DEBUG_COTP) printf(\"TPKT: Error parsing message\\n\");\n    return TPKT_ERROR;\n\nexit_waiting:\n\n    if (DEBUG_COTP)\n        if (bufPos != 0)\n            printf(\"TPKT: waiting (read %i of %i)\\n\", bufPos, self->packetSize);\n\n    self->readBuffer->size = bufPos;\n    return TPKT_WAITING;\n}\n\n"], "fixing_code": ["/*\n *  cotp.c\n *\n *  ISO 8073 Connection Oriented Transport Protocol over TCP (RFC1006)\n *\n *  Partial implementation of the ISO 8073 COTP (ISO TP0) protocol for MMS.\n *\n *  Copyright 2013-2018 Michael Zillgith\n *\n *  This file is part of libIEC61850.\n *\n *  libIEC61850 is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  libIEC61850 is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with libIEC61850.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  See COPYING file for the complete license text.\n */\n\n#include \"libiec61850_platform_includes.h\"\n#include \"stack_config.h\"\n#include \"cotp.h\"\n#include \"byte_buffer.h\"\n#include \"buffer_chain.h\"\n\n#define TPKT_RFC1006_HEADER_SIZE 4\n\n#define COTP_DATA_HEADER_SIZE 3\n\n#ifdef CONFIG_COTP_MAX_TPDU_SIZE\n#define COTP_MAX_TPDU_SIZE CONFIG_COTP_MAX_TPDU_SIZE\n#else\n#define COTP_MAX_TPDU_SIZE 8192\n#endif\n\n#ifndef DEBUG_COTP\n#define DEBUG_COTP 0\n#endif\n\nstatic bool\naddPayloadToBuffer(CotpConnection* self, uint8_t* buffer, int payloadLength);\n\nstatic uint16_t\ngetUint16(uint8_t* buffer)\n{\n    return (buffer[0] * 0x100) + buffer[1];\n}\n\nstatic uint8_t\ngetUint8(uint8_t* buffer)\n{\n    return buffer[0];\n}\n\nstatic void\nwriteOptions(CotpConnection* self)\n{\n    /* max size = 11 byte */\n    uint8_t* buffer = self->writeBuffer->buffer;\n    int bufPos = self->writeBuffer->size;\n\n    if (self->options.tpduSize != 0) {\n\n        if (DEBUG_COTP)\n            printf(\"COTP: send TPDU size: %i\\n\", CotpConnection_getTpduSize(self));\n\n        buffer[bufPos++] = 0xc0;\n        buffer[bufPos++] = 0x01;\n        buffer[bufPos++] = self->options.tpduSize;\n    }\n\n    if (self->options.tSelDst.size != 0) {\n        buffer[bufPos++] = 0xc2;\n        buffer[bufPos++] = (uint8_t) self->options.tSelDst.size;\n\n        int i;\n        for (i = 0; i < self->options.tSelDst.size; i++)\n            buffer[bufPos++] = (uint8_t) self->options.tSelDst.value[i];\n    }\n\n    if (self->options.tSelSrc.size != 0) {\n        buffer[bufPos++] = 0xc1;\n        buffer[bufPos++] = (uint8_t) self->options.tSelSrc.size;\n\n        int i;\n        for (i = 0; i < self->options.tSelSrc.size; i++)\n            buffer[bufPos++] = (uint8_t) self->options.tSelSrc.value[i];\n    }\n\n    self->writeBuffer->size = bufPos;\n}\n\nstatic int\ngetOptionsLength(CotpConnection* self)\n{\n    int optionsLength = 0;\n\n    if (self->options.tpduSize != 0)\n        optionsLength += 3;\n\n    if (self->options.tSelDst.size != 0)\n        optionsLength += (2 + self->options.tSelDst.size);\n\n    if (self->options.tSelSrc.size != 0)\n        optionsLength += (2 + self->options.tSelSrc.size);\n\n    return optionsLength;\n}\n\nstatic void\nwriteStaticConnectResponseHeader(CotpConnection* self, int optionsLength)\n{\n    /* always same size (7) and same position in buffer */\n    uint8_t* buffer = self->writeBuffer->buffer;\n\n    buffer[4] = 6 + optionsLength;\n    buffer[5] = 0xd0;\n    buffer[6] = (uint8_t) (self->remoteRef / 0x100);\n    buffer[7] = (uint8_t) (self->remoteRef & 0xff);\n    buffer[8] = (uint8_t) (self->localRef / 0x100);\n    buffer[9] = (uint8_t) (self->localRef & 0xff);\n    buffer[10] = (uint8_t) (self->protocolClass);\n\n    self->writeBuffer->size = 11;\n}\n\nstatic void\nwriteRfc1006Header(CotpConnection* self, int len)\n{\n    uint8_t* buffer = self->writeBuffer->buffer;\n\n    buffer[0] = 0x03;\n    buffer[1] = 0x00;\n    buffer[2] = (uint8_t) (len / 0x100);\n    buffer[3] = (uint8_t) (len & 0xff);\n\n    self->writeBuffer->size = 4;\n}\n\nstatic void\nwriteDataTpduHeader(CotpConnection* self, int isLastUnit)\n{\n    /* always 3 byte starting from byte 5 in buffer */\n    uint8_t* buffer = self->writeBuffer->buffer;\n\n    buffer[4] = 0x02;\n    buffer[5] = 0xf0;\n    if (isLastUnit)\n        buffer[6] = 0x80;\n    else\n        buffer[6] = 0x00;\n\n    self->writeBuffer->size = 7;\n}\n\nstatic int\nwriteToSocket(CotpConnection* self, uint8_t* buf, int size)\n{\n#if (CONFIG_MMS_SUPPORT_TLS == 1)\n    if (self->tlsSocket)\n        return TLSSocket_write(self->tlsSocket, buf, size);\n    else\n        return Socket_write(self->socket, buf, size);\n#else\n    return Socket_write(self->socket, buf, size);\n#endif\n}\n\n\nstatic bool\nsendBuffer(CotpConnection* self)\n{\n    int remainingSize = ByteBuffer_getSize(self->writeBuffer);\n    uint8_t* buffer = ByteBuffer_getBuffer(self->writeBuffer);\n\n    bool retVal = false;\n\n    do {\n        int sentBytes = writeToSocket(self, buffer, remainingSize);\n\n        if (sentBytes == -1)\n            goto exit_function;\n\n        buffer += sentBytes;\n        remainingSize -= sentBytes;\n\n    } while (remainingSize > 0);\n\n    retVal = true;\n\n    ByteBuffer_setSize(self->writeBuffer, 0);\n\nexit_function:\n    return retVal;\n}\n\nCotpIndication\nCotpConnection_sendDataMessage(CotpConnection* self, BufferChain payload)\n{\n    CotpIndication retValue = COTP_OK;\n\n    int fragments = 1;\n\n    int fragmentPayloadSize = CotpConnection_getTpduSize(self) - COTP_DATA_HEADER_SIZE;\n\n    if (payload->length > fragmentPayloadSize) { /* Check if segmentation is required? */\n        fragments = payload->length / fragmentPayloadSize;\n\n        if ((payload->length % fragmentPayloadSize) != 0)\n            fragments += 1;\n    }\n\n    int currentBufPos = 0;\n    int currentLimit;\n    int lastUnit;\n\n    BufferChain currentChain = payload;\n    int currentChainIndex = 0;\n\n    if (DEBUG_COTP)\n        printf(\"\\nCOTP: nextBufferPart: len:%i partLen:%i\\n\", currentChain->length, currentChain->partLength);\n\n    uint8_t* buffer = self->writeBuffer->buffer;\n\n    while (fragments > 0) {\n        if (fragments > 1) {\n            currentLimit = currentBufPos + fragmentPayloadSize;\n            lastUnit = 0;\n        }\n        else {\n            currentLimit = payload->length;\n            lastUnit = 1;\n        }\n\n        writeRfc1006Header(self, 7 + (currentLimit - currentBufPos));\n\n        writeDataTpduHeader(self, lastUnit);\n\n        int bufPos = 7;\n\n        int i;\n        for (i = currentBufPos; i < currentLimit; i++) {\n\n            if (currentChainIndex >= currentChain->partLength) {\n                currentChain = currentChain->nextPart;\n                if (DEBUG_COTP)\n                    printf(\"\\nCOTP: nextBufferPart: len:%i partLen:%i\\n\", currentChain->length, currentChain->partLength);\n                currentChainIndex = 0;\n            }\n\n            buffer[bufPos++] = currentChain->buffer[currentChainIndex];\n\n            currentChainIndex++;\n\n            currentBufPos++;\n        }\n\n        self->writeBuffer->size = bufPos;\n\n        if (DEBUG_COTP)\n            printf(\"COTP: Send COTP fragment %i bufpos: %i\\n\", fragments, currentBufPos);\n\n        if (!sendBuffer(self)) {\n            retValue = COTP_ERROR;\n\n            if (DEBUG_COTP)\n                printf(\"COTP: sending message failed!\\n\");\n\n            goto exit_function;\n        }\n\n\n        fragments--;\n    }\n\nexit_function:\n\n    if (DEBUG_COTP)\n        printf(\"COTP: message transmission finished (fragments=%i, return=%i)\\n\", fragments, retValue);\n\n    return retValue;\n}\n\nstatic void\nallocateWriteBuffer(CotpConnection* self)\n{\n    if (self->writeBuffer == NULL )\n        self->writeBuffer = ByteBuffer_create(NULL,\n                CotpConnection_getTpduSize(self) + TPKT_RFC1006_HEADER_SIZE);\n}\n\n/* client side */\nCotpIndication\nCotpConnection_sendConnectionRequestMessage(CotpConnection* self, IsoConnectionParameters isoParameters)\n{\n    allocateWriteBuffer(self);\n\n    self->options.tSelDst = isoParameters->remoteTSelector;\n    self->options.tSelSrc = isoParameters->localTSelector;\n\n    int cotpRequestSize = getOptionsLength(self) + 6;\n\n    int conRequestSize = cotpRequestSize + 5;\n\n    if(self->writeBuffer->maxSize < conRequestSize)\n        return COTP_ERROR;\n\n    uint8_t* buffer = self->writeBuffer->buffer;\n\n    writeRfc1006Header(self, conRequestSize);\n\n    /* LI */\n    buffer[4] = (uint8_t) cotpRequestSize;\n\n    /* TPDU CODE */\n    buffer[5] = 0xe0;\n\n    /* DST REF */\n    buffer[6] = 0x00;\n    buffer[7] = 0x00;\n\n    /* SRC REF */\n    buffer[8] = (uint8_t) (self->localRef / 0x100);\n    buffer[9] = (uint8_t) (self->localRef & 0xff);\n\n    /* Class */\n    buffer[10] = 0x00;\n\n    self->writeBuffer->size = 11;\n\n    writeOptions(self);\n\n    if (sendBuffer(self))\n        return COTP_OK;\n    else\n        return COTP_ERROR;\n}\n\nCotpIndication\nCotpConnection_sendConnectionResponseMessage(CotpConnection* self)\n{\n    allocateWriteBuffer(self);\n\n    int optionsLength = getOptionsLength(self);\n    int messageLength = 11 + optionsLength;\n\n    writeRfc1006Header(self, messageLength);\n\n    writeStaticConnectResponseHeader(self, optionsLength);\n\n    writeOptions(self);\n\n    if (sendBuffer(self))\n        return COTP_OK;\n    else\n        return COTP_ERROR;\n}\n\nstatic bool\nparseOptions(CotpConnection* self, uint8_t* buffer, int bufLen)\n{\n    int bufPos = 0;\n\n    while (bufPos < bufLen) {\n        uint8_t optionType = buffer[bufPos++];\n        uint8_t optionLen = buffer[bufPos++];\n\n        if (optionLen > (bufLen - bufPos)) {\n            if (DEBUG_COTP)\n                printf(\"COTP: option to long optionLen:%i bufPos:%i bufLen:%i\\n\", optionLen, bufPos, bufLen);\n            goto cpo_error;\n        }\n\n        if (DEBUG_COTP)\n            printf(\"COTP: option: %02x len: %02x\\n\", optionType, optionLen);\n\n        switch (optionType) {\n        case 0xc0:\n\t\t\tif (optionLen == 1) {\n\t\t\t\tint requestedTpduSize = (1 << buffer[bufPos++]);\n\n                CotpConnection_setTpduSize(self, requestedTpduSize);\n\n\t\t\t\tif (DEBUG_COTP)\n\t\t\t\t    printf(\"COTP: requested TPDU size: %i\\n\", requestedTpduSize);\n\t\t\t}\n\t\t\telse\n\t\t\t    goto cpo_error;\n            break;\n\n        case 0xc1: /* remote T-selector */\n            if (optionLen < 5) {\n                self->options.tSelSrc.size = optionLen;\n\n                int i;\n                for (i = 0; i < optionLen; i++)\n                    self->options.tSelSrc.value[i] = buffer[bufPos++];\n            }\n            else\n                goto cpo_error;\n            break;\n\n        case 0xc2: /* local T-selector */\n            if (optionLen < 5) {\n                self->options.tSelDst.size = optionLen;\n\n                int i;\n                for (i = 0; i < optionLen; i++)\n                    self->options.tSelDst.value[i] = buffer[bufPos++];\n            }\n            else\n                goto cpo_error;\n            break;\n\n        case 0xc6: /* additional option selection */\n            if (optionLen == 1)\n                bufPos++; /* ignore value */\n            else\n                goto cpo_error;\n            break;\n\n        default:\n            if (DEBUG_COTP)\n                printf(\"COTP: Unknown option %02x\\n\", optionType);\n\n            bufPos += optionLen; /* ignore value */\n\n            break;\n        }\n    }\n\n    return true;\n\ncpo_error:\n    if (DEBUG_COTP)\n        printf(\"COTP: cotp_parse_options: error parsing options!\\n\");\n    return false;\n}\n\nvoid\nCotpConnection_init(CotpConnection* self, Socket socket,\n        ByteBuffer* payloadBuffer, ByteBuffer* readBuffer, ByteBuffer* writeBuffer)\n{\n    self->state = 0;\n    self->socket = socket;\n#if (CONFIG_MMS_SUPPORT_TLS == 1)\n    self->tlsSocket = NULL;\n#endif\n    self->remoteRef = -1;\n    self->localRef = 1;\n    self->protocolClass = -1;\n\tself->options.tpduSize = 0;\n\n\tTSelector tsel;\n\ttsel.size = 2;\n\ttsel.value[0] = 0;\n\ttsel.value[1] = 1;\n\n\tself->options.tSelSrc = tsel;\n\tself->options.tSelDst = tsel;\n    self->payload = payloadBuffer;\n\n    CotpConnection_resetPayload(self);\n\n    /* default TPDU size is maximum size */\n    CotpConnection_setTpduSize(self, COTP_MAX_TPDU_SIZE);\n\n    self->writeBuffer = writeBuffer;\n    self->readBuffer = readBuffer;\n    self->packetSize = 0;\n}\n\nint /* in byte */\nCotpConnection_getTpduSize(CotpConnection* self)\n{\n    return (1 << self->options.tpduSize);\n}\n\nvoid\nCotpConnection_setTpduSize(CotpConnection* self, int tpduSize /* in byte */)\n{\n    int newTpduSize = 1;\n\n    if (tpduSize > COTP_MAX_TPDU_SIZE)\n        tpduSize = COTP_MAX_TPDU_SIZE;\n\n    while ((1 << newTpduSize) < tpduSize)\n        newTpduSize++;\n\n    if ((1 << newTpduSize) > tpduSize)\n        newTpduSize--;\n\n    self->options.tpduSize = newTpduSize;\n}\n\nByteBuffer*\nCotpConnection_getPayload(CotpConnection* self)\n{\n    return self->payload;\n}\n\nint\nCotpConnection_getRemoteRef(CotpConnection* self)\n{\n    return self->remoteRef;\n}\n\nint\nCotpConnection_getLocalRef(CotpConnection* self)\n{\n    return self->localRef;\n}\n\n/*\n CR TPDU (from RFC 0905):\n\n 1    2        3        4       5   6    7    8    p  p+1...end\n +--+------+---------+---------+---+---+------+-------+---------+\n |LI|CR CDT|     DST - REF     |SRC-REF|CLASS |VARIAB.|USER     |\n |  |1110  |0000 0000|0000 0000|   |   |OPTION|PART   |DATA     |\n +--+------+---------+---------+---+---+------+-------+---------+\n */\n\n\nstatic bool\nparseConnectRequestTpdu(CotpConnection* self, uint8_t* buffer, uint8_t len)\n{\n    if (len < 6)\n        return false;\n\n    self->remoteRef = getUint16(buffer + 2);\n    self->protocolClass = getUint8(buffer + 4);\n\n    return parseOptions(self, buffer + 5, len - 6);\n}\n\nstatic bool\nparseConnectConfirmTpdu(CotpConnection* self, uint8_t* buffer, uint8_t len)\n{\n    if (len < 6)\n        return false;\n\n    self->remoteRef = getUint16(buffer);\n    self->protocolClass = getUint8(buffer + 4);\n\n    return parseOptions(self, buffer + 5, len - 6);\n}\n\nstatic bool\nparseDataTpdu(CotpConnection* self, uint8_t* buffer, uint8_t len)\n{\n    if (len != 2)\n        return false;\n\n    uint8_t flowControl = getUint8(buffer);\n\n    if (flowControl & 0x80)\n        self->isLastDataUnit = true;\n    else\n        self->isLastDataUnit = false;\n\n    return true;\n}\n\nstatic bool\naddPayloadToBuffer(CotpConnection* self, uint8_t* buffer,  int payloadLength)\n{\n    if (payloadLength < 1) {\n        if (DEBUG_COTP)\n            printf(\"COTP: missing payload\\n\");\n\n        return false;\n    }\n\n    if (DEBUG_COTP)\n        printf(\"COTP: add to payload buffer (cur size: %i, len: %i)\\n\", self->payload->size, payloadLength);\n\n    if ((self->payload->size + payloadLength) > self->payload->maxSize)\n        return false;\n\n    memcpy(self->payload->buffer + self->payload->size, buffer, payloadLength);\n\n    self->payload->size += payloadLength;\n\n    return true;\n}\n\nstatic CotpIndication\nparseCotpMessage(CotpConnection* self)\n{\n    uint8_t* buffer = self->readBuffer->buffer + 4;\n    int tpduLength = self->readBuffer->size - 4;\n\n    uint8_t len;\n    uint8_t tpduType;\n\n    len = buffer[0];\n\n    if (len > tpduLength) {\n      if (DEBUG_COTP)\n          printf(\"COTP: parseCotpMessage: len=%d tpduLength=%d\\n\", len, tpduLength);\n\n      return COTP_ERROR;\n    }\n\n    tpduType = buffer[1];\n\n    switch (tpduType) {\n    case 0xe0:\n        if (parseConnectRequestTpdu(self, buffer + 2, len))\n            return COTP_CONNECT_INDICATION;\n        else\n            return COTP_ERROR;\n    case 0xd0:\n        if (parseConnectConfirmTpdu(self, buffer + 2, len))\n            return COTP_CONNECT_INDICATION;\n        else\n            return COTP_ERROR;\n    case 0xf0:\n        if (parseDataTpdu(self, buffer + 2, len)) {\n\n            if (addPayloadToBuffer(self, buffer + 3, tpduLength - 3) != 1)\n                return COTP_ERROR;\n\n            if (self->isLastDataUnit)\n                return COTP_DATA_INDICATION;\n            else\n                return COTP_MORE_FRAGMENTS_FOLLOW;\n        }\n        else\n            return COTP_ERROR;\n    default:\n        return COTP_ERROR;\n    }\n\n}\n\nCotpIndication\nCotpConnection_parseIncomingMessage(CotpConnection* self)\n{\n    CotpIndication indication = parseCotpMessage(self);\n\n    self->readBuffer->size = 0;\n    self->packetSize = 0;\n\n    return indication;\n}\n\nvoid\nCotpConnection_resetPayload(CotpConnection* self)\n{\n    self->payload->size = 0;\n}\n\n\nstatic int\nreadFromSocket(CotpConnection* self, uint8_t* buf, int size)\n{\n#if (CONFIG_MMS_SUPPORT_TLS == 1)\n    if (self->tlsSocket)\n        return TLSSocket_read(self->tlsSocket, buf, size);\n    else\n        return Socket_read(self->socket, buf, size);\n#else\n    return Socket_read(self->socket, buf, size);\n#endif\n}\n\nTpktState\nCotpConnection_readToTpktBuffer(CotpConnection* self)\n{\n    uint8_t* buffer = self->readBuffer->buffer;\n    int bufferSize = self->readBuffer->maxSize;\n    int bufPos = self->readBuffer->size;\n\n    assert (bufferSize > 4);\n\n    int readBytes;\n\n    if (bufPos < 4) {\n\n        readBytes = readFromSocket(self, buffer + bufPos, 4 - bufPos);\n\n        if (readBytes < 0)\n            goto exit_closed;\n\n        if (DEBUG_COTP) {\n            if (readBytes > 0)\n                printf(\"TPKT: read %i bytes from socket\\n\", readBytes);\n        }\n\n        bufPos += readBytes;\n\n        if (bufPos == 4) {\n            if ((buffer[0] == 3) && (buffer[1] == 0)) {\n                self->packetSize = (buffer[2] * 0x100) + buffer[3];\n\n                if (DEBUG_COTP)\n                    printf(\"TPKT: header complete (msg size = %i)\\n\", self->packetSize);\n\n                if (self->packetSize > bufferSize) {\n                    if (DEBUG_COTP) printf(\"TPKT: packet too large\\n\");\n                    goto exit_error;\n                }\n            }\n            else {\n                if (DEBUG_COTP) printf(\"TPKT: failed to decode TPKT header.\\n\");\n                goto exit_error;\n            }\n        }\n        else\n            goto exit_waiting;\n    }\n\n    if (self->packetSize <= bufPos)\n        goto exit_error;\n\n    readBytes = readFromSocket(self, buffer + bufPos, self->packetSize - bufPos);\n\n    if (readBytes < 0)\n        goto exit_closed;\n\n    bufPos += readBytes;\n\n    if (bufPos < self->packetSize)\n       goto exit_waiting;\n\n    if (DEBUG_COTP) printf(\"TPKT: message complete (size = %i)\\n\", self->packetSize);\n\n    self->readBuffer->size = bufPos;\n    return TPKT_PACKET_COMPLETE;\n\nexit_closed:\n    if (DEBUG_COTP) printf(\"TPKT: socket closed or socket error\\n\");\n    return TPKT_ERROR;\n\nexit_error:\n    if (DEBUG_COTP) printf(\"TPKT: Error parsing message\\n\");\n    return TPKT_ERROR;\n\nexit_waiting:\n\n    if (DEBUG_COTP)\n        if (bufPos != 0)\n            printf(\"TPKT: waiting (read %i of %i)\\n\", bufPos, self->packetSize);\n\n    self->readBuffer->size = bufPos;\n    return TPKT_WAITING;\n}\n\n"], "filenames": ["src/mms/iso_cotp/cotp.c"], "buggy_code_start_loc": [722], "buggy_code_end_loc": [722], "fixing_code_start_loc": [723], "fixing_code_end_loc": [726], "type": "CWE-191", "message": "In libIEC61850 before version 1.4.3, when a message with COTP message length field with value < 4 is received an integer underflow will happen leading to heap buffer overflow. This can cause an application crash or on some platforms even the execution of remote code. If your application is used in open networks or there are untrusted nodes in the network it is highly recommend to apply the patch. This was patched with commit 033ab5b. Users of version 1.4.x should upgrade to version 1.4.3 when available. As a workaround changes of commit 033ab5b can be applied to older versions.", "other": {"cve": {"id": "CVE-2020-15158", "sourceIdentifier": "security-advisories@github.com", "published": "2020-08-26T18:15:10.287", "lastModified": "2021-11-18T18:35:21.607", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In libIEC61850 before version 1.4.3, when a message with COTP message length field with value < 4 is received an integer underflow will happen leading to heap buffer overflow. This can cause an application crash or on some platforms even the execution of remote code. If your application is used in open networks or there are untrusted nodes in the network it is highly recommend to apply the patch. This was patched with commit 033ab5b. Users of version 1.4.x should upgrade to version 1.4.3 when available. As a workaround changes of commit 033ab5b can be applied to older versions."}, {"lang": "es", "value": "En libIEC61850 versiones anteriores a 1.4.3, cuando un mensaje es recibido con un campo de longitud de mensaje COTP con valor menor a 4, se producir\u00e1 un subdesbordamiento de enteros conllevando a un desbordamiento del b\u00fafer en la pila. Esto puede causar un bloqueo de la aplicaci\u00f3n o, en algunas plataformas, inclusive una ejecuci\u00f3n de c\u00f3digo remota. Si su aplicaci\u00f3n es utilizada en redes abiertas o si existen nodos en la red que no son confiables, se recomienda altamente aplicar el parche. Esto fue parcheado con el commit 033ab5b. Los usuarios de la versi\u00f3n 1.4.x deben actualizar a la versi\u00f3n 1.4.3 cuando est\u00e9 disponible. Como soluci\u00f3n alternativa, los cambios de commit 033ab5b pueden ser aplicados a versiones anteriores"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:C/C:L/I:L/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 7.7, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.3}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-191"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-119"}, {"lang": "en", "value": "CWE-122"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mz-automation:libiec61850:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.4.0", "versionEndExcluding": "1.4.3", "matchCriteriaId": "1E993B84-2A79-45F0-BF40-4AF97ACF6F3D"}]}]}], "references": [{"url": "https://github.com/mz-automation/libiec61850/commit/033ab5b6488250c8c3b838f25a7cbc3e099230bb", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/mz-automation/libiec61850/issues/250", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/mz-automation/libiec61850/security/advisories/GHSA-pq77-fmf7-hjw8", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/mz-automation/libiec61850/commit/033ab5b6488250c8c3b838f25a7cbc3e099230bb"}}