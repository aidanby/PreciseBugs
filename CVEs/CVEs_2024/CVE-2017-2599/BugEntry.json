{"buggy_code": ["/*\n * The MIT License\n * \n * Copyright (c) 2004-2011, Sun Microsystems, Inc., Kohsuke Kawaguchi,\n * Daniel Dyer, Tom Huybrechts, Yahoo!, Inc.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson.model;\n\nimport com.infradna.tool.bridge_method_injector.WithBridgeMethods;\nimport hudson.AbortException;\nimport hudson.XmlFile;\nimport hudson.Util;\nimport hudson.Functions;\nimport hudson.BulkChange;\nimport hudson.cli.declarative.CLIMethod;\nimport hudson.cli.declarative.CLIResolver;\nimport hudson.model.listeners.ItemListener;\nimport hudson.model.listeners.SaveableListener;\nimport hudson.security.AccessControlled;\nimport hudson.security.Permission;\nimport hudson.security.ACL;\nimport hudson.util.AlternativeUiTextProvider;\nimport hudson.util.AlternativeUiTextProvider.Message;\nimport hudson.util.AtomicFileWriter;\nimport hudson.util.IOUtils;\nimport hudson.util.Secret;\nimport jenkins.model.DirectlyModifiableTopLevelItemGroup;\nimport jenkins.model.Jenkins;\nimport jenkins.security.NotReallyRoleSensitiveCallable;\nimport org.acegisecurity.Authentication;\nimport jenkins.util.xml.XMLUtils;\n\nimport org.apache.tools.ant.taskdefs.Copy;\nimport org.apache.tools.ant.types.FileSet;\nimport org.kohsuke.stapler.WebMethod;\nimport org.kohsuke.stapler.export.Exported;\nimport org.kohsuke.stapler.export.ExportedBean;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport javax.annotation.Nonnull;\n\nimport org.kohsuke.stapler.StaplerRequest;\nimport org.kohsuke.stapler.StaplerResponse;\nimport org.kohsuke.stapler.Stapler;\nimport org.kohsuke.stapler.HttpDeletable;\nimport org.kohsuke.args4j.Argument;\nimport org.kohsuke.args4j.CmdLineException;\nimport org.kohsuke.stapler.interceptor.RequirePOST;\nimport org.xml.sax.SAXException;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletOutputStream;\nimport javax.xml.transform.Source;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.stream.StreamResult;\nimport javax.xml.transform.stream.StreamSource;\n\nimport static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;\nimport org.apache.commons.io.FileUtils;\nimport org.kohsuke.accmod.Restricted;\nimport org.kohsuke.accmod.restrictions.NoExternalUse;\nimport org.kohsuke.stapler.Ancestor;\n\n/**\n * Partial default implementation of {@link Item}.\n *\n * @author Kohsuke Kawaguchi\n */\n// Item doesn't necessarily have to be Actionable, but\n// Java doesn't let multiple inheritance.\n@ExportedBean\npublic abstract class AbstractItem extends Actionable implements Item, HttpDeletable, AccessControlled, DescriptorByNameOwner {\n\n    private static final Logger LOGGER = Logger.getLogger(AbstractItem.class.getName());\n\n    /**\n     * Project name.\n     */\n    protected /*final*/ transient String name;\n\n    /**\n     * Project description. Can be HTML.\n     */\n    protected volatile String description;\n\n    private transient ItemGroup parent;\n    \n    protected String displayName;\n\n    protected AbstractItem(ItemGroup parent, String name) {\n        this.parent = parent;\n        doSetName(name);\n    }\n\n    public void onCreatedFromScratch() {\n        // noop\n    }\n\n    @Exported(visibility=999)\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Get the term used in the UI to represent this kind of\n     * {@link Item}. Must start with a capital letter.\n     */\n    public String getPronoun() {\n        return AlternativeUiTextProvider.get(PRONOUN, this, Messages.AbstractItem_Pronoun());\n    }\n\n    @Exported\n    /**\n     * @return The display name of this object, or if it is not set, the name\n     * of the object.\n     */\n    public String getDisplayName() {\n        if(null!=displayName) {\n            return displayName;\n        }\n        // if the displayName is not set, then return the name as we use to do\n        return getName();\n    }\n    \n    @Exported\n    /**\n     * This is intended to be used by the Job configuration pages where\n     * we want to return null if the display name is not set.\n     * @return The display name of this object or null if the display name is not\n     * set\n     */\n    public String getDisplayNameOrNull() {\n        return displayName;\n    }\n    \n    /**\n     * This method exists so that the Job configuration pages can use \n     * getDisplayNameOrNull so that nothing is shown in the display name text\n     * box if the display name is not set.\n     * @param displayName\n     * @throws IOException\n     */\n    public void setDisplayNameOrNull(String displayName) throws IOException {\n        setDisplayName(displayName);\n    }\n    \n    public void setDisplayName(String displayName) throws IOException {\n        this.displayName = Util.fixEmpty(displayName);\n        save();\n    }\n             \n    public File getRootDir() {\n        return getParent().getRootDirFor(this);\n    }\n\n    /**\n     * This bridge method is to maintain binary compatibility with {@link TopLevelItem#getParent()}.\n     */\n    @WithBridgeMethods(value=Jenkins.class,castRequired=true)\n    @Override public @Nonnull ItemGroup getParent() {\n        if (parent == null) {\n            throw new IllegalStateException(\"no parent set on \" + getClass().getName() + \"[\" + name + \"]\");\n        }\n        return parent;\n    }\n\n    /**\n     * Gets the project description HTML.\n     */\n    @Exported\n    public String getDescription() {\n        return description;\n    }\n\n    /**\n     * Sets the project description HTML.\n     */\n    public void setDescription(String description) throws IOException {\n        this.description = description;\n        save();\n        ItemListener.fireOnUpdated(this);\n    }\n\n    /**\n     * Just update {@link #name} without performing the rename operation,\n     * which would involve copying files and etc.\n     */\n    protected void doSetName(String name) {\n        this.name = name;\n    }\n\n    /**\n     * Renames this item.\n     * Not all the Items need to support this operation, but if you decide to do so,\n     * you can use this method.\n     */\n    protected void renameTo(final String newName) throws IOException {\n        // always synchronize from bigger objects first\n        final ItemGroup parent = getParent();\n        String oldName = this.name;\n        String oldFullName = getFullName();\n        synchronized (parent) {\n            synchronized (this) {\n                // sanity check\n                if (newName == null)\n                    throw new IllegalArgumentException(\"New name is not given\");\n\n                // noop?\n                if (this.name.equals(newName))\n                    return;\n\n                // the test to see if the project already exists or not needs to be done in escalated privilege\n                // to avoid overwriting\n                ACL.impersonate(ACL.SYSTEM,new NotReallyRoleSensitiveCallable<Void,IOException>() {\n                    final Authentication user = Jenkins.getAuthentication();\n                    @Override\n                    public Void call() throws IOException {\n                        Item existing = parent.getItem(newName);\n                        if (existing != null && existing!=AbstractItem.this) {\n                            if (existing.getACL().hasPermission(user,Item.DISCOVER))\n                                // the look up is case insensitive, so we need \"existing!=this\"\n                                // to allow people to rename \"Foo\" to \"foo\", for example.\n                                // see http://www.nabble.com/error-on-renaming-project-tt18061629.html\n                                throw new IllegalArgumentException(\"Job \" + newName + \" already exists\");\n                            else {\n                                // can't think of any real way to hide this, but at least the error message could be vague.\n                                throw new IOException(\"Unable to rename to \" + newName);\n                            }\n                        }\n                        return null;\n                    }\n                });\n\n                File oldRoot = this.getRootDir();\n\n                doSetName(newName);\n                File newRoot = this.getRootDir();\n\n                boolean success = false;\n\n                try {// rename data files\n                    boolean interrupted = false;\n                    boolean renamed = false;\n\n                    // try to rename the job directory.\n                    // this may fail on Windows due to some other processes\n                    // accessing a file.\n                    // so retry few times before we fall back to copy.\n                    for (int retry = 0; retry < 5; retry++) {\n                        if (oldRoot.renameTo(newRoot)) {\n                            renamed = true;\n                            break; // succeeded\n                        }\n                        try {\n                            Thread.sleep(500);\n                        } catch (InterruptedException e) {\n                            // process the interruption later\n                            interrupted = true;\n                        }\n                    }\n\n                    if (interrupted)\n                        Thread.currentThread().interrupt();\n\n                    if (!renamed) {\n                        // failed to rename. it must be that some lengthy\n                        // process is going on\n                        // to prevent a rename operation. So do a copy. Ideally\n                        // we'd like to\n                        // later delete the old copy, but we can't reliably do\n                        // so, as before the VM\n                        // shuts down there might be a new job created under the\n                        // old name.\n                        Copy cp = new Copy();\n                        cp.setProject(new org.apache.tools.ant.Project());\n                        cp.setTodir(newRoot);\n                        FileSet src = new FileSet();\n                        src.setDir(oldRoot);\n                        cp.addFileset(src);\n                        cp.setOverwrite(true);\n                        cp.setPreserveLastModified(true);\n                        cp.setFailOnError(false); // keep going even if\n                                                    // there's an error\n                        cp.execute();\n\n                        // try to delete as much as possible\n                        try {\n                            Util.deleteRecursive(oldRoot);\n                        } catch (IOException e) {\n                            // but ignore the error, since we expect that\n                            e.printStackTrace();\n                        }\n                    }\n\n                    success = true;\n                } finally {\n                    // if failed, back out the rename.\n                    if (!success)\n                        doSetName(oldName);\n                }\n\n                try {\n                    parent.onRenamed(this, oldName, newName);\n                } catch (AbstractMethodError _) {\n                    // ignore\n                }\n            }\n        }\n        ItemListener.fireLocationChange(this, oldFullName);\n    }\n\n\n    /**\n     * Notify this item it's been moved to another location, replaced by newItem (might be the same object, but not guaranteed).\n     * This method is executed <em>after</em> the item root directory has been moved to it's new location.\n     * <p>\n     * Derived classes can override this method to add some specific behavior on move, but have to call parent method\n     * so the item is actually setup within it's new parent.\n     *\n     * @see hudson.model.Items#move(AbstractItem, jenkins.model.DirectlyModifiableTopLevelItemGroup)\n     */\n    public void movedTo(DirectlyModifiableTopLevelItemGroup destination, AbstractItem newItem, File destDir) throws IOException {\n        newItem.onLoad(destination, name);\n    }\n\n    /**\n     * Gets all the jobs that this {@link Item} contains as descendants.\n     */\n    public abstract Collection<? extends Job> getAllJobs();\n\n    public final String getFullName() {\n        String n = getParent().getFullName();\n        if(n.length()==0)   return getName();\n        else                return n+'/'+getName();\n    }\n\n    public final String getFullDisplayName() {\n        String n = getParent().getFullDisplayName();\n        if(n.length()==0)   return getDisplayName();\n        else                return n+\" \u00bb \"+getDisplayName();\n    }\n    \n    /**\n     * Gets the display name of the current item relative to the given group.\n     *\n     * @since 1.515\n     * @param p the ItemGroup used as point of reference for the item\n     * @return\n     *      String like \"foo \u00bb bar\"\n     */\n    public String getRelativeDisplayNameFrom(ItemGroup p) {\n        return Functions.getRelativeDisplayNameFrom(this, p);\n    }\n    \n    /**\n     * This method only exists to disambiguate {@link #getRelativeNameFrom(ItemGroup)} and {@link #getRelativeNameFrom(Item)}\n     * @since 1.512\n     * @see #getRelativeNameFrom(ItemGroup)\n     */\n    public String getRelativeNameFromGroup(ItemGroup p) {\n        return getRelativeNameFrom(p);\n    }\n\n    /**\n     * @param p\n     *  The ItemGroup instance used as context to evaluate the relative name of this AbstractItem\n     * @return\n     *  The name of the current item, relative to p.\n     *  Nested ItemGroups are separated by / character.\n     */\n    public String getRelativeNameFrom(ItemGroup p) {\n        return Functions.getRelativeNameFrom(this, p);\n    }\n\n    public String getRelativeNameFrom(Item item) {\n        return getRelativeNameFrom(item.getParent());\n    }\n\n    /**\n     * Called right after when a {@link Item} is loaded from disk.\n     * This is an opportunity to do a post load processing.\n     */\n    public void onLoad(ItemGroup<? extends Item> parent, String name) throws IOException {\n        this.parent = parent;\n        doSetName(name);\n    }\n\n    /**\n     * When a {@link Item} is copied from existing one,\n     * the files are first copied on the file system,\n     * then it will be loaded, then this method will be invoked\n     * to perform any implementation-specific work.\n     *\n     * <p>\n     * \n     *\n     * @param src\n     *      Item from which it's copied from. The same type as {@code this}. Never null.\n     */\n    public void onCopiedFrom(Item src) {\n    }\n\n    public final String getUrl() {\n        // try to stick to the current view if possible\n        StaplerRequest req = Stapler.getCurrentRequest();\n        String shortUrl = getShortUrl();\n        String uri = req == null ? null : req.getRequestURI();\n        if (req != null) {\n            String seed = Functions.getNearestAncestorUrl(req,this);\n            LOGGER.log(Level.FINER, \"seed={0} for {1} from {2}\", new Object[] {seed, this, uri});\n            if(seed!=null) {\n                // trim off the context path portion and leading '/', but add trailing '/'\n                return seed.substring(req.getContextPath().length()+1)+'/';\n            }\n            List<Ancestor> ancestors = req.getAncestors();\n            if (!ancestors.isEmpty()) {\n                Ancestor last = ancestors.get(ancestors.size() - 1);\n                if (last.getObject() instanceof View) {\n                    View view = (View) last.getObject();\n                    if (view.getOwnerItemGroup() == getParent() && !view.isDefault()) {\n                        // Showing something inside a view, so should use that as the base URL.\n                        String base = last.getUrl().substring(req.getContextPath().length() + 1) + '/';\n                        LOGGER.log(Level.FINER, \"using {0}{1} for {2} from {3}\", new Object[] {base, shortUrl, this, uri});\n                        return base + shortUrl;\n                    } else {\n                        LOGGER.log(Level.FINER, \"irrelevant {0} for {1} from {2}\", new Object[] {view.getViewName(), this, uri});\n                    }\n                } else {\n                    LOGGER.log(Level.FINER, \"inapplicable {0} for {1} from {2}\", new Object[] {last.getObject(), this, uri});\n                }\n            } else {\n                LOGGER.log(Level.FINER, \"no ancestors for {0} from {1}\", new Object[] {this, uri});\n            }\n        } else {\n            LOGGER.log(Level.FINER, \"no current request for {0}\", this);\n        }\n        // otherwise compute the path normally\n        String base = getParent().getUrl();\n        LOGGER.log(Level.FINER, \"falling back to {0}{1} for {2} from {3}\", new Object[] {base, shortUrl, this, uri});\n        return base + shortUrl;\n    }\n\n    public String getShortUrl() {\n        String prefix = getParent().getUrlChildPrefix();\n        String subdir = Util.rawEncode(getName());\n        return prefix.equals(\".\") ? subdir + '/' : prefix + '/' + subdir + '/';\n    }\n\n    public String getSearchUrl() {\n        return getShortUrl();\n    }\n\n    @Exported(visibility=999,name=\"url\")\n    public final String getAbsoluteUrl() {\n        String r = Jenkins.getInstance().getRootUrl();\n        if(r==null)\n            throw new IllegalStateException(\"Root URL isn't configured yet. Cannot compute absolute URL.\");\n        return Util.encode(r+getUrl());\n    }\n\n    /**\n     * Remote API access.\n     */\n    public final Api getApi() {\n        return new Api(this);\n    }\n\n    /**\n     * Returns the {@link ACL} for this object.\n     */\n    public ACL getACL() {\n        return Jenkins.getInstance().getAuthorizationStrategy().getACL(this);\n    }\n\n    /**\n     * Short for {@code getACL().checkPermission(p)}\n     */\n    public void checkPermission(Permission p) {\n        getACL().checkPermission(p);\n    }\n\n    /**\n     * Short for {@code getACL().hasPermission(p)}\n     */\n    public boolean hasPermission(Permission p) {\n        return getACL().hasPermission(p);\n    }\n\n    /**\n     * Save the settings to a file.\n     */\n    public synchronized void save() throws IOException {\n        if(BulkChange.contains(this))   return;\n        getConfigFile().write(this);\n        SaveableListener.fireOnChange(this, getConfigFile());\n    }\n\n    public final XmlFile getConfigFile() {\n        return Items.getConfigFile(this);\n    }\n\n    public Descriptor getDescriptorByName(String className) {\n        return Jenkins.getInstance().getDescriptorByName(className);\n    }\n\n    /**\n     * Accepts the new description.\n     */\n    public synchronized void doSubmitDescription( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        checkPermission(CONFIGURE);\n\n        setDescription(req.getParameter(\"description\"));\n        rsp.sendRedirect(\".\");  // go to the top page\n    }\n\n    /**\n     * Deletes this item.\n     * Note on the funny name: for reasons of historical compatibility, this URL is {@code /doDelete}\n     * since it predates {@code <l:confirmationLink>}. {@code /delete} goes to a Jelly page\n     * which should now be unused by core but is left in case plugins are still using it.\n     */\n    @RequirePOST\n    public void doDoDelete( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException, InterruptedException {\n        delete();\n        if (req == null || rsp == null) { // CLI\n            return;\n        }\n        List<Ancestor> ancestors = req.getAncestors();\n        ListIterator<Ancestor> it = ancestors.listIterator(ancestors.size());\n        String url = getParent().getUrl(); // fallback but we ought to get to Jenkins.instance at the root\n        while (it.hasPrevious()) {\n            Object a = it.previous().getObject();\n            if (a instanceof View) {\n                url = ((View) a).getUrl();\n                break;\n            } else if (a instanceof ViewGroup && a != this) {\n                url = ((ViewGroup) a).getUrl();\n                break;\n            }\n        }\n        rsp.sendRedirect2(req.getContextPath() + '/' + url);\n    }\n\n    public void delete( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        try {\n            doDoDelete(req,rsp);\n        } catch (InterruptedException e) {\n            // TODO: allow this in Stapler\n            throw new ServletException(e);\n        }\n    }\n\n    /**\n     * Deletes this item.\n     *\n     * <p>\n     * Any exception indicates the deletion has failed, but {@link AbortException} would prevent the caller\n     * from showing the stack trace. This\n     */\n    public void delete() throws IOException, InterruptedException {\n        checkPermission(DELETE);\n        synchronized (this) { // could just make performDelete synchronized but overriders might not honor that\n            performDelete();\n        } // JENKINS-19446: leave synch block, but JENKINS-22001: still notify synchronously\n        getParent().onDeleted(AbstractItem.this);\n        Jenkins.getInstance().rebuildDependencyGraphAsync();\n    }\n\n    /**\n     * Does the real job of deleting the item.\n     */\n    protected void performDelete() throws IOException, InterruptedException {\n        getConfigFile().delete();\n        Util.deleteRecursive(getRootDir());\n    }\n\n    /**\n     * Accepts <tt>config.xml</tt> submission, as well as serve it.\n     */\n    @WebMethod(name = \"config.xml\")\n    public void doConfigDotXml(StaplerRequest req, StaplerResponse rsp)\n            throws IOException {\n        if (req.getMethod().equals(\"GET\")) {\n            // read\n            rsp.setContentType(\"application/xml\");\n            writeConfigDotXml(rsp.getOutputStream());\n            return;\n        }\n        if (req.getMethod().equals(\"POST\")) {\n            // submission\n            updateByXml((Source)new StreamSource(req.getReader()));\n            return;\n        }\n\n        // huh?\n        rsp.sendError(SC_BAD_REQUEST);\n    }\n\n    static final Pattern SECRET_PATTERN = Pattern.compile(\">(\" + Secret.ENCRYPTED_VALUE_PATTERN + \")<\");\n    /**\n     * Writes {@code config.xml} to the specified output stream.\n     * The user must have at least {@link #EXTENDED_READ}.\n     * If he lacks {@link #CONFIGURE}, then any {@link Secret}s detected will be masked out.\n     */\n    @Restricted(NoExternalUse.class)\n    public void writeConfigDotXml(OutputStream os) throws IOException {\n        checkPermission(EXTENDED_READ);\n        XmlFile configFile = getConfigFile();\n        if (hasPermission(CONFIGURE)) {\n            IOUtils.copy(configFile.getFile(), os);\n        } else {\n            String encoding = configFile.sniffEncoding();\n            String xml = FileUtils.readFileToString(configFile.getFile(), encoding);\n            Matcher matcher = SECRET_PATTERN.matcher(xml);\n            StringBuffer cleanXml = new StringBuffer();\n            while (matcher.find()) {\n                if (Secret.decrypt(matcher.group(1)) != null) {\n                    matcher.appendReplacement(cleanXml, \">********<\");\n                }\n            }\n            matcher.appendTail(cleanXml);\n            org.apache.commons.io.IOUtils.write(cleanXml.toString(), os, encoding);\n        }\n    }\n\n    /**\n     * @deprecated as of 1.473\n     *      Use {@link #updateByXml(Source)}\n     */\n    @Deprecated\n    public void updateByXml(StreamSource source) throws IOException {\n        updateByXml((Source)source);\n    }\n\n    /**\n     * Updates an Item by its XML definition.\n     * @param source source of the Item's new definition.\n     *               The source should be either a <code>StreamSource</code> or a <code>SAXSource</code>, other\n     *               sources may not be handled.\n     * @since 1.473\n     */\n    public void updateByXml(Source source) throws IOException {\n        checkPermission(CONFIGURE);\n        XmlFile configXmlFile = getConfigFile();\n        final AtomicFileWriter out = new AtomicFileWriter(configXmlFile.getFile());\n        try {\n            try {\n                XMLUtils.safeTransform(source, new StreamResult(out));\n                out.close();\n            } catch (TransformerException e) {\n                throw new IOException(\"Failed to persist config.xml\", e);\n            } catch (SAXException e) {\n                throw new IOException(\"Failed to persist config.xml\", e);\n            }\n\n            // try to reflect the changes by reloading\n            Object o = new XmlFile(Items.XSTREAM, out.getTemporaryFile()).unmarshal(this);\n            if (o!=this) {\n                // ensure that we've got the same job type. extending this code to support updating\n                // to different job type requires destroying & creating a new job type\n                throw new IOException(\"Expecting \"+this.getClass()+\" but got \"+o.getClass()+\" instead\");\n            }\n\n            Items.whileUpdatingByXml(new NotReallyRoleSensitiveCallable<Void,IOException>() {\n                @Override public Void call() throws IOException {\n                    onLoad(getParent(), getRootDir().getName());\n                    return null;\n                }\n            });\n            Jenkins.getInstance().rebuildDependencyGraphAsync();\n\n            // if everything went well, commit this new version\n            out.commit();\n            SaveableListener.fireOnChange(this, getConfigFile());\n\n        } finally {\n            out.abort(); // don't leave anything behind\n        }\n    }\n\n    /**\n     * Reloads this job from the disk.\n     *\n     * Exposed through CLI as well.\n     *\n     * TODO: think about exposing this to UI\n     *\n     * @since 1.556\n     */\n    @CLIMethod(name=\"reload-job\")\n    @RequirePOST\n    public void doReload() throws IOException {\n        checkPermission(CONFIGURE);\n\n        // try to reflect the changes by reloading\n        getConfigFile().unmarshal(this);\n        Items.whileUpdatingByXml(new NotReallyRoleSensitiveCallable<Void, IOException>() {\n            @Override\n            public Void call() throws IOException {\n                onLoad(getParent(), getRootDir().getName());\n                return null;\n            }\n        });\n        Jenkins.getInstance().rebuildDependencyGraphAsync();\n\n        SaveableListener.fireOnChange(this, getConfigFile());\n    }\n\n\n    /* (non-Javadoc)\n     * @see hudson.model.AbstractModelObject#getSearchName()\n     */\n    @Override\n    public String getSearchName() {\n        // the search name of abstract items should be the name and not display name.\n        // this will make suggestions use the names and not the display name\n        // so that the links will 302 directly to the thing the user was finding\n        return getName();\n    }\n\n    @Override public String toString() {\n        return super.toString() + '[' + (parent != null ? getFullName() : \"?/\" + name) + ']';\n    }\n\n    /**\n     * Used for CLI binding.\n     */\n    @CLIResolver\n    public static AbstractItem resolveForCLI(\n            @Argument(required=true,metaVar=\"NAME\",usage=\"Job name\") String name) throws CmdLineException {\n        // TODO can this (and its pseudo-override in AbstractProject) share code with GenericItemOptionHandler, used for explicit CLICommand\u2019s rather than CLIMethod\u2019s?\n        AbstractItem item = Jenkins.getInstance().getItemByFullName(name, AbstractItem.class);\n        if (item==null)\n            throw new CmdLineException(null,Messages.AbstractItem_NoSuchJobExists(name,AbstractProject.findNearest(name).getFullName()));\n        return item;\n    }\n\n    /**\n     * Replaceable pronoun of that points to a job. Defaults to \"Job\"/\"Project\" depending on the context.\n     */\n    public static final Message<AbstractItem> PRONOUN = new Message<AbstractItem>();\n\n}\n", "/*\n * The MIT License\n * \n * Copyright (c) 2004-2009, Sun Microsystems, Inc., Kohsuke Kawaguchi, CloudBees, Inc.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson.model;\n\nimport hudson.Util;\nimport hudson.XmlFile;\nimport hudson.model.listeners.ItemListener;\nimport hudson.security.AccessControlled;\nimport hudson.util.CopyOnWriteMap;\nimport hudson.util.Function1;\nimport hudson.util.Secret;\nimport jenkins.model.Jenkins;\nimport jenkins.util.xml.XMLUtils;\nimport org.kohsuke.stapler.StaplerRequest;\nimport org.kohsuke.stapler.StaplerResponse;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.xml.transform.Source;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.stream.StreamResult;\nimport javax.xml.transform.stream.StreamSource;\nimport java.io.File;\nimport java.io.FileFilter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Map;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Matcher;\nimport jenkins.security.NotReallyRoleSensitiveCallable;\nimport org.acegisecurity.AccessDeniedException;\nimport org.xml.sax.SAXException;\n\n/**\n * Defines a bunch of static methods to be used as a \"mix-in\" for {@link ItemGroup}\n * implementations. Not meant for a consumption from outside {@link ItemGroup}s.\n *\n * @author Kohsuke Kawaguchi\n * @see ViewGroupMixIn\n */\npublic abstract class ItemGroupMixIn {\n    /**\n     * {@link ItemGroup} for which we are working.\n     */\n    private final ItemGroup parent;\n    private final AccessControlled acl;\n\n    protected ItemGroupMixIn(ItemGroup parent, AccessControlled acl) {\n        this.parent = parent;\n        this.acl = acl;\n    }\n\n    /*\n    * Callback methods to be implemented by the ItemGroup implementation.\n    */\n\n    /**\n     * Adds a newly created item to the parent.\n     */\n    protected abstract void add(TopLevelItem item);\n\n    /**\n     * Assigns the root directory for a prospective item.\n     */\n    protected abstract File getRootDirFor(String name);\n\n\n/*\n * The rest is the methods that provide meat.\n */\n\n    /**\n     * Loads all the child {@link Item}s.\n     *\n     * @param modulesDir\n     *      Directory that contains sub-directories for each child item.\n     */\n    public static <K,V extends Item> Map<K,V> loadChildren(ItemGroup parent, File modulesDir, Function1<? extends K,? super V> key) {\n        modulesDir.mkdirs(); // make sure it exists\n\n        File[] subdirs = modulesDir.listFiles(new FileFilter() {\n            public boolean accept(File child) {\n                return child.isDirectory();\n            }\n        });\n        CopyOnWriteMap.Tree<K,V> configurations = new CopyOnWriteMap.Tree<K,V>();\n        for (File subdir : subdirs) {\n            try {\n                // Try to retain the identity of an existing child object if we can.\n                V item = (V) parent.getItem(subdir.getName());\n                if (item == null) {\n                    XmlFile xmlFile = Items.getConfigFile(subdir);\n                    if (xmlFile.exists()) {\n                        item = (V) Items.load(parent, subdir);\n                    } else {\n                        Logger.getLogger(ItemGroupMixIn.class.getName()).log(Level.WARNING, \"could not find file \" + xmlFile.getFile());\n                        continue;\n                    }\n                } else {\n                    item.onLoad(parent, subdir.getName());\n                }\n                configurations.put(key.call(item), item);\n            } catch (Exception e) {\n                Logger.getLogger(ItemGroupMixIn.class.getName()).log(Level.WARNING, \"could not load \" + subdir, e);\n            }\n        }\n\n        return configurations;\n    }\n\n    /**\n     * {@link Item} -> name function.\n     */\n    public static final Function1<String,Item> KEYED_BY_NAME = new Function1<String, Item>() {\n        public String call(Item item) {\n            return item.getName();\n        }\n    };\n\n    /**\n     * Creates a {@link TopLevelItem} from the submission of the '/lib/hudson/newFromList/formList'\n     * or throws an exception if it fails.\n     */\n    public synchronized TopLevelItem createTopLevelItem( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        acl.checkPermission(Item.CREATE);\n\n        TopLevelItem result;\n\n        String requestContentType = req.getContentType();\n        if(requestContentType==null)\n            throw new Failure(\"No Content-Type header set\");\n\n        boolean isXmlSubmission = requestContentType.startsWith(\"application/xml\") || requestContentType.startsWith(\"text/xml\");\n\n        String name = req.getParameter(\"name\");\n        if(name==null)\n            throw new Failure(\"Query parameter 'name' is required\");\n\n        {// check if the name looks good\n            Jenkins.checkGoodName(name);\n            name = name.trim();\n            if(parent.getItem(name)!=null)\n                throw new Failure(Messages.Hudson_JobAlreadyExists(name));\n        }\n\n        String mode = req.getParameter(\"mode\");\n        if(mode!=null && mode.equals(\"copy\")) {\n            String from = req.getParameter(\"from\");\n\n            // resolve a name to Item\n            Item src = null;\n            if (!from.startsWith(\"/\"))\n                src = parent.getItem(from);\n            if (src==null)\n                src = Jenkins.getInstance().getItemByFullName(from);\n\n            if(src==null) {\n                if(Util.fixEmpty(from)==null)\n                    throw new Failure(\"Specify which job to copy\");\n                else\n                    throw new Failure(\"No such job: \"+from);\n            }\n            if (!(src instanceof TopLevelItem))\n                throw new Failure(from+\" cannot be copied\");\n\n            result = copy((TopLevelItem) src,name);\n        } else {\n            if(isXmlSubmission) {\n                result = createProjectFromXML(name, req.getInputStream());\n                rsp.setStatus(HttpServletResponse.SC_OK);\n                return result;\n            } else {\n                if(mode==null)\n                    throw new Failure(\"No mode given\");\n                TopLevelItemDescriptor descriptor = Items.all().findByName(mode);\n                if (descriptor == null) {\n                    throw new Failure(\"No item type \u2018\" + mode + \"\u2019 is known\");\n                }\n                descriptor.checkApplicableIn(parent);\n                acl.getACL().checkCreatePermission(parent, descriptor);\n\n                // create empty job and redirect to the project config screen\n                result = createProject(descriptor, name, true);\n            }\n        }\n\n        rsp.sendRedirect2(redirectAfterCreateItem(req, result));\n        return result;\n    }\n\n    /**\n     * Computes the redirection target URL for the newly created {@link TopLevelItem}.\n     */\n    protected String redirectAfterCreateItem(StaplerRequest req, TopLevelItem result) throws IOException {\n        return req.getContextPath()+'/'+result.getUrl()+\"configure\";\n    }\n\n    /**\n     * Copies an existing {@link TopLevelItem} to a new name.\n     */\n    @SuppressWarnings({\"unchecked\"})\n    public synchronized <T extends TopLevelItem> T copy(T src, String name) throws IOException {\n        acl.checkPermission(Item.CREATE);\n        src.checkPermission(Item.EXTENDED_READ);\n        XmlFile srcConfigFile = Items.getConfigFile(src);\n        if (!src.hasPermission(Item.CONFIGURE)) {\n            Matcher matcher = AbstractItem.SECRET_PATTERN.matcher(srcConfigFile.asString());\n            while (matcher.find()) {\n                if (Secret.decrypt(matcher.group(1)) != null) {\n                    // AccessDeniedException2 does not permit a custom message, and anyway redirecting the user to the login screen is obviously pointless.\n                    throw new AccessDeniedException(Messages.ItemGroupMixIn_may_not_copy_as_it_contains_secrets_and_(src.getFullName(), Jenkins.getAuthentication().getName(), Item.PERMISSIONS.title, Item.EXTENDED_READ.name, Item.CONFIGURE.name));\n                }\n            }\n        }\n        src.getDescriptor().checkApplicableIn(parent);\n        acl.getACL().checkCreatePermission(parent, src.getDescriptor());\n\n        T result = (T)createProject(src.getDescriptor(),name,false);\n\n        // copy config\n        Util.copyFile(srcConfigFile.getFile(), Items.getConfigFile(result).getFile());\n\n        // reload from the new config\n        final File rootDir = result.getRootDir();\n        result = Items.whileUpdatingByXml(new NotReallyRoleSensitiveCallable<T,IOException>() {\n            @Override public T call() throws IOException {\n                return (T) Items.load(parent, rootDir);\n            }\n        });\n        result.onCopiedFrom(src);\n\n        add(result);\n        ItemListener.fireOnCopied(src,result);\n        Jenkins.getInstance().rebuildDependencyGraphAsync();\n\n        return result;\n    }\n\n    public synchronized TopLevelItem createProjectFromXML(String name, InputStream xml) throws IOException {\n        acl.checkPermission(Item.CREATE);\n\n        Jenkins.getInstance().getProjectNamingStrategy().checkName(name);\n        if (parent.getItem(name) != null) {\n            throw new IllegalArgumentException(parent.getDisplayName() + \" already contains an item '\" + name + \"'\");\n        }\n        // TODO what if we have no DISCOVER permission on the existing job?\n\n        // place it as config.xml\n        File configXml = Items.getConfigFile(getRootDirFor(name)).getFile();\n        final File dir = configXml.getParentFile();\n        dir.mkdirs();\n        boolean success = false;\n        try {\n            XMLUtils.safeTransform((Source)new StreamSource(xml), new StreamResult(configXml));\n\n            // load it\n            TopLevelItem result = Items.whileUpdatingByXml(new NotReallyRoleSensitiveCallable<TopLevelItem,IOException>() {\n                @Override public TopLevelItem call() throws IOException {\n                    return (TopLevelItem) Items.load(parent, dir);\n                }\n            });\n\n            success = acl.getACL().hasCreatePermission(Jenkins.getAuthentication(), parent, result.getDescriptor())\n                && result.getDescriptor().isApplicableIn(parent);\n\n            add(result);\n\n            ItemListener.fireOnCreated(result);\n            Jenkins.getInstance().rebuildDependencyGraphAsync();\n\n            return result;\n        } catch (TransformerException e) {\n            success = false;\n            throw new IOException(\"Failed to persist config.xml\", e);\n        } catch (SAXException e) {\n            success = false;\n            throw new IOException(\"Failed to persist config.xml\", e);\n        } catch (IOException e) {\n            success = false;\n            throw e;\n        } catch (RuntimeException e) {\n            success = false;\n            throw e;\n        } finally {\n            if (!success) {\n                // if anything fails, delete the config file to avoid further confusion\n                Util.deleteRecursive(dir);\n            }\n        }\n    }\n\n    public synchronized TopLevelItem createProject( TopLevelItemDescriptor type, String name, boolean notify )\n            throws IOException {\n        acl.checkPermission(Item.CREATE);\n        type.checkApplicableIn(parent);\n        acl.getACL().checkCreatePermission(parent, type);\n\n        Jenkins.getInstance().getProjectNamingStrategy().checkName(name);\n        if(parent.getItem(name)!=null)\n            throw new IllegalArgumentException(\"Project of the name \"+name+\" already exists\");\n        // TODO problem with DISCOVER as noted above\n\n        TopLevelItem item = type.newInstance(parent, name);\n        try {\n            callOnCreatedFromScratch(item);\n        } catch (AbstractMethodError e) {\n            // ignore this error. Must be older plugin that doesn't have this method\n        }\n        item.save();\n        add(item);\n        Jenkins.getInstance().rebuildDependencyGraphAsync();\n\n        if (notify)\n            ItemListener.fireOnCreated(item);\n\n        return item;\n    }\n\n    /**\n     * Pointless wrapper to avoid HotSpot problem. See JENKINS-5756\n     */\n    private void callOnCreatedFromScratch(TopLevelItem item) {\n        item.onCreatedFromScratch();\n    }\n}\n", "/*\n * The MIT License\n * \n * Copyright (c) 2004-2009, Sun Microsystems, Inc., Kohsuke Kawaguchi\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson.model;\n\nimport com.thoughtworks.xstream.XStream;\nimport hudson.DescriptorExtensionList;\nimport hudson.Extension;\nimport hudson.XmlFile;\nimport hudson.model.listeners.ItemListener;\nimport hudson.remoting.Callable;\nimport hudson.security.ACL;\nimport hudson.security.AccessControlled;\nimport hudson.triggers.Trigger;\nimport hudson.util.DescriptorList;\nimport hudson.util.EditDistance;\nimport hudson.util.XStream2;\nimport jenkins.model.Jenkins;\nimport org.acegisecurity.Authentication;\nimport org.apache.commons.lang.StringUtils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.Stack;\nimport java.util.StringTokenizer;\nimport javax.annotation.CheckForNull;\nimport javax.annotation.Nonnull;\n\nimport jenkins.model.DirectlyModifiableTopLevelItemGroup;\nimport org.apache.commons.io.FileUtils;\n\n/**\n * Convenience methods related to {@link Item}.\n * \n * @author Kohsuke Kawaguchi\n */\npublic class Items {\n    /**\n     * List of all installed {@link TopLevelItem} types.\n     *\n     * @deprecated as of 1.286\n     *      Use {@link #all()} for read access and {@link Extension} for registration.\n     */\n    @Deprecated\n    public static final List<TopLevelItemDescriptor> LIST = (List)new DescriptorList<TopLevelItem>(TopLevelItem.class);\n\n    /**\n     * Used to behave differently when loading posted configuration as opposed to persisted configuration.\n     * @see Trigger#start\n     * @since 1.482\n     */\n    private static final ThreadLocal<Boolean> updatingByXml = new ThreadLocal<Boolean>() {\n        @Override protected Boolean initialValue() {\n            return false;\n        }\n    };\n\n    /**\n     * Runs a block while making {@link #currentlyUpdatingByXml} be temporarily true.\n     * Use this when you are creating or changing an item.\n     * @param <V> a return value type (may be {@link Void})\n     * @param <T> an error type (may be {@link Error})\n     * @param callable a block, typically running {@link #load} or {@link Item#onLoad}\n     * @return whatever {@code callable} returned\n     * @throws T anything {@code callable} throws\n     * @since 1.546\n     */\n    public static <V,T extends Throwable> V whileUpdatingByXml(Callable<V,T> callable) throws T {\n        updatingByXml.set(true);\n        try {\n            return callable.call();\n        } finally {\n            updatingByXml.set(false);\n        }\n    }\n\n    /**\n     * Checks whether we are in the middle of creating or configuring an item via XML.\n     * Used to determine the {@code newInstance} parameter for {@link Trigger#start}.\n     * @return true if {@link #whileUpdatingByXml} is currently being called, false for example when merely starting Jenkins or reloading from disk\n     * @since 1.546\n     */\n    public static boolean currentlyUpdatingByXml() {\n        return updatingByXml.get();\n    }\n\n    /**\n     * Returns all the registered {@link TopLevelItemDescriptor}s.\n     */\n    public static DescriptorExtensionList<TopLevelItem,TopLevelItemDescriptor> all() {\n        return Jenkins.getInstance().<TopLevelItem,TopLevelItemDescriptor>getDescriptorList(TopLevelItem.class);\n    }\n\n    /**\n     * Returns all the registered {@link TopLevelItemDescriptor}s that the current security principal is allowed to\n     * create within the specified item group.\n     *\n     * @since TODO\n     */\n    public static List<TopLevelItemDescriptor> all(ItemGroup c) {\n        return all(Jenkins.getAuthentication(), c);\n    }\n\n    /**\n     * Returns all the registered {@link TopLevelItemDescriptor}s that the specified security principal is allowed to\n     * create within the specified item group.\n     *\n     * @since TODO\n     */\n    public static List<TopLevelItemDescriptor> all(Authentication a, ItemGroup c) {\n        List<TopLevelItemDescriptor> result = new ArrayList<TopLevelItemDescriptor>();\n        ACL acl;\n        if (c instanceof AccessControlled) {\n            acl = ((AccessControlled) c).getACL();\n        } else {\n            // fall back to root\n            acl = Jenkins.getInstance().getACL();\n        }\n        for (TopLevelItemDescriptor d: all()) {\n            if (acl.hasCreatePermission(a, c, d) && d.isApplicableIn(c)) {\n                result.add(d);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @deprecated Underspecified what the parameter is. {@link Descriptor#getId}? A {@link Describable} class name?\n     */\n    public static TopLevelItemDescriptor getDescriptor(String fqcn) {\n        return Descriptor.find(all(), fqcn);\n    }\n\n    /**\n     * Converts a list of items into a comma-separated list of full names.\n     */\n    public static String toNameList(Collection<? extends Item> items) {\n        StringBuilder buf = new StringBuilder();\n        for (Item item : items) {\n            if(buf.length()>0)\n                buf.append(\", \");\n            buf.append(item.getFullName());\n        }\n        return buf.toString();\n    }\n\n    /**\n     * @deprecated as of 1.406\n     *      Use {@link #fromNameList(ItemGroup, String, Class)}\n     */\n    @Deprecated\n    public static <T extends Item> List<T> fromNameList(String list, Class<T> type) {\n        return fromNameList(null,list,type);\n    }\n\n    /**\n     * Does the opposite of {@link #toNameList(Collection)}.\n     */\n    public static <T extends Item> List<T> fromNameList(ItemGroup context, @Nonnull String list, @Nonnull Class<T> type) {\n        Jenkins hudson = Jenkins.getInstance();\n\n        List<T> r = new ArrayList<T>();\n        StringTokenizer tokens = new StringTokenizer(list,\",\");\n        while(tokens.hasMoreTokens()) {\n            String fullName = tokens.nextToken().trim();\n            T item = hudson.getItem(fullName, context, type);\n            if(item!=null)\n                r.add(item);\n        }\n        return r;\n    }\n\n    /**\n     * Computes the canonical full name of a relative path in an {@link ItemGroup} context, handling relative\n     * positions \"..\" and \".\" as absolute path starting with \"/\". The resulting name is the item fullName from Jenkins\n     * root.\n     */\n    public static String getCanonicalName(ItemGroup context, String path) {\n        String[] c = context.getFullName().split(\"/\");\n        String[] p = path.split(\"/\");\n\n        Stack<String> name = new Stack<String>();\n        for (int i=0; i<c.length;i++) {\n            if (i==0 && c[i].equals(\"\")) continue;\n            name.push(c[i]);\n        }\n        for (int i=0; i<p.length;i++) {\n            if (i==0 && p[i].equals(\"\")) {\n                // Absolute path starting with a \"/\"\n                name.clear();\n                continue;\n            }\n            if (p[i].equals(\"..\")) {\n                if (name.size() == 0) {\n                    throw new IllegalArgumentException(String.format(\n                            \"Illegal relative path '%s' within context '%s'\", path, context.getFullName()\n                    ));\n                }\n                name.pop();\n                continue;\n            }\n            if (p[i].equals(\".\")) {\n                continue;\n            }\n            name.push(p[i]);\n        }\n        return StringUtils.join(name, '/');\n    }\n\n    /**\n     * Computes the relative name of list of items after a rename or move occurred.\n     * Used to manage job references as names in plugins to support {@link hudson.model.listeners.ItemListener#onLocationChanged}.\n     * <p>\n     * In a hierarchical context, when a plugin has a reference to a job as <code>../foo/bar</code> this method will\n     * handle the relative path as \"foo\" is renamed to \"zot\" to compute <code>../zot/bar</code>\n     *\n     * @param oldFullName the old full name of the item\n     * @param newFullName the new full name of the item\n     * @param relativeNames coma separated list of Item relative names\n     * @param context the {link ItemGroup} relative names refer to\n     * @return relative name for the renamed item, based on the same ItemGroup context\n     */\n    public static String computeRelativeNamesAfterRenaming(String oldFullName, String newFullName, String relativeNames, ItemGroup context) {\n\n        StringTokenizer tokens = new StringTokenizer(relativeNames,\",\");\n        List<String> newValue = new ArrayList<String>();\n        while(tokens.hasMoreTokens()) {\n            String relativeName = tokens.nextToken().trim();\n            String canonicalName = getCanonicalName(context, relativeName);\n            if (canonicalName.equals(oldFullName) || canonicalName.startsWith(oldFullName+'/')) {\n                String newCanonicalName = newFullName + canonicalName.substring(oldFullName.length());\n                if (relativeName.startsWith(\"/\")) {\n                    newValue.add(\"/\" + newCanonicalName);\n                } else {\n                    newValue.add(getRelativeNameFrom(newCanonicalName, context.getFullName()));\n                }\n            } else {\n                newValue.add(relativeName);\n            }\n        }\n        return StringUtils.join(newValue, \",\");\n    }\n\n    // Had difficulty adapting the version in Functions to use no live items, so rewrote it:\n    static String getRelativeNameFrom(String itemFullName, String groupFullName) {\n        String[] itemFullNameA = itemFullName.isEmpty() ? new String[0] : itemFullName.split(\"/\");\n        String[] groupFullNameA = groupFullName.isEmpty() ? new String[0] : groupFullName.split(\"/\");\n        for (int i = 0; ; i++) {\n            if (i == itemFullNameA.length) {\n                if (i == groupFullNameA.length) {\n                    // itemFullName and groupFullName are identical\n                    return \".\";\n                } else {\n                    // itemFullName is an ancestor of groupFullName; insert ../ for rest of groupFullName\n                    StringBuilder b = new StringBuilder();\n                    for (int j = 0; j < groupFullNameA.length - itemFullNameA.length; j++) {\n                        if (j > 0) {\n                            b.append('/');\n                        }\n                        b.append(\"..\");\n                    }\n                    return b.toString();\n                }\n            } else if (i == groupFullNameA.length) {\n                // groupFullName is an ancestor of itemFullName; insert rest of itemFullName\n                StringBuilder b = new StringBuilder();\n                for (int j = i; j < itemFullNameA.length; j++) {\n                    if (j > i) {\n                        b.append('/');\n                    }\n                    b.append(itemFullNameA[j]);\n                }\n                return b.toString();\n            } else if (itemFullNameA[i].equals(groupFullNameA[i])) {\n                // identical up to this point\n                continue;\n            } else {\n                // first mismatch; insert ../ for rest of groupFullName, then rest of itemFullName\n                StringBuilder b = new StringBuilder();\n                for (int j = i; j < groupFullNameA.length; j++) {\n                    if (j > i) {\n                        b.append('/');\n                    }\n                    b.append(\"..\");\n                }\n                for (int j = i; j < itemFullNameA.length; j++) {\n                    b.append('/').append(itemFullNameA[j]);\n                }\n                return b.toString();\n            }\n        }\n    }\n\n    /**\n     * Loads a {@link Item} from a config file.\n     *\n     * @param dir\n     *      The directory that contains the config file, not the config file itself.\n     */\n    public static Item load(ItemGroup parent, File dir) throws IOException {\n        Item item = (Item)getConfigFile(dir).read();\n        item.onLoad(parent,dir.getName());\n        return item;\n    }\n\n    /**\n     * The file we save our configuration.\n     */\n    public static XmlFile getConfigFile(File dir) {\n        return new XmlFile(XSTREAM,new File(dir,\"config.xml\"));\n    }\n\n    /**\n     * The file we save our configuration.\n     */\n    public static XmlFile getConfigFile(Item item) {\n        return getConfigFile(item.getRootDir());\n    }\n    \n    /**\n     * Gets all the {@link Item}s recursively in the {@link ItemGroup} tree\n     * and filter them by the given type.\n     * \n     * @since 1.512\n     */\n    public static <T extends Item> List<T> getAllItems(final ItemGroup root, Class<T> type) {\n        List<T> r = new ArrayList<T>();\n        getAllItems(root, type, r);\n        return r;\n    }\n    private static <T extends Item> void getAllItems(final ItemGroup root, Class<T> type, List<T> r) {\n        List<Item> items = new ArrayList<Item>(((ItemGroup<?>) root).getItems());\n        Collections.sort(items, new Comparator<Item>() {\n            @Override public int compare(Item i1, Item i2) {\n                return name(i1).compareToIgnoreCase(name(i2));\n            }\n            String name(Item i) {\n                String n = i.getName();\n                if (i instanceof ItemGroup) {\n                    n += '/';\n                }\n                return n;\n            }\n        });\n        for (Item i : items) {\n            if (type.isInstance(i)) {\n                if (i.hasPermission(Item.READ)) {\n                    r.add(type.cast(i));\n                }\n            }\n            if (i instanceof ItemGroup) {\n                getAllItems((ItemGroup) i, type, r);\n            }\n        }\n    }\n\n    /**\n     * Finds an item whose name (when referenced from the specified context) is closest to the given name.\n     * @param <T> the type of item being considered\n     * @param type same as {@code T}\n     * @param name the supplied name\n     * @param context a context to start from (used to compute relative names)\n     * @return the closest available item\n     * @since 1.538\n     */\n    public static @CheckForNull <T extends Item> T findNearest(Class<T> type, String name, ItemGroup context) {\n        List<T> projects = Jenkins.getInstance().getAllItems(type);\n        String[] names = new String[projects.size()];\n        for (int i = 0; i < projects.size(); i++) {\n            names[i] = projects.get(i).getRelativeNameFrom(context);\n        }\n        String nearest = EditDistance.findNearest(name, names);\n        return Jenkins.getInstance().getItem(nearest, context, type);\n    }\n\n    /**\n     * Moves an item between folders (or top level).\n     * Fires all relevant events but does not verify that the item\u2019s directory is not currently being used in some way (for example by a running build).\n     * Does not check any permissions.\n     * @param item some item (job or folder)\n     * @param destination the destination of the move (a folder or {@link Jenkins}); not the current parent (or you could just call {@link AbstractItem#renameTo})\n     * @return the new item (usually the same object as {@code item})\n     * @throws IOException if the move fails, or some subsequent step fails (directory might have already been moved)\n     * @throws IllegalArgumentException if the move would really be a rename, or the destination cannot accept the item, or the destination already has an item of that name\n     * @since 1.548\n     */\n    public static <I extends AbstractItem & TopLevelItem> I move(I item, DirectlyModifiableTopLevelItemGroup destination) throws IOException, IllegalArgumentException {\n        DirectlyModifiableTopLevelItemGroup oldParent = (DirectlyModifiableTopLevelItemGroup) item.getParent();\n        if (oldParent == destination) {\n            throw new IllegalArgumentException();\n        }\n        // TODO verify that destination is to not equal to, or inside, item\n        if (!destination.canAdd(item)) {\n            throw new IllegalArgumentException();\n        }\n        String name = item.getName();\n        if (destination.getItem(name) != null) {\n            throw new IllegalArgumentException(name + \" already exists\");\n        }\n        String oldFullName = item.getFullName();\n        // TODO AbstractItem.renameTo has a more baroque implementation; factor it out into a utility method perhaps?\n        File destDir = destination.getRootDirFor(item);\n        FileUtils.forceMkdir(destDir.getParentFile());\n        FileUtils.moveDirectory(item.getRootDir(), destDir);\n        oldParent.remove(item);\n        I newItem = destination.add(item, name);\n        item.movedTo(destination, newItem, destDir);\n        ItemListener.fireLocationChange(newItem, oldFullName);\n        return newItem;\n    }\n\n    /**\n     * Used to load/save job configuration.\n     *\n     * When you extend {@link Job} in a plugin, try to put the alias so\n     * that it produces a reasonable XML.\n     */\n    public static final XStream XSTREAM = new XStream2();\n\n    /**\n     * Alias to {@link #XSTREAM} so that one can access additional methods on {@link XStream2} more easily.\n     */\n    public static final XStream2 XSTREAM2 = (XStream2)XSTREAM;\n\n    static {\n        XSTREAM.alias(\"project\",FreeStyleProject.class);\n    }\n}\n", "/*\n * The MIT License\n *\n * Copyright (c) 2004-2009, Sun Microsystems, Inc., Kohsuke Kawaguchi\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson.model;\n\nimport com.gargoylesoftware.htmlunit.ElementNotFoundException\nimport com.gargoylesoftware.htmlunit.FailingHttpStatusCodeException;\nimport com.gargoylesoftware.htmlunit.HttpMethod\nimport com.gargoylesoftware.htmlunit.WebRequest;\nimport hudson.tasks.BuildStepMonitor;\nimport hudson.tasks.Recorder;\nimport com.gargoylesoftware.htmlunit.html.HtmlPage\nimport hudson.maven.MavenModuleSet;\nimport hudson.security.*;\nimport hudson.tasks.Shell;\nimport hudson.scm.NullSCM;\nimport hudson.scm.SCM\nimport hudson.scm.SCMDescriptor\nimport hudson.Launcher;\nimport hudson.FilePath;\nimport hudson.Functions;\nimport hudson.Util;\nimport hudson.tasks.ArtifactArchiver\nimport hudson.triggers.SCMTrigger;\nimport hudson.triggers.TimerTrigger\nimport hudson.triggers.Trigger\nimport hudson.triggers.TriggerDescriptor;\nimport hudson.util.StreamTaskListener;\nimport hudson.util.OneShotEvent\nimport jenkins.model.Jenkins;\nimport org.jvnet.hudson.test.HudsonTestCase\nimport org.jvnet.hudson.test.Issue;\nimport org.jvnet.hudson.test.TestExtension;\nimport org.jvnet.hudson.test.recipes.PresetData;\nimport org.jvnet.hudson.test.recipes.PresetData.DataSet\nimport org.apache.commons.io.FileUtils;\n\nimport org.jvnet.hudson.test.MockFolder\n\n/**\n * @author Kohsuke Kawaguchi\n */\npublic class AbstractProjectTest extends HudsonTestCase {\n    public void testConfigRoundtrip() {\n        def project = createFreeStyleProject();\n        def l = jenkins.getLabel(\"foo && bar\");\n        project.assignedLabel = l;\n        configRoundtrip((Item) project);\n\n        assert l == project.getAssignedLabel();\n    }\n\n    /**\n     * Tests the workspace deletion.\n     */\n    public void testWipeWorkspace() {\n        def project = createFreeStyleProject();\n        project.buildersList.add(new Shell(\"echo hello\"));\n\n        def b = project.scheduleBuild2(0).get();\n\n        assert b.workspace.exists(): \"Workspace should exist by now\";\n\n        project.doDoWipeOutWorkspace();\n\n        assert !b.workspace.exists(): \"Workspace should be gone by now\";\n    }\n\n    /**\n     * Makes sure that the workspace deletion is protected.\n     */\n    @PresetData(DataSet.NO_ANONYMOUS_READACCESS)\n    public void testWipeWorkspaceProtected() {\n        def project = createFreeStyleProject();\n        project.getBuildersList().add(new Shell(\"echo hello\"));\n\n        def b = project.scheduleBuild2(0).get();\n\n        assert b.getWorkspace().exists(): \"Workspace should exist by now\";\n\n        // make sure that the action link is protected\n        com.gargoylesoftware.htmlunit.WebClient wc = createWebClient();\n        try {\n            wc.getPage(new WebRequest(new URL(wc.getContextPath() + project.getUrl() + \"doWipeOutWorkspace\"), HttpMethod.POST));\n            fail(\"Expected HTTP status code 403\")\n        } catch (FailingHttpStatusCodeException e) {\n            assertEquals(HttpURLConnection.HTTP_FORBIDDEN, e.getStatusCode());\n        }\n    }\n\n    /**\n     * Makes sure that the workspace deletion link is not provided\n     * when the user doesn't have an access.\n     */\n    @PresetData(DataSet.ANONYMOUS_READONLY)\n    public void testWipeWorkspaceProtected2() {\n        ((GlobalMatrixAuthorizationStrategy) jenkins.getAuthorizationStrategy()).add(AbstractProject.WORKSPACE,\"anonymous\");\n\n        // make sure that the deletion is protected in the same way\n        testWipeWorkspaceProtected();\n\n        // there shouldn't be any \"wipe out workspace\" link for anonymous user\n        def webClient = createWebClient();\n        HtmlPage page = webClient.getPage(jenkins.getItem(\"test0\"));\n\n        page = (HtmlPage)page.getAnchorByText(\"Workspace\").click();\n        try {\n        \tString wipeOutLabel = ResourceBundle.getBundle(\"hudson/model/AbstractProject/sidepanel\").getString(\"Wipe Out Workspace\");\n\t\tpage.getAnchorByText(wipeOutLabel);\n            fail(\"shouldn't find a link\");\n        } catch (ElementNotFoundException e) {\n            // OK\n        }\n    }\n\n    /**\n     * Tests the &lt;optionalBlock @field> round trip behavior by using {@link AbstractProject#concurrentBuild}\n     */\n    public void testOptionalBlockDataBindingRoundtrip() {\n        def p = createFreeStyleProject();\n        [true,false].each { b ->\n            p.concurrentBuild = b;\n            submit(createWebClient().getPage(p,\"configure\").getFormByName(\"config\"));\n            assert b==p.isConcurrentBuild();\n        }\n    }\n\n    /**\n     * Tests round trip configuration of the blockBuildWhenUpstreamBuilding field\n     */\n    @Issue(\"JENKINS-4423\")\n    public void testConfiguringBlockBuildWhenUpstreamBuildingRoundtrip() {\n        def p = createFreeStyleProject();\n        p.blockBuildWhenUpstreamBuilding = false;\n\n        def form = createWebClient().getPage(p, \"configure\").getFormByName(\"config\");\n        def input = form.getInputByName(\"blockBuildWhenUpstreamBuilding\");\n        assert !input.isChecked(): \"blockBuildWhenUpstreamBuilding check box is checked.\";\n\n        input.setChecked(true);\n        submit(form);\n        assert p.blockBuildWhenUpstreamBuilding: \"blockBuildWhenUpstreamBuilding was not updated from configuration form\";\n\n        form = createWebClient().getPage(p, \"configure\").getFormByName(\"config\");\n        input = form.getInputByName(\"blockBuildWhenUpstreamBuilding\");\n        assert input.isChecked(): \"blockBuildWhenUpstreamBuilding check box is not checked.\";\n    }\n\n    /**\n     * Unless the concurrent build option is enabled, polling and build should be mutually exclusive\n     * to avoid allocating unnecessary workspaces.\n     */\n    @Issue(\"JENKINS-4202\")\n    public void testPollingAndBuildExclusion() {\n        final OneShotEvent sync = new OneShotEvent();\n\n        final FreeStyleProject p = createFreeStyleProject();\n        def b1 = buildAndAssertSuccess(p);\n\n        p.scm = new NullSCM() {\n            @Override\n            public boolean pollChanges(AbstractProject project, Launcher launcher, FilePath workspace, TaskListener listener) {\n                try {\n                    sync.block();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                return true;\n            }\n\n            /**\n             * Don't write 'this', so that subtypes can be implemented as anonymous class.\n             */\n            private Object writeReplace() { return new Object(); }\n\n            @Override public boolean requiresWorkspaceForPolling() {\n                return true;\n            }\n            @Override public SCMDescriptor<?> getDescriptor() {\n                return new SCMDescriptor<SCM>(null) {\n                    @Override public String getDisplayName() {\n                        return \"\";\n                    }\n                };\n            }\n        };\n        Thread t = new Thread() {\n            @Override public void run() {\n                p.pollSCMChanges(StreamTaskListener.fromStdout());\n            }\n        };\n        try {\n            t.start();\n            def f = p.scheduleBuild2(0);\n\n            // add a bit of delay to make sure that the blockage is happening\n            Thread.sleep(3000);\n\n            // release the polling\n            sync.signal();\n\n            def b2 = assertBuildStatusSuccess(f);\n\n            // they should have used the same workspace.\n            assert b1.workspace == b2.workspace;\n        } finally {\n            t.interrupt();\n        }\n    }\n\n    @Issue(\"JENKINS-1986\")\n    public void testBuildSymlinks() {\n        // If we're on Windows, don't bother doing this.\n        if (Functions.isWindows())\n            return;\n\n        def job = createFreeStyleProject();\n        job.buildersList.add(new Shell(\"echo \\\"Build #\\$BUILD_NUMBER\\\"\\n\"));\n        def build = job.scheduleBuild2(0, new Cause.UserCause()).get();\n        File lastSuccessful = new File(job.rootDir, \"lastSuccessful\"),\n             lastStable = new File(job.rootDir, \"lastStable\");\n        // First build creates links\n        assertSymlinkForBuild(lastSuccessful, 1);\n        assertSymlinkForBuild(lastStable, 1);\n        FreeStyleBuild build2 = job.scheduleBuild2(0, new Cause.UserCause()).get();\n        // Another build updates links\n        assertSymlinkForBuild(lastSuccessful, 2);\n        assertSymlinkForBuild(lastStable, 2);\n        // Delete latest build should update links\n        build2.delete();\n        assertSymlinkForBuild(lastSuccessful, 1);\n        assertSymlinkForBuild(lastStable, 1);\n        // Delete all builds should remove links\n        build.delete();\n        assert !lastSuccessful.exists(): \"lastSuccessful link should be removed\";\n        assert !lastStable.exists(): \"lastStable link should be removed\";\n    }\n\n    private static void assertSymlinkForBuild(File file, int buildNumber)\n            throws IOException, InterruptedException {\n        assert file.exists(): \"should exist and point to something that exists\";\n        assert Util.isSymlink(file): \"should be symlink\";\n        String s = FileUtils.readFileToString(new File(file, \"log\"));\n        assert s.contains(\"Build #\" + buildNumber + \"\\n\") : \"link should point to build #$buildNumber, but link was: ${Util.resolveSymlink(file, TaskListener.NULL)}\\nand log was:\\n$s\";\n    }\n\n    @Issue(\"JENKINS-2543\")\n    public void testSymlinkForPostBuildFailure() {\n        // If we're on Windows, don't bother doing this.\n        if (Functions.isWindows())\n            return;\n\n        // Links should be updated after post-build actions when final build result is known\n        def job = createFreeStyleProject();\n        job.buildersList.add(new Shell(\"echo \\\"Build #\\$BUILD_NUMBER\\\"\\n\"));\n        def build = job.scheduleBuild2(0, new Cause.UserCause()).get();\n        assert Result.SUCCESS == build.result;\n        File lastSuccessful = new File(job.rootDir, \"lastSuccessful\"),\n             lastStable = new File(job.rootDir, \"lastStable\");\n        // First build creates links\n        assertSymlinkForBuild(lastSuccessful, 1);\n        assertSymlinkForBuild(lastStable, 1);\n        // Archive artifacts that don't exist to create failure in post-build action\n        job.publishersList.add(new ArtifactArchiver(\"*.foo\", \"\", false, false));\n        build = job.scheduleBuild2(0, new Cause.UserCause()).get();\n        assert Result.FAILURE == build.getResult();\n        // Links should not be updated since build failed\n        assertSymlinkForBuild(lastSuccessful, 1);\n        assertSymlinkForBuild(lastStable, 1);\n    }\n\n    /* TODO too slow, seems capable of causing testWorkspaceLock to time out:\n    @Issue(\"JENKINS-15156\")\n    public void testGetBuildAfterGC() {\n        FreeStyleProject job = createFreeStyleProject();\n        job.scheduleBuild2(0, new Cause.UserIdCause()).get();\n        jenkins.queue.clearLeftItems();\n        MemoryAssert.assertGC(new WeakReference(job.getLastBuild()));\n        assert job.lastBuild != null;\n    }\n    */\n\n    @Issue(\"JENKINS-17137\")\n    public void testExternalBuildDirectorySymlinks() {\n        // TODO when using JUnit 4 add: Assume.assumeFalse(Functions.isWindows()); // symlinks may not be available\n        def form = createWebClient().goTo(\"configure\").getFormByName(\"config\");\n        def builds = createTmpDir();\n        form.getInputByName(\"_.rawBuildsDir\").valueAttribute = builds.toString() + \"/\\${ITEM_FULL_NAME}\";\n        submit(form);\n        assert builds.toString() + \"/\\${ITEM_FULL_NAME}\" == jenkins.getRawBuildsDir();\n        def p = jenkins.createProject(MockFolder.class, \"d\").createProject(FreeStyleProject.class, \"p\");\n        def b1 = p.scheduleBuild2(0).get();\n        def link = new File(p.rootDir, \"lastStable\");\n        assert link.exists();\n        assert b1.rootDir.absolutePath == resolveAll(link).absolutePath;\n        def b2 = p.scheduleBuild2(0).get();\n        assert link.exists();\n        assert b2.rootDir.absolutePath == resolveAll(link).absolutePath;\n        b2.delete();\n        assert link.exists();\n        assert b1.rootDir.absolutePath == resolveAll(link).absolutePath;\n        b1.delete();\n        assert !link.exists();\n    }\n\n    private File resolveAll(File link) throws InterruptedException, IOException {\n        while (true) {\n            File f = Util.resolveSymlinkToFile(link);\n            if (f==null)    return link;\n            link = f;\n        }\n    }\n\n    @Issue(\"JENKINS-17138\")\n    public void testExternalBuildDirectoryRenameDelete() {\n        def form = createWebClient().goTo(\"configure\").getFormByName(\"config\");\n        def builds = createTmpDir();\n        form.getInputByName(\"_.rawBuildsDir\").setValueAttribute(builds.toString() + \"/\\${ITEM_FULL_NAME}\");\n        submit(form);\n        assert builds.toString() + \"/\\${ITEM_FULL_NAME}\" == jenkins.rawBuildsDir;\n        def p = jenkins.createProject(MockFolder.class, \"d\").createProject(FreeStyleProject.class, \"prj\");\n        def b = p.scheduleBuild2(0).get();\n        def oldBuildDir = new File(builds, \"d/prj\");\n        assert new File(oldBuildDir, b.id) == b.rootDir;\n        assert b.getRootDir().isDirectory();\n        p.renameTo(\"proj\");\n        def newBuildDir = new File(builds, \"d/proj\");\n        assert new File(newBuildDir, b.id) == b.rootDir;\n        assert b.rootDir.isDirectory();\n        p.delete();\n        assert !b.rootDir.isDirectory();\n    }\n\n    @Issue(\"JENKINS-18678\")\n    public void testRenameJobLostBuilds() throws Exception {\n        def p = createFreeStyleProject(\"initial\");\n        assertBuildStatusSuccess(p.scheduleBuild2(0));\n        assertEquals(1, p.getBuilds().size());\n        p.renameTo(\"edited\");\n        p._getRuns().purgeCache();\n        assertEquals(1, p.getBuilds().size());\n        def d = jenkins.createProject(MockFolder.class, \"d\");\n        Items.move(p, d);\n        assertEquals(p, jenkins.getItemByFullName(\"d/edited\"));\n        p._getRuns().purgeCache();\n        assertEquals(1, p.getBuilds().size());\n        d.renameTo(\"d2\");\n        p = jenkins.getItemByFullName(\"d2/edited\");\n        p._getRuns().purgeCache();\n        assertEquals(1, p.getBuilds().size());\n    }\n\n    @Issue(\"JENKINS-17575\")\n    public void testDeleteRedirect() {\n        createFreeStyleProject(\"j1\");\n        assert \"\" == deleteRedirectTarget(\"job/j1\");\n        createFreeStyleProject(\"j2\");\n        Jenkins.getInstance().addView(new AllView(\"v1\"));\n        assert \"view/v1/\" == deleteRedirectTarget(\"view/v1/job/j2\");\n        MockFolder d = Jenkins.getInstance().createProject(MockFolder.class, \"d\");\n        d.addView(new AllView(\"v2\"));\n        [\"j3\",\"j4\",\"j5\"].each { n -> d.createProject(FreeStyleProject.class, n) }\n        assert \"job/d/\" == deleteRedirectTarget(\"job/d/job/j3\");\n        assert \"job/d/view/v2/\" == deleteRedirectTarget(\"job/d/view/v2/job/j4\");\n        assert \"view/v1/job/d/\" == deleteRedirectTarget(\"view/v1/job/d/job/j5\");\n        assert \"view/v1/\" == deleteRedirectTarget(\"view/v1/job/d\"); // JENKINS-23375\n    }\n\n    private String deleteRedirectTarget(String job) {\n        def wc = createWebClient();\n        String base = wc.getContextPath();\n        String loc = wc.getPage(wc.addCrumb(new WebRequest(new URL(base + job + \"/doDelete\"), HttpMethod.POST))).getUrl().toString();\n        assert loc.startsWith(base): loc;\n        return loc.substring(base.length());\n    }\n\n    @Issue(\"JENKINS-18407\")\n    public void testQueueSuccessBehavior() {\n        // prevent any builds to test the behaviour\n        jenkins.numExecutors = 0;\n\n        def p = createFreeStyleProject()\n        def f = p.scheduleBuild2(0)\n        assert f!=null;\n        def g = p.scheduleBuild2(0)\n        assert f==g;\n\n        p.makeDisabled(true)\n        assert p.scheduleBuild2(0)==null\n    }\n\n    /**\n     * Do the same as {@link #testQueueSuccessBehavior()} but over HTTP\n     */\n    @Issue(\"JENKINS-18407\")\n    public void testQueueSuccessBehaviorOverHTTP() {\n        // prevent any builds to test the behaviour\n        jenkins.numExecutors = 0;\n\n        def p = createFreeStyleProject()\n        def wc = createWebClient();\n\n        def rsp = wc.getPage(\"${getURL()}${p.url}build\").webResponse\n        assert rsp.statusCode==201;\n        assert rsp.getResponseHeaderValue(\"Location\")!=null;\n\n        def rsp2 = wc.getPage(\"${getURL()}${p.url}build\").webResponse\n        assert rsp2.statusCode==201;\n        assert rsp.getResponseHeaderValue(\"Location\")==rsp2.getResponseHeaderValue(\"Location\")\n\n        p.makeDisabled(true)\n\n        try {\n            wc.getPage(\"${getURL()}${p.url}build\")\n            fail();\n        } catch (FailingHttpStatusCodeException e) {\n            // request should fail\n        }\n    }\n\n    /**\n     * We used to store {@link AbstractProject#triggers} as {@link Vector}, so make sure\n     * we can still read back the configuration from that.\n     */\n    public void testVectorTriggers() {\n        AbstractProject j = jenkins.createProjectFromXML(\"foo\", getClass().getResourceAsStream(\"AbstractProjectTest/vectorTriggers.xml\"))\n        assert j.triggers().size()==1\n        def t = j.triggers()[0]\n        assert t.class==SCMTrigger.class;\n        assert t.spec==\"*/10 * * * *\"\n    }\n\n    @Issue(\"JENKINS-18813\")\n    public void testRemoveTrigger() {\n        AbstractProject j = jenkins.createProjectFromXML(\"foo\", getClass().getResourceAsStream(\"AbstractProjectTest/vectorTriggers.xml\"))\n\n        TriggerDescriptor SCM_TRIGGER_DESCRIPTOR = Hudson.instance.getDescriptorOrDie(SCMTrigger.class)\n        j.removeTrigger(SCM_TRIGGER_DESCRIPTOR);\n        assert j.triggers().size()==0\n    }\n\n    @Issue(\"JENKINS-18813\")\n    public void testAddTriggerSameType() {\n        AbstractProject j = jenkins.createProjectFromXML(\"foo\", getClass().getResourceAsStream(\"AbstractProjectTest/vectorTriggers.xml\"))\n\n        def newTrigger = new SCMTrigger(\"H/5 * * * *\")\n        j.addTrigger(newTrigger);\n\n        assert j.triggers().size()==1\n        def t = j.triggers()[0]\n        assert t.class==SCMTrigger.class;\n        assert t.spec==\"H/5 * * * *\"\n    }\n\n    @Issue(\"JENKINS-18813\")\n    public void testAddTriggerDifferentType() {\n        AbstractProject j = jenkins.createProjectFromXML(\"foo\", getClass().getResourceAsStream(\"AbstractProjectTest/vectorTriggers.xml\"))\n\n        def newTrigger = new TimerTrigger(\"20 * * * *\")\n        j.addTrigger(newTrigger);\n\n        assert j.triggers().size()==2\n        def t = j.triggers()[1]\n        assert t == newTrigger\n    }\n\n    @Issue(\"JENKINS-10615\")\n    public void testWorkspaceLock() {\n        def p = createFreeStyleProject()\n        p.concurrentBuild = true;\n        def e1 = new OneShotEvent(), e2=new OneShotEvent()\n        def done = new OneShotEvent()\n\n        p.publishersList.add(new Recorder() {\n            BuildStepMonitor getRequiredMonitorService() {\n                return BuildStepMonitor.NONE;\n            }\n\n            @Override\n            boolean perform(AbstractBuild<?, ?> build, Launcher launcher, BuildListener listener) throws InterruptedException, IOException {\n                if (build.number==1) {\n                    e1.signal();  // signal that build #1 is in publisher\n                } else {\n                    assert build.number==2;\n                    e2.signal()\n                }\n\n                done.block()\n\n                return true;\n            }\n            private Object writeReplace() { return new Object(); }\n        })\n\n        def b1 = p.scheduleBuild2(0)\n        e1.block()\n\n        def b2 = p.scheduleBuild2(0)\n        e2.block()\n\n        // at this point both builds are in the publisher, so we verify that\n        // the workspace are differently allocated\n        assert b1.startCondition.get().workspace!=b2.startCondition.get().workspace\n\n        done.signal()\n    }\n\n    public void testRenameToPrivileged() {\n        def secret = jenkins.createProject(FreeStyleProject.class,\"secret\");\n        def regular = jenkins.createProject(FreeStyleProject.class,\"regular\")\n\n        jenkins.securityRealm = createDummySecurityRealm();\n        def auth = new ProjectMatrixAuthorizationStrategy();\n        jenkins.authorizationStrategy = auth;\n\n        auth.add(Jenkins.ADMINISTER, \"alice\");\n        auth.add(Jenkins.READ, \"bob\");\n\n        // bob the regular user can only see regular jobs\n        regular.addProperty(new AuthorizationMatrixProperty([(Job.READ) : [\"bob\"] as Set]));\n\n        def wc = createWebClient()\n        wc.login(\"bob\")\n        wc.executeOnServer {\n            assert jenkins.getItem(\"secret\")==null;\n            try {\n                regular.renameTo(\"secret\")\n                fail(\"rename as an overwrite should have failed\");\n            } catch (Exception e) {\n                // expected rename to fail in some non-descriptive generic way\n                e.printStackTrace()\n            }\n        }\n\n        // those two jobs should still be there\n        assert jenkins.getItem(\"regular\")!=null;\n        assert jenkins.getItem(\"secret\")!=null;\n    }\n\n\n    /**\n     * Trying to POST to config.xml by a different job type should fail.\n     */\n    public void testConfigDotXmlSubmissionToDifferentType() {\n        jenkins.crumbIssuer = null\n        def p = createFreeStyleProject()\n\n        HttpURLConnection con = postConfigDotXml(p, \"<maven2-moduleset />\")\n\n        // this should fail with a type mismatch error\n        // the error message should report both what was submitted and what was expected\n        assert con.responseCode == 500\n        def msg = con.errorStream.text\n        println msg\n        assert msg.contains(FreeStyleProject.class.name)\n        assert msg.contains(MavenModuleSet.class.name)\n\n        // control. this should work\n        con = postConfigDotXml(p, \"<project />\")\n        assert con.responseCode == 200\n    }\n\n    private HttpURLConnection postConfigDotXml(FreeStyleProject p, String xml) {\n        HttpURLConnection con = new URL(getURL(), \"job/${p.name}/config.xml\").openConnection()\n        con.requestMethod = \"POST\"\n        con.setRequestProperty(\"Content-Type\", \"application/xml\")\n        con.doOutput = true\n        con.outputStream.withStream { s ->\n            s.write(xml.bytes)\n        }\n        return con\n    }\n\n    @Issue(\"JENKINS-27549\")\n    public void testLoadingWithNPEOnTriggerStart() {\n        AbstractProject project = jenkins.createProjectFromXML(\"foo\", getClass().getResourceAsStream(\"AbstractProjectTest/npeTrigger.xml\"))\n\n        assert project.triggers().size() == 1\n    }\n\n    static class MockBuildTriggerThrowsNPEOnStart<Item> extends Trigger {\n        @Override\n        public void start(hudson.model.Item project, boolean newInstance) { throw new NullPointerException(); }\n\n        @Override\n        public TriggerDescriptor getDescriptor() {\n            return DESCRIPTOR;\n        }\n\n        public static final TriggerDescriptor DESCRIPTOR = new DescriptorImpl()\n\n        @TestExtension(\"testLoadingWithNPEOnTriggerStart\")\n        static class DescriptorImpl extends TriggerDescriptor {\n\n            public boolean isApplicable(hudson.model.Item item) {\n                return false;\n            }\n\n            @Override\n            String getDisplayName() {\n                return \"test\";\n            }\n        }\n    }\n}\n", "/*\n * The MIT License\n *\n * Copyright 2014 Jesse Glick.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\npackage hudson.model;\n\nimport java.io.File;\nimport java.util.Arrays;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport org.junit.Rule;\nimport org.junit.rules.TemporaryFolder;\nimport org.jvnet.hudson.test.Issue;\nimport org.jvnet.hudson.test.JenkinsRule;\nimport org.jvnet.hudson.test.MockFolder;\n\npublic class ItemsTest {\n\n    @Rule public JenkinsRule r = new JenkinsRule();\n    @Rule public TemporaryFolder tmpRule = new TemporaryFolder();\n\n    @Test public void getAllItems() throws Exception {\n        MockFolder d = r.createFolder(\"d\");\n        MockFolder sub2 = d.createProject(MockFolder.class, \"sub2\");\n        MockFolder sub2a = sub2.createProject(MockFolder.class, \"a\");\n        MockFolder sub2c = sub2.createProject(MockFolder.class, \"c\");\n        MockFolder sub2b = sub2.createProject(MockFolder.class, \"b\");\n        MockFolder sub1 = d.createProject(MockFolder.class, \"sub1\");\n        FreeStyleProject root = r.createFreeStyleProject(\"root\");\n        FreeStyleProject dp = d.createProject(FreeStyleProject.class, \"p\");\n        FreeStyleProject sub1q = sub1.createProject(FreeStyleProject.class, \"q\");\n        FreeStyleProject sub1p = sub1.createProject(FreeStyleProject.class, \"p\");\n        FreeStyleProject sub2ap = sub2a.createProject(FreeStyleProject.class, \"p\");\n        FreeStyleProject sub2bp = sub2b.createProject(FreeStyleProject.class, \"p\");\n        FreeStyleProject sub2cp = sub2c.createProject(FreeStyleProject.class, \"p\");\n        FreeStyleProject sub2alpha = sub2.createProject(FreeStyleProject.class, \"alpha\");\n        FreeStyleProject sub2BRAVO = sub2.createProject(FreeStyleProject.class, \"BRAVO\");\n        FreeStyleProject sub2charlie = sub2.createProject(FreeStyleProject.class, \"charlie\");\n        assertEquals(Arrays.asList(dp, sub1p, sub1q, sub2ap, sub2alpha, sub2bp, sub2BRAVO, sub2cp, sub2charlie), Items.getAllItems(d, FreeStyleProject.class));\n        assertEquals(Arrays.<Item>asList(sub2a, sub2ap, sub2alpha, sub2b, sub2bp, sub2BRAVO, sub2c, sub2cp, sub2charlie), Items.getAllItems(sub2, Item.class));\n    }\n\n    @Issue(\"JENKINS-24825\")\n    @Test public void moveItem() throws Exception {\n        File tmp = tmpRule.getRoot();\n        r.jenkins.setRawBuildsDir(tmp.getAbsolutePath()+\"/${ITEM_FULL_NAME}\");\n        MockFolder foo = r.createFolder(\"foo\");\n        MockFolder bar = r.createFolder(\"bar\");\n        FreeStyleProject test = foo.createProject(FreeStyleProject.class, \"test\");\n        test.scheduleBuild2(0).get();\n        Items.move(test, bar);\n        assertFalse(new File(tmp, \"foo/test/1\").exists());\n        assertTrue(new File(tmp, \"bar/test/1\").exists());\n    }\n\n}\n"], "fixing_code": ["/*\n * The MIT License\n * \n * Copyright (c) 2004-2011, Sun Microsystems, Inc., Kohsuke Kawaguchi,\n * Daniel Dyer, Tom Huybrechts, Yahoo!, Inc.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson.model;\n\nimport com.infradna.tool.bridge_method_injector.WithBridgeMethods;\nimport hudson.AbortException;\nimport hudson.XmlFile;\nimport hudson.Util;\nimport hudson.Functions;\nimport hudson.BulkChange;\nimport hudson.cli.declarative.CLIMethod;\nimport hudson.cli.declarative.CLIResolver;\nimport hudson.model.listeners.ItemListener;\nimport hudson.model.listeners.SaveableListener;\nimport hudson.security.AccessControlled;\nimport hudson.security.Permission;\nimport hudson.security.ACL;\nimport hudson.util.AlternativeUiTextProvider;\nimport hudson.util.AlternativeUiTextProvider.Message;\nimport hudson.util.AtomicFileWriter;\nimport hudson.util.IOUtils;\nimport hudson.util.Secret;\nimport jenkins.model.DirectlyModifiableTopLevelItemGroup;\nimport jenkins.model.Jenkins;\nimport jenkins.security.NotReallyRoleSensitiveCallable;\nimport jenkins.util.xml.XMLUtils;\n\nimport org.apache.tools.ant.taskdefs.Copy;\nimport org.apache.tools.ant.types.FileSet;\nimport org.kohsuke.stapler.WebMethod;\nimport org.kohsuke.stapler.export.Exported;\nimport org.kohsuke.stapler.export.ExportedBean;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport javax.annotation.Nonnull;\n\nimport org.kohsuke.stapler.StaplerRequest;\nimport org.kohsuke.stapler.StaplerResponse;\nimport org.kohsuke.stapler.Stapler;\nimport org.kohsuke.stapler.HttpDeletable;\nimport org.kohsuke.args4j.Argument;\nimport org.kohsuke.args4j.CmdLineException;\nimport org.kohsuke.stapler.interceptor.RequirePOST;\nimport org.xml.sax.SAXException;\n\nimport javax.servlet.ServletException;\nimport javax.xml.transform.Source;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.stream.StreamResult;\nimport javax.xml.transform.stream.StreamSource;\n\nimport static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;\nimport org.apache.commons.io.FileUtils;\nimport org.kohsuke.accmod.Restricted;\nimport org.kohsuke.accmod.restrictions.NoExternalUse;\nimport org.kohsuke.stapler.Ancestor;\n\n/**\n * Partial default implementation of {@link Item}.\n *\n * @author Kohsuke Kawaguchi\n */\n// Item doesn't necessarily have to be Actionable, but\n// Java doesn't let multiple inheritance.\n@ExportedBean\npublic abstract class AbstractItem extends Actionable implements Item, HttpDeletable, AccessControlled, DescriptorByNameOwner {\n\n    private static final Logger LOGGER = Logger.getLogger(AbstractItem.class.getName());\n\n    /**\n     * Project name.\n     */\n    protected /*final*/ transient String name;\n\n    /**\n     * Project description. Can be HTML.\n     */\n    protected volatile String description;\n\n    private transient ItemGroup parent;\n    \n    protected String displayName;\n\n    protected AbstractItem(ItemGroup parent, String name) {\n        this.parent = parent;\n        doSetName(name);\n    }\n\n    public void onCreatedFromScratch() {\n        // noop\n    }\n\n    @Exported(visibility=999)\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Get the term used in the UI to represent this kind of\n     * {@link Item}. Must start with a capital letter.\n     */\n    public String getPronoun() {\n        return AlternativeUiTextProvider.get(PRONOUN, this, Messages.AbstractItem_Pronoun());\n    }\n\n    @Exported\n    /**\n     * @return The display name of this object, or if it is not set, the name\n     * of the object.\n     */\n    public String getDisplayName() {\n        if(null!=displayName) {\n            return displayName;\n        }\n        // if the displayName is not set, then return the name as we use to do\n        return getName();\n    }\n    \n    @Exported\n    /**\n     * This is intended to be used by the Job configuration pages where\n     * we want to return null if the display name is not set.\n     * @return The display name of this object or null if the display name is not\n     * set\n     */\n    public String getDisplayNameOrNull() {\n        return displayName;\n    }\n    \n    /**\n     * This method exists so that the Job configuration pages can use \n     * getDisplayNameOrNull so that nothing is shown in the display name text\n     * box if the display name is not set.\n     * @param displayName\n     * @throws IOException\n     */\n    public void setDisplayNameOrNull(String displayName) throws IOException {\n        setDisplayName(displayName);\n    }\n    \n    public void setDisplayName(String displayName) throws IOException {\n        this.displayName = Util.fixEmpty(displayName);\n        save();\n    }\n             \n    public File getRootDir() {\n        return getParent().getRootDirFor(this);\n    }\n\n    /**\n     * This bridge method is to maintain binary compatibility with {@link TopLevelItem#getParent()}.\n     */\n    @WithBridgeMethods(value=Jenkins.class,castRequired=true)\n    @Override public @Nonnull ItemGroup getParent() {\n        if (parent == null) {\n            throw new IllegalStateException(\"no parent set on \" + getClass().getName() + \"[\" + name + \"]\");\n        }\n        return parent;\n    }\n\n    /**\n     * Gets the project description HTML.\n     */\n    @Exported\n    public String getDescription() {\n        return description;\n    }\n\n    /**\n     * Sets the project description HTML.\n     */\n    public void setDescription(String description) throws IOException {\n        this.description = description;\n        save();\n        ItemListener.fireOnUpdated(this);\n    }\n\n    /**\n     * Just update {@link #name} without performing the rename operation,\n     * which would involve copying files and etc.\n     */\n    protected void doSetName(String name) {\n        this.name = name;\n    }\n\n    /**\n     * Renames this item.\n     * Not all the Items need to support this operation, but if you decide to do so,\n     * you can use this method.\n     */\n    protected void renameTo(final String newName) throws IOException {\n        // always synchronize from bigger objects first\n        final ItemGroup parent = getParent();\n        String oldName = this.name;\n        String oldFullName = getFullName();\n        synchronized (parent) {\n            synchronized (this) {\n                // sanity check\n                if (newName == null)\n                    throw new IllegalArgumentException(\"New name is not given\");\n\n                // noop?\n                if (this.name.equals(newName))\n                    return;\n\n                // the lookup is case insensitive, so we should not fail if this item was the \u201cexisting\u201d one\n                // to allow people to rename \"Foo\" to \"foo\", for example.\n                // see http://www.nabble.com/error-on-renaming-project-tt18061629.html\n                Items.verifyItemDoesNotAlreadyExist(parent, newName, this);\n\n                File oldRoot = this.getRootDir();\n\n                doSetName(newName);\n                File newRoot = this.getRootDir();\n\n                boolean success = false;\n\n                try {// rename data files\n                    boolean interrupted = false;\n                    boolean renamed = false;\n\n                    // try to rename the job directory.\n                    // this may fail on Windows due to some other processes\n                    // accessing a file.\n                    // so retry few times before we fall back to copy.\n                    for (int retry = 0; retry < 5; retry++) {\n                        if (oldRoot.renameTo(newRoot)) {\n                            renamed = true;\n                            break; // succeeded\n                        }\n                        try {\n                            Thread.sleep(500);\n                        } catch (InterruptedException e) {\n                            // process the interruption later\n                            interrupted = true;\n                        }\n                    }\n\n                    if (interrupted)\n                        Thread.currentThread().interrupt();\n\n                    if (!renamed) {\n                        // failed to rename. it must be that some lengthy\n                        // process is going on\n                        // to prevent a rename operation. So do a copy. Ideally\n                        // we'd like to\n                        // later delete the old copy, but we can't reliably do\n                        // so, as before the VM\n                        // shuts down there might be a new job created under the\n                        // old name.\n                        Copy cp = new Copy();\n                        cp.setProject(new org.apache.tools.ant.Project());\n                        cp.setTodir(newRoot);\n                        FileSet src = new FileSet();\n                        src.setDir(oldRoot);\n                        cp.addFileset(src);\n                        cp.setOverwrite(true);\n                        cp.setPreserveLastModified(true);\n                        cp.setFailOnError(false); // keep going even if\n                                                    // there's an error\n                        cp.execute();\n\n                        // try to delete as much as possible\n                        try {\n                            Util.deleteRecursive(oldRoot);\n                        } catch (IOException e) {\n                            // but ignore the error, since we expect that\n                            e.printStackTrace();\n                        }\n                    }\n\n                    success = true;\n                } finally {\n                    // if failed, back out the rename.\n                    if (!success)\n                        doSetName(oldName);\n                }\n\n                try {\n                    parent.onRenamed(this, oldName, newName);\n                } catch (AbstractMethodError _) {\n                    // ignore\n                }\n            }\n        }\n        ItemListener.fireLocationChange(this, oldFullName);\n    }\n\n\n    /**\n     * Notify this item it's been moved to another location, replaced by newItem (might be the same object, but not guaranteed).\n     * This method is executed <em>after</em> the item root directory has been moved to it's new location.\n     * <p>\n     * Derived classes can override this method to add some specific behavior on move, but have to call parent method\n     * so the item is actually setup within it's new parent.\n     *\n     * @see hudson.model.Items#move(AbstractItem, jenkins.model.DirectlyModifiableTopLevelItemGroup)\n     */\n    public void movedTo(DirectlyModifiableTopLevelItemGroup destination, AbstractItem newItem, File destDir) throws IOException {\n        newItem.onLoad(destination, name);\n    }\n\n    /**\n     * Gets all the jobs that this {@link Item} contains as descendants.\n     */\n    public abstract Collection<? extends Job> getAllJobs();\n\n    public final String getFullName() {\n        String n = getParent().getFullName();\n        if(n.length()==0)   return getName();\n        else                return n+'/'+getName();\n    }\n\n    public final String getFullDisplayName() {\n        String n = getParent().getFullDisplayName();\n        if(n.length()==0)   return getDisplayName();\n        else                return n+\" \u00bb \"+getDisplayName();\n    }\n    \n    /**\n     * Gets the display name of the current item relative to the given group.\n     *\n     * @since 1.515\n     * @param p the ItemGroup used as point of reference for the item\n     * @return\n     *      String like \"foo \u00bb bar\"\n     */\n    public String getRelativeDisplayNameFrom(ItemGroup p) {\n        return Functions.getRelativeDisplayNameFrom(this, p);\n    }\n    \n    /**\n     * This method only exists to disambiguate {@link #getRelativeNameFrom(ItemGroup)} and {@link #getRelativeNameFrom(Item)}\n     * @since 1.512\n     * @see #getRelativeNameFrom(ItemGroup)\n     */\n    public String getRelativeNameFromGroup(ItemGroup p) {\n        return getRelativeNameFrom(p);\n    }\n\n    /**\n     * @param p\n     *  The ItemGroup instance used as context to evaluate the relative name of this AbstractItem\n     * @return\n     *  The name of the current item, relative to p.\n     *  Nested ItemGroups are separated by / character.\n     */\n    public String getRelativeNameFrom(ItemGroup p) {\n        return Functions.getRelativeNameFrom(this, p);\n    }\n\n    public String getRelativeNameFrom(Item item) {\n        return getRelativeNameFrom(item.getParent());\n    }\n\n    /**\n     * Called right after when a {@link Item} is loaded from disk.\n     * This is an opportunity to do a post load processing.\n     */\n    public void onLoad(ItemGroup<? extends Item> parent, String name) throws IOException {\n        this.parent = parent;\n        doSetName(name);\n    }\n\n    /**\n     * When a {@link Item} is copied from existing one,\n     * the files are first copied on the file system,\n     * then it will be loaded, then this method will be invoked\n     * to perform any implementation-specific work.\n     *\n     * <p>\n     * \n     *\n     * @param src\n     *      Item from which it's copied from. The same type as {@code this}. Never null.\n     */\n    public void onCopiedFrom(Item src) {\n    }\n\n    public final String getUrl() {\n        // try to stick to the current view if possible\n        StaplerRequest req = Stapler.getCurrentRequest();\n        String shortUrl = getShortUrl();\n        String uri = req == null ? null : req.getRequestURI();\n        if (req != null) {\n            String seed = Functions.getNearestAncestorUrl(req,this);\n            LOGGER.log(Level.FINER, \"seed={0} for {1} from {2}\", new Object[] {seed, this, uri});\n            if(seed!=null) {\n                // trim off the context path portion and leading '/', but add trailing '/'\n                return seed.substring(req.getContextPath().length()+1)+'/';\n            }\n            List<Ancestor> ancestors = req.getAncestors();\n            if (!ancestors.isEmpty()) {\n                Ancestor last = ancestors.get(ancestors.size() - 1);\n                if (last.getObject() instanceof View) {\n                    View view = (View) last.getObject();\n                    if (view.getOwnerItemGroup() == getParent() && !view.isDefault()) {\n                        // Showing something inside a view, so should use that as the base URL.\n                        String base = last.getUrl().substring(req.getContextPath().length() + 1) + '/';\n                        LOGGER.log(Level.FINER, \"using {0}{1} for {2} from {3}\", new Object[] {base, shortUrl, this, uri});\n                        return base + shortUrl;\n                    } else {\n                        LOGGER.log(Level.FINER, \"irrelevant {0} for {1} from {2}\", new Object[] {view.getViewName(), this, uri});\n                    }\n                } else {\n                    LOGGER.log(Level.FINER, \"inapplicable {0} for {1} from {2}\", new Object[] {last.getObject(), this, uri});\n                }\n            } else {\n                LOGGER.log(Level.FINER, \"no ancestors for {0} from {1}\", new Object[] {this, uri});\n            }\n        } else {\n            LOGGER.log(Level.FINER, \"no current request for {0}\", this);\n        }\n        // otherwise compute the path normally\n        String base = getParent().getUrl();\n        LOGGER.log(Level.FINER, \"falling back to {0}{1} for {2} from {3}\", new Object[] {base, shortUrl, this, uri});\n        return base + shortUrl;\n    }\n\n    public String getShortUrl() {\n        String prefix = getParent().getUrlChildPrefix();\n        String subdir = Util.rawEncode(getName());\n        return prefix.equals(\".\") ? subdir + '/' : prefix + '/' + subdir + '/';\n    }\n\n    public String getSearchUrl() {\n        return getShortUrl();\n    }\n\n    @Exported(visibility=999,name=\"url\")\n    public final String getAbsoluteUrl() {\n        String r = Jenkins.getInstance().getRootUrl();\n        if(r==null)\n            throw new IllegalStateException(\"Root URL isn't configured yet. Cannot compute absolute URL.\");\n        return Util.encode(r+getUrl());\n    }\n\n    /**\n     * Remote API access.\n     */\n    public final Api getApi() {\n        return new Api(this);\n    }\n\n    /**\n     * Returns the {@link ACL} for this object.\n     */\n    public ACL getACL() {\n        return Jenkins.getInstance().getAuthorizationStrategy().getACL(this);\n    }\n\n    /**\n     * Short for {@code getACL().checkPermission(p)}\n     */\n    public void checkPermission(Permission p) {\n        getACL().checkPermission(p);\n    }\n\n    /**\n     * Short for {@code getACL().hasPermission(p)}\n     */\n    public boolean hasPermission(Permission p) {\n        return getACL().hasPermission(p);\n    }\n\n    /**\n     * Save the settings to a file.\n     */\n    public synchronized void save() throws IOException {\n        if(BulkChange.contains(this))   return;\n        getConfigFile().write(this);\n        SaveableListener.fireOnChange(this, getConfigFile());\n    }\n\n    public final XmlFile getConfigFile() {\n        return Items.getConfigFile(this);\n    }\n\n    public Descriptor getDescriptorByName(String className) {\n        return Jenkins.getInstance().getDescriptorByName(className);\n    }\n\n    /**\n     * Accepts the new description.\n     */\n    public synchronized void doSubmitDescription( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        checkPermission(CONFIGURE);\n\n        setDescription(req.getParameter(\"description\"));\n        rsp.sendRedirect(\".\");  // go to the top page\n    }\n\n    /**\n     * Deletes this item.\n     * Note on the funny name: for reasons of historical compatibility, this URL is {@code /doDelete}\n     * since it predates {@code <l:confirmationLink>}. {@code /delete} goes to a Jelly page\n     * which should now be unused by core but is left in case plugins are still using it.\n     */\n    @RequirePOST\n    public void doDoDelete( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException, InterruptedException {\n        delete();\n        if (req == null || rsp == null) { // CLI\n            return;\n        }\n        List<Ancestor> ancestors = req.getAncestors();\n        ListIterator<Ancestor> it = ancestors.listIterator(ancestors.size());\n        String url = getParent().getUrl(); // fallback but we ought to get to Jenkins.instance at the root\n        while (it.hasPrevious()) {\n            Object a = it.previous().getObject();\n            if (a instanceof View) {\n                url = ((View) a).getUrl();\n                break;\n            } else if (a instanceof ViewGroup && a != this) {\n                url = ((ViewGroup) a).getUrl();\n                break;\n            }\n        }\n        rsp.sendRedirect2(req.getContextPath() + '/' + url);\n    }\n\n    public void delete( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        try {\n            doDoDelete(req,rsp);\n        } catch (InterruptedException e) {\n            // TODO: allow this in Stapler\n            throw new ServletException(e);\n        }\n    }\n\n    /**\n     * Deletes this item.\n     *\n     * <p>\n     * Any exception indicates the deletion has failed, but {@link AbortException} would prevent the caller\n     * from showing the stack trace. This\n     */\n    public void delete() throws IOException, InterruptedException {\n        checkPermission(DELETE);\n        synchronized (this) { // could just make performDelete synchronized but overriders might not honor that\n            performDelete();\n        } // JENKINS-19446: leave synch block, but JENKINS-22001: still notify synchronously\n        getParent().onDeleted(AbstractItem.this);\n        Jenkins.getInstance().rebuildDependencyGraphAsync();\n    }\n\n    /**\n     * Does the real job of deleting the item.\n     */\n    protected void performDelete() throws IOException, InterruptedException {\n        getConfigFile().delete();\n        Util.deleteRecursive(getRootDir());\n    }\n\n    /**\n     * Accepts <tt>config.xml</tt> submission, as well as serve it.\n     */\n    @WebMethod(name = \"config.xml\")\n    public void doConfigDotXml(StaplerRequest req, StaplerResponse rsp)\n            throws IOException {\n        if (req.getMethod().equals(\"GET\")) {\n            // read\n            rsp.setContentType(\"application/xml\");\n            writeConfigDotXml(rsp.getOutputStream());\n            return;\n        }\n        if (req.getMethod().equals(\"POST\")) {\n            // submission\n            updateByXml((Source)new StreamSource(req.getReader()));\n            return;\n        }\n\n        // huh?\n        rsp.sendError(SC_BAD_REQUEST);\n    }\n\n    static final Pattern SECRET_PATTERN = Pattern.compile(\">(\" + Secret.ENCRYPTED_VALUE_PATTERN + \")<\");\n    /**\n     * Writes {@code config.xml} to the specified output stream.\n     * The user must have at least {@link #EXTENDED_READ}.\n     * If he lacks {@link #CONFIGURE}, then any {@link Secret}s detected will be masked out.\n     */\n    @Restricted(NoExternalUse.class)\n    public void writeConfigDotXml(OutputStream os) throws IOException {\n        checkPermission(EXTENDED_READ);\n        XmlFile configFile = getConfigFile();\n        if (hasPermission(CONFIGURE)) {\n            IOUtils.copy(configFile.getFile(), os);\n        } else {\n            String encoding = configFile.sniffEncoding();\n            String xml = FileUtils.readFileToString(configFile.getFile(), encoding);\n            Matcher matcher = SECRET_PATTERN.matcher(xml);\n            StringBuffer cleanXml = new StringBuffer();\n            while (matcher.find()) {\n                if (Secret.decrypt(matcher.group(1)) != null) {\n                    matcher.appendReplacement(cleanXml, \">********<\");\n                }\n            }\n            matcher.appendTail(cleanXml);\n            org.apache.commons.io.IOUtils.write(cleanXml.toString(), os, encoding);\n        }\n    }\n\n    /**\n     * @deprecated as of 1.473\n     *      Use {@link #updateByXml(Source)}\n     */\n    @Deprecated\n    public void updateByXml(StreamSource source) throws IOException {\n        updateByXml((Source)source);\n    }\n\n    /**\n     * Updates an Item by its XML definition.\n     * @param source source of the Item's new definition.\n     *               The source should be either a <code>StreamSource</code> or a <code>SAXSource</code>, other\n     *               sources may not be handled.\n     * @since 1.473\n     */\n    public void updateByXml(Source source) throws IOException {\n        checkPermission(CONFIGURE);\n        XmlFile configXmlFile = getConfigFile();\n        final AtomicFileWriter out = new AtomicFileWriter(configXmlFile.getFile());\n        try {\n            try {\n                XMLUtils.safeTransform(source, new StreamResult(out));\n                out.close();\n            } catch (TransformerException e) {\n                throw new IOException(\"Failed to persist config.xml\", e);\n            } catch (SAXException e) {\n                throw new IOException(\"Failed to persist config.xml\", e);\n            }\n\n            // try to reflect the changes by reloading\n            Object o = new XmlFile(Items.XSTREAM, out.getTemporaryFile()).unmarshal(this);\n            if (o!=this) {\n                // ensure that we've got the same job type. extending this code to support updating\n                // to different job type requires destroying & creating a new job type\n                throw new IOException(\"Expecting \"+this.getClass()+\" but got \"+o.getClass()+\" instead\");\n            }\n\n            Items.whileUpdatingByXml(new NotReallyRoleSensitiveCallable<Void,IOException>() {\n                @Override public Void call() throws IOException {\n                    onLoad(getParent(), getRootDir().getName());\n                    return null;\n                }\n            });\n            Jenkins.getInstance().rebuildDependencyGraphAsync();\n\n            // if everything went well, commit this new version\n            out.commit();\n            SaveableListener.fireOnChange(this, getConfigFile());\n\n        } finally {\n            out.abort(); // don't leave anything behind\n        }\n    }\n\n    /**\n     * Reloads this job from the disk.\n     *\n     * Exposed through CLI as well.\n     *\n     * TODO: think about exposing this to UI\n     *\n     * @since 1.556\n     */\n    @CLIMethod(name=\"reload-job\")\n    @RequirePOST\n    public void doReload() throws IOException {\n        checkPermission(CONFIGURE);\n\n        // try to reflect the changes by reloading\n        getConfigFile().unmarshal(this);\n        Items.whileUpdatingByXml(new NotReallyRoleSensitiveCallable<Void, IOException>() {\n            @Override\n            public Void call() throws IOException {\n                onLoad(getParent(), getRootDir().getName());\n                return null;\n            }\n        });\n        Jenkins.getInstance().rebuildDependencyGraphAsync();\n\n        SaveableListener.fireOnChange(this, getConfigFile());\n    }\n\n\n    /* (non-Javadoc)\n     * @see hudson.model.AbstractModelObject#getSearchName()\n     */\n    @Override\n    public String getSearchName() {\n        // the search name of abstract items should be the name and not display name.\n        // this will make suggestions use the names and not the display name\n        // so that the links will 302 directly to the thing the user was finding\n        return getName();\n    }\n\n    @Override public String toString() {\n        return super.toString() + '[' + (parent != null ? getFullName() : \"?/\" + name) + ']';\n    }\n\n    /**\n     * Used for CLI binding.\n     */\n    @CLIResolver\n    public static AbstractItem resolveForCLI(\n            @Argument(required=true,metaVar=\"NAME\",usage=\"Job name\") String name) throws CmdLineException {\n        // TODO can this (and its pseudo-override in AbstractProject) share code with GenericItemOptionHandler, used for explicit CLICommand\u2019s rather than CLIMethod\u2019s?\n        AbstractItem item = Jenkins.getInstance().getItemByFullName(name, AbstractItem.class);\n        if (item==null)\n            throw new CmdLineException(null,Messages.AbstractItem_NoSuchJobExists(name,AbstractProject.findNearest(name).getFullName()));\n        return item;\n    }\n\n    /**\n     * Replaceable pronoun of that points to a job. Defaults to \"Job\"/\"Project\" depending on the context.\n     */\n    public static final Message<AbstractItem> PRONOUN = new Message<AbstractItem>();\n\n}\n", "/*\n * The MIT License\n * \n * Copyright (c) 2004-2009, Sun Microsystems, Inc., Kohsuke Kawaguchi, CloudBees, Inc.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson.model;\n\nimport hudson.Util;\nimport hudson.XmlFile;\nimport hudson.model.listeners.ItemListener;\nimport hudson.security.AccessControlled;\nimport hudson.util.CopyOnWriteMap;\nimport hudson.util.Function1;\nimport hudson.util.Secret;\nimport jenkins.model.Jenkins;\nimport jenkins.util.xml.XMLUtils;\nimport org.kohsuke.stapler.StaplerRequest;\nimport org.kohsuke.stapler.StaplerResponse;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.xml.transform.Source;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.stream.StreamResult;\nimport javax.xml.transform.stream.StreamSource;\nimport java.io.File;\nimport java.io.FileFilter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Map;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Matcher;\nimport jenkins.security.NotReallyRoleSensitiveCallable;\nimport org.acegisecurity.AccessDeniedException;\nimport org.xml.sax.SAXException;\n\n/**\n * Defines a bunch of static methods to be used as a \"mix-in\" for {@link ItemGroup}\n * implementations. Not meant for a consumption from outside {@link ItemGroup}s.\n *\n * @author Kohsuke Kawaguchi\n * @see ViewGroupMixIn\n */\npublic abstract class ItemGroupMixIn {\n    /**\n     * {@link ItemGroup} for which we are working.\n     */\n    private final ItemGroup parent;\n    private final AccessControlled acl;\n\n    protected ItemGroupMixIn(ItemGroup parent, AccessControlled acl) {\n        this.parent = parent;\n        this.acl = acl;\n    }\n\n    /*\n    * Callback methods to be implemented by the ItemGroup implementation.\n    */\n\n    /**\n     * Adds a newly created item to the parent.\n     */\n    protected abstract void add(TopLevelItem item);\n\n    /**\n     * Assigns the root directory for a prospective item.\n     */\n    protected abstract File getRootDirFor(String name);\n\n\n/*\n * The rest is the methods that provide meat.\n */\n\n    /**\n     * Loads all the child {@link Item}s.\n     *\n     * @param modulesDir\n     *      Directory that contains sub-directories for each child item.\n     */\n    public static <K,V extends Item> Map<K,V> loadChildren(ItemGroup parent, File modulesDir, Function1<? extends K,? super V> key) {\n        modulesDir.mkdirs(); // make sure it exists\n\n        File[] subdirs = modulesDir.listFiles(new FileFilter() {\n            public boolean accept(File child) {\n                return child.isDirectory();\n            }\n        });\n        CopyOnWriteMap.Tree<K,V> configurations = new CopyOnWriteMap.Tree<K,V>();\n        for (File subdir : subdirs) {\n            try {\n                // Try to retain the identity of an existing child object if we can.\n                V item = (V) parent.getItem(subdir.getName());\n                if (item == null) {\n                    XmlFile xmlFile = Items.getConfigFile(subdir);\n                    if (xmlFile.exists()) {\n                        item = (V) Items.load(parent, subdir);\n                    } else {\n                        Logger.getLogger(ItemGroupMixIn.class.getName()).log(Level.WARNING, \"could not find file \" + xmlFile.getFile());\n                        continue;\n                    }\n                } else {\n                    item.onLoad(parent, subdir.getName());\n                }\n                configurations.put(key.call(item), item);\n            } catch (Exception e) {\n                Logger.getLogger(ItemGroupMixIn.class.getName()).log(Level.WARNING, \"could not load \" + subdir, e);\n            }\n        }\n\n        return configurations;\n    }\n\n    /**\n     * {@link Item} -> name function.\n     */\n    public static final Function1<String,Item> KEYED_BY_NAME = new Function1<String, Item>() {\n        public String call(Item item) {\n            return item.getName();\n        }\n    };\n\n    /**\n     * Creates a {@link TopLevelItem} from the submission of the '/lib/hudson/newFromList/formList'\n     * or throws an exception if it fails.\n     */\n    public synchronized TopLevelItem createTopLevelItem( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        acl.checkPermission(Item.CREATE);\n\n        TopLevelItem result;\n\n        String requestContentType = req.getContentType();\n        if(requestContentType==null)\n            throw new Failure(\"No Content-Type header set\");\n\n        boolean isXmlSubmission = requestContentType.startsWith(\"application/xml\") || requestContentType.startsWith(\"text/xml\");\n\n        String name = req.getParameter(\"name\");\n        if(name==null)\n            throw new Failure(\"Query parameter 'name' is required\");\n\n        {// check if the name looks good\n            Jenkins.checkGoodName(name);\n            name = name.trim();\n            if(parent.getItem(name)!=null)\n                throw new Failure(Messages.Hudson_JobAlreadyExists(name));\n        }\n\n        String mode = req.getParameter(\"mode\");\n        if(mode!=null && mode.equals(\"copy\")) {\n            String from = req.getParameter(\"from\");\n\n            // resolve a name to Item\n            Item src = null;\n            if (!from.startsWith(\"/\"))\n                src = parent.getItem(from);\n            if (src==null)\n                src = Jenkins.getInstance().getItemByFullName(from);\n\n            if(src==null) {\n                if(Util.fixEmpty(from)==null)\n                    throw new Failure(\"Specify which job to copy\");\n                else\n                    throw new Failure(\"No such job: \"+from);\n            }\n            if (!(src instanceof TopLevelItem))\n                throw new Failure(from+\" cannot be copied\");\n\n            result = copy((TopLevelItem) src,name);\n        } else {\n            if(isXmlSubmission) {\n                result = createProjectFromXML(name, req.getInputStream());\n                rsp.setStatus(HttpServletResponse.SC_OK);\n                return result;\n            } else {\n                if(mode==null)\n                    throw new Failure(\"No mode given\");\n                TopLevelItemDescriptor descriptor = Items.all().findByName(mode);\n                if (descriptor == null) {\n                    throw new Failure(\"No item type \u2018\" + mode + \"\u2019 is known\");\n                }\n                descriptor.checkApplicableIn(parent);\n                acl.getACL().checkCreatePermission(parent, descriptor);\n\n                // create empty job and redirect to the project config screen\n                result = createProject(descriptor, name, true);\n            }\n        }\n\n        rsp.sendRedirect2(redirectAfterCreateItem(req, result));\n        return result;\n    }\n\n    /**\n     * Computes the redirection target URL for the newly created {@link TopLevelItem}.\n     */\n    protected String redirectAfterCreateItem(StaplerRequest req, TopLevelItem result) throws IOException {\n        return req.getContextPath()+'/'+result.getUrl()+\"configure\";\n    }\n\n    /**\n     * Copies an existing {@link TopLevelItem} to a new name.\n     */\n    @SuppressWarnings({\"unchecked\"})\n    public synchronized <T extends TopLevelItem> T copy(T src, String name) throws IOException {\n        acl.checkPermission(Item.CREATE);\n        src.checkPermission(Item.EXTENDED_READ);\n        XmlFile srcConfigFile = Items.getConfigFile(src);\n        if (!src.hasPermission(Item.CONFIGURE)) {\n            Matcher matcher = AbstractItem.SECRET_PATTERN.matcher(srcConfigFile.asString());\n            while (matcher.find()) {\n                if (Secret.decrypt(matcher.group(1)) != null) {\n                    // AccessDeniedException2 does not permit a custom message, and anyway redirecting the user to the login screen is obviously pointless.\n                    throw new AccessDeniedException(Messages.ItemGroupMixIn_may_not_copy_as_it_contains_secrets_and_(src.getFullName(), Jenkins.getAuthentication().getName(), Item.PERMISSIONS.title, Item.EXTENDED_READ.name, Item.CONFIGURE.name));\n                }\n            }\n        }\n        src.getDescriptor().checkApplicableIn(parent);\n        acl.getACL().checkCreatePermission(parent, src.getDescriptor());\n\n        T result = (T)createProject(src.getDescriptor(),name,false);\n\n        // copy config\n        Util.copyFile(srcConfigFile.getFile(), Items.getConfigFile(result).getFile());\n\n        // reload from the new config\n        final File rootDir = result.getRootDir();\n        result = Items.whileUpdatingByXml(new NotReallyRoleSensitiveCallable<T,IOException>() {\n            @Override public T call() throws IOException {\n                return (T) Items.load(parent, rootDir);\n            }\n        });\n        result.onCopiedFrom(src);\n\n        add(result);\n        ItemListener.fireOnCopied(src,result);\n        Jenkins.getInstance().rebuildDependencyGraphAsync();\n\n        return result;\n    }\n\n    public synchronized TopLevelItem createProjectFromXML(String name, InputStream xml) throws IOException {\n        acl.checkPermission(Item.CREATE);\n\n        Jenkins.getInstance().getProjectNamingStrategy().checkName(name);\n        Items.verifyItemDoesNotAlreadyExist(parent, name, null);\n\n        // place it as config.xml\n        File configXml = Items.getConfigFile(getRootDirFor(name)).getFile();\n        final File dir = configXml.getParentFile();\n        dir.mkdirs();\n        boolean success = false;\n        try {\n            XMLUtils.safeTransform((Source)new StreamSource(xml), new StreamResult(configXml));\n\n            // load it\n            TopLevelItem result = Items.whileUpdatingByXml(new NotReallyRoleSensitiveCallable<TopLevelItem,IOException>() {\n                @Override public TopLevelItem call() throws IOException {\n                    return (TopLevelItem) Items.load(parent, dir);\n                }\n            });\n\n            success = acl.getACL().hasCreatePermission(Jenkins.getAuthentication(), parent, result.getDescriptor())\n                && result.getDescriptor().isApplicableIn(parent);\n\n            add(result);\n\n            ItemListener.fireOnCreated(result);\n            Jenkins.getInstance().rebuildDependencyGraphAsync();\n\n            return result;\n        } catch (TransformerException e) {\n            success = false;\n            throw new IOException(\"Failed to persist config.xml\", e);\n        } catch (SAXException e) {\n            success = false;\n            throw new IOException(\"Failed to persist config.xml\", e);\n        } catch (IOException e) {\n            success = false;\n            throw e;\n        } catch (RuntimeException e) {\n            success = false;\n            throw e;\n        } finally {\n            if (!success) {\n                // if anything fails, delete the config file to avoid further confusion\n                Util.deleteRecursive(dir);\n            }\n        }\n    }\n\n    public synchronized TopLevelItem createProject( TopLevelItemDescriptor type, String name, boolean notify )\n            throws IOException {\n        acl.checkPermission(Item.CREATE);\n        type.checkApplicableIn(parent);\n        acl.getACL().checkCreatePermission(parent, type);\n\n        Jenkins.getInstance().getProjectNamingStrategy().checkName(name);\n        Items.verifyItemDoesNotAlreadyExist(parent, name, null);\n\n        TopLevelItem item = type.newInstance(parent, name);\n        try {\n            callOnCreatedFromScratch(item);\n        } catch (AbstractMethodError e) {\n            // ignore this error. Must be older plugin that doesn't have this method\n        }\n        item.save();\n        add(item);\n        Jenkins.getInstance().rebuildDependencyGraphAsync();\n\n        if (notify)\n            ItemListener.fireOnCreated(item);\n\n        return item;\n    }\n\n    /**\n     * Pointless wrapper to avoid HotSpot problem. See JENKINS-5756\n     */\n    private void callOnCreatedFromScratch(TopLevelItem item) {\n        item.onCreatedFromScratch();\n    }\n}\n", "/*\n * The MIT License\n * \n * Copyright (c) 2004-2009, Sun Microsystems, Inc., Kohsuke Kawaguchi\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson.model;\n\nimport com.thoughtworks.xstream.XStream;\nimport hudson.DescriptorExtensionList;\nimport hudson.Extension;\nimport hudson.XmlFile;\nimport hudson.model.listeners.ItemListener;\nimport hudson.remoting.Callable;\nimport hudson.security.ACL;\nimport hudson.security.AccessControlled;\nimport hudson.triggers.Trigger;\nimport hudson.util.DescriptorList;\nimport hudson.util.EditDistance;\nimport hudson.util.XStream2;\nimport jenkins.model.Jenkins;\nimport org.acegisecurity.Authentication;\nimport org.apache.commons.lang.StringUtils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.Stack;\nimport java.util.StringTokenizer;\nimport javax.annotation.CheckForNull;\nimport javax.annotation.Nonnull;\n\nimport jenkins.model.DirectlyModifiableTopLevelItemGroup;\nimport org.acegisecurity.context.SecurityContext;\nimport org.acegisecurity.context.SecurityContextHolder;\nimport org.apache.commons.io.FileUtils;\n\n/**\n * Convenience methods related to {@link Item}.\n * \n * @author Kohsuke Kawaguchi\n */\npublic class Items {\n    /**\n     * List of all installed {@link TopLevelItem} types.\n     *\n     * @deprecated as of 1.286\n     *      Use {@link #all()} for read access and {@link Extension} for registration.\n     */\n    @Deprecated\n    public static final List<TopLevelItemDescriptor> LIST = (List)new DescriptorList<TopLevelItem>(TopLevelItem.class);\n\n    /**\n     * Used to behave differently when loading posted configuration as opposed to persisted configuration.\n     * @see Trigger#start\n     * @since 1.482\n     */\n    private static final ThreadLocal<Boolean> updatingByXml = new ThreadLocal<Boolean>() {\n        @Override protected Boolean initialValue() {\n            return false;\n        }\n    };\n\n    /**\n     * Runs a block while making {@link #currentlyUpdatingByXml} be temporarily true.\n     * Use this when you are creating or changing an item.\n     * @param <V> a return value type (may be {@link Void})\n     * @param <T> an error type (may be {@link Error})\n     * @param callable a block, typically running {@link #load} or {@link Item#onLoad}\n     * @return whatever {@code callable} returned\n     * @throws T anything {@code callable} throws\n     * @since 1.546\n     */\n    public static <V,T extends Throwable> V whileUpdatingByXml(Callable<V,T> callable) throws T {\n        updatingByXml.set(true);\n        try {\n            return callable.call();\n        } finally {\n            updatingByXml.set(false);\n        }\n    }\n\n    /**\n     * Checks whether we are in the middle of creating or configuring an item via XML.\n     * Used to determine the {@code newInstance} parameter for {@link Trigger#start}.\n     * @return true if {@link #whileUpdatingByXml} is currently being called, false for example when merely starting Jenkins or reloading from disk\n     * @since 1.546\n     */\n    public static boolean currentlyUpdatingByXml() {\n        return updatingByXml.get();\n    }\n\n    /**\n     * Returns all the registered {@link TopLevelItemDescriptor}s.\n     */\n    public static DescriptorExtensionList<TopLevelItem,TopLevelItemDescriptor> all() {\n        return Jenkins.getInstance().<TopLevelItem,TopLevelItemDescriptor>getDescriptorList(TopLevelItem.class);\n    }\n\n    /**\n     * Returns all the registered {@link TopLevelItemDescriptor}s that the current security principal is allowed to\n     * create within the specified item group.\n     *\n     * @since TODO\n     */\n    public static List<TopLevelItemDescriptor> all(ItemGroup c) {\n        return all(Jenkins.getAuthentication(), c);\n    }\n\n    /**\n     * Returns all the registered {@link TopLevelItemDescriptor}s that the specified security principal is allowed to\n     * create within the specified item group.\n     *\n     * @since TODO\n     */\n    public static List<TopLevelItemDescriptor> all(Authentication a, ItemGroup c) {\n        List<TopLevelItemDescriptor> result = new ArrayList<TopLevelItemDescriptor>();\n        ACL acl;\n        if (c instanceof AccessControlled) {\n            acl = ((AccessControlled) c).getACL();\n        } else {\n            // fall back to root\n            acl = Jenkins.getInstance().getACL();\n        }\n        for (TopLevelItemDescriptor d: all()) {\n            if (acl.hasCreatePermission(a, c, d) && d.isApplicableIn(c)) {\n                result.add(d);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @deprecated Underspecified what the parameter is. {@link Descriptor#getId}? A {@link Describable} class name?\n     */\n    public static TopLevelItemDescriptor getDescriptor(String fqcn) {\n        return Descriptor.find(all(), fqcn);\n    }\n\n    /**\n     * Converts a list of items into a comma-separated list of full names.\n     */\n    public static String toNameList(Collection<? extends Item> items) {\n        StringBuilder buf = new StringBuilder();\n        for (Item item : items) {\n            if(buf.length()>0)\n                buf.append(\", \");\n            buf.append(item.getFullName());\n        }\n        return buf.toString();\n    }\n\n    /**\n     * @deprecated as of 1.406\n     *      Use {@link #fromNameList(ItemGroup, String, Class)}\n     */\n    @Deprecated\n    public static <T extends Item> List<T> fromNameList(String list, Class<T> type) {\n        return fromNameList(null,list,type);\n    }\n\n    /**\n     * Does the opposite of {@link #toNameList(Collection)}.\n     */\n    public static <T extends Item> List<T> fromNameList(ItemGroup context, @Nonnull String list, @Nonnull Class<T> type) {\n        Jenkins hudson = Jenkins.getInstance();\n\n        List<T> r = new ArrayList<T>();\n        StringTokenizer tokens = new StringTokenizer(list,\",\");\n        while(tokens.hasMoreTokens()) {\n            String fullName = tokens.nextToken().trim();\n            T item = hudson.getItem(fullName, context, type);\n            if(item!=null)\n                r.add(item);\n        }\n        return r;\n    }\n\n    /**\n     * Computes the canonical full name of a relative path in an {@link ItemGroup} context, handling relative\n     * positions \"..\" and \".\" as absolute path starting with \"/\". The resulting name is the item fullName from Jenkins\n     * root.\n     */\n    public static String getCanonicalName(ItemGroup context, String path) {\n        String[] c = context.getFullName().split(\"/\");\n        String[] p = path.split(\"/\");\n\n        Stack<String> name = new Stack<String>();\n        for (int i=0; i<c.length;i++) {\n            if (i==0 && c[i].equals(\"\")) continue;\n            name.push(c[i]);\n        }\n        for (int i=0; i<p.length;i++) {\n            if (i==0 && p[i].equals(\"\")) {\n                // Absolute path starting with a \"/\"\n                name.clear();\n                continue;\n            }\n            if (p[i].equals(\"..\")) {\n                if (name.size() == 0) {\n                    throw new IllegalArgumentException(String.format(\n                            \"Illegal relative path '%s' within context '%s'\", path, context.getFullName()\n                    ));\n                }\n                name.pop();\n                continue;\n            }\n            if (p[i].equals(\".\")) {\n                continue;\n            }\n            name.push(p[i]);\n        }\n        return StringUtils.join(name, '/');\n    }\n\n    /**\n     * Computes the relative name of list of items after a rename or move occurred.\n     * Used to manage job references as names in plugins to support {@link hudson.model.listeners.ItemListener#onLocationChanged}.\n     * <p>\n     * In a hierarchical context, when a plugin has a reference to a job as <code>../foo/bar</code> this method will\n     * handle the relative path as \"foo\" is renamed to \"zot\" to compute <code>../zot/bar</code>\n     *\n     * @param oldFullName the old full name of the item\n     * @param newFullName the new full name of the item\n     * @param relativeNames coma separated list of Item relative names\n     * @param context the {link ItemGroup} relative names refer to\n     * @return relative name for the renamed item, based on the same ItemGroup context\n     */\n    public static String computeRelativeNamesAfterRenaming(String oldFullName, String newFullName, String relativeNames, ItemGroup context) {\n\n        StringTokenizer tokens = new StringTokenizer(relativeNames,\",\");\n        List<String> newValue = new ArrayList<String>();\n        while(tokens.hasMoreTokens()) {\n            String relativeName = tokens.nextToken().trim();\n            String canonicalName = getCanonicalName(context, relativeName);\n            if (canonicalName.equals(oldFullName) || canonicalName.startsWith(oldFullName+'/')) {\n                String newCanonicalName = newFullName + canonicalName.substring(oldFullName.length());\n                if (relativeName.startsWith(\"/\")) {\n                    newValue.add(\"/\" + newCanonicalName);\n                } else {\n                    newValue.add(getRelativeNameFrom(newCanonicalName, context.getFullName()));\n                }\n            } else {\n                newValue.add(relativeName);\n            }\n        }\n        return StringUtils.join(newValue, \",\");\n    }\n\n    // Had difficulty adapting the version in Functions to use no live items, so rewrote it:\n    static String getRelativeNameFrom(String itemFullName, String groupFullName) {\n        String[] itemFullNameA = itemFullName.isEmpty() ? new String[0] : itemFullName.split(\"/\");\n        String[] groupFullNameA = groupFullName.isEmpty() ? new String[0] : groupFullName.split(\"/\");\n        for (int i = 0; ; i++) {\n            if (i == itemFullNameA.length) {\n                if (i == groupFullNameA.length) {\n                    // itemFullName and groupFullName are identical\n                    return \".\";\n                } else {\n                    // itemFullName is an ancestor of groupFullName; insert ../ for rest of groupFullName\n                    StringBuilder b = new StringBuilder();\n                    for (int j = 0; j < groupFullNameA.length - itemFullNameA.length; j++) {\n                        if (j > 0) {\n                            b.append('/');\n                        }\n                        b.append(\"..\");\n                    }\n                    return b.toString();\n                }\n            } else if (i == groupFullNameA.length) {\n                // groupFullName is an ancestor of itemFullName; insert rest of itemFullName\n                StringBuilder b = new StringBuilder();\n                for (int j = i; j < itemFullNameA.length; j++) {\n                    if (j > i) {\n                        b.append('/');\n                    }\n                    b.append(itemFullNameA[j]);\n                }\n                return b.toString();\n            } else if (itemFullNameA[i].equals(groupFullNameA[i])) {\n                // identical up to this point\n                continue;\n            } else {\n                // first mismatch; insert ../ for rest of groupFullName, then rest of itemFullName\n                StringBuilder b = new StringBuilder();\n                for (int j = i; j < groupFullNameA.length; j++) {\n                    if (j > i) {\n                        b.append('/');\n                    }\n                    b.append(\"..\");\n                }\n                for (int j = i; j < itemFullNameA.length; j++) {\n                    b.append('/').append(itemFullNameA[j]);\n                }\n                return b.toString();\n            }\n        }\n    }\n\n    /**\n     * Loads a {@link Item} from a config file.\n     *\n     * @param dir\n     *      The directory that contains the config file, not the config file itself.\n     */\n    public static Item load(ItemGroup parent, File dir) throws IOException {\n        Item item = (Item)getConfigFile(dir).read();\n        item.onLoad(parent,dir.getName());\n        return item;\n    }\n\n    /**\n     * The file we save our configuration.\n     */\n    public static XmlFile getConfigFile(File dir) {\n        return new XmlFile(XSTREAM,new File(dir,\"config.xml\"));\n    }\n\n    /**\n     * The file we save our configuration.\n     */\n    public static XmlFile getConfigFile(Item item) {\n        return getConfigFile(item.getRootDir());\n    }\n    \n    /**\n     * Gets all the {@link Item}s recursively in the {@link ItemGroup} tree\n     * and filter them by the given type.\n     * \n     * @since 1.512\n     */\n    public static <T extends Item> List<T> getAllItems(final ItemGroup root, Class<T> type) {\n        List<T> r = new ArrayList<T>();\n        getAllItems(root, type, r);\n        return r;\n    }\n    private static <T extends Item> void getAllItems(final ItemGroup root, Class<T> type, List<T> r) {\n        List<Item> items = new ArrayList<Item>(((ItemGroup<?>) root).getItems());\n        Collections.sort(items, new Comparator<Item>() {\n            @Override public int compare(Item i1, Item i2) {\n                return name(i1).compareToIgnoreCase(name(i2));\n            }\n            String name(Item i) {\n                String n = i.getName();\n                if (i instanceof ItemGroup) {\n                    n += '/';\n                }\n                return n;\n            }\n        });\n        for (Item i : items) {\n            if (type.isInstance(i)) {\n                if (i.hasPermission(Item.READ)) {\n                    r.add(type.cast(i));\n                }\n            }\n            if (i instanceof ItemGroup) {\n                getAllItems((ItemGroup) i, type, r);\n            }\n        }\n    }\n\n    /**\n     * Finds an item whose name (when referenced from the specified context) is closest to the given name.\n     * @param <T> the type of item being considered\n     * @param type same as {@code T}\n     * @param name the supplied name\n     * @param context a context to start from (used to compute relative names)\n     * @return the closest available item\n     * @since 1.538\n     */\n    public static @CheckForNull <T extends Item> T findNearest(Class<T> type, String name, ItemGroup context) {\n        List<T> projects = Jenkins.getInstance().getAllItems(type);\n        String[] names = new String[projects.size()];\n        for (int i = 0; i < projects.size(); i++) {\n            names[i] = projects.get(i).getRelativeNameFrom(context);\n        }\n        String nearest = EditDistance.findNearest(name, names);\n        return Jenkins.getInstance().getItem(nearest, context, type);\n    }\n\n    /**\n     * Moves an item between folders (or top level).\n     * Fires all relevant events but does not verify that the item\u2019s directory is not currently being used in some way (for example by a running build).\n     * Does not check any permissions.\n     * @param item some item (job or folder)\n     * @param destination the destination of the move (a folder or {@link Jenkins}); not the current parent (or you could just call {@link AbstractItem#renameTo})\n     * @return the new item (usually the same object as {@code item})\n     * @throws IOException if the move fails, or some subsequent step fails (directory might have already been moved)\n     * @throws IllegalArgumentException if the move would really be a rename, or the destination cannot accept the item, or the destination already has an item of that name\n     * @since 1.548\n     */\n    public static <I extends AbstractItem & TopLevelItem> I move(I item, DirectlyModifiableTopLevelItemGroup destination) throws IOException, IllegalArgumentException {\n        DirectlyModifiableTopLevelItemGroup oldParent = (DirectlyModifiableTopLevelItemGroup) item.getParent();\n        if (oldParent == destination) {\n            throw new IllegalArgumentException();\n        }\n        // TODO verify that destination is to not equal to, or inside, item\n        if (!destination.canAdd(item)) {\n            throw new IllegalArgumentException();\n        }\n        String name = item.getName();\n        verifyItemDoesNotAlreadyExist(destination, name, null);\n        String oldFullName = item.getFullName();\n        // TODO AbstractItem.renameTo has a more baroque implementation; factor it out into a utility method perhaps?\n        File destDir = destination.getRootDirFor(item);\n        FileUtils.forceMkdir(destDir.getParentFile());\n        FileUtils.moveDirectory(item.getRootDir(), destDir);\n        oldParent.remove(item);\n        I newItem = destination.add(item, name);\n        item.movedTo(destination, newItem, destDir);\n        ItemListener.fireLocationChange(newItem, oldFullName);\n        return newItem;\n    }\n\n    /**\n     * Securely check for the existence of an item before trying to create one with the same name.\n     * @param parent the folder where we are about to create/rename/move an item\n     * @param newName the proposed new name\n     * @param variant if not null, an existing item which we accept could be there\n     * @throws IllegalArgumentException if there is already something there, which you were supposed to know about\n     * @throws Failure if there is already something there but you should not be told details\n     */\n    static void verifyItemDoesNotAlreadyExist(@Nonnull ItemGroup<?> parent, @Nonnull String newName, @CheckForNull Item variant) throws IllegalArgumentException, Failure {\n        Item existing;\n        SecurityContext orig = ACL.impersonate(ACL.SYSTEM);\n        try {\n            existing = parent.getItem(newName);\n        } finally {\n            SecurityContextHolder.setContext(orig);\n        }\n        if (existing != null && existing != variant) {\n            if (existing.hasPermission(Item.DISCOVER)) {\n                String prefix = parent.getFullName();\n                throw new IllegalArgumentException((prefix.isEmpty() ? \"\" : prefix + \"/\") + newName + \" already exists\");\n            } else {\n                // Cannot hide its existence, so at least be as vague as possible.\n                throw new Failure(\"\");\n            }\n        }\n    }\n\n    /**\n     * Used to load/save job configuration.\n     *\n     * When you extend {@link Job} in a plugin, try to put the alias so\n     * that it produces a reasonable XML.\n     */\n    public static final XStream XSTREAM = new XStream2();\n\n    /**\n     * Alias to {@link #XSTREAM} so that one can access additional methods on {@link XStream2} more easily.\n     */\n    public static final XStream2 XSTREAM2 = (XStream2)XSTREAM;\n\n    static {\n        XSTREAM.alias(\"project\",FreeStyleProject.class);\n    }\n}\n", "/*\n * The MIT License\n *\n * Copyright (c) 2004-2009, Sun Microsystems, Inc., Kohsuke Kawaguchi\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson.model;\n\nimport com.gargoylesoftware.htmlunit.ElementNotFoundException\nimport com.gargoylesoftware.htmlunit.FailingHttpStatusCodeException;\nimport com.gargoylesoftware.htmlunit.HttpMethod\nimport com.gargoylesoftware.htmlunit.WebRequest;\nimport hudson.tasks.BuildStepMonitor;\nimport hudson.tasks.Recorder;\nimport com.gargoylesoftware.htmlunit.html.HtmlPage\nimport hudson.maven.MavenModuleSet;\nimport hudson.security.*;\nimport hudson.tasks.Shell;\nimport hudson.scm.NullSCM;\nimport hudson.scm.SCM\nimport hudson.scm.SCMDescriptor\nimport hudson.Launcher;\nimport hudson.FilePath;\nimport hudson.Functions;\nimport hudson.Util;\nimport hudson.tasks.ArtifactArchiver\nimport hudson.triggers.SCMTrigger;\nimport hudson.triggers.TimerTrigger\nimport hudson.triggers.Trigger\nimport hudson.triggers.TriggerDescriptor;\nimport hudson.util.StreamTaskListener;\nimport hudson.util.OneShotEvent\nimport jenkins.model.Jenkins;\nimport org.jvnet.hudson.test.HudsonTestCase\nimport org.jvnet.hudson.test.Issue;\nimport org.jvnet.hudson.test.TestExtension;\nimport org.jvnet.hudson.test.recipes.PresetData;\nimport org.jvnet.hudson.test.recipes.PresetData.DataSet\nimport org.apache.commons.io.FileUtils;\n\nimport org.jvnet.hudson.test.MockFolder\n\n/**\n * @author Kohsuke Kawaguchi\n */\npublic class AbstractProjectTest extends HudsonTestCase {\n    public void testConfigRoundtrip() {\n        def project = createFreeStyleProject();\n        def l = jenkins.getLabel(\"foo && bar\");\n        project.assignedLabel = l;\n        configRoundtrip((Item) project);\n\n        assert l == project.getAssignedLabel();\n    }\n\n    /**\n     * Tests the workspace deletion.\n     */\n    public void testWipeWorkspace() {\n        def project = createFreeStyleProject();\n        project.buildersList.add(new Shell(\"echo hello\"));\n\n        def b = project.scheduleBuild2(0).get();\n\n        assert b.workspace.exists(): \"Workspace should exist by now\";\n\n        project.doDoWipeOutWorkspace();\n\n        assert !b.workspace.exists(): \"Workspace should be gone by now\";\n    }\n\n    /**\n     * Makes sure that the workspace deletion is protected.\n     */\n    @PresetData(DataSet.NO_ANONYMOUS_READACCESS)\n    public void testWipeWorkspaceProtected() {\n        def project = createFreeStyleProject();\n        project.getBuildersList().add(new Shell(\"echo hello\"));\n\n        def b = project.scheduleBuild2(0).get();\n\n        assert b.getWorkspace().exists(): \"Workspace should exist by now\";\n\n        // make sure that the action link is protected\n        com.gargoylesoftware.htmlunit.WebClient wc = createWebClient();\n        try {\n            wc.getPage(new WebRequest(new URL(wc.getContextPath() + project.getUrl() + \"doWipeOutWorkspace\"), HttpMethod.POST));\n            fail(\"Expected HTTP status code 403\")\n        } catch (FailingHttpStatusCodeException e) {\n            assertEquals(HttpURLConnection.HTTP_FORBIDDEN, e.getStatusCode());\n        }\n    }\n\n    /**\n     * Makes sure that the workspace deletion link is not provided\n     * when the user doesn't have an access.\n     */\n    @PresetData(DataSet.ANONYMOUS_READONLY)\n    public void testWipeWorkspaceProtected2() {\n        ((GlobalMatrixAuthorizationStrategy) jenkins.getAuthorizationStrategy()).add(AbstractProject.WORKSPACE,\"anonymous\");\n\n        // make sure that the deletion is protected in the same way\n        testWipeWorkspaceProtected();\n\n        // there shouldn't be any \"wipe out workspace\" link for anonymous user\n        def webClient = createWebClient();\n        HtmlPage page = webClient.getPage(jenkins.getItem(\"test0\"));\n\n        page = (HtmlPage)page.getAnchorByText(\"Workspace\").click();\n        try {\n        \tString wipeOutLabel = ResourceBundle.getBundle(\"hudson/model/AbstractProject/sidepanel\").getString(\"Wipe Out Workspace\");\n\t\tpage.getAnchorByText(wipeOutLabel);\n            fail(\"shouldn't find a link\");\n        } catch (ElementNotFoundException e) {\n            // OK\n        }\n    }\n\n    /**\n     * Tests the &lt;optionalBlock @field> round trip behavior by using {@link AbstractProject#concurrentBuild}\n     */\n    public void testOptionalBlockDataBindingRoundtrip() {\n        def p = createFreeStyleProject();\n        [true,false].each { b ->\n            p.concurrentBuild = b;\n            submit(createWebClient().getPage(p,\"configure\").getFormByName(\"config\"));\n            assert b==p.isConcurrentBuild();\n        }\n    }\n\n    /**\n     * Tests round trip configuration of the blockBuildWhenUpstreamBuilding field\n     */\n    @Issue(\"JENKINS-4423\")\n    public void testConfiguringBlockBuildWhenUpstreamBuildingRoundtrip() {\n        def p = createFreeStyleProject();\n        p.blockBuildWhenUpstreamBuilding = false;\n\n        def form = createWebClient().getPage(p, \"configure\").getFormByName(\"config\");\n        def input = form.getInputByName(\"blockBuildWhenUpstreamBuilding\");\n        assert !input.isChecked(): \"blockBuildWhenUpstreamBuilding check box is checked.\";\n\n        input.setChecked(true);\n        submit(form);\n        assert p.blockBuildWhenUpstreamBuilding: \"blockBuildWhenUpstreamBuilding was not updated from configuration form\";\n\n        form = createWebClient().getPage(p, \"configure\").getFormByName(\"config\");\n        input = form.getInputByName(\"blockBuildWhenUpstreamBuilding\");\n        assert input.isChecked(): \"blockBuildWhenUpstreamBuilding check box is not checked.\";\n    }\n\n    /**\n     * Unless the concurrent build option is enabled, polling and build should be mutually exclusive\n     * to avoid allocating unnecessary workspaces.\n     */\n    @Issue(\"JENKINS-4202\")\n    public void testPollingAndBuildExclusion() {\n        final OneShotEvent sync = new OneShotEvent();\n\n        final FreeStyleProject p = createFreeStyleProject();\n        def b1 = buildAndAssertSuccess(p);\n\n        p.scm = new NullSCM() {\n            @Override\n            public boolean pollChanges(AbstractProject project, Launcher launcher, FilePath workspace, TaskListener listener) {\n                try {\n                    sync.block();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                return true;\n            }\n\n            /**\n             * Don't write 'this', so that subtypes can be implemented as anonymous class.\n             */\n            private Object writeReplace() { return new Object(); }\n\n            @Override public boolean requiresWorkspaceForPolling() {\n                return true;\n            }\n            @Override public SCMDescriptor<?> getDescriptor() {\n                return new SCMDescriptor<SCM>(null) {\n                    @Override public String getDisplayName() {\n                        return \"\";\n                    }\n                };\n            }\n        };\n        Thread t = new Thread() {\n            @Override public void run() {\n                p.pollSCMChanges(StreamTaskListener.fromStdout());\n            }\n        };\n        try {\n            t.start();\n            def f = p.scheduleBuild2(0);\n\n            // add a bit of delay to make sure that the blockage is happening\n            Thread.sleep(3000);\n\n            // release the polling\n            sync.signal();\n\n            def b2 = assertBuildStatusSuccess(f);\n\n            // they should have used the same workspace.\n            assert b1.workspace == b2.workspace;\n        } finally {\n            t.interrupt();\n        }\n    }\n\n    @Issue(\"JENKINS-1986\")\n    public void testBuildSymlinks() {\n        // If we're on Windows, don't bother doing this.\n        if (Functions.isWindows())\n            return;\n\n        def job = createFreeStyleProject();\n        job.buildersList.add(new Shell(\"echo \\\"Build #\\$BUILD_NUMBER\\\"\\n\"));\n        def build = job.scheduleBuild2(0, new Cause.UserCause()).get();\n        File lastSuccessful = new File(job.rootDir, \"lastSuccessful\"),\n             lastStable = new File(job.rootDir, \"lastStable\");\n        // First build creates links\n        assertSymlinkForBuild(lastSuccessful, 1);\n        assertSymlinkForBuild(lastStable, 1);\n        FreeStyleBuild build2 = job.scheduleBuild2(0, new Cause.UserCause()).get();\n        // Another build updates links\n        assertSymlinkForBuild(lastSuccessful, 2);\n        assertSymlinkForBuild(lastStable, 2);\n        // Delete latest build should update links\n        build2.delete();\n        assertSymlinkForBuild(lastSuccessful, 1);\n        assertSymlinkForBuild(lastStable, 1);\n        // Delete all builds should remove links\n        build.delete();\n        assert !lastSuccessful.exists(): \"lastSuccessful link should be removed\";\n        assert !lastStable.exists(): \"lastStable link should be removed\";\n    }\n\n    private static void assertSymlinkForBuild(File file, int buildNumber)\n            throws IOException, InterruptedException {\n        assert file.exists(): \"should exist and point to something that exists\";\n        assert Util.isSymlink(file): \"should be symlink\";\n        String s = FileUtils.readFileToString(new File(file, \"log\"));\n        assert s.contains(\"Build #\" + buildNumber + \"\\n\") : \"link should point to build #$buildNumber, but link was: ${Util.resolveSymlink(file, TaskListener.NULL)}\\nand log was:\\n$s\";\n    }\n\n    @Issue(\"JENKINS-2543\")\n    public void testSymlinkForPostBuildFailure() {\n        // If we're on Windows, don't bother doing this.\n        if (Functions.isWindows())\n            return;\n\n        // Links should be updated after post-build actions when final build result is known\n        def job = createFreeStyleProject();\n        job.buildersList.add(new Shell(\"echo \\\"Build #\\$BUILD_NUMBER\\\"\\n\"));\n        def build = job.scheduleBuild2(0, new Cause.UserCause()).get();\n        assert Result.SUCCESS == build.result;\n        File lastSuccessful = new File(job.rootDir, \"lastSuccessful\"),\n             lastStable = new File(job.rootDir, \"lastStable\");\n        // First build creates links\n        assertSymlinkForBuild(lastSuccessful, 1);\n        assertSymlinkForBuild(lastStable, 1);\n        // Archive artifacts that don't exist to create failure in post-build action\n        job.publishersList.add(new ArtifactArchiver(\"*.foo\", \"\", false, false));\n        build = job.scheduleBuild2(0, new Cause.UserCause()).get();\n        assert Result.FAILURE == build.getResult();\n        // Links should not be updated since build failed\n        assertSymlinkForBuild(lastSuccessful, 1);\n        assertSymlinkForBuild(lastStable, 1);\n    }\n\n    /* TODO too slow, seems capable of causing testWorkspaceLock to time out:\n    @Issue(\"JENKINS-15156\")\n    public void testGetBuildAfterGC() {\n        FreeStyleProject job = createFreeStyleProject();\n        job.scheduleBuild2(0, new Cause.UserIdCause()).get();\n        jenkins.queue.clearLeftItems();\n        MemoryAssert.assertGC(new WeakReference(job.getLastBuild()));\n        assert job.lastBuild != null;\n    }\n    */\n\n    @Issue(\"JENKINS-17137\")\n    public void testExternalBuildDirectorySymlinks() {\n        // TODO when using JUnit 4 add: Assume.assumeFalse(Functions.isWindows()); // symlinks may not be available\n        def form = createWebClient().goTo(\"configure\").getFormByName(\"config\");\n        def builds = createTmpDir();\n        form.getInputByName(\"_.rawBuildsDir\").valueAttribute = builds.toString() + \"/\\${ITEM_FULL_NAME}\";\n        submit(form);\n        assert builds.toString() + \"/\\${ITEM_FULL_NAME}\" == jenkins.getRawBuildsDir();\n        def p = jenkins.createProject(MockFolder.class, \"d\").createProject(FreeStyleProject.class, \"p\");\n        def b1 = p.scheduleBuild2(0).get();\n        def link = new File(p.rootDir, \"lastStable\");\n        assert link.exists();\n        assert b1.rootDir.absolutePath == resolveAll(link).absolutePath;\n        def b2 = p.scheduleBuild2(0).get();\n        assert link.exists();\n        assert b2.rootDir.absolutePath == resolveAll(link).absolutePath;\n        b2.delete();\n        assert link.exists();\n        assert b1.rootDir.absolutePath == resolveAll(link).absolutePath;\n        b1.delete();\n        assert !link.exists();\n    }\n\n    private File resolveAll(File link) throws InterruptedException, IOException {\n        while (true) {\n            File f = Util.resolveSymlinkToFile(link);\n            if (f==null)    return link;\n            link = f;\n        }\n    }\n\n    @Issue(\"JENKINS-17138\")\n    public void testExternalBuildDirectoryRenameDelete() {\n        def form = createWebClient().goTo(\"configure\").getFormByName(\"config\");\n        def builds = createTmpDir();\n        form.getInputByName(\"_.rawBuildsDir\").setValueAttribute(builds.toString() + \"/\\${ITEM_FULL_NAME}\");\n        submit(form);\n        assert builds.toString() + \"/\\${ITEM_FULL_NAME}\" == jenkins.rawBuildsDir;\n        def p = jenkins.createProject(MockFolder.class, \"d\").createProject(FreeStyleProject.class, \"prj\");\n        def b = p.scheduleBuild2(0).get();\n        def oldBuildDir = new File(builds, \"d/prj\");\n        assert new File(oldBuildDir, b.id) == b.rootDir;\n        assert b.getRootDir().isDirectory();\n        p.renameTo(\"proj\");\n        def newBuildDir = new File(builds, \"d/proj\");\n        assert new File(newBuildDir, b.id) == b.rootDir;\n        assert b.rootDir.isDirectory();\n        p.delete();\n        assert !b.rootDir.isDirectory();\n    }\n\n    @Issue(\"JENKINS-18678\")\n    public void testRenameJobLostBuilds() throws Exception {\n        def p = createFreeStyleProject(\"initial\");\n        assertBuildStatusSuccess(p.scheduleBuild2(0));\n        assertEquals(1, p.getBuilds().size());\n        p.renameTo(\"edited\");\n        p._getRuns().purgeCache();\n        assertEquals(1, p.getBuilds().size());\n        def d = jenkins.createProject(MockFolder.class, \"d\");\n        Items.move(p, d);\n        assertEquals(p, jenkins.getItemByFullName(\"d/edited\"));\n        p._getRuns().purgeCache();\n        assertEquals(1, p.getBuilds().size());\n        d.renameTo(\"d2\");\n        p = jenkins.getItemByFullName(\"d2/edited\");\n        p._getRuns().purgeCache();\n        assertEquals(1, p.getBuilds().size());\n    }\n\n    @Issue(\"JENKINS-17575\")\n    public void testDeleteRedirect() {\n        createFreeStyleProject(\"j1\");\n        assert \"\" == deleteRedirectTarget(\"job/j1\");\n        createFreeStyleProject(\"j2\");\n        Jenkins.getInstance().addView(new AllView(\"v1\"));\n        assert \"view/v1/\" == deleteRedirectTarget(\"view/v1/job/j2\");\n        MockFolder d = Jenkins.getInstance().createProject(MockFolder.class, \"d\");\n        d.addView(new AllView(\"v2\"));\n        [\"j3\",\"j4\",\"j5\"].each { n -> d.createProject(FreeStyleProject.class, n) }\n        assert \"job/d/\" == deleteRedirectTarget(\"job/d/job/j3\");\n        assert \"job/d/view/v2/\" == deleteRedirectTarget(\"job/d/view/v2/job/j4\");\n        assert \"view/v1/job/d/\" == deleteRedirectTarget(\"view/v1/job/d/job/j5\");\n        assert \"view/v1/\" == deleteRedirectTarget(\"view/v1/job/d\"); // JENKINS-23375\n    }\n\n    private String deleteRedirectTarget(String job) {\n        def wc = createWebClient();\n        String base = wc.getContextPath();\n        String loc = wc.getPage(wc.addCrumb(new WebRequest(new URL(base + job + \"/doDelete\"), HttpMethod.POST))).getUrl().toString();\n        assert loc.startsWith(base): loc;\n        return loc.substring(base.length());\n    }\n\n    @Issue(\"JENKINS-18407\")\n    public void testQueueSuccessBehavior() {\n        // prevent any builds to test the behaviour\n        jenkins.numExecutors = 0;\n\n        def p = createFreeStyleProject()\n        def f = p.scheduleBuild2(0)\n        assert f!=null;\n        def g = p.scheduleBuild2(0)\n        assert f==g;\n\n        p.makeDisabled(true)\n        assert p.scheduleBuild2(0)==null\n    }\n\n    /**\n     * Do the same as {@link #testQueueSuccessBehavior()} but over HTTP\n     */\n    @Issue(\"JENKINS-18407\")\n    public void testQueueSuccessBehaviorOverHTTP() {\n        // prevent any builds to test the behaviour\n        jenkins.numExecutors = 0;\n\n        def p = createFreeStyleProject()\n        def wc = createWebClient();\n\n        def rsp = wc.getPage(\"${getURL()}${p.url}build\").webResponse\n        assert rsp.statusCode==201;\n        assert rsp.getResponseHeaderValue(\"Location\")!=null;\n\n        def rsp2 = wc.getPage(\"${getURL()}${p.url}build\").webResponse\n        assert rsp2.statusCode==201;\n        assert rsp.getResponseHeaderValue(\"Location\")==rsp2.getResponseHeaderValue(\"Location\")\n\n        p.makeDisabled(true)\n\n        try {\n            wc.getPage(\"${getURL()}${p.url}build\")\n            fail();\n        } catch (FailingHttpStatusCodeException e) {\n            // request should fail\n        }\n    }\n\n    /**\n     * We used to store {@link AbstractProject#triggers} as {@link Vector}, so make sure\n     * we can still read back the configuration from that.\n     */\n    public void testVectorTriggers() {\n        AbstractProject j = jenkins.createProjectFromXML(\"foo\", getClass().getResourceAsStream(\"AbstractProjectTest/vectorTriggers.xml\"))\n        assert j.triggers().size()==1\n        def t = j.triggers()[0]\n        assert t.class==SCMTrigger.class;\n        assert t.spec==\"*/10 * * * *\"\n    }\n\n    @Issue(\"JENKINS-18813\")\n    public void testRemoveTrigger() {\n        AbstractProject j = jenkins.createProjectFromXML(\"foo\", getClass().getResourceAsStream(\"AbstractProjectTest/vectorTriggers.xml\"))\n\n        TriggerDescriptor SCM_TRIGGER_DESCRIPTOR = Hudson.instance.getDescriptorOrDie(SCMTrigger.class)\n        j.removeTrigger(SCM_TRIGGER_DESCRIPTOR);\n        assert j.triggers().size()==0\n    }\n\n    @Issue(\"JENKINS-18813\")\n    public void testAddTriggerSameType() {\n        AbstractProject j = jenkins.createProjectFromXML(\"foo\", getClass().getResourceAsStream(\"AbstractProjectTest/vectorTriggers.xml\"))\n\n        def newTrigger = new SCMTrigger(\"H/5 * * * *\")\n        j.addTrigger(newTrigger);\n\n        assert j.triggers().size()==1\n        def t = j.triggers()[0]\n        assert t.class==SCMTrigger.class;\n        assert t.spec==\"H/5 * * * *\"\n    }\n\n    @Issue(\"JENKINS-18813\")\n    public void testAddTriggerDifferentType() {\n        AbstractProject j = jenkins.createProjectFromXML(\"foo\", getClass().getResourceAsStream(\"AbstractProjectTest/vectorTriggers.xml\"))\n\n        def newTrigger = new TimerTrigger(\"20 * * * *\")\n        j.addTrigger(newTrigger);\n\n        assert j.triggers().size()==2\n        def t = j.triggers()[1]\n        assert t == newTrigger\n    }\n\n    @Issue(\"JENKINS-10615\")\n    public void testWorkspaceLock() {\n        def p = createFreeStyleProject()\n        p.concurrentBuild = true;\n        def e1 = new OneShotEvent(), e2=new OneShotEvent()\n        def done = new OneShotEvent()\n\n        p.publishersList.add(new Recorder() {\n            BuildStepMonitor getRequiredMonitorService() {\n                return BuildStepMonitor.NONE;\n            }\n\n            @Override\n            boolean perform(AbstractBuild<?, ?> build, Launcher launcher, BuildListener listener) throws InterruptedException, IOException {\n                if (build.number==1) {\n                    e1.signal();  // signal that build #1 is in publisher\n                } else {\n                    assert build.number==2;\n                    e2.signal()\n                }\n\n                done.block()\n\n                return true;\n            }\n            private Object writeReplace() { return new Object(); }\n        })\n\n        def b1 = p.scheduleBuild2(0)\n        e1.block()\n\n        def b2 = p.scheduleBuild2(0)\n        e2.block()\n\n        // at this point both builds are in the publisher, so we verify that\n        // the workspace are differently allocated\n        assert b1.startCondition.get().workspace!=b2.startCondition.get().workspace\n\n        done.signal()\n    }\n\n    /**\n     * Trying to POST to config.xml by a different job type should fail.\n     */\n    public void testConfigDotXmlSubmissionToDifferentType() {\n        jenkins.crumbIssuer = null\n        def p = createFreeStyleProject()\n\n        HttpURLConnection con = postConfigDotXml(p, \"<maven2-moduleset />\")\n\n        // this should fail with a type mismatch error\n        // the error message should report both what was submitted and what was expected\n        assert con.responseCode == 500\n        def msg = con.errorStream.text\n        println msg\n        assert msg.contains(FreeStyleProject.class.name)\n        assert msg.contains(MavenModuleSet.class.name)\n\n        // control. this should work\n        con = postConfigDotXml(p, \"<project />\")\n        assert con.responseCode == 200\n    }\n\n    private HttpURLConnection postConfigDotXml(FreeStyleProject p, String xml) {\n        HttpURLConnection con = new URL(getURL(), \"job/${p.name}/config.xml\").openConnection()\n        con.requestMethod = \"POST\"\n        con.setRequestProperty(\"Content-Type\", \"application/xml\")\n        con.doOutput = true\n        con.outputStream.withStream { s ->\n            s.write(xml.bytes)\n        }\n        return con\n    }\n\n    @Issue(\"JENKINS-27549\")\n    public void testLoadingWithNPEOnTriggerStart() {\n        AbstractProject project = jenkins.createProjectFromXML(\"foo\", getClass().getResourceAsStream(\"AbstractProjectTest/npeTrigger.xml\"))\n\n        assert project.triggers().size() == 1\n    }\n\n    static class MockBuildTriggerThrowsNPEOnStart<Item> extends Trigger {\n        @Override\n        public void start(hudson.model.Item project, boolean newInstance) { throw new NullPointerException(); }\n\n        @Override\n        public TriggerDescriptor getDescriptor() {\n            return DESCRIPTOR;\n        }\n\n        public static final TriggerDescriptor DESCRIPTOR = new DescriptorImpl()\n\n        @TestExtension(\"testLoadingWithNPEOnTriggerStart\")\n        static class DescriptorImpl extends TriggerDescriptor {\n\n            public boolean isApplicable(hudson.model.Item item) {\n                return false;\n            }\n\n            @Override\n            String getDisplayName() {\n                return \"test\";\n            }\n        }\n    }\n}\n", "/*\n * The MIT License\n *\n * Copyright 2014 Jesse Glick.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\npackage hudson.model;\n\nimport com.gargoylesoftware.htmlunit.FailingHttpStatusCodeException;\nimport com.gargoylesoftware.htmlunit.HttpMethod;\nimport com.gargoylesoftware.htmlunit.WebRequest;\nimport com.gargoylesoftware.htmlunit.WebResponse;\nimport hudson.AbortException;\nimport hudson.cli.CLICommand;\nimport hudson.cli.CLICommandInvoker;\nimport hudson.cli.CopyJobCommand;\nimport hudson.cli.CreateJobCommand;\nimport hudson.security.ACL;\nimport hudson.security.AuthorizationStrategy;\nimport hudson.security.Permission;\nimport hudson.security.SidACL;\nimport hudson.security.csrf.CrumbIssuer;\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.regex.Pattern;\nimport jenkins.model.Jenkins;\nimport org.acegisecurity.acls.sid.Sid;\nimport org.acegisecurity.context.SecurityContext;\nimport org.acegisecurity.context.SecurityContextHolder;\nimport org.apache.commons.httpclient.HttpStatus;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport org.junit.Rule;\nimport org.junit.rules.TemporaryFolder;\nimport org.jvnet.hudson.test.Issue;\nimport org.jvnet.hudson.test.JenkinsRule;\nimport org.jvnet.hudson.test.MockFolder;\n\npublic class ItemsTest {\n\n    @Rule public JenkinsRule r = new JenkinsRule();\n    @Rule public TemporaryFolder tmpRule = new TemporaryFolder();\n\n    @Test public void getAllItems() throws Exception {\n        MockFolder d = r.createFolder(\"d\");\n        MockFolder sub2 = d.createProject(MockFolder.class, \"sub2\");\n        MockFolder sub2a = sub2.createProject(MockFolder.class, \"a\");\n        MockFolder sub2c = sub2.createProject(MockFolder.class, \"c\");\n        MockFolder sub2b = sub2.createProject(MockFolder.class, \"b\");\n        MockFolder sub1 = d.createProject(MockFolder.class, \"sub1\");\n        FreeStyleProject root = r.createFreeStyleProject(\"root\");\n        FreeStyleProject dp = d.createProject(FreeStyleProject.class, \"p\");\n        FreeStyleProject sub1q = sub1.createProject(FreeStyleProject.class, \"q\");\n        FreeStyleProject sub1p = sub1.createProject(FreeStyleProject.class, \"p\");\n        FreeStyleProject sub2ap = sub2a.createProject(FreeStyleProject.class, \"p\");\n        FreeStyleProject sub2bp = sub2b.createProject(FreeStyleProject.class, \"p\");\n        FreeStyleProject sub2cp = sub2c.createProject(FreeStyleProject.class, \"p\");\n        FreeStyleProject sub2alpha = sub2.createProject(FreeStyleProject.class, \"alpha\");\n        FreeStyleProject sub2BRAVO = sub2.createProject(FreeStyleProject.class, \"BRAVO\");\n        FreeStyleProject sub2charlie = sub2.createProject(FreeStyleProject.class, \"charlie\");\n        assertEquals(Arrays.asList(dp, sub1p, sub1q, sub2ap, sub2alpha, sub2bp, sub2BRAVO, sub2cp, sub2charlie), Items.getAllItems(d, FreeStyleProject.class));\n        assertEquals(Arrays.<Item>asList(sub2a, sub2ap, sub2alpha, sub2b, sub2bp, sub2BRAVO, sub2c, sub2cp, sub2charlie), Items.getAllItems(sub2, Item.class));\n    }\n\n    @Issue(\"JENKINS-24825\")\n    @Test public void moveItem() throws Exception {\n        File tmp = tmpRule.getRoot();\n        r.jenkins.setRawBuildsDir(tmp.getAbsolutePath()+\"/${ITEM_FULL_NAME}\");\n        MockFolder foo = r.createFolder(\"foo\");\n        MockFolder bar = r.createFolder(\"bar\");\n        FreeStyleProject test = foo.createProject(FreeStyleProject.class, \"test\");\n        test.scheduleBuild2(0).get();\n        Items.move(test, bar);\n        assertFalse(new File(tmp, \"foo/test/1\").exists());\n        assertTrue(new File(tmp, \"bar/test/1\").exists());\n    }\n    \n    // TODO would be more efficient to run these all as a single test case, but after a few Jetty seems to stop serving new content and new requests just hang.\n\n    private void overwriteTargetSetUp() throws Exception {\n        // A fully visible item:\n        r.createFreeStyleProject(\"visible\").setDescription(\"visible\");\n        // An item known to exist but not visible:\n        r.createFreeStyleProject(\"known\").setDescription(\"known\");\n        // An item not even known to exist:\n        r.createFreeStyleProject(\"secret\").setDescription(\"secret\");\n        // A folder from which to launch move attacks:\n        r.createFolder(\"d\");\n        r.jenkins.setSecurityRealm(r.createDummySecurityRealm());\n        r.jenkins.setAuthorizationStrategy(new MockAuthorizationStrategy().\n            grant(Jenkins.READ).everywhere().to(\"attacker\").\n            grant(Item.READ, Item.CONFIGURE, Item.CREATE, Item.DELETE).onPaths(\"(?!known|secret).*\").to(\"attacker\").\n            grant(Item.DISCOVER).onPaths(\"known\").to(\"attacker\"));\n    }\n\n    /** Control cases: if there is no such item yet, nothing is stopping you. */\n    @Test public void overwriteNonexistentTarget() throws Exception {\n        overwriteTargetSetUp();\n        for (OverwriteTactic tactic : OverwriteTactic.values()) {\n            tactic.run(r, \"nonexistent\");\n            System.out.println(tactic + \" worked as expected on a nonexistent target\");\n            r.jenkins.getItem(\"nonexistent\").delete();\n        }\n    }\n\n    private void cannotOverwrite(String target) throws Exception {\n        overwriteTargetSetUp();\n        for (OverwriteTactic tactic : OverwriteTactic.values()) {\n            try {\n                tactic.run(r, target);\n                fail(tactic + \" was not supposed to work against \" + target);\n            } catch (Exception x) {\n                System.out.println(\"good, \" + tactic + \" failed on \" + target + \": \" + x);\n                assertEquals(tactic + \" still overwrote \" + target, target, r.jenkins.getItemByFullName(target, FreeStyleProject.class).getDescription());\n            }\n        }\n    }\n\n    /** More control cases: for non-security-sensitive scenarios, we prevent you from overwriting existing items. */\n    @Test public void overwriteVisibleTarget() throws Exception {\n        cannotOverwrite(\"visible\");\n    }\n\n    /** You may not overwrite an item you know is there even if you cannot see it. */\n    @Test public void overwriteKnownTarget() throws Exception {\n        cannotOverwrite(\"known\");\n    }\n\n    /** You are somehow prevented from overwriting an item even if you did not previously know it was there. */\n    @Issue(\"SECURITY-321\")\n    @Test public void overwriteHiddenTarget() throws Exception {\n        cannotOverwrite(\"secret\");\n    }\n\n    /** All known means of creating an item under a new name. */\n    private enum OverwriteTactic {\n        /** Use the REST command to create an empty project (normally used only from the UI in the New Item dialog). */\n        REST_EMPTY {\n            @Override void run(JenkinsRule r, String target) throws Exception {\n                JenkinsRule.WebClient wc = wc(r);\n                wc.getOptions().setRedirectEnabled(false);\n                wc.getOptions().setThrowExceptionOnFailingStatusCode(false); // redirect perversely counts as a failure\n                WebResponse webResponse = wc.getPage(new WebRequest(createCrumbedUrl(r, wc, \"createItem?name=\" + target + \"&mode=hudson.model.FreeStyleProject\"), HttpMethod.POST)).getWebResponse();\n                if (webResponse.getStatusCode() != HttpStatus.SC_MOVED_TEMPORARILY) {\n                    throw new FailingHttpStatusCodeException(webResponse);\n                }\n            }\n        },\n        /** Use the REST command to copy an existing project (normally used from the UI in the New Item dialog). */\n        REST_COPY {\n            @Override void run(JenkinsRule r, String target) throws Exception {\n                r.createFreeStyleProject(\"dupe\");\n                JenkinsRule.WebClient wc = wc(r);\n                wc.getOptions().setRedirectEnabled(false);\n                wc.getOptions().setThrowExceptionOnFailingStatusCode(false);\n                WebResponse webResponse = wc.getPage(new WebRequest(createCrumbedUrl(r, wc, \"createItem?name=\" + target + \"&mode=copy&from=dupe\"), HttpMethod.POST)).getWebResponse();\n                r.jenkins.getItem(\"dupe\").delete();\n                if (webResponse.getStatusCode() != HttpStatus.SC_MOVED_TEMPORARILY) {\n                    throw new FailingHttpStatusCodeException(webResponse);\n                }\n            }\n        },\n        /** Overwrite target using REST command to create a project from XML submission. */\n        REST_CREATE {\n            @Override void run(JenkinsRule r, String target) throws Exception {\n                JenkinsRule.WebClient wc = wc(r);\n                WebRequest req = new WebRequest(createCrumbedUrl(r, wc, \"createItem?name=\" + target), HttpMethod.POST);\n                req.setAdditionalHeader(\"Content-Type\", \"application/xml\");\n                req.setRequestBody(\"<project/>\");\n                wc.getPage(req);\n            }\n        },\n        /** Overwrite target using REST command to rename an existing project (normally used from the UI in the Configure screen). */\n        REST_RENAME {\n            @Override void run(JenkinsRule r, String target) throws Exception {\n                r.createFreeStyleProject(\"dupe\");\n                JenkinsRule.WebClient wc = wc(r);\n                wc.getOptions().setRedirectEnabled(false);\n                wc.getOptions().setThrowExceptionOnFailingStatusCode(false);\n                WebResponse webResponse = wc.getPage(new WebRequest(createCrumbedUrl(r, wc, \"job/dupe/doRename?newName=\" + target), HttpMethod.POST)).getWebResponse();\n                if (webResponse.getStatusCode() != HttpStatus.SC_MOVED_TEMPORARILY) {\n                    r.jenkins.getItem(\"dupe\").delete();\n                    throw new FailingHttpStatusCodeException(webResponse);\n                }\n                assertNull(r.jenkins.getItem(\"dupe\"));\n            }\n        },\n        /** Overwrite target using the CLI {@code create-job} command. */\n        CLI_CREATE {\n            @Override void run(JenkinsRule r, String target) throws Exception {\n                CLICommand cmd = new CreateJobCommand();\n                CLICommandInvoker invoker = new CLICommandInvoker(r, cmd);\n                cmd.setTransportAuth(User.get(\"attacker\").impersonate());\n                int status = invoker.withStdin(new ByteArrayInputStream(\"<project/>\".getBytes(\"US-ASCII\"))).invokeWithArgs(target).returnCode();\n                if (status != 0) {\n                    throw new AbortException(\"CLI command failed with status \" + status);\n                }\n            }\n        },\n        /** Overwrite target using the CLI {@code copy-job} command. */\n        CLI_COPY {\n            @Override void run(JenkinsRule r, String target) throws Exception {\n                r.createFreeStyleProject(\"dupe\");\n                CLICommand cmd = new CopyJobCommand();\n                CLICommandInvoker invoker = new CLICommandInvoker(r, cmd);\n                cmd.setTransportAuth(User.get(\"attacker\").impersonate());\n                int status = invoker.invokeWithArgs(\"dupe\", target).returnCode();\n                r.jenkins.getItem(\"dupe\").delete();\n                if (status != 0) {\n                    throw new AbortException(\"CLI command failed with status \" + status);\n                }\n            }\n        },\n        /** Overwrite target using a move function normally called from {@code cloudbees-folder} via a {@code move} action. */\n        MOVE {\n            @Override void run(JenkinsRule r, String target) throws Exception {\n                try {\n                    SecurityContext orig = ACL.impersonate(User.get(\"attacker\").impersonate());\n                    try {\n                        Items.move(r.jenkins.getItemByFullName(\"d\", MockFolder.class).createProject(FreeStyleProject.class, target), r.jenkins);\n                    } finally {\n                        SecurityContextHolder.setContext(orig);\n                    }\n                    assertNull(r.jenkins.getItemByFullName(\"d/\" + target));\n                } catch (Exception x) {\n                    r.jenkins.getItemByFullName(\"d/\" + target).delete();\n                    throw x;\n                }\n            }\n        };\n        abstract void run(JenkinsRule r, String target) throws Exception;\n        private static final JenkinsRule.WebClient wc(JenkinsRule r) throws Exception {\n            return r.createWebClient().login(\"attacker\");\n        }\n        // TODO replace with standard version once it is fixed to detect an existing query string\n        private static URL createCrumbedUrl(JenkinsRule r, JenkinsRule.WebClient wc, String relativePath) throws IOException {\n            CrumbIssuer issuer = r.jenkins.getCrumbIssuer();\n            String crumbName = issuer.getDescriptor().getCrumbRequestField();\n            String crumb = issuer.getCrumb(null);\n            return new URL(wc.getContextPath() + relativePath + (relativePath.contains(\"?\") ? \"&\" : \"?\") + crumbName + \"=\" + crumb);\n        }\n    }\n\n    // TODO delete in 1.651+ and use standard version\n    /**\n     * An authorization strategy configured in a fluent style from test code.\n     * Install using {@link Jenkins#setAuthorizationStrategy}.\n     * You probably also want to call {@link Jenkins#setSecurityRealm} on {@link JenkinsRule#createDummySecurityRealm}.\n     */\n    private static class MockAuthorizationStrategy extends AuthorizationStrategy {\n\n        private final List<Grant.GrantOn.GrantOnTo> grantsOnTo = new ArrayList<Grant.GrantOn.GrantOnTo>();\n\n        /** Creates a new strategy granting no permissions. */\n        public MockAuthorizationStrategy() {}\n\n        /**\n         * Begin granting a set of permissions.\n         * Note that grants cannot be subsequently revoked, but you could reset the strategy to a newly configured one.\n         * @param permissions which permissions to grant ({@link Permission#impliedBy} is honored)\n         */\n        public Grant grant(Permission... permissions) {\n            Set<Permission> effective = new HashSet<Permission>(Arrays.asList(permissions));\n            boolean added = true;\n            while (added) {\n                added = false;\n                for (Permission p : Permission.getAll()) {\n                    added |= effective.contains(p.impliedBy) && effective.add(p);\n                }\n            }\n            return new Grant(effective);\n        }\n\n        /**\n         * Like {@link #grant} but does <em>not</em> honor {@link Permission#impliedBy}.\n         */\n        public Grant grantWithoutImplication(Permission... permissions) {\n            return new Grant(new HashSet<Permission>(Arrays.asList(permissions)));\n        }\n\n        /**\n         * A grant of a set of permissions.\n         * You must proceed to specify where they should be granted.\n         */\n        public class Grant {\n\n            private final Set<Permission> permissions;\n\n            Grant(Set<Permission> permissions) {\n                this.permissions = permissions;\n            }\n\n            /**\n             * Everywhere in Jenkins.\n             */\n            public GrantOn everywhere() {\n                return onPaths(\".*\");\n            }\n\n            /**\n             * On {@code Jenkins} itself, but not any child objects.\n             */\n            public GrantOn onRoot() {\n                return onPaths(\"\");\n            }\n\n            /**\n             * On some items such as jobs.\n             * If some of these happen to be {@link ItemGroup}s, the grant is <em>not</em> applied to children.\n             */\n            public GrantOn onItems(Item... items) {\n                String[] paths = new String[items.length];\n                for (int i = 0; i < items.length; i++) {\n                    paths[i] = Pattern.quote(items[i].getFullName());\n                }\n                return onPaths(paths);\n            }\n\n            /**\n             * On some item groups, typically folders.\n             * The grant applies to the folder itself as well as any (direct or indirect) children.\n             */\n            public GrantOn onFolders(ItemGroup<?>... folders) {\n                String[] paths = new String[folders.length];\n                for (int i = 0; i < folders.length; i++) {\n                    paths[i] = Pattern.quote(folders[i].getFullName()) + \"(|/.+)\";\n                }\n                return onPaths(paths);\n            }\n\n            /**\n             * On some item path expressions.\n             * Each element is an implicitly rooted regular expression.\n             * {@code Jenkins} itself is {@code \"\"}, a top-level job would be {@code \"jobname\"}, a nested job would be {@code \"folder/jobname\"}, etc.\n             * Grants are <em>not</em> implicitly applied to child objects.\n             */\n            public GrantOn onPaths(String... pathRegexps) {\n                StringBuilder b = new StringBuilder();\n                boolean first = true;\n                for (String rx : pathRegexps) {\n                    if (first) {\n                        first = false;\n                    } else {\n                        b.append('|');\n                    }\n                    b.append(\"(?:\").append(rx).append(')');\n                }\n                return new GrantOn(b.toString());\n            }\n\n            /**\n             * A grant of some permissions in certain places.\n             * You must proceed to specify to whom the grant is made.\n             */\n            public class GrantOn {\n\n                private final Pattern regexp;\n\n                GrantOn(String regexp) {\n                    this.regexp = Pattern.compile(regexp);\n                }\n\n                /** To some users or groups. */\n                public MockAuthorizationStrategy to(String... sids) {\n                    return new GrantOnTo(new HashSet<String>(Arrays.asList(sids))).add();\n                }\n\n                /** To some users. */\n                public MockAuthorizationStrategy to(User... users) {\n                    String[] sids = new String[users.length];\n                    for (int i = 0; i < users.length; i++) {\n                        sids[i] = users[i].getId();\n                    }\n                    return to(sids);\n                }\n\n                /** To everyone, including anonymous users. */\n                public MockAuthorizationStrategy toEveryone() {\n                    return to(/* SidACL.toString(ACL.EVERYONE) */\"role_everyone\");\n                }\n\n                /** To all authenticated users. */\n                public MockAuthorizationStrategy toAuthenticated() {\n                    return to(/* SecurityRealm.AUTHENTICATED_AUTHORITY */\"authenticated\");\n                }\n\n                private class GrantOnTo {\n\n                    private final Set<String> sids;\n\n                    GrantOnTo(Set<String> sids) {\n                        this.sids = sids;\n                    }\n\n                    MockAuthorizationStrategy add() {\n                        grantsOnTo.add(this);\n                        return MockAuthorizationStrategy.this;\n                    }\n\n                    boolean matches(String path, String name, Permission permission) {\n                        return regexp.matcher(path).matches() &&\n                            sids.contains(name) && // TODO consider IdStrategy\n                            permissions.contains(permission);\n                    }\n\n                }\n\n            }\n\n        }\n\n        @Override\n        public ACL getRootACL() {\n            return new ACLImpl(\"\");\n        }\n\n        @Override\n        public ACL getACL(AbstractItem item) {\n            return new ACLImpl(item.getFullName());\n        }\n\n        @Override\n        public ACL getACL(Job<?, ?> project) {\n            return getACL((AbstractItem) project); // stupid overload\n        }\n\n        private class ACLImpl extends SidACL {\n\n            private final String path;\n\n            ACLImpl(String path) {\n                this.path = path;\n            }\n\n            @Override protected Boolean hasPermission(Sid p, Permission permission) {\n                String name = toString(p);\n                for (Grant.GrantOn.GrantOnTo grantOnTo : grantsOnTo) {\n                    if (grantOnTo.matches(path, name, permission)) {\n                        return true;\n                    }\n                }\n                return null; // allow groups to be checked after users, etc.\n            }\n\n        }\n\n        @Override\n        public Collection<String> getGroups() {\n            return Collections.emptySet(); // we do not differentiate usernames from groups\n        }\n    }\n\n}\n"], "filenames": ["core/src/main/java/hudson/model/AbstractItem.java", "core/src/main/java/hudson/model/ItemGroupMixIn.java", "core/src/main/java/hudson/model/Items.java", "test/src/test/groovy/hudson/model/AbstractProjectTest.groovy", "test/src/test/java/hudson/model/ItemsTest.java"], "buggy_code_start_loc": [48, 265, 54, 528, 26], "buggy_code_end_loc": [260, 324, 437, 561, 75], "fixing_code_start_loc": [47, 265, 55, 527, 27], "fixing_code_end_loc": [241, 319, 465, 527, 480], "type": "CWE-863", "message": "Jenkins before versions 2.44 and 2.32.2 is vulnerable to an insufficient permission check. This allows users with permissions to create new items (e.g. jobs) to overwrite existing items they don't have access to (SECURITY-321).", "other": {"cve": {"id": "CVE-2017-2599", "sourceIdentifier": "secalert@redhat.com", "published": "2018-04-11T16:29:00.277", "lastModified": "2022-11-30T21:19:48.990", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Jenkins before versions 2.44 and 2.32.2 is vulnerable to an insufficient permission check. This allows users with permissions to create new items (e.g. jobs) to overwrite existing items they don't have access to (SECURITY-321)."}, {"lang": "es", "value": "Jenkins, en versiones anteriores a la 2.44 y 2.32.2, es vulnerable a una comprobaci\u00f3n de permisos insuficiente. Esto permite que usuarios con permisos para crear nuevos items (por ejemplo, jobs) para sobrescribir items existentes a los que no tienen acceso (SECURITY-321)."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.5}], "cvssMetricV30": [{"source": "secalert@redhat.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.5}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-863"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-863"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jenkins:jenkins:*:*:*:*:lts:*:*:*", "versionEndExcluding": "2.32.2", "matchCriteriaId": "F1F48E96-6C2B-4773-98A4-BFF626A0811F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jenkins:jenkins:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.44", "matchCriteriaId": "D4595374-F7F2-43D5-BB78-37E8377B1E45"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/95949", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2017-2599", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/jenkinsci/jenkins/commit/4ed5c850b6855ab064a66d02fb338f366853ce89", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://jenkins.io/security/advisory/2017-02-01/", "source": "secalert@redhat.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/jenkinsci/jenkins/commit/4ed5c850b6855ab064a66d02fb338f366853ce89"}}