{"buggy_code": ["/**\n * Form related functions.\n */\n\ndocument.addEventListener( 'DOMContentLoaded', () => {\n\tconst forms = document.querySelectorAll( '.wp-block-form-block-form' );\n\t\n\tfor ( const form of forms ) {\n\t\tform.addEventListener( 'submit', submitForm );\n\t}\n\t\n\t/**\n\t * Submit the form.\n\t * \n\t * @param\t{Event}\tevent The submit event\n\t */\n\tfunction submitForm( event ) {\n\t\tevent.preventDefault();\n\t\t\n\t\tconst form = event.currentTarget;\n\t\tconst messageContainer = form.querySelector( '.form-block__message-container' );\n\t\t\n\t\tif ( messageContainer ) {\n\t\t\tmessageContainer.remove();\n\t\t}\n\t\t\n\t\tsetSubmitMessage( form, 'loading', formBlockData.i18n.isLoading );\n\t\t\n\t\tlet intervalCount = 0;\n\t\tconst interval = setInterval( () => {\n\t\t\tintervalCount++;\n\t\t\t\n\t\t\tif ( intervalCount > 10 ) {\n\t\t\t\tclearInterval( interval );\n\t\t\t}\n\t\t\t\n\t\t\tif ( ! formBlockIsValidated ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tclearInterval( interval );\n\t\t\tconst formData = new FormData( form );\n\t\t\tconst xhr = new XMLHttpRequest();\n\t\t\t\n\t\t\tformData.set( 'action', 'form-block-submit' ) \n\t\t\t\n\t\t\txhr.open( 'POST', formBlockData.ajaxUrl, true );\n\t\t\txhr.send( formData );\n\t\t\txhr.onreadystatechange = () => {\n\t\t\t\tif ( xhr.readyState !== 4 ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif ( xhr.status === 200 ) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst response = JSON.parse( xhr.responseText );\n\t\t\t\t\t\t\n\t\t\t\t\t\tif ( response.success ) {\n\t\t\t\t\t\t\tform.reset();\n\t\t\t\t\t\t\tsetSubmitMessage( form, 'success', formBlockData.i18n.requestSuccess );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if ( response?.data?.message ) {\n\t\t\t\t\t\t\t// server-side error message\n\t\t\t\t\t\t\tsetSubmitMessage( form, 'error', response?.data?.message );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// generic error message\n\t\t\t\t\t\t\tsetSubmitMessage( form, 'error', formBlockData.i18n.backendError );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch ( error ) {\n\t\t\t\t\t\t// invalid data from server\n\t\t\t\t\t\tsetSubmitMessage( form, 'error', formBlockData.i18n.backendError );\n\t\t\t\t\t\tconsole.error( error );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// request completely failed\n\t\t\t\t\tsetSubmitMessage( form, 'error', formBlockData.i18n.requestError );\n\t\t\t\t\tconsole.error( xhr.responseText );\n\t\t\t\t}\n\t\t\t}\n\t\t}, 50 );\n\t}\n\t\n\t/**\n\t * Set a submit message.\n\t * \n\t * @param\t{HTMLElement}\tform Form element\n\t * @param\t{String}\t\tmessageType 'error', 'loading' or 'success'\n\t * @param\t{String}\t\tmessage Message\n\t */\n\tfunction setSubmitMessage( form, messageType, message ) {\n\t\tlet messageContainer = form.querySelector( '.form-block__message-container' );\n\t\t\n\t\tif ( ! messageContainer ) {\n\t\t\tmessageContainer = document.createElement( 'div' );\n\t\t\tmessageContainer.classList.add( 'form-block__message-container' );\n\t\t\tform.appendChild( messageContainer );\n\t\t}\n\t\telse {\n\t\t\tmessageContainer.classList.remove( 'is-type-error', 'is-type-loading', 'is-type-success' );\n\t\t}\n\t\t\n\t\tmessageContainer.classList.add( 'is-type-' + messageType );\n\t\t// first add only the text content to make sure no unwanted HTML is added\n\t\tmessageContainer.textContent = message;\n\t\t// then replace all newlines with <br />\n\t\tmessageContainer.innerHTML = nl2br( messageContainer.innerHTML );\n\t\t\n\t\tif ( messageType === 'loading' ) {\n\t\t\tconst loadingIndicator = document.createElement( 'span' );\n\t\t\t\n\t\t\tloadingIndicator.classList.add( 'form-block__loading-indicator' );\n\t\t\tmessageContainer.prepend( loadingIndicator );\n\t\t}\n\t\t\n\t\t// scroll error message into viewport\n\t\tif ( ! isElementInViewport( messageContainer ) ) {\n\t\t\tconst rect = messageContainer.getBoundingClientRect();\n\t\t\t\n\t\t\twindow.scrollTo( 0, window.scrollY + rect.top + messageContainer.offsetHeight - document.documentElement.clientHeight );\n\t\t}\n\t}\n} );\n\n/**\n * Replace all newlines with <br />.\n * \n * @see\t\thttps://stackoverflow.com/a/784547\n * \n * @param\t{String}\tstring Any string\n * @returns\tstring The string with replaced newlines\n */\nfunction nl2br( string ) {\n\treturn string.replace( /(?:\\r\\n|\\r|\\n)/g, '<br />' );\n}\n\n/**\n * Check if an element is in the viewport.\n * \n * @see\t\thttps://stackoverflow.com/a/7557433\n * \n * @param\t{HTMLElement}\telement The element to check\n * @returns\tWhether the element is in the viewport\n */\nfunction isElementInViewport ( element ) {\n\tconst rect = element.getBoundingClientRect();\n\t\n\treturn (\n\t\trect.top >= 0 &&\n\t\trect.left >= 0 &&\n\t\trect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&\n\t\trect.right <= (window.innerWidth || document.documentElement.clientWidth)\n\t);\n}\n", "<?php\nnamespace epiphyt\\Form_Block\\form_data;\nuse epiphyt\\Form_Block\\Form_Block;\n\n/**\n * Form data class.\n * \n * @author\tEpiphyt\n * @license\tGPL2\n * @package\tepiphyt\\Form_Block\n */\nfinal class Data {\n\t/**\n\t * @var\t\tstring The form ID\n\t */\n\tprivate $form_id = '';\n\t\n\t/**\n\t * @var\t\t\\epiphyt\\Form_Block\\form_data\\Data\n\t */\n\tpublic static $instance;\n\t\n\t/**\n\t * Initialize the class.\n\t */\n\tpublic function init(): void {\n\t\tadd_action( 'wp_ajax_form-block-submit', [ $this, 'get_request' ] );\n\t\tadd_action( 'wp_ajax_nopriv_form-block-submit', [ $this, 'get_request' ] );\n\t}\n\t\n\t/**\n\t * Get form data.\n\t * \n\t * @param\tstring\t$form_id Current form ID\n\t * @return\tarray Form data\n\t */\n\tpublic function get( string $form_id = '' ): array {\n\t\tif ( ! $form_id ) {\n\t\t\t$form_id = $this->form_id;\n\t\t}\n\t\t\n\t\tif ( ! $form_id ) {\n\t\t\treturn [];\n\t\t}\n\t\t\n\t\treturn (array) get_option( 'form_block_data_' . $form_id, [] );\n\t}\n\t\n\t/**\n\t * Get the field title of a list of fields by its name.\n\t * \n\t * @param\tstring\t$name The name to search for\n\t * @param\tarray\t$fields The fields to search in\n\t * @return\tstring The field title or the field name, if title cannot be found\n\t */\n\tpublic function get_field_title_by_name( string $name, array $fields ): string {\n\t\tForm_Block::get_instance()->reset_block_name_attributes();\n\t\t\n\t\tforeach ( $fields as $field ) {\n\t\t\t$field_name = Form_Block::get_instance()->get_block_name_attribute( $field );\n\t\t\t\n\t\t\tif ( $field_name === $name || preg_match( '/' . preg_quote( $field_name, '/' ) . '-\\d+/', $name ) ) {\n\t\t\t\treturn $field['label'] ?? $name;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn $name;\n\t}\n\t\n\t/**\n\t * Get the form ID.\n\t * \n\t * @return\tstring The form ID\n\t */\n\tpublic function get_form_id(): string {\n\t\treturn $this->form_id;\n\t}\n\t\n\t/**\n\t * Get a unique instance of the class.\n\t * \n\t * @return\t\\epiphyt\\Form_Block\\form_data\\Data The single instance of this class\n\t */\n\tpublic static function get_instance(): Data {\n\t\tif ( self::$instance === null ) {\n\t\t\tself::$instance = new self();\n\t\t}\n\t\t\n\t\treturn self::$instance;\n\t}\n\t\n\t/**\n\t * Get the request data.\n\t */\n\tpublic function get_request(): void {\n\t\tif ( ! isset( $_POST['_form_id'] ) || ! isset( $_POST['_town'] ) ) { // phpcs:ignore WordPress.Security.NonceVerification.Missing\n\t\t\t/**\n\t\t\t * Fires after a request is considered invalid.\n\t\t\t */\n\t\t\tdo_action( 'form_block_invalid_data' );\n\t\t\t\n\t\t\t// explicitly return success so that bots cannot learn\n\t\t\twp_send_json_success();\n\t\t}\n\t\t\n\t\tif ( $this->is_honeypot_filled() ) {\n\t\t\t/**\n\t\t\t * Fires after a request is considered invalid due to a filled honeypot.\n\t\t\t */\n\t\t\tdo_action( 'form_block_is_honeypot_filled' );\n\t\t\t\n\t\t\t// explicitly return success so that bots cannot learn\n\t\t\twp_send_json_success();\n\t\t}\n\t\t\n\t\t$this->form_id = sanitize_text_field( wp_unslash( $_POST['_form_id'] ) ); // phpcs:ignore WordPress.Security.NonceVerification.Missing\n\t\t\n\t\t/**\n\t\t * Fires before data has been validated.\n\t\t * \n\t\t * @param\tstring\t$form_id The form ID\n\t\t */\n\t\tdo_action( 'form_block_pre_validated_data', $this->form_id );\n\t\t\n\t\t$fields = Validation::get_instance()->fields();\n\t\t$files = Validation::get_instance()->files();\n\t\t\n\t\t/**\n\t\t * Fires after data has been validated.\n\t\t * \n\t\t * @param\tstring\t$form_id The form ID\n\t\t * @param\tarray\t$fields Validated fields\n\t\t * @param\tarray\t$files Validated files\n\t\t */\n\t\tdo_action( 'form_block_validated_data', $this->form_id, $fields, $files );\n\t\t\n\t\t$this->send( $fields, $files );\n\t}\n\t\n\t/**\n\t * Get all required fields of a form.\n\t * \n\t * @param\tstring\t$form_id Current form ID\n\t * @return\tarray List of required field names\n\t */\n\tpublic function get_required_fields( string $form_id = '' ): array {\n\t\tif ( ! $form_id ) {\n\t\t\t$form_id = $this->form_id;\n\t\t}\n\t\t\n\t\tif ( ! $form_id ) {\n\t\t\treturn [];\n\t\t}\n\t\t\n\t\tForm_Block::get_instance()->reset_block_name_attributes();\n\t\t\n\t\t$data = $this->get( $form_id );\n\t\t$required = [];\n\t\t\n\t\tforeach ( $data['fields'] as $field ) {\n\t\t\tif ( ! isset( $field['required'] ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t$required[] = Form_Block::get_instance()->get_block_name_attribute( $field );\n\t\t}\n\t\t\n\t\treturn $required;\n\t}\n\t\n\t/**\n\t * Check whether the honeypot is filled.\n\t * \n\t * @return\tboolean Wether the honeypot is filled\n\t */\n\tprivate function is_honeypot_filled(): bool {\n\t\t$honeypot_key = '_town';\n\t\t$is_filled = false;\n\t\t\n\t\t/**\n\t\t * Filter the honeypot key.\n\t\t * \n\t\t * @param\tstring\t$honeypot_key The default key '_town'\n\t\t */\n\t\t$honeypot_key = apply_filters( 'form_block_honeypot_key', $honeypot_key );\n\t\t\n\t\t$is_filled = ! empty( $_POST[ $honeypot_key ] ); // phpcs:ignore WordPress.Security.NonceVerification.Missing\n\t\t\n\t\t/**\n\t\t * Filter whether the honeypot is filled.\n\t\t * \n\t\t * @param\tbool\t$is_filled Whethter the honeypot is filled.\n\t\t */\n\t\t$is_filled = apply_filters( 'form_block_is_honeypot_filled', $is_filled );\n\t\t\n\t\treturn $is_filled;\n\t}\n\t\n\t/**\n\t * Send form submission to the recipients.\n\t * \n\t * @param\tarray\t$fields The validated fields\n\t * @param\tarray\t$files The validated files\n\t */\n\tpublic function send( array $fields, array $files ): void {\n\t\t$recipients = [\n\t\t\tget_option( 'admin_email' ),\n\t\t];\n\t\t\n\t\t/**\n\t\t * Filter the form recipients.\n\t\t * \n\t\t * @param\tarray\t$recipients The recipients\n\t\t * @param\tint\t\t$form_id The form ID\n\t\t * @param\tarray\t$fields The validated fields\n\t\t * @param\tarray\t$files The validated files\n\t\t */\n\t\t$recipients = apply_filters( 'form_block_recipients', $recipients, $this->form_id, $fields, $files );\n\t\t\n\t\t$field_data = $this->get( $this->form_id );\n\t\t$field_output = [];\n\t\t\n\t\tforeach ( $fields as $name => $value ) {\n\t\t\t$output = $this->get_field_title_by_name( $name, $field_data['fields'] ) . ': ';\n\t\t\t\n\t\t\tif ( strpos( $value, PHP_EOL ) !== false ) {\n\t\t\t\t$output .= PHP_EOL;\n\t\t\t}\n\t\t\t\n\t\t\tif ( ! is_array( $value ) ) {\n\t\t\t\t$output .= $value;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$output .= implode( PHP_EOL, array_map( function( $item ) {\n\t\t\t\t\t/* translators: list element value */\n\t\t\t\t\treturn sprintf( _x( '- %s', 'list element in plaintext email', 'form-block' ), $item );\n\t\t\t\t}, $value ) );\n\t\t\t}\n\t\t\t\n\t\t\t$field_output[] = $output;\n\t\t}\n\t\t\n\t\t$email_text = sprintf(\n\t\t\t/* translators: 1: blog title, 2: form fields */\n\t\t\t__( 'Hello,\n\nyou have just received a new form submission with the following data from \"%1$s\":\n\n%2$s\n\nYour \"%1$s\" WordPress', 'form-block' ),\n\t\t\tget_bloginfo( 'name' ),\n\t\t\timplode( PHP_EOL, $field_output )\n\t\t);\n\t\t\n\t\t/**\n\t\t * Filter the email text.\n\t\t * \n\t\t * @param\tstring\t$email_text The email text\n\t\t * @param\tstring\t$field_output The field text output\n\t\t * @param\tstring\t$form_id The form ID\n\t\t * @param\tarray\t$fields The validated fields\n\t\t */\n\t\t$email_text = apply_filters( 'form_block_email_text', $email_text, $field_output, $this->form_id, $fields );\n\t\t\n\t\t$attachments = [];\n\t\t\n\t\tif ( ! empty( $files ) ) {\n\t\t\tforeach ( $files as $file ) {\n\t\t\t\t$new_path = sys_get_temp_dir() . '/' . $file['name'];\n\t\t\t\t$attachments[] = $new_path;\n\t\t\t\t\n\t\t\t\tmove_uploaded_file( $file['path'], $new_path );\n\t\t\t}\n\t\t}\n\t\t\n\t\t/* translators: blog name */\n\t\t$subject = sprintf( __( 'New form submission via \"%s\"', 'form-block' ), get_bloginfo( 'name' ) );\n\t\t$success = [];\n\t\t\n\t\t/**\n\t\t * Filter the email subject.\n\t\t * \n\t\t * @param\tstring\t$subject The email subject\n\t\t */\n\t\t$subject = apply_filters( 'form_block_mail_subject', $subject );\n\t\t\n\t\tforeach ( $recipients as $recipient ) {\n\t\t\tif ( ! filter_var( $recipient, FILTER_VALIDATE_EMAIL ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t$sent = wp_mail( $recipient, $subject, $email_text, [], $attachments );\n\t\t\t\n\t\t\t$success[ $recipient ] = $sent;\n\t\t}\n\t\t\n\t\t/**\n\t\t * Runs after sending emails with a status per recipient.\n\t\t * If status is true, the email was sent.\n\t\t * \n\t\t * @param\tarray\t$success List of emails and whether they were sent\n\t\t * @param\tstring\t$email_text The sent email text\n\t\t * @param\tarray\t$attachments The  sentattachments\n\t\t */\n\t\tdo_action( 'form_block_sent_emails', $success, $email_text, $attachments );\n\t\t\n\t\tif ( in_array( false, array_values( $success ), true ) ) {\n\t\t\twp_send_json_error( [\n\t\t\t\t'message' => esc_html__( 'Form submission failed for at least one recipient.', 'form-block' ),\n\t\t\t] );\n\t\t}\n\t\t\n\t\twp_send_json_success();\n\t}\n\t\n\t/**\n\t * Unify the $_FILES-formatted array.\n\t * \n\t * @param\tarray\t$file_post The $_FILES-formatted array\n\t * @return\tarray The new formatted array\n\t */\n\tpublic function unify_files_array( array $file_post ): array {\n\t\t$file_ary = [];\n\t\t$file_count = count( $file_post['name'] );\n\t\t$file_keys = array_keys( $file_post );\n\t\t\n\t\tfor ( $i = 0; $i < $file_count; $i++ ) {\n\t\t\tforeach ( $file_keys as $key ) {\n\t\t\t\t$file_ary[ $i ][ $key ] = $file_post[ $key ][ $i ];\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn $file_ary;\n\t}\n}\n", "<?php\nnamespace epiphyt\\Form_Block\\form_data;\n\nuse epiphyt\\Form_Block\\Form_Block;\n\n/**\n * Form data class.\n * \n * @author\tEpiphyt\n * @license\tGPL2\n * @package\tepiphyt\\Form_Block\n */\nfinal class Validation {\n\t/**\n\t * @var\t\t\\epiphyt\\Form_Block\\form_data\\Validation\n\t */\n\tpublic static $instance;\n\t\n\t/**\n\t * Validate form fields by allowed names.\n\t *\n\t * @param\tstring\t$name The field name\n\t * @param\tarray\t$form_data The form data\n\t */\n\tprivate function by_allowed_names( string $name, array $form_data ): void {\n\t\t$allowed_names = $this->get_allowed_names( $form_data );\n\t\t$name = preg_replace( '/-\\d+$/', '', $name );\n\t\t\n\t\tif ( in_array( $name, $allowed_names, true ) ) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\twp_send_json_error( [\n\t\t\t'message' => sprintf(\n\t\t\t\t/* translators: field title */\n\t\t\t\tesc_html__( 'The following field is not allowed: %s', 'form-block' ),\n\t\t\t\tesc_html( Data::get_instance()->get_field_title_by_name( $name, $form_data['fields'] ) )\n\t\t\t),\n\t\t] );\n\t}\n\t\n\t/**\n\t * Validate form fields by field data.\n\t * \n\t * @param\tstring\t$form_id The form ID\n\t * @param\tarray\t$fields Field data from request\n\t * @return\tarray List of validation errors\n\t */\n\tprivate function by_field_data( string $form_id, array $fields ): array {\n\t\t$form_data = Data::get_instance()->get( $form_id );\n\t\t$errors = $this->get_errors( $fields, $form_data );\n\t\t\n\t\t/**\n\t\t * Filter the field data errors.\n\t\t * \n\t\t * @param\tarray\t$errors Current detected errors\n\t\t * @param\tarray\t$form_data Current form data to validate\n\t\t * @param\tarray\t$fields Field data from request\n\t\t * @param\tstring\t$form_id Current form ID\n\t\t */\n\t\t$errors = apply_filters( 'form_block_field_data_errors', $errors, $form_data, $fields, $form_id );\n\t\t\n\t\treturn $errors;\n\t}\n\t\n\t/**\n\t * Validate a field value by its field attributes.\n\t * \n\t * @param\tmixed\t$value The field value\n\t * @param\tarray\t$attributes Form field attributes\n\t * @return\tarray List of validation errors\n\t */\n\tprivate function by_attributes( $value, array $attributes ): array {\n\t\t$errors = [];\n\t\t\n\t\tforeach ( $attributes as $attribute => $attribute_value ) {\n\t\t\tswitch ( $attribute ) {\n\t\t\t\tcase 'block_type':\n\t\t\t\t\tswitch ( $attribute_value ) {\n\t\t\t\t\t\tcase 'textarea':\n\t\t\t\t\t\t\t$validated = sanitize_textarea_field( $value );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t$validated = sanitize_text_field( $value );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif ( $value !== $validated ) {\n\t\t\t\t\t\t$errors[] = [\n\t\t\t\t\t\t\t'message' => __( 'The entered value is invalid.', 'form-block' ),\n\t\t\t\t\t\t\t'type' => $attribute,\n\t\t\t\t\t\t];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'disabled':\n\t\t\t\tcase 'readonly':\n\t\t\t\t\tif (\n\t\t\t\t\t\t! empty( $attributes['value'] ) && $attributes['value'] !== $value\n\t\t\t\t\t\t|| empty( $attributes['value'] ) && ! empty( $value )\n\t\t\t\t\t) {\n\t\t\t\t\t\t$errors[] = [\n\t\t\t\t\t\t\t'message' => __( 'The value must not change.', 'form-block' ),\n\t\t\t\t\t\t\t'type' => $attribute,\n\t\t\t\t\t\t];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t/**\n\t\t * Filter the validation by field attributes.\n\t\t * \n\t\t * @param\tarray\t$errors Current error list\n\t\t * @param\tmixed\t$value The field value\n\t\t * @param\tarray\t$attributes Form field attributes\n\t\t */\n\t\t$errors = apply_filters( 'form_block_field_attributes_validation', $errors, $value, $attributes );\n\t\t\n\t\treturn $errors;\n\t}\n\t\n\t/**\n\t * Get all allowed name attributes without their unique -\\d+ part.\n\t *\n\t * @param\tarray\t$form_data Current form data to validate\n\t * @return\tarray List of allowed name attributes\n\t */\n\tprivate function get_allowed_names( array $form_data ): array {\n\t\tForm_Block::get_instance()->reset_block_name_attributes();\n\t\t\n\t\t$allowed_names = [\n\t\t\t'_form_id',\n\t\t\t'_town',\n\t\t\t'action',\n\t\t];\n\t\t\n\t\tforeach ( $form_data['fields'] as $field ) {\n\t\t\t$field_name = Form_Block::get_instance()->get_block_name_attribute( $field );\n\t\t\t$allowed_names[] = preg_replace( '/-\\d+$/', '', $field_name );\n\t\t}\n\t\t\n\t\treturn $allowed_names;\n\t}\n\t\n\t/**\n\t * Validate all POST fields.\n\t * \n\t * @return\tarray The validated fields\n\t */\n\tpublic function fields(): array {\n\t\t$form_data = get_option( 'form_block_data_' . Data::get_instance()->get_form_id(), [] );\n\t\t$validated = [];\n\t\t\n\t\t// phpcs:disable WordPress.Security.NonceVerification.Missing\n\t\tforeach ( $_POST as $key => $value ) {\n\t\t\t// sanitize_key() but with support for uppercase\n\t\t\t$key = preg_replace( '/[^A-Za-z0-9_\\-]/', '', wp_unslash( $key ) );\n\t\t\t\n\t\t\t$this->by_allowed_names( $key, $form_data );\n\t\t\t\n\t\t\t// iterate through an array to sanitize its fields\n\t\t\tif ( is_array( $value ) ) {\n\t\t\t\tforeach ( $value as $item_key => &$item ) {\n\t\t\t\t\t// if it's not a string, die with an error message\n\t\t\t\t\tif ( ! is_string( $item ) ) {\n\t\t\t\t\t\twp_send_json_error( [\n\t\t\t\t\t\t\t'message' => sprintf(\n\t\t\t\t\t\t\t\t/* translators: 1: the value name, 2: the field name */\n\t\t\t\t\t\t\t\tesc_html__( 'Wrong item format of value %1$s in field %2$s.', 'form-block' ),\n\t\t\t\t\t\t\t\tesc_html( $item_key ),\n\t\t\t\t\t\t\t\tesc_html( Data::get_instance()->get_field_title_by_name( $key, $form_data['fields'] ) )\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t] );\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t$item = sanitize_textarea_field( wp_unslash( $item ) );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// if it's not a string, die with an error message\n\t\t\t\tif ( ! is_string( $value ) ) {\n\t\t\t\t\twp_send_json_error( [\n\t\t\t\t\t\t'message' => sprintf(\n\t\t\t\t\t\t\t/* translators: the field name */\n\t\t\t\t\t\t\tesc_html__( 'Wrong item format in field %s.', 'form-block' ),\n\t\t\t\t\t\t\tesc_html( Data::get_instance()->get_field_title_by_name( $key, $form_data['fields'] ) )\n\t\t\t\t\t\t),\n\t\t\t\t\t] );\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t$value = sanitize_textarea_field( wp_unslash( $value ) );\n\t\t\t}\n\t\t\t\n\t\t\t$validated[ $key ] = $value;\n\t\t}\n\t\t// phpcs:enable\n\t\t\n\t\tunset( $validated['_form_id'], $validated['action'], $validated['_town'] );\n\t\t\n\t\t// remove empty fields\n\t\tforeach ( $validated as $key => $value ) {\n\t\t\tif ( ! empty( $value ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tunset( $validated[ $key ] );\n\t\t}\n\t\t\n\t\t/**\n\t\t * Filter the validated fields.\n\t\t * \n\t\t * @param\tarray\t$validated The validated fields\n\t\t * @param\tstring\t$form_id The form ID\n\t\t * @param\tarray\t$form_data The form data\n\t\t */\n\t\t$validated = apply_filters( 'form_block_validated_fields', $validated, Data::get_instance()->get_form_id(), $form_data );\n\t\t\n\t\t$required_fields = Data::get_instance()->get_required_fields( Data::get_instance()->get_form_id() );\n\t\t\n\t\t// check all required fields\n\t\t$missing_fields = [];\n\t\t\n\t\t// iterate through all required\n\t\tforeach ( $required_fields as $field_name ) {\n\t\t\t// check if a field with this identifier is empty\n\t\t\t// and if it's not a file upload\n\t\t\tif (\n\t\t\t\t(\n\t\t\t\t\tempty( $_FILES[ $field_name ]['tmp_name'] )\n\t\t\t\t\t|| is_array( $_FILES[ $field_name ]['tmp_name'] ) && empty( array_filter( $_FILES[ $field_name ]['tmp_name'] ) ) // phpcs:ignore WordPress.Security.ValidatedSanitizedInput.InputNotSanitized,WordPress.Security.ValidatedSanitizedInput.MissingUnslash\n\t\t\t\t)\n\t\t\t\t&& empty( $validated[ $field_name ] )\n\t\t\t) {\n\t\t\t\t$missing_fields[] = Data::get_instance()->get_field_title_by_name( $field_name, $form_data['fields'] );\n\t\t\t}\n\t\t}\n\t\t\n\t\t// output error if there are missing fields\n\t\tif ( ! empty( $missing_fields ) ) {\n\t\t\twp_send_json_error( [\n\t\t\t\t'message' => sprintf(\n\t\t\t\t\t/* translators: missing fields */\n\t\t\t\t\tesc_html( _n( 'The following field is missing: %s', 'The following fields are missing: %s', count( $missing_fields ), 'form-block' ) ),\n\t\t\t\t\tesc_html( implode( ', ', $missing_fields ) )\n\t\t\t\t),\n\t\t\t] );\n\t\t}\n\t\t\n\t\t$field_data_errors = $this->by_field_data( Data::get_instance()->get_form_id(), $validated );\n\t\t\n\t\tif ( ! empty( $field_data_errors ) ) {\n\t\t\t$message = '';\n\t\t\t\n\t\t\tforeach ( $field_data_errors as $field_errors ) {\n\t\t\t\t$message .= esc_html( $field_errors['field_title'] ) . ': ';\n\t\t\t\t\n\t\t\t\tforeach ( $field_errors['errors'] as $error ) {\n\t\t\t\t\t$message .= esc_html( $error['message'] );\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t$message .= PHP_EOL;\n\t\t\t}\n\t\t\t\n\t\t\twp_send_json_error( [\n\t\t\t\t'message' => $message,\n\t\t\t] );\n\t\t}\n\t\t\n\t\treturn $validated;\n\t}\n\t\n\t/**\n\t * Validate all files.\n\t * \n\t * @return\tarray The validated files\n\t */\n\tpublic function files(): array {\n\t\t$form_data = get_option( 'form_block_data_' . Data::get_instance()->get_form_id(), [] );\n\t\t$validated = [];\n\t\t\n\t\tif ( empty( $_FILES ) ) {\n\t\t\treturn $validated;\n\t\t}\n\t\t\n\t\t$filesize = 0;\n\t\t$maximum_file_size = wp_convert_hr_to_bytes( ini_get( 'upload_max_filesize' ) );\n\t\t$maximum_post_size = wp_convert_hr_to_bytes( ini_get( 'post_max_size' ) );\n\t\t$maximum_upload_size = max( $maximum_file_size, $maximum_post_size );\n\t\t\n\t\tif ( isset( $_SERVER['CONTENT_LENGTH'] ) || isset( $_SERVER['HTTP_CONTENT_LENGTH'] ) ) {\n\t\t\t$content_length = (int) sanitize_text_field( wp_unslash( $_SERVER['CONTENT_LENGTH'] ?? $_SERVER['HTTP_CONTENT_LENGTH'] ?? $maximum_upload_size ) );\n\t\t\t\n\t\t\tif ( $content_length >= $maximum_upload_size ) {\n\t\t\t\twp_send_json_error( [\n\t\t\t\t\t'message' => esc_html__( 'The uploaded file(s) are too big.', 'form-block' ),\n\t\t\t\t] );\n\t\t\t}\n\t\t}\n\t\t\n\t\tforeach ( $_FILES as $field_name => $files ) {\n\t\t\t$this->by_allowed_names( $field_name, $form_data );\n\t\t\t\n\t\t\tif ( is_array( $files['name'] ) ) {\n\t\t\t\t// if multiple files, resort\n\t\t\t\t$files = Data::get_instance()->unify_files_array( $files );\n\t\t\t\t\n\t\t\t\tforeach ( $files as $file ) {\n\t\t\t\t\tif ( empty( $file['tmp_name'] ) ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif ( $file['size'] > wp_max_upload_size() ) {\n\t\t\t\t\t\twp_send_json_error( [\n\t\t\t\t\t\t\t'message' => esc_html__( 'The uploaded file is too big.', 'form-block' ),\n\t\t\t\t\t\t] );\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t$filesize += $file['size'];\n\t\t\t\t\t$validated[] = [\n\t\t\t\t\t\t'name' => $file['name'],\n\t\t\t\t\t\t'path' => $file['tmp_name'],\n\t\t\t\t\t];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( ! empty( $files['tmp_name'] ) ) {\n\t\t\t\tif ( $files['size'] > wp_max_upload_size() ) {\n\t\t\t\t\twp_send_json_error( [\n\t\t\t\t\t\t'message' => esc_html__( 'The uploaded file is too big.', 'form-block' ),\n\t\t\t\t\t] );\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t$filesize += $files['size'];\n\t\t\t\t$validated[] = [\n\t\t\t\t\t'name' => $files['name'],\n\t\t\t\t\t'path' => $files['tmp_name'],\n\t\t\t\t];\n\t\t\t}\n\t\t}\n\t\t\n\t\tif ( $filesize > wp_max_upload_size() ) {\n\t\t\twp_send_json_error( [\n\t\t\t\t'message' => esc_html__( 'The uploaded file(s) are too big.', 'form-block' ),\n\t\t\t] );\n\t\t}\n\t\t\n\t\treturn $validated;\n\t}\n\t\n\t/**\n\t * Get validation errors by field data attributes.\n\t * \n\t * @param\tarray\t$fields Given fields from request\n\t * @param\tarray\t$form_data Form data\n\t * @return\tarray A list of errors\n\t */\n\tpublic function get_errors( array $fields, array $form_data ): array {\n\t\t$errors = [];\n\t\t\n\t\tif ( empty( $form_data['fields'] ) ) {\n\t\t\treturn $errors;\n\t\t}\n\t\t\n\t\tforeach ( $form_data['fields'] as $field ) {\n\t\t\tforeach ( $fields as $name => $value ) {\n\t\t\t\t$field_title = '';\n\t\t\t\t\n\t\t\t\tif ( empty( $field['name'] ) ) {\n\t\t\t\t\t$field_title = Data::get_instance()->get_field_title_by_name( $name, $form_data['fields'] );\n\t\t\t\t\t\n\t\t\t\t\tif ( empty( $field['label'] ) || $field_title !== $field['label'] ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if ( $field['name'] === $name ) {\n\t\t\t\t\t$field_title = $field['label'];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif ( empty( $field_title ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t$field_errors = $this->by_attributes( $value, $field );\n\t\t\t\t\n\t\t\t\tif ( ! empty( $field_errors ) ) {\n\t\t\t\t\t$errors[ $name ] = [\n\t\t\t\t\t\t'errors' => $field_errors,\n\t\t\t\t\t\t'field_title' => $field_title,\n\t\t\t\t\t];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn $errors;\n\t}\n\t\n\t/**\n\t * Get a unique instance of the class.\n\t * \n\t * @return\t\\epiphyt\\Form_Block\\form_data\\Validation The single instance of this class\n\t */\n\tpublic static function get_instance(): Validation {\n\t\tif ( self::$instance === null ) {\n\t\t\tself::$instance = new self();\n\t\t}\n\t\t\n\t\treturn self::$instance;\n\t}\n}\n"], "fixing_code": ["/**\n * Form related functions.\n */\n\ndocument.addEventListener( 'DOMContentLoaded', () => {\n\tconst forms = document.querySelectorAll( '.wp-block-form-block-form' );\n\t\n\tfor ( const form of forms ) {\n\t\tgetNonce( form );\n\t\tform.addEventListener( 'submit', submitForm );\n\t}\n\t\n\t/**\n\t * Get a nonce via Ajax.\n\t * \n\t * @since\t1.0.2\n\t * @param {HTMLElement} form \n\t */\n\tfunction getNonce( form ) {\n\t\tconst formData = new FormData();\n\t\tconst xhr = new XMLHttpRequest();\n\t\t\n\t\tformData.set( 'action', 'form-block-create-nonce' );\n\t\tformData.set( 'form_id', form.querySelector( '[name=\"_form_id\"]' ).value );\n\t\t\n\t\txhr.open( 'POST', formBlockData.ajaxUrl, true );\n\t\txhr.send( formData );\n\t\txhr.onreadystatechange = () => {\n\t\t\tif ( xhr.readyState !== 4 ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif ( xhr.status === 200 || xhr.status === 201 ) {\n\t\t\t\ttry {\n\t\t\t\t\tconst response = JSON.parse( xhr.responseText );\n\t\t\t\t\t\n\t\t\t\t\tif ( response.success ) {\n\t\t\t\t\t\tlet nonceField = form.querySelector( '[name=\"_wpnonce\"]' );\n\t\t\t\t\t\t\n\t\t\t\t\t\tif ( ! nonceField ) {\n\t\t\t\t\t\t\tnonceField = document.createElement( 'input' );\n\t\t\t\t\t\t\tnonceField.name = '_wpnonce';\n\t\t\t\t\t\t\tnonceField.type = 'hidden';\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tform.appendChild( nonceField );\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tnonceField.value = response?.data?.nonce;\n\t\t\t\t\t}\n\t\t\t\t\telse if ( response?.data?.message ) {\n\t\t\t\t\t\t// server-side error message\n\t\t\t\t\t\tsetSubmitMessage( form, 'error', response?.data?.message );\n\t\t\t\t\t\t\n\t\t\t\t\t\t// disable submit button if nonce creation was not successful\n\t\t\t\t\t\tconst submitButton = form.querySelector( '[type=\"submit\"]' );\n\t\t\t\t\t\t\n\t\t\t\t\t\tif ( submitButton ) {\n\t\t\t\t\t\t\tsubmitButton.disabled = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// generic error message\n\t\t\t\t\t\tsetSubmitMessage( form, 'error', formBlockData.i18n.backendError );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch ( error ) {\n\t\t\t\t\t// invalid data from server\n\t\t\t\t\tsetSubmitMessage( form, 'error', formBlockData.i18n.backendError );\n\t\t\t\t\tconsole.error( error );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// request completely failed\n\t\t\t\tsetSubmitMessage( form, 'error', formBlockData.i18n.requestError );\n\t\t\t\tconsole.error( xhr.responseText );\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * Submit the form.\n\t * \n\t * @param\t{Event}\tevent The submit event\n\t */\n\tfunction submitForm( event ) {\n\t\tevent.preventDefault();\n\t\t\n\t\tconst form = event.currentTarget;\n\t\tconst messageContainer = form.querySelector( '.form-block__message-container' );\n\t\t\n\t\tif ( messageContainer ) {\n\t\t\tmessageContainer.remove();\n\t\t}\n\t\t\n\t\tsetSubmitMessage( form, 'loading', formBlockData.i18n.isLoading );\n\t\t\n\t\tlet intervalCount = 0;\n\t\tconst interval = setInterval( () => {\n\t\t\tintervalCount++;\n\t\t\t\n\t\t\tif ( intervalCount > 10 ) {\n\t\t\t\tclearInterval( interval );\n\t\t\t}\n\t\t\t\n\t\t\tif ( ! formBlockIsValidated ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tclearInterval( interval );\n\t\t\tconst formData = new FormData( form );\n\t\t\tconst xhr = new XMLHttpRequest();\n\t\t\t\n\t\t\tformData.set( 'action', 'form-block-submit' ) \n\t\t\t\n\t\t\txhr.open( 'POST', formBlockData.ajaxUrl, true );\n\t\t\txhr.send( formData );\n\t\t\txhr.onreadystatechange = () => {\n\t\t\t\tif ( xhr.readyState !== 4 ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif ( xhr.status === 200 ) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst response = JSON.parse( xhr.responseText );\n\t\t\t\t\t\t\n\t\t\t\t\t\tif ( response.success ) {\n\t\t\t\t\t\t\tform.reset();\n\t\t\t\t\t\t\tsetSubmitMessage( form, 'success', formBlockData.i18n.requestSuccess );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if ( response?.data?.message ) {\n\t\t\t\t\t\t\t// server-side error message\n\t\t\t\t\t\t\tsetSubmitMessage( form, 'error', response?.data?.message );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// generic error message\n\t\t\t\t\t\t\tsetSubmitMessage( form, 'error', formBlockData.i18n.backendError );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch ( error ) {\n\t\t\t\t\t\t// invalid data from server\n\t\t\t\t\t\tsetSubmitMessage( form, 'error', formBlockData.i18n.backendError );\n\t\t\t\t\t\tconsole.error( error );\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// get a new nonce for another request\n\t\t\t\t\tgetNonce( form );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// request completely failed\n\t\t\t\t\tsetSubmitMessage( form, 'error', formBlockData.i18n.requestError );\n\t\t\t\t\tconsole.error( xhr.responseText );\n\t\t\t\t}\n\t\t\t}\n\t\t}, 50 );\n\t}\n\t\n\t/**\n\t * Set a submit message.\n\t * \n\t * @param\t{HTMLElement}\tform Form element\n\t * @param\t{String}\t\tmessageType 'error', 'loading' or 'success'\n\t * @param\t{String}\t\tmessage Message\n\t */\n\tfunction setSubmitMessage( form, messageType, message ) {\n\t\tlet messageContainer = form.querySelector( '.form-block__message-container' );\n\t\t\n\t\tif ( ! messageContainer ) {\n\t\t\tmessageContainer = document.createElement( 'div' );\n\t\t\tmessageContainer.classList.add( 'form-block__message-container' );\n\t\t\tform.appendChild( messageContainer );\n\t\t}\n\t\telse {\n\t\t\tmessageContainer.classList.remove( 'is-type-error', 'is-type-loading', 'is-type-success' );\n\t\t}\n\t\t\n\t\tmessageContainer.classList.add( 'is-type-' + messageType );\n\t\t// first add only the text content to make sure no unwanted HTML is added\n\t\tmessageContainer.textContent = message;\n\t\t// then replace all newlines with <br />\n\t\tmessageContainer.innerHTML = nl2br( messageContainer.innerHTML );\n\t\t\n\t\tif ( messageType === 'loading' ) {\n\t\t\tconst loadingIndicator = document.createElement( 'span' );\n\t\t\t\n\t\t\tloadingIndicator.classList.add( 'form-block__loading-indicator' );\n\t\t\tmessageContainer.prepend( loadingIndicator );\n\t\t}\n\t\t\n\t\t// scroll error message into viewport\n\t\tif ( ! isElementInViewport( messageContainer ) ) {\n\t\t\tconst rect = messageContainer.getBoundingClientRect();\n\t\t\t\n\t\t\twindow.scrollTo( 0, window.scrollY + rect.top + messageContainer.offsetHeight - document.documentElement.clientHeight );\n\t\t}\n\t}\n} );\n\n/**\n * Replace all newlines with <br />.\n * \n * @see\t\thttps://stackoverflow.com/a/784547\n * \n * @param\t{String}\tstring Any string\n * @returns\tstring The string with replaced newlines\n */\nfunction nl2br( string ) {\n\treturn string.replace( /(?:\\r\\n|\\r|\\n)/g, '<br />' );\n}\n\n/**\n * Check if an element is in the viewport.\n * \n * @see\t\thttps://stackoverflow.com/a/7557433\n * \n * @param\t{HTMLElement}\telement The element to check\n * @returns\tWhether the element is in the viewport\n */\nfunction isElementInViewport ( element ) {\n\tconst rect = element.getBoundingClientRect();\n\t\n\treturn (\n\t\trect.top >= 0 &&\n\t\trect.left >= 0 &&\n\t\trect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&\n\t\trect.right <= (window.innerWidth || document.documentElement.clientWidth)\n\t);\n}\n", "<?php\nnamespace epiphyt\\Form_Block\\form_data;\nuse epiphyt\\Form_Block\\Form_Block;\n\n/**\n * Form data class.\n * \n * @author\tEpiphyt\n * @license\tGPL2\n * @package\tepiphyt\\Form_Block\n */\nfinal class Data {\n\t/**\n\t * @var\t\tstring The form ID\n\t */\n\tprivate $form_id = '';\n\t\n\t/**\n\t * @var\t\t\\epiphyt\\Form_Block\\form_data\\Data\n\t */\n\tpublic static $instance;\n\t\n\t/**\n\t * Initialize the class.\n\t */\n\tpublic function init(): void {\n\t\tadd_action( 'wp_ajax_form-block-create-nonce', [ $this, 'create_nonce' ] );\n\t\tadd_action( 'wp_ajax_form-block-submit', [ $this, 'get_request' ] );\n\t\tadd_action( 'wp_ajax_nopriv_form-block-create-nonce', [ $this, 'create_nonce' ] );\n\t\tadd_action( 'wp_ajax_nopriv_form-block-submit', [ $this, 'get_request' ] );\n\t}\n\t\n\t/**\n\t * Create a nonce via Ajax.\n\t * \n\t * @since\t1.0.2\n\t */\n\tpublic function create_nonce(): void {\n\t\tif ( empty( $_POST['form_id'] ) ) { // phpcs:ignore WordPress.Security.NonceVerification.Missing\n\t\t\twp_send_json_error(\n\t\t\t\t[\n\t\t\t\t\t'message' => __( 'The form could not be prepared to submit requests. Please reload the page.', 'form-block' ),\n\t\t\t\t]\n\t\t\t);\n\t\t}\n\t\t\n\t\t$id = sanitize_text_field( wp_unslash( $_POST['form_id'] ) ); // phpcs:ignore WordPress.Security.NonceVerification.Missing\n\t\t\n\t\tif ( ! $this->is_valid_form_id( $id ) ) {\n\t\t\twp_send_json_error();\n\t\t}\n\t\t\n\t\twp_send_json_success(\n\t\t\t[\n\t\t\t\t'nonce' => wp_create_nonce( 'form_block_submit_' . $id ),\n\t\t\t],\n\t\t\t201\n\t\t);\n\t}\n\t\n\t/**\n\t * Get form data.\n\t * \n\t * @param\tstring\t$form_id Current form ID\n\t * @return\tarray Form data\n\t */\n\tpublic function get( string $form_id = '' ): array {\n\t\tif ( ! $form_id ) {\n\t\t\t$form_id = $this->form_id;\n\t\t}\n\t\t\n\t\tif ( ! $form_id ) {\n\t\t\treturn [];\n\t\t}\n\t\t\n\t\treturn (array) get_option( 'form_block_data_' . $form_id, [] );\n\t}\n\t\n\t/**\n\t * Get the field title of a list of fields by its name.\n\t * \n\t * @param\tstring\t$name The name to search for\n\t * @param\tarray\t$fields The fields to search in\n\t * @return\tstring The field title or the field name, if title cannot be found\n\t */\n\tpublic function get_field_title_by_name( string $name, array $fields ): string {\n\t\tForm_Block::get_instance()->reset_block_name_attributes();\n\t\t\n\t\tforeach ( $fields as $field ) {\n\t\t\t$field_name = Form_Block::get_instance()->get_block_name_attribute( $field );\n\t\t\t\n\t\t\tif ( $field_name === $name || preg_match( '/' . preg_quote( $field_name, '/' ) . '-\\d+/', $name ) ) {\n\t\t\t\treturn $field['label'] ?? $name;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn $name;\n\t}\n\t\n\t/**\n\t * Get the form ID.\n\t * \n\t * @return\tstring The form ID\n\t */\n\tpublic function get_form_id(): string {\n\t\treturn $this->form_id;\n\t}\n\t\n\t/**\n\t * Get a unique instance of the class.\n\t * \n\t * @return\t\\epiphyt\\Form_Block\\form_data\\Data The single instance of this class\n\t */\n\tpublic static function get_instance(): Data {\n\t\tif ( self::$instance === null ) {\n\t\t\tself::$instance = new self();\n\t\t}\n\t\t\n\t\treturn self::$instance;\n\t}\n\t\n\t/**\n\t * Get the request data.\n\t */\n\tpublic function get_request(): void {\n\t\tif ( empty( $_POST['_wpnonce'] ) ) {\n\t\t\t/**\n\t\t\t * Fires after verifying that the nonce is empty or absent.\n\t\t\t */\n\t\t\tdo_action( 'form_block_empty_nonce' );\n\t\t\t\n\t\t\t// explicitly return success so that bad actors cannot learn\n\t\t\twp_send_json_success();\n\t\t}\n\t\t\n\t\tif ( ! isset( $_POST['_form_id'] ) || ! isset( $_POST['_town'] ) ) {\n\t\t\t/**\n\t\t\t * Fires after a request is considered invalid.\n\t\t\t */\n\t\t\tdo_action( 'form_block_invalid_data' );\n\t\t\t\n\t\t\t// explicitly return success so that bots cannot learn\n\t\t\twp_send_json_success();\n\t\t}\n\t\t\n\t\t$this->form_id = sanitize_text_field( wp_unslash( $_POST['_form_id'] ) );\n\t\t\n\t\tif ( ! wp_verify_nonce( sanitize_text_field( wp_unslash( $_POST['_wpnonce'] ) ), 'form_block_submit_' . $this->form_id ) ) {\n\t\t\t/**\n\t\t\t * Fires after a request has an invalid nonce.\n\t\t\t */\n\t\t\tdo_action( 'form_block_invalid_nonce' );\n\t\t\t\n\t\t\t// explicitly return success so that bad actors cannot learn\n\t\t\twp_send_json_success();\n\t\t}\n\t\t\n\t\tif ( $this->is_honeypot_filled() ) {\n\t\t\t/**\n\t\t\t * Fires after a request is considered invalid due to a filled honeypot.\n\t\t\t */\n\t\t\tdo_action( 'form_block_is_honeypot_filled' );\n\t\t\t\n\t\t\t// explicitly return success so that bots cannot learn\n\t\t\twp_send_json_success();\n\t\t}\n\t\t\n\t\t/**\n\t\t * Fires before data has been validated.\n\t\t * \n\t\t * @param\tstring\t$form_id The form ID\n\t\t */\n\t\tdo_action( 'form_block_pre_validated_data', $this->form_id );\n\t\t\n\t\t$fields = Validation::get_instance()->fields();\n\t\t$files = Validation::get_instance()->files();\n\t\t\n\t\t/**\n\t\t * Fires after data has been validated.\n\t\t * \n\t\t * @param\tstring\t$form_id The form ID\n\t\t * @param\tarray\t$fields Validated fields\n\t\t * @param\tarray\t$files Validated files\n\t\t */\n\t\tdo_action( 'form_block_validated_data', $this->form_id, $fields, $files );\n\t\t\n\t\t$this->send( $fields, $files );\n\t}\n\t\n\t/**\n\t * Get all required fields of a form.\n\t * \n\t * @param\tstring\t$form_id Current form ID\n\t * @return\tarray List of required field names\n\t */\n\tpublic function get_required_fields( string $form_id = '' ): array {\n\t\tif ( ! $form_id ) {\n\t\t\t$form_id = $this->form_id;\n\t\t}\n\t\t\n\t\tif ( ! $form_id ) {\n\t\t\treturn [];\n\t\t}\n\t\t\n\t\tForm_Block::get_instance()->reset_block_name_attributes();\n\t\t\n\t\t$data = $this->get( $form_id );\n\t\t$required = [];\n\t\t\n\t\tforeach ( $data['fields'] as $field ) {\n\t\t\tif ( ! isset( $field['required'] ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t$required[] = Form_Block::get_instance()->get_block_name_attribute( $field );\n\t\t}\n\t\t\n\t\treturn $required;\n\t}\n\t\n\t/**\n\t * Check whether the honeypot is filled.\n\t * \n\t * @return\tboolean Wether the honeypot is filled\n\t */\n\tprivate function is_honeypot_filled(): bool {\n\t\t$honeypot_key = '_town';\n\t\t$is_filled = false;\n\t\t\n\t\t/**\n\t\t * Filter the honeypot key.\n\t\t * \n\t\t * @param\tstring\t$honeypot_key The default key '_town'\n\t\t */\n\t\t$honeypot_key = apply_filters( 'form_block_honeypot_key', $honeypot_key );\n\t\t\n\t\t$is_filled = ! empty( $_POST[ $honeypot_key ] ); // phpcs:ignore WordPress.Security.NonceVerification.Missing\n\t\t\n\t\t/**\n\t\t * Filter whether the honeypot is filled.\n\t\t * \n\t\t * @param\tbool\t$is_filled Whethter the honeypot is filled.\n\t\t */\n\t\t$is_filled = apply_filters( 'form_block_is_honeypot_filled', $is_filled );\n\t\t\n\t\treturn $is_filled;\n\t}\n\t\n\t/**\n\t * Check wheter a form ID is valid. That means, there are form fields stored.\n\t * \n\t * @since\t1.0.2\n\t * \n\t * @param\tstring\t$form_id The form ID to check\n\t * @return\tbool Weter a form ID is valid\n\t */\n\tpublic function is_valid_form_id( string $form_id ): bool {\n\t\t$maybe_data = (array) get_option( 'form_block_data_' . $form_id, [] );\n\t\t\n\t\treturn ! empty( $maybe_data['fields'] );\n\t}\n\t\n\t/**\n\t * Send form submission to the recipients.\n\t * \n\t * @param\tarray\t$fields The validated fields\n\t * @param\tarray\t$files The validated files\n\t */\n\tpublic function send( array $fields, array $files ): void {\n\t\t$recipients = [\n\t\t\tget_option( 'admin_email' ),\n\t\t];\n\t\t\n\t\t/**\n\t\t * Filter the form recipients.\n\t\t * \n\t\t * @param\tarray\t$recipients The recipients\n\t\t * @param\tint\t\t$form_id The form ID\n\t\t * @param\tarray\t$fields The validated fields\n\t\t * @param\tarray\t$files The validated files\n\t\t */\n\t\t$recipients = apply_filters( 'form_block_recipients', $recipients, $this->form_id, $fields, $files );\n\t\t\n\t\t$field_data = $this->get( $this->form_id );\n\t\t$field_output = [];\n\t\t\n\t\tforeach ( $fields as $name => $value ) {\n\t\t\t$output = $this->get_field_title_by_name( $name, $field_data['fields'] ) . ': ';\n\t\t\t\n\t\t\tif ( strpos( $value, PHP_EOL ) !== false ) {\n\t\t\t\t$output .= PHP_EOL;\n\t\t\t}\n\t\t\t\n\t\t\tif ( ! is_array( $value ) ) {\n\t\t\t\t$output .= $value;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$output .= implode( PHP_EOL, array_map( function( $item ) {\n\t\t\t\t\t/* translators: list element value */\n\t\t\t\t\treturn sprintf( _x( '- %s', 'list element in plaintext email', 'form-block' ), $item );\n\t\t\t\t}, $value ) );\n\t\t\t}\n\t\t\t\n\t\t\t$field_output[] = $output;\n\t\t}\n\t\t\n\t\t$email_text = sprintf(\n\t\t\t/* translators: 1: blog title, 2: form fields */\n\t\t\t__( 'Hello,\n\nyou have just received a new form submission with the following data from \"%1$s\":\n\n%2$s\n\nYour \"%1$s\" WordPress', 'form-block' ),\n\t\t\tget_bloginfo( 'name' ),\n\t\t\timplode( PHP_EOL, $field_output )\n\t\t);\n\t\t\n\t\t/**\n\t\t * Filter the email text.\n\t\t * \n\t\t * @param\tstring\t$email_text The email text\n\t\t * @param\tstring\t$field_output The field text output\n\t\t * @param\tstring\t$form_id The form ID\n\t\t * @param\tarray\t$fields The validated fields\n\t\t */\n\t\t$email_text = apply_filters( 'form_block_email_text', $email_text, $field_output, $this->form_id, $fields );\n\t\t\n\t\t$attachments = [];\n\t\t\n\t\tif ( ! empty( $files ) ) {\n\t\t\tforeach ( $files as $file ) {\n\t\t\t\t$new_path = sys_get_temp_dir() . '/' . $file['name'];\n\t\t\t\t$attachments[] = $new_path;\n\t\t\t\t\n\t\t\t\tmove_uploaded_file( $file['path'], $new_path );\n\t\t\t}\n\t\t}\n\t\t\n\t\t/* translators: blog name */\n\t\t$subject = sprintf( __( 'New form submission via \"%s\"', 'form-block' ), get_bloginfo( 'name' ) );\n\t\t$success = [];\n\t\t\n\t\t/**\n\t\t * Filter the email subject.\n\t\t * \n\t\t * @param\tstring\t$subject The email subject\n\t\t */\n\t\t$subject = apply_filters( 'form_block_mail_subject', $subject );\n\t\t\n\t\tforeach ( $recipients as $recipient ) {\n\t\t\tif ( ! filter_var( $recipient, FILTER_VALIDATE_EMAIL ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t$sent = wp_mail( $recipient, $subject, $email_text, [], $attachments );\n\t\t\t\n\t\t\t$success[ $recipient ] = $sent;\n\t\t}\n\t\t\n\t\t/**\n\t\t * Runs after sending emails with a status per recipient.\n\t\t * If status is true, the email was sent.\n\t\t * \n\t\t * @param\tarray\t$success List of emails and whether they were sent\n\t\t * @param\tstring\t$email_text The sent email text\n\t\t * @param\tarray\t$attachments The  sentattachments\n\t\t */\n\t\tdo_action( 'form_block_sent_emails', $success, $email_text, $attachments );\n\t\t\n\t\tif ( in_array( false, array_values( $success ), true ) ) {\n\t\t\twp_send_json_error( [\n\t\t\t\t'message' => esc_html__( 'Form submission failed for at least one recipient.', 'form-block' ),\n\t\t\t] );\n\t\t}\n\t\t\n\t\twp_send_json_success();\n\t}\n\t\n\t/**\n\t * Unify the $_FILES-formatted array.\n\t * \n\t * @param\tarray\t$file_post The $_FILES-formatted array\n\t * @return\tarray The new formatted array\n\t */\n\tpublic function unify_files_array( array $file_post ): array {\n\t\t$file_ary = [];\n\t\t$file_count = count( $file_post['name'] );\n\t\t$file_keys = array_keys( $file_post );\n\t\t\n\t\tfor ( $i = 0; $i < $file_count; $i++ ) {\n\t\t\tforeach ( $file_keys as $key ) {\n\t\t\t\t$file_ary[ $i ][ $key ] = $file_post[ $key ][ $i ];\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn $file_ary;\n\t}\n}\n", "<?php\nnamespace epiphyt\\Form_Block\\form_data;\n\nuse epiphyt\\Form_Block\\Form_Block;\n\n/**\n * Form data class.\n * \n * @author\tEpiphyt\n * @license\tGPL2\n * @package\tepiphyt\\Form_Block\n */\nfinal class Validation {\n\t/**\n\t * @var\t\t\\epiphyt\\Form_Block\\form_data\\Validation\n\t */\n\tpublic static $instance;\n\t\n\t/**\n\t * @since\t1.0.2\n\t * @var\t\tarray List of field names used by the system\n\t */\n\tprivate $system_field_names = [\n\t\t'_form_id',\n\t\t'_town',\n\t\t'_wpnonce',\n\t\t'action',\n\t];\n\t\n\t/**\n\t * Validate form fields by allowed names.\n\t *\n\t * @param\tstring\t$name The field name\n\t * @param\tarray\t$form_data The form data\n\t */\n\tprivate function by_allowed_names( string $name, array $form_data ): void {\n\t\t$allowed_names = $this->get_allowed_names( $form_data );\n\t\t$name = preg_replace( '/-\\d+$/', '', $name );\n\t\t\n\t\tif ( in_array( $name, $allowed_names, true ) ) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\twp_send_json_error( [\n\t\t\t'message' => sprintf(\n\t\t\t\t/* translators: field title */\n\t\t\t\tesc_html__( 'The following field is not allowed: %s', 'form-block' ),\n\t\t\t\tesc_html( Data::get_instance()->get_field_title_by_name( $name, $form_data['fields'] ) )\n\t\t\t),\n\t\t] );\n\t}\n\t\n\t/**\n\t * Validate form fields by field data.\n\t * \n\t * @param\tstring\t$form_id The form ID\n\t * @param\tarray\t$fields Field data from request\n\t * @return\tarray List of validation errors\n\t */\n\tprivate function by_field_data( string $form_id, array $fields ): array {\n\t\t$form_data = Data::get_instance()->get( $form_id );\n\t\t$errors = $this->get_errors( $fields, $form_data );\n\t\t\n\t\t/**\n\t\t * Filter the field data errors.\n\t\t * \n\t\t * @param\tarray\t$errors Current detected errors\n\t\t * @param\tarray\t$form_data Current form data to validate\n\t\t * @param\tarray\t$fields Field data from request\n\t\t * @param\tstring\t$form_id Current form ID\n\t\t */\n\t\t$errors = apply_filters( 'form_block_field_data_errors', $errors, $form_data, $fields, $form_id );\n\t\t\n\t\treturn $errors;\n\t}\n\t\n\t/**\n\t * Validate a field value by its field attributes.\n\t * \n\t * @param\tmixed\t$value The field value\n\t * @param\tarray\t$attributes Form field attributes\n\t * @return\tarray List of validation errors\n\t */\n\tprivate function by_attributes( $value, array $attributes ): array {\n\t\t$errors = [];\n\t\t\n\t\tforeach ( $attributes as $attribute => $attribute_value ) {\n\t\t\tswitch ( $attribute ) {\n\t\t\t\tcase 'block_type':\n\t\t\t\t\tswitch ( $attribute_value ) {\n\t\t\t\t\t\tcase 'textarea':\n\t\t\t\t\t\t\t$validated = sanitize_textarea_field( $value );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t$validated = sanitize_text_field( $value );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif ( $value !== $validated ) {\n\t\t\t\t\t\t$errors[] = [\n\t\t\t\t\t\t\t'message' => __( 'The entered value is invalid.', 'form-block' ),\n\t\t\t\t\t\t\t'type' => $attribute,\n\t\t\t\t\t\t];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'disabled':\n\t\t\t\tcase 'readonly':\n\t\t\t\t\tif (\n\t\t\t\t\t\t! empty( $attributes['value'] ) && $attributes['value'] !== $value\n\t\t\t\t\t\t|| empty( $attributes['value'] ) && ! empty( $value )\n\t\t\t\t\t) {\n\t\t\t\t\t\t$errors[] = [\n\t\t\t\t\t\t\t'message' => __( 'The value must not change.', 'form-block' ),\n\t\t\t\t\t\t\t'type' => $attribute,\n\t\t\t\t\t\t];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t/**\n\t\t * Filter the validation by field attributes.\n\t\t * \n\t\t * @param\tarray\t$errors Current error list\n\t\t * @param\tmixed\t$value The field value\n\t\t * @param\tarray\t$attributes Form field attributes\n\t\t */\n\t\t$errors = apply_filters( 'form_block_field_attributes_validation', $errors, $value, $attributes );\n\t\t\n\t\treturn $errors;\n\t}\n\t\n\t/**\n\t * Get all allowed name attributes without their unique -\\d+ part.\n\t *\n\t * @param\tarray\t$form_data Current form data to validate\n\t * @return\tarray List of allowed name attributes\n\t */\n\tprivate function get_allowed_names( array $form_data ): array {\n\t\tForm_Block::get_instance()->reset_block_name_attributes();\n\t\t\n\t\t$allowed_names = $this->system_field_names;\n\t\t\n\t\tforeach ( $form_data['fields'] as $field ) {\n\t\t\t$field_name = Form_Block::get_instance()->get_block_name_attribute( $field );\n\t\t\t$allowed_names[] = preg_replace( '/-\\d+$/', '', $field_name );\n\t\t}\n\t\t\n\t\treturn $allowed_names;\n\t}\n\t\n\t/**\n\t * Validate all POST fields.\n\t * \n\t * @return\tarray The validated fields\n\t */\n\tpublic function fields(): array {\n\t\t$form_data = get_option( 'form_block_data_' . Data::get_instance()->get_form_id(), [] );\n\t\t$validated = [];\n\t\t\n\t\t// phpcs:disable WordPress.Security.NonceVerification.Missing\n\t\tforeach ( $_POST as $key => $value ) {\n\t\t\t// sanitize_key() but with support for uppercase\n\t\t\t$key = preg_replace( '/[^A-Za-z0-9_\\-]/', '', wp_unslash( $key ) );\n\t\t\t\n\t\t\t$this->by_allowed_names( $key, $form_data );\n\t\t\t\n\t\t\t// iterate through an array to sanitize its fields\n\t\t\tif ( is_array( $value ) ) {\n\t\t\t\tforeach ( $value as $item_key => &$item ) {\n\t\t\t\t\t// if it's not a string, die with an error message\n\t\t\t\t\tif ( ! is_string( $item ) ) {\n\t\t\t\t\t\twp_send_json_error( [\n\t\t\t\t\t\t\t'message' => sprintf(\n\t\t\t\t\t\t\t\t/* translators: 1: the value name, 2: the field name */\n\t\t\t\t\t\t\t\tesc_html__( 'Wrong item format of value %1$s in field %2$s.', 'form-block' ),\n\t\t\t\t\t\t\t\tesc_html( $item_key ),\n\t\t\t\t\t\t\t\tesc_html( Data::get_instance()->get_field_title_by_name( $key, $form_data['fields'] ) )\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t] );\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t$item = sanitize_textarea_field( wp_unslash( $item ) );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// if it's not a string, die with an error message\n\t\t\t\tif ( ! is_string( $value ) ) {\n\t\t\t\t\twp_send_json_error( [\n\t\t\t\t\t\t'message' => sprintf(\n\t\t\t\t\t\t\t/* translators: the field name */\n\t\t\t\t\t\t\tesc_html__( 'Wrong item format in field %s.', 'form-block' ),\n\t\t\t\t\t\t\tesc_html( Data::get_instance()->get_field_title_by_name( $key, $form_data['fields'] ) )\n\t\t\t\t\t\t),\n\t\t\t\t\t] );\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t$value = sanitize_textarea_field( wp_unslash( $value ) );\n\t\t\t}\n\t\t\t\n\t\t\t$validated[ $key ] = $value;\n\t\t}\n\t\t// phpcs:enable\n\t\t\n\t\tforeach ( $this->system_field_names as $name ) {\n\t\t\tunset( $validated[ $name ] );\n\t\t}\n\t\t\n\t\t// remove empty fields\n\t\tforeach ( $validated as $key => $value ) {\n\t\t\tif ( ! empty( $value ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tunset( $validated[ $key ] );\n\t\t}\n\t\t\n\t\t/**\n\t\t * Filter the validated fields.\n\t\t * \n\t\t * @param\tarray\t$validated The validated fields\n\t\t * @param\tstring\t$form_id The form ID\n\t\t * @param\tarray\t$form_data The form data\n\t\t */\n\t\t$validated = apply_filters( 'form_block_validated_fields', $validated, Data::get_instance()->get_form_id(), $form_data );\n\t\t\n\t\t$required_fields = Data::get_instance()->get_required_fields( Data::get_instance()->get_form_id() );\n\t\t\n\t\t// check all required fields\n\t\t$missing_fields = [];\n\t\t\n\t\t// iterate through all required\n\t\tforeach ( $required_fields as $field_name ) {\n\t\t\t// check if a field with this identifier is empty\n\t\t\t// and if it's not a file upload\n\t\t\tif (\n\t\t\t\t(\n\t\t\t\t\tempty( $_FILES[ $field_name ]['tmp_name'] )\n\t\t\t\t\t|| is_array( $_FILES[ $field_name ]['tmp_name'] ) && empty( array_filter( $_FILES[ $field_name ]['tmp_name'] ) ) // phpcs:ignore WordPress.Security.ValidatedSanitizedInput.InputNotSanitized,WordPress.Security.ValidatedSanitizedInput.MissingUnslash\n\t\t\t\t)\n\t\t\t\t&& empty( $validated[ $field_name ] )\n\t\t\t) {\n\t\t\t\t$missing_fields[] = Data::get_instance()->get_field_title_by_name( $field_name, $form_data['fields'] );\n\t\t\t}\n\t\t}\n\t\t\n\t\t// output error if there are missing fields\n\t\tif ( ! empty( $missing_fields ) ) {\n\t\t\twp_send_json_error( [\n\t\t\t\t'message' => sprintf(\n\t\t\t\t\t/* translators: missing fields */\n\t\t\t\t\tesc_html( _n( 'The following field is missing: %s', 'The following fields are missing: %s', count( $missing_fields ), 'form-block' ) ),\n\t\t\t\t\tesc_html( implode( ', ', $missing_fields ) )\n\t\t\t\t),\n\t\t\t] );\n\t\t}\n\t\t\n\t\t$field_data_errors = $this->by_field_data( Data::get_instance()->get_form_id(), $validated );\n\t\t\n\t\tif ( ! empty( $field_data_errors ) ) {\n\t\t\t$message = '';\n\t\t\t\n\t\t\tforeach ( $field_data_errors as $field_errors ) {\n\t\t\t\t$message .= esc_html( $field_errors['field_title'] ) . ': ';\n\t\t\t\t\n\t\t\t\tforeach ( $field_errors['errors'] as $error ) {\n\t\t\t\t\t$message .= esc_html( $error['message'] );\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t$message .= PHP_EOL;\n\t\t\t}\n\t\t\t\n\t\t\twp_send_json_error( [\n\t\t\t\t'message' => $message,\n\t\t\t] );\n\t\t}\n\t\t\n\t\treturn $validated;\n\t}\n\t\n\t/**\n\t * Validate all files.\n\t * \n\t * @return\tarray The validated files\n\t */\n\tpublic function files(): array {\n\t\t$form_data = get_option( 'form_block_data_' . Data::get_instance()->get_form_id(), [] );\n\t\t$validated = [];\n\t\t\n\t\tif ( empty( $_FILES ) ) {\n\t\t\treturn $validated;\n\t\t}\n\t\t\n\t\t$filesize = 0;\n\t\t$maximum_file_size = wp_convert_hr_to_bytes( ini_get( 'upload_max_filesize' ) );\n\t\t$maximum_post_size = wp_convert_hr_to_bytes( ini_get( 'post_max_size' ) );\n\t\t$maximum_upload_size = max( $maximum_file_size, $maximum_post_size );\n\t\t\n\t\tif ( isset( $_SERVER['CONTENT_LENGTH'] ) || isset( $_SERVER['HTTP_CONTENT_LENGTH'] ) ) {\n\t\t\t$content_length = (int) sanitize_text_field( wp_unslash( $_SERVER['CONTENT_LENGTH'] ?? $_SERVER['HTTP_CONTENT_LENGTH'] ?? $maximum_upload_size ) );\n\t\t\t\n\t\t\tif ( $content_length >= $maximum_upload_size ) {\n\t\t\t\twp_send_json_error( [\n\t\t\t\t\t'message' => esc_html__( 'The uploaded file(s) are too big.', 'form-block' ),\n\t\t\t\t] );\n\t\t\t}\n\t\t}\n\t\t\n\t\tforeach ( $_FILES as $field_name => $files ) {\n\t\t\t$this->by_allowed_names( $field_name, $form_data );\n\t\t\t\n\t\t\tif ( is_array( $files['name'] ) ) {\n\t\t\t\t// if multiple files, resort\n\t\t\t\t$files = Data::get_instance()->unify_files_array( $files );\n\t\t\t\t\n\t\t\t\tforeach ( $files as $file ) {\n\t\t\t\t\tif ( empty( $file['tmp_name'] ) ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif ( $file['size'] > wp_max_upload_size() ) {\n\t\t\t\t\t\twp_send_json_error( [\n\t\t\t\t\t\t\t'message' => esc_html__( 'The uploaded file is too big.', 'form-block' ),\n\t\t\t\t\t\t] );\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t$filesize += $file['size'];\n\t\t\t\t\t$validated[] = [\n\t\t\t\t\t\t'name' => $file['name'],\n\t\t\t\t\t\t'path' => $file['tmp_name'],\n\t\t\t\t\t];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( ! empty( $files['tmp_name'] ) ) {\n\t\t\t\tif ( $files['size'] > wp_max_upload_size() ) {\n\t\t\t\t\twp_send_json_error( [\n\t\t\t\t\t\t'message' => esc_html__( 'The uploaded file is too big.', 'form-block' ),\n\t\t\t\t\t] );\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t$filesize += $files['size'];\n\t\t\t\t$validated[] = [\n\t\t\t\t\t'name' => $files['name'],\n\t\t\t\t\t'path' => $files['tmp_name'],\n\t\t\t\t];\n\t\t\t}\n\t\t}\n\t\t\n\t\tif ( $filesize > wp_max_upload_size() ) {\n\t\t\twp_send_json_error( [\n\t\t\t\t'message' => esc_html__( 'The uploaded file(s) are too big.', 'form-block' ),\n\t\t\t] );\n\t\t}\n\t\t\n\t\treturn $validated;\n\t}\n\t\n\t/**\n\t * Get validation errors by field data attributes.\n\t * \n\t * @param\tarray\t$fields Given fields from request\n\t * @param\tarray\t$form_data Form data\n\t * @return\tarray A list of errors\n\t */\n\tpublic function get_errors( array $fields, array $form_data ): array {\n\t\t$errors = [];\n\t\t\n\t\tif ( empty( $form_data['fields'] ) ) {\n\t\t\treturn $errors;\n\t\t}\n\t\t\n\t\tforeach ( $form_data['fields'] as $field ) {\n\t\t\tforeach ( $fields as $name => $value ) {\n\t\t\t\t$field_title = '';\n\t\t\t\t\n\t\t\t\tif ( empty( $field['name'] ) ) {\n\t\t\t\t\t$field_title = Data::get_instance()->get_field_title_by_name( $name, $form_data['fields'] );\n\t\t\t\t\t\n\t\t\t\t\tif ( empty( $field['label'] ) || $field_title !== $field['label'] ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if ( $field['name'] === $name ) {\n\t\t\t\t\t$field_title = $field['label'];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif ( empty( $field_title ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t$field_errors = $this->by_attributes( $value, $field );\n\t\t\t\t\n\t\t\t\tif ( ! empty( $field_errors ) ) {\n\t\t\t\t\t$errors[ $name ] = [\n\t\t\t\t\t\t'errors' => $field_errors,\n\t\t\t\t\t\t'field_title' => $field_title,\n\t\t\t\t\t];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn $errors;\n\t}\n\t\n\t/**\n\t * Get a unique instance of the class.\n\t * \n\t * @return\t\\epiphyt\\Form_Block\\form_data\\Validation The single instance of this class\n\t */\n\tpublic static function get_instance(): Validation {\n\t\tif ( self::$instance === null ) {\n\t\t\tself::$instance = new self();\n\t\t}\n\t\t\n\t\treturn self::$instance;\n\t}\n}\n"], "filenames": ["assets/js/form.js", "inc/form-data/class-data.php", "inc/form-data/class-validation.php"], "buggy_code_start_loc": [8, 26, 19], "buggy_code_end_loc": [75, 196, 199], "fixing_code_start_loc": [9, 27, 20], "fixing_code_end_loc": [147, 261, 208], "type": "CWE-352", "message": "Form block is a wordpress plugin designed to make form creation easier. Versions prior to 1.0.2 are subject to a Cross-Site Request Forgery due to a missing nonce check. There is potential for a Cross Site Request Forgery for all form blocks, since it allows to send requests to the forms from any website without a user noticing. Users are advised to upgrade to version 1.0.2. There are no known workarounds for this vulnerability.", "other": {"cve": {"id": "CVE-2023-30616", "sourceIdentifier": "security-advisories@github.com", "published": "2023-04-20T18:15:07.367", "lastModified": "2023-05-01T18:46:24.547", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Form block is a wordpress plugin designed to make form creation easier. Versions prior to 1.0.2 are subject to a Cross-Site Request Forgery due to a missing nonce check. There is potential for a Cross Site Request Forgery for all form blocks, since it allows to send requests to the forms from any website without a user noticing. Users are advised to upgrade to version 1.0.2. There are no known workarounds for this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-352"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:epiph:form_block:*:*:*:*:*:wordpress:*:*", "versionEndExcluding": "1.0.2", "matchCriteriaId": "A6E131BC-61B8-47BC-9A19-12EAEFA493DC"}]}]}], "references": [{"url": "https://github.com/epiphyt/form-block/commit/cf0012fa0710d906c594346ba775c5dc433a9426", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/epiphyt/form-block/security/advisories/GHSA-j4c2-7p87-q824", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/epiphyt/form-block/commit/cf0012fa0710d906c594346ba775c5dc433a9426"}}