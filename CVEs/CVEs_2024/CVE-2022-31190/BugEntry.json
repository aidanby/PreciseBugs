{"buggy_code": ["/**\n * The contents of this file are subject to the license and copyright\n * detailed in the LICENSE and NOTICE files at the root of the source\n * tree and available online at\n *\n * http://www.dspace.org/license/\n */\npackage org.dspace.app.xmlui.cocoon;\n\nimport java.io.IOException;\nimport java.sql.SQLException;\nimport java.util.UUID;\n\nimport org.apache.cocoon.ProcessingException;\nimport org.apache.cocoon.ResourceNotFoundException;\nimport org.apache.cocoon.environment.ObjectModelHelper;\nimport org.apache.cocoon.environment.Request;\nimport org.apache.cocoon.generation.AbstractGenerator;\nimport org.dspace.app.xmlui.objectmanager.AbstractAdapter;\nimport org.dspace.app.xmlui.objectmanager.ContainerAdapter;\nimport org.dspace.app.xmlui.objectmanager.ItemAdapter;\nimport org.dspace.app.xmlui.objectmanager.RepositoryAdapter;\nimport org.dspace.app.xmlui.utils.ContextUtil;\nimport org.dspace.app.xmlui.wing.WingException;\nimport org.dspace.content.Collection;\nimport org.dspace.content.Community;\nimport org.dspace.content.DSpaceObject;\nimport org.dspace.content.Item;\nimport org.dspace.content.crosswalk.CrosswalkException;\nimport org.dspace.content.factory.ContentServiceFactory;\nimport org.dspace.content.service.CollectionService;\nimport org.dspace.content.service.CommunityService;\nimport org.dspace.content.service.ItemService;\nimport org.dspace.core.Context;\nimport org.dspace.handle.factory.HandleServiceFactory;\nimport org.dspace.handle.service.HandleService;\nimport org.xml.sax.SAXException;\n\n/**\n * Generate a METS document for the identified item, community or collection. The object to be rendered should be\n * identified by passing in one of the two parameters: handle or internal. If an internal ID is given then it must\n * be of the form \"type:id\" i.g. item:255 or community:4 or repository:123456789. In the case of a repository the\n * id must be the handle prefix.\n * \n * In addition to rendering a METS document there are several options which can be specified for how the mets\n * document should be rendered. All parameters are a comma-separated list of values, here is a list:\n * \n * \n * sections:\n * \n * A comma-separated list of METS sections to included. The possible values are: \"metsHdr\", \"dmdSec\", \n * \"amdSec\", \"fileSec\", \"structMap\", \"structLink\", \"behaviorSec\", and \"extraSec\". If no list is provided then *ALL*\n * sections are rendered.\n * \n * \n * dmdTypes:\n * \n * A comma-separated list of metadata formats to provide as descriptive metadata. The list of available metadata\n * types is defined in the dspace.cfg, dissemination crosswalks. If no formats are provided them DIM - DSpace \n * Intermediate Format - is used.\n * \n * \n * amdTypes:\n * \n * A comma-separated list of metadata formats to provide administrative metadata. DSpace does not currently\n * support this type of metadata.\n * \n * \n * fileGrpTypes:\n * \n * A comma-separated list of file groups to render. For DSpace a bundle is translated into a METS fileGrp, so\n * possible values are \"THUMBNAIL\",\"CONTENT\", \"METADATA\", etc... If no list is provided then all groups are\n * rendered.\n * \n * \n * structTypes:\n * \n * A comma-separated list of structure types to render. For DSpace there is only one structType: LOGICAL. If this\n * is provided then the logical structType will be rendered, otherwise none will. The default operation is to\n * render all structure types.\n * \n * @author Scott Phillips\n */\npublic class DSpaceMETSGenerator extends AbstractGenerator\n{\n    protected HandleService handleService = HandleServiceFactory.getInstance().getHandleService();\n    protected CommunityService communityService = ContentServiceFactory.getInstance().getCommunityService();\n   \tprotected CollectionService collectionService = ContentServiceFactory.getInstance().getCollectionService();\n    protected ItemService itemService = ContentServiceFactory.getInstance().getItemService();\n\n\t/**\n\t * Generate the METS Document.\n     * @throws java.io.IOException passed through.\n     * @throws org.xml.sax.SAXException passed through.\n     * @throws org.apache.cocoon.ProcessingException on error.\n\t */\n    @Override\n\tpublic void generate() throws IOException, SAXException, ProcessingException {\n\t\ttry {\n\t\t\t// Open a new context.\n\t\t\tContext context = ContextUtil.obtainContext(objectModel);\n\t\t\t\n\t\t\t// Determine which adapter to use\n\t\t\tAbstractAdapter adapter = resolveAdapter(context);\n            if (adapter == null)\n            {\n                throw new ResourceNotFoundException(\"Unable to locate object.\");\n            }\n            \n            // Configure the adapter for this request.\n            configureAdapter(adapter);\n            \n\t\t\t// Generate the METS document\n\t\t\tcontentHandler.startDocument();\n\t\t\tadapter.renderMETS(context, contentHandler,lexicalHandler);\n\t\t\tcontentHandler.endDocument();\n\t\t\t\n\t\t} catch (WingException we) {\n\t\t\tthrow new ProcessingException(we);\n\t\t} catch (CrosswalkException ce) {\n\t\t\tthrow new ProcessingException(ce);\n\t\t} catch (SQLException sqle) {\n\t\t\tthrow new ProcessingException(sqle);\n\t\t}\n\t}\n   \n\t\n\t\n\t/**\n\t * Determine which type of adapter to use for this object, either a community, collection, item, or\n\t * repository adapter. The decision is based upon the two supplied identifiers: a handle or an\n\t * internal id. If the handle is supplied then this is resolved and the appropriate adapter is\n\t * picked. Otherwise the internal identifier is used to resolve the correct type of adapter.\n\t * \n\t * The internal identifier must be of the form \"type:id\" i.g. item:255 or collection:99. In the\n\t * case of a repository the handle prefix must be used.\n\t * \n\t * @return Return the correct adaptor or null if none found.\n\t */\n\tprivate AbstractAdapter resolveAdapter(Context context) throws SQLException \n\t{\t\t\t\n\t\tRequest request = ObjectModelHelper.getRequest(objectModel);\n        String contextPath = request.getContextPath();\n\n        // Determine the correct adapter to use for this item\n        String handle = parameters.getParameter(\"handle\",null);\n        String internal = parameters.getParameter(\"internal\",null);\n\t\t\n        AbstractAdapter adapter = null;\n\t\t if (handle != null)\n         {\n            // Specified using a regular handle.\n            DSpaceObject dso = handleService.resolveToObject(context, handle);\n\n            // Handles can be either items or containers.\n            if (dso instanceof Item)\n            {\n                adapter = new ItemAdapter(context, (Item) dso, contextPath);\n            }\n         \telse if (dso instanceof Collection || dso instanceof Community)\n            {\n                adapter = new ContainerAdapter(context, dso, contextPath);\n            }\n         }\n         else if (internal != null)\n         {\n        \t// Internal identifier, format: \"type:id\".\n         \tString[] parts = internal.split(\":\");\n         \t\n         \tif (parts.length == 2)\n         \t{\n         \t\tString type = parts[0];\n                       String strid = parts[1];\n         \t\tUUID id = null;\n\n                        // Handle prefixes must be treated as strings\n                        // all non-repository types need integer IDs\n                        if (\"repository\".equals(type))\n                        {\n                                if (handleService.getPrefix().equals(strid))\n                                {\n                                    adapter = new RepositoryAdapter(context, contextPath);\n                                }\n                        }\n                        else\n                        {\n                               id = UUID.fromString(parts[1]);\n         \t\t\tif (\"item\".equals(type))\n         \t\t\t{\n         \t\t\t\tItem item = itemService.find(context,id);\n         \t\t\t\tif (item != null)\n                         {\n                             adapter = new ItemAdapter(context, item, contextPath);\n                         }\n         \t\t\t}\n         \t\t\telse if (\"collection\".equals(type))\n         \t\t\t{\n         \t\t\t\tCollection collection = collectionService.find(context,id);\n         \t\t\t\tif (collection != null)\n                         {\n                             adapter = new ContainerAdapter(context, collection, contextPath);\n                         }\n         \t\t\t}\n         \t\t\telse if (\"community\".equals(type))\n         \t\t\t{\n         \t\t\t\tCommunity community = communityService.find(context,id);\n         \t\t\t\tif (community != null)\n                         {\n                             adapter = new ContainerAdapter(context, community, contextPath);\n                         }\n         \t\t\t}\n\t\t\t}\n         \t}\n         }\n\t\t return adapter;\n\t}\n\t\n\t/**\n\t * Configure the adapter according to the supplied parameters.\n     * @param adapter the adapter.\n\t */\n\tpublic void configureAdapter(AbstractAdapter adapter)\n\t{\n        // Configure the adapter based upon the passed parameters\n        Request request = ObjectModelHelper.getRequest(objectModel);\n        String sections = request.getParameter(\"sections\");\n        String dmdTypes = request.getParameter(\"dmdTypes\");\n        String techMDTypes = request.getParameter(\"techMDTypes\");\n        String rightsMDTypes = request.getParameter(\"rightsMDTypes\");\n        String sourceMDTypes = request.getParameter(\"sourceMDTypes\");\n        String digiprovMDTypes = request.getParameter(\"digiprovMDTypes\");\n        String fileGrpTypes = request.getParameter(\"fileGrpTypes\");\n        String structTypes = request.getParameter(\"structTypes\");\n        \n        adapter.setSections(sections);\n        adapter.setDmdTypes(dmdTypes);\n        adapter.setTechMDTypes(techMDTypes);\n        adapter.setRightsMDTypes(rightsMDTypes);\n        adapter.setSourceMDTypes(sourceMDTypes);\n        adapter.setDigiProvMDTypes(digiprovMDTypes);\n        adapter.setFileGrpTypes(fileGrpTypes);\n        adapter.setStructTypes(structTypes);\n\t}\n\n}\n", "/**\n * The contents of this file are subject to the license and copyright\n * detailed in the LICENSE and NOTICE files at the root of the source\n * tree and available online at\n *\n * http://www.dspace.org/license/\n */\npackage org.dspace.app.xmlui.cocoon;\n\nimport java.io.IOException;\nimport java.sql.SQLException;\nimport java.util.UUID;\n\nimport org.apache.cocoon.ProcessingException;\nimport org.apache.cocoon.ResourceNotFoundException;\nimport org.apache.cocoon.generation.AbstractGenerator;\nimport org.dspace.app.xmlui.utils.ContextUtil;\nimport org.dspace.authorize.AuthorizeException;\nimport org.dspace.content.DSpaceObject;\nimport org.dspace.content.Item;\nimport org.dspace.content.crosswalk.CrosswalkException;\nimport org.dspace.content.crosswalk.DisseminationCrosswalk;\nimport org.dspace.content.factory.ContentServiceFactory;\nimport org.dspace.content.service.ItemService;\nimport org.dspace.core.Context;\nimport org.dspace.core.factory.CoreServiceFactory;\nimport org.dspace.handle.factory.HandleServiceFactory;\nimport org.dspace.handle.service.HandleService;\nimport org.jdom.Element;\nimport org.jdom.JDOMException;\nimport org.jdom.output.SAXOutputter;\nimport org.xml.sax.SAXException;\n\n/**\n * Generate an ORE aggregation of a DSpace Item. The object to be rendered should be an item identified by pasing \n * in one of the two parameters: handle or internal. The fragment parameter determines the encoding format for\n * the aggregation; only Atom is supported at this time.\n\n * @author Alexey Maslov\n */\npublic class DSpaceOREGenerator extends AbstractGenerator\n{\n\n\tprotected ItemService itemService = ContentServiceFactory.getInstance().getItemService();\n\tprotected HandleService handleService = HandleServiceFactory.getInstance().getHandleService();\n\n\t/**\n\t * Generate the ORE Aggregation.\n\t */\n\tpublic void generate() throws IOException, SAXException,\n\t\t\tProcessingException {\n\t\ttry {\n\t\t\t// Grab the context.\n\t\t\tContext context = ContextUtil.obtainContext(objectModel);\n\t\t\t\n\t\t\tItem item = getItem(context);\n            if (item == null)\n            {\n                throw new ResourceNotFoundException(\"Unable to locate object.\");\n            }\n            \n            \n            // Instantiate and execute the ORE plugin\n            SAXOutputter out = new SAXOutputter(contentHandler);\n            DisseminationCrosswalk xwalk = (DisseminationCrosswalk)CoreServiceFactory.getInstance().getPluginService().getNamedPlugin(DisseminationCrosswalk.class,\"ore\");\n            \n            Element ore = xwalk.disseminateElement(context, item);\n            out.output(ore);\n            \n\t\t\t/* Generate the METS document\n\t\t\tcontentHandler.startDocument();\n\t\t\tadapter.renderMETS(contentHandler,lexicalHandler);\n\t\t\tcontentHandler.endDocument();*/\n\t\t\t\n\t\t} catch (JDOMException je) {\n\t\t\tthrow new ProcessingException(je);\n\t\t} catch (AuthorizeException ae) {\n\t\t\tthrow new ProcessingException(ae);\n\t\t} catch (CrosswalkException ce) {\n\t\t\tthrow new ProcessingException(ce);\n\t\t} catch (SQLException sqle) {\n\t\t\tthrow new ProcessingException(sqle);\n\t\t}\n\t}\n   \n\t\n\tprivate Item getItem(Context context) throws SQLException, CrosswalkException \n\t{\t\t\t\n        // Determine the correct adatper to use for this item\n        String handle = parameters.getParameter(\"handle\",null);\n        String internal = parameters.getParameter(\"internal\",null);\n\t\t\n\t\t if (handle != null)\n         {\n\t\t\t// Specified using a regular handle. \n         \tDSpaceObject dso = handleService.resolveToObject(context, handle);\n         \t\n         \t// Handles can be either items or containers.\n         \tif (dso instanceof Item)\n             {\n                 return (Item) dso;\n             }\n         \telse\n             {\n                 throw new CrosswalkException(\"ORE dissemination only available for DSpace Items.\");\n             }\n         }\n         else if (internal != null)\n         {\n        \t// Internal identifier, format: \"type:id\".\n         \tString[] parts = internal.split(\":\");\n         \t\n         \tif (parts.length == 2)\n         \t{\n         \t\tString type = parts[0];\n         \t\tUUID id = UUID.fromString(parts[1]);\n         \t\t\n         \t\tif (\"item\".equals(type))\n         \t\t{\n                     return itemService.find(context,id);\n         \t\t}\n         \t\telse\n                 {\n                     throw new CrosswalkException(\"ORE dissemination only available for DSpace Items.\");\n                 }\n         \t\t\n         \t}\n         }\n\t\t return null;\n\t}\n\t\n}\n", "/**\n * The contents of this file are subject to the license and copyright\n * detailed in the LICENSE and NOTICE files at the root of the source\n * tree and available online at\n *\n * http://www.dspace.org/license/\n */\npackage org.dspace.app.xmlui.objectmanager;\n\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.dspace.app.util.Util;\nimport org.dspace.app.xmlui.wing.AttributeMap;\nimport org.dspace.app.xmlui.wing.Namespace;\nimport org.dspace.app.xmlui.wing.WingException;\nimport org.dspace.content.Bitstream;\nimport org.dspace.content.BitstreamFormat;\nimport org.dspace.content.Item;\nimport org.dspace.content.crosswalk.CrosswalkException;\nimport org.dspace.content.crosswalk.DisseminationCrosswalk;\nimport org.dspace.core.Context;\nimport org.dspace.core.factory.CoreServiceFactory;\nimport org.xml.sax.ContentHandler;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.ext.LexicalHandler;\nimport org.xml.sax.helpers.AttributesImpl;\nimport org.xml.sax.helpers.NamespaceSupport;\n\n/**\n * This is the abstract adapter containing all the common elements between\n * the three types of adapters: item, container, and repository. Each adapter\n * translate a given type of DSpace object into a METS document for rendering\n * into the DRI document.\n * \n * <p>This class provides the chassis for those unique parts of the document to be\n * built upon. There are seven rendering methods that may be overridden for each\n * section of the METS document:\n *\n * <ul>\n * <li>Header</li>\n * <li>Descriptive Section</li>\n * <li>Administrative Section</li>\n * <li>File Section</li>\n * <li>Structure Map</li>\n * <li>Structural Link</li>\n * <li>Behavioral Section</li>\n * </ul>\n *\n * @author Scott Phillips\n */\n\npublic abstract class AbstractAdapter\n{\n    /** Namespace declaration for METS and XLINK */\n    public static final String METS_URI = \"http://www.loc.gov/METS/\";\n    public static final Namespace METS = new Namespace(METS_URI);\n    public static final String XLINK_URI = \"http://www.w3.org/TR/xlink/\";\n    public static final Namespace XLINK = new Namespace(XLINK_URI);\n    public static final String XSI_URI = \"http://www.w3.org/2001/XMLSchema-instance\";\n    public static final Namespace XSI = new Namespace(XSI_URI);\n    public static final String DIM_URI = \"http://www.dspace.org/xmlns/dspace/dim\";\n    public static final Namespace DIM = new Namespace(DIM_URI);    \n    \n    /**\n     * A sequence used to generate unique mets ids.\n     */\n    private int idSequence = 0;\n    \n    /**\n     * The contextPath of this web application, used for generating URLs.\n     */\n    protected String contextPath;\n    \n    /**\n     * The SAX handlers for content and lexical events. Also the support \n     * element for namespaces which knows the prefixes for each declared \n     * namespace.\n     */\n    protected ContentHandler contentHandler;\n    protected LexicalHandler lexicalHandler;\n    protected NamespaceSupport namespaces;\n    \n    /**\n     * Construct a new adapter, implementers must call this method so\n     * the appropriate internal values are ensured to be set correctly.\n     * \n     * @param contextPath\n     *            The contextPath of this web application.\n     */\n    public AbstractAdapter(String contextPath)\n    {\n        this.contextPath = contextPath;\n    }\n\n    /** The variables that dictate what part of the METS document to render */\n    List<String> sections = new ArrayList<>();\n    List<String> dmdTypes = new ArrayList<>();\n    Map<String,List> amdTypes = new HashMap<>();\n    List<String> fileGrpTypes = new ArrayList<>();\n    List<String> structTypes = new ArrayList<>();\n    \n    /**\n     * A comma-separated list of METS sections to render. If no value \n     * is provided then all METS sections are rendered.\n     * \n     * @param sections Comma separated list of METS sections.\n     */\n    public final void setSections(String sections)\n    {\n    \tif (sections == null)\n        {\n            return;\n        }\n\n    \tfor (String section : sections.split(\",\"))\n    \t{\n    \t\tthis.sections.add(section);\n    \t}\n    }\n    \n    /**\n     * A comma-separated list of METS descriptive metadata formats to \n     * render. If no value is provided then only the DIM format is used.\n     * \n     * @param dmdTypes Comma separated list of METS metadata types.\n     */\n    public final void setDmdTypes(String dmdTypes)\n    {\n    \tif (dmdTypes == null)\n        {\n            return;\n        }\n\n    \tfor (String dmdType : dmdTypes.split(\",\"))\n    \t{\n    \t\tthis.dmdTypes.add(dmdType);\n    \t}\n    }\n    \n    /**\n     * Store information about what will be rendered in the METS administrative\n     * metadata section.  HashMap format: keys = amdSec, value = List of mdTypes\n     *\n     * @param amdSec Section of {@code <amdSec>} where this administrative metadata\n     *                will be rendered.\n     * @param mdTypes Comma-separated list of METS metadata types.\n     */\n    public final void setAmdTypes(String amdSec, String mdTypes)\n    {\n    \tif (mdTypes == null)\n        {\n            return;\n        }\n\n        List<String> mdTypeList = new ArrayList<>();\n    \tfor (String mdType : mdTypes.split(\",\"))\n    \t{\n    \t\tmdTypeList.add(mdType);\n    \t}\n        \n        this.amdTypes.put(amdSec, mdTypeList);\n    }\n\n    /**\n     * A comma-separated list of METS technical metadata formats to\n     * render.\n     *\n     * @param techMDTypes Comma-separated list of METS metadata types.\n     */\n    public final void setTechMDTypes(String techMDTypes)\n    {\n    \tsetAmdTypes(\"techMD\", techMDTypes);\n    }\n\n    /**\n     * A comma-separated list of METS intellectual property rights metadata\n     * formats to render.\n     *\n     * @param rightsMDTypes Comma-separated list of METS metadata types.\n     */\n    public final void setRightsMDTypes(String rightsMDTypes)\n    {\n    \tsetAmdTypes(\"rightsMD\", rightsMDTypes);\n    }\n\n    /**\n     * A comma-separated list of METS source metadata\n     * formats to render.\n     *\n     * @param sourceMDTypes Comma-separated list of METS metadata types.\n     */\n    public final void setSourceMDTypes(String sourceMDTypes)\n    {\n    \tsetAmdTypes(\"sourceMD\", sourceMDTypes);\n    }\n\n    /**\n     * A comma-separated list of METS digital provenance metadata\n     * formats to render.\n     *\n     * @param digiprovMDTypes Comma-separated list of METS metadata types.\n     */\n    public final void setDigiProvMDTypes(String digiprovMDTypes)\n    {\n    \tsetAmdTypes(\"digiprovMD\", digiprovMDTypes);\n    }\n    \n    /**\n     * A comma-separated list of METS fileGrps to render. If no value\n     * is provided then all groups are rendered.\n     * \n     * @param fileGrpTypes Comma-separated list of METS file groups.\n     */\n    public final void setFileGrpTypes(String fileGrpTypes)\n    {\n    \tif (fileGrpTypes == null)\n        {\n            return;\n        }\n\n    \tfor (String fileGrpType : fileGrpTypes.split(\",\"))\n    \t{\n    \t\tthis.fileGrpTypes.add(fileGrpType);\n    \t}\n    }\n    \n    /**\n     * A comma-separated list of METS structural types to render. If no \n     * value is provided then only the DIM format is used.\n     * \n     * @param structTypes Comma-separated list of METS structure types.\n     */\n    public final void setStructTypes(String structTypes)\n    {\n    \tif (structTypes == null)\n        {\n            return;\n        }\n\n    \tfor (String structType : structTypes.split(\",\"))\n    \t{\n    \t\tthis.structTypes.add(structType);\n    \t}\n    }\n\t\n    \n    /**\n     * \n     * \n     * \n     * \n     * \n     * METS methods\n     * \n     * \n     * \n     * \n     * \n     * \n     */\n    \n    \n    /**\n     * @return the URL for this item in the interface.\n     * @throws org.dspace.app.xmlui.wing.WingException on error.\n     */\n    protected abstract String getMETSOBJID() throws WingException;\n\n    /**\n     * @return the URL for editing this item\n     */\n    protected abstract String getMETSOBJEDIT();\n\n    /**\n     * @return the METS ID of the mets document.\n     * @throws org.dspace.app.xmlui.wing.WingException on error.\n     */\n    protected abstract String getMETSID() throws WingException;\n\n    /**\n     * @return The Profile this METS document conforms to.\n     * @throws org.dspace.app.xmlui.wing.WingException on error.\n     */\n    protected abstract String getMETSProfile() throws WingException;\n\n    /**\n     * @return The label of this METS document.\n     * @throws org.dspace.app.xmlui.wing.WingException on error.\n     */\n    protected abstract String getMETSLabel() throws WingException;\n\n    \n\t/**\n\t * Render the complete METS document.\n     * @param context session context.\n     * @param contentHandler XML content handler.\n     * @param lexicalHandler XML lexical handler.\n     * @throws org.dspace.app.xmlui.wing.WingException passed through.\n     * @throws org.xml.sax.SAXException passed through.\n     * @throws org.dspace.content.crosswalk.CrosswalkException passed through.\n     * @throws java.io.IOException passed through.\n     * @throws java.sql.SQLException passed through.\n\t */\n    public final void renderMETS(Context context, ContentHandler contentHandler, LexicalHandler lexicalHandler)\n            throws WingException, SAXException, CrosswalkException, IOException, SQLException\n    {\n    \t\tthis.contentHandler = contentHandler;\n    \t\tthis.lexicalHandler = lexicalHandler;\n    \t\tthis.namespaces = new NamespaceSupport();\n    \t\n    \t\n    \t\t// Declare our namespaces\n    \t\tnamespaces.pushContext();\n    \t\tnamespaces.declarePrefix(\"mets\", METS.URI);\n    \t\tnamespaces.declarePrefix(\"xlink\", XLINK.URI);\n    \t\tnamespaces.declarePrefix(\"xsi\", XSI.URI);\n    \t\tnamespaces.declarePrefix(\"dim\", DIM.URI);\n    \t\tcontentHandler.startPrefixMapping(\"mets\", METS.URI);\n    \t\tcontentHandler.startPrefixMapping(\"xlink\", XLINK.URI);\n    \t\tcontentHandler.startPrefixMapping(\"xsi\", XSI.URI);\n    \t\tcontentHandler.startPrefixMapping(\"dim\", DIM.URI);\n    \t\t\n    \t\t// Send the METS element\n    \t\tAttributeMap attributes = new AttributeMap();\n    \t\tattributes.put(\"ID\", getMETSID());\n    \t\tattributes.put(\"PROFILE\", getMETSProfile());\n    \t\tattributes.put(\"LABEL\", getMETSLabel());\n    \t\tString objid = getMETSOBJID();\n    \t\tif (objid != null)\n            {\n                attributes.put(\"OBJID\", objid);\n            }\n\n            // Include the link for editing the item\n            objid = getMETSOBJEDIT();\n            if (objid != null)\n            {\n                attributes.put(\"OBJEDIT\", objid);\n            }\n\n    \t\tstartElement(METS,\"METS\",attributes);\n\n    \t\t// If the user requested no specific sections then render them all.\n    \t\tboolean all = (sections.isEmpty());\n    \t\t\n    \t\tif (all || sections.contains(\"metsHdr\"))\n            {\n                renderHeader();\n            }\n    \t\tif (all || sections.contains(\"dmdSec\"))\n            {\n                renderDescriptiveSection();\n            }\n    \t\tif (all || sections.contains(\"amdSec\"))\n            {\n                renderAdministrativeSection();\n            }\n    \t\tif (all || sections.contains(\"fileSec\"))\n            {\n                renderFileSection(context);\n            }\n    \t\tif (all || sections.contains(\"structMap\"))\n            {\n                renderStructureMap();\n            }\n    \t\tif (all || sections.contains(\"structLink\"))\n            {\n                renderStructuralLink();\n            }\n    \t\tif (all || sections.contains(\"behaviorSec\"))\n            {\n                renderBehavioralSection();\n            }\n    \t\t\n    \t\t// FIXME: this is not a met's section, it should be removed\n    \t\tif (all || sections.contains(\"extraSec\"))\n            {\n                renderExtraSections();\n            }\n    \t\t\n    \t\tendElement(METS,\"METS\");\n    \t\tcontentHandler.endPrefixMapping(\"mets\");\n    \t\tcontentHandler.endPrefixMapping(\"xlink\");\n    \t\tcontentHandler.endPrefixMapping(\"dim\");\n    \t\tnamespaces.popContext();\n\n    }\n\t\n    /*\n     * Each of the METS sections\n     */\n\tprotected void renderHeader() throws WingException, SAXException, CrosswalkException, IOException, SQLException  {}\n\tprotected void renderDescriptiveSection() throws WingException, SAXException, CrosswalkException, IOException, SQLException  {}\n\tprotected void renderAdministrativeSection() throws WingException, SAXException, CrosswalkException, IOException, SQLException  {}\n\tprotected void renderFileSection(Context context) throws WingException, SAXException, CrosswalkException, IOException, SQLException  {}\n\tprotected void renderStructureMap() throws WingException, SAXException, CrosswalkException, IOException, SQLException  {}\n\tprotected void renderStructuralLink() throws WingException, SAXException, CrosswalkException, IOException, SQLException  {}\n\tprotected void renderBehavioralSection() throws WingException, SAXException, CrosswalkException, IOException, SQLException  {}\n\tprotected void renderExtraSections() throws WingException, SAXException, CrosswalkException, SQLException, IOException {}\n    \n\n\n    /**\n     * Generate a METS file element for a given bitstream.\n     *\n     * @param context\n     *            Session context.\n     * @param item\n     *            If the bitstream is associated with an item provide the item\n     *            otherwise leave null.\n     * @param bitstream\n     *            The bitstream to build a file element for.\n     * @param fileID\n     *            The unique file id for this file.\n     * @param groupID\n     *            The group id for this file, if it is derived from another file\n     *            then they should share the same groupID.\n     * @throws org.xml.sax.SAXException passed through.\n     * @throws java.sql.SQLException passed through.\n     */\n\tprotected final void renderFile(Context context, Item item, Bitstream bitstream, String fileID, String groupID)\n            throws SAXException, SQLException\n    {\n       renderFile(context, item, bitstream, fileID, groupID, null);\n    }\n\n\t/**\n     * Generate a METS file element for a given bitstream.\n     *\n     * @param context\n     *            session context.\n     * @param item\n     *            If the bitstream is associated with an item, provide the item,\n     *            otherwise leave null.\n     * @param bitstream\n     *            The bitstream to build a file element for.\n     * @param fileID\n     *            The unique file id for this file.\n     * @param groupID\n     *            The group id for this file, if it is derived from another file\n     *            then they should share the same groupID.\n     * @param admID\n     *            The IDs of the administrative metadata sections which pertain\n     *            to this file\n     * @throws org.xml.sax.SAXException passed through.\n     * @throws java.sql.SQLException passed through.\n     */\n\tprotected final void renderFile(Context context, Item item,\n            Bitstream bitstream, String fileID, String groupID, String admID)\n            throws SAXException, SQLException\n    {\n\t\tAttributeMap attributes;\n\t\t\n\t\t// //////////////////////////////\n    \t// Determine the file attributes\n        BitstreamFormat format = bitstream.getFormat(context);\n        String mimeType = null;\n        if (format != null)\n        {\n            mimeType = format.getMIMEType();\n        }\n        String checksumType = bitstream.getChecksumAlgorithm();\n        String checksum = bitstream.getChecksum();\n        long size = bitstream.getSizeBytes();\n    \t\n        // ////////////////////////////////\n        // Start the actual file\n        attributes = new AttributeMap();\n        attributes.put(\"ID\", fileID);\n        attributes.put(\"GROUPID\",groupID);\n        if (admID != null && admID.length()>0)\n        {\n            attributes.put(\"ADMID\", admID);\n        }\n        if (mimeType != null && mimeType.length()>0)\n        {\n            attributes.put(\"MIMETYPE\", mimeType);\n        }\n        if (checksumType != null && checksum != null)\n        {\n        \tattributes.put(\"CHECKSUM\", checksum);\n        \tattributes.put(\"CHECKSUMTYPE\", checksumType);\n        }\n        attributes.put(\"SIZE\", String.valueOf(size));\n        startElement(METS,\"file\",attributes);\n        \n        \n        // ////////////////////////////////////\n        // Determine the file location attributes\n        String name = bitstream.getName();\n        String description = bitstream.getDescription();\n\n        \n        // If possible, reference this bitstream via a handle, however this may\n        // be null if a handle has not yet been assigned. In this case reference the\n        // item its internal id. In the last case where the bitstream is not associated\n        // with an item (such as a community logo) then reference the bitstreamID directly.\n        String identifier = null;\n        if (item != null && item.getHandle() != null)\n        {\n            identifier = \"handle/\" + item.getHandle();\n        }\n        else if (item != null)\n        {\n            identifier = \"item/\" + item.getID();\n        }\n        else\n        {\n            identifier = \"id/\" + bitstream.getID();\n        }\n        \n        \n        String url = contextPath + \"/bitstream/\"+identifier+\"/\";\n        \n        // If we can, append the pretty name of the bitstream to the URL\n        try\n        {\n        \tif (bitstream.getName() != null)\n            {\n                url += Util.encodeBitstreamName(bitstream.getName(), \"UTF-8\");\n            }\n        }\n        catch (UnsupportedEncodingException uee)\n        {\n            // just ignore it, we don't have to have a pretty\n            // name at the end of the URL because the sequence id will \n        \t// locate it. However it means that links in this file might\n        \t// not work....\n        }\n        \n        url += \"?sequence=\"+bitstream.getSequenceID();\n        \n        \n        // //////////////////////\n        // Start the file location\n        attributes = new AttributeMap();\n        AttributeMap attributesXLINK = new AttributeMap();\n        attributesXLINK.setNamespace(XLINK);\n        attributes.put(\"LOCTYPE\", \"URL\");\n        attributesXLINK.put(\"type\",\"locator\");\n        attributesXLINK.put(\"title\", name);\n        if (description != null)\n        {\n            attributesXLINK.put(\"label\", description);\n        }\n        attributesXLINK.put(\"href\", url);\n        startElement(METS,\"FLocat\",attributes,attributesXLINK);\n        \n\n        // ///////////////////////\n        // End file location\n        endElement(METS,\"FLocate\");\n        \n        // ////////////////////////////////\n        // End the file\n        endElement(METS,\"file\");\n\t}\n\t\n\t\n\t/**\n     * \n     * Generate a unique METS id. For consistency, all prefixes should probably\n     * end in an underscore, \"_\".\n     * \n     * @param prefix\n     *            Prefix to prepend to the id for readability.\n     * \n     * @return A unique METS id.\n     */\n    protected final String getGenericID(String prefix)\n    {\n        return prefix + (idSequence++);\n    }\n    \n    /**\n     * Return a dissemination crosswalk for the given name.\n     * \n     * @param crosswalkName name of crosswalk plugin to be looked up.\n     * @return The crosswalk.\n     * @throws org.dspace.app.xmlui.wing.WingException if crosswalk not found.\n     */\n    public final DisseminationCrosswalk getDisseminationCrosswalk(String crosswalkName) throws WingException \n    {\n    \t// FIXME add some caching here\n    \tDisseminationCrosswalk crosswalk\n                = (DisseminationCrosswalk) CoreServiceFactory.getInstance()\n                        .getPluginService()\n                        .getNamedPlugin(DisseminationCrosswalk.class, crosswalkName);\n\n\t    if (crosswalk == null)\n        {\n            throw new WingException(\"Unable to find named DisseminationCrosswalk: \" + crosswalkName);\n        }\n\t    \n\t    return crosswalk;\n    }\n    \n    /** \n     * The METS defined types of Metadata, if a format is not listed here \n     * then it should use the string \"OTHER\" and provide additional \n     * attributes describing the metadata type \n     */\n    public static final String[] METS_DEFINED_TYPES = \n    \t{\"MARC\",\"MODS\",\"EAD\",\"DC\",\"NISOIMG\",\"LC-AV\",\"VRA\",\"TEIHDR\",\"DDI\",\"FGDC\",\"PREMIS\"/*,\"OTHER\"*/};\n    \n    /**\n     * Determine if the provided metadata type is a standard METS\n     * defined type. If it is not, use the other string.\n     * \n     * @param metadataType type name\n     * @return True if METS defined\n     */\n    public final boolean isDefinedMETStype(String metadataType)\n    {\n       for (String definedType : METS_DEFINED_TYPES)\n       {\n           if (definedType.equals(metadataType))\n           {\n               return true;\n           }\n       }\n       return false;\n    }\n    \n    \n    \n    \n    \n    /**\n\t * \n\t * \n\t * SAX Helper methods\n\t * \n\t * \n\t *\n\t */\n\t\n\t/**\n     * Send the SAX events to start this element.\n     * \n     * @param namespace\n     *            (Required) The namespace of this element.\n     * @param name\n     *            (Required) The local name of this element.\n     * @param attributes\n     *            (May be null) Attributes for this element\n     * @throws org.xml.sax.SAXException passed through.\n     */\n    protected final void startElement(Namespace namespace, String name,\n            AttributeMap... attributes) throws SAXException\n    {\n        contentHandler.startElement(namespace.URI, name, qName(namespace, name),\n                map2sax(namespace,attributes));\n    }\n\n    /**\n     * Send the SAX event for these plain characters, not wrapped in any\n     * elements.\n     * \n     * @param characters\n     *            (May be null) Characters to send.\n     * @throws org.xml.sax.SAXException passed through.\n     */\n    protected final void sendCharacters(String characters) throws SAXException\n    {\n        if (characters != null)\n        {\n            char[] contentArray = characters.toCharArray();\n            contentHandler.characters(contentArray, 0, contentArray.length);\n        }\n    }\n    \n    /**\n     * Send the SAX events to end this element.\n     * \n     * @param namespace\n     *            (Required) The namespace of this element.\n     * @param name\n     *            (Required) The local name of this element.\n     * @throws org.xml.sax.SAXException passed through.\n     */\n    protected final void endElement(Namespace namespace, String name)\n            throws SAXException\n    {\n        contentHandler.endElement(namespace.URI, name, qName(namespace, name));\n    }\n\n    /**\n     * Build the SAX attributes object based upon Java's String map. This\n     * convenience method will build, or add to an existing attributes object,\n     * the attributes detailed in the AttributeMap.\n     * \n     * @param elementNamespace\n     *            SAX Helper class to keep track of namespaces able to determine\n     *            the correct prefix for a given namespace URI.\n     * @param attributes\n     *            An existing SAX AttributesImpl object to add attributes to.\n     *            If the value is null then a new attributes object will be\n     *            created to house the attributes.\n     * @param attributeMap\n     *            A map of attributes and values.\n     * @return\n     */\n    private AttributesImpl map2sax(Namespace elementNamespace, AttributeMap ... attributeMaps)\n    {\n\n        AttributesImpl attributes = new AttributesImpl();\n        for (AttributeMap attributeMap : attributeMaps)\n        {\n            boolean differentNamespaces = false;\n            Namespace attributeNamespace = attributeMap.getNamespace();\n            if (attributeNamespace != null && !(attributeNamespace.URI.equals(elementNamespace.URI)))\n            {\n                differentNamespaces = true;\n            }\n\n            // copy each one over.\n            for (Map.Entry<String, String> attr : attributeMap.entrySet())\n            {\n                if (attr.getValue() == null)\n                {\n                    continue;\n                }\n\n                if (differentNamespaces)\n                {\n                    attributes.addAttribute(attributeNamespace.URI, attr.getKey(),\n                            qName(attributeNamespace, attr.getKey()), \"CDATA\", attr.getValue());\n\n                }\n                else\n                {\n                    attributes.addAttribute(\"\", attr.getKey(), attr.getKey(), \"CDATA\", attr.getValue());\n                }\n            }\n        }\n        return attributes;\n    }\n    \n    /**\n     * Create the qName for the element with the given localName and namespace\n     * prefix.\n     * \n     * @param namespace\n     *            (May be null) The namespace prefix.\n     * @param localName\n     *            (Required) The element's local name.\n     * @return\n     */\n    private String qName(Namespace namespace, String localName)\n    {\n    \tString prefix = namespaces.getPrefix(namespace.URI);\n        if (prefix == null || prefix.equals(\"\"))\n        {\n            return localName;\n        }\n        else\n        {\n            return prefix + \":\" + localName;\n        }\n    }\n    \n}\n", "/**\n * The contents of this file are subject to the license and copyright\n * detailed in the LICENSE and NOTICE files at the root of the source\n * tree and available online at\n *\n * http://www.dspace.org/license/\n */\npackage org.dspace.app.xmlui.objectmanager;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.sql.SQLException;\n\nimport org.apache.log4j.Logger;\nimport org.dspace.app.xmlui.wing.AttributeMap;\nimport org.dspace.app.xmlui.wing.WingException;\nimport org.dspace.authorize.AuthorizeException;\nimport org.dspace.browse.ItemCounter;\nimport org.dspace.browse.ItemCountException;\nimport org.dspace.content.Bitstream;\nimport org.dspace.content.Collection;\nimport org.dspace.content.Community;\nimport org.dspace.content.DSpaceObject;\nimport org.dspace.content.crosswalk.CrosswalkException;\nimport org.dspace.content.crosswalk.DisseminationCrosswalk;\nimport org.dspace.content.factory.ContentServiceFactory;\nimport org.dspace.content.service.CollectionService;\nimport org.dspace.content.service.CommunityService;\nimport org.dspace.services.factory.DSpaceServicesFactory;\nimport org.dspace.core.Constants;\nimport org.dspace.core.Context;\nimport org.dspace.handle.factory.HandleServiceFactory;\nimport org.dspace.handle.service.HandleService;\nimport org.jdom.Document;\nimport org.jdom.Element;\nimport org.jdom.JDOMException;\nimport org.jdom.input.SAXBuilder;\nimport org.jdom.output.SAXOutputter;\nimport org.xml.sax.SAXException;\n\n/**\n * This is an adapter which translates DSpace containers \n * (communities and collections) into METS documents. This adapter follows\n * the DSpace METS profile, however that profile does not define how a\n * community or collection should be described, but we make the obvious \n * decisions to deviate when necessary from the profile.\n * \n * The METS document consists of three parts: descriptive metadata section,\n * file section, and a structural map. The descriptive metadata sections holds\n * metadata about the item being adapted using DSpace crosswalks. This is the \n * same way the item adapter works.\n * \n * However, the file section and structural map are a bit different. In these\n * cases the the only files listed is the one logo that may be attached to \n * a community or collection.\n * \n * @author Scott Phillips\n */\npublic class ContainerAdapter extends AbstractAdapter\n{\n    private static final Logger log = Logger.getLogger(ContainerAdapter.class);\n\n    /** The community or collection this adapter represents. */\n    private final DSpaceObject dso;\n\n    /** A space-separated list of descriptive metadata sections */\n    private StringBuffer dmdSecIDS;\n    \n    /** Current DSpace context **/\n    private final Context dspaceContext;\n\n    protected CommunityService communityService = ContentServiceFactory.getInstance().getCommunityService();\n   \tprotected CollectionService collectionService = ContentServiceFactory.getInstance().getCollectionService();\n   \tprotected HandleService handleService = HandleServiceFactory.getInstance().getHandleService();\n    \n    \n    /**\n     * Construct a new CommunityCollectionMETSAdapter.\n     * \n     * @param context session context.\n     * @param dso\n     *            A DSpace Community or Collection to adapt.\n     * @param contextPath\n     *            The contextPath of this webapplication.\n     */\n    public ContainerAdapter(Context context, DSpaceObject dso,String contextPath)\n    {\n        super(contextPath);\n        this.dso = dso;\n        this.dspaceContext = context;\n    }\n\n    /** Return the container, community or collection, object\n     * @return the contained object.\n     */\n    public DSpaceObject getContainer()\n    {\n    \treturn this.dso;\n    }\n    \n    /**\n     * \n     * \n     * \n     * Required abstract methods\n     * \n     * \n     * \n     */\n    \n    /**\n     * @return the URL of this community/collection in the interface.\n     */\n    @Override\n    protected String getMETSOBJID()\n    {\n    \tif (dso.getHandle() != null)\n        {\n            return contextPath + \"/handle/\" + dso.getHandle();\n        }\n    \treturn null;\n    }\n\n    /**\n     * @return Return the URL for editing this item\n     */\n    @Override\n    protected String getMETSOBJEDIT()\n    {\n        return null;\n    }\n    \n    /**\n     * Use the handle as the id for this METS document.\n     * @return the id.\n     */\n    @Override\n    protected String getMETSID()\n    {\n    \tif (dso.getHandle() == null)\n    \t{\n        \tif (dso instanceof Collection)\n            {\n                return \"collection:\" + dso.getID();\n            }\n        \telse\n            {\n                return \"community:\" + dso.getID();\n            }\n    \t}\n        else\n        {\n            return \"hdl:\" + dso.getHandle();\n        }\n    }\n\n    /**\n     * Return the profile to use for communities and collections.\n     * \n     * @return the constant profile name.\n     * @throws org.dspace.app.xmlui.wing.WingException never.\n     */\n    @Override\n    protected String getMETSProfile() throws WingException\n    {\n    \treturn \"DSPACE METS SIP Profile 1.0\";\n    }\n\n    /**\n     * @return a friendly label for the METS document to say we are a community\n     * or collection.\n     */\n    @Override\n    protected String getMETSLabel()\n    {\n        if (dso instanceof Community)\n        {\n            return \"DSpace Community\";\n        }\n        else\n        {\n            return \"DSpace Collection\";\n        }\n    }\n\n    /**\n     * @param bitstream the bitstream to be identified.\n     * @return a unique id for the given bitstream.\n     */\n    protected String getFileID(Bitstream bitstream)\n    {\n        return \"file_\" + bitstream.getID();\n    }\n\n    /**\n     * @param bitstream the bitstream to be queried.\n     * @return a group id for the given bitstream.\n     */\n    protected String getGroupFileID(Bitstream bitstream)\n    {\n        return \"group_file_\" + bitstream.getID();\n    }\n\n\n    \n    \n    /**\n     * \n     * \n     * \n     * METS structural methods\n     * \n     * \n     * \n     */\n\n    \n    \n    /**\n     * Render the METS descriptive section. This will create a new metadata\n     * section for each crosswalk configured.\n     * \n     * <p>Example:\n     *\n     * <pre>{@code\n     * <dmdSec>\n     *  <mdWrap MDTYPE=\"MODS\">\n     *    <xmlData>\n     *      ... content from the crosswalk ...\n     *    </xmlDate>\n     *  </mdWrap>\n     * </dmdSec>\n     * } </pre>\n     * @throws org.dspace.app.xmlui.wing.WingException on XML errors.\n     * @throws org.xml.sax.SAXException passed through.\n     * @throws org.dspace.content.crosswalk.CrosswalkException passed through.\n     * @throws java.io.IOException if items could not be counted.\n     * @throws java.sql.SQLException passed through.\n     */\n    @Override\n    protected void renderDescriptiveSection() throws WingException, SAXException, CrosswalkException, IOException, SQLException \n    {\n        AttributeMap attributes;\n        \n        String groupID = getGenericID(\"group_dmd_\");\n        dmdSecIDS = new StringBuffer();\n\n        // Add DIM descriptive metadata if it was requested or if no metadata types \n        // were specified. Furthermore, since this is the default type we also use a \n        // faster rendering method that the crosswalk API.\n        if(dmdTypes.isEmpty() || dmdTypes.contains(\"DIM\"))\n        {\n            // Metadata element's ID\n            String dmdID = getGenericID(\"dmd_\");\n            \n            // Keep track of all descriptive sections\n            dmdSecIDS.append(dmdID);\n            \n            \n            // ////////////////////////////////\n            // Start a new dmdSec for each crosswalk.\n            attributes = new AttributeMap();\n            attributes.put(\"ID\", dmdID);\n            attributes.put(\"GROUPID\", groupID);\n            startElement(METS,\"dmdSec\",attributes);\n            \n            // ////////////////////////////////\n            // Start metadata wrapper\n            attributes = new AttributeMap();\n            attributes.put(\"MDTYPE\", \"OTHER\");\n            attributes.put(\"OTHERMDTYPE\", \"DIM\");\n            startElement(METS,\"mdWrap\",attributes);\n\n            // ////////////////////////////////\n            // Start the xml data\n            startElement(METS,\"xmlData\");\n            \n            \n            // ///////////////////////////////\n            // Start the DIM element\n            attributes = new AttributeMap();\n            attributes.put(\"dspaceType\", Constants.typeText[dso.getType()]);\n            startElement(DIM,\"dim\",attributes);\n\n            // Add each field for this collection\n            if (dso.getType() == Constants.COLLECTION) \n            {\n                Collection collection = (Collection) dso;\n                \n                String description = collectionService.getMetadata(collection, \"introductory_text\");\n                String description_abstract = collectionService.getMetadata(collection, \"short_description\");\n                String description_table = collectionService.getMetadata(collection, \"side_bar_text\");\n                String identifier_uri = handleService.getCanonicalPrefix() + collection.getHandle();\n                String provenance = collectionService.getMetadata(collection, \"provenance_description\");\n                String rights = collectionService.getMetadata(collection, \"copyright_text\");\n                String rights_license = collectionService.getMetadata(collection, \"license\");\n                String title = collectionService.getMetadata(collection, \"name\");\n                \n                createField(\"dc\",\"description\",null,null,description);\n                createField(\"dc\",\"description\",\"abstract\",null,description_abstract);\n                createField(\"dc\",\"description\",\"tableofcontents\",null,description_table);\n                createField(\"dc\",\"identifier\",\"uri\",null,identifier_uri);\n                createField(\"dc\",\"provenance\",null,null,provenance);\n                createField(\"dc\",\"rights\",null,null,rights);\n                createField(\"dc\",\"rights\",\"license\",null,rights_license);\n                createField(\"dc\",\"title\",null,null,title);\n                \n                boolean showCount = DSpaceServicesFactory.getInstance().getConfigurationService().getBooleanProperty(\"webui.strengths.show\");\n                 \n                if (showCount)\n                {\n                    try\n                    {\t// try to determine Collection size (i.e. # of items)\n                        int size = new ItemCounter(this.dspaceContext).getCount(collection);\n                        createField(\"dc\",\"format\",\"extent\",null, String.valueOf(size)); \n                    }\n                    catch (ItemCountException e)\n                    {\n                        throw new IOException(\"Could not obtain Collection item count\", e);\n                    }\n                }\n            } \n            else if (dso.getType() == Constants.COMMUNITY) \n            {\n                Community community = (Community) dso;\n                \n                String description = communityService.getMetadata(community, \"introductory_text\");\n                String description_abstract = communityService.getMetadata(community, \"short_description\");\n                String description_table = communityService.getMetadata(community, \"side_bar_text\");\n                String identifier_uri = handleService.getCanonicalPrefix() + community.getHandle();\n                String rights = communityService.getMetadata(community, \"copyright_text\");\n                String title = communityService.getMetadata(community, \"name\");\n                \n                createField(\"dc\",\"description\",null,null,description);\n                createField(\"dc\",\"description\",\"abstract\",null,description_abstract);\n                createField(\"dc\",\"description\",\"tableofcontents\",null,description_table);\n                createField(\"dc\",\"identifier\",\"uri\",null,identifier_uri);\n                createField(\"dc\",\"rights\",null,null,rights);\n                createField(\"dc\",\"title\",null,null,title);\n                \n                boolean showCount = DSpaceServicesFactory.getInstance().getConfigurationService().getBooleanProperty(\"webui.strengths.show\");\n        \t\t\n                if (showCount)\n                {\n                    try\n                    {\t// try to determine Community size (i.e. # of items)\n                        int size = new ItemCounter(this.dspaceContext).getCount(community);\n                        createField(\"dc\",\"format\",\"extent\",null, String.valueOf(size)); \n                    }\n                    catch (ItemCountException e)\n                    {\n                        throw new IOException(\"Could not obtain Collection item count\", e);\n                    }\n                }\n            }\n            \n            // ///////////////////////////////\n            // End the DIM element\n            endElement(DIM,\"dim\");\n            \n            // ////////////////////////////////\n            // End elements\n            endElement(METS,\"xmlData\");\n            endElement(METS,\"mdWrap\");\n            endElement(METS, \"dmdSec\");\n          \n        }\n        \n    \tfor (String dmdType : dmdTypes)\n    \t{\n    \t\t// If DIM was requested then it was generated above without using\n    \t\t// the crosswalk API. So we can skip this one.\n    \t\tif (\"DIM\".equals(dmdType))\n            {\n                continue;\n            }\n    \t\t\n    \t\tDisseminationCrosswalk crosswalk = getDisseminationCrosswalk(dmdType);\n    \t\t\n    \t\tif (crosswalk == null)\n            {\n                continue;\n            }\n    \t\t\n        \tString dmdID = getGenericID(\"dmd_\");\n\t   \t\t// Add our id to the list.\n            dmdSecIDS.append(\" \").append(dmdID);\n\n            // ////////////////////////////////\n            // Start a new dmdSec for each crosswalk.\n            attributes = new AttributeMap();\n            attributes.put(\"ID\", dmdID);\n            attributes.put(\"GROUPID\", groupID);\n            startElement(METS,\"dmdSec\",attributes);\n            \n            // ////////////////////////////////\n            // Start metadata wrapper\n            attributes = new AttributeMap();\n            if (isDefinedMETStype(dmdType))\n            {\n            \tattributes.put(\"MDTYPE\", dmdType);\n            }\n            else\n            {\n            \tattributes.put(\"MDTYPE\", \"OTHER\");\n            \tattributes.put(\"OTHERMDTYPE\", dmdType);\n            }\n            startElement(METS,\"mdWrap\",attributes);\n\n            // ////////////////////////////////\n            // Start the xml data\n            startElement(METS,\"xmlData\");\n            \n            // ///////////////////////////////\n            // Send the actual XML content\n            try {\n\t    \t\tElement dissemination = crosswalk.disseminateElement(dspaceContext, dso);\n\t\n\t    \t\tSAXFilter filter = new SAXFilter(contentHandler, lexicalHandler, namespaces);\n\t    \t\t// Allow the basics for XML\n\t    \t\tfilter.allowElements().allowIgnorableWhitespace().allowCharacters().allowCDATA().allowPrefixMappings();\n\t    \t\t\n\t            SAXOutputter outputter = new SAXOutputter();\n\t            outputter.setContentHandler(filter);\n\t            outputter.setLexicalHandler(filter);\n\t\t\t\toutputter.output(dissemination);\n\t\t\t} \n            catch (JDOMException jdome) \n\t\t\t{\n\t\t\t\tthrow new WingException(jdome);\n\t\t\t}\n\t\t\tcatch (AuthorizeException ae)\n\t\t\t{\n\t\t\t\t// just ignore the authorize exception and continue on\n\t\t\t\t// without parsing the xml document.\n\t\t\t}\n    \t\t\n            \n            // ////////////////////////////////\n            // End elements\n            endElement(METS,\"xmlData\");\n            endElement(METS,\"mdWrap\");\n            endElement(METS, \"dmdSec\");\n            \n            \n            // Record keeping\n            if (dmdSecIDS == null)\n            {\n                dmdSecIDS = new StringBuffer(dmdID);\n            }\n            else\n            {\n                dmdSecIDS.append(\" \").append(dmdID);\n\n            }\n        }\n    }\n\n    /**\n     * Render the METS file section. If a logo is present for this\n     * container then that single bitstream is listed in the \n     * file section.\n     *\n     * <p>Example:\n     *\n     * <pre>{@code\n     * <fileSec>\n     *   <fileGrp USE=\"LOGO\">\n     *     <file ... >\n     *       <fLocate ... >\n     *     </file>\n     *   </fileGrp>\n     * </fileSec>\n     * }</pre>\n     * @param context session context.\n     * @throws org.xml.sax.SAXException passed through.\n     * @throws java.sql.SQLException passed through.\n     */\n    @Override\n    protected void renderFileSection(Context context) throws SAXException, SQLException\n    {\n    \tAttributeMap attributes;\n    \t\n        // Get the Community or Collection logo.\n        Bitstream logo = getLogo();\n\n        if (logo != null)\n        {\n            // ////////////////////////////////\n            // Start the file section\n        \tstartElement(METS,\"fileSec\");\n\n            // ////////////////////////////////\n            // Start a new fileGrp for the logo.\n            attributes = new AttributeMap();\n            attributes.put(\"USE\", \"LOGO\");\n            startElement(METS,\"fileGrp\",attributes);\n            \n            // ////////////////////////////////\n            // Add the actual file element\n            String fileID = getFileID(logo);\n            String groupID = getGroupFileID(logo);\n            renderFile(context, null, logo, fileID, groupID);\n            \n            // ////////////////////////////////\n            // End th file group and file section\n            endElement(METS,\"fileGrp\");\n            endElement(METS,\"fileSec\");\n        }\n    }\n\n    /**\n     * Render the container's structural map. This includes a reference\n     * to the container's logo, if available, otherwise it is an empty \n     * division that just states it is a DSpace community or Collection.\n     * \n     * <p>Example:\n     *\n     * <pre>{@code\n     * <structMap TYPE=\"LOGICAL\" LABEL=\"DSpace\">\n     *   <div TYPE=\"DSpace Collection\" DMDID=\"space-separated list of ids\">\n     *     <fptr FILEID=\"logo id\"/>\n     *   </div>\n     * </structMap>\n     * }</pre>\n     * @throws java.sql.SQLException passed through.\n     * @throws org.xml.sax.SAXException passed through.\n     */\n    @Override\n    protected void renderStructureMap() throws SQLException, SAXException\n    {\n    \tAttributeMap attributes;\n    \t\n    \t// ///////////////////////\n    \t// Start a new structure map\n    \tattributes = new AttributeMap();\n    \tattributes.put(\"TYPE\", \"LOGICAL\");\n    \tattributes.put(\"LABEL\", \"DSpace\");\n    \tstartElement(METS,\"structMap\",attributes);\n\n    \t// ////////////////////////////////\n    \t// Start the special first division\n    \tattributes = new AttributeMap();\n    \tattributes.put(\"TYPE\", getMETSLabel());\n    \t// add references to the Descriptive metadata\n    \tif (dmdSecIDS != null)\n        {\n            attributes.put(\"DMDID\", dmdSecIDS.toString());\n        }\n    \tstartElement(METS,\"div\",attributes);\n    \t\n    \t\n    \t// add a fptr pointer to the logo.\n        Bitstream logo = getLogo();\n        if (logo != null)\n        {\n            // ////////////////////////////////\n            // Add a reference to the logo as the primary bitstream.\n            attributes = new AttributeMap();\n            attributes.put(\"FILEID\",getFileID(logo));\n            startElement(METS,\"fptr\",attributes);\n            endElement(METS,\"fptr\");\n        \n            \n            // ///////////////////////////////////////////////\n            // Add a div for the publicly viewable bitstreams (i.e. the logo)\n            attributes = new AttributeMap();\n            attributes.put(\"ID\", getGenericID(\"div_\"));\n            attributes.put(\"TYPE\", \"DSpace Content Bitstream\");\n            startElement(METS,\"div\",attributes);\n        \t\n            // ////////////////////////////////\n            // Add a reference to the logo as the primary bitstream.\n            attributes = new AttributeMap();\n            attributes.put(\"FILEID\",getFileID(logo));\n            startElement(METS,\"fptr\",attributes);\n            endElement(METS,\"fptr\");\n        \t\n            // //////////////////////////\n            // End the logo division\n            endElement(METS,\"div\");\n        }\n\n    \t// ////////////////////////////////\n    \t// End the special first division\n    \tendElement(METS,\"div\");\n    \t\n    \t// ///////////////////////\n    \t// End the structure map\n    \tendElement(METS,\"structMap\");\n    }\n    \n\n    /**\n     * \n     * \n     * \n     * Private helpful methods\n     * \n     * \n     * \n     */\n\n    /**\n     * Return the logo bitstream associated with this community or collection.\n     * If there is no logo then null is returned.\n     */\n    private Bitstream getLogo()\n    {\n        if (dso instanceof Community)\n        {\n            Community community = (Community) dso;\n            return community.getLogo();\n        }\n        else if (dso instanceof Collection)\n        {\n\n            Collection collection = (Collection) dso;\n            return collection.getLogo();\n        }\n        return null;\n    }\n    \n    /**\n     * Count how many occurrence there is of the given\n     * character in the given string.\n     * \n     * @param string The string value to be counted.\n     * @param character the character to count in the string.\n     */\n    private int countOccurences(String string, char character)\n    {\n    \tif (string == null || string.length() == 0)\n        {\n            return 0;\n        }\n    \t\n    \tint fromIndex = -1;\n        int count = 0;\n        \n        while (true)\n        {\n        \tfromIndex = string.indexOf('>', fromIndex+1);\n        \t\n        \tif (fromIndex == -1)\n            {\n                break;\n            }\n        \t\n        \tcount++;\n        }\n        \n        return count;\n    }\n    \n    /**\n     * Check if the given character sequence is located in the given\n     * string at the specified index. If it is then return true, otherwise false.\n     * \n     * @param string The string to test against\n     * @param index The location within the string\n     * @param characters The character sequence to look for.\n     * @return true if the character sequence was found, otherwise false.\n     */\n    private boolean substringCompare(String string, int index, char ... characters)\n    {\n    \t// Is the string long enough?\n    \tif (string.length() <= index + characters.length)\n        {\n            return false;\n        }\n    \t\n    \t// Do all the characters match?\n    \tfor (char character : characters)\n    \t{\n    \t\tif (string.charAt(index) != character)\n            {\n                return false;\n            }\n    \t\tindex++;\n    \t}\n    \t\n    \treturn false;\n    }\n    \n    /**\n     * Create a new DIM field element with the given attributes.\n     * \n     * @param schema The schema the DIM field belongs too.\n     * @param element The element the DIM field belongs too.\n     * @param qualifier The qualifier the DIM field belongs too.\n     * @param language The language the DIM field belongs too.\n     * @param value The value of the DIM field.\n     * @return A new DIM field element\n     * @throws SAXException \n     */\n    private void createField(String schema, String element, String qualifier, String language, String value) throws SAXException\n    {\n    \t// ///////////////////////////////\n    \t// Field element for each metadata field.\n    \tAttributeMap attributes = new AttributeMap();\n\t\tattributes.put(\"mdschema\",schema);\n\t\tattributes.put(\"element\", element);\n\t\tif (qualifier != null)\n        {\n            attributes.put(\"qualifier\", qualifier);\n        }\n\t\tif (language != null)\n        {\n            attributes.put(\"language\", language);\n        }\n\t\tstartElement(DIM,\"field\",attributes);\n\t\t\n\t\t// Only try and add the metadata value, but only if it is non-null.\n    \tif (value != null)\n    \t{\n    \t\t// First, perform a quick check to see if the value may be XML.\n\t        int countOpen = countOccurences(value,'<');\n\t        int countClose = countOccurences(value, '>');\n\t        \n\t        // If it passed the quick test, then try and parse the value.\n\t        Element xmlDocument = null;\n\t        if (countOpen > 0 && countOpen == countClose)\n\t        {\n\t        \t// This may be XML, First try and remove any bad entity references.\n\t        \tint amp = -1;\n\t        \twhile ((amp = value.indexOf('&', amp+1)) > -1)\n\t        \t{\n\t        \t\t// Is it an xml entity named by number?\n\t        \t\tif (substringCompare(value,amp+1,'#'))\n                    {\n                        continue;\n                    }\n\t        \t\t\n\t        \t\t// &amp;\n\t        \t\tif (substringCompare(value,amp+1,'a','m','p',';'))\n                    {\n                        continue;\n                    }\n\t        \t\t\n\t        \t\t// &apos;\n\t        \t\tif (substringCompare(value,amp+1,'a','p','o','s',';'))\n                    {\n                        continue;\n                    }\n\t        \t\t\n\t        \t\t// &quot;\n\t        \t\tif (substringCompare(value,amp+1,'q','u','o','t',';'))\n                    {\n                        continue;\n                    }\n\t        \t\t\t\n\t        \t\t// &lt;\n\t        \t\tif (substringCompare(value,amp+1,'l','t',';'))\n                    {\n                        continue;\n                    }\n\t        \t\t\n\t        \t\t// &gt;\n\t        \t\tif (substringCompare(value,amp+1,'g','t',';'))\n                    {\n                        continue;\n                    }\n\t        \t\t\n\t        \t\t// Replace the ampersand with an XML entity.\n\t        \t\tvalue = value.substring(0,amp) + \"&amp;\" + value.substring(amp+1);\n\t        \t}\n\t        \t\n\t        \t\n\t        \t// Second try and parse the XML into a mini-dom\n\t        \ttry {\n\t        \t\t// Wrap the value inside a root element (which will be trimed out \n\t        \t\t// by the SAX filter and set the default namespace to XHTML. \n\t\t        \tString xml = \"<?xml version='1.0' encoding='UTF-8'?><fragment xmlns=\\\"http://www.w3.org/1999/xhtml\\\">\"+value+\"</fragment>\";\n\n\t\t            ByteArrayInputStream inputStream = new ByteArrayInputStream(xml.getBytes(\"UTF-8\"));\n\t\t     \t   \n\t\t\t \t    SAXBuilder builder = new SAXBuilder();\n\t\t\t\t\tDocument document = builder.build(inputStream);\n\t\t\t\t\t\n\t\t\t\t\txmlDocument = document.getRootElement();\n\t        \t} \n\t        \tcatch (JDOMException | IOException e)\n\t\t\t\t{\n                    log.trace(\"Caught exception\", e);\n\t\t\t\t}\n\t        }\t\t\n\t\t\t\t\t\n\t        // Third, If we have xml, attempt to serialize the dom.\n\t        if (xmlDocument != null)\n\t        {\t\n\t        \tSAXFilter filter = new SAXFilter(contentHandler, lexicalHandler, namespaces);\n\t    \t\t// Allow the basics for XML\n\t    \t\tfilter.allowElements().allowIgnorableWhitespace().allowCharacters().allowCDATA().allowPrefixMappings();\n\t    \t\t// Special option, only allow elements below the second level to pass through. This\n\t    \t\t// will trim out the METS declaration and only leave the actual METS parts to be\n\t    \t\t// included.\n\t    \t\tfilter.allowElements(1);\n\t    \t\t\n\t            SAXOutputter outputter = new SAXOutputter();\n\t            outputter.setContentHandler(filter);\n\t            outputter.setLexicalHandler(filter);\n\t            try {\n\t            \toutputter.output(xmlDocument);\n\t            } \n\t            catch (JDOMException jdome)\n\t            {\n\t            \t// serialization failed so let's just fallback sending the plain characters.\n\t            \tsendCharacters(value);\n\t            }\n\t        }\n\t        else\n\t        {\n\t        \t// We don't have XML, so just send the plain old characters.\n\t        \tsendCharacters(value);\n\t        }\n    \t}\n        \n        // //////////////////////////////\n        // Close out field\n        endElement(DIM,\"field\");\n    }  \n}\n", "/**\n * The contents of this file are subject to the license and copyright\n * detailed in the LICENSE and NOTICE files at the root of the source\n * tree and available online at\n *\n * http://www.dspace.org/license/\n */\npackage org.dspace.app.xmlui.objectmanager;\n\nimport org.dspace.app.util.Util;\nimport org.dspace.app.util.factory.UtilServiceFactory;\nimport org.dspace.app.util.service.MetadataExposureService;\nimport org.dspace.app.xmlui.wing.AttributeMap;\nimport org.dspace.app.xmlui.wing.WingException;\nimport org.dspace.authorize.AuthorizeException;\nimport org.dspace.authorize.factory.AuthorizeServiceFactory;\nimport org.dspace.authorize.service.AuthorizeService;\nimport org.dspace.content.*;\nimport org.dspace.content.authority.Choices;\nimport org.dspace.content.crosswalk.CrosswalkException;\nimport org.dspace.content.crosswalk.DisseminationCrosswalk;\nimport org.dspace.content.factory.ContentServiceFactory;\nimport org.dspace.content.service.BitstreamService;\nimport org.dspace.content.service.BundleService;\nimport org.dspace.content.service.ItemService;\nimport org.dspace.services.factory.DSpaceServicesFactory;\nimport org.dspace.core.Constants;\nimport org.dspace.core.Context;\nimport org.jdom.Element;\nimport org.jdom.JDOMException;\nimport org.jdom.output.SAXOutputter;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.XMLReader;\nimport org.xml.sax.helpers.XMLReaderFactory;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.sql.SQLException;\nimport java.util.*;\n\n/**\n * This is an adapter which translates a DSpace item into a METS document\n * following the DSpace METS profile, err well mostly. At least if you use\n * the proper configuration it will be fully compliant with the profile,\n * however this adapter will allow you to configure it to be incorrect.\n *\n * <p>When we are configured to be non-compliant with the profile, the MET's\n * profile is changed to reflect the deviation. The DSpace profile states\n * that metadata should be given in MODS format. However, you can configure\n * this adapter to use any metadata crosswalk. When that case is detected we\n * change the profile to say that we are deviating from the standard profile\n * and it lists what metadata has been added.\n *\n * <p>There are four parts to an item's METS document: descriptive metadata,\n * file section, structural map, and extra sections.\n *\n * <p>Request item-support\n * <p>Original Concept, JSPUI version:    Universidade do Minho   at www.uminho.pt\n * <p>Sponsorship of XMLUI version:    Instituto Oceanogr\u00e1fico de Espa\u00f1a at www.ieo.es\n *\n * @author Scott Phillips\n * @author Ad\u00e1n Rom\u00e1n Ruiz at arvo.es (for request item support)\n */\n\npublic class ItemAdapter extends AbstractAdapter\n{\n    /** The item this METS adapter represents */\n    private final Item item;\n\n    /** List of bitstreams which should be publicly viewable */\n    private final List<Bitstream> contentBitstreams = new ArrayList<>();\n\n    /** The primary bitstream, or null if none specified */\n    private Bitstream primaryBitstream;\n\n    /** A space-separated list of descriptive metadata sections */\n    private StringBuffer dmdSecIDS;\n\n    /** A space-separated list of administrative metadata sections (for item)*/\n    private StringBuffer amdSecIDS;\n\n    /** A hashmap of all Files and their corresponding space separated list of\n        administrative metadata sections */\n    private final Map<String,StringBuffer> fileAmdSecIDs = new HashMap<>();\n\n    // DSpace DB context\n    private final Context context;\n\n    protected AuthorizeService authorizeService = AuthorizeServiceFactory.getInstance().getAuthorizeService();\n    protected ItemService itemService = ContentServiceFactory.getInstance().getItemService();\n    protected BundleService bundleService = ContentServiceFactory.getInstance().getBundleService();\n    protected BitstreamService bitstreamService = ContentServiceFactory.getInstance().getBitstreamService();\n    protected MetadataExposureService metadataExposureService = UtilServiceFactory.getInstance().getMetadataExposureService();\n\n\n    /**\n     * Construct a new ItemAdapter\n     *\n     * @param context\n     *            Session context.\n     * @param item\n     *            The DSpace item to adapt.\n     * @param contextPath\n     *            The context path for this web application.\n     */\n    public ItemAdapter(Context context, Item item,String contextPath)\n    {\n        super(contextPath);\n        this.item = item;\n        this.context = context;\n    }\n\n    /** @return the item. */\n    public Item getItem()\n    {\n        return this.item;\n    }\n\n\n\n    /**\n     *\n     *\n     *\n     * Required abstract methods\n     *\n     *\n     *\n     */\n\n    /**\n     * @return the URL of this item in the interface.\n     */\n    @Override\n    protected String getMETSOBJID()\n    {\n        if (item.getHandle() != null)\n        {\n            return contextPath + \"/handle/\" + item.getHandle();\n        }\n        return null;\n    }\n\n    /**\n     * @return the URL for editing this item\n     */\n    @Override\n    protected String getMETSOBJEDIT()\n    {\n        return contextPath+\"/admin/item?itemID=\" + item.getID();\n    }\n\n    /**\n     * @return the item's handle as the METS ID\n     */\n    @Override\n    protected String getMETSID()\n    {\n        if (item.getHandle() == null)\n        {\n            return \"item:\" + item.getID();\n        }\n        else\n        {\n            return \"hdl:\" + item.getHandle();\n        }\n    }\n\n    /**\n     * @return the official METS SIP Profile.\n     * @throws org.dspace.app.xmlui.wing.WingException never.\n     */\n    @Override\n    protected String getMETSProfile() throws WingException\n    {\n        return \"DSPACE METS SIP Profile 1.0\";\n    }\n\n    /**\n     * @return a helpful label that this is a DSpace Item.\n     */\n    @Override\n    protected String getMETSLabel()\n    {\n        return \"DSpace Item\";\n    }\n\n    /**\n     * @param bitstream a Bitstream.\n     * @return a unique id for a bitstream.\n     */\n    protected String getFileID(Bitstream bitstream)\n    {\n        return \"file_\" + bitstream.getID();\n    }\n\n    /**\n     * @param bitstream a Bitstream.\n     * @return a group id for a bitstream.\n     */\n    protected String getGroupFileID(Bitstream bitstream)\n    {\n        return \"group_file_\" + bitstream.getID();\n    }\n\n    /**\n     * @param admSecName section.\n     * @param mdType type.\n     * @param dso object.\n     * @return a techMD id for a bitstream.\n     */\n    protected String getAmdSecID(String admSecName, String mdType, DSpaceObject dso)\n    {\n        if (dso.getType() == Constants.BITSTREAM)\n        {\n            return admSecName + \"_\" + getFileID((Bitstream) dso) + \"_\" + mdType;\n        }\n        else\n        {\n            return admSecName + \"_\" + dso.getID() + \"_\" + mdType;\n        }\n    }\n\n    /**\n     * Render the METS descriptive section. This will create a new metadata\n     * section for each crosswalk configured. Furthermore, a special check\n     * has been added that will add MODS descriptive metadata if it is\n     * available in DSpace.\n     *\n     * <p>Example:\n     *\n     * <pre>{@code\n     * <dmdSec>\n     *  <mdWrap MDTYPE=\"MODS\">\n     *    <xmlData>\n     *      ... content from the crosswalk ...\n     *    </xmlDate>\n     *  </mdWrap>\n     * </dmdSec\n     * }</pre>\n     * @throws org.dspace.app.xmlui.wing.WingException on XML errors.\n     * @throws org.xml.sax.SAXException passed through.\n     * @throws org.dspace.content.crosswalk.CrosswalkException passed through.\n     * @throws java.io.IOException passed through.\n     * @throws java.sql.SQLException passed through.\n     */\n    @Override\n    protected void renderDescriptiveSection() throws WingException, SAXException, CrosswalkException, IOException, SQLException\n    {\n        AttributeMap attributes;\n        String groupID = getGenericID(\"group_dmd_\");\n        dmdSecIDS = new StringBuffer();\n\n        // Add DIM descriptive metadata if it was requested or if no metadata types\n        // were specified. Furthermore, since this is the default type we also use a\n        // faster rendering method that the crosswalk API.\n        if(dmdTypes.isEmpty() || dmdTypes.contains(\"DIM\"))\n        {\n                // Metadata element's ID\n                String dmdID = getGenericID(\"dmd_\");\n                // Keep track of all descriptive sections\n                dmdSecIDS.append(dmdID);\n\n                        ////////////////////////////////\n                        // Start a metadata wrapper\n                        attributes = new AttributeMap();\n                        attributes.put(\"ID\", dmdID);\n                        attributes.put(\"GROUPID\", groupID);\n                        startElement(METS, \"dmdSec\", attributes);\n\n                         ////////////////////////////////\n                        // Start a metadata wrapper\n                        attributes = new AttributeMap();\n                        attributes.put(\"MDTYPE\",\"OTHER\");\n                        attributes.put(\"OTHERMDTYPE\", \"DIM\");\n                        startElement(METS,\"mdWrap\",attributes);\n\n                        // ////////////////////////////////\n                        // Start the xml data\n                        startElement(METS,\"xmlData\");\n\n\n                        // ///////////////////////////////\n                        // Start the DIM element\n                        attributes = new AttributeMap();\n                        attributes.put(\"dspaceType\", Constants.typeText[item.getType()]);\n            if (item.isWithdrawn())\n            {\n                attributes.put(\"withdrawn\", \"y\");\n            }\n            startElement(DIM,\"dim\",attributes);\n\n                List<MetadataValue> dcvs = itemService.getMetadata(item, Item.ANY, Item.ANY, Item.ANY, Item.ANY);\n                for (MetadataValue dcv : dcvs)\n                {\n                    MetadataField metadataField = dcv.getMetadataField();\n                    if (!metadataExposureService.isHidden(context, dcv.getMetadataField().getMetadataSchema().getName(), metadataField.getElement(), metadataField.getQualifier())) {\n                        // ///////////////////////////////\n                        // Field element for each metadata field.\n                        attributes = new AttributeMap();\n                        attributes.put(\"mdschema\", metadataField.getMetadataSchema().getName());\n                        attributes.put(\"element\", metadataField.getElement());\n                        if (metadataField.getQualifier() != null) {\n                            attributes.put(\"qualifier\", metadataField.getQualifier());\n                        }\n                        if (dcv.getLanguage() != null) {\n                            attributes.put(\"language\", dcv.getLanguage());\n                        }\n                        if (dcv.getAuthority() != null || dcv.getConfidence() != Choices.CF_UNSET) {\n                            attributes.put(\"authority\", dcv.getAuthority());\n                            attributes.put(\"confidence\", Choices.getConfidenceText(dcv.getConfidence()));\n                        }\n                        startElement(DIM, \"field\", attributes);\n                        sendCharacters(dcv.getValue());\n                        endElement(DIM,\"field\");\n                }\n                }\n\n                // ///////////////////////////////\n                        // End the DIM element\n                        endElement(DIM,\"dim\");\n\n                // ////////////////////////////////\n                // End elements\n                endElement(METS,\"xmlData\");\n                endElement(METS,\"mdWrap\");\n                endElement(METS,\"dmdSec\");\n\n        }\n\n\n        // Add any extra crosswalks that may configured.\n        for (String dmdType : dmdTypes)\n        {\n                // If DIM was requested then it was generated above without using\n                // the crosswalk API. So we can skip this one.\n                if (\"DIM\".equals(dmdType))\n                {\n                    continue;\n                }\n\n                DisseminationCrosswalk crosswalk = getDisseminationCrosswalk(dmdType);\n\n                if (crosswalk == null)\n                {\n                    continue;\n                }\n\n                String dmdID = getGenericID(\"dmd_\");\n                // Add our id to the list.\n                dmdSecIDS.append(\" \").append(dmdID);\n\n                ////////////////////////////////\n                // Start a metadata wrapper\n                attributes = new AttributeMap();\n                attributes.put(\"ID\", dmdID);\n                attributes.put(\"GROUPID\", groupID);\n                startElement(METS, \"dmdSec\", attributes);\n\n                ////////////////////////////////\n                // Start a metadata wrapper\n                attributes = new AttributeMap();\n                if (isDefinedMETStype(dmdType))\n                {\n                        attributes.put(\"MDTYPE\", dmdType);\n                }\n                else\n                {\n                        attributes.put(\"MDTYPE\",\"OTHER\");\n                        attributes.put(\"OTHERMDTYPE\", dmdType);\n                }\n                startElement(METS,\"mdWrap\",attributes);\n\n                // ////////////////////////////////\n                // Start the xml data\n                startElement(METS,\"xmlData\");\n\n\n                // ///////////////////////////////\n                // Send the actual XML content\n                try {\n                        Element dissemination = crosswalk.disseminateElement(context, item);\n\n                        SAXFilter filter = new SAXFilter(contentHandler, lexicalHandler, namespaces);\n                        // Allow the basics for XML\n                        filter.allowElements().allowIgnorableWhitespace().allowCharacters().allowCDATA().allowPrefixMappings();\n\n                    SAXOutputter outputter = new SAXOutputter();\n                    outputter.setContentHandler(filter);\n                    outputter.setLexicalHandler(filter);\n                                outputter.output(dissemination);\n                        }\n            catch (JDOMException jdome)\n                        {\n                                throw new WingException(jdome);\n                        }\n                        catch (AuthorizeException ae)\n                        {\n                                // just ignore the authorize exception and continue on\n                                // without parsing the xml document.\n                        }\n\n\n            // ////////////////////////////////\n            // End elements\n            endElement(METS,\"xmlData\");\n            endElement(METS,\"mdWrap\");\n            endElement(METS,\"dmdSec\");\n        }\n\n\n        // Check to see if there is an in-line MODS document\n        // stored as a bitstream. If there is then we should also\n        // include these metadata in our METS document. However,\n        // we don't really know what the document describes, so we\n        // but it in its own dmd group.\n\n        Boolean include = DSpaceServicesFactory.getInstance().getConfigurationService().getBooleanProperty(\"xmlui.bitstream.mods\");\n        if (include && dmdTypes.contains(\"MODS\"))\n        {\n                // Generate a second group id for any extra metadata added.\n                String groupID2 = getGenericID(\"group_dmd_\");\n\n                List<Bundle> bundles = itemService.getBundles(item, \"METADATA\");\n                for (Bundle bundle : bundles)\n                {\n                        Bitstream bitstream = bundleService.getBitstreamByName(bundle, \"MODS.xml\");\n\n                        if (bitstream == null)\n                        {\n                            continue;\n                        }\n\n\n                        String dmdID = getGenericID(\"dmd_\");\n\n\n                        ////////////////////////////////\n                        // Start a metadata wrapper\n                        attributes = new AttributeMap();\n                        attributes.put(\"ID\", dmdID);\n                        attributes.put(\"GROUPID\", groupID2);\n                        startElement(METS, \"dmdSec\", attributes);\n\n                         ////////////////////////////////\n                        // Start a metadata wrapper\n                        attributes = new AttributeMap();\n                        attributes.put(\"MDTYPE\", \"MODS\");\n                        startElement(METS,\"mdWrap\",attributes);\n\n                        // ////////////////////////////////\n                        // Start the xml data\n                        startElement(METS,\"xmlData\");\n\n\n                        // ///////////////////////////////\n                        // Send the actual XML content\n\n                        SAXFilter filter = new SAXFilter(contentHandler, lexicalHandler, namespaces);\n                        // Allow the basics for XML\n                        filter.allowElements().allowIgnorableWhitespace().allowCharacters().allowCDATA().allowPrefixMappings();\n\n                        XMLReader reader = XMLReaderFactory.createXMLReader();\n                        reader.setContentHandler(filter);\n                        reader.setProperty(\"http://xml.org/sax/properties/lexical-handler\", filter);\n                        try {\n                                InputStream is = bitstreamService.retrieve(context, bitstream);\n                                reader.parse(new InputSource(is));\n                        }\n                        catch (AuthorizeException ae)\n                        {\n                                // just ignore the authorize exception and continue on\n                                // without parsing the xml document.\n                        }\n\n                        // ////////////////////////////////\n                    // End elements\n                    endElement(METS,\"xmlData\");\n                    endElement(METS,\"mdWrap\");\n                    endElement(METS, \"dmdSec\");\n                }\n        }\n\n    }\n\n    /**\n     * Render the METS administrative section.\n     *\n     * <p>Example:\n     *\n     * <pre>{@code\n     * <amdSec>\n     *  <mdWrap MDTYPE=\"OTHER\" OTHERMDTYPE=\"METSRights\">\n     *    <xmlData>\n     *      ... content from the crosswalk ...\n     *    </xmlDate>\n     *  </mdWrap>\n     * </amdSec>\n     * }</pre>\n     *\n     * @throws org.dspace.app.xmlui.wing.WingException passed through.\n     * @throws org.xml.sax.SAXException passed through.\n     * @throws org.dspace.content.crosswalk.CrosswalkException passed through.\n     * @throws java.io.IOException passed through.\n     * @throws java.sql.SQLException passed through.\n     */\n    @Override\n    protected void renderAdministrativeSection() throws WingException, SAXException, CrosswalkException, IOException, SQLException\n    {\n        AttributeMap attributes;\n        String groupID;\n\n        // Only create an <amdSec>, if we have amdTypes (or sub-sections) specified...\n        // (this keeps our METS file small, by default, and hides all our admin metadata)\n        if(amdTypes.size() > 0)\n        {\n          ////////////////////////////////\n          // Start an administrative wrapper\n\n          // Administrative element's ID\n          String amdID = getGenericID(\"amd_\");\n          attributes = new AttributeMap();\n          attributes.put(\"ID\", amdID);\n          startElement(METS, \"amdSec\", attributes);\n\n          groupID = getGenericID(\"group_amd_\");\n          attributes.put(\"GROUPID\", groupID);\n        }\n\n        // For each administrative metadata section specified\n        for (String amdSecName : amdTypes.keySet())\n        {\n          // get a list of metadata crosswalks which will be used to build\n          // this administrative metadata section\n          List<String> mdTypes = amdTypes.get(amdSecName);\n\n          // For each crosswalk\n          for (String mdType : mdTypes)\n          {\n            // get our dissemination crosswalk\n            DisseminationCrosswalk crosswalk = getDisseminationCrosswalk(mdType);\n\n            // skip, if we cannot find this crosswalk in config file\n            if (crosswalk == null)\n            {\n                continue;\n            }\n\n            // First, check if this crosswalk can handle disseminating Item-level Administrative metadata\n            if(crosswalk.canDisseminate(item))\n            {\n              // Since this crosswalk works with items, first render a section for entire item\n              renderAmdSubSection(amdSecName, mdType, crosswalk, item);\n            }\n\n            // Next, we'll try and render Bitstream-level administrative metadata\n            // (Although, we're only rendering this metadata for the bundles specified)\n            List<Bundle> bundles = findEnabledBundles();\n            for (Bundle bundle : bundles)\n            {\n              List<Bitstream> bitstreams = bundle.getBitstreams();\n\n              // Create a sub-section of <amdSec> for each bitstream in bundle\n              for(Bitstream bitstream : bitstreams)\n              {\n                 // Only render the section if crosswalk works with bitstreams\n                 if(crosswalk.canDisseminate(bitstream))\n                 {\n                    renderAmdSubSection(amdSecName, mdType, crosswalk, bitstream);\n                 }\n              } // end for each bitstream\n            } // end for each bundle\n          } // end for each crosswalk\n        } // end for each amdSec\n\n        if(amdTypes.size() > 0)\n        {\n          //////////////////////////////////\n          // End administrative section\n          endElement(METS,\"amdSec\");\n        }\n    }\n\n    /**\n     * Render a sub-section of the administrative metadata section.\n     * Valid sub-sections include: techMD, rightsMD, sourceMD, digiprovMD\n     *\n     * <p>Example:\n     *\n     * <pre>{@code\n     * <techMD>\n     *   <mdWrap MDTYPE=\"PREMIS\">\n     *     <xmlData>\n     *       [PREMIS content ... ]\n     *     </xmlData>\n     *   </mdWrap>\n     * </techMD>\n     * }</pre>\n     *\n     * @param amdSecName Name of administrative metadata section\n     * @param mdType Type of metadata section (e.g. PREMIS)\n     * @param crosswalk The DisseminationCrosswalk to use to generate this section\n     * @param dso The current DSpace object to use the crosswalk on\n     * @throws org.dspace.app.xmlui.wing.WingException on XML errors.\n     * @throws org.xml.sax.SAXException passed through.\n     * @throws org.dspace.content.crosswalk.CrosswalkException passed through.\n     * @throws java.io.IOException passed through.\n     * @throws java.sql.SQLException passed through.\n     */\n    protected void renderAmdSubSection(String amdSecName, String mdType, DisseminationCrosswalk crosswalk, DSpaceObject dso)\n            throws WingException, SAXException, CrosswalkException, IOException, SQLException\n    {\n        /////////////////////////////////\n        // Start administrative metadata section wrapper\n        String amdSecID = getAmdSecID(amdSecName, mdType, dso);\n        AttributeMap attributes = new AttributeMap();\n        attributes.put(\"ID\", amdSecID);\n        startElement(METS, amdSecName, attributes);\n\n        // If this is a bitstream\n        if (dso.getType() == Constants.BITSTREAM)\n        {\n          // Add this to our list of each file's administrative section IDs\n          String fileID = getFileID((Bitstream) dso);\n          if(fileAmdSecIDs.containsKey(fileID))\n          {\n              fileAmdSecIDs.get(fileID).append(\" \").append(amdSecID);\n          }\n          else\n          {\n              fileAmdSecIDs.put(fileID, new StringBuffer(amdSecID));\n          }\n        } // else if an Item\n        else if (dso.getType() == Constants.ITEM)\n        {\n           // Add this to our list of item's administrative section IDs\n           if(amdSecIDS==null)\n           {\n               amdSecIDS = new StringBuffer(amdSecID);\n           }\n           else\n           {\n               amdSecIDS.append(\" \").append(amdSecID);\n           }\n        }\n\n        ////////////////////////////////\n        // Start a metadata wrapper\n        attributes = new AttributeMap();\n        if (isDefinedMETStype(mdType))\n        {\n            attributes.put(\"MDTYPE\", mdType);\n        }\n        else\n        {\n            attributes.put(\"MDTYPE\",\"OTHER\");\n            attributes.put(\"OTHERMDTYPE\", mdType);\n        }\n        startElement(METS,\"mdWrap\",attributes);\n\n        //////////////////////////////////\n        // Start the xml data\n        startElement(METS,\"xmlData\");\n\n        /////////////////////////////////\n        // Send the actual XML content,\n        // using the PREMIS crosswalk for each bitstream\n        try {\n            Element dissemination = crosswalk.disseminateElement(context, dso);\n\n            SAXFilter filter = new SAXFilter(contentHandler, lexicalHandler, namespaces);\n            // Allow the basics for XML\n            filter.allowElements().allowIgnorableWhitespace().allowCharacters().allowCDATA().allowPrefixMappings();\n\n            SAXOutputter outputter = new SAXOutputter();\n            outputter.setContentHandler(filter);\n            outputter.setLexicalHandler(filter);\n            outputter.output(dissemination);\n        }\n        catch (JDOMException jdome)\n        {\n            throw new WingException(jdome);\n        }\n        catch (AuthorizeException ae)\n        {\n            // just ignore the authorize exception and continue on\n            // without parsing the xml document.\n        }\n\n        // ////////////////////////////////\n        // End elements\n        endElement(METS,\"xmlData\");\n        endElement(METS,\"mdWrap\");\n        endElement(METS,amdSecName);\n    }\n\n    /**\n     * Render the METS file section. This will contain a list of all bitstreams in the\n     * item. Each bundle, even those that are not typically displayed will be listed.\n     *\n     * <p>Example:\n     *\n     * <pre>{@code\n     * <fileSec>\n     *   <fileGrp USE=\"CONTENT\">\n     *     <file ... >\n     *       <fLocate ... >\n     *     </file>\n     *   </fileGrp>\n     *   <fileGrp USE=\"TEXT\">\n     *     <file ... >\n     *       <fLocate ... >\n     *     </file>\n     *   </fileGrp>\n     * </fileSec>\n     * }</pre>\n     *\n     * @param context session context.\n     * @throws java.sql.SQLException passed through.\n     * @throws org.xml.sax.SAXException passed through.\n     */\n    @Override\n    protected void renderFileSection(Context context) throws SQLException, SAXException\n    {\n        AttributeMap attributes;\n\n        // //////////////////////\n        // Start a new file section\n        startElement(METS,\"fileSec\");\n\n        // Check if the user is requested a specific bundle or\n        // the all bundles.\n        List<Bundle> bundles = findEnabledBundles();\n\n        // Suppress license?\n        Boolean showLicense = DSpaceServicesFactory.getInstance().getConfigurationService().getBooleanProperty(\"webui.licence_bundle.show\");\n\n        // Check if ORIGINAL bundle included (either explicitly or via include all fileGrp types)\n        boolean includeContentBundle = this.fileGrpTypes.isEmpty() ? true : this.fileGrpTypes.contains(\"ORIGINAL\");\n\n        // Loop over all requested bundles\n        for (Bundle bundle : bundles)\n        {\n\n            // Use the bitstream's name as the use parameter unless we\n            // are the original bundle. In this case rename it to\n            // content.\n            String use = bundle.getName();\n            boolean isContentBundle = false; // remember the content bundle.\n            boolean isDerivedBundle = false;\n            if (\"ORIGINAL\".equals(use))\n            {\n                use = \"CONTENT\";\n                isContentBundle = true;\n            }\n            if (\"TEXT\".equals(bundle.getName()) || \"THUMBNAIL\".equals(bundle.getName()))\n            {\n                isDerivedBundle = true;\n            }\n            if (\"LICENSE\".equals(bundle.getName()) && ! showLicense)\n            {\n                continue;\n            }\n\n            // /////////////////////////////////////\n            // Determine which bitstreams to include in bundle\n            List<Bitstream> bitstreams = new ArrayList<Bitstream>();\n\n            // If this is the THUMBNAIL bundle, and we are NOT including content bundle,\n            // Then assume this is an item summary page, and we can just include the main thumbnail.\n            if (\"THUMBNAIL\".equals(bundle.getName()) && !includeContentBundle)\n            {\n                Thumbnail thumbnail = itemService.getThumbnail(context, item, false);\n                if(thumbnail != null) {\n                    bitstreams.add(thumbnail.getThumb());\n                }\n            }\n            else\n            {   // Default to including all bitstreams\n                bitstreams = bundle.getBitstreams();\n            }\n\n\n            // ///////////////////\n            // Start bundle's file group\n            attributes = new AttributeMap();\n            attributes.put(\"USE\", use);\n            startElement(METS,\"fileGrp\",attributes);\n\n            for (Bitstream bitstream : bitstreams)\n            {\n                // //////////////////////////////\n                // Determine the file's IDs\n                String fileID = getFileID(bitstream);\n\n                Bitstream originalBitstream = null;\n                // If we are looping through a derived bundle and content bundle is included,\n                // ensure each derived bitstream and original bitstream share the same groupID\n                if (isDerivedBundle && includeContentBundle)\n                {\n                    originalBitstream = findOriginalBitstream(item, bitstream);\n                }\n                String groupID = getGroupFileID((originalBitstream == null) ? bitstream : originalBitstream );\n\n                // Check if there were administrative metadata sections corresponding to this file\n                String admIDs = null;\n                if(fileAmdSecIDs.containsKey(fileID))\n                {\n                    admIDs = fileAmdSecIDs.get(fileID).toString();\n                }\n\n                // Render the actual file & flocate elements.\n                renderFileWithAllowed(item, bitstream, fileID, groupID, admIDs);\n\n                // Remember all the viewable content bitstreams for later in the\n                // structMap.\n                if (isContentBundle)\n                {\n                    contentBitstreams.add(bitstream);\n                    if (bundle.getPrimaryBitstream() != null && bundle.getPrimaryBitstream().equals(bitstream))\n                    {\n                        primaryBitstream = bitstream;\n                    }\n                }\n            }\n\n            // ///////////////////\n            // End the bundle's file group\n            endElement(METS,\"fileGrp\");\n        }\n\n        // //////////////////////\n        // End the file section\n        endElement(METS,\"fileSec\");\n    }\n\n\n    /**\n     * Render the item's structural map. This includes a list of\n     * content bitstreams, those are bitstreams that are typically\n     * viewable by the end user.\n     *\n     * <p>Example:\n     *\n     * <pre>{@code\n     * <structMap TYPE=\"LOGICAL\" LABEL=\"DSpace\">\n     *   <div TYPE=\"DSpace Item\" DMDID=\"space-separated list of ids\">\n     *     <fptr FILEID=\"primary bitstream\"/>\n     *     ... a div for each content bitstream.\n     *   </div>\n     * </structMap>\n     * }</pre>\n     * @throws java.sql.SQLException passed through.\n     * @throws org.xml.sax.SAXException passed through.\n     */\n    @Override\n    protected void renderStructureMap() throws SQLException, SAXException\n    {\n        AttributeMap attributes;\n\n        // ///////////////////////\n        // Start a new structure map\n        attributes = new AttributeMap();\n        attributes.put(\"TYPE\", \"LOGICAL\");\n        attributes.put(\"LABEL\", \"DSpace\");\n        startElement(METS,\"structMap\",attributes);\n\n        // ////////////////////////////////\n        // Start the special first division\n        attributes = new AttributeMap();\n        attributes.put(\"TYPE\", \"DSpace Item\");\n        // add references to the Descriptive metadata\n        if (dmdSecIDS != null)\n        {\n            attributes.put(\"DMDID\", dmdSecIDS.toString());\n        }\n        // add references to the Administrative metadata\n        if (amdSecIDS != null)\n        {\n            attributes.put(\"AMDID\", amdSecIDS.toString());\n        }\n        startElement(METS,\"div\",attributes);\n\n        // add a fptr pointer to the primary bitstream.\n        if (primaryBitstream != null)\n        {\n                // ////////////////////////////////\n                // Start & end a reference to the primary bitstream.\n                attributes = new AttributeMap();\n                String fileID = getFileID(primaryBitstream);\n                attributes.put(\"FILEID\", fileID);\n\n                startElement(METS,\"fptr\",attributes);\n                endElement(METS,\"fptr\");\n        }\n\n        for (Bitstream bitstream : contentBitstreams)\n        {\n                // ////////////////////////////////////\n                // Start a div for each publicly viewable bitstream\n                attributes = new AttributeMap();\n                attributes.put(\"ID\", getGenericID(\"div_\"));\n                attributes.put(\"TYPE\", \"DSpace Content Bitstream\");\n                startElement(METS,\"div\",attributes);\n\n                // ////////////////////////////////\n                // Start a the actualy pointer to the bitstream FIXME: what?\n                attributes = new AttributeMap();\n                String fileID = getFileID(bitstream);\n                attributes.put(\"FILEID\", fileID);\n\n                startElement(METS,\"fptr\",attributes);\n                endElement(METS,\"fptr\");\n\n                // ///////////////////////////////\n                // End the div\n                endElement(METS,\"div\");\n        }\n\n        // ////////////////////////////////\n        // End the special first division\n        endElement(METS,\"div\");\n\n        // ///////////////////////\n        // End the structure map\n        endElement(METS,\"structMap\");\n    }\n\n\n\n    /**\n     * Render any extra METS section. If the item contains a METS.xml document\n     * then all of that document's sections are included in this document's\n     * METS document.\n     * @throws org.xml.sax.SAXException passed through.\n     * @throws java.sql.SQLException passed through.\n     * @throws java.io.IOException passed through.\n     */\n    @Override\n    protected void renderExtraSections() throws SAXException, SQLException, IOException\n    {\n        Boolean include = DSpaceServicesFactory.getInstance().getConfigurationService().getBooleanProperty(\"xmlui.bitstream.mets\");\n        if (!include)\n        {\n            return;\n        }\n\n\n        List<Bundle> bundles = itemService.getBundles(item, \"METADATA\");\n\n        for (Bundle bundle : bundles)\n        {\n                Bitstream bitstream = bundleService.getBitstreamByName(bundle, \"METS.xml\");\n\n                if (bitstream == null)\n                {\n                    continue;\n                }\n\n                // ///////////////////////////////\n                // Send the actual XML content\n                try {\n                        SAXFilter filter = new SAXFilter(contentHandler, lexicalHandler, namespaces);\n                        // Allow the basics for XML\n                        filter.allowIgnorableWhitespace().allowCharacters().allowCDATA().allowPrefixMappings();\n                        // Special option, only allow elements below the second level to pass through. This\n                        // will trim out the METS declaration and only leave the actual METS parts to be\n                        // included.\n                        filter.allowElements(1);\n\n\n                        XMLReader reader = XMLReaderFactory.createXMLReader();\n                        reader.setContentHandler(filter);\n                        reader.setProperty(\"http://xml.org/sax/properties/lexical-handler\", filter);\n                        reader.parse(new InputSource(bitstreamService.retrieve(context, bitstream)));\n                }\n                        catch (AuthorizeException ae)\n                        {\n                                // just ignore the authorize exception and continue on\n                                // without parsing the xml document.\n                        }\n        }\n    }\n\n\n    /**\n     * Checks which Bundles of current item a user has requested.\n     * If none specifically requested, then all Bundles are returned.\n     *\n     * @return List of enabled bundles\n     * @throws java.sql.SQLException passed through.\n     */\n    protected List<Bundle> findEnabledBundles() throws SQLException\n    {\n        // Check if the user is requested a specific bundle or\n        // the all bundles.\n        List<Bundle> bundles;\n        if (fileGrpTypes.isEmpty())\n        {\n            bundles = item.getBundles();\n        }\n        else\n        {\n                bundles = new ArrayList<>();\n                for (String fileGrpType : fileGrpTypes)\n                {\n                        for (Bundle newBundle : itemService.getBundles(item, fileGrpType))\n                        {\n                                bundles.add(newBundle);\n                        }\n                }\n        }\n\n        return bundles;\n    }\n\n\n    /**\n     * For a bitstream that's a thumbnail or extracted text, find the\n     * corresponding bitstream it was derived from, in the ORIGINAL bundle.\n     *\n     * @param item\n     *            the item we're dealing with\n     * @param derived\n     *            the derived bitstream\n     *\n     * @return the corresponding original bitstream (or null)\n     * @throws java.sql.SQLException passed through.\n     */\n    protected static Bitstream findOriginalBitstream(Item item,Bitstream derived) throws SQLException\n    {\n        // FIXME: this method is a copy of the one found below. However, the\n        // original method is protected so we can't use it here. I think that\n        // perhaps this should be folded into the DSpace bitstream API. Until\n        // when a good final solution can be determined I am just going to copy\n        // the method here.\n        //\n        // return org.dspace.content.packager.AbstractMetsDissemination\n        // .findOriginalBitstream(item, derived);\n\n        List<Bundle> bundles = item.getBundles();\n\n        // Filename of original will be filename of the derived bitstream\n        // minus the extension (ie everything from and including the last \".\" character)\n       int endIndex = derived.getName().lastIndexOf(\".\");\n       String originalFilename = derived.getName().substring(0, endIndex>0?endIndex:(derived.getName().length()-1));\n\n        // First find \"original\" bundle\n        for (Bundle bundle : bundles)\n        {\n            if ((bundle.getName() != null)\n                    && bundle.getName().equals(\"ORIGINAL\"))\n            {\n                // Now find the corresponding bitstream\n                List<Bitstream> bitstreams = bundle.getBitstreams();\n\n                for (Bitstream bitstream : bitstreams)\n                {\n                    if (bitstream.getName().equals(originalFilename))\n                    {\n                        return bitstream;\n                    }\n                }\n            }\n        }\n\n        // Didn't find it\n        return null;\n    }\n\n    /**\n     * Generate a METS file element for a given bitstream.\n     *\n     * @param item\n     *            If the bitstream is associated with an item provide the item\n     *            otherwise leave null.\n     * @param bitstream\n     *            The bitstream to build a file element for.\n     * @param fileID\n     *            The unique file id for this file.\n     * @param groupID\n     *            The group id for this file, if it is derived from another file\n     *            then they should share the same groupID.\n     * @param admID\n     *            The IDs of the administrative metadata sections which pertain\n     *            to this file\n     * @throws org.xml.sax.SAXException passed through.\n     * @throws java.sql.SQLException passed through.\n     */\n\n    // FIXME: this method is a copy of the one inherited. However the\n    // original method is final so we must rename it.\n\tprotected void renderFileWithAllowed(Item item, Bitstream bitstream, String fileID, String groupID, String admID) throws SAXException, SQLException\n    {\n\t\tAttributeMap attributes;\n\n\t\t// //////////////////////////////\n    \t// Determine the file attributes\n        BitstreamFormat format = bitstream.getFormat(context);\n        String mimeType = null;\n        if (format != null)\n        {\n            mimeType = format.getMIMEType();\n        }\n        String checksumType = bitstream.getChecksumAlgorithm();\n        String checksum = bitstream.getChecksum();\n        long size = bitstream.getSizeBytes();\n\n        // ////////////////////////////////\n        // Start the actual file\n        attributes = new AttributeMap();\n        attributes.put(\"ID\", fileID);\n        attributes.put(\"GROUPID\",groupID);\n        if (admID != null && admID.length()>0)\n        {\n            attributes.put(\"ADMID\", admID);\n        }\n        if (mimeType != null && mimeType.length()>0)\n        {\n            attributes.put(\"MIMETYPE\", mimeType);\n        }\n        if (checksumType != null && checksum != null)\n        {\n        \tattributes.put(\"CHECKSUM\", checksum);\n        \tattributes.put(\"CHECKSUMTYPE\", checksumType);\n        }\n        attributes.put(\"SIZE\", String.valueOf(size));\n        startElement(METS,\"file\",attributes);\n\n\n        // ////////////////////////////////////\n        // Determine the file location attributes\n        String name = bitstream.getName();\n        String description = bitstream.getDescription();\n\n\n        // If possible reference this bitstream via a handle, however this may\n        // be null if a handle has not yet been assigned. In this case reference the\n        // item its internal id. In the last case where the bitstream is not associated\n        // with an item (such as a community logo) then reference the bitstreamID directly.\n        String identifier = null;\n        if (item != null && item.getHandle() != null)\n        {\n            identifier = \"handle/\" + item.getHandle();\n        }\n        else if (item != null)\n        {\n            identifier = \"item/\" + item.getID();\n        }\n        else\n        {\n            identifier = \"id/\" + bitstream.getID();\n        }\n\n\n        String url = contextPath + \"/bitstream/\"+identifier+\"/\";\n\n        // If we can put the pretty name of the bitstream on the end of the URL\n        try\n        {\n        \tif (bitstream.getName() != null)\n            {\n                url += Util.encodeBitstreamName(bitstream.getName(), \"UTF-8\");\n            }\n        }\n        catch (UnsupportedEncodingException uee)\n        {\n            // just ignore it, we don't have to have a pretty\n            // name on the end of the URL because the sequence id will\n        \t// locate it. However it means that links in this file might\n        \t// not work....\n        }\n\n        url += \"?sequence=\"+bitstream.getSequenceID();\n\n\t// Test if we are allowed to see this item\n\tString isAllowed = \"n\";\n\ttry {\n\t    if (authorizeService.authorizeActionBoolean(context, bitstream, Constants.READ)) {\n\t\tisAllowed = \"y\";\n\t    }\n\t} catch (SQLException e) {/* Do nothing */}\n\n\turl += \"&isAllowed=\" + isAllowed;\n\n        // //////////////////////\n        // Start the file location\n        attributes = new AttributeMap();\n        AttributeMap attributesXLINK = new AttributeMap();\n        attributesXLINK.setNamespace(XLINK);\n        attributes.put(\"LOCTYPE\", \"URL\");\n        attributesXLINK.put(\"type\",\"locator\");\n        attributesXLINK.put(\"title\", name);\n        if (description != null)\n        {\n            attributesXLINK.put(\"label\", description);\n        }\n        attributesXLINK.put(\"href\", url);\n        startElement(METS,\"FLocat\",attributes,attributesXLINK);\n\n\n        // ///////////////////////\n        // End file location\n        endElement(METS,\"FLocate\");\n\n        // ////////////////////////////////\n        // End the file\n        endElement(METS,\"file\");\n\t}\n}\n", "/**\n * The contents of this file are subject to the license and copyright\n * detailed in the LICENSE and NOTICE files at the root of the source\n * tree and available online at\n *\n * http://www.dspace.org/license/\n */\npackage org.dspace.app.xmlui.objectmanager;\n\nimport java.sql.SQLException;\n\nimport org.dspace.app.xmlui.wing.AttributeMap;\nimport org.dspace.app.xmlui.wing.Namespace;\nimport org.dspace.app.xmlui.wing.WingException;\nimport org.dspace.content.Collection;\nimport org.dspace.content.Community;\nimport org.dspace.content.DSpaceObject;\nimport org.dspace.content.factory.ContentServiceFactory;\nimport org.dspace.content.service.CommunityService;\nimport org.dspace.services.factory.DSpaceServicesFactory;\nimport org.dspace.core.Constants;\nimport org.dspace.core.Context;\nimport org.dspace.handle.factory.HandleServiceFactory;\nimport org.dspace.handle.service.HandleService;\nimport org.xml.sax.SAXException;\n\n/**\n * This is an an adapter which translates a DSpace repository into a METS \n * document. Unfortunately, there is no real definition of what this is. So\n * we just kind of made it up based upon what we saw for the item profile.\n * \n * The basic structure is simply two parts:  the descriptive metadata and a\n * structural map. The descriptive metadata is a place to put metadata about \n * the whole repository. The structural map is used to map relationships\n * between communities and collections in DSpace.\n * \n * @author Scott Phillips\n */\npublic class RepositoryAdapter extends AbstractAdapter\n{\n\n\t/** MODS namespace */\n    public static final String MODS_URI = \"http://www.loc.gov/mods/v3\";\n    public static final Namespace MODS = new Namespace(MODS_URI);\n\n\t\n    /** A space separated list of descriptive metadata sections */\n    private String dmdSecIDS;\n    \n    /** Dspace context to be able to look up additional objects */\n    private final Context context;\n\n    protected CommunityService communityService = ContentServiceFactory.getInstance().getCommunityService();\n    protected HandleService handleService = HandleServiceFactory.getInstance().getHandleService();\n\n    /**\n     * Construct a new RepositoryAdapter\n     * \n     * @param context\n     *            The DSpace context to look up communities / collections.\n     * \n     * @param contextPath\n     *            The context Path of this web application.\n     */\n    public RepositoryAdapter(Context context, String contextPath)\n    {\n        super(contextPath);\n        this.context = context;\n    }\n\n    /**\n     * \n     * \n     * \n     * Abstract methods\n     * \n     * \n     * \n     */\n\n    /**\n     * @return the handle prefix as the identifier.\n     */\n    @Override\n    protected String getMETSID()\n    {\n        return handleService.getPrefix();\n    }\n    \n\t/**\n\t * The OBJID is used to encode the URL to the object, in this\n\t * case the repository which is just at the contextPath.\n     * @return local path to the object.\n     * @throws org.dspace.app.xmlui.wing.WingException passed through.\n\t */\n    @Override\n\tprotected String getMETSOBJID() throws WingException {\n\t\t\n\t\tif (contextPath == null)\n        {\n            return \"/\";\n        }\n\t\telse\n        {\n            return contextPath + \"/\";\n        }\n\t}\n\n    /**\n     * @return  Return the URL for editing this item\n     */\n    @Override\n    protected String getMETSOBJEDIT()\n    {\n        return null;\n    }\n\n    /**\n     * @return the profile this METS document conforms to...\n     *\n     * FIXME: It doesn't conform to a profile. This needs to be fixed.\n     */\n    @Override\n    protected String getMETSProfile()\n    {\n        return \"DRI DSPACE Repository Profile 1.0\";\n    }\n\n    /**\n     * @return a friendly label for the METS document stating that this is a\n     * DSpace repository.\n     */\n    @Override\n    protected String getMETSLabel()\n    {\n        return \"DSpace Repository\";\n    }\n\n    \n    /**\n     * \n     * \n     * \n     * METS structural methods\n     * \n     * \n     * \n     */\n\n    /**\n     * Render the repository's descriptive metadata section.\n     *\n     * For a the DSpace repository we just grab a few items \n     * from the config file and put them into the descriptive \n     * section, such as the name, hostname, handle prefix, and \n     * default language.\n     * \n     * @throws org.xml.sax.SAXException passed through.\n     */\n    @Override\n\tprotected void renderDescriptiveSection() throws SAXException\n    {\n    \tAttributeMap attributes;\n    \t\n    \t// Generate our ids\n        String dmdID = getGenericID(\"dmd_\");\n        String groupID = getGenericID(\"group_dmd_\");\n\n        // ////////////////////////////////\n        // Start a single dmdSec\n        attributes = new AttributeMap();\n        attributes.put(\"ID\", dmdID);\n        attributes.put(\"GROUPID\", groupID);\n        startElement(METS,\"dmdSec\",attributes);\n\n        // ////////////////////////////////\n        // Start a metadata wrapper (hardcoded to mods)\n        attributes = new AttributeMap();\n        attributes.put(\"MDTYPE\", \"OTHER\");\n        attributes.put(\"OTHERMDTYPE\", \"DIM\");\n        startElement(METS,\"mdWrap\",attributes);\n\n        // ////////////////////////////////\n        // Start the xml data\n        startElement(METS,\"xmlData\");\n        \n        /////////////////////////////////\n\t\t// Start the DIM element\t\t\t\n\t\tattributes = new AttributeMap();\n\t\tattributes.put(\"dspaceType\", Constants.typeText[Constants.SITE]);\n\t\tstartElement(DIM,\"dim\",attributes);\n\t\t\n\t\t// Entry for dspace.name\n\t\tattributes = new AttributeMap();\n\t\tattributes.put(\"mdschema\",\"dspace\");\n\t\tattributes.put(\"element\", \"name\");\n\t\tstartElement(DIM,\"field\",attributes);\n\t\tsendCharacters(DSpaceServicesFactory.getInstance().getConfigurationService().getProperty(\"dspace.name\"));\n\t\tendElement(DIM,\"field\");\n\t\t\n\t\t// Entry for dspace.hostname\n\t\tattributes = new AttributeMap();\n\t\tattributes.put(\"mdschema\",\"dspace\");\n\t\tattributes.put(\"element\", \"hostname\");\n\t\tstartElement(DIM,\"field\",attributes);\n\t\tsendCharacters(DSpaceServicesFactory.getInstance().getConfigurationService().getProperty(\"dspace.hostname\"));\n\t\tendElement(DIM,\"field\");\n\t\t\n\t\t// Entry for handle.prefix\n\t\tattributes = new AttributeMap();\n\t\tattributes.put(\"mdschema\",\"dspace\");\n\t\tattributes.put(\"element\", \"handle\");\n\t\tstartElement(DIM,\"field\",attributes);\n\t\tsendCharacters(handleService.getPrefix());\n\t\tendElement(DIM,\"field\");\n\t\t\n\t\t// Entry for default.language\n\t\tattributes = new AttributeMap();\n\t\tattributes.put(\"mdschema\",\"dspace\");\n\t\tattributes.put(\"element\", \"default\");\n\t\tattributes.put(\"qualifier\", \"language\");\n\t\tstartElement(DIM,\"field\",attributes);\n\t\tsendCharacters(DSpaceServicesFactory.getInstance().getConfigurationService().getProperty(\"default.language\"));\n\t\tendElement(DIM,\"field\");\n\t\t\n        // ///////////////////////////////\n        // End the DIM element\n        endElement(DIM,\"dim\");\n        \n        // End all the open elements.\n        endElement(METS,\"xmlData\");\n        endElement(METS,\"mdWrap\");\n        endElement(METS,\"dmdSec\");\n\n        // Remember the IDS\n        this.dmdSecIDS = dmdID;\n    }\n\n    /**\n     * Render the repository's structure map. This map will include a reference to\n     * all the community and collection objects showing how they are related to\n     * one another. \n     * @throws java.sql.SQLException passed through.\n     * @throws org.xml.sax.SAXException passed through.\n     */\n    @Override\n\tprotected void renderStructureMap() throws SQLException, SAXException\n    {\n    \tAttributeMap attributes;\n        \n    \t// //////////////////////////\n    \t// Start the new struct map\n        attributes = new AttributeMap();\n        attributes.put(\"TYPE\", \"LOGICAL\");\n        attributes.put(\"LABEL\", \"DSpace\");\n        startElement(METS,\"structMap\",attributes);\n        \n        // ////////////////////////////////\n        // Start the special first division\n        attributes = new AttributeMap();\n        attributes.put(\"TYPE\", \"DSpace Repository\");\n        // add references to the Descriptive metadata\n        if (dmdSecIDS != null)\n        {\n            attributes.put(\"DMDID\", dmdSecIDS);\n        }\n        startElement(METS,\"div\",attributes);\n\n        // Put each root level node into the document.\n        for (Community community : communityService.findAllTop(context))\n        {\n            renderStructuralDiv(community);\n        }\n        \n        \n        // //////////////////\n        // Close special first division and structural map\n        endElement(METS,\"div\");\n        endElement(METS,\"structMap\");\n        \n    }\n\n    /**\n     * \n     * \n     * \n     * private helpful methods\n     * \n     * \n     * \n     */\n\n    /**\n     * Recursively walk the DSpace hierarchy, rendering each container and subcontainer.\n     *\n     * @param dso\n     *            The DSpace Object to be rendered.\n     */\n    private void renderStructuralDiv(DSpaceObject dso) throws SAXException, SQLException\n    {\n    \tAttributeMap attributes;\n\n        // ////////////////////////////////\n        // Start the new div for this repository container\n        attributes = new AttributeMap();\n        if (dso instanceof Community)\n        {\n            attributes.put(\"TYPE\", \"DSpace Community\");\n        }\n        else if (dso instanceof Collection)\n        {\n            attributes.put(\"TYPE\", \"DSpace Collection\");\n        }\n        startElement(METS,\"div\",attributes);\n        \n        // //////////////////////////////////\n        // Start a metadata pointer for this container\n        attributes = new AttributeMap();\n        AttributeMap attributesXLINK = new AttributeMap();\n        attributesXLINK.setNamespace(XLINK);\n        \n        attributes.put(\"LOCTYPE\", \"URL\");\n        attributesXLINK.put(\"href\", \"/metadata/handle/\"+ dso.getHandle() +\"/mets.xml\");\n        startElement(METS,\"mptr\",attributes,attributesXLINK);\n        endElement(METS,\"mptr\");\n        \n        // Recurse to ensure that our children are also included even if this\n        // node already existed in the div structure.\n        if (dso instanceof Community)\n        {\n        \tfor (DSpaceObject child : ((Community)dso).getCollections())\n            {\n                renderStructuralDiv(child);\n            }\n        \t\n        \tfor (DSpaceObject child : ((Community)dso).getSubcommunities())\n            {\n                renderStructuralDiv(child);\n            }\n        }\n        \n        // ////////////////////\n        // Close division\n        endElement(METS,\"div\");\n    }\n}\n"], "fixing_code": ["/**\n * The contents of this file are subject to the license and copyright\n * detailed in the LICENSE and NOTICE files at the root of the source\n * tree and available online at\n *\n * http://www.dspace.org/license/\n */\npackage org.dspace.app.xmlui.cocoon;\n\nimport java.io.IOException;\nimport java.sql.SQLException;\nimport java.util.UUID;\n\nimport org.apache.cocoon.ProcessingException;\nimport org.apache.cocoon.ResourceNotFoundException;\nimport org.apache.cocoon.environment.ObjectModelHelper;\nimport org.apache.cocoon.environment.Request;\nimport org.apache.cocoon.environment.Response;\nimport org.apache.cocoon.generation.AbstractGenerator;\nimport org.dspace.app.xmlui.objectmanager.AbstractAdapter;\nimport org.dspace.app.xmlui.objectmanager.ContainerAdapter;\nimport org.dspace.app.xmlui.objectmanager.ItemAdapter;\nimport org.dspace.app.xmlui.objectmanager.RepositoryAdapter;\nimport org.dspace.app.xmlui.utils.ContextUtil;\nimport org.dspace.app.xmlui.wing.WingException;\nimport org.dspace.content.Collection;\nimport org.dspace.content.Community;\nimport org.dspace.content.DSpaceObject;\nimport org.dspace.content.Item;\nimport org.dspace.content.crosswalk.CrosswalkException;\nimport org.dspace.content.factory.ContentServiceFactory;\nimport org.dspace.content.service.CollectionService;\nimport org.dspace.content.service.CommunityService;\nimport org.dspace.content.service.ItemService;\nimport org.dspace.core.Context;\nimport org.dspace.handle.factory.HandleServiceFactory;\nimport org.dspace.handle.service.HandleService;\nimport org.xml.sax.SAXException;\n\n/**\n * Generate a METS document for the identified item, community or collection. The object to be rendered should be\n * identified by passing in one of the two parameters: handle or internal. If an internal ID is given then it must\n * be of the form \"type:id\" i.g. item:255 or community:4 or repository:123456789. In the case of a repository the\n * id must be the handle prefix.\n * \n * In addition to rendering a METS document there are several options which can be specified for how the mets\n * document should be rendered. All parameters are a comma-separated list of values, here is a list:\n * \n * \n * sections:\n * \n * A comma-separated list of METS sections to included. The possible values are: \"metsHdr\", \"dmdSec\", \n * \"amdSec\", \"fileSec\", \"structMap\", \"structLink\", \"behaviorSec\", and \"extraSec\". If no list is provided then *ALL*\n * sections are rendered.\n * \n * \n * dmdTypes:\n * \n * A comma-separated list of metadata formats to provide as descriptive metadata. The list of available metadata\n * types is defined in the dspace.cfg, dissemination crosswalks. If no formats are provided them DIM - DSpace \n * Intermediate Format - is used.\n * \n * \n * amdTypes:\n * \n * A comma-separated list of metadata formats to provide administrative metadata. DSpace does not currently\n * support this type of metadata.\n * \n * \n * fileGrpTypes:\n * \n * A comma-separated list of file groups to render. For DSpace a bundle is translated into a METS fileGrp, so\n * possible values are \"THUMBNAIL\",\"CONTENT\", \"METADATA\", etc... If no list is provided then all groups are\n * rendered.\n * \n * \n * structTypes:\n * \n * A comma-separated list of structure types to render. For DSpace there is only one structType: LOGICAL. If this\n * is provided then the logical structType will be rendered, otherwise none will. The default operation is to\n * render all structure types.\n * \n * @author Scott Phillips\n */\npublic class DSpaceMETSGenerator extends AbstractGenerator\n{\n    protected HandleService handleService = HandleServiceFactory.getInstance().getHandleService();\n    protected CommunityService communityService = ContentServiceFactory.getInstance().getCommunityService();\n   \tprotected CollectionService collectionService = ContentServiceFactory.getInstance().getCollectionService();\n    protected ItemService itemService = ContentServiceFactory.getInstance().getItemService();\n\n\t/**\n\t * Generate the METS Document.\n     * @throws java.io.IOException passed through.\n     * @throws org.xml.sax.SAXException passed through.\n     * @throws org.apache.cocoon.ProcessingException on error.\n\t */\n    @Override\n\tpublic void generate() throws IOException, SAXException, ProcessingException {\n\t\ttry {\n\t\t\t// Open a new context.\n\t\t\tContext context = ContextUtil.obtainContext(objectModel);\n\t\t\t\n\t\t\t// Determine which adapter to use\n\t\t\tAbstractAdapter adapter = resolveAdapter(context);\n            if (adapter == null)\n            {\n                throw new ResourceNotFoundException(\"Unable to locate object.\");\n            }\n            \n\t\t\tif (adapter.isAuthorized())\n\t\t\t{\n\t\t\t\t// Configure the adapter for this request.\n\t\t\t\tconfigureAdapter(adapter);\n\n\t\t\t\t// Generate the METS document\n\t\t\t\tcontentHandler.startDocument();\n\t\t\t\tadapter.renderMETS(context, contentHandler, lexicalHandler);\n\t\t\t\tcontentHandler.endDocument();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tResponse response = ObjectModelHelper.getResponse(objectModel);\n\t\t\t\tresponse.setStatus(403);\n\t\t\t}\n\t\t} catch (WingException we) {\n\t\t\tthrow new ProcessingException(we);\n\t\t} catch (CrosswalkException ce) {\n\t\t\tthrow new ProcessingException(ce);\n\t\t} catch (SQLException sqle) {\n\t\t\tthrow new ProcessingException(sqle);\n\t\t}\n\t}\n   \n\t\n\t\n\t/**\n\t * Determine which type of adapter to use for this object, either a community, collection, item, or\n\t * repository adapter. The decision is based upon the two supplied identifiers: a handle or an\n\t * internal id. If the handle is supplied then this is resolved and the appropriate adapter is\n\t * picked. Otherwise the internal identifier is used to resolve the correct type of adapter.\n\t * \n\t * The internal identifier must be of the form \"type:id\" i.g. item:255 or collection:99. In the\n\t * case of a repository the handle prefix must be used.\n\t * \n\t * @return Return the correct adaptor or null if none found.\n\t */\n\tprivate AbstractAdapter resolveAdapter(Context context) throws SQLException \n\t{\t\t\t\n\t\tRequest request = ObjectModelHelper.getRequest(objectModel);\n        String contextPath = request.getContextPath();\n\n        // Determine the correct adapter to use for this item\n        String handle = parameters.getParameter(\"handle\",null);\n        String internal = parameters.getParameter(\"internal\",null);\n\t\t\n        AbstractAdapter adapter = null;\n\t\t if (handle != null)\n         {\n            // Specified using a regular handle.\n            DSpaceObject dso = handleService.resolveToObject(context, handle);\n\n            // Handles can be either items or containers.\n            if (dso instanceof Item)\n            {\n                adapter = new ItemAdapter(context, (Item) dso, contextPath);\n            }\n         \telse if (dso instanceof Collection || dso instanceof Community)\n            {\n                adapter = new ContainerAdapter(context, dso, contextPath);\n            }\n         }\n         else if (internal != null)\n         {\n        \t// Internal identifier, format: \"type:id\".\n         \tString[] parts = internal.split(\":\");\n         \t\n         \tif (parts.length == 2)\n         \t{\n         \t\tString type = parts[0];\n                       String strid = parts[1];\n         \t\tUUID id = null;\n\n                        // Handle prefixes must be treated as strings\n                        // all non-repository types need integer IDs\n                        if (\"repository\".equals(type))\n                        {\n                                if (handleService.getPrefix().equals(strid))\n                                {\n                                    adapter = new RepositoryAdapter(context, contextPath);\n                                }\n                        }\n                        else\n                        {\n                               id = UUID.fromString(parts[1]);\n         \t\t\tif (\"item\".equals(type))\n         \t\t\t{\n         \t\t\t\tItem item = itemService.find(context,id);\n         \t\t\t\tif (item != null)\n                         {\n                             adapter = new ItemAdapter(context, item, contextPath);\n                         }\n         \t\t\t}\n         \t\t\telse if (\"collection\".equals(type))\n         \t\t\t{\n         \t\t\t\tCollection collection = collectionService.find(context,id);\n         \t\t\t\tif (collection != null)\n                         {\n                             adapter = new ContainerAdapter(context, collection, contextPath);\n                         }\n         \t\t\t}\n         \t\t\telse if (\"community\".equals(type))\n         \t\t\t{\n         \t\t\t\tCommunity community = communityService.find(context,id);\n         \t\t\t\tif (community != null)\n                         {\n                             adapter = new ContainerAdapter(context, community, contextPath);\n                         }\n         \t\t\t}\n\t\t\t}\n         \t}\n         }\n\t\t return adapter;\n\t}\n\t\n\t/**\n\t * Configure the adapter according to the supplied parameters.\n     * @param adapter the adapter.\n\t */\n\tpublic void configureAdapter(AbstractAdapter adapter)\n\t{\n        // Configure the adapter based upon the passed parameters\n        Request request = ObjectModelHelper.getRequest(objectModel);\n        String sections = request.getParameter(\"sections\");\n        String dmdTypes = request.getParameter(\"dmdTypes\");\n        String techMDTypes = request.getParameter(\"techMDTypes\");\n        String rightsMDTypes = request.getParameter(\"rightsMDTypes\");\n        String sourceMDTypes = request.getParameter(\"sourceMDTypes\");\n        String digiprovMDTypes = request.getParameter(\"digiprovMDTypes\");\n        String fileGrpTypes = request.getParameter(\"fileGrpTypes\");\n        String structTypes = request.getParameter(\"structTypes\");\n        \n        adapter.setSections(sections);\n        adapter.setDmdTypes(dmdTypes);\n        adapter.setTechMDTypes(techMDTypes);\n        adapter.setRightsMDTypes(rightsMDTypes);\n        adapter.setSourceMDTypes(sourceMDTypes);\n        adapter.setDigiProvMDTypes(digiprovMDTypes);\n        adapter.setFileGrpTypes(fileGrpTypes);\n        adapter.setStructTypes(structTypes);\n\t}\n\n}\n", "/**\n * The contents of this file are subject to the license and copyright\n * detailed in the LICENSE and NOTICE files at the root of the source\n * tree and available online at\n *\n * http://www.dspace.org/license/\n */\npackage org.dspace.app.xmlui.cocoon;\n\nimport java.io.IOException;\nimport java.sql.SQLException;\nimport java.util.UUID;\n\nimport org.apache.cocoon.ProcessingException;\nimport org.apache.cocoon.ResourceNotFoundException;\nimport org.apache.cocoon.environment.ObjectModelHelper;\nimport org.apache.cocoon.environment.Response;\nimport org.apache.cocoon.generation.AbstractGenerator;\nimport org.dspace.app.xmlui.utils.ContextUtil;\nimport org.dspace.authorize.AuthorizeException;\nimport org.dspace.authorize.factory.AuthorizeServiceFactory;\nimport org.dspace.authorize.service.AuthorizeService;\nimport org.dspace.content.DSpaceObject;\nimport org.dspace.content.Item;\nimport org.dspace.content.crosswalk.CrosswalkException;\nimport org.dspace.content.crosswalk.DisseminationCrosswalk;\nimport org.dspace.content.factory.ContentServiceFactory;\nimport org.dspace.content.service.ItemService;\nimport org.dspace.core.Constants;\nimport org.dspace.core.Context;\nimport org.dspace.core.factory.CoreServiceFactory;\nimport org.dspace.handle.factory.HandleServiceFactory;\nimport org.dspace.handle.service.HandleService;\nimport org.jdom.Element;\nimport org.jdom.JDOMException;\nimport org.jdom.output.SAXOutputter;\nimport org.xml.sax.SAXException;\n\n/**\n * Generate an ORE aggregation of a DSpace Item. The object to be rendered should be an item identified by pasing \n * in one of the two parameters: handle or internal. The fragment parameter determines the encoding format for\n * the aggregation; only Atom is supported at this time.\n\n * @author Alexey Maslov\n */\npublic class DSpaceOREGenerator extends AbstractGenerator\n{\n\n\tprotected ItemService itemService = ContentServiceFactory.getInstance().getItemService();\n\tprotected HandleService handleService = HandleServiceFactory.getInstance().getHandleService();\n\tprotected AuthorizeService authorizeService = AuthorizeServiceFactory.getInstance().getAuthorizeService();\n\n\t/**\n\t * Generate the ORE Aggregation.\n\t */\n\tpublic void generate() throws IOException, SAXException,\n\t\t\tProcessingException {\n\t\ttry {\n\t\t\t// Grab the context.\n\t\t\tContext context = ContextUtil.obtainContext(objectModel);\n\t\t\t\n\t\t\tItem item = getItem(context);\n            if (item == null)\n            {\n                throw new ResourceNotFoundException(\"Unable to locate object.\");\n            }\n            \n\t\t\tif (authorizeService.authorizeActionBoolean(context, item,\n\t\t\t\t\tConstants.READ))\n\t\t\t{\n\t\t\t\t// Instantiate and execute the ORE plugin\n\t\t\t\tSAXOutputter out = new SAXOutputter(contentHandler);\n\t\t\t\tDisseminationCrosswalk xwalk = (DisseminationCrosswalk) CoreServiceFactory\n\t\t\t\t\t\t.getInstance().getPluginService()\n\t\t\t\t\t\t.getNamedPlugin(DisseminationCrosswalk.class, \"ore\");\n\n\t\t\t\tElement ore = xwalk.disseminateElement(context, item);\n\t\t\t\tout.output(ore);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tResponse response = ObjectModelHelper.getResponse(objectModel);\n\t\t\t\tresponse.setStatus(403);\n\t\t\t}\n\t\t} catch (JDOMException je) {\n\t\t\tthrow new ProcessingException(je);\n\t\t} catch (AuthorizeException ae) {\n\t\t\tthrow new ProcessingException(ae);\n\t\t} catch (CrosswalkException ce) {\n\t\t\tthrow new ProcessingException(ce);\n\t\t} catch (SQLException sqle) {\n\t\t\tthrow new ProcessingException(sqle);\n\t\t}\n\t}\n   \n\t\n\tprivate Item getItem(Context context) throws SQLException, CrosswalkException \n\t{\t\t\t\n        // Determine the correct adatper to use for this item\n        String handle = parameters.getParameter(\"handle\",null);\n        String internal = parameters.getParameter(\"internal\",null);\n\t\t\n\t\t if (handle != null)\n         {\n\t\t\t// Specified using a regular handle. \n         \tDSpaceObject dso = handleService.resolveToObject(context, handle);\n         \t\n         \t// Handles can be either items or containers.\n         \tif (dso instanceof Item)\n             {\n                 return (Item) dso;\n             }\n         \telse\n             {\n                 throw new CrosswalkException(\"ORE dissemination only available for DSpace Items.\");\n             }\n         }\n         else if (internal != null)\n         {\n        \t// Internal identifier, format: \"type:id\".\n         \tString[] parts = internal.split(\":\");\n         \t\n         \tif (parts.length == 2)\n         \t{\n         \t\tString type = parts[0];\n         \t\tUUID id = UUID.fromString(parts[1]);\n         \t\t\n         \t\tif (\"item\".equals(type))\n         \t\t{\n                     return itemService.find(context,id);\n         \t\t}\n         \t\telse\n                 {\n                     throw new CrosswalkException(\"ORE dissemination only available for DSpace Items.\");\n                 }\n         \t\t\n         \t}\n         }\n\t\t return null;\n\t}\n\t\n}\n", "/**\n * The contents of this file are subject to the license and copyright\n * detailed in the LICENSE and NOTICE files at the root of the source\n * tree and available online at\n *\n * http://www.dspace.org/license/\n */\npackage org.dspace.app.xmlui.objectmanager;\n\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.dspace.app.util.Util;\nimport org.dspace.app.xmlui.wing.AttributeMap;\nimport org.dspace.app.xmlui.wing.Namespace;\nimport org.dspace.app.xmlui.wing.WingException;\nimport org.dspace.authenticate.factory.AuthenticateServiceFactory;\nimport org.dspace.authorize.factory.AuthorizeServiceFactory;\nimport org.dspace.authorize.service.AuthorizeService;\nimport org.dspace.content.Bitstream;\nimport org.dspace.content.BitstreamFormat;\nimport org.dspace.content.Item;\nimport org.dspace.content.crosswalk.CrosswalkException;\nimport org.dspace.content.crosswalk.DisseminationCrosswalk;\nimport org.dspace.core.Context;\nimport org.dspace.core.factory.CoreServiceFactory;\nimport org.xml.sax.ContentHandler;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.ext.LexicalHandler;\nimport org.xml.sax.helpers.AttributesImpl;\nimport org.xml.sax.helpers.NamespaceSupport;\n\n/**\n * This is the abstract adapter containing all the common elements between\n * the three types of adapters: item, container, and repository. Each adapter\n * translate a given type of DSpace object into a METS document for rendering\n * into the DRI document.\n * \n * <p>This class provides the chassis for those unique parts of the document to be\n * built upon. There are seven rendering methods that may be overridden for each\n * section of the METS document:\n *\n * <ul>\n * <li>Header</li>\n * <li>Descriptive Section</li>\n * <li>Administrative Section</li>\n * <li>File Section</li>\n * <li>Structure Map</li>\n * <li>Structural Link</li>\n * <li>Behavioral Section</li>\n * </ul>\n *\n * @author Scott Phillips\n */\n\npublic abstract class AbstractAdapter\n{\n    /** Namespace declaration for METS and XLINK */\n    public static final String METS_URI = \"http://www.loc.gov/METS/\";\n    public static final Namespace METS = new Namespace(METS_URI);\n    public static final String XLINK_URI = \"http://www.w3.org/TR/xlink/\";\n    public static final Namespace XLINK = new Namespace(XLINK_URI);\n    public static final String XSI_URI = \"http://www.w3.org/2001/XMLSchema-instance\";\n    public static final Namespace XSI = new Namespace(XSI_URI);\n    public static final String DIM_URI = \"http://www.dspace.org/xmlns/dspace/dim\";\n    public static final Namespace DIM = new Namespace(DIM_URI);    \n    \n    /**\n     * A sequence used to generate unique mets ids.\n     */\n    private int idSequence = 0;\n    \n    /**\n     * The contextPath of this web application, used for generating URLs.\n     */\n    protected String contextPath;\n    \n    /**\n     * The SAX handlers for content and lexical events. Also the support \n     * element for namespaces which knows the prefixes for each declared \n     * namespace.\n     */\n    protected ContentHandler contentHandler;\n    protected LexicalHandler lexicalHandler;\n    protected NamespaceSupport namespaces;\n\n    protected AuthorizeService authorizeService = AuthorizeServiceFactory.getInstance().getAuthorizeService();\n    \n    /**\n     * Construct a new adapter, implementers must call this method so\n     * the appropriate internal values are ensured to be set correctly.\n     * \n     * @param contextPath\n     *            The contextPath of this web application.\n     */\n    public AbstractAdapter(String contextPath)\n    {\n        this.contextPath = contextPath;\n    }\n\n    /** The variables that dictate what part of the METS document to render */\n    List<String> sections = new ArrayList<>();\n    List<String> dmdTypes = new ArrayList<>();\n    Map<String,List> amdTypes = new HashMap<>();\n    List<String> fileGrpTypes = new ArrayList<>();\n    List<String> structTypes = new ArrayList<>();\n    \n    /**\n     * A comma-separated list of METS sections to render. If no value \n     * is provided then all METS sections are rendered.\n     * \n     * @param sections Comma separated list of METS sections.\n     */\n    public final void setSections(String sections)\n    {\n    \tif (sections == null)\n        {\n            return;\n        }\n\n    \tfor (String section : sections.split(\",\"))\n    \t{\n    \t\tthis.sections.add(section);\n    \t}\n    }\n    \n    /**\n     * A comma-separated list of METS descriptive metadata formats to \n     * render. If no value is provided then only the DIM format is used.\n     * \n     * @param dmdTypes Comma separated list of METS metadata types.\n     */\n    public final void setDmdTypes(String dmdTypes)\n    {\n    \tif (dmdTypes == null)\n        {\n            return;\n        }\n\n    \tfor (String dmdType : dmdTypes.split(\",\"))\n    \t{\n    \t\tthis.dmdTypes.add(dmdType);\n    \t}\n    }\n    \n    /**\n     * Store information about what will be rendered in the METS administrative\n     * metadata section.  HashMap format: keys = amdSec, value = List of mdTypes\n     *\n     * @param amdSec Section of {@code <amdSec>} where this administrative metadata\n     *                will be rendered.\n     * @param mdTypes Comma-separated list of METS metadata types.\n     */\n    public final void setAmdTypes(String amdSec, String mdTypes)\n    {\n    \tif (mdTypes == null)\n        {\n            return;\n        }\n\n        List<String> mdTypeList = new ArrayList<>();\n    \tfor (String mdType : mdTypes.split(\",\"))\n    \t{\n    \t\tmdTypeList.add(mdType);\n    \t}\n        \n        this.amdTypes.put(amdSec, mdTypeList);\n    }\n\n    /**\n     * A comma-separated list of METS technical metadata formats to\n     * render.\n     *\n     * @param techMDTypes Comma-separated list of METS metadata types.\n     */\n    public final void setTechMDTypes(String techMDTypes)\n    {\n    \tsetAmdTypes(\"techMD\", techMDTypes);\n    }\n\n    /**\n     * A comma-separated list of METS intellectual property rights metadata\n     * formats to render.\n     *\n     * @param rightsMDTypes Comma-separated list of METS metadata types.\n     */\n    public final void setRightsMDTypes(String rightsMDTypes)\n    {\n    \tsetAmdTypes(\"rightsMD\", rightsMDTypes);\n    }\n\n    /**\n     * A comma-separated list of METS source metadata\n     * formats to render.\n     *\n     * @param sourceMDTypes Comma-separated list of METS metadata types.\n     */\n    public final void setSourceMDTypes(String sourceMDTypes)\n    {\n    \tsetAmdTypes(\"sourceMD\", sourceMDTypes);\n    }\n\n    /**\n     * A comma-separated list of METS digital provenance metadata\n     * formats to render.\n     *\n     * @param digiprovMDTypes Comma-separated list of METS metadata types.\n     */\n    public final void setDigiProvMDTypes(String digiprovMDTypes)\n    {\n    \tsetAmdTypes(\"digiprovMD\", digiprovMDTypes);\n    }\n    \n    /**\n     * A comma-separated list of METS fileGrps to render. If no value\n     * is provided then all groups are rendered.\n     * \n     * @param fileGrpTypes Comma-separated list of METS file groups.\n     */\n    public final void setFileGrpTypes(String fileGrpTypes)\n    {\n    \tif (fileGrpTypes == null)\n        {\n            return;\n        }\n\n    \tfor (String fileGrpType : fileGrpTypes.split(\",\"))\n    \t{\n    \t\tthis.fileGrpTypes.add(fileGrpType);\n    \t}\n    }\n    \n    /**\n     * A comma-separated list of METS structural types to render. If no \n     * value is provided then only the DIM format is used.\n     * \n     * @param structTypes Comma-separated list of METS structure types.\n     */\n    public final void setStructTypes(String structTypes)\n    {\n    \tif (structTypes == null)\n        {\n            return;\n        }\n\n    \tfor (String structType : structTypes.split(\",\"))\n    \t{\n    \t\tthis.structTypes.add(structType);\n    \t}\n    }\n\t\n    \n    /**\n     * \n     * \n     * \n     * \n     * \n     * METS methods\n     * \n     * \n     * \n     * \n     * \n     * \n     */\n    \n    \n    /**\n     * @return the URL for this item in the interface.\n     * @throws org.dspace.app.xmlui.wing.WingException on error.\n     */\n    protected abstract String getMETSOBJID() throws WingException;\n\n    /**\n     * @return the URL for editing this item\n     */\n    protected abstract String getMETSOBJEDIT();\n\n    /**\n     * @return the METS ID of the mets document.\n     * @throws org.dspace.app.xmlui.wing.WingException on error.\n     */\n    protected abstract String getMETSID() throws WingException;\n\n    /**\n     * @return The Profile this METS document conforms to.\n     * @throws org.dspace.app.xmlui.wing.WingException on error.\n     */\n    protected abstract String getMETSProfile() throws WingException;\n\n    /**\n     * @return The label of this METS document.\n     * @throws org.dspace.app.xmlui.wing.WingException on error.\n     */\n    protected abstract String getMETSLabel() throws WingException;\n\n    \n\t/**\n\t * Render the complete METS document.\n     * @param context session context.\n     * @param contentHandler XML content handler.\n     * @param lexicalHandler XML lexical handler.\n     * @throws org.dspace.app.xmlui.wing.WingException passed through.\n     * @throws org.xml.sax.SAXException passed through.\n     * @throws org.dspace.content.crosswalk.CrosswalkException passed through.\n     * @throws java.io.IOException passed through.\n     * @throws java.sql.SQLException passed through.\n\t */\n    public final void renderMETS(Context context, ContentHandler contentHandler, LexicalHandler lexicalHandler)\n            throws WingException, SAXException, CrosswalkException, IOException, SQLException\n    {\n    \t\tthis.contentHandler = contentHandler;\n    \t\tthis.lexicalHandler = lexicalHandler;\n    \t\tthis.namespaces = new NamespaceSupport();\n    \t\n    \t\n    \t\t// Declare our namespaces\n    \t\tnamespaces.pushContext();\n    \t\tnamespaces.declarePrefix(\"mets\", METS.URI);\n    \t\tnamespaces.declarePrefix(\"xlink\", XLINK.URI);\n    \t\tnamespaces.declarePrefix(\"xsi\", XSI.URI);\n    \t\tnamespaces.declarePrefix(\"dim\", DIM.URI);\n    \t\tcontentHandler.startPrefixMapping(\"mets\", METS.URI);\n    \t\tcontentHandler.startPrefixMapping(\"xlink\", XLINK.URI);\n    \t\tcontentHandler.startPrefixMapping(\"xsi\", XSI.URI);\n    \t\tcontentHandler.startPrefixMapping(\"dim\", DIM.URI);\n    \t\t\n    \t\t// Send the METS element\n    \t\tAttributeMap attributes = new AttributeMap();\n    \t\tattributes.put(\"ID\", getMETSID());\n    \t\tattributes.put(\"PROFILE\", getMETSProfile());\n    \t\tattributes.put(\"LABEL\", getMETSLabel());\n    \t\tString objid = getMETSOBJID();\n    \t\tif (objid != null)\n            {\n                attributes.put(\"OBJID\", objid);\n            }\n\n            // Include the link for editing the item\n            objid = getMETSOBJEDIT();\n            if (objid != null)\n            {\n                attributes.put(\"OBJEDIT\", objid);\n            }\n\n    \t\tstartElement(METS,\"METS\",attributes);\n\n    \t\t// If the user requested no specific sections then render them all.\n    \t\tboolean all = (sections.isEmpty());\n    \t\t\n    \t\tif (all || sections.contains(\"metsHdr\"))\n            {\n                renderHeader();\n            }\n    \t\tif (all || sections.contains(\"dmdSec\"))\n            {\n                renderDescriptiveSection();\n            }\n    \t\tif (all || sections.contains(\"amdSec\"))\n            {\n                renderAdministrativeSection();\n            }\n    \t\tif (all || sections.contains(\"fileSec\"))\n            {\n                renderFileSection(context);\n            }\n    \t\tif (all || sections.contains(\"structMap\"))\n            {\n                renderStructureMap();\n            }\n    \t\tif (all || sections.contains(\"structLink\"))\n            {\n                renderStructuralLink();\n            }\n    \t\tif (all || sections.contains(\"behaviorSec\"))\n            {\n                renderBehavioralSection();\n            }\n    \t\t\n    \t\t// FIXME: this is not a met's section, it should be removed\n    \t\tif (all || sections.contains(\"extraSec\"))\n            {\n                renderExtraSections();\n            }\n    \t\t\n    \t\tendElement(METS,\"METS\");\n    \t\tcontentHandler.endPrefixMapping(\"mets\");\n    \t\tcontentHandler.endPrefixMapping(\"xlink\");\n    \t\tcontentHandler.endPrefixMapping(\"dim\");\n    \t\tnamespaces.popContext();\n\n    }\n\t\n    /*\n     * Each of the METS sections\n     */\n\tprotected void renderHeader() throws WingException, SAXException, CrosswalkException, IOException, SQLException  {}\n\tprotected void renderDescriptiveSection() throws WingException, SAXException, CrosswalkException, IOException, SQLException  {}\n\tprotected void renderAdministrativeSection() throws WingException, SAXException, CrosswalkException, IOException, SQLException  {}\n\tprotected void renderFileSection(Context context) throws WingException, SAXException, CrosswalkException, IOException, SQLException  {}\n\tprotected void renderStructureMap() throws WingException, SAXException, CrosswalkException, IOException, SQLException  {}\n\tprotected void renderStructuralLink() throws WingException, SAXException, CrosswalkException, IOException, SQLException  {}\n\tprotected void renderBehavioralSection() throws WingException, SAXException, CrosswalkException, IOException, SQLException  {}\n\tprotected void renderExtraSections() throws WingException, SAXException, CrosswalkException, SQLException, IOException {}\n    \n\n\n    /**\n     * Generate a METS file element for a given bitstream.\n     *\n     * @param context\n     *            Session context.\n     * @param item\n     *            If the bitstream is associated with an item provide the item\n     *            otherwise leave null.\n     * @param bitstream\n     *            The bitstream to build a file element for.\n     * @param fileID\n     *            The unique file id for this file.\n     * @param groupID\n     *            The group id for this file, if it is derived from another file\n     *            then they should share the same groupID.\n     * @throws org.xml.sax.SAXException passed through.\n     * @throws java.sql.SQLException passed through.\n     */\n\tprotected final void renderFile(Context context, Item item, Bitstream bitstream, String fileID, String groupID)\n            throws SAXException, SQLException\n    {\n       renderFile(context, item, bitstream, fileID, groupID, null);\n    }\n\n\t/**\n     * Generate a METS file element for a given bitstream.\n     *\n     * @param context\n     *            session context.\n     * @param item\n     *            If the bitstream is associated with an item, provide the item,\n     *            otherwise leave null.\n     * @param bitstream\n     *            The bitstream to build a file element for.\n     * @param fileID\n     *            The unique file id for this file.\n     * @param groupID\n     *            The group id for this file, if it is derived from another file\n     *            then they should share the same groupID.\n     * @param admID\n     *            The IDs of the administrative metadata sections which pertain\n     *            to this file\n     * @throws org.xml.sax.SAXException passed through.\n     * @throws java.sql.SQLException passed through.\n     */\n\tprotected final void renderFile(Context context, Item item,\n            Bitstream bitstream, String fileID, String groupID, String admID)\n            throws SAXException, SQLException\n    {\n\t\tAttributeMap attributes;\n\t\t\n\t\t// //////////////////////////////\n    \t// Determine the file attributes\n        BitstreamFormat format = bitstream.getFormat(context);\n        String mimeType = null;\n        if (format != null)\n        {\n            mimeType = format.getMIMEType();\n        }\n        String checksumType = bitstream.getChecksumAlgorithm();\n        String checksum = bitstream.getChecksum();\n        long size = bitstream.getSizeBytes();\n    \t\n        // ////////////////////////////////\n        // Start the actual file\n        attributes = new AttributeMap();\n        attributes.put(\"ID\", fileID);\n        attributes.put(\"GROUPID\",groupID);\n        if (admID != null && admID.length()>0)\n        {\n            attributes.put(\"ADMID\", admID);\n        }\n        if (mimeType != null && mimeType.length()>0)\n        {\n            attributes.put(\"MIMETYPE\", mimeType);\n        }\n        if (checksumType != null && checksum != null)\n        {\n        \tattributes.put(\"CHECKSUM\", checksum);\n        \tattributes.put(\"CHECKSUMTYPE\", checksumType);\n        }\n        attributes.put(\"SIZE\", String.valueOf(size));\n        startElement(METS,\"file\",attributes);\n        \n        \n        // ////////////////////////////////////\n        // Determine the file location attributes\n        String name = bitstream.getName();\n        String description = bitstream.getDescription();\n\n        \n        // If possible, reference this bitstream via a handle, however this may\n        // be null if a handle has not yet been assigned. In this case reference the\n        // item its internal id. In the last case where the bitstream is not associated\n        // with an item (such as a community logo) then reference the bitstreamID directly.\n        String identifier = null;\n        if (item != null && item.getHandle() != null)\n        {\n            identifier = \"handle/\" + item.getHandle();\n        }\n        else if (item != null)\n        {\n            identifier = \"item/\" + item.getID();\n        }\n        else\n        {\n            identifier = \"id/\" + bitstream.getID();\n        }\n        \n        \n        String url = contextPath + \"/bitstream/\"+identifier+\"/\";\n        \n        // If we can, append the pretty name of the bitstream to the URL\n        try\n        {\n        \tif (bitstream.getName() != null)\n            {\n                url += Util.encodeBitstreamName(bitstream.getName(), \"UTF-8\");\n            }\n        }\n        catch (UnsupportedEncodingException uee)\n        {\n            // just ignore it, we don't have to have a pretty\n            // name at the end of the URL because the sequence id will \n        \t// locate it. However it means that links in this file might\n        \t// not work....\n        }\n        \n        url += \"?sequence=\"+bitstream.getSequenceID();\n        \n        \n        // //////////////////////\n        // Start the file location\n        attributes = new AttributeMap();\n        AttributeMap attributesXLINK = new AttributeMap();\n        attributesXLINK.setNamespace(XLINK);\n        attributes.put(\"LOCTYPE\", \"URL\");\n        attributesXLINK.put(\"type\",\"locator\");\n        attributesXLINK.put(\"title\", name);\n        if (description != null)\n        {\n            attributesXLINK.put(\"label\", description);\n        }\n        attributesXLINK.put(\"href\", url);\n        startElement(METS,\"FLocat\",attributes,attributesXLINK);\n        \n\n        // ///////////////////////\n        // End file location\n        endElement(METS,\"FLocate\");\n        \n        // ////////////////////////////////\n        // End the file\n        endElement(METS,\"file\");\n\t}\n\t\n\t\n\t/**\n     * \n     * Generate a unique METS id. For consistency, all prefixes should probably\n     * end in an underscore, \"_\".\n     * \n     * @param prefix\n     *            Prefix to prepend to the id for readability.\n     * \n     * @return A unique METS id.\n     */\n    protected final String getGenericID(String prefix)\n    {\n        return prefix + (idSequence++);\n    }\n    \n    /**\n     * Return a dissemination crosswalk for the given name.\n     * \n     * @param crosswalkName name of crosswalk plugin to be looked up.\n     * @return The crosswalk.\n     * @throws org.dspace.app.xmlui.wing.WingException if crosswalk not found.\n     */\n    public final DisseminationCrosswalk getDisseminationCrosswalk(String crosswalkName) throws WingException \n    {\n    \t// FIXME add some caching here\n    \tDisseminationCrosswalk crosswalk\n                = (DisseminationCrosswalk) CoreServiceFactory.getInstance()\n                        .getPluginService()\n                        .getNamedPlugin(DisseminationCrosswalk.class, crosswalkName);\n\n\t    if (crosswalk == null)\n        {\n            throw new WingException(\"Unable to find named DisseminationCrosswalk: \" + crosswalkName);\n        }\n\t    \n\t    return crosswalk;\n    }\n    \n    /** \n     * The METS defined types of Metadata, if a format is not listed here \n     * then it should use the string \"OTHER\" and provide additional \n     * attributes describing the metadata type \n     */\n    public static final String[] METS_DEFINED_TYPES = \n    \t{\"MARC\",\"MODS\",\"EAD\",\"DC\",\"NISOIMG\",\"LC-AV\",\"VRA\",\"TEIHDR\",\"DDI\",\"FGDC\",\"PREMIS\"/*,\"OTHER\"*/};\n    \n    /**\n     * Determine if the provided metadata type is a standard METS\n     * defined type. If it is not, use the other string.\n     * \n     * @param metadataType type name\n     * @return True if METS defined\n     */\n    public final boolean isDefinedMETStype(String metadataType)\n    {\n       for (String definedType : METS_DEFINED_TYPES)\n       {\n           if (definedType.equals(metadataType))\n           {\n               return true;\n           }\n       }\n       return false;\n    }\n    \n    /**\n     * Check if the current user is allowed to read the contents\n     * of the adapter.\n     *\n     * @return True if the user has sufficient permissions\n     * @throws SQLException passed through.\n     */\n    abstract public boolean isAuthorized() throws SQLException;\n    \n    \n    \n    \n    /**\n\t * \n\t * \n\t * SAX Helper methods\n\t * \n\t * \n\t *\n\t */\n\t\n\t/**\n     * Send the SAX events to start this element.\n     * \n     * @param namespace\n     *            (Required) The namespace of this element.\n     * @param name\n     *            (Required) The local name of this element.\n     * @param attributes\n     *            (May be null) Attributes for this element\n     * @throws org.xml.sax.SAXException passed through.\n     */\n    protected final void startElement(Namespace namespace, String name,\n            AttributeMap... attributes) throws SAXException\n    {\n        contentHandler.startElement(namespace.URI, name, qName(namespace, name),\n                map2sax(namespace,attributes));\n    }\n\n    /**\n     * Send the SAX event for these plain characters, not wrapped in any\n     * elements.\n     * \n     * @param characters\n     *            (May be null) Characters to send.\n     * @throws org.xml.sax.SAXException passed through.\n     */\n    protected final void sendCharacters(String characters) throws SAXException\n    {\n        if (characters != null)\n        {\n            char[] contentArray = characters.toCharArray();\n            contentHandler.characters(contentArray, 0, contentArray.length);\n        }\n    }\n    \n    /**\n     * Send the SAX events to end this element.\n     * \n     * @param namespace\n     *            (Required) The namespace of this element.\n     * @param name\n     *            (Required) The local name of this element.\n     * @throws org.xml.sax.SAXException passed through.\n     */\n    protected final void endElement(Namespace namespace, String name)\n            throws SAXException\n    {\n        contentHandler.endElement(namespace.URI, name, qName(namespace, name));\n    }\n\n    /**\n     * Build the SAX attributes object based upon Java's String map. This\n     * convenience method will build, or add to an existing attributes object,\n     * the attributes detailed in the AttributeMap.\n     * \n     * @param elementNamespace\n     *            SAX Helper class to keep track of namespaces able to determine\n     *            the correct prefix for a given namespace URI.\n     * @param attributes\n     *            An existing SAX AttributesImpl object to add attributes to.\n     *            If the value is null then a new attributes object will be\n     *            created to house the attributes.\n     * @param attributeMap\n     *            A map of attributes and values.\n     * @return\n     */\n    private AttributesImpl map2sax(Namespace elementNamespace, AttributeMap ... attributeMaps)\n    {\n\n        AttributesImpl attributes = new AttributesImpl();\n        for (AttributeMap attributeMap : attributeMaps)\n        {\n            boolean differentNamespaces = false;\n            Namespace attributeNamespace = attributeMap.getNamespace();\n            if (attributeNamespace != null && !(attributeNamespace.URI.equals(elementNamespace.URI)))\n            {\n                differentNamespaces = true;\n            }\n\n            // copy each one over.\n            for (Map.Entry<String, String> attr : attributeMap.entrySet())\n            {\n                if (attr.getValue() == null)\n                {\n                    continue;\n                }\n\n                if (differentNamespaces)\n                {\n                    attributes.addAttribute(attributeNamespace.URI, attr.getKey(),\n                            qName(attributeNamespace, attr.getKey()), \"CDATA\", attr.getValue());\n\n                }\n                else\n                {\n                    attributes.addAttribute(\"\", attr.getKey(), attr.getKey(), \"CDATA\", attr.getValue());\n                }\n            }\n        }\n        return attributes;\n    }\n    \n    /**\n     * Create the qName for the element with the given localName and namespace\n     * prefix.\n     * \n     * @param namespace\n     *            (May be null) The namespace prefix.\n     * @param localName\n     *            (Required) The element's local name.\n     * @return\n     */\n    private String qName(Namespace namespace, String localName)\n    {\n    \tString prefix = namespaces.getPrefix(namespace.URI);\n        if (prefix == null || prefix.equals(\"\"))\n        {\n            return localName;\n        }\n        else\n        {\n            return prefix + \":\" + localName;\n        }\n    }\n    \n}\n", "/**\n * The contents of this file are subject to the license and copyright\n * detailed in the LICENSE and NOTICE files at the root of the source\n * tree and available online at\n *\n * http://www.dspace.org/license/\n */\npackage org.dspace.app.xmlui.objectmanager;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.sql.SQLException;\n\nimport org.apache.log4j.Logger;\nimport org.dspace.app.xmlui.wing.AttributeMap;\nimport org.dspace.app.xmlui.wing.WingException;\nimport org.dspace.authorize.AuthorizeException;\nimport org.dspace.browse.ItemCounter;\nimport org.dspace.browse.ItemCountException;\nimport org.dspace.content.Bitstream;\nimport org.dspace.content.Collection;\nimport org.dspace.content.Community;\nimport org.dspace.content.DSpaceObject;\nimport org.dspace.content.crosswalk.CrosswalkException;\nimport org.dspace.content.crosswalk.DisseminationCrosswalk;\nimport org.dspace.content.factory.ContentServiceFactory;\nimport org.dspace.content.service.CollectionService;\nimport org.dspace.content.service.CommunityService;\nimport org.dspace.services.factory.DSpaceServicesFactory;\nimport org.dspace.core.Constants;\nimport org.dspace.core.Context;\nimport org.dspace.handle.factory.HandleServiceFactory;\nimport org.dspace.handle.service.HandleService;\nimport org.jdom.Document;\nimport org.jdom.Element;\nimport org.jdom.JDOMException;\nimport org.jdom.input.SAXBuilder;\nimport org.jdom.output.SAXOutputter;\nimport org.xml.sax.SAXException;\n\n/**\n * This is an adapter which translates DSpace containers \n * (communities and collections) into METS documents. This adapter follows\n * the DSpace METS profile, however that profile does not define how a\n * community or collection should be described, but we make the obvious \n * decisions to deviate when necessary from the profile.\n * \n * The METS document consists of three parts: descriptive metadata section,\n * file section, and a structural map. The descriptive metadata sections holds\n * metadata about the item being adapted using DSpace crosswalks. This is the \n * same way the item adapter works.\n * \n * However, the file section and structural map are a bit different. In these\n * cases the the only files listed is the one logo that may be attached to \n * a community or collection.\n * \n * @author Scott Phillips\n */\npublic class ContainerAdapter extends AbstractAdapter\n{\n    private static final Logger log = Logger.getLogger(ContainerAdapter.class);\n\n    /** The community or collection this adapter represents. */\n    private final DSpaceObject dso;\n\n    /** A space-separated list of descriptive metadata sections */\n    private StringBuffer dmdSecIDS;\n    \n    /** Current DSpace context **/\n    private final Context dspaceContext;\n\n    protected CommunityService communityService = ContentServiceFactory.getInstance().getCommunityService();\n   \tprotected CollectionService collectionService = ContentServiceFactory.getInstance().getCollectionService();\n   \tprotected HandleService handleService = HandleServiceFactory.getInstance().getHandleService();\n    \n    \n    /**\n     * Construct a new CommunityCollectionMETSAdapter.\n     * \n     * @param context session context.\n     * @param dso\n     *            A DSpace Community or Collection to adapt.\n     * @param contextPath\n     *            The contextPath of this webapplication.\n     */\n    public ContainerAdapter(Context context, DSpaceObject dso,String contextPath)\n    {\n        super(contextPath);\n        this.dso = dso;\n        this.dspaceContext = context;\n    }\n\n    /** Return the container, community or collection, object\n     * @return the contained object.\n     */\n    public DSpaceObject getContainer()\n    {\n    \treturn this.dso;\n    }\n    \n    /**\n     * \n     * \n     * \n     * Required abstract methods\n     * \n     * \n     * \n     */\n    \n    /**\n     * @return the URL of this community/collection in the interface.\n     */\n    @Override\n    protected String getMETSOBJID()\n    {\n    \tif (dso.getHandle() != null)\n        {\n            return contextPath + \"/handle/\" + dso.getHandle();\n        }\n    \treturn null;\n    }\n\n    /**\n     * @return Return the URL for editing this item\n     */\n    @Override\n    protected String getMETSOBJEDIT()\n    {\n        return null;\n    }\n    \n    /**\n     * Use the handle as the id for this METS document.\n     * @return the id.\n     */\n    @Override\n    protected String getMETSID()\n    {\n    \tif (dso.getHandle() == null)\n    \t{\n        \tif (dso instanceof Collection)\n            {\n                return \"collection:\" + dso.getID();\n            }\n        \telse\n            {\n                return \"community:\" + dso.getID();\n            }\n    \t}\n        else\n        {\n            return \"hdl:\" + dso.getHandle();\n        }\n    }\n\n    /**\n     * Return the profile to use for communities and collections.\n     * \n     * @return the constant profile name.\n     * @throws org.dspace.app.xmlui.wing.WingException never.\n     */\n    @Override\n    protected String getMETSProfile() throws WingException\n    {\n    \treturn \"DSPACE METS SIP Profile 1.0\";\n    }\n\n    /**\n     * @return a friendly label for the METS document to say we are a community\n     * or collection.\n     */\n    @Override\n    protected String getMETSLabel()\n    {\n        if (dso instanceof Community)\n        {\n            return \"DSpace Community\";\n        }\n        else\n        {\n            return \"DSpace Collection\";\n        }\n    }\n\n    /**\n     * @param bitstream the bitstream to be identified.\n     * @return a unique id for the given bitstream.\n     */\n    protected String getFileID(Bitstream bitstream)\n    {\n        return \"file_\" + bitstream.getID();\n    }\n\n    /**\n     * @param bitstream the bitstream to be queried.\n     * @return a group id for the given bitstream.\n     */\n    protected String getGroupFileID(Bitstream bitstream)\n    {\n        return \"group_file_\" + bitstream.getID();\n    }\n\n\n    \n    \n    /**\n     * \n     * \n     * \n     * METS structural methods\n     * \n     * \n     * \n     */\n\n    \n    \n    /**\n     * Render the METS descriptive section. This will create a new metadata\n     * section for each crosswalk configured.\n     * \n     * <p>Example:\n     *\n     * <pre>{@code\n     * <dmdSec>\n     *  <mdWrap MDTYPE=\"MODS\">\n     *    <xmlData>\n     *      ... content from the crosswalk ...\n     *    </xmlDate>\n     *  </mdWrap>\n     * </dmdSec>\n     * } </pre>\n     * @throws org.dspace.app.xmlui.wing.WingException on XML errors.\n     * @throws org.xml.sax.SAXException passed through.\n     * @throws org.dspace.content.crosswalk.CrosswalkException passed through.\n     * @throws java.io.IOException if items could not be counted.\n     * @throws java.sql.SQLException passed through.\n     */\n    @Override\n    protected void renderDescriptiveSection() throws WingException, SAXException, CrosswalkException, IOException, SQLException \n    {\n        AttributeMap attributes;\n        \n        String groupID = getGenericID(\"group_dmd_\");\n        dmdSecIDS = new StringBuffer();\n\n        // Add DIM descriptive metadata if it was requested or if no metadata types \n        // were specified. Furthermore, since this is the default type we also use a \n        // faster rendering method that the crosswalk API.\n        if(dmdTypes.isEmpty() || dmdTypes.contains(\"DIM\"))\n        {\n            // Metadata element's ID\n            String dmdID = getGenericID(\"dmd_\");\n            \n            // Keep track of all descriptive sections\n            dmdSecIDS.append(dmdID);\n            \n            \n            // ////////////////////////////////\n            // Start a new dmdSec for each crosswalk.\n            attributes = new AttributeMap();\n            attributes.put(\"ID\", dmdID);\n            attributes.put(\"GROUPID\", groupID);\n            startElement(METS,\"dmdSec\",attributes);\n            \n            // ////////////////////////////////\n            // Start metadata wrapper\n            attributes = new AttributeMap();\n            attributes.put(\"MDTYPE\", \"OTHER\");\n            attributes.put(\"OTHERMDTYPE\", \"DIM\");\n            startElement(METS,\"mdWrap\",attributes);\n\n            // ////////////////////////////////\n            // Start the xml data\n            startElement(METS,\"xmlData\");\n            \n            \n            // ///////////////////////////////\n            // Start the DIM element\n            attributes = new AttributeMap();\n            attributes.put(\"dspaceType\", Constants.typeText[dso.getType()]);\n            startElement(DIM,\"dim\",attributes);\n\n            // Add each field for this collection\n            if (dso.getType() == Constants.COLLECTION) \n            {\n                Collection collection = (Collection) dso;\n                \n                String description = collectionService.getMetadata(collection, \"introductory_text\");\n                String description_abstract = collectionService.getMetadata(collection, \"short_description\");\n                String description_table = collectionService.getMetadata(collection, \"side_bar_text\");\n                String identifier_uri = handleService.getCanonicalPrefix() + collection.getHandle();\n                String provenance = collectionService.getMetadata(collection, \"provenance_description\");\n                String rights = collectionService.getMetadata(collection, \"copyright_text\");\n                String rights_license = collectionService.getMetadata(collection, \"license\");\n                String title = collectionService.getMetadata(collection, \"name\");\n                \n                createField(\"dc\",\"description\",null,null,description);\n                createField(\"dc\",\"description\",\"abstract\",null,description_abstract);\n                createField(\"dc\",\"description\",\"tableofcontents\",null,description_table);\n                createField(\"dc\",\"identifier\",\"uri\",null,identifier_uri);\n                createField(\"dc\",\"provenance\",null,null,provenance);\n                createField(\"dc\",\"rights\",null,null,rights);\n                createField(\"dc\",\"rights\",\"license\",null,rights_license);\n                createField(\"dc\",\"title\",null,null,title);\n                \n                boolean showCount = DSpaceServicesFactory.getInstance().getConfigurationService().getBooleanProperty(\"webui.strengths.show\");\n                 \n                if (showCount)\n                {\n                    try\n                    {\t// try to determine Collection size (i.e. # of items)\n                        int size = new ItemCounter(this.dspaceContext).getCount(collection);\n                        createField(\"dc\",\"format\",\"extent\",null, String.valueOf(size)); \n                    }\n                    catch (ItemCountException e)\n                    {\n                        throw new IOException(\"Could not obtain Collection item count\", e);\n                    }\n                }\n            } \n            else if (dso.getType() == Constants.COMMUNITY) \n            {\n                Community community = (Community) dso;\n                \n                String description = communityService.getMetadata(community, \"introductory_text\");\n                String description_abstract = communityService.getMetadata(community, \"short_description\");\n                String description_table = communityService.getMetadata(community, \"side_bar_text\");\n                String identifier_uri = handleService.getCanonicalPrefix() + community.getHandle();\n                String rights = communityService.getMetadata(community, \"copyright_text\");\n                String title = communityService.getMetadata(community, \"name\");\n                \n                createField(\"dc\",\"description\",null,null,description);\n                createField(\"dc\",\"description\",\"abstract\",null,description_abstract);\n                createField(\"dc\",\"description\",\"tableofcontents\",null,description_table);\n                createField(\"dc\",\"identifier\",\"uri\",null,identifier_uri);\n                createField(\"dc\",\"rights\",null,null,rights);\n                createField(\"dc\",\"title\",null,null,title);\n                \n                boolean showCount = DSpaceServicesFactory.getInstance().getConfigurationService().getBooleanProperty(\"webui.strengths.show\");\n        \t\t\n                if (showCount)\n                {\n                    try\n                    {\t// try to determine Community size (i.e. # of items)\n                        int size = new ItemCounter(this.dspaceContext).getCount(community);\n                        createField(\"dc\",\"format\",\"extent\",null, String.valueOf(size)); \n                    }\n                    catch (ItemCountException e)\n                    {\n                        throw new IOException(\"Could not obtain Collection item count\", e);\n                    }\n                }\n            }\n            \n            // ///////////////////////////////\n            // End the DIM element\n            endElement(DIM,\"dim\");\n            \n            // ////////////////////////////////\n            // End elements\n            endElement(METS,\"xmlData\");\n            endElement(METS,\"mdWrap\");\n            endElement(METS, \"dmdSec\");\n          \n        }\n        \n    \tfor (String dmdType : dmdTypes)\n    \t{\n    \t\t// If DIM was requested then it was generated above without using\n    \t\t// the crosswalk API. So we can skip this one.\n    \t\tif (\"DIM\".equals(dmdType))\n            {\n                continue;\n            }\n    \t\t\n    \t\tDisseminationCrosswalk crosswalk = getDisseminationCrosswalk(dmdType);\n    \t\t\n    \t\tif (crosswalk == null)\n            {\n                continue;\n            }\n    \t\t\n        \tString dmdID = getGenericID(\"dmd_\");\n\t   \t\t// Add our id to the list.\n            dmdSecIDS.append(\" \").append(dmdID);\n\n            // ////////////////////////////////\n            // Start a new dmdSec for each crosswalk.\n            attributes = new AttributeMap();\n            attributes.put(\"ID\", dmdID);\n            attributes.put(\"GROUPID\", groupID);\n            startElement(METS,\"dmdSec\",attributes);\n            \n            // ////////////////////////////////\n            // Start metadata wrapper\n            attributes = new AttributeMap();\n            if (isDefinedMETStype(dmdType))\n            {\n            \tattributes.put(\"MDTYPE\", dmdType);\n            }\n            else\n            {\n            \tattributes.put(\"MDTYPE\", \"OTHER\");\n            \tattributes.put(\"OTHERMDTYPE\", dmdType);\n            }\n            startElement(METS,\"mdWrap\",attributes);\n\n            // ////////////////////////////////\n            // Start the xml data\n            startElement(METS,\"xmlData\");\n            \n            // ///////////////////////////////\n            // Send the actual XML content\n            try {\n\t    \t\tElement dissemination = crosswalk.disseminateElement(dspaceContext, dso);\n\t\n\t    \t\tSAXFilter filter = new SAXFilter(contentHandler, lexicalHandler, namespaces);\n\t    \t\t// Allow the basics for XML\n\t    \t\tfilter.allowElements().allowIgnorableWhitespace().allowCharacters().allowCDATA().allowPrefixMappings();\n\t    \t\t\n\t            SAXOutputter outputter = new SAXOutputter();\n\t            outputter.setContentHandler(filter);\n\t            outputter.setLexicalHandler(filter);\n\t\t\t\toutputter.output(dissemination);\n\t\t\t} \n            catch (JDOMException jdome) \n\t\t\t{\n\t\t\t\tthrow new WingException(jdome);\n\t\t\t}\n\t\t\tcatch (AuthorizeException ae)\n\t\t\t{\n\t\t\t\t// just ignore the authorize exception and continue on\n\t\t\t\t// without parsing the xml document.\n\t\t\t}\n    \t\t\n            \n            // ////////////////////////////////\n            // End elements\n            endElement(METS,\"xmlData\");\n            endElement(METS,\"mdWrap\");\n            endElement(METS, \"dmdSec\");\n            \n            \n            // Record keeping\n            if (dmdSecIDS == null)\n            {\n                dmdSecIDS = new StringBuffer(dmdID);\n            }\n            else\n            {\n                dmdSecIDS.append(\" \").append(dmdID);\n\n            }\n        }\n    }\n\n    /**\n     * Render the METS file section. If a logo is present for this\n     * container then that single bitstream is listed in the \n     * file section.\n     *\n     * <p>Example:\n     *\n     * <pre>{@code\n     * <fileSec>\n     *   <fileGrp USE=\"LOGO\">\n     *     <file ... >\n     *       <fLocate ... >\n     *     </file>\n     *   </fileGrp>\n     * </fileSec>\n     * }</pre>\n     * @param context session context.\n     * @throws org.xml.sax.SAXException passed through.\n     * @throws java.sql.SQLException passed through.\n     */\n    @Override\n    protected void renderFileSection(Context context) throws SAXException, SQLException\n    {\n    \tAttributeMap attributes;\n    \t\n        // Get the Community or Collection logo.\n        Bitstream logo = getLogo();\n\n        if (logo != null)\n        {\n            // ////////////////////////////////\n            // Start the file section\n        \tstartElement(METS,\"fileSec\");\n\n            // ////////////////////////////////\n            // Start a new fileGrp for the logo.\n            attributes = new AttributeMap();\n            attributes.put(\"USE\", \"LOGO\");\n            startElement(METS,\"fileGrp\",attributes);\n            \n            // ////////////////////////////////\n            // Add the actual file element\n            String fileID = getFileID(logo);\n            String groupID = getGroupFileID(logo);\n            renderFile(context, null, logo, fileID, groupID);\n            \n            // ////////////////////////////////\n            // End th file group and file section\n            endElement(METS,\"fileGrp\");\n            endElement(METS,\"fileSec\");\n        }\n    }\n\n    /**\n     * Render the container's structural map. This includes a reference\n     * to the container's logo, if available, otherwise it is an empty \n     * division that just states it is a DSpace community or Collection.\n     * \n     * <p>Example:\n     *\n     * <pre>{@code\n     * <structMap TYPE=\"LOGICAL\" LABEL=\"DSpace\">\n     *   <div TYPE=\"DSpace Collection\" DMDID=\"space-separated list of ids\">\n     *     <fptr FILEID=\"logo id\"/>\n     *   </div>\n     * </structMap>\n     * }</pre>\n     * @throws java.sql.SQLException passed through.\n     * @throws org.xml.sax.SAXException passed through.\n     */\n    @Override\n    protected void renderStructureMap() throws SQLException, SAXException\n    {\n    \tAttributeMap attributes;\n    \t\n    \t// ///////////////////////\n    \t// Start a new structure map\n    \tattributes = new AttributeMap();\n    \tattributes.put(\"TYPE\", \"LOGICAL\");\n    \tattributes.put(\"LABEL\", \"DSpace\");\n    \tstartElement(METS,\"structMap\",attributes);\n\n    \t// ////////////////////////////////\n    \t// Start the special first division\n    \tattributes = new AttributeMap();\n    \tattributes.put(\"TYPE\", getMETSLabel());\n    \t// add references to the Descriptive metadata\n    \tif (dmdSecIDS != null)\n        {\n            attributes.put(\"DMDID\", dmdSecIDS.toString());\n        }\n    \tstartElement(METS,\"div\",attributes);\n    \t\n    \t\n    \t// add a fptr pointer to the logo.\n        Bitstream logo = getLogo();\n        if (logo != null)\n        {\n            // ////////////////////////////////\n            // Add a reference to the logo as the primary bitstream.\n            attributes = new AttributeMap();\n            attributes.put(\"FILEID\",getFileID(logo));\n            startElement(METS,\"fptr\",attributes);\n            endElement(METS,\"fptr\");\n        \n            \n            // ///////////////////////////////////////////////\n            // Add a div for the publicly viewable bitstreams (i.e. the logo)\n            attributes = new AttributeMap();\n            attributes.put(\"ID\", getGenericID(\"div_\"));\n            attributes.put(\"TYPE\", \"DSpace Content Bitstream\");\n            startElement(METS,\"div\",attributes);\n        \t\n            // ////////////////////////////////\n            // Add a reference to the logo as the primary bitstream.\n            attributes = new AttributeMap();\n            attributes.put(\"FILEID\",getFileID(logo));\n            startElement(METS,\"fptr\",attributes);\n            endElement(METS,\"fptr\");\n        \t\n            // //////////////////////////\n            // End the logo division\n            endElement(METS,\"div\");\n        }\n\n    \t// ////////////////////////////////\n    \t// End the special first division\n    \tendElement(METS,\"div\");\n    \t\n    \t// ///////////////////////\n    \t// End the structure map\n    \tendElement(METS,\"structMap\");\n    }\n    \n\n    /**\n     * \n     * \n     * \n     * Private helpful methods\n     * \n     * \n     * \n     */\n\n    /**\n     * Return the logo bitstream associated with this community or collection.\n     * If there is no logo then null is returned.\n     */\n    private Bitstream getLogo()\n    {\n        if (dso instanceof Community)\n        {\n            Community community = (Community) dso;\n            return community.getLogo();\n        }\n        else if (dso instanceof Collection)\n        {\n\n            Collection collection = (Collection) dso;\n            return collection.getLogo();\n        }\n        return null;\n    }\n    \n    /**\n     * Count how many occurrence there is of the given\n     * character in the given string.\n     * \n     * @param string The string value to be counted.\n     * @param character the character to count in the string.\n     */\n    private int countOccurences(String string, char character)\n    {\n    \tif (string == null || string.length() == 0)\n        {\n            return 0;\n        }\n    \t\n    \tint fromIndex = -1;\n        int count = 0;\n        \n        while (true)\n        {\n        \tfromIndex = string.indexOf('>', fromIndex+1);\n        \t\n        \tif (fromIndex == -1)\n            {\n                break;\n            }\n        \t\n        \tcount++;\n        }\n        \n        return count;\n    }\n    \n    /**\n     * Check if the given character sequence is located in the given\n     * string at the specified index. If it is then return true, otherwise false.\n     * \n     * @param string The string to test against\n     * @param index The location within the string\n     * @param characters The character sequence to look for.\n     * @return true if the character sequence was found, otherwise false.\n     */\n    private boolean substringCompare(String string, int index, char ... characters)\n    {\n    \t// Is the string long enough?\n    \tif (string.length() <= index + characters.length)\n        {\n            return false;\n        }\n    \t\n    \t// Do all the characters match?\n    \tfor (char character : characters)\n    \t{\n    \t\tif (string.charAt(index) != character)\n            {\n                return false;\n            }\n    \t\tindex++;\n    \t}\n    \t\n    \treturn false;\n    }\n    \n    /**\n     * Create a new DIM field element with the given attributes.\n     * \n     * @param schema The schema the DIM field belongs too.\n     * @param element The element the DIM field belongs too.\n     * @param qualifier The qualifier the DIM field belongs too.\n     * @param language The language the DIM field belongs too.\n     * @param value The value of the DIM field.\n     * @return A new DIM field element\n     * @throws SAXException \n     */\n    private void createField(String schema, String element, String qualifier, String language, String value) throws SAXException\n    {\n    \t// ///////////////////////////////\n    \t// Field element for each metadata field.\n    \tAttributeMap attributes = new AttributeMap();\n\t\tattributes.put(\"mdschema\",schema);\n\t\tattributes.put(\"element\", element);\n\t\tif (qualifier != null)\n        {\n            attributes.put(\"qualifier\", qualifier);\n        }\n\t\tif (language != null)\n        {\n            attributes.put(\"language\", language);\n        }\n\t\tstartElement(DIM,\"field\",attributes);\n\t\t\n\t\t// Only try and add the metadata value, but only if it is non-null.\n    \tif (value != null)\n    \t{\n    \t\t// First, perform a quick check to see if the value may be XML.\n\t        int countOpen = countOccurences(value,'<');\n\t        int countClose = countOccurences(value, '>');\n\t        \n\t        // If it passed the quick test, then try and parse the value.\n\t        Element xmlDocument = null;\n\t        if (countOpen > 0 && countOpen == countClose)\n\t        {\n\t        \t// This may be XML, First try and remove any bad entity references.\n\t        \tint amp = -1;\n\t        \twhile ((amp = value.indexOf('&', amp+1)) > -1)\n\t        \t{\n\t        \t\t// Is it an xml entity named by number?\n\t        \t\tif (substringCompare(value,amp+1,'#'))\n                    {\n                        continue;\n                    }\n\t        \t\t\n\t        \t\t// &amp;\n\t        \t\tif (substringCompare(value,amp+1,'a','m','p',';'))\n                    {\n                        continue;\n                    }\n\t        \t\t\n\t        \t\t// &apos;\n\t        \t\tif (substringCompare(value,amp+1,'a','p','o','s',';'))\n                    {\n                        continue;\n                    }\n\t        \t\t\n\t        \t\t// &quot;\n\t        \t\tif (substringCompare(value,amp+1,'q','u','o','t',';'))\n                    {\n                        continue;\n                    }\n\t        \t\t\t\n\t        \t\t// &lt;\n\t        \t\tif (substringCompare(value,amp+1,'l','t',';'))\n                    {\n                        continue;\n                    }\n\t        \t\t\n\t        \t\t// &gt;\n\t        \t\tif (substringCompare(value,amp+1,'g','t',';'))\n                    {\n                        continue;\n                    }\n\t        \t\t\n\t        \t\t// Replace the ampersand with an XML entity.\n\t        \t\tvalue = value.substring(0,amp) + \"&amp;\" + value.substring(amp+1);\n\t        \t}\n\t        \t\n\t        \t\n\t        \t// Second try and parse the XML into a mini-dom\n\t        \ttry {\n\t        \t\t// Wrap the value inside a root element (which will be trimed out \n\t        \t\t// by the SAX filter and set the default namespace to XHTML. \n\t\t        \tString xml = \"<?xml version='1.0' encoding='UTF-8'?><fragment xmlns=\\\"http://www.w3.org/1999/xhtml\\\">\"+value+\"</fragment>\";\n\n\t\t            ByteArrayInputStream inputStream = new ByteArrayInputStream(xml.getBytes(\"UTF-8\"));\n\t\t     \t   \n\t\t\t \t    SAXBuilder builder = new SAXBuilder();\n\t\t\t\t\tDocument document = builder.build(inputStream);\n\t\t\t\t\t\n\t\t\t\t\txmlDocument = document.getRootElement();\n\t        \t} \n\t        \tcatch (JDOMException | IOException e)\n\t\t\t\t{\n                    log.trace(\"Caught exception\", e);\n\t\t\t\t}\n\t        }\t\t\n\t\t\t\t\t\n\t        // Third, If we have xml, attempt to serialize the dom.\n\t        if (xmlDocument != null)\n\t        {\t\n\t        \tSAXFilter filter = new SAXFilter(contentHandler, lexicalHandler, namespaces);\n\t    \t\t// Allow the basics for XML\n\t    \t\tfilter.allowElements().allowIgnorableWhitespace().allowCharacters().allowCDATA().allowPrefixMappings();\n\t    \t\t// Special option, only allow elements below the second level to pass through. This\n\t    \t\t// will trim out the METS declaration and only leave the actual METS parts to be\n\t    \t\t// included.\n\t    \t\tfilter.allowElements(1);\n\t    \t\t\n\t            SAXOutputter outputter = new SAXOutputter();\n\t            outputter.setContentHandler(filter);\n\t            outputter.setLexicalHandler(filter);\n\t            try {\n\t            \toutputter.output(xmlDocument);\n\t            } \n\t            catch (JDOMException jdome)\n\t            {\n\t            \t// serialization failed so let's just fallback sending the plain characters.\n\t            \tsendCharacters(value);\n\t            }\n\t        }\n\t        else\n\t        {\n\t        \t// We don't have XML, so just send the plain old characters.\n\t        \tsendCharacters(value);\n\t        }\n    \t}\n        \n        // //////////////////////////////\n        // Close out field\n        endElement(DIM,\"field\");\n    }  \n\n    @Override\n    public boolean isAuthorized() throws SQLException\n    {\n        return authorizeService.authorizeActionBoolean(dspaceContext, dso, Constants.READ);\n    }\n}\n", "/**\n * The contents of this file are subject to the license and copyright\n * detailed in the LICENSE and NOTICE files at the root of the source\n * tree and available online at\n *\n * http://www.dspace.org/license/\n */\npackage org.dspace.app.xmlui.objectmanager;\n\nimport org.dspace.app.util.Util;\nimport org.dspace.app.util.factory.UtilServiceFactory;\nimport org.dspace.app.util.service.MetadataExposureService;\nimport org.dspace.app.xmlui.wing.AttributeMap;\nimport org.dspace.app.xmlui.wing.WingException;\nimport org.dspace.authorize.AuthorizeException;\nimport org.dspace.authorize.factory.AuthorizeServiceFactory;\nimport org.dspace.authorize.service.AuthorizeService;\nimport org.dspace.content.*;\nimport org.dspace.content.authority.Choices;\nimport org.dspace.content.crosswalk.CrosswalkException;\nimport org.dspace.content.crosswalk.DisseminationCrosswalk;\nimport org.dspace.content.factory.ContentServiceFactory;\nimport org.dspace.content.service.BitstreamService;\nimport org.dspace.content.service.BundleService;\nimport org.dspace.content.service.ItemService;\nimport org.dspace.services.factory.DSpaceServicesFactory;\nimport org.dspace.core.Constants;\nimport org.dspace.core.Context;\nimport org.jdom.Element;\nimport org.jdom.JDOMException;\nimport org.jdom.output.SAXOutputter;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.XMLReader;\nimport org.xml.sax.helpers.XMLReaderFactory;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.sql.SQLException;\nimport java.util.*;\n\n/**\n * This is an adapter which translates a DSpace item into a METS document\n * following the DSpace METS profile, err well mostly. At least if you use\n * the proper configuration it will be fully compliant with the profile,\n * however this adapter will allow you to configure it to be incorrect.\n *\n * <p>When we are configured to be non-compliant with the profile, the MET's\n * profile is changed to reflect the deviation. The DSpace profile states\n * that metadata should be given in MODS format. However, you can configure\n * this adapter to use any metadata crosswalk. When that case is detected we\n * change the profile to say that we are deviating from the standard profile\n * and it lists what metadata has been added.\n *\n * <p>There are four parts to an item's METS document: descriptive metadata,\n * file section, structural map, and extra sections.\n *\n * <p>Request item-support\n * <p>Original Concept, JSPUI version:    Universidade do Minho   at www.uminho.pt\n * <p>Sponsorship of XMLUI version:    Instituto Oceanogr\u00e1fico de Espa\u00f1a at www.ieo.es\n *\n * @author Scott Phillips\n * @author Ad\u00e1n Rom\u00e1n Ruiz at arvo.es (for request item support)\n */\n\npublic class ItemAdapter extends AbstractAdapter\n{\n    /** The item this METS adapter represents */\n    private final Item item;\n\n    /** List of bitstreams which should be publicly viewable */\n    private final List<Bitstream> contentBitstreams = new ArrayList<>();\n\n    /** The primary bitstream, or null if none specified */\n    private Bitstream primaryBitstream;\n\n    /** A space-separated list of descriptive metadata sections */\n    private StringBuffer dmdSecIDS;\n\n    /** A space-separated list of administrative metadata sections (for item)*/\n    private StringBuffer amdSecIDS;\n\n    /** A hashmap of all Files and their corresponding space separated list of\n        administrative metadata sections */\n    private final Map<String,StringBuffer> fileAmdSecIDs = new HashMap<>();\n\n    // DSpace DB context\n    private final Context context;\n\n    protected AuthorizeService authorizeService = AuthorizeServiceFactory.getInstance().getAuthorizeService();\n    protected ItemService itemService = ContentServiceFactory.getInstance().getItemService();\n    protected BundleService bundleService = ContentServiceFactory.getInstance().getBundleService();\n    protected BitstreamService bitstreamService = ContentServiceFactory.getInstance().getBitstreamService();\n    protected MetadataExposureService metadataExposureService = UtilServiceFactory.getInstance().getMetadataExposureService();\n\n\n    /**\n     * Construct a new ItemAdapter\n     *\n     * @param context\n     *            Session context.\n     * @param item\n     *            The DSpace item to adapt.\n     * @param contextPath\n     *            The context path for this web application.\n     */\n    public ItemAdapter(Context context, Item item,String contextPath)\n    {\n        super(contextPath);\n        this.item = item;\n        this.context = context;\n    }\n\n    /** @return the item. */\n    public Item getItem()\n    {\n        return this.item;\n    }\n\n\n\n    /**\n     *\n     *\n     *\n     * Required abstract methods\n     *\n     *\n     *\n     */\n\n    /**\n     * @return the URL of this item in the interface.\n     */\n    @Override\n    protected String getMETSOBJID()\n    {\n        if (item.getHandle() != null)\n        {\n            return contextPath + \"/handle/\" + item.getHandle();\n        }\n        return null;\n    }\n\n    /**\n     * @return the URL for editing this item\n     */\n    @Override\n    protected String getMETSOBJEDIT()\n    {\n        return contextPath+\"/admin/item?itemID=\" + item.getID();\n    }\n\n    /**\n     * @return the item's handle as the METS ID\n     */\n    @Override\n    protected String getMETSID()\n    {\n        if (item.getHandle() == null)\n        {\n            return \"item:\" + item.getID();\n        }\n        else\n        {\n            return \"hdl:\" + item.getHandle();\n        }\n    }\n\n    /**\n     * @return the official METS SIP Profile.\n     * @throws org.dspace.app.xmlui.wing.WingException never.\n     */\n    @Override\n    protected String getMETSProfile() throws WingException\n    {\n        return \"DSPACE METS SIP Profile 1.0\";\n    }\n\n    /**\n     * @return a helpful label that this is a DSpace Item.\n     */\n    @Override\n    protected String getMETSLabel()\n    {\n        return \"DSpace Item\";\n    }\n\n    /**\n     * @param bitstream a Bitstream.\n     * @return a unique id for a bitstream.\n     */\n    protected String getFileID(Bitstream bitstream)\n    {\n        return \"file_\" + bitstream.getID();\n    }\n\n    /**\n     * @param bitstream a Bitstream.\n     * @return a group id for a bitstream.\n     */\n    protected String getGroupFileID(Bitstream bitstream)\n    {\n        return \"group_file_\" + bitstream.getID();\n    }\n\n    /**\n     * @param admSecName section.\n     * @param mdType type.\n     * @param dso object.\n     * @return a techMD id for a bitstream.\n     */\n    protected String getAmdSecID(String admSecName, String mdType, DSpaceObject dso)\n    {\n        if (dso.getType() == Constants.BITSTREAM)\n        {\n            return admSecName + \"_\" + getFileID((Bitstream) dso) + \"_\" + mdType;\n        }\n        else\n        {\n            return admSecName + \"_\" + dso.getID() + \"_\" + mdType;\n        }\n    }\n\n    /**\n     * Render the METS descriptive section. This will create a new metadata\n     * section for each crosswalk configured. Furthermore, a special check\n     * has been added that will add MODS descriptive metadata if it is\n     * available in DSpace.\n     *\n     * <p>Example:\n     *\n     * <pre>{@code\n     * <dmdSec>\n     *  <mdWrap MDTYPE=\"MODS\">\n     *    <xmlData>\n     *      ... content from the crosswalk ...\n     *    </xmlDate>\n     *  </mdWrap>\n     * </dmdSec\n     * }</pre>\n     * @throws org.dspace.app.xmlui.wing.WingException on XML errors.\n     * @throws org.xml.sax.SAXException passed through.\n     * @throws org.dspace.content.crosswalk.CrosswalkException passed through.\n     * @throws java.io.IOException passed through.\n     * @throws java.sql.SQLException passed through.\n     */\n    @Override\n    protected void renderDescriptiveSection() throws WingException, SAXException, CrosswalkException, IOException, SQLException\n    {\n        AttributeMap attributes;\n        String groupID = getGenericID(\"group_dmd_\");\n        dmdSecIDS = new StringBuffer();\n\n        // Add DIM descriptive metadata if it was requested or if no metadata types\n        // were specified. Furthermore, since this is the default type we also use a\n        // faster rendering method that the crosswalk API.\n        if(dmdTypes.isEmpty() || dmdTypes.contains(\"DIM\"))\n        {\n                // Metadata element's ID\n                String dmdID = getGenericID(\"dmd_\");\n                // Keep track of all descriptive sections\n                dmdSecIDS.append(dmdID);\n\n                        ////////////////////////////////\n                        // Start a metadata wrapper\n                        attributes = new AttributeMap();\n                        attributes.put(\"ID\", dmdID);\n                        attributes.put(\"GROUPID\", groupID);\n                        startElement(METS, \"dmdSec\", attributes);\n\n                         ////////////////////////////////\n                        // Start a metadata wrapper\n                        attributes = new AttributeMap();\n                        attributes.put(\"MDTYPE\",\"OTHER\");\n                        attributes.put(\"OTHERMDTYPE\", \"DIM\");\n                        startElement(METS,\"mdWrap\",attributes);\n\n                        // ////////////////////////////////\n                        // Start the xml data\n                        startElement(METS,\"xmlData\");\n\n\n                        // ///////////////////////////////\n                        // Start the DIM element\n                        attributes = new AttributeMap();\n                        attributes.put(\"dspaceType\", Constants.typeText[item.getType()]);\n            if (item.isWithdrawn())\n            {\n                attributes.put(\"withdrawn\", \"y\");\n            }\n            startElement(DIM,\"dim\",attributes);\n\n                List<MetadataValue> dcvs = itemService.getMetadata(item, Item.ANY, Item.ANY, Item.ANY, Item.ANY);\n                for (MetadataValue dcv : dcvs)\n                {\n                    MetadataField metadataField = dcv.getMetadataField();\n                    if (!metadataExposureService.isHidden(context, dcv.getMetadataField().getMetadataSchema().getName(), metadataField.getElement(), metadataField.getQualifier())) {\n                        // ///////////////////////////////\n                        // Field element for each metadata field.\n                        attributes = new AttributeMap();\n                        attributes.put(\"mdschema\", metadataField.getMetadataSchema().getName());\n                        attributes.put(\"element\", metadataField.getElement());\n                        if (metadataField.getQualifier() != null) {\n                            attributes.put(\"qualifier\", metadataField.getQualifier());\n                        }\n                        if (dcv.getLanguage() != null) {\n                            attributes.put(\"language\", dcv.getLanguage());\n                        }\n                        if (dcv.getAuthority() != null || dcv.getConfidence() != Choices.CF_UNSET) {\n                            attributes.put(\"authority\", dcv.getAuthority());\n                            attributes.put(\"confidence\", Choices.getConfidenceText(dcv.getConfidence()));\n                        }\n                        startElement(DIM, \"field\", attributes);\n                        sendCharacters(dcv.getValue());\n                        endElement(DIM,\"field\");\n                }\n                }\n\n                // ///////////////////////////////\n                        // End the DIM element\n                        endElement(DIM,\"dim\");\n\n                // ////////////////////////////////\n                // End elements\n                endElement(METS,\"xmlData\");\n                endElement(METS,\"mdWrap\");\n                endElement(METS,\"dmdSec\");\n\n        }\n\n\n        // Add any extra crosswalks that may configured.\n        for (String dmdType : dmdTypes)\n        {\n                // If DIM was requested then it was generated above without using\n                // the crosswalk API. So we can skip this one.\n                if (\"DIM\".equals(dmdType))\n                {\n                    continue;\n                }\n\n                DisseminationCrosswalk crosswalk = getDisseminationCrosswalk(dmdType);\n\n                if (crosswalk == null)\n                {\n                    continue;\n                }\n\n                String dmdID = getGenericID(\"dmd_\");\n                // Add our id to the list.\n                dmdSecIDS.append(\" \").append(dmdID);\n\n                ////////////////////////////////\n                // Start a metadata wrapper\n                attributes = new AttributeMap();\n                attributes.put(\"ID\", dmdID);\n                attributes.put(\"GROUPID\", groupID);\n                startElement(METS, \"dmdSec\", attributes);\n\n                ////////////////////////////////\n                // Start a metadata wrapper\n                attributes = new AttributeMap();\n                if (isDefinedMETStype(dmdType))\n                {\n                        attributes.put(\"MDTYPE\", dmdType);\n                }\n                else\n                {\n                        attributes.put(\"MDTYPE\",\"OTHER\");\n                        attributes.put(\"OTHERMDTYPE\", dmdType);\n                }\n                startElement(METS,\"mdWrap\",attributes);\n\n                // ////////////////////////////////\n                // Start the xml data\n                startElement(METS,\"xmlData\");\n\n\n                // ///////////////////////////////\n                // Send the actual XML content\n                try {\n                        Element dissemination = crosswalk.disseminateElement(context, item);\n\n                        SAXFilter filter = new SAXFilter(contentHandler, lexicalHandler, namespaces);\n                        // Allow the basics for XML\n                        filter.allowElements().allowIgnorableWhitespace().allowCharacters().allowCDATA().allowPrefixMappings();\n\n                    SAXOutputter outputter = new SAXOutputter();\n                    outputter.setContentHandler(filter);\n                    outputter.setLexicalHandler(filter);\n                                outputter.output(dissemination);\n                        }\n            catch (JDOMException jdome)\n                        {\n                                throw new WingException(jdome);\n                        }\n                        catch (AuthorizeException ae)\n                        {\n                                // just ignore the authorize exception and continue on\n                                // without parsing the xml document.\n                        }\n\n\n            // ////////////////////////////////\n            // End elements\n            endElement(METS,\"xmlData\");\n            endElement(METS,\"mdWrap\");\n            endElement(METS,\"dmdSec\");\n        }\n\n\n        // Check to see if there is an in-line MODS document\n        // stored as a bitstream. If there is then we should also\n        // include these metadata in our METS document. However,\n        // we don't really know what the document describes, so we\n        // but it in its own dmd group.\n\n        Boolean include = DSpaceServicesFactory.getInstance().getConfigurationService().getBooleanProperty(\"xmlui.bitstream.mods\");\n        if (include && dmdTypes.contains(\"MODS\"))\n        {\n                // Generate a second group id for any extra metadata added.\n                String groupID2 = getGenericID(\"group_dmd_\");\n\n                List<Bundle> bundles = itemService.getBundles(item, \"METADATA\");\n                for (Bundle bundle : bundles)\n                {\n                        Bitstream bitstream = bundleService.getBitstreamByName(bundle, \"MODS.xml\");\n\n                        if (bitstream == null)\n                        {\n                            continue;\n                        }\n\n\n                        String dmdID = getGenericID(\"dmd_\");\n\n\n                        ////////////////////////////////\n                        // Start a metadata wrapper\n                        attributes = new AttributeMap();\n                        attributes.put(\"ID\", dmdID);\n                        attributes.put(\"GROUPID\", groupID2);\n                        startElement(METS, \"dmdSec\", attributes);\n\n                         ////////////////////////////////\n                        // Start a metadata wrapper\n                        attributes = new AttributeMap();\n                        attributes.put(\"MDTYPE\", \"MODS\");\n                        startElement(METS,\"mdWrap\",attributes);\n\n                        // ////////////////////////////////\n                        // Start the xml data\n                        startElement(METS,\"xmlData\");\n\n\n                        // ///////////////////////////////\n                        // Send the actual XML content\n\n                        SAXFilter filter = new SAXFilter(contentHandler, lexicalHandler, namespaces);\n                        // Allow the basics for XML\n                        filter.allowElements().allowIgnorableWhitespace().allowCharacters().allowCDATA().allowPrefixMappings();\n\n                        XMLReader reader = XMLReaderFactory.createXMLReader();\n                        reader.setContentHandler(filter);\n                        reader.setProperty(\"http://xml.org/sax/properties/lexical-handler\", filter);\n                        try {\n                                InputStream is = bitstreamService.retrieve(context, bitstream);\n                                reader.parse(new InputSource(is));\n                        }\n                        catch (AuthorizeException ae)\n                        {\n                                // just ignore the authorize exception and continue on\n                                // without parsing the xml document.\n                        }\n\n                        // ////////////////////////////////\n                    // End elements\n                    endElement(METS,\"xmlData\");\n                    endElement(METS,\"mdWrap\");\n                    endElement(METS, \"dmdSec\");\n                }\n        }\n\n    }\n\n    /**\n     * Render the METS administrative section.\n     *\n     * <p>Example:\n     *\n     * <pre>{@code\n     * <amdSec>\n     *  <mdWrap MDTYPE=\"OTHER\" OTHERMDTYPE=\"METSRights\">\n     *    <xmlData>\n     *      ... content from the crosswalk ...\n     *    </xmlDate>\n     *  </mdWrap>\n     * </amdSec>\n     * }</pre>\n     *\n     * @throws org.dspace.app.xmlui.wing.WingException passed through.\n     * @throws org.xml.sax.SAXException passed through.\n     * @throws org.dspace.content.crosswalk.CrosswalkException passed through.\n     * @throws java.io.IOException passed through.\n     * @throws java.sql.SQLException passed through.\n     */\n    @Override\n    protected void renderAdministrativeSection() throws WingException, SAXException, CrosswalkException, IOException, SQLException\n    {\n        AttributeMap attributes;\n        String groupID;\n\n        // Only create an <amdSec>, if we have amdTypes (or sub-sections) specified...\n        // (this keeps our METS file small, by default, and hides all our admin metadata)\n        if(amdTypes.size() > 0)\n        {\n          ////////////////////////////////\n          // Start an administrative wrapper\n\n          // Administrative element's ID\n          String amdID = getGenericID(\"amd_\");\n          attributes = new AttributeMap();\n          attributes.put(\"ID\", amdID);\n          startElement(METS, \"amdSec\", attributes);\n\n          groupID = getGenericID(\"group_amd_\");\n          attributes.put(\"GROUPID\", groupID);\n        }\n\n        // For each administrative metadata section specified\n        for (String amdSecName : amdTypes.keySet())\n        {\n          // get a list of metadata crosswalks which will be used to build\n          // this administrative metadata section\n          List<String> mdTypes = amdTypes.get(amdSecName);\n\n          // For each crosswalk\n          for (String mdType : mdTypes)\n          {\n            // get our dissemination crosswalk\n            DisseminationCrosswalk crosswalk = getDisseminationCrosswalk(mdType);\n\n            // skip, if we cannot find this crosswalk in config file\n            if (crosswalk == null)\n            {\n                continue;\n            }\n\n            // First, check if this crosswalk can handle disseminating Item-level Administrative metadata\n            if(crosswalk.canDisseminate(item))\n            {\n              // Since this crosswalk works with items, first render a section for entire item\n              renderAmdSubSection(amdSecName, mdType, crosswalk, item);\n            }\n\n            // Next, we'll try and render Bitstream-level administrative metadata\n            // (Although, we're only rendering this metadata for the bundles specified)\n            List<Bundle> bundles = findEnabledBundles();\n            for (Bundle bundle : bundles)\n            {\n              List<Bitstream> bitstreams = bundle.getBitstreams();\n\n              // Create a sub-section of <amdSec> for each bitstream in bundle\n              for(Bitstream bitstream : bitstreams)\n              {\n                 // Only render the section if crosswalk works with bitstreams\n                 if(crosswalk.canDisseminate(bitstream))\n                 {\n                    renderAmdSubSection(amdSecName, mdType, crosswalk, bitstream);\n                 }\n              } // end for each bitstream\n            } // end for each bundle\n          } // end for each crosswalk\n        } // end for each amdSec\n\n        if(amdTypes.size() > 0)\n        {\n          //////////////////////////////////\n          // End administrative section\n          endElement(METS,\"amdSec\");\n        }\n    }\n\n    /**\n     * Render a sub-section of the administrative metadata section.\n     * Valid sub-sections include: techMD, rightsMD, sourceMD, digiprovMD\n     *\n     * <p>Example:\n     *\n     * <pre>{@code\n     * <techMD>\n     *   <mdWrap MDTYPE=\"PREMIS\">\n     *     <xmlData>\n     *       [PREMIS content ... ]\n     *     </xmlData>\n     *   </mdWrap>\n     * </techMD>\n     * }</pre>\n     *\n     * @param amdSecName Name of administrative metadata section\n     * @param mdType Type of metadata section (e.g. PREMIS)\n     * @param crosswalk The DisseminationCrosswalk to use to generate this section\n     * @param dso The current DSpace object to use the crosswalk on\n     * @throws org.dspace.app.xmlui.wing.WingException on XML errors.\n     * @throws org.xml.sax.SAXException passed through.\n     * @throws org.dspace.content.crosswalk.CrosswalkException passed through.\n     * @throws java.io.IOException passed through.\n     * @throws java.sql.SQLException passed through.\n     */\n    protected void renderAmdSubSection(String amdSecName, String mdType, DisseminationCrosswalk crosswalk, DSpaceObject dso)\n            throws WingException, SAXException, CrosswalkException, IOException, SQLException\n    {\n        /////////////////////////////////\n        // Start administrative metadata section wrapper\n        String amdSecID = getAmdSecID(amdSecName, mdType, dso);\n        AttributeMap attributes = new AttributeMap();\n        attributes.put(\"ID\", amdSecID);\n        startElement(METS, amdSecName, attributes);\n\n        // If this is a bitstream\n        if (dso.getType() == Constants.BITSTREAM)\n        {\n          // Add this to our list of each file's administrative section IDs\n          String fileID = getFileID((Bitstream) dso);\n          if(fileAmdSecIDs.containsKey(fileID))\n          {\n              fileAmdSecIDs.get(fileID).append(\" \").append(amdSecID);\n          }\n          else\n          {\n              fileAmdSecIDs.put(fileID, new StringBuffer(amdSecID));\n          }\n        } // else if an Item\n        else if (dso.getType() == Constants.ITEM)\n        {\n           // Add this to our list of item's administrative section IDs\n           if(amdSecIDS==null)\n           {\n               amdSecIDS = new StringBuffer(amdSecID);\n           }\n           else\n           {\n               amdSecIDS.append(\" \").append(amdSecID);\n           }\n        }\n\n        ////////////////////////////////\n        // Start a metadata wrapper\n        attributes = new AttributeMap();\n        if (isDefinedMETStype(mdType))\n        {\n            attributes.put(\"MDTYPE\", mdType);\n        }\n        else\n        {\n            attributes.put(\"MDTYPE\",\"OTHER\");\n            attributes.put(\"OTHERMDTYPE\", mdType);\n        }\n        startElement(METS,\"mdWrap\",attributes);\n\n        //////////////////////////////////\n        // Start the xml data\n        startElement(METS,\"xmlData\");\n\n        /////////////////////////////////\n        // Send the actual XML content,\n        // using the PREMIS crosswalk for each bitstream\n        try {\n            Element dissemination = crosswalk.disseminateElement(context, dso);\n\n            SAXFilter filter = new SAXFilter(contentHandler, lexicalHandler, namespaces);\n            // Allow the basics for XML\n            filter.allowElements().allowIgnorableWhitespace().allowCharacters().allowCDATA().allowPrefixMappings();\n\n            SAXOutputter outputter = new SAXOutputter();\n            outputter.setContentHandler(filter);\n            outputter.setLexicalHandler(filter);\n            outputter.output(dissemination);\n        }\n        catch (JDOMException jdome)\n        {\n            throw new WingException(jdome);\n        }\n        catch (AuthorizeException ae)\n        {\n            // just ignore the authorize exception and continue on\n            // without parsing the xml document.\n        }\n\n        // ////////////////////////////////\n        // End elements\n        endElement(METS,\"xmlData\");\n        endElement(METS,\"mdWrap\");\n        endElement(METS,amdSecName);\n    }\n\n    /**\n     * Render the METS file section. This will contain a list of all bitstreams in the\n     * item. Each bundle, even those that are not typically displayed will be listed.\n     *\n     * <p>Example:\n     *\n     * <pre>{@code\n     * <fileSec>\n     *   <fileGrp USE=\"CONTENT\">\n     *     <file ... >\n     *       <fLocate ... >\n     *     </file>\n     *   </fileGrp>\n     *   <fileGrp USE=\"TEXT\">\n     *     <file ... >\n     *       <fLocate ... >\n     *     </file>\n     *   </fileGrp>\n     * </fileSec>\n     * }</pre>\n     *\n     * @param context session context.\n     * @throws java.sql.SQLException passed through.\n     * @throws org.xml.sax.SAXException passed through.\n     */\n    @Override\n    protected void renderFileSection(Context context) throws SQLException, SAXException\n    {\n        AttributeMap attributes;\n\n        // //////////////////////\n        // Start a new file section\n        startElement(METS,\"fileSec\");\n\n        // Check if the user is requested a specific bundle or\n        // the all bundles.\n        List<Bundle> bundles = findEnabledBundles();\n\n        // Suppress license?\n        Boolean showLicense = DSpaceServicesFactory.getInstance().getConfigurationService().getBooleanProperty(\"webui.licence_bundle.show\");\n\n        // Check if ORIGINAL bundle included (either explicitly or via include all fileGrp types)\n        boolean includeContentBundle = this.fileGrpTypes.isEmpty() ? true : this.fileGrpTypes.contains(\"ORIGINAL\");\n\n        // Loop over all requested bundles\n        for (Bundle bundle : bundles)\n        {\n\n            // Use the bitstream's name as the use parameter unless we\n            // are the original bundle. In this case rename it to\n            // content.\n            String use = bundle.getName();\n            boolean isContentBundle = false; // remember the content bundle.\n            boolean isDerivedBundle = false;\n            if (\"ORIGINAL\".equals(use))\n            {\n                use = \"CONTENT\";\n                isContentBundle = true;\n            }\n            if (\"TEXT\".equals(bundle.getName()) || \"THUMBNAIL\".equals(bundle.getName()))\n            {\n                isDerivedBundle = true;\n            }\n            if (\"LICENSE\".equals(bundle.getName()) && ! showLicense)\n            {\n                continue;\n            }\n\n            // /////////////////////////////////////\n            // Determine which bitstreams to include in bundle\n            List<Bitstream> bitstreams = new ArrayList<Bitstream>();\n\n            // If this is the THUMBNAIL bundle, and we are NOT including content bundle,\n            // Then assume this is an item summary page, and we can just include the main thumbnail.\n            if (\"THUMBNAIL\".equals(bundle.getName()) && !includeContentBundle)\n            {\n                Thumbnail thumbnail = itemService.getThumbnail(context, item, false);\n                if(thumbnail != null) {\n                    bitstreams.add(thumbnail.getThumb());\n                }\n            }\n            else\n            {   // Default to including all bitstreams\n                bitstreams = bundle.getBitstreams();\n            }\n\n\n            // ///////////////////\n            // Start bundle's file group\n            attributes = new AttributeMap();\n            attributes.put(\"USE\", use);\n            startElement(METS,\"fileGrp\",attributes);\n\n            for (Bitstream bitstream : bitstreams)\n            {\n                // //////////////////////////////\n                // Determine the file's IDs\n                String fileID = getFileID(bitstream);\n\n                Bitstream originalBitstream = null;\n                // If we are looping through a derived bundle and content bundle is included,\n                // ensure each derived bitstream and original bitstream share the same groupID\n                if (isDerivedBundle && includeContentBundle)\n                {\n                    originalBitstream = findOriginalBitstream(item, bitstream);\n                }\n                String groupID = getGroupFileID((originalBitstream == null) ? bitstream : originalBitstream );\n\n                // Check if there were administrative metadata sections corresponding to this file\n                String admIDs = null;\n                if(fileAmdSecIDs.containsKey(fileID))\n                {\n                    admIDs = fileAmdSecIDs.get(fileID).toString();\n                }\n\n                // Render the actual file & flocate elements.\n                renderFileWithAllowed(item, bitstream, fileID, groupID, admIDs);\n\n                // Remember all the viewable content bitstreams for later in the\n                // structMap.\n                if (isContentBundle)\n                {\n                    contentBitstreams.add(bitstream);\n                    if (bundle.getPrimaryBitstream() != null && bundle.getPrimaryBitstream().equals(bitstream))\n                    {\n                        primaryBitstream = bitstream;\n                    }\n                }\n            }\n\n            // ///////////////////\n            // End the bundle's file group\n            endElement(METS,\"fileGrp\");\n        }\n\n        // //////////////////////\n        // End the file section\n        endElement(METS,\"fileSec\");\n    }\n\n\n    /**\n     * Render the item's structural map. This includes a list of\n     * content bitstreams, those are bitstreams that are typically\n     * viewable by the end user.\n     *\n     * <p>Example:\n     *\n     * <pre>{@code\n     * <structMap TYPE=\"LOGICAL\" LABEL=\"DSpace\">\n     *   <div TYPE=\"DSpace Item\" DMDID=\"space-separated list of ids\">\n     *     <fptr FILEID=\"primary bitstream\"/>\n     *     ... a div for each content bitstream.\n     *   </div>\n     * </structMap>\n     * }</pre>\n     * @throws java.sql.SQLException passed through.\n     * @throws org.xml.sax.SAXException passed through.\n     */\n    @Override\n    protected void renderStructureMap() throws SQLException, SAXException\n    {\n        AttributeMap attributes;\n\n        // ///////////////////////\n        // Start a new structure map\n        attributes = new AttributeMap();\n        attributes.put(\"TYPE\", \"LOGICAL\");\n        attributes.put(\"LABEL\", \"DSpace\");\n        startElement(METS,\"structMap\",attributes);\n\n        // ////////////////////////////////\n        // Start the special first division\n        attributes = new AttributeMap();\n        attributes.put(\"TYPE\", \"DSpace Item\");\n        // add references to the Descriptive metadata\n        if (dmdSecIDS != null)\n        {\n            attributes.put(\"DMDID\", dmdSecIDS.toString());\n        }\n        // add references to the Administrative metadata\n        if (amdSecIDS != null)\n        {\n            attributes.put(\"AMDID\", amdSecIDS.toString());\n        }\n        startElement(METS,\"div\",attributes);\n\n        // add a fptr pointer to the primary bitstream.\n        if (primaryBitstream != null)\n        {\n                // ////////////////////////////////\n                // Start & end a reference to the primary bitstream.\n                attributes = new AttributeMap();\n                String fileID = getFileID(primaryBitstream);\n                attributes.put(\"FILEID\", fileID);\n\n                startElement(METS,\"fptr\",attributes);\n                endElement(METS,\"fptr\");\n        }\n\n        for (Bitstream bitstream : contentBitstreams)\n        {\n                // ////////////////////////////////////\n                // Start a div for each publicly viewable bitstream\n                attributes = new AttributeMap();\n                attributes.put(\"ID\", getGenericID(\"div_\"));\n                attributes.put(\"TYPE\", \"DSpace Content Bitstream\");\n                startElement(METS,\"div\",attributes);\n\n                // ////////////////////////////////\n                // Start a the actualy pointer to the bitstream FIXME: what?\n                attributes = new AttributeMap();\n                String fileID = getFileID(bitstream);\n                attributes.put(\"FILEID\", fileID);\n\n                startElement(METS,\"fptr\",attributes);\n                endElement(METS,\"fptr\");\n\n                // ///////////////////////////////\n                // End the div\n                endElement(METS,\"div\");\n        }\n\n        // ////////////////////////////////\n        // End the special first division\n        endElement(METS,\"div\");\n\n        // ///////////////////////\n        // End the structure map\n        endElement(METS,\"structMap\");\n    }\n\n\n\n    /**\n     * Render any extra METS section. If the item contains a METS.xml document\n     * then all of that document's sections are included in this document's\n     * METS document.\n     * @throws org.xml.sax.SAXException passed through.\n     * @throws java.sql.SQLException passed through.\n     * @throws java.io.IOException passed through.\n     */\n    @Override\n    protected void renderExtraSections() throws SAXException, SQLException, IOException\n    {\n        Boolean include = DSpaceServicesFactory.getInstance().getConfigurationService().getBooleanProperty(\"xmlui.bitstream.mets\");\n        if (!include)\n        {\n            return;\n        }\n\n\n        List<Bundle> bundles = itemService.getBundles(item, \"METADATA\");\n\n        for (Bundle bundle : bundles)\n        {\n                Bitstream bitstream = bundleService.getBitstreamByName(bundle, \"METS.xml\");\n\n                if (bitstream == null)\n                {\n                    continue;\n                }\n\n                // ///////////////////////////////\n                // Send the actual XML content\n                try {\n                        SAXFilter filter = new SAXFilter(contentHandler, lexicalHandler, namespaces);\n                        // Allow the basics for XML\n                        filter.allowIgnorableWhitespace().allowCharacters().allowCDATA().allowPrefixMappings();\n                        // Special option, only allow elements below the second level to pass through. This\n                        // will trim out the METS declaration and only leave the actual METS parts to be\n                        // included.\n                        filter.allowElements(1);\n\n\n                        XMLReader reader = XMLReaderFactory.createXMLReader();\n                        reader.setContentHandler(filter);\n                        reader.setProperty(\"http://xml.org/sax/properties/lexical-handler\", filter);\n                        reader.parse(new InputSource(bitstreamService.retrieve(context, bitstream)));\n                }\n                        catch (AuthorizeException ae)\n                        {\n                                // just ignore the authorize exception and continue on\n                                // without parsing the xml document.\n                        }\n        }\n    }\n\n    @Override\n    public boolean isAuthorized() throws SQLException\n    {\n        return authorizeService.authorizeActionBoolean(context, item, Constants.READ);\n    }\n\n\n    /**\n     * Checks which Bundles of current item a user has requested.\n     * If none specifically requested, then all Bundles are returned.\n     *\n     * @return List of enabled bundles\n     * @throws java.sql.SQLException passed through.\n     */\n    protected List<Bundle> findEnabledBundles() throws SQLException\n    {\n        // Check if the user is requested a specific bundle or\n        // the all bundles.\n        List<Bundle> bundles;\n        if (fileGrpTypes.isEmpty())\n        {\n            bundles = item.getBundles();\n        }\n        else\n        {\n                bundles = new ArrayList<>();\n                for (String fileGrpType : fileGrpTypes)\n                {\n                        for (Bundle newBundle : itemService.getBundles(item, fileGrpType))\n                        {\n                                bundles.add(newBundle);\n                        }\n                }\n        }\n\n        return bundles;\n    }\n\n\n    /**\n     * For a bitstream that's a thumbnail or extracted text, find the\n     * corresponding bitstream it was derived from, in the ORIGINAL bundle.\n     *\n     * @param item\n     *            the item we're dealing with\n     * @param derived\n     *            the derived bitstream\n     *\n     * @return the corresponding original bitstream (or null)\n     * @throws java.sql.SQLException passed through.\n     */\n    protected static Bitstream findOriginalBitstream(Item item,Bitstream derived) throws SQLException\n    {\n        // FIXME: this method is a copy of the one found below. However, the\n        // original method is protected so we can't use it here. I think that\n        // perhaps this should be folded into the DSpace bitstream API. Until\n        // when a good final solution can be determined I am just going to copy\n        // the method here.\n        //\n        // return org.dspace.content.packager.AbstractMetsDissemination\n        // .findOriginalBitstream(item, derived);\n\n        List<Bundle> bundles = item.getBundles();\n\n        // Filename of original will be filename of the derived bitstream\n        // minus the extension (ie everything from and including the last \".\" character)\n       int endIndex = derived.getName().lastIndexOf(\".\");\n       String originalFilename = derived.getName().substring(0, endIndex>0?endIndex:(derived.getName().length()-1));\n\n        // First find \"original\" bundle\n        for (Bundle bundle : bundles)\n        {\n            if ((bundle.getName() != null)\n                    && bundle.getName().equals(\"ORIGINAL\"))\n            {\n                // Now find the corresponding bitstream\n                List<Bitstream> bitstreams = bundle.getBitstreams();\n\n                for (Bitstream bitstream : bitstreams)\n                {\n                    if (bitstream.getName().equals(originalFilename))\n                    {\n                        return bitstream;\n                    }\n                }\n            }\n        }\n\n        // Didn't find it\n        return null;\n    }\n\n    /**\n     * Generate a METS file element for a given bitstream.\n     *\n     * @param item\n     *            If the bitstream is associated with an item provide the item\n     *            otherwise leave null.\n     * @param bitstream\n     *            The bitstream to build a file element for.\n     * @param fileID\n     *            The unique file id for this file.\n     * @param groupID\n     *            The group id for this file, if it is derived from another file\n     *            then they should share the same groupID.\n     * @param admID\n     *            The IDs of the administrative metadata sections which pertain\n     *            to this file\n     * @throws org.xml.sax.SAXException passed through.\n     * @throws java.sql.SQLException passed through.\n     */\n\n    // FIXME: this method is a copy of the one inherited. However the\n    // original method is final so we must rename it.\n\tprotected void renderFileWithAllowed(Item item, Bitstream bitstream, String fileID, String groupID, String admID) throws SAXException, SQLException\n    {\n\t\tAttributeMap attributes;\n\n\t\t// //////////////////////////////\n    \t// Determine the file attributes\n        BitstreamFormat format = bitstream.getFormat(context);\n        String mimeType = null;\n        if (format != null)\n        {\n            mimeType = format.getMIMEType();\n        }\n        String checksumType = bitstream.getChecksumAlgorithm();\n        String checksum = bitstream.getChecksum();\n        long size = bitstream.getSizeBytes();\n\n        // ////////////////////////////////\n        // Start the actual file\n        attributes = new AttributeMap();\n        attributes.put(\"ID\", fileID);\n        attributes.put(\"GROUPID\",groupID);\n        if (admID != null && admID.length()>0)\n        {\n            attributes.put(\"ADMID\", admID);\n        }\n        if (mimeType != null && mimeType.length()>0)\n        {\n            attributes.put(\"MIMETYPE\", mimeType);\n        }\n        if (checksumType != null && checksum != null)\n        {\n        \tattributes.put(\"CHECKSUM\", checksum);\n        \tattributes.put(\"CHECKSUMTYPE\", checksumType);\n        }\n        attributes.put(\"SIZE\", String.valueOf(size));\n        startElement(METS,\"file\",attributes);\n\n\n        // ////////////////////////////////////\n        // Determine the file location attributes\n        String name = bitstream.getName();\n        String description = bitstream.getDescription();\n\n\n        // If possible reference this bitstream via a handle, however this may\n        // be null if a handle has not yet been assigned. In this case reference the\n        // item its internal id. In the last case where the bitstream is not associated\n        // with an item (such as a community logo) then reference the bitstreamID directly.\n        String identifier = null;\n        if (item != null && item.getHandle() != null)\n        {\n            identifier = \"handle/\" + item.getHandle();\n        }\n        else if (item != null)\n        {\n            identifier = \"item/\" + item.getID();\n        }\n        else\n        {\n            identifier = \"id/\" + bitstream.getID();\n        }\n\n\n        String url = contextPath + \"/bitstream/\"+identifier+\"/\";\n\n        // If we can put the pretty name of the bitstream on the end of the URL\n        try\n        {\n        \tif (bitstream.getName() != null)\n            {\n                url += Util.encodeBitstreamName(bitstream.getName(), \"UTF-8\");\n            }\n        }\n        catch (UnsupportedEncodingException uee)\n        {\n            // just ignore it, we don't have to have a pretty\n            // name on the end of the URL because the sequence id will\n        \t// locate it. However it means that links in this file might\n        \t// not work....\n        }\n\n        url += \"?sequence=\"+bitstream.getSequenceID();\n\n\t// Test if we are allowed to see this item\n\tString isAllowed = \"n\";\n\ttry {\n\t    if (authorizeService.authorizeActionBoolean(context, bitstream, Constants.READ)) {\n\t\tisAllowed = \"y\";\n\t    }\n\t} catch (SQLException e) {/* Do nothing */}\n\n\turl += \"&isAllowed=\" + isAllowed;\n\n        // //////////////////////\n        // Start the file location\n        attributes = new AttributeMap();\n        AttributeMap attributesXLINK = new AttributeMap();\n        attributesXLINK.setNamespace(XLINK);\n        attributes.put(\"LOCTYPE\", \"URL\");\n        attributesXLINK.put(\"type\",\"locator\");\n        attributesXLINK.put(\"title\", name);\n        if (description != null)\n        {\n            attributesXLINK.put(\"label\", description);\n        }\n        attributesXLINK.put(\"href\", url);\n        startElement(METS,\"FLocat\",attributes,attributesXLINK);\n\n\n        // ///////////////////////\n        // End file location\n        endElement(METS,\"FLocate\");\n\n        // ////////////////////////////////\n        // End the file\n        endElement(METS,\"file\");\n\t}\n}\n", "/**\n * The contents of this file are subject to the license and copyright\n * detailed in the LICENSE and NOTICE files at the root of the source\n * tree and available online at\n *\n * http://www.dspace.org/license/\n */\npackage org.dspace.app.xmlui.objectmanager;\n\nimport java.sql.SQLException;\n\nimport org.dspace.app.xmlui.wing.AttributeMap;\nimport org.dspace.app.xmlui.wing.Namespace;\nimport org.dspace.app.xmlui.wing.WingException;\nimport org.dspace.content.Collection;\nimport org.dspace.content.Community;\nimport org.dspace.content.DSpaceObject;\nimport org.dspace.content.factory.ContentServiceFactory;\nimport org.dspace.content.service.CommunityService;\nimport org.dspace.services.factory.DSpaceServicesFactory;\nimport org.dspace.core.Constants;\nimport org.dspace.core.Context;\nimport org.dspace.handle.factory.HandleServiceFactory;\nimport org.dspace.handle.service.HandleService;\nimport org.xml.sax.SAXException;\n\n/**\n * This is an an adapter which translates a DSpace repository into a METS \n * document. Unfortunately, there is no real definition of what this is. So\n * we just kind of made it up based upon what we saw for the item profile.\n * \n * The basic structure is simply two parts:  the descriptive metadata and a\n * structural map. The descriptive metadata is a place to put metadata about \n * the whole repository. The structural map is used to map relationships\n * between communities and collections in DSpace.\n * \n * @author Scott Phillips\n */\npublic class RepositoryAdapter extends AbstractAdapter\n{\n\n\t/** MODS namespace */\n    public static final String MODS_URI = \"http://www.loc.gov/mods/v3\";\n    public static final Namespace MODS = new Namespace(MODS_URI);\n\n\t\n    /** A space separated list of descriptive metadata sections */\n    private String dmdSecIDS;\n    \n    /** Dspace context to be able to look up additional objects */\n    private final Context context;\n\n    protected CommunityService communityService = ContentServiceFactory.getInstance().getCommunityService();\n    protected HandleService handleService = HandleServiceFactory.getInstance().getHandleService();\n\n    /**\n     * Construct a new RepositoryAdapter\n     * \n     * @param context\n     *            The DSpace context to look up communities / collections.\n     * \n     * @param contextPath\n     *            The context Path of this web application.\n     */\n    public RepositoryAdapter(Context context, String contextPath)\n    {\n        super(contextPath);\n        this.context = context;\n    }\n\n    /**\n     * \n     * \n     * \n     * Abstract methods\n     * \n     * \n     * \n     */\n\n    /**\n     * @return the handle prefix as the identifier.\n     */\n    @Override\n    protected String getMETSID()\n    {\n        return handleService.getPrefix();\n    }\n    \n\t/**\n\t * The OBJID is used to encode the URL to the object, in this\n\t * case the repository which is just at the contextPath.\n     * @return local path to the object.\n     * @throws org.dspace.app.xmlui.wing.WingException passed through.\n\t */\n    @Override\n\tprotected String getMETSOBJID() throws WingException {\n\t\t\n\t\tif (contextPath == null)\n        {\n            return \"/\";\n        }\n\t\telse\n        {\n            return contextPath + \"/\";\n        }\n\t}\n\n    /**\n     * @return  Return the URL for editing this item\n     */\n    @Override\n    protected String getMETSOBJEDIT()\n    {\n        return null;\n    }\n\n    /**\n     * @return the profile this METS document conforms to...\n     *\n     * FIXME: It doesn't conform to a profile. This needs to be fixed.\n     */\n    @Override\n    protected String getMETSProfile()\n    {\n        return \"DRI DSPACE Repository Profile 1.0\";\n    }\n\n    /**\n     * @return a friendly label for the METS document stating that this is a\n     * DSpace repository.\n     */\n    @Override\n    protected String getMETSLabel()\n    {\n        return \"DSpace Repository\";\n    }\n\n    \n    /**\n     * \n     * \n     * \n     * METS structural methods\n     * \n     * \n     * \n     */\n\n    /**\n     * Render the repository's descriptive metadata section.\n     *\n     * For a the DSpace repository we just grab a few items \n     * from the config file and put them into the descriptive \n     * section, such as the name, hostname, handle prefix, and \n     * default language.\n     * \n     * @throws org.xml.sax.SAXException passed through.\n     */\n    @Override\n\tprotected void renderDescriptiveSection() throws SAXException\n    {\n    \tAttributeMap attributes;\n    \t\n    \t// Generate our ids\n        String dmdID = getGenericID(\"dmd_\");\n        String groupID = getGenericID(\"group_dmd_\");\n\n        // ////////////////////////////////\n        // Start a single dmdSec\n        attributes = new AttributeMap();\n        attributes.put(\"ID\", dmdID);\n        attributes.put(\"GROUPID\", groupID);\n        startElement(METS,\"dmdSec\",attributes);\n\n        // ////////////////////////////////\n        // Start a metadata wrapper (hardcoded to mods)\n        attributes = new AttributeMap();\n        attributes.put(\"MDTYPE\", \"OTHER\");\n        attributes.put(\"OTHERMDTYPE\", \"DIM\");\n        startElement(METS,\"mdWrap\",attributes);\n\n        // ////////////////////////////////\n        // Start the xml data\n        startElement(METS,\"xmlData\");\n        \n        /////////////////////////////////\n\t\t// Start the DIM element\t\t\t\n\t\tattributes = new AttributeMap();\n\t\tattributes.put(\"dspaceType\", Constants.typeText[Constants.SITE]);\n\t\tstartElement(DIM,\"dim\",attributes);\n\t\t\n\t\t// Entry for dspace.name\n\t\tattributes = new AttributeMap();\n\t\tattributes.put(\"mdschema\",\"dspace\");\n\t\tattributes.put(\"element\", \"name\");\n\t\tstartElement(DIM,\"field\",attributes);\n\t\tsendCharacters(DSpaceServicesFactory.getInstance().getConfigurationService().getProperty(\"dspace.name\"));\n\t\tendElement(DIM,\"field\");\n\t\t\n\t\t// Entry for dspace.hostname\n\t\tattributes = new AttributeMap();\n\t\tattributes.put(\"mdschema\",\"dspace\");\n\t\tattributes.put(\"element\", \"hostname\");\n\t\tstartElement(DIM,\"field\",attributes);\n\t\tsendCharacters(DSpaceServicesFactory.getInstance().getConfigurationService().getProperty(\"dspace.hostname\"));\n\t\tendElement(DIM,\"field\");\n\t\t\n\t\t// Entry for handle.prefix\n\t\tattributes = new AttributeMap();\n\t\tattributes.put(\"mdschema\",\"dspace\");\n\t\tattributes.put(\"element\", \"handle\");\n\t\tstartElement(DIM,\"field\",attributes);\n\t\tsendCharacters(handleService.getPrefix());\n\t\tendElement(DIM,\"field\");\n\t\t\n\t\t// Entry for default.language\n\t\tattributes = new AttributeMap();\n\t\tattributes.put(\"mdschema\",\"dspace\");\n\t\tattributes.put(\"element\", \"default\");\n\t\tattributes.put(\"qualifier\", \"language\");\n\t\tstartElement(DIM,\"field\",attributes);\n\t\tsendCharacters(DSpaceServicesFactory.getInstance().getConfigurationService().getProperty(\"default.language\"));\n\t\tendElement(DIM,\"field\");\n\t\t\n        // ///////////////////////////////\n        // End the DIM element\n        endElement(DIM,\"dim\");\n        \n        // End all the open elements.\n        endElement(METS,\"xmlData\");\n        endElement(METS,\"mdWrap\");\n        endElement(METS,\"dmdSec\");\n\n        // Remember the IDS\n        this.dmdSecIDS = dmdID;\n    }\n\n    /**\n     * Render the repository's structure map. This map will include a reference to\n     * all the community and collection objects showing how they are related to\n     * one another. \n     * @throws java.sql.SQLException passed through.\n     * @throws org.xml.sax.SAXException passed through.\n     */\n    @Override\n\tprotected void renderStructureMap() throws SQLException, SAXException\n    {\n    \tAttributeMap attributes;\n        \n    \t// //////////////////////////\n    \t// Start the new struct map\n        attributes = new AttributeMap();\n        attributes.put(\"TYPE\", \"LOGICAL\");\n        attributes.put(\"LABEL\", \"DSpace\");\n        startElement(METS,\"structMap\",attributes);\n        \n        // ////////////////////////////////\n        // Start the special first division\n        attributes = new AttributeMap();\n        attributes.put(\"TYPE\", \"DSpace Repository\");\n        // add references to the Descriptive metadata\n        if (dmdSecIDS != null)\n        {\n            attributes.put(\"DMDID\", dmdSecIDS);\n        }\n        startElement(METS,\"div\",attributes);\n\n        // Put each root level node into the document.\n        for (Community community : communityService.findAllTop(context))\n        {\n            renderStructuralDiv(community);\n        }\n        \n        \n        // //////////////////\n        // Close special first division and structural map\n        endElement(METS,\"div\");\n        endElement(METS,\"structMap\");\n        \n    }\n\n    @Override\n    public boolean isAuthorized()\n    {\n        return true;\n    }\n\n    /**\n     * \n     * \n     * \n     * private helpful methods\n     * \n     * \n     * \n     */\n\n    /**\n     * Recursively walk the DSpace hierarchy, rendering each container and subcontainer.\n     *\n     * @param dso\n     *            The DSpace Object to be rendered.\n     */\n    private void renderStructuralDiv(DSpaceObject dso) throws SAXException, SQLException\n    {\n    \tAttributeMap attributes;\n\n        // ////////////////////////////////\n        // Start the new div for this repository container\n        attributes = new AttributeMap();\n        if (dso instanceof Community)\n        {\n            attributes.put(\"TYPE\", \"DSpace Community\");\n        }\n        else if (dso instanceof Collection)\n        {\n            attributes.put(\"TYPE\", \"DSpace Collection\");\n        }\n        startElement(METS,\"div\",attributes);\n        \n        // //////////////////////////////////\n        // Start a metadata pointer for this container\n        attributes = new AttributeMap();\n        AttributeMap attributesXLINK = new AttributeMap();\n        attributesXLINK.setNamespace(XLINK);\n        \n        attributes.put(\"LOCTYPE\", \"URL\");\n        attributesXLINK.put(\"href\", \"/metadata/handle/\"+ dso.getHandle() +\"/mets.xml\");\n        startElement(METS,\"mptr\",attributes,attributesXLINK);\n        endElement(METS,\"mptr\");\n        \n        // Recurse to ensure that our children are also included even if this\n        // node already existed in the div structure.\n        if (dso instanceof Community)\n        {\n        \tfor (DSpaceObject child : ((Community)dso).getCollections())\n            {\n                renderStructuralDiv(child);\n            }\n        \t\n        \tfor (DSpaceObject child : ((Community)dso).getSubcommunities())\n            {\n                renderStructuralDiv(child);\n            }\n        }\n        \n        // ////////////////////\n        // Close division\n        endElement(METS,\"div\");\n    }\n}\n"], "filenames": ["dspace-xmlui/src/main/java/org/dspace/app/xmlui/cocoon/DSpaceMETSGenerator.java", "dspace-xmlui/src/main/java/org/dspace/app/xmlui/cocoon/DSpaceOREGenerator.java", "dspace-xmlui/src/main/java/org/dspace/app/xmlui/objectmanager/AbstractAdapter.java", "dspace-xmlui/src/main/java/org/dspace/app/xmlui/objectmanager/ContainerAdapter.java", "dspace-xmlui/src/main/java/org/dspace/app/xmlui/objectmanager/ItemAdapter.java", "dspace-xmlui/src/main/java/org/dspace/app/xmlui/objectmanager/RepositoryAdapter.java"], "buggy_code_start_loc": [17, 15, 21, 822, 986, 282], "buggy_code_end_loc": [118, 75, 630, 822, 986, 282], "fixing_code_start_loc": [18, 16, 22, 823, 987, 283], "fixing_code_end_loc": [126, 85, 644, 829, 993, 289], "type": "CWE-200", "message": "DSpace open source software is a repository application which provides durable access to digital resources. dspace-xmlui is a UI component for DSpace. In affected versions metadata on a withdrawn Item is exposed via the XMLUI \"mets.xml\" object, as long as you know the handle/URL of the withdrawn Item. This vulnerability only impacts the XMLUI. Users are advised to upgrade to version 6.4 or newer.", "other": {"cve": {"id": "CVE-2022-31190", "sourceIdentifier": "security-advisories@github.com", "published": "2022-08-01T20:15:08.707", "lastModified": "2022-08-08T16:52:23.683", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "DSpace open source software is a repository application which provides durable access to digital resources. dspace-xmlui is a UI component for DSpace. In affected versions metadata on a withdrawn Item is exposed via the XMLUI \"mets.xml\" object, as long as you know the handle/URL of the withdrawn Item. This vulnerability only impacts the XMLUI. Users are advised to upgrade to version 6.4 or newer."}, {"lang": "es", "value": "El software de c\u00f3digo abierto DSpace es una aplicaci\u00f3n de repositorio que proporciona acceso duradero a recursos digitales. dspace-xmlui es un componente de interfaz de usuario para DSpace. En versiones afectadas, los metadatos de un elemento retirado son expuestos por medio del objeto \"mets.xml\" de XMLUI, siempre y cuando sea conocido el handle/URL del elemento retirado. Esta vulnerabilidad s\u00f3lo afecta a la XMLUI. Es recomendado a usuarios actualizar a versi\u00f3n 6.4 o m\u00e1s reciente"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:duraspace:dspace:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.0", "versionEndExcluding": "6.4", "matchCriteriaId": "25C7D713-232D-4234-B069-67FBBFE2B495"}]}]}], "references": [{"url": "https://github.com/DSpace/DSpace/commit/574e25496a40173653ae7d0a49a19ed8e3458606.patch", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/DSpace/DSpace/pull/2451", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/DSpace/DSpace/security/advisories/GHSA-7w85-pp86-p4pq", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/DSpace/DSpace/commit/574e25496a40173653ae7d0a49a19ed8e3458606.patch"}}