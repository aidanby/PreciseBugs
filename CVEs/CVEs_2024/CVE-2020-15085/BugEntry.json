{"buggy_code": ["# Changelog\n\nAll notable, unreleased changes to this project will be documented in this file. For the released changes, please visit the [Releases](https://github.com/mirumee/saleor-storefront/releases) page.\n\n## [Unreleased]\n\n## 2.10.2\n\n- Fix fetching `quantityAvailable` field - #738 by @AlicjaSzu\n\n## 2.10.1\n\n- Replace stockQuantity field with quantityAvailable - #723 by @AlicjaSzu\n- Regenerate types - #712 by @dominik-zeglen\n\n## 2.10.0\n\n- Account confirmation mechanism - #565 by @tomaszszymanski129\n- Add missing product attributes on product page - #536 by @orzechdev\n- Change register mutation to accountRegister - #549 by @tomaszszymanski129\n- Add `ProductVariantPicker` component supporting multiple product variant attributes - #550 by @orzechdev\n- Fix not working storefront when no data in saleor database exist - #551 by @orzechdev\n- Make checkout working without shipping if it is not required - #571 by @orzechdev\n- Add ability to apply a promo code in checkout - #582 by @orzechdev\n- Refactor product list - #591 by @orzechdev\n- Add chips of selected filter attributes values and fix product list filtering - #602 by @orzechdev\n- Refactor FilterAttribute to AttributeValuesChecklist - #610 by @orzechdev\n- Clear cache on logout - #623 by @orzechdev\n- Add missing Cypress functional tests - #624 by @mateuszkula\n- Add lighthouse config - #627 by @mateuszkula\n- Load Stripe asynchronously - #629 by @orzechdev\n- Fix crash address book on logout - #630 by @orzechdev\n- Preload css for Inter font - #631 by @orzechdev\n- Use sdk for fetching shop details - #632 by @mateuszkula\n- Preconnect to Graphql API_URI - #634 by @mateuszkula\n- Upgrade typescript to 3.8.2 - #635 by @mateuszkula\n- Remove linguijs usage - #637 by @mateuszkula\n- Remove old storybook - #638 by @mateuszkula\n- Add docs to storybook - #614 by @orzechdev\n- Create new UI for product page - #605 by @mateuszkula\n- Use new pricing on product page with TaxedMoney component to display prices - #584 by @orzechdev\n- Update GraphQL schema - #567 by @orzechdev\n- Completely recreate checkout and cart, with new checkout nad cart SDK - #639 by @orzechdev, @mateuszkula\n- Hide payment options - #678 by @orzechdev\n- Fix unhandled JWT token expiration - #696 by @orzechdev\n\n## 0.7.0\n\n- Fix login and registration overlay not showing - #322 by @mateuszkula\n- Add new design for 404 page - #183 by @mateuszkula\n- Add Sitemap generator - #342 by @bogdal\n- Add Cypress tests - #333 by @AlicjaSzu\n- Add rich-text content renderer - #361 by @AlicjaSzu\n- Add rich-text content renderer for pages - #426 @ChanceLeachman\n- Add TextField and ErrorMessage components - #373 by @AlicjaSzu\n- Add CreditCardForm component - #369 by @AlicjaSzu\n- Display filters when no product was found - #319 by @aldomonteiro\n- Add ServiceWorker provider - #352 by @bogdal\n- Add ButtonLink atom component - #392 by @AlicjaSzu\n- Add `lingui` - #382 by @AlicjaSzu\n- Add FormFooter molecule component - #393 by @AlicjaSzu\n- Add Overlay component - #402 by @AlicjaSzu\n- Add Modal component - #391 by @AlicjaSzu\n- Add the Credential Management API support - #409 by @bogdal\n- Add size picker component - #425 by @bogdal\n- Replace `BACKEND_URL` in favor of `API_URI` - #474 by @bogdal\n- Adapt `checkout.availablePaymentGateways` structure to the new schema - #483 by @bogdal\n- Replace product/variant `price` fields with appropriate `pricing` fields - #483 by @bogdal\n- Add Stripe integration - #486 by @bogdal\n- Add `PlaceholderImage` component and show it in case of missing thumbnail - #489 by @xit4\n\n## 0.6.0\n\n- Fix items number in cart based on total sum of quantities - #286 by @bogdandjukic\n- Add new styles for inputs and labels - #311 by @AlicjaSzu\n- Create custom Select component and add it to ShippingAddress form - ##312 by @AlicjaSzu\n- Add schema.org data to homepage and product detail page - #316 by @koradon\n- Add link for creating account for anonymous users - #317 by @mateuszkula\n- Add react-alert library = #320 by @AlicjaSzu\n- CreditCard component refactor = #323 by @AlicjaSzu\n- Move App component to seperate module = #327 by @AlicjaSzu\n- Update Footer, Breadcrumbs and Table styles = #332 by @AlicjaSzu\n\n## 0.5.1\n\n- Fix image caching - #271 by @timuric\n- Fix images cors - #288 by @piotrgrundas\n\n## 0.5.0\n\n- Add stock quantity check without checkout in cart page - #254 by @piotrgrundas\n- Add ability to chose payment method, add dummy payment method, improve error handling on checkout shipping address update - #255 by @piotrgrundas\n- Add order details page - #262 by @piotrgrundas\n- Add order confirmation page - #263 by @piotrgrundas\n- Fix checkout composition - #264 by @piotrgrundas\n- Add ability to select user stored addresses, update copying shipping address to billing - #265 by @piotrgrundas\n- Fix rendering order statuses and order line prices - #281 by @maarcingebala\n\n## 0.4.0\n\n- Handle quantity API errors in cart - #199 by @piotrgrundas\n- Fix sticky footer, adjust cart overlay to the mockups, fix error if no shipping method found - #205 by @piotrgrundas\n- Disable ability to continue to the billing step without shipement chosen - #211 by @piotrgrundas\n- Set max width of images in product description as 100% - #220 by @jxltom\n- Move checkout to a separate module, create checkout after user provides a valid email - #223 by @piotrgrundas\n- Update checkout review page styles - #239 by @piotrgrundas\n- Add syncing checkout after user logs in - #243 by @piotrgrundas\n- Create checkout for logged in users without checkout upon adding to cart - #250 by @piotrgrundas\n\n## 0.3.0\n\n- Hide filters and sorting when there are no search results; add trending products to empty search and categories pages - #165 by @piotrgrundas\n- Add fetching menus from API - #170 by @piotrgrundas\n- Add \"Add to cart\" indicator - #173 by @piotrgrundas\n- Fix product page tablet view - #181 by @piotrgrundas\n- Add collection view, fix cursor pagination for categories, update storefront to use new thumbnail structure - #178 by @piotrgrundas\n- Minor UX improvements - #182 by @piotrgrundas\n- Fix product titles breaking the homepage carousel - #184 by @piotrgrundas\n- Fix resolving URLs that include numbers - #185 by @piotrgrundas\n- Add OpenGraph and Meta tags - #191 by @piotrgrundas\n- Add `tslint` check on CI; add the ability to change cart quantity - #194 by @piotrgrundas\n- Update placeholder for missing image - #198 by @piotrgrundas\n", "import {\n  ApolloClient,\n  ApolloError,\n  ObservableQuery,\n  WatchQueryOptions,\n} from \"apollo-client\";\nimport { GraphQLError } from \"graphql\";\n\nimport { fireSignOut, getAuthToken, setAuthToken } from \"../auth\";\nimport { MUTATIONS } from \"../mutations\";\nimport { TokenAuth } from \"../mutations/gqlTypes/TokenAuth\";\nimport { QUERIES } from \"../queries\";\nimport { UserDetails } from \"../queries/gqlTypes/UserDetails\";\nimport { RequireAtLeastOne } from \"../tsHelpers\";\nimport {\n  InferOptions,\n  MapFn,\n  QueryShape,\n  WatchMapFn,\n  WatchQueryData,\n} from \"../types\";\nimport {\n  getErrorsFromData,\n  getMappedData,\n  isDataEmpty,\n  mergeEdges,\n} from \"../utils\";\n\nexport class APIProxy {\n  getAttributes = this.watchQuery(QUERIES.Attributes, data => data.attributes);\n\n  getProductDetails = this.watchQuery(\n    QUERIES.ProductDetails,\n    data => data.product\n  );\n\n  getProductList = this.watchQuery(QUERIES.ProductList, data => data.products);\n\n  getCategoryDetails = this.watchQuery(\n    QUERIES.CategoryDetails,\n    data => data.category\n  );\n\n  getOrdersByUser = this.watchQuery(QUERIES.OrdersByUser, data =>\n    data.me ? data.me.orders : null\n  );\n\n  getOrderDetails = this.watchQuery(\n    QUERIES.OrderDetails,\n    data => data.orderByToken\n  );\n\n  getVariantsProducts = this.watchQuery(\n    QUERIES.VariantsProducts,\n    data => data.productVariants\n  );\n\n  getShopDetails = this.watchQuery(QUERIES.GetShopDetails, data => data);\n\n  setUserDefaultAddress = this.fireQuery(\n    MUTATIONS.AddressTypeUpdate,\n    data => data!.accountSetDefaultAddress\n  );\n\n  setDeleteUserAddress = this.fireQuery(\n    MUTATIONS.DeleteUserAddress,\n    data => data!.accountAddressDelete\n  );\n\n  setCreateUserAddress = this.fireQuery(\n    MUTATIONS.CreateUserAddress,\n    data => data!.accountAddressCreate\n  );\n\n  setUpdateuserAddress = this.fireQuery(\n    MUTATIONS.UpdateUserAddress,\n    data => data!.accountAddressUpdate\n  );\n\n  setAccountUpdate = this.fireQuery(\n    MUTATIONS.AccountUpdate,\n    data => data!.accountUpdate\n  );\n\n  setPasswordChange = this.fireQuery(MUTATIONS.PasswordChange, data => data);\n\n  setPassword = this.fireQuery(MUTATIONS.SetPassword, data => data);\n\n  client: ApolloClient<any>;\n\n  constructor(client: ApolloClient<any>) {\n    this.client = client;\n  }\n\n  getUserDetails = (\n    variables: InferOptions<QUERIES[\"UserDetails\"]>[\"variables\"],\n    options: Omit<InferOptions<QUERIES[\"UserDetails\"]>, \"variables\"> & {\n      onUpdate: (data: UserDetails[\"me\"] | null) => void;\n    }\n  ) => {\n    if (this.isLoggedIn()) {\n      return this.watchQuery(QUERIES.UserDetails, data => data.me)(\n        variables,\n        options\n      );\n    }\n    if (options.onUpdate) {\n      options.onUpdate(null);\n    }\n    return {\n      refetch: () =>\n        new Promise<{ data: UserDetails[\"me\"] }>((resolve, _reject) => {\n          resolve({ data: null });\n        }),\n      unsubscribe: () => undefined,\n    };\n  };\n\n  signIn = (\n    variables: InferOptions<MUTATIONS[\"TokenAuth\"]>[\"variables\"],\n    options?: Omit<InferOptions<MUTATIONS[\"TokenAuth\"]>, \"variables\">\n  ) =>\n    new Promise<{ data: TokenAuth[\"tokenCreate\"] }>(async (resolve, reject) => {\n      try {\n        this.client.resetStore();\n\n        const data = await this.fireQuery(\n          MUTATIONS.TokenAuth,\n          data => data!.tokenCreate\n        )(variables, {\n          ...options,\n          update: (proxy, data) => {\n            const handledData = handleDataErrors(\n              (data: any) => data.tokenCreate,\n              data.data,\n              data.errors\n            );\n            if (!handledData.errors && handledData.data) {\n              setAuthToken(handledData.data.token);\n              if (window.PasswordCredential && variables) {\n                navigator.credentials.store(\n                  new window.PasswordCredential({\n                    id: variables.email,\n                    password: variables.password,\n                  })\n                );\n              }\n            }\n            if (options && options.update) {\n              options.update(proxy, data);\n            }\n          },\n        });\n\n        resolve(data);\n      } catch (e) {\n        reject(e);\n      }\n    });\n\n  signOut = () =>\n    new Promise(async (resolve, reject) => {\n      try {\n        fireSignOut(this.client);\n\n        resolve();\n      } catch (e) {\n        reject(e);\n      }\n    });\n\n  attachAuthListener = (callback: (authenticated: boolean) => void) => {\n    const eventHandler = () => {\n      callback(this.isLoggedIn());\n    };\n\n    addEventListener(\"auth\", eventHandler);\n\n    return () => {\n      removeEventListener(\"auth\", eventHandler);\n    };\n  };\n\n  isLoggedIn = () => {\n    return !!getAuthToken();\n  };\n\n  watchQuery<T extends QueryShape, TResult>(\n    query: T,\n    mapFn: WatchMapFn<T, TResult>\n  ) {\n    return <\n      TVariables extends InferOptions<T>[\"variables\"],\n      TOptions extends Omit<\n        InferOptions<T> | WatchQueryOptions<InferOptions<T>>,\n        \"variables\"\n      >\n    >(\n      variables: TVariables,\n      options: TOptions & {\n        skip?: boolean;\n        onComplete?: () => void;\n        onError?: (error: ApolloError) => void;\n        onUpdate: (data: ReturnType<typeof mapFn> | null) => void;\n      }\n    ) => {\n      const { onComplete, onError, onUpdate, ...apolloClientOptions } = options;\n\n      const observable: ObservableQuery<WatchQueryData<T>, TVariables> = query(\n        this.client,\n        {\n          ...apolloClientOptions,\n          variables,\n        }\n      );\n\n      if (options.skip) {\n        return {\n          refetch: (_variables?: TVariables) => {\n            return new Promise((resolve, _reject) => {\n              resolve({ data: null });\n            });\n          },\n          unsubscribe: null,\n        };\n      }\n\n      const subscription = observable.subscribe(\n        result => {\n          const { data, errors: apolloErrors } = result;\n          const errorHandledData = handleDataErrors(\n            mapFn,\n            data as any,\n            apolloErrors\n          );\n          if (onUpdate) {\n            if (errorHandledData.errors) {\n              if (onError) {\n                onError(errorHandledData.errors);\n              }\n            } else {\n              onUpdate(errorHandledData.data as TResult);\n              if (onComplete) {\n                onComplete();\n              }\n            }\n          }\n        },\n        error => {\n          if (onError) {\n            onError(error);\n          }\n        }\n      );\n\n      return {\n        loadMore: (\n          extraVariables: RequireAtLeastOne<TVariables>,\n          mergeResults: boolean = true\n        ) => {\n          observable.fetchMore({\n            updateQuery: (previousResult, { fetchMoreResult }) => {\n              if (!fetchMoreResult) {\n                // returning previousResult doesn't trigger observable `next`\n                onUpdate(mapFn(previousResult));\n                return previousResult;\n              }\n\n              if (mergeResults) {\n                const prevResultRef = mapFn(previousResult) as any;\n                const newResultRef = mapFn(fetchMoreResult) as any;\n\n                if (!prevResultRef || !newResultRef) {\n                  onUpdate(prevResultRef);\n                  return previousResult;\n                }\n\n                const mergedEdges = mergeEdges(\n                  prevResultRef.edges,\n                  newResultRef.edges\n                );\n\n                // use new result for metadata and mutate existing data\n                Object.keys(prevResultRef).forEach(key => {\n                  prevResultRef[key] = newResultRef[key];\n                });\n                prevResultRef.edges = mergedEdges;\n\n                return previousResult;\n              }\n\n              return fetchMoreResult;\n            },\n            variables: { ...variables, ...extraVariables },\n          });\n        },\n        refetch: (variables?: TVariables) => {\n          if (variables) {\n            observable.setVariables(variables);\n            const cachedResult = observable.currentResult();\n            const errorHandledData = handleDataErrors(mapFn, cachedResult.data);\n            if (errorHandledData.data) {\n              onUpdate(errorHandledData.data as TResult);\n            }\n          }\n\n          return this.firePromise(() => observable.refetch(variables), mapFn);\n        },\n        setOptions: (options: TOptions) =>\n          this.firePromise(() => observable.setOptions(options), mapFn),\n        unsubscribe: subscription.unsubscribe.bind(subscription),\n      };\n    };\n  }\n\n  fireQuery<T extends QueryShape, TResult>(query: T, mapFn: MapFn<T, TResult>) {\n    return (\n      variables: InferOptions<T>[\"variables\"],\n      options?: Omit<InferOptions<T>, \"variables\">\n    ) =>\n      this.firePromise(\n        () =>\n          query(this.client, {\n            ...options,\n            variables,\n          }),\n        mapFn\n      );\n  }\n\n  // Promise wrapper to catch errors\n  firePromise<T extends QueryShape, TResult>(\n    promise: () => Promise<any>,\n    mapFn: MapFn<T, TResult> | WatchMapFn<T, TResult>\n  ) {\n    return new Promise<{ data: ReturnType<typeof mapFn> | null }>(\n      async (resolve, reject) => {\n        try {\n          const { data, errors: apolloErrors } = await promise();\n          const errorHandledData = handleDataErrors(mapFn, data, apolloErrors);\n\n          if (errorHandledData.errors) {\n            reject(errorHandledData.errors);\n          }\n\n          resolve({ data: errorHandledData.data });\n        } catch (error) {\n          reject(error);\n        }\n      }\n    );\n  }\n}\n\n// error handler\nconst handleDataErrors = <T extends QueryShape, TData>(\n  mapFn: MapFn<T, TData> | WatchMapFn<T, TData>,\n  data: TData,\n  apolloErrors?: readonly GraphQLError[]\n) => {\n  // INFO: user input errors will be moved to graphql errors\n  const userInputErrors = getErrorsFromData(data);\n  const errors =\n    apolloErrors || userInputErrors\n      ? new ApolloError({\n          extraInfo: userInputErrors,\n          graphQLErrors: apolloErrors,\n        })\n      : null;\n\n  if (errors && isDataEmpty(data)) {\n    return { errors };\n  }\n\n  const result = getMappedData(mapFn, data);\n\n  return { data: result };\n};\n", "export interface ErrorResponse<T> {\n  error?: any;\n  type?: T;\n}\n\nexport interface FunctionQueueResponse {\n  pending: boolean;\n}\nexport interface FunctionRunResponse<D, F> {\n  data?: any;\n  dataError?: ErrorResponse<D>;\n  functionError?: ErrorResponse<F>;\n  pending: boolean;\n}\n\nexport type PromiseQueuedResponse = Promise<FunctionQueueResponse>;\nexport type PromiseRunResponse<D, F> = Promise<FunctionRunResponse<D, F>>;\n"], "fixing_code": ["# Changelog\n\nAll notable, unreleased changes to this project will be documented in this file. For the released changes, please visit the [Releases](https://github.com/mirumee/saleor-storefront/releases) page.\n\n## [Unreleased]\n\n## 2.10.3\n\n- Stop storing plain text passwords in localStorage - by @dominik-zeglen\n\n## 2.10.2\n\n- Fix fetching `quantityAvailable` field - #738 by @AlicjaSzu\n\n## 2.10.1\n\n- Replace stockQuantity field with quantityAvailable - #723 by @AlicjaSzu\n- Regenerate types - #712 by @dominik-zeglen\n\n## 2.10.0\n\n- Account confirmation mechanism - #565 by @tomaszszymanski129\n- Add missing product attributes on product page - #536 by @orzechdev\n- Change register mutation to accountRegister - #549 by @tomaszszymanski129\n- Add `ProductVariantPicker` component supporting multiple product variant attributes - #550 by @orzechdev\n- Fix not working storefront when no data in saleor database exist - #551 by @orzechdev\n- Make checkout working without shipping if it is not required - #571 by @orzechdev\n- Add ability to apply a promo code in checkout - #582 by @orzechdev\n- Refactor product list - #591 by @orzechdev\n- Add chips of selected filter attributes values and fix product list filtering - #602 by @orzechdev\n- Refactor FilterAttribute to AttributeValuesChecklist - #610 by @orzechdev\n- Clear cache on logout - #623 by @orzechdev\n- Add missing Cypress functional tests - #624 by @mateuszkula\n- Add lighthouse config - #627 by @mateuszkula\n- Load Stripe asynchronously - #629 by @orzechdev\n- Fix crash address book on logout - #630 by @orzechdev\n- Preload css for Inter font - #631 by @orzechdev\n- Use sdk for fetching shop details - #632 by @mateuszkula\n- Preconnect to Graphql API_URI - #634 by @mateuszkula\n- Upgrade typescript to 3.8.2 - #635 by @mateuszkula\n- Remove linguijs usage - #637 by @mateuszkula\n- Remove old storybook - #638 by @mateuszkula\n- Add docs to storybook - #614 by @orzechdev\n- Create new UI for product page - #605 by @mateuszkula\n- Use new pricing on product page with TaxedMoney component to display prices - #584 by @orzechdev\n- Update GraphQL schema - #567 by @orzechdev\n- Completely recreate checkout and cart, with new checkout nad cart SDK - #639 by @orzechdev, @mateuszkula\n- Hide payment options - #678 by @orzechdev\n- Fix unhandled JWT token expiration - #696 by @orzechdev\n\n## 0.7.0\n\n- Fix login and registration overlay not showing - #322 by @mateuszkula\n- Add new design for 404 page - #183 by @mateuszkula\n- Add Sitemap generator - #342 by @bogdal\n- Add Cypress tests - #333 by @AlicjaSzu\n- Add rich-text content renderer - #361 by @AlicjaSzu\n- Add rich-text content renderer for pages - #426 @ChanceLeachman\n- Add TextField and ErrorMessage components - #373 by @AlicjaSzu\n- Add CreditCardForm component - #369 by @AlicjaSzu\n- Display filters when no product was found - #319 by @aldomonteiro\n- Add ServiceWorker provider - #352 by @bogdal\n- Add ButtonLink atom component - #392 by @AlicjaSzu\n- Add `lingui` - #382 by @AlicjaSzu\n- Add FormFooter molecule component - #393 by @AlicjaSzu\n- Add Overlay component - #402 by @AlicjaSzu\n- Add Modal component - #391 by @AlicjaSzu\n- Add the Credential Management API support - #409 by @bogdal\n- Add size picker component - #425 by @bogdal\n- Replace `BACKEND_URL` in favor of `API_URI` - #474 by @bogdal\n- Adapt `checkout.availablePaymentGateways` structure to the new schema - #483 by @bogdal\n- Replace product/variant `price` fields with appropriate `pricing` fields - #483 by @bogdal\n- Add Stripe integration - #486 by @bogdal\n- Add `PlaceholderImage` component and show it in case of missing thumbnail - #489 by @xit4\n\n## 0.6.0\n\n- Fix items number in cart based on total sum of quantities - #286 by @bogdandjukic\n- Add new styles for inputs and labels - #311 by @AlicjaSzu\n- Create custom Select component and add it to ShippingAddress form - ##312 by @AlicjaSzu\n- Add schema.org data to homepage and product detail page - #316 by @koradon\n- Add link for creating account for anonymous users - #317 by @mateuszkula\n- Add react-alert library = #320 by @AlicjaSzu\n- CreditCard component refactor = #323 by @AlicjaSzu\n- Move App component to seperate module = #327 by @AlicjaSzu\n- Update Footer, Breadcrumbs and Table styles = #332 by @AlicjaSzu\n\n## 0.5.1\n\n- Fix image caching - #271 by @timuric\n- Fix images cors - #288 by @piotrgrundas\n\n## 0.5.0\n\n- Add stock quantity check without checkout in cart page - #254 by @piotrgrundas\n- Add ability to chose payment method, add dummy payment method, improve error handling on checkout shipping address update - #255 by @piotrgrundas\n- Add order details page - #262 by @piotrgrundas\n- Add order confirmation page - #263 by @piotrgrundas\n- Fix checkout composition - #264 by @piotrgrundas\n- Add ability to select user stored addresses, update copying shipping address to billing - #265 by @piotrgrundas\n- Fix rendering order statuses and order line prices - #281 by @maarcingebala\n\n## 0.4.0\n\n- Handle quantity API errors in cart - #199 by @piotrgrundas\n- Fix sticky footer, adjust cart overlay to the mockups, fix error if no shipping method found - #205 by @piotrgrundas\n- Disable ability to continue to the billing step without shipement chosen - #211 by @piotrgrundas\n- Set max width of images in product description as 100% - #220 by @jxltom\n- Move checkout to a separate module, create checkout after user provides a valid email - #223 by @piotrgrundas\n- Update checkout review page styles - #239 by @piotrgrundas\n- Add syncing checkout after user logs in - #243 by @piotrgrundas\n- Create checkout for logged in users without checkout upon adding to cart - #250 by @piotrgrundas\n\n## 0.3.0\n\n- Hide filters and sorting when there are no search results; add trending products to empty search and categories pages - #165 by @piotrgrundas\n- Add fetching menus from API - #170 by @piotrgrundas\n- Add \"Add to cart\" indicator - #173 by @piotrgrundas\n- Fix product page tablet view - #181 by @piotrgrundas\n- Add collection view, fix cursor pagination for categories, update storefront to use new thumbnail structure - #178 by @piotrgrundas\n- Minor UX improvements - #182 by @piotrgrundas\n- Fix product titles breaking the homepage carousel - #184 by @piotrgrundas\n- Fix resolving URLs that include numbers - #185 by @piotrgrundas\n- Add OpenGraph and Meta tags - #191 by @piotrgrundas\n- Add `tslint` check on CI; add the ability to change cart quantity - #194 by @piotrgrundas\n- Update placeholder for missing image - #198 by @piotrgrundas\n", "import {\n  ApolloClient,\n  ApolloError,\n  ObservableQuery,\n  WatchQueryOptions,\n} from \"apollo-client\";\nimport { GraphQLError } from \"graphql\";\n\nimport { fireSignOut, getAuthToken, setAuthToken } from \"../auth\";\nimport { MUTATIONS } from \"../mutations\";\nimport { PasswordChange } from \"../mutations/gqlTypes/PasswordChange\";\nimport { SetPassword } from \"../mutations/gqlTypes/SetPassword\";\nimport {\n  TokenAuth,\n  TokenAuth_tokenCreatte,\n} from \"../mutations/gqlTypes/TokenAuth\";\nimport { QUERIES } from \"../queries\";\nimport { UserDetails } from \"../queries/gqlTypes/UserDetails\";\nimport { RequireAtLeastOne } from \"../tsHelpers\";\nimport {\n  InferOptions,\n  MapFn,\n  QueryShape,\n  WatchMapFn,\n  WatchQueryData,\n} from \"../types\";\nimport {\n  getErrorsFromData,\n  getMappedData,\n  isDataEmpty,\n  mergeEdges,\n} from \"../utils\";\nimport { SetPasswordChange, SetPasswordResult, SignIn } from \"./types\";\n\nexport class APIProxy {\n  getAttributes = this.watchQuery(\n    QUERIES.Attributes,\n    (data) => data.attributes\n  );\n\n  getProductDetails = this.watchQuery(\n    QUERIES.ProductDetails,\n    (data) => data.product\n  );\n\n  getProductList = this.watchQuery(\n    QUERIES.ProductList,\n    (data) => data.products\n  );\n\n  getCategoryDetails = this.watchQuery(\n    QUERIES.CategoryDetails,\n    (data) => data.category\n  );\n\n  getOrdersByUser = this.watchQuery(QUERIES.OrdersByUser, (data) =>\n    data.me ? data.me.orders : null\n  );\n\n  getOrderDetails = this.watchQuery(\n    QUERIES.OrderDetails,\n    (data) => data.orderByToken\n  );\n\n  getVariantsProducts = this.watchQuery(\n    QUERIES.VariantsProducts,\n    (data) => data.productVariants\n  );\n\n  getShopDetails = this.watchQuery(QUERIES.GetShopDetails, (data) => data);\n\n  setUserDefaultAddress = this.fireQuery(\n    MUTATIONS.AddressTypeUpdate,\n    (data) => data!.accountSetDefaultAddress\n  );\n\n  setDeleteUserAddress = this.fireQuery(\n    MUTATIONS.DeleteUserAddress,\n    (data) => data!.accountAddressDelete\n  );\n\n  setCreateUserAddress = this.fireQuery(\n    MUTATIONS.CreateUserAddress,\n    (data) => data!.accountAddressCreate\n  );\n\n  setUpdateuserAddress = this.fireQuery(\n    MUTATIONS.UpdateUserAddress,\n    (data) => data!.accountAddressUpdate\n  );\n\n  setAccountUpdate = this.fireQuery(\n    MUTATIONS.AccountUpdate,\n    (data) => data!.accountUpdate\n  );\n\n  client: ApolloClient<any>;\n\n  constructor(client: ApolloClient<any>) {\n    this.client = client;\n  }\n\n  getUserDetails = (\n    variables: InferOptions<QUERIES[\"UserDetails\"]>[\"variables\"],\n    options: Omit<InferOptions<QUERIES[\"UserDetails\"]>, \"variables\"> & {\n      onUpdate: (data: UserDetails[\"me\"] | null) => void;\n    }\n  ) => {\n    if (this.isLoggedIn()) {\n      return this.watchQuery(QUERIES.UserDetails, (data) => data.me)(\n        variables,\n        options\n      );\n    }\n    if (options.onUpdate) {\n      options.onUpdate(null);\n    }\n    return {\n      refetch: () =>\n        new Promise<{ data: UserDetails[\"me\"] }>((resolve, _reject) => {\n          resolve({ data: null });\n        }),\n      unsubscribe: () => undefined,\n    };\n  };\n\n  signIn = async (\n    variables: InferOptions<MUTATIONS[\"TokenAuth\"]>[\"variables\"],\n    options?: Omit<InferOptions<MUTATIONS[\"TokenAuth\"]>, \"variables\">\n  ): Promise<SignIn> => {\n    await this.client.resetStore();\n    let result: {\n      data: TokenAuth_tokenCreate | null;\n    } | null = null;\n\n    result = await this.fireQuery(\n      MUTATIONS.TokenAuth,\n      (mutationData) => mutationData!.tokenCreate\n    )(variables, {\n      ...options,\n      fetchPolicy: \"no-cache\",\n    });\n    const { data } = result;\n\n    if (data?.token && data.errors.length === 0) {\n      setAuthToken(data.token);\n      if (window.PasswordCredential && variables) {\n        navigator.credentials.store(\n          new window.PasswordCredential({\n            id: variables.email,\n            password: variables.password,\n          })\n        );\n      }\n    }\n    return {\n      data,\n      error: null,\n    };\n  };\n\n  signOut = () =>\n    new Promise(async (resolve, reject) => {\n      try {\n        fireSignOut(this.client);\n\n        resolve();\n      } catch (e) {\n        reject(e);\n      }\n    });\n\n  setPassword = async (\n    variables: InferOptions<MUTATIONS[\"SetPassword\"]>[\"variables\"],\n    options?: Omit<InferOptions<MUTATIONS[\"SetPassword\"]>, \"variables\">\n  ): Promise<SetPasswordResult> => {\n    let result: {\n      data: SetPassword | null;\n    } | null = null;\n\n    result = await this.fireQuery(MUTATIONS.SetPassword, (data) => data!)(\n      variables,\n      {\n        ...options,\n        fetchPolicy: \"no-cache\",\n      }\n    );\n    const { data } = result;\n\n    return {\n      data,\n      error: null,\n    };\n  };\n\n  setPasswordChange = async (\n    variables: InferOptions<MUTATIONS[\"PasswordChange\"]>[\"variables\"],\n    options?: Omit<InferOptions<MUTATIONS[\"PasswordChange\"]>, \"variables\">\n  ): Promise<SetPasswordChange> => {\n    let result: {\n      data: PasswordChange | null;\n    } | null = null;\n\n    result = await this.fireQuery(MUTATIONS.PasswordChange, (data) => data!)(\n      variables,\n      {\n        ...options,\n        fetchPolicy: \"no-cache\",\n      }\n    );\n    const { data } = result;\n\n    return {\n      data,\n      error: null,\n    };\n  };\n\n  attachAuthListener = (callback: (authenticated: boolean) => void) => {\n    const eventHandler = () => {\n      callback(this.isLoggedIn());\n    };\n\n    addEventListener(\"auth\", eventHandler);\n\n    return () => {\n      removeEventListener(\"auth\", eventHandler);\n    };\n  };\n\n  isLoggedIn = () => {\n    return !!getAuthToken();\n  };\n\n  watchQuery<T extends QueryShape, TResult>(\n    query: T,\n    mapFn: WatchMapFn<T, TResult>\n  ) {\n    return <\n      TVariables extends InferOptions<T>[\"variables\"],\n      TOptions extends Omit<\n        InferOptions<T> | WatchQueryOptions<InferOptions<T>>,\n        \"variables\"\n      >\n    >(\n      variables: TVariables,\n      options: TOptions & {\n        skip?: boolean;\n        onComplete?: () => void;\n        onError?: (error: ApolloError) => void;\n        onUpdate: (data: ReturnType<typeof mapFn> | null) => void;\n      }\n    ) => {\n      const { onComplete, onError, onUpdate, ...apolloClientOptions } = options;\n\n      const observable: ObservableQuery<WatchQueryData<T>, TVariables> = query(\n        this.client,\n        {\n          ...apolloClientOptions,\n          variables,\n        }\n      );\n\n      if (options.skip) {\n        return {\n          refetch: (_variables?: TVariables) => {\n            return new Promise((resolve, _reject) => {\n              resolve({ data: null });\n            });\n          },\n          unsubscribe: null,\n        };\n      }\n\n      const subscription = observable.subscribe(\n        (result) => {\n          const { data, errors: apolloErrors } = result;\n          const errorHandledData = handleDataErrors(\n            mapFn,\n            data as any,\n            apolloErrors\n          );\n          if (onUpdate) {\n            if (errorHandledData.errors) {\n              if (onError) {\n                onError(errorHandledData.errors);\n              }\n            } else {\n              onUpdate(errorHandledData.data as TResult);\n              if (onComplete) {\n                onComplete();\n              }\n            }\n          }\n        },\n        (error) => {\n          if (onError) {\n            onError(error);\n          }\n        }\n      );\n\n      return {\n        loadMore: (\n          extraVariables: RequireAtLeastOne<TVariables>,\n          mergeResults: boolean = true\n        ) => {\n          observable.fetchMore({\n            updateQuery: (previousResult, { fetchMoreResult }) => {\n              if (!fetchMoreResult) {\n                // returning previousResult doesn't trigger observable `next`\n                onUpdate(mapFn(previousResult));\n                return previousResult;\n              }\n\n              if (mergeResults) {\n                const prevResultRef = mapFn(previousResult) as any;\n                const newResultRef = mapFn(fetchMoreResult) as any;\n\n                if (!prevResultRef || !newResultRef) {\n                  onUpdate(prevResultRef);\n                  return previousResult;\n                }\n\n                const mergedEdges = mergeEdges(\n                  prevResultRef.edges,\n                  newResultRef.edges\n                );\n\n                // use new result for metadata and mutate existing data\n                Object.keys(prevResultRef).forEach((key) => {\n                  prevResultRef[key] = newResultRef[key];\n                });\n                prevResultRef.edges = mergedEdges;\n\n                return previousResult;\n              }\n\n              return fetchMoreResult;\n            },\n            variables: { ...variables, ...extraVariables },\n          });\n        },\n        refetch: (variables?: TVariables) => {\n          if (variables) {\n            observable.setVariables(variables);\n            const cachedResult = observable.currentResult();\n            const errorHandledData = handleDataErrors(mapFn, cachedResult.data);\n            if (errorHandledData.data) {\n              onUpdate(errorHandledData.data as TResult);\n            }\n          }\n\n          return this.firePromise(() => observable.refetch(variables), mapFn);\n        },\n        setOptions: (options: TOptions) =>\n          this.firePromise(() => observable.setOptions(options), mapFn),\n        unsubscribe: subscription.unsubscribe.bind(subscription),\n      };\n    };\n  }\n\n  fireQuery<T extends QueryShape, TResult>(query: T, mapFn: MapFn<T, TResult>) {\n    return (\n      variables: InferOptions<T>[\"variables\"],\n      options?: Omit<InferOptions<T>, \"variables\">\n    ) =>\n      this.firePromise(\n        () =>\n          query(this.client, {\n            ...options,\n            variables,\n          }),\n        mapFn\n      );\n  }\n\n  // Promise wrapper to catch errors\n  firePromise<T extends QueryShape, TResult>(\n    promise: () => Promise<any>,\n    mapFn: MapFn<T, TResult> | WatchMapFn<T, TResult>\n  ) {\n    return new Promise<{ data: ReturnType<typeof mapFn> | null }>(\n      async (resolve, reject) => {\n        try {\n          const { data, errors: apolloErrors } = await promise();\n          const errorHandledData = handleDataErrors(mapFn, data, apolloErrors);\n\n          if (errorHandledData.errors) {\n            reject(errorHandledData.errors);\n          }\n\n          resolve({ data: errorHandledData.data });\n        } catch (error) {\n          reject(error);\n        }\n      }\n    );\n  }\n}\n\n// error handler\nconst handleDataErrors = <T extends QueryShape, TData>(\n  mapFn: MapFn<T, TData> | WatchMapFn<T, TData>,\n  data: TData,\n  apolloErrors?: readonly GraphQLError[]\n) => {\n  // INFO: user input errors will be moved to graphql errors\n  const userInputErrors = getErrorsFromData(data);\n  const errors =\n    apolloErrors || userInputErrors\n      ? new ApolloError({\n          extraInfo: userInputErrors,\n          graphQLErrors: apolloErrors,\n        })\n      : null;\n\n  if (errors && isDataEmpty(data)) {\n    return { errors };\n  }\n\n  const result = getMappedData(mapFn, data);\n\n  return { data: result };\n};\n", "import { ApolloError } from \"apollo-client\";\nimport { PasswordChange } from \"../mutations/gqlTypes/PasswordChange\";\nimport { SetPassword } from \"../mutations/gqlTypes/SetPassword\";\nimport { TokenAuth_tokenCreate } from \"../mutations/gqlTypes/TokenAuth\";\n\nexport interface ErrorResponse<T> {\n  error?: any;\n  type?: T;\n}\n\nexport interface FunctionQueueResponse {\n  pending: boolean;\n}\nexport interface FunctionRunResponse<D, F> {\n  data?: any;\n  dataError?: ErrorResponse<D>;\n  functionError?: ErrorResponse<F>;\n  pending: boolean;\n}\n\nexport type PromiseQueuedResponse = Promise<FunctionQueueResponse>;\nexport type PromiseRunResponse<D, F> = Promise<FunctionRunResponse<D, F>>;\n\nexport type SignIn = {\n  data: TokenAuth_tokenCreate | null;\n  error: ApolloError | null;\n} | null;\n\nexport type SetPasswordChange = {\n  data: PasswordChange | null;\n  error: ApolloError | null;\n} | null;\n\nexport type SetPasswordResult = {\n  data: SetPassword | null;\n  error: ApolloError | null;\n} | null;\n"], "filenames": ["CHANGELOG.md", "src/@sdk/api/APIProxy.ts", "src/@sdk/api/types.ts"], "buggy_code_start_loc": [5, 11, 0], "buggy_code_end_loc": [5, 285, 17], "fixing_code_start_loc": [6, 11, 1], "fixing_code_end_loc": [10, 332, 38], "type": "CWE-312", "message": "In Saleor Storefront before version 2.10.3, request data used to authenticate customers was inadvertently cached in the browser's local storage mechanism, including credentials. A malicious user with direct access to the browser could extract the email and password. In versions prior to 2.10.0 persisted the cache even after the user logged out. This is fixed in version 2.10.3. A workaround is to manually clear application data (browser's local storage) after logging into Saleor Storefront.", "other": {"cve": {"id": "CVE-2020-15085", "sourceIdentifier": "security-advisories@github.com", "published": "2020-06-30T17:15:10.797", "lastModified": "2020-07-28T15:45:59.960", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Saleor Storefront before version 2.10.3, request data used to authenticate customers was inadvertently cached in the browser's local storage mechanism, including credentials. A malicious user with direct access to the browser could extract the email and password. In versions prior to 2.10.0 persisted the cache even after the user logged out. This is fixed in version 2.10.3. A workaround is to manually clear application data (browser's local storage) after logging into Saleor Storefront."}, {"lang": "es", "value": "En Saleor Storefront versiones anteriores a 2.10.3, los datos de petici\u00f3n usados para autenticar a los clientes se almacenaron en memoria cach\u00e9 inadvertidamente en el mecanismo de almacenamiento local del navegador, incluyendo las credenciales. Un usuario malicioso con acceso directo al navegador podr\u00eda extraer el correo electr\u00f3nico y la contrase\u00f1a. En versiones anteriores a 2.10.0, la memoria cach\u00e9 persist\u00eda incluso despu\u00e9s de que el usuario cerraba la sesi\u00f3n. Esto es corregido en la versi\u00f3n 2.10.3. Una soluci\u00f3n alternativa es borrar manualmente los datos de la aplicaci\u00f3n (almacenamiento local del navegador) despu\u00e9s de iniciar sesi\u00f3n en Saleor Storefront"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:L/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 4.2}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:C/C:H/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.6, "impactScore": 4.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-312"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mirumee:saleor:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.10.3", "matchCriteriaId": "7D75FAC4-CD4C-4C99-A9AB-A51A2BD52992"}]}]}], "references": [{"url": "https://github.com/mirumee/saleor-storefront/blob/master/CHANGELOG.md#2103", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/mirumee/saleor-storefront/commit/7c331e1be805022c9a7be719bd69d050b2577458", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/mirumee/saleor-storefront/security/advisories/GHSA-4279-h39w-2jqm", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/mirumee/saleor-storefront/commit/7c331e1be805022c9a7be719bd69d050b2577458"}}