{"buggy_code": ["module Mail\n  \n  # FileDelivery class delivers emails into multiple files based on the destination\n  # address.  Each file is appended to if it already exists.\n  # \n  # So if you have an email going to fred@test, bob@test, joe@anothertest, and you\n  # set your location path to /path/to/mails then FileDelivery will create the directory\n  # if it does not exist, and put one copy of the email in three files, called\n  # \"fred@test\", \"bob@test\" and \"joe@anothertest\"\n  # \n  # Make sure the path you specify with :location is writable by the Ruby process\n  # running Mail.\n  class FileDelivery\n\n    if RUBY_VERSION >= '1.9.1'\n      require 'fileutils'\n    else\n      require 'ftools'\n    end\n\n    def initialize(values)\n      self.settings = { :location => './mails' }.merge!(values)\n    end\n    \n    attr_accessor :settings\n    \n    def deliver!(mail)\n      if ::File.respond_to?(:makedirs)\n        ::File.makedirs settings[:location]\n      else\n        ::FileUtils.mkdir_p settings[:location]\n      end\n\n      mail.destinations.uniq.each do |to|\n        ::File.open(::File.join(settings[:location], to), 'a') { |f| \"#{f.write(mail.encoded)}\\r\\n\\r\\n\" }\n      end\n    end\n    \n  end\nend\n", "# encoding: utf-8\nrequire 'spec_helper'\n\ndescribe \"SMTP Delivery Method\" do\n\n  before(:each) do\n    # Reset all defaults back to an original state\n    Mail.defaults do\n      delivery_method :smtp, { :address              => \"localhost\",\n                               :port                 => 25,\n                               :domain               => 'localhost.localdomain',\n                               :user_name            => nil,\n                               :password             => nil,\n                               :authentication       => nil,\n                               :enable_starttls_auto => true  }\n    end\n  end\n  \n  after(:each) do\n    files = Dir.glob(File.join(Mail.delivery_method.settings[:location], '*'))\n    files.each do |file|\n      File.delete(file)\n    end\n  end\n  \n  describe \"general usage\" do\n    tmpdir = File.expand_path('../../../../tmp/mail', __FILE__)\n\n    it \"should send an email to a file\" do\n      Mail.defaults do\n        delivery_method :file, :location => tmpdir\n      end\n      \n      mail = Mail.deliver do\n        from    'roger@moore.com'\n        to      'marcel@amont.com'\n        subject 'invalid RFC2822'\n      end\n      \n      delivery = File.join(Mail.delivery_method.settings[:location], 'marcel@amont.com')\n      \n      File.read(delivery).should eq mail.encoded\n    end\n\n    it \"should send multiple emails to multiple files\" do\n      Mail.defaults do\n        delivery_method :file, :location => tmpdir\n      end\n      \n      mail = Mail.deliver do\n        from    'roger@moore.com'\n        to      'marcel@amont.com, bob@me.com'\n        subject 'invalid RFC2822'\n      end\n      \n      delivery_one = File.join(Mail.delivery_method.settings[:location], 'marcel@amont.com')\n      delivery_two = File.join(Mail.delivery_method.settings[:location], 'bob@me.com')\n      \n      File.read(delivery_one).should eq mail.encoded\n      File.read(delivery_two).should eq mail.encoded\n    end\n\n    it \"should only create files based on the addr_spec of the destination\" do\n      Mail.defaults do\n        delivery_method :file, :location => tmpdir\n      end\n      \n      Mail.deliver do\n        from    'roger@moore.com'\n        to      '\"Long, stupid email address\" <mikel@test.lindsaar.net>'\n        subject 'invalid RFC2822'\n      end\n      delivery = File.join(Mail.delivery_method.settings[:location], 'mikel@test.lindsaar.net')\n      File.exists?(delivery).should be_true\n    end\n\n  end\n  \nend\n"], "fixing_code": ["module Mail\n  \n  # FileDelivery class delivers emails into multiple files based on the destination\n  # address.  Each file is appended to if it already exists.\n  # \n  # So if you have an email going to fred@test, bob@test, joe@anothertest, and you\n  # set your location path to /path/to/mails then FileDelivery will create the directory\n  # if it does not exist, and put one copy of the email in three files, called\n  # by their message id\n  # \n  # Make sure the path you specify with :location is writable by the Ruby process\n  # running Mail.\n  class FileDelivery\n\n    if RUBY_VERSION >= '1.9.1'\n      require 'fileutils'\n    else\n      require 'ftools'\n    end\n\n    def initialize(values)\n      self.settings = { :location => './mails' }.merge!(values)\n    end\n    \n    attr_accessor :settings\n    \n    def deliver!(mail)\n      if ::File.respond_to?(:makedirs)\n        ::File.makedirs settings[:location]\n      else\n        ::FileUtils.mkdir_p settings[:location]\n      end\n\n      mail.destinations.uniq.each do |to|\n        ::File.open(::File.join(settings[:location], File.basename(to.to_s)), 'a') { |f| \"#{f.write(mail.encoded)}\\r\\n\\r\\n\" }\n      end\n    end\n    \n  end\nend\n", "# encoding: utf-8\nrequire 'spec_helper'\n\ndescribe \"SMTP Delivery Method\" do\n\n  before(:each) do\n    # Reset all defaults back to an original state\n    Mail.defaults do\n      delivery_method :smtp, { :address              => \"localhost\",\n                               :port                 => 25,\n                               :domain               => 'localhost.localdomain',\n                               :user_name            => nil,\n                               :password             => nil,\n                               :authentication       => nil,\n                               :enable_starttls_auto => true  }\n    end\n  end\n  \n  after(:each) do\n    files = Dir.glob(File.join(Mail.delivery_method.settings[:location], '*'))\n    files.each do |file|\n      File.delete(file)\n    end\n  end\n  \n  describe \"general usage\" do\n    tmpdir = File.expand_path('../../../../tmp/mail', __FILE__)\n\n    it \"should send an email to a file\" do\n      Mail.defaults do\n        delivery_method :file, :location => tmpdir\n      end\n      \n      mail = Mail.deliver do\n        from    'roger@moore.com'\n        to      'marcel@amont.com'\n        subject 'invalid RFC2822'\n      end\n      \n      delivery = File.join(Mail.delivery_method.settings[:location], 'marcel@amont.com')\n      \n      File.read(delivery).should eq mail.encoded\n    end\n\n    it \"should send multiple emails to multiple files\" do\n      Mail.defaults do\n        delivery_method :file, :location => tmpdir\n      end\n      \n      mail = Mail.deliver do\n        from    'roger@moore.com'\n        to      'marcel@amont.com, bob@me.com'\n        subject 'invalid RFC2822'\n      end\n      \n      delivery_one = File.join(Mail.delivery_method.settings[:location], 'marcel@amont.com')\n      delivery_two = File.join(Mail.delivery_method.settings[:location], 'bob@me.com')\n      \n      File.read(delivery_one).should eq mail.encoded\n      File.read(delivery_two).should eq mail.encoded\n    end\n\n    it \"should only create files based on the addr_spec of the destination\" do\n      Mail.defaults do\n        delivery_method :file, :location => tmpdir\n      end\n      \n      Mail.deliver do\n        from    'roger@moore.com'\n        to      '\"Long, stupid email address\" <mikel@test.lindsaar.net>'\n        subject 'invalid RFC2822'\n      end\n      delivery = File.join(Mail.delivery_method.settings[:location], 'mikel@test.lindsaar.net')\n      File.exists?(delivery).should be_true\n    end\n\n    it \"should use the base name of the file name to prevent file system traversal\" do\n      Mail.defaults do\n        delivery_method :file, :location => tmpdir\n      end\n      \n      Mail.deliver do\n        from    'roger@moore.com'\n        to      '../../../../../../../../../../../tmp/pwn'\n        subject 'evil hacker'\n      end\n\n      delivery = File.join(Mail.delivery_method.settings[:location], 'pwn')\n      File.exists?(delivery).should be_true\n    end\n\n  end\n  \nend\n"], "filenames": ["lib/mail/network/delivery_methods/file_delivery.rb", "spec/mail/network/delivery_methods/file_delivery_spec.rb"], "buggy_code_start_loc": [9, 76], "buggy_code_end_loc": [36, 76], "fixing_code_start_loc": [9, 77], "fixing_code_end_loc": [36, 92], "type": "CWE-22", "message": "Directory traversal vulnerability in lib/mail/network/delivery_methods/file_delivery.rb in the Mail gem before 2.4.4 for Ruby allows remote attackers to read arbitrary files via a .. (dot dot) in the to parameter.", "other": {"cve": {"id": "CVE-2012-2139", "sourceIdentifier": "secalert@redhat.com", "published": "2012-07-18T18:55:01.463", "lastModified": "2013-10-07T16:18:35.840", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Directory traversal vulnerability in lib/mail/network/delivery_methods/file_delivery.rb in the Mail gem before 2.4.4 for Ruby allows remote attackers to read arbitrary files via a .. (dot dot) in the to parameter."}, {"lang": "es", "value": "Vulnerabilidad de salto de directorio en lib/mail/network/delivery_methods/file_delivery.rb en la gema Mail antes de v2.4.3 para Ruby, permite a atacantes remotos para leer archivos de su elecci\u00f3n a trav\u00e9s de .. (punto punto) en el par\u00e1metro to."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rubygems:mail_gem:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.4.3", "matchCriteriaId": "F4FF0928-2CF5-4614-9DB1-5D6C7425F93E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubygems:mail_gem:2.3.2:*:*:*:*:*:*:*", "matchCriteriaId": "5CCE5E86-3A46-4B27-8626-4106778E990B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubygems:mail_gem:2.3.3:*:*:*:*:*:*:*", "matchCriteriaId": "B0743617-3C95-4DFE-B19B-425FE4A4876B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubygems:mail_gem:2.4.1:*:*:*:*:*:*:*", "matchCriteriaId": "BB91D56B-7AAE-4501-845F-84EA617BA3CC"}]}]}], "references": [{"url": "http://lists.fedoraproject.org/pipermail/package-announce/2012-May/080645.html", "source": "secalert@redhat.com"}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2012-May/080648.html", "source": "secalert@redhat.com"}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2012-May/080747.html", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2012/04/25/8", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2012/04/26/1", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.novell.com/show_bug.cgi?id=759092", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=816352", "source": "secalert@redhat.com"}, {"url": "https://github.com/mikel/mail/commit/29aca25218e4c82991400eb9b0c933626aefc98f", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/mikel/mail/commit/29aca25218e4c82991400eb9b0c933626aefc98f"}}