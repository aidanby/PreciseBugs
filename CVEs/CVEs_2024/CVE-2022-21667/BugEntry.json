{"buggy_code": ["import async from 'async';\nimport { HttpResponse, RecognizedString } from 'uWebSockets.js';\nimport { Server } from './server';\nimport { Utils } from './utils';\nimport { Log } from './log';\n\nconst v8 = require('v8');\n\nexport interface ChannelResponse {\n    subscription_count: number;\n    user_count?: number;\n    occupied: boolean;\n}\n\nexport class HttpHandler {\n    /**\n     * Initialize the HTTP handler.\n     */\n    constructor(protected server: Server) {\n        //\n    }\n\n    ready(res: HttpResponse) {\n        this.attachMiddleware(res, [\n            this.corsMiddleware,\n        ]).then(res => {\n            if (this.server.closing) {\n                this.serverErrorResponse(res, 'The server is closing. Choose another server. :)');\n            } else {\n                this.send(res, 'OK');\n            }\n        });\n    }\n\n    healthCheck(res: HttpResponse) {\n        this.attachMiddleware(res, [\n            this.corsMiddleware,\n        ]).then(res => {\n            this.send(res, 'OK');\n        });\n    }\n\n    usage(res: HttpResponse) {\n        this.attachMiddleware(res, [\n            this.corsMiddleware,\n        ]).then(res => {\n            let {\n                rss,\n                heapTotal,\n                external,\n                arrayBuffers,\n            } = process.memoryUsage();\n\n            let totalSize = v8.getHeapStatistics().total_available_size;\n            let usedSize = rss + heapTotal + external + arrayBuffers;\n            let freeSize = totalSize - usedSize;\n            let percentUsage = (usedSize / totalSize) * 100;\n\n            return this.sendJson(res, {\n                memory: {\n                    free: freeSize,\n                    used: usedSize,\n                    total: totalSize,\n                    percent: percentUsage,\n                },\n            });\n        });\n    }\n\n    metrics(res: HttpResponse) {\n        this.attachMiddleware(res, [\n            this.corsMiddleware,\n        ]).then(res => {\n            let handleError = err => {\n                this.serverErrorResponse(res, 'A server error has occurred.');\n            }\n\n            if (res.query.json) {\n                this.server.metricsManager\n                    .getMetricsAsJson()\n                    .then(metrics => {\n                        this.sendJson(res, metrics);\n                    })\n                    .catch(handleError);\n            } else {\n                this.server.metricsManager\n                    .getMetricsAsPlaintext()\n                    .then(metrics => {\n                        this.send(res, metrics);\n                    })\n                    .catch(handleError);\n            }\n        });\n    }\n\n    channels(res: HttpResponse) {\n        this.attachMiddleware(res, [\n            this.corsMiddleware,\n            this.appMiddleware,\n            this.authMiddleware,\n            this.readRateLimitingMiddleware,\n        ]).then(res => {\n            this.server.adapter.getChannels(res.params.appId).then(channels => {\n                let response: { [channel: string]: ChannelResponse } = [...channels].reduce((channels, [channel, connections]) => {\n                    if (connections.size === 0) {\n                        return channels;\n                    }\n\n                    channels[channel] = {\n                        subscription_count: connections.size,\n                        occupied: true,\n                    };\n\n                    return channels;\n                }, {});\n\n                return response;\n            }).catch(err => {\n                Log.error(err);\n\n                return this.serverErrorResponse(res, 'A server error has occurred.');\n            }).then(channels => {\n                let broadcastMessage = { channels };\n\n                this.server.metricsManager.markApiMessage(res.params.appId, {}, broadcastMessage);\n\n                this.sendJson(res, broadcastMessage);\n            });\n        });\n    }\n\n    channel(res: HttpResponse) {\n        this.attachMiddleware(res, [\n            this.corsMiddleware,\n            this.appMiddleware,\n            this.authMiddleware,\n            this.readRateLimitingMiddleware,\n        ]).then(res => {\n            let response: ChannelResponse;\n\n            this.server.adapter.getChannelSocketsCount(res.params.appId, res.params.channel).then(socketsCount => {\n                response = {\n                    subscription_count: socketsCount,\n                    occupied: socketsCount > 0,\n                };\n\n                // For presence channels, attach an user_count.\n                // Avoid extra call to get channel members if there are no sockets.\n                if (res.params.channel.startsWith('presence-')) {\n                    response.user_count = 0;\n\n                    if (response.subscription_count > 0) {\n                        this.server.adapter.getChannelMembersCount(res.params.appId, res.params.channel).then(membersCount => {\n                            let broadcastMessage = {\n                                ...response,\n                                ...{\n                                    user_count: membersCount,\n                                },\n                            };\n\n                            this.server.metricsManager.markApiMessage(res.params.appId, {}, broadcastMessage);\n\n                            this.sendJson(res, broadcastMessage);\n                        }).catch(err => {\n                            Log.error(err);\n\n                            return this.serverErrorResponse(res, 'A server error has occurred.');\n                        });\n\n                        return;\n                    }\n                }\n\n                this.server.metricsManager.markApiMessage(res.params.appId, {}, response);\n\n                return this.sendJson(res, response);\n            }).catch(err => {\n                Log.error(err);\n\n                return this.serverErrorResponse(res, 'A server error has occurred.');\n            });\n        });\n    }\n\n    channelUsers(res: HttpResponse) {\n        this.attachMiddleware(res, [\n            this.corsMiddleware,\n            this.appMiddleware,\n            this.authMiddleware,\n            this.readRateLimitingMiddleware,\n        ]).then(res => {\n            if (!res.params.channel.startsWith('presence-')) {\n                return this.badResponse(res, 'The channel must be a presence channel.');\n            }\n\n            this.server.adapter.getChannelMembers(res.params.appId, res.params.channel).then(members => {\n                let broadcastMessage = {\n                    users: [...members].map(([user_id, user_info]) => ({ id: user_id })),\n                };\n\n                this.server.metricsManager.markApiMessage(res.params.appId, {}, broadcastMessage);\n\n                this.sendJson(res, broadcastMessage);\n            });\n        });\n    }\n\n    events(res: HttpResponse) {\n        this.attachMiddleware(res, [\n            this.jsonBodyMiddleware,\n            this.corsMiddleware,\n            this.appMiddleware,\n            this.authMiddleware,\n            this.broadcastEventRateLimitingMiddleware,\n        ]).then(res => {\n            let message = res.body;\n\n            if (\n                (!message.channels && !message.channel) ||\n                !message.name ||\n                !message.data\n            ) {\n                return this.badResponse(res, 'The received data is incorrect');\n            }\n\n            let channels: string[] = message.channels || [message.channel];\n\n            // Make sure the channels length is not too big.\n            if (channels.length > this.server.options.eventLimits.maxChannelsAtOnce) {\n                return this.badResponse(res, `Cannot broadcast to more than ${this.server.options.eventLimits.maxChannelsAtOnce} channels at once`);\n            }\n\n            // Make sure the event name length is not too big.\n            if (message.name.length > this.server.options.eventLimits.maxNameLength) {\n                return this.badResponse(res, `Event name is too long. Maximum allowed size is ${this.server.options.eventLimits.maxNameLength}.`);\n            }\n\n            let payloadSizeInKb = Utils.dataToKilobytes(message.data);\n\n            // Make sure the total payload of the message body is not too big.\n            if (payloadSizeInKb > parseFloat(this.server.options.eventLimits.maxPayloadInKb as string)) {\n                return this.badResponse(res, `The event data should be less than ${this.server.options.eventLimits.maxPayloadInKb} KB.`);\n            }\n\n            channels.forEach(channel => {\n                this.server.adapter.send(res.params.appId, channel, JSON.stringify({\n                    event: message.name,\n                    channel,\n                    data: message.data,\n                }), message.socket_id);\n            });\n\n            this.server.metricsManager.markApiMessage(res.params.appId, message, { ok: true });\n\n            this.sendJson(res, {\n                ok: true,\n            });\n        });\n    }\n\n    notFound(res: HttpResponse) {\n        //Send status before any headers.\n        res.writeStatus('404 Not Found');\n\n        this.attachMiddleware(res, [\n            this.corsMiddleware,\n        ]).then(res => {\n            this.send(res, '', '404 Not Found');\n        });\n    }\n\n    protected badResponse(res: HttpResponse, error: string) {\n        return this.sendJson(res, { error, code: 400 }, '400 Invalid Request');\n    }\n\n    protected notFoundResponse(res: HttpResponse, error: string) {\n        return this.sendJson(res, { error, code: 404 }, '404 Not Found');\n    }\n\n    protected unauthorizedResponse(res: HttpResponse, error: string) {\n        return this.sendJson(res, { error, code: 401 }, '401 Unauthorized');\n    }\n\n    protected entityTooLargeResponse(res: HttpResponse, error: string) {\n        return this.sendJson(res, { error, code: 413 }, '413 Payload Too Large');\n    }\n\n    protected tooManyRequestsResponse(res: HttpResponse) {\n        return this.sendJson(res, { error: 'Too many requests.', code: 429 }, '429 Too Many Requests');\n    }\n\n    protected serverErrorResponse(res: HttpResponse, error: string) {\n        return this.sendJson(res, { error, code: 500 }, '500 Internal Server Error');\n    }\n\n    protected jsonBodyMiddleware(res: HttpResponse, next: CallableFunction): any {\n        this.readJson(res, (body, rawBody) => {\n            res.body = body;\n            res.rawBody = rawBody;\n\n            let requestSizeInMb = Utils.dataToMegabytes(rawBody);\n\n            if (requestSizeInMb > this.server.options.httpApi.requestLimitInMb) {\n                return this.entityTooLargeResponse(res, 'The payload size is too big.');\n            }\n\n            next(null, res);\n        }, err => {\n            return this.badResponse(res, 'The received data is incorrect.');\n        });\n    }\n\n    protected corsMiddleware(res: HttpResponse, next: CallableFunction): any {\n        res.writeHeader('Access-Control-Allow-Origin', this.server.options.cors.origin.join(', '));\n        res.writeHeader('Access-Control-Allow-Methods', this.server.options.cors.methods.join(', '));\n        res.writeHeader('Access-Control-Allow-Headers', this.server.options.cors.allowedHeaders.join(', '));\n\n        next(null, res);\n    }\n\n    protected appMiddleware(res: HttpResponse, next: CallableFunction): any {\n        return this.server.appManager.findById(res.params.appId).then(validApp => {\n            if (!validApp) {\n                return this.notFoundResponse(res, `The app ${res.params.appId} could not be found.`);\n            }\n\n            res.app = validApp;\n\n            next(null, res);\n        });\n    }\n\n    protected authMiddleware(res: HttpResponse, next: CallableFunction): any {\n        this.signatureIsValid(res).then(valid => {\n            if (valid) {\n                return next(null, res);\n            }\n\n            return this.unauthorizedResponse(res, 'The secret authentication failed');\n        });\n    }\n\n    protected readRateLimitingMiddleware(res: HttpResponse, next: CallableFunction): any {\n        this.server.rateLimiter.consumeReadRequestsPoints(1, res.app).then(response => {\n            if (response.canContinue) {\n                for (let header in response.headers) {\n                    res.writeHeader(header, '' + response.headers[header]);\n                }\n\n                return next(null, res);\n            }\n\n            this.tooManyRequestsResponse(res);\n        });\n    }\n\n    protected broadcastEventRateLimitingMiddleware(res: HttpResponse, next: CallableFunction): any {\n        let channels = res.body.channels || [res.body.channel];\n\n        this.server.rateLimiter.consumeBackendEventPoints(Math.max(channels.length, 1), res.app).then(response => {\n            if (response.canContinue) {\n                for (let header in response.headers) {\n                    res.writeHeader(header, '' + response.headers[header]);\n                }\n\n                return next(null, res);\n            }\n\n            this.tooManyRequestsResponse(res);\n        });\n    }\n\n    protected attachMiddleware(res: HttpResponse, functions: any[]): Promise<HttpResponse> {\n        return new Promise((resolve, reject) => {\n            let waterfallInit = callback => callback(null, res);\n\n            let abortHandlerMiddleware = (res, callback) => {\n                res.onAborted(() => {\n                    Log.warning({ message: 'Aborted request.', res });\n                    this.serverErrorResponse(res, 'Aborted request.');\n                });\n\n                callback(null, res);\n            };\n\n            async.waterfall([\n                waterfallInit.bind(this),\n                abortHandlerMiddleware.bind(this),\n                ...functions.map(fn => fn.bind(this)),\n            ], (err, res) => {\n                if (err) {\n                    this.serverErrorResponse(res, 'A server error has occurred.');\n                    Log.error(err);\n\n                    return reject({ res, err });\n                }\n\n                resolve(res);\n            });\n        });\n    }\n\n    /**\n     * Read the JSON content of a request.\n     */\n    protected readJson(res: HttpResponse, cb: CallableFunction, err: any) {\n        let buffer;\n\n        let loggingAction = (payload) => {\n            if (this.server.options.debug) {\n                Log.httpTitle('\u26a1 HTTP Payload received');\n                Log.http(payload);\n            }\n        };\n\n        res.onData((ab, isLast) => {\n            let chunk = Buffer.from(ab);\n\n            if (isLast) {\n                let json;\n                let raw;\n\n                if (buffer) {\n                    try {\n                        // @ts-ignore\n                        json = JSON.parse(Buffer.concat([buffer, chunk]));\n                    } catch (e) {\n                        res.close();\n                        return;\n                    }\n\n                    raw = Buffer.concat([buffer, chunk]).toString();\n\n                    cb(json, raw);\n                    loggingAction(json);\n                } else {\n                    try {\n                        // @ts-ignore\n                        json = JSON.parse(chunk);\n                        raw = chunk.toString();\n                    } catch (e) {\n                        res.close();\n                        return;\n                    }\n\n                    cb(json, raw);\n                    loggingAction(json);\n                }\n            } else {\n                if (buffer) {\n                    buffer = Buffer.concat([buffer, chunk]);\n                } else {\n                    buffer = Buffer.concat([chunk]);\n                }\n            }\n        });\n\n        res.onAborted(err);\n    }\n\n    /**\n     * Check is an incoming request can access the api.\n     */\n    protected signatureIsValid(res: HttpResponse): Promise<boolean> {\n        return this.getSignedToken(res).then(token => {\n            return token === res.query.auth_signature;\n        });\n    }\n\n    protected sendJson(res: HttpResponse, data: any, status: RecognizedString = '200 OK') {\n        return res.writeStatus(status)\n            .writeHeader('Content-Type', 'application/json')\n            // TODO: Remove after uWS19.4\n            // @ts-ignore Remove after uWS 19.4 release\n            .end(JSON.stringify(data), true);\n    }\n\n    protected send(res: HttpResponse, data: RecognizedString, status: RecognizedString = '200 OK') {\n        return res.writeStatus(status)\n            // TODO: Remove after uWS19.4\n            // @ts-ignore Remove after uWS 19.4 release\n            .end(data, true);\n    }\n\n    /**\n     * Get the signed token from the given request.\n     */\n    protected getSignedToken(res: HttpResponse): Promise<string> {\n        return Promise.resolve(res.app.signingTokenFromRequest(res));\n    }\n}\n"], "fixing_code": ["import async from 'async';\nimport { HttpResponse, RecognizedString } from 'uWebSockets.js';\nimport { Server } from './server';\nimport { Utils } from './utils';\nimport { Log } from './log';\n\nconst v8 = require('v8');\n\nexport interface ChannelResponse {\n    subscription_count: number;\n    user_count?: number;\n    occupied: boolean;\n}\n\nexport class HttpHandler {\n    /**\n     * Initialize the HTTP handler.\n     */\n    constructor(protected server: Server) {\n        //\n    }\n\n    ready(res: HttpResponse) {\n        this.attachMiddleware(res, [\n            this.corsMiddleware,\n        ]).then(res => {\n            if (this.server.closing) {\n                this.serverErrorResponse(res, 'The server is closing. Choose another server. :)');\n            } else {\n                this.send(res, 'OK');\n            }\n        });\n    }\n\n    healthCheck(res: HttpResponse) {\n        this.attachMiddleware(res, [\n            this.corsMiddleware,\n        ]).then(res => {\n            this.send(res, 'OK');\n        });\n    }\n\n    usage(res: HttpResponse) {\n        this.attachMiddleware(res, [\n            this.corsMiddleware,\n        ]).then(res => {\n            let {\n                rss,\n                heapTotal,\n                external,\n                arrayBuffers,\n            } = process.memoryUsage();\n\n            let totalSize = v8.getHeapStatistics().total_available_size;\n            let usedSize = rss + heapTotal + external + arrayBuffers;\n            let freeSize = totalSize - usedSize;\n            let percentUsage = (usedSize / totalSize) * 100;\n\n            return this.sendJson(res, {\n                memory: {\n                    free: freeSize,\n                    used: usedSize,\n                    total: totalSize,\n                    percent: percentUsage,\n                },\n            });\n        });\n    }\n\n    metrics(res: HttpResponse) {\n        this.attachMiddleware(res, [\n            this.corsMiddleware,\n        ]).then(res => {\n            let handleError = err => {\n                this.serverErrorResponse(res, 'A server error has occurred.');\n            }\n\n            if (res.query.json) {\n                this.server.metricsManager\n                    .getMetricsAsJson()\n                    .then(metrics => {\n                        this.sendJson(res, metrics);\n                    })\n                    .catch(handleError);\n            } else {\n                this.server.metricsManager\n                    .getMetricsAsPlaintext()\n                    .then(metrics => {\n                        this.send(res, metrics);\n                    })\n                    .catch(handleError);\n            }\n        });\n    }\n\n    channels(res: HttpResponse) {\n        this.attachMiddleware(res, [\n            this.corsMiddleware,\n            this.appMiddleware,\n            this.authMiddleware,\n            this.readRateLimitingMiddleware,\n        ]).then(res => {\n            this.server.adapter.getChannels(res.params.appId).then(channels => {\n                let response: { [channel: string]: ChannelResponse } = [...channels].reduce((channels, [channel, connections]) => {\n                    if (connections.size === 0) {\n                        return channels;\n                    }\n\n                    channels[channel] = {\n                        subscription_count: connections.size,\n                        occupied: true,\n                    };\n\n                    return channels;\n                }, {});\n\n                return response;\n            }).catch(err => {\n                Log.error(err);\n\n                return this.serverErrorResponse(res, 'A server error has occurred.');\n            }).then(channels => {\n                let broadcastMessage = { channels };\n\n                this.server.metricsManager.markApiMessage(res.params.appId, {}, broadcastMessage);\n\n                this.sendJson(res, broadcastMessage);\n            });\n        });\n    }\n\n    channel(res: HttpResponse) {\n        this.attachMiddleware(res, [\n            this.corsMiddleware,\n            this.appMiddleware,\n            this.authMiddleware,\n            this.readRateLimitingMiddleware,\n        ]).then(res => {\n            let response: ChannelResponse;\n\n            this.server.adapter.getChannelSocketsCount(res.params.appId, res.params.channel).then(socketsCount => {\n                response = {\n                    subscription_count: socketsCount,\n                    occupied: socketsCount > 0,\n                };\n\n                // For presence channels, attach an user_count.\n                // Avoid extra call to get channel members if there are no sockets.\n                if (res.params.channel.startsWith('presence-')) {\n                    response.user_count = 0;\n\n                    if (response.subscription_count > 0) {\n                        this.server.adapter.getChannelMembersCount(res.params.appId, res.params.channel).then(membersCount => {\n                            let broadcastMessage = {\n                                ...response,\n                                ...{\n                                    user_count: membersCount,\n                                },\n                            };\n\n                            this.server.metricsManager.markApiMessage(res.params.appId, {}, broadcastMessage);\n\n                            this.sendJson(res, broadcastMessage);\n                        }).catch(err => {\n                            Log.error(err);\n\n                            return this.serverErrorResponse(res, 'A server error has occurred.');\n                        });\n\n                        return;\n                    }\n                }\n\n                this.server.metricsManager.markApiMessage(res.params.appId, {}, response);\n\n                return this.sendJson(res, response);\n            }).catch(err => {\n                Log.error(err);\n\n                return this.serverErrorResponse(res, 'A server error has occurred.');\n            });\n        });\n    }\n\n    channelUsers(res: HttpResponse) {\n        this.attachMiddleware(res, [\n            this.corsMiddleware,\n            this.appMiddleware,\n            this.authMiddleware,\n            this.readRateLimitingMiddleware,\n        ]).then(res => {\n            if (!res.params.channel.startsWith('presence-')) {\n                return this.badResponse(res, 'The channel must be a presence channel.');\n            }\n\n            this.server.adapter.getChannelMembers(res.params.appId, res.params.channel).then(members => {\n                let broadcastMessage = {\n                    users: [...members].map(([user_id, user_info]) => ({ id: user_id })),\n                };\n\n                this.server.metricsManager.markApiMessage(res.params.appId, {}, broadcastMessage);\n\n                this.sendJson(res, broadcastMessage);\n            });\n        });\n    }\n\n    events(res: HttpResponse) {\n        this.attachMiddleware(res, [\n            this.jsonBodyMiddleware,\n            this.corsMiddleware,\n            this.appMiddleware,\n            this.authMiddleware,\n            this.broadcastEventRateLimitingMiddleware,\n        ]).then(res => {\n            let message = res.body;\n\n            if (\n                (!message.channels && !message.channel) ||\n                !message.name ||\n                !message.data\n            ) {\n                return this.badResponse(res, 'The received data is incorrect');\n            }\n\n            let channels: string[] = message.channels || [message.channel];\n\n            // Make sure the channels length is not too big.\n            if (channels.length > this.server.options.eventLimits.maxChannelsAtOnce) {\n                return this.badResponse(res, `Cannot broadcast to more than ${this.server.options.eventLimits.maxChannelsAtOnce} channels at once`);\n            }\n\n            // Make sure the event name length is not too big.\n            if (message.name.length > this.server.options.eventLimits.maxNameLength) {\n                return this.badResponse(res, `Event name is too long. Maximum allowed size is ${this.server.options.eventLimits.maxNameLength}.`);\n            }\n\n            let payloadSizeInKb = Utils.dataToKilobytes(message.data);\n\n            // Make sure the total payload of the message body is not too big.\n            if (payloadSizeInKb > parseFloat(this.server.options.eventLimits.maxPayloadInKb as string)) {\n                return this.badResponse(res, `The event data should be less than ${this.server.options.eventLimits.maxPayloadInKb} KB.`);\n            }\n\n            channels.forEach(channel => {\n                this.server.adapter.send(res.params.appId, channel, JSON.stringify({\n                    event: message.name,\n                    channel,\n                    data: message.data,\n                }), message.socket_id);\n            });\n\n            this.server.metricsManager.markApiMessage(res.params.appId, message, { ok: true });\n\n            this.sendJson(res, {\n                ok: true,\n            });\n        });\n    }\n\n    notFound(res: HttpResponse) {\n        //Send status before any headers.\n        res.writeStatus('404 Not Found');\n\n        this.attachMiddleware(res, [\n            this.corsMiddleware,\n        ]).then(res => {\n            this.send(res, '', '404 Not Found');\n        });\n    }\n\n    protected badResponse(res: HttpResponse, error: string) {\n        return this.sendJson(res, { error, code: 400 }, '400 Invalid Request');\n    }\n\n    protected notFoundResponse(res: HttpResponse, error: string) {\n        return this.sendJson(res, { error, code: 404 }, '404 Not Found');\n    }\n\n    protected unauthorizedResponse(res: HttpResponse, error: string) {\n        return this.sendJson(res, { error, code: 401 }, '401 Unauthorized');\n    }\n\n    protected entityTooLargeResponse(res: HttpResponse, error: string) {\n        return this.sendJson(res, { error, code: 413 }, '413 Payload Too Large');\n    }\n\n    protected tooManyRequestsResponse(res: HttpResponse) {\n        return this.sendJson(res, { error: 'Too many requests.', code: 429 }, '429 Too Many Requests');\n    }\n\n    protected serverErrorResponse(res: HttpResponse, error: string) {\n        return this.sendJson(res, { error, code: 500 }, '500 Internal Server Error');\n    }\n\n    protected jsonBodyMiddleware(res: HttpResponse, next: CallableFunction): any {\n        this.readJson(res, (body, rawBody) => {\n            res.body = body;\n            res.rawBody = rawBody;\n\n            let requestSizeInMb = Utils.dataToMegabytes(rawBody);\n\n            if (requestSizeInMb > this.server.options.httpApi.requestLimitInMb) {\n                return this.entityTooLargeResponse(res, 'The payload size is too big.');\n            }\n\n            next(null, res);\n        }, err => {\n            return this.badResponse(res, 'The received data is incorrect.');\n        });\n    }\n\n    protected corsMiddleware(res: HttpResponse, next: CallableFunction): any {\n        res.writeHeader('Access-Control-Allow-Origin', this.server.options.cors.origin.join(', '));\n        res.writeHeader('Access-Control-Allow-Methods', this.server.options.cors.methods.join(', '));\n        res.writeHeader('Access-Control-Allow-Headers', this.server.options.cors.allowedHeaders.join(', '));\n\n        next(null, res);\n    }\n\n    protected appMiddleware(res: HttpResponse, next: CallableFunction): any {\n        return this.server.appManager.findById(res.params.appId).then(validApp => {\n            if (!validApp) {\n                return this.notFoundResponse(res, `The app ${res.params.appId} could not be found.`);\n            }\n\n            res.app = validApp;\n\n            next(null, res);\n        });\n    }\n\n    protected authMiddleware(res: HttpResponse, next: CallableFunction): any {\n        this.signatureIsValid(res).then(valid => {\n            if (valid) {\n                return next(null, res);\n            }\n\n            return this.unauthorizedResponse(res, 'The secret authentication failed');\n        });\n    }\n\n    protected readRateLimitingMiddleware(res: HttpResponse, next: CallableFunction): any {\n        this.server.rateLimiter.consumeReadRequestsPoints(1, res.app).then(response => {\n            if (response.canContinue) {\n                for (let header in response.headers) {\n                    res.writeHeader(header, '' + response.headers[header]);\n                }\n\n                return next(null, res);\n            }\n\n            this.tooManyRequestsResponse(res);\n        });\n    }\n\n    protected broadcastEventRateLimitingMiddleware(res: HttpResponse, next: CallableFunction): any {\n        let channels = res.body.channels || [res.body.channel];\n\n        this.server.rateLimiter.consumeBackendEventPoints(Math.max(channels.length, 1), res.app).then(response => {\n            if (response.canContinue) {\n                for (let header in response.headers) {\n                    res.writeHeader(header, '' + response.headers[header]);\n                }\n\n                return next(null, res);\n            }\n\n            this.tooManyRequestsResponse(res);\n        });\n    }\n\n    protected attachMiddleware(res: HttpResponse, functions: any[]): Promise<HttpResponse> {\n        return new Promise((resolve, reject) => {\n            let waterfallInit = callback => callback(null, res);\n\n            let abortHandlerMiddleware = (res, callback) => {\n                res.onAborted(() => {\n                    Log.warning({ message: 'Aborted request.', res });\n                    this.serverErrorResponse(res, 'Aborted request.');\n                });\n\n                callback(null, res);\n            };\n\n            async.waterfall([\n                waterfallInit.bind(this),\n                abortHandlerMiddleware.bind(this),\n                ...functions.map(fn => fn.bind(this)),\n            ], (err, res) => {\n                if (err) {\n                    this.serverErrorResponse(res, 'A server error has occurred.');\n                    Log.error(err);\n\n                    return reject({ res, err });\n                }\n\n                resolve(res);\n            });\n        });\n    }\n\n    /**\n     * Read the JSON content of a request.\n     */\n    protected readJson(res: HttpResponse, cb: CallableFunction, err: any) {\n        let buffer;\n\n        let loggingAction = (payload) => {\n            if (this.server.options.debug) {\n                Log.httpTitle('\u26a1 HTTP Payload received');\n                Log.http(payload);\n            }\n        };\n\n        res.onData((ab, isLast) => {\n            let chunk = Buffer.from(ab);\n\n            if (isLast) {\n                let json = {};\n                let raw = '{}';\n\n                if (buffer) {\n                    try {\n                        // @ts-ignore\n                        json = JSON.parse(Buffer.concat([buffer, chunk]));\n                    } catch (e) {\n                        //\n                    }\n\n                    try {\n                        raw = Buffer.concat([buffer, chunk]).toString();\n                    } catch (e) {\n                        //\n                    }\n\n                    cb(json, raw);\n                    loggingAction(json);\n                } else {\n                    try {\n                        // @ts-ignore\n                        json = JSON.parse(chunk);\n                        raw = chunk.toString();\n                    } catch (e) {\n                        //\n                    }\n\n                    cb(json, raw);\n                    loggingAction(json);\n                }\n            } else {\n                if (buffer) {\n                    buffer = Buffer.concat([buffer, chunk]);\n                } else {\n                    buffer = Buffer.concat([chunk]);\n                }\n            }\n        });\n\n        res.onAborted(err);\n    }\n\n    /**\n     * Check is an incoming request can access the api.\n     */\n    protected signatureIsValid(res: HttpResponse): Promise<boolean> {\n        return this.getSignedToken(res).then(token => {\n            return token === res.query.auth_signature;\n        });\n    }\n\n    protected sendJson(res: HttpResponse, data: any, status: RecognizedString = '200 OK') {\n        return res.writeStatus(status)\n            .writeHeader('Content-Type', 'application/json')\n            // TODO: Remove after uWS19.4\n            // @ts-ignore Remove after uWS 19.4 release\n            .end(JSON.stringify(data), true);\n    }\n\n    protected send(res: HttpResponse, data: RecognizedString, status: RecognizedString = '200 OK') {\n        return res.writeStatus(status)\n            // TODO: Remove after uWS19.4\n            // @ts-ignore Remove after uWS 19.4 release\n            .end(data, true);\n    }\n\n    /**\n     * Get the signed token from the given request.\n     */\n    protected getSignedToken(res: HttpResponse): Promise<string> {\n        return Promise.resolve(res.app.signingTokenFromRequest(res));\n    }\n}\n"], "filenames": ["src/http-handler.ts"], "buggy_code_start_loc": [420], "buggy_code_end_loc": [444], "fixing_code_start_loc": [420], "fixing_code_end_loc": [446], "type": "CWE-755", "message": "soketi is an open-source WebSockets server. There is an unhandled case when reading POST requests which results in the server crashing if it could not read the body of a request. In the event that a POST request is sent to any endpoint of the server with an empty body, even unauthenticated with the Pusher Protocol, it will crash the server. All users that run the server are affected by this vulnerability and it's highly recommended to upgrade to the latest patch. There are no workarounds for this issue.", "other": {"cve": {"id": "CVE-2022-21667", "sourceIdentifier": "security-advisories@github.com", "published": "2022-01-10T14:12:31.747", "lastModified": "2022-01-14T16:45:42.420", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "soketi is an open-source WebSockets server. There is an unhandled case when reading POST requests which results in the server crashing if it could not read the body of a request. In the event that a POST request is sent to any endpoint of the server with an empty body, even unauthenticated with the Pusher Protocol, it will crash the server. All users that run the server are affected by this vulnerability and it's highly recommended to upgrade to the latest patch. There are no workarounds for this issue."}, {"lang": "es", "value": "soketi es un servidor de WebSockets de c\u00f3digo abierto. Se presenta un caso no manejado cuando son le\u00eddas peticiones POST que hace que el servidor se bloquee si no puede leer el cuerpo de una petici\u00f3n. En el caso de que sea enviado una petici\u00f3n POST a cualquier endpoint del servidor con un cuerpo vac\u00edo, incluso sin autenticar con el protocolo Pusher, bloquear\u00e1 el servidor. Todos los usuarios que ejecutan el servidor est\u00e1n afectados por esta vulnerabilidad y es muy recomendable actualizar al \u00faltimo parche. No se presentan medidas de mitigaci\u00f3n para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-755"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-755"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:soketi_project:soketi:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "0.24.1", "matchCriteriaId": "2E363318-9A9C-4BB6-929B-C610CE261BFD"}]}]}], "references": [{"url": "https://github.com/soketi/soketi/commit/4b12efef9c31117c36a0a0f1c3aa32114e86364b", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/soketi/soketi/releases/tag/0.24.1", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/soketi/soketi/security/advisories/GHSA-86ch-6w7v-v6xf", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/soketi/soketi/commit/4b12efef9c31117c36a0a0f1c3aa32114e86364b"}}