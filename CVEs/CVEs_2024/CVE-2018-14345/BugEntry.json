{"buggy_code": ["/***************************************************************************\n* Copyright (c) 2014-2015 Pier Luigi Fiorini <pierluigi.fiorini@gmail.com>\n* Copyright (c) 2014 Martin B\u0159\u00edza <mbriza@redhat.com>\n* Copyright (c) 2013 Abdurrahman AVCI <abdurrahmanavci@gmail.com>\n*\n* This program is free software; you can redistribute it and/or modify\n* it under the terms of the GNU General Public License as published by\n* the Free Software Foundation; either version 2 of the License, or\n* (at your option) any later version.\n*\n* This program is distributed in the hope that it will be useful,\n* but WITHOUT ANY WARRANTY; without even the implied warranty of\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n* GNU General Public License for more details.\n*\n* You should have received a copy of the GNU General Public License\n* along with this program; if not, write to the\n* Free Software Foundation, Inc.,\n* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n***************************************************************************/\n\n#include \"Display.h\"\n\n#include \"Configuration.h\"\n#include \"DaemonApp.h\"\n#include \"DisplayManager.h\"\n#include \"XorgDisplayServer.h\"\n#include \"Seat.h\"\n#include \"SocketServer.h\"\n#include \"Greeter.h\"\n#include \"Utils.h\"\n#include \"SignalHandler.h\"\n#include \"VirtualTerminal.h\"\n\n#include <QDebug>\n#include <QFile>\n#include <QTimer>\n\n#include <pwd.h>\n#include <unistd.h>\n\n#include <QDBusConnection>\n#include <QDBusMessage>\n#include <QDBusReply>\n\n#include \"Login1Manager.h\"\n#include \"Login1Session.h\"\n\n\nnamespace SDDM {\n    Display::Display(const int terminalId, Seat *parent) : QObject(parent),\n        m_terminalId(terminalId),\n        m_auth(new Auth(this)),\n        m_displayServer(new XorgDisplayServer(this)),\n        m_seat(parent),\n        m_socketServer(new SocketServer(this)),\n        m_greeter(new Greeter(this)) {\n\n        // respond to authentication requests\n        m_auth->setVerbose(true);\n        connect(m_auth, SIGNAL(requestChanged()), this, SLOT(slotRequestChanged()));\n        connect(m_auth, SIGNAL(authentication(QString,bool)), this, SLOT(slotAuthenticationFinished(QString,bool)));\n        connect(m_auth, SIGNAL(session(bool)), this, SLOT(slotSessionStarted(bool)));\n        connect(m_auth, SIGNAL(finished(Auth::HelperExitStatus)), this, SLOT(slotHelperFinished(Auth::HelperExitStatus)));\n        connect(m_auth, SIGNAL(info(QString,Auth::Info)), this, SLOT(slotAuthInfo(QString,Auth::Info)));\n        connect(m_auth, SIGNAL(error(QString,Auth::Error)), this, SLOT(slotAuthError(QString,Auth::Error)));\n\n        // restart display after display server ended\n        connect(m_displayServer, SIGNAL(started()), this, SLOT(displayServerStarted()));\n        connect(m_displayServer, SIGNAL(stopped()), this, SLOT(stop()));\n\n        // connect login signal\n        connect(m_socketServer, SIGNAL(login(QLocalSocket*,QString,QString,Session)),\n                this, SLOT(login(QLocalSocket*,QString,QString,Session)));\n\n        // connect login result signals\n        connect(this, SIGNAL(loginFailed(QLocalSocket*)), m_socketServer, SLOT(loginFailed(QLocalSocket*)));\n        connect(this, SIGNAL(loginSucceeded(QLocalSocket*)), m_socketServer, SLOT(loginSucceeded(QLocalSocket*)));\n    }\n\n    Display::~Display() {\n        stop();\n    }\n\n    QString Display::displayId() const {\n        return m_displayServer->display();\n    }\n\n    const int Display::terminalId() const {\n        return m_terminalId;\n    }\n\n    const QString &Display::name() const {\n        return m_displayServer->display();\n    }\n\n    QString Display::sessionType() const {\n        return m_displayServer->sessionType();\n    }\n\n    Seat *Display::seat() const {\n        return m_seat;\n    }\n\n    void Display::start() {\n        // check flag\n        if (m_started)\n            return;\n\n        // start display server\n        if (!m_displayServer->start()) {\n            qFatal(\"Display server failed to start. Exiting\");\n        }\n    }\n\n    bool Display::attemptAutologin() {\n        Session::Type sessionType = Session::X11Session;\n\n        // determine session type\n        QString autologinSession = mainConfig.Autologin.Session.get();\n        // not configured: try last successful logged in\n        if (autologinSession.isEmpty()) {\n            autologinSession = stateConfig.Last.Session.get();\n        }\n        if (findSessionEntry(mainConfig.X11.SessionDir.get(), autologinSession)) {\n            sessionType = Session::X11Session;\n        } else if (findSessionEntry(mainConfig.Wayland.SessionDir.get(), autologinSession)) {\n            sessionType = Session::WaylandSession;\n        } else {\n            qCritical() << \"Unable to find autologin session entry\" << autologinSession;\n            return false;\n        }\n\n        Session session;\n        session.setTo(sessionType, autologinSession);\n\n        m_auth->setAutologin(true);\n        startAuth(mainConfig.Autologin.User.get(), QString(), session);\n\n        return true;\n    }\n\n    void Display::displayServerStarted() {\n        // check flag\n        if (m_started)\n            return;\n\n        // setup display\n        m_displayServer->setupDisplay();\n\n        // log message\n        qDebug() << \"Display server started.\";\n\n        if ((daemonApp->first || mainConfig.Autologin.Relogin.get()) &&\n            !mainConfig.Autologin.User.get().isEmpty()) {\n            // reset first flag\n            daemonApp->first = false;\n\n            // set flags\n            m_started = true;\n\n            bool success = attemptAutologin();\n            if (success) {\n                return;\n            }\n        }\n\n        // start socket server\n        m_socketServer->start(m_displayServer->display());\n\n        if (!daemonApp->testing()) {\n            // change the owner and group of the socket to avoid permission denied errors\n            struct passwd *pw = getpwnam(\"sddm\");\n            if (pw) {\n                if (chown(qPrintable(m_socketServer->socketAddress()), pw->pw_uid, pw->pw_gid) == -1) {\n                    qWarning() << \"Failed to change owner of the socket\";\n                    return;\n                }\n            }\n        }\n\n        // set greeter params\n        m_greeter->setDisplay(this);\n        m_greeter->setAuthPath(qobject_cast<XorgDisplayServer *>(m_displayServer)->authPath());\n        m_greeter->setSocket(m_socketServer->socketAddress());\n        m_greeter->setTheme(findGreeterTheme());\n\n        // start greeter\n        m_greeter->start();\n\n        // reset first flag\n        daemonApp->first = false;\n\n        // set flags\n        m_started = true;\n    }\n\n    void Display::stop() {\n        // check flag\n        if (!m_started)\n            return;\n\n        // stop the greeter\n        m_greeter->stop();\n\n        // stop socket server\n        m_socketServer->stop();\n\n        // stop display server\n        m_displayServer->blockSignals(true);\n        m_displayServer->stop();\n        m_displayServer->blockSignals(false);\n\n        // reset flag\n        m_started = false;\n\n        // emit signal\n        emit stopped();\n    }\n\n    void Display::login(QLocalSocket *socket,\n                        const QString &user, const QString &password,\n                        const Session &session) {\n        m_socket = socket;\n\n        //the SDDM user has special privileges that skip password checking so that we can load the greeter\n        //block ever trying to log in as the SDDM user\n        if (user == QLatin1String(\"sddm\")) {\n            return;\n        }\n\n        // authenticate\n        startAuth(user, password, session);\n    }\n\n    QString Display::findGreeterTheme() const {\n        QString themeName = mainConfig.Theme.Current.get();\n\n        // an unconfigured theme means the user wants to load the\n        // default theme from the resources\n        if (themeName.isEmpty())\n            return QString();\n\n        QDir dir(mainConfig.Theme.ThemeDir.get());\n\n        // return the default theme if it exists\n        if (dir.exists(themeName))\n            return dir.absoluteFilePath(themeName);\n\n        // otherwise use the embedded theme\n        qWarning() << \"The configured theme\" << themeName << \"doesn't exist, using the embedded theme instead\";\n        return QString();\n    }\n\n    bool Display::findSessionEntry(const QDir &dir, const QString &name) const {\n        QString fileName = name;\n\n        // append extension\n        const QString extension = QStringLiteral(\".desktop\");\n        if (!fileName.endsWith(extension))\n            fileName += extension;\n\n        return dir.exists(fileName);\n    }\n\n    void Display::startAuth(const QString &user, const QString &password, const Session &session) {\n        m_passPhrase = password;\n\n        // sanity check\n        if (!session.isValid()) {\n            qCritical() << \"Invalid session\" << session.fileName();\n            return;\n        }\n        if (session.xdgSessionType().isEmpty()) {\n            qCritical() << \"Failed to find XDG session type for session\" << session.fileName();\n            return;\n        }\n        if (session.exec().isEmpty()) {\n            qCritical() << \"Failed to find command for session\" << session.fileName();\n            return;\n        }\n\n        QString existingSessionId;\n\n        if (Logind::isAvailable() && mainConfig.Users.ReuseSession.get()) {\n            OrgFreedesktopLogin1ManagerInterface manager(Logind::serviceName(), Logind::managerPath(), QDBusConnection::systemBus());\n            auto reply = manager.ListSessions();\n            reply.waitForFinished();\n\n            foreach(const SessionInfo &s, reply.value()) {\n                if (s.userName == user) {\n                    OrgFreedesktopLogin1SessionInterface session(Logind::serviceName(), s.sessionPath.path(), QDBusConnection::systemBus());\n                    if (session.service() == QLatin1String(\"sddm\")) {\n                        existingSessionId =  s.sessionId;\n                        break;\n                    }\n                }\n            }\n        }\n\n        // cache last session\n        m_lastSession = session;\n\n        // save session desktop file name, we'll use it to set the\n        // last session later, in slotAuthenticationFinished()\n        m_sessionName = session.fileName();\n\n        // some information\n        qDebug() << \"Session\" << m_sessionName << \"selected, command:\" << session.exec();\n\n        // create new VT for Wayland sessions otherwise use greeter vt\n        int vt = terminalId();\n        if (session.xdgSessionType() == QLatin1String(\"wayland\"))\n            vt = VirtualTerminal::setUpNewVt();\n        m_lastSession.setVt(vt);\n\n        QProcessEnvironment env;\n        env.insert(QStringLiteral(\"PATH\"), mainConfig.Users.DefaultPath.get());\n        if (session.xdgSessionType() == QLatin1String(\"x11\"))\n            env.insert(QStringLiteral(\"DISPLAY\"), name());\n        env.insert(QStringLiteral(\"XDG_SEAT_PATH\"), daemonApp->displayManager()->seatPath(seat()->name()));\n        env.insert(QStringLiteral(\"XDG_SESSION_PATH\"), daemonApp->displayManager()->sessionPath(QStringLiteral(\"Session%1\").arg(daemonApp->newSessionId())));\n        env.insert(QStringLiteral(\"DESKTOP_SESSION\"), session.desktopSession());\n        env.insert(QStringLiteral(\"XDG_CURRENT_DESKTOP\"), session.desktopNames());\n        env.insert(QStringLiteral(\"XDG_SESSION_CLASS\"), QStringLiteral(\"user\"));\n        env.insert(QStringLiteral(\"XDG_SESSION_TYPE\"), session.xdgSessionType());\n        env.insert(QStringLiteral(\"XDG_SEAT\"), seat()->name());\n\n        env.insert(QStringLiteral(\"XDG_SESSION_DESKTOP\"), session.desktopNames());\n        if (seat()->name() == QLatin1String(\"seat0\")) {\n            env.insert(QStringLiteral(\"XDG_VTNR\"), QString::number(vt));\n        }\n\n        m_auth->insertEnvironment(env);\n\n        m_auth->setUser(user);\n        if (existingSessionId.isNull()) {\n            m_auth->setSession(session.exec());\n        } else {\n            //we only want to unlock the session if we can lock in, so we want to go via PAM auth, but not start a new session\n            //by not setting the session and the helper will emit authentication and then quit\n            connect(m_auth, &Auth::authentication, this, [=](){\n                qDebug() << \"activating existing seat\";\n                OrgFreedesktopLogin1ManagerInterface manager(Logind::serviceName(), Logind::managerPath(), QDBusConnection::systemBus());\n                manager.UnlockSession(existingSessionId);\n                manager.ActivateSession(existingSessionId);\n            });\n        }\n        m_auth->start();\n    }\n\n    void Display::slotAuthenticationFinished(const QString &user, bool success) {\n        if (success) {\n            qDebug() << \"Authenticated successfully\";\n\n            m_auth->setCookie(qobject_cast<XorgDisplayServer *>(m_displayServer)->cookie());\n\n            // save last user and last session\n            if (mainConfig.Users.RememberLastUser.get())\n                stateConfig.Last.User.set(m_auth->user());\n            else\n                stateConfig.Last.User.setDefault();\n            if (mainConfig.Users.RememberLastSession.get())\n                stateConfig.Last.Session.set(m_sessionName);\n            else\n                stateConfig.Last.Session.setDefault();\n            stateConfig.save();\n\n            // switch to the new VT for Wayland sessions\n            if (m_lastSession.xdgSessionType() == QLatin1String(\"wayland\"))\n                // set vt_auto to false, so handle the vt switch yourself (VT_PROCESS)\n                VirtualTerminal::jumpToVt(m_lastSession.vt(), false);\n\n            if (m_socket)\n                emit loginSucceeded(m_socket);\n        } else if (m_socket) {\n            qDebug() << \"Authentication failure\";\n            emit loginFailed(m_socket);\n        }\n        m_socket = nullptr;\n    }\n\n    void Display::slotAuthInfo(const QString &message, Auth::Info info) {\n        // TODO: presentable to the user, eventually\n        Q_UNUSED(info);\n        qWarning() << \"Authentication information:\" << message;\n    }\n\n    void Display::slotAuthError(const QString &message, Auth::Error error) {\n        // TODO: handle more errors\n        qWarning() << \"Authentication error:\" << message;\n\n        if (!m_socket)\n            return;\n\n        if (error == Auth::ERROR_AUTHENTICATION)\n            emit loginFailed(m_socket);\n    }\n\n    void Display::slotHelperFinished(Auth::HelperExitStatus status) {\n        // Don't restart greeter and display server unless sddm-helper exited\n        // with an internal error or the user session finished successfully,\n        // we want to avoid greeter from restarting when an authentication\n        // error happens (in this case we want to show the message from the\n        // greeter\n        if (status != Auth::HELPER_AUTH_ERROR)\n            stop();\n    }\n\n    void Display::slotRequestChanged() {\n        if (m_auth->request()->prompts().length() == 1) {\n            m_auth->request()->prompts()[0]->setResponse(qPrintable(m_passPhrase));\n            m_auth->request()->done();\n        } else if (m_auth->request()->prompts().length() == 2) {\n            m_auth->request()->prompts()[0]->setResponse(qPrintable(m_auth->user()));\n            m_auth->request()->prompts()[1]->setResponse(qPrintable(m_passPhrase));\n            m_auth->request()->done();\n        }\n    }\n\n    void Display::slotSessionStarted(bool success) {\n        qDebug() << \"Session started\";\n    }\n}\n", "/*\n * PAM authentication backend\n * Copyright (C) 2013 Martin B\u0159\u00edza <mbriza@redhat.com>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n */\n\n#include \"PamBackend.h\"\n#include \"PamHandle.h\"\n#include \"HelperApp.h\"\n#include \"UserSession.h\"\n#include \"Auth.h\"\n\n#include <QtCore/QString>\n#include <QtCore/QDebug>\n\n#include <stdlib.h>\n\nnamespace SDDM {\n    static Request loginRequest {\n        {   { AuthPrompt::LOGIN_USER, QStringLiteral(\"login:\"), false },\n            { AuthPrompt::LOGIN_PASSWORD, QStringLiteral(\"Password: \"), true }\n        }\n    };\n\n    static Request changePassRequest {\n        {   { AuthPrompt::CHANGE_CURRENT, QStringLiteral(\"(current) UNIX password: \"), true },\n            { AuthPrompt::CHANGE_NEW, QStringLiteral(\"New password: \"), true },\n            { AuthPrompt::CHANGE_REPEAT, QStringLiteral(\"Retype new password: \"), true }\n        }\n    };\n\n    static Request changePassNoOldRequest {\n        {   { AuthPrompt::CHANGE_NEW, QStringLiteral(\"New password: \"), true },\n            { AuthPrompt::CHANGE_REPEAT, QStringLiteral(\"Retype new password: \"), true }\n        }\n    };\n\n    static Request invalidRequest { {} };\n\n    static Prompt invalidPrompt {};\n\n    PamData::PamData() { }\n\n    AuthPrompt::Type PamData::detectPrompt(const struct pam_message* msg) const {\n        if (msg->msg_style == PAM_PROMPT_ECHO_OFF) {\n            QString message = QString::fromLocal8Bit(msg->msg);\n            if (message.indexOf(QRegExp(QStringLiteral(\"\\\\bpassword\\\\b\"), Qt::CaseInsensitive)) >= 0) {\n                if (message.indexOf(QRegExp(QStringLiteral(\"\\\\b(re-?(enter|type)|again|confirm|repeat)\\\\b\"), Qt::CaseInsensitive)) >= 0) {\n                    return AuthPrompt::CHANGE_REPEAT;\n                }\n                else if (message.indexOf(QRegExp(QStringLiteral(\"\\\\bnew\\\\b\"), Qt::CaseInsensitive)) >= 0) {\n                    return AuthPrompt::CHANGE_NEW;\n                }\n                else if (message.indexOf(QRegExp(QStringLiteral(\"\\\\b(old|current)\\\\b\"), Qt::CaseInsensitive)) >= 0) {\n                    return AuthPrompt::CHANGE_CURRENT;\n                }\n                else {\n                    return AuthPrompt::LOGIN_PASSWORD;\n                }\n            }\n        }\n        else {\n            return AuthPrompt::LOGIN_USER;\n        }\n\n        return AuthPrompt::UNKNOWN;\n    }\n\n    const Prompt& PamData::findPrompt(const struct pam_message* msg) const {\n        AuthPrompt::Type type = detectPrompt(msg);\n\n        for (const Prompt &p : m_currentRequest.prompts) {\n            if (type == p.type && p.message == QString::fromLocal8Bit(msg->msg))\n                return p;\n        }\n\n        return invalidPrompt;\n    }\n\n    Prompt& PamData::findPrompt(const struct pam_message* msg) {\n        AuthPrompt::Type type = detectPrompt(msg);\n\n        for (Prompt &p : m_currentRequest.prompts) {\n            if (type == AuthPrompt::UNKNOWN && QString::fromLocal8Bit(msg->msg) == p.message)\n                return p;\n            if (type == p.type)\n                return p;\n        }\n\n        return invalidPrompt;\n    }\n\n    /*\n    * Expects an empty prompt list if the previous request has been processed\n    */\n    bool PamData::insertPrompt(const struct pam_message* msg, bool predict) {\n        Prompt &p = findPrompt(msg);\n\n        // first, check if we already have stored this propmpt\n        if (p.valid()) {\n            // we have a response already - do nothing\n            if (m_sent)\n                return false;\n            // we don't have a response yet - replace the message and prepare to send it\n            p.message = QString::fromLocal8Bit(msg->msg);\n            return true;\n        }\n        // this prompt is not stored but we have some prompts\n        else if (m_currentRequest.prompts.length() != 0) {\n            // check if we have already sent this - if we did, get rid of the answers\n            if (m_sent) {\n                m_currentRequest.clear();\n                m_sent = false;\n            }\n        }\n\n        // we'll predict what will come next\n        if (predict) {\n            AuthPrompt::Type type = detectPrompt(msg);\n            switch (type) {\n                case AuthPrompt::LOGIN_USER:\n                    m_currentRequest = Request(loginRequest);\n                    return true;\n                case AuthPrompt::CHANGE_CURRENT:\n                    m_currentRequest = Request(changePassRequest);\n                    return true;\n                case AuthPrompt::CHANGE_NEW:\n                    m_currentRequest = Request(changePassNoOldRequest);\n                    return true;\n                default:\n                    break;\n            }\n        }\n\n        // or just add whatever comes exactly as it comes\n        m_currentRequest.prompts.append(Prompt(detectPrompt(msg), QString::fromLocal8Bit(msg->msg), msg->msg_style == PAM_PROMPT_ECHO_OFF));\n\n        return true;\n    }\n\n    Auth::Info PamData::handleInfo(const struct pam_message* msg, bool predict) {\n        if (QString::fromLocal8Bit(msg->msg).indexOf(QRegExp(QStringLiteral(\"^Changing password for [^ ]+$\")))) {\n            if (predict)\n                m_currentRequest = Request(changePassRequest);\n            return Auth::INFO_PASS_CHANGE_REQUIRED;\n        }\n        return Auth::INFO_UNKNOWN;\n    }\n\n    /*\n    * Destroys the prompt with that response\n    */\n    QByteArray PamData::getResponse(const struct pam_message* msg) {\n        QByteArray response = findPrompt(msg).response;\n        m_currentRequest.prompts.removeOne(findPrompt(msg));\n        if (m_currentRequest.prompts.length() == 0)\n            m_sent = false;\n        return response;\n    }\n\n    const Request& PamData::getRequest() const {\n        if (!m_sent)\n            return m_currentRequest;\n        else\n            return invalidRequest;\n    }\n\n    void PamData::completeRequest(const Request& request) {\n        if (request.prompts.length() != m_currentRequest.prompts.length()) {\n            qWarning() << \"[PAM] Different request/response list length, ignoring\";\n            return;\n        }\n\n        for (int i = 0; i < request.prompts.length(); i++) {\n            if (request.prompts[i].type != m_currentRequest.prompts[i].type\n                || request.prompts[i].message != m_currentRequest.prompts[i].message\n                || request.prompts[i].hidden != m_currentRequest.prompts[i].hidden) {\n                qWarning() << \"[PAM] Order or type of the messages doesn't match, ignoring\";\n                return;\n            }\n        }\n\n        m_currentRequest = request;\n        m_sent = true;\n    }\n\n\n\n\n    PamBackend::PamBackend(HelperApp *parent)\n            : Backend(parent)\n            , m_data(new PamData())\n            , m_pam(new PamHandle(this)) {\n    }\n\n    PamBackend::~PamBackend() {\n        delete m_data;\n        delete m_pam;\n    }\n\n    bool PamBackend::start(const QString &user) {\n        bool result;\n\n        QString service = QStringLiteral(\"sddm\");\n\n        if (user == QStringLiteral(\"sddm\") && m_greeter)\n            service = QStringLiteral(\"sddm-greeter\");\n        else if (m_app->session()->path().isEmpty())\n            service = QStringLiteral(\"sddm-check\");\n        else if (m_autologin)\n            service = QStringLiteral(\"sddm-autologin\");\n        result = m_pam->start(service, user);\n\n        if (!result)\n            m_app->error(m_pam->errorString(), Auth::ERROR_INTERNAL);\n\n        return result;\n    }\n\n    bool PamBackend::authenticate() {\n        if (!m_pam->authenticate()) {\n            m_app->error(m_pam->errorString(), Auth::ERROR_AUTHENTICATION);\n            return false;\n        }\n        if (!m_pam->acctMgmt()) {\n            m_app->error(m_pam->errorString(), Auth::ERROR_AUTHENTICATION);\n            return false;\n        }\n        return true;\n    }\n\n    bool PamBackend::openSession() {\n        if (!m_pam->setCred(PAM_ESTABLISH_CRED)) {\n            m_app->error(m_pam->errorString(), Auth::ERROR_AUTHENTICATION);\n            return false;\n        }\n\n        QProcessEnvironment sessionEnv = m_app->session()->processEnvironment();\n        if (sessionEnv.value(QStringLiteral(\"XDG_SESSION_TYPE\")) == QLatin1String(\"x11\")) {\n            QString display = sessionEnv.value(QStringLiteral(\"DISPLAY\"));\n            if (!display.isEmpty()) {\n#ifdef PAM_XDISPLAY\n                m_pam->setItem(PAM_XDISPLAY, qPrintable(display));\n#endif\n                m_pam->setItem(PAM_TTY, qPrintable(display));\n            }\n        } else if (sessionEnv.value(QStringLiteral(\"XDG_SESSION_TYPE\")) == QLatin1String(\"wayland\")) {\n            QString tty = QStringLiteral(\"/dev/tty%1\").arg(sessionEnv.value(QStringLiteral(\"XDG_VTNR\")));\n            m_pam->setItem(PAM_TTY, qPrintable(tty));\n        }\n\n        if (!m_pam->putEnv(sessionEnv)) {\n            m_app->error(m_pam->errorString(), Auth::ERROR_INTERNAL);\n            return false;\n        }\n        if (!m_pam->openSession()) {\n            m_app->error(m_pam->errorString(), Auth::ERROR_INTERNAL);\n            return false;\n        }\n        sessionEnv.insert(m_pam->getEnv());\n        m_app->session()->setProcessEnvironment(sessionEnv);\n        return Backend::openSession();\n    }\n\n    bool PamBackend::closeSession() {\n        if (m_pam->isOpen()) {\n            qDebug() << \"[PAM] Closing session\";\n            m_pam->closeSession();\n            m_pam->setCred(PAM_DELETE_CRED);\n            return true;\n        }\n        qWarning() << \"[PAM] Asked to close the session but it wasn't previously open\";\n        return Backend::closeSession();\n    }\n\n    QString PamBackend::userName() {\n        return QString::fromLocal8Bit((const char*) m_pam->getItem(PAM_USER));\n    }\n\n    int PamBackend::converse(int n, const struct pam_message **msg, struct pam_response **resp) {\n        qDebug() << \"[PAM] Conversation with\" << n << \"messages\";\n\n        bool newRequest = false;\n\n        if (n <= 0 || n > PAM_MAX_NUM_MSG)\n            return PAM_CONV_ERR;\n\n        for (int i = 0; i < n; i++) {\n            switch(msg[i]->msg_style) {\n                case PAM_PROMPT_ECHO_OFF:\n                case PAM_PROMPT_ECHO_ON:\n                    newRequest = m_data->insertPrompt(msg[i], n == 1);\n                    break;\n                case PAM_ERROR_MSG:\n                    m_app->error(QString::fromLocal8Bit(msg[i]->msg), Auth::ERROR_AUTHENTICATION);\n                    break;\n                case PAM_TEXT_INFO:\n                    // if there's only the info message, let's predict the prompts too\n                    m_app->info(QString::fromLocal8Bit(msg[i]->msg), m_data->handleInfo(msg[i], n == 1));\n                    break;\n                default:\n                    break;\n            }\n        }\n\n        if (newRequest) {\n            Request sent = m_data->getRequest();\n            Request received;\n\n            if (sent.valid()) {\n                received = m_app->request(sent);\n\n                if (!received.valid())\n                    return PAM_CONV_ERR;\n\n                m_data->completeRequest(received);\n            }\n        }\n\n        *resp = (struct pam_response *) calloc(n, sizeof(struct pam_response));\n        if (!*resp) {\n            return PAM_BUF_ERR;\n        }\n\n        for (int i = 0; i < n; i++) {\n            QByteArray response = m_data->getResponse(msg[i]);\n\n            resp[i]->resp = (char *) malloc(response.length() + 1);\n            // on error, get rid of everything\n            if (!resp[i]->resp) {\n                for (int j = 0; j < n; j++) {\n                    free(resp[i]->resp);\n                    resp[i]->resp = nullptr;\n                }\n                free(*resp);\n                *resp = nullptr;\n                return PAM_BUF_ERR;\n            }\n\n            memcpy(resp[i]->resp, response.constData(), response.length());\n            resp[i]->resp[response.length()] = '\\0';\n        }\n\n        return PAM_SUCCESS;\n    }\n}\n"], "fixing_code": ["/***************************************************************************\n* Copyright (c) 2014-2015 Pier Luigi Fiorini <pierluigi.fiorini@gmail.com>\n* Copyright (c) 2014 Martin B\u0159\u00edza <mbriza@redhat.com>\n* Copyright (c) 2013 Abdurrahman AVCI <abdurrahmanavci@gmail.com>\n*\n* This program is free software; you can redistribute it and/or modify\n* it under the terms of the GNU General Public License as published by\n* the Free Software Foundation; either version 2 of the License, or\n* (at your option) any later version.\n*\n* This program is distributed in the hope that it will be useful,\n* but WITHOUT ANY WARRANTY; without even the implied warranty of\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n* GNU General Public License for more details.\n*\n* You should have received a copy of the GNU General Public License\n* along with this program; if not, write to the\n* Free Software Foundation, Inc.,\n* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n***************************************************************************/\n\n#include \"Display.h\"\n\n#include \"Configuration.h\"\n#include \"DaemonApp.h\"\n#include \"DisplayManager.h\"\n#include \"XorgDisplayServer.h\"\n#include \"Seat.h\"\n#include \"SocketServer.h\"\n#include \"Greeter.h\"\n#include \"Utils.h\"\n#include \"SignalHandler.h\"\n#include \"VirtualTerminal.h\"\n\n#include <QDebug>\n#include <QFile>\n#include <QTimer>\n\n#include <pwd.h>\n#include <unistd.h>\n\n#include <QDBusConnection>\n#include <QDBusMessage>\n#include <QDBusReply>\n\n#include \"Login1Manager.h\"\n#include \"Login1Session.h\"\n\n\nnamespace SDDM {\n    Display::Display(const int terminalId, Seat *parent) : QObject(parent),\n        m_terminalId(terminalId),\n        m_auth(new Auth(this)),\n        m_displayServer(new XorgDisplayServer(this)),\n        m_seat(parent),\n        m_socketServer(new SocketServer(this)),\n        m_greeter(new Greeter(this)) {\n\n        // respond to authentication requests\n        m_auth->setVerbose(true);\n        connect(m_auth, SIGNAL(requestChanged()), this, SLOT(slotRequestChanged()));\n        connect(m_auth, SIGNAL(authentication(QString,bool)), this, SLOT(slotAuthenticationFinished(QString,bool)));\n        connect(m_auth, SIGNAL(session(bool)), this, SLOT(slotSessionStarted(bool)));\n        connect(m_auth, SIGNAL(finished(Auth::HelperExitStatus)), this, SLOT(slotHelperFinished(Auth::HelperExitStatus)));\n        connect(m_auth, SIGNAL(info(QString,Auth::Info)), this, SLOT(slotAuthInfo(QString,Auth::Info)));\n        connect(m_auth, SIGNAL(error(QString,Auth::Error)), this, SLOT(slotAuthError(QString,Auth::Error)));\n\n        // restart display after display server ended\n        connect(m_displayServer, SIGNAL(started()), this, SLOT(displayServerStarted()));\n        connect(m_displayServer, SIGNAL(stopped()), this, SLOT(stop()));\n\n        // connect login signal\n        connect(m_socketServer, SIGNAL(login(QLocalSocket*,QString,QString,Session)),\n                this, SLOT(login(QLocalSocket*,QString,QString,Session)));\n\n        // connect login result signals\n        connect(this, SIGNAL(loginFailed(QLocalSocket*)), m_socketServer, SLOT(loginFailed(QLocalSocket*)));\n        connect(this, SIGNAL(loginSucceeded(QLocalSocket*)), m_socketServer, SLOT(loginSucceeded(QLocalSocket*)));\n    }\n\n    Display::~Display() {\n        stop();\n    }\n\n    QString Display::displayId() const {\n        return m_displayServer->display();\n    }\n\n    const int Display::terminalId() const {\n        return m_terminalId;\n    }\n\n    const QString &Display::name() const {\n        return m_displayServer->display();\n    }\n\n    QString Display::sessionType() const {\n        return m_displayServer->sessionType();\n    }\n\n    Seat *Display::seat() const {\n        return m_seat;\n    }\n\n    void Display::start() {\n        // check flag\n        if (m_started)\n            return;\n\n        // start display server\n        if (!m_displayServer->start()) {\n            qFatal(\"Display server failed to start. Exiting\");\n        }\n    }\n\n    bool Display::attemptAutologin() {\n        Session::Type sessionType = Session::X11Session;\n\n        // determine session type\n        QString autologinSession = mainConfig.Autologin.Session.get();\n        // not configured: try last successful logged in\n        if (autologinSession.isEmpty()) {\n            autologinSession = stateConfig.Last.Session.get();\n        }\n        if (findSessionEntry(mainConfig.X11.SessionDir.get(), autologinSession)) {\n            sessionType = Session::X11Session;\n        } else if (findSessionEntry(mainConfig.Wayland.SessionDir.get(), autologinSession)) {\n            sessionType = Session::WaylandSession;\n        } else {\n            qCritical() << \"Unable to find autologin session entry\" << autologinSession;\n            return false;\n        }\n\n        Session session;\n        session.setTo(sessionType, autologinSession);\n\n        m_auth->setAutologin(true);\n        startAuth(mainConfig.Autologin.User.get(), QString(), session);\n\n        return true;\n    }\n\n    void Display::displayServerStarted() {\n        // check flag\n        if (m_started)\n            return;\n\n        // setup display\n        m_displayServer->setupDisplay();\n\n        // log message\n        qDebug() << \"Display server started.\";\n\n        if ((daemonApp->first || mainConfig.Autologin.Relogin.get()) &&\n            !mainConfig.Autologin.User.get().isEmpty()) {\n            // reset first flag\n            daemonApp->first = false;\n\n            // set flags\n            m_started = true;\n\n            bool success = attemptAutologin();\n            if (success) {\n                return;\n            }\n        }\n\n        // start socket server\n        m_socketServer->start(m_displayServer->display());\n\n        if (!daemonApp->testing()) {\n            // change the owner and group of the socket to avoid permission denied errors\n            struct passwd *pw = getpwnam(\"sddm\");\n            if (pw) {\n                if (chown(qPrintable(m_socketServer->socketAddress()), pw->pw_uid, pw->pw_gid) == -1) {\n                    qWarning() << \"Failed to change owner of the socket\";\n                    return;\n                }\n            }\n        }\n\n        // set greeter params\n        m_greeter->setDisplay(this);\n        m_greeter->setAuthPath(qobject_cast<XorgDisplayServer *>(m_displayServer)->authPath());\n        m_greeter->setSocket(m_socketServer->socketAddress());\n        m_greeter->setTheme(findGreeterTheme());\n\n        // start greeter\n        m_greeter->start();\n\n        // reset first flag\n        daemonApp->first = false;\n\n        // set flags\n        m_started = true;\n    }\n\n    void Display::stop() {\n        // check flag\n        if (!m_started)\n            return;\n\n        // stop the greeter\n        m_greeter->stop();\n\n        // stop socket server\n        m_socketServer->stop();\n\n        // stop display server\n        m_displayServer->blockSignals(true);\n        m_displayServer->stop();\n        m_displayServer->blockSignals(false);\n\n        // reset flag\n        m_started = false;\n\n        // emit signal\n        emit stopped();\n    }\n\n    void Display::login(QLocalSocket *socket,\n                        const QString &user, const QString &password,\n                        const Session &session) {\n        m_socket = socket;\n\n        //the SDDM user has special privileges that skip password checking so that we can load the greeter\n        //block ever trying to log in as the SDDM user\n        if (user == QLatin1String(\"sddm\")) {\n            return;\n        }\n\n        // authenticate\n        startAuth(user, password, session);\n    }\n\n    QString Display::findGreeterTheme() const {\n        QString themeName = mainConfig.Theme.Current.get();\n\n        // an unconfigured theme means the user wants to load the\n        // default theme from the resources\n        if (themeName.isEmpty())\n            return QString();\n\n        QDir dir(mainConfig.Theme.ThemeDir.get());\n\n        // return the default theme if it exists\n        if (dir.exists(themeName))\n            return dir.absoluteFilePath(themeName);\n\n        // otherwise use the embedded theme\n        qWarning() << \"The configured theme\" << themeName << \"doesn't exist, using the embedded theme instead\";\n        return QString();\n    }\n\n    bool Display::findSessionEntry(const QDir &dir, const QString &name) const {\n        QString fileName = name;\n\n        // append extension\n        const QString extension = QStringLiteral(\".desktop\");\n        if (!fileName.endsWith(extension))\n            fileName += extension;\n\n        return dir.exists(fileName);\n    }\n\n    void Display::startAuth(const QString &user, const QString &password, const Session &session) {\n        m_passPhrase = password;\n\n        // sanity check\n        if (!session.isValid()) {\n            qCritical() << \"Invalid session\" << session.fileName();\n            return;\n        }\n        if (session.xdgSessionType().isEmpty()) {\n            qCritical() << \"Failed to find XDG session type for session\" << session.fileName();\n            return;\n        }\n        if (session.exec().isEmpty()) {\n            qCritical() << \"Failed to find command for session\" << session.fileName();\n            return;\n        }\n\n        QString existingSessionId;\n\n        if (Logind::isAvailable() && mainConfig.Users.ReuseSession.get()) {\n            OrgFreedesktopLogin1ManagerInterface manager(Logind::serviceName(), Logind::managerPath(), QDBusConnection::systemBus());\n            auto reply = manager.ListSessions();\n            reply.waitForFinished();\n\n            foreach(const SessionInfo &s, reply.value()) {\n                if (s.userName == user) {\n                    OrgFreedesktopLogin1SessionInterface session(Logind::serviceName(), s.sessionPath.path(), QDBusConnection::systemBus());\n                    if (session.service() == QLatin1String(\"sddm\")) {\n                        existingSessionId =  s.sessionId;\n                        break;\n                    }\n                }\n            }\n        }\n\n        // cache last session\n        m_lastSession = session;\n\n        // save session desktop file name, we'll use it to set the\n        // last session later, in slotAuthenticationFinished()\n        m_sessionName = session.fileName();\n\n        // some information\n        qDebug() << \"Session\" << m_sessionName << \"selected, command:\" << session.exec();\n\n        // create new VT for Wayland sessions otherwise use greeter vt\n        int vt = terminalId();\n        if (session.xdgSessionType() == QLatin1String(\"wayland\"))\n            vt = VirtualTerminal::setUpNewVt();\n        m_lastSession.setVt(vt);\n\n        QProcessEnvironment env;\n        env.insert(QStringLiteral(\"PATH\"), mainConfig.Users.DefaultPath.get());\n        if (session.xdgSessionType() == QLatin1String(\"x11\"))\n            env.insert(QStringLiteral(\"DISPLAY\"), name());\n        env.insert(QStringLiteral(\"XDG_SEAT_PATH\"), daemonApp->displayManager()->seatPath(seat()->name()));\n        env.insert(QStringLiteral(\"XDG_SESSION_PATH\"), daemonApp->displayManager()->sessionPath(QStringLiteral(\"Session%1\").arg(daemonApp->newSessionId())));\n        env.insert(QStringLiteral(\"DESKTOP_SESSION\"), session.desktopSession());\n        env.insert(QStringLiteral(\"XDG_CURRENT_DESKTOP\"), session.desktopNames());\n        env.insert(QStringLiteral(\"XDG_SESSION_CLASS\"), QStringLiteral(\"user\"));\n        env.insert(QStringLiteral(\"XDG_SESSION_TYPE\"), session.xdgSessionType());\n        env.insert(QStringLiteral(\"XDG_SEAT\"), seat()->name());\n\n        env.insert(QStringLiteral(\"XDG_SESSION_DESKTOP\"), session.desktopNames());\n        if (seat()->name() == QLatin1String(\"seat0\")) {\n            env.insert(QStringLiteral(\"XDG_VTNR\"), QString::number(vt));\n        }\n\n        m_auth->insertEnvironment(env);\n\n        m_auth->setUser(user);\n        if (existingSessionId.isNull()) {\n            m_auth->setSession(session.exec());\n        } else {\n            //we only want to unlock the session if we can lock in, so we want to go via PAM auth, but not start a new session\n            //by not setting the session and the helper will emit authentication and then quit\n            connect(m_auth, &Auth::authentication, this, [=](const QString &, bool success){\n                if(!success)\n                    return;\n                qDebug() << \"activating existing seat\";\n                OrgFreedesktopLogin1ManagerInterface manager(Logind::serviceName(), Logind::managerPath(), QDBusConnection::systemBus());\n                manager.UnlockSession(existingSessionId);\n                manager.ActivateSession(existingSessionId);\n            });\n        }\n        m_auth->start();\n    }\n\n    void Display::slotAuthenticationFinished(const QString &user, bool success) {\n        if (success) {\n            qDebug() << \"Authenticated successfully\";\n\n            m_auth->setCookie(qobject_cast<XorgDisplayServer *>(m_displayServer)->cookie());\n\n            // save last user and last session\n            if (mainConfig.Users.RememberLastUser.get())\n                stateConfig.Last.User.set(m_auth->user());\n            else\n                stateConfig.Last.User.setDefault();\n            if (mainConfig.Users.RememberLastSession.get())\n                stateConfig.Last.Session.set(m_sessionName);\n            else\n                stateConfig.Last.Session.setDefault();\n            stateConfig.save();\n\n            // switch to the new VT for Wayland sessions\n            if (m_lastSession.xdgSessionType() == QLatin1String(\"wayland\"))\n                // set vt_auto to false, so handle the vt switch yourself (VT_PROCESS)\n                VirtualTerminal::jumpToVt(m_lastSession.vt(), false);\n\n            if (m_socket)\n                emit loginSucceeded(m_socket);\n        } else if (m_socket) {\n            qDebug() << \"Authentication failure\";\n            emit loginFailed(m_socket);\n        }\n        m_socket = nullptr;\n    }\n\n    void Display::slotAuthInfo(const QString &message, Auth::Info info) {\n        // TODO: presentable to the user, eventually\n        Q_UNUSED(info);\n        qWarning() << \"Authentication information:\" << message;\n    }\n\n    void Display::slotAuthError(const QString &message, Auth::Error error) {\n        // TODO: handle more errors\n        qWarning() << \"Authentication error:\" << message;\n\n        if (!m_socket)\n            return;\n\n        if (error == Auth::ERROR_AUTHENTICATION)\n            emit loginFailed(m_socket);\n    }\n\n    void Display::slotHelperFinished(Auth::HelperExitStatus status) {\n        // Don't restart greeter and display server unless sddm-helper exited\n        // with an internal error or the user session finished successfully,\n        // we want to avoid greeter from restarting when an authentication\n        // error happens (in this case we want to show the message from the\n        // greeter\n        if (status != Auth::HELPER_AUTH_ERROR)\n            stop();\n    }\n\n    void Display::slotRequestChanged() {\n        if (m_auth->request()->prompts().length() == 1) {\n            m_auth->request()->prompts()[0]->setResponse(qPrintable(m_passPhrase));\n            m_auth->request()->done();\n        } else if (m_auth->request()->prompts().length() == 2) {\n            m_auth->request()->prompts()[0]->setResponse(qPrintable(m_auth->user()));\n            m_auth->request()->prompts()[1]->setResponse(qPrintable(m_passPhrase));\n            m_auth->request()->done();\n        }\n    }\n\n    void Display::slotSessionStarted(bool success) {\n        qDebug() << \"Session started\";\n    }\n}\n", "/*\n * PAM authentication backend\n * Copyright (C) 2013 Martin B\u0159\u00edza <mbriza@redhat.com>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n */\n\n#include \"PamBackend.h\"\n#include \"PamHandle.h\"\n#include \"HelperApp.h\"\n#include \"UserSession.h\"\n#include \"Auth.h\"\n\n#include <QtCore/QString>\n#include <QtCore/QDebug>\n\n#include <stdlib.h>\n\nnamespace SDDM {\n    static Request loginRequest {\n        {   { AuthPrompt::LOGIN_USER, QStringLiteral(\"login:\"), false },\n            { AuthPrompt::LOGIN_PASSWORD, QStringLiteral(\"Password: \"), true }\n        }\n    };\n\n    static Request changePassRequest {\n        {   { AuthPrompt::CHANGE_CURRENT, QStringLiteral(\"(current) UNIX password: \"), true },\n            { AuthPrompt::CHANGE_NEW, QStringLiteral(\"New password: \"), true },\n            { AuthPrompt::CHANGE_REPEAT, QStringLiteral(\"Retype new password: \"), true }\n        }\n    };\n\n    static Request changePassNoOldRequest {\n        {   { AuthPrompt::CHANGE_NEW, QStringLiteral(\"New password: \"), true },\n            { AuthPrompt::CHANGE_REPEAT, QStringLiteral(\"Retype new password: \"), true }\n        }\n    };\n\n    static Request invalidRequest { {} };\n\n    static Prompt invalidPrompt {};\n\n    PamData::PamData() { }\n\n    AuthPrompt::Type PamData::detectPrompt(const struct pam_message* msg) const {\n        if (msg->msg_style == PAM_PROMPT_ECHO_OFF) {\n            QString message = QString::fromLocal8Bit(msg->msg);\n            if (message.indexOf(QRegExp(QStringLiteral(\"\\\\bpassword\\\\b\"), Qt::CaseInsensitive)) >= 0) {\n                if (message.indexOf(QRegExp(QStringLiteral(\"\\\\b(re-?(enter|type)|again|confirm|repeat)\\\\b\"), Qt::CaseInsensitive)) >= 0) {\n                    return AuthPrompt::CHANGE_REPEAT;\n                }\n                else if (message.indexOf(QRegExp(QStringLiteral(\"\\\\bnew\\\\b\"), Qt::CaseInsensitive)) >= 0) {\n                    return AuthPrompt::CHANGE_NEW;\n                }\n                else if (message.indexOf(QRegExp(QStringLiteral(\"\\\\b(old|current)\\\\b\"), Qt::CaseInsensitive)) >= 0) {\n                    return AuthPrompt::CHANGE_CURRENT;\n                }\n                else {\n                    return AuthPrompt::LOGIN_PASSWORD;\n                }\n            }\n        }\n        else {\n            return AuthPrompt::LOGIN_USER;\n        }\n\n        return AuthPrompt::UNKNOWN;\n    }\n\n    const Prompt& PamData::findPrompt(const struct pam_message* msg) const {\n        AuthPrompt::Type type = detectPrompt(msg);\n\n        for (const Prompt &p : m_currentRequest.prompts) {\n            if (type == p.type && p.message == QString::fromLocal8Bit(msg->msg))\n                return p;\n        }\n\n        return invalidPrompt;\n    }\n\n    Prompt& PamData::findPrompt(const struct pam_message* msg) {\n        AuthPrompt::Type type = detectPrompt(msg);\n\n        for (Prompt &p : m_currentRequest.prompts) {\n            if (type == AuthPrompt::UNKNOWN && QString::fromLocal8Bit(msg->msg) == p.message)\n                return p;\n            if (type == p.type)\n                return p;\n        }\n\n        return invalidPrompt;\n    }\n\n    /*\n    * Expects an empty prompt list if the previous request has been processed\n    */\n    bool PamData::insertPrompt(const struct pam_message* msg, bool predict) {\n        Prompt &p = findPrompt(msg);\n\n        // first, check if we already have stored this propmpt\n        if (p.valid()) {\n            // we have a response already - do nothing\n            if (m_sent)\n                return false;\n            // we don't have a response yet - replace the message and prepare to send it\n            p.message = QString::fromLocal8Bit(msg->msg);\n            return true;\n        }\n        // this prompt is not stored but we have some prompts\n        else if (m_currentRequest.prompts.length() != 0) {\n            // check if we have already sent this - if we did, get rid of the answers\n            if (m_sent) {\n                m_currentRequest.clear();\n                m_sent = false;\n            }\n        }\n\n        // we'll predict what will come next\n        if (predict) {\n            AuthPrompt::Type type = detectPrompt(msg);\n            switch (type) {\n                case AuthPrompt::LOGIN_USER:\n                    m_currentRequest = Request(loginRequest);\n                    return true;\n                case AuthPrompt::CHANGE_CURRENT:\n                    m_currentRequest = Request(changePassRequest);\n                    return true;\n                case AuthPrompt::CHANGE_NEW:\n                    m_currentRequest = Request(changePassNoOldRequest);\n                    return true;\n                default:\n                    break;\n            }\n        }\n\n        // or just add whatever comes exactly as it comes\n        m_currentRequest.prompts.append(Prompt(detectPrompt(msg), QString::fromLocal8Bit(msg->msg), msg->msg_style == PAM_PROMPT_ECHO_OFF));\n\n        return true;\n    }\n\n    Auth::Info PamData::handleInfo(const struct pam_message* msg, bool predict) {\n        if (QString::fromLocal8Bit(msg->msg).indexOf(QRegExp(QStringLiteral(\"^Changing password for [^ ]+$\")))) {\n            if (predict)\n                m_currentRequest = Request(changePassRequest);\n            return Auth::INFO_PASS_CHANGE_REQUIRED;\n        }\n        return Auth::INFO_UNKNOWN;\n    }\n\n    /*\n    * Destroys the prompt with that response\n    */\n    QByteArray PamData::getResponse(const struct pam_message* msg) {\n        QByteArray response = findPrompt(msg).response;\n        m_currentRequest.prompts.removeOne(findPrompt(msg));\n        if (m_currentRequest.prompts.length() == 0)\n            m_sent = false;\n        return response;\n    }\n\n    const Request& PamData::getRequest() const {\n        if (!m_sent)\n            return m_currentRequest;\n        else\n            return invalidRequest;\n    }\n\n    void PamData::completeRequest(const Request& request) {\n        if (request.prompts.length() != m_currentRequest.prompts.length()) {\n            qWarning() << \"[PAM] Different request/response list length, ignoring\";\n            return;\n        }\n\n        for (int i = 0; i < request.prompts.length(); i++) {\n            if (request.prompts[i].type != m_currentRequest.prompts[i].type\n                || request.prompts[i].message != m_currentRequest.prompts[i].message\n                || request.prompts[i].hidden != m_currentRequest.prompts[i].hidden) {\n                qWarning() << \"[PAM] Order or type of the messages doesn't match, ignoring\";\n                return;\n            }\n        }\n\n        m_currentRequest = request;\n        m_sent = true;\n    }\n\n\n\n\n    PamBackend::PamBackend(HelperApp *parent)\n            : Backend(parent)\n            , m_data(new PamData())\n            , m_pam(new PamHandle(this)) {\n    }\n\n    PamBackend::~PamBackend() {\n        delete m_data;\n        delete m_pam;\n    }\n\n    bool PamBackend::start(const QString &user) {\n        bool result;\n\n        QString service = QStringLiteral(\"sddm\");\n\n        if (user == QStringLiteral(\"sddm\") && m_greeter)\n            service = QStringLiteral(\"sddm-greeter\");\n        else if (m_autologin)\n            service = QStringLiteral(\"sddm-autologin\");\n        result = m_pam->start(service, user);\n\n        if (!result)\n            m_app->error(m_pam->errorString(), Auth::ERROR_INTERNAL);\n\n        return result;\n    }\n\n    bool PamBackend::authenticate() {\n        if (!m_pam->authenticate()) {\n            m_app->error(m_pam->errorString(), Auth::ERROR_AUTHENTICATION);\n            return false;\n        }\n        if (!m_pam->acctMgmt()) {\n            m_app->error(m_pam->errorString(), Auth::ERROR_AUTHENTICATION);\n            return false;\n        }\n        return true;\n    }\n\n    bool PamBackend::openSession() {\n        if (!m_pam->setCred(PAM_ESTABLISH_CRED)) {\n            m_app->error(m_pam->errorString(), Auth::ERROR_AUTHENTICATION);\n            return false;\n        }\n\n        QProcessEnvironment sessionEnv = m_app->session()->processEnvironment();\n        if (sessionEnv.value(QStringLiteral(\"XDG_SESSION_TYPE\")) == QLatin1String(\"x11\")) {\n            QString display = sessionEnv.value(QStringLiteral(\"DISPLAY\"));\n            if (!display.isEmpty()) {\n#ifdef PAM_XDISPLAY\n                m_pam->setItem(PAM_XDISPLAY, qPrintable(display));\n#endif\n                m_pam->setItem(PAM_TTY, qPrintable(display));\n            }\n        } else if (sessionEnv.value(QStringLiteral(\"XDG_SESSION_TYPE\")) == QLatin1String(\"wayland\")) {\n            QString tty = QStringLiteral(\"/dev/tty%1\").arg(sessionEnv.value(QStringLiteral(\"XDG_VTNR\")));\n            m_pam->setItem(PAM_TTY, qPrintable(tty));\n        }\n\n        if (!m_pam->putEnv(sessionEnv)) {\n            m_app->error(m_pam->errorString(), Auth::ERROR_INTERNAL);\n            return false;\n        }\n        if (!m_pam->openSession()) {\n            m_app->error(m_pam->errorString(), Auth::ERROR_INTERNAL);\n            return false;\n        }\n        sessionEnv.insert(m_pam->getEnv());\n        m_app->session()->setProcessEnvironment(sessionEnv);\n        return Backend::openSession();\n    }\n\n    bool PamBackend::closeSession() {\n        if (m_pam->isOpen()) {\n            qDebug() << \"[PAM] Closing session\";\n            m_pam->closeSession();\n            m_pam->setCred(PAM_DELETE_CRED);\n            return true;\n        }\n        qWarning() << \"[PAM] Asked to close the session but it wasn't previously open\";\n        return Backend::closeSession();\n    }\n\n    QString PamBackend::userName() {\n        return QString::fromLocal8Bit((const char*) m_pam->getItem(PAM_USER));\n    }\n\n    int PamBackend::converse(int n, const struct pam_message **msg, struct pam_response **resp) {\n        qDebug() << \"[PAM] Conversation with\" << n << \"messages\";\n\n        bool newRequest = false;\n\n        if (n <= 0 || n > PAM_MAX_NUM_MSG)\n            return PAM_CONV_ERR;\n\n        for (int i = 0; i < n; i++) {\n            switch(msg[i]->msg_style) {\n                case PAM_PROMPT_ECHO_OFF:\n                case PAM_PROMPT_ECHO_ON:\n                    newRequest = m_data->insertPrompt(msg[i], n == 1);\n                    break;\n                case PAM_ERROR_MSG:\n                    m_app->error(QString::fromLocal8Bit(msg[i]->msg), Auth::ERROR_AUTHENTICATION);\n                    break;\n                case PAM_TEXT_INFO:\n                    // if there's only the info message, let's predict the prompts too\n                    m_app->info(QString::fromLocal8Bit(msg[i]->msg), m_data->handleInfo(msg[i], n == 1));\n                    break;\n                default:\n                    break;\n            }\n        }\n\n        if (newRequest) {\n            Request sent = m_data->getRequest();\n            Request received;\n\n            if (sent.valid()) {\n                received = m_app->request(sent);\n\n                if (!received.valid())\n                    return PAM_CONV_ERR;\n\n                m_data->completeRequest(received);\n            }\n        }\n\n        *resp = (struct pam_response *) calloc(n, sizeof(struct pam_response));\n        if (!*resp) {\n            return PAM_BUF_ERR;\n        }\n\n        for (int i = 0; i < n; i++) {\n            QByteArray response = m_data->getResponse(msg[i]);\n\n            resp[i]->resp = (char *) malloc(response.length() + 1);\n            // on error, get rid of everything\n            if (!resp[i]->resp) {\n                for (int j = 0; j < n; j++) {\n                    free(resp[i]->resp);\n                    resp[i]->resp = nullptr;\n                }\n                free(*resp);\n                *resp = nullptr;\n                return PAM_BUF_ERR;\n            }\n\n            memcpy(resp[i]->resp, response.constData(), response.length());\n            resp[i]->resp[response.length()] = '\\0';\n        }\n\n        return PAM_SUCCESS;\n    }\n}\n"], "filenames": ["src/daemon/Display.cpp", "src/helper/backend/PamBackend.cpp"], "buggy_code_start_loc": [342, 222], "buggy_code_end_loc": [343, 224], "fixing_code_start_loc": [342, 221], "fixing_code_end_loc": [345, 221], "type": "CWE-287", "message": "An issue was discovered in SDDM through 0.17.0. If configured with ReuseSession=true, the password is not checked for users with an already existing session. Any user with access to the system D-Bus can therefore unlock any graphical session. This is related to daemon/Display.cpp and helper/backend/PamBackend.cpp.", "other": {"cve": {"id": "CVE-2018-14345", "sourceIdentifier": "cve@mitre.org", "published": "2018-07-17T14:29:00.517", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in SDDM through 0.17.0. If configured with ReuseSession=true, the password is not checked for users with an already existing session. Any user with access to the system D-Bus can therefore unlock any graphical session. This is related to daemon/Display.cpp and helper/backend/PamBackend.cpp."}, {"lang": "es", "value": "Se ha descubierto un problema en SDDM hasta su versi\u00f3n 0.17.0. Si se configura con ReuseSession=true, la contrase\u00f1a no se comprueba para los usuarios con una sesi\u00f3n ya existente. Cualquier usuario con acceso al D-Bus del sistema puede, por lo tanto, desbloquear cualquier sesi\u00f3n gr\u00e1fica. Esto est\u00e1 relacionado con daemon/Display.cpp y helper/backend/PamBackend.cpp."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.6, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 6.8, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}, {"lang": "en", "value": "CWE-613"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:sddm_project:sddm:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.17.0", "matchCriteriaId": "EE2F0E6C-6C6C-4EBF-941F-226F9F4A7719"}]}]}], "references": [{"url": "https://bugzilla.suse.com/show_bug.cgi?id=1101450", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/sddm/sddm/commit/147cec383892d143b5e02daa70f1e7def50f5d98", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/sddm/sddm/commit/147cec383892d143b5e02daa70f1e7def50f5d98"}}