{"buggy_code": ["/*\n * arch/arm64/include/asm/arch_timer.h\n *\n * Copyright (C) 2012 ARM Ltd.\n * Author: Marc Zyngier <marc.zyngier@arm.com>\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n#ifndef __ASM_ARCH_TIMER_H\n#define __ASM_ARCH_TIMER_H\n\n#include <asm/barrier.h>\n#include <asm/sysreg.h>\n\n#include <linux/bug.h>\n#include <linux/init.h>\n#include <linux/jump_label.h>\n#include <linux/smp.h>\n#include <linux/types.h>\n\n#include <clocksource/arm_arch_timer.h>\n\n#if IS_ENABLED(CONFIG_ARM_ARCH_TIMER_OOL_WORKAROUND)\nextern struct static_key_false arch_timer_read_ool_enabled;\n#define needs_unstable_timer_counter_workaround() \\\n\tstatic_branch_unlikely(&arch_timer_read_ool_enabled)\n#else\n#define needs_unstable_timer_counter_workaround()  false\n#endif\n\nenum arch_timer_erratum_match_type {\n\tate_match_dt,\n\tate_match_local_cap_id,\n\tate_match_acpi_oem_info,\n};\n\nstruct clock_event_device;\n\nstruct arch_timer_erratum_workaround {\n\tenum arch_timer_erratum_match_type match_type;\n\tconst void *id;\n\tconst char *desc;\n\tu32 (*read_cntp_tval_el0)(void);\n\tu32 (*read_cntv_tval_el0)(void);\n\tu64 (*read_cntvct_el0)(void);\n\tint (*set_next_event_phys)(unsigned long, struct clock_event_device *);\n\tint (*set_next_event_virt)(unsigned long, struct clock_event_device *);\n};\n\nDECLARE_PER_CPU(const struct arch_timer_erratum_workaround *,\n\t\ttimer_unstable_counter_workaround);\n\n#define arch_timer_reg_read_stable(reg)\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tu64 _val;\t\t\t\t\t\t\t\\\n\tif (needs_unstable_timer_counter_workaround()) {\t\t\\\n\t\tconst struct arch_timer_erratum_workaround *wa;\t\t\\\n\t\tpreempt_disable();\t\t\t\t\t\\\n\t\twa = __this_cpu_read(timer_unstable_counter_workaround); \\\n\t\tif (wa && wa->read_##reg)\t\t\t\t\\\n\t\t\t_val = wa->read_##reg();\t\t\t\\\n\t\telse\t\t\t\t\t\t\t\\\n\t\t\t_val = read_sysreg(reg);\t\t\t\\\n\t\tpreempt_enable();\t\t\t\t\t\\\n\t} else {\t\t\t\t\t\t\t\\\n\t\t_val = read_sysreg(reg);\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t_val;\t\t\t\t\t\t\t\t\\\n})\n\n/*\n * These register accessors are marked inline so the compiler can\n * nicely work out which register we want, and chuck away the rest of\n * the code.\n */\nstatic __always_inline\nvoid arch_timer_reg_write_cp15(int access, enum arch_timer_reg reg, u32 val)\n{\n\tif (access == ARCH_TIMER_PHYS_ACCESS) {\n\t\tswitch (reg) {\n\t\tcase ARCH_TIMER_REG_CTRL:\n\t\t\twrite_sysreg(val, cntp_ctl_el0);\n\t\t\tbreak;\n\t\tcase ARCH_TIMER_REG_TVAL:\n\t\t\twrite_sysreg(val, cntp_tval_el0);\n\t\t\tbreak;\n\t\t}\n\t} else if (access == ARCH_TIMER_VIRT_ACCESS) {\n\t\tswitch (reg) {\n\t\tcase ARCH_TIMER_REG_CTRL:\n\t\t\twrite_sysreg(val, cntv_ctl_el0);\n\t\t\tbreak;\n\t\tcase ARCH_TIMER_REG_TVAL:\n\t\t\twrite_sysreg(val, cntv_tval_el0);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tisb();\n}\n\nstatic __always_inline\nu32 arch_timer_reg_read_cp15(int access, enum arch_timer_reg reg)\n{\n\tif (access == ARCH_TIMER_PHYS_ACCESS) {\n\t\tswitch (reg) {\n\t\tcase ARCH_TIMER_REG_CTRL:\n\t\t\treturn read_sysreg(cntp_ctl_el0);\n\t\tcase ARCH_TIMER_REG_TVAL:\n\t\t\treturn arch_timer_reg_read_stable(cntp_tval_el0);\n\t\t}\n\t} else if (access == ARCH_TIMER_VIRT_ACCESS) {\n\t\tswitch (reg) {\n\t\tcase ARCH_TIMER_REG_CTRL:\n\t\t\treturn read_sysreg(cntv_ctl_el0);\n\t\tcase ARCH_TIMER_REG_TVAL:\n\t\t\treturn arch_timer_reg_read_stable(cntv_tval_el0);\n\t\t}\n\t}\n\n\tBUG();\n}\n\nstatic inline u32 arch_timer_get_cntfrq(void)\n{\n\treturn read_sysreg(cntfrq_el0);\n}\n\nstatic inline u32 arch_timer_get_cntkctl(void)\n{\n\treturn read_sysreg(cntkctl_el1);\n}\n\nstatic inline void arch_timer_set_cntkctl(u32 cntkctl)\n{\n\twrite_sysreg(cntkctl, cntkctl_el1);\n}\n\nstatic inline u64 arch_counter_get_cntpct(void)\n{\n\t/*\n\t * AArch64 kernel and user space mandate the use of CNTVCT.\n\t */\n\tBUG();\n\treturn 0;\n}\n\nstatic inline u64 arch_counter_get_cntvct(void)\n{\n\tisb();\n\treturn arch_timer_reg_read_stable(cntvct_el0);\n}\n\nstatic inline int arch_timer_arch_init(void)\n{\n\treturn 0;\n}\n\n#endif\n"], "fixing_code": ["/*\n * arch/arm64/include/asm/arch_timer.h\n *\n * Copyright (C) 2012 ARM Ltd.\n * Author: Marc Zyngier <marc.zyngier@arm.com>\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n#ifndef __ASM_ARCH_TIMER_H\n#define __ASM_ARCH_TIMER_H\n\n#include <asm/barrier.h>\n#include <asm/sysreg.h>\n\n#include <linux/bug.h>\n#include <linux/init.h>\n#include <linux/jump_label.h>\n#include <linux/smp.h>\n#include <linux/types.h>\n\n#include <clocksource/arm_arch_timer.h>\n\n#if IS_ENABLED(CONFIG_ARM_ARCH_TIMER_OOL_WORKAROUND)\nextern struct static_key_false arch_timer_read_ool_enabled;\n#define needs_unstable_timer_counter_workaround() \\\n\tstatic_branch_unlikely(&arch_timer_read_ool_enabled)\n#else\n#define needs_unstable_timer_counter_workaround()  false\n#endif\n\nenum arch_timer_erratum_match_type {\n\tate_match_dt,\n\tate_match_local_cap_id,\n\tate_match_acpi_oem_info,\n};\n\nstruct clock_event_device;\n\nstruct arch_timer_erratum_workaround {\n\tenum arch_timer_erratum_match_type match_type;\n\tconst void *id;\n\tconst char *desc;\n\tu32 (*read_cntp_tval_el0)(void);\n\tu32 (*read_cntv_tval_el0)(void);\n\tu64 (*read_cntvct_el0)(void);\n\tint (*set_next_event_phys)(unsigned long, struct clock_event_device *);\n\tint (*set_next_event_virt)(unsigned long, struct clock_event_device *);\n};\n\nDECLARE_PER_CPU(const struct arch_timer_erratum_workaround *,\n\t\ttimer_unstable_counter_workaround);\n\n#define arch_timer_reg_read_stable(reg)\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tu64 _val;\t\t\t\t\t\t\t\\\n\tif (needs_unstable_timer_counter_workaround()) {\t\t\\\n\t\tconst struct arch_timer_erratum_workaround *wa;\t\t\\\n\t\tpreempt_disable_notrace();\t\t\t\t\\\n\t\twa = __this_cpu_read(timer_unstable_counter_workaround); \\\n\t\tif (wa && wa->read_##reg)\t\t\t\t\\\n\t\t\t_val = wa->read_##reg();\t\t\t\\\n\t\telse\t\t\t\t\t\t\t\\\n\t\t\t_val = read_sysreg(reg);\t\t\t\\\n\t\tpreempt_enable_notrace();\t\t\t\t\\\n\t} else {\t\t\t\t\t\t\t\\\n\t\t_val = read_sysreg(reg);\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t_val;\t\t\t\t\t\t\t\t\\\n})\n\n/*\n * These register accessors are marked inline so the compiler can\n * nicely work out which register we want, and chuck away the rest of\n * the code.\n */\nstatic __always_inline\nvoid arch_timer_reg_write_cp15(int access, enum arch_timer_reg reg, u32 val)\n{\n\tif (access == ARCH_TIMER_PHYS_ACCESS) {\n\t\tswitch (reg) {\n\t\tcase ARCH_TIMER_REG_CTRL:\n\t\t\twrite_sysreg(val, cntp_ctl_el0);\n\t\t\tbreak;\n\t\tcase ARCH_TIMER_REG_TVAL:\n\t\t\twrite_sysreg(val, cntp_tval_el0);\n\t\t\tbreak;\n\t\t}\n\t} else if (access == ARCH_TIMER_VIRT_ACCESS) {\n\t\tswitch (reg) {\n\t\tcase ARCH_TIMER_REG_CTRL:\n\t\t\twrite_sysreg(val, cntv_ctl_el0);\n\t\t\tbreak;\n\t\tcase ARCH_TIMER_REG_TVAL:\n\t\t\twrite_sysreg(val, cntv_tval_el0);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tisb();\n}\n\nstatic __always_inline\nu32 arch_timer_reg_read_cp15(int access, enum arch_timer_reg reg)\n{\n\tif (access == ARCH_TIMER_PHYS_ACCESS) {\n\t\tswitch (reg) {\n\t\tcase ARCH_TIMER_REG_CTRL:\n\t\t\treturn read_sysreg(cntp_ctl_el0);\n\t\tcase ARCH_TIMER_REG_TVAL:\n\t\t\treturn arch_timer_reg_read_stable(cntp_tval_el0);\n\t\t}\n\t} else if (access == ARCH_TIMER_VIRT_ACCESS) {\n\t\tswitch (reg) {\n\t\tcase ARCH_TIMER_REG_CTRL:\n\t\t\treturn read_sysreg(cntv_ctl_el0);\n\t\tcase ARCH_TIMER_REG_TVAL:\n\t\t\treturn arch_timer_reg_read_stable(cntv_tval_el0);\n\t\t}\n\t}\n\n\tBUG();\n}\n\nstatic inline u32 arch_timer_get_cntfrq(void)\n{\n\treturn read_sysreg(cntfrq_el0);\n}\n\nstatic inline u32 arch_timer_get_cntkctl(void)\n{\n\treturn read_sysreg(cntkctl_el1);\n}\n\nstatic inline void arch_timer_set_cntkctl(u32 cntkctl)\n{\n\twrite_sysreg(cntkctl, cntkctl_el1);\n}\n\nstatic inline u64 arch_counter_get_cntpct(void)\n{\n\t/*\n\t * AArch64 kernel and user space mandate the use of CNTVCT.\n\t */\n\tBUG();\n\treturn 0;\n}\n\nstatic inline u64 arch_counter_get_cntvct(void)\n{\n\tisb();\n\treturn arch_timer_reg_read_stable(cntvct_el0);\n}\n\nstatic inline int arch_timer_arch_init(void)\n{\n\treturn 0;\n}\n\n#endif\n"], "filenames": ["arch/arm64/include/asm/arch_timer.h"], "buggy_code_start_loc": [68], "buggy_code_end_loc": [75], "fixing_code_start_loc": [68], "fixing_code_end_loc": [75], "type": "CWE-835", "message": "The arch_timer_reg_read_stable macro in arch/arm64/include/asm/arch_timer.h in the Linux kernel before 4.13 allows local users to cause a denial of service (infinite recursion) by writing to a file under /sys/kernel/debug in certain circumstances, as demonstrated by a scenario involving debugfs, ftrace, PREEMPT_TRACER, and FUNCTION_GRAPH_TRACER.", "other": {"cve": {"id": "CVE-2017-18261", "sourceIdentifier": "cve@mitre.org", "published": "2018-04-19T08:29:00.207", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The arch_timer_reg_read_stable macro in arch/arm64/include/asm/arch_timer.h in the Linux kernel before 4.13 allows local users to cause a denial of service (infinite recursion) by writing to a file under /sys/kernel/debug in certain circumstances, as demonstrated by a scenario involving debugfs, ftrace, PREEMPT_TRACER, and FUNCTION_GRAPH_TRACER."}, {"lang": "es", "value": "La macro arch_timer_reg_read_stable en arch/arm64/include/asm/arch_timer.h en el kernel de Linux, en versiones anteriores a la 4.13, permite que usuarios locales provoquen una denegaci\u00f3n de servicio (recursi\u00f3n infinita) escribiendo en un archivo en /sys/kernel/debug en ciertas circunstancias, tal y como se demuestra por un escenario que implica debugfs, ftrace, PREEMPT_TRACER y FUNCTION_GRAPH_TRACER."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-835"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.13", "matchCriteriaId": "D2894F22-5448-4402-AE27-6E43BD08E14E"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=adb4f11e0a8f4e29900adb2b7af28b6bbd5c1fa4", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/adb4f11e0a8f4e29900adb2b7af28b6bbd5c1fa4", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/adb4f11e0a8f4e29900adb2b7af28b6bbd5c1fa4"}}