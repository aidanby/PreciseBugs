{"buggy_code": ["/*\n *   (Tentative) USB Audio Driver for ALSA\n *\n *   Copyright (c) 2002 by Takashi Iwai <tiwai@suse.de>\n *\n *   Many codes borrowed from audio.c by\n *\t    Alan Cox (alan@lxorguk.ukuu.org.uk)\n *\t    Thomas Sailer (sailer@ife.ee.ethz.ch)\n *\n *\n *   This program is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation; either version 2 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU General Public License for more details.\n *\n *   You should have received a copy of the GNU General Public License\n *   along with this program; if not, write to the Free Software\n *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA\n *\n *\n *  NOTES:\n *\n *   - the linked URBs would be preferred but not used so far because of\n *     the instability of unlinking.\n *   - type II is not supported properly.  there is no device which supports\n *     this type *correctly*.  SB extigy looks as if it supports, but it's\n *     indeed an AC3 stream packed in SPDIF frames (i.e. no real AC3 stream).\n */\n\n\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/usb.h>\n#include <linux/moduleparam.h>\n#include <linux/mutex.h>\n#include <linux/usb/audio.h>\n#include <linux/usb/audio-v2.h>\n#include <linux/module.h>\n\n#include <sound/control.h>\n#include <sound/core.h>\n#include <sound/info.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/initval.h>\n\n#include \"usbaudio.h\"\n#include \"card.h\"\n#include \"midi.h\"\n#include \"mixer.h\"\n#include \"proc.h\"\n#include \"quirks.h\"\n#include \"endpoint.h\"\n#include \"helper.h\"\n#include \"debug.h\"\n#include \"pcm.h\"\n#include \"format.h\"\n#include \"power.h\"\n#include \"stream.h\"\n\nMODULE_AUTHOR(\"Takashi Iwai <tiwai@suse.de>\");\nMODULE_DESCRIPTION(\"USB Audio\");\nMODULE_LICENSE(\"GPL\");\nMODULE_SUPPORTED_DEVICE(\"{{Generic,USB Audio}}\");\n\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\t/* Index 0-MAX */\nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\t/* ID for this card */\nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;/* Enable this card */\n/* Vendor/product IDs for this card */\nstatic int vid[SNDRV_CARDS] = { [0 ... (SNDRV_CARDS-1)] = -1 };\nstatic int pid[SNDRV_CARDS] = { [0 ... (SNDRV_CARDS-1)] = -1 };\nstatic int device_setup[SNDRV_CARDS]; /* device parameter for this card */\nstatic bool ignore_ctl_error;\nstatic bool autoclock = true;\nstatic char *quirk_alias[SNDRV_CARDS];\n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for the USB audio adapter.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for the USB audio adapter.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable USB audio adapter.\");\nmodule_param_array(vid, int, NULL, 0444);\nMODULE_PARM_DESC(vid, \"Vendor ID for the USB audio device.\");\nmodule_param_array(pid, int, NULL, 0444);\nMODULE_PARM_DESC(pid, \"Product ID for the USB audio device.\");\nmodule_param_array(device_setup, int, NULL, 0444);\nMODULE_PARM_DESC(device_setup, \"Specific device setup (if needed).\");\nmodule_param(ignore_ctl_error, bool, 0444);\nMODULE_PARM_DESC(ignore_ctl_error,\n\t\t \"Ignore errors from USB controller for mixer interfaces.\");\nmodule_param(autoclock, bool, 0444);\nMODULE_PARM_DESC(autoclock, \"Enable auto-clock selection for UAC2 devices (default: yes).\");\nmodule_param_array(quirk_alias, charp, NULL, 0444);\nMODULE_PARM_DESC(quirk_alias, \"Quirk aliases, e.g. 0123abcd:5678beef.\");\n\n/*\n * we keep the snd_usb_audio_t instances by ourselves for merging\n * the all interfaces on the same card as one sound device.\n */\n\nstatic DEFINE_MUTEX(register_mutex);\nstatic struct snd_usb_audio *usb_chip[SNDRV_CARDS];\nstatic struct usb_driver usb_audio_driver;\n\n/*\n * disconnect streams\n * called from usb_audio_disconnect()\n */\nstatic void snd_usb_stream_disconnect(struct snd_usb_stream *as)\n{\n\tint idx;\n\tstruct snd_usb_substream *subs;\n\n\tfor (idx = 0; idx < 2; idx++) {\n\t\tsubs = &as->substream[idx];\n\t\tif (!subs->num_formats)\n\t\t\tcontinue;\n\t\tsubs->interface = -1;\n\t\tsubs->data_endpoint = NULL;\n\t\tsubs->sync_endpoint = NULL;\n\t}\n}\n\nstatic int snd_usb_create_stream(struct snd_usb_audio *chip, int ctrlif, int interface)\n{\n\tstruct usb_device *dev = chip->dev;\n\tstruct usb_host_interface *alts;\n\tstruct usb_interface_descriptor *altsd;\n\tstruct usb_interface *iface = usb_ifnum_to_if(dev, interface);\n\n\tif (!iface) {\n\t\tdev_err(&dev->dev, \"%u:%d : does not exist\\n\",\n\t\t\tctrlif, interface);\n\t\treturn -EINVAL;\n\t}\n\n\talts = &iface->altsetting[0];\n\taltsd = get_iface_desc(alts);\n\n\t/*\n\t * Android with both accessory and audio interfaces enabled gets the\n\t * interface numbers wrong.\n\t */\n\tif ((chip->usb_id == USB_ID(0x18d1, 0x2d04) ||\n\t     chip->usb_id == USB_ID(0x18d1, 0x2d05)) &&\n\t    interface == 0 &&\n\t    altsd->bInterfaceClass == USB_CLASS_VENDOR_SPEC &&\n\t    altsd->bInterfaceSubClass == USB_SUBCLASS_VENDOR_SPEC) {\n\t\tinterface = 2;\n\t\tiface = usb_ifnum_to_if(dev, interface);\n\t\tif (!iface)\n\t\t\treturn -EINVAL;\n\t\talts = &iface->altsetting[0];\n\t\taltsd = get_iface_desc(alts);\n\t}\n\n\tif (usb_interface_claimed(iface)) {\n\t\tdev_dbg(&dev->dev, \"%d:%d: skipping, already claimed\\n\",\n\t\t\tctrlif, interface);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((altsd->bInterfaceClass == USB_CLASS_AUDIO ||\n\t     altsd->bInterfaceClass == USB_CLASS_VENDOR_SPEC) &&\n\t    altsd->bInterfaceSubClass == USB_SUBCLASS_MIDISTREAMING) {\n\t\tint err = __snd_usbmidi_create(chip->card, iface,\n\t\t\t\t\t     &chip->midi_list, NULL,\n\t\t\t\t\t     chip->usb_id);\n\t\tif (err < 0) {\n\t\t\tdev_err(&dev->dev,\n\t\t\t\t\"%u:%d: cannot create sequencer device\\n\",\n\t\t\t\tctrlif, interface);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tusb_driver_claim_interface(&usb_audio_driver, iface, (void *)-1L);\n\n\t\treturn 0;\n\t}\n\n\tif ((altsd->bInterfaceClass != USB_CLASS_AUDIO &&\n\t     altsd->bInterfaceClass != USB_CLASS_VENDOR_SPEC) ||\n\t    altsd->bInterfaceSubClass != USB_SUBCLASS_AUDIOSTREAMING) {\n\t\tdev_dbg(&dev->dev,\n\t\t\t\"%u:%d: skipping non-supported interface %d\\n\",\n\t\t\tctrlif, interface, altsd->bInterfaceClass);\n\t\t/* skip non-supported classes */\n\t\treturn -EINVAL;\n\t}\n\n\tif (snd_usb_get_speed(dev) == USB_SPEED_LOW) {\n\t\tdev_err(&dev->dev, \"low speed audio streaming not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (! snd_usb_parse_audio_interface(chip, interface)) {\n\t\tusb_set_interface(dev, interface, 0); /* reset the current interface */\n\t\tusb_driver_claim_interface(&usb_audio_driver, iface, (void *)-1L);\n\t}\n\n\treturn 0;\n}\n\n/*\n * parse audio control descriptor and create pcm/midi streams\n */\nstatic int snd_usb_create_streams(struct snd_usb_audio *chip, int ctrlif)\n{\n\tstruct usb_device *dev = chip->dev;\n\tstruct usb_host_interface *host_iface;\n\tstruct usb_interface_descriptor *altsd;\n\tvoid *control_header;\n\tint i, protocol;\n\n\t/* find audiocontrol interface */\n\thost_iface = &usb_ifnum_to_if(dev, ctrlif)->altsetting[0];\n\tcontrol_header = snd_usb_find_csint_desc(host_iface->extra,\n\t\t\t\t\t\t host_iface->extralen,\n\t\t\t\t\t\t NULL, UAC_HEADER);\n\taltsd = get_iface_desc(host_iface);\n\tprotocol = altsd->bInterfaceProtocol;\n\n\tif (!control_header) {\n\t\tdev_err(&dev->dev, \"cannot find UAC_HEADER\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (protocol) {\n\tdefault:\n\t\tdev_warn(&dev->dev,\n\t\t\t \"unknown interface protocol %#02x, assuming v1\\n\",\n\t\t\t protocol);\n\t\t/* fall through */\n\n\tcase UAC_VERSION_1: {\n\t\tstruct uac1_ac_header_descriptor *h1 = control_header;\n\n\t\tif (!h1->bInCollection) {\n\t\t\tdev_info(&dev->dev, \"skipping empty audio interface (v1)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (h1->bLength < sizeof(*h1) + h1->bInCollection) {\n\t\t\tdev_err(&dev->dev, \"invalid UAC_HEADER (v1)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfor (i = 0; i < h1->bInCollection; i++)\n\t\t\tsnd_usb_create_stream(chip, ctrlif, h1->baInterfaceNr[i]);\n\n\t\tbreak;\n\t}\n\n\tcase UAC_VERSION_2: {\n\t\tstruct usb_interface_assoc_descriptor *assoc =\n\t\t\tusb_ifnum_to_if(dev, ctrlif)->intf_assoc;\n\n\t\tif (!assoc) {\n\t\t\t/*\n\t\t\t * Firmware writers cannot count to three.  So to find\n\t\t\t * the IAD on the NuForce UDH-100, also check the next\n\t\t\t * interface.\n\t\t\t */\n\t\t\tstruct usb_interface *iface =\n\t\t\t\tusb_ifnum_to_if(dev, ctrlif + 1);\n\t\t\tif (iface &&\n\t\t\t    iface->intf_assoc &&\n\t\t\t    iface->intf_assoc->bFunctionClass == USB_CLASS_AUDIO &&\n\t\t\t    iface->intf_assoc->bFunctionProtocol == UAC_VERSION_2)\n\t\t\t\tassoc = iface->intf_assoc;\n\t\t}\n\n\t\tif (!assoc) {\n\t\t\tdev_err(&dev->dev, \"Audio class v2 interfaces need an interface association\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfor (i = 0; i < assoc->bInterfaceCount; i++) {\n\t\t\tint intf = assoc->bFirstInterface + i;\n\n\t\t\tif (intf != ctrlif)\n\t\t\t\tsnd_usb_create_stream(chip, ctrlif, intf);\n\t\t}\n\n\t\tbreak;\n\t}\n\t}\n\n\treturn 0;\n}\n\n/*\n * free the chip instance\n *\n * here we have to do not much, since pcm and controls are already freed\n *\n */\n\nstatic int snd_usb_audio_free(struct snd_usb_audio *chip)\n{\n\tstruct snd_usb_endpoint *ep, *n;\n\n\tlist_for_each_entry_safe(ep, n, &chip->ep_list, list)\n\t\tsnd_usb_endpoint_free(ep);\n\n\tmutex_destroy(&chip->mutex);\n\tif (!atomic_read(&chip->shutdown))\n\t\tdev_set_drvdata(&chip->dev->dev, NULL);\n\tkfree(chip);\n\treturn 0;\n}\n\nstatic int snd_usb_audio_dev_free(struct snd_device *device)\n{\n\tstruct snd_usb_audio *chip = device->device_data;\n\treturn snd_usb_audio_free(chip);\n}\n\n/*\n * create a chip instance and set its names.\n */\nstatic int snd_usb_audio_create(struct usb_interface *intf,\n\t\t\t\tstruct usb_device *dev, int idx,\n\t\t\t\tconst struct snd_usb_audio_quirk *quirk,\n\t\t\t\tunsigned int usb_id,\n\t\t\t\tstruct snd_usb_audio **rchip)\n{\n\tstruct snd_card *card;\n\tstruct snd_usb_audio *chip;\n\tint err, len;\n\tchar component[14];\n\tstatic struct snd_device_ops ops = {\n\t\t.dev_free =\tsnd_usb_audio_dev_free,\n\t};\n\n\t*rchip = NULL;\n\n\tswitch (snd_usb_get_speed(dev)) {\n\tcase USB_SPEED_LOW:\n\tcase USB_SPEED_FULL:\n\tcase USB_SPEED_HIGH:\n\tcase USB_SPEED_WIRELESS:\n\tcase USB_SPEED_SUPER:\n\tcase USB_SPEED_SUPER_PLUS:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&dev->dev, \"unknown device speed %d\\n\", snd_usb_get_speed(dev));\n\t\treturn -ENXIO;\n\t}\n\n\terr = snd_card_new(&intf->dev, index[idx], id[idx], THIS_MODULE,\n\t\t\t   0, &card);\n\tif (err < 0) {\n\t\tdev_err(&dev->dev, \"cannot create card instance %d\\n\", idx);\n\t\treturn err;\n\t}\n\n\tchip = kzalloc(sizeof(*chip), GFP_KERNEL);\n\tif (! chip) {\n\t\tsnd_card_free(card);\n\t\treturn -ENOMEM;\n\t}\n\n\tmutex_init(&chip->mutex);\n\tinit_waitqueue_head(&chip->shutdown_wait);\n\tchip->index = idx;\n\tchip->dev = dev;\n\tchip->card = card;\n\tchip->setup = device_setup[idx];\n\tchip->autoclock = autoclock;\n\tatomic_set(&chip->active, 1); /* avoid autopm during probing */\n\tatomic_set(&chip->usage_count, 0);\n\tatomic_set(&chip->shutdown, 0);\n\n\tchip->usb_id = usb_id;\n\tINIT_LIST_HEAD(&chip->pcm_list);\n\tINIT_LIST_HEAD(&chip->ep_list);\n\tINIT_LIST_HEAD(&chip->midi_list);\n\tINIT_LIST_HEAD(&chip->mixer_list);\n\n\tif ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops)) < 0) {\n\t\tsnd_usb_audio_free(chip);\n\t\tsnd_card_free(card);\n\t\treturn err;\n\t}\n\n\tstrcpy(card->driver, \"USB-Audio\");\n\tsprintf(component, \"USB%04x:%04x\",\n\t\tUSB_ID_VENDOR(chip->usb_id), USB_ID_PRODUCT(chip->usb_id));\n\tsnd_component_add(card, component);\n\n\t/* retrieve the device string as shortname */\n\tif (quirk && quirk->product_name && *quirk->product_name) {\n\t\tstrlcpy(card->shortname, quirk->product_name, sizeof(card->shortname));\n\t} else {\n\t\tif (!dev->descriptor.iProduct ||\n\t\t    usb_string(dev, dev->descriptor.iProduct,\n\t\t    card->shortname, sizeof(card->shortname)) <= 0) {\n\t\t\t/* no name available from anywhere, so use ID */\n\t\t\tsprintf(card->shortname, \"USB Device %#04x:%#04x\",\n\t\t\t\tUSB_ID_VENDOR(chip->usb_id),\n\t\t\t\tUSB_ID_PRODUCT(chip->usb_id));\n\t\t}\n\t}\n\tstrim(card->shortname);\n\n\t/* retrieve the vendor and device strings as longname */\n\tif (quirk && quirk->vendor_name && *quirk->vendor_name) {\n\t\tlen = strlcpy(card->longname, quirk->vendor_name, sizeof(card->longname));\n\t} else {\n\t\tif (dev->descriptor.iManufacturer)\n\t\t\tlen = usb_string(dev, dev->descriptor.iManufacturer,\n\t\t\t\t\t card->longname, sizeof(card->longname));\n\t\telse\n\t\t\tlen = 0;\n\t\t/* we don't really care if there isn't any vendor string */\n\t}\n\tif (len > 0) {\n\t\tstrim(card->longname);\n\t\tif (*card->longname)\n\t\t\tstrlcat(card->longname, \" \", sizeof(card->longname));\n\t}\n\n\tstrlcat(card->longname, card->shortname, sizeof(card->longname));\n\n\tlen = strlcat(card->longname, \" at \", sizeof(card->longname));\n\n\tif (len < sizeof(card->longname))\n\t\tusb_make_path(dev, card->longname + len, sizeof(card->longname) - len);\n\n\tswitch (snd_usb_get_speed(dev)) {\n\tcase USB_SPEED_LOW:\n\t\tstrlcat(card->longname, \", low speed\", sizeof(card->longname));\n\t\tbreak;\n\tcase USB_SPEED_FULL:\n\t\tstrlcat(card->longname, \", full speed\", sizeof(card->longname));\n\t\tbreak;\n\tcase USB_SPEED_HIGH:\n\t\tstrlcat(card->longname, \", high speed\", sizeof(card->longname));\n\t\tbreak;\n\tcase USB_SPEED_SUPER:\n\t\tstrlcat(card->longname, \", super speed\", sizeof(card->longname));\n\t\tbreak;\n\tcase USB_SPEED_SUPER_PLUS:\n\t\tstrlcat(card->longname, \", super speed plus\", sizeof(card->longname));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tsnd_usb_audio_create_proc(chip);\n\n\t*rchip = chip;\n\treturn 0;\n}\n\n/* look for a matching quirk alias id */\nstatic bool get_alias_id(struct usb_device *dev, unsigned int *id)\n{\n\tint i;\n\tunsigned int src, dst;\n\n\tfor (i = 0; i < ARRAY_SIZE(quirk_alias); i++) {\n\t\tif (!quirk_alias[i] ||\n\t\t    sscanf(quirk_alias[i], \"%x:%x\", &src, &dst) != 2 ||\n\t\t    src != *id)\n\t\t\tcontinue;\n\t\tdev_info(&dev->dev,\n\t\t\t \"device (%04x:%04x): applying quirk alias %04x:%04x\\n\",\n\t\t\t USB_ID_VENDOR(*id), USB_ID_PRODUCT(*id),\n\t\t\t USB_ID_VENDOR(dst), USB_ID_PRODUCT(dst));\n\t\t*id = dst;\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic const struct usb_device_id usb_audio_ids[]; /* defined below */\n\n/* look for the corresponding quirk */\nstatic const struct snd_usb_audio_quirk *\nget_alias_quirk(struct usb_device *dev, unsigned int id)\n{\n\tconst struct usb_device_id *p;\n\n\tfor (p = usb_audio_ids; p->match_flags; p++) {\n\t\t/* FIXME: this checks only vendor:product pair in the list */\n\t\tif ((p->match_flags & USB_DEVICE_ID_MATCH_DEVICE) ==\n\t\t    USB_DEVICE_ID_MATCH_DEVICE &&\n\t\t    p->idVendor == USB_ID_VENDOR(id) &&\n\t\t    p->idProduct == USB_ID_PRODUCT(id))\n\t\t\treturn (const struct snd_usb_audio_quirk *)p->driver_info;\n\t}\n\n\treturn NULL;\n}\n\n/*\n * probe the active usb device\n *\n * note that this can be called multiple times per a device, when it\n * includes multiple audio control interfaces.\n *\n * thus we check the usb device pointer and creates the card instance\n * only at the first time.  the successive calls of this function will\n * append the pcm interface to the corresponding card.\n */\nstatic int usb_audio_probe(struct usb_interface *intf,\n\t\t\t   const struct usb_device_id *usb_id)\n{\n\tstruct usb_device *dev = interface_to_usbdev(intf);\n\tconst struct snd_usb_audio_quirk *quirk =\n\t\t(const struct snd_usb_audio_quirk *)usb_id->driver_info;\n\tstruct snd_usb_audio *chip;\n\tint i, err;\n\tstruct usb_host_interface *alts;\n\tint ifnum;\n\tu32 id;\n\n\talts = &intf->altsetting[0];\n\tifnum = get_iface_desc(alts)->bInterfaceNumber;\n\tid = USB_ID(le16_to_cpu(dev->descriptor.idVendor),\n\t\t    le16_to_cpu(dev->descriptor.idProduct));\n\tif (get_alias_id(dev, &id))\n\t\tquirk = get_alias_quirk(dev, id);\n\tif (quirk && quirk->ifnum >= 0 && ifnum != quirk->ifnum)\n\t\treturn -ENXIO;\n\n\terr = snd_usb_apply_boot_quirk(dev, intf, quirk, id);\n\tif (err < 0)\n\t\treturn err;\n\n\t/*\n\t * found a config.  now register to ALSA\n\t */\n\n\t/* check whether it's already registered */\n\tchip = NULL;\n\tmutex_lock(&register_mutex);\n\tfor (i = 0; i < SNDRV_CARDS; i++) {\n\t\tif (usb_chip[i] && usb_chip[i]->dev == dev) {\n\t\t\tif (atomic_read(&usb_chip[i]->shutdown)) {\n\t\t\t\tdev_err(&dev->dev, \"USB device is in the shutdown state, cannot create a card instance\\n\");\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto __error;\n\t\t\t}\n\t\t\tchip = usb_chip[i];\n\t\t\tatomic_inc(&chip->active); /* avoid autopm */\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (! chip) {\n\t\t/* it's a fresh one.\n\t\t * now look for an empty slot and create a new card instance\n\t\t */\n\t\tfor (i = 0; i < SNDRV_CARDS; i++)\n\t\t\tif (enable[i] && ! usb_chip[i] &&\n\t\t\t    (vid[i] == -1 || vid[i] == USB_ID_VENDOR(id)) &&\n\t\t\t    (pid[i] == -1 || pid[i] == USB_ID_PRODUCT(id))) {\n\t\t\t\terr = snd_usb_audio_create(intf, dev, i, quirk,\n\t\t\t\t\t\t\t   id, &chip);\n\t\t\t\tif (err < 0)\n\t\t\t\t\tgoto __error;\n\t\t\t\tchip->pm_intf = intf;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (!chip) {\n\t\t\tdev_err(&dev->dev, \"no available usb audio device\\n\");\n\t\t\terr = -ENODEV;\n\t\t\tgoto __error;\n\t\t}\n\t}\n\tdev_set_drvdata(&dev->dev, chip);\n\n\t/*\n\t * For devices with more than one control interface, we assume the\n\t * first contains the audio controls. We might need a more specific\n\t * check here in the future.\n\t */\n\tif (!chip->ctrl_intf)\n\t\tchip->ctrl_intf = alts;\n\n\tchip->txfr_quirk = 0;\n\terr = 1; /* continue */\n\tif (quirk && quirk->ifnum != QUIRK_NO_INTERFACE) {\n\t\t/* need some special handlings */\n\t\terr = snd_usb_create_quirk(chip, intf, &usb_audio_driver, quirk);\n\t\tif (err < 0)\n\t\t\tgoto __error;\n\t}\n\n\tif (err > 0) {\n\t\t/* create normal USB audio interfaces */\n\t\terr = snd_usb_create_streams(chip, ifnum);\n\t\tif (err < 0)\n\t\t\tgoto __error;\n\t\terr = snd_usb_create_mixer(chip, ifnum, ignore_ctl_error);\n\t\tif (err < 0)\n\t\t\tgoto __error;\n\t}\n\n\t/* we are allowed to call snd_card_register() many times */\n\terr = snd_card_register(chip->card);\n\tif (err < 0)\n\t\tgoto __error;\n\n\tusb_chip[chip->index] = chip;\n\tchip->num_interfaces++;\n\tusb_set_intfdata(intf, chip);\n\tatomic_dec(&chip->active);\n\tmutex_unlock(&register_mutex);\n\treturn 0;\n\n __error:\n\tif (chip) {\n\t\tif (!chip->num_interfaces)\n\t\t\tsnd_card_free(chip->card);\n\t\tatomic_dec(&chip->active);\n\t}\n\tmutex_unlock(&register_mutex);\n\treturn err;\n}\n\n/*\n * we need to take care of counter, since disconnection can be called also\n * many times as well as usb_audio_probe().\n */\nstatic void usb_audio_disconnect(struct usb_interface *intf)\n{\n\tstruct snd_usb_audio *chip = usb_get_intfdata(intf);\n\tstruct snd_card *card;\n\tstruct list_head *p;\n\n\tif (chip == (void *)-1L)\n\t\treturn;\n\n\tcard = chip->card;\n\n\tmutex_lock(&register_mutex);\n\tif (atomic_inc_return(&chip->shutdown) == 1) {\n\t\tstruct snd_usb_stream *as;\n\t\tstruct snd_usb_endpoint *ep;\n\t\tstruct usb_mixer_interface *mixer;\n\n\t\t/* wait until all pending tasks done;\n\t\t * they are protected by snd_usb_lock_shutdown()\n\t\t */\n\t\twait_event(chip->shutdown_wait,\n\t\t\t   !atomic_read(&chip->usage_count));\n\t\tsnd_card_disconnect(card);\n\t\t/* release the pcm resources */\n\t\tlist_for_each_entry(as, &chip->pcm_list, list) {\n\t\t\tsnd_usb_stream_disconnect(as);\n\t\t}\n\t\t/* release the endpoint resources */\n\t\tlist_for_each_entry(ep, &chip->ep_list, list) {\n\t\t\tsnd_usb_endpoint_release(ep);\n\t\t}\n\t\t/* release the midi resources */\n\t\tlist_for_each(p, &chip->midi_list) {\n\t\t\tsnd_usbmidi_disconnect(p);\n\t\t}\n\t\t/* release mixer resources */\n\t\tlist_for_each_entry(mixer, &chip->mixer_list, list) {\n\t\t\tsnd_usb_mixer_disconnect(mixer);\n\t\t}\n\t}\n\n\tchip->num_interfaces--;\n\tif (chip->num_interfaces <= 0) {\n\t\tusb_chip[chip->index] = NULL;\n\t\tmutex_unlock(&register_mutex);\n\t\tsnd_card_free_when_closed(card);\n\t} else {\n\t\tmutex_unlock(&register_mutex);\n\t}\n}\n\n/* lock the shutdown (disconnect) task and autoresume */\nint snd_usb_lock_shutdown(struct snd_usb_audio *chip)\n{\n\tint err;\n\n\tatomic_inc(&chip->usage_count);\n\tif (atomic_read(&chip->shutdown)) {\n\t\terr = -EIO;\n\t\tgoto error;\n\t}\n\terr = snd_usb_autoresume(chip);\n\tif (err < 0)\n\t\tgoto error;\n\treturn 0;\n\n error:\n\tif (atomic_dec_and_test(&chip->usage_count))\n\t\twake_up(&chip->shutdown_wait);\n\treturn err;\n}\n\n/* autosuspend and unlock the shutdown */\nvoid snd_usb_unlock_shutdown(struct snd_usb_audio *chip)\n{\n\tsnd_usb_autosuspend(chip);\n\tif (atomic_dec_and_test(&chip->usage_count))\n\t\twake_up(&chip->shutdown_wait);\n}\n\n#ifdef CONFIG_PM\n\nint snd_usb_autoresume(struct snd_usb_audio *chip)\n{\n\tif (atomic_read(&chip->shutdown))\n\t\treturn -EIO;\n\tif (atomic_inc_return(&chip->active) == 1)\n\t\treturn usb_autopm_get_interface(chip->pm_intf);\n\treturn 0;\n}\n\nvoid snd_usb_autosuspend(struct snd_usb_audio *chip)\n{\n\tif (atomic_read(&chip->shutdown))\n\t\treturn;\n\tif (atomic_dec_and_test(&chip->active))\n\t\tusb_autopm_put_interface(chip->pm_intf);\n}\n\nstatic int usb_audio_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\tstruct snd_usb_audio *chip = usb_get_intfdata(intf);\n\tstruct snd_usb_stream *as;\n\tstruct usb_mixer_interface *mixer;\n\tstruct list_head *p;\n\n\tif (chip == (void *)-1L)\n\t\treturn 0;\n\n\tchip->autosuspended = !!PMSG_IS_AUTO(message);\n\tif (!chip->autosuspended)\n\t\tsnd_power_change_state(chip->card, SNDRV_CTL_POWER_D3hot);\n\tif (!chip->num_suspended_intf++) {\n\t\tlist_for_each_entry(as, &chip->pcm_list, list) {\n\t\t\tsnd_pcm_suspend_all(as->pcm);\n\t\t\tas->substream[0].need_setup_ep =\n\t\t\t\tas->substream[1].need_setup_ep = true;\n\t\t}\n\t\tlist_for_each(p, &chip->midi_list)\n\t\t\tsnd_usbmidi_suspend(p);\n\t\tlist_for_each_entry(mixer, &chip->mixer_list, list)\n\t\t\tsnd_usb_mixer_suspend(mixer);\n\t}\n\n\treturn 0;\n}\n\nstatic int __usb_audio_resume(struct usb_interface *intf, bool reset_resume)\n{\n\tstruct snd_usb_audio *chip = usb_get_intfdata(intf);\n\tstruct usb_mixer_interface *mixer;\n\tstruct list_head *p;\n\tint err = 0;\n\n\tif (chip == (void *)-1L)\n\t\treturn 0;\n\tif (--chip->num_suspended_intf)\n\t\treturn 0;\n\n\tatomic_inc(&chip->active); /* avoid autopm */\n\t/*\n\t * ALSA leaves material resumption to user space\n\t * we just notify and restart the mixers\n\t */\n\tlist_for_each_entry(mixer, &chip->mixer_list, list) {\n\t\terr = snd_usb_mixer_resume(mixer, reset_resume);\n\t\tif (err < 0)\n\t\t\tgoto err_out;\n\t}\n\n\tlist_for_each(p, &chip->midi_list) {\n\t\tsnd_usbmidi_resume(p);\n\t}\n\n\tif (!chip->autosuspended)\n\t\tsnd_power_change_state(chip->card, SNDRV_CTL_POWER_D0);\n\tchip->autosuspended = 0;\n\nerr_out:\n\tatomic_dec(&chip->active); /* allow autopm after this point */\n\treturn err;\n}\n\nstatic int usb_audio_resume(struct usb_interface *intf)\n{\n\treturn __usb_audio_resume(intf, false);\n}\n\nstatic int usb_audio_reset_resume(struct usb_interface *intf)\n{\n\treturn __usb_audio_resume(intf, true);\n}\n#else\n#define usb_audio_suspend\tNULL\n#define usb_audio_resume\tNULL\n#define usb_audio_reset_resume\tNULL\n#endif\t\t/* CONFIG_PM */\n\nstatic const struct usb_device_id usb_audio_ids [] = {\n#include \"quirks-table.h\"\n    { .match_flags = (USB_DEVICE_ID_MATCH_INT_CLASS | USB_DEVICE_ID_MATCH_INT_SUBCLASS),\n      .bInterfaceClass = USB_CLASS_AUDIO,\n      .bInterfaceSubClass = USB_SUBCLASS_AUDIOCONTROL },\n    { }\t\t\t\t\t\t/* Terminating entry */\n};\nMODULE_DEVICE_TABLE(usb, usb_audio_ids);\n\n/*\n * entry point for linux usb interface\n */\n\nstatic struct usb_driver usb_audio_driver = {\n\t.name =\t\t\"snd-usb-audio\",\n\t.probe =\tusb_audio_probe,\n\t.disconnect =\tusb_audio_disconnect,\n\t.suspend =\tusb_audio_suspend,\n\t.resume =\tusb_audio_resume,\n\t.reset_resume =\tusb_audio_reset_resume,\n\t.id_table =\tusb_audio_ids,\n\t.supports_autosuspend = 1,\n};\n\nmodule_usb_driver(usb_audio_driver);\n"], "fixing_code": ["/*\n *   (Tentative) USB Audio Driver for ALSA\n *\n *   Copyright (c) 2002 by Takashi Iwai <tiwai@suse.de>\n *\n *   Many codes borrowed from audio.c by\n *\t    Alan Cox (alan@lxorguk.ukuu.org.uk)\n *\t    Thomas Sailer (sailer@ife.ee.ethz.ch)\n *\n *\n *   This program is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation; either version 2 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU General Public License for more details.\n *\n *   You should have received a copy of the GNU General Public License\n *   along with this program; if not, write to the Free Software\n *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA\n *\n *\n *  NOTES:\n *\n *   - the linked URBs would be preferred but not used so far because of\n *     the instability of unlinking.\n *   - type II is not supported properly.  there is no device which supports\n *     this type *correctly*.  SB extigy looks as if it supports, but it's\n *     indeed an AC3 stream packed in SPDIF frames (i.e. no real AC3 stream).\n */\n\n\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/usb.h>\n#include <linux/moduleparam.h>\n#include <linux/mutex.h>\n#include <linux/usb/audio.h>\n#include <linux/usb/audio-v2.h>\n#include <linux/module.h>\n\n#include <sound/control.h>\n#include <sound/core.h>\n#include <sound/info.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/initval.h>\n\n#include \"usbaudio.h\"\n#include \"card.h\"\n#include \"midi.h\"\n#include \"mixer.h\"\n#include \"proc.h\"\n#include \"quirks.h\"\n#include \"endpoint.h\"\n#include \"helper.h\"\n#include \"debug.h\"\n#include \"pcm.h\"\n#include \"format.h\"\n#include \"power.h\"\n#include \"stream.h\"\n\nMODULE_AUTHOR(\"Takashi Iwai <tiwai@suse.de>\");\nMODULE_DESCRIPTION(\"USB Audio\");\nMODULE_LICENSE(\"GPL\");\nMODULE_SUPPORTED_DEVICE(\"{{Generic,USB Audio}}\");\n\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\t/* Index 0-MAX */\nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\t/* ID for this card */\nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;/* Enable this card */\n/* Vendor/product IDs for this card */\nstatic int vid[SNDRV_CARDS] = { [0 ... (SNDRV_CARDS-1)] = -1 };\nstatic int pid[SNDRV_CARDS] = { [0 ... (SNDRV_CARDS-1)] = -1 };\nstatic int device_setup[SNDRV_CARDS]; /* device parameter for this card */\nstatic bool ignore_ctl_error;\nstatic bool autoclock = true;\nstatic char *quirk_alias[SNDRV_CARDS];\n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for the USB audio adapter.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for the USB audio adapter.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable USB audio adapter.\");\nmodule_param_array(vid, int, NULL, 0444);\nMODULE_PARM_DESC(vid, \"Vendor ID for the USB audio device.\");\nmodule_param_array(pid, int, NULL, 0444);\nMODULE_PARM_DESC(pid, \"Product ID for the USB audio device.\");\nmodule_param_array(device_setup, int, NULL, 0444);\nMODULE_PARM_DESC(device_setup, \"Specific device setup (if needed).\");\nmodule_param(ignore_ctl_error, bool, 0444);\nMODULE_PARM_DESC(ignore_ctl_error,\n\t\t \"Ignore errors from USB controller for mixer interfaces.\");\nmodule_param(autoclock, bool, 0444);\nMODULE_PARM_DESC(autoclock, \"Enable auto-clock selection for UAC2 devices (default: yes).\");\nmodule_param_array(quirk_alias, charp, NULL, 0444);\nMODULE_PARM_DESC(quirk_alias, \"Quirk aliases, e.g. 0123abcd:5678beef.\");\n\n/*\n * we keep the snd_usb_audio_t instances by ourselves for merging\n * the all interfaces on the same card as one sound device.\n */\n\nstatic DEFINE_MUTEX(register_mutex);\nstatic struct snd_usb_audio *usb_chip[SNDRV_CARDS];\nstatic struct usb_driver usb_audio_driver;\n\n/*\n * disconnect streams\n * called from usb_audio_disconnect()\n */\nstatic void snd_usb_stream_disconnect(struct snd_usb_stream *as)\n{\n\tint idx;\n\tstruct snd_usb_substream *subs;\n\n\tfor (idx = 0; idx < 2; idx++) {\n\t\tsubs = &as->substream[idx];\n\t\tif (!subs->num_formats)\n\t\t\tcontinue;\n\t\tsubs->interface = -1;\n\t\tsubs->data_endpoint = NULL;\n\t\tsubs->sync_endpoint = NULL;\n\t}\n}\n\nstatic int snd_usb_create_stream(struct snd_usb_audio *chip, int ctrlif, int interface)\n{\n\tstruct usb_device *dev = chip->dev;\n\tstruct usb_host_interface *alts;\n\tstruct usb_interface_descriptor *altsd;\n\tstruct usb_interface *iface = usb_ifnum_to_if(dev, interface);\n\n\tif (!iface) {\n\t\tdev_err(&dev->dev, \"%u:%d : does not exist\\n\",\n\t\t\tctrlif, interface);\n\t\treturn -EINVAL;\n\t}\n\n\talts = &iface->altsetting[0];\n\taltsd = get_iface_desc(alts);\n\n\t/*\n\t * Android with both accessory and audio interfaces enabled gets the\n\t * interface numbers wrong.\n\t */\n\tif ((chip->usb_id == USB_ID(0x18d1, 0x2d04) ||\n\t     chip->usb_id == USB_ID(0x18d1, 0x2d05)) &&\n\t    interface == 0 &&\n\t    altsd->bInterfaceClass == USB_CLASS_VENDOR_SPEC &&\n\t    altsd->bInterfaceSubClass == USB_SUBCLASS_VENDOR_SPEC) {\n\t\tinterface = 2;\n\t\tiface = usb_ifnum_to_if(dev, interface);\n\t\tif (!iface)\n\t\t\treturn -EINVAL;\n\t\talts = &iface->altsetting[0];\n\t\taltsd = get_iface_desc(alts);\n\t}\n\n\tif (usb_interface_claimed(iface)) {\n\t\tdev_dbg(&dev->dev, \"%d:%d: skipping, already claimed\\n\",\n\t\t\tctrlif, interface);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((altsd->bInterfaceClass == USB_CLASS_AUDIO ||\n\t     altsd->bInterfaceClass == USB_CLASS_VENDOR_SPEC) &&\n\t    altsd->bInterfaceSubClass == USB_SUBCLASS_MIDISTREAMING) {\n\t\tint err = __snd_usbmidi_create(chip->card, iface,\n\t\t\t\t\t     &chip->midi_list, NULL,\n\t\t\t\t\t     chip->usb_id);\n\t\tif (err < 0) {\n\t\t\tdev_err(&dev->dev,\n\t\t\t\t\"%u:%d: cannot create sequencer device\\n\",\n\t\t\t\tctrlif, interface);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tusb_driver_claim_interface(&usb_audio_driver, iface, (void *)-1L);\n\n\t\treturn 0;\n\t}\n\n\tif ((altsd->bInterfaceClass != USB_CLASS_AUDIO &&\n\t     altsd->bInterfaceClass != USB_CLASS_VENDOR_SPEC) ||\n\t    altsd->bInterfaceSubClass != USB_SUBCLASS_AUDIOSTREAMING) {\n\t\tdev_dbg(&dev->dev,\n\t\t\t\"%u:%d: skipping non-supported interface %d\\n\",\n\t\t\tctrlif, interface, altsd->bInterfaceClass);\n\t\t/* skip non-supported classes */\n\t\treturn -EINVAL;\n\t}\n\n\tif (snd_usb_get_speed(dev) == USB_SPEED_LOW) {\n\t\tdev_err(&dev->dev, \"low speed audio streaming not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (! snd_usb_parse_audio_interface(chip, interface)) {\n\t\tusb_set_interface(dev, interface, 0); /* reset the current interface */\n\t\tusb_driver_claim_interface(&usb_audio_driver, iface, (void *)-1L);\n\t}\n\n\treturn 0;\n}\n\n/*\n * parse audio control descriptor and create pcm/midi streams\n */\nstatic int snd_usb_create_streams(struct snd_usb_audio *chip, int ctrlif)\n{\n\tstruct usb_device *dev = chip->dev;\n\tstruct usb_host_interface *host_iface;\n\tstruct usb_interface_descriptor *altsd;\n\tvoid *control_header;\n\tint i, protocol;\n\tint rest_bytes;\n\n\t/* find audiocontrol interface */\n\thost_iface = &usb_ifnum_to_if(dev, ctrlif)->altsetting[0];\n\tcontrol_header = snd_usb_find_csint_desc(host_iface->extra,\n\t\t\t\t\t\t host_iface->extralen,\n\t\t\t\t\t\t NULL, UAC_HEADER);\n\taltsd = get_iface_desc(host_iface);\n\tprotocol = altsd->bInterfaceProtocol;\n\n\tif (!control_header) {\n\t\tdev_err(&dev->dev, \"cannot find UAC_HEADER\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trest_bytes = (void *)(host_iface->extra + host_iface->extralen) -\n\t\tcontrol_header;\n\n\t/* just to be sure -- this shouldn't hit at all */\n\tif (rest_bytes <= 0) {\n\t\tdev_err(&dev->dev, \"invalid control header\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (protocol) {\n\tdefault:\n\t\tdev_warn(&dev->dev,\n\t\t\t \"unknown interface protocol %#02x, assuming v1\\n\",\n\t\t\t protocol);\n\t\t/* fall through */\n\n\tcase UAC_VERSION_1: {\n\t\tstruct uac1_ac_header_descriptor *h1 = control_header;\n\n\t\tif (rest_bytes < sizeof(*h1)) {\n\t\t\tdev_err(&dev->dev, \"too short v1 buffer descriptor\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!h1->bInCollection) {\n\t\t\tdev_info(&dev->dev, \"skipping empty audio interface (v1)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (rest_bytes < h1->bLength) {\n\t\t\tdev_err(&dev->dev, \"invalid buffer length (v1)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (h1->bLength < sizeof(*h1) + h1->bInCollection) {\n\t\t\tdev_err(&dev->dev, \"invalid UAC_HEADER (v1)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfor (i = 0; i < h1->bInCollection; i++)\n\t\t\tsnd_usb_create_stream(chip, ctrlif, h1->baInterfaceNr[i]);\n\n\t\tbreak;\n\t}\n\n\tcase UAC_VERSION_2: {\n\t\tstruct usb_interface_assoc_descriptor *assoc =\n\t\t\tusb_ifnum_to_if(dev, ctrlif)->intf_assoc;\n\n\t\tif (!assoc) {\n\t\t\t/*\n\t\t\t * Firmware writers cannot count to three.  So to find\n\t\t\t * the IAD on the NuForce UDH-100, also check the next\n\t\t\t * interface.\n\t\t\t */\n\t\t\tstruct usb_interface *iface =\n\t\t\t\tusb_ifnum_to_if(dev, ctrlif + 1);\n\t\t\tif (iface &&\n\t\t\t    iface->intf_assoc &&\n\t\t\t    iface->intf_assoc->bFunctionClass == USB_CLASS_AUDIO &&\n\t\t\t    iface->intf_assoc->bFunctionProtocol == UAC_VERSION_2)\n\t\t\t\tassoc = iface->intf_assoc;\n\t\t}\n\n\t\tif (!assoc) {\n\t\t\tdev_err(&dev->dev, \"Audio class v2 interfaces need an interface association\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfor (i = 0; i < assoc->bInterfaceCount; i++) {\n\t\t\tint intf = assoc->bFirstInterface + i;\n\n\t\t\tif (intf != ctrlif)\n\t\t\t\tsnd_usb_create_stream(chip, ctrlif, intf);\n\t\t}\n\n\t\tbreak;\n\t}\n\t}\n\n\treturn 0;\n}\n\n/*\n * free the chip instance\n *\n * here we have to do not much, since pcm and controls are already freed\n *\n */\n\nstatic int snd_usb_audio_free(struct snd_usb_audio *chip)\n{\n\tstruct snd_usb_endpoint *ep, *n;\n\n\tlist_for_each_entry_safe(ep, n, &chip->ep_list, list)\n\t\tsnd_usb_endpoint_free(ep);\n\n\tmutex_destroy(&chip->mutex);\n\tif (!atomic_read(&chip->shutdown))\n\t\tdev_set_drvdata(&chip->dev->dev, NULL);\n\tkfree(chip);\n\treturn 0;\n}\n\nstatic int snd_usb_audio_dev_free(struct snd_device *device)\n{\n\tstruct snd_usb_audio *chip = device->device_data;\n\treturn snd_usb_audio_free(chip);\n}\n\n/*\n * create a chip instance and set its names.\n */\nstatic int snd_usb_audio_create(struct usb_interface *intf,\n\t\t\t\tstruct usb_device *dev, int idx,\n\t\t\t\tconst struct snd_usb_audio_quirk *quirk,\n\t\t\t\tunsigned int usb_id,\n\t\t\t\tstruct snd_usb_audio **rchip)\n{\n\tstruct snd_card *card;\n\tstruct snd_usb_audio *chip;\n\tint err, len;\n\tchar component[14];\n\tstatic struct snd_device_ops ops = {\n\t\t.dev_free =\tsnd_usb_audio_dev_free,\n\t};\n\n\t*rchip = NULL;\n\n\tswitch (snd_usb_get_speed(dev)) {\n\tcase USB_SPEED_LOW:\n\tcase USB_SPEED_FULL:\n\tcase USB_SPEED_HIGH:\n\tcase USB_SPEED_WIRELESS:\n\tcase USB_SPEED_SUPER:\n\tcase USB_SPEED_SUPER_PLUS:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&dev->dev, \"unknown device speed %d\\n\", snd_usb_get_speed(dev));\n\t\treturn -ENXIO;\n\t}\n\n\terr = snd_card_new(&intf->dev, index[idx], id[idx], THIS_MODULE,\n\t\t\t   0, &card);\n\tif (err < 0) {\n\t\tdev_err(&dev->dev, \"cannot create card instance %d\\n\", idx);\n\t\treturn err;\n\t}\n\n\tchip = kzalloc(sizeof(*chip), GFP_KERNEL);\n\tif (! chip) {\n\t\tsnd_card_free(card);\n\t\treturn -ENOMEM;\n\t}\n\n\tmutex_init(&chip->mutex);\n\tinit_waitqueue_head(&chip->shutdown_wait);\n\tchip->index = idx;\n\tchip->dev = dev;\n\tchip->card = card;\n\tchip->setup = device_setup[idx];\n\tchip->autoclock = autoclock;\n\tatomic_set(&chip->active, 1); /* avoid autopm during probing */\n\tatomic_set(&chip->usage_count, 0);\n\tatomic_set(&chip->shutdown, 0);\n\n\tchip->usb_id = usb_id;\n\tINIT_LIST_HEAD(&chip->pcm_list);\n\tINIT_LIST_HEAD(&chip->ep_list);\n\tINIT_LIST_HEAD(&chip->midi_list);\n\tINIT_LIST_HEAD(&chip->mixer_list);\n\n\tif ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops)) < 0) {\n\t\tsnd_usb_audio_free(chip);\n\t\tsnd_card_free(card);\n\t\treturn err;\n\t}\n\n\tstrcpy(card->driver, \"USB-Audio\");\n\tsprintf(component, \"USB%04x:%04x\",\n\t\tUSB_ID_VENDOR(chip->usb_id), USB_ID_PRODUCT(chip->usb_id));\n\tsnd_component_add(card, component);\n\n\t/* retrieve the device string as shortname */\n\tif (quirk && quirk->product_name && *quirk->product_name) {\n\t\tstrlcpy(card->shortname, quirk->product_name, sizeof(card->shortname));\n\t} else {\n\t\tif (!dev->descriptor.iProduct ||\n\t\t    usb_string(dev, dev->descriptor.iProduct,\n\t\t    card->shortname, sizeof(card->shortname)) <= 0) {\n\t\t\t/* no name available from anywhere, so use ID */\n\t\t\tsprintf(card->shortname, \"USB Device %#04x:%#04x\",\n\t\t\t\tUSB_ID_VENDOR(chip->usb_id),\n\t\t\t\tUSB_ID_PRODUCT(chip->usb_id));\n\t\t}\n\t}\n\tstrim(card->shortname);\n\n\t/* retrieve the vendor and device strings as longname */\n\tif (quirk && quirk->vendor_name && *quirk->vendor_name) {\n\t\tlen = strlcpy(card->longname, quirk->vendor_name, sizeof(card->longname));\n\t} else {\n\t\tif (dev->descriptor.iManufacturer)\n\t\t\tlen = usb_string(dev, dev->descriptor.iManufacturer,\n\t\t\t\t\t card->longname, sizeof(card->longname));\n\t\telse\n\t\t\tlen = 0;\n\t\t/* we don't really care if there isn't any vendor string */\n\t}\n\tif (len > 0) {\n\t\tstrim(card->longname);\n\t\tif (*card->longname)\n\t\t\tstrlcat(card->longname, \" \", sizeof(card->longname));\n\t}\n\n\tstrlcat(card->longname, card->shortname, sizeof(card->longname));\n\n\tlen = strlcat(card->longname, \" at \", sizeof(card->longname));\n\n\tif (len < sizeof(card->longname))\n\t\tusb_make_path(dev, card->longname + len, sizeof(card->longname) - len);\n\n\tswitch (snd_usb_get_speed(dev)) {\n\tcase USB_SPEED_LOW:\n\t\tstrlcat(card->longname, \", low speed\", sizeof(card->longname));\n\t\tbreak;\n\tcase USB_SPEED_FULL:\n\t\tstrlcat(card->longname, \", full speed\", sizeof(card->longname));\n\t\tbreak;\n\tcase USB_SPEED_HIGH:\n\t\tstrlcat(card->longname, \", high speed\", sizeof(card->longname));\n\t\tbreak;\n\tcase USB_SPEED_SUPER:\n\t\tstrlcat(card->longname, \", super speed\", sizeof(card->longname));\n\t\tbreak;\n\tcase USB_SPEED_SUPER_PLUS:\n\t\tstrlcat(card->longname, \", super speed plus\", sizeof(card->longname));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tsnd_usb_audio_create_proc(chip);\n\n\t*rchip = chip;\n\treturn 0;\n}\n\n/* look for a matching quirk alias id */\nstatic bool get_alias_id(struct usb_device *dev, unsigned int *id)\n{\n\tint i;\n\tunsigned int src, dst;\n\n\tfor (i = 0; i < ARRAY_SIZE(quirk_alias); i++) {\n\t\tif (!quirk_alias[i] ||\n\t\t    sscanf(quirk_alias[i], \"%x:%x\", &src, &dst) != 2 ||\n\t\t    src != *id)\n\t\t\tcontinue;\n\t\tdev_info(&dev->dev,\n\t\t\t \"device (%04x:%04x): applying quirk alias %04x:%04x\\n\",\n\t\t\t USB_ID_VENDOR(*id), USB_ID_PRODUCT(*id),\n\t\t\t USB_ID_VENDOR(dst), USB_ID_PRODUCT(dst));\n\t\t*id = dst;\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic const struct usb_device_id usb_audio_ids[]; /* defined below */\n\n/* look for the corresponding quirk */\nstatic const struct snd_usb_audio_quirk *\nget_alias_quirk(struct usb_device *dev, unsigned int id)\n{\n\tconst struct usb_device_id *p;\n\n\tfor (p = usb_audio_ids; p->match_flags; p++) {\n\t\t/* FIXME: this checks only vendor:product pair in the list */\n\t\tif ((p->match_flags & USB_DEVICE_ID_MATCH_DEVICE) ==\n\t\t    USB_DEVICE_ID_MATCH_DEVICE &&\n\t\t    p->idVendor == USB_ID_VENDOR(id) &&\n\t\t    p->idProduct == USB_ID_PRODUCT(id))\n\t\t\treturn (const struct snd_usb_audio_quirk *)p->driver_info;\n\t}\n\n\treturn NULL;\n}\n\n/*\n * probe the active usb device\n *\n * note that this can be called multiple times per a device, when it\n * includes multiple audio control interfaces.\n *\n * thus we check the usb device pointer and creates the card instance\n * only at the first time.  the successive calls of this function will\n * append the pcm interface to the corresponding card.\n */\nstatic int usb_audio_probe(struct usb_interface *intf,\n\t\t\t   const struct usb_device_id *usb_id)\n{\n\tstruct usb_device *dev = interface_to_usbdev(intf);\n\tconst struct snd_usb_audio_quirk *quirk =\n\t\t(const struct snd_usb_audio_quirk *)usb_id->driver_info;\n\tstruct snd_usb_audio *chip;\n\tint i, err;\n\tstruct usb_host_interface *alts;\n\tint ifnum;\n\tu32 id;\n\n\talts = &intf->altsetting[0];\n\tifnum = get_iface_desc(alts)->bInterfaceNumber;\n\tid = USB_ID(le16_to_cpu(dev->descriptor.idVendor),\n\t\t    le16_to_cpu(dev->descriptor.idProduct));\n\tif (get_alias_id(dev, &id))\n\t\tquirk = get_alias_quirk(dev, id);\n\tif (quirk && quirk->ifnum >= 0 && ifnum != quirk->ifnum)\n\t\treturn -ENXIO;\n\n\terr = snd_usb_apply_boot_quirk(dev, intf, quirk, id);\n\tif (err < 0)\n\t\treturn err;\n\n\t/*\n\t * found a config.  now register to ALSA\n\t */\n\n\t/* check whether it's already registered */\n\tchip = NULL;\n\tmutex_lock(&register_mutex);\n\tfor (i = 0; i < SNDRV_CARDS; i++) {\n\t\tif (usb_chip[i] && usb_chip[i]->dev == dev) {\n\t\t\tif (atomic_read(&usb_chip[i]->shutdown)) {\n\t\t\t\tdev_err(&dev->dev, \"USB device is in the shutdown state, cannot create a card instance\\n\");\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto __error;\n\t\t\t}\n\t\t\tchip = usb_chip[i];\n\t\t\tatomic_inc(&chip->active); /* avoid autopm */\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (! chip) {\n\t\t/* it's a fresh one.\n\t\t * now look for an empty slot and create a new card instance\n\t\t */\n\t\tfor (i = 0; i < SNDRV_CARDS; i++)\n\t\t\tif (enable[i] && ! usb_chip[i] &&\n\t\t\t    (vid[i] == -1 || vid[i] == USB_ID_VENDOR(id)) &&\n\t\t\t    (pid[i] == -1 || pid[i] == USB_ID_PRODUCT(id))) {\n\t\t\t\terr = snd_usb_audio_create(intf, dev, i, quirk,\n\t\t\t\t\t\t\t   id, &chip);\n\t\t\t\tif (err < 0)\n\t\t\t\t\tgoto __error;\n\t\t\t\tchip->pm_intf = intf;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (!chip) {\n\t\t\tdev_err(&dev->dev, \"no available usb audio device\\n\");\n\t\t\terr = -ENODEV;\n\t\t\tgoto __error;\n\t\t}\n\t}\n\tdev_set_drvdata(&dev->dev, chip);\n\n\t/*\n\t * For devices with more than one control interface, we assume the\n\t * first contains the audio controls. We might need a more specific\n\t * check here in the future.\n\t */\n\tif (!chip->ctrl_intf)\n\t\tchip->ctrl_intf = alts;\n\n\tchip->txfr_quirk = 0;\n\terr = 1; /* continue */\n\tif (quirk && quirk->ifnum != QUIRK_NO_INTERFACE) {\n\t\t/* need some special handlings */\n\t\terr = snd_usb_create_quirk(chip, intf, &usb_audio_driver, quirk);\n\t\tif (err < 0)\n\t\t\tgoto __error;\n\t}\n\n\tif (err > 0) {\n\t\t/* create normal USB audio interfaces */\n\t\terr = snd_usb_create_streams(chip, ifnum);\n\t\tif (err < 0)\n\t\t\tgoto __error;\n\t\terr = snd_usb_create_mixer(chip, ifnum, ignore_ctl_error);\n\t\tif (err < 0)\n\t\t\tgoto __error;\n\t}\n\n\t/* we are allowed to call snd_card_register() many times */\n\terr = snd_card_register(chip->card);\n\tif (err < 0)\n\t\tgoto __error;\n\n\tusb_chip[chip->index] = chip;\n\tchip->num_interfaces++;\n\tusb_set_intfdata(intf, chip);\n\tatomic_dec(&chip->active);\n\tmutex_unlock(&register_mutex);\n\treturn 0;\n\n __error:\n\tif (chip) {\n\t\tif (!chip->num_interfaces)\n\t\t\tsnd_card_free(chip->card);\n\t\tatomic_dec(&chip->active);\n\t}\n\tmutex_unlock(&register_mutex);\n\treturn err;\n}\n\n/*\n * we need to take care of counter, since disconnection can be called also\n * many times as well as usb_audio_probe().\n */\nstatic void usb_audio_disconnect(struct usb_interface *intf)\n{\n\tstruct snd_usb_audio *chip = usb_get_intfdata(intf);\n\tstruct snd_card *card;\n\tstruct list_head *p;\n\n\tif (chip == (void *)-1L)\n\t\treturn;\n\n\tcard = chip->card;\n\n\tmutex_lock(&register_mutex);\n\tif (atomic_inc_return(&chip->shutdown) == 1) {\n\t\tstruct snd_usb_stream *as;\n\t\tstruct snd_usb_endpoint *ep;\n\t\tstruct usb_mixer_interface *mixer;\n\n\t\t/* wait until all pending tasks done;\n\t\t * they are protected by snd_usb_lock_shutdown()\n\t\t */\n\t\twait_event(chip->shutdown_wait,\n\t\t\t   !atomic_read(&chip->usage_count));\n\t\tsnd_card_disconnect(card);\n\t\t/* release the pcm resources */\n\t\tlist_for_each_entry(as, &chip->pcm_list, list) {\n\t\t\tsnd_usb_stream_disconnect(as);\n\t\t}\n\t\t/* release the endpoint resources */\n\t\tlist_for_each_entry(ep, &chip->ep_list, list) {\n\t\t\tsnd_usb_endpoint_release(ep);\n\t\t}\n\t\t/* release the midi resources */\n\t\tlist_for_each(p, &chip->midi_list) {\n\t\t\tsnd_usbmidi_disconnect(p);\n\t\t}\n\t\t/* release mixer resources */\n\t\tlist_for_each_entry(mixer, &chip->mixer_list, list) {\n\t\t\tsnd_usb_mixer_disconnect(mixer);\n\t\t}\n\t}\n\n\tchip->num_interfaces--;\n\tif (chip->num_interfaces <= 0) {\n\t\tusb_chip[chip->index] = NULL;\n\t\tmutex_unlock(&register_mutex);\n\t\tsnd_card_free_when_closed(card);\n\t} else {\n\t\tmutex_unlock(&register_mutex);\n\t}\n}\n\n/* lock the shutdown (disconnect) task and autoresume */\nint snd_usb_lock_shutdown(struct snd_usb_audio *chip)\n{\n\tint err;\n\n\tatomic_inc(&chip->usage_count);\n\tif (atomic_read(&chip->shutdown)) {\n\t\terr = -EIO;\n\t\tgoto error;\n\t}\n\terr = snd_usb_autoresume(chip);\n\tif (err < 0)\n\t\tgoto error;\n\treturn 0;\n\n error:\n\tif (atomic_dec_and_test(&chip->usage_count))\n\t\twake_up(&chip->shutdown_wait);\n\treturn err;\n}\n\n/* autosuspend and unlock the shutdown */\nvoid snd_usb_unlock_shutdown(struct snd_usb_audio *chip)\n{\n\tsnd_usb_autosuspend(chip);\n\tif (atomic_dec_and_test(&chip->usage_count))\n\t\twake_up(&chip->shutdown_wait);\n}\n\n#ifdef CONFIG_PM\n\nint snd_usb_autoresume(struct snd_usb_audio *chip)\n{\n\tif (atomic_read(&chip->shutdown))\n\t\treturn -EIO;\n\tif (atomic_inc_return(&chip->active) == 1)\n\t\treturn usb_autopm_get_interface(chip->pm_intf);\n\treturn 0;\n}\n\nvoid snd_usb_autosuspend(struct snd_usb_audio *chip)\n{\n\tif (atomic_read(&chip->shutdown))\n\t\treturn;\n\tif (atomic_dec_and_test(&chip->active))\n\t\tusb_autopm_put_interface(chip->pm_intf);\n}\n\nstatic int usb_audio_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\tstruct snd_usb_audio *chip = usb_get_intfdata(intf);\n\tstruct snd_usb_stream *as;\n\tstruct usb_mixer_interface *mixer;\n\tstruct list_head *p;\n\n\tif (chip == (void *)-1L)\n\t\treturn 0;\n\n\tchip->autosuspended = !!PMSG_IS_AUTO(message);\n\tif (!chip->autosuspended)\n\t\tsnd_power_change_state(chip->card, SNDRV_CTL_POWER_D3hot);\n\tif (!chip->num_suspended_intf++) {\n\t\tlist_for_each_entry(as, &chip->pcm_list, list) {\n\t\t\tsnd_pcm_suspend_all(as->pcm);\n\t\t\tas->substream[0].need_setup_ep =\n\t\t\t\tas->substream[1].need_setup_ep = true;\n\t\t}\n\t\tlist_for_each(p, &chip->midi_list)\n\t\t\tsnd_usbmidi_suspend(p);\n\t\tlist_for_each_entry(mixer, &chip->mixer_list, list)\n\t\t\tsnd_usb_mixer_suspend(mixer);\n\t}\n\n\treturn 0;\n}\n\nstatic int __usb_audio_resume(struct usb_interface *intf, bool reset_resume)\n{\n\tstruct snd_usb_audio *chip = usb_get_intfdata(intf);\n\tstruct usb_mixer_interface *mixer;\n\tstruct list_head *p;\n\tint err = 0;\n\n\tif (chip == (void *)-1L)\n\t\treturn 0;\n\tif (--chip->num_suspended_intf)\n\t\treturn 0;\n\n\tatomic_inc(&chip->active); /* avoid autopm */\n\t/*\n\t * ALSA leaves material resumption to user space\n\t * we just notify and restart the mixers\n\t */\n\tlist_for_each_entry(mixer, &chip->mixer_list, list) {\n\t\terr = snd_usb_mixer_resume(mixer, reset_resume);\n\t\tif (err < 0)\n\t\t\tgoto err_out;\n\t}\n\n\tlist_for_each(p, &chip->midi_list) {\n\t\tsnd_usbmidi_resume(p);\n\t}\n\n\tif (!chip->autosuspended)\n\t\tsnd_power_change_state(chip->card, SNDRV_CTL_POWER_D0);\n\tchip->autosuspended = 0;\n\nerr_out:\n\tatomic_dec(&chip->active); /* allow autopm after this point */\n\treturn err;\n}\n\nstatic int usb_audio_resume(struct usb_interface *intf)\n{\n\treturn __usb_audio_resume(intf, false);\n}\n\nstatic int usb_audio_reset_resume(struct usb_interface *intf)\n{\n\treturn __usb_audio_resume(intf, true);\n}\n#else\n#define usb_audio_suspend\tNULL\n#define usb_audio_resume\tNULL\n#define usb_audio_reset_resume\tNULL\n#endif\t\t/* CONFIG_PM */\n\nstatic const struct usb_device_id usb_audio_ids [] = {\n#include \"quirks-table.h\"\n    { .match_flags = (USB_DEVICE_ID_MATCH_INT_CLASS | USB_DEVICE_ID_MATCH_INT_SUBCLASS),\n      .bInterfaceClass = USB_CLASS_AUDIO,\n      .bInterfaceSubClass = USB_SUBCLASS_AUDIOCONTROL },\n    { }\t\t\t\t\t\t/* Terminating entry */\n};\nMODULE_DEVICE_TABLE(usb, usb_audio_ids);\n\n/*\n * entry point for linux usb interface\n */\n\nstatic struct usb_driver usb_audio_driver = {\n\t.name =\t\t\"snd-usb-audio\",\n\t.probe =\tusb_audio_probe,\n\t.disconnect =\tusb_audio_disconnect,\n\t.suspend =\tusb_audio_suspend,\n\t.resume =\tusb_audio_resume,\n\t.reset_resume =\tusb_audio_reset_resume,\n\t.id_table =\tusb_audio_ids,\n\t.supports_autosuspend = 1,\n};\n\nmodule_usb_driver(usb_audio_driver);\n"], "filenames": ["sound/usb/card.c"], "buggy_code_start_loc": [223], "buggy_code_end_loc": [249], "fixing_code_start_loc": [224], "fixing_code_end_loc": [270], "type": "CWE-125", "message": "The snd_usb_create_streams function in sound/usb/card.c in the Linux kernel before 4.13.6 allows local users to cause a denial of service (out-of-bounds read and system crash) or possibly have unspecified other impact via a crafted USB device.", "other": {"cve": {"id": "CVE-2017-16529", "sourceIdentifier": "cve@mitre.org", "published": "2017-11-04T01:29:36.880", "lastModified": "2018-08-24T10:29:00.927", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The snd_usb_create_streams function in sound/usb/card.c in the Linux kernel before 4.13.6 allows local users to cause a denial of service (out-of-bounds read and system crash) or possibly have unspecified other impact via a crafted USB device."}, {"lang": "es", "value": "La funci\u00f3n snd_usb_create_streams en sound/usb/card.c en el kernel de Linux, en versiones anteriores a la 4.13.6, permite que los usuarios locales provoquen una denegaci\u00f3n de servicio (lectura fuera de l\u00edmites y cierre inesperado del sistema) o, posiblemente, causen otros impactos no especificados mediante llamadas del sistema manipuladas."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:P/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "PHYSICAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 6.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.7, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.13.5", "matchCriteriaId": "8CBA5FF4-3406-4A63-9242-E6597219C011"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/103284", "source": "cve@mitre.org"}, {"url": "https://github.com/torvalds/linux/commit/bfc81a8bc18e3c4ba0cbaa7666ff76be2f998991", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://groups.google.com/d/msg/syzkaller/rDzv5RP_f2M/M5au06qmAwAJ", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2017/12/msg00004.html", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3754-1/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/bfc81a8bc18e3c4ba0cbaa7666ff76be2f998991"}}