{"buggy_code": ["/*****************************************************************\n|\n|   Platinum - HTTP Server\n|\n| Copyright (c) 2004-2010, Plutinosoft, LLC.\n| All rights reserved.\n| http://www.plutinosoft.com\n|\n| This program is free software; you can redistribute it and/or\n| modify it under the terms of the GNU General Public License\n| as published by the Free Software Foundation; either version 2\n| of the License, or (at your option) any later version.\n|\n| OEMs, ISVs, VARs and other distributors that combine and \n| distribute commercially licensed software with Platinum software\n| and do not wish to distribute the source code for the commercially\n| licensed software under version 2, or (at your option) any later\n| version, of the GNU General Public License (the \"GPL\") must enter\n| into a commercial license agreement with Plutinosoft, LLC.\n| licensing@plutinosoft.com\n|  \n| This program is distributed in the hope that it will be useful,\n| but WITHOUT ANY WARRANTY; without even the implied warranty of\n| MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n| GNU General Public License for more details.\n|\n| You should have received a copy of the GNU General Public License\n| along with this program; see the file LICENSE.txt. If not, write to\n| the Free Software Foundation, Inc., \n| 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n| http://www.gnu.org/licenses/gpl-2.0.html\n|\n****************************************************************/\n\n/*----------------------------------------------------------------------\n|   includes\n+---------------------------------------------------------------------*/\n#include \"PltTaskManager.h\"\n#include \"PltHttpServer.h\"\n#include \"PltHttp.h\"\n#include \"PltVersion.h\"\n#include \"PltUtilities.h\"\n#include \"PltProtocolInfo.h\"\n#include \"PltMimeType.h\"\n\nNPT_SET_LOCAL_LOGGER(\"platinum.core.http.server\")\n\n/*----------------------------------------------------------------------\n|   PLT_HttpServer::PLT_HttpServer\n+---------------------------------------------------------------------*/\nPLT_HttpServer::PLT_HttpServer(NPT_IpAddress address,\n                               NPT_IpPort    port,\n                               bool          allow_random_port_on_bind_failure,   /* = false */\n                               NPT_Cardinal  max_clients,                         /* = 50 */\n                               bool          reuse_address) :                     /* = false */\n    NPT_HttpServer(address, port, true),\n    m_TaskManager(new PLT_TaskManager(max_clients)),\n    m_Address(address),\n    m_Port(port),\n    m_AllowRandomPortOnBindFailure(allow_random_port_on_bind_failure),\n    m_ReuseAddress(reuse_address),\n    m_Running(false),\n    m_Aborted(false)\n{\n}\n\n/*----------------------------------------------------------------------\n|   PLT_HttpServer::~PLT_HttpServer\n+---------------------------------------------------------------------*/\nPLT_HttpServer::~PLT_HttpServer()\n{ \n    Stop();\n}\n\n/*----------------------------------------------------------------------\n|   PLT_HttpServer::Start\n+---------------------------------------------------------------------*/\nNPT_Result\nPLT_HttpServer::Start()\n{\n    NPT_Result res = NPT_FAILURE;\n    \n    // we can't start an already running server or restart an aborted server\n    // because the socket is shared create a new instance\n    if (m_Running || m_Aborted) NPT_CHECK_WARNING(NPT_ERROR_INVALID_STATE);\n    \n    // if we're given a port for our http server, try it\n    if (m_Port) {\n        res = SetListenPort(m_Port, m_ReuseAddress);\n        // return right away if failed and not allowed to try again randomly\n        if (NPT_FAILED(res) && !m_AllowRandomPortOnBindFailure) {\n            NPT_CHECK_SEVERE(res);\n        }\n    }\n    \n    // try random port now\n    if (!m_Port || NPT_FAILED(res)) {\n        int retries = 100;\n        do {    \n            int random = NPT_System::GetRandomInteger();\n            int port = (unsigned short)(1024 + (random % 1024));\n            if (NPT_SUCCEEDED(SetListenPort(port, m_ReuseAddress))) {\n                break;\n            }\n        } while (--retries > 0);\n\n        if (retries == 0) NPT_CHECK_SEVERE(NPT_FAILURE);\n    }\n\n    // keep track of port server has successfully bound\n    m_Port = m_BoundPort;\n\n    // Tell server to try to listen to more incoming sockets\n    // (this could fail silently)\n    if (m_TaskManager->GetMaxTasks() > 20) {\n        m_Socket.Listen(m_TaskManager->GetMaxTasks());\n    }\n    \n    // start a task to listen for incoming connections\n    PLT_HttpListenTask *task = new PLT_HttpListenTask(this, &m_Socket, false);\n    NPT_CHECK_SEVERE(m_TaskManager->StartTask(task));\n\n    NPT_SocketInfo info;\n    m_Socket.GetInfo(info);\n    NPT_LOG_INFO_2(\"HttpServer listening on %s:%d\", \n        (const char*)info.local_address.GetIpAddress().ToString(), \n        m_Port);\n    \n    m_Running = true;\n    return NPT_SUCCESS;\n}\n\n/*----------------------------------------------------------------------\n|   PLT_HttpServer::Stop\n+---------------------------------------------------------------------*/\nNPT_Result\nPLT_HttpServer::Stop()\n{\n    // we can't restart an aborted server\n    if (m_Aborted || !m_Running) NPT_CHECK_WARNING(NPT_ERROR_INVALID_STATE);\n    \n    // stop all other pending tasks \n    m_TaskManager->Abort();\n    \n    m_Running = false;\n    m_Aborted = true;\n    \n    return NPT_SUCCESS;\n}\n\n/*----------------------------------------------------------------------\n|   PLT_HttpServer::SetupResponse\n+---------------------------------------------------------------------*/\nNPT_Result \nPLT_HttpServer::SetupResponse(NPT_HttpRequest&              request, \n                              const NPT_HttpRequestContext& context,\n                              NPT_HttpResponse&             response) \n{\n    NPT_String prefix = NPT_String::Format(\"PLT_HttpServer::SetupResponse %s request from %s for \\\"%s\\\"\", \n        (const char*) request.GetMethod(),\n        (const char*) context.GetRemoteAddress().ToString(),\n        (const char*) request.GetUrl().ToString());\n    PLT_LOG_HTTP_REQUEST(NPT_LOG_LEVEL_FINE, prefix, &request);\n\n    NPT_List<NPT_HttpRequestHandler*> handlers = FindRequestHandlers(request);\n    if (handlers.GetItemCount() == 0) return NPT_ERROR_NO_SUCH_ITEM;\n\n    // ask the handler to setup the response\n    NPT_Result result = (*handlers.GetFirstItem())->SetupResponse(request, context, response);\n    \n    // DLNA compliance\n    PLT_UPnPMessageHelper::SetDate(response);\n    if (request.GetHeaders().GetHeader(\"Accept-Language\")) {\n        response.GetHeaders().SetHeader(\"Content-Language\", \"en\");\n    }\n    return result;\n}\n\n/*----------------------------------------------------------------------\n|   PLT_HttpServer::ServeFile\n+---------------------------------------------------------------------*/\nNPT_Result \nPLT_HttpServer::ServeFile(const NPT_HttpRequest&        request, \n                          const NPT_HttpRequestContext& context,\n                          NPT_HttpResponse&             response,\n                          NPT_String                    file_path) \n{\n    NPT_InputStreamReference stream;\n    NPT_File                 file(file_path);\n    NPT_FileInfo             file_info;\n    \n    // prevent hackers from accessing files outside of our root\n    if ((file_path.Find(\"/..\") >= 0) || (file_path.Find(\"\\\\..\") >= 0) ||\n        NPT_FAILED(NPT_File::GetInfo(file_path, &file_info))) {\n        return NPT_ERROR_NO_SUCH_ITEM;\n    }\n    \n    // check for range requests\n    const NPT_String* range_spec = request.GetHeaders().GetHeaderValue(NPT_HTTP_HEADER_RANGE);\n    \n    // handle potential 304 only if range header not set\n    NPT_DateTime  date;\n    NPT_TimeStamp timestamp;\n    if (NPT_SUCCEEDED(PLT_UPnPMessageHelper::GetIfModifiedSince((NPT_HttpMessage&)request, date)) &&\n        !range_spec) {\n        date.ToTimeStamp(timestamp);\n        \n        NPT_LOG_INFO_5(\"File %s timestamps: request=%d (%s) vs file=%d (%s)\", \n                       (const char*)request.GetUrl().GetPath(),\n                       (NPT_UInt32)timestamp.ToSeconds(),\n                       (const char*)date.ToString(),\n                       (NPT_UInt32)file_info.m_ModificationTime,\n                       (const char*)NPT_DateTime(file_info.m_ModificationTime).ToString());\n        \n        if (timestamp >= file_info.m_ModificationTime) {\n            // it's a match\n            NPT_LOG_FINE_1(\"Returning 304 for %s\", request.GetUrl().GetPath().GetChars());\n            response.SetStatus(304, \"Not Modified\", NPT_HTTP_PROTOCOL_1_1);\n            return NPT_SUCCESS;\n        }\n    }\n    \n    // open file\n    if (NPT_FAILED(file.Open(NPT_FILE_OPEN_MODE_READ)) || \n        NPT_FAILED(file.GetInputStream(stream))        ||\n        stream.IsNull()) {\n        return NPT_ERROR_NO_SUCH_ITEM;\n    }\n    \n    // set Last-Modified and Cache-Control headers\n    if (file_info.m_ModificationTime) {\n        NPT_DateTime last_modified = NPT_DateTime(file_info.m_ModificationTime);\n        response.GetHeaders().SetHeader(\"Last-Modified\", last_modified.ToString(NPT_DateTime::FORMAT_RFC_1123), true);\n        response.GetHeaders().SetHeader(\"Cache-Control\", \"max-age=0,must-revalidate\", true);\n        //response.GetHeaders().SetHeader(\"Cache-Control\", \"max-age=1800\", true);\n    }\n    \n    PLT_HttpRequestContext tmp_context(request, context);\n    return ServeStream(request, context, response, stream, PLT_MimeType::GetMimeType(file_path, &tmp_context));\n}\n\n/*----------------------------------------------------------------------\n|   PLT_HttpServer::ServeStream\n+---------------------------------------------------------------------*/\nNPT_Result \nPLT_HttpServer::ServeStream(const NPT_HttpRequest&        request, \n                            const NPT_HttpRequestContext& context,\n                            NPT_HttpResponse&             response,\n                            NPT_InputStreamReference&     body, \n                            const char*                   content_type) \n{    \n    if (body.IsNull()) return NPT_FAILURE;\n    \n    // set date\n    NPT_TimeStamp now;\n    NPT_System::GetCurrentTimeStamp(now);\n    response.GetHeaders().SetHeader(\"Date\", NPT_DateTime(now).ToString(NPT_DateTime::FORMAT_RFC_1123), true);\n    \n    // get entity\n    NPT_HttpEntity* entity = response.GetEntity();\n    NPT_CHECK_POINTER_FATAL(entity);\n    \n    // set the content type\n    entity->SetContentType(content_type);\n    \n    // check for range requests\n    const NPT_String* range_spec = request.GetHeaders().GetHeaderValue(NPT_HTTP_HEADER_RANGE);\n    \n    // setup entity body\n    NPT_CHECK(NPT_HttpFileRequestHandler::SetupResponseBody(response, body, range_spec));\n              \n    // set some default headers\n    if (response.GetEntity()->GetTransferEncoding() != NPT_HTTP_TRANSFER_ENCODING_CHUNKED) {\n        // set but don't replace Accept-Range header only if body is seekable\n        NPT_Position offset;\n        if (NPT_SUCCEEDED(body->Tell(offset)) && NPT_SUCCEEDED(body->Seek(offset))) {\n            response.GetHeaders().SetHeader(NPT_HTTP_HEADER_ACCEPT_RANGES, \"bytes\", false); \n        }\n    }\n    \n    // set getcontentFeatures.dlna.org\n    const NPT_String* value = request.GetHeaders().GetHeaderValue(\"getcontentFeatures.dlna.org\");\n    if (value) {\n        PLT_HttpRequestContext tmp_context(request, context);\n        const char* dlna = PLT_ProtocolInfo::GetDlnaExtension(entity->GetContentType(),\n                                                              &tmp_context);\n        if (dlna) response.GetHeaders().SetHeader(\"ContentFeatures.DLNA.ORG\", dlna, false);\n    }\n    \n    // transferMode.dlna.org\n    value = request.GetHeaders().GetHeaderValue(\"transferMode.dlna.org\");\n    if (value) {\n        // Interactive mode not supported?\n        /*if (value->Compare(\"Interactive\", true) == 0) {\n            response.SetStatus(406, \"Not Acceptable\");\n            return NPT_SUCCESS;\n        }*/\n        \n        response.GetHeaders().SetHeader(\"TransferMode.DLNA.ORG\", value->GetChars(), false);\n    } else {\n        response.GetHeaders().SetHeader(\"TransferMode.DLNA.ORG\", \"Streaming\", false);\n    }\n    \n    if (request.GetHeaders().GetHeaderValue(\"TimeSeekRange.dlna.org\")) {\n        response.SetStatus(406, \"Not Acceptable\");\n        return NPT_SUCCESS;\n    }\n    \n    return NPT_SUCCESS;\n}\n"], "fixing_code": ["/*****************************************************************\n|\n|   Platinum - HTTP Server\n|\n| Copyright (c) 2004-2010, Plutinosoft, LLC.\n| All rights reserved.\n| http://www.plutinosoft.com\n|\n| This program is free software; you can redistribute it and/or\n| modify it under the terms of the GNU General Public License\n| as published by the Free Software Foundation; either version 2\n| of the License, or (at your option) any later version.\n|\n| OEMs, ISVs, VARs and other distributors that combine and \n| distribute commercially licensed software with Platinum software\n| and do not wish to distribute the source code for the commercially\n| licensed software under version 2, or (at your option) any later\n| version, of the GNU General Public License (the \"GPL\") must enter\n| into a commercial license agreement with Plutinosoft, LLC.\n| licensing@plutinosoft.com\n|  \n| This program is distributed in the hope that it will be useful,\n| but WITHOUT ANY WARRANTY; without even the implied warranty of\n| MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n| GNU General Public License for more details.\n|\n| You should have received a copy of the GNU General Public License\n| along with this program; see the file LICENSE.txt. If not, write to\n| the Free Software Foundation, Inc., \n| 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n| http://www.gnu.org/licenses/gpl-2.0.html\n|\n****************************************************************/\n\n/*----------------------------------------------------------------------\n|   includes\n+---------------------------------------------------------------------*/\n#include \"PltTaskManager.h\"\n#include \"PltHttpServer.h\"\n#include \"PltHttp.h\"\n#include \"PltVersion.h\"\n#include \"PltUtilities.h\"\n#include \"PltProtocolInfo.h\"\n#include \"PltMimeType.h\"\n\nNPT_SET_LOCAL_LOGGER(\"platinum.core.http.server\")\n\n/*----------------------------------------------------------------------\n|   PLT_HttpServer::PLT_HttpServer\n+---------------------------------------------------------------------*/\nPLT_HttpServer::PLT_HttpServer(NPT_IpAddress address,\n                               NPT_IpPort    port,\n                               bool          allow_random_port_on_bind_failure,   /* = false */\n                               NPT_Cardinal  max_clients,                         /* = 50 */\n                               bool          reuse_address) :                     /* = false */\n    NPT_HttpServer(address, port, true),\n    m_TaskManager(new PLT_TaskManager(max_clients)),\n    m_Address(address),\n    m_Port(port),\n    m_AllowRandomPortOnBindFailure(allow_random_port_on_bind_failure),\n    m_ReuseAddress(reuse_address),\n    m_Running(false),\n    m_Aborted(false)\n{\n}\n\n/*----------------------------------------------------------------------\n|   PLT_HttpServer::~PLT_HttpServer\n+---------------------------------------------------------------------*/\nPLT_HttpServer::~PLT_HttpServer()\n{ \n    Stop();\n}\n\n/*----------------------------------------------------------------------\n|   PLT_HttpServer::Start\n+---------------------------------------------------------------------*/\nNPT_Result\nPLT_HttpServer::Start()\n{\n    NPT_Result res = NPT_FAILURE;\n    \n    // we can't start an already running server or restart an aborted server\n    // because the socket is shared create a new instance\n    if (m_Running || m_Aborted) NPT_CHECK_WARNING(NPT_ERROR_INVALID_STATE);\n    \n    // if we're given a port for our http server, try it\n    if (m_Port) {\n        res = SetListenPort(m_Port, m_ReuseAddress);\n        // return right away if failed and not allowed to try again randomly\n        if (NPT_FAILED(res) && !m_AllowRandomPortOnBindFailure) {\n            NPT_CHECK_SEVERE(res);\n        }\n    }\n    \n    // try random port now\n    if (!m_Port || NPT_FAILED(res)) {\n        int retries = 100;\n        do {    \n            int random = NPT_System::GetRandomInteger();\n            int port = (unsigned short)(1024 + (random % 1024));\n            if (NPT_SUCCEEDED(SetListenPort(port, m_ReuseAddress))) {\n                break;\n            }\n        } while (--retries > 0);\n\n        if (retries == 0) NPT_CHECK_SEVERE(NPT_FAILURE);\n    }\n\n    // keep track of port server has successfully bound\n    m_Port = m_BoundPort;\n\n    // Tell server to try to listen to more incoming sockets\n    // (this could fail silently)\n    if (m_TaskManager->GetMaxTasks() > 20) {\n        m_Socket.Listen(m_TaskManager->GetMaxTasks());\n    }\n    \n    // start a task to listen for incoming connections\n    PLT_HttpListenTask *task = new PLT_HttpListenTask(this, &m_Socket, false);\n    NPT_CHECK_SEVERE(m_TaskManager->StartTask(task));\n\n    NPT_SocketInfo info;\n    m_Socket.GetInfo(info);\n    NPT_LOG_INFO_2(\"HttpServer listening on %s:%d\", \n        (const char*)info.local_address.GetIpAddress().ToString(), \n        m_Port);\n    \n    m_Running = true;\n    return NPT_SUCCESS;\n}\n\n/*----------------------------------------------------------------------\n|   PLT_HttpServer::Stop\n+---------------------------------------------------------------------*/\nNPT_Result\nPLT_HttpServer::Stop()\n{\n    // we can't restart an aborted server\n    if (m_Aborted || !m_Running) NPT_CHECK_WARNING(NPT_ERROR_INVALID_STATE);\n    \n    // stop all other pending tasks \n    m_TaskManager->Abort();\n    \n    m_Running = false;\n    m_Aborted = true;\n    \n    return NPT_SUCCESS;\n}\n\n/*----------------------------------------------------------------------\n|   PLT_HttpServer::SetupResponse\n+---------------------------------------------------------------------*/\nNPT_Result \nPLT_HttpServer::SetupResponse(NPT_HttpRequest&              request, \n                              const NPT_HttpRequestContext& context,\n                              NPT_HttpResponse&             response) \n{\n    NPT_String prefix = NPT_String::Format(\"PLT_HttpServer::SetupResponse %s request from %s for \\\"%s\\\"\", \n        (const char*) request.GetMethod(),\n        (const char*) context.GetRemoteAddress().ToString(),\n        (const char*) request.GetUrl().ToString());\n    PLT_LOG_HTTP_REQUEST(NPT_LOG_LEVEL_FINE, prefix, &request);\n\n    NPT_List<NPT_HttpRequestHandler*> handlers = FindRequestHandlers(request);\n    if (handlers.GetItemCount() == 0) return NPT_ERROR_NO_SUCH_ITEM;\n\n    // ask the handler to setup the response\n    NPT_Result result = (*handlers.GetFirstItem())->SetupResponse(request, context, response);\n    \n    // DLNA compliance\n    PLT_UPnPMessageHelper::SetDate(response);\n    if (request.GetHeaders().GetHeader(\"Accept-Language\")) {\n        response.GetHeaders().SetHeader(\"Content-Language\", \"en\");\n    }\n    return result;\n}\n\n/*----------------------------------------------------------------------\n|   PLT_HttpServer::ServeFile\n+---------------------------------------------------------------------*/\nNPT_Result \nPLT_HttpServer::ServeFile(const NPT_HttpRequest&        request, \n                          const NPT_HttpRequestContext& context,\n                          NPT_HttpResponse&             response,\n                          NPT_String                    file_path) \n{\n    NPT_InputStreamReference stream;\n    NPT_File                 file(file_path);\n    NPT_FileInfo             file_info;\n    \n    // prevent hackers from accessing files outside of our root\n    if ((file_path.Find(\"../\") >= 0) || (file_path.Find(\"..\\\\\") >= 0) ||\n        NPT_FAILED(NPT_File::GetInfo(file_path, &file_info))) {\n        return NPT_ERROR_NO_SUCH_ITEM;\n    }\n    \n    // check for range requests\n    const NPT_String* range_spec = request.GetHeaders().GetHeaderValue(NPT_HTTP_HEADER_RANGE);\n    \n    // handle potential 304 only if range header not set\n    NPT_DateTime  date;\n    NPT_TimeStamp timestamp;\n    if (NPT_SUCCEEDED(PLT_UPnPMessageHelper::GetIfModifiedSince((NPT_HttpMessage&)request, date)) &&\n        !range_spec) {\n        date.ToTimeStamp(timestamp);\n        \n        NPT_LOG_INFO_5(\"File %s timestamps: request=%d (%s) vs file=%d (%s)\", \n                       (const char*)request.GetUrl().GetPath(),\n                       (NPT_UInt32)timestamp.ToSeconds(),\n                       (const char*)date.ToString(),\n                       (NPT_UInt32)file_info.m_ModificationTime,\n                       (const char*)NPT_DateTime(file_info.m_ModificationTime).ToString());\n        \n        if (timestamp >= file_info.m_ModificationTime) {\n            // it's a match\n            NPT_LOG_FINE_1(\"Returning 304 for %s\", request.GetUrl().GetPath().GetChars());\n            response.SetStatus(304, \"Not Modified\", NPT_HTTP_PROTOCOL_1_1);\n            return NPT_SUCCESS;\n        }\n    }\n    \n    // open file\n    if (NPT_FAILED(file.Open(NPT_FILE_OPEN_MODE_READ)) || \n        NPT_FAILED(file.GetInputStream(stream))        ||\n        stream.IsNull()) {\n        return NPT_ERROR_NO_SUCH_ITEM;\n    }\n    \n    // set Last-Modified and Cache-Control headers\n    if (file_info.m_ModificationTime) {\n        NPT_DateTime last_modified = NPT_DateTime(file_info.m_ModificationTime);\n        response.GetHeaders().SetHeader(\"Last-Modified\", last_modified.ToString(NPT_DateTime::FORMAT_RFC_1123), true);\n        response.GetHeaders().SetHeader(\"Cache-Control\", \"max-age=0,must-revalidate\", true);\n        //response.GetHeaders().SetHeader(\"Cache-Control\", \"max-age=1800\", true);\n    }\n    \n    PLT_HttpRequestContext tmp_context(request, context);\n    return ServeStream(request, context, response, stream, PLT_MimeType::GetMimeType(file_path, &tmp_context));\n}\n\n/*----------------------------------------------------------------------\n|   PLT_HttpServer::ServeStream\n+---------------------------------------------------------------------*/\nNPT_Result \nPLT_HttpServer::ServeStream(const NPT_HttpRequest&        request, \n                            const NPT_HttpRequestContext& context,\n                            NPT_HttpResponse&             response,\n                            NPT_InputStreamReference&     body, \n                            const char*                   content_type) \n{    \n    if (body.IsNull()) return NPT_FAILURE;\n    \n    // set date\n    NPT_TimeStamp now;\n    NPT_System::GetCurrentTimeStamp(now);\n    response.GetHeaders().SetHeader(\"Date\", NPT_DateTime(now).ToString(NPT_DateTime::FORMAT_RFC_1123), true);\n    \n    // get entity\n    NPT_HttpEntity* entity = response.GetEntity();\n    NPT_CHECK_POINTER_FATAL(entity);\n    \n    // set the content type\n    entity->SetContentType(content_type);\n    \n    // check for range requests\n    const NPT_String* range_spec = request.GetHeaders().GetHeaderValue(NPT_HTTP_HEADER_RANGE);\n    \n    // setup entity body\n    NPT_CHECK(NPT_HttpFileRequestHandler::SetupResponseBody(response, body, range_spec));\n              \n    // set some default headers\n    if (response.GetEntity()->GetTransferEncoding() != NPT_HTTP_TRANSFER_ENCODING_CHUNKED) {\n        // set but don't replace Accept-Range header only if body is seekable\n        NPT_Position offset;\n        if (NPT_SUCCEEDED(body->Tell(offset)) && NPT_SUCCEEDED(body->Seek(offset))) {\n            response.GetHeaders().SetHeader(NPT_HTTP_HEADER_ACCEPT_RANGES, \"bytes\", false); \n        }\n    }\n    \n    // set getcontentFeatures.dlna.org\n    const NPT_String* value = request.GetHeaders().GetHeaderValue(\"getcontentFeatures.dlna.org\");\n    if (value) {\n        PLT_HttpRequestContext tmp_context(request, context);\n        const char* dlna = PLT_ProtocolInfo::GetDlnaExtension(entity->GetContentType(),\n                                                              &tmp_context);\n        if (dlna) response.GetHeaders().SetHeader(\"ContentFeatures.DLNA.ORG\", dlna, false);\n    }\n    \n    // transferMode.dlna.org\n    value = request.GetHeaders().GetHeaderValue(\"transferMode.dlna.org\");\n    if (value) {\n        // Interactive mode not supported?\n        /*if (value->Compare(\"Interactive\", true) == 0) {\n            response.SetStatus(406, \"Not Acceptable\");\n            return NPT_SUCCESS;\n        }*/\n        \n        response.GetHeaders().SetHeader(\"TransferMode.DLNA.ORG\", value->GetChars(), false);\n    } else {\n        response.GetHeaders().SetHeader(\"TransferMode.DLNA.ORG\", \"Streaming\", false);\n    }\n    \n    if (request.GetHeaders().GetHeaderValue(\"TimeSeekRange.dlna.org\")) {\n        response.SetStatus(406, \"Not Acceptable\");\n        return NPT_SUCCESS;\n    }\n    \n    return NPT_SUCCESS;\n}\n"], "filenames": ["Source/Core/PltHttpServer.cpp"], "buggy_code_start_loc": [193], "buggy_code_end_loc": [194], "fixing_code_start_loc": [193], "fixing_code_end_loc": [194], "type": "CWE-22", "message": "Platinum Upnp SDK through 1.2.0 has a directory traversal vulnerability. The attack could remote attack victim by sending http://ip:port/../privacy.avi URL to compromise a victim's privacy.", "other": {"cve": {"id": "CVE-2020-19858", "sourceIdentifier": "cve@mitre.org", "published": "2022-01-21T13:15:08.197", "lastModified": "2022-01-27T14:37:54.867", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Platinum Upnp SDK through 1.2.0 has a directory traversal vulnerability. The attack could remote attack victim by sending http://ip:port/../privacy.avi URL to compromise a victim's privacy."}, {"lang": "es", "value": "Platinum Upnp SDK versiones hasta 1.2.0, presenta una vulnerabilidad de salto de directorios. Un atacante podr\u00eda atacar remotamente a la v\u00edctima mediante el env\u00edo de la URL http://ip:port/../privacy.avi para comprometer la privacidad de la v\u00edctima"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:plutinosoft:platinum:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.2.0", "matchCriteriaId": "80A5082C-C846-446C-B25A-4BF74F5C4706"}]}]}], "references": [{"url": "https://github.com/plutinosoft/Platinum/commit/9a4ceaccb1585ec35c45fd8e2585538fff6a865e", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/plutinosoft/Platinum/issues/22", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/plutinosoft/Platinum/commit/9a4ceaccb1585ec35c45fd8e2585538fff6a865e"}}