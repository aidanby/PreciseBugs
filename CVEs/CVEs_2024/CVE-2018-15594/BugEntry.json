{"buggy_code": ["/*  Paravirtualization interfaces\n    Copyright (C) 2006 Rusty Russell IBM Corporation\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program; if not, write to the Free Software\n    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n\n    2007 - x86_64 support added by Glauber de Oliveira Costa, Red Hat Inc\n*/\n\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/efi.h>\n#include <linux/bcd.h>\n#include <linux/highmem.h>\n#include <linux/kprobes.h>\n\n#include <asm/bug.h>\n#include <asm/paravirt.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/setup.h>\n#include <asm/pgtable.h>\n#include <asm/time.h>\n#include <asm/pgalloc.h>\n#include <asm/irq.h>\n#include <asm/delay.h>\n#include <asm/fixmap.h>\n#include <asm/apic.h>\n#include <asm/tlbflush.h>\n#include <asm/timer.h>\n#include <asm/special_insns.h>\n\n/*\n * nop stub, which must not clobber anything *including the stack* to\n * avoid confusing the entry prologues.\n */\nextern void _paravirt_nop(void);\nasm (\".pushsection .entry.text, \\\"ax\\\"\\n\"\n     \".global _paravirt_nop\\n\"\n     \"_paravirt_nop:\\n\\t\"\n     \"ret\\n\\t\"\n     \".size _paravirt_nop, . - _paravirt_nop\\n\\t\"\n     \".type _paravirt_nop, @function\\n\\t\"\n     \".popsection\");\n\n/* identity function, which can be inlined */\nu32 notrace _paravirt_ident_32(u32 x)\n{\n\treturn x;\n}\n\nu64 notrace _paravirt_ident_64(u64 x)\n{\n\treturn x;\n}\n\nvoid __init default_banner(void)\n{\n\tprintk(KERN_INFO \"Booting paravirtualized kernel on %s\\n\",\n\t       pv_info.name);\n}\n\n/* Undefined instruction for dealing with missing ops pointers. */\nstatic const unsigned char ud2a[] = { 0x0f, 0x0b };\n\nstruct branch {\n\tunsigned char opcode;\n\tu32 delta;\n} __attribute__((packed));\n\nunsigned paravirt_patch_call(void *insnbuf,\n\t\t\t     const void *target, u16 tgt_clobbers,\n\t\t\t     unsigned long addr, u16 site_clobbers,\n\t\t\t     unsigned len)\n{\n\tstruct branch *b = insnbuf;\n\tunsigned long delta = (unsigned long)target - (addr+5);\n\n\tif (tgt_clobbers & ~site_clobbers)\n\t\treturn len;\t/* target would clobber too much for this site */\n\tif (len < 5)\n\t\treturn len;\t/* call too long for patch site */\n\n\tb->opcode = 0xe8; /* call */\n\tb->delta = delta;\n\tBUILD_BUG_ON(sizeof(*b) != 5);\n\n\treturn 5;\n}\n\nunsigned paravirt_patch_jmp(void *insnbuf, const void *target,\n\t\t\t    unsigned long addr, unsigned len)\n{\n\tstruct branch *b = insnbuf;\n\tunsigned long delta = (unsigned long)target - (addr+5);\n\n\tif (len < 5)\n\t\treturn len;\t/* call too long for patch site */\n\n\tb->opcode = 0xe9;\t/* jmp */\n\tb->delta = delta;\n\n\treturn 5;\n}\n\nDEFINE_STATIC_KEY_TRUE(virt_spin_lock_key);\n\nvoid __init native_pv_lock_init(void)\n{\n\tif (!static_cpu_has(X86_FEATURE_HYPERVISOR))\n\t\tstatic_branch_disable(&virt_spin_lock_key);\n}\n\n/*\n * Neat trick to map patch type back to the call within the\n * corresponding structure.\n */\nstatic void *get_call_destination(u8 type)\n{\n\tstruct paravirt_patch_template tmpl = {\n\t\t.pv_init_ops = pv_init_ops,\n\t\t.pv_time_ops = pv_time_ops,\n\t\t.pv_cpu_ops = pv_cpu_ops,\n\t\t.pv_irq_ops = pv_irq_ops,\n\t\t.pv_mmu_ops = pv_mmu_ops,\n#ifdef CONFIG_PARAVIRT_SPINLOCKS\n\t\t.pv_lock_ops = pv_lock_ops,\n#endif\n\t};\n\treturn *((void **)&tmpl + type);\n}\n\nunsigned paravirt_patch_default(u8 type, u16 clobbers, void *insnbuf,\n\t\t\t\tunsigned long addr, unsigned len)\n{\n\tvoid *opfunc = get_call_destination(type);\n\tunsigned ret;\n\n\tif (opfunc == NULL)\n\t\t/* If there's no function, patch it with a ud2a (BUG) */\n\t\tret = paravirt_patch_insns(insnbuf, len, ud2a, ud2a+sizeof(ud2a));\n\telse if (opfunc == _paravirt_nop)\n\t\tret = 0;\n\n\t/* identity functions just return their single argument */\n\telse if (opfunc == _paravirt_ident_32)\n\t\tret = paravirt_patch_ident_32(insnbuf, len);\n\telse if (opfunc == _paravirt_ident_64)\n\t\tret = paravirt_patch_ident_64(insnbuf, len);\n\n\telse if (type == PARAVIRT_PATCH(pv_cpu_ops.iret) ||\n\t\t type == PARAVIRT_PATCH(pv_cpu_ops.usergs_sysret64))\n\t\t/* If operation requires a jmp, then jmp */\n\t\tret = paravirt_patch_jmp(insnbuf, opfunc, addr, len);\n\telse\n\t\t/* Otherwise call the function; assume target could\n\t\t   clobber any caller-save reg */\n\t\tret = paravirt_patch_call(insnbuf, opfunc, CLBR_ANY,\n\t\t\t\t\t  addr, clobbers, len);\n\n\treturn ret;\n}\n\nunsigned paravirt_patch_insns(void *insnbuf, unsigned len,\n\t\t\t      const char *start, const char *end)\n{\n\tunsigned insn_len = end - start;\n\n\tif (insn_len > len || start == NULL)\n\t\tinsn_len = len;\n\telse\n\t\tmemcpy(insnbuf, start, insn_len);\n\n\treturn insn_len;\n}\n\nstatic void native_flush_tlb(void)\n{\n\t__native_flush_tlb();\n}\n\n/*\n * Global pages have to be flushed a bit differently. Not a real\n * performance problem because this does not happen often.\n */\nstatic void native_flush_tlb_global(void)\n{\n\t__native_flush_tlb_global();\n}\n\nstatic void native_flush_tlb_one_user(unsigned long addr)\n{\n\t__native_flush_tlb_one_user(addr);\n}\n\nstruct static_key paravirt_steal_enabled;\nstruct static_key paravirt_steal_rq_enabled;\n\nstatic u64 native_steal_clock(int cpu)\n{\n\treturn 0;\n}\n\n/* These are in entry.S */\nextern void native_iret(void);\nextern void native_usergs_sysret64(void);\n\nstatic struct resource reserve_ioports = {\n\t.start = 0,\n\t.end = IO_SPACE_LIMIT,\n\t.name = \"paravirt-ioport\",\n\t.flags = IORESOURCE_IO | IORESOURCE_BUSY,\n};\n\n/*\n * Reserve the whole legacy IO space to prevent any legacy drivers\n * from wasting time probing for their hardware.  This is a fairly\n * brute-force approach to disabling all non-virtual drivers.\n *\n * Note that this must be called very early to have any effect.\n */\nint paravirt_disable_iospace(void)\n{\n\treturn request_resource(&ioport_resource, &reserve_ioports);\n}\n\nstatic DEFINE_PER_CPU(enum paravirt_lazy_mode, paravirt_lazy_mode) = PARAVIRT_LAZY_NONE;\n\nstatic inline void enter_lazy(enum paravirt_lazy_mode mode)\n{\n\tBUG_ON(this_cpu_read(paravirt_lazy_mode) != PARAVIRT_LAZY_NONE);\n\n\tthis_cpu_write(paravirt_lazy_mode, mode);\n}\n\nstatic void leave_lazy(enum paravirt_lazy_mode mode)\n{\n\tBUG_ON(this_cpu_read(paravirt_lazy_mode) != mode);\n\n\tthis_cpu_write(paravirt_lazy_mode, PARAVIRT_LAZY_NONE);\n}\n\nvoid paravirt_enter_lazy_mmu(void)\n{\n\tenter_lazy(PARAVIRT_LAZY_MMU);\n}\n\nvoid paravirt_leave_lazy_mmu(void)\n{\n\tleave_lazy(PARAVIRT_LAZY_MMU);\n}\n\nvoid paravirt_flush_lazy_mmu(void)\n{\n\tpreempt_disable();\n\n\tif (paravirt_get_lazy_mode() == PARAVIRT_LAZY_MMU) {\n\t\tarch_leave_lazy_mmu_mode();\n\t\tarch_enter_lazy_mmu_mode();\n\t}\n\n\tpreempt_enable();\n}\n\nvoid paravirt_start_context_switch(struct task_struct *prev)\n{\n\tBUG_ON(preemptible());\n\n\tif (this_cpu_read(paravirt_lazy_mode) == PARAVIRT_LAZY_MMU) {\n\t\tarch_leave_lazy_mmu_mode();\n\t\tset_ti_thread_flag(task_thread_info(prev), TIF_LAZY_MMU_UPDATES);\n\t}\n\tenter_lazy(PARAVIRT_LAZY_CPU);\n}\n\nvoid paravirt_end_context_switch(struct task_struct *next)\n{\n\tBUG_ON(preemptible());\n\n\tleave_lazy(PARAVIRT_LAZY_CPU);\n\n\tif (test_and_clear_ti_thread_flag(task_thread_info(next), TIF_LAZY_MMU_UPDATES))\n\t\tarch_enter_lazy_mmu_mode();\n}\n\nenum paravirt_lazy_mode paravirt_get_lazy_mode(void)\n{\n\tif (in_interrupt())\n\t\treturn PARAVIRT_LAZY_NONE;\n\n\treturn this_cpu_read(paravirt_lazy_mode);\n}\n\nstruct pv_info pv_info = {\n\t.name = \"bare hardware\",\n\t.kernel_rpl = 0,\n\t.shared_kernel_pmd = 1,\t/* Only used when CONFIG_X86_PAE is set */\n\n#ifdef CONFIG_X86_64\n\t.extra_user_64bit_cs = __USER_CS,\n#endif\n};\n\nstruct pv_init_ops pv_init_ops = {\n\t.patch = native_patch,\n};\n\nstruct pv_time_ops pv_time_ops = {\n\t.sched_clock = native_sched_clock,\n\t.steal_clock = native_steal_clock,\n};\n\n__visible struct pv_irq_ops pv_irq_ops = {\n\t.save_fl = __PV_IS_CALLEE_SAVE(native_save_fl),\n\t.restore_fl = __PV_IS_CALLEE_SAVE(native_restore_fl),\n\t.irq_disable = __PV_IS_CALLEE_SAVE(native_irq_disable),\n\t.irq_enable = __PV_IS_CALLEE_SAVE(native_irq_enable),\n\t.safe_halt = native_safe_halt,\n\t.halt = native_halt,\n};\n\n__visible struct pv_cpu_ops pv_cpu_ops = {\n\t.cpuid = native_cpuid,\n\t.get_debugreg = native_get_debugreg,\n\t.set_debugreg = native_set_debugreg,\n\t.read_cr0 = native_read_cr0,\n\t.write_cr0 = native_write_cr0,\n\t.write_cr4 = native_write_cr4,\n#ifdef CONFIG_X86_64\n\t.read_cr8 = native_read_cr8,\n\t.write_cr8 = native_write_cr8,\n#endif\n\t.wbinvd = native_wbinvd,\n\t.read_msr = native_read_msr,\n\t.write_msr = native_write_msr,\n\t.read_msr_safe = native_read_msr_safe,\n\t.write_msr_safe = native_write_msr_safe,\n\t.read_pmc = native_read_pmc,\n\t.load_tr_desc = native_load_tr_desc,\n\t.set_ldt = native_set_ldt,\n\t.load_gdt = native_load_gdt,\n\t.load_idt = native_load_idt,\n\t.store_tr = native_store_tr,\n\t.load_tls = native_load_tls,\n#ifdef CONFIG_X86_64\n\t.load_gs_index = native_load_gs_index,\n#endif\n\t.write_ldt_entry = native_write_ldt_entry,\n\t.write_gdt_entry = native_write_gdt_entry,\n\t.write_idt_entry = native_write_idt_entry,\n\n\t.alloc_ldt = paravirt_nop,\n\t.free_ldt = paravirt_nop,\n\n\t.load_sp0 = native_load_sp0,\n\n#ifdef CONFIG_X86_64\n\t.usergs_sysret64 = native_usergs_sysret64,\n#endif\n\t.iret = native_iret,\n\t.swapgs = native_swapgs,\n\n\t.set_iopl_mask = native_set_iopl_mask,\n\t.io_delay = native_io_delay,\n\n\t.start_context_switch = paravirt_nop,\n\t.end_context_switch = paravirt_nop,\n};\n\n/* At this point, native_get/set_debugreg has real function entries */\nNOKPROBE_SYMBOL(native_get_debugreg);\nNOKPROBE_SYMBOL(native_set_debugreg);\nNOKPROBE_SYMBOL(native_load_idt);\n\n#if defined(CONFIG_X86_32) && !defined(CONFIG_X86_PAE)\n/* 32-bit pagetable entries */\n#define PTE_IDENT\t__PV_IS_CALLEE_SAVE(_paravirt_ident_32)\n#else\n/* 64-bit pagetable entries */\n#define PTE_IDENT\t__PV_IS_CALLEE_SAVE(_paravirt_ident_64)\n#endif\n\nstruct pv_mmu_ops pv_mmu_ops __ro_after_init = {\n\n\t.read_cr2 = native_read_cr2,\n\t.write_cr2 = native_write_cr2,\n\t.read_cr3 = __native_read_cr3,\n\t.write_cr3 = native_write_cr3,\n\n\t.flush_tlb_user = native_flush_tlb,\n\t.flush_tlb_kernel = native_flush_tlb_global,\n\t.flush_tlb_one_user = native_flush_tlb_one_user,\n\t.flush_tlb_others = native_flush_tlb_others,\n\n\t.pgd_alloc = __paravirt_pgd_alloc,\n\t.pgd_free = paravirt_nop,\n\n\t.alloc_pte = paravirt_nop,\n\t.alloc_pmd = paravirt_nop,\n\t.alloc_pud = paravirt_nop,\n\t.alloc_p4d = paravirt_nop,\n\t.release_pte = paravirt_nop,\n\t.release_pmd = paravirt_nop,\n\t.release_pud = paravirt_nop,\n\t.release_p4d = paravirt_nop,\n\n\t.set_pte = native_set_pte,\n\t.set_pte_at = native_set_pte_at,\n\t.set_pmd = native_set_pmd,\n\n\t.ptep_modify_prot_start = __ptep_modify_prot_start,\n\t.ptep_modify_prot_commit = __ptep_modify_prot_commit,\n\n#if CONFIG_PGTABLE_LEVELS >= 3\n#ifdef CONFIG_X86_PAE\n\t.set_pte_atomic = native_set_pte_atomic,\n\t.pte_clear = native_pte_clear,\n\t.pmd_clear = native_pmd_clear,\n#endif\n\t.set_pud = native_set_pud,\n\n\t.pmd_val = PTE_IDENT,\n\t.make_pmd = PTE_IDENT,\n\n#if CONFIG_PGTABLE_LEVELS >= 4\n\t.pud_val = PTE_IDENT,\n\t.make_pud = PTE_IDENT,\n\n\t.set_p4d = native_set_p4d,\n\n#if CONFIG_PGTABLE_LEVELS >= 5\n\t.p4d_val = PTE_IDENT,\n\t.make_p4d = PTE_IDENT,\n\n\t.set_pgd = native_set_pgd,\n#endif /* CONFIG_PGTABLE_LEVELS >= 5 */\n#endif /* CONFIG_PGTABLE_LEVELS >= 4 */\n#endif /* CONFIG_PGTABLE_LEVELS >= 3 */\n\n\t.pte_val = PTE_IDENT,\n\t.pgd_val = PTE_IDENT,\n\n\t.make_pte = PTE_IDENT,\n\t.make_pgd = PTE_IDENT,\n\n\t.dup_mmap = paravirt_nop,\n\t.exit_mmap = paravirt_nop,\n\t.activate_mm = paravirt_nop,\n\n\t.lazy_mode = {\n\t\t.enter = paravirt_nop,\n\t\t.leave = paravirt_nop,\n\t\t.flush = paravirt_nop,\n\t},\n\n\t.set_fixmap = native_set_fixmap,\n};\n\nEXPORT_SYMBOL_GPL(pv_time_ops);\nEXPORT_SYMBOL    (pv_cpu_ops);\nEXPORT_SYMBOL    (pv_mmu_ops);\nEXPORT_SYMBOL_GPL(pv_info);\nEXPORT_SYMBOL    (pv_irq_ops);\n"], "fixing_code": ["/*  Paravirtualization interfaces\n    Copyright (C) 2006 Rusty Russell IBM Corporation\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program; if not, write to the Free Software\n    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n\n    2007 - x86_64 support added by Glauber de Oliveira Costa, Red Hat Inc\n*/\n\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/efi.h>\n#include <linux/bcd.h>\n#include <linux/highmem.h>\n#include <linux/kprobes.h>\n\n#include <asm/bug.h>\n#include <asm/paravirt.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/setup.h>\n#include <asm/pgtable.h>\n#include <asm/time.h>\n#include <asm/pgalloc.h>\n#include <asm/irq.h>\n#include <asm/delay.h>\n#include <asm/fixmap.h>\n#include <asm/apic.h>\n#include <asm/tlbflush.h>\n#include <asm/timer.h>\n#include <asm/special_insns.h>\n\n/*\n * nop stub, which must not clobber anything *including the stack* to\n * avoid confusing the entry prologues.\n */\nextern void _paravirt_nop(void);\nasm (\".pushsection .entry.text, \\\"ax\\\"\\n\"\n     \".global _paravirt_nop\\n\"\n     \"_paravirt_nop:\\n\\t\"\n     \"ret\\n\\t\"\n     \".size _paravirt_nop, . - _paravirt_nop\\n\\t\"\n     \".type _paravirt_nop, @function\\n\\t\"\n     \".popsection\");\n\n/* identity function, which can be inlined */\nu32 notrace _paravirt_ident_32(u32 x)\n{\n\treturn x;\n}\n\nu64 notrace _paravirt_ident_64(u64 x)\n{\n\treturn x;\n}\n\nvoid __init default_banner(void)\n{\n\tprintk(KERN_INFO \"Booting paravirtualized kernel on %s\\n\",\n\t       pv_info.name);\n}\n\n/* Undefined instruction for dealing with missing ops pointers. */\nstatic const unsigned char ud2a[] = { 0x0f, 0x0b };\n\nstruct branch {\n\tunsigned char opcode;\n\tu32 delta;\n} __attribute__((packed));\n\nunsigned paravirt_patch_call(void *insnbuf,\n\t\t\t     const void *target, u16 tgt_clobbers,\n\t\t\t     unsigned long addr, u16 site_clobbers,\n\t\t\t     unsigned len)\n{\n\tstruct branch *b = insnbuf;\n\tunsigned long delta = (unsigned long)target - (addr+5);\n\n\tif (len < 5) {\n#ifdef CONFIG_RETPOLINE\n\t\tWARN_ONCE(\"Failing to patch indirect CALL in %ps\\n\", (void *)addr);\n#endif\n\t\treturn len;\t/* call too long for patch site */\n\t}\n\n\tb->opcode = 0xe8; /* call */\n\tb->delta = delta;\n\tBUILD_BUG_ON(sizeof(*b) != 5);\n\n\treturn 5;\n}\n\nunsigned paravirt_patch_jmp(void *insnbuf, const void *target,\n\t\t\t    unsigned long addr, unsigned len)\n{\n\tstruct branch *b = insnbuf;\n\tunsigned long delta = (unsigned long)target - (addr+5);\n\n\tif (len < 5) {\n#ifdef CONFIG_RETPOLINE\n\t\tWARN_ONCE(\"Failing to patch indirect JMP in %ps\\n\", (void *)addr);\n#endif\n\t\treturn len;\t/* call too long for patch site */\n\t}\n\n\tb->opcode = 0xe9;\t/* jmp */\n\tb->delta = delta;\n\n\treturn 5;\n}\n\nDEFINE_STATIC_KEY_TRUE(virt_spin_lock_key);\n\nvoid __init native_pv_lock_init(void)\n{\n\tif (!static_cpu_has(X86_FEATURE_HYPERVISOR))\n\t\tstatic_branch_disable(&virt_spin_lock_key);\n}\n\n/*\n * Neat trick to map patch type back to the call within the\n * corresponding structure.\n */\nstatic void *get_call_destination(u8 type)\n{\n\tstruct paravirt_patch_template tmpl = {\n\t\t.pv_init_ops = pv_init_ops,\n\t\t.pv_time_ops = pv_time_ops,\n\t\t.pv_cpu_ops = pv_cpu_ops,\n\t\t.pv_irq_ops = pv_irq_ops,\n\t\t.pv_mmu_ops = pv_mmu_ops,\n#ifdef CONFIG_PARAVIRT_SPINLOCKS\n\t\t.pv_lock_ops = pv_lock_ops,\n#endif\n\t};\n\treturn *((void **)&tmpl + type);\n}\n\nunsigned paravirt_patch_default(u8 type, u16 clobbers, void *insnbuf,\n\t\t\t\tunsigned long addr, unsigned len)\n{\n\tvoid *opfunc = get_call_destination(type);\n\tunsigned ret;\n\n\tif (opfunc == NULL)\n\t\t/* If there's no function, patch it with a ud2a (BUG) */\n\t\tret = paravirt_patch_insns(insnbuf, len, ud2a, ud2a+sizeof(ud2a));\n\telse if (opfunc == _paravirt_nop)\n\t\tret = 0;\n\n\t/* identity functions just return their single argument */\n\telse if (opfunc == _paravirt_ident_32)\n\t\tret = paravirt_patch_ident_32(insnbuf, len);\n\telse if (opfunc == _paravirt_ident_64)\n\t\tret = paravirt_patch_ident_64(insnbuf, len);\n\n\telse if (type == PARAVIRT_PATCH(pv_cpu_ops.iret) ||\n\t\t type == PARAVIRT_PATCH(pv_cpu_ops.usergs_sysret64))\n\t\t/* If operation requires a jmp, then jmp */\n\t\tret = paravirt_patch_jmp(insnbuf, opfunc, addr, len);\n\telse\n\t\t/* Otherwise call the function; assume target could\n\t\t   clobber any caller-save reg */\n\t\tret = paravirt_patch_call(insnbuf, opfunc, CLBR_ANY,\n\t\t\t\t\t  addr, clobbers, len);\n\n\treturn ret;\n}\n\nunsigned paravirt_patch_insns(void *insnbuf, unsigned len,\n\t\t\t      const char *start, const char *end)\n{\n\tunsigned insn_len = end - start;\n\n\tif (insn_len > len || start == NULL)\n\t\tinsn_len = len;\n\telse\n\t\tmemcpy(insnbuf, start, insn_len);\n\n\treturn insn_len;\n}\n\nstatic void native_flush_tlb(void)\n{\n\t__native_flush_tlb();\n}\n\n/*\n * Global pages have to be flushed a bit differently. Not a real\n * performance problem because this does not happen often.\n */\nstatic void native_flush_tlb_global(void)\n{\n\t__native_flush_tlb_global();\n}\n\nstatic void native_flush_tlb_one_user(unsigned long addr)\n{\n\t__native_flush_tlb_one_user(addr);\n}\n\nstruct static_key paravirt_steal_enabled;\nstruct static_key paravirt_steal_rq_enabled;\n\nstatic u64 native_steal_clock(int cpu)\n{\n\treturn 0;\n}\n\n/* These are in entry.S */\nextern void native_iret(void);\nextern void native_usergs_sysret64(void);\n\nstatic struct resource reserve_ioports = {\n\t.start = 0,\n\t.end = IO_SPACE_LIMIT,\n\t.name = \"paravirt-ioport\",\n\t.flags = IORESOURCE_IO | IORESOURCE_BUSY,\n};\n\n/*\n * Reserve the whole legacy IO space to prevent any legacy drivers\n * from wasting time probing for their hardware.  This is a fairly\n * brute-force approach to disabling all non-virtual drivers.\n *\n * Note that this must be called very early to have any effect.\n */\nint paravirt_disable_iospace(void)\n{\n\treturn request_resource(&ioport_resource, &reserve_ioports);\n}\n\nstatic DEFINE_PER_CPU(enum paravirt_lazy_mode, paravirt_lazy_mode) = PARAVIRT_LAZY_NONE;\n\nstatic inline void enter_lazy(enum paravirt_lazy_mode mode)\n{\n\tBUG_ON(this_cpu_read(paravirt_lazy_mode) != PARAVIRT_LAZY_NONE);\n\n\tthis_cpu_write(paravirt_lazy_mode, mode);\n}\n\nstatic void leave_lazy(enum paravirt_lazy_mode mode)\n{\n\tBUG_ON(this_cpu_read(paravirt_lazy_mode) != mode);\n\n\tthis_cpu_write(paravirt_lazy_mode, PARAVIRT_LAZY_NONE);\n}\n\nvoid paravirt_enter_lazy_mmu(void)\n{\n\tenter_lazy(PARAVIRT_LAZY_MMU);\n}\n\nvoid paravirt_leave_lazy_mmu(void)\n{\n\tleave_lazy(PARAVIRT_LAZY_MMU);\n}\n\nvoid paravirt_flush_lazy_mmu(void)\n{\n\tpreempt_disable();\n\n\tif (paravirt_get_lazy_mode() == PARAVIRT_LAZY_MMU) {\n\t\tarch_leave_lazy_mmu_mode();\n\t\tarch_enter_lazy_mmu_mode();\n\t}\n\n\tpreempt_enable();\n}\n\nvoid paravirt_start_context_switch(struct task_struct *prev)\n{\n\tBUG_ON(preemptible());\n\n\tif (this_cpu_read(paravirt_lazy_mode) == PARAVIRT_LAZY_MMU) {\n\t\tarch_leave_lazy_mmu_mode();\n\t\tset_ti_thread_flag(task_thread_info(prev), TIF_LAZY_MMU_UPDATES);\n\t}\n\tenter_lazy(PARAVIRT_LAZY_CPU);\n}\n\nvoid paravirt_end_context_switch(struct task_struct *next)\n{\n\tBUG_ON(preemptible());\n\n\tleave_lazy(PARAVIRT_LAZY_CPU);\n\n\tif (test_and_clear_ti_thread_flag(task_thread_info(next), TIF_LAZY_MMU_UPDATES))\n\t\tarch_enter_lazy_mmu_mode();\n}\n\nenum paravirt_lazy_mode paravirt_get_lazy_mode(void)\n{\n\tif (in_interrupt())\n\t\treturn PARAVIRT_LAZY_NONE;\n\n\treturn this_cpu_read(paravirt_lazy_mode);\n}\n\nstruct pv_info pv_info = {\n\t.name = \"bare hardware\",\n\t.kernel_rpl = 0,\n\t.shared_kernel_pmd = 1,\t/* Only used when CONFIG_X86_PAE is set */\n\n#ifdef CONFIG_X86_64\n\t.extra_user_64bit_cs = __USER_CS,\n#endif\n};\n\nstruct pv_init_ops pv_init_ops = {\n\t.patch = native_patch,\n};\n\nstruct pv_time_ops pv_time_ops = {\n\t.sched_clock = native_sched_clock,\n\t.steal_clock = native_steal_clock,\n};\n\n__visible struct pv_irq_ops pv_irq_ops = {\n\t.save_fl = __PV_IS_CALLEE_SAVE(native_save_fl),\n\t.restore_fl = __PV_IS_CALLEE_SAVE(native_restore_fl),\n\t.irq_disable = __PV_IS_CALLEE_SAVE(native_irq_disable),\n\t.irq_enable = __PV_IS_CALLEE_SAVE(native_irq_enable),\n\t.safe_halt = native_safe_halt,\n\t.halt = native_halt,\n};\n\n__visible struct pv_cpu_ops pv_cpu_ops = {\n\t.cpuid = native_cpuid,\n\t.get_debugreg = native_get_debugreg,\n\t.set_debugreg = native_set_debugreg,\n\t.read_cr0 = native_read_cr0,\n\t.write_cr0 = native_write_cr0,\n\t.write_cr4 = native_write_cr4,\n#ifdef CONFIG_X86_64\n\t.read_cr8 = native_read_cr8,\n\t.write_cr8 = native_write_cr8,\n#endif\n\t.wbinvd = native_wbinvd,\n\t.read_msr = native_read_msr,\n\t.write_msr = native_write_msr,\n\t.read_msr_safe = native_read_msr_safe,\n\t.write_msr_safe = native_write_msr_safe,\n\t.read_pmc = native_read_pmc,\n\t.load_tr_desc = native_load_tr_desc,\n\t.set_ldt = native_set_ldt,\n\t.load_gdt = native_load_gdt,\n\t.load_idt = native_load_idt,\n\t.store_tr = native_store_tr,\n\t.load_tls = native_load_tls,\n#ifdef CONFIG_X86_64\n\t.load_gs_index = native_load_gs_index,\n#endif\n\t.write_ldt_entry = native_write_ldt_entry,\n\t.write_gdt_entry = native_write_gdt_entry,\n\t.write_idt_entry = native_write_idt_entry,\n\n\t.alloc_ldt = paravirt_nop,\n\t.free_ldt = paravirt_nop,\n\n\t.load_sp0 = native_load_sp0,\n\n#ifdef CONFIG_X86_64\n\t.usergs_sysret64 = native_usergs_sysret64,\n#endif\n\t.iret = native_iret,\n\t.swapgs = native_swapgs,\n\n\t.set_iopl_mask = native_set_iopl_mask,\n\t.io_delay = native_io_delay,\n\n\t.start_context_switch = paravirt_nop,\n\t.end_context_switch = paravirt_nop,\n};\n\n/* At this point, native_get/set_debugreg has real function entries */\nNOKPROBE_SYMBOL(native_get_debugreg);\nNOKPROBE_SYMBOL(native_set_debugreg);\nNOKPROBE_SYMBOL(native_load_idt);\n\n#if defined(CONFIG_X86_32) && !defined(CONFIG_X86_PAE)\n/* 32-bit pagetable entries */\n#define PTE_IDENT\t__PV_IS_CALLEE_SAVE(_paravirt_ident_32)\n#else\n/* 64-bit pagetable entries */\n#define PTE_IDENT\t__PV_IS_CALLEE_SAVE(_paravirt_ident_64)\n#endif\n\nstruct pv_mmu_ops pv_mmu_ops __ro_after_init = {\n\n\t.read_cr2 = native_read_cr2,\n\t.write_cr2 = native_write_cr2,\n\t.read_cr3 = __native_read_cr3,\n\t.write_cr3 = native_write_cr3,\n\n\t.flush_tlb_user = native_flush_tlb,\n\t.flush_tlb_kernel = native_flush_tlb_global,\n\t.flush_tlb_one_user = native_flush_tlb_one_user,\n\t.flush_tlb_others = native_flush_tlb_others,\n\n\t.pgd_alloc = __paravirt_pgd_alloc,\n\t.pgd_free = paravirt_nop,\n\n\t.alloc_pte = paravirt_nop,\n\t.alloc_pmd = paravirt_nop,\n\t.alloc_pud = paravirt_nop,\n\t.alloc_p4d = paravirt_nop,\n\t.release_pte = paravirt_nop,\n\t.release_pmd = paravirt_nop,\n\t.release_pud = paravirt_nop,\n\t.release_p4d = paravirt_nop,\n\n\t.set_pte = native_set_pte,\n\t.set_pte_at = native_set_pte_at,\n\t.set_pmd = native_set_pmd,\n\n\t.ptep_modify_prot_start = __ptep_modify_prot_start,\n\t.ptep_modify_prot_commit = __ptep_modify_prot_commit,\n\n#if CONFIG_PGTABLE_LEVELS >= 3\n#ifdef CONFIG_X86_PAE\n\t.set_pte_atomic = native_set_pte_atomic,\n\t.pte_clear = native_pte_clear,\n\t.pmd_clear = native_pmd_clear,\n#endif\n\t.set_pud = native_set_pud,\n\n\t.pmd_val = PTE_IDENT,\n\t.make_pmd = PTE_IDENT,\n\n#if CONFIG_PGTABLE_LEVELS >= 4\n\t.pud_val = PTE_IDENT,\n\t.make_pud = PTE_IDENT,\n\n\t.set_p4d = native_set_p4d,\n\n#if CONFIG_PGTABLE_LEVELS >= 5\n\t.p4d_val = PTE_IDENT,\n\t.make_p4d = PTE_IDENT,\n\n\t.set_pgd = native_set_pgd,\n#endif /* CONFIG_PGTABLE_LEVELS >= 5 */\n#endif /* CONFIG_PGTABLE_LEVELS >= 4 */\n#endif /* CONFIG_PGTABLE_LEVELS >= 3 */\n\n\t.pte_val = PTE_IDENT,\n\t.pgd_val = PTE_IDENT,\n\n\t.make_pte = PTE_IDENT,\n\t.make_pgd = PTE_IDENT,\n\n\t.dup_mmap = paravirt_nop,\n\t.exit_mmap = paravirt_nop,\n\t.activate_mm = paravirt_nop,\n\n\t.lazy_mode = {\n\t\t.enter = paravirt_nop,\n\t\t.leave = paravirt_nop,\n\t\t.flush = paravirt_nop,\n\t},\n\n\t.set_fixmap = native_set_fixmap,\n};\n\nEXPORT_SYMBOL_GPL(pv_time_ops);\nEXPORT_SYMBOL    (pv_cpu_ops);\nEXPORT_SYMBOL    (pv_mmu_ops);\nEXPORT_SYMBOL_GPL(pv_info);\nEXPORT_SYMBOL    (pv_irq_ops);\n"], "filenames": ["arch/x86/kernel/paravirt.c"], "buggy_code_start_loc": [91], "buggy_code_end_loc": [110], "fixing_code_start_loc": [91], "fixing_code_end_loc": [117], "type": "CWE-200", "message": "arch/x86/kernel/paravirt.c in the Linux kernel before 4.18.1 mishandles certain indirect calls, which makes it easier for attackers to conduct Spectre-v2 attacks against paravirtual guests.", "other": {"cve": {"id": "CVE-2018-15594", "sourceIdentifier": "cve@mitre.org", "published": "2018-08-20T08:29:00.253", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "arch/x86/kernel/paravirt.c in the Linux kernel before 4.18.1 mishandles certain indirect calls, which makes it easier for attackers to conduct Spectre-v2 attacks against paravirtual guests."}, {"lang": "es", "value": "arch/x86/kernel/paravirt.c en el kernel de Linux en versiones anteriores a la 4.18.1 maneja incorrectamente algunas llamadas indirectas, lo que hace que sea m\u00e1s f\u00e1cil para los atacantes realizar ataques Spectre-v2 contra guests paravirtuales."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:esm:*:*:*", "matchCriteriaId": "8D305F7A-D159-4716-AB26-5E38BB5CD991"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.18.1", "matchCriteriaId": "C4E114F9-94BB-4D0A-A648-C9D431110D2F"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=5800dc5c19f34e6e03b5adab1282535cb102fafd", "source": "cve@mitre.org", "tags": ["Mitigation", "Patch", "Vendor Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2019-05/msg00043.html", "source": "cve@mitre.org"}, {"url": "http://www.securityfocus.com/bid/105120", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1041601", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2019:2029", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2019:2043", "source": "cve@mitre.org"}, {"url": "https://cdn.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.18.1", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/5800dc5c19f34e6e03b5adab1282535cb102fafd", "source": "cve@mitre.org", "tags": ["Mitigation", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/10/msg00003.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://twitter.com/grsecurity/status/1029324426142199808", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3775-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3775-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3776-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3776-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3777-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3777-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3777-3/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2018/dsa-4308", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/5800dc5c19f34e6e03b5adab1282535cb102fafd"}}