{"buggy_code": ["/* This work is licensed under a Creative Commons CCZero 1.0 Universal License.\n * See http://creativecommons.org/publicdomain/zero/1.0/ for more information.\n *\n *    Copyright 2017 (c) Fraunhofer IOSB (Author: Julius Pfrommer)\n *    Copyright 2017 (c) Julian Grothoff\n *    Copyright 2017-2018 (c) Mark Giraud, Fraunhofer IOSB\n *    Copyright 2017 (c) Stefan Profanter, fortiss GmbH\n *    Copyright 2017 (c) Thomas Stalder, Blue Time Concept SA\n *    Copyright 2018 (c) Daniel Feist, Precitec GmbH & Co. KG\n *    Copyright 2018 (c) Fabian Arndt, Root-Core\n *    Copyright 2019 (c) Kalycito Infotech Private Limited\n *    Copyright 2017-2020 (c) HMS Industrial Networks AB (Author: Jonas Green)\n *    Copyright 2020 (c) Wind River Systems, Inc.\n */\n\n#include <open62541/client.h>\n#include <open62541/client_config_default.h>\n#include <open62541/network_tcp.h>\n#ifdef UA_ENABLE_WEBSOCKET_SERVER\n#include <open62541/network_ws.h>\n#endif\n#include <open62541/plugin/accesscontrol_default.h>\n#include <open62541/plugin/nodestore_default.h>\n#include <open62541/plugin/log_stdout.h>\n#include <open62541/plugin/pki_default.h>\n#include <open62541/plugin/securitypolicy_default.h>\n#include <open62541/server_config_default.h>\n\n/* Struct initialization works across ANSI C/C99/C++ if it is done when the\n * variable is first declared. Assigning values to existing structs is\n * heterogeneous across the three. */\nstatic UA_INLINE UA_UInt32Range\nUA_UINT32RANGE(UA_UInt32 min, UA_UInt32 max) {\n    UA_UInt32Range range = {min, max};\n    return range;\n}\n\nstatic UA_INLINE UA_DurationRange\nUA_DURATIONRANGE(UA_Duration min, UA_Duration max) {\n    UA_DurationRange range = {min, max};\n    return range;\n}\n\nUA_Server *\nUA_Server_new() {\n    UA_ServerConfig config;\n    memset(&config, 0, sizeof(UA_ServerConfig));\n    /* Set a default logger and NodeStore for the initialization */\n    config.logger = UA_Log_Stdout_;\n    if(UA_STATUSCODE_GOOD != UA_Nodestore_HashMap(&config.nodestore)) {\n        return NULL;\n    }\n\n    return UA_Server_newWithConfig(&config);\n}\n\n/*******************************/\n/* Default Connection Settings */\n/*******************************/\n\nconst UA_ConnectionConfig UA_ConnectionConfig_default = {\n    0,     /* .protocolVersion */\n    65535, /* .sendBufferSize, 64k per chunk */\n    65535, /* .recvBufferSize, 64k per chunk */\n    0,     /* .localMaxMessageSize, 0 -> unlimited */\n    0,     /* .remoteMaxMessageSize, 0 -> unlimited */\n    0,     /* .localMaxChunkCount, 0 -> unlimited */\n    0      /* .remoteMaxChunkCount, 0 -> unlimited */\n};\n\n/***************************/\n/* Default Server Settings */\n/***************************/\n\n#define MANUFACTURER_NAME \"open62541\"\n#define PRODUCT_NAME \"open62541 OPC UA Server\"\n#define PRODUCT_URI \"http://open62541.org\"\n#define APPLICATION_NAME \"open62541-based OPC UA Application\"\n#define APPLICATION_URI \"urn:unconfigured:application\"\n#define APPLICATION_URI_SERVER \"urn:open62541.server.application\"\n\n#define STRINGIFY(arg) #arg\n#define VERSION(MAJOR, MINOR, PATCH, LABEL) \\\n    STRINGIFY(MAJOR) \".\" STRINGIFY(MINOR) \".\" STRINGIFY(PATCH) LABEL\n\nstatic UA_StatusCode\ncreateEndpoint(UA_ServerConfig *conf, UA_EndpointDescription *endpoint,\n               const UA_SecurityPolicy *securityPolicy,\n               UA_MessageSecurityMode securityMode) {\n    UA_EndpointDescription_init(endpoint);\n\n    endpoint->securityMode = securityMode;\n    UA_String_copy(&securityPolicy->policyUri, &endpoint->securityPolicyUri);\n    endpoint->transportProfileUri =\n        UA_STRING_ALLOC(\"http://opcfoundation.org/UA-Profile/Transport/uatcp-uasc-uabinary\");\n\n    /* Add security level value for the corresponding message security mode */\n    endpoint->securityLevel = (UA_Byte) securityMode;\n\n    /* Enable all login mechanisms from the access control plugin  */\n    UA_StatusCode retval = UA_Array_copy(conf->accessControl.userTokenPolicies,\n                                         conf->accessControl.userTokenPoliciesSize,\n                                         (void **)&endpoint->userIdentityTokens,\n                                         &UA_TYPES[UA_TYPES_USERTOKENPOLICY]);\n    if(retval != UA_STATUSCODE_GOOD){\n        UA_String_clear(&endpoint->securityPolicyUri);\n        UA_String_clear(&endpoint->transportProfileUri);\n        return retval;\n    }\n    endpoint->userIdentityTokensSize = conf->accessControl.userTokenPoliciesSize;\n\n    UA_String_copy(&securityPolicy->localCertificate, &endpoint->serverCertificate);\n    UA_ApplicationDescription_copy(&conf->applicationDescription, &endpoint->server);\n\n    return UA_STATUSCODE_GOOD;\n}\n\nstatic const size_t usernamePasswordsSize = 2;\nstatic UA_UsernamePasswordLogin usernamePasswords[2] = {\n    {UA_STRING_STATIC(\"user1\"), UA_STRING_STATIC(\"password\")},\n    {UA_STRING_STATIC(\"user2\"), UA_STRING_STATIC(\"password1\")}};\n\nstatic UA_StatusCode\nsetDefaultConfig(UA_ServerConfig *conf) {\n    if(!conf)\n        return UA_STATUSCODE_BADINVALIDARGUMENT;\n\n    if(conf->nodestore.context == NULL)\n        UA_Nodestore_HashMap(&conf->nodestore);\n\n    /* --> Start setting the default static config <-- */\n    /* Allow user to set his own logger */\n    if(!conf->logger.log)\n        conf->logger = UA_Log_Stdout_;\n\n    conf->shutdownDelay = 0.0;\n\n    /* Server Description */\n    UA_BuildInfo_clear(&conf->buildInfo);\n    conf->buildInfo.productUri = UA_STRING_ALLOC(PRODUCT_URI);\n    conf->buildInfo.manufacturerName = UA_STRING_ALLOC(MANUFACTURER_NAME);\n    conf->buildInfo.productName = UA_STRING_ALLOC(PRODUCT_NAME);\n    conf->buildInfo.softwareVersion =\n        UA_STRING_ALLOC(VERSION(UA_OPEN62541_VER_MAJOR, UA_OPEN62541_VER_MINOR,\n                                UA_OPEN62541_VER_PATCH, UA_OPEN62541_VER_LABEL));\n#ifdef UA_PACK_DEBIAN\n    conf->buildInfo.buildNumber = UA_STRING_ALLOC(\"deb\");\n#else\n    conf->buildInfo.buildNumber = UA_STRING_ALLOC(__DATE__ \" \" __TIME__);\n#endif\n    conf->buildInfo.buildDate = UA_DateTime_now();\n\n    UA_ApplicationDescription_clear(&conf->applicationDescription);\n    conf->applicationDescription.applicationUri = UA_STRING_ALLOC(APPLICATION_URI_SERVER);\n    conf->applicationDescription.productUri = UA_STRING_ALLOC(PRODUCT_URI);\n    conf->applicationDescription.applicationName =\n        UA_LOCALIZEDTEXT_ALLOC(\"en\", APPLICATION_NAME);\n    conf->applicationDescription.applicationType = UA_APPLICATIONTYPE_SERVER;\n    /* conf->applicationDescription.gatewayServerUri = UA_STRING_NULL; */\n    /* conf->applicationDescription.discoveryProfileUri = UA_STRING_NULL; */\n    /* conf->applicationDescription.discoveryUrlsSize = 0; */\n    /* conf->applicationDescription.discoveryUrls = NULL; */\n\n#ifdef UA_ENABLE_DISCOVERY_MULTICAST\n    UA_MdnsDiscoveryConfiguration_clear(&conf->mdnsConfig);\n    conf->mdnsInterfaceIP = UA_STRING_NULL;\n# if !defined(UA_HAS_GETIFADDR)\n    conf->mdnsIpAddressList = NULL;\n    conf->mdnsIpAddressListSize = 0;\n# endif\n#endif\n\n    /* Custom DataTypes */\n    /* conf->customDataTypesSize = 0; */\n    /* conf->customDataTypes = NULL; */\n\n    /* Networking */\n    /* conf->networkLayersSize = 0; */\n    /* conf->networkLayers = NULL; */\n    /* conf->customHostname = UA_STRING_NULL; */\n\n    /* Endpoints */\n    /* conf->endpoints = {0, NULL}; */\n\n    /* Certificate Verification that accepts every certificate. Can be\n     * overwritten when the policy is specialized. */\n    UA_CertificateVerification_AcceptAll(&conf->certificateVerification);\n\n    /* * Global Node Lifecycle * */\n    /* conf->nodeLifecycle.constructor = NULL; */\n    /* conf->nodeLifecycle.destructor = NULL; */\n    /* conf->nodeLifecycle.createOptionalChild = NULL; */\n    /* conf->nodeLifecycle.generateChildNodeId = NULL; */\n\n    /* Limits for SecureChannels */\n    conf->maxSecureChannels = 40;\n    conf->maxSecurityTokenLifetime = 10 * 60 * 1000; /* 10 minutes */\n\n    /* Limits for Sessions */\n    conf->maxSessions = 100;\n    conf->maxSessionTimeout = 60.0 * 60.0 * 1000.0; /* 1h */\n\n#ifdef UA_ENABLE_SUBSCRIPTIONS\n    /* Limits for Subscriptions */\n    conf->publishingIntervalLimits = UA_DURATIONRANGE(100.0, 3600.0 * 1000.0);\n    conf->lifeTimeCountLimits = UA_UINT32RANGE(3, 15000);\n    conf->keepAliveCountLimits = UA_UINT32RANGE(1, 100);\n    conf->maxNotificationsPerPublish = 1000;\n    conf->enableRetransmissionQueue = true;\n    conf->maxRetransmissionQueueSize = 0; /* unlimited */\n# ifdef UA_ENABLE_SUBSCRIPTIONS_EVENTS\n    conf->maxEventsPerNode = 0; /* unlimited */\n# endif\n\n    /* Limits for MonitoredItems */\n    conf->samplingIntervalLimits = UA_DURATIONRANGE(50.0, 24.0 * 3600.0 * 1000.0);\n    conf->queueSizeLimits = UA_UINT32RANGE(1, 100);\n#endif\n\n#ifdef UA_ENABLE_DISCOVERY\n    conf->discoveryCleanupTimeout = 60 * 60;\n#endif\n\n#ifdef UA_ENABLE_HISTORIZING\n    /* conf->accessHistoryDataCapability = UA_FALSE; */\n    /* conf->maxReturnDataValues = 0; */\n\n    /* conf->accessHistoryEventsCapability = UA_FALSE; */\n    /* conf->maxReturnEventValues = 0; */\n\n    /* conf->insertDataCapability = UA_FALSE; */\n    /* conf->insertEventCapability = UA_FALSE; */\n    /* conf->insertAnnotationsCapability = UA_FALSE; */\n\n    /* conf->replaceDataCapability = UA_FALSE; */\n    /* conf->replaceEventCapability = UA_FALSE; */\n\n    /* conf->updateDataCapability = UA_FALSE; */\n    /* conf->updateEventCapability = UA_FALSE; */\n\n    /* conf->deleteRawCapability = UA_FALSE; */\n    /* conf->deleteEventCapability = UA_FALSE; */\n    /* conf->deleteAtTimeDataCapability = UA_FALSE; */\n#endif\n\n#if UA_MULTITHREADING >= 100\n    conf->maxAsyncOperationQueueSize = 0;\n    conf->asyncOperationTimeout = 120000; /* Async Operation Timeout in ms (2 minutes) */\n#endif\n\n    /* --> Finish setting the default static config <-- */\n\n    return UA_STATUSCODE_GOOD;\n}\n\nUA_EXPORT UA_StatusCode\nUA_ServerConfig_setBasics(UA_ServerConfig* conf) {\n    UA_StatusCode res = setDefaultConfig(conf);\n    UA_LOG_WARNING(&conf->logger, UA_LOGCATEGORY_USERLAND,\n                   \"AcceptAll Certificate Verification. \"\n                   \"Any remote certificate will be accepted.\");\n    return res;\n}\n\nstatic UA_StatusCode\naddDefaultNetworkLayers(UA_ServerConfig *conf, UA_UInt16 portNumber,\n                        UA_UInt32 sendBufferSize, UA_UInt32 recvBufferSize) {\n    return UA_ServerConfig_addNetworkLayerTCP(conf, portNumber, sendBufferSize, recvBufferSize);\n}\n\n#ifdef UA_ENABLE_WEBSOCKET_SERVER\nUA_EXPORT UA_StatusCode\nUA_ServerConfig_addNetworkLayerWS(UA_ServerConfig *conf, UA_UInt16 portNumber,\n                                   UA_UInt32 sendBufferSize, UA_UInt32 recvBufferSize, const UA_ByteString* certificate, const UA_ByteString* privateKey) {\n    /* Add a network layer */\n    UA_ServerNetworkLayer *tmp = (UA_ServerNetworkLayer *)\n        UA_realloc(conf->networkLayers,\n                   sizeof(UA_ServerNetworkLayer) * (1 + conf->networkLayersSize));\n    if(!tmp)\n        return UA_STATUSCODE_BADOUTOFMEMORY;\n    conf->networkLayers = tmp;\n\n    UA_ConnectionConfig config = UA_ConnectionConfig_default;\n    if(sendBufferSize > 0)\n        config.sendBufferSize = sendBufferSize;\n    if(recvBufferSize > 0)\n        config.recvBufferSize = recvBufferSize;\n\n    conf->networkLayers[conf->networkLayersSize] =\n        UA_ServerNetworkLayerWS(config, portNumber, certificate, privateKey);\n    if(!conf->networkLayers[conf->networkLayersSize].handle)\n        return UA_STATUSCODE_BADOUTOFMEMORY;\n    conf->networkLayersSize++;\n\n    return UA_STATUSCODE_GOOD;\n}\n#endif\n\nUA_EXPORT UA_StatusCode\nUA_ServerConfig_addNetworkLayerTCP(UA_ServerConfig *conf, UA_UInt16 portNumber,\n                                   UA_UInt32 sendBufferSize, UA_UInt32 recvBufferSize) {\n    /* Add a network layer */\n    UA_ServerNetworkLayer *tmp = (UA_ServerNetworkLayer *)\n        UA_realloc(conf->networkLayers,\n                   sizeof(UA_ServerNetworkLayer) * (1 + conf->networkLayersSize));\n    if(!tmp)\n        return UA_STATUSCODE_BADOUTOFMEMORY;\n    conf->networkLayers = tmp;\n\n    UA_ConnectionConfig config = UA_ConnectionConfig_default;\n    if (sendBufferSize > 0)\n        config.sendBufferSize = sendBufferSize;\n    if (recvBufferSize > 0)\n        config.recvBufferSize = recvBufferSize;\n\n    conf->networkLayers[conf->networkLayersSize] =\n        UA_ServerNetworkLayerTCP(config, portNumber, 0);\n    if (!conf->networkLayers[conf->networkLayersSize].handle)\n        return UA_STATUSCODE_BADOUTOFMEMORY;\n    conf->networkLayersSize++;\n\n    return UA_STATUSCODE_GOOD;\n}\n\nUA_EXPORT UA_StatusCode\nUA_ServerConfig_addSecurityPolicyNone(UA_ServerConfig *config, \n                                      const UA_ByteString *certificate) {\n    /* Allocate the SecurityPolicies */\n    UA_SecurityPolicy *tmp = (UA_SecurityPolicy *)\n        UA_realloc(config->securityPolicies,\n                   sizeof(UA_SecurityPolicy) * (1 + config->securityPoliciesSize));\n    if(!tmp)\n        return UA_STATUSCODE_BADOUTOFMEMORY;\n    config->securityPolicies = tmp;\n    \n    /* Populate the SecurityPolicies */\n    UA_ByteString localCertificate = UA_BYTESTRING_NULL;\n    if(certificate)\n        localCertificate = *certificate;\n    UA_StatusCode retval =\n        UA_SecurityPolicy_None(&config->securityPolicies[config->securityPoliciesSize],\n                               localCertificate, &config->logger);\n    if(retval != UA_STATUSCODE_GOOD) {\n        if(config->securityPoliciesSize == 0) {\n            UA_free(config->securityPolicies);\n            config->securityPolicies = NULL;\n        }\n        return retval;\n    }\n\n    config->securityPoliciesSize++;\n    return UA_STATUSCODE_GOOD;\n}\n\nUA_EXPORT UA_StatusCode\nUA_ServerConfig_addEndpoint(UA_ServerConfig *config, const UA_String securityPolicyUri, \n                            UA_MessageSecurityMode securityMode) {\n    /* Allocate the endpoint */\n    UA_EndpointDescription *tmp = (UA_EndpointDescription *)\n        UA_realloc(config->endpoints,\n                   sizeof(UA_EndpointDescription) * (1 + config->endpointsSize));\n    if(!tmp) {\n        return UA_STATUSCODE_BADOUTOFMEMORY;\n    }\n    config->endpoints = tmp;\n\n    /* Lookup the security policy */\n    const UA_SecurityPolicy *policy = NULL;\n    for (size_t i = 0; i < config->securityPoliciesSize; ++i) {\n        if (UA_String_equal(&securityPolicyUri, &config->securityPolicies[i].policyUri)) {\n            policy = &config->securityPolicies[i];\n            break;\n        }\n    }\n    if (!policy)\n        return UA_STATUSCODE_BADINVALIDARGUMENT;\n\n    /* Populate the endpoint */\n    UA_StatusCode retval =\n        createEndpoint(config, &config->endpoints[config->endpointsSize],\n                       policy, securityMode);\n    if(retval != UA_STATUSCODE_GOOD)\n        return retval;\n    config->endpointsSize++;\n\n    return UA_STATUSCODE_GOOD;\n}\n\nUA_EXPORT UA_StatusCode\nUA_ServerConfig_addAllEndpoints(UA_ServerConfig *config) {\n    /* Allocate the endpoints */\n    UA_EndpointDescription * tmp = (UA_EndpointDescription *)\n        UA_realloc(config->endpoints,\n                   sizeof(UA_EndpointDescription) *\n                   (2 * config->securityPoliciesSize + config->endpointsSize));\n    if(!tmp) {\n        return UA_STATUSCODE_BADOUTOFMEMORY;\n    }\n    config->endpoints = tmp;\n\n    /* Populate the endpoints */\n    for(size_t i = 0; i < config->securityPoliciesSize; ++i) {\n        if(UA_String_equal(&UA_SECURITY_POLICY_NONE_URI, &config->securityPolicies[i].policyUri)) {\n            UA_StatusCode retval =\n                createEndpoint(config, &config->endpoints[config->endpointsSize],\n                               &config->securityPolicies[i], UA_MESSAGESECURITYMODE_NONE);\n            if(retval != UA_STATUSCODE_GOOD)\n                return retval;\n            config->endpointsSize++;\n        } else {\n            UA_StatusCode retval =\n                createEndpoint(config, &config->endpoints[config->endpointsSize],\n                               &config->securityPolicies[i], UA_MESSAGESECURITYMODE_SIGN);\n            if(retval != UA_STATUSCODE_GOOD)\n                return retval;\n            config->endpointsSize++;\n\n            retval = createEndpoint(config, &config->endpoints[config->endpointsSize],\n                                    &config->securityPolicies[i],\n                                    UA_MESSAGESECURITYMODE_SIGNANDENCRYPT);\n            if(retval != UA_STATUSCODE_GOOD)\n                return retval;\n            config->endpointsSize++;\n        }\n    }\n\n    return UA_STATUSCODE_GOOD;\n}\n\nUA_EXPORT UA_StatusCode\nUA_ServerConfig_setMinimalCustomBuffer(UA_ServerConfig *config, UA_UInt16 portNumber,\n                                       const UA_ByteString *certificate,\n                                       UA_UInt32 sendBufferSize,\n                                       UA_UInt32 recvBufferSize) {\n    if(!config)\n        return UA_STATUSCODE_BADINVALIDARGUMENT;\n\n    UA_StatusCode retval = setDefaultConfig(config);\n    if(retval != UA_STATUSCODE_GOOD) {\n        UA_ServerConfig_clean(config);\n        return retval;\n    }\n\n    retval = addDefaultNetworkLayers(config, portNumber, sendBufferSize, recvBufferSize);\n    if(retval != UA_STATUSCODE_GOOD) {\n        UA_ServerConfig_clean(config);\n        return retval;\n    }\n\n    /* Allocate the SecurityPolicies */\n    retval = UA_ServerConfig_addSecurityPolicyNone(config, certificate);\n    if(retval != UA_STATUSCODE_GOOD) {\n        UA_ServerConfig_clean(config);\n        return retval;\n    }\n\n    /* Initialize the Access Control plugin */\n    retval = UA_AccessControl_default(config, true,\n                &config->securityPolicies[config->securityPoliciesSize-1].policyUri,\n                usernamePasswordsSize, usernamePasswords);\n    if(retval != UA_STATUSCODE_GOOD) {\n        UA_ServerConfig_clean(config);\n        return retval;\n    }\n\n    /* Allocate the endpoint */\n    retval = UA_ServerConfig_addEndpoint(config, UA_SECURITY_POLICY_NONE_URI,\n                                         UA_MESSAGESECURITYMODE_NONE);\n    if(retval != UA_STATUSCODE_GOOD) {\n        UA_ServerConfig_clean(config);\n        return retval;\n    }\n\n    UA_LOG_WARNING(&config->logger, UA_LOGCATEGORY_USERLAND,\n                   \"AcceptAll Certificate Verification. \"\n                   \"Any remote certificate will be accepted.\");\n\n    return UA_STATUSCODE_GOOD;\n}\n\n#ifdef UA_ENABLE_ENCRYPTION\n\nUA_EXPORT UA_StatusCode\nUA_ServerConfig_addSecurityPolicyBasic128Rsa15(UA_ServerConfig *config, \n                                               const UA_ByteString *certificate,\n                                               const UA_ByteString *privateKey) {\n    /* Allocate the SecurityPolicies */\n    UA_SecurityPolicy *tmp = (UA_SecurityPolicy *)\n        UA_realloc(config->securityPolicies,\n                   sizeof(UA_SecurityPolicy) * (1 + config->securityPoliciesSize));\n    if(!tmp)\n        return UA_STATUSCODE_BADOUTOFMEMORY;\n    config->securityPolicies = tmp;\n    \n    /* Populate the SecurityPolicies */\n    UA_ByteString localCertificate = UA_BYTESTRING_NULL;\n    UA_ByteString localPrivateKey  = UA_BYTESTRING_NULL;\n    if(certificate)\n        localCertificate = *certificate;\n    if(privateKey)\n       localPrivateKey = *privateKey;\n    UA_StatusCode retval =\n        UA_SecurityPolicy_Basic128Rsa15(&config->securityPolicies[config->securityPoliciesSize],\n                                        localCertificate, localPrivateKey, &config->logger);\n    if(retval != UA_STATUSCODE_GOOD) {\n        if(config->securityPoliciesSize == 0) {\n            UA_free(config->securityPolicies);\n            config->securityPolicies = NULL;\n        }\n        return retval;\n    }\n\n    config->securityPoliciesSize++;\n    return UA_STATUSCODE_GOOD;\n}\n\nUA_EXPORT UA_StatusCode\nUA_ServerConfig_addSecurityPolicyBasic256(UA_ServerConfig *config, \n                                          const UA_ByteString *certificate,\n                                          const UA_ByteString *privateKey) {\n    /* Allocate the SecurityPolicies */\n    UA_SecurityPolicy *tmp = (UA_SecurityPolicy *)\n        UA_realloc(config->securityPolicies,\n                   sizeof(UA_SecurityPolicy) * (1 + config->securityPoliciesSize));\n    if(!tmp)\n        return UA_STATUSCODE_BADOUTOFMEMORY;\n    config->securityPolicies = tmp;\n    \n    /* Populate the SecurityPolicies */\n    UA_ByteString localCertificate = UA_BYTESTRING_NULL;\n    UA_ByteString localPrivateKey  = UA_BYTESTRING_NULL;\n    if(certificate)\n        localCertificate = *certificate;\n    if(privateKey)\n       localPrivateKey = *privateKey;\n    UA_StatusCode retval =\n        UA_SecurityPolicy_Basic256(&config->securityPolicies[config->securityPoliciesSize],\n                                   localCertificate, localPrivateKey, &config->logger);\n    if(retval != UA_STATUSCODE_GOOD) {\n        if(config->securityPoliciesSize == 0) {\n            UA_free(config->securityPolicies);\n            config->securityPolicies = NULL;\n        }\n        return retval;\n    }\n\n    config->securityPoliciesSize++;\n    return UA_STATUSCODE_GOOD;\n}\n\nUA_EXPORT UA_StatusCode\nUA_ServerConfig_addSecurityPolicyBasic256Sha256(UA_ServerConfig *config, \n                                                const UA_ByteString *certificate,\n                                                const UA_ByteString *privateKey) {\n    /* Allocate the SecurityPolicies */\n    UA_SecurityPolicy *tmp = (UA_SecurityPolicy *)\n        UA_realloc(config->securityPolicies,\n                   sizeof(UA_SecurityPolicy) * (1 + config->securityPoliciesSize));\n    if(!tmp)\n        return UA_STATUSCODE_BADOUTOFMEMORY;\n    config->securityPolicies = tmp;\n    \n    /* Populate the SecurityPolicies */\n    UA_ByteString localCertificate = UA_BYTESTRING_NULL;\n    UA_ByteString localPrivateKey  = UA_BYTESTRING_NULL;\n    if(certificate)\n        localCertificate = *certificate;\n    if(privateKey)\n       localPrivateKey = *privateKey;\n    UA_StatusCode retval =\n        UA_SecurityPolicy_Basic256Sha256(&config->securityPolicies[config->securityPoliciesSize],\n                                         localCertificate, localPrivateKey, &config->logger);\n    if(retval != UA_STATUSCODE_GOOD) {\n        if(config->securityPoliciesSize == 0) {\n            UA_free(config->securityPolicies);\n            config->securityPolicies = NULL;\n        }\n        return retval;\n    }\n\n    config->securityPoliciesSize++;\n    return UA_STATUSCODE_GOOD;\n}\n\nUA_EXPORT UA_StatusCode\nUA_ServerConfig_addSecurityPolicyAes128Sha256RsaOaep(UA_ServerConfig *config, \n                                                const UA_ByteString *certificate,\n                                                const UA_ByteString *privateKey) {\n    /* Allocate the SecurityPolicies */\n    UA_SecurityPolicy *tmp = (UA_SecurityPolicy *)\n        UA_realloc(config->securityPolicies,\n                   sizeof(UA_SecurityPolicy) * (1 + config->securityPoliciesSize));\n    if(!tmp)\n        return UA_STATUSCODE_BADOUTOFMEMORY;\n    config->securityPolicies = tmp;\n    \n    /* Populate the SecurityPolicies */\n    UA_ByteString localCertificate = UA_BYTESTRING_NULL;\n    UA_ByteString localPrivateKey  = UA_BYTESTRING_NULL;\n    if(certificate)\n        localCertificate = *certificate;\n    if(privateKey)\n       localPrivateKey = *privateKey;\n    UA_StatusCode retval =\n        UA_SecurityPolicy_Aes128Sha256RsaOaep(&config->securityPolicies[config->securityPoliciesSize],\n                                              localCertificate, localPrivateKey, &config->logger);\n    if(retval != UA_STATUSCODE_GOOD) {\n        if(config->securityPoliciesSize == 0) {\n            UA_free(config->securityPolicies);\n            config->securityPolicies = NULL;\n        }\n        return retval;\n    }\n\n    config->securityPoliciesSize++;\n    return UA_STATUSCODE_GOOD;\n}\n\n/* Always returns UA_STATUSCODE_GOOD. Logs a warning if policies could not be added. */\nUA_EXPORT UA_StatusCode\nUA_ServerConfig_addAllSecurityPolicies(UA_ServerConfig *config,\n                                       const UA_ByteString *certificate,\n                                       const UA_ByteString *privateKey) {\n    /* Populate the SecurityPolicies */\n    UA_ByteString localCertificate = UA_BYTESTRING_NULL;\n    UA_ByteString localPrivateKey  = UA_BYTESTRING_NULL;\n    if(certificate)\n        localCertificate = *certificate;\n    if(privateKey)\n       localPrivateKey = *privateKey;\n\n    UA_StatusCode retval = UA_ServerConfig_addSecurityPolicyNone(config, &localCertificate);\n    if(retval != UA_STATUSCODE_GOOD) {\n        UA_LOG_WARNING(&config->logger, UA_LOGCATEGORY_USERLAND,\n                       \"Could not add SecurityPolicy#None with error code %s\",\n                       UA_StatusCode_name(retval));\n    }\n\n    retval = UA_ServerConfig_addSecurityPolicyBasic128Rsa15(config, &localCertificate, &localPrivateKey);\n    if(retval != UA_STATUSCODE_GOOD) {\n        UA_LOG_WARNING(&config->logger, UA_LOGCATEGORY_USERLAND,\n                       \"Could not add SecurityPolicy#Basic128Rsa15 with error code %s\",\n                       UA_StatusCode_name(retval));\n    }\n\n    retval = UA_ServerConfig_addSecurityPolicyBasic256(config, &localCertificate, &localPrivateKey);\n    if(retval != UA_STATUSCODE_GOOD) {\n        UA_LOG_WARNING(&config->logger, UA_LOGCATEGORY_USERLAND,\n                       \"Could not add SecurityPolicy#Basic256 with error code %s\",\n                       UA_StatusCode_name(retval));\n    }\n\n    retval = UA_ServerConfig_addSecurityPolicyBasic256Sha256(config, &localCertificate, &localPrivateKey);\n    if(retval != UA_STATUSCODE_GOOD) {\n        UA_LOG_WARNING(&config->logger, UA_LOGCATEGORY_USERLAND,\n                       \"Could not add SecurityPolicy#Basic256Sha256 with error code %s\",\n                       UA_StatusCode_name(retval));\n    }\n\n    retval = UA_ServerConfig_addSecurityPolicyAes128Sha256RsaOaep(config, &localCertificate, &localPrivateKey);\n    if(retval != UA_STATUSCODE_GOOD) {\n        UA_LOG_WARNING(&config->logger, UA_LOGCATEGORY_USERLAND,\n                       \"Could not add SecurityPolicy#Aes128Sha256RsaOaep with error code %s\",\n                       UA_StatusCode_name(retval));\n    }\n\n    return UA_STATUSCODE_GOOD;\n}\n\nUA_EXPORT UA_StatusCode\nUA_ServerConfig_setDefaultWithSecurityPolicies(UA_ServerConfig *conf,\n                                               UA_UInt16 portNumber,\n                                               const UA_ByteString *certificate,\n                                               const UA_ByteString *privateKey,\n                                               const UA_ByteString *trustList,\n                                               size_t trustListSize,\n                                               const UA_ByteString *issuerList,\n                                               size_t issuerListSize,\n                                               const UA_ByteString *revocationList,\n                                               size_t revocationListSize) {\n    UA_StatusCode retval = setDefaultConfig(conf);\n    if(retval != UA_STATUSCODE_GOOD) {\n        UA_ServerConfig_clean(conf);\n        return retval;\n    }\n\n    retval = UA_CertificateVerification_Trustlist(&conf->certificateVerification,\n                                                  trustList, trustListSize,\n                                                  issuerList, issuerListSize,\n                                                  revocationList, revocationListSize);\n    if (retval != UA_STATUSCODE_GOOD)\n        return retval;\n\n    retval = addDefaultNetworkLayers(conf, portNumber, 0, 0);\n    if(retval != UA_STATUSCODE_GOOD) {\n        UA_ServerConfig_clean(conf);\n        return retval;\n    }\n\n    retval = UA_ServerConfig_addAllSecurityPolicies(conf, certificate, privateKey);\n    if(retval != UA_STATUSCODE_GOOD) {\n        UA_ServerConfig_clean(conf);\n        return retval;\n    }\n\n    retval = UA_AccessControl_default(conf, true,\n                &conf->securityPolicies[conf->securityPoliciesSize-1].policyUri,\n                usernamePasswordsSize, usernamePasswords);\n    if(retval != UA_STATUSCODE_GOOD) {\n        UA_ServerConfig_clean(conf);\n        return retval;\n    }\n\n    retval = UA_ServerConfig_addAllEndpoints(conf);\n    if(retval != UA_STATUSCODE_GOOD) {\n        UA_ServerConfig_clean(conf);\n        return retval;\n    }\n\n    return UA_STATUSCODE_GOOD;\n}\n\n#endif\n\n/***************************/\n/* Default Client Settings */\n/***************************/\n\nUA_Client * UA_Client_new() {\n    UA_ClientConfig config;\n    memset(&config, 0, sizeof(UA_ClientConfig));\n    config.logger.log = UA_Log_Stdout_log;\n    config.logger.context = NULL;\n    config.logger.clear = UA_Log_Stdout_clear;\n    return UA_Client_newWithConfig(&config);\n}\n\nUA_StatusCode\nUA_ClientConfig_setDefault(UA_ClientConfig *config) {\n    config->timeout = 5000;\n    config->secureChannelLifeTime = 10 * 60 * 1000; /* 10 minutes */\n\n    if(!config->logger.log) {\n       config->logger.log = UA_Log_Stdout_log;\n       config->logger.context = NULL;\n       config->logger.clear = UA_Log_Stdout_clear;\n    }\n\n    config->localConnectionConfig = UA_ConnectionConfig_default;\n\n    /* Certificate Verification that accepts every certificate. Can be\n     * overwritten when the policy is specialized. */\n    UA_CertificateVerification_AcceptAll(&config->certificateVerification);\n    UA_LOG_WARNING(&config->logger, UA_LOGCATEGORY_USERLAND,\n                   \"AcceptAll Certificate Verification. \"\n                   \"Any remote certificate will be accepted.\");\n\n    /* With encryption enabled, the applicationUri needs to match the URI from\n     * the certificate */\n    config->clientDescription.applicationUri = UA_STRING_ALLOC(APPLICATION_URI);\n    config->clientDescription.applicationType = UA_APPLICATIONTYPE_CLIENT;\n\n    if(config->securityPoliciesSize > 0) {\n        UA_LOG_ERROR(&config->logger, UA_LOGCATEGORY_NETWORK,\n                     \"Could not initialize a config that already has SecurityPolicies\");\n        return UA_STATUSCODE_BADINTERNALERROR;\n    }\n\n    config->securityPolicies = (UA_SecurityPolicy*)UA_malloc(sizeof(UA_SecurityPolicy));\n    if(!config->securityPolicies)\n        return UA_STATUSCODE_BADOUTOFMEMORY;\n    UA_StatusCode retval = UA_SecurityPolicy_None(config->securityPolicies,\n                                                  UA_BYTESTRING_NULL, &config->logger);\n    if(retval != UA_STATUSCODE_GOOD) {\n        UA_free(config->securityPolicies);\n        config->securityPolicies = NULL;\n        return retval;\n    }\n    config->securityPoliciesSize = 1;\n\n    config->initConnectionFunc = UA_ClientConnectionTCP_init; /* for async client */\n    config->pollConnectionFunc = UA_ClientConnectionTCP_poll; /* for async connection */\n\n    config->customDataTypes = NULL;\n    config->stateCallback = NULL;\n    config->connectivityCheckInterval = 0;\n\n    config->requestedSessionTimeout = 1200000; /* requestedSessionTimeout */\n\n    config->inactivityCallback = NULL;\n    config->clientContext = NULL;\n\n#ifdef UA_ENABLE_SUBSCRIPTIONS\n    config->outStandingPublishRequests = 10;\n    config->subscriptionInactivityCallback = NULL;\n#endif\n\n    return UA_STATUSCODE_GOOD;\n}\n\n#ifdef UA_ENABLE_ENCRYPTION\nUA_StatusCode\nUA_ClientConfig_setDefaultEncryption(UA_ClientConfig *config,\n                                     UA_ByteString localCertificate, UA_ByteString privateKey,\n                                     const UA_ByteString *trustList, size_t trustListSize,\n                                     const UA_ByteString *revocationList, size_t revocationListSize) {\n    UA_StatusCode retval = UA_ClientConfig_setDefault(config);\n    if(retval != UA_STATUSCODE_GOOD)\n        return retval;\n\n    retval = UA_CertificateVerification_Trustlist(&config->certificateVerification,\n                                                  trustList, trustListSize,\n                                                  NULL, 0,\n                                                  revocationList, revocationListSize);\n    if(retval != UA_STATUSCODE_GOOD)\n        return retval;\n\n    /* Populate SecurityPolicies */\n    UA_SecurityPolicy *sp = (UA_SecurityPolicy*)\n        UA_realloc(config->securityPolicies, sizeof(UA_SecurityPolicy) * 5);\n    if(!sp)\n        return UA_STATUSCODE_BADOUTOFMEMORY;\n    config->securityPolicies = sp;\n                  \n    retval = UA_SecurityPolicy_Basic128Rsa15(&config->securityPolicies[config->securityPoliciesSize],\n                                             localCertificate, privateKey, &config->logger);\n    if(retval == UA_STATUSCODE_GOOD) {\n        ++config->securityPoliciesSize;\n    } else {\n        UA_LOG_WARNING(&config->logger, UA_LOGCATEGORY_USERLAND,\n                       \"Could not add SecurityPolicy#Basic128Rsa15 with error code %s\",\n                       UA_StatusCode_name(retval));\n    }\n\n    retval = UA_SecurityPolicy_Basic256(&config->securityPolicies[config->securityPoliciesSize],\n                                        localCertificate, privateKey, &config->logger);\n    if(retval == UA_STATUSCODE_GOOD) {\n        ++config->securityPoliciesSize;\n    } else {\n        UA_LOG_WARNING(&config->logger, UA_LOGCATEGORY_USERLAND,\n                       \"Could not add SecurityPolicy#Basic256 with error code %s\",\n                       UA_StatusCode_name(retval));\n    }\n\n    retval = UA_SecurityPolicy_Basic256Sha256(&config->securityPolicies[config->securityPoliciesSize],\n                                              localCertificate, privateKey, &config->logger);\n    if(retval == UA_STATUSCODE_GOOD) {\n        ++config->securityPoliciesSize;\n    } else {\n        UA_LOG_WARNING(&config->logger, UA_LOGCATEGORY_USERLAND,\n                       \"Could not add SecurityPolicy#Basic256Sha256 with error code %s\",\n                       UA_StatusCode_name(retval));\n    }\n\n    retval = UA_SecurityPolicy_Aes128Sha256RsaOaep(&config->securityPolicies[config->securityPoliciesSize],\n                                                   localCertificate, privateKey, &config->logger);\n    if(retval == UA_STATUSCODE_GOOD) {\n        ++config->securityPoliciesSize;\n    } else {\n        UA_LOG_WARNING(&config->logger, UA_LOGCATEGORY_USERLAND,\n                       \"Could not add SecurityPolicy#Aes128Sha256RsaOaep with error code %s\",\n                       UA_StatusCode_name(retval));\n    }\n\n    if(config->securityPoliciesSize == 0) {\n        UA_free(config->securityPolicies);\n        config->securityPolicies = NULL;\n    }\n\n    return UA_STATUSCODE_GOOD;\n}\n#endif\n", "/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n#include <open62541/transport_generated.h>\n#include <open62541/transport_generated_encoding_binary.h>\n#include <open62541/transport_generated_handling.h>\n#include <open62541/types_generated.h>\n#include <open62541/types_generated_encoding_binary.h>\n#include <open62541/server_config_default.h>\n\n#include \"ua_securechannel.h\"\n#include <ua_types_encoding_binary.h>\n\n#include \"check.h\"\n#include \"testing_networklayers.h\"\n#include \"testing_policy.h\"\n\n#define UA_BYTESTRING_STATIC(s) {sizeof(s)-1, (UA_Byte*)(s)}\n\n// Some default testing sizes. Can be overwritten in testing functions.\n#define DEFAULT_SYM_ENCRYPTION_BLOCK_SIZE 2\n#define DEFAULT_SYM_SIGNING_KEY_LENGTH 3\n#define DEFAULT_SYM_ENCRYPTION_KEY_LENGTH 5\n#define DEFAULT_ASYM_REMOTE_SIGNATURE_SIZE 7\n#define DEFAULT_ASYM_LOCAL_SIGNATURE_SIZE 11\n#define DEFAULT_SYM_SIGNATURE_SIZE 13\n#define DEFAULT_ASYM_REMOTE_PLAINTEXT_BLOCKSIZE 256\n#define DEFAULT_ASYM_REMOTE_BLOCKSIZE 256\n\nUA_SecureChannel testChannel;\nUA_ByteString dummyCertificate =\n    UA_BYTESTRING_STATIC(\"DUMMY CERTIFICATE DUMMY CERTIFICATE DUMMY CERTIFICATE\");\nUA_SecurityPolicy dummyPolicy;\nUA_Connection testingConnection;\nUA_ByteString sentData;\n\n\nstatic funcs_called fCalled;\nstatic key_sizes keySizes;\n\nstatic void\nsetup_secureChannel(void) {\n    TestingPolicy(&dummyPolicy, dummyCertificate, &fCalled, &keySizes);\n    UA_SecureChannel_init(&testChannel, &UA_ConnectionConfig_default);\n    UA_SecureChannel_setSecurityPolicy(&testChannel, &dummyPolicy, &dummyCertificate);\n\n    testingConnection = createDummyConnection(65535, &sentData);\n    UA_Connection_attachSecureChannel(&testingConnection, &testChannel);\n    testChannel.connection = &testingConnection;\n\n    testChannel.state = UA_SECURECHANNELSTATE_OPEN;\n}\n\nstatic void\nteardown_secureChannel(void) {\n    UA_SecureChannel_close(&testChannel);\n    dummyPolicy.clear(&dummyPolicy);\n    testingConnection.close(&testingConnection);\n}\n\nstatic void\nsetup_funcs_called(void) {\n    memset(&fCalled, 0, sizeof(struct funcs_called));\n}\n\nstatic void\nteardown_funcs_called(void) {\n    memset(&fCalled, 0, sizeof(struct funcs_called));\n}\n\nstatic void\nsetup_key_sizes(void) {\n    memset(&keySizes, 0, sizeof(struct key_sizes));\n\n    keySizes.sym_sig_keyLen = DEFAULT_SYM_SIGNING_KEY_LENGTH;\n    keySizes.sym_enc_blockSize = DEFAULT_SYM_ENCRYPTION_BLOCK_SIZE;\n    keySizes.sym_enc_keyLen = DEFAULT_SYM_ENCRYPTION_KEY_LENGTH;\n    keySizes.sym_sig_size = DEFAULT_SYM_SIGNATURE_SIZE;\n\n    keySizes.asym_lcl_sig_size = DEFAULT_ASYM_LOCAL_SIGNATURE_SIZE;\n    keySizes.asym_rmt_sig_size = DEFAULT_ASYM_REMOTE_SIGNATURE_SIZE;\n\n    keySizes.asym_rmt_ptext_blocksize = DEFAULT_ASYM_REMOTE_PLAINTEXT_BLOCKSIZE;\n    keySizes.asym_rmt_blocksize = DEFAULT_ASYM_REMOTE_BLOCKSIZE;\n    keySizes.asym_rmt_enc_key_size = 2048;\n    keySizes.asym_lcl_enc_key_size = 1024;\n}\n\nstatic void\nteardown_key_sizes(void) {\n    memset(&keySizes, 0, sizeof(struct key_sizes));\n}\n\nSTART_TEST(SecureChannel_initAndDelete) {\n    TestingPolicy(&dummyPolicy, dummyCertificate, &fCalled, &keySizes);\n    UA_StatusCode retval;\n\n    UA_SecureChannel channel;\n    UA_SecureChannel_init(&channel, &UA_ConnectionConfig_default);\n    retval = UA_SecureChannel_setSecurityPolicy(&channel, &dummyPolicy, &dummyCertificate);\n\n    ck_assert_msg(retval == UA_STATUSCODE_GOOD, \"Expected StatusCode to be good\");\n    ck_assert_msg(channel.state == UA_SECURECHANNELSTATE_FRESH, \"Expected state to be new/fresh\");\n    ck_assert_msg(fCalled.newContext, \"Expected newContext to have been called\");\n    ck_assert_msg(fCalled.makeCertificateThumbprint,\n                  \"Expected makeCertificateThumbprint to have been called\");\n    ck_assert_msg(channel.securityPolicy == &dummyPolicy, \"SecurityPolicy not set correctly\");\n\n    UA_SecureChannel_close(&channel);\n    ck_assert_msg(fCalled.deleteContext, \"Expected deleteContext to have been called\");\n\n    dummyPolicy.clear(&dummyPolicy);\n}END_TEST\n\nstatic void\ncreateDummyResponse(UA_OpenSecureChannelResponse *response) {\n    UA_OpenSecureChannelResponse_init(response);\n    memset(response, 0, sizeof(UA_OpenSecureChannelResponse));\n}\n\nSTART_TEST(SecureChannel_sendAsymmetricOPNMessage_withoutConnection) {\n    UA_OpenSecureChannelResponse dummyResponse;\n    createDummyResponse(&dummyResponse);\n    testChannel.securityMode = UA_MESSAGESECURITYMODE_NONE;\n\n    // Remove connection to provoke error\n    UA_Connection_detachSecureChannel(testChannel.connection);\n    testChannel.connection = NULL;\n\n    UA_StatusCode retval =\n        UA_SecureChannel_sendAsymmetricOPNMessage(&testChannel, 42, &dummyResponse,\n                                                  &UA_TYPES[UA_TYPES_OPENSECURECHANNELRESPONSE]);\n\n    ck_assert_msg(retval != UA_STATUSCODE_GOOD, \"Expected failure without a connection\");\n}END_TEST\n\nSTART_TEST(SecureChannel_sendAsymmetricOPNMessage_invalidParameters) {\n    UA_OpenSecureChannelResponse dummyResponse;\n    createDummyResponse(&dummyResponse);\n\n    UA_StatusCode retval =\n        UA_SecureChannel_sendAsymmetricOPNMessage(&testChannel, 42, NULL,\n                                                  &UA_TYPES[UA_TYPES_OPENSECURECHANNELRESPONSE]);\n    ck_assert_msg(retval != UA_STATUSCODE_GOOD, \"Expected failure\");\n\n    retval = UA_SecureChannel_sendAsymmetricOPNMessage(&testChannel, 42, &dummyResponse, NULL);\n    ck_assert_msg(retval != UA_STATUSCODE_GOOD, \"Expected failure\");\n\n}END_TEST\n\nSTART_TEST(SecureChannel_sendAsymmetricOPNMessage_SecurityModeInvalid) {\n    // Configure our channel correctly for OPN messages and setup dummy message\n    UA_OpenSecureChannelResponse dummyResponse;\n    createDummyResponse(&dummyResponse);\n\n    testChannel.securityMode = UA_MESSAGESECURITYMODE_INVALID;\n\n    UA_StatusCode retval =\n        UA_SecureChannel_sendAsymmetricOPNMessage(&testChannel, 42, &dummyResponse,\n                                                  &UA_TYPES[UA_TYPES_OPENSECURECHANNELRESPONSE]);\n    ck_assert_msg(retval == UA_STATUSCODE_BADSECURITYMODEREJECTED,\n                  \"Expected SecurityMode rejected error\");\n}\nEND_TEST\n\nSTART_TEST(SecureChannel_sendAsymmetricOPNMessage_SecurityModeNone) {\n    // Configure our channel correctly for OPN messages and setup dummy message\n    UA_OpenSecureChannelResponse dummyResponse;\n    createDummyResponse(&dummyResponse);\n    testChannel.securityMode = UA_MESSAGESECURITYMODE_NONE;\n\n    UA_StatusCode retval =\n        UA_SecureChannel_sendAsymmetricOPNMessage(&testChannel, 42, &dummyResponse,\n                                                  &UA_TYPES[UA_TYPES_OPENSECURECHANNELRESPONSE]);\n    ck_assert_msg(retval == UA_STATUSCODE_GOOD, \"Expected function to succeed\");\n    ck_assert_msg(!fCalled.asym_enc, \"Message encryption was called but should not have been\");\n    ck_assert_msg(!fCalled.asym_sign, \"Message signing was called but should not have been\");\n}\nEND_TEST\n\n#ifdef UA_ENABLE_ENCRYPTION\n\nSTART_TEST(SecureChannel_sendAsymmetricOPNMessage_SecurityModeSign) {\n    // Configure our channel correctly for OPN messages and setup dummy message\n    UA_OpenSecureChannelResponse dummyResponse;\n    createDummyResponse(&dummyResponse);\n    testChannel.securityMode = UA_MESSAGESECURITYMODE_SIGN;\n\n    UA_StatusCode retval =\n        UA_SecureChannel_sendAsymmetricOPNMessage(&testChannel, 42, &dummyResponse,\n                                                  &UA_TYPES[UA_TYPES_OPENSECURECHANNELRESPONSE]);\n    ck_assert_msg(retval == UA_STATUSCODE_GOOD, \"Expected function to succeed\");\n    ck_assert_msg(fCalled.asym_enc, \"Expected message to have been encrypted but it was not\");\n    ck_assert_msg(fCalled.asym_sign, \"Expected message to have been signed but it was not\");\n}END_TEST\n\nSTART_TEST(SecureChannel_sendAsymmetricOPNMessage_SecurityModeSignAndEncrypt) {\n    // Configure our channel correctly for OPN messages and setup dummy message\n    UA_OpenSecureChannelResponse dummyResponse;\n    createDummyResponse(&dummyResponse);\n\n    testChannel.securityMode = UA_MESSAGESECURITYMODE_SIGNANDENCRYPT;\n    UA_StatusCode retval =\n        UA_SecureChannel_sendAsymmetricOPNMessage(&testChannel, 42, &dummyResponse,\n                                                  &UA_TYPES[UA_TYPES_OPENSECURECHANNELRESPONSE]);\n    ck_assert_msg(retval == UA_STATUSCODE_GOOD, \"Expected function to succeed\");\n    ck_assert_msg(fCalled.asym_enc, \"Expected message to have been encrypted but it was not\");\n    ck_assert_msg(fCalled.asym_sign, \"Expected message to have been signed but it was not\");\n}END_TEST\n\n#endif /* UA_ENABLE_ENCRYPTION */\n\nSTART_TEST(SecureChannel_sendAsymmetricOPNMessage_sentDataIsValid) {\n    UA_OpenSecureChannelResponse dummyResponse;\n    createDummyResponse(&dummyResponse);\n\n    /* Enable encryption for the SecureChannel */\n#ifdef UA_ENABLE_ENCRYPTION\n    testChannel.securityMode = UA_MESSAGESECURITYMODE_SIGNANDENCRYPT;\n#else\n    testChannel.securityMode = UA_MESSAGESECURITYMODE_NONE;\n#endif\n\n    UA_UInt32 requestId = UA_UInt32_random();\n\n    UA_StatusCode retval =\n        UA_SecureChannel_sendAsymmetricOPNMessage(&testChannel, requestId, &dummyResponse,\n                                                  &UA_TYPES[UA_TYPES_OPENSECURECHANNELRESPONSE]);\n    ck_assert_msg(retval == UA_STATUSCODE_GOOD, \"Expected function to succeed\");\n\n    size_t offset = 0;\n    UA_TcpMessageHeader header;\n    UA_TcpMessageHeader_decodeBinary(&sentData, &offset, &header);\n    UA_UInt32 secureChannelId;\n    UA_UInt32_decodeBinary(&sentData, &offset, &secureChannelId);\n\n    UA_AsymmetricAlgorithmSecurityHeader asymSecurityHeader;\n    UA_AsymmetricAlgorithmSecurityHeader_decodeBinary(&sentData, &offset, &asymSecurityHeader);\n\n    ck_assert_msg(UA_ByteString_equal(&testChannel.securityPolicy->policyUri,\n                                      &asymSecurityHeader.securityPolicyUri),\n                  \"Expected securityPolicyUri to be equal to the one used by the secureChannel\");\n\n#ifdef UA_ENABLE_ENCRYPTION\n    ck_assert_msg(UA_ByteString_equal(&dummyCertificate, &asymSecurityHeader.senderCertificate),\n                  \"Expected the certificate to be equal to the one used  by the secureChannel\");\n\n    UA_ByteString thumbPrint = {20, testChannel.remoteCertificateThumbprint};\n    ck_assert_msg(UA_ByteString_equal(&thumbPrint,\n                                      &asymSecurityHeader.receiverCertificateThumbprint),\n                  \"Expected receiverCertificateThumbprint to be equal to the one set \"\n                  \"in the secureChannel\");\n\n    /* Dummy encryption */\n    for(size_t i = offset; i < header.messageSize; ++i) {\n        sentData.data[i] = (UA_Byte)((sentData.data[i] - 1) % (UA_BYTE_MAX + 1));\n    }\n#endif\n\n    UA_SequenceHeader sequenceHeader;\n    UA_SequenceHeader_decodeBinary(&sentData, &offset, &sequenceHeader);\n    ck_assert_msg(sequenceHeader.requestId == requestId, \"Expected requestId to be %i but was %i\",\n                  requestId,\n                  sequenceHeader.requestId);\n\n    UA_NodeId requestTypeId;\n    UA_NodeId_decodeBinary(&sentData, &offset, &requestTypeId);\n    ck_assert_msg(UA_NodeId_equal(&UA_TYPES[UA_TYPES_OPENSECURECHANNELRESPONSE].binaryEncodingId, &requestTypeId), \"Expected nodeIds to be equal\");\n\n    UA_OpenSecureChannelResponse sentResponse;\n    UA_OpenSecureChannelResponse_decodeBinary(&sentData, &offset, &sentResponse);\n\n    ck_assert_msg(memcmp(&sentResponse, &dummyResponse, sizeof(UA_OpenSecureChannelResponse)) == 0,\n                  \"Expected the sent response to be equal to the one supplied to the send function\");\n\n#ifdef UA_ENABLE_ENCRYPTION\n    UA_Byte paddingByte = sentData.data[offset];\n    size_t paddingSize = (size_t)paddingByte;\n\n    for(size_t i = 0; i <= paddingSize; ++i) {\n        ck_assert_msg(sentData.data[offset + i] == paddingByte,\n                      \"Expected padding byte %i to be %i but got value %i\",\n                      (int)i, paddingByte, sentData.data[offset + i]);\n    }\n\n    ck_assert_msg(sentData.data[offset + paddingSize + 1] == '*', \"Expected first byte of signature\");\n#endif\n\n    UA_AsymmetricAlgorithmSecurityHeader_clear(&asymSecurityHeader);\n    UA_SequenceHeader_clear(&sequenceHeader);\n    UA_OpenSecureChannelResponse_clear(&sentResponse);\n} END_TEST\n\n#ifdef UA_ENABLE_ENCRYPTION\n\nSTART_TEST(Securechannel_sendAsymmetricOPNMessage_extraPaddingPresentWhenKeyLargerThan2048Bits) {\n    keySizes.asym_rmt_enc_key_size = 4096;\n    keySizes.asym_rmt_blocksize = 4096;\n    keySizes.asym_rmt_ptext_blocksize = 4096;\n\n    UA_OpenSecureChannelResponse dummyResponse;\n    createDummyResponse(&dummyResponse);\n\n    testChannel.securityMode = UA_MESSAGESECURITYMODE_SIGNANDENCRYPT;\n    UA_UInt32 requestId = UA_UInt32_random();\n\n    UA_StatusCode retval =\n        UA_SecureChannel_sendAsymmetricOPNMessage(&testChannel, requestId, &dummyResponse,\n                                                  &UA_TYPES[UA_TYPES_OPENSECURECHANNELRESPONSE]);\n    ck_assert_msg(retval == UA_STATUSCODE_GOOD, \"Expected function to succeed\");\n\n    size_t offset = 0;\n    UA_TcpMessageHeader header;\n    UA_TcpMessageHeader_decodeBinary(&sentData, &offset, &header);\n    UA_UInt32 secureChannelId;\n    UA_UInt32_decodeBinary(&sentData, &offset, &secureChannelId);\n\n    UA_AsymmetricAlgorithmSecurityHeader asymSecurityHeader;\n    UA_AsymmetricAlgorithmSecurityHeader_decodeBinary(&sentData, &offset, &asymSecurityHeader);\n    ck_assert_msg(UA_ByteString_equal(&dummyCertificate, &asymSecurityHeader.senderCertificate),\n                  \"Expected the certificate to be equal to the one used  by the secureChannel\");\n    ck_assert_msg(UA_ByteString_equal(&testChannel.securityPolicy->policyUri,\n                                      &asymSecurityHeader.securityPolicyUri),\n                  \"Expected securityPolicyUri to be equal to the one used by the secureChannel\");\n    UA_ByteString thumbPrint = {20, testChannel.remoteCertificateThumbprint};\n    ck_assert_msg(UA_ByteString_equal(&thumbPrint,\n                                      &asymSecurityHeader.receiverCertificateThumbprint),\n                  \"Expected receiverCertificateThumbprint to be equal to the one set \"\n                  \"in the secureChannel\");\n\n    for(size_t i = offset; i < header.messageSize; ++i) {\n        sentData.data[i] = (UA_Byte)((sentData.data[i] - 1) % (UA_BYTE_MAX + 1));\n    }\n\n    UA_SequenceHeader sequenceHeader;\n    UA_SequenceHeader_decodeBinary(&sentData, &offset, &sequenceHeader);\n    ck_assert_msg(sequenceHeader.requestId == requestId, \"Expected requestId to be %i but was %i\",\n                  requestId, sequenceHeader.requestId);\n\n    UA_NodeId requestTypeId;\n    UA_NodeId_decodeBinary(&sentData, &offset, &requestTypeId);\n    ck_assert_msg(UA_NodeId_equal(&UA_TYPES[UA_TYPES_OPENSECURECHANNELRESPONSE].binaryEncodingId, &requestTypeId), \"Expected nodeIds to be equal\");\n\n    UA_OpenSecureChannelResponse sentResponse;\n    UA_OpenSecureChannelResponse_decodeBinary(&sentData, &offset, &sentResponse);\n\n    ck_assert_msg(memcmp(&sentResponse, &dummyResponse, sizeof(UA_OpenSecureChannelResponse)) == 0,\n                  \"Expected the sent response to be equal to the one supplied to the send function\");\n\n    UA_Byte paddingByte = sentData.data[offset];\n    UA_Byte extraPaddingByte = sentData.data[sentData.length - keySizes.asym_lcl_sig_size - 1];\n    size_t paddingSize = (size_t)paddingByte;\n    paddingSize |= extraPaddingByte << 8;\n\n    for(size_t i = 0; i <= paddingSize; ++i) {\n        ck_assert_msg(sentData.data[offset + i] == paddingByte,\n                      \"Expected padding byte %i to be %i but got value %i\",\n                      (int)i, paddingByte, sentData.data[offset + i]);\n    }\n\n    ck_assert_msg(sentData.data[offset + paddingSize + 1] == extraPaddingByte,\n                  \"Expected extra padding byte to be %i but got %i\",\n                  extraPaddingByte, sentData.data[offset + paddingSize + 1]);\n    ck_assert_msg(sentData.data[offset + paddingSize + 2] == '*',\n                  \"Expected first byte 42 of signature but got %i\",\n                  sentData.data[offset + paddingSize + 2]);\n\n    UA_AsymmetricAlgorithmSecurityHeader_clear(&asymSecurityHeader);\n    UA_SequenceHeader_clear(&sequenceHeader);\n    UA_OpenSecureChannelResponse_clear(&sentResponse);\n}END_TEST\n\n#endif /* UA_ENABLE_ENCRYPTION */\n\nSTART_TEST(SecureChannel_sendSymmetricMessage) {\n    // initialize dummy message\n    UA_ReadRequest dummyMessage;\n    UA_ReadRequest_init(&dummyMessage);\n    UA_DataType dummyType = UA_TYPES[UA_TYPES_READREQUEST];\n\n    UA_StatusCode retval = UA_SecureChannel_sendSymmetricMessage(&testChannel, 42, UA_MESSAGETYPE_MSG,\n                                                                 &dummyMessage, &dummyType);\n    ck_assert_msg(retval == UA_STATUSCODE_GOOD, \"Expected success\");\n    // TODO: expand test\n}\nEND_TEST\n\nSTART_TEST(SecureChannel_sendSymmetricMessage_modeNone) {\n    // initialize dummy message\n    UA_ReadRequest dummyMessage;\n    UA_ReadRequest_init(&dummyMessage);\n    UA_DataType dummyType = UA_TYPES[UA_TYPES_READREQUEST];\n\n    testChannel.securityMode = UA_MESSAGESECURITYMODE_NONE;\n\n    UA_StatusCode retval = UA_SecureChannel_sendSymmetricMessage(&testChannel, 42, UA_MESSAGETYPE_MSG,\n                                                                 &dummyMessage, &dummyType);\n    ck_assert_msg(retval == UA_STATUSCODE_GOOD, \"Expected success\");\n    ck_assert_msg(!fCalled.sym_sign, \"Expected message to not have been signed\");\n    ck_assert_msg(!fCalled.sym_enc, \"Expected message to not have been encrypted\");\n} END_TEST\n\n#ifdef UA_ENABLE_ENCRYPTION\n\nSTART_TEST(SecureChannel_sendSymmetricMessage_modeSign) {\n    // initialize dummy message\n    UA_ReadRequest dummyMessage;\n    UA_ReadRequest_init(&dummyMessage);\n    UA_DataType dummyType = UA_TYPES[UA_TYPES_READREQUEST];\n\n    testChannel.securityMode = UA_MESSAGESECURITYMODE_SIGN;\n\n    UA_StatusCode retval = UA_SecureChannel_sendSymmetricMessage(&testChannel, 42, UA_MESSAGETYPE_MSG,\n                                                                 &dummyMessage, &dummyType);\n    ck_assert_msg(retval == UA_STATUSCODE_GOOD, \"Expected success\");\n    ck_assert_msg(fCalled.sym_sign, \"Expected message to have been signed\");\n    ck_assert_msg(!fCalled.sym_enc, \"Expected message to not have been encrypted\");\n} END_TEST\n\nSTART_TEST(SecureChannel_sendSymmetricMessage_modeSignAndEncrypt)\n{\n    // initialize dummy message\n    UA_ReadRequest dummyMessage;\n    UA_ReadRequest_init(&dummyMessage);\n    UA_DataType dummyType = UA_TYPES[UA_TYPES_READREQUEST];\n\n    testChannel.securityMode = UA_MESSAGESECURITYMODE_SIGNANDENCRYPT;\n\n    UA_StatusCode retval = UA_SecureChannel_sendSymmetricMessage(&testChannel, 42, UA_MESSAGETYPE_MSG,\n                                                                 &dummyMessage, &dummyType);\n    ck_assert_msg(retval == UA_STATUSCODE_GOOD, \"Expected success\");\n    ck_assert_msg(fCalled.sym_sign, \"Expected message to have been signed\");\n    ck_assert_msg(fCalled.sym_enc, \"Expected message to have been encrypted\");\n} END_TEST\n\n#endif /* UA_ENABLE_ENCRYPTION */\n\nSTART_TEST(SecureChannel_sendSymmetricMessage_invalidParameters) {\n    // initialize dummy message\n    UA_ReadRequest dummyMessage;\n    UA_ReadRequest_init(&dummyMessage);\n    UA_DataType dummyType = UA_TYPES[UA_TYPES_READREQUEST];\n\n    UA_StatusCode retval = UA_SecureChannel_sendSymmetricMessage(NULL, 42, UA_MESSAGETYPE_MSG,\n                                                                 &dummyMessage, &dummyType);\n    ck_assert_msg(retval != UA_STATUSCODE_GOOD, \"Expected failure\");\n\n    retval = UA_SecureChannel_sendSymmetricMessage(&testChannel, 42,\n                                                   UA_MESSAGETYPE_HEL, &dummyMessage, &dummyType);\n    ck_assert_msg(retval != UA_STATUSCODE_GOOD, \"Expected failure\");\n\n    retval = UA_SecureChannel_sendSymmetricMessage(&testChannel, 42,\n                                                   UA_MESSAGETYPE_ACK, &dummyMessage, &dummyType);\n    ck_assert_msg(retval != UA_STATUSCODE_GOOD, \"Expected failure\");\n\n    retval = UA_SecureChannel_sendSymmetricMessage(&testChannel, 42,\n                                                   UA_MESSAGETYPE_ERR, &dummyMessage, &dummyType);\n    ck_assert_msg(retval != UA_STATUSCODE_GOOD, \"Expected failure\");\n\n    retval = UA_SecureChannel_sendSymmetricMessage(&testChannel, 42,\n                                                   UA_MESSAGETYPE_OPN, &dummyMessage, &dummyType);\n    ck_assert_msg(retval != UA_STATUSCODE_GOOD, \"Expected failure\");\n\n    retval = UA_SecureChannel_sendSymmetricMessage(&testChannel, 42,\n                                                   UA_MESSAGETYPE_MSG, NULL, &dummyType);\n    ck_assert_msg(retval != UA_STATUSCODE_GOOD, \"Expected failure\");\n\n    retval = UA_SecureChannel_sendSymmetricMessage(&testChannel, 42,\n                                                   UA_MESSAGETYPE_MSG, &dummyMessage, NULL);\n    ck_assert_msg(retval != UA_STATUSCODE_GOOD, \"Expected failure\");\n} END_TEST\n\nstatic UA_StatusCode\nprocess_callback(void *application, UA_SecureChannel *channel,\n                 UA_MessageType messageType, UA_UInt32 requestId,\n                 UA_ByteString *message) {\n    ck_assert_ptr_ne(message, NULL);\n    ck_assert_ptr_ne(application, NULL);\n    if(message == NULL || application == NULL)\n        return UA_STATUSCODE_BADINTERNALERROR;\n    ck_assert_uint_ne(message->length, 0);\n    ck_assert_ptr_ne(message->data, NULL);\n    int *chunks_processed = (int *)application;\n    ++*chunks_processed;\n    return UA_STATUSCODE_GOOD;\n}\n\nSTART_TEST(SecureChannel_assemblePartialChunks) {\n    int chunks_processed = 0;\n    UA_ByteString buffer = UA_BYTESTRING_NULL;\n\n    buffer.data = (UA_Byte *)\"HELF \\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\"\n                             \"\\x10\\x00\\x00\\x00@\\x00\\x00\\x00\\x00\\x00\\x00\\xff\\xff\\xff\\xff\";\n    buffer.length = 32;\n\n    UA_StatusCode retval = UA_SecureChannel_processBuffer(&testChannel, &chunks_processed, process_callback, &buffer);\n    ck_assert_msg(retval == UA_STATUSCODE_GOOD, \"Expected success\");\n    ck_assert_int_eq(chunks_processed, 1);\n\n    buffer.length = 16;\n\n    UA_SecureChannel_processBuffer(&testChannel, &chunks_processed, process_callback, &buffer);\n    ck_assert_msg(retval == UA_STATUSCODE_GOOD, \"Expected success\");\n    ck_assert_int_eq(chunks_processed, 1);\n\n    buffer.data = &buffer.data[16];\n    UA_SecureChannel_processBuffer(&testChannel, &chunks_processed, process_callback, &buffer);\n    ck_assert_msg(retval == UA_STATUSCODE_GOOD, \"Expected success\");\n    ck_assert_int_eq(chunks_processed, 2);\n\n    buffer.data = (UA_Byte *)\"HELF \\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\"\n                             \"\\x10\\x00\\x00\\x00@\\x00\\x00\\x00\\x00\\x00\\x00\\xff\\xff\\xff\\xff\"\n                             \"HELF \\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\"\n                             \"\\x10\\x00\\x00\\x00@\\x00\\x00\\x00\\x00\\x00\\x00\\xff\\xff\\xff\\xff\"\n                             \"HELF \\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\"\n                             \"\\x10\\x00\\x00\\x00@\\x00\\x00\\x00\\x00\\x00\\x00\\xff\\xff\\xff\\xff\";\n    buffer.length = 48;\n\n    UA_SecureChannel_processBuffer(&testChannel, &chunks_processed, process_callback, &buffer);\n    ck_assert_msg(retval == UA_STATUSCODE_GOOD, \"Expected success\");\n    ck_assert_int_eq(chunks_processed, 3);\n\n    buffer.data = &buffer.data[48];\n    buffer.length = 32;\n\n    UA_SecureChannel_processBuffer(&testChannel, &chunks_processed, process_callback, &buffer);\n    ck_assert_msg(retval == UA_STATUSCODE_GOOD, \"Expected success\");\n    ck_assert_int_eq(chunks_processed, 4);\n\n    buffer.data = &buffer.data[32];\n    buffer.length = 16;\n    UA_SecureChannel_processBuffer(&testChannel, &chunks_processed, process_callback, &buffer);\n    ck_assert_msg(retval == UA_STATUSCODE_GOOD, \"Expected success\");\n    ck_assert_int_eq(chunks_processed, 5);\n} END_TEST\n\n\nstatic Suite *\ntestSuite_SecureChannel(void) {\n    Suite *s = suite_create(\"SecureChannel\");\n\n    TCase *tc_initAndDelete = tcase_create(\"Initialize and delete Securechannel\");\n    tcase_add_checked_fixture(tc_initAndDelete, setup_funcs_called, teardown_funcs_called);\n    tcase_add_checked_fixture(tc_initAndDelete, setup_key_sizes, teardown_key_sizes);\n    tcase_add_test(tc_initAndDelete, SecureChannel_initAndDelete);\n    suite_add_tcase(s, tc_initAndDelete);\n\n    TCase *tc_sendAsymmetricOPNMessage = tcase_create(\"Test sendAsymmetricOPNMessage function\");\n    tcase_add_checked_fixture(tc_sendAsymmetricOPNMessage, setup_funcs_called, teardown_funcs_called);\n    tcase_add_checked_fixture(tc_sendAsymmetricOPNMessage, setup_key_sizes, teardown_key_sizes);\n    tcase_add_checked_fixture(tc_sendAsymmetricOPNMessage, setup_secureChannel, teardown_secureChannel);\n    tcase_add_test(tc_sendAsymmetricOPNMessage, SecureChannel_sendAsymmetricOPNMessage_withoutConnection);\n    tcase_add_test(tc_sendAsymmetricOPNMessage, SecureChannel_sendAsymmetricOPNMessage_invalidParameters);\n    tcase_add_test(tc_sendAsymmetricOPNMessage, SecureChannel_sendAsymmetricOPNMessage_SecurityModeInvalid);\n    tcase_add_test(tc_sendAsymmetricOPNMessage, SecureChannel_sendAsymmetricOPNMessage_SecurityModeNone);\n    tcase_add_test(tc_sendAsymmetricOPNMessage, SecureChannel_sendAsymmetricOPNMessage_sentDataIsValid);\n#ifdef UA_ENABLE_ENCRYPTION\n    tcase_add_test(tc_sendAsymmetricOPNMessage, SecureChannel_sendAsymmetricOPNMessage_SecurityModeSign);\n    tcase_add_test(tc_sendAsymmetricOPNMessage, SecureChannel_sendAsymmetricOPNMessage_SecurityModeSignAndEncrypt);\n    tcase_add_test(tc_sendAsymmetricOPNMessage,\n                   Securechannel_sendAsymmetricOPNMessage_extraPaddingPresentWhenKeyLargerThan2048Bits);\n#endif\n    suite_add_tcase(s, tc_sendAsymmetricOPNMessage);\n\n    TCase *tc_sendSymmetricMessage = tcase_create(\"Test sendSymmetricMessage function\");\n    tcase_add_checked_fixture(tc_sendSymmetricMessage, setup_funcs_called, teardown_funcs_called);\n    tcase_add_checked_fixture(tc_sendSymmetricMessage, setup_key_sizes, teardown_key_sizes);\n    tcase_add_checked_fixture(tc_sendSymmetricMessage, setup_secureChannel, teardown_secureChannel);\n    tcase_add_test(tc_sendSymmetricMessage, SecureChannel_sendSymmetricMessage);\n    tcase_add_test(tc_sendSymmetricMessage, SecureChannel_sendSymmetricMessage_invalidParameters);\n    tcase_add_test(tc_sendSymmetricMessage, SecureChannel_sendSymmetricMessage_modeNone);\n#ifdef UA_ENABLE_ENCRYPTION\n    tcase_add_test(tc_sendSymmetricMessage, SecureChannel_sendSymmetricMessage_modeSign);\n    tcase_add_test(tc_sendSymmetricMessage, SecureChannel_sendSymmetricMessage_modeSignAndEncrypt);\n#endif\n    suite_add_tcase(s, tc_sendSymmetricMessage);\n\n    TCase *tc_processBuffer = tcase_create(\"Test chunk assembly\");\n    tcase_add_checked_fixture(tc_processBuffer, setup_funcs_called, teardown_funcs_called);\n    tcase_add_checked_fixture(tc_processBuffer, setup_key_sizes, teardown_key_sizes);\n    tcase_add_checked_fixture(tc_processBuffer, setup_secureChannel, teardown_secureChannel);\n    tcase_add_test(tc_processBuffer, SecureChannel_assemblePartialChunks);\n    suite_add_tcase(s, tc_processBuffer);\n\n    return s;\n}\n\nint\nmain(void) {\n    Suite *s = testSuite_SecureChannel();\n    SRunner *sr = srunner_create(s);\n    srunner_set_fork_status(sr, CK_NOFORK);\n    srunner_run_all(sr, CK_NORMAL);\n    int number_failed = srunner_ntests_failed(sr);\n    srunner_free(sr);\n    return (number_failed == 0) ? EXIT_SUCCESS : EXIT_FAILURE;\n}\n"], "fixing_code": ["/* This work is licensed under a Creative Commons CCZero 1.0 Universal License.\n * See http://creativecommons.org/publicdomain/zero/1.0/ for more information.\n *\n *    Copyright 2017 (c) Fraunhofer IOSB (Author: Julius Pfrommer)\n *    Copyright 2017 (c) Julian Grothoff\n *    Copyright 2017-2018 (c) Mark Giraud, Fraunhofer IOSB\n *    Copyright 2017 (c) Stefan Profanter, fortiss GmbH\n *    Copyright 2017 (c) Thomas Stalder, Blue Time Concept SA\n *    Copyright 2018 (c) Daniel Feist, Precitec GmbH & Co. KG\n *    Copyright 2018 (c) Fabian Arndt, Root-Core\n *    Copyright 2019 (c) Kalycito Infotech Private Limited\n *    Copyright 2017-2020 (c) HMS Industrial Networks AB (Author: Jonas Green)\n *    Copyright 2020 (c) Wind River Systems, Inc.\n */\n\n#include <open62541/client.h>\n#include <open62541/client_config_default.h>\n#include <open62541/network_tcp.h>\n#ifdef UA_ENABLE_WEBSOCKET_SERVER\n#include <open62541/network_ws.h>\n#endif\n#include <open62541/plugin/accesscontrol_default.h>\n#include <open62541/plugin/nodestore_default.h>\n#include <open62541/plugin/log_stdout.h>\n#include <open62541/plugin/pki_default.h>\n#include <open62541/plugin/securitypolicy_default.h>\n#include <open62541/server_config_default.h>\n\n/* Struct initialization works across ANSI C/C99/C++ if it is done when the\n * variable is first declared. Assigning values to existing structs is\n * heterogeneous across the three. */\nstatic UA_INLINE UA_UInt32Range\nUA_UINT32RANGE(UA_UInt32 min, UA_UInt32 max) {\n    UA_UInt32Range range = {min, max};\n    return range;\n}\n\nstatic UA_INLINE UA_DurationRange\nUA_DURATIONRANGE(UA_Duration min, UA_Duration max) {\n    UA_DurationRange range = {min, max};\n    return range;\n}\n\nUA_Server *\nUA_Server_new() {\n    UA_ServerConfig config;\n    memset(&config, 0, sizeof(UA_ServerConfig));\n    /* Set a default logger and NodeStore for the initialization */\n    config.logger = UA_Log_Stdout_;\n    if(UA_STATUSCODE_GOOD != UA_Nodestore_HashMap(&config.nodestore)) {\n        return NULL;\n    }\n\n    return UA_Server_newWithConfig(&config);\n}\n\n/*******************************/\n/* Default Connection Settings */\n/*******************************/\n\nconst UA_ConnectionConfig UA_ConnectionConfig_default = {\n    0,       /* .protocolVersion */\n    2 << 16, /* .sendBufferSize, 64k per chunk */\n    2 << 16, /* .recvBufferSize, 64k per chunk */\n    2 << 29, /* .localMaxMessageSize, 512 MB */\n    2 << 29, /* .remoteMaxMessageSize, 512 MB */\n    2 << 14, /* .localMaxChunkCount, 16k */\n    2 << 14  /* .remoteMaxChunkCount, 16k */\n};\n\n/***************************/\n/* Default Server Settings */\n/***************************/\n\n#define MANUFACTURER_NAME \"open62541\"\n#define PRODUCT_NAME \"open62541 OPC UA Server\"\n#define PRODUCT_URI \"http://open62541.org\"\n#define APPLICATION_NAME \"open62541-based OPC UA Application\"\n#define APPLICATION_URI \"urn:unconfigured:application\"\n#define APPLICATION_URI_SERVER \"urn:open62541.server.application\"\n\n#define STRINGIFY(arg) #arg\n#define VERSION(MAJOR, MINOR, PATCH, LABEL) \\\n    STRINGIFY(MAJOR) \".\" STRINGIFY(MINOR) \".\" STRINGIFY(PATCH) LABEL\n\nstatic UA_StatusCode\ncreateEndpoint(UA_ServerConfig *conf, UA_EndpointDescription *endpoint,\n               const UA_SecurityPolicy *securityPolicy,\n               UA_MessageSecurityMode securityMode) {\n    UA_EndpointDescription_init(endpoint);\n\n    endpoint->securityMode = securityMode;\n    UA_String_copy(&securityPolicy->policyUri, &endpoint->securityPolicyUri);\n    endpoint->transportProfileUri =\n        UA_STRING_ALLOC(\"http://opcfoundation.org/UA-Profile/Transport/uatcp-uasc-uabinary\");\n\n    /* Add security level value for the corresponding message security mode */\n    endpoint->securityLevel = (UA_Byte) securityMode;\n\n    /* Enable all login mechanisms from the access control plugin  */\n    UA_StatusCode retval = UA_Array_copy(conf->accessControl.userTokenPolicies,\n                                         conf->accessControl.userTokenPoliciesSize,\n                                         (void **)&endpoint->userIdentityTokens,\n                                         &UA_TYPES[UA_TYPES_USERTOKENPOLICY]);\n    if(retval != UA_STATUSCODE_GOOD){\n        UA_String_clear(&endpoint->securityPolicyUri);\n        UA_String_clear(&endpoint->transportProfileUri);\n        return retval;\n    }\n    endpoint->userIdentityTokensSize = conf->accessControl.userTokenPoliciesSize;\n\n    UA_String_copy(&securityPolicy->localCertificate, &endpoint->serverCertificate);\n    UA_ApplicationDescription_copy(&conf->applicationDescription, &endpoint->server);\n\n    return UA_STATUSCODE_GOOD;\n}\n\nstatic const size_t usernamePasswordsSize = 2;\nstatic UA_UsernamePasswordLogin usernamePasswords[2] = {\n    {UA_STRING_STATIC(\"user1\"), UA_STRING_STATIC(\"password\")},\n    {UA_STRING_STATIC(\"user2\"), UA_STRING_STATIC(\"password1\")}};\n\nstatic UA_StatusCode\nsetDefaultConfig(UA_ServerConfig *conf) {\n    if(!conf)\n        return UA_STATUSCODE_BADINVALIDARGUMENT;\n\n    if(conf->nodestore.context == NULL)\n        UA_Nodestore_HashMap(&conf->nodestore);\n\n    /* --> Start setting the default static config <-- */\n    /* Allow user to set his own logger */\n    if(!conf->logger.log)\n        conf->logger = UA_Log_Stdout_;\n\n    conf->shutdownDelay = 0.0;\n\n    /* Server Description */\n    UA_BuildInfo_clear(&conf->buildInfo);\n    conf->buildInfo.productUri = UA_STRING_ALLOC(PRODUCT_URI);\n    conf->buildInfo.manufacturerName = UA_STRING_ALLOC(MANUFACTURER_NAME);\n    conf->buildInfo.productName = UA_STRING_ALLOC(PRODUCT_NAME);\n    conf->buildInfo.softwareVersion =\n        UA_STRING_ALLOC(VERSION(UA_OPEN62541_VER_MAJOR, UA_OPEN62541_VER_MINOR,\n                                UA_OPEN62541_VER_PATCH, UA_OPEN62541_VER_LABEL));\n#ifdef UA_PACK_DEBIAN\n    conf->buildInfo.buildNumber = UA_STRING_ALLOC(\"deb\");\n#else\n    conf->buildInfo.buildNumber = UA_STRING_ALLOC(__DATE__ \" \" __TIME__);\n#endif\n    conf->buildInfo.buildDate = UA_DateTime_now();\n\n    UA_ApplicationDescription_clear(&conf->applicationDescription);\n    conf->applicationDescription.applicationUri = UA_STRING_ALLOC(APPLICATION_URI_SERVER);\n    conf->applicationDescription.productUri = UA_STRING_ALLOC(PRODUCT_URI);\n    conf->applicationDescription.applicationName =\n        UA_LOCALIZEDTEXT_ALLOC(\"en\", APPLICATION_NAME);\n    conf->applicationDescription.applicationType = UA_APPLICATIONTYPE_SERVER;\n    /* conf->applicationDescription.gatewayServerUri = UA_STRING_NULL; */\n    /* conf->applicationDescription.discoveryProfileUri = UA_STRING_NULL; */\n    /* conf->applicationDescription.discoveryUrlsSize = 0; */\n    /* conf->applicationDescription.discoveryUrls = NULL; */\n\n#ifdef UA_ENABLE_DISCOVERY_MULTICAST\n    UA_MdnsDiscoveryConfiguration_clear(&conf->mdnsConfig);\n    conf->mdnsInterfaceIP = UA_STRING_NULL;\n# if !defined(UA_HAS_GETIFADDR)\n    conf->mdnsIpAddressList = NULL;\n    conf->mdnsIpAddressListSize = 0;\n# endif\n#endif\n\n    /* Custom DataTypes */\n    /* conf->customDataTypesSize = 0; */\n    /* conf->customDataTypes = NULL; */\n\n    /* Networking */\n    /* conf->networkLayersSize = 0; */\n    /* conf->networkLayers = NULL; */\n    /* conf->customHostname = UA_STRING_NULL; */\n\n    /* Endpoints */\n    /* conf->endpoints = {0, NULL}; */\n\n    /* Certificate Verification that accepts every certificate. Can be\n     * overwritten when the policy is specialized. */\n    UA_CertificateVerification_AcceptAll(&conf->certificateVerification);\n\n    /* * Global Node Lifecycle * */\n    /* conf->nodeLifecycle.constructor = NULL; */\n    /* conf->nodeLifecycle.destructor = NULL; */\n    /* conf->nodeLifecycle.createOptionalChild = NULL; */\n    /* conf->nodeLifecycle.generateChildNodeId = NULL; */\n\n    /* Limits for SecureChannels */\n    conf->maxSecureChannels = 40;\n    conf->maxSecurityTokenLifetime = 10 * 60 * 1000; /* 10 minutes */\n\n    /* Limits for Sessions */\n    conf->maxSessions = 100;\n    conf->maxSessionTimeout = 60.0 * 60.0 * 1000.0; /* 1h */\n\n#ifdef UA_ENABLE_SUBSCRIPTIONS\n    /* Limits for Subscriptions */\n    conf->publishingIntervalLimits = UA_DURATIONRANGE(100.0, 3600.0 * 1000.0);\n    conf->lifeTimeCountLimits = UA_UINT32RANGE(3, 15000);\n    conf->keepAliveCountLimits = UA_UINT32RANGE(1, 100);\n    conf->maxNotificationsPerPublish = 1000;\n    conf->enableRetransmissionQueue = true;\n    conf->maxRetransmissionQueueSize = 0; /* unlimited */\n# ifdef UA_ENABLE_SUBSCRIPTIONS_EVENTS\n    conf->maxEventsPerNode = 0; /* unlimited */\n# endif\n\n    /* Limits for MonitoredItems */\n    conf->samplingIntervalLimits = UA_DURATIONRANGE(50.0, 24.0 * 3600.0 * 1000.0);\n    conf->queueSizeLimits = UA_UINT32RANGE(1, 100);\n#endif\n\n#ifdef UA_ENABLE_DISCOVERY\n    conf->discoveryCleanupTimeout = 60 * 60;\n#endif\n\n#ifdef UA_ENABLE_HISTORIZING\n    /* conf->accessHistoryDataCapability = UA_FALSE; */\n    /* conf->maxReturnDataValues = 0; */\n\n    /* conf->accessHistoryEventsCapability = UA_FALSE; */\n    /* conf->maxReturnEventValues = 0; */\n\n    /* conf->insertDataCapability = UA_FALSE; */\n    /* conf->insertEventCapability = UA_FALSE; */\n    /* conf->insertAnnotationsCapability = UA_FALSE; */\n\n    /* conf->replaceDataCapability = UA_FALSE; */\n    /* conf->replaceEventCapability = UA_FALSE; */\n\n    /* conf->updateDataCapability = UA_FALSE; */\n    /* conf->updateEventCapability = UA_FALSE; */\n\n    /* conf->deleteRawCapability = UA_FALSE; */\n    /* conf->deleteEventCapability = UA_FALSE; */\n    /* conf->deleteAtTimeDataCapability = UA_FALSE; */\n#endif\n\n#if UA_MULTITHREADING >= 100\n    conf->maxAsyncOperationQueueSize = 0;\n    conf->asyncOperationTimeout = 120000; /* Async Operation Timeout in ms (2 minutes) */\n#endif\n\n    /* --> Finish setting the default static config <-- */\n\n    return UA_STATUSCODE_GOOD;\n}\n\nUA_EXPORT UA_StatusCode\nUA_ServerConfig_setBasics(UA_ServerConfig* conf) {\n    UA_StatusCode res = setDefaultConfig(conf);\n    UA_LOG_WARNING(&conf->logger, UA_LOGCATEGORY_USERLAND,\n                   \"AcceptAll Certificate Verification. \"\n                   \"Any remote certificate will be accepted.\");\n    return res;\n}\n\nstatic UA_StatusCode\naddDefaultNetworkLayers(UA_ServerConfig *conf, UA_UInt16 portNumber,\n                        UA_UInt32 sendBufferSize, UA_UInt32 recvBufferSize) {\n    return UA_ServerConfig_addNetworkLayerTCP(conf, portNumber, sendBufferSize, recvBufferSize);\n}\n\n#ifdef UA_ENABLE_WEBSOCKET_SERVER\nUA_EXPORT UA_StatusCode\nUA_ServerConfig_addNetworkLayerWS(UA_ServerConfig *conf, UA_UInt16 portNumber,\n                                   UA_UInt32 sendBufferSize, UA_UInt32 recvBufferSize, const UA_ByteString* certificate, const UA_ByteString* privateKey) {\n    /* Add a network layer */\n    UA_ServerNetworkLayer *tmp = (UA_ServerNetworkLayer *)\n        UA_realloc(conf->networkLayers,\n                   sizeof(UA_ServerNetworkLayer) * (1 + conf->networkLayersSize));\n    if(!tmp)\n        return UA_STATUSCODE_BADOUTOFMEMORY;\n    conf->networkLayers = tmp;\n\n    UA_ConnectionConfig config = UA_ConnectionConfig_default;\n    if(sendBufferSize > 0)\n        config.sendBufferSize = sendBufferSize;\n    if(recvBufferSize > 0)\n        config.recvBufferSize = recvBufferSize;\n\n    conf->networkLayers[conf->networkLayersSize] =\n        UA_ServerNetworkLayerWS(config, portNumber, certificate, privateKey);\n    if(!conf->networkLayers[conf->networkLayersSize].handle)\n        return UA_STATUSCODE_BADOUTOFMEMORY;\n    conf->networkLayersSize++;\n\n    return UA_STATUSCODE_GOOD;\n}\n#endif\n\nUA_EXPORT UA_StatusCode\nUA_ServerConfig_addNetworkLayerTCP(UA_ServerConfig *conf, UA_UInt16 portNumber,\n                                   UA_UInt32 sendBufferSize, UA_UInt32 recvBufferSize) {\n    /* Add a network layer */\n    UA_ServerNetworkLayer *tmp = (UA_ServerNetworkLayer *)\n        UA_realloc(conf->networkLayers,\n                   sizeof(UA_ServerNetworkLayer) * (1 + conf->networkLayersSize));\n    if(!tmp)\n        return UA_STATUSCODE_BADOUTOFMEMORY;\n    conf->networkLayers = tmp;\n\n    UA_ConnectionConfig config = UA_ConnectionConfig_default;\n    if (sendBufferSize > 0)\n        config.sendBufferSize = sendBufferSize;\n    if (recvBufferSize > 0)\n        config.recvBufferSize = recvBufferSize;\n\n    conf->networkLayers[conf->networkLayersSize] =\n        UA_ServerNetworkLayerTCP(config, portNumber, 0);\n    if (!conf->networkLayers[conf->networkLayersSize].handle)\n        return UA_STATUSCODE_BADOUTOFMEMORY;\n    conf->networkLayersSize++;\n\n    return UA_STATUSCODE_GOOD;\n}\n\nUA_EXPORT UA_StatusCode\nUA_ServerConfig_addSecurityPolicyNone(UA_ServerConfig *config, \n                                      const UA_ByteString *certificate) {\n    /* Allocate the SecurityPolicies */\n    UA_SecurityPolicy *tmp = (UA_SecurityPolicy *)\n        UA_realloc(config->securityPolicies,\n                   sizeof(UA_SecurityPolicy) * (1 + config->securityPoliciesSize));\n    if(!tmp)\n        return UA_STATUSCODE_BADOUTOFMEMORY;\n    config->securityPolicies = tmp;\n    \n    /* Populate the SecurityPolicies */\n    UA_ByteString localCertificate = UA_BYTESTRING_NULL;\n    if(certificate)\n        localCertificate = *certificate;\n    UA_StatusCode retval =\n        UA_SecurityPolicy_None(&config->securityPolicies[config->securityPoliciesSize],\n                               localCertificate, &config->logger);\n    if(retval != UA_STATUSCODE_GOOD) {\n        if(config->securityPoliciesSize == 0) {\n            UA_free(config->securityPolicies);\n            config->securityPolicies = NULL;\n        }\n        return retval;\n    }\n\n    config->securityPoliciesSize++;\n    return UA_STATUSCODE_GOOD;\n}\n\nUA_EXPORT UA_StatusCode\nUA_ServerConfig_addEndpoint(UA_ServerConfig *config, const UA_String securityPolicyUri, \n                            UA_MessageSecurityMode securityMode) {\n    /* Allocate the endpoint */\n    UA_EndpointDescription *tmp = (UA_EndpointDescription *)\n        UA_realloc(config->endpoints,\n                   sizeof(UA_EndpointDescription) * (1 + config->endpointsSize));\n    if(!tmp) {\n        return UA_STATUSCODE_BADOUTOFMEMORY;\n    }\n    config->endpoints = tmp;\n\n    /* Lookup the security policy */\n    const UA_SecurityPolicy *policy = NULL;\n    for (size_t i = 0; i < config->securityPoliciesSize; ++i) {\n        if (UA_String_equal(&securityPolicyUri, &config->securityPolicies[i].policyUri)) {\n            policy = &config->securityPolicies[i];\n            break;\n        }\n    }\n    if (!policy)\n        return UA_STATUSCODE_BADINVALIDARGUMENT;\n\n    /* Populate the endpoint */\n    UA_StatusCode retval =\n        createEndpoint(config, &config->endpoints[config->endpointsSize],\n                       policy, securityMode);\n    if(retval != UA_STATUSCODE_GOOD)\n        return retval;\n    config->endpointsSize++;\n\n    return UA_STATUSCODE_GOOD;\n}\n\nUA_EXPORT UA_StatusCode\nUA_ServerConfig_addAllEndpoints(UA_ServerConfig *config) {\n    /* Allocate the endpoints */\n    UA_EndpointDescription * tmp = (UA_EndpointDescription *)\n        UA_realloc(config->endpoints,\n                   sizeof(UA_EndpointDescription) *\n                   (2 * config->securityPoliciesSize + config->endpointsSize));\n    if(!tmp) {\n        return UA_STATUSCODE_BADOUTOFMEMORY;\n    }\n    config->endpoints = tmp;\n\n    /* Populate the endpoints */\n    for(size_t i = 0; i < config->securityPoliciesSize; ++i) {\n        if(UA_String_equal(&UA_SECURITY_POLICY_NONE_URI, &config->securityPolicies[i].policyUri)) {\n            UA_StatusCode retval =\n                createEndpoint(config, &config->endpoints[config->endpointsSize],\n                               &config->securityPolicies[i], UA_MESSAGESECURITYMODE_NONE);\n            if(retval != UA_STATUSCODE_GOOD)\n                return retval;\n            config->endpointsSize++;\n        } else {\n            UA_StatusCode retval =\n                createEndpoint(config, &config->endpoints[config->endpointsSize],\n                               &config->securityPolicies[i], UA_MESSAGESECURITYMODE_SIGN);\n            if(retval != UA_STATUSCODE_GOOD)\n                return retval;\n            config->endpointsSize++;\n\n            retval = createEndpoint(config, &config->endpoints[config->endpointsSize],\n                                    &config->securityPolicies[i],\n                                    UA_MESSAGESECURITYMODE_SIGNANDENCRYPT);\n            if(retval != UA_STATUSCODE_GOOD)\n                return retval;\n            config->endpointsSize++;\n        }\n    }\n\n    return UA_STATUSCODE_GOOD;\n}\n\nUA_EXPORT UA_StatusCode\nUA_ServerConfig_setMinimalCustomBuffer(UA_ServerConfig *config, UA_UInt16 portNumber,\n                                       const UA_ByteString *certificate,\n                                       UA_UInt32 sendBufferSize,\n                                       UA_UInt32 recvBufferSize) {\n    if(!config)\n        return UA_STATUSCODE_BADINVALIDARGUMENT;\n\n    UA_StatusCode retval = setDefaultConfig(config);\n    if(retval != UA_STATUSCODE_GOOD) {\n        UA_ServerConfig_clean(config);\n        return retval;\n    }\n\n    retval = addDefaultNetworkLayers(config, portNumber, sendBufferSize, recvBufferSize);\n    if(retval != UA_STATUSCODE_GOOD) {\n        UA_ServerConfig_clean(config);\n        return retval;\n    }\n\n    /* Allocate the SecurityPolicies */\n    retval = UA_ServerConfig_addSecurityPolicyNone(config, certificate);\n    if(retval != UA_STATUSCODE_GOOD) {\n        UA_ServerConfig_clean(config);\n        return retval;\n    }\n\n    /* Initialize the Access Control plugin */\n    retval = UA_AccessControl_default(config, true,\n                &config->securityPolicies[config->securityPoliciesSize-1].policyUri,\n                usernamePasswordsSize, usernamePasswords);\n    if(retval != UA_STATUSCODE_GOOD) {\n        UA_ServerConfig_clean(config);\n        return retval;\n    }\n\n    /* Allocate the endpoint */\n    retval = UA_ServerConfig_addEndpoint(config, UA_SECURITY_POLICY_NONE_URI,\n                                         UA_MESSAGESECURITYMODE_NONE);\n    if(retval != UA_STATUSCODE_GOOD) {\n        UA_ServerConfig_clean(config);\n        return retval;\n    }\n\n    UA_LOG_WARNING(&config->logger, UA_LOGCATEGORY_USERLAND,\n                   \"AcceptAll Certificate Verification. \"\n                   \"Any remote certificate will be accepted.\");\n\n    return UA_STATUSCODE_GOOD;\n}\n\n#ifdef UA_ENABLE_ENCRYPTION\n\nUA_EXPORT UA_StatusCode\nUA_ServerConfig_addSecurityPolicyBasic128Rsa15(UA_ServerConfig *config, \n                                               const UA_ByteString *certificate,\n                                               const UA_ByteString *privateKey) {\n    /* Allocate the SecurityPolicies */\n    UA_SecurityPolicy *tmp = (UA_SecurityPolicy *)\n        UA_realloc(config->securityPolicies,\n                   sizeof(UA_SecurityPolicy) * (1 + config->securityPoliciesSize));\n    if(!tmp)\n        return UA_STATUSCODE_BADOUTOFMEMORY;\n    config->securityPolicies = tmp;\n    \n    /* Populate the SecurityPolicies */\n    UA_ByteString localCertificate = UA_BYTESTRING_NULL;\n    UA_ByteString localPrivateKey  = UA_BYTESTRING_NULL;\n    if(certificate)\n        localCertificate = *certificate;\n    if(privateKey)\n       localPrivateKey = *privateKey;\n    UA_StatusCode retval =\n        UA_SecurityPolicy_Basic128Rsa15(&config->securityPolicies[config->securityPoliciesSize],\n                                        localCertificate, localPrivateKey, &config->logger);\n    if(retval != UA_STATUSCODE_GOOD) {\n        if(config->securityPoliciesSize == 0) {\n            UA_free(config->securityPolicies);\n            config->securityPolicies = NULL;\n        }\n        return retval;\n    }\n\n    config->securityPoliciesSize++;\n    return UA_STATUSCODE_GOOD;\n}\n\nUA_EXPORT UA_StatusCode\nUA_ServerConfig_addSecurityPolicyBasic256(UA_ServerConfig *config, \n                                          const UA_ByteString *certificate,\n                                          const UA_ByteString *privateKey) {\n    /* Allocate the SecurityPolicies */\n    UA_SecurityPolicy *tmp = (UA_SecurityPolicy *)\n        UA_realloc(config->securityPolicies,\n                   sizeof(UA_SecurityPolicy) * (1 + config->securityPoliciesSize));\n    if(!tmp)\n        return UA_STATUSCODE_BADOUTOFMEMORY;\n    config->securityPolicies = tmp;\n    \n    /* Populate the SecurityPolicies */\n    UA_ByteString localCertificate = UA_BYTESTRING_NULL;\n    UA_ByteString localPrivateKey  = UA_BYTESTRING_NULL;\n    if(certificate)\n        localCertificate = *certificate;\n    if(privateKey)\n       localPrivateKey = *privateKey;\n    UA_StatusCode retval =\n        UA_SecurityPolicy_Basic256(&config->securityPolicies[config->securityPoliciesSize],\n                                   localCertificate, localPrivateKey, &config->logger);\n    if(retval != UA_STATUSCODE_GOOD) {\n        if(config->securityPoliciesSize == 0) {\n            UA_free(config->securityPolicies);\n            config->securityPolicies = NULL;\n        }\n        return retval;\n    }\n\n    config->securityPoliciesSize++;\n    return UA_STATUSCODE_GOOD;\n}\n\nUA_EXPORT UA_StatusCode\nUA_ServerConfig_addSecurityPolicyBasic256Sha256(UA_ServerConfig *config, \n                                                const UA_ByteString *certificate,\n                                                const UA_ByteString *privateKey) {\n    /* Allocate the SecurityPolicies */\n    UA_SecurityPolicy *tmp = (UA_SecurityPolicy *)\n        UA_realloc(config->securityPolicies,\n                   sizeof(UA_SecurityPolicy) * (1 + config->securityPoliciesSize));\n    if(!tmp)\n        return UA_STATUSCODE_BADOUTOFMEMORY;\n    config->securityPolicies = tmp;\n    \n    /* Populate the SecurityPolicies */\n    UA_ByteString localCertificate = UA_BYTESTRING_NULL;\n    UA_ByteString localPrivateKey  = UA_BYTESTRING_NULL;\n    if(certificate)\n        localCertificate = *certificate;\n    if(privateKey)\n       localPrivateKey = *privateKey;\n    UA_StatusCode retval =\n        UA_SecurityPolicy_Basic256Sha256(&config->securityPolicies[config->securityPoliciesSize],\n                                         localCertificate, localPrivateKey, &config->logger);\n    if(retval != UA_STATUSCODE_GOOD) {\n        if(config->securityPoliciesSize == 0) {\n            UA_free(config->securityPolicies);\n            config->securityPolicies = NULL;\n        }\n        return retval;\n    }\n\n    config->securityPoliciesSize++;\n    return UA_STATUSCODE_GOOD;\n}\n\nUA_EXPORT UA_StatusCode\nUA_ServerConfig_addSecurityPolicyAes128Sha256RsaOaep(UA_ServerConfig *config, \n                                                const UA_ByteString *certificate,\n                                                const UA_ByteString *privateKey) {\n    /* Allocate the SecurityPolicies */\n    UA_SecurityPolicy *tmp = (UA_SecurityPolicy *)\n        UA_realloc(config->securityPolicies,\n                   sizeof(UA_SecurityPolicy) * (1 + config->securityPoliciesSize));\n    if(!tmp)\n        return UA_STATUSCODE_BADOUTOFMEMORY;\n    config->securityPolicies = tmp;\n    \n    /* Populate the SecurityPolicies */\n    UA_ByteString localCertificate = UA_BYTESTRING_NULL;\n    UA_ByteString localPrivateKey  = UA_BYTESTRING_NULL;\n    if(certificate)\n        localCertificate = *certificate;\n    if(privateKey)\n       localPrivateKey = *privateKey;\n    UA_StatusCode retval =\n        UA_SecurityPolicy_Aes128Sha256RsaOaep(&config->securityPolicies[config->securityPoliciesSize],\n                                              localCertificate, localPrivateKey, &config->logger);\n    if(retval != UA_STATUSCODE_GOOD) {\n        if(config->securityPoliciesSize == 0) {\n            UA_free(config->securityPolicies);\n            config->securityPolicies = NULL;\n        }\n        return retval;\n    }\n\n    config->securityPoliciesSize++;\n    return UA_STATUSCODE_GOOD;\n}\n\n/* Always returns UA_STATUSCODE_GOOD. Logs a warning if policies could not be added. */\nUA_EXPORT UA_StatusCode\nUA_ServerConfig_addAllSecurityPolicies(UA_ServerConfig *config,\n                                       const UA_ByteString *certificate,\n                                       const UA_ByteString *privateKey) {\n    /* Populate the SecurityPolicies */\n    UA_ByteString localCertificate = UA_BYTESTRING_NULL;\n    UA_ByteString localPrivateKey  = UA_BYTESTRING_NULL;\n    if(certificate)\n        localCertificate = *certificate;\n    if(privateKey)\n       localPrivateKey = *privateKey;\n\n    UA_StatusCode retval = UA_ServerConfig_addSecurityPolicyNone(config, &localCertificate);\n    if(retval != UA_STATUSCODE_GOOD) {\n        UA_LOG_WARNING(&config->logger, UA_LOGCATEGORY_USERLAND,\n                       \"Could not add SecurityPolicy#None with error code %s\",\n                       UA_StatusCode_name(retval));\n    }\n\n    retval = UA_ServerConfig_addSecurityPolicyBasic128Rsa15(config, &localCertificate, &localPrivateKey);\n    if(retval != UA_STATUSCODE_GOOD) {\n        UA_LOG_WARNING(&config->logger, UA_LOGCATEGORY_USERLAND,\n                       \"Could not add SecurityPolicy#Basic128Rsa15 with error code %s\",\n                       UA_StatusCode_name(retval));\n    }\n\n    retval = UA_ServerConfig_addSecurityPolicyBasic256(config, &localCertificate, &localPrivateKey);\n    if(retval != UA_STATUSCODE_GOOD) {\n        UA_LOG_WARNING(&config->logger, UA_LOGCATEGORY_USERLAND,\n                       \"Could not add SecurityPolicy#Basic256 with error code %s\",\n                       UA_StatusCode_name(retval));\n    }\n\n    retval = UA_ServerConfig_addSecurityPolicyBasic256Sha256(config, &localCertificate, &localPrivateKey);\n    if(retval != UA_STATUSCODE_GOOD) {\n        UA_LOG_WARNING(&config->logger, UA_LOGCATEGORY_USERLAND,\n                       \"Could not add SecurityPolicy#Basic256Sha256 with error code %s\",\n                       UA_StatusCode_name(retval));\n    }\n\n    retval = UA_ServerConfig_addSecurityPolicyAes128Sha256RsaOaep(config, &localCertificate, &localPrivateKey);\n    if(retval != UA_STATUSCODE_GOOD) {\n        UA_LOG_WARNING(&config->logger, UA_LOGCATEGORY_USERLAND,\n                       \"Could not add SecurityPolicy#Aes128Sha256RsaOaep with error code %s\",\n                       UA_StatusCode_name(retval));\n    }\n\n    return UA_STATUSCODE_GOOD;\n}\n\nUA_EXPORT UA_StatusCode\nUA_ServerConfig_setDefaultWithSecurityPolicies(UA_ServerConfig *conf,\n                                               UA_UInt16 portNumber,\n                                               const UA_ByteString *certificate,\n                                               const UA_ByteString *privateKey,\n                                               const UA_ByteString *trustList,\n                                               size_t trustListSize,\n                                               const UA_ByteString *issuerList,\n                                               size_t issuerListSize,\n                                               const UA_ByteString *revocationList,\n                                               size_t revocationListSize) {\n    UA_StatusCode retval = setDefaultConfig(conf);\n    if(retval != UA_STATUSCODE_GOOD) {\n        UA_ServerConfig_clean(conf);\n        return retval;\n    }\n\n    retval = UA_CertificateVerification_Trustlist(&conf->certificateVerification,\n                                                  trustList, trustListSize,\n                                                  issuerList, issuerListSize,\n                                                  revocationList, revocationListSize);\n    if (retval != UA_STATUSCODE_GOOD)\n        return retval;\n\n    retval = addDefaultNetworkLayers(conf, portNumber, 0, 0);\n    if(retval != UA_STATUSCODE_GOOD) {\n        UA_ServerConfig_clean(conf);\n        return retval;\n    }\n\n    retval = UA_ServerConfig_addAllSecurityPolicies(conf, certificate, privateKey);\n    if(retval != UA_STATUSCODE_GOOD) {\n        UA_ServerConfig_clean(conf);\n        return retval;\n    }\n\n    retval = UA_AccessControl_default(conf, true,\n                &conf->securityPolicies[conf->securityPoliciesSize-1].policyUri,\n                usernamePasswordsSize, usernamePasswords);\n    if(retval != UA_STATUSCODE_GOOD) {\n        UA_ServerConfig_clean(conf);\n        return retval;\n    }\n\n    retval = UA_ServerConfig_addAllEndpoints(conf);\n    if(retval != UA_STATUSCODE_GOOD) {\n        UA_ServerConfig_clean(conf);\n        return retval;\n    }\n\n    return UA_STATUSCODE_GOOD;\n}\n\n#endif\n\n/***************************/\n/* Default Client Settings */\n/***************************/\n\nUA_Client * UA_Client_new() {\n    UA_ClientConfig config;\n    memset(&config, 0, sizeof(UA_ClientConfig));\n    config.logger.log = UA_Log_Stdout_log;\n    config.logger.context = NULL;\n    config.logger.clear = UA_Log_Stdout_clear;\n    return UA_Client_newWithConfig(&config);\n}\n\nUA_StatusCode\nUA_ClientConfig_setDefault(UA_ClientConfig *config) {\n    config->timeout = 5000;\n    config->secureChannelLifeTime = 10 * 60 * 1000; /* 10 minutes */\n\n    if(!config->logger.log) {\n       config->logger.log = UA_Log_Stdout_log;\n       config->logger.context = NULL;\n       config->logger.clear = UA_Log_Stdout_clear;\n    }\n\n    config->localConnectionConfig = UA_ConnectionConfig_default;\n\n    /* Certificate Verification that accepts every certificate. Can be\n     * overwritten when the policy is specialized. */\n    UA_CertificateVerification_AcceptAll(&config->certificateVerification);\n    UA_LOG_WARNING(&config->logger, UA_LOGCATEGORY_USERLAND,\n                   \"AcceptAll Certificate Verification. \"\n                   \"Any remote certificate will be accepted.\");\n\n    /* With encryption enabled, the applicationUri needs to match the URI from\n     * the certificate */\n    config->clientDescription.applicationUri = UA_STRING_ALLOC(APPLICATION_URI);\n    config->clientDescription.applicationType = UA_APPLICATIONTYPE_CLIENT;\n\n    if(config->securityPoliciesSize > 0) {\n        UA_LOG_ERROR(&config->logger, UA_LOGCATEGORY_NETWORK,\n                     \"Could not initialize a config that already has SecurityPolicies\");\n        return UA_STATUSCODE_BADINTERNALERROR;\n    }\n\n    config->securityPolicies = (UA_SecurityPolicy*)UA_malloc(sizeof(UA_SecurityPolicy));\n    if(!config->securityPolicies)\n        return UA_STATUSCODE_BADOUTOFMEMORY;\n    UA_StatusCode retval = UA_SecurityPolicy_None(config->securityPolicies,\n                                                  UA_BYTESTRING_NULL, &config->logger);\n    if(retval != UA_STATUSCODE_GOOD) {\n        UA_free(config->securityPolicies);\n        config->securityPolicies = NULL;\n        return retval;\n    }\n    config->securityPoliciesSize = 1;\n\n    config->initConnectionFunc = UA_ClientConnectionTCP_init; /* for async client */\n    config->pollConnectionFunc = UA_ClientConnectionTCP_poll; /* for async connection */\n\n    config->customDataTypes = NULL;\n    config->stateCallback = NULL;\n    config->connectivityCheckInterval = 0;\n\n    config->requestedSessionTimeout = 1200000; /* requestedSessionTimeout */\n\n    config->inactivityCallback = NULL;\n    config->clientContext = NULL;\n\n#ifdef UA_ENABLE_SUBSCRIPTIONS\n    config->outStandingPublishRequests = 10;\n    config->subscriptionInactivityCallback = NULL;\n#endif\n\n    return UA_STATUSCODE_GOOD;\n}\n\n#ifdef UA_ENABLE_ENCRYPTION\nUA_StatusCode\nUA_ClientConfig_setDefaultEncryption(UA_ClientConfig *config,\n                                     UA_ByteString localCertificate, UA_ByteString privateKey,\n                                     const UA_ByteString *trustList, size_t trustListSize,\n                                     const UA_ByteString *revocationList, size_t revocationListSize) {\n    UA_StatusCode retval = UA_ClientConfig_setDefault(config);\n    if(retval != UA_STATUSCODE_GOOD)\n        return retval;\n\n    retval = UA_CertificateVerification_Trustlist(&config->certificateVerification,\n                                                  trustList, trustListSize,\n                                                  NULL, 0,\n                                                  revocationList, revocationListSize);\n    if(retval != UA_STATUSCODE_GOOD)\n        return retval;\n\n    /* Populate SecurityPolicies */\n    UA_SecurityPolicy *sp = (UA_SecurityPolicy*)\n        UA_realloc(config->securityPolicies, sizeof(UA_SecurityPolicy) * 5);\n    if(!sp)\n        return UA_STATUSCODE_BADOUTOFMEMORY;\n    config->securityPolicies = sp;\n                  \n    retval = UA_SecurityPolicy_Basic128Rsa15(&config->securityPolicies[config->securityPoliciesSize],\n                                             localCertificate, privateKey, &config->logger);\n    if(retval == UA_STATUSCODE_GOOD) {\n        ++config->securityPoliciesSize;\n    } else {\n        UA_LOG_WARNING(&config->logger, UA_LOGCATEGORY_USERLAND,\n                       \"Could not add SecurityPolicy#Basic128Rsa15 with error code %s\",\n                       UA_StatusCode_name(retval));\n    }\n\n    retval = UA_SecurityPolicy_Basic256(&config->securityPolicies[config->securityPoliciesSize],\n                                        localCertificate, privateKey, &config->logger);\n    if(retval == UA_STATUSCODE_GOOD) {\n        ++config->securityPoliciesSize;\n    } else {\n        UA_LOG_WARNING(&config->logger, UA_LOGCATEGORY_USERLAND,\n                       \"Could not add SecurityPolicy#Basic256 with error code %s\",\n                       UA_StatusCode_name(retval));\n    }\n\n    retval = UA_SecurityPolicy_Basic256Sha256(&config->securityPolicies[config->securityPoliciesSize],\n                                              localCertificate, privateKey, &config->logger);\n    if(retval == UA_STATUSCODE_GOOD) {\n        ++config->securityPoliciesSize;\n    } else {\n        UA_LOG_WARNING(&config->logger, UA_LOGCATEGORY_USERLAND,\n                       \"Could not add SecurityPolicy#Basic256Sha256 with error code %s\",\n                       UA_StatusCode_name(retval));\n    }\n\n    retval = UA_SecurityPolicy_Aes128Sha256RsaOaep(&config->securityPolicies[config->securityPoliciesSize],\n                                                   localCertificate, privateKey, &config->logger);\n    if(retval == UA_STATUSCODE_GOOD) {\n        ++config->securityPoliciesSize;\n    } else {\n        UA_LOG_WARNING(&config->logger, UA_LOGCATEGORY_USERLAND,\n                       \"Could not add SecurityPolicy#Aes128Sha256RsaOaep with error code %s\",\n                       UA_StatusCode_name(retval));\n    }\n\n    if(config->securityPoliciesSize == 0) {\n        UA_free(config->securityPolicies);\n        config->securityPolicies = NULL;\n    }\n\n    return UA_STATUSCODE_GOOD;\n}\n#endif\n", "/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n#include <open62541/transport_generated.h>\n#include <open62541/transport_generated_encoding_binary.h>\n#include <open62541/transport_generated_handling.h>\n#include <open62541/types_generated.h>\n#include <open62541/types_generated_encoding_binary.h>\n#include <open62541/server_config_default.h>\n\n#include \"ua_securechannel.h\"\n#include <ua_types_encoding_binary.h>\n\n#include \"check.h\"\n#include \"testing_networklayers.h\"\n#include \"testing_policy.h\"\n\n#define UA_BYTESTRING_STATIC(s) {sizeof(s)-1, (UA_Byte*)(s)}\n\n// Some default testing sizes. Can be overwritten in testing functions.\n#define DEFAULT_SYM_ENCRYPTION_BLOCK_SIZE 2\n#define DEFAULT_SYM_SIGNING_KEY_LENGTH 3\n#define DEFAULT_SYM_ENCRYPTION_KEY_LENGTH 5\n#define DEFAULT_ASYM_REMOTE_SIGNATURE_SIZE 7\n#define DEFAULT_ASYM_LOCAL_SIGNATURE_SIZE 11\n#define DEFAULT_SYM_SIGNATURE_SIZE 13\n#define DEFAULT_ASYM_REMOTE_PLAINTEXT_BLOCKSIZE 256\n#define DEFAULT_ASYM_REMOTE_BLOCKSIZE 256\n\nUA_SecureChannel testChannel;\nUA_ByteString dummyCertificate =\n    UA_BYTESTRING_STATIC(\"DUMMY CERTIFICATE DUMMY CERTIFICATE DUMMY CERTIFICATE\");\nUA_SecurityPolicy dummyPolicy;\nUA_Connection testingConnection;\nUA_ByteString sentData;\n\n\nstatic funcs_called fCalled;\nstatic key_sizes keySizes;\n\nstatic void\nsetup_secureChannel(void) {\n    TestingPolicy(&dummyPolicy, dummyCertificate, &fCalled, &keySizes);\n    UA_SecureChannel_init(&testChannel, &UA_ConnectionConfig_default);\n    UA_SecureChannel_setSecurityPolicy(&testChannel, &dummyPolicy, &dummyCertificate);\n\n    testingConnection =\n        createDummyConnection(UA_ConnectionConfig_default.sendBufferSize, &sentData);\n    UA_Connection_attachSecureChannel(&testingConnection, &testChannel);\n    testChannel.connection = &testingConnection;\n\n    testChannel.state = UA_SECURECHANNELSTATE_OPEN;\n}\n\nstatic void\nteardown_secureChannel(void) {\n    UA_SecureChannel_close(&testChannel);\n    dummyPolicy.clear(&dummyPolicy);\n    testingConnection.close(&testingConnection);\n}\n\nstatic void\nsetup_funcs_called(void) {\n    memset(&fCalled, 0, sizeof(struct funcs_called));\n}\n\nstatic void\nteardown_funcs_called(void) {\n    memset(&fCalled, 0, sizeof(struct funcs_called));\n}\n\nstatic void\nsetup_key_sizes(void) {\n    memset(&keySizes, 0, sizeof(struct key_sizes));\n\n    keySizes.sym_sig_keyLen = DEFAULT_SYM_SIGNING_KEY_LENGTH;\n    keySizes.sym_enc_blockSize = DEFAULT_SYM_ENCRYPTION_BLOCK_SIZE;\n    keySizes.sym_enc_keyLen = DEFAULT_SYM_ENCRYPTION_KEY_LENGTH;\n    keySizes.sym_sig_size = DEFAULT_SYM_SIGNATURE_SIZE;\n\n    keySizes.asym_lcl_sig_size = DEFAULT_ASYM_LOCAL_SIGNATURE_SIZE;\n    keySizes.asym_rmt_sig_size = DEFAULT_ASYM_REMOTE_SIGNATURE_SIZE;\n\n    keySizes.asym_rmt_ptext_blocksize = DEFAULT_ASYM_REMOTE_PLAINTEXT_BLOCKSIZE;\n    keySizes.asym_rmt_blocksize = DEFAULT_ASYM_REMOTE_BLOCKSIZE;\n    keySizes.asym_rmt_enc_key_size = 2048;\n    keySizes.asym_lcl_enc_key_size = 1024;\n}\n\nstatic void\nteardown_key_sizes(void) {\n    memset(&keySizes, 0, sizeof(struct key_sizes));\n}\n\nSTART_TEST(SecureChannel_initAndDelete) {\n    TestingPolicy(&dummyPolicy, dummyCertificate, &fCalled, &keySizes);\n    UA_StatusCode retval;\n\n    UA_SecureChannel channel;\n    UA_SecureChannel_init(&channel, &UA_ConnectionConfig_default);\n    retval = UA_SecureChannel_setSecurityPolicy(&channel, &dummyPolicy, &dummyCertificate);\n\n    ck_assert_msg(retval == UA_STATUSCODE_GOOD, \"Expected StatusCode to be good\");\n    ck_assert_msg(channel.state == UA_SECURECHANNELSTATE_FRESH, \"Expected state to be new/fresh\");\n    ck_assert_msg(fCalled.newContext, \"Expected newContext to have been called\");\n    ck_assert_msg(fCalled.makeCertificateThumbprint,\n                  \"Expected makeCertificateThumbprint to have been called\");\n    ck_assert_msg(channel.securityPolicy == &dummyPolicy, \"SecurityPolicy not set correctly\");\n\n    UA_SecureChannel_close(&channel);\n    ck_assert_msg(fCalled.deleteContext, \"Expected deleteContext to have been called\");\n\n    dummyPolicy.clear(&dummyPolicy);\n}END_TEST\n\nstatic void\ncreateDummyResponse(UA_OpenSecureChannelResponse *response) {\n    UA_OpenSecureChannelResponse_init(response);\n    memset(response, 0, sizeof(UA_OpenSecureChannelResponse));\n}\n\nSTART_TEST(SecureChannel_sendAsymmetricOPNMessage_withoutConnection) {\n    UA_OpenSecureChannelResponse dummyResponse;\n    createDummyResponse(&dummyResponse);\n    testChannel.securityMode = UA_MESSAGESECURITYMODE_NONE;\n\n    // Remove connection to provoke error\n    UA_Connection_detachSecureChannel(testChannel.connection);\n    testChannel.connection = NULL;\n\n    UA_StatusCode retval =\n        UA_SecureChannel_sendAsymmetricOPNMessage(&testChannel, 42, &dummyResponse,\n                                                  &UA_TYPES[UA_TYPES_OPENSECURECHANNELRESPONSE]);\n\n    ck_assert_msg(retval != UA_STATUSCODE_GOOD, \"Expected failure without a connection\");\n}END_TEST\n\nSTART_TEST(SecureChannel_sendAsymmetricOPNMessage_invalidParameters) {\n    UA_OpenSecureChannelResponse dummyResponse;\n    createDummyResponse(&dummyResponse);\n\n    UA_StatusCode retval =\n        UA_SecureChannel_sendAsymmetricOPNMessage(&testChannel, 42, NULL,\n                                                  &UA_TYPES[UA_TYPES_OPENSECURECHANNELRESPONSE]);\n    ck_assert_msg(retval != UA_STATUSCODE_GOOD, \"Expected failure\");\n\n    retval = UA_SecureChannel_sendAsymmetricOPNMessage(&testChannel, 42, &dummyResponse, NULL);\n    ck_assert_msg(retval != UA_STATUSCODE_GOOD, \"Expected failure\");\n\n}END_TEST\n\nSTART_TEST(SecureChannel_sendAsymmetricOPNMessage_SecurityModeInvalid) {\n    // Configure our channel correctly for OPN messages and setup dummy message\n    UA_OpenSecureChannelResponse dummyResponse;\n    createDummyResponse(&dummyResponse);\n\n    testChannel.securityMode = UA_MESSAGESECURITYMODE_INVALID;\n\n    UA_StatusCode retval =\n        UA_SecureChannel_sendAsymmetricOPNMessage(&testChannel, 42, &dummyResponse,\n                                                  &UA_TYPES[UA_TYPES_OPENSECURECHANNELRESPONSE]);\n    ck_assert_msg(retval == UA_STATUSCODE_BADSECURITYMODEREJECTED,\n                  \"Expected SecurityMode rejected error\");\n}\nEND_TEST\n\nSTART_TEST(SecureChannel_sendAsymmetricOPNMessage_SecurityModeNone) {\n    // Configure our channel correctly for OPN messages and setup dummy message\n    UA_OpenSecureChannelResponse dummyResponse;\n    createDummyResponse(&dummyResponse);\n    testChannel.securityMode = UA_MESSAGESECURITYMODE_NONE;\n\n    UA_StatusCode retval =\n        UA_SecureChannel_sendAsymmetricOPNMessage(&testChannel, 42, &dummyResponse,\n                                                  &UA_TYPES[UA_TYPES_OPENSECURECHANNELRESPONSE]);\n    ck_assert_msg(retval == UA_STATUSCODE_GOOD, \"Expected function to succeed\");\n    ck_assert_msg(!fCalled.asym_enc, \"Message encryption was called but should not have been\");\n    ck_assert_msg(!fCalled.asym_sign, \"Message signing was called but should not have been\");\n}\nEND_TEST\n\n#ifdef UA_ENABLE_ENCRYPTION\n\nSTART_TEST(SecureChannel_sendAsymmetricOPNMessage_SecurityModeSign) {\n    // Configure our channel correctly for OPN messages and setup dummy message\n    UA_OpenSecureChannelResponse dummyResponse;\n    createDummyResponse(&dummyResponse);\n    testChannel.securityMode = UA_MESSAGESECURITYMODE_SIGN;\n\n    UA_StatusCode retval =\n        UA_SecureChannel_sendAsymmetricOPNMessage(&testChannel, 42, &dummyResponse,\n                                                  &UA_TYPES[UA_TYPES_OPENSECURECHANNELRESPONSE]);\n    ck_assert_msg(retval == UA_STATUSCODE_GOOD, \"Expected function to succeed\");\n    ck_assert_msg(fCalled.asym_enc, \"Expected message to have been encrypted but it was not\");\n    ck_assert_msg(fCalled.asym_sign, \"Expected message to have been signed but it was not\");\n}END_TEST\n\nSTART_TEST(SecureChannel_sendAsymmetricOPNMessage_SecurityModeSignAndEncrypt) {\n    // Configure our channel correctly for OPN messages and setup dummy message\n    UA_OpenSecureChannelResponse dummyResponse;\n    createDummyResponse(&dummyResponse);\n\n    testChannel.securityMode = UA_MESSAGESECURITYMODE_SIGNANDENCRYPT;\n    UA_StatusCode retval =\n        UA_SecureChannel_sendAsymmetricOPNMessage(&testChannel, 42, &dummyResponse,\n                                                  &UA_TYPES[UA_TYPES_OPENSECURECHANNELRESPONSE]);\n    ck_assert_msg(retval == UA_STATUSCODE_GOOD, \"Expected function to succeed\");\n    ck_assert_msg(fCalled.asym_enc, \"Expected message to have been encrypted but it was not\");\n    ck_assert_msg(fCalled.asym_sign, \"Expected message to have been signed but it was not\");\n}END_TEST\n\n#endif /* UA_ENABLE_ENCRYPTION */\n\nSTART_TEST(SecureChannel_sendAsymmetricOPNMessage_sentDataIsValid) {\n    UA_OpenSecureChannelResponse dummyResponse;\n    createDummyResponse(&dummyResponse);\n\n    /* Enable encryption for the SecureChannel */\n#ifdef UA_ENABLE_ENCRYPTION\n    testChannel.securityMode = UA_MESSAGESECURITYMODE_SIGNANDENCRYPT;\n#else\n    testChannel.securityMode = UA_MESSAGESECURITYMODE_NONE;\n#endif\n\n    UA_UInt32 requestId = UA_UInt32_random();\n\n    UA_StatusCode retval =\n        UA_SecureChannel_sendAsymmetricOPNMessage(&testChannel, requestId, &dummyResponse,\n                                                  &UA_TYPES[UA_TYPES_OPENSECURECHANNELRESPONSE]);\n    ck_assert_msg(retval == UA_STATUSCODE_GOOD, \"Expected function to succeed\");\n\n    size_t offset = 0;\n    UA_TcpMessageHeader header;\n    UA_TcpMessageHeader_decodeBinary(&sentData, &offset, &header);\n    UA_UInt32 secureChannelId;\n    UA_UInt32_decodeBinary(&sentData, &offset, &secureChannelId);\n\n    UA_AsymmetricAlgorithmSecurityHeader asymSecurityHeader;\n    UA_AsymmetricAlgorithmSecurityHeader_decodeBinary(&sentData, &offset, &asymSecurityHeader);\n\n    ck_assert_msg(UA_ByteString_equal(&testChannel.securityPolicy->policyUri,\n                                      &asymSecurityHeader.securityPolicyUri),\n                  \"Expected securityPolicyUri to be equal to the one used by the secureChannel\");\n\n#ifdef UA_ENABLE_ENCRYPTION\n    ck_assert_msg(UA_ByteString_equal(&dummyCertificate, &asymSecurityHeader.senderCertificate),\n                  \"Expected the certificate to be equal to the one used  by the secureChannel\");\n\n    UA_ByteString thumbPrint = {20, testChannel.remoteCertificateThumbprint};\n    ck_assert_msg(UA_ByteString_equal(&thumbPrint,\n                                      &asymSecurityHeader.receiverCertificateThumbprint),\n                  \"Expected receiverCertificateThumbprint to be equal to the one set \"\n                  \"in the secureChannel\");\n\n    /* Dummy encryption */\n    for(size_t i = offset; i < header.messageSize; ++i) {\n        sentData.data[i] = (UA_Byte)((sentData.data[i] - 1) % (UA_BYTE_MAX + 1));\n    }\n#endif\n\n    UA_SequenceHeader sequenceHeader;\n    UA_SequenceHeader_decodeBinary(&sentData, &offset, &sequenceHeader);\n    ck_assert_msg(sequenceHeader.requestId == requestId, \"Expected requestId to be %i but was %i\",\n                  requestId,\n                  sequenceHeader.requestId);\n\n    UA_NodeId requestTypeId;\n    UA_NodeId_decodeBinary(&sentData, &offset, &requestTypeId);\n    ck_assert_msg(UA_NodeId_equal(&UA_TYPES[UA_TYPES_OPENSECURECHANNELRESPONSE].binaryEncodingId, &requestTypeId), \"Expected nodeIds to be equal\");\n\n    UA_OpenSecureChannelResponse sentResponse;\n    UA_OpenSecureChannelResponse_decodeBinary(&sentData, &offset, &sentResponse);\n\n    ck_assert_msg(memcmp(&sentResponse, &dummyResponse, sizeof(UA_OpenSecureChannelResponse)) == 0,\n                  \"Expected the sent response to be equal to the one supplied to the send function\");\n\n#ifdef UA_ENABLE_ENCRYPTION\n    UA_Byte paddingByte = sentData.data[offset];\n    size_t paddingSize = (size_t)paddingByte;\n\n    for(size_t i = 0; i <= paddingSize; ++i) {\n        ck_assert_msg(sentData.data[offset + i] == paddingByte,\n                      \"Expected padding byte %i to be %i but got value %i\",\n                      (int)i, paddingByte, sentData.data[offset + i]);\n    }\n\n    ck_assert_msg(sentData.data[offset + paddingSize + 1] == '*', \"Expected first byte of signature\");\n#endif\n\n    UA_AsymmetricAlgorithmSecurityHeader_clear(&asymSecurityHeader);\n    UA_SequenceHeader_clear(&sequenceHeader);\n    UA_OpenSecureChannelResponse_clear(&sentResponse);\n} END_TEST\n\n#ifdef UA_ENABLE_ENCRYPTION\n\nSTART_TEST(Securechannel_sendAsymmetricOPNMessage_extraPaddingPresentWhenKeyLargerThan2048Bits) {\n    keySizes.asym_rmt_enc_key_size = 4096;\n    keySizes.asym_rmt_blocksize = 4096;\n    keySizes.asym_rmt_ptext_blocksize = 4096;\n\n    UA_OpenSecureChannelResponse dummyResponse;\n    createDummyResponse(&dummyResponse);\n\n    testChannel.securityMode = UA_MESSAGESECURITYMODE_SIGNANDENCRYPT;\n    UA_UInt32 requestId = UA_UInt32_random();\n\n    UA_StatusCode retval =\n        UA_SecureChannel_sendAsymmetricOPNMessage(&testChannel, requestId, &dummyResponse,\n                                                  &UA_TYPES[UA_TYPES_OPENSECURECHANNELRESPONSE]);\n    ck_assert_msg(retval == UA_STATUSCODE_GOOD, \"Expected function to succeed\");\n\n    size_t offset = 0;\n    UA_TcpMessageHeader header;\n    UA_TcpMessageHeader_decodeBinary(&sentData, &offset, &header);\n    UA_UInt32 secureChannelId;\n    UA_UInt32_decodeBinary(&sentData, &offset, &secureChannelId);\n\n    UA_AsymmetricAlgorithmSecurityHeader asymSecurityHeader;\n    UA_AsymmetricAlgorithmSecurityHeader_decodeBinary(&sentData, &offset, &asymSecurityHeader);\n    ck_assert_msg(UA_ByteString_equal(&dummyCertificate, &asymSecurityHeader.senderCertificate),\n                  \"Expected the certificate to be equal to the one used  by the secureChannel\");\n    ck_assert_msg(UA_ByteString_equal(&testChannel.securityPolicy->policyUri,\n                                      &asymSecurityHeader.securityPolicyUri),\n                  \"Expected securityPolicyUri to be equal to the one used by the secureChannel\");\n    UA_ByteString thumbPrint = {20, testChannel.remoteCertificateThumbprint};\n    ck_assert_msg(UA_ByteString_equal(&thumbPrint,\n                                      &asymSecurityHeader.receiverCertificateThumbprint),\n                  \"Expected receiverCertificateThumbprint to be equal to the one set \"\n                  \"in the secureChannel\");\n\n    for(size_t i = offset; i < header.messageSize; ++i) {\n        sentData.data[i] = (UA_Byte)((sentData.data[i] - 1) % (UA_BYTE_MAX + 1));\n    }\n\n    UA_SequenceHeader sequenceHeader;\n    UA_SequenceHeader_decodeBinary(&sentData, &offset, &sequenceHeader);\n    ck_assert_msg(sequenceHeader.requestId == requestId, \"Expected requestId to be %i but was %i\",\n                  requestId, sequenceHeader.requestId);\n\n    UA_NodeId requestTypeId;\n    UA_NodeId_decodeBinary(&sentData, &offset, &requestTypeId);\n    ck_assert_msg(UA_NodeId_equal(&UA_TYPES[UA_TYPES_OPENSECURECHANNELRESPONSE].binaryEncodingId, &requestTypeId), \"Expected nodeIds to be equal\");\n\n    UA_OpenSecureChannelResponse sentResponse;\n    UA_OpenSecureChannelResponse_decodeBinary(&sentData, &offset, &sentResponse);\n\n    ck_assert_msg(memcmp(&sentResponse, &dummyResponse, sizeof(UA_OpenSecureChannelResponse)) == 0,\n                  \"Expected the sent response to be equal to the one supplied to the send function\");\n\n    UA_Byte paddingByte = sentData.data[offset];\n    UA_Byte extraPaddingByte = sentData.data[sentData.length - keySizes.asym_lcl_sig_size - 1];\n    size_t paddingSize = (size_t)paddingByte;\n    paddingSize |= extraPaddingByte << 8;\n\n    for(size_t i = 0; i <= paddingSize; ++i) {\n        ck_assert_msg(sentData.data[offset + i] == paddingByte,\n                      \"Expected padding byte %i to be %i but got value %i\",\n                      (int)i, paddingByte, sentData.data[offset + i]);\n    }\n\n    ck_assert_msg(sentData.data[offset + paddingSize + 1] == extraPaddingByte,\n                  \"Expected extra padding byte to be %i but got %i\",\n                  extraPaddingByte, sentData.data[offset + paddingSize + 1]);\n    ck_assert_msg(sentData.data[offset + paddingSize + 2] == '*',\n                  \"Expected first byte 42 of signature but got %i\",\n                  sentData.data[offset + paddingSize + 2]);\n\n    UA_AsymmetricAlgorithmSecurityHeader_clear(&asymSecurityHeader);\n    UA_SequenceHeader_clear(&sequenceHeader);\n    UA_OpenSecureChannelResponse_clear(&sentResponse);\n}END_TEST\n\n#endif /* UA_ENABLE_ENCRYPTION */\n\nSTART_TEST(SecureChannel_sendSymmetricMessage) {\n    // initialize dummy message\n    UA_ReadRequest dummyMessage;\n    UA_ReadRequest_init(&dummyMessage);\n    UA_DataType dummyType = UA_TYPES[UA_TYPES_READREQUEST];\n\n    UA_StatusCode retval = UA_SecureChannel_sendSymmetricMessage(&testChannel, 42, UA_MESSAGETYPE_MSG,\n                                                                 &dummyMessage, &dummyType);\n    ck_assert_msg(retval == UA_STATUSCODE_GOOD, \"Expected success\");\n    // TODO: expand test\n}\nEND_TEST\n\nSTART_TEST(SecureChannel_sendSymmetricMessage_modeNone) {\n    // initialize dummy message\n    UA_ReadRequest dummyMessage;\n    UA_ReadRequest_init(&dummyMessage);\n    UA_DataType dummyType = UA_TYPES[UA_TYPES_READREQUEST];\n\n    testChannel.securityMode = UA_MESSAGESECURITYMODE_NONE;\n\n    UA_StatusCode retval = UA_SecureChannel_sendSymmetricMessage(&testChannel, 42, UA_MESSAGETYPE_MSG,\n                                                                 &dummyMessage, &dummyType);\n    ck_assert_msg(retval == UA_STATUSCODE_GOOD, \"Expected success\");\n    ck_assert_msg(!fCalled.sym_sign, \"Expected message to not have been signed\");\n    ck_assert_msg(!fCalled.sym_enc, \"Expected message to not have been encrypted\");\n} END_TEST\n\n#ifdef UA_ENABLE_ENCRYPTION\n\nSTART_TEST(SecureChannel_sendSymmetricMessage_modeSign) {\n    // initialize dummy message\n    UA_ReadRequest dummyMessage;\n    UA_ReadRequest_init(&dummyMessage);\n    UA_DataType dummyType = UA_TYPES[UA_TYPES_READREQUEST];\n\n    testChannel.securityMode = UA_MESSAGESECURITYMODE_SIGN;\n\n    UA_StatusCode retval = UA_SecureChannel_sendSymmetricMessage(&testChannel, 42, UA_MESSAGETYPE_MSG,\n                                                                 &dummyMessage, &dummyType);\n    ck_assert_msg(retval == UA_STATUSCODE_GOOD, \"Expected success\");\n    ck_assert_msg(fCalled.sym_sign, \"Expected message to have been signed\");\n    ck_assert_msg(!fCalled.sym_enc, \"Expected message to not have been encrypted\");\n} END_TEST\n\nSTART_TEST(SecureChannel_sendSymmetricMessage_modeSignAndEncrypt)\n{\n    // initialize dummy message\n    UA_ReadRequest dummyMessage;\n    UA_ReadRequest_init(&dummyMessage);\n    UA_DataType dummyType = UA_TYPES[UA_TYPES_READREQUEST];\n\n    testChannel.securityMode = UA_MESSAGESECURITYMODE_SIGNANDENCRYPT;\n\n    UA_StatusCode retval = UA_SecureChannel_sendSymmetricMessage(&testChannel, 42, UA_MESSAGETYPE_MSG,\n                                                                 &dummyMessage, &dummyType);\n    ck_assert_msg(retval == UA_STATUSCODE_GOOD, \"Expected success\");\n    ck_assert_msg(fCalled.sym_sign, \"Expected message to have been signed\");\n    ck_assert_msg(fCalled.sym_enc, \"Expected message to have been encrypted\");\n} END_TEST\n\n#endif /* UA_ENABLE_ENCRYPTION */\n\nSTART_TEST(SecureChannel_sendSymmetricMessage_invalidParameters) {\n    // initialize dummy message\n    UA_ReadRequest dummyMessage;\n    UA_ReadRequest_init(&dummyMessage);\n    UA_DataType dummyType = UA_TYPES[UA_TYPES_READREQUEST];\n\n    UA_StatusCode retval = UA_SecureChannel_sendSymmetricMessage(NULL, 42, UA_MESSAGETYPE_MSG,\n                                                                 &dummyMessage, &dummyType);\n    ck_assert_msg(retval != UA_STATUSCODE_GOOD, \"Expected failure\");\n\n    retval = UA_SecureChannel_sendSymmetricMessage(&testChannel, 42,\n                                                   UA_MESSAGETYPE_HEL, &dummyMessage, &dummyType);\n    ck_assert_msg(retval != UA_STATUSCODE_GOOD, \"Expected failure\");\n\n    retval = UA_SecureChannel_sendSymmetricMessage(&testChannel, 42,\n                                                   UA_MESSAGETYPE_ACK, &dummyMessage, &dummyType);\n    ck_assert_msg(retval != UA_STATUSCODE_GOOD, \"Expected failure\");\n\n    retval = UA_SecureChannel_sendSymmetricMessage(&testChannel, 42,\n                                                   UA_MESSAGETYPE_ERR, &dummyMessage, &dummyType);\n    ck_assert_msg(retval != UA_STATUSCODE_GOOD, \"Expected failure\");\n\n    retval = UA_SecureChannel_sendSymmetricMessage(&testChannel, 42,\n                                                   UA_MESSAGETYPE_OPN, &dummyMessage, &dummyType);\n    ck_assert_msg(retval != UA_STATUSCODE_GOOD, \"Expected failure\");\n\n    retval = UA_SecureChannel_sendSymmetricMessage(&testChannel, 42,\n                                                   UA_MESSAGETYPE_MSG, NULL, &dummyType);\n    ck_assert_msg(retval != UA_STATUSCODE_GOOD, \"Expected failure\");\n\n    retval = UA_SecureChannel_sendSymmetricMessage(&testChannel, 42,\n                                                   UA_MESSAGETYPE_MSG, &dummyMessage, NULL);\n    ck_assert_msg(retval != UA_STATUSCODE_GOOD, \"Expected failure\");\n} END_TEST\n\nstatic UA_StatusCode\nprocess_callback(void *application, UA_SecureChannel *channel,\n                 UA_MessageType messageType, UA_UInt32 requestId,\n                 UA_ByteString *message) {\n    ck_assert_ptr_ne(message, NULL);\n    ck_assert_ptr_ne(application, NULL);\n    if(message == NULL || application == NULL)\n        return UA_STATUSCODE_BADINTERNALERROR;\n    ck_assert_uint_ne(message->length, 0);\n    ck_assert_ptr_ne(message->data, NULL);\n    int *chunks_processed = (int *)application;\n    ++*chunks_processed;\n    return UA_STATUSCODE_GOOD;\n}\n\nSTART_TEST(SecureChannel_assemblePartialChunks) {\n    int chunks_processed = 0;\n    UA_ByteString buffer = UA_BYTESTRING_NULL;\n\n    buffer.data = (UA_Byte *)\"HELF \\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\"\n                             \"\\x10\\x00\\x00\\x00@\\x00\\x00\\x00\\x00\\x00\\x00\\xff\\xff\\xff\\xff\";\n    buffer.length = 32;\n\n    UA_StatusCode retval = UA_SecureChannel_processBuffer(&testChannel, &chunks_processed, process_callback, &buffer);\n    ck_assert_msg(retval == UA_STATUSCODE_GOOD, \"Expected success\");\n    ck_assert_int_eq(chunks_processed, 1);\n\n    buffer.length = 16;\n\n    UA_SecureChannel_processBuffer(&testChannel, &chunks_processed, process_callback, &buffer);\n    ck_assert_msg(retval == UA_STATUSCODE_GOOD, \"Expected success\");\n    ck_assert_int_eq(chunks_processed, 1);\n\n    buffer.data = &buffer.data[16];\n    UA_SecureChannel_processBuffer(&testChannel, &chunks_processed, process_callback, &buffer);\n    ck_assert_msg(retval == UA_STATUSCODE_GOOD, \"Expected success\");\n    ck_assert_int_eq(chunks_processed, 2);\n\n    buffer.data = (UA_Byte *)\"HELF \\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\"\n                             \"\\x10\\x00\\x00\\x00@\\x00\\x00\\x00\\x00\\x00\\x00\\xff\\xff\\xff\\xff\"\n                             \"HELF \\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\"\n                             \"\\x10\\x00\\x00\\x00@\\x00\\x00\\x00\\x00\\x00\\x00\\xff\\xff\\xff\\xff\"\n                             \"HELF \\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\"\n                             \"\\x10\\x00\\x00\\x00@\\x00\\x00\\x00\\x00\\x00\\x00\\xff\\xff\\xff\\xff\";\n    buffer.length = 48;\n\n    UA_SecureChannel_processBuffer(&testChannel, &chunks_processed, process_callback, &buffer);\n    ck_assert_msg(retval == UA_STATUSCODE_GOOD, \"Expected success\");\n    ck_assert_int_eq(chunks_processed, 3);\n\n    buffer.data = &buffer.data[48];\n    buffer.length = 32;\n\n    UA_SecureChannel_processBuffer(&testChannel, &chunks_processed, process_callback, &buffer);\n    ck_assert_msg(retval == UA_STATUSCODE_GOOD, \"Expected success\");\n    ck_assert_int_eq(chunks_processed, 4);\n\n    buffer.data = &buffer.data[32];\n    buffer.length = 16;\n    UA_SecureChannel_processBuffer(&testChannel, &chunks_processed, process_callback, &buffer);\n    ck_assert_msg(retval == UA_STATUSCODE_GOOD, \"Expected success\");\n    ck_assert_int_eq(chunks_processed, 5);\n} END_TEST\n\n\nstatic Suite *\ntestSuite_SecureChannel(void) {\n    Suite *s = suite_create(\"SecureChannel\");\n\n    TCase *tc_initAndDelete = tcase_create(\"Initialize and delete Securechannel\");\n    tcase_add_checked_fixture(tc_initAndDelete, setup_funcs_called, teardown_funcs_called);\n    tcase_add_checked_fixture(tc_initAndDelete, setup_key_sizes, teardown_key_sizes);\n    tcase_add_test(tc_initAndDelete, SecureChannel_initAndDelete);\n    suite_add_tcase(s, tc_initAndDelete);\n\n    TCase *tc_sendAsymmetricOPNMessage = tcase_create(\"Test sendAsymmetricOPNMessage function\");\n    tcase_add_checked_fixture(tc_sendAsymmetricOPNMessage, setup_funcs_called, teardown_funcs_called);\n    tcase_add_checked_fixture(tc_sendAsymmetricOPNMessage, setup_key_sizes, teardown_key_sizes);\n    tcase_add_checked_fixture(tc_sendAsymmetricOPNMessage, setup_secureChannel, teardown_secureChannel);\n    tcase_add_test(tc_sendAsymmetricOPNMessage, SecureChannel_sendAsymmetricOPNMessage_withoutConnection);\n    tcase_add_test(tc_sendAsymmetricOPNMessage, SecureChannel_sendAsymmetricOPNMessage_invalidParameters);\n    tcase_add_test(tc_sendAsymmetricOPNMessage, SecureChannel_sendAsymmetricOPNMessage_SecurityModeInvalid);\n    tcase_add_test(tc_sendAsymmetricOPNMessage, SecureChannel_sendAsymmetricOPNMessage_SecurityModeNone);\n    tcase_add_test(tc_sendAsymmetricOPNMessage, SecureChannel_sendAsymmetricOPNMessage_sentDataIsValid);\n#ifdef UA_ENABLE_ENCRYPTION\n    tcase_add_test(tc_sendAsymmetricOPNMessage, SecureChannel_sendAsymmetricOPNMessage_SecurityModeSign);\n    tcase_add_test(tc_sendAsymmetricOPNMessage, SecureChannel_sendAsymmetricOPNMessage_SecurityModeSignAndEncrypt);\n    tcase_add_test(tc_sendAsymmetricOPNMessage,\n                   Securechannel_sendAsymmetricOPNMessage_extraPaddingPresentWhenKeyLargerThan2048Bits);\n#endif\n    suite_add_tcase(s, tc_sendAsymmetricOPNMessage);\n\n    TCase *tc_sendSymmetricMessage = tcase_create(\"Test sendSymmetricMessage function\");\n    tcase_add_checked_fixture(tc_sendSymmetricMessage, setup_funcs_called, teardown_funcs_called);\n    tcase_add_checked_fixture(tc_sendSymmetricMessage, setup_key_sizes, teardown_key_sizes);\n    tcase_add_checked_fixture(tc_sendSymmetricMessage, setup_secureChannel, teardown_secureChannel);\n    tcase_add_test(tc_sendSymmetricMessage, SecureChannel_sendSymmetricMessage);\n    tcase_add_test(tc_sendSymmetricMessage, SecureChannel_sendSymmetricMessage_invalidParameters);\n    tcase_add_test(tc_sendSymmetricMessage, SecureChannel_sendSymmetricMessage_modeNone);\n#ifdef UA_ENABLE_ENCRYPTION\n    tcase_add_test(tc_sendSymmetricMessage, SecureChannel_sendSymmetricMessage_modeSign);\n    tcase_add_test(tc_sendSymmetricMessage, SecureChannel_sendSymmetricMessage_modeSignAndEncrypt);\n#endif\n    suite_add_tcase(s, tc_sendSymmetricMessage);\n\n    TCase *tc_processBuffer = tcase_create(\"Test chunk assembly\");\n    tcase_add_checked_fixture(tc_processBuffer, setup_funcs_called, teardown_funcs_called);\n    tcase_add_checked_fixture(tc_processBuffer, setup_key_sizes, teardown_key_sizes);\n    tcase_add_checked_fixture(tc_processBuffer, setup_secureChannel, teardown_secureChannel);\n    tcase_add_test(tc_processBuffer, SecureChannel_assemblePartialChunks);\n    suite_add_tcase(s, tc_processBuffer);\n\n    return s;\n}\n\nint\nmain(void) {\n    Suite *s = testSuite_SecureChannel();\n    SRunner *sr = srunner_create(s);\n    srunner_set_fork_status(sr, CK_NOFORK);\n    srunner_run_all(sr, CK_NORMAL);\n    int number_failed = srunner_ntests_failed(sr);\n    srunner_free(sr);\n    return (number_failed == 0) ? EXIT_SUCCESS : EXIT_FAILURE;\n}\n"], "filenames": ["plugins/ua_config_default.c", "tests/check_securechannel.c"], "buggy_code_start_loc": [62, 48], "buggy_code_end_loc": [69, 49], "fixing_code_start_loc": [62, 48], "fixing_code_end_loc": [69, 50], "type": "CWE-770", "message": "The package open62541/open62541 before 1.2.5, from 1.3-rc1 and before 1.3.1 are vulnerable to Denial of Service (DoS) due to a missing limitation on the number of received chunks - per single session or in total for all concurrent sessions. An attacker can exploit this vulnerability by sending an unlimited number of huge chunks (e.g. 2GB each) without sending the Final closing chunk.", "other": {"cve": {"id": "CVE-2022-25761", "sourceIdentifier": "report@snyk.io", "published": "2022-08-23T05:15:08.047", "lastModified": "2023-02-28T18:30:56.400", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The package open62541/open62541 before 1.2.5, from 1.3-rc1 and before 1.3.1 are vulnerable to Denial of Service (DoS) due to a missing limitation on the number of received chunks - per single session or in total for all concurrent sessions. An attacker can exploit this vulnerability by sending an unlimited number of huge chunks (e.g. 2GB each) without sending the Final closing chunk."}, {"lang": "es", "value": "El paquete open62541/open62541 versiones anteriores a 1.2.5, a partir de la 1.3-rc1 y anteriores a 1.3.1, son vulnerables a una Denegaci\u00f3n de Servicio (DoS) debido a una falta de limitaci\u00f3n del n\u00famero de chunks recibidos - por sesi\u00f3n \u00fanica o en total para todas las sesiones concurrentes. Un atacante puede explotar esta vulnerabilidad mediante el env\u00edo de un n\u00famero ilimitado de chunks enormes (por ejemplo, 2GB cada uno) sin enviar el chunk de cierre Final."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-770"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:open62541:open62541:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.2.5", "matchCriteriaId": "E2C217B5-F257-41E6-AB0B-47CD825BE1CD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:open62541:open62541:1.3:rc1:*:*:*:*:*:*", "matchCriteriaId": "B1FFC899-E72A-4353-8E3F-1E304CECFB8C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:open62541:open62541:1.3:rc2:*:*:*:*:*:*", "matchCriteriaId": "2CBF1985-C383-4F54-BEB3-861DF3ABC148"}, {"vulnerable": true, "criteria": "cpe:2.3:a:open62541:open62541:1.3:rc2-ef:*:*:*:*:*:*", "matchCriteriaId": "56DF56BE-77DF-45E4-9208-52475D99779F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:open62541:open62541:1.3:rc2-ef2:*:*:*:*:*:*", "matchCriteriaId": "2496D971-25AF-40E0-B2E4-815BDB7C3088"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:37:*:*:*:*:*:*:*", "matchCriteriaId": "E30D0E6F-4AE8-4284-8716-991DFA48CC5D"}]}]}], "references": [{"url": "https://github.com/open62541/open62541/commit/b79db1ac78146fc06b0b8435773d3967de2d659c", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/open62541/open62541/pull/5173", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/open62541/open62541/releases/tag/v1.2.5", "source": "report@snyk.io", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/open62541/open62541/releases/tag/v1.3.1", "source": "report@snyk.io", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/JNUV4FDVDBQHCPMOOEVKLMQK5SLKPK2L/", "source": "report@snyk.io", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.snyk.io/vuln/SNYK-UNMANAGED-OPEN62541OPEN62541-2988719", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/open62541/open62541/commit/b79db1ac78146fc06b0b8435773d3967de2d659c"}}