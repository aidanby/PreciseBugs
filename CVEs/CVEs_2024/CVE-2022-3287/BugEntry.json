{"buggy_code": ["%global glib2_version 2.45.8\n%global libxmlb_version 0.1.3\n%global libgusb_version 0.3.5\n%global libcurl_version 7.61.0\n%global libjcat_version 0.1.0\n%global systemd_version 231\n%global json_glib_version 1.1.1\n%global fwupdplugin_version @FWUPD_PLUGINVER@\n\n# although we ship a few tiny python files these are utilities that 99.99%\n# of users do not need -- use this to avoid dragging python onto CoreOS\n%global __requires_exclude ^%{python3}$\n\n%define alphatag                #ALPHATAG#\n\n%global enable_ci 0\n%global enable_tests 1\n%global enable_dummy 1\n%global __meson_wrap_mode nodownload\n\n# fwupd.efi is only available on these arches\n%ifarch x86_64 aarch64\n%global have_uefi 1\n%endif\n\n# gpio.h is only available on these arches\n%ifarch x86_64 aarch64\n%global have_gpio 1\n%endif\n\n# flashrom is only available on these arches\n%ifarch i686 x86_64 armv7hl aarch64 ppc64le\n%global have_flashrom 1\n%endif\n\n%ifarch i686 x86_64\n%global have_msr 1\n%endif\n\n# libsmbios is only available on x86\n%ifarch x86_64\n%global have_dell 1\n%endif\n\n# Until we actually have seen it outside x86\n%ifarch i686 x86_64\n%global have_thunderbolt 1\n%endif\n\n# only available recently\n%if 0%{?fedora} >= 30\n%global have_modem_manager 1\n%endif\n\nSummary:   Firmware update daemon\nName:      fwupd\nVersion:   #VERSION#\nRelease:   0.#BUILD#%{?alphatag}%{?dist}\nLicense:   LGPLv2+\nURL:       https://github.com/fwupd/fwupd\nSource0:   http://people.freedesktop.org/~hughsient/releases/%{name}-%{version}.tar.xz\n\nBuildRequires: gettext\nBuildRequires: glib2-devel >= %{glib2_version}\nBuildRequires: libxmlb-devel >= %{libxmlb_version}\nBuildRequires: libgcab1-devel\nBuildRequires: libgudev1-devel\nBuildRequires: libgusb-devel >= %{libgusb_version}\nBuildRequires: libcurl-devel >= %{libcurl_version}\nBuildRequires: libjcat-devel >= %{libjcat_version}\nBuildRequires: polkit-devel >= 0.103\nBuildRequires: protobuf-c-devel\nBuildRequires: python3-packaging\nBuildRequires: sqlite-devel\nBuildRequires: systemd >= %{systemd_version}\nBuildRequires: systemd-devel\nBuildRequires: libarchive-devel\nBuildRequires: libcbor-devel\nBuildRequires: gobject-introspection-devel\nBuildRequires: gcab\n%ifarch %{valgrind_arches}\nBuildRequires: valgrind\nBuildRequires: valgrind-devel\n%endif\nBuildRequires: gi-docgen\nBuildRequires: gnutls-devel\nBuildRequires: gnutls-utils\nBuildRequires: meson\nBuildRequires: json-glib-devel >= %{json_glib_version}\nBuildRequires: vala\nBuildRequires: bash-completion\nBuildRequires: git-core\n%if 0%{?have_flashrom}\nBuildRequires: flashrom-devel >= 1.2-2\n%endif\n\n%if 0%{?have_modem_manager}\nBuildRequires: ModemManager-glib-devel >= 1.10.0\nBuildRequires: libqmi-devel >= 1.22.0\nBuildRequires: libmbim-devel\n%endif\n\n%if 0%{?have_uefi}\nBuildRequires: efivar-devel >= 33\nBuildRequires: python3 python3-cairo python3-gobject\nBuildRequires: pango-devel\nBuildRequires: cairo-devel cairo-gobject-devel\nBuildRequires: freetype\nBuildRequires: fontconfig\nBuildRequires: google-noto-sans-cjk-ttc-fonts\nBuildRequires: tpm2-tss-devel >= 2.2.3\n%endif\n\n%if 0%{?have_dell}\nBuildRequires: efivar-devel >= 33\nBuildRequires: libsmbios-devel >= 2.3.0\n%endif\n\nRequires(post): systemd\nRequires(preun): systemd\nRequires(postun): systemd\n\nRequires: glib2%{?_isa} >= %{glib2_version}\nRequires: libxmlb%{?_isa} >= %{libxmlb_version}\nRequires: libgusb%{?_isa} >= %{libgusb_version}\nRequires: shared-mime-info\n\n%if 0%{?rhel} > 7 || 0%{?fedora} > 28\nRecommends: python3\n%endif\n\nObsoletes: fwupd-sign < 0.1.6\nObsoletes: libebitdo < 0.7.5-3\nObsoletes: libdfu < 1.0.0\nObsoletes: fwupd-labels < 1.1.0-1\n\nObsoletes: dbxtool < 9\nProvides: dbxtool\n\n%if 0%{?rhel} > 7\nObsoletes: fwupdate < 11-4\nObsoletes: fwupdate-efi < 11-4\n\nProvides: fwupdate\nProvides: fwupdate-efi\n%endif\n\n# optional, but a really good idea\nRecommends: udisks2\nRecommends: bluez\nRecommends: jq\n\n%if 0%{?have_modem_manager}\nRecommends: %{name}-plugin-modem-manager\n%endif\n%if 0%{?have_flashrom}\nRecommends: %{name}-plugin-flashrom\n%endif\n%if 0%{?have_uefi}\nRecommends: %{name}-efi\nRecommends: %{name}-plugin-uefi-capsule-data\n%endif\n\n%description\nfwupd is a daemon to allow session software to update device firmware.\n\n%package devel\nSummary: Development package for %{name}\nRequires: %{name}%{?_isa} = %{version}-%{release}\nObsoletes: libebitdo-devel < 0.7.5-3\nObsoletes: libdfu-devel < 1.0.0\n\n%description devel\nFiles for development with %{name}.\n\n%package tests\nSummary: Data files for installed tests\nRequires: %{name}%{?_isa} = %{version}-%{release}\n\n%description tests\nData files for installed tests.\n\n%if 0%{?have_modem_manager}\n%package plugin-modem-manager\nSummary: fwupd plugin using ModemManger\nRequires: %{name}%{?_isa} = %{version}-%{release}\n\n%description plugin-modem-manager\nThis provides the optional package which is only required on hardware that\nmight have mobile broadband hardware. It is probably not required on servers.\n%endif\n\n%if 0%{?have_flashrom}\n%package plugin-flashrom\nSummary: fwupd plugin using flashrom\nRequires: %{name}%{?_isa} = %{version}-%{release}\n\n%description plugin-flashrom\nThis provides the optional package which is only required on hardware that\ncan be flashed using flashrom. It is probably not required on servers.\n%endif\n\n%if 0%{?have_uefi}\n%package plugin-uefi-capsule-data\nSummary: Localized data for the UEFI UX capsule\nRequires: %{name}%{?_isa} = %{version}-%{release}\n\n%description plugin-uefi-capsule-data\nThis provides the pregenerated BMP artwork for the UX capsule, which allows the\n\"Installing firmware update\u2026\" localized text to be shown during a UEFI firmware\nupdate operation. This subpackage is probably not required on embedded hardware\nor server machines.\n%endif\n\n%if 0%{?qubes_packages}\n%package qubes-dom0\nSummary: fwupd wrapper for Qubes OS - dom0 scripts\nRequires:   gcab\nRequires:   fwupd >= 1.5.7\nRequires:   libjcat >= 0.1.6\n\n%description qubes-dom0\nfwupd wrapper for Qubes OS\n\n%package qubes-vm\nSummary: fwupd wrapper for Qubes OS - VM scripts\nRequires:   gcab\nRequires:   fwupd >= 1.5.7\nRequires:   libjcat >= 0.1.6\n\n%description qubes-vm\nfwupd wrapper for Qubes OS\n%endif\n\n%prep\n%autosetup -p1\n\n%build\n\n%meson \\\n%if 0%{?enable_ci}\n    --werror \\\n%endif\n    -Ddocs=enabled \\\n%if 0%{?enable_tests}\n    -Dtests=true \\\n%else\n    -Dtests=false \\\n%endif\n%if 0%{?enable_dummy}\n    -Dplugin_dummy=true \\\n%else\n    -Dplugin_dummy=false \\\n%endif\n%if 0%{?have_flashrom}\n    -Dplugin_flashrom=enabled \\\n%else\n    -Dplugin_flashrom=disabled \\\n%endif\n%if 0%{?have_msr}\n    -Dplugin_msr=enabled \\\n%else\n    -Dplugin_msr=disabled \\\n%endif\n%if 0%{?have_gpio}\n    -Dplugin_gpio=enabled \\\n%else\n    -Dplugin_gpio=disabled \\\n%endif\n%if 0%{?have_uefi}\n    -Dplugin_uefi_capsule=enabled \\\n    -Dplugin_uefi_pk=enabled \\\n    -Dplugin_tpm=enabled \\\n    -Defi_binary=false \\\n%else\n    -Dplugin_uefi_capsule=disabled \\\n    -Dplugin_uefi_pk=disabled \\\n    -Dplugin_tpm=disabled \\\n%endif\n%if 0%{?have_dell}\n    -Dplugin_dell=enabled \\\n%else\n    -Dplugin_dell=disabled \\\n%endif\n%if 0%{?have_modem_manager}\n    -Dplugin_modem_manager=enabled \\\n%else\n    -Dplugin_modem_manager=disabled \\\n%endif\n%if 0%{?qubes_packages}\n    -Dqubes=true \\\n%endif\n    -Dman=true \\\n    -Dbluez=enabled \\\n    -Dplugin_powerd=disabled \\\n    -Dgresource_quirks=disabled \\\n    -Dsupported_build=enabled\n\n%meson_build\n\n%if 0%{?enable_tests}\n%if 0%{?enable_ci}\n    ./contrib/ci/get_test_firmware.sh\n%endif\n%check\n%meson_test\n%endif\n\n%install\n%meson_install\n\nmkdir -p --mode=0700 $RPM_BUILD_ROOT%{_localstatedir}/lib/fwupd/gnupg\n\n# workaround for https://bugzilla.redhat.com/show_bug.cgi?id=1757948\nmkdir -p $RPM_BUILD_ROOT%{_localstatedir}/cache/fwupd\n\n%find_lang %{name}\n\n%post\n%systemd_post fwupd.service\n\n# change vendor-installed remotes to use the default keyring type\nfor fn in /etc/fwupd/remotes.d/*.conf; do\n    if grep -q \"Keyring=gpg\" \"$fn\"; then\n        sed -i 's/Keyring=gpg/#Keyring=pkcs/g' \"$fn\";\n    fi\ndone\n\n%preun\n%systemd_preun fwupd.service\n\n%postun\n%systemd_postun_with_restart fwupd.service\n\n%files -f %{name}.lang\n%doc README.md AUTHORS\n%license COPYING\n%config(noreplace)%{_sysconfdir}/fwupd/daemon.conf\n%if 0%{?have_uefi}\n%config(noreplace)%{_sysconfdir}/fwupd/uefi_capsule.conf\n%endif\n%config(noreplace)%{_sysconfdir}/fwupd/redfish.conf\n%if 0%{?have_thunderbolt}\n%config(noreplace)%{_sysconfdir}/fwupd/thunderbolt.conf\n%endif\n%dir %{_libexecdir}/fwupd\n%{_libexecdir}/fwupd/fwupd\n%ifarch i686 x86_64\n%{_libexecdir}/fwupd/fwupd-detect-cet\n%endif\n%{_libexecdir}/fwupd/fwupdoffline\n%if 0%{?have_uefi}\n%{_bindir}/fwupdate\n%endif\n%{_bindir}/dfu-tool\n%if 0%{?have_uefi}\n%{_bindir}/dbxtool\n%endif\n%{_bindir}/fwupdmgr\n%{_bindir}/fwupdtool\n%{_bindir}/fwupdagent\n%dir %{_sysconfdir}/fwupd\n%dir %{_sysconfdir}/fwupd/bios-settings.d\n%config%(noreplace)%{_sysconfdir}/fwupd/bios-settings.d/README.md\n%dir %{_sysconfdir}/fwupd/remotes.d\n%if 0%{?have_dell}\n%config(noreplace)%{_sysconfdir}/fwupd/remotes.d/dell-esrt.conf\n%endif\n%config(noreplace)%{_sysconfdir}/fwupd/remotes.d/lvfs.conf\n%config(noreplace)%{_sysconfdir}/fwupd/remotes.d/lvfs-testing.conf\n%config(noreplace)%{_sysconfdir}/fwupd/remotes.d/vendor.conf\n%config(noreplace)%{_sysconfdir}/fwupd/remotes.d/vendor-directory.conf\n%config(noreplace)%{_sysconfdir}/pki/fwupd\n%{_sysconfdir}/pki/fwupd-metadata\n%if 0%{?have_msr}\n/usr/lib/modules-load.d/fwupd-msr.conf\n%config(noreplace)%{_sysconfdir}/fwupd/msr.conf\n%endif\n%{_datadir}/dbus-1/system.d/org.freedesktop.fwupd.conf\n%{_datadir}/bash-completion/completions/fwupdmgr\n%{_datadir}/bash-completion/completions/fwupdtool\n%{_datadir}/bash-completion/completions/fwupdagent\n%{_datadir}/fish/vendor_completions.d/fwupdmgr.fish\n%{_datadir}/fwupd/metainfo/org.freedesktop.fwupd*.metainfo.xml\n%if 0%{?have_dell}\n%{_datadir}/fwupd/remotes.d/dell-esrt/metadata.xml\n%endif\n%{_datadir}/fwupd/remotes.d/vendor/firmware/README.md\n%{_datadir}/dbus-1/interfaces/org.freedesktop.fwupd.xml\n%{_datadir}/polkit-1/actions/org.freedesktop.fwupd.policy\n%{_datadir}/polkit-1/rules.d/org.freedesktop.fwupd.rules\n%{_datadir}/dbus-1/system-services/org.freedesktop.fwupd.service\n%{_mandir}/man1/fwupdtool.1*\n%{_mandir}/man1/fwupdagent.1*\n%{_mandir}/man1/dfu-tool.1*\n%if 0%{?have_uefi}\n%{_mandir}/man1/dbxtool.*\n%endif\n%{_mandir}/man1/fwupdmgr.1*\n%if 0%{?have_uefi}\n%{_mandir}/man1/fwupdate.1*\n%endif\n%{_datadir}/metainfo/org.freedesktop.fwupd.metainfo.xml\n%{_datadir}/icons/hicolor/scalable/apps/org.freedesktop.fwupd.svg\n%{_datadir}/fwupd/firmware_packager.py\n%{_datadir}/fwupd/simple_client.py\n%{_datadir}/fwupd/add_capsule_header.py\n%{_datadir}/fwupd/install_dell_bios_exe.py\n%{_unitdir}/fwupd-offline-update.service\n%{_unitdir}/fwupd.service\n%{_unitdir}/fwupd-refresh.service\n%{_unitdir}/fwupd-refresh.timer\n%{_presetdir}/fwupd-refresh.preset\n%{_unitdir}/system-update.target.wants/\n%dir %{_localstatedir}/lib/fwupd\n%dir %{_localstatedir}/cache/fwupd\n%dir %{_datadir}/fwupd/quirks.d\n%{_datadir}/fwupd/quirks.d/*.quirk\n%{_datadir}/doc/fwupd/*.html\n%{_datadir}/fwupd/host-emulate.d/*.json.gz\n%if 0%{?have_uefi}\n%{_sysconfdir}/grub.d/35_fwupd\n%endif\n%{_libdir}/libfwupd.so.2*\n%{_libdir}/libfwupdplugin.so.%{fwupdplugin_version}*\n%{_libdir}/girepository-1.0/Fwupd-2.0.typelib\n%{_libdir}/girepository-1.0/FwupdPlugin-1.0.typelib\n/usr/lib/udev/rules.d/*.rules\n/usr/lib/systemd/system-shutdown/fwupd.shutdown\n%dir %{_libdir}/fwupd-plugins-%{fwupdplugin_version}\n%ifarch i686 x86_64\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_acpi_facp.so\n%endif\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_acpi_phat.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_amt.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_analogix.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_android_boot.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_ata.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_bcm57xx.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_cfu.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_ccgx.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_ch341a.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_colorhug.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_corsair.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_cros_ec.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_cpu.so\n%if 0%{?have_dell}\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_dell.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_dell_esrt.so\n%endif\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_dell_dock.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_dfu.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_dfu_csr.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_ebitdo.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_elantp.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_elanfp.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_emmc.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_ep963x.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_fastboot.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_fresco_pd.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_genesys.so\n%if 0%{?have_gpio}\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_gpio.so\n%endif\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_hailuck.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_intel_usb4.so\n%ifarch i686 x86_64\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_iommu.so\n%endif\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_jabra.so\n%if 0%{?have_uefi}\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_lenovo_thinklmi.so\n%endif\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_linux_lockdown.so\n%ifarch i686 x86_64\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_linux_sleep.so\n%endif\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_linux_swap.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_linux_tainted.so\n%if 0%{?have_msr}\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_acpi_dmar.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_acpi_ivrs.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_msr.so\n%endif\n%ifarch x86_64\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_amd_pmc.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_pci_psp.so\n%endif\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_mtd.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_nitrokey.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_nordic_hid.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_nvme.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_optionrom.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_parade_lspcon.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_pci_bcr.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_pci_mei.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_pixart_rf.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_realtek_mst.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_redfish.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_rts54hid.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_rts54hub.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_scsi.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_steelseries.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_superio.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_synaptics_mst.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_synaptics_cape.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_synaptics_cxaudio.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_synaptics_prometheus.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_synaptics_rmi.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_system76_launch.so\n%if 0%{?enable_dummy}\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_test.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_test_ble.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_invalid.so\n%endif\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_thelio_io.so\n%if 0%{?have_thunderbolt}\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_thunderbolt.so\n%endif\n%if 0%{?have_uefi}\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_tpm.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_bios.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_uefi_capsule.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_uefi_dbx.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_uefi_pk.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_uefi_recovery.so\n%endif\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_usi_dock.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_vbe.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_logind.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_logitech_bulkcontroller.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_logitech_hidpp.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_uf2.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_upower.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_vli.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_wacom_raw.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_wacom_usb.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_goodixmoc.so\n%ghost %{_localstatedir}/lib/fwupd/gnupg\n\n%if 0%{?have_modem_manager}\n%files plugin-modem-manager\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_modem_manager.so\n%endif\n%if 0%{?have_flashrom}\n%files plugin-flashrom\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_flashrom.so\n%endif\n%if 0%{?have_uefi}\n%files plugin-uefi-capsule-data\n%{_datadir}/fwupd/uefi-capsule-ux.tar.xz\n%endif\n\n%files devel\n%{_datadir}/gir-1.0/Fwupd-2.0.gir\n%{_datadir}/gir-1.0/FwupdPlugin-1.0.gir\n%{_datadir}/doc/fwupd/libfwupdplugin\n%{_datadir}/doc/fwupd/libfwupd\n%{_datadir}/doc/libfwupdplugin\n%{_datadir}/doc/libfwupd\n%{_datadir}/vala/vapi\n%{_includedir}/fwupd-1\n%{_libdir}/libfwupd*.so\n%{_libdir}/pkgconfig/fwupd.pc\n%{_libdir}/pkgconfig/fwupdplugin.pc\n\n%files tests\n%if 0%{?enable_tests}\n%dir %{_datadir}/installed-tests/fwupd\n%{_datadir}/installed-tests/fwupd/tests/*\n%{_datadir}/installed-tests/fwupd/fwupd-tests.xml\n%{_datadir}/installed-tests/fwupd/*.test\n%{_datadir}/installed-tests/fwupd/*.cab\n%{_datadir}/installed-tests/fwupd/*.sh\n%if 0%{?have_uefi}\n%{_datadir}/installed-tests/fwupd/efi\n%endif\n%{_datadir}/fwupd/device-tests/*.json\n%{_libexecdir}/installed-tests/fwupd/*\n%dir %{_sysconfdir}/fwupd/remotes.d\n%config(noreplace)%{_sysconfdir}/fwupd/remotes.d/fwupd-tests.conf\n%endif\n\n%if 0%{?qubes_packages}\n%files qubes-vm\n%{_libexecdir}/qubes-fwupd/fwupd_common_vm.py\n%{_libexecdir}/qubes-fwupd/fwupd_download_updates.py\n%{_libexecdir}/qubes-fwupd/fwupd_usbvm_validate.py\n\n%files qubes-dom0\n%{_datadir}/qubes-fwupd/src/fwupd_receive_updates.py\n/usr/sbin/qubes-fwupdmgr\n%{_datadir}/qubes-fwupd/src/qubes_fwupd_heads.py\n%{_datadir}/qubes-fwupd/src/qubes_fwupd_update.py\n%{_datadir}/qubes-fwupd/src/__init__.py\n%{_datadir}/qubes-fwupd/test/fwupd_logs.py\n%{_datadir}/qubes-fwupd/test/test_qubes_fwupdmgr.py\n%{_datadir}/qubes-fwupd/test/test_qubes_fwupd_heads.py\n%{_datadir}/qubes-fwupd/test/__init__.py\n%{_datadir}/qubes-fwupd/test/logs/get_devices.log\n%{_datadir}/qubes-fwupd/test/logs/get_updates.log\n%{_datadir}/qubes-fwupd/test/logs/help.log\n%{_datadir}/qubes-fwupd/test/logs/firmware.metainfo.xml\n%{_datadir}/qubes-fwupd/test/logs/metainfo_name/firmware.metainfo.xml\n%{_datadir}/qubes-fwupd/test/logs/metainfo_version/firmware.metainfo.xml\n%endif\n\n%changelog\n* #LONGDATE# Richard Hughes <richard@hughsie.com> #VERSION#-0.#BUILD##ALPHATAG#\n- Update from git\n", "/*\n * Copyright (C) 2016 Richard Hughes <richard@hughsie.com>\n *\n * SPDX-License-Identifier: LGPL-2.1+\n */\n\n#define G_LOG_DOMAIN \"FuPlugin\"\n\n#include \"config.h\"\n\n#include <errno.h>\n#include <fwupd.h>\n#include <glib/gstdio.h>\n#include <gmodule.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"fu-bytes.h\"\n#include \"fu-context-private.h\"\n#include \"fu-device-private.h\"\n#include \"fu-kernel.h\"\n#include \"fu-mutex.h\"\n#include \"fu-path.h\"\n#include \"fu-plugin-private.h\"\n#include \"fu-security-attr.h\"\n#include \"fu-string.h\"\n\n/**\n * FuPlugin:\n *\n * A plugin which is used by fwupd to enumerate and update devices.\n *\n * See also: [class@FuDevice], [class@Fwupd.Plugin]\n */\n\nstatic void\nfu_plugin_finalize(GObject *object);\n\ntypedef struct {\n\tGModule *module;\n\tguint order;\n\tguint priority;\n\tgboolean done_init;\n\tGPtrArray *rules[FU_PLUGIN_RULE_LAST];\n\tGPtrArray *devices; /* (nullable) (element-type FuDevice) */\n\tGHashTable *runtime_versions;\n\tGHashTable *compile_versions;\n\tFuContext *ctx;\n\tGArray *device_gtypes; /* (nullable): of #GType */\n\tGHashTable *cache;     /* (nullable): platform_id:GObject */\n\tGRWLock cache_mutex;\n\tGHashTable *report_metadata; /* (nullable): key:value */\n\tGFileMonitor *config_monitor;\n\tFuPluginData *data;\n\tFuPluginVfuncs vfuncs;\n} FuPluginPrivate;\n\nenum {\n\tSIGNAL_DEVICE_ADDED,\n\tSIGNAL_DEVICE_REMOVED,\n\tSIGNAL_DEVICE_REGISTER,\n\tSIGNAL_RULES_CHANGED,\n\tSIGNAL_CONFIG_CHANGED,\n\tSIGNAL_CHECK_SUPPORTED,\n\tSIGNAL_LAST\n};\n\nstatic guint signals[SIGNAL_LAST] = {0};\n\nG_DEFINE_TYPE_WITH_PRIVATE(FuPlugin, fu_plugin, FWUPD_TYPE_PLUGIN)\n#define GET_PRIVATE(o) (fu_plugin_get_instance_private(o))\n\ntypedef void (*FuPluginInitVfuncsFunc)(FuPluginVfuncs *vfuncs);\ntypedef gboolean (*FuPluginDeviceFunc)(FuPlugin *self, FuDevice *device, GError **error);\ntypedef gboolean (*FuPluginDeviceProgressFunc)(FuPlugin *self,\n\t\t\t\t\t       FuDevice *device,\n\t\t\t\t\t       FuProgress *progress,\n\t\t\t\t\t       GError **error);\ntypedef gboolean (*FuPluginFlaggedDeviceFunc)(FuPlugin *self,\n\t\t\t\t\t      FuDevice *device,\n\t\t\t\t\t      FuProgress *progress,\n\t\t\t\t\t      FwupdInstallFlags flags,\n\t\t\t\t\t      GError **error);\ntypedef gboolean (*FuPluginDeviceArrayFunc)(FuPlugin *self, GPtrArray *devices, GError **error);\n\n/**\n * fu_plugin_is_open:\n * @self: a #FuPlugin\n *\n * Determines if the plugin is opened\n *\n * Returns: TRUE for opened, FALSE for not\n *\n * Since: 1.3.5\n **/\ngboolean\nfu_plugin_is_open(FuPlugin *self)\n{\n\tFuPluginPrivate *priv = GET_PRIVATE(self);\n\treturn priv->module != NULL;\n}\n\n/**\n * fu_plugin_get_name:\n * @self: a #FuPlugin\n *\n * Gets the plugin name.\n *\n * Returns: a plugin name, or %NULL for unknown.\n *\n * Since: 0.8.0\n **/\nconst gchar *\nfu_plugin_get_name(FuPlugin *self)\n{\n\tg_return_val_if_fail(FU_IS_PLUGIN(self), NULL);\n\treturn fwupd_plugin_get_name(FWUPD_PLUGIN(self));\n}\n\n/**\n * fu_plugin_set_name:\n * @self: a #FuPlugin\n * @name: a string\n *\n * Sets the plugin name.\n *\n * Since: 0.8.0\n **/\nvoid\nfu_plugin_set_name(FuPlugin *self, const gchar *name)\n{\n\tg_return_if_fail(FU_IS_PLUGIN(self));\n\tfwupd_plugin_set_name(FWUPD_PLUGIN(self), name);\n}\n\nstatic FuPluginVfuncs *\nfu_plugin_get_vfuncs(FuPlugin *self)\n{\n\tFuPluginPrivate *priv = GET_PRIVATE(self);\n\treturn &priv->vfuncs;\n}\n\n/**\n * fu_plugin_get_build_hash:\n * @self: a #FuPlugin\n *\n * Gets the build hash a plugin was generated with.\n *\n * Returns: (transfer none): a #gchar, or %NULL for unset.\n *\n * Since: 1.2.4\n **/\nconst gchar *\nfu_plugin_get_build_hash(FuPlugin *self)\n{\n\tFuPluginVfuncs *vfuncs = fu_plugin_get_vfuncs(self);\n\tg_return_val_if_fail(FU_IS_PLUGIN(self), NULL);\n\treturn vfuncs->build_hash;\n}\n\n/**\n * fu_plugin_cache_lookup:\n * @self: a #FuPlugin\n * @id: the key\n *\n * Finds an object in the per-plugin cache.\n *\n * Returns: (transfer none): a #GObject, or %NULL for unfound.\n *\n * Since: 0.8.0\n **/\ngpointer\nfu_plugin_cache_lookup(FuPlugin *self, const gchar *id)\n{\n\tFuPluginPrivate *priv = GET_PRIVATE(self);\n\tg_autoptr(GRWLockReaderLocker) locker = g_rw_lock_reader_locker_new(&priv->cache_mutex);\n\tg_return_val_if_fail(FU_IS_PLUGIN(self), NULL);\n\tg_return_val_if_fail(id != NULL, NULL);\n\tg_return_val_if_fail(locker != NULL, NULL);\n\tif (priv->cache == NULL)\n\t\treturn NULL;\n\treturn g_hash_table_lookup(priv->cache, id);\n}\n\n/**\n * fu_plugin_cache_add:\n * @self: a #FuPlugin\n * @id: the key\n * @dev: a #GObject, typically a #FuDevice\n *\n * Adds an object to the per-plugin cache.\n *\n * Since: 0.8.0\n **/\nvoid\nfu_plugin_cache_add(FuPlugin *self, const gchar *id, gpointer dev)\n{\n\tFuPluginPrivate *priv = GET_PRIVATE(self);\n\tg_autoptr(GRWLockWriterLocker) locker = g_rw_lock_writer_locker_new(&priv->cache_mutex);\n\tg_return_if_fail(FU_IS_PLUGIN(self));\n\tg_return_if_fail(id != NULL);\n\tg_return_if_fail(G_IS_OBJECT(dev));\n\tg_return_if_fail(locker != NULL);\n\tif (priv->cache == NULL) {\n\t\tpriv->cache = g_hash_table_new_full(g_str_hash,\n\t\t\t\t\t\t    g_str_equal,\n\t\t\t\t\t\t    g_free,\n\t\t\t\t\t\t    (GDestroyNotify)g_object_unref);\n\t}\n\tg_hash_table_insert(priv->cache, g_strdup(id), g_object_ref(dev));\n}\n\n/**\n * fu_plugin_cache_remove:\n * @self: a #FuPlugin\n * @id: the key\n *\n * Removes an object from the per-plugin cache.\n *\n * Since: 0.8.0\n **/\nvoid\nfu_plugin_cache_remove(FuPlugin *self, const gchar *id)\n{\n\tFuPluginPrivate *priv = GET_PRIVATE(self);\n\tg_autoptr(GRWLockWriterLocker) locker = g_rw_lock_writer_locker_new(&priv->cache_mutex);\n\tg_return_if_fail(FU_IS_PLUGIN(self));\n\tg_return_if_fail(id != NULL);\n\tg_return_if_fail(locker != NULL);\n\tif (priv->cache == NULL)\n\t\treturn;\n\tg_hash_table_remove(priv->cache, id);\n}\n\n/**\n * fu_plugin_get_data:\n * @self: a #FuPlugin\n *\n * Gets the per-plugin allocated private data. This will return %NULL unless\n * fu_plugin_alloc_data() has been called by the plugin.\n *\n * Returns: (transfer none): a pointer to a structure, or %NULL for unset.\n *\n * Since: 0.8.0\n **/\nFuPluginData *\nfu_plugin_get_data(FuPlugin *self)\n{\n\tFuPluginPrivate *priv = GET_PRIVATE(self);\n\tg_return_val_if_fail(FU_IS_PLUGIN(self), NULL);\n\treturn priv->data;\n}\n\n/**\n * fu_plugin_alloc_data: (skip):\n * @self: a #FuPlugin\n * @data_sz: the size to allocate\n *\n * Allocates the per-plugin allocated private data.\n *\n * Returns: (transfer full): a pointer to a structure, or %NULL for unset.\n *\n * Since: 0.8.0\n **/\nFuPluginData *\nfu_plugin_alloc_data(FuPlugin *self, gsize data_sz)\n{\n\tFuPluginPrivate *priv = GET_PRIVATE(self);\n\tg_return_val_if_fail(FU_IS_PLUGIN(self), NULL);\n\tif (priv->data != NULL) {\n\t\tg_critical(\"fu_plugin_alloc_data() already used by plugin\");\n\t\treturn priv->data;\n\t}\n\tpriv->data = g_malloc0(data_sz);\n\treturn priv->data;\n}\n\n/**\n * fu_plugin_guess_name_from_fn:\n * @filename: filename to guess\n *\n * Tries to guess the name of the plugin from a filename\n *\n * Returns: (transfer full): the guessed name of the plugin\n *\n * Since: 1.0.8\n **/\ngchar *\nfu_plugin_guess_name_from_fn(const gchar *filename)\n{\n\tconst gchar *prefix = \"libfu_plugin_\";\n\tgchar *name;\n\tgchar *str = g_strstr_len(filename, -1, prefix);\n\tif (str == NULL)\n\t\treturn NULL;\n\tname = g_strdup(str + strlen(prefix));\n\tg_strdelimit(name, \".\", '\\0');\n\treturn name;\n}\n\n/**\n * fu_plugin_open:\n * @self: a #FuPlugin\n * @filename: the shared object filename to open\n * @error: (nullable): optional return location for an error\n *\n * Opens the plugin module, and calls `->load()` on it.\n *\n * Returns: TRUE for success, FALSE for fail\n *\n * Since: 0.8.0\n **/\ngboolean\nfu_plugin_open(FuPlugin *self, const gchar *filename, GError **error)\n{\n\tFuPluginPrivate *priv = GET_PRIVATE(self);\n\tFuPluginVfuncs *vfuncs = fu_plugin_get_vfuncs(self);\n\tFuPluginInitVfuncsFunc init_vfuncs = NULL;\n\n\tg_return_val_if_fail(FU_IS_PLUGIN(self), FALSE);\n\tg_return_val_if_fail(filename != NULL, FALSE);\n\tg_return_val_if_fail(error == NULL || *error == NULL, FALSE);\n\n\tpriv->module = g_module_open(filename, 0);\n\tif (priv->module == NULL) {\n\t\tg_set_error(error,\n\t\t\t    G_IO_ERROR,\n\t\t\t    G_IO_ERROR_FAILED,\n\t\t\t    \"failed to open plugin %s: %s\",\n\t\t\t    filename,\n\t\t\t    g_module_error());\n\t\tfu_plugin_add_flag(self, FWUPD_PLUGIN_FLAG_FAILED_OPEN);\n\t\tfu_plugin_add_flag(self, FWUPD_PLUGIN_FLAG_USER_WARNING);\n\t\treturn FALSE;\n\t}\n\n\t/* call the vfunc setup */\n\tg_module_symbol(priv->module, \"fu_plugin_init_vfuncs\", (gpointer *)&init_vfuncs);\n\tif (init_vfuncs == NULL) {\n\t\tg_set_error(error,\n\t\t\t    G_IO_ERROR,\n\t\t\t    G_IO_ERROR_FAILED,\n\t\t\t    \"failed to init_vfuncs() on plugin %s\",\n\t\t\t    filename);\n\t\tfu_plugin_add_flag(self, FWUPD_PLUGIN_FLAG_FAILED_OPEN);\n\t\tfu_plugin_add_flag(self, FWUPD_PLUGIN_FLAG_USER_WARNING);\n\t\treturn FALSE;\n\t}\n\tinit_vfuncs(vfuncs);\n\n\t/* set automatically */\n\tif (fu_plugin_get_name(self) == NULL) {\n\t\tg_autofree gchar *str = fu_plugin_guess_name_from_fn(filename);\n\t\tfu_plugin_set_name(self, str);\n\t}\n\n\t/* optional */\n\tif (vfuncs->load != NULL) {\n\t\tFuContext *ctx = fu_plugin_get_context(self);\n\t\tg_debug(\"load(%s)\", filename);\n\t\tvfuncs->load(ctx);\n\t}\n\n\treturn TRUE;\n}\n\nstatic gchar *\nfu_plugin_flags_to_string(FwupdPluginFlags flags)\n{\n\tg_autoptr(GString) str = g_string_new(NULL);\n\tfor (guint i = 0; i < 64; i++) {\n\t\tFwupdPluginFlags flag = (guint64)1 << i;\n\t\tif ((flags & flag) == 0)\n\t\t\tcontinue;\n\t\tif (str->len > 0)\n\t\t\tg_string_append_c(str, ',');\n\t\tg_string_append(str, fwupd_plugin_flag_to_string(flag));\n\t}\n\tif (str->len == 0)\n\t\treturn NULL;\n\treturn g_string_free(g_steal_pointer(&str), FALSE);\n}\n\n/**\n * fu_plugin_add_string:\n * @self: a #FuPlugin\n * @idt: indent level\n * @str: a string to append to\n *\n * Add daemon-specific device metadata to an existing string.\n *\n * Since: 1.8.4\n **/\nvoid\nfu_plugin_add_string(FuPlugin *self, guint idt, GString *str)\n{\n\tFuPluginPrivate *priv = GET_PRIVATE(self);\n\tFuPluginVfuncs *vfuncs = fu_plugin_get_vfuncs(self);\n\tconst gchar *name = fwupd_plugin_get_name(FWUPD_PLUGIN(self));\n\tg_autofree gchar *flags = NULL;\n\n\tg_return_if_fail(FU_IS_PLUGIN(self));\n\tg_return_if_fail(str != NULL);\n\n\t/* attributes */\n\tfu_string_append(str, idt, G_OBJECT_TYPE_NAME(self), \"\");\n\tif (name != NULL)\n\t\tfu_string_append(str, idt + 1, \"Name\", name);\n\tflags = fu_plugin_flags_to_string(fwupd_plugin_get_flags(FWUPD_PLUGIN(self)));\n\tif (flags != NULL)\n\t\tfu_string_append(str, idt + 1, \"Flags\", flags);\n\tif (priv->order != 0)\n\t\tfu_string_append_ku(str, idt + 1, \"Order\", priv->order);\n\tif (priv->priority != 0)\n\t\tfu_string_append_ku(str, idt + 1, \"Priority\", priv->priority);\n\n\t/* optional */\n\tif (vfuncs->to_string != NULL)\n\t\tvfuncs->to_string(self, idt + 1, str);\n}\n\n/**\n * fu_plugin_to_string:\n * @self: a #FuPlugin\n *\n * This allows us to easily print the plugin metadata.\n *\n * Returns: a string value, or %NULL for invalid.\n *\n * Since: 1.8.4\n **/\ngchar *\nfu_plugin_to_string(FuPlugin *self)\n{\n\tg_autoptr(GString) str = g_string_new(NULL);\n\tg_return_val_if_fail(FU_IS_PLUGIN(self), NULL);\n\tfu_plugin_add_string(self, 0, str);\n\treturn g_string_free(g_steal_pointer(&str), FALSE);\n}\n\n/* order of usefulness to the user */\nstatic const gchar *\nfu_plugin_build_device_update_error(FuPlugin *self)\n{\n\tif (fu_plugin_has_flag(self, FWUPD_PLUGIN_FLAG_NO_HARDWARE))\n\t\treturn \"Not updatable as required hardware was not found\";\n\tif (fu_plugin_has_flag(self, FWUPD_PLUGIN_FLAG_LEGACY_BIOS))\n\t\treturn \"Not updatable in legacy BIOS mode\";\n\tif (fu_plugin_has_flag(self, FWUPD_PLUGIN_FLAG_CAPSULES_UNSUPPORTED))\n\t\treturn \"Not updatable as UEFI capsule updates not enabled in firmware setup\";\n\tif (fu_plugin_has_flag(self, FWUPD_PLUGIN_FLAG_UNLOCK_REQUIRED))\n\t\treturn \"Not updatable as requires unlock\";\n\tif (fu_plugin_has_flag(self, FWUPD_PLUGIN_FLAG_AUTH_REQUIRED))\n\t\treturn \"Not updatable as requires authentication\";\n\tif (fu_plugin_has_flag(self, FWUPD_PLUGIN_FLAG_EFIVAR_NOT_MOUNTED))\n\t\treturn \"Not updatable as efivarfs was not found\";\n\tif (fu_plugin_has_flag(self, FWUPD_PLUGIN_FLAG_ESP_NOT_FOUND))\n\t\treturn \"Not updatable as UEFI ESP partition not detected\";\n\tif (fu_plugin_has_flag(self, FWUPD_PLUGIN_FLAG_DISABLED))\n\t\treturn \"Not updatable as plugin was disabled\";\n\treturn NULL;\n}\n\nstatic void\nfu_plugin_ensure_devices(FuPlugin *self)\n{\n\tFuPluginPrivate *priv = GET_PRIVATE(self);\n\tif (priv->devices != NULL)\n\t\treturn;\n\tpriv->devices = g_ptr_array_new_with_free_func((GDestroyNotify)g_object_unref);\n}\n\nstatic void\nfu_plugin_device_child_added_cb(FuDevice *device, FuDevice *child, FuPlugin *self)\n{\n\tg_debug(\"child %s added to parent %s after setup, adding to daemon\",\n\t\tfu_device_get_id(child),\n\t\tfu_device_get_id(device));\n\tfu_plugin_device_add(self, child);\n}\n\nstatic void\nfu_plugin_device_child_removed_cb(FuDevice *device, FuDevice *child, FuPlugin *self)\n{\n\tg_debug(\"child %s removed from parent %s after setup, removing from daemon\",\n\t\tfu_device_get_id(child),\n\t\tfu_device_get_id(device));\n\tfu_plugin_device_remove(self, child);\n}\n\nstatic void\nfu_plugin_config_monitor_changed_cb(GFileMonitor *monitor,\n\t\t\t\t    GFile *file,\n\t\t\t\t    GFile *other_file,\n\t\t\t\t    GFileMonitorEvent event_type,\n\t\t\t\t    gpointer user_data)\n{\n\tFuPlugin *self = FU_PLUGIN(user_data);\n\tg_autofree gchar *fn = g_file_get_path(file);\n\tg_debug(\"%s changed, sending signal\", fn);\n\tg_signal_emit(self, signals[SIGNAL_CONFIG_CHANGED], 0);\n}\n\nstatic gchar *\nfu_plugin_get_config_filename(FuPlugin *self)\n{\n\tg_autofree gchar *conf_dir = fu_path_from_kind(FU_PATH_KIND_SYSCONFDIR_PKG);\n\tg_autofree gchar *conf_file = g_strdup_printf(\"%s.conf\", fu_plugin_get_name(self));\n\treturn g_build_filename(conf_dir, conf_file, NULL);\n}\n\n/**\n * fu_plugin_device_add:\n * @self: a #FuPlugin\n * @device: a device\n *\n * Asks the daemon to add a device to the exported list. If this device ID\n * has already been added by a different plugin then this request will be\n * ignored.\n *\n * Since: 0.8.0\n **/\nvoid\nfu_plugin_device_add(FuPlugin *self, FuDevice *device)\n{\n\tFuPluginPrivate *priv = GET_PRIVATE(self);\n\tGPtrArray *children;\n\tg_autoptr(GError) error = NULL;\n\n\tg_return_if_fail(FU_IS_PLUGIN(self));\n\tg_return_if_fail(FU_IS_DEVICE(device));\n\n\t/* ensure the device ID is set from the physical and logical IDs */\n\tif (!fu_device_ensure_id(device, &error)) {\n\t\tg_warning(\"ignoring add: %s\", error->message);\n\t\treturn;\n\t}\n\n\t/* add to array */\n\tfu_plugin_ensure_devices(self);\n\tg_ptr_array_add(priv->devices, g_object_ref(device));\n\n\t/* proxy to device where required */\n\tif (fu_plugin_has_flag(self, FWUPD_PLUGIN_FLAG_CLEAR_UPDATABLE)) {\n\t\tif (fu_plugin_has_flag(self, FWUPD_PLUGIN_FLAG_USER_WARNING)) {\n\t\t\tfu_device_inhibit(device,\n\t\t\t\t\t  \"clear-updatable\",\n\t\t\t\t\t  fu_plugin_build_device_update_error(self));\n\t\t} else {\n\t\t\tfu_device_inhibit(device,\n\t\t\t\t\t  \"clear-updatable\",\n\t\t\t\t\t  \"Plugin disallowed updates with no user warning\");\n\t\t}\n\t}\n\n\tg_debug(\"emit added from %s: %s\", fu_plugin_get_name(self), fu_device_get_id(device));\n\tfu_device_set_created(device, (guint64)g_get_real_time() / G_USEC_PER_SEC);\n\tfu_device_set_plugin(device, fu_plugin_get_name(self));\n\tg_signal_emit(self, signals[SIGNAL_DEVICE_ADDED], 0, device);\n\n\t/* add children if they have not already been added */\n\tchildren = fu_device_get_children(device);\n\tfor (guint i = 0; i < children->len; i++) {\n\t\tFuDevice *child = g_ptr_array_index(children, i);\n\t\tif (fu_device_get_created(child) == 0)\n\t\t\tfu_plugin_device_add(self, child);\n\t}\n\n\t/* watch to see if children are added or removed at runtime */\n\tg_signal_connect(FU_DEVICE(device),\n\t\t\t \"child-added\",\n\t\t\t G_CALLBACK(fu_plugin_device_child_added_cb),\n\t\t\t self);\n\tg_signal_connect(FU_DEVICE(device),\n\t\t\t \"child-removed\",\n\t\t\t G_CALLBACK(fu_plugin_device_child_removed_cb),\n\t\t\t self);\n}\n\n/**\n * fu_plugin_get_devices:\n * @self: a #FuPlugin\n *\n * Returns all devices added by the plugin using [method@FuPlugin.device_add] and\n * not yet removed with [method@FuPlugin.device_remove].\n *\n * Returns: (transfer none) (element-type FuDevice): devices\n *\n * Since: 1.5.6\n **/\nGPtrArray *\nfu_plugin_get_devices(FuPlugin *self)\n{\n\tFuPluginPrivate *priv = GET_PRIVATE(self);\n\tg_return_val_if_fail(FU_IS_PLUGIN(self), NULL);\n\tfu_plugin_ensure_devices(self);\n\treturn priv->devices;\n}\n\n/**\n * fu_plugin_device_register:\n * @self: a #FuPlugin\n * @device: a device\n *\n * Registers the device with other plugins so they can set metadata.\n *\n * Plugins do not have to call this manually as this is done automatically\n * when using [method@FuPlugin.device_add]. They may wish to use this manually\n * if for instance the coldplug should be ignored based on the metadata\n * set from other plugins.\n *\n * Since: 0.9.7\n **/\nvoid\nfu_plugin_device_register(FuPlugin *self, FuDevice *device)\n{\n\tg_autoptr(GError) error = NULL;\n\n\tg_return_if_fail(FU_IS_PLUGIN(self));\n\tg_return_if_fail(FU_IS_DEVICE(device));\n\n\t/* ensure the device ID is set from the physical and logical IDs */\n\tif (!fu_device_ensure_id(device, &error)) {\n\t\tg_warning(\"ignoring registration: %s\", error->message);\n\t\treturn;\n\t}\n\n\tg_debug(\"emit device-register from %s: %s\",\n\t\tfu_plugin_get_name(self),\n\t\tfu_device_get_id(device));\n\tg_signal_emit(self, signals[SIGNAL_DEVICE_REGISTER], 0, device);\n}\n\n/**\n * fu_plugin_device_remove:\n * @self: a #FuPlugin\n * @device: a device\n *\n * Asks the daemon to remove a device from the exported list.\n *\n * Since: 0.8.0\n **/\nvoid\nfu_plugin_device_remove(FuPlugin *self, FuDevice *device)\n{\n\tFuPluginPrivate *priv = GET_PRIVATE(self);\n\n\tg_return_if_fail(FU_IS_PLUGIN(self));\n\tg_return_if_fail(FU_IS_DEVICE(device));\n\n\t/* remove from array */\n\tif (priv->devices != NULL)\n\t\tg_ptr_array_remove(priv->devices, device);\n\n\tg_debug(\"emit removed from %s: %s\", fu_plugin_get_name(self), fu_device_get_id(device));\n\tg_signal_emit(self, signals[SIGNAL_DEVICE_REMOVED], 0, device);\n}\n\n/**\n * fu_plugin_check_supported:\n * @self: a #FuPlugin\n * @guid: a hardware ID GUID, e.g. `6de5d951-d755-576b-bd09-c5cf66b27234`\n *\n * Checks to see if a specific device GUID is supported, i.e. available in the\n * AppStream metadata.\n *\n * Returns: %TRUE if the device is supported.\n *\n * Since: 1.0.0\n **/\nstatic gboolean\nfu_plugin_check_supported(FuPlugin *self, const gchar *guid)\n{\n\tgboolean retval = FALSE;\n\tg_signal_emit(self, signals[SIGNAL_CHECK_SUPPORTED], 0, guid, &retval);\n\treturn retval;\n}\n\n/**\n * fu_plugin_get_context:\n * @self: a #FuPlugin\n *\n * Gets the context for a plugin.\n *\n * Returns: (transfer none): a #FuContext or %NULL if not set\n *\n * Since: 1.6.0\n **/\nFuContext *\nfu_plugin_get_context(FuPlugin *self)\n{\n\tFuPluginPrivate *priv = GET_PRIVATE(self);\n\treturn priv->ctx;\n}\n\nstatic gboolean\nfu_plugin_device_attach(FuPlugin *self, FuDevice *device, FuProgress *progress, GError **error)\n{\n\tFuDevice *proxy = fu_device_get_proxy_with_fallback(device);\n\tFuDeviceClass *proxy_klass = FU_DEVICE_GET_CLASS(proxy);\n\tg_autoptr(FuDeviceLocker) locker = NULL;\n\tif (proxy_klass->attach == NULL)\n\t\treturn TRUE;\n\tlocker = fu_device_locker_new(proxy, error);\n\tif (locker == NULL)\n\t\treturn FALSE;\n\treturn fu_device_attach_full(device, progress, error);\n}\n\nstatic gboolean\nfu_plugin_device_detach(FuPlugin *self, FuDevice *device, FuProgress *progress, GError **error)\n{\n\tFuDevice *proxy = fu_device_get_proxy_with_fallback(device);\n\tFuDeviceClass *proxy_klass = FU_DEVICE_GET_CLASS(proxy);\n\tg_autoptr(FuDeviceLocker) locker = NULL;\n\tif (proxy_klass->detach == NULL)\n\t\treturn TRUE;\n\tlocker = fu_device_locker_new(proxy, error);\n\tif (locker == NULL)\n\t\treturn FALSE;\n\treturn fu_device_detach_full(device, progress, error);\n}\n\nstatic gboolean\nfu_plugin_device_activate(FuPlugin *self, FuDevice *device, FuProgress *progress, GError **error)\n{\n\tFuDevice *proxy = fu_device_get_proxy_with_fallback(device);\n\tFuDeviceClass *proxy_klass = FU_DEVICE_GET_CLASS(proxy);\n\tg_autoptr(FuDeviceLocker) locker = NULL;\n\tif (proxy_klass->activate == NULL)\n\t\treturn TRUE;\n\tlocker = fu_device_locker_new(proxy, error);\n\tif (locker == NULL)\n\t\treturn FALSE;\n\treturn fu_device_activate(device, progress, error);\n}\n\nstatic gboolean\nfu_plugin_device_write_firmware(FuPlugin *self,\n\t\t\t\tFuDevice *device,\n\t\t\t\tGBytes *fw,\n\t\t\t\tFuProgress *progress,\n\t\t\t\tFwupdInstallFlags flags,\n\t\t\t\tGError **error)\n{\n\tFuDevice *proxy = fu_device_get_proxy_with_fallback(device);\n\tg_autoptr(FuDeviceLocker) locker = NULL;\n\tlocker = fu_device_locker_new(proxy, error);\n\tif (locker == NULL)\n\t\treturn FALSE;\n\n\t/* back the old firmware up to /var/lib/fwupd */\n\tif (fu_device_has_flag(device, FWUPD_DEVICE_FLAG_BACKUP_BEFORE_INSTALL)) {\n\t\tg_autoptr(GBytes) fw_old = NULL;\n\t\tg_autofree gchar *path = NULL;\n\t\tg_autofree gchar *fn = NULL;\n\t\tg_autofree gchar *localstatedir = NULL;\n\n\t\t/* progress */\n\t\tfu_progress_set_id(progress, G_STRLOC);\n\t\tfu_progress_add_flag(progress, FU_PROGRESS_FLAG_NO_PROFILE);\n\t\tfu_progress_add_step(progress, FWUPD_STATUS_DEVICE_READ, 25, NULL);\n\t\tfu_progress_add_step(progress, FWUPD_STATUS_DEVICE_WRITE, 75, NULL);\n\n\t\tfw_old = fu_device_dump_firmware(device, fu_progress_get_child(progress), error);\n\t\tif (fw_old == NULL) {\n\t\t\tg_prefix_error(error, \"failed to backup old firmware: \");\n\t\t\treturn FALSE;\n\t\t}\n\t\tlocalstatedir = fu_path_from_kind(FU_PATH_KIND_LOCALSTATEDIR_PKG);\n\t\tfn = g_strdup_printf(\"%s.bin\", fu_device_get_version(device));\n\t\tpath = g_build_filename(\n\t\t    localstatedir,\n\t\t    \"backup\",\n\t\t    fu_device_get_id(device),\n\t\t    fu_device_get_serial(device) != NULL ? fu_device_get_serial(device) : \"default\",\n\t\t    fn,\n\t\t    NULL);\n\t\tfu_progress_step_done(progress);\n\t\tif (!fu_bytes_set_contents(path, fw_old, error))\n\t\t\treturn FALSE;\n\t\tif (!fu_device_write_firmware(device,\n\t\t\t\t\t      fw,\n\t\t\t\t\t      fu_progress_get_child(progress),\n\t\t\t\t\t      flags,\n\t\t\t\t\t      error))\n\t\t\treturn FALSE;\n\t\tfu_progress_step_done(progress);\n\t\treturn TRUE;\n\t}\n\n\treturn fu_device_write_firmware(device, fw, progress, flags, error);\n}\n\nstatic gboolean\nfu_plugin_device_get_results(FuPlugin *self, FuDevice *device, GError **error)\n{\n\tg_autoptr(FuDeviceLocker) locker = NULL;\n\tg_autoptr(GError) error_local = NULL;\n\tlocker = fu_device_locker_new(device, error);\n\tif (locker == NULL)\n\t\treturn FALSE;\n\tif (!fu_device_get_results(device, &error_local)) {\n\t\tif (g_error_matches(error_local, FWUPD_ERROR, FWUPD_ERROR_NOT_SUPPORTED))\n\t\t\treturn TRUE;\n\t\tg_propagate_error(error, g_steal_pointer(&error_local));\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\nstatic gboolean\nfu_plugin_device_read_firmware(FuPlugin *self,\n\t\t\t       FuDevice *device,\n\t\t\t       FuProgress *progress,\n\t\t\t       GError **error)\n{\n\tFuDevice *proxy = fu_device_get_proxy_with_fallback(device);\n\tg_autoptr(FuDeviceLocker) locker = NULL;\n\tg_autoptr(FuFirmware) firmware = NULL;\n\tg_autoptr(GBytes) fw = NULL;\n\tGChecksumType checksum_types[] = {G_CHECKSUM_SHA1, G_CHECKSUM_SHA256, 0};\n\tlocker = fu_device_locker_new(proxy, error);\n\tif (locker == NULL)\n\t\treturn FALSE;\n\tif (!fu_device_detach_full(device, progress, error))\n\t\treturn FALSE;\n\tfirmware = fu_device_read_firmware(device, progress, error);\n\tif (firmware == NULL) {\n\t\tg_autoptr(GError) error_local = NULL;\n\t\tif (!fu_device_attach_full(device, progress, &error_local))\n\t\t\tg_debug(\"ignoring attach failure: %s\", error_local->message);\n\t\tg_prefix_error(error, \"failed to read firmware: \");\n\t\treturn FALSE;\n\t}\n\tfw = fu_firmware_write(firmware, error);\n\tif (fw == NULL) {\n\t\tg_autoptr(GError) error_local = NULL;\n\t\tif (!fu_device_attach_full(device, progress, &error_local))\n\t\t\tg_debug(\"ignoring attach failure: %s\", error_local->message);\n\t\tg_prefix_error(error, \"failed to write firmware: \");\n\t\treturn FALSE;\n\t}\n\tfor (guint i = 0; checksum_types[i] != 0; i++) {\n\t\tg_autofree gchar *hash = NULL;\n\t\thash = g_compute_checksum_for_bytes(checksum_types[i], fw);\n\t\tfu_device_add_checksum(device, hash);\n\t}\n\treturn fu_device_attach_full(device, progress, error);\n}\n\n/**\n * fu_plugin_runner_startup:\n * @self: a #FuPlugin\n * @error: (nullable): optional return location for an error\n *\n * Runs the startup routine for the plugin\n *\n * Returns: #TRUE for success, #FALSE for failure\n *\n * Since: 0.8.0\n **/\ngboolean\nfu_plugin_runner_startup(FuPlugin *self, FuProgress *progress, GError **error)\n{\n\tFuPluginPrivate *priv = GET_PRIVATE(self);\n\tFuPluginVfuncs *vfuncs = fu_plugin_get_vfuncs(self);\n\tg_autofree gchar *config_filename = fu_plugin_get_config_filename(self);\n\tg_autoptr(GError) error_local = NULL;\n\tg_autoptr(GFile) file = g_file_new_for_path(config_filename);\n\n\tg_return_val_if_fail(FU_IS_PLUGIN(self), FALSE);\n\n\t/* progress */\n\tfu_progress_set_name(progress, fu_plugin_get_name(self));\n\n\t/* be helpful for unit tests */\n\tfu_plugin_runner_init(self);\n\n\t/* not enabled */\n\tif (fu_plugin_has_flag(self, FWUPD_PLUGIN_FLAG_DISABLED))\n\t\treturn TRUE;\n\n\t/* optional */\n\tif (vfuncs->startup == NULL)\n\t\treturn TRUE;\n\tg_debug(\"startup(%s)\", fu_plugin_get_name(self));\n\tif (!vfuncs->startup(self, progress, &error_local)) {\n\t\tif (error_local == NULL) {\n\t\t\tg_critical(\"unset plugin error in startup(%s)\", fu_plugin_get_name(self));\n\t\t\tg_set_error_literal(&error_local,\n\t\t\t\t\t    FWUPD_ERROR,\n\t\t\t\t\t    FWUPD_ERROR_INTERNAL,\n\t\t\t\t\t    \"unspecified error\");\n\t\t}\n\t\tg_propagate_prefixed_error(error,\n\t\t\t\t\t   g_steal_pointer(&error_local),\n\t\t\t\t\t   \"failed to startup using %s: \",\n\t\t\t\t\t   fu_plugin_get_name(self));\n\t\treturn FALSE;\n\t}\n\n\t/* create a monitor on the config file */\n\tpriv->config_monitor = g_file_monitor_file(file, G_FILE_MONITOR_NONE, NULL, error);\n\tif (priv->config_monitor == NULL)\n\t\treturn FALSE;\n\tg_signal_connect(G_FILE_MONITOR(priv->config_monitor),\n\t\t\t \"changed\",\n\t\t\t G_CALLBACK(fu_plugin_config_monitor_changed_cb),\n\t\t\t self);\n\n\t/* success */\n\treturn TRUE;\n}\n\n/**\n * fu_plugin_runner_init:\n * @self: a #FuPlugin\n *\n * Runs the init routine for the plugin, if enabled.\n *\n * Since: 1.8.1\n **/\nvoid\nfu_plugin_runner_init(FuPlugin *self)\n{\n\tFuPluginVfuncs *vfuncs = fu_plugin_get_vfuncs(self);\n\tFuPluginPrivate *priv = GET_PRIVATE(self);\n\n\tg_return_if_fail(FU_IS_PLUGIN(self));\n\n\t/* already done */\n\tif (priv->done_init)\n\t\treturn;\n\n\t/* not enabled */\n\tif (fu_plugin_has_flag(self, FWUPD_PLUGIN_FLAG_DISABLED))\n\t\treturn;\n\n\t/* optional */\n\tif (vfuncs->init != NULL) {\n\t\tg_debug(\"init(%s)\", fu_plugin_get_name(self));\n\t\tvfuncs->init(self);\n\t\tpriv->done_init = TRUE;\n\t}\n}\n\nstatic gboolean\nfu_plugin_runner_device_generic(FuPlugin *self,\n\t\t\t\tFuDevice *device,\n\t\t\t\tconst gchar *symbol_name,\n\t\t\t\tFuPluginDeviceFunc device_func,\n\t\t\t\tGError **error)\n{\n\tg_autoptr(GError) error_local = NULL;\n\n\t/* not enabled */\n\tif (fu_plugin_has_flag(self, FWUPD_PLUGIN_FLAG_DISABLED))\n\t\treturn TRUE;\n\n\t/* optional */\n\tif (device_func == NULL)\n\t\treturn TRUE;\n\tg_debug(\"%s(%s)\", symbol_name + 10, fu_plugin_get_name(self));\n\tif (!device_func(self, device, &error_local)) {\n\t\tif (error_local == NULL) {\n\t\t\tg_critical(\"unset plugin error in %s(%s)\",\n\t\t\t\t   fu_plugin_get_name(self),\n\t\t\t\t   symbol_name + 10);\n\t\t\tg_set_error_literal(&error_local,\n\t\t\t\t\t    FWUPD_ERROR,\n\t\t\t\t\t    FWUPD_ERROR_INTERNAL,\n\t\t\t\t\t    \"unspecified error\");\n\t\t}\n\t\tg_propagate_prefixed_error(error,\n\t\t\t\t\t   g_steal_pointer(&error_local),\n\t\t\t\t\t   \"failed to %s using %s: \",\n\t\t\t\t\t   symbol_name + 10,\n\t\t\t\t\t   fu_plugin_get_name(self));\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\nstatic gboolean\nfu_plugin_runner_device_generic_progress(FuPlugin *self,\n\t\t\t\t\t FuDevice *device,\n\t\t\t\t\t FuProgress *progress,\n\t\t\t\t\t const gchar *symbol_name,\n\t\t\t\t\t FuPluginDeviceProgressFunc device_func,\n\t\t\t\t\t GError **error)\n{\n\tg_autoptr(GError) error_local = NULL;\n\n\t/* not enabled */\n\tif (fu_plugin_has_flag(self, FWUPD_PLUGIN_FLAG_DISABLED))\n\t\treturn TRUE;\n\n\t/* optional */\n\tif (device_func == NULL)\n\t\treturn TRUE;\n\tg_debug(\"%s(%s)\", symbol_name + 10, fu_plugin_get_name(self));\n\tif (!device_func(self, device, progress, &error_local)) {\n\t\tif (error_local == NULL) {\n\t\t\tg_critical(\"unset plugin error in %s(%s)\",\n\t\t\t\t   fu_plugin_get_name(self),\n\t\t\t\t   symbol_name + 10);\n\t\t\tg_set_error_literal(&error_local,\n\t\t\t\t\t    FWUPD_ERROR,\n\t\t\t\t\t    FWUPD_ERROR_INTERNAL,\n\t\t\t\t\t    \"unspecified error\");\n\t\t}\n\t\tg_propagate_prefixed_error(error,\n\t\t\t\t\t   g_steal_pointer(&error_local),\n\t\t\t\t\t   \"failed to %s using %s: \",\n\t\t\t\t\t   symbol_name + 10,\n\t\t\t\t\t   fu_plugin_get_name(self));\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\nstatic gboolean\nfu_plugin_runner_flagged_device_generic(FuPlugin *self,\n\t\t\t\t\tFuDevice *device,\n\t\t\t\t\tFuProgress *progress,\n\t\t\t\t\tFwupdInstallFlags flags,\n\t\t\t\t\tconst gchar *symbol_name,\n\t\t\t\t\tFuPluginFlaggedDeviceFunc func,\n\t\t\t\t\tGError **error)\n{\n\tg_autoptr(GError) error_local = NULL;\n\n\t/* not enabled */\n\tif (fu_plugin_has_flag(self, FWUPD_PLUGIN_FLAG_DISABLED))\n\t\treturn TRUE;\n\n\t/* optional */\n\tif (func == NULL)\n\t\treturn TRUE;\n\tg_debug(\"%s(%s)\", symbol_name + 10, fu_plugin_get_name(self));\n\tif (!func(self, device, progress, flags, &error_local)) {\n\t\tif (error_local == NULL) {\n\t\t\tg_critical(\"unset plugin error in %s(%s)\",\n\t\t\t\t   fu_plugin_get_name(self),\n\t\t\t\t   symbol_name + 10);\n\t\t\tg_set_error_literal(&error_local,\n\t\t\t\t\t    FWUPD_ERROR,\n\t\t\t\t\t    FWUPD_ERROR_INTERNAL,\n\t\t\t\t\t    \"unspecified error\");\n\t\t}\n\t\tg_propagate_prefixed_error(error,\n\t\t\t\t\t   g_steal_pointer(&error_local),\n\t\t\t\t\t   \"failed to %s using %s: \",\n\t\t\t\t\t   symbol_name + 10,\n\t\t\t\t\t   fu_plugin_get_name(self));\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\nstatic gboolean\nfu_plugin_runner_device_array_generic(FuPlugin *self,\n\t\t\t\t      GPtrArray *devices,\n\t\t\t\t      const gchar *symbol_name,\n\t\t\t\t      FuPluginDeviceArrayFunc func,\n\t\t\t\t      GError **error)\n{\n\tg_autoptr(GError) error_local = NULL;\n\n\t/* not enabled */\n\tif (fu_plugin_has_flag(self, FWUPD_PLUGIN_FLAG_DISABLED))\n\t\treturn TRUE;\n\n\t/* optional */\n\tif (func == NULL)\n\t\treturn TRUE;\n\tg_debug(\"%s(%s)\", symbol_name + 10, fu_plugin_get_name(self));\n\tif (!func(self, devices, &error_local)) {\n\t\tif (error_local == NULL) {\n\t\t\tg_critical(\"unset plugin error in for %s(%s)\",\n\t\t\t\t   fu_plugin_get_name(self),\n\t\t\t\t   symbol_name + 10);\n\t\t\tg_set_error_literal(&error_local,\n\t\t\t\t\t    FWUPD_ERROR,\n\t\t\t\t\t    FWUPD_ERROR_INTERNAL,\n\t\t\t\t\t    \"unspecified error\");\n\t\t}\n\t\tg_propagate_prefixed_error(error,\n\t\t\t\t\t   g_steal_pointer(&error_local),\n\t\t\t\t\t   \"failed to %s using %s: \",\n\t\t\t\t\t   symbol_name + 10,\n\t\t\t\t\t   fu_plugin_get_name(self));\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\n/**\n * fu_plugin_runner_coldplug:\n * @self: a #FuPlugin\n * @progress: a #FuProgress\n * @error: (nullable): optional return location for an error\n *\n * Runs the coldplug routine for the plugin\n *\n * Returns: #TRUE for success, #FALSE for failure\n *\n * Since: 0.8.0\n **/\ngboolean\nfu_plugin_runner_coldplug(FuPlugin *self, FuProgress *progress, GError **error)\n{\n\tFuPluginPrivate *priv = GET_PRIVATE(self);\n\tFuPluginVfuncs *vfuncs = fu_plugin_get_vfuncs(self);\n\tg_autoptr(GError) error_local = NULL;\n\n\tg_return_val_if_fail(FU_IS_PLUGIN(self), FALSE);\n\n\t/* progress */\n\tfu_progress_set_name(progress, fu_plugin_get_name(self));\n\n\t/* not enabled */\n\tif (fu_plugin_has_flag(self, FWUPD_PLUGIN_FLAG_DISABLED))\n\t\treturn TRUE;\n\n\t/* no HwId */\n\tif (fu_plugin_has_flag(self, FWUPD_PLUGIN_FLAG_REQUIRE_HWID))\n\t\treturn TRUE;\n\n\t/* optional */\n\tif (vfuncs->coldplug == NULL)\n\t\treturn TRUE;\n\tg_debug(\"coldplug(%s)\", fu_plugin_get_name(self));\n\tif (!vfuncs->coldplug(self, progress, &error_local)) {\n\t\tif (error_local == NULL) {\n\t\t\tg_critical(\"unset plugin error in coldplug(%s)\", fu_plugin_get_name(self));\n\t\t\tg_set_error_literal(&error_local,\n\t\t\t\t\t    FWUPD_ERROR,\n\t\t\t\t\t    FWUPD_ERROR_INTERNAL,\n\t\t\t\t\t    \"unspecified error\");\n\t\t}\n\t\t/* coldplug failed, but we might have already added devices to the daemon... */\n\t\tif (priv->devices != NULL) {\n\t\t\tfor (guint i = 0; i < priv->devices->len; i++) {\n\t\t\t\tFuDevice *device = g_ptr_array_index(priv->devices, i);\n\t\t\t\tg_warning(\"removing device %s due to failed coldplug\",\n\t\t\t\t\t  fu_device_get_id(device));\n\t\t\t\tfu_plugin_device_remove(self, device);\n\t\t\t}\n\t\t}\n\t\tg_propagate_prefixed_error(error,\n\t\t\t\t\t   g_steal_pointer(&error_local),\n\t\t\t\t\t   \"failed to coldplug using %s: \",\n\t\t\t\t\t   fu_plugin_get_name(self));\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\n/**\n * fu_plugin_runner_composite_prepare:\n * @self: a #FuPlugin\n * @devices: (element-type FuDevice): an array of devices\n * @error: (nullable): optional return location for an error\n *\n * Runs the composite_prepare routine for the plugin\n *\n * Returns: #TRUE for success, #FALSE for failure\n *\n * Since: 1.0.9\n **/\ngboolean\nfu_plugin_runner_composite_prepare(FuPlugin *self, GPtrArray *devices, GError **error)\n{\n\tFuPluginVfuncs *vfuncs = fu_plugin_get_vfuncs(self);\n\treturn fu_plugin_runner_device_array_generic(self,\n\t\t\t\t\t\t     devices,\n\t\t\t\t\t\t     \"fu_plugin_composite_prepare\",\n\t\t\t\t\t\t     vfuncs->composite_prepare,\n\t\t\t\t\t\t     error);\n}\n\n/**\n * fu_plugin_runner_composite_cleanup:\n * @self: a #FuPlugin\n * @devices: (element-type FuDevice): an array of devices\n * @error: (nullable): optional return location for an error\n *\n * Runs the composite_cleanup routine for the plugin\n *\n * Returns: #TRUE for success, #FALSE for failure\n *\n * Since: 1.0.9\n **/\ngboolean\nfu_plugin_runner_composite_cleanup(FuPlugin *self, GPtrArray *devices, GError **error)\n{\n\tFuPluginVfuncs *vfuncs = fu_plugin_get_vfuncs(self);\n\treturn fu_plugin_runner_device_array_generic(self,\n\t\t\t\t\t\t     devices,\n\t\t\t\t\t\t     \"fu_plugin_composite_cleanup\",\n\t\t\t\t\t\t     vfuncs->composite_cleanup,\n\t\t\t\t\t\t     error);\n}\n\n/**\n * fu_plugin_runner_prepare:\n * @self: a #FuPlugin\n * @device: a device\n * @progress: a #FuProgress\n * @flags: install flags\n * @error: (nullable): optional return location for an error\n *\n * Runs the update_prepare routine for the plugin\n *\n * Returns: #TRUE for success, #FALSE for failure\n *\n * Since: 1.7.0\n **/\ngboolean\nfu_plugin_runner_prepare(FuPlugin *self,\n\t\t\t FuDevice *device,\n\t\t\t FuProgress *progress,\n\t\t\t FwupdInstallFlags flags,\n\t\t\t GError **error)\n{\n\tFuPluginVfuncs *vfuncs = fu_plugin_get_vfuncs(self);\n\tfu_device_add_backend_tag(device, \"prepare\");\n\treturn fu_plugin_runner_flagged_device_generic(self,\n\t\t\t\t\t\t       device,\n\t\t\t\t\t\t       progress,\n\t\t\t\t\t\t       flags,\n\t\t\t\t\t\t       \"fu_plugin_prepare\",\n\t\t\t\t\t\t       vfuncs->prepare,\n\t\t\t\t\t\t       error);\n}\n\n/**\n * fu_plugin_runner_cleanup:\n * @self: a #FuPlugin\n * @device: a device\n * @progress: a #FuProgress\n * @flags: install flags\n * @error: (nullable): optional return location for an error\n *\n * Runs the update_cleanup routine for the plugin\n *\n * Returns: #TRUE for success, #FALSE for failure\n *\n * Since: 1.7.0\n **/\ngboolean\nfu_plugin_runner_cleanup(FuPlugin *self,\n\t\t\t FuDevice *device,\n\t\t\t FuProgress *progress,\n\t\t\t FwupdInstallFlags flags,\n\t\t\t GError **error)\n{\n\tFuPluginVfuncs *vfuncs = fu_plugin_get_vfuncs(self);\n\tfu_device_add_backend_tag(device, \"cleanup\");\n\treturn fu_plugin_runner_flagged_device_generic(self,\n\t\t\t\t\t\t       device,\n\t\t\t\t\t\t       progress,\n\t\t\t\t\t\t       flags,\n\t\t\t\t\t\t       \"fu_plugin_cleanup\",\n\t\t\t\t\t\t       vfuncs->cleanup,\n\t\t\t\t\t\t       error);\n}\n\n/**\n * fu_plugin_runner_attach:\n * @self: a #FuPlugin\n * @device: a device\n * @progress: a #FuProgress\n * @error: (nullable): optional return location for an error\n *\n * Runs the update_attach routine for the plugin\n *\n * Returns: #TRUE for success, #FALSE for failure\n *\n * Since: 1.7.0\n **/\ngboolean\nfu_plugin_runner_attach(FuPlugin *self, FuDevice *device, FuProgress *progress, GError **error)\n{\n\tFuPluginVfuncs *vfuncs = fu_plugin_get_vfuncs(self);\n\tfu_device_add_backend_tag(device, \"attach\");\n\treturn fu_plugin_runner_device_generic_progress(\n\t    self,\n\t    device,\n\t    progress,\n\t    \"fu_plugin_attach\",\n\t    vfuncs->attach != NULL ? vfuncs->attach : fu_plugin_device_attach,\n\t    error);\n}\n\n/**\n * fu_plugin_runner_detach:\n * @self: a #FuPlugin\n * @device: a device\n * @progress: a #FuProgress\n * @error: (nullable): optional return location for an error\n *\n * Runs the update_detach routine for the plugin\n *\n * Returns: #TRUE for success, #FALSE for failure\n *\n * Since: 1.7.0\n **/\ngboolean\nfu_plugin_runner_detach(FuPlugin *self, FuDevice *device, FuProgress *progress, GError **error)\n{\n\tFuPluginVfuncs *vfuncs = fu_plugin_get_vfuncs(self);\n\tfu_device_add_backend_tag(device, \"detach\");\n\treturn fu_plugin_runner_device_generic_progress(\n\t    self,\n\t    device,\n\t    progress,\n\t    \"fu_plugin_detach\",\n\t    vfuncs->detach != NULL ? vfuncs->detach : fu_plugin_device_detach,\n\t    error);\n}\n\n/**\n * fu_plugin_runner_reload:\n * @self: a #FuPlugin\n * @device: a device\n * @error: (nullable): optional return location for an error\n *\n * Runs reload routine for a device\n *\n * Returns: #TRUE for success, #FALSE for failure\n *\n * Since: 1.7.0\n **/\ngboolean\nfu_plugin_runner_reload(FuPlugin *self, FuDevice *device, GError **error)\n{\n\tFuDevice *proxy = fu_device_get_proxy_with_fallback(device);\n\tg_autoptr(FuDeviceLocker) locker = NULL;\n\n\t/* not enabled */\n\tif (fu_plugin_has_flag(self, FWUPD_PLUGIN_FLAG_DISABLED))\n\t\treturn TRUE;\n\n\t/* no object loaded */\n\tlocker = fu_device_locker_new(proxy, error);\n\tif (locker == NULL)\n\t\treturn FALSE;\n\tfu_device_add_backend_tag(device, \"reload\");\n\treturn fu_device_reload(device, error);\n}\n\n/**\n * fu_plugin_runner_add_security_attrs:\n * @self: a #FuPlugin\n * @attrs: a security attribute\n *\n * Runs the `add_security_attrs()` routine for the plugin\n *\n * Since: 1.5.0\n **/\nvoid\nfu_plugin_runner_add_security_attrs(FuPlugin *self, FuSecurityAttrs *attrs)\n{\n\tFuPluginVfuncs *vfuncs = fu_plugin_get_vfuncs(self);\n\n\t/* optional, but gets called even for disabled plugins */\n\tif (vfuncs->add_security_attrs == NULL)\n\t\treturn;\n\tg_debug(\"add_security_attrs(%s)\", fu_plugin_get_name(self));\n\tvfuncs->add_security_attrs(self, attrs);\n}\n\n/**\n * fu_plugin_add_device_gtype:\n * @self: a #FuPlugin\n * @device_gtype: a #GType, e.g. `FU_TYPE_DEVICE`\n *\n * Adds the device #GType which is used when creating devices.\n *\n * If this method is used then fu_plugin_backend_device_added() is not called, and\n * instead the object is created in the daemon for the plugin.\n *\n * Plugins can use this method only in fu_plugin_init()\n *\n * Since: 1.6.0\n **/\nvoid\nfu_plugin_add_device_gtype(FuPlugin *self, GType device_gtype)\n{\n\tFuPluginPrivate *priv = GET_PRIVATE(self);\n\n\t/* create as required */\n\tif (priv->device_gtypes == NULL)\n\t\tpriv->device_gtypes = g_array_new(FALSE, FALSE, sizeof(GType));\n\n\t/* ensure (to allow quirks to use it) then add */\n\tg_type_ensure(device_gtype);\n\tg_array_append_val(priv->device_gtypes, device_gtype);\n}\n\nstatic gchar *\nfu_common_string_uncamelcase(const gchar *str)\n{\n\tGString *tmp = g_string_new(NULL);\n\tfor (guint i = 0; str[i] != '\\0'; i++) {\n\t\tif (g_ascii_islower(str[i]) || g_ascii_isdigit(str[i])) {\n\t\t\tg_string_append_c(tmp, str[i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (i > 0)\n\t\t\tg_string_append_c(tmp, '-');\n\t\tg_string_append_c(tmp, g_ascii_tolower(str[i]));\n\t}\n\treturn g_string_free(tmp, FALSE);\n}\n\nstatic gboolean\nfu_plugin_check_amdgpu_dpaux(FuPlugin *self, GError **error)\n{\n#ifdef __linux__\n\tgsize bufsz = 0;\n\tg_autofree gchar *buf = NULL;\n\tg_auto(GStrv) lines = NULL;\n\n\t/* no module support in the kernel, we can't test for amdgpu module */\n\tif (!g_file_test(\"/proc/modules\", G_FILE_TEST_EXISTS))\n\t\treturn TRUE;\n\tif (!g_file_get_contents(\"/proc/modules\", &buf, &bufsz, error))\n\t\treturn FALSE;\n\tlines = g_strsplit(buf, \"\\n\", -1);\n\tfor (guint i = 0; lines[i] != NULL; i++) {\n\t\tif (g_str_has_prefix(lines[i], \"amdgpu \")) {\n\t\t\t/* released 2019! */\n\t\t\treturn fu_kernel_check_version(\"5.2.0\", error);\n\t\t}\n\t}\n#endif\n\treturn TRUE;\n}\n\n/**\n * fu_plugin_add_udev_subsystem:\n * @self: a #FuPlugin\n * @subsystem: a subsystem name, e.g. `pciport`\n *\n * Registers the udev subsystem to be watched by the daemon.\n *\n * Plugins can use this method only in fu_plugin_init()\n *\n * Since: 1.6.2\n **/\nvoid\nfu_plugin_add_udev_subsystem(FuPlugin *self, const gchar *subsystem)\n{\n\tFuPluginPrivate *priv = GET_PRIVATE(self);\n\n\t/* see https://github.com/fwupd/fwupd/issues/1121 for more details */\n\tif (g_strcmp0(subsystem, \"drm_dp_aux_dev\") == 0) {\n\t\tg_autoptr(GError) error = NULL;\n\t\tif (!fu_plugin_check_amdgpu_dpaux(self, &error)) {\n\t\t\tg_warning(\"failed to add subsystem: %s\", error->message);\n\t\t\tfu_plugin_add_flag(self, FWUPD_PLUGIN_FLAG_DISABLED);\n\t\t\tfu_plugin_add_flag(self, FWUPD_PLUGIN_FLAG_KERNEL_TOO_OLD);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* proxy */\n\tfu_context_add_udev_subsystem(priv->ctx, subsystem);\n}\n\n/**\n * fu_plugin_add_firmware_gtype:\n * @self: a #FuPlugin\n * @id: (nullable): an optional string describing the type, e.g. `ihex`\n * @gtype: a #GType e.g. `FU_TYPE_FOO_FIRMWARE`\n *\n * Adds a firmware #GType which is used when creating devices. If @id is not\n * specified then it is guessed using the #GType name.\n *\n * Plugins can use this method only in fu_plugin_init()\n *\n * Since: 1.3.3\n **/\nvoid\nfu_plugin_add_firmware_gtype(FuPlugin *self, const gchar *id, GType gtype)\n{\n\tFuPluginPrivate *priv = GET_PRIVATE(self);\n\tg_autofree gchar *id_safe = NULL;\n\tif (id != NULL) {\n\t\tid_safe = g_strdup(id);\n\t} else {\n\t\tg_autoptr(GString) str = g_string_new(g_type_name(gtype));\n\t\tif (g_str_has_prefix(str->str, \"Fu\"))\n\t\t\tg_string_erase(str, 0, 2);\n\t\tfu_string_replace(str, \"Firmware\", \"\");\n\t\tid_safe = fu_common_string_uncamelcase(str->str);\n\t}\n\tfu_context_add_firmware_gtype(priv->ctx, id_safe, gtype);\n}\n\nstatic gboolean\nfu_plugin_check_supported_device(FuPlugin *self, FuDevice *device)\n{\n\tGPtrArray *instance_ids = fu_device_get_instance_ids(device);\n\tfor (guint i = 0; i < instance_ids->len; i++) {\n\t\tconst gchar *instance_id = g_ptr_array_index(instance_ids, i);\n\t\tg_autofree gchar *guid = fwupd_guid_hash_string(instance_id);\n\t\tif (fu_plugin_check_supported(self, guid))\n\t\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}\n\nstatic gboolean\nfu_plugin_backend_device_added(FuPlugin *self, FuDevice *device, GError **error)\n{\n\tFuDevice *proxy;\n\tFuPluginPrivate *priv = GET_PRIVATE(self);\n\tGType device_gtype = fu_device_get_specialized_gtype(FU_DEVICE(device));\n\tg_autoptr(FuDevice) dev = NULL;\n\tg_autoptr(FuDeviceLocker) locker = NULL;\n\n\t/* fall back to plugin default */\n\tif (device_gtype == G_TYPE_INVALID) {\n\t\tif (priv->device_gtypes->len > 1) {\n\t\t\tg_set_error_literal(error,\n\t\t\t\t\t    FWUPD_ERROR,\n\t\t\t\t\t    FWUPD_ERROR_INTERNAL,\n\t\t\t\t\t    \"too many GTypes to choose a default\");\n\t\t\treturn FALSE;\n\t\t}\n\t\tdevice_gtype = g_array_index(priv->device_gtypes, GType, 0);\n\t}\n\n\t/* create new device and incorporate existing properties */\n\tdev = g_object_new(device_gtype, \"context\", priv->ctx, NULL);\n\tfu_device_incorporate(dev, FU_DEVICE(device));\n\tif (!fu_plugin_runner_device_created(self, dev, error))\n\t\treturn FALSE;\n\n\t/* there are a lot of different devices that match, but not all respond\n\t * well to opening -- so limit some ones with issued updates */\n\tif (fu_device_has_internal_flag(dev, FU_DEVICE_INTERNAL_FLAG_ONLY_SUPPORTED)) {\n\t\tif (!fu_device_probe(dev, error))\n\t\t\treturn FALSE;\n\t\tfu_device_convert_instance_ids(dev);\n\t\tif (!fu_plugin_check_supported_device(self, dev)) {\n\t\t\tg_autofree gchar *guids = fu_device_get_guids_as_str(dev);\n\t\t\tg_debug(\"%s has no updates, so ignoring device\", guids);\n\t\t\treturn TRUE;\n\t\t}\n\t}\n\n\t/* open and add */\n\tproxy = fu_device_get_proxy(device);\n\tif (proxy != NULL) {\n\t\tg_autoptr(FuDeviceLocker) locker_proxy = NULL;\n\t\tlocker_proxy = fu_device_locker_new(proxy, error);\n\t\tif (locker_proxy == NULL)\n\t\t\treturn FALSE;\n\t}\n\tlocker = fu_device_locker_new(dev, error);\n\tif (locker == NULL)\n\t\treturn FALSE;\n\tfu_plugin_device_add(self, dev);\n\tfu_plugin_runner_device_added(self, dev);\n\treturn TRUE;\n}\n\n/**\n * fu_plugin_runner_backend_device_added:\n * @self: a #FuPlugin\n * @device: a device\n * @error: (nullable): optional return location for an error\n *\n * Call the backend_device_added routine for the plugin\n *\n * Returns: #TRUE for success, #FALSE for failure\n *\n * Since: 1.5.6\n **/\ngboolean\nfu_plugin_runner_backend_device_added(FuPlugin *self, FuDevice *device, GError **error)\n{\n\tFuPluginPrivate *priv = GET_PRIVATE(self);\n\tFuPluginVfuncs *vfuncs = fu_plugin_get_vfuncs(self);\n\tg_autoptr(GError) error_local = NULL;\n\n\tg_return_val_if_fail(FU_IS_PLUGIN(self), FALSE);\n\tg_return_val_if_fail(FU_IS_DEVICE(device), FALSE);\n\tg_return_val_if_fail(error == NULL || *error == NULL, FALSE);\n\n\t/* not enabled */\n\tif (fu_plugin_has_flag(self, FWUPD_PLUGIN_FLAG_DISABLED))\n\t\treturn TRUE;\n\n\t/* optional */\n\tif (vfuncs->backend_device_added == NULL) {\n\t\tif (priv->device_gtypes != NULL ||\n\t\t    fu_device_get_specialized_gtype(device) != G_TYPE_INVALID) {\n\t\t\treturn fu_plugin_backend_device_added(self, device, error);\n\t\t}\n\t\tg_set_error_literal(error,\n\t\t\t\t    FWUPD_ERROR,\n\t\t\t\t    FWUPD_ERROR_INTERNAL,\n\t\t\t\t    \"No device GType set\");\n\t\treturn FALSE;\n\t}\n\tg_debug(\"backend_device_added(%s)\", fu_plugin_get_name(self));\n\tif (!vfuncs->backend_device_added(self, device, &error_local)) {\n\t\tif (error_local == NULL) {\n\t\t\tg_critical(\"unset plugin error in backend_device_added(%s)\",\n\t\t\t\t   fu_plugin_get_name(self));\n\t\t\tg_set_error_literal(&error_local,\n\t\t\t\t\t    FWUPD_ERROR,\n\t\t\t\t\t    FWUPD_ERROR_INTERNAL,\n\t\t\t\t\t    \"unspecified error\");\n\t\t}\n\t\tg_propagate_prefixed_error(error,\n\t\t\t\t\t   g_steal_pointer(&error_local),\n\t\t\t\t\t   \"failed to add device using on %s: \",\n\t\t\t\t\t   fu_plugin_get_name(self));\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\n/**\n * fu_plugin_runner_backend_device_changed:\n * @self: a #FuPlugin\n * @device: a device\n * @error: (nullable): optional return location for an error\n *\n * Call the backend_device_changed routine for the plugin\n *\n * Returns: #TRUE for success, #FALSE for failure\n *\n * Since: 1.5.6\n **/\ngboolean\nfu_plugin_runner_backend_device_changed(FuPlugin *self, FuDevice *device, GError **error)\n{\n\tFuPluginVfuncs *vfuncs = fu_plugin_get_vfuncs(self);\n\tg_autoptr(GError) error_local = NULL;\n\n\tg_return_val_if_fail(FU_IS_PLUGIN(self), FALSE);\n\tg_return_val_if_fail(FU_IS_DEVICE(device), FALSE);\n\tg_return_val_if_fail(error == NULL || *error == NULL, FALSE);\n\n\t/* not enabled */\n\tif (fu_plugin_has_flag(self, FWUPD_PLUGIN_FLAG_DISABLED))\n\t\treturn TRUE;\n\n\t/* optional */\n\tif (vfuncs->backend_device_changed == NULL)\n\t\treturn TRUE;\n\tg_debug(\"udev_device_changed(%s)\", fu_plugin_get_name(self));\n\tif (!vfuncs->backend_device_changed(self, device, &error_local)) {\n\t\tif (error_local == NULL) {\n\t\t\tg_critical(\"unset plugin error in udev_device_changed(%s)\",\n\t\t\t\t   fu_plugin_get_name(self));\n\t\t\tg_set_error_literal(&error_local,\n\t\t\t\t\t    FWUPD_ERROR,\n\t\t\t\t\t    FWUPD_ERROR_INTERNAL,\n\t\t\t\t\t    \"unspecified error\");\n\t\t}\n\t\tg_propagate_prefixed_error(error,\n\t\t\t\t\t   g_steal_pointer(&error_local),\n\t\t\t\t\t   \"failed to change device on %s: \",\n\t\t\t\t\t   fu_plugin_get_name(self));\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\n/**\n * fu_plugin_runner_device_added:\n * @self: a #FuPlugin\n * @device: a device\n *\n * Call the device_added routine for the plugin\n *\n * Since: 1.5.0\n **/\nvoid\nfu_plugin_runner_device_added(FuPlugin *self, FuDevice *device)\n{\n\tFuPluginVfuncs *vfuncs = fu_plugin_get_vfuncs(self);\n\n\t/* not enabled */\n\tif (fu_plugin_has_flag(self, FWUPD_PLUGIN_FLAG_DISABLED))\n\t\treturn;\n\n\t/* optional */\n\tif (vfuncs->device_added == NULL)\n\t\treturn;\n\tg_debug(\"fu_plugin_device_added(%s)\", fu_plugin_get_name(self));\n\tvfuncs->device_added(self, device);\n}\n\n/**\n * fu_plugin_runner_device_removed:\n * @self: a #FuPlugin\n * @device: a device\n *\n * Call the device_removed routine for the plugin\n *\n * Since: 1.1.2\n **/\nvoid\nfu_plugin_runner_device_removed(FuPlugin *self, FuDevice *device)\n{\n\tFuPluginVfuncs *vfuncs = fu_plugin_get_vfuncs(self);\n\tg_autoptr(GError) error_local = NULL;\n\n\tif (!fu_plugin_runner_device_generic(self,\n\t\t\t\t\t     device,\n\t\t\t\t\t     \"fu_plugin_backend_device_removed\",\n\t\t\t\t\t     vfuncs->backend_device_removed,\n\t\t\t\t\t     &error_local))\n\t\tg_warning(\"%s\", error_local->message);\n}\n\n/**\n * fu_plugin_runner_device_register:\n * @self: a #FuPlugin\n * @device: a device\n *\n * Call the device_registered routine for the plugin\n *\n * Since: 0.9.7\n **/\nvoid\nfu_plugin_runner_device_register(FuPlugin *self, FuDevice *device)\n{\n\tFuPluginVfuncs *vfuncs = fu_plugin_get_vfuncs(self);\n\n\t/* not enabled */\n\tif (fu_plugin_has_flag(self, FWUPD_PLUGIN_FLAG_DISABLED))\n\t\treturn;\n\n\t/* optional */\n\tif (vfuncs->device_registered != NULL) {\n\t\tg_debug(\"fu_plugin_device_registered(%s)\", fu_plugin_get_name(self));\n\t\tvfuncs->device_registered(self, device);\n\t}\n}\n\n/**\n * fu_plugin_runner_device_created:\n * @self: a #FuPlugin\n * @device: a device\n * @error: (nullable): optional return location for an error\n *\n * Call the device_created routine for the plugin\n *\n * Returns: #TRUE for success, #FALSE for failure\n *\n * Since: 1.4.0\n **/\ngboolean\nfu_plugin_runner_device_created(FuPlugin *self, FuDevice *device, GError **error)\n{\n\tFuPluginVfuncs *vfuncs = fu_plugin_get_vfuncs(self);\n\n\tg_return_val_if_fail(FU_IS_PLUGIN(self), FALSE);\n\tg_return_val_if_fail(FU_IS_DEVICE(device), FALSE);\n\tg_return_val_if_fail(error == NULL || *error == NULL, FALSE);\n\n\t/* not enabled */\n\tif (fu_plugin_has_flag(self, FWUPD_PLUGIN_FLAG_DISABLED))\n\t\treturn TRUE;\n\n\t/* optional */\n\tif (vfuncs->device_created == NULL)\n\t\treturn TRUE;\n\tg_debug(\"fu_plugin_device_created(%s)\", fu_plugin_get_name(self));\n\treturn vfuncs->device_created(self, device, error);\n}\n\n/**\n * fu_plugin_runner_verify:\n * @self: a #FuPlugin\n * @device: a device\n * @progress: a #FuProgress\n * @flags: verify flags\n * @error: (nullable): optional return location for an error\n *\n * Call into the plugin's verify routine\n *\n * Returns: #TRUE for success, #FALSE for failure\n *\n * Since: 0.8.0\n **/\ngboolean\nfu_plugin_runner_verify(FuPlugin *self,\n\t\t\tFuDevice *device,\n\t\t\tFuProgress *progress,\n\t\t\tFuPluginVerifyFlags flags,\n\t\t\tGError **error)\n{\n\tFuPluginVfuncs *vfuncs = fu_plugin_get_vfuncs(self);\n\tGPtrArray *checksums;\n\tg_autoptr(GError) error_local = NULL;\n\n\tg_return_val_if_fail(FU_IS_PLUGIN(self), FALSE);\n\tg_return_val_if_fail(FU_IS_DEVICE(device), FALSE);\n\tg_return_val_if_fail(FU_IS_PROGRESS(progress), FALSE);\n\tg_return_val_if_fail(error == NULL || *error == NULL, FALSE);\n\n\t/* not enabled */\n\tif (fu_plugin_has_flag(self, FWUPD_PLUGIN_FLAG_DISABLED))\n\t\treturn TRUE;\n\n\t/* optional */\n\tif (vfuncs->verify == NULL) {\n\t\tif (!fu_device_has_flag(device, FWUPD_DEVICE_FLAG_CAN_VERIFY)) {\n\t\t\tg_set_error(error,\n\t\t\t\t    FWUPD_ERROR,\n\t\t\t\t    FWUPD_ERROR_NOT_SUPPORTED,\n\t\t\t\t    \"device %s does not support verification\",\n\t\t\t\t    fu_device_get_id(device));\n\t\t\treturn FALSE;\n\t\t}\n\t\treturn fu_plugin_device_read_firmware(self, device, progress, error);\n\t}\n\n\t/* clear any existing verification checksums */\n\tchecksums = fu_device_get_checksums(device);\n\tg_ptr_array_set_size(checksums, 0);\n\n\t/* run additional detach */\n\tif (!fu_plugin_runner_device_generic_progress(\n\t\tself,\n\t\tdevice,\n\t\tprogress,\n\t\t\"fu_plugin_detach\",\n\t\tvfuncs->detach != NULL ? vfuncs->detach : fu_plugin_device_detach,\n\t\terror))\n\t\treturn FALSE;\n\n\t/* run vfunc */\n\tg_debug(\"verify(%s)\", fu_plugin_get_name(self));\n\tif (!vfuncs->verify(self, device, progress, flags, &error_local)) {\n\t\tg_autoptr(GError) error_attach = NULL;\n\t\tif (error_local == NULL) {\n\t\t\tg_critical(\"unset plugin error in verify(%s)\", fu_plugin_get_name(self));\n\t\t\tg_set_error_literal(&error_local,\n\t\t\t\t\t    FWUPD_ERROR,\n\t\t\t\t\t    FWUPD_ERROR_INTERNAL,\n\t\t\t\t\t    \"unspecified error\");\n\t\t}\n\t\tg_propagate_prefixed_error(error,\n\t\t\t\t\t   g_steal_pointer(&error_local),\n\t\t\t\t\t   \"failed to verify using %s: \",\n\t\t\t\t\t   fu_plugin_get_name(self));\n\t\t/* make the device \"work\" again, but don't prefix the error */\n\t\tif (!fu_plugin_runner_device_generic_progress(\n\t\t\tself,\n\t\t\tdevice,\n\t\t\tprogress,\n\t\t\t\"fu_plugin_attach\",\n\t\t\tvfuncs->attach != NULL ? vfuncs->attach : fu_plugin_device_attach,\n\t\t\t&error_attach)) {\n\t\t\tg_warning(\"failed to attach whilst aborting verify(): %s\",\n\t\t\t\t  error_attach->message);\n\t\t}\n\t\treturn FALSE;\n\t}\n\n\t/* run optional attach */\n\tif (!fu_plugin_runner_device_generic_progress(\n\t\tself,\n\t\tdevice,\n\t\tprogress,\n\t\t\"fu_plugin_attach\",\n\t\tvfuncs->attach != NULL ? vfuncs->attach : fu_plugin_device_attach,\n\t\terror))\n\t\treturn FALSE;\n\n\t/* success */\n\treturn TRUE;\n}\n\n/**\n * fu_plugin_runner_activate:\n * @self: a #FuPlugin\n * @device: a device\n * @progress: a #FuProgress\n * @error: (nullable): optional return location for an error\n *\n * Call into the plugin's activate routine\n *\n * Returns: #TRUE for success, #FALSE for failure\n *\n * Since: 1.2.6\n **/\ngboolean\nfu_plugin_runner_activate(FuPlugin *self, FuDevice *device, FuProgress *progress, GError **error)\n{\n\tFuPluginVfuncs *vfuncs = fu_plugin_get_vfuncs(self);\n\tguint64 flags;\n\n\tg_return_val_if_fail(FU_IS_PLUGIN(self), FALSE);\n\tg_return_val_if_fail(FU_IS_DEVICE(device), FALSE);\n\tg_return_val_if_fail(FU_IS_PROGRESS(progress), FALSE);\n\tg_return_val_if_fail(error == NULL || *error == NULL, FALSE);\n\n\t/* final check */\n\tflags = fu_device_get_flags(device);\n\tif ((flags & FWUPD_DEVICE_FLAG_NEEDS_ACTIVATION) == 0) {\n\t\tg_set_error(error,\n\t\t\t    FWUPD_ERROR,\n\t\t\t    FWUPD_ERROR_NOT_SUPPORTED,\n\t\t\t    \"Device %s does not need activation\",\n\t\t\t    fu_device_get_id(device));\n\t\treturn FALSE;\n\t}\n\n\t/* run vfunc */\n\tfu_device_add_backend_tag(device, \"activate\");\n\tif (!fu_plugin_runner_device_generic_progress(\n\t\tself,\n\t\tdevice,\n\t\tprogress,\n\t\t\"fu_plugin_activate\",\n\t\tvfuncs->activate != NULL ? vfuncs->activate : fu_plugin_device_activate,\n\t\terror))\n\t\treturn FALSE;\n\n\t/* update with correct flags */\n\tfu_device_remove_flag(device, FWUPD_DEVICE_FLAG_NEEDS_ACTIVATION);\n\tfu_device_set_modified(device, (guint64)g_get_real_time() / G_USEC_PER_SEC);\n\treturn TRUE;\n}\n\n/**\n * fu_plugin_runner_unlock:\n * @self: a #FuPlugin\n * @device: a device\n * @error: (nullable): optional return location for an error\n *\n * Call into the plugin's unlock routine\n *\n * Returns: #TRUE for success, #FALSE for failure\n *\n * Since: 0.8.0\n **/\ngboolean\nfu_plugin_runner_unlock(FuPlugin *self, FuDevice *device, GError **error)\n{\n\tFuPluginVfuncs *vfuncs = fu_plugin_get_vfuncs(self);\n\tguint64 flags;\n\n\tg_return_val_if_fail(FU_IS_PLUGIN(self), FALSE);\n\tg_return_val_if_fail(FU_IS_DEVICE(device), FALSE);\n\tg_return_val_if_fail(error == NULL || *error == NULL, FALSE);\n\n\t/* final check */\n\tflags = fu_device_get_flags(device);\n\tif ((flags & FWUPD_DEVICE_FLAG_LOCKED) == 0) {\n\t\tg_set_error(error,\n\t\t\t    FWUPD_ERROR,\n\t\t\t    FWUPD_ERROR_NOT_SUPPORTED,\n\t\t\t    \"Device %s is not locked\",\n\t\t\t    fu_device_get_id(device));\n\t\treturn FALSE;\n\t}\n\n\t/* run vfunc */\n\tfu_device_add_backend_tag(device, \"unlock\");\n\tif (!fu_plugin_runner_device_generic(self,\n\t\t\t\t\t     device,\n\t\t\t\t\t     \"fu_plugin_unlock\",\n\t\t\t\t\t     vfuncs->unlock,\n\t\t\t\t\t     error))\n\t\treturn FALSE;\n\n\t/* update with correct flags */\n\tfu_device_remove_flag(device, FWUPD_DEVICE_FLAG_LOCKED);\n\tfu_device_set_modified(device, (guint64)g_get_real_time() / G_USEC_PER_SEC);\n\treturn TRUE;\n}\n\n/**\n * fu_plugin_runner_write_firmware:\n * @self: a #FuPlugin\n * @device: a device\n * @blob_fw: a data blob\n * @progress: a #FuProgress\n * @flags: install flags\n * @error: (nullable): optional return location for an error\n *\n * Call into the plugin's write firmware routine\n *\n * Returns: #TRUE for success, #FALSE for failure\n *\n * Since: 1.7.0\n **/\ngboolean\nfu_plugin_runner_write_firmware(FuPlugin *self,\n\t\t\t\tFuDevice *device,\n\t\t\t\tGBytes *blob_fw,\n\t\t\t\tFuProgress *progress,\n\t\t\t\tFwupdInstallFlags flags,\n\t\t\t\tGError **error)\n{\n\tFuPluginVfuncs *vfuncs = fu_plugin_get_vfuncs(self);\n\tg_autoptr(GError) error_local = NULL;\n\n\tg_return_val_if_fail(FU_IS_PLUGIN(self), FALSE);\n\tg_return_val_if_fail(FU_IS_DEVICE(device), FALSE);\n\tg_return_val_if_fail(FU_IS_PROGRESS(progress), FALSE);\n\tg_return_val_if_fail(error == NULL || *error == NULL, FALSE);\n\n\t/* not enabled */\n\tif (fu_plugin_has_flag(self, FWUPD_PLUGIN_FLAG_DISABLED)) {\n\t\tg_debug(\"plugin not enabled, skipping\");\n\t\treturn TRUE;\n\t}\n\tfu_device_add_backend_tag(device, \"write-firmware\");\n\n\t/* optional */\n\tif (vfuncs->write_firmware == NULL) {\n\t\tg_debug(\"superclassed write_firmware(%s)\", fu_plugin_get_name(self));\n\t\treturn fu_plugin_device_write_firmware(self,\n\t\t\t\t\t\t       device,\n\t\t\t\t\t\t       blob_fw,\n\t\t\t\t\t\t       progress,\n\t\t\t\t\t\t       flags,\n\t\t\t\t\t\t       error);\n\t}\n\n\t/* online */\n\tif (!vfuncs->write_firmware(self, device, blob_fw, progress, flags, &error_local)) {\n\t\tif (error_local == NULL) {\n\t\t\tg_critical(\"unset plugin error in update(%s)\", fu_plugin_get_name(self));\n\t\t\tg_set_error_literal(&error_local,\n\t\t\t\t\t    FWUPD_ERROR,\n\t\t\t\t\t    FWUPD_ERROR_INTERNAL,\n\t\t\t\t\t    \"unspecified error\");\n\t\t\treturn FALSE;\n\t\t}\n\t\tfu_device_set_update_error(device, error_local->message);\n\t\tg_propagate_error(error, g_steal_pointer(&error_local));\n\t\treturn FALSE;\n\t}\n\n\t/* no longer valid */\n\tif (!fu_device_has_flag(device, FWUPD_DEVICE_FLAG_NEEDS_REBOOT) &&\n\t    !fu_device_has_flag(device, FWUPD_DEVICE_FLAG_NEEDS_SHUTDOWN)) {\n\t\tGPtrArray *checksums = fu_device_get_checksums(device);\n\t\tg_ptr_array_set_size(checksums, 0);\n\t}\n\n\t/* success */\n\treturn TRUE;\n}\n\n/**\n * fu_plugin_runner_clear_results:\n * @self: a #FuPlugin\n * @device: a device\n * @error: (nullable): optional return location for an error\n *\n * Call into the plugin's clear results routine\n *\n * Returns: #TRUE for success, #FALSE for failure\n *\n * Since: 0.8.0\n **/\ngboolean\nfu_plugin_runner_clear_results(FuPlugin *self, FuDevice *device, GError **error)\n{\n\tFuPluginVfuncs *vfuncs = fu_plugin_get_vfuncs(self);\n\tg_autoptr(GError) error_local = NULL;\n\n\tg_return_val_if_fail(FU_IS_PLUGIN(self), FALSE);\n\tg_return_val_if_fail(FU_IS_DEVICE(device), FALSE);\n\tg_return_val_if_fail(error == NULL || *error == NULL, FALSE);\n\n\t/* not enabled */\n\tif (fu_plugin_has_flag(self, FWUPD_PLUGIN_FLAG_DISABLED))\n\t\treturn TRUE;\n\n\t/* optional */\n\tif (vfuncs->clear_results == NULL)\n\t\treturn TRUE;\n\tg_debug(\"clear_result(%s)\", fu_plugin_get_name(self));\n\tif (!vfuncs->clear_results(self, device, &error_local)) {\n\t\tif (error_local == NULL) {\n\t\t\tg_critical(\"unset plugin error in clear_result(%s)\",\n\t\t\t\t   fu_plugin_get_name(self));\n\t\t\tg_set_error_literal(&error_local,\n\t\t\t\t\t    FWUPD_ERROR,\n\t\t\t\t\t    FWUPD_ERROR_INTERNAL,\n\t\t\t\t\t    \"unspecified error\");\n\t\t}\n\t\tg_propagate_prefixed_error(error,\n\t\t\t\t\t   g_steal_pointer(&error_local),\n\t\t\t\t\t   \"failed to clear_result using %s: \",\n\t\t\t\t\t   fu_plugin_get_name(self));\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\n/**\n * fu_plugin_runner_get_results:\n * @self: a #FuPlugin\n * @device: a device\n * @error: (nullable): optional return location for an error\n *\n * Call into the plugin's get results routine\n *\n * Returns: #TRUE for success, #FALSE for failure\n *\n * Since: 0.8.0\n **/\ngboolean\nfu_plugin_runner_get_results(FuPlugin *self, FuDevice *device, GError **error)\n{\n\tFuPluginVfuncs *vfuncs = fu_plugin_get_vfuncs(self);\n\tg_autoptr(GError) error_local = NULL;\n\n\tg_return_val_if_fail(FU_IS_PLUGIN(self), FALSE);\n\tg_return_val_if_fail(FU_IS_DEVICE(device), FALSE);\n\tg_return_val_if_fail(error == NULL || *error == NULL, FALSE);\n\n\t/* not enabled */\n\tif (fu_plugin_has_flag(self, FWUPD_PLUGIN_FLAG_DISABLED))\n\t\treturn TRUE;\n\n\t/* optional */\n\tif (vfuncs->get_results == NULL) {\n\t\tg_debug(\"superclassed get_results(%s)\", fu_plugin_get_name(self));\n\t\treturn fu_plugin_device_get_results(self, device, error);\n\t}\n\tg_debug(\"get_results(%s)\", fu_plugin_get_name(self));\n\tif (!vfuncs->get_results(self, device, &error_local)) {\n\t\tif (error_local == NULL) {\n\t\t\tg_critical(\"unset plugin error in get_results(%s)\",\n\t\t\t\t   fu_plugin_get_name(self));\n\t\t\tg_set_error_literal(&error_local,\n\t\t\t\t\t    FWUPD_ERROR,\n\t\t\t\t\t    FWUPD_ERROR_INTERNAL,\n\t\t\t\t\t    \"unspecified error\");\n\t\t}\n\t\tg_propagate_prefixed_error(error,\n\t\t\t\t\t   g_steal_pointer(&error_local),\n\t\t\t\t\t   \"failed to get_results using %s: \",\n\t\t\t\t\t   fu_plugin_get_name(self));\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\n/**\n * fu_plugin_get_order:\n * @self: a #FuPlugin\n *\n * Gets the plugin order, where higher numbers are run after lower\n * numbers.\n *\n * Returns: the integer value\n *\n * Since: 1.0.0\n **/\nguint\nfu_plugin_get_order(FuPlugin *self)\n{\n\tFuPluginPrivate *priv = fu_plugin_get_instance_private(self);\n\treturn priv->order;\n}\n\n/**\n * fu_plugin_set_order:\n * @self: a #FuPlugin\n * @order: an integer value\n *\n * Sets the plugin order, where higher numbers are run after lower\n * numbers.\n *\n * Since: 1.0.0\n **/\nvoid\nfu_plugin_set_order(FuPlugin *self, guint order)\n{\n\tFuPluginPrivate *priv = fu_plugin_get_instance_private(self);\n\tpriv->order = order;\n}\n\n/**\n * fu_plugin_get_priority:\n * @self: a #FuPlugin\n *\n * Gets the plugin priority, where higher numbers are better.\n *\n * Returns: the integer value\n *\n * Since: 1.1.1\n **/\nguint\nfu_plugin_get_priority(FuPlugin *self)\n{\n\tFuPluginPrivate *priv = fu_plugin_get_instance_private(self);\n\treturn priv->priority;\n}\n\n/**\n * fu_plugin_set_priority:\n * @self: a #FuPlugin\n * @priority: an integer value\n *\n * Sets the plugin priority, where higher numbers are better.\n *\n * Since: 1.0.0\n **/\nvoid\nfu_plugin_set_priority(FuPlugin *self, guint priority)\n{\n\tFuPluginPrivate *priv = fu_plugin_get_instance_private(self);\n\tpriv->priority = priority;\n}\n\n/**\n * fu_plugin_add_rule:\n * @self: a #FuPlugin\n * @rule: a plugin rule, e.g. %FU_PLUGIN_RULE_CONFLICTS\n * @name: a plugin name, e.g. `upower`\n *\n * If the plugin name is found, the rule will be used to sort the plugin list,\n * for example the plugin specified by @name will be ordered after this plugin\n * when %FU_PLUGIN_RULE_RUN_AFTER is used.\n *\n * NOTE: The depsolver is iterative and may not solve overly-complicated rules;\n * If depsolving fails then fwupd will not start.\n *\n * Since: 1.0.0\n **/\nvoid\nfu_plugin_add_rule(FuPlugin *self, FuPluginRule rule, const gchar *name)\n{\n\tFuPluginPrivate *priv = fu_plugin_get_instance_private(self);\n\tif (priv->rules[rule] == NULL)\n\t\tpriv->rules[rule] = g_ptr_array_new_with_free_func(g_free);\n\tg_ptr_array_add(priv->rules[rule], g_strdup(name));\n\tg_signal_emit(self, signals[SIGNAL_RULES_CHANGED], 0);\n}\n\n/**\n * fu_plugin_get_rules:\n * @self: a #FuPlugin\n * @rule: a plugin rule, e.g. %FU_PLUGIN_RULE_CONFLICTS\n *\n * Gets the plugin IDs that should be run after this plugin.\n *\n * Returns: (element-type utf8) (transfer none) (nullable): the list of plugin names, e.g.\n *`['appstream']`\n *\n * Since: 1.0.0\n **/\nGPtrArray *\nfu_plugin_get_rules(FuPlugin *self, FuPluginRule rule)\n{\n\tFuPluginPrivate *priv = fu_plugin_get_instance_private(self);\n\tg_return_val_if_fail(rule < FU_PLUGIN_RULE_LAST, NULL);\n\treturn priv->rules[rule];\n}\n\n/**\n * fu_plugin_has_rule:\n * @self: a #FuPlugin\n * @rule: a plugin rule, e.g. %FU_PLUGIN_RULE_CONFLICTS\n * @name: a plugin name, e.g. `upower`\n *\n * Gets the plugin IDs that should be run after this plugin.\n *\n * Returns: %TRUE if the name exists for the specific rule\n *\n * Since: 1.0.0\n **/\ngboolean\nfu_plugin_has_rule(FuPlugin *self, FuPluginRule rule, const gchar *name)\n{\n\tFuPluginPrivate *priv = fu_plugin_get_instance_private(self);\n\tif (priv->rules[rule] == NULL)\n\t\treturn FALSE;\n\tfor (guint i = 0; i < priv->rules[rule]->len; i++) {\n\t\tconst gchar *tmp = g_ptr_array_index(priv->rules[rule], i);\n\t\tif (g_strcmp0(tmp, name) == 0)\n\t\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}\n\n/**\n * fu_plugin_add_report_metadata:\n * @self: a #FuPlugin\n * @key: a string, e.g. `FwupdateVersion`\n * @value: a string, e.g. `10`\n *\n * Sets any additional metadata to be included in the firmware report to aid\n * debugging problems.\n *\n * Any data included here will be sent to the metadata server after user\n * confirmation.\n *\n * Since: 1.0.4\n **/\nvoid\nfu_plugin_add_report_metadata(FuPlugin *self, const gchar *key, const gchar *value)\n{\n\tFuPluginPrivate *priv = fu_plugin_get_instance_private(self);\n\tif (priv->report_metadata == NULL) {\n\t\tpriv->report_metadata =\n\t\t    g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);\n\t}\n\tg_hash_table_insert(priv->report_metadata, g_strdup(key), g_strdup(value));\n}\n\n/**\n * fu_plugin_get_report_metadata:\n * @self: a #FuPlugin\n *\n * Returns the list of additional metadata to be added when filing a report.\n *\n * Returns: (transfer none) (nullable): the map of report metadata\n *\n * Since: 1.0.4\n **/\nGHashTable *\nfu_plugin_get_report_metadata(FuPlugin *self)\n{\n\tFuPluginPrivate *priv = fu_plugin_get_instance_private(self);\n\treturn priv->report_metadata;\n}\n\n/**\n * fu_plugin_get_config_value:\n * @self: a #FuPlugin\n * @key: a settings key\n *\n * Return the value of a key if it's been configured\n *\n * Since: 1.0.6\n **/\ngchar *\nfu_plugin_get_config_value(FuPlugin *self, const gchar *key)\n{\n\tg_autofree gchar *conf_path = fu_plugin_get_config_filename(self);\n\tg_autoptr(GKeyFile) keyfile = NULL;\n\tif (!g_file_test(conf_path, G_FILE_TEST_IS_REGULAR))\n\t\treturn NULL;\n\tkeyfile = g_key_file_new();\n\tif (!g_key_file_load_from_file(keyfile, conf_path, G_KEY_FILE_NONE, NULL))\n\t\treturn NULL;\n\treturn g_key_file_get_string(keyfile, fu_plugin_get_name(self), key, NULL);\n}\n\n/**\n * fu_plugin_security_attr_new:\n * @self: a #FuPlugin\n * @appstream_id: (nullable): the AppStream component ID, e.g. `com.intel.BiosGuard`\n *\n * Creates a new #FwupdSecurityAttr for this specific plugin.\n *\n * Returns: (transfer full): a #FwupdSecurityAttr\n *\n * Since: 1.8.4\n **/\nFwupdSecurityAttr *\nfu_plugin_security_attr_new(FuPlugin *self, const gchar *appstream_id)\n{\n\tFuPluginPrivate *priv = fu_plugin_get_instance_private(self);\n\tg_autoptr(FwupdSecurityAttr) attr = NULL;\n\n\tg_return_val_if_fail(FU_IS_PLUGIN(self), NULL);\n\tg_return_val_if_fail(appstream_id != NULL, NULL);\n\n\tattr = fu_security_attr_new(priv->ctx, appstream_id);\n\tfwupd_security_attr_set_plugin(attr, fu_plugin_get_name(self));\n\treturn g_steal_pointer(&attr);\n}\n\n/**\n * fu_plugin_set_config_value:\n * @self: a #FuPlugin\n * @key: a settings key\n * @value: (nullable): a settings value\n * @error: (nullable): optional return location for an error\n *\n * Sets a plugin config value.\n *\n * Returns: %TRUE for success\n *\n * Since: 1.7.0\n **/\ngboolean\nfu_plugin_set_config_value(FuPlugin *self, const gchar *key, const gchar *value, GError **error)\n{\n\tg_autofree gchar *conf_path = fu_plugin_get_config_filename(self);\n\tg_autoptr(GKeyFile) keyfile = NULL;\n\n\tg_return_val_if_fail(FU_IS_PLUGIN(self), FALSE);\n\tg_return_val_if_fail(key != NULL, FALSE);\n\tg_return_val_if_fail(error == NULL || *error == NULL, FALSE);\n\n\tkeyfile = g_key_file_new();\n\tif (!g_key_file_load_from_file(keyfile, conf_path, G_KEY_FILE_KEEP_COMMENTS, error))\n\t\treturn FALSE;\n\tg_key_file_set_string(keyfile, fu_plugin_get_name(self), key, value);\n\treturn g_key_file_save_to_file(keyfile, conf_path, error);\n}\n\n/**\n * fu_plugin_set_secure_config_value:\n * @self: a #FuPlugin\n * @key: a settings key\n * @value: (nullable): a settings value\n * @error: (nullable): optional return location for an error\n *\n * Sets a plugin config file value and updates file so that non-privileged users\n * cannot read it.\n *\n * Returns: %TRUE for success\n *\n * Since: 1.7.4\n **/\ngboolean\nfu_plugin_set_secure_config_value(FuPlugin *self,\n\t\t\t\t  const gchar *key,\n\t\t\t\t  const gchar *value,\n\t\t\t\t  GError **error)\n{\n\tg_autofree gchar *conf_path = fu_plugin_get_config_filename(self);\n\tgint ret;\n\n\tg_return_val_if_fail(FU_IS_PLUGIN(self), FALSE);\n\tg_return_val_if_fail(error == NULL || *error == NULL, FALSE);\n\n\tif (!g_file_test(conf_path, G_FILE_TEST_EXISTS)) {\n\t\tg_set_error(error, FWUPD_ERROR, FWUPD_ERROR_NOT_FOUND, \"%s is missing\", conf_path);\n\t\treturn FALSE;\n\t}\n\tret = g_chmod(conf_path, 0660);\n\tif (ret == -1) {\n\t\tg_set_error(error,\n\t\t\t    FWUPD_ERROR,\n\t\t\t    FWUPD_ERROR_INTERNAL,\n\t\t\t    \"failed to set permissions on %s\",\n\t\t\t    conf_path);\n\t\treturn FALSE;\n\t}\n\n\treturn fu_plugin_set_config_value(self, key, value, error);\n}\n\n/**\n * fu_plugin_get_config_value_boolean:\n * @self: a #FuPlugin\n * @key: a settings key\n *\n * Return the boolean value of a key if it's been configured\n *\n * Returns: %TRUE if the value is `true` (case insensitive), %FALSE otherwise\n *\n * Since: 1.4.0\n **/\ngboolean\nfu_plugin_get_config_value_boolean(FuPlugin *self, const gchar *key)\n{\n\tg_autofree gchar *tmp = fu_plugin_get_config_value(self, key);\n\tif (tmp == NULL)\n\t\treturn FALSE;\n\treturn g_ascii_strcasecmp(tmp, \"true\") == 0;\n}\n\n/**\n * fu_plugin_name_compare:\n * @plugin1: first #FuPlugin to compare.\n * @plugin2: second #FuPlugin to compare.\n *\n * Compares two plugins by their names.\n *\n * Returns: 1, 0 or -1 if @plugin1 is greater, equal, or less than @plugin2.\n *\n * Since: 1.0.8\n **/\ngint\nfu_plugin_name_compare(FuPlugin *plugin1, FuPlugin *plugin2)\n{\n\treturn g_strcmp0(fu_plugin_get_name(plugin1), fu_plugin_get_name(plugin2));\n}\n\n/**\n * fu_plugin_order_compare:\n * @plugin1: first #FuPlugin to compare.\n * @plugin2: second #FuPlugin to compare.\n *\n * Compares two plugins by their depsolved order, and then by name.\n *\n * Returns: 1, 0 or -1 if @plugin1 is greater, equal, or less than @plugin2.\n *\n * Since: 1.0.8\n **/\ngint\nfu_plugin_order_compare(FuPlugin *plugin1, FuPlugin *plugin2)\n{\n\tFuPluginPrivate *priv1 = fu_plugin_get_instance_private(plugin1);\n\tFuPluginPrivate *priv2 = fu_plugin_get_instance_private(plugin2);\n\tif (priv1->order < priv2->order)\n\t\treturn -1;\n\tif (priv1->order > priv2->order)\n\t\treturn 1;\n\treturn fu_plugin_name_compare(plugin1, plugin2);\n}\n\nstatic void\nfu_plugin_class_init(FuPluginClass *klass)\n{\n\tGObjectClass *object_class = G_OBJECT_CLASS(klass);\n\tobject_class->finalize = fu_plugin_finalize;\n\n\t/**\n\t * FuPlugin::device-added:\n\t * @self: the #FuPlugin instance that emitted the signal\n\t * @device: the #FuDevice\n\t *\n\t * The ::device-added signal is emitted when a device has been added by the plugin.\n\t *\n\t * Since: 0.8.0\n\t **/\n\tsignals[SIGNAL_DEVICE_ADDED] = g_signal_new(\"device-added\",\n\t\t\t\t\t\t    G_TYPE_FROM_CLASS(object_class),\n\t\t\t\t\t\t    G_SIGNAL_RUN_LAST,\n\t\t\t\t\t\t    G_STRUCT_OFFSET(FuPluginClass, device_added),\n\t\t\t\t\t\t    NULL,\n\t\t\t\t\t\t    NULL,\n\t\t\t\t\t\t    g_cclosure_marshal_VOID__OBJECT,\n\t\t\t\t\t\t    G_TYPE_NONE,\n\t\t\t\t\t\t    1,\n\t\t\t\t\t\t    FU_TYPE_DEVICE);\n\t/**\n\t * FuPlugin::device-removed:\n\t * @self: the #FuPlugin instance that emitted the signal\n\t * @device: the #FuDevice\n\t *\n\t * The ::device-removed signal is emitted when a device has been removed by the plugin.\n\t *\n\t * Since: 0.8.0\n\t **/\n\tsignals[SIGNAL_DEVICE_REMOVED] =\n\t    g_signal_new(\"device-removed\",\n\t\t\t G_TYPE_FROM_CLASS(object_class),\n\t\t\t G_SIGNAL_RUN_LAST,\n\t\t\t G_STRUCT_OFFSET(FuPluginClass, device_removed),\n\t\t\t NULL,\n\t\t\t NULL,\n\t\t\t g_cclosure_marshal_VOID__OBJECT,\n\t\t\t G_TYPE_NONE,\n\t\t\t 1,\n\t\t\t FU_TYPE_DEVICE);\n\t/**\n\t * FuPlugin::device-register:\n\t * @self: the #FuPlugin instance that emitted the signal\n\t * @device: the #FuDevice\n\t *\n\t * The ::device-register signal is emitted when another plugin has added the device.\n\t *\n\t * Since: 0.9.7\n\t **/\n\tsignals[SIGNAL_DEVICE_REGISTER] =\n\t    g_signal_new(\"device-register\",\n\t\t\t G_TYPE_FROM_CLASS(object_class),\n\t\t\t G_SIGNAL_RUN_LAST,\n\t\t\t G_STRUCT_OFFSET(FuPluginClass, device_register),\n\t\t\t NULL,\n\t\t\t NULL,\n\t\t\t g_cclosure_marshal_VOID__OBJECT,\n\t\t\t G_TYPE_NONE,\n\t\t\t 1,\n\t\t\t FU_TYPE_DEVICE);\n\t/**\n\t * FuPlugin::check-supported:\n\t * @self: the #FuPlugin instance that emitted the signal\n\t * @guid: a device GUID\n\t *\n\t * The ::check-supported signal is emitted when a plugin wants to ask the daemon if a\n\t * specific device GUID is supported in the existing system metadata.\n\t *\n\t * Returns: %TRUE if the GUID is found\n\t *\n\t * Since: 1.0.0\n\t **/\n\tsignals[SIGNAL_CHECK_SUPPORTED] =\n\t    g_signal_new(\"check-supported\",\n\t\t\t G_TYPE_FROM_CLASS(object_class),\n\t\t\t G_SIGNAL_RUN_LAST,\n\t\t\t G_STRUCT_OFFSET(FuPluginClass, check_supported),\n\t\t\t NULL,\n\t\t\t NULL,\n\t\t\t g_cclosure_marshal_generic,\n\t\t\t G_TYPE_BOOLEAN,\n\t\t\t 1,\n\t\t\t G_TYPE_STRING);\n\tsignals[SIGNAL_RULES_CHANGED] = g_signal_new(\"rules-changed\",\n\t\t\t\t\t\t     G_TYPE_FROM_CLASS(object_class),\n\t\t\t\t\t\t     G_SIGNAL_RUN_LAST,\n\t\t\t\t\t\t     G_STRUCT_OFFSET(FuPluginClass, rules_changed),\n\t\t\t\t\t\t     NULL,\n\t\t\t\t\t\t     NULL,\n\t\t\t\t\t\t     g_cclosure_marshal_VOID__VOID,\n\t\t\t\t\t\t     G_TYPE_NONE,\n\t\t\t\t\t\t     0);\n\t/**\n\t * FuPlugin::config-changed:\n\t * @self: the #FuPlugin instance that emitted the signal\n\t *\n\t * The ::config-changed signal is emitted when one or more config files have changed which\n\t * may affect how the daemon should be run.\n\t *\n\t * Since: 1.7.0\n\t **/\n\tsignals[SIGNAL_CONFIG_CHANGED] =\n\t    g_signal_new(\"config-changed\",\n\t\t\t G_TYPE_FROM_CLASS(object_class),\n\t\t\t G_SIGNAL_RUN_LAST,\n\t\t\t G_STRUCT_OFFSET(FuPluginClass, config_changed),\n\t\t\t NULL,\n\t\t\t NULL,\n\t\t\t g_cclosure_marshal_VOID__VOID,\n\t\t\t G_TYPE_NONE,\n\t\t\t 0);\n}\n\nstatic void\nfu_plugin_init(FuPlugin *self)\n{\n\tFuPluginPrivate *priv = GET_PRIVATE(self);\n\tg_rw_lock_init(&priv->cache_mutex);\n}\n\nstatic void\nfu_plugin_finalize(GObject *object)\n{\n\tFuPlugin *self = FU_PLUGIN(object);\n\tFuPluginPrivate *priv = GET_PRIVATE(self);\n\tFuPluginVfuncs *vfuncs = fu_plugin_get_vfuncs(self);\n\n\tg_rw_lock_clear(&priv->cache_mutex);\n\n\t/* optional */\n\tif (priv->done_init && vfuncs->destroy != NULL) {\n\t\tg_debug(\"destroy(%s)\", fu_plugin_get_name(self));\n\t\tvfuncs->destroy(self);\n\t}\n\n\tfor (guint i = 0; i < FU_PLUGIN_RULE_LAST; i++) {\n\t\tif (priv->rules[i] != NULL)\n\t\t\tg_ptr_array_unref(priv->rules[i]);\n\t}\n\tif (priv->devices != NULL)\n\t\tg_ptr_array_unref(priv->devices);\n\tif (priv->ctx != NULL)\n\t\tg_object_unref(priv->ctx);\n\tif (priv->runtime_versions != NULL)\n\t\tg_hash_table_unref(priv->runtime_versions);\n\tif (priv->compile_versions != NULL)\n\t\tg_hash_table_unref(priv->compile_versions);\n\tif (priv->report_metadata != NULL)\n\t\tg_hash_table_unref(priv->report_metadata);\n\tif (priv->cache != NULL)\n\t\tg_hash_table_unref(priv->cache);\n\tif (priv->device_gtypes != NULL)\n\t\tg_array_unref(priv->device_gtypes);\n\tif (priv->config_monitor != NULL)\n\t\tg_object_unref(priv->config_monitor);\n\tg_free(priv->data);\n\n\tG_OBJECT_CLASS(fu_plugin_parent_class)->finalize(object);\n}\n\n/**\n * fu_plugin_new:\n * @ctx: (nullable): a #FuContext\n *\n * Creates a new #FuPlugin\n *\n * Since: 0.8.0\n **/\nFuPlugin *\nfu_plugin_new(FuContext *ctx)\n{\n\tFuPlugin *self = FU_PLUGIN(g_object_new(FU_TYPE_PLUGIN, NULL));\n\tFuPluginPrivate *priv = GET_PRIVATE(self);\n\tif (ctx != NULL)\n\t\tpriv->ctx = g_object_ref(ctx);\n\treturn self;\n}\n", "/*\n * Copyright (C) 2015 Richard Hughes <richard@hughsie.com>\n *\n * SPDX-License-Identifier: LGPL-2.1+\n */\n\n#include \"config.h\"\n\n#include <fwupdplugin.h>\n\n#include <glib/gstdio.h>\n#include <libgcab.h>\n#include <string.h>\n\n#include \"fwupd-bios-setting-private.h\"\n#include \"fwupd-security-attr-private.h\"\n\n#include \"fu-bios-settings-private.h\"\n#include \"fu-cabinet.h\"\n#include \"fu-common-private.h\"\n#include \"fu-context-private.h\"\n#include \"fu-coswid-firmware.h\"\n#include \"fu-device-private.h\"\n#include \"fu-plugin-private.h\"\n#include \"fu-security-attrs-private.h\"\n#include \"fu-smbios-private.h\"\n\nstatic GMainLoop *_test_loop = NULL;\nstatic guint _test_loop_timeout_id = 0;\n\nstatic gboolean\nfu_test_hang_check_cb(gpointer user_data)\n{\n\tg_main_loop_quit(_test_loop);\n\t_test_loop_timeout_id = 0;\n\treturn G_SOURCE_REMOVE;\n}\n\nstatic void\nfu_test_loop_run_with_timeout(guint timeout_ms)\n{\n\tg_assert_cmpint(_test_loop_timeout_id, ==, 0);\n\tg_assert_null(_test_loop);\n\t_test_loop = g_main_loop_new(NULL, FALSE);\n\t_test_loop_timeout_id = g_timeout_add(timeout_ms, fu_test_hang_check_cb, NULL);\n\tg_main_loop_run(_test_loop);\n}\n\nstatic void\nfu_test_loop_quit(void)\n{\n\tif (_test_loop_timeout_id > 0) {\n\t\tg_source_remove(_test_loop_timeout_id);\n\t\t_test_loop_timeout_id = 0;\n\t}\n\tif (_test_loop != NULL) {\n\t\tg_main_loop_quit(_test_loop);\n\t\tg_main_loop_unref(_test_loop);\n\t\t_test_loop = NULL;\n\t}\n}\n\nstatic void\nfu_archive_invalid_func(void)\n{\n\tg_autofree gchar *filename = NULL;\n\tg_autoptr(FuArchive) archive = NULL;\n\tg_autoptr(GBytes) data = NULL;\n\tg_autoptr(GError) error = NULL;\n\n#ifndef HAVE_LIBARCHIVE\n\tg_test_skip(\"no libarchive support\");\n\treturn;\n#endif\n\n\tfilename = g_test_build_filename(G_TEST_DIST, \"tests\", \"metadata.xml\", NULL);\n\tdata = fu_bytes_get_contents(filename, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(data);\n\n\tarchive = fu_archive_new(data, FU_ARCHIVE_FLAG_NONE, &error);\n\tg_assert_error(error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED);\n\tg_assert_null(archive);\n}\n\nstatic void\nfu_archive_cab_func(void)\n{\n\tg_autofree gchar *checksum1 = NULL;\n\tg_autofree gchar *checksum2 = NULL;\n\tg_autofree gchar *filename = NULL;\n\tg_autoptr(FuArchive) archive = NULL;\n\tg_autoptr(GBytes) data = NULL;\n\tg_autoptr(GError) error = NULL;\n\tGBytes *data_tmp;\n\n#ifndef HAVE_LIBARCHIVE\n\tg_test_skip(\"no libarchive support\");\n\treturn;\n#endif\n\n\tfilename = g_test_build_filename(G_TEST_BUILT,\n\t\t\t\t\t \"tests\",\n\t\t\t\t\t \"colorhug\",\n\t\t\t\t\t \"colorhug-als-3.0.2.cab\",\n\t\t\t\t\t NULL);\n\tdata = fu_bytes_get_contents(filename, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(data);\n\n\tarchive = fu_archive_new(data, FU_ARCHIVE_FLAG_NONE, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(archive);\n\n\tdata_tmp = fu_archive_lookup_by_fn(archive, \"firmware.metainfo.xml\", &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(data_tmp);\n\tchecksum1 = g_compute_checksum_for_bytes(G_CHECKSUM_SHA1, data_tmp);\n\tg_assert_cmpstr(checksum1, ==, \"8611114f51f7151f190de86a5c9259d79ff34216\");\n\n\tdata_tmp = fu_archive_lookup_by_fn(archive, \"firmware.bin\", &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(data_tmp);\n\tchecksum2 = g_compute_checksum_for_bytes(G_CHECKSUM_SHA1, data_tmp);\n\tg_assert_cmpstr(checksum2, ==, \"7c0ae84b191822bcadbdcbe2f74a011695d783c7\");\n\n\tdata_tmp = fu_archive_lookup_by_fn(archive, \"NOTGOINGTOEXIST.xml\", &error);\n\tg_assert_error(error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND);\n\tg_assert_null(data_tmp);\n}\n\nstatic void\nfu_common_gpt_type_func(void)\n{\n\tg_assert_cmpstr(fu_common_convert_to_gpt_type(\"0xef\"),\n\t\t\t==,\n\t\t\t\"c12a7328-f81f-11d2-ba4b-00a0c93ec93b\");\n\tg_assert_cmpstr(fu_common_convert_to_gpt_type(\"0x0b\"),\n\t\t\t==,\n\t\t\t\"ebd0a0a2-b9e5-4433-87c0-68b6b72699c7\");\n\tg_assert_cmpstr(fu_common_convert_to_gpt_type(\"fat32lba\"),\n\t\t\t==,\n\t\t\t\"ebd0a0a2-b9e5-4433-87c0-68b6b72699c7\");\n\tg_assert_cmpstr(fu_common_convert_to_gpt_type(\"0x00\"), ==, \"0x00\");\n}\n\nstatic void\nfu_common_align_up_func(void)\n{\n\tg_assert_cmpint(fu_common_align_up(0, 0), ==, 0);\n\tg_assert_cmpint(fu_common_align_up(5, 0), ==, 5);\n\tg_assert_cmpint(fu_common_align_up(5, 3), ==, 8);\n\tg_assert_cmpint(fu_common_align_up(1023, 10), ==, 1024);\n\tg_assert_cmpint(fu_common_align_up(1024, 10), ==, 1024);\n\tg_assert_cmpint(fu_common_align_up(G_MAXSIZE - 1, 10), ==, G_MAXSIZE);\n}\n\nstatic void\nfu_common_byte_array_func(void)\n{\n\tg_autoptr(GByteArray) array = g_byte_array_new();\n\n\tfu_byte_array_append_uint8(array, (guint8)'h');\n\tfu_byte_array_append_uint8(array, (guint8)'e');\n\tfu_byte_array_append_uint8(array, (guint8)'l');\n\tfu_byte_array_append_uint8(array, (guint8)'l');\n\tfu_byte_array_append_uint8(array, (guint8)'o');\n\tg_assert_cmpint(array->len, ==, 5);\n\tg_assert_cmpint(memcmp(array->data, \"hello\", array->len), ==, 0);\n\n\tfu_byte_array_set_size(array, 10, 0x00);\n\tg_assert_cmpint(array->len, ==, 10);\n\tg_assert_cmpint(memcmp(array->data, \"hello\\0\\0\\0\\0\\0\", array->len), ==, 0);\n}\n\nstatic void\nfu_common_crc_func(void)\n{\n\tguint8 buf[] = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09};\n\tg_assert_cmpint(fu_crc8(buf, sizeof(buf)), ==, 0x7A);\n\tg_assert_cmpint(fu_crc16(buf, sizeof(buf)), ==, 0x4DF1);\n\tg_assert_cmpint(fu_crc32(buf, sizeof(buf)), ==, 0x40EFAB9E);\n}\n\nstatic void\nfu_string_append_func(void)\n{\n\tg_autoptr(GString) str = g_string_new(NULL);\n\tfu_string_append(str, 0, \"hdr\", NULL);\n\tfu_string_append(str, 0, \"key\", \"value\");\n\tfu_string_append(str, 0, \"key1\", \"value1\");\n\tfu_string_append(str, 1, \"key2\", \"value2\");\n\tfu_string_append(str, 1, \"\", \"value2\");\n\tfu_string_append(str, 2, \"key3\", \"value3\");\n\tg_assert_cmpstr(str->str,\n\t\t\t==,\n\t\t\t\"hdr:\\n\"\n\t\t\t\"key:                    value\\n\"\n\t\t\t\"key1:                   value1\\n\"\n\t\t\t\"  key2:                 value2\\n\"\n\t\t\t\"                        value2\\n\"\n\t\t\t\"    key3:               value3\\n\");\n}\n\nstatic void\nfu_version_guess_format_func(void)\n{\n\tg_assert_cmpint(fu_version_guess_format(NULL), ==, FWUPD_VERSION_FORMAT_UNKNOWN);\n\tg_assert_cmpint(fu_version_guess_format(\"\"), ==, FWUPD_VERSION_FORMAT_UNKNOWN);\n\tg_assert_cmpint(fu_version_guess_format(\"1234ac\"), ==, FWUPD_VERSION_FORMAT_PLAIN);\n\tg_assert_cmpint(fu_version_guess_format(\"1.2\"), ==, FWUPD_VERSION_FORMAT_PAIR);\n\tg_assert_cmpint(fu_version_guess_format(\"1.2.3\"), ==, FWUPD_VERSION_FORMAT_TRIPLET);\n\tg_assert_cmpint(fu_version_guess_format(\"1.2.3.4\"), ==, FWUPD_VERSION_FORMAT_QUAD);\n\tg_assert_cmpint(fu_version_guess_format(\"1.2.3.4.5\"), ==, FWUPD_VERSION_FORMAT_UNKNOWN);\n\tg_assert_cmpint(fu_version_guess_format(\"1a.2b.3\"), ==, FWUPD_VERSION_FORMAT_PLAIN);\n\tg_assert_cmpint(fu_version_guess_format(\"1\"), ==, FWUPD_VERSION_FORMAT_NUMBER);\n\tg_assert_cmpint(fu_version_guess_format(\"0x10201\"), ==, FWUPD_VERSION_FORMAT_NUMBER);\n}\n\nstatic void\nfu_device_version_format_func(void)\n{\n\tg_autoptr(FuDevice) device = fu_device_new(NULL);\n\tfu_device_add_internal_flag(device, FU_DEVICE_INTERNAL_FLAG_ENSURE_SEMVER);\n\tfu_device_set_version_format(device, FWUPD_VERSION_FORMAT_TRIPLET);\n\tfu_device_set_version(device, \"Ver1.2.3 RELEASE\");\n\tg_assert_cmpstr(fu_device_get_version(device), ==, \"1.2.3\");\n}\n\nstatic void\nfu_device_open_refcount_func(void)\n{\n\tgboolean ret;\n\tg_autoptr(FuDevice) device = fu_device_new(NULL);\n\tg_autoptr(GError) error = NULL;\n\tfu_device_set_id(device, \"test_device\");\n\tret = fu_device_open(device, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tret = fu_device_open(device, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tret = fu_device_close(device, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tret = fu_device_close(device, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tret = fu_device_close(device, &error);\n\tg_assert_error(error, FWUPD_ERROR, FWUPD_ERROR_NOTHING_TO_DO);\n\tg_assert_false(ret);\n}\n\nstatic void\nfu_device_name_func(void)\n{\n\tg_autoptr(FuDevice) device1 = fu_device_new(NULL);\n\tg_autoptr(FuDevice) device2 = fu_device_new(NULL);\n\n\t/* vendor then name */\n\tfu_device_set_vendor(device1, \"  Hughski  \");\n\tfu_device_set_name(device1, \"HUGHSKI  ColorHug(TM)__Pro  \");\n\tg_assert_cmpstr(fu_device_get_vendor(device1), ==, \"Hughski\");\n\tg_assert_cmpstr(fu_device_get_name(device1), ==, \"ColorHug\u2122 Pro\");\n\n\t/* name then vendor */\n\tfu_device_set_name(device2, \"Hughski ColorHug(TM)_Pro\");\n\tfu_device_set_vendor(device2, \"Hughski\");\n\tg_assert_cmpstr(fu_device_get_vendor(device2), ==, \"Hughski\");\n\tg_assert_cmpstr(fu_device_get_name(device2), ==, \"ColorHug\u2122 Pro\");\n\n\t/* a real example */\n\tfu_device_set_name(device2, \"Intel(R) Core(TM) i7-10850H CPU @ 2.70GHz\");\n\tfu_device_set_vendor(device2, \"Intel\");\n\tg_assert_cmpstr(fu_device_get_name(device2), ==, \"Core\u2122 i7-10850H CPU @ 2.70GHz\");\n}\n\nstatic void\nfu_device_cfi_device_func(void)\n{\n\tgboolean ret;\n\tguint8 cmd = 0;\n\tg_autoptr(FuContext) ctx = fu_context_new();\n\tg_autoptr(FuCfiDevice) cfi_device = NULL;\n\tg_autoptr(GError) error = NULL;\n\n\tret = fu_context_load_quirks(ctx, FU_QUIRKS_LOAD_FLAG_NO_CACHE, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\n\tcfi_device = fu_cfi_device_new(ctx, \"3730\");\n\tret = fu_device_setup(FU_DEVICE(cfi_device), &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\n\t/* fallback */\n\tret = fu_cfi_device_get_cmd(cfi_device, FU_CFI_DEVICE_CMD_READ_DATA, &cmd, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_assert_cmpint(cmd, ==, 0x03);\n\n\t/* from quirk */\n\tret = fu_cfi_device_get_cmd(cfi_device, FU_CFI_DEVICE_CMD_CHIP_ERASE, &cmd, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_assert_cmpint(cmd, ==, 0xC7);\n\tg_assert_cmpint(fu_cfi_device_get_size(cfi_device), ==, 0x10000);\n\tg_assert_cmpint(fu_cfi_device_get_page_size(cfi_device), ==, 0x200);\n\tg_assert_cmpint(fu_cfi_device_get_sector_size(cfi_device), ==, 0x2000);\n\tg_assert_cmpint(fu_cfi_device_get_block_size(cfi_device), ==, 0x8000);\n}\n\nstatic void\nfu_device_metadata_func(void)\n{\n\tg_autoptr(FuDevice) device = fu_device_new(NULL);\n\n\t/* string */\n\tfu_device_set_metadata(device, \"foo\", \"bar\");\n\tg_assert_cmpstr(fu_device_get_metadata(device, \"foo\"), ==, \"bar\");\n\tfu_device_set_metadata(device, \"foo\", \"baz\");\n\tg_assert_cmpstr(fu_device_get_metadata(device, \"foo\"), ==, \"baz\");\n\tg_assert_null(fu_device_get_metadata(device, \"unknown\"));\n\n\t/* boolean */\n\tfu_device_set_metadata_boolean(device, \"baz\", TRUE);\n\tg_assert_cmpstr(fu_device_get_metadata(device, \"baz\"), ==, \"true\");\n\tg_assert_true(fu_device_get_metadata_boolean(device, \"baz\"));\n\tg_assert_false(fu_device_get_metadata_boolean(device, \"unknown\"));\n\n\t/* integer */\n\tfu_device_set_metadata_integer(device, \"bam\", 12345);\n\tg_assert_cmpstr(fu_device_get_metadata(device, \"bam\"), ==, \"12345\");\n\tg_assert_cmpint(fu_device_get_metadata_integer(device, \"bam\"), ==, 12345);\n\tg_assert_cmpint(fu_device_get_metadata_integer(device, \"unknown\"), ==, G_MAXUINT);\n\n\t/* broken integer */\n\tfu_device_set_metadata(device, \"bam\", \"123junk\");\n\tg_assert_cmpint(fu_device_get_metadata_integer(device, \"bam\"), ==, G_MAXUINT);\n\tfu_device_set_metadata(device, \"huge\", \"4294967296\"); /* not 32 bit */\n\tg_assert_cmpint(fu_device_get_metadata_integer(device, \"huge\"), ==, G_MAXUINT);\n}\n\nstatic void\nfu_smbios_func(void)\n{\n\tconst gchar *str;\n\tgboolean ret;\n\tg_autofree gchar *dump = NULL;\n\tg_autofree gchar *testdatadir = NULL;\n\tg_autoptr(FuSmbios) smbios = NULL;\n\tg_autoptr(GError) error = NULL;\n\n#ifdef _WIN32\n\tg_test_skip(\"Windows uses GetSystemFirmwareTable rather than parsing the fake test data\");\n\treturn;\n#endif\n\n\t/* these tests will not write */\n\ttestdatadir = g_test_build_filename(G_TEST_DIST, \"tests\", NULL);\n\t(void)g_setenv(\"FWUPD_SYSFSFWDIR\", testdatadir, TRUE);\n\n\tsmbios = fu_smbios_new();\n\tret = fu_smbios_setup(smbios, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tdump = fu_firmware_to_string(FU_FIRMWARE(smbios));\n\tif (g_getenv(\"FWUPD_VERBOSE\") != NULL)\n\t\tg_debug(\"%s\", dump);\n\n\t/* test for missing table */\n\tstr = fu_smbios_get_string(smbios, 0xff, 0, &error);\n\tg_assert_error(error, FWUPD_ERROR, FWUPD_ERROR_INVALID_FILE);\n\tg_assert_null(str);\n\tg_clear_error(&error);\n\n\t/* check for invalid offset */\n\tstr = fu_smbios_get_string(smbios, FU_SMBIOS_STRUCTURE_TYPE_BIOS, 0xff, &error);\n\tg_assert_error(error, FWUPD_ERROR, FWUPD_ERROR_INVALID_FILE);\n\tg_assert_null(str);\n\tg_clear_error(&error);\n\n\t/* get vendor */\n\tstr = fu_smbios_get_string(smbios, FU_SMBIOS_STRUCTURE_TYPE_BIOS, 0x04, &error);\n\tg_assert_no_error(error);\n\tg_assert_cmpstr(str, ==, \"LENOVO\");\n}\n\nstatic void\nfu_smbios3_func(void)\n{\n\tconst gchar *str;\n\tgboolean ret;\n\tg_autofree gchar *path = NULL;\n\tg_autoptr(FuSmbios) smbios = NULL;\n\tg_autoptr(GError) error = NULL;\n\n\tpath = g_test_build_filename(G_TEST_DIST, \"tests\", \"dmi\", \"tables64\", NULL);\n\tsmbios = fu_smbios_new();\n\tret = fu_smbios_setup_from_path(smbios, path, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tif (g_getenv(\"FWUPD_VERBOSE\") != NULL) {\n\t\tg_autofree gchar *dump = fu_firmware_to_string(FU_FIRMWARE(smbios));\n\t\tg_debug(\"%s\", dump);\n\t}\n\n\t/* get vendor */\n\tstr = fu_smbios_get_string(smbios, FU_SMBIOS_STRUCTURE_TYPE_BIOS, 0x04, &error);\n\tg_assert_no_error(error);\n\tg_assert_cmpstr(str, ==, \"Dell Inc.\");\n}\n\nstatic void\nfu_smbios_dt_func(void)\n{\n\tconst gchar *str;\n\tgboolean ret;\n\tg_autofree gchar *path = NULL;\n\tg_autoptr(FuSmbios) smbios = NULL;\n\tg_autoptr(GError) error = NULL;\n\n\tpath = g_test_build_filename(G_TEST_DIST, \"tests\", \"devicetree\", \"base\", NULL);\n\tsmbios = fu_smbios_new();\n\tret = fu_smbios_setup_from_path(smbios, path, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tif (g_getenv(\"FWUPD_VERBOSE\") != NULL) {\n\t\tg_autofree gchar *dump = fu_firmware_to_string(FU_FIRMWARE(smbios));\n\t\tg_debug(\"%s\", dump);\n\t}\n\n\t/* get vendor */\n\tstr = fu_smbios_get_string(smbios, FU_SMBIOS_STRUCTURE_TYPE_SYSTEM, 0x04, &error);\n\tg_assert_no_error(error);\n\tg_assert_cmpstr(str, ==, \"Hughski Limited\");\n}\n\nstatic void\nfu_smbios_dt_fallback_func(void)\n{\n\tconst gchar *str;\n\tgboolean ret;\n\tg_autofree gchar *path = NULL;\n\tg_autoptr(FuSmbios) smbios = fu_smbios_new();\n\tg_autoptr(GError) error = NULL;\n\n\tpath = g_test_build_filename(G_TEST_DIST, \"tests\", \"devicetree-fallback\", \"base\", NULL);\n\tret = fu_smbios_setup_from_path(smbios, path, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tif (g_getenv(\"FWUPD_VERBOSE\") != NULL) {\n\t\tg_autofree gchar *dump = fu_firmware_to_string(FU_FIRMWARE(smbios));\n\t\tg_debug(\"%s\", dump);\n\t}\n\n\t/* get vendor */\n\tstr = fu_smbios_get_string(smbios, FU_SMBIOS_STRUCTURE_TYPE_SYSTEM, 0x04, &error);\n\tg_assert_no_error(error);\n\tg_assert_cmpstr(str, ==, \"solidrun\");\n\n\t/* get model */\n\tstr = fu_smbios_get_string(smbios, FU_SMBIOS_STRUCTURE_TYPE_SYSTEM, 0x05, &error);\n\tg_assert_no_error(error);\n\tg_assert_cmpstr(str, ==, \"honeycomb\");\n}\n\nstatic void\nfu_smbios_class_func(void)\n{\n\tg_autofree gchar *path = g_test_build_filename(G_TEST_DIST, \"tests\", \"dmi\", \"class\", NULL);\n\tg_autoptr(FuSmbios) smbios = fu_smbios_new();\n\tg_autoptr(GError) error = NULL;\n\tgboolean ret;\n\tconst gchar *str;\n\tguint8 byte;\n\n\tret = fu_smbios_setup_from_kernel(smbios, path, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tif (g_getenv(\"FWUPD_VERBOSE\") != NULL) {\n\t\tg_autofree gchar *dump = fu_firmware_to_string(FU_FIRMWARE(smbios));\n\t\tg_debug(\"%s\", dump);\n\t}\n\n\tstr = fu_smbios_get_string(smbios, FU_SMBIOS_STRUCTURE_TYPE_SYSTEM, 4, &error);\n\tg_assert_no_error(error);\n\tg_assert_cmpstr(str, ==, \"FwupdTest\");\n\n\tbyte = fu_smbios_get_integer(smbios, FU_SMBIOS_STRUCTURE_TYPE_CHASSIS, 5, &error);\n\tg_assert_no_error(error);\n\tg_assert_cmpuint(byte, ==, 16);\n}\n\nstatic gboolean\n_strnsplit_add_cb(GString *token, guint token_idx, gpointer user_data, GError **error)\n{\n\tGPtrArray *array = (GPtrArray *)user_data;\n\tg_debug(\"TOKEN: [%s] (%u)\", token->str, token_idx);\n\tg_ptr_array_add(array, g_strdup(token->str));\n\treturn TRUE;\n}\n\nstatic gboolean\n_strnsplit_nop_cb(GString *token, guint token_idx, gpointer user_data, GError **error)\n{\n\tguint *cnt = (guint *)user_data;\n\t(*cnt)++;\n\treturn TRUE;\n}\n\nstatic void\nfu_common_memmem_func(void)\n{\n\tconst guint8 haystack[] = {'H', 'A', 'Y', 'S'};\n\tconst guint8 needle[] = {'A', 'Y'};\n\tgboolean ret;\n\tgsize offset = 0;\n\tg_autoptr(GError) error = NULL;\n\n\tret = fu_memmem_safe(haystack, sizeof(haystack), needle, sizeof(needle), &offset, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_assert_cmpint(offset, ==, 0x1);\n\n\tret = fu_memmem_safe(haystack + 2,\n\t\t\t     sizeof(haystack) - 2,\n\t\t\t     needle,\n\t\t\t     sizeof(needle),\n\t\t\t     &offset,\n\t\t\t     &error);\n\tg_assert_error(error, FWUPD_ERROR, FWUPD_ERROR_NOT_FOUND);\n\tg_assert_false(ret);\n}\n\nstatic void\nfu_strsplit_func(void)\n{\n\tconst gchar *str = \"123foo123bar123\";\n\tconst guint bigsz = 1024 * 1024;\n\tgboolean ret;\n\tguint cnt = 0;\n\tg_autoptr(GError) error = NULL;\n\tg_autoptr(GPtrArray) array = g_ptr_array_new_with_free_func(g_free);\n\tg_autoptr(GString) bigstr = g_string_sized_new(bigsz * 2);\n\n\t/* works for me */\n\tret = fu_strsplit_full(str, -1, \"123\", _strnsplit_add_cb, array, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_assert_cmpint(array->len, ==, 3);\n\tg_assert_cmpstr(g_ptr_array_index(array, 0), ==, \"\");\n\tg_assert_cmpstr(g_ptr_array_index(array, 1), ==, \"foo\");\n\tg_assert_cmpstr(g_ptr_array_index(array, 2), ==, \"bar\");\n\n\t/* lets try something insane */\n\tfor (guint i = 0; i < bigsz; i++)\n\t\tg_string_append(bigstr, \"X\\n\");\n\tret = fu_strsplit_full(bigstr->str, -1, \"\\n\", _strnsplit_nop_cb, &cnt, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_assert_cmpint(cnt, ==, bigsz);\n}\n\nstatic void\nfu_strsafe_func(void)\n{\n\tstruct {\n\t\tconst gchar *in;\n\t\tconst gchar *op;\n\t} strs[] = {{\"dave123\", \"dave123\"},\n\t\t    {\"dave123XXX\", \"dave123\"},\n\t\t    {\"dave\\x03XXX\", \"dave.XX\"},\n\t\t    {\"dave\\x03\\x04XXX\", \"dave..X\"},\n\t\t    {\"\\x03\\x03\", NULL},\n\t\t    {NULL, NULL}};\n\tGPtrArray *instance_ids;\n\tgboolean ret;\n\tg_autoptr(FuContext) ctx = fu_context_new();\n\tg_autoptr(FuDevice) dev = fu_device_new(ctx);\n\tg_autoptr(GError) error = NULL;\n\n\t/* check bespoke legacy instance ID behavior */\n\tfu_device_add_instance_strsafe(dev, \"KEY\", \"_ _LEN&VO&\\\\&\");\n\tret = fu_device_build_instance_id(dev, &error, \"SUB\", \"KEY\", NULL);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tinstance_ids = fu_device_get_instance_ids(dev);\n\tg_assert_cmpint(instance_ids->len, ==, 1);\n\tg_assert_cmpstr(g_ptr_array_index(instance_ids, 0), ==, \"SUB\\\\KEY_LEN-VO\");\n\n\tfor (guint i = 0; strs[i].in != NULL; i++) {\n\t\tg_autofree gchar *tmp = fu_strsafe(strs[i].in, 7);\n\t\tg_assert_cmpstr(tmp, ==, strs[i].op);\n\t}\n}\n\nstatic void\nfu_hwids_func(void)\n{\n\tg_autofree gchar *testdatadir = NULL;\n\tg_autoptr(FuHwids) hwids = NULL;\n\tg_autoptr(FuSmbios) smbios = NULL;\n\tg_autoptr(GError) error = NULL;\n\tgboolean ret;\n\n\tstruct {\n\t\tconst gchar *key;\n\t\tconst gchar *value;\n\t} guids[] = {{\"Manufacturer\", \"6de5d951-d755-576b-bd09-c5cf66b27234\"},\n\t\t     {\"HardwareID-14\", \"6de5d951-d755-576b-bd09-c5cf66b27234\"},\n\t\t     {\"HardwareID-13\", \"f8e1de5f-b68c-5f52-9d1a-f1ba52f1f773\"},\n\t\t     {\"HardwareID-12\", \"e093d715-70f7-51f4-b6c8-b4a7e31def85\"},\n\t\t     {\"HardwareID-11\", \"db73af4c-4612-50f7-b8a7-787cf4871847\"},\n\t\t     {\"HardwareID-10\", \"f4275c1f-6130-5191-845c-3426247eb6a1\"},\n\t\t     {\"HardwareID-9\", \"0cf8618d-9eff-537c-9f35-46861406eb9c\"},\n\t\t     {\"HardwareID-8\", \"059eb22d-6dc7-59af-abd3-94bbe017f67c\"},\n\t\t     {\"HardwareID-7\", \"da1da9b6-62f5-5f22-8aaa-14db7eeda2a4\"},\n\t\t     {\"HardwareID-6\", \"178cd22d-ad9f-562d-ae0a-34009822cdbe\"},\n\t\t     {\"HardwareID-5\", \"8dc9b7c5-f5d5-5850-9ab3-bd6f0549d814\"},\n\t\t     {\"HardwareID-4\", \"660ccba8-1b78-5a33-80e6-9fb8354ee873\"},\n\t\t     {\"HardwareID-3\", \"3faec92a-3ae3-5744-be88-495e90a7d541\"},\n\t\t     {\"HardwareID-2\", \"f5ff077f-3eeb-5bae-be1c-e98ffe8ce5f8\"},\n\t\t     {\"HardwareID-1\", \"b7cceb67-774c-537e-bf8b-22c6107e9a74\"},\n\t\t     {\"HardwareID-0\", \"147efce9-f201-5fc8-ab0c-c859751c3440\"},\n\t\t     {NULL, NULL}};\n\n#ifdef _WIN32\n\tg_test_skip(\"Windows uses GetSystemFirmwareTable rather than parsing the fake test data\");\n\treturn;\n#endif\n\n\t/* these tests will not write */\n\ttestdatadir = g_test_build_filename(G_TEST_DIST, \"tests\", NULL);\n\t(void)g_setenv(\"FWUPD_SYSFSFWDIR\", testdatadir, TRUE);\n\n\tsmbios = fu_smbios_new();\n\tret = fu_smbios_setup(smbios, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\n\thwids = fu_hwids_new();\n\tret = fu_hwids_setup(hwids, smbios, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\n\tg_assert_cmpstr(fu_hwids_get_value(hwids, FU_HWIDS_KEY_MANUFACTURER), ==, \"LENOVO\");\n\tg_assert_cmpstr(fu_hwids_get_value(hwids, FU_HWIDS_KEY_ENCLOSURE_KIND), ==, \"a\");\n\tg_assert_cmpstr(fu_hwids_get_value(hwids, FU_HWIDS_KEY_FAMILY), ==, \"ThinkPad T440s\");\n\tg_assert_cmpstr(fu_hwids_get_value(hwids, FU_HWIDS_KEY_PRODUCT_NAME), ==, \"20ARS19C0C\");\n\tg_assert_cmpstr(fu_hwids_get_value(hwids, FU_HWIDS_KEY_BIOS_VENDOR), ==, \"LENOVO\");\n\tg_assert_cmpstr(fu_hwids_get_value(hwids, FU_HWIDS_KEY_BIOS_VERSION),\n\t\t\t==,\n\t\t\t\"GJET75WW (2.25 )\");\n\tg_assert_cmpstr(fu_hwids_get_value(hwids, FU_HWIDS_KEY_BIOS_MAJOR_RELEASE), ==, \"02\");\n\tg_assert_cmpstr(fu_hwids_get_value(hwids, FU_HWIDS_KEY_BIOS_MINOR_RELEASE), ==, \"19\");\n\tg_assert_cmpstr(fu_hwids_get_value(hwids, FU_HWIDS_KEY_PRODUCT_SKU),\n\t\t\t==,\n\t\t\t\"LENOVO_MT_20AR_BU_Think_FM_ThinkPad T440s\");\n\tfor (guint i = 0; guids[i].key != NULL; i++) {\n\t\tg_autofree gchar *guid = fu_hwids_get_guid(hwids, guids[i].key, &error);\n\t\tg_assert_no_error(error);\n\t\tg_assert_cmpstr(guid, ==, guids[i].value);\n\t}\n\tfor (guint i = 0; guids[i].key != NULL; i++)\n\t\tg_assert_true(fu_hwids_has_guid(hwids, guids[i].value));\n}\n\nstatic void\n_plugin_device_added_cb(FuPlugin *plugin, FuDevice *device, gpointer user_data)\n{\n\tFuDevice **dev = (FuDevice **)user_data;\n\t*dev = g_object_ref(device);\n\tfu_test_loop_quit();\n}\n\nstatic void\nfu_plugin_devices_func(void)\n{\n\tg_autoptr(FuDevice) device = fu_device_new(NULL);\n\tg_autoptr(FuDevice) child = fu_device_new(NULL);\n\tg_autoptr(FuPlugin) plugin = fu_plugin_new(NULL);\n\tGPtrArray *devices;\n\n\tdevices = fu_plugin_get_devices(plugin);\n\tg_assert_nonnull(devices);\n\tg_assert_cmpint(devices->len, ==, 0);\n\n\tfu_device_set_id(device, \"testdev\");\n\tfu_device_set_name(device, \"testdev\");\n\tfu_plugin_device_add(plugin, device);\n\tg_assert_cmpint(devices->len, ==, 1);\n\tfu_plugin_device_remove(plugin, device);\n\tg_assert_cmpint(devices->len, ==, 0);\n\n\t/* add a child after adding the parent to the plugin */\n\tfu_device_set_id(child, \"child\");\n\tfu_device_set_name(child, \"child\");\n\tfu_device_add_child(device, child);\n\tg_assert_cmpint(devices->len, ==, 1);\n\n\t/* remove said child */\n\tfu_device_remove_child(device, child);\n\tg_assert_cmpint(devices->len, ==, 0);\n}\n\nstatic void\nfu_plugin_device_inhibit_children_func(void)\n{\n\tg_autoptr(FuDevice) parent = fu_device_new(NULL);\n\tg_autoptr(FuDevice) child1 = fu_device_new(NULL);\n\tg_autoptr(FuDevice) child2 = fu_device_new(NULL);\n\n\tfu_device_set_id(parent, \"testdev\");\n\tfu_device_set_name(parent, \"testdev\");\n\tfu_device_add_flag(parent, FWUPD_DEVICE_FLAG_UPDATABLE);\n\tfu_device_set_id(child1, \"child1\");\n\tfu_device_set_name(child1, \"child1\");\n\tfu_device_add_flag(child1, FWUPD_DEVICE_FLAG_UPDATABLE);\n\tfu_device_add_child(parent, child1);\n\n\t/* inhibit the parent */\n\tfu_device_inhibit(parent, \"test\", \"because\");\n\tg_assert_false(fu_device_has_flag(parent, FWUPD_DEVICE_FLAG_UPDATABLE));\n\tg_assert_true(fu_device_has_flag(child1, FWUPD_DEVICE_FLAG_UPDATABLE));\n\tfu_device_uninhibit(parent, \"test\");\n\n\t/* make the inhibit propagate to children */\n\tfu_device_add_internal_flag(parent, FU_DEVICE_INTERNAL_FLAG_INHIBIT_CHILDREN);\n\tfu_device_inhibit(parent, \"test\", \"because\");\n\tg_assert_false(fu_device_has_flag(parent, FWUPD_DEVICE_FLAG_UPDATABLE));\n\tg_assert_false(fu_device_has_flag(child1, FWUPD_DEVICE_FLAG_UPDATABLE));\n\n\t/* add a child after the inhibit, which should also be inhibited too */\n\tfu_device_set_id(child2, \"child2\");\n\tfu_device_set_name(child2, \"child2\");\n\tfu_device_add_flag(child2, FWUPD_DEVICE_FLAG_UPDATABLE);\n\tfu_device_add_child(parent, child2);\n\tg_assert_false(fu_device_has_flag(parent, FWUPD_DEVICE_FLAG_UPDATABLE));\n\tg_assert_false(fu_device_has_flag(child1, FWUPD_DEVICE_FLAG_UPDATABLE));\n\tg_assert_false(fu_device_has_flag(child2, FWUPD_DEVICE_FLAG_UPDATABLE));\n}\n\nstatic void\nfu_plugin_delay_func(void)\n{\n\tFuDevice *device_tmp;\n\tg_autoptr(FuPlugin) plugin = NULL;\n\tg_autoptr(FuDevice) device = NULL;\n\n\tplugin = fu_plugin_new(NULL);\n\tg_signal_connect(FU_PLUGIN(plugin),\n\t\t\t \"device-added\",\n\t\t\t G_CALLBACK(_plugin_device_added_cb),\n\t\t\t &device_tmp);\n\tg_signal_connect(FU_PLUGIN(plugin),\n\t\t\t \"device-removed\",\n\t\t\t G_CALLBACK(_plugin_device_added_cb),\n\t\t\t &device_tmp);\n\n\t/* add device straight away */\n\tdevice = fu_device_new(NULL);\n\tfu_device_set_id(device, \"testdev\");\n\tfu_plugin_device_add(plugin, device);\n\tg_assert_nonnull(device_tmp);\n\tg_assert_cmpstr(fu_device_get_id(device_tmp),\n\t\t\t==,\n\t\t\t\"b7eccd0059d6d7dc2ef76c35d6de0048cc8c029d\");\n\tg_clear_object(&device_tmp);\n\n\t/* remove device */\n\tfu_plugin_device_remove(plugin, device);\n\tg_assert_nonnull(device_tmp);\n\tg_assert_cmpstr(fu_device_get_id(device_tmp),\n\t\t\t==,\n\t\t\t\"b7eccd0059d6d7dc2ef76c35d6de0048cc8c029d\");\n\tg_clear_object(&device_tmp);\n}\n\nstatic void\nfu_plugin_quirks_func(void)\n{\n\tconst gchar *tmp;\n\tgboolean ret;\n\tg_autoptr(FuContext) ctx = fu_context_new();\n\tg_autoptr(GError) error = NULL;\n\n\tret = fu_context_load_quirks(ctx, FU_QUIRKS_LOAD_FLAG_NO_CACHE, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\n\t/* USB\\\\VID_0A5C&PID_6412 */\n\ttmp = fu_context_lookup_quirk_by_id(ctx, \"7a1ba7b9-6bcd-54a4-8a36-d60cc5ee935c\", \"Flags\");\n\tg_assert_cmpstr(tmp, ==, \"ignore-runtime\");\n\n\t/* ACME Inc.=True */\n\ttmp = fu_context_lookup_quirk_by_id(ctx, \"ec77e295-7c63-5935-9957-be0472d9593a\", \"Name\");\n\tg_assert_cmpstr(tmp, ==, \"awesome\");\n\n\t/* CORP* */\n\ttmp = fu_context_lookup_quirk_by_id(ctx, \"3731cce4-484c-521f-a652-892c8e0a65c7\", \"Name\");\n\tg_assert_cmpstr(tmp, ==, \"town\");\n\n\t/* baz */\n\ttmp = fu_context_lookup_quirk_by_id(ctx, \"579a3b1c-d1db-5bdc-b6b9-e2c1b28d5b8a\", \"Unfound\");\n\tg_assert_cmpstr(tmp, ==, NULL);\n\n\t/* unfound */\n\ttmp = fu_context_lookup_quirk_by_id(ctx, \"8ff2ed23-b37e-5f61-b409-b7fe9563be36\", \"tests\");\n\tg_assert_cmpstr(tmp, ==, NULL);\n\n\t/* unfound */\n\ttmp = fu_context_lookup_quirk_by_id(ctx, \"8ff2ed23-b37e-5f61-b409-b7fe9563be36\", \"unfound\");\n\tg_assert_cmpstr(tmp, ==, NULL);\n\n\t/* GUID */\n\ttmp = fu_context_lookup_quirk_by_id(ctx, \"bb9ec3e2-77b3-53bc-a1f1-b05916715627\", \"Flags\");\n\tg_assert_cmpstr(tmp, ==, \"clever\");\n}\n\nstatic void\nfu_plugin_quirks_performance_func(void)\n{\n\tgboolean ret;\n\tg_autoptr(FuQuirks) quirks = fu_quirks_new();\n\tg_autoptr(GTimer) timer = g_timer_new();\n\tg_autoptr(GError) error = NULL;\n\tconst gchar *keys[] = {\"Name\", \"Children\", \"Flags\", NULL};\n\n\tret = fu_quirks_load(quirks, FU_QUIRKS_LOAD_FLAG_NO_CACHE, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\n\t/* lookup */\n\tg_timer_reset(timer);\n\tfor (guint j = 0; j < 1000; j++) {\n\t\tconst gchar *group = \"bb9ec3e2-77b3-53bc-a1f1-b05916715627\";\n\t\tfor (guint i = 0; keys[i] != NULL; i++) {\n\t\t\tconst gchar *tmp = fu_quirks_lookup_by_id(quirks, group, keys[i]);\n\t\t\tg_assert_cmpstr(tmp, !=, NULL);\n\t\t}\n\t}\n\tg_print(\"lookup=%.3fms \", g_timer_elapsed(timer, NULL) * 1000.f);\n}\n\nstatic void\nfu_plugin_quirks_device_func(void)\n{\n\tFuDevice *device_tmp;\n\tGPtrArray *children;\n\tgboolean ret;\n\tg_autoptr(FuDevice) device = fu_device_new(NULL);\n\tg_autoptr(FuContext) ctx = fu_context_new();\n\tg_autoptr(GError) error = NULL;\n\n\tret = fu_context_load_quirks(ctx, FU_QUIRKS_LOAD_FLAG_NO_CACHE, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\n\t/* use quirk file to set device attributes */\n\tfu_device_set_physical_id(device, \"usb:00:05\");\n\tfu_device_set_context(device, ctx);\n\tfu_device_add_flag(device, FWUPD_DEVICE_FLAG_UPDATABLE);\n\tfu_device_add_instance_id(device, \"USB\\\\VID_0BDA&PID_1100\");\n\tfu_device_convert_instance_ids(device);\n\tg_assert_cmpstr(fu_device_get_name(device), ==, \"Hub\");\n\n\t/* ensure children are created */\n\tchildren = fu_device_get_children(device);\n\tg_assert_cmpint(children->len, ==, 1);\n\tdevice_tmp = g_ptr_array_index(children, 0);\n\tg_assert_cmpstr(fu_device_get_name(device_tmp), ==, \"HDMI\");\n\tg_assert_true(fu_device_has_flag(device_tmp, FWUPD_DEVICE_FLAG_UPDATABLE));\n}\n\nstatic void\nfu_common_kernel_lockdown_func(void)\n{\n\tgboolean ret;\n\tg_autofree gchar *locked_dir = NULL;\n\tg_autofree gchar *none_dir = NULL;\n\tg_autofree gchar *old_kernel_dir = NULL;\n\n#ifndef __linux__\n\tg_test_skip(\"only works on Linux\");\n\treturn;\n#endif\n\n\told_kernel_dir = g_test_build_filename(G_TEST_DIST, \"tests\", \"lockdown\", NULL);\n\t(void)g_setenv(\"FWUPD_SYSFSSECURITYDIR\", old_kernel_dir, TRUE);\n\tret = fu_kernel_locked_down();\n\tg_assert_false(ret);\n\n\tlocked_dir = g_test_build_filename(G_TEST_DIST, \"tests\", \"lockdown\", \"locked\", NULL);\n\t(void)g_setenv(\"FWUPD_SYSFSSECURITYDIR\", locked_dir, TRUE);\n\tret = fu_kernel_locked_down();\n\tg_assert_true(ret);\n\n\tnone_dir = g_test_build_filename(G_TEST_DIST, \"tests\", \"lockdown\", \"none\", NULL);\n\t(void)g_setenv(\"FWUPD_SYSFSSECURITYDIR\", none_dir, TRUE);\n\tret = fu_kernel_locked_down();\n\tg_assert_false(ret);\n}\n\nstatic gboolean\n_open_cb(GObject *device, GError **error)\n{\n\tg_assert_cmpstr(g_object_get_data(device, \"state\"), ==, \"closed\");\n\tg_object_set_data(device, \"state\", (gpointer) \"opened\");\n\treturn TRUE;\n}\n\nstatic gboolean\n_close_cb(GObject *device, GError **error)\n{\n\tg_assert_cmpstr(g_object_get_data(device, \"state\"), ==, \"opened\");\n\tg_object_set_data(device, \"state\", (gpointer) \"closed-on-unref\");\n\treturn TRUE;\n}\n\nstatic void\nfu_device_locker_func(void)\n{\n\tg_autoptr(FuDeviceLocker) locker = NULL;\n\tg_autoptr(GError) error = NULL;\n\tg_autoptr(GObject) device = g_object_new(G_TYPE_OBJECT, NULL);\n\n\tg_object_set_data(device, \"state\", (gpointer) \"closed\");\n\tlocker = fu_device_locker_new_full(device, _open_cb, _close_cb, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(locker);\n\tg_clear_object(&locker);\n\tg_assert_cmpstr(g_object_get_data(device, \"state\"), ==, \"closed-on-unref\");\n}\n\nstatic gboolean\n_fail_open_cb(FuDevice *device, GError **error)\n{\n\tfu_device_set_metadata_boolean(device, \"Test::Open\", TRUE);\n\tg_set_error_literal(error, G_IO_ERROR, G_IO_ERROR_FAILED, \"fail\");\n\treturn FALSE;\n}\n\nstatic gboolean\n_fail_close_cb(FuDevice *device, GError **error)\n{\n\tfu_device_set_metadata_boolean(device, \"Test::Close\", TRUE);\n\tg_set_error_literal(error, G_IO_ERROR, G_IO_ERROR_BUSY, \"busy\");\n\treturn FALSE;\n}\n\nstatic void\nfu_device_locker_fail_func(void)\n{\n\tg_autoptr(FuDeviceLocker) locker = NULL;\n\tg_autoptr(GError) error = NULL;\n\tg_autoptr(FuDevice) device = fu_device_new(NULL);\n\tlocker = fu_device_locker_new_full(device,\n\t\t\t\t\t   (FuDeviceLockerFunc)_fail_open_cb,\n\t\t\t\t\t   (FuDeviceLockerFunc)_fail_close_cb,\n\t\t\t\t\t   &error);\n\tg_assert_error(error, G_IO_ERROR, G_IO_ERROR_FAILED);\n\tg_assert_null(locker);\n\tg_assert_true(fu_device_get_metadata_boolean(device, \"Test::Open\"));\n\tg_assert_true(fu_device_get_metadata_boolean(device, \"Test::Close\"));\n\tg_assert_false(fu_device_has_internal_flag(device, FU_DEVICE_INTERNAL_FLAG_IS_OPEN));\n}\n\nstatic void\nfu_common_endian_func(void)\n{\n\tguint8 buf[3];\n\n\tfu_memwrite_uint16(buf, 0x1234, G_LITTLE_ENDIAN);\n\tg_assert_cmpint(buf[0], ==, 0x34);\n\tg_assert_cmpint(buf[1], ==, 0x12);\n\tg_assert_cmpint(fu_memread_uint16(buf, G_LITTLE_ENDIAN), ==, 0x1234);\n\n\tfu_memwrite_uint16(buf, 0x1234, G_BIG_ENDIAN);\n\tg_assert_cmpint(buf[0], ==, 0x12);\n\tg_assert_cmpint(buf[1], ==, 0x34);\n\tg_assert_cmpint(fu_memread_uint16(buf, G_BIG_ENDIAN), ==, 0x1234);\n\n\tfu_memwrite_uint24(buf, 0x123456, G_LITTLE_ENDIAN);\n\tg_assert_cmpint(buf[0], ==, 0x56);\n\tg_assert_cmpint(buf[1], ==, 0x34);\n\tg_assert_cmpint(buf[2], ==, 0x12);\n\tg_assert_cmpint(fu_memread_uint24(buf, G_LITTLE_ENDIAN), ==, 0x123456);\n\n\tfu_memwrite_uint24(buf, 0x123456, G_BIG_ENDIAN);\n\tg_assert_cmpint(buf[0], ==, 0x12);\n\tg_assert_cmpint(buf[1], ==, 0x34);\n\tg_assert_cmpint(buf[2], ==, 0x56);\n\tg_assert_cmpint(fu_memread_uint24(buf, G_BIG_ENDIAN), ==, 0x123456);\n}\n\nstatic void\nfu_common_cabinet_func(void)\n{\n\tg_autoptr(FuCabinet) cabinet = fu_cabinet_new();\n\tg_autoptr(GBytes) blob1 = NULL;\n\tg_autoptr(GBytes) blob2 = NULL;\n\tg_autoptr(GBytes) jcat_blob1 = g_bytes_new_static(\"hello\", 6);\n\tg_autoptr(GBytes) jcat_blob2 = g_bytes_new_static(\"hellX\", 6);\n\tg_autoptr(GError) error = NULL;\n\n\t/* add */\n\tfu_cabinet_add_file(cabinet, \"firmware.jcat\", jcat_blob1);\n\n\t/* replace */\n\tfu_cabinet_add_file(cabinet, \"firmware.jcat\", jcat_blob2);\n\n\t/* get data */\n\tblob1 = fu_cabinet_get_file(cabinet, \"firmware.jcat\", &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(blob1);\n\tg_assert_cmpstr(g_bytes_get_data(blob1, NULL), ==, \"hellX\");\n\n\t/* get data that does not exist */\n\tblob2 = fu_cabinet_get_file(cabinet, \"foo.jcat\", &error);\n\tg_assert_error(error, FWUPD_ERROR, FWUPD_ERROR_INVALID_FILE);\n\tg_assert_null(blob2);\n}\n\nstatic void\nfu_common_bytes_get_data_func(void)\n{\n\tconst gchar *fn = \"/tmp/fwupdzero\";\n\tconst guint8 *buf;\n\tgboolean ret;\n\tg_autoptr(GBytes) bytes1 = NULL;\n\tg_autoptr(GBytes) bytes2 = NULL;\n\tg_autoptr(GError) error = NULL;\n\tg_autoptr(GMappedFile) mmap = NULL;\n\n\t/* create file with zero size */\n\tret = g_file_set_contents(fn, NULL, 0, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\n\t/* check we got zero sized data */\n\tbytes1 = fu_bytes_get_contents(fn, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(bytes1);\n\tg_assert_cmpint(g_bytes_get_size(bytes1), ==, 0);\n\tg_assert_nonnull(g_bytes_get_data(bytes1, NULL));\n\n\t/* do the same with an mmap mapping, which returns NULL on empty file */\n\tmmap = g_mapped_file_new(fn, FALSE, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(mmap);\n\tbytes2 = g_mapped_file_get_bytes(mmap);\n\tg_assert_nonnull(bytes2);\n\tg_assert_cmpint(g_bytes_get_size(bytes2), ==, 0);\n\tg_assert_null(g_bytes_get_data(bytes2, NULL));\n\n\t/* use the safe function */\n\tbuf = fu_bytes_get_data_safe(bytes2, NULL, &error);\n\tg_assert_error(error, G_IO_ERROR, G_IO_ERROR_INVALID_DATA);\n\tg_assert_null(buf);\n}\n\nstatic gboolean\nfu_device_poll_cb(FuDevice *device, GError **error)\n{\n\tguint64 cnt = fu_device_get_metadata_integer(device, \"cnt\");\n\tg_debug(\"poll cnt=%\" G_GUINT64_FORMAT, cnt);\n\tfu_device_set_metadata_integer(device, \"cnt\", cnt + 1);\n\treturn TRUE;\n}\n\nstatic void\nfu_device_poll_func(void)\n{\n\tg_autoptr(FuDevice) device = fu_device_new(NULL);\n\tFuDeviceClass *klass = FU_DEVICE_GET_CLASS(device);\n\tguint cnt;\n\n\t/* set up a 10ms poll */\n\tklass->poll = fu_device_poll_cb;\n\tfu_device_set_metadata_integer(device, \"cnt\", 0);\n\tfu_device_set_poll_interval(device, 10);\n\tfu_test_loop_run_with_timeout(100);\n\tfu_test_loop_quit();\n\tcnt = fu_device_get_metadata_integer(device, \"cnt\");\n\tg_assert_cmpint(cnt, >=, 8);\n\n\t/* disable the poll */\n\tfu_device_set_poll_interval(device, 0);\n\tfu_test_loop_run_with_timeout(100);\n\tfu_test_loop_quit();\n\tg_assert_cmpint(fu_device_get_metadata_integer(device, \"cnt\"), ==, cnt);\n}\n\nstatic void\nfu_device_func(void)\n{\n\tg_autoptr(FuDevice) device = fu_device_new(NULL);\n\tg_autoptr(GPtrArray) possible_plugins = NULL;\n\n\t/* only add one plugin name of the same type */\n\tfu_device_add_possible_plugin(device, \"test\");\n\tfu_device_add_possible_plugin(device, \"test\");\n\tpossible_plugins = fu_device_get_possible_plugins(device);\n\tg_assert_cmpint(possible_plugins->len, ==, 1);\n\n\tg_assert_cmpint(fu_device_get_backend_tags(device)->len, ==, 0);\n\tfu_device_add_backend_tag(device, \"foo\");\n\tfu_device_add_backend_tag(device, \"bar\");\n\tg_assert_cmpint(fu_device_get_backend_tags(device)->len, ==, 2);\n\tg_assert_true(fu_device_has_backend_tag(device, \"foo\"));\n\tg_assert_false(fu_device_has_backend_tag(device, \"bazbazbazbazbaz\"));\n}\n\nstatic void\nfu_device_instance_ids_func(void)\n{\n\tgboolean ret;\n\tg_autoptr(FuContext) ctx = fu_context_new();\n\tg_autoptr(FuDevice) device = fu_device_new(ctx);\n\tg_autoptr(GError) error = NULL;\n\n\t/* do not save silo */\n\tret = fu_context_load_quirks(ctx, FU_QUIRKS_LOAD_FLAG_NO_CACHE, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\n\t/* sanity check */\n\tg_assert_false(fu_device_has_guid(device, \"c0a26214-223b-572a-9477-cde897fe8619\"));\n\n\t/* add a deferred instance ID that only gets converted on ->setup */\n\tfu_device_add_instance_id(device, \"foobarbaz\");\n\tg_assert_false(fu_device_has_guid(device, \"c0a26214-223b-572a-9477-cde897fe8619\"));\n\n\tret = fu_device_setup(device, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_assert_true(fu_device_has_guid(device, \"c0a26214-223b-572a-9477-cde897fe8619\"));\n\n\t/* this gets added immediately */\n\tfu_device_add_instance_id(device, \"bazbarfoo\");\n\tg_assert_true(fu_device_has_guid(device, \"77e49bb0-2cd6-5faf-bcee-5b7fbe6e944d\"));\n}\n\nstatic void\nfu_device_composite_id_func(void)\n{\n\tg_autoptr(FuDevice) dev1 = fu_device_new(NULL);\n\tg_autoptr(FuDevice) dev2 = fu_device_new(NULL);\n\tg_autoptr(FuDevice) dev3 = fu_device_new(NULL);\n\tg_autoptr(FuDevice) dev4 = fu_device_new(NULL);\n\n\t/* single device */\n\tfu_device_set_id(dev1, \"dev1\");\n\tg_assert_cmpstr(fu_device_get_composite_id(dev1),\n\t\t\t==,\n\t\t\t\"3b42553c4e3241e8f3f8fbc19a69fa2f95708a9d\");\n\tfu_device_set_id(dev2, \"dev2\");\n\n\t/* one child */\n\tfu_device_add_child(dev1, dev2);\n\tg_assert_cmpstr(fu_device_get_composite_id(dev1),\n\t\t\t==,\n\t\t\t\"3b42553c4e3241e8f3f8fbc19a69fa2f95708a9d\");\n\tg_assert_cmpstr(fu_device_get_composite_id(dev2),\n\t\t\t==,\n\t\t\t\"3b42553c4e3241e8f3f8fbc19a69fa2f95708a9d\");\n\n\t/* add a different \"family\" */\n\tfu_device_set_id(dev3, \"dev3\");\n\tfu_device_set_id(dev4, \"dev4\");\n\tfu_device_add_child(dev3, dev4);\n\tfu_device_add_child(dev2, dev3);\n\tg_assert_cmpstr(fu_device_get_composite_id(dev1),\n\t\t\t==,\n\t\t\t\"3b42553c4e3241e8f3f8fbc19a69fa2f95708a9d\");\n\tg_assert_cmpstr(fu_device_get_composite_id(dev2),\n\t\t\t==,\n\t\t\t\"3b42553c4e3241e8f3f8fbc19a69fa2f95708a9d\");\n\tg_assert_cmpstr(fu_device_get_composite_id(dev3),\n\t\t\t==,\n\t\t\t\"3b42553c4e3241e8f3f8fbc19a69fa2f95708a9d\");\n\tg_assert_cmpstr(fu_device_get_composite_id(dev4),\n\t\t\t==,\n\t\t\t\"3b42553c4e3241e8f3f8fbc19a69fa2f95708a9d\");\n\n\t/* change the parent ID */\n\tfu_device_set_id(dev1, \"dev1-NEW\");\n\tg_assert_cmpstr(fu_device_get_composite_id(dev1),\n\t\t\t==,\n\t\t\t\"a4c8efc6a0a58c2dc14c05fd33186703f7352997\");\n\tg_assert_cmpstr(fu_device_get_composite_id(dev2),\n\t\t\t==,\n\t\t\t\"a4c8efc6a0a58c2dc14c05fd33186703f7352997\");\n}\n\nstatic void\nfu_device_inhibit_func(void)\n{\n\tg_autoptr(FuDevice) device = fu_device_new(NULL);\n\n\tfu_device_add_flag(device, FWUPD_DEVICE_FLAG_UPDATABLE);\n\tfu_device_set_battery_threshold(device, 25);\n\tg_assert_true(fu_device_has_flag(device, FWUPD_DEVICE_FLAG_UPDATABLE));\n\tg_assert_false(fu_device_has_flag(device, FWUPD_DEVICE_FLAG_UPDATABLE_HIDDEN));\n\n\t/* does not exist -> fine */\n\tfu_device_uninhibit(device, \"NOTGOINGTOEXIST\");\n\tg_assert_false(fu_device_has_inhibit(device, \"NOTGOINGTOEXIST\"));\n\n\t/* first one */\n\tfu_device_inhibit(device, \"needs-activation\", \"Device is pending activation\");\n\tg_assert_true(fu_device_has_inhibit(device, \"needs-activation\"));\n\tg_assert_true(fu_device_has_flag(device, FWUPD_DEVICE_FLAG_UPDATABLE_HIDDEN));\n\tg_assert_false(fu_device_has_flag(device, FWUPD_DEVICE_FLAG_UPDATABLE));\n\n\t/* another */\n\tfu_device_set_battery_level(device, 5);\n\tg_assert_true(fu_device_has_flag(device, FWUPD_DEVICE_FLAG_UPDATABLE_HIDDEN));\n\tg_assert_false(fu_device_has_flag(device, FWUPD_DEVICE_FLAG_UPDATABLE));\n\n\t/* activated, power still too low */\n\tfu_device_uninhibit(device, \"needs-activation\");\n\tg_assert_false(fu_device_has_inhibit(device, \"needs-activation\"));\n\tg_assert_true(fu_device_has_flag(device, FWUPD_DEVICE_FLAG_UPDATABLE_HIDDEN));\n\tg_assert_false(fu_device_has_flag(device, FWUPD_DEVICE_FLAG_UPDATABLE));\n\n\t/* we got some more power -> fine */\n\tfu_device_set_battery_level(device, 95);\n\tg_assert_true(fu_device_has_flag(device, FWUPD_DEVICE_FLAG_UPDATABLE));\n\tg_assert_false(fu_device_has_flag(device, FWUPD_DEVICE_FLAG_UPDATABLE_HIDDEN));\n}\n\nstatic void\nfu_device_inhibit_updateable_func(void)\n{\n\tg_autoptr(FuDevice) device = fu_device_new(NULL);\n\n\tg_assert_false(fu_device_has_flag(device, FWUPD_DEVICE_FLAG_UPDATABLE));\n\tg_assert_false(fu_device_has_flag(device, FWUPD_DEVICE_FLAG_UPDATABLE_HIDDEN));\n\tg_assert_cmpstr(fu_device_get_update_error(device), ==, NULL);\n\n\t/* first one */\n\tfu_device_inhibit(device, \"needs-activation\", \"Device is pending activation\");\n\tg_assert_false(fu_device_has_flag(device, FWUPD_DEVICE_FLAG_UPDATABLE_HIDDEN));\n\tg_assert_false(fu_device_has_flag(device, FWUPD_DEVICE_FLAG_UPDATABLE));\n\tg_assert_cmpstr(fu_device_get_update_error(device), ==, \"Device is pending activation\");\n\n\t/* activated, but still not updatable */\n\tfu_device_uninhibit(device, \"needs-activation\");\n\tg_assert_false(fu_device_has_flag(device, FWUPD_DEVICE_FLAG_UPDATABLE));\n\tg_assert_false(fu_device_has_flag(device, FWUPD_DEVICE_FLAG_UPDATABLE_HIDDEN));\n\tg_assert_cmpstr(fu_device_get_update_error(device), ==, NULL);\n}\n\n#define TEST_FLAG_FOO (1 << 0)\n#define TEST_FLAG_BAR (1 << 1)\n#define TEST_FLAG_BAZ (1 << 2)\n\nstatic void\nfu_device_private_flags_func(void)\n{\n\tg_autofree gchar *tmp = NULL;\n\tg_autoptr(FuDevice) device = fu_device_new(NULL);\n\n\tfu_device_register_private_flag(device, TEST_FLAG_FOO, \"foo\");\n\tfu_device_register_private_flag(device, TEST_FLAG_BAR, \"bar\");\n\n\tfu_device_set_custom_flags(device, \"foo\");\n\tg_assert_cmpint(fu_device_get_private_flags(device), ==, TEST_FLAG_FOO);\n\tfu_device_set_custom_flags(device, \"bar\");\n\tg_assert_cmpint(fu_device_get_private_flags(device), ==, TEST_FLAG_FOO | TEST_FLAG_BAR);\n\tfu_device_set_custom_flags(device, \"~bar\");\n\tg_assert_cmpint(fu_device_get_private_flags(device), ==, TEST_FLAG_FOO);\n\tfu_device_set_custom_flags(device, \"baz\");\n\tg_assert_cmpint(fu_device_get_private_flags(device), ==, TEST_FLAG_FOO);\n\tfu_device_add_private_flag(device, TEST_FLAG_BAZ);\n\tg_assert_cmpint(fu_device_get_private_flags(device), ==, TEST_FLAG_FOO | TEST_FLAG_BAZ);\n\n\ttmp = fu_device_to_string(device);\n\tg_assert_cmpstr(tmp,\n\t\t\t==,\n\t\t\t\"FuDevice:\\n\"\n\t\t\t\"  Flags:                none\\n\"\n\t\t\t\"  AcquiesceDelay:       50\\n\"\n\t\t\t\"  CustomFlags:          baz\\n\"\n\t\t\t\"  PrivateFlags:         foo\\n\");\n}\n\nstatic void\nfu_device_flags_func(void)\n{\n\tg_autoptr(FuDevice) device = fu_device_new(NULL);\n\n\t/* bitfield */\n\tfor (guint64 i = 1; i < FU_DEVICE_INTERNAL_FLAG_UNKNOWN; i *= 2) {\n\t\tconst gchar *tmp = fu_device_internal_flag_to_string(i);\n\t\tif (tmp == NULL)\n\t\t\tbreak;\n\t\tg_assert_cmpint(fu_device_internal_flag_from_string(tmp), ==, i);\n\t}\n\n\tg_assert_cmpint(fu_device_get_flags(device), ==, FWUPD_DEVICE_FLAG_NONE);\n\n\t/* remove IS_BOOTLOADER if is a BOOTLOADER */\n\tfu_device_add_flag(device, FWUPD_DEVICE_FLAG_IS_BOOTLOADER);\n\tfu_device_add_flag(device, FWUPD_DEVICE_FLAG_NEEDS_BOOTLOADER);\n\tg_assert_cmpint(fu_device_get_flags(device), ==, FWUPD_DEVICE_FLAG_NEEDS_BOOTLOADER);\n\tfu_device_remove_flag(device, FWUPD_DEVICE_FLAG_NEEDS_BOOTLOADER);\n\n\t/* check implication */\n\tfu_device_add_flag(device, FWUPD_DEVICE_FLAG_CAN_VERIFY_IMAGE);\n\tg_assert_cmpint(fu_device_get_flags(device),\n\t\t\t==,\n\t\t\tFWUPD_DEVICE_FLAG_CAN_VERIFY_IMAGE | FWUPD_DEVICE_FLAG_CAN_VERIFY);\n\tfu_device_remove_flag(device,\n\t\t\t      FWUPD_DEVICE_FLAG_CAN_VERIFY | FWUPD_DEVICE_FLAG_CAN_VERIFY_IMAGE);\n\n\t/* negation */\n\tfu_device_set_custom_flags(device, \"is-bootloader,updatable\");\n\tg_assert_cmpint(fu_device_get_flags(device),\n\t\t\t==,\n\t\t\tFWUPD_DEVICE_FLAG_IS_BOOTLOADER | FWUPD_DEVICE_FLAG_UPDATABLE);\n\tfu_device_set_custom_flags(device, \"~is-bootloader\");\n\tg_assert_cmpint(fu_device_get_flags(device), ==, FWUPD_DEVICE_FLAG_UPDATABLE);\n}\n\nstatic void\nfu_device_children_func(void)\n{\n\tgboolean ret;\n\tg_autoptr(FuContext) ctx = fu_context_new();\n\tg_autoptr(FuDevice) child = fu_device_new(NULL);\n\tg_autoptr(FuDevice) parent = fu_device_new(ctx);\n\tg_autoptr(GError) error = NULL;\n\n\t/* do not save silo */\n\tret = fu_context_load_quirks(ctx, FU_QUIRKS_LOAD_FLAG_NO_CACHE, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\n\tfu_device_set_physical_id(child, \"dummy\");\n\tfu_device_set_physical_id(parent, \"dummy\");\n\n\t/* set up family */\n\tfu_device_add_child(parent, child);\n\n\t/* set an instance ID that will be converted to a GUID when the parent\n\t * calls ->setup */\n\tfu_device_add_instance_id(child, \"foo\");\n\tg_assert_false(fu_device_has_guid(child, \"b84ed8ed-a7b1-502f-83f6-90132e68adef\"));\n\n\t/* setup parent, which also calls setup on child too (and thus also\n\t * converts the instance ID to a GUID) */\n\tret = fu_device_setup(parent, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_assert_true(fu_device_has_guid(child, \"b84ed8ed-a7b1-502f-83f6-90132e68adef\"));\n}\n\nstatic void\nfu_device_parent_func(void)\n{\n\tg_autoptr(FuDevice) child = fu_device_new(NULL);\n\tg_autoptr(FuDevice) child_root = NULL;\n\tg_autoptr(FuDevice) grandparent = fu_device_new(NULL);\n\tg_autoptr(FuDevice) grandparent_root = NULL;\n\tg_autoptr(FuDevice) parent = fu_device_new(NULL);\n\tg_autoptr(FuDevice) parent_root = NULL;\n\n\tfu_device_set_physical_id(child, \"dummy\");\n\tfu_device_set_physical_id(grandparent, \"dummy\");\n\tfu_device_set_physical_id(parent, \"dummy\");\n\n\t/* set up three layer family */\n\tfu_device_add_child(grandparent, parent);\n\tfu_device_add_child(parent, child);\n\n\t/* check parents */\n\tg_assert_true(fu_device_get_parent(child) == parent);\n\tg_assert_true(fu_device_get_parent(parent) == grandparent);\n\tg_assert_true(fu_device_get_parent(grandparent) == NULL);\n\n\t/* check root */\n\tchild_root = fu_device_get_root(child);\n\tg_assert_true(child_root == grandparent);\n\tparent_root = fu_device_get_root(parent);\n\tg_assert_true(parent_root == grandparent);\n\tgrandparent_root = fu_device_get_root(child);\n\tg_assert_true(grandparent_root == grandparent);\n}\n\nstatic void\nfu_device_incorporate_func(void)\n{\n\tgboolean ret;\n\tg_autoptr(FuContext) ctx = fu_context_new();\n\tg_autoptr(FuDevice) device = fu_device_new(ctx);\n\tg_autoptr(FuDevice) donor = fu_device_new(ctx);\n\tg_autoptr(GError) error = NULL;\n\n\t/* set up donor device */\n\tfu_device_set_alternate_id(donor, \"alt-id\");\n\tfu_device_set_equivalent_id(donor, \"equiv-id\");\n\tfu_device_set_metadata(donor, \"test\", \"me\");\n\tfu_device_set_metadata(donor, \"test2\", \"me\");\n\tfu_device_add_instance_str(donor, \"VID\", \"1234\");\n\n\t/* base properties */\n\tfu_device_add_flag(donor, FWUPD_DEVICE_FLAG_REQUIRE_AC);\n\tfu_device_set_created(donor, 123);\n\tfu_device_set_modified(donor, 456);\n\tfu_device_add_icon(donor, \"computer\");\n\n\t/* existing properties */\n\tfu_device_set_equivalent_id(device, \"DO_NOT_OVERWRITE\");\n\tfu_device_set_metadata(device, \"test2\", \"DO_NOT_OVERWRITE\");\n\tfu_device_set_modified(device, 789);\n\n\t/* incorporate properties from donor to device */\n\tfu_device_incorporate(device, donor);\n\tg_assert_cmpstr(fu_device_get_alternate_id(device), ==, \"alt-id\");\n\tg_assert_cmpstr(fu_device_get_equivalent_id(device), ==, \"DO_NOT_OVERWRITE\");\n\tg_assert_cmpstr(fu_device_get_metadata(device, \"test\"), ==, \"me\");\n\tg_assert_cmpstr(fu_device_get_metadata(device, \"test2\"), ==, \"DO_NOT_OVERWRITE\");\n\tg_assert_true(fu_device_has_flag(device, FWUPD_DEVICE_FLAG_REQUIRE_AC));\n\tg_assert_cmpint(fu_device_get_created(device), ==, 123);\n\tg_assert_cmpint(fu_device_get_modified(device), ==, 789);\n\tg_assert_cmpint(fu_device_get_icons(device)->len, ==, 1);\n\tret = fu_device_build_instance_id(device, &error, \"SUBSYS\", \"VID\", NULL);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_assert_true(fu_device_has_instance_id(device, \"SUBSYS\\\\VID_1234\"));\n}\n\nstatic void\nfu_backend_func(void)\n{\n\tFuDevice *dev;\n\tgboolean ret;\n\tg_autoptr(FuBackend) backend = g_object_new(FU_TYPE_BACKEND, NULL);\n\tg_autoptr(FuDevice) dev1 = fu_device_new(NULL);\n\tg_autoptr(FuDevice) dev2 = fu_device_new(NULL);\n\tg_autoptr(FuProgress) progress = fu_progress_new(G_STRLOC);\n\tg_autoptr(GError) error = NULL;\n\tg_autoptr(GPtrArray) devices = NULL;\n\n\t/* defaults */\n\tg_assert_null(fu_backend_get_name(backend));\n\tg_assert_true(fu_backend_get_enabled(backend));\n\n\t/* load */\n\tret = fu_backend_setup(backend, progress, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tret = fu_backend_coldplug(backend, progress, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\n\t/* add two devices, then remove one of them */\n\tfu_device_set_physical_id(dev1, \"dev1\");\n\tfu_backend_device_added(backend, dev1);\n\tfu_device_set_physical_id(dev2, \"dev2\");\n\tfu_backend_device_added(backend, dev2);\n\tfu_backend_device_changed(backend, dev2);\n\tfu_backend_device_removed(backend, dev2);\n\n\tdev = fu_backend_lookup_by_id(backend, \"dev1\");\n\tg_assert_nonnull(dev);\n\tg_assert_true(dev == dev1);\n\n\t/* should have been removed */\n\tdev = fu_backend_lookup_by_id(backend, \"dev2\");\n\tg_assert_null(dev);\n\n\t/* get linear array */\n\tdevices = fu_backend_get_devices(backend);\n\tg_assert_nonnull(devices);\n\tg_assert_cmpint(devices->len, ==, 1);\n\tdev = g_ptr_array_index(devices, 0);\n\tg_assert_nonnull(dev);\n\tg_assert_true(dev == dev1);\n}\n\nstatic void\nfu_chunk_func(void)\n{\n\tg_autofree gchar *chunked1_str = NULL;\n\tg_autofree gchar *chunked2_str = NULL;\n\tg_autofree gchar *chunked3_str = NULL;\n\tg_autofree gchar *chunked4_str = NULL;\n\tg_autoptr(GPtrArray) chunked1 = NULL;\n\tg_autoptr(GPtrArray) chunked2 = NULL;\n\tg_autoptr(GPtrArray) chunked3 = NULL;\n\tg_autoptr(GPtrArray) chunked4 = NULL;\n\n\tchunked3 = fu_chunk_array_new((const guint8 *)\"123456\", 6, 0x0, 3, 3);\n\tchunked3_str = fu_chunk_array_to_string(chunked3);\n\tg_assert_cmpstr(chunked3_str,\n\t\t\t==,\n\t\t\t\"<chunks>\\n\"\n\t\t\t\"  <chunk>\\n\"\n\t\t\t\"    <data size=\\\"0x3\\\">123</data>\\n\"\n\t\t\t\"  </chunk>\\n\"\n\t\t\t\"  <chunk>\\n\"\n\t\t\t\"    <idx>0x1</idx>\\n\"\n\t\t\t\"    <page>0x1</page>\\n\"\n\t\t\t\"    <data size=\\\"0x3\\\">456</data>\\n\"\n\t\t\t\"  </chunk>\\n\"\n\t\t\t\"</chunks>\\n\");\n\n\tchunked4 = fu_chunk_array_new((const guint8 *)\"123456\", 6, 0x4, 4, 4);\n\tchunked4_str = fu_chunk_array_to_string(chunked4);\n\tg_assert_cmpstr(chunked4_str,\n\t\t\t==,\n\t\t\t\"<chunks>\\n\"\n\t\t\t\"  <chunk>\\n\"\n\t\t\t\"    <page>0x1</page>\\n\"\n\t\t\t\"    <data size=\\\"0x4\\\">1234</data>\\n\"\n\t\t\t\"  </chunk>\\n\"\n\t\t\t\"  <chunk>\\n\"\n\t\t\t\"    <idx>0x1</idx>\\n\"\n\t\t\t\"    <page>0x2</page>\\n\"\n\t\t\t\"    <data size=\\\"0x2\\\">56</data>\\n\"\n\t\t\t\"  </chunk>\\n\"\n\t\t\t\"</chunks>\\n\");\n\n\tchunked1 = fu_chunk_array_new((const guint8 *)\"0123456789abcdef\", 16, 0x0, 10, 4);\n\tchunked1_str = fu_chunk_array_to_string(chunked1);\n\tg_assert_cmpstr(chunked1_str,\n\t\t\t==,\n\t\t\t\"<chunks>\\n\"\n\t\t\t\"  <chunk>\\n\"\n\t\t\t\"    <data size=\\\"0x4\\\">0123</data>\\n\"\n\t\t\t\"  </chunk>\\n\"\n\t\t\t\"  <chunk>\\n\"\n\t\t\t\"    <idx>0x1</idx>\\n\"\n\t\t\t\"    <addr>0x4</addr>\\n\"\n\t\t\t\"    <data size=\\\"0x4\\\">4567</data>\\n\"\n\t\t\t\"  </chunk>\\n\"\n\t\t\t\"  <chunk>\\n\"\n\t\t\t\"    <idx>0x2</idx>\\n\"\n\t\t\t\"    <addr>0x8</addr>\\n\"\n\t\t\t\"    <data size=\\\"0x2\\\">89</data>\\n\"\n\t\t\t\"  </chunk>\\n\"\n\t\t\t\"  <chunk>\\n\"\n\t\t\t\"    <idx>0x3</idx>\\n\"\n\t\t\t\"    <page>0x1</page>\\n\"\n\t\t\t\"    <data size=\\\"0x4\\\">abcd</data>\\n\"\n\t\t\t\"  </chunk>\\n\"\n\t\t\t\"  <chunk>\\n\"\n\t\t\t\"    <idx>0x4</idx>\\n\"\n\t\t\t\"    <page>0x1</page>\\n\"\n\t\t\t\"    <addr>0x4</addr>\\n\"\n\t\t\t\"    <data size=\\\"0x2\\\">ef</data>\\n\"\n\t\t\t\"  </chunk>\\n\"\n\t\t\t\"</chunks>\\n\");\n\tchunked2 = fu_chunk_array_new((const guint8 *)\"XXXXXXYYYYYYZZZZZZ\", 18, 0x0, 6, 4);\n\tchunked2_str = fu_chunk_array_to_string(chunked2);\n\tg_print(\"\\n%s\", chunked2_str);\n\tg_assert_cmpstr(chunked2_str,\n\t\t\t==,\n\t\t\t\"<chunks>\\n\"\n\t\t\t\"  <chunk>\\n\"\n\t\t\t\"    <data size=\\\"0x4\\\">XXXX</data>\\n\"\n\t\t\t\"  </chunk>\\n\"\n\t\t\t\"  <chunk>\\n\"\n\t\t\t\"    <idx>0x1</idx>\\n\"\n\t\t\t\"    <addr>0x4</addr>\\n\"\n\t\t\t\"    <data size=\\\"0x2\\\">XX</data>\\n\"\n\t\t\t\"  </chunk>\\n\"\n\t\t\t\"  <chunk>\\n\"\n\t\t\t\"    <idx>0x2</idx>\\n\"\n\t\t\t\"    <page>0x1</page>\\n\"\n\t\t\t\"    <data size=\\\"0x4\\\">YYYY</data>\\n\"\n\t\t\t\"  </chunk>\\n\"\n\t\t\t\"  <chunk>\\n\"\n\t\t\t\"    <idx>0x3</idx>\\n\"\n\t\t\t\"    <page>0x1</page>\\n\"\n\t\t\t\"    <addr>0x4</addr>\\n\"\n\t\t\t\"    <data size=\\\"0x2\\\">YY</data>\\n\"\n\t\t\t\"  </chunk>\\n\"\n\t\t\t\"  <chunk>\\n\"\n\t\t\t\"    <idx>0x4</idx>\\n\"\n\t\t\t\"    <page>0x2</page>\\n\"\n\t\t\t\"    <data size=\\\"0x4\\\">ZZZZ</data>\\n\"\n\t\t\t\"  </chunk>\\n\"\n\t\t\t\"  <chunk>\\n\"\n\t\t\t\"    <idx>0x5</idx>\\n\"\n\t\t\t\"    <page>0x2</page>\\n\"\n\t\t\t\"    <addr>0x4</addr>\\n\"\n\t\t\t\"    <data size=\\\"0x2\\\">ZZ</data>\\n\"\n\t\t\t\"  </chunk>\\n\"\n\t\t\t\"</chunks>\\n\");\n}\n\nstatic void\nfu_strstrip_func(void)\n{\n\tstruct {\n\t\tconst gchar *old;\n\t\tconst gchar *new;\n\t} map[] = {{\"same\", \"same\"},\n\t\t   {\" leading\", \"leading\"},\n\t\t   {\"tailing \", \"tailing\"},\n\t\t   {\"  b  \", \"b\"},\n\t\t   {\"  \", \"\"},\n\t\t   {NULL, NULL}};\n\tfor (guint i = 0; map[i].old != NULL; i++) {\n\t\tg_autofree gchar *tmp = fu_strstrip(map[i].old);\n\t\tg_assert_cmpstr(tmp, ==, map[i].new);\n\t}\n}\n\nstatic void\nfu_version_semver_func(void)\n{\n\tstruct {\n\t\tconst gchar *old;\n\t\tconst gchar *new;\n\t\tFwupdVersionFormat fmt;\n\t} map[] = {{\"1.2.3\", \"1.2.3\", FWUPD_VERSION_FORMAT_TRIPLET},\n\t\t   {\"1.2.3.4\", \"1.2.3\", FWUPD_VERSION_FORMAT_TRIPLET},\n\t\t   {\"1.2\", \"0.1.2\", FWUPD_VERSION_FORMAT_TRIPLET},\n\t\t   {\"1\", \"0.0.1\", FWUPD_VERSION_FORMAT_TRIPLET},\n\t\t   {\"CBET1.2.3\", \"1.2.3\", FWUPD_VERSION_FORMAT_TRIPLET},\n\t\t   {\"4.11-1190-g12d8072e6b-dirty\", \"4.11.1190\", FWUPD_VERSION_FORMAT_TRIPLET},\n\t\t   {\"4.11-1190-g12d8072e6b-dirty\", \"4.11\", FWUPD_VERSION_FORMAT_PAIR},\n\t\t   {NULL, NULL}};\n\tfor (guint i = 0; map[i].old != NULL; i++) {\n\t\tg_autofree gchar *tmp = fu_version_ensure_semver(map[i].old, map[i].fmt);\n\t\tg_assert_cmpstr(tmp, ==, map[i].new);\n\t}\n}\n\nstatic void\nfu_strtoull_func(void)\n{\n\tgboolean ret;\n\tguint64 val = 0;\n\tg_autoptr(GError) error = NULL;\n\n\tret = fu_strtoull(\"123\", &val, 123, 200, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_assert_cmpint(val, ==, 123);\n\n\tret = fu_strtoull(\"123\\n\", &val, 0, 200, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_assert_cmpint(val, ==, 123);\n\n\tret = fu_strtoull(\"0x123\", &val, 0, 0x123, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_assert_cmpint(val, ==, 0x123);\n\n\tret = fu_strtoull(NULL, &val, 0, G_MAXUINT32, NULL);\n\tg_assert_false(ret);\n\tret = fu_strtoull(\"\", &val, 120, 123, NULL);\n\tg_assert_false(ret);\n\tret = fu_strtoull(\"124\", &val, 120, 123, NULL);\n\tg_assert_false(ret);\n\tret = fu_strtoull(\"119\", &val, 120, 123, NULL);\n\tg_assert_false(ret);\n}\n\nstatic void\nfu_common_version_func(void)\n{\n\tguint i;\n\tstruct {\n\t\tguint32 val;\n\t\tconst gchar *ver;\n\t\tFwupdVersionFormat flags;\n\t} version_from_uint32[] = {\n\t    {0x0, \"0.0.0.0\", FWUPD_VERSION_FORMAT_QUAD},\n\t    {0xff, \"0.0.0.255\", FWUPD_VERSION_FORMAT_QUAD},\n\t    {0xff01, \"0.0.255.1\", FWUPD_VERSION_FORMAT_QUAD},\n\t    {0xff0001, \"0.255.0.1\", FWUPD_VERSION_FORMAT_QUAD},\n\t    {0xff000100, \"255.0.1.0\", FWUPD_VERSION_FORMAT_QUAD},\n\t    {0x0, \"0.0.0\", FWUPD_VERSION_FORMAT_TRIPLET},\n\t    {0xff, \"0.0.255\", FWUPD_VERSION_FORMAT_TRIPLET},\n\t    {0xff01, \"0.0.65281\", FWUPD_VERSION_FORMAT_TRIPLET},\n\t    {0xff0001, \"0.255.1\", FWUPD_VERSION_FORMAT_TRIPLET},\n\t    {0xff000100, \"255.0.256\", FWUPD_VERSION_FORMAT_TRIPLET},\n\t    {0x0, \"0\", FWUPD_VERSION_FORMAT_NUMBER},\n\t    {0xff000100, \"4278190336\", FWUPD_VERSION_FORMAT_NUMBER},\n\t    {0x0, \"11.0.0.0\", FWUPD_VERSION_FORMAT_INTEL_ME},\n\t    {0xffffffff, \"18.31.255.65535\", FWUPD_VERSION_FORMAT_INTEL_ME},\n\t    {0x0b32057a, \"11.11.50.1402\", FWUPD_VERSION_FORMAT_INTEL_ME},\n\t    {0xb8320d84, \"11.8.50.3460\", FWUPD_VERSION_FORMAT_INTEL_ME2},\n\t    {0x226a4b00, \"137.2706.768\", FWUPD_VERSION_FORMAT_SURFACE_LEGACY},\n\t    {0x6001988, \"6.25.136\", FWUPD_VERSION_FORMAT_SURFACE},\n\t    {0x00ff0001, \"255.0.1\", FWUPD_VERSION_FORMAT_DELL_BIOS},\n\t    {0xc8, \"0x000000c8\", FWUPD_VERSION_FORMAT_HEX},\n\t    {0, NULL}};\n\tstruct {\n\t\tguint64 val;\n\t\tconst gchar *ver;\n\t\tFwupdVersionFormat flags;\n\t} version_from_uint64[] = {\n\t    {0x0, \"0.0.0.0\", FWUPD_VERSION_FORMAT_QUAD},\n\t    {0xff, \"0.0.0.255\", FWUPD_VERSION_FORMAT_QUAD},\n\t    {0xffffffffffffffff, \"65535.65535.65535.65535\", FWUPD_VERSION_FORMAT_QUAD},\n\t    {0xff, \"0.255\", FWUPD_VERSION_FORMAT_PAIR},\n\t    {0xffffffffffffffff, \"4294967295.4294967295\", FWUPD_VERSION_FORMAT_PAIR},\n\t    {0x0, \"0\", FWUPD_VERSION_FORMAT_NUMBER},\n\t    {0x11000000c8, \"0x00000011000000c8\", FWUPD_VERSION_FORMAT_HEX},\n\t    {0, NULL}};\n\tstruct {\n\t\tguint16 val;\n\t\tconst gchar *ver;\n\t\tFwupdVersionFormat flags;\n\t} version_from_uint16[] = {{0x0, \"0.0\", FWUPD_VERSION_FORMAT_PAIR},\n\t\t\t\t   {0xff, \"0.255\", FWUPD_VERSION_FORMAT_PAIR},\n\t\t\t\t   {0xff01, \"255.1\", FWUPD_VERSION_FORMAT_PAIR},\n\t\t\t\t   {0x0, \"0.0\", FWUPD_VERSION_FORMAT_BCD},\n\t\t\t\t   {0x0110, \"1.10\", FWUPD_VERSION_FORMAT_BCD},\n\t\t\t\t   {0x9999, \"99.99\", FWUPD_VERSION_FORMAT_BCD},\n\t\t\t\t   {0x0, \"0\", FWUPD_VERSION_FORMAT_NUMBER},\n\t\t\t\t   {0x1234, \"4660\", FWUPD_VERSION_FORMAT_NUMBER},\n\t\t\t\t   {0, NULL}};\n\tstruct {\n\t\tconst gchar *old;\n\t\tconst gchar *new;\n\t} version_parse[] = {{\"0\", \"0\"},\n\t\t\t     {\"0x1a\", \"0.0.26\"},\n\t\t\t     {\"257\", \"0.0.257\"},\n\t\t\t     {\"1.2.3\", \"1.2.3\"},\n\t\t\t     {\"0xff0001\", \"0.255.1\"},\n\t\t\t     {\"16711681\", \"0.255.1\"},\n\t\t\t     {\"20150915\", \"20150915\"},\n\t\t\t     {\"dave\", \"dave\"},\n\t\t\t     {\"0x1x\", \"0x1x\"},\n\t\t\t     {NULL, NULL}};\n\n\t/* check version conversion */\n\tfor (i = 0; version_from_uint64[i].ver != NULL; i++) {\n\t\tg_autofree gchar *ver = NULL;\n\t\tver = fu_version_from_uint64(version_from_uint64[i].val,\n\t\t\t\t\t     version_from_uint64[i].flags);\n\t\tg_assert_cmpstr(ver, ==, version_from_uint64[i].ver);\n\t}\n\tfor (i = 0; version_from_uint32[i].ver != NULL; i++) {\n\t\tg_autofree gchar *ver = NULL;\n\t\tver = fu_version_from_uint32(version_from_uint32[i].val,\n\t\t\t\t\t     version_from_uint32[i].flags);\n\t\tg_assert_cmpstr(ver, ==, version_from_uint32[i].ver);\n\t}\n\tfor (i = 0; version_from_uint16[i].ver != NULL; i++) {\n\t\tg_autofree gchar *ver = NULL;\n\t\tver = fu_version_from_uint16(version_from_uint16[i].val,\n\t\t\t\t\t     version_from_uint16[i].flags);\n\t\tg_assert_cmpstr(ver, ==, version_from_uint16[i].ver);\n\t}\n\n\t/* check version parsing */\n\tfor (i = 0; version_parse[i].old != NULL; i++) {\n\t\tg_autofree gchar *ver = NULL;\n\t\tver = fu_version_parse_from_format(version_parse[i].old,\n\t\t\t\t\t\t   FWUPD_VERSION_FORMAT_TRIPLET);\n\t\tg_assert_cmpstr(ver, ==, version_parse[i].new);\n\t}\n}\n\nstatic void\nfu_common_vercmp_func(void)\n{\n\t/* same */\n\tg_assert_cmpint(fu_version_compare(\"1.2.3\", \"1.2.3\", FWUPD_VERSION_FORMAT_UNKNOWN), ==, 0);\n\tg_assert_cmpint(\n\t    fu_version_compare(\"001.002.003\", \"001.002.003\", FWUPD_VERSION_FORMAT_UNKNOWN),\n\t    ==,\n\t    0);\n\tg_assert_cmpint(fu_version_compare(\"0x00000002\", \"0x2\", FWUPD_VERSION_FORMAT_HEX), ==, 0);\n\n\t/* upgrade and downgrade */\n\tg_assert_cmpint(fu_version_compare(\"1.2.3\", \"1.2.4\", FWUPD_VERSION_FORMAT_UNKNOWN), <, 0);\n\tg_assert_cmpint(\n\t    fu_version_compare(\"001.002.000\", \"001.002.009\", FWUPD_VERSION_FORMAT_UNKNOWN),\n\t    <,\n\t    0);\n\tg_assert_cmpint(fu_version_compare(\"1.2.3\", \"1.2.2\", FWUPD_VERSION_FORMAT_UNKNOWN), >, 0);\n\tg_assert_cmpint(\n\t    fu_version_compare(\"001.002.009\", \"001.002.000\", FWUPD_VERSION_FORMAT_UNKNOWN),\n\t    >,\n\t    0);\n\n\t/* unequal depth */\n\tg_assert_cmpint(fu_version_compare(\"1.2.3\", \"1.2.3.1\", FWUPD_VERSION_FORMAT_UNKNOWN), <, 0);\n\tg_assert_cmpint(fu_version_compare(\"1.2.3.1\", \"1.2.4\", FWUPD_VERSION_FORMAT_UNKNOWN), <, 0);\n\n\t/* mixed-alpha-numeric */\n\tg_assert_cmpint(fu_version_compare(\"1.2.3a\", \"1.2.3a\", FWUPD_VERSION_FORMAT_UNKNOWN),\n\t\t\t==,\n\t\t\t0);\n\tg_assert_cmpint(fu_version_compare(\"1.2.3a\", \"1.2.3b\", FWUPD_VERSION_FORMAT_UNKNOWN), <, 0);\n\tg_assert_cmpint(fu_version_compare(\"1.2.3b\", \"1.2.3a\", FWUPD_VERSION_FORMAT_UNKNOWN), >, 0);\n\n\t/* alpha version append */\n\tg_assert_cmpint(fu_version_compare(\"1.2.3\", \"1.2.3a\", FWUPD_VERSION_FORMAT_UNKNOWN), <, 0);\n\tg_assert_cmpint(fu_version_compare(\"1.2.3a\", \"1.2.3\", FWUPD_VERSION_FORMAT_UNKNOWN), >, 0);\n\n\t/* alpha only */\n\tg_assert_cmpint(fu_version_compare(\"alpha\", \"alpha\", FWUPD_VERSION_FORMAT_UNKNOWN), ==, 0);\n\tg_assert_cmpint(fu_version_compare(\"alpha\", \"beta\", FWUPD_VERSION_FORMAT_UNKNOWN), <, 0);\n\tg_assert_cmpint(fu_version_compare(\"beta\", \"alpha\", FWUPD_VERSION_FORMAT_UNKNOWN), >, 0);\n\n\t/* alpha-compare */\n\tg_assert_cmpint(fu_version_compare(\"1.2a.3\", \"1.2a.3\", FWUPD_VERSION_FORMAT_UNKNOWN),\n\t\t\t==,\n\t\t\t0);\n\tg_assert_cmpint(fu_version_compare(\"1.2a.3\", \"1.2b.3\", FWUPD_VERSION_FORMAT_UNKNOWN), <, 0);\n\tg_assert_cmpint(fu_version_compare(\"1.2b.3\", \"1.2a.3\", FWUPD_VERSION_FORMAT_UNKNOWN), >, 0);\n\n\t/* tilde is all-powerful */\n\tg_assert_cmpint(fu_version_compare(\"1.2.3~rc1\", \"1.2.3~rc1\", FWUPD_VERSION_FORMAT_UNKNOWN),\n\t\t\t==,\n\t\t\t0);\n\tg_assert_cmpint(fu_version_compare(\"1.2.3~rc1\", \"1.2.3\", FWUPD_VERSION_FORMAT_UNKNOWN),\n\t\t\t<,\n\t\t\t0);\n\tg_assert_cmpint(fu_version_compare(\"1.2.3\", \"1.2.3~rc1\", FWUPD_VERSION_FORMAT_UNKNOWN),\n\t\t\t>,\n\t\t\t0);\n\tg_assert_cmpint(fu_version_compare(\"1.2.3~rc2\", \"1.2.3~rc1\", FWUPD_VERSION_FORMAT_UNKNOWN),\n\t\t\t>,\n\t\t\t0);\n\n\t/* invalid */\n\tg_assert_cmpint(fu_version_compare(\"1\", NULL, FWUPD_VERSION_FORMAT_UNKNOWN), ==, G_MAXINT);\n\tg_assert_cmpint(fu_version_compare(NULL, \"1\", FWUPD_VERSION_FORMAT_UNKNOWN), ==, G_MAXINT);\n\tg_assert_cmpint(fu_version_compare(NULL, NULL, FWUPD_VERSION_FORMAT_UNKNOWN), ==, G_MAXINT);\n}\n\nstatic void\nfu_firmware_raw_aligned_func(void)\n{\n\tgboolean ret;\n\tg_autoptr(FuFirmware) firmware1 = fu_firmware_new();\n\tg_autoptr(FuFirmware) firmware2 = fu_firmware_new();\n\tg_autoptr(GError) error = NULL;\n\tg_autoptr(GBytes) blob = g_bytes_new_static(\"hello\", 5);\n\n\t/* no alignment */\n\tret = fu_firmware_parse(firmware1, blob, FWUPD_INSTALL_FLAG_NO_SEARCH, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\n\t/* invalid alignment */\n\tfu_firmware_set_alignment(firmware2, FU_FIRMWARE_ALIGNMENT_4K);\n\tret = fu_firmware_parse(firmware2, blob, FWUPD_INSTALL_FLAG_NO_SEARCH, &error);\n\tg_assert_error(error, FWUPD_ERROR, FWUPD_ERROR_INVALID_FILE);\n\tg_assert_false(ret);\n}\n\nstatic void\nfu_firmware_ihex_func(void)\n{\n\tconst guint8 *data;\n\tgboolean ret;\n\tgsize len;\n\tg_autofree gchar *filename_hex = NULL;\n\tg_autofree gchar *filename_ref = NULL;\n\tg_autofree gchar *str = NULL;\n\tg_autoptr(FuFirmware) firmware = fu_ihex_firmware_new();\n\tg_autoptr(GBytes) data_file = NULL;\n\tg_autoptr(GBytes) data_fw = NULL;\n\tg_autoptr(GBytes) data_hex = NULL;\n\tg_autoptr(GBytes) data_ref = NULL;\n\tg_autoptr(GError) error = NULL;\n\n\t/* load a Intel hex32 file */\n\tfilename_hex = g_test_build_filename(G_TEST_DIST, \"tests\", \"firmware.hex\", NULL);\n\tdata_file = fu_bytes_get_contents(filename_hex, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(data_file);\n\tret = fu_firmware_parse(firmware, data_file, FWUPD_INSTALL_FLAG_NO_SEARCH, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tdata_fw = fu_firmware_get_bytes(firmware, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(data_fw);\n\tg_assert_cmpint(g_bytes_get_size(data_fw), ==, 136);\n\n\t/* did we match the reference file? */\n\tfilename_ref = g_test_build_filename(G_TEST_DIST, \"tests\", \"firmware.bin\", NULL);\n\tdata_ref = fu_bytes_get_contents(filename_ref, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(data_ref);\n\tret = fu_bytes_compare(data_fw, data_ref, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\n\t/* export a ihex file (which will be slightly different due to\n\t * non-continous regions being expanded */\n\tdata_hex = fu_firmware_write(firmware, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(data_hex);\n\tdata = g_bytes_get_data(data_hex, &len);\n\tstr = g_strndup((const gchar *)data, len);\n\tg_assert_cmpstr(str,\n\t\t\t==,\n\t\t\t\":104000003DEF20F000000000FACF01F0FBCF02F0FE\\n\"\n\t\t\t\":10401000E9CF03F0EACF04F0E1CF05F0E2CF06F0FC\\n\"\n\t\t\t\":10402000D9CF07F0DACF08F0F3CF09F0F4CF0AF0D8\\n\"\n\t\t\t\":10403000F6CF0BF0F7CF0CF0F8CF0DF0F5CF0EF078\\n\"\n\t\t\t\":104040000EC0F5FF0DC0F8FF0CC0F7FF0BC0F6FF68\\n\"\n\t\t\t\":104050000AC0F4FF09C0F3FF08C0DAFF07C0D9FFA8\\n\"\n\t\t\t\":1040600006C0E2FF05C0E1FF04C0EAFF03C0E9FFAC\\n\"\n\t\t\t\":1040700002C0FBFF01C0FAFF11003FEF20F000017A\\n\"\n\t\t\t\":0840800042EF20F03DEF20F0BB\\n\"\n\t\t\t\":00000001FF\\n\");\n}\n\nstatic void\nfu_firmware_ihex_signed_func(void)\n{\n\tconst guint8 *data;\n\tgboolean ret;\n\tgsize len;\n\tg_autofree gchar *filename_shex = NULL;\n\tg_autoptr(FuFirmware) firmware = fu_ihex_firmware_new();\n\tg_autoptr(GBytes) data_file = NULL;\n\tg_autoptr(GBytes) data_fw = NULL;\n\tg_autoptr(GBytes) data_sig = NULL;\n\tg_autoptr(GError) error = NULL;\n\n\t/* load a signed Intel hex32 file */\n\tfilename_shex = g_test_build_filename(G_TEST_DIST, \"tests\", \"firmware.shex\", NULL);\n\tdata_file = fu_bytes_get_contents(filename_shex, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(data_file);\n\tret = fu_firmware_parse(firmware, data_file, FWUPD_INSTALL_FLAG_NO_SEARCH, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tdata_fw = fu_firmware_get_bytes(firmware, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(data_fw);\n\tg_assert_cmpint(g_bytes_get_size(data_fw), ==, 136);\n\n\t/* get the signed image */\n\tdata_sig = fu_firmware_get_image_by_id_bytes(firmware, FU_FIRMWARE_ID_SIGNATURE, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(data_sig);\n\tdata = g_bytes_get_data(data_sig, &len);\n\tg_assert_cmpint(len, ==, 8);\n\tg_assert_nonnull(data);\n\tg_assert_cmpint(memcmp(data, \"deadbeef\", 8), ==, 0);\n}\n\nstatic void\nfu_firmware_ihex_offset_func(void)\n{\n\tconst guint8 *data;\n\tgboolean ret;\n\tgsize len;\n\tg_autofree gchar *str = NULL;\n\tg_autoptr(FuFirmware) firmware = fu_ihex_firmware_new();\n\tg_autoptr(FuFirmware) firmware_verify = fu_ihex_firmware_new();\n\tg_autoptr(GBytes) data_bin = NULL;\n\tg_autoptr(GBytes) data_dummy = NULL;\n\tg_autoptr(GBytes) data_verify = NULL;\n\tg_autoptr(GError) error = NULL;\n\n\t/* add a 4 byte image in high memory */\n\tdata_dummy = g_bytes_new_static(\"foo\", 4);\n\tfu_firmware_set_addr(firmware, 0x80000000);\n\tfu_firmware_set_bytes(firmware, data_dummy);\n\tdata_bin = fu_firmware_write(firmware, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(data_bin);\n\tdata = g_bytes_get_data(data_bin, &len);\n\tstr = g_strndup((const gchar *)data, len);\n\tg_assert_cmpstr(str,\n\t\t\t==,\n\t\t\t\":0200000480007A\\n\"\n\t\t\t\":04000000666F6F00B8\\n\"\n\t\t\t\":00000001FF\\n\");\n\n\t/* check we can load it too */\n\tret = fu_firmware_parse(firmware_verify, data_bin, FWUPD_INSTALL_FLAG_NO_SEARCH, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_assert_cmpint(fu_firmware_get_addr(firmware_verify), ==, 0x80000000);\n\tdata_verify = fu_firmware_get_bytes(firmware_verify, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(data_verify);\n\tg_assert_cmpint(g_bytes_get_size(data_verify), ==, 0x4);\n}\n\nstatic void\nfu_firmware_srec_func(void)\n{\n\tgboolean ret;\n\tg_autofree gchar *filename_srec = NULL;\n\tg_autofree gchar *filename_ref = NULL;\n\tg_autoptr(FuFirmware) firmware = fu_srec_firmware_new();\n\tg_autoptr(GBytes) data_ref = NULL;\n\tg_autoptr(GBytes) data_srec = NULL;\n\tg_autoptr(GBytes) data_bin = NULL;\n\tg_autoptr(GError) error = NULL;\n\n\tfilename_srec = g_test_build_filename(G_TEST_DIST, \"tests\", \"firmware.srec\", NULL);\n\tdata_srec = fu_bytes_get_contents(filename_srec, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(data_srec);\n\tret = fu_firmware_parse(firmware, data_srec, FWUPD_INSTALL_FLAG_NO_SEARCH, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tdata_bin = fu_firmware_get_bytes(firmware, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(data_bin);\n\tg_assert_cmpint(g_bytes_get_size(data_bin), ==, 136);\n\n\t/* did we match the reference file? */\n\tfilename_ref = g_test_build_filename(G_TEST_DIST, \"tests\", \"firmware.bin\", NULL);\n\tdata_ref = fu_bytes_get_contents(filename_ref, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(data_ref);\n\tret = fu_bytes_compare(data_bin, data_ref, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n}\n\nstatic void\nfu_firmware_fdt_func(void)\n{\n\tgboolean ret;\n\tguint32 val32 = 0;\n\tguint64 val64 = 0;\n\tg_autofree gchar *filename = NULL;\n\tg_autofree gchar *val = NULL;\n\tg_autofree gchar *str = NULL;\n\tg_autoptr(FuFirmware) firmware = fu_fdt_firmware_new();\n\tg_autoptr(FuFirmware) img1 = NULL;\n\tg_autoptr(FuFdtImage) img2 = NULL;\n\tg_autoptr(GBytes) data = NULL;\n\tg_autoptr(GError) error = NULL;\n\n\tfilename = g_test_build_filename(G_TEST_DIST, \"tests\", \"fdt.bin\", NULL);\n\tdata = fu_bytes_get_contents(filename, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(data);\n\tret = fu_firmware_parse(firmware, data, FWUPD_INSTALL_FLAG_NO_SEARCH, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_assert_cmpint(fu_fdt_firmware_get_cpuid(FU_FDT_FIRMWARE(firmware)), ==, 0x0);\n\tstr = fu_firmware_to_string(firmware);\n\tg_debug(\"%s\", str);\n\n\timg1 = fu_firmware_get_image_by_id(firmware, NULL, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(img1);\n\tret = fu_fdt_image_get_attr_str(FU_FDT_IMAGE(img1), \"key\", &val, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_assert_cmpstr(val, ==, \"hello world\");\n\n\t/* get image, and get the uint32 attr */\n\timg2 = fu_fdt_firmware_get_image_by_path(FU_FDT_FIRMWARE(firmware),\n\t\t\t\t\t\t \"/images/firmware-1\",\n\t\t\t\t\t\t &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(img2);\n\tret = fu_fdt_image_get_attr_u32(FU_FDT_IMAGE(img2), \"key\", &val32, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_assert_cmpint(val32, ==, 0x123);\n\n\t/* wrong type */\n\tret = fu_fdt_image_get_attr_u64(img2, \"key\", &val64, &error);\n\tg_assert_error(error, G_IO_ERROR, G_IO_ERROR_INVALID_DATA);\n\tg_assert_false(ret);\n}\n\nstatic void\nfu_firmware_fit_func(void)\n{\n\tgboolean ret;\n\tg_autofree gchar *filename = NULL;\n\tg_autofree gchar *str = NULL;\n\tg_auto(GStrv) val = NULL;\n\tg_autoptr(FuFdtImage) img1 = NULL;\n\tg_autoptr(FuFirmware) firmware = fu_fit_firmware_new();\n\tg_autoptr(GBytes) data = NULL;\n\tg_autoptr(GError) error = NULL;\n\n\tfilename = g_test_build_filename(G_TEST_DIST, \"tests\", \"fit.bin\", NULL);\n\tdata = fu_bytes_get_contents(filename, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(data);\n\tret = fu_firmware_parse(firmware, data, FWUPD_INSTALL_FLAG_NO_SEARCH, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_assert_cmpint(fu_fit_firmware_get_timestamp(FU_FIT_FIRMWARE(firmware)), ==, 0x629D4ABD);\n\tstr = fu_firmware_to_string(firmware);\n\tg_debug(\"%s\", str);\n\n\timg1 = fu_fdt_firmware_get_image_by_path(FU_FDT_FIRMWARE(firmware),\n\t\t\t\t\t\t \"/configurations/conf-1\",\n\t\t\t\t\t\t &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(img1);\n\tret = fu_fdt_image_get_attr_strlist(FU_FDT_IMAGE(img1),\n\t\t\t\t\t    FU_FIT_FIRMWARE_ATTR_COMPATIBLE,\n\t\t\t\t\t    &val,\n\t\t\t\t\t    &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_assert_nonnull(val);\n\tg_assert_cmpstr(val[0], ==, \"alice\");\n\tg_assert_cmpstr(val[1], ==, \"bob\");\n\tg_assert_cmpstr(val[2], ==, \"clara\");\n\tg_assert_cmpstr(val[3], ==, NULL);\n}\n\nstatic void\nfu_firmware_srec_tokenization_func(void)\n{\n\tFuSrecFirmwareRecord *rcd;\n\tGPtrArray *records;\n\tgboolean ret;\n\tg_autoptr(FuFirmware) firmware = fu_srec_firmware_new();\n\tg_autoptr(GBytes) data_srec = NULL;\n\tg_autoptr(GError) error = NULL;\n\tconst gchar *buf = \"S3060000001400E5\\r\\n\"\n\t\t\t   \"S31000000002281102000000007F0304002C\\r\\n\"\n\t\t\t   \"S306000000145095\\r\\n\"\n\t\t\t   \"S70500000000FA\\r\\n\";\n\tdata_srec = g_bytes_new_static(buf, strlen(buf));\n\tg_assert_no_error(error);\n\tg_assert_nonnull(data_srec);\n\tret = fu_firmware_tokenize(firmware, data_srec, FWUPD_INSTALL_FLAG_NONE, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\n\trecords = fu_srec_firmware_get_records(FU_SREC_FIRMWARE(firmware));\n\tg_assert_nonnull(records);\n\tg_assert_cmpint(records->len, ==, 4);\n\trcd = g_ptr_array_index(records, 2);\n\tg_assert_nonnull(rcd);\n\tg_assert_cmpint(rcd->ln, ==, 0x3);\n\tg_assert_cmpint(rcd->kind, ==, 3);\n\tg_assert_cmpint(rcd->addr, ==, 0x14);\n\tg_assert_cmpint(rcd->buf->len, ==, 0x1);\n\tg_assert_cmpint(rcd->buf->data[0], ==, 0x50);\n}\n\nstatic void\nfu_firmware_build_func(void)\n{\n\tgboolean ret;\n\tg_autofree gchar *str = NULL;\n\tg_autoptr(FuFirmware) firmware = fu_firmware_new();\n\tg_autoptr(FuFirmware) img = NULL;\n\tg_autoptr(GBytes) blob = NULL;\n\tg_autoptr(GBytes) blob2 = NULL;\n\tg_autoptr(GError) error = NULL;\n\tg_autoptr(XbBuilder) builder = xb_builder_new();\n\tg_autoptr(XbBuilderSource) source = xb_builder_source_new();\n\tg_autoptr(XbNode) n = NULL;\n\tg_autoptr(XbSilo) silo = NULL;\n\tconst gchar *buf = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\"\n\t\t\t   \"<firmware>\\n\"\n\t\t\t   \"  <version>1.2.3</version>\\n\"\n\t\t\t   \"  <firmware>\\n\"\n\t\t\t   \"    <version>4.5.6</version>\\n\"\n\t\t\t   \"    <id>header</id>\\n\"\n\t\t\t   \"    <idx>456</idx>\\n\"\n\t\t\t   \"    <addr>0x456</addr>\\n\"\n\t\t\t   \"    <data>aGVsbG8=</data>\\n\"\n\t\t\t   \"  </firmware>\\n\"\n\t\t\t   \"  <firmware>\\n\"\n\t\t\t   \"    <version>7.8.9</version>\\n\"\n\t\t\t   \"    <id>header</id>\\n\"\n\t\t\t   \"    <idx>789</idx>\\n\"\n\t\t\t   \"    <addr>0x789</addr>\\n\"\n\t\t\t   \"  </firmware>\\n\"\n\t\t\t   \"</firmware>\\n\";\n\tblob = g_bytes_new_static(buf, strlen(buf));\n\tg_assert_no_error(error);\n\tg_assert_nonnull(blob);\n\n\t/* parse XML */\n\tret = xb_builder_source_load_bytes(source, blob, XB_BUILDER_SOURCE_FLAG_NONE, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\txb_builder_import_source(builder, source);\n\tsilo = xb_builder_compile(builder, XB_BUILDER_COMPILE_FLAG_NONE, NULL, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(silo);\n\tn = xb_silo_query_first(silo, \"firmware\", &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(n);\n\n\t/* build object */\n\tret = fu_firmware_build(firmware, n, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_assert_cmpstr(fu_firmware_get_version(firmware), ==, \"1.2.3\");\n\n\t/* verify image */\n\timg = fu_firmware_get_image_by_id(firmware, \"header\", &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(img);\n\tg_assert_cmpstr(fu_firmware_get_version(img), ==, \"4.5.6\");\n\tg_assert_cmpint(fu_firmware_get_idx(img), ==, 456);\n\tg_assert_cmpint(fu_firmware_get_addr(img), ==, 0x456);\n\tblob2 = fu_firmware_write(img, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(blob2);\n\tg_assert_cmpint(g_bytes_get_size(blob2), ==, 5);\n\tstr = g_strndup(g_bytes_get_data(blob2, NULL), g_bytes_get_size(blob2));\n\tg_assert_cmpstr(str, ==, \"hello\");\n}\n\nstatic gsize\nfu_firmware_dfuse_image_get_size(FuFirmware *self)\n{\n\tg_autoptr(GPtrArray) chunks = fu_firmware_get_chunks(self, NULL);\n\tgsize length = 0;\n\tfor (guint i = 0; i < chunks->len; i++) {\n\t\tFuChunk *chk = g_ptr_array_index(chunks, i);\n\t\tlength += fu_chunk_get_data_sz(chk);\n\t}\n\treturn length;\n}\n\nstatic gsize\nfu_firmware_dfuse_get_size(FuFirmware *firmware)\n{\n\tgsize length = 0;\n\tg_autoptr(GPtrArray) images = fu_firmware_get_images(firmware);\n\tfor (guint i = 0; i < images->len; i++) {\n\t\tFuFirmware *image = g_ptr_array_index(images, i);\n\t\tlength += fu_firmware_dfuse_image_get_size(image);\n\t}\n\treturn length;\n}\n\nstatic void\nfu_firmware_dfuse_func(void)\n{\n\tgboolean ret;\n\tg_autofree gchar *filename = NULL;\n\tg_autoptr(FuFirmware) firmware = fu_dfuse_firmware_new();\n\tg_autoptr(GBytes) roundtrip_orig = NULL;\n\tg_autoptr(GBytes) roundtrip = NULL;\n\tg_autoptr(GError) error = NULL;\n\n\t/* load a DfuSe firmware */\n\tfilename = g_test_build_filename(G_TEST_DIST, \"tests\", \"firmware.dfuse\", NULL);\n\tg_assert_nonnull(filename);\n\troundtrip_orig = fu_bytes_get_contents(filename, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(roundtrip_orig);\n\tret = fu_firmware_parse(firmware, roundtrip_orig, FWUPD_INSTALL_FLAG_NO_SEARCH, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_assert_cmpint(fu_dfu_firmware_get_vid(FU_DFU_FIRMWARE(firmware)), ==, 0x1234);\n\tg_assert_cmpint(fu_dfu_firmware_get_pid(FU_DFU_FIRMWARE(firmware)), ==, 0x5678);\n\tg_assert_cmpint(fu_dfu_firmware_get_release(FU_DFU_FIRMWARE(firmware)), ==, 0x8642);\n\tg_assert_cmpint(fu_firmware_dfuse_get_size(firmware), ==, 0x21);\n\n\t/* can we roundtrip without losing data */\n\troundtrip = fu_firmware_write(firmware, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(roundtrip);\n\tret = fu_bytes_compare(roundtrip, roundtrip_orig, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n}\n\nstatic void\nfu_firmware_fmap_func(void)\n{\n\tgboolean ret;\n\tg_autofree gchar *filename = NULL;\n\tg_autofree gchar *img_str = NULL;\n\tg_autoptr(FuFirmware) firmware = fu_fmap_firmware_new();\n\tg_autoptr(FuFirmware) img = NULL;\n\tg_autoptr(GBytes) img_blob = NULL;\n\tg_autoptr(GBytes) roundtrip = NULL;\n\tg_autoptr(GBytes) roundtrip_orig = NULL;\n\tg_autoptr(GError) error = NULL;\n\tg_autoptr(GPtrArray) images = NULL;\n\n#ifndef HAVE_MEMMEM\n\tg_test_skip(\"no memmem()\");\n\treturn;\n#endif\n\n\t/* load firmware */\n\tfilename = g_test_build_filename(G_TEST_DIST, \"tests\", \"fmap-offset.bin\", NULL);\n\tg_assert_nonnull(filename);\n\troundtrip_orig = fu_bytes_get_contents(filename, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(roundtrip_orig);\n\tret = fu_firmware_parse(firmware, roundtrip_orig, FWUPD_INSTALL_FLAG_NONE, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\n\t/* check image count */\n\timages = fu_firmware_get_images(firmware);\n\tg_assert_cmpint(images->len, ==, 2);\n\n\t/* get a specific image */\n\timg = fu_firmware_get_image_by_id(firmware, \"FMAP\", &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(img);\n\timg_blob = fu_firmware_get_bytes(img, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(img_blob);\n\tg_assert_cmpint(g_bytes_get_size(img_blob), ==, 0xb);\n\timg_str = g_strndup(g_bytes_get_data(img_blob, NULL), g_bytes_get_size(img_blob));\n\tg_assert_cmpstr(img_str, ==, \"hello world\");\n\n\t/* can we roundtrip without losing data */\n\troundtrip = fu_firmware_write(firmware, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(roundtrip);\n\tret = fu_bytes_compare(roundtrip, roundtrip_orig, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n}\n\nstatic void\nfu_firmware_new_from_gtypes_func(void)\n{\n\tg_autofree gchar *fn = NULL;\n\tg_autoptr(FuFirmware) firmware1 = NULL;\n\tg_autoptr(FuFirmware) firmware2 = NULL;\n\tg_autoptr(FuFirmware) firmware3 = NULL;\n\tg_autoptr(GBytes) blob = NULL;\n\tg_autoptr(GError) error = NULL;\n\n\tfn = g_test_build_filename(G_TEST_DIST, \"tests\", \"firmware.dfu\", NULL);\n\tblob = fu_bytes_get_contents(fn, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(blob);\n\n\t/* dfu -> FuDfuFirmware */\n\tfirmware1 = fu_firmware_new_from_gtypes(blob,\n\t\t\t\t\t\tFWUPD_INSTALL_FLAG_NONE,\n\t\t\t\t\t\t&error,\n\t\t\t\t\t\tFU_TYPE_SREC_FIRMWARE,\n\t\t\t\t\t\tFU_TYPE_DFUSE_FIRMWARE,\n\t\t\t\t\t\tFU_TYPE_DFU_FIRMWARE,\n\t\t\t\t\t\tG_TYPE_INVALID);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(firmware1);\n\tg_assert_cmpstr(G_OBJECT_TYPE_NAME(firmware1), ==, \"FuDfuFirmware\");\n\n\t/* dfu -> FuFirmware */\n\tfirmware2 = fu_firmware_new_from_gtypes(blob,\n\t\t\t\t\t\tFWUPD_INSTALL_FLAG_NONE,\n\t\t\t\t\t\t&error,\n\t\t\t\t\t\tFU_TYPE_SREC_FIRMWARE,\n\t\t\t\t\t\tFU_TYPE_FIRMWARE,\n\t\t\t\t\t\tG_TYPE_INVALID);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(firmware2);\n\tg_assert_cmpstr(G_OBJECT_TYPE_NAME(firmware2), ==, \"FuFirmware\");\n\n\t/* dfu -> error */\n\tfirmware3 = fu_firmware_new_from_gtypes(blob,\n\t\t\t\t\t\tFWUPD_INSTALL_FLAG_NONE,\n\t\t\t\t\t\t&error,\n\t\t\t\t\t\tFU_TYPE_SREC_FIRMWARE,\n\t\t\t\t\t\tG_TYPE_INVALID);\n\tg_assert_error(error, FWUPD_ERROR, FWUPD_ERROR_INVALID_FILE);\n\tg_assert_null(firmware3);\n}\n\nstatic void\nfu_firmware_linear_func(void)\n{\n\tgboolean ret;\n\tg_autoptr(FuFirmware) firmware1 = fu_linear_firmware_new(FU_TYPE_OPROM_FIRMWARE);\n\tg_autoptr(FuFirmware) firmware2 = fu_linear_firmware_new(FU_TYPE_OPROM_FIRMWARE);\n\tg_autoptr(GBytes) blob1 = g_bytes_new_static(\"XXXX\", 4);\n\tg_autoptr(GBytes) blob2 = g_bytes_new_static(\"HELO\", 4);\n\tg_autoptr(GBytes) blob3 = NULL;\n\tg_autoptr(FuFirmware) img1 = fu_oprom_firmware_new();\n\tg_autoptr(FuFirmware) img2 = fu_oprom_firmware_new();\n\tg_autoptr(GError) error = NULL;\n\tg_autoptr(GPtrArray) imgs = NULL;\n\tg_autofree gchar *str = NULL;\n\n\t/* add images then parse */\n\tfu_firmware_set_bytes(img1, blob1);\n\tfu_firmware_add_image(firmware1, img1);\n\tfu_firmware_set_bytes(img2, blob2);\n\tfu_firmware_add_image(firmware1, img2);\n\tblob3 = fu_firmware_write(firmware1, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(blob3);\n\tg_assert_cmpint(g_bytes_get_size(blob3), ==, 1024);\n\n\t/* parse them back */\n\tret = fu_firmware_parse(firmware2, blob3, FWUPD_INSTALL_FLAG_NO_SEARCH, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tstr = fu_firmware_to_string(firmware2);\n\tg_debug(\"\\n%s\", str);\n\n\t/* verify we got both images */\n\timgs = fu_firmware_get_images(firmware2);\n\tg_assert_cmpint(imgs->len, ==, 2);\n}\n\nstatic void\nfu_firmware_dfu_func(void)\n{\n\tgboolean ret;\n\tg_autofree gchar *filename_dfu = NULL;\n\tg_autofree gchar *filename_ref = NULL;\n\tg_autoptr(FuFirmware) firmware = fu_dfu_firmware_new();\n\tg_autoptr(GBytes) data_ref = NULL;\n\tg_autoptr(GBytes) data_dfu = NULL;\n\tg_autoptr(GBytes) data_bin = NULL;\n\tg_autoptr(GError) error = NULL;\n\n\tfilename_dfu = g_test_build_filename(G_TEST_DIST, \"tests\", \"firmware.dfu\", NULL);\n\tdata_dfu = fu_bytes_get_contents(filename_dfu, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(data_dfu);\n\tret = fu_firmware_parse(firmware, data_dfu, FWUPD_INSTALL_FLAG_NO_SEARCH, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_assert_cmpint(fu_dfu_firmware_get_vid(FU_DFU_FIRMWARE(firmware)), ==, 0x1234);\n\tg_assert_cmpint(fu_dfu_firmware_get_pid(FU_DFU_FIRMWARE(firmware)), ==, 0x4321);\n\tg_assert_cmpint(fu_dfu_firmware_get_release(FU_DFU_FIRMWARE(firmware)), ==, 0xdead);\n\tdata_bin = fu_firmware_get_bytes(firmware, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(data_bin);\n\tg_assert_cmpint(g_bytes_get_size(data_bin), ==, 136);\n\n\t/* did we match the reference file? */\n\tfilename_ref = g_test_build_filename(G_TEST_DIST, \"tests\", \"firmware.bin\", NULL);\n\tdata_ref = fu_bytes_get_contents(filename_ref, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(data_ref);\n\tret = fu_bytes_compare(data_bin, data_ref, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n}\n\nstatic void\nfu_firmware_ifwi_cpd_func(void)\n{\n\tgboolean ret;\n\tg_autofree gchar *filename_ifwi_cpd = NULL;\n\tg_autoptr(FuFirmware) firmware = fu_ifwi_cpd_firmware_new();\n\tg_autoptr(FuFirmware) img1 = NULL;\n\tg_autoptr(FuFirmware) img2 = NULL;\n\tg_autoptr(GBytes) data_bin = NULL;\n\tg_autoptr(GBytes) data_ifwi_cpd = NULL;\n\tg_autoptr(GError) error = NULL;\n\n\tfilename_ifwi_cpd = g_test_build_filename(G_TEST_DIST, \"tests\", \"ifwi-cpd.bin\", NULL);\n\tdata_ifwi_cpd = fu_bytes_get_contents(filename_ifwi_cpd, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(data_ifwi_cpd);\n\tret = fu_firmware_parse(firmware, data_ifwi_cpd, FWUPD_INSTALL_FLAG_NO_SEARCH, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_assert_cmpint(fu_firmware_get_idx(firmware), ==, 0x1234);\n\tdata_bin = fu_firmware_write(firmware, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(data_bin);\n\tg_assert_cmpint(g_bytes_get_size(data_bin), ==, 90);\n\n\timg1 = fu_firmware_get_image_by_id(firmware, \"one\", &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(img1);\n\tg_assert_cmpint(fu_firmware_get_offset(img1), ==, 68);\n\tg_assert_cmpint(fu_firmware_get_size(img1), ==, 11);\n\n\timg2 = fu_firmware_get_image_by_id(firmware, \"two\", &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(img2);\n\tg_assert_cmpint(fu_firmware_get_offset(img2), ==, 79);\n\tg_assert_cmpint(fu_firmware_get_size(img2), ==, 11);\n}\n\nstatic void\nfu_firmware_ifwi_fpt_func(void)\n{\n\tgboolean ret;\n\tg_autofree gchar *filename_ifwi_fpt = NULL;\n\tg_autoptr(FuFirmware) firmware = fu_ifwi_fpt_firmware_new();\n\tg_autoptr(FuFirmware) img1 = NULL;\n\tg_autoptr(FuFirmware) img2 = NULL;\n\tg_autoptr(GBytes) data_bin = NULL;\n\tg_autoptr(GBytes) data_ifwi_fpt = NULL;\n\tg_autoptr(GError) error = NULL;\n\n\tfilename_ifwi_fpt = g_test_build_filename(G_TEST_DIST, \"tests\", \"ifwi-fpt.bin\", NULL);\n\tdata_ifwi_fpt = fu_bytes_get_contents(filename_ifwi_fpt, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(data_ifwi_fpt);\n\tret = fu_firmware_parse(firmware, data_ifwi_fpt, FWUPD_INSTALL_FLAG_NO_SEARCH, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tdata_bin = fu_firmware_write(firmware, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(data_bin);\n\tg_assert_cmpint(g_bytes_get_size(data_bin), ==, 118);\n\n\timg1 = fu_firmware_get_image_by_idx(firmware, 0x4f464e49, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(img1);\n\tg_assert_cmpint(fu_firmware_get_offset(img1), ==, 96);\n\tg_assert_cmpint(fu_firmware_get_size(img1), ==, 11);\n\n\timg2 = fu_firmware_get_image_by_idx(firmware, 0x4d495746, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(img2);\n\tg_assert_cmpint(fu_firmware_get_offset(img2), ==, 107);\n\tg_assert_cmpint(fu_firmware_get_size(img2), ==, 11);\n}\n\nstatic void\nfu_firmware_oprom_func(void)\n{\n\tgboolean ret;\n\tg_autofree gchar *filename_oprom = NULL;\n\tg_autoptr(FuFirmware) firmware = fu_oprom_firmware_new();\n\tg_autoptr(FuFirmware) img1 = NULL;\n\tg_autoptr(GBytes) data_bin = NULL;\n\tg_autoptr(GBytes) data_oprom = NULL;\n\tg_autoptr(GError) error = NULL;\n\n\tfilename_oprom = g_test_build_filename(G_TEST_DIST, \"tests\", \"oprom.bin\", NULL);\n\tdata_oprom = fu_bytes_get_contents(filename_oprom, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(data_oprom);\n\tret = fu_firmware_parse(firmware, data_oprom, FWUPD_INSTALL_FLAG_NO_SEARCH, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_assert_cmpint(fu_firmware_get_idx(firmware), ==, 0x1);\n\tdata_bin = fu_firmware_write(firmware, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(data_bin);\n\tg_assert_cmpint(g_bytes_get_size(data_bin), ==, 1024);\n\n\timg1 = fu_firmware_get_image_by_id(firmware, \"cpd\", &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(img1);\n\tg_assert_cmpint(fu_firmware_get_offset(img1), ==, 512);\n\tg_assert_cmpint(fu_firmware_get_size(img1), ==, 512);\n}\n\nstatic void\nfu_firmware_dfu_patch_func(void)\n{\n\tgboolean ret;\n\tg_autofree gchar *csum = NULL;\n\tg_autofree gchar *filename_dfu = NULL;\n\tg_autoptr(FuFirmware) firmware = fu_dfu_firmware_new();\n\tg_autoptr(GBytes) data_dfu = NULL;\n\tg_autoptr(GBytes) data_new = NULL;\n\tg_autoptr(GBytes) data_patch0 = g_bytes_new_static(\"XXXX\", 4);\n\tg_autoptr(GBytes) data_patch1 = g_bytes_new_static(\"HELO\", 4);\n\tg_autoptr(GError) error = NULL;\n\n\tfilename_dfu = g_test_build_filename(G_TEST_DIST, \"tests\", \"firmware.dfu\", NULL);\n\tdata_dfu = fu_bytes_get_contents(filename_dfu, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(data_dfu);\n\tret = fu_firmware_parse(firmware, data_dfu, FWUPD_INSTALL_FLAG_NO_SEARCH, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\n\t/* add a couple of patches */\n\tfu_firmware_add_patch(firmware, 0x0, data_patch0);\n\tfu_firmware_add_patch(firmware, 0x0, data_patch1);\n\tfu_firmware_add_patch(firmware, 136 - 4, data_patch1);\n\n\tdata_new = fu_firmware_write(firmware, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(data_new);\n\tfu_dump_full(G_LOG_DOMAIN,\n\t\t     \"patch\",\n\t\t     g_bytes_get_data(data_new, NULL),\n\t\t     g_bytes_get_size(data_new),\n\t\t     20,\n\t\t     FU_DUMP_FLAGS_SHOW_ASCII | FU_DUMP_FLAGS_SHOW_ADDRESSES);\n\tcsum = g_compute_checksum_for_bytes(G_CHECKSUM_SHA1, data_new);\n\tg_assert_cmpstr(csum, ==, \"0722727426092ac564861d1a11697182017be83f\");\n}\n\nstatic void\nfu_firmware_func(void)\n{\n\tgboolean ret;\n\tg_autoptr(FuFirmware) firmware = fu_firmware_new();\n\tg_autoptr(FuFirmware) img1 = fu_firmware_new();\n\tg_autoptr(FuFirmware) img2 = fu_firmware_new();\n\tg_autoptr(FuFirmware) img_id = NULL;\n\tg_autoptr(FuFirmware) img_idx = NULL;\n\tg_autoptr(GError) error = NULL;\n\tg_autoptr(GPtrArray) images = NULL;\n\tg_autofree gchar *str = NULL;\n\n\tfu_firmware_set_addr(img1, 0x200);\n\tfu_firmware_set_idx(img1, 13);\n\tfu_firmware_set_id(img1, \"primary\");\n\tfu_firmware_set_filename(img1, \"BIOS.bin\");\n\tfu_firmware_add_image(firmware, img1);\n\tfu_firmware_set_addr(img2, 0x400);\n\tfu_firmware_set_idx(img2, 23);\n\tfu_firmware_set_id(img2, \"secondary\");\n\tfu_firmware_add_image(firmware, img2);\n\n\timg_id = fu_firmware_get_image_by_id(firmware, \"NotGoingToExist\", &error);\n\tg_assert_error(error, FWUPD_ERROR, FWUPD_ERROR_NOT_FOUND);\n\tg_assert_null(img_id);\n\tg_clear_error(&error);\n\timg_id = fu_firmware_get_image_by_id(firmware, \"primary\", &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(img_id);\n\tg_assert_cmpint(fu_firmware_get_addr(img_id), ==, 0x200);\n\tg_assert_cmpint(fu_firmware_get_idx(img_id), ==, 13);\n\tg_assert_cmpstr(fu_firmware_get_id(img_id), ==, \"primary\");\n\n\timg_idx = fu_firmware_get_image_by_idx(firmware, 123456, &error);\n\tg_assert_error(error, FWUPD_ERROR, FWUPD_ERROR_NOT_FOUND);\n\tg_assert_null(img_idx);\n\tg_clear_error(&error);\n\timg_idx = fu_firmware_get_image_by_idx(firmware, 23, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(img_idx);\n\tg_assert_cmpint(fu_firmware_get_addr(img_idx), ==, 0x400);\n\tg_assert_cmpint(fu_firmware_get_idx(img_idx), ==, 23);\n\tg_assert_cmpstr(fu_firmware_get_id(img_idx), ==, \"secondary\");\n\n\tstr = fu_firmware_to_string(firmware);\n\tg_assert_cmpstr(str,\n\t\t\t==,\n\t\t\t\"<firmware>\\n\"\n\t\t\t\"  <firmware>\\n\"\n\t\t\t\"    <id>primary</id>\\n\"\n\t\t\t\"    <idx>0xd</idx>\\n\"\n\t\t\t\"    <addr>0x200</addr>\\n\"\n\t\t\t\"    <filename>BIOS.bin</filename>\\n\"\n\t\t\t\"  </firmware>\\n\"\n\t\t\t\"  <firmware>\\n\"\n\t\t\t\"    <id>secondary</id>\\n\"\n\t\t\t\"    <idx>0x17</idx>\\n\"\n\t\t\t\"    <addr>0x400</addr>\\n\"\n\t\t\t\"  </firmware>\\n\"\n\t\t\t\"</firmware>\\n\");\n\n\tret = fu_firmware_remove_image_by_idx(firmware, 0xd, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tret = fu_firmware_remove_image_by_id(firmware, \"secondary\", &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\timages = fu_firmware_get_images(firmware);\n\tg_assert_nonnull(images);\n\tg_assert_cmpint(images->len, ==, 0);\n\tret = fu_firmware_remove_image_by_id(firmware, \"NOTGOINGTOEXIST\", &error);\n\tg_assert_error(error, FWUPD_ERROR, FWUPD_ERROR_NOT_FOUND);\n\tg_assert_false(ret);\n}\n\nstatic void\nfu_firmware_common_func(void)\n{\n\tgboolean ret;\n\tguint8 value = 0;\n\tg_autoptr(GError) error = NULL;\n\n\tret = fu_firmware_strparse_uint8_safe(\"ff00XX\", 6, 0, &value, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_assert_cmpint(value, ==, 0xFF);\n\n\tret = fu_firmware_strparse_uint8_safe(\"ff00XX\", 6, 2, &value, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_assert_cmpint(value, ==, 0x00);\n\n\tret = fu_firmware_strparse_uint8_safe(\"ff00XX\", 6, 4, &value, &error);\n\tg_assert_error(error, G_IO_ERROR, G_IO_ERROR_INVALID_DATA);\n\tg_assert_false(ret);\n}\n\nstatic void\nfu_firmware_dedupe_func(void)\n{\n\tg_autoptr(FuFirmware) firmware = fu_firmware_new();\n\tg_autoptr(FuFirmware) img1 = fu_firmware_new();\n\tg_autoptr(FuFirmware) img1_old = fu_firmware_new();\n\tg_autoptr(FuFirmware) img2 = fu_firmware_new();\n\tg_autoptr(FuFirmware) img2_old = fu_firmware_new();\n\tg_autoptr(FuFirmware) img_id = NULL;\n\tg_autoptr(FuFirmware) img_idx = NULL;\n\tg_autoptr(GError) error = NULL;\n\n\tfu_firmware_add_flag(firmware, FU_FIRMWARE_FLAG_DEDUPE_ID);\n\tfu_firmware_add_flag(firmware, FU_FIRMWARE_FLAG_DEDUPE_IDX);\n\n\tfu_firmware_set_idx(img1_old, 13);\n\tfu_firmware_set_id(img1_old, \"DAVE\");\n\tfu_firmware_add_image(firmware, img1_old);\n\tg_assert_true(fu_firmware_get_parent(img1_old) == firmware);\n\n\tfu_firmware_set_idx(img1, 13);\n\tfu_firmware_set_id(img1, \"primary\");\n\tfu_firmware_add_image(firmware, img1);\n\n\tfu_firmware_set_idx(img2_old, 123456);\n\tfu_firmware_set_id(img2_old, \"secondary\");\n\tfu_firmware_add_image(firmware, img2_old);\n\n\tfu_firmware_set_idx(img2, 23);\n\tfu_firmware_set_id(img2, \"secondary\");\n\tfu_firmware_add_image(firmware, img2);\n\n\timg_id = fu_firmware_get_image_by_id(firmware, \"primary\", &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(img_id);\n\tg_assert_cmpint(fu_firmware_get_idx(img_id), ==, 13);\n\tg_assert_cmpstr(fu_firmware_get_id(img_id), ==, \"primary\");\n\n\timg_idx = fu_firmware_get_image_by_idx(firmware, 23, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(img_idx);\n\tg_assert_cmpint(fu_firmware_get_idx(img_idx), ==, 23);\n\tg_assert_cmpstr(fu_firmware_get_id(img_idx), ==, \"secondary\");\n}\n\nstatic void\nfu_efivar_func(void)\n{\n\tgboolean ret;\n\tgsize sz = 0;\n\tguint32 attr = 0;\n\tguint64 total;\n\tg_autofree gchar *sysfsfwdir = NULL;\n\tg_autofree guint8 *data = NULL;\n\tg_autoptr(GError) error = NULL;\n\tg_autoptr(GPtrArray) names = NULL;\n\n#ifndef __linux__\n\tg_test_skip(\"only works on Linux\");\n\treturn;\n#endif\n\n\t/* these tests will write */\n\tsysfsfwdir = g_test_build_filename(G_TEST_BUILT, \"tests\", NULL);\n\t(void)g_setenv(\"FWUPD_SYSFSFWDIR\", sysfsfwdir, TRUE);\n\n\t/* check supported */\n\tret = fu_efivar_supported(&error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\n\t/* check we can get the space used */\n\ttotal = fu_efivar_space_used(&error);\n\tg_assert_no_error(error);\n\tg_assert_cmpint(total, >=, 0x2000);\n\n\t/* check existing keys */\n\tg_assert_false(fu_efivar_exists(FU_EFIVAR_GUID_EFI_GLOBAL, \"NotGoingToExist\"));\n\tg_assert_true(fu_efivar_exists(FU_EFIVAR_GUID_EFI_GLOBAL, \"SecureBoot\"));\n\n\t/* list a few keys */\n\tnames = fu_efivar_get_names(FU_EFIVAR_GUID_EFI_GLOBAL, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(names);\n\tg_assert_cmpint(names->len, ==, 2);\n\n\t/* write and read a key */\n\tret = fu_efivar_set_data(FU_EFIVAR_GUID_EFI_GLOBAL,\n\t\t\t\t \"Test\",\n\t\t\t\t (guint8 *)\"1\",\n\t\t\t\t 1,\n\t\t\t\t FU_EFIVAR_ATTR_NON_VOLATILE | FU_EFIVAR_ATTR_RUNTIME_ACCESS,\n\t\t\t\t &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tret = fu_efivar_get_data(FU_EFIVAR_GUID_EFI_GLOBAL, \"Test\", &data, &sz, &attr, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_assert_cmpint(sz, ==, 1);\n\tg_assert_cmpint(attr, ==, FU_EFIVAR_ATTR_NON_VOLATILE | FU_EFIVAR_ATTR_RUNTIME_ACCESS);\n\tg_assert_cmpint(data[0], ==, '1');\n\n\t/* delete single key */\n\tret = fu_efivar_delete(FU_EFIVAR_GUID_EFI_GLOBAL, \"Test\", &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_assert_false(fu_efivar_exists(FU_EFIVAR_GUID_EFI_GLOBAL, \"Test\"));\n\n\t/* delete multiple keys */\n\tret = fu_efivar_set_data(FU_EFIVAR_GUID_EFI_GLOBAL, \"Test1\", (guint8 *)\"1\", 1, 0, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tret = fu_efivar_set_data(FU_EFIVAR_GUID_EFI_GLOBAL, \"Test2\", (guint8 *)\"1\", 1, 0, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tret = fu_efivar_delete_with_glob(FU_EFIVAR_GUID_EFI_GLOBAL, \"Test*\", &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_assert_false(fu_efivar_exists(FU_EFIVAR_GUID_EFI_GLOBAL, \"Test1\"));\n\tg_assert_false(fu_efivar_exists(FU_EFIVAR_GUID_EFI_GLOBAL, \"Test2\"));\n\n\t/* read a key that doesn't exist */\n\tret = fu_efivar_get_data(FU_EFIVAR_GUID_EFI_GLOBAL,\n\t\t\t\t \"NotGoingToExist\",\n\t\t\t\t NULL,\n\t\t\t\t NULL,\n\t\t\t\t NULL,\n\t\t\t\t &error);\n\tg_assert_error(error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND);\n\tg_assert_false(ret);\n}\n\ntypedef struct {\n\tguint cnt_success;\n\tguint cnt_failed;\n} FuDeviceRetryHelper;\n\nstatic gboolean\nfu_device_retry_success(FuDevice *device, gpointer user_data, GError **error)\n{\n\tFuDeviceRetryHelper *helper = (FuDeviceRetryHelper *)user_data;\n\thelper->cnt_success++;\n\treturn TRUE;\n}\n\nstatic gboolean\nfu_device_retry_failed(FuDevice *device, gpointer user_data, GError **error)\n{\n\tFuDeviceRetryHelper *helper = (FuDeviceRetryHelper *)user_data;\n\thelper->cnt_failed++;\n\tg_set_error_literal(error, FWUPD_ERROR, FWUPD_ERROR_INTERNAL, \"failed\");\n\treturn FALSE;\n}\n\nstatic gboolean\nfu_device_retry_success_3rd_try(FuDevice *device, gpointer user_data, GError **error)\n{\n\tFuDeviceRetryHelper *helper = (FuDeviceRetryHelper *)user_data;\n\tif (helper->cnt_failed == 2) {\n\t\thelper->cnt_success++;\n\t\treturn TRUE;\n\t}\n\thelper->cnt_failed++;\n\tg_set_error_literal(error, FWUPD_ERROR, FWUPD_ERROR_INTERNAL, \"failed\");\n\treturn FALSE;\n}\n\nstatic void\nfu_device_retry_success_func(void)\n{\n\tgboolean ret;\n\tg_autoptr(FuDevice) device = fu_device_new(NULL);\n\tg_autoptr(GError) error = NULL;\n\tFuDeviceRetryHelper helper = {\n\t    .cnt_success = 0,\n\t    .cnt_failed = 0,\n\t};\n\tfu_device_retry_add_recovery(device,\n\t\t\t\t     FWUPD_ERROR,\n\t\t\t\t     FWUPD_ERROR_INTERNAL,\n\t\t\t\t     fu_device_retry_failed);\n\tret = fu_device_retry(device, fu_device_retry_success, 3, &helper, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_assert_cmpint(helper.cnt_success, ==, 1);\n\tg_assert_cmpint(helper.cnt_failed, ==, 0);\n}\n\nstatic void\nfu_device_retry_failed_func(void)\n{\n\tgboolean ret;\n\tg_autoptr(FuDevice) device = fu_device_new(NULL);\n\tg_autoptr(GError) error = NULL;\n\tFuDeviceRetryHelper helper = {\n\t    .cnt_success = 0,\n\t    .cnt_failed = 0,\n\t};\n\tfu_device_retry_add_recovery(device,\n\t\t\t\t     FWUPD_ERROR,\n\t\t\t\t     FWUPD_ERROR_INTERNAL,\n\t\t\t\t     fu_device_retry_success);\n\tret = fu_device_retry(device, fu_device_retry_failed, 3, &helper, &error);\n\tg_assert_error(error, FWUPD_ERROR, FWUPD_ERROR_INTERNAL);\n\tg_assert_true(!ret);\n\tg_assert_cmpint(helper.cnt_success, ==, 2); /* do not reset for the last failure */\n\tg_assert_cmpint(helper.cnt_failed, ==, 3);\n}\n\nstatic void\nfu_device_retry_hardware_func(void)\n{\n\tgboolean ret;\n\tg_autoptr(FuDevice) device = fu_device_new(NULL);\n\tg_autoptr(GError) error = NULL;\n\tFuDeviceRetryHelper helper = {\n\t    .cnt_success = 0,\n\t    .cnt_failed = 0,\n\t};\n\tret = fu_device_retry(device, fu_device_retry_success_3rd_try, 3, &helper, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_assert_cmpint(helper.cnt_success, ==, 1);\n\tg_assert_cmpint(helper.cnt_failed, ==, 2);\n}\n\nstatic void\nfu_bios_settings_load_func(void)\n{\n\tgboolean ret;\n\tgint integer;\n\tconst gchar *tmp;\n\tGPtrArray *values;\n\tFwupdBiosSetting *setting;\n\tFwupdBiosSettingKind kind;\n\tg_autofree gchar *test_dir = NULL;\n\tg_autoptr(FuContext) ctx = fu_context_new();\n\tg_autoptr(GError) error = NULL;\n\tg_autoptr(FuBiosSettings) p620_settings = NULL;\n\tg_autoptr(FuBiosSettings) p14s_settings = NULL;\n\tg_autoptr(FuBiosSettings) xp29310_settings = NULL;\n\tg_autoptr(GPtrArray) p14s_items = NULL;\n\tg_autoptr(GPtrArray) p620_items = NULL;\n\tg_autoptr(GPtrArray) xps9310_items = NULL;\n\n\t/* load BIOS settings from a Lenovo P620 (with thinklmi driver problems) */\n\ttest_dir = g_test_build_filename(G_TEST_DIST, \"tests\", \"bios-attrs\", \"lenovo-p620\", NULL);\n\t(void)g_setenv(\"FWUPD_SYSFSFWATTRIBDIR\", test_dir, TRUE);\n\n\tg_test_expect_message(\"FuBiosSettings\", G_LOG_LEVEL_WARNING, \"*BUG*\");\n\tret = fu_context_reload_bios_settings(ctx, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_test_assert_expected_messages();\n\n\tp620_settings = fu_context_get_bios_settings(ctx);\n\tp620_items = fu_bios_settings_get_all(p620_settings);\n\tg_assert_cmpint(p620_items->len, ==, 128);\n\n\t/* make sure nothing pending */\n\tret = fu_context_get_bios_setting_pending_reboot(ctx);\n\tg_assert_false(ret);\n\n\t/* check a BIOS setting reads from kernel as expected by fwupd today */\n\tsetting = fu_context_get_bios_setting(ctx, \"com.thinklmi.AMDMemoryGuard\");\n\tg_assert_nonnull(setting);\n\ttmp = fwupd_bios_setting_get_name(setting);\n\tg_assert_cmpstr(tmp, ==, \"AMDMemoryGuard\");\n\ttmp = fwupd_bios_setting_get_description(setting);\n\tg_assert_cmpstr(tmp, ==, \"AMDMemoryGuard\");\n\ttmp = fwupd_bios_setting_get_current_value(setting);\n\tg_assert_cmpstr(tmp, ==, \"Disable\");\n\tvalues = fwupd_bios_setting_get_possible_values(setting);\n\tfor (guint i = 0; i < values->len; i++) {\n\t\tconst gchar *possible = g_ptr_array_index(values, i);\n\t\tif (i == 0)\n\t\t\tg_assert_cmpstr(possible, ==, \"Disable\");\n\t\tif (i == 1)\n\t\t\tg_assert_cmpstr(possible, ==, \"Enable\");\n\t}\n\n\t/* try to read an BIOS setting known to have ][Status] to make sure we worked\n\t * around the thinklmi bug sufficiently\n\t */\n\tsetting = fu_context_get_bios_setting(ctx, \"com.thinklmi.StartupSequence\");\n\tg_assert_nonnull(setting);\n\ttmp = fwupd_bios_setting_get_current_value(setting);\n\tg_assert_cmpstr(tmp, ==, \"Primary\");\n\tvalues = fwupd_bios_setting_get_possible_values(setting);\n\tfor (guint i = 0; i < values->len; i++) {\n\t\tconst gchar *possible = g_ptr_array_index(values, i);\n\t\tif (i == 0)\n\t\t\tg_assert_cmpstr(possible, ==, \"Primary\");\n\t\tif (i == 1)\n\t\t\tg_assert_cmpstr(possible, ==, \"Automatic\");\n\t}\n\n\t/* check no BIOS settings have [Status in them */\n\tfor (guint i = 0; i < p620_items->len; i++) {\n\t\tsetting = g_ptr_array_index(p620_items, i);\n\t\ttmp = fwupd_bios_setting_get_current_value(setting);\n\t\tg_debug(\"%s\", tmp);\n\t\tg_assert_null(g_strrstr(tmp, \"[Status\"));\n\t}\n\n\tg_free(test_dir);\n\n\t/* load BIOS settings from a Lenovo P14s Gen1 */\n\ttest_dir =\n\t    g_test_build_filename(G_TEST_DIST, \"tests\", \"bios-attrs\", \"lenovo-p14s-gen1\", NULL);\n\t(void)g_setenv(\"FWUPD_SYSFSFWATTRIBDIR\", test_dir, TRUE);\n\tret = fu_context_reload_bios_settings(ctx, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\n\tp14s_settings = fu_context_get_bios_settings(ctx);\n\tp14s_items = fu_bios_settings_get_all(p14s_settings);\n\tg_assert_cmpint(p14s_items->len, ==, 75);\n\n\t/* reboot should be pending on this one */\n\tret = fu_context_get_bios_setting_pending_reboot(ctx);\n\tg_assert_true(ret);\n\n\t/* look for an enumeration BIOS setting with a space */\n\tsetting = fu_context_get_bios_setting(ctx, \"com.thinklmi.SleepState\");\n\tg_assert_nonnull(setting);\n\ttmp = fwupd_bios_setting_get_name(setting);\n\tg_assert_cmpstr(tmp, ==, \"SleepState\");\n\ttmp = fwupd_bios_setting_get_description(setting);\n\tg_assert_cmpstr(tmp, ==, \"SleepState\");\n\tvalues = fwupd_bios_setting_get_possible_values(setting);\n\tfor (guint i = 0; i < values->len; i++) {\n\t\tconst gchar *possible = g_ptr_array_index(values, i);\n\t\tif (i == 0)\n\t\t\tg_assert_cmpstr(possible, ==, \"Linux\");\n\t\tif (i == 1)\n\t\t\tg_assert_cmpstr(possible, ==, \"Windows 10\");\n\t}\n\n\t/* make sure we defaulted UEFI Secure boot to read only if enabled */\n\tsetting = fu_context_get_bios_setting(ctx, \"com.thinklmi.SecureBoot\");\n\tg_assert_nonnull(setting);\n\tret = fwupd_bios_setting_get_read_only(setting);\n\tg_assert_true(ret);\n\n\tg_free(test_dir);\n\n\t/* load BIOS settings from a Dell XPS 9310 */\n\ttest_dir =\n\t    g_test_build_filename(G_TEST_DIST, \"tests\", \"bios-attrs\", \"dell-xps13-9310\", NULL);\n\t(void)g_setenv(\"FWUPD_SYSFSFWATTRIBDIR\", test_dir, TRUE);\n\tret = fu_context_reload_bios_settings(ctx, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\n\txp29310_settings = fu_context_get_bios_settings(ctx);\n\txps9310_items = fu_bios_settings_get_all(xp29310_settings);\n\tg_assert_cmpint(xps9310_items->len, ==, 109);\n\n\t/* make sure that we DIDN'T parse reset_bios setting */\n\tsetting = fu_context_get_bios_setting(ctx, FWUPD_BIOS_SETTING_RESET_BIOS);\n\tg_assert_null(setting);\n\n\t/* look at a integer BIOS setting */\n\tsetting = fu_context_get_bios_setting(ctx, \"com.dell-wmi-sysman.CustomChargeStop\");\n\tg_assert_nonnull(setting);\n\tkind = fwupd_bios_setting_get_kind(setting);\n\tg_assert_cmpint(kind, ==, FWUPD_BIOS_SETTING_KIND_INTEGER);\n\tinteger = fwupd_bios_setting_get_lower_bound(setting);\n\tg_assert_cmpint(integer, ==, 55);\n\tinteger = fwupd_bios_setting_get_upper_bound(setting);\n\tg_assert_cmpint(integer, ==, 100);\n\tinteger = fwupd_bios_setting_get_scalar_increment(setting);\n\tg_assert_cmpint(integer, ==, 1);\n\n\t/* look at a string BIOS setting */\n\tsetting = fu_context_get_bios_setting(ctx, \"com.dell-wmi-sysman.Asset\");\n\tg_assert_nonnull(setting);\n\tinteger = fwupd_bios_setting_get_lower_bound(setting);\n\tg_assert_cmpint(integer, ==, 1);\n\tinteger = fwupd_bios_setting_get_upper_bound(setting);\n\tg_assert_cmpint(integer, ==, 64);\n\ttmp = fwupd_bios_setting_get_description(setting);\n\tg_assert_cmpstr(tmp, ==, \"Asset Tag\");\n\n\t/* look at a enumeration BIOS setting */\n\tsetting = fu_context_get_bios_setting(ctx, \"com.dell-wmi-sysman.BiosRcvrFrmHdd\");\n\tg_assert_nonnull(setting);\n\tkind = fwupd_bios_setting_get_kind(setting);\n\tg_assert_cmpint(kind, ==, FWUPD_BIOS_SETTING_KIND_ENUMERATION);\n\tvalues = fwupd_bios_setting_get_possible_values(setting);\n\tfor (guint i = 0; i < values->len; i++) {\n\t\tconst gchar *possible = g_ptr_array_index(values, i);\n\t\tif (i == 0)\n\t\t\tg_assert_cmpstr(possible, ==, \"Disabled\");\n\t\tif (i == 1)\n\t\t\tg_assert_cmpstr(possible, ==, \"Enabled\");\n\t}\n\n\t/* make sure we defaulted UEFI Secure boot to read only if enabled */\n\tsetting = fu_context_get_bios_setting(ctx, \"com.dell-wmi-sysman.SecureBoot\");\n\tg_assert_nonnull(setting);\n\tret = fwupd_bios_setting_get_read_only(setting);\n\tg_assert_true(ret);\n}\n\nstatic void\nfu_security_attrs_hsi_func(void)\n{\n\tg_autofree gchar *hsi1 = NULL;\n\tg_autofree gchar *hsi2 = NULL;\n\tg_autofree gchar *hsi3 = NULL;\n\tg_autofree gchar *hsi4 = NULL;\n\tg_autofree gchar *hsi5 = NULL;\n\tg_autofree gchar *hsi6 = NULL;\n\tg_autofree gchar *hsi7 = NULL;\n\tg_autofree gchar *hsi8 = NULL;\n\tg_autofree gchar *hsi9 = NULL;\n\tg_autofree gchar *expected_hsi9 = NULL;\n\tg_autoptr(FuSecurityAttrs) attrs = NULL;\n\tg_autoptr(FwupdSecurityAttr) attr = NULL;\n\n\t/* no attrs */\n\tattrs = fu_security_attrs_new();\n\thsi1 = fu_security_attrs_calculate_hsi(attrs, FU_SECURITY_ATTRS_FLAG_NONE);\n\tg_assert_cmpstr(hsi1, ==, \"HSI:0\");\n\n\t/* just success from HSI:1 */\n\tattr = fwupd_security_attr_new(FWUPD_SECURITY_ATTR_ID_SPI_BIOSWE);\n\tfwupd_security_attr_set_plugin(attr, \"test\");\n\tfwupd_security_attr_set_level(attr, FWUPD_SECURITY_ATTR_LEVEL_CRITICAL);\n\tfwupd_security_attr_add_flag(attr, FWUPD_SECURITY_ATTR_FLAG_SUCCESS);\n\tfwupd_security_attr_set_url(attr, \"http://test\");\n\tfu_security_attrs_append(attrs, attr);\n\thsi2 = fu_security_attrs_calculate_hsi(attrs, FU_SECURITY_ATTRS_FLAG_NONE);\n\tg_assert_cmpstr(hsi2, ==, \"HSI:1\");\n\tg_clear_object(&attr);\n\n\t/* add failed from HSI:2, so still HSI:1 */\n\tattr = fwupd_security_attr_new(\"org.fwupd.hsi.PRX\");\n\tfwupd_security_attr_set_plugin(attr, \"test\");\n\tfwupd_security_attr_set_level(attr, FWUPD_SECURITY_ATTR_LEVEL_IMPORTANT);\n\tfwupd_security_attr_set_url(attr, \"http://test\");\n\tfu_security_attrs_append(attrs, attr);\n\thsi3 = fu_security_attrs_calculate_hsi(attrs, FU_SECURITY_ATTRS_FLAG_NONE);\n\tg_assert_cmpstr(hsi3, ==, \"HSI:1\");\n\tg_clear_object(&attr);\n\n\t/* add an implicit obsolete via duplication */\n\tattr = fwupd_security_attr_new(\"org.fwupd.hsi.PRX\");\n\tfwupd_security_attr_set_plugin(attr, \"other-plugin\");\n\tfwupd_security_attr_set_level(attr, FWUPD_SECURITY_ATTR_LEVEL_IMPORTANT);\n\tfwupd_security_attr_set_url(attr, \"http://other-plugin\");\n\tfu_security_attrs_append(attrs, attr);\n\tfu_security_attrs_depsolve(attrs);\n\thsi4 = fu_security_attrs_calculate_hsi(attrs, FU_SECURITY_ATTRS_FLAG_NONE);\n\tg_assert_cmpstr(hsi4, ==, \"HSI:1\");\n\tg_assert_true(fwupd_security_attr_has_flag(attr, FWUPD_SECURITY_ATTR_FLAG_OBSOLETED));\n\tg_clear_object(&attr);\n\n\t/* add attr from HSI:3, obsoleting the failure */\n\tattr = fwupd_security_attr_new(\"org.fwupd.hsi.BIOSGuard\");\n\tfwupd_security_attr_set_plugin(attr, \"test\");\n\tfwupd_security_attr_set_level(attr, FWUPD_SECURITY_ATTR_LEVEL_THEORETICAL);\n\tfwupd_security_attr_add_flag(attr, FWUPD_SECURITY_ATTR_FLAG_SUCCESS);\n\tfwupd_security_attr_add_obsolete(attr, \"org.fwupd.hsi.PRX\");\n\tfwupd_security_attr_set_url(attr, \"http://test\");\n\tfu_security_attrs_append(attrs, attr);\n\tfu_security_attrs_depsolve(attrs);\n\thsi5 = fu_security_attrs_calculate_hsi(attrs, FU_SECURITY_ATTRS_FLAG_NONE);\n\tg_assert_cmpstr(hsi5, ==, \"HSI:3\");\n\tg_clear_object(&attr);\n\n\t/* add taint that was fine */\n\tattr = fwupd_security_attr_new(FWUPD_SECURITY_ATTR_ID_FWUPD_PLUGINS);\n\tfwupd_security_attr_set_plugin(attr, \"test\");\n\tfwupd_security_attr_add_flag(attr, FWUPD_SECURITY_ATTR_FLAG_SUCCESS);\n\tfwupd_security_attr_add_flag(attr, FWUPD_SECURITY_ATTR_FLAG_RUNTIME_ISSUE);\n\tfwupd_security_attr_set_url(attr, \"http://test\");\n\tfu_security_attrs_append(attrs, attr);\n\thsi6 = fu_security_attrs_calculate_hsi(attrs, FU_SECURITY_ATTRS_FLAG_NONE);\n\tg_assert_cmpstr(hsi6, ==, \"HSI:3\");\n\tg_clear_object(&attr);\n\n\t/* add updates and attestation */\n\tattr = fwupd_security_attr_new(FWUPD_SECURITY_ATTR_ID_FWUPD_UPDATES);\n\tfwupd_security_attr_set_plugin(attr, \"test\");\n\tfwupd_security_attr_add_flag(attr, FWUPD_SECURITY_ATTR_FLAG_SUCCESS);\n\tfwupd_security_attr_set_url(attr, \"http://test\");\n\tfu_security_attrs_append(attrs, attr);\n\thsi7 = fu_security_attrs_calculate_hsi(attrs, FU_SECURITY_ATTRS_FLAG_NONE);\n\tg_assert_cmpstr(hsi7, ==, \"HSI:3\");\n\tg_clear_object(&attr);\n\n\t/* add issue that was uncool */\n\tattr = fwupd_security_attr_new(FWUPD_SECURITY_ATTR_ID_KERNEL_SWAP);\n\tfwupd_security_attr_set_plugin(attr, \"test\");\n\tfwupd_security_attr_add_flag(attr, FWUPD_SECURITY_ATTR_FLAG_RUNTIME_ISSUE);\n\tfwupd_security_attr_set_url(attr, \"http://test\");\n\tfu_security_attrs_append(attrs, attr);\n\thsi8 = fu_security_attrs_calculate_hsi(attrs, FU_SECURITY_ATTRS_FLAG_NONE);\n\tg_assert_cmpstr(hsi8, ==, \"HSI:3!\");\n\tg_clear_object(&attr);\n\n\t/* show version in the attribute */\n\tattr = fwupd_security_attr_new(FWUPD_SECURITY_ATTR_ID_KERNEL_SWAP);\n\tfwupd_security_attr_set_plugin(attr, \"test\");\n\tfwupd_security_attr_add_flag(attr, FWUPD_SECURITY_ATTR_FLAG_RUNTIME_ISSUE);\n\tfwupd_security_attr_set_url(attr, \"http://test\");\n\tfu_security_attrs_append(attrs, attr);\n\thsi9 = fu_security_attrs_calculate_hsi(attrs, FU_SECURITY_ATTRS_FLAG_ADD_VERSION);\n\texpected_hsi9 = g_strdup_printf(\"HSI:3! (v%d.%d.%d)\",\n\t\t\t\t\tFWUPD_MAJOR_VERSION,\n\t\t\t\t\tFWUPD_MINOR_VERSION,\n\t\t\t\t\tFWUPD_MICRO_VERSION);\n\tg_assert_cmpstr(hsi9, ==, expected_hsi9);\n\tg_clear_object(&attr);\n}\nstatic void\nfu_firmware_builder_round_trip_func(void)\n{\n\tstruct {\n\t\tGType gtype;\n\t\tconst gchar *xml_fn;\n\t\tconst gchar *checksum;\n\t} map[] = {\n\t    {FU_TYPE_DFUSE_FIRMWARE,\n\t     \"dfuse.builder.xml\",\n\t     \"c1ff429f0e381c8fe8e1b2ee41a5a9a79e2f2ff7\"},\n\t    {FU_TYPE_FDT_FIRMWARE, \"fdt.builder.xml\", \"40f7fbaff684a6bcf67c81b3079422c2529741e1\"},\n\t    {FU_TYPE_FIT_FIRMWARE, \"fit.builder.xml\", \"293ce07351bb7d76631c4e2ba47243db1e150f3c\"},\n\t    {FU_TYPE_SREC_FIRMWARE, \"srec.builder.xml\", \"2aae6c35c94fcfb415dbe95f408b9ce91ee846ed\"},\n\t    {FU_TYPE_IHEX_FIRMWARE, \"ihex.builder.xml\", \"a8d74f767f3fc992b413e5ba801cedc80a4cf013\"},\n\t    {FU_TYPE_FMAP_FIRMWARE, \"fmap.builder.xml\", \"a0b9ffc10a586d217edf9e9bae7c1fe7c564ea01\"},\n\t    {FU_TYPE_EFI_FIRMWARE_SECTION,\n\t     \"efi-firmware-section.builder.xml\",\n\t     \"2aae6c35c94fcfb415dbe95f408b9ce91ee846ed\"},\n\t    {FU_TYPE_EFI_FIRMWARE_SECTION,\n\t     \"efi-firmware-section.builder.xml\",\n\t     \"2aae6c35c94fcfb415dbe95f408b9ce91ee846ed\"},\n\t    {FU_TYPE_EFI_FIRMWARE_FILE,\n\t     \"efi-firmware-file.builder.xml\",\n\t     \"1002c14b29a76069f3b7e35c50a55d2b0d197441\"},\n\t    {FU_TYPE_EFI_FIRMWARE_FILESYSTEM,\n\t     \"efi-firmware-filesystem.builder.xml\",\n\t     \"d6fbadc1c303a3b4eede9db7fb0ddb353efffc86\"},\n\t    {FU_TYPE_EFI_FIRMWARE_VOLUME,\n\t     \"efi-firmware-volume.builder.xml\",\n\t     \"2aae6c35c94fcfb415dbe95f408b9ce91ee846ed\"},\n\t    {FU_TYPE_IFD_FIRMWARE, \"ifd.builder.xml\", \"0805c742e0deec12db2d8f9a86158a7cf610869b\"},\n\t    {FU_TYPE_CFU_OFFER,\n\t     \"cfu-offer.builder.xml\",\n\t     \"acc572d03a129081921c36118b527dab34a077ad\"},\n\t    {FU_TYPE_CFU_PAYLOAD,\n\t     \"cfu-payload.builder.xml\",\n\t     \"5da829f5fd15a28970aed98ebb26ebf2f88ed6f2\"},\n\t    {FU_TYPE_IFWI_CPD_FIRMWARE,\n\t     \"ifwi-cpd.builder.xml\",\n\t     \"91e348d17cb91ef7a528e85beb39d15a0532dca5\"},\n\t    {FU_TYPE_IFWI_FPT_FIRMWARE,\n\t     \"ifwi-fpt.builder.xml\",\n\t     \"d1f0fb2c2a7a99441bf4a825d060642315a94d91\"},\n\t    {FU_TYPE_OPROM_FIRMWARE,\n\t     \"oprom.builder.xml\",\n\t     \"2aae6c35c94fcfb415dbe95f408b9ce91ee846ed\"},\n\t    {FU_TYPE_INTEL_THUNDERBOLT_NVM,\n\t     \"intel-thunderbolt.builder.xml\",\n\t     \"e858000646fecb5223b41df57647c005b495749b\"},\n#ifdef HAVE_CBOR\n\t    {FU_TYPE_USWID_FIRMWARE,\n\t     \"uswid.builder.xml\",\n\t     \"cae8660d5acd5bb614d0410bc53dedaa1899aee1\"},\n#endif\n\t    {G_TYPE_INVALID, NULL, NULL}};\n\tg_type_ensure(FU_TYPE_COSWID_FIRMWARE);\n\tfor (guint i = 0; map[i].gtype != G_TYPE_INVALID; i++) {\n\t\tgboolean ret;\n\t\tg_autofree gchar *csum1 = NULL;\n\t\tg_autofree gchar *csum2 = NULL;\n\t\tg_autofree gchar *filename = NULL;\n\t\tg_autofree gchar *xml1 = NULL;\n\t\tg_autofree gchar *xml2 = NULL;\n\t\tg_autoptr(FuFirmware) firmware1 = g_object_new(map[i].gtype, NULL);\n\t\tg_autoptr(FuFirmware) firmware2 = g_object_new(map[i].gtype, NULL);\n\t\tg_autoptr(FuFirmware) firmware3 = g_object_new(map[i].gtype, NULL);\n\t\tg_autoptr(GError) error = NULL;\n\t\tg_autoptr(GBytes) blob = NULL;\n\n\t\t/* build and write */\n\t\tfilename = g_test_build_filename(G_TEST_DIST, \"tests\", map[i].xml_fn, NULL);\n\t\tret = g_file_get_contents(filename, &xml1, NULL, &error);\n\t\tg_assert_no_error(error);\n\t\tg_assert_true(ret);\n\t\tret = fu_firmware_build_from_xml(firmware1, xml1, &error);\n\t\tg_assert_no_error(error);\n\t\tg_assert_true(ret);\n\t\tcsum1 = fu_firmware_get_checksum(firmware1, G_CHECKSUM_SHA1, &error);\n\t\tg_assert_no_error(error);\n\t\tg_assert_cmpstr(csum1, ==, map[i].checksum);\n\n\t\t/* ensure we can write and then parse what we just wrote */\n\t\tblob = fu_firmware_write(firmware1, &error);\n\t\tg_assert_no_error(error);\n\t\tg_assert_nonnull(blob);\n\t\tret = fu_firmware_parse(firmware3, blob, FWUPD_INSTALL_FLAG_NO_SEARCH, &error);\n\t\tif (!ret)\n\t\t\tg_prefix_error(&error, \"%s: \", map[i].xml_fn);\n\t\tg_assert_no_error(error);\n\t\tg_assert_true(ret);\n\n\t\t/* ensure we can round-trip */\n\t\txml2 = fu_firmware_export_to_xml(firmware1, FU_FIRMWARE_EXPORT_FLAG_NONE, &error);\n\t\tg_assert_no_error(error);\n\t\tret = fu_firmware_build_from_xml(firmware2, xml2, &error);\n\t\tg_assert_no_error(error);\n\t\tg_assert_true(ret);\n\t\tcsum2 = fu_firmware_get_checksum(firmware2, G_CHECKSUM_SHA1, &error);\n\t\tg_assert_no_error(error);\n\t\tg_assert_cmpstr(csum2, ==, map[i].checksum);\n\t}\n}\n\ntypedef struct {\n\tguint last_percentage;\n\tguint updates;\n} FuProgressHelper;\n\nstatic void\nfu_progress_percentage_changed_cb(FuProgress *progress, guint percentage, gpointer data)\n{\n\tFuProgressHelper *helper = (FuProgressHelper *)data;\n\thelper->last_percentage = percentage;\n\thelper->updates++;\n}\n\nstatic void\nfu_progress_func(void)\n{\n\tFuProgressHelper helper = {0};\n\tg_autoptr(FuProgress) progress = fu_progress_new(G_STRLOC);\n\tg_autofree gchar *str = NULL;\n\n\tg_signal_connect(FU_PROGRESS(progress),\n\t\t\t \"percentage-changed\",\n\t\t\t G_CALLBACK(fu_progress_percentage_changed_cb),\n\t\t\t &helper);\n\n\tg_assert_cmpfloat_with_epsilon(fu_progress_get_duration(progress), 0.f, 0.001);\n\n\tfu_progress_set_profile(progress, TRUE);\n\tfu_progress_set_steps(progress, 5);\n\tg_assert_cmpint(helper.last_percentage, ==, 0);\n\n\tg_usleep(20 * 1000);\n\tfu_progress_step_done(progress);\n\tg_assert_cmpint(helper.updates, ==, 2);\n\tg_assert_cmpint(helper.last_percentage, ==, 20);\n\n\tfor (guint i = 0; i < 4; i++) {\n\t\tg_usleep(20 * 1000);\n\t\tfu_progress_step_done(progress);\n\t}\n\n\tg_assert_cmpint(helper.last_percentage, ==, 100);\n\tg_assert_cmpint(helper.updates, ==, 6);\n\tg_assert_cmpfloat_with_epsilon(fu_progress_get_duration(progress), 0.1f, 0.05);\n\tstr = fu_progress_traceback(progress);\n\tg_debug(\"\\n%s\", str);\n}\n\nstatic void\nfu_progress_child_func(void)\n{\n\tFuProgressHelper helper = {0};\n\tFuProgress *child;\n\tg_autoptr(FuProgress) progress = fu_progress_new(G_STRLOC);\n\n\t/* reset */\n\tfu_progress_set_profile(progress, TRUE);\n\tfu_progress_set_steps(progress, 2);\n\tg_signal_connect(FU_PROGRESS(progress),\n\t\t\t \"percentage-changed\",\n\t\t\t G_CALLBACK(fu_progress_percentage_changed_cb),\n\t\t\t &helper);\n\n\t/* parent: |-----------------------|-----------------------|\n\t * step1:  |-----------------------|\n\t * child:                          |-------------|---------|\n\t */\n\n\t/* PARENT UPDATE */\n\tg_debug(\"parent update #1\");\n\tfu_progress_step_done(progress);\n\tg_assert_cmpint(helper.updates, ==, 1);\n\tg_assert_cmpint(helper.last_percentage, ==, 50);\n\n\t/* now test with a child */\n\tchild = fu_progress_get_child(progress);\n\tfu_progress_set_id(child, G_STRLOC);\n\tfu_progress_set_steps(child, 2);\n\n\tg_debug(\"child update #1\");\n\tfu_progress_step_done(child);\n\tg_assert_cmpint(helper.updates, ==, 2);\n\tg_assert_cmpint(helper.last_percentage, ==, 75);\n\n\t/* child update */\n\tg_debug(\"child update #2\");\n\tfu_progress_step_done(child);\n\tg_assert_cmpint(helper.updates, ==, 3);\n\tg_assert_cmpint(helper.last_percentage, ==, 100);\n\n\t/* parent update */\n\tg_debug(\"parent update #2\");\n\tfu_progress_step_done(progress);\n\n\t/* ensure we ignored the duplicate */\n\tg_assert_cmpint(helper.updates, ==, 3);\n\tg_assert_cmpint(helper.last_percentage, ==, 100);\n}\n\nstatic void\nfu_progress_parent_one_step_proxy_func(void)\n{\n\tFuProgressHelper helper = {0};\n\tFuProgress *child;\n\tg_autoptr(FuProgress) progress = fu_progress_new(G_STRLOC);\n\n\t/* one step */\n\tfu_progress_set_steps(progress, 1);\n\tg_signal_connect(FU_PROGRESS(progress),\n\t\t\t \"percentage-changed\",\n\t\t\t G_CALLBACK(fu_progress_percentage_changed_cb),\n\t\t\t &helper);\n\n\t/* now test with a child */\n\tchild = fu_progress_get_child(progress);\n\tfu_progress_set_id(child, G_STRLOC);\n\tfu_progress_set_steps(child, 2);\n\n\t/* child set value */\n\tfu_progress_set_percentage(child, 33);\n\n\t/* ensure 1 updates for progress with one step and ensure using child value as parent */\n\tg_assert_cmpint(helper.updates, ==, 1);\n\tg_assert_cmpint(helper.last_percentage, ==, 33);\n}\n\nstatic void\nfu_progress_non_equal_steps_func(void)\n{\n\tg_autoptr(FuProgress) progress = fu_progress_new(G_STRLOC);\n\tFuProgress *child;\n\tFuProgress *grandchild;\n\n\t/* test non-equal steps */\n\tfu_progress_set_id(progress, G_STRLOC);\n\tfu_progress_add_step(progress, FWUPD_STATUS_DEVICE_ERASE, 20, NULL);\n\tfu_progress_add_step(progress, FWUPD_STATUS_DEVICE_WRITE, 60, NULL);\n\tfu_progress_add_step(progress, FWUPD_STATUS_DEVICE_READ, 20, NULL);\n\tg_assert_cmpint(fu_progress_get_percentage(progress), ==, 0);\n\tg_assert_cmpint(fu_progress_get_status(progress), ==, FWUPD_STATUS_DEVICE_ERASE);\n\n\t/* child step should increment according to the custom steps */\n\tchild = fu_progress_get_child(progress);\n\tfu_progress_set_id(child, G_STRLOC);\n\tfu_progress_set_steps(child, 2);\n\tfu_progress_set_status(child, FWUPD_STATUS_DEVICE_BUSY);\n\tg_assert_cmpint(fu_progress_get_status(progress), ==, FWUPD_STATUS_DEVICE_BUSY);\n\n\t/* start child */\n\tfu_progress_step_done(child);\n\n\t/* verify 10% */\n\tg_assert_cmpint(fu_progress_get_percentage(progress), ==, 10);\n\n\t/* finish child */\n\tfu_progress_step_done(child);\n\n\t/* ensure the parent is switched back to the status before the child took over */\n\tg_assert_cmpint(fu_progress_get_status(progress), ==, FWUPD_STATUS_DEVICE_ERASE);\n\n\tfu_progress_step_done(progress);\n\tg_assert_cmpint(fu_progress_get_status(progress), ==, FWUPD_STATUS_DEVICE_WRITE);\n\n\t/* verify 20% */\n\tg_assert_cmpint(fu_progress_get_percentage(progress), ==, 20);\n\n\t/* child step should increment according to the custom steps */\n\tchild = fu_progress_get_child(progress);\n\tfu_progress_set_id(child, G_STRLOC);\n\tfu_progress_set_id(child, G_STRLOC);\n\tfu_progress_add_step(child, FWUPD_STATUS_DEVICE_RESTART, 25, NULL);\n\tfu_progress_add_step(child, FWUPD_STATUS_DEVICE_WRITE, 75, NULL);\n\tg_assert_cmpint(fu_progress_get_status(progress), ==, FWUPD_STATUS_DEVICE_RESTART);\n\n\t/* start child */\n\tfu_progress_step_done(child);\n\tg_assert_cmpint(fu_progress_get_status(progress), ==, FWUPD_STATUS_DEVICE_WRITE);\n\n\t/* verify bilinear interpolation is working */\n\tg_assert_cmpint(fu_progress_get_percentage(progress), ==, 35);\n\n\t/*\n\t * 0        20                             80         100\n\t * |---------||----------------------------||---------|\n\t *            |       35                   |\n\t *            |-------||-------------------| (25%)\n\t *                     |              75.5 |\n\t *                     |---------------||--| (90%)\n\t */\n\tgrandchild = fu_progress_get_child(child);\n\tfu_progress_set_id(grandchild, G_STRLOC);\n\tfu_progress_add_step(grandchild, FWUPD_STATUS_DEVICE_ERASE, 90, NULL);\n\tfu_progress_add_step(grandchild, FWUPD_STATUS_DEVICE_WRITE, 10, NULL);\n\n\tfu_progress_step_done(grandchild);\n\n\t/* verify bilinear interpolation (twice) is working for subpercentage */\n\tg_assert_cmpint(fu_progress_get_percentage(progress), ==, 75);\n\n\tfu_progress_step_done(grandchild);\n\n\t/* finish child */\n\tfu_progress_step_done(child);\n\n\tfu_progress_step_done(progress);\n\tg_assert_cmpint(fu_progress_get_status(progress), ==, FWUPD_STATUS_DEVICE_READ);\n\n\t/* verify 80% */\n\tg_assert_cmpint(fu_progress_get_percentage(progress), ==, 80);\n\n\tfu_progress_step_done(progress);\n\n\t/* verify 100% */\n\tg_assert_cmpint(fu_progress_get_percentage(progress), ==, 100);\n\tg_assert_cmpint(fu_progress_get_status(progress), ==, FWUPD_STATUS_UNKNOWN);\n}\n\nstatic void\nfu_progress_finish_func(void)\n{\n\tFuProgress *child;\n\tg_autoptr(FuProgress) progress = fu_progress_new(G_STRLOC);\n\n\t/* check straight finish */\n\tfu_progress_set_steps(progress, 3);\n\n\tchild = fu_progress_get_child(progress);\n\tfu_progress_set_id(child, G_STRLOC);\n\tfu_progress_set_steps(child, 3);\n\tfu_progress_finished(child);\n\n\t/* parent step done after child finish */\n\tfu_progress_step_done(progress);\n}\n\nstatic void\nfu_progress_child_finished(void)\n{\n\tFuProgress *child;\n\tg_autoptr(FuProgress) progress = fu_progress_new(G_STRLOC);\n\n\t/* check straight finish */\n\tfu_progress_set_steps(progress, 3);\n\n\tchild = fu_progress_get_child(progress);\n\tfu_progress_set_id(child, G_STRLOC);\n\tfu_progress_set_steps(child, 3);\n\t/* some imaginary igorable error */\n\n\t/* parent step done after child finish */\n\tfu_progress_add_flag(progress, FU_PROGRESS_FLAG_CHILD_FINISHED);\n\tfu_progress_step_done(progress);\n}\n\nint\nmain(int argc, char **argv)\n{\n\tg_autofree gchar *testdatadir = NULL;\n\n\tg_test_init(&argc, &argv, NULL);\n\tg_type_ensure(FU_TYPE_IFD_BIOS);\n\n\t/* only critical and error are fatal */\n\tg_log_set_fatal_mask(NULL, G_LOG_LEVEL_ERROR | G_LOG_LEVEL_CRITICAL);\n\t(void)g_setenv(\"G_MESSAGES_DEBUG\", \"all\", TRUE);\n\n\ttestdatadir = g_test_build_filename(G_TEST_DIST, \"tests\", NULL);\n\t(void)g_setenv(\"FWUPD_DATADIR\", testdatadir, TRUE);\n\t(void)g_setenv(\"FWUPD_PLUGINDIR\", testdatadir, TRUE);\n\t(void)g_setenv(\"FWUPD_SYSCONFDIR\", testdatadir, TRUE);\n\t(void)g_setenv(\"FWUPD_SYSFSFWATTRIBDIR\", testdatadir, TRUE);\n\t(void)g_setenv(\"FWUPD_OFFLINE_TRIGGER\", \"/tmp/fwupd-self-test/system-update\", TRUE);\n\t(void)g_setenv(\"FWUPD_LOCALSTATEDIR\", \"/tmp/fwupd-self-test/var\", TRUE);\n\t(void)g_setenv(\"FWUPD_PROFILE\", \"1\", TRUE);\n\n\tg_test_add_func(\"/fwupd/common{strnsplit}\", fu_strsplit_func);\n\tg_test_add_func(\"/fwupd/common{memmem}\", fu_common_memmem_func);\n\tg_test_add_func(\"/fwupd/progress\", fu_progress_func);\n\tg_test_add_func(\"/fwupd/progress{child}\", fu_progress_child_func);\n\tg_test_add_func(\"/fwupd/progress{child-finished}\", fu_progress_child_finished);\n\tg_test_add_func(\"/fwupd/progress{parent-1-step}\", fu_progress_parent_one_step_proxy_func);\n\tg_test_add_func(\"/fwupd/progress{no-equal}\", fu_progress_non_equal_steps_func);\n\tg_test_add_func(\"/fwupd/progress{finish}\", fu_progress_finish_func);\n\tg_test_add_func(\"/fwupd/bios-attrs{load}\", fu_bios_settings_load_func);\n\tg_test_add_func(\"/fwupd/security-attrs{hsi}\", fu_security_attrs_hsi_func);\n\tg_test_add_func(\"/fwupd/plugin{devices}\", fu_plugin_devices_func);\n\tg_test_add_func(\"/fwupd/plugin{device-inhibit-children}\",\n\t\t\tfu_plugin_device_inhibit_children_func);\n\tg_test_add_func(\"/fwupd/plugin{delay}\", fu_plugin_delay_func);\n\tg_test_add_func(\"/fwupd/plugin{quirks}\", fu_plugin_quirks_func);\n\tg_test_add_func(\"/fwupd/plugin{quirks-performance}\", fu_plugin_quirks_performance_func);\n\tg_test_add_func(\"/fwupd/plugin{quirks-device}\", fu_plugin_quirks_device_func);\n\tg_test_add_func(\"/fwupd/backend\", fu_backend_func);\n\tg_test_add_func(\"/fwupd/chunk\", fu_chunk_func);\n\tg_test_add_func(\"/fwupd/common{align-up}\", fu_common_align_up_func);\n\tg_test_add_func(\"/fwupd/common{gpt-type}\", fu_common_gpt_type_func);\n\tg_test_add_func(\"/fwupd/common{byte-array}\", fu_common_byte_array_func);\n\tg_test_add_func(\"/fwupd/common{crc}\", fu_common_crc_func);\n\tg_test_add_func(\"/fwupd/common{string-append-kv}\", fu_string_append_func);\n\tg_test_add_func(\"/fwupd/common{version-guess-format}\", fu_version_guess_format_func);\n\tg_test_add_func(\"/fwupd/common{strtoull}\", fu_strtoull_func);\n\tg_test_add_func(\"/fwupd/common{version}\", fu_common_version_func);\n\tg_test_add_func(\"/fwupd/common{version-semver}\", fu_version_semver_func);\n\tg_test_add_func(\"/fwupd/common{vercmp}\", fu_common_vercmp_func);\n\tg_test_add_func(\"/fwupd/common{strstrip}\", fu_strstrip_func);\n\tg_test_add_func(\"/fwupd/common{endian}\", fu_common_endian_func);\n\tg_test_add_func(\"/fwupd/common{cabinet}\", fu_common_cabinet_func);\n\tg_test_add_func(\"/fwupd/common{bytes-get-data}\", fu_common_bytes_get_data_func);\n\tg_test_add_func(\"/fwupd/common{kernel-lockdown}\", fu_common_kernel_lockdown_func);\n\tg_test_add_func(\"/fwupd/common{strsafe}\", fu_strsafe_func);\n\tg_test_add_func(\"/fwupd/efivar\", fu_efivar_func);\n\tg_test_add_func(\"/fwupd/hwids\", fu_hwids_func);\n\tg_test_add_func(\"/fwupd/smbios\", fu_smbios_func);\n\tg_test_add_func(\"/fwupd/smbios3\", fu_smbios3_func);\n\tg_test_add_func(\"/fwupd/smbios{dt}\", fu_smbios_dt_func);\n\tg_test_add_func(\"/fwupd/smbios{dt-fallback}\", fu_smbios_dt_fallback_func);\n\tg_test_add_func(\"/fwupd/smbios{class}\", fu_smbios_class_func);\n\tg_test_add_func(\"/fwupd/firmware\", fu_firmware_func);\n\tg_test_add_func(\"/fwupd/firmware{common}\", fu_firmware_common_func);\n\tg_test_add_func(\"/fwupd/firmware{linear}\", fu_firmware_linear_func);\n\tg_test_add_func(\"/fwupd/firmware{dedupe}\", fu_firmware_dedupe_func);\n\tg_test_add_func(\"/fwupd/firmware{build}\", fu_firmware_build_func);\n\tg_test_add_func(\"/fwupd/firmware{raw-aligned}\", fu_firmware_raw_aligned_func);\n\tg_test_add_func(\"/fwupd/firmware{ihex}\", fu_firmware_ihex_func);\n\tg_test_add_func(\"/fwupd/firmware{ihex-offset}\", fu_firmware_ihex_offset_func);\n\tg_test_add_func(\"/fwupd/firmware{ihex-signed}\", fu_firmware_ihex_signed_func);\n\tg_test_add_func(\"/fwupd/firmware{srec-tokenization}\", fu_firmware_srec_tokenization_func);\n\tg_test_add_func(\"/fwupd/firmware{srec}\", fu_firmware_srec_func);\n\tg_test_add_func(\"/fwupd/firmware{fdt}\", fu_firmware_fdt_func);\n\tg_test_add_func(\"/fwupd/firmware{fit}\", fu_firmware_fit_func);\n\tg_test_add_func(\"/fwupd/firmware{ifwi-cpd}\", fu_firmware_ifwi_cpd_func);\n\tg_test_add_func(\"/fwupd/firmware{ifwi-fpt}\", fu_firmware_ifwi_fpt_func);\n\tg_test_add_func(\"/fwupd/firmware{oprom}\", fu_firmware_oprom_func);\n\tg_test_add_func(\"/fwupd/firmware{dfu}\", fu_firmware_dfu_func);\n\tg_test_add_func(\"/fwupd/firmware{dfu-patch}\", fu_firmware_dfu_patch_func);\n\tg_test_add_func(\"/fwupd/firmware{dfuse}\", fu_firmware_dfuse_func);\n\tg_test_add_func(\"/fwupd/firmware{builder-round-trip}\", fu_firmware_builder_round_trip_func);\n\tg_test_add_func(\"/fwupd/firmware{fmap}\", fu_firmware_fmap_func);\n\tg_test_add_func(\"/fwupd/firmware{gtypes}\", fu_firmware_new_from_gtypes_func);\n\tg_test_add_func(\"/fwupd/archive{invalid}\", fu_archive_invalid_func);\n\tg_test_add_func(\"/fwupd/archive{cab}\", fu_archive_cab_func);\n\tg_test_add_func(\"/fwupd/device\", fu_device_func);\n\tg_test_add_func(\"/fwupd/device{instance-ids}\", fu_device_instance_ids_func);\n\tg_test_add_func(\"/fwupd/device{composite-id}\", fu_device_composite_id_func);\n\tg_test_add_func(\"/fwupd/device{flags}\", fu_device_flags_func);\n\tg_test_add_func(\"/fwupd/device{custom-flags}\", fu_device_private_flags_func);\n\tg_test_add_func(\"/fwupd/device{inhibit}\", fu_device_inhibit_func);\n\tg_test_add_func(\"/fwupd/device{inhibit-updateable}\", fu_device_inhibit_updateable_func);\n\tg_test_add_func(\"/fwupd/device{parent}\", fu_device_parent_func);\n\tg_test_add_func(\"/fwupd/device{children}\", fu_device_children_func);\n\tg_test_add_func(\"/fwupd/device{incorporate}\", fu_device_incorporate_func);\n\tif (g_test_slow())\n\t\tg_test_add_func(\"/fwupd/device{poll}\", fu_device_poll_func);\n\tg_test_add_func(\"/fwupd/device-locker{success}\", fu_device_locker_func);\n\tg_test_add_func(\"/fwupd/device-locker{fail}\", fu_device_locker_fail_func);\n\tg_test_add_func(\"/fwupd/device{name}\", fu_device_name_func);\n\tg_test_add_func(\"/fwupd/device{metadata}\", fu_device_metadata_func);\n\tg_test_add_func(\"/fwupd/device{open-refcount}\", fu_device_open_refcount_func);\n\tg_test_add_func(\"/fwupd/device{version-format}\", fu_device_version_format_func);\n\tg_test_add_func(\"/fwupd/device{retry-success}\", fu_device_retry_success_func);\n\tg_test_add_func(\"/fwupd/device{retry-failed}\", fu_device_retry_failed_func);\n\tg_test_add_func(\"/fwupd/device{retry-hardware}\", fu_device_retry_hardware_func);\n\tg_test_add_func(\"/fwupd/device{cfi-device}\", fu_device_cfi_device_func);\n\treturn g_test_run();\n}\n"], "fixing_code": ["%global glib2_version 2.45.8\n%global libxmlb_version 0.1.3\n%global libgusb_version 0.3.5\n%global libcurl_version 7.61.0\n%global libjcat_version 0.1.0\n%global systemd_version 231\n%global json_glib_version 1.1.1\n%global fwupdplugin_version @FWUPD_PLUGINVER@\n\n# although we ship a few tiny python files these are utilities that 99.99%\n# of users do not need -- use this to avoid dragging python onto CoreOS\n%global __requires_exclude ^%{python3}$\n\n%define alphatag                #ALPHATAG#\n\n%global enable_ci 0\n%global enable_tests 1\n%global enable_dummy 1\n%global __meson_wrap_mode nodownload\n\n# fwupd.efi is only available on these arches\n%ifarch x86_64 aarch64\n%global have_uefi 1\n%endif\n\n# gpio.h is only available on these arches\n%ifarch x86_64 aarch64\n%global have_gpio 1\n%endif\n\n# flashrom is only available on these arches\n%ifarch i686 x86_64 armv7hl aarch64 ppc64le\n%global have_flashrom 1\n%endif\n\n%ifarch i686 x86_64\n%global have_msr 1\n%endif\n\n# libsmbios is only available on x86\n%ifarch x86_64\n%global have_dell 1\n%endif\n\n# Until we actually have seen it outside x86\n%ifarch i686 x86_64\n%global have_thunderbolt 1\n%endif\n\n# only available recently\n%if 0%{?fedora} >= 30\n%global have_modem_manager 1\n%endif\n\nSummary:   Firmware update daemon\nName:      fwupd\nVersion:   #VERSION#\nRelease:   0.#BUILD#%{?alphatag}%{?dist}\nLicense:   LGPLv2+\nURL:       https://github.com/fwupd/fwupd\nSource0:   http://people.freedesktop.org/~hughsient/releases/%{name}-%{version}.tar.xz\n\nBuildRequires: gettext\nBuildRequires: glib2-devel >= %{glib2_version}\nBuildRequires: libxmlb-devel >= %{libxmlb_version}\nBuildRequires: libgcab1-devel\nBuildRequires: libgudev1-devel\nBuildRequires: libgusb-devel >= %{libgusb_version}\nBuildRequires: libcurl-devel >= %{libcurl_version}\nBuildRequires: libjcat-devel >= %{libjcat_version}\nBuildRequires: polkit-devel >= 0.103\nBuildRequires: protobuf-c-devel\nBuildRequires: python3-packaging\nBuildRequires: sqlite-devel\nBuildRequires: systemd >= %{systemd_version}\nBuildRequires: systemd-devel\nBuildRequires: libarchive-devel\nBuildRequires: libcbor-devel\nBuildRequires: gobject-introspection-devel\nBuildRequires: gcab\n%ifarch %{valgrind_arches}\nBuildRequires: valgrind\nBuildRequires: valgrind-devel\n%endif\nBuildRequires: gi-docgen\nBuildRequires: gnutls-devel\nBuildRequires: gnutls-utils\nBuildRequires: meson\nBuildRequires: json-glib-devel >= %{json_glib_version}\nBuildRequires: vala\nBuildRequires: bash-completion\nBuildRequires: git-core\n%if 0%{?have_flashrom}\nBuildRequires: flashrom-devel >= 1.2-2\n%endif\n\n%if 0%{?have_modem_manager}\nBuildRequires: ModemManager-glib-devel >= 1.10.0\nBuildRequires: libqmi-devel >= 1.22.0\nBuildRequires: libmbim-devel\n%endif\n\n%if 0%{?have_uefi}\nBuildRequires: efivar-devel >= 33\nBuildRequires: python3 python3-cairo python3-gobject\nBuildRequires: pango-devel\nBuildRequires: cairo-devel cairo-gobject-devel\nBuildRequires: freetype\nBuildRequires: fontconfig\nBuildRequires: google-noto-sans-cjk-ttc-fonts\nBuildRequires: tpm2-tss-devel >= 2.2.3\n%endif\n\n%if 0%{?have_dell}\nBuildRequires: efivar-devel >= 33\nBuildRequires: libsmbios-devel >= 2.3.0\n%endif\n\nRequires(post): systemd\nRequires(preun): systemd\nRequires(postun): systemd\n\nRequires: glib2%{?_isa} >= %{glib2_version}\nRequires: libxmlb%{?_isa} >= %{libxmlb_version}\nRequires: libgusb%{?_isa} >= %{libgusb_version}\nRequires: shared-mime-info\n\n%if 0%{?rhel} > 7 || 0%{?fedora} > 28\nRecommends: python3\n%endif\n\nObsoletes: fwupd-sign < 0.1.6\nObsoletes: libebitdo < 0.7.5-3\nObsoletes: libdfu < 1.0.0\nObsoletes: fwupd-labels < 1.1.0-1\n\nObsoletes: dbxtool < 9\nProvides: dbxtool\n\n%if 0%{?rhel} > 7\nObsoletes: fwupdate < 11-4\nObsoletes: fwupdate-efi < 11-4\n\nProvides: fwupdate\nProvides: fwupdate-efi\n%endif\n\n# optional, but a really good idea\nRecommends: udisks2\nRecommends: bluez\nRecommends: jq\n\n%if 0%{?have_modem_manager}\nRecommends: %{name}-plugin-modem-manager\n%endif\n%if 0%{?have_flashrom}\nRecommends: %{name}-plugin-flashrom\n%endif\n%if 0%{?have_uefi}\nRecommends: %{name}-efi\nRecommends: %{name}-plugin-uefi-capsule-data\n%endif\n\n%description\nfwupd is a daemon to allow session software to update device firmware.\n\n%package devel\nSummary: Development package for %{name}\nRequires: %{name}%{?_isa} = %{version}-%{release}\nObsoletes: libebitdo-devel < 0.7.5-3\nObsoletes: libdfu-devel < 1.0.0\n\n%description devel\nFiles for development with %{name}.\n\n%package tests\nSummary: Data files for installed tests\nRequires: %{name}%{?_isa} = %{version}-%{release}\n\n%description tests\nData files for installed tests.\n\n%if 0%{?have_modem_manager}\n%package plugin-modem-manager\nSummary: fwupd plugin using ModemManger\nRequires: %{name}%{?_isa} = %{version}-%{release}\n\n%description plugin-modem-manager\nThis provides the optional package which is only required on hardware that\nmight have mobile broadband hardware. It is probably not required on servers.\n%endif\n\n%if 0%{?have_flashrom}\n%package plugin-flashrom\nSummary: fwupd plugin using flashrom\nRequires: %{name}%{?_isa} = %{version}-%{release}\n\n%description plugin-flashrom\nThis provides the optional package which is only required on hardware that\ncan be flashed using flashrom. It is probably not required on servers.\n%endif\n\n%if 0%{?have_uefi}\n%package plugin-uefi-capsule-data\nSummary: Localized data for the UEFI UX capsule\nRequires: %{name}%{?_isa} = %{version}-%{release}\n\n%description plugin-uefi-capsule-data\nThis provides the pregenerated BMP artwork for the UX capsule, which allows the\n\"Installing firmware update\u2026\" localized text to be shown during a UEFI firmware\nupdate operation. This subpackage is probably not required on embedded hardware\nor server machines.\n%endif\n\n%if 0%{?qubes_packages}\n%package qubes-dom0\nSummary: fwupd wrapper for Qubes OS - dom0 scripts\nRequires:   gcab\nRequires:   fwupd >= 1.5.7\nRequires:   libjcat >= 0.1.6\n\n%description qubes-dom0\nfwupd wrapper for Qubes OS\n\n%package qubes-vm\nSummary: fwupd wrapper for Qubes OS - VM scripts\nRequires:   gcab\nRequires:   fwupd >= 1.5.7\nRequires:   libjcat >= 0.1.6\n\n%description qubes-vm\nfwupd wrapper for Qubes OS\n%endif\n\n%prep\n%autosetup -p1\n\n%build\n\n%meson \\\n%if 0%{?enable_ci}\n    --werror \\\n%endif\n    -Ddocs=enabled \\\n%if 0%{?enable_tests}\n    -Dtests=true \\\n%else\n    -Dtests=false \\\n%endif\n%if 0%{?enable_dummy}\n    -Dplugin_dummy=true \\\n%else\n    -Dplugin_dummy=false \\\n%endif\n%if 0%{?have_flashrom}\n    -Dplugin_flashrom=enabled \\\n%else\n    -Dplugin_flashrom=disabled \\\n%endif\n%if 0%{?have_msr}\n    -Dplugin_msr=enabled \\\n%else\n    -Dplugin_msr=disabled \\\n%endif\n%if 0%{?have_gpio}\n    -Dplugin_gpio=enabled \\\n%else\n    -Dplugin_gpio=disabled \\\n%endif\n%if 0%{?have_uefi}\n    -Dplugin_uefi_capsule=enabled \\\n    -Dplugin_uefi_pk=enabled \\\n    -Dplugin_tpm=enabled \\\n    -Defi_binary=false \\\n%else\n    -Dplugin_uefi_capsule=disabled \\\n    -Dplugin_uefi_pk=disabled \\\n    -Dplugin_tpm=disabled \\\n%endif\n%if 0%{?have_dell}\n    -Dplugin_dell=enabled \\\n%else\n    -Dplugin_dell=disabled \\\n%endif\n%if 0%{?have_modem_manager}\n    -Dplugin_modem_manager=enabled \\\n%else\n    -Dplugin_modem_manager=disabled \\\n%endif\n%if 0%{?qubes_packages}\n    -Dqubes=true \\\n%endif\n    -Dman=true \\\n    -Dbluez=enabled \\\n    -Dplugin_powerd=disabled \\\n    -Dgresource_quirks=disabled \\\n    -Dsupported_build=enabled\n\n%meson_build\n\n%if 0%{?enable_tests}\n%if 0%{?enable_ci}\n    ./contrib/ci/get_test_firmware.sh\n%endif\n%check\n%meson_test\n%endif\n\n%install\n%meson_install\n\nmkdir -p --mode=0700 $RPM_BUILD_ROOT%{_localstatedir}/lib/fwupd/gnupg\n\n# workaround for https://bugzilla.redhat.com/show_bug.cgi?id=1757948\nmkdir -p $RPM_BUILD_ROOT%{_localstatedir}/cache/fwupd\n\n%find_lang %{name}\n\n%post\n%systemd_post fwupd.service\n\n# change vendor-installed remotes to use the default keyring type\nfor fn in /etc/fwupd/remotes.d/*.conf; do\n    if grep -q \"Keyring=gpg\" \"$fn\"; then\n        sed -i 's/Keyring=gpg/#Keyring=pkcs/g' \"$fn\";\n    fi\ndone\n\n# ensure this is private\nchmod 0660 /etc/fwupd/redfish.conf\n\n%preun\n%systemd_preun fwupd.service\n\n%postun\n%systemd_postun_with_restart fwupd.service\n\n%files -f %{name}.lang\n%doc README.md AUTHORS\n%license COPYING\n%config(noreplace)%{_sysconfdir}/fwupd/daemon.conf\n%if 0%{?have_uefi}\n%config(noreplace)%{_sysconfdir}/fwupd/uefi_capsule.conf\n%endif\n%config(noreplace)%{_sysconfdir}/fwupd/redfish.conf\n%if 0%{?have_thunderbolt}\n%config(noreplace)%{_sysconfdir}/fwupd/thunderbolt.conf\n%endif\n%dir %{_libexecdir}/fwupd\n%{_libexecdir}/fwupd/fwupd\n%ifarch i686 x86_64\n%{_libexecdir}/fwupd/fwupd-detect-cet\n%endif\n%{_libexecdir}/fwupd/fwupdoffline\n%if 0%{?have_uefi}\n%{_bindir}/fwupdate\n%endif\n%{_bindir}/dfu-tool\n%if 0%{?have_uefi}\n%{_bindir}/dbxtool\n%endif\n%{_bindir}/fwupdmgr\n%{_bindir}/fwupdtool\n%{_bindir}/fwupdagent\n%dir %{_sysconfdir}/fwupd\n%dir %{_sysconfdir}/fwupd/bios-settings.d\n%config%(noreplace)%{_sysconfdir}/fwupd/bios-settings.d/README.md\n%dir %{_sysconfdir}/fwupd/remotes.d\n%if 0%{?have_dell}\n%config(noreplace)%{_sysconfdir}/fwupd/remotes.d/dell-esrt.conf\n%endif\n%config(noreplace)%{_sysconfdir}/fwupd/remotes.d/lvfs.conf\n%config(noreplace)%{_sysconfdir}/fwupd/remotes.d/lvfs-testing.conf\n%config(noreplace)%{_sysconfdir}/fwupd/remotes.d/vendor.conf\n%config(noreplace)%{_sysconfdir}/fwupd/remotes.d/vendor-directory.conf\n%config(noreplace)%{_sysconfdir}/pki/fwupd\n%{_sysconfdir}/pki/fwupd-metadata\n%if 0%{?have_msr}\n/usr/lib/modules-load.d/fwupd-msr.conf\n%config(noreplace)%{_sysconfdir}/fwupd/msr.conf\n%endif\n%{_datadir}/dbus-1/system.d/org.freedesktop.fwupd.conf\n%{_datadir}/bash-completion/completions/fwupdmgr\n%{_datadir}/bash-completion/completions/fwupdtool\n%{_datadir}/bash-completion/completions/fwupdagent\n%{_datadir}/fish/vendor_completions.d/fwupdmgr.fish\n%{_datadir}/fwupd/metainfo/org.freedesktop.fwupd*.metainfo.xml\n%if 0%{?have_dell}\n%{_datadir}/fwupd/remotes.d/dell-esrt/metadata.xml\n%endif\n%{_datadir}/fwupd/remotes.d/vendor/firmware/README.md\n%{_datadir}/dbus-1/interfaces/org.freedesktop.fwupd.xml\n%{_datadir}/polkit-1/actions/org.freedesktop.fwupd.policy\n%{_datadir}/polkit-1/rules.d/org.freedesktop.fwupd.rules\n%{_datadir}/dbus-1/system-services/org.freedesktop.fwupd.service\n%{_mandir}/man1/fwupdtool.1*\n%{_mandir}/man1/fwupdagent.1*\n%{_mandir}/man1/dfu-tool.1*\n%if 0%{?have_uefi}\n%{_mandir}/man1/dbxtool.*\n%endif\n%{_mandir}/man1/fwupdmgr.1*\n%if 0%{?have_uefi}\n%{_mandir}/man1/fwupdate.1*\n%endif\n%{_datadir}/metainfo/org.freedesktop.fwupd.metainfo.xml\n%{_datadir}/icons/hicolor/scalable/apps/org.freedesktop.fwupd.svg\n%{_datadir}/fwupd/firmware_packager.py\n%{_datadir}/fwupd/simple_client.py\n%{_datadir}/fwupd/add_capsule_header.py\n%{_datadir}/fwupd/install_dell_bios_exe.py\n%{_unitdir}/fwupd-offline-update.service\n%{_unitdir}/fwupd.service\n%{_unitdir}/fwupd-refresh.service\n%{_unitdir}/fwupd-refresh.timer\n%{_presetdir}/fwupd-refresh.preset\n%{_unitdir}/system-update.target.wants/\n%dir %{_localstatedir}/lib/fwupd\n%dir %{_localstatedir}/cache/fwupd\n%dir %{_datadir}/fwupd/quirks.d\n%{_datadir}/fwupd/quirks.d/*.quirk\n%{_datadir}/doc/fwupd/*.html\n%{_datadir}/fwupd/host-emulate.d/*.json.gz\n%if 0%{?have_uefi}\n%{_sysconfdir}/grub.d/35_fwupd\n%endif\n%{_libdir}/libfwupd.so.2*\n%{_libdir}/libfwupdplugin.so.%{fwupdplugin_version}*\n%{_libdir}/girepository-1.0/Fwupd-2.0.typelib\n%{_libdir}/girepository-1.0/FwupdPlugin-1.0.typelib\n/usr/lib/udev/rules.d/*.rules\n/usr/lib/systemd/system-shutdown/fwupd.shutdown\n%dir %{_libdir}/fwupd-plugins-%{fwupdplugin_version}\n%ifarch i686 x86_64\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_acpi_facp.so\n%endif\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_acpi_phat.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_amt.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_analogix.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_android_boot.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_ata.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_bcm57xx.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_cfu.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_ccgx.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_ch341a.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_colorhug.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_corsair.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_cros_ec.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_cpu.so\n%if 0%{?have_dell}\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_dell.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_dell_esrt.so\n%endif\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_dell_dock.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_dfu.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_dfu_csr.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_ebitdo.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_elantp.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_elanfp.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_emmc.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_ep963x.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_fastboot.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_fresco_pd.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_genesys.so\n%if 0%{?have_gpio}\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_gpio.so\n%endif\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_hailuck.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_intel_usb4.so\n%ifarch i686 x86_64\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_iommu.so\n%endif\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_jabra.so\n%if 0%{?have_uefi}\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_lenovo_thinklmi.so\n%endif\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_linux_lockdown.so\n%ifarch i686 x86_64\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_linux_sleep.so\n%endif\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_linux_swap.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_linux_tainted.so\n%if 0%{?have_msr}\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_acpi_dmar.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_acpi_ivrs.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_msr.so\n%endif\n%ifarch x86_64\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_amd_pmc.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_pci_psp.so\n%endif\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_mtd.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_nitrokey.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_nordic_hid.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_nvme.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_optionrom.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_parade_lspcon.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_pci_bcr.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_pci_mei.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_pixart_rf.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_realtek_mst.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_redfish.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_rts54hid.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_rts54hub.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_scsi.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_steelseries.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_superio.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_synaptics_mst.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_synaptics_cape.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_synaptics_cxaudio.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_synaptics_prometheus.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_synaptics_rmi.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_system76_launch.so\n%if 0%{?enable_dummy}\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_test.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_test_ble.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_invalid.so\n%endif\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_thelio_io.so\n%if 0%{?have_thunderbolt}\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_thunderbolt.so\n%endif\n%if 0%{?have_uefi}\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_tpm.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_bios.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_uefi_capsule.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_uefi_dbx.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_uefi_pk.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_uefi_recovery.so\n%endif\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_usi_dock.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_vbe.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_logind.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_logitech_bulkcontroller.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_logitech_hidpp.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_uf2.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_upower.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_vli.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_wacom_raw.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_wacom_usb.so\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_goodixmoc.so\n%ghost %{_localstatedir}/lib/fwupd/gnupg\n\n%if 0%{?have_modem_manager}\n%files plugin-modem-manager\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_modem_manager.so\n%endif\n%if 0%{?have_flashrom}\n%files plugin-flashrom\n%{_libdir}/fwupd-plugins-%{fwupdplugin_version}/libfu_plugin_flashrom.so\n%endif\n%if 0%{?have_uefi}\n%files plugin-uefi-capsule-data\n%{_datadir}/fwupd/uefi-capsule-ux.tar.xz\n%endif\n\n%files devel\n%{_datadir}/gir-1.0/Fwupd-2.0.gir\n%{_datadir}/gir-1.0/FwupdPlugin-1.0.gir\n%{_datadir}/doc/fwupd/libfwupdplugin\n%{_datadir}/doc/fwupd/libfwupd\n%{_datadir}/doc/libfwupdplugin\n%{_datadir}/doc/libfwupd\n%{_datadir}/vala/vapi\n%{_includedir}/fwupd-1\n%{_libdir}/libfwupd*.so\n%{_libdir}/pkgconfig/fwupd.pc\n%{_libdir}/pkgconfig/fwupdplugin.pc\n\n%files tests\n%if 0%{?enable_tests}\n%dir %{_datadir}/installed-tests/fwupd\n%{_datadir}/installed-tests/fwupd/tests/*\n%{_datadir}/installed-tests/fwupd/fwupd-tests.xml\n%{_datadir}/installed-tests/fwupd/*.test\n%{_datadir}/installed-tests/fwupd/*.cab\n%{_datadir}/installed-tests/fwupd/*.sh\n%if 0%{?have_uefi}\n%{_datadir}/installed-tests/fwupd/efi\n%endif\n%{_datadir}/fwupd/device-tests/*.json\n%{_libexecdir}/installed-tests/fwupd/*\n%dir %{_sysconfdir}/fwupd/remotes.d\n%config(noreplace)%{_sysconfdir}/fwupd/remotes.d/fwupd-tests.conf\n%endif\n\n%if 0%{?qubes_packages}\n%files qubes-vm\n%{_libexecdir}/qubes-fwupd/fwupd_common_vm.py\n%{_libexecdir}/qubes-fwupd/fwupd_download_updates.py\n%{_libexecdir}/qubes-fwupd/fwupd_usbvm_validate.py\n\n%files qubes-dom0\n%{_datadir}/qubes-fwupd/src/fwupd_receive_updates.py\n/usr/sbin/qubes-fwupdmgr\n%{_datadir}/qubes-fwupd/src/qubes_fwupd_heads.py\n%{_datadir}/qubes-fwupd/src/qubes_fwupd_update.py\n%{_datadir}/qubes-fwupd/src/__init__.py\n%{_datadir}/qubes-fwupd/test/fwupd_logs.py\n%{_datadir}/qubes-fwupd/test/test_qubes_fwupdmgr.py\n%{_datadir}/qubes-fwupd/test/test_qubes_fwupd_heads.py\n%{_datadir}/qubes-fwupd/test/__init__.py\n%{_datadir}/qubes-fwupd/test/logs/get_devices.log\n%{_datadir}/qubes-fwupd/test/logs/get_updates.log\n%{_datadir}/qubes-fwupd/test/logs/help.log\n%{_datadir}/qubes-fwupd/test/logs/firmware.metainfo.xml\n%{_datadir}/qubes-fwupd/test/logs/metainfo_name/firmware.metainfo.xml\n%{_datadir}/qubes-fwupd/test/logs/metainfo_version/firmware.metainfo.xml\n%endif\n\n%changelog\n* #LONGDATE# Richard Hughes <richard@hughsie.com> #VERSION#-0.#BUILD##ALPHATAG#\n- Update from git\n", "/*\n * Copyright (C) 2016 Richard Hughes <richard@hughsie.com>\n *\n * SPDX-License-Identifier: LGPL-2.1+\n */\n\n#define G_LOG_DOMAIN \"FuPlugin\"\n\n#include \"config.h\"\n\n#include <errno.h>\n#include <fcntl.h>\n#include <fwupd.h>\n#include <glib/gstdio.h>\n#include <gmodule.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"fu-bytes.h\"\n#include \"fu-context-private.h\"\n#include \"fu-device-private.h\"\n#include \"fu-kernel.h\"\n#include \"fu-mutex.h\"\n#include \"fu-path.h\"\n#include \"fu-plugin-private.h\"\n#include \"fu-security-attr.h\"\n#include \"fu-string.h\"\n\n/**\n * FuPlugin:\n *\n * A plugin which is used by fwupd to enumerate and update devices.\n *\n * See also: [class@FuDevice], [class@Fwupd.Plugin]\n */\n\nstatic void\nfu_plugin_finalize(GObject *object);\n\ntypedef struct {\n\tGModule *module;\n\tguint order;\n\tguint priority;\n\tgboolean done_init;\n\tGPtrArray *rules[FU_PLUGIN_RULE_LAST];\n\tGPtrArray *devices; /* (nullable) (element-type FuDevice) */\n\tGHashTable *runtime_versions;\n\tGHashTable *compile_versions;\n\tFuContext *ctx;\n\tGArray *device_gtypes; /* (nullable): of #GType */\n\tGHashTable *cache;     /* (nullable): platform_id:GObject */\n\tGRWLock cache_mutex;\n\tGHashTable *report_metadata; /* (nullable): key:value */\n\tGFileMonitor *config_monitor;\n\tFuPluginData *data;\n\tFuPluginVfuncs vfuncs;\n} FuPluginPrivate;\n\nenum {\n\tSIGNAL_DEVICE_ADDED,\n\tSIGNAL_DEVICE_REMOVED,\n\tSIGNAL_DEVICE_REGISTER,\n\tSIGNAL_RULES_CHANGED,\n\tSIGNAL_CONFIG_CHANGED,\n\tSIGNAL_CHECK_SUPPORTED,\n\tSIGNAL_LAST\n};\n\nstatic guint signals[SIGNAL_LAST] = {0};\n\nG_DEFINE_TYPE_WITH_PRIVATE(FuPlugin, fu_plugin, FWUPD_TYPE_PLUGIN)\n#define GET_PRIVATE(o) (fu_plugin_get_instance_private(o))\n\ntypedef void (*FuPluginInitVfuncsFunc)(FuPluginVfuncs *vfuncs);\ntypedef gboolean (*FuPluginDeviceFunc)(FuPlugin *self, FuDevice *device, GError **error);\ntypedef gboolean (*FuPluginDeviceProgressFunc)(FuPlugin *self,\n\t\t\t\t\t       FuDevice *device,\n\t\t\t\t\t       FuProgress *progress,\n\t\t\t\t\t       GError **error);\ntypedef gboolean (*FuPluginFlaggedDeviceFunc)(FuPlugin *self,\n\t\t\t\t\t      FuDevice *device,\n\t\t\t\t\t      FuProgress *progress,\n\t\t\t\t\t      FwupdInstallFlags flags,\n\t\t\t\t\t      GError **error);\ntypedef gboolean (*FuPluginDeviceArrayFunc)(FuPlugin *self, GPtrArray *devices, GError **error);\n\n/**\n * fu_plugin_is_open:\n * @self: a #FuPlugin\n *\n * Determines if the plugin is opened\n *\n * Returns: TRUE for opened, FALSE for not\n *\n * Since: 1.3.5\n **/\ngboolean\nfu_plugin_is_open(FuPlugin *self)\n{\n\tFuPluginPrivate *priv = GET_PRIVATE(self);\n\treturn priv->module != NULL;\n}\n\n/**\n * fu_plugin_get_name:\n * @self: a #FuPlugin\n *\n * Gets the plugin name.\n *\n * Returns: a plugin name, or %NULL for unknown.\n *\n * Since: 0.8.0\n **/\nconst gchar *\nfu_plugin_get_name(FuPlugin *self)\n{\n\tg_return_val_if_fail(FU_IS_PLUGIN(self), NULL);\n\treturn fwupd_plugin_get_name(FWUPD_PLUGIN(self));\n}\n\n/**\n * fu_plugin_set_name:\n * @self: a #FuPlugin\n * @name: a string\n *\n * Sets the plugin name.\n *\n * Since: 0.8.0\n **/\nvoid\nfu_plugin_set_name(FuPlugin *self, const gchar *name)\n{\n\tg_return_if_fail(FU_IS_PLUGIN(self));\n\tfwupd_plugin_set_name(FWUPD_PLUGIN(self), name);\n}\n\nstatic FuPluginVfuncs *\nfu_plugin_get_vfuncs(FuPlugin *self)\n{\n\tFuPluginPrivate *priv = GET_PRIVATE(self);\n\treturn &priv->vfuncs;\n}\n\n/**\n * fu_plugin_get_build_hash:\n * @self: a #FuPlugin\n *\n * Gets the build hash a plugin was generated with.\n *\n * Returns: (transfer none): a #gchar, or %NULL for unset.\n *\n * Since: 1.2.4\n **/\nconst gchar *\nfu_plugin_get_build_hash(FuPlugin *self)\n{\n\tFuPluginVfuncs *vfuncs = fu_plugin_get_vfuncs(self);\n\tg_return_val_if_fail(FU_IS_PLUGIN(self), NULL);\n\treturn vfuncs->build_hash;\n}\n\n/**\n * fu_plugin_cache_lookup:\n * @self: a #FuPlugin\n * @id: the key\n *\n * Finds an object in the per-plugin cache.\n *\n * Returns: (transfer none): a #GObject, or %NULL for unfound.\n *\n * Since: 0.8.0\n **/\ngpointer\nfu_plugin_cache_lookup(FuPlugin *self, const gchar *id)\n{\n\tFuPluginPrivate *priv = GET_PRIVATE(self);\n\tg_autoptr(GRWLockReaderLocker) locker = g_rw_lock_reader_locker_new(&priv->cache_mutex);\n\tg_return_val_if_fail(FU_IS_PLUGIN(self), NULL);\n\tg_return_val_if_fail(id != NULL, NULL);\n\tg_return_val_if_fail(locker != NULL, NULL);\n\tif (priv->cache == NULL)\n\t\treturn NULL;\n\treturn g_hash_table_lookup(priv->cache, id);\n}\n\n/**\n * fu_plugin_cache_add:\n * @self: a #FuPlugin\n * @id: the key\n * @dev: a #GObject, typically a #FuDevice\n *\n * Adds an object to the per-plugin cache.\n *\n * Since: 0.8.0\n **/\nvoid\nfu_plugin_cache_add(FuPlugin *self, const gchar *id, gpointer dev)\n{\n\tFuPluginPrivate *priv = GET_PRIVATE(self);\n\tg_autoptr(GRWLockWriterLocker) locker = g_rw_lock_writer_locker_new(&priv->cache_mutex);\n\tg_return_if_fail(FU_IS_PLUGIN(self));\n\tg_return_if_fail(id != NULL);\n\tg_return_if_fail(G_IS_OBJECT(dev));\n\tg_return_if_fail(locker != NULL);\n\tif (priv->cache == NULL) {\n\t\tpriv->cache = g_hash_table_new_full(g_str_hash,\n\t\t\t\t\t\t    g_str_equal,\n\t\t\t\t\t\t    g_free,\n\t\t\t\t\t\t    (GDestroyNotify)g_object_unref);\n\t}\n\tg_hash_table_insert(priv->cache, g_strdup(id), g_object_ref(dev));\n}\n\n/**\n * fu_plugin_cache_remove:\n * @self: a #FuPlugin\n * @id: the key\n *\n * Removes an object from the per-plugin cache.\n *\n * Since: 0.8.0\n **/\nvoid\nfu_plugin_cache_remove(FuPlugin *self, const gchar *id)\n{\n\tFuPluginPrivate *priv = GET_PRIVATE(self);\n\tg_autoptr(GRWLockWriterLocker) locker = g_rw_lock_writer_locker_new(&priv->cache_mutex);\n\tg_return_if_fail(FU_IS_PLUGIN(self));\n\tg_return_if_fail(id != NULL);\n\tg_return_if_fail(locker != NULL);\n\tif (priv->cache == NULL)\n\t\treturn;\n\tg_hash_table_remove(priv->cache, id);\n}\n\n/**\n * fu_plugin_get_data:\n * @self: a #FuPlugin\n *\n * Gets the per-plugin allocated private data. This will return %NULL unless\n * fu_plugin_alloc_data() has been called by the plugin.\n *\n * Returns: (transfer none): a pointer to a structure, or %NULL for unset.\n *\n * Since: 0.8.0\n **/\nFuPluginData *\nfu_plugin_get_data(FuPlugin *self)\n{\n\tFuPluginPrivate *priv = GET_PRIVATE(self);\n\tg_return_val_if_fail(FU_IS_PLUGIN(self), NULL);\n\treturn priv->data;\n}\n\n/**\n * fu_plugin_alloc_data: (skip):\n * @self: a #FuPlugin\n * @data_sz: the size to allocate\n *\n * Allocates the per-plugin allocated private data.\n *\n * Returns: (transfer full): a pointer to a structure, or %NULL for unset.\n *\n * Since: 0.8.0\n **/\nFuPluginData *\nfu_plugin_alloc_data(FuPlugin *self, gsize data_sz)\n{\n\tFuPluginPrivate *priv = GET_PRIVATE(self);\n\tg_return_val_if_fail(FU_IS_PLUGIN(self), NULL);\n\tif (priv->data != NULL) {\n\t\tg_critical(\"fu_plugin_alloc_data() already used by plugin\");\n\t\treturn priv->data;\n\t}\n\tpriv->data = g_malloc0(data_sz);\n\treturn priv->data;\n}\n\n/**\n * fu_plugin_guess_name_from_fn:\n * @filename: filename to guess\n *\n * Tries to guess the name of the plugin from a filename\n *\n * Returns: (transfer full): the guessed name of the plugin\n *\n * Since: 1.0.8\n **/\ngchar *\nfu_plugin_guess_name_from_fn(const gchar *filename)\n{\n\tconst gchar *prefix = \"libfu_plugin_\";\n\tgchar *name;\n\tgchar *str = g_strstr_len(filename, -1, prefix);\n\tif (str == NULL)\n\t\treturn NULL;\n\tname = g_strdup(str + strlen(prefix));\n\tg_strdelimit(name, \".\", '\\0');\n\treturn name;\n}\n\n/**\n * fu_plugin_open:\n * @self: a #FuPlugin\n * @filename: the shared object filename to open\n * @error: (nullable): optional return location for an error\n *\n * Opens the plugin module, and calls `->load()` on it.\n *\n * Returns: TRUE for success, FALSE for fail\n *\n * Since: 0.8.0\n **/\ngboolean\nfu_plugin_open(FuPlugin *self, const gchar *filename, GError **error)\n{\n\tFuPluginPrivate *priv = GET_PRIVATE(self);\n\tFuPluginVfuncs *vfuncs = fu_plugin_get_vfuncs(self);\n\tFuPluginInitVfuncsFunc init_vfuncs = NULL;\n\n\tg_return_val_if_fail(FU_IS_PLUGIN(self), FALSE);\n\tg_return_val_if_fail(filename != NULL, FALSE);\n\tg_return_val_if_fail(error == NULL || *error == NULL, FALSE);\n\n\tpriv->module = g_module_open(filename, 0);\n\tif (priv->module == NULL) {\n\t\tg_set_error(error,\n\t\t\t    G_IO_ERROR,\n\t\t\t    G_IO_ERROR_FAILED,\n\t\t\t    \"failed to open plugin %s: %s\",\n\t\t\t    filename,\n\t\t\t    g_module_error());\n\t\tfu_plugin_add_flag(self, FWUPD_PLUGIN_FLAG_FAILED_OPEN);\n\t\tfu_plugin_add_flag(self, FWUPD_PLUGIN_FLAG_USER_WARNING);\n\t\treturn FALSE;\n\t}\n\n\t/* call the vfunc setup */\n\tg_module_symbol(priv->module, \"fu_plugin_init_vfuncs\", (gpointer *)&init_vfuncs);\n\tif (init_vfuncs == NULL) {\n\t\tg_set_error(error,\n\t\t\t    G_IO_ERROR,\n\t\t\t    G_IO_ERROR_FAILED,\n\t\t\t    \"failed to init_vfuncs() on plugin %s\",\n\t\t\t    filename);\n\t\tfu_plugin_add_flag(self, FWUPD_PLUGIN_FLAG_FAILED_OPEN);\n\t\tfu_plugin_add_flag(self, FWUPD_PLUGIN_FLAG_USER_WARNING);\n\t\treturn FALSE;\n\t}\n\tinit_vfuncs(vfuncs);\n\n\t/* set automatically */\n\tif (fu_plugin_get_name(self) == NULL) {\n\t\tg_autofree gchar *str = fu_plugin_guess_name_from_fn(filename);\n\t\tfu_plugin_set_name(self, str);\n\t}\n\n\t/* optional */\n\tif (vfuncs->load != NULL) {\n\t\tFuContext *ctx = fu_plugin_get_context(self);\n\t\tg_debug(\"load(%s)\", filename);\n\t\tvfuncs->load(ctx);\n\t}\n\n\treturn TRUE;\n}\n\nstatic gchar *\nfu_plugin_flags_to_string(FwupdPluginFlags flags)\n{\n\tg_autoptr(GString) str = g_string_new(NULL);\n\tfor (guint i = 0; i < 64; i++) {\n\t\tFwupdPluginFlags flag = (guint64)1 << i;\n\t\tif ((flags & flag) == 0)\n\t\t\tcontinue;\n\t\tif (str->len > 0)\n\t\t\tg_string_append_c(str, ',');\n\t\tg_string_append(str, fwupd_plugin_flag_to_string(flag));\n\t}\n\tif (str->len == 0)\n\t\treturn NULL;\n\treturn g_string_free(g_steal_pointer(&str), FALSE);\n}\n\n/**\n * fu_plugin_add_string:\n * @self: a #FuPlugin\n * @idt: indent level\n * @str: a string to append to\n *\n * Add daemon-specific device metadata to an existing string.\n *\n * Since: 1.8.4\n **/\nvoid\nfu_plugin_add_string(FuPlugin *self, guint idt, GString *str)\n{\n\tFuPluginPrivate *priv = GET_PRIVATE(self);\n\tFuPluginVfuncs *vfuncs = fu_plugin_get_vfuncs(self);\n\tconst gchar *name = fwupd_plugin_get_name(FWUPD_PLUGIN(self));\n\tg_autofree gchar *flags = NULL;\n\n\tg_return_if_fail(FU_IS_PLUGIN(self));\n\tg_return_if_fail(str != NULL);\n\n\t/* attributes */\n\tfu_string_append(str, idt, G_OBJECT_TYPE_NAME(self), \"\");\n\tif (name != NULL)\n\t\tfu_string_append(str, idt + 1, \"Name\", name);\n\tflags = fu_plugin_flags_to_string(fwupd_plugin_get_flags(FWUPD_PLUGIN(self)));\n\tif (flags != NULL)\n\t\tfu_string_append(str, idt + 1, \"Flags\", flags);\n\tif (priv->order != 0)\n\t\tfu_string_append_ku(str, idt + 1, \"Order\", priv->order);\n\tif (priv->priority != 0)\n\t\tfu_string_append_ku(str, idt + 1, \"Priority\", priv->priority);\n\n\t/* optional */\n\tif (vfuncs->to_string != NULL)\n\t\tvfuncs->to_string(self, idt + 1, str);\n}\n\n/**\n * fu_plugin_to_string:\n * @self: a #FuPlugin\n *\n * This allows us to easily print the plugin metadata.\n *\n * Returns: a string value, or %NULL for invalid.\n *\n * Since: 1.8.4\n **/\ngchar *\nfu_plugin_to_string(FuPlugin *self)\n{\n\tg_autoptr(GString) str = g_string_new(NULL);\n\tg_return_val_if_fail(FU_IS_PLUGIN(self), NULL);\n\tfu_plugin_add_string(self, 0, str);\n\treturn g_string_free(g_steal_pointer(&str), FALSE);\n}\n\n/* order of usefulness to the user */\nstatic const gchar *\nfu_plugin_build_device_update_error(FuPlugin *self)\n{\n\tif (fu_plugin_has_flag(self, FWUPD_PLUGIN_FLAG_NO_HARDWARE))\n\t\treturn \"Not updatable as required hardware was not found\";\n\tif (fu_plugin_has_flag(self, FWUPD_PLUGIN_FLAG_LEGACY_BIOS))\n\t\treturn \"Not updatable in legacy BIOS mode\";\n\tif (fu_plugin_has_flag(self, FWUPD_PLUGIN_FLAG_CAPSULES_UNSUPPORTED))\n\t\treturn \"Not updatable as UEFI capsule updates not enabled in firmware setup\";\n\tif (fu_plugin_has_flag(self, FWUPD_PLUGIN_FLAG_UNLOCK_REQUIRED))\n\t\treturn \"Not updatable as requires unlock\";\n\tif (fu_plugin_has_flag(self, FWUPD_PLUGIN_FLAG_AUTH_REQUIRED))\n\t\treturn \"Not updatable as requires authentication\";\n\tif (fu_plugin_has_flag(self, FWUPD_PLUGIN_FLAG_EFIVAR_NOT_MOUNTED))\n\t\treturn \"Not updatable as efivarfs was not found\";\n\tif (fu_plugin_has_flag(self, FWUPD_PLUGIN_FLAG_ESP_NOT_FOUND))\n\t\treturn \"Not updatable as UEFI ESP partition not detected\";\n\tif (fu_plugin_has_flag(self, FWUPD_PLUGIN_FLAG_DISABLED))\n\t\treturn \"Not updatable as plugin was disabled\";\n\treturn NULL;\n}\n\nstatic void\nfu_plugin_ensure_devices(FuPlugin *self)\n{\n\tFuPluginPrivate *priv = GET_PRIVATE(self);\n\tif (priv->devices != NULL)\n\t\treturn;\n\tpriv->devices = g_ptr_array_new_with_free_func((GDestroyNotify)g_object_unref);\n}\n\nstatic void\nfu_plugin_device_child_added_cb(FuDevice *device, FuDevice *child, FuPlugin *self)\n{\n\tg_debug(\"child %s added to parent %s after setup, adding to daemon\",\n\t\tfu_device_get_id(child),\n\t\tfu_device_get_id(device));\n\tfu_plugin_device_add(self, child);\n}\n\nstatic void\nfu_plugin_device_child_removed_cb(FuDevice *device, FuDevice *child, FuPlugin *self)\n{\n\tg_debug(\"child %s removed from parent %s after setup, removing from daemon\",\n\t\tfu_device_get_id(child),\n\t\tfu_device_get_id(device));\n\tfu_plugin_device_remove(self, child);\n}\n\nstatic void\nfu_plugin_config_monitor_changed_cb(GFileMonitor *monitor,\n\t\t\t\t    GFile *file,\n\t\t\t\t    GFile *other_file,\n\t\t\t\t    GFileMonitorEvent event_type,\n\t\t\t\t    gpointer user_data)\n{\n\tFuPlugin *self = FU_PLUGIN(user_data);\n\tg_autofree gchar *fn = g_file_get_path(file);\n\tg_debug(\"%s changed, sending signal\", fn);\n\tg_signal_emit(self, signals[SIGNAL_CONFIG_CHANGED], 0);\n}\n\nstatic gchar *\nfu_plugin_get_config_filename(FuPlugin *self)\n{\n\tg_autofree gchar *conf_dir = fu_path_from_kind(FU_PATH_KIND_SYSCONFDIR_PKG);\n\tg_autofree gchar *conf_file = g_strdup_printf(\"%s.conf\", fu_plugin_get_name(self));\n\treturn g_build_filename(conf_dir, conf_file, NULL);\n}\n\n/**\n * fu_plugin_device_add:\n * @self: a #FuPlugin\n * @device: a device\n *\n * Asks the daemon to add a device to the exported list. If this device ID\n * has already been added by a different plugin then this request will be\n * ignored.\n *\n * Since: 0.8.0\n **/\nvoid\nfu_plugin_device_add(FuPlugin *self, FuDevice *device)\n{\n\tFuPluginPrivate *priv = GET_PRIVATE(self);\n\tGPtrArray *children;\n\tg_autoptr(GError) error = NULL;\n\n\tg_return_if_fail(FU_IS_PLUGIN(self));\n\tg_return_if_fail(FU_IS_DEVICE(device));\n\n\t/* ensure the device ID is set from the physical and logical IDs */\n\tif (!fu_device_ensure_id(device, &error)) {\n\t\tg_warning(\"ignoring add: %s\", error->message);\n\t\treturn;\n\t}\n\n\t/* add to array */\n\tfu_plugin_ensure_devices(self);\n\tg_ptr_array_add(priv->devices, g_object_ref(device));\n\n\t/* proxy to device where required */\n\tif (fu_plugin_has_flag(self, FWUPD_PLUGIN_FLAG_CLEAR_UPDATABLE)) {\n\t\tif (fu_plugin_has_flag(self, FWUPD_PLUGIN_FLAG_USER_WARNING)) {\n\t\t\tfu_device_inhibit(device,\n\t\t\t\t\t  \"clear-updatable\",\n\t\t\t\t\t  fu_plugin_build_device_update_error(self));\n\t\t} else {\n\t\t\tfu_device_inhibit(device,\n\t\t\t\t\t  \"clear-updatable\",\n\t\t\t\t\t  \"Plugin disallowed updates with no user warning\");\n\t\t}\n\t}\n\n\tg_debug(\"emit added from %s: %s\", fu_plugin_get_name(self), fu_device_get_id(device));\n\tfu_device_set_created(device, (guint64)g_get_real_time() / G_USEC_PER_SEC);\n\tfu_device_set_plugin(device, fu_plugin_get_name(self));\n\tg_signal_emit(self, signals[SIGNAL_DEVICE_ADDED], 0, device);\n\n\t/* add children if they have not already been added */\n\tchildren = fu_device_get_children(device);\n\tfor (guint i = 0; i < children->len; i++) {\n\t\tFuDevice *child = g_ptr_array_index(children, i);\n\t\tif (fu_device_get_created(child) == 0)\n\t\t\tfu_plugin_device_add(self, child);\n\t}\n\n\t/* watch to see if children are added or removed at runtime */\n\tg_signal_connect(FU_DEVICE(device),\n\t\t\t \"child-added\",\n\t\t\t G_CALLBACK(fu_plugin_device_child_added_cb),\n\t\t\t self);\n\tg_signal_connect(FU_DEVICE(device),\n\t\t\t \"child-removed\",\n\t\t\t G_CALLBACK(fu_plugin_device_child_removed_cb),\n\t\t\t self);\n}\n\n/**\n * fu_plugin_get_devices:\n * @self: a #FuPlugin\n *\n * Returns all devices added by the plugin using [method@FuPlugin.device_add] and\n * not yet removed with [method@FuPlugin.device_remove].\n *\n * Returns: (transfer none) (element-type FuDevice): devices\n *\n * Since: 1.5.6\n **/\nGPtrArray *\nfu_plugin_get_devices(FuPlugin *self)\n{\n\tFuPluginPrivate *priv = GET_PRIVATE(self);\n\tg_return_val_if_fail(FU_IS_PLUGIN(self), NULL);\n\tfu_plugin_ensure_devices(self);\n\treturn priv->devices;\n}\n\n/**\n * fu_plugin_device_register:\n * @self: a #FuPlugin\n * @device: a device\n *\n * Registers the device with other plugins so they can set metadata.\n *\n * Plugins do not have to call this manually as this is done automatically\n * when using [method@FuPlugin.device_add]. They may wish to use this manually\n * if for instance the coldplug should be ignored based on the metadata\n * set from other plugins.\n *\n * Since: 0.9.7\n **/\nvoid\nfu_plugin_device_register(FuPlugin *self, FuDevice *device)\n{\n\tg_autoptr(GError) error = NULL;\n\n\tg_return_if_fail(FU_IS_PLUGIN(self));\n\tg_return_if_fail(FU_IS_DEVICE(device));\n\n\t/* ensure the device ID is set from the physical and logical IDs */\n\tif (!fu_device_ensure_id(device, &error)) {\n\t\tg_warning(\"ignoring registration: %s\", error->message);\n\t\treturn;\n\t}\n\n\tg_debug(\"emit device-register from %s: %s\",\n\t\tfu_plugin_get_name(self),\n\t\tfu_device_get_id(device));\n\tg_signal_emit(self, signals[SIGNAL_DEVICE_REGISTER], 0, device);\n}\n\n/**\n * fu_plugin_device_remove:\n * @self: a #FuPlugin\n * @device: a device\n *\n * Asks the daemon to remove a device from the exported list.\n *\n * Since: 0.8.0\n **/\nvoid\nfu_plugin_device_remove(FuPlugin *self, FuDevice *device)\n{\n\tFuPluginPrivate *priv = GET_PRIVATE(self);\n\n\tg_return_if_fail(FU_IS_PLUGIN(self));\n\tg_return_if_fail(FU_IS_DEVICE(device));\n\n\t/* remove from array */\n\tif (priv->devices != NULL)\n\t\tg_ptr_array_remove(priv->devices, device);\n\n\tg_debug(\"emit removed from %s: %s\", fu_plugin_get_name(self), fu_device_get_id(device));\n\tg_signal_emit(self, signals[SIGNAL_DEVICE_REMOVED], 0, device);\n}\n\n/**\n * fu_plugin_check_supported:\n * @self: a #FuPlugin\n * @guid: a hardware ID GUID, e.g. `6de5d951-d755-576b-bd09-c5cf66b27234`\n *\n * Checks to see if a specific device GUID is supported, i.e. available in the\n * AppStream metadata.\n *\n * Returns: %TRUE if the device is supported.\n *\n * Since: 1.0.0\n **/\nstatic gboolean\nfu_plugin_check_supported(FuPlugin *self, const gchar *guid)\n{\n\tgboolean retval = FALSE;\n\tg_signal_emit(self, signals[SIGNAL_CHECK_SUPPORTED], 0, guid, &retval);\n\treturn retval;\n}\n\n/**\n * fu_plugin_get_context:\n * @self: a #FuPlugin\n *\n * Gets the context for a plugin.\n *\n * Returns: (transfer none): a #FuContext or %NULL if not set\n *\n * Since: 1.6.0\n **/\nFuContext *\nfu_plugin_get_context(FuPlugin *self)\n{\n\tFuPluginPrivate *priv = GET_PRIVATE(self);\n\treturn priv->ctx;\n}\n\nstatic gboolean\nfu_plugin_device_attach(FuPlugin *self, FuDevice *device, FuProgress *progress, GError **error)\n{\n\tFuDevice *proxy = fu_device_get_proxy_with_fallback(device);\n\tFuDeviceClass *proxy_klass = FU_DEVICE_GET_CLASS(proxy);\n\tg_autoptr(FuDeviceLocker) locker = NULL;\n\tif (proxy_klass->attach == NULL)\n\t\treturn TRUE;\n\tlocker = fu_device_locker_new(proxy, error);\n\tif (locker == NULL)\n\t\treturn FALSE;\n\treturn fu_device_attach_full(device, progress, error);\n}\n\nstatic gboolean\nfu_plugin_device_detach(FuPlugin *self, FuDevice *device, FuProgress *progress, GError **error)\n{\n\tFuDevice *proxy = fu_device_get_proxy_with_fallback(device);\n\tFuDeviceClass *proxy_klass = FU_DEVICE_GET_CLASS(proxy);\n\tg_autoptr(FuDeviceLocker) locker = NULL;\n\tif (proxy_klass->detach == NULL)\n\t\treturn TRUE;\n\tlocker = fu_device_locker_new(proxy, error);\n\tif (locker == NULL)\n\t\treturn FALSE;\n\treturn fu_device_detach_full(device, progress, error);\n}\n\nstatic gboolean\nfu_plugin_device_activate(FuPlugin *self, FuDevice *device, FuProgress *progress, GError **error)\n{\n\tFuDevice *proxy = fu_device_get_proxy_with_fallback(device);\n\tFuDeviceClass *proxy_klass = FU_DEVICE_GET_CLASS(proxy);\n\tg_autoptr(FuDeviceLocker) locker = NULL;\n\tif (proxy_klass->activate == NULL)\n\t\treturn TRUE;\n\tlocker = fu_device_locker_new(proxy, error);\n\tif (locker == NULL)\n\t\treturn FALSE;\n\treturn fu_device_activate(device, progress, error);\n}\n\nstatic gboolean\nfu_plugin_device_write_firmware(FuPlugin *self,\n\t\t\t\tFuDevice *device,\n\t\t\t\tGBytes *fw,\n\t\t\t\tFuProgress *progress,\n\t\t\t\tFwupdInstallFlags flags,\n\t\t\t\tGError **error)\n{\n\tFuDevice *proxy = fu_device_get_proxy_with_fallback(device);\n\tg_autoptr(FuDeviceLocker) locker = NULL;\n\tlocker = fu_device_locker_new(proxy, error);\n\tif (locker == NULL)\n\t\treturn FALSE;\n\n\t/* back the old firmware up to /var/lib/fwupd */\n\tif (fu_device_has_flag(device, FWUPD_DEVICE_FLAG_BACKUP_BEFORE_INSTALL)) {\n\t\tg_autoptr(GBytes) fw_old = NULL;\n\t\tg_autofree gchar *path = NULL;\n\t\tg_autofree gchar *fn = NULL;\n\t\tg_autofree gchar *localstatedir = NULL;\n\n\t\t/* progress */\n\t\tfu_progress_set_id(progress, G_STRLOC);\n\t\tfu_progress_add_flag(progress, FU_PROGRESS_FLAG_NO_PROFILE);\n\t\tfu_progress_add_step(progress, FWUPD_STATUS_DEVICE_READ, 25, NULL);\n\t\tfu_progress_add_step(progress, FWUPD_STATUS_DEVICE_WRITE, 75, NULL);\n\n\t\tfw_old = fu_device_dump_firmware(device, fu_progress_get_child(progress), error);\n\t\tif (fw_old == NULL) {\n\t\t\tg_prefix_error(error, \"failed to backup old firmware: \");\n\t\t\treturn FALSE;\n\t\t}\n\t\tlocalstatedir = fu_path_from_kind(FU_PATH_KIND_LOCALSTATEDIR_PKG);\n\t\tfn = g_strdup_printf(\"%s.bin\", fu_device_get_version(device));\n\t\tpath = g_build_filename(\n\t\t    localstatedir,\n\t\t    \"backup\",\n\t\t    fu_device_get_id(device),\n\t\t    fu_device_get_serial(device) != NULL ? fu_device_get_serial(device) : \"default\",\n\t\t    fn,\n\t\t    NULL);\n\t\tfu_progress_step_done(progress);\n\t\tif (!fu_bytes_set_contents(path, fw_old, error))\n\t\t\treturn FALSE;\n\t\tif (!fu_device_write_firmware(device,\n\t\t\t\t\t      fw,\n\t\t\t\t\t      fu_progress_get_child(progress),\n\t\t\t\t\t      flags,\n\t\t\t\t\t      error))\n\t\t\treturn FALSE;\n\t\tfu_progress_step_done(progress);\n\t\treturn TRUE;\n\t}\n\n\treturn fu_device_write_firmware(device, fw, progress, flags, error);\n}\n\nstatic gboolean\nfu_plugin_device_get_results(FuPlugin *self, FuDevice *device, GError **error)\n{\n\tg_autoptr(FuDeviceLocker) locker = NULL;\n\tg_autoptr(GError) error_local = NULL;\n\tlocker = fu_device_locker_new(device, error);\n\tif (locker == NULL)\n\t\treturn FALSE;\n\tif (!fu_device_get_results(device, &error_local)) {\n\t\tif (g_error_matches(error_local, FWUPD_ERROR, FWUPD_ERROR_NOT_SUPPORTED))\n\t\t\treturn TRUE;\n\t\tg_propagate_error(error, g_steal_pointer(&error_local));\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\nstatic gboolean\nfu_plugin_device_read_firmware(FuPlugin *self,\n\t\t\t       FuDevice *device,\n\t\t\t       FuProgress *progress,\n\t\t\t       GError **error)\n{\n\tFuDevice *proxy = fu_device_get_proxy_with_fallback(device);\n\tg_autoptr(FuDeviceLocker) locker = NULL;\n\tg_autoptr(FuFirmware) firmware = NULL;\n\tg_autoptr(GBytes) fw = NULL;\n\tGChecksumType checksum_types[] = {G_CHECKSUM_SHA1, G_CHECKSUM_SHA256, 0};\n\tlocker = fu_device_locker_new(proxy, error);\n\tif (locker == NULL)\n\t\treturn FALSE;\n\tif (!fu_device_detach_full(device, progress, error))\n\t\treturn FALSE;\n\tfirmware = fu_device_read_firmware(device, progress, error);\n\tif (firmware == NULL) {\n\t\tg_autoptr(GError) error_local = NULL;\n\t\tif (!fu_device_attach_full(device, progress, &error_local))\n\t\t\tg_debug(\"ignoring attach failure: %s\", error_local->message);\n\t\tg_prefix_error(error, \"failed to read firmware: \");\n\t\treturn FALSE;\n\t}\n\tfw = fu_firmware_write(firmware, error);\n\tif (fw == NULL) {\n\t\tg_autoptr(GError) error_local = NULL;\n\t\tif (!fu_device_attach_full(device, progress, &error_local))\n\t\t\tg_debug(\"ignoring attach failure: %s\", error_local->message);\n\t\tg_prefix_error(error, \"failed to write firmware: \");\n\t\treturn FALSE;\n\t}\n\tfor (guint i = 0; checksum_types[i] != 0; i++) {\n\t\tg_autofree gchar *hash = NULL;\n\t\thash = g_compute_checksum_for_bytes(checksum_types[i], fw);\n\t\tfu_device_add_checksum(device, hash);\n\t}\n\treturn fu_device_attach_full(device, progress, error);\n}\n\n/**\n * fu_plugin_runner_startup:\n * @self: a #FuPlugin\n * @error: (nullable): optional return location for an error\n *\n * Runs the startup routine for the plugin\n *\n * Returns: #TRUE for success, #FALSE for failure\n *\n * Since: 0.8.0\n **/\ngboolean\nfu_plugin_runner_startup(FuPlugin *self, FuProgress *progress, GError **error)\n{\n\tFuPluginPrivate *priv = GET_PRIVATE(self);\n\tFuPluginVfuncs *vfuncs = fu_plugin_get_vfuncs(self);\n\tg_autofree gchar *config_filename = fu_plugin_get_config_filename(self);\n\tg_autoptr(GError) error_local = NULL;\n\tg_autoptr(GFile) file = g_file_new_for_path(config_filename);\n\n\tg_return_val_if_fail(FU_IS_PLUGIN(self), FALSE);\n\n\t/* progress */\n\tfu_progress_set_name(progress, fu_plugin_get_name(self));\n\n\t/* be helpful for unit tests */\n\tfu_plugin_runner_init(self);\n\n\t/* not enabled */\n\tif (fu_plugin_has_flag(self, FWUPD_PLUGIN_FLAG_DISABLED))\n\t\treturn TRUE;\n\n\t/* optional */\n\tif (vfuncs->startup == NULL)\n\t\treturn TRUE;\n\tg_debug(\"startup(%s)\", fu_plugin_get_name(self));\n\tif (!vfuncs->startup(self, progress, &error_local)) {\n\t\tif (error_local == NULL) {\n\t\t\tg_critical(\"unset plugin error in startup(%s)\", fu_plugin_get_name(self));\n\t\t\tg_set_error_literal(&error_local,\n\t\t\t\t\t    FWUPD_ERROR,\n\t\t\t\t\t    FWUPD_ERROR_INTERNAL,\n\t\t\t\t\t    \"unspecified error\");\n\t\t}\n\t\tg_propagate_prefixed_error(error,\n\t\t\t\t\t   g_steal_pointer(&error_local),\n\t\t\t\t\t   \"failed to startup using %s: \",\n\t\t\t\t\t   fu_plugin_get_name(self));\n\t\treturn FALSE;\n\t}\n\n\t/* create a monitor on the config file */\n\tpriv->config_monitor = g_file_monitor_file(file, G_FILE_MONITOR_NONE, NULL, error);\n\tif (priv->config_monitor == NULL)\n\t\treturn FALSE;\n\tg_signal_connect(G_FILE_MONITOR(priv->config_monitor),\n\t\t\t \"changed\",\n\t\t\t G_CALLBACK(fu_plugin_config_monitor_changed_cb),\n\t\t\t self);\n\n\t/* success */\n\treturn TRUE;\n}\n\n/**\n * fu_plugin_runner_init:\n * @self: a #FuPlugin\n *\n * Runs the init routine for the plugin, if enabled.\n *\n * Since: 1.8.1\n **/\nvoid\nfu_plugin_runner_init(FuPlugin *self)\n{\n\tFuPluginVfuncs *vfuncs = fu_plugin_get_vfuncs(self);\n\tFuPluginPrivate *priv = GET_PRIVATE(self);\n\n\tg_return_if_fail(FU_IS_PLUGIN(self));\n\n\t/* already done */\n\tif (priv->done_init)\n\t\treturn;\n\n\t/* not enabled */\n\tif (fu_plugin_has_flag(self, FWUPD_PLUGIN_FLAG_DISABLED))\n\t\treturn;\n\n\t/* optional */\n\tif (vfuncs->init != NULL) {\n\t\tg_debug(\"init(%s)\", fu_plugin_get_name(self));\n\t\tvfuncs->init(self);\n\t\tpriv->done_init = TRUE;\n\t}\n}\n\nstatic gboolean\nfu_plugin_runner_device_generic(FuPlugin *self,\n\t\t\t\tFuDevice *device,\n\t\t\t\tconst gchar *symbol_name,\n\t\t\t\tFuPluginDeviceFunc device_func,\n\t\t\t\tGError **error)\n{\n\tg_autoptr(GError) error_local = NULL;\n\n\t/* not enabled */\n\tif (fu_plugin_has_flag(self, FWUPD_PLUGIN_FLAG_DISABLED))\n\t\treturn TRUE;\n\n\t/* optional */\n\tif (device_func == NULL)\n\t\treturn TRUE;\n\tg_debug(\"%s(%s)\", symbol_name + 10, fu_plugin_get_name(self));\n\tif (!device_func(self, device, &error_local)) {\n\t\tif (error_local == NULL) {\n\t\t\tg_critical(\"unset plugin error in %s(%s)\",\n\t\t\t\t   fu_plugin_get_name(self),\n\t\t\t\t   symbol_name + 10);\n\t\t\tg_set_error_literal(&error_local,\n\t\t\t\t\t    FWUPD_ERROR,\n\t\t\t\t\t    FWUPD_ERROR_INTERNAL,\n\t\t\t\t\t    \"unspecified error\");\n\t\t}\n\t\tg_propagate_prefixed_error(error,\n\t\t\t\t\t   g_steal_pointer(&error_local),\n\t\t\t\t\t   \"failed to %s using %s: \",\n\t\t\t\t\t   symbol_name + 10,\n\t\t\t\t\t   fu_plugin_get_name(self));\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\nstatic gboolean\nfu_plugin_runner_device_generic_progress(FuPlugin *self,\n\t\t\t\t\t FuDevice *device,\n\t\t\t\t\t FuProgress *progress,\n\t\t\t\t\t const gchar *symbol_name,\n\t\t\t\t\t FuPluginDeviceProgressFunc device_func,\n\t\t\t\t\t GError **error)\n{\n\tg_autoptr(GError) error_local = NULL;\n\n\t/* not enabled */\n\tif (fu_plugin_has_flag(self, FWUPD_PLUGIN_FLAG_DISABLED))\n\t\treturn TRUE;\n\n\t/* optional */\n\tif (device_func == NULL)\n\t\treturn TRUE;\n\tg_debug(\"%s(%s)\", symbol_name + 10, fu_plugin_get_name(self));\n\tif (!device_func(self, device, progress, &error_local)) {\n\t\tif (error_local == NULL) {\n\t\t\tg_critical(\"unset plugin error in %s(%s)\",\n\t\t\t\t   fu_plugin_get_name(self),\n\t\t\t\t   symbol_name + 10);\n\t\t\tg_set_error_literal(&error_local,\n\t\t\t\t\t    FWUPD_ERROR,\n\t\t\t\t\t    FWUPD_ERROR_INTERNAL,\n\t\t\t\t\t    \"unspecified error\");\n\t\t}\n\t\tg_propagate_prefixed_error(error,\n\t\t\t\t\t   g_steal_pointer(&error_local),\n\t\t\t\t\t   \"failed to %s using %s: \",\n\t\t\t\t\t   symbol_name + 10,\n\t\t\t\t\t   fu_plugin_get_name(self));\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\nstatic gboolean\nfu_plugin_runner_flagged_device_generic(FuPlugin *self,\n\t\t\t\t\tFuDevice *device,\n\t\t\t\t\tFuProgress *progress,\n\t\t\t\t\tFwupdInstallFlags flags,\n\t\t\t\t\tconst gchar *symbol_name,\n\t\t\t\t\tFuPluginFlaggedDeviceFunc func,\n\t\t\t\t\tGError **error)\n{\n\tg_autoptr(GError) error_local = NULL;\n\n\t/* not enabled */\n\tif (fu_plugin_has_flag(self, FWUPD_PLUGIN_FLAG_DISABLED))\n\t\treturn TRUE;\n\n\t/* optional */\n\tif (func == NULL)\n\t\treturn TRUE;\n\tg_debug(\"%s(%s)\", symbol_name + 10, fu_plugin_get_name(self));\n\tif (!func(self, device, progress, flags, &error_local)) {\n\t\tif (error_local == NULL) {\n\t\t\tg_critical(\"unset plugin error in %s(%s)\",\n\t\t\t\t   fu_plugin_get_name(self),\n\t\t\t\t   symbol_name + 10);\n\t\t\tg_set_error_literal(&error_local,\n\t\t\t\t\t    FWUPD_ERROR,\n\t\t\t\t\t    FWUPD_ERROR_INTERNAL,\n\t\t\t\t\t    \"unspecified error\");\n\t\t}\n\t\tg_propagate_prefixed_error(error,\n\t\t\t\t\t   g_steal_pointer(&error_local),\n\t\t\t\t\t   \"failed to %s using %s: \",\n\t\t\t\t\t   symbol_name + 10,\n\t\t\t\t\t   fu_plugin_get_name(self));\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\nstatic gboolean\nfu_plugin_runner_device_array_generic(FuPlugin *self,\n\t\t\t\t      GPtrArray *devices,\n\t\t\t\t      const gchar *symbol_name,\n\t\t\t\t      FuPluginDeviceArrayFunc func,\n\t\t\t\t      GError **error)\n{\n\tg_autoptr(GError) error_local = NULL;\n\n\t/* not enabled */\n\tif (fu_plugin_has_flag(self, FWUPD_PLUGIN_FLAG_DISABLED))\n\t\treturn TRUE;\n\n\t/* optional */\n\tif (func == NULL)\n\t\treturn TRUE;\n\tg_debug(\"%s(%s)\", symbol_name + 10, fu_plugin_get_name(self));\n\tif (!func(self, devices, &error_local)) {\n\t\tif (error_local == NULL) {\n\t\t\tg_critical(\"unset plugin error in for %s(%s)\",\n\t\t\t\t   fu_plugin_get_name(self),\n\t\t\t\t   symbol_name + 10);\n\t\t\tg_set_error_literal(&error_local,\n\t\t\t\t\t    FWUPD_ERROR,\n\t\t\t\t\t    FWUPD_ERROR_INTERNAL,\n\t\t\t\t\t    \"unspecified error\");\n\t\t}\n\t\tg_propagate_prefixed_error(error,\n\t\t\t\t\t   g_steal_pointer(&error_local),\n\t\t\t\t\t   \"failed to %s using %s: \",\n\t\t\t\t\t   symbol_name + 10,\n\t\t\t\t\t   fu_plugin_get_name(self));\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\n/**\n * fu_plugin_runner_coldplug:\n * @self: a #FuPlugin\n * @progress: a #FuProgress\n * @error: (nullable): optional return location for an error\n *\n * Runs the coldplug routine for the plugin\n *\n * Returns: #TRUE for success, #FALSE for failure\n *\n * Since: 0.8.0\n **/\ngboolean\nfu_plugin_runner_coldplug(FuPlugin *self, FuProgress *progress, GError **error)\n{\n\tFuPluginPrivate *priv = GET_PRIVATE(self);\n\tFuPluginVfuncs *vfuncs = fu_plugin_get_vfuncs(self);\n\tg_autoptr(GError) error_local = NULL;\n\n\tg_return_val_if_fail(FU_IS_PLUGIN(self), FALSE);\n\n\t/* progress */\n\tfu_progress_set_name(progress, fu_plugin_get_name(self));\n\n\t/* not enabled */\n\tif (fu_plugin_has_flag(self, FWUPD_PLUGIN_FLAG_DISABLED))\n\t\treturn TRUE;\n\n\t/* no HwId */\n\tif (fu_plugin_has_flag(self, FWUPD_PLUGIN_FLAG_REQUIRE_HWID))\n\t\treturn TRUE;\n\n\t/* optional */\n\tif (vfuncs->coldplug == NULL)\n\t\treturn TRUE;\n\tg_debug(\"coldplug(%s)\", fu_plugin_get_name(self));\n\tif (!vfuncs->coldplug(self, progress, &error_local)) {\n\t\tif (error_local == NULL) {\n\t\t\tg_critical(\"unset plugin error in coldplug(%s)\", fu_plugin_get_name(self));\n\t\t\tg_set_error_literal(&error_local,\n\t\t\t\t\t    FWUPD_ERROR,\n\t\t\t\t\t    FWUPD_ERROR_INTERNAL,\n\t\t\t\t\t    \"unspecified error\");\n\t\t}\n\t\t/* coldplug failed, but we might have already added devices to the daemon... */\n\t\tif (priv->devices != NULL) {\n\t\t\tfor (guint i = 0; i < priv->devices->len; i++) {\n\t\t\t\tFuDevice *device = g_ptr_array_index(priv->devices, i);\n\t\t\t\tg_warning(\"removing device %s due to failed coldplug\",\n\t\t\t\t\t  fu_device_get_id(device));\n\t\t\t\tfu_plugin_device_remove(self, device);\n\t\t\t}\n\t\t}\n\t\tg_propagate_prefixed_error(error,\n\t\t\t\t\t   g_steal_pointer(&error_local),\n\t\t\t\t\t   \"failed to coldplug using %s: \",\n\t\t\t\t\t   fu_plugin_get_name(self));\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\n/**\n * fu_plugin_runner_composite_prepare:\n * @self: a #FuPlugin\n * @devices: (element-type FuDevice): an array of devices\n * @error: (nullable): optional return location for an error\n *\n * Runs the composite_prepare routine for the plugin\n *\n * Returns: #TRUE for success, #FALSE for failure\n *\n * Since: 1.0.9\n **/\ngboolean\nfu_plugin_runner_composite_prepare(FuPlugin *self, GPtrArray *devices, GError **error)\n{\n\tFuPluginVfuncs *vfuncs = fu_plugin_get_vfuncs(self);\n\treturn fu_plugin_runner_device_array_generic(self,\n\t\t\t\t\t\t     devices,\n\t\t\t\t\t\t     \"fu_plugin_composite_prepare\",\n\t\t\t\t\t\t     vfuncs->composite_prepare,\n\t\t\t\t\t\t     error);\n}\n\n/**\n * fu_plugin_runner_composite_cleanup:\n * @self: a #FuPlugin\n * @devices: (element-type FuDevice): an array of devices\n * @error: (nullable): optional return location for an error\n *\n * Runs the composite_cleanup routine for the plugin\n *\n * Returns: #TRUE for success, #FALSE for failure\n *\n * Since: 1.0.9\n **/\ngboolean\nfu_plugin_runner_composite_cleanup(FuPlugin *self, GPtrArray *devices, GError **error)\n{\n\tFuPluginVfuncs *vfuncs = fu_plugin_get_vfuncs(self);\n\treturn fu_plugin_runner_device_array_generic(self,\n\t\t\t\t\t\t     devices,\n\t\t\t\t\t\t     \"fu_plugin_composite_cleanup\",\n\t\t\t\t\t\t     vfuncs->composite_cleanup,\n\t\t\t\t\t\t     error);\n}\n\n/**\n * fu_plugin_runner_prepare:\n * @self: a #FuPlugin\n * @device: a device\n * @progress: a #FuProgress\n * @flags: install flags\n * @error: (nullable): optional return location for an error\n *\n * Runs the update_prepare routine for the plugin\n *\n * Returns: #TRUE for success, #FALSE for failure\n *\n * Since: 1.7.0\n **/\ngboolean\nfu_plugin_runner_prepare(FuPlugin *self,\n\t\t\t FuDevice *device,\n\t\t\t FuProgress *progress,\n\t\t\t FwupdInstallFlags flags,\n\t\t\t GError **error)\n{\n\tFuPluginVfuncs *vfuncs = fu_plugin_get_vfuncs(self);\n\tfu_device_add_backend_tag(device, \"prepare\");\n\treturn fu_plugin_runner_flagged_device_generic(self,\n\t\t\t\t\t\t       device,\n\t\t\t\t\t\t       progress,\n\t\t\t\t\t\t       flags,\n\t\t\t\t\t\t       \"fu_plugin_prepare\",\n\t\t\t\t\t\t       vfuncs->prepare,\n\t\t\t\t\t\t       error);\n}\n\n/**\n * fu_plugin_runner_cleanup:\n * @self: a #FuPlugin\n * @device: a device\n * @progress: a #FuProgress\n * @flags: install flags\n * @error: (nullable): optional return location for an error\n *\n * Runs the update_cleanup routine for the plugin\n *\n * Returns: #TRUE for success, #FALSE for failure\n *\n * Since: 1.7.0\n **/\ngboolean\nfu_plugin_runner_cleanup(FuPlugin *self,\n\t\t\t FuDevice *device,\n\t\t\t FuProgress *progress,\n\t\t\t FwupdInstallFlags flags,\n\t\t\t GError **error)\n{\n\tFuPluginVfuncs *vfuncs = fu_plugin_get_vfuncs(self);\n\tfu_device_add_backend_tag(device, \"cleanup\");\n\treturn fu_plugin_runner_flagged_device_generic(self,\n\t\t\t\t\t\t       device,\n\t\t\t\t\t\t       progress,\n\t\t\t\t\t\t       flags,\n\t\t\t\t\t\t       \"fu_plugin_cleanup\",\n\t\t\t\t\t\t       vfuncs->cleanup,\n\t\t\t\t\t\t       error);\n}\n\n/**\n * fu_plugin_runner_attach:\n * @self: a #FuPlugin\n * @device: a device\n * @progress: a #FuProgress\n * @error: (nullable): optional return location for an error\n *\n * Runs the update_attach routine for the plugin\n *\n * Returns: #TRUE for success, #FALSE for failure\n *\n * Since: 1.7.0\n **/\ngboolean\nfu_plugin_runner_attach(FuPlugin *self, FuDevice *device, FuProgress *progress, GError **error)\n{\n\tFuPluginVfuncs *vfuncs = fu_plugin_get_vfuncs(self);\n\tfu_device_add_backend_tag(device, \"attach\");\n\treturn fu_plugin_runner_device_generic_progress(\n\t    self,\n\t    device,\n\t    progress,\n\t    \"fu_plugin_attach\",\n\t    vfuncs->attach != NULL ? vfuncs->attach : fu_plugin_device_attach,\n\t    error);\n}\n\n/**\n * fu_plugin_runner_detach:\n * @self: a #FuPlugin\n * @device: a device\n * @progress: a #FuProgress\n * @error: (nullable): optional return location for an error\n *\n * Runs the update_detach routine for the plugin\n *\n * Returns: #TRUE for success, #FALSE for failure\n *\n * Since: 1.7.0\n **/\ngboolean\nfu_plugin_runner_detach(FuPlugin *self, FuDevice *device, FuProgress *progress, GError **error)\n{\n\tFuPluginVfuncs *vfuncs = fu_plugin_get_vfuncs(self);\n\tfu_device_add_backend_tag(device, \"detach\");\n\treturn fu_plugin_runner_device_generic_progress(\n\t    self,\n\t    device,\n\t    progress,\n\t    \"fu_plugin_detach\",\n\t    vfuncs->detach != NULL ? vfuncs->detach : fu_plugin_device_detach,\n\t    error);\n}\n\n/**\n * fu_plugin_runner_reload:\n * @self: a #FuPlugin\n * @device: a device\n * @error: (nullable): optional return location for an error\n *\n * Runs reload routine for a device\n *\n * Returns: #TRUE for success, #FALSE for failure\n *\n * Since: 1.7.0\n **/\ngboolean\nfu_plugin_runner_reload(FuPlugin *self, FuDevice *device, GError **error)\n{\n\tFuDevice *proxy = fu_device_get_proxy_with_fallback(device);\n\tg_autoptr(FuDeviceLocker) locker = NULL;\n\n\t/* not enabled */\n\tif (fu_plugin_has_flag(self, FWUPD_PLUGIN_FLAG_DISABLED))\n\t\treturn TRUE;\n\n\t/* no object loaded */\n\tlocker = fu_device_locker_new(proxy, error);\n\tif (locker == NULL)\n\t\treturn FALSE;\n\tfu_device_add_backend_tag(device, \"reload\");\n\treturn fu_device_reload(device, error);\n}\n\n/**\n * fu_plugin_runner_add_security_attrs:\n * @self: a #FuPlugin\n * @attrs: a security attribute\n *\n * Runs the `add_security_attrs()` routine for the plugin\n *\n * Since: 1.5.0\n **/\nvoid\nfu_plugin_runner_add_security_attrs(FuPlugin *self, FuSecurityAttrs *attrs)\n{\n\tFuPluginVfuncs *vfuncs = fu_plugin_get_vfuncs(self);\n\n\t/* optional, but gets called even for disabled plugins */\n\tif (vfuncs->add_security_attrs == NULL)\n\t\treturn;\n\tg_debug(\"add_security_attrs(%s)\", fu_plugin_get_name(self));\n\tvfuncs->add_security_attrs(self, attrs);\n}\n\n/**\n * fu_plugin_add_device_gtype:\n * @self: a #FuPlugin\n * @device_gtype: a #GType, e.g. `FU_TYPE_DEVICE`\n *\n * Adds the device #GType which is used when creating devices.\n *\n * If this method is used then fu_plugin_backend_device_added() is not called, and\n * instead the object is created in the daemon for the plugin.\n *\n * Plugins can use this method only in fu_plugin_init()\n *\n * Since: 1.6.0\n **/\nvoid\nfu_plugin_add_device_gtype(FuPlugin *self, GType device_gtype)\n{\n\tFuPluginPrivate *priv = GET_PRIVATE(self);\n\n\t/* create as required */\n\tif (priv->device_gtypes == NULL)\n\t\tpriv->device_gtypes = g_array_new(FALSE, FALSE, sizeof(GType));\n\n\t/* ensure (to allow quirks to use it) then add */\n\tg_type_ensure(device_gtype);\n\tg_array_append_val(priv->device_gtypes, device_gtype);\n}\n\nstatic gchar *\nfu_common_string_uncamelcase(const gchar *str)\n{\n\tGString *tmp = g_string_new(NULL);\n\tfor (guint i = 0; str[i] != '\\0'; i++) {\n\t\tif (g_ascii_islower(str[i]) || g_ascii_isdigit(str[i])) {\n\t\t\tg_string_append_c(tmp, str[i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (i > 0)\n\t\t\tg_string_append_c(tmp, '-');\n\t\tg_string_append_c(tmp, g_ascii_tolower(str[i]));\n\t}\n\treturn g_string_free(tmp, FALSE);\n}\n\nstatic gboolean\nfu_plugin_check_amdgpu_dpaux(FuPlugin *self, GError **error)\n{\n#ifdef __linux__\n\tgsize bufsz = 0;\n\tg_autofree gchar *buf = NULL;\n\tg_auto(GStrv) lines = NULL;\n\n\t/* no module support in the kernel, we can't test for amdgpu module */\n\tif (!g_file_test(\"/proc/modules\", G_FILE_TEST_EXISTS))\n\t\treturn TRUE;\n\tif (!g_file_get_contents(\"/proc/modules\", &buf, &bufsz, error))\n\t\treturn FALSE;\n\tlines = g_strsplit(buf, \"\\n\", -1);\n\tfor (guint i = 0; lines[i] != NULL; i++) {\n\t\tif (g_str_has_prefix(lines[i], \"amdgpu \")) {\n\t\t\t/* released 2019! */\n\t\t\treturn fu_kernel_check_version(\"5.2.0\", error);\n\t\t}\n\t}\n#endif\n\treturn TRUE;\n}\n\n/**\n * fu_plugin_add_udev_subsystem:\n * @self: a #FuPlugin\n * @subsystem: a subsystem name, e.g. `pciport`\n *\n * Registers the udev subsystem to be watched by the daemon.\n *\n * Plugins can use this method only in fu_plugin_init()\n *\n * Since: 1.6.2\n **/\nvoid\nfu_plugin_add_udev_subsystem(FuPlugin *self, const gchar *subsystem)\n{\n\tFuPluginPrivate *priv = GET_PRIVATE(self);\n\n\t/* see https://github.com/fwupd/fwupd/issues/1121 for more details */\n\tif (g_strcmp0(subsystem, \"drm_dp_aux_dev\") == 0) {\n\t\tg_autoptr(GError) error = NULL;\n\t\tif (!fu_plugin_check_amdgpu_dpaux(self, &error)) {\n\t\t\tg_warning(\"failed to add subsystem: %s\", error->message);\n\t\t\tfu_plugin_add_flag(self, FWUPD_PLUGIN_FLAG_DISABLED);\n\t\t\tfu_plugin_add_flag(self, FWUPD_PLUGIN_FLAG_KERNEL_TOO_OLD);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* proxy */\n\tfu_context_add_udev_subsystem(priv->ctx, subsystem);\n}\n\n/**\n * fu_plugin_add_firmware_gtype:\n * @self: a #FuPlugin\n * @id: (nullable): an optional string describing the type, e.g. `ihex`\n * @gtype: a #GType e.g. `FU_TYPE_FOO_FIRMWARE`\n *\n * Adds a firmware #GType which is used when creating devices. If @id is not\n * specified then it is guessed using the #GType name.\n *\n * Plugins can use this method only in fu_plugin_init()\n *\n * Since: 1.3.3\n **/\nvoid\nfu_plugin_add_firmware_gtype(FuPlugin *self, const gchar *id, GType gtype)\n{\n\tFuPluginPrivate *priv = GET_PRIVATE(self);\n\tg_autofree gchar *id_safe = NULL;\n\tif (id != NULL) {\n\t\tid_safe = g_strdup(id);\n\t} else {\n\t\tg_autoptr(GString) str = g_string_new(g_type_name(gtype));\n\t\tif (g_str_has_prefix(str->str, \"Fu\"))\n\t\t\tg_string_erase(str, 0, 2);\n\t\tfu_string_replace(str, \"Firmware\", \"\");\n\t\tid_safe = fu_common_string_uncamelcase(str->str);\n\t}\n\tfu_context_add_firmware_gtype(priv->ctx, id_safe, gtype);\n}\n\nstatic gboolean\nfu_plugin_check_supported_device(FuPlugin *self, FuDevice *device)\n{\n\tGPtrArray *instance_ids = fu_device_get_instance_ids(device);\n\tfor (guint i = 0; i < instance_ids->len; i++) {\n\t\tconst gchar *instance_id = g_ptr_array_index(instance_ids, i);\n\t\tg_autofree gchar *guid = fwupd_guid_hash_string(instance_id);\n\t\tif (fu_plugin_check_supported(self, guid))\n\t\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}\n\nstatic gboolean\nfu_plugin_backend_device_added(FuPlugin *self, FuDevice *device, GError **error)\n{\n\tFuDevice *proxy;\n\tFuPluginPrivate *priv = GET_PRIVATE(self);\n\tGType device_gtype = fu_device_get_specialized_gtype(FU_DEVICE(device));\n\tg_autoptr(FuDevice) dev = NULL;\n\tg_autoptr(FuDeviceLocker) locker = NULL;\n\n\t/* fall back to plugin default */\n\tif (device_gtype == G_TYPE_INVALID) {\n\t\tif (priv->device_gtypes->len > 1) {\n\t\t\tg_set_error_literal(error,\n\t\t\t\t\t    FWUPD_ERROR,\n\t\t\t\t\t    FWUPD_ERROR_INTERNAL,\n\t\t\t\t\t    \"too many GTypes to choose a default\");\n\t\t\treturn FALSE;\n\t\t}\n\t\tdevice_gtype = g_array_index(priv->device_gtypes, GType, 0);\n\t}\n\n\t/* create new device and incorporate existing properties */\n\tdev = g_object_new(device_gtype, \"context\", priv->ctx, NULL);\n\tfu_device_incorporate(dev, FU_DEVICE(device));\n\tif (!fu_plugin_runner_device_created(self, dev, error))\n\t\treturn FALSE;\n\n\t/* there are a lot of different devices that match, but not all respond\n\t * well to opening -- so limit some ones with issued updates */\n\tif (fu_device_has_internal_flag(dev, FU_DEVICE_INTERNAL_FLAG_ONLY_SUPPORTED)) {\n\t\tif (!fu_device_probe(dev, error))\n\t\t\treturn FALSE;\n\t\tfu_device_convert_instance_ids(dev);\n\t\tif (!fu_plugin_check_supported_device(self, dev)) {\n\t\t\tg_autofree gchar *guids = fu_device_get_guids_as_str(dev);\n\t\t\tg_debug(\"%s has no updates, so ignoring device\", guids);\n\t\t\treturn TRUE;\n\t\t}\n\t}\n\n\t/* open and add */\n\tproxy = fu_device_get_proxy(device);\n\tif (proxy != NULL) {\n\t\tg_autoptr(FuDeviceLocker) locker_proxy = NULL;\n\t\tlocker_proxy = fu_device_locker_new(proxy, error);\n\t\tif (locker_proxy == NULL)\n\t\t\treturn FALSE;\n\t}\n\tlocker = fu_device_locker_new(dev, error);\n\tif (locker == NULL)\n\t\treturn FALSE;\n\tfu_plugin_device_add(self, dev);\n\tfu_plugin_runner_device_added(self, dev);\n\treturn TRUE;\n}\n\n/**\n * fu_plugin_runner_backend_device_added:\n * @self: a #FuPlugin\n * @device: a device\n * @error: (nullable): optional return location for an error\n *\n * Call the backend_device_added routine for the plugin\n *\n * Returns: #TRUE for success, #FALSE for failure\n *\n * Since: 1.5.6\n **/\ngboolean\nfu_plugin_runner_backend_device_added(FuPlugin *self, FuDevice *device, GError **error)\n{\n\tFuPluginPrivate *priv = GET_PRIVATE(self);\n\tFuPluginVfuncs *vfuncs = fu_plugin_get_vfuncs(self);\n\tg_autoptr(GError) error_local = NULL;\n\n\tg_return_val_if_fail(FU_IS_PLUGIN(self), FALSE);\n\tg_return_val_if_fail(FU_IS_DEVICE(device), FALSE);\n\tg_return_val_if_fail(error == NULL || *error == NULL, FALSE);\n\n\t/* not enabled */\n\tif (fu_plugin_has_flag(self, FWUPD_PLUGIN_FLAG_DISABLED))\n\t\treturn TRUE;\n\n\t/* optional */\n\tif (vfuncs->backend_device_added == NULL) {\n\t\tif (priv->device_gtypes != NULL ||\n\t\t    fu_device_get_specialized_gtype(device) != G_TYPE_INVALID) {\n\t\t\treturn fu_plugin_backend_device_added(self, device, error);\n\t\t}\n\t\tg_set_error_literal(error,\n\t\t\t\t    FWUPD_ERROR,\n\t\t\t\t    FWUPD_ERROR_INTERNAL,\n\t\t\t\t    \"No device GType set\");\n\t\treturn FALSE;\n\t}\n\tg_debug(\"backend_device_added(%s)\", fu_plugin_get_name(self));\n\tif (!vfuncs->backend_device_added(self, device, &error_local)) {\n\t\tif (error_local == NULL) {\n\t\t\tg_critical(\"unset plugin error in backend_device_added(%s)\",\n\t\t\t\t   fu_plugin_get_name(self));\n\t\t\tg_set_error_literal(&error_local,\n\t\t\t\t\t    FWUPD_ERROR,\n\t\t\t\t\t    FWUPD_ERROR_INTERNAL,\n\t\t\t\t\t    \"unspecified error\");\n\t\t}\n\t\tg_propagate_prefixed_error(error,\n\t\t\t\t\t   g_steal_pointer(&error_local),\n\t\t\t\t\t   \"failed to add device using on %s: \",\n\t\t\t\t\t   fu_plugin_get_name(self));\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\n/**\n * fu_plugin_runner_backend_device_changed:\n * @self: a #FuPlugin\n * @device: a device\n * @error: (nullable): optional return location for an error\n *\n * Call the backend_device_changed routine for the plugin\n *\n * Returns: #TRUE for success, #FALSE for failure\n *\n * Since: 1.5.6\n **/\ngboolean\nfu_plugin_runner_backend_device_changed(FuPlugin *self, FuDevice *device, GError **error)\n{\n\tFuPluginVfuncs *vfuncs = fu_plugin_get_vfuncs(self);\n\tg_autoptr(GError) error_local = NULL;\n\n\tg_return_val_if_fail(FU_IS_PLUGIN(self), FALSE);\n\tg_return_val_if_fail(FU_IS_DEVICE(device), FALSE);\n\tg_return_val_if_fail(error == NULL || *error == NULL, FALSE);\n\n\t/* not enabled */\n\tif (fu_plugin_has_flag(self, FWUPD_PLUGIN_FLAG_DISABLED))\n\t\treturn TRUE;\n\n\t/* optional */\n\tif (vfuncs->backend_device_changed == NULL)\n\t\treturn TRUE;\n\tg_debug(\"udev_device_changed(%s)\", fu_plugin_get_name(self));\n\tif (!vfuncs->backend_device_changed(self, device, &error_local)) {\n\t\tif (error_local == NULL) {\n\t\t\tg_critical(\"unset plugin error in udev_device_changed(%s)\",\n\t\t\t\t   fu_plugin_get_name(self));\n\t\t\tg_set_error_literal(&error_local,\n\t\t\t\t\t    FWUPD_ERROR,\n\t\t\t\t\t    FWUPD_ERROR_INTERNAL,\n\t\t\t\t\t    \"unspecified error\");\n\t\t}\n\t\tg_propagate_prefixed_error(error,\n\t\t\t\t\t   g_steal_pointer(&error_local),\n\t\t\t\t\t   \"failed to change device on %s: \",\n\t\t\t\t\t   fu_plugin_get_name(self));\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\n/**\n * fu_plugin_runner_device_added:\n * @self: a #FuPlugin\n * @device: a device\n *\n * Call the device_added routine for the plugin\n *\n * Since: 1.5.0\n **/\nvoid\nfu_plugin_runner_device_added(FuPlugin *self, FuDevice *device)\n{\n\tFuPluginVfuncs *vfuncs = fu_plugin_get_vfuncs(self);\n\n\t/* not enabled */\n\tif (fu_plugin_has_flag(self, FWUPD_PLUGIN_FLAG_DISABLED))\n\t\treturn;\n\n\t/* optional */\n\tif (vfuncs->device_added == NULL)\n\t\treturn;\n\tg_debug(\"fu_plugin_device_added(%s)\", fu_plugin_get_name(self));\n\tvfuncs->device_added(self, device);\n}\n\n/**\n * fu_plugin_runner_device_removed:\n * @self: a #FuPlugin\n * @device: a device\n *\n * Call the device_removed routine for the plugin\n *\n * Since: 1.1.2\n **/\nvoid\nfu_plugin_runner_device_removed(FuPlugin *self, FuDevice *device)\n{\n\tFuPluginVfuncs *vfuncs = fu_plugin_get_vfuncs(self);\n\tg_autoptr(GError) error_local = NULL;\n\n\tif (!fu_plugin_runner_device_generic(self,\n\t\t\t\t\t     device,\n\t\t\t\t\t     \"fu_plugin_backend_device_removed\",\n\t\t\t\t\t     vfuncs->backend_device_removed,\n\t\t\t\t\t     &error_local))\n\t\tg_warning(\"%s\", error_local->message);\n}\n\n/**\n * fu_plugin_runner_device_register:\n * @self: a #FuPlugin\n * @device: a device\n *\n * Call the device_registered routine for the plugin\n *\n * Since: 0.9.7\n **/\nvoid\nfu_plugin_runner_device_register(FuPlugin *self, FuDevice *device)\n{\n\tFuPluginVfuncs *vfuncs = fu_plugin_get_vfuncs(self);\n\n\t/* not enabled */\n\tif (fu_plugin_has_flag(self, FWUPD_PLUGIN_FLAG_DISABLED))\n\t\treturn;\n\n\t/* optional */\n\tif (vfuncs->device_registered != NULL) {\n\t\tg_debug(\"fu_plugin_device_registered(%s)\", fu_plugin_get_name(self));\n\t\tvfuncs->device_registered(self, device);\n\t}\n}\n\n/**\n * fu_plugin_runner_device_created:\n * @self: a #FuPlugin\n * @device: a device\n * @error: (nullable): optional return location for an error\n *\n * Call the device_created routine for the plugin\n *\n * Returns: #TRUE for success, #FALSE for failure\n *\n * Since: 1.4.0\n **/\ngboolean\nfu_plugin_runner_device_created(FuPlugin *self, FuDevice *device, GError **error)\n{\n\tFuPluginVfuncs *vfuncs = fu_plugin_get_vfuncs(self);\n\n\tg_return_val_if_fail(FU_IS_PLUGIN(self), FALSE);\n\tg_return_val_if_fail(FU_IS_DEVICE(device), FALSE);\n\tg_return_val_if_fail(error == NULL || *error == NULL, FALSE);\n\n\t/* not enabled */\n\tif (fu_plugin_has_flag(self, FWUPD_PLUGIN_FLAG_DISABLED))\n\t\treturn TRUE;\n\n\t/* optional */\n\tif (vfuncs->device_created == NULL)\n\t\treturn TRUE;\n\tg_debug(\"fu_plugin_device_created(%s)\", fu_plugin_get_name(self));\n\treturn vfuncs->device_created(self, device, error);\n}\n\n/**\n * fu_plugin_runner_verify:\n * @self: a #FuPlugin\n * @device: a device\n * @progress: a #FuProgress\n * @flags: verify flags\n * @error: (nullable): optional return location for an error\n *\n * Call into the plugin's verify routine\n *\n * Returns: #TRUE for success, #FALSE for failure\n *\n * Since: 0.8.0\n **/\ngboolean\nfu_plugin_runner_verify(FuPlugin *self,\n\t\t\tFuDevice *device,\n\t\t\tFuProgress *progress,\n\t\t\tFuPluginVerifyFlags flags,\n\t\t\tGError **error)\n{\n\tFuPluginVfuncs *vfuncs = fu_plugin_get_vfuncs(self);\n\tGPtrArray *checksums;\n\tg_autoptr(GError) error_local = NULL;\n\n\tg_return_val_if_fail(FU_IS_PLUGIN(self), FALSE);\n\tg_return_val_if_fail(FU_IS_DEVICE(device), FALSE);\n\tg_return_val_if_fail(FU_IS_PROGRESS(progress), FALSE);\n\tg_return_val_if_fail(error == NULL || *error == NULL, FALSE);\n\n\t/* not enabled */\n\tif (fu_plugin_has_flag(self, FWUPD_PLUGIN_FLAG_DISABLED))\n\t\treturn TRUE;\n\n\t/* optional */\n\tif (vfuncs->verify == NULL) {\n\t\tif (!fu_device_has_flag(device, FWUPD_DEVICE_FLAG_CAN_VERIFY)) {\n\t\t\tg_set_error(error,\n\t\t\t\t    FWUPD_ERROR,\n\t\t\t\t    FWUPD_ERROR_NOT_SUPPORTED,\n\t\t\t\t    \"device %s does not support verification\",\n\t\t\t\t    fu_device_get_id(device));\n\t\t\treturn FALSE;\n\t\t}\n\t\treturn fu_plugin_device_read_firmware(self, device, progress, error);\n\t}\n\n\t/* clear any existing verification checksums */\n\tchecksums = fu_device_get_checksums(device);\n\tg_ptr_array_set_size(checksums, 0);\n\n\t/* run additional detach */\n\tif (!fu_plugin_runner_device_generic_progress(\n\t\tself,\n\t\tdevice,\n\t\tprogress,\n\t\t\"fu_plugin_detach\",\n\t\tvfuncs->detach != NULL ? vfuncs->detach : fu_plugin_device_detach,\n\t\terror))\n\t\treturn FALSE;\n\n\t/* run vfunc */\n\tg_debug(\"verify(%s)\", fu_plugin_get_name(self));\n\tif (!vfuncs->verify(self, device, progress, flags, &error_local)) {\n\t\tg_autoptr(GError) error_attach = NULL;\n\t\tif (error_local == NULL) {\n\t\t\tg_critical(\"unset plugin error in verify(%s)\", fu_plugin_get_name(self));\n\t\t\tg_set_error_literal(&error_local,\n\t\t\t\t\t    FWUPD_ERROR,\n\t\t\t\t\t    FWUPD_ERROR_INTERNAL,\n\t\t\t\t\t    \"unspecified error\");\n\t\t}\n\t\tg_propagate_prefixed_error(error,\n\t\t\t\t\t   g_steal_pointer(&error_local),\n\t\t\t\t\t   \"failed to verify using %s: \",\n\t\t\t\t\t   fu_plugin_get_name(self));\n\t\t/* make the device \"work\" again, but don't prefix the error */\n\t\tif (!fu_plugin_runner_device_generic_progress(\n\t\t\tself,\n\t\t\tdevice,\n\t\t\tprogress,\n\t\t\t\"fu_plugin_attach\",\n\t\t\tvfuncs->attach != NULL ? vfuncs->attach : fu_plugin_device_attach,\n\t\t\t&error_attach)) {\n\t\t\tg_warning(\"failed to attach whilst aborting verify(): %s\",\n\t\t\t\t  error_attach->message);\n\t\t}\n\t\treturn FALSE;\n\t}\n\n\t/* run optional attach */\n\tif (!fu_plugin_runner_device_generic_progress(\n\t\tself,\n\t\tdevice,\n\t\tprogress,\n\t\t\"fu_plugin_attach\",\n\t\tvfuncs->attach != NULL ? vfuncs->attach : fu_plugin_device_attach,\n\t\terror))\n\t\treturn FALSE;\n\n\t/* success */\n\treturn TRUE;\n}\n\n/**\n * fu_plugin_runner_activate:\n * @self: a #FuPlugin\n * @device: a device\n * @progress: a #FuProgress\n * @error: (nullable): optional return location for an error\n *\n * Call into the plugin's activate routine\n *\n * Returns: #TRUE for success, #FALSE for failure\n *\n * Since: 1.2.6\n **/\ngboolean\nfu_plugin_runner_activate(FuPlugin *self, FuDevice *device, FuProgress *progress, GError **error)\n{\n\tFuPluginVfuncs *vfuncs = fu_plugin_get_vfuncs(self);\n\tguint64 flags;\n\n\tg_return_val_if_fail(FU_IS_PLUGIN(self), FALSE);\n\tg_return_val_if_fail(FU_IS_DEVICE(device), FALSE);\n\tg_return_val_if_fail(FU_IS_PROGRESS(progress), FALSE);\n\tg_return_val_if_fail(error == NULL || *error == NULL, FALSE);\n\n\t/* final check */\n\tflags = fu_device_get_flags(device);\n\tif ((flags & FWUPD_DEVICE_FLAG_NEEDS_ACTIVATION) == 0) {\n\t\tg_set_error(error,\n\t\t\t    FWUPD_ERROR,\n\t\t\t    FWUPD_ERROR_NOT_SUPPORTED,\n\t\t\t    \"Device %s does not need activation\",\n\t\t\t    fu_device_get_id(device));\n\t\treturn FALSE;\n\t}\n\n\t/* run vfunc */\n\tfu_device_add_backend_tag(device, \"activate\");\n\tif (!fu_plugin_runner_device_generic_progress(\n\t\tself,\n\t\tdevice,\n\t\tprogress,\n\t\t\"fu_plugin_activate\",\n\t\tvfuncs->activate != NULL ? vfuncs->activate : fu_plugin_device_activate,\n\t\terror))\n\t\treturn FALSE;\n\n\t/* update with correct flags */\n\tfu_device_remove_flag(device, FWUPD_DEVICE_FLAG_NEEDS_ACTIVATION);\n\tfu_device_set_modified(device, (guint64)g_get_real_time() / G_USEC_PER_SEC);\n\treturn TRUE;\n}\n\n/**\n * fu_plugin_runner_unlock:\n * @self: a #FuPlugin\n * @device: a device\n * @error: (nullable): optional return location for an error\n *\n * Call into the plugin's unlock routine\n *\n * Returns: #TRUE for success, #FALSE for failure\n *\n * Since: 0.8.0\n **/\ngboolean\nfu_plugin_runner_unlock(FuPlugin *self, FuDevice *device, GError **error)\n{\n\tFuPluginVfuncs *vfuncs = fu_plugin_get_vfuncs(self);\n\tguint64 flags;\n\n\tg_return_val_if_fail(FU_IS_PLUGIN(self), FALSE);\n\tg_return_val_if_fail(FU_IS_DEVICE(device), FALSE);\n\tg_return_val_if_fail(error == NULL || *error == NULL, FALSE);\n\n\t/* final check */\n\tflags = fu_device_get_flags(device);\n\tif ((flags & FWUPD_DEVICE_FLAG_LOCKED) == 0) {\n\t\tg_set_error(error,\n\t\t\t    FWUPD_ERROR,\n\t\t\t    FWUPD_ERROR_NOT_SUPPORTED,\n\t\t\t    \"Device %s is not locked\",\n\t\t\t    fu_device_get_id(device));\n\t\treturn FALSE;\n\t}\n\n\t/* run vfunc */\n\tfu_device_add_backend_tag(device, \"unlock\");\n\tif (!fu_plugin_runner_device_generic(self,\n\t\t\t\t\t     device,\n\t\t\t\t\t     \"fu_plugin_unlock\",\n\t\t\t\t\t     vfuncs->unlock,\n\t\t\t\t\t     error))\n\t\treturn FALSE;\n\n\t/* update with correct flags */\n\tfu_device_remove_flag(device, FWUPD_DEVICE_FLAG_LOCKED);\n\tfu_device_set_modified(device, (guint64)g_get_real_time() / G_USEC_PER_SEC);\n\treturn TRUE;\n}\n\n/**\n * fu_plugin_runner_write_firmware:\n * @self: a #FuPlugin\n * @device: a device\n * @blob_fw: a data blob\n * @progress: a #FuProgress\n * @flags: install flags\n * @error: (nullable): optional return location for an error\n *\n * Call into the plugin's write firmware routine\n *\n * Returns: #TRUE for success, #FALSE for failure\n *\n * Since: 1.7.0\n **/\ngboolean\nfu_plugin_runner_write_firmware(FuPlugin *self,\n\t\t\t\tFuDevice *device,\n\t\t\t\tGBytes *blob_fw,\n\t\t\t\tFuProgress *progress,\n\t\t\t\tFwupdInstallFlags flags,\n\t\t\t\tGError **error)\n{\n\tFuPluginVfuncs *vfuncs = fu_plugin_get_vfuncs(self);\n\tg_autoptr(GError) error_local = NULL;\n\n\tg_return_val_if_fail(FU_IS_PLUGIN(self), FALSE);\n\tg_return_val_if_fail(FU_IS_DEVICE(device), FALSE);\n\tg_return_val_if_fail(FU_IS_PROGRESS(progress), FALSE);\n\tg_return_val_if_fail(error == NULL || *error == NULL, FALSE);\n\n\t/* not enabled */\n\tif (fu_plugin_has_flag(self, FWUPD_PLUGIN_FLAG_DISABLED)) {\n\t\tg_debug(\"plugin not enabled, skipping\");\n\t\treturn TRUE;\n\t}\n\tfu_device_add_backend_tag(device, \"write-firmware\");\n\n\t/* optional */\n\tif (vfuncs->write_firmware == NULL) {\n\t\tg_debug(\"superclassed write_firmware(%s)\", fu_plugin_get_name(self));\n\t\treturn fu_plugin_device_write_firmware(self,\n\t\t\t\t\t\t       device,\n\t\t\t\t\t\t       blob_fw,\n\t\t\t\t\t\t       progress,\n\t\t\t\t\t\t       flags,\n\t\t\t\t\t\t       error);\n\t}\n\n\t/* online */\n\tif (!vfuncs->write_firmware(self, device, blob_fw, progress, flags, &error_local)) {\n\t\tif (error_local == NULL) {\n\t\t\tg_critical(\"unset plugin error in update(%s)\", fu_plugin_get_name(self));\n\t\t\tg_set_error_literal(&error_local,\n\t\t\t\t\t    FWUPD_ERROR,\n\t\t\t\t\t    FWUPD_ERROR_INTERNAL,\n\t\t\t\t\t    \"unspecified error\");\n\t\t\treturn FALSE;\n\t\t}\n\t\tfu_device_set_update_error(device, error_local->message);\n\t\tg_propagate_error(error, g_steal_pointer(&error_local));\n\t\treturn FALSE;\n\t}\n\n\t/* no longer valid */\n\tif (!fu_device_has_flag(device, FWUPD_DEVICE_FLAG_NEEDS_REBOOT) &&\n\t    !fu_device_has_flag(device, FWUPD_DEVICE_FLAG_NEEDS_SHUTDOWN)) {\n\t\tGPtrArray *checksums = fu_device_get_checksums(device);\n\t\tg_ptr_array_set_size(checksums, 0);\n\t}\n\n\t/* success */\n\treturn TRUE;\n}\n\n/**\n * fu_plugin_runner_clear_results:\n * @self: a #FuPlugin\n * @device: a device\n * @error: (nullable): optional return location for an error\n *\n * Call into the plugin's clear results routine\n *\n * Returns: #TRUE for success, #FALSE for failure\n *\n * Since: 0.8.0\n **/\ngboolean\nfu_plugin_runner_clear_results(FuPlugin *self, FuDevice *device, GError **error)\n{\n\tFuPluginVfuncs *vfuncs = fu_plugin_get_vfuncs(self);\n\tg_autoptr(GError) error_local = NULL;\n\n\tg_return_val_if_fail(FU_IS_PLUGIN(self), FALSE);\n\tg_return_val_if_fail(FU_IS_DEVICE(device), FALSE);\n\tg_return_val_if_fail(error == NULL || *error == NULL, FALSE);\n\n\t/* not enabled */\n\tif (fu_plugin_has_flag(self, FWUPD_PLUGIN_FLAG_DISABLED))\n\t\treturn TRUE;\n\n\t/* optional */\n\tif (vfuncs->clear_results == NULL)\n\t\treturn TRUE;\n\tg_debug(\"clear_result(%s)\", fu_plugin_get_name(self));\n\tif (!vfuncs->clear_results(self, device, &error_local)) {\n\t\tif (error_local == NULL) {\n\t\t\tg_critical(\"unset plugin error in clear_result(%s)\",\n\t\t\t\t   fu_plugin_get_name(self));\n\t\t\tg_set_error_literal(&error_local,\n\t\t\t\t\t    FWUPD_ERROR,\n\t\t\t\t\t    FWUPD_ERROR_INTERNAL,\n\t\t\t\t\t    \"unspecified error\");\n\t\t}\n\t\tg_propagate_prefixed_error(error,\n\t\t\t\t\t   g_steal_pointer(&error_local),\n\t\t\t\t\t   \"failed to clear_result using %s: \",\n\t\t\t\t\t   fu_plugin_get_name(self));\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\n/**\n * fu_plugin_runner_get_results:\n * @self: a #FuPlugin\n * @device: a device\n * @error: (nullable): optional return location for an error\n *\n * Call into the plugin's get results routine\n *\n * Returns: #TRUE for success, #FALSE for failure\n *\n * Since: 0.8.0\n **/\ngboolean\nfu_plugin_runner_get_results(FuPlugin *self, FuDevice *device, GError **error)\n{\n\tFuPluginVfuncs *vfuncs = fu_plugin_get_vfuncs(self);\n\tg_autoptr(GError) error_local = NULL;\n\n\tg_return_val_if_fail(FU_IS_PLUGIN(self), FALSE);\n\tg_return_val_if_fail(FU_IS_DEVICE(device), FALSE);\n\tg_return_val_if_fail(error == NULL || *error == NULL, FALSE);\n\n\t/* not enabled */\n\tif (fu_plugin_has_flag(self, FWUPD_PLUGIN_FLAG_DISABLED))\n\t\treturn TRUE;\n\n\t/* optional */\n\tif (vfuncs->get_results == NULL) {\n\t\tg_debug(\"superclassed get_results(%s)\", fu_plugin_get_name(self));\n\t\treturn fu_plugin_device_get_results(self, device, error);\n\t}\n\tg_debug(\"get_results(%s)\", fu_plugin_get_name(self));\n\tif (!vfuncs->get_results(self, device, &error_local)) {\n\t\tif (error_local == NULL) {\n\t\t\tg_critical(\"unset plugin error in get_results(%s)\",\n\t\t\t\t   fu_plugin_get_name(self));\n\t\t\tg_set_error_literal(&error_local,\n\t\t\t\t\t    FWUPD_ERROR,\n\t\t\t\t\t    FWUPD_ERROR_INTERNAL,\n\t\t\t\t\t    \"unspecified error\");\n\t\t}\n\t\tg_propagate_prefixed_error(error,\n\t\t\t\t\t   g_steal_pointer(&error_local),\n\t\t\t\t\t   \"failed to get_results using %s: \",\n\t\t\t\t\t   fu_plugin_get_name(self));\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\n/**\n * fu_plugin_get_order:\n * @self: a #FuPlugin\n *\n * Gets the plugin order, where higher numbers are run after lower\n * numbers.\n *\n * Returns: the integer value\n *\n * Since: 1.0.0\n **/\nguint\nfu_plugin_get_order(FuPlugin *self)\n{\n\tFuPluginPrivate *priv = fu_plugin_get_instance_private(self);\n\treturn priv->order;\n}\n\n/**\n * fu_plugin_set_order:\n * @self: a #FuPlugin\n * @order: an integer value\n *\n * Sets the plugin order, where higher numbers are run after lower\n * numbers.\n *\n * Since: 1.0.0\n **/\nvoid\nfu_plugin_set_order(FuPlugin *self, guint order)\n{\n\tFuPluginPrivate *priv = fu_plugin_get_instance_private(self);\n\tpriv->order = order;\n}\n\n/**\n * fu_plugin_get_priority:\n * @self: a #FuPlugin\n *\n * Gets the plugin priority, where higher numbers are better.\n *\n * Returns: the integer value\n *\n * Since: 1.1.1\n **/\nguint\nfu_plugin_get_priority(FuPlugin *self)\n{\n\tFuPluginPrivate *priv = fu_plugin_get_instance_private(self);\n\treturn priv->priority;\n}\n\n/**\n * fu_plugin_set_priority:\n * @self: a #FuPlugin\n * @priority: an integer value\n *\n * Sets the plugin priority, where higher numbers are better.\n *\n * Since: 1.0.0\n **/\nvoid\nfu_plugin_set_priority(FuPlugin *self, guint priority)\n{\n\tFuPluginPrivate *priv = fu_plugin_get_instance_private(self);\n\tpriv->priority = priority;\n}\n\n/**\n * fu_plugin_add_rule:\n * @self: a #FuPlugin\n * @rule: a plugin rule, e.g. %FU_PLUGIN_RULE_CONFLICTS\n * @name: a plugin name, e.g. `upower`\n *\n * If the plugin name is found, the rule will be used to sort the plugin list,\n * for example the plugin specified by @name will be ordered after this plugin\n * when %FU_PLUGIN_RULE_RUN_AFTER is used.\n *\n * NOTE: The depsolver is iterative and may not solve overly-complicated rules;\n * If depsolving fails then fwupd will not start.\n *\n * Since: 1.0.0\n **/\nvoid\nfu_plugin_add_rule(FuPlugin *self, FuPluginRule rule, const gchar *name)\n{\n\tFuPluginPrivate *priv = fu_plugin_get_instance_private(self);\n\tif (priv->rules[rule] == NULL)\n\t\tpriv->rules[rule] = g_ptr_array_new_with_free_func(g_free);\n\tg_ptr_array_add(priv->rules[rule], g_strdup(name));\n\tg_signal_emit(self, signals[SIGNAL_RULES_CHANGED], 0);\n}\n\n/**\n * fu_plugin_get_rules:\n * @self: a #FuPlugin\n * @rule: a plugin rule, e.g. %FU_PLUGIN_RULE_CONFLICTS\n *\n * Gets the plugin IDs that should be run after this plugin.\n *\n * Returns: (element-type utf8) (transfer none) (nullable): the list of plugin names, e.g.\n *`['appstream']`\n *\n * Since: 1.0.0\n **/\nGPtrArray *\nfu_plugin_get_rules(FuPlugin *self, FuPluginRule rule)\n{\n\tFuPluginPrivate *priv = fu_plugin_get_instance_private(self);\n\tg_return_val_if_fail(rule < FU_PLUGIN_RULE_LAST, NULL);\n\treturn priv->rules[rule];\n}\n\n/**\n * fu_plugin_has_rule:\n * @self: a #FuPlugin\n * @rule: a plugin rule, e.g. %FU_PLUGIN_RULE_CONFLICTS\n * @name: a plugin name, e.g. `upower`\n *\n * Gets the plugin IDs that should be run after this plugin.\n *\n * Returns: %TRUE if the name exists for the specific rule\n *\n * Since: 1.0.0\n **/\ngboolean\nfu_plugin_has_rule(FuPlugin *self, FuPluginRule rule, const gchar *name)\n{\n\tFuPluginPrivate *priv = fu_plugin_get_instance_private(self);\n\tif (priv->rules[rule] == NULL)\n\t\treturn FALSE;\n\tfor (guint i = 0; i < priv->rules[rule]->len; i++) {\n\t\tconst gchar *tmp = g_ptr_array_index(priv->rules[rule], i);\n\t\tif (g_strcmp0(tmp, name) == 0)\n\t\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}\n\n/**\n * fu_plugin_add_report_metadata:\n * @self: a #FuPlugin\n * @key: a string, e.g. `FwupdateVersion`\n * @value: a string, e.g. `10`\n *\n * Sets any additional metadata to be included in the firmware report to aid\n * debugging problems.\n *\n * Any data included here will be sent to the metadata server after user\n * confirmation.\n *\n * Since: 1.0.4\n **/\nvoid\nfu_plugin_add_report_metadata(FuPlugin *self, const gchar *key, const gchar *value)\n{\n\tFuPluginPrivate *priv = fu_plugin_get_instance_private(self);\n\tif (priv->report_metadata == NULL) {\n\t\tpriv->report_metadata =\n\t\t    g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);\n\t}\n\tg_hash_table_insert(priv->report_metadata, g_strdup(key), g_strdup(value));\n}\n\n/**\n * fu_plugin_get_report_metadata:\n * @self: a #FuPlugin\n *\n * Returns the list of additional metadata to be added when filing a report.\n *\n * Returns: (transfer none) (nullable): the map of report metadata\n *\n * Since: 1.0.4\n **/\nGHashTable *\nfu_plugin_get_report_metadata(FuPlugin *self)\n{\n\tFuPluginPrivate *priv = fu_plugin_get_instance_private(self);\n\treturn priv->report_metadata;\n}\n\n/**\n * fu_plugin_get_config_value:\n * @self: a #FuPlugin\n * @key: a settings key\n *\n * Return the value of a key if it's been configured\n *\n * Since: 1.0.6\n **/\ngchar *\nfu_plugin_get_config_value(FuPlugin *self, const gchar *key)\n{\n\tg_autofree gchar *conf_path = fu_plugin_get_config_filename(self);\n\tg_autoptr(GKeyFile) keyfile = NULL;\n\tif (!g_file_test(conf_path, G_FILE_TEST_IS_REGULAR))\n\t\treturn NULL;\n\tkeyfile = g_key_file_new();\n\tif (!g_key_file_load_from_file(keyfile, conf_path, G_KEY_FILE_NONE, NULL))\n\t\treturn NULL;\n\treturn g_key_file_get_string(keyfile, fu_plugin_get_name(self), key, NULL);\n}\n\n/**\n * fu_plugin_security_attr_new:\n * @self: a #FuPlugin\n * @appstream_id: (nullable): the AppStream component ID, e.g. `com.intel.BiosGuard`\n *\n * Creates a new #FwupdSecurityAttr for this specific plugin.\n *\n * Returns: (transfer full): a #FwupdSecurityAttr\n *\n * Since: 1.8.4\n **/\nFwupdSecurityAttr *\nfu_plugin_security_attr_new(FuPlugin *self, const gchar *appstream_id)\n{\n\tFuPluginPrivate *priv = fu_plugin_get_instance_private(self);\n\tg_autoptr(FwupdSecurityAttr) attr = NULL;\n\n\tg_return_val_if_fail(FU_IS_PLUGIN(self), NULL);\n\tg_return_val_if_fail(appstream_id != NULL, NULL);\n\n\tattr = fu_security_attr_new(priv->ctx, appstream_id);\n\tfwupd_security_attr_set_plugin(attr, fu_plugin_get_name(self));\n\treturn g_steal_pointer(&attr);\n}\n\n/**\n * fu_plugin_set_config_value:\n * @self: a #FuPlugin\n * @key: a settings key\n * @value: (nullable): a settings value\n * @error: (nullable): optional return location for an error\n *\n * Sets a plugin config value.\n *\n * Returns: %TRUE for success\n *\n * Since: 1.7.0\n **/\ngboolean\nfu_plugin_set_config_value(FuPlugin *self, const gchar *key, const gchar *value, GError **error)\n{\n\tg_autofree gchar *conf_path = fu_plugin_get_config_filename(self);\n\tg_autoptr(GKeyFile) keyfile = NULL;\n\n\tg_return_val_if_fail(FU_IS_PLUGIN(self), FALSE);\n\tg_return_val_if_fail(key != NULL, FALSE);\n\tg_return_val_if_fail(error == NULL || *error == NULL, FALSE);\n\n\tkeyfile = g_key_file_new();\n\tif (!g_key_file_load_from_file(keyfile, conf_path, G_KEY_FILE_KEEP_COMMENTS, error))\n\t\treturn FALSE;\n\tg_key_file_set_string(keyfile, fu_plugin_get_name(self), key, value);\n\treturn g_key_file_save_to_file(keyfile, conf_path, error);\n}\n\n#if !GLIB_CHECK_VERSION(2, 66, 0)\n\n#define G_FILE_SET_CONTENTS_CONSISTENT 0\ntypedef guint GFileSetContentsFlags;\nstatic gboolean\ng_file_set_contents_full(const gchar *filename,\n\t\t\t const gchar *contents,\n\t\t\t gssize length,\n\t\t\t GFileSetContentsFlags flags,\n\t\t\t int mode,\n\t\t\t GError **error)\n{\n\tgint fd;\n\tgssize wrote;\n\n\tif (length < 0)\n\t\tlength = strlen(contents);\n\tfd = g_open(filename, O_CREAT, mode);\n\tif (fd <= 0) {\n\t\tg_set_error(error,\n\t\t\t    G_IO_ERROR,\n\t\t\t    G_IO_ERROR_FAILED,\n\t\t\t    \"could not open %s file\",\n\t\t\t    filename);\n\t\treturn FALSE;\n\t}\n\twrote = write(fd, contents, length);\n\tif (wrote != length) {\n\t\tg_set_error(error,\n\t\t\t    G_IO_ERROR,\n\t\t\t    G_IO_ERROR_FAILED,\n\t\t\t    \"did not write %s file\",\n\t\t\t    filename);\n\t\tg_close(fd, NULL);\n\t\treturn FALSE;\n\t}\n\treturn g_close(fd, error);\n}\n#endif\n\n/**\n * fu_plugin_set_secure_config_value:\n * @self: a #FuPlugin\n * @key: a settings key\n * @value: (nullable): a settings value\n * @error: (nullable): optional return location for an error\n *\n * Sets a plugin config file value and updates file so that non-privileged users\n * cannot read it.\n *\n * Returns: %TRUE for success\n *\n * Since: 1.7.4\n **/\ngboolean\nfu_plugin_set_secure_config_value(FuPlugin *self,\n\t\t\t\t  const gchar *key,\n\t\t\t\t  const gchar *value,\n\t\t\t\t  GError **error)\n{\n\tg_autofree gchar *conf_path = fu_plugin_get_config_filename(self);\n\tg_autofree gchar *data = NULL;\n\tg_autoptr(GKeyFile) keyfile = g_key_file_new();\n\n\tg_return_val_if_fail(FU_IS_PLUGIN(self), FALSE);\n\tg_return_val_if_fail(error == NULL || *error == NULL, FALSE);\n\n\tif (!g_file_test(conf_path, G_FILE_TEST_EXISTS)) {\n\t\tg_set_error(error, FWUPD_ERROR, FWUPD_ERROR_NOT_FOUND, \"%s is missing\", conf_path);\n\t\treturn FALSE;\n\t}\n\tif (!g_key_file_load_from_file(keyfile, conf_path, G_KEY_FILE_KEEP_COMMENTS, error))\n\t\treturn FALSE;\n\tg_key_file_set_string(keyfile, fu_plugin_get_name(self), key, value);\n\tdata = g_key_file_to_data(keyfile, NULL, error);\n\tif (data == NULL)\n\t\treturn FALSE;\n\treturn g_file_set_contents_full(conf_path,\n\t\t\t\t\tdata,\n\t\t\t\t\t-1,\n\t\t\t\t\tG_FILE_SET_CONTENTS_CONSISTENT,\n\t\t\t\t\t0660,\n\t\t\t\t\terror);\n}\n\n/**\n * fu_plugin_get_config_value_boolean:\n * @self: a #FuPlugin\n * @key: a settings key\n *\n * Return the boolean value of a key if it's been configured\n *\n * Returns: %TRUE if the value is `true` (case insensitive), %FALSE otherwise\n *\n * Since: 1.4.0\n **/\ngboolean\nfu_plugin_get_config_value_boolean(FuPlugin *self, const gchar *key)\n{\n\tg_autofree gchar *tmp = fu_plugin_get_config_value(self, key);\n\tif (tmp == NULL)\n\t\treturn FALSE;\n\treturn g_ascii_strcasecmp(tmp, \"true\") == 0;\n}\n\n/**\n * fu_plugin_name_compare:\n * @plugin1: first #FuPlugin to compare.\n * @plugin2: second #FuPlugin to compare.\n *\n * Compares two plugins by their names.\n *\n * Returns: 1, 0 or -1 if @plugin1 is greater, equal, or less than @plugin2.\n *\n * Since: 1.0.8\n **/\ngint\nfu_plugin_name_compare(FuPlugin *plugin1, FuPlugin *plugin2)\n{\n\treturn g_strcmp0(fu_plugin_get_name(plugin1), fu_plugin_get_name(plugin2));\n}\n\n/**\n * fu_plugin_order_compare:\n * @plugin1: first #FuPlugin to compare.\n * @plugin2: second #FuPlugin to compare.\n *\n * Compares two plugins by their depsolved order, and then by name.\n *\n * Returns: 1, 0 or -1 if @plugin1 is greater, equal, or less than @plugin2.\n *\n * Since: 1.0.8\n **/\ngint\nfu_plugin_order_compare(FuPlugin *plugin1, FuPlugin *plugin2)\n{\n\tFuPluginPrivate *priv1 = fu_plugin_get_instance_private(plugin1);\n\tFuPluginPrivate *priv2 = fu_plugin_get_instance_private(plugin2);\n\tif (priv1->order < priv2->order)\n\t\treturn -1;\n\tif (priv1->order > priv2->order)\n\t\treturn 1;\n\treturn fu_plugin_name_compare(plugin1, plugin2);\n}\n\nstatic void\nfu_plugin_class_init(FuPluginClass *klass)\n{\n\tGObjectClass *object_class = G_OBJECT_CLASS(klass);\n\tobject_class->finalize = fu_plugin_finalize;\n\n\t/**\n\t * FuPlugin::device-added:\n\t * @self: the #FuPlugin instance that emitted the signal\n\t * @device: the #FuDevice\n\t *\n\t * The ::device-added signal is emitted when a device has been added by the plugin.\n\t *\n\t * Since: 0.8.0\n\t **/\n\tsignals[SIGNAL_DEVICE_ADDED] = g_signal_new(\"device-added\",\n\t\t\t\t\t\t    G_TYPE_FROM_CLASS(object_class),\n\t\t\t\t\t\t    G_SIGNAL_RUN_LAST,\n\t\t\t\t\t\t    G_STRUCT_OFFSET(FuPluginClass, device_added),\n\t\t\t\t\t\t    NULL,\n\t\t\t\t\t\t    NULL,\n\t\t\t\t\t\t    g_cclosure_marshal_VOID__OBJECT,\n\t\t\t\t\t\t    G_TYPE_NONE,\n\t\t\t\t\t\t    1,\n\t\t\t\t\t\t    FU_TYPE_DEVICE);\n\t/**\n\t * FuPlugin::device-removed:\n\t * @self: the #FuPlugin instance that emitted the signal\n\t * @device: the #FuDevice\n\t *\n\t * The ::device-removed signal is emitted when a device has been removed by the plugin.\n\t *\n\t * Since: 0.8.0\n\t **/\n\tsignals[SIGNAL_DEVICE_REMOVED] =\n\t    g_signal_new(\"device-removed\",\n\t\t\t G_TYPE_FROM_CLASS(object_class),\n\t\t\t G_SIGNAL_RUN_LAST,\n\t\t\t G_STRUCT_OFFSET(FuPluginClass, device_removed),\n\t\t\t NULL,\n\t\t\t NULL,\n\t\t\t g_cclosure_marshal_VOID__OBJECT,\n\t\t\t G_TYPE_NONE,\n\t\t\t 1,\n\t\t\t FU_TYPE_DEVICE);\n\t/**\n\t * FuPlugin::device-register:\n\t * @self: the #FuPlugin instance that emitted the signal\n\t * @device: the #FuDevice\n\t *\n\t * The ::device-register signal is emitted when another plugin has added the device.\n\t *\n\t * Since: 0.9.7\n\t **/\n\tsignals[SIGNAL_DEVICE_REGISTER] =\n\t    g_signal_new(\"device-register\",\n\t\t\t G_TYPE_FROM_CLASS(object_class),\n\t\t\t G_SIGNAL_RUN_LAST,\n\t\t\t G_STRUCT_OFFSET(FuPluginClass, device_register),\n\t\t\t NULL,\n\t\t\t NULL,\n\t\t\t g_cclosure_marshal_VOID__OBJECT,\n\t\t\t G_TYPE_NONE,\n\t\t\t 1,\n\t\t\t FU_TYPE_DEVICE);\n\t/**\n\t * FuPlugin::check-supported:\n\t * @self: the #FuPlugin instance that emitted the signal\n\t * @guid: a device GUID\n\t *\n\t * The ::check-supported signal is emitted when a plugin wants to ask the daemon if a\n\t * specific device GUID is supported in the existing system metadata.\n\t *\n\t * Returns: %TRUE if the GUID is found\n\t *\n\t * Since: 1.0.0\n\t **/\n\tsignals[SIGNAL_CHECK_SUPPORTED] =\n\t    g_signal_new(\"check-supported\",\n\t\t\t G_TYPE_FROM_CLASS(object_class),\n\t\t\t G_SIGNAL_RUN_LAST,\n\t\t\t G_STRUCT_OFFSET(FuPluginClass, check_supported),\n\t\t\t NULL,\n\t\t\t NULL,\n\t\t\t g_cclosure_marshal_generic,\n\t\t\t G_TYPE_BOOLEAN,\n\t\t\t 1,\n\t\t\t G_TYPE_STRING);\n\tsignals[SIGNAL_RULES_CHANGED] = g_signal_new(\"rules-changed\",\n\t\t\t\t\t\t     G_TYPE_FROM_CLASS(object_class),\n\t\t\t\t\t\t     G_SIGNAL_RUN_LAST,\n\t\t\t\t\t\t     G_STRUCT_OFFSET(FuPluginClass, rules_changed),\n\t\t\t\t\t\t     NULL,\n\t\t\t\t\t\t     NULL,\n\t\t\t\t\t\t     g_cclosure_marshal_VOID__VOID,\n\t\t\t\t\t\t     G_TYPE_NONE,\n\t\t\t\t\t\t     0);\n\t/**\n\t * FuPlugin::config-changed:\n\t * @self: the #FuPlugin instance that emitted the signal\n\t *\n\t * The ::config-changed signal is emitted when one or more config files have changed which\n\t * may affect how the daemon should be run.\n\t *\n\t * Since: 1.7.0\n\t **/\n\tsignals[SIGNAL_CONFIG_CHANGED] =\n\t    g_signal_new(\"config-changed\",\n\t\t\t G_TYPE_FROM_CLASS(object_class),\n\t\t\t G_SIGNAL_RUN_LAST,\n\t\t\t G_STRUCT_OFFSET(FuPluginClass, config_changed),\n\t\t\t NULL,\n\t\t\t NULL,\n\t\t\t g_cclosure_marshal_VOID__VOID,\n\t\t\t G_TYPE_NONE,\n\t\t\t 0);\n}\n\nstatic void\nfu_plugin_init(FuPlugin *self)\n{\n\tFuPluginPrivate *priv = GET_PRIVATE(self);\n\tg_rw_lock_init(&priv->cache_mutex);\n}\n\nstatic void\nfu_plugin_finalize(GObject *object)\n{\n\tFuPlugin *self = FU_PLUGIN(object);\n\tFuPluginPrivate *priv = GET_PRIVATE(self);\n\tFuPluginVfuncs *vfuncs = fu_plugin_get_vfuncs(self);\n\n\tg_rw_lock_clear(&priv->cache_mutex);\n\n\t/* optional */\n\tif (priv->done_init && vfuncs->destroy != NULL) {\n\t\tg_debug(\"destroy(%s)\", fu_plugin_get_name(self));\n\t\tvfuncs->destroy(self);\n\t}\n\n\tfor (guint i = 0; i < FU_PLUGIN_RULE_LAST; i++) {\n\t\tif (priv->rules[i] != NULL)\n\t\t\tg_ptr_array_unref(priv->rules[i]);\n\t}\n\tif (priv->devices != NULL)\n\t\tg_ptr_array_unref(priv->devices);\n\tif (priv->ctx != NULL)\n\t\tg_object_unref(priv->ctx);\n\tif (priv->runtime_versions != NULL)\n\t\tg_hash_table_unref(priv->runtime_versions);\n\tif (priv->compile_versions != NULL)\n\t\tg_hash_table_unref(priv->compile_versions);\n\tif (priv->report_metadata != NULL)\n\t\tg_hash_table_unref(priv->report_metadata);\n\tif (priv->cache != NULL)\n\t\tg_hash_table_unref(priv->cache);\n\tif (priv->device_gtypes != NULL)\n\t\tg_array_unref(priv->device_gtypes);\n\tif (priv->config_monitor != NULL)\n\t\tg_object_unref(priv->config_monitor);\n\tg_free(priv->data);\n\n\tG_OBJECT_CLASS(fu_plugin_parent_class)->finalize(object);\n}\n\n/**\n * fu_plugin_new:\n * @ctx: (nullable): a #FuContext\n *\n * Creates a new #FuPlugin\n *\n * Since: 0.8.0\n **/\nFuPlugin *\nfu_plugin_new(FuContext *ctx)\n{\n\tFuPlugin *self = FU_PLUGIN(g_object_new(FU_TYPE_PLUGIN, NULL));\n\tFuPluginPrivate *priv = GET_PRIVATE(self);\n\tif (ctx != NULL)\n\t\tpriv->ctx = g_object_ref(ctx);\n\treturn self;\n}\n", "/*\n * Copyright (C) 2015 Richard Hughes <richard@hughsie.com>\n *\n * SPDX-License-Identifier: LGPL-2.1+\n */\n\n#include \"config.h\"\n\n#include <fwupdplugin.h>\n\n#include <glib/gstdio.h>\n#include <libgcab.h>\n#include <string.h>\n\n#include \"fwupd-bios-setting-private.h\"\n#include \"fwupd-security-attr-private.h\"\n\n#include \"fu-bios-settings-private.h\"\n#include \"fu-cabinet.h\"\n#include \"fu-common-private.h\"\n#include \"fu-context-private.h\"\n#include \"fu-coswid-firmware.h\"\n#include \"fu-device-private.h\"\n#include \"fu-plugin-private.h\"\n#include \"fu-security-attrs-private.h\"\n#include \"fu-smbios-private.h\"\n\nstatic GMainLoop *_test_loop = NULL;\nstatic guint _test_loop_timeout_id = 0;\n\nstatic gboolean\nfu_test_hang_check_cb(gpointer user_data)\n{\n\tg_main_loop_quit(_test_loop);\n\t_test_loop_timeout_id = 0;\n\treturn G_SOURCE_REMOVE;\n}\n\nstatic void\nfu_test_loop_run_with_timeout(guint timeout_ms)\n{\n\tg_assert_cmpint(_test_loop_timeout_id, ==, 0);\n\tg_assert_null(_test_loop);\n\t_test_loop = g_main_loop_new(NULL, FALSE);\n\t_test_loop_timeout_id = g_timeout_add(timeout_ms, fu_test_hang_check_cb, NULL);\n\tg_main_loop_run(_test_loop);\n}\n\nstatic void\nfu_test_loop_quit(void)\n{\n\tif (_test_loop_timeout_id > 0) {\n\t\tg_source_remove(_test_loop_timeout_id);\n\t\t_test_loop_timeout_id = 0;\n\t}\n\tif (_test_loop != NULL) {\n\t\tg_main_loop_quit(_test_loop);\n\t\tg_main_loop_unref(_test_loop);\n\t\t_test_loop = NULL;\n\t}\n}\n\nstatic void\nfu_archive_invalid_func(void)\n{\n\tg_autofree gchar *filename = NULL;\n\tg_autoptr(FuArchive) archive = NULL;\n\tg_autoptr(GBytes) data = NULL;\n\tg_autoptr(GError) error = NULL;\n\n#ifndef HAVE_LIBARCHIVE\n\tg_test_skip(\"no libarchive support\");\n\treturn;\n#endif\n\n\tfilename = g_test_build_filename(G_TEST_DIST, \"tests\", \"metadata.xml\", NULL);\n\tdata = fu_bytes_get_contents(filename, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(data);\n\n\tarchive = fu_archive_new(data, FU_ARCHIVE_FLAG_NONE, &error);\n\tg_assert_error(error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED);\n\tg_assert_null(archive);\n}\n\nstatic void\nfu_archive_cab_func(void)\n{\n\tg_autofree gchar *checksum1 = NULL;\n\tg_autofree gchar *checksum2 = NULL;\n\tg_autofree gchar *filename = NULL;\n\tg_autoptr(FuArchive) archive = NULL;\n\tg_autoptr(GBytes) data = NULL;\n\tg_autoptr(GError) error = NULL;\n\tGBytes *data_tmp;\n\n#ifndef HAVE_LIBARCHIVE\n\tg_test_skip(\"no libarchive support\");\n\treturn;\n#endif\n\n\tfilename = g_test_build_filename(G_TEST_BUILT,\n\t\t\t\t\t \"tests\",\n\t\t\t\t\t \"colorhug\",\n\t\t\t\t\t \"colorhug-als-3.0.2.cab\",\n\t\t\t\t\t NULL);\n\tdata = fu_bytes_get_contents(filename, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(data);\n\n\tarchive = fu_archive_new(data, FU_ARCHIVE_FLAG_NONE, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(archive);\n\n\tdata_tmp = fu_archive_lookup_by_fn(archive, \"firmware.metainfo.xml\", &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(data_tmp);\n\tchecksum1 = g_compute_checksum_for_bytes(G_CHECKSUM_SHA1, data_tmp);\n\tg_assert_cmpstr(checksum1, ==, \"8611114f51f7151f190de86a5c9259d79ff34216\");\n\n\tdata_tmp = fu_archive_lookup_by_fn(archive, \"firmware.bin\", &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(data_tmp);\n\tchecksum2 = g_compute_checksum_for_bytes(G_CHECKSUM_SHA1, data_tmp);\n\tg_assert_cmpstr(checksum2, ==, \"7c0ae84b191822bcadbdcbe2f74a011695d783c7\");\n\n\tdata_tmp = fu_archive_lookup_by_fn(archive, \"NOTGOINGTOEXIST.xml\", &error);\n\tg_assert_error(error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND);\n\tg_assert_null(data_tmp);\n}\n\nstatic void\nfu_common_gpt_type_func(void)\n{\n\tg_assert_cmpstr(fu_common_convert_to_gpt_type(\"0xef\"),\n\t\t\t==,\n\t\t\t\"c12a7328-f81f-11d2-ba4b-00a0c93ec93b\");\n\tg_assert_cmpstr(fu_common_convert_to_gpt_type(\"0x0b\"),\n\t\t\t==,\n\t\t\t\"ebd0a0a2-b9e5-4433-87c0-68b6b72699c7\");\n\tg_assert_cmpstr(fu_common_convert_to_gpt_type(\"fat32lba\"),\n\t\t\t==,\n\t\t\t\"ebd0a0a2-b9e5-4433-87c0-68b6b72699c7\");\n\tg_assert_cmpstr(fu_common_convert_to_gpt_type(\"0x00\"), ==, \"0x00\");\n}\n\nstatic void\nfu_common_align_up_func(void)\n{\n\tg_assert_cmpint(fu_common_align_up(0, 0), ==, 0);\n\tg_assert_cmpint(fu_common_align_up(5, 0), ==, 5);\n\tg_assert_cmpint(fu_common_align_up(5, 3), ==, 8);\n\tg_assert_cmpint(fu_common_align_up(1023, 10), ==, 1024);\n\tg_assert_cmpint(fu_common_align_up(1024, 10), ==, 1024);\n\tg_assert_cmpint(fu_common_align_up(G_MAXSIZE - 1, 10), ==, G_MAXSIZE);\n}\n\nstatic void\nfu_common_byte_array_func(void)\n{\n\tg_autoptr(GByteArray) array = g_byte_array_new();\n\n\tfu_byte_array_append_uint8(array, (guint8)'h');\n\tfu_byte_array_append_uint8(array, (guint8)'e');\n\tfu_byte_array_append_uint8(array, (guint8)'l');\n\tfu_byte_array_append_uint8(array, (guint8)'l');\n\tfu_byte_array_append_uint8(array, (guint8)'o');\n\tg_assert_cmpint(array->len, ==, 5);\n\tg_assert_cmpint(memcmp(array->data, \"hello\", array->len), ==, 0);\n\n\tfu_byte_array_set_size(array, 10, 0x00);\n\tg_assert_cmpint(array->len, ==, 10);\n\tg_assert_cmpint(memcmp(array->data, \"hello\\0\\0\\0\\0\\0\", array->len), ==, 0);\n}\n\nstatic void\nfu_common_crc_func(void)\n{\n\tguint8 buf[] = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09};\n\tg_assert_cmpint(fu_crc8(buf, sizeof(buf)), ==, 0x7A);\n\tg_assert_cmpint(fu_crc16(buf, sizeof(buf)), ==, 0x4DF1);\n\tg_assert_cmpint(fu_crc32(buf, sizeof(buf)), ==, 0x40EFAB9E);\n}\n\nstatic void\nfu_string_append_func(void)\n{\n\tg_autoptr(GString) str = g_string_new(NULL);\n\tfu_string_append(str, 0, \"hdr\", NULL);\n\tfu_string_append(str, 0, \"key\", \"value\");\n\tfu_string_append(str, 0, \"key1\", \"value1\");\n\tfu_string_append(str, 1, \"key2\", \"value2\");\n\tfu_string_append(str, 1, \"\", \"value2\");\n\tfu_string_append(str, 2, \"key3\", \"value3\");\n\tg_assert_cmpstr(str->str,\n\t\t\t==,\n\t\t\t\"hdr:\\n\"\n\t\t\t\"key:                    value\\n\"\n\t\t\t\"key1:                   value1\\n\"\n\t\t\t\"  key2:                 value2\\n\"\n\t\t\t\"                        value2\\n\"\n\t\t\t\"    key3:               value3\\n\");\n}\n\nstatic void\nfu_version_guess_format_func(void)\n{\n\tg_assert_cmpint(fu_version_guess_format(NULL), ==, FWUPD_VERSION_FORMAT_UNKNOWN);\n\tg_assert_cmpint(fu_version_guess_format(\"\"), ==, FWUPD_VERSION_FORMAT_UNKNOWN);\n\tg_assert_cmpint(fu_version_guess_format(\"1234ac\"), ==, FWUPD_VERSION_FORMAT_PLAIN);\n\tg_assert_cmpint(fu_version_guess_format(\"1.2\"), ==, FWUPD_VERSION_FORMAT_PAIR);\n\tg_assert_cmpint(fu_version_guess_format(\"1.2.3\"), ==, FWUPD_VERSION_FORMAT_TRIPLET);\n\tg_assert_cmpint(fu_version_guess_format(\"1.2.3.4\"), ==, FWUPD_VERSION_FORMAT_QUAD);\n\tg_assert_cmpint(fu_version_guess_format(\"1.2.3.4.5\"), ==, FWUPD_VERSION_FORMAT_UNKNOWN);\n\tg_assert_cmpint(fu_version_guess_format(\"1a.2b.3\"), ==, FWUPD_VERSION_FORMAT_PLAIN);\n\tg_assert_cmpint(fu_version_guess_format(\"1\"), ==, FWUPD_VERSION_FORMAT_NUMBER);\n\tg_assert_cmpint(fu_version_guess_format(\"0x10201\"), ==, FWUPD_VERSION_FORMAT_NUMBER);\n}\n\nstatic void\nfu_device_version_format_func(void)\n{\n\tg_autoptr(FuDevice) device = fu_device_new(NULL);\n\tfu_device_add_internal_flag(device, FU_DEVICE_INTERNAL_FLAG_ENSURE_SEMVER);\n\tfu_device_set_version_format(device, FWUPD_VERSION_FORMAT_TRIPLET);\n\tfu_device_set_version(device, \"Ver1.2.3 RELEASE\");\n\tg_assert_cmpstr(fu_device_get_version(device), ==, \"1.2.3\");\n}\n\nstatic void\nfu_device_open_refcount_func(void)\n{\n\tgboolean ret;\n\tg_autoptr(FuDevice) device = fu_device_new(NULL);\n\tg_autoptr(GError) error = NULL;\n\tfu_device_set_id(device, \"test_device\");\n\tret = fu_device_open(device, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tret = fu_device_open(device, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tret = fu_device_close(device, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tret = fu_device_close(device, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tret = fu_device_close(device, &error);\n\tg_assert_error(error, FWUPD_ERROR, FWUPD_ERROR_NOTHING_TO_DO);\n\tg_assert_false(ret);\n}\n\nstatic void\nfu_device_name_func(void)\n{\n\tg_autoptr(FuDevice) device1 = fu_device_new(NULL);\n\tg_autoptr(FuDevice) device2 = fu_device_new(NULL);\n\n\t/* vendor then name */\n\tfu_device_set_vendor(device1, \"  Hughski  \");\n\tfu_device_set_name(device1, \"HUGHSKI  ColorHug(TM)__Pro  \");\n\tg_assert_cmpstr(fu_device_get_vendor(device1), ==, \"Hughski\");\n\tg_assert_cmpstr(fu_device_get_name(device1), ==, \"ColorHug\u2122 Pro\");\n\n\t/* name then vendor */\n\tfu_device_set_name(device2, \"Hughski ColorHug(TM)_Pro\");\n\tfu_device_set_vendor(device2, \"Hughski\");\n\tg_assert_cmpstr(fu_device_get_vendor(device2), ==, \"Hughski\");\n\tg_assert_cmpstr(fu_device_get_name(device2), ==, \"ColorHug\u2122 Pro\");\n\n\t/* a real example */\n\tfu_device_set_name(device2, \"Intel(R) Core(TM) i7-10850H CPU @ 2.70GHz\");\n\tfu_device_set_vendor(device2, \"Intel\");\n\tg_assert_cmpstr(fu_device_get_name(device2), ==, \"Core\u2122 i7-10850H CPU @ 2.70GHz\");\n}\n\nstatic void\nfu_device_cfi_device_func(void)\n{\n\tgboolean ret;\n\tguint8 cmd = 0;\n\tg_autoptr(FuContext) ctx = fu_context_new();\n\tg_autoptr(FuCfiDevice) cfi_device = NULL;\n\tg_autoptr(GError) error = NULL;\n\n\tret = fu_context_load_quirks(ctx, FU_QUIRKS_LOAD_FLAG_NO_CACHE, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\n\tcfi_device = fu_cfi_device_new(ctx, \"3730\");\n\tret = fu_device_setup(FU_DEVICE(cfi_device), &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\n\t/* fallback */\n\tret = fu_cfi_device_get_cmd(cfi_device, FU_CFI_DEVICE_CMD_READ_DATA, &cmd, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_assert_cmpint(cmd, ==, 0x03);\n\n\t/* from quirk */\n\tret = fu_cfi_device_get_cmd(cfi_device, FU_CFI_DEVICE_CMD_CHIP_ERASE, &cmd, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_assert_cmpint(cmd, ==, 0xC7);\n\tg_assert_cmpint(fu_cfi_device_get_size(cfi_device), ==, 0x10000);\n\tg_assert_cmpint(fu_cfi_device_get_page_size(cfi_device), ==, 0x200);\n\tg_assert_cmpint(fu_cfi_device_get_sector_size(cfi_device), ==, 0x2000);\n\tg_assert_cmpint(fu_cfi_device_get_block_size(cfi_device), ==, 0x8000);\n}\n\nstatic void\nfu_device_metadata_func(void)\n{\n\tg_autoptr(FuDevice) device = fu_device_new(NULL);\n\n\t/* string */\n\tfu_device_set_metadata(device, \"foo\", \"bar\");\n\tg_assert_cmpstr(fu_device_get_metadata(device, \"foo\"), ==, \"bar\");\n\tfu_device_set_metadata(device, \"foo\", \"baz\");\n\tg_assert_cmpstr(fu_device_get_metadata(device, \"foo\"), ==, \"baz\");\n\tg_assert_null(fu_device_get_metadata(device, \"unknown\"));\n\n\t/* boolean */\n\tfu_device_set_metadata_boolean(device, \"baz\", TRUE);\n\tg_assert_cmpstr(fu_device_get_metadata(device, \"baz\"), ==, \"true\");\n\tg_assert_true(fu_device_get_metadata_boolean(device, \"baz\"));\n\tg_assert_false(fu_device_get_metadata_boolean(device, \"unknown\"));\n\n\t/* integer */\n\tfu_device_set_metadata_integer(device, \"bam\", 12345);\n\tg_assert_cmpstr(fu_device_get_metadata(device, \"bam\"), ==, \"12345\");\n\tg_assert_cmpint(fu_device_get_metadata_integer(device, \"bam\"), ==, 12345);\n\tg_assert_cmpint(fu_device_get_metadata_integer(device, \"unknown\"), ==, G_MAXUINT);\n\n\t/* broken integer */\n\tfu_device_set_metadata(device, \"bam\", \"123junk\");\n\tg_assert_cmpint(fu_device_get_metadata_integer(device, \"bam\"), ==, G_MAXUINT);\n\tfu_device_set_metadata(device, \"huge\", \"4294967296\"); /* not 32 bit */\n\tg_assert_cmpint(fu_device_get_metadata_integer(device, \"huge\"), ==, G_MAXUINT);\n}\n\nstatic void\nfu_smbios_func(void)\n{\n\tconst gchar *str;\n\tgboolean ret;\n\tg_autofree gchar *dump = NULL;\n\tg_autofree gchar *testdatadir = NULL;\n\tg_autoptr(FuSmbios) smbios = NULL;\n\tg_autoptr(GError) error = NULL;\n\n#ifdef _WIN32\n\tg_test_skip(\"Windows uses GetSystemFirmwareTable rather than parsing the fake test data\");\n\treturn;\n#endif\n\n\t/* these tests will not write */\n\ttestdatadir = g_test_build_filename(G_TEST_DIST, \"tests\", NULL);\n\t(void)g_setenv(\"FWUPD_SYSFSFWDIR\", testdatadir, TRUE);\n\n\tsmbios = fu_smbios_new();\n\tret = fu_smbios_setup(smbios, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tdump = fu_firmware_to_string(FU_FIRMWARE(smbios));\n\tif (g_getenv(\"FWUPD_VERBOSE\") != NULL)\n\t\tg_debug(\"%s\", dump);\n\n\t/* test for missing table */\n\tstr = fu_smbios_get_string(smbios, 0xff, 0, &error);\n\tg_assert_error(error, FWUPD_ERROR, FWUPD_ERROR_INVALID_FILE);\n\tg_assert_null(str);\n\tg_clear_error(&error);\n\n\t/* check for invalid offset */\n\tstr = fu_smbios_get_string(smbios, FU_SMBIOS_STRUCTURE_TYPE_BIOS, 0xff, &error);\n\tg_assert_error(error, FWUPD_ERROR, FWUPD_ERROR_INVALID_FILE);\n\tg_assert_null(str);\n\tg_clear_error(&error);\n\n\t/* get vendor */\n\tstr = fu_smbios_get_string(smbios, FU_SMBIOS_STRUCTURE_TYPE_BIOS, 0x04, &error);\n\tg_assert_no_error(error);\n\tg_assert_cmpstr(str, ==, \"LENOVO\");\n}\n\nstatic void\nfu_smbios3_func(void)\n{\n\tconst gchar *str;\n\tgboolean ret;\n\tg_autofree gchar *path = NULL;\n\tg_autoptr(FuSmbios) smbios = NULL;\n\tg_autoptr(GError) error = NULL;\n\n\tpath = g_test_build_filename(G_TEST_DIST, \"tests\", \"dmi\", \"tables64\", NULL);\n\tsmbios = fu_smbios_new();\n\tret = fu_smbios_setup_from_path(smbios, path, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tif (g_getenv(\"FWUPD_VERBOSE\") != NULL) {\n\t\tg_autofree gchar *dump = fu_firmware_to_string(FU_FIRMWARE(smbios));\n\t\tg_debug(\"%s\", dump);\n\t}\n\n\t/* get vendor */\n\tstr = fu_smbios_get_string(smbios, FU_SMBIOS_STRUCTURE_TYPE_BIOS, 0x04, &error);\n\tg_assert_no_error(error);\n\tg_assert_cmpstr(str, ==, \"Dell Inc.\");\n}\n\nstatic void\nfu_smbios_dt_func(void)\n{\n\tconst gchar *str;\n\tgboolean ret;\n\tg_autofree gchar *path = NULL;\n\tg_autoptr(FuSmbios) smbios = NULL;\n\tg_autoptr(GError) error = NULL;\n\n\tpath = g_test_build_filename(G_TEST_DIST, \"tests\", \"devicetree\", \"base\", NULL);\n\tsmbios = fu_smbios_new();\n\tret = fu_smbios_setup_from_path(smbios, path, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tif (g_getenv(\"FWUPD_VERBOSE\") != NULL) {\n\t\tg_autofree gchar *dump = fu_firmware_to_string(FU_FIRMWARE(smbios));\n\t\tg_debug(\"%s\", dump);\n\t}\n\n\t/* get vendor */\n\tstr = fu_smbios_get_string(smbios, FU_SMBIOS_STRUCTURE_TYPE_SYSTEM, 0x04, &error);\n\tg_assert_no_error(error);\n\tg_assert_cmpstr(str, ==, \"Hughski Limited\");\n}\n\nstatic void\nfu_smbios_dt_fallback_func(void)\n{\n\tconst gchar *str;\n\tgboolean ret;\n\tg_autofree gchar *path = NULL;\n\tg_autoptr(FuSmbios) smbios = fu_smbios_new();\n\tg_autoptr(GError) error = NULL;\n\n\tpath = g_test_build_filename(G_TEST_DIST, \"tests\", \"devicetree-fallback\", \"base\", NULL);\n\tret = fu_smbios_setup_from_path(smbios, path, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tif (g_getenv(\"FWUPD_VERBOSE\") != NULL) {\n\t\tg_autofree gchar *dump = fu_firmware_to_string(FU_FIRMWARE(smbios));\n\t\tg_debug(\"%s\", dump);\n\t}\n\n\t/* get vendor */\n\tstr = fu_smbios_get_string(smbios, FU_SMBIOS_STRUCTURE_TYPE_SYSTEM, 0x04, &error);\n\tg_assert_no_error(error);\n\tg_assert_cmpstr(str, ==, \"solidrun\");\n\n\t/* get model */\n\tstr = fu_smbios_get_string(smbios, FU_SMBIOS_STRUCTURE_TYPE_SYSTEM, 0x05, &error);\n\tg_assert_no_error(error);\n\tg_assert_cmpstr(str, ==, \"honeycomb\");\n}\n\nstatic void\nfu_smbios_class_func(void)\n{\n\tg_autofree gchar *path = g_test_build_filename(G_TEST_DIST, \"tests\", \"dmi\", \"class\", NULL);\n\tg_autoptr(FuSmbios) smbios = fu_smbios_new();\n\tg_autoptr(GError) error = NULL;\n\tgboolean ret;\n\tconst gchar *str;\n\tguint8 byte;\n\n\tret = fu_smbios_setup_from_kernel(smbios, path, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tif (g_getenv(\"FWUPD_VERBOSE\") != NULL) {\n\t\tg_autofree gchar *dump = fu_firmware_to_string(FU_FIRMWARE(smbios));\n\t\tg_debug(\"%s\", dump);\n\t}\n\n\tstr = fu_smbios_get_string(smbios, FU_SMBIOS_STRUCTURE_TYPE_SYSTEM, 4, &error);\n\tg_assert_no_error(error);\n\tg_assert_cmpstr(str, ==, \"FwupdTest\");\n\n\tbyte = fu_smbios_get_integer(smbios, FU_SMBIOS_STRUCTURE_TYPE_CHASSIS, 5, &error);\n\tg_assert_no_error(error);\n\tg_assert_cmpuint(byte, ==, 16);\n}\n\nstatic gboolean\n_strnsplit_add_cb(GString *token, guint token_idx, gpointer user_data, GError **error)\n{\n\tGPtrArray *array = (GPtrArray *)user_data;\n\tg_debug(\"TOKEN: [%s] (%u)\", token->str, token_idx);\n\tg_ptr_array_add(array, g_strdup(token->str));\n\treturn TRUE;\n}\n\nstatic gboolean\n_strnsplit_nop_cb(GString *token, guint token_idx, gpointer user_data, GError **error)\n{\n\tguint *cnt = (guint *)user_data;\n\t(*cnt)++;\n\treturn TRUE;\n}\n\nstatic void\nfu_common_memmem_func(void)\n{\n\tconst guint8 haystack[] = {'H', 'A', 'Y', 'S'};\n\tconst guint8 needle[] = {'A', 'Y'};\n\tgboolean ret;\n\tgsize offset = 0;\n\tg_autoptr(GError) error = NULL;\n\n\tret = fu_memmem_safe(haystack, sizeof(haystack), needle, sizeof(needle), &offset, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_assert_cmpint(offset, ==, 0x1);\n\n\tret = fu_memmem_safe(haystack + 2,\n\t\t\t     sizeof(haystack) - 2,\n\t\t\t     needle,\n\t\t\t     sizeof(needle),\n\t\t\t     &offset,\n\t\t\t     &error);\n\tg_assert_error(error, FWUPD_ERROR, FWUPD_ERROR_NOT_FOUND);\n\tg_assert_false(ret);\n}\n\nstatic void\nfu_strsplit_func(void)\n{\n\tconst gchar *str = \"123foo123bar123\";\n\tconst guint bigsz = 1024 * 1024;\n\tgboolean ret;\n\tguint cnt = 0;\n\tg_autoptr(GError) error = NULL;\n\tg_autoptr(GPtrArray) array = g_ptr_array_new_with_free_func(g_free);\n\tg_autoptr(GString) bigstr = g_string_sized_new(bigsz * 2);\n\n\t/* works for me */\n\tret = fu_strsplit_full(str, -1, \"123\", _strnsplit_add_cb, array, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_assert_cmpint(array->len, ==, 3);\n\tg_assert_cmpstr(g_ptr_array_index(array, 0), ==, \"\");\n\tg_assert_cmpstr(g_ptr_array_index(array, 1), ==, \"foo\");\n\tg_assert_cmpstr(g_ptr_array_index(array, 2), ==, \"bar\");\n\n\t/* lets try something insane */\n\tfor (guint i = 0; i < bigsz; i++)\n\t\tg_string_append(bigstr, \"X\\n\");\n\tret = fu_strsplit_full(bigstr->str, -1, \"\\n\", _strnsplit_nop_cb, &cnt, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_assert_cmpint(cnt, ==, bigsz);\n}\n\nstatic void\nfu_strsafe_func(void)\n{\n\tstruct {\n\t\tconst gchar *in;\n\t\tconst gchar *op;\n\t} strs[] = {{\"dave123\", \"dave123\"},\n\t\t    {\"dave123XXX\", \"dave123\"},\n\t\t    {\"dave\\x03XXX\", \"dave.XX\"},\n\t\t    {\"dave\\x03\\x04XXX\", \"dave..X\"},\n\t\t    {\"\\x03\\x03\", NULL},\n\t\t    {NULL, NULL}};\n\tGPtrArray *instance_ids;\n\tgboolean ret;\n\tg_autoptr(FuContext) ctx = fu_context_new();\n\tg_autoptr(FuDevice) dev = fu_device_new(ctx);\n\tg_autoptr(GError) error = NULL;\n\n\t/* check bespoke legacy instance ID behavior */\n\tfu_device_add_instance_strsafe(dev, \"KEY\", \"_ _LEN&VO&\\\\&\");\n\tret = fu_device_build_instance_id(dev, &error, \"SUB\", \"KEY\", NULL);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tinstance_ids = fu_device_get_instance_ids(dev);\n\tg_assert_cmpint(instance_ids->len, ==, 1);\n\tg_assert_cmpstr(g_ptr_array_index(instance_ids, 0), ==, \"SUB\\\\KEY_LEN-VO\");\n\n\tfor (guint i = 0; strs[i].in != NULL; i++) {\n\t\tg_autofree gchar *tmp = fu_strsafe(strs[i].in, 7);\n\t\tg_assert_cmpstr(tmp, ==, strs[i].op);\n\t}\n}\n\nstatic void\nfu_hwids_func(void)\n{\n\tg_autofree gchar *testdatadir = NULL;\n\tg_autoptr(FuHwids) hwids = NULL;\n\tg_autoptr(FuSmbios) smbios = NULL;\n\tg_autoptr(GError) error = NULL;\n\tgboolean ret;\n\n\tstruct {\n\t\tconst gchar *key;\n\t\tconst gchar *value;\n\t} guids[] = {{\"Manufacturer\", \"6de5d951-d755-576b-bd09-c5cf66b27234\"},\n\t\t     {\"HardwareID-14\", \"6de5d951-d755-576b-bd09-c5cf66b27234\"},\n\t\t     {\"HardwareID-13\", \"f8e1de5f-b68c-5f52-9d1a-f1ba52f1f773\"},\n\t\t     {\"HardwareID-12\", \"e093d715-70f7-51f4-b6c8-b4a7e31def85\"},\n\t\t     {\"HardwareID-11\", \"db73af4c-4612-50f7-b8a7-787cf4871847\"},\n\t\t     {\"HardwareID-10\", \"f4275c1f-6130-5191-845c-3426247eb6a1\"},\n\t\t     {\"HardwareID-9\", \"0cf8618d-9eff-537c-9f35-46861406eb9c\"},\n\t\t     {\"HardwareID-8\", \"059eb22d-6dc7-59af-abd3-94bbe017f67c\"},\n\t\t     {\"HardwareID-7\", \"da1da9b6-62f5-5f22-8aaa-14db7eeda2a4\"},\n\t\t     {\"HardwareID-6\", \"178cd22d-ad9f-562d-ae0a-34009822cdbe\"},\n\t\t     {\"HardwareID-5\", \"8dc9b7c5-f5d5-5850-9ab3-bd6f0549d814\"},\n\t\t     {\"HardwareID-4\", \"660ccba8-1b78-5a33-80e6-9fb8354ee873\"},\n\t\t     {\"HardwareID-3\", \"3faec92a-3ae3-5744-be88-495e90a7d541\"},\n\t\t     {\"HardwareID-2\", \"f5ff077f-3eeb-5bae-be1c-e98ffe8ce5f8\"},\n\t\t     {\"HardwareID-1\", \"b7cceb67-774c-537e-bf8b-22c6107e9a74\"},\n\t\t     {\"HardwareID-0\", \"147efce9-f201-5fc8-ab0c-c859751c3440\"},\n\t\t     {NULL, NULL}};\n\n#ifdef _WIN32\n\tg_test_skip(\"Windows uses GetSystemFirmwareTable rather than parsing the fake test data\");\n\treturn;\n#endif\n\n\t/* these tests will not write */\n\ttestdatadir = g_test_build_filename(G_TEST_DIST, \"tests\", NULL);\n\t(void)g_setenv(\"FWUPD_SYSFSFWDIR\", testdatadir, TRUE);\n\n\tsmbios = fu_smbios_new();\n\tret = fu_smbios_setup(smbios, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\n\thwids = fu_hwids_new();\n\tret = fu_hwids_setup(hwids, smbios, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\n\tg_assert_cmpstr(fu_hwids_get_value(hwids, FU_HWIDS_KEY_MANUFACTURER), ==, \"LENOVO\");\n\tg_assert_cmpstr(fu_hwids_get_value(hwids, FU_HWIDS_KEY_ENCLOSURE_KIND), ==, \"a\");\n\tg_assert_cmpstr(fu_hwids_get_value(hwids, FU_HWIDS_KEY_FAMILY), ==, \"ThinkPad T440s\");\n\tg_assert_cmpstr(fu_hwids_get_value(hwids, FU_HWIDS_KEY_PRODUCT_NAME), ==, \"20ARS19C0C\");\n\tg_assert_cmpstr(fu_hwids_get_value(hwids, FU_HWIDS_KEY_BIOS_VENDOR), ==, \"LENOVO\");\n\tg_assert_cmpstr(fu_hwids_get_value(hwids, FU_HWIDS_KEY_BIOS_VERSION),\n\t\t\t==,\n\t\t\t\"GJET75WW (2.25 )\");\n\tg_assert_cmpstr(fu_hwids_get_value(hwids, FU_HWIDS_KEY_BIOS_MAJOR_RELEASE), ==, \"02\");\n\tg_assert_cmpstr(fu_hwids_get_value(hwids, FU_HWIDS_KEY_BIOS_MINOR_RELEASE), ==, \"19\");\n\tg_assert_cmpstr(fu_hwids_get_value(hwids, FU_HWIDS_KEY_PRODUCT_SKU),\n\t\t\t==,\n\t\t\t\"LENOVO_MT_20AR_BU_Think_FM_ThinkPad T440s\");\n\tfor (guint i = 0; guids[i].key != NULL; i++) {\n\t\tg_autofree gchar *guid = fu_hwids_get_guid(hwids, guids[i].key, &error);\n\t\tg_assert_no_error(error);\n\t\tg_assert_cmpstr(guid, ==, guids[i].value);\n\t}\n\tfor (guint i = 0; guids[i].key != NULL; i++)\n\t\tg_assert_true(fu_hwids_has_guid(hwids, guids[i].value));\n}\n\nstatic void\n_plugin_device_added_cb(FuPlugin *plugin, FuDevice *device, gpointer user_data)\n{\n\tFuDevice **dev = (FuDevice **)user_data;\n\t*dev = g_object_ref(device);\n\tfu_test_loop_quit();\n}\n\nstatic void\nfu_plugin_config_func(void)\n{\n\tGStatBuf statbuf = {0};\n\tgboolean ret;\n\tgint rc;\n\tg_autofree gchar *conf_dir = NULL;\n\tg_autofree gchar *conf_file = NULL;\n\tg_autofree gchar *fn = NULL;\n\tg_autofree gchar *testdatadir = NULL;\n\tg_autofree gchar *value = NULL;\n\tg_autoptr(FuPlugin) plugin = fu_plugin_new(NULL);\n\tg_autoptr(GError) error = NULL;\n\n\t/* this is a build file */\n\ttestdatadir = g_test_build_filename(G_TEST_BUILT, \"tests\", NULL);\n\t(void)g_setenv(\"FWUPD_SYSCONFDIR\", testdatadir, TRUE);\n\tconf_dir = fu_path_from_kind(FU_PATH_KIND_SYSCONFDIR_PKG);\n\n\t/* remove existing file */\n\tfu_plugin_set_name(plugin, \"test\");\n\tconf_file = g_strdup_printf(\"%s.conf\", fu_plugin_get_name(plugin));\n\tfn = g_build_filename(conf_dir, conf_file, NULL);\n\tret = fu_path_mkdir_parent(fn, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_remove(fn);\n\tret = g_file_set_contents(fn, \"\", -1, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\n\t/* set a value */\n\tret = fu_plugin_set_config_value(plugin, \"Key\", \"True\", &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_assert_true(g_file_test(fn, G_FILE_TEST_EXISTS));\n\n\t/* check it is world readable */\n\trc = g_stat(fn, &statbuf);\n\tg_assert_cmpint(rc, ==, 0);\n\tg_assert_cmpint(statbuf.st_mode & 0777, ==, 0644);\n\n\t/* read back the value */\n\tvalue = fu_plugin_get_config_value(plugin, \"Key\");\n\tg_assert_cmpstr(value, ==, \"True\");\n\tg_assert_true(fu_plugin_get_config_value_boolean(plugin, \"Key\"));\n\n\t/* check it is private, i.e. only readable by the user/group */\n\tret = fu_plugin_set_secure_config_value(plugin, \"Key\", \"False\", &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\trc = g_stat(fn, &statbuf);\n\tg_assert_cmpint(rc, ==, 0);\n\tg_assert_cmpint(statbuf.st_mode & 0777, ==, 0640);\n}\n\nstatic void\nfu_plugin_devices_func(void)\n{\n\tg_autoptr(FuDevice) device = fu_device_new(NULL);\n\tg_autoptr(FuDevice) child = fu_device_new(NULL);\n\tg_autoptr(FuPlugin) plugin = fu_plugin_new(NULL);\n\tGPtrArray *devices;\n\n\tdevices = fu_plugin_get_devices(plugin);\n\tg_assert_nonnull(devices);\n\tg_assert_cmpint(devices->len, ==, 0);\n\n\tfu_device_set_id(device, \"testdev\");\n\tfu_device_set_name(device, \"testdev\");\n\tfu_plugin_device_add(plugin, device);\n\tg_assert_cmpint(devices->len, ==, 1);\n\tfu_plugin_device_remove(plugin, device);\n\tg_assert_cmpint(devices->len, ==, 0);\n\n\t/* add a child after adding the parent to the plugin */\n\tfu_device_set_id(child, \"child\");\n\tfu_device_set_name(child, \"child\");\n\tfu_device_add_child(device, child);\n\tg_assert_cmpint(devices->len, ==, 1);\n\n\t/* remove said child */\n\tfu_device_remove_child(device, child);\n\tg_assert_cmpint(devices->len, ==, 0);\n}\n\nstatic void\nfu_plugin_device_inhibit_children_func(void)\n{\n\tg_autoptr(FuDevice) parent = fu_device_new(NULL);\n\tg_autoptr(FuDevice) child1 = fu_device_new(NULL);\n\tg_autoptr(FuDevice) child2 = fu_device_new(NULL);\n\n\tfu_device_set_id(parent, \"testdev\");\n\tfu_device_set_name(parent, \"testdev\");\n\tfu_device_add_flag(parent, FWUPD_DEVICE_FLAG_UPDATABLE);\n\tfu_device_set_id(child1, \"child1\");\n\tfu_device_set_name(child1, \"child1\");\n\tfu_device_add_flag(child1, FWUPD_DEVICE_FLAG_UPDATABLE);\n\tfu_device_add_child(parent, child1);\n\n\t/* inhibit the parent */\n\tfu_device_inhibit(parent, \"test\", \"because\");\n\tg_assert_false(fu_device_has_flag(parent, FWUPD_DEVICE_FLAG_UPDATABLE));\n\tg_assert_true(fu_device_has_flag(child1, FWUPD_DEVICE_FLAG_UPDATABLE));\n\tfu_device_uninhibit(parent, \"test\");\n\n\t/* make the inhibit propagate to children */\n\tfu_device_add_internal_flag(parent, FU_DEVICE_INTERNAL_FLAG_INHIBIT_CHILDREN);\n\tfu_device_inhibit(parent, \"test\", \"because\");\n\tg_assert_false(fu_device_has_flag(parent, FWUPD_DEVICE_FLAG_UPDATABLE));\n\tg_assert_false(fu_device_has_flag(child1, FWUPD_DEVICE_FLAG_UPDATABLE));\n\n\t/* add a child after the inhibit, which should also be inhibited too */\n\tfu_device_set_id(child2, \"child2\");\n\tfu_device_set_name(child2, \"child2\");\n\tfu_device_add_flag(child2, FWUPD_DEVICE_FLAG_UPDATABLE);\n\tfu_device_add_child(parent, child2);\n\tg_assert_false(fu_device_has_flag(parent, FWUPD_DEVICE_FLAG_UPDATABLE));\n\tg_assert_false(fu_device_has_flag(child1, FWUPD_DEVICE_FLAG_UPDATABLE));\n\tg_assert_false(fu_device_has_flag(child2, FWUPD_DEVICE_FLAG_UPDATABLE));\n}\n\nstatic void\nfu_plugin_delay_func(void)\n{\n\tFuDevice *device_tmp;\n\tg_autoptr(FuPlugin) plugin = NULL;\n\tg_autoptr(FuDevice) device = NULL;\n\n\tplugin = fu_plugin_new(NULL);\n\tg_signal_connect(FU_PLUGIN(plugin),\n\t\t\t \"device-added\",\n\t\t\t G_CALLBACK(_plugin_device_added_cb),\n\t\t\t &device_tmp);\n\tg_signal_connect(FU_PLUGIN(plugin),\n\t\t\t \"device-removed\",\n\t\t\t G_CALLBACK(_plugin_device_added_cb),\n\t\t\t &device_tmp);\n\n\t/* add device straight away */\n\tdevice = fu_device_new(NULL);\n\tfu_device_set_id(device, \"testdev\");\n\tfu_plugin_device_add(plugin, device);\n\tg_assert_nonnull(device_tmp);\n\tg_assert_cmpstr(fu_device_get_id(device_tmp),\n\t\t\t==,\n\t\t\t\"b7eccd0059d6d7dc2ef76c35d6de0048cc8c029d\");\n\tg_clear_object(&device_tmp);\n\n\t/* remove device */\n\tfu_plugin_device_remove(plugin, device);\n\tg_assert_nonnull(device_tmp);\n\tg_assert_cmpstr(fu_device_get_id(device_tmp),\n\t\t\t==,\n\t\t\t\"b7eccd0059d6d7dc2ef76c35d6de0048cc8c029d\");\n\tg_clear_object(&device_tmp);\n}\n\nstatic void\nfu_plugin_quirks_func(void)\n{\n\tconst gchar *tmp;\n\tgboolean ret;\n\tg_autoptr(FuContext) ctx = fu_context_new();\n\tg_autoptr(GError) error = NULL;\n\n\tret = fu_context_load_quirks(ctx, FU_QUIRKS_LOAD_FLAG_NO_CACHE, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\n\t/* USB\\\\VID_0A5C&PID_6412 */\n\ttmp = fu_context_lookup_quirk_by_id(ctx, \"7a1ba7b9-6bcd-54a4-8a36-d60cc5ee935c\", \"Flags\");\n\tg_assert_cmpstr(tmp, ==, \"ignore-runtime\");\n\n\t/* ACME Inc.=True */\n\ttmp = fu_context_lookup_quirk_by_id(ctx, \"ec77e295-7c63-5935-9957-be0472d9593a\", \"Name\");\n\tg_assert_cmpstr(tmp, ==, \"awesome\");\n\n\t/* CORP* */\n\ttmp = fu_context_lookup_quirk_by_id(ctx, \"3731cce4-484c-521f-a652-892c8e0a65c7\", \"Name\");\n\tg_assert_cmpstr(tmp, ==, \"town\");\n\n\t/* baz */\n\ttmp = fu_context_lookup_quirk_by_id(ctx, \"579a3b1c-d1db-5bdc-b6b9-e2c1b28d5b8a\", \"Unfound\");\n\tg_assert_cmpstr(tmp, ==, NULL);\n\n\t/* unfound */\n\ttmp = fu_context_lookup_quirk_by_id(ctx, \"8ff2ed23-b37e-5f61-b409-b7fe9563be36\", \"tests\");\n\tg_assert_cmpstr(tmp, ==, NULL);\n\n\t/* unfound */\n\ttmp = fu_context_lookup_quirk_by_id(ctx, \"8ff2ed23-b37e-5f61-b409-b7fe9563be36\", \"unfound\");\n\tg_assert_cmpstr(tmp, ==, NULL);\n\n\t/* GUID */\n\ttmp = fu_context_lookup_quirk_by_id(ctx, \"bb9ec3e2-77b3-53bc-a1f1-b05916715627\", \"Flags\");\n\tg_assert_cmpstr(tmp, ==, \"clever\");\n}\n\nstatic void\nfu_plugin_quirks_performance_func(void)\n{\n\tgboolean ret;\n\tg_autoptr(FuQuirks) quirks = fu_quirks_new();\n\tg_autoptr(GTimer) timer = g_timer_new();\n\tg_autoptr(GError) error = NULL;\n\tconst gchar *keys[] = {\"Name\", \"Children\", \"Flags\", NULL};\n\n\tret = fu_quirks_load(quirks, FU_QUIRKS_LOAD_FLAG_NO_CACHE, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\n\t/* lookup */\n\tg_timer_reset(timer);\n\tfor (guint j = 0; j < 1000; j++) {\n\t\tconst gchar *group = \"bb9ec3e2-77b3-53bc-a1f1-b05916715627\";\n\t\tfor (guint i = 0; keys[i] != NULL; i++) {\n\t\t\tconst gchar *tmp = fu_quirks_lookup_by_id(quirks, group, keys[i]);\n\t\t\tg_assert_cmpstr(tmp, !=, NULL);\n\t\t}\n\t}\n\tg_print(\"lookup=%.3fms \", g_timer_elapsed(timer, NULL) * 1000.f);\n}\n\nstatic void\nfu_plugin_quirks_device_func(void)\n{\n\tFuDevice *device_tmp;\n\tGPtrArray *children;\n\tgboolean ret;\n\tg_autoptr(FuDevice) device = fu_device_new(NULL);\n\tg_autoptr(FuContext) ctx = fu_context_new();\n\tg_autoptr(GError) error = NULL;\n\n\tret = fu_context_load_quirks(ctx, FU_QUIRKS_LOAD_FLAG_NO_CACHE, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\n\t/* use quirk file to set device attributes */\n\tfu_device_set_physical_id(device, \"usb:00:05\");\n\tfu_device_set_context(device, ctx);\n\tfu_device_add_flag(device, FWUPD_DEVICE_FLAG_UPDATABLE);\n\tfu_device_add_instance_id(device, \"USB\\\\VID_0BDA&PID_1100\");\n\tfu_device_convert_instance_ids(device);\n\tg_assert_cmpstr(fu_device_get_name(device), ==, \"Hub\");\n\n\t/* ensure children are created */\n\tchildren = fu_device_get_children(device);\n\tg_assert_cmpint(children->len, ==, 1);\n\tdevice_tmp = g_ptr_array_index(children, 0);\n\tg_assert_cmpstr(fu_device_get_name(device_tmp), ==, \"HDMI\");\n\tg_assert_true(fu_device_has_flag(device_tmp, FWUPD_DEVICE_FLAG_UPDATABLE));\n}\n\nstatic void\nfu_common_kernel_lockdown_func(void)\n{\n\tgboolean ret;\n\tg_autofree gchar *locked_dir = NULL;\n\tg_autofree gchar *none_dir = NULL;\n\tg_autofree gchar *old_kernel_dir = NULL;\n\n#ifndef __linux__\n\tg_test_skip(\"only works on Linux\");\n\treturn;\n#endif\n\n\told_kernel_dir = g_test_build_filename(G_TEST_DIST, \"tests\", \"lockdown\", NULL);\n\t(void)g_setenv(\"FWUPD_SYSFSSECURITYDIR\", old_kernel_dir, TRUE);\n\tret = fu_kernel_locked_down();\n\tg_assert_false(ret);\n\n\tlocked_dir = g_test_build_filename(G_TEST_DIST, \"tests\", \"lockdown\", \"locked\", NULL);\n\t(void)g_setenv(\"FWUPD_SYSFSSECURITYDIR\", locked_dir, TRUE);\n\tret = fu_kernel_locked_down();\n\tg_assert_true(ret);\n\n\tnone_dir = g_test_build_filename(G_TEST_DIST, \"tests\", \"lockdown\", \"none\", NULL);\n\t(void)g_setenv(\"FWUPD_SYSFSSECURITYDIR\", none_dir, TRUE);\n\tret = fu_kernel_locked_down();\n\tg_assert_false(ret);\n}\n\nstatic gboolean\n_open_cb(GObject *device, GError **error)\n{\n\tg_assert_cmpstr(g_object_get_data(device, \"state\"), ==, \"closed\");\n\tg_object_set_data(device, \"state\", (gpointer) \"opened\");\n\treturn TRUE;\n}\n\nstatic gboolean\n_close_cb(GObject *device, GError **error)\n{\n\tg_assert_cmpstr(g_object_get_data(device, \"state\"), ==, \"opened\");\n\tg_object_set_data(device, \"state\", (gpointer) \"closed-on-unref\");\n\treturn TRUE;\n}\n\nstatic void\nfu_device_locker_func(void)\n{\n\tg_autoptr(FuDeviceLocker) locker = NULL;\n\tg_autoptr(GError) error = NULL;\n\tg_autoptr(GObject) device = g_object_new(G_TYPE_OBJECT, NULL);\n\n\tg_object_set_data(device, \"state\", (gpointer) \"closed\");\n\tlocker = fu_device_locker_new_full(device, _open_cb, _close_cb, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(locker);\n\tg_clear_object(&locker);\n\tg_assert_cmpstr(g_object_get_data(device, \"state\"), ==, \"closed-on-unref\");\n}\n\nstatic gboolean\n_fail_open_cb(FuDevice *device, GError **error)\n{\n\tfu_device_set_metadata_boolean(device, \"Test::Open\", TRUE);\n\tg_set_error_literal(error, G_IO_ERROR, G_IO_ERROR_FAILED, \"fail\");\n\treturn FALSE;\n}\n\nstatic gboolean\n_fail_close_cb(FuDevice *device, GError **error)\n{\n\tfu_device_set_metadata_boolean(device, \"Test::Close\", TRUE);\n\tg_set_error_literal(error, G_IO_ERROR, G_IO_ERROR_BUSY, \"busy\");\n\treturn FALSE;\n}\n\nstatic void\nfu_device_locker_fail_func(void)\n{\n\tg_autoptr(FuDeviceLocker) locker = NULL;\n\tg_autoptr(GError) error = NULL;\n\tg_autoptr(FuDevice) device = fu_device_new(NULL);\n\tlocker = fu_device_locker_new_full(device,\n\t\t\t\t\t   (FuDeviceLockerFunc)_fail_open_cb,\n\t\t\t\t\t   (FuDeviceLockerFunc)_fail_close_cb,\n\t\t\t\t\t   &error);\n\tg_assert_error(error, G_IO_ERROR, G_IO_ERROR_FAILED);\n\tg_assert_null(locker);\n\tg_assert_true(fu_device_get_metadata_boolean(device, \"Test::Open\"));\n\tg_assert_true(fu_device_get_metadata_boolean(device, \"Test::Close\"));\n\tg_assert_false(fu_device_has_internal_flag(device, FU_DEVICE_INTERNAL_FLAG_IS_OPEN));\n}\n\nstatic void\nfu_common_endian_func(void)\n{\n\tguint8 buf[3];\n\n\tfu_memwrite_uint16(buf, 0x1234, G_LITTLE_ENDIAN);\n\tg_assert_cmpint(buf[0], ==, 0x34);\n\tg_assert_cmpint(buf[1], ==, 0x12);\n\tg_assert_cmpint(fu_memread_uint16(buf, G_LITTLE_ENDIAN), ==, 0x1234);\n\n\tfu_memwrite_uint16(buf, 0x1234, G_BIG_ENDIAN);\n\tg_assert_cmpint(buf[0], ==, 0x12);\n\tg_assert_cmpint(buf[1], ==, 0x34);\n\tg_assert_cmpint(fu_memread_uint16(buf, G_BIG_ENDIAN), ==, 0x1234);\n\n\tfu_memwrite_uint24(buf, 0x123456, G_LITTLE_ENDIAN);\n\tg_assert_cmpint(buf[0], ==, 0x56);\n\tg_assert_cmpint(buf[1], ==, 0x34);\n\tg_assert_cmpint(buf[2], ==, 0x12);\n\tg_assert_cmpint(fu_memread_uint24(buf, G_LITTLE_ENDIAN), ==, 0x123456);\n\n\tfu_memwrite_uint24(buf, 0x123456, G_BIG_ENDIAN);\n\tg_assert_cmpint(buf[0], ==, 0x12);\n\tg_assert_cmpint(buf[1], ==, 0x34);\n\tg_assert_cmpint(buf[2], ==, 0x56);\n\tg_assert_cmpint(fu_memread_uint24(buf, G_BIG_ENDIAN), ==, 0x123456);\n}\n\nstatic void\nfu_common_cabinet_func(void)\n{\n\tg_autoptr(FuCabinet) cabinet = fu_cabinet_new();\n\tg_autoptr(GBytes) blob1 = NULL;\n\tg_autoptr(GBytes) blob2 = NULL;\n\tg_autoptr(GBytes) jcat_blob1 = g_bytes_new_static(\"hello\", 6);\n\tg_autoptr(GBytes) jcat_blob2 = g_bytes_new_static(\"hellX\", 6);\n\tg_autoptr(GError) error = NULL;\n\n\t/* add */\n\tfu_cabinet_add_file(cabinet, \"firmware.jcat\", jcat_blob1);\n\n\t/* replace */\n\tfu_cabinet_add_file(cabinet, \"firmware.jcat\", jcat_blob2);\n\n\t/* get data */\n\tblob1 = fu_cabinet_get_file(cabinet, \"firmware.jcat\", &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(blob1);\n\tg_assert_cmpstr(g_bytes_get_data(blob1, NULL), ==, \"hellX\");\n\n\t/* get data that does not exist */\n\tblob2 = fu_cabinet_get_file(cabinet, \"foo.jcat\", &error);\n\tg_assert_error(error, FWUPD_ERROR, FWUPD_ERROR_INVALID_FILE);\n\tg_assert_null(blob2);\n}\n\nstatic void\nfu_common_bytes_get_data_func(void)\n{\n\tconst gchar *fn = \"/tmp/fwupdzero\";\n\tconst guint8 *buf;\n\tgboolean ret;\n\tg_autoptr(GBytes) bytes1 = NULL;\n\tg_autoptr(GBytes) bytes2 = NULL;\n\tg_autoptr(GError) error = NULL;\n\tg_autoptr(GMappedFile) mmap = NULL;\n\n\t/* create file with zero size */\n\tret = g_file_set_contents(fn, NULL, 0, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\n\t/* check we got zero sized data */\n\tbytes1 = fu_bytes_get_contents(fn, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(bytes1);\n\tg_assert_cmpint(g_bytes_get_size(bytes1), ==, 0);\n\tg_assert_nonnull(g_bytes_get_data(bytes1, NULL));\n\n\t/* do the same with an mmap mapping, which returns NULL on empty file */\n\tmmap = g_mapped_file_new(fn, FALSE, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(mmap);\n\tbytes2 = g_mapped_file_get_bytes(mmap);\n\tg_assert_nonnull(bytes2);\n\tg_assert_cmpint(g_bytes_get_size(bytes2), ==, 0);\n\tg_assert_null(g_bytes_get_data(bytes2, NULL));\n\n\t/* use the safe function */\n\tbuf = fu_bytes_get_data_safe(bytes2, NULL, &error);\n\tg_assert_error(error, G_IO_ERROR, G_IO_ERROR_INVALID_DATA);\n\tg_assert_null(buf);\n}\n\nstatic gboolean\nfu_device_poll_cb(FuDevice *device, GError **error)\n{\n\tguint64 cnt = fu_device_get_metadata_integer(device, \"cnt\");\n\tg_debug(\"poll cnt=%\" G_GUINT64_FORMAT, cnt);\n\tfu_device_set_metadata_integer(device, \"cnt\", cnt + 1);\n\treturn TRUE;\n}\n\nstatic void\nfu_device_poll_func(void)\n{\n\tg_autoptr(FuDevice) device = fu_device_new(NULL);\n\tFuDeviceClass *klass = FU_DEVICE_GET_CLASS(device);\n\tguint cnt;\n\n\t/* set up a 10ms poll */\n\tklass->poll = fu_device_poll_cb;\n\tfu_device_set_metadata_integer(device, \"cnt\", 0);\n\tfu_device_set_poll_interval(device, 10);\n\tfu_test_loop_run_with_timeout(100);\n\tfu_test_loop_quit();\n\tcnt = fu_device_get_metadata_integer(device, \"cnt\");\n\tg_assert_cmpint(cnt, >=, 8);\n\n\t/* disable the poll */\n\tfu_device_set_poll_interval(device, 0);\n\tfu_test_loop_run_with_timeout(100);\n\tfu_test_loop_quit();\n\tg_assert_cmpint(fu_device_get_metadata_integer(device, \"cnt\"), ==, cnt);\n}\n\nstatic void\nfu_device_func(void)\n{\n\tg_autoptr(FuDevice) device = fu_device_new(NULL);\n\tg_autoptr(GPtrArray) possible_plugins = NULL;\n\n\t/* only add one plugin name of the same type */\n\tfu_device_add_possible_plugin(device, \"test\");\n\tfu_device_add_possible_plugin(device, \"test\");\n\tpossible_plugins = fu_device_get_possible_plugins(device);\n\tg_assert_cmpint(possible_plugins->len, ==, 1);\n\n\tg_assert_cmpint(fu_device_get_backend_tags(device)->len, ==, 0);\n\tfu_device_add_backend_tag(device, \"foo\");\n\tfu_device_add_backend_tag(device, \"bar\");\n\tg_assert_cmpint(fu_device_get_backend_tags(device)->len, ==, 2);\n\tg_assert_true(fu_device_has_backend_tag(device, \"foo\"));\n\tg_assert_false(fu_device_has_backend_tag(device, \"bazbazbazbazbaz\"));\n}\n\nstatic void\nfu_device_instance_ids_func(void)\n{\n\tgboolean ret;\n\tg_autoptr(FuContext) ctx = fu_context_new();\n\tg_autoptr(FuDevice) device = fu_device_new(ctx);\n\tg_autoptr(GError) error = NULL;\n\n\t/* do not save silo */\n\tret = fu_context_load_quirks(ctx, FU_QUIRKS_LOAD_FLAG_NO_CACHE, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\n\t/* sanity check */\n\tg_assert_false(fu_device_has_guid(device, \"c0a26214-223b-572a-9477-cde897fe8619\"));\n\n\t/* add a deferred instance ID that only gets converted on ->setup */\n\tfu_device_add_instance_id(device, \"foobarbaz\");\n\tg_assert_false(fu_device_has_guid(device, \"c0a26214-223b-572a-9477-cde897fe8619\"));\n\n\tret = fu_device_setup(device, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_assert_true(fu_device_has_guid(device, \"c0a26214-223b-572a-9477-cde897fe8619\"));\n\n\t/* this gets added immediately */\n\tfu_device_add_instance_id(device, \"bazbarfoo\");\n\tg_assert_true(fu_device_has_guid(device, \"77e49bb0-2cd6-5faf-bcee-5b7fbe6e944d\"));\n}\n\nstatic void\nfu_device_composite_id_func(void)\n{\n\tg_autoptr(FuDevice) dev1 = fu_device_new(NULL);\n\tg_autoptr(FuDevice) dev2 = fu_device_new(NULL);\n\tg_autoptr(FuDevice) dev3 = fu_device_new(NULL);\n\tg_autoptr(FuDevice) dev4 = fu_device_new(NULL);\n\n\t/* single device */\n\tfu_device_set_id(dev1, \"dev1\");\n\tg_assert_cmpstr(fu_device_get_composite_id(dev1),\n\t\t\t==,\n\t\t\t\"3b42553c4e3241e8f3f8fbc19a69fa2f95708a9d\");\n\tfu_device_set_id(dev2, \"dev2\");\n\n\t/* one child */\n\tfu_device_add_child(dev1, dev2);\n\tg_assert_cmpstr(fu_device_get_composite_id(dev1),\n\t\t\t==,\n\t\t\t\"3b42553c4e3241e8f3f8fbc19a69fa2f95708a9d\");\n\tg_assert_cmpstr(fu_device_get_composite_id(dev2),\n\t\t\t==,\n\t\t\t\"3b42553c4e3241e8f3f8fbc19a69fa2f95708a9d\");\n\n\t/* add a different \"family\" */\n\tfu_device_set_id(dev3, \"dev3\");\n\tfu_device_set_id(dev4, \"dev4\");\n\tfu_device_add_child(dev3, dev4);\n\tfu_device_add_child(dev2, dev3);\n\tg_assert_cmpstr(fu_device_get_composite_id(dev1),\n\t\t\t==,\n\t\t\t\"3b42553c4e3241e8f3f8fbc19a69fa2f95708a9d\");\n\tg_assert_cmpstr(fu_device_get_composite_id(dev2),\n\t\t\t==,\n\t\t\t\"3b42553c4e3241e8f3f8fbc19a69fa2f95708a9d\");\n\tg_assert_cmpstr(fu_device_get_composite_id(dev3),\n\t\t\t==,\n\t\t\t\"3b42553c4e3241e8f3f8fbc19a69fa2f95708a9d\");\n\tg_assert_cmpstr(fu_device_get_composite_id(dev4),\n\t\t\t==,\n\t\t\t\"3b42553c4e3241e8f3f8fbc19a69fa2f95708a9d\");\n\n\t/* change the parent ID */\n\tfu_device_set_id(dev1, \"dev1-NEW\");\n\tg_assert_cmpstr(fu_device_get_composite_id(dev1),\n\t\t\t==,\n\t\t\t\"a4c8efc6a0a58c2dc14c05fd33186703f7352997\");\n\tg_assert_cmpstr(fu_device_get_composite_id(dev2),\n\t\t\t==,\n\t\t\t\"a4c8efc6a0a58c2dc14c05fd33186703f7352997\");\n}\n\nstatic void\nfu_device_inhibit_func(void)\n{\n\tg_autoptr(FuDevice) device = fu_device_new(NULL);\n\n\tfu_device_add_flag(device, FWUPD_DEVICE_FLAG_UPDATABLE);\n\tfu_device_set_battery_threshold(device, 25);\n\tg_assert_true(fu_device_has_flag(device, FWUPD_DEVICE_FLAG_UPDATABLE));\n\tg_assert_false(fu_device_has_flag(device, FWUPD_DEVICE_FLAG_UPDATABLE_HIDDEN));\n\n\t/* does not exist -> fine */\n\tfu_device_uninhibit(device, \"NOTGOINGTOEXIST\");\n\tg_assert_false(fu_device_has_inhibit(device, \"NOTGOINGTOEXIST\"));\n\n\t/* first one */\n\tfu_device_inhibit(device, \"needs-activation\", \"Device is pending activation\");\n\tg_assert_true(fu_device_has_inhibit(device, \"needs-activation\"));\n\tg_assert_true(fu_device_has_flag(device, FWUPD_DEVICE_FLAG_UPDATABLE_HIDDEN));\n\tg_assert_false(fu_device_has_flag(device, FWUPD_DEVICE_FLAG_UPDATABLE));\n\n\t/* another */\n\tfu_device_set_battery_level(device, 5);\n\tg_assert_true(fu_device_has_flag(device, FWUPD_DEVICE_FLAG_UPDATABLE_HIDDEN));\n\tg_assert_false(fu_device_has_flag(device, FWUPD_DEVICE_FLAG_UPDATABLE));\n\n\t/* activated, power still too low */\n\tfu_device_uninhibit(device, \"needs-activation\");\n\tg_assert_false(fu_device_has_inhibit(device, \"needs-activation\"));\n\tg_assert_true(fu_device_has_flag(device, FWUPD_DEVICE_FLAG_UPDATABLE_HIDDEN));\n\tg_assert_false(fu_device_has_flag(device, FWUPD_DEVICE_FLAG_UPDATABLE));\n\n\t/* we got some more power -> fine */\n\tfu_device_set_battery_level(device, 95);\n\tg_assert_true(fu_device_has_flag(device, FWUPD_DEVICE_FLAG_UPDATABLE));\n\tg_assert_false(fu_device_has_flag(device, FWUPD_DEVICE_FLAG_UPDATABLE_HIDDEN));\n}\n\nstatic void\nfu_device_inhibit_updateable_func(void)\n{\n\tg_autoptr(FuDevice) device = fu_device_new(NULL);\n\n\tg_assert_false(fu_device_has_flag(device, FWUPD_DEVICE_FLAG_UPDATABLE));\n\tg_assert_false(fu_device_has_flag(device, FWUPD_DEVICE_FLAG_UPDATABLE_HIDDEN));\n\tg_assert_cmpstr(fu_device_get_update_error(device), ==, NULL);\n\n\t/* first one */\n\tfu_device_inhibit(device, \"needs-activation\", \"Device is pending activation\");\n\tg_assert_false(fu_device_has_flag(device, FWUPD_DEVICE_FLAG_UPDATABLE_HIDDEN));\n\tg_assert_false(fu_device_has_flag(device, FWUPD_DEVICE_FLAG_UPDATABLE));\n\tg_assert_cmpstr(fu_device_get_update_error(device), ==, \"Device is pending activation\");\n\n\t/* activated, but still not updatable */\n\tfu_device_uninhibit(device, \"needs-activation\");\n\tg_assert_false(fu_device_has_flag(device, FWUPD_DEVICE_FLAG_UPDATABLE));\n\tg_assert_false(fu_device_has_flag(device, FWUPD_DEVICE_FLAG_UPDATABLE_HIDDEN));\n\tg_assert_cmpstr(fu_device_get_update_error(device), ==, NULL);\n}\n\n#define TEST_FLAG_FOO (1 << 0)\n#define TEST_FLAG_BAR (1 << 1)\n#define TEST_FLAG_BAZ (1 << 2)\n\nstatic void\nfu_device_private_flags_func(void)\n{\n\tg_autofree gchar *tmp = NULL;\n\tg_autoptr(FuDevice) device = fu_device_new(NULL);\n\n\tfu_device_register_private_flag(device, TEST_FLAG_FOO, \"foo\");\n\tfu_device_register_private_flag(device, TEST_FLAG_BAR, \"bar\");\n\n\tfu_device_set_custom_flags(device, \"foo\");\n\tg_assert_cmpint(fu_device_get_private_flags(device), ==, TEST_FLAG_FOO);\n\tfu_device_set_custom_flags(device, \"bar\");\n\tg_assert_cmpint(fu_device_get_private_flags(device), ==, TEST_FLAG_FOO | TEST_FLAG_BAR);\n\tfu_device_set_custom_flags(device, \"~bar\");\n\tg_assert_cmpint(fu_device_get_private_flags(device), ==, TEST_FLAG_FOO);\n\tfu_device_set_custom_flags(device, \"baz\");\n\tg_assert_cmpint(fu_device_get_private_flags(device), ==, TEST_FLAG_FOO);\n\tfu_device_add_private_flag(device, TEST_FLAG_BAZ);\n\tg_assert_cmpint(fu_device_get_private_flags(device), ==, TEST_FLAG_FOO | TEST_FLAG_BAZ);\n\n\ttmp = fu_device_to_string(device);\n\tg_assert_cmpstr(tmp,\n\t\t\t==,\n\t\t\t\"FuDevice:\\n\"\n\t\t\t\"  Flags:                none\\n\"\n\t\t\t\"  AcquiesceDelay:       50\\n\"\n\t\t\t\"  CustomFlags:          baz\\n\"\n\t\t\t\"  PrivateFlags:         foo\\n\");\n}\n\nstatic void\nfu_device_flags_func(void)\n{\n\tg_autoptr(FuDevice) device = fu_device_new(NULL);\n\n\t/* bitfield */\n\tfor (guint64 i = 1; i < FU_DEVICE_INTERNAL_FLAG_UNKNOWN; i *= 2) {\n\t\tconst gchar *tmp = fu_device_internal_flag_to_string(i);\n\t\tif (tmp == NULL)\n\t\t\tbreak;\n\t\tg_assert_cmpint(fu_device_internal_flag_from_string(tmp), ==, i);\n\t}\n\n\tg_assert_cmpint(fu_device_get_flags(device), ==, FWUPD_DEVICE_FLAG_NONE);\n\n\t/* remove IS_BOOTLOADER if is a BOOTLOADER */\n\tfu_device_add_flag(device, FWUPD_DEVICE_FLAG_IS_BOOTLOADER);\n\tfu_device_add_flag(device, FWUPD_DEVICE_FLAG_NEEDS_BOOTLOADER);\n\tg_assert_cmpint(fu_device_get_flags(device), ==, FWUPD_DEVICE_FLAG_NEEDS_BOOTLOADER);\n\tfu_device_remove_flag(device, FWUPD_DEVICE_FLAG_NEEDS_BOOTLOADER);\n\n\t/* check implication */\n\tfu_device_add_flag(device, FWUPD_DEVICE_FLAG_CAN_VERIFY_IMAGE);\n\tg_assert_cmpint(fu_device_get_flags(device),\n\t\t\t==,\n\t\t\tFWUPD_DEVICE_FLAG_CAN_VERIFY_IMAGE | FWUPD_DEVICE_FLAG_CAN_VERIFY);\n\tfu_device_remove_flag(device,\n\t\t\t      FWUPD_DEVICE_FLAG_CAN_VERIFY | FWUPD_DEVICE_FLAG_CAN_VERIFY_IMAGE);\n\n\t/* negation */\n\tfu_device_set_custom_flags(device, \"is-bootloader,updatable\");\n\tg_assert_cmpint(fu_device_get_flags(device),\n\t\t\t==,\n\t\t\tFWUPD_DEVICE_FLAG_IS_BOOTLOADER | FWUPD_DEVICE_FLAG_UPDATABLE);\n\tfu_device_set_custom_flags(device, \"~is-bootloader\");\n\tg_assert_cmpint(fu_device_get_flags(device), ==, FWUPD_DEVICE_FLAG_UPDATABLE);\n}\n\nstatic void\nfu_device_children_func(void)\n{\n\tgboolean ret;\n\tg_autoptr(FuContext) ctx = fu_context_new();\n\tg_autoptr(FuDevice) child = fu_device_new(NULL);\n\tg_autoptr(FuDevice) parent = fu_device_new(ctx);\n\tg_autoptr(GError) error = NULL;\n\n\t/* do not save silo */\n\tret = fu_context_load_quirks(ctx, FU_QUIRKS_LOAD_FLAG_NO_CACHE, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\n\tfu_device_set_physical_id(child, \"dummy\");\n\tfu_device_set_physical_id(parent, \"dummy\");\n\n\t/* set up family */\n\tfu_device_add_child(parent, child);\n\n\t/* set an instance ID that will be converted to a GUID when the parent\n\t * calls ->setup */\n\tfu_device_add_instance_id(child, \"foo\");\n\tg_assert_false(fu_device_has_guid(child, \"b84ed8ed-a7b1-502f-83f6-90132e68adef\"));\n\n\t/* setup parent, which also calls setup on child too (and thus also\n\t * converts the instance ID to a GUID) */\n\tret = fu_device_setup(parent, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_assert_true(fu_device_has_guid(child, \"b84ed8ed-a7b1-502f-83f6-90132e68adef\"));\n}\n\nstatic void\nfu_device_parent_func(void)\n{\n\tg_autoptr(FuDevice) child = fu_device_new(NULL);\n\tg_autoptr(FuDevice) child_root = NULL;\n\tg_autoptr(FuDevice) grandparent = fu_device_new(NULL);\n\tg_autoptr(FuDevice) grandparent_root = NULL;\n\tg_autoptr(FuDevice) parent = fu_device_new(NULL);\n\tg_autoptr(FuDevice) parent_root = NULL;\n\n\tfu_device_set_physical_id(child, \"dummy\");\n\tfu_device_set_physical_id(grandparent, \"dummy\");\n\tfu_device_set_physical_id(parent, \"dummy\");\n\n\t/* set up three layer family */\n\tfu_device_add_child(grandparent, parent);\n\tfu_device_add_child(parent, child);\n\n\t/* check parents */\n\tg_assert_true(fu_device_get_parent(child) == parent);\n\tg_assert_true(fu_device_get_parent(parent) == grandparent);\n\tg_assert_true(fu_device_get_parent(grandparent) == NULL);\n\n\t/* check root */\n\tchild_root = fu_device_get_root(child);\n\tg_assert_true(child_root == grandparent);\n\tparent_root = fu_device_get_root(parent);\n\tg_assert_true(parent_root == grandparent);\n\tgrandparent_root = fu_device_get_root(child);\n\tg_assert_true(grandparent_root == grandparent);\n}\n\nstatic void\nfu_device_incorporate_func(void)\n{\n\tgboolean ret;\n\tg_autoptr(FuContext) ctx = fu_context_new();\n\tg_autoptr(FuDevice) device = fu_device_new(ctx);\n\tg_autoptr(FuDevice) donor = fu_device_new(ctx);\n\tg_autoptr(GError) error = NULL;\n\n\t/* set up donor device */\n\tfu_device_set_alternate_id(donor, \"alt-id\");\n\tfu_device_set_equivalent_id(donor, \"equiv-id\");\n\tfu_device_set_metadata(donor, \"test\", \"me\");\n\tfu_device_set_metadata(donor, \"test2\", \"me\");\n\tfu_device_add_instance_str(donor, \"VID\", \"1234\");\n\n\t/* base properties */\n\tfu_device_add_flag(donor, FWUPD_DEVICE_FLAG_REQUIRE_AC);\n\tfu_device_set_created(donor, 123);\n\tfu_device_set_modified(donor, 456);\n\tfu_device_add_icon(donor, \"computer\");\n\n\t/* existing properties */\n\tfu_device_set_equivalent_id(device, \"DO_NOT_OVERWRITE\");\n\tfu_device_set_metadata(device, \"test2\", \"DO_NOT_OVERWRITE\");\n\tfu_device_set_modified(device, 789);\n\n\t/* incorporate properties from donor to device */\n\tfu_device_incorporate(device, donor);\n\tg_assert_cmpstr(fu_device_get_alternate_id(device), ==, \"alt-id\");\n\tg_assert_cmpstr(fu_device_get_equivalent_id(device), ==, \"DO_NOT_OVERWRITE\");\n\tg_assert_cmpstr(fu_device_get_metadata(device, \"test\"), ==, \"me\");\n\tg_assert_cmpstr(fu_device_get_metadata(device, \"test2\"), ==, \"DO_NOT_OVERWRITE\");\n\tg_assert_true(fu_device_has_flag(device, FWUPD_DEVICE_FLAG_REQUIRE_AC));\n\tg_assert_cmpint(fu_device_get_created(device), ==, 123);\n\tg_assert_cmpint(fu_device_get_modified(device), ==, 789);\n\tg_assert_cmpint(fu_device_get_icons(device)->len, ==, 1);\n\tret = fu_device_build_instance_id(device, &error, \"SUBSYS\", \"VID\", NULL);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_assert_true(fu_device_has_instance_id(device, \"SUBSYS\\\\VID_1234\"));\n}\n\nstatic void\nfu_backend_func(void)\n{\n\tFuDevice *dev;\n\tgboolean ret;\n\tg_autoptr(FuBackend) backend = g_object_new(FU_TYPE_BACKEND, NULL);\n\tg_autoptr(FuDevice) dev1 = fu_device_new(NULL);\n\tg_autoptr(FuDevice) dev2 = fu_device_new(NULL);\n\tg_autoptr(FuProgress) progress = fu_progress_new(G_STRLOC);\n\tg_autoptr(GError) error = NULL;\n\tg_autoptr(GPtrArray) devices = NULL;\n\n\t/* defaults */\n\tg_assert_null(fu_backend_get_name(backend));\n\tg_assert_true(fu_backend_get_enabled(backend));\n\n\t/* load */\n\tret = fu_backend_setup(backend, progress, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tret = fu_backend_coldplug(backend, progress, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\n\t/* add two devices, then remove one of them */\n\tfu_device_set_physical_id(dev1, \"dev1\");\n\tfu_backend_device_added(backend, dev1);\n\tfu_device_set_physical_id(dev2, \"dev2\");\n\tfu_backend_device_added(backend, dev2);\n\tfu_backend_device_changed(backend, dev2);\n\tfu_backend_device_removed(backend, dev2);\n\n\tdev = fu_backend_lookup_by_id(backend, \"dev1\");\n\tg_assert_nonnull(dev);\n\tg_assert_true(dev == dev1);\n\n\t/* should have been removed */\n\tdev = fu_backend_lookup_by_id(backend, \"dev2\");\n\tg_assert_null(dev);\n\n\t/* get linear array */\n\tdevices = fu_backend_get_devices(backend);\n\tg_assert_nonnull(devices);\n\tg_assert_cmpint(devices->len, ==, 1);\n\tdev = g_ptr_array_index(devices, 0);\n\tg_assert_nonnull(dev);\n\tg_assert_true(dev == dev1);\n}\n\nstatic void\nfu_chunk_func(void)\n{\n\tg_autofree gchar *chunked1_str = NULL;\n\tg_autofree gchar *chunked2_str = NULL;\n\tg_autofree gchar *chunked3_str = NULL;\n\tg_autofree gchar *chunked4_str = NULL;\n\tg_autoptr(GPtrArray) chunked1 = NULL;\n\tg_autoptr(GPtrArray) chunked2 = NULL;\n\tg_autoptr(GPtrArray) chunked3 = NULL;\n\tg_autoptr(GPtrArray) chunked4 = NULL;\n\n\tchunked3 = fu_chunk_array_new((const guint8 *)\"123456\", 6, 0x0, 3, 3);\n\tchunked3_str = fu_chunk_array_to_string(chunked3);\n\tg_assert_cmpstr(chunked3_str,\n\t\t\t==,\n\t\t\t\"<chunks>\\n\"\n\t\t\t\"  <chunk>\\n\"\n\t\t\t\"    <data size=\\\"0x3\\\">123</data>\\n\"\n\t\t\t\"  </chunk>\\n\"\n\t\t\t\"  <chunk>\\n\"\n\t\t\t\"    <idx>0x1</idx>\\n\"\n\t\t\t\"    <page>0x1</page>\\n\"\n\t\t\t\"    <data size=\\\"0x3\\\">456</data>\\n\"\n\t\t\t\"  </chunk>\\n\"\n\t\t\t\"</chunks>\\n\");\n\n\tchunked4 = fu_chunk_array_new((const guint8 *)\"123456\", 6, 0x4, 4, 4);\n\tchunked4_str = fu_chunk_array_to_string(chunked4);\n\tg_assert_cmpstr(chunked4_str,\n\t\t\t==,\n\t\t\t\"<chunks>\\n\"\n\t\t\t\"  <chunk>\\n\"\n\t\t\t\"    <page>0x1</page>\\n\"\n\t\t\t\"    <data size=\\\"0x4\\\">1234</data>\\n\"\n\t\t\t\"  </chunk>\\n\"\n\t\t\t\"  <chunk>\\n\"\n\t\t\t\"    <idx>0x1</idx>\\n\"\n\t\t\t\"    <page>0x2</page>\\n\"\n\t\t\t\"    <data size=\\\"0x2\\\">56</data>\\n\"\n\t\t\t\"  </chunk>\\n\"\n\t\t\t\"</chunks>\\n\");\n\n\tchunked1 = fu_chunk_array_new((const guint8 *)\"0123456789abcdef\", 16, 0x0, 10, 4);\n\tchunked1_str = fu_chunk_array_to_string(chunked1);\n\tg_assert_cmpstr(chunked1_str,\n\t\t\t==,\n\t\t\t\"<chunks>\\n\"\n\t\t\t\"  <chunk>\\n\"\n\t\t\t\"    <data size=\\\"0x4\\\">0123</data>\\n\"\n\t\t\t\"  </chunk>\\n\"\n\t\t\t\"  <chunk>\\n\"\n\t\t\t\"    <idx>0x1</idx>\\n\"\n\t\t\t\"    <addr>0x4</addr>\\n\"\n\t\t\t\"    <data size=\\\"0x4\\\">4567</data>\\n\"\n\t\t\t\"  </chunk>\\n\"\n\t\t\t\"  <chunk>\\n\"\n\t\t\t\"    <idx>0x2</idx>\\n\"\n\t\t\t\"    <addr>0x8</addr>\\n\"\n\t\t\t\"    <data size=\\\"0x2\\\">89</data>\\n\"\n\t\t\t\"  </chunk>\\n\"\n\t\t\t\"  <chunk>\\n\"\n\t\t\t\"    <idx>0x3</idx>\\n\"\n\t\t\t\"    <page>0x1</page>\\n\"\n\t\t\t\"    <data size=\\\"0x4\\\">abcd</data>\\n\"\n\t\t\t\"  </chunk>\\n\"\n\t\t\t\"  <chunk>\\n\"\n\t\t\t\"    <idx>0x4</idx>\\n\"\n\t\t\t\"    <page>0x1</page>\\n\"\n\t\t\t\"    <addr>0x4</addr>\\n\"\n\t\t\t\"    <data size=\\\"0x2\\\">ef</data>\\n\"\n\t\t\t\"  </chunk>\\n\"\n\t\t\t\"</chunks>\\n\");\n\tchunked2 = fu_chunk_array_new((const guint8 *)\"XXXXXXYYYYYYZZZZZZ\", 18, 0x0, 6, 4);\n\tchunked2_str = fu_chunk_array_to_string(chunked2);\n\tg_print(\"\\n%s\", chunked2_str);\n\tg_assert_cmpstr(chunked2_str,\n\t\t\t==,\n\t\t\t\"<chunks>\\n\"\n\t\t\t\"  <chunk>\\n\"\n\t\t\t\"    <data size=\\\"0x4\\\">XXXX</data>\\n\"\n\t\t\t\"  </chunk>\\n\"\n\t\t\t\"  <chunk>\\n\"\n\t\t\t\"    <idx>0x1</idx>\\n\"\n\t\t\t\"    <addr>0x4</addr>\\n\"\n\t\t\t\"    <data size=\\\"0x2\\\">XX</data>\\n\"\n\t\t\t\"  </chunk>\\n\"\n\t\t\t\"  <chunk>\\n\"\n\t\t\t\"    <idx>0x2</idx>\\n\"\n\t\t\t\"    <page>0x1</page>\\n\"\n\t\t\t\"    <data size=\\\"0x4\\\">YYYY</data>\\n\"\n\t\t\t\"  </chunk>\\n\"\n\t\t\t\"  <chunk>\\n\"\n\t\t\t\"    <idx>0x3</idx>\\n\"\n\t\t\t\"    <page>0x1</page>\\n\"\n\t\t\t\"    <addr>0x4</addr>\\n\"\n\t\t\t\"    <data size=\\\"0x2\\\">YY</data>\\n\"\n\t\t\t\"  </chunk>\\n\"\n\t\t\t\"  <chunk>\\n\"\n\t\t\t\"    <idx>0x4</idx>\\n\"\n\t\t\t\"    <page>0x2</page>\\n\"\n\t\t\t\"    <data size=\\\"0x4\\\">ZZZZ</data>\\n\"\n\t\t\t\"  </chunk>\\n\"\n\t\t\t\"  <chunk>\\n\"\n\t\t\t\"    <idx>0x5</idx>\\n\"\n\t\t\t\"    <page>0x2</page>\\n\"\n\t\t\t\"    <addr>0x4</addr>\\n\"\n\t\t\t\"    <data size=\\\"0x2\\\">ZZ</data>\\n\"\n\t\t\t\"  </chunk>\\n\"\n\t\t\t\"</chunks>\\n\");\n}\n\nstatic void\nfu_strstrip_func(void)\n{\n\tstruct {\n\t\tconst gchar *old;\n\t\tconst gchar *new;\n\t} map[] = {{\"same\", \"same\"},\n\t\t   {\" leading\", \"leading\"},\n\t\t   {\"tailing \", \"tailing\"},\n\t\t   {\"  b  \", \"b\"},\n\t\t   {\"  \", \"\"},\n\t\t   {NULL, NULL}};\n\tfor (guint i = 0; map[i].old != NULL; i++) {\n\t\tg_autofree gchar *tmp = fu_strstrip(map[i].old);\n\t\tg_assert_cmpstr(tmp, ==, map[i].new);\n\t}\n}\n\nstatic void\nfu_version_semver_func(void)\n{\n\tstruct {\n\t\tconst gchar *old;\n\t\tconst gchar *new;\n\t\tFwupdVersionFormat fmt;\n\t} map[] = {{\"1.2.3\", \"1.2.3\", FWUPD_VERSION_FORMAT_TRIPLET},\n\t\t   {\"1.2.3.4\", \"1.2.3\", FWUPD_VERSION_FORMAT_TRIPLET},\n\t\t   {\"1.2\", \"0.1.2\", FWUPD_VERSION_FORMAT_TRIPLET},\n\t\t   {\"1\", \"0.0.1\", FWUPD_VERSION_FORMAT_TRIPLET},\n\t\t   {\"CBET1.2.3\", \"1.2.3\", FWUPD_VERSION_FORMAT_TRIPLET},\n\t\t   {\"4.11-1190-g12d8072e6b-dirty\", \"4.11.1190\", FWUPD_VERSION_FORMAT_TRIPLET},\n\t\t   {\"4.11-1190-g12d8072e6b-dirty\", \"4.11\", FWUPD_VERSION_FORMAT_PAIR},\n\t\t   {NULL, NULL}};\n\tfor (guint i = 0; map[i].old != NULL; i++) {\n\t\tg_autofree gchar *tmp = fu_version_ensure_semver(map[i].old, map[i].fmt);\n\t\tg_assert_cmpstr(tmp, ==, map[i].new);\n\t}\n}\n\nstatic void\nfu_strtoull_func(void)\n{\n\tgboolean ret;\n\tguint64 val = 0;\n\tg_autoptr(GError) error = NULL;\n\n\tret = fu_strtoull(\"123\", &val, 123, 200, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_assert_cmpint(val, ==, 123);\n\n\tret = fu_strtoull(\"123\\n\", &val, 0, 200, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_assert_cmpint(val, ==, 123);\n\n\tret = fu_strtoull(\"0x123\", &val, 0, 0x123, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_assert_cmpint(val, ==, 0x123);\n\n\tret = fu_strtoull(NULL, &val, 0, G_MAXUINT32, NULL);\n\tg_assert_false(ret);\n\tret = fu_strtoull(\"\", &val, 120, 123, NULL);\n\tg_assert_false(ret);\n\tret = fu_strtoull(\"124\", &val, 120, 123, NULL);\n\tg_assert_false(ret);\n\tret = fu_strtoull(\"119\", &val, 120, 123, NULL);\n\tg_assert_false(ret);\n}\n\nstatic void\nfu_common_version_func(void)\n{\n\tguint i;\n\tstruct {\n\t\tguint32 val;\n\t\tconst gchar *ver;\n\t\tFwupdVersionFormat flags;\n\t} version_from_uint32[] = {\n\t    {0x0, \"0.0.0.0\", FWUPD_VERSION_FORMAT_QUAD},\n\t    {0xff, \"0.0.0.255\", FWUPD_VERSION_FORMAT_QUAD},\n\t    {0xff01, \"0.0.255.1\", FWUPD_VERSION_FORMAT_QUAD},\n\t    {0xff0001, \"0.255.0.1\", FWUPD_VERSION_FORMAT_QUAD},\n\t    {0xff000100, \"255.0.1.0\", FWUPD_VERSION_FORMAT_QUAD},\n\t    {0x0, \"0.0.0\", FWUPD_VERSION_FORMAT_TRIPLET},\n\t    {0xff, \"0.0.255\", FWUPD_VERSION_FORMAT_TRIPLET},\n\t    {0xff01, \"0.0.65281\", FWUPD_VERSION_FORMAT_TRIPLET},\n\t    {0xff0001, \"0.255.1\", FWUPD_VERSION_FORMAT_TRIPLET},\n\t    {0xff000100, \"255.0.256\", FWUPD_VERSION_FORMAT_TRIPLET},\n\t    {0x0, \"0\", FWUPD_VERSION_FORMAT_NUMBER},\n\t    {0xff000100, \"4278190336\", FWUPD_VERSION_FORMAT_NUMBER},\n\t    {0x0, \"11.0.0.0\", FWUPD_VERSION_FORMAT_INTEL_ME},\n\t    {0xffffffff, \"18.31.255.65535\", FWUPD_VERSION_FORMAT_INTEL_ME},\n\t    {0x0b32057a, \"11.11.50.1402\", FWUPD_VERSION_FORMAT_INTEL_ME},\n\t    {0xb8320d84, \"11.8.50.3460\", FWUPD_VERSION_FORMAT_INTEL_ME2},\n\t    {0x226a4b00, \"137.2706.768\", FWUPD_VERSION_FORMAT_SURFACE_LEGACY},\n\t    {0x6001988, \"6.25.136\", FWUPD_VERSION_FORMAT_SURFACE},\n\t    {0x00ff0001, \"255.0.1\", FWUPD_VERSION_FORMAT_DELL_BIOS},\n\t    {0xc8, \"0x000000c8\", FWUPD_VERSION_FORMAT_HEX},\n\t    {0, NULL}};\n\tstruct {\n\t\tguint64 val;\n\t\tconst gchar *ver;\n\t\tFwupdVersionFormat flags;\n\t} version_from_uint64[] = {\n\t    {0x0, \"0.0.0.0\", FWUPD_VERSION_FORMAT_QUAD},\n\t    {0xff, \"0.0.0.255\", FWUPD_VERSION_FORMAT_QUAD},\n\t    {0xffffffffffffffff, \"65535.65535.65535.65535\", FWUPD_VERSION_FORMAT_QUAD},\n\t    {0xff, \"0.255\", FWUPD_VERSION_FORMAT_PAIR},\n\t    {0xffffffffffffffff, \"4294967295.4294967295\", FWUPD_VERSION_FORMAT_PAIR},\n\t    {0x0, \"0\", FWUPD_VERSION_FORMAT_NUMBER},\n\t    {0x11000000c8, \"0x00000011000000c8\", FWUPD_VERSION_FORMAT_HEX},\n\t    {0, NULL}};\n\tstruct {\n\t\tguint16 val;\n\t\tconst gchar *ver;\n\t\tFwupdVersionFormat flags;\n\t} version_from_uint16[] = {{0x0, \"0.0\", FWUPD_VERSION_FORMAT_PAIR},\n\t\t\t\t   {0xff, \"0.255\", FWUPD_VERSION_FORMAT_PAIR},\n\t\t\t\t   {0xff01, \"255.1\", FWUPD_VERSION_FORMAT_PAIR},\n\t\t\t\t   {0x0, \"0.0\", FWUPD_VERSION_FORMAT_BCD},\n\t\t\t\t   {0x0110, \"1.10\", FWUPD_VERSION_FORMAT_BCD},\n\t\t\t\t   {0x9999, \"99.99\", FWUPD_VERSION_FORMAT_BCD},\n\t\t\t\t   {0x0, \"0\", FWUPD_VERSION_FORMAT_NUMBER},\n\t\t\t\t   {0x1234, \"4660\", FWUPD_VERSION_FORMAT_NUMBER},\n\t\t\t\t   {0, NULL}};\n\tstruct {\n\t\tconst gchar *old;\n\t\tconst gchar *new;\n\t} version_parse[] = {{\"0\", \"0\"},\n\t\t\t     {\"0x1a\", \"0.0.26\"},\n\t\t\t     {\"257\", \"0.0.257\"},\n\t\t\t     {\"1.2.3\", \"1.2.3\"},\n\t\t\t     {\"0xff0001\", \"0.255.1\"},\n\t\t\t     {\"16711681\", \"0.255.1\"},\n\t\t\t     {\"20150915\", \"20150915\"},\n\t\t\t     {\"dave\", \"dave\"},\n\t\t\t     {\"0x1x\", \"0x1x\"},\n\t\t\t     {NULL, NULL}};\n\n\t/* check version conversion */\n\tfor (i = 0; version_from_uint64[i].ver != NULL; i++) {\n\t\tg_autofree gchar *ver = NULL;\n\t\tver = fu_version_from_uint64(version_from_uint64[i].val,\n\t\t\t\t\t     version_from_uint64[i].flags);\n\t\tg_assert_cmpstr(ver, ==, version_from_uint64[i].ver);\n\t}\n\tfor (i = 0; version_from_uint32[i].ver != NULL; i++) {\n\t\tg_autofree gchar *ver = NULL;\n\t\tver = fu_version_from_uint32(version_from_uint32[i].val,\n\t\t\t\t\t     version_from_uint32[i].flags);\n\t\tg_assert_cmpstr(ver, ==, version_from_uint32[i].ver);\n\t}\n\tfor (i = 0; version_from_uint16[i].ver != NULL; i++) {\n\t\tg_autofree gchar *ver = NULL;\n\t\tver = fu_version_from_uint16(version_from_uint16[i].val,\n\t\t\t\t\t     version_from_uint16[i].flags);\n\t\tg_assert_cmpstr(ver, ==, version_from_uint16[i].ver);\n\t}\n\n\t/* check version parsing */\n\tfor (i = 0; version_parse[i].old != NULL; i++) {\n\t\tg_autofree gchar *ver = NULL;\n\t\tver = fu_version_parse_from_format(version_parse[i].old,\n\t\t\t\t\t\t   FWUPD_VERSION_FORMAT_TRIPLET);\n\t\tg_assert_cmpstr(ver, ==, version_parse[i].new);\n\t}\n}\n\nstatic void\nfu_common_vercmp_func(void)\n{\n\t/* same */\n\tg_assert_cmpint(fu_version_compare(\"1.2.3\", \"1.2.3\", FWUPD_VERSION_FORMAT_UNKNOWN), ==, 0);\n\tg_assert_cmpint(\n\t    fu_version_compare(\"001.002.003\", \"001.002.003\", FWUPD_VERSION_FORMAT_UNKNOWN),\n\t    ==,\n\t    0);\n\tg_assert_cmpint(fu_version_compare(\"0x00000002\", \"0x2\", FWUPD_VERSION_FORMAT_HEX), ==, 0);\n\n\t/* upgrade and downgrade */\n\tg_assert_cmpint(fu_version_compare(\"1.2.3\", \"1.2.4\", FWUPD_VERSION_FORMAT_UNKNOWN), <, 0);\n\tg_assert_cmpint(\n\t    fu_version_compare(\"001.002.000\", \"001.002.009\", FWUPD_VERSION_FORMAT_UNKNOWN),\n\t    <,\n\t    0);\n\tg_assert_cmpint(fu_version_compare(\"1.2.3\", \"1.2.2\", FWUPD_VERSION_FORMAT_UNKNOWN), >, 0);\n\tg_assert_cmpint(\n\t    fu_version_compare(\"001.002.009\", \"001.002.000\", FWUPD_VERSION_FORMAT_UNKNOWN),\n\t    >,\n\t    0);\n\n\t/* unequal depth */\n\tg_assert_cmpint(fu_version_compare(\"1.2.3\", \"1.2.3.1\", FWUPD_VERSION_FORMAT_UNKNOWN), <, 0);\n\tg_assert_cmpint(fu_version_compare(\"1.2.3.1\", \"1.2.4\", FWUPD_VERSION_FORMAT_UNKNOWN), <, 0);\n\n\t/* mixed-alpha-numeric */\n\tg_assert_cmpint(fu_version_compare(\"1.2.3a\", \"1.2.3a\", FWUPD_VERSION_FORMAT_UNKNOWN),\n\t\t\t==,\n\t\t\t0);\n\tg_assert_cmpint(fu_version_compare(\"1.2.3a\", \"1.2.3b\", FWUPD_VERSION_FORMAT_UNKNOWN), <, 0);\n\tg_assert_cmpint(fu_version_compare(\"1.2.3b\", \"1.2.3a\", FWUPD_VERSION_FORMAT_UNKNOWN), >, 0);\n\n\t/* alpha version append */\n\tg_assert_cmpint(fu_version_compare(\"1.2.3\", \"1.2.3a\", FWUPD_VERSION_FORMAT_UNKNOWN), <, 0);\n\tg_assert_cmpint(fu_version_compare(\"1.2.3a\", \"1.2.3\", FWUPD_VERSION_FORMAT_UNKNOWN), >, 0);\n\n\t/* alpha only */\n\tg_assert_cmpint(fu_version_compare(\"alpha\", \"alpha\", FWUPD_VERSION_FORMAT_UNKNOWN), ==, 0);\n\tg_assert_cmpint(fu_version_compare(\"alpha\", \"beta\", FWUPD_VERSION_FORMAT_UNKNOWN), <, 0);\n\tg_assert_cmpint(fu_version_compare(\"beta\", \"alpha\", FWUPD_VERSION_FORMAT_UNKNOWN), >, 0);\n\n\t/* alpha-compare */\n\tg_assert_cmpint(fu_version_compare(\"1.2a.3\", \"1.2a.3\", FWUPD_VERSION_FORMAT_UNKNOWN),\n\t\t\t==,\n\t\t\t0);\n\tg_assert_cmpint(fu_version_compare(\"1.2a.3\", \"1.2b.3\", FWUPD_VERSION_FORMAT_UNKNOWN), <, 0);\n\tg_assert_cmpint(fu_version_compare(\"1.2b.3\", \"1.2a.3\", FWUPD_VERSION_FORMAT_UNKNOWN), >, 0);\n\n\t/* tilde is all-powerful */\n\tg_assert_cmpint(fu_version_compare(\"1.2.3~rc1\", \"1.2.3~rc1\", FWUPD_VERSION_FORMAT_UNKNOWN),\n\t\t\t==,\n\t\t\t0);\n\tg_assert_cmpint(fu_version_compare(\"1.2.3~rc1\", \"1.2.3\", FWUPD_VERSION_FORMAT_UNKNOWN),\n\t\t\t<,\n\t\t\t0);\n\tg_assert_cmpint(fu_version_compare(\"1.2.3\", \"1.2.3~rc1\", FWUPD_VERSION_FORMAT_UNKNOWN),\n\t\t\t>,\n\t\t\t0);\n\tg_assert_cmpint(fu_version_compare(\"1.2.3~rc2\", \"1.2.3~rc1\", FWUPD_VERSION_FORMAT_UNKNOWN),\n\t\t\t>,\n\t\t\t0);\n\n\t/* invalid */\n\tg_assert_cmpint(fu_version_compare(\"1\", NULL, FWUPD_VERSION_FORMAT_UNKNOWN), ==, G_MAXINT);\n\tg_assert_cmpint(fu_version_compare(NULL, \"1\", FWUPD_VERSION_FORMAT_UNKNOWN), ==, G_MAXINT);\n\tg_assert_cmpint(fu_version_compare(NULL, NULL, FWUPD_VERSION_FORMAT_UNKNOWN), ==, G_MAXINT);\n}\n\nstatic void\nfu_firmware_raw_aligned_func(void)\n{\n\tgboolean ret;\n\tg_autoptr(FuFirmware) firmware1 = fu_firmware_new();\n\tg_autoptr(FuFirmware) firmware2 = fu_firmware_new();\n\tg_autoptr(GError) error = NULL;\n\tg_autoptr(GBytes) blob = g_bytes_new_static(\"hello\", 5);\n\n\t/* no alignment */\n\tret = fu_firmware_parse(firmware1, blob, FWUPD_INSTALL_FLAG_NO_SEARCH, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\n\t/* invalid alignment */\n\tfu_firmware_set_alignment(firmware2, FU_FIRMWARE_ALIGNMENT_4K);\n\tret = fu_firmware_parse(firmware2, blob, FWUPD_INSTALL_FLAG_NO_SEARCH, &error);\n\tg_assert_error(error, FWUPD_ERROR, FWUPD_ERROR_INVALID_FILE);\n\tg_assert_false(ret);\n}\n\nstatic void\nfu_firmware_ihex_func(void)\n{\n\tconst guint8 *data;\n\tgboolean ret;\n\tgsize len;\n\tg_autofree gchar *filename_hex = NULL;\n\tg_autofree gchar *filename_ref = NULL;\n\tg_autofree gchar *str = NULL;\n\tg_autoptr(FuFirmware) firmware = fu_ihex_firmware_new();\n\tg_autoptr(GBytes) data_file = NULL;\n\tg_autoptr(GBytes) data_fw = NULL;\n\tg_autoptr(GBytes) data_hex = NULL;\n\tg_autoptr(GBytes) data_ref = NULL;\n\tg_autoptr(GError) error = NULL;\n\n\t/* load a Intel hex32 file */\n\tfilename_hex = g_test_build_filename(G_TEST_DIST, \"tests\", \"firmware.hex\", NULL);\n\tdata_file = fu_bytes_get_contents(filename_hex, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(data_file);\n\tret = fu_firmware_parse(firmware, data_file, FWUPD_INSTALL_FLAG_NO_SEARCH, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tdata_fw = fu_firmware_get_bytes(firmware, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(data_fw);\n\tg_assert_cmpint(g_bytes_get_size(data_fw), ==, 136);\n\n\t/* did we match the reference file? */\n\tfilename_ref = g_test_build_filename(G_TEST_DIST, \"tests\", \"firmware.bin\", NULL);\n\tdata_ref = fu_bytes_get_contents(filename_ref, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(data_ref);\n\tret = fu_bytes_compare(data_fw, data_ref, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\n\t/* export a ihex file (which will be slightly different due to\n\t * non-continous regions being expanded */\n\tdata_hex = fu_firmware_write(firmware, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(data_hex);\n\tdata = g_bytes_get_data(data_hex, &len);\n\tstr = g_strndup((const gchar *)data, len);\n\tg_assert_cmpstr(str,\n\t\t\t==,\n\t\t\t\":104000003DEF20F000000000FACF01F0FBCF02F0FE\\n\"\n\t\t\t\":10401000E9CF03F0EACF04F0E1CF05F0E2CF06F0FC\\n\"\n\t\t\t\":10402000D9CF07F0DACF08F0F3CF09F0F4CF0AF0D8\\n\"\n\t\t\t\":10403000F6CF0BF0F7CF0CF0F8CF0DF0F5CF0EF078\\n\"\n\t\t\t\":104040000EC0F5FF0DC0F8FF0CC0F7FF0BC0F6FF68\\n\"\n\t\t\t\":104050000AC0F4FF09C0F3FF08C0DAFF07C0D9FFA8\\n\"\n\t\t\t\":1040600006C0E2FF05C0E1FF04C0EAFF03C0E9FFAC\\n\"\n\t\t\t\":1040700002C0FBFF01C0FAFF11003FEF20F000017A\\n\"\n\t\t\t\":0840800042EF20F03DEF20F0BB\\n\"\n\t\t\t\":00000001FF\\n\");\n}\n\nstatic void\nfu_firmware_ihex_signed_func(void)\n{\n\tconst guint8 *data;\n\tgboolean ret;\n\tgsize len;\n\tg_autofree gchar *filename_shex = NULL;\n\tg_autoptr(FuFirmware) firmware = fu_ihex_firmware_new();\n\tg_autoptr(GBytes) data_file = NULL;\n\tg_autoptr(GBytes) data_fw = NULL;\n\tg_autoptr(GBytes) data_sig = NULL;\n\tg_autoptr(GError) error = NULL;\n\n\t/* load a signed Intel hex32 file */\n\tfilename_shex = g_test_build_filename(G_TEST_DIST, \"tests\", \"firmware.shex\", NULL);\n\tdata_file = fu_bytes_get_contents(filename_shex, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(data_file);\n\tret = fu_firmware_parse(firmware, data_file, FWUPD_INSTALL_FLAG_NO_SEARCH, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tdata_fw = fu_firmware_get_bytes(firmware, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(data_fw);\n\tg_assert_cmpint(g_bytes_get_size(data_fw), ==, 136);\n\n\t/* get the signed image */\n\tdata_sig = fu_firmware_get_image_by_id_bytes(firmware, FU_FIRMWARE_ID_SIGNATURE, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(data_sig);\n\tdata = g_bytes_get_data(data_sig, &len);\n\tg_assert_cmpint(len, ==, 8);\n\tg_assert_nonnull(data);\n\tg_assert_cmpint(memcmp(data, \"deadbeef\", 8), ==, 0);\n}\n\nstatic void\nfu_firmware_ihex_offset_func(void)\n{\n\tconst guint8 *data;\n\tgboolean ret;\n\tgsize len;\n\tg_autofree gchar *str = NULL;\n\tg_autoptr(FuFirmware) firmware = fu_ihex_firmware_new();\n\tg_autoptr(FuFirmware) firmware_verify = fu_ihex_firmware_new();\n\tg_autoptr(GBytes) data_bin = NULL;\n\tg_autoptr(GBytes) data_dummy = NULL;\n\tg_autoptr(GBytes) data_verify = NULL;\n\tg_autoptr(GError) error = NULL;\n\n\t/* add a 4 byte image in high memory */\n\tdata_dummy = g_bytes_new_static(\"foo\", 4);\n\tfu_firmware_set_addr(firmware, 0x80000000);\n\tfu_firmware_set_bytes(firmware, data_dummy);\n\tdata_bin = fu_firmware_write(firmware, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(data_bin);\n\tdata = g_bytes_get_data(data_bin, &len);\n\tstr = g_strndup((const gchar *)data, len);\n\tg_assert_cmpstr(str,\n\t\t\t==,\n\t\t\t\":0200000480007A\\n\"\n\t\t\t\":04000000666F6F00B8\\n\"\n\t\t\t\":00000001FF\\n\");\n\n\t/* check we can load it too */\n\tret = fu_firmware_parse(firmware_verify, data_bin, FWUPD_INSTALL_FLAG_NO_SEARCH, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_assert_cmpint(fu_firmware_get_addr(firmware_verify), ==, 0x80000000);\n\tdata_verify = fu_firmware_get_bytes(firmware_verify, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(data_verify);\n\tg_assert_cmpint(g_bytes_get_size(data_verify), ==, 0x4);\n}\n\nstatic void\nfu_firmware_srec_func(void)\n{\n\tgboolean ret;\n\tg_autofree gchar *filename_srec = NULL;\n\tg_autofree gchar *filename_ref = NULL;\n\tg_autoptr(FuFirmware) firmware = fu_srec_firmware_new();\n\tg_autoptr(GBytes) data_ref = NULL;\n\tg_autoptr(GBytes) data_srec = NULL;\n\tg_autoptr(GBytes) data_bin = NULL;\n\tg_autoptr(GError) error = NULL;\n\n\tfilename_srec = g_test_build_filename(G_TEST_DIST, \"tests\", \"firmware.srec\", NULL);\n\tdata_srec = fu_bytes_get_contents(filename_srec, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(data_srec);\n\tret = fu_firmware_parse(firmware, data_srec, FWUPD_INSTALL_FLAG_NO_SEARCH, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tdata_bin = fu_firmware_get_bytes(firmware, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(data_bin);\n\tg_assert_cmpint(g_bytes_get_size(data_bin), ==, 136);\n\n\t/* did we match the reference file? */\n\tfilename_ref = g_test_build_filename(G_TEST_DIST, \"tests\", \"firmware.bin\", NULL);\n\tdata_ref = fu_bytes_get_contents(filename_ref, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(data_ref);\n\tret = fu_bytes_compare(data_bin, data_ref, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n}\n\nstatic void\nfu_firmware_fdt_func(void)\n{\n\tgboolean ret;\n\tguint32 val32 = 0;\n\tguint64 val64 = 0;\n\tg_autofree gchar *filename = NULL;\n\tg_autofree gchar *val = NULL;\n\tg_autofree gchar *str = NULL;\n\tg_autoptr(FuFirmware) firmware = fu_fdt_firmware_new();\n\tg_autoptr(FuFirmware) img1 = NULL;\n\tg_autoptr(FuFdtImage) img2 = NULL;\n\tg_autoptr(GBytes) data = NULL;\n\tg_autoptr(GError) error = NULL;\n\n\tfilename = g_test_build_filename(G_TEST_DIST, \"tests\", \"fdt.bin\", NULL);\n\tdata = fu_bytes_get_contents(filename, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(data);\n\tret = fu_firmware_parse(firmware, data, FWUPD_INSTALL_FLAG_NO_SEARCH, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_assert_cmpint(fu_fdt_firmware_get_cpuid(FU_FDT_FIRMWARE(firmware)), ==, 0x0);\n\tstr = fu_firmware_to_string(firmware);\n\tg_debug(\"%s\", str);\n\n\timg1 = fu_firmware_get_image_by_id(firmware, NULL, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(img1);\n\tret = fu_fdt_image_get_attr_str(FU_FDT_IMAGE(img1), \"key\", &val, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_assert_cmpstr(val, ==, \"hello world\");\n\n\t/* get image, and get the uint32 attr */\n\timg2 = fu_fdt_firmware_get_image_by_path(FU_FDT_FIRMWARE(firmware),\n\t\t\t\t\t\t \"/images/firmware-1\",\n\t\t\t\t\t\t &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(img2);\n\tret = fu_fdt_image_get_attr_u32(FU_FDT_IMAGE(img2), \"key\", &val32, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_assert_cmpint(val32, ==, 0x123);\n\n\t/* wrong type */\n\tret = fu_fdt_image_get_attr_u64(img2, \"key\", &val64, &error);\n\tg_assert_error(error, G_IO_ERROR, G_IO_ERROR_INVALID_DATA);\n\tg_assert_false(ret);\n}\n\nstatic void\nfu_firmware_fit_func(void)\n{\n\tgboolean ret;\n\tg_autofree gchar *filename = NULL;\n\tg_autofree gchar *str = NULL;\n\tg_auto(GStrv) val = NULL;\n\tg_autoptr(FuFdtImage) img1 = NULL;\n\tg_autoptr(FuFirmware) firmware = fu_fit_firmware_new();\n\tg_autoptr(GBytes) data = NULL;\n\tg_autoptr(GError) error = NULL;\n\n\tfilename = g_test_build_filename(G_TEST_DIST, \"tests\", \"fit.bin\", NULL);\n\tdata = fu_bytes_get_contents(filename, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(data);\n\tret = fu_firmware_parse(firmware, data, FWUPD_INSTALL_FLAG_NO_SEARCH, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_assert_cmpint(fu_fit_firmware_get_timestamp(FU_FIT_FIRMWARE(firmware)), ==, 0x629D4ABD);\n\tstr = fu_firmware_to_string(firmware);\n\tg_debug(\"%s\", str);\n\n\timg1 = fu_fdt_firmware_get_image_by_path(FU_FDT_FIRMWARE(firmware),\n\t\t\t\t\t\t \"/configurations/conf-1\",\n\t\t\t\t\t\t &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(img1);\n\tret = fu_fdt_image_get_attr_strlist(FU_FDT_IMAGE(img1),\n\t\t\t\t\t    FU_FIT_FIRMWARE_ATTR_COMPATIBLE,\n\t\t\t\t\t    &val,\n\t\t\t\t\t    &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_assert_nonnull(val);\n\tg_assert_cmpstr(val[0], ==, \"alice\");\n\tg_assert_cmpstr(val[1], ==, \"bob\");\n\tg_assert_cmpstr(val[2], ==, \"clara\");\n\tg_assert_cmpstr(val[3], ==, NULL);\n}\n\nstatic void\nfu_firmware_srec_tokenization_func(void)\n{\n\tFuSrecFirmwareRecord *rcd;\n\tGPtrArray *records;\n\tgboolean ret;\n\tg_autoptr(FuFirmware) firmware = fu_srec_firmware_new();\n\tg_autoptr(GBytes) data_srec = NULL;\n\tg_autoptr(GError) error = NULL;\n\tconst gchar *buf = \"S3060000001400E5\\r\\n\"\n\t\t\t   \"S31000000002281102000000007F0304002C\\r\\n\"\n\t\t\t   \"S306000000145095\\r\\n\"\n\t\t\t   \"S70500000000FA\\r\\n\";\n\tdata_srec = g_bytes_new_static(buf, strlen(buf));\n\tg_assert_no_error(error);\n\tg_assert_nonnull(data_srec);\n\tret = fu_firmware_tokenize(firmware, data_srec, FWUPD_INSTALL_FLAG_NONE, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\n\trecords = fu_srec_firmware_get_records(FU_SREC_FIRMWARE(firmware));\n\tg_assert_nonnull(records);\n\tg_assert_cmpint(records->len, ==, 4);\n\trcd = g_ptr_array_index(records, 2);\n\tg_assert_nonnull(rcd);\n\tg_assert_cmpint(rcd->ln, ==, 0x3);\n\tg_assert_cmpint(rcd->kind, ==, 3);\n\tg_assert_cmpint(rcd->addr, ==, 0x14);\n\tg_assert_cmpint(rcd->buf->len, ==, 0x1);\n\tg_assert_cmpint(rcd->buf->data[0], ==, 0x50);\n}\n\nstatic void\nfu_firmware_build_func(void)\n{\n\tgboolean ret;\n\tg_autofree gchar *str = NULL;\n\tg_autoptr(FuFirmware) firmware = fu_firmware_new();\n\tg_autoptr(FuFirmware) img = NULL;\n\tg_autoptr(GBytes) blob = NULL;\n\tg_autoptr(GBytes) blob2 = NULL;\n\tg_autoptr(GError) error = NULL;\n\tg_autoptr(XbBuilder) builder = xb_builder_new();\n\tg_autoptr(XbBuilderSource) source = xb_builder_source_new();\n\tg_autoptr(XbNode) n = NULL;\n\tg_autoptr(XbSilo) silo = NULL;\n\tconst gchar *buf = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\"\n\t\t\t   \"<firmware>\\n\"\n\t\t\t   \"  <version>1.2.3</version>\\n\"\n\t\t\t   \"  <firmware>\\n\"\n\t\t\t   \"    <version>4.5.6</version>\\n\"\n\t\t\t   \"    <id>header</id>\\n\"\n\t\t\t   \"    <idx>456</idx>\\n\"\n\t\t\t   \"    <addr>0x456</addr>\\n\"\n\t\t\t   \"    <data>aGVsbG8=</data>\\n\"\n\t\t\t   \"  </firmware>\\n\"\n\t\t\t   \"  <firmware>\\n\"\n\t\t\t   \"    <version>7.8.9</version>\\n\"\n\t\t\t   \"    <id>header</id>\\n\"\n\t\t\t   \"    <idx>789</idx>\\n\"\n\t\t\t   \"    <addr>0x789</addr>\\n\"\n\t\t\t   \"  </firmware>\\n\"\n\t\t\t   \"</firmware>\\n\";\n\tblob = g_bytes_new_static(buf, strlen(buf));\n\tg_assert_no_error(error);\n\tg_assert_nonnull(blob);\n\n\t/* parse XML */\n\tret = xb_builder_source_load_bytes(source, blob, XB_BUILDER_SOURCE_FLAG_NONE, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\txb_builder_import_source(builder, source);\n\tsilo = xb_builder_compile(builder, XB_BUILDER_COMPILE_FLAG_NONE, NULL, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(silo);\n\tn = xb_silo_query_first(silo, \"firmware\", &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(n);\n\n\t/* build object */\n\tret = fu_firmware_build(firmware, n, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_assert_cmpstr(fu_firmware_get_version(firmware), ==, \"1.2.3\");\n\n\t/* verify image */\n\timg = fu_firmware_get_image_by_id(firmware, \"header\", &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(img);\n\tg_assert_cmpstr(fu_firmware_get_version(img), ==, \"4.5.6\");\n\tg_assert_cmpint(fu_firmware_get_idx(img), ==, 456);\n\tg_assert_cmpint(fu_firmware_get_addr(img), ==, 0x456);\n\tblob2 = fu_firmware_write(img, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(blob2);\n\tg_assert_cmpint(g_bytes_get_size(blob2), ==, 5);\n\tstr = g_strndup(g_bytes_get_data(blob2, NULL), g_bytes_get_size(blob2));\n\tg_assert_cmpstr(str, ==, \"hello\");\n}\n\nstatic gsize\nfu_firmware_dfuse_image_get_size(FuFirmware *self)\n{\n\tg_autoptr(GPtrArray) chunks = fu_firmware_get_chunks(self, NULL);\n\tgsize length = 0;\n\tfor (guint i = 0; i < chunks->len; i++) {\n\t\tFuChunk *chk = g_ptr_array_index(chunks, i);\n\t\tlength += fu_chunk_get_data_sz(chk);\n\t}\n\treturn length;\n}\n\nstatic gsize\nfu_firmware_dfuse_get_size(FuFirmware *firmware)\n{\n\tgsize length = 0;\n\tg_autoptr(GPtrArray) images = fu_firmware_get_images(firmware);\n\tfor (guint i = 0; i < images->len; i++) {\n\t\tFuFirmware *image = g_ptr_array_index(images, i);\n\t\tlength += fu_firmware_dfuse_image_get_size(image);\n\t}\n\treturn length;\n}\n\nstatic void\nfu_firmware_dfuse_func(void)\n{\n\tgboolean ret;\n\tg_autofree gchar *filename = NULL;\n\tg_autoptr(FuFirmware) firmware = fu_dfuse_firmware_new();\n\tg_autoptr(GBytes) roundtrip_orig = NULL;\n\tg_autoptr(GBytes) roundtrip = NULL;\n\tg_autoptr(GError) error = NULL;\n\n\t/* load a DfuSe firmware */\n\tfilename = g_test_build_filename(G_TEST_DIST, \"tests\", \"firmware.dfuse\", NULL);\n\tg_assert_nonnull(filename);\n\troundtrip_orig = fu_bytes_get_contents(filename, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(roundtrip_orig);\n\tret = fu_firmware_parse(firmware, roundtrip_orig, FWUPD_INSTALL_FLAG_NO_SEARCH, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_assert_cmpint(fu_dfu_firmware_get_vid(FU_DFU_FIRMWARE(firmware)), ==, 0x1234);\n\tg_assert_cmpint(fu_dfu_firmware_get_pid(FU_DFU_FIRMWARE(firmware)), ==, 0x5678);\n\tg_assert_cmpint(fu_dfu_firmware_get_release(FU_DFU_FIRMWARE(firmware)), ==, 0x8642);\n\tg_assert_cmpint(fu_firmware_dfuse_get_size(firmware), ==, 0x21);\n\n\t/* can we roundtrip without losing data */\n\troundtrip = fu_firmware_write(firmware, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(roundtrip);\n\tret = fu_bytes_compare(roundtrip, roundtrip_orig, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n}\n\nstatic void\nfu_firmware_fmap_func(void)\n{\n\tgboolean ret;\n\tg_autofree gchar *filename = NULL;\n\tg_autofree gchar *img_str = NULL;\n\tg_autoptr(FuFirmware) firmware = fu_fmap_firmware_new();\n\tg_autoptr(FuFirmware) img = NULL;\n\tg_autoptr(GBytes) img_blob = NULL;\n\tg_autoptr(GBytes) roundtrip = NULL;\n\tg_autoptr(GBytes) roundtrip_orig = NULL;\n\tg_autoptr(GError) error = NULL;\n\tg_autoptr(GPtrArray) images = NULL;\n\n#ifndef HAVE_MEMMEM\n\tg_test_skip(\"no memmem()\");\n\treturn;\n#endif\n\n\t/* load firmware */\n\tfilename = g_test_build_filename(G_TEST_DIST, \"tests\", \"fmap-offset.bin\", NULL);\n\tg_assert_nonnull(filename);\n\troundtrip_orig = fu_bytes_get_contents(filename, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(roundtrip_orig);\n\tret = fu_firmware_parse(firmware, roundtrip_orig, FWUPD_INSTALL_FLAG_NONE, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\n\t/* check image count */\n\timages = fu_firmware_get_images(firmware);\n\tg_assert_cmpint(images->len, ==, 2);\n\n\t/* get a specific image */\n\timg = fu_firmware_get_image_by_id(firmware, \"FMAP\", &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(img);\n\timg_blob = fu_firmware_get_bytes(img, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(img_blob);\n\tg_assert_cmpint(g_bytes_get_size(img_blob), ==, 0xb);\n\timg_str = g_strndup(g_bytes_get_data(img_blob, NULL), g_bytes_get_size(img_blob));\n\tg_assert_cmpstr(img_str, ==, \"hello world\");\n\n\t/* can we roundtrip without losing data */\n\troundtrip = fu_firmware_write(firmware, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(roundtrip);\n\tret = fu_bytes_compare(roundtrip, roundtrip_orig, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n}\n\nstatic void\nfu_firmware_new_from_gtypes_func(void)\n{\n\tg_autofree gchar *fn = NULL;\n\tg_autoptr(FuFirmware) firmware1 = NULL;\n\tg_autoptr(FuFirmware) firmware2 = NULL;\n\tg_autoptr(FuFirmware) firmware3 = NULL;\n\tg_autoptr(GBytes) blob = NULL;\n\tg_autoptr(GError) error = NULL;\n\n\tfn = g_test_build_filename(G_TEST_DIST, \"tests\", \"firmware.dfu\", NULL);\n\tblob = fu_bytes_get_contents(fn, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(blob);\n\n\t/* dfu -> FuDfuFirmware */\n\tfirmware1 = fu_firmware_new_from_gtypes(blob,\n\t\t\t\t\t\tFWUPD_INSTALL_FLAG_NONE,\n\t\t\t\t\t\t&error,\n\t\t\t\t\t\tFU_TYPE_SREC_FIRMWARE,\n\t\t\t\t\t\tFU_TYPE_DFUSE_FIRMWARE,\n\t\t\t\t\t\tFU_TYPE_DFU_FIRMWARE,\n\t\t\t\t\t\tG_TYPE_INVALID);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(firmware1);\n\tg_assert_cmpstr(G_OBJECT_TYPE_NAME(firmware1), ==, \"FuDfuFirmware\");\n\n\t/* dfu -> FuFirmware */\n\tfirmware2 = fu_firmware_new_from_gtypes(blob,\n\t\t\t\t\t\tFWUPD_INSTALL_FLAG_NONE,\n\t\t\t\t\t\t&error,\n\t\t\t\t\t\tFU_TYPE_SREC_FIRMWARE,\n\t\t\t\t\t\tFU_TYPE_FIRMWARE,\n\t\t\t\t\t\tG_TYPE_INVALID);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(firmware2);\n\tg_assert_cmpstr(G_OBJECT_TYPE_NAME(firmware2), ==, \"FuFirmware\");\n\n\t/* dfu -> error */\n\tfirmware3 = fu_firmware_new_from_gtypes(blob,\n\t\t\t\t\t\tFWUPD_INSTALL_FLAG_NONE,\n\t\t\t\t\t\t&error,\n\t\t\t\t\t\tFU_TYPE_SREC_FIRMWARE,\n\t\t\t\t\t\tG_TYPE_INVALID);\n\tg_assert_error(error, FWUPD_ERROR, FWUPD_ERROR_INVALID_FILE);\n\tg_assert_null(firmware3);\n}\n\nstatic void\nfu_firmware_linear_func(void)\n{\n\tgboolean ret;\n\tg_autoptr(FuFirmware) firmware1 = fu_linear_firmware_new(FU_TYPE_OPROM_FIRMWARE);\n\tg_autoptr(FuFirmware) firmware2 = fu_linear_firmware_new(FU_TYPE_OPROM_FIRMWARE);\n\tg_autoptr(GBytes) blob1 = g_bytes_new_static(\"XXXX\", 4);\n\tg_autoptr(GBytes) blob2 = g_bytes_new_static(\"HELO\", 4);\n\tg_autoptr(GBytes) blob3 = NULL;\n\tg_autoptr(FuFirmware) img1 = fu_oprom_firmware_new();\n\tg_autoptr(FuFirmware) img2 = fu_oprom_firmware_new();\n\tg_autoptr(GError) error = NULL;\n\tg_autoptr(GPtrArray) imgs = NULL;\n\tg_autofree gchar *str = NULL;\n\n\t/* add images then parse */\n\tfu_firmware_set_bytes(img1, blob1);\n\tfu_firmware_add_image(firmware1, img1);\n\tfu_firmware_set_bytes(img2, blob2);\n\tfu_firmware_add_image(firmware1, img2);\n\tblob3 = fu_firmware_write(firmware1, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(blob3);\n\tg_assert_cmpint(g_bytes_get_size(blob3), ==, 1024);\n\n\t/* parse them back */\n\tret = fu_firmware_parse(firmware2, blob3, FWUPD_INSTALL_FLAG_NO_SEARCH, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tstr = fu_firmware_to_string(firmware2);\n\tg_debug(\"\\n%s\", str);\n\n\t/* verify we got both images */\n\timgs = fu_firmware_get_images(firmware2);\n\tg_assert_cmpint(imgs->len, ==, 2);\n}\n\nstatic void\nfu_firmware_dfu_func(void)\n{\n\tgboolean ret;\n\tg_autofree gchar *filename_dfu = NULL;\n\tg_autofree gchar *filename_ref = NULL;\n\tg_autoptr(FuFirmware) firmware = fu_dfu_firmware_new();\n\tg_autoptr(GBytes) data_ref = NULL;\n\tg_autoptr(GBytes) data_dfu = NULL;\n\tg_autoptr(GBytes) data_bin = NULL;\n\tg_autoptr(GError) error = NULL;\n\n\tfilename_dfu = g_test_build_filename(G_TEST_DIST, \"tests\", \"firmware.dfu\", NULL);\n\tdata_dfu = fu_bytes_get_contents(filename_dfu, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(data_dfu);\n\tret = fu_firmware_parse(firmware, data_dfu, FWUPD_INSTALL_FLAG_NO_SEARCH, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_assert_cmpint(fu_dfu_firmware_get_vid(FU_DFU_FIRMWARE(firmware)), ==, 0x1234);\n\tg_assert_cmpint(fu_dfu_firmware_get_pid(FU_DFU_FIRMWARE(firmware)), ==, 0x4321);\n\tg_assert_cmpint(fu_dfu_firmware_get_release(FU_DFU_FIRMWARE(firmware)), ==, 0xdead);\n\tdata_bin = fu_firmware_get_bytes(firmware, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(data_bin);\n\tg_assert_cmpint(g_bytes_get_size(data_bin), ==, 136);\n\n\t/* did we match the reference file? */\n\tfilename_ref = g_test_build_filename(G_TEST_DIST, \"tests\", \"firmware.bin\", NULL);\n\tdata_ref = fu_bytes_get_contents(filename_ref, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(data_ref);\n\tret = fu_bytes_compare(data_bin, data_ref, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n}\n\nstatic void\nfu_firmware_ifwi_cpd_func(void)\n{\n\tgboolean ret;\n\tg_autofree gchar *filename_ifwi_cpd = NULL;\n\tg_autoptr(FuFirmware) firmware = fu_ifwi_cpd_firmware_new();\n\tg_autoptr(FuFirmware) img1 = NULL;\n\tg_autoptr(FuFirmware) img2 = NULL;\n\tg_autoptr(GBytes) data_bin = NULL;\n\tg_autoptr(GBytes) data_ifwi_cpd = NULL;\n\tg_autoptr(GError) error = NULL;\n\n\tfilename_ifwi_cpd = g_test_build_filename(G_TEST_DIST, \"tests\", \"ifwi-cpd.bin\", NULL);\n\tdata_ifwi_cpd = fu_bytes_get_contents(filename_ifwi_cpd, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(data_ifwi_cpd);\n\tret = fu_firmware_parse(firmware, data_ifwi_cpd, FWUPD_INSTALL_FLAG_NO_SEARCH, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_assert_cmpint(fu_firmware_get_idx(firmware), ==, 0x1234);\n\tdata_bin = fu_firmware_write(firmware, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(data_bin);\n\tg_assert_cmpint(g_bytes_get_size(data_bin), ==, 90);\n\n\timg1 = fu_firmware_get_image_by_id(firmware, \"one\", &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(img1);\n\tg_assert_cmpint(fu_firmware_get_offset(img1), ==, 68);\n\tg_assert_cmpint(fu_firmware_get_size(img1), ==, 11);\n\n\timg2 = fu_firmware_get_image_by_id(firmware, \"two\", &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(img2);\n\tg_assert_cmpint(fu_firmware_get_offset(img2), ==, 79);\n\tg_assert_cmpint(fu_firmware_get_size(img2), ==, 11);\n}\n\nstatic void\nfu_firmware_ifwi_fpt_func(void)\n{\n\tgboolean ret;\n\tg_autofree gchar *filename_ifwi_fpt = NULL;\n\tg_autoptr(FuFirmware) firmware = fu_ifwi_fpt_firmware_new();\n\tg_autoptr(FuFirmware) img1 = NULL;\n\tg_autoptr(FuFirmware) img2 = NULL;\n\tg_autoptr(GBytes) data_bin = NULL;\n\tg_autoptr(GBytes) data_ifwi_fpt = NULL;\n\tg_autoptr(GError) error = NULL;\n\n\tfilename_ifwi_fpt = g_test_build_filename(G_TEST_DIST, \"tests\", \"ifwi-fpt.bin\", NULL);\n\tdata_ifwi_fpt = fu_bytes_get_contents(filename_ifwi_fpt, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(data_ifwi_fpt);\n\tret = fu_firmware_parse(firmware, data_ifwi_fpt, FWUPD_INSTALL_FLAG_NO_SEARCH, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tdata_bin = fu_firmware_write(firmware, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(data_bin);\n\tg_assert_cmpint(g_bytes_get_size(data_bin), ==, 118);\n\n\timg1 = fu_firmware_get_image_by_idx(firmware, 0x4f464e49, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(img1);\n\tg_assert_cmpint(fu_firmware_get_offset(img1), ==, 96);\n\tg_assert_cmpint(fu_firmware_get_size(img1), ==, 11);\n\n\timg2 = fu_firmware_get_image_by_idx(firmware, 0x4d495746, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(img2);\n\tg_assert_cmpint(fu_firmware_get_offset(img2), ==, 107);\n\tg_assert_cmpint(fu_firmware_get_size(img2), ==, 11);\n}\n\nstatic void\nfu_firmware_oprom_func(void)\n{\n\tgboolean ret;\n\tg_autofree gchar *filename_oprom = NULL;\n\tg_autoptr(FuFirmware) firmware = fu_oprom_firmware_new();\n\tg_autoptr(FuFirmware) img1 = NULL;\n\tg_autoptr(GBytes) data_bin = NULL;\n\tg_autoptr(GBytes) data_oprom = NULL;\n\tg_autoptr(GError) error = NULL;\n\n\tfilename_oprom = g_test_build_filename(G_TEST_DIST, \"tests\", \"oprom.bin\", NULL);\n\tdata_oprom = fu_bytes_get_contents(filename_oprom, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(data_oprom);\n\tret = fu_firmware_parse(firmware, data_oprom, FWUPD_INSTALL_FLAG_NO_SEARCH, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_assert_cmpint(fu_firmware_get_idx(firmware), ==, 0x1);\n\tdata_bin = fu_firmware_write(firmware, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(data_bin);\n\tg_assert_cmpint(g_bytes_get_size(data_bin), ==, 1024);\n\n\timg1 = fu_firmware_get_image_by_id(firmware, \"cpd\", &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(img1);\n\tg_assert_cmpint(fu_firmware_get_offset(img1), ==, 512);\n\tg_assert_cmpint(fu_firmware_get_size(img1), ==, 512);\n}\n\nstatic void\nfu_firmware_dfu_patch_func(void)\n{\n\tgboolean ret;\n\tg_autofree gchar *csum = NULL;\n\tg_autofree gchar *filename_dfu = NULL;\n\tg_autoptr(FuFirmware) firmware = fu_dfu_firmware_new();\n\tg_autoptr(GBytes) data_dfu = NULL;\n\tg_autoptr(GBytes) data_new = NULL;\n\tg_autoptr(GBytes) data_patch0 = g_bytes_new_static(\"XXXX\", 4);\n\tg_autoptr(GBytes) data_patch1 = g_bytes_new_static(\"HELO\", 4);\n\tg_autoptr(GError) error = NULL;\n\n\tfilename_dfu = g_test_build_filename(G_TEST_DIST, \"tests\", \"firmware.dfu\", NULL);\n\tdata_dfu = fu_bytes_get_contents(filename_dfu, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(data_dfu);\n\tret = fu_firmware_parse(firmware, data_dfu, FWUPD_INSTALL_FLAG_NO_SEARCH, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\n\t/* add a couple of patches */\n\tfu_firmware_add_patch(firmware, 0x0, data_patch0);\n\tfu_firmware_add_patch(firmware, 0x0, data_patch1);\n\tfu_firmware_add_patch(firmware, 136 - 4, data_patch1);\n\n\tdata_new = fu_firmware_write(firmware, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(data_new);\n\tfu_dump_full(G_LOG_DOMAIN,\n\t\t     \"patch\",\n\t\t     g_bytes_get_data(data_new, NULL),\n\t\t     g_bytes_get_size(data_new),\n\t\t     20,\n\t\t     FU_DUMP_FLAGS_SHOW_ASCII | FU_DUMP_FLAGS_SHOW_ADDRESSES);\n\tcsum = g_compute_checksum_for_bytes(G_CHECKSUM_SHA1, data_new);\n\tg_assert_cmpstr(csum, ==, \"0722727426092ac564861d1a11697182017be83f\");\n}\n\nstatic void\nfu_firmware_func(void)\n{\n\tgboolean ret;\n\tg_autoptr(FuFirmware) firmware = fu_firmware_new();\n\tg_autoptr(FuFirmware) img1 = fu_firmware_new();\n\tg_autoptr(FuFirmware) img2 = fu_firmware_new();\n\tg_autoptr(FuFirmware) img_id = NULL;\n\tg_autoptr(FuFirmware) img_idx = NULL;\n\tg_autoptr(GError) error = NULL;\n\tg_autoptr(GPtrArray) images = NULL;\n\tg_autofree gchar *str = NULL;\n\n\tfu_firmware_set_addr(img1, 0x200);\n\tfu_firmware_set_idx(img1, 13);\n\tfu_firmware_set_id(img1, \"primary\");\n\tfu_firmware_set_filename(img1, \"BIOS.bin\");\n\tfu_firmware_add_image(firmware, img1);\n\tfu_firmware_set_addr(img2, 0x400);\n\tfu_firmware_set_idx(img2, 23);\n\tfu_firmware_set_id(img2, \"secondary\");\n\tfu_firmware_add_image(firmware, img2);\n\n\timg_id = fu_firmware_get_image_by_id(firmware, \"NotGoingToExist\", &error);\n\tg_assert_error(error, FWUPD_ERROR, FWUPD_ERROR_NOT_FOUND);\n\tg_assert_null(img_id);\n\tg_clear_error(&error);\n\timg_id = fu_firmware_get_image_by_id(firmware, \"primary\", &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(img_id);\n\tg_assert_cmpint(fu_firmware_get_addr(img_id), ==, 0x200);\n\tg_assert_cmpint(fu_firmware_get_idx(img_id), ==, 13);\n\tg_assert_cmpstr(fu_firmware_get_id(img_id), ==, \"primary\");\n\n\timg_idx = fu_firmware_get_image_by_idx(firmware, 123456, &error);\n\tg_assert_error(error, FWUPD_ERROR, FWUPD_ERROR_NOT_FOUND);\n\tg_assert_null(img_idx);\n\tg_clear_error(&error);\n\timg_idx = fu_firmware_get_image_by_idx(firmware, 23, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(img_idx);\n\tg_assert_cmpint(fu_firmware_get_addr(img_idx), ==, 0x400);\n\tg_assert_cmpint(fu_firmware_get_idx(img_idx), ==, 23);\n\tg_assert_cmpstr(fu_firmware_get_id(img_idx), ==, \"secondary\");\n\n\tstr = fu_firmware_to_string(firmware);\n\tg_assert_cmpstr(str,\n\t\t\t==,\n\t\t\t\"<firmware>\\n\"\n\t\t\t\"  <firmware>\\n\"\n\t\t\t\"    <id>primary</id>\\n\"\n\t\t\t\"    <idx>0xd</idx>\\n\"\n\t\t\t\"    <addr>0x200</addr>\\n\"\n\t\t\t\"    <filename>BIOS.bin</filename>\\n\"\n\t\t\t\"  </firmware>\\n\"\n\t\t\t\"  <firmware>\\n\"\n\t\t\t\"    <id>secondary</id>\\n\"\n\t\t\t\"    <idx>0x17</idx>\\n\"\n\t\t\t\"    <addr>0x400</addr>\\n\"\n\t\t\t\"  </firmware>\\n\"\n\t\t\t\"</firmware>\\n\");\n\n\tret = fu_firmware_remove_image_by_idx(firmware, 0xd, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tret = fu_firmware_remove_image_by_id(firmware, \"secondary\", &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\timages = fu_firmware_get_images(firmware);\n\tg_assert_nonnull(images);\n\tg_assert_cmpint(images->len, ==, 0);\n\tret = fu_firmware_remove_image_by_id(firmware, \"NOTGOINGTOEXIST\", &error);\n\tg_assert_error(error, FWUPD_ERROR, FWUPD_ERROR_NOT_FOUND);\n\tg_assert_false(ret);\n}\n\nstatic void\nfu_firmware_common_func(void)\n{\n\tgboolean ret;\n\tguint8 value = 0;\n\tg_autoptr(GError) error = NULL;\n\n\tret = fu_firmware_strparse_uint8_safe(\"ff00XX\", 6, 0, &value, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_assert_cmpint(value, ==, 0xFF);\n\n\tret = fu_firmware_strparse_uint8_safe(\"ff00XX\", 6, 2, &value, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_assert_cmpint(value, ==, 0x00);\n\n\tret = fu_firmware_strparse_uint8_safe(\"ff00XX\", 6, 4, &value, &error);\n\tg_assert_error(error, G_IO_ERROR, G_IO_ERROR_INVALID_DATA);\n\tg_assert_false(ret);\n}\n\nstatic void\nfu_firmware_dedupe_func(void)\n{\n\tg_autoptr(FuFirmware) firmware = fu_firmware_new();\n\tg_autoptr(FuFirmware) img1 = fu_firmware_new();\n\tg_autoptr(FuFirmware) img1_old = fu_firmware_new();\n\tg_autoptr(FuFirmware) img2 = fu_firmware_new();\n\tg_autoptr(FuFirmware) img2_old = fu_firmware_new();\n\tg_autoptr(FuFirmware) img_id = NULL;\n\tg_autoptr(FuFirmware) img_idx = NULL;\n\tg_autoptr(GError) error = NULL;\n\n\tfu_firmware_add_flag(firmware, FU_FIRMWARE_FLAG_DEDUPE_ID);\n\tfu_firmware_add_flag(firmware, FU_FIRMWARE_FLAG_DEDUPE_IDX);\n\n\tfu_firmware_set_idx(img1_old, 13);\n\tfu_firmware_set_id(img1_old, \"DAVE\");\n\tfu_firmware_add_image(firmware, img1_old);\n\tg_assert_true(fu_firmware_get_parent(img1_old) == firmware);\n\n\tfu_firmware_set_idx(img1, 13);\n\tfu_firmware_set_id(img1, \"primary\");\n\tfu_firmware_add_image(firmware, img1);\n\n\tfu_firmware_set_idx(img2_old, 123456);\n\tfu_firmware_set_id(img2_old, \"secondary\");\n\tfu_firmware_add_image(firmware, img2_old);\n\n\tfu_firmware_set_idx(img2, 23);\n\tfu_firmware_set_id(img2, \"secondary\");\n\tfu_firmware_add_image(firmware, img2);\n\n\timg_id = fu_firmware_get_image_by_id(firmware, \"primary\", &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(img_id);\n\tg_assert_cmpint(fu_firmware_get_idx(img_id), ==, 13);\n\tg_assert_cmpstr(fu_firmware_get_id(img_id), ==, \"primary\");\n\n\timg_idx = fu_firmware_get_image_by_idx(firmware, 23, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(img_idx);\n\tg_assert_cmpint(fu_firmware_get_idx(img_idx), ==, 23);\n\tg_assert_cmpstr(fu_firmware_get_id(img_idx), ==, \"secondary\");\n}\n\nstatic void\nfu_efivar_func(void)\n{\n\tgboolean ret;\n\tgsize sz = 0;\n\tguint32 attr = 0;\n\tguint64 total;\n\tg_autofree gchar *sysfsfwdir = NULL;\n\tg_autofree guint8 *data = NULL;\n\tg_autoptr(GError) error = NULL;\n\tg_autoptr(GPtrArray) names = NULL;\n\n#ifndef __linux__\n\tg_test_skip(\"only works on Linux\");\n\treturn;\n#endif\n\n\t/* these tests will write */\n\tsysfsfwdir = g_test_build_filename(G_TEST_BUILT, \"tests\", NULL);\n\t(void)g_setenv(\"FWUPD_SYSFSFWDIR\", sysfsfwdir, TRUE);\n\n\t/* check supported */\n\tret = fu_efivar_supported(&error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\n\t/* check we can get the space used */\n\ttotal = fu_efivar_space_used(&error);\n\tg_assert_no_error(error);\n\tg_assert_cmpint(total, >=, 0x2000);\n\n\t/* check existing keys */\n\tg_assert_false(fu_efivar_exists(FU_EFIVAR_GUID_EFI_GLOBAL, \"NotGoingToExist\"));\n\tg_assert_true(fu_efivar_exists(FU_EFIVAR_GUID_EFI_GLOBAL, \"SecureBoot\"));\n\n\t/* list a few keys */\n\tnames = fu_efivar_get_names(FU_EFIVAR_GUID_EFI_GLOBAL, &error);\n\tg_assert_no_error(error);\n\tg_assert_nonnull(names);\n\tg_assert_cmpint(names->len, ==, 2);\n\n\t/* write and read a key */\n\tret = fu_efivar_set_data(FU_EFIVAR_GUID_EFI_GLOBAL,\n\t\t\t\t \"Test\",\n\t\t\t\t (guint8 *)\"1\",\n\t\t\t\t 1,\n\t\t\t\t FU_EFIVAR_ATTR_NON_VOLATILE | FU_EFIVAR_ATTR_RUNTIME_ACCESS,\n\t\t\t\t &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tret = fu_efivar_get_data(FU_EFIVAR_GUID_EFI_GLOBAL, \"Test\", &data, &sz, &attr, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_assert_cmpint(sz, ==, 1);\n\tg_assert_cmpint(attr, ==, FU_EFIVAR_ATTR_NON_VOLATILE | FU_EFIVAR_ATTR_RUNTIME_ACCESS);\n\tg_assert_cmpint(data[0], ==, '1');\n\n\t/* delete single key */\n\tret = fu_efivar_delete(FU_EFIVAR_GUID_EFI_GLOBAL, \"Test\", &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_assert_false(fu_efivar_exists(FU_EFIVAR_GUID_EFI_GLOBAL, \"Test\"));\n\n\t/* delete multiple keys */\n\tret = fu_efivar_set_data(FU_EFIVAR_GUID_EFI_GLOBAL, \"Test1\", (guint8 *)\"1\", 1, 0, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tret = fu_efivar_set_data(FU_EFIVAR_GUID_EFI_GLOBAL, \"Test2\", (guint8 *)\"1\", 1, 0, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tret = fu_efivar_delete_with_glob(FU_EFIVAR_GUID_EFI_GLOBAL, \"Test*\", &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_assert_false(fu_efivar_exists(FU_EFIVAR_GUID_EFI_GLOBAL, \"Test1\"));\n\tg_assert_false(fu_efivar_exists(FU_EFIVAR_GUID_EFI_GLOBAL, \"Test2\"));\n\n\t/* read a key that doesn't exist */\n\tret = fu_efivar_get_data(FU_EFIVAR_GUID_EFI_GLOBAL,\n\t\t\t\t \"NotGoingToExist\",\n\t\t\t\t NULL,\n\t\t\t\t NULL,\n\t\t\t\t NULL,\n\t\t\t\t &error);\n\tg_assert_error(error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND);\n\tg_assert_false(ret);\n}\n\ntypedef struct {\n\tguint cnt_success;\n\tguint cnt_failed;\n} FuDeviceRetryHelper;\n\nstatic gboolean\nfu_device_retry_success(FuDevice *device, gpointer user_data, GError **error)\n{\n\tFuDeviceRetryHelper *helper = (FuDeviceRetryHelper *)user_data;\n\thelper->cnt_success++;\n\treturn TRUE;\n}\n\nstatic gboolean\nfu_device_retry_failed(FuDevice *device, gpointer user_data, GError **error)\n{\n\tFuDeviceRetryHelper *helper = (FuDeviceRetryHelper *)user_data;\n\thelper->cnt_failed++;\n\tg_set_error_literal(error, FWUPD_ERROR, FWUPD_ERROR_INTERNAL, \"failed\");\n\treturn FALSE;\n}\n\nstatic gboolean\nfu_device_retry_success_3rd_try(FuDevice *device, gpointer user_data, GError **error)\n{\n\tFuDeviceRetryHelper *helper = (FuDeviceRetryHelper *)user_data;\n\tif (helper->cnt_failed == 2) {\n\t\thelper->cnt_success++;\n\t\treturn TRUE;\n\t}\n\thelper->cnt_failed++;\n\tg_set_error_literal(error, FWUPD_ERROR, FWUPD_ERROR_INTERNAL, \"failed\");\n\treturn FALSE;\n}\n\nstatic void\nfu_device_retry_success_func(void)\n{\n\tgboolean ret;\n\tg_autoptr(FuDevice) device = fu_device_new(NULL);\n\tg_autoptr(GError) error = NULL;\n\tFuDeviceRetryHelper helper = {\n\t    .cnt_success = 0,\n\t    .cnt_failed = 0,\n\t};\n\tfu_device_retry_add_recovery(device,\n\t\t\t\t     FWUPD_ERROR,\n\t\t\t\t     FWUPD_ERROR_INTERNAL,\n\t\t\t\t     fu_device_retry_failed);\n\tret = fu_device_retry(device, fu_device_retry_success, 3, &helper, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_assert_cmpint(helper.cnt_success, ==, 1);\n\tg_assert_cmpint(helper.cnt_failed, ==, 0);\n}\n\nstatic void\nfu_device_retry_failed_func(void)\n{\n\tgboolean ret;\n\tg_autoptr(FuDevice) device = fu_device_new(NULL);\n\tg_autoptr(GError) error = NULL;\n\tFuDeviceRetryHelper helper = {\n\t    .cnt_success = 0,\n\t    .cnt_failed = 0,\n\t};\n\tfu_device_retry_add_recovery(device,\n\t\t\t\t     FWUPD_ERROR,\n\t\t\t\t     FWUPD_ERROR_INTERNAL,\n\t\t\t\t     fu_device_retry_success);\n\tret = fu_device_retry(device, fu_device_retry_failed, 3, &helper, &error);\n\tg_assert_error(error, FWUPD_ERROR, FWUPD_ERROR_INTERNAL);\n\tg_assert_true(!ret);\n\tg_assert_cmpint(helper.cnt_success, ==, 2); /* do not reset for the last failure */\n\tg_assert_cmpint(helper.cnt_failed, ==, 3);\n}\n\nstatic void\nfu_device_retry_hardware_func(void)\n{\n\tgboolean ret;\n\tg_autoptr(FuDevice) device = fu_device_new(NULL);\n\tg_autoptr(GError) error = NULL;\n\tFuDeviceRetryHelper helper = {\n\t    .cnt_success = 0,\n\t    .cnt_failed = 0,\n\t};\n\tret = fu_device_retry(device, fu_device_retry_success_3rd_try, 3, &helper, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_assert_cmpint(helper.cnt_success, ==, 1);\n\tg_assert_cmpint(helper.cnt_failed, ==, 2);\n}\n\nstatic void\nfu_bios_settings_load_func(void)\n{\n\tgboolean ret;\n\tgint integer;\n\tconst gchar *tmp;\n\tGPtrArray *values;\n\tFwupdBiosSetting *setting;\n\tFwupdBiosSettingKind kind;\n\tg_autofree gchar *test_dir = NULL;\n\tg_autoptr(FuContext) ctx = fu_context_new();\n\tg_autoptr(GError) error = NULL;\n\tg_autoptr(FuBiosSettings) p620_settings = NULL;\n\tg_autoptr(FuBiosSettings) p14s_settings = NULL;\n\tg_autoptr(FuBiosSettings) xp29310_settings = NULL;\n\tg_autoptr(GPtrArray) p14s_items = NULL;\n\tg_autoptr(GPtrArray) p620_items = NULL;\n\tg_autoptr(GPtrArray) xps9310_items = NULL;\n\n\t/* load BIOS settings from a Lenovo P620 (with thinklmi driver problems) */\n\ttest_dir = g_test_build_filename(G_TEST_DIST, \"tests\", \"bios-attrs\", \"lenovo-p620\", NULL);\n\t(void)g_setenv(\"FWUPD_SYSFSFWATTRIBDIR\", test_dir, TRUE);\n\n\tg_test_expect_message(\"FuBiosSettings\", G_LOG_LEVEL_WARNING, \"*BUG*\");\n\tret = fu_context_reload_bios_settings(ctx, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_test_assert_expected_messages();\n\n\tp620_settings = fu_context_get_bios_settings(ctx);\n\tp620_items = fu_bios_settings_get_all(p620_settings);\n\tg_assert_cmpint(p620_items->len, ==, 128);\n\n\t/* make sure nothing pending */\n\tret = fu_context_get_bios_setting_pending_reboot(ctx);\n\tg_assert_false(ret);\n\n\t/* check a BIOS setting reads from kernel as expected by fwupd today */\n\tsetting = fu_context_get_bios_setting(ctx, \"com.thinklmi.AMDMemoryGuard\");\n\tg_assert_nonnull(setting);\n\ttmp = fwupd_bios_setting_get_name(setting);\n\tg_assert_cmpstr(tmp, ==, \"AMDMemoryGuard\");\n\ttmp = fwupd_bios_setting_get_description(setting);\n\tg_assert_cmpstr(tmp, ==, \"AMDMemoryGuard\");\n\ttmp = fwupd_bios_setting_get_current_value(setting);\n\tg_assert_cmpstr(tmp, ==, \"Disable\");\n\tvalues = fwupd_bios_setting_get_possible_values(setting);\n\tfor (guint i = 0; i < values->len; i++) {\n\t\tconst gchar *possible = g_ptr_array_index(values, i);\n\t\tif (i == 0)\n\t\t\tg_assert_cmpstr(possible, ==, \"Disable\");\n\t\tif (i == 1)\n\t\t\tg_assert_cmpstr(possible, ==, \"Enable\");\n\t}\n\n\t/* try to read an BIOS setting known to have ][Status] to make sure we worked\n\t * around the thinklmi bug sufficiently\n\t */\n\tsetting = fu_context_get_bios_setting(ctx, \"com.thinklmi.StartupSequence\");\n\tg_assert_nonnull(setting);\n\ttmp = fwupd_bios_setting_get_current_value(setting);\n\tg_assert_cmpstr(tmp, ==, \"Primary\");\n\tvalues = fwupd_bios_setting_get_possible_values(setting);\n\tfor (guint i = 0; i < values->len; i++) {\n\t\tconst gchar *possible = g_ptr_array_index(values, i);\n\t\tif (i == 0)\n\t\t\tg_assert_cmpstr(possible, ==, \"Primary\");\n\t\tif (i == 1)\n\t\t\tg_assert_cmpstr(possible, ==, \"Automatic\");\n\t}\n\n\t/* check no BIOS settings have [Status in them */\n\tfor (guint i = 0; i < p620_items->len; i++) {\n\t\tsetting = g_ptr_array_index(p620_items, i);\n\t\ttmp = fwupd_bios_setting_get_current_value(setting);\n\t\tg_debug(\"%s\", tmp);\n\t\tg_assert_null(g_strrstr(tmp, \"[Status\"));\n\t}\n\n\tg_free(test_dir);\n\n\t/* load BIOS settings from a Lenovo P14s Gen1 */\n\ttest_dir =\n\t    g_test_build_filename(G_TEST_DIST, \"tests\", \"bios-attrs\", \"lenovo-p14s-gen1\", NULL);\n\t(void)g_setenv(\"FWUPD_SYSFSFWATTRIBDIR\", test_dir, TRUE);\n\tret = fu_context_reload_bios_settings(ctx, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\n\tp14s_settings = fu_context_get_bios_settings(ctx);\n\tp14s_items = fu_bios_settings_get_all(p14s_settings);\n\tg_assert_cmpint(p14s_items->len, ==, 75);\n\n\t/* reboot should be pending on this one */\n\tret = fu_context_get_bios_setting_pending_reboot(ctx);\n\tg_assert_true(ret);\n\n\t/* look for an enumeration BIOS setting with a space */\n\tsetting = fu_context_get_bios_setting(ctx, \"com.thinklmi.SleepState\");\n\tg_assert_nonnull(setting);\n\ttmp = fwupd_bios_setting_get_name(setting);\n\tg_assert_cmpstr(tmp, ==, \"SleepState\");\n\ttmp = fwupd_bios_setting_get_description(setting);\n\tg_assert_cmpstr(tmp, ==, \"SleepState\");\n\tvalues = fwupd_bios_setting_get_possible_values(setting);\n\tfor (guint i = 0; i < values->len; i++) {\n\t\tconst gchar *possible = g_ptr_array_index(values, i);\n\t\tif (i == 0)\n\t\t\tg_assert_cmpstr(possible, ==, \"Linux\");\n\t\tif (i == 1)\n\t\t\tg_assert_cmpstr(possible, ==, \"Windows 10\");\n\t}\n\n\t/* make sure we defaulted UEFI Secure boot to read only if enabled */\n\tsetting = fu_context_get_bios_setting(ctx, \"com.thinklmi.SecureBoot\");\n\tg_assert_nonnull(setting);\n\tret = fwupd_bios_setting_get_read_only(setting);\n\tg_assert_true(ret);\n\n\tg_free(test_dir);\n\n\t/* load BIOS settings from a Dell XPS 9310 */\n\ttest_dir =\n\t    g_test_build_filename(G_TEST_DIST, \"tests\", \"bios-attrs\", \"dell-xps13-9310\", NULL);\n\t(void)g_setenv(\"FWUPD_SYSFSFWATTRIBDIR\", test_dir, TRUE);\n\tret = fu_context_reload_bios_settings(ctx, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\n\txp29310_settings = fu_context_get_bios_settings(ctx);\n\txps9310_items = fu_bios_settings_get_all(xp29310_settings);\n\tg_assert_cmpint(xps9310_items->len, ==, 109);\n\n\t/* make sure that we DIDN'T parse reset_bios setting */\n\tsetting = fu_context_get_bios_setting(ctx, FWUPD_BIOS_SETTING_RESET_BIOS);\n\tg_assert_null(setting);\n\n\t/* look at a integer BIOS setting */\n\tsetting = fu_context_get_bios_setting(ctx, \"com.dell-wmi-sysman.CustomChargeStop\");\n\tg_assert_nonnull(setting);\n\tkind = fwupd_bios_setting_get_kind(setting);\n\tg_assert_cmpint(kind, ==, FWUPD_BIOS_SETTING_KIND_INTEGER);\n\tinteger = fwupd_bios_setting_get_lower_bound(setting);\n\tg_assert_cmpint(integer, ==, 55);\n\tinteger = fwupd_bios_setting_get_upper_bound(setting);\n\tg_assert_cmpint(integer, ==, 100);\n\tinteger = fwupd_bios_setting_get_scalar_increment(setting);\n\tg_assert_cmpint(integer, ==, 1);\n\n\t/* look at a string BIOS setting */\n\tsetting = fu_context_get_bios_setting(ctx, \"com.dell-wmi-sysman.Asset\");\n\tg_assert_nonnull(setting);\n\tinteger = fwupd_bios_setting_get_lower_bound(setting);\n\tg_assert_cmpint(integer, ==, 1);\n\tinteger = fwupd_bios_setting_get_upper_bound(setting);\n\tg_assert_cmpint(integer, ==, 64);\n\ttmp = fwupd_bios_setting_get_description(setting);\n\tg_assert_cmpstr(tmp, ==, \"Asset Tag\");\n\n\t/* look at a enumeration BIOS setting */\n\tsetting = fu_context_get_bios_setting(ctx, \"com.dell-wmi-sysman.BiosRcvrFrmHdd\");\n\tg_assert_nonnull(setting);\n\tkind = fwupd_bios_setting_get_kind(setting);\n\tg_assert_cmpint(kind, ==, FWUPD_BIOS_SETTING_KIND_ENUMERATION);\n\tvalues = fwupd_bios_setting_get_possible_values(setting);\n\tfor (guint i = 0; i < values->len; i++) {\n\t\tconst gchar *possible = g_ptr_array_index(values, i);\n\t\tif (i == 0)\n\t\t\tg_assert_cmpstr(possible, ==, \"Disabled\");\n\t\tif (i == 1)\n\t\t\tg_assert_cmpstr(possible, ==, \"Enabled\");\n\t}\n\n\t/* make sure we defaulted UEFI Secure boot to read only if enabled */\n\tsetting = fu_context_get_bios_setting(ctx, \"com.dell-wmi-sysman.SecureBoot\");\n\tg_assert_nonnull(setting);\n\tret = fwupd_bios_setting_get_read_only(setting);\n\tg_assert_true(ret);\n}\n\nstatic void\nfu_security_attrs_hsi_func(void)\n{\n\tg_autofree gchar *hsi1 = NULL;\n\tg_autofree gchar *hsi2 = NULL;\n\tg_autofree gchar *hsi3 = NULL;\n\tg_autofree gchar *hsi4 = NULL;\n\tg_autofree gchar *hsi5 = NULL;\n\tg_autofree gchar *hsi6 = NULL;\n\tg_autofree gchar *hsi7 = NULL;\n\tg_autofree gchar *hsi8 = NULL;\n\tg_autofree gchar *hsi9 = NULL;\n\tg_autofree gchar *expected_hsi9 = NULL;\n\tg_autoptr(FuSecurityAttrs) attrs = NULL;\n\tg_autoptr(FwupdSecurityAttr) attr = NULL;\n\n\t/* no attrs */\n\tattrs = fu_security_attrs_new();\n\thsi1 = fu_security_attrs_calculate_hsi(attrs, FU_SECURITY_ATTRS_FLAG_NONE);\n\tg_assert_cmpstr(hsi1, ==, \"HSI:0\");\n\n\t/* just success from HSI:1 */\n\tattr = fwupd_security_attr_new(FWUPD_SECURITY_ATTR_ID_SPI_BIOSWE);\n\tfwupd_security_attr_set_plugin(attr, \"test\");\n\tfwupd_security_attr_set_level(attr, FWUPD_SECURITY_ATTR_LEVEL_CRITICAL);\n\tfwupd_security_attr_add_flag(attr, FWUPD_SECURITY_ATTR_FLAG_SUCCESS);\n\tfwupd_security_attr_set_url(attr, \"http://test\");\n\tfu_security_attrs_append(attrs, attr);\n\thsi2 = fu_security_attrs_calculate_hsi(attrs, FU_SECURITY_ATTRS_FLAG_NONE);\n\tg_assert_cmpstr(hsi2, ==, \"HSI:1\");\n\tg_clear_object(&attr);\n\n\t/* add failed from HSI:2, so still HSI:1 */\n\tattr = fwupd_security_attr_new(\"org.fwupd.hsi.PRX\");\n\tfwupd_security_attr_set_plugin(attr, \"test\");\n\tfwupd_security_attr_set_level(attr, FWUPD_SECURITY_ATTR_LEVEL_IMPORTANT);\n\tfwupd_security_attr_set_url(attr, \"http://test\");\n\tfu_security_attrs_append(attrs, attr);\n\thsi3 = fu_security_attrs_calculate_hsi(attrs, FU_SECURITY_ATTRS_FLAG_NONE);\n\tg_assert_cmpstr(hsi3, ==, \"HSI:1\");\n\tg_clear_object(&attr);\n\n\t/* add an implicit obsolete via duplication */\n\tattr = fwupd_security_attr_new(\"org.fwupd.hsi.PRX\");\n\tfwupd_security_attr_set_plugin(attr, \"other-plugin\");\n\tfwupd_security_attr_set_level(attr, FWUPD_SECURITY_ATTR_LEVEL_IMPORTANT);\n\tfwupd_security_attr_set_url(attr, \"http://other-plugin\");\n\tfu_security_attrs_append(attrs, attr);\n\tfu_security_attrs_depsolve(attrs);\n\thsi4 = fu_security_attrs_calculate_hsi(attrs, FU_SECURITY_ATTRS_FLAG_NONE);\n\tg_assert_cmpstr(hsi4, ==, \"HSI:1\");\n\tg_assert_true(fwupd_security_attr_has_flag(attr, FWUPD_SECURITY_ATTR_FLAG_OBSOLETED));\n\tg_clear_object(&attr);\n\n\t/* add attr from HSI:3, obsoleting the failure */\n\tattr = fwupd_security_attr_new(\"org.fwupd.hsi.BIOSGuard\");\n\tfwupd_security_attr_set_plugin(attr, \"test\");\n\tfwupd_security_attr_set_level(attr, FWUPD_SECURITY_ATTR_LEVEL_THEORETICAL);\n\tfwupd_security_attr_add_flag(attr, FWUPD_SECURITY_ATTR_FLAG_SUCCESS);\n\tfwupd_security_attr_add_obsolete(attr, \"org.fwupd.hsi.PRX\");\n\tfwupd_security_attr_set_url(attr, \"http://test\");\n\tfu_security_attrs_append(attrs, attr);\n\tfu_security_attrs_depsolve(attrs);\n\thsi5 = fu_security_attrs_calculate_hsi(attrs, FU_SECURITY_ATTRS_FLAG_NONE);\n\tg_assert_cmpstr(hsi5, ==, \"HSI:3\");\n\tg_clear_object(&attr);\n\n\t/* add taint that was fine */\n\tattr = fwupd_security_attr_new(FWUPD_SECURITY_ATTR_ID_FWUPD_PLUGINS);\n\tfwupd_security_attr_set_plugin(attr, \"test\");\n\tfwupd_security_attr_add_flag(attr, FWUPD_SECURITY_ATTR_FLAG_SUCCESS);\n\tfwupd_security_attr_add_flag(attr, FWUPD_SECURITY_ATTR_FLAG_RUNTIME_ISSUE);\n\tfwupd_security_attr_set_url(attr, \"http://test\");\n\tfu_security_attrs_append(attrs, attr);\n\thsi6 = fu_security_attrs_calculate_hsi(attrs, FU_SECURITY_ATTRS_FLAG_NONE);\n\tg_assert_cmpstr(hsi6, ==, \"HSI:3\");\n\tg_clear_object(&attr);\n\n\t/* add updates and attestation */\n\tattr = fwupd_security_attr_new(FWUPD_SECURITY_ATTR_ID_FWUPD_UPDATES);\n\tfwupd_security_attr_set_plugin(attr, \"test\");\n\tfwupd_security_attr_add_flag(attr, FWUPD_SECURITY_ATTR_FLAG_SUCCESS);\n\tfwupd_security_attr_set_url(attr, \"http://test\");\n\tfu_security_attrs_append(attrs, attr);\n\thsi7 = fu_security_attrs_calculate_hsi(attrs, FU_SECURITY_ATTRS_FLAG_NONE);\n\tg_assert_cmpstr(hsi7, ==, \"HSI:3\");\n\tg_clear_object(&attr);\n\n\t/* add issue that was uncool */\n\tattr = fwupd_security_attr_new(FWUPD_SECURITY_ATTR_ID_KERNEL_SWAP);\n\tfwupd_security_attr_set_plugin(attr, \"test\");\n\tfwupd_security_attr_add_flag(attr, FWUPD_SECURITY_ATTR_FLAG_RUNTIME_ISSUE);\n\tfwupd_security_attr_set_url(attr, \"http://test\");\n\tfu_security_attrs_append(attrs, attr);\n\thsi8 = fu_security_attrs_calculate_hsi(attrs, FU_SECURITY_ATTRS_FLAG_NONE);\n\tg_assert_cmpstr(hsi8, ==, \"HSI:3!\");\n\tg_clear_object(&attr);\n\n\t/* show version in the attribute */\n\tattr = fwupd_security_attr_new(FWUPD_SECURITY_ATTR_ID_KERNEL_SWAP);\n\tfwupd_security_attr_set_plugin(attr, \"test\");\n\tfwupd_security_attr_add_flag(attr, FWUPD_SECURITY_ATTR_FLAG_RUNTIME_ISSUE);\n\tfwupd_security_attr_set_url(attr, \"http://test\");\n\tfu_security_attrs_append(attrs, attr);\n\thsi9 = fu_security_attrs_calculate_hsi(attrs, FU_SECURITY_ATTRS_FLAG_ADD_VERSION);\n\texpected_hsi9 = g_strdup_printf(\"HSI:3! (v%d.%d.%d)\",\n\t\t\t\t\tFWUPD_MAJOR_VERSION,\n\t\t\t\t\tFWUPD_MINOR_VERSION,\n\t\t\t\t\tFWUPD_MICRO_VERSION);\n\tg_assert_cmpstr(hsi9, ==, expected_hsi9);\n\tg_clear_object(&attr);\n}\nstatic void\nfu_firmware_builder_round_trip_func(void)\n{\n\tstruct {\n\t\tGType gtype;\n\t\tconst gchar *xml_fn;\n\t\tconst gchar *checksum;\n\t} map[] = {\n\t    {FU_TYPE_DFUSE_FIRMWARE,\n\t     \"dfuse.builder.xml\",\n\t     \"c1ff429f0e381c8fe8e1b2ee41a5a9a79e2f2ff7\"},\n\t    {FU_TYPE_FDT_FIRMWARE, \"fdt.builder.xml\", \"40f7fbaff684a6bcf67c81b3079422c2529741e1\"},\n\t    {FU_TYPE_FIT_FIRMWARE, \"fit.builder.xml\", \"293ce07351bb7d76631c4e2ba47243db1e150f3c\"},\n\t    {FU_TYPE_SREC_FIRMWARE, \"srec.builder.xml\", \"2aae6c35c94fcfb415dbe95f408b9ce91ee846ed\"},\n\t    {FU_TYPE_IHEX_FIRMWARE, \"ihex.builder.xml\", \"a8d74f767f3fc992b413e5ba801cedc80a4cf013\"},\n\t    {FU_TYPE_FMAP_FIRMWARE, \"fmap.builder.xml\", \"a0b9ffc10a586d217edf9e9bae7c1fe7c564ea01\"},\n\t    {FU_TYPE_EFI_FIRMWARE_SECTION,\n\t     \"efi-firmware-section.builder.xml\",\n\t     \"2aae6c35c94fcfb415dbe95f408b9ce91ee846ed\"},\n\t    {FU_TYPE_EFI_FIRMWARE_SECTION,\n\t     \"efi-firmware-section.builder.xml\",\n\t     \"2aae6c35c94fcfb415dbe95f408b9ce91ee846ed\"},\n\t    {FU_TYPE_EFI_FIRMWARE_FILE,\n\t     \"efi-firmware-file.builder.xml\",\n\t     \"1002c14b29a76069f3b7e35c50a55d2b0d197441\"},\n\t    {FU_TYPE_EFI_FIRMWARE_FILESYSTEM,\n\t     \"efi-firmware-filesystem.builder.xml\",\n\t     \"d6fbadc1c303a3b4eede9db7fb0ddb353efffc86\"},\n\t    {FU_TYPE_EFI_FIRMWARE_VOLUME,\n\t     \"efi-firmware-volume.builder.xml\",\n\t     \"2aae6c35c94fcfb415dbe95f408b9ce91ee846ed\"},\n\t    {FU_TYPE_IFD_FIRMWARE, \"ifd.builder.xml\", \"0805c742e0deec12db2d8f9a86158a7cf610869b\"},\n\t    {FU_TYPE_CFU_OFFER,\n\t     \"cfu-offer.builder.xml\",\n\t     \"acc572d03a129081921c36118b527dab34a077ad\"},\n\t    {FU_TYPE_CFU_PAYLOAD,\n\t     \"cfu-payload.builder.xml\",\n\t     \"5da829f5fd15a28970aed98ebb26ebf2f88ed6f2\"},\n\t    {FU_TYPE_IFWI_CPD_FIRMWARE,\n\t     \"ifwi-cpd.builder.xml\",\n\t     \"91e348d17cb91ef7a528e85beb39d15a0532dca5\"},\n\t    {FU_TYPE_IFWI_FPT_FIRMWARE,\n\t     \"ifwi-fpt.builder.xml\",\n\t     \"d1f0fb2c2a7a99441bf4a825d060642315a94d91\"},\n\t    {FU_TYPE_OPROM_FIRMWARE,\n\t     \"oprom.builder.xml\",\n\t     \"2aae6c35c94fcfb415dbe95f408b9ce91ee846ed\"},\n\t    {FU_TYPE_INTEL_THUNDERBOLT_NVM,\n\t     \"intel-thunderbolt.builder.xml\",\n\t     \"e858000646fecb5223b41df57647c005b495749b\"},\n#ifdef HAVE_CBOR\n\t    {FU_TYPE_USWID_FIRMWARE,\n\t     \"uswid.builder.xml\",\n\t     \"cae8660d5acd5bb614d0410bc53dedaa1899aee1\"},\n#endif\n\t    {G_TYPE_INVALID, NULL, NULL}};\n\tg_type_ensure(FU_TYPE_COSWID_FIRMWARE);\n\tfor (guint i = 0; map[i].gtype != G_TYPE_INVALID; i++) {\n\t\tgboolean ret;\n\t\tg_autofree gchar *csum1 = NULL;\n\t\tg_autofree gchar *csum2 = NULL;\n\t\tg_autofree gchar *filename = NULL;\n\t\tg_autofree gchar *xml1 = NULL;\n\t\tg_autofree gchar *xml2 = NULL;\n\t\tg_autoptr(FuFirmware) firmware1 = g_object_new(map[i].gtype, NULL);\n\t\tg_autoptr(FuFirmware) firmware2 = g_object_new(map[i].gtype, NULL);\n\t\tg_autoptr(FuFirmware) firmware3 = g_object_new(map[i].gtype, NULL);\n\t\tg_autoptr(GError) error = NULL;\n\t\tg_autoptr(GBytes) blob = NULL;\n\n\t\t/* build and write */\n\t\tfilename = g_test_build_filename(G_TEST_DIST, \"tests\", map[i].xml_fn, NULL);\n\t\tret = g_file_get_contents(filename, &xml1, NULL, &error);\n\t\tg_assert_no_error(error);\n\t\tg_assert_true(ret);\n\t\tret = fu_firmware_build_from_xml(firmware1, xml1, &error);\n\t\tg_assert_no_error(error);\n\t\tg_assert_true(ret);\n\t\tcsum1 = fu_firmware_get_checksum(firmware1, G_CHECKSUM_SHA1, &error);\n\t\tg_assert_no_error(error);\n\t\tg_assert_cmpstr(csum1, ==, map[i].checksum);\n\n\t\t/* ensure we can write and then parse what we just wrote */\n\t\tblob = fu_firmware_write(firmware1, &error);\n\t\tg_assert_no_error(error);\n\t\tg_assert_nonnull(blob);\n\t\tret = fu_firmware_parse(firmware3, blob, FWUPD_INSTALL_FLAG_NO_SEARCH, &error);\n\t\tif (!ret)\n\t\t\tg_prefix_error(&error, \"%s: \", map[i].xml_fn);\n\t\tg_assert_no_error(error);\n\t\tg_assert_true(ret);\n\n\t\t/* ensure we can round-trip */\n\t\txml2 = fu_firmware_export_to_xml(firmware1, FU_FIRMWARE_EXPORT_FLAG_NONE, &error);\n\t\tg_assert_no_error(error);\n\t\tret = fu_firmware_build_from_xml(firmware2, xml2, &error);\n\t\tg_assert_no_error(error);\n\t\tg_assert_true(ret);\n\t\tcsum2 = fu_firmware_get_checksum(firmware2, G_CHECKSUM_SHA1, &error);\n\t\tg_assert_no_error(error);\n\t\tg_assert_cmpstr(csum2, ==, map[i].checksum);\n\t}\n}\n\ntypedef struct {\n\tguint last_percentage;\n\tguint updates;\n} FuProgressHelper;\n\nstatic void\nfu_progress_percentage_changed_cb(FuProgress *progress, guint percentage, gpointer data)\n{\n\tFuProgressHelper *helper = (FuProgressHelper *)data;\n\thelper->last_percentage = percentage;\n\thelper->updates++;\n}\n\nstatic void\nfu_progress_func(void)\n{\n\tFuProgressHelper helper = {0};\n\tg_autoptr(FuProgress) progress = fu_progress_new(G_STRLOC);\n\tg_autofree gchar *str = NULL;\n\n\tg_signal_connect(FU_PROGRESS(progress),\n\t\t\t \"percentage-changed\",\n\t\t\t G_CALLBACK(fu_progress_percentage_changed_cb),\n\t\t\t &helper);\n\n\tg_assert_cmpfloat_with_epsilon(fu_progress_get_duration(progress), 0.f, 0.001);\n\n\tfu_progress_set_profile(progress, TRUE);\n\tfu_progress_set_steps(progress, 5);\n\tg_assert_cmpint(helper.last_percentage, ==, 0);\n\n\tg_usleep(20 * 1000);\n\tfu_progress_step_done(progress);\n\tg_assert_cmpint(helper.updates, ==, 2);\n\tg_assert_cmpint(helper.last_percentage, ==, 20);\n\n\tfor (guint i = 0; i < 4; i++) {\n\t\tg_usleep(20 * 1000);\n\t\tfu_progress_step_done(progress);\n\t}\n\n\tg_assert_cmpint(helper.last_percentage, ==, 100);\n\tg_assert_cmpint(helper.updates, ==, 6);\n\tg_assert_cmpfloat_with_epsilon(fu_progress_get_duration(progress), 0.1f, 0.05);\n\tstr = fu_progress_traceback(progress);\n\tg_debug(\"\\n%s\", str);\n}\n\nstatic void\nfu_progress_child_func(void)\n{\n\tFuProgressHelper helper = {0};\n\tFuProgress *child;\n\tg_autoptr(FuProgress) progress = fu_progress_new(G_STRLOC);\n\n\t/* reset */\n\tfu_progress_set_profile(progress, TRUE);\n\tfu_progress_set_steps(progress, 2);\n\tg_signal_connect(FU_PROGRESS(progress),\n\t\t\t \"percentage-changed\",\n\t\t\t G_CALLBACK(fu_progress_percentage_changed_cb),\n\t\t\t &helper);\n\n\t/* parent: |-----------------------|-----------------------|\n\t * step1:  |-----------------------|\n\t * child:                          |-------------|---------|\n\t */\n\n\t/* PARENT UPDATE */\n\tg_debug(\"parent update #1\");\n\tfu_progress_step_done(progress);\n\tg_assert_cmpint(helper.updates, ==, 1);\n\tg_assert_cmpint(helper.last_percentage, ==, 50);\n\n\t/* now test with a child */\n\tchild = fu_progress_get_child(progress);\n\tfu_progress_set_id(child, G_STRLOC);\n\tfu_progress_set_steps(child, 2);\n\n\tg_debug(\"child update #1\");\n\tfu_progress_step_done(child);\n\tg_assert_cmpint(helper.updates, ==, 2);\n\tg_assert_cmpint(helper.last_percentage, ==, 75);\n\n\t/* child update */\n\tg_debug(\"child update #2\");\n\tfu_progress_step_done(child);\n\tg_assert_cmpint(helper.updates, ==, 3);\n\tg_assert_cmpint(helper.last_percentage, ==, 100);\n\n\t/* parent update */\n\tg_debug(\"parent update #2\");\n\tfu_progress_step_done(progress);\n\n\t/* ensure we ignored the duplicate */\n\tg_assert_cmpint(helper.updates, ==, 3);\n\tg_assert_cmpint(helper.last_percentage, ==, 100);\n}\n\nstatic void\nfu_progress_parent_one_step_proxy_func(void)\n{\n\tFuProgressHelper helper = {0};\n\tFuProgress *child;\n\tg_autoptr(FuProgress) progress = fu_progress_new(G_STRLOC);\n\n\t/* one step */\n\tfu_progress_set_steps(progress, 1);\n\tg_signal_connect(FU_PROGRESS(progress),\n\t\t\t \"percentage-changed\",\n\t\t\t G_CALLBACK(fu_progress_percentage_changed_cb),\n\t\t\t &helper);\n\n\t/* now test with a child */\n\tchild = fu_progress_get_child(progress);\n\tfu_progress_set_id(child, G_STRLOC);\n\tfu_progress_set_steps(child, 2);\n\n\t/* child set value */\n\tfu_progress_set_percentage(child, 33);\n\n\t/* ensure 1 updates for progress with one step and ensure using child value as parent */\n\tg_assert_cmpint(helper.updates, ==, 1);\n\tg_assert_cmpint(helper.last_percentage, ==, 33);\n}\n\nstatic void\nfu_progress_non_equal_steps_func(void)\n{\n\tg_autoptr(FuProgress) progress = fu_progress_new(G_STRLOC);\n\tFuProgress *child;\n\tFuProgress *grandchild;\n\n\t/* test non-equal steps */\n\tfu_progress_set_id(progress, G_STRLOC);\n\tfu_progress_add_step(progress, FWUPD_STATUS_DEVICE_ERASE, 20, NULL);\n\tfu_progress_add_step(progress, FWUPD_STATUS_DEVICE_WRITE, 60, NULL);\n\tfu_progress_add_step(progress, FWUPD_STATUS_DEVICE_READ, 20, NULL);\n\tg_assert_cmpint(fu_progress_get_percentage(progress), ==, 0);\n\tg_assert_cmpint(fu_progress_get_status(progress), ==, FWUPD_STATUS_DEVICE_ERASE);\n\n\t/* child step should increment according to the custom steps */\n\tchild = fu_progress_get_child(progress);\n\tfu_progress_set_id(child, G_STRLOC);\n\tfu_progress_set_steps(child, 2);\n\tfu_progress_set_status(child, FWUPD_STATUS_DEVICE_BUSY);\n\tg_assert_cmpint(fu_progress_get_status(progress), ==, FWUPD_STATUS_DEVICE_BUSY);\n\n\t/* start child */\n\tfu_progress_step_done(child);\n\n\t/* verify 10% */\n\tg_assert_cmpint(fu_progress_get_percentage(progress), ==, 10);\n\n\t/* finish child */\n\tfu_progress_step_done(child);\n\n\t/* ensure the parent is switched back to the status before the child took over */\n\tg_assert_cmpint(fu_progress_get_status(progress), ==, FWUPD_STATUS_DEVICE_ERASE);\n\n\tfu_progress_step_done(progress);\n\tg_assert_cmpint(fu_progress_get_status(progress), ==, FWUPD_STATUS_DEVICE_WRITE);\n\n\t/* verify 20% */\n\tg_assert_cmpint(fu_progress_get_percentage(progress), ==, 20);\n\n\t/* child step should increment according to the custom steps */\n\tchild = fu_progress_get_child(progress);\n\tfu_progress_set_id(child, G_STRLOC);\n\tfu_progress_set_id(child, G_STRLOC);\n\tfu_progress_add_step(child, FWUPD_STATUS_DEVICE_RESTART, 25, NULL);\n\tfu_progress_add_step(child, FWUPD_STATUS_DEVICE_WRITE, 75, NULL);\n\tg_assert_cmpint(fu_progress_get_status(progress), ==, FWUPD_STATUS_DEVICE_RESTART);\n\n\t/* start child */\n\tfu_progress_step_done(child);\n\tg_assert_cmpint(fu_progress_get_status(progress), ==, FWUPD_STATUS_DEVICE_WRITE);\n\n\t/* verify bilinear interpolation is working */\n\tg_assert_cmpint(fu_progress_get_percentage(progress), ==, 35);\n\n\t/*\n\t * 0        20                             80         100\n\t * |---------||----------------------------||---------|\n\t *            |       35                   |\n\t *            |-------||-------------------| (25%)\n\t *                     |              75.5 |\n\t *                     |---------------||--| (90%)\n\t */\n\tgrandchild = fu_progress_get_child(child);\n\tfu_progress_set_id(grandchild, G_STRLOC);\n\tfu_progress_add_step(grandchild, FWUPD_STATUS_DEVICE_ERASE, 90, NULL);\n\tfu_progress_add_step(grandchild, FWUPD_STATUS_DEVICE_WRITE, 10, NULL);\n\n\tfu_progress_step_done(grandchild);\n\n\t/* verify bilinear interpolation (twice) is working for subpercentage */\n\tg_assert_cmpint(fu_progress_get_percentage(progress), ==, 75);\n\n\tfu_progress_step_done(grandchild);\n\n\t/* finish child */\n\tfu_progress_step_done(child);\n\n\tfu_progress_step_done(progress);\n\tg_assert_cmpint(fu_progress_get_status(progress), ==, FWUPD_STATUS_DEVICE_READ);\n\n\t/* verify 80% */\n\tg_assert_cmpint(fu_progress_get_percentage(progress), ==, 80);\n\n\tfu_progress_step_done(progress);\n\n\t/* verify 100% */\n\tg_assert_cmpint(fu_progress_get_percentage(progress), ==, 100);\n\tg_assert_cmpint(fu_progress_get_status(progress), ==, FWUPD_STATUS_UNKNOWN);\n}\n\nstatic void\nfu_progress_finish_func(void)\n{\n\tFuProgress *child;\n\tg_autoptr(FuProgress) progress = fu_progress_new(G_STRLOC);\n\n\t/* check straight finish */\n\tfu_progress_set_steps(progress, 3);\n\n\tchild = fu_progress_get_child(progress);\n\tfu_progress_set_id(child, G_STRLOC);\n\tfu_progress_set_steps(child, 3);\n\tfu_progress_finished(child);\n\n\t/* parent step done after child finish */\n\tfu_progress_step_done(progress);\n}\n\nstatic void\nfu_progress_child_finished(void)\n{\n\tFuProgress *child;\n\tg_autoptr(FuProgress) progress = fu_progress_new(G_STRLOC);\n\n\t/* check straight finish */\n\tfu_progress_set_steps(progress, 3);\n\n\tchild = fu_progress_get_child(progress);\n\tfu_progress_set_id(child, G_STRLOC);\n\tfu_progress_set_steps(child, 3);\n\t/* some imaginary igorable error */\n\n\t/* parent step done after child finish */\n\tfu_progress_add_flag(progress, FU_PROGRESS_FLAG_CHILD_FINISHED);\n\tfu_progress_step_done(progress);\n}\n\nint\nmain(int argc, char **argv)\n{\n\tg_autofree gchar *testdatadir = NULL;\n\n\tg_test_init(&argc, &argv, NULL);\n\tg_type_ensure(FU_TYPE_IFD_BIOS);\n\n\t/* only critical and error are fatal */\n\tg_log_set_fatal_mask(NULL, G_LOG_LEVEL_ERROR | G_LOG_LEVEL_CRITICAL);\n\t(void)g_setenv(\"G_MESSAGES_DEBUG\", \"all\", TRUE);\n\n\ttestdatadir = g_test_build_filename(G_TEST_DIST, \"tests\", NULL);\n\t(void)g_setenv(\"FWUPD_DATADIR\", testdatadir, TRUE);\n\t(void)g_setenv(\"FWUPD_PLUGINDIR\", testdatadir, TRUE);\n\t(void)g_setenv(\"FWUPD_SYSCONFDIR\", testdatadir, TRUE);\n\t(void)g_setenv(\"FWUPD_SYSFSFWATTRIBDIR\", testdatadir, TRUE);\n\t(void)g_setenv(\"FWUPD_OFFLINE_TRIGGER\", \"/tmp/fwupd-self-test/system-update\", TRUE);\n\t(void)g_setenv(\"FWUPD_LOCALSTATEDIR\", \"/tmp/fwupd-self-test/var\", TRUE);\n\t(void)g_setenv(\"FWUPD_PROFILE\", \"1\", TRUE);\n\n\tg_test_add_func(\"/fwupd/common{strnsplit}\", fu_strsplit_func);\n\tg_test_add_func(\"/fwupd/common{memmem}\", fu_common_memmem_func);\n\tg_test_add_func(\"/fwupd/progress\", fu_progress_func);\n\tg_test_add_func(\"/fwupd/progress{child}\", fu_progress_child_func);\n\tg_test_add_func(\"/fwupd/progress{child-finished}\", fu_progress_child_finished);\n\tg_test_add_func(\"/fwupd/progress{parent-1-step}\", fu_progress_parent_one_step_proxy_func);\n\tg_test_add_func(\"/fwupd/progress{no-equal}\", fu_progress_non_equal_steps_func);\n\tg_test_add_func(\"/fwupd/progress{finish}\", fu_progress_finish_func);\n\tg_test_add_func(\"/fwupd/bios-attrs{load}\", fu_bios_settings_load_func);\n\tg_test_add_func(\"/fwupd/security-attrs{hsi}\", fu_security_attrs_hsi_func);\n\tg_test_add_func(\"/fwupd/plugin{config}\", fu_plugin_config_func);\n\tg_test_add_func(\"/fwupd/plugin{devices}\", fu_plugin_devices_func);\n\tg_test_add_func(\"/fwupd/plugin{device-inhibit-children}\",\n\t\t\tfu_plugin_device_inhibit_children_func);\n\tg_test_add_func(\"/fwupd/plugin{delay}\", fu_plugin_delay_func);\n\tg_test_add_func(\"/fwupd/plugin{quirks}\", fu_plugin_quirks_func);\n\tg_test_add_func(\"/fwupd/plugin{quirks-performance}\", fu_plugin_quirks_performance_func);\n\tg_test_add_func(\"/fwupd/plugin{quirks-device}\", fu_plugin_quirks_device_func);\n\tg_test_add_func(\"/fwupd/backend\", fu_backend_func);\n\tg_test_add_func(\"/fwupd/chunk\", fu_chunk_func);\n\tg_test_add_func(\"/fwupd/common{align-up}\", fu_common_align_up_func);\n\tg_test_add_func(\"/fwupd/common{gpt-type}\", fu_common_gpt_type_func);\n\tg_test_add_func(\"/fwupd/common{byte-array}\", fu_common_byte_array_func);\n\tg_test_add_func(\"/fwupd/common{crc}\", fu_common_crc_func);\n\tg_test_add_func(\"/fwupd/common{string-append-kv}\", fu_string_append_func);\n\tg_test_add_func(\"/fwupd/common{version-guess-format}\", fu_version_guess_format_func);\n\tg_test_add_func(\"/fwupd/common{strtoull}\", fu_strtoull_func);\n\tg_test_add_func(\"/fwupd/common{version}\", fu_common_version_func);\n\tg_test_add_func(\"/fwupd/common{version-semver}\", fu_version_semver_func);\n\tg_test_add_func(\"/fwupd/common{vercmp}\", fu_common_vercmp_func);\n\tg_test_add_func(\"/fwupd/common{strstrip}\", fu_strstrip_func);\n\tg_test_add_func(\"/fwupd/common{endian}\", fu_common_endian_func);\n\tg_test_add_func(\"/fwupd/common{cabinet}\", fu_common_cabinet_func);\n\tg_test_add_func(\"/fwupd/common{bytes-get-data}\", fu_common_bytes_get_data_func);\n\tg_test_add_func(\"/fwupd/common{kernel-lockdown}\", fu_common_kernel_lockdown_func);\n\tg_test_add_func(\"/fwupd/common{strsafe}\", fu_strsafe_func);\n\tg_test_add_func(\"/fwupd/efivar\", fu_efivar_func);\n\tg_test_add_func(\"/fwupd/hwids\", fu_hwids_func);\n\tg_test_add_func(\"/fwupd/smbios\", fu_smbios_func);\n\tg_test_add_func(\"/fwupd/smbios3\", fu_smbios3_func);\n\tg_test_add_func(\"/fwupd/smbios{dt}\", fu_smbios_dt_func);\n\tg_test_add_func(\"/fwupd/smbios{dt-fallback}\", fu_smbios_dt_fallback_func);\n\tg_test_add_func(\"/fwupd/smbios{class}\", fu_smbios_class_func);\n\tg_test_add_func(\"/fwupd/firmware\", fu_firmware_func);\n\tg_test_add_func(\"/fwupd/firmware{common}\", fu_firmware_common_func);\n\tg_test_add_func(\"/fwupd/firmware{linear}\", fu_firmware_linear_func);\n\tg_test_add_func(\"/fwupd/firmware{dedupe}\", fu_firmware_dedupe_func);\n\tg_test_add_func(\"/fwupd/firmware{build}\", fu_firmware_build_func);\n\tg_test_add_func(\"/fwupd/firmware{raw-aligned}\", fu_firmware_raw_aligned_func);\n\tg_test_add_func(\"/fwupd/firmware{ihex}\", fu_firmware_ihex_func);\n\tg_test_add_func(\"/fwupd/firmware{ihex-offset}\", fu_firmware_ihex_offset_func);\n\tg_test_add_func(\"/fwupd/firmware{ihex-signed}\", fu_firmware_ihex_signed_func);\n\tg_test_add_func(\"/fwupd/firmware{srec-tokenization}\", fu_firmware_srec_tokenization_func);\n\tg_test_add_func(\"/fwupd/firmware{srec}\", fu_firmware_srec_func);\n\tg_test_add_func(\"/fwupd/firmware{fdt}\", fu_firmware_fdt_func);\n\tg_test_add_func(\"/fwupd/firmware{fit}\", fu_firmware_fit_func);\n\tg_test_add_func(\"/fwupd/firmware{ifwi-cpd}\", fu_firmware_ifwi_cpd_func);\n\tg_test_add_func(\"/fwupd/firmware{ifwi-fpt}\", fu_firmware_ifwi_fpt_func);\n\tg_test_add_func(\"/fwupd/firmware{oprom}\", fu_firmware_oprom_func);\n\tg_test_add_func(\"/fwupd/firmware{dfu}\", fu_firmware_dfu_func);\n\tg_test_add_func(\"/fwupd/firmware{dfu-patch}\", fu_firmware_dfu_patch_func);\n\tg_test_add_func(\"/fwupd/firmware{dfuse}\", fu_firmware_dfuse_func);\n\tg_test_add_func(\"/fwupd/firmware{builder-round-trip}\", fu_firmware_builder_round_trip_func);\n\tg_test_add_func(\"/fwupd/firmware{fmap}\", fu_firmware_fmap_func);\n\tg_test_add_func(\"/fwupd/firmware{gtypes}\", fu_firmware_new_from_gtypes_func);\n\tg_test_add_func(\"/fwupd/archive{invalid}\", fu_archive_invalid_func);\n\tg_test_add_func(\"/fwupd/archive{cab}\", fu_archive_cab_func);\n\tg_test_add_func(\"/fwupd/device\", fu_device_func);\n\tg_test_add_func(\"/fwupd/device{instance-ids}\", fu_device_instance_ids_func);\n\tg_test_add_func(\"/fwupd/device{composite-id}\", fu_device_composite_id_func);\n\tg_test_add_func(\"/fwupd/device{flags}\", fu_device_flags_func);\n\tg_test_add_func(\"/fwupd/device{custom-flags}\", fu_device_private_flags_func);\n\tg_test_add_func(\"/fwupd/device{inhibit}\", fu_device_inhibit_func);\n\tg_test_add_func(\"/fwupd/device{inhibit-updateable}\", fu_device_inhibit_updateable_func);\n\tg_test_add_func(\"/fwupd/device{parent}\", fu_device_parent_func);\n\tg_test_add_func(\"/fwupd/device{children}\", fu_device_children_func);\n\tg_test_add_func(\"/fwupd/device{incorporate}\", fu_device_incorporate_func);\n\tif (g_test_slow())\n\t\tg_test_add_func(\"/fwupd/device{poll}\", fu_device_poll_func);\n\tg_test_add_func(\"/fwupd/device-locker{success}\", fu_device_locker_func);\n\tg_test_add_func(\"/fwupd/device-locker{fail}\", fu_device_locker_fail_func);\n\tg_test_add_func(\"/fwupd/device{name}\", fu_device_name_func);\n\tg_test_add_func(\"/fwupd/device{metadata}\", fu_device_metadata_func);\n\tg_test_add_func(\"/fwupd/device{open-refcount}\", fu_device_open_refcount_func);\n\tg_test_add_func(\"/fwupd/device{version-format}\", fu_device_version_format_func);\n\tg_test_add_func(\"/fwupd/device{retry-success}\", fu_device_retry_success_func);\n\tg_test_add_func(\"/fwupd/device{retry-failed}\", fu_device_retry_failed_func);\n\tg_test_add_func(\"/fwupd/device{retry-hardware}\", fu_device_retry_hardware_func);\n\tg_test_add_func(\"/fwupd/device{cfi-device}\", fu_device_cfi_device_func);\n\treturn g_test_run();\n}\n"], "filenames": ["contrib/fwupd.spec.in", "libfwupdplugin/fu-plugin.c", "libfwupdplugin/fu-self-test.c"], "buggy_code_start_loc": [327, 11, 674], "buggy_code_end_loc": [327, 2461, 3600], "fixing_code_start_loc": [328, 12, 675], "fixing_code_end_loc": [331, 2504, 3658], "type": "CWE-552", "message": "When creating an OPERATOR user account on the BMC, the redfish plugin saved the auto-generated password to /etc/fwupd/redfish.conf without proper restriction, allowing any user on the system to read the same configuration file.", "other": {"cve": {"id": "CVE-2022-3287", "sourceIdentifier": "secalert@redhat.com", "published": "2022-09-28T20:15:18.433", "lastModified": "2022-09-30T16:18:33.310", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "When creating an OPERATOR user account on the BMC, the redfish plugin saved the auto-generated password to /etc/fwupd/redfish.conf without proper restriction, allowing any user on the system to read the same configuration file."}, {"lang": "es", "value": "Cuando era creada una cuenta de usuario OPERATOR en el BMC, el plugin redfish guardaba la contrase\u00f1a autogenerada en /etc/fwupd/redfish.conf sin una restricci\u00f3n apropiada, permitiendo a cualquier usuario del sistema leer el mismo archivo de configuraci\u00f3n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-552"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-256"}, {"lang": "en", "value": "CWE-552"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:fwupd:fwupd:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.8.5", "matchCriteriaId": "6D1E50C4-33F3-42A4-A6C5-4BD995A86434"}]}]}], "references": [{"url": "https://github.com/fwupd/fwupd/commit/ea676855f2119e36d433fbd2ed604039f53b2091", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/fwupd/fwupd/commit/ea676855f2119e36d433fbd2ed604039f53b2091"}}