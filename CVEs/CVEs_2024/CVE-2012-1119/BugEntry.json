{"buggy_code": ["<?php\n# MantisBT - A PHP based bugtracking system\n\n# MantisBT is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 2 of the License, or\n# (at your option) any later version.\n#\n# MantisBT is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with MantisBT.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * This page allows actions to be performed an an array of bugs\n *\n * @package MantisBT\n * @copyright Copyright (C) 2000 - 2002  Kenzaburo Ito - kenito@300baud.org\n * @copyright Copyright (C) 2002 - 2012  MantisBT Team - mantisbt-dev@lists.sourceforge.net\n * @link http://www.mantisbt.org\n *\n * @uses core.php\n * @uses access_api.php\n * @uses authentication_api.php\n * @uses bug_api.php\n * @uses bugnote_api.php\n * @uses category_api.php\n * @uses config_api.php\n * @uses constant_inc.php\n * @uses custom_field_api.php\n * @uses event_api.php\n * @uses form_api.php\n * @uses gpc_api.php\n * @uses helper_api.php\n * @uses html_api.php\n * @uses lang_api.php\n * @uses print_api.php\n * @uses string_api.php\n * @uses utility_api.php\n * @uses version_api.php\n */\n\n/**\n * MantisBT Core API's\n */\nrequire_once( 'core.php' );\nrequire_api( 'access_api.php' );\nrequire_api( 'authentication_api.php' );\nrequire_api( 'bug_api.php' );\nrequire_api( 'bugnote_api.php' );\nrequire_api( 'category_api.php' );\nrequire_api( 'config_api.php' );\nrequire_api( 'constant_inc.php' );\nrequire_api( 'custom_field_api.php' );\nrequire_api( 'event_api.php' );\nrequire_api( 'form_api.php' );\nrequire_api( 'gpc_api.php' );\nrequire_api( 'helper_api.php' );\nrequire_api( 'html_api.php' );\nrequire_api( 'lang_api.php' );\nrequire_api( 'print_api.php' );\nrequire_api( 'string_api.php' );\nrequire_api( 'utility_api.php' );\nrequire_api( 'version_api.php' );\n\nauth_ensure_user_authenticated();\nhelper_begin_long_process();\n\n$f_action\t= gpc_get_string( 'action' );\n$f_custom_field_id = gpc_get_int( 'custom_field_id', 0 );\n$f_bug_arr\t= gpc_get_int_array( 'bug_arr', array() );\n$f_bug_notetext = gpc_get_string( 'bugnote_text', '' );\n$f_bug_noteprivate = gpc_get_bool( 'private' );\n$t_form_name = 'bug_actiongroup_' . $f_action;\nform_security_validate( $t_form_name );\n\n$t_custom_group_actions = config_get( 'custom_group_actions' );\n\nforeach( $t_custom_group_actions as $t_custom_group_action ) {\n\tif ( $f_action == $t_custom_group_action['action'] ) {\n\t\trequire_once( $t_custom_group_action['action_page'] );\n\t\texit;\n\t}\n}\n\n$t_failed_ids = array();\n\nif ( 0 != $f_custom_field_id ) {\n\t$t_custom_field_def = custom_field_get_definition( $f_custom_field_id );\n}\n\nforeach( $f_bug_arr as $t_bug_id ) {\n\tbug_ensure_exists( $t_bug_id );\n\t$t_bug = bug_get( $t_bug_id, true );\n\n\tif( $t_bug->project_id != helper_get_current_project() ) {\n\t\t# in case the current project is not the same project of the bug we are viewing...\n\t\t# ... override the current project. This to avoid problems with categories and handlers lists etc.\n\t\t$g_project_override = $t_bug->project_id;\n\t\t/** @todo (thraxisp) the next line goes away if the cache was smarter and used project */\n\t\tconfig_flush_cache(); # flush the config cache so that configs are refetched\n\t}\n\n\t$t_status = $t_bug->status;\n\n\tswitch ( $f_action ) {\n\n\tcase 'CLOSE':\n\t\t$t_closed = config_get( 'bug_closed_status_threshold' );\n\t\tif ( access_can_close_bug( $t_bug_id ) ) {\n\t\t\tif( ( $t_status < $t_closed ) &&\n\t\t\t\tbug_check_workflow( $t_status, $t_closed ) ) {\n\n\t\t\t/** @todo we need to issue a helper_call_custom_function( 'issue_update_validate', array( $f_bug_id, $t_bug_data, $f_bugnote_text ) ); */\n\t\t\tbug_close( $t_bug_id, $f_bug_notetext, $f_bug_noteprivate );\n\t\t\thelper_call_custom_function( 'issue_update_notify', array( $t_bug_id ) );\n\t\t} else {\n\t\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_status' );\n\t\t\t}\n\t\t} else {\n\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_access' );\n\t\t}\n\t\tbreak;\n\n\tcase 'DELETE':\n\t\tif ( access_has_bug_level( config_get( 'delete_bug_threshold' ), $t_bug_id ) ) {\n\t\t\tevent_signal( 'EVENT_BUG_DELETED', array( $t_bug_id ) );\n\t\t\tbug_delete( $t_bug_id );\n\t\t} else {\n\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_access' );\n\t\t}\n\t\tbreak;\n\n\tcase 'MOVE':\n\t\t$f_project_id = gpc_get_int( 'project_id' );\n\t\tif( access_has_bug_level( config_get( 'move_bug_threshold' ), $t_bug_id ) &&\n\t\t    access_has_project_level( config_get( 'report_bug_threshold', null, null, $f_project_id ), $f_project_id ) ) {\n\t\t\t/** @todo we need to issue a helper_call_custom_function( 'issue_update_validate', array( $t_bug_id, $t_bug_data, $f_bugnote_text ) ); */\n\t\t\tbug_move( $t_bug_id, $f_project_id );\n\t\t\thelper_call_custom_function( 'issue_update_notify', array( $t_bug_id ) );\n\t\t} else {\n\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_access' );\n\t\t}\n\t\tbreak;\n\n\tcase 'COPY':\n\t\t$f_project_id = gpc_get_int( 'project_id' );\n\n\t\tif ( access_has_project_level( config_get( 'report_bug_threshold' ), $f_project_id ) ) {\n\t\t\tbug_copy( $t_bug_id, $f_project_id, true, true, true, true, true, true );\n\t\t} else {\n\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_access' );\n\t\t}\n\t\tbreak;\n\n\tcase 'ASSIGN':\n\t\t$f_assign = gpc_get_int( 'assign' );\n\t\tif ( ON == config_get( 'auto_set_status_to_assigned' ) ) {\n\t\t\t$t_assign_status = config_get( 'bug_assigned_status' );\n\t\t} else {\n\t\t\t$t_assign_status = $t_status;\n\t\t}\n\t\t# check that new handler has rights to handle the issue, and\n\t\t#  that current user has rights to assign the issue\n\t\t$t_threshold = access_get_status_threshold( $t_assign_status, bug_get_field( $t_bug_id, 'project_id' ) );\n\t\tif ( access_has_bug_level( config_get( 'update_bug_assign_threshold', config_get( 'update_bug_threshold' ) ), $t_bug_id ) ) {\n\t\t\tif ( access_has_bug_level( config_get( 'handle_bug_threshold' ), $t_bug_id, $f_assign ) ) {\n\t\t\t\tif ( bug_check_workflow( $t_status, $t_assign_status ) ) {\n\t\t\t\t\t/** @todo we need to issue a helper_call_custom_function( 'issue_update_validate', array( $t_bug_id, $t_bug_data, $f_bugnote_text ) ); */\n\t\t\t\t\tbug_assign( $t_bug_id, $f_assign, $f_bug_notetext, $f_bug_noteprivate );\n\t\t\t\t\thelper_call_custom_function( 'issue_update_notify', array( $t_bug_id ) );\n\t\t\t\t} else {\n\t\t\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_status' );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_handler' );\n\t\t\t}\n\t\t} else {\n\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_access' );\n\t\t}\n\t\tbreak;\n\n\tcase 'RESOLVE':\n\t\t$t_resolved_status = config_get( 'bug_resolved_status_threshold' );\n\t\t\tif ( access_has_bug_level( access_get_status_threshold( $t_resolved_status, bug_get_field( $t_bug_id, 'project_id' ) ), $t_bug_id ) ) {\n\t\t\t\tif ( ( $t_status < $t_resolved_status ) &&\n\t\t\t\t\tbug_check_workflow($t_status, $t_resolved_status ) ) {\n\t\t\t$f_resolution = gpc_get_int( 'resolution' );\n\t\t\t$f_fixed_in_version = gpc_get_string( 'fixed_in_version', '' );\n\t\t\t/** @todo we need to issue a helper_call_custom_function( 'issue_update_validate', array( $t_bug_id, $t_bug_data, $f_bugnote_text ) ); */\n\t\t\tbug_resolve( $t_bug_id, $f_resolution, $f_fixed_in_version, $f_bug_notetext, null, null, $f_bug_noteprivate );\n\t\t\thelper_call_custom_function( 'issue_update_notify', array( $t_bug_id ) );\n\t\t} else {\n\t\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_status' );\n\t\t\t}\n\t\t\t} else {\n\t\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_access' );\n\t\t}\n\t\tbreak;\n\n\tcase 'UP_PRIOR':\n\t\tif ( access_has_bug_level( config_get( 'update_bug_threshold' ), $t_bug_id ) ) {\n\t\t\t$f_priority = gpc_get_int( 'priority' );\n\t\t\t/** @todo we need to issue a helper_call_custom_function( 'issue_update_validate', array( $t_bug_id, $t_bug_data, $f_bugnote_text ) ); */\n\t\t\tbug_set_field( $t_bug_id, 'priority', $f_priority );\n\t\t\thelper_call_custom_function( 'issue_update_notify', array( $t_bug_id ) );\n\t\t} else {\n\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_access' );\n\t\t}\n\t\tbreak;\n\n\tcase 'UP_STATUS':\n\t\t$f_status = gpc_get_int( 'status' );\n\t\t$t_project = bug_get_field( $t_bug_id, 'project_id' );\n\t\tif ( access_has_bug_level( access_get_status_threshold( $f_status, $t_project ), $t_bug_id ) ) {\n\t\t\tif ( TRUE == bug_check_workflow($t_status, $f_status ) ) {\n\t\t\t\t/** @todo we need to issue a helper_call_custom_function( 'issue_update_validate', array( $t_bug_id, $t_bug_data, $f_bugnote_text ) ); */\n\t\t\t\tbug_set_field( $t_bug_id, 'status', $f_status );\n\n\t\t\t\t# Add bugnote if supplied\n\t\t\t\tif ( !is_blank( $f_bug_notetext ) ) {\n\t\t\t\t\tbugnote_add( $t_bug_id, $f_bug_notetext, null, $f_bug_noteprivate );\n\t\t\t\t}\n\n\t\t\t\thelper_call_custom_function( 'issue_update_notify', array( $t_bug_id ) );\n\t\t\t} else {\n\t\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_status' );\n\t\t\t}\n\t\t} else {\n\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_access' );\n\t\t}\n\t\tbreak;\n\n\tcase 'UP_CATEGORY':\n\t\t$f_category_id = gpc_get_int( 'category' );\n\t\tif ( access_has_bug_level( config_get( 'update_bug_threshold' ), $t_bug_id ) ) {\n\t\t\tif ( category_exists( $f_category_id ) ) {\n\t\t\t\t/** @todo we need to issue a helper_call_custom_function( 'issue_update_validate', array( $t_bug_id, $t_bug_data, $f_bugnote_text ) ); */\n\t\t\t\tbug_set_field( $t_bug_id, 'category_id', $f_category_id );\n\t\t\t\thelper_call_custom_function( 'issue_update_notify', array( $t_bug_id ) );\n\t\t\t} else {\n\t\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_category' );\n\t\t\t}\n\t\t} else {\n\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_access' );\n\t\t}\n\t\tbreak;\n\n\tcase 'UP_FIXED_IN_VERSION':\n\t\t$f_fixed_in_version = gpc_get_string( 'fixed_in_version' );\n\t\t$t_project_id = bug_get_field( $t_bug_id, 'project_id' );\n\n\t\tif ( access_has_bug_level( config_get( 'update_bug_threshold' ), $t_bug_id ) ) {\n\t\t\tif ( $f_fixed_in_version === '' || version_get_id( $f_fixed_in_version, $t_project_id ) !== false ) {\n\t\t\t\t/** @todo we need to issue a helper_call_custom_function( 'issue_update_validate', array( $t_bug_id, $t_bug_data, $f_bugnote_text ) ); */\n\t\t\t\tbug_set_field( $t_bug_id, 'fixed_in_version', $f_fixed_in_version );\n\t\t\t\thelper_call_custom_function( 'issue_update_notify', array( $t_bug_id ) );\n\t\t\t\t} else {\n\t\t\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_version' );\n\t\t\t}\n\t\t\t} else {\n\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_access' );\n\t\t}\n\t\tbreak;\n\n\tcase 'UP_TARGET_VERSION':\n\t\t$f_target_version = gpc_get_string( 'target_version' );\n\t\t$t_project_id = bug_get_field( $t_bug_id, 'project_id' );\n\n\t\tif ( access_has_bug_level( config_get( 'roadmap_update_threshold' ), $t_bug_id ) ) {\n\t\t\tif ( $f_target_version === '' || version_get_id( $f_target_version, $t_project_id ) !== false ) {\n\t\t\t\t/** @todo we need to issue a helper_call_custom_function( 'issue_update_validate', array( $t_bug_id, $t_bug_data, $f_bugnote_text ) ); */\n\t\t\t\tbug_set_field( $t_bug_id, 'target_version', $f_target_version );\n\t\t\t\thelper_call_custom_function( 'issue_update_notify', array( $t_bug_id ) );\n\t\t\t\t} else {\n\t\t\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_version' );\n\t\t\t}\n\t\t\t} else {\n\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_access' );\n\t\t}\n\t\tbreak;\n\n\tcase 'VIEW_STATUS':\n\t\tif ( access_has_bug_level( config_get( 'change_view_status_threshold' ), $t_bug_id ) ) {\n\t\t\t$f_view_status = gpc_get_int( 'view_status' );\n\t\t\t/** @todo we need to issue a helper_call_custom_function( 'issue_update_validate', array( $t_bug_id, $t_bug_data, $f_bugnote_text ) ); */\n\t\t\tbug_set_field( $t_bug_id, 'view_state', $f_view_status );\n\t\t\thelper_call_custom_function( 'issue_update_notify', array( $t_bug_id ) );\n\t\t} else {\n\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_access' );\n\t\t}\n\t\tbreak;\n\n\tcase 'SET_STICKY':\n\t\tif ( access_has_bug_level( config_get( 'set_bug_sticky_threshold' ), $t_bug_id ) ) {\n\t\t\t$f_sticky = bug_get_field( $t_bug_id, 'sticky' );\n\t\t\t// The new value is the inverted old value\n\t\t\t/** @todo we need to issue a helper_call_custom_function( 'issue_update_validate', array( $t_bug_id, $t_bug_data, $f_bugnote_text ) ); */\n\t\t\tbug_set_field( $t_bug_id, 'sticky', intval( !$f_sticky ) );\n\t\t\thelper_call_custom_function( 'issue_update_notify', array( $t_bug_id ) );\n\t\t} else {\n\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_access' );\n\t\t}\n\t\tbreak;\n\n\tcase 'CUSTOM':\n\t\tif ( 0 === $f_custom_field_id ) {\n\t\t\ttrigger_error( ERROR_GENERIC, ERROR );\n\t\t}\n\n\t\t/** @todo we need to issue a helper_call_custom_function( 'issue_update_validate', array( $t_bug_id, $t_bug_data, $f_bugnote_text ) ); */\n\t\t$t_form_var = \"custom_field_$f_custom_field_id\";\n\t\t$t_custom_field_value = gpc_get_custom_field( $t_form_var, $t_custom_field_def['type'], null );\n\t\tcustom_field_set_value( $f_custom_field_id, $t_bug_id, $t_custom_field_value );\n\t\thelper_call_custom_function( 'issue_update_notify', array( $t_bug_id ) );\n\t\tbreak;\n\n\tdefault:\n\t\ttrigger_error( ERROR_GENERIC, ERROR );\n\t}\n\n\t// Bug Action Event\n\tevent_signal( 'EVENT_BUG_ACTION', array( $f_action, $t_bug_id ) );\n}\n\nform_security_purge( $t_form_name );\n\n$t_redirect_url = 'view_all_bug_page.php';\n\nif ( count( $t_failed_ids ) > 0 ) {\n\thtml_page_top();\n\n\techo '<div><br />';\n\techo '<table class=\"width75\">';\n\t$separator = lang_get( 'word_separator' );\n\tforeach( $t_failed_ids as $t_id => $t_reason ) {\n\t\t$label = sprintf( lang_get( 'label' ), string_get_bug_view_link( $t_id ) ) . $separator;\n\t\tprintf( \"<tr><td width=\\\"50%%\\\">%s%s</td><td>%s</td></tr>\\n\", $label, bug_get_field( $t_id, 'summary' ), $t_reason );\n\t}\n\techo '</table><br />';\n\tprint_bracket_link( $t_redirect_url, lang_get( 'proceed' ) );\n\techo '</div>';\n\n\thtml_page_bottom();\n} else {\n\tprint_header_redirect( $t_redirect_url );\n}\n", "<?php\n# MantisBT - A PHP based bugtracking system\n\n# MantisBT is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 2 of the License, or\n# (at your option) any later version.\n#\n# MantisBT is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with MantisBT.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Bug API\n *\n * @package CoreAPI\n * @subpackage BugAPI\n * @copyright Copyright (C) 2000 - 2002  Kenzaburo Ito - kenito@300baud.org\n * @copyright Copyright (C) 2002 - 2012  MantisBT Team - mantisbt-dev@lists.sourceforge.net\n * @link http://www.mantisbt.org\n *\n * @uses access_api.php\n * @uses authentication_api.php\n * @uses bugnote_api.php\n * @uses bug_revision_api.php\n * @uses category_api.php\n * @uses config_api.php\n * @uses constant_inc.php\n * @uses custom_field_api.php\n * @uses database_api.php\n * @uses date_api.php\n * @uses email_api.php\n * @uses error_api.php\n * @uses event_api.php\n * @uses file_api.php\n * @uses helper_api.php\n * @uses history_api.php\n * @uses lang_api.php\n * @uses relationship_api.php\n * @uses sponsorship_api.php\n * @uses tag_api.php\n * @uses twitter_api.php\n * @uses user_api.php\n * @uses utility_api.php\n */\n\nrequire_api( 'access_api.php' );\nrequire_api( 'authentication_api.php' );\nrequire_api( 'bugnote_api.php' );\nrequire_api( 'bug_revision_api.php' );\nrequire_api( 'category_api.php' );\nrequire_api( 'config_api.php' );\nrequire_api( 'constant_inc.php' );\nrequire_api( 'custom_field_api.php' );\nrequire_api( 'database_api.php' );\nrequire_api( 'date_api.php' );\nrequire_api( 'email_api.php' );\nrequire_api( 'error_api.php' );\nrequire_api( 'event_api.php' );\nrequire_api( 'file_api.php' );\nrequire_api( 'helper_api.php' );\nrequire_api( 'history_api.php' );\nrequire_api( 'lang_api.php' );\nrequire_api( 'relationship_api.php' );\nrequire_api( 'sponsorship_api.php' );\nrequire_api( 'tag_api.php' );\nrequire_api( 'twitter_api.php' );\nrequire_api( 'user_api.php' );\nrequire_api( 'utility_api.php' );\n\n/**\n * Bug Data Structure Definition\n * @package MantisBT\n * @subpackage classes\n */\nclass BugData {\n\tprotected $id;\n\tprotected $project_id = null;\n\tprotected $reporter_id = 0;\n\tprotected $handler_id = 0;\n\tprotected $duplicate_id = 0;\n\tprotected $priority = NORMAL;\n\tprotected $severity = MINOR;\n\tprotected $reproducibility = 10;\n\tprotected $status = NEW_;\n\tprotected $resolution = OPEN;\n\tprotected $projection = 10;\n\tprotected $category_id = 1;\n\tprotected $date_submitted = '';\n\tprotected $last_updated = '';\n\tprotected $eta = 10;\n\tprotected $os = '';\n\tprotected $os_build = '';\n\tprotected $platform = '';\n\tprotected $version = '';\n\tprotected $fixed_in_version = '';\n\tprotected $target_version = '';\n\tprotected $build = '';\n\tprotected $view_state = VS_PUBLIC;\n\tprotected $summary = '';\n\tprotected $sponsorship_total = 0;\n\tprotected $sticky = 0;\n\tprotected $due_date = 0;\n\n\t# omitted:\n\t# var $bug_text_id\n\tprotected $profile_id = 0;\n\n\t# extended info\n\tprotected $description = '';\n\tprotected $steps_to_reproduce = '';\n\tprotected $additional_information = '';\n\n\t# internal helper objects\n\tprivate $_stats = null;\n\n\tpublic $attachment_count = null;\n\tpublic $bugnotes_count = null;\n\n\tprivate $loading = false;\n\n\t/**\n\t * return number of file attachment's linked to current bug\n\t * @return int\n\t */\n\tpublic function get_attachment_count() {\n\t\tif ( $this->attachment_count === null ) {\n\t\t\t$this->attachment_count = file_bug_attachment_count( $this->id );\n\t\t\treturn $this->attachment_count;\n\t\t} else {\n\t\t\treturn $this->attachment_count;\n\t\t}\n\t}\n\n\t/**\n\t * return number of bugnotes's linked to current bug\n\t * @return int\n\t */\n\tpublic function get_bugnotes_count() {\n\t\tif ( $this->bugnotes_count === null ) {\n\t\t\t$this->bugnotes_count = self::bug_get_bugnote_count();\n\t\t\treturn $this->bugnotes_count;\n\t\t} else {\n\t\t\treturn $this->bugnotes_count;\n\t\t}\n\t}\n\n\t/**\n\t * @private\n\t */\n\tpublic function __set($name, $value) {\n\t\tswitch ($name) {\n\t\t\t// integer types\n\t\t\tcase 'id':\n\t\t\tcase 'project_id':\n\t\t\tcase 'reporter_id':\n\t\t\tcase 'handler_id':\n\t\t\tcase 'duplicate_id':\n\t\t\tcase 'priority':\n\t\t\tcase 'severity':\n\t\t\tcase 'reproducibility':\n\t\t\tcase 'status':\n\t\t\tcase 'resolution':\n\t\t\tcase 'projection':\n\t\t\tcase 'category_id':\n\t\t\t\t$value = (int)$value;\n\t\t\t\tbreak;\n\t\t\tcase 'target_version':\n\t\t\t\tif ( !$this->loading ) {\n\t\t\t\t\t# Only set target_version if user has access to do so\n\t\t\t\t\tif( !access_has_project_level( config_get( 'roadmap_update_threshold' ) ) ) {\n\t\t\t\t\t\ttrigger_error( ERROR_ACCESS_DENIED, ERROR );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'due_date':\n\t\t\t\tif ( !is_numeric( $value ) ) {\n\t\t\t\t\t$value = strtotime($value);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t\t$this->$name = $value;\n\t}\n\n\t/**\n\t * @private\n\t */\n\tpublic function __get($name) {\n\t\tif( $this->is_extended_field($name) )\n\t\t\t$this->fetch_extended_info();\n\t\treturn $this->{$name};\n\t}\n\n\t/**\n\t * @private\n\t */\n\tpublic function __isset($name) {\n\t\treturn isset( $this->{$name} );\n\t}\n\n\t/**\n\t * fast-load database row into bugobject\n\t * @param array $p_row\n\t */\n\tpublic function loadrow( $p_row ) {\n\t\t$this->loading = true;\n\n\t\tforeach( $p_row as $var => $val ) {\n\t\t\t$this->__set( $var, $p_row[$var] );\n\t\t}\n\t\t$this->loading = false;\n\t}\n\n\t/**\n\t * Retrieves extended information for bug (e.g. bug description)\n\t * @return null\n\t */\n\tprivate function fetch_extended_info() {\n\t\tif ( $this->description == '' ) {\n\t\t\t$t_text = bug_text_cache_row($this->id);\n\n\t\t\t$this->description = $t_text['description'];\n\t\t\t$this->steps_to_reproduce = $t_text['steps_to_reproduce'];\n\t\t\t$this->additional_information = $t_text['additional_information'];\n\t\t}\n\t}\n\n\t/**\n\t * Returns if the field is an extended field which needs fetch_extended_info()\n\t * @return boolean\n\t */\n\tprivate function is_extended_field( $p_field_name ) {\n\t\tswitch( $p_field_name ) {\n\t\t\tcase 'description':\n\t\t\tcase 'steps_to_reproduce':\n\t\t\tcase 'additional_information':\n\t\t\t\treturn true;\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Returns the number of bugnotes for the given bug_id\n\t * @return int number of bugnotes\n\t * @access private\n\t * @uses database_api.php\n\t */\n\tprivate function bug_get_bugnote_count() {\n\t\tif( !access_has_project_level( config_get( 'private_bugnote_threshold' ), $this->project_id ) ) {\n\t\t\t$t_restriction = 'AND view_state=' . VS_PUBLIC;\n\t\t} else {\n\t\t\t$t_restriction = '';\n\t\t}\n\n\t\t$t_bugnote_table = db_get_table( 'bugnote' );\n\t\t$query = \"SELECT COUNT(*)\n\t\t\t\t\t  FROM $t_bugnote_table\n\t\t\t\t\t  WHERE bug_id =\" . db_param() . \" $t_restriction\";\n\t\t$result = db_query_bound( $query, Array( $this->bug_id ) );\n\n\t\treturn db_result( $result );\n\t}\n\n\t/**\n\t * validate current bug object for database insert/update\n\t * triggers error on failure\n\t * @param bool $p_update_extended\n\t */\n\tfunction validate( $p_update_extended =  true) {\n\t\t# Summary cannot be blank\n\t\tif( is_blank( $this->summary ) ) {\n\t\t\terror_parameters( lang_get( 'summary' ) );\n\t\t\ttrigger_error( ERROR_EMPTY_FIELD, ERROR );\n\t\t}\n\n\t\tif( $p_update_extended ) {\n\t\t\t# Description field cannot be empty\n\t\t\tif( is_blank( $this->description ) ) {\n\t\t\t\terror_parameters( lang_get( 'description' ) );\n\t\t\t\ttrigger_error( ERROR_EMPTY_FIELD, ERROR );\n\t\t\t}\n\t\t}\n\n\t\t# Make sure a category is set\n\t\tif( 0 == $this->category_id && !config_get( 'allow_no_category' ) ) {\n\t\t\terror_parameters( lang_get( 'category' ) );\n\t\t\ttrigger_error( ERROR_EMPTY_FIELD, ERROR );\n\t\t}\n\n\t\tif( !is_blank( $this->duplicate_id ) && ( $this->duplicate_id != 0 ) && ( $this->id == $this->duplicate_id ) ) {\n\t\t\ttrigger_error( ERROR_BUG_DUPLICATE_SELF, ERROR );\n\t\t\t# never returns\n\t\t}\n\t}\n\n\t/**\n\t * Insert a new bug into the database\n\t * @return int integer representing the bug id that was created\n\t * @access public\n\t * @uses database_api.php\n\t * @uses lang_api.php\n\t */\n\tfunction create() {\n\t\tself::validate( true );\n\n\t\t# check due_date format\n\t\tif( is_blank( $this->due_date ) ) {\n\t\t\t$this->due_date = date_get_null();\n\t\t}\n\t\t# check date submitted and last modified\n\t\tif( is_blank( $this->date_submitted ) ) {\n\t\t\t$this->date_submitted = db_now();\n\t\t}\n\t\tif( is_blank( $this->last_updated ) ) {\n\t\t\t$this->last_updated = db_now();\n\t\t}\n\n\t\t$t_bug_table = db_get_table( 'bug' );\n\t\t$t_bug_text_table = db_get_table( 'bug_text' );\n\t\t$t_category_table = db_get_table( 'category' );\n\n\t\t# Insert text information\n\t\t$query = \"INSERT INTO $t_bug_text_table\n\t\t\t\t\t    ( description, steps_to_reproduce, additional_information )\n\t\t\t\t\t  VALUES\n\t\t\t\t\t    ( \" . db_param() . ',' . db_param() . ',' . db_param() . ')';\n\t\tdb_query_bound( $query, Array( $this->description, $this->steps_to_reproduce, $this->additional_information ) );\n\n\t\t# Get the id of the text information we just inserted\n\t\t# NOTE: this is guarranteed to be the correct one.\n\t\t# The value LAST_INSERT_ID is stored on a per connection basis.\n\n\t\t$t_text_id = db_insert_id( $t_bug_text_table );\n\n\t\t# check to see if we want to assign this right off\n\t\t$t_starting_status  = config_get( 'bug_submit_status' );\n\t\t$t_original_status = $this->status;\n\n\t\t# if not assigned, check if it should auto-assigned.\n\t\tif( 0 == $this->handler_id ) {\n\t\t\t# if a default user is associated with the category and we know at this point\n\t\t\t# that that the bug was not assigned to somebody, then assign it automatically.\n\t\t\t$query = \"SELECT user_id\n\t\t\t\t\t\t  FROM $t_category_table\n\t\t\t\t\t\t  WHERE id=\" . db_param();\n\t\t\t$result = db_query_bound( $query, array( $this->category_id ) );\n\n\t\t\tif( db_num_rows( $result ) > 0 ) {\n\t\t\t\t$this->handler_id = db_result( $result );\n\t\t\t}\n\t\t}\n\n\t\t# Check if bug was pre-assigned or auto-assigned.\n\t\tif( ( $this->handler_id != 0 ) && ( $this->status == $t_starting_status ) && ( ON == config_get( 'auto_set_status_to_assigned' ) ) ) {\n\t\t\t$t_status = config_get( 'bug_assigned_status' );\n\t\t} else {\n\t\t\t$t_status = $this->status;\n\t\t}\n\n\t\t# Insert the rest of the data\n\t\t$query = \"INSERT INTO $t_bug_table\n\t\t\t\t\t    ( project_id,reporter_id, handler_id,duplicate_id,\n\t\t\t\t\t      priority,severity, reproducibility,status,\n\t\t\t\t\t      resolution,projection, category_id,date_submitted,\n\t\t\t\t\t      last_updated,eta, bug_text_id,\n\t\t\t\t\t      os, os_build,platform, version,build,\n\t\t\t\t\t      profile_id, summary, view_state, sponsorship_total, sticky, fixed_in_version,\n\t\t\t\t\t      target_version, due_date\n\t\t\t\t\t    )\n\t\t\t\t\t  VALUES\n\t\t\t\t\t    ( \" . db_param() . ',' . db_param() . ',' . db_param() . ',' . db_param() . \",\n\t\t\t\t\t      \" . db_param() . ',' . db_param() . ',' . db_param() . ',' . db_param() . \",\n\t\t\t\t\t      \" . db_param() . ',' . db_param() . ',' . db_param() . ',' . db_param() . \",\n\t\t\t\t\t      \" . db_param() . ',' . db_param() . ',' . db_param() . ',' . db_param() . \",\n\t\t\t\t\t      \" . db_param() . ',' . db_param() . ',' . db_param() . ',' . db_param() . \",\n\t\t\t\t\t      \" . db_param() . ',' . db_param() . ',' . db_param() . ',' . db_param() . \",\n\t\t\t\t\t      \" . db_param() . ',' . db_param() . ',' . db_param() . ',' . db_param() . ')';\n\n\t\tdb_query_bound( $query, Array( $this->project_id, $this->reporter_id, $this->handler_id, $this->duplicate_id, $this->priority, $this->severity, $this->reproducibility, $t_status, $this->resolution, $this->projection, $this->category_id, $this->date_submitted, $this->last_updated, $this->eta, $t_text_id, $this->os, $this->os_build, $this->platform, $this->version, $this->build, $this->profile_id, $this->summary, $this->view_state, $this->sponsorship_total, $this->sticky, $this->fixed_in_version, $this->target_version, $this->due_date ) );\n\n\t\t$this->id = db_insert_id( $t_bug_table );\n\n\t\t# log new bug\n\t\thistory_log_event_special( $this->id, NEW_BUG );\n\n\t\t# log changes, if any (compare happens in history_log_event_direct)\n\t\thistory_log_event_direct( $this->id, 'status', $t_original_status, $t_status );\n\t\thistory_log_event_direct( $this->id, 'handler_id', 0, $this->handler_id );\n\n\t\treturn $this->id;\n\t}\n\n\t/**\n\t * Update a bug from the given data structure\n\t *  If the third parameter is true, also update the longer strings table\n\t * @param bool p_update_extended\n\t * @param bool p_bypass_email Default false, set to true to avoid generating emails (if sending elsewhere)\n\t * @return bool (always true)\n\t * @access public\n\t */\n\tfunction update( $p_update_extended = false, $p_bypass_mail = false ) {\n\t\tself::validate( $p_update_extended );\n\n\t\t$c_bug_id = $this->id;\n\n\t\tif( is_blank( $this->due_date ) ) {\n\t\t\t$this->due_date = date_get_null();\n\t\t}\n\n\t\t$t_old_data = bug_get( $this->id, true );\n\n\t\t$t_bug_table = db_get_table( 'bug' );\n\n\t\t# Update all fields\n\t\t# Ignore date_submitted and last_updated since they are pulled out\n\t\t#  as unix timestamps which could confuse the history log and they\n\t\t#  shouldn't get updated like this anyway.  If you really need to change\n\t\t#  them use bug_set_field()\n\t\t$query = \"UPDATE $t_bug_table\n\t\t\t\t\tSET project_id=\" . db_param() . ', reporter_id=' . db_param() . \",\n\t\t\t\t\t\thandler_id=\" . db_param() . ', duplicate_id=' . db_param() . \",\n\t\t\t\t\t\tpriority=\" . db_param() . ', severity=' . db_param() . \",\n\t\t\t\t\t\treproducibility=\" . db_param() . ', status=' . db_param() . \",\n\t\t\t\t\t\tresolution=\" . db_param() . ', projection=' . db_param() . \",\n\t\t\t\t\t\tcategory_id=\" . db_param() . ', eta=' . db_param() . \",\n\t\t\t\t\t\tos=\" . db_param() . ', os_build=' . db_param() . \",\n\t\t\t\t\t\tplatform=\" . db_param() . ', version=' . db_param() . \",\n\t\t\t\t\t\tbuild=\" . db_param() . ', fixed_in_version=' . db_param() . ',';\n\n\t\t$t_fields = Array(\n\t\t\t$this->project_id, $this->reporter_id,\n\t\t\t$this->handler_id, $this->duplicate_id,\n\t\t\t$this->priority, $this->severity,\n\t\t\t$this->reproducibility, $this->status,\n\t\t\t$this->resolution, $this->projection,\n\t\t\t$this->category_id, $this->eta,\n\t\t\t$this->os, $this->os_build,\n\t\t\t$this->platform, $this->version,\n\t\t\t$this->build, $this->fixed_in_version,\n\t\t);\n\t\t$t_roadmap_updated = false;\n\t\tif( access_has_project_level( config_get( 'roadmap_update_threshold' ) ) ) {\n\t\t\t$query .= \"\n\t\t\t\t\t\ttarget_version=\" . db_param() . \",\";\n\t\t\t$t_fields[] = $this->target_version;\n\t\t\t$t_roadmap_updated = true;\n\t\t}\n\n\t\t$query .= \"\n\t\t\t\t\t\tview_state=\" . db_param() . \",\n\t\t\t\t\t\tsummary=\" . db_param() . \",\n\t\t\t\t\t\tsponsorship_total=\" . db_param() . \",\n\t\t\t\t\t\tsticky=\" . db_param() . \",\n\t\t\t\t\t\tdue_date=\" . db_param() . \"\n\t\t\t\t\tWHERE id=\" . db_param();\n\t\t$t_fields[] = $this->view_state;\n\t\t$t_fields[] = $this->summary;\n\t\t$t_fields[] = $this->sponsorship_total;\n\t\t$t_fields[] = (bool)$this->sticky;\n\t\t$t_fields[] = $this->due_date;\n\t\t$t_fields[] = $this->id;\n\n\t\tdb_query_bound( $query, $t_fields );\n\n\t\tbug_clear_cache( $this->id );\n\n\t\t# log changes\n\t\thistory_log_event_direct( $c_bug_id, 'project_id', $t_old_data->project_id, $this->project_id );\n\t\thistory_log_event_direct( $c_bug_id, 'reporter_id', $t_old_data->reporter_id, $this->reporter_id );\n\t\thistory_log_event_direct( $c_bug_id, 'handler_id', $t_old_data->handler_id, $this->handler_id );\n\t\thistory_log_event_direct( $c_bug_id, 'priority', $t_old_data->priority, $this->priority );\n\t\thistory_log_event_direct( $c_bug_id, 'severity', $t_old_data->severity, $this->severity );\n\t\thistory_log_event_direct( $c_bug_id, 'reproducibility', $t_old_data->reproducibility, $this->reproducibility );\n\t\thistory_log_event_direct( $c_bug_id, 'status', $t_old_data->status, $this->status );\n\t\thistory_log_event_direct( $c_bug_id, 'resolution', $t_old_data->resolution, $this->resolution );\n\t\thistory_log_event_direct( $c_bug_id, 'projection', $t_old_data->projection, $this->projection );\n\t\thistory_log_event_direct( $c_bug_id, 'category', category_full_name( $t_old_data->category_id, false ), category_full_name( $this->category_id, false ) );\n\t\thistory_log_event_direct( $c_bug_id, 'eta', $t_old_data->eta, $this->eta );\n\t\thistory_log_event_direct( $c_bug_id, 'os', $t_old_data->os, $this->os );\n\t\thistory_log_event_direct( $c_bug_id, 'os_build', $t_old_data->os_build, $this->os_build );\n\t\thistory_log_event_direct( $c_bug_id, 'platform', $t_old_data->platform, $this->platform );\n\t\thistory_log_event_direct( $c_bug_id, 'version', $t_old_data->version, $this->version );\n\t\thistory_log_event_direct( $c_bug_id, 'build', $t_old_data->build, $this->build );\n\t\thistory_log_event_direct( $c_bug_id, 'fixed_in_version', $t_old_data->fixed_in_version, $this->fixed_in_version );\n\t\tif( $t_roadmap_updated ) {\n\t\t\thistory_log_event_direct( $c_bug_id, 'target_version', $t_old_data->target_version, $this->target_version );\n\t\t}\n\t\thistory_log_event_direct( $c_bug_id, 'view_state', $t_old_data->view_state, $this->view_state );\n\t\thistory_log_event_direct( $c_bug_id, 'summary', $t_old_data->summary, $this->summary );\n\t\thistory_log_event_direct( $c_bug_id, 'sponsorship_total', $t_old_data->sponsorship_total, $this->sponsorship_total );\n\t\thistory_log_event_direct( $c_bug_id, 'sticky', $t_old_data->sticky, $this->sticky );\n\n\t\thistory_log_event_direct( $c_bug_id, 'due_date', ( $t_old_data->due_date != date_get_null() ) ? $t_old_data->due_date : null, ( $this->due_date != date_get_null() ) ? $this->due_date : null );\n\n\t\t# Update extended info if requested\n\t\tif( $p_update_extended ) {\n\t\t\t$t_bug_text_table = db_get_table( 'bug_text' );\n\n\t\t\t$t_bug_text_id = bug_get_field( $c_bug_id, 'bug_text_id' );\n\n\t\t\t$query = \"UPDATE $t_bug_text_table\n\t\t\t\t\t\t\tSET description=\" . db_param() . \",\n\t\t\t\t\t\t\t\tsteps_to_reproduce=\" . db_param() . \",\n\t\t\t\t\t\t\t\tadditional_information=\" . db_param() . \"\n\t\t\t\t\t\t\tWHERE id=\" . db_param();\n\t\t\tdb_query_bound( $query, Array( $this->description, $this->steps_to_reproduce, $this->additional_information, $t_bug_text_id ) );\n\n\t\t\tbug_text_clear_cache( $c_bug_id );\n\n\t\t\t$t_current_user = auth_get_current_user_id();\n\n\t\t\tif( $t_old_data->description != $this->description ) {\n\t\t\t\tif ( bug_revision_count( $c_bug_id, REV_DESCRIPTION ) < 1 ) {\n\t\t\t\t\t$t_revision_id = bug_revision_add( $c_bug_id, $t_current_user, REV_DESCRIPTION, $t_old_data->description, 0, $t_old_data->last_updated );\n\t\t\t\t}\n\t\t\t\t$t_revision_id = bug_revision_add( $c_bug_id, $t_current_user, REV_DESCRIPTION, $this->description );\n\t\t\t\thistory_log_event_special( $c_bug_id, DESCRIPTION_UPDATED, $t_revision_id );\n\t\t\t}\n\n\t\t\tif( $t_old_data->steps_to_reproduce != $this->steps_to_reproduce ) {\n\t\t\t\tif ( bug_revision_count( $c_bug_id, REV_STEPS_TO_REPRODUCE ) < 1 ) {\n\t\t\t\t\t$t_revision_id = bug_revision_add( $c_bug_id, $t_current_user, REV_STEPS_TO_REPRODUCE, $t_old_data->steps_to_reproduce, 0, $t_old_data->last_updated );\n\t\t\t\t}\n\t\t\t\t$t_revision_id = bug_revision_add( $c_bug_id, $t_current_user, REV_STEPS_TO_REPRODUCE, $this->steps_to_reproduce );\n\t\t\t\thistory_log_event_special( $c_bug_id, STEP_TO_REPRODUCE_UPDATED, $t_revision_id );\n\t\t\t}\n\n\t\t\tif( $t_old_data->additional_information != $this->additional_information ) {\n\t\t\t\tif ( bug_revision_count( $c_bug_id, REV_ADDITIONAL_INFO ) < 1 ) {\n\t\t\t\t\t$t_revision_id = bug_revision_add( $c_bug_id, $t_current_user, REV_ADDITIONAL_INFO, $t_old_data->additional_information, 0, $t_old_data->last_updated );\n\t\t\t\t}\n\t\t\t\t$t_revision_id = bug_revision_add( $c_bug_id, $t_current_user, REV_ADDITIONAL_INFO, $this->additional_information );\n\t\t\t\thistory_log_event_special( $c_bug_id, ADDITIONAL_INFO_UPDATED, $t_revision_id );\n\t\t\t}\n\t\t}\n\n\t\t# Update the last update date\n\t\tbug_update_date( $c_bug_id );\n\n\t\t# allow bypass if user is sending mail separately\n\t\tif( false == $p_bypass_mail ) {\n\t\t\t# bug assigned\n\t\t\tif( $t_old_data->handler_id != $this->handler_id ) {\n\t\t\t\temail_generic( $c_bug_id, 'owner', 'email_notification_title_for_action_bug_assigned' );\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t# status changed\n\t\t\tif( $t_old_data->status != $this->status ) {\n\t\t\t\t$t_status = MantisEnum::getLabel( config_get( 'status_enum_string' ), $this->status );\n\t\t\t\t$t_status = str_replace( ' ', '_', $t_status );\n\t\t\t\temail_generic( $c_bug_id, $t_status, 'email_notification_title_for_status_bug_' . $t_status );\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t# @todo handle priority change if it requires special handling\n\t\t\t# generic update notification\n\t\t\temail_generic( $c_bug_id, 'updated', 'email_notification_title_for_action_bug_updated' );\n\t\t}\n\n\t\treturn true;\n\t}\n}\n\n$g_cache_bug = array();\n$g_cache_bug_text = array();\n\n/**\n * Cache a database result-set containing full contents of bug_table row.\n * @param array p_bug_database_result database row containing all columns from mantis_bug_table\n * @param array p_stats (optional) array representing bugnote stats\n * @return array returns an array representing the bug row if bug exists\n * @access public\n */\nfunction bug_cache_database_result( $p_bug_database_result, $p_stats = null ) {\n\tglobal $g_cache_bug;\n\n\tif( !is_array( $p_bug_database_result ) || isset( $g_cache_bug[(int) $p_bug_database_result['id']] ) ) {\n\t\treturn $g_cache_bug[(int) $p_bug_database_result['id']];\n\t}\n\n\treturn bug_add_to_cache( $p_bug_database_result, $p_stats );\n}\n\n/**\n * Cache a bug row if necessary and return the cached copy\n * @param array p_bug_id id of bug to cache from mantis_bug_table\n * @param array p_trigger_errors set to true to trigger an error if the bug does not exist.\n * @return bool|array returns an array representing the bug row if bug exists or false if bug does not exist\n * @access public\n * @uses database_api.php\n */\nfunction bug_cache_row( $p_bug_id, $p_trigger_errors = true ) {\n\tglobal $g_cache_bug;\n\n\tif( isset( $g_cache_bug[$p_bug_id] ) ) {\n\t\treturn $g_cache_bug[$p_bug_id];\n\t}\n\n\t$c_bug_id = (int) $p_bug_id;\n\t$t_bug_table = db_get_table( 'bug' );\n\n\t$query = \"SELECT *\n\t\t\t\t  FROM $t_bug_table\n\t\t\t\t  WHERE id=\" . db_param();\n\t$result = db_query_bound( $query, Array( $c_bug_id ) );\n\n\tif( 0 == db_num_rows( $result ) ) {\n\t\t$g_cache_bug[$c_bug_id] = false;\n\n\t\tif( $p_trigger_errors ) {\n\t\t\terror_parameters( $p_bug_id );\n\t\t\ttrigger_error( ERROR_BUG_NOT_FOUND, ERROR );\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t$row = db_fetch_array( $result );\n\n\treturn bug_add_to_cache( $row );\n}\n\n/**\n * Cache a set of bugs\n * @param array p_bug_id_array integer array representing bug ids to cache\n * @return null\n * @access public\n * @uses database_api.php\n */\nfunction bug_cache_array_rows( $p_bug_id_array ) {\n\tglobal $g_cache_bug;\n\t$c_bug_id_array = array();\n\n\tforeach( $p_bug_id_array as $t_bug_id ) {\n\t\tif( !isset( $g_cache_bug[(int) $t_bug_id] ) ) {\n\t\t\t$c_bug_id_array[] = (int) $t_bug_id;\n\t\t}\n\t}\n\n\tif( empty( $c_bug_id_array ) ) {\n\t\treturn;\n\t}\n\n\t$t_bug_table = db_get_table( 'bug' );\n\n\t$query = \"SELECT *\n\t\t\t\t  FROM $t_bug_table\n\t\t\t\t  WHERE id IN (\" . implode( ',', $c_bug_id_array ) . ')';\n\t$result = db_query_bound( $query );\n\n\twhile( $row = db_fetch_array( $result ) ) {\n\t\tbug_add_to_cache( $row );\n\t}\n\treturn;\n}\n\n/**\n * Inject a bug into the bug cache\n * @param array p_bug_row bug row to cache\n * @param array p_stats bugnote stats to cache\n * @return null\n * @access private\n */\nfunction bug_add_to_cache( $p_bug_row, $p_stats = null ) {\n\tglobal $g_cache_bug;\n\n\t$g_cache_bug[(int) $p_bug_row['id']] = $p_bug_row;\n\n\tif( !is_null( $p_stats ) ) {\n\t\t$g_cache_bug[(int) $p_bug_row['id']]['_stats'] = $p_stats;\n\t}\n\n\treturn $g_cache_bug[(int) $p_bug_row['id']];\n}\n\n/**\n * Clear a bug from the cache or all bugs if no bug id specified.\n * @param int bug id to clear (optional)\n * @return null\n * @access public\n */\nfunction bug_clear_cache( $p_bug_id = null ) {\n\tglobal $g_cache_bug;\n\n\tif( null === $p_bug_id ) {\n\t\t$g_cache_bug = array();\n\t} else {\n\t\tunset( $g_cache_bug[(int) $p_bug_id] );\n\t}\n\n\treturn true;\n}\n\n/**\n * Cache a bug text row if necessary and return the cached copy\n * @param int p_bug_id integer bug id to retrieve text for\n * @param bool p_trigger_errors If the second parameter is true (default), trigger an error if bug text not found.\n * @return bool|array returns false if not bug text found or array of bug text\n * @access public\n * @uses database_api.php\n */\nfunction bug_text_cache_row( $p_bug_id, $p_trigger_errors = true ) {\n\tglobal $g_cache_bug_text;\n\n\t$c_bug_id = (int) $p_bug_id;\n\t$t_bug_table = db_get_table( 'bug' );\n\t$t_bug_text_table = db_get_table( 'bug_text' );\n\n\tif( isset( $g_cache_bug_text[$c_bug_id] ) ) {\n\t\treturn $g_cache_bug_text[$c_bug_id];\n\t}\n\n\t$query = \"SELECT bt.*\n\t\t\t\t  FROM $t_bug_text_table bt, $t_bug_table b\n\t\t\t\t  WHERE b.id=\" . db_param() . \" AND\n\t\t\t\t  \t\tb.bug_text_id = bt.id\";\n\t$result = db_query_bound( $query, Array( $c_bug_id ) );\n\n\tif( 0 == db_num_rows( $result ) ) {\n\t\t$g_cache_bug_text[$c_bug_id] = false;\n\n\t\tif( $p_trigger_errors ) {\n\t\t\terror_parameters( $p_bug_id );\n\t\t\ttrigger_error( ERROR_BUG_NOT_FOUND, ERROR );\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t$row = db_fetch_array( $result );\n\n\t$g_cache_bug_text[$c_bug_id] = $row;\n\n\treturn $row;\n}\n\n/**\n * Clear a bug's bug text from the cache or all bug text if no bug id specified.\n * @param int bug id to clear (optional)\n * @return null\n * @access public\n */\nfunction bug_text_clear_cache( $p_bug_id = null ) {\n\tglobal $g_cache_bug_text;\n\n\tif( null === $p_bug_id ) {\n\t\t$g_cache_bug_text = array();\n\t} else {\n\t\tunset( $g_cache_bug_text[(int) $p_bug_id] );\n\t}\n\n\treturn true;\n}\n\n/**\n * Check if a bug exists\n * @param int p_bug_id integer representing bug id\n * @return bool true if bug exists, false otherwise\n * @access public\n */\nfunction bug_exists( $p_bug_id ) {\n\tif( false == bug_cache_row( $p_bug_id, false ) ) {\n\t\treturn false;\n\t} else {\n\t\treturn true;\n\t}\n}\n\n/**\n * Check if a bug exists. If it doesn't then trigger an error\n * @param int p_bug_id integer representing bug id\n * @return null\n * @access public\n */\nfunction bug_ensure_exists( $p_bug_id ) {\n\tif( !bug_exists( $p_bug_id ) ) {\n\t\terror_parameters( $p_bug_id );\n\t\ttrigger_error( ERROR_BUG_NOT_FOUND, ERROR );\n\t}\n}\n\n/**\n * check if the given user is the reporter of the bug\n * @param int p_bug_id integer representing bug id\n * @param int p_user_id integer reprenting a user id\n * @return bool return true if the user is the reporter, false otherwise\n * @access public\n */\nfunction bug_is_user_reporter( $p_bug_id, $p_user_id ) {\n\tif( bug_get_field( $p_bug_id, 'reporter_id' ) == $p_user_id ) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\n/**\n * check if the given user is the handler of the bug\n * @param int p_bug_id integer representing bug id\n * @param int p_user_id integer reprenting a user id\n * @return bool return true if the user is the handler, false otherwise\n * @access public\n */\nfunction bug_is_user_handler( $p_bug_id, $p_user_id ) {\n\tif( bug_get_field( $p_bug_id, 'handler_id' ) == $p_user_id ) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\n/**\n * Check if the bug is readonly and shouldn't be modified\n * For a bug to be readonly the status has to be >= bug_readonly_status_threshold and\n * current user access level < update_readonly_bug_threshold.\n * @param int p_bug_id integer representing bug id\n * @return bool\n * @access public\n * @uses access_api.php\n * @uses config_api.php\n */\nfunction bug_is_readonly( $p_bug_id ) {\n\t$t_status = bug_get_field( $p_bug_id, 'status' );\n\tif( $t_status < config_get( 'bug_readonly_status_threshold' ) ) {\n\t\treturn false;\n\t}\n\n\tif( access_has_bug_level( config_get( 'update_readonly_bug_threshold' ), $p_bug_id ) ) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n/**\n * Check if a given bug is resolved\n * @param int p_bug_id integer representing bug id\n * @return bool true if bug is resolved, false otherwise\n * @access public\n * @uses config_api.php\n */\nfunction bug_is_resolved( $p_bug_id ) {\n\t$t_status = bug_get_field( $p_bug_id, 'status' );\n\treturn( $t_status >= config_get( 'bug_resolved_status_threshold' ) );\n}\n\n/**\n * Check if a given bug is overdue\n * @param int p_bug_id integer representing bug id\n * @return bool true if bug is overdue, false otherwise\n * @access public\n * @uses database_api.php\n */\nfunction bug_is_overdue( $p_bug_id ) {\n\t$t_due_date = bug_get_field( $p_bug_id, 'due_date' );\n\tif( !date_is_null( $t_due_date ) ) {\n\t\t$t_now = db_now();\n\t\tif( $t_now > $t_due_date ) {\n\t\t\tif( !bug_is_resolved( $p_bug_id ) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\n/**\n * Validate workflow state to see if bug can be moved to requested state\n * @param int p_bug_status current bug status\n * @param int p_wanted_status new bug status\n * @return bool\n * @access public\n * @uses config_api.php\n * @uses utility_api.php\n */\nfunction bug_check_workflow( $p_bug_status, $p_wanted_status ) {\n\t$t_status_enum_workflow = config_get( 'status_enum_workflow' );\n\n\tif( count( $t_status_enum_workflow ) < 1 ) {\n\n\t\t# workflow not defined, use default enum\n\t\treturn true;\n\t}\n\n\tif ( $p_bug_status == $p_wanted_status ) {\n\t\t# no change in state, allow the transition\n\t\treturn true;\n\t}\n\n\t# workflow defined - find allowed states\n\t$t_allowed_states = $t_status_enum_workflow[$p_bug_status];\n\n\treturn MantisEnum::hasValue( $t_allowed_states, $p_wanted_status );\n}\n\n/**\n * Copy a bug from one project to another. Also make copies of issue notes, attachments, history,\n * email notifications etc.\n * @todo Not managed FTP file upload\n * @param array p_bug_id integer representing bug id\n * @param int p_target_project_id\n * @param bool p_copy_custom_fields\n * @param bool p_copy_relationships\n * @return int representing the new bugid\n * @access public\n */\nfunction bug_copy( $p_bug_id, $p_target_project_id = null, $p_copy_custom_fields = false, $p_copy_relationships = false, $p_copy_history = false, $p_copy_attachments = false, $p_copy_bugnotes = false, $p_copy_monitoring_users = false ) {\n\tglobal $g_db;\n\n\t$t_mantis_custom_field_string_table = db_get_table( 'custom_field_string' );\n\t$t_mantis_bug_file_table = db_get_table( 'bug_file' );\n\t$t_mantis_bugnote_table = db_get_table( 'bugnote' );\n\t$t_mantis_bugnote_text_table = db_get_table( 'bugnote_text' );\n\t$t_mantis_bug_history_table = db_get_table( 'bug_history' );\n\t$t_mantis_db = $g_db;\n\n\t$t_bug_id = db_prepare_int( $p_bug_id );\n\t$t_target_project_id = db_prepare_int( $p_target_project_id );\n\n\t$t_bug_data = bug_get( $t_bug_id, true );\n\n\t# retrieve the project id associated with the bug\n\tif(( $p_target_project_id == null ) || is_blank( $p_target_project_id ) ) {\n\t\t$t_target_project_id = $t_bug_data->project_id;\n\t}\n\n\t$t_bug_data->project_id = $t_target_project_id;\n\n\t$t_new_bug_id = $t_bug_data->create();\n\n\t# MASC ATTENTION: IF THE SOURCE BUG HAS TO HANDLER THE bug_create FUNCTION CAN TRY TO AUTO-ASSIGN THE BUG\n\t# WE FORCE HERE TO DUPLICATE THE SAME HANDLER OF THE SOURCE BUG\n\t# @todo VB: Shouldn't we check if the handler in the source project is also a handler in the destination project?\n\tbug_set_field( $t_new_bug_id, 'handler_id', $t_bug_data->handler_id );\n\n\tbug_set_field( $t_new_bug_id, 'duplicate_id', $t_bug_data->duplicate_id );\n\tbug_set_field( $t_new_bug_id, 'status', $t_bug_data->status );\n\tbug_set_field( $t_new_bug_id, 'resolution', $t_bug_data->resolution );\n\tbug_set_field( $t_new_bug_id, 'projection', $t_bug_data->projection );\n\tbug_set_field( $t_new_bug_id, 'date_submitted', $t_bug_data->date_submitted );\n\tbug_set_field( $t_new_bug_id, 'last_updated', $t_bug_data->last_updated );\n\tbug_set_field( $t_new_bug_id, 'eta', $t_bug_data->eta );\n\tbug_set_field( $t_new_bug_id, 'fixed_in_version', $t_bug_data->fixed_in_version );\n\tbug_set_field( $t_new_bug_id, 'target_version', $t_bug_data->target_version );\n\tbug_set_field( $t_new_bug_id, 'sponsorship_total', 0 );\n\tbug_set_field( $t_new_bug_id, 'sticky', 0 );\n\tbug_set_field( $t_new_bug_id, 'due_date', $t_bug_data->due_date );\n\n\t# COPY CUSTOM FIELDS\n\tif( $p_copy_custom_fields ) {\n\t\t$query = \"SELECT field_id, bug_id, value\n\t\t\t\t\t   FROM $t_mantis_custom_field_string_table\n\t\t\t\t\t   WHERE bug_id=\" . db_param();\n\t\t$result = db_query_bound( $query, Array( $t_bug_id ) );\n\t\t$t_count = db_num_rows( $result );\n\n\t\tfor( $i = 0;$i < $t_count;$i++ ) {\n\t\t\t$t_bug_custom = db_fetch_array( $result );\n\n\t\t\t$c_field_id = db_prepare_int( $t_bug_custom['field_id'] );\n\t\t\t$c_new_bug_id = db_prepare_int( $t_new_bug_id );\n\t\t\t$c_value = $t_bug_custom['value'];\n\n\t\t\t$query = \"INSERT INTO $t_mantis_custom_field_string_table\n\t\t\t\t\t\t   ( field_id, bug_id, value )\n\t\t\t\t\t\t   VALUES (\" . db_param() . ', ' . db_param() . ', ' . db_param() . ')';\n\t\t\tdb_query_bound( $query, Array( $c_field_id, $c_new_bug_id, $c_value ) );\n\t\t}\n\t}\n\n\t# Copy Relationships\n\tif( $p_copy_relationships ) {\n\t\trelationship_copy_all( $t_bug_id, $t_new_bug_id );\n\t}\n\n\t# Copy bugnotes\n\tif( $p_copy_bugnotes ) {\n\t\t$query = \"SELECT *\n\t\t\t\t\t  FROM $t_mantis_bugnote_table\n\t\t\t\t\t  WHERE bug_id=\" . db_param();\n\t\t$result = db_query_bound( $query, Array( $t_bug_id ) );\n\t\t$t_count = db_num_rows( $result );\n\n\t\tfor( $i = 0;$i < $t_count;$i++ ) {\n\t\t\t$t_bug_note = db_fetch_array( $result );\n\t\t\t$t_bugnote_text_id = $t_bug_note['bugnote_text_id'];\n\n\t\t\t$query2 = \"SELECT *\n\t\t\t\t\t\t   FROM $t_mantis_bugnote_text_table\n\t\t\t\t\t\t   WHERE id=\" . db_param();\n\t\t\t$result2 = db_query_bound( $query2, Array( $t_bugnote_text_id ) );\n\t\t\t$t_count2 = db_num_rows( $result2 );\n\n\t\t\t$t_bugnote_text_insert_id = -1;\n\t\t\tif( $t_count2 > 0 ) {\n\t\t\t\t$t_bugnote_text = db_fetch_array( $result2 );\n\n\t\t\t\t$query2 = \"INSERT INTO $t_mantis_bugnote_text_table\n\t\t\t\t\t\t\t   ( note )\n\t\t\t\t\t\t\t   VALUES ( \" . db_param() . ' )';\n\t\t\t\tdb_query_bound( $query2, Array( $t_bugnote_text['note'] ) );\n\t\t\t\t$t_bugnote_text_insert_id = db_insert_id( $t_mantis_bugnote_text_table );\n\t\t\t}\n\n\t\t\t$query2 = \"INSERT INTO $t_mantis_bugnote_table\n\t\t\t\t\t\t   ( bug_id, reporter_id, bugnote_text_id, view_state, date_submitted, last_modified )\n\t\t\t\t\t\t   VALUES ( \" . db_param() . \",\n\t\t\t\t\t\t   \t\t\t\" . db_param() . \",\n\t\t\t\t\t\t   \t\t\t\" . db_param() . \",\n\t\t\t\t\t\t   \t\t\t\" . db_param() . \",\n\t\t\t\t\t\t   \t\t\t\" . db_param() . \",\n\t\t\t\t\t\t   \t\t\t\" . db_param() . ')';\n\t\t\tdb_query_bound( $query2, Array( $t_new_bug_id, $t_bug_note['reporter_id'], $t_bugnote_text_insert_id, $t_bug_note['view_state'], $t_bug_note['date_submitted'], $t_bug_note['last_modified'] ) );\n\t\t}\n\t}\n\n\t# Copy attachments\n\tif( $p_copy_attachments ) {\n\t    file_copy_attachments( $t_bug_id , $t_new_bug_id );\n\t}\n\n\t# Copy users monitoring bug\n\tif( $p_copy_monitoring_users ) {\n\t\tbug_monitor_copy( $t_bug_id, $t_new_bug_id );\n\t}\n\n\t# COPY HISTORY\n\thistory_delete( $t_new_bug_id );\t# should history only be deleted inside the if statement below?\n\tif( $p_copy_history ) {\n\t\t$query = \"SELECT *\n\t\t\t\t\t  FROM $t_mantis_bug_history_table\n\t\t\t\t\t  WHERE bug_id = \" . db_param();\n\t\t$result = db_query_bound( $query, Array( $t_bug_id ) );\n\t\t$t_count = db_num_rows( $result );\n\n\t\tfor( $i = 0;$i < $t_count;$i++ ) {\n\t\t\t$t_bug_history = db_fetch_array( $result );\n\t\t\t$query = \"INSERT INTO $t_mantis_bug_history_table\n\t\t\t\t\t\t  ( user_id, bug_id, date_modified, field_name, old_value, new_value, type )\n\t\t\t\t\t\t  VALUES ( \" . db_param() . \",\n\t\t\t\t\t\t  \t\t   \" . db_param() . \",\n\t\t\t\t\t\t  \t\t   \" . db_param() . \",\n\t\t\t\t\t\t  \t\t   \" . db_param() . \",\n\t\t\t\t\t\t  \t\t   \" . db_param() . \",\n\t\t\t\t\t\t  \t\t   \" . db_param() . \",\n\t\t\t\t\t\t  \t\t   \" . db_param() . \" );\";\n\t\t\tdb_query_bound( $query, Array( $t_bug_history['user_id'], $t_new_bug_id, $t_bug_history['date_modified'], $t_bug_history['field_name'], $t_bug_history['old_value'], $t_bug_history['new_value'], $t_bug_history['type'] ) );\n\t\t}\n\t}\n\n\treturn $t_new_bug_id;\n}\n\n/**\n * Moves an issue from a project to another.\n *\n * @todo Validate with sub-project / category inheritance scenarios.\n * @param int p_bug_id The bug to be moved.\n * @param int p_target_project_id The target project to move the bug to.\n * @access public\n */\nfunction bug_move( $p_bug_id, $p_target_project_id ) {\n\t// Attempt to move disk based attachments to new project file directory.\n\tfile_move_bug_attachments( $p_bug_id, $p_target_project_id );\n\n\t// Move the issue to the new project.\n\tbug_set_field( $p_bug_id, 'project_id', $p_target_project_id );\n\n\t// Update the category if needed\n\t$t_category_id = bug_get_field( $p_bug_id, 'category_id' );\n\n\t// Bug has no category\n\tif( $t_category_id == 0 ) {\n\t\t// Category is required in target project, set it to default\n\t\tif( ON != config_get( 'allow_no_category', null, null, $p_target_project_id ) ) {\n\t\t\tbug_set_field( $p_bug_id, 'category_id', config_get( 'default_category_for_moves' ) );\n\t\t}\n\t}\n\t// Check if the category is global, and if not attempt mapping it to the new project\n\telse {\n\t\t$t_category_project_id = category_get_field( $t_category_id, 'project_id' );\n\n\t\tif ( $t_category_project_id != ALL_PROJECTS\n\t\t  && !project_hierarchy_inherit_parent( $p_target_project_id, $t_category_project_id )\n\t\t) {\n\t\t\t// Map by name\n\t\t\t$t_category_name = category_get_field( $t_category_id, 'name' );\n\t\t\t$t_target_project_category_id = category_get_id_by_name( $t_category_name, $p_target_project_id, /* triggerErrors */ false );\n\t\t\tif ( $t_target_project_category_id === false ) {\n\t\t\t\t// Use default category after moves, since there is no match by name.\n\t\t\t\t$t_target_project_category_id = config_get( 'default_category_for_moves' );\n\t\t\t}\n\t\t\tbug_set_field( $p_bug_id, 'category_id', $t_target_project_category_id );\n\t\t}\n\t}\n}\n\n/**\n * allows bug deletion :\n * delete the bug, bugtext, bugnote, and bugtexts selected\n * @param array p_bug_id integer representing bug id\n * @return bool (always true)\n * @access public\n */\nfunction bug_delete( $p_bug_id ) {\n\t$c_bug_id = (int) $p_bug_id;\n\t$t_bug_table = db_get_table( 'bug' );\n\t$t_bug_text_table = db_get_table( 'bug_text' );\n\n\t# call pre-deletion custom function\n\thelper_call_custom_function( 'issue_delete_validate', array( $p_bug_id ) );\n\n\t# log deletion of bug\n\thistory_log_event_special( $p_bug_id, BUG_DELETED, bug_format_id( $p_bug_id ) );\n\n\temail_bug_deleted( $p_bug_id );\n\n\t# call post-deletion custom function.  We call this here to allow the custom function to access the details of the bug before\n\t# they are deleted from the database given it's id.  The other option would be to move this to the end of the function and\n\t# provide it with bug data rather than an id, but this will break backward compatibility.\n\thelper_call_custom_function( 'issue_delete_notify', array( $p_bug_id ) );\n\n\t# Unmonitor bug for all users\n\tbug_unmonitor( $p_bug_id, null );\n\n\t# Delete custom fields\n\tcustom_field_delete_all_values( $p_bug_id );\n\n\t# Delete bugnotes\n\tbugnote_delete_all( $p_bug_id );\n\n\t# Delete all sponsorships\n\tsponsorship_delete_all( $p_bug_id );\n\n\t# MASC RELATIONSHIP\n\t# we delete relationships even if the feature is currently off.\n\trelationship_delete_all( $p_bug_id );\n\n\t# MASC RELATIONSHIP\n\t# Delete files\n\tfile_delete_attachments( $p_bug_id );\n\n\t# Detach tags\n\ttag_bug_detach_all( $p_bug_id, false );\n\n\t# Delete the bug history\n\thistory_delete( $p_bug_id );\n\n\t# Delete bug info revisions\n\tbug_revision_delete( $p_bug_id );\n\n\t# Delete the bugnote text\n\t$t_bug_text_id = bug_get_field( $p_bug_id, 'bug_text_id' );\n\n\t$query = \"DELETE FROM $t_bug_text_table\n\t\t\t\t  WHERE id=\" . db_param();\n\tdb_query_bound( $query, Array( $t_bug_text_id ) );\n\n\t# Delete the bug entry\n\t$query = \"DELETE FROM $t_bug_table\n\t\t\t\t  WHERE id=\" . db_param();\n\tdb_query_bound( $query, Array( $c_bug_id ) );\n\n\tbug_clear_cache( $p_bug_id );\n\tbug_text_clear_cache( $p_bug_id );\n\n\t# db_query errors on failure so:\n\treturn true;\n}\n\n/**\n * Delete all bugs associated with a project\n * @param array p_project_id integer representing a projectid\n * @return bool always true\n * @access public\n * @uses database_api.php\n */\nfunction bug_delete_all( $p_project_id ) {\n\t$c_project_id = (int) $p_project_id;\n\n\t$t_bug_table = db_get_table( 'bug' );\n\n\t$query = \"SELECT id\n\t\t\t\t  FROM $t_bug_table\n\t\t\t\t  WHERE project_id=\" . db_param();\n\t$result = db_query_bound( $query, array( $c_project_id ) );\n\n\t$bug_count = db_num_rows( $result );\n\n\tfor( $i = 0;$i < $bug_count;$i++ ) {\n\t\t$row = db_fetch_array( $result );\n\n\t\tbug_delete( $row['id'] );\n\t}\n\n\t# @todo should we check the return value of each bug_delete() and\n\t#  return false if any of them return false? Presumable bug_delete()\n\t#  will eventually trigger an error on failure so it won't matter...\n\n\treturn true;\n}\n\n/**\n * Returns the extended record of the specified bug, this includes\n * the bug text fields\n * @todo include reporter name and handler name, the problem is that\n *      handler can be 0, in this case no corresponding name will be\n *      found.  Use equivalent of (+) in Oracle.\n * @param int p_bug_id integer representing bug id\n * @return array\n * @access public\n */\nfunction bug_get_extended_row( $p_bug_id ) {\n\t$t_base = bug_cache_row( $p_bug_id );\n\t$t_text = bug_text_cache_row( $p_bug_id );\n\n\t# merge $t_text first so that the 'id' key has the bug id not the bug text id\n\treturn array_merge( $t_text, $t_base );\n}\n\n/**\n * Returns the record of the specified bug\n * @param int p_bug_id integer representing bug id\n * @return array\n * @access public\n */\nfunction bug_get_row( $p_bug_id ) {\n\treturn bug_cache_row( $p_bug_id );\n}\n\n/**\n * Returns an object representing the specified bug\n * @param int p_bug_id integer representing bug id\n * @param bool p_get_extended included extended information (including bug_text)\n * @return object BugData Object\n * @access public\n */\nfunction bug_get( $p_bug_id, $p_get_extended = false ) {\n\tif( $p_get_extended ) {\n\t\t$row = bug_get_extended_row( $p_bug_id );\n\t} else {\n\t\t$row = bug_get_row( $p_bug_id );\n\t}\n\n\t$t_bug_data = new BugData;\n\t$t_bug_data->loadrow( $row );\n\treturn $t_bug_data;\n}\n\nfunction bug_row_to_object( $p_row ) {\n\t$t_bug_data = new BugData;\n\t$t_bug_data->loadrow( $p_row );\n\treturn $t_bug_data;\n}\n\n/**\n * return the specified field of the given bug\n *  if the field does not exist, display a warning and return ''\n * @param int p_bug_id integer representing bug id\n * @param string p_fieldname field name\n * @return string\n * @access public\n */\nfunction bug_get_field( $p_bug_id, $p_field_name ) {\n\t$row = bug_get_row( $p_bug_id );\n\n\tif( isset( $row[$p_field_name] ) ) {\n\t\treturn $row[$p_field_name];\n\t} else {\n\t\terror_parameters( $p_field_name );\n\t\ttrigger_error( ERROR_DB_FIELD_NOT_FOUND, WARNING );\n\t\treturn '';\n\t}\n}\n\n/**\n * return the specified text field of the given bug\n *  if the field does not exist, display a warning and return ''\n * @param int p_bug_id integer representing bug id\n * @param string p_fieldname field name\n * @return string\n * @access public\n */\nfunction bug_get_text_field( $p_bug_id, $p_field_name ) {\n\t$row = bug_text_cache_row( $p_bug_id );\n\n\tif( isset( $row[$p_field_name] ) ) {\n\t\treturn $row[$p_field_name];\n\t} else {\n\t\terror_parameters( $p_field_name );\n\t\ttrigger_error( ERROR_DB_FIELD_NOT_FOUND, WARNING );\n\t\treturn '';\n\t}\n}\n\n/**\n * return the bug summary\n *  this is a wrapper for the custom function\n * @param int p_bug_id integer representing bug id\n * @param int p_context representing SUMMARY_CAPTION, SUMMARY_FIELD\n * @return string\n * @access public\n * @uses helper_api.php\n */\nfunction bug_format_summary( $p_bug_id, $p_context ) {\n\treturn helper_call_custom_function( 'format_issue_summary', array( $p_bug_id, $p_context ) );\n}\n\n/**\n * return the timestamp for the most recent time at which a bugnote\n *  associated with the bug was modified\n * @param int p_bug_id integer representing bug id\n * @return bool|int false or timestamp in integer format representing newest bugnote timestamp\n * @access public\n * @uses database_api.php\n */\nfunction bug_get_newest_bugnote_timestamp( $p_bug_id ) {\n\t$c_bug_id = db_prepare_int( $p_bug_id );\n\t$t_bugnote_table = db_get_table( 'bugnote' );\n\n\t$query = \"SELECT last_modified\n\t\t\t\t  FROM $t_bugnote_table\n\t\t\t\t  WHERE bug_id=\" . db_param() . \"\n\t\t\t\t  ORDER BY last_modified DESC\";\n\t$result = db_query_bound( $query, Array( $c_bug_id ), 1 );\n\t$row = db_result( $result );\n\n\tif( false === $row ) {\n\t\treturn false;\n\t} else {\n\t\treturn $row;\n\t}\n}\n\n/**\n * return the timestamp for the most recent time at which a bugnote\n *  associated with the bug was modified and the total bugnote\n *  count in one db query\n * @param int p_bug_id integer representing bug id\n * @return object consisting of bugnote stats\n * @access public\n * @uses database_api.php\n */\nfunction bug_get_bugnote_stats( $p_bug_id ) {\n\tglobal $g_cache_bug;\n\t$c_bug_id = db_prepare_int( $p_bug_id );\n\n\tif( !is_null( $g_cache_bug[$c_bug_id]['_stats'] ) ) {\n\t\tif( $g_cache_bug[$c_bug_id]['_stats'] === false ) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\t$t_stats = $g_cache_bug[$c_bug_id]['_stats'];\n\t\t}\n\t\treturn $t_stats;\n\t}\n\n\t$t_bugnote_table = db_get_table( 'bugnote' );\n\n\t$query = \"SELECT last_modified\n\t\t\t\t  FROM $t_bugnote_table\n\t\t\t\t  WHERE bug_id=\" . db_param() . \"\n\t\t\t\t  ORDER BY last_modified DESC\";\n\t$result = db_query_bound( $query, Array( $c_bug_id ) );\n\t$row = db_fetch_array( $result );\n\n\tif( false === $row ) {\n\t\treturn false;\n\t}\n\n\t$t_stats['last_modified'] = $row['last_modified'];\n\t$t_stats['count'] = db_num_rows( $result );\n\n\treturn $t_stats;\n}\n\n/**\n * Get array of attachments associated with the specified bug id.  The array will be\n * sorted in terms of date added (ASC).  The array will include the following fields:\n * id, title, diskfile, filename, filesize, file_type, date_added, user_id.\n * @param int p_bug_id integer representing bug id\n * @return array array of results or null\n * @access public\n * @uses database_api.php\n * @uses file_api.php\n */\nfunction bug_get_attachments( $p_bug_id ) {\n\t$c_bug_id = db_prepare_int( $p_bug_id );\n\n\t$t_bug_file_table = db_get_table( 'bug_file' );\n\n\t$query = \"SELECT id, title, diskfile, filename, filesize, file_type, date_added, user_id\n\t\t                FROM $t_bug_file_table\n\t\t                WHERE bug_id=\" . db_param() . \"\n\t\t                ORDER BY date_added\";\n\t$db_result = db_query_bound( $query, Array( $c_bug_id ) );\n\t$num_files = db_num_rows( $db_result );\n\n\t$t_result = array();\n\n\tfor( $i = 0;$i < $num_files;$i++ ) {\n\t\t$t_result[] = db_fetch_array( $db_result );\n\t}\n\n\treturn $t_result;\n}\n\n# ===================================\n# Data Modification\n# ===================================\n/**\n * Set the value of a bug field\n * @param int p_bug_id integer representing bug id\n * @param string p_field_name pre-defined field name\n * @param any p_value value to set\n * @return bool (always true)\n * @access public\n * @uses database_api.php\n * @uses history_api.php\n */\nfunction bug_set_field( $p_bug_id, $p_field_name, $p_value ) {\n\t$c_bug_id = db_prepare_int( $p_bug_id );\n\t$c_value = null;\n\n\tswitch( $p_field_name ) {\n\n\t\t# bool\n\t\tcase 'sticky':\n\t\t\t$c_value = $p_value;\n\t\t\tbreak;\n\n\t\t# int\n\t\tcase 'project_id':\n\t\tcase 'reporter_id':\n\t\tcase 'handler_id':\n\t\tcase 'duplicate_id':\n\t\tcase 'priority':\n\t\tcase 'severity':\n\t\tcase 'reproducibility':\n\t\tcase 'status':\n\t\tcase 'resolution':\n\t\tcase 'projection':\n\t\tcase 'category_id':\n\t\tcase 'eta':\n\t\tcase 'view_state':\n\t\tcase 'profile_id':\n\t\tcase 'sponsorship_total':\n\t\t\t$c_value = (int) $p_value;\n\t\t\tbreak;\n\n\t\t# string\n\t\tcase 'os':\n\t\tcase 'os_build':\n\t\tcase 'platform':\n\t\tcase 'version':\n\t\tcase 'fixed_in_version':\n\t\tcase 'target_version':\n\t\tcase 'build':\n\t\tcase 'summary':\n\t\t\t$c_value = $p_value;\n\t\t\tbreak;\n\n\t\t# dates\n\t\tcase 'last_updated':\n\t\tcase 'date_submitted':\n\t\tcase 'due_date':\n\t\t\tif ( !is_numeric( $p_value ) ) {\n\t\t\t\ttrigger_error( ERROR_GENERIC, ERROR );\n\t\t\t}\n\t\t\t$c_value = $p_value;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\ttrigger_error( ERROR_DB_FIELD_NOT_FOUND, WARNING );\n\t\t\tbreak;\n\t}\n\n\t$t_current_value = bug_get_field( $p_bug_id, $p_field_name );\n\n\t# return if status is already set\n\tif( $c_value == $t_current_value ) {\n\t\treturn true;\n\t}\n\t$t_bug_table = db_get_table( 'bug' );\n\n\t# Update fields\n\t$query = \"UPDATE $t_bug_table\n\t\t\t\t  SET $p_field_name=\" . db_param() . \"\n\t\t\t\t  WHERE id=\" . db_param();\n\tdb_query_bound( $query, Array( $c_value, $c_bug_id ) );\n\n\t# updated the last_updated date\n\tbug_update_date( $p_bug_id );\n\n\t# log changes except for duplicate_id which is obsolete and should be removed in\n\t# MantisBT 1.3.\n\tswitch( $p_field_name ) {\n\t\tcase 'duplicate_id':\n\t\t\tbreak;\n\n\t\tcase 'category_id':\n\t\t\thistory_log_event_direct( $p_bug_id, 'category', category_full_name( $t_current_value, false ), category_full_name( $c_value, false ) );\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\thistory_log_event_direct( $p_bug_id, $p_field_name, $t_current_value, $c_value );\n\t}\n\n\tbug_clear_cache( $p_bug_id );\n\n\treturn true;\n}\n\n/**\n * assign the bug to the given user\n * @param array p_bug_id_array integer array representing bug ids to cache\n * @return null\n * @access public\n * @uses database_api.php\n */\nfunction bug_assign( $p_bug_id, $p_user_id, $p_bugnote_text = '', $p_bugnote_private = false ) {\n\t$c_bug_id = db_prepare_int( $p_bug_id );\n\t$c_user_id = db_prepare_int( $p_user_id );\n\n\tif(( $c_user_id != NO_USER ) && !access_has_bug_level( config_get( 'handle_bug_threshold' ), $p_bug_id, $p_user_id ) ) {\n\t\ttrigger_error( ERROR_USER_DOES_NOT_HAVE_REQ_ACCESS );\n\t}\n\n\t# extract current information into history variables\n\t$h_status = bug_get_field( $p_bug_id, 'status' );\n\t$h_handler_id = bug_get_field( $p_bug_id, 'handler_id' );\n\n\tif(( ON == config_get( 'auto_set_status_to_assigned' ) ) && ( NO_USER != $p_user_id ) ) {\n\t\t$t_ass_val = config_get( 'bug_assigned_status' );\n\t} else {\n\t\t$t_ass_val = $h_status;\n\t}\n\n\t$t_bug_table = db_get_table( 'bug' );\n\n\tif(( $t_ass_val != $h_status ) || ( $p_user_id != $h_handler_id ) ) {\n\n\t\t# get user id\n\t\t$query = \"UPDATE $t_bug_table\n\t\t\t\t\t  SET handler_id=\" . db_param() . \", status=\" . db_param() . \"\n\t\t\t\t\t  WHERE id=\" . db_param();\n\t\tdb_query_bound( $query, Array( $c_user_id, $t_ass_val, $c_bug_id ) );\n\n\t\t# log changes\n\t\thistory_log_event_direct( $c_bug_id, 'status', $h_status, $t_ass_val );\n\t\thistory_log_event_direct( $c_bug_id, 'handler_id', $h_handler_id, $p_user_id );\n\n\t\t# Add bugnote if supplied ignore false return\n\t\tbugnote_add( $p_bug_id, $p_bugnote_text, 0, $p_bugnote_private, 0, '', NULL, FALSE );\n\n\t\t# updated the last_updated date\n\t\tbug_update_date( $p_bug_id );\n\n\t\tbug_clear_cache( $p_bug_id );\n\n\t\t# send assigned to email\n\t\temail_assign( $p_bug_id );\n\t}\n\n\treturn true;\n}\n\n/**\n * close the given bug\n * @param int p_bug_id\n * @param string p_bugnote_text\n * @param bool p_bugnote_private\n * @param string p_time_tracking\n * @return bool (always true)\n * @access public\n */\nfunction bug_close( $p_bug_id, $p_bugnote_text = '', $p_bugnote_private = false, $p_time_tracking = '0:00' ) {\n\t$p_bugnote_text = trim( $p_bugnote_text );\n\n\t# Add bugnote if supplied ignore a false return\n\t# Moved bugnote_add before bug_set_field calls in case time_tracking_no_note is off.\n\t# Error condition stopped execution but status had already been changed\n\tbugnote_add( $p_bug_id, $p_bugnote_text, $p_time_tracking, $p_bugnote_private, 0, '', NULL, FALSE );\n\n\tbug_set_field( $p_bug_id, 'status', config_get( 'bug_closed_status_threshold' ) );\n\n\temail_close( $p_bug_id );\n\temail_relationship_child_closed( $p_bug_id );\n\n\treturn true;\n}\n\n/**\n * resolve the given bug\n * @return bool (alawys true)\n * @access public\n */\nfunction bug_resolve( $p_bug_id, $p_resolution, $p_fixed_in_version = '', $p_bugnote_text = '', $p_duplicate_id = null, $p_handler_id = null, $p_bugnote_private = false, $p_time_tracking = '0:00' ) {\n\t$c_resolution = (int) $p_resolution;\n\t$p_bugnote_text = trim( $p_bugnote_text );\n\n\t# Add bugnote if supplied\n\t# Moved bugnote_add before bug_set_field calls in case time_tracking_no_note is off.\n\t# Error condition stopped execution but status had already been changed\n\tbugnote_add( $p_bug_id, $p_bugnote_text, $p_time_tracking, $p_bugnote_private, 0, '', NULL, FALSE );\n\n\t$t_duplicate = !is_blank( $p_duplicate_id ) && ( $p_duplicate_id != 0 );\n\tif( $t_duplicate ) {\n\t\tif( $p_bug_id == $p_duplicate_id ) {\n\t\t\ttrigger_error( ERROR_BUG_DUPLICATE_SELF, ERROR );\n\n\t\t\t# never returns\n\t\t}\n\n\t\t# the related bug exists...\n\t\tbug_ensure_exists( $p_duplicate_id );\n\n\t\t# check if there is other relationship between the bugs...\n\t\t$t_id_relationship = relationship_same_type_exists( $p_bug_id, $p_duplicate_id, BUG_DUPLICATE );\n\n\t\t if( $t_id_relationship > 0 ) {\n\t\t\t# Update the relationship\n\t\t\trelationship_update( $t_id_relationship, $p_bug_id, $p_duplicate_id, BUG_DUPLICATE );\n\n\t\t\t# Add log line to the history (both bugs)\n\t\t\thistory_log_event_special( $p_bug_id, BUG_REPLACE_RELATIONSHIP, BUG_DUPLICATE, $p_duplicate_id );\n\t\t\thistory_log_event_special( $p_duplicate_id, BUG_REPLACE_RELATIONSHIP, BUG_HAS_DUPLICATE, $p_bug_id );\n\t\t} else if ( $t_id_relationship != -1 ) {\n\t\t\t# Add the new relationship\n\t\t\trelationship_add( $p_bug_id, $p_duplicate_id, BUG_DUPLICATE );\n\n\t\t\t# Add log line to the history (both bugs)\n\t\t\thistory_log_event_special( $p_bug_id, BUG_ADD_RELATIONSHIP, BUG_DUPLICATE, $p_duplicate_id );\n\t\t\thistory_log_event_special( $p_duplicate_id, BUG_ADD_RELATIONSHIP, BUG_HAS_DUPLICATE, $p_bug_id );\n\t\t} # else relationship is -1 - same type exists, do nothing\n\n\t\t# Copy list of users monitoring the duplicate bug to the original bug\n\t\t$t_old_reporter_id = bug_get_field( $p_bug_id, 'reporter_id' );\n\t\t$t_old_handler_id = bug_get_field( $p_bug_id, 'handler_id' );\n\t\tif ( user_exists( $t_old_reporter_id ) ) {\n\t\t\tbug_monitor( $p_duplicate_id, $t_old_reporter_id );\n\t\t}\n\t\tif ( user_exists ( $t_old_handler_id ) ) {\n\t\t\tbug_monitor( $p_duplicate_id, $t_old_handler_id );\n\t\t}\n\t\tbug_monitor_copy( $p_bug_id, $p_duplicate_id );\n\n\t\tbug_set_field( $p_bug_id, 'duplicate_id', (int) $p_duplicate_id );\n\t}\n\n\tbug_set_field( $p_bug_id, 'status', config_get( 'bug_resolved_status_threshold' ) );\n\tbug_set_field( $p_bug_id, 'fixed_in_version', $p_fixed_in_version );\n\tbug_set_field( $p_bug_id, 'resolution', $c_resolution );\n\n\t# only set handler if specified explicitly or if bug was not assigned to a handler\n\tif( null == $p_handler_id ) {\n\t\tif( bug_get_field( $p_bug_id, 'handler_id' ) == 0 ) {\n\t\t\t$p_handler_id = auth_get_current_user_id();\n\t\t\tbug_set_field( $p_bug_id, 'handler_id', $p_handler_id );\n\t\t}\n\t} else {\n\t\tbug_set_field( $p_bug_id, 'handler_id', $p_handler_id );\n\t}\n\n\temail_resolved( $p_bug_id );\n\temail_relationship_child_resolved( $p_bug_id );\n\n\tif( $c_resolution >= config_get( 'bug_resolution_fixed_threshold' ) &&\n\t\t$c_resolution < config_get( 'bug_resolution_not_fixed_threshold' ) ) {\n\t\ttwitter_issue_resolved( $p_bug_id );\n\t}\n\n\treturn true;\n}\n\n/**\n * reopen the given bug\n * @param int p_bug_id\n * @param string p_bugnote_text\n * @param string p_time_tracking\n * @param bool p_bugnote_private\n * @return bool (always true)\n * @access public\n * @uses database_api.php\n * @uses email_api.php\n * @uses bugnote_api.php\n * @uses config_api.php\n */\nfunction bug_reopen( $p_bug_id, $p_bugnote_text = '', $p_time_tracking = '0:00', $p_bugnote_private = false ) {\n\t$p_bugnote_text = trim( $p_bugnote_text );\n\n\t# Add bugnote if supplied\n\t# Moved bugnote_add before bug_set_field calls in case time_tracking_no_note is off.\n\t# Error condition stopped execution but status had already been changed\n\tbugnote_add( $p_bug_id, $p_bugnote_text, $p_time_tracking, $p_bugnote_private, 0, '', NULL, FALSE );\n\n\tbug_set_field( $p_bug_id, 'status', config_get( 'bug_reopen_status' ) );\n\tbug_set_field( $p_bug_id, 'resolution', config_get( 'bug_reopen_resolution' ) );\n\n\temail_reopen( $p_bug_id );\n\n\treturn true;\n}\n\n/**\n * updates the last_updated field\n * @param int p_bug_id integer representing bug ids\n * @return bool (always true)\n * @access public\n * @uses database_api.php\n */\nfunction bug_update_date( $p_bug_id ) {\n\t$c_bug_id = (int) $p_bug_id;\n\n\t$t_bug_table = db_get_table( 'bug' );\n\n\t$query = \"UPDATE $t_bug_table\n\t\t\t\t  SET last_updated= \" . db_param() . \"\n\t\t\t\t  WHERE id=\" . db_param();\n\tdb_query_bound( $query, Array( db_now(), $c_bug_id ) );\n\n\tbug_clear_cache( $c_bug_id );\n\n\treturn true;\n}\n\n/**\n * enable monitoring of this bug for the user\n * @param int p_bug_id integer representing bug ids\n * @param int p_user_id integer representing user ids\n * @return true if successful, false if unsuccessful\n * @access public\n * @uses database_api.php\n * @uses history_api.php\n * @uses user_api.php\n */\nfunction bug_monitor( $p_bug_id, $p_user_id ) {\n\t$c_bug_id = (int) $p_bug_id;\n\t$c_user_id = (int) $p_user_id;\n\n\t# Make sure we aren't already monitoring this bug\n\tif( user_is_monitoring_bug( $c_user_id, $c_bug_id ) ) {\n\t\treturn true;\n\t}\n\n\t# Don't let the anonymous user monitor bugs\n\tif ( user_is_anonymous( $c_user_id ) ) {\n\t\treturn false;\n\t}\n\n\t$t_bug_monitor_table = db_get_table( 'bug_monitor' );\n\n\t# Insert monitoring record\n\t$query = 'INSERT INTO ' . $t_bug_monitor_table . '( user_id, bug_id ) VALUES (' . db_param() . ',' . db_param() . ')';\n\tdb_query_bound( $query, Array( $c_user_id, $c_bug_id ) );\n\n\t# log new monitoring action\n\thistory_log_event_special( $c_bug_id, BUG_MONITOR, $c_user_id );\n\n\t# updated the last_updated date\n\tbug_update_date( $p_bug_id );\n\n\temail_monitor_added( $p_bug_id, $p_user_id );\n\n\treturn true;\n}\n\n/**\n * Returns the list of users monitoring the specified bug\n *\n * @param int $p_bug_id\n */\nfunction bug_get_monitors( $p_bug_id ) {\n\n\tif ( ! access_has_bug_level( config_get( 'show_monitor_list_threshold' ), $p_bug_id ) ) {\n\t\treturn Array();\n\t}\n\n\t$c_bug_id = db_prepare_int( $p_bug_id );\n\t$t_bug_monitor_table = db_get_table( 'bug_monitor' );\n\t$t_user_table = db_get_table( 'user' );\n\n\t# get the bugnote data\n\t$query = \"SELECT user_id, enabled\n\t\t\tFROM $t_bug_monitor_table m, $t_user_table u\n\t\t\tWHERE m.bug_id=\" . db_param() . \" AND m.user_id = u.id\n\t\t\tORDER BY u.realname, u.username\";\n\t$result = db_query_bound($query, Array( $c_bug_id ) );\n\t$num_users = db_num_rows($result);\n\n\t$t_users = array();\n\tfor ( $i = 0; $i < $num_users; $i++ ) {\n\t\t$row = db_fetch_array( $result );\n\t\t$t_users[$i] = $row['user_id'];\n\t}\n\n\tuser_cache_array_rows( $t_users );\n\n\treturn $t_users;\n}\n\n/**\n * Copy list of users monitoring a bug to the monitor list of a second bug\n * @param int p_source_bug_id integer representing the bug ID of the source bug\n * @param int p_dest_bug_id integer representing the bug ID of the destination bug\n * @return bool (always true)\n * @access public\n * @uses database_api.php\n * @uses history_api.php\n * @uses user_api.php\n */\nfunction bug_monitor_copy( $p_source_bug_id, $p_dest_bug_id ) {\n\t$c_source_bug_id = (int)$p_source_bug_id;\n\t$c_dest_bug_id = (int)$p_dest_bug_id;\n\n\t$t_bug_monitor_table = db_get_table( 'bug_monitor' );\n\n\t$query = 'SELECT user_id\n\t\tFROM ' . $t_bug_monitor_table . '\n\t\tWHERE bug_id = ' . db_param();\n\t$result = db_query_bound( $query, Array( $c_source_bug_id ) );\n\t$t_count = db_num_rows( $result );\n\n\tfor( $i = 0; $i < $t_count; $i++ ) {\n\t\t$t_bug_monitor = db_fetch_array( $result );\n\t\tif ( user_exists( $t_bug_monitor['user_id'] ) &&\n\t\t\t!user_is_monitoring_bug( $t_bug_monitor['user_id'], $c_dest_bug_id ) ) {\n\t\t\t$query = 'INSERT INTO ' . $t_bug_monitor_table . ' ( user_id, bug_id )\n\t\t\t\tVALUES ( ' . db_param() . ', ' . db_param() . ' )';\n\t\t\tdb_query_bound( $query, Array( $t_bug_monitor['user_id'], $c_dest_bug_id ) );\n\t\t\thistory_log_event_special( $c_dest_bug_id, BUG_MONITOR, $t_bug_monitor['user_id'] );\n\t\t}\n\t}\n}\n\n/**\n * disable monitoring of this bug for the user\n * if $p_user_id = null, then bug is unmonitored for all users.\n * @param int p_bug_id integer representing bug ids\n * @param int p_user_id integer representing user ids\n * @return bool (always true)\n * @access public\n * @uses database_api.php\n * @uses history_api.php\n */\nfunction bug_unmonitor( $p_bug_id, $p_user_id ) {\n\t$c_bug_id = (int) $p_bug_id;\n\t$c_user_id = (int) $p_user_id;\n\n\t$t_bug_monitor_table = db_get_table( 'bug_monitor' );\n\n\t# Delete monitoring record\n\t$query = 'DELETE FROM ' . $t_bug_monitor_table . ' WHERE bug_id = ' . db_param();\n\t$db_query_params[] = $c_bug_id;\n\n\tif( $p_user_id !== null ) {\n\t\t$query .= \" AND user_id = \" . db_param();\n\t\t$db_query_params[] = $c_user_id;\n\t}\n\n\tdb_query_bound( $query, $db_query_params );\n\n\t# log new un-monitor action\n\thistory_log_event_special( $c_bug_id, BUG_UNMONITOR, $c_user_id );\n\n\t# updated the last_updated date\n\tbug_update_date( $p_bug_id );\n\n\treturn true;\n}\n\n/**\n * Pads the bug id with the appropriate number of zeros.\n * @param int p_bug_id\n * @return string\n * @access public\n * @uses config_api.php\n */\nfunction bug_format_id( $p_bug_id ) {\n\t$t_padding = config_get( 'display_bug_padding' );\n\t$t_string = utf8_str_pad( $p_bug_id, $t_padding, '0', STR_PAD_LEFT );\n\n\treturn event_signal( 'EVENT_DISPLAY_BUG_ID', $t_string, array( $p_bug_id ) );\n}\n", "<?php\n# MantisBT - A PHP based bugtracking system\n\n# MantisBT is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 2 of the License, or\n# (at your option) any later version.\n#\n# MantisBT is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with MantisBT.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * History API\n *\n * @package CoreAPI\n * @subpackage HistoryAPI\n * @copyright Copyright (C) 2000 - 2002  Kenzaburo Ito - kenito@300baud.org\n * @copyright Copyright (C) 2002 - 2012  MantisBT Team - mantisbt-dev@lists.sourceforge.net\n * @link http://www.mantisbt.org\n *\n * @uses access_api.php\n * @uses authentication_api.php\n * @uses bug_api.php\n * @uses bug_revision_api.php\n * @uses bugnote_api.php\n * @uses columns_api.php\n * @uses config_api.php\n * @uses constant_inc.php\n * @uses custom_field_api.php\n * @uses database_api.php\n * @uses gpc_api.php\n * @uses helper_api.php\n * @uses lang_api.php\n * @uses project_api.php\n * @uses relationship_api.php\n * @uses sponsorship_api.php\n * @uses user_api.php\n * @uses utility_api.php\n */\n\nrequire_api( 'access_api.php' );\nrequire_api( 'authentication_api.php' );\nrequire_api( 'bug_api.php' );\nrequire_api( 'bug_revision_api.php' );\nrequire_api( 'bugnote_api.php' );\nrequire_api( 'columns_api.php' );\nrequire_api( 'config_api.php' );\nrequire_api( 'constant_inc.php' );\nrequire_api( 'custom_field_api.php' );\nrequire_api( 'database_api.php' );\nrequire_api( 'gpc_api.php' );\nrequire_api( 'helper_api.php' );\nrequire_api( 'lang_api.php' );\nrequire_api( 'project_api.php' );\nrequire_api( 'relationship_api.php' );\nrequire_api( 'sponsorship_api.php' );\nrequire_api( 'user_api.php' );\nrequire_api( 'utility_api.php' );\n\n/**\n * log the changes (old / new value are supplied to reduce db access)\n * events should be logged *after* the modification\n * @param int $p_bug_id\n * @param string $p_field_name\n * @param string $p_old_value\n * @param string $p_new_value\n * @param int $p_user_id\n * @param int $p_type\n */\nfunction history_log_event_direct( $p_bug_id, $p_field_name, $p_old_value, $p_new_value, $p_user_id = null, $p_type = 0 ) {\n\t# Only log events that change the value\n\tif( $p_new_value != $p_old_value ) {\n\t\tif( null === $p_user_id ) {\n\t\t\t$p_user_id = auth_get_current_user_id();\n\t\t}\n\n\t\t$c_field_name = $p_field_name;\n\t\t$c_old_value = ( is_null( $p_old_value ) ? '' : $p_old_value );\n\t\t$c_new_value = ( is_null( $p_new_value ) ? '' : $p_new_value );\n\t\t$c_bug_id = db_prepare_int( $p_bug_id );\n\t\t$c_user_id = db_prepare_int( $p_user_id );\n\t\t$c_type = db_prepare_int( $p_type );\n\n\t\t$t_mantis_bug_history_table = db_get_table( 'bug_history' );\n\n\t\t$query = \"INSERT INTO $t_mantis_bug_history_table\n\t\t\t\t\t\t( user_id, bug_id, date_modified, field_name, old_value, new_value, type )\n\t\t\t\t\tVALUES\n\t\t\t\t\t\t( \" . db_param() . ', ' . db_param() . ', ' . db_param() . ', ' . db_param() . ', ' . db_param() . ', ' . db_param() . ', ' . db_param() . ' )';\n\t\t$result = db_query_bound( $query, Array( $c_user_id, $c_bug_id, db_now(), $c_field_name, $c_old_value, $c_new_value, $c_type ) );\n\t}\n}\n\n/**\n * log the changes\n * events should be logged *after* the modification\n * @param int $p_bug_id\n * @param string $p_field_name\n * @param string $p_old_value\n * @return null\n */\nfunction history_log_event( $p_bug_id, $p_field_name, $p_old_value ) {\n\thistory_log_event_direct( $p_bug_id, $p_field_name, $p_old_value, bug_get_field( $p_bug_id, $p_field_name ) );\n}\n\n/**\n * log the changes\n * events should be logged *after* the modification\n * These are special case logs (new bug, deleted bugnote, etc.)\n * @param int $p_bug_id\n * @param int $p_type\n * @param string $p_optional\n * @param string $p_optional2\n * @return null\n */\nfunction history_log_event_special( $p_bug_id, $p_type, $p_optional = '', $p_optional2 = '' ) {\n\t$c_bug_id = db_prepare_int( $p_bug_id );\n\t$c_type = db_prepare_int( $p_type );\n\t$c_optional = ( $p_optional );\n\t$c_optional2 = ( $p_optional2 );\n\t$t_user_id = auth_get_current_user_id();\n\n\t$t_mantis_bug_history_table = db_get_table( 'bug_history' );\n\n\t$query = \"INSERT INTO $t_mantis_bug_history_table\n\t\t\t\t\t( user_id, bug_id, date_modified, type, old_value, new_value, field_name )\n\t\t\t\tVALUES\n\t\t\t\t\t( \" . db_param() . ', ' . db_param() . ', ' . db_param() . ', ' . db_param() . ', ' . db_param() . ',' . db_param() . ', ' . db_param() . ')';\n\t$result = db_query_bound( $query, Array( $t_user_id, $c_bug_id, db_now(), $c_type, $c_optional, $c_optional2, '' ) );\n}\n\n/**\n * Retrieves the history events for the specified bug id and returns it in an array\n * The array is indexed from 0 to N-1.  The second dimension is: 'date', 'username',\n * 'note', 'change'.\n * @param int $p_bug_id\n * @param int $p_user_id\n * @return array\n */\nfunction history_get_events_array( $p_bug_id, $p_user_id = null ) {\n\t$t_normal_date_format = config_get( 'normal_date_format' );\n\n\t$raw_history = history_get_raw_events_array( $p_bug_id, $p_user_id );\n\t$raw_history_count = count( $raw_history );\n\t$history = array();\n\n\tfor( $i = 0;$i < $raw_history_count;$i++ ) {\n\t\t$history[$i] = history_localize_item( $raw_history[$i]['field'], $raw_history[$i]['type'], $raw_history[$i]['old_value'], $raw_history[$i]['new_value'] );\n\t\t$history[$i]['date'] = date( $t_normal_date_format, $raw_history[$i]['date'] );\n\t\t$history[$i]['userid'] = $raw_history[$i]['userid'];\n\t\t$history[$i]['username'] = $raw_history[$i]['username'];\n\t}\n\n\treturn( $history );\n}\n\n/**\n * Retrieves the raw history events for the specified bug id and returns it in an array\n * The array is indexed from 0 to N-1.  The second dimension is: 'date', 'userid', 'username',\n * 'field','type','old_value','new_value'\n * @param int $p_bug_id\n * @param int $p_user_id\n * @return array\n */\nfunction history_get_raw_events_array( $p_bug_id, $p_user_id = null ) {\n\t$t_mantis_bug_history_table = db_get_table( 'bug_history' );\n\t$t_mantis_user_table = db_get_table( 'user' );\n\t$t_history_order = config_get( 'history_order' );\n\t$c_bug_id = db_prepare_int( $p_bug_id );\n\n\t$t_user_id = (( null === $p_user_id ) ? auth_get_current_user_id() : $p_user_id );\n\n\t$t_roadmap_view_access_level = config_get( 'roadmap_view_threshold' );\n\t$t_due_date_view_threshold = config_get( 'due_date_view_threshold' );\n\n\t# grab history and display by date_modified then field_name\n\t# @@@ by MASC I guess it's better by id then by field_name. When we have more history lines with the same\n\t# date, it's better to respect the storing order otherwise we should risk to mix different information\n\t# I give you an example. We create a child of a bug with different custom fields. In the history of the child\n\t# bug we will find the line related to the relationship mixed with the custom fields (the history is creted\n\t# for the new bug with the same timestamp...)\n\t$query = \"SELECT *\n\t\t\t\tFROM $t_mantis_bug_history_table\n\t\t\t\tWHERE bug_id=\" . db_param() . \"\n\t\t\t\tORDER BY date_modified $t_history_order,id\";\n\t$result = db_query_bound( $query, Array( $c_bug_id ) );\n\t$raw_history_count = db_num_rows( $result );\n\t$raw_history = array();\n\n\t$t_private_bugnote_threshold = config_get( 'private_bugnote_threshold' );\n\t$t_private_bugnote_visible = access_has_bug_level( config_get( 'private_bugnote_threshold' ), $p_bug_id, $t_user_id );\n\t$t_tag_view_threshold = config_get( 'tag_view_threshold' );\n\t$t_show_monitor_list_threshold = config_get( 'show_monitor_list_threshold' );\n\t$t_show_handler_threshold = config_get( 'view_handler_threshold' );\n\n\t$t_standard_fields = columns_get_standard();\n\n\tfor( $i = 0, $j = 0;$i < $raw_history_count;++$i ) {\n\t\t$t_row = db_fetch_array( $result );\n\n\t\t$v_type = $t_row['type'];\n\t\t$v_field_name = $t_row['field_name'];\n\t\t$v_user_id = $t_row['user_id'];\n\t\t$v_new_value = $t_row['new_value'];\n\t\t$v_old_value = $t_row['old_value'];\n\t\t$v_date_modified = $t_row['date_modified'];\n\n\t\tif ( $v_type == NORMAL_TYPE ) {\n\t\t\tif ( !in_array( $v_field_name, $t_standard_fields ) ) {\n\n\t\t\t\t// check that the item should be visible to the user\n\t\t\t\t// custom fields - we are passing 32 here to notify the API that the custom field name is truncated by the history column from 64 to 32 characters.\n\t\t\t\t$t_field_id = custom_field_get_id_from_name( $v_field_name, 32 );\n\t\t\t\tif( false !== $t_field_id && !custom_field_has_read_access( $t_field_id, $p_bug_id, $t_user_id ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( ( $v_field_name == 'target_version' ) && !access_has_bug_level( $t_roadmap_view_access_level, $p_bug_id, $t_user_id ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ( ( $v_field_name == 'due_date' ) && !access_has_bug_level( $t_due_date_view_threshold, $p_bug_id, $t_user_id ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ( ( $v_field_name == 'handler_id' ) && !access_has_bug_level( $t_show_handler_threshold, $p_bug_id, $t_user_id ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t// bugnotes\n\t\tif( $t_user_id != $v_user_id ) {\n\t\t\t// bypass if user originated note\n\t\t\tif(( $v_type == BUGNOTE_ADDED ) || ( $v_type == BUGNOTE_UPDATED ) || ( $v_type == BUGNOTE_DELETED ) ) {\n\t\t\t\tif( !$t_private_bugnote_visible && ( bugnote_get_field( $v_old_value, 'view_state' ) == VS_PRIVATE ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif( $v_type == BUGNOTE_STATE_CHANGED ) {\n\t\t\t\tif( !$t_private_bugnote_visible && ( bugnote_get_field( $v_new_value, 'view_state' ) == VS_PRIVATE ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// tags\n\t\tif( $v_type == TAG_ATTACHED || $v_type == TAG_DETACHED || $v_type == TAG_RENAMED ) {\n\t\t\tif( !access_has_bug_level( $t_tag_view_threshold, $p_bug_id, $t_user_id ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t// monitoring\n\t\tif( $v_type == BUG_MONITOR || $v_type == BUG_UNMONITOR ) {\n\t\t\tif( !access_has_bug_level( $t_show_monitor_list_threshold, $p_bug_id, $t_user_id ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t$raw_history[$j]['date'] = $v_date_modified;\n\t\t$raw_history[$j]['userid'] = $v_user_id;\n\n\t\t# user_get_name handles deleted users, and username vs realname\n\t\t$raw_history[$j]['username'] = user_get_name( $v_user_id );\n\n\t\t$raw_history[$j]['field'] = $v_field_name;\n\t\t$raw_history[$j]['type'] = $v_type;\n\t\t$raw_history[$j]['old_value'] = $v_old_value;\n\t\t$raw_history[$j]['new_value'] = $v_new_value;\n\n\t\t$j++;\n\t}\n\n\t# end for loop\n\n\treturn $raw_history;\n}\n\n/**\n * Localizes one raw history item specified by set the next parameters: $p_field_name, $p_type, $p_old_value, $p_new_value\n * Returns array with two elements indexed as 'note' and 'change'\n * @param string $p_field_name\n * @param int $p_type\n * @param string $p_old_value\n * @param string $p_new_value\n * @param bool $p_linkify\n * @return array\n */\nfunction history_localize_item( $p_field_name, $p_type, $p_old_value, $p_new_value, $p_linkify=true ) {\n\t$t_note = '';\n\t$t_change = '';\n\t$t_field_localized = $p_field_name;\n\t$t_raw = true;\n\n\tif( PLUGIN_HISTORY == $p_type ) {\n\t\t$t_note = lang_get_defaulted( \"plugin_$p_field_name\", $p_field_name );\n\t\t$t_change = ( isset( $p_new_value ) ? \"$p_old_value => $p_new_value\" : $p_old_value );\n\n\t\treturn array( 'note' => $t_note, 'change' => $t_change, 'raw' => true );\n\t}\n\n\tswitch( $p_field_name ) {\n\t\tcase 'category':\n\t\t\t$t_field_localized = lang_get( 'category' );\n\t\t\tbreak;\n\t\tcase 'status':\n\t\t\t$p_old_value = get_enum_element( 'status', $p_old_value );\n\t\t\t$p_new_value = get_enum_element( 'status', $p_new_value );\n\t\t\t$t_field_localized = lang_get( 'status' );\n\t\t\tbreak;\n\t\tcase 'severity':\n\t\t\t$p_old_value = get_enum_element( 'severity', $p_old_value );\n\t\t\t$p_new_value = get_enum_element( 'severity', $p_new_value );\n\t\t\t$t_field_localized = lang_get( 'severity' );\n\t\t\tbreak;\n\t\tcase 'reproducibility':\n\t\t\t$p_old_value = get_enum_element( 'reproducibility', $p_old_value );\n\t\t\t$p_new_value = get_enum_element( 'reproducibility', $p_new_value );\n\t\t\t$t_field_localized = lang_get( 'reproducibility' );\n\t\t\tbreak;\n\t\tcase 'resolution':\n\t\t\t$p_old_value = get_enum_element( 'resolution', $p_old_value );\n\t\t\t$p_new_value = get_enum_element( 'resolution', $p_new_value );\n\t\t\t$t_field_localized = lang_get( 'resolution' );\n\t\t\tbreak;\n\t\tcase 'priority':\n\t\t\t$p_old_value = get_enum_element( 'priority', $p_old_value );\n\t\t\t$p_new_value = get_enum_element( 'priority', $p_new_value );\n\t\t\t$t_field_localized = lang_get( 'priority' );\n\t\t\tbreak;\n\t\tcase 'eta':\n\t\t\t$p_old_value = get_enum_element( 'eta', $p_old_value );\n\t\t\t$p_new_value = get_enum_element( 'eta', $p_new_value );\n\t\t\t$t_field_localized = lang_get( 'eta' );\n\t\t\tbreak;\n\t\tcase 'view_state':\n\t\t\t$p_old_value = get_enum_element( 'view_state', $p_old_value );\n\t\t\t$p_new_value = get_enum_element( 'view_state', $p_new_value );\n\t\t\t$t_field_localized = lang_get( 'view_status' );\n\t\t\tbreak;\n\t\tcase 'projection':\n\t\t\t$p_old_value = get_enum_element( 'projection', $p_old_value );\n\t\t\t$p_new_value = get_enum_element( 'projection', $p_new_value );\n\t\t\t$t_field_localized = lang_get( 'projection' );\n\t\t\tbreak;\n\t\tcase 'sticky':\n\t\t\t$p_old_value = gpc_string_to_bool( $p_old_value ) ? lang_get( 'yes' ) : lang_get( 'no' );\n\t\t\t$p_new_value = gpc_string_to_bool( $p_new_value ) ? lang_get( 'yes' ) : lang_get( 'no' );\n\t\t\t$t_field_localized = lang_get( 'sticky_issue' );\n\t\t\tbreak;\n\t\tcase 'project_id':\n\t\t\tif( project_exists( $p_old_value ) ) {\n\t\t\t\t$p_old_value = project_get_field( $p_old_value, 'name' );\n\t\t\t} else {\n\t\t\t\t$p_old_value = '@' . $p_old_value . '@';\n\t\t\t}\n\n\t\t\t# Note that the new value maybe an intermediately project and not the\n\t\t\t# current one.\n\t\t\tif( project_exists( $p_new_value ) ) {\n\t\t\t\t$p_new_value = project_get_field( $p_new_value, 'name' );\n\t\t\t} else {\n\t\t\t\t$p_new_value = '@' . $p_new_value . '@';\n\t\t\t}\n\t\t\t$t_field_localized = lang_get( 'email_project' );\n\t\t\tbreak;\n\t\tcase 'handler_id':\n\t\t\t$t_field_localized = lang_get( 'assigned_to' );\n\t\tcase 'reporter_id':\n\t\t\tif( 'reporter_id' == $p_field_name ) {\n\t\t\t\t$t_field_localized = lang_get( 'reporter' );\n\t\t\t}\n\t\t\tif( 0 == $p_old_value ) {\n\t\t\t\t$p_old_value = '';\n\t\t\t} else {\n\t\t\t\t$p_old_value = user_get_name( $p_old_value );\n\t\t\t}\n\n\t\t\tif( 0 == $p_new_value ) {\n\t\t\t\t$p_new_value = '';\n\t\t\t} else {\n\t\t\t\t$p_new_value = user_get_name( $p_new_value );\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'version':\n\t\t\t$t_field_localized = lang_get( 'product_version' );\n\t\t\tbreak;\n\t\tcase 'fixed_in_version':\n\t\t\t$t_field_localized = lang_get( 'fixed_in_version' );\n\t\t\tbreak;\n\t\tcase 'target_version':\n\t\t\t$t_field_localized = lang_get( 'target_version' );\n\t\t\tbreak;\n\t\tcase 'date_submitted':\n\t\t\t$t_field_localized = lang_get( 'date_submitted' );\n\t\t\tbreak;\n\t\tcase 'last_updated':\n\t\t\t$t_field_localized = lang_get( 'last_update' );\n\t\t\tbreak;\n\t\tcase 'os':\n\t\t\t$t_field_localized = lang_get( 'os' );\n\t\t\tbreak;\n\t\tcase 'os_build':\n\t\t\t$t_field_localized = lang_get( 'os_version' );\n\t\t\tbreak;\n\t\tcase 'build':\n\t\t\t$t_field_localized = lang_get( 'build' );\n\t\t\tbreak;\n\t\tcase 'platform':\n\t\t\t$t_field_localized = lang_get( 'platform' );\n\t\t\tbreak;\n\t\tcase 'summary':\n\t\t\t$t_field_localized = lang_get( 'summary' );\n\t\t\tbreak;\n\t\tcase 'duplicate_id':\n\t\t\t$t_field_localized = lang_get( 'duplicate_id' );\n\t\t\tbreak;\n\t\tcase 'sponsorship_total':\n\t\t\t$t_field_localized = lang_get( 'sponsorship_total' );\n\t\t\tbreak;\n\t\tcase 'due_date':\n\t\t\tif( $p_old_value !== '' ) {\n\t\t\t\t$p_old_value = date( config_get( 'normal_date_format' ), (int) $p_old_value );\n\t\t\t}\n\t\t\tif( $p_new_value !== '' ) {\n\t\t\t\t$p_new_value = date( config_get( 'normal_date_format' ), (int) $p_new_value );\n\t\t\t}\n\t\t\t$t_field_localized = lang_get( 'due_date' );\n\t\t\tbreak;\n\t\tdefault:\n\n\t\t\t# assume it's a custom field name\n\t\t\t$t_field_id = custom_field_get_id_from_name( $p_field_name );\n\t\t\tif( false !== $t_field_id ) {\n\t\t\t\t$t_cf_type = custom_field_type( $t_field_id );\n\t\t\t\tif( '' != $p_old_value ) {\n\t\t\t\t\t$p_old_value = string_custom_field_value_for_email( $p_old_value, $t_cf_type );\n\t\t\t\t}\n\t\t\t\t$p_new_value = string_custom_field_value_for_email( $p_new_value, $t_cf_type );\n\t\t\t}\n\t\t}\n\n\t\tif( NORMAL_TYPE != $p_type ) {\n\t\t\tswitch( $p_type ) {\n\t\t\t\tcase NEW_BUG:\n\t\t\t\t\t$t_note = lang_get( 'new_bug' );\n\t\t\t\t\tbreak;\n\t\t\t\tcase BUGNOTE_ADDED:\n\t\t\t\t\t$t_note = lang_get( 'bugnote_added' ) . ': ' . $p_old_value;\n\t\t\t\t\tbreak;\n\t\t\t\tcase BUGNOTE_UPDATED:\n\t\t\t\t\t$t_note = lang_get( 'bugnote_edited' ) . ': ' . $p_old_value;\n\t\t\t\t\t$t_old_value = (int)$p_old_value;\n\t\t\t\t\t$t_new_value = (int)$p_new_value;\n\t\t\t\t\tif ( $p_linkify && bug_revision_exists( $t_new_value ) ) {\n\t\t\t\t\t\tif ( bugnote_exists( $t_old_value ) ) {\n\t\t\t\t\t\t\t$t_bug_revision_view_page_argument = 'bugnote_id=' . $t_old_value . '#r' . $t_new_value;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$t_bug_revision_view_page_argument = 'rev_id=' . $t_new_value;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$t_change = '<a href=\"bug_revision_view_page.php?' . $t_bug_revision_view_page_argument . '\">' .\n\t\t\t\t\t\t\tlang_get( 'view_revisions' ) . '</a>';\n\t\t\t\t\t\t$t_raw = false;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase BUGNOTE_DELETED:\n\t\t\t\t\t$t_note = lang_get( 'bugnote_deleted' ) . ': ' . $p_old_value;\n\t\t\t\t\tbreak;\n\t\t\t\tcase DESCRIPTION_UPDATED:\n\t\t\t\t\t$t_note = lang_get( 'description_updated' );\n\t\t\t\t\t$t_old_value = (int)$p_old_value;\n\t\t\t\t\tif ( $p_linkify && bug_revision_exists( $t_old_value ) ) {\n\t\t\t\t\t\t$t_change = '<a href=\"bug_revision_view_page.php?rev_id=' . $t_old_value . '#r' . $t_old_value . '\">' .\n\t\t\t\t\t\t\tlang_get( 'view_revisions' ) . '</a>';\n\t\t\t\t\t\t$t_raw = false;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase ADDITIONAL_INFO_UPDATED:\n\t\t\t\t\t$t_note = lang_get( 'additional_information_updated' );\n\t\t\t\t\t$t_old_value = (int)$p_old_value;\n\t\t\t\t\tif ( $p_linkify && bug_revision_exists( $t_old_value ) ) {\n\t\t\t\t\t\t$t_change = '<a href=\"bug_revision_view_page.php?rev_id=' . $t_old_value . '#r' . $t_old_value . '\">' .\n\t\t\t\t\t\t\tlang_get( 'view_revisions' ) . '</a>';\n\t\t\t\t\t\t$t_raw = false;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase STEP_TO_REPRODUCE_UPDATED:\n\t\t\t\t\t$t_note = lang_get( 'steps_to_reproduce_updated' );\n\t\t\t\t\t$t_old_value = (int)$p_old_value;\n\t\t\t\t\tif ( $p_linkify && bug_revision_exists( $t_old_value ) ) {\n\t\t\t\t\t\t$t_change = '<a href=\"bug_revision_view_page.php?rev_id=' . $t_old_value . '#r' . $t_old_value . '\">' .\n\t\t\t\t\t\t\tlang_get( 'view_revisions' ) . '</a>';\n\t\t\t\t\t\t$t_raw = false;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_ADDED:\n\t\t\t\t\t$t_note = lang_get( 'file_added' ) . ': ' . $p_old_value;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_DELETED:\n\t\t\t\t\t$t_note = lang_get( 'file_deleted' ) . ': ' . $p_old_value;\n\t\t\t\t\tbreak;\n\t\t\t\tcase BUGNOTE_STATE_CHANGED:\n\t\t\t\t\t$p_old_value = get_enum_element( 'view_state', $p_old_value );\n\t\t\t\t\t$t_note = lang_get( 'bugnote_view_state' ) . ': ' . $p_new_value . ': ' . $p_old_value;\n\t\t\t\t\tbreak;\n\t\t\t\tcase BUG_MONITOR:\n\t\t\t\t\t$p_old_value = user_get_name( $p_old_value );\n\t\t\t\t\t$t_note = lang_get( 'bug_monitor' ) . ': ' . $p_old_value;\n\t\t\t\t\tbreak;\n\t\t\t\tcase BUG_UNMONITOR:\n\t\t\t\t\t$p_old_value = user_get_name( $p_old_value );\n\t\t\t\t\t$t_note = lang_get( 'bug_end_monitor' ) . ': ' . $p_old_value;\n\t\t\t\t\tbreak;\n\t\t\t\tcase BUG_DELETED:\n\t\t\t\t\t$t_note = lang_get( 'bug_deleted' ) . ': ' . $p_old_value;\n\t\t\t\t\tbreak;\n\t\t\t\tcase BUG_ADD_SPONSORSHIP:\n\t\t\t\t\t$t_note = lang_get( 'sponsorship_added' );\n\t\t\t\t\t$t_change = user_get_name( $p_old_value ) . ': ' . sponsorship_format_amount( $p_new_value );\n\t\t\t\t\tbreak;\n\t\t\t\tcase BUG_UPDATE_SPONSORSHIP:\n\t\t\t\t\t$t_note = lang_get( 'sponsorship_updated' );\n\t\t\t\t\t$t_change = user_get_name( $p_old_value ) . ': ' . sponsorship_format_amount( $p_new_value );\n\t\t\t\t\tbreak;\n\t\t\t\tcase BUG_DELETE_SPONSORSHIP:\n\t\t\t\t\t$t_note = lang_get( 'sponsorship_deleted' );\n\t\t\t\t\t$t_change = user_get_name( $p_old_value ) . ': ' . sponsorship_format_amount( $p_new_value );\n\t\t\t\t\tbreak;\n\t\t\t\tcase BUG_PAID_SPONSORSHIP:\n\t\t\t\t\t$t_note = lang_get( 'sponsorship_paid' );\n\t\t\t\t\t$t_change = user_get_name( $p_old_value ) . ': ' . get_enum_element( 'sponsorship', $p_new_value );\n\t\t\t\t\tbreak;\n\t\t\t\tcase BUG_ADD_RELATIONSHIP:\n\t\t\t\t\t$t_note = lang_get( 'relationship_added' );\n\t\t\t\t\t$t_change = relationship_get_description_for_history( $p_old_value ) . ' ' . bug_format_id( $p_new_value );\n\t\t\t\t\tbreak;\n\t\t\t\tcase BUG_REPLACE_RELATIONSHIP:\n\t\t\t\t\t$t_note = lang_get( 'relationship_replaced' );\n\t\t\t\t\t$t_change = relationship_get_description_for_history( $p_old_value ) . ' ' . bug_format_id( $p_new_value );\n\t\t\t\t\tbreak;\n\t\t\t\tcase BUG_DEL_RELATIONSHIP:\n\t\t\t\t\t$t_note = lang_get( 'relationship_deleted' );\n\n\t\t\t\t\t# Fix for #7846: There are some cases where old value is empty, this may be due to an old bug.\n\t\t\t\t\tif( !is_blank( $p_old_value ) && $p_old_value > 0 ) {\n\t\t\t\t\t\t$t_change = relationship_get_description_for_history( $p_old_value ) . ' ' . bug_format_id( $p_new_value );\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$t_change = bug_format_id( $p_new_value );\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase BUG_CLONED_TO:\n\t\t\t\t\t$t_note = lang_get( 'bug_cloned_to' );\n\t\t\t\t\t$t_change = bug_format_id( $p_new_value );\n\t\t\t\t\tbreak;\n\t\t\t\tcase BUG_CREATED_FROM:\n\t\t\t\t\t$t_note = lang_get( 'bug_created_from' );\n\t\t\t\t\t$t_change = bug_format_id( $p_new_value );\n\t\t\t\t\tbreak;\n\t\t\t\tcase TAG_ATTACHED:\n\t\t\t\t\t$t_note = lang_get( 'tag_history_attached' ) . ': ' . $p_old_value;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TAG_DETACHED:\n\t\t\t\t\t$t_note = lang_get( 'tag_history_detached' ) . ': ' . $p_old_value;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TAG_RENAMED:\n\t\t\t\t\t$t_note = lang_get( 'tag_history_renamed' );\n\t\t\t\t\t$t_change = $p_old_value . ' => ' . $p_new_value;\n\t\t\t\t\tbreak;\n\t\t\t\tcase BUG_REVISION_DROPPED:\n\t\t\t\t\t$t_note = lang_get( 'bug_revision_dropped_history' ) . ': ' . bug_revision_get_type_name( $p_new_value ) . ': ' . $p_old_value;\n\t\t\t\t\tbreak;\n\t\t\t\tcase BUGNOTE_REVISION_DROPPED:\n\t\t\t\t\t$t_note = lang_get( 'bugnote_revision_dropped_history' ) . ': ' . $p_new_value . ': ' . $p_old_value;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\t# output special cases\n\tif( NORMAL_TYPE == $p_type ) {\n\t\t$t_note = $t_field_localized;\n\t\t$t_change = $p_old_value . ' => ' . $p_new_value;\n\t}\n\n\t# end if DEFAULT\n\treturn array( 'note' => $t_note, 'change' => $t_change, 'raw' => $t_raw );\n}\n\n/**\n * delete all history associated with a bug\n * @param int $p_bug_id\n * @return true\n */\nfunction history_delete( $p_bug_id ) {\n\t$c_bug_id = db_prepare_int( $p_bug_id );\n\n\t$t_bug_history_table = db_get_table( 'bug_history' );\n\n\t$query = 'DELETE FROM ' . $t_bug_history_table . ' WHERE bug_id=' . db_param();\n\tdb_query_bound( $query, Array( $c_bug_id ) );\n\n\t# db_query errors on failure so:\n\treturn true;\n}\n"], "fixing_code": ["<?php\n# MantisBT - A PHP based bugtracking system\n\n# MantisBT is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 2 of the License, or\n# (at your option) any later version.\n#\n# MantisBT is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with MantisBT.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * This page allows actions to be performed an an array of bugs\n *\n * @package MantisBT\n * @copyright Copyright (C) 2000 - 2002  Kenzaburo Ito - kenito@300baud.org\n * @copyright Copyright (C) 2002 - 2012  MantisBT Team - mantisbt-dev@lists.sourceforge.net\n * @link http://www.mantisbt.org\n *\n * @uses core.php\n * @uses access_api.php\n * @uses authentication_api.php\n * @uses bug_api.php\n * @uses bugnote_api.php\n * @uses category_api.php\n * @uses config_api.php\n * @uses constant_inc.php\n * @uses custom_field_api.php\n * @uses event_api.php\n * @uses form_api.php\n * @uses gpc_api.php\n * @uses helper_api.php\n * @uses html_api.php\n * @uses lang_api.php\n * @uses print_api.php\n * @uses string_api.php\n * @uses utility_api.php\n * @uses version_api.php\n */\n\n/**\n * MantisBT Core API's\n */\nrequire_once( 'core.php' );\nrequire_api( 'access_api.php' );\nrequire_api( 'authentication_api.php' );\nrequire_api( 'bug_api.php' );\nrequire_api( 'bugnote_api.php' );\nrequire_api( 'category_api.php' );\nrequire_api( 'config_api.php' );\nrequire_api( 'constant_inc.php' );\nrequire_api( 'custom_field_api.php' );\nrequire_api( 'event_api.php' );\nrequire_api( 'form_api.php' );\nrequire_api( 'gpc_api.php' );\nrequire_api( 'helper_api.php' );\nrequire_api( 'html_api.php' );\nrequire_api( 'lang_api.php' );\nrequire_api( 'print_api.php' );\nrequire_api( 'string_api.php' );\nrequire_api( 'utility_api.php' );\nrequire_api( 'version_api.php' );\n\nauth_ensure_user_authenticated();\nhelper_begin_long_process();\n\n$f_action\t= gpc_get_string( 'action' );\n$f_custom_field_id = gpc_get_int( 'custom_field_id', 0 );\n$f_bug_arr\t= gpc_get_int_array( 'bug_arr', array() );\n$f_bug_notetext = gpc_get_string( 'bugnote_text', '' );\n$f_bug_noteprivate = gpc_get_bool( 'private' );\n$t_form_name = 'bug_actiongroup_' . $f_action;\nform_security_validate( $t_form_name );\n\n$t_custom_group_actions = config_get( 'custom_group_actions' );\n\nforeach( $t_custom_group_actions as $t_custom_group_action ) {\n\tif ( $f_action == $t_custom_group_action['action'] ) {\n\t\trequire_once( $t_custom_group_action['action_page'] );\n\t\texit;\n\t}\n}\n\n$t_failed_ids = array();\n\nif ( 0 != $f_custom_field_id ) {\n\t$t_custom_field_def = custom_field_get_definition( $f_custom_field_id );\n}\n\nforeach( $f_bug_arr as $t_bug_id ) {\n\tbug_ensure_exists( $t_bug_id );\n\t$t_bug = bug_get( $t_bug_id, true );\n\n\tif( $t_bug->project_id != helper_get_current_project() ) {\n\t\t# in case the current project is not the same project of the bug we are viewing...\n\t\t# ... override the current project. This to avoid problems with categories and handlers lists etc.\n\t\t$g_project_override = $t_bug->project_id;\n\t\t/** @todo (thraxisp) the next line goes away if the cache was smarter and used project */\n\t\tconfig_flush_cache(); # flush the config cache so that configs are refetched\n\t}\n\n\t$t_status = $t_bug->status;\n\n\tswitch ( $f_action ) {\n\n\tcase 'CLOSE':\n\t\t$t_closed = config_get( 'bug_closed_status_threshold' );\n\t\tif ( access_can_close_bug( $t_bug_id ) ) {\n\t\t\tif( ( $t_status < $t_closed ) &&\n\t\t\t\tbug_check_workflow( $t_status, $t_closed ) ) {\n\n\t\t\t/** @todo we need to issue a helper_call_custom_function( 'issue_update_validate', array( $f_bug_id, $t_bug_data, $f_bugnote_text ) ); */\n\t\t\tbug_close( $t_bug_id, $f_bug_notetext, $f_bug_noteprivate );\n\t\t\thelper_call_custom_function( 'issue_update_notify', array( $t_bug_id ) );\n\t\t} else {\n\t\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_status' );\n\t\t\t}\n\t\t} else {\n\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_access' );\n\t\t}\n\t\tbreak;\n\n\tcase 'DELETE':\n\t\tif ( access_has_bug_level( config_get( 'delete_bug_threshold' ), $t_bug_id ) ) {\n\t\t\tevent_signal( 'EVENT_BUG_DELETED', array( $t_bug_id ) );\n\t\t\tbug_delete( $t_bug_id );\n\t\t} else {\n\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_access' );\n\t\t}\n\t\tbreak;\n\n\tcase 'MOVE':\n\t\t$f_project_id = gpc_get_int( 'project_id' );\n\t\tif( access_has_bug_level( config_get( 'move_bug_threshold' ), $t_bug_id ) &&\n\t\t    access_has_project_level( config_get( 'report_bug_threshold', null, null, $f_project_id ), $f_project_id ) ) {\n\t\t\t/** @todo we need to issue a helper_call_custom_function( 'issue_update_validate', array( $t_bug_id, $t_bug_data, $f_bugnote_text ) ); */\n\t\t\tbug_move( $t_bug_id, $f_project_id );\n\t\t\thelper_call_custom_function( 'issue_update_notify', array( $t_bug_id ) );\n\t\t} else {\n\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_access' );\n\t\t}\n\t\tbreak;\n\n\tcase 'COPY':\n\t\t$f_project_id = gpc_get_int( 'project_id' );\n\n\t\tif ( access_has_project_level( config_get( 'report_bug_threshold' ), $f_project_id ) ) {\n\t\t\t# Copy everything except history\n\t\t\tbug_copy( $t_bug_id, $f_project_id, true, true, false, true, true, true );\n\t\t} else {\n\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_access' );\n\t\t}\n\t\tbreak;\n\n\tcase 'ASSIGN':\n\t\t$f_assign = gpc_get_int( 'assign' );\n\t\tif ( ON == config_get( 'auto_set_status_to_assigned' ) ) {\n\t\t\t$t_assign_status = config_get( 'bug_assigned_status' );\n\t\t} else {\n\t\t\t$t_assign_status = $t_status;\n\t\t}\n\t\t# check that new handler has rights to handle the issue, and\n\t\t#  that current user has rights to assign the issue\n\t\t$t_threshold = access_get_status_threshold( $t_assign_status, bug_get_field( $t_bug_id, 'project_id' ) );\n\t\tif ( access_has_bug_level( config_get( 'update_bug_assign_threshold', config_get( 'update_bug_threshold' ) ), $t_bug_id ) ) {\n\t\t\tif ( access_has_bug_level( config_get( 'handle_bug_threshold' ), $t_bug_id, $f_assign ) ) {\n\t\t\t\tif ( bug_check_workflow( $t_status, $t_assign_status ) ) {\n\t\t\t\t\t/** @todo we need to issue a helper_call_custom_function( 'issue_update_validate', array( $t_bug_id, $t_bug_data, $f_bugnote_text ) ); */\n\t\t\t\t\tbug_assign( $t_bug_id, $f_assign, $f_bug_notetext, $f_bug_noteprivate );\n\t\t\t\t\thelper_call_custom_function( 'issue_update_notify', array( $t_bug_id ) );\n\t\t\t\t} else {\n\t\t\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_status' );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_handler' );\n\t\t\t}\n\t\t} else {\n\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_access' );\n\t\t}\n\t\tbreak;\n\n\tcase 'RESOLVE':\n\t\t$t_resolved_status = config_get( 'bug_resolved_status_threshold' );\n\t\t\tif ( access_has_bug_level( access_get_status_threshold( $t_resolved_status, bug_get_field( $t_bug_id, 'project_id' ) ), $t_bug_id ) ) {\n\t\t\t\tif ( ( $t_status < $t_resolved_status ) &&\n\t\t\t\t\tbug_check_workflow($t_status, $t_resolved_status ) ) {\n\t\t\t$f_resolution = gpc_get_int( 'resolution' );\n\t\t\t$f_fixed_in_version = gpc_get_string( 'fixed_in_version', '' );\n\t\t\t/** @todo we need to issue a helper_call_custom_function( 'issue_update_validate', array( $t_bug_id, $t_bug_data, $f_bugnote_text ) ); */\n\t\t\tbug_resolve( $t_bug_id, $f_resolution, $f_fixed_in_version, $f_bug_notetext, null, null, $f_bug_noteprivate );\n\t\t\thelper_call_custom_function( 'issue_update_notify', array( $t_bug_id ) );\n\t\t} else {\n\t\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_status' );\n\t\t\t}\n\t\t\t} else {\n\t\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_access' );\n\t\t}\n\t\tbreak;\n\n\tcase 'UP_PRIOR':\n\t\tif ( access_has_bug_level( config_get( 'update_bug_threshold' ), $t_bug_id ) ) {\n\t\t\t$f_priority = gpc_get_int( 'priority' );\n\t\t\t/** @todo we need to issue a helper_call_custom_function( 'issue_update_validate', array( $t_bug_id, $t_bug_data, $f_bugnote_text ) ); */\n\t\t\tbug_set_field( $t_bug_id, 'priority', $f_priority );\n\t\t\thelper_call_custom_function( 'issue_update_notify', array( $t_bug_id ) );\n\t\t} else {\n\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_access' );\n\t\t}\n\t\tbreak;\n\n\tcase 'UP_STATUS':\n\t\t$f_status = gpc_get_int( 'status' );\n\t\t$t_project = bug_get_field( $t_bug_id, 'project_id' );\n\t\tif ( access_has_bug_level( access_get_status_threshold( $f_status, $t_project ), $t_bug_id ) ) {\n\t\t\tif ( TRUE == bug_check_workflow($t_status, $f_status ) ) {\n\t\t\t\t/** @todo we need to issue a helper_call_custom_function( 'issue_update_validate', array( $t_bug_id, $t_bug_data, $f_bugnote_text ) ); */\n\t\t\t\tbug_set_field( $t_bug_id, 'status', $f_status );\n\n\t\t\t\t# Add bugnote if supplied\n\t\t\t\tif ( !is_blank( $f_bug_notetext ) ) {\n\t\t\t\t\tbugnote_add( $t_bug_id, $f_bug_notetext, null, $f_bug_noteprivate );\n\t\t\t\t}\n\n\t\t\t\thelper_call_custom_function( 'issue_update_notify', array( $t_bug_id ) );\n\t\t\t} else {\n\t\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_status' );\n\t\t\t}\n\t\t} else {\n\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_access' );\n\t\t}\n\t\tbreak;\n\n\tcase 'UP_CATEGORY':\n\t\t$f_category_id = gpc_get_int( 'category' );\n\t\tif ( access_has_bug_level( config_get( 'update_bug_threshold' ), $t_bug_id ) ) {\n\t\t\tif ( category_exists( $f_category_id ) ) {\n\t\t\t\t/** @todo we need to issue a helper_call_custom_function( 'issue_update_validate', array( $t_bug_id, $t_bug_data, $f_bugnote_text ) ); */\n\t\t\t\tbug_set_field( $t_bug_id, 'category_id', $f_category_id );\n\t\t\t\thelper_call_custom_function( 'issue_update_notify', array( $t_bug_id ) );\n\t\t\t} else {\n\t\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_category' );\n\t\t\t}\n\t\t} else {\n\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_access' );\n\t\t}\n\t\tbreak;\n\n\tcase 'UP_FIXED_IN_VERSION':\n\t\t$f_fixed_in_version = gpc_get_string( 'fixed_in_version' );\n\t\t$t_project_id = bug_get_field( $t_bug_id, 'project_id' );\n\n\t\tif ( access_has_bug_level( config_get( 'update_bug_threshold' ), $t_bug_id ) ) {\n\t\t\tif ( $f_fixed_in_version === '' || version_get_id( $f_fixed_in_version, $t_project_id ) !== false ) {\n\t\t\t\t/** @todo we need to issue a helper_call_custom_function( 'issue_update_validate', array( $t_bug_id, $t_bug_data, $f_bugnote_text ) ); */\n\t\t\t\tbug_set_field( $t_bug_id, 'fixed_in_version', $f_fixed_in_version );\n\t\t\t\thelper_call_custom_function( 'issue_update_notify', array( $t_bug_id ) );\n\t\t\t\t} else {\n\t\t\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_version' );\n\t\t\t}\n\t\t\t} else {\n\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_access' );\n\t\t}\n\t\tbreak;\n\n\tcase 'UP_TARGET_VERSION':\n\t\t$f_target_version = gpc_get_string( 'target_version' );\n\t\t$t_project_id = bug_get_field( $t_bug_id, 'project_id' );\n\n\t\tif ( access_has_bug_level( config_get( 'roadmap_update_threshold' ), $t_bug_id ) ) {\n\t\t\tif ( $f_target_version === '' || version_get_id( $f_target_version, $t_project_id ) !== false ) {\n\t\t\t\t/** @todo we need to issue a helper_call_custom_function( 'issue_update_validate', array( $t_bug_id, $t_bug_data, $f_bugnote_text ) ); */\n\t\t\t\tbug_set_field( $t_bug_id, 'target_version', $f_target_version );\n\t\t\t\thelper_call_custom_function( 'issue_update_notify', array( $t_bug_id ) );\n\t\t\t\t} else {\n\t\t\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_version' );\n\t\t\t}\n\t\t\t} else {\n\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_access' );\n\t\t}\n\t\tbreak;\n\n\tcase 'VIEW_STATUS':\n\t\tif ( access_has_bug_level( config_get( 'change_view_status_threshold' ), $t_bug_id ) ) {\n\t\t\t$f_view_status = gpc_get_int( 'view_status' );\n\t\t\t/** @todo we need to issue a helper_call_custom_function( 'issue_update_validate', array( $t_bug_id, $t_bug_data, $f_bugnote_text ) ); */\n\t\t\tbug_set_field( $t_bug_id, 'view_state', $f_view_status );\n\t\t\thelper_call_custom_function( 'issue_update_notify', array( $t_bug_id ) );\n\t\t} else {\n\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_access' );\n\t\t}\n\t\tbreak;\n\n\tcase 'SET_STICKY':\n\t\tif ( access_has_bug_level( config_get( 'set_bug_sticky_threshold' ), $t_bug_id ) ) {\n\t\t\t$f_sticky = bug_get_field( $t_bug_id, 'sticky' );\n\t\t\t// The new value is the inverted old value\n\t\t\t/** @todo we need to issue a helper_call_custom_function( 'issue_update_validate', array( $t_bug_id, $t_bug_data, $f_bugnote_text ) ); */\n\t\t\tbug_set_field( $t_bug_id, 'sticky', intval( !$f_sticky ) );\n\t\t\thelper_call_custom_function( 'issue_update_notify', array( $t_bug_id ) );\n\t\t} else {\n\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_access' );\n\t\t}\n\t\tbreak;\n\n\tcase 'CUSTOM':\n\t\tif ( 0 === $f_custom_field_id ) {\n\t\t\ttrigger_error( ERROR_GENERIC, ERROR );\n\t\t}\n\n\t\t/** @todo we need to issue a helper_call_custom_function( 'issue_update_validate', array( $t_bug_id, $t_bug_data, $f_bugnote_text ) ); */\n\t\t$t_form_var = \"custom_field_$f_custom_field_id\";\n\t\t$t_custom_field_value = gpc_get_custom_field( $t_form_var, $t_custom_field_def['type'], null );\n\t\tcustom_field_set_value( $f_custom_field_id, $t_bug_id, $t_custom_field_value );\n\t\thelper_call_custom_function( 'issue_update_notify', array( $t_bug_id ) );\n\t\tbreak;\n\n\tdefault:\n\t\ttrigger_error( ERROR_GENERIC, ERROR );\n\t}\n\n\t// Bug Action Event\n\tevent_signal( 'EVENT_BUG_ACTION', array( $f_action, $t_bug_id ) );\n}\n\nform_security_purge( $t_form_name );\n\n$t_redirect_url = 'view_all_bug_page.php';\n\nif ( count( $t_failed_ids ) > 0 ) {\n\thtml_page_top();\n\n\techo '<div><br />';\n\techo '<table class=\"width75\">';\n\t$separator = lang_get( 'word_separator' );\n\tforeach( $t_failed_ids as $t_id => $t_reason ) {\n\t\t$label = sprintf( lang_get( 'label' ), string_get_bug_view_link( $t_id ) ) . $separator;\n\t\tprintf( \"<tr><td width=\\\"50%%\\\">%s%s</td><td>%s</td></tr>\\n\", $label, bug_get_field( $t_id, 'summary' ), $t_reason );\n\t}\n\techo '</table><br />';\n\tprint_bracket_link( $t_redirect_url, lang_get( 'proceed' ) );\n\techo '</div>';\n\n\thtml_page_bottom();\n} else {\n\tprint_header_redirect( $t_redirect_url );\n}\n", "<?php\n# MantisBT - A PHP based bugtracking system\n\n# MantisBT is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 2 of the License, or\n# (at your option) any later version.\n#\n# MantisBT is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with MantisBT.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Bug API\n *\n * @package CoreAPI\n * @subpackage BugAPI\n * @copyright Copyright (C) 2000 - 2002  Kenzaburo Ito - kenito@300baud.org\n * @copyright Copyright (C) 2002 - 2012  MantisBT Team - mantisbt-dev@lists.sourceforge.net\n * @link http://www.mantisbt.org\n *\n * @uses access_api.php\n * @uses authentication_api.php\n * @uses bugnote_api.php\n * @uses bug_revision_api.php\n * @uses category_api.php\n * @uses config_api.php\n * @uses constant_inc.php\n * @uses custom_field_api.php\n * @uses database_api.php\n * @uses date_api.php\n * @uses email_api.php\n * @uses error_api.php\n * @uses event_api.php\n * @uses file_api.php\n * @uses helper_api.php\n * @uses history_api.php\n * @uses lang_api.php\n * @uses relationship_api.php\n * @uses sponsorship_api.php\n * @uses tag_api.php\n * @uses twitter_api.php\n * @uses user_api.php\n * @uses utility_api.php\n */\n\nrequire_api( 'access_api.php' );\nrequire_api( 'authentication_api.php' );\nrequire_api( 'bugnote_api.php' );\nrequire_api( 'bug_revision_api.php' );\nrequire_api( 'category_api.php' );\nrequire_api( 'config_api.php' );\nrequire_api( 'constant_inc.php' );\nrequire_api( 'custom_field_api.php' );\nrequire_api( 'database_api.php' );\nrequire_api( 'date_api.php' );\nrequire_api( 'email_api.php' );\nrequire_api( 'error_api.php' );\nrequire_api( 'event_api.php' );\nrequire_api( 'file_api.php' );\nrequire_api( 'helper_api.php' );\nrequire_api( 'history_api.php' );\nrequire_api( 'lang_api.php' );\nrequire_api( 'relationship_api.php' );\nrequire_api( 'sponsorship_api.php' );\nrequire_api( 'tag_api.php' );\nrequire_api( 'twitter_api.php' );\nrequire_api( 'user_api.php' );\nrequire_api( 'utility_api.php' );\n\n/**\n * Bug Data Structure Definition\n * @package MantisBT\n * @subpackage classes\n */\nclass BugData {\n\tprotected $id;\n\tprotected $project_id = null;\n\tprotected $reporter_id = 0;\n\tprotected $handler_id = 0;\n\tprotected $duplicate_id = 0;\n\tprotected $priority = NORMAL;\n\tprotected $severity = MINOR;\n\tprotected $reproducibility = 10;\n\tprotected $status = NEW_;\n\tprotected $resolution = OPEN;\n\tprotected $projection = 10;\n\tprotected $category_id = 1;\n\tprotected $date_submitted = '';\n\tprotected $last_updated = '';\n\tprotected $eta = 10;\n\tprotected $os = '';\n\tprotected $os_build = '';\n\tprotected $platform = '';\n\tprotected $version = '';\n\tprotected $fixed_in_version = '';\n\tprotected $target_version = '';\n\tprotected $build = '';\n\tprotected $view_state = VS_PUBLIC;\n\tprotected $summary = '';\n\tprotected $sponsorship_total = 0;\n\tprotected $sticky = 0;\n\tprotected $due_date = 0;\n\n\t# omitted:\n\t# var $bug_text_id\n\tprotected $profile_id = 0;\n\n\t# extended info\n\tprotected $description = '';\n\tprotected $steps_to_reproduce = '';\n\tprotected $additional_information = '';\n\n\t# internal helper objects\n\tprivate $_stats = null;\n\n\tpublic $attachment_count = null;\n\tpublic $bugnotes_count = null;\n\n\tprivate $loading = false;\n\n\t/**\n\t * return number of file attachment's linked to current bug\n\t * @return int\n\t */\n\tpublic function get_attachment_count() {\n\t\tif ( $this->attachment_count === null ) {\n\t\t\t$this->attachment_count = file_bug_attachment_count( $this->id );\n\t\t\treturn $this->attachment_count;\n\t\t} else {\n\t\t\treturn $this->attachment_count;\n\t\t}\n\t}\n\n\t/**\n\t * return number of bugnotes's linked to current bug\n\t * @return int\n\t */\n\tpublic function get_bugnotes_count() {\n\t\tif ( $this->bugnotes_count === null ) {\n\t\t\t$this->bugnotes_count = self::bug_get_bugnote_count();\n\t\t\treturn $this->bugnotes_count;\n\t\t} else {\n\t\t\treturn $this->bugnotes_count;\n\t\t}\n\t}\n\n\t/**\n\t * @private\n\t */\n\tpublic function __set($name, $value) {\n\t\tswitch ($name) {\n\t\t\t// integer types\n\t\t\tcase 'id':\n\t\t\tcase 'project_id':\n\t\t\tcase 'reporter_id':\n\t\t\tcase 'handler_id':\n\t\t\tcase 'duplicate_id':\n\t\t\tcase 'priority':\n\t\t\tcase 'severity':\n\t\t\tcase 'reproducibility':\n\t\t\tcase 'status':\n\t\t\tcase 'resolution':\n\t\t\tcase 'projection':\n\t\t\tcase 'category_id':\n\t\t\t\t$value = (int)$value;\n\t\t\t\tbreak;\n\t\t\tcase 'target_version':\n\t\t\t\tif ( !$this->loading ) {\n\t\t\t\t\t# Only set target_version if user has access to do so\n\t\t\t\t\tif( !access_has_project_level( config_get( 'roadmap_update_threshold' ) ) ) {\n\t\t\t\t\t\ttrigger_error( ERROR_ACCESS_DENIED, ERROR );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'due_date':\n\t\t\t\tif ( !is_numeric( $value ) ) {\n\t\t\t\t\t$value = strtotime($value);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t\t$this->$name = $value;\n\t}\n\n\t/**\n\t * @private\n\t */\n\tpublic function __get($name) {\n\t\tif( $this->is_extended_field($name) )\n\t\t\t$this->fetch_extended_info();\n\t\treturn $this->{$name};\n\t}\n\n\t/**\n\t * @private\n\t */\n\tpublic function __isset($name) {\n\t\treturn isset( $this->{$name} );\n\t}\n\n\t/**\n\t * fast-load database row into bugobject\n\t * @param array $p_row\n\t */\n\tpublic function loadrow( $p_row ) {\n\t\t$this->loading = true;\n\n\t\tforeach( $p_row as $var => $val ) {\n\t\t\t$this->__set( $var, $p_row[$var] );\n\t\t}\n\t\t$this->loading = false;\n\t}\n\n\t/**\n\t * Retrieves extended information for bug (e.g. bug description)\n\t * @return null\n\t */\n\tprivate function fetch_extended_info() {\n\t\tif ( $this->description == '' ) {\n\t\t\t$t_text = bug_text_cache_row($this->id);\n\n\t\t\t$this->description = $t_text['description'];\n\t\t\t$this->steps_to_reproduce = $t_text['steps_to_reproduce'];\n\t\t\t$this->additional_information = $t_text['additional_information'];\n\t\t}\n\t}\n\n\t/**\n\t * Returns if the field is an extended field which needs fetch_extended_info()\n\t * @return boolean\n\t */\n\tprivate function is_extended_field( $p_field_name ) {\n\t\tswitch( $p_field_name ) {\n\t\t\tcase 'description':\n\t\t\tcase 'steps_to_reproduce':\n\t\t\tcase 'additional_information':\n\t\t\t\treturn true;\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Returns the number of bugnotes for the given bug_id\n\t * @return int number of bugnotes\n\t * @access private\n\t * @uses database_api.php\n\t */\n\tprivate function bug_get_bugnote_count() {\n\t\tif( !access_has_project_level( config_get( 'private_bugnote_threshold' ), $this->project_id ) ) {\n\t\t\t$t_restriction = 'AND view_state=' . VS_PUBLIC;\n\t\t} else {\n\t\t\t$t_restriction = '';\n\t\t}\n\n\t\t$t_bugnote_table = db_get_table( 'bugnote' );\n\t\t$query = \"SELECT COUNT(*)\n\t\t\t\t\t  FROM $t_bugnote_table\n\t\t\t\t\t  WHERE bug_id =\" . db_param() . \" $t_restriction\";\n\t\t$result = db_query_bound( $query, Array( $this->bug_id ) );\n\n\t\treturn db_result( $result );\n\t}\n\n\t/**\n\t * validate current bug object for database insert/update\n\t * triggers error on failure\n\t * @param bool $p_update_extended\n\t */\n\tfunction validate( $p_update_extended =  true) {\n\t\t# Summary cannot be blank\n\t\tif( is_blank( $this->summary ) ) {\n\t\t\terror_parameters( lang_get( 'summary' ) );\n\t\t\ttrigger_error( ERROR_EMPTY_FIELD, ERROR );\n\t\t}\n\n\t\tif( $p_update_extended ) {\n\t\t\t# Description field cannot be empty\n\t\t\tif( is_blank( $this->description ) ) {\n\t\t\t\terror_parameters( lang_get( 'description' ) );\n\t\t\t\ttrigger_error( ERROR_EMPTY_FIELD, ERROR );\n\t\t\t}\n\t\t}\n\n\t\t# Make sure a category is set\n\t\tif( 0 == $this->category_id && !config_get( 'allow_no_category' ) ) {\n\t\t\terror_parameters( lang_get( 'category' ) );\n\t\t\ttrigger_error( ERROR_EMPTY_FIELD, ERROR );\n\t\t}\n\n\t\tif( !is_blank( $this->duplicate_id ) && ( $this->duplicate_id != 0 ) && ( $this->id == $this->duplicate_id ) ) {\n\t\t\ttrigger_error( ERROR_BUG_DUPLICATE_SELF, ERROR );\n\t\t\t# never returns\n\t\t}\n\t}\n\n\t/**\n\t * Insert a new bug into the database\n\t * @return int integer representing the bug id that was created\n\t * @access public\n\t * @uses database_api.php\n\t * @uses lang_api.php\n\t */\n\tfunction create() {\n\t\tself::validate( true );\n\n\t\t# check due_date format\n\t\tif( is_blank( $this->due_date ) ) {\n\t\t\t$this->due_date = date_get_null();\n\t\t}\n\t\t# check date submitted and last modified\n\t\tif( is_blank( $this->date_submitted ) ) {\n\t\t\t$this->date_submitted = db_now();\n\t\t}\n\t\tif( is_blank( $this->last_updated ) ) {\n\t\t\t$this->last_updated = db_now();\n\t\t}\n\n\t\t$t_bug_table = db_get_table( 'bug' );\n\t\t$t_bug_text_table = db_get_table( 'bug_text' );\n\t\t$t_category_table = db_get_table( 'category' );\n\n\t\t# Insert text information\n\t\t$query = \"INSERT INTO $t_bug_text_table\n\t\t\t\t\t    ( description, steps_to_reproduce, additional_information )\n\t\t\t\t\t  VALUES\n\t\t\t\t\t    ( \" . db_param() . ',' . db_param() . ',' . db_param() . ')';\n\t\tdb_query_bound( $query, Array( $this->description, $this->steps_to_reproduce, $this->additional_information ) );\n\n\t\t# Get the id of the text information we just inserted\n\t\t# NOTE: this is guarranteed to be the correct one.\n\t\t# The value LAST_INSERT_ID is stored on a per connection basis.\n\n\t\t$t_text_id = db_insert_id( $t_bug_text_table );\n\n\t\t# check to see if we want to assign this right off\n\t\t$t_starting_status  = config_get( 'bug_submit_status' );\n\t\t$t_original_status = $this->status;\n\n\t\t# if not assigned, check if it should auto-assigned.\n\t\tif( 0 == $this->handler_id ) {\n\t\t\t# if a default user is associated with the category and we know at this point\n\t\t\t# that that the bug was not assigned to somebody, then assign it automatically.\n\t\t\t$query = \"SELECT user_id\n\t\t\t\t\t\t  FROM $t_category_table\n\t\t\t\t\t\t  WHERE id=\" . db_param();\n\t\t\t$result = db_query_bound( $query, array( $this->category_id ) );\n\n\t\t\tif( db_num_rows( $result ) > 0 ) {\n\t\t\t\t$this->handler_id = db_result( $result );\n\t\t\t}\n\t\t}\n\n\t\t# Check if bug was pre-assigned or auto-assigned.\n\t\tif( ( $this->handler_id != 0 ) && ( $this->status == $t_starting_status ) && ( ON == config_get( 'auto_set_status_to_assigned' ) ) ) {\n\t\t\t$t_status = config_get( 'bug_assigned_status' );\n\t\t} else {\n\t\t\t$t_status = $this->status;\n\t\t}\n\n\t\t# Insert the rest of the data\n\t\t$query = \"INSERT INTO $t_bug_table\n\t\t\t\t\t    ( project_id,reporter_id, handler_id,duplicate_id,\n\t\t\t\t\t      priority,severity, reproducibility,status,\n\t\t\t\t\t      resolution,projection, category_id,date_submitted,\n\t\t\t\t\t      last_updated,eta, bug_text_id,\n\t\t\t\t\t      os, os_build,platform, version,build,\n\t\t\t\t\t      profile_id, summary, view_state, sponsorship_total, sticky, fixed_in_version,\n\t\t\t\t\t      target_version, due_date\n\t\t\t\t\t    )\n\t\t\t\t\t  VALUES\n\t\t\t\t\t    ( \" . db_param() . ',' . db_param() . ',' . db_param() . ',' . db_param() . \",\n\t\t\t\t\t      \" . db_param() . ',' . db_param() . ',' . db_param() . ',' . db_param() . \",\n\t\t\t\t\t      \" . db_param() . ',' . db_param() . ',' . db_param() . ',' . db_param() . \",\n\t\t\t\t\t      \" . db_param() . ',' . db_param() . ',' . db_param() . ',' . db_param() . \",\n\t\t\t\t\t      \" . db_param() . ',' . db_param() . ',' . db_param() . ',' . db_param() . \",\n\t\t\t\t\t      \" . db_param() . ',' . db_param() . ',' . db_param() . ',' . db_param() . \",\n\t\t\t\t\t      \" . db_param() . ',' . db_param() . ',' . db_param() . ',' . db_param() . ')';\n\n\t\tdb_query_bound( $query, Array( $this->project_id, $this->reporter_id, $this->handler_id, $this->duplicate_id, $this->priority, $this->severity, $this->reproducibility, $t_status, $this->resolution, $this->projection, $this->category_id, $this->date_submitted, $this->last_updated, $this->eta, $t_text_id, $this->os, $this->os_build, $this->platform, $this->version, $this->build, $this->profile_id, $this->summary, $this->view_state, $this->sponsorship_total, $this->sticky, $this->fixed_in_version, $this->target_version, $this->due_date ) );\n\n\t\t$this->id = db_insert_id( $t_bug_table );\n\n\t\t# log new bug\n\t\thistory_log_event_special( $this->id, NEW_BUG );\n\n\t\t# log changes, if any (compare happens in history_log_event_direct)\n\t\thistory_log_event_direct( $this->id, 'status', $t_original_status, $t_status );\n\t\thistory_log_event_direct( $this->id, 'handler_id', 0, $this->handler_id );\n\n\t\treturn $this->id;\n\t}\n\n\t/**\n\t * Update a bug from the given data structure\n\t *  If the third parameter is true, also update the longer strings table\n\t * @param bool p_update_extended\n\t * @param bool p_bypass_email Default false, set to true to avoid generating emails (if sending elsewhere)\n\t * @return bool (always true)\n\t * @access public\n\t */\n\tfunction update( $p_update_extended = false, $p_bypass_mail = false ) {\n\t\tself::validate( $p_update_extended );\n\n\t\t$c_bug_id = $this->id;\n\n\t\tif( is_blank( $this->due_date ) ) {\n\t\t\t$this->due_date = date_get_null();\n\t\t}\n\n\t\t$t_old_data = bug_get( $this->id, true );\n\n\t\t$t_bug_table = db_get_table( 'bug' );\n\n\t\t# Update all fields\n\t\t# Ignore date_submitted and last_updated since they are pulled out\n\t\t#  as unix timestamps which could confuse the history log and they\n\t\t#  shouldn't get updated like this anyway.  If you really need to change\n\t\t#  them use bug_set_field()\n\t\t$query = \"UPDATE $t_bug_table\n\t\t\t\t\tSET project_id=\" . db_param() . ', reporter_id=' . db_param() . \",\n\t\t\t\t\t\thandler_id=\" . db_param() . ', duplicate_id=' . db_param() . \",\n\t\t\t\t\t\tpriority=\" . db_param() . ', severity=' . db_param() . \",\n\t\t\t\t\t\treproducibility=\" . db_param() . ', status=' . db_param() . \",\n\t\t\t\t\t\tresolution=\" . db_param() . ', projection=' . db_param() . \",\n\t\t\t\t\t\tcategory_id=\" . db_param() . ', eta=' . db_param() . \",\n\t\t\t\t\t\tos=\" . db_param() . ', os_build=' . db_param() . \",\n\t\t\t\t\t\tplatform=\" . db_param() . ', version=' . db_param() . \",\n\t\t\t\t\t\tbuild=\" . db_param() . ', fixed_in_version=' . db_param() . ',';\n\n\t\t$t_fields = Array(\n\t\t\t$this->project_id, $this->reporter_id,\n\t\t\t$this->handler_id, $this->duplicate_id,\n\t\t\t$this->priority, $this->severity,\n\t\t\t$this->reproducibility, $this->status,\n\t\t\t$this->resolution, $this->projection,\n\t\t\t$this->category_id, $this->eta,\n\t\t\t$this->os, $this->os_build,\n\t\t\t$this->platform, $this->version,\n\t\t\t$this->build, $this->fixed_in_version,\n\t\t);\n\t\t$t_roadmap_updated = false;\n\t\tif( access_has_project_level( config_get( 'roadmap_update_threshold' ) ) ) {\n\t\t\t$query .= \"\n\t\t\t\t\t\ttarget_version=\" . db_param() . \",\";\n\t\t\t$t_fields[] = $this->target_version;\n\t\t\t$t_roadmap_updated = true;\n\t\t}\n\n\t\t$query .= \"\n\t\t\t\t\t\tview_state=\" . db_param() . \",\n\t\t\t\t\t\tsummary=\" . db_param() . \",\n\t\t\t\t\t\tsponsorship_total=\" . db_param() . \",\n\t\t\t\t\t\tsticky=\" . db_param() . \",\n\t\t\t\t\t\tdue_date=\" . db_param() . \"\n\t\t\t\t\tWHERE id=\" . db_param();\n\t\t$t_fields[] = $this->view_state;\n\t\t$t_fields[] = $this->summary;\n\t\t$t_fields[] = $this->sponsorship_total;\n\t\t$t_fields[] = (bool)$this->sticky;\n\t\t$t_fields[] = $this->due_date;\n\t\t$t_fields[] = $this->id;\n\n\t\tdb_query_bound( $query, $t_fields );\n\n\t\tbug_clear_cache( $this->id );\n\n\t\t# log changes\n\t\thistory_log_event_direct( $c_bug_id, 'project_id', $t_old_data->project_id, $this->project_id );\n\t\thistory_log_event_direct( $c_bug_id, 'reporter_id', $t_old_data->reporter_id, $this->reporter_id );\n\t\thistory_log_event_direct( $c_bug_id, 'handler_id', $t_old_data->handler_id, $this->handler_id );\n\t\thistory_log_event_direct( $c_bug_id, 'priority', $t_old_data->priority, $this->priority );\n\t\thistory_log_event_direct( $c_bug_id, 'severity', $t_old_data->severity, $this->severity );\n\t\thistory_log_event_direct( $c_bug_id, 'reproducibility', $t_old_data->reproducibility, $this->reproducibility );\n\t\thistory_log_event_direct( $c_bug_id, 'status', $t_old_data->status, $this->status );\n\t\thistory_log_event_direct( $c_bug_id, 'resolution', $t_old_data->resolution, $this->resolution );\n\t\thistory_log_event_direct( $c_bug_id, 'projection', $t_old_data->projection, $this->projection );\n\t\thistory_log_event_direct( $c_bug_id, 'category', category_full_name( $t_old_data->category_id, false ), category_full_name( $this->category_id, false ) );\n\t\thistory_log_event_direct( $c_bug_id, 'eta', $t_old_data->eta, $this->eta );\n\t\thistory_log_event_direct( $c_bug_id, 'os', $t_old_data->os, $this->os );\n\t\thistory_log_event_direct( $c_bug_id, 'os_build', $t_old_data->os_build, $this->os_build );\n\t\thistory_log_event_direct( $c_bug_id, 'platform', $t_old_data->platform, $this->platform );\n\t\thistory_log_event_direct( $c_bug_id, 'version', $t_old_data->version, $this->version );\n\t\thistory_log_event_direct( $c_bug_id, 'build', $t_old_data->build, $this->build );\n\t\thistory_log_event_direct( $c_bug_id, 'fixed_in_version', $t_old_data->fixed_in_version, $this->fixed_in_version );\n\t\tif( $t_roadmap_updated ) {\n\t\t\thistory_log_event_direct( $c_bug_id, 'target_version', $t_old_data->target_version, $this->target_version );\n\t\t}\n\t\thistory_log_event_direct( $c_bug_id, 'view_state', $t_old_data->view_state, $this->view_state );\n\t\thistory_log_event_direct( $c_bug_id, 'summary', $t_old_data->summary, $this->summary );\n\t\thistory_log_event_direct( $c_bug_id, 'sponsorship_total', $t_old_data->sponsorship_total, $this->sponsorship_total );\n\t\thistory_log_event_direct( $c_bug_id, 'sticky', $t_old_data->sticky, $this->sticky );\n\n\t\thistory_log_event_direct( $c_bug_id, 'due_date', ( $t_old_data->due_date != date_get_null() ) ? $t_old_data->due_date : null, ( $this->due_date != date_get_null() ) ? $this->due_date : null );\n\n\t\t# Update extended info if requested\n\t\tif( $p_update_extended ) {\n\t\t\t$t_bug_text_table = db_get_table( 'bug_text' );\n\n\t\t\t$t_bug_text_id = bug_get_field( $c_bug_id, 'bug_text_id' );\n\n\t\t\t$query = \"UPDATE $t_bug_text_table\n\t\t\t\t\t\t\tSET description=\" . db_param() . \",\n\t\t\t\t\t\t\t\tsteps_to_reproduce=\" . db_param() . \",\n\t\t\t\t\t\t\t\tadditional_information=\" . db_param() . \"\n\t\t\t\t\t\t\tWHERE id=\" . db_param();\n\t\t\tdb_query_bound( $query, Array( $this->description, $this->steps_to_reproduce, $this->additional_information, $t_bug_text_id ) );\n\n\t\t\tbug_text_clear_cache( $c_bug_id );\n\n\t\t\t$t_current_user = auth_get_current_user_id();\n\n\t\t\tif( $t_old_data->description != $this->description ) {\n\t\t\t\tif ( bug_revision_count( $c_bug_id, REV_DESCRIPTION ) < 1 ) {\n\t\t\t\t\t$t_revision_id = bug_revision_add( $c_bug_id, $t_current_user, REV_DESCRIPTION, $t_old_data->description, 0, $t_old_data->last_updated );\n\t\t\t\t}\n\t\t\t\t$t_revision_id = bug_revision_add( $c_bug_id, $t_current_user, REV_DESCRIPTION, $this->description );\n\t\t\t\thistory_log_event_special( $c_bug_id, DESCRIPTION_UPDATED, $t_revision_id );\n\t\t\t}\n\n\t\t\tif( $t_old_data->steps_to_reproduce != $this->steps_to_reproduce ) {\n\t\t\t\tif ( bug_revision_count( $c_bug_id, REV_STEPS_TO_REPRODUCE ) < 1 ) {\n\t\t\t\t\t$t_revision_id = bug_revision_add( $c_bug_id, $t_current_user, REV_STEPS_TO_REPRODUCE, $t_old_data->steps_to_reproduce, 0, $t_old_data->last_updated );\n\t\t\t\t}\n\t\t\t\t$t_revision_id = bug_revision_add( $c_bug_id, $t_current_user, REV_STEPS_TO_REPRODUCE, $this->steps_to_reproduce );\n\t\t\t\thistory_log_event_special( $c_bug_id, STEP_TO_REPRODUCE_UPDATED, $t_revision_id );\n\t\t\t}\n\n\t\t\tif( $t_old_data->additional_information != $this->additional_information ) {\n\t\t\t\tif ( bug_revision_count( $c_bug_id, REV_ADDITIONAL_INFO ) < 1 ) {\n\t\t\t\t\t$t_revision_id = bug_revision_add( $c_bug_id, $t_current_user, REV_ADDITIONAL_INFO, $t_old_data->additional_information, 0, $t_old_data->last_updated );\n\t\t\t\t}\n\t\t\t\t$t_revision_id = bug_revision_add( $c_bug_id, $t_current_user, REV_ADDITIONAL_INFO, $this->additional_information );\n\t\t\t\thistory_log_event_special( $c_bug_id, ADDITIONAL_INFO_UPDATED, $t_revision_id );\n\t\t\t}\n\t\t}\n\n\t\t# Update the last update date\n\t\tbug_update_date( $c_bug_id );\n\n\t\t# allow bypass if user is sending mail separately\n\t\tif( false == $p_bypass_mail ) {\n\t\t\t# bug assigned\n\t\t\tif( $t_old_data->handler_id != $this->handler_id ) {\n\t\t\t\temail_generic( $c_bug_id, 'owner', 'email_notification_title_for_action_bug_assigned' );\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t# status changed\n\t\t\tif( $t_old_data->status != $this->status ) {\n\t\t\t\t$t_status = MantisEnum::getLabel( config_get( 'status_enum_string' ), $this->status );\n\t\t\t\t$t_status = str_replace( ' ', '_', $t_status );\n\t\t\t\temail_generic( $c_bug_id, $t_status, 'email_notification_title_for_status_bug_' . $t_status );\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t# @todo handle priority change if it requires special handling\n\t\t\t# generic update notification\n\t\t\temail_generic( $c_bug_id, 'updated', 'email_notification_title_for_action_bug_updated' );\n\t\t}\n\n\t\treturn true;\n\t}\n}\n\n$g_cache_bug = array();\n$g_cache_bug_text = array();\n\n/**\n * Cache a database result-set containing full contents of bug_table row.\n * @param array p_bug_database_result database row containing all columns from mantis_bug_table\n * @param array p_stats (optional) array representing bugnote stats\n * @return array returns an array representing the bug row if bug exists\n * @access public\n */\nfunction bug_cache_database_result( $p_bug_database_result, $p_stats = null ) {\n\tglobal $g_cache_bug;\n\n\tif( !is_array( $p_bug_database_result ) || isset( $g_cache_bug[(int) $p_bug_database_result['id']] ) ) {\n\t\treturn $g_cache_bug[(int) $p_bug_database_result['id']];\n\t}\n\n\treturn bug_add_to_cache( $p_bug_database_result, $p_stats );\n}\n\n/**\n * Cache a bug row if necessary and return the cached copy\n * @param array p_bug_id id of bug to cache from mantis_bug_table\n * @param array p_trigger_errors set to true to trigger an error if the bug does not exist.\n * @return bool|array returns an array representing the bug row if bug exists or false if bug does not exist\n * @access public\n * @uses database_api.php\n */\nfunction bug_cache_row( $p_bug_id, $p_trigger_errors = true ) {\n\tglobal $g_cache_bug;\n\n\tif( isset( $g_cache_bug[$p_bug_id] ) ) {\n\t\treturn $g_cache_bug[$p_bug_id];\n\t}\n\n\t$c_bug_id = (int) $p_bug_id;\n\t$t_bug_table = db_get_table( 'bug' );\n\n\t$query = \"SELECT *\n\t\t\t\t  FROM $t_bug_table\n\t\t\t\t  WHERE id=\" . db_param();\n\t$result = db_query_bound( $query, Array( $c_bug_id ) );\n\n\tif( 0 == db_num_rows( $result ) ) {\n\t\t$g_cache_bug[$c_bug_id] = false;\n\n\t\tif( $p_trigger_errors ) {\n\t\t\terror_parameters( $p_bug_id );\n\t\t\ttrigger_error( ERROR_BUG_NOT_FOUND, ERROR );\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t$row = db_fetch_array( $result );\n\n\treturn bug_add_to_cache( $row );\n}\n\n/**\n * Cache a set of bugs\n * @param array p_bug_id_array integer array representing bug ids to cache\n * @return null\n * @access public\n * @uses database_api.php\n */\nfunction bug_cache_array_rows( $p_bug_id_array ) {\n\tglobal $g_cache_bug;\n\t$c_bug_id_array = array();\n\n\tforeach( $p_bug_id_array as $t_bug_id ) {\n\t\tif( !isset( $g_cache_bug[(int) $t_bug_id] ) ) {\n\t\t\t$c_bug_id_array[] = (int) $t_bug_id;\n\t\t}\n\t}\n\n\tif( empty( $c_bug_id_array ) ) {\n\t\treturn;\n\t}\n\n\t$t_bug_table = db_get_table( 'bug' );\n\n\t$query = \"SELECT *\n\t\t\t\t  FROM $t_bug_table\n\t\t\t\t  WHERE id IN (\" . implode( ',', $c_bug_id_array ) . ')';\n\t$result = db_query_bound( $query );\n\n\twhile( $row = db_fetch_array( $result ) ) {\n\t\tbug_add_to_cache( $row );\n\t}\n\treturn;\n}\n\n/**\n * Inject a bug into the bug cache\n * @param array p_bug_row bug row to cache\n * @param array p_stats bugnote stats to cache\n * @return null\n * @access private\n */\nfunction bug_add_to_cache( $p_bug_row, $p_stats = null ) {\n\tglobal $g_cache_bug;\n\n\t$g_cache_bug[(int) $p_bug_row['id']] = $p_bug_row;\n\n\tif( !is_null( $p_stats ) ) {\n\t\t$g_cache_bug[(int) $p_bug_row['id']]['_stats'] = $p_stats;\n\t}\n\n\treturn $g_cache_bug[(int) $p_bug_row['id']];\n}\n\n/**\n * Clear a bug from the cache or all bugs if no bug id specified.\n * @param int bug id to clear (optional)\n * @return null\n * @access public\n */\nfunction bug_clear_cache( $p_bug_id = null ) {\n\tglobal $g_cache_bug;\n\n\tif( null === $p_bug_id ) {\n\t\t$g_cache_bug = array();\n\t} else {\n\t\tunset( $g_cache_bug[(int) $p_bug_id] );\n\t}\n\n\treturn true;\n}\n\n/**\n * Cache a bug text row if necessary and return the cached copy\n * @param int p_bug_id integer bug id to retrieve text for\n * @param bool p_trigger_errors If the second parameter is true (default), trigger an error if bug text not found.\n * @return bool|array returns false if not bug text found or array of bug text\n * @access public\n * @uses database_api.php\n */\nfunction bug_text_cache_row( $p_bug_id, $p_trigger_errors = true ) {\n\tglobal $g_cache_bug_text;\n\n\t$c_bug_id = (int) $p_bug_id;\n\t$t_bug_table = db_get_table( 'bug' );\n\t$t_bug_text_table = db_get_table( 'bug_text' );\n\n\tif( isset( $g_cache_bug_text[$c_bug_id] ) ) {\n\t\treturn $g_cache_bug_text[$c_bug_id];\n\t}\n\n\t$query = \"SELECT bt.*\n\t\t\t\t  FROM $t_bug_text_table bt, $t_bug_table b\n\t\t\t\t  WHERE b.id=\" . db_param() . \" AND\n\t\t\t\t  \t\tb.bug_text_id = bt.id\";\n\t$result = db_query_bound( $query, Array( $c_bug_id ) );\n\n\tif( 0 == db_num_rows( $result ) ) {\n\t\t$g_cache_bug_text[$c_bug_id] = false;\n\n\t\tif( $p_trigger_errors ) {\n\t\t\terror_parameters( $p_bug_id );\n\t\t\ttrigger_error( ERROR_BUG_NOT_FOUND, ERROR );\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t$row = db_fetch_array( $result );\n\n\t$g_cache_bug_text[$c_bug_id] = $row;\n\n\treturn $row;\n}\n\n/**\n * Clear a bug's bug text from the cache or all bug text if no bug id specified.\n * @param int bug id to clear (optional)\n * @return null\n * @access public\n */\nfunction bug_text_clear_cache( $p_bug_id = null ) {\n\tglobal $g_cache_bug_text;\n\n\tif( null === $p_bug_id ) {\n\t\t$g_cache_bug_text = array();\n\t} else {\n\t\tunset( $g_cache_bug_text[(int) $p_bug_id] );\n\t}\n\n\treturn true;\n}\n\n/**\n * Check if a bug exists\n * @param int p_bug_id integer representing bug id\n * @return bool true if bug exists, false otherwise\n * @access public\n */\nfunction bug_exists( $p_bug_id ) {\n\tif( false == bug_cache_row( $p_bug_id, false ) ) {\n\t\treturn false;\n\t} else {\n\t\treturn true;\n\t}\n}\n\n/**\n * Check if a bug exists. If it doesn't then trigger an error\n * @param int p_bug_id integer representing bug id\n * @return null\n * @access public\n */\nfunction bug_ensure_exists( $p_bug_id ) {\n\tif( !bug_exists( $p_bug_id ) ) {\n\t\terror_parameters( $p_bug_id );\n\t\ttrigger_error( ERROR_BUG_NOT_FOUND, ERROR );\n\t}\n}\n\n/**\n * check if the given user is the reporter of the bug\n * @param int p_bug_id integer representing bug id\n * @param int p_user_id integer reprenting a user id\n * @return bool return true if the user is the reporter, false otherwise\n * @access public\n */\nfunction bug_is_user_reporter( $p_bug_id, $p_user_id ) {\n\tif( bug_get_field( $p_bug_id, 'reporter_id' ) == $p_user_id ) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\n/**\n * check if the given user is the handler of the bug\n * @param int p_bug_id integer representing bug id\n * @param int p_user_id integer reprenting a user id\n * @return bool return true if the user is the handler, false otherwise\n * @access public\n */\nfunction bug_is_user_handler( $p_bug_id, $p_user_id ) {\n\tif( bug_get_field( $p_bug_id, 'handler_id' ) == $p_user_id ) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\n/**\n * Check if the bug is readonly and shouldn't be modified\n * For a bug to be readonly the status has to be >= bug_readonly_status_threshold and\n * current user access level < update_readonly_bug_threshold.\n * @param int p_bug_id integer representing bug id\n * @return bool\n * @access public\n * @uses access_api.php\n * @uses config_api.php\n */\nfunction bug_is_readonly( $p_bug_id ) {\n\t$t_status = bug_get_field( $p_bug_id, 'status' );\n\tif( $t_status < config_get( 'bug_readonly_status_threshold' ) ) {\n\t\treturn false;\n\t}\n\n\tif( access_has_bug_level( config_get( 'update_readonly_bug_threshold' ), $p_bug_id ) ) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n/**\n * Check if a given bug is resolved\n * @param int p_bug_id integer representing bug id\n * @return bool true if bug is resolved, false otherwise\n * @access public\n * @uses config_api.php\n */\nfunction bug_is_resolved( $p_bug_id ) {\n\t$t_status = bug_get_field( $p_bug_id, 'status' );\n\treturn( $t_status >= config_get( 'bug_resolved_status_threshold' ) );\n}\n\n/**\n * Check if a given bug is overdue\n * @param int p_bug_id integer representing bug id\n * @return bool true if bug is overdue, false otherwise\n * @access public\n * @uses database_api.php\n */\nfunction bug_is_overdue( $p_bug_id ) {\n\t$t_due_date = bug_get_field( $p_bug_id, 'due_date' );\n\tif( !date_is_null( $t_due_date ) ) {\n\t\t$t_now = db_now();\n\t\tif( $t_now > $t_due_date ) {\n\t\t\tif( !bug_is_resolved( $p_bug_id ) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\n/**\n * Validate workflow state to see if bug can be moved to requested state\n * @param int p_bug_status current bug status\n * @param int p_wanted_status new bug status\n * @return bool\n * @access public\n * @uses config_api.php\n * @uses utility_api.php\n */\nfunction bug_check_workflow( $p_bug_status, $p_wanted_status ) {\n\t$t_status_enum_workflow = config_get( 'status_enum_workflow' );\n\n\tif( count( $t_status_enum_workflow ) < 1 ) {\n\n\t\t# workflow not defined, use default enum\n\t\treturn true;\n\t}\n\n\tif ( $p_bug_status == $p_wanted_status ) {\n\t\t# no change in state, allow the transition\n\t\treturn true;\n\t}\n\n\t# workflow defined - find allowed states\n\t$t_allowed_states = $t_status_enum_workflow[$p_bug_status];\n\n\treturn MantisEnum::hasValue( $t_allowed_states, $p_wanted_status );\n}\n\n/**\n * Copy a bug from one project to another. Also make copies of issue notes, attachments, history,\n * email notifications etc.\n * @todo Not managed FTP file upload\n * @param array p_bug_id integer representing bug id\n * @param int p_target_project_id\n * @param bool p_copy_custom_fields\n * @param bool p_copy_relationships\n * @param bool p_copy_history\n * @param bool p_copy_attachments\n * @param bool p_copy_bugnotes\n * @param bool p_copy_monitoring_users\n * @return int representing the new bugid\n * @access public\n */\nfunction bug_copy( $p_bug_id, $p_target_project_id = null, $p_copy_custom_fields = false, $p_copy_relationships = false, $p_copy_history = false, $p_copy_attachments = false, $p_copy_bugnotes = false, $p_copy_monitoring_users = false ) {\n\tglobal $g_db;\n\n\t$t_mantis_custom_field_string_table = db_get_table( 'custom_field_string' );\n\t$t_mantis_bug_file_table = db_get_table( 'bug_file' );\n\t$t_mantis_bugnote_table = db_get_table( 'bugnote' );\n\t$t_mantis_bugnote_text_table = db_get_table( 'bugnote_text' );\n\t$t_mantis_bug_history_table = db_get_table( 'bug_history' );\n\t$t_mantis_db = $g_db;\n\n\t$t_bug_id = db_prepare_int( $p_bug_id );\n\t$t_target_project_id = db_prepare_int( $p_target_project_id );\n\n\t$t_bug_data = bug_get( $t_bug_id, true );\n\n\t# retrieve the project id associated with the bug\n\tif(( $p_target_project_id == null ) || is_blank( $p_target_project_id ) ) {\n\t\t$t_target_project_id = $t_bug_data->project_id;\n\t}\n\n\t$t_bug_data->project_id = $t_target_project_id;\n\n\t$t_new_bug_id = $t_bug_data->create();\n\n\t# MASC ATTENTION: IF THE SOURCE BUG HAS TO HANDLER THE bug_create FUNCTION CAN TRY TO AUTO-ASSIGN THE BUG\n\t# WE FORCE HERE TO DUPLICATE THE SAME HANDLER OF THE SOURCE BUG\n\t# @todo VB: Shouldn't we check if the handler in the source project is also a handler in the destination project?\n\tbug_set_field( $t_new_bug_id, 'handler_id', $t_bug_data->handler_id );\n\n\tbug_set_field( $t_new_bug_id, 'duplicate_id', $t_bug_data->duplicate_id );\n\tbug_set_field( $t_new_bug_id, 'status', $t_bug_data->status );\n\tbug_set_field( $t_new_bug_id, 'resolution', $t_bug_data->resolution );\n\tbug_set_field( $t_new_bug_id, 'projection', $t_bug_data->projection );\n\tbug_set_field( $t_new_bug_id, 'date_submitted', $t_bug_data->date_submitted );\n\tbug_set_field( $t_new_bug_id, 'last_updated', $t_bug_data->last_updated );\n\tbug_set_field( $t_new_bug_id, 'eta', $t_bug_data->eta );\n\tbug_set_field( $t_new_bug_id, 'fixed_in_version', $t_bug_data->fixed_in_version );\n\tbug_set_field( $t_new_bug_id, 'target_version', $t_bug_data->target_version );\n\tbug_set_field( $t_new_bug_id, 'sponsorship_total', 0 );\n\tbug_set_field( $t_new_bug_id, 'sticky', 0 );\n\tbug_set_field( $t_new_bug_id, 'due_date', $t_bug_data->due_date );\n\n\t# COPY CUSTOM FIELDS\n\tif( $p_copy_custom_fields ) {\n\t\t$query = \"SELECT field_id, bug_id, value\n\t\t\t\t\t   FROM $t_mantis_custom_field_string_table\n\t\t\t\t\t   WHERE bug_id=\" . db_param();\n\t\t$result = db_query_bound( $query, Array( $t_bug_id ) );\n\t\t$t_count = db_num_rows( $result );\n\n\t\tfor( $i = 0;$i < $t_count;$i++ ) {\n\t\t\t$t_bug_custom = db_fetch_array( $result );\n\n\t\t\t$c_field_id = db_prepare_int( $t_bug_custom['field_id'] );\n\t\t\t$c_new_bug_id = db_prepare_int( $t_new_bug_id );\n\t\t\t$c_value = $t_bug_custom['value'];\n\n\t\t\t$query = \"INSERT INTO $t_mantis_custom_field_string_table\n\t\t\t\t\t\t   ( field_id, bug_id, value )\n\t\t\t\t\t\t   VALUES (\" . db_param() . ', ' . db_param() . ', ' . db_param() . ')';\n\t\t\tdb_query_bound( $query, Array( $c_field_id, $c_new_bug_id, $c_value ) );\n\t\t}\n\t}\n\n\t# Copy Relationships\n\tif( $p_copy_relationships ) {\n\t\trelationship_copy_all( $t_bug_id, $t_new_bug_id );\n\t}\n\n\t# Copy bugnotes\n\tif( $p_copy_bugnotes ) {\n\t\t$query = \"SELECT *\n\t\t\t\t\t  FROM $t_mantis_bugnote_table\n\t\t\t\t\t  WHERE bug_id=\" . db_param();\n\t\t$result = db_query_bound( $query, Array( $t_bug_id ) );\n\t\t$t_count = db_num_rows( $result );\n\n\t\tfor( $i = 0;$i < $t_count;$i++ ) {\n\t\t\t$t_bug_note = db_fetch_array( $result );\n\t\t\t$t_bugnote_text_id = $t_bug_note['bugnote_text_id'];\n\n\t\t\t$query2 = \"SELECT *\n\t\t\t\t\t\t   FROM $t_mantis_bugnote_text_table\n\t\t\t\t\t\t   WHERE id=\" . db_param();\n\t\t\t$result2 = db_query_bound( $query2, Array( $t_bugnote_text_id ) );\n\t\t\t$t_count2 = db_num_rows( $result2 );\n\n\t\t\t$t_bugnote_text_insert_id = -1;\n\t\t\tif( $t_count2 > 0 ) {\n\t\t\t\t$t_bugnote_text = db_fetch_array( $result2 );\n\n\t\t\t\t$query2 = \"INSERT INTO $t_mantis_bugnote_text_table\n\t\t\t\t\t\t\t   ( note )\n\t\t\t\t\t\t\t   VALUES ( \" . db_param() . ' )';\n\t\t\t\tdb_query_bound( $query2, Array( $t_bugnote_text['note'] ) );\n\t\t\t\t$t_bugnote_text_insert_id = db_insert_id( $t_mantis_bugnote_text_table );\n\t\t\t}\n\n\t\t\t$query2 = \"INSERT INTO $t_mantis_bugnote_table\n\t\t\t\t\t\t   ( bug_id, reporter_id, bugnote_text_id, view_state, date_submitted, last_modified )\n\t\t\t\t\t\t   VALUES ( \" . db_param() . \",\n\t\t\t\t\t\t   \t\t\t\" . db_param() . \",\n\t\t\t\t\t\t   \t\t\t\" . db_param() . \",\n\t\t\t\t\t\t   \t\t\t\" . db_param() . \",\n\t\t\t\t\t\t   \t\t\t\" . db_param() . \",\n\t\t\t\t\t\t   \t\t\t\" . db_param() . ')';\n\t\t\tdb_query_bound( $query2, Array( $t_new_bug_id, $t_bug_note['reporter_id'], $t_bugnote_text_insert_id, $t_bug_note['view_state'], $t_bug_note['date_submitted'], $t_bug_note['last_modified'] ) );\n\t\t}\n\t}\n\n\t# Copy attachments\n\tif( $p_copy_attachments ) {\n\t    file_copy_attachments( $t_bug_id , $t_new_bug_id );\n\t}\n\n\t# Copy users monitoring bug\n\tif( $p_copy_monitoring_users ) {\n\t\tbug_monitor_copy( $t_bug_id, $t_new_bug_id );\n\t}\n\n\t# COPY HISTORY\n\thistory_delete( $t_new_bug_id );\t# should history only be deleted inside the if statement below?\n\tif( $p_copy_history ) {\n\t\t$query = \"SELECT *\n\t\t\t\t\t  FROM $t_mantis_bug_history_table\n\t\t\t\t\t  WHERE bug_id = \" . db_param();\n\t\t$result = db_query_bound( $query, Array( $t_bug_id ) );\n\t\t$t_count = db_num_rows( $result );\n\n\t\tfor( $i = 0;$i < $t_count;$i++ ) {\n\t\t\t$t_bug_history = db_fetch_array( $result );\n\t\t\t$query = \"INSERT INTO $t_mantis_bug_history_table\n\t\t\t\t\t\t  ( user_id, bug_id, date_modified, field_name, old_value, new_value, type )\n\t\t\t\t\t\t  VALUES ( \" . db_param() . \",\n\t\t\t\t\t\t  \t\t   \" . db_param() . \",\n\t\t\t\t\t\t  \t\t   \" . db_param() . \",\n\t\t\t\t\t\t  \t\t   \" . db_param() . \",\n\t\t\t\t\t\t  \t\t   \" . db_param() . \",\n\t\t\t\t\t\t  \t\t   \" . db_param() . \",\n\t\t\t\t\t\t  \t\t   \" . db_param() . \" );\";\n\t\t\tdb_query_bound( $query, Array( $t_bug_history['user_id'], $t_new_bug_id, $t_bug_history['date_modified'], $t_bug_history['field_name'], $t_bug_history['old_value'], $t_bug_history['new_value'], $t_bug_history['type'] ) );\n\t\t}\n\t}\n\n\t# Create history entries to reflect the copy operation\n\thistory_log_event_special( $t_new_bug_id, BUG_CREATED_FROM, '', $t_bug_id );\n\thistory_log_event_special( $t_bug_id, BUG_CLONED_TO, '', $t_new_bug_id );\n\n\treturn $t_new_bug_id;\n}\n\n/**\n * Moves an issue from a project to another.\n *\n * @todo Validate with sub-project / category inheritance scenarios.\n * @param int p_bug_id The bug to be moved.\n * @param int p_target_project_id The target project to move the bug to.\n * @access public\n */\nfunction bug_move( $p_bug_id, $p_target_project_id ) {\n\t// Attempt to move disk based attachments to new project file directory.\n\tfile_move_bug_attachments( $p_bug_id, $p_target_project_id );\n\n\t// Move the issue to the new project.\n\tbug_set_field( $p_bug_id, 'project_id', $p_target_project_id );\n\n\t// Update the category if needed\n\t$t_category_id = bug_get_field( $p_bug_id, 'category_id' );\n\n\t// Bug has no category\n\tif( $t_category_id == 0 ) {\n\t\t// Category is required in target project, set it to default\n\t\tif( ON != config_get( 'allow_no_category', null, null, $p_target_project_id ) ) {\n\t\t\tbug_set_field( $p_bug_id, 'category_id', config_get( 'default_category_for_moves' ) );\n\t\t}\n\t}\n\t// Check if the category is global, and if not attempt mapping it to the new project\n\telse {\n\t\t$t_category_project_id = category_get_field( $t_category_id, 'project_id' );\n\n\t\tif ( $t_category_project_id != ALL_PROJECTS\n\t\t  && !project_hierarchy_inherit_parent( $p_target_project_id, $t_category_project_id )\n\t\t) {\n\t\t\t// Map by name\n\t\t\t$t_category_name = category_get_field( $t_category_id, 'name' );\n\t\t\t$t_target_project_category_id = category_get_id_by_name( $t_category_name, $p_target_project_id, /* triggerErrors */ false );\n\t\t\tif ( $t_target_project_category_id === false ) {\n\t\t\t\t// Use default category after moves, since there is no match by name.\n\t\t\t\t$t_target_project_category_id = config_get( 'default_category_for_moves' );\n\t\t\t}\n\t\t\tbug_set_field( $p_bug_id, 'category_id', $t_target_project_category_id );\n\t\t}\n\t}\n}\n\n/**\n * allows bug deletion :\n * delete the bug, bugtext, bugnote, and bugtexts selected\n * @param array p_bug_id integer representing bug id\n * @return bool (always true)\n * @access public\n */\nfunction bug_delete( $p_bug_id ) {\n\t$c_bug_id = (int) $p_bug_id;\n\t$t_bug_table = db_get_table( 'bug' );\n\t$t_bug_text_table = db_get_table( 'bug_text' );\n\n\t# call pre-deletion custom function\n\thelper_call_custom_function( 'issue_delete_validate', array( $p_bug_id ) );\n\n\t# log deletion of bug\n\thistory_log_event_special( $p_bug_id, BUG_DELETED, bug_format_id( $p_bug_id ) );\n\n\temail_bug_deleted( $p_bug_id );\n\n\t# call post-deletion custom function.  We call this here to allow the custom function to access the details of the bug before\n\t# they are deleted from the database given it's id.  The other option would be to move this to the end of the function and\n\t# provide it with bug data rather than an id, but this will break backward compatibility.\n\thelper_call_custom_function( 'issue_delete_notify', array( $p_bug_id ) );\n\n\t# Unmonitor bug for all users\n\tbug_unmonitor( $p_bug_id, null );\n\n\t# Delete custom fields\n\tcustom_field_delete_all_values( $p_bug_id );\n\n\t# Delete bugnotes\n\tbugnote_delete_all( $p_bug_id );\n\n\t# Delete all sponsorships\n\tsponsorship_delete_all( $p_bug_id );\n\n\t# MASC RELATIONSHIP\n\t# we delete relationships even if the feature is currently off.\n\trelationship_delete_all( $p_bug_id );\n\n\t# MASC RELATIONSHIP\n\t# Delete files\n\tfile_delete_attachments( $p_bug_id );\n\n\t# Detach tags\n\ttag_bug_detach_all( $p_bug_id, false );\n\n\t# Delete the bug history\n\thistory_delete( $p_bug_id );\n\n\t# Delete bug info revisions\n\tbug_revision_delete( $p_bug_id );\n\n\t# Delete the bugnote text\n\t$t_bug_text_id = bug_get_field( $p_bug_id, 'bug_text_id' );\n\n\t$query = \"DELETE FROM $t_bug_text_table\n\t\t\t\t  WHERE id=\" . db_param();\n\tdb_query_bound( $query, Array( $t_bug_text_id ) );\n\n\t# Delete the bug entry\n\t$query = \"DELETE FROM $t_bug_table\n\t\t\t\t  WHERE id=\" . db_param();\n\tdb_query_bound( $query, Array( $c_bug_id ) );\n\n\tbug_clear_cache( $p_bug_id );\n\tbug_text_clear_cache( $p_bug_id );\n\n\t# db_query errors on failure so:\n\treturn true;\n}\n\n/**\n * Delete all bugs associated with a project\n * @param array p_project_id integer representing a projectid\n * @return bool always true\n * @access public\n * @uses database_api.php\n */\nfunction bug_delete_all( $p_project_id ) {\n\t$c_project_id = (int) $p_project_id;\n\n\t$t_bug_table = db_get_table( 'bug' );\n\n\t$query = \"SELECT id\n\t\t\t\t  FROM $t_bug_table\n\t\t\t\t  WHERE project_id=\" . db_param();\n\t$result = db_query_bound( $query, array( $c_project_id ) );\n\n\t$bug_count = db_num_rows( $result );\n\n\tfor( $i = 0;$i < $bug_count;$i++ ) {\n\t\t$row = db_fetch_array( $result );\n\n\t\tbug_delete( $row['id'] );\n\t}\n\n\t# @todo should we check the return value of each bug_delete() and\n\t#  return false if any of them return false? Presumable bug_delete()\n\t#  will eventually trigger an error on failure so it won't matter...\n\n\treturn true;\n}\n\n/**\n * Returns the extended record of the specified bug, this includes\n * the bug text fields\n * @todo include reporter name and handler name, the problem is that\n *      handler can be 0, in this case no corresponding name will be\n *      found.  Use equivalent of (+) in Oracle.\n * @param int p_bug_id integer representing bug id\n * @return array\n * @access public\n */\nfunction bug_get_extended_row( $p_bug_id ) {\n\t$t_base = bug_cache_row( $p_bug_id );\n\t$t_text = bug_text_cache_row( $p_bug_id );\n\n\t# merge $t_text first so that the 'id' key has the bug id not the bug text id\n\treturn array_merge( $t_text, $t_base );\n}\n\n/**\n * Returns the record of the specified bug\n * @param int p_bug_id integer representing bug id\n * @return array\n * @access public\n */\nfunction bug_get_row( $p_bug_id ) {\n\treturn bug_cache_row( $p_bug_id );\n}\n\n/**\n * Returns an object representing the specified bug\n * @param int p_bug_id integer representing bug id\n * @param bool p_get_extended included extended information (including bug_text)\n * @return object BugData Object\n * @access public\n */\nfunction bug_get( $p_bug_id, $p_get_extended = false ) {\n\tif( $p_get_extended ) {\n\t\t$row = bug_get_extended_row( $p_bug_id );\n\t} else {\n\t\t$row = bug_get_row( $p_bug_id );\n\t}\n\n\t$t_bug_data = new BugData;\n\t$t_bug_data->loadrow( $row );\n\treturn $t_bug_data;\n}\n\nfunction bug_row_to_object( $p_row ) {\n\t$t_bug_data = new BugData;\n\t$t_bug_data->loadrow( $p_row );\n\treturn $t_bug_data;\n}\n\n/**\n * return the specified field of the given bug\n *  if the field does not exist, display a warning and return ''\n * @param int p_bug_id integer representing bug id\n * @param string p_fieldname field name\n * @return string\n * @access public\n */\nfunction bug_get_field( $p_bug_id, $p_field_name ) {\n\t$row = bug_get_row( $p_bug_id );\n\n\tif( isset( $row[$p_field_name] ) ) {\n\t\treturn $row[$p_field_name];\n\t} else {\n\t\terror_parameters( $p_field_name );\n\t\ttrigger_error( ERROR_DB_FIELD_NOT_FOUND, WARNING );\n\t\treturn '';\n\t}\n}\n\n/**\n * return the specified text field of the given bug\n *  if the field does not exist, display a warning and return ''\n * @param int p_bug_id integer representing bug id\n * @param string p_fieldname field name\n * @return string\n * @access public\n */\nfunction bug_get_text_field( $p_bug_id, $p_field_name ) {\n\t$row = bug_text_cache_row( $p_bug_id );\n\n\tif( isset( $row[$p_field_name] ) ) {\n\t\treturn $row[$p_field_name];\n\t} else {\n\t\terror_parameters( $p_field_name );\n\t\ttrigger_error( ERROR_DB_FIELD_NOT_FOUND, WARNING );\n\t\treturn '';\n\t}\n}\n\n/**\n * return the bug summary\n *  this is a wrapper for the custom function\n * @param int p_bug_id integer representing bug id\n * @param int p_context representing SUMMARY_CAPTION, SUMMARY_FIELD\n * @return string\n * @access public\n * @uses helper_api.php\n */\nfunction bug_format_summary( $p_bug_id, $p_context ) {\n\treturn helper_call_custom_function( 'format_issue_summary', array( $p_bug_id, $p_context ) );\n}\n\n/**\n * return the timestamp for the most recent time at which a bugnote\n *  associated with the bug was modified\n * @param int p_bug_id integer representing bug id\n * @return bool|int false or timestamp in integer format representing newest bugnote timestamp\n * @access public\n * @uses database_api.php\n */\nfunction bug_get_newest_bugnote_timestamp( $p_bug_id ) {\n\t$c_bug_id = db_prepare_int( $p_bug_id );\n\t$t_bugnote_table = db_get_table( 'bugnote' );\n\n\t$query = \"SELECT last_modified\n\t\t\t\t  FROM $t_bugnote_table\n\t\t\t\t  WHERE bug_id=\" . db_param() . \"\n\t\t\t\t  ORDER BY last_modified DESC\";\n\t$result = db_query_bound( $query, Array( $c_bug_id ), 1 );\n\t$row = db_result( $result );\n\n\tif( false === $row ) {\n\t\treturn false;\n\t} else {\n\t\treturn $row;\n\t}\n}\n\n/**\n * return the timestamp for the most recent time at which a bugnote\n *  associated with the bug was modified and the total bugnote\n *  count in one db query\n * @param int p_bug_id integer representing bug id\n * @return object consisting of bugnote stats\n * @access public\n * @uses database_api.php\n */\nfunction bug_get_bugnote_stats( $p_bug_id ) {\n\tglobal $g_cache_bug;\n\t$c_bug_id = db_prepare_int( $p_bug_id );\n\n\tif( !is_null( $g_cache_bug[$c_bug_id]['_stats'] ) ) {\n\t\tif( $g_cache_bug[$c_bug_id]['_stats'] === false ) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\t$t_stats = $g_cache_bug[$c_bug_id]['_stats'];\n\t\t}\n\t\treturn $t_stats;\n\t}\n\n\t$t_bugnote_table = db_get_table( 'bugnote' );\n\n\t$query = \"SELECT last_modified\n\t\t\t\t  FROM $t_bugnote_table\n\t\t\t\t  WHERE bug_id=\" . db_param() . \"\n\t\t\t\t  ORDER BY last_modified DESC\";\n\t$result = db_query_bound( $query, Array( $c_bug_id ) );\n\t$row = db_fetch_array( $result );\n\n\tif( false === $row ) {\n\t\treturn false;\n\t}\n\n\t$t_stats['last_modified'] = $row['last_modified'];\n\t$t_stats['count'] = db_num_rows( $result );\n\n\treturn $t_stats;\n}\n\n/**\n * Get array of attachments associated with the specified bug id.  The array will be\n * sorted in terms of date added (ASC).  The array will include the following fields:\n * id, title, diskfile, filename, filesize, file_type, date_added, user_id.\n * @param int p_bug_id integer representing bug id\n * @return array array of results or null\n * @access public\n * @uses database_api.php\n * @uses file_api.php\n */\nfunction bug_get_attachments( $p_bug_id ) {\n\t$c_bug_id = db_prepare_int( $p_bug_id );\n\n\t$t_bug_file_table = db_get_table( 'bug_file' );\n\n\t$query = \"SELECT id, title, diskfile, filename, filesize, file_type, date_added, user_id\n\t\t                FROM $t_bug_file_table\n\t\t                WHERE bug_id=\" . db_param() . \"\n\t\t                ORDER BY date_added\";\n\t$db_result = db_query_bound( $query, Array( $c_bug_id ) );\n\t$num_files = db_num_rows( $db_result );\n\n\t$t_result = array();\n\n\tfor( $i = 0;$i < $num_files;$i++ ) {\n\t\t$t_result[] = db_fetch_array( $db_result );\n\t}\n\n\treturn $t_result;\n}\n\n# ===================================\n# Data Modification\n# ===================================\n/**\n * Set the value of a bug field\n * @param int p_bug_id integer representing bug id\n * @param string p_field_name pre-defined field name\n * @param any p_value value to set\n * @return bool (always true)\n * @access public\n * @uses database_api.php\n * @uses history_api.php\n */\nfunction bug_set_field( $p_bug_id, $p_field_name, $p_value ) {\n\t$c_bug_id = db_prepare_int( $p_bug_id );\n\t$c_value = null;\n\n\tswitch( $p_field_name ) {\n\n\t\t# bool\n\t\tcase 'sticky':\n\t\t\t$c_value = $p_value;\n\t\t\tbreak;\n\n\t\t# int\n\t\tcase 'project_id':\n\t\tcase 'reporter_id':\n\t\tcase 'handler_id':\n\t\tcase 'duplicate_id':\n\t\tcase 'priority':\n\t\tcase 'severity':\n\t\tcase 'reproducibility':\n\t\tcase 'status':\n\t\tcase 'resolution':\n\t\tcase 'projection':\n\t\tcase 'category_id':\n\t\tcase 'eta':\n\t\tcase 'view_state':\n\t\tcase 'profile_id':\n\t\tcase 'sponsorship_total':\n\t\t\t$c_value = (int) $p_value;\n\t\t\tbreak;\n\n\t\t# string\n\t\tcase 'os':\n\t\tcase 'os_build':\n\t\tcase 'platform':\n\t\tcase 'version':\n\t\tcase 'fixed_in_version':\n\t\tcase 'target_version':\n\t\tcase 'build':\n\t\tcase 'summary':\n\t\t\t$c_value = $p_value;\n\t\t\tbreak;\n\n\t\t# dates\n\t\tcase 'last_updated':\n\t\tcase 'date_submitted':\n\t\tcase 'due_date':\n\t\t\tif ( !is_numeric( $p_value ) ) {\n\t\t\t\ttrigger_error( ERROR_GENERIC, ERROR );\n\t\t\t}\n\t\t\t$c_value = $p_value;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\ttrigger_error( ERROR_DB_FIELD_NOT_FOUND, WARNING );\n\t\t\tbreak;\n\t}\n\n\t$t_current_value = bug_get_field( $p_bug_id, $p_field_name );\n\n\t# return if status is already set\n\tif( $c_value == $t_current_value ) {\n\t\treturn true;\n\t}\n\t$t_bug_table = db_get_table( 'bug' );\n\n\t# Update fields\n\t$query = \"UPDATE $t_bug_table\n\t\t\t\t  SET $p_field_name=\" . db_param() . \"\n\t\t\t\t  WHERE id=\" . db_param();\n\tdb_query_bound( $query, Array( $c_value, $c_bug_id ) );\n\n\t# updated the last_updated date\n\tbug_update_date( $p_bug_id );\n\n\t# log changes except for duplicate_id which is obsolete and should be removed in\n\t# MantisBT 1.3.\n\tswitch( $p_field_name ) {\n\t\tcase 'duplicate_id':\n\t\t\tbreak;\n\n\t\tcase 'category_id':\n\t\t\thistory_log_event_direct( $p_bug_id, 'category', category_full_name( $t_current_value, false ), category_full_name( $c_value, false ) );\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\thistory_log_event_direct( $p_bug_id, $p_field_name, $t_current_value, $c_value );\n\t}\n\n\tbug_clear_cache( $p_bug_id );\n\n\treturn true;\n}\n\n/**\n * assign the bug to the given user\n * @param array p_bug_id_array integer array representing bug ids to cache\n * @return null\n * @access public\n * @uses database_api.php\n */\nfunction bug_assign( $p_bug_id, $p_user_id, $p_bugnote_text = '', $p_bugnote_private = false ) {\n\t$c_bug_id = db_prepare_int( $p_bug_id );\n\t$c_user_id = db_prepare_int( $p_user_id );\n\n\tif(( $c_user_id != NO_USER ) && !access_has_bug_level( config_get( 'handle_bug_threshold' ), $p_bug_id, $p_user_id ) ) {\n\t\ttrigger_error( ERROR_USER_DOES_NOT_HAVE_REQ_ACCESS );\n\t}\n\n\t# extract current information into history variables\n\t$h_status = bug_get_field( $p_bug_id, 'status' );\n\t$h_handler_id = bug_get_field( $p_bug_id, 'handler_id' );\n\n\tif(( ON == config_get( 'auto_set_status_to_assigned' ) ) && ( NO_USER != $p_user_id ) ) {\n\t\t$t_ass_val = config_get( 'bug_assigned_status' );\n\t} else {\n\t\t$t_ass_val = $h_status;\n\t}\n\n\t$t_bug_table = db_get_table( 'bug' );\n\n\tif(( $t_ass_val != $h_status ) || ( $p_user_id != $h_handler_id ) ) {\n\n\t\t# get user id\n\t\t$query = \"UPDATE $t_bug_table\n\t\t\t\t\t  SET handler_id=\" . db_param() . \", status=\" . db_param() . \"\n\t\t\t\t\t  WHERE id=\" . db_param();\n\t\tdb_query_bound( $query, Array( $c_user_id, $t_ass_val, $c_bug_id ) );\n\n\t\t# log changes\n\t\thistory_log_event_direct( $c_bug_id, 'status', $h_status, $t_ass_val );\n\t\thistory_log_event_direct( $c_bug_id, 'handler_id', $h_handler_id, $p_user_id );\n\n\t\t# Add bugnote if supplied ignore false return\n\t\tbugnote_add( $p_bug_id, $p_bugnote_text, 0, $p_bugnote_private, 0, '', NULL, FALSE );\n\n\t\t# updated the last_updated date\n\t\tbug_update_date( $p_bug_id );\n\n\t\tbug_clear_cache( $p_bug_id );\n\n\t\t# send assigned to email\n\t\temail_assign( $p_bug_id );\n\t}\n\n\treturn true;\n}\n\n/**\n * close the given bug\n * @param int p_bug_id\n * @param string p_bugnote_text\n * @param bool p_bugnote_private\n * @param string p_time_tracking\n * @return bool (always true)\n * @access public\n */\nfunction bug_close( $p_bug_id, $p_bugnote_text = '', $p_bugnote_private = false, $p_time_tracking = '0:00' ) {\n\t$p_bugnote_text = trim( $p_bugnote_text );\n\n\t# Add bugnote if supplied ignore a false return\n\t# Moved bugnote_add before bug_set_field calls in case time_tracking_no_note is off.\n\t# Error condition stopped execution but status had already been changed\n\tbugnote_add( $p_bug_id, $p_bugnote_text, $p_time_tracking, $p_bugnote_private, 0, '', NULL, FALSE );\n\n\tbug_set_field( $p_bug_id, 'status', config_get( 'bug_closed_status_threshold' ) );\n\n\temail_close( $p_bug_id );\n\temail_relationship_child_closed( $p_bug_id );\n\n\treturn true;\n}\n\n/**\n * resolve the given bug\n * @return bool (alawys true)\n * @access public\n */\nfunction bug_resolve( $p_bug_id, $p_resolution, $p_fixed_in_version = '', $p_bugnote_text = '', $p_duplicate_id = null, $p_handler_id = null, $p_bugnote_private = false, $p_time_tracking = '0:00' ) {\n\t$c_resolution = (int) $p_resolution;\n\t$p_bugnote_text = trim( $p_bugnote_text );\n\n\t# Add bugnote if supplied\n\t# Moved bugnote_add before bug_set_field calls in case time_tracking_no_note is off.\n\t# Error condition stopped execution but status had already been changed\n\tbugnote_add( $p_bug_id, $p_bugnote_text, $p_time_tracking, $p_bugnote_private, 0, '', NULL, FALSE );\n\n\t$t_duplicate = !is_blank( $p_duplicate_id ) && ( $p_duplicate_id != 0 );\n\tif( $t_duplicate ) {\n\t\tif( $p_bug_id == $p_duplicate_id ) {\n\t\t\ttrigger_error( ERROR_BUG_DUPLICATE_SELF, ERROR );\n\n\t\t\t# never returns\n\t\t}\n\n\t\t# the related bug exists...\n\t\tbug_ensure_exists( $p_duplicate_id );\n\n\t\t# check if there is other relationship between the bugs...\n\t\t$t_id_relationship = relationship_same_type_exists( $p_bug_id, $p_duplicate_id, BUG_DUPLICATE );\n\n\t\t if( $t_id_relationship > 0 ) {\n\t\t\t# Update the relationship\n\t\t\trelationship_update( $t_id_relationship, $p_bug_id, $p_duplicate_id, BUG_DUPLICATE );\n\n\t\t\t# Add log line to the history (both bugs)\n\t\t\thistory_log_event_special( $p_bug_id, BUG_REPLACE_RELATIONSHIP, BUG_DUPLICATE, $p_duplicate_id );\n\t\t\thistory_log_event_special( $p_duplicate_id, BUG_REPLACE_RELATIONSHIP, BUG_HAS_DUPLICATE, $p_bug_id );\n\t\t} else if ( $t_id_relationship != -1 ) {\n\t\t\t# Add the new relationship\n\t\t\trelationship_add( $p_bug_id, $p_duplicate_id, BUG_DUPLICATE );\n\n\t\t\t# Add log line to the history (both bugs)\n\t\t\thistory_log_event_special( $p_bug_id, BUG_ADD_RELATIONSHIP, BUG_DUPLICATE, $p_duplicate_id );\n\t\t\thistory_log_event_special( $p_duplicate_id, BUG_ADD_RELATIONSHIP, BUG_HAS_DUPLICATE, $p_bug_id );\n\t\t} # else relationship is -1 - same type exists, do nothing\n\n\t\t# Copy list of users monitoring the duplicate bug to the original bug\n\t\t$t_old_reporter_id = bug_get_field( $p_bug_id, 'reporter_id' );\n\t\t$t_old_handler_id = bug_get_field( $p_bug_id, 'handler_id' );\n\t\tif ( user_exists( $t_old_reporter_id ) ) {\n\t\t\tbug_monitor( $p_duplicate_id, $t_old_reporter_id );\n\t\t}\n\t\tif ( user_exists ( $t_old_handler_id ) ) {\n\t\t\tbug_monitor( $p_duplicate_id, $t_old_handler_id );\n\t\t}\n\t\tbug_monitor_copy( $p_bug_id, $p_duplicate_id );\n\n\t\tbug_set_field( $p_bug_id, 'duplicate_id', (int) $p_duplicate_id );\n\t}\n\n\tbug_set_field( $p_bug_id, 'status', config_get( 'bug_resolved_status_threshold' ) );\n\tbug_set_field( $p_bug_id, 'fixed_in_version', $p_fixed_in_version );\n\tbug_set_field( $p_bug_id, 'resolution', $c_resolution );\n\n\t# only set handler if specified explicitly or if bug was not assigned to a handler\n\tif( null == $p_handler_id ) {\n\t\tif( bug_get_field( $p_bug_id, 'handler_id' ) == 0 ) {\n\t\t\t$p_handler_id = auth_get_current_user_id();\n\t\t\tbug_set_field( $p_bug_id, 'handler_id', $p_handler_id );\n\t\t}\n\t} else {\n\t\tbug_set_field( $p_bug_id, 'handler_id', $p_handler_id );\n\t}\n\n\temail_resolved( $p_bug_id );\n\temail_relationship_child_resolved( $p_bug_id );\n\n\tif( $c_resolution >= config_get( 'bug_resolution_fixed_threshold' ) &&\n\t\t$c_resolution < config_get( 'bug_resolution_not_fixed_threshold' ) ) {\n\t\ttwitter_issue_resolved( $p_bug_id );\n\t}\n\n\treturn true;\n}\n\n/**\n * reopen the given bug\n * @param int p_bug_id\n * @param string p_bugnote_text\n * @param string p_time_tracking\n * @param bool p_bugnote_private\n * @return bool (always true)\n * @access public\n * @uses database_api.php\n * @uses email_api.php\n * @uses bugnote_api.php\n * @uses config_api.php\n */\nfunction bug_reopen( $p_bug_id, $p_bugnote_text = '', $p_time_tracking = '0:00', $p_bugnote_private = false ) {\n\t$p_bugnote_text = trim( $p_bugnote_text );\n\n\t# Add bugnote if supplied\n\t# Moved bugnote_add before bug_set_field calls in case time_tracking_no_note is off.\n\t# Error condition stopped execution but status had already been changed\n\tbugnote_add( $p_bug_id, $p_bugnote_text, $p_time_tracking, $p_bugnote_private, 0, '', NULL, FALSE );\n\n\tbug_set_field( $p_bug_id, 'status', config_get( 'bug_reopen_status' ) );\n\tbug_set_field( $p_bug_id, 'resolution', config_get( 'bug_reopen_resolution' ) );\n\n\temail_reopen( $p_bug_id );\n\n\treturn true;\n}\n\n/**\n * updates the last_updated field\n * @param int p_bug_id integer representing bug ids\n * @return bool (always true)\n * @access public\n * @uses database_api.php\n */\nfunction bug_update_date( $p_bug_id ) {\n\t$c_bug_id = (int) $p_bug_id;\n\n\t$t_bug_table = db_get_table( 'bug' );\n\n\t$query = \"UPDATE $t_bug_table\n\t\t\t\t  SET last_updated= \" . db_param() . \"\n\t\t\t\t  WHERE id=\" . db_param();\n\tdb_query_bound( $query, Array( db_now(), $c_bug_id ) );\n\n\tbug_clear_cache( $c_bug_id );\n\n\treturn true;\n}\n\n/**\n * enable monitoring of this bug for the user\n * @param int p_bug_id integer representing bug ids\n * @param int p_user_id integer representing user ids\n * @return true if successful, false if unsuccessful\n * @access public\n * @uses database_api.php\n * @uses history_api.php\n * @uses user_api.php\n */\nfunction bug_monitor( $p_bug_id, $p_user_id ) {\n\t$c_bug_id = (int) $p_bug_id;\n\t$c_user_id = (int) $p_user_id;\n\n\t# Make sure we aren't already monitoring this bug\n\tif( user_is_monitoring_bug( $c_user_id, $c_bug_id ) ) {\n\t\treturn true;\n\t}\n\n\t# Don't let the anonymous user monitor bugs\n\tif ( user_is_anonymous( $c_user_id ) ) {\n\t\treturn false;\n\t}\n\n\t$t_bug_monitor_table = db_get_table( 'bug_monitor' );\n\n\t# Insert monitoring record\n\t$query = 'INSERT INTO ' . $t_bug_monitor_table . '( user_id, bug_id ) VALUES (' . db_param() . ',' . db_param() . ')';\n\tdb_query_bound( $query, Array( $c_user_id, $c_bug_id ) );\n\n\t# log new monitoring action\n\thistory_log_event_special( $c_bug_id, BUG_MONITOR, $c_user_id );\n\n\t# updated the last_updated date\n\tbug_update_date( $p_bug_id );\n\n\temail_monitor_added( $p_bug_id, $p_user_id );\n\n\treturn true;\n}\n\n/**\n * Returns the list of users monitoring the specified bug\n *\n * @param int $p_bug_id\n */\nfunction bug_get_monitors( $p_bug_id ) {\n\n\tif ( ! access_has_bug_level( config_get( 'show_monitor_list_threshold' ), $p_bug_id ) ) {\n\t\treturn Array();\n\t}\n\n\t$c_bug_id = db_prepare_int( $p_bug_id );\n\t$t_bug_monitor_table = db_get_table( 'bug_monitor' );\n\t$t_user_table = db_get_table( 'user' );\n\n\t# get the bugnote data\n\t$query = \"SELECT user_id, enabled\n\t\t\tFROM $t_bug_monitor_table m, $t_user_table u\n\t\t\tWHERE m.bug_id=\" . db_param() . \" AND m.user_id = u.id\n\t\t\tORDER BY u.realname, u.username\";\n\t$result = db_query_bound($query, Array( $c_bug_id ) );\n\t$num_users = db_num_rows($result);\n\n\t$t_users = array();\n\tfor ( $i = 0; $i < $num_users; $i++ ) {\n\t\t$row = db_fetch_array( $result );\n\t\t$t_users[$i] = $row['user_id'];\n\t}\n\n\tuser_cache_array_rows( $t_users );\n\n\treturn $t_users;\n}\n\n/**\n * Copy list of users monitoring a bug to the monitor list of a second bug\n * @param int p_source_bug_id integer representing the bug ID of the source bug\n * @param int p_dest_bug_id integer representing the bug ID of the destination bug\n * @return bool (always true)\n * @access public\n * @uses database_api.php\n * @uses history_api.php\n * @uses user_api.php\n */\nfunction bug_monitor_copy( $p_source_bug_id, $p_dest_bug_id ) {\n\t$c_source_bug_id = (int)$p_source_bug_id;\n\t$c_dest_bug_id = (int)$p_dest_bug_id;\n\n\t$t_bug_monitor_table = db_get_table( 'bug_monitor' );\n\n\t$query = 'SELECT user_id\n\t\tFROM ' . $t_bug_monitor_table . '\n\t\tWHERE bug_id = ' . db_param();\n\t$result = db_query_bound( $query, Array( $c_source_bug_id ) );\n\t$t_count = db_num_rows( $result );\n\n\tfor( $i = 0; $i < $t_count; $i++ ) {\n\t\t$t_bug_monitor = db_fetch_array( $result );\n\t\tif ( user_exists( $t_bug_monitor['user_id'] ) &&\n\t\t\t!user_is_monitoring_bug( $t_bug_monitor['user_id'], $c_dest_bug_id ) ) {\n\t\t\t$query = 'INSERT INTO ' . $t_bug_monitor_table . ' ( user_id, bug_id )\n\t\t\t\tVALUES ( ' . db_param() . ', ' . db_param() . ' )';\n\t\t\tdb_query_bound( $query, Array( $t_bug_monitor['user_id'], $c_dest_bug_id ) );\n\t\t\thistory_log_event_special( $c_dest_bug_id, BUG_MONITOR, $t_bug_monitor['user_id'] );\n\t\t}\n\t}\n}\n\n/**\n * disable monitoring of this bug for the user\n * if $p_user_id = null, then bug is unmonitored for all users.\n * @param int p_bug_id integer representing bug ids\n * @param int p_user_id integer representing user ids\n * @return bool (always true)\n * @access public\n * @uses database_api.php\n * @uses history_api.php\n */\nfunction bug_unmonitor( $p_bug_id, $p_user_id ) {\n\t$c_bug_id = (int) $p_bug_id;\n\t$c_user_id = (int) $p_user_id;\n\n\t$t_bug_monitor_table = db_get_table( 'bug_monitor' );\n\n\t# Delete monitoring record\n\t$query = 'DELETE FROM ' . $t_bug_monitor_table . ' WHERE bug_id = ' . db_param();\n\t$db_query_params[] = $c_bug_id;\n\n\tif( $p_user_id !== null ) {\n\t\t$query .= \" AND user_id = \" . db_param();\n\t\t$db_query_params[] = $c_user_id;\n\t}\n\n\tdb_query_bound( $query, $db_query_params );\n\n\t# log new un-monitor action\n\thistory_log_event_special( $c_bug_id, BUG_UNMONITOR, $c_user_id );\n\n\t# updated the last_updated date\n\tbug_update_date( $p_bug_id );\n\n\treturn true;\n}\n\n/**\n * Pads the bug id with the appropriate number of zeros.\n * @param int p_bug_id\n * @return string\n * @access public\n * @uses config_api.php\n */\nfunction bug_format_id( $p_bug_id ) {\n\t$t_padding = config_get( 'display_bug_padding' );\n\t$t_string = utf8_str_pad( $p_bug_id, $t_padding, '0', STR_PAD_LEFT );\n\n\treturn event_signal( 'EVENT_DISPLAY_BUG_ID', $t_string, array( $p_bug_id ) );\n}\n", "<?php\n# MantisBT - A PHP based bugtracking system\n\n# MantisBT is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 2 of the License, or\n# (at your option) any later version.\n#\n# MantisBT is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with MantisBT.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * History API\n *\n * @package CoreAPI\n * @subpackage HistoryAPI\n * @copyright Copyright (C) 2000 - 2002  Kenzaburo Ito - kenito@300baud.org\n * @copyright Copyright (C) 2002 - 2012  MantisBT Team - mantisbt-dev@lists.sourceforge.net\n * @link http://www.mantisbt.org\n *\n * @uses access_api.php\n * @uses authentication_api.php\n * @uses bug_api.php\n * @uses bug_revision_api.php\n * @uses bugnote_api.php\n * @uses columns_api.php\n * @uses config_api.php\n * @uses constant_inc.php\n * @uses custom_field_api.php\n * @uses database_api.php\n * @uses gpc_api.php\n * @uses helper_api.php\n * @uses lang_api.php\n * @uses project_api.php\n * @uses relationship_api.php\n * @uses sponsorship_api.php\n * @uses user_api.php\n * @uses utility_api.php\n */\n\nrequire_api( 'access_api.php' );\nrequire_api( 'authentication_api.php' );\nrequire_api( 'bug_api.php' );\nrequire_api( 'bug_revision_api.php' );\nrequire_api( 'bugnote_api.php' );\nrequire_api( 'columns_api.php' );\nrequire_api( 'config_api.php' );\nrequire_api( 'constant_inc.php' );\nrequire_api( 'custom_field_api.php' );\nrequire_api( 'database_api.php' );\nrequire_api( 'gpc_api.php' );\nrequire_api( 'helper_api.php' );\nrequire_api( 'lang_api.php' );\nrequire_api( 'project_api.php' );\nrequire_api( 'relationship_api.php' );\nrequire_api( 'sponsorship_api.php' );\nrequire_api( 'user_api.php' );\nrequire_api( 'utility_api.php' );\n\n/**\n * log the changes (old / new value are supplied to reduce db access)\n * events should be logged *after* the modification\n * @param int $p_bug_id\n * @param string $p_field_name\n * @param string $p_old_value\n * @param string $p_new_value\n * @param int $p_user_id\n * @param int $p_type\n */\nfunction history_log_event_direct( $p_bug_id, $p_field_name, $p_old_value, $p_new_value, $p_user_id = null, $p_type = 0 ) {\n\t# Only log events that change the value\n\tif( $p_new_value != $p_old_value ) {\n\t\tif( null === $p_user_id ) {\n\t\t\t$p_user_id = auth_get_current_user_id();\n\t\t}\n\n\t\t$c_field_name = $p_field_name;\n\t\t$c_old_value = ( is_null( $p_old_value ) ? '' : $p_old_value );\n\t\t$c_new_value = ( is_null( $p_new_value ) ? '' : $p_new_value );\n\t\t$c_bug_id = db_prepare_int( $p_bug_id );\n\t\t$c_user_id = db_prepare_int( $p_user_id );\n\t\t$c_type = db_prepare_int( $p_type );\n\n\t\t$t_mantis_bug_history_table = db_get_table( 'bug_history' );\n\n\t\t$query = \"INSERT INTO $t_mantis_bug_history_table\n\t\t\t\t\t\t( user_id, bug_id, date_modified, field_name, old_value, new_value, type )\n\t\t\t\t\tVALUES\n\t\t\t\t\t\t( \" . db_param() . ', ' . db_param() . ', ' . db_param() . ', ' . db_param() . ', ' . db_param() . ', ' . db_param() . ', ' . db_param() . ' )';\n\t\t$result = db_query_bound( $query, Array( $c_user_id, $c_bug_id, db_now(), $c_field_name, $c_old_value, $c_new_value, $c_type ) );\n\t}\n}\n\n/**\n * log the changes\n * events should be logged *after* the modification\n * @param int $p_bug_id\n * @param string $p_field_name\n * @param string $p_old_value\n * @return null\n */\nfunction history_log_event( $p_bug_id, $p_field_name, $p_old_value ) {\n\thistory_log_event_direct( $p_bug_id, $p_field_name, $p_old_value, bug_get_field( $p_bug_id, $p_field_name ) );\n}\n\n/**\n * log the changes\n * events should be logged *after* the modification\n * These are special case logs (new bug, deleted bugnote, etc.)\n * @param int $p_bug_id\n * @param int $p_type\n * @param string $p_optional\n * @param string $p_optional2\n * @return null\n */\nfunction history_log_event_special( $p_bug_id, $p_type, $p_optional = '', $p_optional2 = '' ) {\n\t$c_bug_id = db_prepare_int( $p_bug_id );\n\t$c_type = db_prepare_int( $p_type );\n\t$c_optional = ( $p_optional );\n\t$c_optional2 = ( $p_optional2 );\n\t$t_user_id = auth_get_current_user_id();\n\n\t$t_mantis_bug_history_table = db_get_table( 'bug_history' );\n\n\t$query = \"INSERT INTO $t_mantis_bug_history_table\n\t\t\t\t\t( user_id, bug_id, date_modified, type, old_value, new_value, field_name )\n\t\t\t\tVALUES\n\t\t\t\t\t( \" . db_param() . ', ' . db_param() . ', ' . db_param() . ', ' . db_param() . ', ' . db_param() . ',' . db_param() . ', ' . db_param() . ')';\n\t$result = db_query_bound( $query, Array( $t_user_id, $c_bug_id, db_now(), $c_type, $c_optional, $c_optional2, '' ) );\n}\n\n/**\n * Retrieves the history events for the specified bug id and returns it in an array\n * The array is indexed from 0 to N-1.  The second dimension is: 'date', 'username',\n * 'note', 'change'.\n * @param int $p_bug_id\n * @param int $p_user_id\n * @return array\n */\nfunction history_get_events_array( $p_bug_id, $p_user_id = null ) {\n\t$t_normal_date_format = config_get( 'normal_date_format' );\n\n\t$raw_history = history_get_raw_events_array( $p_bug_id, $p_user_id );\n\t$raw_history_count = count( $raw_history );\n\t$history = array();\n\n\tfor( $i = 0;$i < $raw_history_count;$i++ ) {\n\t\t$history[$i] = history_localize_item( $raw_history[$i]['field'], $raw_history[$i]['type'], $raw_history[$i]['old_value'], $raw_history[$i]['new_value'] );\n\t\t$history[$i]['date'] = date( $t_normal_date_format, $raw_history[$i]['date'] );\n\t\t$history[$i]['userid'] = $raw_history[$i]['userid'];\n\t\t$history[$i]['username'] = $raw_history[$i]['username'];\n\t}\n\n\treturn( $history );\n}\n\n/**\n * Retrieves the raw history events for the specified bug id and returns it in an array\n * The array is indexed from 0 to N-1.  The second dimension is: 'date', 'userid', 'username',\n * 'field','type','old_value','new_value'\n * @param int $p_bug_id\n * @param int $p_user_id\n * @return array\n */\nfunction history_get_raw_events_array( $p_bug_id, $p_user_id = null ) {\n\t$t_mantis_bug_history_table = db_get_table( 'bug_history' );\n\t$t_mantis_user_table = db_get_table( 'user' );\n\t$t_history_order = config_get( 'history_order' );\n\t$c_bug_id = db_prepare_int( $p_bug_id );\n\n\t$t_user_id = (( null === $p_user_id ) ? auth_get_current_user_id() : $p_user_id );\n\n\t$t_roadmap_view_access_level = config_get( 'roadmap_view_threshold' );\n\t$t_due_date_view_threshold = config_get( 'due_date_view_threshold' );\n\n\t# grab history and display by date_modified then field_name\n\t# @@@ by MASC I guess it's better by id then by field_name. When we have more history lines with the same\n\t# date, it's better to respect the storing order otherwise we should risk to mix different information\n\t# I give you an example. We create a child of a bug with different custom fields. In the history of the child\n\t# bug we will find the line related to the relationship mixed with the custom fields (the history is creted\n\t# for the new bug with the same timestamp...)\n\t$query = \"SELECT *\n\t\t\t\tFROM $t_mantis_bug_history_table\n\t\t\t\tWHERE bug_id=\" . db_param() . \"\n\t\t\t\tORDER BY date_modified $t_history_order,id\";\n\t$result = db_query_bound( $query, Array( $c_bug_id ) );\n\t$raw_history_count = db_num_rows( $result );\n\t$raw_history = array();\n\n\t$t_private_bugnote_threshold = config_get( 'private_bugnote_threshold' );\n\t$t_private_bugnote_visible = access_has_bug_level( config_get( 'private_bugnote_threshold' ), $p_bug_id, $t_user_id );\n\t$t_tag_view_threshold = config_get( 'tag_view_threshold' );\n\t$t_show_monitor_list_threshold = config_get( 'show_monitor_list_threshold' );\n\t$t_show_handler_threshold = config_get( 'view_handler_threshold' );\n\n\t$t_standard_fields = columns_get_standard();\n\n\tfor( $i = 0, $j = 0;$i < $raw_history_count;++$i ) {\n\t\t$t_row = db_fetch_array( $result );\n\n\t\t$v_type = $t_row['type'];\n\t\t$v_field_name = $t_row['field_name'];\n\t\t$v_user_id = $t_row['user_id'];\n\t\t$v_new_value = $t_row['new_value'];\n\t\t$v_old_value = $t_row['old_value'];\n\t\t$v_date_modified = $t_row['date_modified'];\n\n\t\tif ( $v_type == NORMAL_TYPE ) {\n\t\t\tif ( !in_array( $v_field_name, $t_standard_fields ) ) {\n\n\t\t\t\t// check that the item should be visible to the user\n\t\t\t\t// custom fields - we are passing 32 here to notify the API that the custom field name is truncated by the history column from 64 to 32 characters.\n\t\t\t\t$t_field_id = custom_field_get_id_from_name( $v_field_name, 32 );\n\t\t\t\tif( false !== $t_field_id && !custom_field_has_read_access( $t_field_id, $p_bug_id, $t_user_id ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( ( $v_field_name == 'target_version' ) && !access_has_bug_level( $t_roadmap_view_access_level, $p_bug_id, $t_user_id ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ( ( $v_field_name == 'due_date' ) && !access_has_bug_level( $t_due_date_view_threshold, $p_bug_id, $t_user_id ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ( ( $v_field_name == 'handler_id' ) && !access_has_bug_level( $t_show_handler_threshold, $p_bug_id, $t_user_id ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t// bugnotes\n\t\tif( $t_user_id != $v_user_id ) {\n\t\t\t// bypass if user originated note\n\t\t\tif(( $v_type == BUGNOTE_ADDED ) || ( $v_type == BUGNOTE_UPDATED ) || ( $v_type == BUGNOTE_DELETED ) ) {\n\t\t\t\tif( !$t_private_bugnote_visible && ( bugnote_get_field( $v_old_value, 'view_state' ) == VS_PRIVATE ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif( $v_type == BUGNOTE_STATE_CHANGED ) {\n\t\t\t\tif( !$t_private_bugnote_visible && ( bugnote_get_field( $v_new_value, 'view_state' ) == VS_PRIVATE ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// tags\n\t\tif( $v_type == TAG_ATTACHED || $v_type == TAG_DETACHED || $v_type == TAG_RENAMED ) {\n\t\t\tif( !access_has_bug_level( $t_tag_view_threshold, $p_bug_id, $t_user_id ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t// monitoring\n\t\tif( $v_type == BUG_MONITOR || $v_type == BUG_UNMONITOR ) {\n\t\t\tif( !access_has_bug_level( $t_show_monitor_list_threshold, $p_bug_id, $t_user_id ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t$raw_history[$j]['date'] = $v_date_modified;\n\t\t$raw_history[$j]['userid'] = $v_user_id;\n\n\t\t# user_get_name handles deleted users, and username vs realname\n\t\t$raw_history[$j]['username'] = user_get_name( $v_user_id );\n\n\t\t$raw_history[$j]['field'] = $v_field_name;\n\t\t$raw_history[$j]['type'] = $v_type;\n\t\t$raw_history[$j]['old_value'] = $v_old_value;\n\t\t$raw_history[$j]['new_value'] = $v_new_value;\n\n\t\t$j++;\n\t}\n\n\t# end for loop\n\n\treturn $raw_history;\n}\n\n/**\n * Localizes one raw history item specified by set the next parameters: $p_field_name, $p_type, $p_old_value, $p_new_value\n * Returns array with two elements indexed as 'note' and 'change'\n * @param string $p_field_name\n * @param int $p_type\n * @param string $p_old_value\n * @param string $p_new_value\n * @param bool $p_linkify\n * @return array\n */\nfunction history_localize_item( $p_field_name, $p_type, $p_old_value, $p_new_value, $p_linkify=true ) {\n\t$t_note = '';\n\t$t_change = '';\n\t$t_field_localized = $p_field_name;\n\t$t_raw = true;\n\n\tif( PLUGIN_HISTORY == $p_type ) {\n\t\t$t_note = lang_get_defaulted( \"plugin_$p_field_name\", $p_field_name );\n\t\t$t_change = ( isset( $p_new_value ) ? \"$p_old_value => $p_new_value\" : $p_old_value );\n\n\t\treturn array( 'note' => $t_note, 'change' => $t_change, 'raw' => true );\n\t}\n\n\tswitch( $p_field_name ) {\n\t\tcase 'category':\n\t\t\t$t_field_localized = lang_get( 'category' );\n\t\t\tbreak;\n\t\tcase 'status':\n\t\t\t$p_old_value = get_enum_element( 'status', $p_old_value );\n\t\t\t$p_new_value = get_enum_element( 'status', $p_new_value );\n\t\t\t$t_field_localized = lang_get( 'status' );\n\t\t\tbreak;\n\t\tcase 'severity':\n\t\t\t$p_old_value = get_enum_element( 'severity', $p_old_value );\n\t\t\t$p_new_value = get_enum_element( 'severity', $p_new_value );\n\t\t\t$t_field_localized = lang_get( 'severity' );\n\t\t\tbreak;\n\t\tcase 'reproducibility':\n\t\t\t$p_old_value = get_enum_element( 'reproducibility', $p_old_value );\n\t\t\t$p_new_value = get_enum_element( 'reproducibility', $p_new_value );\n\t\t\t$t_field_localized = lang_get( 'reproducibility' );\n\t\t\tbreak;\n\t\tcase 'resolution':\n\t\t\t$p_old_value = get_enum_element( 'resolution', $p_old_value );\n\t\t\t$p_new_value = get_enum_element( 'resolution', $p_new_value );\n\t\t\t$t_field_localized = lang_get( 'resolution' );\n\t\t\tbreak;\n\t\tcase 'priority':\n\t\t\t$p_old_value = get_enum_element( 'priority', $p_old_value );\n\t\t\t$p_new_value = get_enum_element( 'priority', $p_new_value );\n\t\t\t$t_field_localized = lang_get( 'priority' );\n\t\t\tbreak;\n\t\tcase 'eta':\n\t\t\t$p_old_value = get_enum_element( 'eta', $p_old_value );\n\t\t\t$p_new_value = get_enum_element( 'eta', $p_new_value );\n\t\t\t$t_field_localized = lang_get( 'eta' );\n\t\t\tbreak;\n\t\tcase 'view_state':\n\t\t\t$p_old_value = get_enum_element( 'view_state', $p_old_value );\n\t\t\t$p_new_value = get_enum_element( 'view_state', $p_new_value );\n\t\t\t$t_field_localized = lang_get( 'view_status' );\n\t\t\tbreak;\n\t\tcase 'projection':\n\t\t\t$p_old_value = get_enum_element( 'projection', $p_old_value );\n\t\t\t$p_new_value = get_enum_element( 'projection', $p_new_value );\n\t\t\t$t_field_localized = lang_get( 'projection' );\n\t\t\tbreak;\n\t\tcase 'sticky':\n\t\t\t$p_old_value = gpc_string_to_bool( $p_old_value ) ? lang_get( 'yes' ) : lang_get( 'no' );\n\t\t\t$p_new_value = gpc_string_to_bool( $p_new_value ) ? lang_get( 'yes' ) : lang_get( 'no' );\n\t\t\t$t_field_localized = lang_get( 'sticky_issue' );\n\t\t\tbreak;\n\t\tcase 'project_id':\n\t\t\tif( project_exists( $p_old_value ) ) {\n\t\t\t\t$p_old_value = project_get_field( $p_old_value, 'name' );\n\t\t\t} else {\n\t\t\t\t$p_old_value = '@' . $p_old_value . '@';\n\t\t\t}\n\n\t\t\t# Note that the new value maybe an intermediately project and not the\n\t\t\t# current one.\n\t\t\tif( project_exists( $p_new_value ) ) {\n\t\t\t\t$p_new_value = project_get_field( $p_new_value, 'name' );\n\t\t\t} else {\n\t\t\t\t$p_new_value = '@' . $p_new_value . '@';\n\t\t\t}\n\t\t\t$t_field_localized = lang_get( 'email_project' );\n\t\t\tbreak;\n\t\tcase 'handler_id':\n\t\t\t$t_field_localized = lang_get( 'assigned_to' );\n\t\tcase 'reporter_id':\n\t\t\tif( 'reporter_id' == $p_field_name ) {\n\t\t\t\t$t_field_localized = lang_get( 'reporter' );\n\t\t\t}\n\t\t\tif( 0 == $p_old_value ) {\n\t\t\t\t$p_old_value = '';\n\t\t\t} else {\n\t\t\t\t$p_old_value = user_get_name( $p_old_value );\n\t\t\t}\n\n\t\t\tif( 0 == $p_new_value ) {\n\t\t\t\t$p_new_value = '';\n\t\t\t} else {\n\t\t\t\t$p_new_value = user_get_name( $p_new_value );\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'version':\n\t\t\t$t_field_localized = lang_get( 'product_version' );\n\t\t\tbreak;\n\t\tcase 'fixed_in_version':\n\t\t\t$t_field_localized = lang_get( 'fixed_in_version' );\n\t\t\tbreak;\n\t\tcase 'target_version':\n\t\t\t$t_field_localized = lang_get( 'target_version' );\n\t\t\tbreak;\n\t\tcase 'date_submitted':\n\t\t\t$t_field_localized = lang_get( 'date_submitted' );\n\t\t\tbreak;\n\t\tcase 'last_updated':\n\t\t\t$t_field_localized = lang_get( 'last_update' );\n\t\t\tbreak;\n\t\tcase 'os':\n\t\t\t$t_field_localized = lang_get( 'os' );\n\t\t\tbreak;\n\t\tcase 'os_build':\n\t\t\t$t_field_localized = lang_get( 'os_version' );\n\t\t\tbreak;\n\t\tcase 'build':\n\t\t\t$t_field_localized = lang_get( 'build' );\n\t\t\tbreak;\n\t\tcase 'platform':\n\t\t\t$t_field_localized = lang_get( 'platform' );\n\t\t\tbreak;\n\t\tcase 'summary':\n\t\t\t$t_field_localized = lang_get( 'summary' );\n\t\t\tbreak;\n\t\tcase 'duplicate_id':\n\t\t\t$t_field_localized = lang_get( 'duplicate_id' );\n\t\t\tbreak;\n\t\tcase 'sponsorship_total':\n\t\t\t$t_field_localized = lang_get( 'sponsorship_total' );\n\t\t\tbreak;\n\t\tcase 'due_date':\n\t\t\tif( $p_old_value !== '' ) {\n\t\t\t\t$p_old_value = date( config_get( 'normal_date_format' ), (int) $p_old_value );\n\t\t\t}\n\t\t\tif( $p_new_value !== '' ) {\n\t\t\t\t$p_new_value = date( config_get( 'normal_date_format' ), (int) $p_new_value );\n\t\t\t}\n\t\t\t$t_field_localized = lang_get( 'due_date' );\n\t\t\tbreak;\n\t\tdefault:\n\n\t\t\t# assume it's a custom field name\n\t\t\t$t_field_id = custom_field_get_id_from_name( $p_field_name );\n\t\t\tif( false !== $t_field_id ) {\n\t\t\t\t$t_cf_type = custom_field_type( $t_field_id );\n\t\t\t\tif( '' != $p_old_value ) {\n\t\t\t\t\t$p_old_value = string_custom_field_value_for_email( $p_old_value, $t_cf_type );\n\t\t\t\t}\n\t\t\t\t$p_new_value = string_custom_field_value_for_email( $p_new_value, $t_cf_type );\n\t\t\t}\n\t\t}\n\n\t\tif( NORMAL_TYPE != $p_type ) {\n\t\t\tswitch( $p_type ) {\n\t\t\t\tcase NEW_BUG:\n\t\t\t\t\t$t_note = lang_get( 'new_bug' );\n\t\t\t\t\tbreak;\n\t\t\t\tcase BUGNOTE_ADDED:\n\t\t\t\t\t$t_note = lang_get( 'bugnote_added' ) . ': ' . $p_old_value;\n\t\t\t\t\tbreak;\n\t\t\t\tcase BUGNOTE_UPDATED:\n\t\t\t\t\t$t_note = lang_get( 'bugnote_edited' ) . ': ' . $p_old_value;\n\t\t\t\t\t$t_old_value = (int)$p_old_value;\n\t\t\t\t\t$t_new_value = (int)$p_new_value;\n\t\t\t\t\tif ( $p_linkify && bug_revision_exists( $t_new_value ) ) {\n\t\t\t\t\t\tif ( bugnote_exists( $t_old_value ) ) {\n\t\t\t\t\t\t\t$t_bug_revision_view_page_argument = 'bugnote_id=' . $t_old_value . '#r' . $t_new_value;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$t_bug_revision_view_page_argument = 'rev_id=' . $t_new_value;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$t_change = '<a href=\"bug_revision_view_page.php?' . $t_bug_revision_view_page_argument . '\">' .\n\t\t\t\t\t\t\tlang_get( 'view_revisions' ) . '</a>';\n\t\t\t\t\t\t$t_raw = false;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase BUGNOTE_DELETED:\n\t\t\t\t\t$t_note = lang_get( 'bugnote_deleted' ) . ': ' . $p_old_value;\n\t\t\t\t\tbreak;\n\t\t\t\tcase DESCRIPTION_UPDATED:\n\t\t\t\t\t$t_note = lang_get( 'description_updated' );\n\t\t\t\t\t$t_old_value = (int)$p_old_value;\n\t\t\t\t\tif ( $p_linkify && bug_revision_exists( $t_old_value ) ) {\n\t\t\t\t\t\t$t_change = '<a href=\"bug_revision_view_page.php?rev_id=' . $t_old_value . '#r' . $t_old_value . '\">' .\n\t\t\t\t\t\t\tlang_get( 'view_revisions' ) . '</a>';\n\t\t\t\t\t\t$t_raw = false;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase ADDITIONAL_INFO_UPDATED:\n\t\t\t\t\t$t_note = lang_get( 'additional_information_updated' );\n\t\t\t\t\t$t_old_value = (int)$p_old_value;\n\t\t\t\t\tif ( $p_linkify && bug_revision_exists( $t_old_value ) ) {\n\t\t\t\t\t\t$t_change = '<a href=\"bug_revision_view_page.php?rev_id=' . $t_old_value . '#r' . $t_old_value . '\">' .\n\t\t\t\t\t\t\tlang_get( 'view_revisions' ) . '</a>';\n\t\t\t\t\t\t$t_raw = false;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase STEP_TO_REPRODUCE_UPDATED:\n\t\t\t\t\t$t_note = lang_get( 'steps_to_reproduce_updated' );\n\t\t\t\t\t$t_old_value = (int)$p_old_value;\n\t\t\t\t\tif ( $p_linkify && bug_revision_exists( $t_old_value ) ) {\n\t\t\t\t\t\t$t_change = '<a href=\"bug_revision_view_page.php?rev_id=' . $t_old_value . '#r' . $t_old_value . '\">' .\n\t\t\t\t\t\t\tlang_get( 'view_revisions' ) . '</a>';\n\t\t\t\t\t\t$t_raw = false;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_ADDED:\n\t\t\t\t\t$t_note = lang_get( 'file_added' ) . ': ' . $p_old_value;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_DELETED:\n\t\t\t\t\t$t_note = lang_get( 'file_deleted' ) . ': ' . $p_old_value;\n\t\t\t\t\tbreak;\n\t\t\t\tcase BUGNOTE_STATE_CHANGED:\n\t\t\t\t\t$p_old_value = get_enum_element( 'view_state', $p_old_value );\n\t\t\t\t\t$t_note = lang_get( 'bugnote_view_state' ) . ': ' . $p_new_value . ': ' . $p_old_value;\n\t\t\t\t\tbreak;\n\t\t\t\tcase BUG_MONITOR:\n\t\t\t\t\t$p_old_value = user_get_name( $p_old_value );\n\t\t\t\t\t$t_note = lang_get( 'bug_monitor' ) . ': ' . $p_old_value;\n\t\t\t\t\tbreak;\n\t\t\t\tcase BUG_UNMONITOR:\n\t\t\t\t\t$p_old_value = user_get_name( $p_old_value );\n\t\t\t\t\t$t_note = lang_get( 'bug_end_monitor' ) . ': ' . $p_old_value;\n\t\t\t\t\tbreak;\n\t\t\t\tcase BUG_DELETED:\n\t\t\t\t\t$t_note = lang_get( 'bug_deleted' ) . ': ' . $p_old_value;\n\t\t\t\t\tbreak;\n\t\t\t\tcase BUG_ADD_SPONSORSHIP:\n\t\t\t\t\t$t_note = lang_get( 'sponsorship_added' );\n\t\t\t\t\t$t_change = user_get_name( $p_old_value ) . ': ' . sponsorship_format_amount( $p_new_value );\n\t\t\t\t\tbreak;\n\t\t\t\tcase BUG_UPDATE_SPONSORSHIP:\n\t\t\t\t\t$t_note = lang_get( 'sponsorship_updated' );\n\t\t\t\t\t$t_change = user_get_name( $p_old_value ) . ': ' . sponsorship_format_amount( $p_new_value );\n\t\t\t\t\tbreak;\n\t\t\t\tcase BUG_DELETE_SPONSORSHIP:\n\t\t\t\t\t$t_note = lang_get( 'sponsorship_deleted' );\n\t\t\t\t\t$t_change = user_get_name( $p_old_value ) . ': ' . sponsorship_format_amount( $p_new_value );\n\t\t\t\t\tbreak;\n\t\t\t\tcase BUG_PAID_SPONSORSHIP:\n\t\t\t\t\t$t_note = lang_get( 'sponsorship_paid' );\n\t\t\t\t\t$t_change = user_get_name( $p_old_value ) . ': ' . get_enum_element( 'sponsorship', $p_new_value );\n\t\t\t\t\tbreak;\n\t\t\t\tcase BUG_ADD_RELATIONSHIP:\n\t\t\t\t\t$t_note = lang_get( 'relationship_added' );\n\t\t\t\t\t$t_change = relationship_get_description_for_history( $p_old_value ) . ' ' . bug_format_id( $p_new_value );\n\t\t\t\t\tbreak;\n\t\t\t\tcase BUG_REPLACE_RELATIONSHIP:\n\t\t\t\t\t$t_note = lang_get( 'relationship_replaced' );\n\t\t\t\t\t$t_change = relationship_get_description_for_history( $p_old_value ) . ' ' . bug_format_id( $p_new_value );\n\t\t\t\t\tbreak;\n\t\t\t\tcase BUG_DEL_RELATIONSHIP:\n\t\t\t\t\t$t_note = lang_get( 'relationship_deleted' );\n\n\t\t\t\t\t# Fix for #7846: There are some cases where old value is empty, this may be due to an old bug.\n\t\t\t\t\tif( !is_blank( $p_old_value ) && $p_old_value > 0 ) {\n\t\t\t\t\t\t$t_change = relationship_get_description_for_history( $p_old_value ) . ' ' . bug_format_id( $p_new_value );\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$t_change = bug_format_id( $p_new_value );\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase BUG_CLONED_TO:\n\t\t\t\t\t$t_note = lang_get( 'bug_cloned_to' ) . ': ' . bug_format_id( $p_new_value );\n\t\t\t\t\tbreak;\n\t\t\t\tcase BUG_CREATED_FROM:\n\t\t\t\t\t$t_note = lang_get( 'bug_created_from' ) . ': ' . bug_format_id( $p_new_value );\n\t\t\t\t\tbreak;\n\t\t\t\tcase TAG_ATTACHED:\n\t\t\t\t\t$t_note = lang_get( 'tag_history_attached' ) . ': ' . $p_old_value;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TAG_DETACHED:\n\t\t\t\t\t$t_note = lang_get( 'tag_history_detached' ) . ': ' . $p_old_value;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TAG_RENAMED:\n\t\t\t\t\t$t_note = lang_get( 'tag_history_renamed' );\n\t\t\t\t\t$t_change = $p_old_value . ' => ' . $p_new_value;\n\t\t\t\t\tbreak;\n\t\t\t\tcase BUG_REVISION_DROPPED:\n\t\t\t\t\t$t_note = lang_get( 'bug_revision_dropped_history' ) . ': ' . bug_revision_get_type_name( $p_new_value ) . ': ' . $p_old_value;\n\t\t\t\t\tbreak;\n\t\t\t\tcase BUGNOTE_REVISION_DROPPED:\n\t\t\t\t\t$t_note = lang_get( 'bugnote_revision_dropped_history' ) . ': ' . $p_new_value . ': ' . $p_old_value;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\t# output special cases\n\tif( NORMAL_TYPE == $p_type ) {\n\t\t$t_note = $t_field_localized;\n\t\t$t_change = $p_old_value . ' => ' . $p_new_value;\n\t}\n\n\t# end if DEFAULT\n\treturn array( 'note' => $t_note, 'change' => $t_change, 'raw' => $t_raw );\n}\n\n/**\n * delete all history associated with a bug\n * @param int $p_bug_id\n * @return true\n */\nfunction history_delete( $p_bug_id ) {\n\t$c_bug_id = db_prepare_int( $p_bug_id );\n\n\t$t_bug_history_table = db_get_table( 'bug_history' );\n\n\t$query = 'DELETE FROM ' . $t_bug_history_table . ' WHERE bug_id=' . db_param();\n\tdb_query_bound( $query, Array( $c_bug_id ) );\n\n\t# db_query errors on failure so:\n\treturn true;\n}\n"], "filenames": ["bug_actiongroup.php", "core/bug_api.php", "core/history_api.php"], "buggy_code_start_loc": [153, 909, 559], "buggy_code_end_loc": [154, 1055, 565], "fixing_code_start_loc": [153, 910, 559], "fixing_code_end_loc": [155, 1064, 563], "type": "CWE-264", "message": "MantisBT before 1.2.9 does not audit when users copy or clone a bug report, which makes it easier for remote attackers to copy bug reports without detection.", "other": {"cve": {"id": "CVE-2012-1119", "sourceIdentifier": "secalert@redhat.com", "published": "2012-06-29T19:55:02.907", "lastModified": "2021-01-12T18:05:59.507", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "MantisBT before 1.2.9 does not audit when users copy or clone a bug report, which makes it easier for remote attackers to copy bug reports without detection."}, {"lang": "es", "value": "MantisBT anteriores a 1.2.9 no audita la acci\u00f3n de un usuario de copiar o clonar un reporte de bug, lo que facilita a atacantes remotos copiar reportes de bug sin detecci\u00f3n."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-264"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.2.8", "matchCriteriaId": "79367D94-9665-49D7-94E4-CC9EFC7439BB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:0.18.0:*:*:*:*:*:*:*", "matchCriteriaId": "AF83F757-4B62-441C-8421-15809E573A83"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:0.19.0:*:*:*:*:*:*:*", "matchCriteriaId": "A608AFEC-B265-4143-99DA-BB2AE9D522BC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:0.19.0:a1:*:*:*:*:*:*", "matchCriteriaId": "A826DA75-7DEE-4E96-9B00-347508BBCFE8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:0.19.0:a2:*:*:*:*:*:*", "matchCriteriaId": "06663B16-0609-4FCF-9B42-6BF30D25E67A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:0.19.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "7FCB56AC-4C14-49B1-BEFE-8651BC70476E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:0.19.1:*:*:*:*:*:*:*", "matchCriteriaId": "F59BAE6B-C73D-4BE2-AEF9-93F2F4A4373F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:0.19.2:*:*:*:*:*:*:*", "matchCriteriaId": "C9DA5C2F-FB7C-4D95-81DE-24D8EADC5C30"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:0.19.3:*:*:*:*:*:*:*", "matchCriteriaId": "85A3FBD5-163C-4990-B809-A5C9C81A3C6C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:0.19.4:*:*:*:*:*:*:*", "matchCriteriaId": "D3FDF456-9648-4A7C-B15A-2828A32D4962"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:0.19.5:*:*:*:*:*:*:*", "matchCriteriaId": "9EE8BCBE-D864-4311-B73A-DF92162D8DF3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "6B2602F7-2D93-4E1E-9425-4EDD23752029"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.0:a1:*:*:*:*:*:*", "matchCriteriaId": "482256A6-B213-4226-AF03-9F93164AA337"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.0:a2:*:*:*:*:*:*", "matchCriteriaId": "1F005474-CEBD-48FC-9C7F-861AFF771081"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.0:a3:*:*:*:*:*:*", "matchCriteriaId": "BEF461E5-24D2-4540-A2FC-E0D4C3488B8F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "62F6B391-DDE3-4E8E-8582-85EA7287E591"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "80DBD667-1FB9-4354-9150-A190D4D817A2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.0:rc3:*:*:*:*:*:*", "matchCriteriaId": "F27E40C0-263F-452B-8C91-E621A02EFC28"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.0:rc4:*:*:*:*:*:*", "matchCriteriaId": "CB888B14-EA67-4EDB-A3AF-ACD3F0A6227E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.0:rc5:*:*:*:*:*:*", "matchCriteriaId": "1DB45A02-2522-4E10-BC81-48750ACB42DD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "86DE3BE3-D6C9-4905-9E61-B70776460604"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "F128A2E2-D509-4B50-95C2-1A31C5B3B31F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "140D5F68-1CAB-458C-BC8B-4F726D657FE8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "0D25F4F5-7678-41C1-93CB-305883A08527"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.5:*:*:*:*:*:*:*", "matchCriteriaId": "D1A1316D-314B-4740-A836-D5E6319F4B28"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.6:*:*:*:*:*:*:*", "matchCriteriaId": "DBD27CCE-28C4-43CC-8CBD-D7FFB46171AC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.7:*:*:*:*:*:*:*", "matchCriteriaId": "97298C43-B881-4C11-ADB6-17A8E43EB84E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.8:*:*:*:*:*:*:*", "matchCriteriaId": "7257ADD7-C9B7-4F85-AA13-615DD033FD5C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.9:*:*:*:*:*:*:*", "matchCriteriaId": "DE6A94C0-48A1-4D42-AC43-7B4E959C4E21"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "02FE950B-5E29-4FAA-9BE5-79F38B4C38F7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.1.0:a1:*:*:*:*:*:*", "matchCriteriaId": "45FF2B45-AA64-4428-8F6E-65C5171990CB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.1.0:a2:*:*:*:*:*:*", "matchCriteriaId": "CC868663-1E48-4F9A-B687-5B48D016611B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.1.0:a3:*:*:*:*:*:*", "matchCriteriaId": "4F04ED02-4D99-45CF-9BEC-AC0F648748EA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.1.0:a4:*:*:*:*:*:*", "matchCriteriaId": "0AC08731-C4BB-4D84-ADBE-80054149BF33"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.1.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "35AAF0B4-31B5-4849-813F-63D9546C2E16"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.1.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "FB98EF06-7D6E-4D5F-819D-21B437E91B58"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.1.0:rc3:*:*:*:*:*:*", "matchCriteriaId": "66AB409E-5A5B-4455-8B68-22C32152681B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "D6F2BA78-D054-4E49-ABCA-637922898BF7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.1.2:*:*:*:*:*:*:*", "matchCriteriaId": "4595B1E3-25AB-489E-A847-FDBF2554DD6D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.1.3:*:*:*:*:*:*:*", "matchCriteriaId": "E6A13A38-E149-42A7-9309-BC991521320B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.1.4:*:*:*:*:*:*:*", "matchCriteriaId": "C11A8F17-5253-475B-89FF-A26EA7531E13"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.1.5:*:*:*:*:*:*:*", "matchCriteriaId": "4A88B09D-CDCF-45FD-B004-13B597DA4F48"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.1.6:*:*:*:*:*:*:*", "matchCriteriaId": "49583BE8-B832-4E9F-B154-47A26C72489D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.1.7:*:*:*:*:*:*:*", "matchCriteriaId": "E2501F40-3630-4528-BE0A-61D4BB6EC7FE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.1.8:*:*:*:*:*:*:*", "matchCriteriaId": "9223DAF7-D03E-4A4E-8AB5-5CEB87DFF2C3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.1.9:*:*:*:*:*:*:*", "matchCriteriaId": "078C0943-C27C-44A9-B00D-5A261C58D6CF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "CFF77ABF-0A03-437A-B241-1EF2BBB83D24"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.2.0:alpha1:*:*:*:*:*:*", "matchCriteriaId": "9DA2615A-CD65-4765-AB0A-D72C2BEB00F5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.2.0:alpha2:*:*:*:*:*:*", "matchCriteriaId": "7D09CC46-DFA2-408D-8720-05C23E73C859"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.2.0:alpha3:*:*:*:*:*:*", "matchCriteriaId": "3461212B-A96B-4D38-A722-84E7418C2A7A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.2.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "7B6DEE14-744B-4DE4-BDCF-E4E4D37F70A0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.2.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "D4462BEE-39B6-47BD-B08F-5BE1FD918221"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "5F096CD6-534E-4ABF-B2DF-D4B55B8C5F6A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.2.2:*:*:*:*:*:*:*", "matchCriteriaId": "A66AB537-6FBA-4A51-B10C-BF61F54BC01B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.2.3:*:*:*:*:*:*:*", "matchCriteriaId": "A50835BF-D28B-47FF-81F0-C34D95D6F2E9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.2.4:*:*:*:*:*:*:*", "matchCriteriaId": "BA0EB9A6-1DFD-4C17-A002-0899DA252A56"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.2.5:*:*:*:*:*:*:*", "matchCriteriaId": "BBA33285-3EE7-43FD-8347-E7D9A18DC134"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.2.6:*:*:*:*:*:*:*", "matchCriteriaId": "8827C2B4-EBEC-4D64-9AC8-07A048467F40"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.2.7:*:*:*:*:*:*:*", "matchCriteriaId": "1F32DFF4-6448-46FD-9358-4FB1C310EC2E"}]}]}], "references": [{"url": "http://lists.fedoraproject.org/pipermail/package-announce/2012-November/092926.html", "source": "secalert@redhat.com"}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2012-November/093063.html", "source": "secalert@redhat.com"}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2012-November/093064.html", "source": "secalert@redhat.com"}, {"url": "http://security.gentoo.org/glsa/glsa-201211-01.xml", "source": "secalert@redhat.com"}, {"url": "http://www.debian.org/security/2012/dsa-2500", "source": "secalert@redhat.com"}, {"url": "http://www.mantisbt.org/bugs/changelog_page.php?version_id=140", "source": "secalert@redhat.com"}, {"url": "http://www.mantisbt.org/bugs/view.php?id=13816", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2012/03/06/9", "source": "secalert@redhat.com"}, {"url": "http://www.securityfocus.com/bid/52313", "source": "secalert@redhat.com"}, {"url": "https://github.com/mantisbt/mantisbt/commit/cf5df427f17cf9204645f83e000665780eb9afe6", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}, {"url": "https://github.com/mantisbt/mantisbt/commit/dea7e315f3fc96dfa995e56e8810845fc07a47aa", "source": "secalert@redhat.com", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/mantisbt/mantisbt/commit/cf5df427f17cf9204645f83e000665780eb9afe6"}}