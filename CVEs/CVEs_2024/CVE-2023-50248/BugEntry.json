{"buggy_code": ["# encoding: utf-8\nfrom __future__ import annotations\nfrom contextlib import contextmanager\n\nimport functools\nimport logging\nimport re\nimport importlib\n\nfrom collections import defaultdict\nfrom typing import (Any, Callable, Container, Iterable, Optional,\n                    TypeVar, Union, cast, overload)\nfrom typing_extensions import Literal\n\nfrom werkzeug.datastructures import MultiDict\nfrom sqlalchemy import exc\n\nimport ckan.model as model\nimport ckan.authz as authz\nimport ckan.lib.navl.dictization_functions as df\nimport ckan.plugins as p\nimport ckan.lib.signals as signals\n\nfrom ckan.common import _, g\nfrom ckan.types import (\n    Action, ChainedAction,\n    ChainedAuthFunction, DataDict, ErrorDict, Context, FlattenDataDict,\n    Schema, Validator, ValidatorFactory)\n\nDecorated = TypeVar(\"Decorated\")\n\nlog = logging.getLogger(__name__)\n_validate = df.validate\n\n_PG_ERR_CODE = {'unique_violation': '23505'}\n\n\nclass NameConflict(Exception):\n    pass\n\n\nclass UsernamePasswordError(Exception):\n    pass\n\n\nclass ActionError(Exception):\n    message: Optional[str]\n\n    def __init__(self, message: Optional[str] = '') -> None:\n        self.message = message\n        super(ActionError, self).__init__(message)\n\n    def __str__(self):\n        msg = self.message\n        if not isinstance(msg, str):\n            msg = str(msg)\n        return msg\n\n\nclass NotFound(ActionError):\n    '''Exception raised by logic functions when a given object is not found.\n\n    For example :py:func:`~ckan.logic.action.get.package_show` raises\n    :py:exc:`~ckan.plugins.toolkit.ObjectNotFound` if no package with the\n    given ``id`` exists.\n\n    '''\n    pass\n\n\nclass NotAuthorized(ActionError):\n    '''Exception raised when the user is not authorized to call the action.\n\n    For example :py:func:`~ckan.logic.action.create.package_create` raises\n    :py:exc:`~ckan.plugins.toolkit.NotAuthorized` if the user is not authorized\n    to create packages.\n    '''\n    pass\n\n\nclass ValidationError(ActionError):\n    '''Exception raised by action functions when validating their given\n    ``data_dict`` fails.\n\n    '''\n    error_dict: ErrorDict\n\n    def __init__(self,\n                 errors: Union[str, ErrorDict],\n                 error_summary: Optional[dict[str, str]] = None,\n                 extra_msg: Optional[str] = None) -> None:\n        if not isinstance(errors, dict):\n            error_dict: ErrorDict = {'message': errors}\n        else:\n            error_dict = errors\n        # tags errors are a mess so let's clean them up\n        if 'tags' in error_dict:\n            tag_errors: list[Union[str, dict[str, Any]]] = []\n            for error in cast(\"list[dict[str, Any]]\", error_dict['tags']):\n                try:\n                    tag_errors.append(', '.join(error['name']))\n                except KeyError:\n                    # e.g. if it is a vocabulary_id error\n                    if error:\n                        tag_errors.append(error)\n            error_dict['tags'] = tag_errors\n        self.error_dict = error_dict\n        self._error_summary = error_summary\n        super(ValidationError, self).__init__(extra_msg)\n\n    @property\n    def error_summary(self) -> dict[str, str]:\n        ''' autogenerate the summary if not supplied '''\n        def summarise(error_dict: ErrorDict) -> dict[str, str]:\n            ''' Do some i18n stuff on the error_dict keys '''\n\n            def prettify(field_name: str):\n                field_name = re.sub(r'(?<!\\w)[Uu]rl(?!\\w)', 'URL',\n                                    field_name.replace('_', ' ').capitalize())\n                return _(field_name.replace('_', ' '))\n\n            summary = {}\n\n            for key, error in error_dict.items():\n                if key == 'resources':\n                    summary[_('Resources')] = _('Package resource(s) invalid')\n                elif key == 'extras':\n                    errors_extras = []\n                    for item in cast(\"list[dict[str, Any]]\", error):\n                        if (item.get('key') and\n                                item['key'][0] not in errors_extras):\n                            errors_extras.append(item['key'][0])\n                    summary[_('Extras')] = ', '.join(errors_extras)\n                elif key == 'extras_validation':\n                    assert isinstance(error, list)\n                    summary[_('Extras')] = error[0]\n                elif key == 'tags':\n                    assert isinstance(error, list)\n                    summary[_('Tags')] = error[0]\n                else:\n                    assert isinstance(error, list)\n                    summary[_(prettify(key))] = error[0]\n            return summary\n\n        if self._error_summary:\n            return self._error_summary\n        return summarise(self.error_dict)\n\n    def __str__(self):\n        err_msgs = (super(ValidationError, self).__str__(),\n                    self.error_dict)\n        return ' - '.join([str(err_msg) for err_msg in err_msgs if err_msg])\n\n\ndef checks_and_delete_if_csrf_token_in_forms(parsed: dict[str, Any]):\n    '''\n    Checks and delete, if the csrf_token is in \"parsed\".\n    We don't want the csrf_token to be a part of a data_dict\n    as it will expose the token to the metadata.\n    This way we are deleting the token from every data_dict that fills\n    from request.form instead of deleting it separately in every\n    view/blueprint.\n    '''\n    from ckan.common import config\n\n    # WTF_CSRF_FIELD_NAME is added by flask_wtf\n    csrf_token = config.get(\"WTF_CSRF_FIELD_NAME\")\n    if csrf_token in parsed:\n        parsed.pop(csrf_token)\n    return parsed\n\n\ndef parse_params(\n    params: 'MultiDict[str, Any]',\n    ignore_keys: Optional['Container[str]'] = None\n) -> dict[str, Union[str, list[str]]]:\n    '''Takes a dict and returns it with some values standardised.\n    This is done on a dict before calling tuplize_dict on it.\n    '''\n    parsed = {}\n    for key in params:\n        if ignore_keys and key in ignore_keys:\n            continue\n        # flask request has `getlist` instead of pylons' `getall`\n\n        if hasattr(params, 'getall'):\n            # type_ignore_reason: pylons legacy\n            value = params.getall(key)  # type: ignore\n        else:\n            value = params.getlist(key)\n\n        # Blank values become ''\n        if not value:\n            value = ''\n        # A list with only one item is stripped of being a list\n        if len(value) == 1:\n            value = value[0]\n        parsed[key] = value\n\n    parsed = checks_and_delete_if_csrf_token_in_forms(parsed)\n    return parsed\n\n\ndef clean_dict(data_dict: dict[str, Any]) -> dict[str, Any]:\n    '''Takes a dict and if any of the values are lists of dicts,\n    the empty dicts are stripped from the lists (recursive).\n\n    e.g.\n    >>> clean_dict(\n        {'name': u'testgrp4',\n         'title': u'',\n         'description': u'',\n         'packages': [{'name': u'testpkg'}, {'name': u'testpkg'}],\n         'extras': [{'key': u'packages', 'value': u'[\"testpkg\"]'},\n                    {'key': u'', 'value': u''},\n                    {'key': u'', 'value': u''}],\n         'state': u'active'}\n    {'name': u'testgrp4',\n     'title': u'',\n     'description': u'',\n     'packages': [{'name': u'testpkg'}, {'name': u'testpkg'}],\n     'extras': [{'key': u'packages', 'value': u'[\"testpkg\"]'}],\n     'state': u'active'}\n\n    '''\n    for value in data_dict.values():\n        if not isinstance(value, list):\n            continue\n        for inner_dict in value[:]:\n            if isinstance(inner_dict, str):\n                break\n            if not any(inner_dict.values()):\n                value.remove(inner_dict)\n            else:\n                clean_dict(inner_dict)\n    return data_dict\n\n\ndef tuplize_dict(data_dict: dict[str, Any]) -> FlattenDataDict:\n    '''Takes a dict with keys of the form 'table__0__key' and converts them\n    to a tuple like ('table', 0, 'key').\n\n    Dict should be put through parse_dict before this function, to have\n    values standardized.\n\n    May raise a DataError if the format of the key is incorrect.\n    '''\n    tuplized_dict: FlattenDataDict = {}\n    for k, value in data_dict.items():\n        key_list = cast(\"list[Union[str, int]]\", k.split('__'))\n        for num, key in enumerate(key_list):\n            if num % 2 == 1:\n                try:\n                    key_list[num] = int(key)\n                except ValueError:\n                    raise df.DataError('Bad key')\n        tuplized_dict[tuple(key_list)] = value\n    return tuplized_dict\n\n\ndef untuplize_dict(tuplized_dict: FlattenDataDict) -> dict[str, Any]:\n\n    data_dict = {}\n    for key, value in tuplized_dict.items():\n        new_key = '__'.join([str(item) for item in key])\n        data_dict[new_key] = value\n    return data_dict\n\n\ndef flatten_to_string_key(dict: dict[str, Any]) -> dict[str, Any]:\n\n    flattented = df.flatten_dict(dict)\n    return untuplize_dict(flattented)\n\n\ndef _prepopulate_context(context: Optional[Context]) -> Context:\n    if context is None:\n        context = {}\n    context.setdefault('model', model)\n    context.setdefault('session', model.Session)\n\n    try:\n        user = g.user\n    except AttributeError:\n        # g.user not set\n        user = \"\"\n    except RuntimeError:\n        # Outside of request context\n        user = \"\"\n    except TypeError:\n        # g not registered\n        user = \"\"\n\n    context.setdefault('user', user)\n    return context\n\n\ndef check_access(action: str,\n                 context: Context,\n                 data_dict: Optional[dict[str, Any]] = None) -> Literal[True]:\n    '''Calls the authorization function for the provided action\n\n    This is the only function that should be called to determine whether a\n    user (or an anonymous request) is allowed to perform a particular action.\n\n    The function accepts a context object, which should contain a 'user' key\n    with the name of the user performing the action, and optionally a\n    dictionary with extra data to be passed to the authorization function.\n\n    For example::\n\n        check_access('package_update', context, data_dict)\n\n    If not already there, the function will add an `auth_user_obj` key to the\n    context object with the actual User object (in case it exists in the\n    database). This check is only performed once per context object.\n\n    Raise :py:exc:`~ckan.plugins.toolkit.NotAuthorized` if the user is not\n    authorized to call the named action function.\n\n    If the user *is* authorized to call the action, return ``True``.\n\n    :param action: the name of the action function, eg. ``'package_create'``\n    :type action: string\n\n    :param context:\n    :type context: dict\n\n    :param data_dict:\n    :type data_dict: dict\n\n    :raises: :py:exc:`~ckan.plugins.toolkit.NotAuthorized` if the user is not\n        authorized to call the named action\n\n    '''\n\n    # Auth Auditing.  We remove this call from the __auth_audit stack to show\n    # we have called the auth function\n    try:\n        audit: Optional[tuple[str, int]] = context.get('__auth_audit', [])[-1]\n    except IndexError:\n        audit = None\n    if audit and audit[0] == action:\n        context['__auth_audit'].pop()\n\n    if 'auth_user_obj' not in context:\n        context['auth_user_obj'] = None\n\n    context = _prepopulate_context(context)\n\n    if not context.get('__auth_user_obj_checked'):\n        if context[\"user\"] and not context[\"auth_user_obj\"]:\n            context['auth_user_obj'] = model.User.get(context['user'])\n        context['__auth_user_obj_checked'] = True\n\n    try:\n        logic_authorization = authz.is_authorized(action, context, data_dict)\n        if not logic_authorization['success']:\n            msg = cast(str, logic_authorization.get('msg', ''))\n            raise NotAuthorized(msg)\n    except NotAuthorized as e:\n        log.debug(u'check access NotAuthorized - %s user=%s \"%s\"',\n                  action, context[\"user\"], str(e))\n        raise\n\n    log.debug('check access OK - %s user=%s', action, context[\"user\"])\n    return True\n\n\n_actions: dict[str, Action] = {}\n\n\ndef clear_actions_cache() -> None:\n    _actions.clear()\n\n\ndef chained_action(func: ChainedAction) -> ChainedAction:\n    '''Decorator function allowing action function to be chained.\n\n    This allows a plugin to modify the behaviour of an existing action\n    function. A Chained action function must be defined as\n    ``action_function(original_action, context, data_dict)`` where the\n    first parameter will be set to the action function in the next plugin\n    or in core ckan. The chained action may call the original_action\n    function, optionally passing different values, handling exceptions,\n    returning different values and/or raising different exceptions\n    to the caller.\n\n    Usage::\n\n        from ckan.plugins.toolkit import chained_action\n\n        @chained_action\n        @side_effect_free\n        def package_search(original_action, context, data_dict):\n            return original_action(context, data_dict)\n\n    :param func: chained action function\n    :type func: callable\n\n    :returns: chained action function\n    :rtype: callable\n\n    '''\n    # type_ignore_reason: custom attribute\n    func.chained_action = True  # type: ignore\n\n    return func\n\n\ndef _is_chained_action(func: Action) -> bool:\n    return getattr(func, 'chained_action', False)\n\n\ndef get_action(action: str) -> Action:\n    '''Return the named :py:mod:`ckan.logic.action` function.\n\n    For example ``get_action('package_create')`` will normally return the\n    :py:func:`ckan.logic.action.create.package_create()` function.\n\n    For documentation of the available action functions, see\n    :ref:`api-reference`.\n\n    You should always use ``get_action()`` instead of importing an action\n    function directly, because :py:class:`~ckan.plugins.interfaces.IActions`\n    plugins can override action functions, causing ``get_action()`` to return a\n    plugin-provided function instead of the default one.\n\n    Usage::\n\n        import ckan.plugins.toolkit as toolkit\n\n        # Call the package_create action function:\n        toolkit.get_action('package_create')(context, data_dict)\n\n    As the context parameter passed to an action function is commonly::\n\n        context = {'model': ckan.model, 'session': ckan.model.Session,\n                   'user': user}\n\n    an action function returned by ``get_action()`` will automatically add\n    these parameters to the context if they are not defined.  This is\n    especially useful for plugins as they should not really be importing parts\n    of ckan eg :py:mod:`ckan.model` and as such do not have access to ``model``\n    or ``model.Session``.\n\n    If a ``context`` of ``None`` is passed to the action function then the\n    default context dict will be created.\n\n    .. note::\n\n        Many action functions modify the context dict. It can therefore\n        not be reused for multiple calls of the same or different action\n        functions.\n\n    :param action: name of the action function to return,\n        eg. ``'package_create'``\n    :type action: string\n\n    :returns: the named action function\n    :rtype: callable\n\n    '''\n\n    if _actions:\n        if action not in _actions:\n            raise KeyError(\"Action '%s' not found\" % action)\n        return _actions[action]\n    # Otherwise look in all the plugins to resolve all possible First\n    # get the default ones in the ckan/logic/action directory Rather\n    # than writing them out in full will use importlib.import_module\n    # to load anything from ckan.logic.action that looks like it might\n    # be an action\n    for action_module_name in ['get', 'create', 'update', 'delete', 'patch']:\n        module = importlib.import_module(\n            '.' + action_module_name, 'ckan.logic.action')\n        for k, v in authz.get_local_functions(module):\n            _actions[k] = v\n            # Allow all actions defined in logic/action/get.py to\n            # be side-effect free.\n            if action_module_name == 'get' and \\\n               not hasattr(v, 'side_effect_free'):\n                v.side_effect_free = True\n\n    # Then overwrite them with any specific ones in the plugins:\n    resolved_action_plugins: dict[str, str] = {}\n    fetched_actions = {}\n    chained_actions = defaultdict(list)\n    for plugin in p.PluginImplementations(p.IActions):\n        for name, action_function in plugin.get_actions().items():\n            if _is_chained_action(action_function):\n                chained_actions[name].append(action_function)\n            elif name in resolved_action_plugins:\n                raise NameConflict(\n                    'The action %r is already implemented in %r' % (\n                        name,\n                        resolved_action_plugins[name]\n                    )\n                )\n            else:\n                resolved_action_plugins[name] = plugin.name\n                # Extensions are exempted from the auth audit for now\n                # This needs to be resolved later\n                # type_ignore_reason: custom attribute\n                action_function.auth_audit_exempt = True  # type: ignore\n                fetched_actions[name] = action_function\n    for name, func_list in chained_actions.items():\n        if name not in fetched_actions and name not in _actions:\n            # nothing to override from plugins or core\n            raise NotFound('The action %r is not found for chained action' % (\n                name))\n        for func in reversed(func_list):\n            # try other plugins first, fall back to core\n            prev_func = fetched_actions.get(name, _actions.get(name))\n            new_func = functools.partial(func, prev_func)\n            # persisting attributes to the new partial function\n            for attribute, value in func.__dict__.items():\n                setattr(new_func, attribute, value)\n            fetched_actions[name] = new_func\n\n    # Use the updated ones in preference to the originals.\n    _actions.update(fetched_actions)\n\n    # wrap the functions\n    for action_name, _action in _actions.items():\n        def make_wrapped(_action: Action, action_name: str):\n            def wrapped(context: Optional[Context] = None,\n                        data_dict: Optional[DataDict] = None, **kw: Any):\n                if kw:\n                    log.critical('%s was passed extra keywords %r'\n                                 % (_action.__name__, kw))\n\n                context = _prepopulate_context(context)\n\n                if data_dict is None:\n                    data_dict = {}\n\n                # Auth Auditing - checks that the action function did call\n                # check_access (unless there is no accompanying auth function).\n                # We push the action name and id onto the __auth_audit stack\n                # before calling the action, and check_access removes it.\n                # (We need the id of the action in case the action is wrapped\n                # inside an action of the same name, which happens in the\n                # datastore)\n                context.setdefault('__auth_audit', [])\n                context['__auth_audit'].append((action_name, id(_action)))\n\n                # check_access(action_name, context, data_dict=None)\n                result = _action(context, data_dict, **kw)\n                try:\n                    audit = context['__auth_audit'][-1]\n                    if audit[0] == action_name and audit[1] == id(_action):\n                        if action_name not in authz.auth_functions_list():\n                            log.debug('No auth function for %s' % action_name)\n                        elif not getattr(_action, 'auth_audit_exempt', False):\n                            raise Exception(\n                                'Action function {0} did not call its '\n                                'auth function'\n                                .format(action_name))\n                        # remove from audit stack\n                        context['__auth_audit'].pop()\n                except IndexError:\n                    pass\n\n                signals.action_succeeded.send(\n                    action_name, context=context, data_dict=data_dict,\n                    result=result)\n                return result\n            return wrapped\n\n        fn = make_wrapped(_action, action_name)\n        # we need to mirror the docstring\n        fn.__doc__ = _action.__doc__\n        # we need to retain the side effect free behaviour\n        if getattr(_action, 'side_effect_free', False):\n            # type_ignore_reason: custom attribute\n            fn.side_effect_free = True  # type: ignore\n        _actions[action_name] = fn\n\n    return _actions[action]\n\n\n@overload\ndef get_or_bust(data_dict: dict[str, Any], keys: str) -> Any:\n    ...\n\n\n@overload\ndef get_or_bust(\n        data_dict: dict[str, Any], keys: Iterable[str]) -> tuple[Any, ...]:\n    ...\n\n\ndef get_or_bust(\n        data_dict: dict[str, Any],\n        keys: Union[str, Iterable[str]]) -> Union[Any, tuple[Any, ...]]:\n    '''Return the value(s) from the given data_dict for the given key(s).\n\n    Usage::\n\n        single_value = get_or_bust(data_dict, 'a_key')\n        value_1, value_2 = get_or_bust(data_dict, ['key1', 'key2'])\n\n    :param data_dict: the dictionary to return the values from\n    :type data_dict: dictionary\n\n    :param keys: the key(s) for the value(s) to return\n    :type keys: either a string or a list\n\n    :returns: a single value from the dict if a single key was given,\n        or a tuple of values if a list of keys was given\n\n    :raises: :py:exc:`ckan.logic.ValidationError` if one of the given keys is\n        not in the given dictionary\n\n    '''\n    if isinstance(keys, str):\n        keys = [keys]\n\n    from ckan.logic.schema import create_schema_for_required_keys\n    schema = create_schema_for_required_keys(keys)\n\n    data_dict, errors = _validate(data_dict, schema)\n\n    if errors:\n        raise ValidationError(errors)\n\n    # preserve original key order\n    values = [data_dict[key] for key in keys]\n    if len(values) == 1:\n        return values[0]\n    return tuple(values)\n\n\ndef validate(schema_func: Callable[[], Schema],\n             can_skip_validator: bool = False) -> Callable[[Action], Action]:\n    ''' A decorator that validates an action function against a given schema\n    '''\n    def action_decorator(action: Action) -> Action:\n        @functools.wraps(action)\n        def wrapper(context: Context, data_dict: DataDict):\n            if can_skip_validator:\n                if context.get('skip_validation'):\n                    return action(context, data_dict)\n\n            schema = context.get('schema', schema_func())\n            data_dict, errors = _validate(data_dict, schema, context)\n            if errors:\n                raise ValidationError(errors)\n            return action(context, data_dict)\n        return wrapper\n    return action_decorator\n\n\ndef side_effect_free(action: Decorated) -> Decorated:\n    '''A decorator that marks the given action function as side-effect-free.\n\n    Action functions decorated with this decorator can be called with an HTTP\n    GET request to the :doc:`Action API </api/index>`. Action functions that\n    don't have this decorator must be called with a POST request.\n\n    If your CKAN extension defines its own action functions using the\n    :py:class:`~ckan.plugins.interfaces.IActions` plugin interface, you can use\n    this decorator to make your actions available with GET requests instead of\n    just with POST requests.\n\n    Example::\n\n        import ckan.plugins.toolkit as toolkit\n\n        @toolkit.side_effect_free\n        def my_custom_action_function(context, data_dict):\n            ...\n\n    (Then implement :py:class:`~ckan.plugins.interfaces.IActions` to register\n    your action function with CKAN.)\n\n    '''\n    # type_ignore_reason: custom attribute\n    action.side_effect_free = True  # type: ignore\n    return action\n\n\ndef auth_sysadmins_check(action: Decorated) -> Decorated:\n    '''A decorator that prevents sysadmins from being automatically authorized\n    to call an action function.\n\n    Normally sysadmins are allowed to call any action function (for example\n    when they're using the :doc:`Action API </api/index>` or the web\n    interface), if the user is a sysadmin the action function's authorization\n    function will not even be called.\n\n    If an action function is decorated with this decorator, then its\n    authorization function will always be called, even if the user is a\n    sysadmin.\n\n    '''\n    # type_ignore_reason: custom attribute\n    action.auth_sysadmins_check = True  # type: ignore\n    return action\n\n\ndef auth_audit_exempt(action: Decorated) -> Decorated:\n    ''' Dirty hack to stop auth audit being done '''\n    # type_ignore_reason: custom attribute\n    action.auth_audit_exempt = True  # type: ignore\n    return action\n\n\ndef auth_allow_anonymous_access(action: Decorated) -> Decorated:\n    ''' Flag an auth function as not requiring a logged in user\n\n    This means that check_access won't automatically raise a NotAuthorized\n    exception if an authenticated user is not provided in the context. (The\n    auth function can still return False if for some reason access is not\n    granted).\n    '''\n    # type_ignore_reason: custom attribute\n    action.auth_allow_anonymous_access = True  # type: ignore\n    return action\n\n\ndef auth_disallow_anonymous_access(action: Decorated) -> Decorated:\n    ''' Flag an auth function as requiring a logged in user\n\n    This means that check_access will automatically raise a NotAuthorized\n    exception if an authenticated user is not provided in the context, without\n    calling the actual auth function.\n    '''\n    # type_ignore_reason: custom attribute\n    action.auth_allow_anonymous_access = False  # type: ignore\n    return action\n\n\ndef chained_auth_function(func: ChainedAuthFunction) -> ChainedAuthFunction:\n    '''\n    Decorator function allowing authentication functions to be chained.\n\n    This chain starts with the last chained auth function to be registered and\n    ends with the original auth function (or a non-chained plugin override\n    version). Chained auth functions must accept an extra parameter,\n    specifically the next auth function in the chain, for example::\n\n        auth_function(next_auth, context, data_dict).\n\n    The chained auth function may call the next_auth function, optionally\n    passing different values, handling exceptions, returning different\n    values and/or raising different exceptions to the caller.\n\n    Usage::\n\n        from ckan.plugins.toolkit import chained_auth_function\n\n        @chained_auth_function\n        @auth_allow_anonymous_access\n        def user_show(next_auth, context, data_dict=None):\n            return next_auth(context, data_dict)\n\n    :param func: chained authentication function\n    :type func: callable\n\n    :returns: chained authentication function\n    :rtype: callable\n\n    '''\n    # type_ignore_reason: custom attribute\n    func.chained_auth_function = True  # type: ignore\n    return func\n\n\nclass UnknownValidator(Exception):\n    '''Exception raised when a requested validator function cannot be found.\n\n    '''\n    pass\n\n\n_validators_cache: dict[str, Union[Validator, ValidatorFactory]] = {}\n\n\ndef clear_validators_cache() -> None:\n    _validators_cache.clear()\n\n\n# This function exists mainly so that validators can be made available to\n# extensions via ckan.plugins.toolkit.\ndef get_validator(\n        validator: str) -> Union[Validator, ValidatorFactory]:\n    '''Return a validator function by name.\n\n    :param validator: the name of the validator function to return,\n        eg. ``'package_name_exists'``\n    :type validator: string\n\n    :raises: :py:exc:`~ckan.plugins.toolkit.UnknownValidator` if the named\n        validator is not found\n\n    :returns: the named validator function\n    :rtype: ``types.FunctionType``\n\n    '''\n    if not _validators_cache:\n        validators = _import_module_functions('ckan.lib.navl.validators')\n        _validators_cache.update(validators)\n        validators = _import_module_functions('ckan.logic.validators')\n        _validators_cache.update(validators)\n        converters = _import_module_functions('ckan.logic.converters')\n        _validators_cache.update(converters)\n        _validators_cache.update({'OneOf': _validators_cache['one_of']})\n\n        for plugin in p.PluginImplementations(p.IValidators):\n            for name, fn in plugin.get_validators().items():\n                log.debug('Validator function {0} from plugin {1} was inserted'\n                          .format(name, plugin.name))\n                _validators_cache[name] = fn\n    try:\n        return _validators_cache[validator]\n    except KeyError:\n        raise UnknownValidator('Validator `%s` does not exist' % validator)\n\n\ndef model_name_to_class(model_module: Any, model_name: str) -> Any:\n    '''Return the class in model_module that has the same name as the\n    received string.\n\n    Raises AttributeError if there's no model in model_module named model_name.\n    '''\n    model_class_name = model_name.title()\n    try:\n        return getattr(model_module, model_class_name)\n    except AttributeError:\n        raise ValidationError({\n            \"message\": \"%s isn't a valid model\" % model_class_name})\n\n\ndef _import_module_functions(\n        module_path: str) -> dict[str, Callable[..., Any]]:\n    '''Import a module and get the functions and return them in a dict'''\n    module = importlib.import_module(module_path)\n    return {\n        k: v\n        for k, v in authz.get_local_functions(module)\n    }\n\n\n@contextmanager\ndef guard_against_duplicated_email(email: str):\n    try:\n        yield\n    except exc.IntegrityError as e:\n        if e.orig.pgcode == _PG_ERR_CODE[\"unique_violation\"]:\n            model.Session.rollback()\n            raise ValidationError({\n                \"email\": [\n                    \"The email address '{email}' belongs to \"\n                    \"a registered user.\".format(email=email)\n                ]\n            })\n        raise\n\n\ndef fresh_context(\n    context: Context,\n) -> Context:\n    \"\"\" Copy just the minimum fields into a new context\n        for cases in which we reuse the context and\n        we want a clean version with minimum fields \"\"\"\n    new_context = {\n        k: context[k] for k in (\n            'model', 'session', 'user', 'auth_user_obj',\n            'ignore_auth', 'defer_commit',\n        ) if k in context\n    }\n    new_context = cast(Context, new_context)\n    return new_context\n", "# -*- coding: utf-8 -*-\n\nfrom unittest import mock\nimport pytest\nfrom ckan import logic, model\nfrom ckan.types import Context\nimport ckan.tests.factories as factories\n\n\ndef test_model_name_to_class():\n    assert logic.model_name_to_class(model, \"package\") == model.Package\n    with pytest.raises(logic.ValidationError):\n        logic.model_name_to_class(model, \"inexistent_model_name\")\n\n\ndef test_check_access_auth_user_obj_is_not_set():\n\n    user_names = (\"unknown_user\", \"\", None)\n    for user_name in user_names:\n        context = {\"user\": user_name}\n\n        result = logic.check_access(\"package_search\", context)\n\n        assert result\n        assert context[\"__auth_user_obj_checked\"]\n        assert context[\"auth_user_obj\"] is None\n\n\n@pytest.mark.usefixtures(\"non_clean_db\")\ndef test_check_access_auth_user_obj_is_set():\n    user = factories.User()\n    context = {\"user\": user[\"name\"]}\n\n    result = logic.check_access(\"package_create\", context)\n\n    assert result\n    assert context[\"__auth_user_obj_checked\"]\n    assert context[\"auth_user_obj\"].name == user[\"name\"]\n\n\n@mock.patch(\"ckan.authz.is_authorized\")\ndef test_user_inside_context_of_check_access(is_authorized: mock.Mock):\n    logic.check_access(\"package_create\", {})\n    is_authorized.assert_called_once()\n    context = is_authorized.call_args[0][1]\n    assert context[\"user\"] == \"\"\n\n    is_authorized.reset_mock()\n\n    logic.check_access(\"package_create\", {\"user\": \"test\"})\n    context = is_authorized.call_args[0][1]\n    assert context[\"user\"] == \"test\"\n\n\ndef test_get_action_optional_params():\n\n    assert \"ckan_version\" in logic.get_action(\"status_show\")()\n\n\ndef test_fresh_context():\n    \"\"\" Test the fresh_context function.\n        It should return a new context object only with\n        'model', 'session', 'user', 'auth_user_obj', 'ignore_auth'\n        values (if they exists).\"\"\"\n\n    dirty_context: Context = {\n        \"user\": \"test\",\n        \"ignore_auth\": True,\n        \"to_be_cleaned\": \"test\",\n    }\n\n    cleaned_context = logic.fresh_context(dirty_context)\n\n    assert \"to_be_cleaned\" not in cleaned_context\n    assert cleaned_context[\"user\"] == \"test\"\n    assert cleaned_context[\"ignore_auth\"] is True\n    assert \"model\" not in cleaned_context\n    assert \"session\" not in cleaned_context\n    assert \"auth_user_obj\" not in cleaned_context\n\n\ndef test_check_access_auth_user_for_different_objects():\n    user1 = factories.User()\n    user2 = factories.User()\n    context = {\"user\": user1[\"name\"]}\n\n    organization1 = factories.Organization(user=user1)\n    organization2 = factories.Organization(user=user2)\n\n    datasets1 = [\n        factories.Dataset(owner_org=organization1[\"id\"], private=True)\n        for _ in range(0, 1)\n    ]\n    datasets2 = [\n        factories.Dataset(owner_org=organization2[\"id\"], private=True)\n        for _ in range(0, 1)\n    ]\n    dataset3 = datasets1 + datasets2\n\n    with pytest.raises(logic.NotAuthorized):\n        for dataset in dataset3:\n            logic.check_access(\"package_show\", context, {'id': dataset[\"id\"]})\n"], "fixing_code": ["# encoding: utf-8\nfrom __future__ import annotations\nfrom contextlib import contextmanager\n\nimport functools\nimport logging\nimport re\nimport importlib\n\nfrom collections import defaultdict\nfrom typing import (Any, Callable, Container, Iterable, Optional,\n                    TypeVar, Union, cast, overload)\nfrom typing_extensions import Literal\n\nfrom werkzeug.datastructures import MultiDict\nfrom sqlalchemy import exc\n\nimport ckan.model as model\nimport ckan.authz as authz\nimport ckan.lib.navl.dictization_functions as df\nimport ckan.plugins as p\nimport ckan.lib.signals as signals\n\nfrom ckan.common import _, g\nfrom ckan.types import (\n    Action, ChainedAction,\n    ChainedAuthFunction, DataDict, ErrorDict, Context, FlattenDataDict,\n    FlattenKey, Schema, Validator, ValidatorFactory\n)\n\nDecorated = TypeVar(\"Decorated\")\n\nlog = logging.getLogger(__name__)\n_validate = df.validate\n\n_PG_ERR_CODE = {'unique_violation': '23505'}\n\n\nclass NameConflict(Exception):\n    pass\n\n\nclass UsernamePasswordError(Exception):\n    pass\n\n\nclass ActionError(Exception):\n    message: Optional[str]\n\n    def __init__(self, message: Optional[str] = '') -> None:\n        self.message = message\n        super(ActionError, self).__init__(message)\n\n    def __str__(self):\n        msg = self.message\n        if not isinstance(msg, str):\n            msg = str(msg)\n        return msg\n\n\nclass NotFound(ActionError):\n    '''Exception raised by logic functions when a given object is not found.\n\n    For example :py:func:`~ckan.logic.action.get.package_show` raises\n    :py:exc:`~ckan.plugins.toolkit.ObjectNotFound` if no package with the\n    given ``id`` exists.\n\n    '''\n    pass\n\n\nclass NotAuthorized(ActionError):\n    '''Exception raised when the user is not authorized to call the action.\n\n    For example :py:func:`~ckan.logic.action.create.package_create` raises\n    :py:exc:`~ckan.plugins.toolkit.NotAuthorized` if the user is not authorized\n    to create packages.\n    '''\n    pass\n\n\nclass ValidationError(ActionError):\n    '''Exception raised by action functions when validating their given\n    ``data_dict`` fails.\n\n    '''\n    error_dict: ErrorDict\n\n    def __init__(self,\n                 errors: Union[str, ErrorDict],\n                 error_summary: Optional[dict[str, str]] = None,\n                 extra_msg: Optional[str] = None) -> None:\n        if not isinstance(errors, dict):\n            error_dict: ErrorDict = {'message': errors}\n        else:\n            error_dict = errors\n        # tags errors are a mess so let's clean them up\n        if 'tags' in error_dict:\n            tag_errors: list[Union[str, dict[str, Any]]] = []\n            for error in cast(\"list[dict[str, Any]]\", error_dict['tags']):\n                try:\n                    tag_errors.append(', '.join(error['name']))\n                except KeyError:\n                    # e.g. if it is a vocabulary_id error\n                    if error:\n                        tag_errors.append(error)\n            error_dict['tags'] = tag_errors\n        self.error_dict = error_dict\n        self._error_summary = error_summary\n        super(ValidationError, self).__init__(extra_msg)\n\n    @property\n    def error_summary(self) -> dict[str, str]:\n        ''' autogenerate the summary if not supplied '''\n        def summarise(error_dict: ErrorDict) -> dict[str, str]:\n            ''' Do some i18n stuff on the error_dict keys '''\n\n            def prettify(field_name: str):\n                field_name = re.sub(r'(?<!\\w)[Uu]rl(?!\\w)', 'URL',\n                                    field_name.replace('_', ' ').capitalize())\n                return _(field_name.replace('_', ' '))\n\n            summary = {}\n\n            for key, error in error_dict.items():\n                if key == 'resources':\n                    summary[_('Resources')] = _('Package resource(s) invalid')\n                elif key == 'extras':\n                    errors_extras = []\n                    for item in cast(\"list[dict[str, Any]]\", error):\n                        if (item.get('key') and\n                                item['key'][0] not in errors_extras):\n                            errors_extras.append(item['key'][0])\n                    summary[_('Extras')] = ', '.join(errors_extras)\n                elif key == 'extras_validation':\n                    assert isinstance(error, list)\n                    summary[_('Extras')] = error[0]\n                elif key == 'tags':\n                    assert isinstance(error, list)\n                    summary[_('Tags')] = error[0]\n                else:\n                    assert isinstance(error, list)\n                    summary[_(prettify(key))] = error[0]\n            return summary\n\n        if self._error_summary:\n            return self._error_summary\n        return summarise(self.error_dict)\n\n    def __str__(self):\n        err_msgs = (super(ValidationError, self).__str__(),\n                    self.error_dict)\n        return ' - '.join([str(err_msg) for err_msg in err_msgs if err_msg])\n\n\ndef checks_and_delete_if_csrf_token_in_forms(parsed: dict[str, Any]):\n    '''\n    Checks and delete, if the csrf_token is in \"parsed\".\n    We don't want the csrf_token to be a part of a data_dict\n    as it will expose the token to the metadata.\n    This way we are deleting the token from every data_dict that fills\n    from request.form instead of deleting it separately in every\n    view/blueprint.\n    '''\n    from ckan.common import config\n\n    # WTF_CSRF_FIELD_NAME is added by flask_wtf\n    csrf_token = config.get(\"WTF_CSRF_FIELD_NAME\")\n    if csrf_token in parsed:\n        parsed.pop(csrf_token)\n    return parsed\n\n\ndef parse_params(\n    params: 'MultiDict[str, Any]',\n    ignore_keys: Optional['Container[str]'] = None\n) -> dict[str, Union[str, list[str]]]:\n    '''Takes a dict and returns it with some values standardised.\n    This is done on a dict before calling tuplize_dict on it.\n    '''\n    parsed = {}\n    for key in params:\n        if ignore_keys and key in ignore_keys:\n            continue\n        # flask request has `getlist` instead of pylons' `getall`\n\n        if hasattr(params, 'getall'):\n            # type_ignore_reason: pylons legacy\n            value = params.getall(key)  # type: ignore\n        else:\n            value = params.getlist(key)\n\n        # Blank values become ''\n        if not value:\n            value = ''\n        # A list with only one item is stripped of being a list\n        if len(value) == 1:\n            value = value[0]\n        parsed[key] = value\n\n    parsed = checks_and_delete_if_csrf_token_in_forms(parsed)\n    return parsed\n\n\ndef clean_dict(data_dict: dict[str, Any]) -> dict[str, Any]:\n    '''Takes a dict and if any of the values are lists of dicts,\n    the empty dicts are stripped from the lists (recursive).\n\n    e.g.\n    >>> clean_dict(\n        {'name': u'testgrp4',\n         'title': u'',\n         'description': u'',\n         'packages': [{'name': u'testpkg'}, {'name': u'testpkg'}],\n         'extras': [{'key': u'packages', 'value': u'[\"testpkg\"]'},\n                    {'key': u'', 'value': u''},\n                    {'key': u'', 'value': u''}],\n         'state': u'active'}\n    {'name': u'testgrp4',\n     'title': u'',\n     'description': u'',\n     'packages': [{'name': u'testpkg'}, {'name': u'testpkg'}],\n     'extras': [{'key': u'packages', 'value': u'[\"testpkg\"]'}],\n     'state': u'active'}\n\n    '''\n    for value in data_dict.values():\n        if not isinstance(value, list):\n            continue\n        for inner_dict in value[:]:\n            if isinstance(inner_dict, str):\n                break\n            if not any(inner_dict.values()):\n                value.remove(inner_dict)\n            else:\n                clean_dict(inner_dict)\n    return data_dict\n\n\ndef tuplize_dict(data_dict: dict[str, Any]) -> FlattenDataDict:\n    '''Takes a dict with keys of the form 'table__0__key' and converts them\n    to a tuple like ('table', 0, 'key').\n\n    Dict should be put through parse_dict before this function, to have\n    values standardized.\n\n    May raise a DataError if the format of the key is incorrect.\n    '''\n    tuplized_dict: FlattenDataDict = {}\n    for k, value in data_dict.items():\n        key_list = cast(\"list[Union[str, int]]\", k.split('__'))\n        for num, key in enumerate(key_list):\n            if num % 2 == 1:\n                try:\n                    key_list[num] = int(key)\n                except ValueError:\n                    raise df.DataError('Bad key')\n        tuplized_dict[tuple(key_list)] = value\n\n    # Sanitize key indexes to make sure they are sequential\n    seq_tuplized_dict: FlattenDataDict = {}\n    # sequential field indexes grouped by common prefix\n    groups: dict[FlattenKey, dict[FlattenKey, int]] = defaultdict(dict)\n    for key in sorted(tuplized_dict.keys()):\n        new_key = key\n\n        # iterate over even(numeric) parts of the key\n        for idx in range(1, len(key), 2):\n            # narrow down scope by common prefix\n            group = groups[key[:idx]]\n\n            # if the identifier(i.e `(extra, 123)`, `(resource, 9)`) is met for\n            # the first time, generate for it next number in the index\n            # sequence. Index of the latest added item is always equals to the\n            # number of unique identifiers minus one(because list indexation\n            # starts from 0 in Python). If identifier already present(i.e, we\n            # process `(extra, 10, VALUE)` after processing `(extra, 10,\n            # KEY)`), reuse sequential index of this identifier\n            seq_index = group.setdefault(key[idx-1:idx+1], len(group))\n\n            # replace the currently processed key segment with computed\n            # sequential index\n            new_key = new_key[:idx] + (seq_index,) + new_key[idx+1:]\n\n        seq_tuplized_dict[new_key] = tuplized_dict[key]\n\n    return seq_tuplized_dict\n\n\ndef untuplize_dict(tuplized_dict: FlattenDataDict) -> dict[str, Any]:\n\n    data_dict = {}\n    for key, value in tuplized_dict.items():\n        new_key = '__'.join([str(item) for item in key])\n        data_dict[new_key] = value\n    return data_dict\n\n\ndef flatten_to_string_key(dict: dict[str, Any]) -> dict[str, Any]:\n\n    flattented = df.flatten_dict(dict)\n    return untuplize_dict(flattented)\n\n\ndef _prepopulate_context(context: Optional[Context]) -> Context:\n    if context is None:\n        context = {}\n    context.setdefault('model', model)\n    context.setdefault('session', model.Session)\n\n    try:\n        user = g.user\n    except AttributeError:\n        # g.user not set\n        user = \"\"\n    except RuntimeError:\n        # Outside of request context\n        user = \"\"\n    except TypeError:\n        # g not registered\n        user = \"\"\n\n    context.setdefault('user', user)\n    return context\n\n\ndef check_access(action: str,\n                 context: Context,\n                 data_dict: Optional[dict[str, Any]] = None) -> Literal[True]:\n    '''Calls the authorization function for the provided action\n\n    This is the only function that should be called to determine whether a\n    user (or an anonymous request) is allowed to perform a particular action.\n\n    The function accepts a context object, which should contain a 'user' key\n    with the name of the user performing the action, and optionally a\n    dictionary with extra data to be passed to the authorization function.\n\n    For example::\n\n        check_access('package_update', context, data_dict)\n\n    If not already there, the function will add an `auth_user_obj` key to the\n    context object with the actual User object (in case it exists in the\n    database). This check is only performed once per context object.\n\n    Raise :py:exc:`~ckan.plugins.toolkit.NotAuthorized` if the user is not\n    authorized to call the named action function.\n\n    If the user *is* authorized to call the action, return ``True``.\n\n    :param action: the name of the action function, eg. ``'package_create'``\n    :type action: string\n\n    :param context:\n    :type context: dict\n\n    :param data_dict:\n    :type data_dict: dict\n\n    :raises: :py:exc:`~ckan.plugins.toolkit.NotAuthorized` if the user is not\n        authorized to call the named action\n\n    '''\n\n    # Auth Auditing.  We remove this call from the __auth_audit stack to show\n    # we have called the auth function\n    try:\n        audit: Optional[tuple[str, int]] = context.get('__auth_audit', [])[-1]\n    except IndexError:\n        audit = None\n    if audit and audit[0] == action:\n        context['__auth_audit'].pop()\n\n    if 'auth_user_obj' not in context:\n        context['auth_user_obj'] = None\n\n    context = _prepopulate_context(context)\n\n    if not context.get('__auth_user_obj_checked'):\n        if context[\"user\"] and not context[\"auth_user_obj\"]:\n            context['auth_user_obj'] = model.User.get(context['user'])\n        context['__auth_user_obj_checked'] = True\n\n    try:\n        logic_authorization = authz.is_authorized(action, context, data_dict)\n        if not logic_authorization['success']:\n            msg = cast(str, logic_authorization.get('msg', ''))\n            raise NotAuthorized(msg)\n    except NotAuthorized as e:\n        log.debug(u'check access NotAuthorized - %s user=%s \"%s\"',\n                  action, context[\"user\"], str(e))\n        raise\n\n    log.debug('check access OK - %s user=%s', action, context[\"user\"])\n    return True\n\n\n_actions: dict[str, Action] = {}\n\n\ndef clear_actions_cache() -> None:\n    _actions.clear()\n\n\ndef chained_action(func: ChainedAction) -> ChainedAction:\n    '''Decorator function allowing action function to be chained.\n\n    This allows a plugin to modify the behaviour of an existing action\n    function. A Chained action function must be defined as\n    ``action_function(original_action, context, data_dict)`` where the\n    first parameter will be set to the action function in the next plugin\n    or in core ckan. The chained action may call the original_action\n    function, optionally passing different values, handling exceptions,\n    returning different values and/or raising different exceptions\n    to the caller.\n\n    Usage::\n\n        from ckan.plugins.toolkit import chained_action\n\n        @chained_action\n        @side_effect_free\n        def package_search(original_action, context, data_dict):\n            return original_action(context, data_dict)\n\n    :param func: chained action function\n    :type func: callable\n\n    :returns: chained action function\n    :rtype: callable\n\n    '''\n    # type_ignore_reason: custom attribute\n    func.chained_action = True  # type: ignore\n\n    return func\n\n\ndef _is_chained_action(func: Action) -> bool:\n    return getattr(func, 'chained_action', False)\n\n\ndef get_action(action: str) -> Action:\n    '''Return the named :py:mod:`ckan.logic.action` function.\n\n    For example ``get_action('package_create')`` will normally return the\n    :py:func:`ckan.logic.action.create.package_create()` function.\n\n    For documentation of the available action functions, see\n    :ref:`api-reference`.\n\n    You should always use ``get_action()`` instead of importing an action\n    function directly, because :py:class:`~ckan.plugins.interfaces.IActions`\n    plugins can override action functions, causing ``get_action()`` to return a\n    plugin-provided function instead of the default one.\n\n    Usage::\n\n        import ckan.plugins.toolkit as toolkit\n\n        # Call the package_create action function:\n        toolkit.get_action('package_create')(context, data_dict)\n\n    As the context parameter passed to an action function is commonly::\n\n        context = {'model': ckan.model, 'session': ckan.model.Session,\n                   'user': user}\n\n    an action function returned by ``get_action()`` will automatically add\n    these parameters to the context if they are not defined.  This is\n    especially useful for plugins as they should not really be importing parts\n    of ckan eg :py:mod:`ckan.model` and as such do not have access to ``model``\n    or ``model.Session``.\n\n    If a ``context`` of ``None`` is passed to the action function then the\n    default context dict will be created.\n\n    .. note::\n\n        Many action functions modify the context dict. It can therefore\n        not be reused for multiple calls of the same or different action\n        functions.\n\n    :param action: name of the action function to return,\n        eg. ``'package_create'``\n    :type action: string\n\n    :returns: the named action function\n    :rtype: callable\n\n    '''\n\n    if _actions:\n        if action not in _actions:\n            raise KeyError(\"Action '%s' not found\" % action)\n        return _actions[action]\n    # Otherwise look in all the plugins to resolve all possible First\n    # get the default ones in the ckan/logic/action directory Rather\n    # than writing them out in full will use importlib.import_module\n    # to load anything from ckan.logic.action that looks like it might\n    # be an action\n    for action_module_name in ['get', 'create', 'update', 'delete', 'patch']:\n        module = importlib.import_module(\n            '.' + action_module_name, 'ckan.logic.action')\n        for k, v in authz.get_local_functions(module):\n            _actions[k] = v\n            # Allow all actions defined in logic/action/get.py to\n            # be side-effect free.\n            if action_module_name == 'get' and \\\n               not hasattr(v, 'side_effect_free'):\n                v.side_effect_free = True\n\n    # Then overwrite them with any specific ones in the plugins:\n    resolved_action_plugins: dict[str, str] = {}\n    fetched_actions = {}\n    chained_actions = defaultdict(list)\n    for plugin in p.PluginImplementations(p.IActions):\n        for name, action_function in plugin.get_actions().items():\n            if _is_chained_action(action_function):\n                chained_actions[name].append(action_function)\n            elif name in resolved_action_plugins:\n                raise NameConflict(\n                    'The action %r is already implemented in %r' % (\n                        name,\n                        resolved_action_plugins[name]\n                    )\n                )\n            else:\n                resolved_action_plugins[name] = plugin.name\n                # Extensions are exempted from the auth audit for now\n                # This needs to be resolved later\n                # type_ignore_reason: custom attribute\n                action_function.auth_audit_exempt = True  # type: ignore\n                fetched_actions[name] = action_function\n    for name, func_list in chained_actions.items():\n        if name not in fetched_actions and name not in _actions:\n            # nothing to override from plugins or core\n            raise NotFound('The action %r is not found for chained action' % (\n                name))\n        for func in reversed(func_list):\n            # try other plugins first, fall back to core\n            prev_func = fetched_actions.get(name, _actions.get(name))\n            new_func = functools.partial(func, prev_func)\n            # persisting attributes to the new partial function\n            for attribute, value in func.__dict__.items():\n                setattr(new_func, attribute, value)\n            fetched_actions[name] = new_func\n\n    # Use the updated ones in preference to the originals.\n    _actions.update(fetched_actions)\n\n    # wrap the functions\n    for action_name, _action in _actions.items():\n        def make_wrapped(_action: Action, action_name: str):\n            def wrapped(context: Optional[Context] = None,\n                        data_dict: Optional[DataDict] = None, **kw: Any):\n                if kw:\n                    log.critical('%s was passed extra keywords %r'\n                                 % (_action.__name__, kw))\n\n                context = _prepopulate_context(context)\n\n                if data_dict is None:\n                    data_dict = {}\n\n                # Auth Auditing - checks that the action function did call\n                # check_access (unless there is no accompanying auth function).\n                # We push the action name and id onto the __auth_audit stack\n                # before calling the action, and check_access removes it.\n                # (We need the id of the action in case the action is wrapped\n                # inside an action of the same name, which happens in the\n                # datastore)\n                context.setdefault('__auth_audit', [])\n                context['__auth_audit'].append((action_name, id(_action)))\n\n                # check_access(action_name, context, data_dict=None)\n                result = _action(context, data_dict, **kw)\n                try:\n                    audit = context['__auth_audit'][-1]\n                    if audit[0] == action_name and audit[1] == id(_action):\n                        if action_name not in authz.auth_functions_list():\n                            log.debug('No auth function for %s' % action_name)\n                        elif not getattr(_action, 'auth_audit_exempt', False):\n                            raise Exception(\n                                'Action function {0} did not call its '\n                                'auth function'\n                                .format(action_name))\n                        # remove from audit stack\n                        context['__auth_audit'].pop()\n                except IndexError:\n                    pass\n\n                signals.action_succeeded.send(\n                    action_name, context=context, data_dict=data_dict,\n                    result=result)\n                return result\n            return wrapped\n\n        fn = make_wrapped(_action, action_name)\n        # we need to mirror the docstring\n        fn.__doc__ = _action.__doc__\n        # we need to retain the side effect free behaviour\n        if getattr(_action, 'side_effect_free', False):\n            # type_ignore_reason: custom attribute\n            fn.side_effect_free = True  # type: ignore\n        _actions[action_name] = fn\n\n    return _actions[action]\n\n\n@overload\ndef get_or_bust(data_dict: dict[str, Any], keys: str) -> Any:\n    ...\n\n\n@overload\ndef get_or_bust(\n        data_dict: dict[str, Any], keys: Iterable[str]) -> tuple[Any, ...]:\n    ...\n\n\ndef get_or_bust(\n        data_dict: dict[str, Any],\n        keys: Union[str, Iterable[str]]) -> Union[Any, tuple[Any, ...]]:\n    '''Return the value(s) from the given data_dict for the given key(s).\n\n    Usage::\n\n        single_value = get_or_bust(data_dict, 'a_key')\n        value_1, value_2 = get_or_bust(data_dict, ['key1', 'key2'])\n\n    :param data_dict: the dictionary to return the values from\n    :type data_dict: dictionary\n\n    :param keys: the key(s) for the value(s) to return\n    :type keys: either a string or a list\n\n    :returns: a single value from the dict if a single key was given,\n        or a tuple of values if a list of keys was given\n\n    :raises: :py:exc:`ckan.logic.ValidationError` if one of the given keys is\n        not in the given dictionary\n\n    '''\n    if isinstance(keys, str):\n        keys = [keys]\n\n    from ckan.logic.schema import create_schema_for_required_keys\n    schema = create_schema_for_required_keys(keys)\n\n    data_dict, errors = _validate(data_dict, schema)\n\n    if errors:\n        raise ValidationError(errors)\n\n    # preserve original key order\n    values = [data_dict[key] for key in keys]\n    if len(values) == 1:\n        return values[0]\n    return tuple(values)\n\n\ndef validate(schema_func: Callable[[], Schema],\n             can_skip_validator: bool = False) -> Callable[[Action], Action]:\n    ''' A decorator that validates an action function against a given schema\n    '''\n    def action_decorator(action: Action) -> Action:\n        @functools.wraps(action)\n        def wrapper(context: Context, data_dict: DataDict):\n            if can_skip_validator:\n                if context.get('skip_validation'):\n                    return action(context, data_dict)\n\n            schema = context.get('schema', schema_func())\n            data_dict, errors = _validate(data_dict, schema, context)\n            if errors:\n                raise ValidationError(errors)\n            return action(context, data_dict)\n        return wrapper\n    return action_decorator\n\n\ndef side_effect_free(action: Decorated) -> Decorated:\n    '''A decorator that marks the given action function as side-effect-free.\n\n    Action functions decorated with this decorator can be called with an HTTP\n    GET request to the :doc:`Action API </api/index>`. Action functions that\n    don't have this decorator must be called with a POST request.\n\n    If your CKAN extension defines its own action functions using the\n    :py:class:`~ckan.plugins.interfaces.IActions` plugin interface, you can use\n    this decorator to make your actions available with GET requests instead of\n    just with POST requests.\n\n    Example::\n\n        import ckan.plugins.toolkit as toolkit\n\n        @toolkit.side_effect_free\n        def my_custom_action_function(context, data_dict):\n            ...\n\n    (Then implement :py:class:`~ckan.plugins.interfaces.IActions` to register\n    your action function with CKAN.)\n\n    '''\n    # type_ignore_reason: custom attribute\n    action.side_effect_free = True  # type: ignore\n    return action\n\n\ndef auth_sysadmins_check(action: Decorated) -> Decorated:\n    '''A decorator that prevents sysadmins from being automatically authorized\n    to call an action function.\n\n    Normally sysadmins are allowed to call any action function (for example\n    when they're using the :doc:`Action API </api/index>` or the web\n    interface), if the user is a sysadmin the action function's authorization\n    function will not even be called.\n\n    If an action function is decorated with this decorator, then its\n    authorization function will always be called, even if the user is a\n    sysadmin.\n\n    '''\n    # type_ignore_reason: custom attribute\n    action.auth_sysadmins_check = True  # type: ignore\n    return action\n\n\ndef auth_audit_exempt(action: Decorated) -> Decorated:\n    ''' Dirty hack to stop auth audit being done '''\n    # type_ignore_reason: custom attribute\n    action.auth_audit_exempt = True  # type: ignore\n    return action\n\n\ndef auth_allow_anonymous_access(action: Decorated) -> Decorated:\n    ''' Flag an auth function as not requiring a logged in user\n\n    This means that check_access won't automatically raise a NotAuthorized\n    exception if an authenticated user is not provided in the context. (The\n    auth function can still return False if for some reason access is not\n    granted).\n    '''\n    # type_ignore_reason: custom attribute\n    action.auth_allow_anonymous_access = True  # type: ignore\n    return action\n\n\ndef auth_disallow_anonymous_access(action: Decorated) -> Decorated:\n    ''' Flag an auth function as requiring a logged in user\n\n    This means that check_access will automatically raise a NotAuthorized\n    exception if an authenticated user is not provided in the context, without\n    calling the actual auth function.\n    '''\n    # type_ignore_reason: custom attribute\n    action.auth_allow_anonymous_access = False  # type: ignore\n    return action\n\n\ndef chained_auth_function(func: ChainedAuthFunction) -> ChainedAuthFunction:\n    '''\n    Decorator function allowing authentication functions to be chained.\n\n    This chain starts with the last chained auth function to be registered and\n    ends with the original auth function (or a non-chained plugin override\n    version). Chained auth functions must accept an extra parameter,\n    specifically the next auth function in the chain, for example::\n\n        auth_function(next_auth, context, data_dict).\n\n    The chained auth function may call the next_auth function, optionally\n    passing different values, handling exceptions, returning different\n    values and/or raising different exceptions to the caller.\n\n    Usage::\n\n        from ckan.plugins.toolkit import chained_auth_function\n\n        @chained_auth_function\n        @auth_allow_anonymous_access\n        def user_show(next_auth, context, data_dict=None):\n            return next_auth(context, data_dict)\n\n    :param func: chained authentication function\n    :type func: callable\n\n    :returns: chained authentication function\n    :rtype: callable\n\n    '''\n    # type_ignore_reason: custom attribute\n    func.chained_auth_function = True  # type: ignore\n    return func\n\n\nclass UnknownValidator(Exception):\n    '''Exception raised when a requested validator function cannot be found.\n\n    '''\n    pass\n\n\n_validators_cache: dict[str, Union[Validator, ValidatorFactory]] = {}\n\n\ndef clear_validators_cache() -> None:\n    _validators_cache.clear()\n\n\n# This function exists mainly so that validators can be made available to\n# extensions via ckan.plugins.toolkit.\ndef get_validator(\n        validator: str) -> Union[Validator, ValidatorFactory]:\n    '''Return a validator function by name.\n\n    :param validator: the name of the validator function to return,\n        eg. ``'package_name_exists'``\n    :type validator: string\n\n    :raises: :py:exc:`~ckan.plugins.toolkit.UnknownValidator` if the named\n        validator is not found\n\n    :returns: the named validator function\n    :rtype: ``types.FunctionType``\n\n    '''\n    if not _validators_cache:\n        validators = _import_module_functions('ckan.lib.navl.validators')\n        _validators_cache.update(validators)\n        validators = _import_module_functions('ckan.logic.validators')\n        _validators_cache.update(validators)\n        converters = _import_module_functions('ckan.logic.converters')\n        _validators_cache.update(converters)\n        _validators_cache.update({'OneOf': _validators_cache['one_of']})\n\n        for plugin in p.PluginImplementations(p.IValidators):\n            for name, fn in plugin.get_validators().items():\n                log.debug('Validator function {0} from plugin {1} was inserted'\n                          .format(name, plugin.name))\n                _validators_cache[name] = fn\n    try:\n        return _validators_cache[validator]\n    except KeyError:\n        raise UnknownValidator('Validator `%s` does not exist' % validator)\n\n\ndef model_name_to_class(model_module: Any, model_name: str) -> Any:\n    '''Return the class in model_module that has the same name as the\n    received string.\n\n    Raises AttributeError if there's no model in model_module named model_name.\n    '''\n    model_class_name = model_name.title()\n    try:\n        return getattr(model_module, model_class_name)\n    except AttributeError:\n        raise ValidationError({\n            \"message\": \"%s isn't a valid model\" % model_class_name})\n\n\ndef _import_module_functions(\n        module_path: str) -> dict[str, Callable[..., Any]]:\n    '''Import a module and get the functions and return them in a dict'''\n    module = importlib.import_module(module_path)\n    return {\n        k: v\n        for k, v in authz.get_local_functions(module)\n    }\n\n\n@contextmanager\ndef guard_against_duplicated_email(email: str):\n    try:\n        yield\n    except exc.IntegrityError as e:\n        if e.orig.pgcode == _PG_ERR_CODE[\"unique_violation\"]:\n            model.Session.rollback()\n            raise ValidationError({\n                \"email\": [\n                    \"The email address '{email}' belongs to \"\n                    \"a registered user.\".format(email=email)\n                ]\n            })\n        raise\n\n\ndef fresh_context(\n    context: Context,\n) -> Context:\n    \"\"\" Copy just the minimum fields into a new context\n        for cases in which we reuse the context and\n        we want a clean version with minimum fields \"\"\"\n    new_context = {\n        k: context[k] for k in (\n            'model', 'session', 'user', 'auth_user_obj',\n            'ignore_auth', 'defer_commit',\n        ) if k in context\n    }\n    new_context = cast(Context, new_context)\n    return new_context\n", "# -*- coding: utf-8 -*-\n\nfrom unittest import mock\nimport pytest\nfrom ckan import logic, model\nimport ckan.lib.navl.dictization_functions as df\n\nfrom ckan.types import Context\nimport ckan.tests.factories as factories\n\n\ndef test_model_name_to_class():\n    assert logic.model_name_to_class(model, \"package\") == model.Package\n    with pytest.raises(logic.ValidationError):\n        logic.model_name_to_class(model, \"inexistent_model_name\")\n\n\ndef test_check_access_auth_user_obj_is_not_set():\n\n    user_names = (\"unknown_user\", \"\", None)\n    for user_name in user_names:\n        context = {\"user\": user_name}\n\n        result = logic.check_access(\"package_search\", context)\n\n        assert result\n        assert context[\"__auth_user_obj_checked\"]\n        assert context[\"auth_user_obj\"] is None\n\n\n@pytest.mark.usefixtures(\"non_clean_db\")\ndef test_check_access_auth_user_obj_is_set():\n    user = factories.User()\n    context = {\"user\": user[\"name\"]}\n\n    result = logic.check_access(\"package_create\", context)\n\n    assert result\n    assert context[\"__auth_user_obj_checked\"]\n    assert context[\"auth_user_obj\"].name == user[\"name\"]\n\n\n@mock.patch(\"ckan.authz.is_authorized\")\ndef test_user_inside_context_of_check_access(is_authorized: mock.Mock):\n    logic.check_access(\"package_create\", {})\n    is_authorized.assert_called_once()\n    context = is_authorized.call_args[0][1]\n    assert context[\"user\"] == \"\"\n\n    is_authorized.reset_mock()\n\n    logic.check_access(\"package_create\", {\"user\": \"test\"})\n    context = is_authorized.call_args[0][1]\n    assert context[\"user\"] == \"test\"\n\n\ndef test_get_action_optional_params():\n\n    assert \"ckan_version\" in logic.get_action(\"status_show\")()\n\n\ndef test_fresh_context():\n    \"\"\" Test the fresh_context function.\n        It should return a new context object only with\n        'model', 'session', 'user', 'auth_user_obj', 'ignore_auth'\n        values (if they exists).\"\"\"\n\n    dirty_context: Context = {\n        \"user\": \"test\",\n        \"ignore_auth\": True,\n        \"to_be_cleaned\": \"test\",\n    }\n\n    cleaned_context = logic.fresh_context(dirty_context)\n\n    assert \"to_be_cleaned\" not in cleaned_context\n    assert cleaned_context[\"user\"] == \"test\"\n    assert cleaned_context[\"ignore_auth\"] is True\n    assert \"model\" not in cleaned_context\n    assert \"session\" not in cleaned_context\n    assert \"auth_user_obj\" not in cleaned_context\n\n\ndef test_check_access_auth_user_for_different_objects():\n    user1 = factories.User()\n    user2 = factories.User()\n    context = {\"user\": user1[\"name\"]}\n\n    organization1 = factories.Organization(user=user1)\n    organization2 = factories.Organization(user=user2)\n\n    datasets1 = [\n        factories.Dataset(owner_org=organization1[\"id\"], private=True)\n        for _ in range(0, 1)\n    ]\n    datasets2 = [\n        factories.Dataset(owner_org=organization2[\"id\"], private=True)\n        for _ in range(0, 1)\n    ]\n    dataset3 = datasets1 + datasets2\n\n    with pytest.raises(logic.NotAuthorized):\n        for dataset in dataset3:\n            logic.check_access(\"package_show\", context, {'id': dataset[\"id\"]})\n\n\ndef test_tuplize_dict():\n\n    data_dict = {\n        \"author\": \"Test Author\",\n        \"extras__0__key\": \"extra1\",\n        \"extras__0__value\": \"value1\",\n        \"extras__1__key\": \"extra2\",\n        \"extras__1__value\": \"value2\",\n        \"extras__2__key\": \"extra3\",\n        \"extras__2__value\": \"value3\",\n        \"extras__3__key\": \"\",\n        \"extras__3__value\": \"\",\n        \"groups__0__id\": \"5a65eae8-ef2b-4a85-8022-d9e5a71ad074\",\n        \"name\": \"test-title\",\n        \"notes\": \"Test desc\",\n        \"owner_org\": \"5a65eae8-ef2b-4a85-8022-d9e5a71ad074\",\n        \"private\": \"True\",\n        \"tag_string\": \"economy,climate\",\n        \"title\": \"Test title\",\n    }\n\n    expected = {\n        (\"author\",): \"Test Author\",\n        (\"extras\", 0, \"key\"): \"extra1\",\n        (\"extras\", 0, \"value\"): \"value1\",\n        (\"extras\", 1, \"key\"): \"extra2\",\n        (\"extras\", 1, \"value\"): \"value2\",\n        (\"extras\", 2, \"key\"): \"extra3\",\n        (\"extras\", 2, \"value\"): \"value3\",\n        (\"extras\", 3, \"key\"): \"\",\n        (\"extras\", 3, \"value\"): \"\",\n        (\"groups\", 0, \"id\"): \"5a65eae8-ef2b-4a85-8022-d9e5a71ad074\",\n        (\"name\",): \"test-title\",\n        (\"notes\",): \"Test desc\",\n        (\"owner_org\",): \"5a65eae8-ef2b-4a85-8022-d9e5a71ad074\",\n        (\"private\",): \"True\",\n        (\"tag_string\",): \"economy,climate\",\n        (\"title\",): \"Test title\",\n    }\n\n    assert logic.tuplize_dict(data_dict) == expected\n\n\ndef test_tuplize_dict_random_indexes():\n\n    data_dict = {\n        \"extras__22__key\": \"extra2\",\n        \"extras__22__value\": \"value2\",\n        \"extras__1__key\": \"extra1\",\n        \"extras__1__value\": \"value1\",\n        \"extras__245566546__key\": \"extra3\",\n        \"extras__245566546__value\": \"value3\",\n        \"groups__13__id\": \"group2\",\n        \"groups__1__id\": \"group1\",\n        \"groups__13__nested__7__name\": \"latter\",\n        \"groups__13__nested__2__name\": \"former\",\n\n    }\n\n    expected = {\n        (\"extras\", 0, \"key\"): \"extra1\",\n        (\"extras\", 0, \"value\"): \"value1\",\n        (\"extras\", 1, \"key\"): \"extra2\",\n        (\"extras\", 1, \"value\"): \"value2\",\n        (\"extras\", 2, \"key\"): \"extra3\",\n        (\"extras\", 2, \"value\"): \"value3\",\n        (\"groups\", 0, \"id\"): \"group1\",\n        (\"groups\", 1, \"id\"): \"group2\",\n        (\"groups\", 1, \"nested\", 0, \"name\"): \"former\",\n        (\"groups\", 1, \"nested\", 1, \"name\"): \"latter\",\n    }\n\n    assert logic.tuplize_dict(data_dict) == expected\n\n\ndef test_tuplize_dict_wrong_index():\n\n    with pytest.raises(df.DataError):\n        data_dict = {\n            \"extras__2a__key\": \"extra\",\n        }\n        logic.tuplize_dict(data_dict)\n"], "filenames": ["ckan/logic/__init__.py", "ckan/tests/logic/test_logic.py"], "buggy_code_start_loc": [28, 5], "buggy_code_end_loc": [259, 102], "fixing_code_start_loc": [28, 6], "fixing_code_end_loc": [288, 189], "type": "CWE-130", "message": "CKAN is an open-source data management system for powering data hubs and data portals. Starting in version 2.0.0 and prior to versions 2.9.10 and 2.10.3, when submitting a POST request to the `/dataset/new` endpoint (including either the auth cookie or the `Authorization` header) with a specially-crafted field, an attacker can create an out-of-memory error in the hosting server. To trigger this error, the attacker need to have permissions to create or edit datasets. This vulnerability has been patched in CKAN 2.10.3 and 2.9.10.", "other": {"cve": {"id": "CVE-2023-50248", "sourceIdentifier": "security-advisories@github.com", "published": "2023-12-13T21:15:08.660", "lastModified": "2023-12-18T19:56:50.123", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "CKAN is an open-source data management system for powering data hubs and data portals. Starting in version 2.0.0 and prior to versions 2.9.10 and 2.10.3, when submitting a POST request to the `/dataset/new` endpoint (including either the auth cookie or the `Authorization` header) with a specially-crafted field, an attacker can create an out-of-memory error in the hosting server. To trigger this error, the attacker need to have permissions to create or edit datasets. This vulnerability has been patched in CKAN 2.10.3 and 2.9.10."}, {"lang": "es", "value": "CKAN es un sistema de gesti\u00f3n de datos de c\u00f3digo abierto para impulsar centros y portales de datos. A partir de la versi\u00f3n 2.0.0 y anteriores a las versiones 2.9.10 y 2.10.3, al enviar una solicitud POST al endpoint `/dataset/new` (incluida la cookie de autenticaci\u00f3n o el encabezado `Authorization`) con un archivo especialmente manipulado campo, un atacante puede crear un error de falta de memoria en el servidor de alojamiento. Para desencadenar este error, el atacante debe tener permisos para crear o editar conjuntos de datos. Esta vulnerabilidad ha sido parcheada en CKAN 2.10.3 y 2.9.10."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 4.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-130"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:okfn:ckan:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.0", "versionEndExcluding": "2.9.10", "matchCriteriaId": "3C332324-34D4-4EA8-B552-8EA55EFAA33B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:okfn:ckan:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.10.0", "versionEndExcluding": "2.10.3", "matchCriteriaId": "B48DC86C-262E-41F5-8BD9-44F664CE36D8"}]}]}], "references": [{"url": "https://github.com/ckan/ckan/commit/bd02018b65c5b81d7ede195d00d0fcbac3aa33be", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/ckan/ckan/security/advisories/GHSA-7fgc-89cx-w8j5", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/ckan/ckan/commit/bd02018b65c5b81d7ede195d00d0fcbac3aa33be"}}