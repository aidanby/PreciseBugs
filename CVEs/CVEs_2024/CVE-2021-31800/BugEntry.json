{"buggy_code": ["# SECUREAUTH LABS. Copyright 2018 SecureAuth Corporation. All rights reserved.\n#\n# This software is provided under under a slightly modified version\n# of the Apache Software License. See the accompanying LICENSE file\n# for more information.\n#\n# Author: Alberto Solino (@agsolino)\n#\n# TODO:\n# [-] Functions should return NT error codes\n# [-] Handling errors in all situations, right now it's just raising exceptions. \n# [*] Standard authentication support\n# [ ] Organize the connectionData stuff\n# [*] Add capability to send a bad user ID if the user is not authenticated,\n#     right now you can ask for any command without actually being authenticated\n# [ ] PATH TRAVERSALS EVERYWHERE.. BE WARNED!\n# [ ] Check error situation (now many places assume the right data is coming)\n# [ ] Implement IPC to the main process so the connectionData is on a single place\n# [ ] Hence.. implement locking\n# estamos en la B\n\n\nimport calendar\nimport socket\nimport time\nimport datetime\nimport struct\nimport threading\nimport logging\nimport logging.config\nimport ntpath\nimport os\nimport fnmatch\nimport errno\nimport sys\nimport random\nimport shutil\nimport string\nimport hashlib\nimport hmac\n\nfrom binascii import unhexlify, hexlify, a2b_hex\nfrom six import PY2, b, text_type\nfrom six.moves import configparser, socketserver\n\n# For signing\nfrom impacket import smb, nmb, ntlm, uuid\nfrom impacket import smb3structs as smb2\nfrom impacket.spnego import SPNEGO_NegTokenInit, TypesMech, MechTypes, SPNEGO_NegTokenResp, ASN1_AID, ASN1_SUPPORTED_MECH\nfrom impacket.nt_errors import STATUS_NO_MORE_FILES, STATUS_NETWORK_NAME_DELETED, STATUS_INVALID_PARAMETER, \\\n    STATUS_FILE_CLOSED, STATUS_MORE_PROCESSING_REQUIRED, STATUS_OBJECT_PATH_NOT_FOUND, STATUS_DIRECTORY_NOT_EMPTY, \\\n    STATUS_FILE_IS_A_DIRECTORY, STATUS_NOT_IMPLEMENTED, STATUS_INVALID_HANDLE, STATUS_OBJECT_NAME_COLLISION, \\\n    STATUS_NO_SUCH_FILE, STATUS_CANCELLED, STATUS_OBJECT_NAME_NOT_FOUND, STATUS_SUCCESS, STATUS_ACCESS_DENIED, \\\n    STATUS_NOT_SUPPORTED, STATUS_INVALID_DEVICE_REQUEST, STATUS_FS_DRIVER_REQUIRED, STATUS_INVALID_INFO_CLASS, \\\n    STATUS_LOGON_FAILURE\n\n# Setting LOG to current's module name\nLOG = logging.getLogger(__name__)\n\n# These ones not defined in nt_errors\nSTATUS_SMB_BAD_UID = 0x005B0002\nSTATUS_SMB_BAD_TID = 0x00050002\n\n# Utility functions\n# and general functions. \n# There are some common functions that can be accessed from more than one SMB \n# command (or either TRANSACTION). That's why I'm putting them here\n# TODO: Return NT ERROR Codes\n\ndef computeNTLMv2(identity, lmhash, nthash, serverChallenge, authenticateMessage, ntlmChallenge, type1):\n    # Let's calculate the NTLMv2 Response\n\n\n    responseKeyNT = ntlm.NTOWFv2(identity, '', authenticateMessage['domain_name'].decode('utf-16le'), nthash)\n    responseKeyLM = ntlm.LMOWFv2(identity, '', authenticateMessage['domain_name'].decode('utf-16le'), lmhash)\n\n    ntProofStr = authenticateMessage['ntlm'][:16]\n    temp = authenticateMessage['ntlm'][16:]\n    ntProofStr2 = ntlm.hmac_md5(responseKeyNT, serverChallenge + temp)\n    lmChallengeResponse = authenticateMessage['lanman']\n    sessionBaseKey = ntlm.hmac_md5(responseKeyNT, ntProofStr)\n\n    responseFlags = type1['flags']\n\n    # Let's check the return flags\n    if (ntlmChallenge['flags'] & ntlm.NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY) == 0:\n        # No extended session security, taking it out\n        responseFlags &= 0xffffffff ^ ntlm.NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY\n    if (ntlmChallenge['flags'] & ntlm.NTLMSSP_NEGOTIATE_128) == 0:\n        # No support for 128 key len, taking it out\n        responseFlags &= 0xffffffff ^ ntlm.NTLMSSP_NEGOTIATE_128\n    if (ntlmChallenge['flags'] & ntlm.NTLMSSP_NEGOTIATE_KEY_EXCH) == 0:\n        # No key exchange supported, taking it out\n        responseFlags &= 0xffffffff ^ ntlm.NTLMSSP_NEGOTIATE_KEY_EXCH\n    if (ntlmChallenge['flags'] & ntlm.NTLMSSP_NEGOTIATE_SEAL) == 0:\n        # No sign available, taking it out\n        responseFlags &= 0xffffffff ^ ntlm.NTLMSSP_NEGOTIATE_SEAL\n    if (ntlmChallenge['flags'] & ntlm.NTLMSSP_NEGOTIATE_SIGN) == 0:\n        # No sign available, taking it out\n        responseFlags &= 0xffffffff ^ ntlm.NTLMSSP_NEGOTIATE_SIGN\n    if (ntlmChallenge['flags'] & ntlm.NTLMSSP_NEGOTIATE_ALWAYS_SIGN) == 0:\n        # No sign available, taking it out\n        responseFlags &= 0xffffffff ^ ntlm.NTLMSSP_NEGOTIATE_ALWAYS_SIGN\n\n    keyExchangeKey = ntlm.KXKEY(ntlmChallenge['flags'], sessionBaseKey, lmChallengeResponse,\n                           ntlmChallenge['challenge'], '',\n                           lmhash, nthash, True)\n\n    # If we set up key exchange, let's fill the right variables\n    if ntlmChallenge['flags'] & ntlm.NTLMSSP_NEGOTIATE_KEY_EXCH:\n        exportedSessionKey = authenticateMessage['session_key']\n        exportedSessionKey = ntlm.generateEncryptedSessionKey(keyExchangeKey, exportedSessionKey)\n    else:\n        encryptedRandomSessionKey = None\n        # [MS-NLMP] page 46\n        exportedSessionKey = keyExchangeKey\n\n    # Do they match?\n    if ntProofStr == ntProofStr2:\n        # Yes!, process login\n        return STATUS_SUCCESS, exportedSessionKey\n    else:\n        return STATUS_LOGON_FAILURE, exportedSessionKey\n\n\ndef outputToJohnFormat(challenge, username, domain, lmresponse, ntresponse):\n# We don't want to add a possible failure here, since this is an\n# extra bonus. We try, if it fails, returns nothing\n# ToDo: Document the parameter's types (bytes / string) and check all the places where it's called\n    ret_value = ''\n    if type(challenge) is not bytes:\n        challenge = challenge.decode('latin-1')\n\n    try:\n        if len(ntresponse) > 24:\n            # Extended Security - NTLMv2\n            ret_value = {'hash_string': '%s::%s:%s:%s:%s' % (\n                username.decode('utf-16le'), domain.decode('utf-16le'), hexlify(challenge).decode('latin-1'),\n                hexlify(ntresponse).decode('latin-1')[:32],\n            hexlify(ntresponse).decode()[32:]), 'hash_version': 'ntlmv2'}\n        else:\n            # NTLMv1\n            ret_value = {'hash_string': '%s::%s:%s:%s:%s' % (\n                username.decode('utf-16le'), domain.decode('utf-16le'), hexlify(lmresponse).decode('latin-1'),\n                hexlify(ntresponse).decode('latin-1'),\n            hexlify(challenge).decode()), 'hash_version': 'ntlm'}\n    except:\n        # Let's try w/o decoding Unicode\n        try:\n            if len(ntresponse) > 24:\n                # Extended Security - NTLMv2\n                ret_value = {'hash_string': '%s::%s:%s:%s:%s' % (\n                    username.decode('latin-1'), domain.decode('latin-1'), hexlify(challenge).decode('latin-1'),\n                    hexlify(ntresponse)[:32].decode('latin-1'), hexlify(ntresponse)[32:].decode('latin-1')),\n                             'hash_version': 'ntlmv2'}\n            else:\n                # NTLMv1\n                ret_value = {'hash_string': '%s::%s:%s:%s:%s' % (\n                    username, domain, hexlify(lmresponse).decode('latin-1'), hexlify(ntresponse).decode('latin-1'),\n                    hexlify(challenge).decode('latin-1')), 'hash_version': 'ntlm'}\n        except Exception as e:\n            import traceback\n            traceback.print_exc()\n            LOG.error(\"outputToJohnFormat: %s\" % e)\n            pass\n\n    return ret_value\n\ndef writeJohnOutputToFile(hash_string, hash_version, file_name):\n    fn_data = os.path.splitext(file_name)\n    if hash_version == \"ntlmv2\":\n        output_filename = fn_data[0] + \"_ntlmv2\" + fn_data[1]\n    else:\n        output_filename = fn_data[0] + \"_ntlm\" + fn_data[1]\n\n    with open(output_filename,\"a\") as f:\n            f.write(hash_string)\n            f.write('\\n')\t\t        \n\n\ndef decodeSMBString( flags, text ):\n    if flags & smb.SMB.FLAGS2_UNICODE:\n        return text.decode('utf-16le')\n    else:\n        return text\n\ndef encodeSMBString( flags, text ):\n    if flags & smb.SMB.FLAGS2_UNICODE:\n        return (text).encode('utf-16le')\n    else:\n        return text.encode('ascii')\n    \ndef getFileTime(t):\n    t *= 10000000\n    t += 116444736000000000\n    return t\n\ndef getUnixTime(t):\n    t -= 116444736000000000\n    t //= 10000000\n    return t\n\ndef getSMBDate(t):\n    # TODO: Fix this :P\n    d = datetime.date.fromtimestamp(t)\n    year = d.year - 1980\n    ret = (year << 8) + (d.month << 4) + d.day\n    return ret\n\ndef getSMBTime(t):\n    # TODO: Fix this :P\n    d = datetime.datetime.fromtimestamp(t)\n    return (d.hour << 8) + (d.minute << 4) + d.second \n\ndef getShares(connId, smbServer):\n    config = smbServer.getServerConfig()\n    sections = config.sections()\n    # Remove the global one\n    del(sections[sections.index('global')])\n    shares = {}\n    for i in sections:\n        shares[i] = dict(config.items(i))\n    return shares\n\ndef searchShare(connId, share, smbServer):\n    config = smbServer.getServerConfig()\n    if config.has_section(share):\n       return dict(config.items(share))\n    else:\n       return None\n\ndef openFile(path,fileName, accessMode, fileAttributes, openMode):\n    fileName = os.path.normpath(fileName.replace('\\\\','/'))\n    errorCode = 0\n    if len(fileName) > 0 and (fileName[0] == '/' or fileName[0] == '\\\\'):\n       # strip leading '/'\n       fileName = fileName[1:]\n    pathName = os.path.join(path,fileName)\n    mode = 0\n    # Check the Open Mode\n    if openMode & 0x10:\n        # If the file does not exist, create it.\n        mode = os.O_CREAT\n    else:\n        # If file does not exist, return an error\n        if os.path.exists(pathName) is not True:\n            errorCode = STATUS_NO_SUCH_FILE\n            return 0,mode, pathName, errorCode\n\n    if os.path.isdir(pathName) and (fileAttributes & smb.ATTR_DIRECTORY) == 0:\n        # Request to open a normal file and this is actually a directory\n            errorCode = STATUS_FILE_IS_A_DIRECTORY\n            return 0, mode, pathName, errorCode\n    # Check the Access Mode\n    if accessMode & 0x7 == 1:\n       mode |= os.O_WRONLY\n    elif accessMode & 0x7 == 2:\n       mode |= os.O_RDWR\n    else:\n       mode = os.O_RDONLY\n\n    try:\n        if sys.platform == 'win32':\n            mode |= os.O_BINARY\n        fid = os.open(pathName, mode)\n    except Exception as e:\n        LOG.error(\"openFile: %s,%s\" % (pathName, mode) ,e)\n        fid = 0\n        errorCode = STATUS_ACCESS_DENIED\n\n    return fid, mode, pathName, errorCode\n\ndef queryFsInformation(path, filename, level=0, pktFlags = smb.SMB.FLAGS2_UNICODE):\n\n    if pktFlags & smb.SMB.FLAGS2_UNICODE:\n         encoding = 'utf-16le'\n    else:\n         encoding = 'ascii'\n\n    fileName = os.path.normpath(filename.replace('\\\\','/'))\n    if len(fileName) > 0 and (fileName[0] == '/' or fileName[0] == '\\\\'):\n       # strip leading '/'\n       fileName = fileName[1:]\n    pathName = os.path.join(path,fileName)\n    fileSize = os.path.getsize(pathName)\n    (mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime) = os.stat(pathName)\n    if level == smb.SMB_QUERY_FS_ATTRIBUTE_INFO or level == smb2.SMB2_FILESYSTEM_ATTRIBUTE_INFO:\n        data = smb.SMBQueryFsAttributeInfo()\n        data['FileSystemAttributes']      = smb.FILE_CASE_SENSITIVE_SEARCH | smb.FILE_CASE_PRESERVED_NAMES\n        data['MaxFilenNameLengthInBytes'] = 255\n        data['LengthOfFileSystemName']    = len('XTFS')*2\n        data['FileSystemName']            = 'XTFS'.encode('utf-16le')\n        return data.getData()\n    elif level == smb.SMB_INFO_VOLUME:\n        data = smb.SMBQueryFsInfoVolume( flags = pktFlags )\n        data['VolumeLabel']               = 'SHARE'.encode(encoding)\n        return data.getData()\n    elif level == smb.SMB_QUERY_FS_VOLUME_INFO or level == smb2.SMB2_FILESYSTEM_VOLUME_INFO:\n        data = smb.SMBQueryFsVolumeInfo()\n        data['VolumeLabel']               = ''\n        data['VolumeCreationTime']        = getFileTime(ctime)\n        return data.getData() \n    elif level == smb.SMB_QUERY_FS_SIZE_INFO:\n        data = smb.SMBQueryFsSizeInfo()\n        return data.getData()\n    elif level == smb.FILE_FS_FULL_SIZE_INFORMATION:\n        data = smb.SMBFileFsFullSizeInformation()\n        return data.getData()\n    elif level == smb.FILE_FS_SIZE_INFORMATION:\n        data = smb.FileFsSizeInformation()\n        return data.getData()\n    else:\n        lastWriteTime = mtime\n        attribs = 0\n        if os.path.isdir(pathName):\n            attribs |= smb.SMB_FILE_ATTRIBUTE_DIRECTORY\n        if os.path.isfile(pathName):\n            attribs |= smb.SMB_FILE_ATTRIBUTE_NORMAL\n        fileAttributes = attribs\n        return fileSize, lastWriteTime, fileAttributes\n\ndef findFirst2(path, fileName, level, searchAttributes, pktFlags = smb.SMB.FLAGS2_UNICODE, isSMB2 = False):\n     # TODO: Depending on the level, this could be done much simpler\n     \n     #print \"FindFirs2 path:%s, filename:%s\" % (path, fileName)\n     fileName = os.path.normpath(fileName.replace('\\\\','/'))\n     # Let's choose the right encoding depending on the request\n     if pktFlags & smb.SMB.FLAGS2_UNICODE:\n         encoding = 'utf-16le'\n     else:\n         encoding = 'ascii'\n\n     if len(fileName) > 0 and (fileName[0] == '/' or fileName[0] == '\\\\'):\n        # strip leading '/'\n        fileName = fileName[1:]\n\n     pathName = os.path.join(path,fileName)\n     files = []\n\n     if pathName.find('*') == -1 and pathName.find('?') == -1:\n         # No search patterns\n         pattern = ''\n     else:\n         pattern = os.path.basename(pathName)\n         dirName = os.path.dirname(pathName)\n\n     # Always add . and .. Not that important for Windows, but Samba whines if \n     # not present (for * search only)\n     if pattern == '*':\n         files.append(os.path.join(dirName,'.'))\n         files.append(os.path.join(dirName,'..'))\n\n     if pattern != '':\n         for file in os.listdir(dirName):\n             if fnmatch.fnmatch(file.lower(),pattern.lower()):\n                entry = os.path.join(dirName, file)\n                if os.path.isdir(entry):\n                    if searchAttributes & smb.ATTR_DIRECTORY:\n                        files.append(entry)\n                else:\n                    files.append(entry)\n     else:\n         if os.path.exists(pathName):\n             files.append(pathName)\n\n     searchResult = []\n     searchCount = len(files)\n     errorCode = STATUS_SUCCESS\n\n     for i in files:\n        if level == smb.SMB_FIND_FILE_BOTH_DIRECTORY_INFO or level == smb2.SMB2_FILE_BOTH_DIRECTORY_INFO:\n            item = smb.SMBFindFileBothDirectoryInfo( flags = pktFlags )\n        elif level == smb.SMB_FIND_FILE_DIRECTORY_INFO or level == smb2.SMB2_FILE_DIRECTORY_INFO:\n            item = smb.SMBFindFileDirectoryInfo( flags = pktFlags )\n        elif level == smb.SMB_FIND_FILE_FULL_DIRECTORY_INFO or level == smb2.SMB2_FULL_DIRECTORY_INFO:\n            item = smb.SMBFindFileFullDirectoryInfo( flags = pktFlags )\n        elif level == smb.SMB_FIND_INFO_STANDARD:\n            item = smb.SMBFindInfoStandard( flags = pktFlags )\n        elif level == smb.SMB_FIND_FILE_ID_FULL_DIRECTORY_INFO or level == smb2.SMB2_FILE_ID_FULL_DIRECTORY_INFO:\n            item = smb.SMBFindFileIdFullDirectoryInfo( flags = pktFlags )\n        elif level == smb.SMB_FIND_FILE_ID_BOTH_DIRECTORY_INFO or level == smb2.SMB2_FILE_ID_BOTH_DIRECTORY_INFO:\n            item = smb.SMBFindFileIdBothDirectoryInfo( flags = pktFlags )\n        elif level == smb.SMB_FIND_FILE_NAMES_INFO or level == smb2.SMB2_FILE_NAMES_INFO:\n            item = smb.SMBFindFileNamesInfo( flags = pktFlags )\n        else:\n            LOG.error(\"Wrong level %d!\" % level)\n            return  searchResult, searchCount, STATUS_NOT_SUPPORTED\n            \n        (mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime) = os.stat(i)\n        if os.path.isdir(i):\n           item['ExtFileAttributes'] = smb.ATTR_DIRECTORY\n        else:\n           item['ExtFileAttributes'] = smb.ATTR_NORMAL | smb.ATTR_ARCHIVE\n\n        item['FileName'] = os.path.basename(i).encode(encoding)\n\n        if level == smb.SMB_FIND_FILE_BOTH_DIRECTORY_INFO or level == smb.SMB_FIND_FILE_ID_BOTH_DIRECTORY_INFO or level == smb2.SMB2_FILE_ID_BOTH_DIRECTORY_INFO or level == smb2.SMB2_FILE_BOTH_DIRECTORY_INFO:\n           item['EaSize']            = 0\n           item['EndOfFile']         = size\n           item['AllocationSize']    = size\n           item['CreationTime']      = getFileTime(ctime)\n           item['LastAccessTime']    = getFileTime(atime)\n           item['LastWriteTime']     = getFileTime(mtime)\n           item['LastChangeTime']    = getFileTime(mtime)\n           item['ShortName']         = '\\x00'*24\n           item['FileName']          = os.path.basename(i).encode(encoding)\n           padLen = (8-(len(item) % 8)) % 8\n           item['NextEntryOffset']   = len(item) + padLen\n        elif level == smb.SMB_FIND_FILE_DIRECTORY_INFO:\n           item['EndOfFile']         = size\n           item['AllocationSize']    = size\n           item['CreationTime']      = getFileTime(ctime)\n           item['LastAccessTime']    = getFileTime(atime)\n           item['LastWriteTime']     = getFileTime(mtime)\n           item['LastChangeTime']    = getFileTime(mtime)\n           item['FileName']          = os.path.basename(i).encode(encoding)\n           padLen = (8-(len(item) % 8)) % 8\n           item['NextEntryOffset']   = len(item) + padLen\n        elif level == smb.SMB_FIND_FILE_FULL_DIRECTORY_INFO or level == smb.SMB_FIND_FILE_ID_FULL_DIRECTORY_INFO or level == smb2.SMB2_FULL_DIRECTORY_INFO:\n           item['EaSize']            = 0\n           item['EndOfFile']         = size\n           item['AllocationSize']    = size\n           item['CreationTime']      = getFileTime(ctime)\n           item['LastAccessTime']    = getFileTime(atime)\n           item['LastWriteTime']     = getFileTime(mtime)\n           item['LastChangeTime']    = getFileTime(mtime)\n           padLen = (8-(len(item) % 8)) % 8\n           item['NextEntryOffset']   = len(item) + padLen\n        elif level == smb.SMB_FIND_INFO_STANDARD:\n           item['EaSize']            = size\n           item['CreationDate']      = getSMBDate(ctime)\n           item['CreationTime']      = getSMBTime(ctime)\n           item['LastAccessDate']    = getSMBDate(atime)\n           item['LastAccessTime']    = getSMBTime(atime)\n           item['LastWriteDate']     = getSMBDate(mtime)\n           item['LastWriteTime']     = getSMBTime(mtime)\n        searchResult.append(item)\n\n     # No more files\n     if (level >= smb.SMB_FIND_FILE_DIRECTORY_INFO or isSMB2 is True) and searchCount > 0:\n         searchResult[-1]['NextEntryOffset'] = 0\n\n     return searchResult, searchCount, errorCode\n\ndef queryFileInformation(path, filename, level):\n    #print \"queryFileInfo path: %s, filename: %s, level:0x%x\" % (path,filename,level)\n    return queryPathInformation(path,filename, level)\n\ndef queryPathInformation(path, filename, level):\n    # TODO: Depending on the level, this could be done much simpler\n  #print(\"queryPathInfo path: %s, filename: %s, level:0x%x\" % (path,filename,level))\n  try:\n    errorCode = 0\n    fileName = os.path.normpath(filename.replace('\\\\','/'))\n    if len(fileName) > 0 and (fileName[0] == '/' or fileName[0] == '\\\\') and path != '':\n       # strip leading '/'\n       fileName = fileName[1:]\n    pathName = os.path.join(path,fileName)\n    if os.path.exists(pathName):\n        (mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime) = os.stat(pathName)\n        if level == smb.SMB_QUERY_FILE_BASIC_INFO:\n            infoRecord = smb.SMBQueryFileBasicInfo()\n            infoRecord['CreationTime']         = getFileTime(ctime)\n            infoRecord['LastAccessTime']       = getFileTime(atime)\n            infoRecord['LastWriteTime']        = getFileTime(mtime)\n            infoRecord['LastChangeTime']       = getFileTime(mtime)\n            if os.path.isdir(pathName):\n               infoRecord['ExtFileAttributes'] = smb.ATTR_DIRECTORY\n            else:\n               infoRecord['ExtFileAttributes'] = smb.ATTR_NORMAL | smb.ATTR_ARCHIVE\n        elif level == smb.SMB_QUERY_FILE_STANDARD_INFO:\n            infoRecord = smb.SMBQueryFileStandardInfo()\n            infoRecord['AllocationSize']       = size\n            infoRecord['EndOfFile']            = size\n            if os.path.isdir(pathName):\n               infoRecord['Directory']         = 1\n            else:\n               infoRecord['Directory']         = 0\n        elif level == smb.SMB_QUERY_FILE_ALL_INFO or level == smb2.SMB2_FILE_ALL_INFO:\n            infoRecord = smb.SMBQueryFileAllInfo()\n            infoRecord['CreationTime']         = getFileTime(ctime)\n            infoRecord['LastAccessTime']       = getFileTime(atime)\n            infoRecord['LastWriteTime']        = getFileTime(mtime)\n            infoRecord['LastChangeTime']       = getFileTime(mtime)\n            if os.path.isdir(pathName):\n               infoRecord['ExtFileAttributes'] = smb.ATTR_DIRECTORY\n            else:\n               infoRecord['ExtFileAttributes'] = smb.ATTR_NORMAL | smb.ATTR_ARCHIVE\n            infoRecord['AllocationSize']       = size\n            infoRecord['EndOfFile']            = size\n            if os.path.isdir(pathName):\n               infoRecord['Directory']         = 1\n            else:\n               infoRecord['Directory']         = 0\n            infoRecord['FileName']             = filename.encode('utf-16le')\n        elif level == smb2.SMB2_FILE_NETWORK_OPEN_INFO:\n            infoRecord = smb.SMBFileNetworkOpenInfo()\n            infoRecord['CreationTime']         = getFileTime(ctime)\n            infoRecord['LastAccessTime']       = getFileTime(atime)\n            infoRecord['LastWriteTime']        = getFileTime(mtime)\n            infoRecord['ChangeTime']           = getFileTime(mtime)\n            infoRecord['AllocationSize']       = size\n            infoRecord['EndOfFile']            = size\n            if os.path.isdir(pathName):\n               infoRecord['FileAttributes'] = smb.ATTR_DIRECTORY\n            else:\n               infoRecord['FileAttributes'] = smb.ATTR_NORMAL | smb.ATTR_ARCHIVE\n        elif level == smb.SMB_QUERY_FILE_EA_INFO or level == smb2.SMB2_FILE_EA_INFO: \n            infoRecord = smb.SMBQueryFileEaInfo()\n        elif level == smb2.SMB2_FILE_STREAM_INFO:\n            infoRecord = smb.SMBFileStreamInformation()\n        else:\n            LOG.error('Unknown level for query path info! 0x%x' % level)\n            # UNSUPPORTED\n            return None, STATUS_NOT_SUPPORTED\n\n        return infoRecord, errorCode\n    else:\n        # NOT FOUND\n        return None, STATUS_OBJECT_NAME_NOT_FOUND\n  except Exception as e:\n      LOG.error('queryPathInfo: %s' % e)\n      raise\n\ndef queryDiskInformation(path):\n# TODO: Do something useful here :)\n# For now we just return fake values\n   totalUnits = 65535\n   freeUnits = 65535\n   return totalUnits, freeUnits\n\n# Here we implement the NT transaction handlers\nclass NTTRANSCommands:\n    def default(self, connId, smbServer, recvPacket, parameters, data, maxDataCount = 0):\n        pass\n\n# Here we implement the NT transaction handlers\nclass TRANSCommands:\n    @staticmethod\n    def lanMan(connId, smbServer, recvPacket, parameters, data, maxDataCount = 0):\n        # Minimal [MS-RAP] implementation, just to return the shares\n        connData = smbServer.getConnectionData(connId)\n\n        respSetup = b''\n        respParameters = b''\n        respData = b''\n        errorCode = STATUS_SUCCESS\n        if struct.unpack('<H',parameters[:2])[0] == 0:\n            # NetShareEnum Request\n            netShareEnum = smb.SMBNetShareEnum(parameters)\n            if netShareEnum['InfoLevel'] == 1:\n                shares = getShares(connId, smbServer)\n                respParameters = smb.SMBNetShareEnumResponse()\n                respParameters['EntriesReturned']  = len(shares)\n                respParameters['EntriesAvailable'] = len(shares)\n                tailData = ''\n                for i in shares:\n                    # NetShareInfo1 len == 20\n                    entry = smb.NetShareInfo1()\n                    entry['NetworkName'] = i + '\\x00'*(13-len(i))\n                    entry['Type']        = int(shares[i]['share type'])\n                    # (beto) If offset == 0 it crashes explorer.exe on windows 7\n                    entry['RemarkOffsetLow'] = 20 * len(shares) + len(tailData)\n                    respData += entry.getData()\n                    if 'comment' in shares[i]:\n                        tailData += shares[i]['comment'] + '\\x00'\n                    else:\n                        tailData += '\\x00'\n                respData += tailData\n            else:\n                # We don't support other info levels\n                errorCode = STATUS_NOT_SUPPORTED\n        elif struct.unpack('<H',parameters[:2])[0] == 13:\n            # NetrServerGetInfo Request\n            respParameters = smb.SMBNetServerGetInfoResponse()\n            netServerInfo = smb.SMBNetServerInfo1()\n            netServerInfo['ServerName'] = smbServer.getServerName()\n            respData = netServerInfo.getData()\n            respParameters['TotalBytesAvailable'] = len(respData)\n        elif struct.unpack('<H',parameters[:2])[0] == 1:\n            # NetrShareGetInfo Request\n            request = smb.SMBNetShareGetInfo(parameters)\n            respParameters = smb.SMBNetShareGetInfoResponse()\n            shares = getShares(connId, smbServer)\n            share = shares[request['ShareName'].upper()]\n            shareInfo = smb.NetShareInfo1() \n            shareInfo['NetworkName'] = request['ShareName'].upper() + '\\x00'\n            shareInfo['Type']        = int(share['share type'])\n            respData = shareInfo.getData()\n            if 'comment' in share:\n                shareInfo['RemarkOffsetLow'] = len(respData)\n                respData += share['comment'] + '\\x00'\n            respParameters['TotalBytesAvailable'] = len(respData)\n     \n        else:\n            # We don't know how to handle anything else\n            errorCode = STATUS_NOT_SUPPORTED\n\n        smbServer.setConnectionData(connId, connData)\n\n        return respSetup, respParameters, respData, errorCode\n\n    @staticmethod\n    def transactNamedPipe(connId, smbServer, recvPacket, parameters, data, maxDataCount = 0):\n        connData = smbServer.getConnectionData(connId)\n\n        respSetup = b''\n        respParameters = b''\n        respData = b''\n        errorCode = STATUS_SUCCESS\n        SMBCommand  = smb.SMBCommand(recvPacket['Data'][0])\n        transParameters= smb.SMBTransaction_Parameters(SMBCommand['Parameters'])\n\n        # Extract the FID\n        fid = struct.unpack('<H', transParameters['Setup'][2:])[0]\n\n        if fid in connData['OpenedFiles']:\n            fileHandle = connData['OpenedFiles'][fid]['FileHandle']\n            if fileHandle != PIPE_FILE_DESCRIPTOR:\n                os.write(fileHandle,data)\n                respData = os.read(fileHandle,data)\n            else:\n                sock = connData['OpenedFiles'][fid]['Socket']\n                sock.send(data)\n                respData = sock.recv(maxDataCount)\n        else:\n            errorCode = STATUS_INVALID_HANDLE\n\n        smbServer.setConnectionData(connId, connData)\n\n        return respSetup, respParameters, respData, errorCode\n\n# Here we implement the transaction2 handlers\nclass TRANS2Commands:\n    # All these commands return setup, parameters, data, errorCode\n    @staticmethod\n    def setPathInformation(connId, smbServer, recvPacket, parameters, data, maxDataCount = 0):\n        connData = smbServer.getConnectionData(connId)\n\n        respSetup = b''\n        respParameters = b''\n        respData = b''\n        errorCode = STATUS_SUCCESS\n        setPathInfoParameters = smb.SMBSetPathInformation_Parameters(flags = recvPacket['Flags2'], data = parameters)\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            path     = connData['ConnectedShares'][recvPacket['Tid']]['path']\n            fileName = decodeSMBString(recvPacket['Flags2'], setPathInfoParameters['FileName'])\n            fileName = os.path.normpath(fileName.replace('\\\\','/'))\n            if len(fileName) > 0 and (fileName[0] == '/' or fileName[0] == '\\\\') and path != '':\n               # strip leading '/'\n               fileName = fileName[1:]\n            pathName = os.path.join(path,fileName)\n            if os.path.exists(pathName):\n                informationLevel = setPathInfoParameters['InformationLevel']\n                if informationLevel == smb.SMB_SET_FILE_BASIC_INFO:\n                    infoRecord = smb.SMBSetFileBasicInfo(data)\n                    # Creation time won't be set,  the other ones we play with.\n                    atime = infoRecord['LastAccessTime']\n                    if atime == 0:\n                        atime = -1\n                    else:\n                        atime = getUnixTime(atime)\n                    mtime = infoRecord['LastWriteTime']\n                    if mtime == 0:\n                        mtime = -1\n                    else:\n                        mtime = getUnixTime(mtime)\n                    if mtime != -1 or atime != -1:\n                        os.utime(pathName,(atime,mtime))\n                else:\n                    smbServer.log('Unknown level for set path info! 0x%x' % setPathInfoParameters['InformationLevel'], logging.ERROR)\n                    # UNSUPPORTED\n                    errorCode =  STATUS_NOT_SUPPORTED\n            else:\n                errorCode = STATUS_OBJECT_NAME_NOT_FOUND\n\n            if errorCode == STATUS_SUCCESS:\n                respParameters = smb.SMBSetPathInformationResponse_Parameters()\n\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        smbServer.setConnectionData(connId, connData)\n\n        return respSetup, respParameters, respData, errorCode\n\n\n    @staticmethod\n    def setFileInformation(connId, smbServer, recvPacket, parameters, data, maxDataCount = 0):\n        connData = smbServer.getConnectionData(connId)\n\n        respSetup = b''\n        respParameters = b''\n        respData = b''\n        errorCode = STATUS_SUCCESS\n        setFileInfoParameters = smb.SMBSetFileInformation_Parameters(parameters)\n\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            if setFileInfoParameters['FID'] in connData['OpenedFiles']:\n                fileName = connData['OpenedFiles'][setFileInfoParameters['FID']]['FileName']\n                informationLevel = setFileInfoParameters['InformationLevel']\n                if informationLevel == smb.SMB_SET_FILE_DISPOSITION_INFO:\n                    infoRecord = smb.SMBSetFileDispositionInfo(parameters)\n                    if infoRecord['DeletePending'] > 0:\n                       # Mark this file for removal after closed\n                       connData['OpenedFiles'][setFileInfoParameters['FID']]['DeleteOnClose'] = True\n                       respParameters = smb.SMBSetFileInformationResponse_Parameters()\n                elif informationLevel == smb.SMB_SET_FILE_BASIC_INFO:\n                    infoRecord = smb.SMBSetFileBasicInfo(data)\n                    # Creation time won't be set,  the other ones we play with.\n                    atime = infoRecord['LastAccessTime']\n                    if atime == 0:\n                        atime = -1\n                    else:\n                        atime = getUnixTime(atime)\n                    mtime = infoRecord['LastWriteTime']\n                    if mtime == 0:\n                        mtime = -1\n                    else:\n                        mtime = getUnixTime(mtime)\n                    os.utime(fileName,(atime,mtime))\n                elif informationLevel == smb.SMB_SET_FILE_END_OF_FILE_INFO:\n                    fileHandle = connData['OpenedFiles'][setFileInfoParameters['FID']]['FileHandle']\n                    infoRecord = smb.SMBSetFileEndOfFileInfo(data)\n                    if infoRecord['EndOfFile'] > 0:\n                        os.lseek(fileHandle, infoRecord['EndOfFile']-1, 0)\n                        os.write(fileHandle, b'\\x00')\n                else:\n                    smbServer.log('Unknown level for set file info! 0x%x' % setFileInfoParameters['InformationLevel'], logging.ERROR)\n                    # UNSUPPORTED\n                    errorCode =  STATUS_NOT_SUPPORTED\n            else:\n                errorCode = STATUS_NO_SUCH_FILE\n\n            if errorCode == STATUS_SUCCESS:\n                respParameters = smb.SMBSetFileInformationResponse_Parameters()\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        smbServer.setConnectionData(connId, connData)\n\n        return respSetup, respParameters, respData, errorCode\n\n    @staticmethod\n    def queryFileInformation(connId, smbServer, recvPacket, parameters, data, maxDataCount = 0):\n        connData = smbServer.getConnectionData(connId)\n\n        respSetup = b''\n        respParameters = b''\n        respData = b''\n\n        queryFileInfoParameters = smb.SMBQueryFileInformation_Parameters(parameters)\n\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            if queryFileInfoParameters['FID'] in connData['OpenedFiles']:\n                fileName = connData['OpenedFiles'][queryFileInfoParameters['FID']]['FileName']\n\n                infoRecord, errorCode = queryFileInformation('', fileName, queryFileInfoParameters['InformationLevel'])\n\n                if infoRecord is not None:\n                    respParameters = smb.SMBQueryFileInformationResponse_Parameters()\n                    respData = infoRecord\n            else:\n                errorCode = STATUS_INVALID_HANDLE\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        smbServer.setConnectionData(connId, connData)\n\n        return respSetup, respParameters, respData, errorCode\n\n    @staticmethod\n    def queryPathInformation(connId, smbServer, recvPacket, parameters, data, maxDataCount = 0):\n        connData = smbServer.getConnectionData(connId)\n\n        respSetup = b''\n        respParameters = b''\n        respData = b''\n        errorCode = 0\n\n        queryPathInfoParameters = smb.SMBQueryPathInformation_Parameters(flags = recvPacket['Flags2'], data = parameters)\n\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            path = connData['ConnectedShares'][recvPacket['Tid']]['path']\n            try:\n                infoRecord, errorCode = queryPathInformation(path, decodeSMBString(recvPacket['Flags2'],\n                                                                                   queryPathInfoParameters['FileName']),\n                                                             queryPathInfoParameters['InformationLevel'])\n            except Exception as e:\n               smbServer.log(\"queryPathInformation: %s\" % e,logging.ERROR)\n\n            if infoRecord is not None:\n                respParameters = smb.SMBQueryPathInformationResponse_Parameters()\n                respData = infoRecord\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n           \n        smbServer.setConnectionData(connId, connData)\n\n        return respSetup, respParameters, respData, errorCode\n\n    @staticmethod\n    def queryFsInformation(connId, smbServer, recvPacket, parameters, data, maxDataCount = 0):\n        connData = smbServer.getConnectionData(connId)\n        errorCode = 0\n        # Get the Tid associated\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            data = queryFsInformation(connData['ConnectedShares'][recvPacket['Tid']]['path'], '',\n                                      struct.unpack('<H',parameters)[0], pktFlags = recvPacket['Flags2'])\n\n        smbServer.setConnectionData(connId, connData)\n\n        return b'',b'', data, errorCode\n\n    @staticmethod\n    def findNext2(connId, smbServer, recvPacket, parameters, data, maxDataCount):\n        connData = smbServer.getConnectionData(connId)\n\n        respSetup = b''\n        respParameters = b''\n        respData = b''\n        errorCode = STATUS_SUCCESS\n        findNext2Parameters = smb.SMBFindNext2_Parameters(flags = recvPacket['Flags2'], data = parameters)\n\n        sid = findNext2Parameters['SID']\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            if sid in connData['SIDs']:\n                searchResult = connData['SIDs'][sid]\n                respParameters = smb.SMBFindNext2Response_Parameters()\n                endOfSearch = 1\n                searchCount = 1\n                totalData = 0\n                for i in enumerate(searchResult):\n                    data = i[1].getData()\n                    lenData = len(data)\n                    if (totalData+lenData) >= maxDataCount or (i[0]+1) >= findNext2Parameters['SearchCount']:\n                        # We gotta stop here and continue on a find_next2\n                        endOfSearch = 0\n                        connData['SIDs'][sid] = searchResult[i[0]:]\n                        respParameters['LastNameOffset'] = totalData\n                        break\n                    else:\n                        searchCount +=1\n                        respData += data\n                        totalData += lenData\n                    \n                # Have we reached the end of the search or still stuff to send?\n                if endOfSearch > 0:\n                    # Let's remove the SID from our ConnData\n                    del(connData['SIDs'][sid])\n\n                respParameters['EndOfSearch'] = endOfSearch\n                respParameters['SearchCount'] = searchCount\n            else: \n                errorCode = STATUS_INVALID_HANDLE\n        else:\n            errorCode = STATUS_SMB_BAD_TID   \n\n        smbServer.setConnectionData(connId, connData)\n\n        return respSetup, respParameters, respData, errorCode\n\n    @staticmethod\n    def findFirst2(connId, smbServer, recvPacket, parameters, data, maxDataCount):\n        connData = smbServer.getConnectionData(connId)\n\n        respSetup = b''\n        respParameters = b''\n        respData = b''\n        findFirst2Parameters = smb.SMBFindFirst2_Parameters( recvPacket['Flags2'], data = parameters)\n\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            path = connData['ConnectedShares'][recvPacket['Tid']]['path']\n\n            searchResult, searchCount, errorCode = findFirst2(path, \n                          decodeSMBString( recvPacket['Flags2'], findFirst2Parameters['FileName'] ), \n                          findFirst2Parameters['InformationLevel'], \n                          findFirst2Parameters['SearchAttributes'] , pktFlags = recvPacket['Flags2'])\n\n            respParameters = smb.SMBFindFirst2Response_Parameters()\n            endOfSearch = 1\n            sid = 0x80 # default SID\n            searchCount = 0\n            totalData = 0\n            for i in enumerate(searchResult):\n                #i[1].dump()\n                data = i[1].getData()\n                lenData = len(data)\n                if (totalData+lenData) >= maxDataCount or (i[0]+1) > findFirst2Parameters['SearchCount']:\n                    # We gotta stop here and continue on a find_next2\n                    endOfSearch = 0\n                    # Simple way to generate a fid\n                    if len(connData['SIDs']) == 0:\n                       sid = 1\n                    else:\n                       sid = list(connData['SIDs'].keys())[-1] + 1\n                    # Store the remaining search results in the ConnData SID\n                    connData['SIDs'][sid] = searchResult[i[0]:]\n                    respParameters['LastNameOffset'] = totalData\n                    break\n                else:\n                    searchCount +=1\n                    respData += data\n\n                    padLen = (8-(lenData % 8)) %8\n                    respData += b'\\xaa'*padLen\n                    totalData += lenData + padLen\n\n            respParameters['SID'] = sid\n            respParameters['EndOfSearch'] = endOfSearch\n            respParameters['SearchCount'] = searchCount\n        else:\n            errorCode = STATUS_SMB_BAD_TID   \n\n        smbServer.setConnectionData(connId, connData)\n\n        return respSetup, respParameters, respData, errorCode\n\n# Here we implement the commands handlers\nclass SMBCommands:\n\n    @staticmethod\n    def smbTransaction(connId, smbServer, SMBCommand, recvPacket, transCommands):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(recvPacket['Command'])\n\n        transParameters= smb.SMBTransaction_Parameters(SMBCommand['Parameters'])\n\n        # Do the stuff\n        if transParameters['ParameterCount'] != transParameters['TotalParameterCount']:\n            # TODO: Handle partial parameters \n            raise Exception(\"Unsupported partial parameters in TRANSACT2!\")\n        else:\n            transData = smb.SMBTransaction_SData(flags = recvPacket['Flags2'])\n            # Standard says servers shouldn't trust Parameters and Data comes \n            # in order, so we have to parse the offsets, ugly   \n\n            paramCount = transParameters['ParameterCount']\n            transData['Trans_ParametersLength'] = paramCount\n            dataCount = transParameters['DataCount']\n            transData['Trans_DataLength'] = dataCount\n            transData.fromString(SMBCommand['Data'])\n            if transParameters['ParameterOffset'] > 0:\n                paramOffset = transParameters['ParameterOffset'] - 63 - transParameters['SetupLength']\n                transData['Trans_Parameters'] = SMBCommand['Data'][paramOffset:paramOffset+paramCount]\n            else:\n                transData['Trans_Parameters'] = b''\n\n            if transParameters['DataOffset'] > 0:\n                dataOffset = transParameters['DataOffset'] - 63 - transParameters['SetupLength']\n                transData['Trans_Data'] = SMBCommand['Data'][dataOffset:dataOffset + dataCount]\n            else: \n                transData['Trans_Data'] = b''\n            \n            # Call the handler for this TRANSACTION\n            if transParameters['SetupCount'] == 0:\n                # No subcommand, let's play with the Name\n                command = decodeSMBString(recvPacket['Flags2'],transData['Name'])\n            else:\n                command = struct.unpack('<H', transParameters['Setup'][:2])[0]\n            \n            if command in transCommands:\n               # Call the TRANS subcommand\n               setup = b''\n               parameters = b''\n               data = b''\n               try: \n                   setup, parameters, data, errorCode = transCommands[command](connId,\n                                smbServer, \n                                recvPacket, \n                                transData['Trans_Parameters'], \n                                transData['Trans_Data'],\n                                transParameters['MaxDataCount'])\n               except Exception as e:\n                   #print 'Transaction: %s' % e,e\n                   smbServer.log('Transaction: (%r,%s)' % (command, e), logging.ERROR)\n                   errorCode = STATUS_ACCESS_DENIED\n                   #raise\n\n               if setup == b'' and parameters == b'' and data == b'':\n                   # Something wen't wrong\n                   respParameters = b''\n                   respData = b''\n               else:\n                   # Build the answer\n                   if hasattr(data, 'getData'):\n                       data = data.getData()\n                   remainingData = len(data)\n                   if hasattr(parameters, 'getData'):\n                       parameters = parameters.getData()\n                   remainingParameters = len(parameters)\n                   commands = []\n                   dataDisplacement = 0\n                   while remainingData > 0 or remainingParameters > 0: \n                       respSMBCommand = smb.SMBCommand(recvPacket['Command'])\n                       respParameters = smb.SMBTransactionResponse_Parameters()\n                       respData       = smb.SMBTransaction2Response_Data()\n\n                       respParameters['TotalParameterCount'] = len(parameters)\n                       respParameters['ParameterCount']      = len(parameters)\n                       respData['Trans_ParametersLength']    = len(parameters)\n                       respParameters['TotalDataCount']      = len(data)\n                       respParameters['DataDisplacement']    = dataDisplacement\n\n                       # TODO: Do the same for parameters\n                       if len(data) >  transParameters['MaxDataCount']:\n                           # Answer doesn't fit in this packet\n                           LOG.debug(\"Lowering answer from %d to %d\" % (len(data),transParameters['MaxDataCount']) )\n                           respParameters['DataCount'] = transParameters['MaxDataCount']\n                       else:\n                           respParameters['DataCount'] = len(data)\n\n                       respData['Trans_DataLength']          = respParameters['DataCount']\n                       respParameters['SetupCount']          = len(setup)\n                       respParameters['Setup']               = setup\n                       # TODO: Make sure we're calculating the pad right\n                       if len(parameters) > 0:\n                           #padLen = 4 - (55 + len(setup)) % 4 \n                           padLen = (4 - (55 + len(setup)) % 4 ) % 4\n                           padBytes = b'\\xFF' * padLen\n                           respData['Pad1'] = padBytes\n                           respParameters['ParameterOffset'] = 55 + len(setup) + padLen \n                       else:\n                           padLen = 0\n                           respParameters['ParameterOffset'] = 0\n                           respData['Pad1']                  = b''\n\n                       if len(data) > 0:\n                           #pad2Len = 4 - (55 + len(setup) + padLen + len(parameters)) % 4\n                           pad2Len = (4 - (55 + len(setup) + padLen + len(parameters)) % 4) % 4\n                           respData['Pad2'] = b'\\xFF' * pad2Len\n                           respParameters['DataOffset'] = 55 + len(setup) + padLen + len(parameters) + pad2Len\n                       else:\n                           respParameters['DataOffset'] = 0\n                           respData['Pad2']             = b''\n\n                       respData['Trans_Parameters'] = parameters[:respParameters['ParameterCount']]\n                       respData['Trans_Data']       = data[:respParameters['DataCount']] \n                       respSMBCommand['Parameters'] = respParameters\n                       respSMBCommand['Data']       = respData \n\n                       data = data[respParameters['DataCount']:]\n                       remainingData -= respParameters['DataCount']\n                       dataDisplacement += respParameters['DataCount'] + 1\n\n                       parameters = parameters[respParameters['ParameterCount']:]\n                       remainingParameters -= respParameters['ParameterCount']\n                       commands.append(respSMBCommand)\n\n                   smbServer.setConnectionData(connId, connData)\n                   return commands, None, errorCode\n\n            else:\n               smbServer.log(\"Unsupported Transact command %r\" % command, logging.ERROR)\n               respParameters = b''\n               respData = b''\n               errorCode = STATUS_NOT_IMPLEMENTED\n\n        respSMBCommand['Parameters']             = respParameters\n        respSMBCommand['Data']                   = respData \n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode\n\n\n    @staticmethod\n    def smbNTTransact(connId, smbServer, SMBCommand, recvPacket, transCommands):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(recvPacket['Command'])\n\n        NTTransParameters= smb.SMBNTTransaction_Parameters(SMBCommand['Parameters'])\n        # Do the stuff\n        if NTTransParameters['ParameterCount'] != NTTransParameters['TotalParameterCount']:\n            # TODO: Handle partial parameters \n            raise Exception(\"Unsupported partial parameters in NTTrans!\")\n        else:\n            NTTransData = smb.SMBNTTransaction_Data()\n            # Standard says servers shouldn't trust Parameters and Data comes \n            # in order, so we have to parse the offsets, ugly   \n\n            paramCount = NTTransParameters['ParameterCount']\n            NTTransData['NT_Trans_ParametersLength'] = paramCount\n            dataCount = NTTransParameters['DataCount']\n            NTTransData['NT_Trans_DataLength'] = dataCount\n\n            if NTTransParameters['ParameterOffset'] > 0:\n                paramOffset = NTTransParameters['ParameterOffset'] - 73 - NTTransParameters['SetupLength']\n                NTTransData['NT_Trans_Parameters'] = SMBCommand['Data'][paramOffset:paramOffset+paramCount]\n            else:\n                NTTransData['NT_Trans_Parameters'] = b''\n\n            if NTTransParameters['DataOffset'] > 0:\n                dataOffset = NTTransParameters['DataOffset'] - 73 - NTTransParameters['SetupLength']\n                NTTransData['NT_Trans_Data'] = SMBCommand['Data'][dataOffset:dataOffset + dataCount]\n            else: \n                NTTransData['NT_Trans_Data'] = b''\n\n            # Call the handler for this TRANSACTION\n            command = NTTransParameters['Function']\n            if command in transCommands:\n               # Call the NT TRANS subcommand\n               setup = b''\n               parameters = b''\n               data = b''\n               try: \n                   setup, parameters, data, errorCode = transCommands[command](connId,\n                                smbServer, \n                                recvPacket, \n                                NTTransData['NT_Trans_Parameters'], \n                                NTTransData['NT_Trans_Data'],\n                                NTTransParameters['MaxDataCount'])\n               except Exception as e:\n                   smbServer.log('NTTransaction: (0x%x,%s)' % (command, e), logging.ERROR)\n                   errorCode = STATUS_ACCESS_DENIED\n                   #raise\n\n               if setup == b'' and parameters == b'' and data == b'':\n                   # Something wen't wrong\n                   respParameters = b''\n                   respData = b''\n                   if errorCode == STATUS_SUCCESS:\n                       errorCode = STATUS_ACCESS_DENIED \n               else:\n                   # Build the answer\n                   if hasattr(data, 'getData'):\n                       data = data.getData()\n                   remainingData = len(data)\n                   if hasattr(parameters, 'getData'):\n                       parameters = parameters.getData()\n                   remainingParameters = len(parameters)\n                   commands = []\n                   dataDisplacement = 0\n                   while remainingData > 0 or remainingParameters > 0: \n                       respSMBCommand = smb.SMBCommand(recvPacket['Command'])\n                       respParameters = smb.SMBNTTransactionResponse_Parameters()\n                       respData       = smb.SMBNTTransactionResponse_Data()\n\n                       respParameters['TotalParameterCount'] = len(parameters)\n                       respParameters['ParameterCount']      = len(parameters)\n                       respData['Trans_ParametersLength']    = len(parameters)\n                       respParameters['TotalDataCount']      = len(data)\n                       respParameters['DataDisplacement']    = dataDisplacement\n                       # TODO: Do the same for parameters\n                       if len(data) >  NTTransParameters['MaxDataCount']:\n                           # Answer doesn't fit in this packet\n                           LOG.debug(\"Lowering answer from %d to %d\" % (len(data),NTTransParameters['MaxDataCount']) )\n                           respParameters['DataCount'] = NTTransParameters['MaxDataCount']\n                       else:\n                           respParameters['DataCount'] = len(data)\n\n                       respData['NT_Trans_DataLength']          = respParameters['DataCount']\n                       respParameters['SetupCount']          = len(setup)\n                       respParameters['Setup']               = setup\n                       # TODO: Make sure we're calculating the pad right\n                       if len(parameters) > 0:\n                           #padLen = 4 - (71 + len(setup)) % 4 \n                           padLen = (4 - (73 + len(setup)) % 4 ) % 4\n                           padBytes = b'\\xFF' * padLen\n                           respData['Pad1'] = padBytes\n                           respParameters['ParameterOffset'] = 73 + len(setup) + padLen \n                       else:\n                           padLen = 0\n                           respParameters['ParameterOffset'] = 0\n                           respData['Pad1']                  = b''\n\n                       if len(data) > 0:\n                           #pad2Len = 4 - (71 + len(setup) + padLen + len(parameters)) % 4\n                           pad2Len = (4 - (73 + len(setup) + padLen + len(parameters)) % 4) % 4\n                           respData['Pad2'] = b'\\xFF' * pad2Len\n                           respParameters['DataOffset'] = 73 + len(setup) + padLen + len(parameters) + pad2Len\n                       else:\n                           respParameters['DataOffset'] = 0\n                           respData['Pad2']             = b''\n\n                       respData['NT_Trans_Parameters'] = parameters[:respParameters['ParameterCount']]\n                       respData['NT_Trans_Data']       = data[:respParameters['DataCount']] \n                       respSMBCommand['Parameters'] = respParameters\n                       respSMBCommand['Data']       = respData \n\n                       data = data[respParameters['DataCount']:]\n                       remainingData -= respParameters['DataCount']\n                       dataDisplacement += respParameters['DataCount'] + 1\n\n                       parameters = parameters[respParameters['ParameterCount']:]\n                       remainingParameters -= respParameters['ParameterCount']\n                       commands.append(respSMBCommand)\n\n                   smbServer.setConnectionData(connId, connData)\n                   return commands, None, errorCode\n\n            else:\n               #smbServer.log(\"Unsupported NTTransact command 0x%x\" % command, logging.ERROR)\n               respParameters = b''\n               respData = b''\n               errorCode = STATUS_NOT_IMPLEMENTED\n\n        respSMBCommand['Parameters']             = respParameters\n        respSMBCommand['Data']                   = respData \n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode\n\n\n    @staticmethod\n    def smbTransaction2(connId, smbServer, SMBCommand, recvPacket, transCommands):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(recvPacket['Command'])\n\n        trans2Parameters= smb.SMBTransaction2_Parameters(SMBCommand['Parameters'])\n\n        # Do the stuff\n        if trans2Parameters['ParameterCount'] != trans2Parameters['TotalParameterCount']:\n            # TODO: Handle partial parameters \n            #print \"Unsupported partial parameters in TRANSACT2!\"\n            raise Exception(\"Unsupported partial parameters in TRANSACT2!\")\n        else:\n            trans2Data = smb.SMBTransaction2_Data()\n            # Standard says servers shouldn't trust Parameters and Data comes \n            # in order, so we have to parse the offsets, ugly   \n\n            paramCount = trans2Parameters['ParameterCount']\n            trans2Data['Trans_ParametersLength'] = paramCount\n            dataCount = trans2Parameters['DataCount']\n            trans2Data['Trans_DataLength'] = dataCount\n\n            if trans2Parameters['ParameterOffset'] > 0:\n                paramOffset = trans2Parameters['ParameterOffset'] - 63 - trans2Parameters['SetupLength']\n                trans2Data['Trans_Parameters'] = SMBCommand['Data'][paramOffset:paramOffset+paramCount]\n            else:\n                trans2Data['Trans_Parameters'] = b''\n\n            if trans2Parameters['DataOffset'] > 0:\n                dataOffset = trans2Parameters['DataOffset'] - 63 - trans2Parameters['SetupLength']\n                trans2Data['Trans_Data'] = SMBCommand['Data'][dataOffset:dataOffset + dataCount]\n            else: \n                trans2Data['Trans_Data'] = b''\n\n            # Call the handler for this TRANSACTION\n            command = struct.unpack('<H', trans2Parameters['Setup'])[0]\n            if command in transCommands:\n               # Call the TRANS2 subcommand\n               try:\n                   setup, parameters, data, errorCode = transCommands[command](connId,\n                                smbServer, \n                                recvPacket, \n                                trans2Data['Trans_Parameters'], \n                                trans2Data['Trans_Data'],\n                                trans2Parameters['MaxDataCount'])\n               except Exception as e:\n                   smbServer.log('Transaction2: (0x%x,%s)' % (command, e), logging.ERROR)\n                   #import traceback\n                   #traceback.print_exc()\n                   raise\n\n               if setup == b'' and parameters == b'' and data == b'':\n                   # Something wen't wrong\n                   respParameters = b''\n                   respData = b''\n               else:\n                   # Build the answer\n                   if hasattr(data, 'getData'):\n                       data = data.getData()\n                   remainingData = len(data)\n                   if hasattr(parameters, 'getData'):\n                       parameters = parameters.getData()\n                   remainingParameters = len(parameters)\n                   commands = []\n                   dataDisplacement = 0\n                   while remainingData > 0 or remainingParameters > 0: \n                       respSMBCommand = smb.SMBCommand(recvPacket['Command'])\n                       respParameters = smb.SMBTransaction2Response_Parameters()\n                       respData       = smb.SMBTransaction2Response_Data()\n\n                       respParameters['TotalParameterCount'] = len(parameters)\n                       respParameters['ParameterCount']      = len(parameters)\n                       respData['Trans_ParametersLength']    = len(parameters)\n                       respParameters['TotalDataCount']      = len(data)\n                       respParameters['DataDisplacement']    = dataDisplacement\n                       # TODO: Do the same for parameters\n                       if len(data) >  trans2Parameters['MaxDataCount']:\n                           # Answer doesn't fit in this packet\n                           LOG.debug(\"Lowering answer from %d to %d\" % (len(data),trans2Parameters['MaxDataCount']) )\n                           respParameters['DataCount'] = trans2Parameters['MaxDataCount']\n                       else:\n                           respParameters['DataCount'] = len(data)\n\n                       respData['Trans_DataLength']          = respParameters['DataCount']\n                       respParameters['SetupCount']          = len(setup)\n                       respParameters['Setup']               = setup\n                       # TODO: Make sure we're calculating the pad right\n                       if len(parameters) > 0:\n                           #padLen = 4 - (55 + len(setup)) % 4 \n                           padLen = (4 - (55 + len(setup)) % 4 ) % 4\n                           padBytes = b'\\xFF' * padLen\n                           respData['Pad1'] = padBytes\n                           respParameters['ParameterOffset'] = 55 + len(setup) + padLen \n                       else:\n                           padLen = 0\n                           respParameters['ParameterOffset'] = 0\n                           respData['Pad1']                  = b''\n\n                       if len(data) > 0:\n                           #pad2Len = 4 - (55 + len(setup) + padLen + len(parameters)) % 4\n                           pad2Len = (4 - (55 + len(setup) + padLen + len(parameters)) % 4) % 4\n                           respData['Pad2'] = b'\\xFF' * pad2Len\n                           respParameters['DataOffset'] = 55 + len(setup) + padLen + len(parameters) + pad2Len\n                       else:\n                           respParameters['DataOffset'] = 0\n                           respData['Pad2']             = b''\n\n                       respData['Trans_Parameters'] = parameters[:respParameters['ParameterCount']]\n                       respData['Trans_Data']       = data[:respParameters['DataCount']] \n                       respSMBCommand['Parameters'] = respParameters\n                       respSMBCommand['Data']       = respData \n\n                       data = data[respParameters['DataCount']:]\n                       remainingData -= respParameters['DataCount']\n                       dataDisplacement += respParameters['DataCount'] + 1\n\n                       parameters = parameters[respParameters['ParameterCount']:]\n                       remainingParameters -= respParameters['ParameterCount']\n                       commands.append(respSMBCommand)\n\n                   smbServer.setConnectionData(connId, connData)\n                   return commands, None, errorCode\n\n            else:\n               smbServer.log(\"Unsupported Transact/2 command 0x%x\" % command, logging.ERROR)\n               respParameters = b''\n               respData = b''\n               errorCode = STATUS_NOT_IMPLEMENTED\n\n        respSMBCommand['Parameters']             = respParameters\n        respSMBCommand['Data']                   = respData \n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smbComLockingAndX(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand        = smb.SMBCommand(smb.SMB.SMB_COM_LOCKING_ANDX)\n        respParameters        = b''\n        respData              = b''\n\n        # I'm actually doing nothing.. just make MacOS happy ;)\n        errorCode = STATUS_SUCCESS\n\n        respSMBCommand['Parameters']             = respParameters\n        respSMBCommand['Data']                   = respData \n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode\n\n\n    @staticmethod\n    def smbComClose(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand        = smb.SMBCommand(smb.SMB.SMB_COM_CLOSE)\n        respParameters        = b''\n        respData              = b''\n\n        comClose =  smb.SMBClose_Parameters(SMBCommand['Parameters'])\n\n        if comClose['FID'] in connData['OpenedFiles']:\n             errorCode = STATUS_SUCCESS\n             fileHandle = connData['OpenedFiles'][comClose['FID']]['FileHandle']\n             try:\n                 if fileHandle == PIPE_FILE_DESCRIPTOR:\n                     connData['OpenedFiles'][comClose['FID']]['Socket'].close()\n                 elif fileHandle != VOID_FILE_DESCRIPTOR:\n                     os.close(fileHandle)\n             except Exception as e:\n                 smbServer.log(\"comClose %s\" % e, logging.ERROR)\n                 errorCode = STATUS_ACCESS_DENIED\n             else:\n                 # Check if the file was marked for removal\n                 if connData['OpenedFiles'][comClose['FID']]['DeleteOnClose'] is True:\n                     try:\n                         os.remove(connData['OpenedFiles'][comClose['FID']]['FileName'])\n                     except Exception as e:\n                         smbServer.log(\"comClose %s\" % e, logging.ERROR)\n                         errorCode = STATUS_ACCESS_DENIED\n                 del(connData['OpenedFiles'][comClose['FID']])\n        else:\n            errorCode = STATUS_INVALID_HANDLE\n\n        if errorCode > 0:\n            respParameters = b''\n            respData       = b''\n\n        respSMBCommand['Parameters']             = respParameters\n        respSMBCommand['Data']                   = respData \n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smbComWrite(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand        = smb.SMBCommand(smb.SMB.SMB_COM_WRITE)\n        respParameters        = smb.SMBWriteResponse_Parameters()\n        respData              = b''\n\n        comWriteParameters =  smb.SMBWrite_Parameters(SMBCommand['Parameters'])\n        comWriteData = smb.SMBWrite_Data(SMBCommand['Data'])\n\n        if comWriteParameters['Fid'] in connData['OpenedFiles']:\n             fileHandle = connData['OpenedFiles'][comWriteParameters['Fid']]['FileHandle']\n             errorCode = STATUS_SUCCESS\n             try:\n                 if fileHandle != PIPE_FILE_DESCRIPTOR:\n                     # TODO: Handle big size files\n                     # If we're trying to write past the file end we just skip the write call (Vista does this)\n                     if os.lseek(fileHandle, 0, 2) >= comWriteParameters['Offset']: \n                         os.lseek(fileHandle,comWriteParameters['Offset'],0)\n                         os.write(fileHandle,comWriteData['Data'])\n                 else:\n                     sock = connData['OpenedFiles'][comWriteParameters['Fid']]['Socket']\n                     sock.send(comWriteData['Data'])\n                 respParameters['Count']    = comWriteParameters['Count']\n             except Exception as e:\n                 smbServer.log('smbComWrite: %s' % e, logging.ERROR)\n                 errorCode = STATUS_ACCESS_DENIED\n        else:\n            errorCode = STATUS_INVALID_HANDLE\n\n\n        if errorCode > 0:\n            respParameters = b''\n            respData       = b''\n\n        respSMBCommand['Parameters']             = respParameters\n        respSMBCommand['Data']                   = respData \n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smbComFlush(connId, smbServer, SMBCommand,recvPacket ):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand        = smb.SMBCommand(smb.SMB.SMB_COM_FLUSH)\n        respParameters        = b''\n        respData              = b''\n\n        comFlush =  smb.SMBFlush_Parameters(SMBCommand['Parameters'])\n\n        if comFlush['FID'] in connData['OpenedFiles']:\n             errorCode = STATUS_SUCCESS\n             fileHandle = connData['OpenedFiles'][comFlush['FID']]['FileHandle']\n             try:\n                 os.fsync(fileHandle)\n             except Exception as e:\n                 smbServer.log(\"comFlush %s\" % e, logging.ERROR)\n                 errorCode = STATUS_ACCESS_DENIED\n        else:\n            errorCode = STATUS_INVALID_HANDLE\n\n        if errorCode > 0:\n            respParameters = b''\n            respData       = b''\n\n        respSMBCommand['Parameters']             = respParameters\n        respSMBCommand['Data']                   = respData \n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode\n\n\n    @staticmethod\n    def smbComCreateDirectory(connId, smbServer, SMBCommand,recvPacket ):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand        = smb.SMBCommand(smb.SMB.SMB_COM_CREATE_DIRECTORY)\n        respParameters        = b''\n        respData              = b''\n\n        comCreateDirectoryData=  smb.SMBCreateDirectory_Data(flags = recvPacket['Flags2'], data = SMBCommand['Data'])\n\n        # Get the Tid associated\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n             errorCode = STATUS_SUCCESS\n             path = connData['ConnectedShares'][recvPacket['Tid']]['path']\n             fileName = os.path.normpath(decodeSMBString(recvPacket['Flags2'],comCreateDirectoryData['DirectoryName']).replace('\\\\','/'))\n             if len(fileName) > 0:\n                if fileName[0] == '/' or fileName[0] == '\\\\':\n                    # strip leading '/'\n                    fileName = fileName[1:]\n             pathName = os.path.join(path,fileName)\n             if os.path.exists(pathName):\n                errorCode = STATUS_OBJECT_NAME_COLLISION\n\n             # TODO: More checks here in the future.. Specially when we support\n             # user access\n             else:\n                 try:\n                     os.mkdir(pathName)\n                 except Exception as e:\n                     smbServer.log(\"smbComCreateDirectory: %s\" % e, logging.ERROR)\n                     errorCode = STATUS_ACCESS_DENIED\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n\n        if errorCode > 0:\n            respParameters = b''\n            respData       = b''\n\n        respSMBCommand['Parameters']             = respParameters\n        respSMBCommand['Data']                   = respData \n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smbComRename(connId, smbServer, SMBCommand, recvPacket ):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand        = smb.SMBCommand(smb.SMB.SMB_COM_RENAME)\n        respParameters        = b''\n        respData              = b''\n\n        comRenameData      =  smb.SMBRename_Data(flags = recvPacket['Flags2'], data = SMBCommand['Data'])\n        # Get the Tid associated\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n             errorCode = STATUS_SUCCESS\n             path = connData['ConnectedShares'][recvPacket['Tid']]['path']\n             oldFileName = os.path.normpath(decodeSMBString(recvPacket['Flags2'],comRenameData['OldFileName']).replace('\\\\','/'))\n             newFileName = os.path.normpath(decodeSMBString(recvPacket['Flags2'],comRenameData['NewFileName']).replace('\\\\','/'))\n             if len(oldFileName) > 0 and (oldFileName[0] == '/' or oldFileName[0] == '\\\\'):\n                # strip leading '/'\n                oldFileName = oldFileName[1:]\n             oldPathName = os.path.join(path,oldFileName)\n             if len(newFileName) > 0 and (newFileName[0] == '/' or newFileName[0] == '\\\\'):\n                # strip leading '/'\n                newFileName = newFileName[1:]\n             newPathName = os.path.join(path,newFileName)\n\n             if os.path.exists(oldPathName) is not True:\n                errorCode = STATUS_NO_SUCH_FILE\n\n             # TODO: More checks here in the future.. Specially when we support\n             # user access\n             else:\n                 try:\n                     os.rename(oldPathName,newPathName)\n                 except OSError as e:\n                     smbServer.log(\"smbComRename: %s\" % e, logging.ERROR)\n                     errorCode = STATUS_ACCESS_DENIED\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n\n        if errorCode > 0:\n            respParameters = b''\n            respData       = b''\n\n        respSMBCommand['Parameters']             = respParameters\n        respSMBCommand['Data']                   = respData \n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smbComDelete(connId, smbServer, SMBCommand, recvPacket ):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand        = smb.SMBCommand(smb.SMB.SMB_COM_DELETE)\n        respParameters        = b''\n        respData              = b''\n\n        comDeleteData         =  smb.SMBDelete_Data(flags = recvPacket['Flags2'], data = SMBCommand['Data'])\n\n        # Get the Tid associated\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n             errorCode = STATUS_SUCCESS\n             path = connData['ConnectedShares'][recvPacket['Tid']]['path']\n             fileName = os.path.normpath(decodeSMBString(recvPacket['Flags2'],comDeleteData['FileName']).replace('\\\\','/'))\n             if len(fileName) > 0 and (fileName[0] == '/' or fileName[0] == '\\\\'):\n                # strip leading '/'\n                fileName = fileName[1:]\n             pathName = os.path.join(path,fileName)\n             if os.path.exists(pathName) is not True:\n                errorCode = STATUS_NO_SUCH_FILE\n\n             # TODO: More checks here in the future.. Specially when we support\n             # user access\n             else:\n                 try:\n                     os.remove(pathName)\n                 except OSError as e:\n                     smbServer.log(\"smbComDelete: %s\" % e, logging.ERROR)\n                     errorCode = STATUS_ACCESS_DENIED\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        if errorCode > 0:\n            respParameters = b''\n            respData       = b''\n\n        respSMBCommand['Parameters']             = respParameters\n        respSMBCommand['Data']                   = respData \n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode\n\n\n    @staticmethod\n    def smbComDeleteDirectory(connId, smbServer, SMBCommand, recvPacket ):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand        = smb.SMBCommand(smb.SMB.SMB_COM_DELETE_DIRECTORY)\n        respParameters        = b''\n        respData              = b''\n\n        comDeleteDirectoryData=  smb.SMBDeleteDirectory_Data(flags = recvPacket['Flags2'], data = SMBCommand['Data'])\n\n        # Get the Tid associated\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n             errorCode = STATUS_SUCCESS\n             path = connData['ConnectedShares'][recvPacket['Tid']]['path']\n             fileName = os.path.normpath(decodeSMBString(recvPacket['Flags2'],comDeleteDirectoryData['DirectoryName']).replace('\\\\','/'))\n             if len(fileName) > 0 and (fileName[0] == '/' or fileName[0] == '\\\\'):\n                # strip leading '/'\n                fileName = fileName[1:]\n             pathName = os.path.join(path,fileName)\n             if os.path.exists(pathName) is not True:\n                errorCode = STATUS_NO_SUCH_FILE\n\n             # TODO: More checks here in the future.. Specially when we support\n             # user access\n             else:\n                 try:\n                     os.rmdir(pathName)\n                 except OSError as e:\n                     smbServer.log(\"smbComDeleteDirectory: %s\" % e,logging.ERROR)\n                     if e.errno == errno.ENOTEMPTY:\n                         errorCode = STATUS_DIRECTORY_NOT_EMPTY\n                     else:\n                         errorCode = STATUS_ACCESS_DENIED\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        if errorCode > 0:\n            respParameters = b''\n            respData       = b''\n\n        respSMBCommand['Parameters']             = respParameters\n        respSMBCommand['Data']                   = respData \n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode\n\n\n    @staticmethod\n    def smbComWriteAndX(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand        = smb.SMBCommand(smb.SMB.SMB_COM_WRITE_ANDX)\n        respParameters        = smb.SMBWriteAndXResponse_Parameters()\n        respData              = b''\n\n        if SMBCommand['WordCount'] == 0x0C:\n            writeAndX =  smb.SMBWriteAndX_Parameters_Short(SMBCommand['Parameters'])\n            writeAndXData = smb.SMBWriteAndX_Data_Short()\n        else:\n            writeAndX =  smb.SMBWriteAndX_Parameters(SMBCommand['Parameters'])\n            writeAndXData = smb.SMBWriteAndX_Data()\n        writeAndXData['DataLength'] = writeAndX['DataLength']\n        writeAndXData['DataOffset'] = writeAndX['DataOffset']\n        writeAndXData.fromString(SMBCommand['Data'])\n        \n\n        if writeAndX['Fid'] in connData['OpenedFiles']:\n             fileHandle = connData['OpenedFiles'][writeAndX['Fid']]['FileHandle']\n             errorCode = STATUS_SUCCESS\n             try:\n                 if fileHandle != PIPE_FILE_DESCRIPTOR:\n                     offset = writeAndX['Offset']\n                     if 'HighOffset' in writeAndX.fields:\n                         offset += (writeAndX['HighOffset'] << 32)\n                     # If we're trying to write past the file end we just skip the write call (Vista does this)\n                     if os.lseek(fileHandle, 0, 2) >= offset:\n                         os.lseek(fileHandle,offset,0)\n                         os.write(fileHandle,writeAndXData['Data'])\n                 else:\n                     sock = connData['OpenedFiles'][writeAndX['Fid']]['Socket']\n                     sock.send(writeAndXData['Data'])\n\n                 respParameters['Count']    = writeAndX['DataLength']\n                 respParameters['Available']= 0xff\n             except Exception as e:\n                 smbServer.log('smbComWriteAndx: %s' % e, logging.ERROR)\n                 errorCode = STATUS_ACCESS_DENIED\n        else:\n            errorCode = STATUS_INVALID_HANDLE\n\n        if errorCode > 0:\n            respParameters = b''\n            respData       = b''\n\n        respSMBCommand['Parameters']             = respParameters\n        respSMBCommand['Data']                   = respData \n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smbComRead(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand        = smb.SMBCommand(smb.SMB.SMB_COM_READ)\n        respParameters        = smb.SMBReadResponse_Parameters()\n        respData              = smb.SMBReadResponse_Data()\n\n        comReadParameters =  smb.SMBRead_Parameters(SMBCommand['Parameters'])\n\n        if comReadParameters['Fid'] in connData['OpenedFiles']:\n             fileHandle = connData['OpenedFiles'][comReadParameters['Fid']]['FileHandle']\n             errorCode = STATUS_SUCCESS\n             try:\n                 if fileHandle != PIPE_FILE_DESCRIPTOR:\n                     # TODO: Handle big size files\n                     os.lseek(fileHandle,comReadParameters['Offset'],0)\n                     content = os.read(fileHandle,comReadParameters['Count'])\n                 else:\n                     sock = connData['OpenedFiles'][comReadParameters['Fid']]['Socket']\n                     content = sock.recv(comReadParameters['Count'])\n                 respParameters['Count']    = len(content)\n                 respData['DataLength']     = len(content)\n                 respData['Data']           = content\n             except Exception as e:\n                 smbServer.log('smbComRead: %s ' % e, logging.ERROR)\n                 errorCode = STATUS_ACCESS_DENIED\n        else:\n            errorCode = STATUS_INVALID_HANDLE\n\n        if errorCode > 0:\n            respParameters = b''\n            respData       = b''\n\n        respSMBCommand['Parameters']             = respParameters\n        respSMBCommand['Data']                   = respData \n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smbComReadAndX(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand        = smb.SMBCommand(smb.SMB.SMB_COM_READ_ANDX)\n        respParameters        = smb.SMBReadAndXResponse_Parameters()\n        respData              = b''\n\n        if SMBCommand['WordCount'] == 0x0A:\n            readAndX =  smb.SMBReadAndX_Parameters2(SMBCommand['Parameters'])\n        else:\n            readAndX =  smb.SMBReadAndX_Parameters(SMBCommand['Parameters'])\n\n        if readAndX['Fid'] in connData['OpenedFiles']:\n             fileHandle = connData['OpenedFiles'][readAndX['Fid']]['FileHandle']\n             errorCode = 0\n             try:\n                 if fileHandle != PIPE_FILE_DESCRIPTOR:\n                     offset = readAndX['Offset']\n                     if 'HighOffset' in readAndX.fields:\n                         offset += (readAndX['HighOffset'] << 32)\n                     os.lseek(fileHandle,offset,0)\n                     content = os.read(fileHandle,readAndX['MaxCount'])\n                 else:\n                     sock = connData['OpenedFiles'][readAndX['Fid']]['Socket']\n                     content = sock.recv(readAndX['MaxCount'])\n                 respParameters['Remaining']    = 0xffff\n                 respParameters['DataCount']    = len(content)\n                 respParameters['DataOffset']   = 59\n                 respParameters['DataCount_Hi'] = 0\n                 respData = content\n             except Exception as e:\n                 smbServer.log('smbComReadAndX: %s ' % e, logging.ERROR)\n                 errorCode = STATUS_ACCESS_DENIED\n        else:\n            errorCode = STATUS_INVALID_HANDLE\n\n        if errorCode > 0:\n            respParameters = b''\n            respData       = b''\n\n        respSMBCommand['Parameters']             = respParameters\n        respSMBCommand['Data']                   = respData \n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smbQueryInformation(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_QUERY_INFORMATION)\n        respParameters = smb.SMBQueryInformationResponse_Parameters()\n        respData       = b''\n\n        queryInformation= smb.SMBQueryInformation_Data(flags = recvPacket['Flags2'], data = SMBCommand['Data'])\n\n        # Get the Tid associated\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            fileSize, lastWriteTime, fileAttributes = queryFsInformation(\n                connData['ConnectedShares'][recvPacket['Tid']]['path'], \n                decodeSMBString(recvPacket['Flags2'],queryInformation['FileName']), pktFlags = recvPacket['Flags2'])\n\n            respParameters['FileSize']       = fileSize\n            respParameters['LastWriteTime']  = lastWriteTime\n            respParameters['FileAttributes'] = fileAttributes\n            errorCode = STATUS_SUCCESS\n        else:\n            # STATUS_SMB_BAD_TID\n            errorCode = STATUS_SMB_BAD_TID\n            respParameters  = b''\n            respData        = b''\n\n        respSMBCommand['Parameters']             = respParameters\n        respSMBCommand['Data']                   = respData \n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smbQueryInformationDisk(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_QUERY_INFORMATION_DISK)\n        respParameters = smb.SMBQueryInformationDiskResponse_Parameters()\n        respData       = b''\n\n        # Get the Tid associated\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            totalUnits, freeUnits = queryDiskInformation(\n                        connData['ConnectedShares'][recvPacket['Tid']]['path'])\n\n            respParameters['TotalUnits']    = totalUnits\n            respParameters['BlocksPerUnit'] = 1\n            respParameters['BlockSize']     = 1\n            respParameters['FreeUnits']     = freeUnits\n            errorCode = STATUS_SUCCESS\n        else:\n            # STATUS_SMB_BAD_TID\n            respData  = b''\n            respParameters = b''\n            errorCode = STATUS_SMB_BAD_TID\n\n\n        respSMBCommand['Parameters']             = respParameters\n        respSMBCommand['Data']                   = respData \n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smbComEcho(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_ECHO)\n        respParameters = smb.SMBEchoResponse_Parameters()\n        respData       = smb.SMBEchoResponse_Data()\n\n        echoData       = smb.SMBEcho_Data(SMBCommand['Data'])\n\n        respParameters['SequenceNumber'] = 1\n        respData['Data']                 = echoData['Data']\n\n        respSMBCommand['Parameters']     = respParameters\n        respSMBCommand['Data']           = respData \n\n        errorCode = STATUS_SUCCESS\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smbComTreeDisconnect(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_TREE_DISCONNECT)\n\n        # Check if the Tid matches the Tid trying to disconnect\n        respParameters = b''\n        respData = b''\n\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            smbServer.log(\"Disconnecting Share(%d:%s)\" % (recvPacket['Tid'],connData['ConnectedShares'][recvPacket['Tid']]['shareName']))\n            del(connData['ConnectedShares'][recvPacket['Tid']])\n            errorCode = STATUS_SUCCESS\n        else:\n            # STATUS_SMB_BAD_TID\n            errorCode = STATUS_SMB_BAD_TID\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data']       = respData \n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smbComLogOffAndX(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand        = smb.SMBCommand(smb.SMB.SMB_COM_LOGOFF_ANDX)\n\n        # Check if the Uid matches the user trying to logoff\n        respParameters = b''\n        respData = b''\n        if recvPacket['Uid'] != connData['Uid']:\n            # STATUS_SMB_BAD_UID\n            errorCode = STATUS_SMB_BAD_UID\n        else:\n            errorCode = STATUS_SUCCESS\n\n        respSMBCommand['Parameters']   = respParameters\n        respSMBCommand['Data']         = respData \n        connData['Uid'] = 0\n        connData['Authenticated'] = False\n\n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smbComQueryInformation2(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand        = smb.SMBCommand(smb.SMB.SMB_COM_QUERY_INFORMATION2)\n        respParameters        = smb.SMBQueryInformation2Response_Parameters()\n        respData              = b''\n\n        queryInformation2 = smb.SMBQueryInformation2_Parameters(SMBCommand['Parameters'])\n        errorCode = 0xFF\n        if queryInformation2['Fid'] in connData['OpenedFiles']:\n             errorCode = STATUS_SUCCESS\n             pathName = connData['OpenedFiles'][queryInformation2['Fid']]['FileName']\n             try:\n                 (mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime) = os.stat(pathName)\n                 respParameters['CreateDate']         = getSMBDate(ctime)\n                 respParameters['CreationTime']       = getSMBTime(ctime)\n                 respParameters['LastAccessDate']     = getSMBDate(atime)\n                 respParameters['LastAccessTime']     = getSMBTime(atime)\n                 respParameters['LastWriteDate']      = getSMBDate(mtime)\n                 respParameters['LastWriteTime']      = getSMBTime(mtime)\n                 respParameters['FileDataSize']       = size\n                 respParameters['FileAllocationSize'] = size\n                 attribs = 0\n                 if os.path.isdir(pathName):\n                     attribs = smb.SMB_FILE_ATTRIBUTE_DIRECTORY\n                 if os.path.isfile(pathName):\n                     attribs = smb.SMB_FILE_ATTRIBUTE_NORMAL\n                 respParameters['FileAttributes'] = attribs\n             except Exception as e:\n                 smbServer.log('smbComQueryInformation2 %s' % e,logging.ERROR)\n                 errorCode = STATUS_ACCESS_DENIED\n\n        if errorCode > 0:\n            respParameters = b''\n            respData       = b''\n\n        respSMBCommand['Parameters']             = respParameters\n        respSMBCommand['Data']                   = respData \n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smbComNtCreateAndX(connId, smbServer, SMBCommand, recvPacket):\n        # TODO: Fully implement this\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand        = smb.SMBCommand(smb.SMB.SMB_COM_NT_CREATE_ANDX)\n        respParameters        = smb.SMBNtCreateAndXResponse_Parameters()\n        respData              = b''\n\n        ntCreateAndXParameters = smb.SMBNtCreateAndX_Parameters(SMBCommand['Parameters'])\n        ntCreateAndXData       = smb.SMBNtCreateAndX_Data( flags = recvPacket['Flags2'], data = SMBCommand['Data'])\n\n        #if ntCreateAndXParameters['CreateFlags'] & 0x10:  # NT_CREATE_REQUEST_EXTENDED_RESPONSE\n        #    respParameters        = smb.SMBNtCreateAndXExtendedResponse_Parameters()\n        #    respParameters['VolumeGUID'] = '\\x00'\n\n        # Get the Tid associated\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n             # If we have a rootFid, the path is relative to that fid\n             errorCode = STATUS_SUCCESS\n             if ntCreateAndXParameters['RootFid'] > 0:\n                 path = connData['OpenedFiles'][ntCreateAndXParameters['RootFid']]['FileName']\n                 LOG.debug(\"RootFid present %s!\" % path)\n             else:\n                 if 'path' in connData['ConnectedShares'][recvPacket['Tid']]:\n                     path = connData['ConnectedShares'][recvPacket['Tid']]['path']\n                 else:\n                     path = 'NONE'\n                     errorCode = STATUS_ACCESS_DENIED\n\n             deleteOnClose = False\n\n             fileName = os.path.normpath(decodeSMBString(recvPacket['Flags2'],ntCreateAndXData['FileName']).replace('\\\\','/'))\n             if len(fileName) > 0 and (fileName[0] == '/' or fileName[0] == '\\\\'):\n                # strip leading '/'\n                fileName = fileName[1:]\n             pathName = os.path.join(path,fileName)\n             createDisposition = ntCreateAndXParameters['Disposition']\n             mode = 0\n\n             if createDisposition == smb.FILE_SUPERSEDE:\n                 mode |= os.O_TRUNC | os.O_CREAT\n             elif createDisposition & smb.FILE_OVERWRITE_IF == smb.FILE_OVERWRITE_IF:\n                 mode |= os.O_TRUNC | os.O_CREAT\n             elif createDisposition & smb.FILE_OVERWRITE == smb.FILE_OVERWRITE:\n                 if os.path.exists(pathName) is True:\n                     mode |= os.O_TRUNC \n                 else:\n                     errorCode = STATUS_NO_SUCH_FILE\n             elif createDisposition & smb.FILE_OPEN_IF == smb.FILE_OPEN_IF:\n                 if os.path.exists(pathName) is True:\n                     mode |= os.O_TRUNC \n                 else:\n                     mode |= os.O_TRUNC | os.O_CREAT\n             elif createDisposition & smb.FILE_CREATE == smb.FILE_CREATE:\n                 if os.path.exists(pathName) is True:\n                     errorCode = STATUS_OBJECT_NAME_COLLISION\n                 else:\n                     mode |= os.O_CREAT\n             elif createDisposition & smb.FILE_OPEN == smb.FILE_OPEN:\n                 if os.path.exists(pathName) is not True and (str(pathName) in smbServer.getRegisteredNamedPipes()) is not True:\n                     errorCode = STATUS_NO_SUCH_FILE\n\n             if errorCode == STATUS_SUCCESS:\n                 desiredAccess = ntCreateAndXParameters['AccessMask']\n                 if (desiredAccess & smb.FILE_READ_DATA) or (desiredAccess & smb.GENERIC_READ):\n                     mode |= os.O_RDONLY\n                 if (desiredAccess & smb.FILE_WRITE_DATA) or (desiredAccess & smb.GENERIC_WRITE):\n                     if (desiredAccess & smb.FILE_READ_DATA) or (desiredAccess & smb.GENERIC_READ):\n                         mode |= os.O_RDWR #| os.O_APPEND\n                     else: \n                         mode |= os.O_WRONLY #| os.O_APPEND\n                 if desiredAccess & smb.GENERIC_ALL:\n                     mode |= os.O_RDWR #| os.O_APPEND\n\n                 createOptions =  ntCreateAndXParameters['CreateOptions']\n                 if mode & os.O_CREAT == os.O_CREAT:\n                     if createOptions & smb.FILE_DIRECTORY_FILE == smb.FILE_DIRECTORY_FILE: \n                         try:\n                             # Let's create the directory\n                             os.mkdir(pathName)\n                             mode = os.O_RDONLY\n                         except Exception as e:\n                             smbServer.log(\"NTCreateAndX: %s,%s,%s\" % (pathName,mode,e),logging.ERROR)\n                             errorCode = STATUS_ACCESS_DENIED\n                 if createOptions & smb.FILE_NON_DIRECTORY_FILE == smb.FILE_NON_DIRECTORY_FILE:\n                     # If the file being opened is a directory, the server MUST fail the request with\n                     # STATUS_FILE_IS_A_DIRECTORY in the Status field of the SMB Header in the server\n                     # response.\n                     if os.path.isdir(pathName) is True:\n                        errorCode = STATUS_FILE_IS_A_DIRECTORY\n\n                 if createOptions & smb.FILE_DELETE_ON_CLOSE == smb.FILE_DELETE_ON_CLOSE:\n                     deleteOnClose = True\n                 \n                 if errorCode == STATUS_SUCCESS:\n                     try:\n                         if os.path.isdir(pathName) and sys.platform == 'win32':\n                            fid = VOID_FILE_DESCRIPTOR\n                         else:\n                            if sys.platform == 'win32':\n                               mode |= os.O_BINARY\n                            if str(pathName) in smbServer.getRegisteredNamedPipes():\n                                fid = PIPE_FILE_DESCRIPTOR\n                                sock = socket.socket()\n                                sock.connect(smbServer.getRegisteredNamedPipes()[str(pathName)])\n                            else:\n                                fid = os.open(pathName, mode)\n                     except Exception as e:\n                         smbServer.log(\"NTCreateAndX: %s,%s,%s\" % (pathName,mode,e),logging.ERROR)\n                         #print e\n                         fid = 0\n                         errorCode = STATUS_ACCESS_DENIED\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        if errorCode == STATUS_SUCCESS:\n            # Simple way to generate a fid\n            if len(connData['OpenedFiles']) == 0:\n               fakefid = 1\n            else:\n               fakefid = list(connData['OpenedFiles'].keys())[-1] + 1\n            respParameters['Fid'] = fakefid\n            respParameters['CreateAction'] = createDisposition\n            if fid == PIPE_FILE_DESCRIPTOR:\n                respParameters['FileAttributes'] = 0x80\n                respParameters['IsDirectory'] = 0\n                respParameters['CreateTime']     = 0\n                respParameters['LastAccessTime'] = 0\n                respParameters['LastWriteTime']  = 0\n                respParameters['LastChangeTime'] = 0\n                respParameters['AllocationSize'] = 4096\n                respParameters['EndOfFile']      = 0\n                respParameters['FileType']       = 2\n                respParameters['IPCState']       = 0x5ff\n            else:\n                if os.path.isdir(pathName):\n                    respParameters['FileAttributes'] = smb.SMB_FILE_ATTRIBUTE_DIRECTORY\n                    respParameters['IsDirectory'] = 1\n                else:\n                    respParameters['IsDirectory'] = 0\n                    respParameters['FileAttributes'] = ntCreateAndXParameters['FileAttributes']\n                # Let's get this file's information\n                respInfo, errorCode = queryPathInformation('',pathName,level= smb.SMB_QUERY_FILE_ALL_INFO)\n                if errorCode == STATUS_SUCCESS:\n                    respParameters['CreateTime']     = respInfo['CreationTime']\n                    respParameters['LastAccessTime'] = respInfo['LastAccessTime']\n                    respParameters['LastWriteTime']  = respInfo['LastWriteTime']\n                    respParameters['LastChangeTime'] = respInfo['LastChangeTime']\n                    respParameters['FileAttributes'] = respInfo['ExtFileAttributes']\n                    respParameters['AllocationSize'] = respInfo['AllocationSize']\n                    respParameters['EndOfFile']      = respInfo['EndOfFile']\n                else:\n                    respParameters = b''\n                    respData       = b''\n\n            if errorCode == STATUS_SUCCESS:\n                # Let's store the fid for the connection\n                # smbServer.log('Create file %s, mode:0x%x' % (pathName, mode))\n                connData['OpenedFiles'][fakefid] = {}\n                connData['OpenedFiles'][fakefid]['FileHandle'] = fid\n                connData['OpenedFiles'][fakefid]['FileName'] = pathName\n                connData['OpenedFiles'][fakefid]['DeleteOnClose']  = deleteOnClose\n                if fid == PIPE_FILE_DESCRIPTOR:\n                    connData['OpenedFiles'][fakefid]['Socket'] = sock\n        else:\n            respParameters = b''\n            respData       = b''\n        \n        respSMBCommand['Parameters']             = respParameters\n        respSMBCommand['Data']                   = respData \n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smbComOpenAndX(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand        = smb.SMBCommand(smb.SMB.SMB_COM_OPEN_ANDX)\n        respParameters        = smb.SMBOpenAndXResponse_Parameters()\n        respData              = b''\n\n        openAndXParameters = smb.SMBOpenAndX_Parameters(SMBCommand['Parameters'])\n        openAndXData       = smb.SMBOpenAndX_Data( flags = recvPacket['Flags2'], data = SMBCommand['Data'])\n\n        # Get the Tid associated\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n             path = connData['ConnectedShares'][recvPacket['Tid']]['path']\n             openedFile, mode, pathName, errorCode = openFile(path,\n                     decodeSMBString(recvPacket['Flags2'],openAndXData['FileName']), \n                     openAndXParameters['DesiredAccess'], \n                     openAndXParameters['FileAttributes'], \n                     openAndXParameters['OpenMode'])\n        else:\n           errorCode = STATUS_SMB_BAD_TID\n\n        if errorCode == STATUS_SUCCESS:\n            # Simple way to generate a fid\n            fid = len(connData['OpenedFiles']) + 1 \n            if len(connData['OpenedFiles']) == 0:\n               fid = 1\n            else:\n               fid = list(connData['OpenedFiles'].keys())[-1] + 1\n            respParameters['Fid'] = fid\n            if mode & os.O_CREAT:\n                # File did not exist and was created\n                respParameters['Action'] = 0x2\n            elif mode & os.O_RDONLY:\n                # File existed and was opened\n                respParameters['Action'] = 0x1\n            elif mode & os.O_APPEND:\n                # File existed and was opened\n                respParameters['Action'] = 0x1\n            else:\n                # File existed and was truncated\n                respParameters['Action'] = 0x3\n            \n            # Let's store the fid for the connection\n            #smbServer.log('Opening file %s' % pathName)\n            connData['OpenedFiles'][fid] = {}\n            connData['OpenedFiles'][fid]['FileHandle'] = openedFile\n            connData['OpenedFiles'][fid]['FileName'] = pathName\n            connData['OpenedFiles'][fid]['DeleteOnClose']  = False\n        else:\n            respParameters = b''\n            respData       = b''\n        \n        respSMBCommand['Parameters']             = respParameters\n        respSMBCommand['Data']                   = respData \n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smbComTreeConnectAndX(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        resp = smb.NewSMBPacket()\n        resp['Flags1'] = smb.SMB.FLAGS1_REPLY\n        resp['Flags2'] = smb.SMB.FLAGS2_EXTENDED_SECURITY | smb.SMB.FLAGS2_NT_STATUS | smb.SMB.FLAGS2_LONG_NAMES | recvPacket['Flags2'] & smb.SMB.FLAGS2_UNICODE\n\n        resp['Tid'] = recvPacket['Tid']\n        resp['Mid'] = recvPacket['Mid']\n        resp['Pid'] = connData['Pid']\n\n        respSMBCommand        = smb.SMBCommand(smb.SMB.SMB_COM_TREE_CONNECT_ANDX)\n        respParameters        = smb.SMBTreeConnectAndXResponse_Parameters()\n        respData              = smb.SMBTreeConnectAndXResponse_Data()\n\n        treeConnectAndXParameters = smb.SMBTreeConnectAndX_Parameters(SMBCommand['Parameters'])\n\n        if treeConnectAndXParameters['Flags'] & 0x8:\n            respParameters        = smb.SMBTreeConnectAndXExtendedResponse_Parameters()\n\n        treeConnectAndXData                    = smb.SMBTreeConnectAndX_Data( flags = recvPacket['Flags2'] )\n        treeConnectAndXData['_PasswordLength'] = treeConnectAndXParameters['PasswordLength']\n        treeConnectAndXData.fromString(SMBCommand['Data'])\n\n        errorCode = STATUS_SUCCESS\n\n        ## Process here the request, does the share exist?\n        UNCOrShare = decodeSMBString(recvPacket['Flags2'], treeConnectAndXData['Path'])\n\n        # Is this a UNC?\n        if ntpath.ismount(UNCOrShare):\n            path = UNCOrShare.split('\\\\')[3]\n        else:\n            path = ntpath.basename(UNCOrShare)\n\n        share = searchShare(connId, path, smbServer) \n        if share is not None:\n            # Simple way to generate a Tid\n            if len(connData['ConnectedShares']) == 0:\n               tid = 1\n            else:\n               tid = list(connData['ConnectedShares'].keys())[-1] + 1\n            connData['ConnectedShares'][tid] = share\n            connData['ConnectedShares'][tid]['shareName'] = path\n            resp['Tid'] = tid\n            #smbServer.log(\"Connecting Share(%d:%s)\" % (tid,path))\n        else:\n            smbServer.log(\"TreeConnectAndX not found %s\" % path, logging.ERROR)\n            errorCode = STATUS_OBJECT_PATH_NOT_FOUND\n            resp['ErrorCode']   = errorCode >> 16\n            resp['ErrorClass']  = errorCode & 0xff\n        ##\n        respParameters['OptionalSupport'] = smb.SMB.SMB_SUPPORT_SEARCH_BITS\n\n        if path == 'IPC$':\n            respData['Service']               = 'IPC'\n        else:\n            respData['Service']               = path\n        respData['PadLen']                = 0\n        respData['NativeFileSystem']      = encodeSMBString(recvPacket['Flags2'], 'NTFS' ).decode()\n\n        respSMBCommand['Parameters']             = respParameters\n        respSMBCommand['Data']                   = respData \n\n        resp['Uid'] = connData['Uid']\n        resp.addCommand(respSMBCommand)\n\n        # Sign the packet if needed\n        if connData['SignatureEnabled']:\n            smbServer.signSMBv1(connData, resp, connData['SigningSessionKey'], connData['SigningChallengeResponse'])\n        smbServer.setConnectionData(connId, connData)\n\n        return None, [resp], errorCode\n\n    @staticmethod\n    def smbComSessionSetupAndX(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId, checkStatus = False)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_SESSION_SETUP_ANDX)\n\n        # From [MS-SMB]\n        # When extended security is being used (see section 3.2.4.2.4), the \n        # request MUST take the following form\n        # [..]\n        # WordCount (1 byte): The value of this field MUST be 0x0C.\n        if SMBCommand['WordCount'] == 12:\n            # Extended security. Here we deal with all SPNEGO stuff\n            respParameters = smb.SMBSessionSetupAndX_Extended_Response_Parameters()\n            respData       = smb.SMBSessionSetupAndX_Extended_Response_Data(flags = recvPacket['Flags2'])\n            sessionSetupParameters = smb.SMBSessionSetupAndX_Extended_Parameters(SMBCommand['Parameters'])\n            sessionSetupData = smb.SMBSessionSetupAndX_Extended_Data()\n            sessionSetupData['SecurityBlobLength'] = sessionSetupParameters['SecurityBlobLength']\n            sessionSetupData.fromString(SMBCommand['Data'])\n            connData['Capabilities'] = sessionSetupParameters['Capabilities']\n\n            rawNTLM = False\n            if struct.unpack('B',sessionSetupData['SecurityBlob'][0:1])[0] == ASN1_AID:\n               # NEGOTIATE packet\n               blob =  SPNEGO_NegTokenInit(sessionSetupData['SecurityBlob'])\n               token = blob['MechToken']\n               if len(blob['MechTypes'][0]) > 0:\n                   # Is this GSSAPI NTLM or something else we don't support?\n                   mechType = blob['MechTypes'][0]\n                   if mechType != TypesMech['NTLMSSP - Microsoft NTLM Security Support Provider']:\n                       # Nope, do we know it?\n                       if mechType in MechTypes:\n                           mechStr = MechTypes[mechType]\n                       else:\n                           mechStr = hexlify(mechType)\n                       smbServer.log(\"Unsupported MechType '%s'\" % mechStr, logging.CRITICAL)\n                       # We don't know the token, we answer back again saying \n                       # we just support NTLM.\n                       # ToDo: Build this into a SPNEGO_NegTokenResp()\n                       respToken = b'\\xa1\\x15\\x30\\x13\\xa0\\x03\\x0a\\x01\\x03\\xa1\\x0c\\x06\\x0a\\x2b\\x06\\x01\\x04\\x01\\x82\\x37\\x02\\x02\\x0a'\n                       respParameters['SecurityBlobLength'] = len(respToken)\n                       respData['SecurityBlobLength'] = respParameters['SecurityBlobLength'] \n                       respData['SecurityBlob']       = respToken\n                       respData['NativeOS']     = encodeSMBString(recvPacket['Flags2'], smbServer.getServerOS())\n                       respData['NativeLanMan'] = encodeSMBString(recvPacket['Flags2'], smbServer.getServerOS())\n                       respSMBCommand['Parameters'] = respParameters\n                       respSMBCommand['Data']       = respData \n                       return [respSMBCommand], None, STATUS_MORE_PROCESSING_REQUIRED\n\n            elif struct.unpack('B',sessionSetupData['SecurityBlob'][0:1])[0] == ASN1_SUPPORTED_MECH:\n               # AUTH packet\n               blob = SPNEGO_NegTokenResp(sessionSetupData['SecurityBlob'])\n               token = blob['ResponseToken']\n            else:\n               # No GSSAPI stuff, raw NTLMSSP\n               rawNTLM = True\n               token = sessionSetupData['SecurityBlob']\n\n            # Here we only handle NTLMSSP, depending on what stage of the \n            # authentication we are, we act on it\n            messageType = struct.unpack('<L',token[len('NTLMSSP\\x00'):len('NTLMSSP\\x00')+4])[0]\n\n            if messageType == 0x01:\n                # NEGOTIATE_MESSAGE\n                negotiateMessage = ntlm.NTLMAuthNegotiate()\n                negotiateMessage.fromString(token)\n                # Let's store it in the connection data\n                connData['NEGOTIATE_MESSAGE'] = negotiateMessage\n                # Let's build the answer flags\n                # TODO: Parse all the flags. With this we're leaving some clients out \n\n                ansFlags = 0\n\n                if negotiateMessage['flags'] & ntlm.NTLMSSP_NEGOTIATE_56:\n                   ansFlags |= ntlm.NTLMSSP_NEGOTIATE_56\n                if negotiateMessage['flags'] & ntlm.NTLMSSP_NEGOTIATE_128:\n                   ansFlags |= ntlm.NTLMSSP_NEGOTIATE_128\n                if negotiateMessage['flags'] & ntlm.NTLMSSP_NEGOTIATE_KEY_EXCH:\n                   ansFlags |= ntlm.NTLMSSP_NEGOTIATE_KEY_EXCH\n                if negotiateMessage['flags'] & ntlm.NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY:\n                   ansFlags |= ntlm.NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY\n                if negotiateMessage['flags'] & ntlm.NTLMSSP_NEGOTIATE_UNICODE:\n                   ansFlags |= ntlm.NTLMSSP_NEGOTIATE_UNICODE\n                if negotiateMessage['flags'] & ntlm.NTLM_NEGOTIATE_OEM:\n                   ansFlags |= ntlm.NTLM_NEGOTIATE_OEM\n\n                ansFlags |= ntlm.NTLMSSP_NEGOTIATE_VERSION | ntlm.NTLMSSP_NEGOTIATE_TARGET_INFO | ntlm.NTLMSSP_TARGET_TYPE_SERVER | ntlm.NTLMSSP_NEGOTIATE_NTLM | ntlm.NTLMSSP_REQUEST_TARGET\n\n                # Generate the AV_PAIRS\n                av_pairs = ntlm.AV_PAIRS()\n                # TODO: Put the proper data from SMBSERVER config\n                av_pairs[ntlm.NTLMSSP_AV_HOSTNAME] = av_pairs[ntlm.NTLMSSP_AV_DNS_HOSTNAME] = smbServer.getServerName().encode('utf-16le')\n                av_pairs[ntlm.NTLMSSP_AV_DOMAINNAME] = av_pairs[ntlm.NTLMSSP_AV_DNS_DOMAINNAME] = smbServer.getServerDomain().encode('utf-16le')\n                av_pairs[ntlm.NTLMSSP_AV_TIME] = struct.pack('<q', (116444736000000000 + calendar.timegm(time.gmtime()) * 10000000) )\n\n                challengeMessage = ntlm.NTLMAuthChallenge()\n                challengeMessage['flags']            = ansFlags\n                challengeMessage['domain_len']       = len(smbServer.getServerDomain().encode('utf-16le'))\n                challengeMessage['domain_max_len']   = challengeMessage['domain_len']\n                challengeMessage['domain_offset']    = 40 + 16\n                challengeMessage['challenge']        = smbServer.getSMBChallenge()\n                challengeMessage['domain_name']      = smbServer.getServerDomain().encode('utf-16le')\n                challengeMessage['TargetInfoFields_len']     = len(av_pairs)\n                challengeMessage['TargetInfoFields_max_len'] = len(av_pairs)\n                challengeMessage['TargetInfoFields'] = av_pairs\n                challengeMessage['TargetInfoFields_offset']  = 40 + 16 + len(challengeMessage['domain_name'])\n                challengeMessage['Version']          = b'\\xff'*8\n                challengeMessage['VersionLen']       = 8\n\n                if rawNTLM is False:\n                    respToken = SPNEGO_NegTokenResp()\n                    # accept-incomplete. We want more data\n                    respToken['NegState'] = b'\\x01'\n                    respToken['SupportedMech'] = TypesMech['NTLMSSP - Microsoft NTLM Security Support Provider']\n\n                    respToken['ResponseToken'] = challengeMessage.getData()\n                else:\n                    respToken = challengeMessage\n\n                # Setting the packet to STATUS_MORE_PROCESSING\n                errorCode = STATUS_MORE_PROCESSING_REQUIRED\n                # Let's set up an UID for this connection and store it \n                # in the connection's data\n                # Picking a fixed value\n                # TODO: Manage more UIDs for the same session\n                connData['Uid'] = 10\n                # Let's store it in the connection data\n                connData['CHALLENGE_MESSAGE'] = challengeMessage\n\n            elif messageType == 0x02:\n                # CHALLENGE_MESSAGE\n                raise Exception('Challenge Message raise, not implemented!')\n            elif messageType == 0x03:\n                # AUTHENTICATE_MESSAGE, here we deal with authentication\n                authenticateMessage = ntlm.NTLMAuthChallengeResponse()\n                authenticateMessage.fromString(token)\n                smbServer.log(\"AUTHENTICATE_MESSAGE (%s\\\\%s,%s)\" % (\n                authenticateMessage['domain_name'].decode('utf-16le'),\n                authenticateMessage['user_name'].decode('utf-16le'),\n                authenticateMessage['host_name'].decode('utf-16le')))\n                # Do we have credentials to check?\n                if len(smbServer.getCredentials()) > 0:\n                    identity = authenticateMessage['user_name'].decode('utf-16le').lower()\n                    # Do we have this user's credentials?\n                    if identity in smbServer.getCredentials():\n                        # Process data:\n                        # Let's parse some data and keep it to ourselves in case it is asked\n                        uid, lmhash, nthash = smbServer.getCredentials()[identity]\n\n                        errorCode, sessionKey = computeNTLMv2(identity, lmhash, nthash, smbServer.getSMBChallenge(),\n                                             authenticateMessage, connData['CHALLENGE_MESSAGE'], connData['NEGOTIATE_MESSAGE'])\n\n                        if sessionKey is not None:\n                            connData['SignatureEnabled'] = False\n                            connData['SigningSessionKey'] = sessionKey\n                            connData['SignSequenceNumber'] = 1\n                    else:\n                        errorCode = STATUS_LOGON_FAILURE\n                else:\n                    # No credentials provided, let's grant access\n                    errorCode = STATUS_SUCCESS\n\n                if errorCode == STATUS_SUCCESS:\n                    connData['Authenticated'] = True\n                    respToken = SPNEGO_NegTokenResp()\n                    # accept-completed\n                    respToken['NegState'] = b'\\x00'\n\n                    smbServer.log('User %s\\\\%s authenticated successfully' % (authenticateMessage['host_name'].decode('utf-16le'),\n                                                                              authenticateMessage['user_name'].decode('utf-16le')))\n                    # Let's store it in the connection data\n                    connData['AUTHENTICATE_MESSAGE'] = authenticateMessage\n                    try:\n                        jtr_dump_path = smbServer.getJTRdumpPath()\n                        ntlm_hash_data = outputToJohnFormat(connData['CHALLENGE_MESSAGE']['challenge'],\n                                                            authenticateMessage['user_name'],\n                                                            authenticateMessage['domain_name'],\n                                                            authenticateMessage['lanman'], authenticateMessage['ntlm'])\n                        smbServer.log(ntlm_hash_data['hash_string'])\n                        if jtr_dump_path != '':\n                            writeJohnOutputToFile(ntlm_hash_data['hash_string'], ntlm_hash_data['hash_version'], jtr_dump_path)\n                    except:\n                        smbServer.log(\"Could not write NTLM Hashes to the specified JTR_Dump_Path %s\" % jtr_dump_path)\n                else:\n                    respToken = SPNEGO_NegTokenResp()\n                    respToken['NegState'] = b'\\x02'\n                    smbServer.log(\"Could not authenticate user!\")\n            else:\n                raise Exception(\"Unknown NTLMSSP MessageType %d\" % messageType)\n\n            respParameters['SecurityBlobLength'] = len(respToken)\n            respData['SecurityBlobLength'] = respParameters['SecurityBlobLength'] \n            respData['SecurityBlob']       = respToken.getData()\n\n        else:\n            # Process Standard Security\n            respParameters = smb.SMBSessionSetupAndXResponse_Parameters()\n            respData       = smb.SMBSessionSetupAndXResponse_Data()\n            sessionSetupParameters = smb.SMBSessionSetupAndX_Parameters(SMBCommand['Parameters'])\n            sessionSetupData = smb.SMBSessionSetupAndX_Data()\n            sessionSetupData['AnsiPwdLength'] = sessionSetupParameters['AnsiPwdLength']\n            sessionSetupData['UnicodePwdLength'] = sessionSetupParameters['UnicodePwdLength']\n            sessionSetupData.fromString(SMBCommand['Data'])\n            connData['Capabilities'] = sessionSetupParameters['Capabilities']\n            # Do the verification here, for just now we grant access\n            # TODO: Manage more UIDs for the same session\n            errorCode = STATUS_SUCCESS\n            connData['Uid'] = 10\n            connData['Authenticated'] = True\n            respParameters['Action'] = 0\n            smbServer.log('User %s\\\\%s authenticated successfully (basic)' % (sessionSetupData['PrimaryDomain'], sessionSetupData['Account']))\n            try:\n                jtr_dump_path = smbServer.getJTRdumpPath()\n                ntlm_hash_data = outputToJohnFormat( b'', b(sessionSetupData['Account']), b(sessionSetupData['PrimaryDomain']), sessionSetupData['AnsiPwd'], sessionSetupData['UnicodePwd'] )\n                smbServer.log(ntlm_hash_data['hash_string'])\n                if jtr_dump_path != '':\n                    writeJohnOutputToFile(ntlm_hash_data['hash_string'], ntlm_hash_data['hash_version'], jtr_dump_path)\n            except:\n                smbServer.log(\"Could not write NTLM Hashes to the specified JTR_Dump_Path %s\" % jtr_dump_path)\n\n        respData['NativeOS']     = encodeSMBString(recvPacket['Flags2'], smbServer.getServerOS())\n        respData['NativeLanMan'] = encodeSMBString(recvPacket['Flags2'], smbServer.getServerOS())\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data']       = respData \n\n        # From now on, the client can ask for other commands\n        connData['Authenticated'] = True\n        # For now, just switching to nobody\n        #os.setregid(65534,65534)\n        #os.setreuid(65534,65534)\n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smbComNegotiate(connId, smbServer, SMBCommand, recvPacket ):\n        connData = smbServer.getConnectionData(connId, checkStatus = False)\n        connData['Pid'] = recvPacket['Pid']\n\n        SMBCommand = smb.SMBCommand(recvPacket['Data'][0])\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_NEGOTIATE)\n        \n        resp = smb.NewSMBPacket()\n        resp['Flags1'] = smb.SMB.FLAGS1_REPLY\n        resp['Pid'] = connData['Pid']\n        resp['Tid'] = recvPacket['Tid']\n        resp['Mid'] = recvPacket['Mid']\n\n        # TODO: We support more dialects, and parse them accordingly\n        dialects = SMBCommand['Data'].split(b'\\x02')\n        try: \n           index = dialects.index(b'NT LM 0.12\\x00') - 1\n           # Let's fill the data for NTLM\n           if recvPacket['Flags2'] & smb.SMB.FLAGS2_EXTENDED_SECURITY:\n                    resp['Flags2'] = smb.SMB.FLAGS2_EXTENDED_SECURITY | smb.SMB.FLAGS2_NT_STATUS | smb.SMB.FLAGS2_UNICODE\n                    #resp['Flags2'] = smb.SMB.FLAGS2_EXTENDED_SECURITY | smb.SMB.FLAGS2_NT_STATUS \n                    _dialects_data = smb.SMBExtended_Security_Data()\n                    _dialects_data['ServerGUID'] = b'A'*16\n                    blob = SPNEGO_NegTokenInit()\n                    blob['MechTypes'] = [TypesMech['NTLMSSP - Microsoft NTLM Security Support Provider']]\n                    _dialects_data['SecurityBlob'] = blob.getData()\n        \n                    _dialects_parameters = smb.SMBExtended_Security_Parameters()\n                    _dialects_parameters['Capabilities']    = smb.SMB.CAP_EXTENDED_SECURITY | smb.SMB.CAP_USE_NT_ERRORS | smb.SMB.CAP_NT_SMBS | smb.SMB.CAP_UNICODE \n                    _dialects_parameters['ChallengeLength'] = 0\n\n           else:\n                    resp['Flags2'] = smb.SMB.FLAGS2_NT_STATUS | smb.SMB.FLAGS2_UNICODE\n                    _dialects_parameters = smb.SMBNTLMDialect_Parameters()\n                    _dialects_data= smb.SMBNTLMDialect_Data()\n                    _dialects_data['Payload'] = ''\n                    if 'EncryptionKey' in connData:\n                        _dialects_data['Challenge'] = connData['EncryptionKey']\n                        _dialects_parameters['ChallengeLength'] = len(_dialects_data.getData())\n                    else:\n                        # TODO: Handle random challenges, now one that can be used with rainbow tables\n                        _dialects_data['Challenge'] = b'\\x11\\x22\\x33\\x44\\x55\\x66\\x77\\x88'\n                        _dialects_parameters['ChallengeLength'] = 8\n                    _dialects_parameters['Capabilities']    = smb.SMB.CAP_USE_NT_ERRORS | smb.SMB.CAP_NT_SMBS \n\n           # Let's see if we need to support RPC_REMOTE_APIS\n           config = smbServer.getServerConfig()\n           if config.has_option('global','rpc_apis'):\n               if config.getboolean('global', 'rpc_apis') is True:\n                  _dialects_parameters['Capabilities'] |= smb.SMB.CAP_RPC_REMOTE_APIS\n\n           _dialects_parameters['DialectIndex']    = index\n           #_dialects_parameters['SecurityMode']    = smb.SMB.SECURITY_AUTH_ENCRYPTED | smb.SMB.SECURITY_SHARE_USER | smb.SMB.SECURITY_SIGNATURES_REQUIRED\n           _dialects_parameters['SecurityMode']    = smb.SMB.SECURITY_AUTH_ENCRYPTED | smb.SMB.SECURITY_SHARE_USER\n           _dialects_parameters['MaxMpxCount']     = 1\n           _dialects_parameters['MaxNumberVcs']    = 1\n           _dialects_parameters['MaxBufferSize']   = 64000\n           _dialects_parameters['MaxRawSize']      = 65536\n           _dialects_parameters['SessionKey']      = 0\n           _dialects_parameters['LowDateTime']     = 0\n           _dialects_parameters['HighDateTime']    = 0\n           _dialects_parameters['ServerTimeZone']  = 0 \n\n\n           respSMBCommand['Data']           = _dialects_data\n           respSMBCommand['Parameters']     = _dialects_parameters\n           connData['_dialects_data']       = _dialects_data\n           connData['_dialects_parameters'] = _dialects_parameters\n\n        except Exception as e:\n           # No NTLM throw an error\n           smbServer.log('smbComNegotiate: %s' % e, logging.ERROR)\n           respSMBCommand['Data'] = struct.pack('<H',0xffff) \n\n       \n        smbServer.setConnectionData(connId, connData)\n\n        resp.addCommand(respSMBCommand)\n        \n        return None, [resp], STATUS_SUCCESS\n\n    @staticmethod\n    def default(connId, smbServer, SMBCommand, recvPacket):\n        # By default we return an SMB Packet with error not implemented\n        smbServer.log(\"Not implemented command: 0x%x\" % recvPacket['Command'],logging.DEBUG)\n        packet = smb.NewSMBPacket()\n        packet['Flags1']  = smb.SMB.FLAGS1_REPLY\n        packet['Flags2']  = smb.SMB.FLAGS2_NT_STATUS \n        packet['Command'] = recvPacket['Command']\n        packet['Pid']     = recvPacket['Pid']\n        packet['Tid']     = recvPacket['Tid']\n        packet['Mid']     = recvPacket['Mid']\n        packet['Uid']     = recvPacket['Uid']\n        packet['Data']    = b'\\x00\\x00\\x00'\n        errorCode = STATUS_NOT_IMPLEMENTED\n        packet['ErrorCode']   = errorCode >> 16\n        packet['ErrorClass']  = errorCode & 0xff\n\n        return None, [packet], errorCode\n\nclass SMB2Commands:\n    @staticmethod\n    def smb2Negotiate(connId, smbServer, recvPacket, isSMB1 = False):\n        connData = smbServer.getConnectionData(connId, checkStatus = False)\n\n        respPacket = smb2.SMB2Packet()\n        respPacket['Flags']     = smb2.SMB2_FLAGS_SERVER_TO_REDIR\n        respPacket['Status']    = STATUS_SUCCESS\n        respPacket['CreditRequestResponse'] = 1\n        respPacket['Command']   = smb2.SMB2_NEGOTIATE\n        respPacket['SessionID'] = 0\n        if isSMB1 is False:\n            respPacket['MessageID'] = recvPacket['MessageID']\n        else:\n            respPacket['MessageID'] = 0\n        respPacket['TreeID']    = 0\n\n\n        respSMBCommand = smb2.SMB2Negotiate_Response()\n\n        respSMBCommand['SecurityMode'] = 1\n        if isSMB1 is True:\n            # Let's first parse the packet to see if the client supports SMB2\n            SMBCommand = smb.SMBCommand(recvPacket['Data'][0])\n        \n            dialects = SMBCommand['Data'].split(b'\\x02')\n            if b'SMB 2.002\\x00' in dialects or b'SMB 2.???\\x00' in dialects:\n                respSMBCommand['DialectRevision'] = smb2.SMB2_DIALECT_002\n            else:\n                # Client does not support SMB2 fallbacking\n                raise Exception('SMB2 not supported, fallbacking')\n        else:\n            respSMBCommand['DialectRevision'] = smb2.SMB2_DIALECT_002\n        respSMBCommand['ServerGuid'] = b'A'*16\n        respSMBCommand['Capabilities'] = 0\n        respSMBCommand['MaxTransactSize'] = 65536\n        respSMBCommand['MaxReadSize'] = 65536\n        respSMBCommand['MaxWriteSize'] = 65536\n        respSMBCommand['SystemTime'] = getFileTime(calendar.timegm(time.gmtime()))\n        respSMBCommand['ServerStartTime'] = getFileTime(calendar.timegm(time.gmtime()))\n        respSMBCommand['SecurityBufferOffset'] = 0x80\n\n        blob = SPNEGO_NegTokenInit()\n        blob['MechTypes'] = [TypesMech['NTLMSSP - Microsoft NTLM Security Support Provider']]\n\n        respSMBCommand['Buffer'] = blob.getData()\n        respSMBCommand['SecurityBufferLength'] = len(respSMBCommand['Buffer'])\n\n        respPacket['Data']      = respSMBCommand\n\n        smbServer.setConnectionData(connId, connData)\n\n        return None, [respPacket], STATUS_SUCCESS\n\n    @staticmethod\n    def smb2SessionSetup(connId, smbServer, recvPacket):\n        connData = smbServer.getConnectionData(connId, checkStatus = False)\n\n        respSMBCommand = smb2.SMB2SessionSetup_Response()\n\n        sessionSetupData = smb2.SMB2SessionSetup(recvPacket['Data'])\n\n        connData['Capabilities'] = sessionSetupData['Capabilities']\n\n        securityBlob = sessionSetupData['Buffer']\n\n        rawNTLM = False\n        if struct.unpack('B',securityBlob[0:1])[0] == ASN1_AID:\n           # NEGOTIATE packet\n           blob =  SPNEGO_NegTokenInit(securityBlob)\n           token = blob['MechToken']\n           if len(blob['MechTypes'][0]) > 0:\n               # Is this GSSAPI NTLM or something else we don't support?\n               mechType = blob['MechTypes'][0]\n               if mechType != TypesMech['NTLMSSP - Microsoft NTLM Security Support Provider']:\n                   # Nope, do we know it?\n                   if mechType in MechTypes:\n                       mechStr = MechTypes[mechType]\n                   else:\n                       mechStr = hexlify(mechType)\n                   smbServer.log(\"Unsupported MechType '%s'\" % mechStr, logging.CRITICAL)\n                   # We don't know the token, we answer back again saying \n                   # we just support NTLM.\n                   # ToDo: Build this into a SPNEGO_NegTokenResp()\n                   respToken = b'\\xa1\\x15\\x30\\x13\\xa0\\x03\\x0a\\x01\\x03\\xa1\\x0c\\x06\\x0a\\x2b\\x06\\x01\\x04\\x01\\x82\\x37\\x02\\x02\\x0a'\n                   respSMBCommand['SecurityBufferOffset'] = 0x48\n                   respSMBCommand['SecurityBufferLength'] = len(respToken)\n                   respSMBCommand['Buffer'] = respToken\n\n                   return [respSMBCommand], None, STATUS_MORE_PROCESSING_REQUIRED\n        elif struct.unpack('B',securityBlob[0:1])[0] == ASN1_SUPPORTED_MECH:\n           # AUTH packet\n           blob = SPNEGO_NegTokenResp(securityBlob)\n           token = blob['ResponseToken']\n        else:\n           # No GSSAPI stuff, raw NTLMSSP\n           rawNTLM = True\n           token = securityBlob\n\n        # Here we only handle NTLMSSP, depending on what stage of the \n        # authentication we are, we act on it\n        messageType = struct.unpack('<L',token[len('NTLMSSP\\x00'):len('NTLMSSP\\x00')+4])[0]\n\n        if messageType == 0x01:\n            # NEGOTIATE_MESSAGE\n            negotiateMessage = ntlm.NTLMAuthNegotiate()\n            negotiateMessage.fromString(token)\n            # Let's store it in the connection data\n            connData['NEGOTIATE_MESSAGE'] = negotiateMessage\n            # Let's build the answer flags\n            # TODO: Parse all the flags. With this we're leaving some clients out \n\n            ansFlags = 0\n\n            if negotiateMessage['flags'] & ntlm.NTLMSSP_NEGOTIATE_56:\n               ansFlags |= ntlm.NTLMSSP_NEGOTIATE_56\n            if negotiateMessage['flags'] & ntlm.NTLMSSP_NEGOTIATE_128:\n               ansFlags |= ntlm.NTLMSSP_NEGOTIATE_128\n            if negotiateMessage['flags'] & ntlm.NTLMSSP_NEGOTIATE_KEY_EXCH:\n               ansFlags |= ntlm.NTLMSSP_NEGOTIATE_KEY_EXCH\n            if negotiateMessage['flags'] & ntlm.NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY:\n               ansFlags |= ntlm.NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY\n            if negotiateMessage['flags'] & ntlm.NTLMSSP_NEGOTIATE_UNICODE:\n               ansFlags |= ntlm.NTLMSSP_NEGOTIATE_UNICODE\n            if negotiateMessage['flags'] & ntlm.NTLM_NEGOTIATE_OEM:\n               ansFlags |= ntlm.NTLM_NEGOTIATE_OEM\n\n            ansFlags |= ntlm.NTLMSSP_NEGOTIATE_VERSION | ntlm.NTLMSSP_NEGOTIATE_TARGET_INFO | ntlm.NTLMSSP_TARGET_TYPE_SERVER | ntlm.NTLMSSP_NEGOTIATE_NTLM | ntlm.NTLMSSP_REQUEST_TARGET\n\n            # Generate the AV_PAIRS\n            av_pairs = ntlm.AV_PAIRS()\n            # TODO: Put the proper data from SMBSERVER config\n            av_pairs[ntlm.NTLMSSP_AV_HOSTNAME] = av_pairs[ntlm.NTLMSSP_AV_DNS_HOSTNAME] = smbServer.getServerName().encode('utf-16le')\n            av_pairs[ntlm.NTLMSSP_AV_DOMAINNAME] = av_pairs[ntlm.NTLMSSP_AV_DNS_DOMAINNAME] = smbServer.getServerDomain().encode('utf-16le')\n            av_pairs[ntlm.NTLMSSP_AV_TIME] = struct.pack('<q', (116444736000000000 + calendar.timegm(time.gmtime()) * 10000000) )\n\n            challengeMessage = ntlm.NTLMAuthChallenge()\n            challengeMessage['flags']            = ansFlags\n            challengeMessage['domain_len']       = len(smbServer.getServerDomain().encode('utf-16le'))\n            challengeMessage['domain_max_len']   = challengeMessage['domain_len']\n            challengeMessage['domain_offset']    = 40 + 16\n            challengeMessage['challenge']        = smbServer.getSMBChallenge()\n            challengeMessage['domain_name']      = smbServer.getServerDomain().encode('utf-16le')\n            challengeMessage['TargetInfoFields_len']     = len(av_pairs)\n            challengeMessage['TargetInfoFields_max_len'] = len(av_pairs)\n            challengeMessage['TargetInfoFields'] = av_pairs\n            challengeMessage['TargetInfoFields_offset']  = 40 + 16 + len(challengeMessage['domain_name'])\n            challengeMessage['Version']          = b'\\xff'*8\n            challengeMessage['VersionLen']       = 8\n\n            if rawNTLM is False:\n                respToken = SPNEGO_NegTokenResp()\n                # accept-incomplete. We want more data\n                respToken['NegState'] = b'\\x01'\n                respToken['SupportedMech'] = TypesMech['NTLMSSP - Microsoft NTLM Security Support Provider']\n\n                respToken['ResponseToken'] = challengeMessage.getData()\n            else:\n                respToken = challengeMessage\n\n            # Setting the packet to STATUS_MORE_PROCESSING\n            errorCode = STATUS_MORE_PROCESSING_REQUIRED\n            # Let's set up an UID for this connection and store it \n            # in the connection's data\n            # Picking a fixed value\n            # TODO: Manage more UIDs for the same session\n            connData['Uid'] = random.randint(1,0xffffffff)\n            # Let's store it in the connection data\n            connData['CHALLENGE_MESSAGE'] = challengeMessage\n\n        elif messageType == 0x02:\n            # CHALLENGE_MESSAGE\n            raise Exception('Challenge Message raise, not implemented!')\n        elif messageType == 0x03:\n            # AUTHENTICATE_MESSAGE, here we deal with authentication\n            authenticateMessage = ntlm.NTLMAuthChallengeResponse()\n            authenticateMessage.fromString(token)\n            smbServer.log(\"AUTHENTICATE_MESSAGE (%s\\\\%s,%s)\" % (\n            authenticateMessage['domain_name'].decode('utf-16le'), authenticateMessage['user_name'].decode('utf-16le'),\n            authenticateMessage['host_name'].decode('utf-16le')))\n            # TODO: Check the credentials! Now granting permissions\n            # Do we have credentials to check?\n            if len(smbServer.getCredentials()) > 0:\n                isGuest = False\n                identity = authenticateMessage['user_name'].decode('utf-16le').lower()\n                # Do we have this user's credentials?\n                if identity in smbServer.getCredentials():\n                    # Process data:\n                    # Let's parse some data and keep it to ourselves in case it is asked\n                    uid, lmhash, nthash = smbServer.getCredentials()[identity]\n\n                    errorCode, sessionKey = computeNTLMv2(identity, lmhash, nthash, smbServer.getSMBChallenge(),\n                                                          authenticateMessage, connData['CHALLENGE_MESSAGE'],\n                                                          connData['NEGOTIATE_MESSAGE'])\n\n                    if sessionKey is not None:\n                        connData['SignatureEnabled'] = True\n                        connData['SigningSessionKey'] = sessionKey\n                        connData['SignSequenceNumber'] = 1\n                else:\n                    errorCode = STATUS_LOGON_FAILURE\n            else:\n                # No credentials provided, let's grant access\n                isGuest = True\n                errorCode = STATUS_SUCCESS\n\n            if errorCode == STATUS_SUCCESS:\n                connData['Authenticated'] = True\n                respToken = SPNEGO_NegTokenResp()\n                # accept-completed\n                respToken['NegState'] = b'\\x00'\n                smbServer.log('User %s\\\\%s authenticated successfully' % (\n                authenticateMessage['host_name'].decode('utf-16le'), authenticateMessage['user_name'].decode('utf-16le')))\n                # Let's store it in the connection data\n                connData['AUTHENTICATE_MESSAGE'] = authenticateMessage\n                try:\n                    jtr_dump_path = smbServer.getJTRdumpPath()\n                    ntlm_hash_data = outputToJohnFormat(connData['CHALLENGE_MESSAGE']['challenge'],\n                                                        authenticateMessage['user_name'],\n                                                        authenticateMessage['domain_name'],\n                                                        authenticateMessage['lanman'], authenticateMessage['ntlm'])\n                    smbServer.log(ntlm_hash_data['hash_string'])\n                    if jtr_dump_path != '':\n                        writeJohnOutputToFile(ntlm_hash_data['hash_string'], ntlm_hash_data['hash_version'],\n                                              jtr_dump_path)\n                except:\n                    smbServer.log(\"Could not write NTLM Hashes to the specified JTR_Dump_Path %s\" % jtr_dump_path)\n\n                if isGuest:\n                    respSMBCommand['SessionFlags'] = 1\n\n            else:\n                respToken = SPNEGO_NegTokenResp()\n                respToken['NegState'] = b'\\x02'\n                smbServer.log(\"Could not authenticate user!\")\n        else:\n            raise Exception(\"Unknown NTLMSSP MessageType %d\" % messageType)\n\n        respSMBCommand['SecurityBufferOffset'] = 0x48\n        respSMBCommand['SecurityBufferLength'] = len(respToken)\n        respSMBCommand['Buffer'] = respToken.getData()\n\n        # From now on, the client can ask for other commands\n        connData['Authenticated'] = True\n        # For now, just switching to nobody\n        #os.setregid(65534,65534)\n        #os.setreuid(65534,65534)\n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smb2TreeConnect(connId, smbServer, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respPacket = smb2.SMB2Packet()\n        respPacket['Flags']     = smb2.SMB2_FLAGS_SERVER_TO_REDIR\n        respPacket['Status']    = STATUS_SUCCESS\n        respPacket['CreditRequestResponse'] = 1\n        respPacket['Command']   = recvPacket['Command']\n        respPacket['SessionID'] = connData['Uid']\n        respPacket['Reserved']  = recvPacket['Reserved']\n        respPacket['MessageID'] = recvPacket['MessageID']\n        respPacket['TreeID']    = recvPacket['TreeID']\n\n        respSMBCommand        = smb2.SMB2TreeConnect_Response()\n\n        treeConnectRequest = smb2.SMB2TreeConnect(recvPacket['Data'])\n\n        errorCode = STATUS_SUCCESS\n\n        ## Process here the request, does the share exist?\n        path = recvPacket.getData()[treeConnectRequest['PathOffset']:][:treeConnectRequest['PathLength']]\n        UNCOrShare = path.decode('utf-16le')\n\n        # Is this a UNC?\n        if ntpath.ismount(UNCOrShare):\n            path = UNCOrShare.split('\\\\')[3]\n        else:\n            path = ntpath.basename(UNCOrShare)\n\n        share = searchShare(connId, path.upper(), smbServer)\n        if share is not None:\n            # Simple way to generate a Tid\n            if len(connData['ConnectedShares']) == 0:\n               tid = 1\n            else:\n               tid = list(connData['ConnectedShares'].keys())[-1] + 1\n            connData['ConnectedShares'][tid] = share\n            connData['ConnectedShares'][tid]['shareName'] = path\n            respPacket['TreeID']    = tid\n            smbServer.log(\"Connecting Share(%d:%s)\" % (tid,path))\n        else:\n            smbServer.log(\"SMB2_TREE_CONNECT not found %s\" % path, logging.ERROR)\n            errorCode = STATUS_OBJECT_PATH_NOT_FOUND\n            respPacket['Status'] = errorCode\n        ##\n\n        if path.upper() == 'IPC$':\n            respSMBCommand['ShareType'] = smb2.SMB2_SHARE_TYPE_PIPE\n            respSMBCommand['ShareFlags'] = 0x30\n        else:\n            respSMBCommand['ShareType'] = smb2.SMB2_SHARE_TYPE_DISK\n            respSMBCommand['ShareFlags'] = 0x0\n\n        respSMBCommand['Capabilities'] = 0\n        respSMBCommand['MaximalAccess'] = 0x000f01ff\n\n        respPacket['Data'] = respSMBCommand\n\n        # Sign the packet if needed\n        if connData['SignatureEnabled']:\n            smbServer.signSMBv2(respPacket, connData['SigningSessionKey'])\n        smbServer.setConnectionData(connId, connData)\n\n        return None, [respPacket], errorCode\n\n    @staticmethod\n    def smb2Create(connId, smbServer, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand        = smb2.SMB2Create_Response()\n\n        ntCreateRequest       = smb2.SMB2Create(recvPacket['Data'])\n\n        respSMBCommand['Buffer'] = b'\\x00'\n        # Get the Tid associated\n        if recvPacket['TreeID'] in connData['ConnectedShares']:\n             # If we have a rootFid, the path is relative to that fid\n             errorCode = STATUS_SUCCESS\n             if 'path' in connData['ConnectedShares'][recvPacket['TreeID']]:\n                 path = connData['ConnectedShares'][recvPacket['TreeID']]['path']\n             else:\n                 path = 'NONE'\n                 errorCode = STATUS_ACCESS_DENIED\n\n             deleteOnClose = False\n\n             fileName = os.path.normpath(ntCreateRequest['Buffer'][:ntCreateRequest['NameLength']].decode('utf-16le').replace('\\\\','/'))\n             if len(fileName) > 0 and (fileName[0] == '/' or fileName[0] == '\\\\'):\n                # strip leading '/'\n                fileName = fileName[1:]\n             pathName = os.path.join(path,fileName)\n             createDisposition = ntCreateRequest['CreateDisposition']\n             mode = 0\n\n             if createDisposition == smb2.FILE_SUPERSEDE:\n                 mode |= os.O_TRUNC | os.O_CREAT\n             elif createDisposition & smb2.FILE_OVERWRITE_IF == smb2.FILE_OVERWRITE_IF:\n                 mode |= os.O_TRUNC | os.O_CREAT\n             elif createDisposition & smb2.FILE_OVERWRITE == smb2.FILE_OVERWRITE:\n                 if os.path.exists(pathName) is True:\n                     mode |= os.O_TRUNC \n                 else:\n                     errorCode = STATUS_NO_SUCH_FILE\n             elif createDisposition & smb2.FILE_OPEN_IF == smb2.FILE_OPEN_IF:\n                 if os.path.exists(pathName) is True:\n                     mode |= os.O_TRUNC \n                 else:\n                     mode |= os.O_TRUNC | os.O_CREAT\n             elif createDisposition & smb2.FILE_CREATE == smb2.FILE_CREATE:\n                 if os.path.exists(pathName) is True:\n                     errorCode = STATUS_OBJECT_NAME_COLLISION\n                 else:\n                     mode |= os.O_CREAT\n             elif createDisposition & smb2.FILE_OPEN == smb2.FILE_OPEN:\n                 if os.path.exists(pathName) is not True and (str(pathName) in smbServer.getRegisteredNamedPipes()) is not True:\n                     errorCode = STATUS_NO_SUCH_FILE\n\n             if errorCode == STATUS_SUCCESS:\n                 desiredAccess = ntCreateRequest['DesiredAccess']\n                 if (desiredAccess & smb2.FILE_READ_DATA) or (desiredAccess & smb2.GENERIC_READ):\n                     mode |= os.O_RDONLY\n                 if (desiredAccess & smb2.FILE_WRITE_DATA) or (desiredAccess & smb2.GENERIC_WRITE):\n                     if (desiredAccess & smb2.FILE_READ_DATA) or (desiredAccess & smb2.GENERIC_READ):\n                         mode |= os.O_RDWR #| os.O_APPEND\n                     else: \n                         mode |= os.O_WRONLY #| os.O_APPEND\n                 if desiredAccess & smb2.GENERIC_ALL:\n                     mode |= os.O_RDWR #| os.O_APPEND\n\n                 createOptions =  ntCreateRequest['CreateOptions']\n                 if mode & os.O_CREAT == os.O_CREAT:\n                     if createOptions & smb2.FILE_DIRECTORY_FILE == smb2.FILE_DIRECTORY_FILE: \n                         try:\n                             # Let's create the directory\n                             os.mkdir(pathName)\n                             mode = os.O_RDONLY\n                         except Exception as e:\n                             smbServer.log(\"SMB2_CREATE: %s,%s,%s\" % (pathName,mode,e),logging.ERROR)\n                             errorCode = STATUS_ACCESS_DENIED\n                 if createOptions & smb2.FILE_NON_DIRECTORY_FILE == smb2.FILE_NON_DIRECTORY_FILE:\n                     # If the file being opened is a directory, the server MUST fail the request with\n                     # STATUS_FILE_IS_A_DIRECTORY in the Status field of the SMB Header in the server\n                     # response.\n                     if os.path.isdir(pathName) is True:\n                        errorCode = STATUS_FILE_IS_A_DIRECTORY\n\n                 if createOptions & smb2.FILE_DELETE_ON_CLOSE == smb2.FILE_DELETE_ON_CLOSE:\n                     deleteOnClose = True\n                 \n                 if errorCode == STATUS_SUCCESS:\n                     try:\n                         if os.path.isdir(pathName) and sys.platform == 'win32':\n                            fid = VOID_FILE_DESCRIPTOR\n                         else:\n                            if sys.platform == 'win32':\n                               mode |= os.O_BINARY\n                            if str(pathName) in smbServer.getRegisteredNamedPipes():\n                                fid = PIPE_FILE_DESCRIPTOR\n                                sock = socket.socket()\n                                sock.connect(smbServer.getRegisteredNamedPipes()[str(pathName)])\n                            else:\n                                fid = os.open(pathName, mode)\n                     except Exception as e:\n                         smbServer.log(\"SMB2_CREATE: %s,%s,%s\" % (pathName,mode,e),logging.ERROR)\n                         #print e\n                         fid = 0\n                         errorCode = STATUS_ACCESS_DENIED\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        if errorCode == STATUS_SUCCESS:\n            # Simple way to generate a fid\n            fakefid = uuid.generate()\n\n            respSMBCommand['FileID'] = fakefid\n            respSMBCommand['CreateAction'] = createDisposition\n\n            if fid == PIPE_FILE_DESCRIPTOR:\n                respSMBCommand['CreationTime']   = 0\n                respSMBCommand['LastAccessTime'] = 0\n                respSMBCommand['LastWriteTime']  = 0\n                respSMBCommand['ChangeTime']     = 0\n                respSMBCommand['AllocationSize'] = 4096\n                respSMBCommand['EndOfFile']      = 0\n                respSMBCommand['FileAttributes'] = 0x80\n\n            else:\n                if os.path.isdir(pathName):\n                    respSMBCommand['FileAttributes'] = smb.SMB_FILE_ATTRIBUTE_DIRECTORY\n                else:\n                    respSMBCommand['FileAttributes'] = ntCreateRequest['FileAttributes']\n                # Let's get this file's information\n                respInfo, errorCode = queryPathInformation('',pathName,level= smb.SMB_QUERY_FILE_ALL_INFO)\n                if errorCode == STATUS_SUCCESS:\n                    respSMBCommand['CreationTime']   = respInfo['CreationTime']\n                    respSMBCommand['LastAccessTime'] = respInfo['LastAccessTime']\n                    respSMBCommand['LastWriteTime']  = respInfo['LastWriteTime']\n                    respSMBCommand['LastChangeTime'] = respInfo['LastChangeTime']\n                    respSMBCommand['FileAttributes'] = respInfo['ExtFileAttributes']\n                    respSMBCommand['AllocationSize'] = respInfo['AllocationSize']\n                    respSMBCommand['EndOfFile']      = respInfo['EndOfFile']\n\n            if errorCode == STATUS_SUCCESS:\n                # Let's store the fid for the connection\n                # smbServer.log('Create file %s, mode:0x%x' % (pathName, mode))\n                connData['OpenedFiles'][fakefid] = {}\n                connData['OpenedFiles'][fakefid]['FileHandle'] = fid\n                connData['OpenedFiles'][fakefid]['FileName'] = pathName\n                connData['OpenedFiles'][fakefid]['DeleteOnClose']  = deleteOnClose\n                connData['OpenedFiles'][fakefid]['Open']  = {}\n                connData['OpenedFiles'][fakefid]['Open']['EnumerationLocation'] = 0\n                connData['OpenedFiles'][fakefid]['Open']['EnumerationSearchPattern'] = ''\n                if fid == PIPE_FILE_DESCRIPTOR:\n                    connData['OpenedFiles'][fakefid]['Socket'] = sock\n        else:\n            respSMBCommand = smb2.SMB2Error()\n        \n        if errorCode == STATUS_SUCCESS:\n            connData['LastRequest']['SMB2_CREATE'] = respSMBCommand\n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smb2Close(connId, smbServer, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand        = smb2.SMB2Close_Response()\n\n        closeRequest = smb2.SMB2Close(recvPacket['Data'])\n\n        if closeRequest['FileID'].getData() == b'\\xff'*16:\n            # Let's take the data from the lastRequest\n            if  'SMB2_CREATE' in connData['LastRequest']:\n                fileID = connData['LastRequest']['SMB2_CREATE']['FileID']\n            else:\n                fileID = closeRequest['FileID'].getData()\n        else:\n            fileID = closeRequest['FileID'].getData()\n\n        if fileID in connData['OpenedFiles']:\n             errorCode = STATUS_SUCCESS\n             fileHandle = connData['OpenedFiles'][fileID]['FileHandle']\n             pathName = connData['OpenedFiles'][fileID]['FileName']\n             infoRecord = None\n             try:\n                 if fileHandle == PIPE_FILE_DESCRIPTOR:\n                     connData['OpenedFiles'][fileID]['Socket'].close()\n                 elif fileHandle != VOID_FILE_DESCRIPTOR:\n                     os.close(fileHandle)\n                     infoRecord, errorCode = queryFileInformation(os.path.dirname(pathName), os.path.basename(pathName), smb2.SMB2_FILE_NETWORK_OPEN_INFO)\n             except Exception as e:\n                 smbServer.log(\"SMB2_CLOSE %s\" % e, logging.ERROR)\n                 errorCode = STATUS_INVALID_HANDLE\n             else:\n                 # Check if the file was marked for removal\n                 if connData['OpenedFiles'][fileID]['DeleteOnClose'] is True:\n                     try:\n                         if os.path.isdir(pathName):\n                             shutil.rmtree(connData['OpenedFiles'][fileID]['FileName'])\n                         else:\n                             os.remove(connData['OpenedFiles'][fileID]['FileName'])\n                     except Exception as e:\n                         smbServer.log(\"SMB2_CLOSE %s\" % e, logging.ERROR)\n                         errorCode = STATUS_ACCESS_DENIED\n    \n                 # Now fill out the response\n                 if infoRecord is not None:\n                     respSMBCommand['CreationTime']   = infoRecord['CreationTime']\n                     respSMBCommand['LastAccessTime'] = infoRecord['LastAccessTime']\n                     respSMBCommand['LastWriteTime']  = infoRecord['LastWriteTime']\n                     respSMBCommand['ChangeTime']     = infoRecord['ChangeTime']\n                     respSMBCommand['AllocationSize'] = infoRecord['AllocationSize']\n                     respSMBCommand['EndofFile']      = infoRecord['EndOfFile']\n                     respSMBCommand['FileAttributes'] = infoRecord['FileAttributes']\n                 if errorCode == STATUS_SUCCESS:\n                     del(connData['OpenedFiles'][fileID])\n        else:\n            errorCode = STATUS_INVALID_HANDLE\n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smb2QueryInfo(connId, smbServer, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand        = smb2.SMB2QueryInfo_Response()\n\n        queryInfo = smb2.SMB2QueryInfo(recvPacket['Data'])\n       \n        errorCode = STATUS_SUCCESS \n\n        respSMBCommand['OutputBufferOffset'] = 0x48\n        respSMBCommand['Buffer'] = b'\\x00'\n\n        if queryInfo['FileID'].getData() == b'\\xff'*16:\n            # Let's take the data from the lastRequest\n            if  'SMB2_CREATE' in connData['LastRequest']:\n                fileID = connData['LastRequest']['SMB2_CREATE']['FileID']\n            else:\n                fileID = queryInfo['FileID'].getData()\n        else:\n            fileID = queryInfo['FileID'].getData()\n\n        if recvPacket['TreeID'] in connData['ConnectedShares']:\n            if fileID in connData['OpenedFiles']:\n                fileName = connData['OpenedFiles'][fileID]['FileName']\n\n                if queryInfo['InfoType'] == smb2.SMB2_0_INFO_FILE:\n                    if queryInfo['FileInfoClass'] == smb2.SMB2_FILE_INTERNAL_INFO:\n                        # No need to call queryFileInformation, we have the data here\n                        infoRecord = smb2.FileInternalInformation()\n                        infoRecord['IndexNumber'] = fileID\n                    else:\n                        infoRecord, errorCode = queryFileInformation(os.path.dirname(fileName),\n                                                                     os.path.basename(fileName),\n                                                                     queryInfo['FileInfoClass'])\n                elif queryInfo['InfoType'] == smb2.SMB2_0_INFO_FILESYSTEM:\n                    if queryInfo['FileInfoClass'] == smb2.SMB2_FILE_EA_INFO:\n                        infoRecord = b'\\x00'*4\n                    else:\n                        infoRecord = queryFsInformation(os.path.dirname(fileName), os.path.basename(fileName), queryInfo['FileInfoClass'])\n                elif queryInfo['InfoType'] == smb2.SMB2_0_INFO_SECURITY:\n                    # Failing for now, until we support it\n                    infoRecord = None\n                    errorCode = STATUS_ACCESS_DENIED\n                else:\n                    smbServer.log(\"queryInfo not supported (%x)\" %  queryInfo['InfoType'], logging.ERROR)\n\n                if infoRecord is not None:\n                    respSMBCommand['OutputBufferLength'] = len(infoRecord)\n                    respSMBCommand['Buffer'] = infoRecord\n            else:\n                errorCode = STATUS_INVALID_HANDLE\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smb2SetInfo(connId, smbServer, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand        = smb2.SMB2SetInfo_Response()\n\n        setInfo = smb2.SMB2SetInfo(recvPacket['Data'])\n       \n        errorCode = STATUS_SUCCESS \n\n        if setInfo['FileID'].getData() == b'\\xff'*16:\n            # Let's take the data from the lastRequest\n            if  'SMB2_CREATE' in connData['LastRequest']:\n                fileID = connData['LastRequest']['SMB2_CREATE']['FileID']\n            else:\n                fileID = setInfo['FileID'].getData()\n        else:\n            fileID = setInfo['FileID'].getData()\n\n        if recvPacket['TreeID'] in connData['ConnectedShares']:\n            path     = connData['ConnectedShares'][recvPacket['TreeID']]['path']\n            if fileID in connData['OpenedFiles']:\n                pathName = connData['OpenedFiles'][fileID]['FileName']\n\n                if setInfo['InfoType'] == smb2.SMB2_0_INFO_FILE:\n                    # The file information is being set\n                    informationLevel = setInfo['FileInfoClass']\n                    if informationLevel == smb2.SMB2_FILE_DISPOSITION_INFO:\n                        infoRecord = smb.SMBSetFileDispositionInfo(setInfo['Buffer'])\n                        if infoRecord['DeletePending'] > 0:\n                           # Mark this file for removal after closed\n                           connData['OpenedFiles'][fileID]['DeleteOnClose'] = True\n                    elif informationLevel == smb2.SMB2_FILE_BASIC_INFO:\n                        infoRecord = smb.SMBSetFileBasicInfo(setInfo['Buffer'])\n                        # Creation time won't be set,  the other ones we play with.\n                        atime = infoRecord['LastWriteTime']\n                        if atime == 0:\n                            atime = -1\n                        else:\n                            atime = getUnixTime(atime)\n                        mtime = infoRecord['ChangeTime']\n                        if mtime == 0:\n                            mtime = -1\n                        else:\n                            mtime = getUnixTime(mtime)\n                        if atime > 0 and mtime > 0:\n                            os.utime(pathName,(atime,mtime))\n                    elif informationLevel == smb2.SMB2_FILE_END_OF_FILE_INFO:\n                        fileHandle = connData['OpenedFiles'][fileID]['FileHandle']\n                        infoRecord = smb.SMBSetFileEndOfFileInfo(setInfo['Buffer'])\n                        if infoRecord['EndOfFile'] > 0:\n                            os.lseek(fileHandle, infoRecord['EndOfFile']-1, 0)\n                            os.write(fileHandle, b'\\x00')\n                    elif informationLevel == smb2.SMB2_FILE_RENAME_INFO:\n                        renameInfo = smb2.FILE_RENAME_INFORMATION_TYPE_2(setInfo['Buffer'])\n                        newPathName = os.path.join(path,renameInfo['FileName'].decode('utf-16le').replace('\\\\', '/')) \n                        if renameInfo['ReplaceIfExists'] == 0 and os.path.exists(newPathName):\n                            return [smb2.SMB2Error()], None, STATUS_OBJECT_NAME_COLLISION\n                        try:\n                             os.rename(pathName,newPathName)\n                             connData['OpenedFiles'][fileID]['FileName'] = newPathName\n                        except Exception as e:\n                             smbServer.log(\"smb2SetInfo: %s\" % e, logging.ERROR)\n                             errorCode = STATUS_ACCESS_DENIED\n                    else:\n                        smbServer.log('Unknown level for set file info! 0x%x' % informationLevel, logging.ERROR)\n                        # UNSUPPORTED\n                        errorCode =  STATUS_NOT_SUPPORTED\n                #elif setInfo['InfoType'] == smb2.SMB2_0_INFO_FILESYSTEM:\n                #    # The underlying object store information is being set.\n                #    setInfo = queryFsInformation('/', fileName, queryInfo['FileInfoClass'])\n                #elif setInfo['InfoType'] == smb2.SMB2_0_INFO_SECURITY:\n                #    # The security information is being set.\n                #    # Failing for now, until we support it\n                #    infoRecord = None\n                #    errorCode = STATUS_ACCESS_DENIED\n                #elif setInfo['InfoType'] == smb2.SMB2_0_INFO_QUOTA:\n                #    # The underlying object store quota information is being set.\n                #    setInfo = queryFsInformation('/', fileName, queryInfo['FileInfoClass'])\n                else:\n                    smbServer.log(\"setInfo not supported (%x)\" %  setInfo['InfoType'], logging.ERROR)\n\n            else:\n                errorCode = STATUS_INVALID_HANDLE\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smb2Write(connId, smbServer, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb2.SMB2Write_Response()\n        writeRequest   = smb2.SMB2Write(recvPacket['Data'])\n\n        respSMBCommand['Buffer'] = b'\\x00'\n\n        if writeRequest['FileID'].getData() == b'\\xff'*16:\n            # Let's take the data from the lastRequest\n            if  'SMB2_CREATE' in connData['LastRequest']:\n                fileID = connData['LastRequest']['SMB2_CREATE']['FileID']\n            else:\n                fileID = writeRequest['FileID'].getData()\n        else:\n            fileID = writeRequest['FileID'].getData()\n\n        if fileID in connData['OpenedFiles']:\n             fileHandle = connData['OpenedFiles'][fileID]['FileHandle']\n             errorCode = STATUS_SUCCESS\n             try:\n                 if fileHandle != PIPE_FILE_DESCRIPTOR:\n                     offset = writeRequest['Offset']\n                     # If we're trying to write past the file end we just skip the write call (Vista does this)\n                     if os.lseek(fileHandle, 0, 2) >= offset:\n                         os.lseek(fileHandle,offset,0)\n                         os.write(fileHandle,writeRequest['Buffer'])\n                 else:\n                     sock = connData['OpenedFiles'][fileID]['Socket']\n                     sock.send(writeRequest['Buffer'])\n\n                 respSMBCommand['Count']    = writeRequest['Length']\n                 respSMBCommand['Remaining']= 0xff\n             except Exception as e:\n                 smbServer.log('SMB2_WRITE: %s' % e, logging.ERROR)\n                 errorCode = STATUS_ACCESS_DENIED\n        else:\n            errorCode = STATUS_INVALID_HANDLE\n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smb2Read(connId, smbServer, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb2.SMB2Read_Response()\n        readRequest   = smb2.SMB2Read(recvPacket['Data'])\n\n        respSMBCommand['Buffer'] = b'\\x00'\n\n        if readRequest['FileID'].getData() == b'\\xff'*16:\n            # Let's take the data from the lastRequest\n            if  'SMB2_CREATE' in connData['LastRequest']:\n                fileID = connData['LastRequest']['SMB2_CREATE']['FileID']\n            else:\n                fileID = readRequest['FileID'].getData()\n        else:\n            fileID = readRequest['FileID'].getData()\n\n        if fileID in connData['OpenedFiles']:\n             fileHandle = connData['OpenedFiles'][fileID]['FileHandle']\n             errorCode = 0\n             try:\n                 if fileHandle != PIPE_FILE_DESCRIPTOR:\n                     offset = readRequest['Offset']\n                     os.lseek(fileHandle,offset,0)\n                     content = os.read(fileHandle,readRequest['Length'])\n                 else:\n                     sock = connData['OpenedFiles'][fileID]['Socket']\n                     content = sock.recv(readRequest['Length'])\n\n                 respSMBCommand['DataOffset']   = 0x50\n                 respSMBCommand['DataLength']   = len(content)\n                 respSMBCommand['DataRemaining']= 0\n                 respSMBCommand['Buffer']       = content\n             except Exception as e:\n                 smbServer.log('SMB2_READ: %s ' % e, logging.ERROR)\n                 errorCode = STATUS_ACCESS_DENIED\n        else:\n            errorCode = STATUS_INVALID_HANDLE\n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smb2Flush(connId, smbServer, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb2.SMB2Flush_Response()\n        flushRequest   = smb2.SMB2Flush(recvPacket['Data'])\n\n        if flushRequest['FileID'].getData() in connData['OpenedFiles']:\n             fileHandle = connData['OpenedFiles'][flushRequest['FileID'].getData()]['FileHandle']\n             errorCode = STATUS_SUCCESS\n             try:\n                 os.fsync(fileHandle)\n             except Exception as e:\n                 smbServer.log(\"SMB2_FLUSH %s\" % e, logging.ERROR)\n                 errorCode = STATUS_ACCESS_DENIED\n        else:\n            errorCode = STATUS_INVALID_HANDLE\n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode\n\n\n    @staticmethod\n    def smb2QueryDirectory(connId, smbServer, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n        respSMBCommand = smb2.SMB2QueryDirectory_Response()\n        queryDirectoryRequest   = smb2.SMB2QueryDirectory(recvPacket['Data'])\n\n        respSMBCommand['Buffer'] = b'\\x00'\n\n        # The server MUST locate the tree connection, as specified in section 3.3.5.2.11.\n        if (recvPacket['TreeID'] in connData['ConnectedShares']) is False:\n            return [smb2.SMB2Error()], None, STATUS_NETWORK_NAME_DELETED\n       \n        # Next, the server MUST locate the open for the directory to be queried \n        # If no open is found, the server MUST fail the request with STATUS_FILE_CLOSED\n        if queryDirectoryRequest['FileID'].getData() == b'\\xff'*16:\n            # Let's take the data from the lastRequest\n            if  'SMB2_CREATE' in connData['LastRequest']:\n                fileID = connData['LastRequest']['SMB2_CREATE']['FileID']\n            else:\n                fileID = queryDirectoryRequest['FileID'].getData()\n        else:\n            fileID = queryDirectoryRequest['FileID'].getData()\n\n        if (fileID in connData['OpenedFiles']) is False:\n            return [smb2.SMB2Error()], None, STATUS_FILE_CLOSED\n\n        # If the open is not an open to a directory, the request MUST be failed \n        # with STATUS_INVALID_PARAMETER.\n        if os.path.isdir(connData['OpenedFiles'][fileID]['FileName']) is False:\n            return [smb2.SMB2Error()], None, STATUS_INVALID_PARAMETER\n\n        # If any other information class is specified in the FileInformationClass \n        # field of the SMB2 QUERY_DIRECTORY Request, the server MUST fail the \n        # operation with STATUS_INVALID_INFO_CLASS. \n        if queryDirectoryRequest['FileInformationClass'] not in (\n        smb2.FILE_DIRECTORY_INFORMATION, smb2.FILE_FULL_DIRECTORY_INFORMATION, smb2.FILEID_FULL_DIRECTORY_INFORMATION,\n        smb2.FILE_BOTH_DIRECTORY_INFORMATION, smb2.FILEID_BOTH_DIRECTORY_INFORMATION, smb2.FILENAMES_INFORMATION):\n            return [smb2.SMB2Error()], None, STATUS_INVALID_INFO_CLASS\n\n        # If SMB2_REOPEN is set in the Flags field of the SMB2 QUERY_DIRECTORY \n        # Request, the server SHOULD<326> set Open.EnumerationLocation to 0 \n        # and Open.EnumerationSearchPattern to an empty string.\n        if queryDirectoryRequest['Flags'] & smb2.SMB2_REOPEN:\n            connData['OpenedFiles'][fileID]['Open']['EnumerationLocation'] = 0\n            connData['OpenedFiles'][fileID]['Open']['EnumerationSearchPattern'] = ''\n        \n        # If SMB2_RESTART_SCANS is set in the Flags field of the SMB2 \n        # QUERY_DIRECTORY Request, the server MUST set \n        # Open.EnumerationLocation to 0.\n        if queryDirectoryRequest['Flags'] & smb2.SMB2_RESTART_SCANS:\n            connData['OpenedFiles'][fileID]['Open']['EnumerationLocation'] = 0\n\n        # If Open.EnumerationLocation is 0 and Open.EnumerationSearchPattern \n        # is an empty string, then Open.EnumerationSearchPattern MUST be set \n        # to the search pattern specified in the SMB2 QUERY_DIRECTORY by \n        # FileNameOffset and FileNameLength. If FileNameLength is 0, the server \n        # SHOULD<327> set Open.EnumerationSearchPattern as \"*\" to search all entries.\n\n        pattern = queryDirectoryRequest['Buffer'].decode('utf-16le')\n        if  connData['OpenedFiles'][fileID]['Open']['EnumerationLocation'] == 0 and \\\n            connData['OpenedFiles'][fileID]['Open']['EnumerationSearchPattern'] == '':\n            if pattern == '':\n                pattern = '*'\n            connData['OpenedFiles'][fileID]['Open']['EnumerationSearchPattern'] = pattern\n\n        # If SMB2_INDEX_SPECIFIED is set and FileNameLength is not zero, \n        # the server MUST set Open.EnumerationSearchPattern to the search pattern \n        # specified in the request by FileNameOffset and FileNameLength.\n        if queryDirectoryRequest['Flags'] & smb2.SMB2_INDEX_SPECIFIED and \\\n           queryDirectoryRequest['FileNameLength'] > 0:\n            connData['OpenedFiles'][fileID]['Open']['EnumerationSearchPattern'] = pattern\n\n        pathName = os.path.join(os.path.normpath(connData['OpenedFiles'][fileID]['FileName']),pattern)\n        searchResult, searchCount, errorCode = findFirst2(os.path.dirname(pathName),\n                  os.path.basename(pathName),\n                  queryDirectoryRequest['FileInformationClass'], \n                  smb.ATTR_DIRECTORY, isSMB2 = True )\n\n        if errorCode != STATUS_SUCCESS:\n            return [smb2.SMB2Error()], None, errorCode\n\n        if searchCount > 2 and pattern == '*':\n            # strip . and ..\n            searchCount -= 2\n            searchResult = searchResult[2:]\n\n        if searchCount == 0 and connData['OpenedFiles'][fileID]['Open']['EnumerationLocation'] == 0:\n            return [smb2.SMB2Error()], None, STATUS_NO_SUCH_FILE\n\n        if  connData['OpenedFiles'][fileID]['Open']['EnumerationLocation'] < 0:\n            return [smb2.SMB2Error()], None, STATUS_NO_MORE_FILES\n\n        totalData = 0\n        respData = b''\n        for nItem in range(connData['OpenedFiles'][fileID]['Open']['EnumerationLocation'], searchCount):\n            connData['OpenedFiles'][fileID]['Open']['EnumerationLocation'] += 1\n            if queryDirectoryRequest['Flags'] & smb2.SL_RETURN_SINGLE_ENTRY:\n                # If single entry is requested we must clear the NextEntryOffset\n                searchResult[nItem]['NextEntryOffset'] = 0\n            data = searchResult[nItem].getData()\n            lenData = len(data)\n            padLen = (8-(lenData % 8)) %8\n \n            if (totalData+lenData) >= queryDirectoryRequest['OutputBufferLength']:\n                connData['OpenedFiles'][fileID]['Open']['EnumerationLocation'] -= 1\n                break\n            else:\n                respData += data + b'\\x00'*padLen\n                totalData += lenData + padLen\n\n            if queryDirectoryRequest['Flags'] & smb2.SL_RETURN_SINGLE_ENTRY:\n                break\n\n        if connData['OpenedFiles'][fileID]['Open']['EnumerationLocation'] >= searchCount:\n             connData['OpenedFiles'][fileID]['Open']['EnumerationLocation'] = -1\n\n        respSMBCommand['OutputBufferOffset'] = 0x48\n        respSMBCommand['OutputBufferLength'] = totalData\n        respSMBCommand['Buffer'] = respData\n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smb2ChangeNotify(connId, smbServer, recvPacket):\n\n        return [smb2.SMB2Error()], None, STATUS_NOT_SUPPORTED\n\n    @staticmethod\n    def smb2Echo(connId, smbServer, recvPacket):\n\n        respSMBCommand = smb2.SMB2Echo_Response()\n\n        return [respSMBCommand], None, STATUS_SUCCESS\n\n    @staticmethod\n    def smb2TreeDisconnect(connId, smbServer, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb2.SMB2TreeDisconnect_Response()\n\n        if recvPacket['TreeID'] in connData['ConnectedShares']:\n            smbServer.log(\"Disconnecting Share(%d:%s)\" % (\n            recvPacket['TreeID'], connData['ConnectedShares'][recvPacket['TreeID']]['shareName']))\n            del(connData['ConnectedShares'][recvPacket['TreeID']])\n            errorCode = STATUS_SUCCESS\n        else:\n            # STATUS_SMB_BAD_TID\n            errorCode = STATUS_SMB_BAD_TID\n\n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smb2Logoff(connId, smbServer, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb2.SMB2Logoff_Response()\n\n        if recvPacket['SessionID'] != connData['Uid']:\n            # STATUS_SMB_BAD_UID\n            errorCode = STATUS_SMB_BAD_UID\n        else:\n            errorCode = STATUS_SUCCESS\n\n        connData['Uid'] = 0\n        connData['Authenticated'] = False\n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smb2Ioctl(connId, smbServer, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb2.SMB2Ioctl_Response()\n        ioctlRequest   = smb2.SMB2Ioctl(recvPacket['Data'])\n\n        ioctls = smbServer.getIoctls()\n        if ioctlRequest['CtlCode'] in ioctls:\n            outputData, errorCode = ioctls[ioctlRequest['CtlCode']](connId, smbServer, ioctlRequest)\n            if errorCode == STATUS_SUCCESS:\n                respSMBCommand['CtlCode']      = ioctlRequest['CtlCode']\n                respSMBCommand['FileID']       = ioctlRequest['FileID']\n                respSMBCommand['InputOffset']  = 0\n                respSMBCommand['InputCount']   = 0\n                respSMBCommand['OutputOffset'] = 0x70\n                respSMBCommand['OutputCount']  = len(outputData)\n                respSMBCommand['Flags']        = 0\n                respSMBCommand['Buffer']       = outputData\n            else:\n                respSMBCommand = outputData\n        else:\n            smbServer.log(\"Ioctl not implemented command: 0x%x\" % ioctlRequest['CtlCode'],logging.DEBUG)\n            errorCode = STATUS_INVALID_DEVICE_REQUEST\n            respSMBCommand = smb2.SMB2Error()\n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smb2Lock(connId, smbServer, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb2.SMB2Lock_Response()\n\n        # I'm actually doing nothing.. just make MacOS happy ;)\n        errorCode = STATUS_SUCCESS\n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smb2Cancel(connId, smbServer, recvPacket):\n        # I'm actually doing nothing\n        return [smb2.SMB2Error()], None, STATUS_CANCELLED\n\n    @staticmethod\n    def default(connId, smbServer, recvPacket):\n        # By default we return an SMB Packet with error not implemented\n        smbServer.log(\"Not implemented command: 0x%x\" % recvPacket['Command'],logging.DEBUG)\n        return [smb2.SMB2Error()], None, STATUS_NOT_SUPPORTED\n\nclass Ioctls:\n   @staticmethod\n   def fsctlDfsGetReferrals(connId, smbServer, ioctlRequest):\n        return smb2.SMB2Error(), STATUS_FS_DRIVER_REQUIRED\n\n   @staticmethod\n   def fsctlPipeTransceive(connId, smbServer, ioctlRequest):\n        connData = smbServer.getConnectionData(connId)\n        \n        ioctlResponse = ''\n\n        if ioctlRequest['FileID'].getData() in connData['OpenedFiles']:\n             fileHandle = connData['OpenedFiles'][ioctlRequest['FileID'].getData()]['FileHandle']\n             errorCode = STATUS_SUCCESS\n             try:\n                 if fileHandle != PIPE_FILE_DESCRIPTOR:\n                     errorCode = STATUS_INVALID_DEVICE_REQUEST\n                 else:\n                     sock = connData['OpenedFiles'][ioctlRequest['FileID'].getData()]['Socket']\n                     sock.sendall(ioctlRequest['Buffer'])\n                     ioctlResponse = sock.recv(ioctlRequest['MaxOutputResponse'])\n             except Exception as e:\n                 smbServer.log('fsctlPipeTransceive: %s ' % e, logging.ERROR)\n                 errorCode = STATUS_ACCESS_DENIED\n        else:\n            errorCode = STATUS_INVALID_DEVICE_REQUEST\n\n        smbServer.setConnectionData(connId, connData)\n        return ioctlResponse, errorCode\n\n   @staticmethod\n   def fsctlValidateNegotiateInfo(connId, smbServer, ioctlRequest):\n        connData = smbServer.getConnectionData(connId)\n        \n        errorCode = STATUS_SUCCESS\n\n        validateNegotiateInfo = smb2.VALIDATE_NEGOTIATE_INFO(ioctlRequest['Buffer'])\n        validateNegotiateInfoResponse = smb2.VALIDATE_NEGOTIATE_INFO_RESPONSE()\n        validateNegotiateInfoResponse['Capabilities'] = 0\n        validateNegotiateInfoResponse['Guid'] = b'A'*16\n        validateNegotiateInfoResponse['SecurityMode'] = 1\n        validateNegotiateInfoResponse['Dialect'] = smb2.SMB2_DIALECT_002\n\n        smbServer.setConnectionData(connId, connData)\n        return validateNegotiateInfoResponse.getData(), errorCode\n\n\nclass SMBSERVERHandler(socketserver.BaseRequestHandler):\n    def __init__(self, request, client_address, server, select_poll = False):\n        self.__SMB = server\n        # In case of AF_INET6 the client_address contains 4 items, ignore the last 2\n        self.__ip, self.__port = client_address[:2]\n        self.__request = request\n        self.__connId = threading.currentThread().getName()\n        self.__timeOut = 60*5\n        self.__select_poll = select_poll\n        #self.__connId = os.getpid()\n        socketserver.BaseRequestHandler.__init__(self, request, client_address, server)\n\n    def handle(self):\n        self.__SMB.log(\"Incoming connection (%s,%d)\" % (self.__ip, self.__port))\n        self.__SMB.addConnection(self.__connId, self.__ip, self.__port)\n        while True:\n            try:\n                # First of all let's get the NETBIOS packet\n                session = nmb.NetBIOSTCPSession(self.__SMB.getServerName(), 'HOST', self.__ip, sess_port=self.__port,\n                                                sock=self.__request, select_poll=self.__select_poll)\n                try:\n                    p = session.recv_packet(self.__timeOut)\n                except nmb.NetBIOSTimeout:\n                    raise\n                except nmb.NetBIOSError:\n                    break                 \n\n                if p.get_type() == nmb.NETBIOS_SESSION_REQUEST:\n                   # Someone is requesting a session, we're gonna accept them all :)\n                   _, rn, my = p.get_trailer().split(b' ')\n                   remote_name = nmb.decode_name(b'\\x20'+rn)\n                   myname = nmb.decode_name(b'\\x20'+my)\n                   self.__SMB.log(\"NetBIOS Session request (%s,%s,%s)\" % (self.__ip, remote_name[1].strip(), myname[1])) \n                   r = nmb.NetBIOSSessionPacket()\n                   r.set_type(nmb.NETBIOS_SESSION_POSITIVE_RESPONSE)\n                   r.set_trailer(p.get_trailer())\n                   self.__request.send(r.rawData())\n                else:\n                   resp = self.__SMB.processRequest(self.__connId, p.get_trailer())\n                   # Send all the packets received. Except for big transactions this should be\n                   # a single packet\n                   for i in resp:\n                       if hasattr(i, 'getData'):\n                           session.send_packet(i.getData())\n                       else:\n                           session.send_packet(i)\n            except Exception as e:\n                self.__SMB.log(\"Handle: %s\" % e)\n                #import traceback\n                #traceback.print_exc()\n                break\n\n    def finish(self):\n        # Thread/process is dying, we should tell the main SMB thread to remove all this thread data\n        self.__SMB.log(\"Closing down connection (%s,%d)\" % (self.__ip, self.__port))\n        self.__SMB.removeConnection(self.__connId)\n        return socketserver.BaseRequestHandler.finish(self)\n\nclass SMBSERVER(socketserver.ThreadingMixIn, socketserver.TCPServer):\n#class SMBSERVER(socketserver.ForkingMixIn, socketserver.TCPServer):\n    def __init__(self, server_address, handler_class=SMBSERVERHandler, config_parser = None):\n        socketserver.TCPServer.allow_reuse_address = True\n        socketserver.TCPServer.__init__(self, server_address, handler_class)\n\n        # Server name and OS to be presented whenever is necessary\n        self.__serverName   = ''\n        self.__serverOS     = ''\n        self.__serverDomain = ''\n        self.__challenge    = ''\n        self.__log          = None\n\n        # Our ConfigParser data\n        self.__serverConfig = config_parser\n\n        # Our credentials to be used during the server's lifetime\n        self.__credentials = {}\n\n        # Our log file\n        self.__logFile = ''\n\n        # Registered Named Pipes, format is PipeName,Socket\n        self.__registeredNamedPipes = {}\n\n        # JTR dump path\n        self.__jtr_dump_path = ''\n\n        # SMB2 Support flag = default not active\n        self.__SMB2Support = False\n \n        # Our list of commands we will answer, by default the NOT IMPLEMENTED one\n        self.__smbCommandsHandler = SMBCommands()\n        self.__smbTrans2Handler   = TRANS2Commands()\n        self.__smbTransHandler    = TRANSCommands()\n        self.__smbNTTransHandler  = NTTRANSCommands()\n        self.__smb2CommandsHandler = SMB2Commands()\n        self.__IoctlHandler       = Ioctls()\n\n        self.__smbNTTransCommands = {\n        # NT IOCTL, can't find doc for this\n        0xff                               :self.__smbNTTransHandler.default\n        }\n\n        self.__smbTransCommands  = {\n'\\\\PIPE\\\\LANMAN'                       :self.__smbTransHandler.lanMan,\nsmb.SMB.TRANS_TRANSACT_NMPIPE          :self.__smbTransHandler.transactNamedPipe,\n        }\n        self.__smbTrans2Commands = {\n smb.SMB.TRANS2_FIND_FIRST2            :self.__smbTrans2Handler.findFirst2,\n smb.SMB.TRANS2_FIND_NEXT2             :self.__smbTrans2Handler.findNext2,\n smb.SMB.TRANS2_QUERY_FS_INFORMATION   :self.__smbTrans2Handler.queryFsInformation,\n smb.SMB.TRANS2_QUERY_PATH_INFORMATION :self.__smbTrans2Handler.queryPathInformation,\n smb.SMB.TRANS2_QUERY_FILE_INFORMATION :self.__smbTrans2Handler.queryFileInformation,\n smb.SMB.TRANS2_SET_FILE_INFORMATION   :self.__smbTrans2Handler.setFileInformation,\n smb.SMB.TRANS2_SET_PATH_INFORMATION   :self.__smbTrans2Handler.setPathInformation\n        }\n\n        self.__smbCommands = { \n #smb.SMB.SMB_COM_FLUSH:              self.__smbCommandsHandler.smbComFlush, \n smb.SMB.SMB_COM_CREATE_DIRECTORY:   self.__smbCommandsHandler.smbComCreateDirectory, \n smb.SMB.SMB_COM_DELETE_DIRECTORY:   self.__smbCommandsHandler.smbComDeleteDirectory, \n smb.SMB.SMB_COM_RENAME:             self.__smbCommandsHandler.smbComRename, \n smb.SMB.SMB_COM_DELETE:             self.__smbCommandsHandler.smbComDelete, \n smb.SMB.SMB_COM_NEGOTIATE:          self.__smbCommandsHandler.smbComNegotiate, \n smb.SMB.SMB_COM_SESSION_SETUP_ANDX: self.__smbCommandsHandler.smbComSessionSetupAndX,\n smb.SMB.SMB_COM_LOGOFF_ANDX:        self.__smbCommandsHandler.smbComLogOffAndX,\n smb.SMB.SMB_COM_TREE_CONNECT_ANDX:  self.__smbCommandsHandler.smbComTreeConnectAndX,\n smb.SMB.SMB_COM_TREE_DISCONNECT:    self.__smbCommandsHandler.smbComTreeDisconnect,\n smb.SMB.SMB_COM_ECHO:               self.__smbCommandsHandler.smbComEcho,\n smb.SMB.SMB_COM_QUERY_INFORMATION:  self.__smbCommandsHandler.smbQueryInformation,\n smb.SMB.SMB_COM_TRANSACTION2:       self.__smbCommandsHandler.smbTransaction2,\n smb.SMB.SMB_COM_TRANSACTION:        self.__smbCommandsHandler.smbTransaction,\n # Not needed for now\n smb.SMB.SMB_COM_NT_TRANSACT:        self.__smbCommandsHandler.smbNTTransact,\n smb.SMB.SMB_COM_QUERY_INFORMATION_DISK: self.__smbCommandsHandler.smbQueryInformationDisk,\n smb.SMB.SMB_COM_OPEN_ANDX:          self.__smbCommandsHandler.smbComOpenAndX,\n smb.SMB.SMB_COM_QUERY_INFORMATION2: self.__smbCommandsHandler.smbComQueryInformation2,\n smb.SMB.SMB_COM_READ_ANDX:          self.__smbCommandsHandler.smbComReadAndX,\n smb.SMB.SMB_COM_READ:               self.__smbCommandsHandler.smbComRead,\n smb.SMB.SMB_COM_WRITE_ANDX:         self.__smbCommandsHandler.smbComWriteAndX,\n smb.SMB.SMB_COM_WRITE:              self.__smbCommandsHandler.smbComWrite,\n smb.SMB.SMB_COM_CLOSE:              self.__smbCommandsHandler.smbComClose,\n smb.SMB.SMB_COM_LOCKING_ANDX:       self.__smbCommandsHandler.smbComLockingAndX,\n smb.SMB.SMB_COM_NT_CREATE_ANDX:     self.__smbCommandsHandler.smbComNtCreateAndX,\n 0xFF:                               self.__smbCommandsHandler.default\n}\n\n        self.__smb2Ioctls = { \n smb2.FSCTL_DFS_GET_REFERRALS:            self.__IoctlHandler.fsctlDfsGetReferrals, \n# smb2.FSCTL_PIPE_PEEK:                    self.__IoctlHandler.fsctlPipePeek, \n# smb2.FSCTL_PIPE_WAIT:                    self.__IoctlHandler.fsctlPipeWait, \n smb2.FSCTL_PIPE_TRANSCEIVE:              self.__IoctlHandler.fsctlPipeTransceive, \n# smb2.FSCTL_SRV_COPYCHUNK:                self.__IoctlHandler.fsctlSrvCopyChunk, \n# smb2.FSCTL_SRV_ENUMERATE_SNAPSHOTS:      self.__IoctlHandler.fsctlSrvEnumerateSnapshots, \n# smb2.FSCTL_SRV_REQUEST_RESUME_KEY:       self.__IoctlHandler.fsctlSrvRequestResumeKey, \n# smb2.FSCTL_SRV_READ_HASH:                self.__IoctlHandler.fsctlSrvReadHash, \n# smb2.FSCTL_SRV_COPYCHUNK_WRITE:          self.__IoctlHandler.fsctlSrvCopyChunkWrite, \n# smb2.FSCTL_LMR_REQUEST_RESILIENCY:       self.__IoctlHandler.fsctlLmrRequestResiliency, \n# smb2.FSCTL_QUERY_NETWORK_INTERFACE_INFO: self.__IoctlHandler.fsctlQueryNetworkInterfaceInfo, \n# smb2.FSCTL_SET_REPARSE_POINT:            self.__IoctlHandler.fsctlSetReparsePoint, \n# smb2.FSCTL_DFS_GET_REFERRALS_EX:         self.__IoctlHandler.fsctlDfsGetReferralsEx, \n# smb2.FSCTL_FILE_LEVEL_TRIM:              self.__IoctlHandler.fsctlFileLevelTrim, \n smb2.FSCTL_VALIDATE_NEGOTIATE_INFO:      self.__IoctlHandler.fsctlValidateNegotiateInfo, \n}\n\n        self.__smb2Commands = { \n smb2.SMB2_NEGOTIATE:       self.__smb2CommandsHandler.smb2Negotiate, \n smb2.SMB2_SESSION_SETUP:   self.__smb2CommandsHandler.smb2SessionSetup, \n smb2.SMB2_LOGOFF:          self.__smb2CommandsHandler.smb2Logoff, \n smb2.SMB2_TREE_CONNECT:    self.__smb2CommandsHandler.smb2TreeConnect, \n smb2.SMB2_TREE_DISCONNECT: self.__smb2CommandsHandler.smb2TreeDisconnect, \n smb2.SMB2_CREATE:          self.__smb2CommandsHandler.smb2Create, \n smb2.SMB2_CLOSE:           self.__smb2CommandsHandler.smb2Close, \n smb2.SMB2_FLUSH:           self.__smb2CommandsHandler.smb2Flush, \n smb2.SMB2_READ:            self.__smb2CommandsHandler.smb2Read, \n smb2.SMB2_WRITE:           self.__smb2CommandsHandler.smb2Write, \n smb2.SMB2_LOCK:            self.__smb2CommandsHandler.smb2Lock, \n smb2.SMB2_IOCTL:           self.__smb2CommandsHandler.smb2Ioctl, \n smb2.SMB2_CANCEL:          self.__smb2CommandsHandler.smb2Cancel, \n smb2.SMB2_ECHO:            self.__smb2CommandsHandler.smb2Echo, \n smb2.SMB2_QUERY_DIRECTORY: self.__smb2CommandsHandler.smb2QueryDirectory, \n smb2.SMB2_CHANGE_NOTIFY:   self.__smb2CommandsHandler.smb2ChangeNotify, \n smb2.SMB2_QUERY_INFO:      self.__smb2CommandsHandler.smb2QueryInfo, \n smb2.SMB2_SET_INFO:        self.__smb2CommandsHandler.smb2SetInfo, \n# smb2.SMB2_OPLOCK_BREAK:    self.__smb2CommandsHandler.smb2SessionSetup, \n 0xFF:                      self.__smb2CommandsHandler.default\n}\n\n        # List of active connections\n        self.__activeConnections = {}\n  \n    def getIoctls(self):\n        return self.__smb2Ioctls\n\n    def getCredentials(self):\n        return self.__credentials\n\n    def removeConnection(self, name):\n        try:\n           del(self.__activeConnections[name])\n        except:\n           pass\n        self.log(\"Remaining connections %s\" % list(self.__activeConnections.keys()))\n\n    def addConnection(self, name, ip, port):\n        self.__activeConnections[name] = {}\n        # Let's init with some know stuff we will need to have\n        # TODO: Document what's in there\n        #print \"Current Connections\", self.__activeConnections.keys()\n        self.__activeConnections[name]['PacketNum']       = 0\n        self.__activeConnections[name]['ClientIP']        = ip\n        self.__activeConnections[name]['ClientPort']      = port\n        self.__activeConnections[name]['Uid']             = 0\n        self.__activeConnections[name]['ConnectedShares'] = {}\n        self.__activeConnections[name]['OpenedFiles']     = {}\n        # SID results for findfirst2\n        self.__activeConnections[name]['SIDs']            = {}\n        self.__activeConnections[name]['LastRequest']     = {}\n        self.__activeConnections[name]['SignatureEnabled']= False\n        self.__activeConnections[name]['SigningChallengeResponse']= ''\n        self.__activeConnections[name]['SigningSessionKey']= b''\n        self.__activeConnections[name]['Authenticated']= False\n\n    def getActiveConnections(self):\n        return self.__activeConnections\n\n    def setConnectionData(self, connId, data):\n        self.__activeConnections[connId] = data\n        #print \"setConnectionData\" \n        #print self.__activeConnections\n\n    def getConnectionData(self, connId, checkStatus = True):\n        conn = self.__activeConnections[connId]\n        if checkStatus is True:\n            if ('Authenticated' in conn) is not True:\n                # Can't keep going further\n                raise Exception(\"User not Authenticated!\")\n        return conn\n\n    def getRegisteredNamedPipes(self):\n        return self.__registeredNamedPipes\n\n    def registerNamedPipe(self, pipeName, address):\n        self.__registeredNamedPipes[str(pipeName)] = address\n        return True\n\n    def unregisterNamedPipe(self, pipeName):\n        if pipeName in self.__registeredNamedPipes:\n            del(self.__registeredNamedPipes[str(pipeName)])\n            return True\n        return False\n\n    def unregisterTransaction(self, transCommand):\n        if transCommand in self.__smbTransCommands:\n           del(self.__smbTransCommands[transCommand])\n\n    def hookTransaction(self, transCommand, callback):\n        # If you call this function, callback will replace \n        # the current Transaction sub command.\n        # (don't get confused with the Transaction smbCommand)\n        # If the transaction sub command doesn't not exist, it is added\n        # If the transaction sub command exists, it returns the original function         # replaced\n        #\n        # callback MUST be declared as:\n        # callback(connId, smbServer, recvPacket, parameters, data, maxDataCount=0)\n        #\n        # WHERE:\n        #\n        # connId      : the connection Id, used to grab/update information about \n        #               the current connection\n        # smbServer   : the SMBServer instance available for you to ask \n        #               configuration data\n        # recvPacket  : the full SMBPacket that triggered this command\n        # parameters  : the transaction parameters\n        # data        : the transaction data\n        # maxDataCount: the max amount of data that can be transferred agreed \n        #               with the client\n        #\n        # and MUST return:\n        # respSetup, respParameters, respData, errorCode\n        #\n        # WHERE:\n        #\n        # respSetup: the setup response of the transaction\n        # respParameters: the parameters response of the transaction\n        # respData: the data response of the transaction\n        # errorCode: the NT error code \n\n        if transCommand in self.__smbTransCommands:\n           originalCommand = self.__smbTransCommands[transCommand]\n        else:\n           originalCommand = None \n\n        self.__smbTransCommands[transCommand] = callback\n        return originalCommand\n\n    def unregisterTransaction2(self, transCommand):\n        if transCommand in self.__smbTrans2Commands:\n           del(self.__smbTrans2Commands[transCommand])\n\n    def hookTransaction2(self, transCommand, callback):\n        # Here we should add to __smbTrans2Commands\n        # Same description as Transaction\n        if transCommand in self.__smbTrans2Commands:\n           originalCommand = self.__smbTrans2Commands[transCommand]\n        else:\n           originalCommand = None \n\n        self.__smbTrans2Commands[transCommand] = callback\n        return originalCommand\n\n    def unregisterNTTransaction(self, transCommand):\n        if transCommand in self.__smbNTTransCommands:\n           del(self.__smbNTTransCommands[transCommand])\n\n    def hookNTTransaction(self, transCommand, callback):\n        # Here we should add to __smbNTTransCommands\n        # Same description as Transaction\n        if transCommand in self.__smbNTTransCommands:\n           originalCommand = self.__smbNTTransCommands[transCommand]\n        else:\n           originalCommand = None \n\n        self.__smbNTTransCommands[transCommand] = callback\n        return originalCommand\n\n    def unregisterSmbCommand(self, smbCommand):\n        if smbCommand in self.__smbCommands:\n           del(self.__smbCommands[smbCommand])\n\n    def hookSmbCommand(self, smbCommand, callback):\n        # Here we should add to self.__smbCommands\n        # If you call this function, callback will replace \n        # the current smbCommand.\n        # If smbCommand doesn't not exist, it is added\n        # If SMB command exists, it returns the original function replaced\n        #\n        # callback MUST be declared as:\n        # callback(connId, smbServer, SMBCommand, recvPacket)\n        #\n        # WHERE:\n        #\n        # connId    : the connection Id, used to grab/update information about \n        #             the current connection\n        # smbServer : the SMBServer instance available for you to ask \n        #             configuration data\n        # SMBCommand: the SMBCommand itself, with its data and parameters. \n        #             Check smb.py:SMBCommand() for a reference\n        # recvPacket: the full SMBPacket that triggered this command\n        #\n        # and MUST return:\n        # <list of respSMBCommands>, <list of packets>, errorCode\n        # <list of packets> has higher preference over commands, in case you \n        # want to change the whole packet \n        # errorCode: the NT error code \n        #\n        # For SMB_COM_TRANSACTION2, SMB_COM_TRANSACTION and SMB_COM_NT_TRANSACT\n        # the callback function is slightly different:\n        #\n        # callback(connId, smbServer, SMBCommand, recvPacket, transCommands)\n        #\n        # WHERE:\n        # \n        # transCommands: a list of transaction subcommands already registered\n        #\n\n        if smbCommand in self.__smbCommands:\n           originalCommand = self.__smbCommands[smbCommand]\n        else:\n           originalCommand = None \n\n        self.__smbCommands[smbCommand] = callback\n        return originalCommand\n  \n    def unregisterSmb2Command(self, smb2Command):\n        if smb2Command in self.__smb2Commands:\n           del(self.__smb2Commands[smb2Command])\n\n    def hookSmb2Command(self, smb2Command, callback):\n        if smb2Command in self.__smb2Commands:\n           originalCommand = self.__smb2Commands[smb2Command]\n        else:\n           originalCommand = None \n\n        self.__smb2Commands[smb2Command] = callback\n        return originalCommand\n\n    def log(self, msg, level=logging.INFO):\n        self.__log.log(level,msg)\n\n    def getServerName(self):\n        return self.__serverName\n\n    def getServerOS(self):\n        return self.__serverOS\n  \n    def getServerDomain(self):\n        return self.__serverDomain\n\n    def getSMBChallenge(self):\n        return self.__challenge\n  \n    def getServerConfig(self):\n        return self.__serverConfig\n\n    def setServerConfig(self, config):\n        self.__serverConfig = config\n\n    def getJTRdumpPath(self):\n        return self.__jtr_dump_path\n\n    def verify_request(self, request, client_address):\n        # TODO: Control here the max amount of processes we want to launch\n        # returning False, closes the connection\n        return True\n\n    def signSMBv1(self, connData, packet, signingSessionKey, signingChallengeResponse):\n        # This logic MUST be applied for messages sent in response to any of the higher-layer actions and in\n        # compliance with the message sequencing rules.\n        #  * The client or server that sends the message MUST provide the 32-bit sequence number for this\n        #    message, as specified in sections 3.2.4.1 and 3.3.4.1.\n        #  * The SMB_FLAGS2_SMB_SECURITY_SIGNATURE flag in the header MUST be set.\n        #  * To generate the signature, a 32-bit sequence number is copied into the\n        #    least significant 32 bits of the SecuritySignature field and the remaining\n        #    4 bytes are set to 0x00.\n        #  * The MD5 algorithm, as specified in [RFC1321], MUST be used to generate a hash of the SMB\n        #    message from the start of the SMB Header, which is defined as follows.\n        #    CALL MD5Init( md5context )\n        #    CALL MD5Update( md5context, Connection.SigningSessionKey )\n        #    CALL MD5Update( md5context, Connection.SigningChallengeResponse )\n        #    CALL MD5Update( md5context, SMB message )\n        #    CALL MD5Final( digest, md5context )\n        #    SET signature TO the first 8 bytes of the digest\n        # The resulting 8-byte signature MUST be copied into the SecuritySignature field of the SMB Header,\n        # after which the message can be transmitted.\n\n        #print \"seq(%d) signingSessionKey %r, signingChallengeResponse %r\" % (connData['SignSequenceNumber'], signingSessionKey, signingChallengeResponse)\n        packet['SecurityFeatures'] = struct.pack('<q',connData['SignSequenceNumber'])\n        # Sign with the sequence\n        m = hashlib.md5()\n        m.update( signingSessionKey )\n        m.update( signingChallengeResponse )\n        if hasattr(packet, 'getData'):\n            m.update( packet.getData() )\n        else:\n            m.update( packet )\n        # Replace sequence with acual hash\n        packet['SecurityFeatures'] = m.digest()[:8]\n        connData['SignSequenceNumber'] +=2\n\n    def signSMBv2(self, packet, signingSessionKey):\n        packet['Signature'] = b'\\x00'*16\n        packet['Flags'] |= smb2.SMB2_FLAGS_SIGNED\n        signature = hmac.new(signingSessionKey, packet.getData(), hashlib.sha256).digest()\n        packet['Signature'] = signature[:16]\n        #print \"%s\" % packet['Signature'].encode('hex')\n\n    def processRequest(self, connId, data):\n\n        # TODO: Process batched commands.\n        isSMB2      = False\n        SMBCommand  = None\n        try:\n            packet = smb.NewSMBPacket(data = data)\n            SMBCommand  = smb.SMBCommand(packet['Data'][0])\n        except:\n            # Maybe a SMB2 packet?\n            packet = smb2.SMB2Packet(data = data)\n            connData = self.getConnectionData(connId, False)\n            self.signSMBv2(packet, connData['SigningSessionKey'])\n            isSMB2 = True\n\n        connData    = self.getConnectionData(connId, False)\n\n        # We might have compound requests\n        compoundedPacketsResponse = []\n        compoundedPackets         = []\n        try:\n            # Search out list of implemented commands\n            # We provide them with:\n            # connId      : representing the data for this specific connection\n            # self        : the SMBSERVER if they want to ask data to it\n            # SMBCommand  : the SMBCommand they are expecting to process\n            # packet      : the received packet itself, in case they need more data than the actual command\n            # Only for Transactions\n            # transCommand: a list of transaction subcommands\n            # We expect to get:\n            # respCommands: a list of answers for the commands processed\n            # respPacket  : if the commands chose to directly craft packet/s, we use this and not the previous\n            #               this MUST be a list\n            # errorCode   : self explanatory\n            if isSMB2 is False:\n                # Is the client authenticated already?\n                if connData['Authenticated'] is False and packet['Command'] not in (smb.SMB.SMB_COM_NEGOTIATE, smb.SMB.SMB_COM_SESSION_SETUP_ANDX):\n                    # Nope.. in that case he should only ask for a few commands, if not throw him out.\n                    errorCode = STATUS_ACCESS_DENIED\n                    respPackets = None\n                    respCommands = [smb.SMBCommand(packet['Command'])]\n                else:\n                    if packet['Command'] == smb.SMB.SMB_COM_TRANSACTION2:\n                        respCommands, respPackets, errorCode = self.__smbCommands[packet['Command']](\n                                      connId,\n                                      self,\n                                      SMBCommand,\n                                      packet,\n                                      self.__smbTrans2Commands)\n                    elif packet['Command'] == smb.SMB.SMB_COM_NT_TRANSACT:\n                        respCommands, respPackets, errorCode = self.__smbCommands[packet['Command']](\n                                      connId,\n                                      self,\n                                      SMBCommand,\n                                      packet,\n                                      self.__smbNTTransCommands)\n                    elif packet['Command'] == smb.SMB.SMB_COM_TRANSACTION:\n                        respCommands, respPackets, errorCode = self.__smbCommands[packet['Command']](\n                                      connId,\n                                      self,\n                                      SMBCommand,\n                                      packet,\n                                      self.__smbTransCommands)\n                    else:\n                        if packet['Command'] in self.__smbCommands:\n                           if self.__SMB2Support is True:\n                               if packet['Command'] == smb.SMB.SMB_COM_NEGOTIATE:\n                                   try:\n                                       respCommands, respPackets, errorCode = self.__smb2Commands[smb2.SMB2_NEGOTIATE](connId, self, packet, True)\n                                       isSMB2 = True\n                                   except Exception as e:\n                                       import traceback\n                                       traceback.print_exc()\n                                       self.log('SMB2_NEGOTIATE: %s' % e, logging.ERROR)\n                                       # If something went wrong, let's fallback to SMB1\n                                       respCommands, respPackets, errorCode = self.__smbCommands[packet['Command']](\n                                           connId,\n                                           self,\n                                           SMBCommand,\n                                           packet)\n                                       #self.__SMB2Support = False\n                                       pass\n                               else:\n                                   respCommands, respPackets, errorCode = self.__smbCommands[packet['Command']](\n                                           connId,\n                                           self,\n                                           SMBCommand,\n                                           packet)\n                           else:\n                               respCommands, respPackets, errorCode = self.__smbCommands[packet['Command']](\n                                           connId,\n                                           self,\n                                           SMBCommand,\n                                           packet)\n                        else:\n                           respCommands, respPackets, errorCode = self.__smbCommands[255](connId, self, SMBCommand, packet)\n\n                compoundedPacketsResponse.append((respCommands, respPackets, errorCode))\n                compoundedPackets.append(packet)\n\n            else:\n                # Is the client authenticated already?\n                if connData['Authenticated'] is False and packet['Command'] not in (smb2.SMB2_NEGOTIATE, smb2.SMB2_SESSION_SETUP):\n                    # Nope.. in that case he should only ask for a few commands, if not throw him out.\n                    errorCode = STATUS_ACCESS_DENIED\n                    respPackets = None\n                    respCommands = ['']\n                    compoundedPacketsResponse.append((respCommands, respPackets, errorCode))\n                    compoundedPackets.append(packet)\n                else:\n                    done = False\n                    while not done:\n                        if packet['Command'] in self.__smb2Commands:\n                           if self.__SMB2Support is True:\n                               respCommands, respPackets, errorCode = self.__smb2Commands[packet['Command']](\n                                       connId,\n                                       self,\n                                       packet)\n                           else:\n                               respCommands, respPackets, errorCode = self.__smb2Commands[255](connId, self, packet)\n                        else:\n                           respCommands, respPackets, errorCode = self.__smb2Commands[255](connId, self, packet)\n                        # Let's store the result for this compounded packet\n                        compoundedPacketsResponse.append((respCommands, respPackets, errorCode))\n                        compoundedPackets.append(packet)\n                        if packet['NextCommand'] != 0:\n                            data = data[packet['NextCommand']:]\n                            packet = smb2.SMB2Packet(data = data)\n                        else:\n                            done = True\n\n        except Exception as e:\n            #import traceback\n            #traceback.print_exc()\n            # Something wen't wrong, defaulting to Bad user ID\n            self.log('processRequest (0x%x,%s)' % (packet['Command'],e), logging.ERROR)\n            raise\n\n        # We prepare the response packet to commands don't need to bother about that.\n        connData    = self.getConnectionData(connId, False)\n\n        # Force reconnection loop.. This is just a test.. client will send me back credentials :)\n        #connData['PacketNum'] += 1\n        #if connData['PacketNum'] == 15:\n        #    connData['PacketNum'] = 0\n        #    # Something wen't wrong, defaulting to Bad user ID\n        #    self.log('Sending BAD USER ID!', logging.ERROR)\n        #    #raise\n        #    packet['Flags1'] |= smb.SMB.FLAGS1_REPLY\n        #    packet['Flags2'] = 0\n        #    errorCode = STATUS_SMB_BAD_UID\n        #    packet['ErrorCode']   = errorCode >> 16\n        #    packet['ErrorClass']  = errorCode & 0xff\n        #    return [packet]\n\n        self.setConnectionData(connId, connData)    \n\n        packetsToSend = []\n        for packetNum in range(len(compoundedPacketsResponse)):\n            respCommands, respPackets, errorCode = compoundedPacketsResponse[packetNum]\n            packet = compoundedPackets[packetNum]\n            if respPackets is None:\n                for respCommand in respCommands:\n                    if isSMB2 is False:\n                        respPacket           = smb.NewSMBPacket()\n                        respPacket['Flags1'] = smb.SMB.FLAGS1_REPLY\n\n                        # TODO this should come from a per session configuration\n                        respPacket['Flags2'] = smb.SMB.FLAGS2_EXTENDED_SECURITY | smb.SMB.FLAGS2_NT_STATUS | smb.SMB.FLAGS2_LONG_NAMES | packet['Flags2'] & smb.SMB.FLAGS2_UNICODE\n                        #respPacket['Flags2'] = smb.SMB.FLAGS2_EXTENDED_SECURITY | smb.SMB.FLAGS2_NT_STATUS | smb.SMB.FLAGS2_LONG_NAMES \n                        #respPacket['Flags1'] = 0x98\n                        #respPacket['Flags2'] = 0xc807\n                \n\n                        respPacket['Tid']    = packet['Tid']\n                        respPacket['Mid']    = packet['Mid']\n                        respPacket['Pid']    = packet['Pid']\n                        respPacket['Uid']    = connData['Uid']\n        \n                        respPacket['ErrorCode']   = errorCode >> 16\n                        respPacket['_reserved']   = errorCode >> 8 & 0xff\n                        respPacket['ErrorClass']  = errorCode & 0xff\n                        respPacket.addCommand(respCommand)\n\n                        if connData['SignatureEnabled']:\n                            respPacket['Flags2'] |= smb.SMB.FLAGS2_SMB_SECURITY_SIGNATURE\n                            self.signSMBv1(connData, respPacket, connData['SigningSessionKey'], connData['SigningChallengeResponse'])\n            \n                        packetsToSend.append(respPacket)\n                    else:\n                        respPacket = smb2.SMB2Packet()\n                        respPacket['Flags']     = smb2.SMB2_FLAGS_SERVER_TO_REDIR\n                        if packetNum > 0:\n                            respPacket['Flags'] |= smb2.SMB2_FLAGS_RELATED_OPERATIONS\n                        respPacket['Status']    = errorCode\n                        respPacket['CreditRequestResponse'] = packet['CreditRequestResponse']\n                        respPacket['Command']   = packet['Command']\n                        respPacket['CreditCharge'] = packet['CreditCharge']\n                        #respPacket['CreditCharge'] = 0\n                        respPacket['Reserved']  = packet['Reserved']\n                        respPacket['SessionID'] = connData['Uid']\n                        respPacket['MessageID'] = packet['MessageID']\n                        respPacket['TreeID']    = packet['TreeID']\n                        if hasattr(respCommand, 'getData'):\n                            respPacket['Data']      = respCommand.getData()\n                        else:\n                            respPacket['Data']      = str(respCommand)\n\n                        if connData['SignatureEnabled']:\n                            self.signSMBv2(respPacket, connData['SigningSessionKey'])\n\n                        packetsToSend.append(respPacket)\n            else:\n                # The SMBCommand took care of building the packet\n                packetsToSend = respPackets\n\n        if isSMB2 is True:\n            # Let's build a compound answer\n            finalData = b''\n            i = 0\n            for i in range(len(packetsToSend)-1):\n                packet = packetsToSend[i]\n                # Align to 8-bytes\n                padLen = (8 - (len(packet) % 8) ) % 8\n                packet['NextCommand'] = len(packet) + padLen\n                if hasattr(packet, 'getData'):\n                    finalData += packet.getData() + padLen*b'\\x00'\n                else:\n                    finalData += packet + padLen*b'\\x00'\n\n            # Last one\n            if hasattr(packetsToSend[len(packetsToSend)-1], 'getData'):\n                finalData += packetsToSend[len(packetsToSend)-1].getData()\n            else:\n                finalData += packetsToSend[len(packetsToSend)-1]\n            packetsToSend = [finalData]\n\n        # We clear the compound requests\n        connData['LastRequest'] = {}\n\n        return packetsToSend\n\n    def processConfigFile(self, configFile = None):\n        # TODO: Do a real config parser\n        if self.__serverConfig is None:\n            if configFile is None:\n                configFile = 'smb.conf'\n            self.__serverConfig = configparser.ConfigParser()\n            self.__serverConfig.read(configFile)\n\n        self.__serverName   = self.__serverConfig.get('global','server_name')\n        self.__serverOS     = self.__serverConfig.get('global','server_os')\n        self.__serverDomain = self.__serverConfig.get('global','server_domain')\n        self.__logFile      = self.__serverConfig.get('global','log_file')\n        if self.__serverConfig.has_option('global', 'challenge'):\n            self.__challenge    = unhexlify(self.__serverConfig.get('global', 'challenge'))\n        else:\n            self.__challenge    = b'A'*16\n\n        if self.__serverConfig.has_option(\"global\", \"jtr_dump_path\"):\n            self.__jtr_dump_path = self.__serverConfig.get(\"global\", \"jtr_dump_path\")\n\n        if self.__serverConfig.has_option(\"global\", \"SMB2Support\"):\n            self.__SMB2Support = self.__serverConfig.getboolean(\"global\",\"SMB2Support\")\n        else:\n            self.__SMB2Support = False\n\n        if self.__logFile != 'None':\n            logging.basicConfig(filename = self.__logFile, \n                             level = logging.DEBUG, \n                             format=\"%(asctime)s: %(levelname)s: %(message)s\", \n                             datefmt = '%m/%d/%Y %I:%M:%S %p')\n        self.__log        = LOG\n\n        # Process the credentials\n        credentials_fname = self.__serverConfig.get('global','credentials_file')\n        if credentials_fname != \"\":\n            cred = open(credentials_fname)\n            line = cred.readline()\n            while line:\n                name, uid, lmhash, nthash = line.split(':')\n                self.__credentials[name.lower()] = (uid, lmhash, nthash.strip('\\r\\n'))\n                line = cred.readline()\n            cred.close()\n        self.log('Config file parsed')\n\n    def addCredential(self, name, uid, lmhash, nthash):\n        # If we have hashes, normalize them\n        if lmhash != '' or nthash != '':\n            if len(lmhash) % 2:\n                lmhash = '0%s' % lmhash\n            if len(nthash) % 2:\n                nthash = '0%s' % nthash\n            try: # just in case they were converted already\n                lmhash = a2b_hex(lmhash)\n                nthash = a2b_hex(nthash)\n            except:\n                pass\n        self.__credentials[name.lower()] = (uid, lmhash, nthash)\n\n# For windows platforms, opening a directory is not an option, so we set a void FD\nVOID_FILE_DESCRIPTOR = -1\nPIPE_FILE_DESCRIPTOR = -2\n\n######################################################################\n# HELPER CLASSES\n######################################################################\n\nfrom impacket.dcerpc.v5.rpcrt import DCERPCServer\nfrom impacket.dcerpc.v5.dtypes import NULL\nfrom impacket.dcerpc.v5.srvs import NetrShareEnum, NetrShareEnumResponse, SHARE_INFO_1, NetrServerGetInfo, NetrServerGetInfoResponse, NetrShareGetInfo, NetrShareGetInfoResponse\nfrom impacket.dcerpc.v5.wkst import NetrWkstaGetInfo, NetrWkstaGetInfoResponse\nfrom impacket.system_errors import ERROR_INVALID_LEVEL\n\nclass WKSTServer(DCERPCServer):\n    def __init__(self):\n        DCERPCServer.__init__(self)\n        self.wkssvcCallBacks = {\n            0: self.NetrWkstaGetInfo,\n        }\n        self.addCallbacks(('6BFFD098-A112-3610-9833-46C3F87E345A', '1.0'),'\\\\PIPE\\\\wkssvc', self.wkssvcCallBacks)\n\n    def NetrWkstaGetInfo(self,data):\n        request = NetrWkstaGetInfo(data)\n        self.log(\"NetrWkstaGetInfo Level: %d\" % request['Level'])\n\n        answer = NetrWkstaGetInfoResponse()\n\n        if request['Level'] not in (100, 101):\n            answer['ErrorCode'] = ERROR_INVALID_LEVEL\n            return answer\n\n        answer['WkstaInfo']['tag'] = request['Level']\n\n        if request['Level'] == 100:\n            # Windows. Decimal value 500.\n            answer['WkstaInfo']['WkstaInfo100']['wki100_platform_id'] = 0x000001F4\n            answer['WkstaInfo']['WkstaInfo100']['wki100_computername'] = NULL\n            answer['WkstaInfo']['WkstaInfo100']['wki100_langroup'] = NULL\n            answer['WkstaInfo']['WkstaInfo100']['wki100_ver_major'] = 5\n            answer['WkstaInfo']['WkstaInfo100']['wki100_ver_minor'] = 0\n        else:\n            # Windows. Decimal value 500.\n            answer['WkstaInfo']['WkstaInfo101']['wki101_platform_id'] = 0x000001F4\n            answer['WkstaInfo']['WkstaInfo101']['wki101_computername'] = NULL\n            answer['WkstaInfo']['WkstaInfo101']['wki101_langroup'] = NULL\n            answer['WkstaInfo']['WkstaInfo101']['wki101_ver_major'] = 5\n            answer['WkstaInfo']['WkstaInfo101']['wki101_ver_minor'] = 0\n            answer['WkstaInfo']['WkstaInfo101']['wki101_lanroot'] = NULL\n\n        return answer\n\nclass SRVSServer(DCERPCServer):\n    def __init__(self):\n        DCERPCServer.__init__(self)\n\n        self._shares = {}\n        self.__serverConfig = None\n        self.__logFile = None\n\n        self.srvsvcCallBacks = {\n            15: self.NetrShareEnum,\n            16: self.NetrShareGetInfo,\n            21: self.NetrServerGetInfo,\n        }\n\n        self.addCallbacks(('4B324FC8-1670-01D3-1278-5A47BF6EE188', '3.0'),'\\\\PIPE\\\\srvsvc', self.srvsvcCallBacks)\n\n    def setServerConfig(self, config):\n        self.__serverConfig = config\n\n    def processConfigFile(self, configFile=None):\n       if configFile is not None:\n           self.__serverConfig = configparser.ConfigParser()\n           self.__serverConfig.read(configFile)\n       sections = self.__serverConfig.sections()\n       # Let's check the log file\n       self.__logFile      = self.__serverConfig.get('global','log_file')\n       if self.__logFile != 'None':\n            logging.basicConfig(filename = self.__logFile, \n                             level = logging.DEBUG, \n                             format=\"%(asctime)s: %(levelname)s: %(message)s\", \n                             datefmt = '%m/%d/%Y %I:%M:%S %p')\n\n       # Remove the global one\n       del(sections[sections.index('global')])\n       self._shares = {}\n       for i in sections:\n           self._shares[i] = dict(self.__serverConfig.items(i))\n\n    def NetrShareGetInfo(self,data):\n       request = NetrShareGetInfo(data)\n       self.log(\"NetrGetShareInfo Level: %d\" % request['Level'])\n\n       s = request['NetName'][:-1].upper()\n       answer = NetrShareGetInfoResponse()\n       if s in self._shares:\n           share  = self._shares[s]\n\n           answer['InfoStruct']['tag'] = 1\n           answer['InfoStruct']['ShareInfo1']['shi1_netname']= s+'\\x00'\n           answer['InfoStruct']['ShareInfo1']['shi1_type']   = share['share type']\n           answer['InfoStruct']['ShareInfo1']['shi1_remark'] = share['comment']+'\\x00' \n           answer['ErrorCode'] = 0\n       else:\n           answer['InfoStruct']['tag'] = 1\n           answer['InfoStruct']['ShareInfo1']= NULL\n           answer['ErrorCode'] = 0x0906 #WERR_NET_NAME_NOT_FOUND\n\n       return answer\n\n    def NetrServerGetInfo(self,data):\n       request = NetrServerGetInfo(data)\n       self.log(\"NetrServerGetInfo Level: %d\" % request['Level'])\n       answer = NetrServerGetInfoResponse()\n       answer['InfoStruct']['tag'] = 101\n       # PLATFORM_ID_NT = 500\n       answer['InfoStruct']['ServerInfo101']['sv101_platform_id'] = 500\n       answer['InfoStruct']['ServerInfo101']['sv101_name'] = request['ServerName']\n       # Windows 7 = 6.1\n       answer['InfoStruct']['ServerInfo101']['sv101_version_major'] = 6\n       answer['InfoStruct']['ServerInfo101']['sv101_version_minor'] = 1\n       # Workstation = 1\n       answer['InfoStruct']['ServerInfo101']['sv101_type'] = 1\n       answer['InfoStruct']['ServerInfo101']['sv101_comment'] = NULL\n       answer['ErrorCode'] = 0\n       return answer\n\n    def NetrShareEnum(self, data):\n       request = NetrShareEnum(data)\n       self.log(\"NetrShareEnum Level: %d\" % request['InfoStruct']['Level'])\n       shareEnum = NetrShareEnumResponse()\n       shareEnum['InfoStruct']['Level'] = 1\n       shareEnum['InfoStruct']['ShareInfo']['tag'] = 1\n       shareEnum['TotalEntries'] = len(self._shares)\n       shareEnum['InfoStruct']['ShareInfo']['Level1']['EntriesRead'] = len(self._shares)\n       shareEnum['ErrorCode'] = 0\n\n       for i in self._shares:\n           shareInfo = SHARE_INFO_1()\n           shareInfo['shi1_netname'] = i+'\\x00'\n           shareInfo['shi1_type'] = self._shares[i]['share type']\n           shareInfo['shi1_remark'] = self._shares[i]['comment']+'\\x00'\n           shareEnum['InfoStruct']['ShareInfo']['Level1']['Buffer'].append(shareInfo)\n\n       return shareEnum\n\nclass SimpleSMBServer:\n    \"\"\"\n    SimpleSMBServer class - Implements a simple, customizable SMB Server\n\n    :param string listenAddress: the address you want the server to listen on\n    :param integer listenPort: the port number you want the server to listen on\n    :param string configFile: a file with all the servers' configuration. If no file specified, this class will create the basic parameters needed to run. You will need to add your shares manually tho. See addShare() method\n    \"\"\"\n    def __init__(self, listenAddress = '0.0.0.0', listenPort=445, configFile=''):\n        if configFile != '':\n            self.__server = SMBSERVER((listenAddress,listenPort))\n            self.__server.processConfigFile(configFile)\n            self.__smbConfig = None\n        else:\n            # Here we write a mini config for the server\n            self.__smbConfig = configparser.ConfigParser()\n            self.__smbConfig.add_section('global')\n            self.__smbConfig.set('global','server_name',''.join([random.choice(string.ascii_letters) for _ in range(8)]))\n            self.__smbConfig.set('global','server_os',''.join([random.choice(string.ascii_letters) for _ in range(8)])\n)\n            self.__smbConfig.set('global','server_domain',''.join([random.choice(string.ascii_letters) for _ in range(8)])\n)\n            self.__smbConfig.set('global','log_file','None')\n            self.__smbConfig.set('global','rpc_apis','yes')\n            self.__smbConfig.set('global','credentials_file','')\n            self.__smbConfig.set('global', 'challenge', \"A\"*16)\n\n            # IPC always needed\n            self.__smbConfig.add_section('IPC$')\n            self.__smbConfig.set('IPC$','comment','')\n            self.__smbConfig.set('IPC$','read only','yes')\n            self.__smbConfig.set('IPC$','share type','3')\n            self.__smbConfig.set('IPC$','path','')\n            self.__server = SMBSERVER((listenAddress,listenPort), config_parser = self.__smbConfig)\n            self.__server.processConfigFile()\n\n        # Now we have to register the MS-SRVS server. This specially important for \n        # Windows 7+ and Mavericks clients since they WON'T (specially OSX) \n        # ask for shares using MS-RAP.\n\n        self.__srvsServer = SRVSServer()\n        self.__srvsServer.daemon = True\n        self.__wkstServer = WKSTServer()\n        self.__wkstServer.daemon = True\n        self.__server.registerNamedPipe('srvsvc',('127.0.0.1',self.__srvsServer.getListenPort()))\n        self.__server.registerNamedPipe('wkssvc',('127.0.0.1',self.__wkstServer.getListenPort()))\n\n    def start(self):\n        self.__srvsServer.start()\n        self.__wkstServer.start()\n        self.__server.serve_forever()\n\n    def registerNamedPipe(self, pipeName, address):\n        return self.__server.registerNamedPipe(pipeName, address)\n\n    def unregisterNamedPipe(self, pipeName):\n        return self.__server.unregisterNamedPipe(pipeName)\n\n    def getRegisteredNamedPipes(self):\n        return self.__server.getRegisteredNamedPipes()\n\n    def addShare(self, shareName, sharePath, shareComment='', shareType = '0', readOnly = 'no'):\n        share = shareName.upper()\n        self.__smbConfig.add_section(share)\n        self.__smbConfig.set(share, 'comment', shareComment)\n        self.__smbConfig.set(share, 'read only', readOnly)\n        self.__smbConfig.set(share, 'share type', shareType)\n        self.__smbConfig.set(share, 'path', sharePath)\n        self.__server.setServerConfig(self.__smbConfig)\n        self.__srvsServer.setServerConfig(self.__smbConfig)\n        self.__server.processConfigFile()\n        self.__srvsServer.processConfigFile()\n\n    def removeShare(self, shareName):\n        self.__smbConfig.remove_section(shareName.upper())\n        self.__server.setServerConfig(self.__smbConfig)\n        self.__srvsServer.setServerConfig(self.__smbConfig)\n        self.__server.processConfigFile()\n        self.__srvsServer.processConfigFile()\n\n    def setSMBChallenge(self, challenge):\n        if challenge != '':\n            self.__smbConfig.set('global', 'challenge', challenge)\n            self.__server.setServerConfig(self.__smbConfig)\n            self.__server.processConfigFile()\n        \n    def setLogFile(self, logFile):\n        self.__smbConfig.set('global','log_file',logFile)\n        self.__server.setServerConfig(self.__smbConfig)\n        self.__server.processConfigFile()\n\n    def setCredentialsFile(self, logFile):\n        self.__smbConfig.set('global','credentials_file',logFile)\n        self.__server.setServerConfig(self.__smbConfig)\n        self.__server.processConfigFile()\n\n    def addCredential(self, name, uid, lmhash, nthash):\n        self.__server.addCredential(name, uid, lmhash, nthash)\n\n    def setSMB2Support(self, value):\n        if value is True:\n            self.__smbConfig.set(\"global\", \"SMB2Support\", \"True\")\n        else:\n            self.__smbConfig.set(\"global\", \"SMB2Support\", \"False\")\n        self.__server.setServerConfig(self.__smbConfig)\n        self.__server.processConfigFile()\n"], "fixing_code": ["# SECUREAUTH LABS. Copyright 2018 SecureAuth Corporation. All rights reserved.\n#\n# This software is provided under under a slightly modified version\n# of the Apache Software License. See the accompanying LICENSE file\n# for more information.\n#\n# Author: Alberto Solino (@agsolino)\n#\n# TODO:\n# [-] Functions should return NT error codes\n# [-] Handling errors in all situations, right now it's just raising exceptions. \n# [*] Standard authentication support\n# [ ] Organize the connectionData stuff\n# [*] Add capability to send a bad user ID if the user is not authenticated,\n#     right now you can ask for any command without actually being authenticated\n# [ ] PATH TRAVERSALS EVERYWHERE.. BE WARNED!\n# [ ] Check error situation (now many places assume the right data is coming)\n# [ ] Implement IPC to the main process so the connectionData is on a single place\n# [ ] Hence.. implement locking\n# estamos en la B\n\n\nimport calendar\nimport socket\nimport time\nimport datetime\nimport struct\nimport threading\nimport logging\nimport logging.config\nimport ntpath\nimport os\nimport fnmatch\nimport errno\nimport sys\nimport random\nimport shutil\nimport string\nimport hashlib\nimport hmac\n\nfrom binascii import unhexlify, hexlify, a2b_hex\nfrom six import PY2, b, text_type\nfrom six.moves import configparser, socketserver\n\n# For signing\nfrom impacket import smb, nmb, ntlm, uuid\nfrom impacket import smb3structs as smb2\nfrom impacket.spnego import SPNEGO_NegTokenInit, TypesMech, MechTypes, SPNEGO_NegTokenResp, ASN1_AID, \\\n    ASN1_SUPPORTED_MECH\nfrom impacket.nt_errors import STATUS_NO_MORE_FILES, STATUS_NETWORK_NAME_DELETED, STATUS_INVALID_PARAMETER, \\\n    STATUS_FILE_CLOSED, STATUS_MORE_PROCESSING_REQUIRED, STATUS_OBJECT_PATH_NOT_FOUND, STATUS_DIRECTORY_NOT_EMPTY, \\\n    STATUS_FILE_IS_A_DIRECTORY, STATUS_NOT_IMPLEMENTED, STATUS_INVALID_HANDLE, STATUS_OBJECT_NAME_COLLISION, \\\n    STATUS_NO_SUCH_FILE, STATUS_CANCELLED, STATUS_OBJECT_NAME_NOT_FOUND, STATUS_SUCCESS, STATUS_ACCESS_DENIED, \\\n    STATUS_NOT_SUPPORTED, STATUS_INVALID_DEVICE_REQUEST, STATUS_FS_DRIVER_REQUIRED, STATUS_INVALID_INFO_CLASS, \\\n    STATUS_LOGON_FAILURE, STATUS_OBJECT_PATH_SYNTAX_BAD\n\n# Setting LOG to current's module name\nLOG = logging.getLogger(__name__)\n\n# These ones not defined in nt_errors\nSTATUS_SMB_BAD_UID = 0x005B0002\nSTATUS_SMB_BAD_TID = 0x00050002\n\n\n# Utility functions\n# and general functions.\n# There are some common functions that can be accessed from more than one SMB\n# command (or either TRANSACTION). That's why I'm putting them here\n# TODO: Return NT ERROR Codes\n\ndef computeNTLMv2(identity, lmhash, nthash, serverChallenge, authenticateMessage, ntlmChallenge, type1):\n    # Let's calculate the NTLMv2 Response\n\n    responseKeyNT = ntlm.NTOWFv2(identity, '', authenticateMessage['domain_name'].decode('utf-16le'), nthash)\n    responseKeyLM = ntlm.LMOWFv2(identity, '', authenticateMessage['domain_name'].decode('utf-16le'), lmhash)\n\n    ntProofStr = authenticateMessage['ntlm'][:16]\n    temp = authenticateMessage['ntlm'][16:]\n    ntProofStr2 = ntlm.hmac_md5(responseKeyNT, serverChallenge + temp)\n    lmChallengeResponse = authenticateMessage['lanman']\n    sessionBaseKey = ntlm.hmac_md5(responseKeyNT, ntProofStr)\n\n    responseFlags = type1['flags']\n\n    # Let's check the return flags\n    if (ntlmChallenge['flags'] & ntlm.NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY) == 0:\n        # No extended session security, taking it out\n        responseFlags &= 0xffffffff ^ ntlm.NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY\n    if (ntlmChallenge['flags'] & ntlm.NTLMSSP_NEGOTIATE_128) == 0:\n        # No support for 128 key len, taking it out\n        responseFlags &= 0xffffffff ^ ntlm.NTLMSSP_NEGOTIATE_128\n    if (ntlmChallenge['flags'] & ntlm.NTLMSSP_NEGOTIATE_KEY_EXCH) == 0:\n        # No key exchange supported, taking it out\n        responseFlags &= 0xffffffff ^ ntlm.NTLMSSP_NEGOTIATE_KEY_EXCH\n    if (ntlmChallenge['flags'] & ntlm.NTLMSSP_NEGOTIATE_SEAL) == 0:\n        # No sign available, taking it out\n        responseFlags &= 0xffffffff ^ ntlm.NTLMSSP_NEGOTIATE_SEAL\n    if (ntlmChallenge['flags'] & ntlm.NTLMSSP_NEGOTIATE_SIGN) == 0:\n        # No sign available, taking it out\n        responseFlags &= 0xffffffff ^ ntlm.NTLMSSP_NEGOTIATE_SIGN\n    if (ntlmChallenge['flags'] & ntlm.NTLMSSP_NEGOTIATE_ALWAYS_SIGN) == 0:\n        # No sign available, taking it out\n        responseFlags &= 0xffffffff ^ ntlm.NTLMSSP_NEGOTIATE_ALWAYS_SIGN\n\n    keyExchangeKey = ntlm.KXKEY(ntlmChallenge['flags'], sessionBaseKey, lmChallengeResponse,\n                                ntlmChallenge['challenge'], '',\n                                lmhash, nthash, True)\n\n    # If we set up key exchange, let's fill the right variables\n    if ntlmChallenge['flags'] & ntlm.NTLMSSP_NEGOTIATE_KEY_EXCH:\n        exportedSessionKey = authenticateMessage['session_key']\n        exportedSessionKey = ntlm.generateEncryptedSessionKey(keyExchangeKey, exportedSessionKey)\n    else:\n        encryptedRandomSessionKey = None\n        # [MS-NLMP] page 46\n        exportedSessionKey = keyExchangeKey\n\n    # Do they match?\n    if ntProofStr == ntProofStr2:\n        # Yes!, process login\n        return STATUS_SUCCESS, exportedSessionKey\n    else:\n        return STATUS_LOGON_FAILURE, exportedSessionKey\n\n\ndef outputToJohnFormat(challenge, username, domain, lmresponse, ntresponse):\n    # We don't want to add a possible failure here, since this is an\n    # extra bonus. We try, if it fails, returns nothing\n    # ToDo: Document the parameter's types (bytes / string) and check all the places where it's called\n    ret_value = ''\n    if type(challenge) is not bytes:\n        challenge = challenge.decode('latin-1')\n\n    try:\n        if len(ntresponse) > 24:\n            # Extended Security - NTLMv2\n            ret_value = {'hash_string': '%s::%s:%s:%s:%s' % (\n                username.decode('utf-16le'), domain.decode('utf-16le'), hexlify(challenge).decode('latin-1'),\n                hexlify(ntresponse).decode('latin-1')[:32],\n                hexlify(ntresponse).decode()[32:]), 'hash_version': 'ntlmv2'}\n        else:\n            # NTLMv1\n            ret_value = {'hash_string': '%s::%s:%s:%s:%s' % (\n                username.decode('utf-16le'), domain.decode('utf-16le'), hexlify(lmresponse).decode('latin-1'),\n                hexlify(ntresponse).decode('latin-1'),\n                hexlify(challenge).decode()), 'hash_version': 'ntlm'}\n    except:\n        # Let's try w/o decoding Unicode\n        try:\n            if len(ntresponse) > 24:\n                # Extended Security - NTLMv2\n                ret_value = {'hash_string': '%s::%s:%s:%s:%s' % (\n                    username.decode('latin-1'), domain.decode('latin-1'), hexlify(challenge).decode('latin-1'),\n                    hexlify(ntresponse)[:32].decode('latin-1'), hexlify(ntresponse)[32:].decode('latin-1')),\n                             'hash_version': 'ntlmv2'}\n            else:\n                # NTLMv1\n                ret_value = {'hash_string': '%s::%s:%s:%s:%s' % (\n                    username, domain, hexlify(lmresponse).decode('latin-1'), hexlify(ntresponse).decode('latin-1'),\n                    hexlify(challenge).decode('latin-1')), 'hash_version': 'ntlm'}\n        except Exception as e:\n            import traceback\n            traceback.print_exc()\n            LOG.error(\"outputToJohnFormat: %s\" % e)\n            pass\n\n    return ret_value\n\n\ndef writeJohnOutputToFile(hash_string, hash_version, file_name):\n    fn_data = os.path.splitext(file_name)\n    if hash_version == \"ntlmv2\":\n        output_filename = fn_data[0] + \"_ntlmv2\" + fn_data[1]\n    else:\n        output_filename = fn_data[0] + \"_ntlm\" + fn_data[1]\n\n    with open(output_filename, \"a\") as f:\n        f.write(hash_string)\n        f.write('\\n')\n\n\ndef decodeSMBString(flags, text):\n    if flags & smb.SMB.FLAGS2_UNICODE:\n        return text.decode('utf-16le')\n    else:\n        return text\n\n\ndef encodeSMBString(flags, text):\n    if flags & smb.SMB.FLAGS2_UNICODE:\n        return (text).encode('utf-16le')\n    else:\n        return text.encode('ascii')\n\n\ndef getFileTime(t):\n    t *= 10000000\n    t += 116444736000000000\n    return t\n\n\ndef getUnixTime(t):\n    t -= 116444736000000000\n    t //= 10000000\n    return t\n\n\ndef getSMBDate(t):\n    # TODO: Fix this :P\n    d = datetime.date.fromtimestamp(t)\n    year = d.year - 1980\n    ret = (year << 8) + (d.month << 4) + d.day\n    return ret\n\n\ndef getSMBTime(t):\n    # TODO: Fix this :P\n    d = datetime.datetime.fromtimestamp(t)\n    return (d.hour << 8) + (d.minute << 4) + d.second\n\n\ndef getShares(connId, smbServer):\n    config = smbServer.getServerConfig()\n    sections = config.sections()\n    # Remove the global one\n    del (sections[sections.index('global')])\n    shares = {}\n    for i in sections:\n        shares[i] = dict(config.items(i))\n    return shares\n\n\ndef searchShare(connId, share, smbServer):\n    config = smbServer.getServerConfig()\n    if config.has_section(share):\n        return dict(config.items(share))\n    else:\n        return None\n\n\ndef openFile(path, fileName, accessMode, fileAttributes, openMode):\n    fileName = os.path.normpath(fileName.replace('\\\\', '/'))\n    errorCode = 0\n    if len(fileName) > 0 and (fileName[0] == '/' or fileName[0] == '\\\\'):\n        # strip leading '/'\n        fileName = fileName[1:]\n    pathName = os.path.join(path, fileName)\n    mode = 0\n    # Check the Open Mode\n    if openMode & 0x10:\n        # If the file does not exist, create it.\n        mode = os.O_CREAT\n    else:\n        # If file does not exist, return an error\n        if os.path.exists(pathName) is not True:\n            errorCode = STATUS_NO_SUCH_FILE\n            return 0, mode, pathName, errorCode\n\n    if os.path.isdir(pathName) and (fileAttributes & smb.ATTR_DIRECTORY) == 0:\n        # Request to open a normal file and this is actually a directory\n        errorCode = STATUS_FILE_IS_A_DIRECTORY\n        return 0, mode, pathName, errorCode\n    # Check the Access Mode\n    if accessMode & 0x7 == 1:\n        mode |= os.O_WRONLY\n    elif accessMode & 0x7 == 2:\n        mode |= os.O_RDWR\n    else:\n        mode = os.O_RDONLY\n\n    try:\n        if sys.platform == 'win32':\n            mode |= os.O_BINARY\n        fid = os.open(pathName, mode)\n    except Exception as e:\n        LOG.error(\"openFile: %s,%s\" % (pathName, mode), e)\n        fid = 0\n        errorCode = STATUS_ACCESS_DENIED\n\n    return fid, mode, pathName, errorCode\n\n\ndef queryFsInformation(path, filename, level=0, pktFlags=smb.SMB.FLAGS2_UNICODE):\n    if pktFlags & smb.SMB.FLAGS2_UNICODE:\n        encoding = 'utf-16le'\n    else:\n        encoding = 'ascii'\n\n    fileName = os.path.normpath(filename.replace('\\\\', '/'))\n    if len(fileName) > 0 and (fileName[0] == '/' or fileName[0] == '\\\\'):\n        # strip leading '/'\n        fileName = fileName[1:]\n    pathName = os.path.join(path, fileName)\n    fileSize = os.path.getsize(pathName)\n    (mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime) = os.stat(pathName)\n    if level == smb.SMB_QUERY_FS_ATTRIBUTE_INFO or level == smb2.SMB2_FILESYSTEM_ATTRIBUTE_INFO:\n        data = smb.SMBQueryFsAttributeInfo()\n        data['FileSystemAttributes'] = smb.FILE_CASE_SENSITIVE_SEARCH | smb.FILE_CASE_PRESERVED_NAMES\n        data['MaxFilenNameLengthInBytes'] = 255\n        data['LengthOfFileSystemName'] = len('XTFS') * 2\n        data['FileSystemName'] = 'XTFS'.encode('utf-16le')\n        return data.getData()\n    elif level == smb.SMB_INFO_VOLUME:\n        data = smb.SMBQueryFsInfoVolume(flags=pktFlags)\n        data['VolumeLabel'] = 'SHARE'.encode(encoding)\n        return data.getData()\n    elif level == smb.SMB_QUERY_FS_VOLUME_INFO or level == smb2.SMB2_FILESYSTEM_VOLUME_INFO:\n        data = smb.SMBQueryFsVolumeInfo()\n        data['VolumeLabel'] = ''\n        data['VolumeCreationTime'] = getFileTime(ctime)\n        return data.getData()\n    elif level == smb.SMB_QUERY_FS_SIZE_INFO:\n        data = smb.SMBQueryFsSizeInfo()\n        return data.getData()\n    elif level == smb.FILE_FS_FULL_SIZE_INFORMATION:\n        data = smb.SMBFileFsFullSizeInformation()\n        return data.getData()\n    elif level == smb.FILE_FS_SIZE_INFORMATION:\n        data = smb.FileFsSizeInformation()\n        return data.getData()\n    else:\n        lastWriteTime = mtime\n        attribs = 0\n        if os.path.isdir(pathName):\n            attribs |= smb.SMB_FILE_ATTRIBUTE_DIRECTORY\n        if os.path.isfile(pathName):\n            attribs |= smb.SMB_FILE_ATTRIBUTE_NORMAL\n        fileAttributes = attribs\n        return fileSize, lastWriteTime, fileAttributes\n\n\ndef findFirst2(path, fileName, level, searchAttributes, pktFlags=smb.SMB.FLAGS2_UNICODE, isSMB2=False):\n    # TODO: Depending on the level, this could be done much simpler\n\n    # print \"FindFirs2 path:%s, filename:%s\" % (path, fileName)\n    fileName = os.path.normpath(fileName.replace('\\\\', '/'))\n    # Let's choose the right encoding depending on the request\n    if pktFlags & smb.SMB.FLAGS2_UNICODE:\n        encoding = 'utf-16le'\n    else:\n        encoding = 'ascii'\n\n    if len(fileName) > 0 and (fileName[0] == '/' or fileName[0] == '\\\\'):\n        # strip leading '/'\n        fileName = fileName[1:]\n\n    if not isInFileJail(path, fileName):\n        LOG.error(\"Path not in current working directory\")\n        return [], 0, STATUS_OBJECT_PATH_SYNTAX_BAD\n\n    pathName = os.path.join(path, fileName)\n    files = []\n\n    if pathName.find('*') == -1 and pathName.find('?') == -1:\n        # No search patterns\n        pattern = ''\n    else:\n        pattern = os.path.basename(pathName)\n        dirName = os.path.dirname(pathName)\n\n    # Always add . and .. Not that important for Windows, but Samba whines if\n    # not present (for * search only)\n    if pattern == '*':\n        files.append(os.path.join(dirName, '.'))\n        files.append(os.path.join(dirName, '..'))\n\n    if pattern != '':\n        for file in os.listdir(dirName):\n            if fnmatch.fnmatch(file.lower(), pattern.lower()):\n                entry = os.path.join(dirName, file)\n                if os.path.isdir(entry):\n                    if searchAttributes & smb.ATTR_DIRECTORY:\n                        files.append(entry)\n                else:\n                    files.append(entry)\n    else:\n        if os.path.exists(pathName):\n            files.append(pathName)\n\n    searchResult = []\n    searchCount = len(files)\n    errorCode = STATUS_SUCCESS\n\n    for i in files:\n        if level == smb.SMB_FIND_FILE_BOTH_DIRECTORY_INFO or level == smb2.SMB2_FILE_BOTH_DIRECTORY_INFO:\n            item = smb.SMBFindFileBothDirectoryInfo(flags=pktFlags)\n        elif level == smb.SMB_FIND_FILE_DIRECTORY_INFO or level == smb2.SMB2_FILE_DIRECTORY_INFO:\n            item = smb.SMBFindFileDirectoryInfo(flags=pktFlags)\n        elif level == smb.SMB_FIND_FILE_FULL_DIRECTORY_INFO or level == smb2.SMB2_FULL_DIRECTORY_INFO:\n            item = smb.SMBFindFileFullDirectoryInfo(flags=pktFlags)\n        elif level == smb.SMB_FIND_INFO_STANDARD:\n            item = smb.SMBFindInfoStandard(flags=pktFlags)\n        elif level == smb.SMB_FIND_FILE_ID_FULL_DIRECTORY_INFO or level == smb2.SMB2_FILE_ID_FULL_DIRECTORY_INFO:\n            item = smb.SMBFindFileIdFullDirectoryInfo(flags=pktFlags)\n        elif level == smb.SMB_FIND_FILE_ID_BOTH_DIRECTORY_INFO or level == smb2.SMB2_FILE_ID_BOTH_DIRECTORY_INFO:\n            item = smb.SMBFindFileIdBothDirectoryInfo(flags=pktFlags)\n        elif level == smb.SMB_FIND_FILE_NAMES_INFO or level == smb2.SMB2_FILE_NAMES_INFO:\n            item = smb.SMBFindFileNamesInfo(flags=pktFlags)\n        else:\n            LOG.error(\"Wrong level %d!\" % level)\n            return searchResult, searchCount, STATUS_NOT_SUPPORTED\n\n        (mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime) = os.stat(i)\n        if os.path.isdir(i):\n            item['ExtFileAttributes'] = smb.ATTR_DIRECTORY\n        else:\n            item['ExtFileAttributes'] = smb.ATTR_NORMAL | smb.ATTR_ARCHIVE\n\n        item['FileName'] = os.path.basename(i).encode(encoding)\n\n        if level == smb.SMB_FIND_FILE_BOTH_DIRECTORY_INFO or level == smb.SMB_FIND_FILE_ID_BOTH_DIRECTORY_INFO or level == smb2.SMB2_FILE_ID_BOTH_DIRECTORY_INFO or level == smb2.SMB2_FILE_BOTH_DIRECTORY_INFO:\n            item['EaSize'] = 0\n            item['EndOfFile'] = size\n            item['AllocationSize'] = size\n            item['CreationTime'] = getFileTime(ctime)\n            item['LastAccessTime'] = getFileTime(atime)\n            item['LastWriteTime'] = getFileTime(mtime)\n            item['LastChangeTime'] = getFileTime(mtime)\n            item['ShortName'] = '\\x00' * 24\n            item['FileName'] = os.path.basename(i).encode(encoding)\n            padLen = (8 - (len(item) % 8)) % 8\n            item['NextEntryOffset'] = len(item) + padLen\n        elif level == smb.SMB_FIND_FILE_DIRECTORY_INFO:\n            item['EndOfFile'] = size\n            item['AllocationSize'] = size\n            item['CreationTime'] = getFileTime(ctime)\n            item['LastAccessTime'] = getFileTime(atime)\n            item['LastWriteTime'] = getFileTime(mtime)\n            item['LastChangeTime'] = getFileTime(mtime)\n            item['FileName'] = os.path.basename(i).encode(encoding)\n            padLen = (8 - (len(item) % 8)) % 8\n            item['NextEntryOffset'] = len(item) + padLen\n        elif level == smb.SMB_FIND_FILE_FULL_DIRECTORY_INFO or level == smb.SMB_FIND_FILE_ID_FULL_DIRECTORY_INFO or level == smb2.SMB2_FULL_DIRECTORY_INFO:\n            item['EaSize'] = 0\n            item['EndOfFile'] = size\n            item['AllocationSize'] = size\n            item['CreationTime'] = getFileTime(ctime)\n            item['LastAccessTime'] = getFileTime(atime)\n            item['LastWriteTime'] = getFileTime(mtime)\n            item['LastChangeTime'] = getFileTime(mtime)\n            padLen = (8 - (len(item) % 8)) % 8\n            item['NextEntryOffset'] = len(item) + padLen\n        elif level == smb.SMB_FIND_INFO_STANDARD:\n            item['EaSize'] = size\n            item['CreationDate'] = getSMBDate(ctime)\n            item['CreationTime'] = getSMBTime(ctime)\n            item['LastAccessDate'] = getSMBDate(atime)\n            item['LastAccessTime'] = getSMBTime(atime)\n            item['LastWriteDate'] = getSMBDate(mtime)\n            item['LastWriteTime'] = getSMBTime(mtime)\n        searchResult.append(item)\n\n    # No more files\n    if (level >= smb.SMB_FIND_FILE_DIRECTORY_INFO or isSMB2 is True) and searchCount > 0:\n        searchResult[-1]['NextEntryOffset'] = 0\n\n    return searchResult, searchCount, errorCode\n\n\ndef queryFileInformation(path, filename, level):\n    # print \"queryFileInfo path: %s, filename: %s, level:0x%x\" % (path,filename,level)\n    return queryPathInformation(path, filename, level)\n\n\ndef queryPathInformation(path, filename, level):\n    # TODO: Depending on the level, this could be done much simpler\n    # print(\"queryPathInfo path: %s, filename: %s, level:0x%x\" % (path,filename,level))\n    try:\n        errorCode = 0\n        fileName = os.path.normpath(filename.replace('\\\\', '/'))\n        if len(fileName) > 0 and (fileName[0] == '/' or fileName[0] == '\\\\') and path != '':\n            # strip leading '/'\n            fileName = fileName[1:]\n        pathName = os.path.join(path, fileName)\n        if os.path.exists(pathName):\n            (mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime) = os.stat(pathName)\n            if level == smb.SMB_QUERY_FILE_BASIC_INFO:\n                infoRecord = smb.SMBQueryFileBasicInfo()\n                infoRecord['CreationTime'] = getFileTime(ctime)\n                infoRecord['LastAccessTime'] = getFileTime(atime)\n                infoRecord['LastWriteTime'] = getFileTime(mtime)\n                infoRecord['LastChangeTime'] = getFileTime(mtime)\n                if os.path.isdir(pathName):\n                    infoRecord['ExtFileAttributes'] = smb.ATTR_DIRECTORY\n                else:\n                    infoRecord['ExtFileAttributes'] = smb.ATTR_NORMAL | smb.ATTR_ARCHIVE\n            elif level == smb.SMB_QUERY_FILE_STANDARD_INFO:\n                infoRecord = smb.SMBQueryFileStandardInfo()\n                infoRecord['AllocationSize'] = size\n                infoRecord['EndOfFile'] = size\n                if os.path.isdir(pathName):\n                    infoRecord['Directory'] = 1\n                else:\n                    infoRecord['Directory'] = 0\n            elif level == smb.SMB_QUERY_FILE_ALL_INFO or level == smb2.SMB2_FILE_ALL_INFO:\n                infoRecord = smb.SMBQueryFileAllInfo()\n                infoRecord['CreationTime'] = getFileTime(ctime)\n                infoRecord['LastAccessTime'] = getFileTime(atime)\n                infoRecord['LastWriteTime'] = getFileTime(mtime)\n                infoRecord['LastChangeTime'] = getFileTime(mtime)\n                if os.path.isdir(pathName):\n                    infoRecord['ExtFileAttributes'] = smb.ATTR_DIRECTORY\n                else:\n                    infoRecord['ExtFileAttributes'] = smb.ATTR_NORMAL | smb.ATTR_ARCHIVE\n                infoRecord['AllocationSize'] = size\n                infoRecord['EndOfFile'] = size\n                if os.path.isdir(pathName):\n                    infoRecord['Directory'] = 1\n                else:\n                    infoRecord['Directory'] = 0\n                infoRecord['FileName'] = filename.encode('utf-16le')\n            elif level == smb2.SMB2_FILE_NETWORK_OPEN_INFO:\n                infoRecord = smb.SMBFileNetworkOpenInfo()\n                infoRecord['CreationTime'] = getFileTime(ctime)\n                infoRecord['LastAccessTime'] = getFileTime(atime)\n                infoRecord['LastWriteTime'] = getFileTime(mtime)\n                infoRecord['ChangeTime'] = getFileTime(mtime)\n                infoRecord['AllocationSize'] = size\n                infoRecord['EndOfFile'] = size\n                if os.path.isdir(pathName):\n                    infoRecord['FileAttributes'] = smb.ATTR_DIRECTORY\n                else:\n                    infoRecord['FileAttributes'] = smb.ATTR_NORMAL | smb.ATTR_ARCHIVE\n            elif level == smb.SMB_QUERY_FILE_EA_INFO or level == smb2.SMB2_FILE_EA_INFO:\n                infoRecord = smb.SMBQueryFileEaInfo()\n            elif level == smb2.SMB2_FILE_STREAM_INFO:\n                infoRecord = smb.SMBFileStreamInformation()\n            else:\n                LOG.error('Unknown level for query path info! 0x%x' % level)\n                # UNSUPPORTED\n                return None, STATUS_NOT_SUPPORTED\n\n            return infoRecord, errorCode\n        else:\n            # NOT FOUND\n            return None, STATUS_OBJECT_NAME_NOT_FOUND\n    except Exception as e:\n        LOG.error('queryPathInfo: %s' % e)\n        raise\n\n\ndef queryDiskInformation(path):\n    # TODO: Do something useful here :)\n    # For now we just return fake values\n    totalUnits = 65535\n    freeUnits = 65535\n    return totalUnits, freeUnits\n\n\ndef isInFileJail(path, fileName):\n    pathName = os.path.join(path, fileName)\n    share_real_path = os.path.realpath(path)\n    return os.path.commonprefix((os.path.realpath(pathName), share_real_path)) == share_real_path\n\n\n# Here we implement the NT transaction handlers\nclass NTTRANSCommands:\n    def default(self, connId, smbServer, recvPacket, parameters, data, maxDataCount=0):\n        pass\n\n\n# Here we implement the NT transaction handlers\nclass TRANSCommands:\n    @staticmethod\n    def lanMan(connId, smbServer, recvPacket, parameters, data, maxDataCount=0):\n        # Minimal [MS-RAP] implementation, just to return the shares\n        connData = smbServer.getConnectionData(connId)\n\n        respSetup = b''\n        respParameters = b''\n        respData = b''\n        errorCode = STATUS_SUCCESS\n        if struct.unpack('<H', parameters[:2])[0] == 0:\n            # NetShareEnum Request\n            netShareEnum = smb.SMBNetShareEnum(parameters)\n            if netShareEnum['InfoLevel'] == 1:\n                shares = getShares(connId, smbServer)\n                respParameters = smb.SMBNetShareEnumResponse()\n                respParameters['EntriesReturned'] = len(shares)\n                respParameters['EntriesAvailable'] = len(shares)\n                tailData = ''\n                for i in shares:\n                    # NetShareInfo1 len == 20\n                    entry = smb.NetShareInfo1()\n                    entry['NetworkName'] = i + '\\x00' * (13 - len(i))\n                    entry['Type'] = int(shares[i]['share type'])\n                    # (beto) If offset == 0 it crashes explorer.exe on windows 7\n                    entry['RemarkOffsetLow'] = 20 * len(shares) + len(tailData)\n                    respData += entry.getData()\n                    if 'comment' in shares[i]:\n                        tailData += shares[i]['comment'] + '\\x00'\n                    else:\n                        tailData += '\\x00'\n                respData += tailData\n            else:\n                # We don't support other info levels\n                errorCode = STATUS_NOT_SUPPORTED\n        elif struct.unpack('<H', parameters[:2])[0] == 13:\n            # NetrServerGetInfo Request\n            respParameters = smb.SMBNetServerGetInfoResponse()\n            netServerInfo = smb.SMBNetServerInfo1()\n            netServerInfo['ServerName'] = smbServer.getServerName()\n            respData = netServerInfo.getData()\n            respParameters['TotalBytesAvailable'] = len(respData)\n        elif struct.unpack('<H', parameters[:2])[0] == 1:\n            # NetrShareGetInfo Request\n            request = smb.SMBNetShareGetInfo(parameters)\n            respParameters = smb.SMBNetShareGetInfoResponse()\n            shares = getShares(connId, smbServer)\n            share = shares[request['ShareName'].upper()]\n            shareInfo = smb.NetShareInfo1()\n            shareInfo['NetworkName'] = request['ShareName'].upper() + '\\x00'\n            shareInfo['Type'] = int(share['share type'])\n            respData = shareInfo.getData()\n            if 'comment' in share:\n                shareInfo['RemarkOffsetLow'] = len(respData)\n                respData += share['comment'] + '\\x00'\n            respParameters['TotalBytesAvailable'] = len(respData)\n\n        else:\n            # We don't know how to handle anything else\n            errorCode = STATUS_NOT_SUPPORTED\n\n        smbServer.setConnectionData(connId, connData)\n\n        return respSetup, respParameters, respData, errorCode\n\n    @staticmethod\n    def transactNamedPipe(connId, smbServer, recvPacket, parameters, data, maxDataCount=0):\n        connData = smbServer.getConnectionData(connId)\n\n        respSetup = b''\n        respParameters = b''\n        respData = b''\n        errorCode = STATUS_SUCCESS\n        SMBCommand = smb.SMBCommand(recvPacket['Data'][0])\n        transParameters = smb.SMBTransaction_Parameters(SMBCommand['Parameters'])\n\n        # Extract the FID\n        fid = struct.unpack('<H', transParameters['Setup'][2:])[0]\n\n        if fid in connData['OpenedFiles']:\n            fileHandle = connData['OpenedFiles'][fid]['FileHandle']\n            if fileHandle != PIPE_FILE_DESCRIPTOR:\n                os.write(fileHandle, data)\n                respData = os.read(fileHandle, data)\n            else:\n                sock = connData['OpenedFiles'][fid]['Socket']\n                sock.send(data)\n                respData = sock.recv(maxDataCount)\n        else:\n            errorCode = STATUS_INVALID_HANDLE\n\n        smbServer.setConnectionData(connId, connData)\n\n        return respSetup, respParameters, respData, errorCode\n\n\n# Here we implement the transaction2 handlers\nclass TRANS2Commands:\n    # All these commands return setup, parameters, data, errorCode\n    @staticmethod\n    def setPathInformation(connId, smbServer, recvPacket, parameters, data, maxDataCount=0):\n        connData = smbServer.getConnectionData(connId)\n\n        respSetup = b''\n        respParameters = b''\n        respData = b''\n        errorCode = STATUS_SUCCESS\n        setPathInfoParameters = smb.SMBSetPathInformation_Parameters(flags=recvPacket['Flags2'], data=parameters)\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            path = connData['ConnectedShares'][recvPacket['Tid']]['path']\n            fileName = decodeSMBString(recvPacket['Flags2'], setPathInfoParameters['FileName'])\n            fileName = os.path.normpath(fileName.replace('\\\\', '/'))\n            if len(fileName) > 0 and (fileName[0] == '/' or fileName[0] == '\\\\') and path != '':\n                # strip leading '/'\n                fileName = fileName[1:]\n            pathName = os.path.join(path, fileName)\n            if os.path.exists(pathName):\n                informationLevel = setPathInfoParameters['InformationLevel']\n                if informationLevel == smb.SMB_SET_FILE_BASIC_INFO:\n                    infoRecord = smb.SMBSetFileBasicInfo(data)\n                    # Creation time won't be set,  the other ones we play with.\n                    atime = infoRecord['LastAccessTime']\n                    if atime == 0:\n                        atime = -1\n                    else:\n                        atime = getUnixTime(atime)\n                    mtime = infoRecord['LastWriteTime']\n                    if mtime == 0:\n                        mtime = -1\n                    else:\n                        mtime = getUnixTime(mtime)\n                    if mtime != -1 or atime != -1:\n                        os.utime(pathName, (atime, mtime))\n                else:\n                    smbServer.log('Unknown level for set path info! 0x%x' % setPathInfoParameters['InformationLevel'],\n                                  logging.ERROR)\n                    # UNSUPPORTED\n                    errorCode = STATUS_NOT_SUPPORTED\n            else:\n                errorCode = STATUS_OBJECT_NAME_NOT_FOUND\n\n            if errorCode == STATUS_SUCCESS:\n                respParameters = smb.SMBSetPathInformationResponse_Parameters()\n\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        smbServer.setConnectionData(connId, connData)\n\n        return respSetup, respParameters, respData, errorCode\n\n    @staticmethod\n    def setFileInformation(connId, smbServer, recvPacket, parameters, data, maxDataCount=0):\n        connData = smbServer.getConnectionData(connId)\n\n        respSetup = b''\n        respParameters = b''\n        respData = b''\n        errorCode = STATUS_SUCCESS\n        setFileInfoParameters = smb.SMBSetFileInformation_Parameters(parameters)\n\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            if setFileInfoParameters['FID'] in connData['OpenedFiles']:\n                fileName = connData['OpenedFiles'][setFileInfoParameters['FID']]['FileName']\n                informationLevel = setFileInfoParameters['InformationLevel']\n                if informationLevel == smb.SMB_SET_FILE_DISPOSITION_INFO:\n                    infoRecord = smb.SMBSetFileDispositionInfo(parameters)\n                    if infoRecord['DeletePending'] > 0:\n                        # Mark this file for removal after closed\n                        connData['OpenedFiles'][setFileInfoParameters['FID']]['DeleteOnClose'] = True\n                        respParameters = smb.SMBSetFileInformationResponse_Parameters()\n                elif informationLevel == smb.SMB_SET_FILE_BASIC_INFO:\n                    infoRecord = smb.SMBSetFileBasicInfo(data)\n                    # Creation time won't be set,  the other ones we play with.\n                    atime = infoRecord['LastAccessTime']\n                    if atime == 0:\n                        atime = -1\n                    else:\n                        atime = getUnixTime(atime)\n                    mtime = infoRecord['LastWriteTime']\n                    if mtime == 0:\n                        mtime = -1\n                    else:\n                        mtime = getUnixTime(mtime)\n                    os.utime(fileName, (atime, mtime))\n                elif informationLevel == smb.SMB_SET_FILE_END_OF_FILE_INFO:\n                    fileHandle = connData['OpenedFiles'][setFileInfoParameters['FID']]['FileHandle']\n                    infoRecord = smb.SMBSetFileEndOfFileInfo(data)\n                    if infoRecord['EndOfFile'] > 0:\n                        os.lseek(fileHandle, infoRecord['EndOfFile'] - 1, 0)\n                        os.write(fileHandle, b'\\x00')\n                else:\n                    smbServer.log('Unknown level for set file info! 0x%x' % setFileInfoParameters['InformationLevel'],\n                                  logging.ERROR)\n                    # UNSUPPORTED\n                    errorCode = STATUS_NOT_SUPPORTED\n            else:\n                errorCode = STATUS_NO_SUCH_FILE\n\n            if errorCode == STATUS_SUCCESS:\n                respParameters = smb.SMBSetFileInformationResponse_Parameters()\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        smbServer.setConnectionData(connId, connData)\n\n        return respSetup, respParameters, respData, errorCode\n\n    @staticmethod\n    def queryFileInformation(connId, smbServer, recvPacket, parameters, data, maxDataCount=0):\n        connData = smbServer.getConnectionData(connId)\n\n        respSetup = b''\n        respParameters = b''\n        respData = b''\n\n        queryFileInfoParameters = smb.SMBQueryFileInformation_Parameters(parameters)\n\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            if queryFileInfoParameters['FID'] in connData['OpenedFiles']:\n                fileName = connData['OpenedFiles'][queryFileInfoParameters['FID']]['FileName']\n\n                infoRecord, errorCode = queryFileInformation('', fileName, queryFileInfoParameters['InformationLevel'])\n\n                if infoRecord is not None:\n                    respParameters = smb.SMBQueryFileInformationResponse_Parameters()\n                    respData = infoRecord\n            else:\n                errorCode = STATUS_INVALID_HANDLE\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        smbServer.setConnectionData(connId, connData)\n\n        return respSetup, respParameters, respData, errorCode\n\n    @staticmethod\n    def queryPathInformation(connId, smbServer, recvPacket, parameters, data, maxDataCount=0):\n        connData = smbServer.getConnectionData(connId)\n\n        respSetup = b''\n        respParameters = b''\n        respData = b''\n        errorCode = 0\n\n        queryPathInfoParameters = smb.SMBQueryPathInformation_Parameters(flags=recvPacket['Flags2'], data=parameters)\n\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            path = connData['ConnectedShares'][recvPacket['Tid']]['path']\n            try:\n                infoRecord, errorCode = queryPathInformation(path, decodeSMBString(recvPacket['Flags2'],\n                                                                                   queryPathInfoParameters['FileName']),\n                                                             queryPathInfoParameters['InformationLevel'])\n            except Exception as e:\n                smbServer.log(\"queryPathInformation: %s\" % e, logging.ERROR)\n\n            if infoRecord is not None:\n                respParameters = smb.SMBQueryPathInformationResponse_Parameters()\n                respData = infoRecord\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        smbServer.setConnectionData(connId, connData)\n\n        return respSetup, respParameters, respData, errorCode\n\n    @staticmethod\n    def queryFsInformation(connId, smbServer, recvPacket, parameters, data, maxDataCount=0):\n        connData = smbServer.getConnectionData(connId)\n        errorCode = 0\n        # Get the Tid associated\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            data = queryFsInformation(connData['ConnectedShares'][recvPacket['Tid']]['path'], '',\n                                      struct.unpack('<H', parameters)[0], pktFlags=recvPacket['Flags2'])\n\n        smbServer.setConnectionData(connId, connData)\n\n        return b'', b'', data, errorCode\n\n    @staticmethod\n    def findNext2(connId, smbServer, recvPacket, parameters, data, maxDataCount):\n        connData = smbServer.getConnectionData(connId)\n\n        respSetup = b''\n        respParameters = b''\n        respData = b''\n        errorCode = STATUS_SUCCESS\n        findNext2Parameters = smb.SMBFindNext2_Parameters(flags=recvPacket['Flags2'], data=parameters)\n\n        sid = findNext2Parameters['SID']\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            if sid in connData['SIDs']:\n                searchResult = connData['SIDs'][sid]\n                respParameters = smb.SMBFindNext2Response_Parameters()\n                endOfSearch = 1\n                searchCount = 1\n                totalData = 0\n                for i in enumerate(searchResult):\n                    data = i[1].getData()\n                    lenData = len(data)\n                    if (totalData + lenData) >= maxDataCount or (i[0] + 1) >= findNext2Parameters['SearchCount']:\n                        # We gotta stop here and continue on a find_next2\n                        endOfSearch = 0\n                        connData['SIDs'][sid] = searchResult[i[0]:]\n                        respParameters['LastNameOffset'] = totalData\n                        break\n                    else:\n                        searchCount += 1\n                        respData += data\n                        totalData += lenData\n\n                # Have we reached the end of the search or still stuff to send?\n                if endOfSearch > 0:\n                    # Let's remove the SID from our ConnData\n                    del (connData['SIDs'][sid])\n\n                respParameters['EndOfSearch'] = endOfSearch\n                respParameters['SearchCount'] = searchCount\n            else:\n                errorCode = STATUS_INVALID_HANDLE\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        smbServer.setConnectionData(connId, connData)\n\n        return respSetup, respParameters, respData, errorCode\n\n    @staticmethod\n    def findFirst2(connId, smbServer, recvPacket, parameters, data, maxDataCount):\n        connData = smbServer.getConnectionData(connId)\n\n        respSetup = b''\n        respParameters = b''\n        respData = b''\n        findFirst2Parameters = smb.SMBFindFirst2_Parameters(recvPacket['Flags2'], data=parameters)\n\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            path = connData['ConnectedShares'][recvPacket['Tid']]['path']\n\n            searchResult, searchCount, errorCode = findFirst2(path,\n                                                              decodeSMBString(recvPacket['Flags2'],\n                                                                              findFirst2Parameters['FileName']),\n                                                              findFirst2Parameters['InformationLevel'],\n                                                              findFirst2Parameters['SearchAttributes'],\n                                                              pktFlags=recvPacket['Flags2'])\n\n            respParameters = smb.SMBFindFirst2Response_Parameters()\n            endOfSearch = 1\n            sid = 0x80  # default SID\n            searchCount = 0\n            totalData = 0\n            for i in enumerate(searchResult):\n                # i[1].dump()\n                data = i[1].getData()\n                lenData = len(data)\n                if (totalData + lenData) >= maxDataCount or (i[0] + 1) > findFirst2Parameters['SearchCount']:\n                    # We gotta stop here and continue on a find_next2\n                    endOfSearch = 0\n                    # Simple way to generate a fid\n                    if len(connData['SIDs']) == 0:\n                        sid = 1\n                    else:\n                        sid = list(connData['SIDs'].keys())[-1] + 1\n                    # Store the remaining search results in the ConnData SID\n                    connData['SIDs'][sid] = searchResult[i[0]:]\n                    respParameters['LastNameOffset'] = totalData\n                    break\n                else:\n                    searchCount += 1\n                    respData += data\n\n                    padLen = (8 - (lenData % 8)) % 8\n                    respData += b'\\xaa' * padLen\n                    totalData += lenData + padLen\n\n            respParameters['SID'] = sid\n            respParameters['EndOfSearch'] = endOfSearch\n            respParameters['SearchCount'] = searchCount\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        smbServer.setConnectionData(connId, connData)\n\n        return respSetup, respParameters, respData, errorCode\n\n\n# Here we implement the commands handlers\nclass SMBCommands:\n\n    @staticmethod\n    def smbTransaction(connId, smbServer, SMBCommand, recvPacket, transCommands):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(recvPacket['Command'])\n\n        transParameters = smb.SMBTransaction_Parameters(SMBCommand['Parameters'])\n\n        # Do the stuff\n        if transParameters['ParameterCount'] != transParameters['TotalParameterCount']:\n            # TODO: Handle partial parameters\n            raise Exception(\"Unsupported partial parameters in TRANSACT2!\")\n        else:\n            transData = smb.SMBTransaction_SData(flags=recvPacket['Flags2'])\n            # Standard says servers shouldn't trust Parameters and Data comes\n            # in order, so we have to parse the offsets, ugly\n\n            paramCount = transParameters['ParameterCount']\n            transData['Trans_ParametersLength'] = paramCount\n            dataCount = transParameters['DataCount']\n            transData['Trans_DataLength'] = dataCount\n            transData.fromString(SMBCommand['Data'])\n            if transParameters['ParameterOffset'] > 0:\n                paramOffset = transParameters['ParameterOffset'] - 63 - transParameters['SetupLength']\n                transData['Trans_Parameters'] = SMBCommand['Data'][paramOffset:paramOffset + paramCount]\n            else:\n                transData['Trans_Parameters'] = b''\n\n            if transParameters['DataOffset'] > 0:\n                dataOffset = transParameters['DataOffset'] - 63 - transParameters['SetupLength']\n                transData['Trans_Data'] = SMBCommand['Data'][dataOffset:dataOffset + dataCount]\n            else:\n                transData['Trans_Data'] = b''\n\n            # Call the handler for this TRANSACTION\n            if transParameters['SetupCount'] == 0:\n                # No subcommand, let's play with the Name\n                command = decodeSMBString(recvPacket['Flags2'], transData['Name'])\n            else:\n                command = struct.unpack('<H', transParameters['Setup'][:2])[0]\n\n            if command in transCommands:\n                # Call the TRANS subcommand\n                setup = b''\n                parameters = b''\n                data = b''\n                try:\n                    setup, parameters, data, errorCode = transCommands[command](connId,\n                                                                                smbServer,\n                                                                                recvPacket,\n                                                                                transData['Trans_Parameters'],\n                                                                                transData['Trans_Data'],\n                                                                                transParameters['MaxDataCount'])\n                except Exception as e:\n                    # print 'Transaction: %s' % e,e\n                    smbServer.log('Transaction: (%r,%s)' % (command, e), logging.ERROR)\n                    errorCode = STATUS_ACCESS_DENIED\n                    # raise\n\n                if setup == b'' and parameters == b'' and data == b'':\n                    # Something wen't wrong\n                    respParameters = b''\n                    respData = b''\n                else:\n                    # Build the answer\n                    if hasattr(data, 'getData'):\n                        data = data.getData()\n                    remainingData = len(data)\n                    if hasattr(parameters, 'getData'):\n                        parameters = parameters.getData()\n                    remainingParameters = len(parameters)\n                    commands = []\n                    dataDisplacement = 0\n                    while remainingData > 0 or remainingParameters > 0:\n                        respSMBCommand = smb.SMBCommand(recvPacket['Command'])\n                        respParameters = smb.SMBTransactionResponse_Parameters()\n                        respData = smb.SMBTransaction2Response_Data()\n\n                        respParameters['TotalParameterCount'] = len(parameters)\n                        respParameters['ParameterCount'] = len(parameters)\n                        respData['Trans_ParametersLength'] = len(parameters)\n                        respParameters['TotalDataCount'] = len(data)\n                        respParameters['DataDisplacement'] = dataDisplacement\n\n                        # TODO: Do the same for parameters\n                        if len(data) > transParameters['MaxDataCount']:\n                            # Answer doesn't fit in this packet\n                            LOG.debug(\"Lowering answer from %d to %d\" % (len(data), transParameters['MaxDataCount']))\n                            respParameters['DataCount'] = transParameters['MaxDataCount']\n                        else:\n                            respParameters['DataCount'] = len(data)\n\n                        respData['Trans_DataLength'] = respParameters['DataCount']\n                        respParameters['SetupCount'] = len(setup)\n                        respParameters['Setup'] = setup\n                        # TODO: Make sure we're calculating the pad right\n                        if len(parameters) > 0:\n                            # padLen = 4 - (55 + len(setup)) % 4\n                            padLen = (4 - (55 + len(setup)) % 4) % 4\n                            padBytes = b'\\xFF' * padLen\n                            respData['Pad1'] = padBytes\n                            respParameters['ParameterOffset'] = 55 + len(setup) + padLen\n                        else:\n                            padLen = 0\n                            respParameters['ParameterOffset'] = 0\n                            respData['Pad1'] = b''\n\n                        if len(data) > 0:\n                            # pad2Len = 4 - (55 + len(setup) + padLen + len(parameters)) % 4\n                            pad2Len = (4 - (55 + len(setup) + padLen + len(parameters)) % 4) % 4\n                            respData['Pad2'] = b'\\xFF' * pad2Len\n                            respParameters['DataOffset'] = 55 + len(setup) + padLen + len(parameters) + pad2Len\n                        else:\n                            respParameters['DataOffset'] = 0\n                            respData['Pad2'] = b''\n\n                        respData['Trans_Parameters'] = parameters[:respParameters['ParameterCount']]\n                        respData['Trans_Data'] = data[:respParameters['DataCount']]\n                        respSMBCommand['Parameters'] = respParameters\n                        respSMBCommand['Data'] = respData\n\n                        data = data[respParameters['DataCount']:]\n                        remainingData -= respParameters['DataCount']\n                        dataDisplacement += respParameters['DataCount'] + 1\n\n                        parameters = parameters[respParameters['ParameterCount']:]\n                        remainingParameters -= respParameters['ParameterCount']\n                        commands.append(respSMBCommand)\n\n                    smbServer.setConnectionData(connId, connData)\n                    return commands, None, errorCode\n\n            else:\n                smbServer.log(\"Unsupported Transact command %r\" % command, logging.ERROR)\n                respParameters = b''\n                respData = b''\n                errorCode = STATUS_NOT_IMPLEMENTED\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smbNTTransact(connId, smbServer, SMBCommand, recvPacket, transCommands):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(recvPacket['Command'])\n\n        NTTransParameters = smb.SMBNTTransaction_Parameters(SMBCommand['Parameters'])\n        # Do the stuff\n        if NTTransParameters['ParameterCount'] != NTTransParameters['TotalParameterCount']:\n            # TODO: Handle partial parameters\n            raise Exception(\"Unsupported partial parameters in NTTrans!\")\n        else:\n            NTTransData = smb.SMBNTTransaction_Data()\n            # Standard says servers shouldn't trust Parameters and Data comes\n            # in order, so we have to parse the offsets, ugly\n\n            paramCount = NTTransParameters['ParameterCount']\n            NTTransData['NT_Trans_ParametersLength'] = paramCount\n            dataCount = NTTransParameters['DataCount']\n            NTTransData['NT_Trans_DataLength'] = dataCount\n\n            if NTTransParameters['ParameterOffset'] > 0:\n                paramOffset = NTTransParameters['ParameterOffset'] - 73 - NTTransParameters['SetupLength']\n                NTTransData['NT_Trans_Parameters'] = SMBCommand['Data'][paramOffset:paramOffset + paramCount]\n            else:\n                NTTransData['NT_Trans_Parameters'] = b''\n\n            if NTTransParameters['DataOffset'] > 0:\n                dataOffset = NTTransParameters['DataOffset'] - 73 - NTTransParameters['SetupLength']\n                NTTransData['NT_Trans_Data'] = SMBCommand['Data'][dataOffset:dataOffset + dataCount]\n            else:\n                NTTransData['NT_Trans_Data'] = b''\n\n            # Call the handler for this TRANSACTION\n            command = NTTransParameters['Function']\n            if command in transCommands:\n                # Call the NT TRANS subcommand\n                setup = b''\n                parameters = b''\n                data = b''\n                try:\n                    setup, parameters, data, errorCode = transCommands[command](connId,\n                                                                                smbServer,\n                                                                                recvPacket,\n                                                                                NTTransData['NT_Trans_Parameters'],\n                                                                                NTTransData['NT_Trans_Data'],\n                                                                                NTTransParameters['MaxDataCount'])\n                except Exception as e:\n                    smbServer.log('NTTransaction: (0x%x,%s)' % (command, e), logging.ERROR)\n                    errorCode = STATUS_ACCESS_DENIED\n                    # raise\n\n                if setup == b'' and parameters == b'' and data == b'':\n                    # Something wen't wrong\n                    respParameters = b''\n                    respData = b''\n                    if errorCode == STATUS_SUCCESS:\n                        errorCode = STATUS_ACCESS_DENIED\n                else:\n                    # Build the answer\n                    if hasattr(data, 'getData'):\n                        data = data.getData()\n                    remainingData = len(data)\n                    if hasattr(parameters, 'getData'):\n                        parameters = parameters.getData()\n                    remainingParameters = len(parameters)\n                    commands = []\n                    dataDisplacement = 0\n                    while remainingData > 0 or remainingParameters > 0:\n                        respSMBCommand = smb.SMBCommand(recvPacket['Command'])\n                        respParameters = smb.SMBNTTransactionResponse_Parameters()\n                        respData = smb.SMBNTTransactionResponse_Data()\n\n                        respParameters['TotalParameterCount'] = len(parameters)\n                        respParameters['ParameterCount'] = len(parameters)\n                        respData['Trans_ParametersLength'] = len(parameters)\n                        respParameters['TotalDataCount'] = len(data)\n                        respParameters['DataDisplacement'] = dataDisplacement\n                        # TODO: Do the same for parameters\n                        if len(data) > NTTransParameters['MaxDataCount']:\n                            # Answer doesn't fit in this packet\n                            LOG.debug(\"Lowering answer from %d to %d\" % (len(data), NTTransParameters['MaxDataCount']))\n                            respParameters['DataCount'] = NTTransParameters['MaxDataCount']\n                        else:\n                            respParameters['DataCount'] = len(data)\n\n                        respData['NT_Trans_DataLength'] = respParameters['DataCount']\n                        respParameters['SetupCount'] = len(setup)\n                        respParameters['Setup'] = setup\n                        # TODO: Make sure we're calculating the pad right\n                        if len(parameters) > 0:\n                            # padLen = 4 - (71 + len(setup)) % 4\n                            padLen = (4 - (73 + len(setup)) % 4) % 4\n                            padBytes = b'\\xFF' * padLen\n                            respData['Pad1'] = padBytes\n                            respParameters['ParameterOffset'] = 73 + len(setup) + padLen\n                        else:\n                            padLen = 0\n                            respParameters['ParameterOffset'] = 0\n                            respData['Pad1'] = b''\n\n                        if len(data) > 0:\n                            # pad2Len = 4 - (71 + len(setup) + padLen + len(parameters)) % 4\n                            pad2Len = (4 - (73 + len(setup) + padLen + len(parameters)) % 4) % 4\n                            respData['Pad2'] = b'\\xFF' * pad2Len\n                            respParameters['DataOffset'] = 73 + len(setup) + padLen + len(parameters) + pad2Len\n                        else:\n                            respParameters['DataOffset'] = 0\n                            respData['Pad2'] = b''\n\n                        respData['NT_Trans_Parameters'] = parameters[:respParameters['ParameterCount']]\n                        respData['NT_Trans_Data'] = data[:respParameters['DataCount']]\n                        respSMBCommand['Parameters'] = respParameters\n                        respSMBCommand['Data'] = respData\n\n                        data = data[respParameters['DataCount']:]\n                        remainingData -= respParameters['DataCount']\n                        dataDisplacement += respParameters['DataCount'] + 1\n\n                        parameters = parameters[respParameters['ParameterCount']:]\n                        remainingParameters -= respParameters['ParameterCount']\n                        commands.append(respSMBCommand)\n\n                    smbServer.setConnectionData(connId, connData)\n                    return commands, None, errorCode\n\n            else:\n                # smbServer.log(\"Unsupported NTTransact command 0x%x\" % command, logging.ERROR)\n                respParameters = b''\n                respData = b''\n                errorCode = STATUS_NOT_IMPLEMENTED\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smbTransaction2(connId, smbServer, SMBCommand, recvPacket, transCommands):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(recvPacket['Command'])\n\n        trans2Parameters = smb.SMBTransaction2_Parameters(SMBCommand['Parameters'])\n\n        # Do the stuff\n        if trans2Parameters['ParameterCount'] != trans2Parameters['TotalParameterCount']:\n            # TODO: Handle partial parameters\n            # print \"Unsupported partial parameters in TRANSACT2!\"\n            raise Exception(\"Unsupported partial parameters in TRANSACT2!\")\n        else:\n            trans2Data = smb.SMBTransaction2_Data()\n            # Standard says servers shouldn't trust Parameters and Data comes\n            # in order, so we have to parse the offsets, ugly\n\n            paramCount = trans2Parameters['ParameterCount']\n            trans2Data['Trans_ParametersLength'] = paramCount\n            dataCount = trans2Parameters['DataCount']\n            trans2Data['Trans_DataLength'] = dataCount\n\n            if trans2Parameters['ParameterOffset'] > 0:\n                paramOffset = trans2Parameters['ParameterOffset'] - 63 - trans2Parameters['SetupLength']\n                trans2Data['Trans_Parameters'] = SMBCommand['Data'][paramOffset:paramOffset + paramCount]\n            else:\n                trans2Data['Trans_Parameters'] = b''\n\n            if trans2Parameters['DataOffset'] > 0:\n                dataOffset = trans2Parameters['DataOffset'] - 63 - trans2Parameters['SetupLength']\n                trans2Data['Trans_Data'] = SMBCommand['Data'][dataOffset:dataOffset + dataCount]\n            else:\n                trans2Data['Trans_Data'] = b''\n\n            # Call the handler for this TRANSACTION\n            command = struct.unpack('<H', trans2Parameters['Setup'])[0]\n            if command in transCommands:\n                # Call the TRANS2 subcommand\n                try:\n                    setup, parameters, data, errorCode = transCommands[command](connId,\n                                                                                smbServer,\n                                                                                recvPacket,\n                                                                                trans2Data['Trans_Parameters'],\n                                                                                trans2Data['Trans_Data'],\n                                                                                trans2Parameters['MaxDataCount'])\n                except Exception as e:\n                    smbServer.log('Transaction2: (0x%x,%s)' % (command, e), logging.ERROR)\n                    # import traceback\n                    # traceback.print_exc()\n                    raise\n\n                if setup == b'' and parameters == b'' and data == b'':\n                    # Something wen't wrong\n                    respParameters = b''\n                    respData = b''\n                else:\n                    # Build the answer\n                    if hasattr(data, 'getData'):\n                        data = data.getData()\n                    remainingData = len(data)\n                    if hasattr(parameters, 'getData'):\n                        parameters = parameters.getData()\n                    remainingParameters = len(parameters)\n                    commands = []\n                    dataDisplacement = 0\n                    while remainingData > 0 or remainingParameters > 0:\n                        respSMBCommand = smb.SMBCommand(recvPacket['Command'])\n                        respParameters = smb.SMBTransaction2Response_Parameters()\n                        respData = smb.SMBTransaction2Response_Data()\n\n                        respParameters['TotalParameterCount'] = len(parameters)\n                        respParameters['ParameterCount'] = len(parameters)\n                        respData['Trans_ParametersLength'] = len(parameters)\n                        respParameters['TotalDataCount'] = len(data)\n                        respParameters['DataDisplacement'] = dataDisplacement\n                        # TODO: Do the same for parameters\n                        if len(data) > trans2Parameters['MaxDataCount']:\n                            # Answer doesn't fit in this packet\n                            LOG.debug(\"Lowering answer from %d to %d\" % (len(data), trans2Parameters['MaxDataCount']))\n                            respParameters['DataCount'] = trans2Parameters['MaxDataCount']\n                        else:\n                            respParameters['DataCount'] = len(data)\n\n                        respData['Trans_DataLength'] = respParameters['DataCount']\n                        respParameters['SetupCount'] = len(setup)\n                        respParameters['Setup'] = setup\n                        # TODO: Make sure we're calculating the pad right\n                        if len(parameters) > 0:\n                            # padLen = 4 - (55 + len(setup)) % 4\n                            padLen = (4 - (55 + len(setup)) % 4) % 4\n                            padBytes = b'\\xFF' * padLen\n                            respData['Pad1'] = padBytes\n                            respParameters['ParameterOffset'] = 55 + len(setup) + padLen\n                        else:\n                            padLen = 0\n                            respParameters['ParameterOffset'] = 0\n                            respData['Pad1'] = b''\n\n                        if len(data) > 0:\n                            # pad2Len = 4 - (55 + len(setup) + padLen + len(parameters)) % 4\n                            pad2Len = (4 - (55 + len(setup) + padLen + len(parameters)) % 4) % 4\n                            respData['Pad2'] = b'\\xFF' * pad2Len\n                            respParameters['DataOffset'] = 55 + len(setup) + padLen + len(parameters) + pad2Len\n                        else:\n                            respParameters['DataOffset'] = 0\n                            respData['Pad2'] = b''\n\n                        respData['Trans_Parameters'] = parameters[:respParameters['ParameterCount']]\n                        respData['Trans_Data'] = data[:respParameters['DataCount']]\n                        respSMBCommand['Parameters'] = respParameters\n                        respSMBCommand['Data'] = respData\n\n                        data = data[respParameters['DataCount']:]\n                        remainingData -= respParameters['DataCount']\n                        dataDisplacement += respParameters['DataCount'] + 1\n\n                        parameters = parameters[respParameters['ParameterCount']:]\n                        remainingParameters -= respParameters['ParameterCount']\n                        commands.append(respSMBCommand)\n\n                    smbServer.setConnectionData(connId, connData)\n                    return commands, None, errorCode\n\n            else:\n                smbServer.log(\"Unsupported Transact/2 command 0x%x\" % command, logging.ERROR)\n                respParameters = b''\n                respData = b''\n                errorCode = STATUS_NOT_IMPLEMENTED\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smbComLockingAndX(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_LOCKING_ANDX)\n        respParameters = b''\n        respData = b''\n\n        # I'm actually doing nothing.. just make MacOS happy ;)\n        errorCode = STATUS_SUCCESS\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smbComClose(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_CLOSE)\n        respParameters = b''\n        respData = b''\n\n        comClose = smb.SMBClose_Parameters(SMBCommand['Parameters'])\n\n        if comClose['FID'] in connData['OpenedFiles']:\n            errorCode = STATUS_SUCCESS\n            fileHandle = connData['OpenedFiles'][comClose['FID']]['FileHandle']\n            try:\n                if fileHandle == PIPE_FILE_DESCRIPTOR:\n                    connData['OpenedFiles'][comClose['FID']]['Socket'].close()\n                elif fileHandle != VOID_FILE_DESCRIPTOR:\n                    os.close(fileHandle)\n            except Exception as e:\n                smbServer.log(\"comClose %s\" % e, logging.ERROR)\n                errorCode = STATUS_ACCESS_DENIED\n            else:\n                # Check if the file was marked for removal\n                if connData['OpenedFiles'][comClose['FID']]['DeleteOnClose'] is True:\n                    try:\n                        os.remove(connData['OpenedFiles'][comClose['FID']]['FileName'])\n                    except Exception as e:\n                        smbServer.log(\"comClose %s\" % e, logging.ERROR)\n                        errorCode = STATUS_ACCESS_DENIED\n                del (connData['OpenedFiles'][comClose['FID']])\n        else:\n            errorCode = STATUS_INVALID_HANDLE\n\n        if errorCode > 0:\n            respParameters = b''\n            respData = b''\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smbComWrite(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_WRITE)\n        respParameters = smb.SMBWriteResponse_Parameters()\n        respData = b''\n\n        comWriteParameters = smb.SMBWrite_Parameters(SMBCommand['Parameters'])\n        comWriteData = smb.SMBWrite_Data(SMBCommand['Data'])\n\n        if comWriteParameters['Fid'] in connData['OpenedFiles']:\n            fileHandle = connData['OpenedFiles'][comWriteParameters['Fid']]['FileHandle']\n            errorCode = STATUS_SUCCESS\n            try:\n                if fileHandle != PIPE_FILE_DESCRIPTOR:\n                    # TODO: Handle big size files\n                    # If we're trying to write past the file end we just skip the write call (Vista does this)\n                    if os.lseek(fileHandle, 0, 2) >= comWriteParameters['Offset']:\n                        os.lseek(fileHandle, comWriteParameters['Offset'], 0)\n                        os.write(fileHandle, comWriteData['Data'])\n                else:\n                    sock = connData['OpenedFiles'][comWriteParameters['Fid']]['Socket']\n                    sock.send(comWriteData['Data'])\n                respParameters['Count'] = comWriteParameters['Count']\n            except Exception as e:\n                smbServer.log('smbComWrite: %s' % e, logging.ERROR)\n                errorCode = STATUS_ACCESS_DENIED\n        else:\n            errorCode = STATUS_INVALID_HANDLE\n\n        if errorCode > 0:\n            respParameters = b''\n            respData = b''\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smbComFlush(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_FLUSH)\n        respParameters = b''\n        respData = b''\n\n        comFlush = smb.SMBFlush_Parameters(SMBCommand['Parameters'])\n\n        if comFlush['FID'] in connData['OpenedFiles']:\n            errorCode = STATUS_SUCCESS\n            fileHandle = connData['OpenedFiles'][comFlush['FID']]['FileHandle']\n            try:\n                os.fsync(fileHandle)\n            except Exception as e:\n                smbServer.log(\"comFlush %s\" % e, logging.ERROR)\n                errorCode = STATUS_ACCESS_DENIED\n        else:\n            errorCode = STATUS_INVALID_HANDLE\n\n        if errorCode > 0:\n            respParameters = b''\n            respData = b''\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smbComCreateDirectory(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_CREATE_DIRECTORY)\n        respParameters = b''\n        respData = b''\n\n        comCreateDirectoryData = smb.SMBCreateDirectory_Data(flags=recvPacket['Flags2'], data=SMBCommand['Data'])\n\n        # Get the Tid associated\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            errorCode = STATUS_SUCCESS\n            path = connData['ConnectedShares'][recvPacket['Tid']]['path']\n            fileName = os.path.normpath(\n                decodeSMBString(recvPacket['Flags2'], comCreateDirectoryData['DirectoryName']).replace('\\\\', '/'))\n            if len(fileName) > 0:\n                if fileName[0] == '/' or fileName[0] == '\\\\':\n                    # strip leading '/'\n                    fileName = fileName[1:]\n            pathName = os.path.join(path, fileName)\n            if os.path.exists(pathName):\n                errorCode = STATUS_OBJECT_NAME_COLLISION\n\n            # TODO: More checks here in the future.. Specially when we support\n            # user access\n            else:\n                try:\n                    os.mkdir(pathName)\n                except Exception as e:\n                    smbServer.log(\"smbComCreateDirectory: %s\" % e, logging.ERROR)\n                    errorCode = STATUS_ACCESS_DENIED\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        if errorCode > 0:\n            respParameters = b''\n            respData = b''\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smbComRename(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_RENAME)\n        respParameters = b''\n        respData = b''\n\n        comRenameData = smb.SMBRename_Data(flags=recvPacket['Flags2'], data=SMBCommand['Data'])\n        # Get the Tid associated\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            errorCode = STATUS_SUCCESS\n            path = connData['ConnectedShares'][recvPacket['Tid']]['path']\n            oldFileName = os.path.normpath(\n                decodeSMBString(recvPacket['Flags2'], comRenameData['OldFileName']).replace('\\\\', '/'))\n            newFileName = os.path.normpath(\n                decodeSMBString(recvPacket['Flags2'], comRenameData['NewFileName']).replace('\\\\', '/'))\n            if len(oldFileName) > 0 and (oldFileName[0] == '/' or oldFileName[0] == '\\\\'):\n                # strip leading '/'\n                oldFileName = oldFileName[1:]\n            oldPathName = os.path.join(path, oldFileName)\n            if len(newFileName) > 0 and (newFileName[0] == '/' or newFileName[0] == '\\\\'):\n                # strip leading '/'\n                newFileName = newFileName[1:]\n            newPathName = os.path.join(path, newFileName)\n\n            if os.path.exists(oldPathName) is not True:\n                errorCode = STATUS_NO_SUCH_FILE\n\n            # TODO: More checks here in the future.. Specially when we support\n            # user access\n            else:\n                try:\n                    os.rename(oldPathName, newPathName)\n                except OSError as e:\n                    smbServer.log(\"smbComRename: %s\" % e, logging.ERROR)\n                    errorCode = STATUS_ACCESS_DENIED\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        if errorCode > 0:\n            respParameters = b''\n            respData = b''\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smbComDelete(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_DELETE)\n        respParameters = b''\n        respData = b''\n\n        comDeleteData = smb.SMBDelete_Data(flags=recvPacket['Flags2'], data=SMBCommand['Data'])\n\n        # Get the Tid associated\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            errorCode = STATUS_SUCCESS\n            path = connData['ConnectedShares'][recvPacket['Tid']]['path']\n            fileName = os.path.normpath(\n                decodeSMBString(recvPacket['Flags2'], comDeleteData['FileName']).replace('\\\\', '/'))\n            if len(fileName) > 0 and (fileName[0] == '/' or fileName[0] == '\\\\'):\n                # strip leading '/'\n                fileName = fileName[1:]\n            pathName = os.path.join(path, fileName)\n            if os.path.exists(pathName) is not True:\n                errorCode = STATUS_NO_SUCH_FILE\n\n            # TODO: More checks here in the future.. Specially when we support\n            # user access\n            else:\n                try:\n                    os.remove(pathName)\n                except OSError as e:\n                    smbServer.log(\"smbComDelete: %s\" % e, logging.ERROR)\n                    errorCode = STATUS_ACCESS_DENIED\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        if errorCode > 0:\n            respParameters = b''\n            respData = b''\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smbComDeleteDirectory(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_DELETE_DIRECTORY)\n        respParameters = b''\n        respData = b''\n\n        comDeleteDirectoryData = smb.SMBDeleteDirectory_Data(flags=recvPacket['Flags2'], data=SMBCommand['Data'])\n\n        # Get the Tid associated\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            errorCode = STATUS_SUCCESS\n            path = connData['ConnectedShares'][recvPacket['Tid']]['path']\n            fileName = os.path.normpath(\n                decodeSMBString(recvPacket['Flags2'], comDeleteDirectoryData['DirectoryName']).replace('\\\\', '/'))\n            if len(fileName) > 0 and (fileName[0] == '/' or fileName[0] == '\\\\'):\n                # strip leading '/'\n                fileName = fileName[1:]\n            pathName = os.path.join(path, fileName)\n            if os.path.exists(pathName) is not True:\n                errorCode = STATUS_NO_SUCH_FILE\n\n            # TODO: More checks here in the future.. Specially when we support\n            # user access\n            else:\n                try:\n                    os.rmdir(pathName)\n                except OSError as e:\n                    smbServer.log(\"smbComDeleteDirectory: %s\" % e, logging.ERROR)\n                    if e.errno == errno.ENOTEMPTY:\n                        errorCode = STATUS_DIRECTORY_NOT_EMPTY\n                    else:\n                        errorCode = STATUS_ACCESS_DENIED\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        if errorCode > 0:\n            respParameters = b''\n            respData = b''\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smbComWriteAndX(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_WRITE_ANDX)\n        respParameters = smb.SMBWriteAndXResponse_Parameters()\n        respData = b''\n\n        if SMBCommand['WordCount'] == 0x0C:\n            writeAndX = smb.SMBWriteAndX_Parameters_Short(SMBCommand['Parameters'])\n            writeAndXData = smb.SMBWriteAndX_Data_Short()\n        else:\n            writeAndX = smb.SMBWriteAndX_Parameters(SMBCommand['Parameters'])\n            writeAndXData = smb.SMBWriteAndX_Data()\n        writeAndXData['DataLength'] = writeAndX['DataLength']\n        writeAndXData['DataOffset'] = writeAndX['DataOffset']\n        writeAndXData.fromString(SMBCommand['Data'])\n\n        if writeAndX['Fid'] in connData['OpenedFiles']:\n            fileHandle = connData['OpenedFiles'][writeAndX['Fid']]['FileHandle']\n            errorCode = STATUS_SUCCESS\n            try:\n                if fileHandle != PIPE_FILE_DESCRIPTOR:\n                    offset = writeAndX['Offset']\n                    if 'HighOffset' in writeAndX.fields:\n                        offset += (writeAndX['HighOffset'] << 32)\n                    # If we're trying to write past the file end we just skip the write call (Vista does this)\n                    if os.lseek(fileHandle, 0, 2) >= offset:\n                        os.lseek(fileHandle, offset, 0)\n                        os.write(fileHandle, writeAndXData['Data'])\n                else:\n                    sock = connData['OpenedFiles'][writeAndX['Fid']]['Socket']\n                    sock.send(writeAndXData['Data'])\n\n                respParameters['Count'] = writeAndX['DataLength']\n                respParameters['Available'] = 0xff\n            except Exception as e:\n                smbServer.log('smbComWriteAndx: %s' % e, logging.ERROR)\n                errorCode = STATUS_ACCESS_DENIED\n        else:\n            errorCode = STATUS_INVALID_HANDLE\n\n        if errorCode > 0:\n            respParameters = b''\n            respData = b''\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smbComRead(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_READ)\n        respParameters = smb.SMBReadResponse_Parameters()\n        respData = smb.SMBReadResponse_Data()\n\n        comReadParameters = smb.SMBRead_Parameters(SMBCommand['Parameters'])\n\n        if comReadParameters['Fid'] in connData['OpenedFiles']:\n            fileHandle = connData['OpenedFiles'][comReadParameters['Fid']]['FileHandle']\n            errorCode = STATUS_SUCCESS\n            try:\n                if fileHandle != PIPE_FILE_DESCRIPTOR:\n                    # TODO: Handle big size files\n                    os.lseek(fileHandle, comReadParameters['Offset'], 0)\n                    content = os.read(fileHandle, comReadParameters['Count'])\n                else:\n                    sock = connData['OpenedFiles'][comReadParameters['Fid']]['Socket']\n                    content = sock.recv(comReadParameters['Count'])\n                respParameters['Count'] = len(content)\n                respData['DataLength'] = len(content)\n                respData['Data'] = content\n            except Exception as e:\n                smbServer.log('smbComRead: %s ' % e, logging.ERROR)\n                errorCode = STATUS_ACCESS_DENIED\n        else:\n            errorCode = STATUS_INVALID_HANDLE\n\n        if errorCode > 0:\n            respParameters = b''\n            respData = b''\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smbComReadAndX(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_READ_ANDX)\n        respParameters = smb.SMBReadAndXResponse_Parameters()\n        respData = b''\n\n        if SMBCommand['WordCount'] == 0x0A:\n            readAndX = smb.SMBReadAndX_Parameters2(SMBCommand['Parameters'])\n        else:\n            readAndX = smb.SMBReadAndX_Parameters(SMBCommand['Parameters'])\n\n        if readAndX['Fid'] in connData['OpenedFiles']:\n            fileHandle = connData['OpenedFiles'][readAndX['Fid']]['FileHandle']\n            errorCode = 0\n            try:\n                if fileHandle != PIPE_FILE_DESCRIPTOR:\n                    offset = readAndX['Offset']\n                    if 'HighOffset' in readAndX.fields:\n                        offset += (readAndX['HighOffset'] << 32)\n                    os.lseek(fileHandle, offset, 0)\n                    content = os.read(fileHandle, readAndX['MaxCount'])\n                else:\n                    sock = connData['OpenedFiles'][readAndX['Fid']]['Socket']\n                    content = sock.recv(readAndX['MaxCount'])\n                respParameters['Remaining'] = 0xffff\n                respParameters['DataCount'] = len(content)\n                respParameters['DataOffset'] = 59\n                respParameters['DataCount_Hi'] = 0\n                respData = content\n            except Exception as e:\n                smbServer.log('smbComReadAndX: %s ' % e, logging.ERROR)\n                errorCode = STATUS_ACCESS_DENIED\n        else:\n            errorCode = STATUS_INVALID_HANDLE\n\n        if errorCode > 0:\n            respParameters = b''\n            respData = b''\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smbQueryInformation(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_QUERY_INFORMATION)\n        respParameters = smb.SMBQueryInformationResponse_Parameters()\n        respData = b''\n\n        queryInformation = smb.SMBQueryInformation_Data(flags=recvPacket['Flags2'], data=SMBCommand['Data'])\n\n        # Get the Tid associated\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            fileSize, lastWriteTime, fileAttributes = queryFsInformation(\n                connData['ConnectedShares'][recvPacket['Tid']]['path'],\n                decodeSMBString(recvPacket['Flags2'], queryInformation['FileName']), pktFlags=recvPacket['Flags2'])\n\n            respParameters['FileSize'] = fileSize\n            respParameters['LastWriteTime'] = lastWriteTime\n            respParameters['FileAttributes'] = fileAttributes\n            errorCode = STATUS_SUCCESS\n        else:\n            # STATUS_SMB_BAD_TID\n            errorCode = STATUS_SMB_BAD_TID\n            respParameters = b''\n            respData = b''\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smbQueryInformationDisk(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_QUERY_INFORMATION_DISK)\n        respParameters = smb.SMBQueryInformationDiskResponse_Parameters()\n        respData = b''\n\n        # Get the Tid associated\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            totalUnits, freeUnits = queryDiskInformation(\n                connData['ConnectedShares'][recvPacket['Tid']]['path'])\n\n            respParameters['TotalUnits'] = totalUnits\n            respParameters['BlocksPerUnit'] = 1\n            respParameters['BlockSize'] = 1\n            respParameters['FreeUnits'] = freeUnits\n            errorCode = STATUS_SUCCESS\n        else:\n            # STATUS_SMB_BAD_TID\n            respData = b''\n            respParameters = b''\n            errorCode = STATUS_SMB_BAD_TID\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smbComEcho(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_ECHO)\n        respParameters = smb.SMBEchoResponse_Parameters()\n        respData = smb.SMBEchoResponse_Data()\n\n        echoData = smb.SMBEcho_Data(SMBCommand['Data'])\n\n        respParameters['SequenceNumber'] = 1\n        respData['Data'] = echoData['Data']\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n\n        errorCode = STATUS_SUCCESS\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smbComTreeDisconnect(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_TREE_DISCONNECT)\n\n        # Check if the Tid matches the Tid trying to disconnect\n        respParameters = b''\n        respData = b''\n\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            smbServer.log(\"Disconnecting Share(%d:%s)\" % (\n            recvPacket['Tid'], connData['ConnectedShares'][recvPacket['Tid']]['shareName']))\n            del (connData['ConnectedShares'][recvPacket['Tid']])\n            errorCode = STATUS_SUCCESS\n        else:\n            # STATUS_SMB_BAD_TID\n            errorCode = STATUS_SMB_BAD_TID\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smbComLogOffAndX(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_LOGOFF_ANDX)\n\n        # Check if the Uid matches the user trying to logoff\n        respParameters = b''\n        respData = b''\n        if recvPacket['Uid'] != connData['Uid']:\n            # STATUS_SMB_BAD_UID\n            errorCode = STATUS_SMB_BAD_UID\n        else:\n            errorCode = STATUS_SUCCESS\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n        connData['Uid'] = 0\n        connData['Authenticated'] = False\n\n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smbComQueryInformation2(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_QUERY_INFORMATION2)\n        respParameters = smb.SMBQueryInformation2Response_Parameters()\n        respData = b''\n\n        queryInformation2 = smb.SMBQueryInformation2_Parameters(SMBCommand['Parameters'])\n        errorCode = 0xFF\n        if queryInformation2['Fid'] in connData['OpenedFiles']:\n            errorCode = STATUS_SUCCESS\n            pathName = connData['OpenedFiles'][queryInformation2['Fid']]['FileName']\n            try:\n                (mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime) = os.stat(pathName)\n                respParameters['CreateDate'] = getSMBDate(ctime)\n                respParameters['CreationTime'] = getSMBTime(ctime)\n                respParameters['LastAccessDate'] = getSMBDate(atime)\n                respParameters['LastAccessTime'] = getSMBTime(atime)\n                respParameters['LastWriteDate'] = getSMBDate(mtime)\n                respParameters['LastWriteTime'] = getSMBTime(mtime)\n                respParameters['FileDataSize'] = size\n                respParameters['FileAllocationSize'] = size\n                attribs = 0\n                if os.path.isdir(pathName):\n                    attribs = smb.SMB_FILE_ATTRIBUTE_DIRECTORY\n                if os.path.isfile(pathName):\n                    attribs = smb.SMB_FILE_ATTRIBUTE_NORMAL\n                respParameters['FileAttributes'] = attribs\n            except Exception as e:\n                smbServer.log('smbComQueryInformation2 %s' % e, logging.ERROR)\n                errorCode = STATUS_ACCESS_DENIED\n\n        if errorCode > 0:\n            respParameters = b''\n            respData = b''\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smbComNtCreateAndX(connId, smbServer, SMBCommand, recvPacket):\n        # TODO: Fully implement this\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_NT_CREATE_ANDX)\n        respParameters = smb.SMBNtCreateAndXResponse_Parameters()\n        respData = b''\n\n        ntCreateAndXParameters = smb.SMBNtCreateAndX_Parameters(SMBCommand['Parameters'])\n        ntCreateAndXData = smb.SMBNtCreateAndX_Data(flags=recvPacket['Flags2'], data=SMBCommand['Data'])\n\n        # if ntCreateAndXParameters['CreateFlags'] & 0x10:  # NT_CREATE_REQUEST_EXTENDED_RESPONSE\n        #    respParameters        = smb.SMBNtCreateAndXExtendedResponse_Parameters()\n        #    respParameters['VolumeGUID'] = '\\x00'\n\n        # Get the Tid associated\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            # If we have a rootFid, the path is relative to that fid\n            errorCode = STATUS_SUCCESS\n            if ntCreateAndXParameters['RootFid'] > 0:\n                path = connData['OpenedFiles'][ntCreateAndXParameters['RootFid']]['FileName']\n                LOG.debug(\"RootFid present %s!\" % path)\n            else:\n                if 'path' in connData['ConnectedShares'][recvPacket['Tid']]:\n                    path = connData['ConnectedShares'][recvPacket['Tid']]['path']\n                else:\n                    path = 'NONE'\n                    errorCode = STATUS_ACCESS_DENIED\n\n            deleteOnClose = False\n\n            fileName = os.path.normpath(\n                decodeSMBString(recvPacket['Flags2'], ntCreateAndXData['FileName']).replace('\\\\', '/'))\n            if len(fileName) > 0 and (fileName[0] == '/' or fileName[0] == '\\\\'):\n                # strip leading '/'\n                fileName = fileName[1:]\n\n            if not isInFileJail(path, fileName):\n                LOG.error(\"Path not in current working directory\")\n                respSMBCommand['Parameters'] = b''\n                respSMBCommand['Data'] = b''\n                return [respSMBCommand], None, STATUS_OBJECT_PATH_SYNTAX_BAD\n\n            pathName = os.path.join(path, fileName)\n            createDisposition = ntCreateAndXParameters['Disposition']\n            mode = 0\n\n            if createDisposition == smb.FILE_SUPERSEDE:\n                mode |= os.O_TRUNC | os.O_CREAT\n            elif createDisposition & smb.FILE_OVERWRITE_IF == smb.FILE_OVERWRITE_IF:\n                mode |= os.O_TRUNC | os.O_CREAT\n            elif createDisposition & smb.FILE_OVERWRITE == smb.FILE_OVERWRITE:\n                if os.path.exists(pathName) is True:\n                    mode |= os.O_TRUNC\n                else:\n                    errorCode = STATUS_NO_SUCH_FILE\n            elif createDisposition & smb.FILE_OPEN_IF == smb.FILE_OPEN_IF:\n                if os.path.exists(pathName) is True:\n                    mode |= os.O_TRUNC\n                else:\n                    mode |= os.O_TRUNC | os.O_CREAT\n            elif createDisposition & smb.FILE_CREATE == smb.FILE_CREATE:\n                if os.path.exists(pathName) is True:\n                    errorCode = STATUS_OBJECT_NAME_COLLISION\n                else:\n                    mode |= os.O_CREAT\n            elif createDisposition & smb.FILE_OPEN == smb.FILE_OPEN:\n                if os.path.exists(pathName) is not True and (\n                        str(pathName) in smbServer.getRegisteredNamedPipes()) is not True:\n                    errorCode = STATUS_NO_SUCH_FILE\n\n            if errorCode == STATUS_SUCCESS:\n                desiredAccess = ntCreateAndXParameters['AccessMask']\n                if (desiredAccess & smb.FILE_READ_DATA) or (desiredAccess & smb.GENERIC_READ):\n                    mode |= os.O_RDONLY\n                if (desiredAccess & smb.FILE_WRITE_DATA) or (desiredAccess & smb.GENERIC_WRITE):\n                    if (desiredAccess & smb.FILE_READ_DATA) or (desiredAccess & smb.GENERIC_READ):\n                        mode |= os.O_RDWR  # | os.O_APPEND\n                    else:\n                        mode |= os.O_WRONLY  # | os.O_APPEND\n                if desiredAccess & smb.GENERIC_ALL:\n                    mode |= os.O_RDWR  # | os.O_APPEND\n\n                createOptions = ntCreateAndXParameters['CreateOptions']\n                if mode & os.O_CREAT == os.O_CREAT:\n                    if createOptions & smb.FILE_DIRECTORY_FILE == smb.FILE_DIRECTORY_FILE:\n                        try:\n                            # Let's create the directory\n                            os.mkdir(pathName)\n                            mode = os.O_RDONLY\n                        except Exception as e:\n                            smbServer.log(\"NTCreateAndX: %s,%s,%s\" % (pathName, mode, e), logging.ERROR)\n                            errorCode = STATUS_ACCESS_DENIED\n                if createOptions & smb.FILE_NON_DIRECTORY_FILE == smb.FILE_NON_DIRECTORY_FILE:\n                    # If the file being opened is a directory, the server MUST fail the request with\n                    # STATUS_FILE_IS_A_DIRECTORY in the Status field of the SMB Header in the server\n                    # response.\n                    if os.path.isdir(pathName) is True:\n                        errorCode = STATUS_FILE_IS_A_DIRECTORY\n\n                if createOptions & smb.FILE_DELETE_ON_CLOSE == smb.FILE_DELETE_ON_CLOSE:\n                    deleteOnClose = True\n\n                if errorCode == STATUS_SUCCESS:\n                    try:\n                        if os.path.isdir(pathName) and sys.platform == 'win32':\n                            fid = VOID_FILE_DESCRIPTOR\n                        else:\n                            if sys.platform == 'win32':\n                                mode |= os.O_BINARY\n                            if str(pathName) in smbServer.getRegisteredNamedPipes():\n                                fid = PIPE_FILE_DESCRIPTOR\n                                sock = socket.socket()\n                                sock.connect(smbServer.getRegisteredNamedPipes()[str(pathName)])\n                            else:\n                                fid = os.open(pathName, mode)\n                    except Exception as e:\n                        smbServer.log(\"NTCreateAndX: %s,%s,%s\" % (pathName, mode, e), logging.ERROR)\n                        # print e\n                        fid = 0\n                        errorCode = STATUS_ACCESS_DENIED\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        if errorCode == STATUS_SUCCESS:\n            # Simple way to generate a fid\n            if len(connData['OpenedFiles']) == 0:\n                fakefid = 1\n            else:\n                fakefid = list(connData['OpenedFiles'].keys())[-1] + 1\n            respParameters['Fid'] = fakefid\n            respParameters['CreateAction'] = createDisposition\n            if fid == PIPE_FILE_DESCRIPTOR:\n                respParameters['FileAttributes'] = 0x80\n                respParameters['IsDirectory'] = 0\n                respParameters['CreateTime'] = 0\n                respParameters['LastAccessTime'] = 0\n                respParameters['LastWriteTime'] = 0\n                respParameters['LastChangeTime'] = 0\n                respParameters['AllocationSize'] = 4096\n                respParameters['EndOfFile'] = 0\n                respParameters['FileType'] = 2\n                respParameters['IPCState'] = 0x5ff\n            else:\n                if os.path.isdir(pathName):\n                    respParameters['FileAttributes'] = smb.SMB_FILE_ATTRIBUTE_DIRECTORY\n                    respParameters['IsDirectory'] = 1\n                else:\n                    respParameters['IsDirectory'] = 0\n                    respParameters['FileAttributes'] = ntCreateAndXParameters['FileAttributes']\n                # Let's get this file's information\n                respInfo, errorCode = queryPathInformation('', pathName, level=smb.SMB_QUERY_FILE_ALL_INFO)\n                if errorCode == STATUS_SUCCESS:\n                    respParameters['CreateTime'] = respInfo['CreationTime']\n                    respParameters['LastAccessTime'] = respInfo['LastAccessTime']\n                    respParameters['LastWriteTime'] = respInfo['LastWriteTime']\n                    respParameters['LastChangeTime'] = respInfo['LastChangeTime']\n                    respParameters['FileAttributes'] = respInfo['ExtFileAttributes']\n                    respParameters['AllocationSize'] = respInfo['AllocationSize']\n                    respParameters['EndOfFile'] = respInfo['EndOfFile']\n                else:\n                    respParameters = b''\n                    respData = b''\n\n            if errorCode == STATUS_SUCCESS:\n                # Let's store the fid for the connection\n                # smbServer.log('Create file %s, mode:0x%x' % (pathName, mode))\n                connData['OpenedFiles'][fakefid] = {}\n                connData['OpenedFiles'][fakefid]['FileHandle'] = fid\n                connData['OpenedFiles'][fakefid]['FileName'] = pathName\n                connData['OpenedFiles'][fakefid]['DeleteOnClose'] = deleteOnClose\n                if fid == PIPE_FILE_DESCRIPTOR:\n                    connData['OpenedFiles'][fakefid]['Socket'] = sock\n        else:\n            respParameters = b''\n            respData = b''\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smbComOpenAndX(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_OPEN_ANDX)\n        respParameters = smb.SMBOpenAndXResponse_Parameters()\n        respData = b''\n\n        openAndXParameters = smb.SMBOpenAndX_Parameters(SMBCommand['Parameters'])\n        openAndXData = smb.SMBOpenAndX_Data(flags=recvPacket['Flags2'], data=SMBCommand['Data'])\n\n        # Get the Tid associated\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            path = connData['ConnectedShares'][recvPacket['Tid']]['path']\n            openedFile, mode, pathName, errorCode = openFile(path,\n                                                             decodeSMBString(recvPacket['Flags2'],\n                                                                             openAndXData['FileName']),\n                                                             openAndXParameters['DesiredAccess'],\n                                                             openAndXParameters['FileAttributes'],\n                                                             openAndXParameters['OpenMode'])\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        if errorCode == STATUS_SUCCESS:\n            # Simple way to generate a fid\n            fid = len(connData['OpenedFiles']) + 1\n            if len(connData['OpenedFiles']) == 0:\n                fid = 1\n            else:\n                fid = list(connData['OpenedFiles'].keys())[-1] + 1\n            respParameters['Fid'] = fid\n            if mode & os.O_CREAT:\n                # File did not exist and was created\n                respParameters['Action'] = 0x2\n            elif mode & os.O_RDONLY:\n                # File existed and was opened\n                respParameters['Action'] = 0x1\n            elif mode & os.O_APPEND:\n                # File existed and was opened\n                respParameters['Action'] = 0x1\n            else:\n                # File existed and was truncated\n                respParameters['Action'] = 0x3\n\n            # Let's store the fid for the connection\n            # smbServer.log('Opening file %s' % pathName)\n            connData['OpenedFiles'][fid] = {}\n            connData['OpenedFiles'][fid]['FileHandle'] = openedFile\n            connData['OpenedFiles'][fid]['FileName'] = pathName\n            connData['OpenedFiles'][fid]['DeleteOnClose'] = False\n        else:\n            respParameters = b''\n            respData = b''\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smbComTreeConnectAndX(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        resp = smb.NewSMBPacket()\n        resp['Flags1'] = smb.SMB.FLAGS1_REPLY\n        resp['Flags2'] = smb.SMB.FLAGS2_EXTENDED_SECURITY | smb.SMB.FLAGS2_NT_STATUS | smb.SMB.FLAGS2_LONG_NAMES | \\\n                         recvPacket['Flags2'] & smb.SMB.FLAGS2_UNICODE\n\n        resp['Tid'] = recvPacket['Tid']\n        resp['Mid'] = recvPacket['Mid']\n        resp['Pid'] = connData['Pid']\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_TREE_CONNECT_ANDX)\n        respParameters = smb.SMBTreeConnectAndXResponse_Parameters()\n        respData = smb.SMBTreeConnectAndXResponse_Data()\n\n        treeConnectAndXParameters = smb.SMBTreeConnectAndX_Parameters(SMBCommand['Parameters'])\n\n        if treeConnectAndXParameters['Flags'] & 0x8:\n            respParameters = smb.SMBTreeConnectAndXExtendedResponse_Parameters()\n\n        treeConnectAndXData = smb.SMBTreeConnectAndX_Data(flags=recvPacket['Flags2'])\n        treeConnectAndXData['_PasswordLength'] = treeConnectAndXParameters['PasswordLength']\n        treeConnectAndXData.fromString(SMBCommand['Data'])\n\n        errorCode = STATUS_SUCCESS\n\n        ## Process here the request, does the share exist?\n        UNCOrShare = decodeSMBString(recvPacket['Flags2'], treeConnectAndXData['Path'])\n\n        # Is this a UNC?\n        if ntpath.ismount(UNCOrShare):\n            path = UNCOrShare.split('\\\\')[3]\n        else:\n            path = ntpath.basename(UNCOrShare)\n\n        share = searchShare(connId, path, smbServer)\n        if share is not None:\n            # Simple way to generate a Tid\n            if len(connData['ConnectedShares']) == 0:\n                tid = 1\n            else:\n                tid = list(connData['ConnectedShares'].keys())[-1] + 1\n            connData['ConnectedShares'][tid] = share\n            connData['ConnectedShares'][tid]['shareName'] = path\n            resp['Tid'] = tid\n            # smbServer.log(\"Connecting Share(%d:%s)\" % (tid,path))\n        else:\n            smbServer.log(\"TreeConnectAndX not found %s\" % path, logging.ERROR)\n            errorCode = STATUS_OBJECT_PATH_NOT_FOUND\n            resp['ErrorCode'] = errorCode >> 16\n            resp['ErrorClass'] = errorCode & 0xff\n        ##\n        respParameters['OptionalSupport'] = smb.SMB.SMB_SUPPORT_SEARCH_BITS\n\n        if path == 'IPC$':\n            respData['Service'] = 'IPC'\n        else:\n            respData['Service'] = path\n        respData['PadLen'] = 0\n        respData['NativeFileSystem'] = encodeSMBString(recvPacket['Flags2'], 'NTFS').decode()\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n\n        resp['Uid'] = connData['Uid']\n        resp.addCommand(respSMBCommand)\n\n        # Sign the packet if needed\n        if connData['SignatureEnabled']:\n            smbServer.signSMBv1(connData, resp, connData['SigningSessionKey'], connData['SigningChallengeResponse'])\n        smbServer.setConnectionData(connId, connData)\n\n        return None, [resp], errorCode\n\n    @staticmethod\n    def smbComSessionSetupAndX(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId, checkStatus=False)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_SESSION_SETUP_ANDX)\n\n        # From [MS-SMB]\n        # When extended security is being used (see section 3.2.4.2.4), the\n        # request MUST take the following form\n        # [..]\n        # WordCount (1 byte): The value of this field MUST be 0x0C.\n        if SMBCommand['WordCount'] == 12:\n            # Extended security. Here we deal with all SPNEGO stuff\n            respParameters = smb.SMBSessionSetupAndX_Extended_Response_Parameters()\n            respData = smb.SMBSessionSetupAndX_Extended_Response_Data(flags=recvPacket['Flags2'])\n            sessionSetupParameters = smb.SMBSessionSetupAndX_Extended_Parameters(SMBCommand['Parameters'])\n            sessionSetupData = smb.SMBSessionSetupAndX_Extended_Data()\n            sessionSetupData['SecurityBlobLength'] = sessionSetupParameters['SecurityBlobLength']\n            sessionSetupData.fromString(SMBCommand['Data'])\n            connData['Capabilities'] = sessionSetupParameters['Capabilities']\n\n            rawNTLM = False\n            if struct.unpack('B', sessionSetupData['SecurityBlob'][0:1])[0] == ASN1_AID:\n                # NEGOTIATE packet\n                blob = SPNEGO_NegTokenInit(sessionSetupData['SecurityBlob'])\n                token = blob['MechToken']\n                if len(blob['MechTypes'][0]) > 0:\n                    # Is this GSSAPI NTLM or something else we don't support?\n                    mechType = blob['MechTypes'][0]\n                    if mechType != TypesMech['NTLMSSP - Microsoft NTLM Security Support Provider']:\n                        # Nope, do we know it?\n                        if mechType in MechTypes:\n                            mechStr = MechTypes[mechType]\n                        else:\n                            mechStr = hexlify(mechType)\n                        smbServer.log(\"Unsupported MechType '%s'\" % mechStr, logging.CRITICAL)\n                        # We don't know the token, we answer back again saying\n                        # we just support NTLM.\n                        # ToDo: Build this into a SPNEGO_NegTokenResp()\n                        respToken = b'\\xa1\\x15\\x30\\x13\\xa0\\x03\\x0a\\x01\\x03\\xa1\\x0c\\x06\\x0a\\x2b\\x06\\x01\\x04\\x01\\x82\\x37\\x02\\x02\\x0a'\n                        respParameters['SecurityBlobLength'] = len(respToken)\n                        respData['SecurityBlobLength'] = respParameters['SecurityBlobLength']\n                        respData['SecurityBlob'] = respToken\n                        respData['NativeOS'] = encodeSMBString(recvPacket['Flags2'], smbServer.getServerOS())\n                        respData['NativeLanMan'] = encodeSMBString(recvPacket['Flags2'], smbServer.getServerOS())\n                        respSMBCommand['Parameters'] = respParameters\n                        respSMBCommand['Data'] = respData\n                        return [respSMBCommand], None, STATUS_MORE_PROCESSING_REQUIRED\n\n            elif struct.unpack('B', sessionSetupData['SecurityBlob'][0:1])[0] == ASN1_SUPPORTED_MECH:\n                # AUTH packet\n                blob = SPNEGO_NegTokenResp(sessionSetupData['SecurityBlob'])\n                token = blob['ResponseToken']\n            else:\n                # No GSSAPI stuff, raw NTLMSSP\n                rawNTLM = True\n                token = sessionSetupData['SecurityBlob']\n\n            # Here we only handle NTLMSSP, depending on what stage of the\n            # authentication we are, we act on it\n            messageType = struct.unpack('<L', token[len('NTLMSSP\\x00'):len('NTLMSSP\\x00') + 4])[0]\n\n            if messageType == 0x01:\n                # NEGOTIATE_MESSAGE\n                negotiateMessage = ntlm.NTLMAuthNegotiate()\n                negotiateMessage.fromString(token)\n                # Let's store it in the connection data\n                connData['NEGOTIATE_MESSAGE'] = negotiateMessage\n                # Let's build the answer flags\n                # TODO: Parse all the flags. With this we're leaving some clients out\n\n                ansFlags = 0\n\n                if negotiateMessage['flags'] & ntlm.NTLMSSP_NEGOTIATE_56:\n                    ansFlags |= ntlm.NTLMSSP_NEGOTIATE_56\n                if negotiateMessage['flags'] & ntlm.NTLMSSP_NEGOTIATE_128:\n                    ansFlags |= ntlm.NTLMSSP_NEGOTIATE_128\n                if negotiateMessage['flags'] & ntlm.NTLMSSP_NEGOTIATE_KEY_EXCH:\n                    ansFlags |= ntlm.NTLMSSP_NEGOTIATE_KEY_EXCH\n                if negotiateMessage['flags'] & ntlm.NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY:\n                    ansFlags |= ntlm.NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY\n                if negotiateMessage['flags'] & ntlm.NTLMSSP_NEGOTIATE_UNICODE:\n                    ansFlags |= ntlm.NTLMSSP_NEGOTIATE_UNICODE\n                if negotiateMessage['flags'] & ntlm.NTLM_NEGOTIATE_OEM:\n                    ansFlags |= ntlm.NTLM_NEGOTIATE_OEM\n\n                ansFlags |= ntlm.NTLMSSP_NEGOTIATE_VERSION | ntlm.NTLMSSP_NEGOTIATE_TARGET_INFO | ntlm.NTLMSSP_TARGET_TYPE_SERVER | ntlm.NTLMSSP_NEGOTIATE_NTLM | ntlm.NTLMSSP_REQUEST_TARGET\n\n                # Generate the AV_PAIRS\n                av_pairs = ntlm.AV_PAIRS()\n                # TODO: Put the proper data from SMBSERVER config\n                av_pairs[ntlm.NTLMSSP_AV_HOSTNAME] = av_pairs[\n                    ntlm.NTLMSSP_AV_DNS_HOSTNAME] = smbServer.getServerName().encode('utf-16le')\n                av_pairs[ntlm.NTLMSSP_AV_DOMAINNAME] = av_pairs[\n                    ntlm.NTLMSSP_AV_DNS_DOMAINNAME] = smbServer.getServerDomain().encode('utf-16le')\n                av_pairs[ntlm.NTLMSSP_AV_TIME] = struct.pack('<q', (\n                            116444736000000000 + calendar.timegm(time.gmtime()) * 10000000))\n\n                challengeMessage = ntlm.NTLMAuthChallenge()\n                challengeMessage['flags'] = ansFlags\n                challengeMessage['domain_len'] = len(smbServer.getServerDomain().encode('utf-16le'))\n                challengeMessage['domain_max_len'] = challengeMessage['domain_len']\n                challengeMessage['domain_offset'] = 40 + 16\n                challengeMessage['challenge'] = smbServer.getSMBChallenge()\n                challengeMessage['domain_name'] = smbServer.getServerDomain().encode('utf-16le')\n                challengeMessage['TargetInfoFields_len'] = len(av_pairs)\n                challengeMessage['TargetInfoFields_max_len'] = len(av_pairs)\n                challengeMessage['TargetInfoFields'] = av_pairs\n                challengeMessage['TargetInfoFields_offset'] = 40 + 16 + len(challengeMessage['domain_name'])\n                challengeMessage['Version'] = b'\\xff' * 8\n                challengeMessage['VersionLen'] = 8\n\n                if rawNTLM is False:\n                    respToken = SPNEGO_NegTokenResp()\n                    # accept-incomplete. We want more data\n                    respToken['NegState'] = b'\\x01'\n                    respToken['SupportedMech'] = TypesMech['NTLMSSP - Microsoft NTLM Security Support Provider']\n\n                    respToken['ResponseToken'] = challengeMessage.getData()\n                else:\n                    respToken = challengeMessage\n\n                # Setting the packet to STATUS_MORE_PROCESSING\n                errorCode = STATUS_MORE_PROCESSING_REQUIRED\n                # Let's set up an UID for this connection and store it\n                # in the connection's data\n                # Picking a fixed value\n                # TODO: Manage more UIDs for the same session\n                connData['Uid'] = 10\n                # Let's store it in the connection data\n                connData['CHALLENGE_MESSAGE'] = challengeMessage\n\n            elif messageType == 0x02:\n                # CHALLENGE_MESSAGE\n                raise Exception('Challenge Message raise, not implemented!')\n            elif messageType == 0x03:\n                # AUTHENTICATE_MESSAGE, here we deal with authentication\n                authenticateMessage = ntlm.NTLMAuthChallengeResponse()\n                authenticateMessage.fromString(token)\n                smbServer.log(\"AUTHENTICATE_MESSAGE (%s\\\\%s,%s)\" % (\n                    authenticateMessage['domain_name'].decode('utf-16le'),\n                    authenticateMessage['user_name'].decode('utf-16le'),\n                    authenticateMessage['host_name'].decode('utf-16le')))\n                # Do we have credentials to check?\n                if len(smbServer.getCredentials()) > 0:\n                    identity = authenticateMessage['user_name'].decode('utf-16le').lower()\n                    # Do we have this user's credentials?\n                    if identity in smbServer.getCredentials():\n                        # Process data:\n                        # Let's parse some data and keep it to ourselves in case it is asked\n                        uid, lmhash, nthash = smbServer.getCredentials()[identity]\n\n                        errorCode, sessionKey = computeNTLMv2(identity, lmhash, nthash, smbServer.getSMBChallenge(),\n                                                              authenticateMessage, connData['CHALLENGE_MESSAGE'],\n                                                              connData['NEGOTIATE_MESSAGE'])\n\n                        if sessionKey is not None:\n                            connData['SignatureEnabled'] = False\n                            connData['SigningSessionKey'] = sessionKey\n                            connData['SignSequenceNumber'] = 1\n                    else:\n                        errorCode = STATUS_LOGON_FAILURE\n                else:\n                    # No credentials provided, let's grant access\n                    errorCode = STATUS_SUCCESS\n\n                if errorCode == STATUS_SUCCESS:\n                    connData['Authenticated'] = True\n                    respToken = SPNEGO_NegTokenResp()\n                    # accept-completed\n                    respToken['NegState'] = b'\\x00'\n\n                    smbServer.log(\n                        'User %s\\\\%s authenticated successfully' % (authenticateMessage['host_name'].decode('utf-16le'),\n                                                                    authenticateMessage['user_name'].decode(\n                                                                        'utf-16le')))\n                    # Let's store it in the connection data\n                    connData['AUTHENTICATE_MESSAGE'] = authenticateMessage\n                    try:\n                        jtr_dump_path = smbServer.getJTRdumpPath()\n                        ntlm_hash_data = outputToJohnFormat(connData['CHALLENGE_MESSAGE']['challenge'],\n                                                            authenticateMessage['user_name'],\n                                                            authenticateMessage['domain_name'],\n                                                            authenticateMessage['lanman'], authenticateMessage['ntlm'])\n                        smbServer.log(ntlm_hash_data['hash_string'])\n                        if jtr_dump_path != '':\n                            writeJohnOutputToFile(ntlm_hash_data['hash_string'], ntlm_hash_data['hash_version'],\n                                                  jtr_dump_path)\n                    except:\n                        smbServer.log(\"Could not write NTLM Hashes to the specified JTR_Dump_Path %s\" % jtr_dump_path)\n                else:\n                    respToken = SPNEGO_NegTokenResp()\n                    respToken['NegState'] = b'\\x02'\n                    smbServer.log(\"Could not authenticate user!\")\n            else:\n                raise Exception(\"Unknown NTLMSSP MessageType %d\" % messageType)\n\n            respParameters['SecurityBlobLength'] = len(respToken)\n            respData['SecurityBlobLength'] = respParameters['SecurityBlobLength']\n            respData['SecurityBlob'] = respToken.getData()\n\n        else:\n            # Process Standard Security\n            respParameters = smb.SMBSessionSetupAndXResponse_Parameters()\n            respData = smb.SMBSessionSetupAndXResponse_Data()\n            sessionSetupParameters = smb.SMBSessionSetupAndX_Parameters(SMBCommand['Parameters'])\n            sessionSetupData = smb.SMBSessionSetupAndX_Data()\n            sessionSetupData['AnsiPwdLength'] = sessionSetupParameters['AnsiPwdLength']\n            sessionSetupData['UnicodePwdLength'] = sessionSetupParameters['UnicodePwdLength']\n            sessionSetupData.fromString(SMBCommand['Data'])\n            connData['Capabilities'] = sessionSetupParameters['Capabilities']\n            # Do the verification here, for just now we grant access\n            # TODO: Manage more UIDs for the same session\n            errorCode = STATUS_SUCCESS\n            connData['Uid'] = 10\n            connData['Authenticated'] = True\n            respParameters['Action'] = 0\n            smbServer.log('User %s\\\\%s authenticated successfully (basic)' % (\n            sessionSetupData['PrimaryDomain'], sessionSetupData['Account']))\n            try:\n                jtr_dump_path = smbServer.getJTRdumpPath()\n                ntlm_hash_data = outputToJohnFormat(b'', b(sessionSetupData['Account']),\n                                                    b(sessionSetupData['PrimaryDomain']), sessionSetupData['AnsiPwd'],\n                                                    sessionSetupData['UnicodePwd'])\n                smbServer.log(ntlm_hash_data['hash_string'])\n                if jtr_dump_path != '':\n                    writeJohnOutputToFile(ntlm_hash_data['hash_string'], ntlm_hash_data['hash_version'], jtr_dump_path)\n            except:\n                smbServer.log(\"Could not write NTLM Hashes to the specified JTR_Dump_Path %s\" % jtr_dump_path)\n\n        respData['NativeOS'] = encodeSMBString(recvPacket['Flags2'], smbServer.getServerOS())\n        respData['NativeLanMan'] = encodeSMBString(recvPacket['Flags2'], smbServer.getServerOS())\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n\n        # From now on, the client can ask for other commands\n        connData['Authenticated'] = True\n        # For now, just switching to nobody\n        # os.setregid(65534,65534)\n        # os.setreuid(65534,65534)\n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smbComNegotiate(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId, checkStatus=False)\n        connData['Pid'] = recvPacket['Pid']\n\n        SMBCommand = smb.SMBCommand(recvPacket['Data'][0])\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_NEGOTIATE)\n\n        resp = smb.NewSMBPacket()\n        resp['Flags1'] = smb.SMB.FLAGS1_REPLY\n        resp['Pid'] = connData['Pid']\n        resp['Tid'] = recvPacket['Tid']\n        resp['Mid'] = recvPacket['Mid']\n\n        # TODO: We support more dialects, and parse them accordingly\n        dialects = SMBCommand['Data'].split(b'\\x02')\n        try:\n            index = dialects.index(b'NT LM 0.12\\x00') - 1\n            # Let's fill the data for NTLM\n            if recvPacket['Flags2'] & smb.SMB.FLAGS2_EXTENDED_SECURITY:\n                resp['Flags2'] = smb.SMB.FLAGS2_EXTENDED_SECURITY | smb.SMB.FLAGS2_NT_STATUS | smb.SMB.FLAGS2_UNICODE\n                # resp['Flags2'] = smb.SMB.FLAGS2_EXTENDED_SECURITY | smb.SMB.FLAGS2_NT_STATUS\n                _dialects_data = smb.SMBExtended_Security_Data()\n                _dialects_data['ServerGUID'] = b'A' * 16\n                blob = SPNEGO_NegTokenInit()\n                blob['MechTypes'] = [TypesMech['NTLMSSP - Microsoft NTLM Security Support Provider']]\n                _dialects_data['SecurityBlob'] = blob.getData()\n\n                _dialects_parameters = smb.SMBExtended_Security_Parameters()\n                _dialects_parameters[\n                    'Capabilities'] = smb.SMB.CAP_EXTENDED_SECURITY | smb.SMB.CAP_USE_NT_ERRORS | smb.SMB.CAP_NT_SMBS | smb.SMB.CAP_UNICODE\n                _dialects_parameters['ChallengeLength'] = 0\n\n            else:\n                resp['Flags2'] = smb.SMB.FLAGS2_NT_STATUS | smb.SMB.FLAGS2_UNICODE\n                _dialects_parameters = smb.SMBNTLMDialect_Parameters()\n                _dialects_data = smb.SMBNTLMDialect_Data()\n                _dialects_data['Payload'] = ''\n                if 'EncryptionKey' in connData:\n                    _dialects_data['Challenge'] = connData['EncryptionKey']\n                    _dialects_parameters['ChallengeLength'] = len(_dialects_data.getData())\n                else:\n                    # TODO: Handle random challenges, now one that can be used with rainbow tables\n                    _dialects_data['Challenge'] = b'\\x11\\x22\\x33\\x44\\x55\\x66\\x77\\x88'\n                    _dialects_parameters['ChallengeLength'] = 8\n                _dialects_parameters['Capabilities'] = smb.SMB.CAP_USE_NT_ERRORS | smb.SMB.CAP_NT_SMBS\n\n                # Let's see if we need to support RPC_REMOTE_APIS\n            config = smbServer.getServerConfig()\n            if config.has_option('global', 'rpc_apis'):\n                if config.getboolean('global', 'rpc_apis') is True:\n                    _dialects_parameters['Capabilities'] |= smb.SMB.CAP_RPC_REMOTE_APIS\n\n            _dialects_parameters['DialectIndex'] = index\n            # _dialects_parameters['SecurityMode']    = smb.SMB.SECURITY_AUTH_ENCRYPTED | smb.SMB.SECURITY_SHARE_USER | smb.SMB.SECURITY_SIGNATURES_REQUIRED\n            _dialects_parameters['SecurityMode'] = smb.SMB.SECURITY_AUTH_ENCRYPTED | smb.SMB.SECURITY_SHARE_USER\n            _dialects_parameters['MaxMpxCount'] = 1\n            _dialects_parameters['MaxNumberVcs'] = 1\n            _dialects_parameters['MaxBufferSize'] = 64000\n            _dialects_parameters['MaxRawSize'] = 65536\n            _dialects_parameters['SessionKey'] = 0\n            _dialects_parameters['LowDateTime'] = 0\n            _dialects_parameters['HighDateTime'] = 0\n            _dialects_parameters['ServerTimeZone'] = 0\n\n            respSMBCommand['Data'] = _dialects_data\n            respSMBCommand['Parameters'] = _dialects_parameters\n            connData['_dialects_data'] = _dialects_data\n            connData['_dialects_parameters'] = _dialects_parameters\n\n        except Exception as e:\n            # No NTLM throw an error\n            smbServer.log('smbComNegotiate: %s' % e, logging.ERROR)\n            respSMBCommand['Data'] = struct.pack('<H', 0xffff)\n\n        smbServer.setConnectionData(connId, connData)\n\n        resp.addCommand(respSMBCommand)\n\n        return None, [resp], STATUS_SUCCESS\n\n    @staticmethod\n    def default(connId, smbServer, SMBCommand, recvPacket):\n        # By default we return an SMB Packet with error not implemented\n        smbServer.log(\"Not implemented command: 0x%x\" % recvPacket['Command'], logging.DEBUG)\n        packet = smb.NewSMBPacket()\n        packet['Flags1'] = smb.SMB.FLAGS1_REPLY\n        packet['Flags2'] = smb.SMB.FLAGS2_NT_STATUS\n        packet['Command'] = recvPacket['Command']\n        packet['Pid'] = recvPacket['Pid']\n        packet['Tid'] = recvPacket['Tid']\n        packet['Mid'] = recvPacket['Mid']\n        packet['Uid'] = recvPacket['Uid']\n        packet['Data'] = b'\\x00\\x00\\x00'\n        errorCode = STATUS_NOT_IMPLEMENTED\n        packet['ErrorCode'] = errorCode >> 16\n        packet['ErrorClass'] = errorCode & 0xff\n\n        return None, [packet], errorCode\n\n\nclass SMB2Commands:\n    @staticmethod\n    def smb2Negotiate(connId, smbServer, recvPacket, isSMB1=False):\n        connData = smbServer.getConnectionData(connId, checkStatus=False)\n\n        respPacket = smb2.SMB2Packet()\n        respPacket['Flags'] = smb2.SMB2_FLAGS_SERVER_TO_REDIR\n        respPacket['Status'] = STATUS_SUCCESS\n        respPacket['CreditRequestResponse'] = 1\n        respPacket['Command'] = smb2.SMB2_NEGOTIATE\n        respPacket['SessionID'] = 0\n        if isSMB1 is False:\n            respPacket['MessageID'] = recvPacket['MessageID']\n        else:\n            respPacket['MessageID'] = 0\n        respPacket['TreeID'] = 0\n\n        respSMBCommand = smb2.SMB2Negotiate_Response()\n\n        respSMBCommand['SecurityMode'] = 1\n        if isSMB1 is True:\n            # Let's first parse the packet to see if the client supports SMB2\n            SMBCommand = smb.SMBCommand(recvPacket['Data'][0])\n\n            dialects = SMBCommand['Data'].split(b'\\x02')\n            if b'SMB 2.002\\x00' in dialects or b'SMB 2.???\\x00' in dialects:\n                respSMBCommand['DialectRevision'] = smb2.SMB2_DIALECT_002\n            else:\n                # Client does not support SMB2 fallbacking\n                raise Exception('SMB2 not supported, fallbacking')\n        else:\n            respSMBCommand['DialectRevision'] = smb2.SMB2_DIALECT_002\n        respSMBCommand['ServerGuid'] = b'A' * 16\n        respSMBCommand['Capabilities'] = 0\n        respSMBCommand['MaxTransactSize'] = 65536\n        respSMBCommand['MaxReadSize'] = 65536\n        respSMBCommand['MaxWriteSize'] = 65536\n        respSMBCommand['SystemTime'] = getFileTime(calendar.timegm(time.gmtime()))\n        respSMBCommand['ServerStartTime'] = getFileTime(calendar.timegm(time.gmtime()))\n        respSMBCommand['SecurityBufferOffset'] = 0x80\n\n        blob = SPNEGO_NegTokenInit()\n        blob['MechTypes'] = [TypesMech['NTLMSSP - Microsoft NTLM Security Support Provider']]\n\n        respSMBCommand['Buffer'] = blob.getData()\n        respSMBCommand['SecurityBufferLength'] = len(respSMBCommand['Buffer'])\n\n        respPacket['Data'] = respSMBCommand\n\n        smbServer.setConnectionData(connId, connData)\n\n        return None, [respPacket], STATUS_SUCCESS\n\n    @staticmethod\n    def smb2SessionSetup(connId, smbServer, recvPacket):\n        connData = smbServer.getConnectionData(connId, checkStatus=False)\n\n        respSMBCommand = smb2.SMB2SessionSetup_Response()\n\n        sessionSetupData = smb2.SMB2SessionSetup(recvPacket['Data'])\n\n        connData['Capabilities'] = sessionSetupData['Capabilities']\n\n        securityBlob = sessionSetupData['Buffer']\n\n        rawNTLM = False\n        if struct.unpack('B', securityBlob[0:1])[0] == ASN1_AID:\n            # NEGOTIATE packet\n            blob = SPNEGO_NegTokenInit(securityBlob)\n            token = blob['MechToken']\n            if len(blob['MechTypes'][0]) > 0:\n                # Is this GSSAPI NTLM or something else we don't support?\n                mechType = blob['MechTypes'][0]\n                if mechType != TypesMech['NTLMSSP - Microsoft NTLM Security Support Provider']:\n                    # Nope, do we know it?\n                    if mechType in MechTypes:\n                        mechStr = MechTypes[mechType]\n                    else:\n                        mechStr = hexlify(mechType)\n                    smbServer.log(\"Unsupported MechType '%s'\" % mechStr, logging.CRITICAL)\n                    # We don't know the token, we answer back again saying\n                    # we just support NTLM.\n                    # ToDo: Build this into a SPNEGO_NegTokenResp()\n                    respToken = b'\\xa1\\x15\\x30\\x13\\xa0\\x03\\x0a\\x01\\x03\\xa1\\x0c\\x06\\x0a\\x2b\\x06\\x01\\x04\\x01\\x82\\x37\\x02\\x02\\x0a'\n                    respSMBCommand['SecurityBufferOffset'] = 0x48\n                    respSMBCommand['SecurityBufferLength'] = len(respToken)\n                    respSMBCommand['Buffer'] = respToken\n\n                    return [respSMBCommand], None, STATUS_MORE_PROCESSING_REQUIRED\n        elif struct.unpack('B', securityBlob[0:1])[0] == ASN1_SUPPORTED_MECH:\n            # AUTH packet\n            blob = SPNEGO_NegTokenResp(securityBlob)\n            token = blob['ResponseToken']\n        else:\n            # No GSSAPI stuff, raw NTLMSSP\n            rawNTLM = True\n            token = securityBlob\n\n        # Here we only handle NTLMSSP, depending on what stage of the\n        # authentication we are, we act on it\n        messageType = struct.unpack('<L', token[len('NTLMSSP\\x00'):len('NTLMSSP\\x00') + 4])[0]\n\n        if messageType == 0x01:\n            # NEGOTIATE_MESSAGE\n            negotiateMessage = ntlm.NTLMAuthNegotiate()\n            negotiateMessage.fromString(token)\n            # Let's store it in the connection data\n            connData['NEGOTIATE_MESSAGE'] = negotiateMessage\n            # Let's build the answer flags\n            # TODO: Parse all the flags. With this we're leaving some clients out\n\n            ansFlags = 0\n\n            if negotiateMessage['flags'] & ntlm.NTLMSSP_NEGOTIATE_56:\n                ansFlags |= ntlm.NTLMSSP_NEGOTIATE_56\n            if negotiateMessage['flags'] & ntlm.NTLMSSP_NEGOTIATE_128:\n                ansFlags |= ntlm.NTLMSSP_NEGOTIATE_128\n            if negotiateMessage['flags'] & ntlm.NTLMSSP_NEGOTIATE_KEY_EXCH:\n                ansFlags |= ntlm.NTLMSSP_NEGOTIATE_KEY_EXCH\n            if negotiateMessage['flags'] & ntlm.NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY:\n                ansFlags |= ntlm.NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY\n            if negotiateMessage['flags'] & ntlm.NTLMSSP_NEGOTIATE_UNICODE:\n                ansFlags |= ntlm.NTLMSSP_NEGOTIATE_UNICODE\n            if negotiateMessage['flags'] & ntlm.NTLM_NEGOTIATE_OEM:\n                ansFlags |= ntlm.NTLM_NEGOTIATE_OEM\n\n            ansFlags |= ntlm.NTLMSSP_NEGOTIATE_VERSION | ntlm.NTLMSSP_NEGOTIATE_TARGET_INFO | ntlm.NTLMSSP_TARGET_TYPE_SERVER | ntlm.NTLMSSP_NEGOTIATE_NTLM | ntlm.NTLMSSP_REQUEST_TARGET\n\n            # Generate the AV_PAIRS\n            av_pairs = ntlm.AV_PAIRS()\n            # TODO: Put the proper data from SMBSERVER config\n            av_pairs[ntlm.NTLMSSP_AV_HOSTNAME] = av_pairs[\n                ntlm.NTLMSSP_AV_DNS_HOSTNAME] = smbServer.getServerName().encode('utf-16le')\n            av_pairs[ntlm.NTLMSSP_AV_DOMAINNAME] = av_pairs[\n                ntlm.NTLMSSP_AV_DNS_DOMAINNAME] = smbServer.getServerDomain().encode('utf-16le')\n            av_pairs[ntlm.NTLMSSP_AV_TIME] = struct.pack('<q', (\n                        116444736000000000 + calendar.timegm(time.gmtime()) * 10000000))\n\n            challengeMessage = ntlm.NTLMAuthChallenge()\n            challengeMessage['flags'] = ansFlags\n            challengeMessage['domain_len'] = len(smbServer.getServerDomain().encode('utf-16le'))\n            challengeMessage['domain_max_len'] = challengeMessage['domain_len']\n            challengeMessage['domain_offset'] = 40 + 16\n            challengeMessage['challenge'] = smbServer.getSMBChallenge()\n            challengeMessage['domain_name'] = smbServer.getServerDomain().encode('utf-16le')\n            challengeMessage['TargetInfoFields_len'] = len(av_pairs)\n            challengeMessage['TargetInfoFields_max_len'] = len(av_pairs)\n            challengeMessage['TargetInfoFields'] = av_pairs\n            challengeMessage['TargetInfoFields_offset'] = 40 + 16 + len(challengeMessage['domain_name'])\n            challengeMessage['Version'] = b'\\xff' * 8\n            challengeMessage['VersionLen'] = 8\n\n            if rawNTLM is False:\n                respToken = SPNEGO_NegTokenResp()\n                # accept-incomplete. We want more data\n                respToken['NegState'] = b'\\x01'\n                respToken['SupportedMech'] = TypesMech['NTLMSSP - Microsoft NTLM Security Support Provider']\n\n                respToken['ResponseToken'] = challengeMessage.getData()\n            else:\n                respToken = challengeMessage\n\n            # Setting the packet to STATUS_MORE_PROCESSING\n            errorCode = STATUS_MORE_PROCESSING_REQUIRED\n            # Let's set up an UID for this connection and store it\n            # in the connection's data\n            # Picking a fixed value\n            # TODO: Manage more UIDs for the same session\n            connData['Uid'] = random.randint(1, 0xffffffff)\n            # Let's store it in the connection data\n            connData['CHALLENGE_MESSAGE'] = challengeMessage\n\n        elif messageType == 0x02:\n            # CHALLENGE_MESSAGE\n            raise Exception('Challenge Message raise, not implemented!')\n        elif messageType == 0x03:\n            # AUTHENTICATE_MESSAGE, here we deal with authentication\n            authenticateMessage = ntlm.NTLMAuthChallengeResponse()\n            authenticateMessage.fromString(token)\n            smbServer.log(\"AUTHENTICATE_MESSAGE (%s\\\\%s,%s)\" % (\n                authenticateMessage['domain_name'].decode('utf-16le'),\n                authenticateMessage['user_name'].decode('utf-16le'),\n                authenticateMessage['host_name'].decode('utf-16le')))\n            # TODO: Check the credentials! Now granting permissions\n            # Do we have credentials to check?\n            if len(smbServer.getCredentials()) > 0:\n                isGuest = False\n                identity = authenticateMessage['user_name'].decode('utf-16le').lower()\n                # Do we have this user's credentials?\n                if identity in smbServer.getCredentials():\n                    # Process data:\n                    # Let's parse some data and keep it to ourselves in case it is asked\n                    uid, lmhash, nthash = smbServer.getCredentials()[identity]\n\n                    errorCode, sessionKey = computeNTLMv2(identity, lmhash, nthash, smbServer.getSMBChallenge(),\n                                                          authenticateMessage, connData['CHALLENGE_MESSAGE'],\n                                                          connData['NEGOTIATE_MESSAGE'])\n\n                    if sessionKey is not None:\n                        connData['SignatureEnabled'] = True\n                        connData['SigningSessionKey'] = sessionKey\n                        connData['SignSequenceNumber'] = 1\n                else:\n                    errorCode = STATUS_LOGON_FAILURE\n            else:\n                # No credentials provided, let's grant access\n                isGuest = True\n                errorCode = STATUS_SUCCESS\n\n            if errorCode == STATUS_SUCCESS:\n                connData['Authenticated'] = True\n                respToken = SPNEGO_NegTokenResp()\n                # accept-completed\n                respToken['NegState'] = b'\\x00'\n                smbServer.log('User %s\\\\%s authenticated successfully' % (\n                    authenticateMessage['host_name'].decode('utf-16le'),\n                    authenticateMessage['user_name'].decode('utf-16le')))\n                # Let's store it in the connection data\n                connData['AUTHENTICATE_MESSAGE'] = authenticateMessage\n                try:\n                    jtr_dump_path = smbServer.getJTRdumpPath()\n                    ntlm_hash_data = outputToJohnFormat(connData['CHALLENGE_MESSAGE']['challenge'],\n                                                        authenticateMessage['user_name'],\n                                                        authenticateMessage['domain_name'],\n                                                        authenticateMessage['lanman'], authenticateMessage['ntlm'])\n                    smbServer.log(ntlm_hash_data['hash_string'])\n                    if jtr_dump_path != '':\n                        writeJohnOutputToFile(ntlm_hash_data['hash_string'], ntlm_hash_data['hash_version'],\n                                              jtr_dump_path)\n                except:\n                    smbServer.log(\"Could not write NTLM Hashes to the specified JTR_Dump_Path %s\" % jtr_dump_path)\n\n                if isGuest:\n                    respSMBCommand['SessionFlags'] = 1\n\n            else:\n                respToken = SPNEGO_NegTokenResp()\n                respToken['NegState'] = b'\\x02'\n                smbServer.log(\"Could not authenticate user!\")\n        else:\n            raise Exception(\"Unknown NTLMSSP MessageType %d\" % messageType)\n\n        respSMBCommand['SecurityBufferOffset'] = 0x48\n        respSMBCommand['SecurityBufferLength'] = len(respToken)\n        respSMBCommand['Buffer'] = respToken.getData()\n\n        # From now on, the client can ask for other commands\n        connData['Authenticated'] = True\n        # For now, just switching to nobody\n        # os.setregid(65534,65534)\n        # os.setreuid(65534,65534)\n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smb2TreeConnect(connId, smbServer, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respPacket = smb2.SMB2Packet()\n        respPacket['Flags'] = smb2.SMB2_FLAGS_SERVER_TO_REDIR\n        respPacket['Status'] = STATUS_SUCCESS\n        respPacket['CreditRequestResponse'] = 1\n        respPacket['Command'] = recvPacket['Command']\n        respPacket['SessionID'] = connData['Uid']\n        respPacket['Reserved'] = recvPacket['Reserved']\n        respPacket['MessageID'] = recvPacket['MessageID']\n        respPacket['TreeID'] = recvPacket['TreeID']\n\n        respSMBCommand = smb2.SMB2TreeConnect_Response()\n\n        treeConnectRequest = smb2.SMB2TreeConnect(recvPacket['Data'])\n\n        errorCode = STATUS_SUCCESS\n\n        ## Process here the request, does the share exist?\n        path = recvPacket.getData()[treeConnectRequest['PathOffset']:][:treeConnectRequest['PathLength']]\n        UNCOrShare = path.decode('utf-16le')\n\n        # Is this a UNC?\n        if ntpath.ismount(UNCOrShare):\n            path = UNCOrShare.split('\\\\')[3]\n        else:\n            path = ntpath.basename(UNCOrShare)\n\n        share = searchShare(connId, path.upper(), smbServer)\n        if share is not None:\n            # Simple way to generate a Tid\n            if len(connData['ConnectedShares']) == 0:\n                tid = 1\n            else:\n                tid = list(connData['ConnectedShares'].keys())[-1] + 1\n            connData['ConnectedShares'][tid] = share\n            connData['ConnectedShares'][tid]['shareName'] = path\n            respPacket['TreeID'] = tid\n            smbServer.log(\"Connecting Share(%d:%s)\" % (tid, path))\n        else:\n            smbServer.log(\"SMB2_TREE_CONNECT not found %s\" % path, logging.ERROR)\n            errorCode = STATUS_OBJECT_PATH_NOT_FOUND\n            respPacket['Status'] = errorCode\n        ##\n\n        if path.upper() == 'IPC$':\n            respSMBCommand['ShareType'] = smb2.SMB2_SHARE_TYPE_PIPE\n            respSMBCommand['ShareFlags'] = 0x30\n        else:\n            respSMBCommand['ShareType'] = smb2.SMB2_SHARE_TYPE_DISK\n            respSMBCommand['ShareFlags'] = 0x0\n\n        respSMBCommand['Capabilities'] = 0\n        respSMBCommand['MaximalAccess'] = 0x000f01ff\n\n        respPacket['Data'] = respSMBCommand\n\n        # Sign the packet if needed\n        if connData['SignatureEnabled']:\n            smbServer.signSMBv2(respPacket, connData['SigningSessionKey'])\n        smbServer.setConnectionData(connId, connData)\n\n        return None, [respPacket], errorCode\n\n    @staticmethod\n    def smb2Create(connId, smbServer, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb2.SMB2Create_Response()\n\n        ntCreateRequest = smb2.SMB2Create(recvPacket['Data'])\n\n        respSMBCommand['Buffer'] = b'\\x00'\n        # Get the Tid associated\n        if recvPacket['TreeID'] in connData['ConnectedShares']:\n            # If we have a rootFid, the path is relative to that fid\n            errorCode = STATUS_SUCCESS\n            if 'path' in connData['ConnectedShares'][recvPacket['TreeID']]:\n                path = connData['ConnectedShares'][recvPacket['TreeID']]['path']\n            else:\n                path = 'NONE'\n                errorCode = STATUS_ACCESS_DENIED\n\n            deleteOnClose = False\n\n            fileName = os.path.normpath(\n                ntCreateRequest['Buffer'][:ntCreateRequest['NameLength']].decode('utf-16le').replace('\\\\', '/'))\n            if len(fileName) > 0 and (fileName[0] == '/' or fileName[0] == '\\\\'):\n                # strip leading '/'\n                fileName = fileName[1:]\n\n            if not isInFileJail(path, fileName):\n                LOG.error(\"Path not in current working directory\")\n                return [smb2.SMB2Error()], None, STATUS_OBJECT_PATH_SYNTAX_BAD\n\n            pathName = os.path.join(path, fileName)\n            createDisposition = ntCreateRequest['CreateDisposition']\n            mode = 0\n\n            if createDisposition == smb2.FILE_SUPERSEDE:\n                mode |= os.O_TRUNC | os.O_CREAT\n            elif createDisposition & smb2.FILE_OVERWRITE_IF == smb2.FILE_OVERWRITE_IF:\n                mode |= os.O_TRUNC | os.O_CREAT\n            elif createDisposition & smb2.FILE_OVERWRITE == smb2.FILE_OVERWRITE:\n                if os.path.exists(pathName) is True:\n                    mode |= os.O_TRUNC\n                else:\n                    errorCode = STATUS_NO_SUCH_FILE\n            elif createDisposition & smb2.FILE_OPEN_IF == smb2.FILE_OPEN_IF:\n                if os.path.exists(pathName) is True:\n                    mode |= os.O_TRUNC\n                else:\n                    mode |= os.O_TRUNC | os.O_CREAT\n            elif createDisposition & smb2.FILE_CREATE == smb2.FILE_CREATE:\n                if os.path.exists(pathName) is True:\n                    errorCode = STATUS_OBJECT_NAME_COLLISION\n                else:\n                    mode |= os.O_CREAT\n            elif createDisposition & smb2.FILE_OPEN == smb2.FILE_OPEN:\n                if os.path.exists(pathName) is not True and (\n                        str(pathName) in smbServer.getRegisteredNamedPipes()) is not True:\n                    errorCode = STATUS_NO_SUCH_FILE\n\n            if errorCode == STATUS_SUCCESS:\n                desiredAccess = ntCreateRequest['DesiredAccess']\n                if (desiredAccess & smb2.FILE_READ_DATA) or (desiredAccess & smb2.GENERIC_READ):\n                    mode |= os.O_RDONLY\n                if (desiredAccess & smb2.FILE_WRITE_DATA) or (desiredAccess & smb2.GENERIC_WRITE):\n                    if (desiredAccess & smb2.FILE_READ_DATA) or (desiredAccess & smb2.GENERIC_READ):\n                        mode |= os.O_RDWR  # | os.O_APPEND\n                    else:\n                        mode |= os.O_WRONLY  # | os.O_APPEND\n                if desiredAccess & smb2.GENERIC_ALL:\n                    mode |= os.O_RDWR  # | os.O_APPEND\n\n                createOptions = ntCreateRequest['CreateOptions']\n                if mode & os.O_CREAT == os.O_CREAT:\n                    if createOptions & smb2.FILE_DIRECTORY_FILE == smb2.FILE_DIRECTORY_FILE:\n                        try:\n                            # Let's create the directory\n                            os.mkdir(pathName)\n                            mode = os.O_RDONLY\n                        except Exception as e:\n                            smbServer.log(\"SMB2_CREATE: %s,%s,%s\" % (pathName, mode, e), logging.ERROR)\n                            errorCode = STATUS_ACCESS_DENIED\n                if createOptions & smb2.FILE_NON_DIRECTORY_FILE == smb2.FILE_NON_DIRECTORY_FILE:\n                    # If the file being opened is a directory, the server MUST fail the request with\n                    # STATUS_FILE_IS_A_DIRECTORY in the Status field of the SMB Header in the server\n                    # response.\n                    if os.path.isdir(pathName) is True:\n                        errorCode = STATUS_FILE_IS_A_DIRECTORY\n\n                if createOptions & smb2.FILE_DELETE_ON_CLOSE == smb2.FILE_DELETE_ON_CLOSE:\n                    deleteOnClose = True\n\n                if errorCode == STATUS_SUCCESS:\n                    try:\n                        if os.path.isdir(pathName) and sys.platform == 'win32':\n                            fid = VOID_FILE_DESCRIPTOR\n                        else:\n                            if sys.platform == 'win32':\n                                mode |= os.O_BINARY\n                            if str(pathName) in smbServer.getRegisteredNamedPipes():\n                                fid = PIPE_FILE_DESCRIPTOR\n                                sock = socket.socket()\n                                sock.connect(smbServer.getRegisteredNamedPipes()[str(pathName)])\n                            else:\n                                fid = os.open(pathName, mode)\n                    except Exception as e:\n                        smbServer.log(\"SMB2_CREATE: %s,%s,%s\" % (pathName, mode, e), logging.ERROR)\n                        # print e\n                        fid = 0\n                        errorCode = STATUS_ACCESS_DENIED\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        if errorCode == STATUS_SUCCESS:\n            # Simple way to generate a fid\n            fakefid = uuid.generate()\n\n            respSMBCommand['FileID'] = fakefid\n            respSMBCommand['CreateAction'] = createDisposition\n\n            if fid == PIPE_FILE_DESCRIPTOR:\n                respSMBCommand['CreationTime'] = 0\n                respSMBCommand['LastAccessTime'] = 0\n                respSMBCommand['LastWriteTime'] = 0\n                respSMBCommand['ChangeTime'] = 0\n                respSMBCommand['AllocationSize'] = 4096\n                respSMBCommand['EndOfFile'] = 0\n                respSMBCommand['FileAttributes'] = 0x80\n\n            else:\n                if os.path.isdir(pathName):\n                    respSMBCommand['FileAttributes'] = smb.SMB_FILE_ATTRIBUTE_DIRECTORY\n                else:\n                    respSMBCommand['FileAttributes'] = ntCreateRequest['FileAttributes']\n                # Let's get this file's information\n                respInfo, errorCode = queryPathInformation('', pathName, level=smb.SMB_QUERY_FILE_ALL_INFO)\n                if errorCode == STATUS_SUCCESS:\n                    respSMBCommand['CreationTime'] = respInfo['CreationTime']\n                    respSMBCommand['LastAccessTime'] = respInfo['LastAccessTime']\n                    respSMBCommand['LastWriteTime'] = respInfo['LastWriteTime']\n                    respSMBCommand['LastChangeTime'] = respInfo['LastChangeTime']\n                    respSMBCommand['FileAttributes'] = respInfo['ExtFileAttributes']\n                    respSMBCommand['AllocationSize'] = respInfo['AllocationSize']\n                    respSMBCommand['EndOfFile'] = respInfo['EndOfFile']\n\n            if errorCode == STATUS_SUCCESS:\n                # Let's store the fid for the connection\n                # smbServer.log('Create file %s, mode:0x%x' % (pathName, mode))\n                connData['OpenedFiles'][fakefid] = {}\n                connData['OpenedFiles'][fakefid]['FileHandle'] = fid\n                connData['OpenedFiles'][fakefid]['FileName'] = pathName\n                connData['OpenedFiles'][fakefid]['DeleteOnClose'] = deleteOnClose\n                connData['OpenedFiles'][fakefid]['Open'] = {}\n                connData['OpenedFiles'][fakefid]['Open']['EnumerationLocation'] = 0\n                connData['OpenedFiles'][fakefid]['Open']['EnumerationSearchPattern'] = ''\n                if fid == PIPE_FILE_DESCRIPTOR:\n                    connData['OpenedFiles'][fakefid]['Socket'] = sock\n        else:\n            respSMBCommand = smb2.SMB2Error()\n\n        if errorCode == STATUS_SUCCESS:\n            connData['LastRequest']['SMB2_CREATE'] = respSMBCommand\n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smb2Close(connId, smbServer, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb2.SMB2Close_Response()\n\n        closeRequest = smb2.SMB2Close(recvPacket['Data'])\n\n        if closeRequest['FileID'].getData() == b'\\xff' * 16:\n            # Let's take the data from the lastRequest\n            if 'SMB2_CREATE' in connData['LastRequest']:\n                fileID = connData['LastRequest']['SMB2_CREATE']['FileID']\n            else:\n                fileID = closeRequest['FileID'].getData()\n        else:\n            fileID = closeRequest['FileID'].getData()\n\n        if fileID in connData['OpenedFiles']:\n            errorCode = STATUS_SUCCESS\n            fileHandle = connData['OpenedFiles'][fileID]['FileHandle']\n            pathName = connData['OpenedFiles'][fileID]['FileName']\n            infoRecord = None\n            try:\n                if fileHandle == PIPE_FILE_DESCRIPTOR:\n                    connData['OpenedFiles'][fileID]['Socket'].close()\n                elif fileHandle != VOID_FILE_DESCRIPTOR:\n                    os.close(fileHandle)\n                    infoRecord, errorCode = queryFileInformation(os.path.dirname(pathName), os.path.basename(pathName),\n                                                                 smb2.SMB2_FILE_NETWORK_OPEN_INFO)\n            except Exception as e:\n                smbServer.log(\"SMB2_CLOSE %s\" % e, logging.ERROR)\n                errorCode = STATUS_INVALID_HANDLE\n            else:\n                # Check if the file was marked for removal\n                if connData['OpenedFiles'][fileID]['DeleteOnClose'] is True:\n                    try:\n                        if os.path.isdir(pathName):\n                            shutil.rmtree(connData['OpenedFiles'][fileID]['FileName'])\n                        else:\n                            os.remove(connData['OpenedFiles'][fileID]['FileName'])\n                    except Exception as e:\n                        smbServer.log(\"SMB2_CLOSE %s\" % e, logging.ERROR)\n                        errorCode = STATUS_ACCESS_DENIED\n\n                # Now fill out the response\n                if infoRecord is not None:\n                    respSMBCommand['CreationTime'] = infoRecord['CreationTime']\n                    respSMBCommand['LastAccessTime'] = infoRecord['LastAccessTime']\n                    respSMBCommand['LastWriteTime'] = infoRecord['LastWriteTime']\n                    respSMBCommand['ChangeTime'] = infoRecord['ChangeTime']\n                    respSMBCommand['AllocationSize'] = infoRecord['AllocationSize']\n                    respSMBCommand['EndofFile'] = infoRecord['EndOfFile']\n                    respSMBCommand['FileAttributes'] = infoRecord['FileAttributes']\n                if errorCode == STATUS_SUCCESS:\n                    del (connData['OpenedFiles'][fileID])\n        else:\n            errorCode = STATUS_INVALID_HANDLE\n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smb2QueryInfo(connId, smbServer, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb2.SMB2QueryInfo_Response()\n\n        queryInfo = smb2.SMB2QueryInfo(recvPacket['Data'])\n\n        errorCode = STATUS_SUCCESS\n\n        respSMBCommand['OutputBufferOffset'] = 0x48\n        respSMBCommand['Buffer'] = b'\\x00'\n\n        if queryInfo['FileID'].getData() == b'\\xff' * 16:\n            # Let's take the data from the lastRequest\n            if 'SMB2_CREATE' in connData['LastRequest']:\n                fileID = connData['LastRequest']['SMB2_CREATE']['FileID']\n            else:\n                fileID = queryInfo['FileID'].getData()\n        else:\n            fileID = queryInfo['FileID'].getData()\n\n        if recvPacket['TreeID'] in connData['ConnectedShares']:\n            if fileID in connData['OpenedFiles']:\n                fileName = connData['OpenedFiles'][fileID]['FileName']\n\n                if queryInfo['InfoType'] == smb2.SMB2_0_INFO_FILE:\n                    if queryInfo['FileInfoClass'] == smb2.SMB2_FILE_INTERNAL_INFO:\n                        # No need to call queryFileInformation, we have the data here\n                        infoRecord = smb2.FileInternalInformation()\n                        infoRecord['IndexNumber'] = fileID\n                    else:\n                        infoRecord, errorCode = queryFileInformation(os.path.dirname(fileName),\n                                                                     os.path.basename(fileName),\n                                                                     queryInfo['FileInfoClass'])\n                elif queryInfo['InfoType'] == smb2.SMB2_0_INFO_FILESYSTEM:\n                    if queryInfo['FileInfoClass'] == smb2.SMB2_FILE_EA_INFO:\n                        infoRecord = b'\\x00' * 4\n                    else:\n                        infoRecord = queryFsInformation(os.path.dirname(fileName), os.path.basename(fileName),\n                                                        queryInfo['FileInfoClass'])\n                elif queryInfo['InfoType'] == smb2.SMB2_0_INFO_SECURITY:\n                    # Failing for now, until we support it\n                    infoRecord = None\n                    errorCode = STATUS_ACCESS_DENIED\n                else:\n                    smbServer.log(\"queryInfo not supported (%x)\" % queryInfo['InfoType'], logging.ERROR)\n\n                if infoRecord is not None:\n                    respSMBCommand['OutputBufferLength'] = len(infoRecord)\n                    respSMBCommand['Buffer'] = infoRecord\n            else:\n                errorCode = STATUS_INVALID_HANDLE\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smb2SetInfo(connId, smbServer, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb2.SMB2SetInfo_Response()\n\n        setInfo = smb2.SMB2SetInfo(recvPacket['Data'])\n\n        errorCode = STATUS_SUCCESS\n\n        if setInfo['FileID'].getData() == b'\\xff' * 16:\n            # Let's take the data from the lastRequest\n            if 'SMB2_CREATE' in connData['LastRequest']:\n                fileID = connData['LastRequest']['SMB2_CREATE']['FileID']\n            else:\n                fileID = setInfo['FileID'].getData()\n        else:\n            fileID = setInfo['FileID'].getData()\n\n        if recvPacket['TreeID'] in connData['ConnectedShares']:\n            path = connData['ConnectedShares'][recvPacket['TreeID']]['path']\n            if fileID in connData['OpenedFiles']:\n                pathName = connData['OpenedFiles'][fileID]['FileName']\n\n                if setInfo['InfoType'] == smb2.SMB2_0_INFO_FILE:\n                    # The file information is being set\n                    informationLevel = setInfo['FileInfoClass']\n                    if informationLevel == smb2.SMB2_FILE_DISPOSITION_INFO:\n                        infoRecord = smb.SMBSetFileDispositionInfo(setInfo['Buffer'])\n                        if infoRecord['DeletePending'] > 0:\n                            # Mark this file for removal after closed\n                            connData['OpenedFiles'][fileID]['DeleteOnClose'] = True\n                    elif informationLevel == smb2.SMB2_FILE_BASIC_INFO:\n                        infoRecord = smb.SMBSetFileBasicInfo(setInfo['Buffer'])\n                        # Creation time won't be set,  the other ones we play with.\n                        atime = infoRecord['LastWriteTime']\n                        if atime == 0:\n                            atime = -1\n                        else:\n                            atime = getUnixTime(atime)\n                        mtime = infoRecord['ChangeTime']\n                        if mtime == 0:\n                            mtime = -1\n                        else:\n                            mtime = getUnixTime(mtime)\n                        if atime > 0 and mtime > 0:\n                            os.utime(pathName, (atime, mtime))\n                    elif informationLevel == smb2.SMB2_FILE_END_OF_FILE_INFO:\n                        fileHandle = connData['OpenedFiles'][fileID]['FileHandle']\n                        infoRecord = smb.SMBSetFileEndOfFileInfo(setInfo['Buffer'])\n                        if infoRecord['EndOfFile'] > 0:\n                            os.lseek(fileHandle, infoRecord['EndOfFile'] - 1, 0)\n                            os.write(fileHandle, b'\\x00')\n                    elif informationLevel == smb2.SMB2_FILE_RENAME_INFO:\n                        renameInfo = smb2.FILE_RENAME_INFORMATION_TYPE_2(setInfo['Buffer'])\n                        newPathName = os.path.join(path, renameInfo['FileName'].decode('utf-16le').replace('\\\\', '/'))\n                        if renameInfo['ReplaceIfExists'] == 0 and os.path.exists(newPathName):\n                            return [smb2.SMB2Error()], None, STATUS_OBJECT_NAME_COLLISION\n                        try:\n                            os.rename(pathName, newPathName)\n                            connData['OpenedFiles'][fileID]['FileName'] = newPathName\n                        except Exception as e:\n                            smbServer.log(\"smb2SetInfo: %s\" % e, logging.ERROR)\n                            errorCode = STATUS_ACCESS_DENIED\n                    else:\n                        smbServer.log('Unknown level for set file info! 0x%x' % informationLevel, logging.ERROR)\n                        # UNSUPPORTED\n                        errorCode = STATUS_NOT_SUPPORTED\n                # elif setInfo['InfoType'] == smb2.SMB2_0_INFO_FILESYSTEM:\n                #    # The underlying object store information is being set.\n                #    setInfo = queryFsInformation('/', fileName, queryInfo['FileInfoClass'])\n                # elif setInfo['InfoType'] == smb2.SMB2_0_INFO_SECURITY:\n                #    # The security information is being set.\n                #    # Failing for now, until we support it\n                #    infoRecord = None\n                #    errorCode = STATUS_ACCESS_DENIED\n                # elif setInfo['InfoType'] == smb2.SMB2_0_INFO_QUOTA:\n                #    # The underlying object store quota information is being set.\n                #    setInfo = queryFsInformation('/', fileName, queryInfo['FileInfoClass'])\n                else:\n                    smbServer.log(\"setInfo not supported (%x)\" % setInfo['InfoType'], logging.ERROR)\n\n            else:\n                errorCode = STATUS_INVALID_HANDLE\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smb2Write(connId, smbServer, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb2.SMB2Write_Response()\n        writeRequest = smb2.SMB2Write(recvPacket['Data'])\n\n        respSMBCommand['Buffer'] = b'\\x00'\n\n        if writeRequest['FileID'].getData() == b'\\xff' * 16:\n            # Let's take the data from the lastRequest\n            if 'SMB2_CREATE' in connData['LastRequest']:\n                fileID = connData['LastRequest']['SMB2_CREATE']['FileID']\n            else:\n                fileID = writeRequest['FileID'].getData()\n        else:\n            fileID = writeRequest['FileID'].getData()\n\n        if fileID in connData['OpenedFiles']:\n            fileHandle = connData['OpenedFiles'][fileID]['FileHandle']\n            errorCode = STATUS_SUCCESS\n            try:\n                if fileHandle != PIPE_FILE_DESCRIPTOR:\n                    offset = writeRequest['Offset']\n                    # If we're trying to write past the file end we just skip the write call (Vista does this)\n                    if os.lseek(fileHandle, 0, 2) >= offset:\n                        os.lseek(fileHandle, offset, 0)\n                        os.write(fileHandle, writeRequest['Buffer'])\n                else:\n                    sock = connData['OpenedFiles'][fileID]['Socket']\n                    sock.send(writeRequest['Buffer'])\n\n                respSMBCommand['Count'] = writeRequest['Length']\n                respSMBCommand['Remaining'] = 0xff\n            except Exception as e:\n                smbServer.log('SMB2_WRITE: %s' % e, logging.ERROR)\n                errorCode = STATUS_ACCESS_DENIED\n        else:\n            errorCode = STATUS_INVALID_HANDLE\n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smb2Read(connId, smbServer, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb2.SMB2Read_Response()\n        readRequest = smb2.SMB2Read(recvPacket['Data'])\n\n        respSMBCommand['Buffer'] = b'\\x00'\n\n        if readRequest['FileID'].getData() == b'\\xff' * 16:\n            # Let's take the data from the lastRequest\n            if 'SMB2_CREATE' in connData['LastRequest']:\n                fileID = connData['LastRequest']['SMB2_CREATE']['FileID']\n            else:\n                fileID = readRequest['FileID'].getData()\n        else:\n            fileID = readRequest['FileID'].getData()\n\n        if fileID in connData['OpenedFiles']:\n            fileHandle = connData['OpenedFiles'][fileID]['FileHandle']\n            errorCode = 0\n            try:\n                if fileHandle != PIPE_FILE_DESCRIPTOR:\n                    offset = readRequest['Offset']\n                    os.lseek(fileHandle, offset, 0)\n                    content = os.read(fileHandle, readRequest['Length'])\n                else:\n                    sock = connData['OpenedFiles'][fileID]['Socket']\n                    content = sock.recv(readRequest['Length'])\n\n                respSMBCommand['DataOffset'] = 0x50\n                respSMBCommand['DataLength'] = len(content)\n                respSMBCommand['DataRemaining'] = 0\n                respSMBCommand['Buffer'] = content\n            except Exception as e:\n                smbServer.log('SMB2_READ: %s ' % e, logging.ERROR)\n                errorCode = STATUS_ACCESS_DENIED\n        else:\n            errorCode = STATUS_INVALID_HANDLE\n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smb2Flush(connId, smbServer, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb2.SMB2Flush_Response()\n        flushRequest = smb2.SMB2Flush(recvPacket['Data'])\n\n        if flushRequest['FileID'].getData() in connData['OpenedFiles']:\n            fileHandle = connData['OpenedFiles'][flushRequest['FileID'].getData()]['FileHandle']\n            errorCode = STATUS_SUCCESS\n            try:\n                os.fsync(fileHandle)\n            except Exception as e:\n                smbServer.log(\"SMB2_FLUSH %s\" % e, logging.ERROR)\n                errorCode = STATUS_ACCESS_DENIED\n        else:\n            errorCode = STATUS_INVALID_HANDLE\n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smb2QueryDirectory(connId, smbServer, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n        respSMBCommand = smb2.SMB2QueryDirectory_Response()\n        queryDirectoryRequest = smb2.SMB2QueryDirectory(recvPacket['Data'])\n\n        respSMBCommand['Buffer'] = b'\\x00'\n\n        # The server MUST locate the tree connection, as specified in section 3.3.5.2.11.\n        if (recvPacket['TreeID'] in connData['ConnectedShares']) is False:\n            return [smb2.SMB2Error()], None, STATUS_NETWORK_NAME_DELETED\n\n        # Next, the server MUST locate the open for the directory to be queried\n        # If no open is found, the server MUST fail the request with STATUS_FILE_CLOSED\n        if queryDirectoryRequest['FileID'].getData() == b'\\xff' * 16:\n            # Let's take the data from the lastRequest\n            if 'SMB2_CREATE' in connData['LastRequest']:\n                fileID = connData['LastRequest']['SMB2_CREATE']['FileID']\n            else:\n                fileID = queryDirectoryRequest['FileID'].getData()\n        else:\n            fileID = queryDirectoryRequest['FileID'].getData()\n\n        if (fileID in connData['OpenedFiles']) is False:\n            return [smb2.SMB2Error()], None, STATUS_FILE_CLOSED\n\n        # If the open is not an open to a directory, the request MUST be failed\n        # with STATUS_INVALID_PARAMETER.\n        if os.path.isdir(connData['OpenedFiles'][fileID]['FileName']) is False:\n            return [smb2.SMB2Error()], None, STATUS_INVALID_PARAMETER\n\n        # If any other information class is specified in the FileInformationClass\n        # field of the SMB2 QUERY_DIRECTORY Request, the server MUST fail the\n        # operation with STATUS_INVALID_INFO_CLASS.\n        if queryDirectoryRequest['FileInformationClass'] not in (\n                smb2.FILE_DIRECTORY_INFORMATION, smb2.FILE_FULL_DIRECTORY_INFORMATION,\n                smb2.FILEID_FULL_DIRECTORY_INFORMATION,\n                smb2.FILE_BOTH_DIRECTORY_INFORMATION, smb2.FILEID_BOTH_DIRECTORY_INFORMATION,\n                smb2.FILENAMES_INFORMATION):\n            return [smb2.SMB2Error()], None, STATUS_INVALID_INFO_CLASS\n\n        # If SMB2_REOPEN is set in the Flags field of the SMB2 QUERY_DIRECTORY\n        # Request, the server SHOULD<326> set Open.EnumerationLocation to 0\n        # and Open.EnumerationSearchPattern to an empty string.\n        if queryDirectoryRequest['Flags'] & smb2.SMB2_REOPEN:\n            connData['OpenedFiles'][fileID]['Open']['EnumerationLocation'] = 0\n            connData['OpenedFiles'][fileID]['Open']['EnumerationSearchPattern'] = ''\n\n        # If SMB2_RESTART_SCANS is set in the Flags field of the SMB2\n        # QUERY_DIRECTORY Request, the server MUST set\n        # Open.EnumerationLocation to 0.\n        if queryDirectoryRequest['Flags'] & smb2.SMB2_RESTART_SCANS:\n            connData['OpenedFiles'][fileID]['Open']['EnumerationLocation'] = 0\n\n        # If Open.EnumerationLocation is 0 and Open.EnumerationSearchPattern\n        # is an empty string, then Open.EnumerationSearchPattern MUST be set\n        # to the search pattern specified in the SMB2 QUERY_DIRECTORY by\n        # FileNameOffset and FileNameLength. If FileNameLength is 0, the server\n        # SHOULD<327> set Open.EnumerationSearchPattern as \"*\" to search all entries.\n\n        pattern = queryDirectoryRequest['Buffer'].decode('utf-16le')\n        if connData['OpenedFiles'][fileID]['Open']['EnumerationLocation'] == 0 and \\\n                connData['OpenedFiles'][fileID]['Open']['EnumerationSearchPattern'] == '':\n            if pattern == '':\n                pattern = '*'\n            connData['OpenedFiles'][fileID]['Open']['EnumerationSearchPattern'] = pattern\n\n        # If SMB2_INDEX_SPECIFIED is set and FileNameLength is not zero,\n        # the server MUST set Open.EnumerationSearchPattern to the search pattern\n        # specified in the request by FileNameOffset and FileNameLength.\n        if queryDirectoryRequest['Flags'] & smb2.SMB2_INDEX_SPECIFIED and \\\n                queryDirectoryRequest['FileNameLength'] > 0:\n            connData['OpenedFiles'][fileID]['Open']['EnumerationSearchPattern'] = pattern\n\n        pathName = os.path.join(os.path.normpath(connData['OpenedFiles'][fileID]['FileName']), pattern)\n        searchResult, searchCount, errorCode = findFirst2(os.path.dirname(pathName),\n                                                          os.path.basename(pathName),\n                                                          queryDirectoryRequest['FileInformationClass'],\n                                                          smb.ATTR_DIRECTORY, isSMB2=True)\n\n        if errorCode != STATUS_SUCCESS:\n            return [smb2.SMB2Error()], None, errorCode\n\n        if searchCount > 2 and pattern == '*':\n            # strip . and ..\n            searchCount -= 2\n            searchResult = searchResult[2:]\n\n        if searchCount == 0 and connData['OpenedFiles'][fileID]['Open']['EnumerationLocation'] == 0:\n            return [smb2.SMB2Error()], None, STATUS_NO_SUCH_FILE\n\n        if connData['OpenedFiles'][fileID]['Open']['EnumerationLocation'] < 0:\n            return [smb2.SMB2Error()], None, STATUS_NO_MORE_FILES\n\n        totalData = 0\n        respData = b''\n        for nItem in range(connData['OpenedFiles'][fileID]['Open']['EnumerationLocation'], searchCount):\n            connData['OpenedFiles'][fileID]['Open']['EnumerationLocation'] += 1\n            if queryDirectoryRequest['Flags'] & smb2.SL_RETURN_SINGLE_ENTRY:\n                # If single entry is requested we must clear the NextEntryOffset\n                searchResult[nItem]['NextEntryOffset'] = 0\n            data = searchResult[nItem].getData()\n            lenData = len(data)\n            padLen = (8 - (lenData % 8)) % 8\n\n            if (totalData + lenData) >= queryDirectoryRequest['OutputBufferLength']:\n                connData['OpenedFiles'][fileID]['Open']['EnumerationLocation'] -= 1\n                break\n            else:\n                respData += data + b'\\x00' * padLen\n                totalData += lenData + padLen\n\n            if queryDirectoryRequest['Flags'] & smb2.SL_RETURN_SINGLE_ENTRY:\n                break\n\n        if connData['OpenedFiles'][fileID]['Open']['EnumerationLocation'] >= searchCount:\n            connData['OpenedFiles'][fileID]['Open']['EnumerationLocation'] = -1\n\n        respSMBCommand['OutputBufferOffset'] = 0x48\n        respSMBCommand['OutputBufferLength'] = totalData\n        respSMBCommand['Buffer'] = respData\n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smb2ChangeNotify(connId, smbServer, recvPacket):\n\n        return [smb2.SMB2Error()], None, STATUS_NOT_SUPPORTED\n\n    @staticmethod\n    def smb2Echo(connId, smbServer, recvPacket):\n\n        respSMBCommand = smb2.SMB2Echo_Response()\n\n        return [respSMBCommand], None, STATUS_SUCCESS\n\n    @staticmethod\n    def smb2TreeDisconnect(connId, smbServer, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb2.SMB2TreeDisconnect_Response()\n\n        if recvPacket['TreeID'] in connData['ConnectedShares']:\n            smbServer.log(\"Disconnecting Share(%d:%s)\" % (\n                recvPacket['TreeID'], connData['ConnectedShares'][recvPacket['TreeID']]['shareName']))\n            del (connData['ConnectedShares'][recvPacket['TreeID']])\n            errorCode = STATUS_SUCCESS\n        else:\n            # STATUS_SMB_BAD_TID\n            errorCode = STATUS_SMB_BAD_TID\n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smb2Logoff(connId, smbServer, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb2.SMB2Logoff_Response()\n\n        if recvPacket['SessionID'] != connData['Uid']:\n            # STATUS_SMB_BAD_UID\n            errorCode = STATUS_SMB_BAD_UID\n        else:\n            errorCode = STATUS_SUCCESS\n\n        connData['Uid'] = 0\n        connData['Authenticated'] = False\n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smb2Ioctl(connId, smbServer, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb2.SMB2Ioctl_Response()\n        ioctlRequest = smb2.SMB2Ioctl(recvPacket['Data'])\n\n        ioctls = smbServer.getIoctls()\n        if ioctlRequest['CtlCode'] in ioctls:\n            outputData, errorCode = ioctls[ioctlRequest['CtlCode']](connId, smbServer, ioctlRequest)\n            if errorCode == STATUS_SUCCESS:\n                respSMBCommand['CtlCode'] = ioctlRequest['CtlCode']\n                respSMBCommand['FileID'] = ioctlRequest['FileID']\n                respSMBCommand['InputOffset'] = 0\n                respSMBCommand['InputCount'] = 0\n                respSMBCommand['OutputOffset'] = 0x70\n                respSMBCommand['OutputCount'] = len(outputData)\n                respSMBCommand['Flags'] = 0\n                respSMBCommand['Buffer'] = outputData\n            else:\n                respSMBCommand = outputData\n        else:\n            smbServer.log(\"Ioctl not implemented command: 0x%x\" % ioctlRequest['CtlCode'], logging.DEBUG)\n            errorCode = STATUS_INVALID_DEVICE_REQUEST\n            respSMBCommand = smb2.SMB2Error()\n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smb2Lock(connId, smbServer, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb2.SMB2Lock_Response()\n\n        # I'm actually doing nothing.. just make MacOS happy ;)\n        errorCode = STATUS_SUCCESS\n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smb2Cancel(connId, smbServer, recvPacket):\n        # I'm actually doing nothing\n        return [smb2.SMB2Error()], None, STATUS_CANCELLED\n\n    @staticmethod\n    def default(connId, smbServer, recvPacket):\n        # By default we return an SMB Packet with error not implemented\n        smbServer.log(\"Not implemented command: 0x%x\" % recvPacket['Command'], logging.DEBUG)\n        return [smb2.SMB2Error()], None, STATUS_NOT_SUPPORTED\n\n\nclass Ioctls:\n    @staticmethod\n    def fsctlDfsGetReferrals(connId, smbServer, ioctlRequest):\n        return smb2.SMB2Error(), STATUS_FS_DRIVER_REQUIRED\n\n    @staticmethod\n    def fsctlPipeTransceive(connId, smbServer, ioctlRequest):\n        connData = smbServer.getConnectionData(connId)\n\n        ioctlResponse = ''\n\n        if ioctlRequest['FileID'].getData() in connData['OpenedFiles']:\n            fileHandle = connData['OpenedFiles'][ioctlRequest['FileID'].getData()]['FileHandle']\n            errorCode = STATUS_SUCCESS\n            try:\n                if fileHandle != PIPE_FILE_DESCRIPTOR:\n                    errorCode = STATUS_INVALID_DEVICE_REQUEST\n                else:\n                    sock = connData['OpenedFiles'][ioctlRequest['FileID'].getData()]['Socket']\n                    sock.sendall(ioctlRequest['Buffer'])\n                    ioctlResponse = sock.recv(ioctlRequest['MaxOutputResponse'])\n            except Exception as e:\n                smbServer.log('fsctlPipeTransceive: %s ' % e, logging.ERROR)\n                errorCode = STATUS_ACCESS_DENIED\n        else:\n            errorCode = STATUS_INVALID_DEVICE_REQUEST\n\n        smbServer.setConnectionData(connId, connData)\n        return ioctlResponse, errorCode\n\n    @staticmethod\n    def fsctlValidateNegotiateInfo(connId, smbServer, ioctlRequest):\n        connData = smbServer.getConnectionData(connId)\n\n        errorCode = STATUS_SUCCESS\n\n        validateNegotiateInfo = smb2.VALIDATE_NEGOTIATE_INFO(ioctlRequest['Buffer'])\n        validateNegotiateInfoResponse = smb2.VALIDATE_NEGOTIATE_INFO_RESPONSE()\n        validateNegotiateInfoResponse['Capabilities'] = 0\n        validateNegotiateInfoResponse['Guid'] = b'A' * 16\n        validateNegotiateInfoResponse['SecurityMode'] = 1\n        validateNegotiateInfoResponse['Dialect'] = smb2.SMB2_DIALECT_002\n\n        smbServer.setConnectionData(connId, connData)\n        return validateNegotiateInfoResponse.getData(), errorCode\n\n\nclass SMBSERVERHandler(socketserver.BaseRequestHandler):\n    def __init__(self, request, client_address, server, select_poll=False):\n        self.__SMB = server\n        # In case of AF_INET6 the client_address contains 4 items, ignore the last 2\n        self.__ip, self.__port = client_address[:2]\n        self.__request = request\n        self.__connId = threading.currentThread().getName()\n        self.__timeOut = 60 * 5\n        self.__select_poll = select_poll\n        # self.__connId = os.getpid()\n        socketserver.BaseRequestHandler.__init__(self, request, client_address, server)\n\n    def handle(self):\n        self.__SMB.log(\"Incoming connection (%s,%d)\" % (self.__ip, self.__port))\n        self.__SMB.addConnection(self.__connId, self.__ip, self.__port)\n        while True:\n            try:\n                # First of all let's get the NETBIOS packet\n                session = nmb.NetBIOSTCPSession(self.__SMB.getServerName(), 'HOST', self.__ip, sess_port=self.__port,\n                                                sock=self.__request, select_poll=self.__select_poll)\n                try:\n                    p = session.recv_packet(self.__timeOut)\n                except nmb.NetBIOSTimeout:\n                    raise\n                except nmb.NetBIOSError:\n                    break\n\n                if p.get_type() == nmb.NETBIOS_SESSION_REQUEST:\n                    # Someone is requesting a session, we're gonna accept them all :)\n                    _, rn, my = p.get_trailer().split(b' ')\n                    remote_name = nmb.decode_name(b'\\x20' + rn)\n                    myname = nmb.decode_name(b'\\x20' + my)\n                    self.__SMB.log(\n                        \"NetBIOS Session request (%s,%s,%s)\" % (self.__ip, remote_name[1].strip(), myname[1]))\n                    r = nmb.NetBIOSSessionPacket()\n                    r.set_type(nmb.NETBIOS_SESSION_POSITIVE_RESPONSE)\n                    r.set_trailer(p.get_trailer())\n                    self.__request.send(r.rawData())\n                else:\n                    resp = self.__SMB.processRequest(self.__connId, p.get_trailer())\n                    # Send all the packets received. Except for big transactions this should be\n                    # a single packet\n                    for i in resp:\n                        if hasattr(i, 'getData'):\n                            session.send_packet(i.getData())\n                        else:\n                            session.send_packet(i)\n            except Exception as e:\n                self.__SMB.log(\"Handle: %s\" % e)\n                # import traceback\n                # traceback.print_exc()\n                break\n\n    def finish(self):\n        # Thread/process is dying, we should tell the main SMB thread to remove all this thread data\n        self.__SMB.log(\"Closing down connection (%s,%d)\" % (self.__ip, self.__port))\n        self.__SMB.removeConnection(self.__connId)\n        return socketserver.BaseRequestHandler.finish(self)\n\n\nclass SMBSERVER(socketserver.ThreadingMixIn, socketserver.TCPServer):\n    # class SMBSERVER(socketserver.ForkingMixIn, socketserver.TCPServer):\n    def __init__(self, server_address, handler_class=SMBSERVERHandler, config_parser=None):\n        socketserver.TCPServer.allow_reuse_address = True\n        socketserver.TCPServer.__init__(self, server_address, handler_class)\n\n        # Server name and OS to be presented whenever is necessary\n        self.__serverName = ''\n        self.__serverOS = ''\n        self.__serverDomain = ''\n        self.__challenge = ''\n        self.__log = None\n\n        # Our ConfigParser data\n        self.__serverConfig = config_parser\n\n        # Our credentials to be used during the server's lifetime\n        self.__credentials = {}\n\n        # Our log file\n        self.__logFile = ''\n\n        # Registered Named Pipes, format is PipeName,Socket\n        self.__registeredNamedPipes = {}\n\n        # JTR dump path\n        self.__jtr_dump_path = ''\n\n        # SMB2 Support flag = default not active\n        self.__SMB2Support = False\n\n        # Our list of commands we will answer, by default the NOT IMPLEMENTED one\n        self.__smbCommandsHandler = SMBCommands()\n        self.__smbTrans2Handler = TRANS2Commands()\n        self.__smbTransHandler = TRANSCommands()\n        self.__smbNTTransHandler = NTTRANSCommands()\n        self.__smb2CommandsHandler = SMB2Commands()\n        self.__IoctlHandler = Ioctls()\n\n        self.__smbNTTransCommands = {\n            # NT IOCTL, can't find doc for this\n            0xff: self.__smbNTTransHandler.default\n        }\n\n        self.__smbTransCommands = {\n            '\\\\PIPE\\\\LANMAN': self.__smbTransHandler.lanMan,\n            smb.SMB.TRANS_TRANSACT_NMPIPE: self.__smbTransHandler.transactNamedPipe,\n        }\n        self.__smbTrans2Commands = {\n            smb.SMB.TRANS2_FIND_FIRST2: self.__smbTrans2Handler.findFirst2,\n            smb.SMB.TRANS2_FIND_NEXT2: self.__smbTrans2Handler.findNext2,\n            smb.SMB.TRANS2_QUERY_FS_INFORMATION: self.__smbTrans2Handler.queryFsInformation,\n            smb.SMB.TRANS2_QUERY_PATH_INFORMATION: self.__smbTrans2Handler.queryPathInformation,\n            smb.SMB.TRANS2_QUERY_FILE_INFORMATION: self.__smbTrans2Handler.queryFileInformation,\n            smb.SMB.TRANS2_SET_FILE_INFORMATION: self.__smbTrans2Handler.setFileInformation,\n            smb.SMB.TRANS2_SET_PATH_INFORMATION: self.__smbTrans2Handler.setPathInformation\n        }\n\n        self.__smbCommands = {\n            # smb.SMB.SMB_COM_FLUSH:              self.__smbCommandsHandler.smbComFlush,\n            smb.SMB.SMB_COM_CREATE_DIRECTORY: self.__smbCommandsHandler.smbComCreateDirectory,\n            smb.SMB.SMB_COM_DELETE_DIRECTORY: self.__smbCommandsHandler.smbComDeleteDirectory,\n            smb.SMB.SMB_COM_RENAME: self.__smbCommandsHandler.smbComRename,\n            smb.SMB.SMB_COM_DELETE: self.__smbCommandsHandler.smbComDelete,\n            smb.SMB.SMB_COM_NEGOTIATE: self.__smbCommandsHandler.smbComNegotiate,\n            smb.SMB.SMB_COM_SESSION_SETUP_ANDX: self.__smbCommandsHandler.smbComSessionSetupAndX,\n            smb.SMB.SMB_COM_LOGOFF_ANDX: self.__smbCommandsHandler.smbComLogOffAndX,\n            smb.SMB.SMB_COM_TREE_CONNECT_ANDX: self.__smbCommandsHandler.smbComTreeConnectAndX,\n            smb.SMB.SMB_COM_TREE_DISCONNECT: self.__smbCommandsHandler.smbComTreeDisconnect,\n            smb.SMB.SMB_COM_ECHO: self.__smbCommandsHandler.smbComEcho,\n            smb.SMB.SMB_COM_QUERY_INFORMATION: self.__smbCommandsHandler.smbQueryInformation,\n            smb.SMB.SMB_COM_TRANSACTION2: self.__smbCommandsHandler.smbTransaction2,\n            smb.SMB.SMB_COM_TRANSACTION: self.__smbCommandsHandler.smbTransaction,\n            # Not needed for now\n            smb.SMB.SMB_COM_NT_TRANSACT: self.__smbCommandsHandler.smbNTTransact,\n            smb.SMB.SMB_COM_QUERY_INFORMATION_DISK: self.__smbCommandsHandler.smbQueryInformationDisk,\n            smb.SMB.SMB_COM_OPEN_ANDX: self.__smbCommandsHandler.smbComOpenAndX,\n            smb.SMB.SMB_COM_QUERY_INFORMATION2: self.__smbCommandsHandler.smbComQueryInformation2,\n            smb.SMB.SMB_COM_READ_ANDX: self.__smbCommandsHandler.smbComReadAndX,\n            smb.SMB.SMB_COM_READ: self.__smbCommandsHandler.smbComRead,\n            smb.SMB.SMB_COM_WRITE_ANDX: self.__smbCommandsHandler.smbComWriteAndX,\n            smb.SMB.SMB_COM_WRITE: self.__smbCommandsHandler.smbComWrite,\n            smb.SMB.SMB_COM_CLOSE: self.__smbCommandsHandler.smbComClose,\n            smb.SMB.SMB_COM_LOCKING_ANDX: self.__smbCommandsHandler.smbComLockingAndX,\n            smb.SMB.SMB_COM_NT_CREATE_ANDX: self.__smbCommandsHandler.smbComNtCreateAndX,\n            0xFF: self.__smbCommandsHandler.default\n        }\n\n        self.__smb2Ioctls = {\n            smb2.FSCTL_DFS_GET_REFERRALS: self.__IoctlHandler.fsctlDfsGetReferrals,\n            # smb2.FSCTL_PIPE_PEEK:                    self.__IoctlHandler.fsctlPipePeek,\n            # smb2.FSCTL_PIPE_WAIT:                    self.__IoctlHandler.fsctlPipeWait,\n            smb2.FSCTL_PIPE_TRANSCEIVE: self.__IoctlHandler.fsctlPipeTransceive,\n            # smb2.FSCTL_SRV_COPYCHUNK:                self.__IoctlHandler.fsctlSrvCopyChunk,\n            # smb2.FSCTL_SRV_ENUMERATE_SNAPSHOTS:      self.__IoctlHandler.fsctlSrvEnumerateSnapshots,\n            # smb2.FSCTL_SRV_REQUEST_RESUME_KEY:       self.__IoctlHandler.fsctlSrvRequestResumeKey,\n            # smb2.FSCTL_SRV_READ_HASH:                self.__IoctlHandler.fsctlSrvReadHash,\n            # smb2.FSCTL_SRV_COPYCHUNK_WRITE:          self.__IoctlHandler.fsctlSrvCopyChunkWrite,\n            # smb2.FSCTL_LMR_REQUEST_RESILIENCY:       self.__IoctlHandler.fsctlLmrRequestResiliency,\n            # smb2.FSCTL_QUERY_NETWORK_INTERFACE_INFO: self.__IoctlHandler.fsctlQueryNetworkInterfaceInfo,\n            # smb2.FSCTL_SET_REPARSE_POINT:            self.__IoctlHandler.fsctlSetReparsePoint,\n            # smb2.FSCTL_DFS_GET_REFERRALS_EX:         self.__IoctlHandler.fsctlDfsGetReferralsEx,\n            # smb2.FSCTL_FILE_LEVEL_TRIM:              self.__IoctlHandler.fsctlFileLevelTrim,\n            smb2.FSCTL_VALIDATE_NEGOTIATE_INFO: self.__IoctlHandler.fsctlValidateNegotiateInfo,\n        }\n\n        self.__smb2Commands = {\n            smb2.SMB2_NEGOTIATE: self.__smb2CommandsHandler.smb2Negotiate,\n            smb2.SMB2_SESSION_SETUP: self.__smb2CommandsHandler.smb2SessionSetup,\n            smb2.SMB2_LOGOFF: self.__smb2CommandsHandler.smb2Logoff,\n            smb2.SMB2_TREE_CONNECT: self.__smb2CommandsHandler.smb2TreeConnect,\n            smb2.SMB2_TREE_DISCONNECT: self.__smb2CommandsHandler.smb2TreeDisconnect,\n            smb2.SMB2_CREATE: self.__smb2CommandsHandler.smb2Create,\n            smb2.SMB2_CLOSE: self.__smb2CommandsHandler.smb2Close,\n            smb2.SMB2_FLUSH: self.__smb2CommandsHandler.smb2Flush,\n            smb2.SMB2_READ: self.__smb2CommandsHandler.smb2Read,\n            smb2.SMB2_WRITE: self.__smb2CommandsHandler.smb2Write,\n            smb2.SMB2_LOCK: self.__smb2CommandsHandler.smb2Lock,\n            smb2.SMB2_IOCTL: self.__smb2CommandsHandler.smb2Ioctl,\n            smb2.SMB2_CANCEL: self.__smb2CommandsHandler.smb2Cancel,\n            smb2.SMB2_ECHO: self.__smb2CommandsHandler.smb2Echo,\n            smb2.SMB2_QUERY_DIRECTORY: self.__smb2CommandsHandler.smb2QueryDirectory,\n            smb2.SMB2_CHANGE_NOTIFY: self.__smb2CommandsHandler.smb2ChangeNotify,\n            smb2.SMB2_QUERY_INFO: self.__smb2CommandsHandler.smb2QueryInfo,\n            smb2.SMB2_SET_INFO: self.__smb2CommandsHandler.smb2SetInfo,\n            # smb2.SMB2_OPLOCK_BREAK:    self.__smb2CommandsHandler.smb2SessionSetup,\n            0xFF: self.__smb2CommandsHandler.default\n        }\n\n        # List of active connections\n        self.__activeConnections = {}\n\n    def getIoctls(self):\n        return self.__smb2Ioctls\n\n    def getCredentials(self):\n        return self.__credentials\n\n    def removeConnection(self, name):\n        try:\n            del (self.__activeConnections[name])\n        except:\n            pass\n        self.log(\"Remaining connections %s\" % list(self.__activeConnections.keys()))\n\n    def addConnection(self, name, ip, port):\n        self.__activeConnections[name] = {}\n        # Let's init with some know stuff we will need to have\n        # TODO: Document what's in there\n        # print \"Current Connections\", self.__activeConnections.keys()\n        self.__activeConnections[name]['PacketNum'] = 0\n        self.__activeConnections[name]['ClientIP'] = ip\n        self.__activeConnections[name]['ClientPort'] = port\n        self.__activeConnections[name]['Uid'] = 0\n        self.__activeConnections[name]['ConnectedShares'] = {}\n        self.__activeConnections[name]['OpenedFiles'] = {}\n        # SID results for findfirst2\n        self.__activeConnections[name]['SIDs'] = {}\n        self.__activeConnections[name]['LastRequest'] = {}\n        self.__activeConnections[name]['SignatureEnabled'] = False\n        self.__activeConnections[name]['SigningChallengeResponse'] = ''\n        self.__activeConnections[name]['SigningSessionKey'] = b''\n        self.__activeConnections[name]['Authenticated'] = False\n\n    def getActiveConnections(self):\n        return self.__activeConnections\n\n    def setConnectionData(self, connId, data):\n        self.__activeConnections[connId] = data\n        # print \"setConnectionData\"\n        # print self.__activeConnections\n\n    def getConnectionData(self, connId, checkStatus=True):\n        conn = self.__activeConnections[connId]\n        if checkStatus is True:\n            if ('Authenticated' in conn) is not True:\n                # Can't keep going further\n                raise Exception(\"User not Authenticated!\")\n        return conn\n\n    def getRegisteredNamedPipes(self):\n        return self.__registeredNamedPipes\n\n    def registerNamedPipe(self, pipeName, address):\n        self.__registeredNamedPipes[str(pipeName)] = address\n        return True\n\n    def unregisterNamedPipe(self, pipeName):\n        if pipeName in self.__registeredNamedPipes:\n            del (self.__registeredNamedPipes[str(pipeName)])\n            return True\n        return False\n\n    def unregisterTransaction(self, transCommand):\n        if transCommand in self.__smbTransCommands:\n            del (self.__smbTransCommands[transCommand])\n\n    def hookTransaction(self, transCommand, callback):\n        # If you call this function, callback will replace\n        # the current Transaction sub command.\n        # (don't get confused with the Transaction smbCommand)\n        # If the transaction sub command doesn't not exist, it is added\n        # If the transaction sub command exists, it returns the original function         # replaced\n        #\n        # callback MUST be declared as:\n        # callback(connId, smbServer, recvPacket, parameters, data, maxDataCount=0)\n        #\n        # WHERE:\n        #\n        # connId      : the connection Id, used to grab/update information about\n        #               the current connection\n        # smbServer   : the SMBServer instance available for you to ask\n        #               configuration data\n        # recvPacket  : the full SMBPacket that triggered this command\n        # parameters  : the transaction parameters\n        # data        : the transaction data\n        # maxDataCount: the max amount of data that can be transferred agreed\n        #               with the client\n        #\n        # and MUST return:\n        # respSetup, respParameters, respData, errorCode\n        #\n        # WHERE:\n        #\n        # respSetup: the setup response of the transaction\n        # respParameters: the parameters response of the transaction\n        # respData: the data response of the transaction\n        # errorCode: the NT error code\n\n        if transCommand in self.__smbTransCommands:\n            originalCommand = self.__smbTransCommands[transCommand]\n        else:\n            originalCommand = None\n\n        self.__smbTransCommands[transCommand] = callback\n        return originalCommand\n\n    def unregisterTransaction2(self, transCommand):\n        if transCommand in self.__smbTrans2Commands:\n            del (self.__smbTrans2Commands[transCommand])\n\n    def hookTransaction2(self, transCommand, callback):\n        # Here we should add to __smbTrans2Commands\n        # Same description as Transaction\n        if transCommand in self.__smbTrans2Commands:\n            originalCommand = self.__smbTrans2Commands[transCommand]\n        else:\n            originalCommand = None\n\n        self.__smbTrans2Commands[transCommand] = callback\n        return originalCommand\n\n    def unregisterNTTransaction(self, transCommand):\n        if transCommand in self.__smbNTTransCommands:\n            del (self.__smbNTTransCommands[transCommand])\n\n    def hookNTTransaction(self, transCommand, callback):\n        # Here we should add to __smbNTTransCommands\n        # Same description as Transaction\n        if transCommand in self.__smbNTTransCommands:\n            originalCommand = self.__smbNTTransCommands[transCommand]\n        else:\n            originalCommand = None\n\n        self.__smbNTTransCommands[transCommand] = callback\n        return originalCommand\n\n    def unregisterSmbCommand(self, smbCommand):\n        if smbCommand in self.__smbCommands:\n            del (self.__smbCommands[smbCommand])\n\n    def hookSmbCommand(self, smbCommand, callback):\n        # Here we should add to self.__smbCommands\n        # If you call this function, callback will replace\n        # the current smbCommand.\n        # If smbCommand doesn't not exist, it is added\n        # If SMB command exists, it returns the original function replaced\n        #\n        # callback MUST be declared as:\n        # callback(connId, smbServer, SMBCommand, recvPacket)\n        #\n        # WHERE:\n        #\n        # connId    : the connection Id, used to grab/update information about\n        #             the current connection\n        # smbServer : the SMBServer instance available for you to ask\n        #             configuration data\n        # SMBCommand: the SMBCommand itself, with its data and parameters.\n        #             Check smb.py:SMBCommand() for a reference\n        # recvPacket: the full SMBPacket that triggered this command\n        #\n        # and MUST return:\n        # <list of respSMBCommands>, <list of packets>, errorCode\n        # <list of packets> has higher preference over commands, in case you\n        # want to change the whole packet\n        # errorCode: the NT error code\n        #\n        # For SMB_COM_TRANSACTION2, SMB_COM_TRANSACTION and SMB_COM_NT_TRANSACT\n        # the callback function is slightly different:\n        #\n        # callback(connId, smbServer, SMBCommand, recvPacket, transCommands)\n        #\n        # WHERE:\n        #\n        # transCommands: a list of transaction subcommands already registered\n        #\n\n        if smbCommand in self.__smbCommands:\n            originalCommand = self.__smbCommands[smbCommand]\n        else:\n            originalCommand = None\n\n        self.__smbCommands[smbCommand] = callback\n        return originalCommand\n\n    def unregisterSmb2Command(self, smb2Command):\n        if smb2Command in self.__smb2Commands:\n            del (self.__smb2Commands[smb2Command])\n\n    def hookSmb2Command(self, smb2Command, callback):\n        if smb2Command in self.__smb2Commands:\n            originalCommand = self.__smb2Commands[smb2Command]\n        else:\n            originalCommand = None\n\n        self.__smb2Commands[smb2Command] = callback\n        return originalCommand\n\n    def log(self, msg, level=logging.INFO):\n        self.__log.log(level, msg)\n\n    def getServerName(self):\n        return self.__serverName\n\n    def getServerOS(self):\n        return self.__serverOS\n\n    def getServerDomain(self):\n        return self.__serverDomain\n\n    def getSMBChallenge(self):\n        return self.__challenge\n\n    def getServerConfig(self):\n        return self.__serverConfig\n\n    def setServerConfig(self, config):\n        self.__serverConfig = config\n\n    def getJTRdumpPath(self):\n        return self.__jtr_dump_path\n\n    def verify_request(self, request, client_address):\n        # TODO: Control here the max amount of processes we want to launch\n        # returning False, closes the connection\n        return True\n\n    def signSMBv1(self, connData, packet, signingSessionKey, signingChallengeResponse):\n        # This logic MUST be applied for messages sent in response to any of the higher-layer actions and in\n        # compliance with the message sequencing rules.\n        #  * The client or server that sends the message MUST provide the 32-bit sequence number for this\n        #    message, as specified in sections 3.2.4.1 and 3.3.4.1.\n        #  * The SMB_FLAGS2_SMB_SECURITY_SIGNATURE flag in the header MUST be set.\n        #  * To generate the signature, a 32-bit sequence number is copied into the\n        #    least significant 32 bits of the SecuritySignature field and the remaining\n        #    4 bytes are set to 0x00.\n        #  * The MD5 algorithm, as specified in [RFC1321], MUST be used to generate a hash of the SMB\n        #    message from the start of the SMB Header, which is defined as follows.\n        #    CALL MD5Init( md5context )\n        #    CALL MD5Update( md5context, Connection.SigningSessionKey )\n        #    CALL MD5Update( md5context, Connection.SigningChallengeResponse )\n        #    CALL MD5Update( md5context, SMB message )\n        #    CALL MD5Final( digest, md5context )\n        #    SET signature TO the first 8 bytes of the digest\n        # The resulting 8-byte signature MUST be copied into the SecuritySignature field of the SMB Header,\n        # after which the message can be transmitted.\n\n        # print \"seq(%d) signingSessionKey %r, signingChallengeResponse %r\" % (connData['SignSequenceNumber'], signingSessionKey, signingChallengeResponse)\n        packet['SecurityFeatures'] = struct.pack('<q', connData['SignSequenceNumber'])\n        # Sign with the sequence\n        m = hashlib.md5()\n        m.update(signingSessionKey)\n        m.update(signingChallengeResponse)\n        if hasattr(packet, 'getData'):\n            m.update(packet.getData())\n        else:\n            m.update(packet)\n        # Replace sequence with acual hash\n        packet['SecurityFeatures'] = m.digest()[:8]\n        connData['SignSequenceNumber'] += 2\n\n    def signSMBv2(self, packet, signingSessionKey):\n        packet['Signature'] = b'\\x00' * 16\n        packet['Flags'] |= smb2.SMB2_FLAGS_SIGNED\n        signature = hmac.new(signingSessionKey, packet.getData(), hashlib.sha256).digest()\n        packet['Signature'] = signature[:16]\n        # print \"%s\" % packet['Signature'].encode('hex')\n\n    def processRequest(self, connId, data):\n\n        # TODO: Process batched commands.\n        isSMB2 = False\n        SMBCommand = None\n        try:\n            packet = smb.NewSMBPacket(data=data)\n            SMBCommand = smb.SMBCommand(packet['Data'][0])\n        except:\n            # Maybe a SMB2 packet?\n            packet = smb2.SMB2Packet(data=data)\n            connData = self.getConnectionData(connId, False)\n            self.signSMBv2(packet, connData['SigningSessionKey'])\n            isSMB2 = True\n\n        connData = self.getConnectionData(connId, False)\n\n        # We might have compound requests\n        compoundedPacketsResponse = []\n        compoundedPackets = []\n        try:\n            # Search out list of implemented commands\n            # We provide them with:\n            # connId      : representing the data for this specific connection\n            # self        : the SMBSERVER if they want to ask data to it\n            # SMBCommand  : the SMBCommand they are expecting to process\n            # packet      : the received packet itself, in case they need more data than the actual command\n            # Only for Transactions\n            # transCommand: a list of transaction subcommands\n            # We expect to get:\n            # respCommands: a list of answers for the commands processed\n            # respPacket  : if the commands chose to directly craft packet/s, we use this and not the previous\n            #               this MUST be a list\n            # errorCode   : self explanatory\n            if isSMB2 is False:\n                # Is the client authenticated already?\n                if connData['Authenticated'] is False and packet['Command'] not in (\n                smb.SMB.SMB_COM_NEGOTIATE, smb.SMB.SMB_COM_SESSION_SETUP_ANDX):\n                    # Nope.. in that case he should only ask for a few commands, if not throw him out.\n                    errorCode = STATUS_ACCESS_DENIED\n                    respPackets = None\n                    respCommands = [smb.SMBCommand(packet['Command'])]\n                else:\n                    if packet['Command'] == smb.SMB.SMB_COM_TRANSACTION2:\n                        respCommands, respPackets, errorCode = self.__smbCommands[packet['Command']](\n                            connId,\n                            self,\n                            SMBCommand,\n                            packet,\n                            self.__smbTrans2Commands)\n                    elif packet['Command'] == smb.SMB.SMB_COM_NT_TRANSACT:\n                        respCommands, respPackets, errorCode = self.__smbCommands[packet['Command']](\n                            connId,\n                            self,\n                            SMBCommand,\n                            packet,\n                            self.__smbNTTransCommands)\n                    elif packet['Command'] == smb.SMB.SMB_COM_TRANSACTION:\n                        respCommands, respPackets, errorCode = self.__smbCommands[packet['Command']](\n                            connId,\n                            self,\n                            SMBCommand,\n                            packet,\n                            self.__smbTransCommands)\n                    else:\n                        if packet['Command'] in self.__smbCommands:\n                            if self.__SMB2Support is True:\n                                if packet['Command'] == smb.SMB.SMB_COM_NEGOTIATE:\n                                    try:\n                                        respCommands, respPackets, errorCode = self.__smb2Commands[smb2.SMB2_NEGOTIATE](\n                                            connId, self, packet, True)\n                                        isSMB2 = True\n                                    except Exception as e:\n                                        import traceback\n                                        traceback.print_exc()\n                                        self.log('SMB2_NEGOTIATE: %s' % e, logging.ERROR)\n                                        # If something went wrong, let's fallback to SMB1\n                                        respCommands, respPackets, errorCode = self.__smbCommands[packet['Command']](\n                                            connId,\n                                            self,\n                                            SMBCommand,\n                                            packet)\n                                        # self.__SMB2Support = False\n                                        pass\n                                else:\n                                    respCommands, respPackets, errorCode = self.__smbCommands[packet['Command']](\n                                        connId,\n                                        self,\n                                        SMBCommand,\n                                        packet)\n                            else:\n                                respCommands, respPackets, errorCode = self.__smbCommands[packet['Command']](\n                                    connId,\n                                    self,\n                                    SMBCommand,\n                                    packet)\n                        else:\n                            respCommands, respPackets, errorCode = self.__smbCommands[255](connId, self, SMBCommand,\n                                                                                           packet)\n\n                compoundedPacketsResponse.append((respCommands, respPackets, errorCode))\n                compoundedPackets.append(packet)\n\n            else:\n                # Is the client authenticated already?\n                if connData['Authenticated'] is False and packet['Command'] not in (\n                smb2.SMB2_NEGOTIATE, smb2.SMB2_SESSION_SETUP):\n                    # Nope.. in that case he should only ask for a few commands, if not throw him out.\n                    errorCode = STATUS_ACCESS_DENIED\n                    respPackets = None\n                    respCommands = ['']\n                    compoundedPacketsResponse.append((respCommands, respPackets, errorCode))\n                    compoundedPackets.append(packet)\n                else:\n                    done = False\n                    while not done:\n                        if packet['Command'] in self.__smb2Commands:\n                            if self.__SMB2Support is True:\n                                respCommands, respPackets, errorCode = self.__smb2Commands[packet['Command']](\n                                    connId,\n                                    self,\n                                    packet)\n                            else:\n                                respCommands, respPackets, errorCode = self.__smb2Commands[255](connId, self, packet)\n                        else:\n                            respCommands, respPackets, errorCode = self.__smb2Commands[255](connId, self, packet)\n                        # Let's store the result for this compounded packet\n                        compoundedPacketsResponse.append((respCommands, respPackets, errorCode))\n                        compoundedPackets.append(packet)\n                        if packet['NextCommand'] != 0:\n                            data = data[packet['NextCommand']:]\n                            packet = smb2.SMB2Packet(data=data)\n                        else:\n                            done = True\n\n        except Exception as e:\n            # import traceback\n            # traceback.print_exc()\n            # Something wen't wrong, defaulting to Bad user ID\n            self.log('processRequest (0x%x,%s)' % (packet['Command'], e), logging.ERROR)\n            raise\n\n        # We prepare the response packet to commands don't need to bother about that.\n        connData = self.getConnectionData(connId, False)\n\n        # Force reconnection loop.. This is just a test.. client will send me back credentials :)\n        # connData['PacketNum'] += 1\n        # if connData['PacketNum'] == 15:\n        #    connData['PacketNum'] = 0\n        #    # Something wen't wrong, defaulting to Bad user ID\n        #    self.log('Sending BAD USER ID!', logging.ERROR)\n        #    #raise\n        #    packet['Flags1'] |= smb.SMB.FLAGS1_REPLY\n        #    packet['Flags2'] = 0\n        #    errorCode = STATUS_SMB_BAD_UID\n        #    packet['ErrorCode']   = errorCode >> 16\n        #    packet['ErrorClass']  = errorCode & 0xff\n        #    return [packet]\n\n        self.setConnectionData(connId, connData)\n\n        packetsToSend = []\n        for packetNum in range(len(compoundedPacketsResponse)):\n            respCommands, respPackets, errorCode = compoundedPacketsResponse[packetNum]\n            packet = compoundedPackets[packetNum]\n            if respPackets is None:\n                for respCommand in respCommands:\n                    if isSMB2 is False:\n                        respPacket = smb.NewSMBPacket()\n                        respPacket['Flags1'] = smb.SMB.FLAGS1_REPLY\n\n                        # TODO this should come from a per session configuration\n                        respPacket[\n                            'Flags2'] = smb.SMB.FLAGS2_EXTENDED_SECURITY | smb.SMB.FLAGS2_NT_STATUS | smb.SMB.FLAGS2_LONG_NAMES | \\\n                                        packet['Flags2'] & smb.SMB.FLAGS2_UNICODE\n                        # respPacket['Flags2'] = smb.SMB.FLAGS2_EXTENDED_SECURITY | smb.SMB.FLAGS2_NT_STATUS | smb.SMB.FLAGS2_LONG_NAMES\n                        # respPacket['Flags1'] = 0x98\n                        # respPacket['Flags2'] = 0xc807\n\n                        respPacket['Tid'] = packet['Tid']\n                        respPacket['Mid'] = packet['Mid']\n                        respPacket['Pid'] = packet['Pid']\n                        respPacket['Uid'] = connData['Uid']\n\n                        respPacket['ErrorCode'] = errorCode >> 16\n                        respPacket['_reserved'] = errorCode >> 8 & 0xff\n                        respPacket['ErrorClass'] = errorCode & 0xff\n                        respPacket.addCommand(respCommand)\n\n                        if connData['SignatureEnabled']:\n                            respPacket['Flags2'] |= smb.SMB.FLAGS2_SMB_SECURITY_SIGNATURE\n                            self.signSMBv1(connData, respPacket, connData['SigningSessionKey'],\n                                           connData['SigningChallengeResponse'])\n\n                        packetsToSend.append(respPacket)\n                    else:\n                        respPacket = smb2.SMB2Packet()\n                        respPacket['Flags'] = smb2.SMB2_FLAGS_SERVER_TO_REDIR\n                        if packetNum > 0:\n                            respPacket['Flags'] |= smb2.SMB2_FLAGS_RELATED_OPERATIONS\n                        respPacket['Status'] = errorCode\n                        respPacket['CreditRequestResponse'] = packet['CreditRequestResponse']\n                        respPacket['Command'] = packet['Command']\n                        respPacket['CreditCharge'] = packet['CreditCharge']\n                        # respPacket['CreditCharge'] = 0\n                        respPacket['Reserved'] = packet['Reserved']\n                        respPacket['SessionID'] = connData['Uid']\n                        respPacket['MessageID'] = packet['MessageID']\n                        respPacket['TreeID'] = packet['TreeID']\n                        if hasattr(respCommand, 'getData'):\n                            respPacket['Data'] = respCommand.getData()\n                        else:\n                            respPacket['Data'] = str(respCommand)\n\n                        if connData['SignatureEnabled']:\n                            self.signSMBv2(respPacket, connData['SigningSessionKey'])\n\n                        packetsToSend.append(respPacket)\n            else:\n                # The SMBCommand took care of building the packet\n                packetsToSend = respPackets\n\n        if isSMB2 is True:\n            # Let's build a compound answer\n            finalData = b''\n            i = 0\n            for i in range(len(packetsToSend) - 1):\n                packet = packetsToSend[i]\n                # Align to 8-bytes\n                padLen = (8 - (len(packet) % 8)) % 8\n                packet['NextCommand'] = len(packet) + padLen\n                if hasattr(packet, 'getData'):\n                    finalData += packet.getData() + padLen * b'\\x00'\n                else:\n                    finalData += packet + padLen * b'\\x00'\n\n            # Last one\n            if hasattr(packetsToSend[len(packetsToSend) - 1], 'getData'):\n                finalData += packetsToSend[len(packetsToSend) - 1].getData()\n            else:\n                finalData += packetsToSend[len(packetsToSend) - 1]\n            packetsToSend = [finalData]\n\n        # We clear the compound requests\n        connData['LastRequest'] = {}\n\n        return packetsToSend\n\n    def processConfigFile(self, configFile=None):\n        # TODO: Do a real config parser\n        if self.__serverConfig is None:\n            if configFile is None:\n                configFile = 'smb.conf'\n            self.__serverConfig = configparser.ConfigParser()\n            self.__serverConfig.read(configFile)\n\n        self.__serverName = self.__serverConfig.get('global', 'server_name')\n        self.__serverOS = self.__serverConfig.get('global', 'server_os')\n        self.__serverDomain = self.__serverConfig.get('global', 'server_domain')\n        self.__logFile = self.__serverConfig.get('global', 'log_file')\n        if self.__serverConfig.has_option('global', 'challenge'):\n            self.__challenge = unhexlify(self.__serverConfig.get('global', 'challenge'))\n        else:\n            self.__challenge = b'A' * 16\n\n        if self.__serverConfig.has_option(\"global\", \"jtr_dump_path\"):\n            self.__jtr_dump_path = self.__serverConfig.get(\"global\", \"jtr_dump_path\")\n\n        if self.__serverConfig.has_option(\"global\", \"SMB2Support\"):\n            self.__SMB2Support = self.__serverConfig.getboolean(\"global\", \"SMB2Support\")\n        else:\n            self.__SMB2Support = False\n\n        if self.__logFile != 'None':\n            logging.basicConfig(filename=self.__logFile,\n                                level=logging.DEBUG,\n                                format=\"%(asctime)s: %(levelname)s: %(message)s\",\n                                datefmt='%m/%d/%Y %I:%M:%S %p')\n        self.__log = LOG\n\n        # Process the credentials\n        credentials_fname = self.__serverConfig.get('global', 'credentials_file')\n        if credentials_fname != \"\":\n            cred = open(credentials_fname)\n            line = cred.readline()\n            while line:\n                name, uid, lmhash, nthash = line.split(':')\n                self.__credentials[name.lower()] = (uid, lmhash, nthash.strip('\\r\\n'))\n                line = cred.readline()\n            cred.close()\n        self.log('Config file parsed')\n\n    def addCredential(self, name, uid, lmhash, nthash):\n        # If we have hashes, normalize them\n        if lmhash != '' or nthash != '':\n            if len(lmhash) % 2:\n                lmhash = '0%s' % lmhash\n            if len(nthash) % 2:\n                nthash = '0%s' % nthash\n            try:  # just in case they were converted already\n                lmhash = a2b_hex(lmhash)\n                nthash = a2b_hex(nthash)\n            except:\n                pass\n        self.__credentials[name.lower()] = (uid, lmhash, nthash)\n\n\n# For windows platforms, opening a directory is not an option, so we set a void FD\nVOID_FILE_DESCRIPTOR = -1\nPIPE_FILE_DESCRIPTOR = -2\n\n######################################################################\n# HELPER CLASSES\n######################################################################\n\nfrom impacket.dcerpc.v5.rpcrt import DCERPCServer\nfrom impacket.dcerpc.v5.dtypes import NULL\nfrom impacket.dcerpc.v5.srvs import NetrShareEnum, NetrShareEnumResponse, SHARE_INFO_1, NetrServerGetInfo, \\\n    NetrServerGetInfoResponse, NetrShareGetInfo, NetrShareGetInfoResponse\nfrom impacket.dcerpc.v5.wkst import NetrWkstaGetInfo, NetrWkstaGetInfoResponse\nfrom impacket.system_errors import ERROR_INVALID_LEVEL\n\n\nclass WKSTServer(DCERPCServer):\n    def __init__(self):\n        DCERPCServer.__init__(self)\n        self.wkssvcCallBacks = {\n            0: self.NetrWkstaGetInfo,\n        }\n        self.addCallbacks(('6BFFD098-A112-3610-9833-46C3F87E345A', '1.0'), '\\\\PIPE\\\\wkssvc', self.wkssvcCallBacks)\n\n    def NetrWkstaGetInfo(self, data):\n        request = NetrWkstaGetInfo(data)\n        self.log(\"NetrWkstaGetInfo Level: %d\" % request['Level'])\n\n        answer = NetrWkstaGetInfoResponse()\n\n        if request['Level'] not in (100, 101):\n            answer['ErrorCode'] = ERROR_INVALID_LEVEL\n            return answer\n\n        answer['WkstaInfo']['tag'] = request['Level']\n\n        if request['Level'] == 100:\n            # Windows. Decimal value 500.\n            answer['WkstaInfo']['WkstaInfo100']['wki100_platform_id'] = 0x000001F4\n            answer['WkstaInfo']['WkstaInfo100']['wki100_computername'] = NULL\n            answer['WkstaInfo']['WkstaInfo100']['wki100_langroup'] = NULL\n            answer['WkstaInfo']['WkstaInfo100']['wki100_ver_major'] = 5\n            answer['WkstaInfo']['WkstaInfo100']['wki100_ver_minor'] = 0\n        else:\n            # Windows. Decimal value 500.\n            answer['WkstaInfo']['WkstaInfo101']['wki101_platform_id'] = 0x000001F4\n            answer['WkstaInfo']['WkstaInfo101']['wki101_computername'] = NULL\n            answer['WkstaInfo']['WkstaInfo101']['wki101_langroup'] = NULL\n            answer['WkstaInfo']['WkstaInfo101']['wki101_ver_major'] = 5\n            answer['WkstaInfo']['WkstaInfo101']['wki101_ver_minor'] = 0\n            answer['WkstaInfo']['WkstaInfo101']['wki101_lanroot'] = NULL\n\n        return answer\n\n\nclass SRVSServer(DCERPCServer):\n    def __init__(self):\n        DCERPCServer.__init__(self)\n\n        self._shares = {}\n        self.__serverConfig = None\n        self.__logFile = None\n\n        self.srvsvcCallBacks = {\n            15: self.NetrShareEnum,\n            16: self.NetrShareGetInfo,\n            21: self.NetrServerGetInfo,\n        }\n\n        self.addCallbacks(('4B324FC8-1670-01D3-1278-5A47BF6EE188', '3.0'), '\\\\PIPE\\\\srvsvc', self.srvsvcCallBacks)\n\n    def setServerConfig(self, config):\n        self.__serverConfig = config\n\n    def processConfigFile(self, configFile=None):\n        if configFile is not None:\n            self.__serverConfig = configparser.ConfigParser()\n            self.__serverConfig.read(configFile)\n        sections = self.__serverConfig.sections()\n        # Let's check the log file\n        self.__logFile = self.__serverConfig.get('global', 'log_file')\n        if self.__logFile != 'None':\n            logging.basicConfig(filename=self.__logFile,\n                                level=logging.DEBUG,\n                                format=\"%(asctime)s: %(levelname)s: %(message)s\",\n                                datefmt='%m/%d/%Y %I:%M:%S %p')\n\n        # Remove the global one\n        del (sections[sections.index('global')])\n        self._shares = {}\n        for i in sections:\n            self._shares[i] = dict(self.__serverConfig.items(i))\n\n    def NetrShareGetInfo(self, data):\n        request = NetrShareGetInfo(data)\n        self.log(\"NetrGetShareInfo Level: %d\" % request['Level'])\n\n        s = request['NetName'][:-1].upper()\n        answer = NetrShareGetInfoResponse()\n        if s in self._shares:\n            share = self._shares[s]\n\n            answer['InfoStruct']['tag'] = 1\n            answer['InfoStruct']['ShareInfo1']['shi1_netname'] = s + '\\x00'\n            answer['InfoStruct']['ShareInfo1']['shi1_type'] = share['share type']\n            answer['InfoStruct']['ShareInfo1']['shi1_remark'] = share['comment'] + '\\x00'\n            answer['ErrorCode'] = 0\n        else:\n            answer['InfoStruct']['tag'] = 1\n            answer['InfoStruct']['ShareInfo1'] = NULL\n            answer['ErrorCode'] = 0x0906  # WERR_NET_NAME_NOT_FOUND\n\n        return answer\n\n    def NetrServerGetInfo(self, data):\n        request = NetrServerGetInfo(data)\n        self.log(\"NetrServerGetInfo Level: %d\" % request['Level'])\n        answer = NetrServerGetInfoResponse()\n        answer['InfoStruct']['tag'] = 101\n        # PLATFORM_ID_NT = 500\n        answer['InfoStruct']['ServerInfo101']['sv101_platform_id'] = 500\n        answer['InfoStruct']['ServerInfo101']['sv101_name'] = request['ServerName']\n        # Windows 7 = 6.1\n        answer['InfoStruct']['ServerInfo101']['sv101_version_major'] = 6\n        answer['InfoStruct']['ServerInfo101']['sv101_version_minor'] = 1\n        # Workstation = 1\n        answer['InfoStruct']['ServerInfo101']['sv101_type'] = 1\n        answer['InfoStruct']['ServerInfo101']['sv101_comment'] = NULL\n        answer['ErrorCode'] = 0\n        return answer\n\n    def NetrShareEnum(self, data):\n        request = NetrShareEnum(data)\n        self.log(\"NetrShareEnum Level: %d\" % request['InfoStruct']['Level'])\n        shareEnum = NetrShareEnumResponse()\n        shareEnum['InfoStruct']['Level'] = 1\n        shareEnum['InfoStruct']['ShareInfo']['tag'] = 1\n        shareEnum['TotalEntries'] = len(self._shares)\n        shareEnum['InfoStruct']['ShareInfo']['Level1']['EntriesRead'] = len(self._shares)\n        shareEnum['ErrorCode'] = 0\n\n        for i in self._shares:\n            shareInfo = SHARE_INFO_1()\n            shareInfo['shi1_netname'] = i + '\\x00'\n            shareInfo['shi1_type'] = self._shares[i]['share type']\n            shareInfo['shi1_remark'] = self._shares[i]['comment'] + '\\x00'\n            shareEnum['InfoStruct']['ShareInfo']['Level1']['Buffer'].append(shareInfo)\n\n        return shareEnum\n\n\nclass SimpleSMBServer:\n    \"\"\"\n    SimpleSMBServer class - Implements a simple, customizable SMB Server\n\n    :param string listenAddress: the address you want the server to listen on\n    :param integer listenPort: the port number you want the server to listen on\n    :param string configFile: a file with all the servers' configuration. If no file specified, this class will create the basic parameters needed to run. You will need to add your shares manually tho. See addShare() method\n    \"\"\"\n\n    def __init__(self, listenAddress='0.0.0.0', listenPort=445, configFile=''):\n        if configFile != '':\n            self.__server = SMBSERVER((listenAddress, listenPort))\n            self.__server.processConfigFile(configFile)\n            self.__smbConfig = None\n        else:\n            # Here we write a mini config for the server\n            self.__smbConfig = configparser.ConfigParser()\n            self.__smbConfig.add_section('global')\n            self.__smbConfig.set('global', 'server_name',\n                                 ''.join([random.choice(string.ascii_letters) for _ in range(8)]))\n            self.__smbConfig.set('global', 'server_os', ''.join([random.choice(string.ascii_letters) for _ in range(8)])\n                                 )\n            self.__smbConfig.set('global', 'server_domain',\n                                 ''.join([random.choice(string.ascii_letters) for _ in range(8)])\n                                 )\n            self.__smbConfig.set('global', 'log_file', 'None')\n            self.__smbConfig.set('global', 'rpc_apis', 'yes')\n            self.__smbConfig.set('global', 'credentials_file', '')\n            self.__smbConfig.set('global', 'challenge', \"A\" * 16)\n\n            # IPC always needed\n            self.__smbConfig.add_section('IPC$')\n            self.__smbConfig.set('IPC$', 'comment', '')\n            self.__smbConfig.set('IPC$', 'read only', 'yes')\n            self.__smbConfig.set('IPC$', 'share type', '3')\n            self.__smbConfig.set('IPC$', 'path', '')\n            self.__server = SMBSERVER((listenAddress, listenPort), config_parser=self.__smbConfig)\n            self.__server.processConfigFile()\n\n        # Now we have to register the MS-SRVS server. This specially important for\n        # Windows 7+ and Mavericks clients since they WON'T (specially OSX)\n        # ask for shares using MS-RAP.\n\n        self.__srvsServer = SRVSServer()\n        self.__srvsServer.daemon = True\n        self.__wkstServer = WKSTServer()\n        self.__wkstServer.daemon = True\n        self.__server.registerNamedPipe('srvsvc', ('127.0.0.1', self.__srvsServer.getListenPort()))\n        self.__server.registerNamedPipe('wkssvc', ('127.0.0.1', self.__wkstServer.getListenPort()))\n\n    def start(self):\n        self.__srvsServer.start()\n        self.__wkstServer.start()\n        self.__server.serve_forever()\n\n    def registerNamedPipe(self, pipeName, address):\n        return self.__server.registerNamedPipe(pipeName, address)\n\n    def unregisterNamedPipe(self, pipeName):\n        return self.__server.unregisterNamedPipe(pipeName)\n\n    def getRegisteredNamedPipes(self):\n        return self.__server.getRegisteredNamedPipes()\n\n    def addShare(self, shareName, sharePath, shareComment='', shareType='0', readOnly='no'):\n        share = shareName.upper()\n        self.__smbConfig.add_section(share)\n        self.__smbConfig.set(share, 'comment', shareComment)\n        self.__smbConfig.set(share, 'read only', readOnly)\n        self.__smbConfig.set(share, 'share type', shareType)\n        self.__smbConfig.set(share, 'path', sharePath)\n        self.__server.setServerConfig(self.__smbConfig)\n        self.__srvsServer.setServerConfig(self.__smbConfig)\n        self.__server.processConfigFile()\n        self.__srvsServer.processConfigFile()\n\n    def removeShare(self, shareName):\n        self.__smbConfig.remove_section(shareName.upper())\n        self.__server.setServerConfig(self.__smbConfig)\n        self.__srvsServer.setServerConfig(self.__smbConfig)\n        self.__server.processConfigFile()\n        self.__srvsServer.processConfigFile()\n\n    def setSMBChallenge(self, challenge):\n        if challenge != '':\n            self.__smbConfig.set('global', 'challenge', challenge)\n            self.__server.setServerConfig(self.__smbConfig)\n            self.__server.processConfigFile()\n\n    def setLogFile(self, logFile):\n        self.__smbConfig.set('global', 'log_file', logFile)\n        self.__server.setServerConfig(self.__smbConfig)\n        self.__server.processConfigFile()\n\n    def setCredentialsFile(self, logFile):\n        self.__smbConfig.set('global', 'credentials_file', logFile)\n        self.__server.setServerConfig(self.__smbConfig)\n        self.__server.processConfigFile()\n\n    def addCredential(self, name, uid, lmhash, nthash):\n        self.__server.addCredential(name, uid, lmhash, nthash)\n\n    def setSMB2Support(self, value):\n        if value is True:\n            self.__smbConfig.set(\"global\", \"SMB2Support\", \"True\")\n        else:\n            self.__smbConfig.set(\"global\", \"SMB2Support\", \"False\")\n        self.__server.setServerConfig(self.__smbConfig)\n        self.__server.processConfigFile()\n"], "filenames": ["impacket/smbserver.py"], "buggy_code_start_loc": [49], "buggy_code_end_loc": [4680], "fixing_code_start_loc": [49], "fixing_code_end_loc": [4755], "type": "CWE-22", "message": "Multiple path traversal vulnerabilities exist in smbserver.py in Impacket through 0.9.22. An attacker that connects to a running smbserver instance can list and write to arbitrary files via ../ directory traversal. This could potentially be abused to achieve arbitrary code execution by replacing /etc/shadow or an SSH authorized key.", "other": {"cve": {"id": "CVE-2021-31800", "sourceIdentifier": "cve@mitre.org", "published": "2021-05-05T11:15:07.397", "lastModified": "2021-05-26T13:10:18.670", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Multiple path traversal vulnerabilities exist in smbserver.py in Impacket through 0.9.22. An attacker that connects to a running smbserver instance can list and write to arbitrary files via ../ directory traversal. This could potentially be abused to achieve arbitrary code execution by replacing /etc/shadow or an SSH authorized key."}, {"lang": "es", "value": "Se presentan m\u00faltiples vulnerabilidades de salto de ruta en el archivo smbserver.py en Impacket versiones hasta 0.9.22.&#xa0;Un atacante que se conecta a una instancia de smbserver en ejecuci\u00f3n puede enumerar y escribir en archivos arbitrarios por medio de un salto de directorio ../.&#xa0;Esto podr\u00eda potencialmente ser abusado para lograr una ejecuci\u00f3n de c\u00f3digo arbitraria al reemplazar /etc/shadow o una clave SSH autorizada"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:secureauth:impacket:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.9.22", "matchCriteriaId": "075A5E4D-3FA0-4BD1-9F79-427792DF7108"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:32:*:*:*:*:*:*:*", "matchCriteriaId": "36D96259-24BD-44E2-96D9-78CE1D41F956"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:33:*:*:*:*:*:*:*", "matchCriteriaId": "E460AA51-FCDA-46B9-AE97-E6676AA5E194"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}]}]}], "references": [{"url": "https://github.com/SecureAuthCorp/impacket/blob/cb6d43a677c338db930bc4e9161620832c1ec624/impacket/smbserver.py#L2008", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/SecureAuthCorp/impacket/blob/cb6d43a677c338db930bc4e9161620832c1ec624/impacket/smbserver.py#L2958", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/SecureAuthCorp/impacket/blob/cb6d43a677c338db930bc4e9161620832c1ec624/impacket/smbserver.py#L3485", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/SecureAuthCorp/impacket/blob/cb6d43a677c338db930bc4e9161620832c1ec624/impacket/smbserver.py#L876", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/SecureAuthCorp/impacket/commit/49c643bf66620646884ed141c94e5fdd85bcdd2f", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/SecureAuthCorp/impacket/releases", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/IPXDPWCAPVX3UWYZ3N2T5OLBSBBUHJP6/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/KRV2C5DATXBHG6TF6CEEX54KZ75THQS3/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/UF56LYB27LHEIFJTFHU3M75NMNNK2SCG/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/SecureAuthCorp/impacket/commit/49c643bf66620646884ed141c94e5fdd85bcdd2f"}}