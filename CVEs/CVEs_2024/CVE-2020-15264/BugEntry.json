{"buggy_code": ["function Install-Boxstarter($here, $ModuleName, $installArgs = \"\") {\r\n    $boxstarterPath = Join-Path $env:ProgramData Boxstarter\r\n    if(!(test-Path $boxstarterPath)){\r\n        mkdir $boxstarterPath\r\n    }\r\n    $packagePath=Join-Path $boxstarterPath BuildPackages\r\n    if(!(test-Path $packagePath)){\r\n        mkdir $packagePath\r\n    }\r\n    foreach($ModulePath in (Get-ChildItem $here | Where-Object { $_.PSIsContainer })){\r\n        $target=Join-Path $boxstarterPath $modulePath.BaseName\r\n        if(test-Path $target){\r\n            Remove-Item $target -Recurse -Force\r\n        }\r\n    }\r\n    Copy-Item \"$here\\*\" $boxstarterPath -Recurse -Force -Exclude ChocolateyInstall.ps1, Setup.*\r\n\r\n    PersistBoxStarterPathToEnvironmentVariable \"PSModulePath\" $boxstarterPath\r\n    PersistBoxStarterPathToEnvironmentVariable \"Path\" $boxstarterPath\r\n    $binPath =  \"$here\\..\\..\\..\\bin\"\r\n    $boxModule=Get-Module Boxstarter.Chocolatey\r\n    if($boxModule) {\r\n        if($boxModule.Path -like \"$env:LOCALAPPDATA\\Apps\\*\") {\r\n            $clickonce=$true\r\n        }\r\n    }\r\n    if(!$clickonce){\r\n        Import-Module \"$boxstarterPath\\$ModuleName\" -DisableNameChecking -Force -ErrorAction SilentlyContinue\r\n    }\r\n    $successMsg = @\"\r\nThe $ModuleName Module has been copied to $boxstarterPath and added to your Module path.\r\nYou will need to open a new console for the path to be visible.\r\nUse 'Get-Module Boxstarter.* -ListAvailable' to list all Boxstarter Modules.\r\nTo list all available Boxstarter Commands, use:\r\nPS:>Import-Module $ModuleName\r\nPS:>Get-Command -Module Boxstarter.*\r\n\r\nTo find more info visit https://Boxstarter.org or use:\r\nPS:>Import-Module $ModuleName\r\nPS:>Get-Help Boxstarter\r\n\"@\r\n    Write-Host $successMsg\r\n\r\n    if($ModuleName -eq \"Boxstarter.Chocolatey\" -and !$env:appdata.StartsWith($env:windir)) {\r\n        $desktop = [System.Environment]::GetFolderPath([System.Environment+SpecialFolder]::CommonDesktopDirectory)\r\n        $startMenu = [System.Environment]::GetFolderPath([System.Environment+SpecialFolder]::CommonStartMenu)\r\n        $startMenu += \"\\Programs\\Boxstarter\"\r\n        if(!(Test-Path $startMenu)){\r\n            mkdir $startMenu\r\n        }\r\n        $target=\"powershell.exe\"\r\n        $targetArgs=\"-ExecutionPolicy bypass -NoExit -Command `\"&'$boxstarterPath\\BoxstarterShell.ps1'`\"\"\r\n\r\n\t\tif($installArgs -inotcontains \"nodesktopicon\") {\r\n\t\t\t$link = Join-Path $desktop \"Boxstarter Shell.lnk\"\r\n\t\t\tCreate-Shortcut $link $target $targetArgs $boxstarterPath\r\n\t\t}\r\n        $link = Join-Path $startMenu \"Boxstarter Shell.lnk\"\r\n        Create-Shortcut $link $target $targetArgs $boxstarterPath\r\n\r\n        Set-Content -Path \"$binPath\\BoxstarterShell.bat\" -Force -Value \"$target $TargetArgs\"\r\n    }\r\n}\r\n\r\nfunction Uninstall-Boxstarter ($here, $ModuleName, $installArgs = \"\") {\r\n\r\n    if ($ModuleName -eq \"Boxstarter.Chocolatey\" -and !$env:appdata.StartsWith($env:windir)) {\r\n        $startMenu = Join-Path -Path ([Environment]::GetFolderPath('CommonPrograms')) -ChildPath \"Boxstarter\"\r\n\r\n        if (Test-Path $startMenu) {\r\n            Write-Verbose \"Removing '$startMenu' menu folder\"\r\n            Remove-Item -Path $startMenu -Recurse -Force\r\n        }\r\n\r\n        $desktopShortcut = Join-Path -Path ([Environment]::GetFolderPath('CommonDesktop')) -ChildPath \"Boxstarter Shell.lnk\"\r\n        if (Test-Path $desktopShortcut) {\r\n            Write-Verbose \"Removing '$desktopShortcut'\"\r\n            Remove-Item -Path $desktopShortcut -Force\r\n        }\r\n    }\r\n}\r\n\r\nfunction Create-Shortcut($location, $target, $targetArgs, $boxstarterPath) {\r\n    $wshshell = New-Object -ComObject WScript.Shell\r\n    $lnk = $wshshell.CreateShortcut($location)\r\n    $lnk.TargetPath = $target\r\n    $lnk.Arguments = \"$targetArgs\"\r\n    $lnk.WorkingDirectory = $boxstarterPath\r\n    $lnk.IconLocation=\"$boxstarterPath\\BoxLogo.ico\"\r\n    $lnk.Save()\r\n\r\n    #This adds a bit to the shortcut link that causes it to open with admin privileges\r\n\t$tempFile = \"$env:temp\\TempShortcut.lnk\"\r\n\r\n\t$writer = new-object System.IO.FileStream $tempFile, ([System.IO.FileMode]::Create)\r\n\t$reader = new-object System.IO.FileStream $location, ([System.IO.FileMode]::Open)\r\n\r\n\twhile ($reader.Position -lt $reader.Length)\r\n\t{\r\n\t\t$byte = $reader.ReadByte()\r\n\t\tif ($reader.Position -eq 22) {\r\n\t\t\t$byte = 34\r\n\t\t}\r\n\t\t$writer.WriteByte($byte)\r\n\t}\r\n\r\n\t$reader.Close()\r\n\t$writer.Close()\r\n\r\n\tMove-Item -Path $tempFile $location -Force\r\n}\r\nfunction PersistBoxStarterPathToEnvironmentVariable($variableName, $boxstarterPath){\r\n    # Remove user scoped vars from previous releases\r\n    $userValue = [Environment]::GetEnvironmentVariable($variableName, 'User')\r\n    if($userValue){\r\n        $userValues=($userValue -split ';' | Where-Object { !($_.ToLower() -match \"\\\\boxstarter$\")}) -join ';'\r\n    }\r\n    elseif($variableName -eq \"PSModulePath\") {\r\n        $userValues = [environment]::getfolderpath(\"mydocuments\")\r\n        $userValues +=\"\\WindowsPowerShell\\Modules\"\r\n    }\r\n    [Environment]::SetEnvironmentVariable($variableName, $userValues, 'User')\r\n\r\n    $value = [Environment]::GetEnvironmentVariable($variableName, 'Machine')\r\n    if($value){\r\n        $values=($value -split ';' | Where-Object { !($_.ToLower() -match \"\\\\boxstarter$\")}) -join ';'\r\n        $values=\"$boxstarterPath;$values\"\r\n    }\r\n    elseif($variableName -eq \"PSModulePath\") {\r\n        $values = \"$boxstarterPath;\"\r\n        $values += [environment]::getfolderpath(\"ProgramFiles\")\r\n        $values +=\"\\WindowsPowerShell\\Modules\"\r\n    }\r\n    else {\r\n        $values =\"$boxstarterPath\"\r\n    }\r\n\r\n    [Environment]::SetEnvironmentVariable($variableName, $values, 'Machine')\r\n    $varValue = Get-Content env:\\$variableName\r\n    $varValue = \"$boxstarterPath;$varValue\"\r\n    Set-Content env:\\$variableName -value $varValue\r\n}\r\n"], "fixing_code": ["\r\n<#\r\n.SYNOPSIS\r\n    test if current session/identity is elevated \r\n    (a.k.a. check if we've got admin privileges)\r\n#>\r\nfunction Test-Admin {\r\n    $identity = [System.Security.Principal.WindowsIdentity]::GetCurrent()\r\n    $principal = New-Object System.Security.Principal.WindowsPrincipal( $identity )\r\n    return $principal.IsInRole( [System.Security.Principal.WindowsBuiltInRole]::Administrator )\r\n}\r\n\r\n<#\r\n.SYNOPSIS\r\n    get name of 'WellKnownSidType' in the current user's system locale\r\n#>\r\nfunction Get-LocalizedWellKnownPrincipalName {\r\n    param (\r\n        [Parameter(Mandatory = $true)]\r\n        [Security.Principal.WellKnownSidType] $WellKnownSidType\r\n    )\r\n    $sid = New-Object -TypeName 'System.Security.Principal.SecurityIdentifier' -ArgumentList @($WellKnownSidType, $null)\r\n    $account = $sid.Translate([Security.Principal.NTAccount])\r\n\r\n    return $account.Value\r\n}\r\n\r\n<#\r\n.SYNOPSIS\r\n    ensure a given folder is only writeable by administrative users\r\n\r\n.NOTES\r\n    we need to do this in order to mitigate privilege escalation attacks!\r\n    \r\n    Attack Vector 1: Boxstarter folders are added to PATH, therefore they must be protected in a way so \r\n    that a random user may not put arbitrary files/dlls in these folders.\r\n    (files may be replaces with hijacked/malicious ones)\r\n    \r\n    Attack Vector 2: 'BuildPackages' contains Boxstarter Packages that may be installed after system reboots.\r\n    If a user would be able to modify those packages, it would be easy to run arbitrary PowerShell code with \r\n    SYSTEM privileges.\r\n    \r\n    see Ensure-Permissions \r\n    https://github.com/chocolatey/choco/blob/master/nuget/chocolatey/tools/chocolateysetup.psm1\r\n#>\r\nfunction Ensure-Permissions {\r\n    [CmdletBinding()]\r\n    param(\r\n        [string]$folder\r\n    )\r\n    Write-Debug \"Ensure-Permissions\"\r\n\r\n    $currentEA = $ErrorActionPreference\r\n    $ErrorActionPreference = 'Stop'\r\n    try {\r\n        # get current acl\r\n        $acl = (Get-Item $folder).GetAccessControl('Access,Owner')\r\n\r\n        Write-Debug \"Removing existing permissions.\"\r\n        $acl.Access | ForEach-Object {\r\n            Write-Debug \"Remove '$($_.FileSystemRights)' for user '$($_.IdentityReference)'\"\r\n            $acl.RemoveAccessRuleAll($_) \r\n        }\r\n\r\n        $inheritanceFlags = ([Security.AccessControl.InheritanceFlags]::ContainerInherit -bor [Security.AccessControl.InheritanceFlags]::ObjectInherit)\r\n        $propagationFlags = [Security.AccessControl.PropagationFlags]::None\r\n\r\n        $rightsFullControl = [Security.AccessControl.FileSystemRights]::FullControl\r\n        $rightsReadExecute = [Security.AccessControl.FileSystemRights]::ReadAndExecute\r\n\r\n        Write-Output \"Restricting write permissions of '$folder' to Administrators\"\r\n        $builtinAdmins = Get-LocalizedWellKnownPrincipalName -WellKnownSidType ([Security.Principal.WellKnownSidType]::BuiltinAdministratorsSid)\r\n        $adminsAccessRule = New-Object System.Security.AccessControl.FileSystemAccessRule($builtinAdmins, $rightsFullControl, $inheritanceFlags, $propagationFlags, \"Allow\")\r\n        $acl.SetAccessRule($adminsAccessRule)\r\n        $localSystem = Get-LocalizedWellKnownPrincipalName -WellKnownSidType ([Security.Principal.WellKnownSidType]::LocalSystemSid)\r\n        $localSystemAccessRule = New-Object System.Security.AccessControl.FileSystemAccessRule($localSystem, $rightsFullControl, $inheritanceFlags, $propagationFlags, \"Allow\")\r\n        $acl.SetAccessRule($localSystemAccessRule)\r\n        $builtinUsers = Get-LocalizedWellKnownPrincipalName -WellKnownSidType ([Security.Principal.WellKnownSidType]::BuiltinUsersSid)\r\n        $usersAccessRule = New-Object System.Security.AccessControl.FileSystemAccessRule($builtinUsers, $rightsReadExecute, $inheritanceFlags, $propagationFlags, \"Allow\")\r\n        $acl.SetAccessRule($usersAccessRule)\r\n\r\n        Write-Debug \"Set Owner to Administrators\"\r\n        $builtinAdminsSid = New-Object System.Security.Principal.SecurityIdentifier([Security.Principal.WellKnownSidType]::BuiltinAdministratorsSid, $null)\r\n        $acl.SetOwner($builtinAdminsSid)\r\n\r\n        Write-Debug \"Removing inheritance with no copy\"\r\n        $acl.SetAccessRuleProtection($true, $false)\r\n\r\n        # enact the changes against the actual\r\n        (Get-Item $folder).SetAccessControl($acl)\r\n\r\n    }\r\n    catch {\r\n        Write-Warning $_.Exception\r\n        Write-Warning \"Not able to set permissions for $folder.\"\r\n    }\r\n    $ErrorActionPreference = $currentEA\r\n}\r\n\r\nfunction Install-Boxstarter($here, $ModuleName, $installArgs = \"\") {\r\n\r\n    if (!(Test-Admin)) {\r\n        throw \"Installation of Boxstarter requires Administrative permissions. Please run from elevated prompt.\"\r\n    }\r\n\r\n    $boxstarterPath = Join-Path $env:ProgramData Boxstarter\r\n    if (!(test-Path $boxstarterPath)) {\r\n        New-Item -ItemType Directory $boxstarterPath | Out-Null\r\n    }\r\n    $packagePath = Join-Path $boxstarterPath BuildPackages\r\n    if (!(test-Path $packagePath)) {\r\n        New-Item -ItemType Directory $packagePath | Out-Null\r\n    }\r\n    foreach ($ModulePath in (Get-ChildItem $here | Where-Object { $_.PSIsContainer })) {\r\n        $target = Join-Path $boxstarterPath $modulePath.BaseName\r\n        if (test-Path $target) {\r\n            Remove-Item $target -Recurse -Force\r\n        }\r\n    }\r\n    Copy-Item \"$here\\*\" $boxstarterPath -Recurse -Force -Exclude ChocolateyInstall.ps1, Setup.*\r\n\r\n    # set permissions to mitigate possible privilege escalation\r\n    Ensure-Permissions -folder $boxstarterPath\r\n\r\n    PersistBoxStarterPathToEnvironmentVariable \"PSModulePath\" $boxstarterPath\r\n    PersistBoxStarterPathToEnvironmentVariable \"Path\" $boxstarterPath\r\n    $binPath =  \"$here\\..\\..\\..\\bin\"\r\n    $boxModule=Get-Module Boxstarter.Chocolatey\r\n    if($boxModule) {\r\n        if($boxModule.Path -like \"$env:LOCALAPPDATA\\Apps\\*\") {\r\n            $clickonce=$true\r\n        }\r\n    }\r\n    if(!$clickonce){\r\n        Import-Module \"$boxstarterPath\\$ModuleName\" -DisableNameChecking -Force -ErrorAction SilentlyContinue\r\n    }\r\n    $successMsg = @\"\r\nThe $ModuleName Module has been copied to $boxstarterPath and added to your Module path.\r\nYou will need to open a new console for the path to be visible.\r\nUse 'Get-Module Boxstarter.* -ListAvailable' to list all Boxstarter Modules.\r\nTo list all available Boxstarter Commands, use:\r\nPS:>Import-Module $ModuleName\r\nPS:>Get-Command -Module Boxstarter.*\r\n\r\nTo find more info visit https://Boxstarter.org or use:\r\nPS:>Import-Module $ModuleName\r\nPS:>Get-Help Boxstarter\r\n\"@\r\n    Write-Host $successMsg\r\n\r\n    if($ModuleName -eq \"Boxstarter.Chocolatey\" -and !$env:appdata.StartsWith($env:windir)) {\r\n        $desktop = [System.Environment]::GetFolderPath([System.Environment+SpecialFolder]::CommonDesktopDirectory)\r\n        $startMenu = [System.Environment]::GetFolderPath([System.Environment+SpecialFolder]::CommonStartMenu)\r\n        $startMenu += \"\\Programs\\Boxstarter\"\r\n        if(!(Test-Path $startMenu)){\r\n            New-Item -ItemType Directory $startMenu | Out-Null\r\n        }\r\n        $target=\"powershell.exe\"\r\n        $targetArgs=\"-ExecutionPolicy bypass -NoExit -Command `\"&'$boxstarterPath\\BoxstarterShell.ps1'`\"\"\r\n\r\n\t\tif($installArgs -inotcontains \"nodesktopicon\") {\r\n\t\t\t$link = Join-Path $desktop \"Boxstarter Shell.lnk\"\r\n\t\t\tCreate-Shortcut $link $target $targetArgs $boxstarterPath\r\n\t\t}\r\n        $link = Join-Path $startMenu \"Boxstarter Shell.lnk\"\r\n        Create-Shortcut $link $target $targetArgs $boxstarterPath\r\n\r\n        Set-Content -Path \"$binPath\\BoxstarterShell.bat\" -Force -Value \"$target $TargetArgs\"\r\n    }\r\n}\r\n\r\nfunction Uninstall-Boxstarter ($here, $ModuleName, $installArgs = \"\") {\r\n\r\n    if ($ModuleName -eq \"Boxstarter.Chocolatey\" -and !$env:appdata.StartsWith($env:windir)) {\r\n        $startMenu = Join-Path -Path ([Environment]::GetFolderPath('CommonPrograms')) -ChildPath \"Boxstarter\"\r\n\r\n        if (Test-Path $startMenu) {\r\n            Write-Verbose \"Removing '$startMenu' menu folder\"\r\n            Remove-Item -Path $startMenu -Recurse -Force\r\n        }\r\n\r\n        $desktopShortcut = Join-Path -Path ([Environment]::GetFolderPath('CommonDesktop')) -ChildPath \"Boxstarter Shell.lnk\"\r\n        if (Test-Path $desktopShortcut) {\r\n            Write-Verbose \"Removing '$desktopShortcut'\"\r\n            Remove-Item -Path $desktopShortcut -Force\r\n        }\r\n    }\r\n}\r\n\r\nfunction Create-Shortcut($location, $target, $targetArgs, $boxstarterPath) {\r\n    $wshshell = New-Object -ComObject WScript.Shell\r\n    $lnk = $wshshell.CreateShortcut($location)\r\n    $lnk.TargetPath = $target\r\n    $lnk.Arguments = \"$targetArgs\"\r\n    $lnk.WorkingDirectory = $boxstarterPath\r\n    $lnk.IconLocation=\"$boxstarterPath\\BoxLogo.ico\"\r\n    $lnk.Save()\r\n\r\n    #This adds a bit to the shortcut link that causes it to open with admin privileges\r\n\t$tempFile = \"$env:temp\\TempShortcut.lnk\"\r\n\r\n\t$writer = new-object System.IO.FileStream $tempFile, ([System.IO.FileMode]::Create)\r\n\t$reader = new-object System.IO.FileStream $location, ([System.IO.FileMode]::Open)\r\n\r\n\twhile ($reader.Position -lt $reader.Length)\r\n\t{\r\n\t\t$byte = $reader.ReadByte()\r\n\t\tif ($reader.Position -eq 22) {\r\n\t\t\t$byte = 34\r\n\t\t}\r\n\t\t$writer.WriteByte($byte)\r\n\t}\r\n\r\n\t$reader.Close()\r\n\t$writer.Close()\r\n\r\n\tMove-Item -Path $tempFile $location -Force\r\n}\r\nfunction PersistBoxStarterPathToEnvironmentVariable($variableName, $boxstarterPath){\r\n    # Remove user scoped vars from previous releases\r\n    $userValue = [Environment]::GetEnvironmentVariable($variableName, 'User')\r\n    if($userValue){\r\n        $userValues=($userValue -split ';' | Where-Object { !($_.ToLower() -match \"\\\\boxstarter$\")}) -join ';'\r\n    }\r\n    elseif($variableName -eq \"PSModulePath\") {\r\n        $userValues = [environment]::getfolderpath(\"mydocuments\")\r\n        $userValues +=\"\\WindowsPowerShell\\Modules\"\r\n    }\r\n    [Environment]::SetEnvironmentVariable($variableName, $userValues, 'User')\r\n\r\n    $value = [Environment]::GetEnvironmentVariable($variableName, 'Machine')\r\n    if($value){\r\n        $values=($value -split ';' | Where-Object { !($_.ToLower() -match \"\\\\boxstarter$\")}) -join ';'\r\n        $values=\"$boxstarterPath;$values\"\r\n    }\r\n    elseif($variableName -eq \"PSModulePath\") {\r\n        $values = \"$boxstarterPath;\"\r\n        $values += [environment]::getfolderpath(\"ProgramFiles\")\r\n        $values +=\"\\WindowsPowerShell\\Modules\"\r\n    }\r\n    else {\r\n        $values =\"$boxstarterPath\"\r\n    }\r\n\r\n    [Environment]::SetEnvironmentVariable($variableName, $values, 'Machine')\r\n    $varValue = Get-Content env:\\$variableName\r\n    $varValue = \"$boxstarterPath;$varValue\"\r\n    Set-Content env:\\$variableName -value $varValue\r\n}\r\n"], "filenames": ["BuildScripts/setup.ps1"], "buggy_code_start_loc": [0], "buggy_code_end_loc": [50], "fixing_code_start_loc": [1], "fixing_code_end_loc": [157], "type": "CWE-668", "message": "The Boxstarter installer before version 2.13.0 configures C:\\ProgramData\\Boxstarter to be in the system-wide PATH environment variable. However, this directory is writable by normal, unprivileged users. To exploit the vulnerability, place a DLL in this directory that a privileged service is looking for. For example, WptsExtensions.dll When Windows starts, it'll execute the code in DllMain() with SYSTEM privileges. Any unprivileged user can execute code with SYSTEM privileges. The issue is fixed in version 3.13.0", "other": {"cve": {"id": "CVE-2020-15264", "sourceIdentifier": "security-advisories@github.com", "published": "2020-10-20T21:15:12.633", "lastModified": "2020-10-30T22:32:46.607", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The Boxstarter installer before version 2.13.0 configures C:\\ProgramData\\Boxstarter to be in the system-wide PATH environment variable. However, this directory is writable by normal, unprivileged users. To exploit the vulnerability, place a DLL in this directory that a privileged service is looking for. For example, WptsExtensions.dll When Windows starts, it'll execute the code in DllMain() with SYSTEM privileges. Any unprivileged user can execute code with SYSTEM privileges. The issue is fixed in version 3.13.0"}, {"lang": "es", "value": "El instalador de Boxstarter anterior a versi\u00f3n 2.13.0 configura C:\\ProgramData\\Boxstarter para estar en la variable de entorno PATH system-wide.&#xa0;Sin embargo, este directorio es escribible por usuarios normales no privilegiados.&#xa0;Para explotar la vulnerabilidad, coloque una DLL en este directorio que est\u00e1  buscando un servicio privilegiado.&#xa0;Por ejemplo, la biblioteca WptsExtensions.dll, cuando Windows inicie ejecutar\u00e1 el c\u00f3digo en la funci\u00f3n DllMain() con privilegios SYSTEM.&#xa0;Cualquier usuario no privilegiado puede ejecutar c\u00f3digo con privilegios SYSTEM.&#xa0;El problema es corregido en la versi\u00f3n 3.13.0"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.3, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-668"}, {"lang": "en", "value": "CWE-73"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:chocolatey:boxstarter:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.13.0", "matchCriteriaId": "2032E45E-759C-4DBB-ADA3-355236C139C0"}]}]}], "references": [{"url": "https://github.com/chocolatey/boxstarter/commit/67e320491813550b48900e87105a34ceefdcf633", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/chocolatey/boxstarter/security/advisories/GHSA-rpgx-h675-r3jf", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.kb.cert.org/vuls/id/208577", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/chocolatey/boxstarter/commit/67e320491813550b48900e87105a34ceefdcf633"}}