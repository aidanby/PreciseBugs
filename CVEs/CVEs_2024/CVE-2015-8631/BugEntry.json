{"buggy_code": ["/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/*\n * Copyright 1993 OpenVision Technologies, Inc., All Rights Reserved\n *\n */\n\n#include <k5-platform.h>\n#include <socket-utils.h>\n#include <gssapi/gssapi.h>\n#include <gssapi/gssapi_krb5.h> /* for gss_nt_krb5_name */\n#include <krb5.h>\n#include <kadm5/admin.h>\n#include <kadm5/kadm_rpc.h>\n#include <kadm5/server_internal.h>\n#include <kadm5/server_acl.h>\n#include <syslog.h>\n#include <adm_proto.h>  /* krb5_klog_syslog */\n#include \"misc.h\"\n\nextern gss_name_t                       gss_changepw_name;\nextern gss_name_t                       gss_oldchangepw_name;\nextern void *                           global_server_handle;\n\n#define CHANGEPW_SERVICE(rqstp)                                         \\\n    (cmp_gss_names_rel_1(acceptor_name(rqstp->rq_svccred), gss_changepw_name) | \\\n     (gss_oldchangepw_name &&                                           \\\n      cmp_gss_names_rel_1(acceptor_name(rqstp->rq_svccred),             \\\n                          gss_oldchangepw_name)))\n\n\nstatic int gss_to_krb5_name(kadm5_server_handle_t handle,\n                            gss_name_t gss_name, krb5_principal *princ);\n\nstatic int gss_name_to_string(gss_name_t gss_name, gss_buffer_desc *str);\n\nstatic gss_name_t acceptor_name(gss_ctx_id_t context);\n\ngss_name_t rqst2name(struct svc_req *rqstp);\n\nstatic int cmp_gss_names(gss_name_t n1, gss_name_t n2)\n{\n    OM_uint32 emin;\n    int equal;\n\n    if (GSS_ERROR(gss_compare_name(&emin, n1, n2, &equal)))\n        return(0);\n\n    return(equal);\n}\n\n/* Does a comparison of the names and then releases the first entity */\n/* For use above in CHANGEPW_SERVICE */\nstatic int cmp_gss_names_rel_1(gss_name_t n1, gss_name_t n2)\n{\n    OM_uint32 min_stat;\n    int ret;\n\n    ret = cmp_gss_names(n1, n2);\n    if (n1) (void) gss_release_name(&min_stat, &n1);\n    return ret;\n}\n\n/*\n * Function check_handle\n *\n * Purpose: Check a server handle and return a com_err code if it is\n * invalid or 0 if it is valid.\n *\n * Arguments:\n *\n *      handle          The server handle.\n */\n\nstatic int check_handle(void *handle)\n{\n    CHECK_HANDLE(handle);\n    return 0;\n}\n\n/*\n * Function: new_server_handle\n *\n * Purpose: Constructs a server handle suitable for passing into the\n * server library API functions, by folding the client's API version\n * and calling principal into the server handle returned by\n * kadm5_init.\n *\n * Arguments:\n *      api_version     (input) The API version specified by the client\n *      rqstp           (input) The RPC request\n *      handle          (output) The returned handle\n *      <return value>  (output) An error code, or 0 if no error occurred\n *\n * Effects:\n *      Returns a pointer to allocated storage containing the server\n *      handle.  If an error occurs, then no allocated storage is\n *      returned, and the return value of the function will be a\n *      non-zero com_err code.\n *\n *      The allocated storage for the handle should be freed with\n *      free_server_handle (see below) when it is no longer needed.\n */\n\nstatic kadm5_ret_t new_server_handle(krb5_ui_4 api_version,\n                                     struct svc_req *rqstp,\n                                     kadm5_server_handle_t\n                                     *out_handle)\n{\n    kadm5_server_handle_t handle;\n\n    *out_handle = NULL;\n\n    if (! (handle = (kadm5_server_handle_t)\n           malloc(sizeof(*handle))))\n        return ENOMEM;\n\n    *handle = *(kadm5_server_handle_t)global_server_handle;\n    handle->api_version = api_version;\n\n    if (! gss_to_krb5_name(handle, rqst2name(rqstp),\n                           &handle->current_caller)) {\n        free(handle);\n        return KADM5_FAILURE;\n    }\n\n    *out_handle = handle;\n    return 0;\n}\n\n/*\n * Function: free_server_handle\n *\n * Purpose: Free handle memory allocated by new_server_handle\n *\n * Arguments:\n *      handle          (input/output) The handle to free\n */\nstatic void free_server_handle(kadm5_server_handle_t handle)\n{\n    if (!handle)\n        return;\n    krb5_free_principal(handle->context, handle->current_caller);\n    free(handle);\n}\n\n/* Result is stored in a static buffer and is invalidated by the next call. */\nconst char *\nclient_addr(SVCXPRT *xprt)\n{\n    static char abuf[128];\n    struct sockaddr_storage ss;\n    socklen_t len = sizeof(ss);\n    const char *p = NULL;\n\n    if (getpeername(xprt->xp_sock, ss2sa(&ss), &len) != 0)\n        return \"(unknown)\";\n    if (ss2sa(&ss)->sa_family == AF_INET)\n        p = inet_ntop(AF_INET, &ss2sin(&ss)->sin_addr, abuf, sizeof(abuf));\n    else if (ss2sa(&ss)->sa_family == AF_INET6)\n        p = inet_ntop(AF_INET6, &ss2sin6(&ss)->sin6_addr, abuf, sizeof(abuf));\n    return (p == NULL) ? \"(unknown)\" : p;\n}\n\n/*\n * Function: setup_gss_names\n *\n * Purpose: Create printable representations of the client and server\n * names.\n *\n * Arguments:\n *      rqstp           (r) the RPC request\n *      client_name     (w) the gss_buffer_t for the client name\n *      server_name     (w) the gss_buffer_t for the server name\n *\n * Effects:\n *\n * Unparses the client and server names into client_name and\n * server_name, both of which must be freed by the caller.  Returns 0\n * on success and -1 on failure.\n */\nint setup_gss_names(struct svc_req *rqstp,\n                    gss_buffer_desc *client_name,\n                    gss_buffer_desc *server_name)\n{\n    OM_uint32 maj_stat, min_stat;\n    gss_name_t server_gss_name;\n\n    if (gss_name_to_string(rqst2name(rqstp), client_name) != 0)\n        return -1;\n    maj_stat = gss_inquire_context(&min_stat, rqstp->rq_svccred, NULL,\n                                   &server_gss_name, NULL, NULL, NULL,\n                                   NULL, NULL);\n    if (maj_stat != GSS_S_COMPLETE) {\n        gss_release_buffer(&min_stat, client_name);\n        gss_release_name(&min_stat, &server_gss_name);\n        return -1;\n    }\n    if (gss_name_to_string(server_gss_name, server_name) != 0) {\n        gss_release_buffer(&min_stat, client_name);\n        gss_release_name(&min_stat, &server_gss_name);\n        return -1;\n    }\n    gss_release_name(&min_stat, &server_gss_name);\n    return 0;\n}\n\nstatic gss_name_t acceptor_name(gss_ctx_id_t context)\n{\n    OM_uint32 maj_stat, min_stat;\n    gss_name_t name;\n\n    maj_stat = gss_inquire_context(&min_stat, context, NULL, &name,\n                                   NULL, NULL, NULL, NULL, NULL);\n    if (maj_stat != GSS_S_COMPLETE)\n        return NULL;\n    return name;\n}\n\nstatic int cmp_gss_krb5_name(kadm5_server_handle_t handle,\n                             gss_name_t gss_name, krb5_principal princ)\n{\n    krb5_principal princ2;\n    int status;\n\n    if (! gss_to_krb5_name(handle, gss_name, &princ2))\n        return 0;\n    status = krb5_principal_compare(handle->context, princ, princ2);\n    krb5_free_principal(handle->context, princ2);\n    return status;\n}\n\nstatic int gss_to_krb5_name(kadm5_server_handle_t handle,\n                            gss_name_t gss_name, krb5_principal *princ)\n{\n    OM_uint32 minor_stat;\n    gss_buffer_desc gss_str;\n    int success;\n    char *s;\n\n    if (gss_name_to_string(gss_name, &gss_str) != 0)\n        return 0;\n    if (asprintf(&s, \"%.*s\", (int)gss_str.length, (char *)gss_str.value) < 0) {\n        gss_release_buffer(&minor_stat, &gss_str);\n        return 0;\n    }\n    success = (krb5_parse_name(handle->context, s, princ) == 0);\n    free(s);\n    gss_release_buffer(&minor_stat, &gss_str);\n    return success;\n}\n\nstatic int\ngss_name_to_string(gss_name_t gss_name, gss_buffer_desc *str)\n{\n    OM_uint32 status, minor_stat;\n    gss_OID gss_type;\n    const char pref[] = KRB5_WELLKNOWN_NAMESTR \"/\" KRB5_ANONYMOUS_PRINCSTR \"@\";\n    const size_t preflen = sizeof(pref) - 1;\n\n    status = gss_display_name(&minor_stat, gss_name, str, &gss_type);\n    if (status != GSS_S_COMPLETE)\n        return 1;\n    if (gss_oid_equal(gss_type, GSS_C_NT_ANONYMOUS)) {\n        /* Guard against non-krb5 mechs with different anonymous displays. */\n        if (str->length < preflen || memcmp(str->value, pref, preflen) != 0)\n            return 1;\n    } else if (!gss_oid_equal(gss_type, GSS_KRB5_NT_PRINCIPAL_NAME)) {\n        return 1;\n    }\n    return 0;\n}\n\nstatic int\nlog_unauth(\n    char *op,\n    char *target,\n    gss_buffer_t client,\n    gss_buffer_t server,\n    struct svc_req *rqstp)\n{\n    size_t tlen, clen, slen;\n    char *tdots, *cdots, *sdots;\n\n    tlen = strlen(target);\n    trunc_name(&tlen, &tdots);\n    clen = client->length;\n    trunc_name(&clen, &cdots);\n    slen = server->length;\n    trunc_name(&slen, &sdots);\n\n    /* okay to cast lengths to int because trunc_name limits max value */\n    return krb5_klog_syslog(LOG_NOTICE,\n                            _(\"Unauthorized request: %s, %.*s%s, \"\n                              \"client=%.*s%s, service=%.*s%s, addr=%s\"),\n                            op, (int)tlen, target, tdots,\n                            (int)clen, (char *)client->value, cdots,\n                            (int)slen, (char *)server->value, sdots,\n                            client_addr(rqstp->rq_xprt));\n}\n\nstatic int\nlog_done(\n    char *op,\n    char *target,\n    const char *errmsg,\n    gss_buffer_t client,\n    gss_buffer_t server,\n    struct svc_req *rqstp)\n{\n    size_t tlen, clen, slen;\n    char *tdots, *cdots, *sdots;\n\n    if (errmsg == NULL)\n        errmsg = _(\"success\");\n    tlen = strlen(target);\n    trunc_name(&tlen, &tdots);\n    clen = client->length;\n    trunc_name(&clen, &cdots);\n    slen = server->length;\n    trunc_name(&slen, &sdots);\n\n    /* okay to cast lengths to int because trunc_name limits max value */\n    return krb5_klog_syslog(LOG_NOTICE,\n                            _(\"Request: %s, %.*s%s, %s, \"\n                              \"client=%.*s%s, service=%.*s%s, addr=%s\"),\n                            op, (int)tlen, target, tdots, errmsg,\n                            (int)clen, (char *)client->value, cdots,\n                            (int)slen, (char *)server->value, sdots,\n                            client_addr(rqstp->rq_xprt));\n}\n\ngeneric_ret *\ncreate_principal_2_svc(cprinc_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret          ret;\n    char                        *prime_arg;\n    gss_buffer_desc             client_name, service_name;\n    OM_uint32                   minor_stat;\n    kadm5_server_handle_t       handle;\n    restriction_t               *rp;\n    const char                  *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->rec.principal, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (CHANGEPW_SERVICE(rqstp)\n        || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_ADD,\n                               arg->rec.principal, &rp)\n        || kadm5int_acl_impose_restrictions(handle->context,\n                                            &arg->rec, &arg->mask, rp)) {\n        ret.code = KADM5_AUTH_ADD;\n        log_unauth(\"kadm5_create_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_create_principal((void *)handle,\n                                          &arg->rec, arg->mask,\n                                          arg->passwd);\n\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_create_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}\n\ngeneric_ret *\ncreate_principal3_2_svc(cprinc3_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret          ret;\n    char                        *prime_arg;\n    gss_buffer_desc             client_name, service_name;\n    OM_uint32                   minor_stat;\n    kadm5_server_handle_t       handle;\n    restriction_t               *rp;\n    const char                  *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->rec.principal, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (CHANGEPW_SERVICE(rqstp)\n        || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_ADD,\n                               arg->rec.principal, &rp)\n        || kadm5int_acl_impose_restrictions(handle->context,\n                                            &arg->rec, &arg->mask, rp)) {\n        ret.code = KADM5_AUTH_ADD;\n        log_unauth(\"kadm5_create_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_create_principal_3((void *)handle,\n                                            &arg->rec, arg->mask,\n                                            arg->n_ks_tuple,\n                                            arg->ks_tuple,\n                                            arg->passwd);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_create_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}\n\ngeneric_ret *\ndelete_principal_2_svc(dprinc_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (CHANGEPW_SERVICE(rqstp)\n        || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_DELETE,\n                               arg->princ, NULL)) {\n        ret.code = KADM5_AUTH_DELETE;\n        log_unauth(\"kadm5_delete_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_delete_principal((void *)handle, arg->princ);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_delete_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}\n\ngeneric_ret *\nmodify_principal_2_svc(mprinc_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    restriction_t                   *rp;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->rec.principal, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (CHANGEPW_SERVICE(rqstp)\n        || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_MODIFY,\n                               arg->rec.principal, &rp)\n        || kadm5int_acl_impose_restrictions(handle->context,\n                                            &arg->rec, &arg->mask, rp)) {\n        ret.code = KADM5_AUTH_MODIFY;\n        log_unauth(\"kadm5_modify_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_modify_principal((void *)handle, &arg->rec,\n                                          arg->mask);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_modify_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}\n\ngeneric_ret *\nrename_principal_2_svc(rprinc_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret          ret;\n    char                        *prime_arg1,\n        *prime_arg2;\n    gss_buffer_desc             client_name,\n        service_name;\n    OM_uint32                   minor_stat;\n    kadm5_server_handle_t       handle;\n    restriction_t               *rp;\n    const char                  *errmsg = NULL;\n    size_t                      tlen1, tlen2, clen, slen;\n    char                        *tdots1, *tdots2, *cdots, *sdots;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->src, &prime_arg1) ||\n        krb5_unparse_name(handle->context, arg->dest, &prime_arg2)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n    tlen1 = strlen(prime_arg1);\n    trunc_name(&tlen1, &tdots1);\n    tlen2 = strlen(prime_arg2);\n    trunc_name(&tlen2, &tdots2);\n    clen = client_name.length;\n    trunc_name(&clen, &cdots);\n    slen = service_name.length;\n    trunc_name(&slen, &sdots);\n\n    ret.code = KADM5_OK;\n    if (! CHANGEPW_SERVICE(rqstp)) {\n        if (!kadm5int_acl_check(handle->context, rqst2name(rqstp),\n                                ACL_DELETE, arg->src, NULL))\n            ret.code = KADM5_AUTH_DELETE;\n        /* any restrictions at all on the ADD kills the RENAME */\n        if (!kadm5int_acl_check(handle->context, rqst2name(rqstp),\n                                ACL_ADD, arg->dest, &rp) || rp) {\n            if (ret.code == KADM5_AUTH_DELETE)\n                ret.code = KADM5_AUTH_INSUFFICIENT;\n            else\n                ret.code = KADM5_AUTH_ADD;\n        }\n    } else\n        ret.code = KADM5_AUTH_INSUFFICIENT;\n    if (ret.code != KADM5_OK) {\n        /* okay to cast lengths to int because trunc_name limits max value */\n        krb5_klog_syslog(LOG_NOTICE,\n                         _(\"Unauthorized request: kadm5_rename_principal, \"\n                           \"%.*s%s to %.*s%s, \"\n                           \"client=%.*s%s, service=%.*s%s, addr=%s\"),\n                         (int)tlen1, prime_arg1, tdots1,\n                         (int)tlen2, prime_arg2, tdots2,\n                         (int)clen, (char *)client_name.value, cdots,\n                         (int)slen, (char *)service_name.value, sdots,\n                         client_addr(rqstp->rq_xprt));\n    } else {\n        ret.code = kadm5_rename_principal((void *)handle, arg->src,\n                                          arg->dest);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        /* okay to cast lengths to int because trunc_name limits max value */\n        krb5_klog_syslog(LOG_NOTICE,\n                         _(\"Request: kadm5_rename_principal, \"\n                           \"%.*s%s to %.*s%s, %s, \"\n                           \"client=%.*s%s, service=%.*s%s, addr=%s\"),\n                         (int)tlen1, prime_arg1, tdots1,\n                         (int)tlen2, prime_arg2, tdots2,\n                         errmsg ? errmsg : _(\"success\"),\n                         (int)clen, (char *)client_name.value, cdots,\n                         (int)slen, (char *)service_name.value, sdots,\n                         client_addr(rqstp->rq_xprt));\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n\n    }\n    free(prime_arg1);\n    free(prime_arg2);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}\n\ngprinc_ret *\nget_principal_2_svc(gprinc_arg *arg, struct svc_req *rqstp)\n{\n    static gprinc_ret               ret;\n    char                            *prime_arg, *funcname;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_gprinc_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    funcname = \"kadm5_get_principal\";\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (! cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ) &&\n        (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                        rqst2name(rqstp),\n                                                        ACL_INQUIRE,\n                                                        arg->princ,\n                                                        NULL))) {\n        ret.code = KADM5_AUTH_GET;\n        log_unauth(funcname, prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_get_principal(handle, arg->princ, &ret.rec,\n                                       arg->mask);\n\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(funcname, prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}\n\ngprincs_ret *\nget_princs_2_svc(gprincs_arg *arg, struct svc_req *rqstp)\n{\n    static gprincs_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_gprincs_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    prime_arg = arg->exp;\n    if (prime_arg == NULL)\n        prime_arg = \"*\";\n\n    if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                       rqst2name(rqstp),\n                                                       ACL_LIST,\n                                                       NULL,\n                                                       NULL)) {\n        ret.code = KADM5_AUTH_LIST;\n        log_unauth(\"kadm5_get_principals\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code  = kadm5_get_principals((void *)handle,\n                                         arg->exp, &ret.princs,\n                                         &ret.count);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_get_principals\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n\n    }\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}\n\ngeneric_ret *\nchpass_principal_2_svc(chpass_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ)) {\n        ret.code = chpass_principal_wrapper_3((void *)handle, arg->princ,\n                                              FALSE, 0, NULL, arg->pass);\n    } else if (!(CHANGEPW_SERVICE(rqstp)) &&\n               kadm5int_acl_check(handle->context, rqst2name(rqstp),\n                                  ACL_CHANGEPW, arg->princ, NULL)) {\n        ret.code = kadm5_chpass_principal((void *)handle, arg->princ,\n                                          arg->pass);\n    } else {\n        log_unauth(\"kadm5_chpass_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_CHANGEPW;\n    }\n\n    if (ret.code != KADM5_AUTH_CHANGEPW) {\n        if (ret.code != 0)\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_chpass_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}\n\ngeneric_ret *\nchpass_principal3_2_svc(chpass3_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ)) {\n        ret.code = chpass_principal_wrapper_3((void *)handle, arg->princ,\n                                              arg->keepold,\n                                              arg->n_ks_tuple,\n                                              arg->ks_tuple,\n                                              arg->pass);\n    } else if (!(CHANGEPW_SERVICE(rqstp)) &&\n               kadm5int_acl_check(handle->context, rqst2name(rqstp),\n                                  ACL_CHANGEPW, arg->princ, NULL)) {\n        ret.code = kadm5_chpass_principal_3((void *)handle, arg->princ,\n                                            arg->keepold,\n                                            arg->n_ks_tuple,\n                                            arg->ks_tuple,\n                                            arg->pass);\n    } else {\n        log_unauth(\"kadm5_chpass_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_CHANGEPW;\n    }\n\n    if(ret.code != KADM5_AUTH_CHANGEPW) {\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_chpass_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}\n\ngeneric_ret *\nsetv4key_principal_2_svc(setv4key_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (!(CHANGEPW_SERVICE(rqstp)) &&\n        kadm5int_acl_check(handle->context, rqst2name(rqstp),\n                           ACL_SETKEY, arg->princ, NULL)) {\n        ret.code = kadm5_setv4key_principal((void *)handle, arg->princ,\n                                            arg->keyblock);\n    } else {\n        log_unauth(\"kadm5_setv4key_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_SETKEY;\n    }\n\n    if(ret.code != KADM5_AUTH_SETKEY) {\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_setv4key_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}\n\ngeneric_ret *\nsetkey_principal_2_svc(setkey_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (!(CHANGEPW_SERVICE(rqstp)) &&\n        kadm5int_acl_check(handle->context, rqst2name(rqstp),\n                           ACL_SETKEY, arg->princ, NULL)) {\n        ret.code = kadm5_setkey_principal((void *)handle, arg->princ,\n                                          arg->keyblocks, arg->n_keys);\n    } else {\n        log_unauth(\"kadm5_setkey_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_SETKEY;\n    }\n\n    if(ret.code != KADM5_AUTH_SETKEY) {\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_setkey_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}\n\ngeneric_ret *\nsetkey_principal3_2_svc(setkey3_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (!(CHANGEPW_SERVICE(rqstp)) &&\n        kadm5int_acl_check(handle->context, rqst2name(rqstp),\n                           ACL_SETKEY, arg->princ, NULL)) {\n        ret.code = kadm5_setkey_principal_3((void *)handle, arg->princ,\n                                            arg->keepold,\n                                            arg->n_ks_tuple,\n                                            arg->ks_tuple,\n                                            arg->keyblocks, arg->n_keys);\n    } else {\n        log_unauth(\"kadm5_setkey_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_SETKEY;\n    }\n\n    if(ret.code != KADM5_AUTH_SETKEY) {\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_setkey_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}\n\nchrand_ret *\nchrand_principal_2_svc(chrand_arg *arg, struct svc_req *rqstp)\n{\n    static chrand_ret           ret;\n    krb5_keyblock               *k;\n    int                         nkeys;\n    char                        *prime_arg, *funcname;\n    gss_buffer_desc             client_name,\n        service_name;\n    OM_uint32                   minor_stat;\n    kadm5_server_handle_t       handle;\n    const char                  *errmsg = NULL;\n\n    xdr_free(xdr_chrand_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    funcname = \"kadm5_randkey_principal\";\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ)) {\n        ret.code = randkey_principal_wrapper_3((void *)handle, arg->princ,\n                                               FALSE, 0, NULL, &k, &nkeys);\n    } else if (!(CHANGEPW_SERVICE(rqstp)) &&\n               kadm5int_acl_check(handle->context, rqst2name(rqstp),\n                                  ACL_CHANGEPW, arg->princ, NULL)) {\n        ret.code = kadm5_randkey_principal((void *)handle, arg->princ,\n                                           &k, &nkeys);\n    } else {\n        log_unauth(funcname, prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_CHANGEPW;\n    }\n\n    if(ret.code == KADM5_OK) {\n        ret.keys = k;\n        ret.n_keys = nkeys;\n    }\n\n    if(ret.code != KADM5_AUTH_CHANGEPW) {\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(funcname, prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}\n\nchrand_ret *\nchrand_principal3_2_svc(chrand3_arg *arg, struct svc_req *rqstp)\n{\n    static chrand_ret           ret;\n    krb5_keyblock               *k;\n    int                         nkeys;\n    char                        *prime_arg, *funcname;\n    gss_buffer_desc             client_name,\n        service_name;\n    OM_uint32                   minor_stat;\n    kadm5_server_handle_t       handle;\n    const char                  *errmsg = NULL;\n\n    xdr_free(xdr_chrand_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    funcname = \"kadm5_randkey_principal\";\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ)) {\n        ret.code = randkey_principal_wrapper_3((void *)handle, arg->princ,\n                                               arg->keepold,\n                                               arg->n_ks_tuple,\n                                               arg->ks_tuple,\n                                               &k, &nkeys);\n    } else if (!(CHANGEPW_SERVICE(rqstp)) &&\n               kadm5int_acl_check(handle->context, rqst2name(rqstp),\n                                  ACL_CHANGEPW, arg->princ, NULL)) {\n        ret.code = kadm5_randkey_principal_3((void *)handle, arg->princ,\n                                             arg->keepold,\n                                             arg->n_ks_tuple,\n                                             arg->ks_tuple,\n                                             &k, &nkeys);\n    } else {\n        log_unauth(funcname, prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_CHANGEPW;\n    }\n\n    if(ret.code == KADM5_OK) {\n        ret.keys = k;\n        ret.n_keys = nkeys;\n    }\n\n    if(ret.code != KADM5_AUTH_CHANGEPW) {\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(funcname, prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}\n\ngeneric_ret *\ncreate_policy_2_svc(cpol_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    prime_arg = arg->rec.policy;\n\n    if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                       rqst2name(rqstp),\n                                                       ACL_ADD, NULL, NULL)) {\n        ret.code = KADM5_AUTH_ADD;\n        log_unauth(\"kadm5_create_policy\", prime_arg,\n                   &client_name, &service_name, rqstp);\n\n    } else {\n        ret.code = kadm5_create_policy((void *)handle, &arg->rec,\n                                       arg->mask);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_create_policy\",\n                 ((prime_arg == NULL) ? \"(null)\" : prime_arg), errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}\n\ngeneric_ret *\ndelete_policy_2_svc(dpol_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    prime_arg = arg->name;\n\n    if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                       rqst2name(rqstp),\n                                                       ACL_DELETE, NULL, NULL)) {\n        log_unauth(\"kadm5_delete_policy\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_DELETE;\n    } else {\n        ret.code = kadm5_delete_policy((void *)handle, arg->name);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_delete_policy\",\n                 ((prime_arg == NULL) ? \"(null)\" : prime_arg), errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}\n\ngeneric_ret *\nmodify_policy_2_svc(mpol_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    prime_arg = arg->rec.policy;\n\n    if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                       rqst2name(rqstp),\n                                                       ACL_MODIFY, NULL, NULL)) {\n        log_unauth(\"kadm5_modify_policy\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_MODIFY;\n    } else {\n        ret.code = kadm5_modify_policy((void *)handle, &arg->rec,\n                                       arg->mask);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_modify_policy\",\n                 ((prime_arg == NULL) ? \"(null)\" : prime_arg), errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}\n\ngpol_ret *\nget_policy_2_svc(gpol_arg *arg, struct svc_req *rqstp)\n{\n    static gpol_ret             ret;\n    kadm5_ret_t         ret2;\n    char                        *prime_arg, *funcname;\n    gss_buffer_desc             client_name,\n        service_name;\n    OM_uint32                   minor_stat;\n    kadm5_principal_ent_rec     caller_ent;\n    kadm5_server_handle_t       handle;\n    const char                  *errmsg = NULL;\n\n    xdr_free(xdr_gpol_ret,  &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    funcname = \"kadm5_get_policy\";\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    prime_arg = arg->name;\n\n    ret.code = KADM5_AUTH_GET;\n    if (!CHANGEPW_SERVICE(rqstp) && kadm5int_acl_check(handle->context,\n                                                       rqst2name(rqstp),\n                                                       ACL_INQUIRE, NULL, NULL))\n        ret.code = KADM5_OK;\n    else {\n        ret.code = kadm5_get_principal(handle->lhandle,\n                                       handle->current_caller,\n                                       &caller_ent,\n                                       KADM5_PRINCIPAL_NORMAL_MASK);\n        if (ret.code == KADM5_OK) {\n            if (caller_ent.aux_attributes & KADM5_POLICY &&\n                strcmp(caller_ent.policy, arg->name) == 0) {\n                ret.code = KADM5_OK;\n            } else ret.code = KADM5_AUTH_GET;\n            ret2 = kadm5_free_principal_ent(handle->lhandle,\n                                            &caller_ent);\n            ret.code = ret.code ? ret.code : ret2;\n        }\n    }\n\n    if (ret.code == KADM5_OK) {\n        ret.code = kadm5_get_policy(handle, arg->name, &ret.rec);\n\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(funcname,\n                 ((prime_arg == NULL) ? \"(null)\" : prime_arg), errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n\n    } else {\n        log_unauth(funcname, prime_arg,\n                   &client_name, &service_name, rqstp);\n    }\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n\n}\n\ngpols_ret *\nget_pols_2_svc(gpols_arg *arg, struct svc_req *rqstp)\n{\n    static gpols_ret                ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_gpols_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    prime_arg = arg->exp;\n    if (prime_arg == NULL)\n        prime_arg = \"*\";\n\n    if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                       rqst2name(rqstp),\n                                                       ACL_LIST, NULL, NULL)) {\n        ret.code = KADM5_AUTH_LIST;\n        log_unauth(\"kadm5_get_policies\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code  = kadm5_get_policies((void *)handle,\n                                       arg->exp, &ret.pols,\n                                       &ret.count);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_get_policies\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}\n\ngetprivs_ret * get_privs_2_svc(krb5_ui_4 *arg, struct svc_req *rqstp)\n{\n    static getprivs_ret            ret;\n    gss_buffer_desc                client_name, service_name;\n    OM_uint32                      minor_stat;\n    kadm5_server_handle_t          handle;\n    const char                     *errmsg = NULL;\n\n    xdr_free(xdr_getprivs_ret, &ret);\n\n    if ((ret.code = new_server_handle(*arg, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n\n    ret.code = kadm5_get_privs((void *)handle, &ret.privs);\n    if( ret.code != 0 )\n        errmsg = krb5_get_error_message(handle->context, ret.code);\n\n    log_done(\"kadm5_get_privs\", client_name.value, errmsg,\n             &client_name, &service_name, rqstp);\n\n    if (errmsg != NULL)\n        krb5_free_error_message(handle->context, errmsg);\n\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}\n\ngeneric_ret *\npurgekeys_2_svc(purgekeys_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret          ret;\n    char                        *prime_arg, *funcname;\n    gss_buffer_desc             client_name, service_name;\n    OM_uint32                   minor_stat;\n    kadm5_server_handle_t       handle;\n\n    const char                  *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    funcname = \"kadm5_purgekeys\";\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (!cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ) &&\n        (CHANGEPW_SERVICE(rqstp)\n         || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_MODIFY,\n                                arg->princ, NULL))) {\n        ret.code = KADM5_AUTH_MODIFY;\n        log_unauth(funcname, prime_arg, &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_purgekeys((void *)handle, arg->princ,\n                                   arg->keepkvno);\n        if (ret.code != 0)\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(funcname, prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}\n\ngstrings_ret *\nget_strings_2_svc(gstrings_arg *arg, struct svc_req *rqstp)\n{\n    static gstrings_ret             ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_gstrings_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (! cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ) &&\n        (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                        rqst2name(rqstp),\n                                                        ACL_INQUIRE,\n                                                        arg->princ,\n                                                        NULL))) {\n        ret.code = KADM5_AUTH_GET;\n        log_unauth(\"kadm5_get_strings\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_get_strings((void *)handle, arg->princ, &ret.strings,\n                                     &ret.count);\n        if (ret.code != 0)\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_get_strings\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}\n\ngeneric_ret *\nset_string_2_svc(sstring_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (CHANGEPW_SERVICE(rqstp)\n        || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_MODIFY,\n                               arg->princ, NULL)) {\n        ret.code = KADM5_AUTH_MODIFY;\n        log_unauth(\"kadm5_mod_strings\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_set_string((void *)handle, arg->princ, arg->key,\n                                    arg->value);\n        if (ret.code != 0)\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_mod_strings\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}\n\ngeneric_ret *init_2_svc(krb5_ui_4 *arg, struct svc_req *rqstp)\n{\n    static generic_ret         ret;\n    gss_buffer_desc            client_name,\n        service_name;\n    kadm5_server_handle_t      handle;\n    OM_uint32                  minor_stat;\n    const char                 *errmsg = NULL;\n    size_t clen, slen;\n    char *cdots, *sdots;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(*arg, rqstp, &handle)))\n        goto exit_func;\n    if (! (ret.code = check_handle((void *)handle))) {\n        ret.api_version = handle->api_version;\n    }\n\n    free_server_handle(handle);\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n\n    if (ret.code != 0)\n        errmsg = krb5_get_error_message(NULL, ret.code);\n\n    clen = client_name.length;\n    trunc_name(&clen, &cdots);\n    slen = service_name.length;\n    trunc_name(&slen, &sdots);\n    /* okay to cast lengths to int because trunc_name limits max value */\n    krb5_klog_syslog(LOG_NOTICE, _(\"Request: kadm5_init, %.*s%s, %s, \"\n                                   \"client=%.*s%s, service=%.*s%s, addr=%s, \"\n                                   \"vers=%d, flavor=%d\"),\n                     (int)clen, (char *)client_name.value, cdots,\n                     errmsg ? errmsg : _(\"success\"),\n                     (int)clen, (char *)client_name.value, cdots,\n                     (int)slen, (char *)service_name.value, sdots,\n                     client_addr(rqstp->rq_xprt),\n                     ret.api_version & ~(KADM5_API_VERSION_MASK),\n                     rqstp->rq_cred.oa_flavor);\n    if (errmsg != NULL)\n        krb5_free_error_message(NULL, errmsg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n\nexit_func:\n    return(&ret);\n}\n\ngss_name_t\nrqst2name(struct svc_req *rqstp)\n{\n\n    if (rqstp->rq_cred.oa_flavor == RPCSEC_GSS)\n        return rqstp->rq_clntname;\n    else\n        return rqstp->rq_clntcred;\n}\n"], "fixing_code": ["/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/*\n * Copyright 1993 OpenVision Technologies, Inc., All Rights Reserved\n *\n */\n\n#include <k5-platform.h>\n#include <socket-utils.h>\n#include <gssapi/gssapi.h>\n#include <gssapi/gssapi_krb5.h> /* for gss_nt_krb5_name */\n#include <krb5.h>\n#include <kadm5/admin.h>\n#include <kadm5/kadm_rpc.h>\n#include <kadm5/server_internal.h>\n#include <kadm5/server_acl.h>\n#include <syslog.h>\n#include <adm_proto.h>  /* krb5_klog_syslog */\n#include \"misc.h\"\n\nextern gss_name_t                       gss_changepw_name;\nextern gss_name_t                       gss_oldchangepw_name;\nextern void *                           global_server_handle;\n\n#define CHANGEPW_SERVICE(rqstp)                                         \\\n    (cmp_gss_names_rel_1(acceptor_name(rqstp->rq_svccred), gss_changepw_name) | \\\n     (gss_oldchangepw_name &&                                           \\\n      cmp_gss_names_rel_1(acceptor_name(rqstp->rq_svccred),             \\\n                          gss_oldchangepw_name)))\n\n\nstatic int gss_to_krb5_name(kadm5_server_handle_t handle,\n                            gss_name_t gss_name, krb5_principal *princ);\n\nstatic int gss_name_to_string(gss_name_t gss_name, gss_buffer_desc *str);\n\nstatic gss_name_t acceptor_name(gss_ctx_id_t context);\n\ngss_name_t rqst2name(struct svc_req *rqstp);\n\nstatic int cmp_gss_names(gss_name_t n1, gss_name_t n2)\n{\n    OM_uint32 emin;\n    int equal;\n\n    if (GSS_ERROR(gss_compare_name(&emin, n1, n2, &equal)))\n        return(0);\n\n    return(equal);\n}\n\n/* Does a comparison of the names and then releases the first entity */\n/* For use above in CHANGEPW_SERVICE */\nstatic int cmp_gss_names_rel_1(gss_name_t n1, gss_name_t n2)\n{\n    OM_uint32 min_stat;\n    int ret;\n\n    ret = cmp_gss_names(n1, n2);\n    if (n1) (void) gss_release_name(&min_stat, &n1);\n    return ret;\n}\n\n/*\n * Function check_handle\n *\n * Purpose: Check a server handle and return a com_err code if it is\n * invalid or 0 if it is valid.\n *\n * Arguments:\n *\n *      handle          The server handle.\n */\n\nstatic int check_handle(void *handle)\n{\n    CHECK_HANDLE(handle);\n    return 0;\n}\n\n/*\n * Function: new_server_handle\n *\n * Purpose: Constructs a server handle suitable for passing into the\n * server library API functions, by folding the client's API version\n * and calling principal into the server handle returned by\n * kadm5_init.\n *\n * Arguments:\n *      api_version     (input) The API version specified by the client\n *      rqstp           (input) The RPC request\n *      handle          (output) The returned handle\n *      <return value>  (output) An error code, or 0 if no error occurred\n *\n * Effects:\n *      Returns a pointer to allocated storage containing the server\n *      handle.  If an error occurs, then no allocated storage is\n *      returned, and the return value of the function will be a\n *      non-zero com_err code.\n *\n *      The allocated storage for the handle should be freed with\n *      free_server_handle (see below) when it is no longer needed.\n */\n\nstatic kadm5_ret_t new_server_handle(krb5_ui_4 api_version,\n                                     struct svc_req *rqstp,\n                                     kadm5_server_handle_t\n                                     *out_handle)\n{\n    kadm5_server_handle_t handle;\n\n    *out_handle = NULL;\n\n    if (! (handle = (kadm5_server_handle_t)\n           malloc(sizeof(*handle))))\n        return ENOMEM;\n\n    *handle = *(kadm5_server_handle_t)global_server_handle;\n    handle->api_version = api_version;\n\n    if (! gss_to_krb5_name(handle, rqst2name(rqstp),\n                           &handle->current_caller)) {\n        free(handle);\n        return KADM5_FAILURE;\n    }\n\n    *out_handle = handle;\n    return 0;\n}\n\n/*\n * Function: free_server_handle\n *\n * Purpose: Free handle memory allocated by new_server_handle\n *\n * Arguments:\n *      handle          (input/output) The handle to free\n */\nstatic void free_server_handle(kadm5_server_handle_t handle)\n{\n    if (!handle)\n        return;\n    krb5_free_principal(handle->context, handle->current_caller);\n    free(handle);\n}\n\n/* Result is stored in a static buffer and is invalidated by the next call. */\nconst char *\nclient_addr(SVCXPRT *xprt)\n{\n    static char abuf[128];\n    struct sockaddr_storage ss;\n    socklen_t len = sizeof(ss);\n    const char *p = NULL;\n\n    if (getpeername(xprt->xp_sock, ss2sa(&ss), &len) != 0)\n        return \"(unknown)\";\n    if (ss2sa(&ss)->sa_family == AF_INET)\n        p = inet_ntop(AF_INET, &ss2sin(&ss)->sin_addr, abuf, sizeof(abuf));\n    else if (ss2sa(&ss)->sa_family == AF_INET6)\n        p = inet_ntop(AF_INET6, &ss2sin6(&ss)->sin6_addr, abuf, sizeof(abuf));\n    return (p == NULL) ? \"(unknown)\" : p;\n}\n\n/*\n * Function: setup_gss_names\n *\n * Purpose: Create printable representations of the client and server\n * names.\n *\n * Arguments:\n *      rqstp           (r) the RPC request\n *      client_name     (w) the gss_buffer_t for the client name\n *      server_name     (w) the gss_buffer_t for the server name\n *\n * Effects:\n *\n * Unparses the client and server names into client_name and\n * server_name, both of which must be freed by the caller.  Returns 0\n * on success and -1 on failure.\n */\nint setup_gss_names(struct svc_req *rqstp,\n                    gss_buffer_desc *client_name,\n                    gss_buffer_desc *server_name)\n{\n    OM_uint32 maj_stat, min_stat;\n    gss_name_t server_gss_name;\n\n    if (gss_name_to_string(rqst2name(rqstp), client_name) != 0)\n        return -1;\n    maj_stat = gss_inquire_context(&min_stat, rqstp->rq_svccred, NULL,\n                                   &server_gss_name, NULL, NULL, NULL,\n                                   NULL, NULL);\n    if (maj_stat != GSS_S_COMPLETE) {\n        gss_release_buffer(&min_stat, client_name);\n        gss_release_name(&min_stat, &server_gss_name);\n        return -1;\n    }\n    if (gss_name_to_string(server_gss_name, server_name) != 0) {\n        gss_release_buffer(&min_stat, client_name);\n        gss_release_name(&min_stat, &server_gss_name);\n        return -1;\n    }\n    gss_release_name(&min_stat, &server_gss_name);\n    return 0;\n}\n\nstatic gss_name_t acceptor_name(gss_ctx_id_t context)\n{\n    OM_uint32 maj_stat, min_stat;\n    gss_name_t name;\n\n    maj_stat = gss_inquire_context(&min_stat, context, NULL, &name,\n                                   NULL, NULL, NULL, NULL, NULL);\n    if (maj_stat != GSS_S_COMPLETE)\n        return NULL;\n    return name;\n}\n\nstatic int cmp_gss_krb5_name(kadm5_server_handle_t handle,\n                             gss_name_t gss_name, krb5_principal princ)\n{\n    krb5_principal princ2;\n    int status;\n\n    if (! gss_to_krb5_name(handle, gss_name, &princ2))\n        return 0;\n    status = krb5_principal_compare(handle->context, princ, princ2);\n    krb5_free_principal(handle->context, princ2);\n    return status;\n}\n\nstatic int gss_to_krb5_name(kadm5_server_handle_t handle,\n                            gss_name_t gss_name, krb5_principal *princ)\n{\n    OM_uint32 minor_stat;\n    gss_buffer_desc gss_str;\n    int success;\n    char *s;\n\n    if (gss_name_to_string(gss_name, &gss_str) != 0)\n        return 0;\n    if (asprintf(&s, \"%.*s\", (int)gss_str.length, (char *)gss_str.value) < 0) {\n        gss_release_buffer(&minor_stat, &gss_str);\n        return 0;\n    }\n    success = (krb5_parse_name(handle->context, s, princ) == 0);\n    free(s);\n    gss_release_buffer(&minor_stat, &gss_str);\n    return success;\n}\n\nstatic int\ngss_name_to_string(gss_name_t gss_name, gss_buffer_desc *str)\n{\n    OM_uint32 status, minor_stat;\n    gss_OID gss_type;\n    const char pref[] = KRB5_WELLKNOWN_NAMESTR \"/\" KRB5_ANONYMOUS_PRINCSTR \"@\";\n    const size_t preflen = sizeof(pref) - 1;\n\n    status = gss_display_name(&minor_stat, gss_name, str, &gss_type);\n    if (status != GSS_S_COMPLETE)\n        return 1;\n    if (gss_oid_equal(gss_type, GSS_C_NT_ANONYMOUS)) {\n        /* Guard against non-krb5 mechs with different anonymous displays. */\n        if (str->length < preflen || memcmp(str->value, pref, preflen) != 0)\n            return 1;\n    } else if (!gss_oid_equal(gss_type, GSS_KRB5_NT_PRINCIPAL_NAME)) {\n        return 1;\n    }\n    return 0;\n}\n\nstatic int\nlog_unauth(\n    char *op,\n    char *target,\n    gss_buffer_t client,\n    gss_buffer_t server,\n    struct svc_req *rqstp)\n{\n    size_t tlen, clen, slen;\n    char *tdots, *cdots, *sdots;\n\n    tlen = strlen(target);\n    trunc_name(&tlen, &tdots);\n    clen = client->length;\n    trunc_name(&clen, &cdots);\n    slen = server->length;\n    trunc_name(&slen, &sdots);\n\n    /* okay to cast lengths to int because trunc_name limits max value */\n    return krb5_klog_syslog(LOG_NOTICE,\n                            _(\"Unauthorized request: %s, %.*s%s, \"\n                              \"client=%.*s%s, service=%.*s%s, addr=%s\"),\n                            op, (int)tlen, target, tdots,\n                            (int)clen, (char *)client->value, cdots,\n                            (int)slen, (char *)server->value, sdots,\n                            client_addr(rqstp->rq_xprt));\n}\n\nstatic int\nlog_done(\n    char *op,\n    char *target,\n    const char *errmsg,\n    gss_buffer_t client,\n    gss_buffer_t server,\n    struct svc_req *rqstp)\n{\n    size_t tlen, clen, slen;\n    char *tdots, *cdots, *sdots;\n\n    if (errmsg == NULL)\n        errmsg = _(\"success\");\n    tlen = strlen(target);\n    trunc_name(&tlen, &tdots);\n    clen = client->length;\n    trunc_name(&clen, &cdots);\n    slen = server->length;\n    trunc_name(&slen, &sdots);\n\n    /* okay to cast lengths to int because trunc_name limits max value */\n    return krb5_klog_syslog(LOG_NOTICE,\n                            _(\"Request: %s, %.*s%s, %s, \"\n                              \"client=%.*s%s, service=%.*s%s, addr=%s\"),\n                            op, (int)tlen, target, tdots, errmsg,\n                            (int)clen, (char *)client->value, cdots,\n                            (int)slen, (char *)server->value, sdots,\n                            client_addr(rqstp->rq_xprt));\n}\n\ngeneric_ret *\ncreate_principal_2_svc(cprinc_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret          ret;\n    char                        *prime_arg;\n    gss_buffer_desc             client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc             service_name = GSS_C_EMPTY_BUFFER;\n    OM_uint32                   minor_stat;\n    kadm5_server_handle_t       handle;\n    restriction_t               *rp;\n    const char                  *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->rec.principal, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (CHANGEPW_SERVICE(rqstp)\n        || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_ADD,\n                               arg->rec.principal, &rp)\n        || kadm5int_acl_impose_restrictions(handle->context,\n                                            &arg->rec, &arg->mask, rp)) {\n        ret.code = KADM5_AUTH_ADD;\n        log_unauth(\"kadm5_create_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_create_principal((void *)handle,\n                                          &arg->rec, arg->mask,\n                                          arg->passwd);\n\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_create_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n\nexit_func:\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    free_server_handle(handle);\n    return &ret;\n}\n\ngeneric_ret *\ncreate_principal3_2_svc(cprinc3_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret          ret;\n    char                        *prime_arg;\n    gss_buffer_desc             client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc             service_name = GSS_C_EMPTY_BUFFER;\n    OM_uint32                   minor_stat;\n    kadm5_server_handle_t       handle;\n    restriction_t               *rp;\n    const char                  *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->rec.principal, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (CHANGEPW_SERVICE(rqstp)\n        || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_ADD,\n                               arg->rec.principal, &rp)\n        || kadm5int_acl_impose_restrictions(handle->context,\n                                            &arg->rec, &arg->mask, rp)) {\n        ret.code = KADM5_AUTH_ADD;\n        log_unauth(\"kadm5_create_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_create_principal_3((void *)handle,\n                                            &arg->rec, arg->mask,\n                                            arg->n_ks_tuple,\n                                            arg->ks_tuple,\n                                            arg->passwd);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_create_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n\nexit_func:\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    free_server_handle(handle);\n    return &ret;\n}\n\ngeneric_ret *\ndelete_principal_2_svc(dprinc_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (CHANGEPW_SERVICE(rqstp)\n        || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_DELETE,\n                               arg->princ, NULL)) {\n        ret.code = KADM5_AUTH_DELETE;\n        log_unauth(\"kadm5_delete_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_delete_principal((void *)handle, arg->princ);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_delete_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n\n    }\n    free(prime_arg);\n\nexit_func:\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    free_server_handle(handle);\n    return &ret;\n}\n\ngeneric_ret *\nmodify_principal_2_svc(mprinc_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    restriction_t                   *rp;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->rec.principal, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (CHANGEPW_SERVICE(rqstp)\n        || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_MODIFY,\n                               arg->rec.principal, &rp)\n        || kadm5int_acl_impose_restrictions(handle->context,\n                                            &arg->rec, &arg->mask, rp)) {\n        ret.code = KADM5_AUTH_MODIFY;\n        log_unauth(\"kadm5_modify_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_modify_principal((void *)handle, &arg->rec,\n                                          arg->mask);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_modify_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\nexit_func:\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    free_server_handle(handle);\n    return &ret;\n}\n\ngeneric_ret *\nrename_principal_2_svc(rprinc_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret          ret;\n    char                        *prime_arg1 = NULL, *prime_arg2 = NULL;\n    gss_buffer_desc             client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc             service_name = GSS_C_EMPTY_BUFFER;\n    OM_uint32                   minor_stat;\n    kadm5_server_handle_t       handle;\n    restriction_t               *rp;\n    const char                  *errmsg = NULL;\n    size_t                      tlen1, tlen2, clen, slen;\n    char                        *tdots1, *tdots2, *cdots, *sdots;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->src, &prime_arg1) ||\n        krb5_unparse_name(handle->context, arg->dest, &prime_arg2)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n    tlen1 = strlen(prime_arg1);\n    trunc_name(&tlen1, &tdots1);\n    tlen2 = strlen(prime_arg2);\n    trunc_name(&tlen2, &tdots2);\n    clen = client_name.length;\n    trunc_name(&clen, &cdots);\n    slen = service_name.length;\n    trunc_name(&slen, &sdots);\n\n    ret.code = KADM5_OK;\n    if (! CHANGEPW_SERVICE(rqstp)) {\n        if (!kadm5int_acl_check(handle->context, rqst2name(rqstp),\n                                ACL_DELETE, arg->src, NULL))\n            ret.code = KADM5_AUTH_DELETE;\n        /* any restrictions at all on the ADD kills the RENAME */\n        if (!kadm5int_acl_check(handle->context, rqst2name(rqstp),\n                                ACL_ADD, arg->dest, &rp) || rp) {\n            if (ret.code == KADM5_AUTH_DELETE)\n                ret.code = KADM5_AUTH_INSUFFICIENT;\n            else\n                ret.code = KADM5_AUTH_ADD;\n        }\n    } else\n        ret.code = KADM5_AUTH_INSUFFICIENT;\n    if (ret.code != KADM5_OK) {\n        /* okay to cast lengths to int because trunc_name limits max value */\n        krb5_klog_syslog(LOG_NOTICE,\n                         _(\"Unauthorized request: kadm5_rename_principal, \"\n                           \"%.*s%s to %.*s%s, \"\n                           \"client=%.*s%s, service=%.*s%s, addr=%s\"),\n                         (int)tlen1, prime_arg1, tdots1,\n                         (int)tlen2, prime_arg2, tdots2,\n                         (int)clen, (char *)client_name.value, cdots,\n                         (int)slen, (char *)service_name.value, sdots,\n                         client_addr(rqstp->rq_xprt));\n    } else {\n        ret.code = kadm5_rename_principal((void *)handle, arg->src,\n                                          arg->dest);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        /* okay to cast lengths to int because trunc_name limits max value */\n        krb5_klog_syslog(LOG_NOTICE,\n                         _(\"Request: kadm5_rename_principal, \"\n                           \"%.*s%s to %.*s%s, %s, \"\n                           \"client=%.*s%s, service=%.*s%s, addr=%s\"),\n                         (int)tlen1, prime_arg1, tdots1,\n                         (int)tlen2, prime_arg2, tdots2,\n                         errmsg ? errmsg : _(\"success\"),\n                         (int)clen, (char *)client_name.value, cdots,\n                         (int)slen, (char *)service_name.value, sdots,\n                         client_addr(rqstp->rq_xprt));\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n\n    }\nexit_func:\n    free(prime_arg1);\n    free(prime_arg2);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    free_server_handle(handle);\n    return &ret;\n}\n\ngprinc_ret *\nget_principal_2_svc(gprinc_arg *arg, struct svc_req *rqstp)\n{\n    static gprinc_ret               ret;\n    char                            *prime_arg, *funcname;\n    gss_buffer_desc                 client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_gprinc_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    funcname = \"kadm5_get_principal\";\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (! cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ) &&\n        (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                        rqst2name(rqstp),\n                                                        ACL_INQUIRE,\n                                                        arg->princ,\n                                                        NULL))) {\n        ret.code = KADM5_AUTH_GET;\n        log_unauth(funcname, prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_get_principal(handle, arg->princ, &ret.rec,\n                                       arg->mask);\n\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(funcname, prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\nexit_func:\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    free_server_handle(handle);\n    return &ret;\n}\n\ngprincs_ret *\nget_princs_2_svc(gprincs_arg *arg, struct svc_req *rqstp)\n{\n    static gprincs_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_gprincs_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    prime_arg = arg->exp;\n    if (prime_arg == NULL)\n        prime_arg = \"*\";\n\n    if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                       rqst2name(rqstp),\n                                                       ACL_LIST,\n                                                       NULL,\n                                                       NULL)) {\n        ret.code = KADM5_AUTH_LIST;\n        log_unauth(\"kadm5_get_principals\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code  = kadm5_get_principals((void *)handle,\n                                         arg->exp, &ret.princs,\n                                         &ret.count);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_get_principals\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n\n    }\nexit_func:\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    free_server_handle(handle);\n    return &ret;\n}\n\ngeneric_ret *\nchpass_principal_2_svc(chpass_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ)) {\n        ret.code = chpass_principal_wrapper_3((void *)handle, arg->princ,\n                                              FALSE, 0, NULL, arg->pass);\n    } else if (!(CHANGEPW_SERVICE(rqstp)) &&\n               kadm5int_acl_check(handle->context, rqst2name(rqstp),\n                                  ACL_CHANGEPW, arg->princ, NULL)) {\n        ret.code = kadm5_chpass_principal((void *)handle, arg->princ,\n                                          arg->pass);\n    } else {\n        log_unauth(\"kadm5_chpass_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_CHANGEPW;\n    }\n\n    if (ret.code != KADM5_AUTH_CHANGEPW) {\n        if (ret.code != 0)\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_chpass_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n\n    free(prime_arg);\nexit_func:\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    free_server_handle(handle);\n    return &ret;\n}\n\ngeneric_ret *\nchpass_principal3_2_svc(chpass3_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ)) {\n        ret.code = chpass_principal_wrapper_3((void *)handle, arg->princ,\n                                              arg->keepold,\n                                              arg->n_ks_tuple,\n                                              arg->ks_tuple,\n                                              arg->pass);\n    } else if (!(CHANGEPW_SERVICE(rqstp)) &&\n               kadm5int_acl_check(handle->context, rqst2name(rqstp),\n                                  ACL_CHANGEPW, arg->princ, NULL)) {\n        ret.code = kadm5_chpass_principal_3((void *)handle, arg->princ,\n                                            arg->keepold,\n                                            arg->n_ks_tuple,\n                                            arg->ks_tuple,\n                                            arg->pass);\n    } else {\n        log_unauth(\"kadm5_chpass_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_CHANGEPW;\n    }\n\n    if(ret.code != KADM5_AUTH_CHANGEPW) {\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_chpass_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n\n    free(prime_arg);\nexit_func:\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    free_server_handle(handle);\n    return &ret;\n}\n\ngeneric_ret *\nsetv4key_principal_2_svc(setv4key_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (!(CHANGEPW_SERVICE(rqstp)) &&\n        kadm5int_acl_check(handle->context, rqst2name(rqstp),\n                           ACL_SETKEY, arg->princ, NULL)) {\n        ret.code = kadm5_setv4key_principal((void *)handle, arg->princ,\n                                            arg->keyblock);\n    } else {\n        log_unauth(\"kadm5_setv4key_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_SETKEY;\n    }\n\n    if(ret.code != KADM5_AUTH_SETKEY) {\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_setv4key_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n\n    free(prime_arg);\nexit_func:\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    free_server_handle(handle);\n    return &ret;\n}\n\ngeneric_ret *\nsetkey_principal_2_svc(setkey_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (!(CHANGEPW_SERVICE(rqstp)) &&\n        kadm5int_acl_check(handle->context, rqst2name(rqstp),\n                           ACL_SETKEY, arg->princ, NULL)) {\n        ret.code = kadm5_setkey_principal((void *)handle, arg->princ,\n                                          arg->keyblocks, arg->n_keys);\n    } else {\n        log_unauth(\"kadm5_setkey_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_SETKEY;\n    }\n\n    if(ret.code != KADM5_AUTH_SETKEY) {\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_setkey_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n\n    free(prime_arg);\nexit_func:\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    free_server_handle(handle);\n    return &ret;\n}\n\ngeneric_ret *\nsetkey_principal3_2_svc(setkey3_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (!(CHANGEPW_SERVICE(rqstp)) &&\n        kadm5int_acl_check(handle->context, rqst2name(rqstp),\n                           ACL_SETKEY, arg->princ, NULL)) {\n        ret.code = kadm5_setkey_principal_3((void *)handle, arg->princ,\n                                            arg->keepold,\n                                            arg->n_ks_tuple,\n                                            arg->ks_tuple,\n                                            arg->keyblocks, arg->n_keys);\n    } else {\n        log_unauth(\"kadm5_setkey_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_SETKEY;\n    }\n\n    if(ret.code != KADM5_AUTH_SETKEY) {\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_setkey_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n\n    free(prime_arg);\nexit_func:\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    free_server_handle(handle);\n    return &ret;\n}\n\nchrand_ret *\nchrand_principal_2_svc(chrand_arg *arg, struct svc_req *rqstp)\n{\n    static chrand_ret           ret;\n    krb5_keyblock               *k;\n    int                         nkeys;\n    char                        *prime_arg, *funcname;\n    gss_buffer_desc             client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc             service_name = GSS_C_EMPTY_BUFFER;\n    OM_uint32                   minor_stat;\n    kadm5_server_handle_t       handle;\n    const char                  *errmsg = NULL;\n\n    xdr_free(xdr_chrand_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    funcname = \"kadm5_randkey_principal\";\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ)) {\n        ret.code = randkey_principal_wrapper_3((void *)handle, arg->princ,\n                                               FALSE, 0, NULL, &k, &nkeys);\n    } else if (!(CHANGEPW_SERVICE(rqstp)) &&\n               kadm5int_acl_check(handle->context, rqst2name(rqstp),\n                                  ACL_CHANGEPW, arg->princ, NULL)) {\n        ret.code = kadm5_randkey_principal((void *)handle, arg->princ,\n                                           &k, &nkeys);\n    } else {\n        log_unauth(funcname, prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_CHANGEPW;\n    }\n\n    if(ret.code == KADM5_OK) {\n        ret.keys = k;\n        ret.n_keys = nkeys;\n    }\n\n    if(ret.code != KADM5_AUTH_CHANGEPW) {\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(funcname, prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\nexit_func:\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    free_server_handle(handle);\n    return &ret;\n}\n\nchrand_ret *\nchrand_principal3_2_svc(chrand3_arg *arg, struct svc_req *rqstp)\n{\n    static chrand_ret           ret;\n    krb5_keyblock               *k;\n    int                         nkeys;\n    char                        *prime_arg, *funcname;\n    gss_buffer_desc             client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc             service_name = GSS_C_EMPTY_BUFFER;\n    OM_uint32                   minor_stat;\n    kadm5_server_handle_t       handle;\n    const char                  *errmsg = NULL;\n\n    xdr_free(xdr_chrand_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    funcname = \"kadm5_randkey_principal\";\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ)) {\n        ret.code = randkey_principal_wrapper_3((void *)handle, arg->princ,\n                                               arg->keepold,\n                                               arg->n_ks_tuple,\n                                               arg->ks_tuple,\n                                               &k, &nkeys);\n    } else if (!(CHANGEPW_SERVICE(rqstp)) &&\n               kadm5int_acl_check(handle->context, rqst2name(rqstp),\n                                  ACL_CHANGEPW, arg->princ, NULL)) {\n        ret.code = kadm5_randkey_principal_3((void *)handle, arg->princ,\n                                             arg->keepold,\n                                             arg->n_ks_tuple,\n                                             arg->ks_tuple,\n                                             &k, &nkeys);\n    } else {\n        log_unauth(funcname, prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_CHANGEPW;\n    }\n\n    if(ret.code == KADM5_OK) {\n        ret.keys = k;\n        ret.n_keys = nkeys;\n    }\n\n    if(ret.code != KADM5_AUTH_CHANGEPW) {\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(funcname, prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\nexit_func:\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    free_server_handle(handle);\n    return &ret;\n}\n\ngeneric_ret *\ncreate_policy_2_svc(cpol_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    prime_arg = arg->rec.policy;\n\n    if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                       rqst2name(rqstp),\n                                                       ACL_ADD, NULL, NULL)) {\n        ret.code = KADM5_AUTH_ADD;\n        log_unauth(\"kadm5_create_policy\", prime_arg,\n                   &client_name, &service_name, rqstp);\n\n    } else {\n        ret.code = kadm5_create_policy((void *)handle, &arg->rec,\n                                       arg->mask);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_create_policy\",\n                 ((prime_arg == NULL) ? \"(null)\" : prime_arg), errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\nexit_func:\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    free_server_handle(handle);\n    return &ret;\n}\n\ngeneric_ret *\ndelete_policy_2_svc(dpol_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    prime_arg = arg->name;\n\n    if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                       rqst2name(rqstp),\n                                                       ACL_DELETE, NULL, NULL)) {\n        log_unauth(\"kadm5_delete_policy\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_DELETE;\n    } else {\n        ret.code = kadm5_delete_policy((void *)handle, arg->name);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_delete_policy\",\n                 ((prime_arg == NULL) ? \"(null)\" : prime_arg), errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\nexit_func:\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    free_server_handle(handle);\n    return &ret;\n}\n\ngeneric_ret *\nmodify_policy_2_svc(mpol_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    prime_arg = arg->rec.policy;\n\n    if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                       rqst2name(rqstp),\n                                                       ACL_MODIFY, NULL, NULL)) {\n        log_unauth(\"kadm5_modify_policy\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_MODIFY;\n    } else {\n        ret.code = kadm5_modify_policy((void *)handle, &arg->rec,\n                                       arg->mask);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_modify_policy\",\n                 ((prime_arg == NULL) ? \"(null)\" : prime_arg), errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\nexit_func:\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    free_server_handle(handle);\n    return &ret;\n}\n\ngpol_ret *\nget_policy_2_svc(gpol_arg *arg, struct svc_req *rqstp)\n{\n    static gpol_ret             ret;\n    kadm5_ret_t         ret2;\n    char                        *prime_arg, *funcname;\n    gss_buffer_desc             client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc             service_name = GSS_C_EMPTY_BUFFER;\n    OM_uint32                   minor_stat;\n    kadm5_principal_ent_rec     caller_ent;\n    kadm5_server_handle_t       handle;\n    const char                  *errmsg = NULL;\n\n    xdr_free(xdr_gpol_ret,  &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    funcname = \"kadm5_get_policy\";\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    prime_arg = arg->name;\n\n    ret.code = KADM5_AUTH_GET;\n    if (!CHANGEPW_SERVICE(rqstp) && kadm5int_acl_check(handle->context,\n                                                       rqst2name(rqstp),\n                                                       ACL_INQUIRE, NULL, NULL))\n        ret.code = KADM5_OK;\n    else {\n        ret.code = kadm5_get_principal(handle->lhandle,\n                                       handle->current_caller,\n                                       &caller_ent,\n                                       KADM5_PRINCIPAL_NORMAL_MASK);\n        if (ret.code == KADM5_OK) {\n            if (caller_ent.aux_attributes & KADM5_POLICY &&\n                strcmp(caller_ent.policy, arg->name) == 0) {\n                ret.code = KADM5_OK;\n            } else ret.code = KADM5_AUTH_GET;\n            ret2 = kadm5_free_principal_ent(handle->lhandle,\n                                            &caller_ent);\n            ret.code = ret.code ? ret.code : ret2;\n        }\n    }\n\n    if (ret.code == KADM5_OK) {\n        ret.code = kadm5_get_policy(handle, arg->name, &ret.rec);\n\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(funcname,\n                 ((prime_arg == NULL) ? \"(null)\" : prime_arg), errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n\n    } else {\n        log_unauth(funcname, prime_arg,\n                   &client_name, &service_name, rqstp);\n    }\nexit_func:\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    free_server_handle(handle);\n    return &ret;\n\n}\n\ngpols_ret *\nget_pols_2_svc(gpols_arg *arg, struct svc_req *rqstp)\n{\n    static gpols_ret                ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_gpols_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    prime_arg = arg->exp;\n    if (prime_arg == NULL)\n        prime_arg = \"*\";\n\n    if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                       rqst2name(rqstp),\n                                                       ACL_LIST, NULL, NULL)) {\n        ret.code = KADM5_AUTH_LIST;\n        log_unauth(\"kadm5_get_policies\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code  = kadm5_get_policies((void *)handle,\n                                       arg->exp, &ret.pols,\n                                       &ret.count);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_get_policies\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\nexit_func:\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    free_server_handle(handle);\n    return &ret;\n}\n\ngetprivs_ret * get_privs_2_svc(krb5_ui_4 *arg, struct svc_req *rqstp)\n{\n    static getprivs_ret            ret;\n    gss_buffer_desc                client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc                service_name = GSS_C_EMPTY_BUFFER;\n    OM_uint32                      minor_stat;\n    kadm5_server_handle_t          handle;\n    const char                     *errmsg = NULL;\n\n    xdr_free(xdr_getprivs_ret, &ret);\n\n    if ((ret.code = new_server_handle(*arg, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n\n    ret.code = kadm5_get_privs((void *)handle, &ret.privs);\n    if( ret.code != 0 )\n        errmsg = krb5_get_error_message(handle->context, ret.code);\n\n    log_done(\"kadm5_get_privs\", client_name.value, errmsg,\n             &client_name, &service_name, rqstp);\n\n    if (errmsg != NULL)\n        krb5_free_error_message(handle->context, errmsg);\n\nexit_func:\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    free_server_handle(handle);\n    return &ret;\n}\n\ngeneric_ret *\npurgekeys_2_svc(purgekeys_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret          ret;\n    char                        *prime_arg, *funcname;\n    gss_buffer_desc             client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc             service_name = GSS_C_EMPTY_BUFFER;\n    OM_uint32                   minor_stat;\n    kadm5_server_handle_t       handle;\n\n    const char                  *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    funcname = \"kadm5_purgekeys\";\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (!cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ) &&\n        (CHANGEPW_SERVICE(rqstp)\n         || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_MODIFY,\n                                arg->princ, NULL))) {\n        ret.code = KADM5_AUTH_MODIFY;\n        log_unauth(funcname, prime_arg, &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_purgekeys((void *)handle, arg->princ,\n                                   arg->keepkvno);\n        if (ret.code != 0)\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(funcname, prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\nexit_func:\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    free_server_handle(handle);\n    return &ret;\n}\n\ngstrings_ret *\nget_strings_2_svc(gstrings_arg *arg, struct svc_req *rqstp)\n{\n    static gstrings_ret             ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_gstrings_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (! cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ) &&\n        (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                        rqst2name(rqstp),\n                                                        ACL_INQUIRE,\n                                                        arg->princ,\n                                                        NULL))) {\n        ret.code = KADM5_AUTH_GET;\n        log_unauth(\"kadm5_get_strings\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_get_strings((void *)handle, arg->princ, &ret.strings,\n                                     &ret.count);\n        if (ret.code != 0)\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_get_strings\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\nexit_func:\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    free_server_handle(handle);\n    return &ret;\n}\n\ngeneric_ret *\nset_string_2_svc(sstring_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (CHANGEPW_SERVICE(rqstp)\n        || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_MODIFY,\n                               arg->princ, NULL)) {\n        ret.code = KADM5_AUTH_MODIFY;\n        log_unauth(\"kadm5_mod_strings\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_set_string((void *)handle, arg->princ, arg->key,\n                                    arg->value);\n        if (ret.code != 0)\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_mod_strings\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\nexit_func:\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    free_server_handle(handle);\n    return &ret;\n}\n\ngeneric_ret *init_2_svc(krb5_ui_4 *arg, struct svc_req *rqstp)\n{\n    static generic_ret         ret;\n    gss_buffer_desc            client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc            service_name = GSS_C_EMPTY_BUFFER;\n    kadm5_server_handle_t      handle;\n    OM_uint32                  minor_stat;\n    const char                 *errmsg = NULL;\n    size_t clen, slen;\n    char *cdots, *sdots;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(*arg, rqstp, &handle)))\n        goto exit_func;\n    if (! (ret.code = check_handle((void *)handle))) {\n        ret.api_version = handle->api_version;\n    }\n\n    free_server_handle(handle);\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n\n    if (ret.code != 0)\n        errmsg = krb5_get_error_message(NULL, ret.code);\n\n    clen = client_name.length;\n    trunc_name(&clen, &cdots);\n    slen = service_name.length;\n    trunc_name(&slen, &sdots);\n    /* okay to cast lengths to int because trunc_name limits max value */\n    krb5_klog_syslog(LOG_NOTICE, _(\"Request: kadm5_init, %.*s%s, %s, \"\n                                   \"client=%.*s%s, service=%.*s%s, addr=%s, \"\n                                   \"vers=%d, flavor=%d\"),\n                     (int)clen, (char *)client_name.value, cdots,\n                     errmsg ? errmsg : _(\"success\"),\n                     (int)clen, (char *)client_name.value, cdots,\n                     (int)slen, (char *)service_name.value, sdots,\n                     client_addr(rqstp->rq_xprt),\n                     ret.api_version & ~(KADM5_API_VERSION_MASK),\n                     rqstp->rq_cred.oa_flavor);\n    if (errmsg != NULL)\n        krb5_free_error_message(NULL, errmsg);\n\nexit_func:\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    return(&ret);\n}\n\ngss_name_t\nrqst2name(struct svc_req *rqstp)\n{\n\n    if (rqstp->rq_cred.oa_flavor == RPCSEC_GSS)\n        return rqstp->rq_clntname;\n    else\n        return rqstp->rq_clntcred;\n}\n"], "filenames": ["src/kadmin/server/server_stubs.c"], "buggy_code_start_loc": [337], "buggy_code_end_loc": [1804], "fixing_code_start_loc": [337], "fixing_code_end_loc": [1807], "type": "CWE-772", "message": "Multiple memory leaks in kadmin/server/server_stubs.c in kadmind in MIT Kerberos 5 (aka krb5) before 1.13.4 and 1.14.x before 1.14.1 allow remote authenticated users to cause a denial of service (memory consumption) via a request specifying a NULL principal name.", "other": {"cve": {"id": "CVE-2015-8631", "sourceIdentifier": "cve@mitre.org", "published": "2016-02-13T02:59:02.023", "lastModified": "2021-02-02T19:15:22.720", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Multiple memory leaks in kadmin/server/server_stubs.c in kadmind in MIT Kerberos 5 (aka krb5) before 1.13.4 and 1.14.x before 1.14.1 allow remote authenticated users to cause a denial of service (memory consumption) via a request specifying a NULL principal name."}, {"lang": "es", "value": "M\u00faltiples p\u00e9rdidas de memoria en kadmin/server/server_stubs.c en kadmind en MIT Kerberos 5 (tambi\u00e9n conocido como krb5) en versiones anteriores a 1.13.4 y 1.14.x en versiones anteriores a 1.14.1 permiten a usuarios remotos autenticados causar una denegaci\u00f3n de servicio (consumo de memoria) a trav\u00e9s de una solicitud especificando un nombre principal NULL."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-772"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.13.4", "matchCriteriaId": "1169B718-3132-4984-9746-320524D141E5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.14", "versionEndExcluding": "1.14.1", "matchCriteriaId": "FFB93D70-A16F-4716-A5EE-7854D0974AC9"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:42.1:*:*:*:*:*:*:*", "matchCriteriaId": "4863BE36-D16A-4D75-90D9-FD76DB5B48B7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:13.2:*:*:*:*:*:*:*", "matchCriteriaId": "03117DF1-3BEC-4B8D-AD63-DBBDB2126081"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "16F59A04-14CF-49E2-9973-645477EA09DA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "EE249E1B-A1FD-4E08-AA71-A0E1F10FFE97"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "33C068A4-3780-4EAB-A937-6082DF847564"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:6.7:*:*:*:*:*:*:*", "matchCriteriaId": "967EC28A-607F-48F4-AD64-5E3041C768F0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:7.2:*:*:*:*:*:*:*", "matchCriteriaId": "AE1D81A1-CD24-4B17-8AFD-DC95E90AD7D0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:7.3:*:*:*:*:*:*:*", "matchCriteriaId": "807C024A-F8E8-4B48-A349-4C68CD252CA1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:7.4:*:*:*:*:*:*:*", "matchCriteriaId": "F96E3779-F56A-45FF-BB3D-4980527D721E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:7.5:*:*:*:*:*:*:*", "matchCriteriaId": "0CF73560-2F5B-4723-A8A1-9AADBB3ADA00"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "5BF3C7A5-9117-42C7-BEA1-4AA378A582EF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:7.7:*:*:*:*:*:*:*", "matchCriteriaId": "83737173-E12E-4641-BC49-0BD84A6B29D0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "9BBCD86A-E6C7-4444-9D74-F861084090F0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "51EF4996-72F4-4FA4-814F-F5991E7A8318"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.2:*:*:*:*:*:*:*", "matchCriteriaId": "1C8D871B-AEA1-4407-AEE3-47EC782250FF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.3:*:*:*:*:*:*:*", "matchCriteriaId": "98381E61-F082-4302-B51F-5648884F998B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.4:*:*:*:*:*:*:*", "matchCriteriaId": "D99A687E-EAE6-417E-A88E-D0082BC194CD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "B353CE99-D57C-465B-AAB0-73EF581127D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.7:*:*:*:*:*:*:*", "matchCriteriaId": "7431ABC1-9252-419E-8CC1-311B41360078"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:7.2:*:*:*:*:*:*:*", "matchCriteriaId": "6755B6AD-0422-467B-8115-34A60B1D1A40"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:7.3:*:*:*:*:*:*:*", "matchCriteriaId": "24C0F4E1-C52C-41E0-9F14-F83ADD5CC7ED"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "B76AA310-FEC7-497F-AF04-C3EC1E76C4CC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:7.7:*:*:*:*:*:*:*", "matchCriteriaId": "17F256A9-D3B9-4C72-B013-4EFD878BFEA8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "E5ED5807-55B7-47C5-97A6-03233F4FBC3A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "825ECE2D-E232-46E0-A047-074B34DB1E97"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:oracle:linux:6:-:*:*:*:*:*:*", "matchCriteriaId": "D7B037A8-72A6-4DFF-94B2-D688A5F6F876"}, {"vulnerable": true, "criteria": "cpe:2.3:o:oracle:linux:7:-:*:*:*:*:*:*", "matchCriteriaId": "44B8FEDF-6CB0-46E9-9AD7-4445B001C158"}]}]}], "references": [{"url": "http://krbdev.mit.edu/rt/Ticket/Display.html?id=8343", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-updates/2016-02/msg00059.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-updates/2016-02/msg00110.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2016-0493.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2016-0532.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.debian.org/security/2016/dsa-3466", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.oracle.com/technetwork/topics/security/linuxbulletinapr2016-2952096.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.securitytracker.com/id/1034916", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/krb5/krb5/commit/83ed75feba32e46f736fcce0d96a0445f29b96c2", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/krb5/krb5/commit/83ed75feba32e46f736fcce0d96a0445f29b96c2"}}