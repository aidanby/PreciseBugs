{"buggy_code": ["!data/conf/nginx/dynmaps.conf\n!data/conf/nginx/meta_exporter.conf\n!data/conf/nginx/site.conf\n!/**/.gitkeep\n*.iml\n.idea\n.vscode/*\ndata/assets/ssl-example/*\ndata/assets/ssl/*\ndata/conf/borgmatic/\ndata/conf/clamav/whitelist.ign2\ndata/conf/dovecot/acl_anyone\ndata/conf/dovecot/dovecot-master.passwd\ndata/conf/dovecot/dovecot-master.userdb\ndata/conf/dovecot/extra.conf\ndata/conf/dovecot/global_sieve_*\ndata/conf/dovecot/last_login\ndata/conf/dovecot/lua\ndata/conf/dovecot/mail_plugins*\ndata/conf/dovecot/shared_namespace.conf\ndata/conf/dovecot/sni.conf\ndata/conf/dovecot/sogo-sso.conf\ndata/conf/dovecot/sogo_trusted_ip.conf\ndata/conf/dovecot/sql\ndata/conf/nextcloud-*.bak\ndata/conf/nginx/*.active\ndata/conf/nginx/*.bak\ndata/conf/nginx/*.conf\ndata/conf/nginx/*.custom\ndata/conf/phpfpm/sogo-sso/sogo-sso.pass\ndata/conf/portainer/\ndata/conf/postfix/allow_mailcow_local.regexp\ndata/conf/postfix/custom_postscreen_whitelist.cidr\ndata/conf/postfix/custom_transport.pcre\ndata/conf/postfix/extra.cf\ndata/conf/postfix/sni.map\ndata/conf/postfix/sni.map.db\ndata/conf/postfix/sql\ndata/conf/postfix/dns_blocklists.cf\ndata/conf/postfix/dnsbl_reply.map\ndata/conf/rspamd/custom/*\ndata/conf/rspamd/local.d/*\ndata/conf/rspamd/override.d/*\ndata/conf/sogo/custom-theme.js\ndata/conf/sogo/plist_ldap\ndata/conf/sogo/sieve.creds\ndata/conf/sogo/sogo-full.svg\ndata/gitea/\ndata/gogs/\ndata/hooks/dovecot/*\ndata/hooks/phpfpm/*\ndata/hooks/postfix/*\ndata/hooks/rspamd/*\ndata/hooks/sogo/*\ndata/hooks/unbound/*\ndata/web/templates/cache/*\n!data/web/templates/cache/.gitkeep\ndata/web/.well-known/acme-challenge\ndata/web/css/build/0081-custom-mailcow.css\ndata/web/inc/vars.local.inc.php\ndata/web/inc/app_info.inc.php\ndata/web/nextcloud*/\ndata/web/rc*/\ndocker-compose.override.yml\nmailcow.conf\nmailcow.conf_backup\nrebuild-images.sh\nrefresh_images.sh\nupdate_diffs/\ncreate_cold_standby.sh\n", "#!/bin/bash\nset -e\n\n# Wait for MySQL to warm-up\nwhile ! mysqladmin status --socket=/var/run/mysqld/mysqld.sock -u${DBUSER} -p${DBPASS} --silent; do\n  echo \"Waiting for database to come up...\"\n  sleep 2\ndone\n\nuntil dig +short mailcow.email > /dev/null; do\n  echo \"Waiting for DNS...\"\n  sleep 1\ndone\n\n# Do not attempt to write to slave\nif [[ ! -z ${REDIS_SLAVEOF_IP} ]]; then\n  REDIS_CMDLINE=\"redis-cli -h ${REDIS_SLAVEOF_IP} -p ${REDIS_SLAVEOF_PORT}\"\nelse\n  REDIS_CMDLINE=\"redis-cli -h redis -p 6379\"\nfi\n\nuntil [[ $(${REDIS_CMDLINE} PING) == \"PONG\" ]]; do\n  echo \"Waiting for Redis...\"\n  sleep 2\ndone\n\n${REDIS_CMDLINE} SET DOVECOT_REPL_HEALTH 1 > /dev/null\n\n# Create missing directories\n[[ ! -d /etc/dovecot/sql/ ]] && mkdir -p /etc/dovecot/sql/\n[[ ! -d /etc/dovecot/lua/ ]] && mkdir -p /etc/dovecot/lua/\n[[ ! -d /var/vmail/_garbage ]] && mkdir -p /var/vmail/_garbage\n[[ ! -d /var/vmail/sieve ]] && mkdir -p /var/vmail/sieve\n[[ ! -d /etc/sogo ]] && mkdir -p /etc/sogo\n[[ ! -d /var/volatile ]] && mkdir -p /var/volatile\n\n# Set Dovecot sql config parameters, escape \" in db password\nDBPASS=$(echo ${DBPASS} | sed 's/\"/\\\\\"/g')\n\n# Create quota dict for Dovecot\nif [[ \"${MASTER}\" =~ ^([yY][eE][sS]|[yY])+$ ]]; then\n  QUOTA_TABLE=quota2\nelse\n  QUOTA_TABLE=quota2replica\nfi\ncat <<EOF > /etc/dovecot/sql/dovecot-dict-sql-quota.conf\n# Autogenerated by mailcow\nconnect = \"host=/var/run/mysqld/mysqld.sock dbname=${DBNAME} user=${DBUSER} password=${DBPASS}\"\nmap {\n  pattern = priv/quota/storage\n  table = ${QUOTA_TABLE}\n  username_field = username\n  value_field = bytes\n}\nmap {\n  pattern = priv/quota/messages\n  table = ${QUOTA_TABLE}\n  username_field = username\n  value_field = messages\n}\nEOF\n\n# Create dict used for sieve pre and postfilters\ncat <<EOF > /etc/dovecot/sql/dovecot-dict-sql-sieve_before.conf\n# Autogenerated by mailcow\nconnect = \"host=/var/run/mysqld/mysqld.sock dbname=${DBNAME} user=${DBUSER} password=${DBPASS}\"\nmap {\n  pattern = priv/sieve/name/\\$script_name\n  table = sieve_before\n  username_field = username\n  value_field = id\n  fields {\n    script_name = \\$script_name\n  }\n}\nmap {\n  pattern = priv/sieve/data/\\$id\n  table = sieve_before\n  username_field = username\n  value_field = script_data\n  fields {\n    id = \\$id\n  }\n}\nEOF\n\ncat <<EOF > /etc/dovecot/sql/dovecot-dict-sql-sieve_after.conf\n# Autogenerated by mailcow\nconnect = \"host=/var/run/mysqld/mysqld.sock dbname=${DBNAME} user=${DBUSER} password=${DBPASS}\"\nmap {\n  pattern = priv/sieve/name/\\$script_name\n  table = sieve_after\n  username_field = username\n  value_field = id\n  fields {\n    script_name = \\$script_name\n  }\n}\nmap {\n  pattern = priv/sieve/data/\\$id\n  table = sieve_after\n  username_field = username\n  value_field = script_data\n  fields {\n    id = \\$id\n  }\n}\nEOF\n\necho -n ${ACL_ANYONE} > /etc/dovecot/acl_anyone\n\nif [[ \"${SKIP_SOLR}\" =~ ^([yY][eE][sS]|[yY])+$ ]]; then\necho -n 'quota acl zlib mail_crypt mail_crypt_acl mail_log notify listescape replication' > /etc/dovecot/mail_plugins\necho -n 'quota imap_quota imap_acl acl zlib imap_zlib imap_sieve mail_crypt mail_crypt_acl notify listescape replication mail_log' > /etc/dovecot/mail_plugins_imap\necho -n 'quota sieve acl zlib mail_crypt mail_crypt_acl notify listescape replication' > /etc/dovecot/mail_plugins_lmtp\nelse\necho -n 'quota acl zlib mail_crypt mail_crypt_acl mail_log notify fts fts_solr listescape replication' > /etc/dovecot/mail_plugins\necho -n 'quota imap_quota imap_acl acl zlib imap_zlib imap_sieve mail_crypt mail_crypt_acl notify mail_log fts fts_solr listescape replication' > /etc/dovecot/mail_plugins_imap\necho -n 'quota sieve acl zlib mail_crypt mail_crypt_acl fts fts_solr notify listescape replication' > /etc/dovecot/mail_plugins_lmtp\nfi\nchmod 644 /etc/dovecot/mail_plugins /etc/dovecot/mail_plugins_imap /etc/dovecot/mail_plugins_lmtp /templates/quarantine.tpl\n\ncat <<EOF > /etc/dovecot/sql/dovecot-dict-sql-userdb.conf\n# Autogenerated by mailcow\ndriver = mysql\nconnect = \"host=/var/run/mysqld/mysqld.sock dbname=${DBNAME} user=${DBUSER} password=${DBPASS}\"\nuser_query = SELECT CONCAT(JSON_UNQUOTE(JSON_VALUE(attributes, '$.mailbox_format')), mailbox_path_prefix, '%d/%n/${MAILDIR_SUB}:VOLATILEDIR=/var/volatile/%u:INDEX=/var/vmail_index/%u') AS mail, '%s' AS protocol, 5000 AS uid, 5000 AS gid, concat('*:bytes=', quota) AS quota_rule FROM mailbox WHERE username = '%u' AND (active = '1' OR active = '2')\niterate_query = SELECT username FROM mailbox WHERE active = '1' OR active = '2';\nEOF\n\ncat <<EOF > /etc/dovecot/lua/passwd-verify.lua\nfunction auth_password_verify(req, pass)\n\n  if req.domain == nil then\n    return dovecot.auth.PASSDB_RESULT_USER_UNKNOWN, \"No such user\"\n  end\n\n  if cur == nil then\n    script_init()\n  end\n\n  if req.user == nil then\n    req.user = ''\n  end\n\n  respbody = {}\n\n  -- check against mailbox passwds\n  local cur,errorString = con:execute(string.format([[SELECT password FROM mailbox\n    WHERE username = '%s'\n      AND active = '1'\n      AND domain IN (SELECT domain FROM domain WHERE domain='%s' AND active='1')\n      AND IFNULL(JSON_UNQUOTE(JSON_VALUE(mailbox.attributes, '$.force_pw_update')), 0) != '1'\n      AND IFNULL(JSON_UNQUOTE(JSON_VALUE(attributes, '$.%s_access')), 1) = '1']], con:escape(req.user), con:escape(req.domain), con:escape(req.service)))\n  local row = cur:fetch ({}, \"a\")\n  while row do\n    if req.password_verify(req, row.password, pass) == 1 then\n      con:execute(string.format([[REPLACE INTO sasl_log (service, app_password, username, real_rip)\n        VALUES (\"%s\", 0, \"%s\", \"%s\")]], con:escape(req.service), con:escape(req.user), con:escape(req.real_rip)))\n      cur:close()\n      con:close()\n      return dovecot.auth.PASSDB_RESULT_OK, \"\"\n    end\n    row = cur:fetch (row, \"a\")\n  end\n\n  -- check against app passwds for imap and smtp\n  -- app passwords are only available for imap, smtp, sieve and pop3 when using sasl\n  if req.service == \"smtp\" or req.service == \"imap\" or req.service == \"sieve\" or req.service == \"pop3\" then\n    local cur,errorString = con:execute(string.format([[SELECT app_passwd.id, %s_access AS has_prot_access, app_passwd.password FROM app_passwd\n      INNER JOIN mailbox ON mailbox.username = app_passwd.mailbox\n      WHERE mailbox = '%s'\n        AND app_passwd.active = '1'\n        AND mailbox.active = '1'\n        AND app_passwd.domain IN (SELECT domain FROM domain WHERE domain='%s' AND active='1')]], con:escape(req.service), con:escape(req.user), con:escape(req.domain)))\n    local row = cur:fetch ({}, \"a\")\n    while row do\n      if req.password_verify(req, row.password, pass) == 1 then\n        -- if password is valid and protocol access is 1 OR real_rip matches SOGo, proceed\n        if tostring(req.real_rip) == \"__IPV4_SOGO__\" then\n          cur:close()\n          con:close()\n          return dovecot.auth.PASSDB_RESULT_OK, \"\"\n        elseif row.has_prot_access == \"1\" then\n          con:execute(string.format([[REPLACE INTO sasl_log (service, app_password, username, real_rip)\n            VALUES (\"%s\", %d, \"%s\", \"%s\")]], con:escape(req.service), row.id, con:escape(req.user), con:escape(req.real_rip)))\n          cur:close()\n          con:close()\n          return dovecot.auth.PASSDB_RESULT_OK, \"\"\n        end\n      end\n      row = cur:fetch (row, \"a\")\n    end\n  end\n\n  cur:close()\n  con:close()\n\n  return dovecot.auth.PASSDB_RESULT_PASSWORD_MISMATCH, \"Failed to authenticate\"\n\n  -- PoC\n  -- local reqbody = string.format([[{\n  --   \"success\":0,\n  --   \"service\":\"%s\",\n  --   \"app_password\":false,\n  --   \"username\":\"%s\",\n  --   \"real_rip\":\"%s\"\n  -- }]], con:escape(req.service), con:escape(req.user), con:escape(req.real_rip))\n  -- http.request {\n  --   method = \"POST\",\n  --   url = \"http://nginx:8081/sasl_log.php\",\n  --   source = ltn12.source.string(reqbody),\n  --   headers = {\n  --     [\"content-type\"] = \"application/json\",\n  --     [\"content-length\"] = tostring(#reqbody)\n  --   },\n  --   sink = ltn12.sink.table(respbody)\n  -- }\n\nend\n\nfunction auth_passdb_lookup(req)\n   return dovecot.auth.PASSDB_RESULT_USER_UNKNOWN, \"\"\nend\n\nfunction script_init()\n  mysql = require \"luasql.mysql\"\n  http = require \"socket.http\"\n  http.TIMEOUT = 5\n  ltn12 = require \"ltn12\"\n  env  = mysql.mysql()\n  con = env:connect(\"__DBNAME__\",\"__DBUSER__\",\"__DBPASS__\",\"localhost\")\n  return 0\nend\n\nfunction script_deinit()\n  con:close()\n  env:close()\nend\nEOF\n\n# Replace patterns in app-passdb.lua\nsed -i \"s/__DBUSER__/${DBUSER}/g\" /etc/dovecot/lua/passwd-verify.lua\nsed -i \"s/__DBPASS__/${DBPASS}/g\" /etc/dovecot/lua/passwd-verify.lua\nsed -i \"s/__DBNAME__/${DBNAME}/g\" /etc/dovecot/lua/passwd-verify.lua\nsed -i \"s/__IPV4_SOGO__/${IPV4_NETWORK}.248/g\" /etc/dovecot/lua/passwd-verify.lua\n\n\n# Migrate old sieve_after file\n[[ -f /etc/dovecot/sieve_after ]] && mv /etc/dovecot/sieve_after /etc/dovecot/global_sieve_after\n# Create global sieve scripts\ncat /etc/dovecot/global_sieve_after > /var/vmail/sieve/global_sieve_after.sieve\ncat /etc/dovecot/global_sieve_before > /var/vmail/sieve/global_sieve_before.sieve\n\n# Check permissions of vmail/index/garbage directories.\n# Do not do this every start-up, it may take a very long time. So we use a stat check here.\nif [[ $(stat -c %U /var/vmail/) != \"vmail\" ]] ; then chown -R vmail:vmail /var/vmail ; fi\nif [[ $(stat -c %U /var/vmail/_garbage) != \"vmail\" ]] ; then chown -R vmail:vmail /var/vmail/_garbage ; fi\nif [[ $(stat -c %U /var/vmail_index) != \"vmail\" ]] ; then chown -R vmail:vmail /var/vmail_index ; fi\n\n# Cleanup random user maildirs\nrm -rf /var/vmail/mailcow.local/*\n# Cleanup PIDs\n[[ -f /tmp/quarantine_notify.pid ]] && rm /tmp/quarantine_notify.pid\n\n# create sni configuration\necho \"\" > /etc/dovecot/sni.conf\nfor cert_dir in /etc/ssl/mail/*/ ; do\n  if [[ ! -f ${cert_dir}domains ]] || [[ ! -f ${cert_dir}cert.pem ]] || [[ ! -f ${cert_dir}key.pem ]]; then\n    continue\n  fi\n  domains=($(cat ${cert_dir}domains))\n  for domain in ${domains[@]}; do\n    echo 'local_name '${domain}' {' >> /etc/dovecot/sni.conf;\n    echo '  ssl_cert = <'${cert_dir}'cert.pem' >> /etc/dovecot/sni.conf;\n    echo '  ssl_key = <'${cert_dir}'key.pem' >> /etc/dovecot/sni.conf;\n    echo '}' >> /etc/dovecot/sni.conf;\n  done\ndone\n\n# Create random master for SOGo sieve features\nRAND_USER=$(cat /dev/urandom | tr -dc 'a-z0-9' | fold -w 16 | head -n 1)\nRAND_PASS=$(cat /dev/urandom | tr -dc 'a-z0-9' | fold -w 24 | head -n 1)\n\nif [[ ! -z ${DOVECOT_MASTER_USER} ]] && [[ ! -z ${DOVECOT_MASTER_PASS} ]]; then\n  RAND_USER=${DOVECOT_MASTER_USER}\n  RAND_PASS=${DOVECOT_MASTER_PASS}\nfi\necho ${RAND_USER}@mailcow.local:{SHA1}$(echo -n ${RAND_PASS} | sha1sum | awk '{print $1}'):::::: > /etc/dovecot/dovecot-master.passwd\necho ${RAND_USER}@mailcow.local::5000:5000:::: > /etc/dovecot/dovecot-master.userdb\necho ${RAND_USER}@mailcow.local:${RAND_PASS} > /etc/sogo/sieve.creds\n\nif [[ -z ${MAILDIR_SUB} ]]; then\n  MAILDIR_SUB_SHARED=\nelse\n  MAILDIR_SUB_SHARED=/${MAILDIR_SUB}\nfi\ncat <<EOF > /etc/dovecot/shared_namespace.conf\n# Autogenerated by mailcow\nnamespace {\n    type = shared\n    separator = /\n    prefix = Shared/%%u/\n    location = maildir:%%h${MAILDIR_SUB_SHARED}:INDEX=~${MAILDIR_SUB_SHARED}/Shared/%%u\n    subscriptions = no\n    list = children\n}\nEOF\n\n\ncat <<EOF > /etc/dovecot/sogo_trusted_ip.conf\n# Autogenerated by mailcow\nremote ${IPV4_NETWORK}.248 {\n  disable_plaintext_auth = no\n}\nEOF\n\n# Create random master Password for SOGo SSO\nRAND_PASS=$(cat /dev/urandom | tr -dc 'a-z0-9' | fold -w 32 | head -n 1)\necho -n ${RAND_PASS} > /etc/phpfpm/sogo-sso.pass\ncat <<EOF > /etc/dovecot/sogo-sso.conf\n# Autogenerated by mailcow\npassdb {\n  driver = static\n  args = allow_real_nets=${IPV4_NETWORK}.248/32 password={plain}${RAND_PASS}\n}\nEOF\n\nif [[ \"${MASTER}\" =~ ^([nN][oO]|[nN])+$ ]]; then\n  # Toggling MASTER will result in a rebuild of containers, so the quota script will be recreated\n  cat <<'EOF' > /usr/local/bin/quota_notify.py\n#!/usr/bin/python3\nimport sys\nsys.exit()\nEOF\nfi\n\n# 401 is user dovecot\nif [[ ! -s /mail_crypt/ecprivkey.pem || ! -s /mail_crypt/ecpubkey.pem ]]; then\n\topenssl ecparam -name prime256v1 -genkey | openssl pkey -out /mail_crypt/ecprivkey.pem\n\topenssl pkey -in /mail_crypt/ecprivkey.pem -pubout -out /mail_crypt/ecpubkey.pem\n\tchown 401 /mail_crypt/ecprivkey.pem /mail_crypt/ecpubkey.pem\nelse\n\tchown 401 /mail_crypt/ecprivkey.pem /mail_crypt/ecpubkey.pem\nfi\n\n# Compile sieve scripts\nsievec /var/vmail/sieve/global_sieve_before.sieve\nsievec /var/vmail/sieve/global_sieve_after.sieve\nsievec /usr/lib/dovecot/sieve/report-spam.sieve\nsievec /usr/lib/dovecot/sieve/report-ham.sieve\n\nfor file in /var/vmail/*/*/sieve/*.sieve ; do\n  if [[ \"$file\" == \"/var/vmail/*/*/sieve/*.sieve\" ]]; then\n    continue\n  fi\n  sievec \"$file\" \"$(dirname \"$file\")/../.dovecot.svbin\"\n  chown vmail:vmail \"$(dirname \"$file\")/../.dovecot.svbin\"\ndone\n\n# Fix permissions\nchown root:root /etc/dovecot/sql/*.conf\nchown root:dovecot /etc/dovecot/sql/dovecot-dict-sql-sieve* /etc/dovecot/sql/dovecot-dict-sql-quota* /etc/dovecot/lua/passwd-verify.lua\nchmod 640 /etc/dovecot/sql/*.conf /etc/dovecot/lua/passwd-verify.lua\nchown -R vmail:vmail /var/vmail/sieve\nchown -R vmail:vmail /var/volatile\nchown -R vmail:vmail /var/vmail_index\nadduser vmail tty\nchmod g+rw /dev/console\nchown root:tty /dev/console\nchmod +x /usr/lib/dovecot/sieve/rspamd-pipe-ham \\\n  /usr/lib/dovecot/sieve/rspamd-pipe-spam \\\n  /usr/local/bin/imapsync_runner.pl \\\n  /usr/local/bin/imapsync \\\n  /usr/local/bin/trim_logs.sh \\\n  /usr/local/bin/sa-rules.sh \\\n  /usr/local/bin/clean_q_aged.sh \\\n  /usr/local/bin/maildir_gc.sh \\\n  /usr/local/sbin/stop-supervisor.sh \\\n  /usr/local/bin/quota_notify.py \\\n  /usr/local/bin/repl_health.sh\n\n# Prepare environment file for cronjobs\nprintenv | sed 's/^\\(.*\\)$/export \\1/g' > /source_env.sh\n\n# Clean old PID if any\n[[ -f /var/run/dovecot/master.pid ]] && rm /var/run/dovecot/master.pid\n\n# Clean stopped imapsync jobs\nrm -f /tmp/imapsync_busy.lock\nIMAPSYNC_TABLE=$(mysql --socket=/var/run/mysqld/mysqld.sock -u ${DBUSER} -p${DBPASS} ${DBNAME} -e \"SHOW TABLES LIKE 'imapsync'\" -Bs)\n[[ ! -z ${IMAPSYNC_TABLE} ]] && mysql --socket=/var/run/mysqld/mysqld.sock -u ${DBUSER} -p${DBPASS} ${DBNAME} -e \"UPDATE imapsync SET is_running='0'\"\n\n# Envsubst maildir_gc\necho \"$(envsubst < /usr/local/bin/maildir_gc.sh)\" > /usr/local/bin/maildir_gc.sh\n\n# GUID generation\nwhile [[ ${VERSIONS_OK} != 'OK' ]]; do\n  if [[ ! -z $(mysql --socket=/var/run/mysqld/mysqld.sock -u ${DBUSER} -p${DBPASS} ${DBNAME} -B -e \"SELECT 'OK' FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = \\\"${DBNAME}\\\" AND TABLE_NAME = 'versions'\") ]]; then\n    VERSIONS_OK=OK\n  else\n    echo \"Waiting for versions table to be created...\"\n    sleep 3\n  fi\ndone\nPUBKEY_MCRYPT=$(doveconf -P 2> /dev/null | grep -i mail_crypt_global_public_key | cut -d '<' -f2)\nif [ -f ${PUBKEY_MCRYPT} ]; then\n  GUID=$(cat <(echo ${MAILCOW_HOSTNAME}) /mail_crypt/ecpubkey.pem | sha256sum | cut -d ' ' -f1 | tr -cd \"[a-fA-F0-9.:/] \")\n  if [ ${#GUID} -eq 64 ]; then\n    mysql --socket=/var/run/mysqld/mysqld.sock -u ${DBUSER} -p${DBPASS} ${DBNAME} << EOF\nREPLACE INTO versions (application, version) VALUES (\"GUID\", \"${GUID}\");\nEOF\n  else\n    mysql --socket=/var/run/mysqld/mysqld.sock -u ${DBUSER} -p${DBPASS} ${DBNAME} << EOF\nREPLACE INTO versions (application, version) VALUES (\"GUID\", \"INVALID\");\nEOF\n  fi\nfi\n\n# Collect SA rules once now\n/usr/local/bin/sa-rules.sh\n\n# Run hooks\nfor file in /hooks/*; do\n  if [ -x \"${file}\" ]; then\n    echo \"Running hook ${file}\"\n    \"${file}\"\n  fi\ndone\n\n# For some strange, unknown and stupid reason, Dovecot may run into a race condition, when this file is not touched before it is read by dovecot/auth\n# May be related to something inside Docker, I seriously don't know\ntouch /etc/dovecot/lua/passwd-verify.lua\n\nif [[ ! -z ${REDIS_SLAVEOF_IP} ]]; then\n  cp /etc/syslog-ng/syslog-ng-redis_slave.conf /etc/syslog-ng/syslog-ng.conf\nfi\n\nexec \"$@\"\n", "#!/usr/bin/env python3\r\n\r\nimport re\r\nimport os\r\nimport sys\r\nimport time\r\nimport atexit\r\nimport signal\r\nimport ipaddress\r\nfrom collections import Counter\r\nfrom random import randint\r\nfrom threading import Thread\r\nfrom threading import Lock\r\nimport redis\r\nimport json\r\nimport dns.resolver\r\nimport dns.exception\r\nimport uuid\r\nfrom modules.Logger import Logger\r\nfrom modules.IPTables import IPTables\r\nfrom modules.NFTables import NFTables\r\n\r\n\r\n# connect to redis\r\nwhile True:\r\n  try:\r\n    redis_slaveof_ip = os.getenv('REDIS_SLAVEOF_IP', '')\r\n    redis_slaveof_port = os.getenv('REDIS_SLAVEOF_PORT', '')\r\n    if \"\".__eq__(redis_slaveof_ip):\r\n      r = redis.StrictRedis(host=os.getenv('IPV4_NETWORK', '172.22.1') + '.249', decode_responses=True, port=6379, db=0)\r\n    else:\r\n      r = redis.StrictRedis(host=redis_slaveof_ip, decode_responses=True, port=redis_slaveof_port, db=0)\r\n    r.ping()\r\n  except Exception as ex:\r\n    print('%s - trying again in 3 seconds'  % (ex))\r\n    time.sleep(3)\r\n  else:\r\n    break\r\npubsub = r.pubsub()\r\n\r\n# rename fail2ban to netfilter\r\nif r.exists('F2B_LOG'):\r\n  r.rename('F2B_LOG', 'NETFILTER_LOG')\r\n\r\n\r\n# globals\r\nWHITELIST = []\r\nBLACKLIST= []\r\nbans = {}\r\nquit_now = False\r\nexit_code = 0\r\nlock = Lock()\r\n\r\n\r\n# init Logger\r\nlogger = Logger(r)\r\n# init backend\r\nbackend = sys.argv[1]\r\nif backend == \"nftables\":\r\n  logger.logInfo('Using NFTables backend')\r\n  tables = NFTables(\"MAILCOW\", logger)\r\nelse:\r\n  logger.logInfo('Using IPTables backend')\r\n  tables = IPTables(\"MAILCOW\", logger)\r\n\r\n\r\ndef refreshF2boptions():\r\n  global f2boptions\r\n  global quit_now\r\n  global exit_code\r\n\r\n  f2boptions = {}\r\n\r\n  if not r.get('F2B_OPTIONS'):\r\n    f2boptions['ban_time'] = r.get('F2B_BAN_TIME')\r\n    f2boptions['max_ban_time'] = r.get('F2B_MAX_BAN_TIME')\r\n    f2boptions['ban_time_increment'] = r.get('F2B_BAN_TIME_INCREMENT')\r\n    f2boptions['max_attempts'] = r.get('F2B_MAX_ATTEMPTS')\r\n    f2boptions['retry_window'] = r.get('F2B_RETRY_WINDOW')\r\n    f2boptions['netban_ipv4'] = r.get('F2B_NETBAN_IPV4')\r\n    f2boptions['netban_ipv6'] = r.get('F2B_NETBAN_IPV6')\r\n  else:\r\n    try:\r\n      f2boptions = json.loads(r.get('F2B_OPTIONS'))\r\n    except ValueError:\r\n      logger.logCrit('Error loading F2B options: F2B_OPTIONS is not json')\r\n      quit_now = True\r\n      exit_code = 2\r\n\r\n  verifyF2boptions(f2boptions)\r\n  r.set('F2B_OPTIONS', json.dumps(f2boptions, ensure_ascii=False))\r\n\r\ndef verifyF2boptions(f2boptions):\r\n  verifyF2boption(f2boptions,'ban_time', 1800)\r\n  verifyF2boption(f2boptions,'max_ban_time', 10000)\r\n  verifyF2boption(f2boptions,'ban_time_increment', True)\r\n  verifyF2boption(f2boptions,'max_attempts', 10)\r\n  verifyF2boption(f2boptions,'retry_window', 600)\r\n  verifyF2boption(f2boptions,'netban_ipv4', 32)\r\n  verifyF2boption(f2boptions,'netban_ipv6', 128)\r\n  verifyF2boption(f2boptions,'banlist_id', str(uuid.uuid4()))\r\n  verifyF2boption(f2boptions,'manage_external', 0)\r\n\r\ndef verifyF2boption(f2boptions, f2boption, f2bdefault):\r\n  f2boptions[f2boption] = f2boptions[f2boption] if f2boption in f2boptions and f2boptions[f2boption] is not None else f2bdefault\r\n\r\ndef refreshF2bregex():\r\n  global f2bregex\r\n  global quit_now\r\n  global exit_code\r\n  if not r.get('F2B_REGEX'):\r\n    f2bregex = {}\r\n    f2bregex[1] = 'mailcow UI: Invalid password for .+ by ([0-9a-f\\.:]+)'\r\n    f2bregex[2] = 'Rspamd UI: Invalid password by ([0-9a-f\\.:]+)'\r\n    f2bregex[3] = 'warning: .*\\[([0-9a-f\\.:]+)\\]: SASL .+ authentication failed: (?!.*Connection lost to authentication server).+'\r\n    f2bregex[4] = 'warning: non-SMTP command from .*\\[([0-9a-f\\.:]+)]:.+'\r\n    f2bregex[5] = 'NOQUEUE: reject: RCPT from \\[([0-9a-f\\.:]+)].+Protocol error.+'\r\n    f2bregex[6] = '-login: Disconnected.+ \\(auth failed, .+\\): user=.*, method=.+, rip=([0-9a-f\\.:]+),'\r\n    f2bregex[7] = '-login: Aborted login.+ \\(auth failed .+\\): user=.+, rip=([0-9a-f\\.:]+), lip.+'\r\n    f2bregex[8] = '-login: Aborted login.+ \\(tried to use disallowed .+\\): user=.+, rip=([0-9a-f\\.:]+), lip.+'\r\n    f2bregex[9] = 'SOGo.+ Login from \\'([0-9a-f\\.:]+)\\' for user .+ might not have worked'\r\n    f2bregex[10] = '([0-9a-f\\.:]+) \\\"GET \\/SOGo\\/.* HTTP.+\\\" 403 .+'\r\n    r.set('F2B_REGEX', json.dumps(f2bregex, ensure_ascii=False))\r\n  else:\r\n    try:\r\n      f2bregex = {}\r\n      f2bregex = json.loads(r.get('F2B_REGEX'))\r\n    except ValueError:\r\n      logger.logCrit('Error loading F2B options: F2B_REGEX is not json')\r\n      quit_now = True\r\n      exit_code = 2\r\n\r\ndef get_ip(address):\r\n  ip = ipaddress.ip_address(address)\r\n  if type(ip) is ipaddress.IPv6Address and ip.ipv4_mapped:\r\n    ip = ip.ipv4_mapped\r\n  if ip.is_private or ip.is_loopback:\r\n    return False\r\n  \r\n  return ip\r\n\r\ndef ban(address):\r\n  global f2boptions\r\n  global lock\r\n\r\n  refreshF2boptions()\r\n  BAN_TIME = int(f2boptions['ban_time'])\r\n  BAN_TIME_INCREMENT = bool(f2boptions['ban_time_increment'])\r\n  MAX_ATTEMPTS = int(f2boptions['max_attempts'])\r\n  RETRY_WINDOW = int(f2boptions['retry_window'])\r\n  NETBAN_IPV4 = '/' + str(f2boptions['netban_ipv4'])\r\n  NETBAN_IPV6 = '/' + str(f2boptions['netban_ipv6'])\r\n\r\n  ip = get_ip(address)\r\n  if not ip: return\r\n  address = str(ip)\r\n  self_network = ipaddress.ip_network(address)\r\n\r\n  with lock:\r\n    temp_whitelist = set(WHITELIST)\r\n  if temp_whitelist:\r\n    for wl_key in temp_whitelist:\r\n      wl_net = ipaddress.ip_network(wl_key, False)\r\n      if wl_net.overlaps(self_network):\r\n        logger.logInfo('Address %s is whitelisted by rule %s' % (self_network, wl_net))\r\n        return\r\n\r\n  net = ipaddress.ip_network((address + (NETBAN_IPV4 if type(ip) is ipaddress.IPv4Address else NETBAN_IPV6)), strict=False)\r\n  net = str(net)\r\n\r\n  if not net in bans:\r\n    bans[net] = {'attempts': 0, 'last_attempt': 0, 'ban_counter': 0}\r\n\r\n  current_attempt = time.time()\r\n  if current_attempt - bans[net]['last_attempt'] > RETRY_WINDOW:\r\n    bans[net]['attempts'] = 0\r\n\r\n  bans[net]['attempts'] += 1\r\n  bans[net]['last_attempt'] = current_attempt\r\n\r\n  if bans[net]['attempts'] >= MAX_ATTEMPTS:\r\n    cur_time = int(round(time.time()))\r\n    NET_BAN_TIME = BAN_TIME if not BAN_TIME_INCREMENT else BAN_TIME * 2 ** bans[net]['ban_counter']\r\n    logger.logCrit('Banning %s for %d minutes' % (net, NET_BAN_TIME / 60 ))\r\n    if type(ip) is ipaddress.IPv4Address and int(f2boptions['manage_external']) != 1:\r\n      with lock:\r\n        tables.banIPv4(net)\r\n    elif int(f2boptions['manage_external']) != 1:\r\n      with lock:\r\n        tables.banIPv6(net)\r\n\r\n    r.hset('F2B_ACTIVE_BANS', '%s' % net, cur_time + NET_BAN_TIME)\r\n  else:\r\n    logger.logWarn('%d more attempts in the next %d seconds until %s is banned' % (MAX_ATTEMPTS - bans[net]['attempts'], RETRY_WINDOW, net))\r\n\r\ndef unban(net):\r\n  global lock\r\n\r\n  if not net in bans:\r\n   logger.logInfo('%s is not banned, skipping unban and deleting from queue (if any)' % net)\r\n   r.hdel('F2B_QUEUE_UNBAN', '%s' % net)\r\n   return\r\n\r\n  logger.logInfo('Unbanning %s' % net)\r\n  if type(ipaddress.ip_network(net)) is ipaddress.IPv4Network:\r\n    with lock:\r\n      tables.unbanIPv4(net)\r\n  else:\r\n    with lock:\r\n      tables.unbanIPv6(net)\r\n\r\n  r.hdel('F2B_ACTIVE_BANS', '%s' % net)\r\n  r.hdel('F2B_QUEUE_UNBAN', '%s' % net)\r\n  if net in bans:\r\n    bans[net]['attempts'] = 0\r\n    bans[net]['ban_counter'] += 1\r\n\r\ndef permBan(net, unban=False):\r\n  global f2boptions\r\n  global lock\r\n\r\n  is_unbanned = False\r\n  is_banned = False\r\n  if type(ipaddress.ip_network(net, strict=False)) is ipaddress.IPv4Network:\r\n    with lock:\r\n      if unban:\r\n        is_unbanned = tables.unbanIPv4(net)\r\n      elif int(f2boptions['manage_external']) != 1:\r\n        is_banned = tables.banIPv4(net)\r\n  else:\r\n    with lock:\r\n      if unban:\r\n        is_unbanned = tables.unbanIPv6(net)\r\n      elif int(f2boptions['manage_external']) != 1:\r\n        is_banned = tables.banIPv6(net)\r\n\r\n\r\n  if is_unbanned:\r\n    r.hdel('F2B_PERM_BANS', '%s' % net)\r\n    logger.logCrit('Removed host/network %s from blacklist' % net)\r\n  elif is_banned:\r\n    r.hset('F2B_PERM_BANS', '%s' % net, int(round(time.time())))\r\n    logger.logCrit('Added host/network %s to blacklist' % net)\r\n\r\ndef clear():\r\n  global lock\r\n  logger.logInfo('Clearing all bans')\r\n  for net in bans.copy():\r\n    unban(net)\r\n  with lock:\r\n    tables.clearIPv4Table()\r\n    tables.clearIPv6Table()\r\n    r.delete('F2B_ACTIVE_BANS')\r\n    r.delete('F2B_PERM_BANS')\r\n    pubsub.unsubscribe()\r\n\r\ndef watch():\r\n  logger.logInfo('Watching Redis channel F2B_CHANNEL')\r\n  pubsub.subscribe('F2B_CHANNEL')\r\n\r\n  global quit_now\r\n  global exit_code\r\n\r\n  while not quit_now:\r\n    try:\r\n      for item in pubsub.listen():\r\n        refreshF2bregex()\r\n        for rule_id, rule_regex in f2bregex.items():\r\n          if item['data'] and item['type'] == 'message':\r\n            try:\r\n              result = re.search(rule_regex, item['data'])\r\n            except re.error:\r\n              result = False\r\n            if result:\r\n              addr = result.group(1)\r\n              ip = ipaddress.ip_address(addr)\r\n              if ip.is_private or ip.is_loopback:\r\n                continue\r\n              logger.logWarn('%s matched rule id %s (%s)' % (addr, rule_id, item['data']))\r\n              ban(addr)\r\n    except Exception as ex:\r\n      logger.logWarn('Error reading log line from pubsub: %s' % ex)\r\n      quit_now = True\r\n      exit_code = 2\r\n\r\ndef snat4(snat_target):\r\n  global lock\r\n  global quit_now\r\n\r\n  while not quit_now:\r\n    time.sleep(10)\r\n    with lock:\r\n      tables.snat4(snat_target, os.getenv('IPV4_NETWORK', '172.22.1') + '.0/24')\r\n\r\ndef snat6(snat_target):\r\n  global lock\r\n  global quit_now\r\n\r\n  while not quit_now:\r\n    time.sleep(10)\r\n    with lock:\r\n      tables.snat6(snat_target, os.getenv('IPV6_NETWORK', 'fd4d:6169:6c63:6f77::/64'))\r\n\r\ndef autopurge():\r\n  while not quit_now:\r\n    time.sleep(10)\r\n    refreshF2boptions()\r\n    BAN_TIME = int(f2boptions['ban_time'])\r\n    MAX_BAN_TIME = int(f2boptions['max_ban_time'])\r\n    BAN_TIME_INCREMENT = bool(f2boptions['ban_time_increment'])\r\n    MAX_ATTEMPTS = int(f2boptions['max_attempts'])\r\n    QUEUE_UNBAN = r.hgetall('F2B_QUEUE_UNBAN')\r\n    if QUEUE_UNBAN:\r\n      for net in QUEUE_UNBAN:\r\n        unban(str(net))\r\n    for net in bans.copy():\r\n      if bans[net]['attempts'] >= MAX_ATTEMPTS:\r\n        NET_BAN_TIME = BAN_TIME if not BAN_TIME_INCREMENT else BAN_TIME * 2 ** bans[net]['ban_counter']\r\n        TIME_SINCE_LAST_ATTEMPT = time.time() - bans[net]['last_attempt']\r\n        if TIME_SINCE_LAST_ATTEMPT > NET_BAN_TIME or TIME_SINCE_LAST_ATTEMPT > MAX_BAN_TIME:\r\n          unban(net)\r\n\r\ndef mailcowChainOrder():\r\n  global lock\r\n  global quit_now\r\n  global exit_code\r\n  while not quit_now:\r\n    time.sleep(10)\r\n    with lock:\r\n      quit_now, exit_code = tables.checkIPv4ChainOrder()\r\n      if quit_now: return\r\n      quit_now, exit_code = tables.checkIPv6ChainOrder()\r\n\r\ndef isIpNetwork(address):\r\n  try:\r\n    ipaddress.ip_network(address, False)\r\n  except ValueError:\r\n    return False\r\n  return True\r\n\r\ndef genNetworkList(list):\r\n  resolver = dns.resolver.Resolver()\r\n  hostnames = []\r\n  networks = []\r\n  for key in list:\r\n    if isIpNetwork(key):\r\n      networks.append(key)\r\n    else:\r\n      hostnames.append(key)\r\n  for hostname in hostnames:\r\n    hostname_ips = []\r\n    for rdtype in ['A', 'AAAA']:\r\n      try:\r\n        answer = resolver.resolve(qname=hostname, rdtype=rdtype, lifetime=3)\r\n      except dns.exception.Timeout:\r\n        logger.logInfo('Hostname %s timedout on resolve' % hostname)\r\n        break\r\n      except (dns.resolver.NXDOMAIN, dns.resolver.NoAnswer):\r\n        continue\r\n      except dns.exception.DNSException as dnsexception:\r\n        logger.logInfo('%s' % dnsexception)\r\n        continue\r\n      for rdata in answer:\r\n        hostname_ips.append(rdata.to_text())\r\n    networks.extend(hostname_ips)\r\n  return set(networks)\r\n\r\ndef whitelistUpdate():\r\n  global lock\r\n  global quit_now\r\n  global WHITELIST\r\n  while not quit_now:\r\n    start_time = time.time()\r\n    list = r.hgetall('F2B_WHITELIST')\r\n    new_whitelist = []\r\n    if list:\r\n      new_whitelist = genNetworkList(list)\r\n    with lock:\r\n      if Counter(new_whitelist) != Counter(WHITELIST):\r\n        WHITELIST = new_whitelist\r\n        logger.logInfo('Whitelist was changed, it has %s entries' % len(WHITELIST))\r\n    time.sleep(60.0 - ((time.time() - start_time) % 60.0))\r\n\r\ndef blacklistUpdate():\r\n  global quit_now\r\n  global BLACKLIST\r\n  while not quit_now:\r\n    start_time = time.time()\r\n    list = r.hgetall('F2B_BLACKLIST')\r\n    new_blacklist = []\r\n    if list:\r\n      new_blacklist = genNetworkList(list)\r\n    if Counter(new_blacklist) != Counter(BLACKLIST):\r\n      addban = set(new_blacklist).difference(BLACKLIST)\r\n      delban = set(BLACKLIST).difference(new_blacklist)\r\n      BLACKLIST = new_blacklist\r\n      logger.logInfo('Blacklist was changed, it has %s entries' % len(BLACKLIST))\r\n      if addban:\r\n        for net in addban:\r\n          permBan(net=net)\r\n      if delban:\r\n        for net in delban:\r\n          permBan(net=net, unban=True)\r\n    time.sleep(60.0 - ((time.time() - start_time) % 60.0))\r\n\r\ndef quit(signum, frame):\r\n  global quit_now\r\n  quit_now = True\r\n\r\n\r\nif __name__ == '__main__':\r\n  refreshF2boptions()\r\n  # In case a previous session was killed without cleanup\r\n  clear()\r\n  # Reinit MAILCOW chain\r\n  # Is called before threads start, no locking\r\n  logger.logInfo(\"Initializing mailcow netfilter chain\")\r\n  tables.initChainIPv4()\r\n  tables.initChainIPv6()\r\n\r\n  watch_thread = Thread(target=watch)\r\n  watch_thread.daemon = True\r\n  watch_thread.start()\r\n\r\n  if os.getenv('SNAT_TO_SOURCE') and os.getenv('SNAT_TO_SOURCE') != 'n':\r\n    try:\r\n      snat_ip = os.getenv('SNAT_TO_SOURCE')\r\n      snat_ipo = ipaddress.ip_address(snat_ip)\r\n      if type(snat_ipo) is ipaddress.IPv4Address:\r\n        snat4_thread = Thread(target=snat4,args=(snat_ip,))\r\n        snat4_thread.daemon = True\r\n        snat4_thread.start()\r\n    except ValueError:\r\n      print(os.getenv('SNAT_TO_SOURCE') + ' is not a valid IPv4 address')\r\n\r\n  if os.getenv('SNAT6_TO_SOURCE') and os.getenv('SNAT6_TO_SOURCE') != 'n':\r\n    try:\r\n      snat_ip = os.getenv('SNAT6_TO_SOURCE')\r\n      snat_ipo = ipaddress.ip_address(snat_ip)\r\n      if type(snat_ipo) is ipaddress.IPv6Address:\r\n        snat6_thread = Thread(target=snat6,args=(snat_ip,))\r\n        snat6_thread.daemon = True\r\n        snat6_thread.start()\r\n    except ValueError:\r\n      print(os.getenv('SNAT6_TO_SOURCE') + ' is not a valid IPv6 address')\r\n\r\n  autopurge_thread = Thread(target=autopurge)\r\n  autopurge_thread.daemon = True\r\n  autopurge_thread.start()\r\n\r\n  mailcowchainwatch_thread = Thread(target=mailcowChainOrder)\r\n  mailcowchainwatch_thread.daemon = True\r\n  mailcowchainwatch_thread.start()\r\n\r\n  blacklistupdate_thread = Thread(target=blacklistUpdate)\r\n  blacklistupdate_thread.daemon = True\r\n  blacklistupdate_thread.start()\r\n\r\n  whitelistupdate_thread = Thread(target=whitelistUpdate)\r\n  whitelistupdate_thread.daemon = True\r\n  whitelistupdate_thread.start()\r\n\r\n  signal.signal(signal.SIGTERM, quit)\r\n  atexit.register(clear)\r\n\r\n  while not quit_now:\r\n    time.sleep(0.5)\r\n\r\n  sys.exit(exit_code)\r\n", "import iptc\nimport time\n\nclass IPTables:\n  def __init__(self, chain_name, logger):\n    self.chain_name = chain_name\n    self.logger = logger\n\n  def initChainIPv4(self):\n    if not iptc.Chain(iptc.Table(iptc.Table.FILTER), self.chain_name) in iptc.Table(iptc.Table.FILTER).chains:\n      iptc.Table(iptc.Table.FILTER).create_chain(self.chain_name)\n    for c in ['FORWARD', 'INPUT']:\n      chain = iptc.Chain(iptc.Table(iptc.Table.FILTER), c)\n      rule = iptc.Rule()\n      rule.src = '0.0.0.0/0'\n      rule.dst = '0.0.0.0/0'\n      target = iptc.Target(rule, self.chain_name)\n      rule.target = target\n      if rule not in chain.rules:\n        chain.insert_rule(rule)\n\n  def initChainIPv6(self):\n    if not iptc.Chain(iptc.Table6(iptc.Table6.FILTER), self.chain_name) in iptc.Table6(iptc.Table6.FILTER).chains:\n      iptc.Table6(iptc.Table6.FILTER).create_chain(self.chain_name)\n    for c in ['FORWARD', 'INPUT']:\n      chain = iptc.Chain(iptc.Table6(iptc.Table6.FILTER), c)\n      rule = iptc.Rule6()\n      rule.src = '::/0'\n      rule.dst = '::/0'\n      target = iptc.Target(rule, self.chain_name)\n      rule.target = target\n      if rule not in chain.rules:\n        chain.insert_rule(rule)\n\n  def checkIPv4ChainOrder(self):\n    filter_table = iptc.Table(iptc.Table.FILTER)\n    filter_table.refresh()\n    return self.checkChainOrder(filter_table)\n\n  def checkIPv6ChainOrder(self):\n    filter_table = iptc.Table6(iptc.Table6.FILTER)\n    filter_table.refresh()\n    return self.checkChainOrder(filter_table)\n\n  def checkChainOrder(self, filter_table):\n    err = False\n    exit_code = None\n\n    forward_chain = iptc.Chain(filter_table, 'FORWARD')\n    input_chain = iptc.Chain(filter_table, 'INPUT')\n    for chain in [forward_chain, input_chain]:\n      target_found = False\n      for position, item in enumerate(chain.rules):\n        if item.target.name == self.chain_name:\n          target_found = True\n          if position > 2:\n            self.logger.logCrit('Error in %s chain: %s target not found, restarting container' % (chain.name, self.chain_name))\n            err = True\n            exit_code = 2\n      if not target_found:\n        self.logger.logCrit('Error in %s chain: %s target not found, restarting container' % (chain.name, self.chain_name))\n        err = True\n        exit_code = 2\n\n    return err, exit_code\n\n  def clearIPv4Table(self):\n    self.clearTable(iptc.Table(iptc.Table.FILTER))\n\n  def clearIPv6Table(self):\n    self.clearTable(iptc.Table6(iptc.Table6.FILTER))\n\n  def clearTable(self, filter_table):\n    filter_table.autocommit = False\n    forward_chain = iptc.Chain(filter_table, \"FORWARD\")\n    input_chain = iptc.Chain(filter_table, \"INPUT\")\n    mailcow_chain = iptc.Chain(filter_table, self.chain_name)\n    if mailcow_chain in filter_table.chains:\n      for rule in mailcow_chain.rules:\n        mailcow_chain.delete_rule(rule)\n      for rule in forward_chain.rules:\n        if rule.target.name == self.chain_name:\n          forward_chain.delete_rule(rule)\n      for rule in input_chain.rules:\n        if rule.target.name == self.chain_name:\n          input_chain.delete_rule(rule)\n      filter_table.delete_chain(self.chain_name)\n    filter_table.commit()\n    filter_table.refresh()\n    filter_table.autocommit = True\n\n  def banIPv4(self, source):\n    chain = iptc.Chain(iptc.Table(iptc.Table.FILTER), self.chain_name)\n    rule = iptc.Rule()\n    rule.src = source\n    target = iptc.Target(rule, \"REJECT\")\n    rule.target = target\n    if rule in chain.rules:\n      return False\n    chain.insert_rule(rule)\n    return True\n\n  def banIPv6(self, source):\n    chain = iptc.Chain(iptc.Table6(iptc.Table6.FILTER), self.chain_name)\n    rule = iptc.Rule6()\n    rule.src = source\n    target = iptc.Target(rule, \"REJECT\")\n    rule.target = target\n    if rule in chain.rules:\n      return False\n    chain.insert_rule(rule)\n    return True\n\n  def unbanIPv4(self, source):\n    chain = iptc.Chain(iptc.Table(iptc.Table.FILTER), self.chain_name)\n    rule = iptc.Rule()\n    rule.src = source\n    target = iptc.Target(rule, \"REJECT\")\n    rule.target = target\n    if rule not in chain.rules: \n      return False\n    chain.delete_rule(rule)\n    return True\n\n  def unbanIPv6(self, source):\n    chain = iptc.Chain(iptc.Table6(iptc.Table6.FILTER), self.chain_name)\n    rule = iptc.Rule6()\n    rule.src = source\n    target = iptc.Target(rule, \"REJECT\")\n    rule.target = target\n    if rule not in chain.rules:\n      return False\n    chain.delete_rule(rule)\n    return True\n\n  def snat4(self, snat_target, source):\n    try:\n      table = iptc.Table('nat')\n      table.refresh()\n      chain = iptc.Chain(table, 'POSTROUTING')\n      table.autocommit = False\n      new_rule = self.getSnat4Rule(snat_target, source)\n\n      if not chain.rules:\n        # if there are no rules in the chain, insert the new rule directly\n        self.logger.logInfo(f'Added POSTROUTING rule for source network {new_rule.src} to SNAT target {snat_target}')\n        chain.insert_rule(new_rule)\n      else:\n        for position, rule in enumerate(chain.rules):\n          if not hasattr(rule.target, 'parameter'):\n              continue\n          match = all((\n            new_rule.get_src() == rule.get_src(),\n            new_rule.get_dst() == rule.get_dst(),\n            new_rule.target.parameters == rule.target.parameters,\n            new_rule.target.name == rule.target.name\n          ))\n          if position == 0:\n            if not match:\n              self.logger.logInfo(f'Added POSTROUTING rule for source network {new_rule.src} to SNAT target {snat_target}')\n              chain.insert_rule(new_rule)\n          else:\n            if match:\n              self.logger.logInfo(f'Remove rule for source network {new_rule.src} to SNAT target {snat_target} from POSTROUTING chain at position {position}')\n              chain.delete_rule(rule)\n\n      table.commit()\n      table.autocommit = True\n      return True\n    except:\n      self.logger.logCrit('Error running SNAT4, retrying...')\n      return False\n\n  def snat6(self, snat_target, source):\n    try:\n      table = iptc.Table6('nat')\n      table.refresh()\n      chain = iptc.Chain(table, 'POSTROUTING')\n      table.autocommit = False\n      new_rule = self.getSnat6Rule(snat_target, source)\n\n      if new_rule not in chain.rules:\n        self.logger.logInfo('Added POSTROUTING rule for source network %s to SNAT target %s' % (new_rule.src, snat_target))\n        chain.insert_rule(new_rule)\n      else:\n        for position, item in enumerate(chain.rules):\n          if item == new_rule:\n            if position != 0:\n              chain.delete_rule(new_rule)\n    \n      table.commit()\n      table.autocommit = True\n    except:\n      self.logger.logCrit('Error running SNAT6, retrying...')\n\n\n  def getSnat4Rule(self, snat_target, source):\n    rule = iptc.Rule()\n    rule.src = source\n    rule.dst = '!' + rule.src\n    target = rule.create_target(\"SNAT\")\n    target.to_source = snat_target\n    match = rule.create_match(\"comment\")\n    match.comment = f'{int(round(time.time()))}'\n    return rule\n\n  def getSnat6Rule(self, snat_target, source):\n    rule = iptc.Rule6()\n    rule.src = source\n    rule.dst = '!' + rule.src\n    target = rule.create_target(\"SNAT\")\n    target.to_source = snat_target\n    return rule\n", "import time\nimport json\n\nclass Logger:\n  def __init__(self, redis):\n    self.r = redis\n\n  def log(self, priority, message):\n    tolog = {}\n    tolog['time'] = int(round(time.time()))\n    tolog['priority'] = priority\n    tolog['message'] = message\n    self.r.lpush('NETFILTER_LOG', json.dumps(tolog, ensure_ascii=False))\n    print(message)\n\n  def logWarn(self, message):\n    self.log('warn', message)\n\n  def logCrit(self, message):\n    self.log('crit', message)\n\n  def logInfo(self, message):\n    self.log('info', message)\n", "import nftables\nimport ipaddress\n\nclass NFTables:\n  def __init__(self, chain_name, logger):\n    self.chain_name = chain_name\n    self.logger = logger\n\n    self.nft = nftables.Nftables()\n    self.nft.set_json_output(True)\n    self.nft.set_handle_output(True)\n    self.nft_chain_names = {'ip': {'filter': {'input': '', 'forward': ''}, 'nat': {'postrouting': ''} },\n                            'ip6': {'filter': {'input': '', 'forward': ''}, 'nat': {'postrouting': ''} } }\n\n    self.search_current_chains()\n\n  def initChainIPv4(self):\n    self.insert_mailcow_chains(\"ip\")\n\n  def initChainIPv6(self):\n    self.insert_mailcow_chains(\"ip6\")\n\n  def checkIPv4ChainOrder(self):\n    return self.checkChainOrder(\"ip\")\n\n  def checkIPv6ChainOrder(self):\n    return self.checkChainOrder(\"ip6\")\n\n  def checkChainOrder(self, filter_table):\n    err = False\n    exit_code = None\n\n    for chain in ['input', 'forward']:\n      chain_position = self.check_mailcow_chains(filter_table, chain)\n      if chain_position is None: continue\n\n      if chain_position is False:\n        self.logger.logCrit(f'MAILCOW target not found in {filter_table} {chain} table, restarting container to fix it...')\n        err = True\n        exit_code = 2\n\n      if chain_position > 0:\n        self.logger.logCrit(f'MAILCOW target is in position {chain_position} in the {filter_table} {chain} table, restarting container to fix it...')\n        err = True\n        exit_code = 2\n\n    return err, exit_code\n\n  def clearIPv4Table(self):\n    self.clearTable(\"ip\")\n\n  def clearIPv6Table(self):\n    self.clearTable(\"ip6\")\n\n  def clearTable(self, _family):\n    is_empty_dict = True\n    json_command = self.get_base_dict()\n    chain_handle = self.get_chain_handle(_family, \"filter\", self.chain_name)\n    # if no handle, the chain doesn't exists\n    if chain_handle is not None:\n      is_empty_dict = False\n      # flush chain\n      mailcow_chain = {'family': _family, 'table': 'filter', 'name': self.chain_name}\n      flush_chain = {'flush': {'chain': mailcow_chain}}\n      json_command[\"nftables\"].append(flush_chain)\n\n    # remove rule in forward chain\n    # remove rule in input chain\n    chains_family = [self.nft_chain_names[_family]['filter']['input'],\n                    self.nft_chain_names[_family]['filter']['forward'] ]\n\n    for chain_base in chains_family:\n      if not chain_base: continue\n\n      rules_handle = self.get_rules_handle(_family, \"filter\", chain_base)\n      if rules_handle is not None:\n        for r_handle in rules_handle:\n          is_empty_dict = False\n          mailcow_rule = {'family':_family,\n                          'table': 'filter',\n                          'chain': chain_base,\n                          'handle': r_handle }\n          delete_rules = {'delete': {'rule': mailcow_rule} }\n          json_command[\"nftables\"].append(delete_rules)\n\n    # remove chain\n    # after delete all rules referencing this chain\n    if chain_handle is not None:\n      mc_chain_handle = {'family':_family,\n                        'table': 'filter',\n                        'name': self.chain_name,\n                        'handle': chain_handle }\n      delete_chain = {'delete': {'chain': mc_chain_handle} }\n      json_command[\"nftables\"].append(delete_chain)\n\n    if is_empty_dict == False:\n      if self.nft_exec_dict(json_command):\n        self.logger.logInfo(f\"Clear completed: {_family}\")\n\n  def banIPv4(self, source):\n    ban_dict = self.get_ban_ip_dict(source, \"ip\")\n    return self.nft_exec_dict(ban_dict)\n\n  def banIPv6(self, source):\n    ban_dict = self.get_ban_ip_dict(source, \"ip6\")\n    return self.nft_exec_dict(ban_dict)\n\n  def unbanIPv4(self, source):\n    unban_dict = self.get_unban_ip_dict(source, \"ip\")\n    if not unban_dict:\n      return False\n    return self.nft_exec_dict(unban_dict)\n\n  def unbanIPv6(self, source):\n    unban_dict = self.get_unban_ip_dict(source, \"ip6\")\n    if not unban_dict:\n      return False\n    return self.nft_exec_dict(unban_dict)\n\n  def snat4(self, snat_target, source):\n    self.snat_rule(\"ip\", snat_target, source)\n\n  def snat6(self, snat_target, source):\n    self.snat_rule(\"ip6\", snat_target, source)\n\n\n  def nft_exec_dict(self, query: dict):\n    if not query: return False\n\n    rc, output, error = self.nft.json_cmd(query)\n    if rc != 0:\n      #self.logger.logCrit(f\"Nftables Error: {error}\")\n      return False\n\n    # Prevent returning False or empty string on commands that do not produce output\n    if rc == 0 and len(output) == 0:\n      return True\n\n    return output\n\n  def get_base_dict(self):\n    return {'nftables': [{ 'metainfo': { 'json_schema_version': 1} } ] }\n\n  def search_current_chains(self):\n    nft_chain_priority = {'ip': {'filter': {'input': None, 'forward': None}, 'nat': {'postrouting': None} },\n                      'ip6': {'filter': {'input': None, 'forward': None}, 'nat': {'postrouting': None} } }\n\n    # Command: 'nft list chains'\n    _list = {'list' : {'chains': 'null'} }\n    command = self.get_base_dict()\n    command['nftables'].append(_list)\n    kernel_ruleset = self.nft_exec_dict(command)\n    if kernel_ruleset:\n      for _object in kernel_ruleset['nftables']:\n        chain = _object.get(\"chain\")\n        if not chain: continue\n\n        _family = chain['family']\n        _table = chain['table']\n        _hook = chain.get(\"hook\")\n        _priority = chain.get(\"prio\")\n        _name = chain['name']\n\n        if _family not in self.nft_chain_names: continue\n        if _table not in self.nft_chain_names[_family]: continue\n        if _hook not in self.nft_chain_names[_family][_table]: continue\n        if _priority is None: continue\n\n        _saved_priority = nft_chain_priority[_family][_table][_hook]\n        if _saved_priority is None or _priority < _saved_priority:\n          # at this point, we know the chain has:\n          # hook and priority set\n          # and it has the lowest priority\n          nft_chain_priority[_family][_table][_hook] = _priority\n          self.nft_chain_names[_family][_table][_hook] = _name\n\n  def search_for_chain(self, kernel_ruleset: dict, chain_name: str):\n    found = False\n    for _object in kernel_ruleset[\"nftables\"]:\n      chain = _object.get(\"chain\")\n      if not chain:\n        continue\n      ch_name = chain.get(\"name\")\n      if ch_name == chain_name:\n        found = True\n        break\n    return found\n\n  def get_chain_dict(self, _family: str, _name: str):\n    # nft (add | create) chain [<family>] <table> <name> \n    _chain_opts = {'family': _family, 'table': 'filter', 'name': _name  }\n    _add = {'add': {'chain': _chain_opts} }\n    final_chain = self.get_base_dict()\n    final_chain[\"nftables\"].append(_add)\n    return final_chain\n\n  def get_mailcow_jump_rule_dict(self, _family: str, _chain: str):\n    _jump_rule = self.get_base_dict()\n    _expr_opt=[]\n    _expr_counter = {'family': _family, 'table': 'filter', 'packets': 0, 'bytes': 0}\n    _counter_dict = {'counter': _expr_counter}\n    _expr_opt.append(_counter_dict)\n\n    _jump_opts = {'jump': {'target': self.chain_name} }\n\n    _expr_opt.append(_jump_opts)\n\n    _rule_params = {'family': _family,\n                    'table': 'filter',\n                    'chain': _chain,\n                    'expr': _expr_opt,\n                    'comment': \"mailcow\" }\n\n    _add_rule = {'insert': {'rule': _rule_params} }\n\n    _jump_rule[\"nftables\"].append(_add_rule)\n\n    return _jump_rule\n\n  def insert_mailcow_chains(self, _family: str):\n    nft_input_chain = self.nft_chain_names[_family]['filter']['input']\n    nft_forward_chain = self.nft_chain_names[_family]['filter']['forward']\n    # Command: 'nft list table <family> filter'\n    _table_opts = {'family': _family, 'name': 'filter'}\n    _list = {'list': {'table': _table_opts} }\n    command = self.get_base_dict()\n    command['nftables'].append(_list)\n    kernel_ruleset = self.nft_exec_dict(command)\n    if kernel_ruleset:\n      # chain\n      if not self.search_for_chain(kernel_ruleset, self.chain_name):\n        cadena = self.get_chain_dict(_family, self.chain_name)\n        if self.nft_exec_dict(cadena):\n          self.logger.logInfo(f\"MAILCOW {_family} chain created successfully.\")\n\n      input_jump_found, forward_jump_found = False, False\n\n      for _object in kernel_ruleset[\"nftables\"]:\n        if not _object.get(\"rule\"):\n          continue\n\n        rule = _object[\"rule\"]\n        if nft_input_chain and rule[\"chain\"] == nft_input_chain:\n          if rule.get(\"comment\") and rule[\"comment\"] == \"mailcow\":\n            input_jump_found = True\n        if nft_forward_chain and rule[\"chain\"] == nft_forward_chain:\n          if rule.get(\"comment\") and rule[\"comment\"] == \"mailcow\":\n            forward_jump_found = True\n\n      if not input_jump_found:\n        command = self.get_mailcow_jump_rule_dict(_family, nft_input_chain)\n        self.nft_exec_dict(command)\n\n      if not forward_jump_found:\n        command = self.get_mailcow_jump_rule_dict(_family, nft_forward_chain)\n        self.nft_exec_dict(command)\n\n  def delete_nat_rule(self, _family:str, _chain: str, _handle:str):\n    delete_command = self.get_base_dict()\n    _rule_opts = {'family': _family,\n                  'table': 'nat',\n                  'chain': _chain,\n                  'handle': _handle  }\n    _delete = {'delete': {'rule': _rule_opts} }\n    delete_command[\"nftables\"].append(_delete)\n\n    return self.nft_exec_dict(delete_command)\n\n  def snat_rule(self, _family: str, snat_target: str, source_address: str):\n    chain_name = self.nft_chain_names[_family]['nat']['postrouting']\n\n    # no postrouting chain, may occur if docker has ipv6 disabled.\n    if not chain_name: return\n\n    # Command: nft list chain <family> nat <chain_name>\n    _chain_opts = {'family': _family, 'table': 'nat', 'name': chain_name}\n    _list = {'list':{'chain': _chain_opts} }\n    command = self.get_base_dict()\n    command['nftables'].append(_list)\n    kernel_ruleset = self.nft_exec_dict(command)\n    if not kernel_ruleset:\n      return\n\n    rule_position = 0\n    rule_handle = None\n    rule_found = False\n    for _object in kernel_ruleset[\"nftables\"]:\n      if not _object.get(\"rule\"):\n        continue\n\n      rule = _object[\"rule\"]\n      if not rule.get(\"comment\") or not rule[\"comment\"] == \"mailcow\":\n        rule_position +=1\n        continue\n\n      rule_found = True\n      rule_handle = rule[\"handle\"]\n      break\n\n    dest_net = ipaddress.ip_network(source_address)\n    target_net = ipaddress.ip_network(snat_target)\n\n    if rule_found:\n      saddr_ip = rule[\"expr\"][0][\"match\"][\"right\"][\"prefix\"][\"addr\"]\n      saddr_len = int(rule[\"expr\"][0][\"match\"][\"right\"][\"prefix\"][\"len\"])\n\n      daddr_ip = rule[\"expr\"][1][\"match\"][\"right\"][\"prefix\"][\"addr\"]\n      daddr_len = int(rule[\"expr\"][1][\"match\"][\"right\"][\"prefix\"][\"len\"])\n\n      target_ip = rule[\"expr\"][3][\"snat\"][\"addr\"]\n\n      saddr_net = ipaddress.ip_network(saddr_ip + '/' + str(saddr_len))\n      daddr_net = ipaddress.ip_network(daddr_ip + '/' + str(daddr_len))\n      current_target_net = ipaddress.ip_network(target_ip)\n\n      match = all((\n                dest_net == saddr_net,\n                dest_net == daddr_net,\n                target_net == current_target_net\n              ))\n      try:\n        if rule_position == 0:\n          if not match:\n            # Position 0 , it is a mailcow rule , but it does not have the same parameters\n            if self.delete_nat_rule(_family, chain_name, rule_handle):\n              self.logger.logInfo(f'Remove rule for source network {saddr_net} to SNAT target {target_net} from {_family} nat {chain_name} chain, rule does not match configured parameters')\n        else:\n          # Position > 0 and is mailcow rule\n          if self.delete_nat_rule(_family, chain_name, rule_handle):\n            self.logger.logInfo(f'Remove rule for source network {saddr_net} to SNAT target {target_net} from {_family} nat {chain_name} chain, rule is at position {rule_position}')\n      except:\n          self.logger.logCrit(f\"Error running SNAT on {_family}, retrying...\" )\n    else:\n      # rule not found\n      json_command = self.get_base_dict()\n      try:\n        snat_dict = {'snat': {'addr': str(target_net.network_address)} }\n\n        expr_counter = {'family': _family, 'table': 'nat', 'packets': 0, 'bytes': 0}\n        counter_dict = {'counter': expr_counter}\n\n        prefix_dict = {'prefix': {'addr': str(dest_net.network_address), 'len': int(dest_net.prefixlen)} }\n        payload_dict = {'payload': {'protocol': _family, 'field': \"saddr\"} }\n        match_dict1 = {'match': {'op': '==', 'left': payload_dict, 'right': prefix_dict} }\n\n        payload_dict2 = {'payload': {'protocol': _family, 'field': \"daddr\"} }\n        match_dict2 = {'match': {'op': '!=', 'left': payload_dict2, 'right': prefix_dict } }\n        expr_list = [\n                    match_dict1,\n                    match_dict2,\n                    counter_dict,\n                    snat_dict\n                    ]\n        rule_fields = {'family': _family,\n                        'table': 'nat',\n                        'chain': chain_name,\n                        'comment': \"mailcow\",\n                        'expr': expr_list }\n\n        insert_dict = {'insert': {'rule': rule_fields} }\n        json_command[\"nftables\"].append(insert_dict)\n        if self.nft_exec_dict(json_command):\n          self.logger.logInfo(f'Added {_family} nat {chain_name} rule for source network {dest_net} to {target_net}')\n      except:\n        self.logger.logCrit(f\"Error running SNAT on {_family}, retrying...\")\n\n  def get_chain_handle(self, _family: str, _table: str, chain_name: str):\n    chain_handle = None\n    # Command: 'nft list chains {family}'\n    _list = {'list': {'chains': {'family': _family} } }\n    command = self.get_base_dict()\n    command['nftables'].append(_list)\n    kernel_ruleset = self.nft_exec_dict(command)\n    if kernel_ruleset:\n      for _object in kernel_ruleset[\"nftables\"]:\n        if not _object.get(\"chain\"):\n          continue\n        chain = _object[\"chain\"]\n        if chain[\"family\"] == _family and chain[\"table\"] == _table and chain[\"name\"] == chain_name:\n          chain_handle = chain[\"handle\"]\n          break\n    return chain_handle\n\n  def get_rules_handle(self, _family: str, _table: str, chain_name: str):\n    rule_handle = []\n    # Command: 'nft list chain {family} {table} {chain_name}'\n    _chain_opts = {'family': _family, 'table': _table, 'name': chain_name}\n    _list = {'list': {'chain': _chain_opts} }\n    command = self.get_base_dict()\n    command['nftables'].append(_list)\n\n    kernel_ruleset = self.nft_exec_dict(command)\n    if kernel_ruleset:\n      for _object in kernel_ruleset[\"nftables\"]:\n        if not _object.get(\"rule\"):\n          continue\n\n        rule = _object[\"rule\"]\n        if rule[\"family\"] == _family and rule[\"table\"] == _table and rule[\"chain\"] == chain_name:\n          if rule.get(\"comment\") and rule[\"comment\"] == \"mailcow\":\n            rule_handle.append(rule[\"handle\"])\n    return rule_handle\n\n  def get_ban_ip_dict(self, ipaddr: str, _family: str):\n    json_command = self.get_base_dict()\n\n    expr_opt = []\n    ipaddr_net = ipaddress.ip_network(ipaddr)\n    right_dict = {'prefix': {'addr': str(ipaddr_net.network_address), 'len': int(ipaddr_net.prefixlen) } }\n\n    left_dict = {'payload': {'protocol': _family, 'field': 'saddr'} }\n    match_dict = {'op': '==', 'left': left_dict, 'right': right_dict }\n    expr_opt.append({'match': match_dict})\n\n    counter_dict = {'counter': {'family': _family, 'table': \"filter\", 'packets': 0, 'bytes': 0} }\n    expr_opt.append(counter_dict)\n\n    expr_opt.append({'drop': \"null\"})\n\n    rule_dict = {'family': _family, 'table': \"filter\", 'chain': self.chain_name, 'expr': expr_opt}\n\n    base_dict = {'insert': {'rule': rule_dict} }\n    json_command[\"nftables\"].append(base_dict)\n\n    return json_command\n\n  def get_unban_ip_dict(self, ipaddr:str, _family: str):\n    json_command = self.get_base_dict()\n    # Command: 'nft list chain {s_family} filter  MAILCOW'\n    _chain_opts = {'family': _family, 'table': 'filter', 'name': self.chain_name}\n    _list = {'list': {'chain': _chain_opts} }\n    command = self.get_base_dict()\n    command['nftables'].append(_list)\n    kernel_ruleset = self.nft_exec_dict(command)\n    rule_handle = None\n    if kernel_ruleset:\n      for _object in kernel_ruleset[\"nftables\"]:\n        if not _object.get(\"rule\"):\n          continue\n\n        rule = _object[\"rule\"][\"expr\"][0][\"match\"]\n        left_opt = rule[\"left\"][\"payload\"]\n        if not left_opt[\"protocol\"] == _family:\n          continue\n        if not left_opt[\"field\"] ==\"saddr\":\n          continue\n\n        # ip currently banned\n        rule_right = rule[\"right\"]\n        if isinstance(rule_right, dict):\n          current_rule_ip = rule_right[\"prefix\"][\"addr\"] + '/' + str(rule_right[\"prefix\"][\"len\"])\n        else:\n          current_rule_ip = rule_right\n        current_rule_net = ipaddress.ip_network(current_rule_ip)\n\n        # ip to ban\n        candidate_net = ipaddress.ip_network(ipaddr)\n\n        if current_rule_net == candidate_net:\n          rule_handle = _object[\"rule\"][\"handle\"]\n          break\n\n      if rule_handle is not None:\n        mailcow_rule = {'family': _family, 'table': 'filter', 'chain': self.chain_name, 'handle': rule_handle}\n        delete_rule = {'delete': {'rule': mailcow_rule} }\n        json_command[\"nftables\"].append(delete_rule)\n      else:\n        return False\n\n    return json_command\n\n  def check_mailcow_chains(self, family: str, chain: str):\n    position = 0\n    rule_found = False\n    chain_name = self.nft_chain_names[family]['filter'][chain]\n\n    if not chain_name: return None\n\n    _chain_opts = {'family': family, 'table': 'filter', 'name': chain_name}\n    _list = {'list': {'chain': _chain_opts}}\n    command = self.get_base_dict()\n    command['nftables'].append(_list)\n    kernel_ruleset = self.nft_exec_dict(command)\n    if kernel_ruleset:\n      for _object in kernel_ruleset[\"nftables\"]:\n        if not _object.get(\"rule\"):\n          continue\n        rule = _object[\"rule\"]\n        if rule.get(\"comment\") and rule[\"comment\"] == \"mailcow\":\n          rule_found = True\n          break\n\n        position+=1\n\n    return position if rule_found else False\n", "# --------------------------------------------------------------------------\n# Please create a file \"extra.conf\" for persistent overrides to dovecot.conf\n# --------------------------------------------------------------------------\n# LDAP example:\n#passdb {\n#  args = /etc/dovecot/ldap/passdb.conf\n#  driver = ldap\n#}\n\nauth_mechanisms = plain login\n#mail_debug = yes\n#auth_debug = yes\nlog_path = syslog\ndisable_plaintext_auth = yes\n# Uncomment on NFS share\n#mmap_disable = yes\n#mail_fsync = always\n#mail_nfs_index = yes\n#mail_nfs_storage = yes\nlogin_log_format_elements = \"user=<%u> method=%m rip=%r lip=%l mpid=%e %c %k\"\nmail_home = /var/vmail/%d/%n\nmail_location = maildir:~/\nmail_plugins = </etc/dovecot/mail_plugins\nmail_attachment_fs = crypt:set_prefix=mail_crypt_global:posix:\nmail_attachment_dir = /var/attachments\nmail_attachment_min_size = 128k\n# Significantly speeds up very large mailboxes, but is only safe to enable if\n# you do not manually modify the files in the `cur` directories in\n# mailcowdockerized_vmail-vol-1.\n# https://docs.mailcow.email/manual-guides/Dovecot/u_e-dovecot-performance/\nmaildir_very_dirty_syncs = yes\n\n# Dovecot 2.2\n#ssl_protocols = !SSLv3\n# Dovecot 2.3\nssl_min_protocol = TLSv1.2\n\nssl_prefer_server_ciphers = yes\nssl_cipher_list = ALL:!ADH:!LOW:!SSLv2:!SSLv3:!EXP:!aNULL:!eNULL:!3DES:!MD5:!PSK:!DSS:!RC4:!SEED:!IDEA:+HIGH:+MEDIUM\n\n# Default in Dovecot 2.3\nssl_options = no_compression no_ticket\n\n# New in Dovecot 2.3\nssl_dh = </etc/ssl/mail/dhparams.pem\n# Dovecot 2.2\n#ssl_dh_parameters_length = 2048\nlog_timestamp = \"%Y-%m-%d %H:%M:%S \"\nrecipient_delimiter = +\nauth_master_user_separator = *\nmail_shared_explicit_inbox = yes\nmail_prefetch_count = 30\npassdb {\n  driver = lua\n  args = file=/etc/dovecot/lua/passwd-verify.lua blocking=yes\n  result_success = return-ok\n  result_failure = continue\n  result_internalfail = continue\n}\n# try a master passwd\npassdb {\n  driver = passwd-file\n  args = /etc/dovecot/dovecot-master.passwd\n  master = yes\n  skip = authenticated\n}\n# check for regular password - if empty (e.g. force-passwd-reset), previous pass=yes passdbs also fail\n# a return of the following passdb is mandatory\npassdb {\n  driver = lua\n  args = file=/etc/dovecot/lua/passwd-verify.lua blocking=yes\n}\n# Set doveadm_password=your-secret-password in data/conf/dovecot/extra.conf (create if missing)\nservice doveadm {\n  inet_listener {\n    port = 12345\n  }\n  vsz_limit=2048 MB\n}\n!include /etc/dovecot/dovecot.folders.conf\nprotocols = imap sieve lmtp pop3\nservice dict {\n  unix_listener dict {\n    mode = 0660\n    user = vmail\n    group = vmail\n  }\n}\nservice log {\n  user = dovenull\n}\nservice config {\n  unix_listener config {\n    user = root\n    group = vmail\n    mode = 0660\n  }\n}\nservice auth {\n  inet_listener auth-inet {\n    port = 10001\n  }\n  unix_listener auth-master {\n    mode = 0600\n    user = vmail\n  }\n  unix_listener auth-userdb {\n    mode = 0600\n    user = vmail\n  }\n  vsz_limit = 2G\n}\nservice managesieve-login {\n  inet_listener sieve {\n    port = 4190\n  }\n  inet_listener sieve_haproxy {\n    port = 14190\n    haproxy = yes\n  }\n  service_count = 1\n  process_min_avail = 2\n  vsz_limit = 1G\n}\nservice imap-login {\n  service_count = 1\n  process_limit = 10000\n  vsz_limit = 1G\n  user = dovenull\n  inet_listener imap_haproxy {\n    port = 10143\n    haproxy = yes\n  }\n  inet_listener imaps_haproxy {\n    port = 10993\n    ssl = yes\n    haproxy = yes\n  }\n}\nservice pop3-login {\n  service_count = 1\n  vsz_limit = 1G\n  inet_listener pop3_haproxy {\n    port = 10110\n    haproxy = yes\n  }\n  inet_listener pop3s_haproxy {\n    port = 10995\n    ssl = yes\n    haproxy = yes\n  }\n}\nservice imap {\n  executable = imap\n  user = vmail\n  vsz_limit = 1G\n}\nservice managesieve {\n  process_limit = 256\n}\nservice lmtp {\n  inet_listener lmtp-inet {\n    port = 24\n  }\n  user = vmail\n}\nlisten = *,[::]\nssl_cert = </etc/ssl/mail/cert.pem\nssl_key = </etc/ssl/mail/key.pem\nuserdb {\n  driver = passwd-file\n  args = /etc/dovecot/dovecot-master.userdb\n}\nuserdb {\n  args = /etc/dovecot/sql/dovecot-dict-sql-userdb.conf\n  driver = sql\n  skip = found\n}\nprotocol imap {\n  mail_plugins = </etc/dovecot/mail_plugins_imap\n  imap_metadata = yes\n}\nmail_attribute_dict = file:%h/dovecot-attributes\nprotocol lmtp {\n  mail_plugins = </etc/dovecot/mail_plugins_lmtp\n  auth_socket_path = /var/run/dovecot/auth-master\n}\nprotocol sieve {\n  managesieve_logout_format = bytes=%i/%o\n}\nplugin {\n  # Allow \"any\" or \"authenticated\" to be used in ACLs\n  acl_anyone = </etc/dovecot/acl_anyone\n  acl_shared_dict = file:/var/vmail/shared-mailboxes.db\n  acl = vfile\n  acl_user = %u\n  fts = solr\n  fts_autoindex = yes\n  fts_solr = url=http://solr:8983/solr/dovecot-fts/\n  quota = dict:Userquota::proxy::sqlquota\n  quota_rule2 = Trash:storage=+100%%\n  sieve = /var/vmail/sieve/%u.sieve\n  sieve_plugins = sieve_imapsieve sieve_extprograms\n  sieve_vacation_send_from_recipient = yes\n  sieve_redirect_envelope_from = recipient\n  # From elsewhere to Spam folder\n  imapsieve_mailbox1_name = Junk\n  imapsieve_mailbox1_causes = COPY\n  imapsieve_mailbox1_before = file:/usr/lib/dovecot/sieve/report-spam.sieve\n  # END\n  # From Spam folder to elsewhere\n  imapsieve_mailbox2_name = *\n  imapsieve_mailbox2_from = Junk\n  imapsieve_mailbox2_causes = COPY\n  imapsieve_mailbox2_before = file:/usr/lib/dovecot/sieve/report-ham.sieve\n  # END\n  master_user = %u\n  quota_warning = storage=95%% quota-warning 95 %u\n  quota_warning2 = storage=80%% quota-warning 80 %u\n  sieve_pipe_bin_dir = /usr/lib/dovecot/sieve\n  sieve_global_extensions = +vnd.dovecot.pipe +vnd.dovecot.execute\n  sieve_extensions = +notify +imapflags +vacation-seconds +editheader\n  sieve_max_script_size = 1M\n  sieve_max_redirects = 100\n  sieve_max_actions = 101\n  sieve_quota_max_scripts = 0\n  sieve_quota_max_storage = 0\n  listescape_char = \"\\\\\"\n  sieve_vacation_min_period = 5s\n  sieve_vacation_max_period = 0\n  sieve_vacation_default_period = 60s\n  sieve_before = /var/vmail/sieve/global_sieve_before.sieve\n  sieve_before2 = dict:proxy::sieve_before;name=active;bindir=/var/vmail/sieve_before_bindir\n  sieve_after = dict:proxy::sieve_after;name=active;bindir=/var/vmail/sieve_after_bindir\n  sieve_after2 = /var/vmail/sieve/global_sieve_after.sieve\n  sieve_duplicate_default_period = 1m\n  sieve_duplicate_max_period = 7d\n\n  # -- Global keys\n  mail_crypt_global_private_key = </mail_crypt/ecprivkey.pem\n  mail_crypt_global_public_key = </mail_crypt/ecpubkey.pem\n  mail_crypt_save_version = 2\n\n  # Enable compression while saving, lz4 Dovecot v2.2.11+\n  zlib_save = lz4\n\n  mail_log_events = delete undelete expunge copy mailbox_delete mailbox_rename\n  mail_log_fields = uid box msgid size\n  mail_log_cached_only = yes\n}\nservice quota-warning {\n  executable = script /usr/local/bin/quota_notify.py\n  # use some unprivileged user for executing the quota warnings\n  user = vmail\n  unix_listener quota-warning {\n    user = vmail\n  }\n}\ndict {\n  sqlquota = mysql:/etc/dovecot/sql/dovecot-dict-sql-quota.conf\n  sieve_after = mysql:/etc/dovecot/sql/dovecot-dict-sql-sieve_after.conf\n  sieve_before = mysql:/etc/dovecot/sql/dovecot-dict-sql-sieve_before.conf\n}\nremote 127.0.0.1 {\n  disable_plaintext_auth = no\n}\nsubmission_host = postfix:588\nmail_max_userip_connections = 500\nservice stats {\n  unix_listener stats-writer {\n    mode = 0660\n    user = vmail\n  }\n}\nimap_max_line_length = 2 M\n#auth_cache_verify_password_with_worker = yes\n#auth_cache_negative_ttl = 0\n#auth_cache_ttl = 30 s\n#auth_cache_size = 2 M\nservice replicator {\n  process_min_avail = 1\n}\nservice aggregator {\n  fifo_listener replication-notify-fifo {\n    user = vmail\n  }\n  unix_listener replication-notify {\n    user = vmail\n  }\n}\nservice replicator {\n  unix_listener replicator-doveadm {\n    mode = 0666\n  }\n}\nreplication_max_conns = 10\ndoveadm_port = 12345\nreplication_dsync_parameters = -d -l 30 -U -n INBOX\n# <Includes>\n!include_try /etc/dovecot/sni.conf\n!include_try /etc/dovecot/sogo_trusted_ip.conf\n!include_try /etc/dovecot/extra.conf\n!include_try /etc/dovecot/sogo-sso.conf\n!include_try /etc/dovecot/shared_namespace.conf\n# </Includes>\ndefault_client_limit = 10400\ndefault_vsz_limit = 1024 M\n", "version: '2.1'\nservices:\n\n    unbound-mailcow:\n      image: mailcow/unbound:1.20\n      environment:\n        - TZ=${TZ}\n        - SKIP_UNBOUND_HEALTHCHECK=${SKIP_UNBOUND_HEALTHCHECK:-n}\n      volumes:\n        - ./data/hooks/unbound:/hooks:Z\n        - ./data/conf/unbound/unbound.conf:/etc/unbound/unbound.conf:ro,Z\n      restart: always\n      tty: true\n      networks:\n        mailcow-network:\n          ipv4_address: ${IPV4_NETWORK:-172.22.1}.254\n          aliases:\n            - unbound\n\n    mysql-mailcow:\n      image: mariadb:10.5\n      depends_on:\n        - unbound-mailcow\n      stop_grace_period: 45s\n      volumes:\n        - mysql-vol-1:/var/lib/mysql/\n        - mysql-socket-vol-1:/var/run/mysqld/\n        - ./data/conf/mysql/:/etc/mysql/conf.d/:ro,Z\n      environment:\n        - TZ=${TZ}\n        - MYSQL_ROOT_PASSWORD=${DBROOT}\n        - MYSQL_DATABASE=${DBNAME}\n        - MYSQL_USER=${DBUSER}\n        - MYSQL_PASSWORD=${DBPASS}\n        - MYSQL_INITDB_SKIP_TZINFO=1\n      restart: always\n      ports:\n        - \"${SQL_PORT:-127.0.0.1:13306}:3306\"\n      networks:\n        mailcow-network:\n          aliases:\n            - mysql\n\n    redis-mailcow:\n      image: redis:7-alpine\n      volumes:\n        - redis-vol-1:/data/\n      restart: always\n      ports:\n        - \"${REDIS_PORT:-127.0.0.1:7654}:6379\"\n      environment:\n        - TZ=${TZ}\n      sysctls:\n        - net.core.somaxconn=4096\n      networks:\n        mailcow-network:\n          ipv4_address: ${IPV4_NETWORK:-172.22.1}.249\n          aliases:\n            - redis\n\n    clamd-mailcow:\n      image: mailcow/clamd:1.64\n      restart: always\n      depends_on:\n        unbound-mailcow:\n          condition: service_healthy\n      dns:\n        - ${IPV4_NETWORK:-172.22.1}.254\n      environment:\n        - TZ=${TZ}\n        - SKIP_CLAMD=${SKIP_CLAMD:-n}\n      volumes:\n        - ./data/conf/clamav/:/etc/clamav/:Z\n        - clamd-db-vol-1:/var/lib/clamav\n      networks:\n        mailcow-network:\n          aliases:\n            - clamd\n\n    rspamd-mailcow:\n      image: mailcow/rspamd:1.95\n      stop_grace_period: 30s\n      depends_on:\n        - dovecot-mailcow\n      environment:\n        - TZ=${TZ}\n        - IPV4_NETWORK=${IPV4_NETWORK:-172.22.1}\n        - IPV6_NETWORK=${IPV6_NETWORK:-fd4d:6169:6c63:6f77::/64}\n        - REDIS_SLAVEOF_IP=${REDIS_SLAVEOF_IP:-}\n        - REDIS_SLAVEOF_PORT=${REDIS_SLAVEOF_PORT:-}\n      volumes:\n        - ./data/hooks/rspamd:/hooks:Z\n        - ./data/conf/rspamd/custom/:/etc/rspamd/custom:z\n        - ./data/conf/rspamd/override.d/:/etc/rspamd/override.d:Z\n        - ./data/conf/rspamd/local.d/:/etc/rspamd/local.d:Z\n        - ./data/conf/rspamd/plugins.d/:/etc/rspamd/plugins.d:Z\n        - ./data/conf/rspamd/lua/:/etc/rspamd/lua/:ro,Z\n        - ./data/conf/rspamd/rspamd.conf.local:/etc/rspamd/rspamd.conf.local:Z\n        - ./data/conf/rspamd/rspamd.conf.override:/etc/rspamd/rspamd.conf.override:Z\n        - rspamd-vol-1:/var/lib/rspamd\n      restart: always\n      hostname: rspamd\n      dns:\n        - ${IPV4_NETWORK:-172.22.1}.254\n      networks:\n        mailcow-network:\n          aliases:\n            - rspamd\n\n    php-fpm-mailcow:\n      image: mailcow/phpfpm:1.87\n      command: \"php-fpm -d date.timezone=${TZ} -d expose_php=0\"\n      depends_on:\n        - redis-mailcow\n      volumes:\n        - ./data/hooks/phpfpm:/hooks:Z\n        - ./data/web:/web:z\n        - ./data/conf/rspamd/dynmaps:/dynmaps:ro,z\n        - ./data/conf/rspamd/custom/:/rspamd_custom_maps:z\n        - rspamd-vol-1:/var/lib/rspamd\n        - mysql-socket-vol-1:/var/run/mysqld/\n        - ./data/conf/sogo/:/etc/sogo/:z\n        - ./data/conf/rspamd/meta_exporter:/meta_exporter:ro,z\n        - ./data/conf/phpfpm/sogo-sso/:/etc/sogo-sso/:z\n        - ./data/conf/phpfpm/php-fpm.d/pools.conf:/usr/local/etc/php-fpm.d/z-pools.conf:Z\n        - ./data/conf/phpfpm/php-conf.d/opcache-recommended.ini:/usr/local/etc/php/conf.d/opcache-recommended.ini:Z\n        - ./data/conf/phpfpm/php-conf.d/upload.ini:/usr/local/etc/php/conf.d/upload.ini:Z\n        - ./data/conf/phpfpm/php-conf.d/other.ini:/usr/local/etc/php/conf.d/zzz-other.ini:Z\n        - ./data/conf/dovecot/global_sieve_before:/global_sieve/before:z\n        - ./data/conf/dovecot/global_sieve_after:/global_sieve/after:z\n        - ./data/assets/templates:/tpls:z\n        - ./data/conf/nginx/:/etc/nginx/conf.d/:z\n      dns:\n        - ${IPV4_NETWORK:-172.22.1}.254\n      environment:\n        - REDIS_SLAVEOF_IP=${REDIS_SLAVEOF_IP:-}\n        - REDIS_SLAVEOF_PORT=${REDIS_SLAVEOF_PORT:-}\n        - LOG_LINES=${LOG_LINES:-9999}\n        - TZ=${TZ}\n        - DBNAME=${DBNAME}\n        - DBUSER=${DBUSER}\n        - DBPASS=${DBPASS}\n        - MAILCOW_HOSTNAME=${MAILCOW_HOSTNAME}\n        - MAILCOW_PASS_SCHEME=${MAILCOW_PASS_SCHEME:-BLF-CRYPT}\n        - IMAP_PORT=${IMAP_PORT:-143}\n        - IMAPS_PORT=${IMAPS_PORT:-993}\n        - POP_PORT=${POP_PORT:-110}\n        - POPS_PORT=${POPS_PORT:-995}\n        - SIEVE_PORT=${SIEVE_PORT:-4190}\n        - IPV4_NETWORK=${IPV4_NETWORK:-172.22.1}\n        - IPV6_NETWORK=${IPV6_NETWORK:-fd4d:6169:6c63:6f77::/64}\n        - SUBMISSION_PORT=${SUBMISSION_PORT:-587}\n        - SMTPS_PORT=${SMTPS_PORT:-465}\n        - SMTP_PORT=${SMTP_PORT:-25}\n        - API_KEY=${API_KEY:-invalid}\n        - API_KEY_READ_ONLY=${API_KEY_READ_ONLY:-invalid}\n        - API_ALLOW_FROM=${API_ALLOW_FROM:-invalid}\n        - COMPOSE_PROJECT_NAME=${COMPOSE_PROJECT_NAME:-mailcow-dockerized}\n        - SKIP_SOLR=${SKIP_SOLR:-y}\n        - SKIP_CLAMD=${SKIP_CLAMD:-n}\n        - SKIP_SOGO=${SKIP_SOGO:-n}\n        - ALLOW_ADMIN_EMAIL_LOGIN=${ALLOW_ADMIN_EMAIL_LOGIN:-n}\n        - MASTER=${MASTER:-y}\n        - DEV_MODE=${DEV_MODE:-n}\n        - DEMO_MODE=${DEMO_MODE:-n}\n        - WEBAUTHN_ONLY_TRUSTED_VENDORS=${WEBAUTHN_ONLY_TRUSTED_VENDORS:-n}\n        - CLUSTERMODE=${CLUSTERMODE:-}\n      restart: always\n      networks:\n        mailcow-network:\n          aliases:\n            - phpfpm\n\n    sogo-mailcow:\n      image: mailcow/sogo:1.122\n      environment:\n        - DBNAME=${DBNAME}\n        - DBUSER=${DBUSER}\n        - DBPASS=${DBPASS}\n        - TZ=${TZ}\n        - LOG_LINES=${LOG_LINES:-9999}\n        - MAILCOW_HOSTNAME=${MAILCOW_HOSTNAME}\n        - MAILCOW_PASS_SCHEME=${MAILCOW_PASS_SCHEME:-BLF-CRYPT}\n        - ACL_ANYONE=${ACL_ANYONE:-disallow}\n        - ALLOW_ADMIN_EMAIL_LOGIN=${ALLOW_ADMIN_EMAIL_LOGIN:-n}\n        - IPV4_NETWORK=${IPV4_NETWORK:-172.22.1}\n        - SOGO_EXPIRE_SESSION=${SOGO_EXPIRE_SESSION:-480}\n        - SKIP_SOGO=${SKIP_SOGO:-n}\n        - MASTER=${MASTER:-y}\n        - REDIS_SLAVEOF_IP=${REDIS_SLAVEOF_IP:-}\n        - REDIS_SLAVEOF_PORT=${REDIS_SLAVEOF_PORT:-}\n      dns:\n        - ${IPV4_NETWORK:-172.22.1}.254\n      volumes:\n        - ./data/hooks/sogo:/hooks:Z\n        - ./data/conf/sogo/:/etc/sogo/:z\n        - ./data/web/inc/init_db.inc.php:/init_db.inc.php:z\n        - ./data/conf/sogo/custom-favicon.ico:/usr/lib/GNUstep/SOGo/WebServerResources/img/sogo.ico:z\n        - ./data/conf/sogo/custom-theme.js:/usr/lib/GNUstep/SOGo/WebServerResources/js/theme.js:z\n        - ./data/conf/sogo/custom-sogo.js:/usr/lib/GNUstep/SOGo/WebServerResources/js/custom-sogo.js:z\n        - mysql-socket-vol-1:/var/run/mysqld/\n        - sogo-web-vol-1:/sogo_web\n        - sogo-userdata-backup-vol-1:/sogo_backup\n      labels:\n        ofelia.enabled: \"true\"\n        ofelia.job-exec.sogo_sessions.schedule: \"@every 1m\"\n        ofelia.job-exec.sogo_sessions.command: \"/bin/bash -c \\\"[[ $${MASTER} == y ]] && /usr/local/bin/gosu sogo /usr/sbin/sogo-tool -v expire-sessions $${SOGO_EXPIRE_SESSION} || exit 0\\\"\"\n        ofelia.job-exec.sogo_ealarms.schedule: \"@every 1m\"\n        ofelia.job-exec.sogo_ealarms.command: \"/bin/bash -c \\\"[[ $${MASTER} == y ]] && /usr/local/bin/gosu sogo /usr/sbin/sogo-ealarms-notify -p /etc/sogo/sieve.creds || exit 0\\\"\"\n        ofelia.job-exec.sogo_eautoreply.schedule: \"@every 5m\"\n        ofelia.job-exec.sogo_eautoreply.command: \"/bin/bash -c \\\"[[ $${MASTER} == y ]] && /usr/local/bin/gosu sogo /usr/sbin/sogo-tool update-autoreply -p /etc/sogo/sieve.creds || exit 0\\\"\"\n        ofelia.job-exec.sogo_backup.schedule: \"@every 24h\"\n        ofelia.job-exec.sogo_backup.command: \"/bin/bash -c \\\"[[ $${MASTER} == y ]] && /usr/local/bin/gosu sogo /usr/sbin/sogo-tool backup /sogo_backup ALL || exit 0\\\"\"\n      restart: always\n      networks:\n        mailcow-network:\n          ipv4_address: ${IPV4_NETWORK:-172.22.1}.248\n          aliases:\n            - sogo\n\n    dovecot-mailcow:\n      image: mailcow/dovecot:1.27\n      depends_on:\n        - mysql-mailcow\n      dns:\n        - ${IPV4_NETWORK:-172.22.1}.254\n      cap_add:\n        - NET_BIND_SERVICE\n      volumes:\n        - ./data/hooks/dovecot:/hooks:Z\n        - ./data/conf/dovecot:/etc/dovecot:z\n        - ./data/assets/ssl:/etc/ssl/mail/:ro,z\n        - ./data/conf/sogo/:/etc/sogo/:z\n        - ./data/conf/phpfpm/sogo-sso/:/etc/phpfpm/:z\n        - vmail-vol-1:/var/vmail\n        - vmail-index-vol-1:/var/vmail_index\n        - crypt-vol-1:/mail_crypt/\n        - ./data/conf/rspamd/custom/:/etc/rspamd/custom:z\n        - ./data/assets/templates:/templates:z\n        - rspamd-vol-1:/var/lib/rspamd\n        - mysql-socket-vol-1:/var/run/mysqld/\n      environment:\n        - DOVECOT_MASTER_USER=${DOVECOT_MASTER_USER:-}\n        - DOVECOT_MASTER_PASS=${DOVECOT_MASTER_PASS:-}\n        - LOG_LINES=${LOG_LINES:-9999}\n        - DBNAME=${DBNAME}\n        - DBUSER=${DBUSER}\n        - DBPASS=${DBPASS}\n        - TZ=${TZ}\n        - MAILCOW_HOSTNAME=${MAILCOW_HOSTNAME}\n        - MAILCOW_PASS_SCHEME=${MAILCOW_PASS_SCHEME:-BLF-CRYPT}\n        - IPV4_NETWORK=${IPV4_NETWORK:-172.22.1}\n        - ALLOW_ADMIN_EMAIL_LOGIN=${ALLOW_ADMIN_EMAIL_LOGIN:-n}\n        - MAILDIR_GC_TIME=${MAILDIR_GC_TIME:-7200}\n        - ACL_ANYONE=${ACL_ANYONE:-disallow}\n        - SKIP_SOLR=${SKIP_SOLR:-y}\n        - MAILDIR_SUB=${MAILDIR_SUB:-}\n        - MASTER=${MASTER:-y}\n        - REDIS_SLAVEOF_IP=${REDIS_SLAVEOF_IP:-}\n        - REDIS_SLAVEOF_PORT=${REDIS_SLAVEOF_PORT:-}\n        - COMPOSE_PROJECT_NAME=${COMPOSE_PROJECT_NAME:-mailcow-dockerized}\n      ports:\n        - \"${DOVEADM_PORT:-127.0.0.1:19991}:12345\"\n        - \"${IMAP_PORT:-143}:143\"\n        - \"${IMAPS_PORT:-993}:993\"\n        - \"${POP_PORT:-110}:110\"\n        - \"${POPS_PORT:-995}:995\"\n        - \"${SIEVE_PORT:-4190}:4190\"\n      restart: always\n      tty: true\n      labels:\n        ofelia.enabled: \"true\"\n        ofelia.job-exec.dovecot_imapsync_runner.schedule: \"@every 1m\"\n        ofelia.job-exec.dovecot_imapsync_runner.no-overlap: \"true\"\n        ofelia.job-exec.dovecot_imapsync_runner.command: \"/bin/bash -c \\\"[[ $${MASTER} == y ]] && /usr/local/bin/gosu nobody /usr/local/bin/imapsync_runner.pl || exit 0\\\"\"\n        ofelia.job-exec.dovecot_trim_logs.schedule: \"@every 1m\"\n        ofelia.job-exec.dovecot_trim_logs.command: \"/bin/bash -c \\\"[[ $${MASTER} == y ]] && /usr/local/bin/gosu vmail /usr/local/bin/trim_logs.sh || exit 0\\\"\"\n        ofelia.job-exec.dovecot_quarantine.schedule: \"@every 20m\"\n        ofelia.job-exec.dovecot_quarantine.command: \"/bin/bash -c \\\"[[ $${MASTER} == y ]] && /usr/local/bin/gosu vmail /usr/local/bin/quarantine_notify.py || exit 0\\\"\"\n        ofelia.job-exec.dovecot_clean_q_aged.schedule: \"@every 24h\"\n        ofelia.job-exec.dovecot_clean_q_aged.command: \"/bin/bash -c \\\"[[ $${MASTER} == y ]] && /usr/local/bin/gosu vmail /usr/local/bin/clean_q_aged.sh || exit 0\\\"\"\n        ofelia.job-exec.dovecot_maildir_gc.schedule: \"@every 30m\"\n        ofelia.job-exec.dovecot_maildir_gc.command: \"/bin/bash -c \\\"source /source_env.sh ; /usr/local/bin/gosu vmail /usr/local/bin/maildir_gc.sh\\\"\"\n        ofelia.job-exec.dovecot_sarules.schedule: \"@every 24h\"\n        ofelia.job-exec.dovecot_sarules.command: \"/bin/bash -c \\\"/usr/local/bin/sa-rules.sh\\\"\"\n        ofelia.job-exec.dovecot_fts.schedule: \"@every 24h\"\n        ofelia.job-exec.dovecot_fts.command: \"/usr/bin/curl http://solr:8983/solr/dovecot-fts/update?optimize=true\"\n        ofelia.job-exec.dovecot_repl_health.schedule: \"@every 5m\"\n        ofelia.job-exec.dovecot_repl_health.command: \"/bin/bash -c \\\"/usr/local/bin/gosu vmail /usr/local/bin/repl_health.sh\\\"\"\n      ulimits:\n        nproc: 65535\n        nofile:\n          soft: 20000\n          hard: 40000\n      networks:\n        mailcow-network:\n          ipv4_address: ${IPV4_NETWORK:-172.22.1}.250\n          aliases:\n            - dovecot\n\n    postfix-mailcow:\n      image: mailcow/postfix:1.74\n      depends_on:\n        mysql-mailcow:\n          condition: service_started\n        unbound-mailcow:\n          condition: service_healthy\n      volumes:\n        - ./data/hooks/postfix:/hooks:Z\n        - ./data/conf/postfix:/opt/postfix/conf:z\n        - ./data/assets/ssl:/etc/ssl/mail/:ro,z\n        - postfix-vol-1:/var/spool/postfix\n        - crypt-vol-1:/var/lib/zeyple\n        - rspamd-vol-1:/var/lib/rspamd\n        - mysql-socket-vol-1:/var/run/mysqld/\n      environment:\n        - LOG_LINES=${LOG_LINES:-9999}\n        - TZ=${TZ}\n        - DBNAME=${DBNAME}\n        - DBUSER=${DBUSER}\n        - DBPASS=${DBPASS}\n        - REDIS_SLAVEOF_IP=${REDIS_SLAVEOF_IP:-}\n        - REDIS_SLAVEOF_PORT=${REDIS_SLAVEOF_PORT:-}\n        - MAILCOW_HOSTNAME=${MAILCOW_HOSTNAME}\n        - SPAMHAUS_DQS_KEY=${SPAMHAUS_DQS_KEY:-}\n      cap_add:\n        - NET_BIND_SERVICE\n      ports:\n        - \"${SMTP_PORT:-25}:25\"\n        - \"${SMTPS_PORT:-465}:465\"\n        - \"${SUBMISSION_PORT:-587}:587\"\n      restart: always\n      dns:\n        - ${IPV4_NETWORK:-172.22.1}.254\n      networks:\n        mailcow-network:\n          ipv4_address: ${IPV4_NETWORK:-172.22.1}.253\n          aliases:\n            - postfix\n\n    memcached-mailcow:\n      image: memcached:alpine\n      restart: always\n      environment:\n        - TZ=${TZ}\n      networks:\n        mailcow-network:\n          aliases:\n            - memcached\n\n    nginx-mailcow:\n      depends_on:\n        - sogo-mailcow\n        - php-fpm-mailcow\n        - redis-mailcow\n      image: nginx:mainline-alpine\n      dns:\n        - ${IPV4_NETWORK:-172.22.1}.254\n      command: /bin/sh -c \"envsubst < /etc/nginx/conf.d/templates/listen_plain.template > /etc/nginx/conf.d/listen_plain.active &&\n        envsubst < /etc/nginx/conf.d/templates/listen_ssl.template > /etc/nginx/conf.d/listen_ssl.active &&\n        envsubst < /etc/nginx/conf.d/templates/sogo.template > /etc/nginx/conf.d/sogo.active &&\n        . /etc/nginx/conf.d/templates/server_name.template.sh > /etc/nginx/conf.d/server_name.active &&\n        . /etc/nginx/conf.d/templates/sites.template.sh > /etc/nginx/conf.d/sites.active &&\n        . /etc/nginx/conf.d/templates/sogo_eas.template.sh > /etc/nginx/conf.d/sogo_eas.active &&\n        nginx -qt &&\n        until ping phpfpm -c1 > /dev/null; do sleep 1; done &&\n        until ping sogo -c1 > /dev/null; do sleep 1; done &&\n        until ping redis -c1 > /dev/null; do sleep 1; done &&\n        until ping rspamd -c1 > /dev/null; do sleep 1; done &&\n        exec nginx -g 'daemon off;'\"\n      environment:\n        - HTTPS_PORT=${HTTPS_PORT:-443}\n        - HTTP_PORT=${HTTP_PORT:-80}\n        - MAILCOW_HOSTNAME=${MAILCOW_HOSTNAME}\n        - IPV4_NETWORK=${IPV4_NETWORK:-172.22.1}\n        - TZ=${TZ}\n        - SKIP_SOGO=${SKIP_SOGO:-n}\n        - ALLOW_ADMIN_EMAIL_LOGIN=${ALLOW_ADMIN_EMAIL_LOGIN:-n}\n        - ADDITIONAL_SERVER_NAMES=${ADDITIONAL_SERVER_NAMES:-}\n      volumes:\n        - ./data/web:/web:ro,z\n        - ./data/conf/rspamd/dynmaps:/dynmaps:ro,z\n        - ./data/assets/ssl/:/etc/ssl/mail/:ro,z\n        - ./data/conf/nginx/:/etc/nginx/conf.d/:z\n        - ./data/conf/rspamd/meta_exporter:/meta_exporter:ro,z\n        - sogo-web-vol-1:/usr/lib/GNUstep/SOGo/\n      ports:\n        - \"${HTTPS_BIND:-}:${HTTPS_PORT:-443}:${HTTPS_PORT:-443}\"\n        - \"${HTTP_BIND:-}:${HTTP_PORT:-80}:${HTTP_PORT:-80}\"\n      restart: always\n      networks:\n        mailcow-network:\n          aliases:\n            - nginx\n\n    acme-mailcow:\n      depends_on:\n        nginx-mailcow:\n          condition: service_started\n        unbound-mailcow:\n          condition: service_healthy\n      image: mailcow/acme:1.87\n      dns:\n        - ${IPV4_NETWORK:-172.22.1}.254\n      environment:\n        - LOG_LINES=${LOG_LINES:-9999}\n        - ACME_CONTACT=${ACME_CONTACT:-}\n        - ADDITIONAL_SAN=${ADDITIONAL_SAN}\n        - MAILCOW_HOSTNAME=${MAILCOW_HOSTNAME}\n        - DBNAME=${DBNAME}\n        - DBUSER=${DBUSER}\n        - DBPASS=${DBPASS}\n        - SKIP_LETS_ENCRYPT=${SKIP_LETS_ENCRYPT:-n}\n        - COMPOSE_PROJECT_NAME=${COMPOSE_PROJECT_NAME:-mailcow-dockerized}\n        - DIRECTORY_URL=${DIRECTORY_URL:-}\n        - ENABLE_SSL_SNI=${ENABLE_SSL_SNI:-n}\n        - SKIP_IP_CHECK=${SKIP_IP_CHECK:-n}\n        - SKIP_HTTP_VERIFICATION=${SKIP_HTTP_VERIFICATION:-n}\n        - ONLY_MAILCOW_HOSTNAME=${ONLY_MAILCOW_HOSTNAME:-n}\n        - LE_STAGING=${LE_STAGING:-n}\n        - TZ=${TZ}\n        - REDIS_SLAVEOF_IP=${REDIS_SLAVEOF_IP:-}\n        - REDIS_SLAVEOF_PORT=${REDIS_SLAVEOF_PORT:-}\n        - SNAT_TO_SOURCE=${SNAT_TO_SOURCE:-n}\n        - SNAT6_TO_SOURCE=${SNAT6_TO_SOURCE:-n}\n      volumes:\n        - ./data/web/.well-known/acme-challenge:/var/www/acme:z\n        - ./data/assets/ssl:/var/lib/acme/:z\n        - ./data/assets/ssl-example:/var/lib/ssl-example/:ro,Z\n        - mysql-socket-vol-1:/var/run/mysqld/\n      restart: always\n      networks:\n        mailcow-network:\n          aliases:\n            - acme\n\n    netfilter-mailcow:\n      image: mailcow/netfilter:1.55\n      stop_grace_period: 30s\n      depends_on:\n        - dovecot-mailcow\n        - postfix-mailcow\n        - sogo-mailcow\n        - php-fpm-mailcow\n        - redis-mailcow\n      restart: always\n      privileged: true\n      environment:\n        - TZ=${TZ}\n        - IPV4_NETWORK=${IPV4_NETWORK:-172.22.1}\n        - IPV6_NETWORK=${IPV6_NETWORK:-fd4d:6169:6c63:6f77::/64}\n        - SNAT_TO_SOURCE=${SNAT_TO_SOURCE:-n}\n        - SNAT6_TO_SOURCE=${SNAT6_TO_SOURCE:-n}\n        - REDIS_SLAVEOF_IP=${REDIS_SLAVEOF_IP:-}\n        - REDIS_SLAVEOF_PORT=${REDIS_SLAVEOF_PORT:-}\n      network_mode: \"host\"\n      volumes:\n        - /lib/modules:/lib/modules:ro\n\n    watchdog-mailcow:\n      image: mailcow/watchdog:2.02\n      dns:\n        - ${IPV4_NETWORK:-172.22.1}.254\n      tmpfs:\n        - /tmp\n      volumes:\n        - rspamd-vol-1:/var/lib/rspamd\n        - mysql-socket-vol-1:/var/run/mysqld/\n        - postfix-vol-1:/var/spool/postfix\n        - ./data/assets/ssl:/etc/ssl/mail/:ro,z\n      restart: always\n      depends_on:\n        - postfix-mailcow\n        - dovecot-mailcow\n        - mysql-mailcow\n        - acme-mailcow\n        - redis-mailcow\n\n      environment:\n        - IPV6_NETWORK=${IPV6_NETWORK:-fd4d:6169:6c63:6f77::/64}\n        - LOG_LINES=${LOG_LINES:-9999}\n        - TZ=${TZ}\n        - DBNAME=${DBNAME}\n        - DBUSER=${DBUSER}\n        - DBPASS=${DBPASS}\n        - DBROOT=${DBROOT}\n        - USE_WATCHDOG=${USE_WATCHDOG:-n}\n        - WATCHDOG_NOTIFY_EMAIL=${WATCHDOG_NOTIFY_EMAIL:-}\n        - WATCHDOG_NOTIFY_BAN=${WATCHDOG_NOTIFY_BAN:-y}\n        - WATCHDOG_NOTIFY_START=${WATCHDOG_NOTIFY_START:-y}\n        - WATCHDOG_SUBJECT=${WATCHDOG_SUBJECT:-Watchdog ALERT}\n        - WATCHDOG_NOTIFY_WEBHOOK=${WATCHDOG_NOTIFY_WEBHOOK:-}\n        - WATCHDOG_NOTIFY_WEBHOOK_BODY=${WATCHDOG_NOTIFY_WEBHOOK_BODY:-}\n        - WATCHDOG_EXTERNAL_CHECKS=${WATCHDOG_EXTERNAL_CHECKS:-n}\n        - WATCHDOG_MYSQL_REPLICATION_CHECKS=${WATCHDOG_MYSQL_REPLICATION_CHECKS:-n}\n        - WATCHDOG_VERBOSE=${WATCHDOG_VERBOSE:-n}\n        - MAILCOW_HOSTNAME=${MAILCOW_HOSTNAME}\n        - COMPOSE_PROJECT_NAME=${COMPOSE_PROJECT_NAME:-mailcow-dockerized}\n        - IPV4_NETWORK=${IPV4_NETWORK:-172.22.1}\n        - IP_BY_DOCKER_API=${IP_BY_DOCKER_API:-0}\n        - CHECK_UNBOUND=${CHECK_UNBOUND:-1}\n        - SKIP_CLAMD=${SKIP_CLAMD:-n}\n        - SKIP_LETS_ENCRYPT=${SKIP_LETS_ENCRYPT:-n}\n        - SKIP_SOGO=${SKIP_SOGO:-n}\n        - HTTPS_PORT=${HTTPS_PORT:-443}\n        - REDIS_SLAVEOF_IP=${REDIS_SLAVEOF_IP:-}\n        - REDIS_SLAVEOF_PORT=${REDIS_SLAVEOF_PORT:-}\n        - EXTERNAL_CHECKS_THRESHOLD=${EXTERNAL_CHECKS_THRESHOLD:-1}\n        - NGINX_THRESHOLD=${NGINX_THRESHOLD:-5}\n        - UNBOUND_THRESHOLD=${UNBOUND_THRESHOLD:-5}\n        - REDIS_THRESHOLD=${REDIS_THRESHOLD:-5}\n        - MYSQL_THRESHOLD=${MYSQL_THRESHOLD:-5}\n        - MYSQL_REPLICATION_THRESHOLD=${MYSQL_REPLICATION_THRESHOLD:-1}\n        - SOGO_THRESHOLD=${SOGO_THRESHOLD:-3}\n        - POSTFIX_THRESHOLD=${POSTFIX_THRESHOLD:-8}\n        - CLAMD_THRESHOLD=${CLAMD_THRESHOLD:-15}\n        - DOVECOT_THRESHOLD=${DOVECOT_THRESHOLD:-12}\n        - DOVECOT_REPL_THRESHOLD=${DOVECOT_REPL_THRESHOLD:-20}\n        - PHPFPM_THRESHOLD=${PHPFPM_THRESHOLD:-5}\n        - RATELIMIT_THRESHOLD=${RATELIMIT_THRESHOLD:-1}\n        - FAIL2BAN_THRESHOLD=${FAIL2BAN_THRESHOLD:-1}\n        - ACME_THRESHOLD=${ACME_THRESHOLD:-1}\n        - RSPAMD_THRESHOLD=${RSPAMD_THRESHOLD:-5}\n        - OLEFY_THRESHOLD=${OLEFY_THRESHOLD:-5}\n        - MAILQ_THRESHOLD=${MAILQ_THRESHOLD:-20}\n        - MAILQ_CRIT=${MAILQ_CRIT:-30}\n      networks:\n        mailcow-network:\n          aliases:\n            - watchdog\n\n    dockerapi-mailcow:\n      image: mailcow/dockerapi:2.07\n      security_opt:\n        - label=disable\n      restart: always\n      dns:\n        - ${IPV4_NETWORK:-172.22.1}.254\n      environment:\n        - DBROOT=${DBROOT}\n        - TZ=${TZ}\n        - REDIS_SLAVEOF_IP=${REDIS_SLAVEOF_IP:-}\n        - REDIS_SLAVEOF_PORT=${REDIS_SLAVEOF_PORT:-}\n      volumes:\n        - /var/run/docker.sock:/var/run/docker.sock:ro\n      networks:\n        mailcow-network:\n          aliases:\n            - dockerapi\n\n    \n    ##### Will be removed soon #####\n    solr-mailcow:\n      image: mailcow/solr:1.8.2\n      restart: always\n      volumes:\n        - solr-vol-1:/opt/solr/server/solr/dovecot-fts/data\n      ports:\n        - \"${SOLR_PORT:-127.0.0.1:18983}:8983\"\n      environment:\n        - TZ=${TZ}\n        - SOLR_HEAP=${SOLR_HEAP:-1024}\n        - SKIP_SOLR=${SKIP_SOLR:-y}\n      networks:\n        mailcow-network:\n          aliases:\n            - solr\n    ################################\n\n    olefy-mailcow:\n      image: mailcow/olefy:1.12\n      restart: always\n      environment:\n        - TZ=${TZ}\n        - OLEFY_BINDADDRESS=0.0.0.0\n        - OLEFY_BINDPORT=10055\n        - OLEFY_TMPDIR=/tmp\n        - OLEFY_PYTHON_PATH=/usr/bin/python3\n        - OLEFY_OLEVBA_PATH=/usr/bin/olevba\n        - OLEFY_LOGLVL=20\n        - OLEFY_MINLENGTH=500\n        - OLEFY_DEL_TMP=1\n      networks:\n        mailcow-network:\n          aliases:\n            - olefy\n\n    ofelia-mailcow:\n      image: mcuadros/ofelia:latest\n      restart: always\n      command: daemon --docker\n      environment:\n        - TZ=${TZ}\n      depends_on:\n        - sogo-mailcow\n        - dovecot-mailcow\n      labels:\n        ofelia.enabled: \"true\"\n      security_opt:\n        - label=disable\n      volumes:\n        - /var/run/docker.sock:/var/run/docker.sock:ro\n      networks:\n        mailcow-network:\n          aliases:\n            - ofelia\n\n    ipv6nat-mailcow:\n      depends_on:\n        - unbound-mailcow\n        - mysql-mailcow\n        - redis-mailcow\n        - clamd-mailcow\n        - rspamd-mailcow\n        - php-fpm-mailcow\n        - sogo-mailcow\n        - dovecot-mailcow\n        - postfix-mailcow\n        - memcached-mailcow\n        - nginx-mailcow\n        - acme-mailcow\n        - netfilter-mailcow\n        - watchdog-mailcow\n        - dockerapi-mailcow\n        - solr-mailcow\n      environment:\n        - TZ=${TZ}\n      image: robbertkl/ipv6nat\n      security_opt:\n        - label=disable\n      restart: always\n      privileged: true\n      network_mode: \"host\"\n      volumes:\n        - /var/run/docker.sock:/var/run/docker.sock:ro\n        - /lib/modules:/lib/modules:ro\n\nnetworks:\n  mailcow-network:\n    driver: bridge\n    driver_opts:\n      com.docker.network.bridge.name: br-mailcow\n    enable_ipv6: true\n    ipam:\n      driver: default\n      config:\n        - subnet: ${IPV4_NETWORK:-172.22.1}.0/24\n        - subnet: ${IPV6_NETWORK:-fd4d:6169:6c63:6f77::/64}\n\nvolumes:\n  vmail-vol-1:\n  vmail-index-vol-1:\n  mysql-vol-1:\n  mysql-socket-vol-1:\n  redis-vol-1:\n  rspamd-vol-1:\n  solr-vol-1:\n  postfix-vol-1:\n  crypt-vol-1:\n  sogo-web-vol-1:\n  sogo-userdata-backup-vol-1:\n  clamd-db-vol-1:\n", "#!/usr/bin/env bash\n\nset -o pipefail\n\nif [[ \"$(uname -r)\" =~ ^4\\.15\\.0-60 ]]; then\n  echo \"DO NOT RUN mailcow ON THIS UBUNTU KERNEL!\";\n  echo \"Please update to 5.x or use another distribution.\"\n  exit 1\nfi\n\nif [[ \"$(uname -r)\" =~ ^4\\.4\\. ]]; then\n  if grep -q Ubuntu <<< $(uname -a); then\n    echo \"DO NOT RUN mailcow ON THIS UBUNTU KERNEL!\";\n    echo \"Please update to linux-generic-hwe-16.04 by running \\\"apt-get install --install-recommends linux-generic-hwe-16.04\\\"\"\n    exit 1\n  fi\nfi\n\nif grep --help 2>&1 | head -n 1 | grep -q -i \"busybox\"; then echo \"BusyBox grep detected, please install gnu grep, \\\"apk add --no-cache --upgrade grep\\\"\"; exit 1; fi\n# This will also cover sort\nif cp --help 2>&1 | head -n 1 | grep -q -i \"busybox\"; then echo \"BusyBox cp detected, please install coreutils, \\\"apk add --no-cache --upgrade coreutils\\\"\"; exit 1; fi\nif sed --help 2>&1 | head -n 1 | grep -q -i \"busybox\"; then echo \"BusyBox sed detected, please install gnu sed, \\\"apk add --no-cache --upgrade sed\\\"\"; exit 1; fi\n\nfor bin in openssl curl docker git awk sha1sum grep cut; do\n  if [[ -z $(which ${bin}) ]]; then echo \"Cannot find ${bin}, exiting...\"; exit 1; fi\ndone\n\nif docker compose > /dev/null 2>&1; then\n    if docker compose version --short | grep -e \"^2.\" -e \"^v2.\" > /dev/null 2>&1; then\n      COMPOSE_VERSION=native\n      echo -e \"\\e[33mFound Docker Compose Plugin (native).\\e[0m\"\n      echo -e \"\\e[33mSetting the DOCKER_COMPOSE_VERSION Variable to native\\e[0m\"\n      sleep 2\n      echo -e \"\\e[33mNotice: You\u00b4ll have to update this Compose Version via your Package Manager manually!\\e[0m\"\n    else\n      echo -e \"\\e[31mCannot find Docker Compose with a Version Higher than 2.X.X.\\e[0m\" \n      echo -e \"\\e[31mPlease update/install it manually regarding to this doc site: https://docs.mailcow.email/install/\\e[0m\"\n      exit 1\n    fi\nelif docker-compose > /dev/null 2>&1; then\n  if ! [[ $(alias docker-compose 2> /dev/null) ]] ; then\n    if docker-compose version --short | grep \"^2.\" > /dev/null 2>&1; then\n      COMPOSE_VERSION=standalone\n      echo -e \"\\e[33mFound Docker Compose Standalone.\\e[0m\"\n      echo -e \"\\e[33mSetting the DOCKER_COMPOSE_VERSION Variable to standalone\\e[0m\"\n      sleep 2\n      echo -e \"\\e[33mNotice: For an automatic update of docker-compose please use the update_compose.sh scripts located at the helper-scripts folder.\\e[0m\"\n    else\n      echo -e \"\\e[31mCannot find Docker Compose with a Version Higher than 2.X.X.\\e[0m\" \n      echo -e \"\\e[31mPlease update/install manually regarding to this doc site: https://docs.mailcow.email/install/\\e[0m\"\n      exit 1\n    fi\n  fi\n\nelse\n  echo -e \"\\e[31mCannot find Docker Compose.\\e[0m\" \n  echo -e \"\\e[31mPlease install it regarding to this doc site: https://docs.mailcow.email/install/\\e[0m\"\n  exit 1\nfi\n\ndetect_bad_asn() {\n  echo -e \"\\e[33mDetecting if your IP is listed on Spamhaus Bad ASN List...\\e[0m\"\n  response=$(curl --connect-timeout 15 --max-time 30 -s -o /dev/null -w \"%{http_code}\" \"https://asn-check.mailcow.email\")\n  if [ \"$response\" -eq 503 ]; then\n    if [ -z \"$SPAMHAUS_DQS_KEY\" ]; then\n      echo -e \"\\e[33mYour server's public IP uses an AS that is blocked by Spamhaus to use their DNS public blocklists for Postfix.\\e[0m\"\n      echo -e \"\\e[33mmailcow did not detected a value for the variable SPAMHAUS_DQS_KEY inside mailcow.conf!\\e[0m\"\n      sleep 2\n      echo \"\"\n      echo -e \"\\e[33mTo use the Spamhaus DNS Blocklists again, you will need to create a FREE account for their Data Query Service (DQS) at: https://www.spamhaus.com/free-trial/sign-up-for-a-free-data-query-service-account\\e[0m\"\n      echo -e \"\\e[33mOnce done, enter your DQS API key in mailcow.conf and mailcow will do the rest for you!\\e[0m\"\n      echo \"\"\n      sleep 2\n\n    else\n      echo -e \"\\e[33mYour server's public IP uses an AS that is blocked by Spamhaus to use their DNS public blocklists for Postfix.\\e[0m\"\n      echo -e \"\\e[32mmailcow detected a Value for the variable SPAMHAUS_DQS_KEY inside mailcow.conf. Postfix will use DQS with the given API key...\\e[0m\"\n    fi\n  elif [ \"$response\" -eq 200 ]; then\n    echo -e \"\\e[33mCheck completed! Your IP is \\e[32mclean\\e[0m\"\n  elif [ \"$response\" -eq 429 ]; then\n    echo -e \"\\e[33mCheck completed! \\e[31mYour IP seems to be rate limited on the ASN Check service... please try again later!\\e[0m\"\n  else\n    echo -e \"\\e[31mCheck failed! \\e[0mMaybe a DNS or Network problem?\\e[0m\"\n  fi\n}\n\n### If generate_config.sh is started with --dev or -d it will not check out nightly or master branch and will keep on the current branch\nif [[ ${1} == \"--dev\" || ${1} == \"-d\" ]]; then\n  SKIP_BRANCH=y\nelse\n  SKIP_BRANCH=n\nfi\n\nif [ -f mailcow.conf ]; then\n  read -r -p \"A config file exists and will be overwritten, are you sure you want to continue? [y/N] \" response\n  case $response in\n    [yY][eE][sS]|[yY])\n      mv mailcow.conf mailcow.conf_backup\n      chmod 600 mailcow.conf_backup\n      ;;\n    *)\n      exit 1\n    ;;\n  esac\nfi\n\necho \"Press enter to confirm the detected value '[value]' where applicable or enter a custom value.\"\nwhile [ -z \"${MAILCOW_HOSTNAME}\" ]; do\n  read -p \"Mail server hostname (FQDN) - this is not your mail domain, but your mail servers hostname: \" -e MAILCOW_HOSTNAME\n  DOTS=${MAILCOW_HOSTNAME//[^.]};\n  if [ ${#DOTS} -lt 1 ]; then\n    echo -e \"\\e[31mMAILCOW_HOSTNAME (${MAILCOW_HOSTNAME}) is not a FQDN!\\e[0m\"\n    sleep 1\n    echo \"Please change it to a FQDN and redeploy the stack with docker(-)compose up -d\"\n    exit 1\n  elif [[ \"${MAILCOW_HOSTNAME: -1}\" == \".\" ]]; then\n    echo \"MAILCOW_HOSTNAME (${MAILCOW_HOSTNAME}) is ending with a dot. This is not a valid FQDN!\"\n    exit 1\n  elif [ ${#DOTS} -eq 1 ]; then\n    echo -e \"\\e[33mMAILCOW_HOSTNAME (${MAILCOW_HOSTNAME}) does not contain a Subdomain. This is not fully tested and may cause issues.\\e[0m\"\n    echo \"Find more information about why this message exists here: https://github.com/mailcow/mailcow-dockerized/issues/1572\"\n    read -r -p \"Do you want to proceed anyway? [y/N] \" response\n    if [[ \"$response\" =~ ^([yY][eE][sS]|[yY])+$ ]]; then\n      echo \"OK. Procceding.\"\n    else\n      echo \"OK. Exiting.\"\n      exit 1\n    fi\n  fi\ndone\n\nif [ -a /etc/timezone ]; then\n  DETECTED_TZ=$(cat /etc/timezone)\nelif [ -a /etc/localtime ]; then\n  DETECTED_TZ=$(readlink /etc/localtime|sed -n 's|^.*zoneinfo/||p')\nfi\n\nwhile [ -z \"${MAILCOW_TZ}\" ]; do\n  if [ -z \"${DETECTED_TZ}\" ]; then\n    read -p \"Timezone: \" -e MAILCOW_TZ\n  else\n    read -p \"Timezone [${DETECTED_TZ}]: \" -e MAILCOW_TZ\n    [ -z \"${MAILCOW_TZ}\" ] && MAILCOW_TZ=${DETECTED_TZ}\n  fi\ndone\n\nMEM_TOTAL=$(awk '/MemTotal/ {print $2}' /proc/meminfo)\n\nif [ ${MEM_TOTAL} -le \"2621440\" ]; then\n  echo \"Installed memory is <= 2.5 GiB. It is recommended to disable ClamAV to prevent out-of-memory situations.\"\n  echo \"ClamAV can be re-enabled by setting SKIP_CLAMD=n in mailcow.conf.\"\n  read -r -p  \"Do you want to disable ClamAV now? [Y/n] \" response\n  case $response in\n    [nN][oO]|[nN])\n      SKIP_CLAMD=n\n      ;;\n    *)\n      SKIP_CLAMD=y\n    ;;\n  esac\nelse\n  SKIP_CLAMD=n\nfi\n\nif [ ${MEM_TOTAL} -le \"2097152\" ]; then\n  echo \"Disabling Solr on low-memory system.\"\n  SKIP_SOLR=y\nelif [ ${MEM_TOTAL} -le \"3670016\" ]; then\n  echo \"Installed memory is <= 3.5 GiB. It is recommended to disable Solr to prevent out-of-memory situations.\"\n  echo \"Solr is a prone to run OOM and should be monitored. The default Solr heap size is 1024 MiB and should be set in mailcow.conf according to your expected load.\"\n  echo \"Solr can be re-enabled by setting SKIP_SOLR=n in mailcow.conf but will refuse to start with less than 2 GB total memory.\"\n  read -r -p  \"Do you want to disable Solr now? [Y/n] \" response\n  case $response in\n    [nN][oO]|[nN])\n      SKIP_SOLR=n\n      ;;\n    *)\n      SKIP_SOLR=y\n    ;;\n  esac\nelse\n  SKIP_SOLR=n\nfi\n\nif [[ ${SKIP_BRANCH} != y ]]; then\n  echo \"Which branch of mailcow do you want to use?\"\n  echo \"\"\n  echo \"Available Branches:\"\n  echo \"- master branch (stable updates) | default, recommended [1]\"\n  echo \"- nightly branch (unstable updates, testing) | not-production ready [2]\"\n  sleep 1\n\n  while [ -z \"${MAILCOW_BRANCH}\" ]; do\n    read -r -p  \"Choose the Branch with it\u00b4s number [1/2] \" branch\n    case $branch in\n      [2])\n        MAILCOW_BRANCH=\"nightly\"\n        ;;\n      *)\n        MAILCOW_BRANCH=\"master\"\n      ;;\n    esac\n  done\n\n  git fetch --all\n  git checkout -f $MAILCOW_BRANCH\n\nelif [[ ${SKIP_BRANCH} == y ]]; then\n  echo -e \"\\033[33mEnabled Dev Mode.\\033[0m\"\n  echo -e \"\\033[33mNot checking out a different branch!\\033[0m\"\n  MAILCOW_BRANCH=$(git rev-parse --short $(git rev-parse @{upstream}))\n\nelse\n  echo -e \"\\033[31mCould not determine branch input...\"\n  echo -e \"\\033[31mExiting.\"\n  exit 1\nfi  \n\nif [ ! -z \"${MAILCOW_BRANCH}\" ]; then\n  git_branch=${MAILCOW_BRANCH}\nfi\n\n[ ! -f ./data/conf/rspamd/override.d/worker-controller-password.inc ] && echo '# Placeholder' > ./data/conf/rspamd/override.d/worker-controller-password.inc\n\ncat << EOF > mailcow.conf\n# ------------------------------\n# mailcow web ui configuration\n# ------------------------------\n# example.org is _not_ a valid hostname, use a fqdn here.\n# Default admin user is \"admin\"\n# Default password is \"moohoo\"\n\nMAILCOW_HOSTNAME=${MAILCOW_HOSTNAME}\n\n# Password hash algorithm\n# Only certain password hash algorithm are supported. For a fully list of supported schemes,\n# see https://docs.mailcow.email/models/model-passwd/\nMAILCOW_PASS_SCHEME=BLF-CRYPT\n\n# ------------------------------\n# SQL database configuration\n# ------------------------------\n\nDBNAME=mailcow\nDBUSER=mailcow\n\n# Please use long, random alphanumeric strings (A-Za-z0-9)\n\nDBPASS=$(LC_ALL=C </dev/urandom tr -dc A-Za-z0-9 2> /dev/null | head -c 28)\nDBROOT=$(LC_ALL=C </dev/urandom tr -dc A-Za-z0-9 2> /dev/null | head -c 28)\n\n# ------------------------------\n# HTTP/S Bindings\n# ------------------------------\n\n# You should use HTTPS, but in case of SSL offloaded reverse proxies:\n# Might be important: This will also change the binding within the container.\n# If you use a proxy within Docker, point it to the ports you set below.\n# Do _not_ use IP:PORT in HTTP(S)_BIND or HTTP(S)_PORT\n# IMPORTANT: Do not use port 8081, 9081 or 65510!\n# Example: HTTP_BIND=1.2.3.4\n# For IPv4 leave it as it is: HTTP_BIND= & HTTPS_PORT=\n# For IPv6 see https://docs.mailcow.email/post_installation/firststeps-ip_bindings/\n\nHTTP_PORT=80\nHTTP_BIND=\n\nHTTPS_PORT=443\nHTTPS_BIND=\n\n# ------------------------------\n# Other bindings\n# ------------------------------\n# You should leave that alone\n# Format: 11.22.33.44:25 or 12.34.56.78:465 etc.\n\nSMTP_PORT=25\nSMTPS_PORT=465\nSUBMISSION_PORT=587\nIMAP_PORT=143\nIMAPS_PORT=993\nPOP_PORT=110\nPOPS_PORT=995\nSIEVE_PORT=4190\nDOVEADM_PORT=127.0.0.1:19991\nSQL_PORT=127.0.0.1:13306\nSOLR_PORT=127.0.0.1:18983\nREDIS_PORT=127.0.0.1:7654\n\n# Your timezone\n# See https://en.wikipedia.org/wiki/List_of_tz_database_time_zones for a list of timezones\n# Use the column named 'TZ identifier' + pay attention for the column named 'Notes'\n\nTZ=${MAILCOW_TZ}\n\n# Fixed project name\n# Please use lowercase letters only\n\nCOMPOSE_PROJECT_NAME=mailcowdockerized\n\n# Used Docker Compose version\n# Switch here between native (compose plugin) and standalone\n# For more informations take a look at the mailcow docs regarding the configuration options.\n# Normally this should be untouched but if you decided to use either of those you can switch it manually here.\n# Please be aware that at least one of those variants should be installed on your machine or mailcow will fail.\n\nDOCKER_COMPOSE_VERSION=${COMPOSE_VERSION}\n\n# Set this to \"allow\" to enable the anyone pseudo user. Disabled by default.\n# When enabled, ACL can be created, that apply to \"All authenticated users\"\n# This should probably only be activated on mail hosts, that are used exclusivly by one organisation.\n# Otherwise a user might share data with too many other users.\nACL_ANYONE=disallow\n\n# Garbage collector cleanup\n# Deleted domains and mailboxes are moved to /var/vmail/_garbage/timestamp_sanitizedstring\n# How long should objects remain in the garbage until they are being deleted? (value in minutes)\n# Check interval is hourly\n\nMAILDIR_GC_TIME=7200\n\n# Additional SAN for the certificate\n#\n# You can use wildcard records to create specific names for every domain you add to mailcow.\n# Example: Add domains \"example.com\" and \"example.net\" to mailcow, change ADDITIONAL_SAN to a value like:\n#ADDITIONAL_SAN=imap.*,smtp.*\n# This will expand the certificate to \"imap.example.com\", \"smtp.example.com\", \"imap.example.net\", \"smtp.example.net\"\n# plus every domain you add in the future.\n#\n# You can also just add static names...\n#ADDITIONAL_SAN=srv1.example.net\n# ...or combine wildcard and static names:\n#ADDITIONAL_SAN=imap.*,srv1.example.com\n#\n\nADDITIONAL_SAN=\n\n# Additional server names for mailcow UI\n#\n# Specify alternative addresses for the mailcow UI to respond to\n# This is useful when you set mail.* as ADDITIONAL_SAN and want to make sure mail.maildomain.com will always point to the mailcow UI.\n# If the server name does not match a known site, Nginx decides by best-guess and may redirect users to the wrong web root.\n# You can understand this as server_name directive in Nginx.\n# Comma separated list without spaces! Example: ADDITIONAL_SERVER_NAMES=a.b.c,d.e.f\n\nADDITIONAL_SERVER_NAMES=\n\n# Skip running ACME (acme-mailcow, Let's Encrypt certs) - y/n\n\nSKIP_LETS_ENCRYPT=n\n\n# Create seperate certificates for all domains - y/n\n# this will allow adding more than 100 domains, but some email clients will not be able to connect with alternative hostnames\n# see https://doc.dovecot.org/admin_manual/ssl/sni_support\nENABLE_SSL_SNI=n\n\n# Skip IPv4 check in ACME container - y/n\n\nSKIP_IP_CHECK=n\n\n# Skip HTTP verification in ACME container - y/n\n\nSKIP_HTTP_VERIFICATION=n\n\n# Skip Unbound (DNS Resolver) Healthchecks (NOT Recommended!) - y/n\n\nSKIP_UNBOUND_HEALTHCHECK=n\n\n# Skip ClamAV (clamd-mailcow) anti-virus (Rspamd will auto-detect a missing ClamAV container) - y/n\n\nSKIP_CLAMD=${SKIP_CLAMD}\n\n# Skip SOGo: Will disable SOGo integration and therefore webmail, DAV protocols and ActiveSync support (experimental, unsupported, not fully implemented) - y/n\n\nSKIP_SOGO=n\n\n# Skip Solr on low-memory systems or if you do not want to store a readable index of your mails in solr-vol-1.\n\nSKIP_SOLR=${SKIP_SOLR}\n\n# Solr heap size in MB, there is no recommendation, please see Solr docs.\n# Solr is a prone to run OOM and should be monitored. Unmonitored Solr setups are not recommended.\n\nSOLR_HEAP=1024\n\n# Allow admins to log into SOGo as email user (without any password)\n\nALLOW_ADMIN_EMAIL_LOGIN=n\n\n# Enable watchdog (watchdog-mailcow) to restart unhealthy containers\n\nUSE_WATCHDOG=y\n\n# Send watchdog notifications by mail (sent from watchdog@MAILCOW_HOSTNAME)\n# CAUTION:\n# 1. You should use external recipients\n# 2. Mails are sent unsigned (no DKIM)\n# 3. If you use DMARC, create a separate DMARC policy (\"v=DMARC1; p=none;\" in _dmarc.MAILCOW_HOSTNAME)\n# Multiple rcpts allowed, NO quotation marks, NO spaces\n\n#WATCHDOG_NOTIFY_EMAIL=a@example.com,b@example.com,c@example.com\n#WATCHDOG_NOTIFY_EMAIL=\n\n# Send notifications to a webhook URL that receives a POST request with the content type \"application/json\".\n# You can use this to send notifications to services like Discord, Slack and others.\n#WATCHDOG_NOTIFY_WEBHOOK=https://discord.com/api/webhooks/XXXXXXXXXXXXXXXXXXX/XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n# JSON body included in the webhook POST request. Needs to be in single quotes.\n# Following variables are available: SUBJECT, BODY\n#WATCHDOG_NOTIFY_WEBHOOK_BODY='{\"username\": \"mailcow Watchdog\", \"content\": \"**${SUBJECT}**\\n${BODY}\"}'\n\n# Notify about banned IP (includes whois lookup)\nWATCHDOG_NOTIFY_BAN=n\n\n# Send a notification when the watchdog is started.\nWATCHDOG_NOTIFY_START=y\n\n# Subject for watchdog mails. Defaults to \"Watchdog ALERT\" followed by the error message.\n#WATCHDOG_SUBJECT=\n\n# Checks if mailcow is an open relay. Requires a SAL. More checks will follow.\n# https://www.servercow.de/mailcow?lang=en\n# https://www.servercow.de/mailcow?lang=de\n# No data is collected. Opt-in and anonymous.\n# Will only work with unmodified mailcow setups.\nWATCHDOG_EXTERNAL_CHECKS=n\n\n# Enable watchdog verbose logging\nWATCHDOG_VERBOSE=n\n\n# Max log lines per service to keep in Redis logs\n\nLOG_LINES=9999\n\n# Internal IPv4 /24 subnet, format n.n.n (expands to n.n.n.0/24)\n# Use private IPv4 addresses only, see https://en.wikipedia.org/wiki/Private_network#Private_IPv4_addresses\n\nIPV4_NETWORK=172.22.1\n\n# Internal IPv6 subnet in fc00::/7\n# Use private IPv6 addresses only, see https://en.wikipedia.org/wiki/Private_network#Private_IPv6_addresses\n\nIPV6_NETWORK=fd4d:6169:6c63:6f77::/64\n\n# Use this IPv4 for outgoing connections (SNAT)\n\n#SNAT_TO_SOURCE=\n\n# Use this IPv6 for outgoing connections (SNAT)\n\n#SNAT6_TO_SOURCE=\n\n# Create or override an API key for the web UI\n# You _must_ define API_ALLOW_FROM, which is a comma separated list of IPs\n# An API key defined as API_KEY has read-write access\n# An API key defined as API_KEY_READ_ONLY has read-only access\n# Allowed chars for API_KEY and API_KEY_READ_ONLY: a-z, A-Z, 0-9, -\n# You can define API_KEY and/or API_KEY_READ_ONLY\n\n#API_KEY=\n#API_KEY_READ_ONLY=\n#API_ALLOW_FROM=172.22.1.1,127.0.0.1\n\n# mail_home is ~/Maildir\nMAILDIR_SUB=Maildir\n\n# SOGo session timeout in minutes\nSOGO_EXPIRE_SESSION=480\n\n# DOVECOT_MASTER_USER and DOVECOT_MASTER_PASS must both be provided. No special chars.\n# Empty by default to auto-generate master user and password on start.\n# User expands to DOVECOT_MASTER_USER@mailcow.local\n# LEAVE EMPTY IF UNSURE\nDOVECOT_MASTER_USER=\n# LEAVE EMPTY IF UNSURE\nDOVECOT_MASTER_PASS=\n\n# Let's Encrypt registration contact information\n# Optional: Leave empty for none\n# This value is only used on first order!\n# Setting it at a later point will require the following steps:\n# https://docs.mailcow.email/troubleshooting/debug-reset_tls/\nACME_CONTACT=\n\n# WebAuthn device manufacturer verification\n# After setting WEBAUTHN_ONLY_TRUSTED_VENDORS=y only devices from trusted manufacturers are allowed\n# root certificates can be placed for validation under mailcow-dockerized/data/web/inc/lib/WebAuthn/rootCertificates\nWEBAUTHN_ONLY_TRUSTED_VENDORS=n\n\n# Spamhaus Data Query Service Key\n# Optional: Leave empty for none\n# Enter your key here if you are using a blocked ASN (OVH, AWS, Cloudflare e.g) for the unregistered Spamhaus Blocklist. \n# If empty, it will completely disable Spamhaus blocklists if it detects that you are running on a server using a blocked AS.\n# Otherwise it will work normally.\nSPAMHAUS_DQS_KEY=\n\nEOF\n\nmkdir -p data/assets/ssl\n\nchmod 600 mailcow.conf\n\n# copy but don't overwrite existing certificate\necho \"Generating snake-oil certificate...\"\n# Making Willich more popular\nopenssl req -x509 -newkey rsa:4096 -keyout data/assets/ssl-example/key.pem -out data/assets/ssl-example/cert.pem -days 365 -subj \"/C=DE/ST=NRW/L=Willich/O=mailcow/OU=mailcow/CN=${MAILCOW_HOSTNAME}\" -sha256 -nodes\necho \"Copying snake-oil certificate...\"\ncp -n -d data/assets/ssl-example/*.pem data/assets/ssl/\n\n# Set app_info.inc.php\ncase ${git_branch} in\n  master)\n    mailcow_git_version=$(git describe --tags `git rev-list --tags --max-count=1`)\n    ;;\n  nightly)\n    mailcow_git_version=$(git rev-parse --short $(git rev-parse @{upstream}))\n    mailcow_last_git_version=\"\"\n    ;;\n  *)\n    mailcow_git_version=$(git rev-parse --short HEAD)\n    mailcow_last_git_version=\"\"\n    ;;\nesac\n# if [ ${git_branch} == \"master\" ]; then\n#   mailcow_git_version=$(git describe --tags `git rev-list --tags --max-count=1`)\n# elif [ ${git_branch} == \"nightly\" ]; then\n#   mailcow_git_version=$(git rev-parse --short $(git rev-parse @{upstream}))\n#   mailcow_last_git_version=\"\"\n# else\n#   mailcow_git_version=$(git rev-parse --short HEAD)\n#   mailcow_last_git_version=\"\"\n# fi\n\nif [[ $SKIP_BRANCH != \"y\" ]]; then\nmailcow_git_commit=$(git rev-parse origin/${git_branch})\nmailcow_git_commit_date=$(git log -1 --format=%ci @{upstream} )\nelse\nmailcow_git_commit=$(git rev-parse ${git_branch})\nmailcow_git_commit_date=$(git log -1 --format=%ci @{upstream} )\ngit_branch=$(git rev-parse --abbrev-ref HEAD)\nfi\n\nif [ $? -eq 0 ]; then\n  echo '<?php' > data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_GIT_VERSION=\"'$mailcow_git_version'\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_LAST_GIT_VERSION=\"\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_GIT_OWNER=\"mailcow\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_GIT_REPO=\"mailcow-dockerized\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_GIT_URL=\"https://github.com/mailcow/mailcow-dockerized\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_GIT_COMMIT=\"'$mailcow_git_commit'\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_GIT_COMMIT_DATE=\"'$mailcow_git_commit_date'\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_BRANCH=\"'$git_branch'\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_UPDATEDAT='$(date +%s)';' >> data/web/inc/app_info.inc.php\n  echo '?>' >> data/web/inc/app_info.inc.php\nelse\n  echo '<?php' > data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_GIT_VERSION=\"'$mailcow_git_version'\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_LAST_GIT_VERSION=\"\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_GIT_OWNER=\"mailcow\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_GIT_REPO=\"mailcow-dockerized\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_GIT_URL=\"https://github.com/mailcow/mailcow-dockerized\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_GIT_COMMIT=\"\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_GIT_COMMIT_DATE=\"\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_BRANCH=\"'$git_branch'\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_UPDATEDAT='$(date +%s)';' >> data/web/inc/app_info.inc.php\n  echo '?>' >> data/web/inc/app_info.inc.php\n  echo -e \"\\e[33mCannot determine current git repository version...\\e[0m\"\nfi\n\ndetect_bad_asn\n", "#!/usr/bin/env bash\n\n############## Begin Function Section ##############\n\ncheck_online_status() {\n  CHECK_ONLINE_DOMAINS=('https://github.com' 'https://hub.docker.com')\n  for domain in \"${CHECK_ONLINE_DOMAINS[@]}\"; do\n    if timeout 6 curl --head --silent --output /dev/null ${domain}; then\n      return 0\n    fi\n  done\n  return 1\n}\n\nprefetch_images() {\n  [[ -z ${BRANCH} ]] && { echo -e \"\\e[33m\\nUnknown branch...\\e[0m\"; exit 1; }\n  git fetch origin #${BRANCH}\n  while read image; do\n    if [[ \"${image}\" == \"robbertkl/ipv6nat\" ]]; then\n      if ! grep -qi \"ipv6nat-mailcow\" docker-compose.yml || grep -qi \"enable_ipv6: false\" docker-compose.yml; then\n        continue\n      fi\n    fi\n    RET_C=0\n    until docker pull ${image}; do\n      RET_C=$((RET_C + 1))\n      echo -e \"\\e[33m\\nError pulling $image, retrying...\\e[0m\"\n      [ ${RET_C} -gt 3 ] && { echo -e \"\\e[31m\\nToo many failed retries, exiting\\e[0m\"; exit 1; }\n      sleep 1\n    done\n  done < <(git show origin/${BRANCH}:docker-compose.yml | grep \"image:\" | awk '{ gsub(\"image:\",\"\", $3); print $2 }')\n}\n\ndocker_garbage() {\n  SCRIPT_DIR=\"$( cd \"$( dirname \"${BASH_SOURCE[0]}\" )\" && pwd )\"\n  IMGS_TO_DELETE=()\n\n  declare -A IMAGES_INFO\n  COMPOSE_IMAGES=($(grep -oP \"image: \\Kmailcow.+\" \"${SCRIPT_DIR}/docker-compose.yml\"))\n\n  for existing_image in $(docker images --format \"{{.ID}}:{{.Repository}}:{{.Tag}}\" | grep 'mailcow/'); do\n      ID=$(echo $existing_image | cut -d ':' -f 1)\n      REPOSITORY=$(echo $existing_image | cut -d ':' -f 2)\n      TAG=$(echo $existing_image | cut -d ':' -f 3)\n\n      if [[ \" ${COMPOSE_IMAGES[@]} \" =~ \" ${REPOSITORY}:${TAG} \" ]]; then\n          continue\n      else\n          IMGS_TO_DELETE+=(\"$ID\")\n          IMAGES_INFO[\"$ID\"]=\"$REPOSITORY:$TAG\"\n      fi\n  done\n\n  if [[ ! -z ${IMGS_TO_DELETE[*]} ]]; then\n      echo \"The following unused mailcow images were found:\"\n      for id in \"${IMGS_TO_DELETE[@]}\"; do\n          echo \"    ${IMAGES_INFO[$id]} ($id)\"\n      done\n\n      if [ ! $FORCE ]; then\n          read -r -p \"Do you want to delete them to free up some space? [y/N] \" response\n          if [[ \"$response\" =~ ^([yY][eE][sS]|[yY])+$ ]]; then\n              docker rmi ${IMGS_TO_DELETE[*]}\n          else\n              echo \"OK, skipped.\"\n          fi\n      else\n          echo \"Running in forced mode! Force removing old mailcow images...\"\n          docker rmi ${IMGS_TO_DELETE[*]}\n      fi\n      echo -e \"\\e[32mFurther cleanup...\\e[0m\"\n      echo \"If you want to cleanup further garbage collected by Docker, please make sure all containers are up and running before cleaning your system by executing \\\"docker system prune\\\"\"\n  fi\n}\n\nin_array() {\n  local e match=\"$1\"\n  shift\n  for e; do [[ \"$e\" == \"$match\" ]] && return 0; done\n  return 1\n}\n\nmigrate_docker_nat() {\n  NAT_CONFIG='{\"ipv6\":true,\"fixed-cidr-v6\":\"fd00:dead:beef:c0::/80\",\"experimental\":true,\"ip6tables\":true}'\n  # Min Docker version\n  DOCKERV_REQ=20.10.2\n  # Current Docker version\n  DOCKERV_CUR=$(docker version -f '{{.Server.Version}}')\n  if grep -qi \"ipv6nat-mailcow\" docker-compose.yml && grep -qi \"enable_ipv6: true\" docker-compose.yml; then\n    echo -e \"\\e[32mNative IPv6 implementation available.\\e[0m\"\n    echo \"This will enable experimental features in the Docker daemon and configure Docker to do the IPv6 NATing instead of ipv6nat-mailcow.\"\n    echo '!!! This step is recommended !!!'\n    echo \"mailcow will try to roll back the changes if starting Docker fails after modifying the daemon.json configuration file.\"\n    read -r -p \"Should we try to enable the native IPv6 implementation in Docker now (recommended)? [y/N] \" dockernatresponse\n    if [[ ! \"${dockernatresponse}\" =~ ^([yY][eE][sS]|[yY])+$ ]]; then\n      echo \"OK, skipping this step.\"\n      return 0\n    fi\n  fi\n  # Sort versions and check if we are running a newer or equal version to req\n  if [ $(printf \"${DOCKERV_REQ}\\n${DOCKERV_CUR}\" | sort -V | tail -n1) == \"${DOCKERV_CUR}\" ]; then\n    # If Dockerd daemon json exists\n    if [ -s /etc/docker/daemon.json ]; then\n      IFS=',' read -r -a dockerconfig <<< $(cat /etc/docker/daemon.json | tr -cd '[:alnum:],')\n      if ! in_array ipv6true \"${dockerconfig[@]}\" || \\\n        ! in_array experimentaltrue \"${dockerconfig[@]}\" || \\\n        ! in_array ip6tablestrue \"${dockerconfig[@]}\" || \\\n        ! grep -qi \"fixed-cidr-v6\" /etc/docker/daemon.json; then\n          echo -e \"\\e[33mWarning:\\e[0m You seem to have modified the /etc/docker/daemon.json configuration by yourself and not fully/correctly activated the native IPv6 NAT implementation.\"\n          echo \"You will need to merge your existing configuration manually or fix/delete the existing daemon.json configuration before trying the update process again.\"\n          echo -e \"Please merge the following content and restart the Docker daemon:\\n\"\n          echo ${NAT_CONFIG}\n          return 1\n      fi\n    else\n      echo \"Working on IPv6 NAT, please wait...\"\n      echo ${NAT_CONFIG} > /etc/docker/daemon.json\n      ip6tables -F -t nat\n      [[ -e /etc/rc.conf ]] && rc-service docker restart || systemctl restart docker.service\n      if [[ $? -ne 0 ]]; then\n        echo -e \"\\e[31mError:\\e[0m Failed to activate IPv6 NAT! Reverting and exiting.\"\n        rm /etc/docker/daemon.json\n        if [[ -e /etc/rc.conf ]]; then\n          rc-service docker restart\n        else\n          systemctl reset-failed docker.service\n          systemctl restart docker.service\n        fi\n        return 1\n      fi\n    fi\n    # Removing legacy container\n    sed -i '/ipv6nat-mailcow:$/,/^$/d' docker-compose.yml\n    if [ -s docker-compose.override.yml ]; then\n        sed -i '/ipv6nat-mailcow:$/,/^$/d' docker-compose.override.yml\n        if [[ \"$(cat docker-compose.override.yml | sed '/^\\s*$/d' | wc -l)\" == \"2\" ]]; then\n            mv docker-compose.override.yml docker-compose.override.yml_backup\n        fi\n    fi\n    echo -e \"\\e[32mGreat! \\e[0mNative IPv6 NAT is active.\\e[0m\"\n  else\n    echo -e \"\\e[31mPlease upgrade Docker to version ${DOCKERV_REQ} or above.\\e[0m\"\n    return 0\n  fi\n}\n\nremove_obsolete_nginx_ports() {\n    # Removing obsolete docker-compose.override.yml\n    for override in docker-compose.override.yml docker-compose.override.yaml; do\n    if [ -s $override ] ; then\n        if cat $override | grep nginx-mailcow > /dev/null 2>&1; then\n          if cat $override | grep -E '(\\[::])' > /dev/null 2>&1; then\n            if cat $override | grep -w 80:80 > /dev/null 2>&1 && cat $override | grep -w 443:443 > /dev/null 2>&1 ; then\n              echo -e \"\\e[33mBacking up ${override} to preserve custom changes...\\e[0m\"\n              echo -e \"\\e[33m!!! Manual Merge needed (if other overrides are set) !!!\\e[0m\"\n              sleep 3\n              cp $override ${override}_backup\n              sed -i '/nginx-mailcow:$/,/^$/d' $override\n              echo -e \"\\e[33mRemoved obsolete NGINX IPv6 Bind from original override File.\\e[0m\"\n                if [[ \"$(cat $override | sed '/^\\s*$/d' | wc -l)\" == \"2\" ]]; then\n                  mv $override ${override}_empty\n                  echo -e \"\\e[31m${override} is empty. Renamed it to ensure mailcow is startable.\\e[0m\"\n                fi\n            fi\n          fi\n        fi\n    fi\n    done        \n}\n\ndetect_docker_compose_command(){\nif ! [[ \"${DOCKER_COMPOSE_VERSION}\" =~ ^(native|standalone)$ ]]; then\n  if docker compose > /dev/null 2>&1; then\n      if docker compose version --short | grep -e \"^2.\" -e \"^v2.\" > /dev/null 2>&1; then\n        DOCKER_COMPOSE_VERSION=native\n        COMPOSE_COMMAND=\"docker compose\"\n        echo -e \"\\e[33mFound Docker Compose Plugin (native).\\e[0m\"\n        echo -e \"\\e[33mSetting the DOCKER_COMPOSE_VERSION Variable to native\\e[0m\"\n        sed -i 's/^DOCKER_COMPOSE_VERSION=.*/DOCKER_COMPOSE_VERSION=native/' $SCRIPT_DIR/mailcow.conf \n        sleep 2\n        echo -e \"\\e[33mNotice: You'll have to update this Compose Version via your Package Manager manually!\\e[0m\"\n      else\n        echo -e \"\\e[31mCannot find Docker Compose with a Version Higher than 2.X.X.\\e[0m\" \n        echo -e \"\\e[31mPlease update/install it manually regarding to this doc site: https://docs.mailcow.email/install/\\e[0m\"\n        exit 1\n      fi\n  elif docker-compose > /dev/null 2>&1; then\n    if ! [[ $(alias docker-compose 2> /dev/null) ]] ; then\n      if docker-compose version --short | grep \"^2.\" > /dev/null 2>&1; then\n        DOCKER_COMPOSE_VERSION=standalone\n        COMPOSE_COMMAND=\"docker-compose\"\n        echo -e \"\\e[33mFound Docker Compose Standalone.\\e[0m\"\n        echo -e \"\\e[33mSetting the DOCKER_COMPOSE_VERSION Variable to standalone\\e[0m\"\n        sed -i 's/^DOCKER_COMPOSE_VERSION=.*/DOCKER_COMPOSE_VERSION=standalone/' $SCRIPT_DIR/mailcow.conf\n        sleep 2\n        echo -e \"\\e[33mNotice: For an automatic update of docker-compose please use the update_compose.sh scripts located at the helper-scripts folder.\\e[0m\"\n      else\n        echo -e \"\\e[31mCannot find Docker Compose with a Version Higher than 2.X.X.\\e[0m\" \n        echo -e \"\\e[31mPlease update/install regarding to this doc site: https://docs.mailcow.email/install/\\e[0m\"\n        exit 1\n      fi\n    fi\n\n  else\n    echo -e \"\\e[31mCannot find Docker Compose.\\e[0m\" \n    echo -e \"\\e[31mPlease install it regarding to this doc site: https://docs.mailcow.email/install/\\e[0m\"\n    exit 1\n  fi\n\nelif [ \"${DOCKER_COMPOSE_VERSION}\" == \"native\" ]; then\n  COMPOSE_COMMAND=\"docker compose\"\n  # Check if Native Compose works and has not been deleted  \n  if ! $COMPOSE_COMMAND > /dev/null 2>&1; then\n    # IF it not exists/work anymore try the other command\n    COMPOSE_COMMAND=\"docker-compose\"\n    if ! $COMPOSE_COMMAND > /dev/null 2>&1 || ! $COMPOSE_COMMAND --version | grep \"^2.\" > /dev/null 2>&1; then\n      # IF it cannot find Standalone in > 2.X, then script stops\n      echo -e \"\\e[31mCannot find Docker Compose or the Version is lower then 2.X.X.\\e[0m\" \n      echo -e \"\\e[31mPlease install it regarding to this doc site: https://docs.mailcow.email/install/\\e[0m\"\n      exit 1\n    fi\n      # If it finds the standalone Plugin it will use this instead and change the mailcow.conf Variable accordingly\n      echo -e \"\\e[31mFound different Docker Compose Version then declared in mailcow.conf!\\e[0m\"\n      echo -e \"\\e[31mSetting the DOCKER_COMPOSE_VERSION Variable from native to standalone\\e[0m\"\n      sed -i 's/^DOCKER_COMPOSE_VERSION=.*/DOCKER_COMPOSE_VERSION=standalone/' $SCRIPT_DIR/mailcow.conf \n      sleep 2\n  fi\n\n\nelif [ \"${DOCKER_COMPOSE_VERSION}\" == \"standalone\" ]; then\n  COMPOSE_COMMAND=\"docker-compose\"\n  # Check if Standalone Compose works and has not been deleted  \n  if ! $COMPOSE_COMMAND > /dev/null 2>&1 && ! $COMPOSE_COMMAND --version > /dev/null 2>&1 | grep \"^2.\" > /dev/null 2>&1; then\n    # IF it not exists/work anymore try the other command\n    COMPOSE_COMMAND=\"docker compose\"\n    if ! $COMPOSE_COMMAND > /dev/null 2>&1; then\n      # IF it cannot find Native in > 2.X, then script stops\n      echo -e \"\\e[31mCannot find Docker Compose.\\e[0m\" \n      echo -e \"\\e[31mPlease install it regarding to this doc site: https://docs.mailcow.email/install/\\e[0m\"\n      exit 1\n    fi\n      # If it finds the native Plugin it will use this instead and change the mailcow.conf Variable accordingly\n      echo -e \"\\e[31mFound different Docker Compose Version then declared in mailcow.conf!\\e[0m\"\n      echo -e \"\\e[31mSetting the DOCKER_COMPOSE_VERSION Variable from standalone to native\\e[0m\"\n      sed -i 's/^DOCKER_COMPOSE_VERSION=.*/DOCKER_COMPOSE_VERSION=native/' $SCRIPT_DIR/mailcow.conf \n      sleep 2\n  fi\nfi\n}\n\ndetect_bad_asn() {\n  echo -e \"\\e[33mDetecting if your IP is listed on Spamhaus Bad ASN List...\\e[0m\"\n  response=$(curl --connect-timeout 15 --max-time 30 -s -o /dev/null -w \"%{http_code}\" \"https://asn-check.mailcow.email\")\n  if [ \"$response\" -eq 503 ]; then\n    if [ -z \"$SPAMHAUS_DQS_KEY\" ]; then\n      echo -e \"\\e[33mYour server's public IP uses an AS that is blocked by Spamhaus to use their DNS public blocklists for Postfix.\\e[0m\"\n      echo -e \"\\e[33mmailcow did not detected a value for the variable SPAMHAUS_DQS_KEY inside mailcow.conf!\\e[0m\"\n      sleep 2\n      echo \"\"\n      echo -e \"\\e[33mTo use the Spamhaus DNS Blocklists again, you will need to create a FREE account for their Data Query Service (DQS) at: https://www.spamhaus.com/free-trial/sign-up-for-a-free-data-query-service-account\\e[0m\"\n      echo -e \"\\e[33mOnce done, enter your DQS API key in mailcow.conf and mailcow will do the rest for you!\\e[0m\"\n      echo \"\"\n      sleep 2\n\n    else\n      echo -e \"\\e[33mYour server's public IP uses an AS that is blocked by Spamhaus to use their DNS public blocklists for Postfix.\\e[0m\"\n      echo -e \"\\e[32mmailcow detected a Value for the variable SPAMHAUS_DQS_KEY inside mailcow.conf. Postfix will use DQS with the given API key...\\e[0m\"\n    fi\n  elif [ \"$response\" -eq 200 ]; then\n    echo -e \"\\e[33mCheck completed! Your IP is \\e[32mclean\\e[0m\"\n  elif [ \"$response\" -eq 429 ]; then\n    echo -e \"\\e[33mCheck completed! \\e[31mYour IP seems to be rate limited on the ASN Check service... please try again later!\\e[0m\"\n  else\n    echo -e \"\\e[31mCheck failed! \\e[0mMaybe a DNS or Network problem?\\e[0m\"\n  fi\n}\n\n############## End Function Section ##############\n\n# Check permissions\nif [ \"$(id -u)\" -ne \"0\" ]; then\n  echo \"You need to be root\"\n  exit 1\nfi\n\nSCRIPT_DIR=\"$( cd \"$( dirname \"${BASH_SOURCE[0]}\" )\" && pwd )\"\n\n# Run pre-update-hook\nif [ -f \"${SCRIPT_DIR}/pre_update_hook.sh\" ]; then\n  bash \"${SCRIPT_DIR}/pre_update_hook.sh\"\nfi\n\nif [[ \"$(uname -r)\" =~ ^4\\.15\\.0-60 ]]; then\n  echo \"DO NOT RUN mailcow ON THIS UBUNTU KERNEL!\";\n  echo \"Please update to 5.x or use another distribution.\"\n  exit 1\nfi\n\nif [[ \"$(uname -r)\" =~ ^4\\.4\\. ]]; then\n  if grep -q Ubuntu <<< $(uname -a); then\n    echo \"DO NOT RUN mailcow ON THIS UBUNTU KERNEL!\"\n    echo \"Please update to linux-generic-hwe-16.04 by running \\\"apt-get install --install-recommends linux-generic-hwe-16.04\\\"\"\n    exit 1\n  fi\n  echo \"mailcow on a 4.4.x kernel is not supported. It may or may not work, please upgrade your kernel or continue at your own risk.\"\n  read -p \"Press any key to continue...\" < /dev/tty\nfi\n\n# Exit on error and pipefail\nset -o pipefail\n\n# Setting high dc timeout\nexport COMPOSE_HTTP_TIMEOUT=600\n\n# Add /opt/bin to PATH\nPATH=$PATH:/opt/bin\n\numask 0022\n\n# Unset COMPOSE_COMMAND and DOCKER_COMPOSE_VERSION Variable to be on the newest state.\nunset COMPOSE_COMMAND\nunset DOCKER_COMPOSE_VERSION\n\nfor bin in curl docker git awk sha1sum grep cut; do\n  if [[ -z $(command -v ${bin}) ]]; then \n  echo \"Cannot find ${bin}, exiting...\" \n  exit 1;\n  fi  \ndone\n\nexport LC_ALL=C\nDATE=$(date +%Y-%m-%d_%H_%M_%S)\nBRANCH=$(cd ${SCRIPT_DIR}; git rev-parse --abbrev-ref HEAD)\n\nwhile (($#)); do\n  case \"${1}\" in\n    --check|-c)\n      echo \"Checking remote code for updates...\"\n      LATEST_REV=$(git ls-remote --exit-code --refs --quiet https://github.com/mailcow/mailcow-dockerized ${BRANCH} | cut -f1)\n      if [ $? -ne 0 ]; then\n        echo \"A problem occurred while trying to fetch the latest revision from github.\"\n        exit 99\n      fi\n      if [[ -z $(git log HEAD --pretty=format:\"%H\" | grep \"${LATEST_REV}\") ]]; then\n        echo -e \"Updated code is available.\\nThe changes can be found here: https://github.com/mailcow/mailcow-dockerized/commits/master\"\n        git log --date=short --pretty=format:\"%ad - %s\" $(git rev-parse --short HEAD)..origin/master\n        exit 0\n      else\n        echo \"No updates available.\"\n        exit 3\n      fi\n    ;;\n    --ours)\n      MERGE_STRATEGY=ours\n    ;;\n    --skip-start)\n      SKIP_START=y\n    ;;\n    --skip-ping-check)\n      SKIP_PING_CHECK=y\n    ;;\n    --stable)\n      CURRENT_BRANCH=\"$(cd ${SCRIPT_DIR}; git rev-parse --abbrev-ref HEAD)\"\n      NEW_BRANCH=\"master\"\n    ;;\n    --gc)\n      echo -e \"\\e[32mCollecting garbage...\\e[0m\"\n      docker_garbage\n      exit 0\n    ;;\n    --nightly)\n      CURRENT_BRANCH=\"$(cd ${SCRIPT_DIR}; git rev-parse --abbrev-ref HEAD)\"\n      NEW_BRANCH=\"nightly\"\n    ;;\n    --prefetch)\n      echo -e \"\\e[32mPrefetching images...\\e[0m\"\n      prefetch_images\n      exit 0\n    ;;\n    -f|--force)\n      echo -e \"\\e[32mRunning in forced mode...\\e[0m\"\n      FORCE=y\n    ;;\n    -d|--dev)\n      echo -e \"\\e[32mRunning in Developer mode...\\e[0m\"\n      DEV=y\n    ;;\n    --help|-h)\n    echo './update.sh [-c|--check, --ours, --gc, --nightly, --prefetch, --skip-start, --skip-ping-check, --stable, -f|--force, -d|--dev, -h|--help]\n\n  -c|--check           -   Check for updates and exit (exit codes => 0: update available, 3: no updates)\n  --ours               -   Use merge strategy option \"ours\" to solve conflicts in favor of non-mailcow code (local changes over remote changes), not recommended!\n  --gc                 -   Run garbage collector to delete old image tags\n  --nightly            -   Switch your mailcow updates to the unstable (nightly) branch. FOR TESTING PURPOSES ONLY!!!!\n  --prefetch           -   Only prefetch new images and exit (useful to prepare updates)\n  --skip-start         -   Do not start mailcow after update\n  --skip-ping-check    -   Skip ICMP Check to public DNS resolvers (Use it only if you\u00b4ve blocked any ICMP Connections to your mailcow machine)\n  --stable             -   Switch your mailcow updates to the stable (master) branch. Default unless you changed it with --nightly.\n  -f|--force           -   Force update, do not ask questions\n  -d|--dev             -   Enables Developer Mode (No Checkout of update.sh for tests)\n'\n    exit 1\n  esac\n  shift\ndone\n\nchmod 600 mailcow.conf\nsource mailcow.conf\n\ndetect_docker_compose_command\n\n[[ ! -f mailcow.conf ]] && { echo \"mailcow.conf is missing! Is mailcow installed?\"; exit 1;}\nDOTS=${MAILCOW_HOSTNAME//[^.]};\nif [ ${#DOTS} -lt 1 ]; then\n  echo -e \"\\e[31mMAILCOW_HOSTNAME (${MAILCOW_HOSTNAME}) is not a FQDN!\\e[0m\"\n  sleep 1\n  echo \"Please change it to a FQDN and redeploy the stack with $COMPOSE_COMMAND up -d\"\n  exit 1\nelif [[ \"${MAILCOW_HOSTNAME: -1}\" == \".\" ]]; then\n  echo \"MAILCOW_HOSTNAME (${MAILCOW_HOSTNAME}) is ending with a dot. This is not a valid FQDN!\"\n  exit 1\nelif [ ${#DOTS} -eq 1 ]; then\n  echo -e \"\\e[33mMAILCOW_HOSTNAME (${MAILCOW_HOSTNAME}) does not contain a Subdomain. This is not fully tested and may cause issues.\\e[0m\"\n  echo \"Find more information about why this message exists here: https://github.com/mailcow/mailcow-dockerized/issues/1572\"\n  read -r -p \"Do you want to proceed anyway? [y/N] \" response\n  if [[ \"$response\" =~ ^([yY][eE][sS]|[yY])+$ ]]; then\n    echo \"OK. Procceding.\"\n  else\n    echo \"OK. Exiting.\"\n    exit 1\n  fi\nfi\n\nif grep --help 2>&1 | head -n 1 | grep -q -i \"busybox\"; then echo \"BusyBox grep detected, please install gnu grep, \\\"apk add --no-cache --upgrade grep\\\"\"; exit 1; fi\n# This will also cover sort\nif cp --help 2>&1 | head -n 1 | grep -q -i \"busybox\"; then echo \"BusyBox cp detected, please install coreutils, \\\"apk add --no-cache --upgrade coreutils\\\"\"; exit 1; fi\nif sed --help 2>&1 | head -n 1 | grep -q -i \"busybox\"; then echo \"BusyBox sed detected, please install gnu sed, \\\"apk add --no-cache --upgrade sed\\\"\"; exit 1; fi\n\nCONFIG_ARRAY=(\n  \"SKIP_LETS_ENCRYPT\"\n  \"SKIP_SOGO\"\n  \"USE_WATCHDOG\"\n  \"WATCHDOG_NOTIFY_EMAIL\"\n  \"WATCHDOG_NOTIFY_WEBHOOK\"\n  \"WATCHDOG_NOTIFY_WEBHOOK_BODY\"\n  \"WATCHDOG_NOTIFY_BAN\"\n  \"WATCHDOG_NOTIFY_START\"\n  \"WATCHDOG_EXTERNAL_CHECKS\"\n  \"WATCHDOG_SUBJECT\"\n  \"SKIP_CLAMD\"\n  \"SKIP_IP_CHECK\"\n  \"ADDITIONAL_SAN\"\n  \"DOVEADM_PORT\"\n  \"IPV4_NETWORK\"\n  \"IPV6_NETWORK\"\n  \"LOG_LINES\"\n  \"SNAT_TO_SOURCE\"\n  \"SNAT6_TO_SOURCE\"\n  \"COMPOSE_PROJECT_NAME\"\n  \"DOCKER_COMPOSE_VERSION\"\n  \"SQL_PORT\"\n  \"API_KEY\"\n  \"API_KEY_READ_ONLY\"\n  \"API_ALLOW_FROM\"\n  \"MAILDIR_GC_TIME\"\n  \"MAILDIR_SUB\"\n  \"ACL_ANYONE\"\n  \"SOLR_HEAP\"\n  \"SKIP_SOLR\"\n  \"ENABLE_SSL_SNI\"\n  \"ALLOW_ADMIN_EMAIL_LOGIN\"\n  \"SKIP_HTTP_VERIFICATION\"\n  \"SOGO_EXPIRE_SESSION\"\n  \"REDIS_PORT\"\n  \"DOVECOT_MASTER_USER\"\n  \"DOVECOT_MASTER_PASS\"\n  \"MAILCOW_PASS_SCHEME\"\n  \"ADDITIONAL_SERVER_NAMES\"\n  \"ACME_CONTACT\"\n  \"WATCHDOG_VERBOSE\"\n  \"WEBAUTHN_ONLY_TRUSTED_VENDORS\"\n  \"SPAMHAUS_DQS_KEY\"\n  \"SKIP_UNBOUND_HEALTHCHECK\"\n)\n\ndetect_bad_asn\n\nsed -i --follow-symlinks '$a\\' mailcow.conf\nfor option in ${CONFIG_ARRAY[@]}; do\n  if [[ ${option} == \"ADDITIONAL_SAN\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo \"${option}=\" >> mailcow.conf\n    fi\n  elif [[ ${option} == \"COMPOSE_PROJECT_NAME\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo \"COMPOSE_PROJECT_NAME=mailcowdockerized\" >> mailcow.conf\n    fi\n  elif [[ ${option} == \"DOCKER_COMPOSE_VERSION\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo \"# Used Docker Compose version\" >> mailcow.conf\n      echo \"# Switch here between native (compose plugin) and standalone\" >> mailcow.conf\n      echo \"# For more informations take a look at the mailcow docs regarding the configuration options.\" >> mailcow.conf\n      echo \"# Normally this should be untouched but if you decided to use either of those you can switch it manually here.\" >> mailcow.conf\n      echo \"# Please be aware that at least one of those variants should be installed on your maschine or mailcow will fail.\" >> mailcow.conf\n      echo \"\" >> mailcow.conf\n      echo \"DOCKER_COMPOSE_VERSION=${DOCKER_COMPOSE_VERSION}\" >> mailcow.conf\n    fi\n  elif [[ ${option} == \"DOVEADM_PORT\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo \"DOVEADM_PORT=127.0.0.1:19991\" >> mailcow.conf\n    fi\n  elif [[ ${option} == \"WATCHDOG_NOTIFY_EMAIL\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo \"WATCHDOG_NOTIFY_EMAIL=\" >> mailcow.conf\n    fi\n  elif [[ ${option} == \"LOG_LINES\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo '# Max log lines per service to keep in Redis logs' >> mailcow.conf\n      echo \"LOG_LINES=9999\" >> mailcow.conf\n    fi\n  elif [[ ${option} == \"IPV4_NETWORK\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo '# Internal IPv4 /24 subnet, format n.n.n. (expands to n.n.n.0/24)' >> mailcow.conf\n      echo \"IPV4_NETWORK=172.22.1\" >> mailcow.conf\n    fi\n  elif [[ ${option} == \"IPV6_NETWORK\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo '# Internal IPv6 subnet in fc00::/7' >> mailcow.conf\n      echo \"IPV6_NETWORK=fd4d:6169:6c63:6f77::/64\" >> mailcow.conf\n    fi\n  elif [[ ${option} == \"SQL_PORT\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo '# Bind SQL to 127.0.0.1 on port 13306' >> mailcow.conf\n      echo \"SQL_PORT=127.0.0.1:13306\" >> mailcow.conf\n    fi\n  elif [[ ${option} == \"API_KEY\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo '# Create or override API key for web UI' >> mailcow.conf\n      echo \"#API_KEY=\" >> mailcow.conf\n    fi\n  elif [[ ${option} == \"API_KEY_READ_ONLY\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo '# Create or override read-only API key for web UI' >> mailcow.conf\n      echo \"#API_KEY_READ_ONLY=\" >> mailcow.conf\n    fi\n  elif [[ ${option} == \"API_ALLOW_FROM\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo '# Must be set for API_KEY to be active' >> mailcow.conf\n      echo '# IPs only, no networks (networks can be set via UI)' >> mailcow.conf\n      echo \"#API_ALLOW_FROM=\" >> mailcow.conf\n    fi\n  elif [[ ${option} == \"SNAT_TO_SOURCE\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo '# Use this IPv4 for outgoing connections (SNAT)' >> mailcow.conf\n      echo \"#SNAT_TO_SOURCE=\" >> mailcow.conf\n    fi\n  elif [[ ${option} == \"SNAT6_TO_SOURCE\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo '# Use this IPv6 for outgoing connections (SNAT)' >> mailcow.conf\n      echo \"#SNAT6_TO_SOURCE=\" >> mailcow.conf\n    fi\n  elif [[ ${option} == \"MAILDIR_GC_TIME\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo '# Garbage collector cleanup' >> mailcow.conf\n      echo '# Deleted domains and mailboxes are moved to /var/vmail/_garbage/timestamp_sanitizedstring' >> mailcow.conf\n      echo '# How long should objects remain in the garbage until they are being deleted? (value in minutes)' >> mailcow.conf\n      echo '# Check interval is hourly' >> mailcow.conf\n      echo 'MAILDIR_GC_TIME=1440' >> mailcow.conf\n    fi\n  elif [[ ${option} == \"ACL_ANYONE\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo '# Set this to \"allow\" to enable the anyone pseudo user. Disabled by default.' >> mailcow.conf\n      echo '# When enabled, ACL can be created, that apply to \"All authenticated users\"' >> mailcow.conf\n      echo '# This should probably only be activated on mail hosts, that are used exclusivly by one organisation.' >> mailcow.conf\n      echo '# Otherwise a user might share data with too many other users.' >> mailcow.conf\n      echo 'ACL_ANYONE=disallow' >> mailcow.conf\n    fi\n  elif [[ ${option} == \"SOLR_HEAP\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo '# Solr heap size, there is no recommendation, please see Solr docs.' >> mailcow.conf\n      echo '# Solr is a prone to run OOM on large systems and should be monitored. Unmonitored Solr setups are not recommended.' >> mailcow.conf\n      echo '# Solr will refuse to start with total system memory below or equal to 2 GB.' >> mailcow.conf\n      echo \"SOLR_HEAP=1024\" >> mailcow.conf\n    fi\n  elif [[ ${option} == \"SKIP_SOLR\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo '# Solr is disabled by default after upgrading from non-Solr to Solr-enabled mailcows.' >> mailcow.conf\n      echo '# Disable Solr or if you do not want to store a readable index of your mails in solr-vol-1.' >> mailcow.conf\n      echo \"SKIP_SOLR=y\" >> mailcow.conf\n    fi\n  elif [[ ${option} == \"ENABLE_SSL_SNI\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo '# Create seperate certificates for all domains - y/n' >> mailcow.conf\n      echo '# this will allow adding more than 100 domains, but some email clients will not be able to connect with alternative hostnames' >> mailcow.conf\n      echo '# see https://wiki.dovecot.org/SSL/SNIClientSupport' >> mailcow.conf\n      echo \"ENABLE_SSL_SNI=n\" >> mailcow.conf\n    fi\n  elif [[ ${option} == \"SKIP_SOGO\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo '# Skip SOGo: Will disable SOGo integration and therefore webmail, DAV protocols and ActiveSync support (experimental, unsupported, not fully implemented) - y/n' >> mailcow.conf\n      echo \"SKIP_SOGO=n\" >> mailcow.conf\n    fi\n  elif [[ ${option} == \"MAILDIR_SUB\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo '# MAILDIR_SUB defines a path in a users virtual home to keep the maildir in. Leave empty for updated setups.' >> mailcow.conf\n      echo \"#MAILDIR_SUB=Maildir\" >> mailcow.conf\n      echo \"MAILDIR_SUB=\" >> mailcow.conf\n    fi\n  elif [[ ${option} == \"WATCHDOG_NOTIFY_WEBHOOK\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo '# Send notifications to a webhook URL that receives a POST request with the content type \"application/json\".' >> mailcow.conf\n      echo '# You can use this to send notifications to services like Discord, Slack and others.' >> mailcow.conf\n      echo '#WATCHDOG_NOTIFY_WEBHOOK=https://discord.com/api/webhooks/XXXXXXXXXXXXXXXXXXX/XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX' >> mailcow.conf\n    fi\n  elif [[ ${option} == \"WATCHDOG_NOTIFY_WEBHOOK_BODY\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo '# JSON body included in the webhook POST request. Needs to be in single quotes.' >> mailcow.conf\n      echo '# Following variables are available: SUBJECT, BODY' >> mailcow.conf\n      WEBHOOK_BODY='{\"username\": \"mailcow Watchdog\", \"content\": \"**${SUBJECT}**\\n${BODY}\"}'\n      echo \"#WATCHDOG_NOTIFY_WEBHOOK_BODY='${WEBHOOK_BODY}'\" >> mailcow.conf\n    fi\n  elif [[ ${option} == \"WATCHDOG_NOTIFY_BAN\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo '# Notify about banned IP. Includes whois lookup.' >> mailcow.conf\n      echo \"WATCHDOG_NOTIFY_BAN=y\" >> mailcow.conf\n    fi\n  elif [[ ${option} == \"WATCHDOG_NOTIFY_START\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo '# Send a notification when the watchdog is started.' >> mailcow.conf\n      echo \"WATCHDOG_NOTIFY_START=y\" >> mailcow.conf\n    fi\n  elif [[ ${option} == \"WATCHDOG_SUBJECT\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo '# Subject for watchdog mails. Defaults to \"Watchdog ALERT\" followed by the error message.' >> mailcow.conf\n      echo \"#WATCHDOG_SUBJECT=\" >> mailcow.conf\n    fi\n  elif [[ ${option} == \"WATCHDOG_EXTERNAL_CHECKS\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo '# Checks if mailcow is an open relay. Requires a SAL. More checks will follow.' >> mailcow.conf\n      echo '# No data is collected. Opt-in and anonymous.' >> mailcow.conf\n      echo '# Will only work with unmodified mailcow setups.' >> mailcow.conf\n      echo \"WATCHDOG_EXTERNAL_CHECKS=n\" >> mailcow.conf\n    fi\n  elif [[ ${option} == \"SOGO_EXPIRE_SESSION\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo '# SOGo session timeout in minutes' >> mailcow.conf\n      echo \"SOGO_EXPIRE_SESSION=480\" >> mailcow.conf\n    fi\n  elif [[ ${option} == \"REDIS_PORT\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo \"REDIS_PORT=127.0.0.1:7654\" >> mailcow.conf\n    fi\n  elif [[ ${option} == \"DOVECOT_MASTER_USER\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo '# DOVECOT_MASTER_USER and _PASS must _both_ be provided. No special chars.' >> mailcow.conf\n      echo '# Empty by default to auto-generate master user and password on start.' >> mailcow.conf\n      echo '# User expands to DOVECOT_MASTER_USER@mailcow.local' >> mailcow.conf\n      echo '# LEAVE EMPTY IF UNSURE' >> mailcow.conf\n      echo \"DOVECOT_MASTER_USER=\" >> mailcow.conf\n    fi\n  elif [[ ${option} == \"DOVECOT_MASTER_PASS\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo '# LEAVE EMPTY IF UNSURE' >> mailcow.conf\n      echo \"DOVECOT_MASTER_PASS=\" >> mailcow.conf\n    fi\n  elif [[ ${option} == \"MAILCOW_PASS_SCHEME\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo '# Password hash algorithm' >> mailcow.conf\n      echo '# Only certain password hash algorithm are supported. For a fully list of supported schemes,' >> mailcow.conf\n      echo '# see https://docs.mailcow.email/models/model-passwd/' >> mailcow.conf\n      echo \"MAILCOW_PASS_SCHEME=BLF-CRYPT\" >> mailcow.conf\n    fi\n  elif [[ ${option} == \"ADDITIONAL_SERVER_NAMES\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo '# Additional server names for mailcow UI' >> mailcow.conf\n      echo '#' >> mailcow.conf\n      echo '# Specify alternative addresses for the mailcow UI to respond to' >> mailcow.conf\n      echo '# This is useful when you set mail.* as ADDITIONAL_SAN and want to make sure mail.maildomain.com will always point to the mailcow UI.' >> mailcow.conf\n      echo '# If the server name does not match a known site, Nginx decides by best-guess and may redirect users to the wrong web root.' >> mailcow.conf\n      echo '# You can understand this as server_name directive in Nginx.' >> mailcow.conf\n      echo '# Comma separated list without spaces! Example: ADDITIONAL_SERVER_NAMES=a.b.c,d.e.f' >> mailcow.conf\n      echo 'ADDITIONAL_SERVER_NAMES=' >> mailcow.conf\n    fi\n  elif [[ ${option} == \"ACME_CONTACT\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo '# Lets Encrypt registration contact information' >> mailcow.conf\n      echo '# Optional: Leave empty for none' >> mailcow.conf\n      echo '# This value is only used on first order!' >> mailcow.conf\n      echo '# Setting it at a later point will require the following steps:' >> mailcow.conf\n      echo '# https://docs.mailcow.email/troubleshooting/debug-reset_tls/' >> mailcow.conf\n      echo 'ACME_CONTACT=' >> mailcow.conf\n    fi\n  elif [[ ${option} == \"WEBAUTHN_ONLY_TRUSTED_VENDORS\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo \"# WebAuthn device manufacturer verification\" >> mailcow.conf\n      echo '# After setting WEBAUTHN_ONLY_TRUSTED_VENDORS=y only devices from trusted manufacturers are allowed' >> mailcow.conf\n      echo '# root certificates can be placed for validation under mailcow-dockerized/data/web/inc/lib/WebAuthn/rootCertificates' >> mailcow.conf\n      echo 'WEBAUTHN_ONLY_TRUSTED_VENDORS=n' >> mailcow.conf\n    fi\n  elif [[ ${option} == \"SPAMHAUS_DQS_KEY\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo \"# Spamhaus Data Query Service Key\" >> mailcow.conf\n      echo '# Optional: Leave empty for none' >> mailcow.conf\n      echo '# Enter your key here if you are using a blocked ASN (OVH, AWS, Cloudflare e.g) for the unregistered Spamhaus Blocklist.' >> mailcow.conf\n      echo '# If empty, it will completely disable Spamhaus blocklists if it detects that you are running on a server using a blocked AS.' >> mailcow.conf\n      echo '# Otherwise it will work as usual.' >> mailcow.conf\n      echo 'SPAMHAUS_DQS_KEY=' >> mailcow.conf\n    fi\n  elif [[ ${option} == \"WATCHDOG_VERBOSE\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo '# Enable watchdog verbose logging' >> mailcow.conf\n      echo 'WATCHDOG_VERBOSE=n' >> mailcow.conf\n    fi\n  elif [[ ${option} == \"SKIP_UNBOUND_HEALTHCHECK\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo '# Skip Unbound (DNS Resolver) Healthchecks (NOT Recommended!) - y/n' >> mailcow.conf\n      echo 'SKIP_UNBOUND_HEALTHCHECK=n' >> mailcow.conf\n    fi\n  elif ! grep -q ${option} mailcow.conf; then\n    echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n    echo \"${option}=n\" >> mailcow.conf\n  fi\ndone\n\nif [[( ${SKIP_PING_CHECK} == \"y\")]]; then\necho -e \"\\e[32mSkipping Ping Check...\\e[0m\"\n\nelse\n   echo -en \"Checking internet connection... \"\n   if ! check_online_status; then\n      echo -e \"\\e[31mfailed\\e[0m\"\n      exit 1\n   else\n      echo -e \"\\e[32mOK\\e[0m\"\n   fi\nfi\n\nif ! [ $NEW_BRANCH ]; then\n  echo -e \"\\e[33mDetecting which build your mailcow runs on...\\e[0m\"\n  sleep 1\n  if [ ${BRANCH} == \"master\" ]; then\n    echo -e \"\\e[32mYou are receiving stable updates (master).\\e[0m\"\n    echo -e \"\\e[33mTo change that run the update.sh Script one time with the --nightly parameter to switch to nightly builds.\\e[0m\"\n\n  elif [ ${BRANCH} == \"nightly\" ]; then\n    echo -e \"\\e[31mYou are receiving unstable updates (nightly). These are for testing purposes only!!!\\e[0m\"\n    sleep 1\n    echo -e \"\\e[33mTo change that run the update.sh Script one time with the --stable parameter to switch to stable builds.\\e[0m\"\n\n  else\n    echo -e \"\\e[33mYou are receiving updates from a unsupported branch.\\e[0m\"\n    sleep 1\n    echo -e \"\\e[33mThe mailcow stack might still work but it is recommended to switch to the master branch (stable builds).\\e[0m\"\n    echo -e \"\\e[33mTo change that run the update.sh Script one time with the --stable parameter to switch to stable builds.\\e[0m\"\n  fi\nelif [ $FORCE ]; then\n  echo -e \"\\e[31mYou are running in forced mode!\\e[0m\"\n  echo -e \"\\e[31mA Branch Switch can only be performed manually (monitored).\\e[0m\"\n  echo -e \"\\e[31mPlease rerun the update.sh Script without the --force/-f parameter.\\e[0m\"\n  sleep 1\nelif [ $NEW_BRANCH == \"master\" ] && [ $CURRENT_BRANCH != \"master\" ]; then\n  echo -e \"\\e[33mYou are about to switch your mailcow Updates to the stable (master) branch.\\e[0m\"\n  sleep 1\n  echo -e \"\\e[33mBefore you do: Please take a backup of all components to ensure that no Data is lost...\\e[0m\"\n  sleep 1\n  echo -e \"\\e[31mWARNING: Please see on GitHub or ask in the communitys if a switch to master is stable or not.\n  In some rear cases a Update back to master can destroy your mailcow configuration in case of Database Upgrades etc.\n  Normally a upgrade back to master should be safe during each full release. \n  Check GitHub for Database Changes and Update only if there similar to the full release!\\e[0m\"\n  read -r -p \"Are you sure you that want to continue upgrading to the stable (master) branch? [y/N] \" response\n  if [[ ! \"${response}\" =~ ^([yY][eE][sS]|[yY])+$ ]]; then\n    echo \"OK. If you prepared yourself for that please run the update.sh Script with the --stable parameter again to trigger this process here.\"\n    exit 0\n  fi\n  BRANCH=$NEW_BRANCH\n  DIFF_DIRECTORY=update_diffs\n  DIFF_FILE=${DIFF_DIRECTORY}/diff_before_upgrade_to_master_$(date +\"%Y-%m-%d-%H-%M-%S\")\n  mv diff_before_upgrade* ${DIFF_DIRECTORY}/ 2> /dev/null\n  if ! git diff-index --quiet HEAD; then\n    echo -e \"\\e[32mSaving diff to ${DIFF_FILE}...\\e[0m\"\n    mkdir -p ${DIFF_DIRECTORY}\n    git diff ${BRANCH} --stat > ${DIFF_FILE}\n    git diff ${BRANCH} >> ${DIFF_FILE}\n  fi\n  echo -e \"\\e[32mSwitching Branch to ${BRANCH}...\\e[0m\"\n  git fetch origin\n  git checkout -f ${BRANCH}\n\nelif [ $NEW_BRANCH == \"nightly\" ] && [ $CURRENT_BRANCH != \"nightly\" ]; then\n  echo -e \"\\e[33mYou are about to switch your mailcow Updates to the unstable (nightly) branch.\\e[0m\"\n  sleep 1\n  echo -e \"\\e[33mBefore you do: Please take a backup of all components to ensure that no Data is lost...\\e[0m\"\n  sleep 1\n  echo -e \"\\e[31mWARNING: A switch to nightly is possible any time. But a switch back (to master) isn't.\\e[0m\"\n  read -r -p \"Are you sure you that want to continue upgrading to the unstable (nightly) branch? [y/N] \" response\n  if [[ ! \"${response}\" =~ ^([yY][eE][sS]|[yY])+$ ]]; then\n    echo \"OK. If you prepared yourself for that please run the update.sh Script with the --nightly parameter again to trigger this process here.\"\n    exit 0\n  fi\n  BRANCH=$NEW_BRANCH\n  DIFF_DIRECTORY=update_diffs\n  DIFF_FILE=${DIFF_DIRECTORY}/diff_before_upgrade_to_nightly_$(date +\"%Y-%m-%d-%H-%M-%S\")\n  mv diff_before_upgrade* ${DIFF_DIRECTORY}/ 2> /dev/null\n  if ! git diff-index --quiet HEAD; then\n    echo -e \"\\e[32mSaving diff to ${DIFF_FILE}...\\e[0m\"\n    mkdir -p ${DIFF_DIRECTORY}\n    git diff ${BRANCH} --stat > ${DIFF_FILE}\n    git diff ${BRANCH} >> ${DIFF_FILE}\n  fi\n  git fetch origin\n  git checkout -f ${BRANCH}\nfi\n\nif [ ! $DEV ]; then\n  echo -e \"\\e[32mChecking for newer update script...\\e[0m\"\n  SHA1_1=$(sha1sum update.sh)\n  git fetch origin #${BRANCH}\n  git checkout origin/${BRANCH} update.sh\n  SHA1_2=$(sha1sum update.sh)\n  if [[ ${SHA1_1} != ${SHA1_2} ]]; then\n    echo \"update.sh changed, please run this script again, exiting.\"\n    chmod +x update.sh\n    exit 2\n  fi\nfi\n\nif [ ! $FORCE ]; then\n  read -r -p \"Are you sure you want to update mailcow: dockerized? All containers will be stopped. [y/N] \" response\n  if [[ ! \"${response}\" =~ ^([yY][eE][sS]|[yY])+$ ]]; then\n    echo \"OK, exiting.\"\n    exit 0\n  fi\n  migrate_docker_nat\nfi\n\nremove_obsolete_nginx_ports\n\necho -e \"\\e[32mValidating docker-compose stack configuration...\\e[0m\"\nsed -i 's/HTTPS_BIND:-:/HTTPS_BIND:-/g' docker-compose.yml\nsed -i 's/HTTP_BIND:-:/HTTP_BIND:-/g' docker-compose.yml\nif ! $COMPOSE_COMMAND config -q; then\n  echo -e \"\\e[31m\\nOh no, something went wrong. Please check the error message above.\\e[0m\"\n  exit 1\nfi\n\necho -e \"\\e[32mChecking for conflicting bridges...\\e[0m\"\nMAILCOW_BRIDGE=$($COMPOSE_COMMAND config | grep -i com.docker.network.bridge.name | cut -d':' -f2)\nwhile read NAT_ID; do\n  iptables -t nat -D POSTROUTING $NAT_ID\ndone < <(iptables -L -vn -t nat --line-numbers | grep $IPV4_NETWORK | grep -E 'MASQUERADE.*all' | grep -v ${MAILCOW_BRIDGE} | cut -d' ' -f1)\n\nDIFF_DIRECTORY=update_diffs\nDIFF_FILE=${DIFF_DIRECTORY}/diff_before_update_$(date +\"%Y-%m-%d-%H-%M-%S\")\nmv diff_before_update* ${DIFF_DIRECTORY}/ 2> /dev/null\nif ! git diff-index --quiet HEAD; then\n  echo -e \"\\e[32mSaving diff to ${DIFF_FILE}...\\e[0m\"\n  mkdir -p ${DIFF_DIRECTORY}\n  git diff --stat > ${DIFF_FILE}\n  git diff >> ${DIFF_FILE}\nfi\n\necho -e \"\\e[32mPrefetching images...\\e[0m\"\nprefetch_images\n\necho -e \"\\e[32mStopping mailcow...\\e[0m\"\nsleep 2\nMAILCOW_CONTAINERS=($($COMPOSE_COMMAND ps -q))\n$COMPOSE_COMMAND down\necho -e \"\\e[32mChecking for remaining containers...\\e[0m\"\nsleep 2\nfor container in \"${MAILCOW_CONTAINERS[@]}\"; do\n  docker rm -f \"$container\" 2> /dev/null\ndone\n\n[[ -f data/conf/nginx/ZZZ-ejabberd.conf ]] && rm data/conf/nginx/ZZZ-ejabberd.conf\n\n\n# Silently fixing remote url from andryyy to mailcow\n# git remote set-url origin https://github.com/mailcow/mailcow-dockerized\n\nDEFAULT_REPO=https://github.com/mailcow/mailcow-dockerized\nCURRENT_REPO=$(git config --get remote.origin.url)\nif [ \"$CURRENT_REPO\" != \"$DEFAULT_REPO\" ]; then \n  echo \"The Repository currently used is not the default Mailcow Repository.\"\n  echo \"Currently Repository: $CURRENT_REPO\"\n  echo \"Default Repository:   $DEFAULT_REPO\"\n  if [ ! $FORCE ]; then\n    read -r -p \"Should it be changed back to default? [y/N] \" repo_response\n    if [[ \"$repo_response\" =~ ^([yY][eE][sS]|[yY])+$ ]]; then\n      git remote set-url origin $DEFAULT_REPO\n    fi\n  else\n      echo \"Running in forced mode... setting Repo to default!\"\n      git remote set-url origin $DEFAULT_REPO\n  fi\nfi\n\nif [ ! $DEV ]; then\n  echo -e \"\\e[32mCommitting current status...\\e[0m\"\n  [[ -z \"$(git config user.name)\" ]] && git config user.name moo\n  [[ -z \"$(git config user.email)\" ]] && git config user.email moo@cow.moo\n  [[ ! -z $(git ls-files data/conf/rspamd/override.d/worker-controller-password.inc) ]] && git rm data/conf/rspamd/override.d/worker-controller-password.inc\n  git add -u\n  git commit -am \"Before update on ${DATE}\" > /dev/null\n  echo -e \"\\e[32mFetching updated code from remote...\\e[0m\"\n  git fetch origin #${BRANCH}\n  echo -e \"\\e[32mMerging local with remote code (recursive, strategy: \\\"${MERGE_STRATEGY:-theirs}\\\", options: \\\"patience\\\"...\\e[0m\"\n  git config merge.defaultToUpstream true\n  git merge -X${MERGE_STRATEGY:-theirs} -Xpatience -m \"After update on ${DATE}\"\n  # Need to use a variable to not pass return codes of if checks\n  MERGE_RETURN=$?\n  if [[ ${MERGE_RETURN} == 128 ]]; then\n    echo -e \"\\e[31m\\nOh no, what happened?\\n=> You most likely added files to your local mailcow instance that were now added to the official mailcow repository. Please move them to another location before updating mailcow.\\e[0m\"\n    exit 1\n  elif [[ ${MERGE_RETURN} == 1 ]]; then\n    echo -e \"\\e[93mPotenial conflict, trying to fix...\\e[0m\"\n    git status --porcelain | grep -E \"UD|DU\" | awk '{print $2}' | xargs rm -v\n    git add -A\n    git commit -m \"After update on ${DATE}\" > /dev/null\n    git checkout .\n    echo -e \"\\e[32mRemoved and recreated files if necessary.\\e[0m\"\n  elif [[ ${MERGE_RETURN} != 0 ]]; then\n    echo -e \"\\e[31m\\nOh no, something went wrong. Please check the error message above.\\e[0m\"\n    echo\n    echo \"Run $COMPOSE_COMMAND up -d to restart your stack without updates or try again after fixing the mentioned errors.\"\n    exit 1\n  fi\nelif [ $DEV ]; then\n  echo -e \"\\e[33mDEVELOPER MODE: Not creating a git diff and commiting it to prevent development stuff within a backup diff...\\e[0m\"\nfi\n\necho -e \"\\e[32mFetching new images, if any...\\e[0m\"\nsleep 2\n$COMPOSE_COMMAND pull\n\n# Fix missing SSL, does not overwrite existing files\n[[ ! -d data/assets/ssl ]] && mkdir -p data/assets/ssl\ncp -n -d data/assets/ssl-example/*.pem data/assets/ssl/\n\necho -e \"Checking IPv6 settings... \"\nif grep -q 'SYSCTL_IPV6_DISABLED=1' mailcow.conf; then\n  echo\n  echo '!! IMPORTANT !!'\n  echo\n  echo 'SYSCTL_IPV6_DISABLED was removed due to complications. IPv6 can be disabled by editing \"docker-compose.yml\" and setting \"enable_ipv6: true\" to \"enable_ipv6: false\".'\n  echo \"This setting will only be active after a complete shutdown of mailcow by running $COMPOSE_COMMAND down followed by $COMPOSE_COMMAND up -d.\"\n  echo\n  echo '!! IMPORTANT !!'\n  echo\n  read -p \"Press any key to continue...\" < /dev/tty\nfi\n\n# Checking for old project name bug\nsed -i --follow-symlinks 's#COMPOSEPROJECT_NAME#COMPOSE_PROJECT_NAME#g' mailcow.conf\n\n# Fix Rspamd maps\nif [ -f data/conf/rspamd/custom/global_from_blacklist.map ]; then\n  mv data/conf/rspamd/custom/global_from_blacklist.map data/conf/rspamd/custom/global_smtp_from_blacklist.map\nfi\nif [ -f data/conf/rspamd/custom/global_from_whitelist.map ]; then\n  mv data/conf/rspamd/custom/global_from_whitelist.map data/conf/rspamd/custom/global_smtp_from_whitelist.map\nfi\n\n# Fix deprecated metrics.conf\nif [ -f \"data/conf/rspamd/local.d/metrics.conf\" ]; then\n  if [ ! -z \"$(git diff --name-only origin/master data/conf/rspamd/local.d/metrics.conf)\" ]; then\n    echo -e \"\\e[33mWARNING\\e[0m - Please migrate your customizations of data/conf/rspamd/local.d/metrics.conf to actions.conf and groups.conf after this update.\"\n    echo \"The deprecated configuration file metrics.conf will be moved to metrics.conf_deprecated after updating mailcow.\"\n  fi\n  mv data/conf/rspamd/local.d/metrics.conf data/conf/rspamd/local.d/metrics.conf_deprecated\nfi\n\n# Set app_info.inc.php\nif [ ${BRANCH} == \"master\" ]; then\n  mailcow_git_version=$(git describe --tags `git rev-list --tags --max-count=1`)\nelif [ ${BRANCH} == \"nightly\" ]; then\n  mailcow_git_version=$(git rev-parse --short $(git rev-parse @{upstream}))\n  mailcow_last_git_version=\"\"\nelse\n  mailcow_git_version=$(git rev-parse --short HEAD)\n  mailcow_last_git_version=\"\"\nfi\n\nmailcow_git_commit=$(git rev-parse origin/${BRANCH})\nmailcow_git_commit_date=$(git log -1 --format=%ci @{upstream} )\n\nif [ $? -eq 0 ]; then\n  echo '<?php' > data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_GIT_VERSION=\"'$mailcow_git_version'\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_LAST_GIT_VERSION=\"\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_GIT_OWNER=\"mailcow\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_GIT_REPO=\"mailcow-dockerized\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_GIT_URL=\"https://github.com/mailcow/mailcow-dockerized\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_GIT_COMMIT=\"'$mailcow_git_commit'\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_GIT_COMMIT_DATE=\"'$mailcow_git_commit_date'\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_BRANCH=\"'$BRANCH'\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_UPDATEDAT='$(date +%s)';' >> data/web/inc/app_info.inc.php\n  echo '?>' >> data/web/inc/app_info.inc.php\nelse\n  echo '<?php' > data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_GIT_VERSION=\"'$mailcow_git_version'\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_LAST_GIT_VERSION=\"\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_GIT_OWNER=\"mailcow\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_GIT_REPO=\"mailcow-dockerized\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_GIT_URL=\"https://github.com/mailcow/mailcow-dockerized\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_GIT_COMMIT=\"\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_GIT_COMMIT_DATE=\"\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_BRANCH=\"'$BRANCH'\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_UPDATEDAT='$(date +%s)';' >> data/web/inc/app_info.inc.php\n  echo '?>' >> data/web/inc/app_info.inc.php\n  echo -e \"\\e[33mCannot determine current git repository version...\\e[0m\"\nfi\n\nif [[ ${SKIP_START} == \"y\" ]]; then\n  echo -e \"\\e[33mNot starting mailcow, please run \\\"$COMPOSE_COMMAND up -d --remove-orphans\\\" to start mailcow.\\e[0m\"\nelse\n  echo -e \"\\e[32mStarting mailcow...\\e[0m\"\n  sleep 2\n  $COMPOSE_COMMAND up -d --remove-orphans\nfi\n\necho -e \"\\e[32mCollecting garbage...\\e[0m\"\ndocker_garbage\n\n# Run post-update-hook\nif [ -f \"${SCRIPT_DIR}/post_update_hook.sh\" ]; then\n  bash \"${SCRIPT_DIR}/post_update_hook.sh\"\nfi\n\n# echo \"In case you encounter any problem, hard-reset to a state before updating mailcow:\"\n# echo\n# git reflog --color=always | grep \"Before update on \"\n# echo\n# echo \"Use \\\"git reset --hard hash-on-the-left\\\" and run $COMPOSE_COMMAND up -d afterwards.\"\n"], "fixing_code": ["!data/conf/nginx/dynmaps.conf\n!data/conf/nginx/meta_exporter.conf\n!data/conf/nginx/site.conf\n!/**/.gitkeep\n*.iml\n.idea\n.vscode/*\ndata/assets/ssl-example/*\ndata/assets/ssl/*\ndata/conf/borgmatic/\ndata/conf/clamav/whitelist.ign2\ndata/conf/dovecot/acl_anyone\ndata/conf/dovecot/dovecot-master.passwd\ndata/conf/dovecot/dovecot-master.userdb\ndata/conf/dovecot/extra.conf\ndata/conf/dovecot/mail_replica.conf\ndata/conf/dovecot/global_sieve_*\ndata/conf/dovecot/last_login\ndata/conf/dovecot/lua\ndata/conf/dovecot/mail_plugins*\ndata/conf/dovecot/shared_namespace.conf\ndata/conf/dovecot/sni.conf\ndata/conf/dovecot/sogo-sso.conf\ndata/conf/dovecot/sogo_trusted_ip.conf\ndata/conf/dovecot/sql\ndata/conf/nextcloud-*.bak\ndata/conf/nginx/*.active\ndata/conf/nginx/*.bak\ndata/conf/nginx/*.conf\ndata/conf/nginx/*.custom\ndata/conf/phpfpm/sogo-sso/sogo-sso.pass\ndata/conf/portainer/\ndata/conf/postfix/allow_mailcow_local.regexp\ndata/conf/postfix/custom_postscreen_whitelist.cidr\ndata/conf/postfix/custom_transport.pcre\ndata/conf/postfix/extra.cf\ndata/conf/postfix/sni.map\ndata/conf/postfix/sni.map.db\ndata/conf/postfix/sql\ndata/conf/postfix/dns_blocklists.cf\ndata/conf/postfix/dnsbl_reply.map\ndata/conf/rspamd/custom/*\ndata/conf/rspamd/local.d/*\ndata/conf/rspamd/override.d/*\ndata/conf/sogo/custom-theme.js\ndata/conf/sogo/plist_ldap\ndata/conf/sogo/sieve.creds\ndata/conf/sogo/sogo-full.svg\ndata/gitea/\ndata/gogs/\ndata/hooks/dovecot/*\ndata/hooks/phpfpm/*\ndata/hooks/postfix/*\ndata/hooks/rspamd/*\ndata/hooks/sogo/*\ndata/hooks/unbound/*\ndata/web/templates/cache/*\n!data/web/templates/cache/.gitkeep\ndata/web/.well-known/acme-challenge\ndata/web/css/build/0081-custom-mailcow.css\ndata/web/inc/vars.local.inc.php\ndata/web/inc/app_info.inc.php\ndata/web/nextcloud*/\ndata/web/rc*/\ndocker-compose.override.yml\nmailcow.conf\nmailcow.conf_backup\nrebuild-images.sh\nrefresh_images.sh\nupdate_diffs/\ncreate_cold_standby.sh\n", "#!/bin/bash\nset -e\n\n# Wait for MySQL to warm-up\nwhile ! mysqladmin status --socket=/var/run/mysqld/mysqld.sock -u${DBUSER} -p${DBPASS} --silent; do\n  echo \"Waiting for database to come up...\"\n  sleep 2\ndone\n\nuntil dig +short mailcow.email > /dev/null; do\n  echo \"Waiting for DNS...\"\n  sleep 1\ndone\n\n# Do not attempt to write to slave\nif [[ ! -z ${REDIS_SLAVEOF_IP} ]]; then\n  REDIS_CMDLINE=\"redis-cli -h ${REDIS_SLAVEOF_IP} -p ${REDIS_SLAVEOF_PORT}\"\nelse\n  REDIS_CMDLINE=\"redis-cli -h redis -p 6379\"\nfi\n\nuntil [[ $(${REDIS_CMDLINE} PING) == \"PONG\" ]]; do\n  echo \"Waiting for Redis...\"\n  sleep 2\ndone\n\n${REDIS_CMDLINE} SET DOVECOT_REPL_HEALTH 1 > /dev/null\n\n# Create missing directories\n[[ ! -d /etc/dovecot/sql/ ]] && mkdir -p /etc/dovecot/sql/\n[[ ! -d /etc/dovecot/lua/ ]] && mkdir -p /etc/dovecot/lua/\n[[ ! -d /var/vmail/_garbage ]] && mkdir -p /var/vmail/_garbage\n[[ ! -d /var/vmail/sieve ]] && mkdir -p /var/vmail/sieve\n[[ ! -d /etc/sogo ]] && mkdir -p /etc/sogo\n[[ ! -d /var/volatile ]] && mkdir -p /var/volatile\n\n# Set Dovecot sql config parameters, escape \" in db password\nDBPASS=$(echo ${DBPASS} | sed 's/\"/\\\\\"/g')\n\n# Create quota dict for Dovecot\nif [[ \"${MASTER}\" =~ ^([yY][eE][sS]|[yY])+$ ]]; then\n  QUOTA_TABLE=quota2\nelse\n  QUOTA_TABLE=quota2replica\nfi\ncat <<EOF > /etc/dovecot/sql/dovecot-dict-sql-quota.conf\n# Autogenerated by mailcow\nconnect = \"host=/var/run/mysqld/mysqld.sock dbname=${DBNAME} user=${DBUSER} password=${DBPASS}\"\nmap {\n  pattern = priv/quota/storage\n  table = ${QUOTA_TABLE}\n  username_field = username\n  value_field = bytes\n}\nmap {\n  pattern = priv/quota/messages\n  table = ${QUOTA_TABLE}\n  username_field = username\n  value_field = messages\n}\nEOF\n\n# Create dict used for sieve pre and postfilters\ncat <<EOF > /etc/dovecot/sql/dovecot-dict-sql-sieve_before.conf\n# Autogenerated by mailcow\nconnect = \"host=/var/run/mysqld/mysqld.sock dbname=${DBNAME} user=${DBUSER} password=${DBPASS}\"\nmap {\n  pattern = priv/sieve/name/\\$script_name\n  table = sieve_before\n  username_field = username\n  value_field = id\n  fields {\n    script_name = \\$script_name\n  }\n}\nmap {\n  pattern = priv/sieve/data/\\$id\n  table = sieve_before\n  username_field = username\n  value_field = script_data\n  fields {\n    id = \\$id\n  }\n}\nEOF\n\ncat <<EOF > /etc/dovecot/sql/dovecot-dict-sql-sieve_after.conf\n# Autogenerated by mailcow\nconnect = \"host=/var/run/mysqld/mysqld.sock dbname=${DBNAME} user=${DBUSER} password=${DBPASS}\"\nmap {\n  pattern = priv/sieve/name/\\$script_name\n  table = sieve_after\n  username_field = username\n  value_field = id\n  fields {\n    script_name = \\$script_name\n  }\n}\nmap {\n  pattern = priv/sieve/data/\\$id\n  table = sieve_after\n  username_field = username\n  value_field = script_data\n  fields {\n    id = \\$id\n  }\n}\nEOF\n\necho -n ${ACL_ANYONE} > /etc/dovecot/acl_anyone\n\nif [[ \"${SKIP_SOLR}\" =~ ^([yY][eE][sS]|[yY])+$ ]]; then\necho -n 'quota acl zlib mail_crypt mail_crypt_acl mail_log notify listescape replication' > /etc/dovecot/mail_plugins\necho -n 'quota imap_quota imap_acl acl zlib imap_zlib imap_sieve mail_crypt mail_crypt_acl notify listescape replication mail_log' > /etc/dovecot/mail_plugins_imap\necho -n 'quota sieve acl zlib mail_crypt mail_crypt_acl notify listescape replication' > /etc/dovecot/mail_plugins_lmtp\nelse\necho -n 'quota acl zlib mail_crypt mail_crypt_acl mail_log notify fts fts_solr listescape replication' > /etc/dovecot/mail_plugins\necho -n 'quota imap_quota imap_acl acl zlib imap_zlib imap_sieve mail_crypt mail_crypt_acl notify mail_log fts fts_solr listescape replication' > /etc/dovecot/mail_plugins_imap\necho -n 'quota sieve acl zlib mail_crypt mail_crypt_acl fts fts_solr notify listescape replication' > /etc/dovecot/mail_plugins_lmtp\nfi\nchmod 644 /etc/dovecot/mail_plugins /etc/dovecot/mail_plugins_imap /etc/dovecot/mail_plugins_lmtp /templates/quarantine.tpl\n\ncat <<EOF > /etc/dovecot/sql/dovecot-dict-sql-userdb.conf\n# Autogenerated by mailcow\ndriver = mysql\nconnect = \"host=/var/run/mysqld/mysqld.sock dbname=${DBNAME} user=${DBUSER} password=${DBPASS}\"\nuser_query = SELECT CONCAT(JSON_UNQUOTE(JSON_VALUE(attributes, '$.mailbox_format')), mailbox_path_prefix, '%d/%n/${MAILDIR_SUB}:VOLATILEDIR=/var/volatile/%u:INDEX=/var/vmail_index/%u') AS mail, '%s' AS protocol, 5000 AS uid, 5000 AS gid, concat('*:bytes=', quota) AS quota_rule FROM mailbox WHERE username = '%u' AND (active = '1' OR active = '2')\niterate_query = SELECT username FROM mailbox WHERE active = '1' OR active = '2';\nEOF\n\ncat <<EOF > /etc/dovecot/lua/passwd-verify.lua\nfunction auth_password_verify(req, pass)\n\n  if req.domain == nil then\n    return dovecot.auth.PASSDB_RESULT_USER_UNKNOWN, \"No such user\"\n  end\n\n  if cur == nil then\n    script_init()\n  end\n\n  if req.user == nil then\n    req.user = ''\n  end\n\n  respbody = {}\n\n  -- check against mailbox passwds\n  local cur,errorString = con:execute(string.format([[SELECT password FROM mailbox\n    WHERE username = '%s'\n      AND active = '1'\n      AND domain IN (SELECT domain FROM domain WHERE domain='%s' AND active='1')\n      AND IFNULL(JSON_UNQUOTE(JSON_VALUE(mailbox.attributes, '$.force_pw_update')), 0) != '1'\n      AND IFNULL(JSON_UNQUOTE(JSON_VALUE(attributes, '$.%s_access')), 1) = '1']], con:escape(req.user), con:escape(req.domain), con:escape(req.service)))\n  local row = cur:fetch ({}, \"a\")\n  while row do\n    if req.password_verify(req, row.password, pass) == 1 then\n      con:execute(string.format([[REPLACE INTO sasl_log (service, app_password, username, real_rip)\n        VALUES (\"%s\", 0, \"%s\", \"%s\")]], con:escape(req.service), con:escape(req.user), con:escape(req.real_rip)))\n      cur:close()\n      con:close()\n      return dovecot.auth.PASSDB_RESULT_OK, \"\"\n    end\n    row = cur:fetch (row, \"a\")\n  end\n\n  -- check against app passwds for imap and smtp\n  -- app passwords are only available for imap, smtp, sieve and pop3 when using sasl\n  if req.service == \"smtp\" or req.service == \"imap\" or req.service == \"sieve\" or req.service == \"pop3\" then\n    local cur,errorString = con:execute(string.format([[SELECT app_passwd.id, %s_access AS has_prot_access, app_passwd.password FROM app_passwd\n      INNER JOIN mailbox ON mailbox.username = app_passwd.mailbox\n      WHERE mailbox = '%s'\n        AND app_passwd.active = '1'\n        AND mailbox.active = '1'\n        AND app_passwd.domain IN (SELECT domain FROM domain WHERE domain='%s' AND active='1')]], con:escape(req.service), con:escape(req.user), con:escape(req.domain)))\n    local row = cur:fetch ({}, \"a\")\n    while row do\n      if req.password_verify(req, row.password, pass) == 1 then\n        -- if password is valid and protocol access is 1 OR real_rip matches SOGo, proceed\n        if tostring(req.real_rip) == \"__IPV4_SOGO__\" then\n          cur:close()\n          con:close()\n          return dovecot.auth.PASSDB_RESULT_OK, \"\"\n        elseif row.has_prot_access == \"1\" then\n          con:execute(string.format([[REPLACE INTO sasl_log (service, app_password, username, real_rip)\n            VALUES (\"%s\", %d, \"%s\", \"%s\")]], con:escape(req.service), row.id, con:escape(req.user), con:escape(req.real_rip)))\n          cur:close()\n          con:close()\n          return dovecot.auth.PASSDB_RESULT_OK, \"\"\n        end\n      end\n      row = cur:fetch (row, \"a\")\n    end\n  end\n\n  cur:close()\n  con:close()\n\n  return dovecot.auth.PASSDB_RESULT_PASSWORD_MISMATCH, \"Failed to authenticate\"\n\n  -- PoC\n  -- local reqbody = string.format([[{\n  --   \"success\":0,\n  --   \"service\":\"%s\",\n  --   \"app_password\":false,\n  --   \"username\":\"%s\",\n  --   \"real_rip\":\"%s\"\n  -- }]], con:escape(req.service), con:escape(req.user), con:escape(req.real_rip))\n  -- http.request {\n  --   method = \"POST\",\n  --   url = \"http://nginx:8081/sasl_log.php\",\n  --   source = ltn12.source.string(reqbody),\n  --   headers = {\n  --     [\"content-type\"] = \"application/json\",\n  --     [\"content-length\"] = tostring(#reqbody)\n  --   },\n  --   sink = ltn12.sink.table(respbody)\n  -- }\n\nend\n\nfunction auth_passdb_lookup(req)\n   return dovecot.auth.PASSDB_RESULT_USER_UNKNOWN, \"\"\nend\n\nfunction script_init()\n  mysql = require \"luasql.mysql\"\n  http = require \"socket.http\"\n  http.TIMEOUT = 5\n  ltn12 = require \"ltn12\"\n  env  = mysql.mysql()\n  con = env:connect(\"__DBNAME__\",\"__DBUSER__\",\"__DBPASS__\",\"localhost\")\n  return 0\nend\n\nfunction script_deinit()\n  con:close()\n  env:close()\nend\nEOF\n\n# Replace patterns in app-passdb.lua\nsed -i \"s/__DBUSER__/${DBUSER}/g\" /etc/dovecot/lua/passwd-verify.lua\nsed -i \"s/__DBPASS__/${DBPASS}/g\" /etc/dovecot/lua/passwd-verify.lua\nsed -i \"s/__DBNAME__/${DBNAME}/g\" /etc/dovecot/lua/passwd-verify.lua\nsed -i \"s/__IPV4_SOGO__/${IPV4_NETWORK}.248/g\" /etc/dovecot/lua/passwd-verify.lua\n\n\n# Migrate old sieve_after file\n[[ -f /etc/dovecot/sieve_after ]] && mv /etc/dovecot/sieve_after /etc/dovecot/global_sieve_after\n# Create global sieve scripts\ncat /etc/dovecot/global_sieve_after > /var/vmail/sieve/global_sieve_after.sieve\ncat /etc/dovecot/global_sieve_before > /var/vmail/sieve/global_sieve_before.sieve\n\n# Check permissions of vmail/index/garbage directories.\n# Do not do this every start-up, it may take a very long time. So we use a stat check here.\nif [[ $(stat -c %U /var/vmail/) != \"vmail\" ]] ; then chown -R vmail:vmail /var/vmail ; fi\nif [[ $(stat -c %U /var/vmail/_garbage) != \"vmail\" ]] ; then chown -R vmail:vmail /var/vmail/_garbage ; fi\nif [[ $(stat -c %U /var/vmail_index) != \"vmail\" ]] ; then chown -R vmail:vmail /var/vmail_index ; fi\n\n# Cleanup random user maildirs\nrm -rf /var/vmail/mailcow.local/*\n# Cleanup PIDs\n[[ -f /tmp/quarantine_notify.pid ]] && rm /tmp/quarantine_notify.pid\n\n# create sni configuration\necho \"\" > /etc/dovecot/sni.conf\nfor cert_dir in /etc/ssl/mail/*/ ; do\n  if [[ ! -f ${cert_dir}domains ]] || [[ ! -f ${cert_dir}cert.pem ]] || [[ ! -f ${cert_dir}key.pem ]]; then\n    continue\n  fi\n  domains=($(cat ${cert_dir}domains))\n  for domain in ${domains[@]}; do\n    echo 'local_name '${domain}' {' >> /etc/dovecot/sni.conf;\n    echo '  ssl_cert = <'${cert_dir}'cert.pem' >> /etc/dovecot/sni.conf;\n    echo '  ssl_key = <'${cert_dir}'key.pem' >> /etc/dovecot/sni.conf;\n    echo '}' >> /etc/dovecot/sni.conf;\n  done\ndone\n\n# Create random master for SOGo sieve features\nRAND_USER=$(cat /dev/urandom | tr -dc 'a-z0-9' | fold -w 16 | head -n 1)\nRAND_PASS=$(cat /dev/urandom | tr -dc 'a-z0-9' | fold -w 24 | head -n 1)\n\nif [[ ! -z ${DOVECOT_MASTER_USER} ]] && [[ ! -z ${DOVECOT_MASTER_PASS} ]]; then\n  RAND_USER=${DOVECOT_MASTER_USER}\n  RAND_PASS=${DOVECOT_MASTER_PASS}\nfi\necho ${RAND_USER}@mailcow.local:{SHA1}$(echo -n ${RAND_PASS} | sha1sum | awk '{print $1}'):::::: > /etc/dovecot/dovecot-master.passwd\necho ${RAND_USER}@mailcow.local::5000:5000:::: > /etc/dovecot/dovecot-master.userdb\necho ${RAND_USER}@mailcow.local:${RAND_PASS} > /etc/sogo/sieve.creds\n\nif [[ -z ${MAILDIR_SUB} ]]; then\n  MAILDIR_SUB_SHARED=\nelse\n  MAILDIR_SUB_SHARED=/${MAILDIR_SUB}\nfi\ncat <<EOF > /etc/dovecot/shared_namespace.conf\n# Autogenerated by mailcow\nnamespace {\n    type = shared\n    separator = /\n    prefix = Shared/%%u/\n    location = maildir:%%h${MAILDIR_SUB_SHARED}:INDEX=~${MAILDIR_SUB_SHARED}/Shared/%%u\n    subscriptions = no\n    list = children\n}\nEOF\n\n\ncat <<EOF > /etc/dovecot/sogo_trusted_ip.conf\n# Autogenerated by mailcow\nremote ${IPV4_NETWORK}.248 {\n  disable_plaintext_auth = no\n}\nEOF\n\n# Create random master Password for SOGo SSO\nRAND_PASS=$(cat /dev/urandom | tr -dc 'a-z0-9' | fold -w 32 | head -n 1)\necho -n ${RAND_PASS} > /etc/phpfpm/sogo-sso.pass\ncat <<EOF > /etc/dovecot/sogo-sso.conf\n# Autogenerated by mailcow\npassdb {\n  driver = static\n  args = allow_real_nets=${IPV4_NETWORK}.248/32 password={plain}${RAND_PASS}\n}\nEOF\n\nif [[ \"${MASTER}\" =~ ^([nN][oO]|[nN])+$ ]]; then\n  # Toggling MASTER will result in a rebuild of containers, so the quota script will be recreated\n  cat <<'EOF' > /usr/local/bin/quota_notify.py\n#!/usr/bin/python3\nimport sys\nsys.exit()\nEOF\nfi\n\n# Set mail_replica for HA setups\nif [[ -n ${MAILCOW_REPLICA_IP} && -n ${DOVEADM_REPLICA_PORT} ]]; then\n  cat <<EOF > /etc/dovecot/mail_replica.conf\n# Autogenerated by mailcow\nmail_replica = tcp:${MAILCOW_REPLICA_IP}:${DOVEADM_REPLICA_PORT}\nEOF\nfi\n\n\n# 401 is user dovecot\nif [[ ! -s /mail_crypt/ecprivkey.pem || ! -s /mail_crypt/ecpubkey.pem ]]; then\n\topenssl ecparam -name prime256v1 -genkey | openssl pkey -out /mail_crypt/ecprivkey.pem\n\topenssl pkey -in /mail_crypt/ecprivkey.pem -pubout -out /mail_crypt/ecpubkey.pem\n\tchown 401 /mail_crypt/ecprivkey.pem /mail_crypt/ecpubkey.pem\nelse\n\tchown 401 /mail_crypt/ecprivkey.pem /mail_crypt/ecpubkey.pem\nfi\n\n# Compile sieve scripts\nsievec /var/vmail/sieve/global_sieve_before.sieve\nsievec /var/vmail/sieve/global_sieve_after.sieve\nsievec /usr/lib/dovecot/sieve/report-spam.sieve\nsievec /usr/lib/dovecot/sieve/report-ham.sieve\n\nfor file in /var/vmail/*/*/sieve/*.sieve ; do\n  if [[ \"$file\" == \"/var/vmail/*/*/sieve/*.sieve\" ]]; then\n    continue\n  fi\n  sievec \"$file\" \"$(dirname \"$file\")/../.dovecot.svbin\"\n  chown vmail:vmail \"$(dirname \"$file\")/../.dovecot.svbin\"\ndone\n\n# Fix permissions\nchown root:root /etc/dovecot/sql/*.conf\nchown root:dovecot /etc/dovecot/sql/dovecot-dict-sql-sieve* /etc/dovecot/sql/dovecot-dict-sql-quota* /etc/dovecot/lua/passwd-verify.lua\nchmod 640 /etc/dovecot/sql/*.conf /etc/dovecot/lua/passwd-verify.lua\nchown -R vmail:vmail /var/vmail/sieve\nchown -R vmail:vmail /var/volatile\nchown -R vmail:vmail /var/vmail_index\nadduser vmail tty\nchmod g+rw /dev/console\nchown root:tty /dev/console\nchmod +x /usr/lib/dovecot/sieve/rspamd-pipe-ham \\\n  /usr/lib/dovecot/sieve/rspamd-pipe-spam \\\n  /usr/local/bin/imapsync_runner.pl \\\n  /usr/local/bin/imapsync \\\n  /usr/local/bin/trim_logs.sh \\\n  /usr/local/bin/sa-rules.sh \\\n  /usr/local/bin/clean_q_aged.sh \\\n  /usr/local/bin/maildir_gc.sh \\\n  /usr/local/sbin/stop-supervisor.sh \\\n  /usr/local/bin/quota_notify.py \\\n  /usr/local/bin/repl_health.sh\n\n# Prepare environment file for cronjobs\nprintenv | sed 's/^\\(.*\\)$/export \\1/g' > /source_env.sh\n\n# Clean old PID if any\n[[ -f /var/run/dovecot/master.pid ]] && rm /var/run/dovecot/master.pid\n\n# Clean stopped imapsync jobs\nrm -f /tmp/imapsync_busy.lock\nIMAPSYNC_TABLE=$(mysql --socket=/var/run/mysqld/mysqld.sock -u ${DBUSER} -p${DBPASS} ${DBNAME} -e \"SHOW TABLES LIKE 'imapsync'\" -Bs)\n[[ ! -z ${IMAPSYNC_TABLE} ]] && mysql --socket=/var/run/mysqld/mysqld.sock -u ${DBUSER} -p${DBPASS} ${DBNAME} -e \"UPDATE imapsync SET is_running='0'\"\n\n# Envsubst maildir_gc\necho \"$(envsubst < /usr/local/bin/maildir_gc.sh)\" > /usr/local/bin/maildir_gc.sh\n\n# GUID generation\nwhile [[ ${VERSIONS_OK} != 'OK' ]]; do\n  if [[ ! -z $(mysql --socket=/var/run/mysqld/mysqld.sock -u ${DBUSER} -p${DBPASS} ${DBNAME} -B -e \"SELECT 'OK' FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = \\\"${DBNAME}\\\" AND TABLE_NAME = 'versions'\") ]]; then\n    VERSIONS_OK=OK\n  else\n    echo \"Waiting for versions table to be created...\"\n    sleep 3\n  fi\ndone\nPUBKEY_MCRYPT=$(doveconf -P 2> /dev/null | grep -i mail_crypt_global_public_key | cut -d '<' -f2)\nif [ -f ${PUBKEY_MCRYPT} ]; then\n  GUID=$(cat <(echo ${MAILCOW_HOSTNAME}) /mail_crypt/ecpubkey.pem | sha256sum | cut -d ' ' -f1 | tr -cd \"[a-fA-F0-9.:/] \")\n  if [ ${#GUID} -eq 64 ]; then\n    mysql --socket=/var/run/mysqld/mysqld.sock -u ${DBUSER} -p${DBPASS} ${DBNAME} << EOF\nREPLACE INTO versions (application, version) VALUES (\"GUID\", \"${GUID}\");\nEOF\n  else\n    mysql --socket=/var/run/mysqld/mysqld.sock -u ${DBUSER} -p${DBPASS} ${DBNAME} << EOF\nREPLACE INTO versions (application, version) VALUES (\"GUID\", \"INVALID\");\nEOF\n  fi\nfi\n\n# Collect SA rules once now\n/usr/local/bin/sa-rules.sh\n\n# Run hooks\nfor file in /hooks/*; do\n  if [ -x \"${file}\" ]; then\n    echo \"Running hook ${file}\"\n    \"${file}\"\n  fi\ndone\n\n# For some strange, unknown and stupid reason, Dovecot may run into a race condition, when this file is not touched before it is read by dovecot/auth\n# May be related to something inside Docker, I seriously don't know\ntouch /etc/dovecot/lua/passwd-verify.lua\n\nif [[ ! -z ${REDIS_SLAVEOF_IP} ]]; then\n  cp /etc/syslog-ng/syslog-ng-redis_slave.conf /etc/syslog-ng/syslog-ng.conf\nfi\n\nexec \"$@\"\n", "#!/usr/bin/env python3\r\n\r\nimport re\r\nimport os\r\nimport sys\r\nimport time\r\nimport atexit\r\nimport signal\r\nimport ipaddress\r\nfrom collections import Counter\r\nfrom random import randint\r\nfrom threading import Thread\r\nfrom threading import Lock\r\nimport redis\r\nimport json\r\nimport dns.resolver\r\nimport dns.exception\r\nimport uuid\r\nfrom modules.Logger import Logger\r\nfrom modules.IPTables import IPTables\r\nfrom modules.NFTables import NFTables\r\n\r\n\r\n# globals\r\nWHITELIST = []\r\nBLACKLIST= []\r\nbans = {}\r\nquit_now = False\r\nexit_code = 0\r\nlock = Lock()\r\nchain_name = \"MAILCOW\"\r\nr = None\r\npubsub = None\r\nclear_before_quit = False\r\n\r\n\r\ndef refreshF2boptions():\r\n  global f2boptions\r\n  global quit_now\r\n  global exit_code\r\n\r\n  f2boptions = {}\r\n\r\n  if not r.get('F2B_OPTIONS'):\r\n    f2boptions['ban_time'] = r.get('F2B_BAN_TIME')\r\n    f2boptions['max_ban_time'] = r.get('F2B_MAX_BAN_TIME')\r\n    f2boptions['ban_time_increment'] = r.get('F2B_BAN_TIME_INCREMENT')\r\n    f2boptions['max_attempts'] = r.get('F2B_MAX_ATTEMPTS')\r\n    f2boptions['retry_window'] = r.get('F2B_RETRY_WINDOW')\r\n    f2boptions['netban_ipv4'] = r.get('F2B_NETBAN_IPV4')\r\n    f2boptions['netban_ipv6'] = r.get('F2B_NETBAN_IPV6')\r\n  else:\r\n    try:\r\n      f2boptions = json.loads(r.get('F2B_OPTIONS'))\r\n    except ValueError:\r\n      logger.logCrit('Error loading F2B options: F2B_OPTIONS is not json')\r\n      quit_now = True\r\n      exit_code = 2\r\n\r\n  verifyF2boptions(f2boptions)\r\n  r.set('F2B_OPTIONS', json.dumps(f2boptions, ensure_ascii=False))\r\n\r\ndef verifyF2boptions(f2boptions):\r\n  verifyF2boption(f2boptions,'ban_time', 1800)\r\n  verifyF2boption(f2boptions,'max_ban_time', 10000)\r\n  verifyF2boption(f2boptions,'ban_time_increment', True)\r\n  verifyF2boption(f2boptions,'max_attempts', 10)\r\n  verifyF2boption(f2boptions,'retry_window', 600)\r\n  verifyF2boption(f2boptions,'netban_ipv4', 32)\r\n  verifyF2boption(f2boptions,'netban_ipv6', 128)\r\n  verifyF2boption(f2boptions,'banlist_id', str(uuid.uuid4()))\r\n  verifyF2boption(f2boptions,'manage_external', 0)\r\n\r\ndef verifyF2boption(f2boptions, f2boption, f2bdefault):\r\n  f2boptions[f2boption] = f2boptions[f2boption] if f2boption in f2boptions and f2boptions[f2boption] is not None else f2bdefault\r\n\r\ndef refreshF2bregex():\r\n  global f2bregex\r\n  global quit_now\r\n  global exit_code\r\n  if not r.get('F2B_REGEX'):\r\n    f2bregex = {}\r\n    f2bregex[1] = 'mailcow UI: Invalid password for .+ by ([0-9a-f\\.:]+)'\r\n    f2bregex[2] = 'Rspamd UI: Invalid password by ([0-9a-f\\.:]+)'\r\n    f2bregex[3] = 'warning: .*\\[([0-9a-f\\.:]+)\\]: SASL .+ authentication failed: (?!.*Connection lost to authentication server).+'\r\n    f2bregex[4] = 'warning: non-SMTP command from .*\\[([0-9a-f\\.:]+)]:.+'\r\n    f2bregex[5] = 'NOQUEUE: reject: RCPT from \\[([0-9a-f\\.:]+)].+Protocol error.+'\r\n    f2bregex[6] = '-login: Disconnected.+ \\(auth failed, .+\\): user=.*, method=.+, rip=([0-9a-f\\.:]+),'\r\n    f2bregex[7] = '-login: Aborted login.+ \\(auth failed .+\\): user=.+, rip=([0-9a-f\\.:]+), lip.+'\r\n    f2bregex[8] = '-login: Aborted login.+ \\(tried to use disallowed .+\\): user=.+, rip=([0-9a-f\\.:]+), lip.+'\r\n    f2bregex[9] = 'SOGo.+ Login from \\'([0-9a-f\\.:]+)\\' for user .+ might not have worked'\r\n    f2bregex[10] = '([0-9a-f\\.:]+) \\\"GET \\/SOGo\\/.* HTTP.+\\\" 403 .+'\r\n    r.set('F2B_REGEX', json.dumps(f2bregex, ensure_ascii=False))\r\n  else:\r\n    try:\r\n      f2bregex = {}\r\n      f2bregex = json.loads(r.get('F2B_REGEX'))\r\n    except ValueError:\r\n      logger.logCrit('Error loading F2B options: F2B_REGEX is not json')\r\n      quit_now = True\r\n      exit_code = 2\r\n\r\ndef get_ip(address):\r\n  ip = ipaddress.ip_address(address)\r\n  if type(ip) is ipaddress.IPv6Address and ip.ipv4_mapped:\r\n    ip = ip.ipv4_mapped\r\n  if ip.is_private or ip.is_loopback:\r\n    return False\r\n  \r\n  return ip\r\n\r\ndef ban(address):\r\n  global f2boptions\r\n  global lock\r\n\r\n  refreshF2boptions()\r\n  BAN_TIME = int(f2boptions['ban_time'])\r\n  BAN_TIME_INCREMENT = bool(f2boptions['ban_time_increment'])\r\n  MAX_ATTEMPTS = int(f2boptions['max_attempts'])\r\n  RETRY_WINDOW = int(f2boptions['retry_window'])\r\n  NETBAN_IPV4 = '/' + str(f2boptions['netban_ipv4'])\r\n  NETBAN_IPV6 = '/' + str(f2boptions['netban_ipv6'])\r\n\r\n  ip = get_ip(address)\r\n  if not ip: return\r\n  address = str(ip)\r\n  self_network = ipaddress.ip_network(address)\r\n\r\n  with lock:\r\n    temp_whitelist = set(WHITELIST)\r\n  if temp_whitelist:\r\n    for wl_key in temp_whitelist:\r\n      wl_net = ipaddress.ip_network(wl_key, False)\r\n      if wl_net.overlaps(self_network):\r\n        logger.logInfo('Address %s is whitelisted by rule %s' % (self_network, wl_net))\r\n        return\r\n\r\n  net = ipaddress.ip_network((address + (NETBAN_IPV4 if type(ip) is ipaddress.IPv4Address else NETBAN_IPV6)), strict=False)\r\n  net = str(net)\r\n\r\n  if not net in bans:\r\n    bans[net] = {'attempts': 0, 'last_attempt': 0, 'ban_counter': 0}\r\n\r\n  current_attempt = time.time()\r\n  if current_attempt - bans[net]['last_attempt'] > RETRY_WINDOW:\r\n    bans[net]['attempts'] = 0\r\n\r\n  bans[net]['attempts'] += 1\r\n  bans[net]['last_attempt'] = current_attempt\r\n\r\n  if bans[net]['attempts'] >= MAX_ATTEMPTS:\r\n    cur_time = int(round(time.time()))\r\n    NET_BAN_TIME = BAN_TIME if not BAN_TIME_INCREMENT else BAN_TIME * 2 ** bans[net]['ban_counter']\r\n    logger.logCrit('Banning %s for %d minutes' % (net, NET_BAN_TIME / 60 ))\r\n    if type(ip) is ipaddress.IPv4Address and int(f2boptions['manage_external']) != 1:\r\n      with lock:\r\n        tables.banIPv4(net)\r\n    elif int(f2boptions['manage_external']) != 1:\r\n      with lock:\r\n        tables.banIPv6(net)\r\n\r\n    r.hset('F2B_ACTIVE_BANS', '%s' % net, cur_time + NET_BAN_TIME)\r\n  else:\r\n    logger.logWarn('%d more attempts in the next %d seconds until %s is banned' % (MAX_ATTEMPTS - bans[net]['attempts'], RETRY_WINDOW, net))\r\n\r\ndef unban(net):\r\n  global lock\r\n\r\n  if not net in bans:\r\n   logger.logInfo('%s is not banned, skipping unban and deleting from queue (if any)' % net)\r\n   r.hdel('F2B_QUEUE_UNBAN', '%s' % net)\r\n   return\r\n\r\n  logger.logInfo('Unbanning %s' % net)\r\n  if type(ipaddress.ip_network(net)) is ipaddress.IPv4Network:\r\n    with lock:\r\n      tables.unbanIPv4(net)\r\n  else:\r\n    with lock:\r\n      tables.unbanIPv6(net)\r\n\r\n  r.hdel('F2B_ACTIVE_BANS', '%s' % net)\r\n  r.hdel('F2B_QUEUE_UNBAN', '%s' % net)\r\n  if net in bans:\r\n    bans[net]['attempts'] = 0\r\n    bans[net]['ban_counter'] += 1\r\n\r\ndef permBan(net, unban=False):\r\n  global f2boptions\r\n  global lock\r\n\r\n  is_unbanned = False\r\n  is_banned = False\r\n  if type(ipaddress.ip_network(net, strict=False)) is ipaddress.IPv4Network:\r\n    with lock:\r\n      if unban:\r\n        is_unbanned = tables.unbanIPv4(net)\r\n      elif int(f2boptions['manage_external']) != 1:\r\n        is_banned = tables.banIPv4(net)\r\n  else:\r\n    with lock:\r\n      if unban:\r\n        is_unbanned = tables.unbanIPv6(net)\r\n      elif int(f2boptions['manage_external']) != 1:\r\n        is_banned = tables.banIPv6(net)\r\n\r\n\r\n  if is_unbanned:\r\n    r.hdel('F2B_PERM_BANS', '%s' % net)\r\n    logger.logCrit('Removed host/network %s from blacklist' % net)\r\n  elif is_banned:\r\n    r.hset('F2B_PERM_BANS', '%s' % net, int(round(time.time())))\r\n    logger.logCrit('Added host/network %s to blacklist' % net)\r\n\r\ndef clear():\r\n  global lock\r\n  logger.logInfo('Clearing all bans')\r\n  for net in bans.copy():\r\n    unban(net)\r\n  with lock:\r\n    tables.clearIPv4Table()\r\n    tables.clearIPv6Table()\r\n    try:\r\n      if r is not None:\r\n        r.delete('F2B_ACTIVE_BANS')\r\n        r.delete('F2B_PERM_BANS')\r\n    except Exception as ex:\r\n      logger.logWarn('Error clearing redis keys F2B_ACTIVE_BANS and F2B_PERM_BANS: %s' % ex)\r\n\r\ndef watch():\r\n  global pubsub\r\n  global quit_now\r\n  global exit_code\r\n\r\n  logger.logInfo('Watching Redis channel F2B_CHANNEL')\r\n  pubsub.subscribe('F2B_CHANNEL')\r\n\r\n  while not quit_now:\r\n    try:\r\n      for item in pubsub.listen():\r\n        refreshF2bregex()\r\n        for rule_id, rule_regex in f2bregex.items():\r\n          if item['data'] and item['type'] == 'message':\r\n            try:\r\n              result = re.search(rule_regex, item['data'])\r\n            except re.error:\r\n              result = False\r\n            if result:\r\n              addr = result.group(1)\r\n              ip = ipaddress.ip_address(addr)\r\n              if ip.is_private or ip.is_loopback:\r\n                continue\r\n              logger.logWarn('%s matched rule id %s (%s)' % (addr, rule_id, item['data']))\r\n              ban(addr)\r\n    except Exception as ex:\r\n      logger.logWarn('Error reading log line from pubsub: %s' % ex)\r\n      pubsub = None\r\n      quit_now = True\r\n      exit_code = 2\r\n\r\ndef snat4(snat_target):\r\n  global lock\r\n  global quit_now\r\n\r\n  while not quit_now:\r\n    time.sleep(10)\r\n    with lock:\r\n      tables.snat4(snat_target, os.getenv('IPV4_NETWORK', '172.22.1') + '.0/24')\r\n\r\ndef snat6(snat_target):\r\n  global lock\r\n  global quit_now\r\n\r\n  while not quit_now:\r\n    time.sleep(10)\r\n    with lock:\r\n      tables.snat6(snat_target, os.getenv('IPV6_NETWORK', 'fd4d:6169:6c63:6f77::/64'))\r\n\r\ndef autopurge():\r\n  while not quit_now:\r\n    time.sleep(10)\r\n    refreshF2boptions()\r\n    BAN_TIME = int(f2boptions['ban_time'])\r\n    MAX_BAN_TIME = int(f2boptions['max_ban_time'])\r\n    BAN_TIME_INCREMENT = bool(f2boptions['ban_time_increment'])\r\n    MAX_ATTEMPTS = int(f2boptions['max_attempts'])\r\n    QUEUE_UNBAN = r.hgetall('F2B_QUEUE_UNBAN')\r\n    if QUEUE_UNBAN:\r\n      for net in QUEUE_UNBAN:\r\n        unban(str(net))\r\n    for net in bans.copy():\r\n      if bans[net]['attempts'] >= MAX_ATTEMPTS:\r\n        NET_BAN_TIME = BAN_TIME if not BAN_TIME_INCREMENT else BAN_TIME * 2 ** bans[net]['ban_counter']\r\n        TIME_SINCE_LAST_ATTEMPT = time.time() - bans[net]['last_attempt']\r\n        if TIME_SINCE_LAST_ATTEMPT > NET_BAN_TIME or TIME_SINCE_LAST_ATTEMPT > MAX_BAN_TIME:\r\n          unban(net)\r\n\r\ndef mailcowChainOrder():\r\n  global lock\r\n  global quit_now\r\n  global exit_code\r\n  while not quit_now:\r\n    time.sleep(10)\r\n    with lock:\r\n      quit_now, exit_code = tables.checkIPv4ChainOrder()\r\n      if quit_now: return\r\n      quit_now, exit_code = tables.checkIPv6ChainOrder()\r\n\r\ndef isIpNetwork(address):\r\n  try:\r\n    ipaddress.ip_network(address, False)\r\n  except ValueError:\r\n    return False\r\n  return True\r\n\r\ndef genNetworkList(list):\r\n  resolver = dns.resolver.Resolver()\r\n  hostnames = []\r\n  networks = []\r\n  for key in list:\r\n    if isIpNetwork(key):\r\n      networks.append(key)\r\n    else:\r\n      hostnames.append(key)\r\n  for hostname in hostnames:\r\n    hostname_ips = []\r\n    for rdtype in ['A', 'AAAA']:\r\n      try:\r\n        answer = resolver.resolve(qname=hostname, rdtype=rdtype, lifetime=3)\r\n      except dns.exception.Timeout:\r\n        logger.logInfo('Hostname %s timedout on resolve' % hostname)\r\n        break\r\n      except (dns.resolver.NXDOMAIN, dns.resolver.NoAnswer):\r\n        continue\r\n      except dns.exception.DNSException as dnsexception:\r\n        logger.logInfo('%s' % dnsexception)\r\n        continue\r\n      for rdata in answer:\r\n        hostname_ips.append(rdata.to_text())\r\n    networks.extend(hostname_ips)\r\n  return set(networks)\r\n\r\ndef whitelistUpdate():\r\n  global lock\r\n  global quit_now\r\n  global WHITELIST\r\n  while not quit_now:\r\n    start_time = time.time()\r\n    list = r.hgetall('F2B_WHITELIST')\r\n    new_whitelist = []\r\n    if list:\r\n      new_whitelist = genNetworkList(list)\r\n    with lock:\r\n      if Counter(new_whitelist) != Counter(WHITELIST):\r\n        WHITELIST = new_whitelist\r\n        logger.logInfo('Whitelist was changed, it has %s entries' % len(WHITELIST))\r\n    time.sleep(60.0 - ((time.time() - start_time) % 60.0))\r\n\r\ndef blacklistUpdate():\r\n  global quit_now\r\n  global BLACKLIST\r\n  while not quit_now:\r\n    start_time = time.time()\r\n    list = r.hgetall('F2B_BLACKLIST')\r\n    new_blacklist = []\r\n    if list:\r\n      new_blacklist = genNetworkList(list)\r\n    if Counter(new_blacklist) != Counter(BLACKLIST):\r\n      addban = set(new_blacklist).difference(BLACKLIST)\r\n      delban = set(BLACKLIST).difference(new_blacklist)\r\n      BLACKLIST = new_blacklist\r\n      logger.logInfo('Blacklist was changed, it has %s entries' % len(BLACKLIST))\r\n      if addban:\r\n        for net in addban:\r\n          permBan(net=net)\r\n      if delban:\r\n        for net in delban:\r\n          permBan(net=net, unban=True)\r\n    time.sleep(60.0 - ((time.time() - start_time) % 60.0))\r\n\r\ndef sigterm_quit(signum, frame):\r\n  global clear_before_quit\r\n  clear_before_quit = True\r\n  sys.exit(exit_code)\r\n\r\ndef berfore_quit():\r\n  if clear_before_quit:\r\n    clear()\r\n  if pubsub is not None:\r\n    pubsub.unsubscribe()\r\n\r\n\r\nif __name__ == '__main__':\r\n  atexit.register(berfore_quit)\r\n  signal.signal(signal.SIGTERM, sigterm_quit)\r\n\r\n  # init Logger\r\n  logger = Logger(None)\r\n\r\n  # init backend\r\n  backend = sys.argv[1]\r\n  if backend == \"nftables\":\r\n    logger.logInfo('Using NFTables backend')\r\n    tables = NFTables(chain_name, logger)\r\n  else:\r\n    logger.logInfo('Using IPTables backend')\r\n    tables = IPTables(chain_name, logger)\r\n\r\n  # In case a previous session was killed without cleanup\r\n  clear()\r\n\r\n  # Reinit MAILCOW chain\r\n  # Is called before threads start, no locking\r\n  logger.logInfo(\"Initializing mailcow netfilter chain\")\r\n  tables.initChainIPv4()\r\n  tables.initChainIPv6()\r\n\r\n  if os.getenv(\"DISABLE_NETFILTER_ISOLATION_RULE\").lower() in (\"y\", \"yes\"):\r\n    logger.logInfo(f\"Skipping {chain_name} isolation\")\r\n  else:\r\n    logger.logInfo(f\"Setting {chain_name} isolation\")\r\n    tables.create_mailcow_isolation_rule(\"br-mailcow\", [3306, 6379, 8983, 12345], os.getenv(\"MAILCOW_REPLICA_IP\"))\r\n\r\n  # connect to redis\r\n  while True:\r\n    try:\r\n      redis_slaveof_ip = os.getenv('REDIS_SLAVEOF_IP', '')\r\n      redis_slaveof_port = os.getenv('REDIS_SLAVEOF_PORT', '')\r\n      if \"\".__eq__(redis_slaveof_ip):\r\n        r = redis.StrictRedis(host=os.getenv('IPV4_NETWORK', '172.22.1') + '.249', decode_responses=True, port=6379, db=0)\r\n      else:\r\n        r = redis.StrictRedis(host=redis_slaveof_ip, decode_responses=True, port=redis_slaveof_port, db=0)\r\n      r.ping()\r\n      pubsub = r.pubsub()\r\n    except Exception as ex:\r\n      print('%s - trying again in 3 seconds'  % (ex))\r\n      time.sleep(3)\r\n    else:\r\n      break\r\n  Logger.r = r\r\n\r\n  # rename fail2ban to netfilter\r\n  if r.exists('F2B_LOG'):\r\n    r.rename('F2B_LOG', 'NETFILTER_LOG')\r\n  # clear bans in redis\r\n  r.delete('F2B_ACTIVE_BANS')\r\n  r.delete('F2B_PERM_BANS')\r\n  \r\n  refreshF2boptions()\r\n\r\n  watch_thread = Thread(target=watch)\r\n  watch_thread.daemon = True\r\n  watch_thread.start()\r\n\r\n  if os.getenv('SNAT_TO_SOURCE') and os.getenv('SNAT_TO_SOURCE') != 'n':\r\n    try:\r\n      snat_ip = os.getenv('SNAT_TO_SOURCE')\r\n      snat_ipo = ipaddress.ip_address(snat_ip)\r\n      if type(snat_ipo) is ipaddress.IPv4Address:\r\n        snat4_thread = Thread(target=snat4,args=(snat_ip,))\r\n        snat4_thread.daemon = True\r\n        snat4_thread.start()\r\n    except ValueError:\r\n      print(os.getenv('SNAT_TO_SOURCE') + ' is not a valid IPv4 address')\r\n\r\n  if os.getenv('SNAT6_TO_SOURCE') and os.getenv('SNAT6_TO_SOURCE') != 'n':\r\n    try:\r\n      snat_ip = os.getenv('SNAT6_TO_SOURCE')\r\n      snat_ipo = ipaddress.ip_address(snat_ip)\r\n      if type(snat_ipo) is ipaddress.IPv6Address:\r\n        snat6_thread = Thread(target=snat6,args=(snat_ip,))\r\n        snat6_thread.daemon = True\r\n        snat6_thread.start()\r\n    except ValueError:\r\n      print(os.getenv('SNAT6_TO_SOURCE') + ' is not a valid IPv6 address')\r\n\r\n  autopurge_thread = Thread(target=autopurge)\r\n  autopurge_thread.daemon = True\r\n  autopurge_thread.start()\r\n\r\n  mailcowchainwatch_thread = Thread(target=mailcowChainOrder)\r\n  mailcowchainwatch_thread.daemon = True\r\n  mailcowchainwatch_thread.start()\r\n\r\n  blacklistupdate_thread = Thread(target=blacklistUpdate)\r\n  blacklistupdate_thread.daemon = True\r\n  blacklistupdate_thread.start()\r\n\r\n  whitelistupdate_thread = Thread(target=whitelistUpdate)\r\n  whitelistupdate_thread.daemon = True\r\n  whitelistupdate_thread.start()\r\n\r\n  while not quit_now:\r\n    time.sleep(0.5)\r\n\r\n  sys.exit(exit_code)\r\n", "import iptc\nimport time\nimport os\n\nclass IPTables:\n  def __init__(self, chain_name, logger):\n    self.chain_name = chain_name\n    self.logger = logger\n\n  def initChainIPv4(self):\n    if not iptc.Chain(iptc.Table(iptc.Table.FILTER), self.chain_name) in iptc.Table(iptc.Table.FILTER).chains:\n      iptc.Table(iptc.Table.FILTER).create_chain(self.chain_name)\n    for c in ['FORWARD', 'INPUT']:\n      chain = iptc.Chain(iptc.Table(iptc.Table.FILTER), c)\n      rule = iptc.Rule()\n      rule.src = '0.0.0.0/0'\n      rule.dst = '0.0.0.0/0'\n      target = iptc.Target(rule, self.chain_name)\n      rule.target = target\n      if rule not in chain.rules:\n        chain.insert_rule(rule)\n\n  def initChainIPv6(self):\n    if not iptc.Chain(iptc.Table6(iptc.Table6.FILTER), self.chain_name) in iptc.Table6(iptc.Table6.FILTER).chains:\n      iptc.Table6(iptc.Table6.FILTER).create_chain(self.chain_name)\n    for c in ['FORWARD', 'INPUT']:\n      chain = iptc.Chain(iptc.Table6(iptc.Table6.FILTER), c)\n      rule = iptc.Rule6()\n      rule.src = '::/0'\n      rule.dst = '::/0'\n      target = iptc.Target(rule, self.chain_name)\n      rule.target = target\n      if rule not in chain.rules:\n        chain.insert_rule(rule)\n\n  def checkIPv4ChainOrder(self):\n    filter_table = iptc.Table(iptc.Table.FILTER)\n    filter_table.refresh()\n    return self.checkChainOrder(filter_table)\n\n  def checkIPv6ChainOrder(self):\n    filter_table = iptc.Table6(iptc.Table6.FILTER)\n    filter_table.refresh()\n    return self.checkChainOrder(filter_table)\n\n  def checkChainOrder(self, filter_table):\n    err = False\n    exit_code = None\n\n    forward_chain = iptc.Chain(filter_table, 'FORWARD')\n    input_chain = iptc.Chain(filter_table, 'INPUT')\n    for chain in [forward_chain, input_chain]:\n      target_found = False\n      for position, item in enumerate(chain.rules):\n        if item.target.name == self.chain_name:\n          target_found = True\n          if position > 2:\n            self.logger.logCrit('Error in %s chain: %s target not found, restarting container' % (chain.name, self.chain_name))\n            err = True\n            exit_code = 2\n      if not target_found:\n        self.logger.logCrit('Error in %s chain: %s target not found, restarting container' % (chain.name, self.chain_name))\n        err = True\n        exit_code = 2\n\n    return err, exit_code\n\n  def clearIPv4Table(self):\n    self.clearTable(iptc.Table(iptc.Table.FILTER))\n\n  def clearIPv6Table(self):\n    self.clearTable(iptc.Table6(iptc.Table6.FILTER))\n\n  def clearTable(self, filter_table):\n    filter_table.autocommit = False\n    forward_chain = iptc.Chain(filter_table, \"FORWARD\")\n    input_chain = iptc.Chain(filter_table, \"INPUT\")\n    mailcow_chain = iptc.Chain(filter_table, self.chain_name)\n    if mailcow_chain in filter_table.chains:\n      for rule in mailcow_chain.rules:\n        mailcow_chain.delete_rule(rule)\n      for rule in forward_chain.rules:\n        if rule.target.name == self.chain_name:\n          forward_chain.delete_rule(rule)\n      for rule in input_chain.rules:\n        if rule.target.name == self.chain_name:\n          input_chain.delete_rule(rule)\n      filter_table.delete_chain(self.chain_name)\n    filter_table.commit()\n    filter_table.refresh()\n    filter_table.autocommit = True\n\n  def banIPv4(self, source):\n    chain = iptc.Chain(iptc.Table(iptc.Table.FILTER), self.chain_name)\n    rule = iptc.Rule()\n    rule.src = source\n    target = iptc.Target(rule, \"REJECT\")\n    rule.target = target\n    if rule in chain.rules:\n      return False\n    chain.insert_rule(rule)\n    return True\n\n  def banIPv6(self, source):\n    chain = iptc.Chain(iptc.Table6(iptc.Table6.FILTER), self.chain_name)\n    rule = iptc.Rule6()\n    rule.src = source\n    target = iptc.Target(rule, \"REJECT\")\n    rule.target = target\n    if rule in chain.rules:\n      return False\n    chain.insert_rule(rule)\n    return True\n\n  def unbanIPv4(self, source):\n    chain = iptc.Chain(iptc.Table(iptc.Table.FILTER), self.chain_name)\n    rule = iptc.Rule()\n    rule.src = source\n    target = iptc.Target(rule, \"REJECT\")\n    rule.target = target\n    if rule not in chain.rules: \n      return False\n    chain.delete_rule(rule)\n    return True\n\n  def unbanIPv6(self, source):\n    chain = iptc.Chain(iptc.Table6(iptc.Table6.FILTER), self.chain_name)\n    rule = iptc.Rule6()\n    rule.src = source\n    target = iptc.Target(rule, \"REJECT\")\n    rule.target = target\n    if rule not in chain.rules:\n      return False\n    chain.delete_rule(rule)\n    return True\n\n  def snat4(self, snat_target, source):\n    try:\n      table = iptc.Table('nat')\n      table.refresh()\n      chain = iptc.Chain(table, 'POSTROUTING')\n      table.autocommit = False\n      new_rule = self.getSnat4Rule(snat_target, source)\n\n      if not chain.rules:\n        # if there are no rules in the chain, insert the new rule directly\n        self.logger.logInfo(f'Added POSTROUTING rule for source network {new_rule.src} to SNAT target {snat_target}')\n        chain.insert_rule(new_rule)\n      else:\n        for position, rule in enumerate(chain.rules):\n          if not hasattr(rule.target, 'parameter'):\n              continue\n          match = all((\n            new_rule.get_src() == rule.get_src(),\n            new_rule.get_dst() == rule.get_dst(),\n            new_rule.target.parameters == rule.target.parameters,\n            new_rule.target.name == rule.target.name\n          ))\n          if position == 0:\n            if not match:\n              self.logger.logInfo(f'Added POSTROUTING rule for source network {new_rule.src} to SNAT target {snat_target}')\n              chain.insert_rule(new_rule)\n          else:\n            if match:\n              self.logger.logInfo(f'Remove rule for source network {new_rule.src} to SNAT target {snat_target} from POSTROUTING chain at position {position}')\n              chain.delete_rule(rule)\n\n      table.commit()\n      table.autocommit = True\n      return True\n    except:\n      self.logger.logCrit('Error running SNAT4, retrying...')\n      return False\n\n  def snat6(self, snat_target, source):\n    try:\n      table = iptc.Table6('nat')\n      table.refresh()\n      chain = iptc.Chain(table, 'POSTROUTING')\n      table.autocommit = False\n      new_rule = self.getSnat6Rule(snat_target, source)\n\n      if new_rule not in chain.rules:\n        self.logger.logInfo('Added POSTROUTING rule for source network %s to SNAT target %s' % (new_rule.src, snat_target))\n        chain.insert_rule(new_rule)\n      else:\n        for position, item in enumerate(chain.rules):\n          if item == new_rule:\n            if position != 0:\n              chain.delete_rule(new_rule)\n    \n      table.commit()\n      table.autocommit = True\n    except:\n      self.logger.logCrit('Error running SNAT6, retrying...')\n\n\n  def getSnat4Rule(self, snat_target, source):\n    rule = iptc.Rule()\n    rule.src = source\n    rule.dst = '!' + rule.src\n    target = rule.create_target(\"SNAT\")\n    target.to_source = snat_target\n    match = rule.create_match(\"comment\")\n    match.comment = f'{int(round(time.time()))}'\n    return rule\n\n  def getSnat6Rule(self, snat_target, source):\n    rule = iptc.Rule6()\n    rule.src = source\n    rule.dst = '!' + rule.src\n    target = rule.create_target(\"SNAT\")\n    target.to_source = snat_target\n    return rule\n\n  def create_mailcow_isolation_rule(self, _interface:str, _dports:list, _allow:str = \"\"):\n    try:\n      chain = iptc.Chain(iptc.Table(iptc.Table.FILTER), self.chain_name)\n\n      # insert mailcow isolation rule\n      rule = iptc.Rule()\n      rule.in_interface = f'! {_interface}'\n      rule.out_interface = _interface\n      rule.protocol = 'tcp'\n      rule.create_target(\"DROP\")\n      match = rule.create_match(\"multiport\")\n      match.dports = ','.join(map(str, _dports))\n\n      if rule in chain.rules:\n        chain.delete_rule(rule)\n      chain.insert_rule(rule, position=0)\n\n      # insert mailcow isolation exception rule\n      if _allow != \"\":\n        rule = iptc.Rule()\n        rule.src = _allow\n        rule.in_interface = f'! {_interface}'\n        rule.out_interface = _interface\n        rule.protocol = 'tcp'\n        rule.create_target(\"ACCEPT\")\n        match = rule.create_match(\"multiport\")\n        match.dports = ','.join(map(str, _dports))\n\n        if rule in chain.rules:\n          chain.delete_rule(rule)\n        chain.insert_rule(rule, position=0)\n\n\n      return True\n    except Exception as e:\n      self.logger.logCrit(f\"Error adding {self.chain_name} isolation: {e}\")\n      return False", "import time\nimport json\n\nclass Logger:\n  def __init__(self, redis):\n    self.r = redis\n\n  def log(self, priority, message):\n    tolog = {}\n    tolog['time'] = int(round(time.time()))\n    tolog['priority'] = priority\n    tolog['message'] = message\n    if self.r:\n      self.r.lpush('NETFILTER_LOG', json.dumps(tolog, ensure_ascii=False))\n    print(message)\n\n  def logWarn(self, message):\n    self.log('warn', message)\n\n  def logCrit(self, message):\n    self.log('crit', message)\n\n  def logInfo(self, message):\n    self.log('info', message)\n", "import nftables\nimport ipaddress\nimport os\n\nclass NFTables:\n  def __init__(self, chain_name, logger):\n    self.chain_name = chain_name\n    self.logger = logger\n\n    self.nft = nftables.Nftables()\n    self.nft.set_json_output(True)\n    self.nft.set_handle_output(True)\n    self.nft_chain_names = {'ip': {'filter': {'input': '', 'forward': ''}, 'nat': {'postrouting': ''} },\n                            'ip6': {'filter': {'input': '', 'forward': ''}, 'nat': {'postrouting': ''} } }\n\n    self.search_current_chains()\n\n  def initChainIPv4(self):\n    self.insert_mailcow_chains(\"ip\")\n\n  def initChainIPv6(self):\n    self.insert_mailcow_chains(\"ip6\")\n\n  def checkIPv4ChainOrder(self):\n    return self.checkChainOrder(\"ip\")\n\n  def checkIPv6ChainOrder(self):\n    return self.checkChainOrder(\"ip6\")\n\n  def checkChainOrder(self, filter_table):\n    err = False\n    exit_code = None\n\n    for chain in ['input', 'forward']:\n      chain_position = self.check_mailcow_chains(filter_table, chain)\n      if chain_position is None: continue\n\n      if chain_position is False:\n        self.logger.logCrit(f'MAILCOW target not found in {filter_table} {chain} table, restarting container to fix it...')\n        err = True\n        exit_code = 2\n\n      if chain_position > 0:\n        self.logger.logCrit(f'MAILCOW target is in position {chain_position} in the {filter_table} {chain} table, restarting container to fix it...')\n        err = True\n        exit_code = 2\n\n    return err, exit_code\n\n  def clearIPv4Table(self):\n    self.clearTable(\"ip\")\n\n  def clearIPv6Table(self):\n    self.clearTable(\"ip6\")\n\n  def clearTable(self, _family):\n    is_empty_dict = True\n    json_command = self.get_base_dict()\n    chain_handle = self.get_chain_handle(_family, \"filter\", self.chain_name)\n    # if no handle, the chain doesn't exists\n    if chain_handle is not None:\n      is_empty_dict = False\n      # flush chain\n      mailcow_chain = {'family': _family, 'table': 'filter', 'name': self.chain_name}\n      flush_chain = {'flush': {'chain': mailcow_chain}}\n      json_command[\"nftables\"].append(flush_chain)\n\n    # remove rule in forward chain\n    # remove rule in input chain\n    chains_family = [self.nft_chain_names[_family]['filter']['input'],\n                    self.nft_chain_names[_family]['filter']['forward'] ]\n\n    for chain_base in chains_family:\n      if not chain_base: continue\n\n      rules_handle = self.get_rules_handle(_family, \"filter\", chain_base)\n      if rules_handle is not None:\n        for r_handle in rules_handle:\n          is_empty_dict = False\n          mailcow_rule = {'family':_family,\n                          'table': 'filter',\n                          'chain': chain_base,\n                          'handle': r_handle }\n          delete_rules = {'delete': {'rule': mailcow_rule} }\n          json_command[\"nftables\"].append(delete_rules)\n\n    # remove chain\n    # after delete all rules referencing this chain\n    if chain_handle is not None:\n      mc_chain_handle = {'family':_family,\n                        'table': 'filter',\n                        'name': self.chain_name,\n                        'handle': chain_handle }\n      delete_chain = {'delete': {'chain': mc_chain_handle} }\n      json_command[\"nftables\"].append(delete_chain)\n\n    if is_empty_dict == False:\n      if self.nft_exec_dict(json_command):\n        self.logger.logInfo(f\"Clear completed: {_family}\")\n\n  def banIPv4(self, source):\n    ban_dict = self.get_ban_ip_dict(source, \"ip\")\n    return self.nft_exec_dict(ban_dict)\n\n  def banIPv6(self, source):\n    ban_dict = self.get_ban_ip_dict(source, \"ip6\")\n    return self.nft_exec_dict(ban_dict)\n\n  def unbanIPv4(self, source):\n    unban_dict = self.get_unban_ip_dict(source, \"ip\")\n    if not unban_dict:\n      return False\n    return self.nft_exec_dict(unban_dict)\n\n  def unbanIPv6(self, source):\n    unban_dict = self.get_unban_ip_dict(source, \"ip6\")\n    if not unban_dict:\n      return False\n    return self.nft_exec_dict(unban_dict)\n\n  def snat4(self, snat_target, source):\n    self.snat_rule(\"ip\", snat_target, source)\n\n  def snat6(self, snat_target, source):\n    self.snat_rule(\"ip6\", snat_target, source)\n\n\n  def nft_exec_dict(self, query: dict):\n    if not query: return False\n\n    rc, output, error = self.nft.json_cmd(query)\n    if rc != 0:\n      #self.logger.logCrit(f\"Nftables Error: {error}\")\n      return False\n\n    # Prevent returning False or empty string on commands that do not produce output\n    if rc == 0 and len(output) == 0:\n      return True\n\n    return output\n\n  def get_base_dict(self):\n    return {'nftables': [{ 'metainfo': { 'json_schema_version': 1} } ] }\n\n  def search_current_chains(self):\n    nft_chain_priority = {'ip': {'filter': {'input': None, 'forward': None}, 'nat': {'postrouting': None} },\n                      'ip6': {'filter': {'input': None, 'forward': None}, 'nat': {'postrouting': None} } }\n\n    # Command: 'nft list chains'\n    _list = {'list' : {'chains': 'null'} }\n    command = self.get_base_dict()\n    command['nftables'].append(_list)\n    kernel_ruleset = self.nft_exec_dict(command)\n    if kernel_ruleset:\n      for _object in kernel_ruleset['nftables']:\n        chain = _object.get(\"chain\")\n        if not chain: continue\n\n        _family = chain['family']\n        _table = chain['table']\n        _hook = chain.get(\"hook\")\n        _priority = chain.get(\"prio\")\n        _name = chain['name']\n\n        if _family not in self.nft_chain_names: continue\n        if _table not in self.nft_chain_names[_family]: continue\n        if _hook not in self.nft_chain_names[_family][_table]: continue\n        if _priority is None: continue\n\n        _saved_priority = nft_chain_priority[_family][_table][_hook]\n        if _saved_priority is None or _priority < _saved_priority:\n          # at this point, we know the chain has:\n          # hook and priority set\n          # and it has the lowest priority\n          nft_chain_priority[_family][_table][_hook] = _priority\n          self.nft_chain_names[_family][_table][_hook] = _name\n\n  def search_for_chain(self, kernel_ruleset: dict, chain_name: str):\n    found = False\n    for _object in kernel_ruleset[\"nftables\"]:\n      chain = _object.get(\"chain\")\n      if not chain:\n        continue\n      ch_name = chain.get(\"name\")\n      if ch_name == chain_name:\n        found = True\n        break\n    return found\n\n  def get_chain_dict(self, _family: str, _name: str):\n    # nft (add | create) chain [<family>] <table> <name> \n    _chain_opts = {'family': _family, 'table': 'filter', 'name': _name  }\n    _add = {'add': {'chain': _chain_opts} }\n    final_chain = self.get_base_dict()\n    final_chain[\"nftables\"].append(_add)\n    return final_chain\n\n  def get_mailcow_jump_rule_dict(self, _family: str, _chain: str):\n    _jump_rule = self.get_base_dict()\n    _expr_opt=[]\n    _expr_counter = {'family': _family, 'table': 'filter', 'packets': 0, 'bytes': 0}\n    _counter_dict = {'counter': _expr_counter}\n    _expr_opt.append(_counter_dict)\n\n    _jump_opts = {'jump': {'target': self.chain_name} }\n\n    _expr_opt.append(_jump_opts)\n\n    _rule_params = {'family': _family,\n                    'table': 'filter',\n                    'chain': _chain,\n                    'expr': _expr_opt,\n                    'comment': \"mailcow\" }\n\n    _add_rule = {'insert': {'rule': _rule_params} }\n\n    _jump_rule[\"nftables\"].append(_add_rule)\n\n    return _jump_rule\n\n  def insert_mailcow_chains(self, _family: str):\n    nft_input_chain = self.nft_chain_names[_family]['filter']['input']\n    nft_forward_chain = self.nft_chain_names[_family]['filter']['forward']\n    # Command: 'nft list table <family> filter'\n    _table_opts = {'family': _family, 'name': 'filter'}\n    _list = {'list': {'table': _table_opts} }\n    command = self.get_base_dict()\n    command['nftables'].append(_list)\n    kernel_ruleset = self.nft_exec_dict(command)\n    if kernel_ruleset:\n      # chain\n      if not self.search_for_chain(kernel_ruleset, self.chain_name):\n        cadena = self.get_chain_dict(_family, self.chain_name)\n        if self.nft_exec_dict(cadena):\n          self.logger.logInfo(f\"MAILCOW {_family} chain created successfully.\")\n\n      input_jump_found, forward_jump_found = False, False\n\n      for _object in kernel_ruleset[\"nftables\"]:\n        if not _object.get(\"rule\"):\n          continue\n\n        rule = _object[\"rule\"]\n        if nft_input_chain and rule[\"chain\"] == nft_input_chain:\n          if rule.get(\"comment\") and rule[\"comment\"] == \"mailcow\":\n            input_jump_found = True\n        if nft_forward_chain and rule[\"chain\"] == nft_forward_chain:\n          if rule.get(\"comment\") and rule[\"comment\"] == \"mailcow\":\n            forward_jump_found = True\n\n      if not input_jump_found:\n        command = self.get_mailcow_jump_rule_dict(_family, nft_input_chain)\n        self.nft_exec_dict(command)\n\n      if not forward_jump_found:\n        command = self.get_mailcow_jump_rule_dict(_family, nft_forward_chain)\n        self.nft_exec_dict(command)\n\n  def delete_nat_rule(self, _family:str, _chain: str, _handle:str):\n    delete_command = self.get_base_dict()\n    _rule_opts = {'family': _family,\n                  'table': 'nat',\n                  'chain': _chain,\n                  'handle': _handle  }\n    _delete = {'delete': {'rule': _rule_opts} }\n    delete_command[\"nftables\"].append(_delete)\n\n    return self.nft_exec_dict(delete_command)\n\n  def delete_filter_rule(self, _family:str, _chain: str, _handle:str):\n    delete_command = self.get_base_dict()\n    _rule_opts = {'family': _family,\n                  'table': 'filter',\n                  'chain': _chain,\n                  'handle': _handle  }\n    _delete = {'delete': {'rule': _rule_opts} }\n    delete_command[\"nftables\"].append(_delete)\n\n    return self.nft_exec_dict(delete_command)\n\n  def snat_rule(self, _family: str, snat_target: str, source_address: str):\n    chain_name = self.nft_chain_names[_family]['nat']['postrouting']\n\n    # no postrouting chain, may occur if docker has ipv6 disabled.\n    if not chain_name: return\n\n    # Command: nft list chain <family> nat <chain_name>\n    _chain_opts = {'family': _family, 'table': 'nat', 'name': chain_name}\n    _list = {'list':{'chain': _chain_opts} }\n    command = self.get_base_dict()\n    command['nftables'].append(_list)\n    kernel_ruleset = self.nft_exec_dict(command)\n    if not kernel_ruleset:\n      return\n\n    rule_position = 0\n    rule_handle = None\n    rule_found = False\n    for _object in kernel_ruleset[\"nftables\"]:\n      if not _object.get(\"rule\"):\n        continue\n\n      rule = _object[\"rule\"]\n      if not rule.get(\"comment\") or not rule[\"comment\"] == \"mailcow\":\n        rule_position +=1\n        continue\n\n      rule_found = True\n      rule_handle = rule[\"handle\"]\n      break\n\n    dest_net = ipaddress.ip_network(source_address)\n    target_net = ipaddress.ip_network(snat_target)\n\n    if rule_found:\n      saddr_ip = rule[\"expr\"][0][\"match\"][\"right\"][\"prefix\"][\"addr\"]\n      saddr_len = int(rule[\"expr\"][0][\"match\"][\"right\"][\"prefix\"][\"len\"])\n\n      daddr_ip = rule[\"expr\"][1][\"match\"][\"right\"][\"prefix\"][\"addr\"]\n      daddr_len = int(rule[\"expr\"][1][\"match\"][\"right\"][\"prefix\"][\"len\"])\n\n      target_ip = rule[\"expr\"][3][\"snat\"][\"addr\"]\n\n      saddr_net = ipaddress.ip_network(saddr_ip + '/' + str(saddr_len))\n      daddr_net = ipaddress.ip_network(daddr_ip + '/' + str(daddr_len))\n      current_target_net = ipaddress.ip_network(target_ip)\n\n      match = all((\n                dest_net == saddr_net,\n                dest_net == daddr_net,\n                target_net == current_target_net\n              ))\n      try:\n        if rule_position == 0:\n          if not match:\n            # Position 0 , it is a mailcow rule , but it does not have the same parameters\n            if self.delete_nat_rule(_family, chain_name, rule_handle):\n              self.logger.logInfo(f'Remove rule for source network {saddr_net} to SNAT target {target_net} from {_family} nat {chain_name} chain, rule does not match configured parameters')\n        else:\n          # Position > 0 and is mailcow rule\n          if self.delete_nat_rule(_family, chain_name, rule_handle):\n            self.logger.logInfo(f'Remove rule for source network {saddr_net} to SNAT target {target_net} from {_family} nat {chain_name} chain, rule is at position {rule_position}')\n      except:\n          self.logger.logCrit(f\"Error running SNAT on {_family}, retrying...\" )\n    else:\n      # rule not found\n      json_command = self.get_base_dict()\n      try:\n        snat_dict = {'snat': {'addr': str(target_net.network_address)} }\n\n        expr_counter = {'family': _family, 'table': 'nat', 'packets': 0, 'bytes': 0}\n        counter_dict = {'counter': expr_counter}\n\n        prefix_dict = {'prefix': {'addr': str(dest_net.network_address), 'len': int(dest_net.prefixlen)} }\n        payload_dict = {'payload': {'protocol': _family, 'field': \"saddr\"} }\n        match_dict1 = {'match': {'op': '==', 'left': payload_dict, 'right': prefix_dict} }\n\n        payload_dict2 = {'payload': {'protocol': _family, 'field': \"daddr\"} }\n        match_dict2 = {'match': {'op': '!=', 'left': payload_dict2, 'right': prefix_dict } }\n        expr_list = [\n                    match_dict1,\n                    match_dict2,\n                    counter_dict,\n                    snat_dict\n                    ]\n        rule_fields = {'family': _family,\n                        'table': 'nat',\n                        'chain': chain_name,\n                        'comment': \"mailcow\",\n                        'expr': expr_list }\n\n        insert_dict = {'insert': {'rule': rule_fields} }\n        json_command[\"nftables\"].append(insert_dict)\n        if self.nft_exec_dict(json_command):\n          self.logger.logInfo(f'Added {_family} nat {chain_name} rule for source network {dest_net} to {target_net}')\n      except:\n        self.logger.logCrit(f\"Error running SNAT on {_family}, retrying...\")\n\n  def get_chain_handle(self, _family: str, _table: str, chain_name: str):\n    chain_handle = None\n    # Command: 'nft list chains {family}'\n    _list = {'list': {'chains': {'family': _family} } }\n    command = self.get_base_dict()\n    command['nftables'].append(_list)\n    kernel_ruleset = self.nft_exec_dict(command)\n    if kernel_ruleset:\n      for _object in kernel_ruleset[\"nftables\"]:\n        if not _object.get(\"chain\"):\n          continue\n        chain = _object[\"chain\"]\n        if chain[\"family\"] == _family and chain[\"table\"] == _table and chain[\"name\"] == chain_name:\n          chain_handle = chain[\"handle\"]\n          break\n    return chain_handle\n\n  def get_rules_handle(self, _family: str, _table: str, chain_name: str, _comment_filter = \"mailcow\"):\n    rule_handle = []\n    # Command: 'nft list chain {family} {table} {chain_name}'\n    _chain_opts = {'family': _family, 'table': _table, 'name': chain_name}\n    _list = {'list': {'chain': _chain_opts} }\n    command = self.get_base_dict()\n    command['nftables'].append(_list)\n\n    kernel_ruleset = self.nft_exec_dict(command)\n    if kernel_ruleset:\n      for _object in kernel_ruleset[\"nftables\"]:\n        if not _object.get(\"rule\"):\n          continue\n\n        rule = _object[\"rule\"]\n        if rule[\"family\"] == _family and rule[\"table\"] == _table and rule[\"chain\"] == chain_name:\n          if rule.get(\"comment\") and rule[\"comment\"] == _comment_filter:\n            rule_handle.append(rule[\"handle\"])\n    return rule_handle\n\n  def get_ban_ip_dict(self, ipaddr: str, _family: str):\n    json_command = self.get_base_dict()\n\n    expr_opt = []\n    ipaddr_net = ipaddress.ip_network(ipaddr)\n    right_dict = {'prefix': {'addr': str(ipaddr_net.network_address), 'len': int(ipaddr_net.prefixlen) } }\n\n    left_dict = {'payload': {'protocol': _family, 'field': 'saddr'} }\n    match_dict = {'op': '==', 'left': left_dict, 'right': right_dict }\n    expr_opt.append({'match': match_dict})\n\n    counter_dict = {'counter': {'family': _family, 'table': \"filter\", 'packets': 0, 'bytes': 0} }\n    expr_opt.append(counter_dict)\n\n    expr_opt.append({'drop': \"null\"})\n\n    rule_dict = {'family': _family, 'table': \"filter\", 'chain': self.chain_name, 'expr': expr_opt}\n\n    base_dict = {'insert': {'rule': rule_dict} }\n    json_command[\"nftables\"].append(base_dict)\n\n    return json_command\n\n  def get_unban_ip_dict(self, ipaddr:str, _family: str):\n    json_command = self.get_base_dict()\n    # Command: 'nft list chain {s_family} filter  MAILCOW'\n    _chain_opts = {'family': _family, 'table': 'filter', 'name': self.chain_name}\n    _list = {'list': {'chain': _chain_opts} }\n    command = self.get_base_dict()\n    command['nftables'].append(_list)\n    kernel_ruleset = self.nft_exec_dict(command)\n    rule_handle = None\n    if kernel_ruleset:\n      for _object in kernel_ruleset[\"nftables\"]:\n        if not _object.get(\"rule\"):\n          continue\n\n        rule = _object[\"rule\"][\"expr\"][0][\"match\"]\n        left_opt = rule[\"left\"][\"payload\"]\n        if not left_opt[\"protocol\"] == _family:\n          continue\n        if not left_opt[\"field\"] ==\"saddr\":\n          continue\n\n        # ip currently banned\n        rule_right = rule[\"right\"]\n        if isinstance(rule_right, dict):\n          current_rule_ip = rule_right[\"prefix\"][\"addr\"] + '/' + str(rule_right[\"prefix\"][\"len\"])\n        else:\n          current_rule_ip = rule_right\n        current_rule_net = ipaddress.ip_network(current_rule_ip)\n\n        # ip to ban\n        candidate_net = ipaddress.ip_network(ipaddr)\n\n        if current_rule_net == candidate_net:\n          rule_handle = _object[\"rule\"][\"handle\"]\n          break\n\n      if rule_handle is not None:\n        mailcow_rule = {'family': _family, 'table': 'filter', 'chain': self.chain_name, 'handle': rule_handle}\n        delete_rule = {'delete': {'rule': mailcow_rule} }\n        json_command[\"nftables\"].append(delete_rule)\n      else:\n        return False\n\n    return json_command\n\n  def check_mailcow_chains(self, family: str, chain: str):\n    position = 0\n    rule_found = False\n    chain_name = self.nft_chain_names[family]['filter'][chain]\n\n    if not chain_name: return None\n\n    _chain_opts = {'family': family, 'table': 'filter', 'name': chain_name}\n    _list = {'list': {'chain': _chain_opts}}\n    command = self.get_base_dict()\n    command['nftables'].append(_list)\n    kernel_ruleset = self.nft_exec_dict(command)\n    if kernel_ruleset:\n      for _object in kernel_ruleset[\"nftables\"]:\n        if not _object.get(\"rule\"):\n          continue\n        rule = _object[\"rule\"]\n        if rule.get(\"comment\") and rule[\"comment\"] == \"mailcow\":\n          rule_found = True\n          break\n\n        position+=1\n\n    return position if rule_found else False\n\n  def create_mailcow_isolation_rule(self, _interface:str, _dports:list, _allow:str = \"\"):\n    family = \"ip\"\n    table = \"filter\"\n    comment_filter_drop = \"mailcow isolation\"\n    comment_filter_allow = \"mailcow isolation allow\"\n    json_command = self.get_base_dict()\n\n    # Delete old mailcow isolation rules\n    handles = self.get_rules_handle(family, table, self.chain_name, comment_filter_drop)\n    for handle in handles:\n      self.delete_filter_rule(family, self.chain_name, handle)\n    handles = self.get_rules_handle(family, table, self.chain_name, comment_filter_allow)\n    for handle in handles:\n      self.delete_filter_rule(family, self.chain_name, handle)\n\n    # insert mailcow isolation rule\n    _match_dict_drop = [\n      {\n        \"match\": {\n          \"op\": \"!=\",\n          \"left\": {\n            \"meta\": {\n              \"key\": \"iifname\"\n            }\n          },\n          \"right\": _interface\n        }\n      },\n      {\n        \"match\": {\n          \"op\": \"==\",\n          \"left\": {\n            \"meta\": {\n              \"key\": \"oifname\"\n            }\n          },\n          \"right\": _interface\n        }\n      },\n      {\n        \"match\": {\n          \"op\": \"==\",\n          \"left\": {\n            \"payload\": {\n              \"protocol\": \"tcp\",\n              \"field\": \"dport\"\n            }\n          },\n          \"right\": {\n            \"set\": _dports\n          }\n        }\n      },\n      {\n        \"counter\": {\n          \"packets\": 0,\n          \"bytes\": 0\n        }\n      },\n      {\n        \"drop\": None\n      }\n    ]\n    rule_drop = { \"insert\": { \"rule\": {\n      \"family\": family,\n      \"table\": table,\n      \"chain\": self.chain_name,\n      \"comment\": comment_filter_drop,\n      \"expr\": _match_dict_drop\n    }}}\n    json_command[\"nftables\"].append(rule_drop)\n\n    # insert mailcow isolation allow rule\n    if _allow != \"\":\n      _match_dict_allow = [\n        {\n          \"match\": {\n            \"op\": \"==\",\n            \"left\": {\n              \"payload\": {\n                \"protocol\": \"ip\",\n                \"field\": \"saddr\"\n              }\n            },\n            \"right\": _allow\n          }\n        },\n        {\n          \"match\": {\n            \"op\": \"!=\",\n            \"left\": {\n              \"meta\": {\n                \"key\": \"iifname\"\n              }\n            },\n            \"right\": _interface\n          }\n        },\n        {\n          \"match\": {\n            \"op\": \"==\",\n            \"left\": {\n              \"meta\": {\n                \"key\": \"oifname\"\n              }\n            },\n            \"right\": _interface\n          }\n        },\n        {\n          \"match\": {\n            \"op\": \"==\",\n            \"left\": {\n              \"payload\": {\n                \"protocol\": \"tcp\",\n                \"field\": \"dport\"\n              }\n            },\n            \"right\": {\n              \"set\": _dports\n            }\n          }\n        },\n        {\n          \"counter\": {\n            \"packets\": 0,\n            \"bytes\": 0\n          }\n        },\n        {\n          \"accept\": None\n        }\n      ]\n      rule_allow = { \"insert\": { \"rule\": {\n        \"family\": family,\n        \"table\": table,\n        \"chain\": self.chain_name,\n        \"comment\": comment_filter_allow,\n        \"expr\": _match_dict_allow\n      }}}\n      json_command[\"nftables\"].append(rule_allow)\n\n    success = self.nft_exec_dict(json_command)\n    if success == False:\n      self.logger.logCrit(f\"Error adding {self.chain_name} isolation\")\n      return False\n\n    return True", "# --------------------------------------------------------------------------\n# Please create a file \"extra.conf\" for persistent overrides to dovecot.conf\n# --------------------------------------------------------------------------\n# LDAP example:\n#passdb {\n#  args = /etc/dovecot/ldap/passdb.conf\n#  driver = ldap\n#}\n\nauth_mechanisms = plain login\n#mail_debug = yes\n#auth_debug = yes\nlog_path = syslog\ndisable_plaintext_auth = yes\n# Uncomment on NFS share\n#mmap_disable = yes\n#mail_fsync = always\n#mail_nfs_index = yes\n#mail_nfs_storage = yes\nlogin_log_format_elements = \"user=<%u> method=%m rip=%r lip=%l mpid=%e %c %k\"\nmail_home = /var/vmail/%d/%n\nmail_location = maildir:~/\nmail_plugins = </etc/dovecot/mail_plugins\nmail_attachment_fs = crypt:set_prefix=mail_crypt_global:posix:\nmail_attachment_dir = /var/attachments\nmail_attachment_min_size = 128k\n# Significantly speeds up very large mailboxes, but is only safe to enable if\n# you do not manually modify the files in the `cur` directories in\n# mailcowdockerized_vmail-vol-1.\n# https://docs.mailcow.email/manual-guides/Dovecot/u_e-dovecot-performance/\nmaildir_very_dirty_syncs = yes\n\n# Dovecot 2.2\n#ssl_protocols = !SSLv3\n# Dovecot 2.3\nssl_min_protocol = TLSv1.2\n\nssl_prefer_server_ciphers = yes\nssl_cipher_list = ALL:!ADH:!LOW:!SSLv2:!SSLv3:!EXP:!aNULL:!eNULL:!3DES:!MD5:!PSK:!DSS:!RC4:!SEED:!IDEA:+HIGH:+MEDIUM\n\n# Default in Dovecot 2.3\nssl_options = no_compression no_ticket\n\n# New in Dovecot 2.3\nssl_dh = </etc/ssl/mail/dhparams.pem\n# Dovecot 2.2\n#ssl_dh_parameters_length = 2048\nlog_timestamp = \"%Y-%m-%d %H:%M:%S \"\nrecipient_delimiter = +\nauth_master_user_separator = *\nmail_shared_explicit_inbox = yes\nmail_prefetch_count = 30\npassdb {\n  driver = lua\n  args = file=/etc/dovecot/lua/passwd-verify.lua blocking=yes\n  result_success = return-ok\n  result_failure = continue\n  result_internalfail = continue\n}\n# try a master passwd\npassdb {\n  driver = passwd-file\n  args = /etc/dovecot/dovecot-master.passwd\n  master = yes\n  skip = authenticated\n}\n# check for regular password - if empty (e.g. force-passwd-reset), previous pass=yes passdbs also fail\n# a return of the following passdb is mandatory\npassdb {\n  driver = lua\n  args = file=/etc/dovecot/lua/passwd-verify.lua blocking=yes\n}\n# Set doveadm_password=your-secret-password in data/conf/dovecot/extra.conf (create if missing)\nservice doveadm {\n  inet_listener {\n    port = 12345\n  }\n  vsz_limit=2048 MB\n}\n!include /etc/dovecot/dovecot.folders.conf\nprotocols = imap sieve lmtp pop3\nservice dict {\n  unix_listener dict {\n    mode = 0660\n    user = vmail\n    group = vmail\n  }\n}\nservice log {\n  user = dovenull\n}\nservice config {\n  unix_listener config {\n    user = root\n    group = vmail\n    mode = 0660\n  }\n}\nservice auth {\n  inet_listener auth-inet {\n    port = 10001\n  }\n  unix_listener auth-master {\n    mode = 0600\n    user = vmail\n  }\n  unix_listener auth-userdb {\n    mode = 0600\n    user = vmail\n  }\n  vsz_limit = 2G\n}\nservice managesieve-login {\n  inet_listener sieve {\n    port = 4190\n  }\n  inet_listener sieve_haproxy {\n    port = 14190\n    haproxy = yes\n  }\n  service_count = 1\n  process_min_avail = 2\n  vsz_limit = 1G\n}\nservice imap-login {\n  service_count = 1\n  process_limit = 10000\n  vsz_limit = 1G\n  user = dovenull\n  inet_listener imap_haproxy {\n    port = 10143\n    haproxy = yes\n  }\n  inet_listener imaps_haproxy {\n    port = 10993\n    ssl = yes\n    haproxy = yes\n  }\n}\nservice pop3-login {\n  service_count = 1\n  vsz_limit = 1G\n  inet_listener pop3_haproxy {\n    port = 10110\n    haproxy = yes\n  }\n  inet_listener pop3s_haproxy {\n    port = 10995\n    ssl = yes\n    haproxy = yes\n  }\n}\nservice imap {\n  executable = imap\n  user = vmail\n  vsz_limit = 1G\n}\nservice managesieve {\n  process_limit = 256\n}\nservice lmtp {\n  inet_listener lmtp-inet {\n    port = 24\n  }\n  user = vmail\n}\nlisten = *,[::]\nssl_cert = </etc/ssl/mail/cert.pem\nssl_key = </etc/ssl/mail/key.pem\nuserdb {\n  driver = passwd-file\n  args = /etc/dovecot/dovecot-master.userdb\n}\nuserdb {\n  args = /etc/dovecot/sql/dovecot-dict-sql-userdb.conf\n  driver = sql\n  skip = found\n}\nprotocol imap {\n  mail_plugins = </etc/dovecot/mail_plugins_imap\n  imap_metadata = yes\n}\nmail_attribute_dict = file:%h/dovecot-attributes\nprotocol lmtp {\n  mail_plugins = </etc/dovecot/mail_plugins_lmtp\n  auth_socket_path = /var/run/dovecot/auth-master\n}\nprotocol sieve {\n  managesieve_logout_format = bytes=%i/%o\n}\nplugin {\n  # Allow \"any\" or \"authenticated\" to be used in ACLs\n  acl_anyone = </etc/dovecot/acl_anyone\n  acl_shared_dict = file:/var/vmail/shared-mailboxes.db\n  acl = vfile\n  acl_user = %u\n  fts = solr\n  fts_autoindex = yes\n  fts_solr = url=http://solr:8983/solr/dovecot-fts/\n  quota = dict:Userquota::proxy::sqlquota\n  quota_rule2 = Trash:storage=+100%%\n  sieve = /var/vmail/sieve/%u.sieve\n  sieve_plugins = sieve_imapsieve sieve_extprograms\n  sieve_vacation_send_from_recipient = yes\n  sieve_redirect_envelope_from = recipient\n  # From elsewhere to Spam folder\n  imapsieve_mailbox1_name = Junk\n  imapsieve_mailbox1_causes = COPY\n  imapsieve_mailbox1_before = file:/usr/lib/dovecot/sieve/report-spam.sieve\n  # END\n  # From Spam folder to elsewhere\n  imapsieve_mailbox2_name = *\n  imapsieve_mailbox2_from = Junk\n  imapsieve_mailbox2_causes = COPY\n  imapsieve_mailbox2_before = file:/usr/lib/dovecot/sieve/report-ham.sieve\n  # END\n  master_user = %u\n  quota_warning = storage=95%% quota-warning 95 %u\n  quota_warning2 = storage=80%% quota-warning 80 %u\n  sieve_pipe_bin_dir = /usr/lib/dovecot/sieve\n  sieve_global_extensions = +vnd.dovecot.pipe +vnd.dovecot.execute\n  sieve_extensions = +notify +imapflags +vacation-seconds +editheader\n  sieve_max_script_size = 1M\n  sieve_max_redirects = 100\n  sieve_max_actions = 101\n  sieve_quota_max_scripts = 0\n  sieve_quota_max_storage = 0\n  listescape_char = \"\\\\\"\n  sieve_vacation_min_period = 5s\n  sieve_vacation_max_period = 0\n  sieve_vacation_default_period = 60s\n  sieve_before = /var/vmail/sieve/global_sieve_before.sieve\n  sieve_before2 = dict:proxy::sieve_before;name=active;bindir=/var/vmail/sieve_before_bindir\n  sieve_after = dict:proxy::sieve_after;name=active;bindir=/var/vmail/sieve_after_bindir\n  sieve_after2 = /var/vmail/sieve/global_sieve_after.sieve\n  sieve_duplicate_default_period = 1m\n  sieve_duplicate_max_period = 7d\n\n  # -- Global keys\n  mail_crypt_global_private_key = </mail_crypt/ecprivkey.pem\n  mail_crypt_global_public_key = </mail_crypt/ecpubkey.pem\n  mail_crypt_save_version = 2\n\n  # Enable compression while saving, lz4 Dovecot v2.2.11+\n  zlib_save = lz4\n\n  mail_log_events = delete undelete expunge copy mailbox_delete mailbox_rename\n  mail_log_fields = uid box msgid size\n  mail_log_cached_only = yes\n\n  # Try set mail_replica\n  !include_try /etc/dovecot/mail_replica.conf\n}\nservice quota-warning {\n  executable = script /usr/local/bin/quota_notify.py\n  # use some unprivileged user for executing the quota warnings\n  user = vmail\n  unix_listener quota-warning {\n    user = vmail\n  }\n}\ndict {\n  sqlquota = mysql:/etc/dovecot/sql/dovecot-dict-sql-quota.conf\n  sieve_after = mysql:/etc/dovecot/sql/dovecot-dict-sql-sieve_after.conf\n  sieve_before = mysql:/etc/dovecot/sql/dovecot-dict-sql-sieve_before.conf\n}\nremote 127.0.0.1 {\n  disable_plaintext_auth = no\n}\nsubmission_host = postfix:588\nmail_max_userip_connections = 500\nservice stats {\n  unix_listener stats-writer {\n    mode = 0660\n    user = vmail\n  }\n}\nimap_max_line_length = 2 M\n#auth_cache_verify_password_with_worker = yes\n#auth_cache_negative_ttl = 0\n#auth_cache_ttl = 30 s\n#auth_cache_size = 2 M\nservice replicator {\n  process_min_avail = 1\n}\nservice aggregator {\n  fifo_listener replication-notify-fifo {\n    user = vmail\n  }\n  unix_listener replication-notify {\n    user = vmail\n  }\n}\nservice replicator {\n  unix_listener replicator-doveadm {\n    mode = 0666\n  }\n}\nreplication_max_conns = 10\ndoveadm_port = 12345\nreplication_dsync_parameters = -d -l 30 -U -n INBOX\n# <Includes>\n!include_try /etc/dovecot/sni.conf\n!include_try /etc/dovecot/sogo_trusted_ip.conf\n!include_try /etc/dovecot/extra.conf\n!include_try /etc/dovecot/sogo-sso.conf\n!include_try /etc/dovecot/shared_namespace.conf\n# </Includes>\ndefault_client_limit = 10400\ndefault_vsz_limit = 1024 M\n", "version: '2.1'\nservices:\n\n    unbound-mailcow:\n      image: mailcow/unbound:1.20\n      environment:\n        - TZ=${TZ}\n        - SKIP_UNBOUND_HEALTHCHECK=${SKIP_UNBOUND_HEALTHCHECK:-n}\n      volumes:\n        - ./data/hooks/unbound:/hooks:Z\n        - ./data/conf/unbound/unbound.conf:/etc/unbound/unbound.conf:ro,Z\n      restart: always\n      tty: true\n      networks:\n        mailcow-network:\n          ipv4_address: ${IPV4_NETWORK:-172.22.1}.254\n          aliases:\n            - unbound\n\n    mysql-mailcow:\n      image: mariadb:10.5\n      depends_on:\n        - unbound-mailcow\n        - netfilter-mailcow\n      stop_grace_period: 45s\n      volumes:\n        - mysql-vol-1:/var/lib/mysql/\n        - mysql-socket-vol-1:/var/run/mysqld/\n        - ./data/conf/mysql/:/etc/mysql/conf.d/:ro,Z\n      environment:\n        - TZ=${TZ}\n        - MYSQL_ROOT_PASSWORD=${DBROOT}\n        - MYSQL_DATABASE=${DBNAME}\n        - MYSQL_USER=${DBUSER}\n        - MYSQL_PASSWORD=${DBPASS}\n        - MYSQL_INITDB_SKIP_TZINFO=1\n      restart: always\n      ports:\n        - \"${SQL_PORT:-127.0.0.1:13306}:3306\"\n      networks:\n        mailcow-network:\n          aliases:\n            - mysql\n\n    redis-mailcow:\n      image: redis:7-alpine\n      volumes:\n        - redis-vol-1:/data/\n      restart: always\n      depends_on:\n        - netfilter-mailcow\n      ports:\n        - \"${REDIS_PORT:-127.0.0.1:7654}:6379\"\n      environment:\n        - TZ=${TZ}\n      sysctls:\n        - net.core.somaxconn=4096\n      networks:\n        mailcow-network:\n          ipv4_address: ${IPV4_NETWORK:-172.22.1}.249\n          aliases:\n            - redis\n\n    clamd-mailcow:\n      image: mailcow/clamd:1.64\n      restart: always\n      depends_on:\n        unbound-mailcow:\n          condition: service_healthy\n      dns:\n        - ${IPV4_NETWORK:-172.22.1}.254\n      environment:\n        - TZ=${TZ}\n        - SKIP_CLAMD=${SKIP_CLAMD:-n}\n      volumes:\n        - ./data/conf/clamav/:/etc/clamav/:Z\n        - clamd-db-vol-1:/var/lib/clamav\n      networks:\n        mailcow-network:\n          aliases:\n            - clamd\n\n    rspamd-mailcow:\n      image: mailcow/rspamd:1.95\n      stop_grace_period: 30s\n      depends_on:\n        - dovecot-mailcow\n      environment:\n        - TZ=${TZ}\n        - IPV4_NETWORK=${IPV4_NETWORK:-172.22.1}\n        - IPV6_NETWORK=${IPV6_NETWORK:-fd4d:6169:6c63:6f77::/64}\n        - REDIS_SLAVEOF_IP=${REDIS_SLAVEOF_IP:-}\n        - REDIS_SLAVEOF_PORT=${REDIS_SLAVEOF_PORT:-}\n      volumes:\n        - ./data/hooks/rspamd:/hooks:Z\n        - ./data/conf/rspamd/custom/:/etc/rspamd/custom:z\n        - ./data/conf/rspamd/override.d/:/etc/rspamd/override.d:Z\n        - ./data/conf/rspamd/local.d/:/etc/rspamd/local.d:Z\n        - ./data/conf/rspamd/plugins.d/:/etc/rspamd/plugins.d:Z\n        - ./data/conf/rspamd/lua/:/etc/rspamd/lua/:ro,Z\n        - ./data/conf/rspamd/rspamd.conf.local:/etc/rspamd/rspamd.conf.local:Z\n        - ./data/conf/rspamd/rspamd.conf.override:/etc/rspamd/rspamd.conf.override:Z\n        - rspamd-vol-1:/var/lib/rspamd\n      restart: always\n      hostname: rspamd\n      dns:\n        - ${IPV4_NETWORK:-172.22.1}.254\n      networks:\n        mailcow-network:\n          aliases:\n            - rspamd\n\n    php-fpm-mailcow:\n      image: mailcow/phpfpm:1.87\n      command: \"php-fpm -d date.timezone=${TZ} -d expose_php=0\"\n      depends_on:\n        - redis-mailcow\n      volumes:\n        - ./data/hooks/phpfpm:/hooks:Z\n        - ./data/web:/web:z\n        - ./data/conf/rspamd/dynmaps:/dynmaps:ro,z\n        - ./data/conf/rspamd/custom/:/rspamd_custom_maps:z\n        - rspamd-vol-1:/var/lib/rspamd\n        - mysql-socket-vol-1:/var/run/mysqld/\n        - ./data/conf/sogo/:/etc/sogo/:z\n        - ./data/conf/rspamd/meta_exporter:/meta_exporter:ro,z\n        - ./data/conf/phpfpm/sogo-sso/:/etc/sogo-sso/:z\n        - ./data/conf/phpfpm/php-fpm.d/pools.conf:/usr/local/etc/php-fpm.d/z-pools.conf:Z\n        - ./data/conf/phpfpm/php-conf.d/opcache-recommended.ini:/usr/local/etc/php/conf.d/opcache-recommended.ini:Z\n        - ./data/conf/phpfpm/php-conf.d/upload.ini:/usr/local/etc/php/conf.d/upload.ini:Z\n        - ./data/conf/phpfpm/php-conf.d/other.ini:/usr/local/etc/php/conf.d/zzz-other.ini:Z\n        - ./data/conf/dovecot/global_sieve_before:/global_sieve/before:z\n        - ./data/conf/dovecot/global_sieve_after:/global_sieve/after:z\n        - ./data/assets/templates:/tpls:z\n        - ./data/conf/nginx/:/etc/nginx/conf.d/:z\n      dns:\n        - ${IPV4_NETWORK:-172.22.1}.254\n      environment:\n        - REDIS_SLAVEOF_IP=${REDIS_SLAVEOF_IP:-}\n        - REDIS_SLAVEOF_PORT=${REDIS_SLAVEOF_PORT:-}\n        - LOG_LINES=${LOG_LINES:-9999}\n        - TZ=${TZ}\n        - DBNAME=${DBNAME}\n        - DBUSER=${DBUSER}\n        - DBPASS=${DBPASS}\n        - MAILCOW_HOSTNAME=${MAILCOW_HOSTNAME}\n        - MAILCOW_PASS_SCHEME=${MAILCOW_PASS_SCHEME:-BLF-CRYPT}\n        - IMAP_PORT=${IMAP_PORT:-143}\n        - IMAPS_PORT=${IMAPS_PORT:-993}\n        - POP_PORT=${POP_PORT:-110}\n        - POPS_PORT=${POPS_PORT:-995}\n        - SIEVE_PORT=${SIEVE_PORT:-4190}\n        - IPV4_NETWORK=${IPV4_NETWORK:-172.22.1}\n        - IPV6_NETWORK=${IPV6_NETWORK:-fd4d:6169:6c63:6f77::/64}\n        - SUBMISSION_PORT=${SUBMISSION_PORT:-587}\n        - SMTPS_PORT=${SMTPS_PORT:-465}\n        - SMTP_PORT=${SMTP_PORT:-25}\n        - API_KEY=${API_KEY:-invalid}\n        - API_KEY_READ_ONLY=${API_KEY_READ_ONLY:-invalid}\n        - API_ALLOW_FROM=${API_ALLOW_FROM:-invalid}\n        - COMPOSE_PROJECT_NAME=${COMPOSE_PROJECT_NAME:-mailcow-dockerized}\n        - SKIP_SOLR=${SKIP_SOLR:-y}\n        - SKIP_CLAMD=${SKIP_CLAMD:-n}\n        - SKIP_SOGO=${SKIP_SOGO:-n}\n        - ALLOW_ADMIN_EMAIL_LOGIN=${ALLOW_ADMIN_EMAIL_LOGIN:-n}\n        - MASTER=${MASTER:-y}\n        - DEV_MODE=${DEV_MODE:-n}\n        - DEMO_MODE=${DEMO_MODE:-n}\n        - WEBAUTHN_ONLY_TRUSTED_VENDORS=${WEBAUTHN_ONLY_TRUSTED_VENDORS:-n}\n        - CLUSTERMODE=${CLUSTERMODE:-}\n      restart: always\n      networks:\n        mailcow-network:\n          aliases:\n            - phpfpm\n\n    sogo-mailcow:\n      image: mailcow/sogo:1.122\n      environment:\n        - DBNAME=${DBNAME}\n        - DBUSER=${DBUSER}\n        - DBPASS=${DBPASS}\n        - TZ=${TZ}\n        - LOG_LINES=${LOG_LINES:-9999}\n        - MAILCOW_HOSTNAME=${MAILCOW_HOSTNAME}\n        - MAILCOW_PASS_SCHEME=${MAILCOW_PASS_SCHEME:-BLF-CRYPT}\n        - ACL_ANYONE=${ACL_ANYONE:-disallow}\n        - ALLOW_ADMIN_EMAIL_LOGIN=${ALLOW_ADMIN_EMAIL_LOGIN:-n}\n        - IPV4_NETWORK=${IPV4_NETWORK:-172.22.1}\n        - SOGO_EXPIRE_SESSION=${SOGO_EXPIRE_SESSION:-480}\n        - SKIP_SOGO=${SKIP_SOGO:-n}\n        - MASTER=${MASTER:-y}\n        - REDIS_SLAVEOF_IP=${REDIS_SLAVEOF_IP:-}\n        - REDIS_SLAVEOF_PORT=${REDIS_SLAVEOF_PORT:-}\n      dns:\n        - ${IPV4_NETWORK:-172.22.1}.254\n      volumes:\n        - ./data/hooks/sogo:/hooks:Z\n        - ./data/conf/sogo/:/etc/sogo/:z\n        - ./data/web/inc/init_db.inc.php:/init_db.inc.php:z\n        - ./data/conf/sogo/custom-favicon.ico:/usr/lib/GNUstep/SOGo/WebServerResources/img/sogo.ico:z\n        - ./data/conf/sogo/custom-theme.js:/usr/lib/GNUstep/SOGo/WebServerResources/js/theme.js:z\n        - ./data/conf/sogo/custom-sogo.js:/usr/lib/GNUstep/SOGo/WebServerResources/js/custom-sogo.js:z\n        - mysql-socket-vol-1:/var/run/mysqld/\n        - sogo-web-vol-1:/sogo_web\n        - sogo-userdata-backup-vol-1:/sogo_backup\n      labels:\n        ofelia.enabled: \"true\"\n        ofelia.job-exec.sogo_sessions.schedule: \"@every 1m\"\n        ofelia.job-exec.sogo_sessions.command: \"/bin/bash -c \\\"[[ $${MASTER} == y ]] && /usr/local/bin/gosu sogo /usr/sbin/sogo-tool -v expire-sessions $${SOGO_EXPIRE_SESSION} || exit 0\\\"\"\n        ofelia.job-exec.sogo_ealarms.schedule: \"@every 1m\"\n        ofelia.job-exec.sogo_ealarms.command: \"/bin/bash -c \\\"[[ $${MASTER} == y ]] && /usr/local/bin/gosu sogo /usr/sbin/sogo-ealarms-notify -p /etc/sogo/sieve.creds || exit 0\\\"\"\n        ofelia.job-exec.sogo_eautoreply.schedule: \"@every 5m\"\n        ofelia.job-exec.sogo_eautoreply.command: \"/bin/bash -c \\\"[[ $${MASTER} == y ]] && /usr/local/bin/gosu sogo /usr/sbin/sogo-tool update-autoreply -p /etc/sogo/sieve.creds || exit 0\\\"\"\n        ofelia.job-exec.sogo_backup.schedule: \"@every 24h\"\n        ofelia.job-exec.sogo_backup.command: \"/bin/bash -c \\\"[[ $${MASTER} == y ]] && /usr/local/bin/gosu sogo /usr/sbin/sogo-tool backup /sogo_backup ALL || exit 0\\\"\"\n      restart: always\n      networks:\n        mailcow-network:\n          ipv4_address: ${IPV4_NETWORK:-172.22.1}.248\n          aliases:\n            - sogo\n\n    dovecot-mailcow:\n      image: mailcow/dovecot:1.28\n      depends_on:\n        - mysql-mailcow\n        - netfilter-mailcow\n      dns:\n        - ${IPV4_NETWORK:-172.22.1}.254\n      cap_add:\n        - NET_BIND_SERVICE\n      volumes:\n        - ./data/hooks/dovecot:/hooks:Z\n        - ./data/conf/dovecot:/etc/dovecot:z\n        - ./data/assets/ssl:/etc/ssl/mail/:ro,z\n        - ./data/conf/sogo/:/etc/sogo/:z\n        - ./data/conf/phpfpm/sogo-sso/:/etc/phpfpm/:z\n        - vmail-vol-1:/var/vmail\n        - vmail-index-vol-1:/var/vmail_index\n        - crypt-vol-1:/mail_crypt/\n        - ./data/conf/rspamd/custom/:/etc/rspamd/custom:z\n        - ./data/assets/templates:/templates:z\n        - rspamd-vol-1:/var/lib/rspamd\n        - mysql-socket-vol-1:/var/run/mysqld/\n      environment:\n        - DOVECOT_MASTER_USER=${DOVECOT_MASTER_USER:-}\n        - DOVECOT_MASTER_PASS=${DOVECOT_MASTER_PASS:-}\n        - MAILCOW_REPLICA_IP=${MAILCOW_REPLICA_IP:-}\n        - DOVEADM_REPLICA_PORT=${DOVEADM_REPLICA_PORT:-}\n        - LOG_LINES=${LOG_LINES:-9999}\n        - DBNAME=${DBNAME}\n        - DBUSER=${DBUSER}\n        - DBPASS=${DBPASS}\n        - TZ=${TZ}\n        - MAILCOW_HOSTNAME=${MAILCOW_HOSTNAME}\n        - MAILCOW_PASS_SCHEME=${MAILCOW_PASS_SCHEME:-BLF-CRYPT}\n        - IPV4_NETWORK=${IPV4_NETWORK:-172.22.1}\n        - ALLOW_ADMIN_EMAIL_LOGIN=${ALLOW_ADMIN_EMAIL_LOGIN:-n}\n        - MAILDIR_GC_TIME=${MAILDIR_GC_TIME:-7200}\n        - ACL_ANYONE=${ACL_ANYONE:-disallow}\n        - SKIP_SOLR=${SKIP_SOLR:-y}\n        - MAILDIR_SUB=${MAILDIR_SUB:-}\n        - MASTER=${MASTER:-y}\n        - REDIS_SLAVEOF_IP=${REDIS_SLAVEOF_IP:-}\n        - REDIS_SLAVEOF_PORT=${REDIS_SLAVEOF_PORT:-}\n        - COMPOSE_PROJECT_NAME=${COMPOSE_PROJECT_NAME:-mailcow-dockerized}\n      ports:\n        - \"${DOVEADM_PORT:-127.0.0.1:19991}:12345\"\n        - \"${IMAP_PORT:-143}:143\"\n        - \"${IMAPS_PORT:-993}:993\"\n        - \"${POP_PORT:-110}:110\"\n        - \"${POPS_PORT:-995}:995\"\n        - \"${SIEVE_PORT:-4190}:4190\"\n      restart: always\n      tty: true\n      labels:\n        ofelia.enabled: \"true\"\n        ofelia.job-exec.dovecot_imapsync_runner.schedule: \"@every 1m\"\n        ofelia.job-exec.dovecot_imapsync_runner.no-overlap: \"true\"\n        ofelia.job-exec.dovecot_imapsync_runner.command: \"/bin/bash -c \\\"[[ $${MASTER} == y ]] && /usr/local/bin/gosu nobody /usr/local/bin/imapsync_runner.pl || exit 0\\\"\"\n        ofelia.job-exec.dovecot_trim_logs.schedule: \"@every 1m\"\n        ofelia.job-exec.dovecot_trim_logs.command: \"/bin/bash -c \\\"[[ $${MASTER} == y ]] && /usr/local/bin/gosu vmail /usr/local/bin/trim_logs.sh || exit 0\\\"\"\n        ofelia.job-exec.dovecot_quarantine.schedule: \"@every 20m\"\n        ofelia.job-exec.dovecot_quarantine.command: \"/bin/bash -c \\\"[[ $${MASTER} == y ]] && /usr/local/bin/gosu vmail /usr/local/bin/quarantine_notify.py || exit 0\\\"\"\n        ofelia.job-exec.dovecot_clean_q_aged.schedule: \"@every 24h\"\n        ofelia.job-exec.dovecot_clean_q_aged.command: \"/bin/bash -c \\\"[[ $${MASTER} == y ]] && /usr/local/bin/gosu vmail /usr/local/bin/clean_q_aged.sh || exit 0\\\"\"\n        ofelia.job-exec.dovecot_maildir_gc.schedule: \"@every 30m\"\n        ofelia.job-exec.dovecot_maildir_gc.command: \"/bin/bash -c \\\"source /source_env.sh ; /usr/local/bin/gosu vmail /usr/local/bin/maildir_gc.sh\\\"\"\n        ofelia.job-exec.dovecot_sarules.schedule: \"@every 24h\"\n        ofelia.job-exec.dovecot_sarules.command: \"/bin/bash -c \\\"/usr/local/bin/sa-rules.sh\\\"\"\n        ofelia.job-exec.dovecot_fts.schedule: \"@every 24h\"\n        ofelia.job-exec.dovecot_fts.command: \"/usr/bin/curl http://solr:8983/solr/dovecot-fts/update?optimize=true\"\n        ofelia.job-exec.dovecot_repl_health.schedule: \"@every 5m\"\n        ofelia.job-exec.dovecot_repl_health.command: \"/bin/bash -c \\\"/usr/local/bin/gosu vmail /usr/local/bin/repl_health.sh\\\"\"\n      ulimits:\n        nproc: 65535\n        nofile:\n          soft: 20000\n          hard: 40000\n      networks:\n        mailcow-network:\n          ipv4_address: ${IPV4_NETWORK:-172.22.1}.250\n          aliases:\n            - dovecot\n\n    postfix-mailcow:\n      image: mailcow/postfix:1.74\n      depends_on:\n        mysql-mailcow:\n          condition: service_started\n        unbound-mailcow:\n          condition: service_healthy\n      volumes:\n        - ./data/hooks/postfix:/hooks:Z\n        - ./data/conf/postfix:/opt/postfix/conf:z\n        - ./data/assets/ssl:/etc/ssl/mail/:ro,z\n        - postfix-vol-1:/var/spool/postfix\n        - crypt-vol-1:/var/lib/zeyple\n        - rspamd-vol-1:/var/lib/rspamd\n        - mysql-socket-vol-1:/var/run/mysqld/\n      environment:\n        - LOG_LINES=${LOG_LINES:-9999}\n        - TZ=${TZ}\n        - DBNAME=${DBNAME}\n        - DBUSER=${DBUSER}\n        - DBPASS=${DBPASS}\n        - REDIS_SLAVEOF_IP=${REDIS_SLAVEOF_IP:-}\n        - REDIS_SLAVEOF_PORT=${REDIS_SLAVEOF_PORT:-}\n        - MAILCOW_HOSTNAME=${MAILCOW_HOSTNAME}\n        - SPAMHAUS_DQS_KEY=${SPAMHAUS_DQS_KEY:-}\n      cap_add:\n        - NET_BIND_SERVICE\n      ports:\n        - \"${SMTP_PORT:-25}:25\"\n        - \"${SMTPS_PORT:-465}:465\"\n        - \"${SUBMISSION_PORT:-587}:587\"\n      restart: always\n      dns:\n        - ${IPV4_NETWORK:-172.22.1}.254\n      networks:\n        mailcow-network:\n          ipv4_address: ${IPV4_NETWORK:-172.22.1}.253\n          aliases:\n            - postfix\n\n    memcached-mailcow:\n      image: memcached:alpine\n      restart: always\n      environment:\n        - TZ=${TZ}\n      networks:\n        mailcow-network:\n          aliases:\n            - memcached\n\n    nginx-mailcow:\n      depends_on:\n        - sogo-mailcow\n        - php-fpm-mailcow\n        - redis-mailcow\n      image: nginx:mainline-alpine\n      dns:\n        - ${IPV4_NETWORK:-172.22.1}.254\n      command: /bin/sh -c \"envsubst < /etc/nginx/conf.d/templates/listen_plain.template > /etc/nginx/conf.d/listen_plain.active &&\n        envsubst < /etc/nginx/conf.d/templates/listen_ssl.template > /etc/nginx/conf.d/listen_ssl.active &&\n        envsubst < /etc/nginx/conf.d/templates/sogo.template > /etc/nginx/conf.d/sogo.active &&\n        . /etc/nginx/conf.d/templates/server_name.template.sh > /etc/nginx/conf.d/server_name.active &&\n        . /etc/nginx/conf.d/templates/sites.template.sh > /etc/nginx/conf.d/sites.active &&\n        . /etc/nginx/conf.d/templates/sogo_eas.template.sh > /etc/nginx/conf.d/sogo_eas.active &&\n        nginx -qt &&\n        until ping phpfpm -c1 > /dev/null; do sleep 1; done &&\n        until ping sogo -c1 > /dev/null; do sleep 1; done &&\n        until ping redis -c1 > /dev/null; do sleep 1; done &&\n        until ping rspamd -c1 > /dev/null; do sleep 1; done &&\n        exec nginx -g 'daemon off;'\"\n      environment:\n        - HTTPS_PORT=${HTTPS_PORT:-443}\n        - HTTP_PORT=${HTTP_PORT:-80}\n        - MAILCOW_HOSTNAME=${MAILCOW_HOSTNAME}\n        - IPV4_NETWORK=${IPV4_NETWORK:-172.22.1}\n        - TZ=${TZ}\n        - SKIP_SOGO=${SKIP_SOGO:-n}\n        - ALLOW_ADMIN_EMAIL_LOGIN=${ALLOW_ADMIN_EMAIL_LOGIN:-n}\n        - ADDITIONAL_SERVER_NAMES=${ADDITIONAL_SERVER_NAMES:-}\n      volumes:\n        - ./data/web:/web:ro,z\n        - ./data/conf/rspamd/dynmaps:/dynmaps:ro,z\n        - ./data/assets/ssl/:/etc/ssl/mail/:ro,z\n        - ./data/conf/nginx/:/etc/nginx/conf.d/:z\n        - ./data/conf/rspamd/meta_exporter:/meta_exporter:ro,z\n        - sogo-web-vol-1:/usr/lib/GNUstep/SOGo/\n      ports:\n        - \"${HTTPS_BIND:-}:${HTTPS_PORT:-443}:${HTTPS_PORT:-443}\"\n        - \"${HTTP_BIND:-}:${HTTP_PORT:-80}:${HTTP_PORT:-80}\"\n      restart: always\n      networks:\n        mailcow-network:\n          aliases:\n            - nginx\n\n    acme-mailcow:\n      depends_on:\n        nginx-mailcow:\n          condition: service_started\n        unbound-mailcow:\n          condition: service_healthy\n      image: mailcow/acme:1.87\n      dns:\n        - ${IPV4_NETWORK:-172.22.1}.254\n      environment:\n        - LOG_LINES=${LOG_LINES:-9999}\n        - ACME_CONTACT=${ACME_CONTACT:-}\n        - ADDITIONAL_SAN=${ADDITIONAL_SAN}\n        - MAILCOW_HOSTNAME=${MAILCOW_HOSTNAME}\n        - DBNAME=${DBNAME}\n        - DBUSER=${DBUSER}\n        - DBPASS=${DBPASS}\n        - SKIP_LETS_ENCRYPT=${SKIP_LETS_ENCRYPT:-n}\n        - COMPOSE_PROJECT_NAME=${COMPOSE_PROJECT_NAME:-mailcow-dockerized}\n        - DIRECTORY_URL=${DIRECTORY_URL:-}\n        - ENABLE_SSL_SNI=${ENABLE_SSL_SNI:-n}\n        - SKIP_IP_CHECK=${SKIP_IP_CHECK:-n}\n        - SKIP_HTTP_VERIFICATION=${SKIP_HTTP_VERIFICATION:-n}\n        - ONLY_MAILCOW_HOSTNAME=${ONLY_MAILCOW_HOSTNAME:-n}\n        - LE_STAGING=${LE_STAGING:-n}\n        - TZ=${TZ}\n        - REDIS_SLAVEOF_IP=${REDIS_SLAVEOF_IP:-}\n        - REDIS_SLAVEOF_PORT=${REDIS_SLAVEOF_PORT:-}\n        - SNAT_TO_SOURCE=${SNAT_TO_SOURCE:-n}\n        - SNAT6_TO_SOURCE=${SNAT6_TO_SOURCE:-n}\n      volumes:\n        - ./data/web/.well-known/acme-challenge:/var/www/acme:z\n        - ./data/assets/ssl:/var/lib/acme/:z\n        - ./data/assets/ssl-example:/var/lib/ssl-example/:ro,Z\n        - mysql-socket-vol-1:/var/run/mysqld/\n      restart: always\n      networks:\n        mailcow-network:\n          aliases:\n            - acme\n\n    netfilter-mailcow:\n      image: mailcow/netfilter:1.56\n      stop_grace_period: 30s\n      restart: always\n      privileged: true\n      environment:\n        - TZ=${TZ}\n        - IPV4_NETWORK=${IPV4_NETWORK:-172.22.1}\n        - IPV6_NETWORK=${IPV6_NETWORK:-fd4d:6169:6c63:6f77::/64}\n        - SNAT_TO_SOURCE=${SNAT_TO_SOURCE:-n}\n        - SNAT6_TO_SOURCE=${SNAT6_TO_SOURCE:-n}\n        - REDIS_SLAVEOF_IP=${REDIS_SLAVEOF_IP:-}\n        - REDIS_SLAVEOF_PORT=${REDIS_SLAVEOF_PORT:-}\n        - MAILCOW_REPLICA_IP=${MAILCOW_REPLICA_IP:-}\n        - DISABLE_NETFILTER_ISOLATION_RULE=${DISABLE_NETFILTER_ISOLATION_RULE:-n}\n      network_mode: \"host\"\n      volumes:\n        - /lib/modules:/lib/modules:ro\n\n    watchdog-mailcow:\n      image: mailcow/watchdog:2.02\n      dns:\n        - ${IPV4_NETWORK:-172.22.1}.254\n      tmpfs:\n        - /tmp\n      volumes:\n        - rspamd-vol-1:/var/lib/rspamd\n        - mysql-socket-vol-1:/var/run/mysqld/\n        - postfix-vol-1:/var/spool/postfix\n        - ./data/assets/ssl:/etc/ssl/mail/:ro,z\n      restart: always\n      depends_on:\n        - postfix-mailcow\n        - dovecot-mailcow\n        - mysql-mailcow\n        - acme-mailcow\n        - redis-mailcow\n\n      environment:\n        - IPV6_NETWORK=${IPV6_NETWORK:-fd4d:6169:6c63:6f77::/64}\n        - LOG_LINES=${LOG_LINES:-9999}\n        - TZ=${TZ}\n        - DBNAME=${DBNAME}\n        - DBUSER=${DBUSER}\n        - DBPASS=${DBPASS}\n        - DBROOT=${DBROOT}\n        - USE_WATCHDOG=${USE_WATCHDOG:-n}\n        - WATCHDOG_NOTIFY_EMAIL=${WATCHDOG_NOTIFY_EMAIL:-}\n        - WATCHDOG_NOTIFY_BAN=${WATCHDOG_NOTIFY_BAN:-y}\n        - WATCHDOG_NOTIFY_START=${WATCHDOG_NOTIFY_START:-y}\n        - WATCHDOG_SUBJECT=${WATCHDOG_SUBJECT:-Watchdog ALERT}\n        - WATCHDOG_NOTIFY_WEBHOOK=${WATCHDOG_NOTIFY_WEBHOOK:-}\n        - WATCHDOG_NOTIFY_WEBHOOK_BODY=${WATCHDOG_NOTIFY_WEBHOOK_BODY:-}\n        - WATCHDOG_EXTERNAL_CHECKS=${WATCHDOG_EXTERNAL_CHECKS:-n}\n        - WATCHDOG_MYSQL_REPLICATION_CHECKS=${WATCHDOG_MYSQL_REPLICATION_CHECKS:-n}\n        - WATCHDOG_VERBOSE=${WATCHDOG_VERBOSE:-n}\n        - MAILCOW_HOSTNAME=${MAILCOW_HOSTNAME}\n        - COMPOSE_PROJECT_NAME=${COMPOSE_PROJECT_NAME:-mailcow-dockerized}\n        - IPV4_NETWORK=${IPV4_NETWORK:-172.22.1}\n        - IP_BY_DOCKER_API=${IP_BY_DOCKER_API:-0}\n        - CHECK_UNBOUND=${CHECK_UNBOUND:-1}\n        - SKIP_CLAMD=${SKIP_CLAMD:-n}\n        - SKIP_LETS_ENCRYPT=${SKIP_LETS_ENCRYPT:-n}\n        - SKIP_SOGO=${SKIP_SOGO:-n}\n        - HTTPS_PORT=${HTTPS_PORT:-443}\n        - REDIS_SLAVEOF_IP=${REDIS_SLAVEOF_IP:-}\n        - REDIS_SLAVEOF_PORT=${REDIS_SLAVEOF_PORT:-}\n        - EXTERNAL_CHECKS_THRESHOLD=${EXTERNAL_CHECKS_THRESHOLD:-1}\n        - NGINX_THRESHOLD=${NGINX_THRESHOLD:-5}\n        - UNBOUND_THRESHOLD=${UNBOUND_THRESHOLD:-5}\n        - REDIS_THRESHOLD=${REDIS_THRESHOLD:-5}\n        - MYSQL_THRESHOLD=${MYSQL_THRESHOLD:-5}\n        - MYSQL_REPLICATION_THRESHOLD=${MYSQL_REPLICATION_THRESHOLD:-1}\n        - SOGO_THRESHOLD=${SOGO_THRESHOLD:-3}\n        - POSTFIX_THRESHOLD=${POSTFIX_THRESHOLD:-8}\n        - CLAMD_THRESHOLD=${CLAMD_THRESHOLD:-15}\n        - DOVECOT_THRESHOLD=${DOVECOT_THRESHOLD:-12}\n        - DOVECOT_REPL_THRESHOLD=${DOVECOT_REPL_THRESHOLD:-20}\n        - PHPFPM_THRESHOLD=${PHPFPM_THRESHOLD:-5}\n        - RATELIMIT_THRESHOLD=${RATELIMIT_THRESHOLD:-1}\n        - FAIL2BAN_THRESHOLD=${FAIL2BAN_THRESHOLD:-1}\n        - ACME_THRESHOLD=${ACME_THRESHOLD:-1}\n        - RSPAMD_THRESHOLD=${RSPAMD_THRESHOLD:-5}\n        - OLEFY_THRESHOLD=${OLEFY_THRESHOLD:-5}\n        - MAILQ_THRESHOLD=${MAILQ_THRESHOLD:-20}\n        - MAILQ_CRIT=${MAILQ_CRIT:-30}\n      networks:\n        mailcow-network:\n          aliases:\n            - watchdog\n\n    dockerapi-mailcow:\n      image: mailcow/dockerapi:2.07\n      security_opt:\n        - label=disable\n      restart: always\n      dns:\n        - ${IPV4_NETWORK:-172.22.1}.254\n      environment:\n        - DBROOT=${DBROOT}\n        - TZ=${TZ}\n        - REDIS_SLAVEOF_IP=${REDIS_SLAVEOF_IP:-}\n        - REDIS_SLAVEOF_PORT=${REDIS_SLAVEOF_PORT:-}\n      volumes:\n        - /var/run/docker.sock:/var/run/docker.sock:ro\n      networks:\n        mailcow-network:\n          aliases:\n            - dockerapi\n\n    \n    ##### Will be removed soon #####\n    solr-mailcow:\n      image: mailcow/solr:1.8.2\n      restart: always\n      depends_on:\n        - netfilter-mailcow\n      volumes:\n        - solr-vol-1:/opt/solr/server/solr/dovecot-fts/data\n      ports:\n        - \"${SOLR_PORT:-127.0.0.1:18983}:8983\"\n      environment:\n        - TZ=${TZ}\n        - SOLR_HEAP=${SOLR_HEAP:-1024}\n        - SKIP_SOLR=${SKIP_SOLR:-y}\n      networks:\n        mailcow-network:\n          aliases:\n            - solr\n    ################################\n\n    olefy-mailcow:\n      image: mailcow/olefy:1.12\n      restart: always\n      environment:\n        - TZ=${TZ}\n        - OLEFY_BINDADDRESS=0.0.0.0\n        - OLEFY_BINDPORT=10055\n        - OLEFY_TMPDIR=/tmp\n        - OLEFY_PYTHON_PATH=/usr/bin/python3\n        - OLEFY_OLEVBA_PATH=/usr/bin/olevba\n        - OLEFY_LOGLVL=20\n        - OLEFY_MINLENGTH=500\n        - OLEFY_DEL_TMP=1\n      networks:\n        mailcow-network:\n          aliases:\n            - olefy\n\n    ofelia-mailcow:\n      image: mcuadros/ofelia:latest\n      restart: always\n      command: daemon --docker\n      environment:\n        - TZ=${TZ}\n      depends_on:\n        - sogo-mailcow\n        - dovecot-mailcow\n      labels:\n        ofelia.enabled: \"true\"\n      security_opt:\n        - label=disable\n      volumes:\n        - /var/run/docker.sock:/var/run/docker.sock:ro\n      networks:\n        mailcow-network:\n          aliases:\n            - ofelia\n\n    ipv6nat-mailcow:\n      depends_on:\n        - unbound-mailcow\n        - mysql-mailcow\n        - redis-mailcow\n        - clamd-mailcow\n        - rspamd-mailcow\n        - php-fpm-mailcow\n        - sogo-mailcow\n        - dovecot-mailcow\n        - postfix-mailcow\n        - memcached-mailcow\n        - nginx-mailcow\n        - acme-mailcow\n        - netfilter-mailcow\n        - watchdog-mailcow\n        - dockerapi-mailcow\n        - solr-mailcow\n      environment:\n        - TZ=${TZ}\n      image: robbertkl/ipv6nat\n      security_opt:\n        - label=disable\n      restart: always\n      privileged: true\n      network_mode: \"host\"\n      volumes:\n        - /var/run/docker.sock:/var/run/docker.sock:ro\n        - /lib/modules:/lib/modules:ro\n\nnetworks:\n  mailcow-network:\n    driver: bridge\n    driver_opts:\n      com.docker.network.bridge.name: br-mailcow\n    enable_ipv6: true\n    ipam:\n      driver: default\n      config:\n        - subnet: ${IPV4_NETWORK:-172.22.1}.0/24\n        - subnet: ${IPV6_NETWORK:-fd4d:6169:6c63:6f77::/64}\n\nvolumes:\n  vmail-vol-1:\n  vmail-index-vol-1:\n  mysql-vol-1:\n  mysql-socket-vol-1:\n  redis-vol-1:\n  rspamd-vol-1:\n  solr-vol-1:\n  postfix-vol-1:\n  crypt-vol-1:\n  sogo-web-vol-1:\n  sogo-userdata-backup-vol-1:\n  clamd-db-vol-1:\n", "#!/usr/bin/env bash\n\nset -o pipefail\n\nif [[ \"$(uname -r)\" =~ ^4\\.15\\.0-60 ]]; then\n  echo \"DO NOT RUN mailcow ON THIS UBUNTU KERNEL!\";\n  echo \"Please update to 5.x or use another distribution.\"\n  exit 1\nfi\n\nif [[ \"$(uname -r)\" =~ ^4\\.4\\. ]]; then\n  if grep -q Ubuntu <<< $(uname -a); then\n    echo \"DO NOT RUN mailcow ON THIS UBUNTU KERNEL!\";\n    echo \"Please update to linux-generic-hwe-16.04 by running \\\"apt-get install --install-recommends linux-generic-hwe-16.04\\\"\"\n    exit 1\n  fi\nfi\n\nif grep --help 2>&1 | head -n 1 | grep -q -i \"busybox\"; then echo \"BusyBox grep detected, please install gnu grep, \\\"apk add --no-cache --upgrade grep\\\"\"; exit 1; fi\n# This will also cover sort\nif cp --help 2>&1 | head -n 1 | grep -q -i \"busybox\"; then echo \"BusyBox cp detected, please install coreutils, \\\"apk add --no-cache --upgrade coreutils\\\"\"; exit 1; fi\nif sed --help 2>&1 | head -n 1 | grep -q -i \"busybox\"; then echo \"BusyBox sed detected, please install gnu sed, \\\"apk add --no-cache --upgrade sed\\\"\"; exit 1; fi\n\nfor bin in openssl curl docker git awk sha1sum grep cut; do\n  if [[ -z $(which ${bin}) ]]; then echo \"Cannot find ${bin}, exiting...\"; exit 1; fi\ndone\n\nif docker compose > /dev/null 2>&1; then\n    if docker compose version --short | grep -e \"^2.\" -e \"^v2.\" > /dev/null 2>&1; then\n      COMPOSE_VERSION=native\n      echo -e \"\\e[33mFound Docker Compose Plugin (native).\\e[0m\"\n      echo -e \"\\e[33mSetting the DOCKER_COMPOSE_VERSION Variable to native\\e[0m\"\n      sleep 2\n      echo -e \"\\e[33mNotice: You\u00b4ll have to update this Compose Version via your Package Manager manually!\\e[0m\"\n    else\n      echo -e \"\\e[31mCannot find Docker Compose with a Version Higher than 2.X.X.\\e[0m\" \n      echo -e \"\\e[31mPlease update/install it manually regarding to this doc site: https://docs.mailcow.email/install/\\e[0m\"\n      exit 1\n    fi\nelif docker-compose > /dev/null 2>&1; then\n  if ! [[ $(alias docker-compose 2> /dev/null) ]] ; then\n    if docker-compose version --short | grep \"^2.\" > /dev/null 2>&1; then\n      COMPOSE_VERSION=standalone\n      echo -e \"\\e[33mFound Docker Compose Standalone.\\e[0m\"\n      echo -e \"\\e[33mSetting the DOCKER_COMPOSE_VERSION Variable to standalone\\e[0m\"\n      sleep 2\n      echo -e \"\\e[33mNotice: For an automatic update of docker-compose please use the update_compose.sh scripts located at the helper-scripts folder.\\e[0m\"\n    else\n      echo -e \"\\e[31mCannot find Docker Compose with a Version Higher than 2.X.X.\\e[0m\" \n      echo -e \"\\e[31mPlease update/install manually regarding to this doc site: https://docs.mailcow.email/install/\\e[0m\"\n      exit 1\n    fi\n  fi\n\nelse\n  echo -e \"\\e[31mCannot find Docker Compose.\\e[0m\" \n  echo -e \"\\e[31mPlease install it regarding to this doc site: https://docs.mailcow.email/install/\\e[0m\"\n  exit 1\nfi\n\ndetect_bad_asn() {\n  echo -e \"\\e[33mDetecting if your IP is listed on Spamhaus Bad ASN List...\\e[0m\"\n  response=$(curl --connect-timeout 15 --max-time 30 -s -o /dev/null -w \"%{http_code}\" \"https://asn-check.mailcow.email\")\n  if [ \"$response\" -eq 503 ]; then\n    if [ -z \"$SPAMHAUS_DQS_KEY\" ]; then\n      echo -e \"\\e[33mYour server's public IP uses an AS that is blocked by Spamhaus to use their DNS public blocklists for Postfix.\\e[0m\"\n      echo -e \"\\e[33mmailcow did not detected a value for the variable SPAMHAUS_DQS_KEY inside mailcow.conf!\\e[0m\"\n      sleep 2\n      echo \"\"\n      echo -e \"\\e[33mTo use the Spamhaus DNS Blocklists again, you will need to create a FREE account for their Data Query Service (DQS) at: https://www.spamhaus.com/free-trial/sign-up-for-a-free-data-query-service-account\\e[0m\"\n      echo -e \"\\e[33mOnce done, enter your DQS API key in mailcow.conf and mailcow will do the rest for you!\\e[0m\"\n      echo \"\"\n      sleep 2\n\n    else\n      echo -e \"\\e[33mYour server's public IP uses an AS that is blocked by Spamhaus to use their DNS public blocklists for Postfix.\\e[0m\"\n      echo -e \"\\e[32mmailcow detected a Value for the variable SPAMHAUS_DQS_KEY inside mailcow.conf. Postfix will use DQS with the given API key...\\e[0m\"\n    fi\n  elif [ \"$response\" -eq 200 ]; then\n    echo -e \"\\e[33mCheck completed! Your IP is \\e[32mclean\\e[0m\"\n  elif [ \"$response\" -eq 429 ]; then\n    echo -e \"\\e[33mCheck completed! \\e[31mYour IP seems to be rate limited on the ASN Check service... please try again later!\\e[0m\"\n  else\n    echo -e \"\\e[31mCheck failed! \\e[0mMaybe a DNS or Network problem?\\e[0m\"\n  fi\n}\n\n### If generate_config.sh is started with --dev or -d it will not check out nightly or master branch and will keep on the current branch\nif [[ ${1} == \"--dev\" || ${1} == \"-d\" ]]; then\n  SKIP_BRANCH=y\nelse\n  SKIP_BRANCH=n\nfi\n\nif [ -f mailcow.conf ]; then\n  read -r -p \"A config file exists and will be overwritten, are you sure you want to continue? [y/N] \" response\n  case $response in\n    [yY][eE][sS]|[yY])\n      mv mailcow.conf mailcow.conf_backup\n      chmod 600 mailcow.conf_backup\n      ;;\n    *)\n      exit 1\n    ;;\n  esac\nfi\n\necho \"Press enter to confirm the detected value '[value]' where applicable or enter a custom value.\"\nwhile [ -z \"${MAILCOW_HOSTNAME}\" ]; do\n  read -p \"Mail server hostname (FQDN) - this is not your mail domain, but your mail servers hostname: \" -e MAILCOW_HOSTNAME\n  DOTS=${MAILCOW_HOSTNAME//[^.]};\n  if [ ${#DOTS} -lt 1 ]; then\n    echo -e \"\\e[31mMAILCOW_HOSTNAME (${MAILCOW_HOSTNAME}) is not a FQDN!\\e[0m\"\n    sleep 1\n    echo \"Please change it to a FQDN and redeploy the stack with docker(-)compose up -d\"\n    exit 1\n  elif [[ \"${MAILCOW_HOSTNAME: -1}\" == \".\" ]]; then\n    echo \"MAILCOW_HOSTNAME (${MAILCOW_HOSTNAME}) is ending with a dot. This is not a valid FQDN!\"\n    exit 1\n  elif [ ${#DOTS} -eq 1 ]; then\n    echo -e \"\\e[33mMAILCOW_HOSTNAME (${MAILCOW_HOSTNAME}) does not contain a Subdomain. This is not fully tested and may cause issues.\\e[0m\"\n    echo \"Find more information about why this message exists here: https://github.com/mailcow/mailcow-dockerized/issues/1572\"\n    read -r -p \"Do you want to proceed anyway? [y/N] \" response\n    if [[ \"$response\" =~ ^([yY][eE][sS]|[yY])+$ ]]; then\n      echo \"OK. Procceding.\"\n    else\n      echo \"OK. Exiting.\"\n      exit 1\n    fi\n  fi\ndone\n\nif [ -a /etc/timezone ]; then\n  DETECTED_TZ=$(cat /etc/timezone)\nelif [ -a /etc/localtime ]; then\n  DETECTED_TZ=$(readlink /etc/localtime|sed -n 's|^.*zoneinfo/||p')\nfi\n\nwhile [ -z \"${MAILCOW_TZ}\" ]; do\n  if [ -z \"${DETECTED_TZ}\" ]; then\n    read -p \"Timezone: \" -e MAILCOW_TZ\n  else\n    read -p \"Timezone [${DETECTED_TZ}]: \" -e MAILCOW_TZ\n    [ -z \"${MAILCOW_TZ}\" ] && MAILCOW_TZ=${DETECTED_TZ}\n  fi\ndone\n\nMEM_TOTAL=$(awk '/MemTotal/ {print $2}' /proc/meminfo)\n\nif [ ${MEM_TOTAL} -le \"2621440\" ]; then\n  echo \"Installed memory is <= 2.5 GiB. It is recommended to disable ClamAV to prevent out-of-memory situations.\"\n  echo \"ClamAV can be re-enabled by setting SKIP_CLAMD=n in mailcow.conf.\"\n  read -r -p  \"Do you want to disable ClamAV now? [Y/n] \" response\n  case $response in\n    [nN][oO]|[nN])\n      SKIP_CLAMD=n\n      ;;\n    *)\n      SKIP_CLAMD=y\n    ;;\n  esac\nelse\n  SKIP_CLAMD=n\nfi\n\nif [ ${MEM_TOTAL} -le \"2097152\" ]; then\n  echo \"Disabling Solr on low-memory system.\"\n  SKIP_SOLR=y\nelif [ ${MEM_TOTAL} -le \"3670016\" ]; then\n  echo \"Installed memory is <= 3.5 GiB. It is recommended to disable Solr to prevent out-of-memory situations.\"\n  echo \"Solr is a prone to run OOM and should be monitored. The default Solr heap size is 1024 MiB and should be set in mailcow.conf according to your expected load.\"\n  echo \"Solr can be re-enabled by setting SKIP_SOLR=n in mailcow.conf but will refuse to start with less than 2 GB total memory.\"\n  read -r -p  \"Do you want to disable Solr now? [Y/n] \" response\n  case $response in\n    [nN][oO]|[nN])\n      SKIP_SOLR=n\n      ;;\n    *)\n      SKIP_SOLR=y\n    ;;\n  esac\nelse\n  SKIP_SOLR=n\nfi\n\nif [[ ${SKIP_BRANCH} != y ]]; then\n  echo \"Which branch of mailcow do you want to use?\"\n  echo \"\"\n  echo \"Available Branches:\"\n  echo \"- master branch (stable updates) | default, recommended [1]\"\n  echo \"- nightly branch (unstable updates, testing) | not-production ready [2]\"\n  sleep 1\n\n  while [ -z \"${MAILCOW_BRANCH}\" ]; do\n    read -r -p  \"Choose the Branch with it\u00b4s number [1/2] \" branch\n    case $branch in\n      [2])\n        MAILCOW_BRANCH=\"nightly\"\n        ;;\n      *)\n        MAILCOW_BRANCH=\"master\"\n      ;;\n    esac\n  done\n\n  git fetch --all\n  git checkout -f $MAILCOW_BRANCH\n\nelif [[ ${SKIP_BRANCH} == y ]]; then\n  echo -e \"\\033[33mEnabled Dev Mode.\\033[0m\"\n  echo -e \"\\033[33mNot checking out a different branch!\\033[0m\"\n  MAILCOW_BRANCH=$(git rev-parse --short $(git rev-parse @{upstream}))\n\nelse\n  echo -e \"\\033[31mCould not determine branch input...\"\n  echo -e \"\\033[31mExiting.\"\n  exit 1\nfi  \n\nif [ ! -z \"${MAILCOW_BRANCH}\" ]; then\n  git_branch=${MAILCOW_BRANCH}\nfi\n\n[ ! -f ./data/conf/rspamd/override.d/worker-controller-password.inc ] && echo '# Placeholder' > ./data/conf/rspamd/override.d/worker-controller-password.inc\n\ncat << EOF > mailcow.conf\n# ------------------------------\n# mailcow web ui configuration\n# ------------------------------\n# example.org is _not_ a valid hostname, use a fqdn here.\n# Default admin user is \"admin\"\n# Default password is \"moohoo\"\n\nMAILCOW_HOSTNAME=${MAILCOW_HOSTNAME}\n\n# Password hash algorithm\n# Only certain password hash algorithm are supported. For a fully list of supported schemes,\n# see https://docs.mailcow.email/models/model-passwd/\nMAILCOW_PASS_SCHEME=BLF-CRYPT\n\n# ------------------------------\n# SQL database configuration\n# ------------------------------\n\nDBNAME=mailcow\nDBUSER=mailcow\n\n# Please use long, random alphanumeric strings (A-Za-z0-9)\n\nDBPASS=$(LC_ALL=C </dev/urandom tr -dc A-Za-z0-9 2> /dev/null | head -c 28)\nDBROOT=$(LC_ALL=C </dev/urandom tr -dc A-Za-z0-9 2> /dev/null | head -c 28)\n\n# ------------------------------\n# HTTP/S Bindings\n# ------------------------------\n\n# You should use HTTPS, but in case of SSL offloaded reverse proxies:\n# Might be important: This will also change the binding within the container.\n# If you use a proxy within Docker, point it to the ports you set below.\n# Do _not_ use IP:PORT in HTTP(S)_BIND or HTTP(S)_PORT\n# IMPORTANT: Do not use port 8081, 9081 or 65510!\n# Example: HTTP_BIND=1.2.3.4\n# For IPv4 leave it as it is: HTTP_BIND= & HTTPS_PORT=\n# For IPv6 see https://docs.mailcow.email/post_installation/firststeps-ip_bindings/\n\nHTTP_PORT=80\nHTTP_BIND=\n\nHTTPS_PORT=443\nHTTPS_BIND=\n\n# ------------------------------\n# Other bindings\n# ------------------------------\n# You should leave that alone\n# Format: 11.22.33.44:25 or 12.34.56.78:465 etc.\n\nSMTP_PORT=25\nSMTPS_PORT=465\nSUBMISSION_PORT=587\nIMAP_PORT=143\nIMAPS_PORT=993\nPOP_PORT=110\nPOPS_PORT=995\nSIEVE_PORT=4190\nDOVEADM_PORT=127.0.0.1:19991\nSQL_PORT=127.0.0.1:13306\nSOLR_PORT=127.0.0.1:18983\nREDIS_PORT=127.0.0.1:7654\n\n# Your timezone\n# See https://en.wikipedia.org/wiki/List_of_tz_database_time_zones for a list of timezones\n# Use the column named 'TZ identifier' + pay attention for the column named 'Notes'\n\nTZ=${MAILCOW_TZ}\n\n# Fixed project name\n# Please use lowercase letters only\n\nCOMPOSE_PROJECT_NAME=mailcowdockerized\n\n# Used Docker Compose version\n# Switch here between native (compose plugin) and standalone\n# For more informations take a look at the mailcow docs regarding the configuration options.\n# Normally this should be untouched but if you decided to use either of those you can switch it manually here.\n# Please be aware that at least one of those variants should be installed on your machine or mailcow will fail.\n\nDOCKER_COMPOSE_VERSION=${COMPOSE_VERSION}\n\n# Set this to \"allow\" to enable the anyone pseudo user. Disabled by default.\n# When enabled, ACL can be created, that apply to \"All authenticated users\"\n# This should probably only be activated on mail hosts, that are used exclusivly by one organisation.\n# Otherwise a user might share data with too many other users.\nACL_ANYONE=disallow\n\n# Garbage collector cleanup\n# Deleted domains and mailboxes are moved to /var/vmail/_garbage/timestamp_sanitizedstring\n# How long should objects remain in the garbage until they are being deleted? (value in minutes)\n# Check interval is hourly\n\nMAILDIR_GC_TIME=7200\n\n# Additional SAN for the certificate\n#\n# You can use wildcard records to create specific names for every domain you add to mailcow.\n# Example: Add domains \"example.com\" and \"example.net\" to mailcow, change ADDITIONAL_SAN to a value like:\n#ADDITIONAL_SAN=imap.*,smtp.*\n# This will expand the certificate to \"imap.example.com\", \"smtp.example.com\", \"imap.example.net\", \"smtp.example.net\"\n# plus every domain you add in the future.\n#\n# You can also just add static names...\n#ADDITIONAL_SAN=srv1.example.net\n# ...or combine wildcard and static names:\n#ADDITIONAL_SAN=imap.*,srv1.example.com\n#\n\nADDITIONAL_SAN=\n\n# Additional server names for mailcow UI\n#\n# Specify alternative addresses for the mailcow UI to respond to\n# This is useful when you set mail.* as ADDITIONAL_SAN and want to make sure mail.maildomain.com will always point to the mailcow UI.\n# If the server name does not match a known site, Nginx decides by best-guess and may redirect users to the wrong web root.\n# You can understand this as server_name directive in Nginx.\n# Comma separated list without spaces! Example: ADDITIONAL_SERVER_NAMES=a.b.c,d.e.f\n\nADDITIONAL_SERVER_NAMES=\n\n# Skip running ACME (acme-mailcow, Let's Encrypt certs) - y/n\n\nSKIP_LETS_ENCRYPT=n\n\n# Create seperate certificates for all domains - y/n\n# this will allow adding more than 100 domains, but some email clients will not be able to connect with alternative hostnames\n# see https://doc.dovecot.org/admin_manual/ssl/sni_support\nENABLE_SSL_SNI=n\n\n# Skip IPv4 check in ACME container - y/n\n\nSKIP_IP_CHECK=n\n\n# Skip HTTP verification in ACME container - y/n\n\nSKIP_HTTP_VERIFICATION=n\n\n# Skip Unbound (DNS Resolver) Healthchecks (NOT Recommended!) - y/n\n\nSKIP_UNBOUND_HEALTHCHECK=n\n\n# Skip ClamAV (clamd-mailcow) anti-virus (Rspamd will auto-detect a missing ClamAV container) - y/n\n\nSKIP_CLAMD=${SKIP_CLAMD}\n\n# Skip SOGo: Will disable SOGo integration and therefore webmail, DAV protocols and ActiveSync support (experimental, unsupported, not fully implemented) - y/n\n\nSKIP_SOGO=n\n\n# Skip Solr on low-memory systems or if you do not want to store a readable index of your mails in solr-vol-1.\n\nSKIP_SOLR=${SKIP_SOLR}\n\n# Solr heap size in MB, there is no recommendation, please see Solr docs.\n# Solr is a prone to run OOM and should be monitored. Unmonitored Solr setups are not recommended.\n\nSOLR_HEAP=1024\n\n# Allow admins to log into SOGo as email user (without any password)\n\nALLOW_ADMIN_EMAIL_LOGIN=n\n\n# Enable watchdog (watchdog-mailcow) to restart unhealthy containers\n\nUSE_WATCHDOG=y\n\n# Send watchdog notifications by mail (sent from watchdog@MAILCOW_HOSTNAME)\n# CAUTION:\n# 1. You should use external recipients\n# 2. Mails are sent unsigned (no DKIM)\n# 3. If you use DMARC, create a separate DMARC policy (\"v=DMARC1; p=none;\" in _dmarc.MAILCOW_HOSTNAME)\n# Multiple rcpts allowed, NO quotation marks, NO spaces\n\n#WATCHDOG_NOTIFY_EMAIL=a@example.com,b@example.com,c@example.com\n#WATCHDOG_NOTIFY_EMAIL=\n\n# Send notifications to a webhook URL that receives a POST request with the content type \"application/json\".\n# You can use this to send notifications to services like Discord, Slack and others.\n#WATCHDOG_NOTIFY_WEBHOOK=https://discord.com/api/webhooks/XXXXXXXXXXXXXXXXXXX/XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n# JSON body included in the webhook POST request. Needs to be in single quotes.\n# Following variables are available: SUBJECT, BODY\n#WATCHDOG_NOTIFY_WEBHOOK_BODY='{\"username\": \"mailcow Watchdog\", \"content\": \"**${SUBJECT}**\\n${BODY}\"}'\n\n# Notify about banned IP (includes whois lookup)\nWATCHDOG_NOTIFY_BAN=n\n\n# Send a notification when the watchdog is started.\nWATCHDOG_NOTIFY_START=y\n\n# Subject for watchdog mails. Defaults to \"Watchdog ALERT\" followed by the error message.\n#WATCHDOG_SUBJECT=\n\n# Checks if mailcow is an open relay. Requires a SAL. More checks will follow.\n# https://www.servercow.de/mailcow?lang=en\n# https://www.servercow.de/mailcow?lang=de\n# No data is collected. Opt-in and anonymous.\n# Will only work with unmodified mailcow setups.\nWATCHDOG_EXTERNAL_CHECKS=n\n\n# Enable watchdog verbose logging\nWATCHDOG_VERBOSE=n\n\n# Max log lines per service to keep in Redis logs\n\nLOG_LINES=9999\n\n# Internal IPv4 /24 subnet, format n.n.n (expands to n.n.n.0/24)\n# Use private IPv4 addresses only, see https://en.wikipedia.org/wiki/Private_network#Private_IPv4_addresses\n\nIPV4_NETWORK=172.22.1\n\n# Internal IPv6 subnet in fc00::/7\n# Use private IPv6 addresses only, see https://en.wikipedia.org/wiki/Private_network#Private_IPv6_addresses\n\nIPV6_NETWORK=fd4d:6169:6c63:6f77::/64\n\n# Use this IPv4 for outgoing connections (SNAT)\n\n#SNAT_TO_SOURCE=\n\n# Use this IPv6 for outgoing connections (SNAT)\n\n#SNAT6_TO_SOURCE=\n\n# Create or override an API key for the web UI\n# You _must_ define API_ALLOW_FROM, which is a comma separated list of IPs\n# An API key defined as API_KEY has read-write access\n# An API key defined as API_KEY_READ_ONLY has read-only access\n# Allowed chars for API_KEY and API_KEY_READ_ONLY: a-z, A-Z, 0-9, -\n# You can define API_KEY and/or API_KEY_READ_ONLY\n\n#API_KEY=\n#API_KEY_READ_ONLY=\n#API_ALLOW_FROM=172.22.1.1,127.0.0.1\n\n# mail_home is ~/Maildir\nMAILDIR_SUB=Maildir\n\n# SOGo session timeout in minutes\nSOGO_EXPIRE_SESSION=480\n\n# DOVECOT_MASTER_USER and DOVECOT_MASTER_PASS must both be provided. No special chars.\n# Empty by default to auto-generate master user and password on start.\n# User expands to DOVECOT_MASTER_USER@mailcow.local\n# LEAVE EMPTY IF UNSURE\nDOVECOT_MASTER_USER=\n# LEAVE EMPTY IF UNSURE\nDOVECOT_MASTER_PASS=\n\n# Let's Encrypt registration contact information\n# Optional: Leave empty for none\n# This value is only used on first order!\n# Setting it at a later point will require the following steps:\n# https://docs.mailcow.email/troubleshooting/debug-reset_tls/\nACME_CONTACT=\n\n# WebAuthn device manufacturer verification\n# After setting WEBAUTHN_ONLY_TRUSTED_VENDORS=y only devices from trusted manufacturers are allowed\n# root certificates can be placed for validation under mailcow-dockerized/data/web/inc/lib/WebAuthn/rootCertificates\nWEBAUTHN_ONLY_TRUSTED_VENDORS=n\n\n# Spamhaus Data Query Service Key\n# Optional: Leave empty for none\n# Enter your key here if you are using a blocked ASN (OVH, AWS, Cloudflare e.g) for the unregistered Spamhaus Blocklist. \n# If empty, it will completely disable Spamhaus blocklists if it detects that you are running on a server using a blocked AS.\n# Otherwise it will work normally.\nSPAMHAUS_DQS_KEY=\n\n# Prevent netfilter from setting an iptables/nftables rule to isolate the mailcow docker network - y/n\n# CAUTION: Disabling this may expose container ports to other neighbors on the same subnet, even if the ports are bound to localhost\nDISABLE_NETFILTER_ISOLATION_RULE=n\nEOF\n\nmkdir -p data/assets/ssl\n\nchmod 600 mailcow.conf\n\n# copy but don't overwrite existing certificate\necho \"Generating snake-oil certificate...\"\n# Making Willich more popular\nopenssl req -x509 -newkey rsa:4096 -keyout data/assets/ssl-example/key.pem -out data/assets/ssl-example/cert.pem -days 365 -subj \"/C=DE/ST=NRW/L=Willich/O=mailcow/OU=mailcow/CN=${MAILCOW_HOSTNAME}\" -sha256 -nodes\necho \"Copying snake-oil certificate...\"\ncp -n -d data/assets/ssl-example/*.pem data/assets/ssl/\n\n# Set app_info.inc.php\ncase ${git_branch} in\n  master)\n    mailcow_git_version=$(git describe --tags `git rev-list --tags --max-count=1`)\n    ;;\n  nightly)\n    mailcow_git_version=$(git rev-parse --short $(git rev-parse @{upstream}))\n    mailcow_last_git_version=\"\"\n    ;;\n  *)\n    mailcow_git_version=$(git rev-parse --short HEAD)\n    mailcow_last_git_version=\"\"\n    ;;\nesac\n# if [ ${git_branch} == \"master\" ]; then\n#   mailcow_git_version=$(git describe --tags `git rev-list --tags --max-count=1`)\n# elif [ ${git_branch} == \"nightly\" ]; then\n#   mailcow_git_version=$(git rev-parse --short $(git rev-parse @{upstream}))\n#   mailcow_last_git_version=\"\"\n# else\n#   mailcow_git_version=$(git rev-parse --short HEAD)\n#   mailcow_last_git_version=\"\"\n# fi\n\nif [[ $SKIP_BRANCH != \"y\" ]]; then\nmailcow_git_commit=$(git rev-parse origin/${git_branch})\nmailcow_git_commit_date=$(git log -1 --format=%ci @{upstream} )\nelse\nmailcow_git_commit=$(git rev-parse ${git_branch})\nmailcow_git_commit_date=$(git log -1 --format=%ci @{upstream} )\ngit_branch=$(git rev-parse --abbrev-ref HEAD)\nfi\n\nif [ $? -eq 0 ]; then\n  echo '<?php' > data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_GIT_VERSION=\"'$mailcow_git_version'\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_LAST_GIT_VERSION=\"\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_GIT_OWNER=\"mailcow\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_GIT_REPO=\"mailcow-dockerized\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_GIT_URL=\"https://github.com/mailcow/mailcow-dockerized\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_GIT_COMMIT=\"'$mailcow_git_commit'\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_GIT_COMMIT_DATE=\"'$mailcow_git_commit_date'\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_BRANCH=\"'$git_branch'\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_UPDATEDAT='$(date +%s)';' >> data/web/inc/app_info.inc.php\n  echo '?>' >> data/web/inc/app_info.inc.php\nelse\n  echo '<?php' > data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_GIT_VERSION=\"'$mailcow_git_version'\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_LAST_GIT_VERSION=\"\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_GIT_OWNER=\"mailcow\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_GIT_REPO=\"mailcow-dockerized\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_GIT_URL=\"https://github.com/mailcow/mailcow-dockerized\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_GIT_COMMIT=\"\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_GIT_COMMIT_DATE=\"\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_BRANCH=\"'$git_branch'\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_UPDATEDAT='$(date +%s)';' >> data/web/inc/app_info.inc.php\n  echo '?>' >> data/web/inc/app_info.inc.php\n  echo -e \"\\e[33mCannot determine current git repository version...\\e[0m\"\nfi\n\ndetect_bad_asn\n", "#!/usr/bin/env bash\n\n############## Begin Function Section ##############\n\ncheck_online_status() {\n  CHECK_ONLINE_DOMAINS=('https://github.com' 'https://hub.docker.com')\n  for domain in \"${CHECK_ONLINE_DOMAINS[@]}\"; do\n    if timeout 6 curl --head --silent --output /dev/null ${domain}; then\n      return 0\n    fi\n  done\n  return 1\n}\n\nprefetch_images() {\n  [[ -z ${BRANCH} ]] && { echo -e \"\\e[33m\\nUnknown branch...\\e[0m\"; exit 1; }\n  git fetch origin #${BRANCH}\n  while read image; do\n    if [[ \"${image}\" == \"robbertkl/ipv6nat\" ]]; then\n      if ! grep -qi \"ipv6nat-mailcow\" docker-compose.yml || grep -qi \"enable_ipv6: false\" docker-compose.yml; then\n        continue\n      fi\n    fi\n    RET_C=0\n    until docker pull ${image}; do\n      RET_C=$((RET_C + 1))\n      echo -e \"\\e[33m\\nError pulling $image, retrying...\\e[0m\"\n      [ ${RET_C} -gt 3 ] && { echo -e \"\\e[31m\\nToo many failed retries, exiting\\e[0m\"; exit 1; }\n      sleep 1\n    done\n  done < <(git show origin/${BRANCH}:docker-compose.yml | grep \"image:\" | awk '{ gsub(\"image:\",\"\", $3); print $2 }')\n}\n\ndocker_garbage() {\n  SCRIPT_DIR=\"$( cd \"$( dirname \"${BASH_SOURCE[0]}\" )\" && pwd )\"\n  IMGS_TO_DELETE=()\n\n  declare -A IMAGES_INFO\n  COMPOSE_IMAGES=($(grep -oP \"image: \\Kmailcow.+\" \"${SCRIPT_DIR}/docker-compose.yml\"))\n\n  for existing_image in $(docker images --format \"{{.ID}}:{{.Repository}}:{{.Tag}}\" | grep 'mailcow/'); do\n      ID=$(echo $existing_image | cut -d ':' -f 1)\n      REPOSITORY=$(echo $existing_image | cut -d ':' -f 2)\n      TAG=$(echo $existing_image | cut -d ':' -f 3)\n\n      if [[ \" ${COMPOSE_IMAGES[@]} \" =~ \" ${REPOSITORY}:${TAG} \" ]]; then\n          continue\n      else\n          IMGS_TO_DELETE+=(\"$ID\")\n          IMAGES_INFO[\"$ID\"]=\"$REPOSITORY:$TAG\"\n      fi\n  done\n\n  if [[ ! -z ${IMGS_TO_DELETE[*]} ]]; then\n      echo \"The following unused mailcow images were found:\"\n      for id in \"${IMGS_TO_DELETE[@]}\"; do\n          echo \"    ${IMAGES_INFO[$id]} ($id)\"\n      done\n\n      if [ ! $FORCE ]; then\n          read -r -p \"Do you want to delete them to free up some space? [y/N] \" response\n          if [[ \"$response\" =~ ^([yY][eE][sS]|[yY])+$ ]]; then\n              docker rmi ${IMGS_TO_DELETE[*]}\n          else\n              echo \"OK, skipped.\"\n          fi\n      else\n          echo \"Running in forced mode! Force removing old mailcow images...\"\n          docker rmi ${IMGS_TO_DELETE[*]}\n      fi\n      echo -e \"\\e[32mFurther cleanup...\\e[0m\"\n      echo \"If you want to cleanup further garbage collected by Docker, please make sure all containers are up and running before cleaning your system by executing \\\"docker system prune\\\"\"\n  fi\n}\n\nin_array() {\n  local e match=\"$1\"\n  shift\n  for e; do [[ \"$e\" == \"$match\" ]] && return 0; done\n  return 1\n}\n\nmigrate_docker_nat() {\n  NAT_CONFIG='{\"ipv6\":true,\"fixed-cidr-v6\":\"fd00:dead:beef:c0::/80\",\"experimental\":true,\"ip6tables\":true}'\n  # Min Docker version\n  DOCKERV_REQ=20.10.2\n  # Current Docker version\n  DOCKERV_CUR=$(docker version -f '{{.Server.Version}}')\n  if grep -qi \"ipv6nat-mailcow\" docker-compose.yml && grep -qi \"enable_ipv6: true\" docker-compose.yml; then\n    echo -e \"\\e[32mNative IPv6 implementation available.\\e[0m\"\n    echo \"This will enable experimental features in the Docker daemon and configure Docker to do the IPv6 NATing instead of ipv6nat-mailcow.\"\n    echo '!!! This step is recommended !!!'\n    echo \"mailcow will try to roll back the changes if starting Docker fails after modifying the daemon.json configuration file.\"\n    read -r -p \"Should we try to enable the native IPv6 implementation in Docker now (recommended)? [y/N] \" dockernatresponse\n    if [[ ! \"${dockernatresponse}\" =~ ^([yY][eE][sS]|[yY])+$ ]]; then\n      echo \"OK, skipping this step.\"\n      return 0\n    fi\n  fi\n  # Sort versions and check if we are running a newer or equal version to req\n  if [ $(printf \"${DOCKERV_REQ}\\n${DOCKERV_CUR}\" | sort -V | tail -n1) == \"${DOCKERV_CUR}\" ]; then\n    # If Dockerd daemon json exists\n    if [ -s /etc/docker/daemon.json ]; then\n      IFS=',' read -r -a dockerconfig <<< $(cat /etc/docker/daemon.json | tr -cd '[:alnum:],')\n      if ! in_array ipv6true \"${dockerconfig[@]}\" || \\\n        ! in_array experimentaltrue \"${dockerconfig[@]}\" || \\\n        ! in_array ip6tablestrue \"${dockerconfig[@]}\" || \\\n        ! grep -qi \"fixed-cidr-v6\" /etc/docker/daemon.json; then\n          echo -e \"\\e[33mWarning:\\e[0m You seem to have modified the /etc/docker/daemon.json configuration by yourself and not fully/correctly activated the native IPv6 NAT implementation.\"\n          echo \"You will need to merge your existing configuration manually or fix/delete the existing daemon.json configuration before trying the update process again.\"\n          echo -e \"Please merge the following content and restart the Docker daemon:\\n\"\n          echo ${NAT_CONFIG}\n          return 1\n      fi\n    else\n      echo \"Working on IPv6 NAT, please wait...\"\n      echo ${NAT_CONFIG} > /etc/docker/daemon.json\n      ip6tables -F -t nat\n      [[ -e /etc/rc.conf ]] && rc-service docker restart || systemctl restart docker.service\n      if [[ $? -ne 0 ]]; then\n        echo -e \"\\e[31mError:\\e[0m Failed to activate IPv6 NAT! Reverting and exiting.\"\n        rm /etc/docker/daemon.json\n        if [[ -e /etc/rc.conf ]]; then\n          rc-service docker restart\n        else\n          systemctl reset-failed docker.service\n          systemctl restart docker.service\n        fi\n        return 1\n      fi\n    fi\n    # Removing legacy container\n    sed -i '/ipv6nat-mailcow:$/,/^$/d' docker-compose.yml\n    if [ -s docker-compose.override.yml ]; then\n        sed -i '/ipv6nat-mailcow:$/,/^$/d' docker-compose.override.yml\n        if [[ \"$(cat docker-compose.override.yml | sed '/^\\s*$/d' | wc -l)\" == \"2\" ]]; then\n            mv docker-compose.override.yml docker-compose.override.yml_backup\n        fi\n    fi\n    echo -e \"\\e[32mGreat! \\e[0mNative IPv6 NAT is active.\\e[0m\"\n  else\n    echo -e \"\\e[31mPlease upgrade Docker to version ${DOCKERV_REQ} or above.\\e[0m\"\n    return 0\n  fi\n}\n\nremove_obsolete_nginx_ports() {\n    # Removing obsolete docker-compose.override.yml\n    for override in docker-compose.override.yml docker-compose.override.yaml; do\n    if [ -s $override ] ; then\n        if cat $override | grep nginx-mailcow > /dev/null 2>&1; then\n          if cat $override | grep -E '(\\[::])' > /dev/null 2>&1; then\n            if cat $override | grep -w 80:80 > /dev/null 2>&1 && cat $override | grep -w 443:443 > /dev/null 2>&1 ; then\n              echo -e \"\\e[33mBacking up ${override} to preserve custom changes...\\e[0m\"\n              echo -e \"\\e[33m!!! Manual Merge needed (if other overrides are set) !!!\\e[0m\"\n              sleep 3\n              cp $override ${override}_backup\n              sed -i '/nginx-mailcow:$/,/^$/d' $override\n              echo -e \"\\e[33mRemoved obsolete NGINX IPv6 Bind from original override File.\\e[0m\"\n                if [[ \"$(cat $override | sed '/^\\s*$/d' | wc -l)\" == \"2\" ]]; then\n                  mv $override ${override}_empty\n                  echo -e \"\\e[31m${override} is empty. Renamed it to ensure mailcow is startable.\\e[0m\"\n                fi\n            fi\n          fi\n        fi\n    fi\n    done        \n}\n\ndetect_docker_compose_command(){\nif ! [[ \"${DOCKER_COMPOSE_VERSION}\" =~ ^(native|standalone)$ ]]; then\n  if docker compose > /dev/null 2>&1; then\n      if docker compose version --short | grep -e \"^2.\" -e \"^v2.\" > /dev/null 2>&1; then\n        DOCKER_COMPOSE_VERSION=native\n        COMPOSE_COMMAND=\"docker compose\"\n        echo -e \"\\e[33mFound Docker Compose Plugin (native).\\e[0m\"\n        echo -e \"\\e[33mSetting the DOCKER_COMPOSE_VERSION Variable to native\\e[0m\"\n        sed -i 's/^DOCKER_COMPOSE_VERSION=.*/DOCKER_COMPOSE_VERSION=native/' $SCRIPT_DIR/mailcow.conf \n        sleep 2\n        echo -e \"\\e[33mNotice: You'll have to update this Compose Version via your Package Manager manually!\\e[0m\"\n      else\n        echo -e \"\\e[31mCannot find Docker Compose with a Version Higher than 2.X.X.\\e[0m\" \n        echo -e \"\\e[31mPlease update/install it manually regarding to this doc site: https://docs.mailcow.email/install/\\e[0m\"\n        exit 1\n      fi\n  elif docker-compose > /dev/null 2>&1; then\n    if ! [[ $(alias docker-compose 2> /dev/null) ]] ; then\n      if docker-compose version --short | grep \"^2.\" > /dev/null 2>&1; then\n        DOCKER_COMPOSE_VERSION=standalone\n        COMPOSE_COMMAND=\"docker-compose\"\n        echo -e \"\\e[33mFound Docker Compose Standalone.\\e[0m\"\n        echo -e \"\\e[33mSetting the DOCKER_COMPOSE_VERSION Variable to standalone\\e[0m\"\n        sed -i 's/^DOCKER_COMPOSE_VERSION=.*/DOCKER_COMPOSE_VERSION=standalone/' $SCRIPT_DIR/mailcow.conf\n        sleep 2\n        echo -e \"\\e[33mNotice: For an automatic update of docker-compose please use the update_compose.sh scripts located at the helper-scripts folder.\\e[0m\"\n      else\n        echo -e \"\\e[31mCannot find Docker Compose with a Version Higher than 2.X.X.\\e[0m\" \n        echo -e \"\\e[31mPlease update/install regarding to this doc site: https://docs.mailcow.email/install/\\e[0m\"\n        exit 1\n      fi\n    fi\n\n  else\n    echo -e \"\\e[31mCannot find Docker Compose.\\e[0m\" \n    echo -e \"\\e[31mPlease install it regarding to this doc site: https://docs.mailcow.email/install/\\e[0m\"\n    exit 1\n  fi\n\nelif [ \"${DOCKER_COMPOSE_VERSION}\" == \"native\" ]; then\n  COMPOSE_COMMAND=\"docker compose\"\n  # Check if Native Compose works and has not been deleted  \n  if ! $COMPOSE_COMMAND > /dev/null 2>&1; then\n    # IF it not exists/work anymore try the other command\n    COMPOSE_COMMAND=\"docker-compose\"\n    if ! $COMPOSE_COMMAND > /dev/null 2>&1 || ! $COMPOSE_COMMAND --version | grep \"^2.\" > /dev/null 2>&1; then\n      # IF it cannot find Standalone in > 2.X, then script stops\n      echo -e \"\\e[31mCannot find Docker Compose or the Version is lower then 2.X.X.\\e[0m\" \n      echo -e \"\\e[31mPlease install it regarding to this doc site: https://docs.mailcow.email/install/\\e[0m\"\n      exit 1\n    fi\n      # If it finds the standalone Plugin it will use this instead and change the mailcow.conf Variable accordingly\n      echo -e \"\\e[31mFound different Docker Compose Version then declared in mailcow.conf!\\e[0m\"\n      echo -e \"\\e[31mSetting the DOCKER_COMPOSE_VERSION Variable from native to standalone\\e[0m\"\n      sed -i 's/^DOCKER_COMPOSE_VERSION=.*/DOCKER_COMPOSE_VERSION=standalone/' $SCRIPT_DIR/mailcow.conf \n      sleep 2\n  fi\n\n\nelif [ \"${DOCKER_COMPOSE_VERSION}\" == \"standalone\" ]; then\n  COMPOSE_COMMAND=\"docker-compose\"\n  # Check if Standalone Compose works and has not been deleted  \n  if ! $COMPOSE_COMMAND > /dev/null 2>&1 && ! $COMPOSE_COMMAND --version > /dev/null 2>&1 | grep \"^2.\" > /dev/null 2>&1; then\n    # IF it not exists/work anymore try the other command\n    COMPOSE_COMMAND=\"docker compose\"\n    if ! $COMPOSE_COMMAND > /dev/null 2>&1; then\n      # IF it cannot find Native in > 2.X, then script stops\n      echo -e \"\\e[31mCannot find Docker Compose.\\e[0m\" \n      echo -e \"\\e[31mPlease install it regarding to this doc site: https://docs.mailcow.email/install/\\e[0m\"\n      exit 1\n    fi\n      # If it finds the native Plugin it will use this instead and change the mailcow.conf Variable accordingly\n      echo -e \"\\e[31mFound different Docker Compose Version then declared in mailcow.conf!\\e[0m\"\n      echo -e \"\\e[31mSetting the DOCKER_COMPOSE_VERSION Variable from standalone to native\\e[0m\"\n      sed -i 's/^DOCKER_COMPOSE_VERSION=.*/DOCKER_COMPOSE_VERSION=native/' $SCRIPT_DIR/mailcow.conf \n      sleep 2\n  fi\nfi\n}\n\ndetect_bad_asn() {\n  echo -e \"\\e[33mDetecting if your IP is listed on Spamhaus Bad ASN List...\\e[0m\"\n  response=$(curl --connect-timeout 15 --max-time 30 -s -o /dev/null -w \"%{http_code}\" \"https://asn-check.mailcow.email\")\n  if [ \"$response\" -eq 503 ]; then\n    if [ -z \"$SPAMHAUS_DQS_KEY\" ]; then\n      echo -e \"\\e[33mYour server's public IP uses an AS that is blocked by Spamhaus to use their DNS public blocklists for Postfix.\\e[0m\"\n      echo -e \"\\e[33mmailcow did not detected a value for the variable SPAMHAUS_DQS_KEY inside mailcow.conf!\\e[0m\"\n      sleep 2\n      echo \"\"\n      echo -e \"\\e[33mTo use the Spamhaus DNS Blocklists again, you will need to create a FREE account for their Data Query Service (DQS) at: https://www.spamhaus.com/free-trial/sign-up-for-a-free-data-query-service-account\\e[0m\"\n      echo -e \"\\e[33mOnce done, enter your DQS API key in mailcow.conf and mailcow will do the rest for you!\\e[0m\"\n      echo \"\"\n      sleep 2\n\n    else\n      echo -e \"\\e[33mYour server's public IP uses an AS that is blocked by Spamhaus to use their DNS public blocklists for Postfix.\\e[0m\"\n      echo -e \"\\e[32mmailcow detected a Value for the variable SPAMHAUS_DQS_KEY inside mailcow.conf. Postfix will use DQS with the given API key...\\e[0m\"\n    fi\n  elif [ \"$response\" -eq 200 ]; then\n    echo -e \"\\e[33mCheck completed! Your IP is \\e[32mclean\\e[0m\"\n  elif [ \"$response\" -eq 429 ]; then\n    echo -e \"\\e[33mCheck completed! \\e[31mYour IP seems to be rate limited on the ASN Check service... please try again later!\\e[0m\"\n  else\n    echo -e \"\\e[31mCheck failed! \\e[0mMaybe a DNS or Network problem?\\e[0m\"\n  fi\n}\n\n############## End Function Section ##############\n\n# Check permissions\nif [ \"$(id -u)\" -ne \"0\" ]; then\n  echo \"You need to be root\"\n  exit 1\nfi\n\nSCRIPT_DIR=\"$( cd \"$( dirname \"${BASH_SOURCE[0]}\" )\" && pwd )\"\n\n# Run pre-update-hook\nif [ -f \"${SCRIPT_DIR}/pre_update_hook.sh\" ]; then\n  bash \"${SCRIPT_DIR}/pre_update_hook.sh\"\nfi\n\nif [[ \"$(uname -r)\" =~ ^4\\.15\\.0-60 ]]; then\n  echo \"DO NOT RUN mailcow ON THIS UBUNTU KERNEL!\";\n  echo \"Please update to 5.x or use another distribution.\"\n  exit 1\nfi\n\nif [[ \"$(uname -r)\" =~ ^4\\.4\\. ]]; then\n  if grep -q Ubuntu <<< $(uname -a); then\n    echo \"DO NOT RUN mailcow ON THIS UBUNTU KERNEL!\"\n    echo \"Please update to linux-generic-hwe-16.04 by running \\\"apt-get install --install-recommends linux-generic-hwe-16.04\\\"\"\n    exit 1\n  fi\n  echo \"mailcow on a 4.4.x kernel is not supported. It may or may not work, please upgrade your kernel or continue at your own risk.\"\n  read -p \"Press any key to continue...\" < /dev/tty\nfi\n\n# Exit on error and pipefail\nset -o pipefail\n\n# Setting high dc timeout\nexport COMPOSE_HTTP_TIMEOUT=600\n\n# Add /opt/bin to PATH\nPATH=$PATH:/opt/bin\n\numask 0022\n\n# Unset COMPOSE_COMMAND and DOCKER_COMPOSE_VERSION Variable to be on the newest state.\nunset COMPOSE_COMMAND\nunset DOCKER_COMPOSE_VERSION\n\nfor bin in curl docker git awk sha1sum grep cut; do\n  if [[ -z $(command -v ${bin}) ]]; then \n  echo \"Cannot find ${bin}, exiting...\" \n  exit 1;\n  fi  \ndone\n\nexport LC_ALL=C\nDATE=$(date +%Y-%m-%d_%H_%M_%S)\nBRANCH=$(cd ${SCRIPT_DIR}; git rev-parse --abbrev-ref HEAD)\n\nwhile (($#)); do\n  case \"${1}\" in\n    --check|-c)\n      echo \"Checking remote code for updates...\"\n      LATEST_REV=$(git ls-remote --exit-code --refs --quiet https://github.com/mailcow/mailcow-dockerized ${BRANCH} | cut -f1)\n      if [ $? -ne 0 ]; then\n        echo \"A problem occurred while trying to fetch the latest revision from github.\"\n        exit 99\n      fi\n      if [[ -z $(git log HEAD --pretty=format:\"%H\" | grep \"${LATEST_REV}\") ]]; then\n        echo -e \"Updated code is available.\\nThe changes can be found here: https://github.com/mailcow/mailcow-dockerized/commits/master\"\n        git log --date=short --pretty=format:\"%ad - %s\" $(git rev-parse --short HEAD)..origin/master\n        exit 0\n      else\n        echo \"No updates available.\"\n        exit 3\n      fi\n    ;;\n    --ours)\n      MERGE_STRATEGY=ours\n    ;;\n    --skip-start)\n      SKIP_START=y\n    ;;\n    --skip-ping-check)\n      SKIP_PING_CHECK=y\n    ;;\n    --stable)\n      CURRENT_BRANCH=\"$(cd ${SCRIPT_DIR}; git rev-parse --abbrev-ref HEAD)\"\n      NEW_BRANCH=\"master\"\n    ;;\n    --gc)\n      echo -e \"\\e[32mCollecting garbage...\\e[0m\"\n      docker_garbage\n      exit 0\n    ;;\n    --nightly)\n      CURRENT_BRANCH=\"$(cd ${SCRIPT_DIR}; git rev-parse --abbrev-ref HEAD)\"\n      NEW_BRANCH=\"nightly\"\n    ;;\n    --prefetch)\n      echo -e \"\\e[32mPrefetching images...\\e[0m\"\n      prefetch_images\n      exit 0\n    ;;\n    -f|--force)\n      echo -e \"\\e[32mRunning in forced mode...\\e[0m\"\n      FORCE=y\n    ;;\n    -d|--dev)\n      echo -e \"\\e[32mRunning in Developer mode...\\e[0m\"\n      DEV=y\n    ;;\n    --help|-h)\n    echo './update.sh [-c|--check, --ours, --gc, --nightly, --prefetch, --skip-start, --skip-ping-check, --stable, -f|--force, -d|--dev, -h|--help]\n\n  -c|--check           -   Check for updates and exit (exit codes => 0: update available, 3: no updates)\n  --ours               -   Use merge strategy option \"ours\" to solve conflicts in favor of non-mailcow code (local changes over remote changes), not recommended!\n  --gc                 -   Run garbage collector to delete old image tags\n  --nightly            -   Switch your mailcow updates to the unstable (nightly) branch. FOR TESTING PURPOSES ONLY!!!!\n  --prefetch           -   Only prefetch new images and exit (useful to prepare updates)\n  --skip-start         -   Do not start mailcow after update\n  --skip-ping-check    -   Skip ICMP Check to public DNS resolvers (Use it only if you\u00b4ve blocked any ICMP Connections to your mailcow machine)\n  --stable             -   Switch your mailcow updates to the stable (master) branch. Default unless you changed it with --nightly.\n  -f|--force           -   Force update, do not ask questions\n  -d|--dev             -   Enables Developer Mode (No Checkout of update.sh for tests)\n'\n    exit 1\n  esac\n  shift\ndone\n\nchmod 600 mailcow.conf\nsource mailcow.conf\n\ndetect_docker_compose_command\n\n[[ ! -f mailcow.conf ]] && { echo \"mailcow.conf is missing! Is mailcow installed?\"; exit 1;}\nDOTS=${MAILCOW_HOSTNAME//[^.]};\nif [ ${#DOTS} -lt 1 ]; then\n  echo -e \"\\e[31mMAILCOW_HOSTNAME (${MAILCOW_HOSTNAME}) is not a FQDN!\\e[0m\"\n  sleep 1\n  echo \"Please change it to a FQDN and redeploy the stack with $COMPOSE_COMMAND up -d\"\n  exit 1\nelif [[ \"${MAILCOW_HOSTNAME: -1}\" == \".\" ]]; then\n  echo \"MAILCOW_HOSTNAME (${MAILCOW_HOSTNAME}) is ending with a dot. This is not a valid FQDN!\"\n  exit 1\nelif [ ${#DOTS} -eq 1 ]; then\n  echo -e \"\\e[33mMAILCOW_HOSTNAME (${MAILCOW_HOSTNAME}) does not contain a Subdomain. This is not fully tested and may cause issues.\\e[0m\"\n  echo \"Find more information about why this message exists here: https://github.com/mailcow/mailcow-dockerized/issues/1572\"\n  read -r -p \"Do you want to proceed anyway? [y/N] \" response\n  if [[ \"$response\" =~ ^([yY][eE][sS]|[yY])+$ ]]; then\n    echo \"OK. Procceding.\"\n  else\n    echo \"OK. Exiting.\"\n    exit 1\n  fi\nfi\n\nif grep --help 2>&1 | head -n 1 | grep -q -i \"busybox\"; then echo \"BusyBox grep detected, please install gnu grep, \\\"apk add --no-cache --upgrade grep\\\"\"; exit 1; fi\n# This will also cover sort\nif cp --help 2>&1 | head -n 1 | grep -q -i \"busybox\"; then echo \"BusyBox cp detected, please install coreutils, \\\"apk add --no-cache --upgrade coreutils\\\"\"; exit 1; fi\nif sed --help 2>&1 | head -n 1 | grep -q -i \"busybox\"; then echo \"BusyBox sed detected, please install gnu sed, \\\"apk add --no-cache --upgrade sed\\\"\"; exit 1; fi\n\nCONFIG_ARRAY=(\n  \"SKIP_LETS_ENCRYPT\"\n  \"SKIP_SOGO\"\n  \"USE_WATCHDOG\"\n  \"WATCHDOG_NOTIFY_EMAIL\"\n  \"WATCHDOG_NOTIFY_WEBHOOK\"\n  \"WATCHDOG_NOTIFY_WEBHOOK_BODY\"\n  \"WATCHDOG_NOTIFY_BAN\"\n  \"WATCHDOG_NOTIFY_START\"\n  \"WATCHDOG_EXTERNAL_CHECKS\"\n  \"WATCHDOG_SUBJECT\"\n  \"SKIP_CLAMD\"\n  \"SKIP_IP_CHECK\"\n  \"ADDITIONAL_SAN\"\n  \"DOVEADM_PORT\"\n  \"IPV4_NETWORK\"\n  \"IPV6_NETWORK\"\n  \"LOG_LINES\"\n  \"SNAT_TO_SOURCE\"\n  \"SNAT6_TO_SOURCE\"\n  \"COMPOSE_PROJECT_NAME\"\n  \"DOCKER_COMPOSE_VERSION\"\n  \"SQL_PORT\"\n  \"API_KEY\"\n  \"API_KEY_READ_ONLY\"\n  \"API_ALLOW_FROM\"\n  \"MAILDIR_GC_TIME\"\n  \"MAILDIR_SUB\"\n  \"ACL_ANYONE\"\n  \"SOLR_HEAP\"\n  \"SKIP_SOLR\"\n  \"ENABLE_SSL_SNI\"\n  \"ALLOW_ADMIN_EMAIL_LOGIN\"\n  \"SKIP_HTTP_VERIFICATION\"\n  \"SOGO_EXPIRE_SESSION\"\n  \"REDIS_PORT\"\n  \"DOVECOT_MASTER_USER\"\n  \"DOVECOT_MASTER_PASS\"\n  \"MAILCOW_PASS_SCHEME\"\n  \"ADDITIONAL_SERVER_NAMES\"\n  \"ACME_CONTACT\"\n  \"WATCHDOG_VERBOSE\"\n  \"WEBAUTHN_ONLY_TRUSTED_VENDORS\"\n  \"SPAMHAUS_DQS_KEY\"\n  \"SKIP_UNBOUND_HEALTHCHECK\"\n  \"DISABLE_NETFILTER_ISOLATION_RULE\"\n)\n\ndetect_bad_asn\n\nsed -i --follow-symlinks '$a\\' mailcow.conf\nfor option in ${CONFIG_ARRAY[@]}; do\n  if [[ ${option} == \"ADDITIONAL_SAN\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo \"${option}=\" >> mailcow.conf\n    fi\n  elif [[ ${option} == \"COMPOSE_PROJECT_NAME\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo \"COMPOSE_PROJECT_NAME=mailcowdockerized\" >> mailcow.conf\n    fi\n  elif [[ ${option} == \"DOCKER_COMPOSE_VERSION\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo \"# Used Docker Compose version\" >> mailcow.conf\n      echo \"# Switch here between native (compose plugin) and standalone\" >> mailcow.conf\n      echo \"# For more informations take a look at the mailcow docs regarding the configuration options.\" >> mailcow.conf\n      echo \"# Normally this should be untouched but if you decided to use either of those you can switch it manually here.\" >> mailcow.conf\n      echo \"# Please be aware that at least one of those variants should be installed on your maschine or mailcow will fail.\" >> mailcow.conf\n      echo \"\" >> mailcow.conf\n      echo \"DOCKER_COMPOSE_VERSION=${DOCKER_COMPOSE_VERSION}\" >> mailcow.conf\n    fi\n  elif [[ ${option} == \"DOVEADM_PORT\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo \"DOVEADM_PORT=127.0.0.1:19991\" >> mailcow.conf\n    fi\n  elif [[ ${option} == \"WATCHDOG_NOTIFY_EMAIL\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo \"WATCHDOG_NOTIFY_EMAIL=\" >> mailcow.conf\n    fi\n  elif [[ ${option} == \"LOG_LINES\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo '# Max log lines per service to keep in Redis logs' >> mailcow.conf\n      echo \"LOG_LINES=9999\" >> mailcow.conf\n    fi\n  elif [[ ${option} == \"IPV4_NETWORK\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo '# Internal IPv4 /24 subnet, format n.n.n. (expands to n.n.n.0/24)' >> mailcow.conf\n      echo \"IPV4_NETWORK=172.22.1\" >> mailcow.conf\n    fi\n  elif [[ ${option} == \"IPV6_NETWORK\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo '# Internal IPv6 subnet in fc00::/7' >> mailcow.conf\n      echo \"IPV6_NETWORK=fd4d:6169:6c63:6f77::/64\" >> mailcow.conf\n    fi\n  elif [[ ${option} == \"SQL_PORT\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo '# Bind SQL to 127.0.0.1 on port 13306' >> mailcow.conf\n      echo \"SQL_PORT=127.0.0.1:13306\" >> mailcow.conf\n    fi\n  elif [[ ${option} == \"API_KEY\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo '# Create or override API key for web UI' >> mailcow.conf\n      echo \"#API_KEY=\" >> mailcow.conf\n    fi\n  elif [[ ${option} == \"API_KEY_READ_ONLY\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo '# Create or override read-only API key for web UI' >> mailcow.conf\n      echo \"#API_KEY_READ_ONLY=\" >> mailcow.conf\n    fi\n  elif [[ ${option} == \"API_ALLOW_FROM\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo '# Must be set for API_KEY to be active' >> mailcow.conf\n      echo '# IPs only, no networks (networks can be set via UI)' >> mailcow.conf\n      echo \"#API_ALLOW_FROM=\" >> mailcow.conf\n    fi\n  elif [[ ${option} == \"SNAT_TO_SOURCE\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo '# Use this IPv4 for outgoing connections (SNAT)' >> mailcow.conf\n      echo \"#SNAT_TO_SOURCE=\" >> mailcow.conf\n    fi\n  elif [[ ${option} == \"SNAT6_TO_SOURCE\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo '# Use this IPv6 for outgoing connections (SNAT)' >> mailcow.conf\n      echo \"#SNAT6_TO_SOURCE=\" >> mailcow.conf\n    fi\n  elif [[ ${option} == \"MAILDIR_GC_TIME\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo '# Garbage collector cleanup' >> mailcow.conf\n      echo '# Deleted domains and mailboxes are moved to /var/vmail/_garbage/timestamp_sanitizedstring' >> mailcow.conf\n      echo '# How long should objects remain in the garbage until they are being deleted? (value in minutes)' >> mailcow.conf\n      echo '# Check interval is hourly' >> mailcow.conf\n      echo 'MAILDIR_GC_TIME=1440' >> mailcow.conf\n    fi\n  elif [[ ${option} == \"ACL_ANYONE\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo '# Set this to \"allow\" to enable the anyone pseudo user. Disabled by default.' >> mailcow.conf\n      echo '# When enabled, ACL can be created, that apply to \"All authenticated users\"' >> mailcow.conf\n      echo '# This should probably only be activated on mail hosts, that are used exclusivly by one organisation.' >> mailcow.conf\n      echo '# Otherwise a user might share data with too many other users.' >> mailcow.conf\n      echo 'ACL_ANYONE=disallow' >> mailcow.conf\n    fi\n  elif [[ ${option} == \"SOLR_HEAP\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo '# Solr heap size, there is no recommendation, please see Solr docs.' >> mailcow.conf\n      echo '# Solr is a prone to run OOM on large systems and should be monitored. Unmonitored Solr setups are not recommended.' >> mailcow.conf\n      echo '# Solr will refuse to start with total system memory below or equal to 2 GB.' >> mailcow.conf\n      echo \"SOLR_HEAP=1024\" >> mailcow.conf\n    fi\n  elif [[ ${option} == \"SKIP_SOLR\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo '# Solr is disabled by default after upgrading from non-Solr to Solr-enabled mailcows.' >> mailcow.conf\n      echo '# Disable Solr or if you do not want to store a readable index of your mails in solr-vol-1.' >> mailcow.conf\n      echo \"SKIP_SOLR=y\" >> mailcow.conf\n    fi\n  elif [[ ${option} == \"ENABLE_SSL_SNI\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo '# Create seperate certificates for all domains - y/n' >> mailcow.conf\n      echo '# this will allow adding more than 100 domains, but some email clients will not be able to connect with alternative hostnames' >> mailcow.conf\n      echo '# see https://wiki.dovecot.org/SSL/SNIClientSupport' >> mailcow.conf\n      echo \"ENABLE_SSL_SNI=n\" >> mailcow.conf\n    fi\n  elif [[ ${option} == \"SKIP_SOGO\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo '# Skip SOGo: Will disable SOGo integration and therefore webmail, DAV protocols and ActiveSync support (experimental, unsupported, not fully implemented) - y/n' >> mailcow.conf\n      echo \"SKIP_SOGO=n\" >> mailcow.conf\n    fi\n  elif [[ ${option} == \"MAILDIR_SUB\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo '# MAILDIR_SUB defines a path in a users virtual home to keep the maildir in. Leave empty for updated setups.' >> mailcow.conf\n      echo \"#MAILDIR_SUB=Maildir\" >> mailcow.conf\n      echo \"MAILDIR_SUB=\" >> mailcow.conf\n    fi\n  elif [[ ${option} == \"WATCHDOG_NOTIFY_WEBHOOK\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo '# Send notifications to a webhook URL that receives a POST request with the content type \"application/json\".' >> mailcow.conf\n      echo '# You can use this to send notifications to services like Discord, Slack and others.' >> mailcow.conf\n      echo '#WATCHDOG_NOTIFY_WEBHOOK=https://discord.com/api/webhooks/XXXXXXXXXXXXXXXXXXX/XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX' >> mailcow.conf\n    fi\n  elif [[ ${option} == \"WATCHDOG_NOTIFY_WEBHOOK_BODY\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo '# JSON body included in the webhook POST request. Needs to be in single quotes.' >> mailcow.conf\n      echo '# Following variables are available: SUBJECT, BODY' >> mailcow.conf\n      WEBHOOK_BODY='{\"username\": \"mailcow Watchdog\", \"content\": \"**${SUBJECT}**\\n${BODY}\"}'\n      echo \"#WATCHDOG_NOTIFY_WEBHOOK_BODY='${WEBHOOK_BODY}'\" >> mailcow.conf\n    fi\n  elif [[ ${option} == \"WATCHDOG_NOTIFY_BAN\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo '# Notify about banned IP. Includes whois lookup.' >> mailcow.conf\n      echo \"WATCHDOG_NOTIFY_BAN=y\" >> mailcow.conf\n    fi\n  elif [[ ${option} == \"WATCHDOG_NOTIFY_START\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo '# Send a notification when the watchdog is started.' >> mailcow.conf\n      echo \"WATCHDOG_NOTIFY_START=y\" >> mailcow.conf\n    fi\n  elif [[ ${option} == \"WATCHDOG_SUBJECT\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo '# Subject for watchdog mails. Defaults to \"Watchdog ALERT\" followed by the error message.' >> mailcow.conf\n      echo \"#WATCHDOG_SUBJECT=\" >> mailcow.conf\n    fi\n  elif [[ ${option} == \"WATCHDOG_EXTERNAL_CHECKS\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo '# Checks if mailcow is an open relay. Requires a SAL. More checks will follow.' >> mailcow.conf\n      echo '# No data is collected. Opt-in and anonymous.' >> mailcow.conf\n      echo '# Will only work with unmodified mailcow setups.' >> mailcow.conf\n      echo \"WATCHDOG_EXTERNAL_CHECKS=n\" >> mailcow.conf\n    fi\n  elif [[ ${option} == \"SOGO_EXPIRE_SESSION\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo '# SOGo session timeout in minutes' >> mailcow.conf\n      echo \"SOGO_EXPIRE_SESSION=480\" >> mailcow.conf\n    fi\n  elif [[ ${option} == \"REDIS_PORT\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo \"REDIS_PORT=127.0.0.1:7654\" >> mailcow.conf\n    fi\n  elif [[ ${option} == \"DOVECOT_MASTER_USER\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo '# DOVECOT_MASTER_USER and _PASS must _both_ be provided. No special chars.' >> mailcow.conf\n      echo '# Empty by default to auto-generate master user and password on start.' >> mailcow.conf\n      echo '# User expands to DOVECOT_MASTER_USER@mailcow.local' >> mailcow.conf\n      echo '# LEAVE EMPTY IF UNSURE' >> mailcow.conf\n      echo \"DOVECOT_MASTER_USER=\" >> mailcow.conf\n    fi\n  elif [[ ${option} == \"DOVECOT_MASTER_PASS\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo '# LEAVE EMPTY IF UNSURE' >> mailcow.conf\n      echo \"DOVECOT_MASTER_PASS=\" >> mailcow.conf\n    fi\n  elif [[ ${option} == \"MAILCOW_PASS_SCHEME\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo '# Password hash algorithm' >> mailcow.conf\n      echo '# Only certain password hash algorithm are supported. For a fully list of supported schemes,' >> mailcow.conf\n      echo '# see https://docs.mailcow.email/models/model-passwd/' >> mailcow.conf\n      echo \"MAILCOW_PASS_SCHEME=BLF-CRYPT\" >> mailcow.conf\n    fi\n  elif [[ ${option} == \"ADDITIONAL_SERVER_NAMES\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo '# Additional server names for mailcow UI' >> mailcow.conf\n      echo '#' >> mailcow.conf\n      echo '# Specify alternative addresses for the mailcow UI to respond to' >> mailcow.conf\n      echo '# This is useful when you set mail.* as ADDITIONAL_SAN and want to make sure mail.maildomain.com will always point to the mailcow UI.' >> mailcow.conf\n      echo '# If the server name does not match a known site, Nginx decides by best-guess and may redirect users to the wrong web root.' >> mailcow.conf\n      echo '# You can understand this as server_name directive in Nginx.' >> mailcow.conf\n      echo '# Comma separated list without spaces! Example: ADDITIONAL_SERVER_NAMES=a.b.c,d.e.f' >> mailcow.conf\n      echo 'ADDITIONAL_SERVER_NAMES=' >> mailcow.conf\n    fi\n  elif [[ ${option} == \"ACME_CONTACT\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo '# Lets Encrypt registration contact information' >> mailcow.conf\n      echo '# Optional: Leave empty for none' >> mailcow.conf\n      echo '# This value is only used on first order!' >> mailcow.conf\n      echo '# Setting it at a later point will require the following steps:' >> mailcow.conf\n      echo '# https://docs.mailcow.email/troubleshooting/debug-reset_tls/' >> mailcow.conf\n      echo 'ACME_CONTACT=' >> mailcow.conf\n    fi\n  elif [[ ${option} == \"WEBAUTHN_ONLY_TRUSTED_VENDORS\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo \"# WebAuthn device manufacturer verification\" >> mailcow.conf\n      echo '# After setting WEBAUTHN_ONLY_TRUSTED_VENDORS=y only devices from trusted manufacturers are allowed' >> mailcow.conf\n      echo '# root certificates can be placed for validation under mailcow-dockerized/data/web/inc/lib/WebAuthn/rootCertificates' >> mailcow.conf\n      echo 'WEBAUTHN_ONLY_TRUSTED_VENDORS=n' >> mailcow.conf\n    fi\n  elif [[ ${option} == \"SPAMHAUS_DQS_KEY\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo \"# Spamhaus Data Query Service Key\" >> mailcow.conf\n      echo '# Optional: Leave empty for none' >> mailcow.conf\n      echo '# Enter your key here if you are using a blocked ASN (OVH, AWS, Cloudflare e.g) for the unregistered Spamhaus Blocklist.' >> mailcow.conf\n      echo '# If empty, it will completely disable Spamhaus blocklists if it detects that you are running on a server using a blocked AS.' >> mailcow.conf\n      echo '# Otherwise it will work as usual.' >> mailcow.conf\n      echo 'SPAMHAUS_DQS_KEY=' >> mailcow.conf\n    fi\n  elif [[ ${option} == \"WATCHDOG_VERBOSE\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo '# Enable watchdog verbose logging' >> mailcow.conf\n      echo 'WATCHDOG_VERBOSE=n' >> mailcow.conf\n    fi\n  elif [[ ${option} == \"SKIP_UNBOUND_HEALTHCHECK\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo '# Skip Unbound (DNS Resolver) Healthchecks (NOT Recommended!) - y/n' >> mailcow.conf\n      echo 'SKIP_UNBOUND_HEALTHCHECK=n' >> mailcow.conf\n    fi\n  elif [[ ${option} == \"DISABLE_NETFILTER_ISOLATION_RULE\" ]]; then\n    if ! grep -q ${option} mailcow.conf; then\n      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n      echo '# Prevent netfilter from setting an iptables/nftables rule to isolate the mailcow docker network - y/n' >> mailcow.conf\n      echo '# CAUTION: Disabling this may expose container ports to other neighbors on the same subnet, even if the ports are bound to localhost' >> mailcow.conf\n      echo 'DISABLE_NETFILTER_ISOLATION_RULE=n' >> mailcow.conf\n    fi \n  elif ! grep -q ${option} mailcow.conf; then\n    echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n    echo \"${option}=n\" >> mailcow.conf\n  fi\ndone\n\nif [[( ${SKIP_PING_CHECK} == \"y\")]]; then\necho -e \"\\e[32mSkipping Ping Check...\\e[0m\"\n\nelse\n   echo -en \"Checking internet connection... \"\n   if ! check_online_status; then\n      echo -e \"\\e[31mfailed\\e[0m\"\n      exit 1\n   else\n      echo -e \"\\e[32mOK\\e[0m\"\n   fi\nfi\n\nif ! [ $NEW_BRANCH ]; then\n  echo -e \"\\e[33mDetecting which build your mailcow runs on...\\e[0m\"\n  sleep 1\n  if [ ${BRANCH} == \"master\" ]; then\n    echo -e \"\\e[32mYou are receiving stable updates (master).\\e[0m\"\n    echo -e \"\\e[33mTo change that run the update.sh Script one time with the --nightly parameter to switch to nightly builds.\\e[0m\"\n\n  elif [ ${BRANCH} == \"nightly\" ]; then\n    echo -e \"\\e[31mYou are receiving unstable updates (nightly). These are for testing purposes only!!!\\e[0m\"\n    sleep 1\n    echo -e \"\\e[33mTo change that run the update.sh Script one time with the --stable parameter to switch to stable builds.\\e[0m\"\n\n  else\n    echo -e \"\\e[33mYou are receiving updates from a unsupported branch.\\e[0m\"\n    sleep 1\n    echo -e \"\\e[33mThe mailcow stack might still work but it is recommended to switch to the master branch (stable builds).\\e[0m\"\n    echo -e \"\\e[33mTo change that run the update.sh Script one time with the --stable parameter to switch to stable builds.\\e[0m\"\n  fi\nelif [ $FORCE ]; then\n  echo -e \"\\e[31mYou are running in forced mode!\\e[0m\"\n  echo -e \"\\e[31mA Branch Switch can only be performed manually (monitored).\\e[0m\"\n  echo -e \"\\e[31mPlease rerun the update.sh Script without the --force/-f parameter.\\e[0m\"\n  sleep 1\nelif [ $NEW_BRANCH == \"master\" ] && [ $CURRENT_BRANCH != \"master\" ]; then\n  echo -e \"\\e[33mYou are about to switch your mailcow Updates to the stable (master) branch.\\e[0m\"\n  sleep 1\n  echo -e \"\\e[33mBefore you do: Please take a backup of all components to ensure that no Data is lost...\\e[0m\"\n  sleep 1\n  echo -e \"\\e[31mWARNING: Please see on GitHub or ask in the communitys if a switch to master is stable or not.\n  In some rear cases a Update back to master can destroy your mailcow configuration in case of Database Upgrades etc.\n  Normally a upgrade back to master should be safe during each full release. \n  Check GitHub for Database Changes and Update only if there similar to the full release!\\e[0m\"\n  read -r -p \"Are you sure you that want to continue upgrading to the stable (master) branch? [y/N] \" response\n  if [[ ! \"${response}\" =~ ^([yY][eE][sS]|[yY])+$ ]]; then\n    echo \"OK. If you prepared yourself for that please run the update.sh Script with the --stable parameter again to trigger this process here.\"\n    exit 0\n  fi\n  BRANCH=$NEW_BRANCH\n  DIFF_DIRECTORY=update_diffs\n  DIFF_FILE=${DIFF_DIRECTORY}/diff_before_upgrade_to_master_$(date +\"%Y-%m-%d-%H-%M-%S\")\n  mv diff_before_upgrade* ${DIFF_DIRECTORY}/ 2> /dev/null\n  if ! git diff-index --quiet HEAD; then\n    echo -e \"\\e[32mSaving diff to ${DIFF_FILE}...\\e[0m\"\n    mkdir -p ${DIFF_DIRECTORY}\n    git diff ${BRANCH} --stat > ${DIFF_FILE}\n    git diff ${BRANCH} >> ${DIFF_FILE}\n  fi\n  echo -e \"\\e[32mSwitching Branch to ${BRANCH}...\\e[0m\"\n  git fetch origin\n  git checkout -f ${BRANCH}\n\nelif [ $NEW_BRANCH == \"nightly\" ] && [ $CURRENT_BRANCH != \"nightly\" ]; then\n  echo -e \"\\e[33mYou are about to switch your mailcow Updates to the unstable (nightly) branch.\\e[0m\"\n  sleep 1\n  echo -e \"\\e[33mBefore you do: Please take a backup of all components to ensure that no Data is lost...\\e[0m\"\n  sleep 1\n  echo -e \"\\e[31mWARNING: A switch to nightly is possible any time. But a switch back (to master) isn't.\\e[0m\"\n  read -r -p \"Are you sure you that want to continue upgrading to the unstable (nightly) branch? [y/N] \" response\n  if [[ ! \"${response}\" =~ ^([yY][eE][sS]|[yY])+$ ]]; then\n    echo \"OK. If you prepared yourself for that please run the update.sh Script with the --nightly parameter again to trigger this process here.\"\n    exit 0\n  fi\n  BRANCH=$NEW_BRANCH\n  DIFF_DIRECTORY=update_diffs\n  DIFF_FILE=${DIFF_DIRECTORY}/diff_before_upgrade_to_nightly_$(date +\"%Y-%m-%d-%H-%M-%S\")\n  mv diff_before_upgrade* ${DIFF_DIRECTORY}/ 2> /dev/null\n  if ! git diff-index --quiet HEAD; then\n    echo -e \"\\e[32mSaving diff to ${DIFF_FILE}...\\e[0m\"\n    mkdir -p ${DIFF_DIRECTORY}\n    git diff ${BRANCH} --stat > ${DIFF_FILE}\n    git diff ${BRANCH} >> ${DIFF_FILE}\n  fi\n  git fetch origin\n  git checkout -f ${BRANCH}\nfi\n\nif [ ! $DEV ]; then\n  echo -e \"\\e[32mChecking for newer update script...\\e[0m\"\n  SHA1_1=$(sha1sum update.sh)\n  git fetch origin #${BRANCH}\n  git checkout origin/${BRANCH} update.sh\n  SHA1_2=$(sha1sum update.sh)\n  if [[ ${SHA1_1} != ${SHA1_2} ]]; then\n    echo \"update.sh changed, please run this script again, exiting.\"\n    chmod +x update.sh\n    exit 2\n  fi\nfi\n\nif [ ! $FORCE ]; then\n  read -r -p \"Are you sure you want to update mailcow: dockerized? All containers will be stopped. [y/N] \" response\n  if [[ ! \"${response}\" =~ ^([yY][eE][sS]|[yY])+$ ]]; then\n    echo \"OK, exiting.\"\n    exit 0\n  fi\n  migrate_docker_nat\nfi\n\nremove_obsolete_nginx_ports\n\necho -e \"\\e[32mValidating docker-compose stack configuration...\\e[0m\"\nsed -i 's/HTTPS_BIND:-:/HTTPS_BIND:-/g' docker-compose.yml\nsed -i 's/HTTP_BIND:-:/HTTP_BIND:-/g' docker-compose.yml\nif ! $COMPOSE_COMMAND config -q; then\n  echo -e \"\\e[31m\\nOh no, something went wrong. Please check the error message above.\\e[0m\"\n  exit 1\nfi\n\necho -e \"\\e[32mChecking for conflicting bridges...\\e[0m\"\nMAILCOW_BRIDGE=$($COMPOSE_COMMAND config | grep -i com.docker.network.bridge.name | cut -d':' -f2)\nwhile read NAT_ID; do\n  iptables -t nat -D POSTROUTING $NAT_ID\ndone < <(iptables -L -vn -t nat --line-numbers | grep $IPV4_NETWORK | grep -E 'MASQUERADE.*all' | grep -v ${MAILCOW_BRIDGE} | cut -d' ' -f1)\n\nDIFF_DIRECTORY=update_diffs\nDIFF_FILE=${DIFF_DIRECTORY}/diff_before_update_$(date +\"%Y-%m-%d-%H-%M-%S\")\nmv diff_before_update* ${DIFF_DIRECTORY}/ 2> /dev/null\nif ! git diff-index --quiet HEAD; then\n  echo -e \"\\e[32mSaving diff to ${DIFF_FILE}...\\e[0m\"\n  mkdir -p ${DIFF_DIRECTORY}\n  git diff --stat > ${DIFF_FILE}\n  git diff >> ${DIFF_FILE}\nfi\n\necho -e \"\\e[32mPrefetching images...\\e[0m\"\nprefetch_images\n\necho -e \"\\e[32mStopping mailcow...\\e[0m\"\nsleep 2\nMAILCOW_CONTAINERS=($($COMPOSE_COMMAND ps -q))\n$COMPOSE_COMMAND down\necho -e \"\\e[32mChecking for remaining containers...\\e[0m\"\nsleep 2\nfor container in \"${MAILCOW_CONTAINERS[@]}\"; do\n  docker rm -f \"$container\" 2> /dev/null\ndone\n\n[[ -f data/conf/nginx/ZZZ-ejabberd.conf ]] && rm data/conf/nginx/ZZZ-ejabberd.conf\n\n\n# Silently fixing remote url from andryyy to mailcow\n# git remote set-url origin https://github.com/mailcow/mailcow-dockerized\n\nDEFAULT_REPO=https://github.com/mailcow/mailcow-dockerized\nCURRENT_REPO=$(git config --get remote.origin.url)\nif [ \"$CURRENT_REPO\" != \"$DEFAULT_REPO\" ]; then \n  echo \"The Repository currently used is not the default Mailcow Repository.\"\n  echo \"Currently Repository: $CURRENT_REPO\"\n  echo \"Default Repository:   $DEFAULT_REPO\"\n  if [ ! $FORCE ]; then\n    read -r -p \"Should it be changed back to default? [y/N] \" repo_response\n    if [[ \"$repo_response\" =~ ^([yY][eE][sS]|[yY])+$ ]]; then\n      git remote set-url origin $DEFAULT_REPO\n    fi\n  else\n      echo \"Running in forced mode... setting Repo to default!\"\n      git remote set-url origin $DEFAULT_REPO\n  fi\nfi\n\nif [ ! $DEV ]; then\n  echo -e \"\\e[32mCommitting current status...\\e[0m\"\n  [[ -z \"$(git config user.name)\" ]] && git config user.name moo\n  [[ -z \"$(git config user.email)\" ]] && git config user.email moo@cow.moo\n  [[ ! -z $(git ls-files data/conf/rspamd/override.d/worker-controller-password.inc) ]] && git rm data/conf/rspamd/override.d/worker-controller-password.inc\n  git add -u\n  git commit -am \"Before update on ${DATE}\" > /dev/null\n  echo -e \"\\e[32mFetching updated code from remote...\\e[0m\"\n  git fetch origin #${BRANCH}\n  echo -e \"\\e[32mMerging local with remote code (recursive, strategy: \\\"${MERGE_STRATEGY:-theirs}\\\", options: \\\"patience\\\"...\\e[0m\"\n  git config merge.defaultToUpstream true\n  git merge -X${MERGE_STRATEGY:-theirs} -Xpatience -m \"After update on ${DATE}\"\n  # Need to use a variable to not pass return codes of if checks\n  MERGE_RETURN=$?\n  if [[ ${MERGE_RETURN} == 128 ]]; then\n    echo -e \"\\e[31m\\nOh no, what happened?\\n=> You most likely added files to your local mailcow instance that were now added to the official mailcow repository. Please move them to another location before updating mailcow.\\e[0m\"\n    exit 1\n  elif [[ ${MERGE_RETURN} == 1 ]]; then\n    echo -e \"\\e[93mPotenial conflict, trying to fix...\\e[0m\"\n    git status --porcelain | grep -E \"UD|DU\" | awk '{print $2}' | xargs rm -v\n    git add -A\n    git commit -m \"After update on ${DATE}\" > /dev/null\n    git checkout .\n    echo -e \"\\e[32mRemoved and recreated files if necessary.\\e[0m\"\n  elif [[ ${MERGE_RETURN} != 0 ]]; then\n    echo -e \"\\e[31m\\nOh no, something went wrong. Please check the error message above.\\e[0m\"\n    echo\n    echo \"Run $COMPOSE_COMMAND up -d to restart your stack without updates or try again after fixing the mentioned errors.\"\n    exit 1\n  fi\nelif [ $DEV ]; then\n  echo -e \"\\e[33mDEVELOPER MODE: Not creating a git diff and commiting it to prevent development stuff within a backup diff...\\e[0m\"\nfi\n\necho -e \"\\e[32mFetching new images, if any...\\e[0m\"\nsleep 2\n$COMPOSE_COMMAND pull\n\n# Fix missing SSL, does not overwrite existing files\n[[ ! -d data/assets/ssl ]] && mkdir -p data/assets/ssl\ncp -n -d data/assets/ssl-example/*.pem data/assets/ssl/\n\necho -e \"Checking IPv6 settings... \"\nif grep -q 'SYSCTL_IPV6_DISABLED=1' mailcow.conf; then\n  echo\n  echo '!! IMPORTANT !!'\n  echo\n  echo 'SYSCTL_IPV6_DISABLED was removed due to complications. IPv6 can be disabled by editing \"docker-compose.yml\" and setting \"enable_ipv6: true\" to \"enable_ipv6: false\".'\n  echo \"This setting will only be active after a complete shutdown of mailcow by running $COMPOSE_COMMAND down followed by $COMPOSE_COMMAND up -d.\"\n  echo\n  echo '!! IMPORTANT !!'\n  echo\n  read -p \"Press any key to continue...\" < /dev/tty\nfi\n\n# Checking for old project name bug\nsed -i --follow-symlinks 's#COMPOSEPROJECT_NAME#COMPOSE_PROJECT_NAME#g' mailcow.conf\n\n# Fix Rspamd maps\nif [ -f data/conf/rspamd/custom/global_from_blacklist.map ]; then\n  mv data/conf/rspamd/custom/global_from_blacklist.map data/conf/rspamd/custom/global_smtp_from_blacklist.map\nfi\nif [ -f data/conf/rspamd/custom/global_from_whitelist.map ]; then\n  mv data/conf/rspamd/custom/global_from_whitelist.map data/conf/rspamd/custom/global_smtp_from_whitelist.map\nfi\n\n# Fix deprecated metrics.conf\nif [ -f \"data/conf/rspamd/local.d/metrics.conf\" ]; then\n  if [ ! -z \"$(git diff --name-only origin/master data/conf/rspamd/local.d/metrics.conf)\" ]; then\n    echo -e \"\\e[33mWARNING\\e[0m - Please migrate your customizations of data/conf/rspamd/local.d/metrics.conf to actions.conf and groups.conf after this update.\"\n    echo \"The deprecated configuration file metrics.conf will be moved to metrics.conf_deprecated after updating mailcow.\"\n  fi\n  mv data/conf/rspamd/local.d/metrics.conf data/conf/rspamd/local.d/metrics.conf_deprecated\nfi\n\n# Set app_info.inc.php\nif [ ${BRANCH} == \"master\" ]; then\n  mailcow_git_version=$(git describe --tags `git rev-list --tags --max-count=1`)\nelif [ ${BRANCH} == \"nightly\" ]; then\n  mailcow_git_version=$(git rev-parse --short $(git rev-parse @{upstream}))\n  mailcow_last_git_version=\"\"\nelse\n  mailcow_git_version=$(git rev-parse --short HEAD)\n  mailcow_last_git_version=\"\"\nfi\n\nmailcow_git_commit=$(git rev-parse origin/${BRANCH})\nmailcow_git_commit_date=$(git log -1 --format=%ci @{upstream} )\n\nif [ $? -eq 0 ]; then\n  echo '<?php' > data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_GIT_VERSION=\"'$mailcow_git_version'\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_LAST_GIT_VERSION=\"\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_GIT_OWNER=\"mailcow\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_GIT_REPO=\"mailcow-dockerized\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_GIT_URL=\"https://github.com/mailcow/mailcow-dockerized\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_GIT_COMMIT=\"'$mailcow_git_commit'\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_GIT_COMMIT_DATE=\"'$mailcow_git_commit_date'\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_BRANCH=\"'$BRANCH'\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_UPDATEDAT='$(date +%s)';' >> data/web/inc/app_info.inc.php\n  echo '?>' >> data/web/inc/app_info.inc.php\nelse\n  echo '<?php' > data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_GIT_VERSION=\"'$mailcow_git_version'\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_LAST_GIT_VERSION=\"\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_GIT_OWNER=\"mailcow\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_GIT_REPO=\"mailcow-dockerized\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_GIT_URL=\"https://github.com/mailcow/mailcow-dockerized\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_GIT_COMMIT=\"\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_GIT_COMMIT_DATE=\"\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_BRANCH=\"'$BRANCH'\";' >> data/web/inc/app_info.inc.php\n  echo '  $MAILCOW_UPDATEDAT='$(date +%s)';' >> data/web/inc/app_info.inc.php\n  echo '?>' >> data/web/inc/app_info.inc.php\n  echo -e \"\\e[33mCannot determine current git repository version...\\e[0m\"\nfi\n\nif [[ ${SKIP_START} == \"y\" ]]; then\n  echo -e \"\\e[33mNot starting mailcow, please run \\\"$COMPOSE_COMMAND up -d --remove-orphans\\\" to start mailcow.\\e[0m\"\nelse\n  echo -e \"\\e[32mStarting mailcow...\\e[0m\"\n  sleep 2\n  $COMPOSE_COMMAND up -d --remove-orphans\nfi\n\necho -e \"\\e[32mCollecting garbage...\\e[0m\"\ndocker_garbage\n\n# Run post-update-hook\nif [ -f \"${SCRIPT_DIR}/post_update_hook.sh\" ]; then\n  bash \"${SCRIPT_DIR}/post_update_hook.sh\"\nfi\n\n# echo \"In case you encounter any problem, hard-reset to a state before updating mailcow:\"\n# echo\n# git reflog --color=always | grep \"Before update on \"\n# echo\n# echo \"Use \\\"git reset --hard hash-on-the-left\\\" and run $COMPOSE_COMMAND up -d afterwards.\"\n"], "filenames": [".gitignore", "data/Dockerfiles/dovecot/docker-entrypoint.sh", "data/Dockerfiles/netfilter/main.py", "data/Dockerfiles/netfilter/modules/IPTables.py", "data/Dockerfiles/netfilter/modules/Logger.py", "data/Dockerfiles/netfilter/modules/NFTables.py", "data/conf/dovecot/dovecot.conf", "docker-compose.yml", "generate_config.sh", "update.sh"], "buggy_code_start_loc": [15, 337, 24, 2, 13, 2, 249, 23, 496, 483], "buggy_code_end_loc": [15, 337, 466, 213, 14, 495, 249, 555, 496, 756], "fixing_code_start_loc": [16, 338, 23, 3, 13, 3, 250, 24, 497, 484], "fixing_code_end_loc": [17, 347, 492, 253, 15, 657, 253, 560, 500, 765], "type": "CWE-610", "message": "mailcow is a dockerized email package, with multiple containers linked in one bridged network. A security vulnerability has been identified in mailcow affecting versions < 2024-01c. This vulnerability potentially allows attackers on the same subnet to connect to exposed ports of a Docker container, even when the port is bound to 127.0.0.1. The vulnerability has been addressed by implementing additional iptables/nftables rules. These rules drop packets for Docker containers on ports 3306, 6379, 8983, and 12345, where the input interface is not `br-mailcow` and the output interface is `br-mailcow`.", "other": {"cve": {"id": "CVE-2024-24760", "sourceIdentifier": "security-advisories@github.com", "published": "2024-02-02T16:15:56.163", "lastModified": "2024-02-10T04:04:55.743", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "mailcow is a dockerized email package, with multiple containers linked in one bridged network. A security vulnerability has been identified in mailcow affecting versions < 2024-01c. This vulnerability potentially allows attackers on the same subnet to connect to exposed ports of a Docker container, even when the port is bound to 127.0.0.1. The vulnerability has been addressed by implementing additional iptables/nftables rules. These rules drop packets for Docker containers on ports 3306, 6379, 8983, and 12345, where the input interface is not `br-mailcow` and the output interface is `br-mailcow`."}, {"lang": "es", "value": "mailcow es un paquete de correo electr\u00f3nico acoplado, con m\u00faltiples contenedores vinculados en una red puente. Se ha identificado una vulnerabilidad de seguridad en mailcow que afecta a las versiones &lt;2024-01c. Esta vulnerabilidad potencialmente permite a atacantes en la misma subred conectarse a puertos expuestos de un contenedor Docker, incluso cuando el puerto est\u00e1 vinculado a 127.0.0.1. La vulnerabilidad se ha solucionado mediante la implementaci\u00f3n de reglas adicionales de iptables/nftables. Estas reglas descartan paquetes para contenedores Docker en los puertos 3306, 6379, 8983 y 12345, donde la interfaz de entrada no es \"br-mailcow\" y la interfaz de salida es \"br-mailcow\"."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:A/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:N", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.1, "impactScore": 5.2}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-610"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mailcow:mailcow\\:_dockerized:*:*:*:*:*:*:*:*", "versionEndExcluding": "2024-01c", "matchCriteriaId": "21F5C59B-FCA1-47DA-8D0F-1CB708EF9EEF"}]}]}], "references": [{"url": "https://github.com/mailcow/mailcow-dockerized/commit/087481ac12bfa5dd715f3630f0b1697be94f7e88", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/mailcow/mailcow-dockerized/security/advisories/GHSA-gmpj-5xcm-xxx6", "source": "security-advisories@github.com", "tags": ["Mitigation", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/mailcow/mailcow-dockerized/commit/087481ac12bfa5dd715f3630f0b1697be94f7e88"}}