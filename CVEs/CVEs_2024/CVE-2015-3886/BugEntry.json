{"buggy_code": ["/* libinfinity - a GObject-based infinote implementation\n * Copyright (C) 2007-2014 Armin Burgmeier <armin@arbur.net>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,\n * MA 02110-1301, USA.\n */\n\n/* TODO: Rename to InfGtkCertificateChecker */\n/* TODO: Put the non-GUI-relevant parts of this code into libinfinity */\n/* TODO: Support CRLs/OCSP */\n\n#include <libinfgtk/inf-gtk-certificate-manager.h>\n#include <libinfgtk/inf-gtk-certificate-dialog.h>\n\n#include <libinfinity/common/inf-xml-connection.h>\n#include <libinfinity/common/inf-cert-util.h>\n#include <libinfinity/common/inf-file-util.h>\n#include <libinfinity/common/inf-error.h>\n#include <libinfinity/inf-i18n.h>\n#include <libinfinity/inf-signals.h>\n\n#include <gnutls/x509.h>\n\n#include <string.h>\n#include <errno.h>\n\ntypedef struct _InfGtkCertificateManagerQuery InfGtkCertificateManagerQuery;\nstruct _InfGtkCertificateManagerQuery {\n  InfGtkCertificateManager* manager;\n  GHashTable* known_hosts;\n  InfXmppConnection* connection;\n  InfGtkCertificateDialog* dialog;\n  GtkWidget* checkbutton;\n  InfCertificateChain* certificate_chain;\n};\n\ntypedef struct _InfGtkCertificateManagerPrivate\n  InfGtkCertificateManagerPrivate;\nstruct _InfGtkCertificateManagerPrivate {\n  GtkWindow* parent_window;\n  InfXmppManager* xmpp_manager;\n\n  gchar* known_hosts_file;\n  GSList* queries;\n};\n\ntypedef enum _InfGtkCertificateManagerError {\n  INF_GTK_CERTIFICATE_MANAGER_ERROR_DUPLICATE_HOST_ENTRY\n} InfGtkCertificateManagerError;\n\nenum {\n  PROP_0,\n\n  PROP_PARENT_WINDOW,\n  PROP_XMPP_MANAGER,\n\n  PROP_KNOWN_HOSTS_FILE\n};\n\n#define INF_GTK_CERTIFICATE_MANAGER_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_GTK_TYPE_CERTIFICATE_MANAGER, InfGtkCertificateManagerPrivate))\n\nG_DEFINE_TYPE_WITH_CODE(InfGtkCertificateManager, inf_gtk_certificate_manager, G_TYPE_OBJECT,\n  G_ADD_PRIVATE(InfGtkCertificateManager))\n\n/* When a host presents a certificate different from one that we have pinned,\n * usually we warn the user that something fishy is going on. However, if the\n * pinned certificate has expired or will expire soon, then we kind of expect\n * the certificate to change, and issue a less \"flashy\" warning message. This\n * value defines how long before the pinned certificate expires we show a\n * less dramatic warning message. */\nstatic const unsigned int\nINF_GTK_CERTIFICATE_MANAGER_EXPIRATION_TOLERANCE = 3 * 24 * 3600; /* 3 days */\n\n/* memrchr does not seem to be available everywhere, so we implement it\n * ourselves. */\nstatic void*\ninf_gtk_certificate_manager_memrchr(void* buf,\n                                    char c,\n                                    size_t len)\n{\n  char* pos;\n  char* end;\n\n  pos = buf + len;\n  end = buf;\n\n  while(pos >= end)\n  {\n    if(*(pos - 1) == c)\n      return pos - 1;\n    --pos;\n  }\n\n  return NULL;\n}\n\nstatic GQuark\ninf_gtk_certificate_manager_verify_error_quark(void)\n{\n  return g_quark_from_static_string(\n    \"INF_GTK_CERTIFICATE_MANAGER_VERIFY_ERROR\"\n  );\n}\n\n#if 0\nstatic InfGtkCertificateManagerQuery*\ninf_gtk_certificate_manager_find_query(InfGtkCertificateManager* manager,\n                                       InfXmppConnection* connection)\n{\n  InfGtkCertificateManagerPrivate* priv;\n  GSList* item;\n  InfGtkCertificateManagerQuery* query;\n\n  priv = INF_GTK_CERTIFICATE_MANAGER_PRIVATE(manager);\n  for(item = priv->queries; item != NULL; item == item->next)\n  {\n    query = (InfGtkCertificateManagerQuery*)item->data;\n    if(query->connection == connection)\n      return query;\n  }\n\n  return NULL;\n}\n#endif\n\nstatic void\ninf_gtk_certificate_manager_notify_status_cb(GObject* object,\n                                             GParamSpec* pspec,\n                                             gpointer user_data);\n\nstatic void\ninf_gtk_certificate_manager_query_free(InfGtkCertificateManagerQuery* query)\n{\n  inf_signal_handlers_disconnect_by_func(\n    G_OBJECT(query->connection),\n    G_CALLBACK(inf_gtk_certificate_manager_notify_status_cb),\n    query\n  );\n\n  g_object_unref(query->connection);\n  inf_certificate_chain_unref(query->certificate_chain);\n  gtk_widget_destroy(GTK_WIDGET(query->dialog));\n  g_hash_table_unref(query->known_hosts);\n  g_slice_free(InfGtkCertificateManagerQuery, query);\n}\n\nstatic gboolean\ninf_gtk_certificate_manager_compare_fingerprint(gnutls_x509_crt_t cert1,\n                                                gnutls_x509_crt_t cert2,\n                                                GError** error)\n{\n  static const unsigned int SHA256_DIGEST_SIZE = 32;\n\n  size_t size;\n  guchar cert1_fingerprint[SHA256_DIGEST_SIZE];\n  guchar cert2_fingerprint[SHA256_DIGEST_SIZE];\n\n  int ret;\n  int cmp;\n\n  size = SHA256_DIGEST_SIZE;\n\n  ret = gnutls_x509_crt_get_fingerprint(\n    cert1,\n    GNUTLS_DIG_SHA256,\n    cert1_fingerprint,\n    &size\n  );\n\n  if(ret == GNUTLS_E_SUCCESS)\n  {\n    g_assert(size == SHA256_DIGEST_SIZE);\n\n    ret = gnutls_x509_crt_get_fingerprint(\n      cert2,\n      GNUTLS_DIG_SHA256,\n      cert2_fingerprint,\n      &size\n    );\n  }\n\n  if(ret != GNUTLS_E_SUCCESS)\n  {\n    inf_gnutls_set_error(error, ret);\n    return FALSE;\n  }\n\n  cmp = memcmp(cert1_fingerprint, cert2_fingerprint, SHA256_DIGEST_SIZE);\n  if(cmp != 0) return FALSE;\n\n  return TRUE;\n}\n\nstatic void\ninf_gtk_certificate_manager_set_known_hosts(InfGtkCertificateManager* manager,\n                                            const gchar* known_hosts_file)\n{\n  InfGtkCertificateManagerPrivate* priv;\n  priv = INF_GTK_CERTIFICATE_MANAGER_PRIVATE(manager);\n\n  /* TODO: If there are running queries, the we need to load the new hosts\n   * file and then change it in all queries. */\n  g_assert(priv->queries == NULL);\n\n  g_free(priv->known_hosts_file);\n  priv->known_hosts_file = g_strdup(known_hosts_file);\n}\n\nstatic GHashTable*\ninf_gtk_certificate_manager_load_known_hosts(InfGtkCertificateManager* mgr,\n                                             GError** error)\n{\n  InfGtkCertificateManagerPrivate* priv;\n  GHashTable* table;\n  gchar* content;\n  gsize size;\n  GError* local_error;\n\n  gchar* out_buf;\n  gsize out_buf_len;\n  gchar* pos;\n  gchar* prev;\n  gchar* next;\n  gchar* sep;\n\n  gsize len;\n  gsize out_len;\n  gint base64_state;\n  guint base64_save;\n\n  gnutls_datum_t data;\n  gnutls_x509_crt_t cert;\n  int res;\n\n  priv = INF_GTK_CERTIFICATE_MANAGER_PRIVATE(mgr);\n\n  table = g_hash_table_new_full(\n    g_str_hash,\n    g_str_equal,\n    g_free,\n    (GDestroyNotify)gnutls_x509_crt_deinit\n  );\n\n  local_error = NULL;\n  g_file_get_contents(priv->known_hosts_file, &content, &size, &local_error);\n  if(local_error != NULL)\n  {\n    if(local_error->domain == G_FILE_ERROR &&\n       local_error->code == G_FILE_ERROR_NOENT)\n    {\n      return table;\n    }\n\n    g_propagate_prefixed_error(\n      error,\n      local_error,\n      _(\"Failed to open known hosts file \\\"%s\\\": \"),\n      priv->known_hosts_file\n    );\n\n    g_hash_table_destroy(table);\n    return NULL;\n  }\n\n  out_buf = NULL;\n  out_buf_len = 0;\n  prev = content;\n  for(prev = content; prev != NULL; prev = next)\n  {\n    pos = strchr(prev, '\\n');\n    next = NULL;\n\n    if(pos == NULL)\n      pos = content + size;\n    else\n      next = pos + 1;\n\n    sep = inf_gtk_certificate_manager_memrchr(prev, ':', pos - prev);\n    if(sep == NULL) continue; /* ignore line */\n\n    *sep = '\\0';\n    if(g_hash_table_lookup(table, prev) != NULL)\n    {\n      g_set_error(\n        error,\n        g_quark_from_static_string(\"INF_GTK_CERTIFICATE_MANAGER_ERROR\"),\n        INF_GTK_CERTIFICATE_MANAGER_ERROR_DUPLICATE_HOST_ENTRY,\n        _(\"Certificate for host \\\"%s\\\" appears twice in \"\n          \"known hosts file \\\"%s\\\"\"),\n        prev,\n        priv->known_hosts_file\n      );\n\n      g_hash_table_destroy(table);\n      g_free(out_buf);\n      g_free(content);\n      return NULL;\n    }\n\n    /* decode base64, import DER certificate */\n    len = (pos - (sep + 1));\n    out_len = len * 3 / 4;\n\n    if(out_len > out_buf_len)\n    {\n      out_buf = g_realloc(out_buf, out_len);\n      out_buf_len = out_len;\n    }\n\n    base64_state = 0;\n    base64_save = 0;\n\n    out_len = g_base64_decode_step(\n      sep + 1,\n      len,\n      out_buf,\n      &base64_state,\n      &base64_save\n    );\n\n    cert = NULL;\n    res = gnutls_x509_crt_init(&cert);\n    if(res == GNUTLS_E_SUCCESS)\n    {\n      data.data = out_buf;\n      data.size = out_len;\n      res = gnutls_x509_crt_import(cert, &data, GNUTLS_X509_FMT_DER);\n    }\n\n    if(res != GNUTLS_E_SUCCESS)\n    {\n      inf_gnutls_set_error(&local_error, res);\n\n      g_propagate_prefixed_error(\n        error,\n        local_error,\n        _(\"Failed to read certificate for host \\\"%s\\\" from \"\n          \"known hosts file \\\"%s\\\": \"),\n        prev,\n        priv->known_hosts_file\n      );\n\n      if(cert != NULL)\n        gnutls_x509_crt_deinit(cert);\n\n      g_hash_table_destroy(table);\n      g_free(out_buf);\n      g_free(content);\n      return NULL;\n    }\n\n    g_hash_table_insert(table, g_strdup(prev), cert);\n  }\n\n  g_free(out_buf);\n  g_free(content);\n  return table;\n}\n\nstatic GHashTable*\ninf_gtk_certificate_manager_ref_known_hosts(InfGtkCertificateManager* mgr,\n                                            GError** error)\n{\n  InfGtkCertificateManagerPrivate* priv;\n  InfGtkCertificateManagerQuery* query;\n\n  priv = INF_GTK_CERTIFICATE_MANAGER_PRIVATE(mgr);\n  if(priv->queries != NULL)\n  {\n    query = (InfGtkCertificateManagerQuery*)priv->queries->data;\n    g_hash_table_ref(query->known_hosts);\n    return query->known_hosts;\n  }\n  else\n  {\n    return inf_gtk_certificate_manager_load_known_hosts(mgr, error);\n  }\n}\n\nstatic gboolean\ninf_gtk_certificate_manager_write_known_hosts(InfGtkCertificateManager* mgr,\n                                              GHashTable* table,\n                                              GError** error)\n{\n  InfGtkCertificateManagerPrivate* priv;\n  gchar* dirname;\n  GIOChannel* channel;\n  GIOStatus status;\n\n  GHashTableIter iter;\n  gpointer key;\n  gpointer value;\n  const gchar* hostname;\n  gnutls_x509_crt_t cert;\n\n  size_t size;\n  int res;\n  gchar* buffer;\n  gchar* encoded_cert;\n\n  priv = INF_GTK_CERTIFICATE_MANAGER_PRIVATE(mgr);\n  \n  /* Note that we pin the whole certificate and not only the public key of\n   * our known hosts. This allows us to differentiate two cases when a\n   * host presents a new certificate:\n   *    a) The old certificate has expired or is very close to expiration. In\n   *       this case we still show a message to the user asking whether they\n   *       trust the new certificate.\n   *    b) The old certificate was perfectly valid. In this case we show a\n   *       message saying that the certificate change was unexpected, and\n   *       unless it was expected the host should not be trusted.\n   */\n  dirname = g_path_get_dirname(priv->known_hosts_file);\n  if(!inf_file_util_create_directory(dirname, 0755, error))\n  {\n    g_free(dirname);\n    return FALSE;\n  }\n\n  g_free(dirname);\n\n  channel = g_io_channel_new_file(priv->known_hosts_file, \"w\", error);\n  if(channel == NULL) return FALSE;\n\n  status = g_io_channel_set_encoding(channel, NULL, error);\n  if(status != G_IO_STATUS_NORMAL)\n  {\n    g_io_channel_unref(channel);\n    return FALSE;\n  }\n\n  g_hash_table_iter_init(&iter, table);\n  while(g_hash_table_iter_next(&iter, &key, &value))\n  {\n    hostname = (const gchar*)key;\n    cert = (gnutls_x509_crt_t)value;\n\n    size = 0;\n    res = gnutls_x509_crt_export(cert, GNUTLS_X509_FMT_DER, NULL, &size);\n    g_assert(res != GNUTLS_E_SUCCESS);\n\n    buffer = NULL;\n    if(res == GNUTLS_E_SHORT_MEMORY_BUFFER)\n    {\n      buffer = g_malloc(size);\n      res = gnutls_x509_crt_export(cert, GNUTLS_X509_FMT_DER, buffer, &size);\n    }\n\n    if(res != GNUTLS_E_SUCCESS)\n    {\n      g_free(buffer);\n      g_io_channel_unref(channel);\n      inf_gnutls_set_error(error, res);\n      return FALSE;\n    }\n\n    encoded_cert = g_base64_encode(buffer, size);\n    g_free(buffer);\n\n    status = g_io_channel_write_chars(channel, hostname, strlen(hostname), NULL, error);\n    if(status == G_IO_STATUS_NORMAL)\n      status = g_io_channel_write_chars(channel, \":\", 1, NULL, error);\n    if(status == G_IO_STATUS_NORMAL)\n      status = g_io_channel_write_chars(channel, encoded_cert, strlen(encoded_cert), NULL, error);\n    if(status == G_IO_STATUS_NORMAL)\n      status = g_io_channel_write_chars(channel, \"\\n\", 1, NULL, error);\n\n    g_free(encoded_cert);\n\n    if(status != G_IO_STATUS_NORMAL)\n    {\n      g_io_channel_unref(channel);\n      return FALSE;\n    }\n  }\n\n  g_io_channel_unref(channel);\n  return TRUE;\n}\n\nstatic void\ninf_gtk_certificate_manager_write_known_hosts_with_warning(\n  InfGtkCertificateManager* mgr,\n  GHashTable* table)\n{\n  InfGtkCertificateManagerPrivate* priv;\n  GError* error;\n  gboolean result;\n\n  priv = INF_GTK_CERTIFICATE_MANAGER_PRIVATE(mgr);\n  error = NULL;\n\n  result = inf_gtk_certificate_manager_write_known_hosts(\n    mgr,\n    table,\n    &error\n  );\n\n  if(error != NULL)\n  {\n    g_warning(\n      _(\"Failed to write file with known hosts \\\"%s\\\": %s\"),\n      priv->known_hosts_file,\n      error->message\n    );\n\n    g_error_free(error);\n  }\n}\n\nstatic void\ninf_gtk_certificate_manager_response_cb(GtkDialog* dialog,\n                                        int response_id,\n                                        gpointer user_data)\n{\n  InfGtkCertificateManagerQuery* query;\n  InfGtkCertificateManagerPrivate* priv;\n  InfXmppConnection* connection;\n\n  gchar* hostname;\n  gnutls_x509_crt_t cert;\n  gnutls_x509_crt_t known_cert;\n  GError* error;\n  gboolean cert_equal;\n\n  query = (InfGtkCertificateManagerQuery*)user_data;\n  priv = INF_GTK_CERTIFICATE_MANAGER_PRIVATE(query->manager);\n\n  connection = query->connection;\n  g_object_ref(connection);\n\n  switch(response_id)\n  {\n  case GTK_RESPONSE_ACCEPT:\n    g_object_get(\n      G_OBJECT(query->connection),\n      \"remote-hostname\", &hostname,\n      NULL\n    );\n\n    /* Add the certificate to the known hosts file, but only if it is not\n     * already, to avoid unnecessary disk I/O. */\n    cert =\n      inf_certificate_chain_get_own_certificate(query->certificate_chain);\n    known_cert = g_hash_table_lookup(query->known_hosts, hostname);\n\n    error = NULL;\n    cert_equal = FALSE;\n    if(known_cert != NULL)\n    {\n      cert_equal = inf_gtk_certificate_manager_compare_fingerprint(\n        cert,\n        known_cert,\n        &error\n      );\n    }\n\n    if(error != NULL)\n    {\n      g_warning(\n        _(\"Failed to add certificate to list of known hosts: %s\"),\n        error->message\n      );\n    }\n    else if(!cert_equal)\n    {\n      cert = inf_cert_util_copy_certificate(cert, &error);\n      g_hash_table_insert(query->known_hosts, hostname, cert);\n\n      inf_gtk_certificate_manager_write_known_hosts_with_warning(\n        query->manager,\n        query->known_hosts\n      );\n    }\n    else\n    {\n      g_free(hostname);\n    }\n\n    priv->queries = g_slist_remove(priv->queries, query);\n    inf_gtk_certificate_manager_query_free(query);\n\n    inf_xmpp_connection_certificate_verify_continue(connection);\n    break;\n  case GTK_RESPONSE_REJECT:\n  case GTK_RESPONSE_DELETE_EVENT:\n    priv->queries = g_slist_remove(priv->queries, query);\n    inf_gtk_certificate_manager_query_free(query);\n    inf_xmpp_connection_certificate_verify_cancel(connection, NULL);\n    break;\n  default:\n    g_assert_not_reached();\n    break;\n  }\n\n  g_object_unref(connection);\n}\n\nstatic void\ninf_gtk_certificate_manager_notify_status_cb(GObject* object,\n                                             GParamSpec* pspec,\n                                             gpointer user_data)\n{\n  InfGtkCertificateManagerQuery* query;\n  InfGtkCertificateManagerPrivate* priv;\n  InfXmppConnection* connection;\n  InfXmlConnectionStatus status;\n\n  query = (InfGtkCertificateManagerQuery*)user_data;\n  priv = INF_GTK_CERTIFICATE_MANAGER_PRIVATE(query->manager);\n  connection = INF_XMPP_CONNECTION(object);\n\n  g_object_get(G_OBJECT(connection), \"status\", &status, NULL);\n\n  if(status == INF_XML_CONNECTION_CLOSING ||\n     status == INF_XML_CONNECTION_CLOSED)\n  {\n    priv->queries = g_slist_remove(priv->queries, query);\n    inf_gtk_certificate_manager_query_free(query);\n  }\n}\n\nstatic void\ninf_gtk_certificate_manager_certificate_func(InfXmppConnection* connection,\n                                             gnutls_session_t session,\n                                             InfCertificateChain* chain,\n                                             gpointer user_data)\n{\n  InfGtkCertificateManager* manager;\n  InfGtkCertificateManagerPrivate* priv;\n\n  InfGtkCertificateDialogFlags flags;\n  gnutls_x509_crt_t presented_cert;\n  gnutls_x509_crt_t known_cert;\n  gchar* hostname;\n\n  gboolean match_hostname;\n  gboolean issuer_known;\n  gnutls_x509_crt_t root_cert;\n\n  int ret;\n  unsigned int verify;\n  GHashTable* table;\n  gboolean cert_equal;\n  time_t expiration_time;\n\n  InfGtkCertificateManagerQuery* query;\n  gchar* text;\n  GtkWidget* vbox;\n  GtkWidget* label;\n\n  GError* error;\n\n  manager = INF_GTK_CERTIFICATE_MANAGER(user_data);\n  priv = INF_GTK_CERTIFICATE_MANAGER_PRIVATE(manager);\n\n  g_object_get(G_OBJECT(connection), \"remote-hostname\", &hostname, NULL);\n  presented_cert = inf_certificate_chain_get_own_certificate(chain);\n\n  match_hostname = gnutls_x509_crt_check_hostname(presented_cert, hostname);\n\n  /* First, validate the certificate */\n  ret = gnutls_certificate_verify_peers2(session, &verify);\n  error = NULL;\n\n  if(ret != GNUTLS_E_SUCCESS)\n    inf_gnutls_set_error(&error, ret);\n\n  /* Remove the GNUTLS_CERT_ISSUER_NOT_KNOWN flag from the verification\n   * result, and if the certificate is still invalid, then set an error. */\n  if(error == NULL)\n  {\n    issuer_known = TRUE;\n    if(verify & GNUTLS_CERT_SIGNER_NOT_FOUND)\n    {\n      issuer_known = FALSE;\n\n      /* Re-validate the certificate for other failure reasons --\n       * unfortunately the gnutls_certificate_verify_peers2() call\n       * does not tell us whether the certificate is otherwise invalid\n       * if a signer is not found already. */\n      /* TODO: Here it would be good to use the verify flags from the\n       * certificate credentials, but GnuTLS does not have API to\n       * retrieve them. */\n      root_cert = inf_certificate_chain_get_root_certificate(chain);\n\n      ret = gnutls_x509_crt_list_verify(\n        inf_certificate_chain_get_raw(chain),\n        inf_certificate_chain_get_n_certificates(chain),\n        &root_cert,\n        1,\n        NULL,\n        0,\n        GNUTLS_VERIFY_ALLOW_X509_V1_CA_CRT,\n        &verify\n      );\n\n      if(ret != GNUTLS_E_SUCCESS)\n        inf_gnutls_set_error(&error, ret);\n      else if(verify & GNUTLS_CERT_INVALID)\n        inf_gnutls_certificate_verification_set_error(&error, verify);\n    }\n  }\n\n  /* Look up the host in our database of pinned certificates if we could not\n   * fully verify the certificate, i.e. if either the issuer is not known or\n   * the hostname of the connection does not match the certificate. */\n  table = NULL;\n  if(error == NULL)\n  {\n    known_cert = NULL;\n    if(!match_hostname || !issuer_known)\n    {\n      /* If we cannot load the known host file, then cancel the connection.\n       * Otherwise it might happen that someone shows us a certificate that we\n       * tell the user we don't know, if though actually for that host we expect\n       * a different certificate. */\n      table = inf_gtk_certificate_manager_ref_known_hosts(manager, &error);\n      if(table != NULL)\n        known_cert = g_hash_table_lookup(table, hostname);\n    }\n  }\n\n  /* Next, configure the flags for the dialog to be shown based on the\n   * verification result, and on whether the pinned certificate matches\n   * the one presented by the host or not. */\n  flags = 0;\n  if(error == NULL)\n  {\n    if(known_cert != NULL)\n    {\n      cert_equal = inf_gtk_certificate_manager_compare_fingerprint(\n        known_cert,\n        presented_cert,\n        &error\n      );\n\n      if(error == NULL && cert_equal == FALSE)\n      {\n        if(!match_hostname)\n          flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_HOSTNAME_MISMATCH;\n        if(!issuer_known)\n          flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_ISSUER_NOT_KNOWN;\n\n        flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_UNEXPECTED;\n        expiration_time = gnutls_x509_crt_get_expiration_time(known_cert);\n        if(expiration_time != (time_t)(-1))\n        {\n          expiration_time -= INF_GTK_CERTIFICATE_MANAGER_EXPIRATION_TOLERANCE;\n          if(time(NULL) > expiration_time)\n          {\n            flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_OLD_EXPIRED;\n          }\n        }\n      }\n    }\n    else\n    {\n      if(!match_hostname)\n        flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_HOSTNAME_MISMATCH;\n      if(!issuer_known)\n        flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_ISSUER_NOT_KNOWN;\n    }\n  }\n\n  /* Now proceed either by accepting the connection, rejecting it, or\n   * bothering the user with an annoying dialog. */\n  if(error == NULL)\n  {\n    if(flags == 0)\n    {\n      if(match_hostname && issuer_known)\n      {\n        /* Remove the pinned entry if we now have a valid certificate for\n         * this host. */\n        if(table != NULL && g_hash_table_remove(table, hostname) == TRUE)\n        {\n          inf_gtk_certificate_manager_write_known_hosts_with_warning(\n            manager,\n            table\n          );\n        }\n      }\n\n      inf_xmpp_connection_certificate_verify_continue(connection);\n    }\n    else\n    {\n      query = g_slice_new(InfGtkCertificateManagerQuery);\n      query->manager = manager;\n      query->known_hosts = table;\n      query->connection = connection;\n      query->dialog = inf_gtk_certificate_dialog_new(\n        priv->parent_window,\n        0,\n        flags,\n        hostname,\n        chain\n      );\n      query->certificate_chain = chain;\n\n      table = NULL;\n\n      g_object_ref(query->connection);\n      inf_certificate_chain_ref(chain);\n\n      g_signal_connect(\n        G_OBJECT(connection),\n        \"notify::status\",\n        G_CALLBACK(inf_gtk_certificate_manager_notify_status_cb),\n        query\n      );\n\n      g_signal_connect(\n        G_OBJECT(query->dialog),\n        \"response\",\n        G_CALLBACK(inf_gtk_certificate_manager_response_cb),\n        query\n      );\n\n      gtk_dialog_add_button(\n        GTK_DIALOG(query->dialog),\n        _(\"_Cancel connection\"),\n        GTK_RESPONSE_REJECT\n      );\n\n      gtk_dialog_add_button(\n        GTK_DIALOG(query->dialog),\n        _(\"C_ontinue connection\"),\n        GTK_RESPONSE_ACCEPT\n      );\n\n      text = g_strdup_printf(\n        _(\"Do you want to continue the connection to host \\\"%s\\\"? If you \"\n          \"choose to continue, this certificate will be trusted in the \"\n          \"future when connecting to this host.\"),\n        hostname\n      );\n\n      label = gtk_label_new(text);\n      gtk_label_set_line_wrap(GTK_LABEL(label), TRUE);\n      gtk_label_set_line_wrap_mode(GTK_LABEL(label), PANGO_WRAP_WORD_CHAR);\n      gtk_label_set_max_width_chars(GTK_LABEL(label), 60);\n      gtk_misc_set_alignment(GTK_MISC(label), 0.0, 0.0);\n      gtk_widget_show(label);\n      g_free(text);\n\n      vbox = gtk_dialog_get_content_area(GTK_DIALOG(query->dialog));\n      gtk_box_pack_start(GTK_BOX(vbox), label, FALSE, FALSE, 0);\n\n      priv->queries = g_slist_prepend(priv->queries, query);\n      gtk_window_present(GTK_WINDOW(query->dialog));\n    }\n  }\n  else\n  {\n    inf_xmpp_connection_certificate_verify_cancel(connection, error);\n    g_error_free(error);\n  }\n\n  if(table != NULL) g_hash_table_unref(table);\n  g_free(hostname);\n}\n\nstatic void\ninf_gtk_certificate_manager_connection_added_cb(InfXmppManager* manager,\n                                                InfXmppConnection* connection,\n                                                gpointer user_data)\n{\n  InfXmppConnectionSite site;\n  g_object_get(G_OBJECT(connection), \"site\", &site, NULL);\n\n  if(site == INF_XMPP_CONNECTION_CLIENT)\n  {\n    inf_xmpp_connection_set_certificate_callback(\n      connection,\n      GNUTLS_CERT_REQUIRE, /* require a server certificate */\n      inf_gtk_certificate_manager_certificate_func,\n      user_data,\n      NULL\n    );\n  }\n}\n\nstatic void\ninf_gtk_certificate_manager_init(InfGtkCertificateManager* manager)\n{\n  InfGtkCertificateManagerPrivate* priv;\n  priv = INF_GTK_CERTIFICATE_MANAGER_PRIVATE(manager);\n\n  priv->parent_window = NULL;\n  priv->xmpp_manager = NULL;\n  priv->known_hosts_file = NULL;\n}\n\nstatic void\ninf_gtk_certificate_manager_dispose(GObject* object)\n{\n  InfGtkCertificateManager* manager;\n  InfGtkCertificateManagerPrivate* priv;\n  GSList* item;\n\n  manager = INF_GTK_CERTIFICATE_MANAGER(object);\n  priv = INF_GTK_CERTIFICATE_MANAGER_PRIVATE(manager);\n\n  if(priv->parent_window != NULL)\n  {\n    g_object_unref(priv->parent_window);\n    priv->parent_window = NULL;\n  }\n\n  if(priv->xmpp_manager != NULL)\n  {\n    g_object_unref(priv->xmpp_manager);\n    priv->xmpp_manager = NULL;\n  }\n\n  for(item = priv->queries; item != NULL; item = g_slist_next(item))\n  {\n    inf_gtk_certificate_manager_query_free(\n      (InfGtkCertificateManagerQuery*)item->data\n    );\n  }\n\n  g_slist_free(priv->queries);\n  priv->queries = NULL;\n\n  G_OBJECT_CLASS(inf_gtk_certificate_manager_parent_class)->dispose(object);\n}\n\nstatic void\ninf_gtk_certificate_manager_finalize(GObject* object)\n{\n  InfGtkCertificateManager* manager;\n  InfGtkCertificateManagerPrivate* priv;\n\n  manager = INF_GTK_CERTIFICATE_MANAGER(object);\n  priv = INF_GTK_CERTIFICATE_MANAGER_PRIVATE(manager);\n\n  inf_gtk_certificate_manager_set_known_hosts(manager, NULL);\n  g_assert(priv->known_hosts_file == NULL);\n\n  G_OBJECT_CLASS(inf_gtk_certificate_manager_parent_class)->finalize(object);\n}\n\nstatic void\ninf_gtk_certificate_manager_set_property(GObject* object,\n                                         guint prop_id,\n                                         const GValue* value,\n                                         GParamSpec* pspec)\n{\n  InfGtkCertificateManager* manager;\n  InfGtkCertificateManagerPrivate* priv;\n\n  manager = INF_GTK_CERTIFICATE_MANAGER(object);\n  priv = INF_GTK_CERTIFICATE_MANAGER_PRIVATE(manager);\n\n  switch(prop_id)\n  {\n  case PROP_PARENT_WINDOW:\n    g_assert(priv->parent_window == NULL); /* construct/only */\n    priv->parent_window = GTK_WINDOW(g_value_dup_object(value));\n    break;\n  case PROP_XMPP_MANAGER:\n    g_assert(priv->xmpp_manager == NULL); /* construct/only */\n    priv->xmpp_manager = INF_XMPP_MANAGER(g_value_dup_object(value));\n\n    g_signal_connect(\n      G_OBJECT(priv->xmpp_manager),\n      \"connection-added\",\n      G_CALLBACK(inf_gtk_certificate_manager_connection_added_cb),\n      manager\n    );\n\n    break;\n  case PROP_KNOWN_HOSTS_FILE:\n    inf_gtk_certificate_manager_set_known_hosts(\n      manager,\n      g_value_get_string(value)\n    );\n\n    break;\n  default:\n    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n    break;\n  }\n}\n\nstatic void\ninf_gtk_certificate_manager_get_property(GObject* object,\n                                         guint prop_id,\n                                         GValue* value,\n                                         GParamSpec* pspec)\n{\n  InfGtkCertificateManager* manager;\n  InfGtkCertificateManagerPrivate* priv;\n\n  manager = INF_GTK_CERTIFICATE_MANAGER(object);\n  priv = INF_GTK_CERTIFICATE_MANAGER_PRIVATE(manager);\n\n  switch(prop_id)\n  {\n  case PROP_PARENT_WINDOW:\n    g_value_set_object(value, G_OBJECT(priv->parent_window));\n    break;\n  case PROP_XMPP_MANAGER:\n    g_value_set_object(value, G_OBJECT(priv->xmpp_manager));\n    break;\n  case PROP_KNOWN_HOSTS_FILE:\n    g_value_set_string(value, priv->known_hosts_file);\n    break;\n  default:\n    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n    break;\n  }\n}\n\n/*\n * GType registration\n */\n\nstatic void\ninf_gtk_certificate_manager_class_init(\n  InfGtkCertificateManagerClass* certificate_manager_class)\n{\n  GObjectClass* object_class;\n  object_class = G_OBJECT_CLASS(certificate_manager_class);\n\n  object_class->dispose = inf_gtk_certificate_manager_dispose;\n  object_class->finalize = inf_gtk_certificate_manager_finalize;\n  object_class->set_property = inf_gtk_certificate_manager_set_property;\n  object_class->get_property = inf_gtk_certificate_manager_get_property;\n\n  g_object_class_install_property(\n    object_class,\n    PROP_PARENT_WINDOW,\n    g_param_spec_object(\n      \"parent-window\",\n      \"Parent window\",\n      \"The parent window for certificate approval dialogs\",\n      GTK_TYPE_WINDOW,\n      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY\n    )\n  );\n\n  g_object_class_install_property(\n    object_class,\n    PROP_XMPP_MANAGER,\n    g_param_spec_object(\n      \"xmpp-manager\",\n      \"XMPP manager\",\n      \"The XMPP manager of registered connections\",\n      INF_TYPE_XMPP_MANAGER,\n      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY\n    )\n  );\n\n  g_object_class_install_property(\n    object_class,\n    PROP_KNOWN_HOSTS_FILE,\n    g_param_spec_string(\n      \"known-hosts-file\",\n      \"Known hosts file\",\n      \"File containing certificates of known hosts\",\n      NULL,\n      G_PARAM_READWRITE\n    )\n  );\n}\n\n/*\n * Public API.\n */\n\n/**\n * inf_gtk_certificate_manager_new: (constructor)\n * @parent_window: The #GtkWindow to which to make certificate approval\n * dialogs transient to.\n * @xmpp_manager: The #InfXmppManager whose #InfXmppConnection<!-- -->s to\n * manage the certificates for.\n * @known_hosts_file: (type filename) (allow-none): Path pointing to a file\n * that contains certificates of known hosts, or %NULL.\n *\n * Creates a new #InfGtkCertificateManager. For each new client-side\n * #InfXmppConnection in @xmpp_manager, the certificate manager will verify\n * the server's certificate.\n *\n * If the certificate is contained in @known_hosts_file, then\n * the certificate is accepted automatically. Otherwise, the user is asked for\n * approval. If the user approves the certificate, then it is inserted into\n * the @known_hosts_file.\n *\n * Returns: (transfer full): A new #InfGtkCertificateManager.\n **/\nInfGtkCertificateManager*\ninf_gtk_certificate_manager_new(GtkWindow* parent_window,\n                                InfXmppManager* xmpp_manager,\n                                const gchar* known_hosts_file)\n{\n  GObject* object;\n\n  object = g_object_new(\n    INF_GTK_TYPE_CERTIFICATE_MANAGER,\n    \"parent-window\", parent_window,\n    \"xmpp-manager\", xmpp_manager,\n    \"known-hosts-file\", known_hosts_file,\n    NULL\n  );\n\n  return INF_GTK_CERTIFICATE_MANAGER(object);\n}\n\n/* vim:set et sw=2 ts=2: */\n"], "fixing_code": ["/* libinfinity - a GObject-based infinote implementation\n * Copyright (C) 2007-2014 Armin Burgmeier <armin@arbur.net>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,\n * MA 02110-1301, USA.\n */\n\n/* TODO: Rename to InfGtkCertificateChecker */\n/* TODO: Put the non-GUI-relevant parts of this code into libinfinity */\n/* TODO: Support CRLs/OCSP */\n\n#include <libinfgtk/inf-gtk-certificate-manager.h>\n#include <libinfgtk/inf-gtk-certificate-dialog.h>\n\n#include <libinfinity/common/inf-xml-connection.h>\n#include <libinfinity/common/inf-cert-util.h>\n#include <libinfinity/common/inf-file-util.h>\n#include <libinfinity/common/inf-error.h>\n#include <libinfinity/inf-i18n.h>\n#include <libinfinity/inf-signals.h>\n\n#include <gnutls/x509.h>\n\n#include <string.h>\n#include <errno.h>\n\ntypedef struct _InfGtkCertificateManagerQuery InfGtkCertificateManagerQuery;\nstruct _InfGtkCertificateManagerQuery {\n  InfGtkCertificateManager* manager;\n  GHashTable* known_hosts;\n  InfXmppConnection* connection;\n  InfGtkCertificateDialog* dialog;\n  GtkWidget* checkbutton;\n  InfCertificateChain* certificate_chain;\n};\n\ntypedef struct _InfGtkCertificateManagerPrivate\n  InfGtkCertificateManagerPrivate;\nstruct _InfGtkCertificateManagerPrivate {\n  GtkWindow* parent_window;\n  InfXmppManager* xmpp_manager;\n\n  gchar* known_hosts_file;\n  GSList* queries;\n};\n\ntypedef enum _InfGtkCertificateManagerError {\n  INF_GTK_CERTIFICATE_MANAGER_ERROR_DUPLICATE_HOST_ENTRY\n} InfGtkCertificateManagerError;\n\nenum {\n  PROP_0,\n\n  PROP_PARENT_WINDOW,\n  PROP_XMPP_MANAGER,\n\n  PROP_KNOWN_HOSTS_FILE\n};\n\n#define INF_GTK_CERTIFICATE_MANAGER_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_GTK_TYPE_CERTIFICATE_MANAGER, InfGtkCertificateManagerPrivate))\n\nG_DEFINE_TYPE_WITH_CODE(InfGtkCertificateManager, inf_gtk_certificate_manager, G_TYPE_OBJECT,\n  G_ADD_PRIVATE(InfGtkCertificateManager))\n\n/* When a host presents a certificate different from one that we have pinned,\n * usually we warn the user that something fishy is going on. However, if the\n * pinned certificate has expired or will expire soon, then we kind of expect\n * the certificate to change, and issue a less \"flashy\" warning message. This\n * value defines how long before the pinned certificate expires we show a\n * less dramatic warning message. */\nstatic const unsigned int\nINF_GTK_CERTIFICATE_MANAGER_EXPIRATION_TOLERANCE = 3 * 24 * 3600; /* 3 days */\n\n/* memrchr does not seem to be available everywhere, so we implement it\n * ourselves. */\nstatic void*\ninf_gtk_certificate_manager_memrchr(void* buf,\n                                    char c,\n                                    size_t len)\n{\n  char* pos;\n  char* end;\n\n  pos = buf + len;\n  end = buf;\n\n  while(pos >= end)\n  {\n    if(*(pos - 1) == c)\n      return pos - 1;\n    --pos;\n  }\n\n  return NULL;\n}\n\nstatic GQuark\ninf_gtk_certificate_manager_verify_error_quark(void)\n{\n  return g_quark_from_static_string(\n    \"INF_GTK_CERTIFICATE_MANAGER_VERIFY_ERROR\"\n  );\n}\n\n#if 0\nstatic InfGtkCertificateManagerQuery*\ninf_gtk_certificate_manager_find_query(InfGtkCertificateManager* manager,\n                                       InfXmppConnection* connection)\n{\n  InfGtkCertificateManagerPrivate* priv;\n  GSList* item;\n  InfGtkCertificateManagerQuery* query;\n\n  priv = INF_GTK_CERTIFICATE_MANAGER_PRIVATE(manager);\n  for(item = priv->queries; item != NULL; item == item->next)\n  {\n    query = (InfGtkCertificateManagerQuery*)item->data;\n    if(query->connection == connection)\n      return query;\n  }\n\n  return NULL;\n}\n#endif\n\nstatic void\ninf_gtk_certificate_manager_notify_status_cb(GObject* object,\n                                             GParamSpec* pspec,\n                                             gpointer user_data);\n\nstatic void\ninf_gtk_certificate_manager_query_free(InfGtkCertificateManagerQuery* query)\n{\n  inf_signal_handlers_disconnect_by_func(\n    G_OBJECT(query->connection),\n    G_CALLBACK(inf_gtk_certificate_manager_notify_status_cb),\n    query\n  );\n\n  g_object_unref(query->connection);\n  inf_certificate_chain_unref(query->certificate_chain);\n  gtk_widget_destroy(GTK_WIDGET(query->dialog));\n  g_hash_table_unref(query->known_hosts);\n  g_slice_free(InfGtkCertificateManagerQuery, query);\n}\n\nstatic gboolean\ninf_gtk_certificate_manager_compare_fingerprint(gnutls_x509_crt_t cert1,\n                                                gnutls_x509_crt_t cert2,\n                                                GError** error)\n{\n  static const unsigned int SHA256_DIGEST_SIZE = 32;\n\n  size_t size;\n  guchar cert1_fingerprint[SHA256_DIGEST_SIZE];\n  guchar cert2_fingerprint[SHA256_DIGEST_SIZE];\n\n  int ret;\n  int cmp;\n\n  size = SHA256_DIGEST_SIZE;\n\n  ret = gnutls_x509_crt_get_fingerprint(\n    cert1,\n    GNUTLS_DIG_SHA256,\n    cert1_fingerprint,\n    &size\n  );\n\n  if(ret == GNUTLS_E_SUCCESS)\n  {\n    g_assert(size == SHA256_DIGEST_SIZE);\n\n    ret = gnutls_x509_crt_get_fingerprint(\n      cert2,\n      GNUTLS_DIG_SHA256,\n      cert2_fingerprint,\n      &size\n    );\n  }\n\n  if(ret != GNUTLS_E_SUCCESS)\n  {\n    inf_gnutls_set_error(error, ret);\n    return FALSE;\n  }\n\n  cmp = memcmp(cert1_fingerprint, cert2_fingerprint, SHA256_DIGEST_SIZE);\n  if(cmp != 0) return FALSE;\n\n  return TRUE;\n}\n\nstatic void\ninf_gtk_certificate_manager_set_known_hosts(InfGtkCertificateManager* manager,\n                                            const gchar* known_hosts_file)\n{\n  InfGtkCertificateManagerPrivate* priv;\n  priv = INF_GTK_CERTIFICATE_MANAGER_PRIVATE(manager);\n\n  /* TODO: If there are running queries, the we need to load the new hosts\n   * file and then change it in all queries. */\n  g_assert(priv->queries == NULL);\n\n  g_free(priv->known_hosts_file);\n  priv->known_hosts_file = g_strdup(known_hosts_file);\n}\n\nstatic GHashTable*\ninf_gtk_certificate_manager_load_known_hosts(InfGtkCertificateManager* mgr,\n                                             GError** error)\n{\n  InfGtkCertificateManagerPrivate* priv;\n  GHashTable* table;\n  gchar* content;\n  gsize size;\n  GError* local_error;\n\n  gchar* out_buf;\n  gsize out_buf_len;\n  gchar* pos;\n  gchar* prev;\n  gchar* next;\n  gchar* sep;\n\n  gsize len;\n  gsize out_len;\n  gint base64_state;\n  guint base64_save;\n\n  gnutls_datum_t data;\n  gnutls_x509_crt_t cert;\n  int res;\n\n  priv = INF_GTK_CERTIFICATE_MANAGER_PRIVATE(mgr);\n\n  table = g_hash_table_new_full(\n    g_str_hash,\n    g_str_equal,\n    g_free,\n    (GDestroyNotify)gnutls_x509_crt_deinit\n  );\n\n  local_error = NULL;\n  g_file_get_contents(priv->known_hosts_file, &content, &size, &local_error);\n  if(local_error != NULL)\n  {\n    if(local_error->domain == G_FILE_ERROR &&\n       local_error->code == G_FILE_ERROR_NOENT)\n    {\n      return table;\n    }\n\n    g_propagate_prefixed_error(\n      error,\n      local_error,\n      _(\"Failed to open known hosts file \\\"%s\\\": \"),\n      priv->known_hosts_file\n    );\n\n    g_hash_table_destroy(table);\n    return NULL;\n  }\n\n  out_buf = NULL;\n  out_buf_len = 0;\n  prev = content;\n  for(prev = content; prev != NULL; prev = next)\n  {\n    pos = strchr(prev, '\\n');\n    next = NULL;\n\n    if(pos == NULL)\n      pos = content + size;\n    else\n      next = pos + 1;\n\n    sep = inf_gtk_certificate_manager_memrchr(prev, ':', pos - prev);\n    if(sep == NULL) continue; /* ignore line */\n\n    *sep = '\\0';\n    if(g_hash_table_lookup(table, prev) != NULL)\n    {\n      g_set_error(\n        error,\n        g_quark_from_static_string(\"INF_GTK_CERTIFICATE_MANAGER_ERROR\"),\n        INF_GTK_CERTIFICATE_MANAGER_ERROR_DUPLICATE_HOST_ENTRY,\n        _(\"Certificate for host \\\"%s\\\" appears twice in \"\n          \"known hosts file \\\"%s\\\"\"),\n        prev,\n        priv->known_hosts_file\n      );\n\n      g_hash_table_destroy(table);\n      g_free(out_buf);\n      g_free(content);\n      return NULL;\n    }\n\n    /* decode base64, import DER certificate */\n    len = (pos - (sep + 1));\n    out_len = len * 3 / 4;\n\n    if(out_len > out_buf_len)\n    {\n      out_buf = g_realloc(out_buf, out_len);\n      out_buf_len = out_len;\n    }\n\n    base64_state = 0;\n    base64_save = 0;\n\n    out_len = g_base64_decode_step(\n      sep + 1,\n      len,\n      out_buf,\n      &base64_state,\n      &base64_save\n    );\n\n    cert = NULL;\n    res = gnutls_x509_crt_init(&cert);\n    if(res == GNUTLS_E_SUCCESS)\n    {\n      data.data = out_buf;\n      data.size = out_len;\n      res = gnutls_x509_crt_import(cert, &data, GNUTLS_X509_FMT_DER);\n    }\n\n    if(res != GNUTLS_E_SUCCESS)\n    {\n      inf_gnutls_set_error(&local_error, res);\n\n      g_propagate_prefixed_error(\n        error,\n        local_error,\n        _(\"Failed to read certificate for host \\\"%s\\\" from \"\n          \"known hosts file \\\"%s\\\": \"),\n        prev,\n        priv->known_hosts_file\n      );\n\n      if(cert != NULL)\n        gnutls_x509_crt_deinit(cert);\n\n      g_hash_table_destroy(table);\n      g_free(out_buf);\n      g_free(content);\n      return NULL;\n    }\n\n    g_hash_table_insert(table, g_strdup(prev), cert);\n  }\n\n  g_free(out_buf);\n  g_free(content);\n  return table;\n}\n\nstatic GHashTable*\ninf_gtk_certificate_manager_ref_known_hosts(InfGtkCertificateManager* mgr,\n                                            GError** error)\n{\n  InfGtkCertificateManagerPrivate* priv;\n  InfGtkCertificateManagerQuery* query;\n\n  priv = INF_GTK_CERTIFICATE_MANAGER_PRIVATE(mgr);\n  if(priv->queries != NULL)\n  {\n    query = (InfGtkCertificateManagerQuery*)priv->queries->data;\n    g_hash_table_ref(query->known_hosts);\n    return query->known_hosts;\n  }\n  else\n  {\n    return inf_gtk_certificate_manager_load_known_hosts(mgr, error);\n  }\n}\n\nstatic gboolean\ninf_gtk_certificate_manager_write_known_hosts(InfGtkCertificateManager* mgr,\n                                              GHashTable* table,\n                                              GError** error)\n{\n  InfGtkCertificateManagerPrivate* priv;\n  gchar* dirname;\n  GIOChannel* channel;\n  GIOStatus status;\n\n  GHashTableIter iter;\n  gpointer key;\n  gpointer value;\n  const gchar* hostname;\n  gnutls_x509_crt_t cert;\n\n  size_t size;\n  int res;\n  gchar* buffer;\n  gchar* encoded_cert;\n\n  priv = INF_GTK_CERTIFICATE_MANAGER_PRIVATE(mgr);\n  \n  /* Note that we pin the whole certificate and not only the public key of\n   * our known hosts. This allows us to differentiate two cases when a\n   * host presents a new certificate:\n   *    a) The old certificate has expired or is very close to expiration. In\n   *       this case we still show a message to the user asking whether they\n   *       trust the new certificate.\n   *    b) The old certificate was perfectly valid. In this case we show a\n   *       message saying that the certificate change was unexpected, and\n   *       unless it was expected the host should not be trusted.\n   */\n  dirname = g_path_get_dirname(priv->known_hosts_file);\n  if(!inf_file_util_create_directory(dirname, 0755, error))\n  {\n    g_free(dirname);\n    return FALSE;\n  }\n\n  g_free(dirname);\n\n  channel = g_io_channel_new_file(priv->known_hosts_file, \"w\", error);\n  if(channel == NULL) return FALSE;\n\n  status = g_io_channel_set_encoding(channel, NULL, error);\n  if(status != G_IO_STATUS_NORMAL)\n  {\n    g_io_channel_unref(channel);\n    return FALSE;\n  }\n\n  g_hash_table_iter_init(&iter, table);\n  while(g_hash_table_iter_next(&iter, &key, &value))\n  {\n    hostname = (const gchar*)key;\n    cert = (gnutls_x509_crt_t)value;\n\n    size = 0;\n    res = gnutls_x509_crt_export(cert, GNUTLS_X509_FMT_DER, NULL, &size);\n    g_assert(res != GNUTLS_E_SUCCESS);\n\n    buffer = NULL;\n    if(res == GNUTLS_E_SHORT_MEMORY_BUFFER)\n    {\n      buffer = g_malloc(size);\n      res = gnutls_x509_crt_export(cert, GNUTLS_X509_FMT_DER, buffer, &size);\n    }\n\n    if(res != GNUTLS_E_SUCCESS)\n    {\n      g_free(buffer);\n      g_io_channel_unref(channel);\n      inf_gnutls_set_error(error, res);\n      return FALSE;\n    }\n\n    encoded_cert = g_base64_encode(buffer, size);\n    g_free(buffer);\n\n    status = g_io_channel_write_chars(channel, hostname, strlen(hostname), NULL, error);\n    if(status == G_IO_STATUS_NORMAL)\n      status = g_io_channel_write_chars(channel, \":\", 1, NULL, error);\n    if(status == G_IO_STATUS_NORMAL)\n      status = g_io_channel_write_chars(channel, encoded_cert, strlen(encoded_cert), NULL, error);\n    if(status == G_IO_STATUS_NORMAL)\n      status = g_io_channel_write_chars(channel, \"\\n\", 1, NULL, error);\n\n    g_free(encoded_cert);\n\n    if(status != G_IO_STATUS_NORMAL)\n    {\n      g_io_channel_unref(channel);\n      return FALSE;\n    }\n  }\n\n  g_io_channel_unref(channel);\n  return TRUE;\n}\n\nstatic void\ninf_gtk_certificate_manager_write_known_hosts_with_warning(\n  InfGtkCertificateManager* mgr,\n  GHashTable* table)\n{\n  InfGtkCertificateManagerPrivate* priv;\n  GError* error;\n  gboolean result;\n\n  priv = INF_GTK_CERTIFICATE_MANAGER_PRIVATE(mgr);\n  error = NULL;\n\n  result = inf_gtk_certificate_manager_write_known_hosts(\n    mgr,\n    table,\n    &error\n  );\n\n  if(error != NULL)\n  {\n    g_warning(\n      _(\"Failed to write file with known hosts \\\"%s\\\": %s\"),\n      priv->known_hosts_file,\n      error->message\n    );\n\n    g_error_free(error);\n  }\n}\n\nstatic void\ninf_gtk_certificate_manager_response_cb(GtkDialog* dialog,\n                                        int response_id,\n                                        gpointer user_data)\n{\n  InfGtkCertificateManagerQuery* query;\n  InfGtkCertificateManagerPrivate* priv;\n  InfXmppConnection* connection;\n\n  gchar* hostname;\n  gnutls_x509_crt_t cert;\n  gnutls_x509_crt_t known_cert;\n  GError* error;\n  gboolean cert_equal;\n\n  query = (InfGtkCertificateManagerQuery*)user_data;\n  priv = INF_GTK_CERTIFICATE_MANAGER_PRIVATE(query->manager);\n\n  connection = query->connection;\n  g_object_ref(connection);\n\n  switch(response_id)\n  {\n  case GTK_RESPONSE_ACCEPT:\n    g_object_get(\n      G_OBJECT(query->connection),\n      \"remote-hostname\", &hostname,\n      NULL\n    );\n\n    /* Add the certificate to the known hosts file, but only if it is not\n     * already, to avoid unnecessary disk I/O. */\n    cert =\n      inf_certificate_chain_get_own_certificate(query->certificate_chain);\n    known_cert = g_hash_table_lookup(query->known_hosts, hostname);\n\n    error = NULL;\n    cert_equal = FALSE;\n    if(known_cert != NULL)\n    {\n      cert_equal = inf_gtk_certificate_manager_compare_fingerprint(\n        cert,\n        known_cert,\n        &error\n      );\n    }\n\n    if(error != NULL)\n    {\n      g_warning(\n        _(\"Failed to add certificate to list of known hosts: %s\"),\n        error->message\n      );\n    }\n    else if(!cert_equal)\n    {\n      cert = inf_cert_util_copy_certificate(cert, &error);\n      g_hash_table_insert(query->known_hosts, hostname, cert);\n\n      inf_gtk_certificate_manager_write_known_hosts_with_warning(\n        query->manager,\n        query->known_hosts\n      );\n    }\n    else\n    {\n      g_free(hostname);\n    }\n\n    priv->queries = g_slist_remove(priv->queries, query);\n    inf_gtk_certificate_manager_query_free(query);\n\n    inf_xmpp_connection_certificate_verify_continue(connection);\n    break;\n  case GTK_RESPONSE_REJECT:\n  case GTK_RESPONSE_DELETE_EVENT:\n    priv->queries = g_slist_remove(priv->queries, query);\n    inf_gtk_certificate_manager_query_free(query);\n    inf_xmpp_connection_certificate_verify_cancel(connection, NULL);\n    break;\n  default:\n    g_assert_not_reached();\n    break;\n  }\n\n  g_object_unref(connection);\n}\n\nstatic void\ninf_gtk_certificate_manager_notify_status_cb(GObject* object,\n                                             GParamSpec* pspec,\n                                             gpointer user_data)\n{\n  InfGtkCertificateManagerQuery* query;\n  InfGtkCertificateManagerPrivate* priv;\n  InfXmppConnection* connection;\n  InfXmlConnectionStatus status;\n\n  query = (InfGtkCertificateManagerQuery*)user_data;\n  priv = INF_GTK_CERTIFICATE_MANAGER_PRIVATE(query->manager);\n  connection = INF_XMPP_CONNECTION(object);\n\n  g_object_get(G_OBJECT(connection), \"status\", &status, NULL);\n\n  if(status == INF_XML_CONNECTION_CLOSING ||\n     status == INF_XML_CONNECTION_CLOSED)\n  {\n    priv->queries = g_slist_remove(priv->queries, query);\n    inf_gtk_certificate_manager_query_free(query);\n  }\n}\n\nstatic void\ninf_gtk_certificate_manager_certificate_func(InfXmppConnection* connection,\n                                             gnutls_session_t session,\n                                             InfCertificateChain* chain,\n                                             gpointer user_data)\n{\n  InfGtkCertificateManager* manager;\n  InfGtkCertificateManagerPrivate* priv;\n\n  InfGtkCertificateDialogFlags flags;\n  gnutls_x509_crt_t presented_cert;\n  gnutls_x509_crt_t known_cert;\n  gchar* hostname;\n\n  gboolean match_hostname;\n  gboolean issuer_known;\n  gnutls_x509_crt_t root_cert;\n\n  int ret;\n  unsigned int verify;\n  GHashTable* table;\n  gboolean cert_equal;\n  time_t expiration_time;\n\n  InfGtkCertificateManagerQuery* query;\n  gchar* text;\n  GtkWidget* vbox;\n  GtkWidget* label;\n\n  GError* error;\n\n  manager = INF_GTK_CERTIFICATE_MANAGER(user_data);\n  priv = INF_GTK_CERTIFICATE_MANAGER_PRIVATE(manager);\n\n  g_object_get(G_OBJECT(connection), \"remote-hostname\", &hostname, NULL);\n  presented_cert = inf_certificate_chain_get_own_certificate(chain);\n\n  match_hostname = gnutls_x509_crt_check_hostname(presented_cert, hostname);\n\n  /* First, validate the certificate */\n  ret = gnutls_certificate_verify_peers2(session, &verify);\n  error = NULL;\n\n  if(ret != GNUTLS_E_SUCCESS)\n    inf_gnutls_set_error(&error, ret);\n\n  /* Remove the GNUTLS_CERT_ISSUER_NOT_KNOWN flag from the verification\n   * result, and if the certificate is still invalid, then set an error. */\n  if(error == NULL)\n  {\n    issuer_known = TRUE;\n    if(verify & GNUTLS_CERT_SIGNER_NOT_FOUND)\n    {\n      issuer_known = FALSE;\n\n      /* Re-validate the certificate for other failure reasons --\n       * unfortunately the gnutls_certificate_verify_peers2() call\n       * does not tell us whether the certificate is otherwise invalid\n       * if a signer is not found already. */\n      /* TODO: Here it would be good to use the verify flags from the\n       * certificate credentials, but GnuTLS does not have API to\n       * retrieve them. */\n      root_cert = inf_certificate_chain_get_root_certificate(chain);\n\n      ret = gnutls_x509_crt_list_verify(\n        inf_certificate_chain_get_raw(chain),\n        inf_certificate_chain_get_n_certificates(chain),\n        &root_cert,\n        1,\n        NULL,\n        0,\n        GNUTLS_VERIFY_ALLOW_X509_V1_CA_CRT,\n        &verify\n      );\n\n      if(ret != GNUTLS_E_SUCCESS)\n        inf_gnutls_set_error(&error, ret);\n    }\n\n    if(error == NULL)\n      if(verify & GNUTLS_CERT_INVALID)\n        inf_gnutls_certificate_verification_set_error(&error, verify);\n  }\n\n  /* Look up the host in our database of pinned certificates if we could not\n   * fully verify the certificate, i.e. if either the issuer is not known or\n   * the hostname of the connection does not match the certificate. */\n  table = NULL;\n  if(error == NULL)\n  {\n    known_cert = NULL;\n    if(!match_hostname || !issuer_known)\n    {\n      /* If we cannot load the known host file, then cancel the connection.\n       * Otherwise it might happen that someone shows us a certificate that we\n       * tell the user we don't know, if though actually for that host we expect\n       * a different certificate. */\n      table = inf_gtk_certificate_manager_ref_known_hosts(manager, &error);\n      if(table != NULL)\n        known_cert = g_hash_table_lookup(table, hostname);\n    }\n  }\n\n  /* Next, configure the flags for the dialog to be shown based on the\n   * verification result, and on whether the pinned certificate matches\n   * the one presented by the host or not. */\n  flags = 0;\n  if(error == NULL)\n  {\n    if(known_cert != NULL)\n    {\n      cert_equal = inf_gtk_certificate_manager_compare_fingerprint(\n        known_cert,\n        presented_cert,\n        &error\n      );\n\n      if(error == NULL && cert_equal == FALSE)\n      {\n        if(!match_hostname)\n          flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_HOSTNAME_MISMATCH;\n        if(!issuer_known)\n          flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_ISSUER_NOT_KNOWN;\n\n        flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_UNEXPECTED;\n        expiration_time = gnutls_x509_crt_get_expiration_time(known_cert);\n        if(expiration_time != (time_t)(-1))\n        {\n          expiration_time -= INF_GTK_CERTIFICATE_MANAGER_EXPIRATION_TOLERANCE;\n          if(time(NULL) > expiration_time)\n          {\n            flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_OLD_EXPIRED;\n          }\n        }\n      }\n    }\n    else\n    {\n      if(!match_hostname)\n        flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_HOSTNAME_MISMATCH;\n      if(!issuer_known)\n        flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_ISSUER_NOT_KNOWN;\n    }\n  }\n\n  /* Now proceed either by accepting the connection, rejecting it, or\n   * bothering the user with an annoying dialog. */\n  if(error == NULL)\n  {\n    if(flags == 0)\n    {\n      if(match_hostname && issuer_known)\n      {\n        /* Remove the pinned entry if we now have a valid certificate for\n         * this host. */\n        if(table != NULL && g_hash_table_remove(table, hostname) == TRUE)\n        {\n          inf_gtk_certificate_manager_write_known_hosts_with_warning(\n            manager,\n            table\n          );\n        }\n      }\n\n      inf_xmpp_connection_certificate_verify_continue(connection);\n    }\n    else\n    {\n      query = g_slice_new(InfGtkCertificateManagerQuery);\n      query->manager = manager;\n      query->known_hosts = table;\n      query->connection = connection;\n      query->dialog = inf_gtk_certificate_dialog_new(\n        priv->parent_window,\n        0,\n        flags,\n        hostname,\n        chain\n      );\n      query->certificate_chain = chain;\n\n      table = NULL;\n\n      g_object_ref(query->connection);\n      inf_certificate_chain_ref(chain);\n\n      g_signal_connect(\n        G_OBJECT(connection),\n        \"notify::status\",\n        G_CALLBACK(inf_gtk_certificate_manager_notify_status_cb),\n        query\n      );\n\n      g_signal_connect(\n        G_OBJECT(query->dialog),\n        \"response\",\n        G_CALLBACK(inf_gtk_certificate_manager_response_cb),\n        query\n      );\n\n      gtk_dialog_add_button(\n        GTK_DIALOG(query->dialog),\n        _(\"_Cancel connection\"),\n        GTK_RESPONSE_REJECT\n      );\n\n      gtk_dialog_add_button(\n        GTK_DIALOG(query->dialog),\n        _(\"C_ontinue connection\"),\n        GTK_RESPONSE_ACCEPT\n      );\n\n      text = g_strdup_printf(\n        _(\"Do you want to continue the connection to host \\\"%s\\\"? If you \"\n          \"choose to continue, this certificate will be trusted in the \"\n          \"future when connecting to this host.\"),\n        hostname\n      );\n\n      label = gtk_label_new(text);\n      gtk_label_set_line_wrap(GTK_LABEL(label), TRUE);\n      gtk_label_set_line_wrap_mode(GTK_LABEL(label), PANGO_WRAP_WORD_CHAR);\n      gtk_label_set_max_width_chars(GTK_LABEL(label), 60);\n      gtk_misc_set_alignment(GTK_MISC(label), 0.0, 0.0);\n      gtk_widget_show(label);\n      g_free(text);\n\n      vbox = gtk_dialog_get_content_area(GTK_DIALOG(query->dialog));\n      gtk_box_pack_start(GTK_BOX(vbox), label, FALSE, FALSE, 0);\n\n      priv->queries = g_slist_prepend(priv->queries, query);\n      gtk_window_present(GTK_WINDOW(query->dialog));\n    }\n  }\n  else\n  {\n    inf_xmpp_connection_certificate_verify_cancel(connection, error);\n    g_error_free(error);\n  }\n\n  if(table != NULL) g_hash_table_unref(table);\n  g_free(hostname);\n}\n\nstatic void\ninf_gtk_certificate_manager_connection_added_cb(InfXmppManager* manager,\n                                                InfXmppConnection* connection,\n                                                gpointer user_data)\n{\n  InfXmppConnectionSite site;\n  g_object_get(G_OBJECT(connection), \"site\", &site, NULL);\n\n  if(site == INF_XMPP_CONNECTION_CLIENT)\n  {\n    inf_xmpp_connection_set_certificate_callback(\n      connection,\n      GNUTLS_CERT_REQUIRE, /* require a server certificate */\n      inf_gtk_certificate_manager_certificate_func,\n      user_data,\n      NULL\n    );\n  }\n}\n\nstatic void\ninf_gtk_certificate_manager_init(InfGtkCertificateManager* manager)\n{\n  InfGtkCertificateManagerPrivate* priv;\n  priv = INF_GTK_CERTIFICATE_MANAGER_PRIVATE(manager);\n\n  priv->parent_window = NULL;\n  priv->xmpp_manager = NULL;\n  priv->known_hosts_file = NULL;\n}\n\nstatic void\ninf_gtk_certificate_manager_dispose(GObject* object)\n{\n  InfGtkCertificateManager* manager;\n  InfGtkCertificateManagerPrivate* priv;\n  GSList* item;\n\n  manager = INF_GTK_CERTIFICATE_MANAGER(object);\n  priv = INF_GTK_CERTIFICATE_MANAGER_PRIVATE(manager);\n\n  if(priv->parent_window != NULL)\n  {\n    g_object_unref(priv->parent_window);\n    priv->parent_window = NULL;\n  }\n\n  if(priv->xmpp_manager != NULL)\n  {\n    g_object_unref(priv->xmpp_manager);\n    priv->xmpp_manager = NULL;\n  }\n\n  for(item = priv->queries; item != NULL; item = g_slist_next(item))\n  {\n    inf_gtk_certificate_manager_query_free(\n      (InfGtkCertificateManagerQuery*)item->data\n    );\n  }\n\n  g_slist_free(priv->queries);\n  priv->queries = NULL;\n\n  G_OBJECT_CLASS(inf_gtk_certificate_manager_parent_class)->dispose(object);\n}\n\nstatic void\ninf_gtk_certificate_manager_finalize(GObject* object)\n{\n  InfGtkCertificateManager* manager;\n  InfGtkCertificateManagerPrivate* priv;\n\n  manager = INF_GTK_CERTIFICATE_MANAGER(object);\n  priv = INF_GTK_CERTIFICATE_MANAGER_PRIVATE(manager);\n\n  inf_gtk_certificate_manager_set_known_hosts(manager, NULL);\n  g_assert(priv->known_hosts_file == NULL);\n\n  G_OBJECT_CLASS(inf_gtk_certificate_manager_parent_class)->finalize(object);\n}\n\nstatic void\ninf_gtk_certificate_manager_set_property(GObject* object,\n                                         guint prop_id,\n                                         const GValue* value,\n                                         GParamSpec* pspec)\n{\n  InfGtkCertificateManager* manager;\n  InfGtkCertificateManagerPrivate* priv;\n\n  manager = INF_GTK_CERTIFICATE_MANAGER(object);\n  priv = INF_GTK_CERTIFICATE_MANAGER_PRIVATE(manager);\n\n  switch(prop_id)\n  {\n  case PROP_PARENT_WINDOW:\n    g_assert(priv->parent_window == NULL); /* construct/only */\n    priv->parent_window = GTK_WINDOW(g_value_dup_object(value));\n    break;\n  case PROP_XMPP_MANAGER:\n    g_assert(priv->xmpp_manager == NULL); /* construct/only */\n    priv->xmpp_manager = INF_XMPP_MANAGER(g_value_dup_object(value));\n\n    g_signal_connect(\n      G_OBJECT(priv->xmpp_manager),\n      \"connection-added\",\n      G_CALLBACK(inf_gtk_certificate_manager_connection_added_cb),\n      manager\n    );\n\n    break;\n  case PROP_KNOWN_HOSTS_FILE:\n    inf_gtk_certificate_manager_set_known_hosts(\n      manager,\n      g_value_get_string(value)\n    );\n\n    break;\n  default:\n    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n    break;\n  }\n}\n\nstatic void\ninf_gtk_certificate_manager_get_property(GObject* object,\n                                         guint prop_id,\n                                         GValue* value,\n                                         GParamSpec* pspec)\n{\n  InfGtkCertificateManager* manager;\n  InfGtkCertificateManagerPrivate* priv;\n\n  manager = INF_GTK_CERTIFICATE_MANAGER(object);\n  priv = INF_GTK_CERTIFICATE_MANAGER_PRIVATE(manager);\n\n  switch(prop_id)\n  {\n  case PROP_PARENT_WINDOW:\n    g_value_set_object(value, G_OBJECT(priv->parent_window));\n    break;\n  case PROP_XMPP_MANAGER:\n    g_value_set_object(value, G_OBJECT(priv->xmpp_manager));\n    break;\n  case PROP_KNOWN_HOSTS_FILE:\n    g_value_set_string(value, priv->known_hosts_file);\n    break;\n  default:\n    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n    break;\n  }\n}\n\n/*\n * GType registration\n */\n\nstatic void\ninf_gtk_certificate_manager_class_init(\n  InfGtkCertificateManagerClass* certificate_manager_class)\n{\n  GObjectClass* object_class;\n  object_class = G_OBJECT_CLASS(certificate_manager_class);\n\n  object_class->dispose = inf_gtk_certificate_manager_dispose;\n  object_class->finalize = inf_gtk_certificate_manager_finalize;\n  object_class->set_property = inf_gtk_certificate_manager_set_property;\n  object_class->get_property = inf_gtk_certificate_manager_get_property;\n\n  g_object_class_install_property(\n    object_class,\n    PROP_PARENT_WINDOW,\n    g_param_spec_object(\n      \"parent-window\",\n      \"Parent window\",\n      \"The parent window for certificate approval dialogs\",\n      GTK_TYPE_WINDOW,\n      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY\n    )\n  );\n\n  g_object_class_install_property(\n    object_class,\n    PROP_XMPP_MANAGER,\n    g_param_spec_object(\n      \"xmpp-manager\",\n      \"XMPP manager\",\n      \"The XMPP manager of registered connections\",\n      INF_TYPE_XMPP_MANAGER,\n      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY\n    )\n  );\n\n  g_object_class_install_property(\n    object_class,\n    PROP_KNOWN_HOSTS_FILE,\n    g_param_spec_string(\n      \"known-hosts-file\",\n      \"Known hosts file\",\n      \"File containing certificates of known hosts\",\n      NULL,\n      G_PARAM_READWRITE\n    )\n  );\n}\n\n/*\n * Public API.\n */\n\n/**\n * inf_gtk_certificate_manager_new: (constructor)\n * @parent_window: The #GtkWindow to which to make certificate approval\n * dialogs transient to.\n * @xmpp_manager: The #InfXmppManager whose #InfXmppConnection<!-- -->s to\n * manage the certificates for.\n * @known_hosts_file: (type filename) (allow-none): Path pointing to a file\n * that contains certificates of known hosts, or %NULL.\n *\n * Creates a new #InfGtkCertificateManager. For each new client-side\n * #InfXmppConnection in @xmpp_manager, the certificate manager will verify\n * the server's certificate.\n *\n * If the certificate is contained in @known_hosts_file, then\n * the certificate is accepted automatically. Otherwise, the user is asked for\n * approval. If the user approves the certificate, then it is inserted into\n * the @known_hosts_file.\n *\n * Returns: (transfer full): A new #InfGtkCertificateManager.\n **/\nInfGtkCertificateManager*\ninf_gtk_certificate_manager_new(GtkWindow* parent_window,\n                                InfXmppManager* xmpp_manager,\n                                const gchar* known_hosts_file)\n{\n  GObject* object;\n\n  object = g_object_new(\n    INF_GTK_TYPE_CERTIFICATE_MANAGER,\n    \"parent-window\", parent_window,\n    \"xmpp-manager\", xmpp_manager,\n    \"known-hosts-file\", known_hosts_file,\n    NULL\n  );\n\n  return INF_GTK_CERTIFICATE_MANAGER(object);\n}\n\n/* vim:set et sw=2 ts=2: */\n"], "filenames": ["libinfgtk/inf-gtk-certificate-manager.c"], "buggy_code_start_loc": [712], "buggy_code_end_loc": [715], "fixing_code_start_loc": [712], "fixing_code_end_loc": [716], "type": "CWE-295", "message": "libinfinity before 0.6.6-1 does not validate expired SSL certificates, which allows remote attackers to have unspecified impact via unknown vectors.", "other": {"cve": {"id": "CVE-2015-3886", "sourceIdentifier": "cve@mitre.org", "published": "2017-07-21T14:29:00.600", "lastModified": "2017-07-25T18:15:12.477", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "libinfinity before 0.6.6-1 does not validate expired SSL certificates, which allows remote attackers to have unspecified impact via unknown vectors."}, {"lang": "es", "value": "libinfinity anterior a versi\u00f3n 0.6.6-1, no comprueba  los certificados SSL expirados, lo que permite a los atacantes remotos tener un impacto no especificado por medio de vectores desconocidos."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-295"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libinfinity_project:libinfinity:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.6.6", "matchCriteriaId": "D37A281B-CF01-4AA9-8EE5-AA582A8723AF"}]}]}], "references": [{"url": "http://seclists.org/oss-sec/2015/q2/410", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=783601", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1221266", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/gobby/gobby/issues/61", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/gobby/libinfinity/commit/c97f870f5ae13112988d9f8ad464b4f679903706", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gobby/libinfinity/commit/c97f870f5ae13112988d9f8ad464b4f679903706"}}