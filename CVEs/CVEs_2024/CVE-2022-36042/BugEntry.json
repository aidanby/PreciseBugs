{"buggy_code": ["// SPDX-FileCopyrightText: 2021 Florian M\u00e4rkl <info@florianmaerkl.de>\n// SPDX-FileCopyrightText: 2021 keegan\n// SPDX-FileCopyrightText: 2020-2021 Francesco Tamagni <mrmacete@protonmail.ch>\n// SPDX-FileCopyrightText: 2018 pancake <pancake@nopcode.org>\n// SPDX-License-Identifier: LGPL-3.0-only\n\n#include \"dyldcache.h\"\n\n#include <ht_pu.h>\n\n#define MAX_N_HDR 16\n\nstatic RzDyldLocSym *rz_dyld_locsym_new(RzDyldCache *cache);\n\n/**\n * \\param magic zero-terminated string from the beginning of some file\n */\nRZ_API bool rz_dyldcache_check_magic(const char *magic) {\n\treturn !strcmp(magic, \"dyld_v1   arm64\") || !strcmp(magic, \"dyld_v1  arm64e\") || !strcmp(magic, \"dyld_v1  x86_64\") || !strcmp(magic, \"dyld_v1 x86_64h\");\n}\n\nstatic ut64 va2pa(uint64_t addr, ut32 n_maps, cache_map_t *maps, RzBuffer *cache_buf, ut64 slide, ut32 *offset, ut32 *left) {\n\tut64 res = UT64_MAX;\n\tut32 i;\n\n\taddr -= slide;\n\n\tfor (i = 0; i < n_maps; i++) {\n\t\tif (addr >= maps[i].address && addr < maps[i].address + maps[i].size) {\n\t\t\tres = maps[i].fileOffset + addr - maps[i].address;\n\t\t\tif (offset) {\n\t\t\t\t*offset = addr - maps[i].address;\n\t\t\t}\n\t\t\tif (left) {\n\t\t\t\t*left = maps[i].size - (addr - maps[i].address);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn res;\n}\n\nstatic void free_bin(RzDyldBinImage *bin) {\n\tif (!bin) {\n\t\treturn;\n\t}\n\tfree(bin->file);\n\tfree(bin);\n}\n\nstatic cache_hdr_t *read_cache_header(RzBuffer *cache_buf, ut64 offset) {\n\tif (!cache_buf) {\n\t\treturn NULL;\n\t}\n\n\tcache_hdr_t *hdr = RZ_NEW0(cache_hdr_t);\n\tif (!hdr) {\n\t\treturn NULL;\n\t}\n\n\tut64 size = sizeof(cache_hdr_t);\n\tif (rz_buf_fread_at(cache_buf, offset, (ut8 *)hdr, \"16c4i7l16clii4l\", 1) != size) {\n\t\tfree(hdr);\n\t\treturn NULL;\n\t}\n\tif (!rz_dyldcache_check_magic(hdr->magic)) {\n\t\tfree(hdr);\n\t\treturn NULL;\n\t}\n\n\tif (!hdr->imagesCount && !hdr->imagesOffset) {\n\t\tif (!rz_buf_read_le32_at(cache_buf, 0x1c0 + offset, &hdr->imagesOffset) || !rz_buf_read_le32_at(cache_buf, 0x1c4 + offset, &hdr->imagesCount)) {\n\t\t\tfree(hdr);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn hdr;\n}\n\nstatic void populate_cache_headers(RzDyldCache *cache) {\n\tcache->n_hdr = 0;\n\tRzList *hdrs = rz_list_newf(NULL);\n\tif (!hdrs) {\n\t\treturn;\n\t}\n\n\tcache_hdr_t *h;\n\tut64 offsets[MAX_N_HDR];\n\tut64 offset = 0;\n\tdo {\n\t\toffsets[cache->n_hdr] = offset;\n\t\th = read_cache_header(cache->buf, offset);\n\t\tif (!h) {\n\t\t\tbreak;\n\t\t}\n\t\trz_list_append(hdrs, h);\n\n\t\tut64 size = h->codeSignatureOffset + h->codeSignatureSize;\n\n#define SHIFT_MAYBE(x) \\\n\tif (x) { \\\n\t\tx += offset; \\\n\t}\n\n\t\tSHIFT_MAYBE(h->mappingOffset);\n\t\tSHIFT_MAYBE(h->imagesOffset);\n\t\tSHIFT_MAYBE(h->codeSignatureOffset);\n\t\tSHIFT_MAYBE(h->slideInfoOffset);\n\t\tSHIFT_MAYBE(h->localSymbolsOffset);\n\t\tSHIFT_MAYBE(h->branchPoolsOffset);\n\t\tSHIFT_MAYBE(h->imagesTextOffset);\n\n\t\toffset += size;\n\t\tcache->n_hdr++;\n\t} while (cache->n_hdr < MAX_N_HDR);\n\n\tif (!cache->n_hdr) {\n\t\tgoto beach;\n\t}\n\n\tcache->hdr = RZ_NEWS0(cache_hdr_t, cache->n_hdr);\n\tif (!cache->hdr) {\n\t\tcache->n_hdr = 0;\n\t\tgoto beach;\n\t}\n\n\tcache->hdr_offset = RZ_NEWS0(ut64, cache->n_hdr);\n\tif (!cache->hdr_offset) {\n\t\tcache->n_hdr = 0;\n\t\tRZ_FREE(cache->hdr);\n\t\tgoto beach;\n\t}\n\n\tmemcpy(cache->hdr_offset, offsets, cache->n_hdr * sizeof(ut64));\n\n\tut32 i = 0;\n\tRzListIter *iter;\n\tcache_hdr_t *item;\n\trz_list_foreach (hdrs, iter, item) {\n\t\tif (i >= cache->n_hdr) {\n\t\t\tbreak;\n\t\t}\n\t\tmemcpy(&cache->hdr[i++], item, sizeof(cache_hdr_t));\n\t}\n\nbeach:\n\trz_list_free(hdrs);\n}\n\nstatic void populate_cache_maps(RzDyldCache *cache) {\n\trz_return_if_fail(cache && cache->buf);\n\n\tut32 i;\n\tut32 n_maps = 0;\n\tut64 max_count = 0;\n\tfor (i = 0; i < cache->n_hdr; i++) {\n\t\tcache_hdr_t *hdr = &cache->hdr[i];\n\t\tif (!hdr->mappingCount || !hdr->mappingOffset) {\n\t\t\tcontinue;\n\t\t}\n\t\tmax_count = RZ_MAX(hdr->mappingCount, max_count);\n\t\tn_maps += hdr->mappingCount;\n\t}\n\n\tif (n_maps < 1 || n_maps < max_count /* overflow */) {\n\t\tcache->maps = NULL;\n\t\tcache->n_maps = 0;\n\t\treturn;\n\t}\n\n\tcache->maps_index = RZ_NEWS0(ut32, cache->n_hdr);\n\tif (!cache->maps_index) {\n\t\treturn;\n\t}\n\tcache_map_t *maps = RZ_NEWS0(cache_map_t, n_maps);\n\n\tut32 next_map = 0;\n\tut32 last_idx = UT32_MAX;\n\tut64 max_address = 0;\n\tfor (i = 0; i < cache->n_hdr; i++) {\n\t\tcache_hdr_t *hdr = &cache->hdr[i];\n\t\tcache->maps_index[i] = next_map;\n\n\t\tif (!hdr->mappingCount || !hdr->mappingOffset) {\n\t\t\tcontinue;\n\t\t}\n\t\tut64 size = sizeof(cache_map_t) * hdr->mappingCount;\n\t\tif (rz_buf_fread_at(cache->buf, hdr->mappingOffset, (ut8 *)&maps[next_map], \"3l2i\", hdr->mappingCount) != size) {\n\t\t\tcontinue;\n\t\t}\n\t\tut32 j;\n\t\tut64 hdr_offset = cache->hdr_offset[i];\n\t\tfor (j = 0; j < hdr->mappingCount; j++) {\n\t\t\tcache_map_t *map = &maps[next_map + j];\n\t\t\tmap->fileOffset += hdr_offset;\n\t\t\tif (map->address > max_address) {\n\t\t\t\tlast_idx = i;\n\t\t\t\tmax_address = map->address;\n\t\t\t}\n\t\t}\n\t\tnext_map += hdr->mappingCount;\n\t}\n\n\tcache->maps = maps;\n\tcache->n_maps = next_map;\n\tif (last_idx == UT32_MAX) {\n\t\tcache->symbols_off_base = 0;\n\t} else {\n\t\tcache->symbols_off_base = cache->hdr_offset[last_idx];\n\t}\n}\n\nstatic cache_accel_t *read_cache_accel(RzBuffer *cache_buf, cache_hdr_t *hdr, cache_map_t *maps) {\n\tif (!cache_buf || !hdr || !hdr->accelerateInfoSize || !hdr->accelerateInfoAddr) {\n\t\treturn NULL;\n\t}\n\n\tut64 offset = va2pa(hdr->accelerateInfoAddr, hdr->mappingCount, maps, cache_buf, 0, NULL, NULL);\n\tif (!offset) {\n\t\treturn NULL;\n\t}\n\n\tut64 size = sizeof(cache_accel_t);\n\tcache_accel_t *accel = RZ_NEW0(cache_accel_t);\n\tif (!accel) {\n\t\treturn NULL;\n\t}\n\n\tif (rz_buf_fread_at(cache_buf, offset, (ut8 *)accel, \"16il\", 1) != size) {\n\t\tRZ_FREE(accel);\n\t\treturn NULL;\n\t}\n\n\taccel->imagesExtrasOffset += offset;\n\taccel->bottomUpListOffset += offset;\n\taccel->dylibTrieOffset += offset;\n\taccel->initializersOffset += offset;\n\taccel->dofSectionsOffset += offset;\n\taccel->reExportListOffset += offset;\n\taccel->depListOffset += offset;\n\taccel->rangeTableOffset += offset;\n\n\treturn accel;\n}\n\nRZ_API objc_cache_opt_info *rz_dyldcache_get_objc_opt_info(RzBinFile *bf, RzDyldCache *cache) {\n\tobjc_cache_opt_info *result = NULL;\n\tRzListIter *iter;\n\tRzDyldBinImage *bin;\n\trz_list_foreach (cache->bins, iter, bin) {\n\t\tif (strcmp(bin->file, \"lib/libobjc.A.dylib\")) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tstruct MACH0_(opts_t) opts = { 0 };\n\t\topts.verbose = bf->rbin->verbose;\n\t\topts.header_at = bin->header_at;\n\n\t\tstruct MACH0_(obj_t) *mach0 = MACH0_(new_buf)(cache->buf, &opts);\n\t\tif (!mach0) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tstruct section_t *sections = NULL;\n\t\tif (!(sections = MACH0_(get_sections)(mach0))) {\n\t\t\tMACH0_(mach0_free)\n\t\t\t(mach0);\n\t\t\tgoto beach;\n\t\t}\n\n\t\tint i;\n\t\tut64 scoffs_offset = 0;\n\t\tut64 scoffs_size = 0;\n\t\tut64 slide = rz_dyldcache_get_slide(cache);\n\t\tfor (i = 0; !sections[i].last; i++) {\n\t\t\tif (sections[i].size == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (strstr(sections[i].name, \"__objc_scoffs\")) {\n\t\t\t\tscoffs_offset = va2pa(sections[i].addr, cache->n_maps, cache->maps, cache->buf, slide, NULL, NULL);\n\t\t\t\tscoffs_size = sections[i].size;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tMACH0_(mach0_free)\n\t\t(mach0);\n\t\tRZ_FREE(sections);\n\n\t\tif (!scoffs_offset || scoffs_size < 40) {\n\t\t\tbreak;\n\t\t}\n\t\tut64 check;\n\t\tif (!rz_buf_read_le64_at(cache->buf, scoffs_offset, &check) || check != 2) {\n\t\t\tbreak;\n\t\t}\n\t\tut64 sel_string_base;\n\t\tif (!rz_buf_read_le64_at(cache->buf, scoffs_offset + 8, &sel_string_base)) {\n\t\t\tbreak;\n\t\t}\n\t\tut64 sel_string_end;\n\t\tif (!rz_buf_read_le64_at(cache->buf, scoffs_offset + 16, &sel_string_end) || sel_string_end == sel_string_base) {\n\t\t\tbreak;\n\t\t}\n\t\tresult = RZ_NEW0(objc_cache_opt_info);\n\t\tif (!result) {\n\t\t\tbreak;\n\t\t}\n\t\tresult->sel_string_base = sel_string_base;\n\t}\nbeach:\n\treturn result;\n}\n\nstatic cache_img_t *read_cache_images(RzBuffer *cache_buf, cache_hdr_t *hdr, ut64 hdr_offset) {\n\tif (!cache_buf || !hdr) {\n\t\treturn NULL;\n\t}\n\tif (!hdr->imagesCount || !hdr->imagesOffset || hdr->imagesOffset == UT32_MAX || hdr->imagesCount == UT32_MAX) {\n\t\treturn NULL;\n\t}\n\n\tut64 size = sizeof(cache_img_t) * hdr->imagesCount;\n\tcache_img_t *images = RZ_NEWS0(cache_img_t, hdr->imagesCount);\n\tif (!images) {\n\t\treturn NULL;\n\t}\n\n\tif (rz_buf_fread_at(cache_buf, hdr->imagesOffset, (ut8 *)images, \"3l2i\", hdr->imagesCount) != size) {\n\t\tRZ_FREE(images);\n\t\treturn NULL;\n\t}\n\n\tif (hdr_offset) {\n\t\tut32 i;\n\t\tfor (i = 0; i < hdr->imagesCount; i++) {\n\t\t\tcache_img_t *img = &images[i];\n\t\t\timg->pathFileOffset += hdr_offset;\n\t\t}\n\t}\n\n\treturn images;\n}\n\nstatic void match_bin_entries(RzDyldCache *cache, void *entries) {\n\trz_return_if_fail(cache && cache->bins && entries);\n\n\tcache_img_t *imgs = read_cache_images(cache->buf, cache->hdr, 0);\n\tif (!imgs) {\n\t\treturn;\n\t}\n\n\tRzDyldBinImage *bin = NULL;\n\tRzListIter *it = rz_list_iterator(cache->bins);\n\n\tbool has_large_entries = cache->n_hdr > 1;\n\n\tut32 i;\n\tfor (i = 0; i < cache->hdr->imagesCount; i++) {\n\t\tcache_img_t *img = &imgs[i];\n\t\tif (!it) {\n\t\t\tbreak;\n\t\t}\n\t\tbin = it->data;\n\t\tif (!bin) {\n\t\t\tbreak;\n\t\t}\n\t\tif (bin && bin->va == img->address) {\n\t\t\tif (has_large_entries) {\n\t\t\t\tcache_locsym_entry_large_t *e = &((cache_locsym_entry_large_t *)entries)[i];\n\t\t\t\tbin->nlist_start_index = e->nlistStartIndex;\n\t\t\t\tbin->nlist_count = e->nlistCount;\n\t\t\t} else {\n\t\t\t\tcache_locsym_entry_t *e = &((cache_locsym_entry_t *)entries)[i];\n\t\t\t\tbin->nlist_start_index = e->nlistStartIndex;\n\t\t\t\tbin->nlist_count = e->nlistCount;\n\t\t\t}\n\t\t\tit = it->n;\n\t\t}\n\t}\n\n\tRZ_FREE(imgs);\n}\n\nstatic cache_imgxtr_t *read_cache_imgextra(RzBuffer *cache_buf, cache_hdr_t *hdr, cache_accel_t *accel) {\n\tif (!cache_buf || !hdr || !hdr->imagesCount || !accel || !accel->imageExtrasCount || !accel->imagesExtrasOffset) {\n\t\treturn NULL;\n\t}\n\n\tut64 size = sizeof(cache_imgxtr_t) * accel->imageExtrasCount;\n\tcache_imgxtr_t *images = RZ_NEWS0(cache_imgxtr_t, accel->imageExtrasCount);\n\tif (!images) {\n\t\treturn NULL;\n\t}\n\n\tif (rz_buf_fread_at(cache_buf, accel->imagesExtrasOffset, (ut8 *)images, \"ll4i\", accel->imageExtrasCount) != size) {\n\t\tRZ_FREE(images);\n\t\treturn NULL;\n\t}\n\n\treturn images;\n}\n\nstatic char *get_lib_name(RzBuffer *cache_buf, cache_img_t *img) {\n\tchar file[256];\n\tchar *lib_name = file;\n\tif (rz_buf_read_at(cache_buf, img->pathFileOffset, (ut8 *)&file, sizeof(file)) == sizeof(file)) {\n\t\tfile[255] = 0;\n\t\treturn strdup(lib_name);\n\t}\n\treturn strdup(\"FAIL\");\n}\n\nstatic int string_contains(const void *a, const void *b) {\n\treturn !strstr((const char *)a, (const char *)b);\n}\n\nstatic HtPU *create_path_to_index(RzBuffer *cache_buf, cache_img_t *img, cache_hdr_t *hdr) {\n\tHtPU *path_to_idx = ht_pu_new0();\n\tif (!path_to_idx) {\n\t\treturn NULL;\n\t}\n\tfor (size_t i = 0; i != hdr->imagesCount; i++) {\n\t\tchar file[256];\n\t\tif (rz_buf_read_at(cache_buf, img[i].pathFileOffset, (ut8 *)&file, sizeof(file)) != sizeof(file)) {\n\t\t\tcontinue;\n\t\t}\n\t\tfile[255] = 0;\n\t\tht_pu_insert(path_to_idx, file, (ut64)i);\n\t}\n\n\treturn path_to_idx;\n}\n\nstatic void carve_deps_at_address(RzDyldCache *cache, cache_img_t *img, HtPU *path_to_idx, ut64 address, int *deps, bool printing) {\n\tut64 pa = va2pa(address, cache->n_maps, cache->maps, cache->buf, 0, NULL, NULL);\n\tif (pa == UT64_MAX) {\n\t\treturn;\n\t}\n\tstruct MACH0_(mach_header) mh;\n\tif (rz_buf_fread_at(cache->buf, pa, (ut8 *)&mh, \"8i\", 1) != sizeof(struct MACH0_(mach_header))) {\n\t\treturn;\n\t}\n\tif (mh.magic != MH_MAGIC_64 || mh.sizeofcmds == 0) {\n\t\treturn;\n\t}\n\tut64 cmds_at = pa + sizeof(struct MACH0_(mach_header));\n\tut8 *cmds = malloc(mh.sizeofcmds + 1);\n\tif (!cmds || rz_buf_read_at(cache->buf, cmds_at, cmds, mh.sizeofcmds) != mh.sizeofcmds) {\n\t\tgoto beach;\n\t}\n\tcmds[mh.sizeofcmds] = 0;\n\tut8 *cursor = cmds;\n\tut8 *end = cmds + mh.sizeofcmds;\n\twhile (cursor < end) {\n\t\tut32 cmd = rz_read_le32(cursor);\n\t\tut32 cmdsize = rz_read_le32(cursor + sizeof(ut32));\n\t\tif (cmd == LC_LOAD_DYLIB ||\n\t\t\tcmd == LC_LOAD_WEAK_DYLIB ||\n\t\t\tcmd == LC_REEXPORT_DYLIB ||\n\t\t\tcmd == LC_LOAD_UPWARD_DYLIB) {\n\t\t\tbool found;\n\t\t\tif (cursor + 24 >= end) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tconst char *key = (const char *)cursor + 24;\n\t\t\tsize_t dep_index = (size_t)ht_pu_find(path_to_idx, key, &found);\n\t\t\tif (!found || dep_index >= cache->hdr->imagesCount) {\n\t\t\t\tRZ_LOG_WARN(\"alien dep '%s'\\n\", key);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdeps[dep_index]++;\n\t\t\tif (printing) {\n\t\t\t\tRZ_LOG_INFO(\"-> %s\\n\", key);\n\t\t\t}\n\t\t}\n\t\tcursor += cmdsize;\n\t}\n\nbeach:\n\tfree(cmds);\n}\n\nstatic RzList *create_cache_bins(RzDyldCache *cache) {\n\tRzList *bins = rz_list_newf((RzListFree)free_bin);\n\tif (!bins) {\n\t\treturn NULL;\n\t}\n\n\tchar *target_libs = NULL;\n\tRzList *target_lib_names = NULL;\n\tint *deps = NULL;\n\ttarget_libs = rz_sys_getenv(\"RZ_DYLDCACHE_FILTER\");\n\tif (target_libs) {\n\t\ttarget_lib_names = rz_str_split_list(target_libs, \":\", 0);\n\t\tif (!target_lib_names) {\n\t\t\trz_list_free(bins);\n\t\t\treturn NULL;\n\t\t}\n\t\tdeps = RZ_NEWS0(int, cache->hdr->imagesCount);\n\t\tif (!deps) {\n\t\t\trz_list_free(bins);\n\t\t\trz_list_free(target_lib_names);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tut32 i;\n\tfor (i = 0; i < cache->n_hdr; i++) {\n\t\tcache_hdr_t *hdr = &cache->hdr[i];\n\t\tut64 hdr_offset = cache->hdr_offset[i];\n\t\tut64 symbols_off = cache->symbols_off_base - hdr_offset;\n\t\tut32 maps_index = cache->maps_index[i];\n\t\tcache_img_t *img = read_cache_images(cache->buf, hdr, hdr_offset);\n\t\tif (!img) {\n\t\t\tgoto next;\n\t\t}\n\n\t\tut32 j;\n\t\tut16 *depArray = NULL;\n\t\tcache_imgxtr_t *extras = NULL;\n\t\tif (target_libs) {\n\t\t\tHtPU *path_to_idx = NULL;\n\t\t\tif (cache->accel) {\n\t\t\t\tdepArray = RZ_NEWS0(ut16, cache->accel->depListCount);\n\t\t\t\tif (!depArray) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\n\t\t\t\tif (rz_buf_fread_at(cache->buf, cache->accel->depListOffset, (ut8 *)depArray, \"s\", cache->accel->depListCount) != cache->accel->depListCount * 2) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\n\t\t\t\textras = read_cache_imgextra(cache->buf, hdr, cache->accel);\n\t\t\t\tif (!extras) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpath_to_idx = create_path_to_index(cache->buf, img, hdr);\n\t\t\t}\n\n\t\t\tfor (j = 0; j < hdr->imagesCount; j++) {\n\t\t\t\tbool printing = !deps[j];\n\t\t\t\tchar *lib_name = get_lib_name(cache->buf, &img[j]);\n\t\t\t\tif (!lib_name) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (strstr(lib_name, \"libobjc.A.dylib\")) {\n\t\t\t\t\tdeps[j]++;\n\t\t\t\t}\n\t\t\t\tif (!rz_list_find(target_lib_names, lib_name, string_contains)) {\n\t\t\t\t\tRZ_FREE(lib_name);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (printing) {\n\t\t\t\t\tRZ_LOG_INFO(\"FILTER: %s\\n\", lib_name);\n\t\t\t\t}\n\t\t\t\tRZ_FREE(lib_name);\n\t\t\t\tdeps[j]++;\n\n\t\t\t\tif (extras && depArray) {\n\t\t\t\t\tut32 k;\n\t\t\t\t\tfor (k = extras[j].dependentsStartArrayIndex; depArray[k] != 0xffff; k++) {\n\t\t\t\t\t\tut16 dep_index = depArray[k] & 0x7fff;\n\t\t\t\t\t\tdeps[dep_index]++;\n\n\t\t\t\t\t\tchar *dep_name = get_lib_name(cache->buf, &img[dep_index]);\n\t\t\t\t\t\tif (!dep_name) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (printing) {\n\t\t\t\t\t\t\tRZ_LOG_INFO(\"-> %s\\n\", dep_name);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree(dep_name);\n\t\t\t\t\t}\n\t\t\t\t} else if (path_to_idx) {\n\t\t\t\t\tcarve_deps_at_address(cache, img, path_to_idx, img[j].address, deps, printing);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tht_pu_free(path_to_idx);\n\t\t\tRZ_FREE(depArray);\n\t\t\tRZ_FREE(extras);\n\t\t}\n\n\t\tfor (j = 0; j < hdr->imagesCount; j++) {\n\t\t\tif (deps && !deps[j]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tut64 pa = va2pa(img[j].address, hdr->mappingCount, &cache->maps[maps_index], cache->buf, 0, NULL, NULL);\n\t\t\tif (pa == UT64_MAX) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tut8 magicbytes[4];\n\t\t\trz_buf_read_at(cache->buf, pa, magicbytes, 4);\n\t\t\tint magic = rz_read_le32(magicbytes);\n\t\t\tswitch (magic) {\n\t\t\tcase MH_MAGIC_64: {\n\t\t\t\tchar file[256];\n\t\t\t\tRzDyldBinImage *bin = RZ_NEW0(RzDyldBinImage);\n\t\t\t\tif (!bin) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t\tbin->header_at = pa;\n\t\t\t\tbin->hdr_offset = hdr_offset;\n\t\t\t\tbin->symbols_off = symbols_off;\n\t\t\t\tbin->va = img[j].address;\n\t\t\t\tif (rz_buf_read_at(cache->buf, img[j].pathFileOffset, (ut8 *)&file, sizeof(file)) == sizeof(file)) {\n\t\t\t\t\tfile[255] = 0;\n\t\t\t\t\tchar *last_slash = strrchr(file, '/');\n\t\t\t\t\tif (last_slash && *last_slash) {\n\t\t\t\t\t\tif (last_slash > file) {\n\t\t\t\t\t\t\tchar *scan = last_slash - 1;\n\t\t\t\t\t\t\twhile (scan > file && *scan != '/') {\n\t\t\t\t\t\t\t\tscan--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (*scan == '/') {\n\t\t\t\t\t\t\t\tbin->file = strdup(scan + 1);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tbin->file = strdup(last_slash + 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbin->file = strdup(last_slash + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbin->file = strdup(file);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trz_list_append(bins, bin);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tRZ_LOG_WARN(\"Unknown sub-bin\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\tnext:\n\t\tRZ_FREE(depArray);\n\t\tRZ_FREE(extras);\n\t\tRZ_FREE(img);\n\t}\n\tif (rz_list_empty(bins)) {\n\t\trz_list_free(bins);\n\t\tbins = NULL;\n\t}\n\tRZ_FREE(deps);\n\tRZ_FREE(target_libs);\n\trz_list_free(target_lib_names);\n\treturn bins;\n}\n\nstatic ut32 dumb_ctzll(ut64 x) {\n\tut64 result = 0;\n\tint i, j;\n\tfor (i = 0; i < 64; i += 8) {\n\t\tut8 byte = (x >> i) & 0xff;\n\t\tif (!byte) {\n\t\t\tresult += 8;\n\t\t} else {\n\t\t\tfor (j = 0; j < 8; j++) {\n\t\t\t\tif (!((byte >> j) & 1)) {\n\t\t\t\t\tresult++;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn result;\n}\n\nstatic ut64 estimate_slide(RzDyldCache *cache, ut64 value_mask, ut64 value_add) {\n\tut64 slide = 0;\n\tif (cache->n_hdr > 1) {\n\t\treturn slide;\n\t}\n\tut64 *classlist = malloc(64);\n\tif (!classlist) {\n\t\tgoto beach;\n\t}\n\n\tRzListIter *iter;\n\tRzDyldBinImage *bin;\n\trz_list_foreach (cache->bins, iter, bin) {\n\t\tbool found_sample = false;\n\n\t\tstruct MACH0_(opts_t) opts = { 0 };\n\t\topts.header_at = bin->header_at;\n\n\t\tstruct MACH0_(obj_t) *mach0 = MACH0_(new_buf)(cache->buf, &opts);\n\t\tif (!mach0) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tstruct section_t *sections = NULL;\n\t\tif (!(sections = MACH0_(get_sections)(mach0))) {\n\t\t\tMACH0_(mach0_free)\n\t\t\t(mach0);\n\t\t\tgoto beach;\n\t\t}\n\n\t\tint i;\n\t\tint incomplete = 2;\n\t\tint classlist_idx = 0, data_idx = 0;\n\t\tfor (i = 0; !sections[i].last && incomplete; i++) {\n\t\t\tif (sections[i].size == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (strstr(sections[i].name, \"__objc_classlist\")) {\n\t\t\t\tincomplete--;\n\t\t\t\tclasslist_idx = i;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (strstr(sections[i].name, \"__objc_data\")) {\n\t\t\t\tincomplete--;\n\t\t\t\tdata_idx = i;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (incomplete) {\n\t\t\tgoto next_bin;\n\t\t}\n\n\t\tint classlist_sample_size = RZ_MIN(64, sections[classlist_idx].size);\n\t\tint n_classes = classlist_sample_size / 8;\n\t\tut64 sect_offset = sections[classlist_idx].offset + bin->hdr_offset;\n\n\t\tif (rz_buf_fread_at(cache->buf, sect_offset, (ut8 *)classlist, \"l\", n_classes) < classlist_sample_size) {\n\t\t\tgoto next_bin;\n\t\t}\n\n\t\tut64 data_addr = sections[data_idx].addr;\n\t\tut64 data_tail = data_addr & 0xfff;\n\t\tut64 data_tail_end = (data_addr + sections[data_idx].size) & 0xfff;\n\t\tfor (i = 0; i < n_classes; i++) {\n\t\t\tut64 cl_addr = (classlist[i] & value_mask) + value_add;\n\t\t\tut64 cl_tail = cl_addr & 0xfff;\n\t\t\tif (cl_tail >= data_tail && cl_tail < data_tail_end) {\n\t\t\t\tut64 off = cl_tail - data_tail;\n\t\t\t\tslide = ((cl_addr - off) & value_mask) - (data_addr & value_mask);\n\t\t\t\tfound_sample = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\tnext_bin:\n\t\tMACH0_(mach0_free)\n\t\t(mach0);\n\t\tfree(sections);\n\n\t\tif (found_sample) {\n\t\t\tbreak;\n\t\t}\n\t}\n\nbeach:\n\tfree(classlist);\n\treturn slide;\n}\n\nstatic RzDyldRebaseInfo *get_rebase_info(RzDyldCache *cache, ut64 slideInfoOffset, ut64 slideInfoSize, ut64 start_of_data, ut64 slide) {\n\tut8 *tmp_buf_1 = NULL;\n\tut8 *tmp_buf_2 = NULL;\n\tut8 *one_page_buf = NULL;\n\tRzBuffer *cache_buf = cache->buf;\n\n\tut64 offset = slideInfoOffset;\n\tut32 slide_info_version = 0;\n\tif (rz_buf_read_at(cache_buf, offset, (ut8 *)&slide_info_version, 4) != 4) {\n\t\treturn NULL;\n\t}\n\n\tif (slide_info_version == 3) {\n\t\tcache_slide3_t slide_info;\n\t\tut64 size = sizeof(cache_slide3_t);\n\t\tif (rz_buf_fread_at(cache_buf, offset, (ut8 *)&slide_info, \"4i1l\", 1) < 20) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tut64 page_starts_offset = offset + size;\n\t\tut64 page_starts_size = slide_info.page_starts_count * 2;\n\n\t\tif (page_starts_size + size > slideInfoSize) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (page_starts_size > 0) {\n\t\t\ttmp_buf_1 = malloc(page_starts_size);\n\t\t\tif (!tmp_buf_1) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (rz_buf_fread_at(cache_buf, page_starts_offset, tmp_buf_1, \"s\", slide_info.page_starts_count) != page_starts_size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\n\t\tif (slide_info.page_size > 0) {\n\t\t\tone_page_buf = malloc(slide_info.page_size);\n\t\t\tif (!one_page_buf) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\n\t\tRzDyldRebaseInfo3 *rebase_info = RZ_NEW0(RzDyldRebaseInfo3);\n\t\tif (!rebase_info) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\trebase_info->version = 3;\n\t\trebase_info->delta_mask = 0x3ff8000000000000ULL;\n\t\trebase_info->delta_shift = 51;\n\t\trebase_info->start_of_data = start_of_data;\n\t\trebase_info->page_starts = (ut16 *)tmp_buf_1;\n\t\trebase_info->page_starts_count = slide_info.page_starts_count;\n\t\trebase_info->auth_value_add = slide_info.auth_value_add;\n\t\trebase_info->page_size = slide_info.page_size;\n\t\trebase_info->one_page_buf = one_page_buf;\n\t\tif (slide == UT64_MAX) {\n\t\t\trebase_info->slide = estimate_slide(cache, 0x7ffffffffffffULL, 0);\n\t\t\tif (rebase_info->slide) {\n\t\t\t\tRZ_LOG_INFO(\"dyldcache is slid: 0x%\" PFMT64x \"\\n\", rebase_info->slide);\n\t\t\t}\n\t\t} else {\n\t\t\trebase_info->slide = slide;\n\t\t}\n\n\t\treturn (RzDyldRebaseInfo *)rebase_info;\n\t} else if (slide_info_version == 2 || slide_info_version == 4) {\n\t\tcache_slide2_t slide_info;\n\t\tut64 size = sizeof(cache_slide2_t);\n\t\tif (rz_buf_fread_at(cache_buf, offset, (ut8 *)&slide_info, \"6i2l\", 1) != size) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (slide_info.page_starts_offset == 0 ||\n\t\t\tslide_info.page_starts_offset > slideInfoSize ||\n\t\t\tslide_info.page_starts_offset + slide_info.page_starts_count * 2 > slideInfoSize) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (slide_info.page_extras_offset == 0 ||\n\t\t\tslide_info.page_extras_offset > slideInfoSize ||\n\t\t\tslide_info.page_extras_offset + slide_info.page_extras_count * 2 > slideInfoSize) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (slide_info.page_starts_count > 0) {\n\t\t\tut64 size = slide_info.page_starts_count * 2;\n\t\t\tut64 at = slideInfoOffset + slide_info.page_starts_offset;\n\t\t\ttmp_buf_1 = malloc(size);\n\t\t\tif (!tmp_buf_1) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (rz_buf_fread_at(cache_buf, at, tmp_buf_1, \"s\", slide_info.page_starts_count) != size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\n\t\tif (slide_info.page_extras_count > 0) {\n\t\t\tut64 size = slide_info.page_extras_count * 2;\n\t\t\tut64 at = slideInfoOffset + slide_info.page_extras_offset;\n\t\t\ttmp_buf_2 = malloc(size);\n\t\t\tif (!tmp_buf_2) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (rz_buf_fread_at(cache_buf, at, tmp_buf_2, \"s\", slide_info.page_extras_count) != size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\n\t\tif (slide_info.page_size > 0) {\n\t\t\tone_page_buf = malloc(slide_info.page_size);\n\t\t\tif (!one_page_buf) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\n\t\tRzDyldRebaseInfo2 *rebase_info = RZ_NEW0(RzDyldRebaseInfo2);\n\t\tif (!rebase_info) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\trebase_info->version = slide_info_version;\n\t\trebase_info->start_of_data = start_of_data;\n\t\trebase_info->page_starts = (ut16 *)tmp_buf_1;\n\t\trebase_info->page_starts_count = slide_info.page_starts_count;\n\t\trebase_info->page_extras = (ut16 *)tmp_buf_2;\n\t\trebase_info->page_extras_count = slide_info.page_extras_count;\n\t\trebase_info->value_add = slide_info.value_add;\n\t\trebase_info->delta_mask = slide_info.delta_mask;\n\t\trebase_info->value_mask = ~rebase_info->delta_mask;\n\t\trebase_info->delta_shift = dumb_ctzll(rebase_info->delta_mask) - 2;\n\t\trebase_info->page_size = slide_info.page_size;\n\t\trebase_info->one_page_buf = one_page_buf;\n\t\tif (slide == UT64_MAX) {\n\t\t\trebase_info->slide = estimate_slide(cache, rebase_info->value_mask, rebase_info->value_add);\n\t\t\tif (rebase_info->slide) {\n\t\t\t\tRZ_LOG_INFO(\"dyldcache is slid: 0x%\" PFMT64x \"\\n\", rebase_info->slide);\n\t\t\t}\n\t\t} else {\n\t\t\trebase_info->slide = slide;\n\t\t}\n\n\t\treturn (RzDyldRebaseInfo *)rebase_info;\n\t} else if (slide_info_version == 1) {\n\t\tcache_slide1_t slide_info;\n\t\tut64 size = sizeof(cache_slide1_t);\n\t\tif (rz_buf_fread_at(cache_buf, offset, (ut8 *)&slide_info, \"6i\", 1) != size) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (slide_info.toc_offset == 0 ||\n\t\t\tslide_info.toc_offset > slideInfoSize ||\n\t\t\tslide_info.toc_offset + slide_info.toc_count * 2 > slideInfoSize) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (slide_info.entries_offset == 0 ||\n\t\t\tslide_info.entries_offset > slideInfoSize ||\n\t\t\tslide_info.entries_offset + slide_info.entries_count * slide_info.entries_size > slideInfoSize) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (slide_info.toc_count > 0) {\n\t\t\tut64 size = slide_info.toc_count * 2;\n\t\t\tut64 at = slideInfoOffset + slide_info.toc_offset;\n\t\t\ttmp_buf_1 = malloc(size);\n\t\t\tif (!tmp_buf_1) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (rz_buf_fread_at(cache_buf, at, tmp_buf_1, \"s\", slide_info.toc_count) != size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\n\t\tif (slide_info.entries_count > 0) {\n\t\t\tut64 size = (ut64)slide_info.entries_count * (ut64)slide_info.entries_size;\n\t\t\tut64 at = slideInfoOffset + slide_info.entries_offset;\n\t\t\ttmp_buf_2 = malloc(size);\n\t\t\tif (!tmp_buf_2) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (rz_buf_read_at(cache_buf, at, tmp_buf_2, size) != size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\n\t\tone_page_buf = malloc(4096);\n\t\tif (!one_page_buf) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tRzDyldRebaseInfo1 *rebase_info = RZ_NEW0(RzDyldRebaseInfo1);\n\t\tif (!rebase_info) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\trebase_info->version = 1;\n\t\trebase_info->start_of_data = start_of_data;\n\t\trebase_info->one_page_buf = one_page_buf;\n\t\trebase_info->page_size = 4096;\n\t\trebase_info->toc = (ut16 *)tmp_buf_1;\n\t\trebase_info->toc_count = slide_info.toc_count;\n\t\trebase_info->entries = tmp_buf_2;\n\t\trebase_info->entries_size = slide_info.entries_size;\n\t\tif (slide == UT64_MAX) {\n\t\t\trebase_info->slide = estimate_slide(cache, UT64_MAX, 0);\n\t\t\tif (rebase_info->slide) {\n\t\t\t\tRZ_LOG_INFO(\"dyldcache is slid: 0x%\" PFMT64x \"\\n\", rebase_info->slide);\n\t\t\t}\n\t\t} else {\n\t\t\trebase_info->slide = slide;\n\t\t}\n\n\t\treturn (RzDyldRebaseInfo *)rebase_info;\n\t} else {\n\t\tRZ_LOG_ERROR(\"Unsupported slide info version %d\\n\", slide_info_version);\n\t\treturn NULL;\n\t}\n\nbeach:\n\tfree(tmp_buf_1);\n\tfree(tmp_buf_2);\n\tfree(one_page_buf);\n\treturn NULL;\n}\n\nstatic RzDyldRebaseInfos *get_rebase_infos(RzDyldCache *cache) {\n\tRzDyldRebaseInfos *result = RZ_NEW0(RzDyldRebaseInfos);\n\tif (!result) {\n\t\treturn NULL;\n\t}\n\n\tif (!cache->hdr->slideInfoOffset || !cache->hdr->slideInfoSize) {\n\t\tut32 total_slide_infos = 0;\n\t\tut32 n_slide_infos[MAX_N_HDR];\n\n\t\tut32 i;\n\t\tfor (i = 0; i < cache->n_hdr && i < MAX_N_HDR; i++) {\n\t\t\tut64 hdr_offset = cache->hdr_offset[i];\n\t\t\tif (!rz_buf_read_le32_at(cache->buf, 0x13c + hdr_offset, &n_slide_infos[i])) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\ttotal_slide_infos += n_slide_infos[i];\n\t\t}\n\n\t\tif (!total_slide_infos) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tRzDyldRebaseInfosEntry *infos = RZ_NEWS0(RzDyldRebaseInfosEntry, total_slide_infos);\n\t\tif (!infos) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tut32 k = 0;\n\t\tfor (i = 0; i < cache->n_hdr && i < MAX_N_HDR; i++) {\n\t\t\tut64 hdr_offset = cache->hdr_offset[i];\n\t\t\tif (!n_slide_infos[i]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tut32 sio;\n\t\t\tif (!rz_buf_read_le32_at(cache->buf, 0x138 + hdr_offset, &sio)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tut64 slide_infos_offset = sio;\n\t\t\tif (!slide_infos_offset) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tslide_infos_offset += hdr_offset;\n\n\t\t\tut32 j;\n\t\t\tRzDyldRebaseInfo *prev_info = NULL;\n\t\t\tfor (j = 0; j < n_slide_infos[i]; j++) {\n\t\t\t\tut64 offset = slide_infos_offset + j * sizeof(cache_mapping_slide);\n\t\t\t\tcache_mapping_slide entry;\n\t\t\t\tif (rz_buf_fread_at(cache->buf, offset, (ut8 *)&entry, \"6lii\", 1) != sizeof(cache_mapping_slide)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (entry.slideInfoOffset && entry.slideInfoSize) {\n\t\t\t\t\tinfos[k].start = entry.fileOffset + hdr_offset;\n\t\t\t\t\tinfos[k].end = infos[k].start + entry.size;\n\t\t\t\t\tut64 slide = prev_info ? prev_info->slide : UT64_MAX;\n\t\t\t\t\tinfos[k].info = get_rebase_info(cache, entry.slideInfoOffset + hdr_offset, entry.slideInfoSize, entry.fileOffset + hdr_offset, slide);\n\t\t\t\t\tprev_info = infos[k].info;\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!k) {\n\t\t\tfree(infos);\n\t\t\tgoto beach;\n\t\t}\n\n\t\tif (k < total_slide_infos) {\n\t\t\tRzDyldRebaseInfosEntry *pruned_infos = RZ_NEWS0(RzDyldRebaseInfosEntry, k);\n\t\t\tif (!pruned_infos) {\n\t\t\t\tfree(infos);\n\t\t\t\tgoto beach;\n\t\t\t}\n\n\t\t\tmemcpy(pruned_infos, infos, sizeof(RzDyldRebaseInfosEntry) * k);\n\t\t\tfree(infos);\n\t\t\tinfos = pruned_infos;\n\t\t}\n\n\t\tresult->entries = infos;\n\t\tresult->length = k;\n\t\treturn result;\n\t}\n\n\tif (cache->hdr->mappingCount > 1) {\n\t\tRzDyldRebaseInfosEntry *infos = RZ_NEWS0(RzDyldRebaseInfosEntry, 1);\n\t\tif (!infos) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tinfos[0].start = cache->maps[1].fileOffset;\n\t\tinfos[0].end = infos[0].start + cache->maps[1].size;\n\t\tinfos[0].info = get_rebase_info(cache, cache->hdr->slideInfoOffset, cache->hdr->slideInfoSize, infos[0].start, UT64_MAX);\n\n\t\tresult->entries = infos;\n\t\tresult->length = 1;\n\t\treturn result;\n\t}\n\nbeach:\n\tfree(result);\n\treturn NULL;\n}\n\nRZ_API ut64 rz_dyldcache_get_slide(RzDyldCache *cache) {\n\trz_return_val_if_fail(cache, 0);\n\tif (!cache->rebase_infos || !cache->rebase_infos->length) {\n\t\treturn 0;\n\t}\n\n\tsize_t i;\n\tfor (i = 0; i < cache->rebase_infos->length; i++) {\n\t\tif (cache->rebase_infos->entries[i].info) {\n\t\t\treturn cache->rebase_infos->entries[i].info->slide;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nRZ_API void rz_dyldcache_symbols_from_locsym(RzDyldCache *cache, RzDyldBinImage *bin, RzList *symbols, SetU *hash) {\n\tRzDyldLocSym *locsym = cache->locsym;\n\tif (!locsym) {\n\t\treturn;\n\t}\n\n\tif (bin->nlist_start_index >= locsym->nlists_count ||\n\t\tbin->nlist_start_index + bin->nlist_count > locsym->nlists_count) {\n\t\tRZ_LOG_ERROR(\"dyldcache: malformed local symbol entry\\n\");\n\t\treturn;\n\t}\n\n\tut64 nlists_size = sizeof(struct MACH0_(nlist)) * bin->nlist_count;\n\tstruct MACH0_(nlist) *nlists = RZ_NEWS0(struct MACH0_(nlist), bin->nlist_count);\n\tif (!nlists) {\n\t\treturn;\n\t}\n\tut64 nlists_offset = locsym->local_symbols_offset + locsym->nlists_offset +\n\t\tbin->nlist_start_index * sizeof(struct MACH0_(nlist));\n\tif (rz_buf_fread_at(cache->buf, nlists_offset, (ut8 *)nlists, \"iccsl\", bin->nlist_count) != nlists_size) {\n\t\tfree(nlists);\n\t\treturn;\n\t}\n\n\tut32 j;\n\tfor (j = 0; j != bin->nlist_count; j++) {\n\t\tstruct MACH0_(nlist) *nlist = &nlists[j];\n\t\tif (set_u_contains(hash, (ut64)nlist->n_value)) {\n\t\t\tcontinue;\n\t\t}\n\t\tset_u_add(hash, (ut64)nlist->n_value);\n\t\tif (nlist->n_strx >= locsym->strings_size) {\n\t\t\tcontinue;\n\t\t}\n\t\tRzBinSymbol *sym = RZ_NEW0(RzBinSymbol);\n\t\tif (!sym) {\n\t\t\tbreak;\n\t\t}\n\t\tsym->type = \"LOCAL\";\n\t\tsym->vaddr = nlist->n_value;\n\t\tut64 slide = rz_dyldcache_get_slide(cache);\n\t\tsym->paddr = va2pa(nlist->n_value, cache->n_maps, cache->maps, cache->buf, slide, NULL, NULL);\n\n\t\tchar *symstr = rz_buf_get_string(cache->buf, locsym->local_symbols_offset + locsym->strings_offset + nlist->n_strx);\n\t\tif (symstr) {\n\t\t\tsym->name = symstr;\n\t\t} else {\n\t\t\tstatic ut32 k = 0;\n\t\t\tsym->name = rz_str_newf(\"unk_local%d\", k++);\n\t\t}\n\n\t\trz_list_append(symbols, sym);\n\t}\n\n\tfree(nlists);\n}\n\nRZ_API RzDyldCache *rz_dyldcache_new_buf(RzBuffer *buf) {\n\tRzDyldCache *cache = RZ_NEW0(RzDyldCache);\n\tif (!cache) {\n\t\treturn NULL;\n\t}\n\tmemcpy(cache->magic, \"dyldcac\", 7);\n\tcache->buf = rz_buf_ref(buf);\n\tpopulate_cache_headers(cache);\n\tif (!cache->hdr) {\n\t\tgoto cupertino;\n\t}\n\tpopulate_cache_maps(cache);\n\tif (!cache->maps) {\n\t\tgoto cupertino;\n\t}\n\tcache->accel = read_cache_accel(cache->buf, cache->hdr, cache->maps);\n\tcache->bins = create_cache_bins(cache);\n\tif (!cache->bins) {\n\t\tgoto cupertino;\n\t}\n\tcache->locsym = rz_dyld_locsym_new(cache);\n\tcache->rebase_infos = get_rebase_infos(cache);\n\treturn cache;\ncupertino:\n\trz_dyldcache_free(cache);\n\treturn NULL;\n}\n\nstatic void rebase_info3_free(RzDyldRebaseInfo3 *rebase_info) {\n\tif (!rebase_info) {\n\t\treturn;\n\t}\n\tfree(rebase_info->page_starts);\n\tfree(rebase_info);\n}\n\nstatic void rebase_info2_free(RzDyldRebaseInfo2 *rebase_info) {\n\tif (!rebase_info) {\n\t\treturn;\n\t}\n\tfree(rebase_info->page_starts);\n\tfree(rebase_info->page_extras);\n\tfree(rebase_info);\n}\n\nstatic void rebase_info1_free(RzDyldRebaseInfo1 *rebase_info) {\n\tif (!rebase_info) {\n\t\treturn;\n\t}\n\tfree(rebase_info->toc);\n\tfree(rebase_info->entries);\n\tfree(rebase_info);\n}\n\nstatic void rebase_info_free(RzDyldRebaseInfo *rebase_info) {\n\tif (!rebase_info) {\n\t\treturn;\n\t}\n\n\tRZ_FREE(rebase_info->one_page_buf);\n\n\tut8 version = rebase_info->version;\n\n\tif (version == 1) {\n\t\trebase_info1_free((RzDyldRebaseInfo1 *)rebase_info);\n\t} else if (version == 2 || version == 4) {\n\t\trebase_info2_free((RzDyldRebaseInfo2 *)rebase_info);\n\t} else if (version == 3) {\n\t\trebase_info3_free((RzDyldRebaseInfo3 *)rebase_info);\n\t} else {\n\t\tfree(rebase_info);\n\t}\n}\n\nstatic RzDyldLocSym *rz_dyld_locsym_new(RzDyldCache *cache) {\n\trz_return_val_if_fail(cache && cache->buf, NULL);\n\n\tut32 i;\n\tfor (i = 0; i < cache->n_hdr; i++) {\n\t\tcache_hdr_t *hdr = &cache->hdr[i];\n\t\tif (!hdr || !hdr->localSymbolsSize || !hdr->localSymbolsOffset) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tcache_locsym_info_t *info = NULL;\n\t\tvoid *entries = NULL;\n\n\t\tut64 info_size = sizeof(cache_locsym_info_t);\n\t\tinfo = RZ_NEW0(cache_locsym_info_t);\n\t\tif (!info) {\n\t\t\tgoto beach;\n\t\t}\n\t\tif (rz_buf_fread_at(cache->buf, hdr->localSymbolsOffset, (ut8 *)info, \"6i\", 1) != info_size) {\n\t\t\tRZ_LOG_ERROR(\"Cannot read cache_locsym_info_t from header\\n\");\n\t\t\tgoto beach;\n\t\t}\n\t\tif (info->entriesCount != cache->hdr->imagesCount) {\n\t\t\tRZ_LOG_ERROR(\"The number of entries count differs from cache header image count\\n\");\n\t\t\tgoto beach;\n\t\t}\n\n\t\tbool has_large_entries = cache->n_hdr > 1;\n\t\tif (has_large_entries) {\n\t\t\tut64 entries_size = sizeof(cache_locsym_entry_large_t) * info->entriesCount;\n\t\t\tcache_locsym_entry_large_t *large_entries = RZ_NEWS0(cache_locsym_entry_large_t, info->entriesCount);\n\t\t\tif (!large_entries) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (rz_buf_fread_at(cache->buf, hdr->localSymbolsOffset + info->entriesOffset, (ut8 *)large_entries, \"lii\",\n\t\t\t\t    info->entriesCount) != entries_size) {\n\t\t\t\tRZ_LOG_ERROR(\"Cannot read cache_locsym_entry_large_t\\n\");\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tentries = large_entries;\n\t\t} else {\n\t\t\tut64 entries_size = sizeof(cache_locsym_entry_t) * info->entriesCount;\n\t\t\tcache_locsym_entry_t *regular_entries = RZ_NEWS0(cache_locsym_entry_t, info->entriesCount);\n\t\t\tif (!regular_entries) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (rz_buf_fread_at(cache->buf, hdr->localSymbolsOffset + info->entriesOffset, (ut8 *)regular_entries, \"iii\",\n\t\t\t\t    info->entriesCount) != entries_size) {\n\t\t\t\tRZ_LOG_ERROR(\"Cannot read cache_locsym_entry_t\\n\");\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tentries = regular_entries;\n\t\t}\n\t\tRzDyldLocSym *locsym = RZ_NEW0(RzDyldLocSym);\n\t\tif (!locsym) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tmatch_bin_entries(cache, entries);\n\n\t\tlocsym->local_symbols_offset = hdr->localSymbolsOffset;\n\t\tlocsym->nlists_offset = info->nlistOffset;\n\t\tlocsym->nlists_count = info->nlistCount;\n\t\tlocsym->strings_offset = info->stringsOffset;\n\t\tlocsym->strings_size = info->stringsSize;\n\n\t\tfree(info);\n\t\tfree(entries);\n\n\t\treturn locsym;\n\n\tbeach:\n\t\tfree(info);\n\t\tfree(entries);\n\n\t\tRZ_LOG_ERROR(\"dyldcache: malformed local symbols metadata\\n\");\n\t\tbreak;\n\t}\n\treturn NULL;\n}\n\nRZ_API void rz_dyldcache_free(RzDyldCache *cache) {\n\tif (!cache) {\n\t\treturn;\n\t}\n\n\trz_list_free(cache->bins);\n\tcache->bins = NULL;\n\trz_buf_free(cache->buf);\n\tcache->buf = NULL;\n\tif (cache->rebase_infos) {\n\t\tint i;\n\t\tfor (i = 0; i < cache->rebase_infos->length; i++) {\n\t\t\trebase_info_free(cache->rebase_infos->entries[i].info);\n\t\t\tcache->rebase_infos->entries[i].info = NULL;\n\t\t}\n\t\tRZ_FREE(cache->rebase_infos->entries);\n\t\tRZ_FREE(cache->rebase_infos);\n\t}\n\tfree(cache->hdr);\n\tfree(cache->maps);\n\tfree(cache->maps_index);\n\tfree(cache->hdr_offset);\n\tfree(cache->accel);\n\tfree(cache->locsym);\n\tfree(cache->oi);\n\tfree(cache);\n}\n\nRZ_API ut64 rz_dyldcache_va2pa(RzDyldCache *cache, uint64_t vaddr, ut32 *offset, ut32 *left) {\n\trz_return_val_if_fail(cache, UT64_MAX);\n\tut64 slide = rz_dyldcache_get_slide(cache);\n\tut64 res = va2pa(vaddr, cache->n_maps, cache->maps, cache->buf, slide, offset, left);\n\tif (res == UT64_MAX) {\n\t\tres = 0;\n\t}\n\treturn res;\n}\n"], "fixing_code": ["// SPDX-FileCopyrightText: 2021 Florian M\u00e4rkl <info@florianmaerkl.de>\n// SPDX-FileCopyrightText: 2021 keegan\n// SPDX-FileCopyrightText: 2020-2021 Francesco Tamagni <mrmacete@protonmail.ch>\n// SPDX-FileCopyrightText: 2018 pancake <pancake@nopcode.org>\n// SPDX-License-Identifier: LGPL-3.0-only\n\n#include \"dyldcache.h\"\n\n#include <ht_pu.h>\n\n#define MAX_N_HDR 16\n\nstatic RzDyldLocSym *rz_dyld_locsym_new(RzDyldCache *cache);\n\n/**\n * \\param magic zero-terminated string from the beginning of some file\n */\nRZ_API bool rz_dyldcache_check_magic(const char *magic) {\n\treturn !strcmp(magic, \"dyld_v1   arm64\") || !strcmp(magic, \"dyld_v1  arm64e\") || !strcmp(magic, \"dyld_v1  x86_64\") || !strcmp(magic, \"dyld_v1 x86_64h\");\n}\n\nstatic ut64 va2pa(uint64_t addr, ut32 n_maps, cache_map_t *maps, RzBuffer *cache_buf, ut64 slide, ut32 *offset, ut32 *left) {\n\tut64 res = UT64_MAX;\n\tut32 i;\n\n\taddr -= slide;\n\n\tfor (i = 0; i < n_maps; i++) {\n\t\tif (addr >= maps[i].address && addr < maps[i].address + maps[i].size) {\n\t\t\tres = maps[i].fileOffset + addr - maps[i].address;\n\t\t\tif (offset) {\n\t\t\t\t*offset = addr - maps[i].address;\n\t\t\t}\n\t\t\tif (left) {\n\t\t\t\t*left = maps[i].size - (addr - maps[i].address);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn res;\n}\n\nstatic void free_bin(RzDyldBinImage *bin) {\n\tif (!bin) {\n\t\treturn;\n\t}\n\tfree(bin->file);\n\tfree(bin);\n}\n\nstatic cache_hdr_t *read_cache_header(RzBuffer *cache_buf, ut64 offset) {\n\tif (!cache_buf) {\n\t\treturn NULL;\n\t}\n\n\tcache_hdr_t *hdr = RZ_NEW0(cache_hdr_t);\n\tif (!hdr) {\n\t\treturn NULL;\n\t}\n\n\tut64 size = sizeof(cache_hdr_t);\n\tif (rz_buf_fread_at(cache_buf, offset, (ut8 *)hdr, \"16c4i7l16clii4l\", 1) != size) {\n\t\tfree(hdr);\n\t\treturn NULL;\n\t}\n\tif (!rz_dyldcache_check_magic(hdr->magic)) {\n\t\tfree(hdr);\n\t\treturn NULL;\n\t}\n\n\tif (!hdr->imagesCount && !hdr->imagesOffset) {\n\t\tif (!rz_buf_read_le32_at(cache_buf, 0x1c0 + offset, &hdr->imagesOffset) || !rz_buf_read_le32_at(cache_buf, 0x1c4 + offset, &hdr->imagesCount)) {\n\t\t\tfree(hdr);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn hdr;\n}\n\nstatic void populate_cache_headers(RzDyldCache *cache) {\n\tcache->n_hdr = 0;\n\tRzList *hdrs = rz_list_newf(NULL);\n\tif (!hdrs) {\n\t\treturn;\n\t}\n\n\tcache_hdr_t *h;\n\tut64 offsets[MAX_N_HDR];\n\tut64 offset = 0;\n\tdo {\n\t\toffsets[cache->n_hdr] = offset;\n\t\th = read_cache_header(cache->buf, offset);\n\t\tif (!h) {\n\t\t\tbreak;\n\t\t}\n\t\trz_list_append(hdrs, h);\n\n\t\tut64 size = h->codeSignatureOffset + h->codeSignatureSize;\n\n#define SHIFT_MAYBE(x) \\\n\tif (x) { \\\n\t\tx += offset; \\\n\t}\n\n\t\tSHIFT_MAYBE(h->mappingOffset);\n\t\tSHIFT_MAYBE(h->imagesOffset);\n\t\tSHIFT_MAYBE(h->codeSignatureOffset);\n\t\tSHIFT_MAYBE(h->slideInfoOffset);\n\t\tSHIFT_MAYBE(h->localSymbolsOffset);\n\t\tSHIFT_MAYBE(h->branchPoolsOffset);\n\t\tSHIFT_MAYBE(h->imagesTextOffset);\n\n\t\toffset += size;\n\t\tcache->n_hdr++;\n\t} while (cache->n_hdr < MAX_N_HDR);\n\n\tif (!cache->n_hdr) {\n\t\tgoto beach;\n\t}\n\n\tcache->hdr = RZ_NEWS0(cache_hdr_t, cache->n_hdr);\n\tif (!cache->hdr) {\n\t\tcache->n_hdr = 0;\n\t\tgoto beach;\n\t}\n\n\tcache->hdr_offset = RZ_NEWS0(ut64, cache->n_hdr);\n\tif (!cache->hdr_offset) {\n\t\tcache->n_hdr = 0;\n\t\tRZ_FREE(cache->hdr);\n\t\tgoto beach;\n\t}\n\n\tmemcpy(cache->hdr_offset, offsets, cache->n_hdr * sizeof(ut64));\n\n\tut32 i = 0;\n\tRzListIter *iter;\n\tcache_hdr_t *item;\n\trz_list_foreach (hdrs, iter, item) {\n\t\tif (i >= cache->n_hdr) {\n\t\t\tbreak;\n\t\t}\n\t\tmemcpy(&cache->hdr[i++], item, sizeof(cache_hdr_t));\n\t}\n\nbeach:\n\trz_list_free(hdrs);\n}\n\nstatic void populate_cache_maps(RzDyldCache *cache) {\n\trz_return_if_fail(cache && cache->buf);\n\n\tut32 i;\n\tut32 n_maps = 0;\n\tut64 max_count = 0;\n\tfor (i = 0; i < cache->n_hdr; i++) {\n\t\tcache_hdr_t *hdr = &cache->hdr[i];\n\t\tif (!hdr->mappingCount || !hdr->mappingOffset) {\n\t\t\tcontinue;\n\t\t}\n\t\tmax_count = RZ_MAX(hdr->mappingCount, max_count);\n\t\tn_maps += hdr->mappingCount;\n\t}\n\n\tif (n_maps < 1 || n_maps < max_count /* overflow */) {\n\t\tcache->maps = NULL;\n\t\tcache->n_maps = 0;\n\t\treturn;\n\t}\n\n\tcache->maps_index = RZ_NEWS0(ut32, cache->n_hdr);\n\tif (!cache->maps_index) {\n\t\treturn;\n\t}\n\tcache_map_t *maps = RZ_NEWS0(cache_map_t, n_maps);\n\n\tut32 next_map = 0;\n\tut32 last_idx = UT32_MAX;\n\tut64 max_address = 0;\n\tfor (i = 0; i < cache->n_hdr; i++) {\n\t\tcache_hdr_t *hdr = &cache->hdr[i];\n\t\tcache->maps_index[i] = next_map;\n\n\t\tif (!hdr->mappingCount || !hdr->mappingOffset) {\n\t\t\tcontinue;\n\t\t}\n\t\tut64 size = sizeof(cache_map_t) * hdr->mappingCount;\n\t\tif (rz_buf_fread_at(cache->buf, hdr->mappingOffset, (ut8 *)&maps[next_map], \"3l2i\", hdr->mappingCount) != size) {\n\t\t\tcontinue;\n\t\t}\n\t\tut32 j;\n\t\tut64 hdr_offset = cache->hdr_offset[i];\n\t\tfor (j = 0; j < hdr->mappingCount; j++) {\n\t\t\tcache_map_t *map = &maps[next_map + j];\n\t\t\tmap->fileOffset += hdr_offset;\n\t\t\tif (map->address > max_address) {\n\t\t\t\tlast_idx = i;\n\t\t\t\tmax_address = map->address;\n\t\t\t}\n\t\t}\n\t\tnext_map += hdr->mappingCount;\n\t}\n\n\tcache->maps = maps;\n\tcache->n_maps = next_map;\n\tif (last_idx == UT32_MAX) {\n\t\tcache->symbols_off_base = 0;\n\t} else {\n\t\tcache->symbols_off_base = cache->hdr_offset[last_idx];\n\t}\n}\n\nstatic cache_accel_t *read_cache_accel(RzBuffer *cache_buf, cache_hdr_t *hdr, cache_map_t *maps) {\n\tif (!cache_buf || !hdr || !hdr->accelerateInfoSize || !hdr->accelerateInfoAddr) {\n\t\treturn NULL;\n\t}\n\n\tut64 offset = va2pa(hdr->accelerateInfoAddr, hdr->mappingCount, maps, cache_buf, 0, NULL, NULL);\n\tif (!offset) {\n\t\treturn NULL;\n\t}\n\n\tut64 size = sizeof(cache_accel_t);\n\tcache_accel_t *accel = RZ_NEW0(cache_accel_t);\n\tif (!accel) {\n\t\treturn NULL;\n\t}\n\n\tif (rz_buf_fread_at(cache_buf, offset, (ut8 *)accel, \"16il\", 1) != size) {\n\t\tRZ_FREE(accel);\n\t\treturn NULL;\n\t}\n\n\taccel->imagesExtrasOffset += offset;\n\taccel->bottomUpListOffset += offset;\n\taccel->dylibTrieOffset += offset;\n\taccel->initializersOffset += offset;\n\taccel->dofSectionsOffset += offset;\n\taccel->reExportListOffset += offset;\n\taccel->depListOffset += offset;\n\taccel->rangeTableOffset += offset;\n\n\treturn accel;\n}\n\nRZ_API objc_cache_opt_info *rz_dyldcache_get_objc_opt_info(RzBinFile *bf, RzDyldCache *cache) {\n\tobjc_cache_opt_info *result = NULL;\n\tRzListIter *iter;\n\tRzDyldBinImage *bin;\n\trz_list_foreach (cache->bins, iter, bin) {\n\t\tif (strcmp(bin->file, \"lib/libobjc.A.dylib\")) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tstruct MACH0_(opts_t) opts = { 0 };\n\t\topts.verbose = bf->rbin->verbose;\n\t\topts.header_at = bin->header_at;\n\n\t\tstruct MACH0_(obj_t) *mach0 = MACH0_(new_buf)(cache->buf, &opts);\n\t\tif (!mach0) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tstruct section_t *sections = NULL;\n\t\tif (!(sections = MACH0_(get_sections)(mach0))) {\n\t\t\tMACH0_(mach0_free)\n\t\t\t(mach0);\n\t\t\tgoto beach;\n\t\t}\n\n\t\tint i;\n\t\tut64 scoffs_offset = 0;\n\t\tut64 scoffs_size = 0;\n\t\tut64 slide = rz_dyldcache_get_slide(cache);\n\t\tfor (i = 0; !sections[i].last; i++) {\n\t\t\tif (sections[i].size == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (strstr(sections[i].name, \"__objc_scoffs\")) {\n\t\t\t\tscoffs_offset = va2pa(sections[i].addr, cache->n_maps, cache->maps, cache->buf, slide, NULL, NULL);\n\t\t\t\tscoffs_size = sections[i].size;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tMACH0_(mach0_free)\n\t\t(mach0);\n\t\tRZ_FREE(sections);\n\n\t\tif (!scoffs_offset || scoffs_size < 40) {\n\t\t\tbreak;\n\t\t}\n\t\tut64 check;\n\t\tif (!rz_buf_read_le64_at(cache->buf, scoffs_offset, &check) || check != 2) {\n\t\t\tbreak;\n\t\t}\n\t\tut64 sel_string_base;\n\t\tif (!rz_buf_read_le64_at(cache->buf, scoffs_offset + 8, &sel_string_base)) {\n\t\t\tbreak;\n\t\t}\n\t\tut64 sel_string_end;\n\t\tif (!rz_buf_read_le64_at(cache->buf, scoffs_offset + 16, &sel_string_end) || sel_string_end == sel_string_base) {\n\t\t\tbreak;\n\t\t}\n\t\tresult = RZ_NEW0(objc_cache_opt_info);\n\t\tif (!result) {\n\t\t\tbreak;\n\t\t}\n\t\tresult->sel_string_base = sel_string_base;\n\t}\nbeach:\n\treturn result;\n}\n\nstatic cache_img_t *read_cache_images(RzBuffer *cache_buf, cache_hdr_t *hdr, ut64 hdr_offset) {\n\tif (!cache_buf || !hdr) {\n\t\treturn NULL;\n\t}\n\tif (!hdr->imagesCount || !hdr->imagesOffset || hdr->imagesOffset == UT32_MAX || hdr->imagesCount == UT32_MAX) {\n\t\treturn NULL;\n\t}\n\n\tut64 size = sizeof(cache_img_t) * hdr->imagesCount;\n\tcache_img_t *images = RZ_NEWS0(cache_img_t, hdr->imagesCount);\n\tif (!images) {\n\t\treturn NULL;\n\t}\n\n\tif (rz_buf_fread_at(cache_buf, hdr->imagesOffset, (ut8 *)images, \"3l2i\", hdr->imagesCount) != size) {\n\t\tRZ_FREE(images);\n\t\treturn NULL;\n\t}\n\n\tif (hdr_offset) {\n\t\tut32 i;\n\t\tfor (i = 0; i < hdr->imagesCount; i++) {\n\t\t\tcache_img_t *img = &images[i];\n\t\t\timg->pathFileOffset += hdr_offset;\n\t\t}\n\t}\n\n\treturn images;\n}\n\nstatic void match_bin_entries(RzDyldCache *cache, void *entries) {\n\trz_return_if_fail(cache && cache->bins && entries);\n\n\tcache_img_t *imgs = read_cache_images(cache->buf, cache->hdr, 0);\n\tif (!imgs) {\n\t\treturn;\n\t}\n\n\tRzDyldBinImage *bin = NULL;\n\tRzListIter *it = rz_list_iterator(cache->bins);\n\n\tbool has_large_entries = cache->n_hdr > 1;\n\n\tut32 i;\n\tfor (i = 0; i < cache->hdr->imagesCount; i++) {\n\t\tcache_img_t *img = &imgs[i];\n\t\tif (!it) {\n\t\t\tbreak;\n\t\t}\n\t\tbin = it->data;\n\t\tif (!bin) {\n\t\t\tbreak;\n\t\t}\n\t\tif (bin && bin->va == img->address) {\n\t\t\tif (has_large_entries) {\n\t\t\t\tcache_locsym_entry_large_t *e = &((cache_locsym_entry_large_t *)entries)[i];\n\t\t\t\tbin->nlist_start_index = e->nlistStartIndex;\n\t\t\t\tbin->nlist_count = e->nlistCount;\n\t\t\t} else {\n\t\t\t\tcache_locsym_entry_t *e = &((cache_locsym_entry_t *)entries)[i];\n\t\t\t\tbin->nlist_start_index = e->nlistStartIndex;\n\t\t\t\tbin->nlist_count = e->nlistCount;\n\t\t\t}\n\t\t\tit = it->n;\n\t\t}\n\t}\n\n\tRZ_FREE(imgs);\n}\n\nstatic cache_imgxtr_t *read_cache_imgextra(RzBuffer *cache_buf, cache_hdr_t *hdr, cache_accel_t *accel) {\n\tif (!cache_buf || !hdr || !hdr->imagesCount || !accel || !accel->imageExtrasCount || !accel->imagesExtrasOffset) {\n\t\treturn NULL;\n\t}\n\n\tut64 size = sizeof(cache_imgxtr_t) * accel->imageExtrasCount;\n\tcache_imgxtr_t *images = RZ_NEWS0(cache_imgxtr_t, accel->imageExtrasCount);\n\tif (!images) {\n\t\treturn NULL;\n\t}\n\n\tif (rz_buf_fread_at(cache_buf, accel->imagesExtrasOffset, (ut8 *)images, \"ll4i\", accel->imageExtrasCount) != size) {\n\t\tRZ_FREE(images);\n\t\treturn NULL;\n\t}\n\n\treturn images;\n}\n\nstatic char *get_lib_name(RzBuffer *cache_buf, cache_img_t *img) {\n\tchar file[256];\n\tchar *lib_name = file;\n\tif (rz_buf_read_at(cache_buf, img->pathFileOffset, (ut8 *)&file, sizeof(file)) == sizeof(file)) {\n\t\tfile[255] = 0;\n\t\treturn strdup(lib_name);\n\t}\n\treturn strdup(\"FAIL\");\n}\n\nstatic int string_contains(const void *a, const void *b) {\n\treturn !strstr((const char *)a, (const char *)b);\n}\n\nstatic HtPU *create_path_to_index(RzBuffer *cache_buf, cache_img_t *img, cache_hdr_t *hdr) {\n\tHtPU *path_to_idx = ht_pu_new0();\n\tif (!path_to_idx) {\n\t\treturn NULL;\n\t}\n\tfor (size_t i = 0; i != hdr->imagesCount; i++) {\n\t\tchar file[256];\n\t\tif (rz_buf_read_at(cache_buf, img[i].pathFileOffset, (ut8 *)&file, sizeof(file)) != sizeof(file)) {\n\t\t\tcontinue;\n\t\t}\n\t\tfile[255] = 0;\n\t\tht_pu_insert(path_to_idx, file, (ut64)i);\n\t}\n\n\treturn path_to_idx;\n}\n\nstatic void carve_deps_at_address(RzDyldCache *cache, cache_img_t *img, HtPU *path_to_idx, ut64 address, int *deps, bool printing) {\n\tut64 pa = va2pa(address, cache->n_maps, cache->maps, cache->buf, 0, NULL, NULL);\n\tif (pa == UT64_MAX) {\n\t\treturn;\n\t}\n\tstruct MACH0_(mach_header) mh;\n\tif (rz_buf_fread_at(cache->buf, pa, (ut8 *)&mh, \"8i\", 1) != sizeof(struct MACH0_(mach_header))) {\n\t\treturn;\n\t}\n\tif (mh.magic != MH_MAGIC_64 || mh.sizeofcmds == 0) {\n\t\treturn;\n\t}\n\tut64 cmds_at = pa + sizeof(struct MACH0_(mach_header));\n\tut8 *cmds = malloc(mh.sizeofcmds + 1);\n\tif (!cmds || rz_buf_read_at(cache->buf, cmds_at, cmds, mh.sizeofcmds) != mh.sizeofcmds) {\n\t\tgoto beach;\n\t}\n\tcmds[mh.sizeofcmds] = 0;\n\tut8 *cursor = cmds;\n\tut8 *end = cmds + mh.sizeofcmds;\n\twhile (cursor < end) {\n\t\tut32 cmd = rz_read_le32(cursor);\n\t\tut32 cmdsize = rz_read_le32(cursor + sizeof(ut32));\n\t\tif (cmd == LC_LOAD_DYLIB ||\n\t\t\tcmd == LC_LOAD_WEAK_DYLIB ||\n\t\t\tcmd == LC_REEXPORT_DYLIB ||\n\t\t\tcmd == LC_LOAD_UPWARD_DYLIB) {\n\t\t\tbool found;\n\t\t\tif (cursor + 24 >= end) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tconst char *key = (const char *)cursor + 24;\n\t\t\tsize_t dep_index = (size_t)ht_pu_find(path_to_idx, key, &found);\n\t\t\tif (!found || dep_index >= cache->hdr->imagesCount) {\n\t\t\t\tRZ_LOG_WARN(\"alien dep '%s'\\n\", key);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdeps[dep_index]++;\n\t\t\tif (printing) {\n\t\t\t\tRZ_LOG_INFO(\"-> %s\\n\", key);\n\t\t\t}\n\t\t}\n\t\tcursor += cmdsize;\n\t}\n\nbeach:\n\tfree(cmds);\n}\n\nstatic RzList *create_cache_bins(RzDyldCache *cache) {\n\tRzList *bins = rz_list_newf((RzListFree)free_bin);\n\tif (!bins) {\n\t\treturn NULL;\n\t}\n\n\tchar *target_libs = NULL;\n\tRzList *target_lib_names = NULL;\n\tint *deps = NULL;\n\ttarget_libs = rz_sys_getenv(\"RZ_DYLDCACHE_FILTER\");\n\tif (target_libs) {\n\t\ttarget_lib_names = rz_str_split_list(target_libs, \":\", 0);\n\t\tif (!target_lib_names) {\n\t\t\trz_list_free(bins);\n\t\t\treturn NULL;\n\t\t}\n\t\tdeps = RZ_NEWS0(int, cache->hdr->imagesCount);\n\t\tif (!deps) {\n\t\t\trz_list_free(bins);\n\t\t\trz_list_free(target_lib_names);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tut32 i;\n\tfor (i = 0; i < cache->n_hdr; i++) {\n\t\tcache_hdr_t *hdr = &cache->hdr[i];\n\t\tut64 hdr_offset = cache->hdr_offset[i];\n\t\tut64 symbols_off = cache->symbols_off_base - hdr_offset;\n\t\tut32 maps_index = cache->maps_index[i];\n\t\tcache_img_t *img = read_cache_images(cache->buf, hdr, hdr_offset);\n\t\tif (!img) {\n\t\t\tgoto next;\n\t\t}\n\n\t\tut32 j;\n\t\tut16 *depArray = NULL;\n\t\tcache_imgxtr_t *extras = NULL;\n\t\tif (target_libs) {\n\t\t\tHtPU *path_to_idx = NULL;\n\t\t\tif (cache->accel) {\n\t\t\t\tdepArray = RZ_NEWS0(ut16, cache->accel->depListCount);\n\t\t\t\tif (!depArray) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\n\t\t\t\tif (rz_buf_fread_at(cache->buf, cache->accel->depListOffset, (ut8 *)depArray, \"s\", cache->accel->depListCount) != cache->accel->depListCount * 2) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\n\t\t\t\textras = read_cache_imgextra(cache->buf, hdr, cache->accel);\n\t\t\t\tif (!extras) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpath_to_idx = create_path_to_index(cache->buf, img, hdr);\n\t\t\t}\n\n\t\t\tfor (j = 0; j < hdr->imagesCount; j++) {\n\t\t\t\tbool printing = !deps[j];\n\t\t\t\tchar *lib_name = get_lib_name(cache->buf, &img[j]);\n\t\t\t\tif (!lib_name) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (strstr(lib_name, \"libobjc.A.dylib\")) {\n\t\t\t\t\tdeps[j]++;\n\t\t\t\t}\n\t\t\t\tif (!rz_list_find(target_lib_names, lib_name, string_contains)) {\n\t\t\t\t\tRZ_FREE(lib_name);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (printing) {\n\t\t\t\t\tRZ_LOG_INFO(\"FILTER: %s\\n\", lib_name);\n\t\t\t\t}\n\t\t\t\tRZ_FREE(lib_name);\n\t\t\t\tdeps[j]++;\n\n\t\t\t\tif (extras && depArray) {\n\t\t\t\t\tut32 k;\n\t\t\t\t\tfor (k = extras[j].dependentsStartArrayIndex; depArray[k] != 0xffff; k++) {\n\t\t\t\t\t\tut16 dep_index = depArray[k] & 0x7fff;\n\t\t\t\t\t\tdeps[dep_index]++;\n\n\t\t\t\t\t\tchar *dep_name = get_lib_name(cache->buf, &img[dep_index]);\n\t\t\t\t\t\tif (!dep_name) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (printing) {\n\t\t\t\t\t\t\tRZ_LOG_INFO(\"-> %s\\n\", dep_name);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree(dep_name);\n\t\t\t\t\t}\n\t\t\t\t} else if (path_to_idx) {\n\t\t\t\t\tcarve_deps_at_address(cache, img, path_to_idx, img[j].address, deps, printing);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tht_pu_free(path_to_idx);\n\t\t\tRZ_FREE(depArray);\n\t\t\tRZ_FREE(extras);\n\t\t}\n\n\t\tfor (j = 0; j < hdr->imagesCount; j++) {\n\t\t\tif (deps && !deps[j]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tut64 pa = va2pa(img[j].address, hdr->mappingCount, &cache->maps[maps_index], cache->buf, 0, NULL, NULL);\n\t\t\tif (pa == UT64_MAX) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tut8 magicbytes[4];\n\t\t\trz_buf_read_at(cache->buf, pa, magicbytes, 4);\n\t\t\tint magic = rz_read_le32(magicbytes);\n\t\t\tswitch (magic) {\n\t\t\tcase MH_MAGIC_64: {\n\t\t\t\tchar file[256];\n\t\t\t\tRzDyldBinImage *bin = RZ_NEW0(RzDyldBinImage);\n\t\t\t\tif (!bin) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t\tbin->header_at = pa;\n\t\t\t\tbin->hdr_offset = hdr_offset;\n\t\t\t\tbin->symbols_off = symbols_off;\n\t\t\t\tbin->va = img[j].address;\n\t\t\t\tif (rz_buf_read_at(cache->buf, img[j].pathFileOffset, (ut8 *)&file, sizeof(file)) == sizeof(file)) {\n\t\t\t\t\tfile[255] = 0;\n\t\t\t\t\tchar *last_slash = strrchr(file, '/');\n\t\t\t\t\tif (last_slash && *last_slash) {\n\t\t\t\t\t\tif (last_slash > file) {\n\t\t\t\t\t\t\tchar *scan = last_slash - 1;\n\t\t\t\t\t\t\twhile (scan > file && *scan != '/') {\n\t\t\t\t\t\t\t\tscan--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (*scan == '/') {\n\t\t\t\t\t\t\t\tbin->file = strdup(scan + 1);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tbin->file = strdup(last_slash + 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbin->file = strdup(last_slash + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbin->file = strdup(file);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trz_list_append(bins, bin);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tRZ_LOG_WARN(\"Unknown sub-bin\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\tnext:\n\t\tRZ_FREE(depArray);\n\t\tRZ_FREE(extras);\n\t\tRZ_FREE(img);\n\t}\n\tif (rz_list_empty(bins)) {\n\t\trz_list_free(bins);\n\t\tbins = NULL;\n\t}\n\tRZ_FREE(deps);\n\tRZ_FREE(target_libs);\n\trz_list_free(target_lib_names);\n\treturn bins;\n}\n\nstatic ut32 dumb_ctzll(ut64 x) {\n\tut64 result = 0;\n\tint i, j;\n\tfor (i = 0; i < 64; i += 8) {\n\t\tut8 byte = (x >> i) & 0xff;\n\t\tif (!byte) {\n\t\t\tresult += 8;\n\t\t} else {\n\t\t\tfor (j = 0; j < 8; j++) {\n\t\t\t\tif (!((byte >> j) & 1)) {\n\t\t\t\t\tresult++;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn result;\n}\n\nstatic ut64 estimate_slide(RzDyldCache *cache, ut64 value_mask, ut64 value_add) {\n\tut64 slide = 0;\n\tif (cache->n_hdr > 1) {\n\t\treturn slide;\n\t}\n\tut64 *classlist = malloc(64);\n\tif (!classlist) {\n\t\tgoto beach;\n\t}\n\n\tRzListIter *iter;\n\tRzDyldBinImage *bin;\n\trz_list_foreach (cache->bins, iter, bin) {\n\t\tbool found_sample = false;\n\n\t\tstruct MACH0_(opts_t) opts = { 0 };\n\t\topts.header_at = bin->header_at;\n\n\t\tstruct MACH0_(obj_t) *mach0 = MACH0_(new_buf)(cache->buf, &opts);\n\t\tif (!mach0) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tstruct section_t *sections = NULL;\n\t\tif (!(sections = MACH0_(get_sections)(mach0))) {\n\t\t\tMACH0_(mach0_free)\n\t\t\t(mach0);\n\t\t\tgoto beach;\n\t\t}\n\n\t\tint i;\n\t\tint incomplete = 2;\n\t\tint classlist_idx = 0, data_idx = 0;\n\t\tfor (i = 0; !sections[i].last && incomplete; i++) {\n\t\t\tif (sections[i].size == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (strstr(sections[i].name, \"__objc_classlist\")) {\n\t\t\t\tincomplete--;\n\t\t\t\tclasslist_idx = i;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (strstr(sections[i].name, \"__objc_data\")) {\n\t\t\t\tincomplete--;\n\t\t\t\tdata_idx = i;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (incomplete) {\n\t\t\tgoto next_bin;\n\t\t}\n\n\t\tint classlist_sample_size = RZ_MIN(64, sections[classlist_idx].size);\n\t\tint n_classes = classlist_sample_size / 8;\n\t\tut64 sect_offset = sections[classlist_idx].offset + bin->hdr_offset;\n\n\t\tif (rz_buf_fread_at(cache->buf, sect_offset, (ut8 *)classlist, \"l\", n_classes) < classlist_sample_size) {\n\t\t\tgoto next_bin;\n\t\t}\n\n\t\tut64 data_addr = sections[data_idx].addr;\n\t\tut64 data_tail = data_addr & 0xfff;\n\t\tut64 data_tail_end = (data_addr + sections[data_idx].size) & 0xfff;\n\t\tfor (i = 0; i < n_classes; i++) {\n\t\t\tut64 cl_addr = (classlist[i] & value_mask) + value_add;\n\t\t\tut64 cl_tail = cl_addr & 0xfff;\n\t\t\tif (cl_tail >= data_tail && cl_tail < data_tail_end) {\n\t\t\t\tut64 off = cl_tail - data_tail;\n\t\t\t\tslide = ((cl_addr - off) & value_mask) - (data_addr & value_mask);\n\t\t\t\tfound_sample = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\tnext_bin:\n\t\tMACH0_(mach0_free)\n\t\t(mach0);\n\t\tfree(sections);\n\n\t\tif (found_sample) {\n\t\t\tbreak;\n\t\t}\n\t}\n\nbeach:\n\tfree(classlist);\n\treturn slide;\n}\n\nstatic RzDyldRebaseInfo *get_rebase_info(RzDyldCache *cache, ut64 slideInfoOffset, ut64 slideInfoSize, ut64 start_of_data, ut64 slide) {\n\tut8 *tmp_buf_1 = NULL;\n\tut8 *tmp_buf_2 = NULL;\n\tut8 *one_page_buf = NULL;\n\tRzBuffer *cache_buf = cache->buf;\n\n\tut64 offset = slideInfoOffset;\n\tut32 slide_info_version = 0;\n\tif (rz_buf_read_at(cache_buf, offset, (ut8 *)&slide_info_version, 4) != 4) {\n\t\treturn NULL;\n\t}\n\n\tif (slide_info_version == 3) {\n\t\tcache_slide3_t slide_info;\n\t\tut64 size = sizeof(cache_slide3_t);\n\t\tif (rz_buf_fread_at(cache_buf, offset, (ut8 *)&slide_info, \"4i1l\", 1) < 20) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tut64 page_starts_offset = offset + size;\n\t\tut64 page_starts_size = slide_info.page_starts_count * 2;\n\n\t\tif (page_starts_size + size > slideInfoSize) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (page_starts_size > 0) {\n\t\t\ttmp_buf_1 = malloc(page_starts_size);\n\t\t\tif (!tmp_buf_1) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (rz_buf_fread_at(cache_buf, page_starts_offset, tmp_buf_1, \"s\", slide_info.page_starts_count) != page_starts_size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\n\t\tif (slide_info.page_size > 0) {\n\t\t\tone_page_buf = malloc(slide_info.page_size);\n\t\t\tif (!one_page_buf) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\n\t\tRzDyldRebaseInfo3 *rebase_info = RZ_NEW0(RzDyldRebaseInfo3);\n\t\tif (!rebase_info) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\trebase_info->version = 3;\n\t\trebase_info->delta_mask = 0x3ff8000000000000ULL;\n\t\trebase_info->delta_shift = 51;\n\t\trebase_info->start_of_data = start_of_data;\n\t\trebase_info->page_starts = (ut16 *)tmp_buf_1;\n\t\trebase_info->page_starts_count = slide_info.page_starts_count;\n\t\trebase_info->auth_value_add = slide_info.auth_value_add;\n\t\trebase_info->page_size = slide_info.page_size;\n\t\trebase_info->one_page_buf = one_page_buf;\n\t\tif (slide == UT64_MAX) {\n\t\t\trebase_info->slide = estimate_slide(cache, 0x7ffffffffffffULL, 0);\n\t\t\tif (rebase_info->slide) {\n\t\t\t\tRZ_LOG_INFO(\"dyldcache is slid: 0x%\" PFMT64x \"\\n\", rebase_info->slide);\n\t\t\t}\n\t\t} else {\n\t\t\trebase_info->slide = slide;\n\t\t}\n\n\t\treturn (RzDyldRebaseInfo *)rebase_info;\n\t} else if (slide_info_version == 2 || slide_info_version == 4) {\n\t\tcache_slide2_t slide_info;\n\t\tut64 size = sizeof(cache_slide2_t);\n\t\tif (rz_buf_fread_at(cache_buf, offset, (ut8 *)&slide_info, \"6i2l\", 1) != size) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (slide_info.page_starts_offset == 0 ||\n\t\t\tslide_info.page_starts_offset > slideInfoSize ||\n\t\t\tslide_info.page_starts_offset + slide_info.page_starts_count * 2 > slideInfoSize) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (slide_info.page_extras_offset == 0 ||\n\t\t\tslide_info.page_extras_offset > slideInfoSize ||\n\t\t\tslide_info.page_extras_offset + slide_info.page_extras_count * 2 > slideInfoSize) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (slide_info.page_starts_count > 0) {\n\t\t\tut64 size = slide_info.page_starts_count * 2;\n\t\t\tut64 at = slideInfoOffset + slide_info.page_starts_offset;\n\t\t\ttmp_buf_1 = malloc(size);\n\t\t\tif (!tmp_buf_1) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (rz_buf_fread_at(cache_buf, at, tmp_buf_1, \"s\", slide_info.page_starts_count) != size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\n\t\tif (slide_info.page_extras_count > 0) {\n\t\t\tut64 size = slide_info.page_extras_count * 2;\n\t\t\tut64 at = slideInfoOffset + slide_info.page_extras_offset;\n\t\t\ttmp_buf_2 = malloc(size);\n\t\t\tif (!tmp_buf_2) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (rz_buf_fread_at(cache_buf, at, tmp_buf_2, \"s\", slide_info.page_extras_count) != size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\n\t\tif (slide_info.page_size > 0) {\n\t\t\tone_page_buf = malloc(slide_info.page_size);\n\t\t\tif (!one_page_buf) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\n\t\tRzDyldRebaseInfo2 *rebase_info = RZ_NEW0(RzDyldRebaseInfo2);\n\t\tif (!rebase_info) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\trebase_info->version = slide_info_version;\n\t\trebase_info->start_of_data = start_of_data;\n\t\trebase_info->page_starts = (ut16 *)tmp_buf_1;\n\t\trebase_info->page_starts_count = slide_info.page_starts_count;\n\t\trebase_info->page_extras = (ut16 *)tmp_buf_2;\n\t\trebase_info->page_extras_count = slide_info.page_extras_count;\n\t\trebase_info->value_add = slide_info.value_add;\n\t\trebase_info->delta_mask = slide_info.delta_mask;\n\t\trebase_info->value_mask = ~rebase_info->delta_mask;\n\t\trebase_info->delta_shift = dumb_ctzll(rebase_info->delta_mask) - 2;\n\t\trebase_info->page_size = slide_info.page_size;\n\t\trebase_info->one_page_buf = one_page_buf;\n\t\tif (slide == UT64_MAX) {\n\t\t\trebase_info->slide = estimate_slide(cache, rebase_info->value_mask, rebase_info->value_add);\n\t\t\tif (rebase_info->slide) {\n\t\t\t\tRZ_LOG_INFO(\"dyldcache is slid: 0x%\" PFMT64x \"\\n\", rebase_info->slide);\n\t\t\t}\n\t\t} else {\n\t\t\trebase_info->slide = slide;\n\t\t}\n\n\t\treturn (RzDyldRebaseInfo *)rebase_info;\n\t} else if (slide_info_version == 1) {\n\t\tcache_slide1_t slide_info;\n\t\tut64 size = sizeof(cache_slide1_t);\n\t\tif (rz_buf_fread_at(cache_buf, offset, (ut8 *)&slide_info, \"6i\", 1) != size) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (slide_info.toc_offset == 0 ||\n\t\t\tslide_info.toc_offset > slideInfoSize ||\n\t\t\tslide_info.toc_offset + slide_info.toc_count * 2 > slideInfoSize) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (slide_info.entries_offset == 0 ||\n\t\t\tslide_info.entries_offset > slideInfoSize ||\n\t\t\tslide_info.entries_offset + slide_info.entries_count * slide_info.entries_size > slideInfoSize) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (slide_info.toc_count > 0) {\n\t\t\tut64 size = slide_info.toc_count * 2;\n\t\t\tut64 at = slideInfoOffset + slide_info.toc_offset;\n\t\t\ttmp_buf_1 = malloc(size);\n\t\t\tif (!tmp_buf_1) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (rz_buf_fread_at(cache_buf, at, tmp_buf_1, \"s\", slide_info.toc_count) != size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\n\t\tif (slide_info.entries_count > 0) {\n\t\t\tut64 size = (ut64)slide_info.entries_count * (ut64)slide_info.entries_size;\n\t\t\tut64 at = slideInfoOffset + slide_info.entries_offset;\n\t\t\ttmp_buf_2 = malloc(size);\n\t\t\tif (!tmp_buf_2) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (rz_buf_read_at(cache_buf, at, tmp_buf_2, size) != size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\n\t\tone_page_buf = malloc(4096);\n\t\tif (!one_page_buf) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tRzDyldRebaseInfo1 *rebase_info = RZ_NEW0(RzDyldRebaseInfo1);\n\t\tif (!rebase_info) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\trebase_info->version = 1;\n\t\trebase_info->start_of_data = start_of_data;\n\t\trebase_info->one_page_buf = one_page_buf;\n\t\trebase_info->page_size = 4096;\n\t\trebase_info->toc = (ut16 *)tmp_buf_1;\n\t\trebase_info->toc_count = slide_info.toc_count;\n\t\trebase_info->entries = tmp_buf_2;\n\t\trebase_info->entries_size = slide_info.entries_size;\n\t\tif (slide == UT64_MAX) {\n\t\t\trebase_info->slide = estimate_slide(cache, UT64_MAX, 0);\n\t\t\tif (rebase_info->slide) {\n\t\t\t\tRZ_LOG_INFO(\"dyldcache is slid: 0x%\" PFMT64x \"\\n\", rebase_info->slide);\n\t\t\t}\n\t\t} else {\n\t\t\trebase_info->slide = slide;\n\t\t}\n\n\t\treturn (RzDyldRebaseInfo *)rebase_info;\n\t} else {\n\t\tRZ_LOG_ERROR(\"Unsupported slide info version %d\\n\", slide_info_version);\n\t\treturn NULL;\n\t}\n\nbeach:\n\tfree(tmp_buf_1);\n\tfree(tmp_buf_2);\n\tfree(one_page_buf);\n\treturn NULL;\n}\n\nstatic RzDyldRebaseInfos *get_rebase_infos(RzDyldCache *cache) {\n\tRzDyldRebaseInfos *result = RZ_NEW0(RzDyldRebaseInfos);\n\tif (!result) {\n\t\treturn NULL;\n\t}\n\n\tif (!cache->hdr->slideInfoOffset || !cache->hdr->slideInfoSize) {\n\t\tsize_t total_slide_infos = 0;\n\t\tut32 n_slide_infos[MAX_N_HDR];\n\n\t\tut32 i;\n\t\tfor (i = 0; i < cache->n_hdr && i < MAX_N_HDR; i++) {\n\t\t\tut64 hdr_offset = cache->hdr_offset[i];\n\t\t\tif (!rz_buf_read_le32_at(cache->buf, 0x13c + hdr_offset, &n_slide_infos[i])) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tut32 total = total_slide_infos + n_slide_infos[i];\n\t\t\tif (total < total_slide_infos) {\n\t\t\t\t// overflow\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\ttotal_slide_infos = total;\n\t\t}\n\n\t\tif (!total_slide_infos) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tRzDyldRebaseInfosEntry *infos = RZ_NEWS0(RzDyldRebaseInfosEntry, total_slide_infos);\n\t\tif (!infos) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tut32 k = 0;\n\t\tfor (i = 0; i < cache->n_hdr && i < MAX_N_HDR; i++) {\n\t\t\tut64 hdr_offset = cache->hdr_offset[i];\n\t\t\tif (!n_slide_infos[i]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tut32 sio;\n\t\t\tif (!rz_buf_read_le32_at(cache->buf, 0x138 + hdr_offset, &sio)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tut64 slide_infos_offset = sio;\n\t\t\tif (!slide_infos_offset) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tslide_infos_offset += hdr_offset;\n\n\t\t\tut32 j;\n\t\t\tRzDyldRebaseInfo *prev_info = NULL;\n\t\t\tfor (j = 0; j < n_slide_infos[i]; j++) {\n\t\t\t\tut64 offset = slide_infos_offset + j * sizeof(cache_mapping_slide);\n\t\t\t\tcache_mapping_slide entry;\n\t\t\t\tif (rz_buf_fread_at(cache->buf, offset, (ut8 *)&entry, \"6lii\", 1) != sizeof(cache_mapping_slide)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (entry.slideInfoOffset && entry.slideInfoSize) {\n\t\t\t\t\tinfos[k].start = entry.fileOffset + hdr_offset;\n\t\t\t\t\tinfos[k].end = infos[k].start + entry.size;\n\t\t\t\t\tut64 slide = prev_info ? prev_info->slide : UT64_MAX;\n\t\t\t\t\tinfos[k].info = get_rebase_info(cache, entry.slideInfoOffset + hdr_offset, entry.slideInfoSize, entry.fileOffset + hdr_offset, slide);\n\t\t\t\t\tprev_info = infos[k].info;\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!k) {\n\t\t\tfree(infos);\n\t\t\tgoto beach;\n\t\t}\n\n\t\tif (k < total_slide_infos) {\n\t\t\tRzDyldRebaseInfosEntry *pruned_infos = RZ_NEWS0(RzDyldRebaseInfosEntry, k);\n\t\t\tif (!pruned_infos) {\n\t\t\t\tfree(infos);\n\t\t\t\tgoto beach;\n\t\t\t}\n\n\t\t\tmemcpy(pruned_infos, infos, sizeof(RzDyldRebaseInfosEntry) * k);\n\t\t\tfree(infos);\n\t\t\tinfos = pruned_infos;\n\t\t}\n\n\t\tresult->entries = infos;\n\t\tresult->length = k;\n\t\treturn result;\n\t}\n\n\tif (cache->hdr->mappingCount > 1) {\n\t\tRzDyldRebaseInfosEntry *infos = RZ_NEWS0(RzDyldRebaseInfosEntry, 1);\n\t\tif (!infos) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tinfos[0].start = cache->maps[1].fileOffset;\n\t\tinfos[0].end = infos[0].start + cache->maps[1].size;\n\t\tinfos[0].info = get_rebase_info(cache, cache->hdr->slideInfoOffset, cache->hdr->slideInfoSize, infos[0].start, UT64_MAX);\n\n\t\tresult->entries = infos;\n\t\tresult->length = 1;\n\t\treturn result;\n\t}\n\nbeach:\n\tfree(result);\n\treturn NULL;\n}\n\nRZ_API ut64 rz_dyldcache_get_slide(RzDyldCache *cache) {\n\trz_return_val_if_fail(cache, 0);\n\tif (!cache->rebase_infos || !cache->rebase_infos->length) {\n\t\treturn 0;\n\t}\n\n\tsize_t i;\n\tfor (i = 0; i < cache->rebase_infos->length; i++) {\n\t\tif (cache->rebase_infos->entries[i].info) {\n\t\t\treturn cache->rebase_infos->entries[i].info->slide;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nRZ_API void rz_dyldcache_symbols_from_locsym(RzDyldCache *cache, RzDyldBinImage *bin, RzList *symbols, SetU *hash) {\n\tRzDyldLocSym *locsym = cache->locsym;\n\tif (!locsym) {\n\t\treturn;\n\t}\n\n\tif (bin->nlist_start_index >= locsym->nlists_count ||\n\t\tbin->nlist_start_index + bin->nlist_count > locsym->nlists_count) {\n\t\tRZ_LOG_ERROR(\"dyldcache: malformed local symbol entry\\n\");\n\t\treturn;\n\t}\n\n\tut64 nlists_size = sizeof(struct MACH0_(nlist)) * bin->nlist_count;\n\tstruct MACH0_(nlist) *nlists = RZ_NEWS0(struct MACH0_(nlist), bin->nlist_count);\n\tif (!nlists) {\n\t\treturn;\n\t}\n\tut64 nlists_offset = locsym->local_symbols_offset + locsym->nlists_offset +\n\t\tbin->nlist_start_index * sizeof(struct MACH0_(nlist));\n\tif (rz_buf_fread_at(cache->buf, nlists_offset, (ut8 *)nlists, \"iccsl\", bin->nlist_count) != nlists_size) {\n\t\tfree(nlists);\n\t\treturn;\n\t}\n\n\tut32 j;\n\tfor (j = 0; j != bin->nlist_count; j++) {\n\t\tstruct MACH0_(nlist) *nlist = &nlists[j];\n\t\tif (set_u_contains(hash, (ut64)nlist->n_value)) {\n\t\t\tcontinue;\n\t\t}\n\t\tset_u_add(hash, (ut64)nlist->n_value);\n\t\tif (nlist->n_strx >= locsym->strings_size) {\n\t\t\tcontinue;\n\t\t}\n\t\tRzBinSymbol *sym = RZ_NEW0(RzBinSymbol);\n\t\tif (!sym) {\n\t\t\tbreak;\n\t\t}\n\t\tsym->type = \"LOCAL\";\n\t\tsym->vaddr = nlist->n_value;\n\t\tut64 slide = rz_dyldcache_get_slide(cache);\n\t\tsym->paddr = va2pa(nlist->n_value, cache->n_maps, cache->maps, cache->buf, slide, NULL, NULL);\n\n\t\tchar *symstr = rz_buf_get_string(cache->buf, locsym->local_symbols_offset + locsym->strings_offset + nlist->n_strx);\n\t\tif (symstr) {\n\t\t\tsym->name = symstr;\n\t\t} else {\n\t\t\tstatic ut32 k = 0;\n\t\t\tsym->name = rz_str_newf(\"unk_local%d\", k++);\n\t\t}\n\n\t\trz_list_append(symbols, sym);\n\t}\n\n\tfree(nlists);\n}\n\nRZ_API RzDyldCache *rz_dyldcache_new_buf(RzBuffer *buf) {\n\tRzDyldCache *cache = RZ_NEW0(RzDyldCache);\n\tif (!cache) {\n\t\treturn NULL;\n\t}\n\tmemcpy(cache->magic, \"dyldcac\", 7);\n\tcache->buf = rz_buf_ref(buf);\n\tpopulate_cache_headers(cache);\n\tif (!cache->hdr) {\n\t\tgoto cupertino;\n\t}\n\tpopulate_cache_maps(cache);\n\tif (!cache->maps) {\n\t\tgoto cupertino;\n\t}\n\tcache->accel = read_cache_accel(cache->buf, cache->hdr, cache->maps);\n\tcache->bins = create_cache_bins(cache);\n\tif (!cache->bins) {\n\t\tgoto cupertino;\n\t}\n\tcache->locsym = rz_dyld_locsym_new(cache);\n\tcache->rebase_infos = get_rebase_infos(cache);\n\treturn cache;\ncupertino:\n\trz_dyldcache_free(cache);\n\treturn NULL;\n}\n\nstatic void rebase_info3_free(RzDyldRebaseInfo3 *rebase_info) {\n\tif (!rebase_info) {\n\t\treturn;\n\t}\n\tfree(rebase_info->page_starts);\n\tfree(rebase_info);\n}\n\nstatic void rebase_info2_free(RzDyldRebaseInfo2 *rebase_info) {\n\tif (!rebase_info) {\n\t\treturn;\n\t}\n\tfree(rebase_info->page_starts);\n\tfree(rebase_info->page_extras);\n\tfree(rebase_info);\n}\n\nstatic void rebase_info1_free(RzDyldRebaseInfo1 *rebase_info) {\n\tif (!rebase_info) {\n\t\treturn;\n\t}\n\tfree(rebase_info->toc);\n\tfree(rebase_info->entries);\n\tfree(rebase_info);\n}\n\nstatic void rebase_info_free(RzDyldRebaseInfo *rebase_info) {\n\tif (!rebase_info) {\n\t\treturn;\n\t}\n\n\tRZ_FREE(rebase_info->one_page_buf);\n\n\tut8 version = rebase_info->version;\n\n\tif (version == 1) {\n\t\trebase_info1_free((RzDyldRebaseInfo1 *)rebase_info);\n\t} else if (version == 2 || version == 4) {\n\t\trebase_info2_free((RzDyldRebaseInfo2 *)rebase_info);\n\t} else if (version == 3) {\n\t\trebase_info3_free((RzDyldRebaseInfo3 *)rebase_info);\n\t} else {\n\t\tfree(rebase_info);\n\t}\n}\n\nstatic RzDyldLocSym *rz_dyld_locsym_new(RzDyldCache *cache) {\n\trz_return_val_if_fail(cache && cache->buf, NULL);\n\n\tut32 i;\n\tfor (i = 0; i < cache->n_hdr; i++) {\n\t\tcache_hdr_t *hdr = &cache->hdr[i];\n\t\tif (!hdr || !hdr->localSymbolsSize || !hdr->localSymbolsOffset) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tcache_locsym_info_t *info = NULL;\n\t\tvoid *entries = NULL;\n\n\t\tut64 info_size = sizeof(cache_locsym_info_t);\n\t\tinfo = RZ_NEW0(cache_locsym_info_t);\n\t\tif (!info) {\n\t\t\tgoto beach;\n\t\t}\n\t\tif (rz_buf_fread_at(cache->buf, hdr->localSymbolsOffset, (ut8 *)info, \"6i\", 1) != info_size) {\n\t\t\tRZ_LOG_ERROR(\"Cannot read cache_locsym_info_t from header\\n\");\n\t\t\tgoto beach;\n\t\t}\n\t\tif (info->entriesCount != cache->hdr->imagesCount) {\n\t\t\tRZ_LOG_ERROR(\"The number of entries count differs from cache header image count\\n\");\n\t\t\tgoto beach;\n\t\t}\n\n\t\tbool has_large_entries = cache->n_hdr > 1;\n\t\tif (has_large_entries) {\n\t\t\tut64 entries_size = sizeof(cache_locsym_entry_large_t) * info->entriesCount;\n\t\t\tcache_locsym_entry_large_t *large_entries = RZ_NEWS0(cache_locsym_entry_large_t, info->entriesCount);\n\t\t\tif (!large_entries) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (rz_buf_fread_at(cache->buf, hdr->localSymbolsOffset + info->entriesOffset, (ut8 *)large_entries, \"lii\",\n\t\t\t\t    info->entriesCount) != entries_size) {\n\t\t\t\tRZ_LOG_ERROR(\"Cannot read cache_locsym_entry_large_t\\n\");\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tentries = large_entries;\n\t\t} else {\n\t\t\tut64 entries_size = sizeof(cache_locsym_entry_t) * info->entriesCount;\n\t\t\tcache_locsym_entry_t *regular_entries = RZ_NEWS0(cache_locsym_entry_t, info->entriesCount);\n\t\t\tif (!regular_entries) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (rz_buf_fread_at(cache->buf, hdr->localSymbolsOffset + info->entriesOffset, (ut8 *)regular_entries, \"iii\",\n\t\t\t\t    info->entriesCount) != entries_size) {\n\t\t\t\tRZ_LOG_ERROR(\"Cannot read cache_locsym_entry_t\\n\");\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tentries = regular_entries;\n\t\t}\n\t\tRzDyldLocSym *locsym = RZ_NEW0(RzDyldLocSym);\n\t\tif (!locsym) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tmatch_bin_entries(cache, entries);\n\n\t\tlocsym->local_symbols_offset = hdr->localSymbolsOffset;\n\t\tlocsym->nlists_offset = info->nlistOffset;\n\t\tlocsym->nlists_count = info->nlistCount;\n\t\tlocsym->strings_offset = info->stringsOffset;\n\t\tlocsym->strings_size = info->stringsSize;\n\n\t\tfree(info);\n\t\tfree(entries);\n\n\t\treturn locsym;\n\n\tbeach:\n\t\tfree(info);\n\t\tfree(entries);\n\n\t\tRZ_LOG_ERROR(\"dyldcache: malformed local symbols metadata\\n\");\n\t\tbreak;\n\t}\n\treturn NULL;\n}\n\nRZ_API void rz_dyldcache_free(RzDyldCache *cache) {\n\tif (!cache) {\n\t\treturn;\n\t}\n\n\trz_list_free(cache->bins);\n\tcache->bins = NULL;\n\trz_buf_free(cache->buf);\n\tcache->buf = NULL;\n\tif (cache->rebase_infos) {\n\t\tint i;\n\t\tfor (i = 0; i < cache->rebase_infos->length; i++) {\n\t\t\trebase_info_free(cache->rebase_infos->entries[i].info);\n\t\t\tcache->rebase_infos->entries[i].info = NULL;\n\t\t}\n\t\tRZ_FREE(cache->rebase_infos->entries);\n\t\tRZ_FREE(cache->rebase_infos);\n\t}\n\tfree(cache->hdr);\n\tfree(cache->maps);\n\tfree(cache->maps_index);\n\tfree(cache->hdr_offset);\n\tfree(cache->accel);\n\tfree(cache->locsym);\n\tfree(cache->oi);\n\tfree(cache);\n}\n\nRZ_API ut64 rz_dyldcache_va2pa(RzDyldCache *cache, uint64_t vaddr, ut32 *offset, ut32 *left) {\n\trz_return_val_if_fail(cache, UT64_MAX);\n\tut64 slide = rz_dyldcache_get_slide(cache);\n\tut64 res = va2pa(vaddr, cache->n_maps, cache->maps, cache->buf, slide, offset, left);\n\tif (res == UT64_MAX) {\n\t\tres = 0;\n\t}\n\treturn res;\n}\n"], "filenames": ["librz/bin/format/mach0/dyldcache.c"], "buggy_code_start_loc": [998], "buggy_code_end_loc": [1008], "fixing_code_start_loc": [998], "fixing_code_end_loc": [1013], "type": "CWE-787", "message": "Rizin is a UNIX-like reverse engineering framework and command-line toolset. Versions 0.4.0 and prior are vulnerable to an out-of-bounds write when getting data from dyld cache files. A user opening a malicious dyld cache file could be affected by this vulnerability, allowing an attacker to execute code on the user's machine. Commit number 556ca2f9eef01ec0f4a76d1fbacfcf3a87a44810 contains a patch.", "other": {"cve": {"id": "CVE-2022-36042", "sourceIdentifier": "security-advisories@github.com", "published": "2022-09-06T19:15:08.660", "lastModified": "2023-03-30T04:15:09.477", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Rizin is a UNIX-like reverse engineering framework and command-line toolset. Versions 0.4.0 and prior are vulnerable to an out-of-bounds write when getting data from dyld cache files. A user opening a malicious dyld cache file could be affected by this vulnerability, allowing an attacker to execute code on the user's machine. Commit number 556ca2f9eef01ec0f4a76d1fbacfcf3a87a44810 contains a patch."}, {"lang": "es", "value": "Rizin es un marco de trabajo de ingenier\u00eda inversa de tipo UNIX y un conjunto de herramientas de l\u00ednea de comandos. Las versiones 0.4.0 y anteriores son vulnerables a una escritura fuera de l\u00edmites cuando obtienen datos de los archivos de cach\u00e9 de dyld. Un usuario que abra un archivo de cach\u00e9 dyld malicioso podr\u00eda verse afectado por esta vulnerabilidad, permitiendo a un atacante ejecutar c\u00f3digo en la m\u00e1quina del usuario. El commit n\u00famero 556ca2f9eef01ec0f4a76d1fbacfcf3a87a44810 contiene un parche.\n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rizin:rizin:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.4.0", "matchCriteriaId": "5E797DF4-7DCA-46AA-9A36-5C0064FE79CA"}]}]}], "references": [{"url": "https://github.com/rizinorg/rizin/commit/556ca2f9eef01ec0f4a76d1fbacfcf3a87a44810", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/rizinorg/rizin/security/advisories/GHSA-pf72-jg54-8gvp", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WQZLMHEI5D7EJASA5UW6XN4ODHLRHK6N/", "source": "security-advisories@github.com"}, {"url": "https://security.gentoo.org/glsa/202209-06", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/rizinorg/rizin/commit/556ca2f9eef01ec0f4a76d1fbacfcf3a87a44810"}}