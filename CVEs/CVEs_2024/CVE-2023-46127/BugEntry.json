{"buggy_code": ["# -*- coding: utf-8 -*-\n# Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors\n# MIT License. See license.txt\nfrom __future__ import unicode_literals\n\nimport logging\nimport os\n\nfrom six import iteritems\nfrom werkzeug.exceptions import HTTPException, NotFound\nfrom werkzeug.local import LocalManager\nfrom werkzeug.middleware.profiler import ProfilerMiddleware\nfrom werkzeug.middleware.shared_data import SharedDataMiddleware\nfrom werkzeug.wrappers import Request, Response\n\nimport frappe\nimport frappe.api\nimport frappe.auth\nimport frappe.handler\nimport frappe.monitor\nimport frappe.rate_limiter\nimport frappe.recorder\nimport frappe.utils.response\nimport frappe.website.render\nfrom frappe import _\nfrom frappe.core.doctype.comment.comment import update_comments_in_parent_after_request\nfrom frappe.middlewares import StaticDataMiddleware\nfrom frappe.utils import get_site_name, sanitize_html\nfrom frappe.utils.error import make_error_snapshot\n\nlocal_manager = LocalManager([frappe.local])\n\n_site = None\n_sites_path = os.environ.get(\"SITES_PATH\", \".\")\n\n\nclass RequestContext(object):\n\tdef __init__(self, environ):\n\t\tself.request = Request(environ)\n\n\tdef __enter__(self):\n\t\tinit_request(self.request)\n\n\tdef __exit__(self, type, value, traceback):\n\t\tfrappe.destroy()\n\n\n@Request.application\ndef application(request):\n\tresponse = None\n\n\ttry:\n\t\trollback = True\n\n\t\tinit_request(request)\n\n\t\tfrappe.api.validate_auth()\n\n\t\tif request.method == \"OPTIONS\":\n\t\t\tresponse = Response()\n\n\t\telif frappe.form_dict.cmd:\n\t\t\tresponse = frappe.handler.handle()\n\n\t\telif request.path.startswith(\"/api/\"):\n\t\t\tresponse = frappe.api.handle()\n\n\t\telif request.path.startswith(\"/backups\"):\n\t\t\tresponse = frappe.utils.response.download_backup(request.path)\n\n\t\telif request.path.startswith(\"/private/files/\"):\n\t\t\tresponse = frappe.utils.response.download_private_file(request.path)\n\n\t\telif request.method in (\"GET\", \"HEAD\", \"POST\"):\n\t\t\tresponse = frappe.website.render.render()\n\n\t\telse:\n\t\t\traise NotFound\n\n\texcept HTTPException as e:\n\t\treturn e\n\n\texcept frappe.SessionStopped as e:\n\t\tresponse = frappe.utils.response.handle_session_stopped()\n\n\texcept Exception as e:\n\t\tresponse = handle_exception(e)\n\n\telse:\n\t\trollback = after_request(rollback)\n\n\tfinally:\n\t\t# Important note:\n\t\t# this function *must* always return a response, hence any exception thrown outside of\n\t\t# try..catch block like this finally block needs to be handled appropriately.\n\n\t\tif request.method in (\"POST\", \"PUT\") and frappe.db and rollback:\n\t\t\tfrappe.db.rollback()\n\n\t\ttry:\n\t\t\trun_after_request_hooks(request, response)\n\t\texcept Exception as e:\n\t\t\t# We can not handle exceptions safely here.\n\t\t\tfrappe.logger().error(\"Failed to run after request hook\", exc_info=True)\n\n\t\tlog_request(request, response)\n\t\tprocess_response(response)\n\t\tfrappe.destroy()\n\n\treturn response\n\n\ndef run_after_request_hooks(request, response):\n\tif not getattr(frappe.local, \"initialised\", False):\n\t\treturn\n\n\tfor after_request_task in frappe.get_hooks(\"after_request\"):\n\t\tfrappe.call(after_request_task, response=response, request=request)\n\n\ndef init_request(request):\n\tfrappe.local.request = request\n\tfrappe.local.is_ajax = frappe.get_request_header(\"X-Requested-With\") == \"XMLHttpRequest\"\n\n\tsite = _site or request.headers.get(\"X-Frappe-Site-Name\") or get_site_name(request.host)\n\tfrappe.init(site=site, sites_path=_sites_path, force=True)\n\n\tif not (frappe.local.conf and frappe.local.conf.db_name):\n\t\t# site does not exist\n\t\traise NotFound\n\n\tif frappe.local.conf.get(\"maintenance_mode\"):\n\t\tfrappe.connect()\n\t\traise frappe.SessionStopped(\"Session Stopped\")\n\telse:\n\t\tfrappe.connect(set_admin_as_user=False)\n\n\tmake_form_dict(request)\n\n\tif request.method != \"OPTIONS\":\n\t\tfrappe.local.http_request = frappe.auth.HTTPRequest()\n\n\tfor before_request_task in frappe.get_hooks(\"before_request\"):\n\t\tfrappe.call(before_request_task)\n\n\ndef log_request(request, response):\n\tif hasattr(frappe.local, \"conf\") and frappe.local.conf.enable_frappe_logger:\n\t\tfrappe.logger(\"frappe.web\", allow_site=frappe.local.site).info(\n\t\t\t{\n\t\t\t\t\"site\": get_site_name(request.host),\n\t\t\t\t\"remote_addr\": getattr(request, \"remote_addr\", \"NOTFOUND\"),\n\t\t\t\t\"base_url\": getattr(request, \"base_url\", \"NOTFOUND\"),\n\t\t\t\t\"full_path\": getattr(request, \"full_path\", \"NOTFOUND\"),\n\t\t\t\t\"method\": getattr(request, \"method\", \"NOTFOUND\"),\n\t\t\t\t\"scheme\": getattr(request, \"scheme\", \"NOTFOUND\"),\n\t\t\t\t\"http_status_code\": getattr(response, \"status_code\", \"NOTFOUND\"),\n\t\t\t}\n\t\t)\n\n\ndef process_response(response):\n\tif not response:\n\t\treturn\n\n\t# set cookies\n\tif hasattr(frappe.local, \"cookie_manager\"):\n\t\tfrappe.local.cookie_manager.flush_cookies(response=response)\n\n\t# rate limiter headers\n\tif hasattr(frappe.local, \"rate_limiter\"):\n\t\tresponse.headers.extend(frappe.local.rate_limiter.headers())\n\n\t# CORS headers\n\tif hasattr(frappe.local, \"conf\") and frappe.conf.allow_cors:\n\t\tset_cors_headers(response)\n\n\ndef set_cors_headers(response):\n\torigin = frappe.request.headers.get(\"Origin\")\n\tallow_cors = frappe.conf.allow_cors\n\tif not (origin and allow_cors):\n\t\treturn\n\n\tif allow_cors != \"*\":\n\t\tif not isinstance(allow_cors, list):\n\t\t\tallow_cors = [allow_cors]\n\n\t\tif origin not in allow_cors:\n\t\t\treturn\n\n\tresponse.headers.extend(\n\t\t{\n\t\t\t\"Access-Control-Allow-Origin\": origin,\n\t\t\t\"Access-Control-Allow-Credentials\": \"true\",\n\t\t\t\"Access-Control-Allow-Methods\": \"GET, POST, PUT, DELETE, OPTIONS\",\n\t\t\t\"Access-Control-Allow-Headers\": (\n\t\t\t\t\"Authorization,DNT,X-Mx-ReqToken,\"\n\t\t\t\t\"Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,\"\n\t\t\t\t\"Cache-Control,Content-Type\"\n\t\t\t),\n\t\t}\n\t)\n\n\ndef make_form_dict(request):\n\timport json\n\n\trequest_data = request.get_data(as_text=True)\n\tif \"application/json\" in (request.content_type or \"\") and request_data:\n\t\targs = json.loads(request_data)\n\telse:\n\t\targs = {}\n\t\targs.update(request.args or {})\n\t\targs.update(request.form or {})\n\n\tif not isinstance(args, dict):\n\t\tfrappe.throw(\"Invalid request arguments\")\n\n\ttry:\n\t\tfrappe.local.form_dict = frappe._dict(\n\t\t\t{k: v[0] if isinstance(v, (list, tuple)) else v for k, v in iteritems(args)}\n\t\t)\n\texcept IndexError:\n\t\tfrappe.local.form_dict = frappe._dict(args)\n\n\tif \"_\" in frappe.local.form_dict:\n\t\t# _ is passed by $.ajax so that the request is not cached by the browser. So, remove _ from form_dict\n\t\tfrappe.local.form_dict.pop(\"_\")\n\n\ndef handle_exception(e):\n\tresponse = None\n\thttp_status_code = getattr(e, \"http_status_code\", 500)\n\treturn_as_message = False\n\taccept_header = frappe.get_request_header(\"Accept\") or \"\"\n\trespond_as_json = (\n\t\tfrappe.get_request_header(\"Accept\")\n\t\tand (frappe.local.is_ajax or \"application/json\" in accept_header)\n\t\tor (frappe.local.request.path.startswith(\"/api/\") and not accept_header.startswith(\"text\"))\n\t)\n\n\tif respond_as_json:\n\t\t# handle ajax responses first\n\t\t# if the request is ajax, send back the trace or error message\n\t\tresponse = frappe.utils.response.report_error(http_status_code)\n\n\telif (\n\t\thttp_status_code == 500\n\t\tand (frappe.db and isinstance(e, frappe.db.InternalError))\n\t\tand (frappe.db and (frappe.db.is_deadlocked(e) or frappe.db.is_timedout(e)))\n\t):\n\t\thttp_status_code = 508\n\n\telif http_status_code == 401:\n\t\tfrappe.respond_as_web_page(\n\t\t\t_(\"Session Expired\"),\n\t\t\t_(\"Your session has expired, please login again to continue.\"),\n\t\t\thttp_status_code=http_status_code,\n\t\t\tindicator_color=\"red\",\n\t\t)\n\t\treturn_as_message = True\n\n\telif http_status_code == 403:\n\t\tfrappe.respond_as_web_page(\n\t\t\t_(\"Not Permitted\"),\n\t\t\t_(\"You do not have enough permissions to complete the action\"),\n\t\t\thttp_status_code=http_status_code,\n\t\t\tindicator_color=\"red\",\n\t\t)\n\t\treturn_as_message = True\n\n\telif http_status_code == 404:\n\t\tfrappe.respond_as_web_page(\n\t\t\t_(\"Not Found\"),\n\t\t\t_(\"The resource you are looking for is not available\"),\n\t\t\thttp_status_code=http_status_code,\n\t\t\tindicator_color=\"red\",\n\t\t)\n\t\treturn_as_message = True\n\n\telif http_status_code == 429:\n\t\tresponse = frappe.rate_limiter.respond()\n\n\telse:\n\t\ttraceback = \"<pre>\" + sanitize_html(frappe.get_traceback()) + \"</pre>\"\n\t\t# disable traceback in production if flag is set\n\t\tif frappe.local.flags.disable_traceback and not frappe.local.dev_server:\n\t\t\ttraceback = \"\"\n\n\t\tfrappe.respond_as_web_page(\n\t\t\t\"Server Error\", traceback, http_status_code=http_status_code, indicator_color=\"red\", width=640\n\t\t)\n\t\treturn_as_message = True\n\n\tif e.__class__ == frappe.AuthenticationError:\n\t\tif hasattr(frappe.local, \"login_manager\"):\n\t\t\tfrappe.local.login_manager.clear_cookies()\n\n\tif http_status_code >= 500:\n\t\tmake_error_snapshot(e)\n\n\tif return_as_message:\n\t\tresponse = frappe.website.render.render(\"message\", http_status_code=http_status_code)\n\n\tif frappe.conf.get(\"developer_mode\") and not respond_as_json:\n\t\t# don't fail silently for non-json response errors\n\t\tprint(frappe.get_traceback())\n\n\treturn response\n\n\ndef after_request(rollback):\n\tif (frappe.local.request.method in (\"POST\", \"PUT\") or frappe.local.flags.commit) and frappe.db:\n\t\tif frappe.db.transaction_writes:\n\t\t\tfrappe.db.commit()\n\t\t\trollback = False\n\n\t# update session\n\tif getattr(frappe.local, \"session_obj\", None):\n\t\tupdated_in_db = frappe.local.session_obj.update()\n\t\tif updated_in_db:\n\t\t\tfrappe.db.commit()\n\t\t\trollback = False\n\n\tupdate_comments_in_parent_after_request()\n\n\treturn rollback\n\n\napplication = local_manager.make_middleware(application)\n\n\ndef serve(\n\tport=8000, profile=False, no_reload=False, no_threading=False, site=None, sites_path=\".\"\n):\n\tglobal application, _site, _sites_path\n\t_site = site\n\t_sites_path = sites_path\n\n\tfrom werkzeug.serving import run_simple\n\n\tpatch_werkzeug_reloader()\n\n\tif profile:\n\t\tapplication = ProfilerMiddleware(application, sort_by=(\"cumtime\", \"calls\"))\n\n\tif not os.environ.get(\"NO_STATICS\"):\n\t\tapplication = SharedDataMiddleware(\n\t\t\tapplication, {str(\"/assets\"): str(os.path.join(sites_path, \"assets\"))}\n\t\t)\n\n\t\tapplication = StaticDataMiddleware(\n\t\t\tapplication, {str(\"/files\"): str(os.path.abspath(sites_path))}\n\t\t)\n\n\tapplication.debug = True\n\tapplication.config = {\"SERVER_NAME\": \"localhost:8000\"}\n\n\tlog = logging.getLogger(\"werkzeug\")\n\tlog.propagate = False\n\n\tin_test_env = os.environ.get(\"CI\")\n\tif in_test_env:\n\t\tlog.setLevel(logging.ERROR)\n\n\trun_simple(\n\t\t\"0.0.0.0\",\n\t\tint(port),\n\t\tapplication,\n\t\tuse_reloader=False if in_test_env else not no_reload,\n\t\tuse_debugger=not in_test_env,\n\t\tuse_evalex=not in_test_env,\n\t\tthreaded=not no_threading,\n\t)\n\n\ndef patch_werkzeug_reloader():\n\t\"\"\"\n\tThis function monkey patches Werkzeug reloader to ignore reloading files in\n\tthe __pycache__ directory.\n\n\tTo be deprecated when upgrading to Werkzeug 2.\n\t\"\"\"\n\n\tfrom werkzeug._reloader import WatchdogReloaderLoop\n\n\ttrigger_reload = WatchdogReloaderLoop.trigger_reload\n\n\tdef custom_trigger_reload(self, filename):\n\t\tif os.path.basename(os.path.dirname(filename)) == \"__pycache__\":\n\t\t\treturn\n\n\t\treturn trigger_reload(self, filename)\n\n\tWatchdogReloaderLoop.trigger_reload = custom_trigger_reload\n"], "fixing_code": ["# -*- coding: utf-8 -*-\n# Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors\n# MIT License. See license.txt\nfrom __future__ import unicode_literals\n\nimport logging\nimport os\n\nfrom six import iteritems\nfrom werkzeug.exceptions import HTTPException, NotFound\nfrom werkzeug.local import LocalManager\nfrom werkzeug.middleware.profiler import ProfilerMiddleware\nfrom werkzeug.middleware.shared_data import SharedDataMiddleware\nfrom werkzeug.wrappers import Request, Response\n\nimport frappe\nimport frappe.api\nimport frappe.auth\nimport frappe.handler\nimport frappe.monitor\nimport frappe.rate_limiter\nimport frappe.recorder\nimport frappe.utils.response\nimport frappe.website.render\nfrom frappe import _\nfrom frappe.core.doctype.comment.comment import update_comments_in_parent_after_request\nfrom frappe.middlewares import StaticDataMiddleware\nfrom frappe.utils import escape_html, get_site_name\nfrom frappe.utils.error import make_error_snapshot\n\nlocal_manager = LocalManager([frappe.local])\n\n_site = None\n_sites_path = os.environ.get(\"SITES_PATH\", \".\")\n\n\nclass RequestContext(object):\n\tdef __init__(self, environ):\n\t\tself.request = Request(environ)\n\n\tdef __enter__(self):\n\t\tinit_request(self.request)\n\n\tdef __exit__(self, type, value, traceback):\n\t\tfrappe.destroy()\n\n\n@Request.application\ndef application(request):\n\tresponse = None\n\n\ttry:\n\t\trollback = True\n\n\t\tinit_request(request)\n\n\t\tfrappe.api.validate_auth()\n\n\t\tif request.method == \"OPTIONS\":\n\t\t\tresponse = Response()\n\n\t\telif frappe.form_dict.cmd:\n\t\t\tresponse = frappe.handler.handle()\n\n\t\telif request.path.startswith(\"/api/\"):\n\t\t\tresponse = frappe.api.handle()\n\n\t\telif request.path.startswith(\"/backups\"):\n\t\t\tresponse = frappe.utils.response.download_backup(request.path)\n\n\t\telif request.path.startswith(\"/private/files/\"):\n\t\t\tresponse = frappe.utils.response.download_private_file(request.path)\n\n\t\telif request.method in (\"GET\", \"HEAD\", \"POST\"):\n\t\t\tresponse = frappe.website.render.render()\n\n\t\telse:\n\t\t\traise NotFound\n\n\texcept HTTPException as e:\n\t\treturn e\n\n\texcept frappe.SessionStopped as e:\n\t\tresponse = frappe.utils.response.handle_session_stopped()\n\n\texcept Exception as e:\n\t\tresponse = handle_exception(e)\n\n\telse:\n\t\trollback = after_request(rollback)\n\n\tfinally:\n\t\t# Important note:\n\t\t# this function *must* always return a response, hence any exception thrown outside of\n\t\t# try..catch block like this finally block needs to be handled appropriately.\n\n\t\tif request.method in (\"POST\", \"PUT\") and frappe.db and rollback:\n\t\t\tfrappe.db.rollback()\n\n\t\ttry:\n\t\t\trun_after_request_hooks(request, response)\n\t\texcept Exception as e:\n\t\t\t# We can not handle exceptions safely here.\n\t\t\tfrappe.logger().error(\"Failed to run after request hook\", exc_info=True)\n\n\t\tlog_request(request, response)\n\t\tprocess_response(response)\n\t\tfrappe.destroy()\n\n\treturn response\n\n\ndef run_after_request_hooks(request, response):\n\tif not getattr(frappe.local, \"initialised\", False):\n\t\treturn\n\n\tfor after_request_task in frappe.get_hooks(\"after_request\"):\n\t\tfrappe.call(after_request_task, response=response, request=request)\n\n\ndef init_request(request):\n\tfrappe.local.request = request\n\tfrappe.local.is_ajax = frappe.get_request_header(\"X-Requested-With\") == \"XMLHttpRequest\"\n\n\tsite = _site or request.headers.get(\"X-Frappe-Site-Name\") or get_site_name(request.host)\n\tfrappe.init(site=site, sites_path=_sites_path, force=True)\n\n\tif not (frappe.local.conf and frappe.local.conf.db_name):\n\t\t# site does not exist\n\t\traise NotFound\n\n\tif frappe.local.conf.get(\"maintenance_mode\"):\n\t\tfrappe.connect()\n\t\traise frappe.SessionStopped(\"Session Stopped\")\n\telse:\n\t\tfrappe.connect(set_admin_as_user=False)\n\n\tmake_form_dict(request)\n\n\tif request.method != \"OPTIONS\":\n\t\tfrappe.local.http_request = frappe.auth.HTTPRequest()\n\n\tfor before_request_task in frappe.get_hooks(\"before_request\"):\n\t\tfrappe.call(before_request_task)\n\n\ndef log_request(request, response):\n\tif hasattr(frappe.local, \"conf\") and frappe.local.conf.enable_frappe_logger:\n\t\tfrappe.logger(\"frappe.web\", allow_site=frappe.local.site).info(\n\t\t\t{\n\t\t\t\t\"site\": get_site_name(request.host),\n\t\t\t\t\"remote_addr\": getattr(request, \"remote_addr\", \"NOTFOUND\"),\n\t\t\t\t\"base_url\": getattr(request, \"base_url\", \"NOTFOUND\"),\n\t\t\t\t\"full_path\": getattr(request, \"full_path\", \"NOTFOUND\"),\n\t\t\t\t\"method\": getattr(request, \"method\", \"NOTFOUND\"),\n\t\t\t\t\"scheme\": getattr(request, \"scheme\", \"NOTFOUND\"),\n\t\t\t\t\"http_status_code\": getattr(response, \"status_code\", \"NOTFOUND\"),\n\t\t\t}\n\t\t)\n\n\ndef process_response(response):\n\tif not response:\n\t\treturn\n\n\t# set cookies\n\tif hasattr(frappe.local, \"cookie_manager\"):\n\t\tfrappe.local.cookie_manager.flush_cookies(response=response)\n\n\t# rate limiter headers\n\tif hasattr(frappe.local, \"rate_limiter\"):\n\t\tresponse.headers.extend(frappe.local.rate_limiter.headers())\n\n\t# CORS headers\n\tif hasattr(frappe.local, \"conf\") and frappe.conf.allow_cors:\n\t\tset_cors_headers(response)\n\n\ndef set_cors_headers(response):\n\torigin = frappe.request.headers.get(\"Origin\")\n\tallow_cors = frappe.conf.allow_cors\n\tif not (origin and allow_cors):\n\t\treturn\n\n\tif allow_cors != \"*\":\n\t\tif not isinstance(allow_cors, list):\n\t\t\tallow_cors = [allow_cors]\n\n\t\tif origin not in allow_cors:\n\t\t\treturn\n\n\tresponse.headers.extend(\n\t\t{\n\t\t\t\"Access-Control-Allow-Origin\": origin,\n\t\t\t\"Access-Control-Allow-Credentials\": \"true\",\n\t\t\t\"Access-Control-Allow-Methods\": \"GET, POST, PUT, DELETE, OPTIONS\",\n\t\t\t\"Access-Control-Allow-Headers\": (\n\t\t\t\t\"Authorization,DNT,X-Mx-ReqToken,\"\n\t\t\t\t\"Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,\"\n\t\t\t\t\"Cache-Control,Content-Type\"\n\t\t\t),\n\t\t}\n\t)\n\n\ndef make_form_dict(request):\n\timport json\n\n\trequest_data = request.get_data(as_text=True)\n\tif \"application/json\" in (request.content_type or \"\") and request_data:\n\t\targs = json.loads(request_data)\n\telse:\n\t\targs = {}\n\t\targs.update(request.args or {})\n\t\targs.update(request.form or {})\n\n\tif not isinstance(args, dict):\n\t\tfrappe.throw(\"Invalid request arguments\")\n\n\ttry:\n\t\tfrappe.local.form_dict = frappe._dict(\n\t\t\t{k: v[0] if isinstance(v, (list, tuple)) else v for k, v in iteritems(args)}\n\t\t)\n\texcept IndexError:\n\t\tfrappe.local.form_dict = frappe._dict(args)\n\n\tif \"_\" in frappe.local.form_dict:\n\t\t# _ is passed by $.ajax so that the request is not cached by the browser. So, remove _ from form_dict\n\t\tfrappe.local.form_dict.pop(\"_\")\n\n\ndef handle_exception(e):\n\tresponse = None\n\thttp_status_code = getattr(e, \"http_status_code\", 500)\n\treturn_as_message = False\n\taccept_header = frappe.get_request_header(\"Accept\") or \"\"\n\trespond_as_json = (\n\t\tfrappe.get_request_header(\"Accept\")\n\t\tand (frappe.local.is_ajax or \"application/json\" in accept_header)\n\t\tor (frappe.local.request.path.startswith(\"/api/\") and not accept_header.startswith(\"text\"))\n\t)\n\n\tif respond_as_json:\n\t\t# handle ajax responses first\n\t\t# if the request is ajax, send back the trace or error message\n\t\tresponse = frappe.utils.response.report_error(http_status_code)\n\n\telif (\n\t\thttp_status_code == 500\n\t\tand (frappe.db and isinstance(e, frappe.db.InternalError))\n\t\tand (frappe.db and (frappe.db.is_deadlocked(e) or frappe.db.is_timedout(e)))\n\t):\n\t\thttp_status_code = 508\n\n\telif http_status_code == 401:\n\t\tfrappe.respond_as_web_page(\n\t\t\t_(\"Session Expired\"),\n\t\t\t_(\"Your session has expired, please login again to continue.\"),\n\t\t\thttp_status_code=http_status_code,\n\t\t\tindicator_color=\"red\",\n\t\t)\n\t\treturn_as_message = True\n\n\telif http_status_code == 403:\n\t\tfrappe.respond_as_web_page(\n\t\t\t_(\"Not Permitted\"),\n\t\t\t_(\"You do not have enough permissions to complete the action\"),\n\t\t\thttp_status_code=http_status_code,\n\t\t\tindicator_color=\"red\",\n\t\t)\n\t\treturn_as_message = True\n\n\telif http_status_code == 404:\n\t\tfrappe.respond_as_web_page(\n\t\t\t_(\"Not Found\"),\n\t\t\t_(\"The resource you are looking for is not available\"),\n\t\t\thttp_status_code=http_status_code,\n\t\t\tindicator_color=\"red\",\n\t\t)\n\t\treturn_as_message = True\n\n\telif http_status_code == 429:\n\t\tresponse = frappe.rate_limiter.respond()\n\n\telse:\n\t\ttraceback = \"<pre>\" + escape_html(frappe.get_traceback()) + \"</pre>\"\n\t\t# disable traceback in production if flag is set\n\t\tif frappe.local.flags.disable_traceback and not frappe.local.dev_server:\n\t\t\ttraceback = \"\"\n\n\t\tfrappe.respond_as_web_page(\n\t\t\t\"Server Error\", traceback, http_status_code=http_status_code, indicator_color=\"red\", width=640\n\t\t)\n\t\treturn_as_message = True\n\n\tif e.__class__ == frappe.AuthenticationError:\n\t\tif hasattr(frappe.local, \"login_manager\"):\n\t\t\tfrappe.local.login_manager.clear_cookies()\n\n\tif http_status_code >= 500:\n\t\tmake_error_snapshot(e)\n\n\tif return_as_message:\n\t\tresponse = frappe.website.render.render(\"message\", http_status_code=http_status_code)\n\n\tif frappe.conf.get(\"developer_mode\") and not respond_as_json:\n\t\t# don't fail silently for non-json response errors\n\t\tprint(frappe.get_traceback())\n\n\treturn response\n\n\ndef after_request(rollback):\n\tif (frappe.local.request.method in (\"POST\", \"PUT\") or frappe.local.flags.commit) and frappe.db:\n\t\tif frappe.db.transaction_writes:\n\t\t\tfrappe.db.commit()\n\t\t\trollback = False\n\n\t# update session\n\tif getattr(frappe.local, \"session_obj\", None):\n\t\tupdated_in_db = frappe.local.session_obj.update()\n\t\tif updated_in_db:\n\t\t\tfrappe.db.commit()\n\t\t\trollback = False\n\n\tupdate_comments_in_parent_after_request()\n\n\treturn rollback\n\n\napplication = local_manager.make_middleware(application)\n\n\ndef serve(\n\tport=8000, profile=False, no_reload=False, no_threading=False, site=None, sites_path=\".\"\n):\n\tglobal application, _site, _sites_path\n\t_site = site\n\t_sites_path = sites_path\n\n\tfrom werkzeug.serving import run_simple\n\n\tpatch_werkzeug_reloader()\n\n\tif profile:\n\t\tapplication = ProfilerMiddleware(application, sort_by=(\"cumtime\", \"calls\"))\n\n\tif not os.environ.get(\"NO_STATICS\"):\n\t\tapplication = SharedDataMiddleware(\n\t\t\tapplication, {str(\"/assets\"): str(os.path.join(sites_path, \"assets\"))}\n\t\t)\n\n\t\tapplication = StaticDataMiddleware(\n\t\t\tapplication, {str(\"/files\"): str(os.path.abspath(sites_path))}\n\t\t)\n\n\tapplication.debug = True\n\tapplication.config = {\"SERVER_NAME\": \"localhost:8000\"}\n\n\tlog = logging.getLogger(\"werkzeug\")\n\tlog.propagate = False\n\n\tin_test_env = os.environ.get(\"CI\")\n\tif in_test_env:\n\t\tlog.setLevel(logging.ERROR)\n\n\trun_simple(\n\t\t\"0.0.0.0\",\n\t\tint(port),\n\t\tapplication,\n\t\tuse_reloader=False if in_test_env else not no_reload,\n\t\tuse_debugger=not in_test_env,\n\t\tuse_evalex=not in_test_env,\n\t\tthreaded=not no_threading,\n\t)\n\n\ndef patch_werkzeug_reloader():\n\t\"\"\"\n\tThis function monkey patches Werkzeug reloader to ignore reloading files in\n\tthe __pycache__ directory.\n\n\tTo be deprecated when upgrading to Werkzeug 2.\n\t\"\"\"\n\n\tfrom werkzeug._reloader import WatchdogReloaderLoop\n\n\ttrigger_reload = WatchdogReloaderLoop.trigger_reload\n\n\tdef custom_trigger_reload(self, filename):\n\t\tif os.path.basename(os.path.dirname(filename)) == \"__pycache__\":\n\t\t\treturn\n\n\t\treturn trigger_reload(self, filename)\n\n\tWatchdogReloaderLoop.trigger_reload = custom_trigger_reload\n"], "filenames": ["frappe/app.py"], "buggy_code_start_loc": [28], "buggy_code_end_loc": [287], "fixing_code_start_loc": [28], "fixing_code_end_loc": [287], "type": "CWE-79", "message": "Frappe is a full-stack web application framework that uses Python and MariaDB on the server side and an integrated client side library. A malicious Frappe user with desk access could create documents containing HTML payloads allowing HTML Injection. This vulnerability has been patched in version 14.49.0.", "other": {"cve": {"id": "CVE-2023-46127", "sourceIdentifier": "security-advisories@github.com", "published": "2023-10-23T15:15:09.313", "lastModified": "2023-10-31T12:17:17.793", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Frappe is a full-stack web application framework that uses Python and MariaDB on the server side and an integrated client side library. A malicious Frappe user with desk access could create documents containing HTML payloads allowing HTML Injection. This vulnerability has been patched in version 14.49.0."}, {"lang": "es", "value": "Frappe es un framework de aplicaci\u00f3n web completo que utiliza Python y MariaDB en el lado del servidor y una librer\u00eda integrada en el lado del cliente. Un usuario malicioso de Frappe con acceso al escritorio podr\u00eda crear documentos que contengan cargas HTML que permitan la inyecci\u00f3n de HTML. Esta vulnerabilidad ha sido parcheada en la versi\u00f3n 14.49.0."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.5}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:frappe:frappe:*:*:*:*:*:*:*:*", "versionEndExcluding": "14.49.0", "matchCriteriaId": "94A420A9-14D7-4416-96EC-AF18CD78BF09"}]}]}], "references": [{"url": "https://github.com/frappe/frappe/commit/3dc5d2fcc7561dde181ba953009fe6e39d64e900", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/frappe/frappe/pull/22339", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/frappe/frappe/security/advisories/GHSA-j2w9-8xrr-7g98", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/frappe/frappe/commit/3dc5d2fcc7561dde181ba953009fe6e39d64e900"}}