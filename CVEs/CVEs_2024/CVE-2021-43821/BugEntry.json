{"buggy_code": ["/**\n * Licensed to The Apereo Foundation under one or more contributor license\n * agreements. See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n *\n * The Apereo Foundation licenses this file to you under the Educational\n * Community License, Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of the License\n * at:\n *\n *   http://opensource.org/licenses/ecl2.txt\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n * License for the specific language governing permissions and limitations under\n * the License.\n *\n */\n\npackage org.opencastproject.ingest.impl;\n\nimport static org.apache.commons.lang3.StringUtils.isBlank;\nimport static org.opencastproject.util.JobUtil.waitForJob;\nimport static org.opencastproject.util.data.Monadics.mlist;\nimport static org.opencastproject.util.data.Option.none;\n\nimport org.opencastproject.capture.CaptureParameters;\nimport org.opencastproject.ingest.api.IngestException;\nimport org.opencastproject.ingest.api.IngestService;\nimport org.opencastproject.ingest.impl.jmx.IngestStatistics;\nimport org.opencastproject.inspection.api.MediaInspectionService;\nimport org.opencastproject.job.api.AbstractJobProducer;\nimport org.opencastproject.job.api.Job;\nimport org.opencastproject.job.api.Job.Status;\nimport org.opencastproject.mediapackage.EName;\nimport org.opencastproject.mediapackage.MediaPackage;\nimport org.opencastproject.mediapackage.MediaPackageBuilderFactory;\nimport org.opencastproject.mediapackage.MediaPackageElement;\nimport org.opencastproject.mediapackage.MediaPackageElementFlavor;\nimport org.opencastproject.mediapackage.MediaPackageElementParser;\nimport org.opencastproject.mediapackage.MediaPackageElements;\nimport org.opencastproject.mediapackage.MediaPackageException;\nimport org.opencastproject.mediapackage.MediaPackageParser;\nimport org.opencastproject.mediapackage.MediaPackageSupport;\nimport org.opencastproject.mediapackage.Track;\nimport org.opencastproject.mediapackage.identifier.IdImpl;\nimport org.opencastproject.metadata.dublincore.DCMIPeriod;\nimport org.opencastproject.metadata.dublincore.DublinCore;\nimport org.opencastproject.metadata.dublincore.DublinCoreCatalog;\nimport org.opencastproject.metadata.dublincore.DublinCoreCatalogService;\nimport org.opencastproject.metadata.dublincore.DublinCoreValue;\nimport org.opencastproject.metadata.dublincore.EncodingSchemeUtils;\nimport org.opencastproject.scheduler.api.SchedulerException;\nimport org.opencastproject.scheduler.api.SchedulerService;\nimport org.opencastproject.security.api.OrganizationDirectoryService;\nimport org.opencastproject.security.api.SecurityService;\nimport org.opencastproject.security.api.TrustedHttpClient;\nimport org.opencastproject.security.api.UnauthorizedException;\nimport org.opencastproject.security.api.UserDirectoryService;\nimport org.opencastproject.series.api.SeriesService;\nimport org.opencastproject.serviceregistry.api.ServiceRegistry;\nimport org.opencastproject.serviceregistry.api.ServiceRegistryException;\nimport org.opencastproject.smil.api.util.SmilUtil;\nimport org.opencastproject.util.ConfigurationException;\nimport org.opencastproject.util.IoSupport;\nimport org.opencastproject.util.LoadUtil;\nimport org.opencastproject.util.MimeTypes;\nimport org.opencastproject.util.NotFoundException;\nimport org.opencastproject.util.ProgressInputStream;\nimport org.opencastproject.util.XmlSafeParser;\nimport org.opencastproject.util.XmlUtil;\nimport org.opencastproject.util.data.Function;\nimport org.opencastproject.util.data.Option;\nimport org.opencastproject.util.data.functions.Misc;\nimport org.opencastproject.util.jmx.JmxUtil;\nimport org.opencastproject.workflow.api.WorkflowDatabaseException;\nimport org.opencastproject.workflow.api.WorkflowDefinition;\nimport org.opencastproject.workflow.api.WorkflowException;\nimport org.opencastproject.workflow.api.WorkflowInstance;\nimport org.opencastproject.workflow.api.WorkflowService;\nimport org.opencastproject.workingfilerepository.api.WorkingFileRepository;\n\nimport com.entwinemedia.fn.Stream;\nimport com.entwinemedia.fn.data.Opt;\nimport com.google.common.cache.Cache;\nimport com.google.common.cache.CacheBuilder;\n\nimport org.apache.commons.compress.archivers.zip.ZipArchiveEntry;\nimport org.apache.commons.compress.archivers.zip.ZipArchiveInputStream;\nimport org.apache.commons.io.FilenameUtils;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang3.BooleanUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.cxf.jaxrs.ext.multipart.ContentDisposition;\nimport org.apache.http.Header;\nimport org.apache.http.HttpResponse;\nimport org.apache.http.auth.AuthScope;\nimport org.apache.http.auth.UsernamePasswordCredentials;\nimport org.apache.http.client.CredentialsProvider;\nimport org.apache.http.client.config.AuthSchemes;\nimport org.apache.http.client.methods.HttpGet;\nimport org.apache.http.impl.client.BasicCredentialsProvider;\nimport org.apache.http.impl.client.CloseableHttpClient;\nimport org.apache.http.impl.client.HttpClientBuilder;\nimport org.osgi.service.cm.ManagedService;\nimport org.osgi.service.component.ComponentContext;\nimport org.osgi.service.component.annotations.Activate;\nimport org.osgi.service.component.annotations.Component;\nimport org.osgi.service.component.annotations.Deactivate;\nimport org.osgi.service.component.annotations.Reference;\nimport org.osgi.service.component.annotations.ReferenceCardinality;\nimport org.osgi.service.component.annotations.ReferencePolicy;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.xml.sax.SAXException;\n\nimport java.beans.PropertyChangeEvent;\nimport java.beans.PropertyChangeListener;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.URI;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Arrays;\nimport java.util.Date;\nimport java.util.Dictionary;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.concurrent.TimeUnit;\nimport java.util.stream.Collectors;\n\nimport javax.management.ObjectInstance;\n\n/**\n * Creates and augments Opencast MediaPackages. Stores media into the Working File Repository.\n */\n@Component(\n  immediate = true,\n  service = {\n    IngestService.class,\n    ManagedService.class\n  },\n  property = {\n    \"service.description=Ingest Service\",\n    \"service.pid=org.opencastproject.ingest.impl.IngestServiceImpl\"\n  }\n)\npublic class IngestServiceImpl extends AbstractJobProducer implements IngestService, ManagedService {\n\n  /** The logger */\n  private static final Logger logger = LoggerFactory.getLogger(IngestServiceImpl.class);\n\n  /** The source SMIL name */\n  private static final String PARTIAL_SMIL_NAME = \"source_partial.smil\";\n\n  /** The configuration key that defines the default workflow definition */\n  protected static final String WORKFLOW_DEFINITION_DEFAULT = \"org.opencastproject.workflow.default.definition\";\n\n  /** The workflow configuration property prefix **/\n  protected static final String WORKFLOW_CONFIGURATION_PREFIX = \"org.opencastproject.workflow.config.\";\n\n  /** The key for the legacy mediapackage identifier */\n  public static final String LEGACY_MEDIAPACKAGE_ID_KEY = \"org.opencastproject.ingest.legacy.mediapackage.id\";\n\n  public static final String JOB_TYPE = \"org.opencastproject.ingest\";\n\n  /** Methods that ingest zips create jobs with this operation type */\n  public static final String INGEST_ZIP = \"zip\";\n\n  /** Methods that ingest tracks directly create jobs with this operation type */\n  public static final String INGEST_TRACK = \"track\";\n\n  /** Methods that ingest tracks from a URI create jobs with this operation type */\n  public static final String INGEST_TRACK_FROM_URI = \"uri-track\";\n\n  /** Methods that ingest attachments directly create jobs with this operation type */\n  public static final String INGEST_ATTACHMENT = \"attachment\";\n\n  /** Methods that ingest attachments from a URI create jobs with this operation type */\n  public static final String INGEST_ATTACHMENT_FROM_URI = \"uri-attachment\";\n\n  /** Methods that ingest catalogs directly create jobs with this operation type */\n  public static final String INGEST_CATALOG = \"catalog\";\n\n  /** Methods that ingest catalogs from a URI create jobs with this operation type */\n  public static final String INGEST_CATALOG_FROM_URI = \"uri-catalog\";\n\n  /** The approximate load placed on the system by ingesting a file */\n  public static final float DEFAULT_INGEST_FILE_JOB_LOAD = 0.2f;\n\n  /** The approximate load placed on the system by ingesting a zip file */\n  public static final float DEFAULT_INGEST_ZIP_JOB_LOAD = 0.2f;\n\n  /** The key to look for in the service configuration file to override the {@link DEFAULT_INGEST_FILE_JOB_LOAD} */\n  public static final String FILE_JOB_LOAD_KEY = \"job.load.ingest.file\";\n\n  /** The key to look for in the service configuration file to override the {@link DEFAULT_INGEST_ZIP_JOB_LOAD} */\n  public static final String ZIP_JOB_LOAD_KEY = \"job.load.ingest.zip\";\n\n  /** The source to download from  */\n  public static final String DOWNLOAD_SOURCE = \"org.opencastproject.download.source\";\n\n  /** The user for download from external sources */\n  public static final String DOWNLOAD_USER = \"org.opencastproject.download.user\";\n\n  /** The password for download from external sources */\n  public static final String DOWNLOAD_PASSWORD = \"org.opencastproject.download.password\";\n\n  /** By default, do not allow event ingest to modify existing series metadata */\n  public static final boolean DEFAULT_ALLOW_SERIES_MODIFICATIONS = false;\n\n  /** The default is to preserve existing Opencast flavors during ingest. */\n  public static final boolean DEFAULT_ALLOW_ONLY_NEW_FLAVORS = true;\n\n  /** The default is not to automatically skip attachments and catalogs from capture agent */\n  public static final boolean DEFAULT_SKIP = false;\n\n  /** The maximum length of filenames ingested by Opencast */\n  public static final int FILENAME_LENGTH_MAX = 75;\n\n  /** Managed Property key to allow Opencast series modification during ingest\n   * Deprecated, the param potentially causes an update chain reaction for all\n   * events associated to that series, for each ingest */\n  @Deprecated\n  public static final String MODIFY_OPENCAST_SERIES_KEY = \"org.opencastproject.series.overwrite\";\n\n  /** Managed Property key to allow new flavors of ingested attachments and catalogs\n   * to be added to the existing Opencast mediapackage. But, not catalogs and attachments\n   * that would overwrite existing ones in Opencast.\n   */\n  public static final String ADD_ONLY_NEW_FLAVORS_KEY = \"add.only.new.catalogs.attachments.for.existing.events\";\n\n  /** Control if catalogs sent by capture agents for scheduled events are skipped. */\n  public static final String SKIP_CATALOGS_KEY = \"skip.catalogs.for.existing.events\";\n\n  /** Control if attachments sent by capture agents for scheduled events are skipped. */\n  public static final String SKIP_ATTACHMENTS_KEY = \"skip.attachments.for.existing.events\";\n\n  /** The approximate load placed on the system by ingesting a file */\n  private float ingestFileJobLoad = DEFAULT_INGEST_FILE_JOB_LOAD;\n\n  /** The approximate load placed on the system by ingesting a zip file */\n  private float ingestZipJobLoad = DEFAULT_INGEST_ZIP_JOB_LOAD;\n\n  /** The user for download from external sources */\n  private static String downloadUser = DOWNLOAD_USER;\n\n  /** The password for download from external sources */\n  private static String downloadPassword = DOWNLOAD_PASSWORD;\n\n  /** The external source dns name */\n  private static String downloadSource = DOWNLOAD_SOURCE;\n\n  /** The JMX business object for ingest statistics */\n  private IngestStatistics ingestStatistics = new IngestStatistics();\n\n  /** The JMX bean object instance */\n  private ObjectInstance registerMXBean;\n\n  /** The workflow service */\n  private WorkflowService workflowService;\n\n  /** The working file repository */\n  private WorkingFileRepository workingFileRepository;\n\n  /** The http client */\n  private TrustedHttpClient httpClient;\n\n  /** The series service */\n  private SeriesService seriesService;\n\n  /** The dublin core service */\n  private DublinCoreCatalogService dublinCoreService;\n\n  /** The opencast service registry */\n  private ServiceRegistry serviceRegistry;\n\n  /** The security service */\n  protected SecurityService securityService = null;\n\n  /** The user directory service */\n  protected UserDirectoryService userDirectoryService = null;\n\n  /** The organization directory service */\n  protected OrganizationDirectoryService organizationDirectoryService = null;\n\n  /** The scheduler service */\n  private SchedulerService schedulerService = null;\n\n  /** The media inspection service */\n  private MediaInspectionService mediaInspectionService = null;\n\n  /** The default workflow identifier, if one is configured */\n  protected String defaultWorkflowDefinionId;\n\n  /** The partial track start time map */\n  private Cache<String, Long> partialTrackStartTimes = CacheBuilder.newBuilder().expireAfterWrite(1, TimeUnit.DAYS)\n          .build();\n\n  /** Option to overwrite matching flavors (e.g. series and episode metadata) on ingest,\n   *  tracks are always taken on ingest */\n  protected boolean isAddOnlyNew = DEFAULT_ALLOW_ONLY_NEW_FLAVORS;\n  protected boolean isAllowModifySeries = DEFAULT_ALLOW_SERIES_MODIFICATIONS;\n\n  private boolean skipCatalogs = DEFAULT_SKIP;\n  private boolean skipAttachments = DEFAULT_SKIP;\n\n  /**\n   * Creates a new ingest service instance.\n   */\n  public IngestServiceImpl() {\n    super(JOB_TYPE);\n  }\n\n  /**\n   * OSGI callback for activating this component\n   *\n   * @param cc\n   *          the osgi component context\n   */\n  @Override\n  @Activate\n  public void activate(ComponentContext cc) {\n    super.activate(cc);\n    logger.info(\"Ingest Service started.\");\n    defaultWorkflowDefinionId = StringUtils.trimToNull(cc.getBundleContext().getProperty(WORKFLOW_DEFINITION_DEFAULT));\n    if (defaultWorkflowDefinionId == null) {\n      defaultWorkflowDefinionId = \"schedule-and-upload\";\n    }\n    registerMXBean = JmxUtil.registerMXBean(ingestStatistics, \"IngestStatistics\");\n  }\n\n  /**\n   * Callback from OSGi on service deactivation.\n   */\n  @Deactivate\n  public void deactivate() {\n    JmxUtil.unregisterMXBean(registerMXBean);\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.osgi.service.cm.ManagedService#updated(java.util.Dictionary)\n   *      Retrieve ManagedService configuration, including option to overwrite series\n   */\n  @Override\n  public void updated(Dictionary<String, ?> properties) throws ConfigurationException {\n\n    if (properties == null) {\n      logger.info(\"No configuration available, using defaults\");\n      return;\n    }\n\n    downloadPassword = StringUtils.trimToEmpty((String)properties.get(DOWNLOAD_PASSWORD));\n    downloadUser = StringUtils.trimToEmpty(((String) properties.get(DOWNLOAD_USER)));\n    downloadSource = StringUtils.trimToEmpty(((String) properties.get(DOWNLOAD_SOURCE)));\n\n    skipAttachments = BooleanUtils.toBoolean(Objects.toString(properties.get(SKIP_ATTACHMENTS_KEY),\n            BooleanUtils.toStringTrueFalse(DEFAULT_SKIP)));\n    skipCatalogs = BooleanUtils.toBoolean(Objects.toString(properties.get(SKIP_CATALOGS_KEY),\n            BooleanUtils.toStringTrueFalse(DEFAULT_SKIP)));\n    logger.debug(\"Skip attachments sent by agents for scheduled events: {}\", skipAttachments);\n    logger.debug(\"Skip metadata catalogs sent by agents for scheduled events: {}\", skipCatalogs);\n\n    ingestFileJobLoad = LoadUtil.getConfiguredLoadValue(properties, FILE_JOB_LOAD_KEY, DEFAULT_INGEST_FILE_JOB_LOAD,\n            serviceRegistry);\n    ingestZipJobLoad = LoadUtil.getConfiguredLoadValue(properties, ZIP_JOB_LOAD_KEY, DEFAULT_INGEST_ZIP_JOB_LOAD,\n            serviceRegistry);\n\n    isAllowModifySeries = BooleanUtils.toBoolean(Objects.toString(properties.get(MODIFY_OPENCAST_SERIES_KEY),\n              BooleanUtils.toStringTrueFalse(DEFAULT_ALLOW_SERIES_MODIFICATIONS)));\n    isAddOnlyNew = BooleanUtils.toBoolean(Objects.toString(properties.get(ADD_ONLY_NEW_FLAVORS_KEY),\n            BooleanUtils.toStringTrueFalse(DEFAULT_ALLOW_ONLY_NEW_FLAVORS)));\n    logger.info(\"Only allow new flavored catalogs and attachments on ingest:'{}'\", isAddOnlyNew);\n    logger.info(\"Allowing series modification:'{}'\", isAllowModifySeries);\n  }\n\n  /**\n   * Sets the trusted http client\n   *\n   * @param httpClient\n   *          the http client\n   */\n  @Reference\n  public void setHttpClient(TrustedHttpClient httpClient) {\n    this.httpClient = httpClient;\n  }\n\n  /**\n   * Sets the service registry\n   *\n   * @param serviceRegistry\n   *          the serviceRegistry to set\n   */\n  @Reference\n  public void setServiceRegistry(ServiceRegistry serviceRegistry) {\n    this.serviceRegistry = serviceRegistry;\n  }\n\n  /**\n   * Sets the media inspection service\n   *\n   * @param mediaInspectionService\n   *          the media inspection service to set\n   */\n  @Reference\n  public void setMediaInspectionService(MediaInspectionService mediaInspectionService) {\n    this.mediaInspectionService = mediaInspectionService;\n  }\n\n  public WorkflowInstance addZippedMediaPackage(InputStream zipStream)\n          throws IngestException, IOException, MediaPackageException {\n    try {\n      return addZippedMediaPackage(zipStream, null, null);\n    } catch (NotFoundException e) {\n      throw new IllegalStateException(\"A not found exception was thrown without a lookup\");\n    }\n  }\n\n  @Override\n  public WorkflowInstance addZippedMediaPackage(InputStream zipStream, String wd, Map<String, String> workflowConfig)\n          throws MediaPackageException, IOException, IngestException, NotFoundException {\n    try {\n      return addZippedMediaPackage(zipStream, wd, workflowConfig, null);\n    } catch (UnauthorizedException e) {\n      throw new IllegalStateException(e);\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#addZippedMediaPackage(java.io.InputStream, java.lang.String,\n   *      java.util.Map, java.lang.Long)\n   */\n  @Override\n  public WorkflowInstance addZippedMediaPackage(InputStream zipStream, String workflowDefinitionId,\n          Map<String, String> workflowConfig, Long workflowInstanceId)\n          throws MediaPackageException, IOException, IngestException, NotFoundException, UnauthorizedException {\n    // Start a job synchronously. We can't keep the open input stream waiting around.\n    Job job = null;\n\n    if (StringUtils.isNotBlank(workflowDefinitionId)) {\n      try {\n        workflowService.getWorkflowDefinitionById(workflowDefinitionId);\n      } catch (WorkflowDatabaseException e) {\n        throw new IngestException(e);\n      } catch (NotFoundException nfe) {\n        logger.warn(\"Workflow definition {} not found, using default workflow {} instead\", workflowDefinitionId,\n                defaultWorkflowDefinionId);\n        workflowDefinitionId = defaultWorkflowDefinionId;\n      }\n    }\n\n    if (workflowInstanceId != null) {\n      logger.warn(\"Deprecated method! Ingesting zipped mediapackage with workflow {}\", workflowInstanceId);\n    } else {\n      logger.info(\"Ingesting zipped mediapackage\");\n    }\n\n    ZipArchiveInputStream zis = null;\n    Set<String> collectionFilenames = new HashSet<>();\n    try {\n      // We don't need anybody to do the dispatching for us. Therefore we need to make sure that the job is never in\n      // QUEUED state but set it to INSTANTIATED in the beginning and then manually switch it to RUNNING.\n      job = serviceRegistry.createJob(JOB_TYPE, INGEST_ZIP, null, null, false, ingestZipJobLoad);\n      job.setStatus(Status.RUNNING);\n      job = serviceRegistry.updateJob(job);\n\n      // Create the working file target collection for this ingest operation\n      String wfrCollectionId = Long.toString(job.getId());\n\n      zis = new ZipArchiveInputStream(zipStream);\n      ZipArchiveEntry entry;\n      MediaPackage mp = null;\n      Map<String, URI> uris = new HashMap<>();\n      // Sequential number to append to file names so that, if two files have the same\n      // name, one does not overwrite the other (see MH-9688)\n      int seq = 1;\n      // Folder name to compare with next one to figure out if there's a root folder\n      String folderName = null;\n      // Indicates if zip has a root folder or not, initialized as true\n      boolean hasRootFolder = true;\n      // While there are entries write them to a collection\n      while ((entry = zis.getNextZipEntry()) != null) {\n        try {\n          if (entry.isDirectory() || entry.getName().contains(\"__MACOSX\"))\n            continue;\n\n          if (entry.getName().endsWith(\"manifest.xml\") || entry.getName().endsWith(\"index.xml\")) {\n            // Build the media package\n            final InputStream is = new ZipEntryInputStream(zis, entry.getSize());\n            mp = MediaPackageParser.getFromXml(IOUtils.toString(is, StandardCharsets.UTF_8));\n          } else {\n            logger.info(\"Storing zip entry {}/{} in working file repository collection '{}'\", job.getId(),\n                    entry.getName(), wfrCollectionId);\n            // Since the directory structure is not being mirrored, makes sure the file\n            // name is different than the previous one(s) by adding a sequential number\n            String fileName = FilenameUtils.getBaseName(entry.getName()) + \"_\" + seq++ + \".\"\n                    + FilenameUtils.getExtension(entry.getName());\n            URI contentUri = workingFileRepository.putInCollection(wfrCollectionId, fileName,\n                    new ZipEntryInputStream(zis, entry.getSize()));\n            collectionFilenames.add(fileName);\n            // Key is the zip entry name as it is\n            String key = entry.getName();\n            uris.put(key, contentUri);\n            ingestStatistics.add(entry.getSize());\n            logger.info(\"Zip entry {}/{} stored at {}\", job.getId(), entry.getName(), contentUri);\n            // Figures out if there's a root folder. Does entry name starts with a folder?\n            int pos = entry.getName().indexOf('/');\n            if (pos == -1) {\n              // No, we can conclude there's no root folder\n              hasRootFolder = false;\n            } else if (hasRootFolder && folderName != null && !folderName.equals(entry.getName().substring(0, pos))) {\n              // Folder name different from previous so there's no root folder\n              hasRootFolder = false;\n            } else if (folderName == null) {\n              // Just initialize folder name\n              folderName = entry.getName().substring(0, pos);\n            }\n          }\n        } catch (IOException e) {\n          logger.warn(\"Unable to process zip entry {}: {}\", entry.getName(), e);\n          throw e;\n        }\n      }\n\n      if (mp == null)\n        throw new MediaPackageException(\"No manifest found in this zip\");\n\n      // Determine the mediapackage identifier\n      if (mp.getIdentifier() == null || isBlank(mp.getIdentifier().toString()))\n        mp.setIdentifier(IdImpl.fromUUID());\n\n      String mediaPackageId = mp.getIdentifier().toString();\n\n      logger.info(\"Ingesting mediapackage {} is named '{}'\", mediaPackageId, mp.getTitle());\n\n      // Make sure there are tracks in the mediapackage\n      if (mp.getTracks().length == 0) {\n        logger.warn(\"Mediapackage {} has no media tracks\", mediaPackageId);\n      }\n\n      // Update the element uris to point to their working file repository location\n      for (MediaPackageElement element : mp.elements()) {\n        // Key has root folder name if there is one\n        URI uri = uris.get((hasRootFolder ? folderName + \"/\" : \"\") + element.getURI().toString());\n\n        if (uri == null)\n          throw new MediaPackageException(\"Unable to map element name '\" + element.getURI() + \"' to workspace uri\");\n        logger.info(\"Ingested mediapackage element {}/{} located at {}\", mediaPackageId, element.getIdentifier(), uri);\n        URI dest = workingFileRepository.moveTo(wfrCollectionId, FilenameUtils.getName(uri.toString()), mediaPackageId,\n                element.getIdentifier(), FilenameUtils.getName(element.getURI().toString()));\n        element.setURI(dest);\n\n        // TODO: This should be triggered somehow instead of being handled here\n        if (MediaPackageElements.SERIES.equals(element.getFlavor())) {\n          logger.info(\"Ingested mediapackage {} contains updated series information\", mediaPackageId);\n          updateSeries(element.getURI());\n        }\n      }\n\n      // Now that all elements are in place, start with ingest\n      logger.info(\"Initiating processing of ingested mediapackage {}\", mediaPackageId);\n      WorkflowInstance workflowInstance = ingest(mp, workflowDefinitionId, workflowConfig, workflowInstanceId);\n      logger.info(\"Ingest of mediapackage {} done\", mediaPackageId);\n      job.setStatus(Job.Status.FINISHED);\n      return workflowInstance;\n    } catch (ServiceRegistryException e) {\n      throw new IngestException(e);\n    } catch (MediaPackageException e) {\n      job.setStatus(Job.Status.FAILED, Job.FailureReason.DATA);\n      throw e;\n    } catch (Exception e) {\n      if (e instanceof IngestException)\n        throw (IngestException) e;\n      throw new IngestException(e);\n    } finally {\n      IOUtils.closeQuietly(zis);\n      finallyUpdateJob(job);\n      for (String filename : collectionFilenames) {\n        workingFileRepository.deleteFromCollection(Long.toString(job.getId()), filename, true);\n      }\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#createMediaPackage()\n   */\n  @Override\n  public MediaPackage createMediaPackage() throws MediaPackageException, ConfigurationException {\n    MediaPackage mediaPackage;\n    try {\n      mediaPackage = MediaPackageBuilderFactory.newInstance().newMediaPackageBuilder().createNew();\n    } catch (MediaPackageException e) {\n      logger.error(\"INGEST:Failed to create media package \" + e.getLocalizedMessage());\n      throw e;\n    }\n    mediaPackage.setDate(new Date());\n    logger.info(\"Created mediapackage {}\", mediaPackage);\n    return mediaPackage;\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#createMediaPackage()\n   */\n  @Override\n  public MediaPackage createMediaPackage(String mediaPackageId)\n          throws MediaPackageException, ConfigurationException {\n    MediaPackage mediaPackage;\n    try {\n      mediaPackage = MediaPackageBuilderFactory.newInstance().newMediaPackageBuilder()\n              .createNew(new IdImpl(mediaPackageId));\n    } catch (MediaPackageException e) {\n      logger.error(\"INGEST:Failed to create media package \" + e.getLocalizedMessage());\n      throw e;\n    }\n    mediaPackage.setDate(new Date());\n    logger.info(\"Created mediapackage {}\", mediaPackage);\n    return mediaPackage;\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#addTrack(java.net.URI,\n   *      org.opencastproject.mediapackage.MediaPackageElementFlavor, org.opencastproject.mediapackage.MediaPackage)\n   */\n  @Override\n  public MediaPackage addTrack(URI uri, MediaPackageElementFlavor flavor, MediaPackage mediaPackage)\n          throws IOException, IngestException {\n    String[] tags = null;\n    return this.addTrack(uri, flavor, tags, mediaPackage);\n\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#addTrack(java.net.URI,\n   *      org.opencastproject.mediapackage.MediaPackageElementFlavor, String[] ,\n   *      org.opencastproject.mediapackage.MediaPackage)\n   */\n  @Override\n  public MediaPackage addTrack(URI uri, MediaPackageElementFlavor flavor, String[] tags, MediaPackage mediaPackage)\n          throws IOException, IngestException {\n    Job job = null;\n    try {\n      job = serviceRegistry\n              .createJob(\n                      JOB_TYPE, INGEST_TRACK_FROM_URI, Arrays.asList(uri.toString(),\n                              flavor == null ? null : flavor.toString(), MediaPackageParser.getAsXml(mediaPackage)),\n                      null, false, ingestFileJobLoad);\n      job.setStatus(Status.RUNNING);\n      job = serviceRegistry.updateJob(job);\n      String elementId = UUID.randomUUID().toString();\n      logger.info(\"Start adding track {} from URL {} on mediapackage {}\", elementId, uri, mediaPackage);\n      URI newUrl = addContentToRepo(mediaPackage, elementId, uri);\n      MediaPackage mp = addContentToMediaPackage(mediaPackage, elementId, newUrl, MediaPackageElement.Type.Track,\n              flavor);\n      if (tags != null && tags.length > 0) {\n        MediaPackageElement trackElement = mp.getTrack(elementId);\n        for (String tag : tags) {\n          logger.info(\"Adding Tag: \" + tag + \" to Element: \" + elementId);\n          trackElement.addTag(tag);\n        }\n      }\n\n      job.setStatus(Job.Status.FINISHED);\n      logger.info(\"Successful added track {} on mediapackage {} at URL {}\", elementId, mediaPackage, newUrl);\n      return mp;\n    } catch (IOException e) {\n      throw e;\n    } catch (ServiceRegistryException e) {\n      throw new IngestException(e);\n    } catch (NotFoundException e) {\n      throw new IngestException(\"Unable to update ingest job\", e);\n    } finally {\n      finallyUpdateJob(job);\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#addTrack(java.io.InputStream, java.lang.String,\n   *      org.opencastproject.mediapackage.MediaPackageElementFlavor, org.opencastproject.mediapackage.MediaPackage)\n   */\n  @Override\n  public MediaPackage addTrack(InputStream in, String fileName, MediaPackageElementFlavor flavor,\n          MediaPackage mediaPackage) throws IOException, IngestException {\n    String[] tags = null;\n    return this.addTrack(in, fileName, flavor, tags, mediaPackage);\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#addTrack(java.io.InputStream, java.lang.String,\n   *      org.opencastproject.mediapackage.MediaPackageElementFlavor, org.opencastproject.mediapackage.MediaPackage)\n   */\n  @Override\n  public MediaPackage addTrack(InputStream in, String fileName, MediaPackageElementFlavor flavor, String[] tags,\n          MediaPackage mediaPackage) throws IOException, IngestException {\n    Job job = null;\n    try {\n      job = serviceRegistry.createJob(JOB_TYPE, INGEST_TRACK, null, null, false, ingestFileJobLoad);\n      job.setStatus(Status.RUNNING);\n      job = serviceRegistry.updateJob(job);\n      String elementId = UUID.randomUUID().toString();\n      logger.info(\"Start adding track {} from input stream on mediapackage {}\", elementId, mediaPackage);\n      if (fileName.length() > FILENAME_LENGTH_MAX) {\n        final String extension = \".\" + FilenameUtils.getExtension(fileName);\n        final int length = Math.max(0, FILENAME_LENGTH_MAX - extension.length());\n        fileName = fileName.substring(0, length) + extension;\n      }\n      URI newUrl = addContentToRepo(mediaPackage, elementId, fileName, in);\n      MediaPackage mp = addContentToMediaPackage(mediaPackage, elementId, newUrl, MediaPackageElement.Type.Track,\n              flavor);\n      if (tags != null && tags.length > 0) {\n        MediaPackageElement trackElement = mp.getTrack(elementId);\n        for (String tag : tags) {\n          logger.debug(\"Adding tag `{}` to element {}\", tag, elementId);\n          trackElement.addTag(tag);\n        }\n      }\n\n      job.setStatus(Job.Status.FINISHED);\n      logger.info(\"Successful added track {} on mediapackage {} at URL {}\", elementId, mediaPackage, newUrl);\n      return mp;\n    } catch (IOException e) {\n      throw e;\n    } catch (ServiceRegistryException e) {\n      throw new IngestException(e);\n    } catch (NotFoundException e) {\n      throw new IngestException(\"Unable to update ingest job\", e);\n    } finally {\n      finallyUpdateJob(job);\n    }\n  }\n\n  @Override\n  public MediaPackage addPartialTrack(URI uri, MediaPackageElementFlavor flavor, long startTime,\n          MediaPackage mediaPackage) throws IOException, IngestException {\n    Job job = null;\n    try {\n      job = serviceRegistry.createJob(\n              JOB_TYPE,\n              INGEST_TRACK_FROM_URI,\n              Arrays.asList(uri.toString(), flavor == null ? null : flavor.toString(),\n                      MediaPackageParser.getAsXml(mediaPackage)), null, false);\n      job.setStatus(Status.RUNNING);\n      job = serviceRegistry.updateJob(job);\n      String elementId = UUID.randomUUID().toString();\n      logger.info(\"Start adding partial track {} from URL {} on mediapackage {}\", elementId, uri, mediaPackage);\n      URI newUrl = addContentToRepo(mediaPackage, elementId, uri);\n      MediaPackage mp = addContentToMediaPackage(mediaPackage, elementId, newUrl, MediaPackageElement.Type.Track,\n              flavor);\n      job.setStatus(Job.Status.FINISHED);\n      // store startTime\n      partialTrackStartTimes.put(elementId, startTime);\n      logger.debug(\"Added start time {} for track {}\", startTime, elementId);\n      logger.info(\"Successful added partial track {} on mediapackage {} at URL {}\", elementId, mediaPackage, newUrl);\n      return mp;\n    } catch (ServiceRegistryException e) {\n      throw new IngestException(e);\n    } catch (NotFoundException e) {\n      throw new IngestException(\"Unable to update ingest job\", e);\n    } finally {\n      finallyUpdateJob(job);\n    }\n  }\n\n  @Override\n  public MediaPackage addPartialTrack(InputStream in, String fileName, MediaPackageElementFlavor flavor, long startTime,\n          MediaPackage mediaPackage) throws IOException, IngestException {\n    Job job = null;\n    try {\n      job = serviceRegistry.createJob(JOB_TYPE, INGEST_TRACK, null, null, false);\n      job.setStatus(Status.RUNNING);\n      job = serviceRegistry.updateJob(job);\n      String elementId = UUID.randomUUID().toString();\n      logger.info(\"Start adding partial track {} from input stream on mediapackage {}\", elementId, mediaPackage);\n      URI newUrl = addContentToRepo(mediaPackage, elementId, fileName, in);\n      MediaPackage mp = addContentToMediaPackage(mediaPackage, elementId, newUrl, MediaPackageElement.Type.Track,\n              flavor);\n      job.setStatus(Job.Status.FINISHED);\n      // store startTime\n      partialTrackStartTimes.put(elementId, startTime);\n      logger.debug(\"Added start time {} for track {}\", startTime, elementId);\n      logger.info(\"Successful added partial track {} on mediapackage {} at URL {}\", elementId, mediaPackage, newUrl);\n      return mp;\n    } catch (ServiceRegistryException e) {\n      throw new IngestException(e);\n    } catch (NotFoundException e) {\n      throw new IngestException(\"Unable to update ingest job\", e);\n    } finally {\n      finallyUpdateJob(job);\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#addCatalog(java.net.URI,\n   *      org.opencastproject.mediapackage.MediaPackageElementFlavor, org.opencastproject.mediapackage.MediaPackage)\n   */\n  @Override\n  public MediaPackage addCatalog(URI uri, MediaPackageElementFlavor flavor, MediaPackage mediaPackage)\n          throws IOException, IngestException {\n    Job job = null;\n    try {\n      job = serviceRegistry.createJob(JOB_TYPE, INGEST_CATALOG_FROM_URI,\n              Arrays.asList(uri.toString(), flavor.toString(), MediaPackageParser.getAsXml(mediaPackage)), null, false,\n              ingestFileJobLoad);\n      job.setStatus(Status.RUNNING);\n      job = serviceRegistry.updateJob(job);\n      String elementId = UUID.randomUUID().toString();\n      logger.info(\"Start adding catalog {} from URL {} on mediapackage {}\", elementId, uri, mediaPackage);\n      URI newUrl = addContentToRepo(mediaPackage, elementId, uri);\n      if (MediaPackageElements.SERIES.equals(flavor)) {\n        updateSeries(uri);\n      }\n      MediaPackage mp = addContentToMediaPackage(mediaPackage, elementId, newUrl, MediaPackageElement.Type.Catalog,\n              flavor);\n      job.setStatus(Job.Status.FINISHED);\n      logger.info(\"Successful added catalog {} on mediapackage {} at URL {}\", elementId, mediaPackage, newUrl);\n      return mp;\n    } catch (ServiceRegistryException e) {\n      throw new IngestException(e);\n    } catch (NotFoundException e) {\n      throw new IngestException(\"Unable to update ingest job\", e);\n    } finally {\n      finallyUpdateJob(job);\n    }\n  }\n\n  /**\n   * Updates the persistent representation of a series based on a potentially modified dublin core document.\n   *\n   * @param uri\n   *          the URI to the dublin core document containing series metadata.\n   * @return\n   *         true, if the series is created or overwritten, false if the existing series remains intact.\n   * @throws IOException if the series catalog was not found\n   * @throws IngestException if any other exception was encountered\n   */\n  protected boolean updateSeries(URI uri) throws IOException, IngestException {\n    HttpResponse response = null;\n    InputStream in = null;\n    boolean isUpdated = false;\n    try {\n      HttpGet getDc = new HttpGet(uri);\n      response = httpClient.execute(getDc);\n      in = response.getEntity().getContent();\n      DublinCoreCatalog dc = dublinCoreService.load(in);\n      String id = dc.getFirst(DublinCore.PROPERTY_IDENTIFIER);\n      if (id == null) {\n        logger.warn(\"Series dublin core document contains no identifier, rejecting ingested series cagtalog.\");\n      } else {\n        try {\n          try {\n            seriesService.getSeries(id);\n            if (isAllowModifySeries) {\n              // Update existing series\n              seriesService.updateSeries(dc);\n              isUpdated = true;\n              logger.debug(\"Ingest is overwriting the existing series {} with the ingested series\", id);\n            } else {\n              logger.debug(\"Series {} already exists. Ignoring series catalog from ingest.\", id);\n            }\n          } catch (NotFoundException e) {\n            logger.info(\"Creating new series {} with default ACL\", id);\n            seriesService.updateSeries(dc);\n            isUpdated = true;\n          }\n\n        } catch (Exception e) {\n          throw new IngestException(e);\n        }\n      }\n      in.close();\n    } catch (IOException e) {\n      logger.error(\"Error updating series from DublinCoreCatalog: {}\", e.getMessage());\n    } finally {\n      IOUtils.closeQuietly(in);\n      httpClient.close(response);\n    }\n    return isUpdated;\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#addCatalog(java.io.InputStream, java.lang.String,\n   *      org.opencastproject.mediapackage.MediaPackageElementFlavor, org.opencastproject.mediapackage.MediaPackage)\n   */\n  @Override\n  public MediaPackage addCatalog(InputStream in, String fileName, MediaPackageElementFlavor flavor,\n          MediaPackage mediaPackage) throws IOException, IngestException {\n    return addCatalog(in, fileName, flavor, null, mediaPackage);\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#addCatalog(java.io.InputStream, java.lang.String,\n   *      org.opencastproject.mediapackage.MediaPackageElementFlavor, org.opencastproject.mediapackage.MediaPackage)\n   */\n  @Override\n  public MediaPackage addCatalog(InputStream in, String fileName, MediaPackageElementFlavor flavor, String[] tags,\n          MediaPackage mediaPackage) throws IOException, IngestException, IllegalArgumentException {\n    Job job = null;\n    try {\n      job = serviceRegistry.createJob(JOB_TYPE, INGEST_CATALOG, null, null, false, ingestFileJobLoad);\n      job.setStatus(Status.RUNNING);\n      job = serviceRegistry.updateJob(job);\n      final String elementId = UUID.randomUUID().toString();\n      final String mediaPackageId = mediaPackage.getIdentifier().toString();\n      logger.info(\"Start adding catalog {} from input stream on mediapackage {}\", elementId, mediaPackageId);\n      final URI newUrl = addContentToRepo(mediaPackage, elementId, fileName, in);\n\n      final boolean isJSON;\n      try (InputStream inputStream = workingFileRepository.get(mediaPackageId, elementId)) {\n        try (BufferedReader reader  = new BufferedReader(new InputStreamReader(inputStream, StandardCharsets.UTF_8))) {\n          // Exception for current BBB integration and Extron SMP351 which is ingesting a JSON array/object as catalog\n          int firstChar = reader.read();\n          isJSON = firstChar == '[' || firstChar == '{';\n        }\n      }\n\n      if (isJSON) {\n        logger.warn(\"Input catalog seems to be JSON. This is a mistake and will fail in future Opencast versions.\"\n            + \"You will likely want to ingest this as a media package attachment instead.\");\n      } else {\n        // Verify XML is not corrupted\n        try {\n          XmlSafeParser.parse(workingFileRepository.get(mediaPackageId, elementId));\n        } catch (SAXException e) {\n          workingFileRepository.delete(mediaPackageId, elementId);\n          throw new IllegalArgumentException(\"Catalog XML is invalid\", e);\n        }\n      }\n\n      if (MediaPackageElements.SERIES.equals(flavor)) {\n        updateSeries(newUrl);\n      }\n      MediaPackage mp = addContentToMediaPackage(mediaPackage, elementId, newUrl, MediaPackageElement.Type.Catalog,\n              flavor);\n      if (tags != null && tags.length > 0) {\n        MediaPackageElement trackElement = mp.getCatalog(elementId);\n        for (String tag : tags) {\n          logger.info(\"Adding tag {} to element {}\", tag, elementId);\n          trackElement.addTag(tag);\n        }\n      }\n\n      job.setStatus(Job.Status.FINISHED);\n      logger.info(\"Successful added catalog {} on mediapackage {} at URL {}\", elementId, mediaPackage, newUrl);\n      return mp;\n    } catch (ServiceRegistryException e) {\n      throw new IngestException(e);\n    } catch (NotFoundException e) {\n      throw new IngestException(\"Unable to update ingest job\", e);\n    } finally {\n      finallyUpdateJob(job);\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#addAttachment(java.net.URI,\n   *      org.opencastproject.mediapackage.MediaPackageElementFlavor, org.opencastproject.mediapackage.MediaPackage)\n   */\n  @Override\n  public MediaPackage addAttachment(URI uri, MediaPackageElementFlavor flavor, MediaPackage mediaPackage)\n          throws IOException, IngestException {\n    Job job = null;\n    try {\n      job = serviceRegistry.createJob(JOB_TYPE, INGEST_ATTACHMENT_FROM_URI,\n              Arrays.asList(uri.toString(), flavor.toString(), MediaPackageParser.getAsXml(mediaPackage)), null, false,\n              ingestFileJobLoad);\n      job.setStatus(Status.RUNNING);\n      job = serviceRegistry.updateJob(job);\n      String elementId = UUID.randomUUID().toString();\n      logger.info(\"Start adding attachment {} from URL {} on mediapackage {}\", elementId, uri, mediaPackage);\n      URI newUrl = addContentToRepo(mediaPackage, elementId, uri);\n      MediaPackage mp = addContentToMediaPackage(mediaPackage, elementId, newUrl, MediaPackageElement.Type.Attachment,\n              flavor);\n      job.setStatus(Job.Status.FINISHED);\n      logger.info(\"Successful added attachment {} on mediapackage {} at URL {}\", elementId, mediaPackage, newUrl);\n      return mp;\n    } catch (ServiceRegistryException e) {\n      throw new IngestException(e);\n    } catch (NotFoundException e) {\n      throw new IngestException(\"Unable to update ingest job\", e);\n    } finally {\n      finallyUpdateJob(job);\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#addAttachment(java.io.InputStream, java.lang.String,\n   *      org.opencastproject.mediapackage.MediaPackageElementFlavor, org.opencastproject.mediapackage.MediaPackage)\n   */\n  @Override\n  public MediaPackage addAttachment(InputStream in, String fileName, MediaPackageElementFlavor flavor, String[] tags,\n          MediaPackage mediaPackage) throws IOException, IngestException {\n    Job job = null;\n    try {\n      job = serviceRegistry.createJob(JOB_TYPE, INGEST_ATTACHMENT, null, null, false, ingestFileJobLoad);\n      job.setStatus(Status.RUNNING);\n      job = serviceRegistry.updateJob(job);\n      String elementId = UUID.randomUUID().toString();\n      logger.info(\"Start adding attachment {} from input stream on mediapackage {}\", elementId, mediaPackage);\n      URI newUrl = addContentToRepo(mediaPackage, elementId, fileName, in);\n      MediaPackage mp = addContentToMediaPackage(mediaPackage, elementId, newUrl, MediaPackageElement.Type.Attachment,\n              flavor);\n      if (tags != null && tags.length > 0) {\n        MediaPackageElement trackElement = mp.getAttachment(elementId);\n        for (String tag : tags) {\n          logger.info(\"Adding Tag: \" + tag + \" to Element: \" + elementId);\n          trackElement.addTag(tag);\n        }\n      }\n      job.setStatus(Job.Status.FINISHED);\n      logger.info(\"Successful added attachment {} on mediapackage {} at URL {}\", elementId, mediaPackage, newUrl);\n      return mp;\n    } catch (ServiceRegistryException e) {\n      throw new IngestException(e);\n    } catch (NotFoundException e) {\n      throw new IngestException(\"Unable to update ingest job\", e);\n    } finally {\n      finallyUpdateJob(job);\n    }\n\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#addAttachment(java.io.InputStream, java.lang.String,\n   *      org.opencastproject.mediapackage.MediaPackageElementFlavor, org.opencastproject.mediapackage.MediaPackage)\n   */\n  @Override\n  public MediaPackage addAttachment(InputStream in, String fileName, MediaPackageElementFlavor flavor,\n          MediaPackage mediaPackage) throws IOException, IngestException {\n    String[] tags = null;\n    return addAttachment(in, fileName, flavor, tags, mediaPackage);\n  }\n\n  /**\n   *\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#ingest(org.opencastproject.mediapackage.MediaPackage)\n   */\n  @Override\n  public WorkflowInstance ingest(MediaPackage mp) throws IngestException {\n    try {\n      return ingest(mp, null, null, null);\n    } catch (NotFoundException e) {\n      throw new IngestException(e);\n    } catch (UnauthorizedException e) {\n      throw new IllegalStateException(e);\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#ingest(org.opencastproject.mediapackage.MediaPackage,\n   *      java.lang.String, java.util.Map)\n   */\n  @Override\n  public WorkflowInstance ingest(MediaPackage mp, String wd, Map<String, String> properties)\n          throws IngestException, NotFoundException {\n    try {\n      return ingest(mp, wd, properties, null);\n    } catch (UnauthorizedException e) {\n      throw new IllegalStateException(e);\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#ingest(org.opencastproject.mediapackage.MediaPackage,\n   *      java.lang.String, java.util.Map, java.lang.Long)\n   */\n  @Override\n  public WorkflowInstance ingest(MediaPackage mp, String workflowDefinitionId, Map<String, String> properties,\n          Long workflowInstanceId) throws IngestException, NotFoundException, UnauthorizedException {\n    // Check for legacy media package id\n    mp = checkForLegacyMediaPackageId(mp, properties);\n\n    try {\n      mp = createSmil(mp);\n    } catch (IOException e) {\n      throw new IngestException(\"Unable to add SMIL Catalog\", e);\n    }\n\n    // Done, update the job status and return the created workflow instance\n    if (workflowInstanceId != null) {\n      logger.warn(\n              \"Resuming workflow {} with ingested mediapackage {} is deprecated, skip resuming and start new workflow\",\n              workflowInstanceId, mp);\n    }\n\n    if (workflowDefinitionId == null) {\n      logger.info(\"Starting a new workflow with ingested mediapackage {} based on the default workflow definition '{}'\",\n              mp, defaultWorkflowDefinionId);\n    } else {\n      logger.info(\"Starting a new workflow with ingested mediapackage {} based on workflow definition '{}'\", mp,\n              workflowDefinitionId);\n    }\n\n    try {\n      // Determine the workflow definition\n      WorkflowDefinition workflowDef = getWorkflowDefinition(workflowDefinitionId, mp);\n\n      // Get the final set of workflow properties\n      properties = mergeWorkflowConfiguration(properties, mp.getIdentifier().toString());\n\n      // Remove potential workflow configuration prefixes from the workflow properties\n      properties = removePrefixFromProperties(properties);\n\n      // Merge scheduled mediapackage with ingested\n      mp = mergeScheduledMediaPackage(mp);\n\n      ingestStatistics.successful();\n      if (workflowDef != null) {\n        logger.info(\"Starting new workflow with ingested mediapackage '{}' using the specified template '{}'\",\n                mp.getIdentifier().toString(), workflowDefinitionId);\n      } else {\n        logger.info(\"Starting new workflow with ingested mediapackage '{}' using the default template '{}'\",\n                mp.getIdentifier().toString(), defaultWorkflowDefinionId);\n      }\n      return workflowService.start(workflowDef, mp, properties);\n    } catch (WorkflowException e) {\n      ingestStatistics.failed();\n      throw new IngestException(e);\n    }\n  }\n\n  @Override\n  public void schedule(MediaPackage mediaPackage, String workflowDefinitionID, Map<String, String> properties)\n          throws IllegalStateException, IngestException, NotFoundException, UnauthorizedException, SchedulerException {\n    MediaPackageElement[] mediaPackageElements = mediaPackage.getElementsByFlavor(MediaPackageElements.EPISODE);\n    if (mediaPackageElements.length != 1) {\n      logger.debug(\"There can be only one (and exactly one) episode dublin core catalog: https://youtu.be/_J3VeogFUOs\");\n      throw new IngestException(\"There can be only one (and exactly one) episode dublin core catalog\");\n    }\n    InputStream inputStream;\n    DublinCoreCatalog dublinCoreCatalog;\n    try {\n      inputStream = workingFileRepository.get(mediaPackage.getIdentifier().toString(),\n              mediaPackageElements[0].getIdentifier());\n      dublinCoreCatalog = dublinCoreService.load(inputStream);\n    } catch (IOException e) {\n      throw new IngestException(e);\n    }\n\n    EName temporal = new EName(DublinCore.TERMS_NS_URI, \"temporal\");\n    List<DublinCoreValue> periods = dublinCoreCatalog.get(temporal);\n    if (periods.size() != 1) {\n      logger.debug(\"There can be only one (and exactly one) period\");\n      throw new IngestException(\"There can be only one (and exactly one) period\");\n    }\n    DCMIPeriod period = EncodingSchemeUtils.decodeMandatoryPeriod(periods.get(0));\n    if (!period.hasStart() || !period.hasEnd()) {\n      logger.debug(\"A scheduled recording needs to have a start and end.\");\n      throw new IngestException(\"A scheduled recording needs to have a start and end.\");\n    }\n    EName createdEName = new EName(DublinCore.TERMS_NS_URI, \"created\");\n    List<DublinCoreValue> created = dublinCoreCatalog.get(createdEName);\n    if (created.size() == 0) {\n      logger.debug(\"Created not set\");\n    } else if (created.size() == 1) {\n      Date date = EncodingSchemeUtils.decodeMandatoryDate(created.get(0));\n      if (date.getTime() != period.getStart().getTime()) {\n        logger.debug(\"start and created date differ ({} vs {})\", date.getTime(), period.getStart().getTime());\n        throw new IngestException(\"Temporal start and created date differ\");\n      }\n    } else {\n      logger.debug(\"There can be only one created date\");\n      throw new IngestException(\"There can be only one created date\");\n    }\n    // spatial\n    EName spatial = new EName(DublinCore.TERMS_NS_URI, \"spatial\");\n    List<DublinCoreValue> captureAgents = dublinCoreCatalog.get(spatial);\n    if (captureAgents.size() != 1) {\n      logger.debug(\"Exactly one capture agent needs to be set\");\n      throw new IngestException(\"Exactly one capture agent needs to be set\");\n    }\n    String captureAgent = captureAgents.get(0).getValue();\n\n    // Go through properties\n    Map<String, String> agentProperties = new HashMap<>();\n    Map<String, String> workflowProperties = new HashMap<>();\n    for (String key : properties.keySet()) {\n      if (key.startsWith(\"org.opencastproject.workflow.config.\")) {\n        workflowProperties.put(key, properties.get(key));\n      } else {\n        agentProperties.put(key, properties.get(key));\n      }\n    }\n    try {\n      schedulerService.addEvent(period.getStart(), period.getEnd(), captureAgent, new HashSet<>(), mediaPackage,\n              workflowProperties, agentProperties, Opt.none());\n    } finally {\n      for (MediaPackageElement mediaPackageElement : mediaPackage.getElements()) {\n        try {\n          workingFileRepository.delete(mediaPackage.getIdentifier().toString(), mediaPackageElement.getIdentifier());\n        } catch (IOException e) {\n          logger.warn(\"Failed to delete media package element\", e);\n        }\n      }\n    }\n  }\n\n  /**\n   * Check whether the mediapackage id is set via the legacy workflow identifier and change the id if existing.\n   *\n   * @param mp\n   *          the mediapackage\n   * @param properties\n   *          the workflow properties\n   * @return the mediapackage\n   */\n  private MediaPackage checkForLegacyMediaPackageId(MediaPackage mp, Map<String, String> properties)\n          throws IngestException {\n    if (properties == null || properties.isEmpty())\n      return mp;\n\n    try {\n      String mediaPackageId = properties.get(LEGACY_MEDIAPACKAGE_ID_KEY);\n      if (StringUtils.isNotBlank(mediaPackageId) && schedulerService != null) {\n        logger.debug(\"Check ingested mediapackage {} for legacy mediapackage identifier {}\",\n                mp.getIdentifier().toString(), mediaPackageId);\n        try {\n          schedulerService.getMediaPackage(mp.getIdentifier().toString());\n          return mp;\n        } catch (NotFoundException e) {\n          logger.info(\"No scheduler mediapackage found with ingested id {}, try legacy mediapackage id {}\",\n                  mp.getIdentifier().toString(), mediaPackageId);\n          try {\n            schedulerService.getMediaPackage(mediaPackageId);\n            logger.info(\"Legacy mediapackage id {} exists, change ingested mediapackage id {} to legacy id\",\n                    mediaPackageId, mp.getIdentifier().toString());\n            mp.setIdentifier(new IdImpl(mediaPackageId));\n            return mp;\n          } catch (NotFoundException e1) {\n            logger.info(\"No scheduler mediapackage found with legacy mediapackage id {}, skip merging\", mediaPackageId);\n          } catch (Exception e1) {\n            logger.error(\"Unable to get event mediapackage from scheduler event {}\", mediaPackageId, e);\n            throw new IngestException(e);\n          }\n        } catch (Exception e) {\n          logger.error(\"Unable to get event mediapackage from scheduler event {}\", mp.getIdentifier().toString(), e);\n          throw new IngestException(e);\n        }\n      }\n      return mp;\n    } finally {\n      properties.remove(LEGACY_MEDIAPACKAGE_ID_KEY);\n    }\n  }\n\n  private Map<String, String> mergeWorkflowConfiguration(Map<String, String> properties, String mediaPackageId) {\n    if (isBlank(mediaPackageId) || schedulerService == null)\n      return properties;\n\n    HashMap<String, String> mergedProperties = new HashMap<>();\n\n    try {\n      Map<String, String> recordingProperties = schedulerService.getCaptureAgentConfiguration(mediaPackageId);\n      logger.debug(\"Restoring workflow properties from scheduler event {}\", mediaPackageId);\n      mergedProperties.putAll(recordingProperties);\n    } catch (SchedulerException e) {\n      logger.warn(\"Unable to get workflow properties from scheduler event {}\", mediaPackageId, e);\n    } catch (NotFoundException e) {\n      logger.info(\"No capture event found for id {}\", mediaPackageId);\n    } catch (UnauthorizedException e) {\n      throw new IllegalStateException(e);\n    }\n\n    if (properties != null) {\n      // Merge the properties, this must be after adding the recording properties\n      logger.debug(\"Merge workflow properties with the one from the scheduler event {}\", mediaPackageId);\n      mergedProperties.putAll(properties);\n    }\n\n    return mergedProperties;\n  }\n\n  /**\n   * Merges the ingested mediapackage with the scheduled mediapackage. The ingested mediapackage takes precedence over\n   * the scheduled mediapackage.\n   *\n   * @param mp\n   *          the ingested mediapackage\n   * @return the merged mediapackage\n   */\n  private MediaPackage mergeScheduledMediaPackage(MediaPackage mp) throws IngestException {\n    if (schedulerService == null) {\n      logger.warn(\"No scheduler service available to merge mediapackage!\");\n      return mp;\n    }\n\n    try {\n      MediaPackage scheduledMp = schedulerService.getMediaPackage(mp.getIdentifier().toString());\n      logger.info(\"Found matching scheduled event for id '{}', merging mediapackage...\", mp.getIdentifier().toString());\n      mergeMediaPackageElements(mp, scheduledMp);\n      mergeMediaPackageMetadata(mp, scheduledMp);\n      return mp;\n    } catch (NotFoundException e) {\n      logger.debug(\"No scheduler mediapackage found with id {}, skip merging\", mp.getIdentifier());\n      return mp;\n    } catch (Exception e) {\n      throw new IngestException(String.format(\"Unable to get event media package from scheduler event %s\",\n              mp.getIdentifier()), e);\n    }\n  }\n\n  /**\n   * Merge different elements from capture agent ingesting mp and Asset manager. Overwrite or replace same flavored\n   * elements depending on the Ingest Service overwrite configuration. Ignore publications (i.e. live publication\n   * channel from Asset Manager) Always keep tracks from the capture agent.\n   *\n   * @param mp\n   *          the medipackage being ingested from the Capture Agent\n   * @param scheduledMp\n   *          the mediapckage that was schedule and managed by the Asset Manager\n   */\n  private void mergeMediaPackageElements(MediaPackage mp, MediaPackage scheduledMp) {\n    // drop catalogs sent by the capture agent in favor of Opencast's own metadata\n    if (skipCatalogs) {\n      for (MediaPackageElement element : mp.getCatalogs()) {\n        if (!element.getFlavor().equals(MediaPackageElements.SMIL)) {\n          mp.remove(element);\n        }\n      }\n    }\n\n    // drop attachments the capture agent sent us in favor of Opencast's attachments\n    // e.g. prevent capture agents from modifying security rules of schedules events\n    if (skipAttachments) {\n      for (MediaPackageElement element : mp.getAttachments()) {\n        mp.remove(element);\n      }\n    }\n\n    for (MediaPackageElement element : scheduledMp.getElements()) {\n      if (MediaPackageElement.Type.Publication.equals(element.getElementType())) {\n        // The Asset managed media package may have a publication element for a live event, if retract live has not run yet.\n        // Publications do not have flavors and are never part of the mediapackage from the capture agent.\n        // Therefore, ignore publication element because it is removed when the recorded media is published and causes complications (on short media) if added.\n        logger.debug(\"Ignoring {}, not adding to ingested mediapackage {}\", MediaPackageElement.Type.Publication, mp);\n        continue;\n      } else if (mp.getElementsByFlavor(element.getFlavor()).length > 0) {\n        // The default is to overwrite matching flavored elements in the Asset managed mediapackage (e.g. catalogs)\n        // If isOverwrite is true, changes made from the CA overwrite (update/revert) changes made from the Admin UI.\n        // If isOverwrite is false, changes made from the CA do not overwrite (update/revert) changes made from the Admin UI.\n        // regardless of overwrite, always keep new ingested tracks.\n        if (!isAddOnlyNew || MediaPackageElement.Type.Track.equals(element.getElementType())) {\n          // Allow updates made from the Capture Agent to overwrite existing metadata in Opencast\n          logger.info(\n                  \"Omitting Opencast (Asset Managed) element '{}', replacing with ingested element of same flavor '{}'\",\n                  element,\n                  element.getFlavor());\n          continue;\n        }\n        // Remove flavored element from ingested mp and replaced it with maching element from Asset Managed mediapackage.\n        // This protects updates made from the admin UI during an event capture from being reverted by artifacts from the ingested CA.\n        for (MediaPackageElement el : mp.getElementsByFlavor(element.getFlavor())) {\n          logger.info(\"Omitting ingested element '{}' {}, keeping existing (Asset Managed) element of same flavor '{}'\", el, el.getURI(),\n                  element.getFlavor());\n          mp.remove(el);\n        }\n      }\n      logger.info(\"Adding element {} from scheduled (Asset Managed) event '{}' into ingested mediapackage\", element, mp);\n      mp.add(element);\n    }\n  }\n\n  /**\n   *\n   * The previous OC behaviour is for metadata in the ingested mediapackage to be updated by the\n   * Asset Managed metadata *only* when the field is blank on the ingested mediapackage.\n   * However, that field may have been intentionally emptied by\n   * removing its value from the Capture Agent UI (e.g. Galicaster)\n   *\n   * If isOverwrite is true, metadata values in the ingest mediapackage overwrite Asset Managed metadata.\n   * If isOverwrite is false, Asset Managed metadata is preserved.\n   *\n   * @param mp,\n   *          the inbound ingested mp\n   * @param scheduledMp,\n   *          the existing scheduled mp\n   */\n  private void mergeMediaPackageMetadata(MediaPackage mp, MediaPackage scheduledMp) {\n    // Merge media package fields depending on overwrite setting\n    boolean noOverwrite = (isAddOnlyNew && !skipCatalogs) || skipCatalogs;\n    if ((mp.getDate() == null) || noOverwrite)\n      mp.setDate(scheduledMp.getDate());\n    if (isBlank(mp.getLicense()) || noOverwrite)\n      mp.setLicense(scheduledMp.getLicense());\n    if (isBlank(mp.getSeries()) || noOverwrite)\n      mp.setSeries(scheduledMp.getSeries());\n    if (isBlank(mp.getSeriesTitle()) || noOverwrite)\n      mp.setSeriesTitle(scheduledMp.getSeriesTitle());\n    if (isBlank(mp.getTitle()) || noOverwrite)\n      mp.setTitle(scheduledMp.getTitle());\n\n    if (mp.getSubjects().length <= 0 || noOverwrite) {\n      Arrays.stream(mp.getSubjects()).forEach(mp::removeSubject);\n      for (String subject : scheduledMp.getSubjects()) {\n        mp.addSubject(subject);\n      }\n    }\n    if (noOverwrite || mp.getContributors().length == 0) {\n      Arrays.stream(mp.getContributors()).forEach(mp::removeContributor);\n      for (String contributor : scheduledMp.getContributors()) {\n        mp.addContributor(contributor);\n      }\n    }\n    if (noOverwrite || mp.getCreators().length == 0) {\n      Arrays.stream(mp.getCreators()).forEach(mp::removeCreator);\n      for (String creator : scheduledMp.getCreators()) {\n        mp.addCreator(creator);\n      }\n    }\n  }\n\n  /**\n   * Removes the workflow configuration file prefix from all properties in a map.\n   *\n   * @param properties\n   *          The properties to remove the prefixes from\n   * @return A Map with the same collection of properties without the prefix\n   */\n  private Map<String, String> removePrefixFromProperties(Map<String, String> properties) {\n    Map<String, String> fixedProperties = new HashMap<>();\n    if (properties != null) {\n      for (Entry<String, String> entry : properties.entrySet()) {\n        if (entry.getKey().startsWith(WORKFLOW_CONFIGURATION_PREFIX)) {\n          logger.debug(\"Removing prefix from key '\" + entry.getKey() + \" with value '\" + entry.getValue() + \"'\");\n          fixedProperties.put(entry.getKey().replace(WORKFLOW_CONFIGURATION_PREFIX, \"\"), entry.getValue());\n        } else {\n          fixedProperties.put(entry.getKey(), entry.getValue());\n        }\n      }\n    }\n    return fixedProperties;\n  }\n\n  private WorkflowDefinition getWorkflowDefinition(String workflowDefinitionID, MediaPackage mediapackage)\n          throws NotFoundException, WorkflowDatabaseException, IngestException {\n    // If the workflow definition and instance ID are null, use the default, or throw if there is none\n    if (isBlank(workflowDefinitionID)) {\n      String mediaPackageId = mediapackage.getIdentifier().toString();\n      if (schedulerService != null) {\n        logger.info(\"Determining workflow template for ingested mediapckage {} from capture event {}\", mediapackage,\n                mediaPackageId);\n        try {\n          Map<String, String> recordingProperties = schedulerService.getCaptureAgentConfiguration(mediaPackageId);\n          workflowDefinitionID = recordingProperties.get(CaptureParameters.INGEST_WORKFLOW_DEFINITION);\n          if (isBlank(workflowDefinitionID)) {\n            workflowDefinitionID = defaultWorkflowDefinionId;\n            logger.debug(\"No workflow set. Falling back to default.\");\n          }\n          if (isBlank(workflowDefinitionID)) {\n            throw new IngestException(\"No value found for key '\" + CaptureParameters.INGEST_WORKFLOW_DEFINITION\n                    + \"' from capture event configuration of scheduler event '\" + mediaPackageId + \"'\");\n          }\n          logger.info(\"Ingested event {} will be processed using workflow '{}'\", mediapackage, workflowDefinitionID);\n        } catch (NotFoundException e) {\n          logger.warn(\"Specified capture event {} was not found\", mediaPackageId);\n        } catch (UnauthorizedException e) {\n          throw new IllegalStateException(e);\n        } catch (SchedulerException e) {\n          logger.warn(\"Unable to get the workflow definition id from scheduler event {}\", mediaPackageId, e);\n          throw new IngestException(e);\n        }\n      } else {\n        logger.warn(\n                \"Scheduler service not bound, unable to determine the workflow template to use for ingested mediapckage {}\",\n                mediapackage);\n      }\n\n    } else {\n      logger.info(\"Ingested mediapackage {} is processed using workflow template '{}', specified during ingest\",\n              mediapackage, workflowDefinitionID);\n    }\n\n    // Use the default workflow definition if nothing was determined\n    if (isBlank(workflowDefinitionID) && defaultWorkflowDefinionId != null) {\n      logger.info(\"Using default workflow definition '{}' to process ingested mediapackage {}\",\n              defaultWorkflowDefinionId, mediapackage);\n      workflowDefinitionID = defaultWorkflowDefinionId;\n    }\n\n    // Check if the workflow definition is valid\n    if (StringUtils.isNotBlank(workflowDefinitionID) && StringUtils.isNotBlank(defaultWorkflowDefinionId)) {\n      try {\n        workflowService.getWorkflowDefinitionById(workflowDefinitionID);\n      } catch (WorkflowDatabaseException e) {\n        throw new IngestException(e);\n      } catch (NotFoundException nfe) {\n        logger.warn(\"Workflow definition {} not found, using default workflow {} instead\", workflowDefinitionID,\n                defaultWorkflowDefinionId);\n        workflowDefinitionID = defaultWorkflowDefinionId;\n      }\n    }\n\n    // Have we been able to find a workflow definition id?\n    if (isBlank(workflowDefinitionID)) {\n      ingestStatistics.failed();\n      throw new IllegalStateException(\n              \"Can not ingest a workflow without a workflow definition or an existing instance. No default definition is specified\");\n    }\n\n    // Let's make sure the workflow definition exists\n    return workflowService.getWorkflowDefinitionById(workflowDefinitionID);\n  }\n\n  /**\n   *\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#discardMediaPackage(org.opencastproject.mediapackage.MediaPackage)\n   */\n  @Override\n  public void discardMediaPackage(MediaPackage mp) throws IOException {\n    String mediaPackageId = mp.getIdentifier().toString();\n    for (MediaPackageElement element : mp.getElements()) {\n      if (!workingFileRepository.delete(mediaPackageId, element.getIdentifier()))\n        logger.warn(\"Unable to find (and hence, delete), this mediapackage element\");\n    }\n    logger.info(\"Successfully discarded media package {}\", mp);\n  }\n\n  protected URI addContentToRepo(MediaPackage mp, String elementId, URI uri) throws IOException {\n    InputStream in = null;\n    HttpResponse response = null;\n    CloseableHttpClient externalHttpClient = null;\n    try {\n      if (uri.toString().startsWith(\"http\")) {\n        HttpGet get = new HttpGet(uri);\n        List<String> clusterUrls = new LinkedList<>();\n        try {\n          // Note that we are not checking ports here.\n          clusterUrls = organizationDirectoryService.getOrganization(uri.toURL()).getServers()\n                          .keySet()\n                          .stream()\n                          .collect(Collectors.toUnmodifiableList());\n        } catch (NotFoundException e) {\n          logger.warn(\"Unable to determine cluster members, will not be able to authenticate any downloads from them\", e);\n        }\n\n        if (uri.toString().matches(downloadSource)) {\n          //NB: We're creating a new client here with *different* auth than the system auth creds\n          externalHttpClient = getAuthedHttpClient();\n          response = externalHttpClient.execute(get);\n        } else if (clusterUrls.contains(uri.getScheme() + \"://\" + uri.getHost())) {\n          // Only using the system-level httpclient and digest credentials against our own servers\n          response = httpClient.execute(get);\n        } else {\n          //NB: No auth here at all\n          externalHttpClient = getNoAuthHttpClient();\n          response = externalHttpClient.execute(get);\n        }\n\n        if (null == response) {\n          // If you get here then chances are you're using a mock httpClient which does not have appropriate\n          // mocking to respond to the URL you are feeding it.  Try adding that URL to the mock and see if that works.\n          throw new IOException(\"Null response object from the http client, refer to code for explanation\");\n        }\n\n        int httpStatusCode = response.getStatusLine().getStatusCode();\n        if (httpStatusCode != 200) {\n          throw new IOException(uri + \" returns http \" + httpStatusCode);\n        }\n        in = response.getEntity().getContent();\n      } else {\n        in = uri.toURL().openStream();\n      }\n      String fileName = FilenameUtils.getName(uri.getPath());\n      if (isBlank(FilenameUtils.getExtension(fileName)))\n        fileName = getContentDispositionFileName(response);\n\n      if (isBlank(FilenameUtils.getExtension(fileName)))\n        throw new IOException(\"No filename extension found: \" + fileName);\n      return addContentToRepo(mp, elementId, fileName, in);\n    } finally {\n      if (in != null) {\n        in.close();\n      }\n      if (externalHttpClient != null) {\n        externalHttpClient.close();\n      }\n      httpClient.close(response);\n    }\n  }\n\n  private String getContentDispositionFileName(HttpResponse response) {\n    if (response == null)\n      return null;\n\n    Header header = response.getFirstHeader(\"Content-Disposition\");\n    ContentDisposition contentDisposition = new ContentDisposition(header.getValue());\n    return contentDisposition.getParameter(\"filename\");\n  }\n\n  private URI addContentToRepo(MediaPackage mp, String elementId, String filename, InputStream file)\n          throws IOException {\n    ProgressInputStream progressInputStream = new ProgressInputStream(file);\n    progressInputStream.addPropertyChangeListener(new PropertyChangeListener() {\n      @Override\n      public void propertyChange(PropertyChangeEvent evt) {\n        long totalNumBytesRead = (Long) evt.getNewValue();\n        long oldTotalNumBytesRead = (Long) evt.getOldValue();\n        ingestStatistics.add(totalNumBytesRead - oldTotalNumBytesRead);\n      }\n    });\n    return workingFileRepository.put(mp.getIdentifier().toString(), elementId, filename, progressInputStream);\n  }\n\n  private MediaPackage addContentToMediaPackage(MediaPackage mp, String elementId, URI uri,\n          MediaPackageElement.Type type, MediaPackageElementFlavor flavor) {\n    logger.info(\"Adding element of type {} to mediapackage {}\", type, mp);\n    MediaPackageElement mpe = mp.add(uri, type, flavor);\n    mpe.setIdentifier(elementId);\n    return mp;\n  }\n\n  // ---------------------------------------------\n  // --------- bind and unbind bundles ---------\n  // ---------------------------------------------\n  @Reference\n  public void setWorkflowService(WorkflowService workflowService) {\n    this.workflowService = workflowService;\n  }\n\n  @Reference\n  public void setWorkingFileRepository(WorkingFileRepository workingFileRepository) {\n    this.workingFileRepository = workingFileRepository;\n  }\n\n  @Reference\n  public void setSeriesService(SeriesService seriesService) {\n    this.seriesService = seriesService;\n  }\n\n  @Reference\n  public void setDublinCoreService(DublinCoreCatalogService dublinCoreService) {\n    this.dublinCoreService = dublinCoreService;\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.job.api.AbstractJobProducer#getServiceRegistry()\n   */\n  @Override\n  protected ServiceRegistry getServiceRegistry() {\n    return serviceRegistry;\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.job.api.AbstractJobProducer#process(org.opencastproject.job.api.Job)\n   */\n  @Override\n  protected String process(Job job) throws Exception {\n    throw new IllegalStateException(\"Ingest jobs are not expected to be dispatched\");\n  }\n\n  /**\n   * Callback for setting the security service.\n   *\n   * @param securityService\n   *          the securityService to set\n   */\n  @Reference\n  public void setSecurityService(SecurityService securityService) {\n    this.securityService = securityService;\n  }\n\n  /**\n   * Callback for setting the user directory service.\n   *\n   * @param userDirectoryService\n   *          the userDirectoryService to set\n   */\n  @Reference\n  public void setUserDirectoryService(UserDirectoryService userDirectoryService) {\n    this.userDirectoryService = userDirectoryService;\n  }\n\n  /**\n   * Callback for setting the scheduler service.\n   *\n   * @param schedulerService\n   *          the scheduler service to set\n   */\n  @Reference(\n    policy = ReferencePolicy.DYNAMIC,\n    cardinality = ReferenceCardinality.OPTIONAL,\n    unbind = \"unsetSchedulerService\"\n  )\n  public void setSchedulerService(SchedulerService schedulerService) {\n    this.schedulerService = schedulerService;\n  }\n\n  public void unsetSchedulerService(SchedulerService schedulerService) {\n    this.schedulerService = null;\n  }\n\n  /**\n   * Sets a reference to the organization directory service.\n   *\n   * @param organizationDirectory\n   *          the organization directory\n   */\n  @Reference\n  public void setOrganizationDirectoryService(OrganizationDirectoryService organizationDirectory) {\n    organizationDirectoryService = organizationDirectory;\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.job.api.AbstractJobProducer#getSecurityService()\n   */\n  @Override\n  protected SecurityService getSecurityService() {\n    return securityService;\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.job.api.AbstractJobProducer#getUserDirectoryService()\n   */\n  @Override\n  protected UserDirectoryService getUserDirectoryService() {\n    return userDirectoryService;\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.job.api.AbstractJobProducer#getOrganizationDirectoryService()\n   */\n  @Override\n  protected OrganizationDirectoryService getOrganizationDirectoryService() {\n    return organizationDirectoryService;\n  }\n\n  //Used in testing\n  protected CloseableHttpClient getNoAuthHttpClient() {\n    return HttpClientBuilder.create().build();\n  }\n\n  protected CloseableHttpClient getAuthedHttpClient() {\n    HttpClientBuilder cb = HttpClientBuilder.create();\n    CredentialsProvider provider = new BasicCredentialsProvider();\n    provider.setCredentials(\n      new AuthScope(AuthScope.ANY_HOST, AuthScope.ANY_PORT, AuthScope.ANY_REALM, AuthSchemes.DIGEST),\n      new UsernamePasswordCredentials(downloadUser, downloadPassword));\n    return cb.build();\n  }\n\n  private MediaPackage createSmil(MediaPackage mediaPackage) throws IOException, IngestException {\n    Stream<Track> partialTracks = Stream.empty();\n    for (Track track : mediaPackage.getTracks()) {\n      Long startTime = partialTrackStartTimes.getIfPresent(track.getIdentifier());\n      if (startTime == null)\n        continue;\n      partialTracks = partialTracks.append(Opt.nul(track));\n    }\n\n    // No partial track available return without adding SMIL catalog\n    if (partialTracks.isEmpty())\n      return mediaPackage;\n\n    // Inspect the partial tracks\n    List<Track> tracks = partialTracks.map(newEnrichJob(mediaInspectionService).toFn())\n            .map(payloadAsTrack(getServiceRegistry()).toFn())\n            .each(MediaPackageSupport.updateElement(mediaPackage).toFn().toFx()).toList();\n\n    // Create the SMIL document\n    org.w3c.dom.Document smilDocument = SmilUtil.createSmil();\n    for (Track track : tracks) {\n      Long startTime = partialTrackStartTimes.getIfPresent(track.getIdentifier());\n      if (startTime == null) {\n        logger.error(\"No start time found for track {}\", track);\n        throw new IngestException(\"No start time found for track \" + track.getIdentifier());\n      }\n      smilDocument = addSmilTrack(smilDocument, track, startTime);\n      partialTrackStartTimes.invalidate(track.getIdentifier());\n    }\n\n    // Store the SMIL document in the mediapackage\n    return addSmilCatalog(smilDocument, mediaPackage);\n  }\n\n  /**\n   * Adds a SMIL catalog to a mediapackage if it's not already existing.\n   *\n   * @param smilDocument\n   *          the smil document\n   * @param mediaPackage\n   *          the mediapackage to extend with the SMIL catalog\n   * @return the augmented mediapcakge\n   * @throws IOException\n   *           if reading or writing of the SMIL catalog fails\n   * @throws IngestException\n   *           if the SMIL catalog already exists\n   */\n  private MediaPackage addSmilCatalog(org.w3c.dom.Document smilDocument, MediaPackage mediaPackage)\n          throws IOException, IngestException {\n    Option<org.w3c.dom.Document> optSmilDocument = loadSmilDocument(workingFileRepository, mediaPackage);\n    if (optSmilDocument.isSome())\n      throw new IngestException(\"SMIL already exists!\");\n\n    InputStream in = null;\n    try {\n      in = XmlUtil.serializeDocument(smilDocument);\n      String elementId = UUID.randomUUID().toString();\n      URI uri = workingFileRepository.put(mediaPackage.getIdentifier().toString(), elementId, PARTIAL_SMIL_NAME, in);\n      MediaPackageElement mpe = mediaPackage.add(uri, MediaPackageElement.Type.Catalog, MediaPackageElements.SMIL);\n      mpe.setIdentifier(elementId);\n      // Reset the checksum since it changed\n      mpe.setChecksum(null);\n      mpe.setMimeType(MimeTypes.SMIL);\n      return mediaPackage;\n    } finally {\n      IoSupport.closeQuietly(in);\n    }\n  }\n\n  /**\n   * Load a SMIL document of a media package.\n   *\n   * @return the document or none if no media package element found.\n   */\n  private Option<org.w3c.dom.Document> loadSmilDocument(final WorkingFileRepository workingFileRepository,\n          MediaPackage mp) {\n    return mlist(mp.getElements()).filter(MediaPackageSupport.Filters.isSmilCatalog).headOpt()\n            .map(new Function<MediaPackageElement, org.w3c.dom.Document>() {\n              @Override\n              public org.w3c.dom.Document apply(MediaPackageElement mpe) {\n                InputStream in = null;\n                try {\n                  in = workingFileRepository.get(mpe.getMediaPackage().getIdentifier().toString(), mpe.getIdentifier());\n                  return SmilUtil.loadSmilDocument(in, mpe);\n                } catch (Exception e) {\n                  logger.warn(\"Unable to load smil document from catalog '{}'\", mpe, e);\n                  return Misc.chuck(e);\n                } finally {\n                  IOUtils.closeQuietly(in);\n                }\n              }\n            });\n  }\n\n  /**\n   * Adds a SMIL track by a mediapackage track to a SMIL document\n   *\n   * @param smilDocument\n   *          the SMIL document to extend\n   * @param track\n   *          the mediapackage track\n   * @param startTime\n   *          the start time\n   * @return the augmented SMIL document\n   * @throws IngestException\n   *           if the partial flavor type is not valid\n   */\n  private org.w3c.dom.Document addSmilTrack(org.w3c.dom.Document smilDocument, Track track, long startTime)\n          throws IngestException {\n    if (MediaPackageElements.PRESENTER_SOURCE.getType().equals(track.getFlavor().getType())) {\n      return SmilUtil.addTrack(smilDocument, SmilUtil.TrackType.PRESENTER, track.hasVideo(), startTime,\n              track.getDuration(), track.getURI(), track.getIdentifier());\n    } else if (MediaPackageElements.PRESENTATION_SOURCE.getType().equals(track.getFlavor().getType())) {\n      return SmilUtil.addTrack(smilDocument, SmilUtil.TrackType.PRESENTATION, track.hasVideo(), startTime,\n              track.getDuration(), track.getURI(), track.getIdentifier());\n    } else {\n      logger.warn(\"Invalid partial flavor type {} of track {}\", track.getFlavor(), track);\n      throw new IngestException(\n              \"Invalid partial flavor type \" + track.getFlavor().getType() + \" of track \" + track.getURI().toString());\n    }\n  }\n\n  /**\n   * Create a media inspection job for a mediapackage element.\n   *\n   * @param svc the media inspection service\n   * @return a function\n   */\n  public static Function<MediaPackageElement, Job> newEnrichJob(final MediaInspectionService svc) {\n    return new Function.X<MediaPackageElement, Job>() {\n      @Override\n      public Job xapply(MediaPackageElement e) throws Exception {\n        return svc.enrich(e, true);\n      }\n    };\n  }\n\n  /**\n   * Interpret the payload of a completed Job as a MediaPackageElement. Wait for the job to complete if necessary.\n   *\n   * @param reg the service registry\n   * @return a function\n   */\n  public static Function<Job, Track> payloadAsTrack(final ServiceRegistry reg) {\n    return new Function.X<Job, Track>() {\n      @Override\n      public Track xapply(Job job) throws MediaPackageException {\n        waitForJob(reg, none(0L), job);\n        return (Track) MediaPackageElementParser.getFromXml(job.getPayload());\n      }\n    };\n  }\n}\n", "/**\n * Licensed to The Apereo Foundation under one or more contributor license\n * agreements. See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n *\n * The Apereo Foundation licenses this file to you under the Educational\n * Community License, Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of the License\n * at:\n *\n *   http://opensource.org/licenses/ecl2.txt\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n * License for the specific language governing permissions and limitations under\n * the License.\n *\n */\n\npackage org.opencastproject.ingest.impl;\n\nimport org.opencastproject.capture.CaptureParameters;\nimport org.opencastproject.inspection.api.MediaInspectionService;\nimport org.opencastproject.job.api.Job;\nimport org.opencastproject.job.api.Job.Status;\nimport org.opencastproject.job.api.JobImpl;\nimport org.opencastproject.mediapackage.Attachment;\nimport org.opencastproject.mediapackage.Catalog;\nimport org.opencastproject.mediapackage.MediaPackage;\nimport org.opencastproject.mediapackage.MediaPackageElement;\nimport org.opencastproject.mediapackage.MediaPackageElementParser;\nimport org.opencastproject.mediapackage.MediaPackageElements;\nimport org.opencastproject.mediapackage.MediaPackageParser;\nimport org.opencastproject.mediapackage.Publication;\nimport org.opencastproject.mediapackage.Track;\nimport org.opencastproject.mediapackage.track.AudioStreamImpl;\nimport org.opencastproject.mediapackage.track.TrackImpl;\nimport org.opencastproject.mediapackage.track.VideoStreamImpl;\nimport org.opencastproject.metadata.dublincore.DublinCoreCatalog;\nimport org.opencastproject.metadata.dublincore.DublinCoreCatalogService;\nimport org.opencastproject.metadata.dublincore.DublinCores;\nimport org.opencastproject.scheduler.api.SchedulerService;\nimport org.opencastproject.security.api.DefaultOrganization;\nimport org.opencastproject.security.api.JaxbRole;\nimport org.opencastproject.security.api.JaxbUser;\nimport org.opencastproject.security.api.Organization;\nimport org.opencastproject.security.api.OrganizationDirectoryService;\nimport org.opencastproject.security.api.SecurityService;\nimport org.opencastproject.security.api.TrustedHttpClient;\nimport org.opencastproject.security.api.User;\nimport org.opencastproject.security.api.UserDirectoryService;\nimport org.opencastproject.series.api.SeriesService;\nimport org.opencastproject.serviceregistry.api.IncidentService;\nimport org.opencastproject.serviceregistry.api.ServiceRegistryInMemoryImpl;\nimport org.opencastproject.util.MimeTypes;\nimport org.opencastproject.util.NotFoundException;\nimport org.opencastproject.util.XmlUtil;\nimport org.opencastproject.util.data.Either;\nimport org.opencastproject.workflow.api.WorkflowDefinition;\nimport org.opencastproject.workflow.api.WorkflowDefinitionImpl;\nimport org.opencastproject.workflow.api.WorkflowInstance;\nimport org.opencastproject.workflow.api.WorkflowInstance.WorkflowState;\nimport org.opencastproject.workflow.api.WorkflowInstanceImpl;\nimport org.opencastproject.workflow.api.WorkflowService;\nimport org.opencastproject.workingfilerepository.api.WorkingFileRepository;\nimport org.opencastproject.workingfilerepository.impl.WorkingFileRepositoryImpl;\n\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang3.reflect.FieldUtils;\nimport org.apache.http.Header;\nimport org.apache.http.HttpEntity;\nimport org.apache.http.StatusLine;\nimport org.apache.http.client.methods.CloseableHttpResponse;\nimport org.apache.http.client.methods.HttpGet;\nimport org.apache.http.impl.client.CloseableHttpClient;\nimport org.easymock.Capture;\nimport org.easymock.EasyMock;\nimport org.easymock.IAnswer;\nimport org.junit.After;\nimport org.junit.Assert;\nimport org.junit.Before;\nimport org.junit.BeforeClass;\nimport org.junit.Test;\nimport org.w3c.dom.Document;\nimport org.xml.sax.InputSource;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.util.Dictionary;\nimport java.util.HashMap;\nimport java.util.Hashtable;\nimport java.util.Map;\n\npublic class IngestServiceImplTest {\n  private IngestServiceImpl service = null;\n  private DublinCoreCatalogService dublinCoreService = null;\n  private SeriesService seriesService = null;\n  private WorkflowService workflowService = null;\n  private WorkflowInstance workflowInstance = null;\n  private WorkingFileRepository wfr = null;\n  private CloseableHttpResponse httpResponse = null;\n  private CloseableHttpClient credClient = null;\n  private CloseableHttpClient noCredClient = null;\n  private static URI baseDir;\n  private static URI urlTrack;\n  private static URI urlTrack1;\n  private static URI urlTrack2;\n  private static URI urlCatalog;\n  private static URI urlCatalog1;\n  private static URI urlCatalog2;\n  private static URI urlAttachment;\n  private static URI urlPackage;\n  private static URI urlPackageOld;\n  private static URI urlTrackNoFilename;\n\n  private static File ingestTempDir;\n  private static File packageFile;\n\n  private static long workflowInstanceID = 1L;\n  private ServiceRegistryInMemoryImpl serviceRegistry;\n\n  private MediaPackage ingestMediaPackage;\n  private MediaPackage schedulerMediaPackage;\n\n  @BeforeClass\n  public static void beforeClass() throws URISyntaxException {\n    baseDir = IngestServiceImplTest.class.getResource(\"/\").toURI();\n    urlTrack = IngestServiceImplTest.class.getResource(\"/av.mov\").toURI();\n    urlTrack1 = IngestServiceImplTest.class.getResource(\"/vonly.mov\").toURI();\n    urlTrack2 = IngestServiceImplTest.class.getResource(\"/aonly.mov\").toURI();\n    urlCatalog = IngestServiceImplTest.class.getResource(\"/mpeg-7.xml\").toURI();\n    urlCatalog1 = IngestServiceImplTest.class.getResource(\"/dublincore.xml\").toURI();\n    urlCatalog2 = IngestServiceImplTest.class.getResource(\"/series-dublincore.xml\").toURI();\n    urlAttachment = IngestServiceImplTest.class.getResource(\"/cover.png\").toURI();\n    urlPackage = IngestServiceImplTest.class.getResource(\"/data.zip\").toURI();\n    urlPackageOld = IngestServiceImplTest.class.getResource(\"/data.old.zip\").toURI();\n    urlTrackNoFilename = IngestServiceImplTest.class.getResource(\"/av\").toURI();\n\n    ingestTempDir = new File(new File(baseDir), \"ingest-temp\");\n    packageFile = new File(ingestTempDir, baseDir.relativize(urlPackage).toString());\n\n  }\n\n  @Before\n  public void setUp() throws Exception {\n    //This looks dumb, but is required so we can override things in testAuthWhitelist\n    setupService();\n  }\n\n  @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n  private void setupService() throws Exception {\n    schedulerMediaPackage = MediaPackageParser\n            .getFromXml(IOUtils.toString(getClass().getResourceAsStream(\"/source-manifest.xml\"), \"UTF-8\"));\n\n    ingestMediaPackage = MediaPackageParser\n            .getFromXml(IOUtils.toString(getClass().getResourceAsStream(\"/target-manifest.xml\"), \"UTF-8\"));\n\n    FileUtils.forceMkdir(ingestTempDir);\n\n    // set up service and mock workspace\n    wfr = EasyMock.createNiceMock(WorkingFileRepository.class);\n    EasyMock.expect(wfr.put((String) EasyMock.anyObject(), (String) EasyMock.anyObject(), (String) EasyMock.anyObject(),\n            (InputStream) EasyMock.anyObject())).andReturn(urlTrack);\n    EasyMock.expect(wfr.put((String) EasyMock.anyObject(), (String) EasyMock.anyObject(), (String) EasyMock.anyObject(),\n            (InputStream) EasyMock.anyObject())).andReturn(urlCatalog);\n    EasyMock.expect(wfr.put((String) EasyMock.anyObject(), (String) EasyMock.anyObject(), (String) EasyMock.anyObject(),\n            (InputStream) EasyMock.anyObject())).andReturn(urlAttachment);\n    EasyMock.expect(wfr.put((String) EasyMock.anyObject(), (String) EasyMock.anyObject(), (String) EasyMock.anyObject(),\n            (InputStream) EasyMock.anyObject())).andReturn(urlTrack1);\n    EasyMock.expect(wfr.put((String) EasyMock.anyObject(), (String) EasyMock.anyObject(), (String) EasyMock.anyObject(),\n            (InputStream) EasyMock.anyObject())).andReturn(urlTrack2);\n    EasyMock.expect(wfr.put((String) EasyMock.anyObject(), (String) EasyMock.anyObject(), (String) EasyMock.anyObject(),\n            (InputStream) EasyMock.anyObject())).andReturn(urlCatalog1);\n    EasyMock.expect(wfr.put((String) EasyMock.anyObject(), (String) EasyMock.anyObject(), (String) EasyMock.anyObject(),\n            (InputStream) EasyMock.anyObject())).andReturn(urlCatalog2);\n    EasyMock.expect(wfr.put((String) EasyMock.anyObject(), (String) EasyMock.anyObject(), (String) EasyMock.anyObject(),\n            (InputStream) EasyMock.anyObject())).andReturn(urlCatalog);\n\n    EasyMock.expect(wfr.putInCollection((String) EasyMock.anyObject(), (String) EasyMock.anyObject(),\n            (InputStream) EasyMock.anyObject())).andReturn(urlTrack1);\n    EasyMock.expect(wfr.putInCollection((String) EasyMock.anyObject(), (String) EasyMock.anyObject(),\n            (InputStream) EasyMock.anyObject())).andReturn(urlTrack2);\n    EasyMock.expect(wfr.putInCollection((String) EasyMock.anyObject(), (String) EasyMock.anyObject(),\n            (InputStream) EasyMock.anyObject())).andReturn(urlCatalog1);\n    EasyMock.expect(wfr.putInCollection((String) EasyMock.anyObject(), (String) EasyMock.anyObject(),\n            (InputStream) EasyMock.anyObject())).andReturn(urlCatalog2);\n    EasyMock.expect(wfr.putInCollection((String) EasyMock.anyObject(), (String) EasyMock.anyObject(),\n            (InputStream) EasyMock.anyObject())).andReturn(urlCatalog);\n\n    EasyMock.expect(wfr.putInCollection((String) EasyMock.anyObject(), (String) EasyMock.anyObject(),\n            (InputStream) EasyMock.anyObject())).andReturn(urlPackage);\n\n    EasyMock.expect(wfr.putInCollection((String) EasyMock.anyObject(), (String) EasyMock.anyObject(),\n            (InputStream) EasyMock.anyObject())).andReturn(urlPackageOld);\n\n    workflowInstance = EasyMock.createNiceMock(WorkflowInstance.class);\n    EasyMock.expect(workflowInstance.getId()).andReturn(workflowInstanceID);\n    EasyMock.expect(workflowInstance.getState()).andReturn(WorkflowState.STOPPED);\n\n    final Capture<MediaPackage> mp = EasyMock.newCapture();\n    workflowService = EasyMock.createNiceMock(WorkflowService.class);\n    EasyMock.expect(workflowService.start((WorkflowDefinition) EasyMock.anyObject(), EasyMock.capture(mp),\n            (Map) EasyMock.anyObject())).andReturn(workflowInstance);\n    EasyMock.expect(workflowInstance.getMediaPackage()).andAnswer(mp::getValue).anyTimes();\n    EasyMock.expect(workflowService.start((WorkflowDefinition) EasyMock.anyObject(),\n            (MediaPackage) EasyMock.anyObject(), (Map) EasyMock.anyObject())).andReturn(workflowInstance).anyTimes();\n    EasyMock.expect(\n            workflowService.start((WorkflowDefinition) EasyMock.anyObject(), (MediaPackage) EasyMock.anyObject()))\n            .andReturn(workflowInstance).anyTimes();\n    EasyMock.expect(workflowService.getWorkflowDefinitionById((String) EasyMock.anyObject()))\n            .andReturn(new WorkflowDefinitionImpl()).anyTimes();\n    EasyMock.expect(workflowService.getWorkflowById(EasyMock.anyLong())).andReturn(workflowInstance).anyTimes();\n\n    SchedulerService schedulerService = EasyMock.createNiceMock(SchedulerService.class);\n\n    Map<String, String> properties = new HashMap<>();\n    properties.put(CaptureParameters.INGEST_WORKFLOW_DEFINITION, \"sample\");\n    properties.put(\"agent-name\", \"matterhorn-agent\");\n    EasyMock.expect(schedulerService.getCaptureAgentConfiguration(EasyMock.anyString())).andReturn(properties)\n            .anyTimes();\n    EasyMock.expect(schedulerService.getDublinCore(EasyMock.anyString()))\n            .andReturn(DublinCores.read(urlCatalog1.toURL().openStream())).anyTimes();\n    EasyMock.expect(schedulerService.getMediaPackage(EasyMock.anyString())).andReturn(schedulerMediaPackage).anyTimes();\n\n    EasyMock.replay(wfr, workflowInstance, workflowService, schedulerService);\n\n    User anonymous = new JaxbUser(\"anonymous\", \"test\", new DefaultOrganization(),\n            new JaxbRole(DefaultOrganization.DEFAULT_ORGANIZATION_ANONYMOUS, new DefaultOrganization(), \"test\"));\n    UserDirectoryService userDirectoryService = EasyMock.createMock(UserDirectoryService.class);\n    EasyMock.expect(userDirectoryService.loadUser((String) EasyMock.anyObject())).andReturn(anonymous).anyTimes();\n    EasyMock.replay(userDirectoryService);\n\n    Organization organization = new DefaultOrganization();\n    OrganizationDirectoryService organizationDirectoryService = EasyMock.createMock(OrganizationDirectoryService.class);\n    EasyMock.expect(organizationDirectoryService.getOrganization((String) EasyMock.anyObject())).andReturn(organization)\n            .anyTimes();\n    EasyMock.expect(organizationDirectoryService.getOrganization((URL) EasyMock.anyObject())).andReturn(organization)\n            .anyTimes();\n    EasyMock.replay(organizationDirectoryService);\n\n    SecurityService securityService = EasyMock.createNiceMock(SecurityService.class);\n    EasyMock.expect(securityService.getUser()).andReturn(anonymous).anyTimes();\n    EasyMock.expect(securityService.getOrganization()).andReturn(organization).anyTimes();\n    EasyMock.replay(securityService);\n\n    HttpEntity entity = EasyMock.createMock(HttpEntity.class);\n    InputStream is = getClass().getResourceAsStream(\"/av.mov\");\n    byte[] movie = IOUtils.toByteArray(is);\n    IOUtils.closeQuietly(is);\n    EasyMock.expect(entity.getContent()).andReturn(new ByteArrayInputStream(movie)).anyTimes();\n    EasyMock.replay(entity);\n\n    StatusLine statusLine = EasyMock.createMock(StatusLine.class);\n    EasyMock.expect(statusLine.getStatusCode()).andReturn(200).anyTimes();\n    EasyMock.replay(statusLine);\n\n    Header contentDispositionHeader = EasyMock.createMock(Header.class);\n    EasyMock.expect(contentDispositionHeader.getValue()).andReturn(\"attachment; filename=fname.mp4\").anyTimes();\n    EasyMock.replay(contentDispositionHeader);\n\n    httpResponse = EasyMock.createMock(CloseableHttpResponse.class);\n    EasyMock.expect(httpResponse.getStatusLine()).andReturn(statusLine).anyTimes();\n    EasyMock.expect(httpResponse.getFirstHeader(\"Content-Disposition\")).andReturn(contentDispositionHeader).anyTimes();\n    EasyMock.expect(httpResponse.getEntity()).andReturn(entity).anyTimes();\n    EasyMock.replay(httpResponse);\n\n    TrustedHttpClient httpClient = EasyMock.createNiceMock(TrustedHttpClient.class);\n    EasyMock.expect(httpClient.execute((HttpGet) EasyMock.anyObject())).andReturn(httpResponse).anyTimes();\n    EasyMock.replay(httpClient);\n\n    MediaInspectionService mediaInspectionService = EasyMock.createNiceMock(MediaInspectionService.class);\n    EasyMock.expect(mediaInspectionService.enrich(EasyMock.anyObject(MediaPackageElement.class), EasyMock.anyBoolean()))\n            .andAnswer(new IAnswer<Job>() {\n              private int i = 0;\n\n              @Override\n              public Job answer() throws Throwable {\n                TrackImpl element = (TrackImpl) EasyMock.getCurrentArguments()[0];\n                element.setDuration(20000L);\n                if (i % 2 == 0) {\n                  element.addStream(new VideoStreamImpl());\n                } else {\n                  element.addStream(new AudioStreamImpl());\n                }\n                i++;\n                JobImpl succeededJob = new JobImpl();\n                succeededJob.setStatus(Status.FINISHED);\n                succeededJob.setPayload(MediaPackageElementParser.getAsXml(element));\n                return succeededJob;\n              }\n            }).anyTimes();\n    EasyMock.replay(mediaInspectionService);\n\n    if (null == service) {\n      service = new IngestServiceImpl() {\n\n        //These are overriden so that we get mock requests, not *actual* requests\n        @Override\n        protected CloseableHttpClient getAuthedHttpClient() {\n          CloseableHttpClient client = EasyMock.createMock(CloseableHttpClient.class);\n          try {\n            EasyMock.expect(client.execute((HttpGet) EasyMock.anyObject())).andReturn(httpResponse).anyTimes();\n            client.close();\n            EasyMock.expectLastCall().once();\n          } catch (Exception e) { }\n          EasyMock.replay(client);\n          return client;\n        }\n        @Override\n        protected CloseableHttpClient getNoAuthHttpClient() {\n          CloseableHttpClient client = EasyMock.createMock(CloseableHttpClient.class);\n          try {\n            EasyMock.expect(client.execute((HttpGet) EasyMock.anyObject())).andReturn(httpResponse).anyTimes();\n            client.close();\n            EasyMock.expectLastCall().once();\n          } catch (Exception e) { }\n          EasyMock.replay(client);\n          return client;\n        }\n      };\n    }\n    service.setHttpClient(httpClient);\n    service.setOrganizationDirectoryService(organizationDirectoryService);\n    service.setWorkingFileRepository(wfr);\n    service.setWorkflowService(workflowService);\n    service.setSecurityService(securityService);\n    service.setSchedulerService(schedulerService);\n    service.setMediaInspectionService(mediaInspectionService);\n    serviceRegistry = new ServiceRegistryInMemoryImpl(service, securityService, userDirectoryService,\n            organizationDirectoryService, EasyMock.createNiceMock(IncidentService.class));\n    serviceRegistry.registerService(service);\n    service.setServiceRegistry(serviceRegistry);\n    service.defaultWorkflowDefinionId = \"sample\";\n    serviceRegistry.registerService(service);\n    Dictionary<String, String> p = new Hashtable<>();\n    p.put(IngestServiceImpl.DOWNLOAD_SOURCE, \"http://localhost.*|http://www.test.com/.*\");\n    service.updated(p);\n  }\n\n  @After\n  public void tearDown() {\n    FileUtils.deleteQuietly(ingestTempDir);\n  }\n\n  @Test\n  public void testThinClient() throws Exception {\n    MediaPackage mediaPackage = null;\n\n    // Use default properties\n    Dictionary<String, String> properties = new Hashtable<>();\n    service.updated(properties);\n\n    mediaPackage = service.createMediaPackage();\n    mediaPackage = service.addTrack(urlTrack, MediaPackageElements.PRESENTATION_SOURCE, mediaPackage);\n    mediaPackage = service.addCatalog(urlCatalog1, MediaPackageElements.EPISODE, mediaPackage);\n    mediaPackage = service.addAttachment(urlAttachment, MediaPackageElements.MEDIAPACKAGE_COVER_FLAVOR, mediaPackage);\n    WorkflowInstance instance = service.ingest(mediaPackage);\n    Assert.assertEquals(1, mediaPackage.getTracks().length);\n    Assert.assertEquals(1, mediaPackage.getCatalogs().length);\n    Assert.assertEquals(1, mediaPackage.getAttachments().length);\n    Assert.assertEquals(workflowInstanceID, instance.getId());\n  }\n\n  @Test\n  public void testThickClient() throws Exception {\n\n    FileUtils.copyURLToFile(urlPackage.toURL(), packageFile);\n\n    InputStream packageStream = null;\n    try {\n      packageStream = urlPackage.toURL().openStream();\n      WorkflowInstance instance = service.addZippedMediaPackage(packageStream);\n\n      // Assert.assertEquals(2, mediaPackage.getTracks().length);\n      // Assert.assertEquals(3, mediaPackage.getCatalogs().length);\n      Assert.assertEquals(workflowInstanceID, instance.getId());\n    } catch (IOException e) {\n      Assert.fail(e.getMessage());\n    } finally {\n      IOUtils.closeQuietly(packageStream);\n    }\n\n  }\n\n  @Test\n  public void testThickClientOldMP() throws Exception {\n\n    FileUtils.copyURLToFile(urlPackageOld.toURL(), packageFile);\n\n    InputStream packageStream = null;\n    try {\n      packageStream = urlPackageOld.toURL().openStream();\n      WorkflowInstance instance = service.addZippedMediaPackage(packageStream);\n\n      // Assert.assertEquals(2, mediaPackage.getTracks().length);\n      // Assert.assertEquals(3, mediaPackage.getCatalogs().length);\n      Assert.assertEquals(workflowInstanceID, instance.getId());\n    } catch (IOException e) {\n      Assert.fail(e.getMessage());\n    } finally {\n      IOUtils.closeQuietly(packageStream);\n    }\n\n  }\n\n  @Test\n  public void testContentDisposition() throws Exception {\n    MediaPackage mediaPackage = null;\n\n    mediaPackage = service.createMediaPackage();\n    try {\n      mediaPackage = service.addTrack(URI.create(\"http://www.test.com/testfile\"), null, mediaPackage);\n    } catch (Exception e) {\n      Assert.fail(\"Unable to read content dispostion filename: \" + e.getMessage());\n    }\n\n    try {\n      mediaPackage = service.addTrack(urlTrackNoFilename, null, mediaPackage);\n      Assert.fail(\"Allowed adding content without filename!\");\n    } catch (Exception e) {\n      Assert.assertNotNull(e);\n    }\n  }\n\n  private void testAuthWhitelist(String url, String regex, boolean shouldFail, boolean shouldSendAuth, boolean shouldTouchMocks) throws Exception {\n    credClient = EasyMock.createNiceMock(CloseableHttpClient.class);\n    noCredClient = EasyMock.createNiceMock(CloseableHttpClient.class);\n\n    //There's one case (accessing the filesystem) where we *don't* expect the mocks to be used\n    if (shouldTouchMocks) {\n      if (shouldSendAuth) {\n        EasyMock.expect(credClient.execute(EasyMock.anyObject())).andReturn(httpResponse).once();\n        credClient.close();\n        EasyMock.expectLastCall().once();\n      } else {\n        EasyMock.expect(noCredClient.execute(EasyMock.anyObject())).andReturn(httpResponse).once();\n        noCredClient.close();\n        EasyMock.expectLastCall().once();\n      }\n    }\n    EasyMock.replay(noCredClient, credClient);\n\n    //Recreate the service so we use our own, custom mocks\n    service = new IngestServiceImpl() {\n      @Override\n      protected CloseableHttpClient getAuthedHttpClient() {\n        return credClient;\n      }\n\n      @Override\n      protected CloseableHttpClient getNoAuthHttpClient() {\n        return noCredClient;\n      }\n    };\n    setupService();\n\n    MediaPackage mediaPackage = service.createMediaPackage();\n\n    Dictionary<String, String> props = new Hashtable<>();\n    props.put(IngestServiceImpl.DOWNLOAD_SOURCE, regex);\n    service.updated(props);\n\n    try {\n      service.addTrack(URI.create(url), null, mediaPackage);\n    } catch (IOException e) {\n      if (!shouldFail) {\n        Assert.fail(\"Should not have failed!\");\n      }\n    }\n    EasyMock.verify(credClient, noCredClient);\n    EasyMock.reset(credClient, noCredClient);\n  }\n\n  @Test\n  public void testAuthWhitelist() throws Exception {\n    //Test fetching something from something known to be inside the cluster.  This should use the default service-wide trusted client\n    testAuthWhitelist(\"http://localhost/testfile\", \"\", false, true, false);\n\n    //Clear the whitelist, this should *never* send digest auth when fetching files\n    testAuthWhitelist(\"http://www.example.org/testfile\", \"\", false, false, true);\n    //Non-matching regex\n    testAuthWhitelist(\"http://www.example.org/testfile\", \"http://localhost.*\", true, false, true);\n    //Matching regex\n    testAuthWhitelist(\"http://www.example.org/testfile\", \"http://localhost.*|http://www.example.org/.*\", false, true, true);\n  }\n\n\n  @Test\n  public void testSmilCreation() throws Exception {\n    service.setWorkingFileRepository(new WorkingFileRepositoryImpl() {\n      @Override\n      public URI put(String mediaPackageID, String mediaPackageElementID, String filename, InputStream in)\n              throws IOException {\n        File file = new File(FileUtils.getTempDirectory(), mediaPackageElementID);\n        file.deleteOnExit();\n        FileUtils.write(file, IOUtils.toString(in), \"UTF-8\");\n        return file.toURI();\n      }\n\n      @Override\n      public InputStream get(String mediaPackageID, String mediaPackageElementID)\n              throws NotFoundException, IOException {\n        File file = new File(FileUtils.getTempDirectory(), mediaPackageElementID);\n        return new FileInputStream(file);\n      }\n    });\n\n    URI presenterUri = URI.create(\"http://localhost:8080/presenter.mp4\");\n    URI presenterUri2 = URI.create(\"http://localhost:8080/presenter2.mp4\");\n    URI presentationUri = URI.create(\"http://localhost:8080/presentation.mp4\");\n\n    MediaPackage mediaPackage = service.createMediaPackage();\n    Catalog[] catalogs = mediaPackage.getCatalogs(MediaPackageElements.SMIL);\n    Assert.assertEquals(0, catalogs.length);\n\n    mediaPackage = service.addPartialTrack(presenterUri, MediaPackageElements.PRESENTER_SOURCE_PARTIAL, 60000L,\n            mediaPackage);\n    mediaPackage = service.addPartialTrack(presenterUri2, MediaPackageElements.PRESENTER_SOURCE_PARTIAL, 120000L,\n            mediaPackage);\n    mediaPackage = service.addPartialTrack(presentationUri, MediaPackageElements.PRESENTATION_SOURCE_PARTIAL, 0L,\n            mediaPackage);\n\n    catalogs = mediaPackage.getCatalogs(MediaPackageElements.SMIL);\n    Assert.assertEquals(0, catalogs.length);\n\n    FieldUtils.writeField(FieldUtils.getField(IngestServiceImpl.class, \"skipCatalogs\", true),\n            service, false, true);\n    service.ingest(mediaPackage);\n    catalogs = mediaPackage.getCatalogs(MediaPackageElements.SMIL);\n    Assert.assertEquals(1, catalogs.length);\n\n    Assert.assertEquals(MimeTypes.SMIL, catalogs[0].getMimeType());\n    Either<Exception, Document> eitherDoc = XmlUtil.parseNs(new InputSource(catalogs[0].getURI().toURL().openStream()));\n    Assert.assertTrue(eitherDoc.isRight());\n    Document document = eitherDoc.right().value();\n    Assert.assertEquals(1, document.getElementsByTagName(\"par\").getLength());\n    Assert.assertEquals(2, document.getElementsByTagName(\"seq\").getLength());\n    Assert.assertEquals(2, document.getElementsByTagName(\"video\").getLength());\n    Assert.assertEquals(1, document.getElementsByTagName(\"audio\").getLength());\n  }\n\n  @Test\n  public void testMergeScheduledMediaPackage() throws Exception {\n    MediaPackage ingestMediaPackage = MediaPackageParser\n            .getFromXml(IOUtils.toString(getClass().getResourceAsStream(\"/source-manifest-partial.xml\"), \"UTF-8\"));\n\n    Dictionary<String, String> properties = new Hashtable<>();\n    properties.put(IngestServiceImpl.SKIP_ATTACHMENTS_KEY, \"false\");\n    properties.put(IngestServiceImpl.SKIP_CATALOGS_KEY, \"false\");\n    properties.put(IngestServiceImpl.ADD_ONLY_NEW_FLAVORS_KEY, \"false\");\n    service.updated(properties);\n\n    MediaPackage mergedMediaPackage = service.ingest(ingestMediaPackage).getMediaPackage();\n    Assert.assertEquals(4, mergedMediaPackage.getTracks().length);\n    Track track = mergedMediaPackage.getTrack(\"track-1\");\n    Assert.assertEquals(\"/vonlya1.mov\", track.getURI().toString());\n    Assert.assertEquals(4, mergedMediaPackage.getCatalogs().length);\n    Assert.assertEquals(2, mergedMediaPackage.getAttachments().length);\n    Attachment attachment = mergedMediaPackage.getAttachment(\"cover\");\n    Assert.assertEquals(\"attachments/cover.png\", attachment.getURI().toString());\n\n    // Validate fields\n    Assert.assertEquals(10045L, mergedMediaPackage.getDuration().doubleValue(), 0L);\n    Assert.assertEquals(\"t2\", mergedMediaPackage.getTitle());\n    Assert.assertEquals(\"s2\", mergedMediaPackage.getSeries());\n    Assert.assertEquals(\"st2\", mergedMediaPackage.getSeriesTitle());\n    Assert.assertEquals(\"l2\", mergedMediaPackage.getLicense());\n    Assert.assertEquals(1, mergedMediaPackage.getSubjects().length);\n    Assert.assertEquals(\"s2\", mergedMediaPackage.getSubjects()[0]);\n    Assert.assertEquals(1, mergedMediaPackage.getContributors().length);\n    Assert.assertEquals(\"sd2\", mergedMediaPackage.getContributors()[0]);\n    Assert.assertEquals(1, mergedMediaPackage.getCreators().length);\n    Assert.assertEquals(\"p2\", mergedMediaPackage.getCreators()[0]);\n\n\n  }\n\n  @Test\n  public void testOverwriteAndNoSkip() throws Exception {\n    MediaPackage ingestMediaPackage = MediaPackageParser\n            .getFromXml(IOUtils.toString(getClass().getResourceAsStream(\"/source-manifest-partial.xml\"), \"UTF-8\"));\n\n    Dictionary<String, String> properties = new Hashtable<>();\n\n    MediaPackage mergedMediaPackage = service.ingest(ingestMediaPackage).getMediaPackage();\n\n    // check element skipping\n    properties.put(IngestServiceImpl.SKIP_ATTACHMENTS_KEY, \"true\");\n    properties.put(IngestServiceImpl.SKIP_CATALOGS_KEY, \"true\");\n    properties.put(IngestServiceImpl.ADD_ONLY_NEW_FLAVORS_KEY, \"true\");\n    service.updated(properties);\n\n    // Existing Opencast mp has 3 catalogs and 1 attachment, the ingest mp has 4 and 2.\n    mergedMediaPackage = service.ingest(ingestMediaPackage).getMediaPackage();\n    Assert.assertEquals(0, mergedMediaPackage.getCatalogs().length);\n    Assert.assertEquals(1, mergedMediaPackage.getAttachments().length);\n  }\n\n  @Test\n  public void testVaryEpisodeWithOnlyNewFlavorsFalse() throws Exception {\n    Dictionary<String, String> properties = new Hashtable<>();\n    boolean isAddOnlyNew;\n    // Test with properties and key is false\n    properties.put(IngestServiceImpl.ADD_ONLY_NEW_FLAVORS_KEY, \"false\");\n    service.updated(properties);\n    isAddOnlyNew = service.isAddOnlyNew;\n    Assert.assertFalse(\"Updated overwrite property to false\", isAddOnlyNew);\n    testEpisodeUpdateNewAndExisting();\n  }\n\n  @Test\n  public void testVaryEpisodeWithOnlyNewFlavorsMissingParam() throws Exception {\n    Dictionary<String, String> properties = new Hashtable<>();\n    boolean isAddOnlyNew;\n    // Test with properties file but no overwrite param\n    properties = new Hashtable<>();\n    properties.put(\"blahblah\", \"blahblah\");\n    service.updated(properties);\n    isAddOnlyNew = service.isAddOnlyNew;\n    Assert.assertTrue(\"Is Add Only New defaults to true when param is not found (i.e. commented out)\", isAddOnlyNew);\n\n  }\n\n  @Test\n  public void testNoPropertiesEpisodeOverwriteParam() throws Exception {\n    Dictionary<String, String> properties = new Hashtable<>();\n    boolean isAddOnlyNew;\n    properties = new Hashtable<>();\n    service.updated(properties);\n    isAddOnlyNew = service.isAddOnlyNew;\n    Assert.assertTrue(\"Overwrite property defaults to true when param is commented out\", isAddOnlyNew);\n  }\n\n\n  @Test\n  public void testLegacyMediaPackageId() throws Exception {\n    SchedulerService schedulerService = EasyMock.createNiceMock(SchedulerService.class);\n\n    Map<String, String> properties = new HashMap<String, String>();\n    properties.put(CaptureParameters.INGEST_WORKFLOW_DEFINITION, \"sample\");\n    properties.put(\"agent-name\", \"matterhorn-agent\");\n    EasyMock.expect(schedulerService.getCaptureAgentConfiguration(EasyMock.anyString())).andReturn(properties)\n            .anyTimes();\n    EasyMock.expect(schedulerService.getDublinCore(EasyMock.anyString()))\n            .andReturn(DublinCores.read(urlCatalog1.toURL().openStream())).anyTimes();\n    EasyMock.expect(schedulerService.getMediaPackage(EasyMock.anyString())).andThrow(new NotFoundException()).once();\n    EasyMock.expect(schedulerService.getMediaPackage(EasyMock.anyString())).andReturn(schedulerMediaPackage).once();\n    EasyMock.expect(schedulerService.getMediaPackage(EasyMock.anyString())).andThrow(new NotFoundException())\n            .anyTimes();\n    EasyMock.replay(schedulerService);\n    service.setSchedulerService(schedulerService);\n\n    final Capture<Map<String, String>> captureConfig = EasyMock.newCapture();\n    WorkflowService workflowService = EasyMock.createNiceMock(WorkflowService.class);\n    EasyMock.expect(workflowService.start(EasyMock.anyObject(WorkflowDefinition.class),\n            EasyMock.anyObject(MediaPackage.class), EasyMock.capture(captureConfig)))\n            .andReturn(new WorkflowInstanceImpl()).once();\n    EasyMock.replay(workflowService);\n    service.setWorkflowService(workflowService);\n\n    Map<String, String> wfConfig = new HashMap<>();\n    wfConfig.put(IngestServiceImpl.LEGACY_MEDIAPACKAGE_ID_KEY, \"6f7a7850-3232-4719-9064-24c9bad2832f\");\n    service.ingest(ingestMediaPackage, null, wfConfig);\n    Assert.assertFalse(captureConfig.getValue().containsKey(IngestServiceImpl.LEGACY_MEDIAPACKAGE_ID_KEY));\n  }\n\n  /**\n   * Test four cases: 1) If no config file 2) If config file but no key 3) If key and false value 4) If key and true\n   * value\n   *\n   * @throws Exception\n   */\n  @Test\n  public void testVarySeriesOverwriteConfiguration() throws Exception {\n    boolean isAddOnlyNewSeries;\n    Dictionary<String, String> properties = makeIngestProperties();\n\n    // Test with no properties\n    // NOTE: This test only works if the serivce.update() was not triggered by any previous tests\n    testSeriesUpdateNewAndExisting(null);\n\n    // Test with properties and no key\n    testSeriesUpdateNewAndExisting(properties);\n\n    // Test with properties and key is true\n    isAddOnlyNewSeries = true;\n    properties.put(IngestServiceImpl.ADD_ONLY_NEW_FLAVORS_KEY, String.valueOf(isAddOnlyNewSeries));\n    testSeriesUpdateNewAndExisting(properties);\n\n    // Test series overwrite key is false\n    isAddOnlyNewSeries = false;\n    properties.put(IngestServiceImpl.ADD_ONLY_NEW_FLAVORS_KEY, String.valueOf(isAddOnlyNewSeries));\n    testSeriesUpdateNewAndExisting(properties);\n  }\n\n  @Test\n  public void testFailedJobs() throws Exception {\n    Assert.assertEquals(0, serviceRegistry.getJobs(IngestServiceImpl.JOB_TYPE, Job.Status.FINISHED).size());\n    Assert.assertEquals(0, serviceRegistry.getJobs(IngestServiceImpl.JOB_TYPE, Job.Status.FAILED).size());\n    service.addTrack(urlTrack, MediaPackageElements.PRESENTATION_SOURCE, service.createMediaPackage());\n    Assert.assertEquals(1, serviceRegistry.getJobs(IngestServiceImpl.JOB_TYPE, Job.Status.FINISHED).size());\n    Assert.assertEquals(0, serviceRegistry.getJobs(IngestServiceImpl.JOB_TYPE, Job.Status.FAILED).size());\n    try {\n      service.addTrack(URI.create(\"file//baduri\"), MediaPackageElements.PRESENTATION_SOURCE,\n              service.createMediaPackage());\n    } catch (Exception e) {\n      // Ignore exception\n    }\n    Assert.assertEquals(1, serviceRegistry.getJobs(IngestServiceImpl.JOB_TYPE, Job.Status.FINISHED).size());\n    Assert.assertEquals(1, serviceRegistry.getJobs(IngestServiceImpl.JOB_TYPE, Job.Status.FAILED).size());\n  }\n\n  private void testEpisodeUpdateNewAndExisting() throws Exception {\n    boolean isAddOnlyNew = service.isAddOnlyNew;\n    MediaPackage partialIngestMediaPackage = MediaPackageParser\n            .getFromXml(IOUtils.toString(getClass().getResourceAsStream(\"/source-manifest-partial.xml\"), \"UTF-8\"));\n\n    WorkflowInstance instance = service.ingest(partialIngestMediaPackage);\n\n    MediaPackage mergedMediaPackage = instance.getMediaPackage();\n    Assert.assertEquals(4, mergedMediaPackage.getTracks().length);\n    Track track = mergedMediaPackage.getTrack(\"track-1\");\n    Assert.assertEquals(\"/vonlya1.mov\", track.getURI().toString());\n    // Existing mp has 3 catalogs 1 attachments, ingest mp has 4 and 2.\n    Assert.assertEquals(4, mergedMediaPackage.getCatalogs().length);\n    Assert.assertEquals(2, mergedMediaPackage.getAttachments().length);\n    Attachment attachment = mergedMediaPackage.getAttachment(\"cover\");\n\n    // The live pub is always omitted, regardless of state of isAddOnlyNew\n    Publication[] pubs = this.schedulerMediaPackage.getPublications();\n    Assert.assertEquals(\"Pub is part of asset managed mediapackage\", 1, pubs.length);\n    Publication[] pubs2 = mergedMediaPackage.getPublications();\n    Assert.assertEquals(\"Pub is not added back into ingested mediapackage\", 0, pubs2.length);\n\n    // Validate fields\n    if (!isAddOnlyNew) { // overwrite\n      Assert.assertEquals(\"attachments/cover.png\", attachment.getURI().toString());\n      Assert.assertEquals(\"t2\", mergedMediaPackage.getTitle());\n      Assert.assertEquals(\"t2\", mergedMediaPackage.getTitle());\n      Assert.assertEquals(\"s2\", mergedMediaPackage.getSeries());\n      Assert.assertEquals(\"st2\", mergedMediaPackage.getSeriesTitle());\n      Assert.assertEquals(\"l2\", mergedMediaPackage.getLicense());\n      Assert.assertEquals(1, mergedMediaPackage.getSubjects().length);\n      Assert.assertEquals(\"s2\", mergedMediaPackage.getSubjects()[0]);\n      Assert.assertEquals(1, mergedMediaPackage.getContributors().length);\n      Assert.assertEquals(\"sd2\", mergedMediaPackage.getContributors()[0]);\n      Assert.assertEquals(1, mergedMediaPackage.getCreators().length);\n      Assert.assertEquals(\"p2\", mergedMediaPackage.getCreators()[0]);\n\n    } else { // no overwrite\n      Assert.assertEquals(\"/cover.png\", attachment.getURI().toString());\n      Assert.assertEquals(\"t1\", mergedMediaPackage.getTitle());\n      Assert.assertEquals(\"t1\", mergedMediaPackage.getTitle());\n      Assert.assertEquals(\"s1\", mergedMediaPackage.getSeries());\n      Assert.assertEquals(\"st1\", mergedMediaPackage.getSeriesTitle());\n      Assert.assertEquals(\"l1\", mergedMediaPackage.getLicense());\n      Assert.assertEquals(1, mergedMediaPackage.getSubjects().length);\n      Assert.assertEquals(\"s1\", mergedMediaPackage.getSubjects()[0]);\n      Assert.assertEquals(1, mergedMediaPackage.getContributors().length);\n      Assert.assertEquals(\"sd1\", mergedMediaPackage.getContributors()[0]);\n      Assert.assertEquals(1, mergedMediaPackage.getCreators().length);\n      Assert.assertEquals(\"p1\", mergedMediaPackage.getCreators()[0]);\n    }\n\n    Assert.assertEquals(10045L, mergedMediaPackage.getDuration().doubleValue(), 0L);\n\n  }\n\n  /**\n   * Utility to set the default required properties\n   *\n   * @return default properties\n   */\n  private Dictionary<String, String> makeIngestProperties() {\n    Dictionary<String, String> properties = new Hashtable<>();\n    String downloadPassword = \"CHANGE_ME\";\n    String downloadSource = \"http://localhost\";\n    String downloadUser = \"opencast_system_account\";\n\n    properties.put(IngestServiceImpl.DOWNLOAD_PASSWORD, downloadPassword);\n    properties.put(IngestServiceImpl.DOWNLOAD_SOURCE, downloadSource);\n    properties.put(IngestServiceImpl.DOWNLOAD_USER, downloadUser);\n\n    return properties;\n  }\n\n  /**\n   * Test method for {@link org.opencastproject.ingest.impl.IngestServiceImpl#updateSeries(java.net.URI)}\n   */\n  private void testSeriesUpdateNewAndExisting(Dictionary<String, String> properties) throws Exception {\n\n    // default expectation for series overwrite\n    boolean isUpdateSeries = IngestServiceImpl.DEFAULT_ALLOW_SERIES_MODIFICATIONS;\n\n    if (properties != null) {\n      service.updated(properties);\n      try {\n        boolean testForValue = Boolean.parseBoolean(properties.get(IngestServiceImpl.MODIFY_OPENCAST_SERIES_KEY).trim());\n        isUpdateSeries = testForValue;\n      } catch (Exception e) {\n        // If key or value not found or not boolean, use the default overwrite expectation\n      }\n    }\n\n    // Get test series dublin core for the mock return value\n    File catalogFile = new File(urlCatalog2);\n    if (!catalogFile.exists() || !catalogFile.canRead())\n      throw new Exception(\"Unable to access test catalog \" + urlCatalog2.getPath());\n    FileInputStream in = new FileInputStream(catalogFile);\n    DublinCoreCatalog series = DublinCores.read(in);\n    IOUtils.closeQuietly(in);\n\n    // Set dublinCore service to return test dublin core\n    dublinCoreService = org.easymock.EasyMock.createNiceMock(DublinCoreCatalogService.class);\n    org.easymock.EasyMock.expect(dublinCoreService.load((InputStream) EasyMock.anyObject())).andReturn(series)\n            .anyTimes();\n    org.easymock.EasyMock.replay(dublinCoreService);\n    service.setDublinCoreService(dublinCoreService);\n\n    // Test with mock found series\n    seriesService = EasyMock.createNiceMock(SeriesService.class);\n    EasyMock.expect(seriesService.getSeries((String) EasyMock.anyObject())).andReturn(series).once();\n    EasyMock.expect(seriesService.updateSeries(series)).andReturn(series).once();\n    EasyMock.replay(seriesService);\n    service.setSeriesService(seriesService);\n\n    // This is true or false depending on the isAddOnlyNew value\n    Assert.assertEquals(\"Desire to update series is \" + isUpdateSeries + \".\",\n            isUpdateSeries, service.updateSeries(urlCatalog2));\n\n    // Test with mock not found exception\n    EasyMock.reset(seriesService);\n    EasyMock.expect(seriesService.updateSeries(series)).andReturn(series).once();\n    EasyMock.expect(seriesService.getSeries((String) EasyMock.anyObject())).andThrow(new NotFoundException()).once();\n    EasyMock.replay(seriesService);\n\n    service.setSeriesService(seriesService);\n\n    // This should be true, i.e. create new series, in all cases\n    Assert.assertEquals(\"Always create a new series catalog.\", true, service.updateSeries(urlCatalog2));\n  }\n\n}\n"], "fixing_code": ["/**\n * Licensed to The Apereo Foundation under one or more contributor license\n * agreements. See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n *\n * The Apereo Foundation licenses this file to you under the Educational\n * Community License, Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of the License\n * at:\n *\n *   http://opensource.org/licenses/ecl2.txt\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n * License for the specific language governing permissions and limitations under\n * the License.\n *\n */\n\npackage org.opencastproject.ingest.impl;\n\nimport static org.apache.commons.lang3.StringUtils.isBlank;\nimport static org.opencastproject.util.JobUtil.waitForJob;\nimport static org.opencastproject.util.data.Monadics.mlist;\nimport static org.opencastproject.util.data.Option.none;\n\nimport org.opencastproject.capture.CaptureParameters;\nimport org.opencastproject.ingest.api.IngestException;\nimport org.opencastproject.ingest.api.IngestService;\nimport org.opencastproject.ingest.impl.jmx.IngestStatistics;\nimport org.opencastproject.inspection.api.MediaInspectionService;\nimport org.opencastproject.job.api.AbstractJobProducer;\nimport org.opencastproject.job.api.Job;\nimport org.opencastproject.job.api.Job.Status;\nimport org.opencastproject.mediapackage.EName;\nimport org.opencastproject.mediapackage.MediaPackage;\nimport org.opencastproject.mediapackage.MediaPackageBuilderFactory;\nimport org.opencastproject.mediapackage.MediaPackageElement;\nimport org.opencastproject.mediapackage.MediaPackageElementFlavor;\nimport org.opencastproject.mediapackage.MediaPackageElementParser;\nimport org.opencastproject.mediapackage.MediaPackageElements;\nimport org.opencastproject.mediapackage.MediaPackageException;\nimport org.opencastproject.mediapackage.MediaPackageParser;\nimport org.opencastproject.mediapackage.MediaPackageSupport;\nimport org.opencastproject.mediapackage.Track;\nimport org.opencastproject.mediapackage.identifier.IdImpl;\nimport org.opencastproject.metadata.dublincore.DCMIPeriod;\nimport org.opencastproject.metadata.dublincore.DublinCore;\nimport org.opencastproject.metadata.dublincore.DublinCoreCatalog;\nimport org.opencastproject.metadata.dublincore.DublinCoreCatalogService;\nimport org.opencastproject.metadata.dublincore.DublinCoreValue;\nimport org.opencastproject.metadata.dublincore.EncodingSchemeUtils;\nimport org.opencastproject.scheduler.api.SchedulerException;\nimport org.opencastproject.scheduler.api.SchedulerService;\nimport org.opencastproject.security.api.OrganizationDirectoryService;\nimport org.opencastproject.security.api.SecurityService;\nimport org.opencastproject.security.api.TrustedHttpClient;\nimport org.opencastproject.security.api.UnauthorizedException;\nimport org.opencastproject.security.api.UserDirectoryService;\nimport org.opencastproject.series.api.SeriesService;\nimport org.opencastproject.serviceregistry.api.ServiceRegistry;\nimport org.opencastproject.serviceregistry.api.ServiceRegistryException;\nimport org.opencastproject.smil.api.util.SmilUtil;\nimport org.opencastproject.util.ConfigurationException;\nimport org.opencastproject.util.IoSupport;\nimport org.opencastproject.util.LoadUtil;\nimport org.opencastproject.util.MimeTypes;\nimport org.opencastproject.util.NotFoundException;\nimport org.opencastproject.util.ProgressInputStream;\nimport org.opencastproject.util.XmlSafeParser;\nimport org.opencastproject.util.XmlUtil;\nimport org.opencastproject.util.data.Function;\nimport org.opencastproject.util.data.Option;\nimport org.opencastproject.util.data.functions.Misc;\nimport org.opencastproject.util.jmx.JmxUtil;\nimport org.opencastproject.workflow.api.WorkflowDatabaseException;\nimport org.opencastproject.workflow.api.WorkflowDefinition;\nimport org.opencastproject.workflow.api.WorkflowException;\nimport org.opencastproject.workflow.api.WorkflowInstance;\nimport org.opencastproject.workflow.api.WorkflowService;\nimport org.opencastproject.workingfilerepository.api.WorkingFileRepository;\n\nimport com.entwinemedia.fn.Stream;\nimport com.entwinemedia.fn.data.Opt;\nimport com.google.common.cache.Cache;\nimport com.google.common.cache.CacheBuilder;\n\nimport org.apache.commons.compress.archivers.zip.ZipArchiveEntry;\nimport org.apache.commons.compress.archivers.zip.ZipArchiveInputStream;\nimport org.apache.commons.io.FilenameUtils;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang3.BooleanUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.cxf.jaxrs.ext.multipart.ContentDisposition;\nimport org.apache.http.Header;\nimport org.apache.http.HttpResponse;\nimport org.apache.http.auth.AuthScope;\nimport org.apache.http.auth.UsernamePasswordCredentials;\nimport org.apache.http.client.CredentialsProvider;\nimport org.apache.http.client.config.AuthSchemes;\nimport org.apache.http.client.methods.HttpGet;\nimport org.apache.http.impl.client.BasicCredentialsProvider;\nimport org.apache.http.impl.client.CloseableHttpClient;\nimport org.apache.http.impl.client.HttpClientBuilder;\nimport org.osgi.service.cm.ManagedService;\nimport org.osgi.service.component.ComponentContext;\nimport org.osgi.service.component.annotations.Activate;\nimport org.osgi.service.component.annotations.Component;\nimport org.osgi.service.component.annotations.Deactivate;\nimport org.osgi.service.component.annotations.Reference;\nimport org.osgi.service.component.annotations.ReferenceCardinality;\nimport org.osgi.service.component.annotations.ReferencePolicy;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.xml.sax.SAXException;\n\nimport java.beans.PropertyChangeEvent;\nimport java.beans.PropertyChangeListener;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.URI;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Arrays;\nimport java.util.Date;\nimport java.util.Dictionary;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.concurrent.TimeUnit;\nimport java.util.stream.Collectors;\n\nimport javax.management.ObjectInstance;\n\n/**\n * Creates and augments Opencast MediaPackages. Stores media into the Working File Repository.\n */\n@Component(\n  immediate = true,\n  service = {\n    IngestService.class,\n    ManagedService.class\n  },\n  property = {\n    \"service.description=Ingest Service\",\n    \"service.pid=org.opencastproject.ingest.impl.IngestServiceImpl\"\n  }\n)\npublic class IngestServiceImpl extends AbstractJobProducer implements IngestService, ManagedService {\n\n  /** The logger */\n  private static final Logger logger = LoggerFactory.getLogger(IngestServiceImpl.class);\n\n  /** The source SMIL name */\n  private static final String PARTIAL_SMIL_NAME = \"source_partial.smil\";\n\n  /** The configuration key that defines the default workflow definition */\n  protected static final String WORKFLOW_DEFINITION_DEFAULT = \"org.opencastproject.workflow.default.definition\";\n\n  /** The workflow configuration property prefix **/\n  protected static final String WORKFLOW_CONFIGURATION_PREFIX = \"org.opencastproject.workflow.config.\";\n\n  /** The key for the legacy mediapackage identifier */\n  public static final String LEGACY_MEDIAPACKAGE_ID_KEY = \"org.opencastproject.ingest.legacy.mediapackage.id\";\n\n  public static final String JOB_TYPE = \"org.opencastproject.ingest\";\n\n  /** Methods that ingest zips create jobs with this operation type */\n  public static final String INGEST_ZIP = \"zip\";\n\n  /** Methods that ingest tracks directly create jobs with this operation type */\n  public static final String INGEST_TRACK = \"track\";\n\n  /** Methods that ingest tracks from a URI create jobs with this operation type */\n  public static final String INGEST_TRACK_FROM_URI = \"uri-track\";\n\n  /** Methods that ingest attachments directly create jobs with this operation type */\n  public static final String INGEST_ATTACHMENT = \"attachment\";\n\n  /** Methods that ingest attachments from a URI create jobs with this operation type */\n  public static final String INGEST_ATTACHMENT_FROM_URI = \"uri-attachment\";\n\n  /** Methods that ingest catalogs directly create jobs with this operation type */\n  public static final String INGEST_CATALOG = \"catalog\";\n\n  /** Methods that ingest catalogs from a URI create jobs with this operation type */\n  public static final String INGEST_CATALOG_FROM_URI = \"uri-catalog\";\n\n  /** The approximate load placed on the system by ingesting a file */\n  public static final float DEFAULT_INGEST_FILE_JOB_LOAD = 0.2f;\n\n  /** The approximate load placed on the system by ingesting a zip file */\n  public static final float DEFAULT_INGEST_ZIP_JOB_LOAD = 0.2f;\n\n  /** The key to look for in the service configuration file to override the {@link DEFAULT_INGEST_FILE_JOB_LOAD} */\n  public static final String FILE_JOB_LOAD_KEY = \"job.load.ingest.file\";\n\n  /** The key to look for in the service configuration file to override the {@link DEFAULT_INGEST_ZIP_JOB_LOAD} */\n  public static final String ZIP_JOB_LOAD_KEY = \"job.load.ingest.zip\";\n\n  /** The source to download from  */\n  public static final String DOWNLOAD_SOURCE = \"org.opencastproject.download.source\";\n\n  /** The user for download from external sources */\n  public static final String DOWNLOAD_USER = \"org.opencastproject.download.user\";\n\n  /** The password for download from external sources */\n  public static final String DOWNLOAD_PASSWORD = \"org.opencastproject.download.password\";\n\n  /** By default, do not allow event ingest to modify existing series metadata */\n  public static final boolean DEFAULT_ALLOW_SERIES_MODIFICATIONS = false;\n\n  /** The default is to preserve existing Opencast flavors during ingest. */\n  public static final boolean DEFAULT_ALLOW_ONLY_NEW_FLAVORS = true;\n\n  /** The default is not to automatically skip attachments and catalogs from capture agent */\n  public static final boolean DEFAULT_SKIP = false;\n\n  /** The maximum length of filenames ingested by Opencast */\n  public static final int FILENAME_LENGTH_MAX = 75;\n\n  /** Managed Property key to allow Opencast series modification during ingest\n   * Deprecated, the param potentially causes an update chain reaction for all\n   * events associated to that series, for each ingest */\n  @Deprecated\n  public static final String MODIFY_OPENCAST_SERIES_KEY = \"org.opencastproject.series.overwrite\";\n\n  /** Managed Property key to allow new flavors of ingested attachments and catalogs\n   * to be added to the existing Opencast mediapackage. But, not catalogs and attachments\n   * that would overwrite existing ones in Opencast.\n   */\n  public static final String ADD_ONLY_NEW_FLAVORS_KEY = \"add.only.new.catalogs.attachments.for.existing.events\";\n\n  /** Control if catalogs sent by capture agents for scheduled events are skipped. */\n  public static final String SKIP_CATALOGS_KEY = \"skip.catalogs.for.existing.events\";\n\n  /** Control if attachments sent by capture agents for scheduled events are skipped. */\n  public static final String SKIP_ATTACHMENTS_KEY = \"skip.attachments.for.existing.events\";\n\n  /** The approximate load placed on the system by ingesting a file */\n  private float ingestFileJobLoad = DEFAULT_INGEST_FILE_JOB_LOAD;\n\n  /** The approximate load placed on the system by ingesting a zip file */\n  private float ingestZipJobLoad = DEFAULT_INGEST_ZIP_JOB_LOAD;\n\n  /** The user for download from external sources */\n  private static String downloadUser = DOWNLOAD_USER;\n\n  /** The password for download from external sources */\n  private static String downloadPassword = DOWNLOAD_PASSWORD;\n\n  /** The external source dns name */\n  private static String downloadSource = DOWNLOAD_SOURCE;\n\n  /** The JMX business object for ingest statistics */\n  private IngestStatistics ingestStatistics = new IngestStatistics();\n\n  /** The JMX bean object instance */\n  private ObjectInstance registerMXBean;\n\n  /** The workflow service */\n  private WorkflowService workflowService;\n\n  /** The working file repository */\n  private WorkingFileRepository workingFileRepository;\n\n  /** The http client */\n  private TrustedHttpClient httpClient;\n\n  /** The series service */\n  private SeriesService seriesService;\n\n  /** The dublin core service */\n  private DublinCoreCatalogService dublinCoreService;\n\n  /** The opencast service registry */\n  private ServiceRegistry serviceRegistry;\n\n  /** The security service */\n  protected SecurityService securityService = null;\n\n  /** The user directory service */\n  protected UserDirectoryService userDirectoryService = null;\n\n  /** The organization directory service */\n  protected OrganizationDirectoryService organizationDirectoryService = null;\n\n  /** The scheduler service */\n  private SchedulerService schedulerService = null;\n\n  /** The media inspection service */\n  private MediaInspectionService mediaInspectionService = null;\n\n  /** The default workflow identifier, if one is configured */\n  protected String defaultWorkflowDefinionId;\n\n  /** The partial track start time map */\n  private Cache<String, Long> partialTrackStartTimes = CacheBuilder.newBuilder().expireAfterWrite(1, TimeUnit.DAYS)\n          .build();\n\n  /** Option to overwrite matching flavors (e.g. series and episode metadata) on ingest,\n   *  tracks are always taken on ingest */\n  protected boolean isAddOnlyNew = DEFAULT_ALLOW_ONLY_NEW_FLAVORS;\n  protected boolean isAllowModifySeries = DEFAULT_ALLOW_SERIES_MODIFICATIONS;\n\n  private boolean skipCatalogs = DEFAULT_SKIP;\n  private boolean skipAttachments = DEFAULT_SKIP;\n\n  protected boolean testMode = false;\n\n  /**\n   * Creates a new ingest service instance.\n   */\n  public IngestServiceImpl() {\n    super(JOB_TYPE);\n  }\n\n  /**\n   * OSGI callback for activating this component\n   *\n   * @param cc\n   *          the osgi component context\n   */\n  @Override\n  @Activate\n  public void activate(ComponentContext cc) {\n    super.activate(cc);\n    logger.info(\"Ingest Service started.\");\n    defaultWorkflowDefinionId = StringUtils.trimToNull(cc.getBundleContext().getProperty(WORKFLOW_DEFINITION_DEFAULT));\n    if (defaultWorkflowDefinionId == null) {\n      defaultWorkflowDefinionId = \"schedule-and-upload\";\n    }\n    registerMXBean = JmxUtil.registerMXBean(ingestStatistics, \"IngestStatistics\");\n  }\n\n  /**\n   * Callback from OSGi on service deactivation.\n   */\n  @Deactivate\n  public void deactivate() {\n    JmxUtil.unregisterMXBean(registerMXBean);\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.osgi.service.cm.ManagedService#updated(java.util.Dictionary)\n   *      Retrieve ManagedService configuration, including option to overwrite series\n   */\n  @Override\n  public void updated(Dictionary<String, ?> properties) throws ConfigurationException {\n\n    if (properties == null) {\n      logger.info(\"No configuration available, using defaults\");\n      return;\n    }\n\n    downloadPassword = StringUtils.trimToEmpty((String)properties.get(DOWNLOAD_PASSWORD));\n    downloadUser = StringUtils.trimToEmpty(((String) properties.get(DOWNLOAD_USER)));\n    downloadSource = StringUtils.trimToEmpty(((String) properties.get(DOWNLOAD_SOURCE)));\n\n    skipAttachments = BooleanUtils.toBoolean(Objects.toString(properties.get(SKIP_ATTACHMENTS_KEY),\n            BooleanUtils.toStringTrueFalse(DEFAULT_SKIP)));\n    skipCatalogs = BooleanUtils.toBoolean(Objects.toString(properties.get(SKIP_CATALOGS_KEY),\n            BooleanUtils.toStringTrueFalse(DEFAULT_SKIP)));\n    logger.debug(\"Skip attachments sent by agents for scheduled events: {}\", skipAttachments);\n    logger.debug(\"Skip metadata catalogs sent by agents for scheduled events: {}\", skipCatalogs);\n\n    ingestFileJobLoad = LoadUtil.getConfiguredLoadValue(properties, FILE_JOB_LOAD_KEY, DEFAULT_INGEST_FILE_JOB_LOAD,\n            serviceRegistry);\n    ingestZipJobLoad = LoadUtil.getConfiguredLoadValue(properties, ZIP_JOB_LOAD_KEY, DEFAULT_INGEST_ZIP_JOB_LOAD,\n            serviceRegistry);\n\n    isAllowModifySeries = BooleanUtils.toBoolean(Objects.toString(properties.get(MODIFY_OPENCAST_SERIES_KEY),\n              BooleanUtils.toStringTrueFalse(DEFAULT_ALLOW_SERIES_MODIFICATIONS)));\n    isAddOnlyNew = BooleanUtils.toBoolean(Objects.toString(properties.get(ADD_ONLY_NEW_FLAVORS_KEY),\n            BooleanUtils.toStringTrueFalse(DEFAULT_ALLOW_ONLY_NEW_FLAVORS)));\n    logger.info(\"Only allow new flavored catalogs and attachments on ingest:'{}'\", isAddOnlyNew);\n    logger.info(\"Allowing series modification:'{}'\", isAllowModifySeries);\n  }\n\n  /**\n   * Sets the trusted http client\n   *\n   * @param httpClient\n   *          the http client\n   */\n  @Reference\n  public void setHttpClient(TrustedHttpClient httpClient) {\n    this.httpClient = httpClient;\n  }\n\n  /**\n   * Sets the service registry\n   *\n   * @param serviceRegistry\n   *          the serviceRegistry to set\n   */\n  @Reference\n  public void setServiceRegistry(ServiceRegistry serviceRegistry) {\n    this.serviceRegistry = serviceRegistry;\n  }\n\n  /**\n   * Sets the media inspection service\n   *\n   * @param mediaInspectionService\n   *          the media inspection service to set\n   */\n  @Reference\n  public void setMediaInspectionService(MediaInspectionService mediaInspectionService) {\n    this.mediaInspectionService = mediaInspectionService;\n  }\n\n  public WorkflowInstance addZippedMediaPackage(InputStream zipStream)\n          throws IngestException, IOException, MediaPackageException {\n    try {\n      return addZippedMediaPackage(zipStream, null, null);\n    } catch (NotFoundException e) {\n      throw new IllegalStateException(\"A not found exception was thrown without a lookup\");\n    }\n  }\n\n  @Override\n  public WorkflowInstance addZippedMediaPackage(InputStream zipStream, String wd, Map<String, String> workflowConfig)\n          throws MediaPackageException, IOException, IngestException, NotFoundException {\n    try {\n      return addZippedMediaPackage(zipStream, wd, workflowConfig, null);\n    } catch (UnauthorizedException e) {\n      throw new IllegalStateException(e);\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#addZippedMediaPackage(java.io.InputStream, java.lang.String,\n   *      java.util.Map, java.lang.Long)\n   */\n  @Override\n  public WorkflowInstance addZippedMediaPackage(InputStream zipStream, String workflowDefinitionId,\n          Map<String, String> workflowConfig, Long workflowInstanceId)\n          throws MediaPackageException, IOException, IngestException, NotFoundException, UnauthorizedException {\n    // Start a job synchronously. We can't keep the open input stream waiting around.\n    Job job = null;\n\n    if (StringUtils.isNotBlank(workflowDefinitionId)) {\n      try {\n        workflowService.getWorkflowDefinitionById(workflowDefinitionId);\n      } catch (WorkflowDatabaseException e) {\n        throw new IngestException(e);\n      } catch (NotFoundException nfe) {\n        logger.warn(\"Workflow definition {} not found, using default workflow {} instead\", workflowDefinitionId,\n                defaultWorkflowDefinionId);\n        workflowDefinitionId = defaultWorkflowDefinionId;\n      }\n    }\n\n    if (workflowInstanceId != null) {\n      logger.warn(\"Deprecated method! Ingesting zipped mediapackage with workflow {}\", workflowInstanceId);\n    } else {\n      logger.info(\"Ingesting zipped mediapackage\");\n    }\n\n    ZipArchiveInputStream zis = null;\n    Set<String> collectionFilenames = new HashSet<>();\n    try {\n      // We don't need anybody to do the dispatching for us. Therefore we need to make sure that the job is never in\n      // QUEUED state but set it to INSTANTIATED in the beginning and then manually switch it to RUNNING.\n      job = serviceRegistry.createJob(JOB_TYPE, INGEST_ZIP, null, null, false, ingestZipJobLoad);\n      job.setStatus(Status.RUNNING);\n      job = serviceRegistry.updateJob(job);\n\n      // Create the working file target collection for this ingest operation\n      String wfrCollectionId = Long.toString(job.getId());\n\n      zis = new ZipArchiveInputStream(zipStream);\n      ZipArchiveEntry entry;\n      MediaPackage mp = null;\n      Map<String, URI> uris = new HashMap<>();\n      // Sequential number to append to file names so that, if two files have the same\n      // name, one does not overwrite the other (see MH-9688)\n      int seq = 1;\n      // Folder name to compare with next one to figure out if there's a root folder\n      String folderName = null;\n      // Indicates if zip has a root folder or not, initialized as true\n      boolean hasRootFolder = true;\n      // While there are entries write them to a collection\n      while ((entry = zis.getNextZipEntry()) != null) {\n        try {\n          if (entry.isDirectory() || entry.getName().contains(\"__MACOSX\"))\n            continue;\n\n          if (entry.getName().endsWith(\"manifest.xml\") || entry.getName().endsWith(\"index.xml\")) {\n            // Build the media package\n            final InputStream is = new ZipEntryInputStream(zis, entry.getSize());\n            mp = MediaPackageParser.getFromXml(IOUtils.toString(is, StandardCharsets.UTF_8));\n          } else {\n            logger.info(\"Storing zip entry {}/{} in working file repository collection '{}'\", job.getId(),\n                    entry.getName(), wfrCollectionId);\n            // Since the directory structure is not being mirrored, makes sure the file\n            // name is different than the previous one(s) by adding a sequential number\n            String fileName = FilenameUtils.getBaseName(entry.getName()) + \"_\" + seq++ + \".\"\n                    + FilenameUtils.getExtension(entry.getName());\n            URI contentUri = workingFileRepository.putInCollection(wfrCollectionId, fileName,\n                    new ZipEntryInputStream(zis, entry.getSize()));\n            collectionFilenames.add(fileName);\n            // Key is the zip entry name as it is\n            String key = entry.getName();\n            uris.put(key, contentUri);\n            ingestStatistics.add(entry.getSize());\n            logger.info(\"Zip entry {}/{} stored at {}\", job.getId(), entry.getName(), contentUri);\n            // Figures out if there's a root folder. Does entry name starts with a folder?\n            int pos = entry.getName().indexOf('/');\n            if (pos == -1) {\n              // No, we can conclude there's no root folder\n              hasRootFolder = false;\n            } else if (hasRootFolder && folderName != null && !folderName.equals(entry.getName().substring(0, pos))) {\n              // Folder name different from previous so there's no root folder\n              hasRootFolder = false;\n            } else if (folderName == null) {\n              // Just initialize folder name\n              folderName = entry.getName().substring(0, pos);\n            }\n          }\n        } catch (IOException e) {\n          logger.warn(\"Unable to process zip entry {}: {}\", entry.getName(), e);\n          throw e;\n        }\n      }\n\n      if (mp == null)\n        throw new MediaPackageException(\"No manifest found in this zip\");\n\n      // Determine the mediapackage identifier\n      if (mp.getIdentifier() == null || isBlank(mp.getIdentifier().toString()))\n        mp.setIdentifier(IdImpl.fromUUID());\n\n      String mediaPackageId = mp.getIdentifier().toString();\n\n      logger.info(\"Ingesting mediapackage {} is named '{}'\", mediaPackageId, mp.getTitle());\n\n      // Make sure there are tracks in the mediapackage\n      if (mp.getTracks().length == 0) {\n        logger.warn(\"Mediapackage {} has no media tracks\", mediaPackageId);\n      }\n\n      // Update the element uris to point to their working file repository location\n      for (MediaPackageElement element : mp.elements()) {\n        // Key has root folder name if there is one\n        URI uri = uris.get((hasRootFolder ? folderName + \"/\" : \"\") + element.getURI().toString());\n\n        if (uri == null)\n          throw new MediaPackageException(\"Unable to map element name '\" + element.getURI() + \"' to workspace uri\");\n        logger.info(\"Ingested mediapackage element {}/{} located at {}\", mediaPackageId, element.getIdentifier(), uri);\n        URI dest = workingFileRepository.moveTo(wfrCollectionId, FilenameUtils.getName(uri.toString()), mediaPackageId,\n                element.getIdentifier(), FilenameUtils.getName(element.getURI().toString()));\n        element.setURI(dest);\n\n        // TODO: This should be triggered somehow instead of being handled here\n        if (MediaPackageElements.SERIES.equals(element.getFlavor())) {\n          logger.info(\"Ingested mediapackage {} contains updated series information\", mediaPackageId);\n          updateSeries(element.getURI());\n        }\n      }\n\n      // Now that all elements are in place, start with ingest\n      logger.info(\"Initiating processing of ingested mediapackage {}\", mediaPackageId);\n      WorkflowInstance workflowInstance = ingest(mp, workflowDefinitionId, workflowConfig, workflowInstanceId);\n      logger.info(\"Ingest of mediapackage {} done\", mediaPackageId);\n      job.setStatus(Job.Status.FINISHED);\n      return workflowInstance;\n    } catch (ServiceRegistryException e) {\n      throw new IngestException(e);\n    } catch (MediaPackageException e) {\n      job.setStatus(Job.Status.FAILED, Job.FailureReason.DATA);\n      throw e;\n    } catch (Exception e) {\n      if (e instanceof IngestException)\n        throw (IngestException) e;\n      throw new IngestException(e);\n    } finally {\n      IOUtils.closeQuietly(zis);\n      finallyUpdateJob(job);\n      for (String filename : collectionFilenames) {\n        workingFileRepository.deleteFromCollection(Long.toString(job.getId()), filename, true);\n      }\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#createMediaPackage()\n   */\n  @Override\n  public MediaPackage createMediaPackage() throws MediaPackageException, ConfigurationException {\n    MediaPackage mediaPackage;\n    try {\n      mediaPackage = MediaPackageBuilderFactory.newInstance().newMediaPackageBuilder().createNew();\n    } catch (MediaPackageException e) {\n      logger.error(\"INGEST:Failed to create media package \" + e.getLocalizedMessage());\n      throw e;\n    }\n    mediaPackage.setDate(new Date());\n    logger.info(\"Created mediapackage {}\", mediaPackage);\n    return mediaPackage;\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#createMediaPackage()\n   */\n  @Override\n  public MediaPackage createMediaPackage(String mediaPackageId)\n          throws MediaPackageException, ConfigurationException {\n    MediaPackage mediaPackage;\n    try {\n      mediaPackage = MediaPackageBuilderFactory.newInstance().newMediaPackageBuilder()\n              .createNew(new IdImpl(mediaPackageId));\n    } catch (MediaPackageException e) {\n      logger.error(\"INGEST:Failed to create media package \" + e.getLocalizedMessage());\n      throw e;\n    }\n    mediaPackage.setDate(new Date());\n    logger.info(\"Created mediapackage {}\", mediaPackage);\n    return mediaPackage;\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#addTrack(java.net.URI,\n   *      org.opencastproject.mediapackage.MediaPackageElementFlavor, org.opencastproject.mediapackage.MediaPackage)\n   */\n  @Override\n  public MediaPackage addTrack(URI uri, MediaPackageElementFlavor flavor, MediaPackage mediaPackage)\n          throws IOException, IngestException {\n    String[] tags = null;\n    return this.addTrack(uri, flavor, tags, mediaPackage);\n\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#addTrack(java.net.URI,\n   *      org.opencastproject.mediapackage.MediaPackageElementFlavor, String[] ,\n   *      org.opencastproject.mediapackage.MediaPackage)\n   */\n  @Override\n  public MediaPackage addTrack(URI uri, MediaPackageElementFlavor flavor, String[] tags, MediaPackage mediaPackage)\n          throws IOException, IngestException {\n    Job job = null;\n    try {\n      job = serviceRegistry\n              .createJob(\n                      JOB_TYPE, INGEST_TRACK_FROM_URI, Arrays.asList(uri.toString(),\n                              flavor == null ? null : flavor.toString(), MediaPackageParser.getAsXml(mediaPackage)),\n                      null, false, ingestFileJobLoad);\n      job.setStatus(Status.RUNNING);\n      job = serviceRegistry.updateJob(job);\n      String elementId = UUID.randomUUID().toString();\n      logger.info(\"Start adding track {} from URL {} on mediapackage {}\", elementId, uri, mediaPackage);\n      URI newUrl = addContentToRepo(mediaPackage, elementId, uri);\n      MediaPackage mp = addContentToMediaPackage(mediaPackage, elementId, newUrl, MediaPackageElement.Type.Track,\n              flavor);\n      if (tags != null && tags.length > 0) {\n        MediaPackageElement trackElement = mp.getTrack(elementId);\n        for (String tag : tags) {\n          logger.info(\"Adding Tag: \" + tag + \" to Element: \" + elementId);\n          trackElement.addTag(tag);\n        }\n      }\n\n      job.setStatus(Job.Status.FINISHED);\n      logger.info(\"Successful added track {} on mediapackage {} at URL {}\", elementId, mediaPackage, newUrl);\n      return mp;\n    } catch (IOException e) {\n      throw e;\n    } catch (ServiceRegistryException e) {\n      throw new IngestException(e);\n    } catch (NotFoundException e) {\n      throw new IngestException(\"Unable to update ingest job\", e);\n    } finally {\n      finallyUpdateJob(job);\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#addTrack(java.io.InputStream, java.lang.String,\n   *      org.opencastproject.mediapackage.MediaPackageElementFlavor, org.opencastproject.mediapackage.MediaPackage)\n   */\n  @Override\n  public MediaPackage addTrack(InputStream in, String fileName, MediaPackageElementFlavor flavor,\n          MediaPackage mediaPackage) throws IOException, IngestException {\n    String[] tags = null;\n    return this.addTrack(in, fileName, flavor, tags, mediaPackage);\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#addTrack(java.io.InputStream, java.lang.String,\n   *      org.opencastproject.mediapackage.MediaPackageElementFlavor, org.opencastproject.mediapackage.MediaPackage)\n   */\n  @Override\n  public MediaPackage addTrack(InputStream in, String fileName, MediaPackageElementFlavor flavor, String[] tags,\n          MediaPackage mediaPackage) throws IOException, IngestException {\n    Job job = null;\n    try {\n      job = serviceRegistry.createJob(JOB_TYPE, INGEST_TRACK, null, null, false, ingestFileJobLoad);\n      job.setStatus(Status.RUNNING);\n      job = serviceRegistry.updateJob(job);\n      String elementId = UUID.randomUUID().toString();\n      logger.info(\"Start adding track {} from input stream on mediapackage {}\", elementId, mediaPackage);\n      if (fileName.length() > FILENAME_LENGTH_MAX) {\n        final String extension = \".\" + FilenameUtils.getExtension(fileName);\n        final int length = Math.max(0, FILENAME_LENGTH_MAX - extension.length());\n        fileName = fileName.substring(0, length) + extension;\n      }\n      URI newUrl = addContentToRepo(mediaPackage, elementId, fileName, in);\n      MediaPackage mp = addContentToMediaPackage(mediaPackage, elementId, newUrl, MediaPackageElement.Type.Track,\n              flavor);\n      if (tags != null && tags.length > 0) {\n        MediaPackageElement trackElement = mp.getTrack(elementId);\n        for (String tag : tags) {\n          logger.debug(\"Adding tag `{}` to element {}\", tag, elementId);\n          trackElement.addTag(tag);\n        }\n      }\n\n      job.setStatus(Job.Status.FINISHED);\n      logger.info(\"Successful added track {} on mediapackage {} at URL {}\", elementId, mediaPackage, newUrl);\n      return mp;\n    } catch (IOException e) {\n      throw e;\n    } catch (ServiceRegistryException e) {\n      throw new IngestException(e);\n    } catch (NotFoundException e) {\n      throw new IngestException(\"Unable to update ingest job\", e);\n    } finally {\n      finallyUpdateJob(job);\n    }\n  }\n\n  @Override\n  public MediaPackage addPartialTrack(URI uri, MediaPackageElementFlavor flavor, long startTime,\n          MediaPackage mediaPackage) throws IOException, IngestException {\n    Job job = null;\n    try {\n      job = serviceRegistry.createJob(\n              JOB_TYPE,\n              INGEST_TRACK_FROM_URI,\n              Arrays.asList(uri.toString(), flavor == null ? null : flavor.toString(),\n                      MediaPackageParser.getAsXml(mediaPackage)), null, false);\n      job.setStatus(Status.RUNNING);\n      job = serviceRegistry.updateJob(job);\n      String elementId = UUID.randomUUID().toString();\n      logger.info(\"Start adding partial track {} from URL {} on mediapackage {}\", elementId, uri, mediaPackage);\n      URI newUrl = addContentToRepo(mediaPackage, elementId, uri);\n      MediaPackage mp = addContentToMediaPackage(mediaPackage, elementId, newUrl, MediaPackageElement.Type.Track,\n              flavor);\n      job.setStatus(Job.Status.FINISHED);\n      // store startTime\n      partialTrackStartTimes.put(elementId, startTime);\n      logger.debug(\"Added start time {} for track {}\", startTime, elementId);\n      logger.info(\"Successful added partial track {} on mediapackage {} at URL {}\", elementId, mediaPackage, newUrl);\n      return mp;\n    } catch (ServiceRegistryException e) {\n      throw new IngestException(e);\n    } catch (NotFoundException e) {\n      throw new IngestException(\"Unable to update ingest job\", e);\n    } finally {\n      finallyUpdateJob(job);\n    }\n  }\n\n  @Override\n  public MediaPackage addPartialTrack(InputStream in, String fileName, MediaPackageElementFlavor flavor, long startTime,\n          MediaPackage mediaPackage) throws IOException, IngestException {\n    Job job = null;\n    try {\n      job = serviceRegistry.createJob(JOB_TYPE, INGEST_TRACK, null, null, false);\n      job.setStatus(Status.RUNNING);\n      job = serviceRegistry.updateJob(job);\n      String elementId = UUID.randomUUID().toString();\n      logger.info(\"Start adding partial track {} from input stream on mediapackage {}\", elementId, mediaPackage);\n      URI newUrl = addContentToRepo(mediaPackage, elementId, fileName, in);\n      MediaPackage mp = addContentToMediaPackage(mediaPackage, elementId, newUrl, MediaPackageElement.Type.Track,\n              flavor);\n      job.setStatus(Job.Status.FINISHED);\n      // store startTime\n      partialTrackStartTimes.put(elementId, startTime);\n      logger.debug(\"Added start time {} for track {}\", startTime, elementId);\n      logger.info(\"Successful added partial track {} on mediapackage {} at URL {}\", elementId, mediaPackage, newUrl);\n      return mp;\n    } catch (ServiceRegistryException e) {\n      throw new IngestException(e);\n    } catch (NotFoundException e) {\n      throw new IngestException(\"Unable to update ingest job\", e);\n    } finally {\n      finallyUpdateJob(job);\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#addCatalog(java.net.URI,\n   *      org.opencastproject.mediapackage.MediaPackageElementFlavor, org.opencastproject.mediapackage.MediaPackage)\n   */\n  @Override\n  public MediaPackage addCatalog(URI uri, MediaPackageElementFlavor flavor, MediaPackage mediaPackage)\n          throws IOException, IngestException {\n    Job job = null;\n    try {\n      job = serviceRegistry.createJob(JOB_TYPE, INGEST_CATALOG_FROM_URI,\n              Arrays.asList(uri.toString(), flavor.toString(), MediaPackageParser.getAsXml(mediaPackage)), null, false,\n              ingestFileJobLoad);\n      job.setStatus(Status.RUNNING);\n      job = serviceRegistry.updateJob(job);\n      String elementId = UUID.randomUUID().toString();\n      logger.info(\"Start adding catalog {} from URL {} on mediapackage {}\", elementId, uri, mediaPackage);\n      URI newUrl = addContentToRepo(mediaPackage, elementId, uri);\n      if (MediaPackageElements.SERIES.equals(flavor)) {\n        updateSeries(uri);\n      }\n      MediaPackage mp = addContentToMediaPackage(mediaPackage, elementId, newUrl, MediaPackageElement.Type.Catalog,\n              flavor);\n      job.setStatus(Job.Status.FINISHED);\n      logger.info(\"Successful added catalog {} on mediapackage {} at URL {}\", elementId, mediaPackage, newUrl);\n      return mp;\n    } catch (ServiceRegistryException e) {\n      throw new IngestException(e);\n    } catch (NotFoundException e) {\n      throw new IngestException(\"Unable to update ingest job\", e);\n    } finally {\n      finallyUpdateJob(job);\n    }\n  }\n\n  /**\n   * Updates the persistent representation of a series based on a potentially modified dublin core document.\n   *\n   * @param uri\n   *          the URI to the dublin core document containing series metadata.\n   * @return\n   *         true, if the series is created or overwritten, false if the existing series remains intact.\n   * @throws IOException if the series catalog was not found\n   * @throws IngestException if any other exception was encountered\n   */\n  protected boolean updateSeries(URI uri) throws IOException, IngestException {\n    HttpResponse response = null;\n    InputStream in = null;\n    boolean isUpdated = false;\n    try {\n      HttpGet getDc = new HttpGet(uri);\n      response = httpClient.execute(getDc);\n      in = response.getEntity().getContent();\n      DublinCoreCatalog dc = dublinCoreService.load(in);\n      String id = dc.getFirst(DublinCore.PROPERTY_IDENTIFIER);\n      if (id == null) {\n        logger.warn(\"Series dublin core document contains no identifier, rejecting ingested series cagtalog.\");\n      } else {\n        try {\n          try {\n            seriesService.getSeries(id);\n            if (isAllowModifySeries) {\n              // Update existing series\n              seriesService.updateSeries(dc);\n              isUpdated = true;\n              logger.debug(\"Ingest is overwriting the existing series {} with the ingested series\", id);\n            } else {\n              logger.debug(\"Series {} already exists. Ignoring series catalog from ingest.\", id);\n            }\n          } catch (NotFoundException e) {\n            logger.info(\"Creating new series {} with default ACL\", id);\n            seriesService.updateSeries(dc);\n            isUpdated = true;\n          }\n\n        } catch (Exception e) {\n          throw new IngestException(e);\n        }\n      }\n      in.close();\n    } catch (IOException e) {\n      logger.error(\"Error updating series from DublinCoreCatalog: {}\", e.getMessage());\n    } finally {\n      IOUtils.closeQuietly(in);\n      httpClient.close(response);\n    }\n    return isUpdated;\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#addCatalog(java.io.InputStream, java.lang.String,\n   *      org.opencastproject.mediapackage.MediaPackageElementFlavor, org.opencastproject.mediapackage.MediaPackage)\n   */\n  @Override\n  public MediaPackage addCatalog(InputStream in, String fileName, MediaPackageElementFlavor flavor,\n          MediaPackage mediaPackage) throws IOException, IngestException {\n    return addCatalog(in, fileName, flavor, null, mediaPackage);\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#addCatalog(java.io.InputStream, java.lang.String,\n   *      org.opencastproject.mediapackage.MediaPackageElementFlavor, org.opencastproject.mediapackage.MediaPackage)\n   */\n  @Override\n  public MediaPackage addCatalog(InputStream in, String fileName, MediaPackageElementFlavor flavor, String[] tags,\n          MediaPackage mediaPackage) throws IOException, IngestException, IllegalArgumentException {\n    Job job = null;\n    try {\n      job = serviceRegistry.createJob(JOB_TYPE, INGEST_CATALOG, null, null, false, ingestFileJobLoad);\n      job.setStatus(Status.RUNNING);\n      job = serviceRegistry.updateJob(job);\n      final String elementId = UUID.randomUUID().toString();\n      final String mediaPackageId = mediaPackage.getIdentifier().toString();\n      logger.info(\"Start adding catalog {} from input stream on mediapackage {}\", elementId, mediaPackageId);\n      final URI newUrl = addContentToRepo(mediaPackage, elementId, fileName, in);\n\n      final boolean isJSON;\n      try (InputStream inputStream = workingFileRepository.get(mediaPackageId, elementId)) {\n        try (BufferedReader reader  = new BufferedReader(new InputStreamReader(inputStream, StandardCharsets.UTF_8))) {\n          // Exception for current BBB integration and Extron SMP351 which is ingesting a JSON array/object as catalog\n          int firstChar = reader.read();\n          isJSON = firstChar == '[' || firstChar == '{';\n        }\n      }\n\n      if (isJSON) {\n        logger.warn(\"Input catalog seems to be JSON. This is a mistake and will fail in future Opencast versions.\"\n            + \"You will likely want to ingest this as a media package attachment instead.\");\n      } else {\n        // Verify XML is not corrupted\n        try {\n          XmlSafeParser.parse(workingFileRepository.get(mediaPackageId, elementId));\n        } catch (SAXException e) {\n          workingFileRepository.delete(mediaPackageId, elementId);\n          throw new IllegalArgumentException(\"Catalog XML is invalid\", e);\n        }\n      }\n\n      if (MediaPackageElements.SERIES.equals(flavor)) {\n        updateSeries(newUrl);\n      }\n      MediaPackage mp = addContentToMediaPackage(mediaPackage, elementId, newUrl, MediaPackageElement.Type.Catalog,\n              flavor);\n      if (tags != null && tags.length > 0) {\n        MediaPackageElement trackElement = mp.getCatalog(elementId);\n        for (String tag : tags) {\n          logger.info(\"Adding tag {} to element {}\", tag, elementId);\n          trackElement.addTag(tag);\n        }\n      }\n\n      job.setStatus(Job.Status.FINISHED);\n      logger.info(\"Successful added catalog {} on mediapackage {} at URL {}\", elementId, mediaPackage, newUrl);\n      return mp;\n    } catch (ServiceRegistryException e) {\n      throw new IngestException(e);\n    } catch (NotFoundException e) {\n      throw new IngestException(\"Unable to update ingest job\", e);\n    } finally {\n      finallyUpdateJob(job);\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#addAttachment(java.net.URI,\n   *      org.opencastproject.mediapackage.MediaPackageElementFlavor, org.opencastproject.mediapackage.MediaPackage)\n   */\n  @Override\n  public MediaPackage addAttachment(URI uri, MediaPackageElementFlavor flavor, MediaPackage mediaPackage)\n          throws IOException, IngestException {\n    Job job = null;\n    try {\n      job = serviceRegistry.createJob(JOB_TYPE, INGEST_ATTACHMENT_FROM_URI,\n              Arrays.asList(uri.toString(), flavor.toString(), MediaPackageParser.getAsXml(mediaPackage)), null, false,\n              ingestFileJobLoad);\n      job.setStatus(Status.RUNNING);\n      job = serviceRegistry.updateJob(job);\n      String elementId = UUID.randomUUID().toString();\n      logger.info(\"Start adding attachment {} from URL {} on mediapackage {}\", elementId, uri, mediaPackage);\n      URI newUrl = addContentToRepo(mediaPackage, elementId, uri);\n      MediaPackage mp = addContentToMediaPackage(mediaPackage, elementId, newUrl, MediaPackageElement.Type.Attachment,\n              flavor);\n      job.setStatus(Job.Status.FINISHED);\n      logger.info(\"Successful added attachment {} on mediapackage {} at URL {}\", elementId, mediaPackage, newUrl);\n      return mp;\n    } catch (ServiceRegistryException e) {\n      throw new IngestException(e);\n    } catch (NotFoundException e) {\n      throw new IngestException(\"Unable to update ingest job\", e);\n    } finally {\n      finallyUpdateJob(job);\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#addAttachment(java.io.InputStream, java.lang.String,\n   *      org.opencastproject.mediapackage.MediaPackageElementFlavor, org.opencastproject.mediapackage.MediaPackage)\n   */\n  @Override\n  public MediaPackage addAttachment(InputStream in, String fileName, MediaPackageElementFlavor flavor, String[] tags,\n          MediaPackage mediaPackage) throws IOException, IngestException {\n    Job job = null;\n    try {\n      job = serviceRegistry.createJob(JOB_TYPE, INGEST_ATTACHMENT, null, null, false, ingestFileJobLoad);\n      job.setStatus(Status.RUNNING);\n      job = serviceRegistry.updateJob(job);\n      String elementId = UUID.randomUUID().toString();\n      logger.info(\"Start adding attachment {} from input stream on mediapackage {}\", elementId, mediaPackage);\n      URI newUrl = addContentToRepo(mediaPackage, elementId, fileName, in);\n      MediaPackage mp = addContentToMediaPackage(mediaPackage, elementId, newUrl, MediaPackageElement.Type.Attachment,\n              flavor);\n      if (tags != null && tags.length > 0) {\n        MediaPackageElement trackElement = mp.getAttachment(elementId);\n        for (String tag : tags) {\n          logger.info(\"Adding Tag: \" + tag + \" to Element: \" + elementId);\n          trackElement.addTag(tag);\n        }\n      }\n      job.setStatus(Job.Status.FINISHED);\n      logger.info(\"Successful added attachment {} on mediapackage {} at URL {}\", elementId, mediaPackage, newUrl);\n      return mp;\n    } catch (ServiceRegistryException e) {\n      throw new IngestException(e);\n    } catch (NotFoundException e) {\n      throw new IngestException(\"Unable to update ingest job\", e);\n    } finally {\n      finallyUpdateJob(job);\n    }\n\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#addAttachment(java.io.InputStream, java.lang.String,\n   *      org.opencastproject.mediapackage.MediaPackageElementFlavor, org.opencastproject.mediapackage.MediaPackage)\n   */\n  @Override\n  public MediaPackage addAttachment(InputStream in, String fileName, MediaPackageElementFlavor flavor,\n          MediaPackage mediaPackage) throws IOException, IngestException {\n    String[] tags = null;\n    return addAttachment(in, fileName, flavor, tags, mediaPackage);\n  }\n\n  /**\n   *\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#ingest(org.opencastproject.mediapackage.MediaPackage)\n   */\n  @Override\n  public WorkflowInstance ingest(MediaPackage mp) throws IngestException {\n    try {\n      return ingest(mp, null, null, null);\n    } catch (NotFoundException e) {\n      throw new IngestException(e);\n    } catch (UnauthorizedException e) {\n      throw new IllegalStateException(e);\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#ingest(org.opencastproject.mediapackage.MediaPackage,\n   *      java.lang.String, java.util.Map)\n   */\n  @Override\n  public WorkflowInstance ingest(MediaPackage mp, String wd, Map<String, String> properties)\n          throws IngestException, NotFoundException {\n    try {\n      return ingest(mp, wd, properties, null);\n    } catch (UnauthorizedException e) {\n      throw new IllegalStateException(e);\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#ingest(org.opencastproject.mediapackage.MediaPackage,\n   *      java.lang.String, java.util.Map, java.lang.Long)\n   */\n  @Override\n  public WorkflowInstance ingest(MediaPackage mp, String workflowDefinitionId, Map<String, String> properties,\n          Long workflowInstanceId) throws IngestException, NotFoundException, UnauthorizedException {\n    // Check for legacy media package id\n    mp = checkForLegacyMediaPackageId(mp, properties);\n\n    try {\n      mp = createSmil(mp);\n    } catch (IOException e) {\n      throw new IngestException(\"Unable to add SMIL Catalog\", e);\n    }\n\n    // Done, update the job status and return the created workflow instance\n    if (workflowInstanceId != null) {\n      logger.warn(\n              \"Resuming workflow {} with ingested mediapackage {} is deprecated, skip resuming and start new workflow\",\n              workflowInstanceId, mp);\n    }\n\n    if (workflowDefinitionId == null) {\n      logger.info(\"Starting a new workflow with ingested mediapackage {} based on the default workflow definition '{}'\",\n              mp, defaultWorkflowDefinionId);\n    } else {\n      logger.info(\"Starting a new workflow with ingested mediapackage {} based on workflow definition '{}'\", mp,\n              workflowDefinitionId);\n    }\n\n    try {\n      // Determine the workflow definition\n      WorkflowDefinition workflowDef = getWorkflowDefinition(workflowDefinitionId, mp);\n\n      // Get the final set of workflow properties\n      properties = mergeWorkflowConfiguration(properties, mp.getIdentifier().toString());\n\n      // Remove potential workflow configuration prefixes from the workflow properties\n      properties = removePrefixFromProperties(properties);\n\n      // Merge scheduled mediapackage with ingested\n      mp = mergeScheduledMediaPackage(mp);\n\n      ingestStatistics.successful();\n      if (workflowDef != null) {\n        logger.info(\"Starting new workflow with ingested mediapackage '{}' using the specified template '{}'\",\n                mp.getIdentifier().toString(), workflowDefinitionId);\n      } else {\n        logger.info(\"Starting new workflow with ingested mediapackage '{}' using the default template '{}'\",\n                mp.getIdentifier().toString(), defaultWorkflowDefinionId);\n      }\n      return workflowService.start(workflowDef, mp, properties);\n    } catch (WorkflowException e) {\n      ingestStatistics.failed();\n      throw new IngestException(e);\n    }\n  }\n\n  @Override\n  public void schedule(MediaPackage mediaPackage, String workflowDefinitionID, Map<String, String> properties)\n          throws IllegalStateException, IngestException, NotFoundException, UnauthorizedException, SchedulerException {\n    MediaPackageElement[] mediaPackageElements = mediaPackage.getElementsByFlavor(MediaPackageElements.EPISODE);\n    if (mediaPackageElements.length != 1) {\n      logger.debug(\"There can be only one (and exactly one) episode dublin core catalog: https://youtu.be/_J3VeogFUOs\");\n      throw new IngestException(\"There can be only one (and exactly one) episode dublin core catalog\");\n    }\n    InputStream inputStream;\n    DublinCoreCatalog dublinCoreCatalog;\n    try {\n      inputStream = workingFileRepository.get(mediaPackage.getIdentifier().toString(),\n              mediaPackageElements[0].getIdentifier());\n      dublinCoreCatalog = dublinCoreService.load(inputStream);\n    } catch (IOException e) {\n      throw new IngestException(e);\n    }\n\n    EName temporal = new EName(DublinCore.TERMS_NS_URI, \"temporal\");\n    List<DublinCoreValue> periods = dublinCoreCatalog.get(temporal);\n    if (periods.size() != 1) {\n      logger.debug(\"There can be only one (and exactly one) period\");\n      throw new IngestException(\"There can be only one (and exactly one) period\");\n    }\n    DCMIPeriod period = EncodingSchemeUtils.decodeMandatoryPeriod(periods.get(0));\n    if (!period.hasStart() || !period.hasEnd()) {\n      logger.debug(\"A scheduled recording needs to have a start and end.\");\n      throw new IngestException(\"A scheduled recording needs to have a start and end.\");\n    }\n    EName createdEName = new EName(DublinCore.TERMS_NS_URI, \"created\");\n    List<DublinCoreValue> created = dublinCoreCatalog.get(createdEName);\n    if (created.size() == 0) {\n      logger.debug(\"Created not set\");\n    } else if (created.size() == 1) {\n      Date date = EncodingSchemeUtils.decodeMandatoryDate(created.get(0));\n      if (date.getTime() != period.getStart().getTime()) {\n        logger.debug(\"start and created date differ ({} vs {})\", date.getTime(), period.getStart().getTime());\n        throw new IngestException(\"Temporal start and created date differ\");\n      }\n    } else {\n      logger.debug(\"There can be only one created date\");\n      throw new IngestException(\"There can be only one created date\");\n    }\n    // spatial\n    EName spatial = new EName(DublinCore.TERMS_NS_URI, \"spatial\");\n    List<DublinCoreValue> captureAgents = dublinCoreCatalog.get(spatial);\n    if (captureAgents.size() != 1) {\n      logger.debug(\"Exactly one capture agent needs to be set\");\n      throw new IngestException(\"Exactly one capture agent needs to be set\");\n    }\n    String captureAgent = captureAgents.get(0).getValue();\n\n    // Go through properties\n    Map<String, String> agentProperties = new HashMap<>();\n    Map<String, String> workflowProperties = new HashMap<>();\n    for (String key : properties.keySet()) {\n      if (key.startsWith(\"org.opencastproject.workflow.config.\")) {\n        workflowProperties.put(key, properties.get(key));\n      } else {\n        agentProperties.put(key, properties.get(key));\n      }\n    }\n    try {\n      schedulerService.addEvent(period.getStart(), period.getEnd(), captureAgent, new HashSet<>(), mediaPackage,\n              workflowProperties, agentProperties, Opt.none());\n    } finally {\n      for (MediaPackageElement mediaPackageElement : mediaPackage.getElements()) {\n        try {\n          workingFileRepository.delete(mediaPackage.getIdentifier().toString(), mediaPackageElement.getIdentifier());\n        } catch (IOException e) {\n          logger.warn(\"Failed to delete media package element\", e);\n        }\n      }\n    }\n  }\n\n  /**\n   * Check whether the mediapackage id is set via the legacy workflow identifier and change the id if existing.\n   *\n   * @param mp\n   *          the mediapackage\n   * @param properties\n   *          the workflow properties\n   * @return the mediapackage\n   */\n  private MediaPackage checkForLegacyMediaPackageId(MediaPackage mp, Map<String, String> properties)\n          throws IngestException {\n    if (properties == null || properties.isEmpty())\n      return mp;\n\n    try {\n      String mediaPackageId = properties.get(LEGACY_MEDIAPACKAGE_ID_KEY);\n      if (StringUtils.isNotBlank(mediaPackageId) && schedulerService != null) {\n        logger.debug(\"Check ingested mediapackage {} for legacy mediapackage identifier {}\",\n                mp.getIdentifier().toString(), mediaPackageId);\n        try {\n          schedulerService.getMediaPackage(mp.getIdentifier().toString());\n          return mp;\n        } catch (NotFoundException e) {\n          logger.info(\"No scheduler mediapackage found with ingested id {}, try legacy mediapackage id {}\",\n                  mp.getIdentifier().toString(), mediaPackageId);\n          try {\n            schedulerService.getMediaPackage(mediaPackageId);\n            logger.info(\"Legacy mediapackage id {} exists, change ingested mediapackage id {} to legacy id\",\n                    mediaPackageId, mp.getIdentifier().toString());\n            mp.setIdentifier(new IdImpl(mediaPackageId));\n            return mp;\n          } catch (NotFoundException e1) {\n            logger.info(\"No scheduler mediapackage found with legacy mediapackage id {}, skip merging\", mediaPackageId);\n          } catch (Exception e1) {\n            logger.error(\"Unable to get event mediapackage from scheduler event {}\", mediaPackageId, e);\n            throw new IngestException(e);\n          }\n        } catch (Exception e) {\n          logger.error(\"Unable to get event mediapackage from scheduler event {}\", mp.getIdentifier().toString(), e);\n          throw new IngestException(e);\n        }\n      }\n      return mp;\n    } finally {\n      properties.remove(LEGACY_MEDIAPACKAGE_ID_KEY);\n    }\n  }\n\n  private Map<String, String> mergeWorkflowConfiguration(Map<String, String> properties, String mediaPackageId) {\n    if (isBlank(mediaPackageId) || schedulerService == null)\n      return properties;\n\n    HashMap<String, String> mergedProperties = new HashMap<>();\n\n    try {\n      Map<String, String> recordingProperties = schedulerService.getCaptureAgentConfiguration(mediaPackageId);\n      logger.debug(\"Restoring workflow properties from scheduler event {}\", mediaPackageId);\n      mergedProperties.putAll(recordingProperties);\n    } catch (SchedulerException e) {\n      logger.warn(\"Unable to get workflow properties from scheduler event {}\", mediaPackageId, e);\n    } catch (NotFoundException e) {\n      logger.info(\"No capture event found for id {}\", mediaPackageId);\n    } catch (UnauthorizedException e) {\n      throw new IllegalStateException(e);\n    }\n\n    if (properties != null) {\n      // Merge the properties, this must be after adding the recording properties\n      logger.debug(\"Merge workflow properties with the one from the scheduler event {}\", mediaPackageId);\n      mergedProperties.putAll(properties);\n    }\n\n    return mergedProperties;\n  }\n\n  /**\n   * Merges the ingested mediapackage with the scheduled mediapackage. The ingested mediapackage takes precedence over\n   * the scheduled mediapackage.\n   *\n   * @param mp\n   *          the ingested mediapackage\n   * @return the merged mediapackage\n   */\n  private MediaPackage mergeScheduledMediaPackage(MediaPackage mp) throws IngestException {\n    if (schedulerService == null) {\n      logger.warn(\"No scheduler service available to merge mediapackage!\");\n      return mp;\n    }\n\n    try {\n      MediaPackage scheduledMp = schedulerService.getMediaPackage(mp.getIdentifier().toString());\n      logger.info(\"Found matching scheduled event for id '{}', merging mediapackage...\", mp.getIdentifier().toString());\n      mergeMediaPackageElements(mp, scheduledMp);\n      mergeMediaPackageMetadata(mp, scheduledMp);\n      return mp;\n    } catch (NotFoundException e) {\n      logger.debug(\"No scheduler mediapackage found with id {}, skip merging\", mp.getIdentifier());\n      return mp;\n    } catch (Exception e) {\n      throw new IngestException(String.format(\"Unable to get event media package from scheduler event %s\",\n              mp.getIdentifier()), e);\n    }\n  }\n\n  /**\n   * Merge different elements from capture agent ingesting mp and Asset manager. Overwrite or replace same flavored\n   * elements depending on the Ingest Service overwrite configuration. Ignore publications (i.e. live publication\n   * channel from Asset Manager) Always keep tracks from the capture agent.\n   *\n   * @param mp\n   *          the medipackage being ingested from the Capture Agent\n   * @param scheduledMp\n   *          the mediapckage that was schedule and managed by the Asset Manager\n   */\n  private void mergeMediaPackageElements(MediaPackage mp, MediaPackage scheduledMp) {\n    // drop catalogs sent by the capture agent in favor of Opencast's own metadata\n    if (skipCatalogs) {\n      for (MediaPackageElement element : mp.getCatalogs()) {\n        if (!element.getFlavor().equals(MediaPackageElements.SMIL)) {\n          mp.remove(element);\n        }\n      }\n    }\n\n    // drop attachments the capture agent sent us in favor of Opencast's attachments\n    // e.g. prevent capture agents from modifying security rules of schedules events\n    if (skipAttachments) {\n      for (MediaPackageElement element : mp.getAttachments()) {\n        mp.remove(element);\n      }\n    }\n\n    for (MediaPackageElement element : scheduledMp.getElements()) {\n      if (MediaPackageElement.Type.Publication.equals(element.getElementType())) {\n        // The Asset managed media package may have a publication element for a live event, if retract live has not run yet.\n        // Publications do not have flavors and are never part of the mediapackage from the capture agent.\n        // Therefore, ignore publication element because it is removed when the recorded media is published and causes complications (on short media) if added.\n        logger.debug(\"Ignoring {}, not adding to ingested mediapackage {}\", MediaPackageElement.Type.Publication, mp);\n        continue;\n      } else if (mp.getElementsByFlavor(element.getFlavor()).length > 0) {\n        // The default is to overwrite matching flavored elements in the Asset managed mediapackage (e.g. catalogs)\n        // If isOverwrite is true, changes made from the CA overwrite (update/revert) changes made from the Admin UI.\n        // If isOverwrite is false, changes made from the CA do not overwrite (update/revert) changes made from the Admin UI.\n        // regardless of overwrite, always keep new ingested tracks.\n        if (!isAddOnlyNew || MediaPackageElement.Type.Track.equals(element.getElementType())) {\n          // Allow updates made from the Capture Agent to overwrite existing metadata in Opencast\n          logger.info(\n                  \"Omitting Opencast (Asset Managed) element '{}', replacing with ingested element of same flavor '{}'\",\n                  element,\n                  element.getFlavor());\n          continue;\n        }\n        // Remove flavored element from ingested mp and replaced it with maching element from Asset Managed mediapackage.\n        // This protects updates made from the admin UI during an event capture from being reverted by artifacts from the ingested CA.\n        for (MediaPackageElement el : mp.getElementsByFlavor(element.getFlavor())) {\n          logger.info(\"Omitting ingested element '{}' {}, keeping existing (Asset Managed) element of same flavor '{}'\", el, el.getURI(),\n                  element.getFlavor());\n          mp.remove(el);\n        }\n      }\n      logger.info(\"Adding element {} from scheduled (Asset Managed) event '{}' into ingested mediapackage\", element, mp);\n      mp.add(element);\n    }\n  }\n\n  /**\n   *\n   * The previous OC behaviour is for metadata in the ingested mediapackage to be updated by the\n   * Asset Managed metadata *only* when the field is blank on the ingested mediapackage.\n   * However, that field may have been intentionally emptied by\n   * removing its value from the Capture Agent UI (e.g. Galicaster)\n   *\n   * If isOverwrite is true, metadata values in the ingest mediapackage overwrite Asset Managed metadata.\n   * If isOverwrite is false, Asset Managed metadata is preserved.\n   *\n   * @param mp,\n   *          the inbound ingested mp\n   * @param scheduledMp,\n   *          the existing scheduled mp\n   */\n  private void mergeMediaPackageMetadata(MediaPackage mp, MediaPackage scheduledMp) {\n    // Merge media package fields depending on overwrite setting\n    boolean noOverwrite = (isAddOnlyNew && !skipCatalogs) || skipCatalogs;\n    if ((mp.getDate() == null) || noOverwrite)\n      mp.setDate(scheduledMp.getDate());\n    if (isBlank(mp.getLicense()) || noOverwrite)\n      mp.setLicense(scheduledMp.getLicense());\n    if (isBlank(mp.getSeries()) || noOverwrite)\n      mp.setSeries(scheduledMp.getSeries());\n    if (isBlank(mp.getSeriesTitle()) || noOverwrite)\n      mp.setSeriesTitle(scheduledMp.getSeriesTitle());\n    if (isBlank(mp.getTitle()) || noOverwrite)\n      mp.setTitle(scheduledMp.getTitle());\n\n    if (mp.getSubjects().length <= 0 || noOverwrite) {\n      Arrays.stream(mp.getSubjects()).forEach(mp::removeSubject);\n      for (String subject : scheduledMp.getSubjects()) {\n        mp.addSubject(subject);\n      }\n    }\n    if (noOverwrite || mp.getContributors().length == 0) {\n      Arrays.stream(mp.getContributors()).forEach(mp::removeContributor);\n      for (String contributor : scheduledMp.getContributors()) {\n        mp.addContributor(contributor);\n      }\n    }\n    if (noOverwrite || mp.getCreators().length == 0) {\n      Arrays.stream(mp.getCreators()).forEach(mp::removeCreator);\n      for (String creator : scheduledMp.getCreators()) {\n        mp.addCreator(creator);\n      }\n    }\n  }\n\n  /**\n   * Removes the workflow configuration file prefix from all properties in a map.\n   *\n   * @param properties\n   *          The properties to remove the prefixes from\n   * @return A Map with the same collection of properties without the prefix\n   */\n  private Map<String, String> removePrefixFromProperties(Map<String, String> properties) {\n    Map<String, String> fixedProperties = new HashMap<>();\n    if (properties != null) {\n      for (Entry<String, String> entry : properties.entrySet()) {\n        if (entry.getKey().startsWith(WORKFLOW_CONFIGURATION_PREFIX)) {\n          logger.debug(\"Removing prefix from key '\" + entry.getKey() + \" with value '\" + entry.getValue() + \"'\");\n          fixedProperties.put(entry.getKey().replace(WORKFLOW_CONFIGURATION_PREFIX, \"\"), entry.getValue());\n        } else {\n          fixedProperties.put(entry.getKey(), entry.getValue());\n        }\n      }\n    }\n    return fixedProperties;\n  }\n\n  private WorkflowDefinition getWorkflowDefinition(String workflowDefinitionID, MediaPackage mediapackage)\n          throws NotFoundException, WorkflowDatabaseException, IngestException {\n    // If the workflow definition and instance ID are null, use the default, or throw if there is none\n    if (isBlank(workflowDefinitionID)) {\n      String mediaPackageId = mediapackage.getIdentifier().toString();\n      if (schedulerService != null) {\n        logger.info(\"Determining workflow template for ingested mediapckage {} from capture event {}\", mediapackage,\n                mediaPackageId);\n        try {\n          Map<String, String> recordingProperties = schedulerService.getCaptureAgentConfiguration(mediaPackageId);\n          workflowDefinitionID = recordingProperties.get(CaptureParameters.INGEST_WORKFLOW_DEFINITION);\n          if (isBlank(workflowDefinitionID)) {\n            workflowDefinitionID = defaultWorkflowDefinionId;\n            logger.debug(\"No workflow set. Falling back to default.\");\n          }\n          if (isBlank(workflowDefinitionID)) {\n            throw new IngestException(\"No value found for key '\" + CaptureParameters.INGEST_WORKFLOW_DEFINITION\n                    + \"' from capture event configuration of scheduler event '\" + mediaPackageId + \"'\");\n          }\n          logger.info(\"Ingested event {} will be processed using workflow '{}'\", mediapackage, workflowDefinitionID);\n        } catch (NotFoundException e) {\n          logger.warn(\"Specified capture event {} was not found\", mediaPackageId);\n        } catch (UnauthorizedException e) {\n          throw new IllegalStateException(e);\n        } catch (SchedulerException e) {\n          logger.warn(\"Unable to get the workflow definition id from scheduler event {}\", mediaPackageId, e);\n          throw new IngestException(e);\n        }\n      } else {\n        logger.warn(\n                \"Scheduler service not bound, unable to determine the workflow template to use for ingested mediapckage {}\",\n                mediapackage);\n      }\n\n    } else {\n      logger.info(\"Ingested mediapackage {} is processed using workflow template '{}', specified during ingest\",\n              mediapackage, workflowDefinitionID);\n    }\n\n    // Use the default workflow definition if nothing was determined\n    if (isBlank(workflowDefinitionID) && defaultWorkflowDefinionId != null) {\n      logger.info(\"Using default workflow definition '{}' to process ingested mediapackage {}\",\n              defaultWorkflowDefinionId, mediapackage);\n      workflowDefinitionID = defaultWorkflowDefinionId;\n    }\n\n    // Check if the workflow definition is valid\n    if (StringUtils.isNotBlank(workflowDefinitionID) && StringUtils.isNotBlank(defaultWorkflowDefinionId)) {\n      try {\n        workflowService.getWorkflowDefinitionById(workflowDefinitionID);\n      } catch (WorkflowDatabaseException e) {\n        throw new IngestException(e);\n      } catch (NotFoundException nfe) {\n        logger.warn(\"Workflow definition {} not found, using default workflow {} instead\", workflowDefinitionID,\n                defaultWorkflowDefinionId);\n        workflowDefinitionID = defaultWorkflowDefinionId;\n      }\n    }\n\n    // Have we been able to find a workflow definition id?\n    if (isBlank(workflowDefinitionID)) {\n      ingestStatistics.failed();\n      throw new IllegalStateException(\n              \"Can not ingest a workflow without a workflow definition or an existing instance. No default definition is specified\");\n    }\n\n    // Let's make sure the workflow definition exists\n    return workflowService.getWorkflowDefinitionById(workflowDefinitionID);\n  }\n\n  /**\n   *\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#discardMediaPackage(org.opencastproject.mediapackage.MediaPackage)\n   */\n  @Override\n  public void discardMediaPackage(MediaPackage mp) throws IOException {\n    String mediaPackageId = mp.getIdentifier().toString();\n    for (MediaPackageElement element : mp.getElements()) {\n      if (!workingFileRepository.delete(mediaPackageId, element.getIdentifier()))\n        logger.warn(\"Unable to find (and hence, delete), this mediapackage element\");\n    }\n    logger.info(\"Successfully discarded media package {}\", mp);\n  }\n\n  protected URI addContentToRepo(MediaPackage mp, String elementId, URI uri) throws IOException {\n    InputStream in = null;\n    HttpResponse response = null;\n    CloseableHttpClient externalHttpClient = null;\n    try {\n      if (uri.toString().startsWith(\"http\")) {\n        HttpGet get = new HttpGet(uri);\n        List<String> clusterUrls = new LinkedList<>();\n        try {\n          // Note that we are not checking ports here.\n          clusterUrls = organizationDirectoryService.getOrganization(uri.toURL()).getServers()\n                          .keySet()\n                          .stream()\n                          .collect(Collectors.toUnmodifiableList());\n        } catch (NotFoundException e) {\n          logger.warn(\"Unable to determine cluster members, will not be able to authenticate any downloads from them\", e);\n        }\n\n        if (uri.toString().matches(downloadSource)) {\n          //NB: We're creating a new client here with *different* auth than the system auth creds\n          externalHttpClient = getAuthedHttpClient();\n          response = externalHttpClient.execute(get);\n        } else if (clusterUrls.contains(uri.getScheme() + \"://\" + uri.getHost())) {\n          // Only using the system-level httpclient and digest credentials against our own servers\n          response = httpClient.execute(get);\n        } else {\n          //NB: No auth here at all\n          externalHttpClient = getNoAuthHttpClient();\n          response = externalHttpClient.execute(get);\n        }\n\n        if (null == response) {\n          // If you get here then chances are you're using a mock httpClient which does not have appropriate\n          // mocking to respond to the URL you are feeding it.  Try adding that URL to the mock and see if that works.\n          throw new IOException(\"Null response object from the http client, refer to code for explanation\");\n        }\n\n        int httpStatusCode = response.getStatusLine().getStatusCode();\n        if (httpStatusCode != 200) {\n          throw new IOException(uri + \" returns http \" + httpStatusCode);\n        }\n        in = response.getEntity().getContent();\n        //If it does not start with file, or we're in test mode (ie, to allow arbitrary file:// access)\n      } else if (!uri.toString().startsWith(\"file\") || testMode) {\n        in = uri.toURL().openStream();\n      } else {\n        throw new IOException(\"Refusing to fetch files from the local filesystem\");\n      }\n      String fileName = FilenameUtils.getName(uri.getPath());\n      if (isBlank(FilenameUtils.getExtension(fileName)))\n        fileName = getContentDispositionFileName(response);\n\n      if (isBlank(FilenameUtils.getExtension(fileName)))\n        throw new IOException(\"No filename extension found: \" + fileName);\n      return addContentToRepo(mp, elementId, fileName, in);\n    } finally {\n      if (in != null) {\n        in.close();\n      }\n      if (externalHttpClient != null) {\n        externalHttpClient.close();\n      }\n      httpClient.close(response);\n    }\n  }\n\n  private String getContentDispositionFileName(HttpResponse response) {\n    if (response == null)\n      return null;\n\n    Header header = response.getFirstHeader(\"Content-Disposition\");\n    ContentDisposition contentDisposition = new ContentDisposition(header.getValue());\n    return contentDisposition.getParameter(\"filename\");\n  }\n\n  private URI addContentToRepo(MediaPackage mp, String elementId, String filename, InputStream file)\n          throws IOException {\n    ProgressInputStream progressInputStream = new ProgressInputStream(file);\n    progressInputStream.addPropertyChangeListener(new PropertyChangeListener() {\n      @Override\n      public void propertyChange(PropertyChangeEvent evt) {\n        long totalNumBytesRead = (Long) evt.getNewValue();\n        long oldTotalNumBytesRead = (Long) evt.getOldValue();\n        ingestStatistics.add(totalNumBytesRead - oldTotalNumBytesRead);\n      }\n    });\n    return workingFileRepository.put(mp.getIdentifier().toString(), elementId, filename, progressInputStream);\n  }\n\n  private MediaPackage addContentToMediaPackage(MediaPackage mp, String elementId, URI uri,\n          MediaPackageElement.Type type, MediaPackageElementFlavor flavor) {\n    logger.info(\"Adding element of type {} to mediapackage {}\", type, mp);\n    MediaPackageElement mpe = mp.add(uri, type, flavor);\n    mpe.setIdentifier(elementId);\n    return mp;\n  }\n\n  // ---------------------------------------------\n  // --------- bind and unbind bundles ---------\n  // ---------------------------------------------\n  @Reference\n  public void setWorkflowService(WorkflowService workflowService) {\n    this.workflowService = workflowService;\n  }\n\n  @Reference\n  public void setWorkingFileRepository(WorkingFileRepository workingFileRepository) {\n    this.workingFileRepository = workingFileRepository;\n  }\n\n  @Reference\n  public void setSeriesService(SeriesService seriesService) {\n    this.seriesService = seriesService;\n  }\n\n  @Reference\n  public void setDublinCoreService(DublinCoreCatalogService dublinCoreService) {\n    this.dublinCoreService = dublinCoreService;\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.job.api.AbstractJobProducer#getServiceRegistry()\n   */\n  @Override\n  protected ServiceRegistry getServiceRegistry() {\n    return serviceRegistry;\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.job.api.AbstractJobProducer#process(org.opencastproject.job.api.Job)\n   */\n  @Override\n  protected String process(Job job) throws Exception {\n    throw new IllegalStateException(\"Ingest jobs are not expected to be dispatched\");\n  }\n\n  /**\n   * Callback for setting the security service.\n   *\n   * @param securityService\n   *          the securityService to set\n   */\n  @Reference\n  public void setSecurityService(SecurityService securityService) {\n    this.securityService = securityService;\n  }\n\n  /**\n   * Callback for setting the user directory service.\n   *\n   * @param userDirectoryService\n   *          the userDirectoryService to set\n   */\n  @Reference\n  public void setUserDirectoryService(UserDirectoryService userDirectoryService) {\n    this.userDirectoryService = userDirectoryService;\n  }\n\n  /**\n   * Callback for setting the scheduler service.\n   *\n   * @param schedulerService\n   *          the scheduler service to set\n   */\n  @Reference(\n    policy = ReferencePolicy.DYNAMIC,\n    cardinality = ReferenceCardinality.OPTIONAL,\n    unbind = \"unsetSchedulerService\"\n  )\n  public void setSchedulerService(SchedulerService schedulerService) {\n    this.schedulerService = schedulerService;\n  }\n\n  public void unsetSchedulerService(SchedulerService schedulerService) {\n    this.schedulerService = null;\n  }\n\n  /**\n   * Sets a reference to the organization directory service.\n   *\n   * @param organizationDirectory\n   *          the organization directory\n   */\n  @Reference\n  public void setOrganizationDirectoryService(OrganizationDirectoryService organizationDirectory) {\n    organizationDirectoryService = organizationDirectory;\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.job.api.AbstractJobProducer#getSecurityService()\n   */\n  @Override\n  protected SecurityService getSecurityService() {\n    return securityService;\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.job.api.AbstractJobProducer#getUserDirectoryService()\n   */\n  @Override\n  protected UserDirectoryService getUserDirectoryService() {\n    return userDirectoryService;\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.job.api.AbstractJobProducer#getOrganizationDirectoryService()\n   */\n  @Override\n  protected OrganizationDirectoryService getOrganizationDirectoryService() {\n    return organizationDirectoryService;\n  }\n\n  //Used in testing\n  protected CloseableHttpClient getNoAuthHttpClient() {\n    return HttpClientBuilder.create().build();\n  }\n\n  protected CloseableHttpClient getAuthedHttpClient() {\n    HttpClientBuilder cb = HttpClientBuilder.create();\n    CredentialsProvider provider = new BasicCredentialsProvider();\n    provider.setCredentials(\n      new AuthScope(AuthScope.ANY_HOST, AuthScope.ANY_PORT, AuthScope.ANY_REALM, AuthSchemes.DIGEST),\n      new UsernamePasswordCredentials(downloadUser, downloadPassword));\n    return cb.build();\n  }\n\n  private MediaPackage createSmil(MediaPackage mediaPackage) throws IOException, IngestException {\n    Stream<Track> partialTracks = Stream.empty();\n    for (Track track : mediaPackage.getTracks()) {\n      Long startTime = partialTrackStartTimes.getIfPresent(track.getIdentifier());\n      if (startTime == null)\n        continue;\n      partialTracks = partialTracks.append(Opt.nul(track));\n    }\n\n    // No partial track available return without adding SMIL catalog\n    if (partialTracks.isEmpty())\n      return mediaPackage;\n\n    // Inspect the partial tracks\n    List<Track> tracks = partialTracks.map(newEnrichJob(mediaInspectionService).toFn())\n            .map(payloadAsTrack(getServiceRegistry()).toFn())\n            .each(MediaPackageSupport.updateElement(mediaPackage).toFn().toFx()).toList();\n\n    // Create the SMIL document\n    org.w3c.dom.Document smilDocument = SmilUtil.createSmil();\n    for (Track track : tracks) {\n      Long startTime = partialTrackStartTimes.getIfPresent(track.getIdentifier());\n      if (startTime == null) {\n        logger.error(\"No start time found for track {}\", track);\n        throw new IngestException(\"No start time found for track \" + track.getIdentifier());\n      }\n      smilDocument = addSmilTrack(smilDocument, track, startTime);\n      partialTrackStartTimes.invalidate(track.getIdentifier());\n    }\n\n    // Store the SMIL document in the mediapackage\n    return addSmilCatalog(smilDocument, mediaPackage);\n  }\n\n  /**\n   * Adds a SMIL catalog to a mediapackage if it's not already existing.\n   *\n   * @param smilDocument\n   *          the smil document\n   * @param mediaPackage\n   *          the mediapackage to extend with the SMIL catalog\n   * @return the augmented mediapcakge\n   * @throws IOException\n   *           if reading or writing of the SMIL catalog fails\n   * @throws IngestException\n   *           if the SMIL catalog already exists\n   */\n  private MediaPackage addSmilCatalog(org.w3c.dom.Document smilDocument, MediaPackage mediaPackage)\n          throws IOException, IngestException {\n    Option<org.w3c.dom.Document> optSmilDocument = loadSmilDocument(workingFileRepository, mediaPackage);\n    if (optSmilDocument.isSome())\n      throw new IngestException(\"SMIL already exists!\");\n\n    InputStream in = null;\n    try {\n      in = XmlUtil.serializeDocument(smilDocument);\n      String elementId = UUID.randomUUID().toString();\n      URI uri = workingFileRepository.put(mediaPackage.getIdentifier().toString(), elementId, PARTIAL_SMIL_NAME, in);\n      MediaPackageElement mpe = mediaPackage.add(uri, MediaPackageElement.Type.Catalog, MediaPackageElements.SMIL);\n      mpe.setIdentifier(elementId);\n      // Reset the checksum since it changed\n      mpe.setChecksum(null);\n      mpe.setMimeType(MimeTypes.SMIL);\n      return mediaPackage;\n    } finally {\n      IoSupport.closeQuietly(in);\n    }\n  }\n\n  /**\n   * Load a SMIL document of a media package.\n   *\n   * @return the document or none if no media package element found.\n   */\n  private Option<org.w3c.dom.Document> loadSmilDocument(final WorkingFileRepository workingFileRepository,\n          MediaPackage mp) {\n    return mlist(mp.getElements()).filter(MediaPackageSupport.Filters.isSmilCatalog).headOpt()\n            .map(new Function<MediaPackageElement, org.w3c.dom.Document>() {\n              @Override\n              public org.w3c.dom.Document apply(MediaPackageElement mpe) {\n                InputStream in = null;\n                try {\n                  in = workingFileRepository.get(mpe.getMediaPackage().getIdentifier().toString(), mpe.getIdentifier());\n                  return SmilUtil.loadSmilDocument(in, mpe);\n                } catch (Exception e) {\n                  logger.warn(\"Unable to load smil document from catalog '{}'\", mpe, e);\n                  return Misc.chuck(e);\n                } finally {\n                  IOUtils.closeQuietly(in);\n                }\n              }\n            });\n  }\n\n  /**\n   * Adds a SMIL track by a mediapackage track to a SMIL document\n   *\n   * @param smilDocument\n   *          the SMIL document to extend\n   * @param track\n   *          the mediapackage track\n   * @param startTime\n   *          the start time\n   * @return the augmented SMIL document\n   * @throws IngestException\n   *           if the partial flavor type is not valid\n   */\n  private org.w3c.dom.Document addSmilTrack(org.w3c.dom.Document smilDocument, Track track, long startTime)\n          throws IngestException {\n    if (MediaPackageElements.PRESENTER_SOURCE.getType().equals(track.getFlavor().getType())) {\n      return SmilUtil.addTrack(smilDocument, SmilUtil.TrackType.PRESENTER, track.hasVideo(), startTime,\n              track.getDuration(), track.getURI(), track.getIdentifier());\n    } else if (MediaPackageElements.PRESENTATION_SOURCE.getType().equals(track.getFlavor().getType())) {\n      return SmilUtil.addTrack(smilDocument, SmilUtil.TrackType.PRESENTATION, track.hasVideo(), startTime,\n              track.getDuration(), track.getURI(), track.getIdentifier());\n    } else {\n      logger.warn(\"Invalid partial flavor type {} of track {}\", track.getFlavor(), track);\n      throw new IngestException(\n              \"Invalid partial flavor type \" + track.getFlavor().getType() + \" of track \" + track.getURI().toString());\n    }\n  }\n\n  /**\n   * Create a media inspection job for a mediapackage element.\n   *\n   * @param svc the media inspection service\n   * @return a function\n   */\n  public static Function<MediaPackageElement, Job> newEnrichJob(final MediaInspectionService svc) {\n    return new Function.X<MediaPackageElement, Job>() {\n      @Override\n      public Job xapply(MediaPackageElement e) throws Exception {\n        return svc.enrich(e, true);\n      }\n    };\n  }\n\n  /**\n   * Interpret the payload of a completed Job as a MediaPackageElement. Wait for the job to complete if necessary.\n   *\n   * @param reg the service registry\n   * @return a function\n   */\n  public static Function<Job, Track> payloadAsTrack(final ServiceRegistry reg) {\n    return new Function.X<Job, Track>() {\n      @Override\n      public Track xapply(Job job) throws MediaPackageException {\n        waitForJob(reg, none(0L), job);\n        return (Track) MediaPackageElementParser.getFromXml(job.getPayload());\n      }\n    };\n  }\n}\n", "/**\n * Licensed to The Apereo Foundation under one or more contributor license\n * agreements. See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n *\n * The Apereo Foundation licenses this file to you under the Educational\n * Community License, Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of the License\n * at:\n *\n *   http://opensource.org/licenses/ecl2.txt\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n * License for the specific language governing permissions and limitations under\n * the License.\n *\n */\n\npackage org.opencastproject.ingest.impl;\n\nimport org.opencastproject.capture.CaptureParameters;\nimport org.opencastproject.inspection.api.MediaInspectionService;\nimport org.opencastproject.job.api.Job;\nimport org.opencastproject.job.api.Job.Status;\nimport org.opencastproject.job.api.JobImpl;\nimport org.opencastproject.mediapackage.Attachment;\nimport org.opencastproject.mediapackage.Catalog;\nimport org.opencastproject.mediapackage.MediaPackage;\nimport org.opencastproject.mediapackage.MediaPackageElement;\nimport org.opencastproject.mediapackage.MediaPackageElementParser;\nimport org.opencastproject.mediapackage.MediaPackageElements;\nimport org.opencastproject.mediapackage.MediaPackageParser;\nimport org.opencastproject.mediapackage.Publication;\nimport org.opencastproject.mediapackage.Track;\nimport org.opencastproject.mediapackage.track.AudioStreamImpl;\nimport org.opencastproject.mediapackage.track.TrackImpl;\nimport org.opencastproject.mediapackage.track.VideoStreamImpl;\nimport org.opencastproject.metadata.dublincore.DublinCoreCatalog;\nimport org.opencastproject.metadata.dublincore.DublinCoreCatalogService;\nimport org.opencastproject.metadata.dublincore.DublinCores;\nimport org.opencastproject.scheduler.api.SchedulerService;\nimport org.opencastproject.security.api.DefaultOrganization;\nimport org.opencastproject.security.api.JaxbRole;\nimport org.opencastproject.security.api.JaxbUser;\nimport org.opencastproject.security.api.Organization;\nimport org.opencastproject.security.api.OrganizationDirectoryService;\nimport org.opencastproject.security.api.SecurityService;\nimport org.opencastproject.security.api.TrustedHttpClient;\nimport org.opencastproject.security.api.User;\nimport org.opencastproject.security.api.UserDirectoryService;\nimport org.opencastproject.series.api.SeriesService;\nimport org.opencastproject.serviceregistry.api.IncidentService;\nimport org.opencastproject.serviceregistry.api.ServiceRegistryInMemoryImpl;\nimport org.opencastproject.util.MimeTypes;\nimport org.opencastproject.util.NotFoundException;\nimport org.opencastproject.util.XmlUtil;\nimport org.opencastproject.util.data.Either;\nimport org.opencastproject.workflow.api.WorkflowDefinition;\nimport org.opencastproject.workflow.api.WorkflowDefinitionImpl;\nimport org.opencastproject.workflow.api.WorkflowInstance;\nimport org.opencastproject.workflow.api.WorkflowInstance.WorkflowState;\nimport org.opencastproject.workflow.api.WorkflowInstanceImpl;\nimport org.opencastproject.workflow.api.WorkflowService;\nimport org.opencastproject.workingfilerepository.api.WorkingFileRepository;\nimport org.opencastproject.workingfilerepository.impl.WorkingFileRepositoryImpl;\n\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang3.reflect.FieldUtils;\nimport org.apache.http.Header;\nimport org.apache.http.HttpEntity;\nimport org.apache.http.StatusLine;\nimport org.apache.http.client.methods.CloseableHttpResponse;\nimport org.apache.http.client.methods.HttpGet;\nimport org.apache.http.impl.client.CloseableHttpClient;\nimport org.easymock.Capture;\nimport org.easymock.EasyMock;\nimport org.easymock.IAnswer;\nimport org.junit.After;\nimport org.junit.Assert;\nimport org.junit.Before;\nimport org.junit.BeforeClass;\nimport org.junit.Test;\nimport org.w3c.dom.Document;\nimport org.xml.sax.InputSource;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.util.Dictionary;\nimport java.util.HashMap;\nimport java.util.Hashtable;\nimport java.util.Map;\n\npublic class IngestServiceImplTest {\n  private IngestServiceImpl service = null;\n  private DublinCoreCatalogService dublinCoreService = null;\n  private SeriesService seriesService = null;\n  private WorkflowService workflowService = null;\n  private WorkflowInstance workflowInstance = null;\n  private WorkingFileRepository wfr = null;\n  private CloseableHttpResponse httpResponse = null;\n  private CloseableHttpClient credClient = null;\n  private CloseableHttpClient noCredClient = null;\n  private static URI baseDir;\n  private static URI urlTrack;\n  private static URI urlTrack1;\n  private static URI urlTrack2;\n  private static URI urlCatalog;\n  private static URI urlCatalog1;\n  private static URI urlCatalog2;\n  private static URI urlAttachment;\n  private static URI urlPackage;\n  private static URI urlPackageOld;\n  private static URI urlTrackNoFilename;\n\n  private static File ingestTempDir;\n  private static File packageFile;\n\n  private static long workflowInstanceID = 1L;\n  private ServiceRegistryInMemoryImpl serviceRegistry;\n\n  private MediaPackage ingestMediaPackage;\n  private MediaPackage schedulerMediaPackage;\n\n  @BeforeClass\n  public static void beforeClass() throws URISyntaxException {\n    baseDir = IngestServiceImplTest.class.getResource(\"/\").toURI();\n    urlTrack = IngestServiceImplTest.class.getResource(\"/av.mov\").toURI();\n    urlTrack1 = IngestServiceImplTest.class.getResource(\"/vonly.mov\").toURI();\n    urlTrack2 = IngestServiceImplTest.class.getResource(\"/aonly.mov\").toURI();\n    urlCatalog = IngestServiceImplTest.class.getResource(\"/mpeg-7.xml\").toURI();\n    urlCatalog1 = IngestServiceImplTest.class.getResource(\"/dublincore.xml\").toURI();\n    urlCatalog2 = IngestServiceImplTest.class.getResource(\"/series-dublincore.xml\").toURI();\n    urlAttachment = IngestServiceImplTest.class.getResource(\"/cover.png\").toURI();\n    urlPackage = IngestServiceImplTest.class.getResource(\"/data.zip\").toURI();\n    urlPackageOld = IngestServiceImplTest.class.getResource(\"/data.old.zip\").toURI();\n    urlTrackNoFilename = IngestServiceImplTest.class.getResource(\"/av\").toURI();\n\n    ingestTempDir = new File(new File(baseDir), \"ingest-temp\");\n    packageFile = new File(ingestTempDir, baseDir.relativize(urlPackage).toString());\n\n  }\n\n  @Before\n  public void setUp() throws Exception {\n    //This looks dumb, but is required so we can override things in testAuthWhitelist\n    setupService();\n  }\n\n  @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n  private void setupService() throws Exception {\n    schedulerMediaPackage = MediaPackageParser\n            .getFromXml(IOUtils.toString(getClass().getResourceAsStream(\"/source-manifest.xml\"), \"UTF-8\"));\n\n    ingestMediaPackage = MediaPackageParser\n            .getFromXml(IOUtils.toString(getClass().getResourceAsStream(\"/target-manifest.xml\"), \"UTF-8\"));\n\n    FileUtils.forceMkdir(ingestTempDir);\n\n    // set up service and mock workspace\n    wfr = EasyMock.createNiceMock(WorkingFileRepository.class);\n    EasyMock.expect(wfr.put((String) EasyMock.anyObject(), (String) EasyMock.anyObject(), (String) EasyMock.anyObject(),\n            (InputStream) EasyMock.anyObject())).andReturn(urlTrack);\n    EasyMock.expect(wfr.put((String) EasyMock.anyObject(), (String) EasyMock.anyObject(), (String) EasyMock.anyObject(),\n            (InputStream) EasyMock.anyObject())).andReturn(urlCatalog);\n    EasyMock.expect(wfr.put((String) EasyMock.anyObject(), (String) EasyMock.anyObject(), (String) EasyMock.anyObject(),\n            (InputStream) EasyMock.anyObject())).andReturn(urlAttachment);\n    EasyMock.expect(wfr.put((String) EasyMock.anyObject(), (String) EasyMock.anyObject(), (String) EasyMock.anyObject(),\n            (InputStream) EasyMock.anyObject())).andReturn(urlTrack1);\n    EasyMock.expect(wfr.put((String) EasyMock.anyObject(), (String) EasyMock.anyObject(), (String) EasyMock.anyObject(),\n            (InputStream) EasyMock.anyObject())).andReturn(urlTrack2);\n    EasyMock.expect(wfr.put((String) EasyMock.anyObject(), (String) EasyMock.anyObject(), (String) EasyMock.anyObject(),\n            (InputStream) EasyMock.anyObject())).andReturn(urlCatalog1);\n    EasyMock.expect(wfr.put((String) EasyMock.anyObject(), (String) EasyMock.anyObject(), (String) EasyMock.anyObject(),\n            (InputStream) EasyMock.anyObject())).andReturn(urlCatalog2);\n    EasyMock.expect(wfr.put((String) EasyMock.anyObject(), (String) EasyMock.anyObject(), (String) EasyMock.anyObject(),\n            (InputStream) EasyMock.anyObject())).andReturn(urlCatalog);\n\n    EasyMock.expect(wfr.putInCollection((String) EasyMock.anyObject(), (String) EasyMock.anyObject(),\n            (InputStream) EasyMock.anyObject())).andReturn(urlTrack1);\n    EasyMock.expect(wfr.putInCollection((String) EasyMock.anyObject(), (String) EasyMock.anyObject(),\n            (InputStream) EasyMock.anyObject())).andReturn(urlTrack2);\n    EasyMock.expect(wfr.putInCollection((String) EasyMock.anyObject(), (String) EasyMock.anyObject(),\n            (InputStream) EasyMock.anyObject())).andReturn(urlCatalog1);\n    EasyMock.expect(wfr.putInCollection((String) EasyMock.anyObject(), (String) EasyMock.anyObject(),\n            (InputStream) EasyMock.anyObject())).andReturn(urlCatalog2);\n    EasyMock.expect(wfr.putInCollection((String) EasyMock.anyObject(), (String) EasyMock.anyObject(),\n            (InputStream) EasyMock.anyObject())).andReturn(urlCatalog);\n\n    EasyMock.expect(wfr.putInCollection((String) EasyMock.anyObject(), (String) EasyMock.anyObject(),\n            (InputStream) EasyMock.anyObject())).andReturn(urlPackage);\n\n    EasyMock.expect(wfr.putInCollection((String) EasyMock.anyObject(), (String) EasyMock.anyObject(),\n            (InputStream) EasyMock.anyObject())).andReturn(urlPackageOld);\n\n    workflowInstance = EasyMock.createNiceMock(WorkflowInstance.class);\n    EasyMock.expect(workflowInstance.getId()).andReturn(workflowInstanceID);\n    EasyMock.expect(workflowInstance.getState()).andReturn(WorkflowState.STOPPED);\n\n    final Capture<MediaPackage> mp = EasyMock.newCapture();\n    workflowService = EasyMock.createNiceMock(WorkflowService.class);\n    EasyMock.expect(workflowService.start((WorkflowDefinition) EasyMock.anyObject(), EasyMock.capture(mp),\n            (Map) EasyMock.anyObject())).andReturn(workflowInstance);\n    EasyMock.expect(workflowInstance.getMediaPackage()).andAnswer(mp::getValue).anyTimes();\n    EasyMock.expect(workflowService.start((WorkflowDefinition) EasyMock.anyObject(),\n            (MediaPackage) EasyMock.anyObject(), (Map) EasyMock.anyObject())).andReturn(workflowInstance).anyTimes();\n    EasyMock.expect(\n            workflowService.start((WorkflowDefinition) EasyMock.anyObject(), (MediaPackage) EasyMock.anyObject()))\n            .andReturn(workflowInstance).anyTimes();\n    EasyMock.expect(workflowService.getWorkflowDefinitionById((String) EasyMock.anyObject()))\n            .andReturn(new WorkflowDefinitionImpl()).anyTimes();\n    EasyMock.expect(workflowService.getWorkflowById(EasyMock.anyLong())).andReturn(workflowInstance).anyTimes();\n\n    SchedulerService schedulerService = EasyMock.createNiceMock(SchedulerService.class);\n\n    Map<String, String> properties = new HashMap<>();\n    properties.put(CaptureParameters.INGEST_WORKFLOW_DEFINITION, \"sample\");\n    properties.put(\"agent-name\", \"matterhorn-agent\");\n    EasyMock.expect(schedulerService.getCaptureAgentConfiguration(EasyMock.anyString())).andReturn(properties)\n            .anyTimes();\n    EasyMock.expect(schedulerService.getDublinCore(EasyMock.anyString()))\n            .andReturn(DublinCores.read(urlCatalog1.toURL().openStream())).anyTimes();\n    EasyMock.expect(schedulerService.getMediaPackage(EasyMock.anyString())).andReturn(schedulerMediaPackage).anyTimes();\n\n    EasyMock.replay(wfr, workflowInstance, workflowService, schedulerService);\n\n    User anonymous = new JaxbUser(\"anonymous\", \"test\", new DefaultOrganization(),\n            new JaxbRole(DefaultOrganization.DEFAULT_ORGANIZATION_ANONYMOUS, new DefaultOrganization(), \"test\"));\n    UserDirectoryService userDirectoryService = EasyMock.createMock(UserDirectoryService.class);\n    EasyMock.expect(userDirectoryService.loadUser((String) EasyMock.anyObject())).andReturn(anonymous).anyTimes();\n    EasyMock.replay(userDirectoryService);\n\n    Organization organization = new DefaultOrganization();\n    OrganizationDirectoryService organizationDirectoryService = EasyMock.createMock(OrganizationDirectoryService.class);\n    EasyMock.expect(organizationDirectoryService.getOrganization((String) EasyMock.anyObject())).andReturn(organization)\n            .anyTimes();\n    EasyMock.expect(organizationDirectoryService.getOrganization((URL) EasyMock.anyObject())).andReturn(organization)\n            .anyTimes();\n    EasyMock.replay(organizationDirectoryService);\n\n    SecurityService securityService = EasyMock.createNiceMock(SecurityService.class);\n    EasyMock.expect(securityService.getUser()).andReturn(anonymous).anyTimes();\n    EasyMock.expect(securityService.getOrganization()).andReturn(organization).anyTimes();\n    EasyMock.replay(securityService);\n\n    HttpEntity entity = EasyMock.createMock(HttpEntity.class);\n    InputStream is = getClass().getResourceAsStream(\"/av.mov\");\n    byte[] movie = IOUtils.toByteArray(is);\n    IOUtils.closeQuietly(is);\n    EasyMock.expect(entity.getContent()).andReturn(new ByteArrayInputStream(movie)).anyTimes();\n    EasyMock.replay(entity);\n\n    StatusLine statusLine = EasyMock.createMock(StatusLine.class);\n    EasyMock.expect(statusLine.getStatusCode()).andReturn(200).anyTimes();\n    EasyMock.replay(statusLine);\n\n    Header contentDispositionHeader = EasyMock.createMock(Header.class);\n    EasyMock.expect(contentDispositionHeader.getValue()).andReturn(\"attachment; filename=fname.mp4\").anyTimes();\n    EasyMock.replay(contentDispositionHeader);\n\n    httpResponse = EasyMock.createMock(CloseableHttpResponse.class);\n    EasyMock.expect(httpResponse.getStatusLine()).andReturn(statusLine).anyTimes();\n    EasyMock.expect(httpResponse.getFirstHeader(\"Content-Disposition\")).andReturn(contentDispositionHeader).anyTimes();\n    EasyMock.expect(httpResponse.getEntity()).andReturn(entity).anyTimes();\n    EasyMock.replay(httpResponse);\n\n    TrustedHttpClient httpClient = EasyMock.createNiceMock(TrustedHttpClient.class);\n    EasyMock.expect(httpClient.execute((HttpGet) EasyMock.anyObject())).andReturn(httpResponse).anyTimes();\n    EasyMock.replay(httpClient);\n\n    MediaInspectionService mediaInspectionService = EasyMock.createNiceMock(MediaInspectionService.class);\n    EasyMock.expect(mediaInspectionService.enrich(EasyMock.anyObject(MediaPackageElement.class), EasyMock.anyBoolean()))\n            .andAnswer(new IAnswer<Job>() {\n              private int i = 0;\n\n              @Override\n              public Job answer() throws Throwable {\n                TrackImpl element = (TrackImpl) EasyMock.getCurrentArguments()[0];\n                element.setDuration(20000L);\n                if (i % 2 == 0) {\n                  element.addStream(new VideoStreamImpl());\n                } else {\n                  element.addStream(new AudioStreamImpl());\n                }\n                i++;\n                JobImpl succeededJob = new JobImpl();\n                succeededJob.setStatus(Status.FINISHED);\n                succeededJob.setPayload(MediaPackageElementParser.getAsXml(element));\n                return succeededJob;\n              }\n            }).anyTimes();\n    EasyMock.replay(mediaInspectionService);\n\n    if (null == service) {\n      service = new IngestServiceImpl() {\n\n        //These are overriden so that we get mock requests, not *actual* requests\n        @Override\n        protected CloseableHttpClient getAuthedHttpClient() {\n          CloseableHttpClient client = EasyMock.createMock(CloseableHttpClient.class);\n          try {\n            EasyMock.expect(client.execute((HttpGet) EasyMock.anyObject())).andReturn(httpResponse).anyTimes();\n            client.close();\n            EasyMock.expectLastCall().once();\n          } catch (Exception e) { }\n          EasyMock.replay(client);\n          return client;\n        }\n        @Override\n        protected CloseableHttpClient getNoAuthHttpClient() {\n          CloseableHttpClient client = EasyMock.createMock(CloseableHttpClient.class);\n          try {\n            EasyMock.expect(client.execute((HttpGet) EasyMock.anyObject())).andReturn(httpResponse).anyTimes();\n            client.close();\n            EasyMock.expectLastCall().once();\n          } catch (Exception e) { }\n          EasyMock.replay(client);\n          return client;\n        }\n      };\n    }\n    service.setHttpClient(httpClient);\n    service.setOrganizationDirectoryService(organizationDirectoryService);\n    service.setWorkingFileRepository(wfr);\n    service.setWorkflowService(workflowService);\n    service.setSecurityService(securityService);\n    service.setSchedulerService(schedulerService);\n    service.setMediaInspectionService(mediaInspectionService);\n    serviceRegistry = new ServiceRegistryInMemoryImpl(service, securityService, userDirectoryService,\n            organizationDirectoryService, EasyMock.createNiceMock(IncidentService.class));\n    serviceRegistry.registerService(service);\n    service.setServiceRegistry(serviceRegistry);\n    service.defaultWorkflowDefinionId = \"sample\";\n    serviceRegistry.registerService(service);\n    Dictionary<String, String> p = new Hashtable<>();\n    p.put(IngestServiceImpl.DOWNLOAD_SOURCE, \"http://localhost.*|http://www.test.com/.*\");\n    service.updated(p);\n    service.testMode = true;\n  }\n\n  @After\n  public void tearDown() {\n    FileUtils.deleteQuietly(ingestTempDir);\n  }\n\n  @Test\n  public void testThinClient() throws Exception {\n    MediaPackage mediaPackage = null;\n\n    // Use default properties\n    Dictionary<String, String> properties = new Hashtable<>();\n    service.updated(properties);\n\n    mediaPackage = service.createMediaPackage();\n    mediaPackage = service.addTrack(urlTrack, MediaPackageElements.PRESENTATION_SOURCE, mediaPackage);\n    mediaPackage = service.addCatalog(urlCatalog1, MediaPackageElements.EPISODE, mediaPackage);\n    mediaPackage = service.addAttachment(urlAttachment, MediaPackageElements.MEDIAPACKAGE_COVER_FLAVOR, mediaPackage);\n    WorkflowInstance instance = service.ingest(mediaPackage);\n    Assert.assertEquals(1, mediaPackage.getTracks().length);\n    Assert.assertEquals(1, mediaPackage.getCatalogs().length);\n    Assert.assertEquals(1, mediaPackage.getAttachments().length);\n    Assert.assertEquals(workflowInstanceID, instance.getId());\n  }\n\n  @Test\n  public void testThickClient() throws Exception {\n\n    FileUtils.copyURLToFile(urlPackage.toURL(), packageFile);\n\n    InputStream packageStream = null;\n    try {\n      packageStream = urlPackage.toURL().openStream();\n      WorkflowInstance instance = service.addZippedMediaPackage(packageStream);\n\n      // Assert.assertEquals(2, mediaPackage.getTracks().length);\n      // Assert.assertEquals(3, mediaPackage.getCatalogs().length);\n      Assert.assertEquals(workflowInstanceID, instance.getId());\n    } catch (IOException e) {\n      Assert.fail(e.getMessage());\n    } finally {\n      IOUtils.closeQuietly(packageStream);\n    }\n\n  }\n\n  @Test\n  public void testThickClientOldMP() throws Exception {\n\n    FileUtils.copyURLToFile(urlPackageOld.toURL(), packageFile);\n\n    InputStream packageStream = null;\n    try {\n      packageStream = urlPackageOld.toURL().openStream();\n      WorkflowInstance instance = service.addZippedMediaPackage(packageStream);\n\n      // Assert.assertEquals(2, mediaPackage.getTracks().length);\n      // Assert.assertEquals(3, mediaPackage.getCatalogs().length);\n      Assert.assertEquals(workflowInstanceID, instance.getId());\n    } catch (IOException e) {\n      Assert.fail(e.getMessage());\n    } finally {\n      IOUtils.closeQuietly(packageStream);\n    }\n\n  }\n\n  @Test\n  public void testContentDisposition() throws Exception {\n    MediaPackage mediaPackage = null;\n\n    mediaPackage = service.createMediaPackage();\n    try {\n      mediaPackage = service.addTrack(URI.create(\"http://www.test.com/testfile\"), null, mediaPackage);\n    } catch (Exception e) {\n      Assert.fail(\"Unable to read content dispostion filename: \" + e.getMessage());\n    }\n\n    try {\n      mediaPackage = service.addTrack(urlTrackNoFilename, null, mediaPackage);\n      Assert.fail(\"Allowed adding content without filename!\");\n    } catch (Exception e) {\n      Assert.assertNotNull(e);\n    }\n  }\n\n  private void testAuthWhitelist(String url, String regex, boolean shouldFail, boolean shouldSendAuth, boolean shouldTouchMocks) throws Exception {\n    credClient = EasyMock.createNiceMock(CloseableHttpClient.class);\n    noCredClient = EasyMock.createNiceMock(CloseableHttpClient.class);\n\n    //There's one case (accessing the filesystem) where we *don't* expect the mocks to be used\n    if (shouldTouchMocks) {\n      if (shouldSendAuth) {\n        EasyMock.expect(credClient.execute(EasyMock.anyObject())).andReturn(httpResponse).once();\n        credClient.close();\n        EasyMock.expectLastCall().once();\n      } else {\n        EasyMock.expect(noCredClient.execute(EasyMock.anyObject())).andReturn(httpResponse).once();\n        noCredClient.close();\n        EasyMock.expectLastCall().once();\n      }\n    }\n    EasyMock.replay(noCredClient, credClient);\n\n    //Recreate the service so we use our own, custom mocks\n    service = new IngestServiceImpl() {\n      @Override\n      protected CloseableHttpClient getAuthedHttpClient() {\n        return credClient;\n      }\n\n      @Override\n      protected CloseableHttpClient getNoAuthHttpClient() {\n        return noCredClient;\n      }\n    };\n    setupService();\n\n    MediaPackage mediaPackage = service.createMediaPackage();\n\n    Dictionary<String, String> props = new Hashtable<>();\n    props.put(IngestServiceImpl.DOWNLOAD_SOURCE, regex);\n    service.updated(props);\n\n    try {\n      service.addTrack(URI.create(url), null, mediaPackage);\n    } catch (IOException e) {\n      if (!shouldFail) {\n        Assert.fail(\"Should not have failed!\");\n      }\n    }\n    EasyMock.verify(credClient, noCredClient);\n    EasyMock.reset(credClient, noCredClient);\n  }\n\n  @Test\n  public void testAuthWhitelist() throws Exception {\n    //Test fetching something from something known to be inside the cluster.  This should use the default service-wide trusted client\n    testAuthWhitelist(\"http://localhost/testfile\", \"\", false, true, false);\n\n    //Clear the whitelist, this should *never* send digest auth when fetching files\n    testAuthWhitelist(\"http://www.example.org/testfile\", \"\", false, false, true);\n    //Non-matching regex\n    testAuthWhitelist(\"http://www.example.org/testfile\", \"http://localhost.*\", true, false, true);\n    //Matching regex\n    testAuthWhitelist(\"http://www.example.org/testfile\", \"http://localhost.*|http://www.example.org/.*\", false, true, true);\n\n    //Local filesystem should be actively rejected.  This file needs to *not* be in the resources directory (look in the impl for why), and needs to be readable by the user running the test\n    //NB: This is a horrible, horrible hack, but it's the only way I can think of to get *out* of test-classes.  If you try and ../ your way up above that getResource NPEs, as expected.\n    testAuthWhitelist(getClass().getResource(\"./../../../../\").toURI().resolve(\"../../pom.xml\").toString(), \".*\", true, false, false);\n    //Test to ensure we can't use '..' to get around filters.  Removing the \"..\" works as expected, see below\n    testAuthWhitelist(getClass().getResource(\"./../impl/IngestServiceImplTest.class\").toURI().toString(), \".*\", true, false, false);\n    testAuthWhitelist(getClass().getResource(\"./IngestServiceImplTest.class\").toURI().toString(), \".*\", false, false, false);\n  }\n\n\n  @Test\n  public void testSmilCreation() throws Exception {\n    service.setWorkingFileRepository(new WorkingFileRepositoryImpl() {\n      @Override\n      public URI put(String mediaPackageID, String mediaPackageElementID, String filename, InputStream in)\n              throws IOException {\n        File file = new File(FileUtils.getTempDirectory(), mediaPackageElementID);\n        file.deleteOnExit();\n        FileUtils.write(file, IOUtils.toString(in), \"UTF-8\");\n        return file.toURI();\n      }\n\n      @Override\n      public InputStream get(String mediaPackageID, String mediaPackageElementID)\n              throws NotFoundException, IOException {\n        File file = new File(FileUtils.getTempDirectory(), mediaPackageElementID);\n        return new FileInputStream(file);\n      }\n    });\n\n    URI presenterUri = URI.create(\"http://localhost:8080/presenter.mp4\");\n    URI presenterUri2 = URI.create(\"http://localhost:8080/presenter2.mp4\");\n    URI presentationUri = URI.create(\"http://localhost:8080/presentation.mp4\");\n\n    MediaPackage mediaPackage = service.createMediaPackage();\n    Catalog[] catalogs = mediaPackage.getCatalogs(MediaPackageElements.SMIL);\n    Assert.assertEquals(0, catalogs.length);\n\n    mediaPackage = service.addPartialTrack(presenterUri, MediaPackageElements.PRESENTER_SOURCE_PARTIAL, 60000L,\n            mediaPackage);\n    mediaPackage = service.addPartialTrack(presenterUri2, MediaPackageElements.PRESENTER_SOURCE_PARTIAL, 120000L,\n            mediaPackage);\n    mediaPackage = service.addPartialTrack(presentationUri, MediaPackageElements.PRESENTATION_SOURCE_PARTIAL, 0L,\n            mediaPackage);\n\n    catalogs = mediaPackage.getCatalogs(MediaPackageElements.SMIL);\n    Assert.assertEquals(0, catalogs.length);\n\n    FieldUtils.writeField(FieldUtils.getField(IngestServiceImpl.class, \"skipCatalogs\", true),\n            service, false, true);\n    service.ingest(mediaPackage);\n    catalogs = mediaPackage.getCatalogs(MediaPackageElements.SMIL);\n    Assert.assertEquals(1, catalogs.length);\n\n    Assert.assertEquals(MimeTypes.SMIL, catalogs[0].getMimeType());\n    Either<Exception, Document> eitherDoc = XmlUtil.parseNs(new InputSource(catalogs[0].getURI().toURL().openStream()));\n    Assert.assertTrue(eitherDoc.isRight());\n    Document document = eitherDoc.right().value();\n    Assert.assertEquals(1, document.getElementsByTagName(\"par\").getLength());\n    Assert.assertEquals(2, document.getElementsByTagName(\"seq\").getLength());\n    Assert.assertEquals(2, document.getElementsByTagName(\"video\").getLength());\n    Assert.assertEquals(1, document.getElementsByTagName(\"audio\").getLength());\n  }\n\n  @Test\n  public void testMergeScheduledMediaPackage() throws Exception {\n    MediaPackage ingestMediaPackage = MediaPackageParser\n            .getFromXml(IOUtils.toString(getClass().getResourceAsStream(\"/source-manifest-partial.xml\"), \"UTF-8\"));\n\n    Dictionary<String, String> properties = new Hashtable<>();\n    properties.put(IngestServiceImpl.SKIP_ATTACHMENTS_KEY, \"false\");\n    properties.put(IngestServiceImpl.SKIP_CATALOGS_KEY, \"false\");\n    properties.put(IngestServiceImpl.ADD_ONLY_NEW_FLAVORS_KEY, \"false\");\n    service.updated(properties);\n\n    MediaPackage mergedMediaPackage = service.ingest(ingestMediaPackage).getMediaPackage();\n    Assert.assertEquals(4, mergedMediaPackage.getTracks().length);\n    Track track = mergedMediaPackage.getTrack(\"track-1\");\n    Assert.assertEquals(\"/vonlya1.mov\", track.getURI().toString());\n    Assert.assertEquals(4, mergedMediaPackage.getCatalogs().length);\n    Assert.assertEquals(2, mergedMediaPackage.getAttachments().length);\n    Attachment attachment = mergedMediaPackage.getAttachment(\"cover\");\n    Assert.assertEquals(\"attachments/cover.png\", attachment.getURI().toString());\n\n    // Validate fields\n    Assert.assertEquals(10045L, mergedMediaPackage.getDuration().doubleValue(), 0L);\n    Assert.assertEquals(\"t2\", mergedMediaPackage.getTitle());\n    Assert.assertEquals(\"s2\", mergedMediaPackage.getSeries());\n    Assert.assertEquals(\"st2\", mergedMediaPackage.getSeriesTitle());\n    Assert.assertEquals(\"l2\", mergedMediaPackage.getLicense());\n    Assert.assertEquals(1, mergedMediaPackage.getSubjects().length);\n    Assert.assertEquals(\"s2\", mergedMediaPackage.getSubjects()[0]);\n    Assert.assertEquals(1, mergedMediaPackage.getContributors().length);\n    Assert.assertEquals(\"sd2\", mergedMediaPackage.getContributors()[0]);\n    Assert.assertEquals(1, mergedMediaPackage.getCreators().length);\n    Assert.assertEquals(\"p2\", mergedMediaPackage.getCreators()[0]);\n\n\n  }\n\n  @Test\n  public void testOverwriteAndNoSkip() throws Exception {\n    MediaPackage ingestMediaPackage = MediaPackageParser\n            .getFromXml(IOUtils.toString(getClass().getResourceAsStream(\"/source-manifest-partial.xml\"), \"UTF-8\"));\n\n    Dictionary<String, String> properties = new Hashtable<>();\n\n    MediaPackage mergedMediaPackage = service.ingest(ingestMediaPackage).getMediaPackage();\n\n    // check element skipping\n    properties.put(IngestServiceImpl.SKIP_ATTACHMENTS_KEY, \"true\");\n    properties.put(IngestServiceImpl.SKIP_CATALOGS_KEY, \"true\");\n    properties.put(IngestServiceImpl.ADD_ONLY_NEW_FLAVORS_KEY, \"true\");\n    service.updated(properties);\n\n    // Existing Opencast mp has 3 catalogs and 1 attachment, the ingest mp has 4 and 2.\n    mergedMediaPackage = service.ingest(ingestMediaPackage).getMediaPackage();\n    Assert.assertEquals(0, mergedMediaPackage.getCatalogs().length);\n    Assert.assertEquals(1, mergedMediaPackage.getAttachments().length);\n  }\n\n  @Test\n  public void testVaryEpisodeWithOnlyNewFlavorsFalse() throws Exception {\n    Dictionary<String, String> properties = new Hashtable<>();\n    boolean isAddOnlyNew;\n    // Test with properties and key is false\n    properties.put(IngestServiceImpl.ADD_ONLY_NEW_FLAVORS_KEY, \"false\");\n    service.updated(properties);\n    isAddOnlyNew = service.isAddOnlyNew;\n    Assert.assertFalse(\"Updated overwrite property to false\", isAddOnlyNew);\n    testEpisodeUpdateNewAndExisting();\n  }\n\n  @Test\n  public void testVaryEpisodeWithOnlyNewFlavorsMissingParam() throws Exception {\n    Dictionary<String, String> properties = new Hashtable<>();\n    boolean isAddOnlyNew;\n    // Test with properties file but no overwrite param\n    properties = new Hashtable<>();\n    properties.put(\"blahblah\", \"blahblah\");\n    service.updated(properties);\n    isAddOnlyNew = service.isAddOnlyNew;\n    Assert.assertTrue(\"Is Add Only New defaults to true when param is not found (i.e. commented out)\", isAddOnlyNew);\n\n  }\n\n  @Test\n  public void testNoPropertiesEpisodeOverwriteParam() throws Exception {\n    Dictionary<String, String> properties = new Hashtable<>();\n    boolean isAddOnlyNew;\n    properties = new Hashtable<>();\n    service.updated(properties);\n    isAddOnlyNew = service.isAddOnlyNew;\n    Assert.assertTrue(\"Overwrite property defaults to true when param is commented out\", isAddOnlyNew);\n  }\n\n\n  @Test\n  public void testLegacyMediaPackageId() throws Exception {\n    SchedulerService schedulerService = EasyMock.createNiceMock(SchedulerService.class);\n\n    Map<String, String> properties = new HashMap<String, String>();\n    properties.put(CaptureParameters.INGEST_WORKFLOW_DEFINITION, \"sample\");\n    properties.put(\"agent-name\", \"matterhorn-agent\");\n    EasyMock.expect(schedulerService.getCaptureAgentConfiguration(EasyMock.anyString())).andReturn(properties)\n            .anyTimes();\n    EasyMock.expect(schedulerService.getDublinCore(EasyMock.anyString()))\n            .andReturn(DublinCores.read(urlCatalog1.toURL().openStream())).anyTimes();\n    EasyMock.expect(schedulerService.getMediaPackage(EasyMock.anyString())).andThrow(new NotFoundException()).once();\n    EasyMock.expect(schedulerService.getMediaPackage(EasyMock.anyString())).andReturn(schedulerMediaPackage).once();\n    EasyMock.expect(schedulerService.getMediaPackage(EasyMock.anyString())).andThrow(new NotFoundException())\n            .anyTimes();\n    EasyMock.replay(schedulerService);\n    service.setSchedulerService(schedulerService);\n\n    final Capture<Map<String, String>> captureConfig = EasyMock.newCapture();\n    WorkflowService workflowService = EasyMock.createNiceMock(WorkflowService.class);\n    EasyMock.expect(workflowService.start(EasyMock.anyObject(WorkflowDefinition.class),\n            EasyMock.anyObject(MediaPackage.class), EasyMock.capture(captureConfig)))\n            .andReturn(new WorkflowInstanceImpl()).once();\n    EasyMock.replay(workflowService);\n    service.setWorkflowService(workflowService);\n\n    Map<String, String> wfConfig = new HashMap<>();\n    wfConfig.put(IngestServiceImpl.LEGACY_MEDIAPACKAGE_ID_KEY, \"6f7a7850-3232-4719-9064-24c9bad2832f\");\n    service.ingest(ingestMediaPackage, null, wfConfig);\n    Assert.assertFalse(captureConfig.getValue().containsKey(IngestServiceImpl.LEGACY_MEDIAPACKAGE_ID_KEY));\n  }\n\n  /**\n   * Test four cases: 1) If no config file 2) If config file but no key 3) If key and false value 4) If key and true\n   * value\n   *\n   * @throws Exception\n   */\n  @Test\n  public void testVarySeriesOverwriteConfiguration() throws Exception {\n    boolean isAddOnlyNewSeries;\n    Dictionary<String, String> properties = makeIngestProperties();\n\n    // Test with no properties\n    // NOTE: This test only works if the serivce.update() was not triggered by any previous tests\n    testSeriesUpdateNewAndExisting(null);\n\n    // Test with properties and no key\n    testSeriesUpdateNewAndExisting(properties);\n\n    // Test with properties and key is true\n    isAddOnlyNewSeries = true;\n    properties.put(IngestServiceImpl.ADD_ONLY_NEW_FLAVORS_KEY, String.valueOf(isAddOnlyNewSeries));\n    testSeriesUpdateNewAndExisting(properties);\n\n    // Test series overwrite key is false\n    isAddOnlyNewSeries = false;\n    properties.put(IngestServiceImpl.ADD_ONLY_NEW_FLAVORS_KEY, String.valueOf(isAddOnlyNewSeries));\n    testSeriesUpdateNewAndExisting(properties);\n  }\n\n  @Test\n  public void testFailedJobs() throws Exception {\n    Assert.assertEquals(0, serviceRegistry.getJobs(IngestServiceImpl.JOB_TYPE, Job.Status.FINISHED).size());\n    Assert.assertEquals(0, serviceRegistry.getJobs(IngestServiceImpl.JOB_TYPE, Job.Status.FAILED).size());\n    service.addTrack(urlTrack, MediaPackageElements.PRESENTATION_SOURCE, service.createMediaPackage());\n    Assert.assertEquals(1, serviceRegistry.getJobs(IngestServiceImpl.JOB_TYPE, Job.Status.FINISHED).size());\n    Assert.assertEquals(0, serviceRegistry.getJobs(IngestServiceImpl.JOB_TYPE, Job.Status.FAILED).size());\n    try {\n      service.addTrack(URI.create(\"file//baduri\"), MediaPackageElements.PRESENTATION_SOURCE,\n              service.createMediaPackage());\n    } catch (Exception e) {\n      // Ignore exception\n    }\n    Assert.assertEquals(1, serviceRegistry.getJobs(IngestServiceImpl.JOB_TYPE, Job.Status.FINISHED).size());\n    Assert.assertEquals(1, serviceRegistry.getJobs(IngestServiceImpl.JOB_TYPE, Job.Status.FAILED).size());\n  }\n\n  private void testEpisodeUpdateNewAndExisting() throws Exception {\n    boolean isAddOnlyNew = service.isAddOnlyNew;\n    MediaPackage partialIngestMediaPackage = MediaPackageParser\n            .getFromXml(IOUtils.toString(getClass().getResourceAsStream(\"/source-manifest-partial.xml\"), \"UTF-8\"));\n\n    WorkflowInstance instance = service.ingest(partialIngestMediaPackage);\n\n    MediaPackage mergedMediaPackage = instance.getMediaPackage();\n    Assert.assertEquals(4, mergedMediaPackage.getTracks().length);\n    Track track = mergedMediaPackage.getTrack(\"track-1\");\n    Assert.assertEquals(\"/vonlya1.mov\", track.getURI().toString());\n    // Existing mp has 3 catalogs 1 attachments, ingest mp has 4 and 2.\n    Assert.assertEquals(4, mergedMediaPackage.getCatalogs().length);\n    Assert.assertEquals(2, mergedMediaPackage.getAttachments().length);\n    Attachment attachment = mergedMediaPackage.getAttachment(\"cover\");\n\n    // The live pub is always omitted, regardless of state of isAddOnlyNew\n    Publication[] pubs = this.schedulerMediaPackage.getPublications();\n    Assert.assertEquals(\"Pub is part of asset managed mediapackage\", 1, pubs.length);\n    Publication[] pubs2 = mergedMediaPackage.getPublications();\n    Assert.assertEquals(\"Pub is not added back into ingested mediapackage\", 0, pubs2.length);\n\n    // Validate fields\n    if (!isAddOnlyNew) { // overwrite\n      Assert.assertEquals(\"attachments/cover.png\", attachment.getURI().toString());\n      Assert.assertEquals(\"t2\", mergedMediaPackage.getTitle());\n      Assert.assertEquals(\"t2\", mergedMediaPackage.getTitle());\n      Assert.assertEquals(\"s2\", mergedMediaPackage.getSeries());\n      Assert.assertEquals(\"st2\", mergedMediaPackage.getSeriesTitle());\n      Assert.assertEquals(\"l2\", mergedMediaPackage.getLicense());\n      Assert.assertEquals(1, mergedMediaPackage.getSubjects().length);\n      Assert.assertEquals(\"s2\", mergedMediaPackage.getSubjects()[0]);\n      Assert.assertEquals(1, mergedMediaPackage.getContributors().length);\n      Assert.assertEquals(\"sd2\", mergedMediaPackage.getContributors()[0]);\n      Assert.assertEquals(1, mergedMediaPackage.getCreators().length);\n      Assert.assertEquals(\"p2\", mergedMediaPackage.getCreators()[0]);\n\n    } else { // no overwrite\n      Assert.assertEquals(\"/cover.png\", attachment.getURI().toString());\n      Assert.assertEquals(\"t1\", mergedMediaPackage.getTitle());\n      Assert.assertEquals(\"t1\", mergedMediaPackage.getTitle());\n      Assert.assertEquals(\"s1\", mergedMediaPackage.getSeries());\n      Assert.assertEquals(\"st1\", mergedMediaPackage.getSeriesTitle());\n      Assert.assertEquals(\"l1\", mergedMediaPackage.getLicense());\n      Assert.assertEquals(1, mergedMediaPackage.getSubjects().length);\n      Assert.assertEquals(\"s1\", mergedMediaPackage.getSubjects()[0]);\n      Assert.assertEquals(1, mergedMediaPackage.getContributors().length);\n      Assert.assertEquals(\"sd1\", mergedMediaPackage.getContributors()[0]);\n      Assert.assertEquals(1, mergedMediaPackage.getCreators().length);\n      Assert.assertEquals(\"p1\", mergedMediaPackage.getCreators()[0]);\n    }\n\n    Assert.assertEquals(10045L, mergedMediaPackage.getDuration().doubleValue(), 0L);\n\n  }\n\n  /**\n   * Utility to set the default required properties\n   *\n   * @return default properties\n   */\n  private Dictionary<String, String> makeIngestProperties() {\n    Dictionary<String, String> properties = new Hashtable<>();\n    String downloadPassword = \"CHANGE_ME\";\n    String downloadSource = \"http://localhost\";\n    String downloadUser = \"opencast_system_account\";\n\n    properties.put(IngestServiceImpl.DOWNLOAD_PASSWORD, downloadPassword);\n    properties.put(IngestServiceImpl.DOWNLOAD_SOURCE, downloadSource);\n    properties.put(IngestServiceImpl.DOWNLOAD_USER, downloadUser);\n\n    return properties;\n  }\n\n  /**\n   * Test method for {@link org.opencastproject.ingest.impl.IngestServiceImpl#updateSeries(java.net.URI)}\n   */\n  private void testSeriesUpdateNewAndExisting(Dictionary<String, String> properties) throws Exception {\n\n    // default expectation for series overwrite\n    boolean isUpdateSeries = IngestServiceImpl.DEFAULT_ALLOW_SERIES_MODIFICATIONS;\n\n    if (properties != null) {\n      service.updated(properties);\n      try {\n        boolean testForValue = Boolean.parseBoolean(properties.get(IngestServiceImpl.MODIFY_OPENCAST_SERIES_KEY).trim());\n        isUpdateSeries = testForValue;\n      } catch (Exception e) {\n        // If key or value not found or not boolean, use the default overwrite expectation\n      }\n    }\n\n    // Get test series dublin core for the mock return value\n    File catalogFile = new File(urlCatalog2);\n    if (!catalogFile.exists() || !catalogFile.canRead())\n      throw new Exception(\"Unable to access test catalog \" + urlCatalog2.getPath());\n    FileInputStream in = new FileInputStream(catalogFile);\n    DublinCoreCatalog series = DublinCores.read(in);\n    IOUtils.closeQuietly(in);\n\n    // Set dublinCore service to return test dublin core\n    dublinCoreService = org.easymock.EasyMock.createNiceMock(DublinCoreCatalogService.class);\n    org.easymock.EasyMock.expect(dublinCoreService.load((InputStream) EasyMock.anyObject())).andReturn(series)\n            .anyTimes();\n    org.easymock.EasyMock.replay(dublinCoreService);\n    service.setDublinCoreService(dublinCoreService);\n\n    // Test with mock found series\n    seriesService = EasyMock.createNiceMock(SeriesService.class);\n    EasyMock.expect(seriesService.getSeries((String) EasyMock.anyObject())).andReturn(series).once();\n    EasyMock.expect(seriesService.updateSeries(series)).andReturn(series).once();\n    EasyMock.replay(seriesService);\n    service.setSeriesService(seriesService);\n\n    // This is true or false depending on the isAddOnlyNew value\n    Assert.assertEquals(\"Desire to update series is \" + isUpdateSeries + \".\",\n            isUpdateSeries, service.updateSeries(urlCatalog2));\n\n    // Test with mock not found exception\n    EasyMock.reset(seriesService);\n    EasyMock.expect(seriesService.updateSeries(series)).andReturn(series).once();\n    EasyMock.expect(seriesService.getSeries((String) EasyMock.anyObject())).andThrow(new NotFoundException()).once();\n    EasyMock.replay(seriesService);\n\n    service.setSeriesService(seriesService);\n\n    // This should be true, i.e. create new series, in all cases\n    Assert.assertEquals(\"Always create a new series catalog.\", true, service.updateSeries(urlCatalog2));\n  }\n\n}\n"], "filenames": ["modules/ingest-service-impl/src/main/java/org/opencastproject/ingest/impl/IngestServiceImpl.java", "modules/ingest-service-impl/src/test/java/org/opencastproject/ingest/impl/IngestServiceImplTest.java"], "buggy_code_start_loc": [317, 346], "buggy_code_end_loc": [1606, 493], "fixing_code_start_loc": [318, 347], "fixing_code_end_loc": [1611, 502], "type": "CWE-552", "message": "Opencast is an Open Source Lecture Capture & Video Management for Education. Opencast before version 9.10 or 10.6 allows references to local file URLs in ingested media packages, allowing attackers to include local files from Opencast's host machines and making them available via the web interface. Before Opencast 9.10 and 10.6, Opencast would open and include local files during ingests. Attackers could exploit this to include most local files the process has read access to, extracting secrets from the host machine. An attacker would need to have the privileges required to add new media to exploit this. But these are often widely given. The issue has been fixed in Opencast 10.6 and 11.0. You can mitigate this issue by narrowing down the read access Opencast has to files on the file system using UNIX permissions or mandatory access control systems like SELinux. This cannot prevent access to files Opencast needs to read though and we highly recommend updating.", "other": {"cve": {"id": "CVE-2021-43821", "sourceIdentifier": "security-advisories@github.com", "published": "2021-12-14T20:15:07.617", "lastModified": "2021-12-20T20:48:12.830", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Opencast is an Open Source Lecture Capture & Video Management for Education. Opencast before version 9.10 or 10.6 allows references to local file URLs in ingested media packages, allowing attackers to include local files from Opencast's host machines and making them available via the web interface. Before Opencast 9.10 and 10.6, Opencast would open and include local files during ingests. Attackers could exploit this to include most local files the process has read access to, extracting secrets from the host machine. An attacker would need to have the privileges required to add new media to exploit this. But these are often widely given. The issue has been fixed in Opencast 10.6 and 11.0. You can mitigate this issue by narrowing down the read access Opencast has to files on the file system using UNIX permissions or mandatory access control systems like SELinux. This cannot prevent access to files Opencast needs to read though and we highly recommend updating."}, {"lang": "es", "value": "Opencast es un software de c\u00f3digo abierto para la captura de conferencias y la administraci\u00f3n de v\u00eddeo para la educaci\u00f3n. Opencast versiones anteriores a 9.10 o 10.6, permite referencias a URLs de archivos locales en paquetes de medios ingeridos, permitiendo a atacantes incluir archivos locales de las m\u00e1quinas anfitrionas de Opencast y hacerlos disponibles por medio de la interfaz web. En versiones anteriores a Opencast 9.10 y 10.6, Opencast abr\u00eda e inclu\u00eda archivos locales durante las ingestas. Los atacantes pod\u00edan aprovechar esto para incluir la mayor\u00eda de los archivos locales a los que el proceso tuviera acceso de lectura, extrayendo secretos de la m\u00e1quina anfitriona. Un atacante necesitar\u00eda tener los privilegios necesarios para a\u00f1adir nuevos medios para explotar esto. Sin embargo, estos suelen ser ampliamente otorgados. El problema se ha corregido en Opencast versiones 10.6 y 11.0. Puede mitigar este problema limitando el acceso de lectura que Opencast posee a los archivos del sistema de archivos mediante permisos UNIX o sistemas de control de acceso obligatorios como SELinux. Sin embargo, esto no puede impedir el acceso a los archivos que Opencast necesita leer, por lo que recomendamos encarecidamente la actualizaci\u00f3n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.7, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.1, "impactScore": 4.0}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.9, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.1, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-552"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-552"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:apereo:opencast:*:*:*:*:*:*:*:*", "versionEndExcluding": "10.6", "matchCriteriaId": "8AFC8FC9-B836-439D-96C4-6DD80FFFB37F"}]}]}], "references": [{"url": "https://github.com/opencast/opencast/blob/69952463971cf578363e3b97d8edaf334ff51253/modules/ingest-service-impl/src/main/java/org/opencastproject/ingest/impl/IngestServiceImpl.java#L1587", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/opencast/opencast/commit/65c46b9d3e8f045c544881059923134571897764", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/opencast/opencast/security/advisories/GHSA-59g4-hpg3-3gcp", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://mvnrepository.com/artifact/org.opencastproject/opencast-ingest-service-impl", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/opencast/opencast/commit/65c46b9d3e8f045c544881059923134571897764"}}