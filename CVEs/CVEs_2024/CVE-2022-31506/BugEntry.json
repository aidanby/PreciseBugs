{"buggy_code": ["#\n#  The OpenDiamond Platform for Interactive Search\n#\n#  Copyright (c) 2009-2018 Carnegie Mellon University\n#  All rights reserved.\n#\n#  This software is distributed under the terms of the Eclipse Public\n#  License, Version 1.0 which can be found in the file named LICENSE.\n#  ANY USE, REPRODUCTION OR DISTRIBUTION OF THIS SOFTWARE CONSTITUTES\n#  RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT\n#\n\nfrom builtins import next\nfrom builtins import range\nimport os\nimport datetime\nfrom xml.sax.saxutils import quoteattr\nimport sys\n\nimport logging\nimport random\nimport glob\nfrom itertools import cycle\nfrom flask import Blueprint, url_for, Response, stream_with_context, send_file, \\\n    jsonify\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.utils import safe_join\nfrom opendiamond.dataretriever.util import read_file_list, write_data\n\n\nBASEURL = 'augment'\nSTYLE = False\nLOCAL_OBJ_URI = True  # if true, return local file path, otherwise http.\nINDEXDIR = DATAROOT = None\nITEMS_PER_ITERATION = int(1e4)\nKEYWORD = 'yellowthroat'\n\n\"\"\"\n    Example url:\n        /augment/root/<ROOT_DIR>/distributed/<id>of<N>/ \\\n            keywords/<d/r ([d]eterminant/[r]andom)>_<random_seed>_<base_rate>\n\n        /augment/root/STREAM/distributed/1of2/keywords/d_42_1.0\n\"\"\"\n\n\ndef init(config):\n    global INDEXDIR, DATAROOT  # pylint: disable=global-statement\n    INDEXDIR = 'STREAM'\n    DATAROOT = config.dataroot\n\n\nscope_blueprint = Blueprint('augment_store', __name__)\n\n_log = logging.getLogger(__name__)\n\n@scope_blueprint.route('/root/<rootdir>/distributed/<int:index>of<int:total>' +\n                        '/keywords/<params>')\n@scope_blueprint.route('/root/<rootdir>/keywords/<params>')\n@scope_blueprint.route('/root/<rootdir>/distributed/<int:index>of<int:total>' +\n                        '/keywords/<params>/start/<int:start>/limit/<int:limit>')\n@scope_blueprint.route('/root/<rootdir>/keywords/<params>' +\n                        '/start/<int:start>/limit/<int:limit>')\ndef get_scope(rootdir, index=0, total=1, params=None, start=0, limit=sys.maxsize):\n    global KEYWORD\n    if rootdir == \"0\":\n        rootdir = INDEXDIR\n\n    rootdir = _get_obj_absolute_path(rootdir)\n    seed = None\n    percentage = 0.\n    seed, percentage = decode_params(params)\n\n    # Assuming the same positive list is present in all the servers\n    # Always create a new index file\n    base_list, KEYWORD = create_index(rootdir, percentage, seed, index, total)\n    total_entries = len(base_list)\n\n    start = start if start > 0 else 0\n    end = min(total_entries, start + limit) if limit > 0 else total_entries\n    base_list = base_list[start:end]\n    total_entries = end - start\n\n    def generate():\n        yield '<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\\n'\n        if STYLE:\n            yield '<?xml-stylesheet type=\"text/xsl\" href=\"/scopelist.xsl\" ?>\\n'\n\n        yield '<objectlist count=\"{:d}\">\\n'.format(total_entries)\n\n        for path in base_list:\n            path = path.strip()\n            yield _get_object_element(object_path=path) + '\\n'\n\n        yield '</objectlist>\\n'\n\n    headers = Headers([('Content-Type', 'text/xml')])\n\n    return Response(stream_with_context(generate()),\n                    status=\"200 OK\",\n                    headers=headers)\n\ndef decode_params(params):\n    \"\"\"\n    Decodes the params which are '_' seperated\n    <[d]eterminant/[r]andom>_<random_seed>_<baserate>\n    \"\"\"\n    keywords = params.split('_')\n    mix_type = keywords[0]\n    seed = None\n    if len(keywords) > 1:\n        seed = int(keywords[1])\n    if mix_type == 'r' or seed is None:\n        seed = random.randrange(10000)\n    percentage = 0.1 # default base_rate = 0.1%\n    if len(keywords) > 2:\n        percentage = float(keywords[2])\n    return seed, round(percentage, 4)\n\n@scope_blueprint.route('/id/<path:object_path>')\ndef get_object_id(object_path):\n    headers = Headers([('Content-Type', 'text/xml')])\n    return Response(_get_object_element(object_path=object_path),\n                    \"200 OK\",\n                    headers=headers)\n\ndef _get_object_element(object_path):\n    path = _get_obj_absolute_path(object_path)\n    meta = {'_gt_label': KEYWORD}\n    if KEYWORD in path:\n        return '<object id={} src={} meta={} />' \\\n                .format(quoteattr(url_for('.get_object_id', object_path=object_path)),\n                        quoteattr(_get_object_src_uri(object_path)),\n                        quoteattr(url_for('.get_object_meta', present=True)))\n\n    return '<object id={} src={} />' \\\n            .format(quoteattr(url_for('.get_object_id', object_path=object_path)),\n                    quoteattr(_get_object_src_uri(object_path)))\n\n\n@scope_blueprint.route('/meta/<path:present>')\ndef get_object_meta(present=False):\n    attrs = dict()\n    if present:\n        attrs['_gt_label'] = KEYWORD\n\n    return jsonify(attrs)\n\ndef _get_object_src_uri(object_path):\n    if LOCAL_OBJ_URI:\n        return 'file://' + _get_obj_absolute_path(object_path)\n\n    return url_for('.get_object_src_http', obj_path=object_path)\n\ndef _get_obj_absolute_path(obj_path):\n    return safe_join(DATAROOT, obj_path)\n\n@scope_blueprint.route('/obj/<path:obj_path>')\ndef get_object_src_http(obj_path):\n    path = _get_obj_absolute_path(obj_path)\n\n    headers = Headers()\n    # With add_etags=True, conditional=True\n    # Flask should be smart enough to do 304 Not Modified\n    response = send_file(path,\n                         cache_timeout=datetime.timedelta(\n                             days=365).total_seconds(),\n                         add_etags=True,\n                         conditional=True)\n    response.headers.extend(headers)\n    return response\n\ndef create_index(base_dir, base_rate=0.05, seed=42, rank=0, total_servers=1):\n    \"\"\"\n    Creates Index List File:\n    Assuming name of files NEGATIVE (e.g:subset YFCC), POSITIVE\n    \"\"\"\n\n    filepath_split = ['STREAM', \"{:.2f}\".format(base_rate), str(rank), str(total_servers), str(seed)]\n    filepath = '_'.join(filepath_split)\n    filepath = os.path.join(base_dir, filepath)\n    positive_path = os.path.join(base_dir, 'POSITIVE')\n    negative_path = os.path.join(base_dir, 'NEGATIVE')\n    positive_firstline = open(positive_path).readline().rstrip()\n    keyword = positive_firstline.split('/')[-2] # Assuming all positives are in the same parent dir\n\n    _log.info(\"Dir {} BR: {} Seed:{} FP{}\".format(base_dir, base_rate, seed, filepath))\n    sys.stdout.flush()\n\n    if not os.path.exists(filepath):\n        positive_data = read_file_list(positive_path) # same across servers\n        negative_data = read_file_list(negative_path) # different across servers\n        random.Random(seed).shuffle(positive_data)\n        random.Random(seed).shuffle(negative_data)\n        len_positive = len(positive_data)\n        start_idx = int(rank * (1.0 / total_servers) * len_positive)\n        end_idx = int((rank+1) * (1.0 / total_servers) * len_positive)\n        positive_data = positive_data[start_idx:end_idx]\n        len_positive = len(positive_data)\n        negative_sample = int(len_positive * (100./base_rate -1))\n        negative_data = negative_data[:negative_sample]\n        return write_data(filepath, [negative_data, positive_data], seed), keyword\n\n    return read_file_list(filepath), keyword\n", "#\n#  The OpenDiamond Platform for Interactive Search\n#\n#  Copyright (c) 2009-2018 Carnegie Mellon University\n#  All rights reserved.\n#\n#  This software is distributed under the terms of the Eclipse Public\n#  License, Version 1.0 which can be found in the file named LICENSE.\n#  ANY USE, REPRODUCTION OR DISTRIBUTION OF THIS SOFTWARE CONSTITUTES\n#  RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT\n#\n\nimport os\nimport datetime\nfrom xml.sax.saxutils import quoteattr\n\nfrom flask import Blueprint, url_for, Response, stream_with_context, send_file, \\\n    jsonify\nfrom werkzeug.datastructures import Headers\n\nfrom opendiamond.dataretriever.util import ATTR_SUFFIX\n\nBASEURL = 'collection'\nSTYLE = False\nLOCAL_OBJ_URI = True  # if true, return local file path, otherwise http.\nINDEXDIR = DATAROOT = None\n\n\ndef init(config):\n    global INDEXDIR, DATAROOT  # pylint: disable=global-statement\n    INDEXDIR = config.indexdir\n    DATAROOT = config.dataroot\n\n\nscope_blueprint = Blueprint('diamond_store', __name__)\n\n\n@scope_blueprint.route('/<gididx>')\n@scope_blueprint.route('/<gididx>/limit/<int:limit>')\ndef get_scope(gididx, limit=None):\n    index = 'GIDIDX' + gididx.upper()\n    index = _get_index_absolute_path(index)\n\n    # Streaming response:\n    # http://flask.pocoo.org/docs/0.12/patterns/streaming/\n    def generate():\n        num_entries = 0\n        with open(index, 'r') as f:\n            for _ in f.readlines():\n                num_entries += 1\n                if limit is not None and num_entries >= limit:\n                    break\n\n        with open(index, 'r') as f:\n            yield '<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\\n'\n            if STYLE:\n                yield '<?xml-stylesheet type=\"text/xsl\" href=\"/scopelist.xsl\" ?>\\n'\n\n            yield '<objectlist count=\"{:d}\">\\n'.format(num_entries)\n            \n            count = 0\n            for path in f.readlines():\n                path = path.strip()\n                yield _get_object_element(object_path=path) + '\\n'\n                count += 1\n                if limit is not None and count >= limit:\n                    break\n\n            yield '</objectlist>\\n'\n\n    headers = Headers([('Content-Type', 'text/xml')])\n\n    return Response(stream_with_context(generate()),\n                    status=\"200 OK\",\n                    headers=headers)\n\n\n@scope_blueprint.route('/id/<path:object_path>')\ndef get_object_id(object_path):\n    headers = Headers([('Content-Type', 'text/xml')])\n    return Response(_get_object_element(object_path=object_path),\n                    \"200 OK\",\n                    headers=headers)\n\n\n@scope_blueprint.route('/meta/<path:object_path>')\ndef get_object_meta(object_path):\n    path = _get_obj_absolute_path(object_path)\n    attrs = dict()\n\n    try:\n        with DiamondTextAttr(path, 'r') as attributes:\n            for key, value in attributes:\n                attrs[key] = value\n    except IOError:\n        pass\n\n    return jsonify(attrs)\n\n\ndef _get_object_element(object_path):\n    path = _get_obj_absolute_path(object_path)\n\n    if os.path.isfile(path + ATTR_SUFFIX):\n        return '<object id={} src={} meta={} />' \\\n            .format(quoteattr(url_for('.get_object_id', object_path=object_path)),\n                    quoteattr(_get_object_src_uri(object_path)),\n                    quoteattr(url_for('.get_object_meta', object_path=object_path)))\n    else:\n        return '<object id={} src={} />' \\\n            .format(quoteattr(url_for('.get_object_id', object_path=object_path)),\n                    quoteattr(_get_object_src_uri(object_path)))\n\n\ndef _get_object_src_uri(object_path):\n    if LOCAL_OBJ_URI:\n        return 'file://' + _get_obj_absolute_path(object_path)\n    else:\n        return url_for('.get_object_src_http', obj_path=object_path)\n\n\ndef _get_obj_absolute_path(obj_path):\n    return os.path.join(DATAROOT, obj_path)\n\n\ndef _get_index_absolute_path(index):\n    return os.path.join(INDEXDIR, index)\n\n\n@scope_blueprint.route('/obj/<path:obj_path>')\ndef get_object_src_http(obj_path):\n    path = _get_obj_absolute_path(obj_path)\n\n    headers = Headers()\n    # With add_etags=True, conditional=True\n    # Flask should be smart enough to do 304 Not Modified\n    response = send_file(path,\n                         cache_timeout=datetime.timedelta(\n                             days=365).total_seconds(),\n                         add_etags=True,\n                         conditional=True)\n    response.headers.extend(headers)\n    return response\n", "#\n#  The OpenDiamond Platform for Interactive Search\n#\n#  Copyright (c) 2009-2018 Carnegie Mellon University\n#  All rights reserved.\n#\n#  This software is distributed under the terms of the Eclipse Public\n#  License, Version 1.0 which can be found in the file named LICENSE.\n#  ANY USE, REPRODUCTION OR DISTRIBUTION OF THIS SOFTWARE CONSTITUTES\n#  RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT\n#\n\nfrom builtins import next\nfrom builtins import range\nimport os\nimport datetime\nfrom xml.sax.saxutils import quoteattr\nimport sys\n\nimport logging\nimport random\nimport glob\nfrom itertools import cycle\nfrom flask import Blueprint, url_for, Response, stream_with_context, send_file, \\\n    jsonify\nfrom werkzeug.datastructures import Headers\n\nBASEURL = 'cocktail'\nSTYLE = False\nLOCAL_OBJ_URI = True  # if true, return local file path, otherwise http.\nINDEXDIR = DATAROOT = None\nITEMS_PER_ITERATION = int(1e4)\n\n\"\"\"\n    Example cocktail url:\n        /cocktail/base/FFFFFFFFFFFFFFFF/distrbuted/1of2/ \\\n            mixers/FFFFFFFFFFFFFFFC/keywords/d_42_1.0/classes/gull,cardinal\n        /cocktail/base/\"0\"/mixers/FFFFFFFFFFFFFFFC/keywords/d_42_1.0\n        /cocktail/base/FFFFFFFFFFFFFFFF/keywords/d_42_1.0\n\"\"\"\n\n\ndef init(config):\n    global INDEXDIR, DATAROOT  # pylint: disable=global-statement\n    INDEXDIR = config.indexdir\n    DATAROOT = config.dataroot\n\n\nscope_blueprint = Blueprint('mixer_store', __name__)\n\n_log = logging.getLogger(__name__)\n\n@scope_blueprint.route('/base/<baseidx>/mixers/<mixeridx>/keywords/<params>')\n@scope_blueprint.route('/base/<baseidx>/mixers/<mixeridx>/keywords/<params>/' +\n                        'classes/<classes>')\n@scope_blueprint.route('/base/<baseidx>/mixers/<mixeridx>/keywords/<params>/' +\n                        'classes/<classes>/start/<int:start>/limit/<int:limit>')\n@scope_blueprint.route('/base/<baseidx>/distrbuted/<int:index>of<int:total>/' +\n                        'mixers/<mixeridx>/keywords/<params>')\n@scope_blueprint.route('/base/<baseidx>/distrbuted/<int:index>of<int:total>/' +\n                        'mixers/<mixeridx>/keywords/<params>/classes/<classes>')\ndef get_mixer_classes(baseidx, mixeridx=None, index=1, total=1, params=None, \n                      classes=None, start=0, limit=-1):\n\n    mixer_list = get_mixer_list(mixeridx, classes)\n    start_idx = int((index-1)*(1.0/total)*len(mixer_list))\n    end_idx = int(index*(1.0/total)*len(mixer_list))\n    mixer_list = mixer_list[start_idx:end_idx]\n    print(\"Mixer Size {}\".format(len(mixer_list)))\n    sys.stdout.flush()\n\n    return get_scope(baseidx, params, mixer_list, start, limit)\n\n@scope_blueprint.route('/base/<baseidx>/keywords/<params>')\n@scope_blueprint.route('/base/<baseidx>/keywords/<params>/start/<int:start>/limit/<int:limit>')\ndef get_scope(baseidx, params=None, mixer_list=None, start=0, limit=-1):\n    print(\"Enter Scope\")\n    sys.stdout.flush()\n    base_list = []\n    seed, percentage = decode_params(params)\n    if baseidx != \"0\":\n        base_index = _get_index_absolute_path('GIDIDX' + baseidx.upper())\n        with open(base_index, 'r') as f:\n            base_list = list(f.readlines())\n        if limit > 0:\n            base_list = base_list[start:start+limit]\n        elif start > 0:\n            base_list = base_list[start:]\n        total_entries = len(base_list)\n\n\n    make_cocktail = bool(mixer_list and base_list)\n        \n    if base_list:\n        total_entries = len(base_list)  #base_entries\n    else:\n        total_entries = len(mixer_list)\n        base_list = mixer_list.copy()\n        del mixer_list\n\n    random.seed(seed)\n    #random.Random(seed).shuffle(base_list)\n\n    total_sample = 0 \n    if make_cocktail:\n        random.Random(seed).shuffle(mixer_list)\n        total_sample = int(percentage*total_entries)\n        total_entries = total_entries + total_sample\n\n    # Streaming response:\n    # http://flask.pocoo.org/docs/0.12/patterns/streaming/\n    def generate():\n\n        yield '<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\\n'\n        if STYLE:\n            yield '<?xml-stylesheet type=\"text/xsl\" href=\"/scopelist.xsl\" ?>\\n'\n\n        yield '<objectlist count=\"{:d}\">\\n'.format(total_entries)\n\n        mix_per_iteration = 0\n        iteration_count = 0\n        if make_cocktail:\n            mix_per_iteration = int(percentage * ITEMS_PER_ITERATION)\n            pool = cycle(mixer_list)\n\n        mix_indices = []\n\n        def generate_mix_indices():\n            random.seed(seed)\n            return list(map(lambda x: x + ITEMS_PER_ITERATION*iteration_count,\n                    sorted(random.sample(list(range(ITEMS_PER_ITERATION)), mix_per_iteration))))\n\n        for count in range(total_entries):\n            if not count % ITEMS_PER_ITERATION and make_cocktail:\n                mix_indices = generate_mix_indices()\n                iteration_count += 1\n\n            if count in mix_indices:\n                obj_path = next(pool).strip()\n            else:\n                obj_path = base_list.pop(0).strip()\n            yield _get_object_element(object_path=obj_path) + '\\n'\n\n        yield '</objectlist>\\n'\n\n    headers = Headers([('Content-Type', 'text/xml')])\n\n    return Response(stream_with_context(generate()),\n                    status=\"200 OK\",\n                    headers=headers)\n\ndef decode_params(params):\n    keywords = params.split('_')\n    m_type = keywords[0]\n    seed = int(keywords[1])\n    percentage = 0.0001\n    if m_type == 'r':\n        seed = None\n    if len(keywords) > 2:\n        percentage = float(keywords[2])/100.\n    return seed, round(percentage, 4)\n\ndef get_mixer_list(idx, classes=None):\n    \"\"\"\n    Return list of file paths present in given classes of mixer set\n    If class list is None or incorrect then return list of entire mixer set.\n\n    Args:\n        classes (str): Comma seperated classes of interest\n        idx     (str): Index of mixer collection\n\n    Returns:\n    \"\"\"\n    mixer_index = _get_index_absolute_path('GIDIDX' + idx.upper())\n    classes_list = []\n    if classes:\n        classes.replace('%2C', ',')\n        classes.replace('%20', ' ')\n        classes_list = classes.split(',')\n\n    def get_class_path():\n        with open(mixer_index, 'r') as f:\n            dataset_path = f.readline()\n        dataset_path = '/'.join(dataset_path.split('/')[:-2])\n        class_paths = []\n        for c in classes_list:\n            class_paths.append(_get_obj_absolute_path(dataset_path+'/'+c.strip()))\n        return class_paths\n\n    mixer_list = []\n    class_paths = get_class_path()\n    print(\"Class paths : {}\".format(class_paths))\n    sys.stdout.flush()\n\n    if class_paths:\n        for path in class_paths:\n            print(\"Path Exists ? {}\".format(os.path.exists(path)))\n            sys.stdout.flush()\n\n            mixer_list.extend(sorted(glob.glob(os.path.join(path, \"*.jpg\"))))\n        mixer_list = [_get_obj_path(l.strip()) for l in mixer_list]\n    else:\n        with open(mixer_index, 'r') as f:\n            mixer_list = list(f.readlines())\n\n    return mixer_list\n\n@scope_blueprint.route('/id/<path:object_path>')\ndef get_object_id(object_path):\n    headers = Headers([('Content-Type', 'text/xml')])\n    return Response(_get_object_element(object_path=object_path),\n                    \"200 OK\",\n                    headers=headers)\n\n\n@scope_blueprint.route('/meta/<path:object_path>')\ndef get_object_meta(object_path):\n    path = _get_obj_absolute_path(object_path)\n    attrs = dict()\n\n    try:\n        attrs['_gt_label'] = path.split('/')[-2]\n    except IOError:\n        pass\n\n    return jsonify(attrs)\n\n\ndef _get_object_element(object_path):\n    path = _get_obj_absolute_path(object_path)\n    class_text = '/'.join(path.split('/')[:-2])+'/classes.txt'\n    if os.path.isfile(class_text):\n        return '<object id={} src={} meta={} />' \\\n            .format(quoteattr(url_for('.get_object_id', object_path=object_path)),\n                    quoteattr(_get_object_src_uri(object_path)),\n                    quoteattr(url_for('.get_object_meta', object_path=object_path)))\n    return '<object id={} src={} />' \\\n            .format(quoteattr(url_for('.get_object_id', object_path=object_path)),\n                    quoteattr(_get_object_src_uri(object_path)))\n\n\ndef _get_object_src_uri(object_path):\n    if LOCAL_OBJ_URI:\n        return 'file://' + _get_obj_absolute_path(object_path)\n\n    return url_for('.get_object_src_http', obj_path=object_path)\n\ndef _get_obj_path(obj_path):\n    return obj_path.replace(DATAROOT+'/', '')\n\ndef _get_obj_absolute_path(obj_path):\n    return os.path.join(DATAROOT, obj_path)\n\n\ndef _get_index_absolute_path(index):\n    return os.path.join(INDEXDIR, index)\n\n\n@scope_blueprint.route('/obj/<path:obj_path>')\ndef get_object_src_http(obj_path):\n    path = _get_obj_absolute_path(obj_path)\n\n    headers = Headers()\n    # With add_etags=True, conditional=True\n    # Flask should be smart enough to do 304 Not Modified\n    response = send_file(path,\n                         cache_timeout=datetime.timedelta(\n                             days=365).total_seconds(),\n                         add_etags=True,\n                         conditional=True)\n    response.headers.extend(headers)\n    return response\n", "#\n#  The OpenDiamond Platform for Interactive Search\n#\n#  Copyright (c) 2009-2018 Carnegie Mellon University\n#  All rights reserved.\n#\n#  This software is distributed under the terms of the Eclipse Public\n#  License, Version 1.0 which can be found in the file named LICENSE.\n#  ANY USE, REPRODUCTION OR DISTRIBUTION OF THIS SOFTWARE CONSTITUTES\n#  RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT\n#\n\nfrom builtins import next\nfrom builtins import range\nimport os\nimport datetime\nfrom xml.sax.saxutils import quoteattr\nimport sys\n\nimport logging\nimport random\nimport glob\nfrom itertools import cycle\nfrom flask import Blueprint, url_for, Response, stream_with_context, send_file, \\\n    jsonify\nfrom werkzeug.datastructures import Headers\nfrom opendiamond.dataretriever.test_utils import *\n\n\nBASEURL = 'cocktailtest'\nSTYLE = False\nLOCAL_OBJ_URI = True  # if true, return local file path, otherwise http.\nINDEXDIR = DATAROOT = None\nITEMS_PER_ITERATION = int(1e4)\n\n\"\"\"\n    Example cocktail url:\n        /cocktail/base/FFFFFFFFFFFFFFFF/distrbuted/1of2/ \\\n            mixers/FFFFFFFFFFFFFFFC/keywords/d_42_1.0/classes/gull,cardinal\n        /cocktail/base/\"0\"/mixers/FFFFFFFFFFFFFFFC/keywords/d_42_1.0\n        /cocktail/base/FFFFFFFFFFFFFFFF/keywords/d_42_1.0\n\"\"\"\n\n\ndef init(config):\n    global INDEXDIR, DATAROOT  # pylint: disable=global-statement\n    INDEXDIR = '/srv/diamond/STREAM'\n    DATAROOT = config.dataroot\n\n\nscope_blueprint = Blueprint('test_store', __name__)\n\n_log = logging.getLogger(__name__)\n\n@scope_blueprint.route('/base/<baseidx>/mixers/<mixeridx>/keywords/<params>')\n@scope_blueprint.route('/base/<baseidx>/mixers/<mixeridx>/keywords/<params>/' +\n                        'classes/<classes>')\n@scope_blueprint.route('/base/<baseidx>/mixers/<mixeridx>/keywords/<params>/' +\n                        'classes/<classes>/start/<int:start>/limit/<int:limit>')\n@scope_blueprint.route('/base/<baseidx>/distrbuted/<int:index>of<int:total>/' +\n                        'mixers/<mixeridx>/keywords/<params>')\n@scope_blueprint.route('/base/<baseidx>/distrbuted/<int:index>of<int:total>/' +\n                        'mixers/<mixeridx>/keywords/<params>/classes/<classes>')\ndef get_mixer_classes(baseidx, mixeridx=None, index=1, total=1, params=None, \n                      classes=None, start=0, limit=-1):\n\n    mixer_list = get_mixer_list(mixeridx, classes)\n    start_idx = int((index-1)*(1.0/total)*len(mixer_list))\n    end_idx = int(index*(1.0/total)*len(mixer_list))\n    mixer_list = mixer_list[start_idx:end_idx]\n    _log.info(\"Mixer Size {}\".format(len(mixer_list)))\n    sys.stdout.flush()\n\n    return get_scope(baseidx, params, mixer_list, start, limit)\n\n@scope_blueprint.route('/base/<baseidx>/keywords/<params>')\n@scope_blueprint.route('/base/<baseidx>/keywords/<params>/start/<int:start>/limit/<int:limit>')\n@scope_blueprint.route('/base/<baseidx>/start/<int:start>/limit/<int:limit>')\ndef get_scope(baseidx, params=None, mixer_list=None, start=0, limit=-1):\n    _log.info(\"Enter Scope baseIdx {}\".format(baseidx))\n    sys.stdout.flush()\n    base_list = []\n    seed = None\n    percentage = 0.\n    if params:\n        seed, percentage = decode_params(params)\n    s_seed = seed\n    if s_seed == None:\n        s_seed = random.randrange(10000)\n    if baseidx != \"0\":\n        # format of baseidx: stream_inat \n        # format of base file: stream_{int: seed}_{float(.2f): baserate} \n        base_index = _get_index_absolute_path(baseidx)\n        data_type, pos_file = base_index.split('_')\n        # index[-1] = str(\"{:.2f}\".format(index[-1])) # to ensure there is exactly two decial places\n        # if seed != s_seed:\n        #     index[1] = str(s_seed)\n        #     base_index = '_'.join(index)\n        base_list = [data_type, str(s_seed), pos_file, \"{:.2f}\".format(percentage)]\n        base_index = '_'.join(base_list)\n        print(base_index)\n        if not os.path.exists(base_index):\n            split_data(INDEXDIR, percentage, s_seed)\n        #base_index = base_index.replace(str(seed),str(s_seed))\n\n        with open(base_index, 'r') as f:\n            base_list = list(f.readlines())\n        if start > 0:\n            base_list = base_list[start:]\n        if limit > 0:\n            end_ = len(base_list)\n            if limit > end_:\n                limit = end_\n            base_list = base_list[:limit]\n        total_entries = len(base_list)\n\n\n    make_cocktail = bool(mixer_list and base_list)\n        \n    if base_list:\n        total_entries = len(base_list)  #base_entries\n    else:\n        total_entries = len(mixer_list)\n        base_list = mixer_list.copy()\n        del mixer_list\n\n    random.seed(seed)\n    #random.Random(seed).shuffle(base_list)\n\n    total_sample = 0 \n    if make_cocktail:\n        random.Random(seed).shuffle(mixer_list)\n        total_sample = int(percentage*total_entries)\n        total_entries = total_entries + total_sample\n\n    # Streaming response:\n    # http://flask.pocoo.org/docs/0.12/patterns/streaming/\n    def generate():\n\n        yield '<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\\n'\n        if STYLE:\n            yield '<?xml-stylesheet type=\"text/xsl\" href=\"/scopelist.xsl\" ?>\\n'\n\n        yield '<objectlist count=\"{:d}\">\\n'.format(total_entries)\n\n        mix_per_iteration = 0\n        iteration_count = 0\n        if make_cocktail:\n            mix_per_iteration = int(percentage * ITEMS_PER_ITERATION)\n            pool = cycle(mixer_list)\n\n        mix_indices = []\n\n        def generate_mix_indices():\n            random.seed(seed)\n            return list(map(lambda x: x + ITEMS_PER_ITERATION*iteration_count,\n                    sorted(random.sample(list(range(ITEMS_PER_ITERATION)), mix_per_iteration))))\n\n        for count in range(total_entries):\n            if not count % ITEMS_PER_ITERATION and make_cocktail:\n                mix_indices = generate_mix_indices()\n                iteration_count += 1\n\n            if count in mix_indices:\n                obj_path = next(pool).strip()\n            else:\n                obj_path = base_list.pop(0).strip()\n            yield _get_object_element(object_path=obj_path) + '\\n'\n\n        yield '</objectlist>\\n'\n\n    headers = Headers([('Content-Type', 'text/xml')])\n\n    return Response(stream_with_context(generate()),\n                    status=\"200 OK\",\n                    headers=headers)\n\ndef decode_params(params):\n    keywords = params.split('_')\n    m_type = keywords[0]\n    seed = int(keywords[1])\n    percentage = 0.1\n    if m_type == 'r':\n        seed = None\n    if len(keywords) > 2:\n        percentage = float(keywords[2]) #float(keywords[2])/100.\n    return seed, round(percentage, 4)\n\ndef get_mixer_list(idx, classes=None):\n    \"\"\"\n    Return list of file paths present in given classes of mixer set\n    If class list is None or incorrect then return list of entire mixer set.\n\n    Args:\n        classes (str): Comma seperated classes of interest\n        idx     (str): Index of mixer collection\n\n    Returns:\n    \"\"\"\n    mixer_index = _get_index_absolute_path('GIDIDX' + idx.upper())\n\n    image_types = ('*.jpg', '*.JPG', '*.jpeg', '.png')\n\n    classes_list = []\n    if classes:\n        classes.replace('%2C', ',')\n        classes.replace('%20', ' ')\n        classes_list = classes.split(',')\n\n    def get_class_path():\n        with open(mixer_index, 'r') as f:\n            dataset_path = f.readline()\n        dataset_path = '/'.join(dataset_path.split('/')[:-2])\n        class_paths = []\n        for c in classes_list:\n            class_paths.append(_get_obj_absolute_path(dataset_path+'/'+c.strip()))\n        return class_paths\n\n    mixer_list = []\n    class_paths = get_class_path()\n    _log.info(\"Class paths : {}\".format(class_paths))\n\n    if class_paths:\n        for path in class_paths:\n            _log.info(\"Path Exists ? {}\".format(os.path.exists(path)))\n            sys.stdout.flush()\n            file_list = []\n            for ext in image_types:\n                file_list.extend(glob.glob(os.path.join(path, ext)))\n            mixer_list.extend(sorted(file_list))\n        mixer_list = [_get_obj_path(l.strip()) for l in mixer_list]\n    else:\n        with open(mixer_index, 'r') as f:\n            mixer_list = list(f.readlines())\n\n    return mixer_list\n\n@scope_blueprint.route('/id/<path:object_path>')\ndef get_object_id(object_path):\n    headers = Headers([('Content-Type', 'text/xml')])\n    return Response(_get_object_element(object_path=object_path),\n                    \"200 OK\",\n                    headers=headers)\n\n\n@scope_blueprint.route('/meta/<path:object_path>')\ndef get_object_meta(object_path):\n    path = _get_obj_absolute_path(object_path)\n    attrs = dict()\n\n    try:\n        attrs['_gt_label'] = path.split('/')[-2]\n    except IOError:\n        pass\n\n    return jsonify(attrs)\n\n\ndef _get_object_element(object_path):\n    path = _get_obj_absolute_path(object_path)\n    class_text = '/'.join(path.split('/')[:-2])+'/classes.txt'\n    if os.path.isfile(class_text):\n        return '<object id={} src={} meta={} />' \\\n            .format(quoteattr(url_for('.get_object_id', object_path=object_path)),\n                    quoteattr(_get_object_src_uri(object_path)),\n                    quoteattr(url_for('.get_object_meta', object_path=object_path)))\n    return '<object id={} src={} />' \\\n            .format(quoteattr(url_for('.get_object_id', object_path=object_path)),\n                    quoteattr(_get_object_src_uri(object_path)))\n\n\ndef _get_object_src_uri(object_path):\n    if LOCAL_OBJ_URI:\n        return 'file://' + _get_obj_absolute_path(object_path)\n\n    return url_for('.get_object_src_http', obj_path=object_path)\n\ndef _get_obj_path(obj_path):\n    return obj_path.replace(DATAROOT+'/', '')\n\ndef _get_obj_absolute_path(obj_path):\n    return os.path.join(DATAROOT, obj_path)\n\n\ndef _get_index_absolute_path(index):\n    return os.path.join(INDEXDIR, index)\n\n\n@scope_blueprint.route('/obj/<path:obj_path>')\ndef get_object_src_http(obj_path):\n    path = _get_obj_absolute_path(obj_path)\n\n    headers = Headers()\n    # With add_etags=True, conditional=True\n    # Flask should be smart enough to do 304 Not Modified\n    response = send_file(path,\n                         cache_timeout=datetime.timedelta(\n                             days=365).total_seconds(),\n                         add_etags=True,\n                         conditional=True)\n    response.headers.extend(headers)\n    return response\n", "#\n#  The OpenDiamond Platform for Interactive Search\n#\n#  Copyright (c) 2018 Carnegie Mellon University\n#  All rights reserved.\n#\n#  This software is distributed under the terms of the Eclipse Public\n#  License, Version 1.0 which can be found in the file named LICENSE.\n#  ANY USE, REPRODUCTION OR DISTRIBUTION OF THIS SOFTWARE CONSTITUTES\n#  RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT\n#\nfrom builtins import range, str\n\nimport datetime\nimport json\nimport os\nimport subprocess\nimport sys\nfrom math import ceil\n\nfrom flask import Blueprint, Response, request, stream_with_context, url_for\nfrom opendiamond.dataretriever.util import DiamondTextAttr\nfrom werkzeug.datastructures import Headers\n\n# IMPORTANT: requires ffmpeg >= 3.3. Lower versions produce incorrect clipping.\n\nBASEURL = 'video'\nSTYLE = False\nINDEXDIR = DATAROOT = None\n\n\ndef init(config):\n    global INDEXDIR, DATAROOT  # pylint: disable=global-statement\n    INDEXDIR = config.indexdir\n    DATAROOT = config.dataroot\n\n\nscope_blueprint = Blueprint('video_store', __name__)\n\n@scope_blueprint.route('/scope/<gididx>')\n@scope_blueprint.route('/scope/stride/<int:stride>/span/<int:span>/<gididx>')\ndef get_scope(gididx, stride=5, span=5):\n    index = 'GIDIDX' + gididx.upper()\n\n    def generate():\n        yield '<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\\n'\n        if STYLE:\n            yield '<?xml-stylesheet type=\"text/xsl\" href=\"/scopelist.xsl\" ?>\\n'\n\n        yield '<objectlist>\\n'\n\n        with open(_get_index_absolute_path(index), 'rt') as f:\n            for line in f:\n                video = line.strip()\n                video_path = str(_get_obj_absolute_path(video))\n                try:\n                    video_meta = _ffprobe(video_path)\n                    length_sec = float(video_meta['format']['duration'])\n                    num_clips = int(ceil(length_sec / stride))\n                    yield '<count adjust=\"{}\"/>\\n'.format(num_clips)\n                    for clip in range(num_clips):\n                        yield _get_object_element(start=clip * stride, span=span, video=video) + '\\n'\n                except Exception as e:\n                    print(\"Error parsing {}. {}. Skip.\".format(video, str(e)), file=sys.stderr)\n                    pass\n\n        yield '</objectlist>\\n'\n\n    headers = Headers([('Content-Type', 'text/xml')])\n    return Response(stream_with_context(generate()),\n                    status=\"200 OK\",\n                    headers=headers)\n\n\n@scope_blueprint.route('/id/start/<int:start>/span/<int:span>/<path:video>')\ndef get_object_id(start, span, video):\n    headers = Headers([('Content-Type', 'text/xml')])\n    return Response(_get_object_element(start, span, video),\n                    \"200 OK\",\n                    headers=headers)\n\n\n@scope_blueprint.route('/obj/start/<int:start>/span/<int:span>/<path:video>')\ndef get_object(start, span, video):\n    # Reference:\n    # https://github.com/mikeboers/PyAV/blob/master/tests/test_seek.py\n    video_path = str(_get_obj_absolute_path(video))\n    proc = _create_ffmpeg_segment_proc(video_path,\n                                       start_sec=start,\n                                       duration_sec=span)\n\n    def generate():\n        while True:\n            data = proc.stdout.read(4096)\n            if not data:\n                break\n            yield data\n\n    headers = Headers([('Content-Type', 'video/mp4')])\n    response = Response(stream_with_context(generate()),\n                        status=\"200 OK\",\n                        headers=headers)\n    # Cache control\n    stat = os.stat(video_path)\n    last_modified = stat.st_mtime\n    size = stat.st_size\n    etag = \"{}_{}_{}_{}\".format(last_modified, size, start, span)\n    response.last_modified = last_modified\n    response.set_etag(etag=etag)\n    response.cache_control.public = True\n    response.cache_control.max_age = \\\n        datetime.timedelta(days=365).total_seconds()\n    response.make_conditional(request)\n\n    return response\n\n\ndef _get_object_element(start, span, video):\n    return '<object id=\"{}\" src=\"{}\" />'.format(\n        url_for('.get_object_id', start=start, span=span, video=video),\n        url_for('.get_object', start=start, span=span, video=video))\n\n\ndef _get_obj_absolute_path(obj_path):\n    return os.path.join(DATAROOT, obj_path)\n\n\ndef _get_index_absolute_path(index):\n    return os.path.join(INDEXDIR, index)\n\n\ndef _ffprobe(video_path):\n    cmd_l = ['ffprobe', '-v', 'quiet', '-print_format', 'json',\n                '-show_format', video_path]\n\n    proc = subprocess.Popen(cmd_l, stdout=subprocess.PIPE, bufsize=-1)\n    data = json.load(proc.stdout)\n    \n    return data\n\n\ndef _create_ffmpeg_segment_proc(video_path, start_sec, duration_sec):\n    \"\"\"\n    Use ffmpeg to extract a .mp4 segment of the video. Outfile is written to stdout.\n    Note: requires ffmpeg >= 3.3. Lower versions produce wrong results.\n    Reference: http://trac.ffmpeg.org/wiki/Seeking\n    https://stackoverflow.com/questions/34123272/ffmpeg-transmux-mpegts-to-mp4-gives-error-muxer-does-not-support-non-seekable\n    :param video_path:\n    :param start_sec:\n    :param duration_sec:\n    :return: the subprocess\n    \"\"\"\n    cmd_l = ['ffmpeg', '-v', 'quiet',\n             '-ss', str(start_sec),\n             '-t', str(duration_sec),\n             '-i', str(video_path),\n             '-movflags', 'frag_keyframe+empty_moov',\n             '-c', 'copy',\n             '-f', 'mp4',\n             'pipe:1']\n\n    proc = subprocess.Popen(cmd_l, stdout=subprocess.PIPE, bufsize=-1)\n    return proc\n", "#\n#  The OpenDiamond Platform for Interactive Search\n#\n#  Copyright (c) 2018 Carnegie Mellon University\n#  All rights reserved.\n#\n#  This software is distributed under the terms of the Eclipse Public\n#  License, Version 1.0 which can be found in the file named LICENSE.\n#  ANY USE, REPRODUCTION OR DISTRIBUTION OF THIS SOFTWARE CONSTITUTES\n#  RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT\n#\n\"\"\"\nPre-conditions:\nMetadata of a data set is stored in a table <dataset> in a MySQL database.\nFiles (objects) belonging to a dataset are stored under DATAROOT/<dataset>/.\nMySQL table stores relative path to the above directory.\nTable provides keyword search to get list of objects.\nDatabase login info is obtained from DiamondConfig.\nMySQL table is indexed with:\n FULLTEXT (title, keywords, description)\n\nRequires:\npip install mysql-connector-python==8.0.6\n\"\"\"\nimport datetime\nimport os\nfrom flask import Blueprint, url_for, Response, \\\n    stream_with_context, abort, jsonify, send_file\nimport logging\nimport mysql.connector\nfrom werkzeug.datastructures import Headers\nfrom xml.sax.saxutils import quoteattr\n\nBASEURL = 'yfcc100m_mysql'\nSTYLE = False\nLOCAL_OBJ_URI = True  # if true, return local path, otherwise http.\nDATAROOT = None\nDB_HOST = DB_DBNAME = DB_USER = DB_PASSWORD = DB_PORT = None\n\n_log = logging.getLogger(__name__)\n\nyfcc100m_s3_image_prefix = 'https://multimedia-commons.s3-us-west-2.amazonaws.com/data/images/'\n\n\ndef init(config):\n    global DATAROOT  # pylint: disable=global-statement\n    DATAROOT = config.dataroot\n    global DB_HOST, DB_DBNAME, DB_USER, DB_PASSWORD, DB_PORT\n    DB_HOST = config.yfcc100m_db_host\n    DB_DBNAME = config.yfcc100m_db_dbname\n    DB_USER = config.yfcc100m_db_user\n    DB_PASSWORD = config.yfcc100m_db_password\n    DB_PORT = config.yfcc100m_db_port\n\n\nscope_blueprint = Blueprint('mysql_store', __name__)\n\n\n@scope_blueprint.route('/scope/<dataset>')\n@scope_blueprint.route('/scope/<dataset>/keywords/<keywords>')\n@scope_blueprint.route('/scope/<dataset>/modulo/<int:divisor>/<expression>')\n@scope_blueprint.route(\n    '/scope/<dataset>/keywords/<keywords>/modulo/<int:divisor>/<expression>')\ndef get_scope(dataset, keywords=None, divisor=None, expression=None):\n    \"\"\"\n\n    :param expression: Can be \"<3\", \"=3\", \">3\", etc.\n    :param dataset:\n    :param keywords: a string of comma-separated keywords\n    :param divisor: positive int\n    :return:\n    \"\"\"\n    # cursor.execute() can't substitute table name\n    query = \"SELECT sequence_no, rel_path, download_link FROM \" + dataset\n    conditions = []\n    substitutes = []\n    if keywords:\n        conditions.append(\"MATCH (title, keywords, description) AGAINST(%s)\")\n        substitutes.append(keywords)\n\n    if divisor:\n        # TODO sanity check expression\n        conditions.append(\"(sequence_no % %s) \" + expression)\n        substitutes.extend([divisor])\n\n    if conditions:\n        query += \" WHERE \" + ' AND '.join(conditions)\n\n    _log.debug(\"Query used: %s, substitutes: %s\", query, substitutes)\n\n    def generate():\n        cnx = mysql.connector.connect(user=DB_USER,\n                                      password=DB_PASSWORD,\n                                      host=DB_HOST,\n                                      database=DB_DBNAME,\n                                      port=DB_PORT)\n        cursor = cnx.cursor()\n        cursor.execute(query, substitutes)\n\n        yield '<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\\n'\n        if STYLE:\n            yield '<?xml-stylesheet type=\"text/xsl\" href=\"/scopelist.xsl\" ?>\\n'\n\n        yield '<objectlist>\\n'\n        for seq_no, rel_path, download_link in cursor:\n            yield '<count adjust=\"1\"/>\\n'\n            yield _get_object_element(dataset, seq_no, rel_path,\n                                      download_link) + '\\n'\n\n        yield '</objectlist>\\n'\n\n    headers = Headers([('Content-Type', 'text/xml')])\n\n    return Response(stream_with_context(generate()),\n                    status=\"200 OK\",\n                    headers=headers)\n\n@scope_blueprint.route('/id/<dataset>/<int:seq_no>')\ndef get_object_id(dataset, seq_no):\n    headers = Headers([('Content-Type', 'text/xml')])\n    return Response(_get_object_element(dataset, seq_no, None, None),\n                    \"200 OK\",\n                    headers=headers)\n\n@scope_blueprint.route('/obj/<dataset>/<path:rel_path>')\ndef get_object_src_http(dataset, rel_path):\n    path = _get_obj_abosolute_path(dataset, rel_path)\n    response = send_file(path,\n                         cache_timeout=datetime.timedelta(\n                             days=365).total_seconds(),\n                         add_etags=True,\n                         conditional=True)\n    return response\n\n\ndef _get_obj_abosolute_path(dataset, rel_path):\n    return os.path.join(DATAROOT, dataset, rel_path)\n\n\ndef _get_object_element(dataset, seq_no, rel_path, download_link):\n    \"\"\"If rel_path and download_link are not None, we are called from scope.\n    Otherwise we are called from ID and need to run SQL query to fetch these attrs.\"\"\"\n\n    if rel_path is None:\n        query = \"SELECT rel_path, download_link FROM \" + \\\n        dataset + \\\n        \" WHERE sequence_no = %s\"\n\n        cnx = mysql.connector.connect(user=DB_USER,\n                                    password=DB_PASSWORD,\n                                    host=DB_HOST,\n                                    database=DB_DBNAME,\n                                    port=DB_PORT)\n        cursor = cnx.cursor()\n        cursor.execute(query, (seq_no,))\n\n        row = cursor.fetchone()\n\n        if not row:\n            return None\n\n        rel_path, download_link = row[0], row[1]\n\n    if LOCAL_OBJ_URI:\n        src_uri = 'file://' + os.path.join(DATAROOT, dataset, rel_path)\n    else:\n        src_uri = url_for('.get_object_src_http', dataset=dataset, rel_path=rel_path)\n\n    return '<object id={} src={} hyperfind.external-link={} />' \\\n        .format(\n        quoteattr(url_for('.get_object_id', dataset=dataset, seq_no=seq_no)),\n        quoteattr(src_uri),\n        quoteattr(download_link))\n"], "fixing_code": ["#\n#  The OpenDiamond Platform for Interactive Search\n#\n#  Copyright (c) 2009-2018 Carnegie Mellon University\n#  All rights reserved.\n#\n#  This software is distributed under the terms of the Eclipse Public\n#  License, Version 1.0 which can be found in the file named LICENSE.\n#  ANY USE, REPRODUCTION OR DISTRIBUTION OF THIS SOFTWARE CONSTITUTES\n#  RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT\n#\n\nfrom builtins import next\nfrom builtins import range\nimport os\nimport datetime\nfrom xml.sax.saxutils import quoteattr\nimport sys\n\nimport logging\nimport random\nimport glob\nfrom itertools import cycle\nfrom flask import Blueprint, url_for, Response, stream_with_context, send_file, \\\n    jsonify\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.security import safe_join\nfrom opendiamond.dataretriever.util import read_file_list, write_data\n\n\nBASEURL = 'augment'\nSTYLE = False\nLOCAL_OBJ_URI = True  # if true, return local file path, otherwise http.\nINDEXDIR = DATAROOT = None\nITEMS_PER_ITERATION = int(1e4)\nKEYWORD = 'yellowthroat'\n\n\"\"\"\n    Example url:\n        /augment/root/<ROOT_DIR>/distributed/<id>of<N>/ \\\n            keywords/<d/r ([d]eterminant/[r]andom)>_<random_seed>_<base_rate>\n\n        /augment/root/STREAM/distributed/1of2/keywords/d_42_1.0\n\"\"\"\n\n\ndef init(config):\n    global INDEXDIR, DATAROOT  # pylint: disable=global-statement\n    INDEXDIR = 'STREAM'\n    DATAROOT = config.dataroot\n\n\nscope_blueprint = Blueprint('augment_store', __name__)\n\n_log = logging.getLogger(__name__)\n\n@scope_blueprint.route('/root/<rootdir>/distributed/<int:index>of<int:total>' +\n                        '/keywords/<params>')\n@scope_blueprint.route('/root/<rootdir>/keywords/<params>')\n@scope_blueprint.route('/root/<rootdir>/distributed/<int:index>of<int:total>' +\n                        '/keywords/<params>/start/<int:start>/limit/<int:limit>')\n@scope_blueprint.route('/root/<rootdir>/keywords/<params>' +\n                        '/start/<int:start>/limit/<int:limit>')\ndef get_scope(rootdir, index=0, total=1, params=None, start=0, limit=sys.maxsize):\n    global KEYWORD\n    if rootdir == \"0\":\n        rootdir = INDEXDIR\n\n    rootdir = _get_obj_absolute_path(rootdir)\n    seed = None\n    percentage = 0.\n    seed, percentage = decode_params(params)\n\n    # Assuming the same positive list is present in all the servers\n    # Always create a new index file\n    base_list, KEYWORD = create_index(rootdir, percentage, seed, index, total)\n    total_entries = len(base_list)\n\n    start = start if start > 0 else 0\n    end = min(total_entries, start + limit) if limit > 0 else total_entries\n    base_list = base_list[start:end]\n    total_entries = end - start\n\n    def generate():\n        yield '<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\\n'\n        if STYLE:\n            yield '<?xml-stylesheet type=\"text/xsl\" href=\"/scopelist.xsl\" ?>\\n'\n\n        yield '<objectlist count=\"{:d}\">\\n'.format(total_entries)\n\n        for path in base_list:\n            path = path.strip()\n            yield _get_object_element(object_path=path) + '\\n'\n\n        yield '</objectlist>\\n'\n\n    headers = Headers([('Content-Type', 'text/xml')])\n\n    return Response(stream_with_context(generate()),\n                    status=\"200 OK\",\n                    headers=headers)\n\ndef decode_params(params):\n    \"\"\"\n    Decodes the params which are '_' seperated\n    <[d]eterminant/[r]andom>_<random_seed>_<baserate>\n    \"\"\"\n    keywords = params.split('_')\n    mix_type = keywords[0]\n    seed = None\n    if len(keywords) > 1:\n        seed = int(keywords[1])\n    if mix_type == 'r' or seed is None:\n        seed = random.randrange(10000)\n    percentage = 0.1 # default base_rate = 0.1%\n    if len(keywords) > 2:\n        percentage = float(keywords[2])\n    return seed, round(percentage, 4)\n\n@scope_blueprint.route('/id/<path:object_path>')\ndef get_object_id(object_path):\n    headers = Headers([('Content-Type', 'text/xml')])\n    return Response(_get_object_element(object_path=object_path),\n                    \"200 OK\",\n                    headers=headers)\n\ndef _get_object_element(object_path):\n    path = _get_obj_absolute_path(object_path)\n    meta = {'_gt_label': KEYWORD}\n    if KEYWORD in path:\n        return '<object id={} src={} meta={} />' \\\n                .format(quoteattr(url_for('.get_object_id', object_path=object_path)),\n                        quoteattr(_get_object_src_uri(object_path)),\n                        quoteattr(url_for('.get_object_meta', present=True)))\n\n    return '<object id={} src={} />' \\\n            .format(quoteattr(url_for('.get_object_id', object_path=object_path)),\n                    quoteattr(_get_object_src_uri(object_path)))\n\n\n@scope_blueprint.route('/meta/<path:present>')\ndef get_object_meta(present=False):\n    attrs = dict()\n    if present:\n        attrs['_gt_label'] = KEYWORD\n\n    return jsonify(attrs)\n\ndef _get_object_src_uri(object_path):\n    if LOCAL_OBJ_URI:\n        return 'file://' + _get_obj_absolute_path(object_path)\n\n    return url_for('.get_object_src_http', obj_path=object_path)\n\ndef _get_obj_absolute_path(obj_path):\n    return safe_join(DATAROOT, obj_path)\n\n@scope_blueprint.route('/obj/<path:obj_path>')\ndef get_object_src_http(obj_path):\n    path = _get_obj_absolute_path(obj_path)\n\n    headers = Headers()\n    # With add_etags=True, conditional=True\n    # Flask should be smart enough to do 304 Not Modified\n    response = send_file(path,\n                         cache_timeout=datetime.timedelta(\n                             days=365).total_seconds(),\n                         add_etags=True,\n                         conditional=True)\n    response.headers.extend(headers)\n    return response\n\ndef create_index(base_dir, base_rate=0.05, seed=42, rank=0, total_servers=1):\n    \"\"\"\n    Creates Index List File:\n    Assuming name of files NEGATIVE (e.g:subset YFCC), POSITIVE\n    \"\"\"\n\n    filepath_split = ['STREAM', \"{:.2f}\".format(base_rate), str(rank), str(total_servers), str(seed)]\n    filepath = '_'.join(filepath_split)\n    filepath = os.path.join(base_dir, filepath)\n    positive_path = os.path.join(base_dir, 'POSITIVE')\n    negative_path = os.path.join(base_dir, 'NEGATIVE')\n    positive_firstline = open(positive_path).readline().rstrip()\n    keyword = positive_firstline.split('/')[-2] # Assuming all positives are in the same parent dir\n\n    _log.info(\"Dir {} BR: {} Seed:{} FP{}\".format(base_dir, base_rate, seed, filepath))\n    sys.stdout.flush()\n\n    if not os.path.exists(filepath):\n        positive_data = read_file_list(positive_path) # same across servers\n        negative_data = read_file_list(negative_path) # different across servers\n        random.Random(seed).shuffle(positive_data)\n        random.Random(seed).shuffle(negative_data)\n        len_positive = len(positive_data)\n        start_idx = int(rank * (1.0 / total_servers) * len_positive)\n        end_idx = int((rank+1) * (1.0 / total_servers) * len_positive)\n        positive_data = positive_data[start_idx:end_idx]\n        len_positive = len(positive_data)\n        negative_sample = int(len_positive * (100./base_rate -1))\n        negative_data = negative_data[:negative_sample]\n        return write_data(filepath, [negative_data, positive_data], seed), keyword\n\n    return read_file_list(filepath), keyword\n", "#\n#  The OpenDiamond Platform for Interactive Search\n#\n#  Copyright (c) 2009-2018 Carnegie Mellon University\n#  All rights reserved.\n#\n#  This software is distributed under the terms of the Eclipse Public\n#  License, Version 1.0 which can be found in the file named LICENSE.\n#  ANY USE, REPRODUCTION OR DISTRIBUTION OF THIS SOFTWARE CONSTITUTES\n#  RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT\n#\n\nimport os\nimport datetime\nfrom xml.sax.saxutils import quoteattr\n\nfrom flask import Blueprint, url_for, Response, stream_with_context, send_file, \\\n    jsonify\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.security import safe_join\n\nfrom opendiamond.dataretriever.util import ATTR_SUFFIX\n\nBASEURL = 'collection'\nSTYLE = False\nLOCAL_OBJ_URI = True  # if true, return local file path, otherwise http.\nINDEXDIR = DATAROOT = None\n\n\ndef init(config):\n    global INDEXDIR, DATAROOT  # pylint: disable=global-statement\n    INDEXDIR = config.indexdir\n    DATAROOT = config.dataroot\n\n\nscope_blueprint = Blueprint('diamond_store', __name__)\n\n\n@scope_blueprint.route('/<gididx>')\n@scope_blueprint.route('/<gididx>/limit/<int:limit>')\ndef get_scope(gididx, limit=None):\n    index = 'GIDIDX' + gididx.upper()\n    index = _get_index_absolute_path(index)\n\n    # Streaming response:\n    # http://flask.pocoo.org/docs/0.12/patterns/streaming/\n    def generate():\n        num_entries = 0\n        with open(index, 'r') as f:\n            for _ in f.readlines():\n                num_entries += 1\n                if limit is not None and num_entries >= limit:\n                    break\n\n        with open(index, 'r') as f:\n            yield '<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\\n'\n            if STYLE:\n                yield '<?xml-stylesheet type=\"text/xsl\" href=\"/scopelist.xsl\" ?>\\n'\n\n            yield '<objectlist count=\"{:d}\">\\n'.format(num_entries)\n            \n            count = 0\n            for path in f.readlines():\n                path = path.strip()\n                yield _get_object_element(object_path=path) + '\\n'\n                count += 1\n                if limit is not None and count >= limit:\n                    break\n\n            yield '</objectlist>\\n'\n\n    headers = Headers([('Content-Type', 'text/xml')])\n\n    return Response(stream_with_context(generate()),\n                    status=\"200 OK\",\n                    headers=headers)\n\n\n@scope_blueprint.route('/id/<path:object_path>')\ndef get_object_id(object_path):\n    headers = Headers([('Content-Type', 'text/xml')])\n    return Response(_get_object_element(object_path=object_path),\n                    \"200 OK\",\n                    headers=headers)\n\n\n@scope_blueprint.route('/meta/<path:object_path>')\ndef get_object_meta(object_path):\n    path = _get_obj_absolute_path(object_path)\n    attrs = dict()\n\n    try:\n        with DiamondTextAttr(path, 'r') as attributes:\n            for key, value in attributes:\n                attrs[key] = value\n    except IOError:\n        pass\n\n    return jsonify(attrs)\n\n\ndef _get_object_element(object_path):\n    path = _get_obj_absolute_path(object_path)\n\n    if os.path.isfile(path + ATTR_SUFFIX):\n        return '<object id={} src={} meta={} />' \\\n            .format(quoteattr(url_for('.get_object_id', object_path=object_path)),\n                    quoteattr(_get_object_src_uri(object_path)),\n                    quoteattr(url_for('.get_object_meta', object_path=object_path)))\n    else:\n        return '<object id={} src={} />' \\\n            .format(quoteattr(url_for('.get_object_id', object_path=object_path)),\n                    quoteattr(_get_object_src_uri(object_path)))\n\n\ndef _get_object_src_uri(object_path):\n    if LOCAL_OBJ_URI:\n        return 'file://' + _get_obj_absolute_path(object_path)\n    else:\n        return url_for('.get_object_src_http', obj_path=object_path)\n\n\ndef _get_obj_absolute_path(obj_path):\n    return safe_join(DATAROOT, obj_path)\n\n\ndef _get_index_absolute_path(index):\n    return safe_join(INDEXDIR, index)\n\n\n@scope_blueprint.route('/obj/<path:obj_path>')\ndef get_object_src_http(obj_path):\n    path = _get_obj_absolute_path(obj_path)\n\n    headers = Headers()\n    # With add_etags=True, conditional=True\n    # Flask should be smart enough to do 304 Not Modified\n    response = send_file(path,\n                         cache_timeout=datetime.timedelta(\n                             days=365).total_seconds(),\n                         add_etags=True,\n                         conditional=True)\n    response.headers.extend(headers)\n    return response\n", "#\n#  The OpenDiamond Platform for Interactive Search\n#\n#  Copyright (c) 2009-2018 Carnegie Mellon University\n#  All rights reserved.\n#\n#  This software is distributed under the terms of the Eclipse Public\n#  License, Version 1.0 which can be found in the file named LICENSE.\n#  ANY USE, REPRODUCTION OR DISTRIBUTION OF THIS SOFTWARE CONSTITUTES\n#  RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT\n#\n\nfrom builtins import next\nfrom builtins import range\nimport os\nimport datetime\nfrom xml.sax.saxutils import quoteattr\nimport sys\n\nimport logging\nimport random\nimport glob\nfrom itertools import cycle\nfrom flask import Blueprint, url_for, Response, stream_with_context, send_file, \\\n    jsonify\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.security import safe_join\n\nBASEURL = 'cocktail'\nSTYLE = False\nLOCAL_OBJ_URI = True  # if true, return local file path, otherwise http.\nINDEXDIR = DATAROOT = None\nITEMS_PER_ITERATION = int(1e4)\n\n\"\"\"\n    Example cocktail url:\n        /cocktail/base/FFFFFFFFFFFFFFFF/distrbuted/1of2/ \\\n            mixers/FFFFFFFFFFFFFFFC/keywords/d_42_1.0/classes/gull,cardinal\n        /cocktail/base/\"0\"/mixers/FFFFFFFFFFFFFFFC/keywords/d_42_1.0\n        /cocktail/base/FFFFFFFFFFFFFFFF/keywords/d_42_1.0\n\"\"\"\n\n\ndef init(config):\n    global INDEXDIR, DATAROOT  # pylint: disable=global-statement\n    INDEXDIR = config.indexdir\n    DATAROOT = config.dataroot\n\n\nscope_blueprint = Blueprint('mixer_store', __name__)\n\n_log = logging.getLogger(__name__)\n\n@scope_blueprint.route('/base/<baseidx>/mixers/<mixeridx>/keywords/<params>')\n@scope_blueprint.route('/base/<baseidx>/mixers/<mixeridx>/keywords/<params>/' +\n                        'classes/<classes>')\n@scope_blueprint.route('/base/<baseidx>/mixers/<mixeridx>/keywords/<params>/' +\n                        'classes/<classes>/start/<int:start>/limit/<int:limit>')\n@scope_blueprint.route('/base/<baseidx>/distrbuted/<int:index>of<int:total>/' +\n                        'mixers/<mixeridx>/keywords/<params>')\n@scope_blueprint.route('/base/<baseidx>/distrbuted/<int:index>of<int:total>/' +\n                        'mixers/<mixeridx>/keywords/<params>/classes/<classes>')\ndef get_mixer_classes(baseidx, mixeridx=None, index=1, total=1, params=None, \n                      classes=None, start=0, limit=-1):\n\n    mixer_list = get_mixer_list(mixeridx, classes)\n    start_idx = int((index-1)*(1.0/total)*len(mixer_list))\n    end_idx = int(index*(1.0/total)*len(mixer_list))\n    mixer_list = mixer_list[start_idx:end_idx]\n    print(\"Mixer Size {}\".format(len(mixer_list)))\n    sys.stdout.flush()\n\n    return get_scope(baseidx, params, mixer_list, start, limit)\n\n@scope_blueprint.route('/base/<baseidx>/keywords/<params>')\n@scope_blueprint.route('/base/<baseidx>/keywords/<params>/start/<int:start>/limit/<int:limit>')\ndef get_scope(baseidx, params=None, mixer_list=None, start=0, limit=-1):\n    print(\"Enter Scope\")\n    sys.stdout.flush()\n    base_list = []\n    seed, percentage = decode_params(params)\n    if baseidx != \"0\":\n        base_index = _get_index_absolute_path('GIDIDX' + baseidx.upper())\n        with open(base_index, 'r') as f:\n            base_list = list(f.readlines())\n        if limit > 0:\n            base_list = base_list[start:start+limit]\n        elif start > 0:\n            base_list = base_list[start:]\n        total_entries = len(base_list)\n\n\n    make_cocktail = bool(mixer_list and base_list)\n        \n    if base_list:\n        total_entries = len(base_list)  #base_entries\n    else:\n        total_entries = len(mixer_list)\n        base_list = mixer_list.copy()\n        del mixer_list\n\n    random.seed(seed)\n    #random.Random(seed).shuffle(base_list)\n\n    total_sample = 0 \n    if make_cocktail:\n        random.Random(seed).shuffle(mixer_list)\n        total_sample = int(percentage*total_entries)\n        total_entries = total_entries + total_sample\n\n    # Streaming response:\n    # http://flask.pocoo.org/docs/0.12/patterns/streaming/\n    def generate():\n\n        yield '<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\\n'\n        if STYLE:\n            yield '<?xml-stylesheet type=\"text/xsl\" href=\"/scopelist.xsl\" ?>\\n'\n\n        yield '<objectlist count=\"{:d}\">\\n'.format(total_entries)\n\n        mix_per_iteration = 0\n        iteration_count = 0\n        if make_cocktail:\n            mix_per_iteration = int(percentage * ITEMS_PER_ITERATION)\n            pool = cycle(mixer_list)\n\n        mix_indices = []\n\n        def generate_mix_indices():\n            random.seed(seed)\n            return list(map(lambda x: x + ITEMS_PER_ITERATION*iteration_count,\n                    sorted(random.sample(list(range(ITEMS_PER_ITERATION)), mix_per_iteration))))\n\n        for count in range(total_entries):\n            if not count % ITEMS_PER_ITERATION and make_cocktail:\n                mix_indices = generate_mix_indices()\n                iteration_count += 1\n\n            if count in mix_indices:\n                obj_path = next(pool).strip()\n            else:\n                obj_path = base_list.pop(0).strip()\n            yield _get_object_element(object_path=obj_path) + '\\n'\n\n        yield '</objectlist>\\n'\n\n    headers = Headers([('Content-Type', 'text/xml')])\n\n    return Response(stream_with_context(generate()),\n                    status=\"200 OK\",\n                    headers=headers)\n\ndef decode_params(params):\n    keywords = params.split('_')\n    m_type = keywords[0]\n    seed = int(keywords[1])\n    percentage = 0.0001\n    if m_type == 'r':\n        seed = None\n    if len(keywords) > 2:\n        percentage = float(keywords[2])/100.\n    return seed, round(percentage, 4)\n\ndef get_mixer_list(idx, classes=None):\n    \"\"\"\n    Return list of file paths present in given classes of mixer set\n    If class list is None or incorrect then return list of entire mixer set.\n\n    Args:\n        classes (str): Comma seperated classes of interest\n        idx     (str): Index of mixer collection\n\n    Returns:\n    \"\"\"\n    mixer_index = _get_index_absolute_path('GIDIDX' + idx.upper())\n    classes_list = []\n    if classes:\n        classes.replace('%2C', ',')\n        classes.replace('%20', ' ')\n        classes_list = classes.split(',')\n\n    def get_class_path():\n        with open(mixer_index, 'r') as f:\n            dataset_path = f.readline()\n        dataset_path = '/'.join(dataset_path.split('/')[:-2])\n        class_paths = []\n        for c in classes_list:\n            class_paths.append(_get_obj_absolute_path(dataset_path+'/'+c.strip()))\n        return class_paths\n\n    mixer_list = []\n    class_paths = get_class_path()\n    print(\"Class paths : {}\".format(class_paths))\n    sys.stdout.flush()\n\n    if class_paths:\n        for path in class_paths:\n            print(\"Path Exists ? {}\".format(os.path.exists(path)))\n            sys.stdout.flush()\n\n            mixer_list.extend(sorted(glob.glob(os.path.join(path, \"*.jpg\"))))\n        mixer_list = [_get_obj_path(l.strip()) for l in mixer_list]\n    else:\n        with open(mixer_index, 'r') as f:\n            mixer_list = list(f.readlines())\n\n    return mixer_list\n\n@scope_blueprint.route('/id/<path:object_path>')\ndef get_object_id(object_path):\n    headers = Headers([('Content-Type', 'text/xml')])\n    return Response(_get_object_element(object_path=object_path),\n                    \"200 OK\",\n                    headers=headers)\n\n\n@scope_blueprint.route('/meta/<path:object_path>')\ndef get_object_meta(object_path):\n    path = _get_obj_absolute_path(object_path)\n    attrs = dict()\n\n    try:\n        attrs['_gt_label'] = path.split('/')[-2]\n    except IOError:\n        pass\n\n    return jsonify(attrs)\n\n\ndef _get_object_element(object_path):\n    path = _get_obj_absolute_path(object_path)\n    class_text = '/'.join(path.split('/')[:-2])+'/classes.txt'\n    if os.path.isfile(class_text):\n        return '<object id={} src={} meta={} />' \\\n            .format(quoteattr(url_for('.get_object_id', object_path=object_path)),\n                    quoteattr(_get_object_src_uri(object_path)),\n                    quoteattr(url_for('.get_object_meta', object_path=object_path)))\n    return '<object id={} src={} />' \\\n            .format(quoteattr(url_for('.get_object_id', object_path=object_path)),\n                    quoteattr(_get_object_src_uri(object_path)))\n\n\ndef _get_object_src_uri(object_path):\n    if LOCAL_OBJ_URI:\n        return 'file://' + _get_obj_absolute_path(object_path)\n\n    return url_for('.get_object_src_http', obj_path=object_path)\n\ndef _get_obj_path(obj_path):\n    return obj_path.replace(DATAROOT+'/', '')\n\ndef _get_obj_absolute_path(obj_path):\n    return safe_join(DATAROOT, obj_path)\n\n\ndef _get_index_absolute_path(index):\n    return safe_join(INDEXDIR, index)\n\n\n@scope_blueprint.route('/obj/<path:obj_path>')\ndef get_object_src_http(obj_path):\n    path = _get_obj_absolute_path(obj_path)\n\n    headers = Headers()\n    # With add_etags=True, conditional=True\n    # Flask should be smart enough to do 304 Not Modified\n    response = send_file(path,\n                         cache_timeout=datetime.timedelta(\n                             days=365).total_seconds(),\n                         add_etags=True,\n                         conditional=True)\n    response.headers.extend(headers)\n    return response\n", "#\n#  The OpenDiamond Platform for Interactive Search\n#\n#  Copyright (c) 2009-2018 Carnegie Mellon University\n#  All rights reserved.\n#\n#  This software is distributed under the terms of the Eclipse Public\n#  License, Version 1.0 which can be found in the file named LICENSE.\n#  ANY USE, REPRODUCTION OR DISTRIBUTION OF THIS SOFTWARE CONSTITUTES\n#  RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT\n#\n\nfrom builtins import next\nfrom builtins import range\nimport os\nimport datetime\nfrom xml.sax.saxutils import quoteattr\nimport sys\n\nimport logging\nimport random\nimport glob\nfrom itertools import cycle\nfrom flask import Blueprint, url_for, Response, stream_with_context, send_file, \\\n    jsonify\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.security import safe_join\n\nfrom opendiamond.dataretriever.test_utils import *\n\n\nBASEURL = 'cocktailtest'\nSTYLE = False\nLOCAL_OBJ_URI = True  # if true, return local file path, otherwise http.\nINDEXDIR = DATAROOT = None\nITEMS_PER_ITERATION = int(1e4)\n\n\"\"\"\n    Example cocktail url:\n        /cocktail/base/FFFFFFFFFFFFFFFF/distrbuted/1of2/ \\\n            mixers/FFFFFFFFFFFFFFFC/keywords/d_42_1.0/classes/gull,cardinal\n        /cocktail/base/\"0\"/mixers/FFFFFFFFFFFFFFFC/keywords/d_42_1.0\n        /cocktail/base/FFFFFFFFFFFFFFFF/keywords/d_42_1.0\n\"\"\"\n\n\ndef init(config):\n    global INDEXDIR, DATAROOT  # pylint: disable=global-statement\n    INDEXDIR = '/srv/diamond/STREAM'\n    DATAROOT = config.dataroot\n\n\nscope_blueprint = Blueprint('test_store', __name__)\n\n_log = logging.getLogger(__name__)\n\n@scope_blueprint.route('/base/<baseidx>/mixers/<mixeridx>/keywords/<params>')\n@scope_blueprint.route('/base/<baseidx>/mixers/<mixeridx>/keywords/<params>/' +\n                        'classes/<classes>')\n@scope_blueprint.route('/base/<baseidx>/mixers/<mixeridx>/keywords/<params>/' +\n                        'classes/<classes>/start/<int:start>/limit/<int:limit>')\n@scope_blueprint.route('/base/<baseidx>/distrbuted/<int:index>of<int:total>/' +\n                        'mixers/<mixeridx>/keywords/<params>')\n@scope_blueprint.route('/base/<baseidx>/distrbuted/<int:index>of<int:total>/' +\n                        'mixers/<mixeridx>/keywords/<params>/classes/<classes>')\ndef get_mixer_classes(baseidx, mixeridx=None, index=1, total=1, params=None, \n                      classes=None, start=0, limit=-1):\n\n    mixer_list = get_mixer_list(mixeridx, classes)\n    start_idx = int((index-1)*(1.0/total)*len(mixer_list))\n    end_idx = int(index*(1.0/total)*len(mixer_list))\n    mixer_list = mixer_list[start_idx:end_idx]\n    _log.info(\"Mixer Size {}\".format(len(mixer_list)))\n    sys.stdout.flush()\n\n    return get_scope(baseidx, params, mixer_list, start, limit)\n\n@scope_blueprint.route('/base/<baseidx>/keywords/<params>')\n@scope_blueprint.route('/base/<baseidx>/keywords/<params>/start/<int:start>/limit/<int:limit>')\n@scope_blueprint.route('/base/<baseidx>/start/<int:start>/limit/<int:limit>')\ndef get_scope(baseidx, params=None, mixer_list=None, start=0, limit=-1):\n    _log.info(\"Enter Scope baseIdx {}\".format(baseidx))\n    sys.stdout.flush()\n    base_list = []\n    seed = None\n    percentage = 0.\n    if params:\n        seed, percentage = decode_params(params)\n    s_seed = seed\n    if s_seed == None:\n        s_seed = random.randrange(10000)\n    if baseidx != \"0\":\n        # format of baseidx: stream_inat \n        # format of base file: stream_{int: seed}_{float(.2f): baserate} \n        base_index = _get_index_absolute_path(baseidx)\n        data_type, pos_file = base_index.split('_')\n        # index[-1] = str(\"{:.2f}\".format(index[-1])) # to ensure there is exactly two decial places\n        # if seed != s_seed:\n        #     index[1] = str(s_seed)\n        #     base_index = '_'.join(index)\n        base_list = [data_type, str(s_seed), pos_file, \"{:.2f}\".format(percentage)]\n        base_index = '_'.join(base_list)\n        print(base_index)\n        if not os.path.exists(base_index):\n            split_data(INDEXDIR, percentage, s_seed)\n        #base_index = base_index.replace(str(seed),str(s_seed))\n\n        with open(base_index, 'r') as f:\n            base_list = list(f.readlines())\n        if start > 0:\n            base_list = base_list[start:]\n        if limit > 0:\n            end_ = len(base_list)\n            if limit > end_:\n                limit = end_\n            base_list = base_list[:limit]\n        total_entries = len(base_list)\n\n\n    make_cocktail = bool(mixer_list and base_list)\n        \n    if base_list:\n        total_entries = len(base_list)  #base_entries\n    else:\n        total_entries = len(mixer_list)\n        base_list = mixer_list.copy()\n        del mixer_list\n\n    random.seed(seed)\n    #random.Random(seed).shuffle(base_list)\n\n    total_sample = 0 \n    if make_cocktail:\n        random.Random(seed).shuffle(mixer_list)\n        total_sample = int(percentage*total_entries)\n        total_entries = total_entries + total_sample\n\n    # Streaming response:\n    # http://flask.pocoo.org/docs/0.12/patterns/streaming/\n    def generate():\n\n        yield '<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\\n'\n        if STYLE:\n            yield '<?xml-stylesheet type=\"text/xsl\" href=\"/scopelist.xsl\" ?>\\n'\n\n        yield '<objectlist count=\"{:d}\">\\n'.format(total_entries)\n\n        mix_per_iteration = 0\n        iteration_count = 0\n        if make_cocktail:\n            mix_per_iteration = int(percentage * ITEMS_PER_ITERATION)\n            pool = cycle(mixer_list)\n\n        mix_indices = []\n\n        def generate_mix_indices():\n            random.seed(seed)\n            return list(map(lambda x: x + ITEMS_PER_ITERATION*iteration_count,\n                    sorted(random.sample(list(range(ITEMS_PER_ITERATION)), mix_per_iteration))))\n\n        for count in range(total_entries):\n            if not count % ITEMS_PER_ITERATION and make_cocktail:\n                mix_indices = generate_mix_indices()\n                iteration_count += 1\n\n            if count in mix_indices:\n                obj_path = next(pool).strip()\n            else:\n                obj_path = base_list.pop(0).strip()\n            yield _get_object_element(object_path=obj_path) + '\\n'\n\n        yield '</objectlist>\\n'\n\n    headers = Headers([('Content-Type', 'text/xml')])\n\n    return Response(stream_with_context(generate()),\n                    status=\"200 OK\",\n                    headers=headers)\n\ndef decode_params(params):\n    keywords = params.split('_')\n    m_type = keywords[0]\n    seed = int(keywords[1])\n    percentage = 0.1\n    if m_type == 'r':\n        seed = None\n    if len(keywords) > 2:\n        percentage = float(keywords[2]) #float(keywords[2])/100.\n    return seed, round(percentage, 4)\n\ndef get_mixer_list(idx, classes=None):\n    \"\"\"\n    Return list of file paths present in given classes of mixer set\n    If class list is None or incorrect then return list of entire mixer set.\n\n    Args:\n        classes (str): Comma seperated classes of interest\n        idx     (str): Index of mixer collection\n\n    Returns:\n    \"\"\"\n    mixer_index = _get_index_absolute_path('GIDIDX' + idx.upper())\n\n    image_types = ('*.jpg', '*.JPG', '*.jpeg', '.png')\n\n    classes_list = []\n    if classes:\n        classes.replace('%2C', ',')\n        classes.replace('%20', ' ')\n        classes_list = classes.split(',')\n\n    def get_class_path():\n        with open(mixer_index, 'r') as f:\n            dataset_path = f.readline()\n        dataset_path = '/'.join(dataset_path.split('/')[:-2])\n        class_paths = []\n        for c in classes_list:\n            class_paths.append(_get_obj_absolute_path(dataset_path+'/'+c.strip()))\n        return class_paths\n\n    mixer_list = []\n    class_paths = get_class_path()\n    _log.info(\"Class paths : {}\".format(class_paths))\n\n    if class_paths:\n        for path in class_paths:\n            _log.info(\"Path Exists ? {}\".format(os.path.exists(path)))\n            sys.stdout.flush()\n            file_list = []\n            for ext in image_types:\n                file_list.extend(glob.glob(os.path.join(path, ext)))\n            mixer_list.extend(sorted(file_list))\n        mixer_list = [_get_obj_path(l.strip()) for l in mixer_list]\n    else:\n        with open(mixer_index, 'r') as f:\n            mixer_list = list(f.readlines())\n\n    return mixer_list\n\n@scope_blueprint.route('/id/<path:object_path>')\ndef get_object_id(object_path):\n    headers = Headers([('Content-Type', 'text/xml')])\n    return Response(_get_object_element(object_path=object_path),\n                    \"200 OK\",\n                    headers=headers)\n\n\n@scope_blueprint.route('/meta/<path:object_path>')\ndef get_object_meta(object_path):\n    path = _get_obj_absolute_path(object_path)\n    attrs = dict()\n\n    try:\n        attrs['_gt_label'] = path.split('/')[-2]\n    except IOError:\n        pass\n\n    return jsonify(attrs)\n\n\ndef _get_object_element(object_path):\n    path = _get_obj_absolute_path(object_path)\n    class_text = '/'.join(path.split('/')[:-2])+'/classes.txt'\n    if os.path.isfile(class_text):\n        return '<object id={} src={} meta={} />' \\\n            .format(quoteattr(url_for('.get_object_id', object_path=object_path)),\n                    quoteattr(_get_object_src_uri(object_path)),\n                    quoteattr(url_for('.get_object_meta', object_path=object_path)))\n    return '<object id={} src={} />' \\\n            .format(quoteattr(url_for('.get_object_id', object_path=object_path)),\n                    quoteattr(_get_object_src_uri(object_path)))\n\n\ndef _get_object_src_uri(object_path):\n    if LOCAL_OBJ_URI:\n        return 'file://' + _get_obj_absolute_path(object_path)\n\n    return url_for('.get_object_src_http', obj_path=object_path)\n\ndef _get_obj_path(obj_path):\n    return obj_path.replace(DATAROOT+'/', '')\n\ndef _get_obj_absolute_path(obj_path):\n    return safe_join(DATAROOT, obj_path)\n\n\ndef _get_index_absolute_path(index):\n    return safe_join(INDEXDIR, index)\n\n\n@scope_blueprint.route('/obj/<path:obj_path>')\ndef get_object_src_http(obj_path):\n    path = _get_obj_absolute_path(obj_path)\n\n    headers = Headers()\n    # With add_etags=True, conditional=True\n    # Flask should be smart enough to do 304 Not Modified\n    response = send_file(path,\n                         cache_timeout=datetime.timedelta(\n                             days=365).total_seconds(),\n                         add_etags=True,\n                         conditional=True)\n    response.headers.extend(headers)\n    return response\n", "#\n#  The OpenDiamond Platform for Interactive Search\n#\n#  Copyright (c) 2018 Carnegie Mellon University\n#  All rights reserved.\n#\n#  This software is distributed under the terms of the Eclipse Public\n#  License, Version 1.0 which can be found in the file named LICENSE.\n#  ANY USE, REPRODUCTION OR DISTRIBUTION OF THIS SOFTWARE CONSTITUTES\n#  RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT\n#\nfrom builtins import range, str\n\nimport datetime\nimport json\nimport os\nimport subprocess\nimport sys\nfrom math import ceil\n\nfrom flask import Blueprint, Response, request, stream_with_context, url_for\nfrom opendiamond.dataretriever.util import DiamondTextAttr\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.security import safe_join\n\n# IMPORTANT: requires ffmpeg >= 3.3. Lower versions produce incorrect clipping.\n\nBASEURL = 'video'\nSTYLE = False\nINDEXDIR = DATAROOT = None\n\n\ndef init(config):\n    global INDEXDIR, DATAROOT  # pylint: disable=global-statement\n    INDEXDIR = config.indexdir\n    DATAROOT = config.dataroot\n\n\nscope_blueprint = Blueprint('video_store', __name__)\n\n@scope_blueprint.route('/scope/<gididx>')\n@scope_blueprint.route('/scope/stride/<int:stride>/span/<int:span>/<gididx>')\ndef get_scope(gididx, stride=5, span=5):\n    index = 'GIDIDX' + gididx.upper()\n\n    def generate():\n        yield '<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\\n'\n        if STYLE:\n            yield '<?xml-stylesheet type=\"text/xsl\" href=\"/scopelist.xsl\" ?>\\n'\n\n        yield '<objectlist>\\n'\n\n        with open(_get_index_absolute_path(index), 'rt') as f:\n            for line in f:\n                video = line.strip()\n                video_path = str(_get_obj_absolute_path(video))\n                try:\n                    video_meta = _ffprobe(video_path)\n                    length_sec = float(video_meta['format']['duration'])\n                    num_clips = int(ceil(length_sec / stride))\n                    yield '<count adjust=\"{}\"/>\\n'.format(num_clips)\n                    for clip in range(num_clips):\n                        yield _get_object_element(start=clip * stride, span=span, video=video) + '\\n'\n                except Exception as e:\n                    print(\"Error parsing {}. {}. Skip.\".format(video, str(e)), file=sys.stderr)\n                    pass\n\n        yield '</objectlist>\\n'\n\n    headers = Headers([('Content-Type', 'text/xml')])\n    return Response(stream_with_context(generate()),\n                    status=\"200 OK\",\n                    headers=headers)\n\n\n@scope_blueprint.route('/id/start/<int:start>/span/<int:span>/<path:video>')\ndef get_object_id(start, span, video):\n    headers = Headers([('Content-Type', 'text/xml')])\n    return Response(_get_object_element(start, span, video),\n                    \"200 OK\",\n                    headers=headers)\n\n\n@scope_blueprint.route('/obj/start/<int:start>/span/<int:span>/<path:video>')\ndef get_object(start, span, video):\n    # Reference:\n    # https://github.com/mikeboers/PyAV/blob/master/tests/test_seek.py\n    video_path = str(_get_obj_absolute_path(video))\n    proc = _create_ffmpeg_segment_proc(video_path,\n                                       start_sec=start,\n                                       duration_sec=span)\n\n    def generate():\n        while True:\n            data = proc.stdout.read(4096)\n            if not data:\n                break\n            yield data\n\n    headers = Headers([('Content-Type', 'video/mp4')])\n    response = Response(stream_with_context(generate()),\n                        status=\"200 OK\",\n                        headers=headers)\n    # Cache control\n    stat = os.stat(video_path)\n    last_modified = stat.st_mtime\n    size = stat.st_size\n    etag = \"{}_{}_{}_{}\".format(last_modified, size, start, span)\n    response.last_modified = last_modified\n    response.set_etag(etag=etag)\n    response.cache_control.public = True\n    response.cache_control.max_age = \\\n        datetime.timedelta(days=365).total_seconds()\n    response.make_conditional(request)\n\n    return response\n\n\ndef _get_object_element(start, span, video):\n    return '<object id=\"{}\" src=\"{}\" />'.format(\n        url_for('.get_object_id', start=start, span=span, video=video),\n        url_for('.get_object', start=start, span=span, video=video))\n\n\ndef _get_obj_absolute_path(obj_path):\n    return safe_join(DATAROOT, obj_path)\n\n\ndef _get_index_absolute_path(index):\n    return safe_join(INDEXDIR, index)\n\n\ndef _ffprobe(video_path):\n    cmd_l = ['ffprobe', '-v', 'quiet', '-print_format', 'json',\n                '-show_format', video_path]\n\n    proc = subprocess.Popen(cmd_l, stdout=subprocess.PIPE, bufsize=-1)\n    data = json.load(proc.stdout)\n    \n    return data\n\n\ndef _create_ffmpeg_segment_proc(video_path, start_sec, duration_sec):\n    \"\"\"\n    Use ffmpeg to extract a .mp4 segment of the video. Outfile is written to stdout.\n    Note: requires ffmpeg >= 3.3. Lower versions produce wrong results.\n    Reference: http://trac.ffmpeg.org/wiki/Seeking\n    https://stackoverflow.com/questions/34123272/ffmpeg-transmux-mpegts-to-mp4-gives-error-muxer-does-not-support-non-seekable\n    :param video_path:\n    :param start_sec:\n    :param duration_sec:\n    :return: the subprocess\n    \"\"\"\n    cmd_l = ['ffmpeg', '-v', 'quiet',\n             '-ss', str(start_sec),\n             '-t', str(duration_sec),\n             '-i', str(video_path),\n             '-movflags', 'frag_keyframe+empty_moov',\n             '-c', 'copy',\n             '-f', 'mp4',\n             'pipe:1']\n\n    proc = subprocess.Popen(cmd_l, stdout=subprocess.PIPE, bufsize=-1)\n    return proc\n", "#\n#  The OpenDiamond Platform for Interactive Search\n#\n#  Copyright (c) 2018 Carnegie Mellon University\n#  All rights reserved.\n#\n#  This software is distributed under the terms of the Eclipse Public\n#  License, Version 1.0 which can be found in the file named LICENSE.\n#  ANY USE, REPRODUCTION OR DISTRIBUTION OF THIS SOFTWARE CONSTITUTES\n#  RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT\n#\n\"\"\"\nPre-conditions:\nMetadata of a data set is stored in a table <dataset> in a MySQL database.\nFiles (objects) belonging to a dataset are stored under DATAROOT/<dataset>/.\nMySQL table stores relative path to the above directory.\nTable provides keyword search to get list of objects.\nDatabase login info is obtained from DiamondConfig.\nMySQL table is indexed with:\n FULLTEXT (title, keywords, description)\n\nRequires:\npip install mysql-connector-python==8.0.6\n\"\"\"\nimport datetime\nimport os\nfrom flask import Blueprint, url_for, Response, \\\n    stream_with_context, abort, jsonify, send_file\nimport logging\nimport mysql.connector\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.security import safe_join\nfrom xml.sax.saxutils import quoteattr\n\nBASEURL = 'yfcc100m_mysql'\nSTYLE = False\nLOCAL_OBJ_URI = True  # if true, return local path, otherwise http.\nDATAROOT = None\nDB_HOST = DB_DBNAME = DB_USER = DB_PASSWORD = DB_PORT = None\n\n_log = logging.getLogger(__name__)\n\nyfcc100m_s3_image_prefix = 'https://multimedia-commons.s3-us-west-2.amazonaws.com/data/images/'\n\n\ndef init(config):\n    global DATAROOT  # pylint: disable=global-statement\n    DATAROOT = config.dataroot\n    global DB_HOST, DB_DBNAME, DB_USER, DB_PASSWORD, DB_PORT\n    DB_HOST = config.yfcc100m_db_host\n    DB_DBNAME = config.yfcc100m_db_dbname\n    DB_USER = config.yfcc100m_db_user\n    DB_PASSWORD = config.yfcc100m_db_password\n    DB_PORT = config.yfcc100m_db_port\n\n\nscope_blueprint = Blueprint('mysql_store', __name__)\n\n\n@scope_blueprint.route('/scope/<dataset>')\n@scope_blueprint.route('/scope/<dataset>/keywords/<keywords>')\n@scope_blueprint.route('/scope/<dataset>/modulo/<int:divisor>/<expression>')\n@scope_blueprint.route(\n    '/scope/<dataset>/keywords/<keywords>/modulo/<int:divisor>/<expression>')\ndef get_scope(dataset, keywords=None, divisor=None, expression=None):\n    \"\"\"\n\n    :param expression: Can be \"<3\", \"=3\", \">3\", etc.\n    :param dataset:\n    :param keywords: a string of comma-separated keywords\n    :param divisor: positive int\n    :return:\n    \"\"\"\n    # cursor.execute() can't substitute table name\n    query = \"SELECT sequence_no, rel_path, download_link FROM \" + dataset\n    conditions = []\n    substitutes = []\n    if keywords:\n        conditions.append(\"MATCH (title, keywords, description) AGAINST(%s)\")\n        substitutes.append(keywords)\n\n    if divisor:\n        # TODO sanity check expression\n        conditions.append(\"(sequence_no % %s) \" + expression)\n        substitutes.extend([divisor])\n\n    if conditions:\n        query += \" WHERE \" + ' AND '.join(conditions)\n\n    _log.debug(\"Query used: %s, substitutes: %s\", query, substitutes)\n\n    def generate():\n        cnx = mysql.connector.connect(user=DB_USER,\n                                      password=DB_PASSWORD,\n                                      host=DB_HOST,\n                                      database=DB_DBNAME,\n                                      port=DB_PORT)\n        cursor = cnx.cursor()\n        cursor.execute(query, substitutes)\n\n        yield '<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\\n'\n        if STYLE:\n            yield '<?xml-stylesheet type=\"text/xsl\" href=\"/scopelist.xsl\" ?>\\n'\n\n        yield '<objectlist>\\n'\n        for seq_no, rel_path, download_link in cursor:\n            yield '<count adjust=\"1\"/>\\n'\n            yield _get_object_element(dataset, seq_no, rel_path,\n                                      download_link) + '\\n'\n\n        yield '</objectlist>\\n'\n\n    headers = Headers([('Content-Type', 'text/xml')])\n\n    return Response(stream_with_context(generate()),\n                    status=\"200 OK\",\n                    headers=headers)\n\n@scope_blueprint.route('/id/<dataset>/<int:seq_no>')\ndef get_object_id(dataset, seq_no):\n    headers = Headers([('Content-Type', 'text/xml')])\n    return Response(_get_object_element(dataset, seq_no, None, None),\n                    \"200 OK\",\n                    headers=headers)\n\n@scope_blueprint.route('/obj/<dataset>/<path:rel_path>')\ndef get_object_src_http(dataset, rel_path):\n    path = _get_obj_absolute_path(dataset, rel_path)\n    response = send_file(path,\n                         cache_timeout=datetime.timedelta(\n                             days=365).total_seconds(),\n                         add_etags=True,\n                         conditional=True)\n    return response\n\n\ndef _get_obj_absolute_path(dataset, rel_path):\n    return safe_join(DATAROOT, dataset, rel_path)\n\n\ndef _get_object_element(dataset, seq_no, rel_path, download_link):\n    \"\"\"If rel_path and download_link are not None, we are called from scope.\n    Otherwise we are called from ID and need to run SQL query to fetch these attrs.\"\"\"\n\n    if rel_path is None:\n        query = \"SELECT rel_path, download_link FROM \" + \\\n        dataset + \\\n        \" WHERE sequence_no = %s\"\n\n        cnx = mysql.connector.connect(user=DB_USER,\n                                    password=DB_PASSWORD,\n                                    host=DB_HOST,\n                                    database=DB_DBNAME,\n                                    port=DB_PORT)\n        cursor = cnx.cursor()\n        cursor.execute(query, (seq_no,))\n\n        row = cursor.fetchone()\n\n        if not row:\n            return None\n\n        rel_path, download_link = row[0], row[1]\n\n    if LOCAL_OBJ_URI:\n        src_uri = 'file://' + _get_obj_absolute_path(dataset, rel_path)\n    else:\n        src_uri = url_for('.get_object_src_http', dataset=dataset, rel_path=rel_path)\n\n    return '<object id={} src={} hyperfind.external-link={} />' \\\n        .format(\n        quoteattr(url_for('.get_object_id', dataset=dataset, seq_no=seq_no)),\n        quoteattr(src_uri),\n        quoteattr(download_link))\n"], "filenames": ["opendiamond/dataretriever/augment_store.py", "opendiamond/dataretriever/diamond_store.py", "opendiamond/dataretriever/mixer_store.py", "opendiamond/dataretriever/test_store.py", "opendiamond/dataretriever/video_store.py", "opendiamond/dataretriever/yfcc100m_mysql_store.py"], "buggy_code_start_loc": [27, 19, 26, 26, 23, 31], "buggy_code_end_loc": [28, 128, 257, 287, 130, 166], "fixing_code_start_loc": [27, 20, 27, 27, 24, 32], "fixing_code_end_loc": [28, 129, 258, 289, 131, 167], "type": "CWE-22", "message": "The cmusatyalab/opendiamond repository through 10.1.1 on GitHub allows absolute path traversal because the Flask send_file function is used unsafely.", "other": {"cve": {"id": "CVE-2022-31506", "sourceIdentifier": "cve@mitre.org", "published": "2022-07-11T01:15:08.253", "lastModified": "2022-07-15T12:08:18.883", "vulnStatus": "Undergoing Analysis", "descriptions": [{"lang": "en", "value": "The cmusatyalab/opendiamond repository through 10.1.1 on GitHub allows absolute path traversal because the Flask send_file function is used unsafely."}, {"lang": "es", "value": "El repositorio cmusatyalab/opendiamond versiones hasta 10.1.1 en GitHub, permite un salto de ruta absoluto porque la funci\u00f3n send_file de Flask es usada de forma no segura"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 9.3, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 4.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:cmu:opendiamond:*:*:*:*:*:*:*:*", "versionEndIncluding": "10.1.1", "matchCriteriaId": "D56B69B3-03C1-4571-9C78-0B78DF60ECCB"}]}]}], "references": [{"url": "https://github.com/cmusatyalab/opendiamond/commit/398049c187ee644beabab44d6fece82251c1ea56", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/github/securitylab/issues/669#issuecomment-1117265726", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/cmusatyalab/opendiamond/commit/398049c187ee644beabab44d6fece82251c1ea56"}}