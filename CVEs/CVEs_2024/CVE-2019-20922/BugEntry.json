{"buggy_code": ["describe('helpers', function() {\n  it('helper with complex lookup$', function() {\n    var string = '{{#goodbyes}}{{{link ../prefix}}}{{/goodbyes}}';\n    var hash = {prefix: '/root', goodbyes: [{text: 'Goodbye', url: 'goodbye'}]};\n    var helpers = {link: function(prefix) {\n      return '<a href=\"' + prefix + '/' + this.url + '\">' + this.text + '</a>';\n    }};\n    shouldCompileTo(string, [hash, helpers], '<a href=\"/root/goodbye\">Goodbye</a>');\n  });\n\n  it('helper for raw block gets raw content', function() {\n    var string = '{{{{raw}}}} {{test}} {{{{/raw}}}}';\n    var hash = { test: 'hello' };\n    var helpers = { raw: function(options) {\n        return options.fn();\n    } };\n    shouldCompileTo(string, [hash, helpers], ' {{test}} ',\n                    'raw block helper gets raw content');\n  });\n\n  it('helper for raw block gets parameters', function() {\n    var string = '{{{{raw 1 2 3}}}} {{test}} {{{{/raw}}}}';\n    var hash = { test: 'hello' };\n    var helpers = { raw: function(a, b, c, options) {\n        return options.fn() + a + b + c;\n    } };\n    shouldCompileTo(string, [hash, helpers], ' {{test}} 123',\n                    'raw block helper gets raw content');\n  });\n\n  describe('raw block parsing (with identity helper-function)', function() {\n\n    function runWithIdentityHelper(template, expected) {\n      var helpers = {\n        identity: function(options) {\n          return options.fn();\n        }\n      };\n      shouldCompileTo(template, [{}, helpers], expected);\n    }\n\n    it('helper for nested raw block gets raw content', function() {\n      runWithIdentityHelper('{{{{identity}}}} {{{{b}}}} {{{{/b}}}} {{{{/identity}}}}', ' {{{{b}}}} {{{{/b}}}} ');\n    });\n\n    it('helper for nested raw block works with empty content', function() {\n      runWithIdentityHelper('{{{{identity}}}}{{{{/identity}}}}', '');\n    });\n\n    it('helper for nested raw block works if nested raw blocks are broken', function() {\n      runWithIdentityHelper('{{{{identity}}}} {{{{a}}}} {{{{ {{{{/ }}}} }}}} {{{{/identity}}}}', ' {{{{a}}}} {{{{ {{{{/ }}}} }}}} ');\n    });\n\n    it('helper for nested raw block throw exception when with missing closing braces', function() {\n      var string = '{{{{a}}}} {{{{/a';\n      shouldThrow(function() {\n        Handlebars.compile(string)();\n      });\n    });\n  });\n\n  it('helper block with identical context', function() {\n    var string = '{{#goodbyes}}{{name}}{{/goodbyes}}';\n    var hash = {name: 'Alan'};\n    var helpers = {goodbyes: function(options) {\n      var out = '';\n      var byes = ['Goodbye', 'goodbye', 'GOODBYE'];\n      for (var i = 0, j = byes.length; i < j; i++) {\n        out += byes[i] + ' ' + options.fn(this) + '! ';\n      }\n      return out;\n    }};\n    shouldCompileTo(string, [hash, helpers], 'Goodbye Alan! goodbye Alan! GOODBYE Alan! ');\n  });\n  it('helper block with complex lookup expression', function() {\n    var string = '{{#goodbyes}}{{../name}}{{/goodbyes}}';\n    var hash = {name: 'Alan'};\n    var helpers = {goodbyes: function(options) {\n      var out = '';\n      var byes = ['Goodbye', 'goodbye', 'GOODBYE'];\n      for (var i = 0, j = byes.length; i < j; i++) {\n        out += byes[i] + ' ' + options.fn({}) + '! ';\n      }\n      return out;\n    }};\n    shouldCompileTo(string, [hash, helpers], 'Goodbye Alan! goodbye Alan! GOODBYE Alan! ');\n  });\n\n  it('helper with complex lookup and nested template', function() {\n    var string = '{{#goodbyes}}{{#link ../prefix}}{{text}}{{/link}}{{/goodbyes}}';\n    var hash = {prefix: '/root', goodbyes: [{text: 'Goodbye', url: 'goodbye'}]};\n    var helpers = {link: function(prefix, options) {\n        return '<a href=\"' + prefix + '/' + this.url + '\">' + options.fn(this) + '</a>';\n    }};\n    shouldCompileToWithPartials(string, [hash, helpers], false, '<a href=\"/root/goodbye\">Goodbye</a>');\n  });\n\n  it('helper with complex lookup and nested template in VM+Compiler', function() {\n    var string = '{{#goodbyes}}{{#link ../prefix}}{{text}}{{/link}}{{/goodbyes}}';\n    var hash = {prefix: '/root', goodbyes: [{text: 'Goodbye', url: 'goodbye'}]};\n    var helpers = {link: function(prefix, options) {\n        return '<a href=\"' + prefix + '/' + this.url + '\">' + options.fn(this) + '</a>';\n    }};\n    shouldCompileToWithPartials(string, [hash, helpers], true, '<a href=\"/root/goodbye\">Goodbye</a>');\n  });\n  it('helper returning undefined value', function() {\n    shouldCompileTo(' {{nothere}}', [{}, {nothere: function() {}}], ' ');\n    shouldCompileTo(' {{#nothere}}{{/nothere}}', [{}, {nothere: function() {}}], ' ');\n  });\n\n  it('block helper', function() {\n    var string = '{{#goodbyes}}{{text}}! {{/goodbyes}}cruel {{world}}!';\n    var template = CompilerContext.compile(string);\n\n    var result = template({world: 'world'}, { helpers: {goodbyes: function(options) { return options.fn({text: 'GOODBYE'}); }}});\n    equal(result, 'GOODBYE! cruel world!', 'Block helper executed');\n  });\n\n  it('block helper staying in the same context', function() {\n    var string = '{{#form}}<p>{{name}}</p>{{/form}}';\n    var template = CompilerContext.compile(string);\n\n    var result = template({name: 'Yehuda'}, {helpers: {form: function(options) { return '<form>' + options.fn(this) + '</form>'; } }});\n    equal(result, '<form><p>Yehuda</p></form>', 'Block helper executed with current context');\n  });\n\n  it('block helper should have context in this', function() {\n    var source = '<ul>{{#people}}<li>{{#link}}{{name}}{{/link}}</li>{{/people}}</ul>';\n    function link(options) {\n      return '<a href=\"/people/' + this.id + '\">' + options.fn(this) + '</a>';\n    }\n    var data = { 'people': [\n      { 'name': 'Alan', 'id': 1 },\n      { 'name': 'Yehuda', 'id': 2 }\n    ]};\n\n    shouldCompileTo(source, [data, {link: link}], '<ul><li><a href=\"/people/1\">Alan</a></li><li><a href=\"/people/2\">Yehuda</a></li></ul>');\n  });\n\n  it('block helper for undefined value', function() {\n    shouldCompileTo(\"{{#empty}}shouldn't render{{/empty}}\", {}, '');\n  });\n\n  it('block helper passing a new context', function() {\n    var string = '{{#form yehuda}}<p>{{name}}</p>{{/form}}';\n    var template = CompilerContext.compile(string);\n\n    var result = template({yehuda: {name: 'Yehuda'}}, { helpers: {form: function(context, options) { return '<form>' + options.fn(context) + '</form>'; }}});\n    equal(result, '<form><p>Yehuda</p></form>', 'Context variable resolved');\n  });\n\n  it('block helper passing a complex path context', function() {\n    var string = '{{#form yehuda/cat}}<p>{{name}}</p>{{/form}}';\n    var template = CompilerContext.compile(string);\n\n    var result = template({yehuda: {name: 'Yehuda', cat: {name: 'Harold'}}}, { helpers: {form: function(context, options) { return '<form>' + options.fn(context) + '</form>'; }}});\n    equal(result, '<form><p>Harold</p></form>', 'Complex path variable resolved');\n  });\n\n  it('nested block helpers', function() {\n    var string = '{{#form yehuda}}<p>{{name}}</p>{{#link}}Hello{{/link}}{{/form}}';\n    var template = CompilerContext.compile(string);\n\n    var result = template({\n      yehuda: {name: 'Yehuda' }\n    }, {\n      helpers: {\n        link: function(options) { return '<a href=\"' + this.name + '\">' + options.fn(this) + '</a>'; },\n        form: function(context, options) { return '<form>' + options.fn(context) + '</form>'; }\n      }\n    });\n    equal(result, '<form><p>Yehuda</p><a href=\"Yehuda\">Hello</a></form>', 'Both blocks executed');\n  });\n\n  it('block helper inverted sections', function() {\n    var string = '{{#list people}}{{name}}{{^}}<em>Nobody\\'s here</em>{{/list}}';\n    function list(context, options) {\n      if (context.length > 0) {\n        var out = '<ul>';\n        for (var i = 0, j = context.length; i < j; i++) {\n          out += '<li>';\n          out += options.fn(context[i]);\n          out += '</li>';\n        }\n        out += '</ul>';\n        return out;\n      } else {\n        return '<p>' + options.inverse(this) + '</p>';\n      }\n    }\n\n    var hash = {people: [{name: 'Alan'}, {name: 'Yehuda'}]};\n    var empty = {people: []};\n    var rootMessage = {\n      people: [],\n      message: 'Nobody\\'s here'\n    };\n\n    var messageString = '{{#list people}}Hello{{^}}{{message}}{{/list}}';\n\n    // the meaning here may be kind of hard to catch, but list.not is always called,\n    // so we should see the output of both\n    shouldCompileTo(string, [hash, { list: list }], '<ul><li>Alan</li><li>Yehuda</li></ul>', 'an inverse wrapper is passed in as a new context');\n    shouldCompileTo(string, [empty, { list: list }], '<p><em>Nobody\\'s here</em></p>', 'an inverse wrapper can be optionally called');\n    shouldCompileTo(messageString, [rootMessage, { list: list }], '<p>Nobody&#x27;s here</p>', 'the context of an inverse is the parent of the block');\n  });\n\n  it('pathed lambas with parameters', function() {\n    var hash = {\n      helper: function() {\n        return 'winning';\n      }\n    };\n    hash.hash = hash;\n    var helpers = {\n      './helper': function() {\n        return 'fail';\n      }\n    };\n    shouldCompileTo('{{./helper 1}}', [hash, helpers], 'winning');\n    shouldCompileTo('{{hash/helper 1}}', [hash, helpers], 'winning');\n  });\n\n  describe('helpers hash', function() {\n    it('providing a helpers hash', function() {\n      shouldCompileTo('Goodbye {{cruel}} {{world}}!', [{cruel: 'cruel'}, {world: function() { return 'world'; }}], 'Goodbye cruel world!',\n                      'helpers hash is available');\n\n      shouldCompileTo('Goodbye {{#iter}}{{cruel}} {{world}}{{/iter}}!', [{iter: [{cruel: 'cruel'}]}, {world: function() { return 'world'; }}],\n                      'Goodbye cruel world!', 'helpers hash is available inside other blocks');\n    });\n\n    it('in cases of conflict, helpers win', function() {\n      shouldCompileTo('{{{lookup}}}', [{lookup: 'Explicit'}, {lookup: function() { return 'helpers'; }}], 'helpers',\n                      'helpers hash has precedence escaped expansion');\n      shouldCompileTo('{{lookup}}', [{lookup: 'Explicit'}, {lookup: function() { return 'helpers'; }}], 'helpers',\n                      'helpers hash has precedence simple expansion');\n    });\n\n    it('the helpers hash is available is nested contexts', function() {\n      shouldCompileTo(\n        '{{#outer}}{{#inner}}{{helper}}{{/inner}}{{/outer}}',\n        [\n          {'outer': {'inner': {'unused': []}}},\n          {'helper': function() { return 'helper'; }}\n        ],\n        'helper',\n        'helpers hash is available in nested contexts.');\n    });\n\n    it('the helper hash should augment the global hash', function() {\n      handlebarsEnv.registerHelper('test_helper', function() { return 'found it!'; });\n\n      shouldCompileTo(\n        '{{test_helper}} {{#if cruel}}Goodbye {{cruel}} {{world}}!{{/if}}', [\n          {cruel: 'cruel'},\n          {world: function() { return 'world!'; }}\n        ],\n        'found it! Goodbye cruel world!!');\n    });\n  });\n\n  describe('registration', function() {\n    it('unregisters', function() {\n      handlebarsEnv.helpers = {};\n\n      handlebarsEnv.registerHelper('foo', function() {\n        return 'fail';\n      });\n      handlebarsEnv.unregisterHelper('foo');\n      equals(handlebarsEnv.helpers.foo, undefined);\n    });\n\n    it('allows multiple globals', function() {\n      var helpers = handlebarsEnv.helpers;\n      handlebarsEnv.helpers = {};\n\n      handlebarsEnv.registerHelper({\n        'if': helpers['if'],\n        world: function() { return 'world!'; },\n        testHelper: function() { return 'found it!'; }\n      });\n\n      shouldCompileTo(\n        '{{testHelper}} {{#if cruel}}Goodbye {{cruel}} {{world}}!{{/if}}',\n        [{cruel: 'cruel'}],\n        'found it! Goodbye cruel world!!');\n    });\n    it('fails with multiple and args', function() {\n      shouldThrow(function() {\n        handlebarsEnv.registerHelper({\n          world: function() { return 'world!'; },\n          testHelper: function() { return 'found it!'; }\n        }, {});\n      }, Error, 'Arg not supported with multiple helpers');\n    });\n  });\n\n  it('decimal number literals work', function() {\n    var string = 'Message: {{hello -1.2 1.2}}';\n    var helpers = {hello: function(times, times2) {\n      if (typeof times !== 'number') { times = 'NaN'; }\n      if (typeof times2 !== 'number') { times2 = 'NaN'; }\n      return 'Hello ' + times + ' ' + times2 + ' times';\n    }};\n    shouldCompileTo(string, [{}, helpers], 'Message: Hello -1.2 1.2 times', 'template with a negative integer literal');\n  });\n\n  it('negative number literals work', function() {\n    var string = 'Message: {{hello -12}}';\n    var helpers = {hello: function(times) {\n      if (typeof times !== 'number') { times = 'NaN'; }\n      return 'Hello ' + times + ' times';\n    }};\n    shouldCompileTo(string, [{}, helpers], 'Message: Hello -12 times', 'template with a negative integer literal');\n  });\n\n  describe('String literal parameters', function() {\n    it('simple literals work', function() {\n      var string = 'Message: {{hello \"world\" 12 true false}}';\n      var helpers = {hello: function(param, times, bool1, bool2) {\n        if (typeof times !== 'number') { times = 'NaN'; }\n        if (typeof bool1 !== 'boolean') { bool1 = 'NaB'; }\n        if (typeof bool2 !== 'boolean') { bool2 = 'NaB'; }\n        return 'Hello ' + param + ' ' + times + ' times: ' + bool1 + ' ' + bool2;\n      }};\n      shouldCompileTo(string, [{}, helpers], 'Message: Hello world 12 times: true false', 'template with a simple String literal');\n    });\n\n    it('using a quote in the middle of a parameter raises an error', function() {\n      var string = 'Message: {{hello wo\"rld\"}}';\n      shouldThrow(function() {\n        CompilerContext.compile(string);\n      }, Error);\n    });\n\n    it('escaping a String is possible', function() {\n      var string = 'Message: {{{hello \"\\\\\"world\\\\\"\"}}}';\n      var helpers = {hello: function(param) { return 'Hello ' + param; }};\n      shouldCompileTo(string, [{}, helpers], 'Message: Hello \"world\"', 'template with an escaped String literal');\n    });\n\n    it(\"it works with ' marks\", function() {\n      var string = 'Message: {{{hello \"Alan\\'s world\"}}}';\n      var helpers = {hello: function(param) { return 'Hello ' + param; }};\n      shouldCompileTo(string, [{}, helpers], \"Message: Hello Alan's world\", \"template with a ' mark\");\n    });\n  });\n\n  it('negative number literals work', function() {\n    var string = 'Message: {{hello -12}}';\n    var helpers = {hello: function(times) {\n      if (typeof times !== 'number') { times = 'NaN'; }\n      return 'Hello ' + times + ' times';\n    }};\n    shouldCompileTo(string, [{}, helpers], 'Message: Hello -12 times', 'template with a negative integer literal');\n  });\n\n  describe('multiple parameters', function() {\n    it('simple multi-params work', function() {\n      var string = 'Message: {{goodbye cruel world}}';\n      var hash = {cruel: 'cruel', world: 'world'};\n      var helpers = {goodbye: function(cruel, world) { return 'Goodbye ' + cruel + ' ' + world; }};\n      shouldCompileTo(string, [hash, helpers], 'Message: Goodbye cruel world', 'regular helpers with multiple params');\n    });\n\n    it('block multi-params work', function() {\n      var string = 'Message: {{#goodbye cruel world}}{{greeting}} {{adj}} {{noun}}{{/goodbye}}';\n      var hash = {cruel: 'cruel', world: 'world'};\n      var helpers = {goodbye: function(cruel, world, options) {\n        return options.fn({greeting: 'Goodbye', adj: cruel, noun: world});\n      }};\n      shouldCompileTo(string, [hash, helpers], 'Message: Goodbye cruel world', 'block helpers with multiple params');\n    });\n  });\n\n  describe('hash', function() {\n    it('helpers can take an optional hash', function() {\n      var template = CompilerContext.compile('{{goodbye cruel=\"CRUEL\" world=\"WORLD\" times=12}}');\n\n      var helpers = {\n        goodbye: function(options) {\n          return 'GOODBYE ' + options.hash.cruel + ' ' + options.hash.world + ' ' + options.hash.times + ' TIMES';\n        }\n      };\n\n      var context = {};\n\n      var result = template(context, {helpers: helpers});\n      equals(result, 'GOODBYE CRUEL WORLD 12 TIMES', 'Helper output hash');\n    });\n\n    it('helpers can take an optional hash with booleans', function() {\n      var helpers = {\n        goodbye: function(options) {\n          if (options.hash.print === true) {\n            return 'GOODBYE ' + options.hash.cruel + ' ' + options.hash.world;\n          } else if (options.hash.print === false) {\n            return 'NOT PRINTING';\n          } else {\n            return 'THIS SHOULD NOT HAPPEN';\n          }\n        }\n      };\n\n      var context = {};\n\n      var template = CompilerContext.compile('{{goodbye cruel=\"CRUEL\" world=\"WORLD\" print=true}}');\n      var result = template(context, {helpers: helpers});\n      equals(result, 'GOODBYE CRUEL WORLD', 'Helper output hash');\n\n      template = CompilerContext.compile('{{goodbye cruel=\"CRUEL\" world=\"WORLD\" print=false}}');\n      result = template(context, {helpers: helpers});\n      equals(result, 'NOT PRINTING', 'Boolean helper parameter honored');\n    });\n\n    it('block helpers can take an optional hash', function() {\n      var template = CompilerContext.compile('{{#goodbye cruel=\"CRUEL\" times=12}}world{{/goodbye}}');\n\n      var helpers = {\n        goodbye: function(options) {\n          return 'GOODBYE ' + options.hash.cruel + ' ' + options.fn(this) + ' ' + options.hash.times + ' TIMES';\n        }\n      };\n\n      var result = template({}, {helpers: helpers});\n      equals(result, 'GOODBYE CRUEL world 12 TIMES', 'Hash parameters output');\n    });\n\n    it('block helpers can take an optional hash with single quoted stings', function() {\n      var template = CompilerContext.compile('{{#goodbye cruel=\"CRUEL\" times=12}}world{{/goodbye}}');\n\n      var helpers = {\n        goodbye: function(options) {\n          return 'GOODBYE ' + options.hash.cruel + ' ' + options.fn(this) + ' ' + options.hash.times + ' TIMES';\n        }\n      };\n\n      var result = template({}, {helpers: helpers});\n      equals(result, 'GOODBYE CRUEL world 12 TIMES', 'Hash parameters output');\n    });\n\n    it('block helpers can take an optional hash with booleans', function() {\n      var helpers = {\n        goodbye: function(options) {\n          if (options.hash.print === true) {\n            return 'GOODBYE ' + options.hash.cruel + ' ' + options.fn(this);\n          } else if (options.hash.print === false) {\n            return 'NOT PRINTING';\n          } else {\n            return 'THIS SHOULD NOT HAPPEN';\n          }\n        }\n      };\n\n      var template = CompilerContext.compile('{{#goodbye cruel=\"CRUEL\" print=true}}world{{/goodbye}}');\n      var result = template({}, {helpers: helpers});\n      equals(result, 'GOODBYE CRUEL world', 'Boolean hash parameter honored');\n\n      template = CompilerContext.compile('{{#goodbye cruel=\"CRUEL\" print=false}}world{{/goodbye}}');\n      result = template({}, {helpers: helpers});\n      equals(result, 'NOT PRINTING', 'Boolean hash parameter honored');\n    });\n  });\n\n  describe('helperMissing', function() {\n    it('if a context is not found, helperMissing is used', function() {\n      shouldThrow(function() {\n          var template = CompilerContext.compile('{{hello}} {{link_to world}}');\n          template({});\n      }, undefined, /Missing helper: \"link_to\"/);\n    });\n\n    it('if a context is not found, custom helperMissing is used', function() {\n      var string = '{{hello}} {{link_to world}}';\n      var context = { hello: 'Hello', world: 'world' };\n\n      var helpers = {\n        helperMissing: function(mesg, options) {\n          if (options.name === 'link_to') {\n            return new Handlebars.SafeString('<a>' + mesg + '</a>');\n          }\n        }\n      };\n\n      shouldCompileTo(string, [context, helpers], 'Hello <a>world</a>');\n    });\n\n    it('if a value is not found, custom helperMissing is used', function() {\n      var string = '{{hello}} {{link_to}}';\n      var context = { hello: 'Hello', world: 'world' };\n\n      var helpers = {\n        helperMissing: function(options) {\n          if (options.name === 'link_to') {\n            return new Handlebars.SafeString('<a>winning</a>');\n          }\n        }\n      };\n\n      shouldCompileTo(string, [context, helpers], 'Hello <a>winning</a>');\n    });\n  });\n\n  describe('knownHelpers', function() {\n    it('Known helper should render helper', function() {\n      var template = CompilerContext.compile('{{hello}}', {knownHelpers: {hello: true}});\n\n      var result = template({}, {helpers: {hello: function() { return 'foo'; }}});\n      equal(result, 'foo', \"'foo' should === '\" + result);\n    });\n\n    it('Unknown helper in knownHelpers only mode should be passed as undefined', function() {\n      var template = CompilerContext.compile('{{typeof hello}}', {knownHelpers: {'typeof': true}, knownHelpersOnly: true});\n\n      var result = template({}, {helpers: {'typeof': function(arg) { return typeof arg; }, hello: function() { return 'foo'; }}});\n      equal(result, 'undefined', \"'undefined' should === '\" + result);\n    });\n    it('Builtin helpers available in knownHelpers only mode', function() {\n      var template = CompilerContext.compile('{{#unless foo}}bar{{/unless}}', {knownHelpersOnly: true});\n\n      var result = template({});\n      equal(result, 'bar', \"'bar' should === '\" + result);\n    });\n    it('Field lookup works in knownHelpers only mode', function() {\n      var template = CompilerContext.compile('{{foo}}', {knownHelpersOnly: true});\n\n      var result = template({foo: 'bar'});\n      equal(result, 'bar', \"'bar' should === '\" + result);\n    });\n    it('Conditional blocks work in knownHelpers only mode', function() {\n      var template = CompilerContext.compile('{{#foo}}bar{{/foo}}', {knownHelpersOnly: true});\n\n      var result = template({foo: 'baz'});\n      equal(result, 'bar', \"'bar' should === '\" + result);\n    });\n    it('Invert blocks work in knownHelpers only mode', function() {\n      var template = CompilerContext.compile('{{^foo}}bar{{/foo}}', {knownHelpersOnly: true});\n\n      var result = template({foo: false});\n      equal(result, 'bar', \"'bar' should === '\" + result);\n    });\n    it('Functions are bound to the context in knownHelpers only mode', function() {\n      var template = CompilerContext.compile('{{foo}}', {knownHelpersOnly: true});\n      var result = template({foo: function() { return this.bar; }, bar: 'bar'});\n      equal(result, 'bar', \"'bar' should === '\" + result);\n    });\n    it('Unknown helper call in knownHelpers only mode should throw', function() {\n      shouldThrow(function() {\n        CompilerContext.compile('{{typeof hello}}', {knownHelpersOnly: true});\n      }, Error);\n    });\n  });\n\n  describe('blockHelperMissing', function() {\n    it('lambdas are resolved by blockHelperMissing, not handlebars proper', function() {\n      var string = '{{#truthy}}yep{{/truthy}}';\n      var data = { truthy: function() { return true; } };\n      shouldCompileTo(string, data, 'yep');\n    });\n    it('lambdas resolved by blockHelperMissing are bound to the context', function() {\n      var string = '{{#truthy}}yep{{/truthy}}';\n      var boundData = { truthy: function() { return this.truthiness(); }, truthiness: function() { return false; } };\n      shouldCompileTo(string, boundData, '');\n    });\n  });\n\n  describe('name field', function() {\n    var context = {};\n    var helpers = {\n      blockHelperMissing: function() {\n        return 'missing: ' + arguments[arguments.length - 1].name;\n      },\n      helperMissing: function() {\n        return 'helper missing: ' + arguments[arguments.length - 1].name;\n      },\n      helper: function() {\n        return 'ran: ' + arguments[arguments.length - 1].name;\n      }\n    };\n\n    it('should include in ambiguous mustache calls', function() {\n      shouldCompileTo('{{helper}}', [context, helpers], 'ran: helper');\n    });\n    it('should include in helper mustache calls', function() {\n      shouldCompileTo('{{helper 1}}', [context, helpers], 'ran: helper');\n    });\n    it('should include in ambiguous block calls', function() {\n      shouldCompileTo('{{#helper}}{{/helper}}', [context, helpers], 'ran: helper');\n    });\n    it('should include in simple block calls', function() {\n      shouldCompileTo('{{#./helper}}{{/./helper}}', [context, helpers], 'missing: ./helper');\n    });\n    it('should include in helper block calls', function() {\n      shouldCompileTo('{{#helper 1}}{{/helper}}', [context, helpers], 'ran: helper');\n    });\n    it('should include in known helper calls', function() {\n      var template = CompilerContext.compile('{{helper}}', {knownHelpers: {'helper': true}, knownHelpersOnly: true});\n\n      equal(template({}, {helpers: helpers}), 'ran: helper');\n    });\n\n    it('should include full id', function() {\n      shouldCompileTo('{{#foo.helper}}{{/foo.helper}}', [{foo: {}}, helpers], 'missing: foo.helper');\n    });\n\n    it('should include full id if a hash is passed', function() {\n      shouldCompileTo('{{#foo.helper bar=baz}}{{/foo.helper}}', [{foo: {}}, helpers], 'helper missing: foo.helper');\n    });\n  });\n\n  describe('name conflicts', function() {\n    it('helpers take precedence over same-named context properties', function() {\n      var template = CompilerContext.compile('{{goodbye}} {{cruel world}}');\n\n      var helpers = {\n        goodbye: function() {\n          return this.goodbye.toUpperCase();\n        },\n\n        cruel: function(world) {\n          return 'cruel ' + world.toUpperCase();\n        }\n      };\n\n      var context = {\n        goodbye: 'goodbye',\n        world: 'world'\n      };\n\n      var result = template(context, {helpers: helpers});\n      equals(result, 'GOODBYE cruel WORLD', 'Helper executed');\n    });\n\n    it('helpers take precedence over same-named context properties$', function() {\n      var template = CompilerContext.compile('{{#goodbye}} {{cruel world}}{{/goodbye}}');\n\n      var helpers = {\n        goodbye: function(options) {\n          return this.goodbye.toUpperCase() + options.fn(this);\n        },\n\n        cruel: function(world) {\n          return 'cruel ' + world.toUpperCase();\n        }\n      };\n\n      var context = {\n        goodbye: 'goodbye',\n        world: 'world'\n      };\n\n      var result = template(context, {helpers: helpers});\n      equals(result, 'GOODBYE cruel WORLD', 'Helper executed');\n    });\n\n    it('Scoped names take precedence over helpers', function() {\n      var template = CompilerContext.compile('{{this.goodbye}} {{cruel world}} {{cruel this.goodbye}}');\n\n      var helpers = {\n        goodbye: function() {\n          return this.goodbye.toUpperCase();\n        },\n\n        cruel: function(world) {\n          return 'cruel ' + world.toUpperCase();\n        }\n      };\n\n      var context = {\n        goodbye: 'goodbye',\n        world: 'world'\n      };\n\n      var result = template(context, {helpers: helpers});\n      equals(result, 'goodbye cruel WORLD cruel GOODBYE', 'Helper not executed');\n    });\n\n    it('Scoped names take precedence over block helpers', function() {\n      var template = CompilerContext.compile('{{#goodbye}} {{cruel world}}{{/goodbye}} {{this.goodbye}}');\n\n      var helpers = {\n        goodbye: function(options) {\n          return this.goodbye.toUpperCase() + options.fn(this);\n        },\n\n        cruel: function(world) {\n          return 'cruel ' + world.toUpperCase();\n        }\n      };\n\n      var context = {\n        goodbye: 'goodbye',\n        world: 'world'\n      };\n\n      var result = template(context, {helpers: helpers});\n      equals(result, 'GOODBYE cruel WORLD goodbye', 'Helper executed');\n    });\n  });\n\n  describe('block params', function() {\n    it('should take presedence over context values', function() {\n      var hash = {value: 'foo'};\n      var helpers = {\n        goodbyes: function(options) {\n          equals(options.fn.blockParams, 1);\n          return options.fn({value: 'bar'}, {blockParams: [1, 2]});\n        }\n      };\n      shouldCompileTo('{{#goodbyes as |value|}}{{value}}{{/goodbyes}}{{value}}', [hash, helpers], '1foo');\n    });\n    it('should take presedence over helper values', function() {\n      var hash = {};\n      var helpers = {\n        value: function() {\n          return 'foo';\n        },\n        goodbyes: function(options) {\n          equals(options.fn.blockParams, 1);\n          return options.fn({}, {blockParams: [1, 2]});\n        }\n      };\n      shouldCompileTo('{{#goodbyes as |value|}}{{value}}{{/goodbyes}}{{value}}', [hash, helpers], '1foo');\n    });\n    it('should not take presedence over pathed values', function() {\n      var hash = {value: 'bar'};\n      var helpers = {\n        value: function() {\n          return 'foo';\n        },\n        goodbyes: function(options) {\n          equals(options.fn.blockParams, 1);\n          return options.fn(this, {blockParams: [1, 2]});\n        }\n      };\n      shouldCompileTo('{{#goodbyes as |value|}}{{./value}}{{/goodbyes}}{{value}}', [hash, helpers], 'barfoo');\n    });\n    it('should take presednece over parent block params', function() {\n      var hash = {value: 'foo'},\n          value = 1;\n      var helpers = {\n        goodbyes: function(options) {\n          return options.fn({value: 'bar'}, {blockParams: options.fn.blockParams === 1 ? [value++, value++] : undefined});\n        }\n      };\n      shouldCompileTo('{{#goodbyes as |value|}}{{#goodbyes}}{{value}}{{#goodbyes as |value|}}{{value}}{{/goodbyes}}{{/goodbyes}}{{/goodbyes}}{{value}}', [hash, helpers], '13foo');\n    });\n\n    it('should allow block params on chained helpers', function() {\n      var hash = {value: 'foo'};\n      var helpers = {\n        goodbyes: function(options) {\n          equals(options.fn.blockParams, 1);\n          return options.fn({value: 'bar'}, {blockParams: [1, 2]});\n        }\n      };\n      shouldCompileTo('{{#if bar}}{{else goodbyes as |value|}}{{value}}{{/if}}{{value}}', [hash, helpers], '1foo');\n    });\n  });\n});\n", "function shouldMatchTokens(result, tokens) {\n  for (var index = 0; index < result.length; index++) {\n    equals(result[index].name, tokens[index]);\n  }\n}\nfunction shouldBeToken(result, name, text) {\n  equals(result.name, name);\n  equals(result.text, text);\n}\n\ndescribe('Tokenizer', function() {\n  if (!Handlebars.Parser) {\n    return;\n  }\n\n  function tokenize(template) {\n    var parser = Handlebars.Parser,\n        lexer = parser.lexer;\n\n    lexer.setInput(template);\n    var out = [],\n        token;\n\n    while ((token = lexer.lex())) {\n      var result = parser.terminals_[token] || token;\n      if (!result || result === 'EOF' || result === 'INVALID') {\n        break;\n      }\n      out.push({name: result, text: lexer.yytext});\n    }\n\n    return out;\n  }\n\n  it('tokenizes a simple mustache as \"OPEN ID CLOSE\"', function() {\n    var result = tokenize('{{foo}}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'CLOSE']);\n    shouldBeToken(result[1], 'ID', 'foo');\n  });\n\n  it('supports unescaping with &', function() {\n    var result = tokenize('{{&bar}}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'CLOSE']);\n\n    shouldBeToken(result[0], 'OPEN', '{{&');\n    shouldBeToken(result[1], 'ID', 'bar');\n  });\n\n  it('supports unescaping with {{{', function() {\n    var result = tokenize('{{{bar}}}');\n    shouldMatchTokens(result, ['OPEN_UNESCAPED', 'ID', 'CLOSE_UNESCAPED']);\n\n    shouldBeToken(result[1], 'ID', 'bar');\n  });\n\n  it('supports escaping delimiters', function() {\n    var result = tokenize('{{foo}} \\\\{{bar}} {{baz}}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'CLOSE', 'CONTENT', 'CONTENT', 'OPEN', 'ID', 'CLOSE']);\n\n    shouldBeToken(result[3], 'CONTENT', ' ');\n    shouldBeToken(result[4], 'CONTENT', '{{bar}} ');\n  });\n\n  it('supports escaping multiple delimiters', function() {\n    var result = tokenize('{{foo}} \\\\{{bar}} \\\\{{baz}}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'CLOSE', 'CONTENT', 'CONTENT', 'CONTENT']);\n\n    shouldBeToken(result[3], 'CONTENT', ' ');\n    shouldBeToken(result[4], 'CONTENT', '{{bar}} ');\n    shouldBeToken(result[5], 'CONTENT', '{{baz}}');\n  });\n\n  it('supports escaping a triple stash', function() {\n    var result = tokenize('{{foo}} \\\\{{{bar}}} {{baz}}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'CLOSE', 'CONTENT', 'CONTENT', 'OPEN', 'ID', 'CLOSE']);\n\n    shouldBeToken(result[4], 'CONTENT', '{{{bar}}} ');\n  });\n\n  it('supports escaping escape character', function() {\n    var result = tokenize('{{foo}} \\\\\\\\{{bar}} {{baz}}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'CLOSE', 'CONTENT', 'OPEN', 'ID', 'CLOSE', 'CONTENT', 'OPEN', 'ID', 'CLOSE']);\n\n    shouldBeToken(result[3], 'CONTENT', ' \\\\');\n    shouldBeToken(result[5], 'ID', 'bar');\n  });\n\n  it('supports escaping multiple escape characters', function() {\n    var result = tokenize('{{foo}} \\\\\\\\{{bar}} \\\\\\\\{{baz}}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'CLOSE', 'CONTENT', 'OPEN', 'ID', 'CLOSE', 'CONTENT', 'OPEN', 'ID', 'CLOSE']);\n\n    shouldBeToken(result[3], 'CONTENT', ' \\\\');\n    shouldBeToken(result[5], 'ID', 'bar');\n    shouldBeToken(result[7], 'CONTENT', ' \\\\');\n    shouldBeToken(result[9], 'ID', 'baz');\n  });\n\n  it('supports escaped mustaches after escaped escape characters', function() {\n    var result = tokenize('{{foo}} \\\\\\\\{{bar}} \\\\{{baz}}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'CLOSE', 'CONTENT', 'OPEN', 'ID', 'CLOSE', 'CONTENT', 'CONTENT', 'CONTENT']);\n\n    shouldBeToken(result[3], 'CONTENT', ' \\\\');\n    shouldBeToken(result[4], 'OPEN', '{{');\n    shouldBeToken(result[5], 'ID', 'bar');\n    shouldBeToken(result[7], 'CONTENT', ' ');\n    shouldBeToken(result[8], 'CONTENT', '{{baz}}');\n  });\n\n  it('supports escaped escape characters after escaped mustaches', function() {\n    var result = tokenize('{{foo}} \\\\{{bar}} \\\\\\\\{{baz}}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'CLOSE', 'CONTENT', 'CONTENT', 'CONTENT', 'OPEN', 'ID', 'CLOSE']);\n\n    shouldBeToken(result[4], 'CONTENT', '{{bar}} ');\n    shouldBeToken(result[5], 'CONTENT', '\\\\');\n    shouldBeToken(result[6], 'OPEN', '{{');\n    shouldBeToken(result[7], 'ID', 'baz');\n  });\n\n  it('supports escaped escape character on a triple stash', function() {\n    var result = tokenize('{{foo}} \\\\\\\\{{{bar}}} {{baz}}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'CLOSE', 'CONTENT', 'OPEN_UNESCAPED', 'ID', 'CLOSE_UNESCAPED', 'CONTENT', 'OPEN', 'ID', 'CLOSE']);\n\n    shouldBeToken(result[3], 'CONTENT', ' \\\\');\n    shouldBeToken(result[5], 'ID', 'bar');\n  });\n\n  it('tokenizes a simple path', function() {\n    var result = tokenize('{{foo/bar}}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'SEP', 'ID', 'CLOSE']);\n  });\n\n  it('allows dot notation', function() {\n    var result = tokenize('{{foo.bar}}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'SEP', 'ID', 'CLOSE']);\n\n    shouldMatchTokens(tokenize('{{foo.bar.baz}}'), ['OPEN', 'ID', 'SEP', 'ID', 'SEP', 'ID', 'CLOSE']);\n  });\n\n  it('allows path literals with []', function() {\n    var result = tokenize('{{foo.[bar]}}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'SEP', 'ID', 'CLOSE']);\n  });\n\n  it('allows multiple path literals on a line with []', function() {\n    var result = tokenize('{{foo.[bar]}}{{foo.[baz]}}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'SEP', 'ID', 'CLOSE', 'OPEN', 'ID', 'SEP', 'ID', 'CLOSE']);\n  });\n\n  it('allows escaped literals in []', function() {\n    var result = tokenize('{{foo.[bar\\\\]]}}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'SEP', 'ID', 'CLOSE']);\n  });\n\n  it('tokenizes {{.}} as OPEN ID CLOSE', function() {\n    var result = tokenize('{{.}}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'CLOSE']);\n  });\n\n  it('tokenizes a path as \"OPEN (ID SEP)* ID CLOSE\"', function() {\n    var result = tokenize('{{../foo/bar}}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'SEP', 'ID', 'SEP', 'ID', 'CLOSE']);\n    shouldBeToken(result[1], 'ID', '..');\n  });\n\n  it('tokenizes a path with .. as a parent path', function() {\n    var result = tokenize('{{../foo.bar}}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'SEP', 'ID', 'SEP', 'ID', 'CLOSE']);\n    shouldBeToken(result[1], 'ID', '..');\n  });\n\n  it('tokenizes a path with this/foo as OPEN ID SEP ID CLOSE', function() {\n    var result = tokenize('{{this/foo}}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'SEP', 'ID', 'CLOSE']);\n    shouldBeToken(result[1], 'ID', 'this');\n    shouldBeToken(result[3], 'ID', 'foo');\n  });\n\n  it('tokenizes a simple mustache with spaces as \"OPEN ID CLOSE\"', function() {\n    var result = tokenize('{{  foo  }}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'CLOSE']);\n    shouldBeToken(result[1], 'ID', 'foo');\n  });\n\n  it('tokenizes a simple mustache with line breaks as \"OPEN ID ID CLOSE\"', function() {\n    var result = tokenize('{{  foo  \\n   bar }}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'ID', 'CLOSE']);\n    shouldBeToken(result[1], 'ID', 'foo');\n  });\n\n  it('tokenizes raw content as \"CONTENT\"', function() {\n    var result = tokenize('foo {{ bar }} baz');\n    shouldMatchTokens(result, ['CONTENT', 'OPEN', 'ID', 'CLOSE', 'CONTENT']);\n    shouldBeToken(result[0], 'CONTENT', 'foo ');\n    shouldBeToken(result[4], 'CONTENT', ' baz');\n  });\n\n  it('tokenizes a partial as \"OPEN_PARTIAL ID CLOSE\"', function() {\n    var result = tokenize('{{> foo}}');\n    shouldMatchTokens(result, ['OPEN_PARTIAL', 'ID', 'CLOSE']);\n  });\n\n  it('tokenizes a partial with context as \"OPEN_PARTIAL ID ID CLOSE\"', function() {\n    var result = tokenize('{{> foo bar }}');\n    shouldMatchTokens(result, ['OPEN_PARTIAL', 'ID', 'ID', 'CLOSE']);\n  });\n\n  it('tokenizes a partial without spaces as \"OPEN_PARTIAL ID CLOSE\"', function() {\n    var result = tokenize('{{>foo}}');\n    shouldMatchTokens(result, ['OPEN_PARTIAL', 'ID', 'CLOSE']);\n  });\n\n  it('tokenizes a partial space at the }); as \"OPEN_PARTIAL ID CLOSE\"', function() {\n    var result = tokenize('{{>foo  }}');\n    shouldMatchTokens(result, ['OPEN_PARTIAL', 'ID', 'CLOSE']);\n  });\n\n  it('tokenizes a partial space at the }); as \"OPEN_PARTIAL ID CLOSE\"', function() {\n    var result = tokenize('{{>foo/bar.baz  }}');\n    shouldMatchTokens(result, ['OPEN_PARTIAL', 'ID', 'SEP', 'ID', 'SEP', 'ID', 'CLOSE']);\n  });\n\n  it('tokenizes partial block declarations', function() {\n    var result = tokenize('{{#> foo}}');\n    shouldMatchTokens(result, ['OPEN_PARTIAL_BLOCK', 'ID', 'CLOSE']);\n  });\n  it('tokenizes a comment as \"COMMENT\"', function() {\n    var result = tokenize('foo {{! this is a comment }} bar {{ baz }}');\n    shouldMatchTokens(result, ['CONTENT', 'COMMENT', 'CONTENT', 'OPEN', 'ID', 'CLOSE']);\n    shouldBeToken(result[1], 'COMMENT', '{{! this is a comment }}');\n  });\n\n  it('tokenizes a block comment as \"COMMENT\"', function() {\n    var result = tokenize('foo {{!-- this is a {{comment}} --}} bar {{ baz }}');\n    shouldMatchTokens(result, ['CONTENT', 'COMMENT', 'CONTENT', 'OPEN', 'ID', 'CLOSE']);\n    shouldBeToken(result[1], 'COMMENT', '{{!-- this is a {{comment}} --}}');\n  });\n\n  it('tokenizes a block comment with whitespace as \"COMMENT\"', function() {\n    var result = tokenize('foo {{!-- this is a\\n{{comment}}\\n--}} bar {{ baz }}');\n    shouldMatchTokens(result, ['CONTENT', 'COMMENT', 'CONTENT', 'OPEN', 'ID', 'CLOSE']);\n    shouldBeToken(result[1], 'COMMENT', '{{!-- this is a\\n{{comment}}\\n--}}');\n  });\n\n  it('tokenizes open and closing blocks as OPEN_BLOCK, ID, CLOSE ..., OPEN_ENDBLOCK ID CLOSE', function() {\n    var result = tokenize('{{#foo}}content{{/foo}}');\n    shouldMatchTokens(result, ['OPEN_BLOCK', 'ID', 'CLOSE', 'CONTENT', 'OPEN_ENDBLOCK', 'ID', 'CLOSE']);\n  });\n\n  it('tokenizes directives', function() {\n    shouldMatchTokens(\n        tokenize('{{#*foo}}content{{/foo}}'),\n        ['OPEN_BLOCK', 'ID', 'CLOSE', 'CONTENT', 'OPEN_ENDBLOCK', 'ID', 'CLOSE']);\n    shouldMatchTokens(\n        tokenize('{{*foo}}'),\n        ['OPEN', 'ID', 'CLOSE']);\n  });\n\n  it('tokenizes inverse sections as \"INVERSE\"', function() {\n    shouldMatchTokens(tokenize('{{^}}'), ['INVERSE']);\n    shouldMatchTokens(tokenize('{{else}}'), ['INVERSE']);\n    shouldMatchTokens(tokenize('{{ else }}'), ['INVERSE']);\n  });\n\n  it('tokenizes inverse sections with ID as \"OPEN_INVERSE ID CLOSE\"', function() {\n    var result = tokenize('{{^foo}}');\n    shouldMatchTokens(result, ['OPEN_INVERSE', 'ID', 'CLOSE']);\n    shouldBeToken(result[1], 'ID', 'foo');\n  });\n\n  it('tokenizes inverse sections with ID and spaces as \"OPEN_INVERSE ID CLOSE\"', function() {\n    var result = tokenize('{{^ foo  }}');\n    shouldMatchTokens(result, ['OPEN_INVERSE', 'ID', 'CLOSE']);\n    shouldBeToken(result[1], 'ID', 'foo');\n  });\n\n  it('tokenizes mustaches with params as \"OPEN ID ID ID CLOSE\"', function() {\n    var result = tokenize('{{ foo bar baz }}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'ID', 'ID', 'CLOSE']);\n    shouldBeToken(result[1], 'ID', 'foo');\n    shouldBeToken(result[2], 'ID', 'bar');\n    shouldBeToken(result[3], 'ID', 'baz');\n  });\n\n  it('tokenizes mustaches with String params as \"OPEN ID ID STRING CLOSE\"', function() {\n    var result = tokenize('{{ foo bar \"baz\" }}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'ID', 'STRING', 'CLOSE']);\n    shouldBeToken(result[3], 'STRING', 'baz');\n  });\n\n  it('tokenizes mustaches with String params using single quotes as \"OPEN ID ID STRING CLOSE\"', function() {\n    var result = tokenize(\"{{ foo bar 'baz' }}\");\n    shouldMatchTokens(result, ['OPEN', 'ID', 'ID', 'STRING', 'CLOSE']);\n    shouldBeToken(result[3], 'STRING', 'baz');\n  });\n\n  it('tokenizes String params with spaces inside as \"STRING\"', function() {\n    var result = tokenize('{{ foo bar \"baz bat\" }}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'ID', 'STRING', 'CLOSE']);\n    shouldBeToken(result[3], 'STRING', 'baz bat');\n  });\n\n  it('tokenizes String params with escapes quotes as STRING', function() {\n    var result = tokenize('{{ foo \"bar\\\\\"baz\" }}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'STRING', 'CLOSE']);\n    shouldBeToken(result[2], 'STRING', 'bar\"baz');\n  });\n\n  it('tokenizes String params using single quotes with escapes quotes as STRING', function() {\n    var result = tokenize(\"{{ foo 'bar\\\\'baz' }}\");\n    shouldMatchTokens(result, ['OPEN', 'ID', 'STRING', 'CLOSE']);\n    shouldBeToken(result[2], 'STRING', \"bar'baz\");\n  });\n\n  it('tokenizes numbers', function() {\n    var result = tokenize('{{ foo 1 }}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'NUMBER', 'CLOSE']);\n    shouldBeToken(result[2], 'NUMBER', '1');\n\n    result = tokenize('{{ foo 1.1 }}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'NUMBER', 'CLOSE']);\n    shouldBeToken(result[2], 'NUMBER', '1.1');\n\n    result = tokenize('{{ foo -1 }}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'NUMBER', 'CLOSE']);\n    shouldBeToken(result[2], 'NUMBER', '-1');\n\n    result = tokenize('{{ foo -1.1 }}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'NUMBER', 'CLOSE']);\n    shouldBeToken(result[2], 'NUMBER', '-1.1');\n  });\n\n  it('tokenizes booleans', function() {\n    var result = tokenize('{{ foo true }}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'BOOLEAN', 'CLOSE']);\n    shouldBeToken(result[2], 'BOOLEAN', 'true');\n\n    result = tokenize('{{ foo false }}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'BOOLEAN', 'CLOSE']);\n    shouldBeToken(result[2], 'BOOLEAN', 'false');\n  });\n\n  it('tokenizes undefined and null', function() {\n    var result = tokenize('{{ foo undefined null }}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'UNDEFINED', 'NULL', 'CLOSE']);\n    shouldBeToken(result[2], 'UNDEFINED', 'undefined');\n    shouldBeToken(result[3], 'NULL', 'null');\n  });\n\n  it('tokenizes hash arguments', function() {\n    var result = tokenize('{{ foo bar=baz }}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'ID', 'EQUALS', 'ID', 'CLOSE']);\n\n    result = tokenize('{{ foo bar baz=bat }}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'ID', 'ID', 'EQUALS', 'ID', 'CLOSE']);\n\n    result = tokenize('{{ foo bar baz=1 }}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'ID', 'ID', 'EQUALS', 'NUMBER', 'CLOSE']);\n\n    result = tokenize('{{ foo bar baz=true }}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'ID', 'ID', 'EQUALS', 'BOOLEAN', 'CLOSE']);\n\n    result = tokenize('{{ foo bar baz=false }}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'ID', 'ID', 'EQUALS', 'BOOLEAN', 'CLOSE']);\n\n    result = tokenize('{{ foo bar\\n  baz=bat }}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'ID', 'ID', 'EQUALS', 'ID', 'CLOSE']);\n\n    result = tokenize('{{ foo bar baz=\"bat\" }}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'ID', 'ID', 'EQUALS', 'STRING', 'CLOSE']);\n\n    result = tokenize('{{ foo bar baz=\"bat\" bam=wot }}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'ID', 'ID', 'EQUALS', 'STRING', 'ID', 'EQUALS', 'ID', 'CLOSE']);\n\n    result = tokenize('{{foo omg bar=baz bat=\"bam\"}}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'ID', 'ID', 'EQUALS', 'ID', 'ID', 'EQUALS', 'STRING', 'CLOSE']);\n    shouldBeToken(result[2], 'ID', 'omg');\n  });\n\n  it('tokenizes special @ identifiers', function() {\n    var result = tokenize('{{ @foo }}');\n    shouldMatchTokens(result, ['OPEN', 'DATA', 'ID', 'CLOSE']);\n    shouldBeToken(result[2], 'ID', 'foo');\n\n    result = tokenize('{{ foo @bar }}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'DATA', 'ID', 'CLOSE']);\n    shouldBeToken(result[3], 'ID', 'bar');\n\n    result = tokenize('{{ foo bar=@baz }}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'ID', 'EQUALS', 'DATA', 'ID', 'CLOSE']);\n    shouldBeToken(result[5], 'ID', 'baz');\n  });\n\n  it('does not time out in a mustache with a single } followed by EOF', function() {\n    shouldMatchTokens(tokenize('{{foo}'), ['OPEN', 'ID']);\n  });\n\n  it('does not time out in a mustache when invalid ID characters are used', function() {\n    shouldMatchTokens(tokenize('{{foo & }}'), ['OPEN', 'ID']);\n  });\n\n  it('tokenizes subexpressions', function() {\n    var result = tokenize('{{foo (bar)}}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'OPEN_SEXPR', 'ID', 'CLOSE_SEXPR', 'CLOSE']);\n    shouldBeToken(result[1], 'ID', 'foo');\n    shouldBeToken(result[3], 'ID', 'bar');\n\n    result = tokenize('{{foo (a-x b-y)}}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'OPEN_SEXPR', 'ID', 'ID', 'CLOSE_SEXPR', 'CLOSE']);\n    shouldBeToken(result[1], 'ID', 'foo');\n    shouldBeToken(result[3], 'ID', 'a-x');\n    shouldBeToken(result[4], 'ID', 'b-y');\n  });\n\n  it('tokenizes nested subexpressions', function() {\n    var result = tokenize('{{foo (bar (lol rofl)) (baz)}}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'OPEN_SEXPR', 'ID', 'OPEN_SEXPR', 'ID', 'ID', 'CLOSE_SEXPR', 'CLOSE_SEXPR', 'OPEN_SEXPR', 'ID', 'CLOSE_SEXPR', 'CLOSE']);\n    shouldBeToken(result[3], 'ID', 'bar');\n    shouldBeToken(result[5], 'ID', 'lol');\n    shouldBeToken(result[6], 'ID', 'rofl');\n    shouldBeToken(result[10], 'ID', 'baz');\n  });\n\n  it('tokenizes nested subexpressions: literals', function() {\n    var result = tokenize(\"{{foo (bar (lol true) false) (baz 1) (blah 'b') (blorg \\\"c\\\")}}\");\n    shouldMatchTokens(result, ['OPEN', 'ID', 'OPEN_SEXPR', 'ID', 'OPEN_SEXPR', 'ID', 'BOOLEAN', 'CLOSE_SEXPR', 'BOOLEAN', 'CLOSE_SEXPR', 'OPEN_SEXPR', 'ID', 'NUMBER', 'CLOSE_SEXPR', 'OPEN_SEXPR', 'ID', 'STRING', 'CLOSE_SEXPR', 'OPEN_SEXPR', 'ID', 'STRING', 'CLOSE_SEXPR', 'CLOSE']);\n  });\n\n  it('tokenizes block params', function() {\n    var result = tokenize('{{#foo as |bar|}}');\n    shouldMatchTokens(result, ['OPEN_BLOCK', 'ID', 'OPEN_BLOCK_PARAMS', 'ID', 'CLOSE_BLOCK_PARAMS', 'CLOSE']);\n\n    result = tokenize('{{#foo as |bar baz|}}');\n    shouldMatchTokens(result, ['OPEN_BLOCK', 'ID', 'OPEN_BLOCK_PARAMS', 'ID', 'ID', 'CLOSE_BLOCK_PARAMS', 'CLOSE']);\n\n    result = tokenize('{{#foo as | bar baz |}}');\n    shouldMatchTokens(result, ['OPEN_BLOCK', 'ID', 'OPEN_BLOCK_PARAMS', 'ID', 'ID', 'CLOSE_BLOCK_PARAMS', 'CLOSE']);\n\n    result = tokenize('{{#foo as as | bar baz |}}');\n    shouldMatchTokens(result, ['OPEN_BLOCK', 'ID', 'ID', 'OPEN_BLOCK_PARAMS', 'ID', 'ID', 'CLOSE_BLOCK_PARAMS', 'CLOSE']);\n\n    result = tokenize('{{else foo as |bar baz|}}');\n    shouldMatchTokens(result, ['OPEN_INVERSE_CHAIN', 'ID', 'OPEN_BLOCK_PARAMS', 'ID', 'ID', 'CLOSE_BLOCK_PARAMS', 'CLOSE']);\n  });\n});\n", "\n%x mu emu com raw\n\n%{\n\nfunction strip(start, end) {\n  return yytext = yytext.substring(start, yyleng - end + start);\n}\n\n%}\n\nLEFT_STRIP    \"~\"\nRIGHT_STRIP   \"~\"\n\nLOOKAHEAD           [=~}\\s\\/.)|]\nLITERAL_LOOKAHEAD   [~}\\s)]\n\n/*\nID is the inverse of control characters.\nControl characters ranges:\n  [\\s]          Whitespace\n  [!\"#%-,\\./]   !, \", #, %, &, ', (, ), *, +, ,, ., /,  Exceptions in range: $, -\n  [;->@]        ;, <, =, >, @,                          Exceptions in range: :, ?\n  [\\[-\\^`]      [, \\, ], ^, `,                          Exceptions in range: _\n  [\\{-~]        {, |, }, ~\n*/\nID    [^\\s!\"#%-,\\.\\/;->@\\[-\\^`\\{-~]+/{LOOKAHEAD}\n\n%%\n\n[^\\x00]*?/(\"{{\")                {\n                                   if(yytext.slice(-2) === \"\\\\\\\\\") {\n                                     strip(0,1);\n                                     this.begin(\"mu\");\n                                   } else if(yytext.slice(-1) === \"\\\\\") {\n                                     strip(0,1);\n                                     this.begin(\"emu\");\n                                   } else {\n                                     this.begin(\"mu\");\n                                   }\n                                   if(yytext) return 'CONTENT';\n                                 }\n\n[^\\x00]+                         return 'CONTENT';\n\n// marks CONTENT up to the next mustache or escaped mustache\n<emu>[^\\x00]{2,}?/(\"{{\"|\"\\\\{{\"|\"\\\\\\\\{{\"|<<EOF>>) {\n                                   this.popState();\n                                   return 'CONTENT';\n                                 }\n\n// nested raw block will create stacked 'raw' condition\n<raw>\"{{{{\"/[^/]                 this.begin('raw'); return 'CONTENT';\n<raw>\"{{{{/\"[^\\s!\"#%-,\\.\\/;->@\\[-\\^`\\{-~]+/[=}\\s\\/.]\"}}}}\" {\n                                  this.popState();\n                                  // Should be using `this.topState()` below, but it currently\n                                  // returns the second top instead of the first top. Opened an\n                                  // issue about it at https://github.com/zaach/jison/issues/291\n                                  if (this.conditionStack[this.conditionStack.length-1] === 'raw') {\n                                    return 'CONTENT';\n                                  } else {\n                                    strip(5, 9);\n                                    return 'END_RAW_BLOCK';\n                                  }\n                                 }\n<raw>[^\\x00]+/(\"{{{{\")          { return 'CONTENT'; }\n\n<com>[\\s\\S]*?\"--\"{RIGHT_STRIP}?\"}}\" {\n  this.popState();\n  return 'COMMENT';\n}\n\n<mu>\"(\"                          return 'OPEN_SEXPR';\n<mu>\")\"                          return 'CLOSE_SEXPR';\n\n<mu>\"{{{{\"                       { return 'OPEN_RAW_BLOCK'; }\n<mu>\"}}}}\"                       {\n                                  this.popState();\n                                  this.begin('raw');\n                                  return 'CLOSE_RAW_BLOCK';\n                                 }\n<mu>\"{{\"{LEFT_STRIP}?\">\"         return 'OPEN_PARTIAL';\n<mu>\"{{\"{LEFT_STRIP}?\"#>\"        return 'OPEN_PARTIAL_BLOCK';\n<mu>\"{{\"{LEFT_STRIP}?\"#\"\"*\"?     return 'OPEN_BLOCK';\n<mu>\"{{\"{LEFT_STRIP}?\"/\"         return 'OPEN_ENDBLOCK';\n<mu>\"{{\"{LEFT_STRIP}?\"^\"\\s*{RIGHT_STRIP}?\"}}\"        this.popState(); return 'INVERSE';\n<mu>\"{{\"{LEFT_STRIP}?\\s*\"else\"\\s*{RIGHT_STRIP}?\"}}\"  this.popState(); return 'INVERSE';\n<mu>\"{{\"{LEFT_STRIP}?\"^\"         return 'OPEN_INVERSE';\n<mu>\"{{\"{LEFT_STRIP}?\\s*\"else\"   return 'OPEN_INVERSE_CHAIN';\n<mu>\"{{\"{LEFT_STRIP}?\"{\"         return 'OPEN_UNESCAPED';\n<mu>\"{{\"{LEFT_STRIP}?\"&\"         return 'OPEN';\n<mu>\"{{\"{LEFT_STRIP}?\"!--\" {\n  this.unput(yytext);\n  this.popState();\n  this.begin('com');\n}\n<mu>\"{{\"{LEFT_STRIP}?\"!\"[\\s\\S]*?\"}}\" {\n  this.popState();\n  return 'COMMENT';\n}\n<mu>\"{{\"{LEFT_STRIP}?\"*\"?        return 'OPEN';\n\n<mu>\"=\"                          return 'EQUALS';\n<mu>\"..\"                         return 'ID';\n<mu>\".\"/{LOOKAHEAD}              return 'ID';\n<mu>[\\/.]                        return 'SEP';\n<mu>\\s+                          // ignore whitespace\n<mu>\"}\"{RIGHT_STRIP}?\"}}\"        this.popState(); return 'CLOSE_UNESCAPED';\n<mu>{RIGHT_STRIP}?\"}}\"           this.popState(); return 'CLOSE';\n<mu>'\"'(\"\\\\\"[\"]|[^\"])*'\"'        yytext = strip(1,2).replace(/\\\\\"/g,'\"'); return 'STRING';\n<mu>\"'\"(\"\\\\\"[']|[^'])*\"'\"        yytext = strip(1,2).replace(/\\\\'/g,\"'\"); return 'STRING';\n<mu>\"@\"                          return 'DATA';\n<mu>\"true\"/{LITERAL_LOOKAHEAD}   return 'BOOLEAN';\n<mu>\"false\"/{LITERAL_LOOKAHEAD}  return 'BOOLEAN';\n<mu>\"undefined\"/{LITERAL_LOOKAHEAD} return 'UNDEFINED';\n<mu>\"null\"/{LITERAL_LOOKAHEAD}   return 'NULL';\n<mu>\\-?[0-9]+(?:\\.[0-9]+)?/{LITERAL_LOOKAHEAD} return 'NUMBER';\n<mu>\"as\"\\s+\"|\"                   return 'OPEN_BLOCK_PARAMS';\n<mu>\"|\"                          return 'CLOSE_BLOCK_PARAMS';\n\n<mu>{ID}                         return 'ID';\n\n<mu>'['('\\\\]'|[^\\]])*']'         yytext = yytext.replace(/\\\\([\\\\\\]])/g,'$1'); return 'ID';\n<mu>.                            return 'INVALID';\n\n<INITIAL,mu><<EOF>>              return 'EOF';\n"], "fixing_code": ["describe('helpers', function() {\n  it('helper with complex lookup$', function() {\n    var string = '{{#goodbyes}}{{{link ../prefix}}}{{/goodbyes}}';\n    var hash = {prefix: '/root', goodbyes: [{text: 'Goodbye', url: 'goodbye'}]};\n    var helpers = {link: function(prefix) {\n      return '<a href=\"' + prefix + '/' + this.url + '\">' + this.text + '</a>';\n    }};\n    shouldCompileTo(string, [hash, helpers], '<a href=\"/root/goodbye\">Goodbye</a>');\n  });\n\n  it('helper for raw block gets raw content', function() {\n    var string = '{{{{raw}}}} {{test}} {{{{/raw}}}}';\n    var hash = { test: 'hello' };\n    var helpers = { raw: function(options) {\n        return options.fn();\n    } };\n    shouldCompileTo(string, [hash, helpers], ' {{test}} ',\n                    'raw block helper gets raw content');\n  });\n\n  it('helper for raw block gets parameters', function() {\n    var string = '{{{{raw 1 2 3}}}} {{test}} {{{{/raw}}}}';\n    var hash = { test: 'hello' };\n    var helpers = { raw: function(a, b, c, options) {\n        return options.fn() + a + b + c;\n    } };\n    shouldCompileTo(string, [hash, helpers], ' {{test}} 123',\n                    'raw block helper gets raw content');\n  });\n\n  describe('raw block parsing (with identity helper-function)', function() {\n\n    function runWithIdentityHelper(template, expected) {\n      var helpers = {\n        identity: function(options) {\n          return options.fn();\n        }\n      };\n      shouldCompileTo(template, [{}, helpers], expected);\n    }\n\n    it('helper for nested raw block gets raw content', function() {\n      runWithIdentityHelper('{{{{identity}}}} {{{{b}}}} {{{{/b}}}} {{{{/identity}}}}', ' {{{{b}}}} {{{{/b}}}} ');\n    });\n\n    it('helper for nested raw block works with empty content', function() {\n      runWithIdentityHelper('{{{{identity}}}}{{{{/identity}}}}', '');\n    });\n\n    xit('helper for nested raw block works if nested raw blocks are broken', function() {\n      // This test was introduced in 4.4.4, but it was not the actual problem that lead to the patch release\n      // The test is deactivated, because in 3.x this template cases an exception and it also does not work in 4.4.3\n      // If anyone can make this template work without breaking everything else, then go for it,\n      // but for now, this is just a known bug, that will be documented.\n      runWithIdentityHelper('{{{{identity}}}} {{{{a}}}} {{{{ {{{{/ }}}} }}}} {{{{/identity}}}}', ' {{{{a}}}} {{{{ {{{{/ }}}} }}}} ');\n    });\n\n    it('helper for nested raw block closes after first matching close', function() {\n      runWithIdentityHelper('{{{{identity}}}}abc{{{{/identity}}}} {{{{identity}}}}abc{{{{/identity}}}}', 'abc abc');\n    });\n\n    it('helper for nested raw block throw exception when with missing closing braces', function() {\n      var string = '{{{{a}}}} {{{{/a';\n      shouldThrow(function() {\n        Handlebars.compile(string)();\n      });\n    });\n  });\n\n  it('helper block with identical context', function() {\n    var string = '{{#goodbyes}}{{name}}{{/goodbyes}}';\n    var hash = {name: 'Alan'};\n    var helpers = {goodbyes: function(options) {\n      var out = '';\n      var byes = ['Goodbye', 'goodbye', 'GOODBYE'];\n      for (var i = 0, j = byes.length; i < j; i++) {\n        out += byes[i] + ' ' + options.fn(this) + '! ';\n      }\n      return out;\n    }};\n    shouldCompileTo(string, [hash, helpers], 'Goodbye Alan! goodbye Alan! GOODBYE Alan! ');\n  });\n  it('helper block with complex lookup expression', function() {\n    var string = '{{#goodbyes}}{{../name}}{{/goodbyes}}';\n    var hash = {name: 'Alan'};\n    var helpers = {goodbyes: function(options) {\n      var out = '';\n      var byes = ['Goodbye', 'goodbye', 'GOODBYE'];\n      for (var i = 0, j = byes.length; i < j; i++) {\n        out += byes[i] + ' ' + options.fn({}) + '! ';\n      }\n      return out;\n    }};\n    shouldCompileTo(string, [hash, helpers], 'Goodbye Alan! goodbye Alan! GOODBYE Alan! ');\n  });\n\n  it('helper with complex lookup and nested template', function() {\n    var string = '{{#goodbyes}}{{#link ../prefix}}{{text}}{{/link}}{{/goodbyes}}';\n    var hash = {prefix: '/root', goodbyes: [{text: 'Goodbye', url: 'goodbye'}]};\n    var helpers = {link: function(prefix, options) {\n        return '<a href=\"' + prefix + '/' + this.url + '\">' + options.fn(this) + '</a>';\n    }};\n    shouldCompileToWithPartials(string, [hash, helpers], false, '<a href=\"/root/goodbye\">Goodbye</a>');\n  });\n\n  it('helper with complex lookup and nested template in VM+Compiler', function() {\n    var string = '{{#goodbyes}}{{#link ../prefix}}{{text}}{{/link}}{{/goodbyes}}';\n    var hash = {prefix: '/root', goodbyes: [{text: 'Goodbye', url: 'goodbye'}]};\n    var helpers = {link: function(prefix, options) {\n        return '<a href=\"' + prefix + '/' + this.url + '\">' + options.fn(this) + '</a>';\n    }};\n    shouldCompileToWithPartials(string, [hash, helpers], true, '<a href=\"/root/goodbye\">Goodbye</a>');\n  });\n  it('helper returning undefined value', function() {\n    shouldCompileTo(' {{nothere}}', [{}, {nothere: function() {}}], ' ');\n    shouldCompileTo(' {{#nothere}}{{/nothere}}', [{}, {nothere: function() {}}], ' ');\n  });\n\n  it('block helper', function() {\n    var string = '{{#goodbyes}}{{text}}! {{/goodbyes}}cruel {{world}}!';\n    var template = CompilerContext.compile(string);\n\n    var result = template({world: 'world'}, { helpers: {goodbyes: function(options) { return options.fn({text: 'GOODBYE'}); }}});\n    equal(result, 'GOODBYE! cruel world!', 'Block helper executed');\n  });\n\n  it('block helper staying in the same context', function() {\n    var string = '{{#form}}<p>{{name}}</p>{{/form}}';\n    var template = CompilerContext.compile(string);\n\n    var result = template({name: 'Yehuda'}, {helpers: {form: function(options) { return '<form>' + options.fn(this) + '</form>'; } }});\n    equal(result, '<form><p>Yehuda</p></form>', 'Block helper executed with current context');\n  });\n\n  it('block helper should have context in this', function() {\n    var source = '<ul>{{#people}}<li>{{#link}}{{name}}{{/link}}</li>{{/people}}</ul>';\n    function link(options) {\n      return '<a href=\"/people/' + this.id + '\">' + options.fn(this) + '</a>';\n    }\n    var data = { 'people': [\n      { 'name': 'Alan', 'id': 1 },\n      { 'name': 'Yehuda', 'id': 2 }\n    ]};\n\n    shouldCompileTo(source, [data, {link: link}], '<ul><li><a href=\"/people/1\">Alan</a></li><li><a href=\"/people/2\">Yehuda</a></li></ul>');\n  });\n\n  it('block helper for undefined value', function() {\n    shouldCompileTo(\"{{#empty}}shouldn't render{{/empty}}\", {}, '');\n  });\n\n  it('block helper passing a new context', function() {\n    var string = '{{#form yehuda}}<p>{{name}}</p>{{/form}}';\n    var template = CompilerContext.compile(string);\n\n    var result = template({yehuda: {name: 'Yehuda'}}, { helpers: {form: function(context, options) { return '<form>' + options.fn(context) + '</form>'; }}});\n    equal(result, '<form><p>Yehuda</p></form>', 'Context variable resolved');\n  });\n\n  it('block helper passing a complex path context', function() {\n    var string = '{{#form yehuda/cat}}<p>{{name}}</p>{{/form}}';\n    var template = CompilerContext.compile(string);\n\n    var result = template({yehuda: {name: 'Yehuda', cat: {name: 'Harold'}}}, { helpers: {form: function(context, options) { return '<form>' + options.fn(context) + '</form>'; }}});\n    equal(result, '<form><p>Harold</p></form>', 'Complex path variable resolved');\n  });\n\n  it('nested block helpers', function() {\n    var string = '{{#form yehuda}}<p>{{name}}</p>{{#link}}Hello{{/link}}{{/form}}';\n    var template = CompilerContext.compile(string);\n\n    var result = template({\n      yehuda: {name: 'Yehuda' }\n    }, {\n      helpers: {\n        link: function(options) { return '<a href=\"' + this.name + '\">' + options.fn(this) + '</a>'; },\n        form: function(context, options) { return '<form>' + options.fn(context) + '</form>'; }\n      }\n    });\n    equal(result, '<form><p>Yehuda</p><a href=\"Yehuda\">Hello</a></form>', 'Both blocks executed');\n  });\n\n  it('block helper inverted sections', function() {\n    var string = '{{#list people}}{{name}}{{^}}<em>Nobody\\'s here</em>{{/list}}';\n    function list(context, options) {\n      if (context.length > 0) {\n        var out = '<ul>';\n        for (var i = 0, j = context.length; i < j; i++) {\n          out += '<li>';\n          out += options.fn(context[i]);\n          out += '</li>';\n        }\n        out += '</ul>';\n        return out;\n      } else {\n        return '<p>' + options.inverse(this) + '</p>';\n      }\n    }\n\n    var hash = {people: [{name: 'Alan'}, {name: 'Yehuda'}]};\n    var empty = {people: []};\n    var rootMessage = {\n      people: [],\n      message: 'Nobody\\'s here'\n    };\n\n    var messageString = '{{#list people}}Hello{{^}}{{message}}{{/list}}';\n\n    // the meaning here may be kind of hard to catch, but list.not is always called,\n    // so we should see the output of both\n    shouldCompileTo(string, [hash, { list: list }], '<ul><li>Alan</li><li>Yehuda</li></ul>', 'an inverse wrapper is passed in as a new context');\n    shouldCompileTo(string, [empty, { list: list }], '<p><em>Nobody\\'s here</em></p>', 'an inverse wrapper can be optionally called');\n    shouldCompileTo(messageString, [rootMessage, { list: list }], '<p>Nobody&#x27;s here</p>', 'the context of an inverse is the parent of the block');\n  });\n\n  it('pathed lambas with parameters', function() {\n    var hash = {\n      helper: function() {\n        return 'winning';\n      }\n    };\n    hash.hash = hash;\n    var helpers = {\n      './helper': function() {\n        return 'fail';\n      }\n    };\n    shouldCompileTo('{{./helper 1}}', [hash, helpers], 'winning');\n    shouldCompileTo('{{hash/helper 1}}', [hash, helpers], 'winning');\n  });\n\n  describe('helpers hash', function() {\n    it('providing a helpers hash', function() {\n      shouldCompileTo('Goodbye {{cruel}} {{world}}!', [{cruel: 'cruel'}, {world: function() { return 'world'; }}], 'Goodbye cruel world!',\n                      'helpers hash is available');\n\n      shouldCompileTo('Goodbye {{#iter}}{{cruel}} {{world}}{{/iter}}!', [{iter: [{cruel: 'cruel'}]}, {world: function() { return 'world'; }}],\n                      'Goodbye cruel world!', 'helpers hash is available inside other blocks');\n    });\n\n    it('in cases of conflict, helpers win', function() {\n      shouldCompileTo('{{{lookup}}}', [{lookup: 'Explicit'}, {lookup: function() { return 'helpers'; }}], 'helpers',\n                      'helpers hash has precedence escaped expansion');\n      shouldCompileTo('{{lookup}}', [{lookup: 'Explicit'}, {lookup: function() { return 'helpers'; }}], 'helpers',\n                      'helpers hash has precedence simple expansion');\n    });\n\n    it('the helpers hash is available is nested contexts', function() {\n      shouldCompileTo(\n        '{{#outer}}{{#inner}}{{helper}}{{/inner}}{{/outer}}',\n        [\n          {'outer': {'inner': {'unused': []}}},\n          {'helper': function() { return 'helper'; }}\n        ],\n        'helper',\n        'helpers hash is available in nested contexts.');\n    });\n\n    it('the helper hash should augment the global hash', function() {\n      handlebarsEnv.registerHelper('test_helper', function() { return 'found it!'; });\n\n      shouldCompileTo(\n        '{{test_helper}} {{#if cruel}}Goodbye {{cruel}} {{world}}!{{/if}}', [\n          {cruel: 'cruel'},\n          {world: function() { return 'world!'; }}\n        ],\n        'found it! Goodbye cruel world!!');\n    });\n  });\n\n  describe('registration', function() {\n    it('unregisters', function() {\n      handlebarsEnv.helpers = {};\n\n      handlebarsEnv.registerHelper('foo', function() {\n        return 'fail';\n      });\n      handlebarsEnv.unregisterHelper('foo');\n      equals(handlebarsEnv.helpers.foo, undefined);\n    });\n\n    it('allows multiple globals', function() {\n      var helpers = handlebarsEnv.helpers;\n      handlebarsEnv.helpers = {};\n\n      handlebarsEnv.registerHelper({\n        'if': helpers['if'],\n        world: function() { return 'world!'; },\n        testHelper: function() { return 'found it!'; }\n      });\n\n      shouldCompileTo(\n        '{{testHelper}} {{#if cruel}}Goodbye {{cruel}} {{world}}!{{/if}}',\n        [{cruel: 'cruel'}],\n        'found it! Goodbye cruel world!!');\n    });\n    it('fails with multiple and args', function() {\n      shouldThrow(function() {\n        handlebarsEnv.registerHelper({\n          world: function() { return 'world!'; },\n          testHelper: function() { return 'found it!'; }\n        }, {});\n      }, Error, 'Arg not supported with multiple helpers');\n    });\n  });\n\n  it('decimal number literals work', function() {\n    var string = 'Message: {{hello -1.2 1.2}}';\n    var helpers = {hello: function(times, times2) {\n      if (typeof times !== 'number') { times = 'NaN'; }\n      if (typeof times2 !== 'number') { times2 = 'NaN'; }\n      return 'Hello ' + times + ' ' + times2 + ' times';\n    }};\n    shouldCompileTo(string, [{}, helpers], 'Message: Hello -1.2 1.2 times', 'template with a negative integer literal');\n  });\n\n  it('negative number literals work', function() {\n    var string = 'Message: {{hello -12}}';\n    var helpers = {hello: function(times) {\n      if (typeof times !== 'number') { times = 'NaN'; }\n      return 'Hello ' + times + ' times';\n    }};\n    shouldCompileTo(string, [{}, helpers], 'Message: Hello -12 times', 'template with a negative integer literal');\n  });\n\n  describe('String literal parameters', function() {\n    it('simple literals work', function() {\n      var string = 'Message: {{hello \"world\" 12 true false}}';\n      var helpers = {hello: function(param, times, bool1, bool2) {\n        if (typeof times !== 'number') { times = 'NaN'; }\n        if (typeof bool1 !== 'boolean') { bool1 = 'NaB'; }\n        if (typeof bool2 !== 'boolean') { bool2 = 'NaB'; }\n        return 'Hello ' + param + ' ' + times + ' times: ' + bool1 + ' ' + bool2;\n      }};\n      shouldCompileTo(string, [{}, helpers], 'Message: Hello world 12 times: true false', 'template with a simple String literal');\n    });\n\n    it('using a quote in the middle of a parameter raises an error', function() {\n      var string = 'Message: {{hello wo\"rld\"}}';\n      shouldThrow(function() {\n        CompilerContext.compile(string);\n      }, Error);\n    });\n\n    it('escaping a String is possible', function() {\n      var string = 'Message: {{{hello \"\\\\\"world\\\\\"\"}}}';\n      var helpers = {hello: function(param) { return 'Hello ' + param; }};\n      shouldCompileTo(string, [{}, helpers], 'Message: Hello \"world\"', 'template with an escaped String literal');\n    });\n\n    it(\"it works with ' marks\", function() {\n      var string = 'Message: {{{hello \"Alan\\'s world\"}}}';\n      var helpers = {hello: function(param) { return 'Hello ' + param; }};\n      shouldCompileTo(string, [{}, helpers], \"Message: Hello Alan's world\", \"template with a ' mark\");\n    });\n  });\n\n  it('negative number literals work', function() {\n    var string = 'Message: {{hello -12}}';\n    var helpers = {hello: function(times) {\n      if (typeof times !== 'number') { times = 'NaN'; }\n      return 'Hello ' + times + ' times';\n    }};\n    shouldCompileTo(string, [{}, helpers], 'Message: Hello -12 times', 'template with a negative integer literal');\n  });\n\n  describe('multiple parameters', function() {\n    it('simple multi-params work', function() {\n      var string = 'Message: {{goodbye cruel world}}';\n      var hash = {cruel: 'cruel', world: 'world'};\n      var helpers = {goodbye: function(cruel, world) { return 'Goodbye ' + cruel + ' ' + world; }};\n      shouldCompileTo(string, [hash, helpers], 'Message: Goodbye cruel world', 'regular helpers with multiple params');\n    });\n\n    it('block multi-params work', function() {\n      var string = 'Message: {{#goodbye cruel world}}{{greeting}} {{adj}} {{noun}}{{/goodbye}}';\n      var hash = {cruel: 'cruel', world: 'world'};\n      var helpers = {goodbye: function(cruel, world, options) {\n        return options.fn({greeting: 'Goodbye', adj: cruel, noun: world});\n      }};\n      shouldCompileTo(string, [hash, helpers], 'Message: Goodbye cruel world', 'block helpers with multiple params');\n    });\n  });\n\n  describe('hash', function() {\n    it('helpers can take an optional hash', function() {\n      var template = CompilerContext.compile('{{goodbye cruel=\"CRUEL\" world=\"WORLD\" times=12}}');\n\n      var helpers = {\n        goodbye: function(options) {\n          return 'GOODBYE ' + options.hash.cruel + ' ' + options.hash.world + ' ' + options.hash.times + ' TIMES';\n        }\n      };\n\n      var context = {};\n\n      var result = template(context, {helpers: helpers});\n      equals(result, 'GOODBYE CRUEL WORLD 12 TIMES', 'Helper output hash');\n    });\n\n    it('helpers can take an optional hash with booleans', function() {\n      var helpers = {\n        goodbye: function(options) {\n          if (options.hash.print === true) {\n            return 'GOODBYE ' + options.hash.cruel + ' ' + options.hash.world;\n          } else if (options.hash.print === false) {\n            return 'NOT PRINTING';\n          } else {\n            return 'THIS SHOULD NOT HAPPEN';\n          }\n        }\n      };\n\n      var context = {};\n\n      var template = CompilerContext.compile('{{goodbye cruel=\"CRUEL\" world=\"WORLD\" print=true}}');\n      var result = template(context, {helpers: helpers});\n      equals(result, 'GOODBYE CRUEL WORLD', 'Helper output hash');\n\n      template = CompilerContext.compile('{{goodbye cruel=\"CRUEL\" world=\"WORLD\" print=false}}');\n      result = template(context, {helpers: helpers});\n      equals(result, 'NOT PRINTING', 'Boolean helper parameter honored');\n    });\n\n    it('block helpers can take an optional hash', function() {\n      var template = CompilerContext.compile('{{#goodbye cruel=\"CRUEL\" times=12}}world{{/goodbye}}');\n\n      var helpers = {\n        goodbye: function(options) {\n          return 'GOODBYE ' + options.hash.cruel + ' ' + options.fn(this) + ' ' + options.hash.times + ' TIMES';\n        }\n      };\n\n      var result = template({}, {helpers: helpers});\n      equals(result, 'GOODBYE CRUEL world 12 TIMES', 'Hash parameters output');\n    });\n\n    it('block helpers can take an optional hash with single quoted stings', function() {\n      var template = CompilerContext.compile('{{#goodbye cruel=\"CRUEL\" times=12}}world{{/goodbye}}');\n\n      var helpers = {\n        goodbye: function(options) {\n          return 'GOODBYE ' + options.hash.cruel + ' ' + options.fn(this) + ' ' + options.hash.times + ' TIMES';\n        }\n      };\n\n      var result = template({}, {helpers: helpers});\n      equals(result, 'GOODBYE CRUEL world 12 TIMES', 'Hash parameters output');\n    });\n\n    it('block helpers can take an optional hash with booleans', function() {\n      var helpers = {\n        goodbye: function(options) {\n          if (options.hash.print === true) {\n            return 'GOODBYE ' + options.hash.cruel + ' ' + options.fn(this);\n          } else if (options.hash.print === false) {\n            return 'NOT PRINTING';\n          } else {\n            return 'THIS SHOULD NOT HAPPEN';\n          }\n        }\n      };\n\n      var template = CompilerContext.compile('{{#goodbye cruel=\"CRUEL\" print=true}}world{{/goodbye}}');\n      var result = template({}, {helpers: helpers});\n      equals(result, 'GOODBYE CRUEL world', 'Boolean hash parameter honored');\n\n      template = CompilerContext.compile('{{#goodbye cruel=\"CRUEL\" print=false}}world{{/goodbye}}');\n      result = template({}, {helpers: helpers});\n      equals(result, 'NOT PRINTING', 'Boolean hash parameter honored');\n    });\n  });\n\n  describe('helperMissing', function() {\n    it('if a context is not found, helperMissing is used', function() {\n      shouldThrow(function() {\n          var template = CompilerContext.compile('{{hello}} {{link_to world}}');\n          template({});\n      }, undefined, /Missing helper: \"link_to\"/);\n    });\n\n    it('if a context is not found, custom helperMissing is used', function() {\n      var string = '{{hello}} {{link_to world}}';\n      var context = { hello: 'Hello', world: 'world' };\n\n      var helpers = {\n        helperMissing: function(mesg, options) {\n          if (options.name === 'link_to') {\n            return new Handlebars.SafeString('<a>' + mesg + '</a>');\n          }\n        }\n      };\n\n      shouldCompileTo(string, [context, helpers], 'Hello <a>world</a>');\n    });\n\n    it('if a value is not found, custom helperMissing is used', function() {\n      var string = '{{hello}} {{link_to}}';\n      var context = { hello: 'Hello', world: 'world' };\n\n      var helpers = {\n        helperMissing: function(options) {\n          if (options.name === 'link_to') {\n            return new Handlebars.SafeString('<a>winning</a>');\n          }\n        }\n      };\n\n      shouldCompileTo(string, [context, helpers], 'Hello <a>winning</a>');\n    });\n  });\n\n  describe('knownHelpers', function() {\n    it('Known helper should render helper', function() {\n      var template = CompilerContext.compile('{{hello}}', {knownHelpers: {hello: true}});\n\n      var result = template({}, {helpers: {hello: function() { return 'foo'; }}});\n      equal(result, 'foo', \"'foo' should === '\" + result);\n    });\n\n    it('Unknown helper in knownHelpers only mode should be passed as undefined', function() {\n      var template = CompilerContext.compile('{{typeof hello}}', {knownHelpers: {'typeof': true}, knownHelpersOnly: true});\n\n      var result = template({}, {helpers: {'typeof': function(arg) { return typeof arg; }, hello: function() { return 'foo'; }}});\n      equal(result, 'undefined', \"'undefined' should === '\" + result);\n    });\n    it('Builtin helpers available in knownHelpers only mode', function() {\n      var template = CompilerContext.compile('{{#unless foo}}bar{{/unless}}', {knownHelpersOnly: true});\n\n      var result = template({});\n      equal(result, 'bar', \"'bar' should === '\" + result);\n    });\n    it('Field lookup works in knownHelpers only mode', function() {\n      var template = CompilerContext.compile('{{foo}}', {knownHelpersOnly: true});\n\n      var result = template({foo: 'bar'});\n      equal(result, 'bar', \"'bar' should === '\" + result);\n    });\n    it('Conditional blocks work in knownHelpers only mode', function() {\n      var template = CompilerContext.compile('{{#foo}}bar{{/foo}}', {knownHelpersOnly: true});\n\n      var result = template({foo: 'baz'});\n      equal(result, 'bar', \"'bar' should === '\" + result);\n    });\n    it('Invert blocks work in knownHelpers only mode', function() {\n      var template = CompilerContext.compile('{{^foo}}bar{{/foo}}', {knownHelpersOnly: true});\n\n      var result = template({foo: false});\n      equal(result, 'bar', \"'bar' should === '\" + result);\n    });\n    it('Functions are bound to the context in knownHelpers only mode', function() {\n      var template = CompilerContext.compile('{{foo}}', {knownHelpersOnly: true});\n      var result = template({foo: function() { return this.bar; }, bar: 'bar'});\n      equal(result, 'bar', \"'bar' should === '\" + result);\n    });\n    it('Unknown helper call in knownHelpers only mode should throw', function() {\n      shouldThrow(function() {\n        CompilerContext.compile('{{typeof hello}}', {knownHelpersOnly: true});\n      }, Error);\n    });\n  });\n\n  describe('blockHelperMissing', function() {\n    it('lambdas are resolved by blockHelperMissing, not handlebars proper', function() {\n      var string = '{{#truthy}}yep{{/truthy}}';\n      var data = { truthy: function() { return true; } };\n      shouldCompileTo(string, data, 'yep');\n    });\n    it('lambdas resolved by blockHelperMissing are bound to the context', function() {\n      var string = '{{#truthy}}yep{{/truthy}}';\n      var boundData = { truthy: function() { return this.truthiness(); }, truthiness: function() { return false; } };\n      shouldCompileTo(string, boundData, '');\n    });\n  });\n\n  describe('name field', function() {\n    var context = {};\n    var helpers = {\n      blockHelperMissing: function() {\n        return 'missing: ' + arguments[arguments.length - 1].name;\n      },\n      helperMissing: function() {\n        return 'helper missing: ' + arguments[arguments.length - 1].name;\n      },\n      helper: function() {\n        return 'ran: ' + arguments[arguments.length - 1].name;\n      }\n    };\n\n    it('should include in ambiguous mustache calls', function() {\n      shouldCompileTo('{{helper}}', [context, helpers], 'ran: helper');\n    });\n    it('should include in helper mustache calls', function() {\n      shouldCompileTo('{{helper 1}}', [context, helpers], 'ran: helper');\n    });\n    it('should include in ambiguous block calls', function() {\n      shouldCompileTo('{{#helper}}{{/helper}}', [context, helpers], 'ran: helper');\n    });\n    it('should include in simple block calls', function() {\n      shouldCompileTo('{{#./helper}}{{/./helper}}', [context, helpers], 'missing: ./helper');\n    });\n    it('should include in helper block calls', function() {\n      shouldCompileTo('{{#helper 1}}{{/helper}}', [context, helpers], 'ran: helper');\n    });\n    it('should include in known helper calls', function() {\n      var template = CompilerContext.compile('{{helper}}', {knownHelpers: {'helper': true}, knownHelpersOnly: true});\n\n      equal(template({}, {helpers: helpers}), 'ran: helper');\n    });\n\n    it('should include full id', function() {\n      shouldCompileTo('{{#foo.helper}}{{/foo.helper}}', [{foo: {}}, helpers], 'missing: foo.helper');\n    });\n\n    it('should include full id if a hash is passed', function() {\n      shouldCompileTo('{{#foo.helper bar=baz}}{{/foo.helper}}', [{foo: {}}, helpers], 'helper missing: foo.helper');\n    });\n  });\n\n  describe('name conflicts', function() {\n    it('helpers take precedence over same-named context properties', function() {\n      var template = CompilerContext.compile('{{goodbye}} {{cruel world}}');\n\n      var helpers = {\n        goodbye: function() {\n          return this.goodbye.toUpperCase();\n        },\n\n        cruel: function(world) {\n          return 'cruel ' + world.toUpperCase();\n        }\n      };\n\n      var context = {\n        goodbye: 'goodbye',\n        world: 'world'\n      };\n\n      var result = template(context, {helpers: helpers});\n      equals(result, 'GOODBYE cruel WORLD', 'Helper executed');\n    });\n\n    it('helpers take precedence over same-named context properties$', function() {\n      var template = CompilerContext.compile('{{#goodbye}} {{cruel world}}{{/goodbye}}');\n\n      var helpers = {\n        goodbye: function(options) {\n          return this.goodbye.toUpperCase() + options.fn(this);\n        },\n\n        cruel: function(world) {\n          return 'cruel ' + world.toUpperCase();\n        }\n      };\n\n      var context = {\n        goodbye: 'goodbye',\n        world: 'world'\n      };\n\n      var result = template(context, {helpers: helpers});\n      equals(result, 'GOODBYE cruel WORLD', 'Helper executed');\n    });\n\n    it('Scoped names take precedence over helpers', function() {\n      var template = CompilerContext.compile('{{this.goodbye}} {{cruel world}} {{cruel this.goodbye}}');\n\n      var helpers = {\n        goodbye: function() {\n          return this.goodbye.toUpperCase();\n        },\n\n        cruel: function(world) {\n          return 'cruel ' + world.toUpperCase();\n        }\n      };\n\n      var context = {\n        goodbye: 'goodbye',\n        world: 'world'\n      };\n\n      var result = template(context, {helpers: helpers});\n      equals(result, 'goodbye cruel WORLD cruel GOODBYE', 'Helper not executed');\n    });\n\n    it('Scoped names take precedence over block helpers', function() {\n      var template = CompilerContext.compile('{{#goodbye}} {{cruel world}}{{/goodbye}} {{this.goodbye}}');\n\n      var helpers = {\n        goodbye: function(options) {\n          return this.goodbye.toUpperCase() + options.fn(this);\n        },\n\n        cruel: function(world) {\n          return 'cruel ' + world.toUpperCase();\n        }\n      };\n\n      var context = {\n        goodbye: 'goodbye',\n        world: 'world'\n      };\n\n      var result = template(context, {helpers: helpers});\n      equals(result, 'GOODBYE cruel WORLD goodbye', 'Helper executed');\n    });\n  });\n\n  describe('block params', function() {\n    it('should take presedence over context values', function() {\n      var hash = {value: 'foo'};\n      var helpers = {\n        goodbyes: function(options) {\n          equals(options.fn.blockParams, 1);\n          return options.fn({value: 'bar'}, {blockParams: [1, 2]});\n        }\n      };\n      shouldCompileTo('{{#goodbyes as |value|}}{{value}}{{/goodbyes}}{{value}}', [hash, helpers], '1foo');\n    });\n    it('should take presedence over helper values', function() {\n      var hash = {};\n      var helpers = {\n        value: function() {\n          return 'foo';\n        },\n        goodbyes: function(options) {\n          equals(options.fn.blockParams, 1);\n          return options.fn({}, {blockParams: [1, 2]});\n        }\n      };\n      shouldCompileTo('{{#goodbyes as |value|}}{{value}}{{/goodbyes}}{{value}}', [hash, helpers], '1foo');\n    });\n    it('should not take presedence over pathed values', function() {\n      var hash = {value: 'bar'};\n      var helpers = {\n        value: function() {\n          return 'foo';\n        },\n        goodbyes: function(options) {\n          equals(options.fn.blockParams, 1);\n          return options.fn(this, {blockParams: [1, 2]});\n        }\n      };\n      shouldCompileTo('{{#goodbyes as |value|}}{{./value}}{{/goodbyes}}{{value}}', [hash, helpers], 'barfoo');\n    });\n    it('should take presednece over parent block params', function() {\n      var hash = {value: 'foo'},\n          value = 1;\n      var helpers = {\n        goodbyes: function(options) {\n          return options.fn({value: 'bar'}, {blockParams: options.fn.blockParams === 1 ? [value++, value++] : undefined});\n        }\n      };\n      shouldCompileTo('{{#goodbyes as |value|}}{{#goodbyes}}{{value}}{{#goodbyes as |value|}}{{value}}{{/goodbyes}}{{/goodbyes}}{{/goodbyes}}{{value}}', [hash, helpers], '13foo');\n    });\n\n    it('should allow block params on chained helpers', function() {\n      var hash = {value: 'foo'};\n      var helpers = {\n        goodbyes: function(options) {\n          equals(options.fn.blockParams, 1);\n          return options.fn({value: 'bar'}, {blockParams: [1, 2]});\n        }\n      };\n      shouldCompileTo('{{#if bar}}{{else goodbyes as |value|}}{{value}}{{/if}}{{value}}', [hash, helpers], '1foo');\n    });\n  });\n});\n", "function shouldMatchTokens(result, tokens) {\n  for (var index = 0; index < result.length; index++) {\n    equals(result[index].name, tokens[index]);\n  }\n}\nfunction shouldBeToken(result, name, text) {\n  equals(result.name, name);\n  equals(result.text, text);\n}\n\ndescribe('Tokenizer', function() {\n  if (!Handlebars.Parser) {\n    return;\n  }\n\n  function tokenize(template) {\n    var parser = Handlebars.Parser,\n        lexer = parser.lexer;\n\n    lexer.setInput(template);\n    var out = [],\n        token;\n\n    while ((token = lexer.lex())) {\n      var result = parser.terminals_[token] || token;\n      if (!result || result === 'EOF' || result === 'INVALID') {\n        break;\n      }\n      out.push({name: result, text: lexer.yytext});\n    }\n\n    return out;\n  }\n\n  it('tokenizes a simple mustache as \"OPEN ID CLOSE\"', function() {\n    var result = tokenize('{{foo}}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'CLOSE']);\n    shouldBeToken(result[1], 'ID', 'foo');\n  });\n\n  it('supports unescaping with &', function() {\n    var result = tokenize('{{&bar}}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'CLOSE']);\n\n    shouldBeToken(result[0], 'OPEN', '{{&');\n    shouldBeToken(result[1], 'ID', 'bar');\n  });\n\n  it('supports unescaping with {{{', function() {\n    var result = tokenize('{{{bar}}}');\n    shouldMatchTokens(result, ['OPEN_UNESCAPED', 'ID', 'CLOSE_UNESCAPED']);\n\n    shouldBeToken(result[1], 'ID', 'bar');\n  });\n\n  it('supports escaping delimiters', function() {\n    var result = tokenize('{{foo}} \\\\{{bar}} {{baz}}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'CLOSE', 'CONTENT', 'CONTENT', 'OPEN', 'ID', 'CLOSE']);\n\n    shouldBeToken(result[3], 'CONTENT', ' ');\n    shouldBeToken(result[4], 'CONTENT', '{{bar}} ');\n  });\n\n  it('supports escaping multiple delimiters', function() {\n    var result = tokenize('{{foo}} \\\\{{bar}} \\\\{{baz}}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'CLOSE', 'CONTENT', 'CONTENT', 'CONTENT']);\n\n    shouldBeToken(result[3], 'CONTENT', ' ');\n    shouldBeToken(result[4], 'CONTENT', '{{bar}} ');\n    shouldBeToken(result[5], 'CONTENT', '{{baz}}');\n  });\n\n  it('supports escaping a triple stash', function() {\n    var result = tokenize('{{foo}} \\\\{{{bar}}} {{baz}}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'CLOSE', 'CONTENT', 'CONTENT', 'OPEN', 'ID', 'CLOSE']);\n\n    shouldBeToken(result[4], 'CONTENT', '{{{bar}}} ');\n  });\n\n  it('supports escaping escape character', function() {\n    var result = tokenize('{{foo}} \\\\\\\\{{bar}} {{baz}}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'CLOSE', 'CONTENT', 'OPEN', 'ID', 'CLOSE', 'CONTENT', 'OPEN', 'ID', 'CLOSE']);\n\n    shouldBeToken(result[3], 'CONTENT', ' \\\\');\n    shouldBeToken(result[5], 'ID', 'bar');\n  });\n\n  it('supports escaping multiple escape characters', function() {\n    var result = tokenize('{{foo}} \\\\\\\\{{bar}} \\\\\\\\{{baz}}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'CLOSE', 'CONTENT', 'OPEN', 'ID', 'CLOSE', 'CONTENT', 'OPEN', 'ID', 'CLOSE']);\n\n    shouldBeToken(result[3], 'CONTENT', ' \\\\');\n    shouldBeToken(result[5], 'ID', 'bar');\n    shouldBeToken(result[7], 'CONTENT', ' \\\\');\n    shouldBeToken(result[9], 'ID', 'baz');\n  });\n\n  it('supports escaped mustaches after escaped escape characters', function() {\n    var result = tokenize('{{foo}} \\\\\\\\{{bar}} \\\\{{baz}}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'CLOSE', 'CONTENT', 'OPEN', 'ID', 'CLOSE', 'CONTENT', 'CONTENT', 'CONTENT']);\n\n    shouldBeToken(result[3], 'CONTENT', ' \\\\');\n    shouldBeToken(result[4], 'OPEN', '{{');\n    shouldBeToken(result[5], 'ID', 'bar');\n    shouldBeToken(result[7], 'CONTENT', ' ');\n    shouldBeToken(result[8], 'CONTENT', '{{baz}}');\n  });\n\n  it('supports escaped escape characters after escaped mustaches', function() {\n    var result = tokenize('{{foo}} \\\\{{bar}} \\\\\\\\{{baz}}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'CLOSE', 'CONTENT', 'CONTENT', 'CONTENT', 'OPEN', 'ID', 'CLOSE']);\n\n    shouldBeToken(result[4], 'CONTENT', '{{bar}} ');\n    shouldBeToken(result[5], 'CONTENT', '\\\\');\n    shouldBeToken(result[6], 'OPEN', '{{');\n    shouldBeToken(result[7], 'ID', 'baz');\n  });\n\n  it('supports escaped escape character on a triple stash', function() {\n    var result = tokenize('{{foo}} \\\\\\\\{{{bar}}} {{baz}}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'CLOSE', 'CONTENT', 'OPEN_UNESCAPED', 'ID', 'CLOSE_UNESCAPED', 'CONTENT', 'OPEN', 'ID', 'CLOSE']);\n\n    shouldBeToken(result[3], 'CONTENT', ' \\\\');\n    shouldBeToken(result[5], 'ID', 'bar');\n  });\n\n  it('tokenizes a simple path', function() {\n    var result = tokenize('{{foo/bar}}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'SEP', 'ID', 'CLOSE']);\n  });\n\n  it('allows dot notation', function() {\n    var result = tokenize('{{foo.bar}}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'SEP', 'ID', 'CLOSE']);\n\n    shouldMatchTokens(tokenize('{{foo.bar.baz}}'), ['OPEN', 'ID', 'SEP', 'ID', 'SEP', 'ID', 'CLOSE']);\n  });\n\n  it('allows path literals with []', function() {\n    var result = tokenize('{{foo.[bar]}}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'SEP', 'ID', 'CLOSE']);\n  });\n\n  it('allows multiple path literals on a line with []', function() {\n    var result = tokenize('{{foo.[bar]}}{{foo.[baz]}}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'SEP', 'ID', 'CLOSE', 'OPEN', 'ID', 'SEP', 'ID', 'CLOSE']);\n  });\n\n  it('allows escaped literals in []', function() {\n    var result = tokenize('{{foo.[bar\\\\]]}}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'SEP', 'ID', 'CLOSE']);\n  });\n\n  it('tokenizes {{.}} as OPEN ID CLOSE', function() {\n    var result = tokenize('{{.}}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'CLOSE']);\n  });\n\n  it('tokenizes a path as \"OPEN (ID SEP)* ID CLOSE\"', function() {\n    var result = tokenize('{{../foo/bar}}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'SEP', 'ID', 'SEP', 'ID', 'CLOSE']);\n    shouldBeToken(result[1], 'ID', '..');\n  });\n\n  it('tokenizes a path with .. as a parent path', function() {\n    var result = tokenize('{{../foo.bar}}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'SEP', 'ID', 'SEP', 'ID', 'CLOSE']);\n    shouldBeToken(result[1], 'ID', '..');\n  });\n\n  it('tokenizes a path with this/foo as OPEN ID SEP ID CLOSE', function() {\n    var result = tokenize('{{this/foo}}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'SEP', 'ID', 'CLOSE']);\n    shouldBeToken(result[1], 'ID', 'this');\n    shouldBeToken(result[3], 'ID', 'foo');\n  });\n\n  it('tokenizes a simple mustache with spaces as \"OPEN ID CLOSE\"', function() {\n    var result = tokenize('{{  foo  }}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'CLOSE']);\n    shouldBeToken(result[1], 'ID', 'foo');\n  });\n\n  it('tokenizes a simple mustache with line breaks as \"OPEN ID ID CLOSE\"', function() {\n    var result = tokenize('{{  foo  \\n   bar }}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'ID', 'CLOSE']);\n    shouldBeToken(result[1], 'ID', 'foo');\n  });\n\n  it('tokenizes raw content as \"CONTENT\"', function() {\n    var result = tokenize('foo {{ bar }} baz');\n    shouldMatchTokens(result, ['CONTENT', 'OPEN', 'ID', 'CLOSE', 'CONTENT']);\n    shouldBeToken(result[0], 'CONTENT', 'foo ');\n    shouldBeToken(result[4], 'CONTENT', ' baz');\n  });\n\n  it('tokenizes a partial as \"OPEN_PARTIAL ID CLOSE\"', function() {\n    var result = tokenize('{{> foo}}');\n    shouldMatchTokens(result, ['OPEN_PARTIAL', 'ID', 'CLOSE']);\n  });\n\n  it('tokenizes a partial with context as \"OPEN_PARTIAL ID ID CLOSE\"', function() {\n    var result = tokenize('{{> foo bar }}');\n    shouldMatchTokens(result, ['OPEN_PARTIAL', 'ID', 'ID', 'CLOSE']);\n  });\n\n  it('tokenizes a partial without spaces as \"OPEN_PARTIAL ID CLOSE\"', function() {\n    var result = tokenize('{{>foo}}');\n    shouldMatchTokens(result, ['OPEN_PARTIAL', 'ID', 'CLOSE']);\n  });\n\n  it('tokenizes a partial space at the }); as \"OPEN_PARTIAL ID CLOSE\"', function() {\n    var result = tokenize('{{>foo  }}');\n    shouldMatchTokens(result, ['OPEN_PARTIAL', 'ID', 'CLOSE']);\n  });\n\n  it('tokenizes a partial space at the }); as \"OPEN_PARTIAL ID CLOSE\"', function() {\n    var result = tokenize('{{>foo/bar.baz  }}');\n    shouldMatchTokens(result, ['OPEN_PARTIAL', 'ID', 'SEP', 'ID', 'SEP', 'ID', 'CLOSE']);\n  });\n\n  it('tokenizes partial block declarations', function() {\n    var result = tokenize('{{#> foo}}');\n    shouldMatchTokens(result, ['OPEN_PARTIAL_BLOCK', 'ID', 'CLOSE']);\n  });\n  it('tokenizes a comment as \"COMMENT\"', function() {\n    var result = tokenize('foo {{! this is a comment }} bar {{ baz }}');\n    shouldMatchTokens(result, ['CONTENT', 'COMMENT', 'CONTENT', 'OPEN', 'ID', 'CLOSE']);\n    shouldBeToken(result[1], 'COMMENT', '{{! this is a comment }}');\n  });\n\n  it('tokenizes a block comment as \"COMMENT\"', function() {\n    var result = tokenize('foo {{!-- this is a {{comment}} --}} bar {{ baz }}');\n    shouldMatchTokens(result, ['CONTENT', 'COMMENT', 'CONTENT', 'OPEN', 'ID', 'CLOSE']);\n    shouldBeToken(result[1], 'COMMENT', '{{!-- this is a {{comment}} --}}');\n  });\n\n  it('tokenizes a block comment with whitespace as \"COMMENT\"', function() {\n    var result = tokenize('foo {{!-- this is a\\n{{comment}}\\n--}} bar {{ baz }}');\n    shouldMatchTokens(result, ['CONTENT', 'COMMENT', 'CONTENT', 'OPEN', 'ID', 'CLOSE']);\n    shouldBeToken(result[1], 'COMMENT', '{{!-- this is a\\n{{comment}}\\n--}}');\n  });\n\n  it('tokenizes open and closing blocks as OPEN_BLOCK, ID, CLOSE ..., OPEN_ENDBLOCK ID CLOSE', function() {\n    var result = tokenize('{{#foo}}content{{/foo}}');\n    shouldMatchTokens(result, ['OPEN_BLOCK', 'ID', 'CLOSE', 'CONTENT', 'OPEN_ENDBLOCK', 'ID', 'CLOSE']);\n  });\n\n  it('tokenizes directives', function() {\n    shouldMatchTokens(\n        tokenize('{{#*foo}}content{{/foo}}'),\n        ['OPEN_BLOCK', 'ID', 'CLOSE', 'CONTENT', 'OPEN_ENDBLOCK', 'ID', 'CLOSE']);\n    shouldMatchTokens(\n        tokenize('{{*foo}}'),\n        ['OPEN', 'ID', 'CLOSE']);\n  });\n\n  it('tokenizes inverse sections as \"INVERSE\"', function() {\n    shouldMatchTokens(tokenize('{{^}}'), ['INVERSE']);\n    shouldMatchTokens(tokenize('{{else}}'), ['INVERSE']);\n    shouldMatchTokens(tokenize('{{ else }}'), ['INVERSE']);\n  });\n\n  it('tokenizes inverse sections with ID as \"OPEN_INVERSE ID CLOSE\"', function() {\n    var result = tokenize('{{^foo}}');\n    shouldMatchTokens(result, ['OPEN_INVERSE', 'ID', 'CLOSE']);\n    shouldBeToken(result[1], 'ID', 'foo');\n  });\n\n  it('tokenizes inverse sections with ID and spaces as \"OPEN_INVERSE ID CLOSE\"', function() {\n    var result = tokenize('{{^ foo  }}');\n    shouldMatchTokens(result, ['OPEN_INVERSE', 'ID', 'CLOSE']);\n    shouldBeToken(result[1], 'ID', 'foo');\n  });\n\n  it('tokenizes mustaches with params as \"OPEN ID ID ID CLOSE\"', function() {\n    var result = tokenize('{{ foo bar baz }}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'ID', 'ID', 'CLOSE']);\n    shouldBeToken(result[1], 'ID', 'foo');\n    shouldBeToken(result[2], 'ID', 'bar');\n    shouldBeToken(result[3], 'ID', 'baz');\n  });\n\n  it('tokenizes mustaches with String params as \"OPEN ID ID STRING CLOSE\"', function() {\n    var result = tokenize('{{ foo bar \"baz\" }}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'ID', 'STRING', 'CLOSE']);\n    shouldBeToken(result[3], 'STRING', 'baz');\n  });\n\n  it('tokenizes mustaches with String params using single quotes as \"OPEN ID ID STRING CLOSE\"', function() {\n    var result = tokenize(\"{{ foo bar 'baz' }}\");\n    shouldMatchTokens(result, ['OPEN', 'ID', 'ID', 'STRING', 'CLOSE']);\n    shouldBeToken(result[3], 'STRING', 'baz');\n  });\n\n  it('tokenizes String params with spaces inside as \"STRING\"', function() {\n    var result = tokenize('{{ foo bar \"baz bat\" }}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'ID', 'STRING', 'CLOSE']);\n    shouldBeToken(result[3], 'STRING', 'baz bat');\n  });\n\n  it('tokenizes String params with escapes quotes as STRING', function() {\n    var result = tokenize('{{ foo \"bar\\\\\"baz\" }}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'STRING', 'CLOSE']);\n    shouldBeToken(result[2], 'STRING', 'bar\"baz');\n  });\n\n  it('tokenizes String params using single quotes with escapes quotes as STRING', function() {\n    var result = tokenize(\"{{ foo 'bar\\\\'baz' }}\");\n    shouldMatchTokens(result, ['OPEN', 'ID', 'STRING', 'CLOSE']);\n    shouldBeToken(result[2], 'STRING', \"bar'baz\");\n  });\n\n  it('tokenizes numbers', function() {\n    var result = tokenize('{{ foo 1 }}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'NUMBER', 'CLOSE']);\n    shouldBeToken(result[2], 'NUMBER', '1');\n\n    result = tokenize('{{ foo 1.1 }}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'NUMBER', 'CLOSE']);\n    shouldBeToken(result[2], 'NUMBER', '1.1');\n\n    result = tokenize('{{ foo -1 }}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'NUMBER', 'CLOSE']);\n    shouldBeToken(result[2], 'NUMBER', '-1');\n\n    result = tokenize('{{ foo -1.1 }}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'NUMBER', 'CLOSE']);\n    shouldBeToken(result[2], 'NUMBER', '-1.1');\n  });\n\n  it('tokenizes booleans', function() {\n    var result = tokenize('{{ foo true }}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'BOOLEAN', 'CLOSE']);\n    shouldBeToken(result[2], 'BOOLEAN', 'true');\n\n    result = tokenize('{{ foo false }}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'BOOLEAN', 'CLOSE']);\n    shouldBeToken(result[2], 'BOOLEAN', 'false');\n  });\n\n  it('tokenizes undefined and null', function() {\n    var result = tokenize('{{ foo undefined null }}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'UNDEFINED', 'NULL', 'CLOSE']);\n    shouldBeToken(result[2], 'UNDEFINED', 'undefined');\n    shouldBeToken(result[3], 'NULL', 'null');\n  });\n\n  it('tokenizes hash arguments', function() {\n    var result = tokenize('{{ foo bar=baz }}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'ID', 'EQUALS', 'ID', 'CLOSE']);\n\n    result = tokenize('{{ foo bar baz=bat }}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'ID', 'ID', 'EQUALS', 'ID', 'CLOSE']);\n\n    result = tokenize('{{ foo bar baz=1 }}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'ID', 'ID', 'EQUALS', 'NUMBER', 'CLOSE']);\n\n    result = tokenize('{{ foo bar baz=true }}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'ID', 'ID', 'EQUALS', 'BOOLEAN', 'CLOSE']);\n\n    result = tokenize('{{ foo bar baz=false }}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'ID', 'ID', 'EQUALS', 'BOOLEAN', 'CLOSE']);\n\n    result = tokenize('{{ foo bar\\n  baz=bat }}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'ID', 'ID', 'EQUALS', 'ID', 'CLOSE']);\n\n    result = tokenize('{{ foo bar baz=\"bat\" }}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'ID', 'ID', 'EQUALS', 'STRING', 'CLOSE']);\n\n    result = tokenize('{{ foo bar baz=\"bat\" bam=wot }}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'ID', 'ID', 'EQUALS', 'STRING', 'ID', 'EQUALS', 'ID', 'CLOSE']);\n\n    result = tokenize('{{foo omg bar=baz bat=\"bam\"}}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'ID', 'ID', 'EQUALS', 'ID', 'ID', 'EQUALS', 'STRING', 'CLOSE']);\n    shouldBeToken(result[2], 'ID', 'omg');\n  });\n\n  it('tokenizes special @ identifiers', function() {\n    var result = tokenize('{{ @foo }}');\n    shouldMatchTokens(result, ['OPEN', 'DATA', 'ID', 'CLOSE']);\n    shouldBeToken(result[2], 'ID', 'foo');\n\n    result = tokenize('{{ foo @bar }}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'DATA', 'ID', 'CLOSE']);\n    shouldBeToken(result[3], 'ID', 'bar');\n\n    result = tokenize('{{ foo bar=@baz }}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'ID', 'EQUALS', 'DATA', 'ID', 'CLOSE']);\n    shouldBeToken(result[5], 'ID', 'baz');\n  });\n\n  it('does not time out in a mustache with a single } followed by EOF', function() {\n    shouldMatchTokens(tokenize('{{foo}'), ['OPEN', 'ID']);\n  });\n\n  it('does not time out in a mustache when invalid ID characters are used', function() {\n    shouldMatchTokens(tokenize('{{foo & }}'), ['OPEN', 'ID']);\n  });\n\n  it('tokenizes subexpressions', function() {\n    var result = tokenize('{{foo (bar)}}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'OPEN_SEXPR', 'ID', 'CLOSE_SEXPR', 'CLOSE']);\n    shouldBeToken(result[1], 'ID', 'foo');\n    shouldBeToken(result[3], 'ID', 'bar');\n\n    result = tokenize('{{foo (a-x b-y)}}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'OPEN_SEXPR', 'ID', 'ID', 'CLOSE_SEXPR', 'CLOSE']);\n    shouldBeToken(result[1], 'ID', 'foo');\n    shouldBeToken(result[3], 'ID', 'a-x');\n    shouldBeToken(result[4], 'ID', 'b-y');\n  });\n\n  it('tokenizes nested subexpressions', function() {\n    var result = tokenize('{{foo (bar (lol rofl)) (baz)}}');\n    shouldMatchTokens(result, ['OPEN', 'ID', 'OPEN_SEXPR', 'ID', 'OPEN_SEXPR', 'ID', 'ID', 'CLOSE_SEXPR', 'CLOSE_SEXPR', 'OPEN_SEXPR', 'ID', 'CLOSE_SEXPR', 'CLOSE']);\n    shouldBeToken(result[3], 'ID', 'bar');\n    shouldBeToken(result[5], 'ID', 'lol');\n    shouldBeToken(result[6], 'ID', 'rofl');\n    shouldBeToken(result[10], 'ID', 'baz');\n  });\n\n  it('tokenizes nested subexpressions: literals', function() {\n    var result = tokenize(\"{{foo (bar (lol true) false) (baz 1) (blah 'b') (blorg \\\"c\\\")}}\");\n    shouldMatchTokens(result, ['OPEN', 'ID', 'OPEN_SEXPR', 'ID', 'OPEN_SEXPR', 'ID', 'BOOLEAN', 'CLOSE_SEXPR', 'BOOLEAN', 'CLOSE_SEXPR', 'OPEN_SEXPR', 'ID', 'NUMBER', 'CLOSE_SEXPR', 'OPEN_SEXPR', 'ID', 'STRING', 'CLOSE_SEXPR', 'OPEN_SEXPR', 'ID', 'STRING', 'CLOSE_SEXPR', 'CLOSE']);\n  });\n\n  it('tokenizes block params', function() {\n    var result = tokenize('{{#foo as |bar|}}');\n    shouldMatchTokens(result, ['OPEN_BLOCK', 'ID', 'OPEN_BLOCK_PARAMS', 'ID', 'CLOSE_BLOCK_PARAMS', 'CLOSE']);\n\n    result = tokenize('{{#foo as |bar baz|}}');\n    shouldMatchTokens(result, ['OPEN_BLOCK', 'ID', 'OPEN_BLOCK_PARAMS', 'ID', 'ID', 'CLOSE_BLOCK_PARAMS', 'CLOSE']);\n\n    result = tokenize('{{#foo as | bar baz |}}');\n    shouldMatchTokens(result, ['OPEN_BLOCK', 'ID', 'OPEN_BLOCK_PARAMS', 'ID', 'ID', 'CLOSE_BLOCK_PARAMS', 'CLOSE']);\n\n    result = tokenize('{{#foo as as | bar baz |}}');\n    shouldMatchTokens(result, ['OPEN_BLOCK', 'ID', 'ID', 'OPEN_BLOCK_PARAMS', 'ID', 'ID', 'CLOSE_BLOCK_PARAMS', 'CLOSE']);\n\n    result = tokenize('{{else foo as |bar baz|}}');\n    shouldMatchTokens(result, ['OPEN_INVERSE_CHAIN', 'ID', 'OPEN_BLOCK_PARAMS', 'ID', 'ID', 'CLOSE_BLOCK_PARAMS', 'CLOSE']);\n  });\n\n  it('tokenizes raw blocks', function() {\n    var result = tokenize('{{{{a}}}} abc {{{{/a}}}} aaa {{{{a}}}} abc {{{{/a}}}}');\n    shouldMatchTokens(result, ['OPEN_RAW_BLOCK', 'ID', 'CLOSE_RAW_BLOCK', 'CONTENT', 'END_RAW_BLOCK', 'CONTENT', 'OPEN_RAW_BLOCK', 'ID', 'CLOSE_RAW_BLOCK', 'CONTENT', 'END_RAW_BLOCK']);\n  });\n});\n", "\n%x mu emu com raw\n\n%{\n\nfunction strip(start, end) {\n  return yytext = yytext.substring(start, yyleng - end + start);\n}\n\n%}\n\nLEFT_STRIP    \"~\"\nRIGHT_STRIP   \"~\"\n\nLOOKAHEAD           [=~}\\s\\/.)|]\nLITERAL_LOOKAHEAD   [~}\\s)]\n\n/*\nID is the inverse of control characters.\nControl characters ranges:\n  [\\s]          Whitespace\n  [!\"#%-,\\./]   !, \", #, %, &, ', (, ), *, +, ,, ., /,  Exceptions in range: $, -\n  [;->@]        ;, <, =, >, @,                          Exceptions in range: :, ?\n  [\\[-\\^`]      [, \\, ], ^, `,                          Exceptions in range: _\n  [\\{-~]        {, |, }, ~\n*/\nID    [^\\s!\"#%-,\\.\\/;->@\\[-\\^`\\{-~]+/{LOOKAHEAD}\n\n%%\n\n[^\\x00]*?/(\"{{\")                {\n                                   if(yytext.slice(-2) === \"\\\\\\\\\") {\n                                     strip(0,1);\n                                     this.begin(\"mu\");\n                                   } else if(yytext.slice(-1) === \"\\\\\") {\n                                     strip(0,1);\n                                     this.begin(\"emu\");\n                                   } else {\n                                     this.begin(\"mu\");\n                                   }\n                                   if(yytext) return 'CONTENT';\n                                 }\n\n[^\\x00]+                         return 'CONTENT';\n\n// marks CONTENT up to the next mustache or escaped mustache\n<emu>[^\\x00]{2,}?/(\"{{\"|\"\\\\{{\"|\"\\\\\\\\{{\"|<<EOF>>) {\n                                   this.popState();\n                                   return 'CONTENT';\n                                 }\n\n// nested raw block will create stacked 'raw' condition\n<raw>\"{{{{\"/[^/]                 this.begin('raw'); return 'CONTENT';\n<raw>\"{{{{/\"[^\\s!\"#%-,\\.\\/;->@\\[-\\^`\\{-~]+/[=}\\s\\/.]\"}}}}\" {\n                                  this.popState();\n                                  // Should be using `this.topState()` below, but it currently\n                                  // returns the second top instead of the first top. Opened an\n                                  // issue about it at https://github.com/zaach/jison/issues/291\n                                  if (this.conditionStack[this.conditionStack.length-1] === 'raw') {\n                                    return 'CONTENT';\n                                  } else {\n                                    strip(5, 9);\n                                    return 'END_RAW_BLOCK';\n                                  }\n                                 }\n<raw>[^\\x00]+?/(\"{{{{\")          { return 'CONTENT'; }\n\n<com>[\\s\\S]*?\"--\"{RIGHT_STRIP}?\"}}\" {\n  this.popState();\n  return 'COMMENT';\n}\n\n<mu>\"(\"                          return 'OPEN_SEXPR';\n<mu>\")\"                          return 'CLOSE_SEXPR';\n\n<mu>\"{{{{\"                       { return 'OPEN_RAW_BLOCK'; }\n<mu>\"}}}}\"                       {\n                                  this.popState();\n                                  this.begin('raw');\n                                  return 'CLOSE_RAW_BLOCK';\n                                 }\n<mu>\"{{\"{LEFT_STRIP}?\">\"         return 'OPEN_PARTIAL';\n<mu>\"{{\"{LEFT_STRIP}?\"#>\"        return 'OPEN_PARTIAL_BLOCK';\n<mu>\"{{\"{LEFT_STRIP}?\"#\"\"*\"?     return 'OPEN_BLOCK';\n<mu>\"{{\"{LEFT_STRIP}?\"/\"         return 'OPEN_ENDBLOCK';\n<mu>\"{{\"{LEFT_STRIP}?\"^\"\\s*{RIGHT_STRIP}?\"}}\"        this.popState(); return 'INVERSE';\n<mu>\"{{\"{LEFT_STRIP}?\\s*\"else\"\\s*{RIGHT_STRIP}?\"}}\"  this.popState(); return 'INVERSE';\n<mu>\"{{\"{LEFT_STRIP}?\"^\"         return 'OPEN_INVERSE';\n<mu>\"{{\"{LEFT_STRIP}?\\s*\"else\"   return 'OPEN_INVERSE_CHAIN';\n<mu>\"{{\"{LEFT_STRIP}?\"{\"         return 'OPEN_UNESCAPED';\n<mu>\"{{\"{LEFT_STRIP}?\"&\"         return 'OPEN';\n<mu>\"{{\"{LEFT_STRIP}?\"!--\" {\n  this.unput(yytext);\n  this.popState();\n  this.begin('com');\n}\n<mu>\"{{\"{LEFT_STRIP}?\"!\"[\\s\\S]*?\"}}\" {\n  this.popState();\n  return 'COMMENT';\n}\n<mu>\"{{\"{LEFT_STRIP}?\"*\"?        return 'OPEN';\n\n<mu>\"=\"                          return 'EQUALS';\n<mu>\"..\"                         return 'ID';\n<mu>\".\"/{LOOKAHEAD}              return 'ID';\n<mu>[\\/.]                        return 'SEP';\n<mu>\\s+                          // ignore whitespace\n<mu>\"}\"{RIGHT_STRIP}?\"}}\"        this.popState(); return 'CLOSE_UNESCAPED';\n<mu>{RIGHT_STRIP}?\"}}\"           this.popState(); return 'CLOSE';\n<mu>'\"'(\"\\\\\"[\"]|[^\"])*'\"'        yytext = strip(1,2).replace(/\\\\\"/g,'\"'); return 'STRING';\n<mu>\"'\"(\"\\\\\"[']|[^'])*\"'\"        yytext = strip(1,2).replace(/\\\\'/g,\"'\"); return 'STRING';\n<mu>\"@\"                          return 'DATA';\n<mu>\"true\"/{LITERAL_LOOKAHEAD}   return 'BOOLEAN';\n<mu>\"false\"/{LITERAL_LOOKAHEAD}  return 'BOOLEAN';\n<mu>\"undefined\"/{LITERAL_LOOKAHEAD} return 'UNDEFINED';\n<mu>\"null\"/{LITERAL_LOOKAHEAD}   return 'NULL';\n<mu>\\-?[0-9]+(?:\\.[0-9]+)?/{LITERAL_LOOKAHEAD} return 'NUMBER';\n<mu>\"as\"\\s+\"|\"                   return 'OPEN_BLOCK_PARAMS';\n<mu>\"|\"                          return 'CLOSE_BLOCK_PARAMS';\n\n<mu>{ID}                         return 'ID';\n\n<mu>'['('\\\\]'|[^\\]])*']'         yytext = yytext.replace(/\\\\([\\\\\\]])/g,'$1'); return 'ID';\n<mu>.                            return 'INVALID';\n\n<INITIAL,mu><<EOF>>              return 'EOF';\n"], "filenames": ["spec/helpers.js", "spec/tokenizer.js", "src/handlebars.l"], "buggy_code_start_loc": [50, 443, 66], "buggy_code_end_loc": [51, 443, 67], "fixing_code_start_loc": [50, 444, 66], "fixing_code_end_loc": [60, 449, 67], "type": "CWE-400", "message": "Handlebars before 4.4.5 allows Regular Expression Denial of Service (ReDoS) because of eager matching. The parser may be forced into an endless loop while processing crafted templates. This may allow attackers to exhaust system resources.", "other": {"cve": {"id": "CVE-2019-20922", "sourceIdentifier": "cve@mitre.org", "published": "2020-09-30T18:15:18.100", "lastModified": "2021-07-21T11:39:23.747", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Handlebars before 4.4.5 allows Regular Expression Denial of Service (ReDoS) because of eager matching. The parser may be forced into an endless loop while processing crafted templates. This may allow attackers to exhaust system resources."}, {"lang": "es", "value": "Handlebars versiones anteriores a 4.4.5, permiten una Denegaci\u00f3n de Servicio de Expresi\u00f3n Regular (ReDoS) debido a una b\u00fasqueda de coincidencias.&#xa0;El analizador puede verse forzado en un bucle infinito mientras se procesan unas plantillas dise\u00f1adas.&#xa0;Esto puede permitir a atacantes agotar los recursos del sistema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.8}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:handlebarsjs:handlebars:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "4.0.0", "versionEndExcluding": "4.4.5", "matchCriteriaId": "4F1262A9-6F18-4AFD-8E15-F4DD95F356DE"}]}]}], "references": [{"url": "https://github.com/handlebars-lang/handlebars.js/commit/8d5530ee2c3ea9f0aee3fde310b9f36887d00b8b", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JS-HANDLEBARS-480388", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.npmjs.com/advisories/1300", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/handlebars-lang/handlebars.js/commit/8d5530ee2c3ea9f0aee3fde310b9f36887d00b8b"}}