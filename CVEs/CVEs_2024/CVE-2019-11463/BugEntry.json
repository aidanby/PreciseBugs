{"buggy_code": ["/*-\n * Copyright (c) 2004-2013 Tim Kientzle\n * Copyright (c) 2011-2012,2014 Michihiro NAKAJIMA\n * Copyright (c) 2013 Konrad Kleine\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"archive_platform.h\"\n__FBSDID(\"$FreeBSD: head/lib/libarchive/archive_read_support_format_zip.c 201102 2009-12-28 03:11:36Z kientzle $\");\n\n/*\n * The definitive documentation of the Zip file format is:\n *   http://www.pkware.com/documents/casestudies/APPNOTE.TXT\n *\n * The Info-Zip project has pioneered various extensions to better\n * support Zip on Unix, including the 0x5455 \"UT\", 0x5855 \"UX\", 0x7855\n * \"Ux\", and 0x7875 \"ux\" extensions for time and ownership\n * information.\n *\n * History of this code: The streaming Zip reader was first added to\n * libarchive in January 2005.  Support for seekable input sources was\n * added in Nov 2011.  Zip64 support (including a significant code\n * refactoring) was added in 2014.\n */\n\n#ifdef HAVE_ERRNO_H\n#include <errno.h>\n#endif\n#ifdef HAVE_STDLIB_H\n#include <stdlib.h>\n#endif\n#ifdef HAVE_ZLIB_H\n#include <zlib.h>\n#endif\n#ifdef HAVE_BZLIB_H\n#include <bzlib.h>\n#endif\n#ifdef HAVE_LZMA_H\n#include <lzma.h>\n#endif\n\n#include \"archive.h\"\n#include \"archive_digest_private.h\"\n#include \"archive_cryptor_private.h\"\n#include \"archive_endian.h\"\n#include \"archive_entry.h\"\n#include \"archive_entry_locale.h\"\n#include \"archive_hmac_private.h\"\n#include \"archive_private.h\"\n#include \"archive_rb.h\"\n#include \"archive_read_private.h\"\n#include \"archive_ppmd8_private.h\"\n\n#ifndef HAVE_ZLIB_H\n#include \"archive_crc32.h\"\n#endif\n\nstruct zip_entry {\n\tstruct archive_rb_node\tnode;\n\tstruct zip_entry\t*next;\n\tint64_t\t\t\tlocal_header_offset;\n\tint64_t\t\t\tcompressed_size;\n\tint64_t\t\t\tuncompressed_size;\n\tint64_t\t\t\tgid;\n\tint64_t\t\t\tuid;\n\tstruct archive_string\trsrcname;\n\ttime_t\t\t\tmtime;\n\ttime_t\t\t\tatime;\n\ttime_t\t\t\tctime;\n\tuint32_t\t\tcrc32;\n\tuint16_t\t\tmode;\n\tuint16_t\t\tzip_flags; /* From GP Flags Field */\n\tunsigned char\t\tcompression;\n\tunsigned char\t\tsystem; /* From \"version written by\" */\n\tunsigned char\t\tflags; /* Our extra markers. */\n\tunsigned char\t\tdecdat;/* Used for Decryption check */\n\n\t/* WinZip AES encryption extra field should be available\n\t * when compression is 99. */\n\tstruct {\n\t\t/* Vendor version: AE-1 - 0x0001, AE-2 - 0x0002 */\n\t\tunsigned\tvendor;\n#define AES_VENDOR_AE_1\t0x0001\n#define AES_VENDOR_AE_2\t0x0002\n\t\t/* AES encryption strength:\n\t\t * 1 - 128 bits, 2 - 192 bits, 2 - 256 bits. */\n\t\tunsigned\tstrength;\n\t\t/* Actual compression method. */\n\t\tunsigned char\tcompression;\n\t}\t\t\taes_extra;\n};\n\nstruct trad_enc_ctx {\n\tuint32_t\tkeys[3];\n};\n\n/* Bits used in zip_flags. */\n#define ZIP_ENCRYPTED\t(1 << 0)\n#define ZIP_LENGTH_AT_END\t(1 << 3)\n#define ZIP_STRONG_ENCRYPTED\t(1 << 6)\n#define ZIP_UTF8_NAME\t(1 << 11)\n/* See \"7.2 Single Password Symmetric Encryption Method\"\n   in http://www.pkware.com/documents/casestudies/APPNOTE.TXT */\n#define ZIP_CENTRAL_DIRECTORY_ENCRYPTED\t(1 << 13)\n\n/* Bits used in flags. */\n#define LA_USED_ZIP64\t(1 << 0)\n#define LA_FROM_CENTRAL_DIRECTORY (1 << 1)\n\n/*\n * See \"WinZip - AES Encryption Information\"\n *     http://www.winzip.com/aes_info.htm\n */\n/* Value used in compression method. */\n#define WINZIP_AES_ENCRYPTION\t99\n/* Authentication code size. */\n#define AUTH_CODE_SIZE\t10\n/**/\n#define MAX_DERIVED_KEY_BUF_SIZE\t(AES_MAX_KEY_SIZE * 2 + 2)\n\nstruct zip {\n\t/* Structural information about the archive. */\n\tstruct archive_string\tformat_name;\n\tint64_t\t\t\tcentral_directory_offset;\n\tsize_t\t\t\tcentral_directory_entries_total;\n\tsize_t\t\t\tcentral_directory_entries_on_this_disk;\n\tint\t\t\thas_encrypted_entries;\n\n\t/* List of entries (seekable Zip only) */\n\tstruct zip_entry\t*zip_entries;\n\tstruct archive_rb_tree\ttree;\n\tstruct archive_rb_tree\ttree_rsrc;\n\n\t/* Bytes read but not yet consumed via __archive_read_consume() */\n\tsize_t\t\t\tunconsumed;\n\n\t/* Information about entry we're currently reading. */\n\tstruct zip_entry\t*entry;\n\tint64_t\t\t\tentry_bytes_remaining;\n\n\t/* These count the number of bytes actually read for the entry. */\n\tint64_t\t\t\tentry_compressed_bytes_read;\n\tint64_t\t\t\tentry_uncompressed_bytes_read;\n\n\t/* Running CRC32 of the decompressed data */\n\tunsigned long\t\tentry_crc32;\n\tunsigned long\t\t(*crc32func)(unsigned long, const void *,\n\t\t\t\t    size_t);\n\tchar\t\t\tignore_crc32;\n\n\t/* Flags to mark progress of decompression. */\n\tchar\t\t\tdecompress_init;\n\tchar\t\t\tend_of_entry;\n\n\tunsigned char \t\t*uncompressed_buffer;\n\tsize_t \t\t\tuncompressed_buffer_size;\n\n#ifdef HAVE_ZLIB_H\n\tz_stream\t\tstream;\n\tchar\t\t\tstream_valid;\n#endif\n\n#if HAVE_LZMA_H && HAVE_LIBLZMA\n\tlzma_stream\t\tzipx_lzma_stream;\n\tchar            zipx_lzma_valid;\n#endif\n\n#ifdef HAVE_BZLIB_H\n\tbz_stream\t\tbzstream;\n\tchar            bzstream_valid;\n#endif\n\n\tIByteIn\t\t\tzipx_ppmd_stream;\n\tssize_t\t\t\tzipx_ppmd_read_compressed;\n\tCPpmd8\t\t\tppmd8;\n\tchar\t\t\tppmd8_valid;\n\tchar\t\t\tppmd8_stream_failed;\n\n\tstruct archive_string_conv *sconv;\n\tstruct archive_string_conv *sconv_default;\n\tstruct archive_string_conv *sconv_utf8;\n\tint\t\t\tinit_default_conversion;\n\tint\t\t\tprocess_mac_extensions;\n\n\tchar\t\t\tinit_decryption;\n\n\t/* Decryption buffer. */\n\t/*\n\t * The decrypted data starts at decrypted_ptr and\n\t * extends for decrypted_bytes_remaining.  Decryption\n\t * adds new data to the end of this block, data is returned\n\t * to clients from the beginning.  When the block hits the\n\t * end of decrypted_buffer, it has to be shuffled back to\n\t * the beginning of the buffer.\n\t */\n\tunsigned char \t\t*decrypted_buffer;\n\tunsigned char \t\t*decrypted_ptr;\n\tsize_t \t\t\tdecrypted_buffer_size;\n\tsize_t \t\t\tdecrypted_bytes_remaining;\n\tsize_t \t\t\tdecrypted_unconsumed_bytes;\n\n\t/* Traditional PKWARE decryption. */\n\tstruct trad_enc_ctx\ttctx;\n\tchar\t\t\ttctx_valid;\n\n\t/* WinZip AES decryption. */\n\t/* Contexts used for AES decryption. */\n\tarchive_crypto_ctx\tcctx;\n\tchar\t\t\tcctx_valid;\n\tarchive_hmac_sha1_ctx\thctx;\n\tchar\t\t\thctx_valid;\n\n\t/* Strong encryption's decryption header information. */\n\tunsigned\t\tiv_size;\n\tunsigned\t\talg_id;\n\tunsigned\t\tbit_len;\n\tunsigned\t\tflags;\n\tunsigned\t\terd_size;\n\tunsigned\t\tv_size;\n\tunsigned\t\tv_crc32;\n\tuint8_t\t\t\t*iv;\n\tuint8_t\t\t\t*erd;\n\tuint8_t\t\t\t*v_data;\n};\n\n/* Many systems define min or MIN, but not all. */\n#define\tzipmin(a,b) ((a) < (b) ? (a) : (b))\n\n/* This function is used by Ppmd8_DecodeSymbol during decompression of Ppmd8\n * streams inside ZIP files. It has 2 purposes: one is to fetch the next\n * compressed byte from the stream, second one is to increase the counter how\n * many compressed bytes were read. */\nstatic Byte\nppmd_read(void* p) {\n\t/* Get the handle to current decompression context. */\n\tstruct archive_read *a = ((IByteIn*)p)->a;\n\tstruct zip *zip = (struct zip*) a->format->data;\n\tssize_t bytes_avail = 0;\n\n\t/* Fetch next byte. */\n\tconst uint8_t* data = __archive_read_ahead(a, 1, &bytes_avail);\n\tif(bytes_avail < 1) {\n\t\tzip->ppmd8_stream_failed = 1;\n\t\treturn 0;\n\t}\n\n\t__archive_read_consume(a, 1);\n\n\t/* Increment the counter. */\n\t++zip->zipx_ppmd_read_compressed;\n\n\t/* Return the next compressed byte. */\n\treturn data[0];\n}\n\n/* ------------------------------------------------------------------------ */\n\n/*\n  Traditional PKWARE Decryption functions.\n */\n\nstatic void\ntrad_enc_update_keys(struct trad_enc_ctx *ctx, uint8_t c)\n{\n\tuint8_t t;\n#define CRC32(c, b) (crc32(c ^ 0xffffffffUL, &b, 1) ^ 0xffffffffUL)\n\n\tctx->keys[0] = CRC32(ctx->keys[0], c);\n\tctx->keys[1] = (ctx->keys[1] + (ctx->keys[0] & 0xff)) * 134775813L + 1;\n\tt = (ctx->keys[1] >> 24) & 0xff;\n\tctx->keys[2] = CRC32(ctx->keys[2], t);\n#undef CRC32\n}\n\nstatic uint8_t\ntrad_enc_decrypt_byte(struct trad_enc_ctx *ctx)\n{\n\tunsigned temp = ctx->keys[2] | 2;\n\treturn (uint8_t)((temp * (temp ^ 1)) >> 8) & 0xff;\n}\n\nstatic void\ntrad_enc_decrypt_update(struct trad_enc_ctx *ctx, const uint8_t *in,\n    size_t in_len, uint8_t *out, size_t out_len)\n{\n\tunsigned i, max;\n\n\tmax = (unsigned)((in_len < out_len)? in_len: out_len);\n\n\tfor (i = 0; i < max; i++) {\n\t\tuint8_t t = in[i] ^ trad_enc_decrypt_byte(ctx);\n\t\tout[i] = t;\n\t\ttrad_enc_update_keys(ctx, t);\n\t}\n}\n\nstatic int\ntrad_enc_init(struct trad_enc_ctx *ctx, const char *pw, size_t pw_len,\n    const uint8_t *key, size_t key_len, uint8_t *crcchk)\n{\n\tuint8_t header[12];\n\n\tif (key_len < 12) {\n\t\t*crcchk = 0xff;\n\t\treturn -1;\n\t}\n\n\tctx->keys[0] = 305419896L;\n\tctx->keys[1] = 591751049L;\n\tctx->keys[2] = 878082192L;\n\n\tfor (;pw_len; --pw_len)\n\t\ttrad_enc_update_keys(ctx, *pw++);\n\n\ttrad_enc_decrypt_update(ctx, key, 12, header, 12);\n\t/* Return the last byte for CRC check. */\n\t*crcchk = header[11];\n\treturn 0;\n}\n\n#if 0\nstatic void\ncrypt_derive_key_sha1(const void *p, int size, unsigned char *key,\n    int key_size)\n{\n#define MD_SIZE 20\n\tarchive_sha1_ctx ctx;\n\tunsigned char md1[MD_SIZE];\n\tunsigned char md2[MD_SIZE * 2];\n\tunsigned char mkb[64];\n\tint i;\n\n\tarchive_sha1_init(&ctx);\n\tarchive_sha1_update(&ctx, p, size);\n\tarchive_sha1_final(&ctx, md1);\n\n\tmemset(mkb, 0x36, sizeof(mkb));\n\tfor (i = 0; i < MD_SIZE; i++)\n\t\tmkb[i] ^= md1[i];\n\tarchive_sha1_init(&ctx);\n\tarchive_sha1_update(&ctx, mkb, sizeof(mkb));\n\tarchive_sha1_final(&ctx, md2);\n\n\tmemset(mkb, 0x5C, sizeof(mkb));\n\tfor (i = 0; i < MD_SIZE; i++)\n\t\tmkb[i] ^= md1[i];\n\tarchive_sha1_init(&ctx);\n\tarchive_sha1_update(&ctx, mkb, sizeof(mkb));\n\tarchive_sha1_final(&ctx, md2 + MD_SIZE);\n\n\tif (key_size > 32)\n\t\tkey_size = 32;\n\tmemcpy(key, md2, key_size);\n#undef MD_SIZE\n}\n#endif\n\n/*\n * Common code for streaming or seeking modes.\n *\n * Includes code to read local file headers, decompress data\n * from entry bodies, and common API.\n */\n\nstatic unsigned long\nreal_crc32(unsigned long crc, const void *buff, size_t len)\n{\n\treturn crc32(crc, buff, (unsigned int)len);\n}\n\n/* Used by \"ignorecrc32\" option to speed up tests. */\nstatic unsigned long\nfake_crc32(unsigned long crc, const void *buff, size_t len)\n{\n\t(void)crc; /* UNUSED */\n\t(void)buff; /* UNUSED */\n\t(void)len; /* UNUSED */\n\treturn 0;\n}\n\nstatic const struct {\n\tint id;\n\tconst char * name;\n} compression_methods[] = {\n\t{0, \"uncompressed\"}, /* The file is stored (no compression) */\n\t{1, \"shrinking\"}, /* The file is Shrunk */\n\t{2, \"reduced-1\"}, /* The file is Reduced with compression factor 1 */\n\t{3, \"reduced-2\"}, /* The file is Reduced with compression factor 2 */\n\t{4, \"reduced-3\"}, /* The file is Reduced with compression factor 3 */\n\t{5, \"reduced-4\"}, /* The file is Reduced with compression factor 4 */\n\t{6, \"imploded\"},  /* The file is Imploded */\n\t{7, \"reserved\"},  /* Reserved for Tokenizing compression algorithm */\n\t{8, \"deflation\"}, /* The file is Deflated */\n\t{9, \"deflation-64-bit\"}, /* Enhanced Deflating using Deflate64(tm) */\n\t{10, \"ibm-terse\"},/* PKWARE Data Compression Library Imploding\n\t\t\t   * (old IBM TERSE) */\n\t{11, \"reserved\"}, /* Reserved by PKWARE */\n\t{12, \"bzip\"},     /* File is compressed using BZIP2 algorithm */\n\t{13, \"reserved\"}, /* Reserved by PKWARE */\n\t{14, \"lzma\"},     /* LZMA (EFS) */\n\t{15, \"reserved\"}, /* Reserved by PKWARE */\n\t{16, \"reserved\"}, /* Reserved by PKWARE */\n\t{17, \"reserved\"}, /* Reserved by PKWARE */\n\t{18, \"ibm-terse-new\"}, /* File is compressed using IBM TERSE (new) */\n\t{19, \"ibm-lz777\"},/* IBM LZ77 z Architecture (PFS) */\n\t{95, \"xz\"},       /* XZ compressed data */\n\t{96, \"jpeg\"},     /* JPEG compressed data */\n\t{97, \"wav-pack\"}, /* WavPack compressed data */\n\t{98, \"ppmd-1\"},   /* PPMd version I, Rev 1 */\n\t{99, \"aes\"}       /* WinZip AES encryption  */\n};\n\nstatic const char *\ncompression_name(const int compression)\n{\n\tstatic const int num_compression_methods =\n\t\tsizeof(compression_methods)/sizeof(compression_methods[0]);\n\tint i=0;\n\n\twhile(compression >= 0 && i < num_compression_methods) {\n\t\tif (compression_methods[i].id == compression)\n\t\t\treturn compression_methods[i].name;\n\t\ti++;\n\t}\n\treturn \"??\";\n}\n\n/* Convert an MSDOS-style date/time into Unix-style time. */\nstatic time_t\nzip_time(const char *p)\n{\n\tint msTime, msDate;\n\tstruct tm ts;\n\n\tmsTime = (0xff & (unsigned)p[0]) + 256 * (0xff & (unsigned)p[1]);\n\tmsDate = (0xff & (unsigned)p[2]) + 256 * (0xff & (unsigned)p[3]);\n\n\tmemset(&ts, 0, sizeof(ts));\n\tts.tm_year = ((msDate >> 9) & 0x7f) + 80; /* Years since 1900. */\n\tts.tm_mon = ((msDate >> 5) & 0x0f) - 1; /* Month number. */\n\tts.tm_mday = msDate & 0x1f; /* Day of month. */\n\tts.tm_hour = (msTime >> 11) & 0x1f;\n\tts.tm_min = (msTime >> 5) & 0x3f;\n\tts.tm_sec = (msTime << 1) & 0x3e;\n\tts.tm_isdst = -1;\n\treturn mktime(&ts);\n}\n\n/*\n * The extra data is stored as a list of\n *\tid1+size1+data1 + id2+size2+data2 ...\n *  triplets.  id and size are 2 bytes each.\n */\nstatic int\nprocess_extra(struct archive_read *a, const char *p, size_t extra_length, struct zip_entry* zip_entry)\n{\n\tunsigned offset = 0;\n\n\tif (extra_length == 0) {\n\t\treturn ARCHIVE_OK;\n\t}\n\n\tif (extra_length < 4) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Too-small extra data: Need at least 4 bytes, but only found %d bytes\", (int)extra_length);\n\t\treturn ARCHIVE_FAILED;\n\t}\n\twhile (offset <= extra_length - 4) {\n\t\tunsigned short headerid = archive_le16dec(p + offset);\n\t\tunsigned short datasize = archive_le16dec(p + offset + 2);\n\n\t\toffset += 4;\n\t\tif (offset + datasize > extra_length) {\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Extra data overflow: Need %d bytes but only found %d bytes\",\n\t\t\t    (int)datasize, (int)(extra_length - offset));\n\t\t\treturn ARCHIVE_FAILED;\n\t\t}\n#ifdef DEBUG\n\t\tfprintf(stderr, \"Header id 0x%04x, length %d\\n\",\n\t\t    headerid, datasize);\n#endif\n\t\tswitch (headerid) {\n\t\tcase 0x0001:\n\t\t\t/* Zip64 extended information extra field. */\n\t\t\tzip_entry->flags |= LA_USED_ZIP64;\n\t\t\tif (zip_entry->uncompressed_size == 0xffffffff) {\n\t\t\t\tuint64_t t = 0;\n\t\t\t\tif (datasize < 8\n\t\t\t\t    || (t = archive_le64dec(p + offset)) > INT64_MAX) {\n\t\t\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t\t    \"Malformed 64-bit uncompressed size\");\n\t\t\t\t\treturn ARCHIVE_FAILED;\n\t\t\t\t}\n\t\t\t\tzip_entry->uncompressed_size = t;\n\t\t\t\toffset += 8;\n\t\t\t\tdatasize -= 8;\n\t\t\t}\n\t\t\tif (zip_entry->compressed_size == 0xffffffff) {\n\t\t\t\tuint64_t t = 0;\n\t\t\t\tif (datasize < 8\n\t\t\t\t    || (t = archive_le64dec(p + offset)) > INT64_MAX) {\n\t\t\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t\t    \"Malformed 64-bit compressed size\");\n\t\t\t\t\treturn ARCHIVE_FAILED;\n\t\t\t\t}\n\t\t\t\tzip_entry->compressed_size = t;\n\t\t\t\toffset += 8;\n\t\t\t\tdatasize -= 8;\n\t\t\t}\n\t\t\tif (zip_entry->local_header_offset == 0xffffffff) {\n\t\t\t\tuint64_t t = 0;\n\t\t\t\tif (datasize < 8\n\t\t\t\t    || (t = archive_le64dec(p + offset)) > INT64_MAX) {\n\t\t\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t\t    \"Malformed 64-bit local header offset\");\n\t\t\t\t\treturn ARCHIVE_FAILED;\n\t\t\t\t}\n\t\t\t\tzip_entry->local_header_offset = t;\n\t\t\t\toffset += 8;\n\t\t\t\tdatasize -= 8;\n\t\t\t}\n\t\t\t/* archive_le32dec(p + offset) gives disk\n\t\t\t * on which file starts, but we don't handle\n\t\t\t * multi-volume Zip files. */\n\t\t\tbreak;\n#ifdef DEBUG\n\t\tcase 0x0017:\n\t\t{\n\t\t\t/* Strong encryption field. */\n\t\t\tif (archive_le16dec(p + offset) == 2) {\n\t\t\t\tunsigned algId =\n\t\t\t\t\tarchive_le16dec(p + offset + 2);\n\t\t\t\tunsigned bitLen =\n\t\t\t\t\tarchive_le16dec(p + offset + 4);\n\t\t\t\tint\t flags =\n\t\t\t\t\tarchive_le16dec(p + offset + 6);\n\t\t\t\tfprintf(stderr, \"algId=0x%04x, bitLen=%u, \"\n\t\t\t\t    \"flgas=%d\\n\", algId, bitLen,flags);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tcase 0x5455:\n\t\t{\n\t\t\t/* Extended time field \"UT\". */\n\t\t\tint flags;\n\t\t\tif (datasize == 0) {\n\t\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \"Incomplete extended time field\");\n\t\t\t\treturn ARCHIVE_FAILED;\n\t\t\t}\n\t\t\tflags = p[offset];\n\t\t\toffset++;\n\t\t\tdatasize--;\n\t\t\t/* Flag bits indicate which dates are present. */\n\t\t\tif (flags & 0x01)\n\t\t\t{\n#ifdef DEBUG\n\t\t\t\tfprintf(stderr, \"mtime: %lld -> %d\\n\",\n\t\t\t\t    (long long)zip_entry->mtime,\n\t\t\t\t    archive_le32dec(p + offset));\n#endif\n\t\t\t\tif (datasize < 4)\n\t\t\t\t\tbreak;\n\t\t\t\tzip_entry->mtime = archive_le32dec(p + offset);\n\t\t\t\toffset += 4;\n\t\t\t\tdatasize -= 4;\n\t\t\t}\n\t\t\tif (flags & 0x02)\n\t\t\t{\n\t\t\t\tif (datasize < 4)\n\t\t\t\t\tbreak;\n\t\t\t\tzip_entry->atime = archive_le32dec(p + offset);\n\t\t\t\toffset += 4;\n\t\t\t\tdatasize -= 4;\n\t\t\t}\n\t\t\tif (flags & 0x04)\n\t\t\t{\n\t\t\t\tif (datasize < 4)\n\t\t\t\t\tbreak;\n\t\t\t\tzip_entry->ctime = archive_le32dec(p + offset);\n\t\t\t\toffset += 4;\n\t\t\t\tdatasize -= 4;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase 0x5855:\n\t\t{\n\t\t\t/* Info-ZIP Unix Extra Field (old version) \"UX\". */\n\t\t\tif (datasize >= 8) {\n\t\t\t\tzip_entry->atime = archive_le32dec(p + offset);\n\t\t\t\tzip_entry->mtime =\n\t\t\t\t    archive_le32dec(p + offset + 4);\n\t\t\t}\n\t\t\tif (datasize >= 12) {\n\t\t\t\tzip_entry->uid =\n\t\t\t\t    archive_le16dec(p + offset + 8);\n\t\t\t\tzip_entry->gid =\n\t\t\t\t    archive_le16dec(p + offset + 10);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase 0x6c78:\n\t\t{\n\t\t\t/* Experimental 'xl' field */\n\t\t\t/*\n\t\t\t * Introduced Dec 2013 to provide a way to\n\t\t\t * include external file attributes (and other\n\t\t\t * fields that ordinarily appear only in\n\t\t\t * central directory) in local file header.\n\t\t\t * This provides file type and permission\n\t\t\t * information necessary to support full\n\t\t\t * streaming extraction.  Currently being\n\t\t\t * discussed with other Zip developers\n\t\t\t * ... subject to change.\n\t\t\t *\n\t\t\t * Format:\n\t\t\t *  The field starts with a bitmap that specifies\n\t\t\t *  which additional fields are included.  The\n\t\t\t *  bitmap is variable length and can be extended in\n\t\t\t *  the future.\n\t\t\t *\n\t\t\t *  n bytes - feature bitmap: first byte has low-order\n\t\t\t *    7 bits.  If high-order bit is set, a subsequent\n\t\t\t *    byte holds the next 7 bits, etc.\n\t\t\t *\n\t\t\t *  if bitmap & 1, 2 byte \"version made by\"\n\t\t\t *  if bitmap & 2, 2 byte \"internal file attributes\"\n\t\t\t *  if bitmap & 4, 4 byte \"external file attributes\"\n\t\t\t *  if bitmap & 8, 2 byte comment length + n byte comment\n\t\t\t */\n\t\t\tint bitmap, bitmap_last;\n\n\t\t\tif (datasize < 1)\n\t\t\t\tbreak;\n\t\t\tbitmap_last = bitmap = 0xff & p[offset];\n\t\t\toffset += 1;\n\t\t\tdatasize -= 1;\n\n\t\t\t/* We only support first 7 bits of bitmap; skip rest. */\n\t\t\twhile ((bitmap_last & 0x80) != 0\n\t\t\t    && datasize >= 1) {\n\t\t\t\tbitmap_last = p[offset];\n\t\t\t\toffset += 1;\n\t\t\t\tdatasize -= 1;\n\t\t\t}\n\n\t\t\tif (bitmap & 1) {\n\t\t\t\t/* 2 byte \"version made by\" */\n\t\t\t\tif (datasize < 2)\n\t\t\t\t\tbreak;\n\t\t\t\tzip_entry->system\n\t\t\t\t    = archive_le16dec(p + offset) >> 8;\n\t\t\t\toffset += 2;\n\t\t\t\tdatasize -= 2;\n\t\t\t}\n\t\t\tif (bitmap & 2) {\n\t\t\t\t/* 2 byte \"internal file attributes\" */\n\t\t\t\tuint32_t internal_attributes;\n\t\t\t\tif (datasize < 2)\n\t\t\t\t\tbreak;\n\t\t\t\tinternal_attributes\n\t\t\t\t    = archive_le16dec(p + offset);\n\t\t\t\t/* Not used by libarchive at present. */\n\t\t\t\t(void)internal_attributes; /* UNUSED */\n\t\t\t\toffset += 2;\n\t\t\t\tdatasize -= 2;\n\t\t\t}\n\t\t\tif (bitmap & 4) {\n\t\t\t\t/* 4 byte \"external file attributes\" */\n\t\t\t\tuint32_t external_attributes;\n\t\t\t\tif (datasize < 4)\n\t\t\t\t\tbreak;\n\t\t\t\texternal_attributes\n\t\t\t\t    = archive_le32dec(p + offset);\n\t\t\t\tif (zip_entry->system == 3) {\n\t\t\t\t\tzip_entry->mode\n\t\t\t\t\t    = external_attributes >> 16;\n\t\t\t\t} else if (zip_entry->system == 0) {\n\t\t\t\t\t// Interpret MSDOS directory bit\n\t\t\t\t\tif (0x10 == (external_attributes & 0x10)) {\n\t\t\t\t\t\tzip_entry->mode = AE_IFDIR | 0775;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tzip_entry->mode = AE_IFREG | 0664;\n\t\t\t\t\t}\n\t\t\t\t\tif (0x01 == (external_attributes & 0x01)) {\n\t\t\t\t\t\t// Read-only bit; strip write permissions\n\t\t\t\t\t\tzip_entry->mode &= 0555;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tzip_entry->mode = 0;\n\t\t\t\t}\n\t\t\t\toffset += 4;\n\t\t\t\tdatasize -= 4;\n\t\t\t}\n\t\t\tif (bitmap & 8) {\n\t\t\t\t/* 2 byte comment length + comment */\n\t\t\t\tuint32_t comment_length;\n\t\t\t\tif (datasize < 2)\n\t\t\t\t\tbreak;\n\t\t\t\tcomment_length\n\t\t\t\t    = archive_le16dec(p + offset);\n\t\t\t\toffset += 2;\n\t\t\t\tdatasize -= 2;\n\n\t\t\t\tif (datasize < comment_length)\n\t\t\t\t\tbreak;\n\t\t\t\t/* Comment is not supported by libarchive */\n\t\t\t\toffset += comment_length;\n\t\t\t\tdatasize -= comment_length;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase 0x7855:\n\t\t\t/* Info-ZIP Unix Extra Field (type 2) \"Ux\". */\n#ifdef DEBUG\n\t\t\tfprintf(stderr, \"uid %d gid %d\\n\",\n\t\t\t    archive_le16dec(p + offset),\n\t\t\t    archive_le16dec(p + offset + 2));\n#endif\n\t\t\tif (datasize >= 2)\n\t\t\t\tzip_entry->uid = archive_le16dec(p + offset);\n\t\t\tif (datasize >= 4)\n\t\t\t\tzip_entry->gid =\n\t\t\t\t    archive_le16dec(p + offset + 2);\n\t\t\tbreak;\n\t\tcase 0x7875:\n\t\t{\n\t\t\t/* Info-Zip Unix Extra Field (type 3) \"ux\". */\n\t\t\tint uidsize = 0, gidsize = 0;\n\n\t\t\t/* TODO: support arbitrary uidsize/gidsize. */\n\t\t\tif (datasize >= 1 && p[offset] == 1) {/* version=1 */\n\t\t\t\tif (datasize >= 4) {\n\t\t\t\t\t/* get a uid size. */\n\t\t\t\t\tuidsize = 0xff & (int)p[offset+1];\n\t\t\t\t\tif (uidsize == 2)\n\t\t\t\t\t\tzip_entry->uid =\n\t\t\t\t\t\t    archive_le16dec(\n\t\t\t\t\t\t        p + offset + 2);\n\t\t\t\t\telse if (uidsize == 4 && datasize >= 6)\n\t\t\t\t\t\tzip_entry->uid =\n\t\t\t\t\t\t    archive_le32dec(\n\t\t\t\t\t\t        p + offset + 2);\n\t\t\t\t}\n\t\t\t\tif (datasize >= (2 + uidsize + 3)) {\n\t\t\t\t\t/* get a gid size. */\n\t\t\t\t\tgidsize = 0xff & (int)p[offset+2+uidsize];\n\t\t\t\t\tif (gidsize == 2)\n\t\t\t\t\t\tzip_entry->gid =\n\t\t\t\t\t\t    archive_le16dec(\n\t\t\t\t\t\t        p+offset+2+uidsize+1);\n\t\t\t\t\telse if (gidsize == 4 &&\n\t\t\t\t\t    datasize >= (2 + uidsize + 5))\n\t\t\t\t\t\tzip_entry->gid =\n\t\t\t\t\t\t    archive_le32dec(\n\t\t\t\t\t\t        p+offset+2+uidsize+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase 0x9901:\n\t\t\t/* WinZip AES extra data field. */\n\t\t\tif (datasize < 6) {\n\t\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \"Incomplete AES field\");\n\t\t\t\treturn ARCHIVE_FAILED;\n\t\t\t}\n\t\t\tif (p[offset + 2] == 'A' && p[offset + 3] == 'E') {\n\t\t\t\t/* Vendor version. */\n\t\t\t\tzip_entry->aes_extra.vendor =\n\t\t\t\t    archive_le16dec(p + offset);\n\t\t\t\t/* AES encryption strength. */\n\t\t\t\tzip_entry->aes_extra.strength = p[offset + 4];\n\t\t\t\t/* Actual compression method. */\n\t\t\t\tzip_entry->aes_extra.compression =\n\t\t\t\t    p[offset + 5];\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\toffset += datasize;\n\t}\n\tif (offset != extra_length) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Malformed extra data: Consumed %d bytes of %d bytes\",\n\t\t    (int)offset, (int)extra_length);\n\t\treturn ARCHIVE_FAILED;\n\t}\n\treturn ARCHIVE_OK;\n}\n\n/*\n * Assumes file pointer is at beginning of local file header.\n */\nstatic int\nzip_read_local_file_header(struct archive_read *a, struct archive_entry *entry,\n    struct zip *zip)\n{\n\tconst char *p;\n\tconst void *h;\n\tconst wchar_t *wp;\n\tconst char *cp;\n\tsize_t len, filename_length, extra_length;\n\tstruct archive_string_conv *sconv;\n\tstruct zip_entry *zip_entry = zip->entry;\n\tstruct zip_entry zip_entry_central_dir;\n\tint ret = ARCHIVE_OK;\n\tchar version;\n\n\t/* Save a copy of the original for consistency checks. */\n\tzip_entry_central_dir = *zip_entry;\n\n\tzip->decompress_init = 0;\n\tzip->end_of_entry = 0;\n\tzip->entry_uncompressed_bytes_read = 0;\n\tzip->entry_compressed_bytes_read = 0;\n\tzip->entry_crc32 = zip->crc32func(0, NULL, 0);\n\n\t/* Setup default conversion. */\n\tif (zip->sconv == NULL && !zip->init_default_conversion) {\n\t\tzip->sconv_default =\n\t\t    archive_string_default_conversion_for_read(&(a->archive));\n\t\tzip->init_default_conversion = 1;\n\t}\n\n\tif ((p = __archive_read_ahead(a, 30, NULL)) == NULL) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Truncated ZIP file header\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\tif (memcmp(p, \"PK\\003\\004\", 4) != 0) {\n\t\tarchive_set_error(&a->archive, -1, \"Damaged Zip archive\");\n\t\treturn ARCHIVE_FATAL;\n\t}\n\tversion = p[4];\n\tzip_entry->system = p[5];\n\tzip_entry->zip_flags = archive_le16dec(p + 6);\n\tif (zip_entry->zip_flags & (ZIP_ENCRYPTED | ZIP_STRONG_ENCRYPTED)) {\n\t\tzip->has_encrypted_entries = 1;\n\t\tarchive_entry_set_is_data_encrypted(entry, 1);\n\t\tif (zip_entry->zip_flags & ZIP_CENTRAL_DIRECTORY_ENCRYPTED &&\n\t\t\tzip_entry->zip_flags & ZIP_ENCRYPTED &&\n\t\t\tzip_entry->zip_flags & ZIP_STRONG_ENCRYPTED) {\n\t\t\tarchive_entry_set_is_metadata_encrypted(entry, 1);\n\t\t\treturn ARCHIVE_FATAL;\n\t\t}\n\t}\n\tzip->init_decryption = (zip_entry->zip_flags & ZIP_ENCRYPTED);\n\tzip_entry->compression = (char)archive_le16dec(p + 8);\n\tzip_entry->mtime = zip_time(p + 10);\n\tzip_entry->crc32 = archive_le32dec(p + 14);\n\tif (zip_entry->zip_flags & ZIP_LENGTH_AT_END)\n\t\tzip_entry->decdat = p[11];\n\telse\n\t\tzip_entry->decdat = p[17];\n\tzip_entry->compressed_size = archive_le32dec(p + 18);\n\tzip_entry->uncompressed_size = archive_le32dec(p + 22);\n\tfilename_length = archive_le16dec(p + 26);\n\textra_length = archive_le16dec(p + 28);\n\n\t__archive_read_consume(a, 30);\n\n\t/* Read the filename. */\n\tif ((h = __archive_read_ahead(a, filename_length, NULL)) == NULL) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Truncated ZIP file header\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\tif (zip_entry->zip_flags & ZIP_UTF8_NAME) {\n\t\t/* The filename is stored to be UTF-8. */\n\t\tif (zip->sconv_utf8 == NULL) {\n\t\t\tzip->sconv_utf8 =\n\t\t\t    archive_string_conversion_from_charset(\n\t\t\t\t&a->archive, \"UTF-8\", 1);\n\t\t\tif (zip->sconv_utf8 == NULL)\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tsconv = zip->sconv_utf8;\n\t} else if (zip->sconv != NULL)\n\t\tsconv = zip->sconv;\n\telse\n\t\tsconv = zip->sconv_default;\n\n\tif (archive_entry_copy_pathname_l(entry,\n\t    h, filename_length, sconv) != 0) {\n\t\tif (errno == ENOMEM) {\n\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t    \"Can't allocate memory for Pathname\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tarchive_set_error(&a->archive,\n\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Pathname cannot be converted \"\n\t\t    \"from %s to current locale.\",\n\t\t    archive_string_conversion_charset_name(sconv));\n\t\tret = ARCHIVE_WARN;\n\t}\n\t__archive_read_consume(a, filename_length);\n\n\t/* Read the extra data. */\n\tif ((h = __archive_read_ahead(a, extra_length, NULL)) == NULL) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Truncated ZIP file header\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\tif (ARCHIVE_OK != process_extra(a, h, extra_length, zip_entry)) {\n\t\treturn ARCHIVE_FATAL;\n\t}\n\t__archive_read_consume(a, extra_length);\n\n\t/* Work around a bug in Info-Zip: When reading from a pipe, it\n\t * stats the pipe instead of synthesizing a file entry. */\n\tif ((zip_entry->mode & AE_IFMT) == AE_IFIFO) {\n\t\tzip_entry->mode &= ~ AE_IFMT;\n\t\tzip_entry->mode |= AE_IFREG;\n\t}\n\n\t/* If the mode is totally empty, set some sane default. */\n\tif (zip_entry->mode == 0) {\n\t\tzip_entry->mode |= 0664;\n\t}\n\n\t/* Windows archivers sometimes use backslash as the directory separator.\n\t   Normalize to slash. */\n\tif (zip_entry->system == 0 &&\n\t    (wp = archive_entry_pathname_w(entry)) != NULL) {\n\t\tif (wcschr(wp, L'/') == NULL && wcschr(wp, L'\\\\') != NULL) {\n\t\t\tsize_t i;\n\t\t\tstruct archive_wstring s;\n\t\t\tarchive_string_init(&s);\n\t\t\tarchive_wstrcpy(&s, wp);\n\t\t\tfor (i = 0; i < archive_strlen(&s); i++) {\n\t\t\t\tif (s.s[i] == '\\\\')\n\t\t\t\t\ts.s[i] = '/';\n\t\t\t}\n\t\t\tarchive_entry_copy_pathname_w(entry, s.s);\n\t\t\tarchive_wstring_free(&s);\n\t\t}\n\t}\n\n\t/* Make sure that entries with a trailing '/' are marked as directories\n\t * even if the External File Attributes contains bogus values.  If this\n\t * is not a directory and there is no type, assume regularfile. */\n\tif ((zip_entry->mode & AE_IFMT) != AE_IFDIR) {\n\t\tint has_slash;\n\n\t\twp = archive_entry_pathname_w(entry);\n\t\tif (wp != NULL) {\n\t\t\tlen = wcslen(wp);\n\t\t\thas_slash = len > 0 && wp[len - 1] == L'/';\n\t\t} else {\n\t\t\tcp = archive_entry_pathname(entry);\n\t\t\tlen = (cp != NULL)?strlen(cp):0;\n\t\t\thas_slash = len > 0 && cp[len - 1] == '/';\n\t\t}\n\t\t/* Correct file type as needed. */\n\t\tif (has_slash) {\n\t\t\tzip_entry->mode &= ~AE_IFMT;\n\t\t\tzip_entry->mode |= AE_IFDIR;\n\t\t\tzip_entry->mode |= 0111;\n\t\t} else if ((zip_entry->mode & AE_IFMT) == 0) {\n\t\t\tzip_entry->mode |= AE_IFREG;\n\t\t}\n\t}\n\n\t/* Make sure directories end in '/' */\n\tif ((zip_entry->mode & AE_IFMT) == AE_IFDIR) {\n\t\twp = archive_entry_pathname_w(entry);\n\t\tif (wp != NULL) {\n\t\t\tlen = wcslen(wp);\n\t\t\tif (len > 0 && wp[len - 1] != L'/') {\n\t\t\t\tstruct archive_wstring s;\n\t\t\t\tarchive_string_init(&s);\n\t\t\t\tarchive_wstrcat(&s, wp);\n\t\t\t\tarchive_wstrappend_wchar(&s, L'/');\n\t\t\t\tarchive_entry_copy_pathname_w(entry, s.s);\n\t\t\t\tarchive_wstring_free(&s);\n\t\t\t}\n\t\t} else {\n\t\t\tcp = archive_entry_pathname(entry);\n\t\t\tlen = (cp != NULL)?strlen(cp):0;\n\t\t\tif (len > 0 && cp[len - 1] != '/') {\n\t\t\t\tstruct archive_string s;\n\t\t\t\tarchive_string_init(&s);\n\t\t\t\tarchive_strcat(&s, cp);\n\t\t\t\tarchive_strappend_char(&s, '/');\n\t\t\t\tarchive_entry_set_pathname(entry, s.s);\n\t\t\t\tarchive_string_free(&s);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (zip_entry->flags & LA_FROM_CENTRAL_DIRECTORY) {\n\t\t/* If this came from the central dir, it's size info\n\t\t * is definitive, so ignore the length-at-end flag. */\n\t\tzip_entry->zip_flags &= ~ZIP_LENGTH_AT_END;\n\t\t/* If local header is missing a value, use the one from\n\t\t   the central directory.  If both have it, warn about\n\t\t   mismatches. */\n\t\tif (zip_entry->crc32 == 0) {\n\t\t\tzip_entry->crc32 = zip_entry_central_dir.crc32;\n\t\t} else if (!zip->ignore_crc32\n\t\t    && zip_entry->crc32 != zip_entry_central_dir.crc32) {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Inconsistent CRC32 values\");\n\t\t\tret = ARCHIVE_WARN;\n\t\t}\n\t\tif (zip_entry->compressed_size == 0) {\n\t\t\tzip_entry->compressed_size\n\t\t\t    = zip_entry_central_dir.compressed_size;\n\t\t} else if (zip_entry->compressed_size\n\t\t    != zip_entry_central_dir.compressed_size) {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Inconsistent compressed size: \"\n\t\t\t    \"%jd in central directory, %jd in local header\",\n\t\t\t    (intmax_t)zip_entry_central_dir.compressed_size,\n\t\t\t    (intmax_t)zip_entry->compressed_size);\n\t\t\tret = ARCHIVE_WARN;\n\t\t}\n\t\tif (zip_entry->uncompressed_size == 0) {\n\t\t\tzip_entry->uncompressed_size\n\t\t\t    = zip_entry_central_dir.uncompressed_size;\n\t\t} else if (zip_entry->uncompressed_size\n\t\t    != zip_entry_central_dir.uncompressed_size) {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Inconsistent uncompressed size: \"\n\t\t\t    \"%jd in central directory, %jd in local header\",\n\t\t\t    (intmax_t)zip_entry_central_dir.uncompressed_size,\n\t\t\t    (intmax_t)zip_entry->uncompressed_size);\n\t\t\tret = ARCHIVE_WARN;\n\t\t}\n\t}\n\n\t/* Populate some additional entry fields: */\n\tarchive_entry_set_mode(entry, zip_entry->mode);\n\tarchive_entry_set_uid(entry, zip_entry->uid);\n\tarchive_entry_set_gid(entry, zip_entry->gid);\n\tarchive_entry_set_mtime(entry, zip_entry->mtime, 0);\n\tarchive_entry_set_ctime(entry, zip_entry->ctime, 0);\n\tarchive_entry_set_atime(entry, zip_entry->atime, 0);\n\n\tif ((zip->entry->mode & AE_IFMT) == AE_IFLNK) {\n\t\tsize_t linkname_length;\n\n\t\tif (zip_entry->compressed_size > 64 * 1024) {\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Zip file with oversized link entry\");\n\t\t\treturn ARCHIVE_FATAL;\n\t\t}\n\n\t\tlinkname_length = (size_t)zip_entry->compressed_size;\n\n\t\tarchive_entry_set_size(entry, 0);\n\t\tp = __archive_read_ahead(a, linkname_length, NULL);\n\t\tif (p == NULL) {\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Truncated Zip file\");\n\t\t\treturn ARCHIVE_FATAL;\n\t\t}\n\n\t\tsconv = zip->sconv;\n\t\tif (sconv == NULL && (zip->entry->zip_flags & ZIP_UTF8_NAME))\n\t\t\tsconv = zip->sconv_utf8;\n\t\tif (sconv == NULL)\n\t\t\tsconv = zip->sconv_default;\n\t\tif (archive_entry_copy_symlink_l(entry, p, linkname_length,\n\t\t    sconv) != 0) {\n\t\t\tif (errno != ENOMEM && sconv == zip->sconv_utf8 &&\n\t\t\t    (zip->entry->zip_flags & ZIP_UTF8_NAME))\n\t\t\t    archive_entry_copy_symlink_l(entry, p,\n\t\t\t\tlinkname_length, NULL);\n\t\t\tif (errno == ENOMEM) {\n\t\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t\t    \"Can't allocate memory for Symlink\");\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t\t/*\n\t\t\t * Since there is no character-set regulation for\n\t\t\t * symlink name, do not report the conversion error\n\t\t\t * in an automatic conversion.\n\t\t\t */\n\t\t\tif (sconv != zip->sconv_utf8 ||\n\t\t\t    (zip->entry->zip_flags & ZIP_UTF8_NAME) == 0) {\n\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \"Symlink cannot be converted \"\n\t\t\t\t    \"from %s to current locale.\",\n\t\t\t\t    archive_string_conversion_charset_name(\n\t\t\t\t\tsconv));\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t}\n\t\t}\n\t\tzip_entry->uncompressed_size = zip_entry->compressed_size = 0;\n\n\t\tif (__archive_read_consume(a, linkname_length) < 0) {\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Read error skipping symlink target name\");\n\t\t\treturn ARCHIVE_FATAL;\n\t\t}\n\t} else if (0 == (zip_entry->zip_flags & ZIP_LENGTH_AT_END)\n\t    || zip_entry->uncompressed_size > 0) {\n\t\t/* Set the size only if it's meaningful. */\n\t\tarchive_entry_set_size(entry, zip_entry->uncompressed_size);\n\t}\n\tzip->entry_bytes_remaining = zip_entry->compressed_size;\n\n\t/* If there's no body, force read_data() to return EOF immediately. */\n\tif (0 == (zip_entry->zip_flags & ZIP_LENGTH_AT_END)\n\t    && zip->entry_bytes_remaining < 1)\n\t\tzip->end_of_entry = 1;\n\n\t/* Set up a more descriptive format name. */\n        archive_string_empty(&zip->format_name);\n\tarchive_string_sprintf(&zip->format_name, \"ZIP %d.%d (%s)\",\n\t    version / 10, version % 10,\n\t    compression_name(zip->entry->compression));\n\ta->archive.archive_format_name = zip->format_name.s;\n\n\treturn (ret);\n}\n\nstatic int\ncheck_authentication_code(struct archive_read *a, const void *_p)\n{\n\tstruct zip *zip = (struct zip *)(a->format->data);\n\n\t/* Check authentication code. */\n\tif (zip->hctx_valid) {\n\t\tconst void *p;\n\t\tuint8_t hmac[20];\n\t\tsize_t hmac_len = 20;\n\t\tint cmp;\n\n\t\tarchive_hmac_sha1_final(&zip->hctx, hmac, &hmac_len);\n\t\tif (_p == NULL) {\n\t\t\t/* Read authentication code. */\n\t\t\tp = __archive_read_ahead(a, AUTH_CODE_SIZE, NULL);\n\t\t\tif (p == NULL) {\n\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \"Truncated ZIP file data\");\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t} else {\n\t\t\tp = _p;\n\t\t}\n\t\tcmp = memcmp(hmac, p, AUTH_CODE_SIZE);\n\t\t__archive_read_consume(a, AUTH_CODE_SIZE);\n\t\tif (cmp != 0) {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t    \"ZIP bad Authentication code\");\n\t\t\treturn (ARCHIVE_WARN);\n\t\t}\n\t}\n\treturn (ARCHIVE_OK);\n}\n\n/*\n * Read \"uncompressed\" data.  There are three cases:\n *  1) We know the size of the data.  This is always true for the\n * seeking reader (we've examined the Central Directory already).\n *  2) ZIP_LENGTH_AT_END was set, but only the CRC was deferred.\n * Info-ZIP seems to do this; we know the size but have to grab\n * the CRC from the data descriptor afterwards.\n *  3) We're streaming and ZIP_LENGTH_AT_END was specified and\n * we have no size information.  In this case, we can do pretty\n * well by watching for the data descriptor record.  The data\n * descriptor is 16 bytes and includes a computed CRC that should\n * provide a strong check.\n *\n * TODO: Technically, the PK\\007\\010 signature is optional.\n * In the original spec, the data descriptor contained CRC\n * and size fields but had no leading signature.  In practice,\n * newer writers seem to provide the signature pretty consistently.\n *\n * For uncompressed data, the PK\\007\\010 marker seems essential\n * to be sure we've actually seen the end of the entry.\n *\n * Returns ARCHIVE_OK if successful, ARCHIVE_FATAL otherwise, sets\n * zip->end_of_entry if it consumes all of the data.\n */\nstatic int\nzip_read_data_none(struct archive_read *a, const void **_buff,\n    size_t *size, int64_t *offset)\n{\n\tstruct zip *zip;\n\tconst char *buff;\n\tssize_t bytes_avail;\n\tint r;\n\n\t(void)offset; /* UNUSED */\n\n\tzip = (struct zip *)(a->format->data);\n\n\tif (zip->entry->zip_flags & ZIP_LENGTH_AT_END) {\n\t\tconst char *p;\n\t\tssize_t grabbing_bytes = 24;\n\n\t\tif (zip->hctx_valid)\n\t\t\tgrabbing_bytes += AUTH_CODE_SIZE;\n\t\t/* Grab at least 24 bytes. */\n\t\tbuff = __archive_read_ahead(a, grabbing_bytes, &bytes_avail);\n\t\tif (bytes_avail < grabbing_bytes) {\n\t\t\t/* Zip archives have end-of-archive markers\n\t\t\t   that are longer than this, so a failure to get at\n\t\t\t   least 24 bytes really does indicate a truncated\n\t\t\t   file. */\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Truncated ZIP file data\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\t/* Check for a complete PK\\007\\010 signature, followed\n\t\t * by the correct 4-byte CRC. */\n\t\tp = buff;\n\t\tif (zip->hctx_valid)\n\t\t\tp += AUTH_CODE_SIZE;\n\t\tif (p[0] == 'P' && p[1] == 'K'\n\t\t    && p[2] == '\\007' && p[3] == '\\010'\n\t\t    && (archive_le32dec(p + 4) == zip->entry_crc32\n\t\t\t|| zip->ignore_crc32\n\t\t\t|| (zip->hctx_valid\n\t\t\t && zip->entry->aes_extra.vendor == AES_VENDOR_AE_2))) {\n\t\t\tif (zip->entry->flags & LA_USED_ZIP64) {\n\t\t\t\tuint64_t compressed, uncompressed;\n\t\t\t\tzip->entry->crc32 = archive_le32dec(p + 4);\n\t\t\t\tcompressed = archive_le64dec(p + 8);\n\t\t\t\tuncompressed = archive_le64dec(p + 16);\n\t\t\t\tif (compressed > INT64_MAX || uncompressed > INT64_MAX) {\n\t\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t\t    \"Overflow of 64-bit file sizes\");\n\t\t\t\t\treturn ARCHIVE_FAILED;\n\t\t\t\t}\n\t\t\t\tzip->entry->compressed_size = compressed;\n\t\t\t\tzip->entry->uncompressed_size = uncompressed;\n\t\t\t\tzip->unconsumed = 24;\n\t\t\t} else {\n\t\t\t\tzip->entry->crc32 = archive_le32dec(p + 4);\n\t\t\t\tzip->entry->compressed_size =\n\t\t\t\t\tarchive_le32dec(p + 8);\n\t\t\t\tzip->entry->uncompressed_size =\n\t\t\t\t\tarchive_le32dec(p + 12);\n\t\t\t\tzip->unconsumed = 16;\n\t\t\t}\n\t\t\tif (zip->hctx_valid) {\n\t\t\t\tr = check_authentication_code(a, buff);\n\t\t\t\tif (r != ARCHIVE_OK)\n\t\t\t\t\treturn (r);\n\t\t\t}\n\t\t\tzip->end_of_entry = 1;\n\t\t\treturn (ARCHIVE_OK);\n\t\t}\n\t\t/* If not at EOF, ensure we consume at least one byte. */\n\t\t++p;\n\n\t\t/* Scan forward until we see where a PK\\007\\010 signature\n\t\t * might be. */\n\t\t/* Return bytes up until that point.  On the next call,\n\t\t * the code above will verify the data descriptor. */\n\t\twhile (p < buff + bytes_avail - 4) {\n\t\t\tif (p[3] == 'P') { p += 3; }\n\t\t\telse if (p[3] == 'K') { p += 2; }\n\t\t\telse if (p[3] == '\\007') { p += 1; }\n\t\t\telse if (p[3] == '\\010' && p[2] == '\\007'\n\t\t\t    && p[1] == 'K' && p[0] == 'P') {\n\t\t\t\tif (zip->hctx_valid)\n\t\t\t\t\tp -= AUTH_CODE_SIZE;\n\t\t\t\tbreak;\n\t\t\t} else { p += 4; }\n\t\t}\n\t\tbytes_avail = p - buff;\n\t} else {\n\t\tif (zip->entry_bytes_remaining == 0) {\n\t\t\tzip->end_of_entry = 1;\n\t\t\tif (zip->hctx_valid) {\n\t\t\t\tr = check_authentication_code(a, NULL);\n\t\t\t\tif (r != ARCHIVE_OK)\n\t\t\t\t\treturn (r);\n\t\t\t}\n\t\t\treturn (ARCHIVE_OK);\n\t\t}\n\t\t/* Grab a bunch of bytes. */\n\t\tbuff = __archive_read_ahead(a, 1, &bytes_avail);\n\t\tif (bytes_avail <= 0) {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Truncated ZIP file data\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tif (bytes_avail > zip->entry_bytes_remaining)\n\t\t\tbytes_avail = (ssize_t)zip->entry_bytes_remaining;\n\t}\n\tif (zip->tctx_valid || zip->cctx_valid) {\n\t\tsize_t dec_size = bytes_avail;\n\n\t\tif (dec_size > zip->decrypted_buffer_size)\n\t\t\tdec_size = zip->decrypted_buffer_size;\n\t\tif (zip->tctx_valid) {\n\t\t\ttrad_enc_decrypt_update(&zip->tctx,\n\t\t\t    (const uint8_t *)buff, dec_size,\n\t\t\t    zip->decrypted_buffer, dec_size);\n\t\t} else {\n\t\t\tsize_t dsize = dec_size;\n\t\t\tarchive_hmac_sha1_update(&zip->hctx,\n\t\t\t    (const uint8_t *)buff, dec_size);\n\t\t\tarchive_decrypto_aes_ctr_update(&zip->cctx,\n\t\t\t    (const uint8_t *)buff, dec_size,\n\t\t\t    zip->decrypted_buffer, &dsize);\n\t\t}\n\t\tbytes_avail = dec_size;\n\t\tbuff = (const char *)zip->decrypted_buffer;\n\t}\n\t*size = bytes_avail;\n\tzip->entry_bytes_remaining -= bytes_avail;\n\tzip->entry_uncompressed_bytes_read += bytes_avail;\n\tzip->entry_compressed_bytes_read += bytes_avail;\n\tzip->unconsumed += bytes_avail;\n\t*_buff = buff;\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\nconsume_optional_marker(struct archive_read *a, struct zip *zip)\n{\n\tif (zip->end_of_entry && (zip->entry->zip_flags & ZIP_LENGTH_AT_END)) {\n\t\tconst char *p;\n\n\t\tif (NULL == (p = __archive_read_ahead(a, 24, NULL))) {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Truncated ZIP end-of-file record\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\t/* Consume the optional PK\\007\\010 marker. */\n\t\tif (p[0] == 'P' && p[1] == 'K' &&\n\t\t    p[2] == '\\007' && p[3] == '\\010') {\n\t\t\tp += 4;\n\t\t\tzip->unconsumed = 4;\n\t\t}\n\t\tif (zip->entry->flags & LA_USED_ZIP64) {\n\t\t\tuint64_t compressed, uncompressed;\n\t\t\tzip->entry->crc32 = archive_le32dec(p);\n\t\t\tcompressed = archive_le64dec(p + 4);\n\t\t\tuncompressed = archive_le64dec(p + 12);\n\t\t\tif (compressed > INT64_MAX || uncompressed > INT64_MAX) {\n\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \"Overflow of 64-bit file sizes\");\n\t\t\t\treturn ARCHIVE_FAILED;\n\t\t\t}\n\t\t\tzip->entry->compressed_size = compressed;\n\t\t\tzip->entry->uncompressed_size = uncompressed;\n\t\t\tzip->unconsumed += 20;\n\t\t} else {\n\t\t\tzip->entry->crc32 = archive_le32dec(p);\n\t\t\tzip->entry->compressed_size = archive_le32dec(p + 4);\n\t\t\tzip->entry->uncompressed_size = archive_le32dec(p + 8);\n\t\t\tzip->unconsumed += 12;\n\t\t}\n\t}\n\n    return (ARCHIVE_OK);\n}\n\n#if HAVE_LZMA_H && HAVE_LIBLZMA\nstatic int\nzipx_xz_init(struct archive_read *a, struct zip *zip)\n{\n\tlzma_ret r;\n\n\tif(zip->zipx_lzma_valid) {\n\t\tlzma_end(&zip->zipx_lzma_stream);\n\t\tzip->zipx_lzma_valid = 0;\n\t}\n\n\tmemset(&zip->zipx_lzma_stream, 0, sizeof(zip->zipx_lzma_stream));\n\tr = lzma_stream_decoder(&zip->zipx_lzma_stream, UINT64_MAX, 0);\n\tif (r != LZMA_OK) {\n\t\tarchive_set_error(&(a->archive), ARCHIVE_ERRNO_MISC,\n\t\t    \"xz initialization failed(%d)\",\n\t\t    r);\n\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n\tzip->zipx_lzma_valid = 1;\n\n\tfree(zip->uncompressed_buffer);\n\n\tzip->uncompressed_buffer_size = 256 * 1024;\n\tzip->uncompressed_buffer =\n\t    (uint8_t*) malloc(zip->uncompressed_buffer_size);\n\tif (zip->uncompressed_buffer == NULL) {\n\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t    \"No memory for xz decompression\");\n\t\t    return (ARCHIVE_FATAL);\n\t}\n\n\tzip->decompress_init = 1;\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\nzipx_lzma_alone_init(struct archive_read *a, struct zip *zip)\n{\n\tlzma_ret r;\n\tconst uint8_t* p;\n\n#pragma pack(push)\n#pragma pack(1)\n\tstruct _alone_header {\n\t    uint8_t bytes[5];\n\t    uint64_t uncompressed_size;\n\t} alone_header;\n#pragma pack(pop)\n\n\t/* To unpack ZIPX's \"LZMA\" (id 14) stream we can use standard liblzma that\n\t * is a part of XZ Utils. The stream format stored inside ZIPX file is a\n\t * modified \"lzma alone\" file format, that was used by the `lzma` utility\n\t * which was later deprecated in favour of `xz` utility. Since those\n\t * formats are nearly the same, we can use a standard \"lzma alone\" decoder\n\t * from XZ Utils. */\n\n\tmemset(&zip->zipx_lzma_stream, 0, sizeof(zip->zipx_lzma_stream));\n\tr = lzma_alone_decoder(&zip->zipx_lzma_stream, UINT64_MAX);\n\tif (r != LZMA_OK) {\n\t\tarchive_set_error(&(a->archive), ARCHIVE_ERRNO_MISC,\n\t\t    \"lzma initialization failed(%d)\", r);\n\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n\t/* Flag the cleanup function that we want our lzma-related structures\n\t * to be freed later. */\n\tzip->zipx_lzma_valid = 1;\n\n\t/* The \"lzma alone\" file format and the stream format inside ZIPx are\n\t * almost the same. Here's an example of a structure of \"lzma alone\"\n\t * format:\n\t *\n\t * $ cat /bin/ls | lzma | xxd | head -n 1\n\t * 00000000: 5d00 0080 00ff ffff ffff ffff ff00 2814\n\t *\n\t *    5 bytes        8 bytes        n bytes\n\t * <lzma_params><uncompressed_size><data...>\n\t *\n\t * lzma_params is a 5-byte blob that has to be decoded to extract\n\t * parameters of this LZMA stream. The uncompressed_size field is an\n\t * uint64_t value that contains information about the size of the\n\t * uncompressed file, or UINT64_MAX if this value is unknown. The <data...>\n\t * part is the actual lzma-compressed data stream.\n\t *\n\t * Now here's the structure of the stream inside the ZIPX file:\n\t *\n\t * $ cat stream_inside_zipx | xxd | head -n 1\n\t * 00000000: 0914 0500 5d00 8000 0000 2814 .... ....\n\t *\n\t *  2byte   2byte    5 bytes     n bytes\n\t * <magic1><magic2><lzma_params><data...>\n\t *\n\t * This means that the ZIPX file contains an additional magic1 and magic2\n\t * headers, the lzma_params field contains the same parameter set as in the\n\t * \"lzma alone\" format, and the <data...> field is the same as in the \"lzma\n\t * alone\" format as well. Note that also the zipx format is missing the\n\t * uncompressed_size field.\n\t *\n\t * So, in order to use the \"lzma alone\" decoder for the zipx lzma stream,\n\t * we simply need to shuffle around some fields, prepare a new lzma alone\n\t * header, feed it into lzma alone decoder so it will initialize itself\n\t * properly, and then we can start feeding normal zipx lzma stream into the\n\t * decoder.\n\t */\n\n\t/* Read magic1,magic2,lzma_params from the ZIPX stream. */\n\tif((p = __archive_read_ahead(a, 9, NULL)) == NULL) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Truncated lzma data\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\tif(p[2] != 0x05 || p[3] != 0x00) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Invalid lzma data\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\t/* Prepare an lzma alone header: copy the lzma_params blob into a proper\n\t * place into the lzma alone header. */\n\tmemcpy(&alone_header.bytes[0], p + 4, 5);\n\n\t/* Initialize the 'uncompressed size' field to unknown; we'll manually\n\t * monitor how many bytes there are still to be uncompressed. */\n\talone_header.uncompressed_size = UINT64_MAX;\n\n\tif(!zip->uncompressed_buffer) {\n\t\tzip->uncompressed_buffer_size = 256 * 1024;\n\t\tzip->uncompressed_buffer =\n\t\t\t(uint8_t*) malloc(zip->uncompressed_buffer_size);\n\n\t\tif (zip->uncompressed_buffer == NULL) {\n\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t    \"No memory for lzma decompression\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t}\n\n\tzip->zipx_lzma_stream.next_in = (void*) &alone_header;\n\tzip->zipx_lzma_stream.avail_in = sizeof(alone_header);\n\tzip->zipx_lzma_stream.total_in = 0;\n\tzip->zipx_lzma_stream.next_out = zip->uncompressed_buffer;\n\tzip->zipx_lzma_stream.avail_out = zip->uncompressed_buffer_size;\n\tzip->zipx_lzma_stream.total_out = 0;\n\n\t/* Feed only the header into the lzma alone decoder. This will effectively\n\t * initialize the decoder, and will not produce any output bytes yet. */\n\tr = lzma_code(&zip->zipx_lzma_stream, LZMA_RUN);\n\tif (r != LZMA_OK) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_PROGRAMMER,\n\t\t    \"lzma stream initialization error\");\n\t\treturn ARCHIVE_FATAL;\n\t}\n\n\t/* We've already consumed some bytes, so take this into account. */\n\t__archive_read_consume(a, 9);\n\tzip->entry_bytes_remaining -= 9;\n\tzip->entry_compressed_bytes_read += 9;\n\n\tzip->decompress_init = 1;\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\nzip_read_data_zipx_xz(struct archive_read *a, const void **buff,\n\tsize_t *size, int64_t *offset)\n{\n\tstruct zip* zip = (struct zip *)(a->format->data);\n\tint ret;\n\tlzma_ret lz_ret;\n\tconst void* compressed_buf;\n\tssize_t bytes_avail, in_bytes, to_consume = 0;\n\n\t(void) offset; /* UNUSED */\n\n\t/* Initialize decompressor if not yet initialized. */\n\tif (!zip->decompress_init) {\n\t\tret = zipx_xz_init(a, zip);\n\t\tif (ret != ARCHIVE_OK)\n\t\t\treturn (ret);\n\t}\n\n\tcompressed_buf = __archive_read_ahead(a, 1, &bytes_avail);\n\tif (bytes_avail < 0) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Truncated xz file body\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\tin_bytes = zipmin(zip->entry_bytes_remaining, bytes_avail);\n\tzip->zipx_lzma_stream.next_in = compressed_buf;\n\tzip->zipx_lzma_stream.avail_in = in_bytes;\n\tzip->zipx_lzma_stream.total_in = 0;\n\tzip->zipx_lzma_stream.next_out = zip->uncompressed_buffer;\n\tzip->zipx_lzma_stream.avail_out = zip->uncompressed_buffer_size;\n\tzip->zipx_lzma_stream.total_out = 0;\n\n\t/* Perform the decompression. */\n\tlz_ret = lzma_code(&zip->zipx_lzma_stream, LZMA_RUN);\n\tswitch(lz_ret) {\n\t\tcase LZMA_DATA_ERROR:\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"xz data error (error %d)\", (int) lz_ret);\n\t\t\treturn (ARCHIVE_FATAL);\n\n\t\tcase LZMA_NO_CHECK:\n\t\tcase LZMA_OK:\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"xz unknown error %d\", (int) lz_ret);\n\t\t\treturn (ARCHIVE_FATAL);\n\n\t\tcase LZMA_STREAM_END:\n\t\t\tlzma_end(&zip->zipx_lzma_stream);\n\t\t\tzip->zipx_lzma_valid = 0;\n\n\t\t\tif((int64_t) zip->zipx_lzma_stream.total_in !=\n\t\t\t    zip->entry_bytes_remaining)\n\t\t\t{\n\t\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t\t    \"xz premature end of stream\");\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\n\t\t\tzip->end_of_entry = 1;\n\t\t\tbreak;\n\t}\n\n\tto_consume = zip->zipx_lzma_stream.total_in;\n\n\t__archive_read_consume(a, to_consume);\n\tzip->entry_bytes_remaining -= to_consume;\n\tzip->entry_compressed_bytes_read += to_consume;\n\tzip->entry_uncompressed_bytes_read += zip->zipx_lzma_stream.total_out;\n\n\t*size = zip->zipx_lzma_stream.total_out;\n\t*buff = zip->uncompressed_buffer;\n\n\tret = consume_optional_marker(a, zip);\n\tif (ret != ARCHIVE_OK)\n\t\treturn (ret);\n\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\nzip_read_data_zipx_lzma_alone(struct archive_read *a, const void **buff,\n    size_t *size, int64_t *offset)\n{\n\tstruct zip* zip = (struct zip *)(a->format->data);\n\tint ret;\n\tlzma_ret lz_ret;\n\tconst void* compressed_buf;\n\tssize_t bytes_avail, in_bytes, to_consume;\n\n\t(void) offset; /* UNUSED */\n\n\t/* Initialize decompressor if not yet initialized. */\n\tif (!zip->decompress_init) {\n\t\tret = zipx_lzma_alone_init(a, zip);\n\t\tif (ret != ARCHIVE_OK)\n\t\t\treturn (ret);\n\t}\n\n\t/* Fetch more compressed data. The same note as in deflate handler applies\n\t * here as well:\n\t *\n\t * Note: '1' here is a performance optimization. Recall that the\n\t * decompression layer returns a count of available bytes; asking for more\n\t * than that forces the decompressor to combine reads by copying data.\n\t */\n\tcompressed_buf = __archive_read_ahead(a, 1, &bytes_avail);\n\tif (bytes_avail < 0) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Truncated lzma file body\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\t/* Set decompressor parameters. */\n\tin_bytes = zipmin(zip->entry_bytes_remaining, bytes_avail);\n\n\tzip->zipx_lzma_stream.next_in = compressed_buf;\n\tzip->zipx_lzma_stream.avail_in = in_bytes;\n\tzip->zipx_lzma_stream.total_in = 0;\n\tzip->zipx_lzma_stream.next_out = zip->uncompressed_buffer;\n\tzip->zipx_lzma_stream.avail_out =\n\t\t/* These lzma_alone streams lack end of stream marker, so let's make\n\t\t * sure the unpacker won't try to unpack more than it's supposed to. */\n\t\tzipmin((int64_t) zip->uncompressed_buffer_size,\n\t\t    zip->entry->uncompressed_size -\n\t\t    zip->entry_uncompressed_bytes_read);\n\tzip->zipx_lzma_stream.total_out = 0;\n\n\t/* Perform the decompression. */\n\tlz_ret = lzma_code(&zip->zipx_lzma_stream, LZMA_RUN);\n\tswitch(lz_ret) {\n\t\tcase LZMA_DATA_ERROR:\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"lzma data error (error %d)\", (int) lz_ret);\n\t\t\treturn (ARCHIVE_FATAL);\n\n\t\tcase LZMA_OK:\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"lzma unknown error %d\", (int) lz_ret);\n\t\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\tto_consume = zip->zipx_lzma_stream.total_in;\n\n\t/* Update pointers. */\n\t__archive_read_consume(a, to_consume);\n\tzip->entry_bytes_remaining -= to_consume;\n\tzip->entry_compressed_bytes_read += to_consume;\n\tzip->entry_uncompressed_bytes_read += zip->zipx_lzma_stream.total_out;\n\n\tif(zip->entry_bytes_remaining == 0) {\n\t\tzip->end_of_entry = 1;\n\t}\n\n\t/* Return values. */\n\t*size = zip->zipx_lzma_stream.total_out;\n\t*buff = zip->uncompressed_buffer;\n\n\t/* Behave the same way as during deflate decompression. */\n\tret = consume_optional_marker(a, zip);\n\tif (ret != ARCHIVE_OK)\n\t\treturn (ret);\n\n\t/* Free lzma decoder handle because we'll no longer need it. */\n\tif(zip->end_of_entry) {\n\t\tlzma_end(&zip->zipx_lzma_stream);\n\t\tzip->zipx_lzma_valid = 0;\n\t}\n\n\t/* If we're here, then we're good! */\n\treturn (ARCHIVE_OK);\n}\n#endif /* HAVE_LZMA_H && HAVE_LIBLZMA */\n\nstatic int\nzipx_ppmd8_init(struct archive_read *a, struct zip *zip)\n{\n\tconst void* p;\n\tuint32_t val;\n\tuint32_t order;\n\tuint32_t mem;\n\tuint32_t restore_method;\n\n\t/* Remove previous decompression context if it exists. */\n\tif(zip->ppmd8_valid) {\n\t\t__archive_ppmd8_functions.Ppmd8_Free(&zip->ppmd8);\n\t\tzip->ppmd8_valid = 0;\n\t}\n\n\t/* Create a new decompression context. */\n\t__archive_ppmd8_functions.Ppmd8_Construct(&zip->ppmd8);\n\tzip->ppmd8_stream_failed = 0;\n\n\t/* Setup function pointers required by Ppmd8 decompressor. The\n\t * 'ppmd_read' function will feed new bytes to the decompressor,\n\t * and will increment the 'zip->zipx_ppmd_read_compressed' counter. */\n\tzip->ppmd8.Stream.In = &zip->zipx_ppmd_stream;\n\tzip->zipx_ppmd_stream.a = a;\n\tzip->zipx_ppmd_stream.Read = &ppmd_read;\n\n\t/* Reset number of read bytes to 0. */\n\tzip->zipx_ppmd_read_compressed = 0;\n\n\t/* Read Ppmd8 header (2 bytes). */\n\tp = __archive_read_ahead(a, 2, NULL);\n\tif(!p) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Truncated file data in PPMd8 stream\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\t__archive_read_consume(a, 2);\n\n\t/* Decode the stream's compression parameters. */\n\tval = archive_le16dec(p);\n\torder = (val & 15) + 1;\n\tmem = ((val >> 4) & 0xff) + 1;\n\trestore_method = (val >> 12);\n\n\tif(order < 2 || restore_method > 2) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Invalid parameter set in PPMd8 stream (order=%d, \"\n\t\t    \"restore=%d)\", order, restore_method);\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n\t/* Allocate the memory needed to properly decompress the file. */\n\tif(!__archive_ppmd8_functions.Ppmd8_Alloc(&zip->ppmd8, mem << 20)) {\n\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t    \"Unable to allocate memory for PPMd8 stream: %d bytes\",\n\t\t    mem << 20);\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\t/* Signal the cleanup function to release Ppmd8 context in the\n\t * cleanup phase. */\n\tzip->ppmd8_valid = 1;\n\n\t/* Perform further Ppmd8 initialization. */\n\tif(!__archive_ppmd8_functions.Ppmd8_RangeDec_Init(&zip->ppmd8)) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_PROGRAMMER,\n\t\t    \"PPMd8 stream range decoder initialization error\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\t__archive_ppmd8_functions.Ppmd8_Init(&zip->ppmd8, order, restore_method);\n\n\t/* Allocate the buffer that will hold uncompressed data. */\n\tfree(zip->uncompressed_buffer);\n\n\tzip->uncompressed_buffer_size = 256 * 1024;\n\tzip->uncompressed_buffer =\n\t    (uint8_t*) malloc(zip->uncompressed_buffer_size);\n\n\tif(zip->uncompressed_buffer == NULL) {\n\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t    \"No memory for PPMd8 decompression\");\n\t\treturn ARCHIVE_FATAL;\n\t}\n\n\t/* Ppmd8 initialization is done. */\n\tzip->decompress_init = 1;\n\n\t/* We've already read 2 bytes in the output stream. Additionally,\n\t * Ppmd8 initialization code could read some data as well. So we\n\t * are advancing the stream by 2 bytes plus whatever number of\n\t * bytes Ppmd8 init function used. */\n\tzip->entry_compressed_bytes_read += 2 + zip->zipx_ppmd_read_compressed;\n\n\treturn ARCHIVE_OK;\n}\n\nstatic int\nzip_read_data_zipx_ppmd(struct archive_read *a, const void **buff,\n    size_t *size, int64_t *offset)\n{\n\tstruct zip* zip = (struct zip *)(a->format->data);\n\tint ret;\n\tsize_t consumed_bytes = 0;\n\tssize_t bytes_avail = 0;\n\n\t(void) offset; /* UNUSED */\n\n\t/* If we're here for the first time, initialize Ppmd8 decompression\n\t * context first. */\n\tif(!zip->decompress_init) {\n\t\tret = zipx_ppmd8_init(a, zip);\n\t\tif(ret != ARCHIVE_OK)\n\t\t\treturn ret;\n\t}\n\n\t/* Fetch for more data. We're reading 1 byte here, but libarchive should\n\t * prefetch more bytes. */\n\t(void) __archive_read_ahead(a, 1, &bytes_avail);\n\tif(bytes_avail < 0) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Truncated PPMd8 file body\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\t/* This counter will be updated inside ppmd_read(), which at one\n\t * point will be called by Ppmd8_DecodeSymbol. */\n\tzip->zipx_ppmd_read_compressed = 0;\n\n\t/* Decompression loop. */\n\tdo {\n\t\tint sym = __archive_ppmd8_functions.Ppmd8_DecodeSymbol(&zip->ppmd8);\n\t\tif(sym < 0) {\n\t\t\tzip->end_of_entry = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* This field is set by ppmd_read() when there was no more data\n\t\t * to be read. */\n\t\tif(zip->ppmd8_stream_failed) {\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t\"Truncated PPMd8 file body\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\n\t\tzip->uncompressed_buffer[consumed_bytes] = (uint8_t) sym;\n\t\t++consumed_bytes;\n\t} while(consumed_bytes < zip->uncompressed_buffer_size);\n\n\t/* Update pointers for libarchive. */\n\t*buff = zip->uncompressed_buffer;\n\t*size = consumed_bytes;\n\n\t/* Update pointers so we can continue decompression in another call. */\n\tzip->entry_bytes_remaining -= zip->zipx_ppmd_read_compressed;\n\tzip->entry_compressed_bytes_read += zip->zipx_ppmd_read_compressed;\n\tzip->entry_uncompressed_bytes_read += consumed_bytes;\n\n\t/* If we're at the end of stream, deinitialize Ppmd8 context. */\n\tif(zip->end_of_entry) {\n\t\t__archive_ppmd8_functions.Ppmd8_Free(&zip->ppmd8);\n\t\tzip->ppmd8_valid = 0;\n\t}\n\n\t/* Seek for optional marker, same way as in each zip entry. */\n\tret = consume_optional_marker(a, zip);\n\tif (ret != ARCHIVE_OK)\n\t\treturn ret;\n\n\treturn ARCHIVE_OK;\n}\n\n#ifdef HAVE_BZLIB_H\nstatic int\nzipx_bzip2_init(struct archive_read *a, struct zip *zip)\n{\n\tint r;\n\n\t/* Deallocate already existing BZ2 decompression context if it\n\t * exists. */\n\tif(zip->bzstream_valid) {\n\t\tBZ2_bzDecompressEnd(&zip->bzstream);\n\t\tzip->bzstream_valid = 0;\n\t}\n\n\t/* Allocate a new BZ2 decompression context. */\n\tmemset(&zip->bzstream, 0, sizeof(bz_stream));\n\tr = BZ2_bzDecompressInit(&zip->bzstream, 0, 1);\n\tif(r != BZ_OK) {\n\t\tarchive_set_error(&(a->archive), ARCHIVE_ERRNO_MISC,\n\t\t    \"bzip2 initialization failed(%d)\",\n\t\t    r);\n\n\t\treturn ARCHIVE_FAILED;\n\t}\n\n\t/* Mark the bzstream field to be released in cleanup phase. */\n\tzip->bzstream_valid = 1;\n\n\t/* (Re)allocate the buffer that will contain decompressed bytes. */\n\tfree(zip->uncompressed_buffer);\n\n\tzip->uncompressed_buffer_size = 256 * 1024;\n\tzip->uncompressed_buffer =\n\t    (uint8_t*) malloc(zip->uncompressed_buffer_size);\n\tif (zip->uncompressed_buffer == NULL) {\n\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t    \"No memory for bzip2 decompression\");\n\t\t    return ARCHIVE_FATAL;\n\t}\n\n\t/* Initialization done. */\n\tzip->decompress_init = 1;\n\treturn ARCHIVE_OK;\n}\n\nstatic int\nzip_read_data_zipx_bzip2(struct archive_read *a, const void **buff,\n    size_t *size, int64_t *offset)\n{\n\tstruct zip *zip = (struct zip *)(a->format->data);\n\tssize_t bytes_avail = 0, in_bytes, to_consume;\n\tconst void *compressed_buff;\n\tint r;\n\tuint64_t total_out;\n\n\t(void) offset; /* UNUSED */\n\n\t/* Initialize decompression context if we're here for the first time. */\n\tif(!zip->decompress_init) {\n\t\tr = zipx_bzip2_init(a, zip);\n\t\tif(r != ARCHIVE_OK)\n\t\t\treturn r;\n\t}\n\n\t/* Fetch more compressed bytes. */\n\tcompressed_buff = __archive_read_ahead(a, 1, &bytes_avail);\n\tif(bytes_avail < 0) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Truncated bzip2 file body\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\tin_bytes = zipmin(zip->entry_bytes_remaining, bytes_avail);\n\tif(in_bytes < 1) {\n\t\t/* libbz2 doesn't complain when caller feeds avail_in == 0. It will\n\t\t * actually return success in this case, which is undesirable. This is\n\t\t * why we need to make this check manually. */\n\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Truncated bzip2 file body\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\t/* Setup buffer boundaries. */\n\tzip->bzstream.next_in = (char*)(uintptr_t) compressed_buff;\n\tzip->bzstream.avail_in = in_bytes;\n\tzip->bzstream.total_in_hi32 = 0;\n\tzip->bzstream.total_in_lo32 = 0;\n\tzip->bzstream.next_out = (char*) zip->uncompressed_buffer;\n\tzip->bzstream.avail_out = zip->uncompressed_buffer_size;\n\tzip->bzstream.total_out_hi32 = 0;\n\tzip->bzstream.total_out_lo32 = 0;\n\n\t/* Perform the decompression. */\n\tr = BZ2_bzDecompress(&zip->bzstream);\n\tswitch(r) {\n\t\tcase BZ_STREAM_END:\n\t\t\t/* If we're at the end of the stream, deinitialize the\n\t\t\t * decompression context now. */\n\t\t\tswitch(BZ2_bzDecompressEnd(&zip->bzstream)) {\n\t\t\t\tcase BZ_OK:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t\t\t    \"Failed to clean up bzip2 decompressor\");\n\t\t\t\t\treturn ARCHIVE_FATAL;\n\t\t\t}\n\n\t\t\tzip->end_of_entry = 1;\n\t\t\tbreak;\n\t\tcase BZ_OK:\n\t\t\t/* The decompressor has successfully decoded this chunk of\n\t\t\t * data, but more data is still in queue. */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"bzip2 decompression failed\");\n\t\t\treturn ARCHIVE_FATAL;\n\t}\n\n\t/* Update the pointers so decompressor can continue decoding. */\n\tto_consume = zip->bzstream.total_in_lo32;\n\t__archive_read_consume(a, to_consume);\n\n\ttotal_out = ((uint64_t) zip->bzstream.total_out_hi32 << 32) +\n\t    zip->bzstream.total_out_lo32;\n\n\tzip->entry_bytes_remaining -= to_consume;\n\tzip->entry_compressed_bytes_read += to_consume;\n\tzip->entry_uncompressed_bytes_read += total_out;\n\n\t/* Give libarchive its due. */\n\t*size = total_out;\n\t*buff = zip->uncompressed_buffer;\n\n\t/* Seek for optional marker, like in other entries. */\n\tr = consume_optional_marker(a, zip);\n\tif(r != ARCHIVE_OK)\n\t\treturn r;\n\n\treturn ARCHIVE_OK;\n}\n\n#endif\n\n#ifdef HAVE_ZLIB_H\nstatic int\nzip_deflate_init(struct archive_read *a, struct zip *zip)\n{\n\tint r;\n\n\t/* If we haven't yet read any data, initialize the decompressor. */\n\tif (!zip->decompress_init) {\n\t\tif (zip->stream_valid)\n\t\t\tr = inflateReset(&zip->stream);\n\t\telse\n\t\t\tr = inflateInit2(&zip->stream,\n\t\t\t    -15 /* Don't check for zlib header */);\n\t\tif (r != Z_OK) {\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Can't initialize ZIP decompression.\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\t/* Stream structure has been set up. */\n\t\tzip->stream_valid = 1;\n\t\t/* We've initialized decompression for this stream. */\n\t\tzip->decompress_init = 1;\n\t}\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\nzip_read_data_deflate(struct archive_read *a, const void **buff,\n    size_t *size, int64_t *offset)\n{\n\tstruct zip *zip;\n\tssize_t bytes_avail;\n\tconst void *compressed_buff, *sp;\n\tint r;\n\n\t(void)offset; /* UNUSED */\n\n\tzip = (struct zip *)(a->format->data);\n\n\t/* If the buffer hasn't been allocated, allocate it now. */\n\tif (zip->uncompressed_buffer == NULL) {\n\t\tzip->uncompressed_buffer_size = 256 * 1024;\n\t\tzip->uncompressed_buffer\n\t\t    = (unsigned char *)malloc(zip->uncompressed_buffer_size);\n\t\tif (zip->uncompressed_buffer == NULL) {\n\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t    \"No memory for ZIP decompression\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t}\n\n\tr = zip_deflate_init(a, zip);\n\tif (r != ARCHIVE_OK)\n\t\treturn (r);\n\n\t/*\n\t * Note: '1' here is a performance optimization.\n\t * Recall that the decompression layer returns a count of\n\t * available bytes; asking for more than that forces the\n\t * decompressor to combine reads by copying data.\n\t */\n\tcompressed_buff = sp = __archive_read_ahead(a, 1, &bytes_avail);\n\tif (0 == (zip->entry->zip_flags & ZIP_LENGTH_AT_END)\n\t    && bytes_avail > zip->entry_bytes_remaining) {\n\t\tbytes_avail = (ssize_t)zip->entry_bytes_remaining;\n\t}\n\tif (bytes_avail < 0) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Truncated ZIP file body\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\tif (zip->tctx_valid || zip->cctx_valid) {\n\t\tif (zip->decrypted_bytes_remaining < (size_t)bytes_avail) {\n\t\t\tsize_t buff_remaining =\n\t\t\t    (zip->decrypted_buffer + zip->decrypted_buffer_size)\n\t\t\t    - (zip->decrypted_ptr + zip->decrypted_bytes_remaining);\n\n\t\t\tif (buff_remaining > (size_t)bytes_avail)\n\t\t\t\tbuff_remaining = (size_t)bytes_avail;\n\n\t\t\tif (0 == (zip->entry->zip_flags & ZIP_LENGTH_AT_END) &&\n\t\t\t      zip->entry_bytes_remaining > 0) {\n\t\t\t\tif ((int64_t)(zip->decrypted_bytes_remaining\n\t\t\t\t    + buff_remaining)\n\t\t\t\t      > zip->entry_bytes_remaining) {\n\t\t\t\t\tif (zip->entry_bytes_remaining <\n\t\t\t\t\t      (int64_t)zip->decrypted_bytes_remaining)\n\t\t\t\t\t\tbuff_remaining = 0;\n\t\t\t\t\telse\n\t\t\t\t\t\tbuff_remaining =\n\t\t\t\t\t\t    (size_t)zip->entry_bytes_remaining\n\t\t\t\t\t\t      - zip->decrypted_bytes_remaining;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (buff_remaining > 0) {\n\t\t\t\tif (zip->tctx_valid) {\n\t\t\t\t\ttrad_enc_decrypt_update(&zip->tctx,\n\t\t\t\t\t    compressed_buff, buff_remaining,\n\t\t\t\t\t    zip->decrypted_ptr\n\t\t\t\t\t      + zip->decrypted_bytes_remaining,\n\t\t\t\t\t    buff_remaining);\n\t\t\t\t} else {\n\t\t\t\t\tsize_t dsize = buff_remaining;\n\t\t\t\t\tarchive_decrypto_aes_ctr_update(\n\t\t\t\t\t    &zip->cctx,\n\t\t\t\t\t    compressed_buff, buff_remaining,\n\t\t\t\t\t    zip->decrypted_ptr\n\t\t\t\t\t      + zip->decrypted_bytes_remaining,\n\t\t\t\t\t    &dsize);\n\t\t\t\t}\n\t\t\t\tzip->decrypted_bytes_remaining += buff_remaining;\n\t\t\t}\n\t\t}\n\t\tbytes_avail = zip->decrypted_bytes_remaining;\n\t\tcompressed_buff = (const char *)zip->decrypted_ptr;\n\t}\n\n\t/*\n\t * A bug in zlib.h: stream.next_in should be marked 'const'\n\t * but isn't (the library never alters data through the\n\t * next_in pointer, only reads it).  The result: this ugly\n\t * cast to remove 'const'.\n\t */\n\tzip->stream.next_in = (Bytef *)(uintptr_t)(const void *)compressed_buff;\n\tzip->stream.avail_in = (uInt)bytes_avail;\n\tzip->stream.total_in = 0;\n\tzip->stream.next_out = zip->uncompressed_buffer;\n\tzip->stream.avail_out = (uInt)zip->uncompressed_buffer_size;\n\tzip->stream.total_out = 0;\n\n\tr = inflate(&zip->stream, 0);\n\tswitch (r) {\n\tcase Z_OK:\n\t\tbreak;\n\tcase Z_STREAM_END:\n\t\tzip->end_of_entry = 1;\n\t\tbreak;\n\tcase Z_MEM_ERROR:\n\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t    \"Out of memory for ZIP decompression\");\n\t\treturn (ARCHIVE_FATAL);\n\tdefault:\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"ZIP decompression failed (%d)\", r);\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\t/* Consume as much as the compressor actually used. */\n\tbytes_avail = zip->stream.total_in;\n\tif (zip->tctx_valid || zip->cctx_valid) {\n\t\tzip->decrypted_bytes_remaining -= bytes_avail;\n\t\tif (zip->decrypted_bytes_remaining == 0)\n\t\t\tzip->decrypted_ptr = zip->decrypted_buffer;\n\t\telse\n\t\t\tzip->decrypted_ptr += bytes_avail;\n\t}\n\t/* Calculate compressed data as much as we used.*/\n\tif (zip->hctx_valid)\n\t\tarchive_hmac_sha1_update(&zip->hctx, sp, bytes_avail);\n\t__archive_read_consume(a, bytes_avail);\n\tzip->entry_bytes_remaining -= bytes_avail;\n\tzip->entry_compressed_bytes_read += bytes_avail;\n\n\t*size = zip->stream.total_out;\n\tzip->entry_uncompressed_bytes_read += zip->stream.total_out;\n\t*buff = zip->uncompressed_buffer;\n\n\tif (zip->end_of_entry && zip->hctx_valid) {\n\t\tr = check_authentication_code(a, NULL);\n\t\tif (r != ARCHIVE_OK)\n\t\t\treturn (r);\n\t}\n\n\tr = consume_optional_marker(a, zip);\n\tif (r != ARCHIVE_OK)\n\t\treturn (r);\n\n\treturn (ARCHIVE_OK);\n}\n#endif\n\nstatic int\nread_decryption_header(struct archive_read *a)\n{\n\tstruct zip *zip = (struct zip *)(a->format->data);\n\tconst char *p;\n\tunsigned int remaining_size;\n\tunsigned int ts;\n\n\t/*\n\t * Read an initialization vector data field.\n\t */\n\tp = __archive_read_ahead(a, 2, NULL);\n\tif (p == NULL)\n\t\tgoto truncated;\n\tts = zip->iv_size;\n\tzip->iv_size = archive_le16dec(p);\n\t__archive_read_consume(a, 2);\n\tif (ts < zip->iv_size) {\n\t\tfree(zip->iv);\n\t\tzip->iv = NULL;\n\t}\n\tp = __archive_read_ahead(a, zip->iv_size, NULL);\n\tif (p == NULL)\n\t\tgoto truncated;\n\tif (zip->iv == NULL) {\n\t\tzip->iv = malloc(zip->iv_size);\n\t\tif (zip->iv == NULL)\n\t\t\tgoto nomem;\n\t}\n\tmemcpy(zip->iv, p, zip->iv_size);\n\t__archive_read_consume(a, zip->iv_size);\n\n\t/*\n\t * Read a size of remaining decryption header field.\n\t */\n\tp = __archive_read_ahead(a, 14, NULL);\n\tif (p == NULL)\n\t\tgoto truncated;\n\tremaining_size = archive_le32dec(p);\n\tif (remaining_size < 16 || remaining_size > (1 << 18))\n\t\tgoto corrupted;\n\n\t/* Check if format version is supported. */\n\tif (archive_le16dec(p+4) != 3) {\n\t\tarchive_set_error(&a->archive,\n\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Unsupported encryption format version: %u\",\n\t\t    archive_le16dec(p+4));\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n\t/*\n\t * Read an encryption algorithm field.\n\t */\n\tzip->alg_id = archive_le16dec(p+6);\n\tswitch (zip->alg_id) {\n\tcase 0x6601:/* DES */\n\tcase 0x6602:/* RC2 */\n\tcase 0x6603:/* 3DES 168 */\n\tcase 0x6609:/* 3DES 112 */\n\tcase 0x660E:/* AES 128 */\n\tcase 0x660F:/* AES 192 */\n\tcase 0x6610:/* AES 256 */\n\tcase 0x6702:/* RC2 (version >= 5.2) */\n\tcase 0x6720:/* Blowfish */\n\tcase 0x6721:/* Twofish */\n\tcase 0x6801:/* RC4 */\n\t\t/* Supported encryption algorithm. */\n\t\tbreak;\n\tdefault:\n\t\tarchive_set_error(&a->archive,\n\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Unknown encryption algorithm: %u\", zip->alg_id);\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n\t/*\n\t * Read a bit length field.\n\t */\n\tzip->bit_len = archive_le16dec(p+8);\n\n\t/*\n\t * Read a flags field.\n\t */\n\tzip->flags = archive_le16dec(p+10);\n\tswitch (zip->flags & 0xf000) {\n\tcase 0x0001: /* Password is required to decrypt. */\n\tcase 0x0002: /* Certificates only. */\n\tcase 0x0003: /* Password or certificate required to decrypt. */\n\t\tbreak;\n\tdefault:\n\t\tarchive_set_error(&a->archive,\n\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Unknown encryption flag: %u\", zip->flags);\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\tif ((zip->flags & 0xf000) == 0 ||\n\t    (zip->flags & 0xf000) == 0x4000) {\n\t\tarchive_set_error(&a->archive,\n\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Unknown encryption flag: %u\", zip->flags);\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n\t/*\n\t * Read an encrypted random data field.\n\t */\n\tts = zip->erd_size;\n\tzip->erd_size = archive_le16dec(p+12);\n\t__archive_read_consume(a, 14);\n\tif ((zip->erd_size & 0xf) != 0 ||\n\t    (zip->erd_size + 16) > remaining_size ||\n\t    (zip->erd_size + 16) < zip->erd_size)\n\t\tgoto corrupted;\n\n\tif (ts < zip->erd_size) {\n\t\tfree(zip->erd);\n\t\tzip->erd = NULL;\n\t}\n\tp = __archive_read_ahead(a, zip->erd_size, NULL);\n\tif (p == NULL)\n\t\tgoto truncated;\n\tif (zip->erd == NULL) {\n\t\tzip->erd = malloc(zip->erd_size);\n\t\tif (zip->erd == NULL)\n\t\t\tgoto nomem;\n\t}\n\tmemcpy(zip->erd, p, zip->erd_size);\n\t__archive_read_consume(a, zip->erd_size);\n\n\t/*\n\t * Read a reserved data field.\n\t */\n\tp = __archive_read_ahead(a, 4, NULL);\n\tif (p == NULL)\n\t\tgoto truncated;\n\t/* Reserved data size should be zero. */\n\tif (archive_le32dec(p) != 0)\n\t\tgoto corrupted;\n\t__archive_read_consume(a, 4);\n\n\t/*\n\t * Read a password validation data field.\n\t */\n\tp = __archive_read_ahead(a, 2, NULL);\n\tif (p == NULL)\n\t\tgoto truncated;\n\tts = zip->v_size;\n\tzip->v_size = archive_le16dec(p);\n\t__archive_read_consume(a, 2);\n\tif ((zip->v_size & 0x0f) != 0 ||\n\t    (zip->erd_size + zip->v_size + 16) > remaining_size ||\n\t    (zip->erd_size + zip->v_size + 16) < (zip->erd_size + zip->v_size))\n\t\tgoto corrupted;\n\tif (ts < zip->v_size) {\n\t\tfree(zip->v_data);\n\t\tzip->v_data = NULL;\n\t}\n\tp = __archive_read_ahead(a, zip->v_size, NULL);\n\tif (p == NULL)\n\t\tgoto truncated;\n\tif (zip->v_data == NULL) {\n\t\tzip->v_data = malloc(zip->v_size);\n\t\tif (zip->v_data == NULL)\n\t\t\tgoto nomem;\n\t}\n\tmemcpy(zip->v_data, p, zip->v_size);\n\t__archive_read_consume(a, zip->v_size);\n\n\tp = __archive_read_ahead(a, 4, NULL);\n\tif (p == NULL)\n\t\tgoto truncated;\n\tzip->v_crc32 = archive_le32dec(p);\n\t__archive_read_consume(a, 4);\n\n\t/*return (ARCHIVE_OK);\n\t * This is not fully implemented yet.*/\n\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t    \"Encrypted file is unsupported\");\n\treturn (ARCHIVE_FAILED);\ntruncated:\n\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t    \"Truncated ZIP file data\");\n\treturn (ARCHIVE_FATAL);\ncorrupted:\n\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t    \"Corrupted ZIP file data\");\n\treturn (ARCHIVE_FATAL);\nnomem:\n\tarchive_set_error(&a->archive, ENOMEM,\n\t    \"No memory for ZIP decryption\");\n\treturn (ARCHIVE_FATAL);\n}\n\nstatic int\nzip_alloc_decryption_buffer(struct archive_read *a)\n{\n\tstruct zip *zip = (struct zip *)(a->format->data);\n\tsize_t bs = 256 * 1024;\n\n\tif (zip->decrypted_buffer == NULL) {\n\t\tzip->decrypted_buffer_size = bs;\n\t\tzip->decrypted_buffer = malloc(bs);\n\t\tif (zip->decrypted_buffer == NULL) {\n\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t    \"No memory for ZIP decryption\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t}\n\tzip->decrypted_ptr = zip->decrypted_buffer;\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\ninit_traditional_PKWARE_decryption(struct archive_read *a)\n{\n\tstruct zip *zip = (struct zip *)(a->format->data);\n\tconst void *p;\n\tint retry;\n\tint r;\n\n\tif (zip->tctx_valid)\n\t\treturn (ARCHIVE_OK);\n\n\t/*\n\t   Read the 12 bytes encryption header stored at\n\t   the start of the data area.\n\t */\n#define ENC_HEADER_SIZE\t12\n\tif (0 == (zip->entry->zip_flags & ZIP_LENGTH_AT_END)\n\t    && zip->entry_bytes_remaining < ENC_HEADER_SIZE) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Truncated Zip encrypted body: only %jd bytes available\",\n\t\t    (intmax_t)zip->entry_bytes_remaining);\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\tp = __archive_read_ahead(a, ENC_HEADER_SIZE, NULL);\n\tif (p == NULL) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Truncated ZIP file data\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\tfor (retry = 0;; retry++) {\n\t\tconst char *passphrase;\n\t\tuint8_t crcchk;\n\n\t\tpassphrase = __archive_read_next_passphrase(a);\n\t\tif (passphrase == NULL) {\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    (retry > 0)?\n\t\t\t\t\"Incorrect passphrase\":\n\t\t\t\t\"Passphrase required for this entry\");\n\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n\n\t\t/*\n\t\t * Initialize ctx for Traditional PKWARE Decryption.\n\t\t */\n\t\tr = trad_enc_init(&zip->tctx, passphrase, strlen(passphrase),\n\t\t\tp, ENC_HEADER_SIZE, &crcchk);\n\t\tif (r == 0 && crcchk == zip->entry->decdat)\n\t\t\tbreak;/* The passphrase is OK. */\n\t\tif (retry > 10000) {\n\t\t\t/* Avoid infinity loop. */\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Too many incorrect passphrases\");\n\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n\t}\n\n\t__archive_read_consume(a, ENC_HEADER_SIZE);\n\tzip->tctx_valid = 1;\n\tif (0 == (zip->entry->zip_flags & ZIP_LENGTH_AT_END)) {\n\t    zip->entry_bytes_remaining -= ENC_HEADER_SIZE;\n\t}\n\t/*zip->entry_uncompressed_bytes_read += ENC_HEADER_SIZE;*/\n\tzip->entry_compressed_bytes_read += ENC_HEADER_SIZE;\n\tzip->decrypted_bytes_remaining = 0;\n\n\treturn (zip_alloc_decryption_buffer(a));\n#undef ENC_HEADER_SIZE\n}\n\nstatic int\ninit_WinZip_AES_decryption(struct archive_read *a)\n{\n\tstruct zip *zip = (struct zip *)(a->format->data);\n\tconst void *p;\n\tconst uint8_t *pv;\n\tsize_t key_len, salt_len;\n\tuint8_t derived_key[MAX_DERIVED_KEY_BUF_SIZE];\n\tint retry;\n\tint r;\n\n\tif (zip->cctx_valid || zip->hctx_valid)\n\t\treturn (ARCHIVE_OK);\n\n\tswitch (zip->entry->aes_extra.strength) {\n\tcase 1: salt_len = 8;  key_len = 16; break;\n\tcase 2: salt_len = 12; key_len = 24; break;\n\tcase 3: salt_len = 16; key_len = 32; break;\n\tdefault: goto corrupted;\n\t}\n\tp = __archive_read_ahead(a, salt_len + 2, NULL);\n\tif (p == NULL)\n\t\tgoto truncated;\n\n\tfor (retry = 0;; retry++) {\n\t\tconst char *passphrase;\n\n\t\tpassphrase = __archive_read_next_passphrase(a);\n\t\tif (passphrase == NULL) {\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    (retry > 0)?\n\t\t\t\t\"Incorrect passphrase\":\n\t\t\t\t\"Passphrase required for this entry\");\n\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n\t\tmemset(derived_key, 0, sizeof(derived_key));\n\t\tr = archive_pbkdf2_sha1(passphrase, strlen(passphrase),\n\t\t    p, salt_len, 1000, derived_key, key_len * 2 + 2);\n\t\tif (r != 0) {\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Decryption is unsupported due to lack of \"\n\t\t\t    \"crypto library\");\n\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n\n\t\t/* Check password verification value. */\n\t\tpv = ((const uint8_t *)p) + salt_len;\n\t\tif (derived_key[key_len * 2] == pv[0] &&\n\t\t    derived_key[key_len * 2 + 1] == pv[1])\n\t\t\tbreak;/* The passphrase is OK. */\n\t\tif (retry > 10000) {\n\t\t\t/* Avoid infinity loop. */\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Too many incorrect passphrases\");\n\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n\t}\n\n\tr = archive_decrypto_aes_ctr_init(&zip->cctx, derived_key, key_len);\n\tif (r != 0) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"Decryption is unsupported due to lack of crypto library\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\tr = archive_hmac_sha1_init(&zip->hctx, derived_key + key_len, key_len);\n\tif (r != 0) {\n\t\tarchive_decrypto_aes_ctr_release(&zip->cctx);\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"Failed to initialize HMAC-SHA1\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\tzip->cctx_valid = zip->hctx_valid = 1;\n\t__archive_read_consume(a, salt_len + 2);\n\tzip->entry_bytes_remaining -= salt_len + 2 + AUTH_CODE_SIZE;\n\tif (0 == (zip->entry->zip_flags & ZIP_LENGTH_AT_END)\n\t    && zip->entry_bytes_remaining < 0)\n\t\tgoto corrupted;\n\tzip->entry_compressed_bytes_read += salt_len + 2 + AUTH_CODE_SIZE;\n\tzip->decrypted_bytes_remaining = 0;\n\n\tzip->entry->compression = zip->entry->aes_extra.compression;\n\treturn (zip_alloc_decryption_buffer(a));\n\ntruncated:\n\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t    \"Truncated ZIP file data\");\n\treturn (ARCHIVE_FATAL);\ncorrupted:\n\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t    \"Corrupted ZIP file data\");\n\treturn (ARCHIVE_FATAL);\n}\n\nstatic int\narchive_read_format_zip_read_data(struct archive_read *a,\n    const void **buff, size_t *size, int64_t *offset)\n{\n\tint r;\n\tstruct zip *zip = (struct zip *)(a->format->data);\n\n\tif (zip->has_encrypted_entries ==\n\t\t\tARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW) {\n\t\tzip->has_encrypted_entries = 0;\n\t}\n\n\t*offset = zip->entry_uncompressed_bytes_read;\n\t*size = 0;\n\t*buff = NULL;\n\n\t/* If we hit end-of-entry last time, return ARCHIVE_EOF. */\n\tif (zip->end_of_entry)\n\t\treturn (ARCHIVE_EOF);\n\n\t/* Return EOF immediately if this is a non-regular file. */\n\tif (AE_IFREG != (zip->entry->mode & AE_IFMT))\n\t\treturn (ARCHIVE_EOF);\n\n\t__archive_read_consume(a, zip->unconsumed);\n\tzip->unconsumed = 0;\n\n\tif (zip->init_decryption) {\n\t\tzip->has_encrypted_entries = 1;\n\t\tif (zip->entry->zip_flags & ZIP_STRONG_ENCRYPTED)\n\t\t\tr = read_decryption_header(a);\n\t\telse if (zip->entry->compression == WINZIP_AES_ENCRYPTION)\n\t\t\tr = init_WinZip_AES_decryption(a);\n\t\telse\n\t\t\tr = init_traditional_PKWARE_decryption(a);\n\t\tif (r != ARCHIVE_OK)\n\t\t\treturn (r);\n\t\tzip->init_decryption = 0;\n\t}\n\n\tswitch(zip->entry->compression) {\n\tcase 0:  /* No compression. */\n\t\tr =  zip_read_data_none(a, buff, size, offset);\n\t\tbreak;\n#ifdef HAVE_BZLIB_H\n\tcase 12: /* ZIPx bzip2 compression. */\n\t\tr = zip_read_data_zipx_bzip2(a, buff, size, offset);\n\t\tbreak;\n#endif\n#if HAVE_LZMA_H && HAVE_LIBLZMA\n\tcase 14: /* ZIPx LZMA compression. */\n\t\tr = zip_read_data_zipx_lzma_alone(a, buff, size, offset);\n\t\tbreak;\n\tcase 95: /* ZIPx XZ compression. */\n\t\tr = zip_read_data_zipx_xz(a, buff, size, offset);\n\t\tbreak;\n#endif\n\t/* PPMd support is built-in, so we don't need any #if guards. */\n\tcase 98: /* ZIPx PPMd compression. */\n\t\tr = zip_read_data_zipx_ppmd(a, buff, size, offset);\n\t\tbreak;\n\n#ifdef HAVE_ZLIB_H\n\tcase 8: /* Deflate compression. */\n\t\tr =  zip_read_data_deflate(a, buff, size, offset);\n\t\tbreak;\n#endif\n\tdefault: /* Unsupported compression. */\n\t\t/* Return a warning. */\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Unsupported ZIP compression method (%d: %s)\",\n\t\t    zip->entry->compression, compression_name(zip->entry->compression));\n\t\t/* We can't decompress this entry, but we will\n\t\t * be able to skip() it and try the next entry. */\n\t\treturn (ARCHIVE_FAILED);\n\t\tbreak;\n\t}\n\tif (r != ARCHIVE_OK)\n\t\treturn (r);\n\t/* Update checksum */\n\tif (*size)\n\t\tzip->entry_crc32 = zip->crc32func(zip->entry_crc32, *buff,\n\t\t    (unsigned)*size);\n\t/* If we hit the end, swallow any end-of-data marker. */\n\tif (zip->end_of_entry) {\n\t\t/* Check file size, CRC against these values. */\n\t\tif (zip->entry->compressed_size !=\n\t\t    zip->entry_compressed_bytes_read) {\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"ZIP compressed data is wrong size \"\n\t\t\t    \"(read %jd, expected %jd)\",\n\t\t\t    (intmax_t)zip->entry_compressed_bytes_read,\n\t\t\t    (intmax_t)zip->entry->compressed_size);\n\t\t\treturn (ARCHIVE_WARN);\n\t\t}\n\t\t/* Size field only stores the lower 32 bits of the actual\n\t\t * size. */\n\t\tif ((zip->entry->uncompressed_size & UINT32_MAX)\n\t\t    != (zip->entry_uncompressed_bytes_read & UINT32_MAX)) {\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"ZIP uncompressed data is wrong size \"\n\t\t\t    \"(read %jd, expected %jd)\\n\",\n\t\t\t    (intmax_t)zip->entry_uncompressed_bytes_read,\n\t\t\t    (intmax_t)zip->entry->uncompressed_size);\n\t\t\treturn (ARCHIVE_WARN);\n\t\t}\n\t\t/* Check computed CRC against header */\n\t\tif ((!zip->hctx_valid ||\n\t\t      zip->entry->aes_extra.vendor != AES_VENDOR_AE_2) &&\n\t\t   zip->entry->crc32 != zip->entry_crc32\n\t\t    && !zip->ignore_crc32) {\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"ZIP bad CRC: 0x%lx should be 0x%lx\",\n\t\t\t    (unsigned long)zip->entry_crc32,\n\t\t\t    (unsigned long)zip->entry->crc32);\n\t\t\treturn (ARCHIVE_WARN);\n\t\t}\n\t}\n\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\narchive_read_format_zip_cleanup(struct archive_read *a)\n{\n\tstruct zip *zip;\n\tstruct zip_entry *zip_entry, *next_zip_entry;\n\n\tzip = (struct zip *)(a->format->data);\n\n#ifdef HAVE_ZLIB_H\n\tif (zip->stream_valid)\n\t\tinflateEnd(&zip->stream);\n#endif\n\n#if HAVA_LZMA_H && HAVE_LIBLZMA\n    if (zip->zipx_lzma_valid) {\n\t\tlzma_end(&zip->zipx_lzma_stream);\n\t}\n#endif\n\n#ifdef HAVE_BZLIB_H\n\tif (zip->bzstream_valid) {\n\t\tBZ2_bzDecompressEnd(&zip->bzstream);\n\t}\n#endif\n\n\tfree(zip->uncompressed_buffer);\n\n\tif (zip->ppmd8_valid)\n\t\t__archive_ppmd8_functions.Ppmd8_Free(&zip->ppmd8);\n\n\tif (zip->zip_entries) {\n\t\tzip_entry = zip->zip_entries;\n\t\twhile (zip_entry != NULL) {\n\t\t\tnext_zip_entry = zip_entry->next;\n\t\t\tarchive_string_free(&zip_entry->rsrcname);\n\t\t\tfree(zip_entry);\n\t\t\tzip_entry = next_zip_entry;\n\t\t}\n\t}\n\tfree(zip->decrypted_buffer);\n\tif (zip->cctx_valid)\n\t\tarchive_decrypto_aes_ctr_release(&zip->cctx);\n\tif (zip->hctx_valid)\n\t\tarchive_hmac_sha1_cleanup(&zip->hctx);\n\tfree(zip->iv);\n\tfree(zip->erd);\n\tfree(zip->v_data);\n\tarchive_string_free(&zip->format_name);\n\tfree(zip);\n\t(a->format->data) = NULL;\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\narchive_read_format_zip_has_encrypted_entries(struct archive_read *_a)\n{\n\tif (_a && _a->format) {\n\t\tstruct zip * zip = (struct zip *)_a->format->data;\n\t\tif (zip) {\n\t\t\treturn zip->has_encrypted_entries;\n\t\t}\n\t}\n\treturn ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW;\n}\n\nstatic int\narchive_read_format_zip_options(struct archive_read *a,\n    const char *key, const char *val)\n{\n\tstruct zip *zip;\n\tint ret = ARCHIVE_FAILED;\n\n\tzip = (struct zip *)(a->format->data);\n\tif (strcmp(key, \"compat-2x\")  == 0) {\n\t\t/* Handle filenames as libarchive 2.x */\n\t\tzip->init_default_conversion = (val != NULL) ? 1 : 0;\n\t\treturn (ARCHIVE_OK);\n\t} else if (strcmp(key, \"hdrcharset\")  == 0) {\n\t\tif (val == NULL || val[0] == 0)\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"zip: hdrcharset option needs a character-set name\"\n\t\t\t);\n\t\telse {\n\t\t\tzip->sconv = archive_string_conversion_from_charset(\n\t\t\t    &a->archive, val, 0);\n\t\t\tif (zip->sconv != NULL) {\n\t\t\t\tif (strcmp(val, \"UTF-8\") == 0)\n\t\t\t\t\tzip->sconv_utf8 = zip->sconv;\n\t\t\t\tret = ARCHIVE_OK;\n\t\t\t} else\n\t\t\t\tret = ARCHIVE_FATAL;\n\t\t}\n\t\treturn (ret);\n\t} else if (strcmp(key, \"ignorecrc32\") == 0) {\n\t\t/* Mostly useful for testing. */\n\t\tif (val == NULL || val[0] == 0) {\n\t\t\tzip->crc32func = real_crc32;\n\t\t\tzip->ignore_crc32 = 0;\n\t\t} else {\n\t\t\tzip->crc32func = fake_crc32;\n\t\t\tzip->ignore_crc32 = 1;\n\t\t}\n\t\treturn (ARCHIVE_OK);\n\t} else if (strcmp(key, \"mac-ext\") == 0) {\n\t\tzip->process_mac_extensions = (val != NULL && val[0] != 0);\n\t\treturn (ARCHIVE_OK);\n\t}\n\n\t/* Note: The \"warn\" return is just to inform the options\n\t * supervisor that we didn't handle it.  It will generate\n\t * a suitable error if no one used this option. */\n\treturn (ARCHIVE_WARN);\n}\n\nint\narchive_read_support_format_zip(struct archive *a)\n{\n\tint r;\n\tr = archive_read_support_format_zip_streamable(a);\n\tif (r != ARCHIVE_OK)\n\t\treturn r;\n\treturn (archive_read_support_format_zip_seekable(a));\n}\n\n/* ------------------------------------------------------------------------ */\n\n/*\n * Streaming-mode support\n */\n\n\nstatic int\narchive_read_support_format_zip_capabilities_streamable(struct archive_read * a)\n{\n\t(void)a; /* UNUSED */\n\treturn (ARCHIVE_READ_FORMAT_CAPS_ENCRYPT_DATA |\n\t\tARCHIVE_READ_FORMAT_CAPS_ENCRYPT_METADATA);\n}\n\nstatic int\narchive_read_format_zip_streamable_bid(struct archive_read *a, int best_bid)\n{\n\tconst char *p;\n\n\t(void)best_bid; /* UNUSED */\n\n\tif ((p = __archive_read_ahead(a, 4, NULL)) == NULL)\n\t\treturn (-1);\n\n\t/*\n\t * Bid of 29 here comes from:\n\t *  + 16 bits for \"PK\",\n\t *  + next 16-bit field has 6 options so contributes\n\t *    about 16 - log_2(6) ~= 16 - 2.6 ~= 13 bits\n\t *\n\t * So we've effectively verified ~29 total bits of check data.\n\t */\n\tif (p[0] == 'P' && p[1] == 'K') {\n\t\tif ((p[2] == '\\001' && p[3] == '\\002')\n\t\t    || (p[2] == '\\003' && p[3] == '\\004')\n\t\t    || (p[2] == '\\005' && p[3] == '\\006')\n\t\t    || (p[2] == '\\006' && p[3] == '\\006')\n\t\t    || (p[2] == '\\007' && p[3] == '\\010')\n\t\t    || (p[2] == '0' && p[3] == '0'))\n\t\t\treturn (29);\n\t}\n\n\t/* TODO: It's worth looking ahead a little bit for a valid\n\t * PK signature.  In particular, that would make it possible\n\t * to read some UUEncoded SFX files or SFX files coming from\n\t * a network socket. */\n\n\treturn (0);\n}\n\nstatic int\narchive_read_format_zip_streamable_read_header(struct archive_read *a,\n    struct archive_entry *entry)\n{\n\tstruct zip *zip;\n\n\ta->archive.archive_format = ARCHIVE_FORMAT_ZIP;\n\tif (a->archive.archive_format_name == NULL)\n\t\ta->archive.archive_format_name = \"ZIP\";\n\n\tzip = (struct zip *)(a->format->data);\n\n\t/*\n\t * It should be sufficient to call archive_read_next_header() for\n\t * a reader to determine if an entry is encrypted or not. If the\n\t * encryption of an entry is only detectable when calling\n\t * archive_read_data(), so be it. We'll do the same check there\n\t * as well.\n\t */\n\tif (zip->has_encrypted_entries ==\n\t\t\tARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW)\n\t\tzip->has_encrypted_entries = 0;\n\n\t/* Make sure we have a zip_entry structure to use. */\n\tif (zip->zip_entries == NULL) {\n\t\tzip->zip_entries = malloc(sizeof(struct zip_entry));\n\t\tif (zip->zip_entries == NULL) {\n\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t    \"Out  of memory\");\n\t\t\treturn ARCHIVE_FATAL;\n\t\t}\n\t}\n\tzip->entry = zip->zip_entries;\n\tmemset(zip->entry, 0, sizeof(struct zip_entry));\n\n\tif (zip->cctx_valid)\n\t\tarchive_decrypto_aes_ctr_release(&zip->cctx);\n\tif (zip->hctx_valid)\n\t\tarchive_hmac_sha1_cleanup(&zip->hctx);\n\tzip->tctx_valid = zip->cctx_valid = zip->hctx_valid = 0;\n\t__archive_read_reset_passphrase(a);\n\n\t/* Search ahead for the next local file header. */\n\t__archive_read_consume(a, zip->unconsumed);\n\tzip->unconsumed = 0;\n\tfor (;;) {\n\t\tint64_t skipped = 0;\n\t\tconst char *p, *end;\n\t\tssize_t bytes;\n\n\t\tp = __archive_read_ahead(a, 4, &bytes);\n\t\tif (p == NULL)\n\t\t\treturn (ARCHIVE_FATAL);\n\t\tend = p + bytes;\n\n\t\twhile (p + 4 <= end) {\n\t\t\tif (p[0] == 'P' && p[1] == 'K') {\n\t\t\t\tif (p[2] == '\\003' && p[3] == '\\004') {\n\t\t\t\t\t/* Regular file entry. */\n\t\t\t\t\t__archive_read_consume(a, skipped);\n\t\t\t\t\treturn zip_read_local_file_header(a,\n\t\t\t\t\t    entry, zip);\n\t\t\t\t}\n\n                              /*\n                               * TODO: We cannot restore permissions\n                               * based only on the local file headers.\n                               * Consider scanning the central\n                               * directory and returning additional\n                               * entries for at least directories.\n                               * This would allow us to properly set\n                               * directory permissions.\n\t\t\t       *\n\t\t\t       * This won't help us fix symlinks\n\t\t\t       * and may not help with regular file\n\t\t\t       * permissions, either.  <sigh>\n                               */\n                              if (p[2] == '\\001' && p[3] == '\\002') {\n                                      return (ARCHIVE_EOF);\n                              }\n\n                              /* End of central directory?  Must be an\n                               * empty archive. */\n                              if ((p[2] == '\\005' && p[3] == '\\006')\n                                  || (p[2] == '\\006' && p[3] == '\\006'))\n                                      return (ARCHIVE_EOF);\n\t\t\t}\n\t\t\t++p;\n\t\t\t++skipped;\n\t\t}\n\t\t__archive_read_consume(a, skipped);\n\t}\n}\n\nstatic int\narchive_read_format_zip_read_data_skip_streamable(struct archive_read *a)\n{\n\tstruct zip *zip;\n\tint64_t bytes_skipped;\n\n\tzip = (struct zip *)(a->format->data);\n\tbytes_skipped = __archive_read_consume(a, zip->unconsumed);\n\tzip->unconsumed = 0;\n\tif (bytes_skipped < 0)\n\t\treturn (ARCHIVE_FATAL);\n\n\t/* If we've already read to end of data, we're done. */\n\tif (zip->end_of_entry)\n\t\treturn (ARCHIVE_OK);\n\n\t/* So we know we're streaming... */\n\tif (0 == (zip->entry->zip_flags & ZIP_LENGTH_AT_END)\n\t    || zip->entry->compressed_size > 0) {\n\t\t/* We know the compressed length, so we can just skip. */\n\t\tbytes_skipped = __archive_read_consume(a,\n\t\t\t\t\tzip->entry_bytes_remaining);\n\t\tif (bytes_skipped < 0)\n\t\t\treturn (ARCHIVE_FATAL);\n\t\treturn (ARCHIVE_OK);\n\t}\n\n\tif (zip->init_decryption) {\n\t\tint r;\n\n\t\tzip->has_encrypted_entries = 1;\n\t\tif (zip->entry->zip_flags & ZIP_STRONG_ENCRYPTED)\n\t\t\tr = read_decryption_header(a);\n\t\telse if (zip->entry->compression == WINZIP_AES_ENCRYPTION)\n\t\t\tr = init_WinZip_AES_decryption(a);\n\t\telse\n\t\t\tr = init_traditional_PKWARE_decryption(a);\n\t\tif (r != ARCHIVE_OK)\n\t\t\treturn (r);\n\t\tzip->init_decryption = 0;\n\t}\n\n\t/* We're streaming and we don't know the length. */\n\t/* If the body is compressed and we know the format, we can\n\t * find an exact end-of-entry by decompressing it. */\n\tswitch (zip->entry->compression) {\n#ifdef HAVE_ZLIB_H\n\tcase 8: /* Deflate compression. */\n\t\twhile (!zip->end_of_entry) {\n\t\t\tint64_t offset = 0;\n\t\t\tconst void *buff = NULL;\n\t\t\tsize_t size = 0;\n\t\t\tint r;\n\t\t\tr =  zip_read_data_deflate(a, &buff, &size, &offset);\n\t\t\tif (r != ARCHIVE_OK)\n\t\t\t\treturn (r);\n\t\t}\n\t\treturn ARCHIVE_OK;\n#endif\n\tdefault: /* Uncompressed or unknown. */\n\t\t/* Scan for a PK\\007\\010 signature. */\n\t\tfor (;;) {\n\t\t\tconst char *p, *buff;\n\t\t\tssize_t bytes_avail;\n\t\t\tbuff = __archive_read_ahead(a, 16, &bytes_avail);\n\t\t\tif (bytes_avail < 16) {\n\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \"Truncated ZIP file data\");\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t\tp = buff;\n\t\t\twhile (p <= buff + bytes_avail - 16) {\n\t\t\t\tif (p[3] == 'P') { p += 3; }\n\t\t\t\telse if (p[3] == 'K') { p += 2; }\n\t\t\t\telse if (p[3] == '\\007') { p += 1; }\n\t\t\t\telse if (p[3] == '\\010' && p[2] == '\\007'\n\t\t\t\t    && p[1] == 'K' && p[0] == 'P') {\n\t\t\t\t\tif (zip->entry->flags & LA_USED_ZIP64)\n\t\t\t\t\t\t__archive_read_consume(a,\n\t\t\t\t\t\t    p - buff + 24);\n\t\t\t\t\telse\n\t\t\t\t\t\t__archive_read_consume(a,\n\t\t\t\t\t\t    p - buff + 16);\n\t\t\t\t\treturn ARCHIVE_OK;\n\t\t\t\t} else { p += 4; }\n\t\t\t}\n\t\t\t__archive_read_consume(a, p - buff);\n\t\t}\n\t}\n}\n\nint\narchive_read_support_format_zip_streamable(struct archive *_a)\n{\n\tstruct archive_read *a = (struct archive_read *)_a;\n\tstruct zip *zip;\n\tint r;\n\n\tarchive_check_magic(_a, ARCHIVE_READ_MAGIC,\n\t    ARCHIVE_STATE_NEW, \"archive_read_support_format_zip\");\n\n\tzip = (struct zip *)calloc(1, sizeof(*zip));\n\tif (zip == NULL) {\n\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t    \"Can't allocate zip data\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\t/* Streamable reader doesn't support mac extensions. */\n\tzip->process_mac_extensions = 0;\n\n\t/*\n\t * Until enough data has been read, we cannot tell about\n\t * any encrypted entries yet.\n\t */\n\tzip->has_encrypted_entries = ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW;\n\tzip->crc32func = real_crc32;\n\n\tr = __archive_read_register_format(a,\n\t    zip,\n\t    \"zip\",\n\t    archive_read_format_zip_streamable_bid,\n\t    archive_read_format_zip_options,\n\t    archive_read_format_zip_streamable_read_header,\n\t    archive_read_format_zip_read_data,\n\t    archive_read_format_zip_read_data_skip_streamable,\n\t    NULL,\n\t    archive_read_format_zip_cleanup,\n\t    archive_read_support_format_zip_capabilities_streamable,\n\t    archive_read_format_zip_has_encrypted_entries);\n\n\tif (r != ARCHIVE_OK)\n\t\tfree(zip);\n\treturn (ARCHIVE_OK);\n}\n\n/* ------------------------------------------------------------------------ */\n\n/*\n * Seeking-mode support\n */\n\nstatic int\narchive_read_support_format_zip_capabilities_seekable(struct archive_read * a)\n{\n\t(void)a; /* UNUSED */\n\treturn (ARCHIVE_READ_FORMAT_CAPS_ENCRYPT_DATA |\n\t\tARCHIVE_READ_FORMAT_CAPS_ENCRYPT_METADATA);\n}\n\n/*\n * TODO: This is a performance sink because it forces the read core to\n * drop buffered data from the start of file, which will then have to\n * be re-read again if this bidder loses.\n *\n * We workaround this a little by passing in the best bid so far so\n * that later bidders can do nothing if they know they'll never\n * outbid.  But we can certainly do better...\n */\nstatic int\nread_eocd(struct zip *zip, const char *p, int64_t current_offset)\n{\n\t/* Sanity-check the EOCD we've found. */\n\n\t/* This must be the first volume. */\n\tif (archive_le16dec(p + 4) != 0)\n\t\treturn 0;\n\t/* Central directory must be on this volume. */\n\tif (archive_le16dec(p + 4) != archive_le16dec(p + 6))\n\t\treturn 0;\n\t/* All central directory entries must be on this volume. */\n\tif (archive_le16dec(p + 10) != archive_le16dec(p + 8))\n\t\treturn 0;\n\t/* Central directory can't extend beyond start of EOCD record. */\n\tif (archive_le32dec(p + 16) + archive_le32dec(p + 12)\n\t    > current_offset)\n\t\treturn 0;\n\n\t/* Save the central directory location for later use. */\n\tzip->central_directory_offset = archive_le32dec(p + 16);\n\n\t/* This is just a tiny bit higher than the maximum\n\t   returned by the streaming Zip bidder.  This ensures\n\t   that the more accurate seeking Zip parser wins\n\t   whenever seek is available. */\n\treturn 32;\n}\n\n/*\n * Examine Zip64 EOCD locator:  If it's valid, store the information\n * from it.\n */\nstatic int\nread_zip64_eocd(struct archive_read *a, struct zip *zip, const char *p)\n{\n\tint64_t eocd64_offset;\n\tint64_t eocd64_size;\n\n\t/* Sanity-check the locator record. */\n\n\t/* Central dir must be on first volume. */\n\tif (archive_le32dec(p + 4) != 0)\n\t\treturn 0;\n\t/* Must be only a single volume. */\n\tif (archive_le32dec(p + 16) != 1)\n\t\treturn 0;\n\n\t/* Find the Zip64 EOCD record. */\n\teocd64_offset = archive_le64dec(p + 8);\n\tif (__archive_read_seek(a, eocd64_offset, SEEK_SET) < 0)\n\t\treturn 0;\n\tif ((p = __archive_read_ahead(a, 56, NULL)) == NULL)\n\t\treturn 0;\n\t/* Make sure we can read all of it. */\n\teocd64_size = archive_le64dec(p + 4) + 12;\n\tif (eocd64_size < 56 || eocd64_size > 16384)\n\t\treturn 0;\n\tif ((p = __archive_read_ahead(a, (size_t)eocd64_size, NULL)) == NULL)\n\t\treturn 0;\n\n\t/* Sanity-check the EOCD64 */\n\tif (archive_le32dec(p + 16) != 0) /* Must be disk #0 */\n\t\treturn 0;\n\tif (archive_le32dec(p + 20) != 0) /* CD must be on disk #0 */\n\t\treturn 0;\n\t/* CD can't be split. */\n\tif (archive_le64dec(p + 24) != archive_le64dec(p + 32))\n\t\treturn 0;\n\n\t/* Save the central directory offset for later use. */\n\tzip->central_directory_offset = archive_le64dec(p + 48);\n\n\treturn 32;\n}\n\nstatic int\narchive_read_format_zip_seekable_bid(struct archive_read *a, int best_bid)\n{\n\tstruct zip *zip = (struct zip *)a->format->data;\n\tint64_t file_size, current_offset;\n\tconst char *p;\n\tint i, tail;\n\n\t/* If someone has already bid more than 32, then avoid\n\t   trashing the look-ahead buffers with a seek. */\n\tif (best_bid > 32)\n\t\treturn (-1);\n\n\tfile_size = __archive_read_seek(a, 0, SEEK_END);\n\tif (file_size <= 0)\n\t\treturn 0;\n\n\t/* Search last 16k of file for end-of-central-directory\n\t * record (which starts with PK\\005\\006) */\n\ttail = (int)zipmin(1024 * 16, file_size);\n\tcurrent_offset = __archive_read_seek(a, -tail, SEEK_END);\n\tif (current_offset < 0)\n\t\treturn 0;\n\tif ((p = __archive_read_ahead(a, (size_t)tail, NULL)) == NULL)\n\t\treturn 0;\n\t/* Boyer-Moore search backwards from the end, since we want\n\t * to match the last EOCD in the file (there can be more than\n\t * one if there is an uncompressed Zip archive as a member\n\t * within this Zip archive). */\n\tfor (i = tail - 22; i > 0;) {\n\t\tswitch (p[i]) {\n\t\tcase 'P':\n\t\t\tif (memcmp(p + i, \"PK\\005\\006\", 4) == 0) {\n\t\t\t\tint ret = read_eocd(zip, p + i,\n\t\t\t\t    current_offset + i);\n\t\t\t\t/* Zip64 EOCD locator precedes\n\t\t\t\t * regular EOCD if present. */\n\t\t\t\tif (i >= 20 && memcmp(p + i - 20, \"PK\\006\\007\", 4) == 0) {\n\t\t\t\t\tint ret_zip64 = read_zip64_eocd(a, zip, p + i - 20);\n\t\t\t\t\tif (ret_zip64 > ret)\n\t\t\t\t\t\tret = ret_zip64;\n\t\t\t\t}\n\t\t\t\treturn (ret);\n\t\t\t}\n\t\t\ti -= 4;\n\t\t\tbreak;\n\t\tcase 'K': i -= 1; break;\n\t\tcase 005: i -= 2; break;\n\t\tcase 006: i -= 3; break;\n\t\tdefault: i -= 4; break;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/* The red-black trees are only used in seeking mode to manage\n * the in-memory copy of the central directory. */\n\nstatic int\ncmp_node(const struct archive_rb_node *n1, const struct archive_rb_node *n2)\n{\n\tconst struct zip_entry *e1 = (const struct zip_entry *)n1;\n\tconst struct zip_entry *e2 = (const struct zip_entry *)n2;\n\n\tif (e1->local_header_offset > e2->local_header_offset)\n\t\treturn -1;\n\tif (e1->local_header_offset < e2->local_header_offset)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int\ncmp_key(const struct archive_rb_node *n, const void *key)\n{\n\t/* This function won't be called */\n\t(void)n; /* UNUSED */\n\t(void)key; /* UNUSED */\n\treturn 1;\n}\n\nstatic const struct archive_rb_tree_ops rb_ops = {\n\t&cmp_node, &cmp_key\n};\n\nstatic int\nrsrc_cmp_node(const struct archive_rb_node *n1,\n    const struct archive_rb_node *n2)\n{\n\tconst struct zip_entry *e1 = (const struct zip_entry *)n1;\n\tconst struct zip_entry *e2 = (const struct zip_entry *)n2;\n\n\treturn (strcmp(e2->rsrcname.s, e1->rsrcname.s));\n}\n\nstatic int\nrsrc_cmp_key(const struct archive_rb_node *n, const void *key)\n{\n\tconst struct zip_entry *e = (const struct zip_entry *)n;\n\treturn (strcmp((const char *)key, e->rsrcname.s));\n}\n\nstatic const struct archive_rb_tree_ops rb_rsrc_ops = {\n\t&rsrc_cmp_node, &rsrc_cmp_key\n};\n\nstatic const char *\nrsrc_basename(const char *name, size_t name_length)\n{\n\tconst char *s, *r;\n\n\tr = s = name;\n\tfor (;;) {\n\t\ts = memchr(s, '/', name_length - (s - name));\n\t\tif (s == NULL)\n\t\t\tbreak;\n\t\tr = ++s;\n\t}\n\treturn (r);\n}\n\nstatic void\nexpose_parent_dirs(struct zip *zip, const char *name, size_t name_length)\n{\n\tstruct archive_string str;\n\tstruct zip_entry *dir;\n\tchar *s;\n\n\tarchive_string_init(&str);\n\tarchive_strncpy(&str, name, name_length);\n\tfor (;;) {\n\t\ts = strrchr(str.s, '/');\n\t\tif (s == NULL)\n\t\t\tbreak;\n\t\t*s = '\\0';\n\t\t/* Transfer the parent directory from zip->tree_rsrc RB\n\t\t * tree to zip->tree RB tree to expose. */\n\t\tdir = (struct zip_entry *)\n\t\t    __archive_rb_tree_find_node(&zip->tree_rsrc, str.s);\n\t\tif (dir == NULL)\n\t\t\tbreak;\n\t\t__archive_rb_tree_remove_node(&zip->tree_rsrc, &dir->node);\n\t\tarchive_string_free(&dir->rsrcname);\n\t\t__archive_rb_tree_insert_node(&zip->tree, &dir->node);\n\t}\n\tarchive_string_free(&str);\n}\n\nstatic int\nslurp_central_directory(struct archive_read *a, struct zip *zip)\n{\n\tssize_t i;\n\tunsigned found;\n\tint64_t correction;\n\tssize_t bytes_avail;\n\tconst char *p;\n\n\t/*\n\t * Find the start of the central directory.  The end-of-CD\n\t * record has our starting point, but there are lots of\n\t * Zip archives which have had other data prepended to the\n\t * file, which makes the recorded offsets all too small.\n\t * So we search forward from the specified offset until we\n\t * find the real start of the central directory.  Then we\n\t * know the correction we need to apply to account for leading\n\t * padding.\n\t */\n\tif (__archive_read_seek(a, zip->central_directory_offset, SEEK_SET) < 0)\n\t\treturn ARCHIVE_FATAL;\n\n\tfound = 0;\n\twhile (!found) {\n\t\tif ((p = __archive_read_ahead(a, 20, &bytes_avail)) == NULL)\n\t\t\treturn ARCHIVE_FATAL;\n\t\tfor (found = 0, i = 0; !found && i < bytes_avail - 4;) {\n\t\t\tswitch (p[i + 3]) {\n\t\t\tcase 'P': i += 3; break;\n\t\t\tcase 'K': i += 2; break;\n\t\t\tcase 001: i += 1; break;\n\t\t\tcase 002:\n\t\t\t\tif (memcmp(p + i, \"PK\\001\\002\", 4) == 0) {\n\t\t\t\t\tp += i;\n\t\t\t\t\tfound = 1;\n\t\t\t\t} else\n\t\t\t\t\ti += 4;\n\t\t\t\tbreak;\n\t\t\tcase 005: i += 1; break;\n\t\t\tcase 006:\n\t\t\t\tif (memcmp(p + i, \"PK\\005\\006\", 4) == 0) {\n\t\t\t\t\tp += i;\n\t\t\t\t\tfound = 1;\n\t\t\t\t} else if (memcmp(p + i, \"PK\\006\\006\", 4) == 0) {\n\t\t\t\t\tp += i;\n\t\t\t\t\tfound = 1;\n\t\t\t\t} else\n\t\t\t\t\ti += 1;\n\t\t\t\tbreak;\n\t\t\tdefault: i += 4; break;\n\t\t\t}\n\t\t}\n\t\t__archive_read_consume(a, i);\n\t}\n\tcorrection = archive_filter_bytes(&a->archive, 0)\n\t\t\t- zip->central_directory_offset;\n\n\t__archive_rb_tree_init(&zip->tree, &rb_ops);\n\t__archive_rb_tree_init(&zip->tree_rsrc, &rb_rsrc_ops);\n\n\tzip->central_directory_entries_total = 0;\n\twhile (1) {\n\t\tstruct zip_entry *zip_entry;\n\t\tsize_t filename_length, extra_length, comment_length;\n\t\tuint32_t external_attributes;\n\t\tconst char *name, *r;\n\n\t\tif ((p = __archive_read_ahead(a, 4, NULL)) == NULL)\n\t\t\treturn ARCHIVE_FATAL;\n\t\tif (memcmp(p, \"PK\\006\\006\", 4) == 0\n\t\t    || memcmp(p, \"PK\\005\\006\", 4) == 0) {\n\t\t\tbreak;\n\t\t} else if (memcmp(p, \"PK\\001\\002\", 4) != 0) {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    -1, \"Invalid central directory signature\");\n\t\t\treturn ARCHIVE_FATAL;\n\t\t}\n\t\tif ((p = __archive_read_ahead(a, 46, NULL)) == NULL)\n\t\t\treturn ARCHIVE_FATAL;\n\n\t\tzip_entry = calloc(1, sizeof(struct zip_entry));\n\t\tif (zip_entry == NULL) {\n\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t\t\"Can't allocate zip entry\");\n\t\t\treturn ARCHIVE_FATAL;\n\t\t}\n\t\tzip_entry->next = zip->zip_entries;\n\t\tzip_entry->flags |= LA_FROM_CENTRAL_DIRECTORY;\n\t\tzip->zip_entries = zip_entry;\n\t\tzip->central_directory_entries_total++;\n\n\t\t/* version = p[4]; */\n\t\tzip_entry->system = p[5];\n\t\t/* version_required = archive_le16dec(p + 6); */\n\t\tzip_entry->zip_flags = archive_le16dec(p + 8);\n\t\tif (zip_entry->zip_flags\n\t\t      & (ZIP_ENCRYPTED | ZIP_STRONG_ENCRYPTED)){\n\t\t\tzip->has_encrypted_entries = 1;\n\t\t}\n\t\tzip_entry->compression = (char)archive_le16dec(p + 10);\n\t\tzip_entry->mtime = zip_time(p + 12);\n\t\tzip_entry->crc32 = archive_le32dec(p + 16);\n\t\tif (zip_entry->zip_flags & ZIP_LENGTH_AT_END)\n\t\t\tzip_entry->decdat = p[13];\n\t\telse\n\t\t\tzip_entry->decdat = p[19];\n\t\tzip_entry->compressed_size = archive_le32dec(p + 20);\n\t\tzip_entry->uncompressed_size = archive_le32dec(p + 24);\n\t\tfilename_length = archive_le16dec(p + 28);\n\t\textra_length = archive_le16dec(p + 30);\n\t\tcomment_length = archive_le16dec(p + 32);\n\t\t/* disk_start = archive_le16dec(p + 34); */ /* Better be zero. */\n\t\t/* internal_attributes = archive_le16dec(p + 36); */ /* text bit */\n\t\texternal_attributes = archive_le32dec(p + 38);\n\t\tzip_entry->local_header_offset =\n\t\t    archive_le32dec(p + 42) + correction;\n\n\t\t/* If we can't guess the mode, leave it zero here;\n\t\t   when we read the local file header we might get\n\t\t   more information. */\n\t\tif (zip_entry->system == 3) {\n\t\t\tzip_entry->mode = external_attributes >> 16;\n\t\t} else if (zip_entry->system == 0) {\n\t\t\t// Interpret MSDOS directory bit\n\t\t\tif (0x10 == (external_attributes & 0x10)) {\n\t\t\t\tzip_entry->mode = AE_IFDIR | 0775;\n\t\t\t} else {\n\t\t\t\tzip_entry->mode = AE_IFREG | 0664;\n\t\t\t}\n\t\t\tif (0x01 == (external_attributes & 0x01)) {\n\t\t\t\t// Read-only bit; strip write permissions\n\t\t\t\tzip_entry->mode &= 0555;\n\t\t\t}\n\t\t} else {\n\t\t\tzip_entry->mode = 0;\n\t\t}\n\n\t\t/* We're done with the regular data; get the filename and\n\t\t * extra data. */\n\t\t__archive_read_consume(a, 46);\n\t\tp = __archive_read_ahead(a, filename_length + extra_length,\n\t\t\tNULL);\n\t\tif (p == NULL) {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Truncated ZIP file header\");\n\t\t\treturn ARCHIVE_FATAL;\n\t\t}\n\t\tif (ARCHIVE_OK != process_extra(a, p + filename_length, extra_length, zip_entry)) {\n\t\t\treturn ARCHIVE_FATAL;\n\t\t}\n\n\t\t/*\n\t\t * Mac resource fork files are stored under the\n\t\t * \"__MACOSX/\" directory, so we should check if\n\t\t * it is.\n\t\t */\n\t\tif (!zip->process_mac_extensions) {\n\t\t\t/* Treat every entry as a regular entry. */\n\t\t\t__archive_rb_tree_insert_node(&zip->tree,\n\t\t\t    &zip_entry->node);\n\t\t} else {\n\t\t\tname = p;\n\t\t\tr = rsrc_basename(name, filename_length);\n\t\t\tif (filename_length >= 9 &&\n\t\t\t    strncmp(\"__MACOSX/\", name, 9) == 0) {\n\t\t\t\t/* If this file is not a resource fork nor\n\t\t\t\t * a directory. We should treat it as a non\n\t\t\t\t * resource fork file to expose it. */\n\t\t\t\tif (name[filename_length-1] != '/' &&\n\t\t\t\t    (r - name < 3 || r[0] != '.' || r[1] != '_')) {\n\t\t\t\t\t__archive_rb_tree_insert_node(\n\t\t\t\t\t    &zip->tree, &zip_entry->node);\n\t\t\t\t\t/* Expose its parent directories. */\n\t\t\t\t\texpose_parent_dirs(zip, name,\n\t\t\t\t\t    filename_length);\n\t\t\t\t} else {\n\t\t\t\t\t/* This file is a resource fork file or\n\t\t\t\t\t * a directory. */\n\t\t\t\t\tarchive_strncpy(&(zip_entry->rsrcname),\n\t\t\t\t\t     name, filename_length);\n\t\t\t\t\t__archive_rb_tree_insert_node(\n\t\t\t\t\t    &zip->tree_rsrc, &zip_entry->node);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* Generate resource fork name to find its\n\t\t\t\t * resource file at zip->tree_rsrc. */\n\t\t\t\tarchive_strcpy(&(zip_entry->rsrcname),\n\t\t\t\t    \"__MACOSX/\");\n\t\t\t\tarchive_strncat(&(zip_entry->rsrcname),\n\t\t\t\t    name, r - name);\n\t\t\t\tarchive_strcat(&(zip_entry->rsrcname), \"._\");\n\t\t\t\tarchive_strncat(&(zip_entry->rsrcname),\n\t\t\t\t    name + (r - name),\n\t\t\t\t    filename_length - (r - name));\n\t\t\t\t/* Register an entry to RB tree to sort it by\n\t\t\t\t * file offset. */\n\t\t\t\t__archive_rb_tree_insert_node(&zip->tree,\n\t\t\t\t    &zip_entry->node);\n\t\t\t}\n\t\t}\n\n\t\t/* Skip the comment too ... */\n\t\t__archive_read_consume(a,\n\t\t    filename_length + extra_length + comment_length);\n\t}\n\n\treturn ARCHIVE_OK;\n}\n\nstatic ssize_t\nzip_get_local_file_header_size(struct archive_read *a, size_t extra)\n{\n\tconst char *p;\n\tssize_t filename_length, extra_length;\n\n\tif ((p = __archive_read_ahead(a, extra + 30, NULL)) == NULL) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Truncated ZIP file header\");\n\t\treturn (ARCHIVE_WARN);\n\t}\n\tp += extra;\n\n\tif (memcmp(p, \"PK\\003\\004\", 4) != 0) {\n\t\tarchive_set_error(&a->archive, -1, \"Damaged Zip archive\");\n\t\treturn ARCHIVE_WARN;\n\t}\n\tfilename_length = archive_le16dec(p + 26);\n\textra_length = archive_le16dec(p + 28);\n\n\treturn (30 + filename_length + extra_length);\n}\n\nstatic int\nzip_read_mac_metadata(struct archive_read *a, struct archive_entry *entry,\n    struct zip_entry *rsrc)\n{\n\tstruct zip *zip = (struct zip *)a->format->data;\n\tunsigned char *metadata, *mp;\n\tint64_t offset = archive_filter_bytes(&a->archive, 0);\n\tsize_t remaining_bytes, metadata_bytes;\n\tssize_t hsize;\n\tint ret = ARCHIVE_OK, eof;\n\n\tswitch(rsrc->compression) {\n\tcase 0:  /* No compression. */\n\t\tif (rsrc->uncompressed_size != rsrc->compressed_size) {\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Malformed OS X metadata entry: inconsistent size\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n#ifdef HAVE_ZLIB_H\n\tcase 8: /* Deflate compression. */\n#endif\n\t\tbreak;\n\tdefault: /* Unsupported compression. */\n\t\t/* Return a warning. */\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Unsupported ZIP compression method (%s)\",\n\t\t    compression_name(rsrc->compression));\n\t\t/* We can't decompress this entry, but we will\n\t\t * be able to skip() it and try the next entry. */\n\t\treturn (ARCHIVE_WARN);\n\t}\n\n\tif (rsrc->uncompressed_size > (4 * 1024 * 1024)) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Mac metadata is too large: %jd > 4M bytes\",\n\t\t    (intmax_t)rsrc->uncompressed_size);\n\t\treturn (ARCHIVE_WARN);\n\t}\n\tif (rsrc->compressed_size > (4 * 1024 * 1024)) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Mac metadata is too large: %jd > 4M bytes\",\n\t\t    (intmax_t)rsrc->compressed_size);\n\t\treturn (ARCHIVE_WARN);\n\t}\n\n\tmetadata = malloc((size_t)rsrc->uncompressed_size);\n\tif (metadata == NULL) {\n\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t    \"Can't allocate memory for Mac metadata\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\tif (offset < rsrc->local_header_offset)\n\t\t__archive_read_consume(a, rsrc->local_header_offset - offset);\n\telse if (offset != rsrc->local_header_offset) {\n\t\t__archive_read_seek(a, rsrc->local_header_offset, SEEK_SET);\n\t}\n\n\thsize = zip_get_local_file_header_size(a, 0);\n\t__archive_read_consume(a, hsize);\n\n\tremaining_bytes = (size_t)rsrc->compressed_size;\n\tmetadata_bytes = (size_t)rsrc->uncompressed_size;\n\tmp = metadata;\n\teof = 0;\n\twhile (!eof && remaining_bytes) {\n\t\tconst unsigned char *p;\n\t\tssize_t bytes_avail;\n\t\tsize_t bytes_used;\n\n\t\tp = __archive_read_ahead(a, 1, &bytes_avail);\n\t\tif (p == NULL) {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Truncated ZIP file header\");\n\t\t\tret = ARCHIVE_WARN;\n\t\t\tgoto exit_mac_metadata;\n\t\t}\n\t\tif ((size_t)bytes_avail > remaining_bytes)\n\t\t\tbytes_avail = remaining_bytes;\n\t\tswitch(rsrc->compression) {\n\t\tcase 0:  /* No compression. */\n\t\t\tif ((size_t)bytes_avail > metadata_bytes)\n\t\t\t\tbytes_avail = metadata_bytes;\n\t\t\tmemcpy(mp, p, bytes_avail);\n\t\t\tbytes_used = (size_t)bytes_avail;\n\t\t\tmetadata_bytes -= bytes_used;\n\t\t\tmp += bytes_used;\n\t\t\tif (metadata_bytes == 0)\n\t\t\t\teof = 1;\n\t\t\tbreak;\n#ifdef HAVE_ZLIB_H\n\t\tcase 8: /* Deflate compression. */\n\t\t{\n\t\t\tint r;\n\n\t\t\tret = zip_deflate_init(a, zip);\n\t\t\tif (ret != ARCHIVE_OK)\n\t\t\t\tgoto exit_mac_metadata;\n\t\t\tzip->stream.next_in =\n\t\t\t    (Bytef *)(uintptr_t)(const void *)p;\n\t\t\tzip->stream.avail_in = (uInt)bytes_avail;\n\t\t\tzip->stream.total_in = 0;\n\t\t\tzip->stream.next_out = mp;\n\t\t\tzip->stream.avail_out = (uInt)metadata_bytes;\n\t\t\tzip->stream.total_out = 0;\n\n\t\t\tr = inflate(&zip->stream, 0);\n\t\t\tswitch (r) {\n\t\t\tcase Z_OK:\n\t\t\t\tbreak;\n\t\t\tcase Z_STREAM_END:\n\t\t\t\teof = 1;\n\t\t\t\tbreak;\n\t\t\tcase Z_MEM_ERROR:\n\t\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t\t    \"Out of memory for ZIP decompression\");\n\t\t\t\tret = ARCHIVE_FATAL;\n\t\t\t\tgoto exit_mac_metadata;\n\t\t\tdefault:\n\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t\t    \"ZIP decompression failed (%d)\", r);\n\t\t\t\tret = ARCHIVE_FATAL;\n\t\t\t\tgoto exit_mac_metadata;\n\t\t\t}\n\t\t\tbytes_used = zip->stream.total_in;\n\t\t\tmetadata_bytes -= zip->stream.total_out;\n\t\t\tmp += zip->stream.total_out;\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tdefault:\n\t\t\tbytes_used = 0;\n\t\t\tbreak;\n\t\t}\n\t\t__archive_read_consume(a, bytes_used);\n\t\tremaining_bytes -= bytes_used;\n\t}\n\tarchive_entry_copy_mac_metadata(entry, metadata,\n\t    (size_t)rsrc->uncompressed_size - metadata_bytes);\n\nexit_mac_metadata:\n\t__archive_read_seek(a, offset, SEEK_SET);\n\tzip->decompress_init = 0;\n\tfree(metadata);\n\treturn (ret);\n}\n\nstatic int\narchive_read_format_zip_seekable_read_header(struct archive_read *a,\n\tstruct archive_entry *entry)\n{\n\tstruct zip *zip = (struct zip *)a->format->data;\n\tstruct zip_entry *rsrc;\n\tint64_t offset;\n\tint r, ret = ARCHIVE_OK;\n\n\t/*\n\t * It should be sufficient to call archive_read_next_header() for\n\t * a reader to determine if an entry is encrypted or not. If the\n\t * encryption of an entry is only detectable when calling\n\t * archive_read_data(), so be it. We'll do the same check there\n\t * as well.\n\t */\n\tif (zip->has_encrypted_entries ==\n\t\t\tARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW)\n\t\tzip->has_encrypted_entries = 0;\n\n\ta->archive.archive_format = ARCHIVE_FORMAT_ZIP;\n\tif (a->archive.archive_format_name == NULL)\n\t\ta->archive.archive_format_name = \"ZIP\";\n\n\tif (zip->zip_entries == NULL) {\n\t\tr = slurp_central_directory(a, zip);\n\t\tif (r != ARCHIVE_OK)\n\t\t\treturn r;\n\t\t/* Get first entry whose local header offset is lower than\n\t\t * other entries in the archive file. */\n\t\tzip->entry =\n\t\t    (struct zip_entry *)ARCHIVE_RB_TREE_MIN(&zip->tree);\n\t} else if (zip->entry != NULL) {\n\t\t/* Get next entry in local header offset order. */\n\t\tzip->entry = (struct zip_entry *)__archive_rb_tree_iterate(\n\t\t    &zip->tree, &zip->entry->node, ARCHIVE_RB_DIR_RIGHT);\n\t}\n\n\tif (zip->entry == NULL)\n\t\treturn ARCHIVE_EOF;\n\n\tif (zip->entry->rsrcname.s)\n\t\trsrc = (struct zip_entry *)__archive_rb_tree_find_node(\n\t\t    &zip->tree_rsrc, zip->entry->rsrcname.s);\n\telse\n\t\trsrc = NULL;\n\n\tif (zip->cctx_valid)\n\t\tarchive_decrypto_aes_ctr_release(&zip->cctx);\n\tif (zip->hctx_valid)\n\t\tarchive_hmac_sha1_cleanup(&zip->hctx);\n\tzip->tctx_valid = zip->cctx_valid = zip->hctx_valid = 0;\n\t__archive_read_reset_passphrase(a);\n\n\t/* File entries are sorted by the header offset, we should mostly\n\t * use __archive_read_consume to advance a read point to avoid redundant\n\t * data reading.  */\n\toffset = archive_filter_bytes(&a->archive, 0);\n\tif (offset < zip->entry->local_header_offset)\n\t\t__archive_read_consume(a,\n\t\t    zip->entry->local_header_offset - offset);\n\telse if (offset != zip->entry->local_header_offset) {\n\t\t__archive_read_seek(a, zip->entry->local_header_offset,\n\t\t    SEEK_SET);\n\t}\n\tzip->unconsumed = 0;\n\tr = zip_read_local_file_header(a, entry, zip);\n\tif (r != ARCHIVE_OK)\n\t\treturn r;\n\tif (rsrc) {\n\t\tint ret2 = zip_read_mac_metadata(a, entry, rsrc);\n\t\tif (ret2 < ret)\n\t\t\tret = ret2;\n\t}\n\treturn (ret);\n}\n\n/*\n * We're going to seek for the next header anyway, so we don't\n * need to bother doing anything here.\n */\nstatic int\narchive_read_format_zip_read_data_skip_seekable(struct archive_read *a)\n{\n\tstruct zip *zip;\n\tzip = (struct zip *)(a->format->data);\n\n\tzip->unconsumed = 0;\n\treturn (ARCHIVE_OK);\n}\n\nint\narchive_read_support_format_zip_seekable(struct archive *_a)\n{\n\tstruct archive_read *a = (struct archive_read *)_a;\n\tstruct zip *zip;\n\tint r;\n\n\tarchive_check_magic(_a, ARCHIVE_READ_MAGIC,\n\t    ARCHIVE_STATE_NEW, \"archive_read_support_format_zip_seekable\");\n\n\tzip = (struct zip *)calloc(1, sizeof(*zip));\n\tif (zip == NULL) {\n\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t    \"Can't allocate zip data\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n#ifdef HAVE_COPYFILE_H\n\t/* Set this by default on Mac OS. */\n\tzip->process_mac_extensions = 1;\n#endif\n\n\t/*\n\t * Until enough data has been read, we cannot tell about\n\t * any encrypted entries yet.\n\t */\n\tzip->has_encrypted_entries = ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW;\n\tzip->crc32func = real_crc32;\n\n\tr = __archive_read_register_format(a,\n\t    zip,\n\t    \"zip\",\n\t    archive_read_format_zip_seekable_bid,\n\t    archive_read_format_zip_options,\n\t    archive_read_format_zip_seekable_read_header,\n\t    archive_read_format_zip_read_data,\n\t    archive_read_format_zip_read_data_skip_seekable,\n\t    NULL,\n\t    archive_read_format_zip_cleanup,\n\t    archive_read_support_format_zip_capabilities_seekable,\n\t    archive_read_format_zip_has_encrypted_entries);\n\n\tif (r != ARCHIVE_OK)\n\t\tfree(zip);\n\treturn (ARCHIVE_OK);\n}\n\n/*# vim:set noet:*/\n"], "fixing_code": ["/*-\n * Copyright (c) 2004-2013 Tim Kientzle\n * Copyright (c) 2011-2012,2014 Michihiro NAKAJIMA\n * Copyright (c) 2013 Konrad Kleine\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"archive_platform.h\"\n__FBSDID(\"$FreeBSD: head/lib/libarchive/archive_read_support_format_zip.c 201102 2009-12-28 03:11:36Z kientzle $\");\n\n/*\n * The definitive documentation of the Zip file format is:\n *   http://www.pkware.com/documents/casestudies/APPNOTE.TXT\n *\n * The Info-Zip project has pioneered various extensions to better\n * support Zip on Unix, including the 0x5455 \"UT\", 0x5855 \"UX\", 0x7855\n * \"Ux\", and 0x7875 \"ux\" extensions for time and ownership\n * information.\n *\n * History of this code: The streaming Zip reader was first added to\n * libarchive in January 2005.  Support for seekable input sources was\n * added in Nov 2011.  Zip64 support (including a significant code\n * refactoring) was added in 2014.\n */\n\n#ifdef HAVE_ERRNO_H\n#include <errno.h>\n#endif\n#ifdef HAVE_STDLIB_H\n#include <stdlib.h>\n#endif\n#ifdef HAVE_ZLIB_H\n#include <zlib.h>\n#endif\n#ifdef HAVE_BZLIB_H\n#include <bzlib.h>\n#endif\n#ifdef HAVE_LZMA_H\n#include <lzma.h>\n#endif\n\n#include \"archive.h\"\n#include \"archive_digest_private.h\"\n#include \"archive_cryptor_private.h\"\n#include \"archive_endian.h\"\n#include \"archive_entry.h\"\n#include \"archive_entry_locale.h\"\n#include \"archive_hmac_private.h\"\n#include \"archive_private.h\"\n#include \"archive_rb.h\"\n#include \"archive_read_private.h\"\n#include \"archive_ppmd8_private.h\"\n\n#ifndef HAVE_ZLIB_H\n#include \"archive_crc32.h\"\n#endif\n\nstruct zip_entry {\n\tstruct archive_rb_node\tnode;\n\tstruct zip_entry\t*next;\n\tint64_t\t\t\tlocal_header_offset;\n\tint64_t\t\t\tcompressed_size;\n\tint64_t\t\t\tuncompressed_size;\n\tint64_t\t\t\tgid;\n\tint64_t\t\t\tuid;\n\tstruct archive_string\trsrcname;\n\ttime_t\t\t\tmtime;\n\ttime_t\t\t\tatime;\n\ttime_t\t\t\tctime;\n\tuint32_t\t\tcrc32;\n\tuint16_t\t\tmode;\n\tuint16_t\t\tzip_flags; /* From GP Flags Field */\n\tunsigned char\t\tcompression;\n\tunsigned char\t\tsystem; /* From \"version written by\" */\n\tunsigned char\t\tflags; /* Our extra markers. */\n\tunsigned char\t\tdecdat;/* Used for Decryption check */\n\n\t/* WinZip AES encryption extra field should be available\n\t * when compression is 99. */\n\tstruct {\n\t\t/* Vendor version: AE-1 - 0x0001, AE-2 - 0x0002 */\n\t\tunsigned\tvendor;\n#define AES_VENDOR_AE_1\t0x0001\n#define AES_VENDOR_AE_2\t0x0002\n\t\t/* AES encryption strength:\n\t\t * 1 - 128 bits, 2 - 192 bits, 2 - 256 bits. */\n\t\tunsigned\tstrength;\n\t\t/* Actual compression method. */\n\t\tunsigned char\tcompression;\n\t}\t\t\taes_extra;\n};\n\nstruct trad_enc_ctx {\n\tuint32_t\tkeys[3];\n};\n\n/* Bits used in zip_flags. */\n#define ZIP_ENCRYPTED\t(1 << 0)\n#define ZIP_LENGTH_AT_END\t(1 << 3)\n#define ZIP_STRONG_ENCRYPTED\t(1 << 6)\n#define ZIP_UTF8_NAME\t(1 << 11)\n/* See \"7.2 Single Password Symmetric Encryption Method\"\n   in http://www.pkware.com/documents/casestudies/APPNOTE.TXT */\n#define ZIP_CENTRAL_DIRECTORY_ENCRYPTED\t(1 << 13)\n\n/* Bits used in flags. */\n#define LA_USED_ZIP64\t(1 << 0)\n#define LA_FROM_CENTRAL_DIRECTORY (1 << 1)\n\n/*\n * See \"WinZip - AES Encryption Information\"\n *     http://www.winzip.com/aes_info.htm\n */\n/* Value used in compression method. */\n#define WINZIP_AES_ENCRYPTION\t99\n/* Authentication code size. */\n#define AUTH_CODE_SIZE\t10\n/**/\n#define MAX_DERIVED_KEY_BUF_SIZE\t(AES_MAX_KEY_SIZE * 2 + 2)\n\nstruct zip {\n\t/* Structural information about the archive. */\n\tstruct archive_string\tformat_name;\n\tint64_t\t\t\tcentral_directory_offset;\n\tsize_t\t\t\tcentral_directory_entries_total;\n\tsize_t\t\t\tcentral_directory_entries_on_this_disk;\n\tint\t\t\thas_encrypted_entries;\n\n\t/* List of entries (seekable Zip only) */\n\tstruct zip_entry\t*zip_entries;\n\tstruct archive_rb_tree\ttree;\n\tstruct archive_rb_tree\ttree_rsrc;\n\n\t/* Bytes read but not yet consumed via __archive_read_consume() */\n\tsize_t\t\t\tunconsumed;\n\n\t/* Information about entry we're currently reading. */\n\tstruct zip_entry\t*entry;\n\tint64_t\t\t\tentry_bytes_remaining;\n\n\t/* These count the number of bytes actually read for the entry. */\n\tint64_t\t\t\tentry_compressed_bytes_read;\n\tint64_t\t\t\tentry_uncompressed_bytes_read;\n\n\t/* Running CRC32 of the decompressed data */\n\tunsigned long\t\tentry_crc32;\n\tunsigned long\t\t(*crc32func)(unsigned long, const void *,\n\t\t\t\t    size_t);\n\tchar\t\t\tignore_crc32;\n\n\t/* Flags to mark progress of decompression. */\n\tchar\t\t\tdecompress_init;\n\tchar\t\t\tend_of_entry;\n\n\tunsigned char \t\t*uncompressed_buffer;\n\tsize_t \t\t\tuncompressed_buffer_size;\n\n#ifdef HAVE_ZLIB_H\n\tz_stream\t\tstream;\n\tchar\t\t\tstream_valid;\n#endif\n\n#if HAVE_LZMA_H && HAVE_LIBLZMA\n\tlzma_stream\t\tzipx_lzma_stream;\n\tchar            zipx_lzma_valid;\n#endif\n\n#ifdef HAVE_BZLIB_H\n\tbz_stream\t\tbzstream;\n\tchar            bzstream_valid;\n#endif\n\n\tIByteIn\t\t\tzipx_ppmd_stream;\n\tssize_t\t\t\tzipx_ppmd_read_compressed;\n\tCPpmd8\t\t\tppmd8;\n\tchar\t\t\tppmd8_valid;\n\tchar\t\t\tppmd8_stream_failed;\n\n\tstruct archive_string_conv *sconv;\n\tstruct archive_string_conv *sconv_default;\n\tstruct archive_string_conv *sconv_utf8;\n\tint\t\t\tinit_default_conversion;\n\tint\t\t\tprocess_mac_extensions;\n\n\tchar\t\t\tinit_decryption;\n\n\t/* Decryption buffer. */\n\t/*\n\t * The decrypted data starts at decrypted_ptr and\n\t * extends for decrypted_bytes_remaining.  Decryption\n\t * adds new data to the end of this block, data is returned\n\t * to clients from the beginning.  When the block hits the\n\t * end of decrypted_buffer, it has to be shuffled back to\n\t * the beginning of the buffer.\n\t */\n\tunsigned char \t\t*decrypted_buffer;\n\tunsigned char \t\t*decrypted_ptr;\n\tsize_t \t\t\tdecrypted_buffer_size;\n\tsize_t \t\t\tdecrypted_bytes_remaining;\n\tsize_t \t\t\tdecrypted_unconsumed_bytes;\n\n\t/* Traditional PKWARE decryption. */\n\tstruct trad_enc_ctx\ttctx;\n\tchar\t\t\ttctx_valid;\n\n\t/* WinZip AES decryption. */\n\t/* Contexts used for AES decryption. */\n\tarchive_crypto_ctx\tcctx;\n\tchar\t\t\tcctx_valid;\n\tarchive_hmac_sha1_ctx\thctx;\n\tchar\t\t\thctx_valid;\n\n\t/* Strong encryption's decryption header information. */\n\tunsigned\t\tiv_size;\n\tunsigned\t\talg_id;\n\tunsigned\t\tbit_len;\n\tunsigned\t\tflags;\n\tunsigned\t\terd_size;\n\tunsigned\t\tv_size;\n\tunsigned\t\tv_crc32;\n\tuint8_t\t\t\t*iv;\n\tuint8_t\t\t\t*erd;\n\tuint8_t\t\t\t*v_data;\n};\n\n/* Many systems define min or MIN, but not all. */\n#define\tzipmin(a,b) ((a) < (b) ? (a) : (b))\n\n/* This function is used by Ppmd8_DecodeSymbol during decompression of Ppmd8\n * streams inside ZIP files. It has 2 purposes: one is to fetch the next\n * compressed byte from the stream, second one is to increase the counter how\n * many compressed bytes were read. */\nstatic Byte\nppmd_read(void* p) {\n\t/* Get the handle to current decompression context. */\n\tstruct archive_read *a = ((IByteIn*)p)->a;\n\tstruct zip *zip = (struct zip*) a->format->data;\n\tssize_t bytes_avail = 0;\n\n\t/* Fetch next byte. */\n\tconst uint8_t* data = __archive_read_ahead(a, 1, &bytes_avail);\n\tif(bytes_avail < 1) {\n\t\tzip->ppmd8_stream_failed = 1;\n\t\treturn 0;\n\t}\n\n\t__archive_read_consume(a, 1);\n\n\t/* Increment the counter. */\n\t++zip->zipx_ppmd_read_compressed;\n\n\t/* Return the next compressed byte. */\n\treturn data[0];\n}\n\n/* ------------------------------------------------------------------------ */\n\n/*\n  Traditional PKWARE Decryption functions.\n */\n\nstatic void\ntrad_enc_update_keys(struct trad_enc_ctx *ctx, uint8_t c)\n{\n\tuint8_t t;\n#define CRC32(c, b) (crc32(c ^ 0xffffffffUL, &b, 1) ^ 0xffffffffUL)\n\n\tctx->keys[0] = CRC32(ctx->keys[0], c);\n\tctx->keys[1] = (ctx->keys[1] + (ctx->keys[0] & 0xff)) * 134775813L + 1;\n\tt = (ctx->keys[1] >> 24) & 0xff;\n\tctx->keys[2] = CRC32(ctx->keys[2], t);\n#undef CRC32\n}\n\nstatic uint8_t\ntrad_enc_decrypt_byte(struct trad_enc_ctx *ctx)\n{\n\tunsigned temp = ctx->keys[2] | 2;\n\treturn (uint8_t)((temp * (temp ^ 1)) >> 8) & 0xff;\n}\n\nstatic void\ntrad_enc_decrypt_update(struct trad_enc_ctx *ctx, const uint8_t *in,\n    size_t in_len, uint8_t *out, size_t out_len)\n{\n\tunsigned i, max;\n\n\tmax = (unsigned)((in_len < out_len)? in_len: out_len);\n\n\tfor (i = 0; i < max; i++) {\n\t\tuint8_t t = in[i] ^ trad_enc_decrypt_byte(ctx);\n\t\tout[i] = t;\n\t\ttrad_enc_update_keys(ctx, t);\n\t}\n}\n\nstatic int\ntrad_enc_init(struct trad_enc_ctx *ctx, const char *pw, size_t pw_len,\n    const uint8_t *key, size_t key_len, uint8_t *crcchk)\n{\n\tuint8_t header[12];\n\n\tif (key_len < 12) {\n\t\t*crcchk = 0xff;\n\t\treturn -1;\n\t}\n\n\tctx->keys[0] = 305419896L;\n\tctx->keys[1] = 591751049L;\n\tctx->keys[2] = 878082192L;\n\n\tfor (;pw_len; --pw_len)\n\t\ttrad_enc_update_keys(ctx, *pw++);\n\n\ttrad_enc_decrypt_update(ctx, key, 12, header, 12);\n\t/* Return the last byte for CRC check. */\n\t*crcchk = header[11];\n\treturn 0;\n}\n\n#if 0\nstatic void\ncrypt_derive_key_sha1(const void *p, int size, unsigned char *key,\n    int key_size)\n{\n#define MD_SIZE 20\n\tarchive_sha1_ctx ctx;\n\tunsigned char md1[MD_SIZE];\n\tunsigned char md2[MD_SIZE * 2];\n\tunsigned char mkb[64];\n\tint i;\n\n\tarchive_sha1_init(&ctx);\n\tarchive_sha1_update(&ctx, p, size);\n\tarchive_sha1_final(&ctx, md1);\n\n\tmemset(mkb, 0x36, sizeof(mkb));\n\tfor (i = 0; i < MD_SIZE; i++)\n\t\tmkb[i] ^= md1[i];\n\tarchive_sha1_init(&ctx);\n\tarchive_sha1_update(&ctx, mkb, sizeof(mkb));\n\tarchive_sha1_final(&ctx, md2);\n\n\tmemset(mkb, 0x5C, sizeof(mkb));\n\tfor (i = 0; i < MD_SIZE; i++)\n\t\tmkb[i] ^= md1[i];\n\tarchive_sha1_init(&ctx);\n\tarchive_sha1_update(&ctx, mkb, sizeof(mkb));\n\tarchive_sha1_final(&ctx, md2 + MD_SIZE);\n\n\tif (key_size > 32)\n\t\tkey_size = 32;\n\tmemcpy(key, md2, key_size);\n#undef MD_SIZE\n}\n#endif\n\n/*\n * Common code for streaming or seeking modes.\n *\n * Includes code to read local file headers, decompress data\n * from entry bodies, and common API.\n */\n\nstatic unsigned long\nreal_crc32(unsigned long crc, const void *buff, size_t len)\n{\n\treturn crc32(crc, buff, (unsigned int)len);\n}\n\n/* Used by \"ignorecrc32\" option to speed up tests. */\nstatic unsigned long\nfake_crc32(unsigned long crc, const void *buff, size_t len)\n{\n\t(void)crc; /* UNUSED */\n\t(void)buff; /* UNUSED */\n\t(void)len; /* UNUSED */\n\treturn 0;\n}\n\nstatic const struct {\n\tint id;\n\tconst char * name;\n} compression_methods[] = {\n\t{0, \"uncompressed\"}, /* The file is stored (no compression) */\n\t{1, \"shrinking\"}, /* The file is Shrunk */\n\t{2, \"reduced-1\"}, /* The file is Reduced with compression factor 1 */\n\t{3, \"reduced-2\"}, /* The file is Reduced with compression factor 2 */\n\t{4, \"reduced-3\"}, /* The file is Reduced with compression factor 3 */\n\t{5, \"reduced-4\"}, /* The file is Reduced with compression factor 4 */\n\t{6, \"imploded\"},  /* The file is Imploded */\n\t{7, \"reserved\"},  /* Reserved for Tokenizing compression algorithm */\n\t{8, \"deflation\"}, /* The file is Deflated */\n\t{9, \"deflation-64-bit\"}, /* Enhanced Deflating using Deflate64(tm) */\n\t{10, \"ibm-terse\"},/* PKWARE Data Compression Library Imploding\n\t\t\t   * (old IBM TERSE) */\n\t{11, \"reserved\"}, /* Reserved by PKWARE */\n\t{12, \"bzip\"},     /* File is compressed using BZIP2 algorithm */\n\t{13, \"reserved\"}, /* Reserved by PKWARE */\n\t{14, \"lzma\"},     /* LZMA (EFS) */\n\t{15, \"reserved\"}, /* Reserved by PKWARE */\n\t{16, \"reserved\"}, /* Reserved by PKWARE */\n\t{17, \"reserved\"}, /* Reserved by PKWARE */\n\t{18, \"ibm-terse-new\"}, /* File is compressed using IBM TERSE (new) */\n\t{19, \"ibm-lz777\"},/* IBM LZ77 z Architecture (PFS) */\n\t{95, \"xz\"},       /* XZ compressed data */\n\t{96, \"jpeg\"},     /* JPEG compressed data */\n\t{97, \"wav-pack\"}, /* WavPack compressed data */\n\t{98, \"ppmd-1\"},   /* PPMd version I, Rev 1 */\n\t{99, \"aes\"}       /* WinZip AES encryption  */\n};\n\nstatic const char *\ncompression_name(const int compression)\n{\n\tstatic const int num_compression_methods =\n\t\tsizeof(compression_methods)/sizeof(compression_methods[0]);\n\tint i=0;\n\n\twhile(compression >= 0 && i < num_compression_methods) {\n\t\tif (compression_methods[i].id == compression)\n\t\t\treturn compression_methods[i].name;\n\t\ti++;\n\t}\n\treturn \"??\";\n}\n\n/* Convert an MSDOS-style date/time into Unix-style time. */\nstatic time_t\nzip_time(const char *p)\n{\n\tint msTime, msDate;\n\tstruct tm ts;\n\n\tmsTime = (0xff & (unsigned)p[0]) + 256 * (0xff & (unsigned)p[1]);\n\tmsDate = (0xff & (unsigned)p[2]) + 256 * (0xff & (unsigned)p[3]);\n\n\tmemset(&ts, 0, sizeof(ts));\n\tts.tm_year = ((msDate >> 9) & 0x7f) + 80; /* Years since 1900. */\n\tts.tm_mon = ((msDate >> 5) & 0x0f) - 1; /* Month number. */\n\tts.tm_mday = msDate & 0x1f; /* Day of month. */\n\tts.tm_hour = (msTime >> 11) & 0x1f;\n\tts.tm_min = (msTime >> 5) & 0x3f;\n\tts.tm_sec = (msTime << 1) & 0x3e;\n\tts.tm_isdst = -1;\n\treturn mktime(&ts);\n}\n\n/*\n * The extra data is stored as a list of\n *\tid1+size1+data1 + id2+size2+data2 ...\n *  triplets.  id and size are 2 bytes each.\n */\nstatic int\nprocess_extra(struct archive_read *a, const char *p, size_t extra_length, struct zip_entry* zip_entry)\n{\n\tunsigned offset = 0;\n\n\tif (extra_length == 0) {\n\t\treturn ARCHIVE_OK;\n\t}\n\n\tif (extra_length < 4) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Too-small extra data: Need at least 4 bytes, but only found %d bytes\", (int)extra_length);\n\t\treturn ARCHIVE_FAILED;\n\t}\n\twhile (offset <= extra_length - 4) {\n\t\tunsigned short headerid = archive_le16dec(p + offset);\n\t\tunsigned short datasize = archive_le16dec(p + offset + 2);\n\n\t\toffset += 4;\n\t\tif (offset + datasize > extra_length) {\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Extra data overflow: Need %d bytes but only found %d bytes\",\n\t\t\t    (int)datasize, (int)(extra_length - offset));\n\t\t\treturn ARCHIVE_FAILED;\n\t\t}\n#ifdef DEBUG\n\t\tfprintf(stderr, \"Header id 0x%04x, length %d\\n\",\n\t\t    headerid, datasize);\n#endif\n\t\tswitch (headerid) {\n\t\tcase 0x0001:\n\t\t\t/* Zip64 extended information extra field. */\n\t\t\tzip_entry->flags |= LA_USED_ZIP64;\n\t\t\tif (zip_entry->uncompressed_size == 0xffffffff) {\n\t\t\t\tuint64_t t = 0;\n\t\t\t\tif (datasize < 8\n\t\t\t\t    || (t = archive_le64dec(p + offset)) > INT64_MAX) {\n\t\t\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t\t    \"Malformed 64-bit uncompressed size\");\n\t\t\t\t\treturn ARCHIVE_FAILED;\n\t\t\t\t}\n\t\t\t\tzip_entry->uncompressed_size = t;\n\t\t\t\toffset += 8;\n\t\t\t\tdatasize -= 8;\n\t\t\t}\n\t\t\tif (zip_entry->compressed_size == 0xffffffff) {\n\t\t\t\tuint64_t t = 0;\n\t\t\t\tif (datasize < 8\n\t\t\t\t    || (t = archive_le64dec(p + offset)) > INT64_MAX) {\n\t\t\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t\t    \"Malformed 64-bit compressed size\");\n\t\t\t\t\treturn ARCHIVE_FAILED;\n\t\t\t\t}\n\t\t\t\tzip_entry->compressed_size = t;\n\t\t\t\toffset += 8;\n\t\t\t\tdatasize -= 8;\n\t\t\t}\n\t\t\tif (zip_entry->local_header_offset == 0xffffffff) {\n\t\t\t\tuint64_t t = 0;\n\t\t\t\tif (datasize < 8\n\t\t\t\t    || (t = archive_le64dec(p + offset)) > INT64_MAX) {\n\t\t\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t\t    \"Malformed 64-bit local header offset\");\n\t\t\t\t\treturn ARCHIVE_FAILED;\n\t\t\t\t}\n\t\t\t\tzip_entry->local_header_offset = t;\n\t\t\t\toffset += 8;\n\t\t\t\tdatasize -= 8;\n\t\t\t}\n\t\t\t/* archive_le32dec(p + offset) gives disk\n\t\t\t * on which file starts, but we don't handle\n\t\t\t * multi-volume Zip files. */\n\t\t\tbreak;\n#ifdef DEBUG\n\t\tcase 0x0017:\n\t\t{\n\t\t\t/* Strong encryption field. */\n\t\t\tif (archive_le16dec(p + offset) == 2) {\n\t\t\t\tunsigned algId =\n\t\t\t\t\tarchive_le16dec(p + offset + 2);\n\t\t\t\tunsigned bitLen =\n\t\t\t\t\tarchive_le16dec(p + offset + 4);\n\t\t\t\tint\t flags =\n\t\t\t\t\tarchive_le16dec(p + offset + 6);\n\t\t\t\tfprintf(stderr, \"algId=0x%04x, bitLen=%u, \"\n\t\t\t\t    \"flgas=%d\\n\", algId, bitLen,flags);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tcase 0x5455:\n\t\t{\n\t\t\t/* Extended time field \"UT\". */\n\t\t\tint flags;\n\t\t\tif (datasize == 0) {\n\t\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \"Incomplete extended time field\");\n\t\t\t\treturn ARCHIVE_FAILED;\n\t\t\t}\n\t\t\tflags = p[offset];\n\t\t\toffset++;\n\t\t\tdatasize--;\n\t\t\t/* Flag bits indicate which dates are present. */\n\t\t\tif (flags & 0x01)\n\t\t\t{\n#ifdef DEBUG\n\t\t\t\tfprintf(stderr, \"mtime: %lld -> %d\\n\",\n\t\t\t\t    (long long)zip_entry->mtime,\n\t\t\t\t    archive_le32dec(p + offset));\n#endif\n\t\t\t\tif (datasize < 4)\n\t\t\t\t\tbreak;\n\t\t\t\tzip_entry->mtime = archive_le32dec(p + offset);\n\t\t\t\toffset += 4;\n\t\t\t\tdatasize -= 4;\n\t\t\t}\n\t\t\tif (flags & 0x02)\n\t\t\t{\n\t\t\t\tif (datasize < 4)\n\t\t\t\t\tbreak;\n\t\t\t\tzip_entry->atime = archive_le32dec(p + offset);\n\t\t\t\toffset += 4;\n\t\t\t\tdatasize -= 4;\n\t\t\t}\n\t\t\tif (flags & 0x04)\n\t\t\t{\n\t\t\t\tif (datasize < 4)\n\t\t\t\t\tbreak;\n\t\t\t\tzip_entry->ctime = archive_le32dec(p + offset);\n\t\t\t\toffset += 4;\n\t\t\t\tdatasize -= 4;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase 0x5855:\n\t\t{\n\t\t\t/* Info-ZIP Unix Extra Field (old version) \"UX\". */\n\t\t\tif (datasize >= 8) {\n\t\t\t\tzip_entry->atime = archive_le32dec(p + offset);\n\t\t\t\tzip_entry->mtime =\n\t\t\t\t    archive_le32dec(p + offset + 4);\n\t\t\t}\n\t\t\tif (datasize >= 12) {\n\t\t\t\tzip_entry->uid =\n\t\t\t\t    archive_le16dec(p + offset + 8);\n\t\t\t\tzip_entry->gid =\n\t\t\t\t    archive_le16dec(p + offset + 10);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase 0x6c78:\n\t\t{\n\t\t\t/* Experimental 'xl' field */\n\t\t\t/*\n\t\t\t * Introduced Dec 2013 to provide a way to\n\t\t\t * include external file attributes (and other\n\t\t\t * fields that ordinarily appear only in\n\t\t\t * central directory) in local file header.\n\t\t\t * This provides file type and permission\n\t\t\t * information necessary to support full\n\t\t\t * streaming extraction.  Currently being\n\t\t\t * discussed with other Zip developers\n\t\t\t * ... subject to change.\n\t\t\t *\n\t\t\t * Format:\n\t\t\t *  The field starts with a bitmap that specifies\n\t\t\t *  which additional fields are included.  The\n\t\t\t *  bitmap is variable length and can be extended in\n\t\t\t *  the future.\n\t\t\t *\n\t\t\t *  n bytes - feature bitmap: first byte has low-order\n\t\t\t *    7 bits.  If high-order bit is set, a subsequent\n\t\t\t *    byte holds the next 7 bits, etc.\n\t\t\t *\n\t\t\t *  if bitmap & 1, 2 byte \"version made by\"\n\t\t\t *  if bitmap & 2, 2 byte \"internal file attributes\"\n\t\t\t *  if bitmap & 4, 4 byte \"external file attributes\"\n\t\t\t *  if bitmap & 8, 2 byte comment length + n byte comment\n\t\t\t */\n\t\t\tint bitmap, bitmap_last;\n\n\t\t\tif (datasize < 1)\n\t\t\t\tbreak;\n\t\t\tbitmap_last = bitmap = 0xff & p[offset];\n\t\t\toffset += 1;\n\t\t\tdatasize -= 1;\n\n\t\t\t/* We only support first 7 bits of bitmap; skip rest. */\n\t\t\twhile ((bitmap_last & 0x80) != 0\n\t\t\t    && datasize >= 1) {\n\t\t\t\tbitmap_last = p[offset];\n\t\t\t\toffset += 1;\n\t\t\t\tdatasize -= 1;\n\t\t\t}\n\n\t\t\tif (bitmap & 1) {\n\t\t\t\t/* 2 byte \"version made by\" */\n\t\t\t\tif (datasize < 2)\n\t\t\t\t\tbreak;\n\t\t\t\tzip_entry->system\n\t\t\t\t    = archive_le16dec(p + offset) >> 8;\n\t\t\t\toffset += 2;\n\t\t\t\tdatasize -= 2;\n\t\t\t}\n\t\t\tif (bitmap & 2) {\n\t\t\t\t/* 2 byte \"internal file attributes\" */\n\t\t\t\tuint32_t internal_attributes;\n\t\t\t\tif (datasize < 2)\n\t\t\t\t\tbreak;\n\t\t\t\tinternal_attributes\n\t\t\t\t    = archive_le16dec(p + offset);\n\t\t\t\t/* Not used by libarchive at present. */\n\t\t\t\t(void)internal_attributes; /* UNUSED */\n\t\t\t\toffset += 2;\n\t\t\t\tdatasize -= 2;\n\t\t\t}\n\t\t\tif (bitmap & 4) {\n\t\t\t\t/* 4 byte \"external file attributes\" */\n\t\t\t\tuint32_t external_attributes;\n\t\t\t\tif (datasize < 4)\n\t\t\t\t\tbreak;\n\t\t\t\texternal_attributes\n\t\t\t\t    = archive_le32dec(p + offset);\n\t\t\t\tif (zip_entry->system == 3) {\n\t\t\t\t\tzip_entry->mode\n\t\t\t\t\t    = external_attributes >> 16;\n\t\t\t\t} else if (zip_entry->system == 0) {\n\t\t\t\t\t// Interpret MSDOS directory bit\n\t\t\t\t\tif (0x10 == (external_attributes & 0x10)) {\n\t\t\t\t\t\tzip_entry->mode = AE_IFDIR | 0775;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tzip_entry->mode = AE_IFREG | 0664;\n\t\t\t\t\t}\n\t\t\t\t\tif (0x01 == (external_attributes & 0x01)) {\n\t\t\t\t\t\t// Read-only bit; strip write permissions\n\t\t\t\t\t\tzip_entry->mode &= 0555;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tzip_entry->mode = 0;\n\t\t\t\t}\n\t\t\t\toffset += 4;\n\t\t\t\tdatasize -= 4;\n\t\t\t}\n\t\t\tif (bitmap & 8) {\n\t\t\t\t/* 2 byte comment length + comment */\n\t\t\t\tuint32_t comment_length;\n\t\t\t\tif (datasize < 2)\n\t\t\t\t\tbreak;\n\t\t\t\tcomment_length\n\t\t\t\t    = archive_le16dec(p + offset);\n\t\t\t\toffset += 2;\n\t\t\t\tdatasize -= 2;\n\n\t\t\t\tif (datasize < comment_length)\n\t\t\t\t\tbreak;\n\t\t\t\t/* Comment is not supported by libarchive */\n\t\t\t\toffset += comment_length;\n\t\t\t\tdatasize -= comment_length;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase 0x7855:\n\t\t\t/* Info-ZIP Unix Extra Field (type 2) \"Ux\". */\n#ifdef DEBUG\n\t\t\tfprintf(stderr, \"uid %d gid %d\\n\",\n\t\t\t    archive_le16dec(p + offset),\n\t\t\t    archive_le16dec(p + offset + 2));\n#endif\n\t\t\tif (datasize >= 2)\n\t\t\t\tzip_entry->uid = archive_le16dec(p + offset);\n\t\t\tif (datasize >= 4)\n\t\t\t\tzip_entry->gid =\n\t\t\t\t    archive_le16dec(p + offset + 2);\n\t\t\tbreak;\n\t\tcase 0x7875:\n\t\t{\n\t\t\t/* Info-Zip Unix Extra Field (type 3) \"ux\". */\n\t\t\tint uidsize = 0, gidsize = 0;\n\n\t\t\t/* TODO: support arbitrary uidsize/gidsize. */\n\t\t\tif (datasize >= 1 && p[offset] == 1) {/* version=1 */\n\t\t\t\tif (datasize >= 4) {\n\t\t\t\t\t/* get a uid size. */\n\t\t\t\t\tuidsize = 0xff & (int)p[offset+1];\n\t\t\t\t\tif (uidsize == 2)\n\t\t\t\t\t\tzip_entry->uid =\n\t\t\t\t\t\t    archive_le16dec(\n\t\t\t\t\t\t        p + offset + 2);\n\t\t\t\t\telse if (uidsize == 4 && datasize >= 6)\n\t\t\t\t\t\tzip_entry->uid =\n\t\t\t\t\t\t    archive_le32dec(\n\t\t\t\t\t\t        p + offset + 2);\n\t\t\t\t}\n\t\t\t\tif (datasize >= (2 + uidsize + 3)) {\n\t\t\t\t\t/* get a gid size. */\n\t\t\t\t\tgidsize = 0xff & (int)p[offset+2+uidsize];\n\t\t\t\t\tif (gidsize == 2)\n\t\t\t\t\t\tzip_entry->gid =\n\t\t\t\t\t\t    archive_le16dec(\n\t\t\t\t\t\t        p+offset+2+uidsize+1);\n\t\t\t\t\telse if (gidsize == 4 &&\n\t\t\t\t\t    datasize >= (2 + uidsize + 5))\n\t\t\t\t\t\tzip_entry->gid =\n\t\t\t\t\t\t    archive_le32dec(\n\t\t\t\t\t\t        p+offset+2+uidsize+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase 0x9901:\n\t\t\t/* WinZip AES extra data field. */\n\t\t\tif (datasize < 6) {\n\t\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \"Incomplete AES field\");\n\t\t\t\treturn ARCHIVE_FAILED;\n\t\t\t}\n\t\t\tif (p[offset + 2] == 'A' && p[offset + 3] == 'E') {\n\t\t\t\t/* Vendor version. */\n\t\t\t\tzip_entry->aes_extra.vendor =\n\t\t\t\t    archive_le16dec(p + offset);\n\t\t\t\t/* AES encryption strength. */\n\t\t\t\tzip_entry->aes_extra.strength = p[offset + 4];\n\t\t\t\t/* Actual compression method. */\n\t\t\t\tzip_entry->aes_extra.compression =\n\t\t\t\t    p[offset + 5];\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\toffset += datasize;\n\t}\n\tif (offset != extra_length) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Malformed extra data: Consumed %d bytes of %d bytes\",\n\t\t    (int)offset, (int)extra_length);\n\t\treturn ARCHIVE_FAILED;\n\t}\n\treturn ARCHIVE_OK;\n}\n\n/*\n * Assumes file pointer is at beginning of local file header.\n */\nstatic int\nzip_read_local_file_header(struct archive_read *a, struct archive_entry *entry,\n    struct zip *zip)\n{\n\tconst char *p;\n\tconst void *h;\n\tconst wchar_t *wp;\n\tconst char *cp;\n\tsize_t len, filename_length, extra_length;\n\tstruct archive_string_conv *sconv;\n\tstruct zip_entry *zip_entry = zip->entry;\n\tstruct zip_entry zip_entry_central_dir;\n\tint ret = ARCHIVE_OK;\n\tchar version;\n\n\t/* Save a copy of the original for consistency checks. */\n\tzip_entry_central_dir = *zip_entry;\n\n\tzip->decompress_init = 0;\n\tzip->end_of_entry = 0;\n\tzip->entry_uncompressed_bytes_read = 0;\n\tzip->entry_compressed_bytes_read = 0;\n\tzip->entry_crc32 = zip->crc32func(0, NULL, 0);\n\n\t/* Setup default conversion. */\n\tif (zip->sconv == NULL && !zip->init_default_conversion) {\n\t\tzip->sconv_default =\n\t\t    archive_string_default_conversion_for_read(&(a->archive));\n\t\tzip->init_default_conversion = 1;\n\t}\n\n\tif ((p = __archive_read_ahead(a, 30, NULL)) == NULL) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Truncated ZIP file header\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\tif (memcmp(p, \"PK\\003\\004\", 4) != 0) {\n\t\tarchive_set_error(&a->archive, -1, \"Damaged Zip archive\");\n\t\treturn ARCHIVE_FATAL;\n\t}\n\tversion = p[4];\n\tzip_entry->system = p[5];\n\tzip_entry->zip_flags = archive_le16dec(p + 6);\n\tif (zip_entry->zip_flags & (ZIP_ENCRYPTED | ZIP_STRONG_ENCRYPTED)) {\n\t\tzip->has_encrypted_entries = 1;\n\t\tarchive_entry_set_is_data_encrypted(entry, 1);\n\t\tif (zip_entry->zip_flags & ZIP_CENTRAL_DIRECTORY_ENCRYPTED &&\n\t\t\tzip_entry->zip_flags & ZIP_ENCRYPTED &&\n\t\t\tzip_entry->zip_flags & ZIP_STRONG_ENCRYPTED) {\n\t\t\tarchive_entry_set_is_metadata_encrypted(entry, 1);\n\t\t\treturn ARCHIVE_FATAL;\n\t\t}\n\t}\n\tzip->init_decryption = (zip_entry->zip_flags & ZIP_ENCRYPTED);\n\tzip_entry->compression = (char)archive_le16dec(p + 8);\n\tzip_entry->mtime = zip_time(p + 10);\n\tzip_entry->crc32 = archive_le32dec(p + 14);\n\tif (zip_entry->zip_flags & ZIP_LENGTH_AT_END)\n\t\tzip_entry->decdat = p[11];\n\telse\n\t\tzip_entry->decdat = p[17];\n\tzip_entry->compressed_size = archive_le32dec(p + 18);\n\tzip_entry->uncompressed_size = archive_le32dec(p + 22);\n\tfilename_length = archive_le16dec(p + 26);\n\textra_length = archive_le16dec(p + 28);\n\n\t__archive_read_consume(a, 30);\n\n\t/* Read the filename. */\n\tif ((h = __archive_read_ahead(a, filename_length, NULL)) == NULL) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Truncated ZIP file header\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\tif (zip_entry->zip_flags & ZIP_UTF8_NAME) {\n\t\t/* The filename is stored to be UTF-8. */\n\t\tif (zip->sconv_utf8 == NULL) {\n\t\t\tzip->sconv_utf8 =\n\t\t\t    archive_string_conversion_from_charset(\n\t\t\t\t&a->archive, \"UTF-8\", 1);\n\t\t\tif (zip->sconv_utf8 == NULL)\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tsconv = zip->sconv_utf8;\n\t} else if (zip->sconv != NULL)\n\t\tsconv = zip->sconv;\n\telse\n\t\tsconv = zip->sconv_default;\n\n\tif (archive_entry_copy_pathname_l(entry,\n\t    h, filename_length, sconv) != 0) {\n\t\tif (errno == ENOMEM) {\n\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t    \"Can't allocate memory for Pathname\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tarchive_set_error(&a->archive,\n\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Pathname cannot be converted \"\n\t\t    \"from %s to current locale.\",\n\t\t    archive_string_conversion_charset_name(sconv));\n\t\tret = ARCHIVE_WARN;\n\t}\n\t__archive_read_consume(a, filename_length);\n\n\t/* Read the extra data. */\n\tif ((h = __archive_read_ahead(a, extra_length, NULL)) == NULL) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Truncated ZIP file header\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\tif (ARCHIVE_OK != process_extra(a, h, extra_length, zip_entry)) {\n\t\treturn ARCHIVE_FATAL;\n\t}\n\t__archive_read_consume(a, extra_length);\n\n\t/* Work around a bug in Info-Zip: When reading from a pipe, it\n\t * stats the pipe instead of synthesizing a file entry. */\n\tif ((zip_entry->mode & AE_IFMT) == AE_IFIFO) {\n\t\tzip_entry->mode &= ~ AE_IFMT;\n\t\tzip_entry->mode |= AE_IFREG;\n\t}\n\n\t/* If the mode is totally empty, set some sane default. */\n\tif (zip_entry->mode == 0) {\n\t\tzip_entry->mode |= 0664;\n\t}\n\n\t/* Windows archivers sometimes use backslash as the directory separator.\n\t   Normalize to slash. */\n\tif (zip_entry->system == 0 &&\n\t    (wp = archive_entry_pathname_w(entry)) != NULL) {\n\t\tif (wcschr(wp, L'/') == NULL && wcschr(wp, L'\\\\') != NULL) {\n\t\t\tsize_t i;\n\t\t\tstruct archive_wstring s;\n\t\t\tarchive_string_init(&s);\n\t\t\tarchive_wstrcpy(&s, wp);\n\t\t\tfor (i = 0; i < archive_strlen(&s); i++) {\n\t\t\t\tif (s.s[i] == '\\\\')\n\t\t\t\t\ts.s[i] = '/';\n\t\t\t}\n\t\t\tarchive_entry_copy_pathname_w(entry, s.s);\n\t\t\tarchive_wstring_free(&s);\n\t\t}\n\t}\n\n\t/* Make sure that entries with a trailing '/' are marked as directories\n\t * even if the External File Attributes contains bogus values.  If this\n\t * is not a directory and there is no type, assume regularfile. */\n\tif ((zip_entry->mode & AE_IFMT) != AE_IFDIR) {\n\t\tint has_slash;\n\n\t\twp = archive_entry_pathname_w(entry);\n\t\tif (wp != NULL) {\n\t\t\tlen = wcslen(wp);\n\t\t\thas_slash = len > 0 && wp[len - 1] == L'/';\n\t\t} else {\n\t\t\tcp = archive_entry_pathname(entry);\n\t\t\tlen = (cp != NULL)?strlen(cp):0;\n\t\t\thas_slash = len > 0 && cp[len - 1] == '/';\n\t\t}\n\t\t/* Correct file type as needed. */\n\t\tif (has_slash) {\n\t\t\tzip_entry->mode &= ~AE_IFMT;\n\t\t\tzip_entry->mode |= AE_IFDIR;\n\t\t\tzip_entry->mode |= 0111;\n\t\t} else if ((zip_entry->mode & AE_IFMT) == 0) {\n\t\t\tzip_entry->mode |= AE_IFREG;\n\t\t}\n\t}\n\n\t/* Make sure directories end in '/' */\n\tif ((zip_entry->mode & AE_IFMT) == AE_IFDIR) {\n\t\twp = archive_entry_pathname_w(entry);\n\t\tif (wp != NULL) {\n\t\t\tlen = wcslen(wp);\n\t\t\tif (len > 0 && wp[len - 1] != L'/') {\n\t\t\t\tstruct archive_wstring s;\n\t\t\t\tarchive_string_init(&s);\n\t\t\t\tarchive_wstrcat(&s, wp);\n\t\t\t\tarchive_wstrappend_wchar(&s, L'/');\n\t\t\t\tarchive_entry_copy_pathname_w(entry, s.s);\n\t\t\t\tarchive_wstring_free(&s);\n\t\t\t}\n\t\t} else {\n\t\t\tcp = archive_entry_pathname(entry);\n\t\t\tlen = (cp != NULL)?strlen(cp):0;\n\t\t\tif (len > 0 && cp[len - 1] != '/') {\n\t\t\t\tstruct archive_string s;\n\t\t\t\tarchive_string_init(&s);\n\t\t\t\tarchive_strcat(&s, cp);\n\t\t\t\tarchive_strappend_char(&s, '/');\n\t\t\t\tarchive_entry_set_pathname(entry, s.s);\n\t\t\t\tarchive_string_free(&s);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (zip_entry->flags & LA_FROM_CENTRAL_DIRECTORY) {\n\t\t/* If this came from the central dir, it's size info\n\t\t * is definitive, so ignore the length-at-end flag. */\n\t\tzip_entry->zip_flags &= ~ZIP_LENGTH_AT_END;\n\t\t/* If local header is missing a value, use the one from\n\t\t   the central directory.  If both have it, warn about\n\t\t   mismatches. */\n\t\tif (zip_entry->crc32 == 0) {\n\t\t\tzip_entry->crc32 = zip_entry_central_dir.crc32;\n\t\t} else if (!zip->ignore_crc32\n\t\t    && zip_entry->crc32 != zip_entry_central_dir.crc32) {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Inconsistent CRC32 values\");\n\t\t\tret = ARCHIVE_WARN;\n\t\t}\n\t\tif (zip_entry->compressed_size == 0) {\n\t\t\tzip_entry->compressed_size\n\t\t\t    = zip_entry_central_dir.compressed_size;\n\t\t} else if (zip_entry->compressed_size\n\t\t    != zip_entry_central_dir.compressed_size) {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Inconsistent compressed size: \"\n\t\t\t    \"%jd in central directory, %jd in local header\",\n\t\t\t    (intmax_t)zip_entry_central_dir.compressed_size,\n\t\t\t    (intmax_t)zip_entry->compressed_size);\n\t\t\tret = ARCHIVE_WARN;\n\t\t}\n\t\tif (zip_entry->uncompressed_size == 0) {\n\t\t\tzip_entry->uncompressed_size\n\t\t\t    = zip_entry_central_dir.uncompressed_size;\n\t\t} else if (zip_entry->uncompressed_size\n\t\t    != zip_entry_central_dir.uncompressed_size) {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Inconsistent uncompressed size: \"\n\t\t\t    \"%jd in central directory, %jd in local header\",\n\t\t\t    (intmax_t)zip_entry_central_dir.uncompressed_size,\n\t\t\t    (intmax_t)zip_entry->uncompressed_size);\n\t\t\tret = ARCHIVE_WARN;\n\t\t}\n\t}\n\n\t/* Populate some additional entry fields: */\n\tarchive_entry_set_mode(entry, zip_entry->mode);\n\tarchive_entry_set_uid(entry, zip_entry->uid);\n\tarchive_entry_set_gid(entry, zip_entry->gid);\n\tarchive_entry_set_mtime(entry, zip_entry->mtime, 0);\n\tarchive_entry_set_ctime(entry, zip_entry->ctime, 0);\n\tarchive_entry_set_atime(entry, zip_entry->atime, 0);\n\n\tif ((zip->entry->mode & AE_IFMT) == AE_IFLNK) {\n\t\tsize_t linkname_length;\n\n\t\tif (zip_entry->compressed_size > 64 * 1024) {\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Zip file with oversized link entry\");\n\t\t\treturn ARCHIVE_FATAL;\n\t\t}\n\n\t\tlinkname_length = (size_t)zip_entry->compressed_size;\n\n\t\tarchive_entry_set_size(entry, 0);\n\t\tp = __archive_read_ahead(a, linkname_length, NULL);\n\t\tif (p == NULL) {\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Truncated Zip file\");\n\t\t\treturn ARCHIVE_FATAL;\n\t\t}\n\n\t\tsconv = zip->sconv;\n\t\tif (sconv == NULL && (zip->entry->zip_flags & ZIP_UTF8_NAME))\n\t\t\tsconv = zip->sconv_utf8;\n\t\tif (sconv == NULL)\n\t\t\tsconv = zip->sconv_default;\n\t\tif (archive_entry_copy_symlink_l(entry, p, linkname_length,\n\t\t    sconv) != 0) {\n\t\t\tif (errno != ENOMEM && sconv == zip->sconv_utf8 &&\n\t\t\t    (zip->entry->zip_flags & ZIP_UTF8_NAME))\n\t\t\t    archive_entry_copy_symlink_l(entry, p,\n\t\t\t\tlinkname_length, NULL);\n\t\t\tif (errno == ENOMEM) {\n\t\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t\t    \"Can't allocate memory for Symlink\");\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t\t/*\n\t\t\t * Since there is no character-set regulation for\n\t\t\t * symlink name, do not report the conversion error\n\t\t\t * in an automatic conversion.\n\t\t\t */\n\t\t\tif (sconv != zip->sconv_utf8 ||\n\t\t\t    (zip->entry->zip_flags & ZIP_UTF8_NAME) == 0) {\n\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \"Symlink cannot be converted \"\n\t\t\t\t    \"from %s to current locale.\",\n\t\t\t\t    archive_string_conversion_charset_name(\n\t\t\t\t\tsconv));\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t}\n\t\t}\n\t\tzip_entry->uncompressed_size = zip_entry->compressed_size = 0;\n\n\t\tif (__archive_read_consume(a, linkname_length) < 0) {\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Read error skipping symlink target name\");\n\t\t\treturn ARCHIVE_FATAL;\n\t\t}\n\t} else if (0 == (zip_entry->zip_flags & ZIP_LENGTH_AT_END)\n\t    || zip_entry->uncompressed_size > 0) {\n\t\t/* Set the size only if it's meaningful. */\n\t\tarchive_entry_set_size(entry, zip_entry->uncompressed_size);\n\t}\n\tzip->entry_bytes_remaining = zip_entry->compressed_size;\n\n\t/* If there's no body, force read_data() to return EOF immediately. */\n\tif (0 == (zip_entry->zip_flags & ZIP_LENGTH_AT_END)\n\t    && zip->entry_bytes_remaining < 1)\n\t\tzip->end_of_entry = 1;\n\n\t/* Set up a more descriptive format name. */\n        archive_string_empty(&zip->format_name);\n\tarchive_string_sprintf(&zip->format_name, \"ZIP %d.%d (%s)\",\n\t    version / 10, version % 10,\n\t    compression_name(zip->entry->compression));\n\ta->archive.archive_format_name = zip->format_name.s;\n\n\treturn (ret);\n}\n\nstatic int\ncheck_authentication_code(struct archive_read *a, const void *_p)\n{\n\tstruct zip *zip = (struct zip *)(a->format->data);\n\n\t/* Check authentication code. */\n\tif (zip->hctx_valid) {\n\t\tconst void *p;\n\t\tuint8_t hmac[20];\n\t\tsize_t hmac_len = 20;\n\t\tint cmp;\n\n\t\tarchive_hmac_sha1_final(&zip->hctx, hmac, &hmac_len);\n\t\tif (_p == NULL) {\n\t\t\t/* Read authentication code. */\n\t\t\tp = __archive_read_ahead(a, AUTH_CODE_SIZE, NULL);\n\t\t\tif (p == NULL) {\n\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \"Truncated ZIP file data\");\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t} else {\n\t\t\tp = _p;\n\t\t}\n\t\tcmp = memcmp(hmac, p, AUTH_CODE_SIZE);\n\t\t__archive_read_consume(a, AUTH_CODE_SIZE);\n\t\tif (cmp != 0) {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t    \"ZIP bad Authentication code\");\n\t\t\treturn (ARCHIVE_WARN);\n\t\t}\n\t}\n\treturn (ARCHIVE_OK);\n}\n\n/*\n * Read \"uncompressed\" data.  There are three cases:\n *  1) We know the size of the data.  This is always true for the\n * seeking reader (we've examined the Central Directory already).\n *  2) ZIP_LENGTH_AT_END was set, but only the CRC was deferred.\n * Info-ZIP seems to do this; we know the size but have to grab\n * the CRC from the data descriptor afterwards.\n *  3) We're streaming and ZIP_LENGTH_AT_END was specified and\n * we have no size information.  In this case, we can do pretty\n * well by watching for the data descriptor record.  The data\n * descriptor is 16 bytes and includes a computed CRC that should\n * provide a strong check.\n *\n * TODO: Technically, the PK\\007\\010 signature is optional.\n * In the original spec, the data descriptor contained CRC\n * and size fields but had no leading signature.  In practice,\n * newer writers seem to provide the signature pretty consistently.\n *\n * For uncompressed data, the PK\\007\\010 marker seems essential\n * to be sure we've actually seen the end of the entry.\n *\n * Returns ARCHIVE_OK if successful, ARCHIVE_FATAL otherwise, sets\n * zip->end_of_entry if it consumes all of the data.\n */\nstatic int\nzip_read_data_none(struct archive_read *a, const void **_buff,\n    size_t *size, int64_t *offset)\n{\n\tstruct zip *zip;\n\tconst char *buff;\n\tssize_t bytes_avail;\n\tint r;\n\n\t(void)offset; /* UNUSED */\n\n\tzip = (struct zip *)(a->format->data);\n\n\tif (zip->entry->zip_flags & ZIP_LENGTH_AT_END) {\n\t\tconst char *p;\n\t\tssize_t grabbing_bytes = 24;\n\n\t\tif (zip->hctx_valid)\n\t\t\tgrabbing_bytes += AUTH_CODE_SIZE;\n\t\t/* Grab at least 24 bytes. */\n\t\tbuff = __archive_read_ahead(a, grabbing_bytes, &bytes_avail);\n\t\tif (bytes_avail < grabbing_bytes) {\n\t\t\t/* Zip archives have end-of-archive markers\n\t\t\t   that are longer than this, so a failure to get at\n\t\t\t   least 24 bytes really does indicate a truncated\n\t\t\t   file. */\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Truncated ZIP file data\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\t/* Check for a complete PK\\007\\010 signature, followed\n\t\t * by the correct 4-byte CRC. */\n\t\tp = buff;\n\t\tif (zip->hctx_valid)\n\t\t\tp += AUTH_CODE_SIZE;\n\t\tif (p[0] == 'P' && p[1] == 'K'\n\t\t    && p[2] == '\\007' && p[3] == '\\010'\n\t\t    && (archive_le32dec(p + 4) == zip->entry_crc32\n\t\t\t|| zip->ignore_crc32\n\t\t\t|| (zip->hctx_valid\n\t\t\t && zip->entry->aes_extra.vendor == AES_VENDOR_AE_2))) {\n\t\t\tif (zip->entry->flags & LA_USED_ZIP64) {\n\t\t\t\tuint64_t compressed, uncompressed;\n\t\t\t\tzip->entry->crc32 = archive_le32dec(p + 4);\n\t\t\t\tcompressed = archive_le64dec(p + 8);\n\t\t\t\tuncompressed = archive_le64dec(p + 16);\n\t\t\t\tif (compressed > INT64_MAX || uncompressed > INT64_MAX) {\n\t\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t\t    \"Overflow of 64-bit file sizes\");\n\t\t\t\t\treturn ARCHIVE_FAILED;\n\t\t\t\t}\n\t\t\t\tzip->entry->compressed_size = compressed;\n\t\t\t\tzip->entry->uncompressed_size = uncompressed;\n\t\t\t\tzip->unconsumed = 24;\n\t\t\t} else {\n\t\t\t\tzip->entry->crc32 = archive_le32dec(p + 4);\n\t\t\t\tzip->entry->compressed_size =\n\t\t\t\t\tarchive_le32dec(p + 8);\n\t\t\t\tzip->entry->uncompressed_size =\n\t\t\t\t\tarchive_le32dec(p + 12);\n\t\t\t\tzip->unconsumed = 16;\n\t\t\t}\n\t\t\tif (zip->hctx_valid) {\n\t\t\t\tr = check_authentication_code(a, buff);\n\t\t\t\tif (r != ARCHIVE_OK)\n\t\t\t\t\treturn (r);\n\t\t\t}\n\t\t\tzip->end_of_entry = 1;\n\t\t\treturn (ARCHIVE_OK);\n\t\t}\n\t\t/* If not at EOF, ensure we consume at least one byte. */\n\t\t++p;\n\n\t\t/* Scan forward until we see where a PK\\007\\010 signature\n\t\t * might be. */\n\t\t/* Return bytes up until that point.  On the next call,\n\t\t * the code above will verify the data descriptor. */\n\t\twhile (p < buff + bytes_avail - 4) {\n\t\t\tif (p[3] == 'P') { p += 3; }\n\t\t\telse if (p[3] == 'K') { p += 2; }\n\t\t\telse if (p[3] == '\\007') { p += 1; }\n\t\t\telse if (p[3] == '\\010' && p[2] == '\\007'\n\t\t\t    && p[1] == 'K' && p[0] == 'P') {\n\t\t\t\tif (zip->hctx_valid)\n\t\t\t\t\tp -= AUTH_CODE_SIZE;\n\t\t\t\tbreak;\n\t\t\t} else { p += 4; }\n\t\t}\n\t\tbytes_avail = p - buff;\n\t} else {\n\t\tif (zip->entry_bytes_remaining == 0) {\n\t\t\tzip->end_of_entry = 1;\n\t\t\tif (zip->hctx_valid) {\n\t\t\t\tr = check_authentication_code(a, NULL);\n\t\t\t\tif (r != ARCHIVE_OK)\n\t\t\t\t\treturn (r);\n\t\t\t}\n\t\t\treturn (ARCHIVE_OK);\n\t\t}\n\t\t/* Grab a bunch of bytes. */\n\t\tbuff = __archive_read_ahead(a, 1, &bytes_avail);\n\t\tif (bytes_avail <= 0) {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Truncated ZIP file data\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tif (bytes_avail > zip->entry_bytes_remaining)\n\t\t\tbytes_avail = (ssize_t)zip->entry_bytes_remaining;\n\t}\n\tif (zip->tctx_valid || zip->cctx_valid) {\n\t\tsize_t dec_size = bytes_avail;\n\n\t\tif (dec_size > zip->decrypted_buffer_size)\n\t\t\tdec_size = zip->decrypted_buffer_size;\n\t\tif (zip->tctx_valid) {\n\t\t\ttrad_enc_decrypt_update(&zip->tctx,\n\t\t\t    (const uint8_t *)buff, dec_size,\n\t\t\t    zip->decrypted_buffer, dec_size);\n\t\t} else {\n\t\t\tsize_t dsize = dec_size;\n\t\t\tarchive_hmac_sha1_update(&zip->hctx,\n\t\t\t    (const uint8_t *)buff, dec_size);\n\t\t\tarchive_decrypto_aes_ctr_update(&zip->cctx,\n\t\t\t    (const uint8_t *)buff, dec_size,\n\t\t\t    zip->decrypted_buffer, &dsize);\n\t\t}\n\t\tbytes_avail = dec_size;\n\t\tbuff = (const char *)zip->decrypted_buffer;\n\t}\n\t*size = bytes_avail;\n\tzip->entry_bytes_remaining -= bytes_avail;\n\tzip->entry_uncompressed_bytes_read += bytes_avail;\n\tzip->entry_compressed_bytes_read += bytes_avail;\n\tzip->unconsumed += bytes_avail;\n\t*_buff = buff;\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\nconsume_optional_marker(struct archive_read *a, struct zip *zip)\n{\n\tif (zip->end_of_entry && (zip->entry->zip_flags & ZIP_LENGTH_AT_END)) {\n\t\tconst char *p;\n\n\t\tif (NULL == (p = __archive_read_ahead(a, 24, NULL))) {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Truncated ZIP end-of-file record\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\t/* Consume the optional PK\\007\\010 marker. */\n\t\tif (p[0] == 'P' && p[1] == 'K' &&\n\t\t    p[2] == '\\007' && p[3] == '\\010') {\n\t\t\tp += 4;\n\t\t\tzip->unconsumed = 4;\n\t\t}\n\t\tif (zip->entry->flags & LA_USED_ZIP64) {\n\t\t\tuint64_t compressed, uncompressed;\n\t\t\tzip->entry->crc32 = archive_le32dec(p);\n\t\t\tcompressed = archive_le64dec(p + 4);\n\t\t\tuncompressed = archive_le64dec(p + 12);\n\t\t\tif (compressed > INT64_MAX || uncompressed > INT64_MAX) {\n\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \"Overflow of 64-bit file sizes\");\n\t\t\t\treturn ARCHIVE_FAILED;\n\t\t\t}\n\t\t\tzip->entry->compressed_size = compressed;\n\t\t\tzip->entry->uncompressed_size = uncompressed;\n\t\t\tzip->unconsumed += 20;\n\t\t} else {\n\t\t\tzip->entry->crc32 = archive_le32dec(p);\n\t\t\tzip->entry->compressed_size = archive_le32dec(p + 4);\n\t\t\tzip->entry->uncompressed_size = archive_le32dec(p + 8);\n\t\t\tzip->unconsumed += 12;\n\t\t}\n\t}\n\n    return (ARCHIVE_OK);\n}\n\n#if HAVE_LZMA_H && HAVE_LIBLZMA\nstatic int\nzipx_xz_init(struct archive_read *a, struct zip *zip)\n{\n\tlzma_ret r;\n\n\tif(zip->zipx_lzma_valid) {\n\t\tlzma_end(&zip->zipx_lzma_stream);\n\t\tzip->zipx_lzma_valid = 0;\n\t}\n\n\tmemset(&zip->zipx_lzma_stream, 0, sizeof(zip->zipx_lzma_stream));\n\tr = lzma_stream_decoder(&zip->zipx_lzma_stream, UINT64_MAX, 0);\n\tif (r != LZMA_OK) {\n\t\tarchive_set_error(&(a->archive), ARCHIVE_ERRNO_MISC,\n\t\t    \"xz initialization failed(%d)\",\n\t\t    r);\n\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n\tzip->zipx_lzma_valid = 1;\n\n\tfree(zip->uncompressed_buffer);\n\n\tzip->uncompressed_buffer_size = 256 * 1024;\n\tzip->uncompressed_buffer =\n\t    (uint8_t*) malloc(zip->uncompressed_buffer_size);\n\tif (zip->uncompressed_buffer == NULL) {\n\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t    \"No memory for xz decompression\");\n\t\t    return (ARCHIVE_FATAL);\n\t}\n\n\tzip->decompress_init = 1;\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\nzipx_lzma_alone_init(struct archive_read *a, struct zip *zip)\n{\n\tlzma_ret r;\n\tconst uint8_t* p;\n\n#pragma pack(push)\n#pragma pack(1)\n\tstruct _alone_header {\n\t    uint8_t bytes[5];\n\t    uint64_t uncompressed_size;\n\t} alone_header;\n#pragma pack(pop)\n\n\t/* To unpack ZIPX's \"LZMA\" (id 14) stream we can use standard liblzma that\n\t * is a part of XZ Utils. The stream format stored inside ZIPX file is a\n\t * modified \"lzma alone\" file format, that was used by the `lzma` utility\n\t * which was later deprecated in favour of `xz` utility. Since those\n\t * formats are nearly the same, we can use a standard \"lzma alone\" decoder\n\t * from XZ Utils. */\n\n\tmemset(&zip->zipx_lzma_stream, 0, sizeof(zip->zipx_lzma_stream));\n\tr = lzma_alone_decoder(&zip->zipx_lzma_stream, UINT64_MAX);\n\tif (r != LZMA_OK) {\n\t\tarchive_set_error(&(a->archive), ARCHIVE_ERRNO_MISC,\n\t\t    \"lzma initialization failed(%d)\", r);\n\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n\t/* Flag the cleanup function that we want our lzma-related structures\n\t * to be freed later. */\n\tzip->zipx_lzma_valid = 1;\n\n\t/* The \"lzma alone\" file format and the stream format inside ZIPx are\n\t * almost the same. Here's an example of a structure of \"lzma alone\"\n\t * format:\n\t *\n\t * $ cat /bin/ls | lzma | xxd | head -n 1\n\t * 00000000: 5d00 0080 00ff ffff ffff ffff ff00 2814\n\t *\n\t *    5 bytes        8 bytes        n bytes\n\t * <lzma_params><uncompressed_size><data...>\n\t *\n\t * lzma_params is a 5-byte blob that has to be decoded to extract\n\t * parameters of this LZMA stream. The uncompressed_size field is an\n\t * uint64_t value that contains information about the size of the\n\t * uncompressed file, or UINT64_MAX if this value is unknown. The <data...>\n\t * part is the actual lzma-compressed data stream.\n\t *\n\t * Now here's the structure of the stream inside the ZIPX file:\n\t *\n\t * $ cat stream_inside_zipx | xxd | head -n 1\n\t * 00000000: 0914 0500 5d00 8000 0000 2814 .... ....\n\t *\n\t *  2byte   2byte    5 bytes     n bytes\n\t * <magic1><magic2><lzma_params><data...>\n\t *\n\t * This means that the ZIPX file contains an additional magic1 and magic2\n\t * headers, the lzma_params field contains the same parameter set as in the\n\t * \"lzma alone\" format, and the <data...> field is the same as in the \"lzma\n\t * alone\" format as well. Note that also the zipx format is missing the\n\t * uncompressed_size field.\n\t *\n\t * So, in order to use the \"lzma alone\" decoder for the zipx lzma stream,\n\t * we simply need to shuffle around some fields, prepare a new lzma alone\n\t * header, feed it into lzma alone decoder so it will initialize itself\n\t * properly, and then we can start feeding normal zipx lzma stream into the\n\t * decoder.\n\t */\n\n\t/* Read magic1,magic2,lzma_params from the ZIPX stream. */\n\tif((p = __archive_read_ahead(a, 9, NULL)) == NULL) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Truncated lzma data\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\tif(p[2] != 0x05 || p[3] != 0x00) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Invalid lzma data\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\t/* Prepare an lzma alone header: copy the lzma_params blob into a proper\n\t * place into the lzma alone header. */\n\tmemcpy(&alone_header.bytes[0], p + 4, 5);\n\n\t/* Initialize the 'uncompressed size' field to unknown; we'll manually\n\t * monitor how many bytes there are still to be uncompressed. */\n\talone_header.uncompressed_size = UINT64_MAX;\n\n\tif(!zip->uncompressed_buffer) {\n\t\tzip->uncompressed_buffer_size = 256 * 1024;\n\t\tzip->uncompressed_buffer =\n\t\t\t(uint8_t*) malloc(zip->uncompressed_buffer_size);\n\n\t\tif (zip->uncompressed_buffer == NULL) {\n\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t    \"No memory for lzma decompression\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t}\n\n\tzip->zipx_lzma_stream.next_in = (void*) &alone_header;\n\tzip->zipx_lzma_stream.avail_in = sizeof(alone_header);\n\tzip->zipx_lzma_stream.total_in = 0;\n\tzip->zipx_lzma_stream.next_out = zip->uncompressed_buffer;\n\tzip->zipx_lzma_stream.avail_out = zip->uncompressed_buffer_size;\n\tzip->zipx_lzma_stream.total_out = 0;\n\n\t/* Feed only the header into the lzma alone decoder. This will effectively\n\t * initialize the decoder, and will not produce any output bytes yet. */\n\tr = lzma_code(&zip->zipx_lzma_stream, LZMA_RUN);\n\tif (r != LZMA_OK) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_PROGRAMMER,\n\t\t    \"lzma stream initialization error\");\n\t\treturn ARCHIVE_FATAL;\n\t}\n\n\t/* We've already consumed some bytes, so take this into account. */\n\t__archive_read_consume(a, 9);\n\tzip->entry_bytes_remaining -= 9;\n\tzip->entry_compressed_bytes_read += 9;\n\n\tzip->decompress_init = 1;\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\nzip_read_data_zipx_xz(struct archive_read *a, const void **buff,\n\tsize_t *size, int64_t *offset)\n{\n\tstruct zip* zip = (struct zip *)(a->format->data);\n\tint ret;\n\tlzma_ret lz_ret;\n\tconst void* compressed_buf;\n\tssize_t bytes_avail, in_bytes, to_consume = 0;\n\n\t(void) offset; /* UNUSED */\n\n\t/* Initialize decompressor if not yet initialized. */\n\tif (!zip->decompress_init) {\n\t\tret = zipx_xz_init(a, zip);\n\t\tif (ret != ARCHIVE_OK)\n\t\t\treturn (ret);\n\t}\n\n\tcompressed_buf = __archive_read_ahead(a, 1, &bytes_avail);\n\tif (bytes_avail < 0) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Truncated xz file body\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\tin_bytes = zipmin(zip->entry_bytes_remaining, bytes_avail);\n\tzip->zipx_lzma_stream.next_in = compressed_buf;\n\tzip->zipx_lzma_stream.avail_in = in_bytes;\n\tzip->zipx_lzma_stream.total_in = 0;\n\tzip->zipx_lzma_stream.next_out = zip->uncompressed_buffer;\n\tzip->zipx_lzma_stream.avail_out = zip->uncompressed_buffer_size;\n\tzip->zipx_lzma_stream.total_out = 0;\n\n\t/* Perform the decompression. */\n\tlz_ret = lzma_code(&zip->zipx_lzma_stream, LZMA_RUN);\n\tswitch(lz_ret) {\n\t\tcase LZMA_DATA_ERROR:\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"xz data error (error %d)\", (int) lz_ret);\n\t\t\treturn (ARCHIVE_FATAL);\n\n\t\tcase LZMA_NO_CHECK:\n\t\tcase LZMA_OK:\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"xz unknown error %d\", (int) lz_ret);\n\t\t\treturn (ARCHIVE_FATAL);\n\n\t\tcase LZMA_STREAM_END:\n\t\t\tlzma_end(&zip->zipx_lzma_stream);\n\t\t\tzip->zipx_lzma_valid = 0;\n\n\t\t\tif((int64_t) zip->zipx_lzma_stream.total_in !=\n\t\t\t    zip->entry_bytes_remaining)\n\t\t\t{\n\t\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t\t    \"xz premature end of stream\");\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\n\t\t\tzip->end_of_entry = 1;\n\t\t\tbreak;\n\t}\n\n\tto_consume = zip->zipx_lzma_stream.total_in;\n\n\t__archive_read_consume(a, to_consume);\n\tzip->entry_bytes_remaining -= to_consume;\n\tzip->entry_compressed_bytes_read += to_consume;\n\tzip->entry_uncompressed_bytes_read += zip->zipx_lzma_stream.total_out;\n\n\t*size = zip->zipx_lzma_stream.total_out;\n\t*buff = zip->uncompressed_buffer;\n\n\tret = consume_optional_marker(a, zip);\n\tif (ret != ARCHIVE_OK)\n\t\treturn (ret);\n\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\nzip_read_data_zipx_lzma_alone(struct archive_read *a, const void **buff,\n    size_t *size, int64_t *offset)\n{\n\tstruct zip* zip = (struct zip *)(a->format->data);\n\tint ret;\n\tlzma_ret lz_ret;\n\tconst void* compressed_buf;\n\tssize_t bytes_avail, in_bytes, to_consume;\n\n\t(void) offset; /* UNUSED */\n\n\t/* Initialize decompressor if not yet initialized. */\n\tif (!zip->decompress_init) {\n\t\tret = zipx_lzma_alone_init(a, zip);\n\t\tif (ret != ARCHIVE_OK)\n\t\t\treturn (ret);\n\t}\n\n\t/* Fetch more compressed data. The same note as in deflate handler applies\n\t * here as well:\n\t *\n\t * Note: '1' here is a performance optimization. Recall that the\n\t * decompression layer returns a count of available bytes; asking for more\n\t * than that forces the decompressor to combine reads by copying data.\n\t */\n\tcompressed_buf = __archive_read_ahead(a, 1, &bytes_avail);\n\tif (bytes_avail < 0) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Truncated lzma file body\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\t/* Set decompressor parameters. */\n\tin_bytes = zipmin(zip->entry_bytes_remaining, bytes_avail);\n\n\tzip->zipx_lzma_stream.next_in = compressed_buf;\n\tzip->zipx_lzma_stream.avail_in = in_bytes;\n\tzip->zipx_lzma_stream.total_in = 0;\n\tzip->zipx_lzma_stream.next_out = zip->uncompressed_buffer;\n\tzip->zipx_lzma_stream.avail_out =\n\t\t/* These lzma_alone streams lack end of stream marker, so let's make\n\t\t * sure the unpacker won't try to unpack more than it's supposed to. */\n\t\tzipmin((int64_t) zip->uncompressed_buffer_size,\n\t\t    zip->entry->uncompressed_size -\n\t\t    zip->entry_uncompressed_bytes_read);\n\tzip->zipx_lzma_stream.total_out = 0;\n\n\t/* Perform the decompression. */\n\tlz_ret = lzma_code(&zip->zipx_lzma_stream, LZMA_RUN);\n\tswitch(lz_ret) {\n\t\tcase LZMA_DATA_ERROR:\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"lzma data error (error %d)\", (int) lz_ret);\n\t\t\treturn (ARCHIVE_FATAL);\n\n\t\tcase LZMA_OK:\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"lzma unknown error %d\", (int) lz_ret);\n\t\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\tto_consume = zip->zipx_lzma_stream.total_in;\n\n\t/* Update pointers. */\n\t__archive_read_consume(a, to_consume);\n\tzip->entry_bytes_remaining -= to_consume;\n\tzip->entry_compressed_bytes_read += to_consume;\n\tzip->entry_uncompressed_bytes_read += zip->zipx_lzma_stream.total_out;\n\n\tif(zip->entry_bytes_remaining == 0) {\n\t\tzip->end_of_entry = 1;\n\t}\n\n\t/* Return values. */\n\t*size = zip->zipx_lzma_stream.total_out;\n\t*buff = zip->uncompressed_buffer;\n\n\t/* Behave the same way as during deflate decompression. */\n\tret = consume_optional_marker(a, zip);\n\tif (ret != ARCHIVE_OK)\n\t\treturn (ret);\n\n\t/* Free lzma decoder handle because we'll no longer need it. */\n\tif(zip->end_of_entry) {\n\t\tlzma_end(&zip->zipx_lzma_stream);\n\t\tzip->zipx_lzma_valid = 0;\n\t}\n\n\t/* If we're here, then we're good! */\n\treturn (ARCHIVE_OK);\n}\n#endif /* HAVE_LZMA_H && HAVE_LIBLZMA */\n\nstatic int\nzipx_ppmd8_init(struct archive_read *a, struct zip *zip)\n{\n\tconst void* p;\n\tuint32_t val;\n\tuint32_t order;\n\tuint32_t mem;\n\tuint32_t restore_method;\n\n\t/* Remove previous decompression context if it exists. */\n\tif(zip->ppmd8_valid) {\n\t\t__archive_ppmd8_functions.Ppmd8_Free(&zip->ppmd8);\n\t\tzip->ppmd8_valid = 0;\n\t}\n\n\t/* Create a new decompression context. */\n\t__archive_ppmd8_functions.Ppmd8_Construct(&zip->ppmd8);\n\tzip->ppmd8_stream_failed = 0;\n\n\t/* Setup function pointers required by Ppmd8 decompressor. The\n\t * 'ppmd_read' function will feed new bytes to the decompressor,\n\t * and will increment the 'zip->zipx_ppmd_read_compressed' counter. */\n\tzip->ppmd8.Stream.In = &zip->zipx_ppmd_stream;\n\tzip->zipx_ppmd_stream.a = a;\n\tzip->zipx_ppmd_stream.Read = &ppmd_read;\n\n\t/* Reset number of read bytes to 0. */\n\tzip->zipx_ppmd_read_compressed = 0;\n\n\t/* Read Ppmd8 header (2 bytes). */\n\tp = __archive_read_ahead(a, 2, NULL);\n\tif(!p) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Truncated file data in PPMd8 stream\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\t__archive_read_consume(a, 2);\n\n\t/* Decode the stream's compression parameters. */\n\tval = archive_le16dec(p);\n\torder = (val & 15) + 1;\n\tmem = ((val >> 4) & 0xff) + 1;\n\trestore_method = (val >> 12);\n\n\tif(order < 2 || restore_method > 2) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Invalid parameter set in PPMd8 stream (order=%d, \"\n\t\t    \"restore=%d)\", order, restore_method);\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n\t/* Allocate the memory needed to properly decompress the file. */\n\tif(!__archive_ppmd8_functions.Ppmd8_Alloc(&zip->ppmd8, mem << 20)) {\n\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t    \"Unable to allocate memory for PPMd8 stream: %d bytes\",\n\t\t    mem << 20);\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\t/* Signal the cleanup function to release Ppmd8 context in the\n\t * cleanup phase. */\n\tzip->ppmd8_valid = 1;\n\n\t/* Perform further Ppmd8 initialization. */\n\tif(!__archive_ppmd8_functions.Ppmd8_RangeDec_Init(&zip->ppmd8)) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_PROGRAMMER,\n\t\t    \"PPMd8 stream range decoder initialization error\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\t__archive_ppmd8_functions.Ppmd8_Init(&zip->ppmd8, order, restore_method);\n\n\t/* Allocate the buffer that will hold uncompressed data. */\n\tfree(zip->uncompressed_buffer);\n\n\tzip->uncompressed_buffer_size = 256 * 1024;\n\tzip->uncompressed_buffer =\n\t    (uint8_t*) malloc(zip->uncompressed_buffer_size);\n\n\tif(zip->uncompressed_buffer == NULL) {\n\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t    \"No memory for PPMd8 decompression\");\n\t\treturn ARCHIVE_FATAL;\n\t}\n\n\t/* Ppmd8 initialization is done. */\n\tzip->decompress_init = 1;\n\n\t/* We've already read 2 bytes in the output stream. Additionally,\n\t * Ppmd8 initialization code could read some data as well. So we\n\t * are advancing the stream by 2 bytes plus whatever number of\n\t * bytes Ppmd8 init function used. */\n\tzip->entry_compressed_bytes_read += 2 + zip->zipx_ppmd_read_compressed;\n\n\treturn ARCHIVE_OK;\n}\n\nstatic int\nzip_read_data_zipx_ppmd(struct archive_read *a, const void **buff,\n    size_t *size, int64_t *offset)\n{\n\tstruct zip* zip = (struct zip *)(a->format->data);\n\tint ret;\n\tsize_t consumed_bytes = 0;\n\tssize_t bytes_avail = 0;\n\n\t(void) offset; /* UNUSED */\n\n\t/* If we're here for the first time, initialize Ppmd8 decompression\n\t * context first. */\n\tif(!zip->decompress_init) {\n\t\tret = zipx_ppmd8_init(a, zip);\n\t\tif(ret != ARCHIVE_OK)\n\t\t\treturn ret;\n\t}\n\n\t/* Fetch for more data. We're reading 1 byte here, but libarchive should\n\t * prefetch more bytes. */\n\t(void) __archive_read_ahead(a, 1, &bytes_avail);\n\tif(bytes_avail < 0) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Truncated PPMd8 file body\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\t/* This counter will be updated inside ppmd_read(), which at one\n\t * point will be called by Ppmd8_DecodeSymbol. */\n\tzip->zipx_ppmd_read_compressed = 0;\n\n\t/* Decompression loop. */\n\tdo {\n\t\tint sym = __archive_ppmd8_functions.Ppmd8_DecodeSymbol(&zip->ppmd8);\n\t\tif(sym < 0) {\n\t\t\tzip->end_of_entry = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* This field is set by ppmd_read() when there was no more data\n\t\t * to be read. */\n\t\tif(zip->ppmd8_stream_failed) {\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t\"Truncated PPMd8 file body\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\n\t\tzip->uncompressed_buffer[consumed_bytes] = (uint8_t) sym;\n\t\t++consumed_bytes;\n\t} while(consumed_bytes < zip->uncompressed_buffer_size);\n\n\t/* Update pointers for libarchive. */\n\t*buff = zip->uncompressed_buffer;\n\t*size = consumed_bytes;\n\n\t/* Update pointers so we can continue decompression in another call. */\n\tzip->entry_bytes_remaining -= zip->zipx_ppmd_read_compressed;\n\tzip->entry_compressed_bytes_read += zip->zipx_ppmd_read_compressed;\n\tzip->entry_uncompressed_bytes_read += consumed_bytes;\n\n\t/* If we're at the end of stream, deinitialize Ppmd8 context. */\n\tif(zip->end_of_entry) {\n\t\t__archive_ppmd8_functions.Ppmd8_Free(&zip->ppmd8);\n\t\tzip->ppmd8_valid = 0;\n\t}\n\n\t/* Seek for optional marker, same way as in each zip entry. */\n\tret = consume_optional_marker(a, zip);\n\tif (ret != ARCHIVE_OK)\n\t\treturn ret;\n\n\treturn ARCHIVE_OK;\n}\n\n#ifdef HAVE_BZLIB_H\nstatic int\nzipx_bzip2_init(struct archive_read *a, struct zip *zip)\n{\n\tint r;\n\n\t/* Deallocate already existing BZ2 decompression context if it\n\t * exists. */\n\tif(zip->bzstream_valid) {\n\t\tBZ2_bzDecompressEnd(&zip->bzstream);\n\t\tzip->bzstream_valid = 0;\n\t}\n\n\t/* Allocate a new BZ2 decompression context. */\n\tmemset(&zip->bzstream, 0, sizeof(bz_stream));\n\tr = BZ2_bzDecompressInit(&zip->bzstream, 0, 1);\n\tif(r != BZ_OK) {\n\t\tarchive_set_error(&(a->archive), ARCHIVE_ERRNO_MISC,\n\t\t    \"bzip2 initialization failed(%d)\",\n\t\t    r);\n\n\t\treturn ARCHIVE_FAILED;\n\t}\n\n\t/* Mark the bzstream field to be released in cleanup phase. */\n\tzip->bzstream_valid = 1;\n\n\t/* (Re)allocate the buffer that will contain decompressed bytes. */\n\tfree(zip->uncompressed_buffer);\n\n\tzip->uncompressed_buffer_size = 256 * 1024;\n\tzip->uncompressed_buffer =\n\t    (uint8_t*) malloc(zip->uncompressed_buffer_size);\n\tif (zip->uncompressed_buffer == NULL) {\n\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t    \"No memory for bzip2 decompression\");\n\t\t    return ARCHIVE_FATAL;\n\t}\n\n\t/* Initialization done. */\n\tzip->decompress_init = 1;\n\treturn ARCHIVE_OK;\n}\n\nstatic int\nzip_read_data_zipx_bzip2(struct archive_read *a, const void **buff,\n    size_t *size, int64_t *offset)\n{\n\tstruct zip *zip = (struct zip *)(a->format->data);\n\tssize_t bytes_avail = 0, in_bytes, to_consume;\n\tconst void *compressed_buff;\n\tint r;\n\tuint64_t total_out;\n\n\t(void) offset; /* UNUSED */\n\n\t/* Initialize decompression context if we're here for the first time. */\n\tif(!zip->decompress_init) {\n\t\tr = zipx_bzip2_init(a, zip);\n\t\tif(r != ARCHIVE_OK)\n\t\t\treturn r;\n\t}\n\n\t/* Fetch more compressed bytes. */\n\tcompressed_buff = __archive_read_ahead(a, 1, &bytes_avail);\n\tif(bytes_avail < 0) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Truncated bzip2 file body\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\tin_bytes = zipmin(zip->entry_bytes_remaining, bytes_avail);\n\tif(in_bytes < 1) {\n\t\t/* libbz2 doesn't complain when caller feeds avail_in == 0. It will\n\t\t * actually return success in this case, which is undesirable. This is\n\t\t * why we need to make this check manually. */\n\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Truncated bzip2 file body\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\t/* Setup buffer boundaries. */\n\tzip->bzstream.next_in = (char*)(uintptr_t) compressed_buff;\n\tzip->bzstream.avail_in = in_bytes;\n\tzip->bzstream.total_in_hi32 = 0;\n\tzip->bzstream.total_in_lo32 = 0;\n\tzip->bzstream.next_out = (char*) zip->uncompressed_buffer;\n\tzip->bzstream.avail_out = zip->uncompressed_buffer_size;\n\tzip->bzstream.total_out_hi32 = 0;\n\tzip->bzstream.total_out_lo32 = 0;\n\n\t/* Perform the decompression. */\n\tr = BZ2_bzDecompress(&zip->bzstream);\n\tswitch(r) {\n\t\tcase BZ_STREAM_END:\n\t\t\t/* If we're at the end of the stream, deinitialize the\n\t\t\t * decompression context now. */\n\t\t\tswitch(BZ2_bzDecompressEnd(&zip->bzstream)) {\n\t\t\t\tcase BZ_OK:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t\t\t    \"Failed to clean up bzip2 decompressor\");\n\t\t\t\t\treturn ARCHIVE_FATAL;\n\t\t\t}\n\n\t\t\tzip->end_of_entry = 1;\n\t\t\tbreak;\n\t\tcase BZ_OK:\n\t\t\t/* The decompressor has successfully decoded this chunk of\n\t\t\t * data, but more data is still in queue. */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"bzip2 decompression failed\");\n\t\t\treturn ARCHIVE_FATAL;\n\t}\n\n\t/* Update the pointers so decompressor can continue decoding. */\n\tto_consume = zip->bzstream.total_in_lo32;\n\t__archive_read_consume(a, to_consume);\n\n\ttotal_out = ((uint64_t) zip->bzstream.total_out_hi32 << 32) +\n\t    zip->bzstream.total_out_lo32;\n\n\tzip->entry_bytes_remaining -= to_consume;\n\tzip->entry_compressed_bytes_read += to_consume;\n\tzip->entry_uncompressed_bytes_read += total_out;\n\n\t/* Give libarchive its due. */\n\t*size = total_out;\n\t*buff = zip->uncompressed_buffer;\n\n\t/* Seek for optional marker, like in other entries. */\n\tr = consume_optional_marker(a, zip);\n\tif(r != ARCHIVE_OK)\n\t\treturn r;\n\n\treturn ARCHIVE_OK;\n}\n\n#endif\n\n#ifdef HAVE_ZLIB_H\nstatic int\nzip_deflate_init(struct archive_read *a, struct zip *zip)\n{\n\tint r;\n\n\t/* If we haven't yet read any data, initialize the decompressor. */\n\tif (!zip->decompress_init) {\n\t\tif (zip->stream_valid)\n\t\t\tr = inflateReset(&zip->stream);\n\t\telse\n\t\t\tr = inflateInit2(&zip->stream,\n\t\t\t    -15 /* Don't check for zlib header */);\n\t\tif (r != Z_OK) {\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Can't initialize ZIP decompression.\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\t/* Stream structure has been set up. */\n\t\tzip->stream_valid = 1;\n\t\t/* We've initialized decompression for this stream. */\n\t\tzip->decompress_init = 1;\n\t}\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\nzip_read_data_deflate(struct archive_read *a, const void **buff,\n    size_t *size, int64_t *offset)\n{\n\tstruct zip *zip;\n\tssize_t bytes_avail;\n\tconst void *compressed_buff, *sp;\n\tint r;\n\n\t(void)offset; /* UNUSED */\n\n\tzip = (struct zip *)(a->format->data);\n\n\t/* If the buffer hasn't been allocated, allocate it now. */\n\tif (zip->uncompressed_buffer == NULL) {\n\t\tzip->uncompressed_buffer_size = 256 * 1024;\n\t\tzip->uncompressed_buffer\n\t\t    = (unsigned char *)malloc(zip->uncompressed_buffer_size);\n\t\tif (zip->uncompressed_buffer == NULL) {\n\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t    \"No memory for ZIP decompression\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t}\n\n\tr = zip_deflate_init(a, zip);\n\tif (r != ARCHIVE_OK)\n\t\treturn (r);\n\n\t/*\n\t * Note: '1' here is a performance optimization.\n\t * Recall that the decompression layer returns a count of\n\t * available bytes; asking for more than that forces the\n\t * decompressor to combine reads by copying data.\n\t */\n\tcompressed_buff = sp = __archive_read_ahead(a, 1, &bytes_avail);\n\tif (0 == (zip->entry->zip_flags & ZIP_LENGTH_AT_END)\n\t    && bytes_avail > zip->entry_bytes_remaining) {\n\t\tbytes_avail = (ssize_t)zip->entry_bytes_remaining;\n\t}\n\tif (bytes_avail < 0) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Truncated ZIP file body\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\tif (zip->tctx_valid || zip->cctx_valid) {\n\t\tif (zip->decrypted_bytes_remaining < (size_t)bytes_avail) {\n\t\t\tsize_t buff_remaining =\n\t\t\t    (zip->decrypted_buffer + zip->decrypted_buffer_size)\n\t\t\t    - (zip->decrypted_ptr + zip->decrypted_bytes_remaining);\n\n\t\t\tif (buff_remaining > (size_t)bytes_avail)\n\t\t\t\tbuff_remaining = (size_t)bytes_avail;\n\n\t\t\tif (0 == (zip->entry->zip_flags & ZIP_LENGTH_AT_END) &&\n\t\t\t      zip->entry_bytes_remaining > 0) {\n\t\t\t\tif ((int64_t)(zip->decrypted_bytes_remaining\n\t\t\t\t    + buff_remaining)\n\t\t\t\t      > zip->entry_bytes_remaining) {\n\t\t\t\t\tif (zip->entry_bytes_remaining <\n\t\t\t\t\t      (int64_t)zip->decrypted_bytes_remaining)\n\t\t\t\t\t\tbuff_remaining = 0;\n\t\t\t\t\telse\n\t\t\t\t\t\tbuff_remaining =\n\t\t\t\t\t\t    (size_t)zip->entry_bytes_remaining\n\t\t\t\t\t\t      - zip->decrypted_bytes_remaining;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (buff_remaining > 0) {\n\t\t\t\tif (zip->tctx_valid) {\n\t\t\t\t\ttrad_enc_decrypt_update(&zip->tctx,\n\t\t\t\t\t    compressed_buff, buff_remaining,\n\t\t\t\t\t    zip->decrypted_ptr\n\t\t\t\t\t      + zip->decrypted_bytes_remaining,\n\t\t\t\t\t    buff_remaining);\n\t\t\t\t} else {\n\t\t\t\t\tsize_t dsize = buff_remaining;\n\t\t\t\t\tarchive_decrypto_aes_ctr_update(\n\t\t\t\t\t    &zip->cctx,\n\t\t\t\t\t    compressed_buff, buff_remaining,\n\t\t\t\t\t    zip->decrypted_ptr\n\t\t\t\t\t      + zip->decrypted_bytes_remaining,\n\t\t\t\t\t    &dsize);\n\t\t\t\t}\n\t\t\t\tzip->decrypted_bytes_remaining += buff_remaining;\n\t\t\t}\n\t\t}\n\t\tbytes_avail = zip->decrypted_bytes_remaining;\n\t\tcompressed_buff = (const char *)zip->decrypted_ptr;\n\t}\n\n\t/*\n\t * A bug in zlib.h: stream.next_in should be marked 'const'\n\t * but isn't (the library never alters data through the\n\t * next_in pointer, only reads it).  The result: this ugly\n\t * cast to remove 'const'.\n\t */\n\tzip->stream.next_in = (Bytef *)(uintptr_t)(const void *)compressed_buff;\n\tzip->stream.avail_in = (uInt)bytes_avail;\n\tzip->stream.total_in = 0;\n\tzip->stream.next_out = zip->uncompressed_buffer;\n\tzip->stream.avail_out = (uInt)zip->uncompressed_buffer_size;\n\tzip->stream.total_out = 0;\n\n\tr = inflate(&zip->stream, 0);\n\tswitch (r) {\n\tcase Z_OK:\n\t\tbreak;\n\tcase Z_STREAM_END:\n\t\tzip->end_of_entry = 1;\n\t\tbreak;\n\tcase Z_MEM_ERROR:\n\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t    \"Out of memory for ZIP decompression\");\n\t\treturn (ARCHIVE_FATAL);\n\tdefault:\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"ZIP decompression failed (%d)\", r);\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\t/* Consume as much as the compressor actually used. */\n\tbytes_avail = zip->stream.total_in;\n\tif (zip->tctx_valid || zip->cctx_valid) {\n\t\tzip->decrypted_bytes_remaining -= bytes_avail;\n\t\tif (zip->decrypted_bytes_remaining == 0)\n\t\t\tzip->decrypted_ptr = zip->decrypted_buffer;\n\t\telse\n\t\t\tzip->decrypted_ptr += bytes_avail;\n\t}\n\t/* Calculate compressed data as much as we used.*/\n\tif (zip->hctx_valid)\n\t\tarchive_hmac_sha1_update(&zip->hctx, sp, bytes_avail);\n\t__archive_read_consume(a, bytes_avail);\n\tzip->entry_bytes_remaining -= bytes_avail;\n\tzip->entry_compressed_bytes_read += bytes_avail;\n\n\t*size = zip->stream.total_out;\n\tzip->entry_uncompressed_bytes_read += zip->stream.total_out;\n\t*buff = zip->uncompressed_buffer;\n\n\tif (zip->end_of_entry && zip->hctx_valid) {\n\t\tr = check_authentication_code(a, NULL);\n\t\tif (r != ARCHIVE_OK)\n\t\t\treturn (r);\n\t}\n\n\tr = consume_optional_marker(a, zip);\n\tif (r != ARCHIVE_OK)\n\t\treturn (r);\n\n\treturn (ARCHIVE_OK);\n}\n#endif\n\nstatic int\nread_decryption_header(struct archive_read *a)\n{\n\tstruct zip *zip = (struct zip *)(a->format->data);\n\tconst char *p;\n\tunsigned int remaining_size;\n\tunsigned int ts;\n\n\t/*\n\t * Read an initialization vector data field.\n\t */\n\tp = __archive_read_ahead(a, 2, NULL);\n\tif (p == NULL)\n\t\tgoto truncated;\n\tts = zip->iv_size;\n\tzip->iv_size = archive_le16dec(p);\n\t__archive_read_consume(a, 2);\n\tif (ts < zip->iv_size) {\n\t\tfree(zip->iv);\n\t\tzip->iv = NULL;\n\t}\n\tp = __archive_read_ahead(a, zip->iv_size, NULL);\n\tif (p == NULL)\n\t\tgoto truncated;\n\tif (zip->iv == NULL) {\n\t\tzip->iv = malloc(zip->iv_size);\n\t\tif (zip->iv == NULL)\n\t\t\tgoto nomem;\n\t}\n\tmemcpy(zip->iv, p, zip->iv_size);\n\t__archive_read_consume(a, zip->iv_size);\n\n\t/*\n\t * Read a size of remaining decryption header field.\n\t */\n\tp = __archive_read_ahead(a, 14, NULL);\n\tif (p == NULL)\n\t\tgoto truncated;\n\tremaining_size = archive_le32dec(p);\n\tif (remaining_size < 16 || remaining_size > (1 << 18))\n\t\tgoto corrupted;\n\n\t/* Check if format version is supported. */\n\tif (archive_le16dec(p+4) != 3) {\n\t\tarchive_set_error(&a->archive,\n\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Unsupported encryption format version: %u\",\n\t\t    archive_le16dec(p+4));\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n\t/*\n\t * Read an encryption algorithm field.\n\t */\n\tzip->alg_id = archive_le16dec(p+6);\n\tswitch (zip->alg_id) {\n\tcase 0x6601:/* DES */\n\tcase 0x6602:/* RC2 */\n\tcase 0x6603:/* 3DES 168 */\n\tcase 0x6609:/* 3DES 112 */\n\tcase 0x660E:/* AES 128 */\n\tcase 0x660F:/* AES 192 */\n\tcase 0x6610:/* AES 256 */\n\tcase 0x6702:/* RC2 (version >= 5.2) */\n\tcase 0x6720:/* Blowfish */\n\tcase 0x6721:/* Twofish */\n\tcase 0x6801:/* RC4 */\n\t\t/* Supported encryption algorithm. */\n\t\tbreak;\n\tdefault:\n\t\tarchive_set_error(&a->archive,\n\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Unknown encryption algorithm: %u\", zip->alg_id);\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n\t/*\n\t * Read a bit length field.\n\t */\n\tzip->bit_len = archive_le16dec(p+8);\n\n\t/*\n\t * Read a flags field.\n\t */\n\tzip->flags = archive_le16dec(p+10);\n\tswitch (zip->flags & 0xf000) {\n\tcase 0x0001: /* Password is required to decrypt. */\n\tcase 0x0002: /* Certificates only. */\n\tcase 0x0003: /* Password or certificate required to decrypt. */\n\t\tbreak;\n\tdefault:\n\t\tarchive_set_error(&a->archive,\n\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Unknown encryption flag: %u\", zip->flags);\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\tif ((zip->flags & 0xf000) == 0 ||\n\t    (zip->flags & 0xf000) == 0x4000) {\n\t\tarchive_set_error(&a->archive,\n\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Unknown encryption flag: %u\", zip->flags);\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n\t/*\n\t * Read an encrypted random data field.\n\t */\n\tts = zip->erd_size;\n\tzip->erd_size = archive_le16dec(p+12);\n\t__archive_read_consume(a, 14);\n\tif ((zip->erd_size & 0xf) != 0 ||\n\t    (zip->erd_size + 16) > remaining_size ||\n\t    (zip->erd_size + 16) < zip->erd_size)\n\t\tgoto corrupted;\n\n\tif (ts < zip->erd_size) {\n\t\tfree(zip->erd);\n\t\tzip->erd = NULL;\n\t}\n\tp = __archive_read_ahead(a, zip->erd_size, NULL);\n\tif (p == NULL)\n\t\tgoto truncated;\n\tif (zip->erd == NULL) {\n\t\tzip->erd = malloc(zip->erd_size);\n\t\tif (zip->erd == NULL)\n\t\t\tgoto nomem;\n\t}\n\tmemcpy(zip->erd, p, zip->erd_size);\n\t__archive_read_consume(a, zip->erd_size);\n\n\t/*\n\t * Read a reserved data field.\n\t */\n\tp = __archive_read_ahead(a, 4, NULL);\n\tif (p == NULL)\n\t\tgoto truncated;\n\t/* Reserved data size should be zero. */\n\tif (archive_le32dec(p) != 0)\n\t\tgoto corrupted;\n\t__archive_read_consume(a, 4);\n\n\t/*\n\t * Read a password validation data field.\n\t */\n\tp = __archive_read_ahead(a, 2, NULL);\n\tif (p == NULL)\n\t\tgoto truncated;\n\tts = zip->v_size;\n\tzip->v_size = archive_le16dec(p);\n\t__archive_read_consume(a, 2);\n\tif ((zip->v_size & 0x0f) != 0 ||\n\t    (zip->erd_size + zip->v_size + 16) > remaining_size ||\n\t    (zip->erd_size + zip->v_size + 16) < (zip->erd_size + zip->v_size))\n\t\tgoto corrupted;\n\tif (ts < zip->v_size) {\n\t\tfree(zip->v_data);\n\t\tzip->v_data = NULL;\n\t}\n\tp = __archive_read_ahead(a, zip->v_size, NULL);\n\tif (p == NULL)\n\t\tgoto truncated;\n\tif (zip->v_data == NULL) {\n\t\tzip->v_data = malloc(zip->v_size);\n\t\tif (zip->v_data == NULL)\n\t\t\tgoto nomem;\n\t}\n\tmemcpy(zip->v_data, p, zip->v_size);\n\t__archive_read_consume(a, zip->v_size);\n\n\tp = __archive_read_ahead(a, 4, NULL);\n\tif (p == NULL)\n\t\tgoto truncated;\n\tzip->v_crc32 = archive_le32dec(p);\n\t__archive_read_consume(a, 4);\n\n\t/*return (ARCHIVE_OK);\n\t * This is not fully implemented yet.*/\n\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t    \"Encrypted file is unsupported\");\n\treturn (ARCHIVE_FAILED);\ntruncated:\n\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t    \"Truncated ZIP file data\");\n\treturn (ARCHIVE_FATAL);\ncorrupted:\n\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t    \"Corrupted ZIP file data\");\n\treturn (ARCHIVE_FATAL);\nnomem:\n\tarchive_set_error(&a->archive, ENOMEM,\n\t    \"No memory for ZIP decryption\");\n\treturn (ARCHIVE_FATAL);\n}\n\nstatic int\nzip_alloc_decryption_buffer(struct archive_read *a)\n{\n\tstruct zip *zip = (struct zip *)(a->format->data);\n\tsize_t bs = 256 * 1024;\n\n\tif (zip->decrypted_buffer == NULL) {\n\t\tzip->decrypted_buffer_size = bs;\n\t\tzip->decrypted_buffer = malloc(bs);\n\t\tif (zip->decrypted_buffer == NULL) {\n\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t    \"No memory for ZIP decryption\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t}\n\tzip->decrypted_ptr = zip->decrypted_buffer;\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\ninit_traditional_PKWARE_decryption(struct archive_read *a)\n{\n\tstruct zip *zip = (struct zip *)(a->format->data);\n\tconst void *p;\n\tint retry;\n\tint r;\n\n\tif (zip->tctx_valid)\n\t\treturn (ARCHIVE_OK);\n\n\t/*\n\t   Read the 12 bytes encryption header stored at\n\t   the start of the data area.\n\t */\n#define ENC_HEADER_SIZE\t12\n\tif (0 == (zip->entry->zip_flags & ZIP_LENGTH_AT_END)\n\t    && zip->entry_bytes_remaining < ENC_HEADER_SIZE) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Truncated Zip encrypted body: only %jd bytes available\",\n\t\t    (intmax_t)zip->entry_bytes_remaining);\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\tp = __archive_read_ahead(a, ENC_HEADER_SIZE, NULL);\n\tif (p == NULL) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Truncated ZIP file data\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\tfor (retry = 0;; retry++) {\n\t\tconst char *passphrase;\n\t\tuint8_t crcchk;\n\n\t\tpassphrase = __archive_read_next_passphrase(a);\n\t\tif (passphrase == NULL) {\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    (retry > 0)?\n\t\t\t\t\"Incorrect passphrase\":\n\t\t\t\t\"Passphrase required for this entry\");\n\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n\n\t\t/*\n\t\t * Initialize ctx for Traditional PKWARE Decryption.\n\t\t */\n\t\tr = trad_enc_init(&zip->tctx, passphrase, strlen(passphrase),\n\t\t\tp, ENC_HEADER_SIZE, &crcchk);\n\t\tif (r == 0 && crcchk == zip->entry->decdat)\n\t\t\tbreak;/* The passphrase is OK. */\n\t\tif (retry > 10000) {\n\t\t\t/* Avoid infinity loop. */\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Too many incorrect passphrases\");\n\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n\t}\n\n\t__archive_read_consume(a, ENC_HEADER_SIZE);\n\tzip->tctx_valid = 1;\n\tif (0 == (zip->entry->zip_flags & ZIP_LENGTH_AT_END)) {\n\t    zip->entry_bytes_remaining -= ENC_HEADER_SIZE;\n\t}\n\t/*zip->entry_uncompressed_bytes_read += ENC_HEADER_SIZE;*/\n\tzip->entry_compressed_bytes_read += ENC_HEADER_SIZE;\n\tzip->decrypted_bytes_remaining = 0;\n\n\treturn (zip_alloc_decryption_buffer(a));\n#undef ENC_HEADER_SIZE\n}\n\nstatic int\ninit_WinZip_AES_decryption(struct archive_read *a)\n{\n\tstruct zip *zip = (struct zip *)(a->format->data);\n\tconst void *p;\n\tconst uint8_t *pv;\n\tsize_t key_len, salt_len;\n\tuint8_t derived_key[MAX_DERIVED_KEY_BUF_SIZE];\n\tint retry;\n\tint r;\n\n\tif (zip->cctx_valid || zip->hctx_valid)\n\t\treturn (ARCHIVE_OK);\n\n\tswitch (zip->entry->aes_extra.strength) {\n\tcase 1: salt_len = 8;  key_len = 16; break;\n\tcase 2: salt_len = 12; key_len = 24; break;\n\tcase 3: salt_len = 16; key_len = 32; break;\n\tdefault: goto corrupted;\n\t}\n\tp = __archive_read_ahead(a, salt_len + 2, NULL);\n\tif (p == NULL)\n\t\tgoto truncated;\n\n\tfor (retry = 0;; retry++) {\n\t\tconst char *passphrase;\n\n\t\tpassphrase = __archive_read_next_passphrase(a);\n\t\tif (passphrase == NULL) {\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    (retry > 0)?\n\t\t\t\t\"Incorrect passphrase\":\n\t\t\t\t\"Passphrase required for this entry\");\n\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n\t\tmemset(derived_key, 0, sizeof(derived_key));\n\t\tr = archive_pbkdf2_sha1(passphrase, strlen(passphrase),\n\t\t    p, salt_len, 1000, derived_key, key_len * 2 + 2);\n\t\tif (r != 0) {\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Decryption is unsupported due to lack of \"\n\t\t\t    \"crypto library\");\n\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n\n\t\t/* Check password verification value. */\n\t\tpv = ((const uint8_t *)p) + salt_len;\n\t\tif (derived_key[key_len * 2] == pv[0] &&\n\t\t    derived_key[key_len * 2 + 1] == pv[1])\n\t\t\tbreak;/* The passphrase is OK. */\n\t\tif (retry > 10000) {\n\t\t\t/* Avoid infinity loop. */\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Too many incorrect passphrases\");\n\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n\t}\n\n\tr = archive_decrypto_aes_ctr_init(&zip->cctx, derived_key, key_len);\n\tif (r != 0) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"Decryption is unsupported due to lack of crypto library\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\tr = archive_hmac_sha1_init(&zip->hctx, derived_key + key_len, key_len);\n\tif (r != 0) {\n\t\tarchive_decrypto_aes_ctr_release(&zip->cctx);\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"Failed to initialize HMAC-SHA1\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\tzip->cctx_valid = zip->hctx_valid = 1;\n\t__archive_read_consume(a, salt_len + 2);\n\tzip->entry_bytes_remaining -= salt_len + 2 + AUTH_CODE_SIZE;\n\tif (0 == (zip->entry->zip_flags & ZIP_LENGTH_AT_END)\n\t    && zip->entry_bytes_remaining < 0)\n\t\tgoto corrupted;\n\tzip->entry_compressed_bytes_read += salt_len + 2 + AUTH_CODE_SIZE;\n\tzip->decrypted_bytes_remaining = 0;\n\n\tzip->entry->compression = zip->entry->aes_extra.compression;\n\treturn (zip_alloc_decryption_buffer(a));\n\ntruncated:\n\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t    \"Truncated ZIP file data\");\n\treturn (ARCHIVE_FATAL);\ncorrupted:\n\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t    \"Corrupted ZIP file data\");\n\treturn (ARCHIVE_FATAL);\n}\n\nstatic int\narchive_read_format_zip_read_data(struct archive_read *a,\n    const void **buff, size_t *size, int64_t *offset)\n{\n\tint r;\n\tstruct zip *zip = (struct zip *)(a->format->data);\n\n\tif (zip->has_encrypted_entries ==\n\t\t\tARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW) {\n\t\tzip->has_encrypted_entries = 0;\n\t}\n\n\t*offset = zip->entry_uncompressed_bytes_read;\n\t*size = 0;\n\t*buff = NULL;\n\n\t/* If we hit end-of-entry last time, return ARCHIVE_EOF. */\n\tif (zip->end_of_entry)\n\t\treturn (ARCHIVE_EOF);\n\n\t/* Return EOF immediately if this is a non-regular file. */\n\tif (AE_IFREG != (zip->entry->mode & AE_IFMT))\n\t\treturn (ARCHIVE_EOF);\n\n\t__archive_read_consume(a, zip->unconsumed);\n\tzip->unconsumed = 0;\n\n\tif (zip->init_decryption) {\n\t\tzip->has_encrypted_entries = 1;\n\t\tif (zip->entry->zip_flags & ZIP_STRONG_ENCRYPTED)\n\t\t\tr = read_decryption_header(a);\n\t\telse if (zip->entry->compression == WINZIP_AES_ENCRYPTION)\n\t\t\tr = init_WinZip_AES_decryption(a);\n\t\telse\n\t\t\tr = init_traditional_PKWARE_decryption(a);\n\t\tif (r != ARCHIVE_OK)\n\t\t\treturn (r);\n\t\tzip->init_decryption = 0;\n\t}\n\n\tswitch(zip->entry->compression) {\n\tcase 0:  /* No compression. */\n\t\tr =  zip_read_data_none(a, buff, size, offset);\n\t\tbreak;\n#ifdef HAVE_BZLIB_H\n\tcase 12: /* ZIPx bzip2 compression. */\n\t\tr = zip_read_data_zipx_bzip2(a, buff, size, offset);\n\t\tbreak;\n#endif\n#if HAVE_LZMA_H && HAVE_LIBLZMA\n\tcase 14: /* ZIPx LZMA compression. */\n\t\tr = zip_read_data_zipx_lzma_alone(a, buff, size, offset);\n\t\tbreak;\n\tcase 95: /* ZIPx XZ compression. */\n\t\tr = zip_read_data_zipx_xz(a, buff, size, offset);\n\t\tbreak;\n#endif\n\t/* PPMd support is built-in, so we don't need any #if guards. */\n\tcase 98: /* ZIPx PPMd compression. */\n\t\tr = zip_read_data_zipx_ppmd(a, buff, size, offset);\n\t\tbreak;\n\n#ifdef HAVE_ZLIB_H\n\tcase 8: /* Deflate compression. */\n\t\tr =  zip_read_data_deflate(a, buff, size, offset);\n\t\tbreak;\n#endif\n\tdefault: /* Unsupported compression. */\n\t\t/* Return a warning. */\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Unsupported ZIP compression method (%d: %s)\",\n\t\t    zip->entry->compression, compression_name(zip->entry->compression));\n\t\t/* We can't decompress this entry, but we will\n\t\t * be able to skip() it and try the next entry. */\n\t\treturn (ARCHIVE_FAILED);\n\t\tbreak;\n\t}\n\tif (r != ARCHIVE_OK)\n\t\treturn (r);\n\t/* Update checksum */\n\tif (*size)\n\t\tzip->entry_crc32 = zip->crc32func(zip->entry_crc32, *buff,\n\t\t    (unsigned)*size);\n\t/* If we hit the end, swallow any end-of-data marker. */\n\tif (zip->end_of_entry) {\n\t\t/* Check file size, CRC against these values. */\n\t\tif (zip->entry->compressed_size !=\n\t\t    zip->entry_compressed_bytes_read) {\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"ZIP compressed data is wrong size \"\n\t\t\t    \"(read %jd, expected %jd)\",\n\t\t\t    (intmax_t)zip->entry_compressed_bytes_read,\n\t\t\t    (intmax_t)zip->entry->compressed_size);\n\t\t\treturn (ARCHIVE_WARN);\n\t\t}\n\t\t/* Size field only stores the lower 32 bits of the actual\n\t\t * size. */\n\t\tif ((zip->entry->uncompressed_size & UINT32_MAX)\n\t\t    != (zip->entry_uncompressed_bytes_read & UINT32_MAX)) {\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"ZIP uncompressed data is wrong size \"\n\t\t\t    \"(read %jd, expected %jd)\\n\",\n\t\t\t    (intmax_t)zip->entry_uncompressed_bytes_read,\n\t\t\t    (intmax_t)zip->entry->uncompressed_size);\n\t\t\treturn (ARCHIVE_WARN);\n\t\t}\n\t\t/* Check computed CRC against header */\n\t\tif ((!zip->hctx_valid ||\n\t\t      zip->entry->aes_extra.vendor != AES_VENDOR_AE_2) &&\n\t\t   zip->entry->crc32 != zip->entry_crc32\n\t\t    && !zip->ignore_crc32) {\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"ZIP bad CRC: 0x%lx should be 0x%lx\",\n\t\t\t    (unsigned long)zip->entry_crc32,\n\t\t\t    (unsigned long)zip->entry->crc32);\n\t\t\treturn (ARCHIVE_WARN);\n\t\t}\n\t}\n\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\narchive_read_format_zip_cleanup(struct archive_read *a)\n{\n\tstruct zip *zip;\n\tstruct zip_entry *zip_entry, *next_zip_entry;\n\n\tzip = (struct zip *)(a->format->data);\n\n#ifdef HAVE_ZLIB_H\n\tif (zip->stream_valid)\n\t\tinflateEnd(&zip->stream);\n#endif\n\n#if HAVE_LZMA_H && HAVE_LIBLZMA\n    if (zip->zipx_lzma_valid) {\n\t\tlzma_end(&zip->zipx_lzma_stream);\n\t}\n#endif\n\n#ifdef HAVE_BZLIB_H\n\tif (zip->bzstream_valid) {\n\t\tBZ2_bzDecompressEnd(&zip->bzstream);\n\t}\n#endif\n\n\tfree(zip->uncompressed_buffer);\n\n\tif (zip->ppmd8_valid)\n\t\t__archive_ppmd8_functions.Ppmd8_Free(&zip->ppmd8);\n\n\tif (zip->zip_entries) {\n\t\tzip_entry = zip->zip_entries;\n\t\twhile (zip_entry != NULL) {\n\t\t\tnext_zip_entry = zip_entry->next;\n\t\t\tarchive_string_free(&zip_entry->rsrcname);\n\t\t\tfree(zip_entry);\n\t\t\tzip_entry = next_zip_entry;\n\t\t}\n\t}\n\tfree(zip->decrypted_buffer);\n\tif (zip->cctx_valid)\n\t\tarchive_decrypto_aes_ctr_release(&zip->cctx);\n\tif (zip->hctx_valid)\n\t\tarchive_hmac_sha1_cleanup(&zip->hctx);\n\tfree(zip->iv);\n\tfree(zip->erd);\n\tfree(zip->v_data);\n\tarchive_string_free(&zip->format_name);\n\tfree(zip);\n\t(a->format->data) = NULL;\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\narchive_read_format_zip_has_encrypted_entries(struct archive_read *_a)\n{\n\tif (_a && _a->format) {\n\t\tstruct zip * zip = (struct zip *)_a->format->data;\n\t\tif (zip) {\n\t\t\treturn zip->has_encrypted_entries;\n\t\t}\n\t}\n\treturn ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW;\n}\n\nstatic int\narchive_read_format_zip_options(struct archive_read *a,\n    const char *key, const char *val)\n{\n\tstruct zip *zip;\n\tint ret = ARCHIVE_FAILED;\n\n\tzip = (struct zip *)(a->format->data);\n\tif (strcmp(key, \"compat-2x\")  == 0) {\n\t\t/* Handle filenames as libarchive 2.x */\n\t\tzip->init_default_conversion = (val != NULL) ? 1 : 0;\n\t\treturn (ARCHIVE_OK);\n\t} else if (strcmp(key, \"hdrcharset\")  == 0) {\n\t\tif (val == NULL || val[0] == 0)\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"zip: hdrcharset option needs a character-set name\"\n\t\t\t);\n\t\telse {\n\t\t\tzip->sconv = archive_string_conversion_from_charset(\n\t\t\t    &a->archive, val, 0);\n\t\t\tif (zip->sconv != NULL) {\n\t\t\t\tif (strcmp(val, \"UTF-8\") == 0)\n\t\t\t\t\tzip->sconv_utf8 = zip->sconv;\n\t\t\t\tret = ARCHIVE_OK;\n\t\t\t} else\n\t\t\t\tret = ARCHIVE_FATAL;\n\t\t}\n\t\treturn (ret);\n\t} else if (strcmp(key, \"ignorecrc32\") == 0) {\n\t\t/* Mostly useful for testing. */\n\t\tif (val == NULL || val[0] == 0) {\n\t\t\tzip->crc32func = real_crc32;\n\t\t\tzip->ignore_crc32 = 0;\n\t\t} else {\n\t\t\tzip->crc32func = fake_crc32;\n\t\t\tzip->ignore_crc32 = 1;\n\t\t}\n\t\treturn (ARCHIVE_OK);\n\t} else if (strcmp(key, \"mac-ext\") == 0) {\n\t\tzip->process_mac_extensions = (val != NULL && val[0] != 0);\n\t\treturn (ARCHIVE_OK);\n\t}\n\n\t/* Note: The \"warn\" return is just to inform the options\n\t * supervisor that we didn't handle it.  It will generate\n\t * a suitable error if no one used this option. */\n\treturn (ARCHIVE_WARN);\n}\n\nint\narchive_read_support_format_zip(struct archive *a)\n{\n\tint r;\n\tr = archive_read_support_format_zip_streamable(a);\n\tif (r != ARCHIVE_OK)\n\t\treturn r;\n\treturn (archive_read_support_format_zip_seekable(a));\n}\n\n/* ------------------------------------------------------------------------ */\n\n/*\n * Streaming-mode support\n */\n\n\nstatic int\narchive_read_support_format_zip_capabilities_streamable(struct archive_read * a)\n{\n\t(void)a; /* UNUSED */\n\treturn (ARCHIVE_READ_FORMAT_CAPS_ENCRYPT_DATA |\n\t\tARCHIVE_READ_FORMAT_CAPS_ENCRYPT_METADATA);\n}\n\nstatic int\narchive_read_format_zip_streamable_bid(struct archive_read *a, int best_bid)\n{\n\tconst char *p;\n\n\t(void)best_bid; /* UNUSED */\n\n\tif ((p = __archive_read_ahead(a, 4, NULL)) == NULL)\n\t\treturn (-1);\n\n\t/*\n\t * Bid of 29 here comes from:\n\t *  + 16 bits for \"PK\",\n\t *  + next 16-bit field has 6 options so contributes\n\t *    about 16 - log_2(6) ~= 16 - 2.6 ~= 13 bits\n\t *\n\t * So we've effectively verified ~29 total bits of check data.\n\t */\n\tif (p[0] == 'P' && p[1] == 'K') {\n\t\tif ((p[2] == '\\001' && p[3] == '\\002')\n\t\t    || (p[2] == '\\003' && p[3] == '\\004')\n\t\t    || (p[2] == '\\005' && p[3] == '\\006')\n\t\t    || (p[2] == '\\006' && p[3] == '\\006')\n\t\t    || (p[2] == '\\007' && p[3] == '\\010')\n\t\t    || (p[2] == '0' && p[3] == '0'))\n\t\t\treturn (29);\n\t}\n\n\t/* TODO: It's worth looking ahead a little bit for a valid\n\t * PK signature.  In particular, that would make it possible\n\t * to read some UUEncoded SFX files or SFX files coming from\n\t * a network socket. */\n\n\treturn (0);\n}\n\nstatic int\narchive_read_format_zip_streamable_read_header(struct archive_read *a,\n    struct archive_entry *entry)\n{\n\tstruct zip *zip;\n\n\ta->archive.archive_format = ARCHIVE_FORMAT_ZIP;\n\tif (a->archive.archive_format_name == NULL)\n\t\ta->archive.archive_format_name = \"ZIP\";\n\n\tzip = (struct zip *)(a->format->data);\n\n\t/*\n\t * It should be sufficient to call archive_read_next_header() for\n\t * a reader to determine if an entry is encrypted or not. If the\n\t * encryption of an entry is only detectable when calling\n\t * archive_read_data(), so be it. We'll do the same check there\n\t * as well.\n\t */\n\tif (zip->has_encrypted_entries ==\n\t\t\tARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW)\n\t\tzip->has_encrypted_entries = 0;\n\n\t/* Make sure we have a zip_entry structure to use. */\n\tif (zip->zip_entries == NULL) {\n\t\tzip->zip_entries = malloc(sizeof(struct zip_entry));\n\t\tif (zip->zip_entries == NULL) {\n\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t    \"Out  of memory\");\n\t\t\treturn ARCHIVE_FATAL;\n\t\t}\n\t}\n\tzip->entry = zip->zip_entries;\n\tmemset(zip->entry, 0, sizeof(struct zip_entry));\n\n\tif (zip->cctx_valid)\n\t\tarchive_decrypto_aes_ctr_release(&zip->cctx);\n\tif (zip->hctx_valid)\n\t\tarchive_hmac_sha1_cleanup(&zip->hctx);\n\tzip->tctx_valid = zip->cctx_valid = zip->hctx_valid = 0;\n\t__archive_read_reset_passphrase(a);\n\n\t/* Search ahead for the next local file header. */\n\t__archive_read_consume(a, zip->unconsumed);\n\tzip->unconsumed = 0;\n\tfor (;;) {\n\t\tint64_t skipped = 0;\n\t\tconst char *p, *end;\n\t\tssize_t bytes;\n\n\t\tp = __archive_read_ahead(a, 4, &bytes);\n\t\tif (p == NULL)\n\t\t\treturn (ARCHIVE_FATAL);\n\t\tend = p + bytes;\n\n\t\twhile (p + 4 <= end) {\n\t\t\tif (p[0] == 'P' && p[1] == 'K') {\n\t\t\t\tif (p[2] == '\\003' && p[3] == '\\004') {\n\t\t\t\t\t/* Regular file entry. */\n\t\t\t\t\t__archive_read_consume(a, skipped);\n\t\t\t\t\treturn zip_read_local_file_header(a,\n\t\t\t\t\t    entry, zip);\n\t\t\t\t}\n\n                              /*\n                               * TODO: We cannot restore permissions\n                               * based only on the local file headers.\n                               * Consider scanning the central\n                               * directory and returning additional\n                               * entries for at least directories.\n                               * This would allow us to properly set\n                               * directory permissions.\n\t\t\t       *\n\t\t\t       * This won't help us fix symlinks\n\t\t\t       * and may not help with regular file\n\t\t\t       * permissions, either.  <sigh>\n                               */\n                              if (p[2] == '\\001' && p[3] == '\\002') {\n                                      return (ARCHIVE_EOF);\n                              }\n\n                              /* End of central directory?  Must be an\n                               * empty archive. */\n                              if ((p[2] == '\\005' && p[3] == '\\006')\n                                  || (p[2] == '\\006' && p[3] == '\\006'))\n                                      return (ARCHIVE_EOF);\n\t\t\t}\n\t\t\t++p;\n\t\t\t++skipped;\n\t\t}\n\t\t__archive_read_consume(a, skipped);\n\t}\n}\n\nstatic int\narchive_read_format_zip_read_data_skip_streamable(struct archive_read *a)\n{\n\tstruct zip *zip;\n\tint64_t bytes_skipped;\n\n\tzip = (struct zip *)(a->format->data);\n\tbytes_skipped = __archive_read_consume(a, zip->unconsumed);\n\tzip->unconsumed = 0;\n\tif (bytes_skipped < 0)\n\t\treturn (ARCHIVE_FATAL);\n\n\t/* If we've already read to end of data, we're done. */\n\tif (zip->end_of_entry)\n\t\treturn (ARCHIVE_OK);\n\n\t/* So we know we're streaming... */\n\tif (0 == (zip->entry->zip_flags & ZIP_LENGTH_AT_END)\n\t    || zip->entry->compressed_size > 0) {\n\t\t/* We know the compressed length, so we can just skip. */\n\t\tbytes_skipped = __archive_read_consume(a,\n\t\t\t\t\tzip->entry_bytes_remaining);\n\t\tif (bytes_skipped < 0)\n\t\t\treturn (ARCHIVE_FATAL);\n\t\treturn (ARCHIVE_OK);\n\t}\n\n\tif (zip->init_decryption) {\n\t\tint r;\n\n\t\tzip->has_encrypted_entries = 1;\n\t\tif (zip->entry->zip_flags & ZIP_STRONG_ENCRYPTED)\n\t\t\tr = read_decryption_header(a);\n\t\telse if (zip->entry->compression == WINZIP_AES_ENCRYPTION)\n\t\t\tr = init_WinZip_AES_decryption(a);\n\t\telse\n\t\t\tr = init_traditional_PKWARE_decryption(a);\n\t\tif (r != ARCHIVE_OK)\n\t\t\treturn (r);\n\t\tzip->init_decryption = 0;\n\t}\n\n\t/* We're streaming and we don't know the length. */\n\t/* If the body is compressed and we know the format, we can\n\t * find an exact end-of-entry by decompressing it. */\n\tswitch (zip->entry->compression) {\n#ifdef HAVE_ZLIB_H\n\tcase 8: /* Deflate compression. */\n\t\twhile (!zip->end_of_entry) {\n\t\t\tint64_t offset = 0;\n\t\t\tconst void *buff = NULL;\n\t\t\tsize_t size = 0;\n\t\t\tint r;\n\t\t\tr =  zip_read_data_deflate(a, &buff, &size, &offset);\n\t\t\tif (r != ARCHIVE_OK)\n\t\t\t\treturn (r);\n\t\t}\n\t\treturn ARCHIVE_OK;\n#endif\n\tdefault: /* Uncompressed or unknown. */\n\t\t/* Scan for a PK\\007\\010 signature. */\n\t\tfor (;;) {\n\t\t\tconst char *p, *buff;\n\t\t\tssize_t bytes_avail;\n\t\t\tbuff = __archive_read_ahead(a, 16, &bytes_avail);\n\t\t\tif (bytes_avail < 16) {\n\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \"Truncated ZIP file data\");\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t\tp = buff;\n\t\t\twhile (p <= buff + bytes_avail - 16) {\n\t\t\t\tif (p[3] == 'P') { p += 3; }\n\t\t\t\telse if (p[3] == 'K') { p += 2; }\n\t\t\t\telse if (p[3] == '\\007') { p += 1; }\n\t\t\t\telse if (p[3] == '\\010' && p[2] == '\\007'\n\t\t\t\t    && p[1] == 'K' && p[0] == 'P') {\n\t\t\t\t\tif (zip->entry->flags & LA_USED_ZIP64)\n\t\t\t\t\t\t__archive_read_consume(a,\n\t\t\t\t\t\t    p - buff + 24);\n\t\t\t\t\telse\n\t\t\t\t\t\t__archive_read_consume(a,\n\t\t\t\t\t\t    p - buff + 16);\n\t\t\t\t\treturn ARCHIVE_OK;\n\t\t\t\t} else { p += 4; }\n\t\t\t}\n\t\t\t__archive_read_consume(a, p - buff);\n\t\t}\n\t}\n}\n\nint\narchive_read_support_format_zip_streamable(struct archive *_a)\n{\n\tstruct archive_read *a = (struct archive_read *)_a;\n\tstruct zip *zip;\n\tint r;\n\n\tarchive_check_magic(_a, ARCHIVE_READ_MAGIC,\n\t    ARCHIVE_STATE_NEW, \"archive_read_support_format_zip\");\n\n\tzip = (struct zip *)calloc(1, sizeof(*zip));\n\tif (zip == NULL) {\n\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t    \"Can't allocate zip data\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\t/* Streamable reader doesn't support mac extensions. */\n\tzip->process_mac_extensions = 0;\n\n\t/*\n\t * Until enough data has been read, we cannot tell about\n\t * any encrypted entries yet.\n\t */\n\tzip->has_encrypted_entries = ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW;\n\tzip->crc32func = real_crc32;\n\n\tr = __archive_read_register_format(a,\n\t    zip,\n\t    \"zip\",\n\t    archive_read_format_zip_streamable_bid,\n\t    archive_read_format_zip_options,\n\t    archive_read_format_zip_streamable_read_header,\n\t    archive_read_format_zip_read_data,\n\t    archive_read_format_zip_read_data_skip_streamable,\n\t    NULL,\n\t    archive_read_format_zip_cleanup,\n\t    archive_read_support_format_zip_capabilities_streamable,\n\t    archive_read_format_zip_has_encrypted_entries);\n\n\tif (r != ARCHIVE_OK)\n\t\tfree(zip);\n\treturn (ARCHIVE_OK);\n}\n\n/* ------------------------------------------------------------------------ */\n\n/*\n * Seeking-mode support\n */\n\nstatic int\narchive_read_support_format_zip_capabilities_seekable(struct archive_read * a)\n{\n\t(void)a; /* UNUSED */\n\treturn (ARCHIVE_READ_FORMAT_CAPS_ENCRYPT_DATA |\n\t\tARCHIVE_READ_FORMAT_CAPS_ENCRYPT_METADATA);\n}\n\n/*\n * TODO: This is a performance sink because it forces the read core to\n * drop buffered data from the start of file, which will then have to\n * be re-read again if this bidder loses.\n *\n * We workaround this a little by passing in the best bid so far so\n * that later bidders can do nothing if they know they'll never\n * outbid.  But we can certainly do better...\n */\nstatic int\nread_eocd(struct zip *zip, const char *p, int64_t current_offset)\n{\n\t/* Sanity-check the EOCD we've found. */\n\n\t/* This must be the first volume. */\n\tif (archive_le16dec(p + 4) != 0)\n\t\treturn 0;\n\t/* Central directory must be on this volume. */\n\tif (archive_le16dec(p + 4) != archive_le16dec(p + 6))\n\t\treturn 0;\n\t/* All central directory entries must be on this volume. */\n\tif (archive_le16dec(p + 10) != archive_le16dec(p + 8))\n\t\treturn 0;\n\t/* Central directory can't extend beyond start of EOCD record. */\n\tif (archive_le32dec(p + 16) + archive_le32dec(p + 12)\n\t    > current_offset)\n\t\treturn 0;\n\n\t/* Save the central directory location for later use. */\n\tzip->central_directory_offset = archive_le32dec(p + 16);\n\n\t/* This is just a tiny bit higher than the maximum\n\t   returned by the streaming Zip bidder.  This ensures\n\t   that the more accurate seeking Zip parser wins\n\t   whenever seek is available. */\n\treturn 32;\n}\n\n/*\n * Examine Zip64 EOCD locator:  If it's valid, store the information\n * from it.\n */\nstatic int\nread_zip64_eocd(struct archive_read *a, struct zip *zip, const char *p)\n{\n\tint64_t eocd64_offset;\n\tint64_t eocd64_size;\n\n\t/* Sanity-check the locator record. */\n\n\t/* Central dir must be on first volume. */\n\tif (archive_le32dec(p + 4) != 0)\n\t\treturn 0;\n\t/* Must be only a single volume. */\n\tif (archive_le32dec(p + 16) != 1)\n\t\treturn 0;\n\n\t/* Find the Zip64 EOCD record. */\n\teocd64_offset = archive_le64dec(p + 8);\n\tif (__archive_read_seek(a, eocd64_offset, SEEK_SET) < 0)\n\t\treturn 0;\n\tif ((p = __archive_read_ahead(a, 56, NULL)) == NULL)\n\t\treturn 0;\n\t/* Make sure we can read all of it. */\n\teocd64_size = archive_le64dec(p + 4) + 12;\n\tif (eocd64_size < 56 || eocd64_size > 16384)\n\t\treturn 0;\n\tif ((p = __archive_read_ahead(a, (size_t)eocd64_size, NULL)) == NULL)\n\t\treturn 0;\n\n\t/* Sanity-check the EOCD64 */\n\tif (archive_le32dec(p + 16) != 0) /* Must be disk #0 */\n\t\treturn 0;\n\tif (archive_le32dec(p + 20) != 0) /* CD must be on disk #0 */\n\t\treturn 0;\n\t/* CD can't be split. */\n\tif (archive_le64dec(p + 24) != archive_le64dec(p + 32))\n\t\treturn 0;\n\n\t/* Save the central directory offset for later use. */\n\tzip->central_directory_offset = archive_le64dec(p + 48);\n\n\treturn 32;\n}\n\nstatic int\narchive_read_format_zip_seekable_bid(struct archive_read *a, int best_bid)\n{\n\tstruct zip *zip = (struct zip *)a->format->data;\n\tint64_t file_size, current_offset;\n\tconst char *p;\n\tint i, tail;\n\n\t/* If someone has already bid more than 32, then avoid\n\t   trashing the look-ahead buffers with a seek. */\n\tif (best_bid > 32)\n\t\treturn (-1);\n\n\tfile_size = __archive_read_seek(a, 0, SEEK_END);\n\tif (file_size <= 0)\n\t\treturn 0;\n\n\t/* Search last 16k of file for end-of-central-directory\n\t * record (which starts with PK\\005\\006) */\n\ttail = (int)zipmin(1024 * 16, file_size);\n\tcurrent_offset = __archive_read_seek(a, -tail, SEEK_END);\n\tif (current_offset < 0)\n\t\treturn 0;\n\tif ((p = __archive_read_ahead(a, (size_t)tail, NULL)) == NULL)\n\t\treturn 0;\n\t/* Boyer-Moore search backwards from the end, since we want\n\t * to match the last EOCD in the file (there can be more than\n\t * one if there is an uncompressed Zip archive as a member\n\t * within this Zip archive). */\n\tfor (i = tail - 22; i > 0;) {\n\t\tswitch (p[i]) {\n\t\tcase 'P':\n\t\t\tif (memcmp(p + i, \"PK\\005\\006\", 4) == 0) {\n\t\t\t\tint ret = read_eocd(zip, p + i,\n\t\t\t\t    current_offset + i);\n\t\t\t\t/* Zip64 EOCD locator precedes\n\t\t\t\t * regular EOCD if present. */\n\t\t\t\tif (i >= 20 && memcmp(p + i - 20, \"PK\\006\\007\", 4) == 0) {\n\t\t\t\t\tint ret_zip64 = read_zip64_eocd(a, zip, p + i - 20);\n\t\t\t\t\tif (ret_zip64 > ret)\n\t\t\t\t\t\tret = ret_zip64;\n\t\t\t\t}\n\t\t\t\treturn (ret);\n\t\t\t}\n\t\t\ti -= 4;\n\t\t\tbreak;\n\t\tcase 'K': i -= 1; break;\n\t\tcase 005: i -= 2; break;\n\t\tcase 006: i -= 3; break;\n\t\tdefault: i -= 4; break;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/* The red-black trees are only used in seeking mode to manage\n * the in-memory copy of the central directory. */\n\nstatic int\ncmp_node(const struct archive_rb_node *n1, const struct archive_rb_node *n2)\n{\n\tconst struct zip_entry *e1 = (const struct zip_entry *)n1;\n\tconst struct zip_entry *e2 = (const struct zip_entry *)n2;\n\n\tif (e1->local_header_offset > e2->local_header_offset)\n\t\treturn -1;\n\tif (e1->local_header_offset < e2->local_header_offset)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int\ncmp_key(const struct archive_rb_node *n, const void *key)\n{\n\t/* This function won't be called */\n\t(void)n; /* UNUSED */\n\t(void)key; /* UNUSED */\n\treturn 1;\n}\n\nstatic const struct archive_rb_tree_ops rb_ops = {\n\t&cmp_node, &cmp_key\n};\n\nstatic int\nrsrc_cmp_node(const struct archive_rb_node *n1,\n    const struct archive_rb_node *n2)\n{\n\tconst struct zip_entry *e1 = (const struct zip_entry *)n1;\n\tconst struct zip_entry *e2 = (const struct zip_entry *)n2;\n\n\treturn (strcmp(e2->rsrcname.s, e1->rsrcname.s));\n}\n\nstatic int\nrsrc_cmp_key(const struct archive_rb_node *n, const void *key)\n{\n\tconst struct zip_entry *e = (const struct zip_entry *)n;\n\treturn (strcmp((const char *)key, e->rsrcname.s));\n}\n\nstatic const struct archive_rb_tree_ops rb_rsrc_ops = {\n\t&rsrc_cmp_node, &rsrc_cmp_key\n};\n\nstatic const char *\nrsrc_basename(const char *name, size_t name_length)\n{\n\tconst char *s, *r;\n\n\tr = s = name;\n\tfor (;;) {\n\t\ts = memchr(s, '/', name_length - (s - name));\n\t\tif (s == NULL)\n\t\t\tbreak;\n\t\tr = ++s;\n\t}\n\treturn (r);\n}\n\nstatic void\nexpose_parent_dirs(struct zip *zip, const char *name, size_t name_length)\n{\n\tstruct archive_string str;\n\tstruct zip_entry *dir;\n\tchar *s;\n\n\tarchive_string_init(&str);\n\tarchive_strncpy(&str, name, name_length);\n\tfor (;;) {\n\t\ts = strrchr(str.s, '/');\n\t\tif (s == NULL)\n\t\t\tbreak;\n\t\t*s = '\\0';\n\t\t/* Transfer the parent directory from zip->tree_rsrc RB\n\t\t * tree to zip->tree RB tree to expose. */\n\t\tdir = (struct zip_entry *)\n\t\t    __archive_rb_tree_find_node(&zip->tree_rsrc, str.s);\n\t\tif (dir == NULL)\n\t\t\tbreak;\n\t\t__archive_rb_tree_remove_node(&zip->tree_rsrc, &dir->node);\n\t\tarchive_string_free(&dir->rsrcname);\n\t\t__archive_rb_tree_insert_node(&zip->tree, &dir->node);\n\t}\n\tarchive_string_free(&str);\n}\n\nstatic int\nslurp_central_directory(struct archive_read *a, struct zip *zip)\n{\n\tssize_t i;\n\tunsigned found;\n\tint64_t correction;\n\tssize_t bytes_avail;\n\tconst char *p;\n\n\t/*\n\t * Find the start of the central directory.  The end-of-CD\n\t * record has our starting point, but there are lots of\n\t * Zip archives which have had other data prepended to the\n\t * file, which makes the recorded offsets all too small.\n\t * So we search forward from the specified offset until we\n\t * find the real start of the central directory.  Then we\n\t * know the correction we need to apply to account for leading\n\t * padding.\n\t */\n\tif (__archive_read_seek(a, zip->central_directory_offset, SEEK_SET) < 0)\n\t\treturn ARCHIVE_FATAL;\n\n\tfound = 0;\n\twhile (!found) {\n\t\tif ((p = __archive_read_ahead(a, 20, &bytes_avail)) == NULL)\n\t\t\treturn ARCHIVE_FATAL;\n\t\tfor (found = 0, i = 0; !found && i < bytes_avail - 4;) {\n\t\t\tswitch (p[i + 3]) {\n\t\t\tcase 'P': i += 3; break;\n\t\t\tcase 'K': i += 2; break;\n\t\t\tcase 001: i += 1; break;\n\t\t\tcase 002:\n\t\t\t\tif (memcmp(p + i, \"PK\\001\\002\", 4) == 0) {\n\t\t\t\t\tp += i;\n\t\t\t\t\tfound = 1;\n\t\t\t\t} else\n\t\t\t\t\ti += 4;\n\t\t\t\tbreak;\n\t\t\tcase 005: i += 1; break;\n\t\t\tcase 006:\n\t\t\t\tif (memcmp(p + i, \"PK\\005\\006\", 4) == 0) {\n\t\t\t\t\tp += i;\n\t\t\t\t\tfound = 1;\n\t\t\t\t} else if (memcmp(p + i, \"PK\\006\\006\", 4) == 0) {\n\t\t\t\t\tp += i;\n\t\t\t\t\tfound = 1;\n\t\t\t\t} else\n\t\t\t\t\ti += 1;\n\t\t\t\tbreak;\n\t\t\tdefault: i += 4; break;\n\t\t\t}\n\t\t}\n\t\t__archive_read_consume(a, i);\n\t}\n\tcorrection = archive_filter_bytes(&a->archive, 0)\n\t\t\t- zip->central_directory_offset;\n\n\t__archive_rb_tree_init(&zip->tree, &rb_ops);\n\t__archive_rb_tree_init(&zip->tree_rsrc, &rb_rsrc_ops);\n\n\tzip->central_directory_entries_total = 0;\n\twhile (1) {\n\t\tstruct zip_entry *zip_entry;\n\t\tsize_t filename_length, extra_length, comment_length;\n\t\tuint32_t external_attributes;\n\t\tconst char *name, *r;\n\n\t\tif ((p = __archive_read_ahead(a, 4, NULL)) == NULL)\n\t\t\treturn ARCHIVE_FATAL;\n\t\tif (memcmp(p, \"PK\\006\\006\", 4) == 0\n\t\t    || memcmp(p, \"PK\\005\\006\", 4) == 0) {\n\t\t\tbreak;\n\t\t} else if (memcmp(p, \"PK\\001\\002\", 4) != 0) {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    -1, \"Invalid central directory signature\");\n\t\t\treturn ARCHIVE_FATAL;\n\t\t}\n\t\tif ((p = __archive_read_ahead(a, 46, NULL)) == NULL)\n\t\t\treturn ARCHIVE_FATAL;\n\n\t\tzip_entry = calloc(1, sizeof(struct zip_entry));\n\t\tif (zip_entry == NULL) {\n\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t\t\"Can't allocate zip entry\");\n\t\t\treturn ARCHIVE_FATAL;\n\t\t}\n\t\tzip_entry->next = zip->zip_entries;\n\t\tzip_entry->flags |= LA_FROM_CENTRAL_DIRECTORY;\n\t\tzip->zip_entries = zip_entry;\n\t\tzip->central_directory_entries_total++;\n\n\t\t/* version = p[4]; */\n\t\tzip_entry->system = p[5];\n\t\t/* version_required = archive_le16dec(p + 6); */\n\t\tzip_entry->zip_flags = archive_le16dec(p + 8);\n\t\tif (zip_entry->zip_flags\n\t\t      & (ZIP_ENCRYPTED | ZIP_STRONG_ENCRYPTED)){\n\t\t\tzip->has_encrypted_entries = 1;\n\t\t}\n\t\tzip_entry->compression = (char)archive_le16dec(p + 10);\n\t\tzip_entry->mtime = zip_time(p + 12);\n\t\tzip_entry->crc32 = archive_le32dec(p + 16);\n\t\tif (zip_entry->zip_flags & ZIP_LENGTH_AT_END)\n\t\t\tzip_entry->decdat = p[13];\n\t\telse\n\t\t\tzip_entry->decdat = p[19];\n\t\tzip_entry->compressed_size = archive_le32dec(p + 20);\n\t\tzip_entry->uncompressed_size = archive_le32dec(p + 24);\n\t\tfilename_length = archive_le16dec(p + 28);\n\t\textra_length = archive_le16dec(p + 30);\n\t\tcomment_length = archive_le16dec(p + 32);\n\t\t/* disk_start = archive_le16dec(p + 34); */ /* Better be zero. */\n\t\t/* internal_attributes = archive_le16dec(p + 36); */ /* text bit */\n\t\texternal_attributes = archive_le32dec(p + 38);\n\t\tzip_entry->local_header_offset =\n\t\t    archive_le32dec(p + 42) + correction;\n\n\t\t/* If we can't guess the mode, leave it zero here;\n\t\t   when we read the local file header we might get\n\t\t   more information. */\n\t\tif (zip_entry->system == 3) {\n\t\t\tzip_entry->mode = external_attributes >> 16;\n\t\t} else if (zip_entry->system == 0) {\n\t\t\t// Interpret MSDOS directory bit\n\t\t\tif (0x10 == (external_attributes & 0x10)) {\n\t\t\t\tzip_entry->mode = AE_IFDIR | 0775;\n\t\t\t} else {\n\t\t\t\tzip_entry->mode = AE_IFREG | 0664;\n\t\t\t}\n\t\t\tif (0x01 == (external_attributes & 0x01)) {\n\t\t\t\t// Read-only bit; strip write permissions\n\t\t\t\tzip_entry->mode &= 0555;\n\t\t\t}\n\t\t} else {\n\t\t\tzip_entry->mode = 0;\n\t\t}\n\n\t\t/* We're done with the regular data; get the filename and\n\t\t * extra data. */\n\t\t__archive_read_consume(a, 46);\n\t\tp = __archive_read_ahead(a, filename_length + extra_length,\n\t\t\tNULL);\n\t\tif (p == NULL) {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Truncated ZIP file header\");\n\t\t\treturn ARCHIVE_FATAL;\n\t\t}\n\t\tif (ARCHIVE_OK != process_extra(a, p + filename_length, extra_length, zip_entry)) {\n\t\t\treturn ARCHIVE_FATAL;\n\t\t}\n\n\t\t/*\n\t\t * Mac resource fork files are stored under the\n\t\t * \"__MACOSX/\" directory, so we should check if\n\t\t * it is.\n\t\t */\n\t\tif (!zip->process_mac_extensions) {\n\t\t\t/* Treat every entry as a regular entry. */\n\t\t\t__archive_rb_tree_insert_node(&zip->tree,\n\t\t\t    &zip_entry->node);\n\t\t} else {\n\t\t\tname = p;\n\t\t\tr = rsrc_basename(name, filename_length);\n\t\t\tif (filename_length >= 9 &&\n\t\t\t    strncmp(\"__MACOSX/\", name, 9) == 0) {\n\t\t\t\t/* If this file is not a resource fork nor\n\t\t\t\t * a directory. We should treat it as a non\n\t\t\t\t * resource fork file to expose it. */\n\t\t\t\tif (name[filename_length-1] != '/' &&\n\t\t\t\t    (r - name < 3 || r[0] != '.' || r[1] != '_')) {\n\t\t\t\t\t__archive_rb_tree_insert_node(\n\t\t\t\t\t    &zip->tree, &zip_entry->node);\n\t\t\t\t\t/* Expose its parent directories. */\n\t\t\t\t\texpose_parent_dirs(zip, name,\n\t\t\t\t\t    filename_length);\n\t\t\t\t} else {\n\t\t\t\t\t/* This file is a resource fork file or\n\t\t\t\t\t * a directory. */\n\t\t\t\t\tarchive_strncpy(&(zip_entry->rsrcname),\n\t\t\t\t\t     name, filename_length);\n\t\t\t\t\t__archive_rb_tree_insert_node(\n\t\t\t\t\t    &zip->tree_rsrc, &zip_entry->node);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* Generate resource fork name to find its\n\t\t\t\t * resource file at zip->tree_rsrc. */\n\t\t\t\tarchive_strcpy(&(zip_entry->rsrcname),\n\t\t\t\t    \"__MACOSX/\");\n\t\t\t\tarchive_strncat(&(zip_entry->rsrcname),\n\t\t\t\t    name, r - name);\n\t\t\t\tarchive_strcat(&(zip_entry->rsrcname), \"._\");\n\t\t\t\tarchive_strncat(&(zip_entry->rsrcname),\n\t\t\t\t    name + (r - name),\n\t\t\t\t    filename_length - (r - name));\n\t\t\t\t/* Register an entry to RB tree to sort it by\n\t\t\t\t * file offset. */\n\t\t\t\t__archive_rb_tree_insert_node(&zip->tree,\n\t\t\t\t    &zip_entry->node);\n\t\t\t}\n\t\t}\n\n\t\t/* Skip the comment too ... */\n\t\t__archive_read_consume(a,\n\t\t    filename_length + extra_length + comment_length);\n\t}\n\n\treturn ARCHIVE_OK;\n}\n\nstatic ssize_t\nzip_get_local_file_header_size(struct archive_read *a, size_t extra)\n{\n\tconst char *p;\n\tssize_t filename_length, extra_length;\n\n\tif ((p = __archive_read_ahead(a, extra + 30, NULL)) == NULL) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Truncated ZIP file header\");\n\t\treturn (ARCHIVE_WARN);\n\t}\n\tp += extra;\n\n\tif (memcmp(p, \"PK\\003\\004\", 4) != 0) {\n\t\tarchive_set_error(&a->archive, -1, \"Damaged Zip archive\");\n\t\treturn ARCHIVE_WARN;\n\t}\n\tfilename_length = archive_le16dec(p + 26);\n\textra_length = archive_le16dec(p + 28);\n\n\treturn (30 + filename_length + extra_length);\n}\n\nstatic int\nzip_read_mac_metadata(struct archive_read *a, struct archive_entry *entry,\n    struct zip_entry *rsrc)\n{\n\tstruct zip *zip = (struct zip *)a->format->data;\n\tunsigned char *metadata, *mp;\n\tint64_t offset = archive_filter_bytes(&a->archive, 0);\n\tsize_t remaining_bytes, metadata_bytes;\n\tssize_t hsize;\n\tint ret = ARCHIVE_OK, eof;\n\n\tswitch(rsrc->compression) {\n\tcase 0:  /* No compression. */\n\t\tif (rsrc->uncompressed_size != rsrc->compressed_size) {\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Malformed OS X metadata entry: inconsistent size\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n#ifdef HAVE_ZLIB_H\n\tcase 8: /* Deflate compression. */\n#endif\n\t\tbreak;\n\tdefault: /* Unsupported compression. */\n\t\t/* Return a warning. */\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Unsupported ZIP compression method (%s)\",\n\t\t    compression_name(rsrc->compression));\n\t\t/* We can't decompress this entry, but we will\n\t\t * be able to skip() it and try the next entry. */\n\t\treturn (ARCHIVE_WARN);\n\t}\n\n\tif (rsrc->uncompressed_size > (4 * 1024 * 1024)) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Mac metadata is too large: %jd > 4M bytes\",\n\t\t    (intmax_t)rsrc->uncompressed_size);\n\t\treturn (ARCHIVE_WARN);\n\t}\n\tif (rsrc->compressed_size > (4 * 1024 * 1024)) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Mac metadata is too large: %jd > 4M bytes\",\n\t\t    (intmax_t)rsrc->compressed_size);\n\t\treturn (ARCHIVE_WARN);\n\t}\n\n\tmetadata = malloc((size_t)rsrc->uncompressed_size);\n\tif (metadata == NULL) {\n\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t    \"Can't allocate memory for Mac metadata\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\tif (offset < rsrc->local_header_offset)\n\t\t__archive_read_consume(a, rsrc->local_header_offset - offset);\n\telse if (offset != rsrc->local_header_offset) {\n\t\t__archive_read_seek(a, rsrc->local_header_offset, SEEK_SET);\n\t}\n\n\thsize = zip_get_local_file_header_size(a, 0);\n\t__archive_read_consume(a, hsize);\n\n\tremaining_bytes = (size_t)rsrc->compressed_size;\n\tmetadata_bytes = (size_t)rsrc->uncompressed_size;\n\tmp = metadata;\n\teof = 0;\n\twhile (!eof && remaining_bytes) {\n\t\tconst unsigned char *p;\n\t\tssize_t bytes_avail;\n\t\tsize_t bytes_used;\n\n\t\tp = __archive_read_ahead(a, 1, &bytes_avail);\n\t\tif (p == NULL) {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Truncated ZIP file header\");\n\t\t\tret = ARCHIVE_WARN;\n\t\t\tgoto exit_mac_metadata;\n\t\t}\n\t\tif ((size_t)bytes_avail > remaining_bytes)\n\t\t\tbytes_avail = remaining_bytes;\n\t\tswitch(rsrc->compression) {\n\t\tcase 0:  /* No compression. */\n\t\t\tif ((size_t)bytes_avail > metadata_bytes)\n\t\t\t\tbytes_avail = metadata_bytes;\n\t\t\tmemcpy(mp, p, bytes_avail);\n\t\t\tbytes_used = (size_t)bytes_avail;\n\t\t\tmetadata_bytes -= bytes_used;\n\t\t\tmp += bytes_used;\n\t\t\tif (metadata_bytes == 0)\n\t\t\t\teof = 1;\n\t\t\tbreak;\n#ifdef HAVE_ZLIB_H\n\t\tcase 8: /* Deflate compression. */\n\t\t{\n\t\t\tint r;\n\n\t\t\tret = zip_deflate_init(a, zip);\n\t\t\tif (ret != ARCHIVE_OK)\n\t\t\t\tgoto exit_mac_metadata;\n\t\t\tzip->stream.next_in =\n\t\t\t    (Bytef *)(uintptr_t)(const void *)p;\n\t\t\tzip->stream.avail_in = (uInt)bytes_avail;\n\t\t\tzip->stream.total_in = 0;\n\t\t\tzip->stream.next_out = mp;\n\t\t\tzip->stream.avail_out = (uInt)metadata_bytes;\n\t\t\tzip->stream.total_out = 0;\n\n\t\t\tr = inflate(&zip->stream, 0);\n\t\t\tswitch (r) {\n\t\t\tcase Z_OK:\n\t\t\t\tbreak;\n\t\t\tcase Z_STREAM_END:\n\t\t\t\teof = 1;\n\t\t\t\tbreak;\n\t\t\tcase Z_MEM_ERROR:\n\t\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t\t    \"Out of memory for ZIP decompression\");\n\t\t\t\tret = ARCHIVE_FATAL;\n\t\t\t\tgoto exit_mac_metadata;\n\t\t\tdefault:\n\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t\t    \"ZIP decompression failed (%d)\", r);\n\t\t\t\tret = ARCHIVE_FATAL;\n\t\t\t\tgoto exit_mac_metadata;\n\t\t\t}\n\t\t\tbytes_used = zip->stream.total_in;\n\t\t\tmetadata_bytes -= zip->stream.total_out;\n\t\t\tmp += zip->stream.total_out;\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tdefault:\n\t\t\tbytes_used = 0;\n\t\t\tbreak;\n\t\t}\n\t\t__archive_read_consume(a, bytes_used);\n\t\tremaining_bytes -= bytes_used;\n\t}\n\tarchive_entry_copy_mac_metadata(entry, metadata,\n\t    (size_t)rsrc->uncompressed_size - metadata_bytes);\n\nexit_mac_metadata:\n\t__archive_read_seek(a, offset, SEEK_SET);\n\tzip->decompress_init = 0;\n\tfree(metadata);\n\treturn (ret);\n}\n\nstatic int\narchive_read_format_zip_seekable_read_header(struct archive_read *a,\n\tstruct archive_entry *entry)\n{\n\tstruct zip *zip = (struct zip *)a->format->data;\n\tstruct zip_entry *rsrc;\n\tint64_t offset;\n\tint r, ret = ARCHIVE_OK;\n\n\t/*\n\t * It should be sufficient to call archive_read_next_header() for\n\t * a reader to determine if an entry is encrypted or not. If the\n\t * encryption of an entry is only detectable when calling\n\t * archive_read_data(), so be it. We'll do the same check there\n\t * as well.\n\t */\n\tif (zip->has_encrypted_entries ==\n\t\t\tARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW)\n\t\tzip->has_encrypted_entries = 0;\n\n\ta->archive.archive_format = ARCHIVE_FORMAT_ZIP;\n\tif (a->archive.archive_format_name == NULL)\n\t\ta->archive.archive_format_name = \"ZIP\";\n\n\tif (zip->zip_entries == NULL) {\n\t\tr = slurp_central_directory(a, zip);\n\t\tif (r != ARCHIVE_OK)\n\t\t\treturn r;\n\t\t/* Get first entry whose local header offset is lower than\n\t\t * other entries in the archive file. */\n\t\tzip->entry =\n\t\t    (struct zip_entry *)ARCHIVE_RB_TREE_MIN(&zip->tree);\n\t} else if (zip->entry != NULL) {\n\t\t/* Get next entry in local header offset order. */\n\t\tzip->entry = (struct zip_entry *)__archive_rb_tree_iterate(\n\t\t    &zip->tree, &zip->entry->node, ARCHIVE_RB_DIR_RIGHT);\n\t}\n\n\tif (zip->entry == NULL)\n\t\treturn ARCHIVE_EOF;\n\n\tif (zip->entry->rsrcname.s)\n\t\trsrc = (struct zip_entry *)__archive_rb_tree_find_node(\n\t\t    &zip->tree_rsrc, zip->entry->rsrcname.s);\n\telse\n\t\trsrc = NULL;\n\n\tif (zip->cctx_valid)\n\t\tarchive_decrypto_aes_ctr_release(&zip->cctx);\n\tif (zip->hctx_valid)\n\t\tarchive_hmac_sha1_cleanup(&zip->hctx);\n\tzip->tctx_valid = zip->cctx_valid = zip->hctx_valid = 0;\n\t__archive_read_reset_passphrase(a);\n\n\t/* File entries are sorted by the header offset, we should mostly\n\t * use __archive_read_consume to advance a read point to avoid redundant\n\t * data reading.  */\n\toffset = archive_filter_bytes(&a->archive, 0);\n\tif (offset < zip->entry->local_header_offset)\n\t\t__archive_read_consume(a,\n\t\t    zip->entry->local_header_offset - offset);\n\telse if (offset != zip->entry->local_header_offset) {\n\t\t__archive_read_seek(a, zip->entry->local_header_offset,\n\t\t    SEEK_SET);\n\t}\n\tzip->unconsumed = 0;\n\tr = zip_read_local_file_header(a, entry, zip);\n\tif (r != ARCHIVE_OK)\n\t\treturn r;\n\tif (rsrc) {\n\t\tint ret2 = zip_read_mac_metadata(a, entry, rsrc);\n\t\tif (ret2 < ret)\n\t\t\tret = ret2;\n\t}\n\treturn (ret);\n}\n\n/*\n * We're going to seek for the next header anyway, so we don't\n * need to bother doing anything here.\n */\nstatic int\narchive_read_format_zip_read_data_skip_seekable(struct archive_read *a)\n{\n\tstruct zip *zip;\n\tzip = (struct zip *)(a->format->data);\n\n\tzip->unconsumed = 0;\n\treturn (ARCHIVE_OK);\n}\n\nint\narchive_read_support_format_zip_seekable(struct archive *_a)\n{\n\tstruct archive_read *a = (struct archive_read *)_a;\n\tstruct zip *zip;\n\tint r;\n\n\tarchive_check_magic(_a, ARCHIVE_READ_MAGIC,\n\t    ARCHIVE_STATE_NEW, \"archive_read_support_format_zip_seekable\");\n\n\tzip = (struct zip *)calloc(1, sizeof(*zip));\n\tif (zip == NULL) {\n\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t    \"Can't allocate zip data\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n#ifdef HAVE_COPYFILE_H\n\t/* Set this by default on Mac OS. */\n\tzip->process_mac_extensions = 1;\n#endif\n\n\t/*\n\t * Until enough data has been read, we cannot tell about\n\t * any encrypted entries yet.\n\t */\n\tzip->has_encrypted_entries = ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW;\n\tzip->crc32func = real_crc32;\n\n\tr = __archive_read_register_format(a,\n\t    zip,\n\t    \"zip\",\n\t    archive_read_format_zip_seekable_bid,\n\t    archive_read_format_zip_options,\n\t    archive_read_format_zip_seekable_read_header,\n\t    archive_read_format_zip_read_data,\n\t    archive_read_format_zip_read_data_skip_seekable,\n\t    NULL,\n\t    archive_read_format_zip_cleanup,\n\t    archive_read_support_format_zip_capabilities_seekable,\n\t    archive_read_format_zip_has_encrypted_entries);\n\n\tif (r != ARCHIVE_OK)\n\t\tfree(zip);\n\treturn (ARCHIVE_OK);\n}\n\n/*# vim:set noet:*/\n"], "filenames": ["libarchive/archive_read_support_format_zip.c"], "buggy_code_start_loc": [2754], "buggy_code_end_loc": [2755], "fixing_code_start_loc": [2754], "fixing_code_end_loc": [2755], "type": "CWE-401", "message": "A memory leak in archive_read_format_zip_cleanup in archive_read_support_format_zip.c in libarchive 3.3.4-dev allows remote attackers to cause a denial of service via a crafted ZIP file because of a HAVE_LZMA_H typo. NOTE: this only affects users who downloaded the development code from GitHub. Users of the product's official releases are unaffected.", "other": {"cve": {"id": "CVE-2019-11463", "sourceIdentifier": "cve@mitre.org", "published": "2019-04-23T03:29:00.353", "lastModified": "2020-12-08T18:24:43.997", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A memory leak in archive_read_format_zip_cleanup in archive_read_support_format_zip.c in libarchive 3.3.4-dev allows remote attackers to cause a denial of service via a crafted ZIP file because of a HAVE_LZMA_H typo. NOTE: this only affects users who downloaded the development code from GitHub. Users of the product's official releases are unaffected."}, {"lang": "es", "value": "Una p\u00e9rdida de memoria en la funci\u00f3n archive_read_format_zip_cleanup en el archivo archive_read_support_format_zip.c en libarchive 3.3.4-dev permite a los atacantes remotos provocar una Denegaci\u00f3n de Servicio a trav\u00e9s de un archivo ZIP creado debido a un error tipogr\u00e1fico HAVE_LZMA_H. NOTA: esto solo impacta a los usuarios que descargaron el c\u00f3digo de desarrollo de GitHub. Los usuarios de las versiones oficiales del producto no se ven afectados."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-401"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libarchive:libarchive:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.4.0", "matchCriteriaId": "CD8C4D61-FC17-4094-8516-F9DB094DEB8B"}]}]}], "references": [{"url": "https://access.redhat.com/security/cve/cve-2019-11463", "source": "nvd@nist.gov", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/libarchive/libarchive/commit/ba641f73f3d758d9032b3f0e5597a9c6e593a505", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/libarchive/libarchive/issues/1165", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/libarchive/libarchive/commit/ba641f73f3d758d9032b3f0e5597a9c6e593a505"}}