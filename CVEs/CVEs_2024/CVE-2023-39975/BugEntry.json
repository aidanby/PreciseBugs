{"buggy_code": ["/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* kdc/do_tgs_req.c - KDC Routines to deal with TGS_REQ's */\n/*\n * Copyright 1990, 1991, 2001, 2007, 2008, 2009, 2013, 2014 by the\n * Massachusetts Institute of Technology.  All Rights Reserved.\n *\n * Export of this software from the United States of America may\n *   require a specific license from the United States Government.\n *   It is the responsibility of any person or organization contemplating\n *   export to obtain such a license before exporting.\n *\n * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and\n * distribute this software and its documentation for any purpose and\n * without fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright notice and\n * this permission notice appear in supporting documentation, and that\n * the name of M.I.T. not be used in advertising or publicity pertaining\n * to distribution of the software without specific, written prior\n * permission.  Furthermore if you modify this software you must label\n * your software as modified software and not distribute it in such a\n * fashion that it might be confused with the original M.I.T. software.\n * M.I.T. makes no representations about the suitability of\n * this software for any purpose.  It is provided \"as is\" without express\n * or implied warranty.\n */\n/*\n * Copyright (c) 2006-2008, Novell, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *       this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *   * The copyright holder's name is not used to endorse or promote products\n *       derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"k5-int.h\"\n\n#include <syslog.h>\n#ifdef HAVE_NETINET_IN_H\n#include <sys/types.h>\n#include <netinet/in.h>\n#ifndef hpux\n#include <arpa/inet.h>\n#endif\n#endif\n\n#include \"kdc_util.h\"\n#include \"kdc_audit.h\"\n#include \"policy.h\"\n#include \"extern.h\"\n#include \"adm_proto.h\"\n#include <ctype.h>\n\nstruct tgs_req_info {\n    /* The decoded request.  Ownership is transferred to this structure.  This\n     * will be replaced with the inner FAST body if present. */\n    krb5_kdc_req *req;\n\n    /*\n     * The decrypted authentication header ticket from the request's\n     * PA-TGS-REQ, the KDB entry for its server, its encryption key, the\n     * PA-TGS-REQ subkey if present, and the decoded and verified header ticket\n     * PAC if present.\n     */\n    krb5_ticket *header_tkt;\n    krb5_db_entry *header_server;\n    krb5_keyblock *header_key;\n    krb5_keyblock *subkey;\n    krb5_pac header_pac;\n\n    /*\n     * If a second ticket is present and this is a U2U or S4U2Proxy request,\n     * the decoded and verified PAC if present, the KDB entry for the second\n     * ticket server server, and the key used to decrypt the second ticket.\n     */\n    krb5_pac stkt_pac;\n    krb5_db_entry *stkt_server;\n    krb5_keyblock *stkt_server_key;\n    /* For cross-realm S4U2Proxy requests, the client principal retrieved from\n     * stkt_pac. */\n    krb5_principal stkt_pac_client;\n\n    /* Storage for the local TGT KDB entry for the service realm if that isn't\n     * the header server. */\n    krb5_db_entry *local_tgt_storage;\n    /* The decrypted first key of the local TGT entry. */\n    krb5_keyblock local_tgt_key;\n\n    /* The server KDB entry.  Normally the requested server, but for referral\n     * and alternate TGS replies this will be a cross-realm TGT entry. */\n    krb5_db_entry *server;\n\n    /*\n     * The subject client KDB entry for an S4U2Self request, or the header\n     * ticket client KDB entry for other requests.  NULL if\n     * NO_AUTH_DATA_REQUIRED is set on the server KDB entry and this isn't an\n     * S4U2Self request, or if the client is in another realm and the KDB\n     * cannot map its principal name.\n     */\n    krb5_db_entry *client;\n\n    /* The decoded S4U2Self padata from the request, if present. */\n    krb5_pa_s4u_x509_user *s4u2self;\n\n    /* Authentication indicators retrieved from the header ticket, for\n     * non-S4U2Self requests. */\n    krb5_data **auth_indicators;\n\n    /* Storage for a transited list with the header TGT realm added, if that\n     * realm is different from the client and server realm. */\n    krb5_data new_transited;\n\n    /* The KDB flags applicable to this request (a subset of {CROSS_REALM,\n     * ISSUING_REFERRAL, PROTOCOL_TRANSITION, CONSTRAINED_DELEGATION}). */\n    unsigned int flags;\n\n    /* Booleans for two of the above flags, for convenience. */\n    krb5_boolean is_referral;\n    krb5_boolean is_crossrealm;\n\n    /* The authtime of subject_tkt.  On early failures this may be 0. */\n    krb5_timestamp authtime;\n\n    /* The following fields are (or contain) alias pointers and should not be\n     * freed. */\n\n    /* The transited list implied by the request, aliasing new_transited or the\n     * header ticket transited field. */\n    krb5_transited transited;\n\n    /* Alias to the decrypted second ticket within req, if one applies to this\n     * request. */\n    const krb5_ticket *stkt;\n\n    /* Alias to stkt for S4U2Proxy requests, header_tkt otherwise. */\n    krb5_enc_tkt_part *subject_tkt;\n\n    /* Alias to local_tgt_storage or header_server. */\n    krb5_db_entry *local_tgt;\n\n    /* For either kind of S4U request, an alias to the requested client\n     * principal name. */\n    krb5_principal s4u_cprinc;\n\n    /* An alias to the client principal name we should issue the ticket for\n     * (either header_tkt->enc_part2->client or s4u_cprinc). */\n    krb5_principal tkt_client;\n\n    /* The client principal of the PA-TGS-REQ header ticket.  On early failures\n     * this may be NULL. */\n    krb5_principal cprinc;\n\n    /* The canonicalized request server principal or referral/alternate TGT.\n     * On early failures this may be the requested server instead. */\n    krb5_principal sprinc;\n\n};\n\nstatic krb5_error_code\ndb_get_svc_princ(krb5_context, krb5_principal, krb5_flags,\n                 krb5_db_entry **, const char **);\n\nstatic krb5_error_code\nprepare_error_tgs(struct kdc_request_state *state, krb5_kdc_req *request,\n                  krb5_ticket *ticket, krb5_error_code code,\n                  krb5_principal canon_server, krb5_data **response,\n                  const char *status, krb5_pa_data **e_data)\n{\n    krb5_context context = state->realm_data->realm_context;\n    krb5_error errpkt;\n    krb5_error_code retval = 0;\n    krb5_data *scratch, *e_data_asn1 = NULL, *fast_edata = NULL;\n\n    errpkt.magic = KV5M_ERROR;\n    errpkt.ctime = 0;\n    errpkt.cusec = 0;\n\n    retval = krb5_us_timeofday(context, &errpkt.stime, &errpkt.susec);\n    if (retval)\n        return(retval);\n    errpkt.error = errcode_to_protocol(code);\n    errpkt.server = request->server;\n    if (ticket && ticket->enc_part2)\n        errpkt.client = ticket->enc_part2->client;\n    else\n        errpkt.client = NULL;\n    errpkt.text.length = strlen(status);\n    if (!(errpkt.text.data = strdup(status)))\n        return ENOMEM;\n\n    if (!(scratch = (krb5_data *)malloc(sizeof(*scratch)))) {\n        free(errpkt.text.data);\n        return ENOMEM;\n    }\n\n    if (e_data != NULL) {\n        retval = encode_krb5_padata_sequence(e_data, &e_data_asn1);\n        if (retval) {\n            free(scratch);\n            free(errpkt.text.data);\n            return retval;\n        }\n        errpkt.e_data = *e_data_asn1;\n    } else\n        errpkt.e_data = empty_data();\n\n    retval = kdc_fast_handle_error(context, state, request, e_data,\n                                   &errpkt, &fast_edata);\n    if (retval) {\n        free(scratch);\n        free(errpkt.text.data);\n        krb5_free_data(context, e_data_asn1);\n        return retval;\n    }\n    if (fast_edata)\n        errpkt.e_data = *fast_edata;\n    if (kdc_fast_hide_client(state) && errpkt.client != NULL)\n        errpkt.client = (krb5_principal)krb5_anonymous_principal();\n    retval = krb5_mk_error(context, &errpkt, scratch);\n    free(errpkt.text.data);\n    krb5_free_data(context, e_data_asn1);\n    krb5_free_data(context, fast_edata);\n    if (retval)\n        free(scratch);\n    else\n        *response = scratch;\n\n    return retval;\n}\n\n/* KDC options that require a second ticket */\n#define STKT_OPTIONS (KDC_OPT_CNAME_IN_ADDL_TKT | KDC_OPT_ENC_TKT_IN_SKEY)\n/*\n * If req is a second-ticket request and a second ticket is present, decrypt\n * it.  Set *stkt_out to an alias to the ticket with populated enc_part2.  Set\n * *server_out to the server DB entry and *key_out to the ticket decryption\n * key.\n */\nstatic krb5_error_code\ndecrypt_2ndtkt(krb5_context context, krb5_kdc_req *req, krb5_flags flags,\n               krb5_db_entry *local_tgt, krb5_keyblock *local_tgt_key,\n               const krb5_ticket **stkt_out, krb5_pac *pac_out,\n               krb5_db_entry **server_out, krb5_keyblock **key_out,\n               const char **status)\n{\n    krb5_error_code retval;\n    krb5_db_entry *server = NULL;\n    krb5_keyblock *key = NULL;\n    krb5_kvno kvno;\n    krb5_ticket *stkt;\n\n    *stkt_out = NULL;\n    *pac_out = NULL;\n    *server_out = NULL;\n    *key_out = NULL;\n\n    if (!(req->kdc_options & STKT_OPTIONS) || req->second_ticket == NULL ||\n        req->second_ticket[0] == NULL)\n        return 0;\n\n    stkt = req->second_ticket[0];\n    retval = kdc_get_server_key(context, stkt, flags, TRUE, &server, &key,\n                                &kvno);\n    if (retval != 0) {\n        *status = \"2ND_TKT_SERVER\";\n        goto cleanup;\n    }\n    retval = krb5_decrypt_tkt_part(context, key, stkt);\n    if (retval != 0) {\n        *status = \"2ND_TKT_DECRYPT\";\n        goto cleanup;\n    }\n    retval = get_verified_pac(context, stkt->enc_part2, server, key, local_tgt,\n                              local_tgt_key, pac_out);\n    if (retval != 0) {\n        *status = \"2ND_TKT_PAC\";\n        goto cleanup;\n    }\n    *stkt_out = stkt;\n    *server_out = server;\n    *key_out = key;\n    server = NULL;\n    key = NULL;\n\ncleanup:\n    krb5_db_free_principal(context, server);\n    krb5_free_keyblock(context, key);\n    return retval;\n}\n\nstatic krb5_error_code\nget_2ndtkt_enctype(krb5_kdc_req *req, krb5_enctype *useenctype,\n                   const char **status)\n{\n    krb5_enctype etype;\n    krb5_ticket *stkt = req->second_ticket[0];\n    int i;\n\n    etype = stkt->enc_part2->session->enctype;\n    if (!krb5_c_valid_enctype(etype)) {\n        *status = \"BAD_ETYPE_IN_2ND_TKT\";\n        return KRB5KDC_ERR_ETYPE_NOSUPP;\n    }\n    for (i = 0; i < req->nktypes; i++) {\n        if (req->ktype[i] == etype) {\n            *useenctype = etype;\n            break;\n        }\n    }\n    return 0;\n}\n\nstatic krb5_error_code\ngen_session_key(krb5_context context, krb5_kdc_req *req, krb5_db_entry *server,\n                krb5_keyblock *skey, const char **status)\n{\n    krb5_error_code retval;\n    krb5_enctype useenctype = 0;\n\n    /*\n     * Some special care needs to be taken in the user-to-user\n     * case, since we don't know what keytypes the application server\n     * which is doing user-to-user authentication can support.  We\n     * know that it at least must be able to support the encryption\n     * type of the session key in the TGT, since otherwise it won't be\n     * able to decrypt the U2U ticket!  So we use that in preference\n     * to anything else.\n     */\n    if (req->kdc_options & KDC_OPT_ENC_TKT_IN_SKEY) {\n        retval = get_2ndtkt_enctype(req, &useenctype, status);\n        if (retval != 0)\n            return retval;\n    }\n    if (useenctype == 0) {\n        useenctype = select_session_keytype(context, server,\n                                            req->nktypes, req->ktype);\n    }\n    if (useenctype == 0) {\n        /* unsupported ktype */\n        *status = \"BAD_ENCRYPTION_TYPE\";\n        return KRB5KDC_ERR_ETYPE_NOSUPP;\n    }\n\n    return krb5_c_make_random_key(context, useenctype, skey);\n}\n\n/*\n * The request seems to be for a ticket-granting service somewhere else,\n * but we don't have a ticket for the final TGS.  Try to give the requestor\n * some intermediate realm.\n */\nstatic krb5_error_code\nfind_alternate_tgs(krb5_context context, krb5_principal princ,\n                   krb5_db_entry **server_ptr, const char **status)\n{\n    krb5_error_code retval;\n    krb5_principal *plist = NULL, *pl2;\n    krb5_data tmp;\n    krb5_db_entry *server = NULL;\n\n    *server_ptr = NULL;\n    assert(is_cross_tgs_principal(princ));\n    retval = krb5_walk_realm_tree(context, &princ->realm, &princ->data[1],\n                                  &plist, KRB5_REALM_BRANCH_CHAR);\n    if (retval)\n        goto cleanup;\n    /* move to the end */\n    for (pl2 = plist; *pl2; pl2++);\n\n    /* the first entry in this array is for krbtgt/local@local, so we\n       ignore it */\n    while (--pl2 > plist) {\n        tmp = *krb5_princ_realm(context, *pl2);\n        krb5_princ_set_realm(context, *pl2, &princ->realm);\n        retval = db_get_svc_princ(context, *pl2, 0, &server, status);\n        krb5_princ_set_realm(context, *pl2, &tmp);\n        if (retval == KRB5_KDB_NOENTRY)\n            continue;\n        else if (retval)\n            goto cleanup;\n\n        log_tgs_alt_tgt(context, server->princ);\n        *server_ptr = server;\n        server = NULL;\n        goto cleanup;\n    }\ncleanup:\n    if (retval == 0 && *server_ptr == NULL)\n        retval = KRB5_KDB_NOENTRY;\n    if (retval != 0)\n        *status = \"UNKNOWN_SERVER\";\n\n    krb5_free_realm_tree(context, plist);\n    krb5_db_free_principal(context, server);\n    return retval;\n}\n\n/* Return true if item is an element of the space/comma-separated list. */\nstatic krb5_boolean\nin_list(const char *list, const char *item)\n{\n    const char *p;\n    int len = strlen(item);\n\n    if (list == NULL)\n        return FALSE;\n    for (p = strstr(list, item); p != NULL; p = strstr(p + 1, item)) {\n        if ((p == list || isspace((unsigned char)p[-1]) || p[-1] == ',') &&\n            (p[len] == '\\0' || isspace((unsigned char)p[len]) ||\n             p[len] == ','))\n                return TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Check whether the request satisfies the conditions for generating a referral\n * TGT.  The caller checks whether the hostname component looks like a FQDN.\n */\nstatic krb5_boolean\nis_referral_req(kdc_realm_t *realm, krb5_kdc_req *request)\n{\n    krb5_boolean ret = FALSE;\n    char *stype = NULL;\n    char *hostbased = realm->realm_hostbased;\n    char *no_referral = realm->realm_no_referral;\n\n    if (!(request->kdc_options & KDC_OPT_CANONICALIZE))\n        return FALSE;\n\n    if (request->kdc_options & KDC_OPT_ENC_TKT_IN_SKEY)\n        return FALSE;\n\n    if (request->server->length != 2)\n        return FALSE;\n\n    stype = data2string(&request->server->data[0]);\n    if (stype == NULL)\n        return FALSE;\n    switch (request->server->type) {\n    case KRB5_NT_UNKNOWN:\n        /* Allow referrals for NT-UNKNOWN principals, if configured. */\n        if (!in_list(hostbased, stype) && !in_list(hostbased, \"*\"))\n            goto cleanup;\n        /* FALLTHROUGH */\n    case KRB5_NT_SRV_HST:\n    case KRB5_NT_SRV_INST:\n        /* Deny referrals for specific service types, if configured. */\n        if (in_list(no_referral, stype) || in_list(no_referral, \"*\"))\n            goto cleanup;\n        ret = TRUE;\n        break;\n    default:\n        goto cleanup;\n    }\ncleanup:\n    free(stype);\n    return ret;\n}\n\n/*\n * Find a remote realm TGS principal for an unknown host-based service\n * principal.\n */\nstatic krb5_int32\nfind_referral_tgs(kdc_realm_t *realm, krb5_kdc_req *request,\n                  krb5_principal *krbtgt_princ)\n{\n    krb5_context context = realm->realm_context;\n    krb5_error_code retval = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n    char **realms = NULL, *hostname = NULL;\n    krb5_data srealm = request->server->realm;\n\n    if (!is_referral_req(realm, request))\n        goto cleanup;\n\n    hostname = data2string(&request->server->data[1]);\n    if (hostname == NULL) {\n        retval = ENOMEM;\n        goto cleanup;\n    }\n    /* If the hostname doesn't contain a '.', it's not a FQDN. */\n    if (strchr(hostname, '.') == NULL)\n        goto cleanup;\n    retval = krb5_get_host_realm(context, hostname, &realms);\n    if (retval) {\n        /* no match found */\n        kdc_err(context, retval, \"unable to find realm of host\");\n        goto cleanup;\n    }\n    /* Don't return a referral to the empty realm or the service realm. */\n    if (realms == NULL || realms[0] == NULL || *realms[0] == '\\0' ||\n        data_eq_string(srealm, realms[0])) {\n        retval = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n        goto cleanup;\n    }\n    retval = krb5_build_principal(context, krbtgt_princ,\n                                  srealm.length, srealm.data,\n                                  \"krbtgt\", realms[0], (char *)0);\ncleanup:\n    krb5_free_host_realm(context, realms);\n    free(hostname);\n\n    return retval;\n}\n\nstatic krb5_error_code\ndb_get_svc_princ(krb5_context ctx, krb5_principal princ,\n                 krb5_flags flags, krb5_db_entry **server,\n                 const char **status)\n{\n    krb5_error_code ret;\n\n    ret = krb5_db_get_principal(ctx, princ, flags, server);\n    if (ret == KRB5_KDB_CANTLOCK_DB)\n        ret = KRB5KDC_ERR_SVC_UNAVAILABLE;\n    if (ret != 0) {\n        *status = \"LOOKING_UP_SERVER\";\n    }\n    return ret;\n}\n\nstatic krb5_error_code\nsearch_sprinc(kdc_realm_t *realm, krb5_kdc_req *req,\n              krb5_flags flags, krb5_db_entry **server, const char **status)\n{\n    krb5_context context = realm->realm_context;\n    krb5_error_code ret;\n    krb5_principal princ = req->server;\n    krb5_principal reftgs = NULL;\n    krb5_boolean allow_referral;\n\n    /* Do not allow referrals for u2u or ticket modification requests, because\n     * the server is supposed to match an already-issued ticket. */\n    allow_referral = !(req->kdc_options & NO_REFERRAL_OPTION);\n    if (!allow_referral)\n        flags &= ~KRB5_KDB_FLAG_REFERRAL_OK;\n\n    ret = db_get_svc_princ(context, princ, flags, server, status);\n    if (ret == 0 || ret != KRB5_KDB_NOENTRY || !allow_referral)\n        goto cleanup;\n\n    if (!is_cross_tgs_principal(req->server)) {\n        ret = find_referral_tgs(realm, req, &reftgs);\n        if (ret != 0)\n            goto cleanup;\n        ret = db_get_svc_princ(context, reftgs, flags, server, status);\n        if (ret == 0 || ret != KRB5_KDB_NOENTRY)\n            goto cleanup;\n\n        princ = reftgs;\n    }\n    ret = find_alternate_tgs(context, princ, server, status);\n\ncleanup:\n    if (ret != 0 && ret != KRB5KDC_ERR_SVC_UNAVAILABLE) {\n        ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n        if (*status == NULL)\n            *status = \"LOOKING_UP_SERVER\";\n    }\n    krb5_free_principal(context, reftgs);\n    return ret;\n}\n\n/*\n * Transfer ownership of *reqptr to *t and fill *t with information about the\n * request.  Decode the PA-TGS-REQ header ticket and the second ticket if\n * applicable, and decode and verify their PACs if present.  Decode and verify\n * the S4U2Self request pa-data if present.  Extract authentication indicators\n * from the subject ticket.  Construct the transited list implied by the\n * request.\n */\nstatic krb5_error_code\ngather_tgs_req_info(kdc_realm_t *realm, krb5_kdc_req **reqptr, krb5_data *pkt,\n                    const krb5_fulladdr *from,\n                    struct kdc_request_state *fast_state,\n                    krb5_audit_state *au_state, struct tgs_req_info *t,\n                    const char **status)\n{\n    krb5_context context = realm->realm_context;\n    krb5_error_code ret;\n    krb5_pa_data *pa_tgs_req;\n    unsigned int s_flags;\n    krb5_enc_tkt_part *header_enc;\n    krb5_data d;\n\n    /* Transfer ownership of *reqptr to *t. */\n    t->req = *reqptr;\n    *reqptr = NULL;\n\n    if (t->req->msg_type != KRB5_TGS_REQ)\n        return KRB5_BADMSGTYPE;\n\n    /* Initially set t->sprinc to the outer request server, for logging of\n     * early failures. */\n    t->sprinc = t->req->server;\n\n    /* Read the PA-TGS-REQ authenticator and decrypt the header ticket. */\n    ret = kdc_process_tgs_req(realm, t->req, from, pkt, &t->header_tkt,\n                              &t->header_server, &t->header_key, &t->subkey,\n                              &pa_tgs_req);\n    if (t->header_tkt != NULL && t->header_tkt->enc_part2 != NULL)\n        t->cprinc = t->header_tkt->enc_part2->client;\n    if (ret) {\n        *status = \"PROCESS_TGS\";\n        return ret;\n    }\n    ret = kau_make_tkt_id(context, t->header_tkt, &au_state->tkt_in_id);\n    if (ret)\n        return ret;\n    header_enc = t->header_tkt->enc_part2;\n\n    /* If PA-FX-FAST-REQUEST padata is present, replace t->req with the inner\n     * request body. */\n    d = make_data(pa_tgs_req->contents, pa_tgs_req->length);\n    ret = kdc_find_fast(&t->req, &d, t->subkey, header_enc->session,\n                        fast_state, NULL);\n    if (ret) {\n        *status = \"FIND_FAST\";\n        return ret;\n    }\n    /* Reset t->sprinc for the inner body and check it. */\n    t->sprinc = t->req->server;\n    if (t->sprinc == NULL) {\n        *status = \"NULL_SERVER\";\n        return KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n    }\n\n    /* The header ticket server is usually a TGT, but if it is not, fetch the\n     * local TGT for the realm.  Get the decrypted first local TGT key. */\n    ret = get_local_tgt(context, &t->sprinc->realm, t->header_server,\n                        &t->local_tgt, &t->local_tgt_storage,\n                        &t->local_tgt_key);\n    if (ret) {\n        *status = \"GET_LOCAL_TGT\";\n        return ret;\n    }\n\n    /* Decode and verify the header ticket PAC. */\n    ret = get_verified_pac(context, header_enc, t->header_server,\n                           t->header_key, t->local_tgt, &t->local_tgt_key,\n                           &t->header_pac);\n    if (ret) {\n        *status = \"HEADER_PAC\";\n        return ret;\n    }\n\n    au_state->request = t->req;\n    au_state->stage = SRVC_PRINC;\n\n    /* Look up the server principal entry, or a referral/alternate TGT.  Reset\n     * t->sprinc to the canonical server name (its final value). */\n    s_flags = (t->req->kdc_options & KDC_OPT_CANONICALIZE) ?\n        KRB5_KDB_FLAG_REFERRAL_OK : 0;\n    ret = search_sprinc(realm, t->req, s_flags, &t->server, status);\n    if (ret)\n        return ret;\n    t->sprinc = t->server->princ;\n\n    /* If we got a cross-realm TGS which is not the requested server, we are\n     * issuing a referral (or alternate TGT, which we treat similarly). */\n    if (is_cross_tgs_principal(t->server->princ) &&\n        !krb5_principal_compare(context, t->req->server, t->server->princ))\n        t->flags |= KRB5_KDB_FLAG_ISSUING_REFERRAL;\n\n    /* Mark the request as cross-realm if the header ticket server is not from\n     * this realm. */\n    if (!data_eq(t->header_server->princ->realm, t->sprinc->realm))\n        t->flags |= KRB5_KDB_FLAG_CROSS_REALM;\n\n    t->is_referral = (t->flags & KRB5_KDB_FLAG_ISSUING_REFERRAL);\n    t->is_crossrealm = (t->flags & KRB5_KDB_FLAG_CROSS_REALM);\n\n    /* If S4U2Self padata is present, read it to get the requested principal\n     * name.  Look up the requested client if it is in this realm. */\n    ret = kdc_process_s4u2self_req(context, t->req, t->server, t->subkey,\n                                   header_enc->session, &t->s4u2self,\n                                   &t->client, status);\n    if (t->s4u2self != NULL || ret) {\n        if (t->s4u2self != NULL)\n            au_state->s4u2self_user = t->s4u2self->user_id.user;\n        au_state->status = *status;\n        kau_s4u2self(context, !ret, au_state);\n        au_state->s4u2self_user = NULL;\n    }\n    if (ret)\n        return ret;\n    if (t->s4u2self != NULL) {\n        t->flags |= KRB5_KDB_FLAG_PROTOCOL_TRANSITION;\n        t->s4u_cprinc = t->s4u2self->user_id.user;\n\n        /*\n         * For consistency with Active Directory, don't allow authorization\n         * data to be disabled if S4U2Self is requested.  The requesting\n         * service likely needs a PAC for an S4U2Proxy operation, even if it\n         * doesn't need authorization data in tickets received from clients.\n         */\n        t->server->attributes &= ~KRB5_KDB_NO_AUTH_DATA_REQUIRED;\n    }\n\n    /* For U2U or S4U2Proxy requests, decrypt the second ticket and read its\n     * PAC. */\n    ret = decrypt_2ndtkt(context, t->req, t->flags, t->local_tgt,\n                         &t->local_tgt_key, &t->stkt, &t->stkt_pac,\n                         &t->stkt_server, &t->stkt_server_key, status);\n    if (ret)\n        return ret;\n\n    /* Determine the subject ticket and set the authtime for logging.  For\n     * S4U2Proxy requests determine the requested client principal. */\n    if (t->req->kdc_options & KDC_OPT_CNAME_IN_ADDL_TKT) {\n        t->flags |= KRB5_KDB_FLAG_CONSTRAINED_DELEGATION;\n        ret = kau_make_tkt_id(context, t->stkt, &au_state->evid_tkt_id);\n        if (ret)\n            return ret;\n        if (t->is_crossrealm) {\n            /* For cross-realm S4U2PROXY requests, the second ticket is a\n             * cross TGT with the requested client principal in its PAC. */\n            if (t->stkt_pac == NULL ||\n                get_pac_princ_with_realm(context, t->stkt_pac,\n                                         &t->stkt_pac_client, NULL) != 0) {\n                au_state->status = *status = \"RBCD_PAC_PRINC\";\n                au_state->violation = PROT_CONSTRAINT;\n                kau_s4u2proxy(context, FALSE, au_state);\n                return KRB5KDC_ERR_BADOPTION;\n            }\n            t->s4u_cprinc = t->stkt_pac_client;\n        } else {\n            /* Otherwise the requested client is the evidence ticket client. */\n            t->s4u_cprinc = t->stkt->enc_part2->client;\n        }\n        t->subject_tkt = t->stkt->enc_part2;\n    } else {\n        t->subject_tkt = header_enc;\n    }\n    t->authtime = t->subject_tkt->times.authtime;\n\n    /* For final S4U requests (either type) the issued ticket will be for the\n     * requested name; otherwise it will be for the header ticket client. */\n    t->tkt_client = ((t->flags & KRB5_KDB_FLAGS_S4U) && !t->is_referral) ?\n        t->s4u_cprinc : header_enc->client;\n\n    if (t->s4u2self == NULL) {\n        /* Extract auth indicators from the subject ticket.  Skip this for\n         * S4U2Self requests as the subject didn't authenticate. */\n        ret = get_auth_indicators(context, t->subject_tkt, t->local_tgt,\n                                  &t->local_tgt_key, &t->auth_indicators);\n        if (ret) {\n            *status = \"GET_AUTH_INDICATORS\";\n            return ret;\n        }\n\n        if (!(t->server->attributes & KRB5_KDB_NO_AUTH_DATA_REQUIRED)) {\n            /* Try to look up the subject principal so that KDB modules can add\n             * additional authdata.  Ask the KDB to map foreign principals. */\n            assert(t->client == NULL);\n            (void)krb5_db_get_principal(context, t->subject_tkt->client,\n                                        t->flags | KRB5_KDB_FLAG_CLIENT |\n                                        KRB5_KDB_FLAG_MAP_PRINCIPALS,\n                                        &t->client);\n        }\n    }\n\n    /*\n     * Compute the transited list implied by the request.  Use the existing\n     * transited list if the realm of the header ticket server is the same as\n     * the subject or server realm.\n     */\n    if (!t->is_crossrealm ||\n        data_eq(t->header_tkt->server->realm, t->tkt_client->realm)) {\n        t->transited = header_enc->transited;\n    } else {\n        if (header_enc->transited.tr_type != KRB5_DOMAIN_X500_COMPRESS) {\n            *status = \"VALIDATE_TRANSIT_TYPE\";\n            return KRB5KDC_ERR_TRTYPE_NOSUPP;\n        }\n        ret = add_to_transited(&header_enc->transited.tr_contents,\n                               &t->new_transited, t->header_tkt->server,\n                               t->tkt_client, t->req->server);\n        if (ret) {\n            *status = \"ADD_TO_TRANSITED_LIST\";\n            return ret;\n        }\n        t->transited.tr_type = KRB5_DOMAIN_X500_COMPRESS;\n        t->transited.tr_contents = t->new_transited;\n    }\n\n    return 0;\n}\n\n/* Fill in *times_out with the times of the ticket to be issued.  Set the\n * TKT_FLG_RENEWABLE bit in *tktflags if the ticket will be renewable. */\nstatic void\ncompute_ticket_times(kdc_realm_t *realm, struct tgs_req_info *t,\n                     krb5_timestamp kdc_time, krb5_flags *tktflags,\n                     krb5_ticket_times *times)\n{\n    krb5_timestamp hstarttime;\n    krb5_deltat hlife;\n    krb5_ticket_times *htimes = &t->header_tkt->enc_part2->times;\n\n    if (t->req->kdc_options & KDC_OPT_VALIDATE) {\n        /* Validation requests preserve the header ticket times. */\n        *times = *htimes;\n        return;\n    }\n\n    /* Preserve the authtime from the subject ticket. */\n    times->authtime = t->authtime;\n\n    times->starttime = (t->req->kdc_options & KDC_OPT_POSTDATED) ?\n        t->req->from : kdc_time;\n\n    if (t->req->kdc_options & KDC_OPT_RENEW) {\n        /* Give the new ticket the same lifetime as the header ticket, but no\n         * later than the renewable end time. */\n        hstarttime = htimes->starttime ? htimes->starttime : htimes->authtime;\n        hlife = ts_delta(htimes->endtime, hstarttime);\n        times->endtime = ts_min(htimes->renew_till,\n                                ts_incr(times->starttime, hlife));\n    } else {\n        kdc_get_ticket_endtime(realm, times->starttime, htimes->endtime,\n                               t->req->till, t->client, t->server,\n                               &times->endtime);\n    }\n\n    kdc_get_ticket_renewtime(realm, t->req, t->header_tkt->enc_part2,\n                             t->client, t->server, tktflags, times);\n\n    /* starttime is optional, and treated as authtime if not present.\n     * so we can omit it if it matches. */\n    if (times->starttime == times->authtime)\n        times->starttime = 0;\n}\n\n/* Check the request in *t against semantic protocol constraints and local\n * policy.  Determine flags and times for the ticket to be issued. */\nstatic krb5_error_code\ncheck_tgs_req(kdc_realm_t *realm, struct tgs_req_info *t,\n              krb5_audit_state *au_state, krb5_flags *tktflags,\n              krb5_ticket_times *times, const char **status,\n              krb5_pa_data ***e_data)\n{\n    krb5_context context = realm->realm_context;\n    krb5_error_code ret;\n    krb5_timestamp kdc_time;\n\n    au_state->stage = VALIDATE_POL;\n\n    ret = krb5_timeofday(context, &kdc_time);\n    if (ret)\n        return ret;\n\n    ret = check_tgs_constraints(realm, t->req, t->server, t->header_tkt,\n                                t->header_pac, t->stkt, t->stkt_pac,\n                                t->stkt_server, kdc_time, t->s4u2self,\n                                t->client, t->is_crossrealm, t->is_referral,\n                                status, e_data);\n    if (ret) {\n        au_state->violation = PROT_CONSTRAINT;\n        return ret;\n    }\n\n    ret = check_tgs_policy(realm, t->req, t->server, t->header_tkt,\n                           t->header_pac, t->stkt, t->stkt_pac,\n                           t->stkt_pac_client, t->stkt_server, kdc_time,\n                           t->is_crossrealm, t->is_referral, status, e_data);\n    if (ret) {\n        au_state->violation = LOCAL_POLICY;\n        if (t->flags & KRB5_KDB_FLAG_CONSTRAINED_DELEGATION) {\n            au_state->status = *status;\n            kau_s4u2proxy(context, FALSE, au_state);\n        }\n        return ret;\n    }\n\n    /* Check auth indicators from the subject ticket, except for S4U2Self\n     * requests (where the client didn't authenticate). */\n    if (t->s4u2self == NULL) {\n        ret = check_indicators(context, t->server, t->auth_indicators);\n        if (ret) {\n            *status = \"HIGHER_AUTHENTICATION_REQUIRED\";\n            return ret;\n        }\n    }\n\n    *tktflags = get_ticket_flags(t->req->kdc_options, t->client, t->server,\n                                 t->header_tkt->enc_part2);\n    compute_ticket_times(realm, t, kdc_time, tktflags, times);\n\n    /* For S4U2Self requests, check if we need to suppress the forwardable\n     * ticket flag. */\n    if (t->s4u2self != NULL && !t->is_referral) {\n        ret = s4u2self_forwardable(context, t->server, tktflags);\n        if (ret)\n            return ret;\n    }\n\n    /* Consult kdcpolicy modules, giving them a chance to modify the times of\n     * the issued ticket. */\n    ret = check_kdcpolicy_tgs(context, t->req, t->server, t->header_tkt,\n                              t->auth_indicators, kdc_time, times, status);\n    if (ret)\n        return ret;\n\n    if (!(t->req->kdc_options & KDC_OPT_DISABLE_TRANSITED_CHECK)) {\n        /* Check the transited path for the issued ticket and set the\n         * transited-policy-checked flag if successful. */\n        ret = kdc_check_transited_list(context, &t->transited.tr_contents,\n                                       &t->subject_tkt->client->realm,\n                                       &t->req->server->realm);\n        if (ret) {\n            /* Log the transited-check failure and continue. */\n            log_tgs_badtrans(context, t->cprinc, t->sprinc,\n                             &t->transited.tr_contents, ret);\n        } else {\n            *tktflags |= TKT_FLG_TRANSIT_POLICY_CHECKED;\n        }\n    } else {\n        krb5_klog_syslog(LOG_INFO, _(\"not checking transit path\"));\n    }\n\n    /* By default, reject the request if the transited path was not checked\n     * successfully. */\n    if (realm->realm_reject_bad_transit &&\n        !(*tktflags & TKT_FLG_TRANSIT_POLICY_CHECKED)) {\n        *status = \"BAD_TRANSIT\";\n        au_state->violation = LOCAL_POLICY;\n        return KRB5KDC_ERR_POLICY;\n    }\n\n    return 0;\n}\n\n/* Construct a response issuing a ticket for the request in *t, using tktflags\n * and *times for the ticket flags and times. */\nstatic krb5_error_code\ntgs_issue_ticket(kdc_realm_t *realm, struct tgs_req_info *t,\n                 krb5_flags tktflags, krb5_ticket_times *times, krb5_data *pkt,\n                 const krb5_fulladdr *from,\n                 struct kdc_request_state *fast_state,\n                 krb5_audit_state *au_state, const char **status,\n                 krb5_data **response)\n{\n    krb5_context context = realm->realm_context;\n    krb5_error_code ret;\n    krb5_keyblock session_key = { 0 }, server_key = { 0 };\n    krb5_keyblock *ticket_encrypting_key, *subject_key;\n    krb5_keyblock *initial_reply_key, *fast_reply_key = NULL;\n    krb5_enc_tkt_part enc_tkt_reply = { 0 };\n    krb5_ticket ticket_reply = { 0 };\n    krb5_enc_kdc_rep_part reply_encpart = { 0 };\n    krb5_kdc_rep reply = { 0 };\n    krb5_pac subject_pac;\n    krb5_db_entry *subject_server;\n    krb5_enc_tkt_part *header_enc_tkt = t->header_tkt->enc_part2;\n    krb5_last_req_entry nolrentry = { KV5M_LAST_REQ_ENTRY, KRB5_LRQ_NONE, 0 };\n    krb5_last_req_entry *nolrarray[2] = { &nolrentry, NULL };\n\n    au_state->stage = ISSUE_TKT;\n\n    ret = gen_session_key(context, t->req, t->server, &session_key, status);\n    if (ret)\n        goto cleanup;\n\n    if (t->flags & KRB5_KDB_FLAG_CONSTRAINED_DELEGATION) {\n        subject_pac = t->stkt_pac;\n        subject_server = t->stkt_server;\n        subject_key = t->stkt_server_key;\n    } else {\n        subject_pac = t->header_pac;\n        subject_server = t->header_server;\n        subject_key = t->header_key;\n    }\n\n    initial_reply_key = (t->subkey != NULL) ? t->subkey :\n        t->header_tkt->enc_part2->session;\n\n    if (t->req->kdc_options & KDC_OPT_ENC_TKT_IN_SKEY) {\n        /* For user-to-user, encrypt the ticket with the second ticket's\n         * session key. */\n        ticket_encrypting_key = t->stkt->enc_part2->session;\n    } else {\n        /* Otherwise encrypt the ticket with the server entry's first long-term\n         * key. */\n        ret = get_first_current_key(context, t->server, &server_key);\n        if (ret) {\n            *status = \"FINDING_SERVER_KEY\";\n            goto cleanup;\n        }\n        ticket_encrypting_key = &server_key;\n    }\n\n    if (t->req->kdc_options & (KDC_OPT_VALIDATE | KDC_OPT_RENEW)) {\n        /* Copy the whole header ticket except for authorization data. */\n        ticket_reply = *t->header_tkt;\n        enc_tkt_reply = *t->header_tkt->enc_part2;\n        enc_tkt_reply.authorization_data = NULL;\n    } else {\n        if (t->req->kdc_options & (KDC_OPT_FORWARDED | KDC_OPT_PROXY)) {\n            /* Include the requested addresses in the ticket and reply. */\n            enc_tkt_reply.caddrs = t->req->addresses;\n            reply_encpart.caddrs = t->req->addresses;\n        } else {\n            /* Use the header ticket addresses and omit them from the reply. */\n            enc_tkt_reply.caddrs = header_enc_tkt->caddrs;\n            reply_encpart.caddrs = NULL;\n        }\n\n        ticket_reply.server = t->is_referral ? t->sprinc : t->req->server;\n    }\n\n    enc_tkt_reply.flags = tktflags;\n    enc_tkt_reply.times = *times;\n    enc_tkt_reply.client = t->tkt_client;\n    enc_tkt_reply.session = &session_key;\n    enc_tkt_reply.transited = t->transited;\n\n    ret = handle_authdata(realm, t->flags, t->client, t->server,\n                          subject_server, t->local_tgt, &t->local_tgt_key,\n                          initial_reply_key, ticket_encrypting_key,\n                          subject_key, NULL, pkt, t->req, t->s4u_cprinc,\n                          subject_pac, t->subject_tkt, &t->auth_indicators,\n                          &enc_tkt_reply);\n    if (ret) {\n        krb5_klog_syslog(LOG_INFO, _(\"TGS_REQ : handle_authdata (%d)\"), ret);\n        *status = \"HANDLE_AUTHDATA\";\n        goto cleanup;\n    }\n\n    ticket_reply.enc_part2 = &enc_tkt_reply;\n\n    ret = krb5_encrypt_tkt_part(context, ticket_encrypting_key, &ticket_reply);\n    if (ret)\n        goto cleanup;\n\n    if (t->req->kdc_options & KDC_OPT_ENC_TKT_IN_SKEY) {\n        ticket_reply.enc_part.kvno = 0;\n        kau_u2u(context, TRUE, au_state);\n    } else {\n        ticket_reply.enc_part.kvno = current_kvno(t->server);\n    }\n\n    au_state->stage = ENCR_REP;\n\n    if (t->s4u2self != NULL &&\n        krb5int_find_pa_data(context, t->req->padata,\n                             KRB5_PADATA_S4U_X509_USER) != NULL) {\n        /* Add an S4U2Self response to the encrypted padata (skipped if the\n         * request only included PA-FOR-USER padata). */\n        ret = kdc_make_s4u2self_rep(context, t->subkey,\n                                    t->header_tkt->enc_part2->session,\n                                    t->s4u2self, &reply, &reply_encpart);\n        if (ret)\n            goto cleanup;\n    }\n\n    reply_encpart.session = &session_key;\n    reply_encpart.nonce = t->req->nonce;\n    reply_encpart.times = enc_tkt_reply.times;\n    reply_encpart.last_req = nolrarray;\n    reply_encpart.key_exp = 0;\n    reply_encpart.flags = enc_tkt_reply.flags;\n    reply_encpart.server = ticket_reply.server;\n\n    reply.msg_type = KRB5_TGS_REP;\n    reply.client = enc_tkt_reply.client;\n    reply.ticket = &ticket_reply;\n    reply.enc_part.kvno = 0;\n    reply.enc_part.enctype = initial_reply_key->enctype;\n    ret = kdc_fast_response_handle_padata(fast_state, t->req, &reply,\n                                          initial_reply_key->enctype);\n    if (ret)\n        goto cleanup;\n    ret = kdc_fast_handle_reply_key(fast_state, initial_reply_key,\n                                    &fast_reply_key);\n    if (ret)\n        goto cleanup;\n    ret = return_enc_padata(context, pkt, t->req, fast_reply_key, t->server,\n                            &reply_encpart,\n                            t->is_referral &&\n                            (t->req->kdc_options & KDC_OPT_CANONICALIZE));\n    if (ret) {\n        *status = \"KDC_RETURN_ENC_PADATA\";\n        goto cleanup;\n    }\n\n    ret = kau_make_tkt_id(context, &ticket_reply, &au_state->tkt_out_id);\n    if (ret)\n        goto cleanup;\n\n    if (kdc_fast_hide_client(fast_state))\n        reply.client = (krb5_principal)krb5_anonymous_principal();\n    ret = krb5_encode_kdc_rep(context, KRB5_TGS_REP, &reply_encpart,\n                              t->subkey != NULL, fast_reply_key, &reply,\n                              response);\n    if (ret)\n        goto cleanup;\n\n    log_tgs_req(context, from, t->req, &reply, t->cprinc, t->sprinc,\n                t->s4u_cprinc, t->authtime, t->flags, \"ISSUE\", 0, NULL);\n    au_state->status = \"ISSUE\";\n    au_state->reply = &reply;\n    if (t->flags & KRB5_KDB_FLAG_CONSTRAINED_DELEGATION)\n        kau_s4u2proxy(context, TRUE, au_state);\n    kau_tgs_req(context, TRUE, au_state);\n    au_state->reply = NULL;\n\ncleanup:\n    zapfree(ticket_reply.enc_part.ciphertext.data,\n            ticket_reply.enc_part.ciphertext.length);\n    zapfree(reply.enc_part.ciphertext.data, reply.enc_part.ciphertext.length);\n    krb5_free_pa_data(context, reply.padata);\n    krb5_free_pa_data(context, reply_encpart.enc_padata);\n    krb5_free_authdata(context, enc_tkt_reply.authorization_data);\n    krb5_free_keyblock_contents(context, &session_key);\n    krb5_free_keyblock_contents(context, &server_key);\n    krb5_free_keyblock(context, fast_reply_key);\n    return ret;\n}\n\nstatic void\nfree_req_info(krb5_context context, struct tgs_req_info *t)\n{\n    krb5_free_kdc_req(context, t->req);\n    krb5_free_ticket(context, t->header_tkt);\n    krb5_db_free_principal(context, t->header_server);\n    krb5_free_keyblock(context, t->header_key);\n    krb5_free_keyblock(context, t->subkey);\n    krb5_pac_free(context, t->header_pac);\n    krb5_pac_free(context, t->stkt_pac);\n    krb5_db_free_principal(context, t->stkt_server);\n    krb5_free_keyblock(context, t->stkt_server_key);\n    krb5_db_free_principal(context, t->local_tgt_storage);\n    krb5_free_keyblock_contents(context, &t->local_tgt_key);\n    krb5_db_free_principal(context, t->server);\n    krb5_db_free_principal(context, t->client);\n    krb5_free_pa_s4u_x509_user(context, t->s4u2self);\n    krb5_free_principal(context, t->stkt_pac_client);\n    k5_free_data_ptr_list(t->auth_indicators);\n    krb5_free_data_contents(context, &t->new_transited);\n}\n\nkrb5_error_code\nprocess_tgs_req(krb5_kdc_req *request, krb5_data *pkt,\n                const krb5_fulladdr *from, kdc_realm_t *realm,\n                krb5_data **response)\n{\n    krb5_context context = realm->realm_context;\n    krb5_error_code ret;\n    struct tgs_req_info t = { 0 };\n    struct kdc_request_state *fast_state = NULL;\n    krb5_audit_state *au_state = NULL;\n    krb5_pa_data **e_data = NULL;\n    krb5_flags tktflags;\n    krb5_ticket_times times = { 0 };\n    const char *emsg = NULL, *status = NULL;\n\n    ret = kdc_make_rstate(realm, &fast_state);\n    if (ret)\n        goto cleanup;\n    ret = kau_init_kdc_req(context, request, from, &au_state);\n    if (ret)\n        goto cleanup;\n    kau_tgs_req(context, TRUE, au_state);\n\n    ret = gather_tgs_req_info(realm, &request, pkt, from, fast_state, au_state,\n                              &t, &status);\n    if (ret)\n        goto cleanup;\n\n    ret = check_tgs_req(realm, &t, au_state, &tktflags, &times, &status,\n                        &e_data);\n    if (ret)\n        goto cleanup;\n\n    ret = tgs_issue_ticket(realm, &t, tktflags, &times, pkt, from, fast_state,\n                           au_state, &status, response);\n    if (ret)\n        goto cleanup;\n\ncleanup:\n    if (status == NULL)\n        status = \"UNKNOWN_REASON\";\n\n    if (ret) {\n        emsg = krb5_get_error_message(context, ret);\n        log_tgs_req(context, from, t.req, NULL, t.cprinc, t.sprinc,\n                    t.s4u_cprinc, t.authtime, t.flags, status, ret, emsg);\n        krb5_free_error_message(context, emsg);\n\n        if (au_state != NULL) {\n            au_state->status = status;\n            kau_tgs_req(context, FALSE, au_state);\n        }\n    }\n\n    if (ret && fast_state != NULL) {\n        ret = prepare_error_tgs(fast_state, t.req, t.header_tkt, ret,\n                                (t.server != NULL) ? t.server->princ : NULL,\n                                response, status, e_data);\n    }\n\n    krb5_free_kdc_req(context, request);\n    kdc_free_rstate(fast_state);\n    kau_free_kdc_req(au_state);\n    free_req_info(context, &t);\n    krb5_free_pa_data(context, e_data);\n    return ret;\n}\n"], "fixing_code": ["/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* kdc/do_tgs_req.c - KDC Routines to deal with TGS_REQ's */\n/*\n * Copyright 1990, 1991, 2001, 2007, 2008, 2009, 2013, 2014 by the\n * Massachusetts Institute of Technology.  All Rights Reserved.\n *\n * Export of this software from the United States of America may\n *   require a specific license from the United States Government.\n *   It is the responsibility of any person or organization contemplating\n *   export to obtain such a license before exporting.\n *\n * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and\n * distribute this software and its documentation for any purpose and\n * without fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright notice and\n * this permission notice appear in supporting documentation, and that\n * the name of M.I.T. not be used in advertising or publicity pertaining\n * to distribution of the software without specific, written prior\n * permission.  Furthermore if you modify this software you must label\n * your software as modified software and not distribute it in such a\n * fashion that it might be confused with the original M.I.T. software.\n * M.I.T. makes no representations about the suitability of\n * this software for any purpose.  It is provided \"as is\" without express\n * or implied warranty.\n */\n/*\n * Copyright (c) 2006-2008, Novell, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *       this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *   * The copyright holder's name is not used to endorse or promote products\n *       derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"k5-int.h\"\n\n#include <syslog.h>\n#ifdef HAVE_NETINET_IN_H\n#include <sys/types.h>\n#include <netinet/in.h>\n#ifndef hpux\n#include <arpa/inet.h>\n#endif\n#endif\n\n#include \"kdc_util.h\"\n#include \"kdc_audit.h\"\n#include \"policy.h\"\n#include \"extern.h\"\n#include \"adm_proto.h\"\n#include <ctype.h>\n\nstruct tgs_req_info {\n    /* The decoded request.  Ownership is transferred to this structure.  This\n     * will be replaced with the inner FAST body if present. */\n    krb5_kdc_req *req;\n\n    /*\n     * The decrypted authentication header ticket from the request's\n     * PA-TGS-REQ, the KDB entry for its server, its encryption key, the\n     * PA-TGS-REQ subkey if present, and the decoded and verified header ticket\n     * PAC if present.\n     */\n    krb5_ticket *header_tkt;\n    krb5_db_entry *header_server;\n    krb5_keyblock *header_key;\n    krb5_keyblock *subkey;\n    krb5_pac header_pac;\n\n    /*\n     * If a second ticket is present and this is a U2U or S4U2Proxy request,\n     * the decoded and verified PAC if present, the KDB entry for the second\n     * ticket server server, and the key used to decrypt the second ticket.\n     */\n    krb5_pac stkt_pac;\n    krb5_db_entry *stkt_server;\n    krb5_keyblock *stkt_server_key;\n    /* For cross-realm S4U2Proxy requests, the client principal retrieved from\n     * stkt_pac. */\n    krb5_principal stkt_pac_client;\n\n    /* Storage for the local TGT KDB entry for the service realm if that isn't\n     * the header server. */\n    krb5_db_entry *local_tgt_storage;\n    /* The decrypted first key of the local TGT entry. */\n    krb5_keyblock local_tgt_key;\n\n    /* The server KDB entry.  Normally the requested server, but for referral\n     * and alternate TGS replies this will be a cross-realm TGT entry. */\n    krb5_db_entry *server;\n\n    /*\n     * The subject client KDB entry for an S4U2Self request, or the header\n     * ticket client KDB entry for other requests.  NULL if\n     * NO_AUTH_DATA_REQUIRED is set on the server KDB entry and this isn't an\n     * S4U2Self request, or if the client is in another realm and the KDB\n     * cannot map its principal name.\n     */\n    krb5_db_entry *client;\n\n    /* The decoded S4U2Self padata from the request, if present. */\n    krb5_pa_s4u_x509_user *s4u2self;\n\n    /* Authentication indicators retrieved from the header ticket, for\n     * non-S4U2Self requests. */\n    krb5_data **auth_indicators;\n\n    /* Storage for a transited list with the header TGT realm added, if that\n     * realm is different from the client and server realm. */\n    krb5_data new_transited;\n\n    /* The KDB flags applicable to this request (a subset of {CROSS_REALM,\n     * ISSUING_REFERRAL, PROTOCOL_TRANSITION, CONSTRAINED_DELEGATION}). */\n    unsigned int flags;\n\n    /* Booleans for two of the above flags, for convenience. */\n    krb5_boolean is_referral;\n    krb5_boolean is_crossrealm;\n\n    /* The authtime of subject_tkt.  On early failures this may be 0. */\n    krb5_timestamp authtime;\n\n    /* The following fields are (or contain) alias pointers and should not be\n     * freed. */\n\n    /* The transited list implied by the request, aliasing new_transited or the\n     * header ticket transited field. */\n    krb5_transited transited;\n\n    /* Alias to the decrypted second ticket within req, if one applies to this\n     * request. */\n    const krb5_ticket *stkt;\n\n    /* Alias to stkt for S4U2Proxy requests, header_tkt otherwise. */\n    krb5_enc_tkt_part *subject_tkt;\n\n    /* Alias to local_tgt_storage or header_server. */\n    krb5_db_entry *local_tgt;\n\n    /* For either kind of S4U request, an alias to the requested client\n     * principal name. */\n    krb5_principal s4u_cprinc;\n\n    /* An alias to the client principal name we should issue the ticket for\n     * (either header_tkt->enc_part2->client or s4u_cprinc). */\n    krb5_principal tkt_client;\n\n    /* The client principal of the PA-TGS-REQ header ticket.  On early failures\n     * this may be NULL. */\n    krb5_principal cprinc;\n\n    /* The canonicalized request server principal or referral/alternate TGT.\n     * On early failures this may be the requested server instead. */\n    krb5_principal sprinc;\n\n};\n\nstatic krb5_error_code\ndb_get_svc_princ(krb5_context, krb5_principal, krb5_flags,\n                 krb5_db_entry **, const char **);\n\nstatic krb5_error_code\nprepare_error_tgs(struct kdc_request_state *state, krb5_kdc_req *request,\n                  krb5_ticket *ticket, krb5_error_code code,\n                  krb5_principal canon_server, krb5_data **response,\n                  const char *status, krb5_pa_data **e_data)\n{\n    krb5_context context = state->realm_data->realm_context;\n    krb5_error errpkt;\n    krb5_error_code retval = 0;\n    krb5_data *scratch, *e_data_asn1 = NULL, *fast_edata = NULL;\n\n    errpkt.magic = KV5M_ERROR;\n    errpkt.ctime = 0;\n    errpkt.cusec = 0;\n\n    retval = krb5_us_timeofday(context, &errpkt.stime, &errpkt.susec);\n    if (retval)\n        return(retval);\n    errpkt.error = errcode_to_protocol(code);\n    errpkt.server = request->server;\n    if (ticket && ticket->enc_part2)\n        errpkt.client = ticket->enc_part2->client;\n    else\n        errpkt.client = NULL;\n    errpkt.text.length = strlen(status);\n    if (!(errpkt.text.data = strdup(status)))\n        return ENOMEM;\n\n    if (!(scratch = (krb5_data *)malloc(sizeof(*scratch)))) {\n        free(errpkt.text.data);\n        return ENOMEM;\n    }\n\n    if (e_data != NULL) {\n        retval = encode_krb5_padata_sequence(e_data, &e_data_asn1);\n        if (retval) {\n            free(scratch);\n            free(errpkt.text.data);\n            return retval;\n        }\n        errpkt.e_data = *e_data_asn1;\n    } else\n        errpkt.e_data = empty_data();\n\n    retval = kdc_fast_handle_error(context, state, request, e_data,\n                                   &errpkt, &fast_edata);\n    if (retval) {\n        free(scratch);\n        free(errpkt.text.data);\n        krb5_free_data(context, e_data_asn1);\n        return retval;\n    }\n    if (fast_edata)\n        errpkt.e_data = *fast_edata;\n    if (kdc_fast_hide_client(state) && errpkt.client != NULL)\n        errpkt.client = (krb5_principal)krb5_anonymous_principal();\n    retval = krb5_mk_error(context, &errpkt, scratch);\n    free(errpkt.text.data);\n    krb5_free_data(context, e_data_asn1);\n    krb5_free_data(context, fast_edata);\n    if (retval)\n        free(scratch);\n    else\n        *response = scratch;\n\n    return retval;\n}\n\n/* KDC options that require a second ticket */\n#define STKT_OPTIONS (KDC_OPT_CNAME_IN_ADDL_TKT | KDC_OPT_ENC_TKT_IN_SKEY)\n/*\n * If req is a second-ticket request and a second ticket is present, decrypt\n * it.  Set *stkt_out to an alias to the ticket with populated enc_part2.  Set\n * *server_out to the server DB entry and *key_out to the ticket decryption\n * key.\n */\nstatic krb5_error_code\ndecrypt_2ndtkt(krb5_context context, krb5_kdc_req *req, krb5_flags flags,\n               krb5_db_entry *local_tgt, krb5_keyblock *local_tgt_key,\n               const krb5_ticket **stkt_out, krb5_pac *pac_out,\n               krb5_db_entry **server_out, krb5_keyblock **key_out,\n               const char **status)\n{\n    krb5_error_code retval;\n    krb5_db_entry *server = NULL;\n    krb5_keyblock *key = NULL;\n    krb5_kvno kvno;\n    krb5_ticket *stkt;\n\n    *stkt_out = NULL;\n    *pac_out = NULL;\n    *server_out = NULL;\n    *key_out = NULL;\n\n    if (!(req->kdc_options & STKT_OPTIONS) || req->second_ticket == NULL ||\n        req->second_ticket[0] == NULL)\n        return 0;\n\n    stkt = req->second_ticket[0];\n    retval = kdc_get_server_key(context, stkt, flags, TRUE, &server, &key,\n                                &kvno);\n    if (retval != 0) {\n        *status = \"2ND_TKT_SERVER\";\n        goto cleanup;\n    }\n    retval = krb5_decrypt_tkt_part(context, key, stkt);\n    if (retval != 0) {\n        *status = \"2ND_TKT_DECRYPT\";\n        goto cleanup;\n    }\n    retval = get_verified_pac(context, stkt->enc_part2, server, key, local_tgt,\n                              local_tgt_key, pac_out);\n    if (retval != 0) {\n        *status = \"2ND_TKT_PAC\";\n        goto cleanup;\n    }\n    *stkt_out = stkt;\n    *server_out = server;\n    *key_out = key;\n    server = NULL;\n    key = NULL;\n\ncleanup:\n    krb5_db_free_principal(context, server);\n    krb5_free_keyblock(context, key);\n    return retval;\n}\n\nstatic krb5_error_code\nget_2ndtkt_enctype(krb5_kdc_req *req, krb5_enctype *useenctype,\n                   const char **status)\n{\n    krb5_enctype etype;\n    krb5_ticket *stkt = req->second_ticket[0];\n    int i;\n\n    etype = stkt->enc_part2->session->enctype;\n    if (!krb5_c_valid_enctype(etype)) {\n        *status = \"BAD_ETYPE_IN_2ND_TKT\";\n        return KRB5KDC_ERR_ETYPE_NOSUPP;\n    }\n    for (i = 0; i < req->nktypes; i++) {\n        if (req->ktype[i] == etype) {\n            *useenctype = etype;\n            break;\n        }\n    }\n    return 0;\n}\n\nstatic krb5_error_code\ngen_session_key(krb5_context context, krb5_kdc_req *req, krb5_db_entry *server,\n                krb5_keyblock *skey, const char **status)\n{\n    krb5_error_code retval;\n    krb5_enctype useenctype = 0;\n\n    /*\n     * Some special care needs to be taken in the user-to-user\n     * case, since we don't know what keytypes the application server\n     * which is doing user-to-user authentication can support.  We\n     * know that it at least must be able to support the encryption\n     * type of the session key in the TGT, since otherwise it won't be\n     * able to decrypt the U2U ticket!  So we use that in preference\n     * to anything else.\n     */\n    if (req->kdc_options & KDC_OPT_ENC_TKT_IN_SKEY) {\n        retval = get_2ndtkt_enctype(req, &useenctype, status);\n        if (retval != 0)\n            return retval;\n    }\n    if (useenctype == 0) {\n        useenctype = select_session_keytype(context, server,\n                                            req->nktypes, req->ktype);\n    }\n    if (useenctype == 0) {\n        /* unsupported ktype */\n        *status = \"BAD_ENCRYPTION_TYPE\";\n        return KRB5KDC_ERR_ETYPE_NOSUPP;\n    }\n\n    return krb5_c_make_random_key(context, useenctype, skey);\n}\n\n/*\n * The request seems to be for a ticket-granting service somewhere else,\n * but we don't have a ticket for the final TGS.  Try to give the requestor\n * some intermediate realm.\n */\nstatic krb5_error_code\nfind_alternate_tgs(krb5_context context, krb5_principal princ,\n                   krb5_db_entry **server_ptr, const char **status)\n{\n    krb5_error_code retval;\n    krb5_principal *plist = NULL, *pl2;\n    krb5_data tmp;\n    krb5_db_entry *server = NULL;\n\n    *server_ptr = NULL;\n    assert(is_cross_tgs_principal(princ));\n    retval = krb5_walk_realm_tree(context, &princ->realm, &princ->data[1],\n                                  &plist, KRB5_REALM_BRANCH_CHAR);\n    if (retval)\n        goto cleanup;\n    /* move to the end */\n    for (pl2 = plist; *pl2; pl2++);\n\n    /* the first entry in this array is for krbtgt/local@local, so we\n       ignore it */\n    while (--pl2 > plist) {\n        tmp = *krb5_princ_realm(context, *pl2);\n        krb5_princ_set_realm(context, *pl2, &princ->realm);\n        retval = db_get_svc_princ(context, *pl2, 0, &server, status);\n        krb5_princ_set_realm(context, *pl2, &tmp);\n        if (retval == KRB5_KDB_NOENTRY)\n            continue;\n        else if (retval)\n            goto cleanup;\n\n        log_tgs_alt_tgt(context, server->princ);\n        *server_ptr = server;\n        server = NULL;\n        goto cleanup;\n    }\ncleanup:\n    if (retval == 0 && *server_ptr == NULL)\n        retval = KRB5_KDB_NOENTRY;\n    if (retval != 0)\n        *status = \"UNKNOWN_SERVER\";\n\n    krb5_free_realm_tree(context, plist);\n    krb5_db_free_principal(context, server);\n    return retval;\n}\n\n/* Return true if item is an element of the space/comma-separated list. */\nstatic krb5_boolean\nin_list(const char *list, const char *item)\n{\n    const char *p;\n    int len = strlen(item);\n\n    if (list == NULL)\n        return FALSE;\n    for (p = strstr(list, item); p != NULL; p = strstr(p + 1, item)) {\n        if ((p == list || isspace((unsigned char)p[-1]) || p[-1] == ',') &&\n            (p[len] == '\\0' || isspace((unsigned char)p[len]) ||\n             p[len] == ','))\n                return TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Check whether the request satisfies the conditions for generating a referral\n * TGT.  The caller checks whether the hostname component looks like a FQDN.\n */\nstatic krb5_boolean\nis_referral_req(kdc_realm_t *realm, krb5_kdc_req *request)\n{\n    krb5_boolean ret = FALSE;\n    char *stype = NULL;\n    char *hostbased = realm->realm_hostbased;\n    char *no_referral = realm->realm_no_referral;\n\n    if (!(request->kdc_options & KDC_OPT_CANONICALIZE))\n        return FALSE;\n\n    if (request->kdc_options & KDC_OPT_ENC_TKT_IN_SKEY)\n        return FALSE;\n\n    if (request->server->length != 2)\n        return FALSE;\n\n    stype = data2string(&request->server->data[0]);\n    if (stype == NULL)\n        return FALSE;\n    switch (request->server->type) {\n    case KRB5_NT_UNKNOWN:\n        /* Allow referrals for NT-UNKNOWN principals, if configured. */\n        if (!in_list(hostbased, stype) && !in_list(hostbased, \"*\"))\n            goto cleanup;\n        /* FALLTHROUGH */\n    case KRB5_NT_SRV_HST:\n    case KRB5_NT_SRV_INST:\n        /* Deny referrals for specific service types, if configured. */\n        if (in_list(no_referral, stype) || in_list(no_referral, \"*\"))\n            goto cleanup;\n        ret = TRUE;\n        break;\n    default:\n        goto cleanup;\n    }\ncleanup:\n    free(stype);\n    return ret;\n}\n\n/*\n * Find a remote realm TGS principal for an unknown host-based service\n * principal.\n */\nstatic krb5_int32\nfind_referral_tgs(kdc_realm_t *realm, krb5_kdc_req *request,\n                  krb5_principal *krbtgt_princ)\n{\n    krb5_context context = realm->realm_context;\n    krb5_error_code retval = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n    char **realms = NULL, *hostname = NULL;\n    krb5_data srealm = request->server->realm;\n\n    if (!is_referral_req(realm, request))\n        goto cleanup;\n\n    hostname = data2string(&request->server->data[1]);\n    if (hostname == NULL) {\n        retval = ENOMEM;\n        goto cleanup;\n    }\n    /* If the hostname doesn't contain a '.', it's not a FQDN. */\n    if (strchr(hostname, '.') == NULL)\n        goto cleanup;\n    retval = krb5_get_host_realm(context, hostname, &realms);\n    if (retval) {\n        /* no match found */\n        kdc_err(context, retval, \"unable to find realm of host\");\n        goto cleanup;\n    }\n    /* Don't return a referral to the empty realm or the service realm. */\n    if (realms == NULL || realms[0] == NULL || *realms[0] == '\\0' ||\n        data_eq_string(srealm, realms[0])) {\n        retval = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n        goto cleanup;\n    }\n    retval = krb5_build_principal(context, krbtgt_princ,\n                                  srealm.length, srealm.data,\n                                  \"krbtgt\", realms[0], (char *)0);\ncleanup:\n    krb5_free_host_realm(context, realms);\n    free(hostname);\n\n    return retval;\n}\n\nstatic krb5_error_code\ndb_get_svc_princ(krb5_context ctx, krb5_principal princ,\n                 krb5_flags flags, krb5_db_entry **server,\n                 const char **status)\n{\n    krb5_error_code ret;\n\n    ret = krb5_db_get_principal(ctx, princ, flags, server);\n    if (ret == KRB5_KDB_CANTLOCK_DB)\n        ret = KRB5KDC_ERR_SVC_UNAVAILABLE;\n    if (ret != 0) {\n        *status = \"LOOKING_UP_SERVER\";\n    }\n    return ret;\n}\n\nstatic krb5_error_code\nsearch_sprinc(kdc_realm_t *realm, krb5_kdc_req *req,\n              krb5_flags flags, krb5_db_entry **server, const char **status)\n{\n    krb5_context context = realm->realm_context;\n    krb5_error_code ret;\n    krb5_principal princ = req->server;\n    krb5_principal reftgs = NULL;\n    krb5_boolean allow_referral;\n\n    /* Do not allow referrals for u2u or ticket modification requests, because\n     * the server is supposed to match an already-issued ticket. */\n    allow_referral = !(req->kdc_options & NO_REFERRAL_OPTION);\n    if (!allow_referral)\n        flags &= ~KRB5_KDB_FLAG_REFERRAL_OK;\n\n    ret = db_get_svc_princ(context, princ, flags, server, status);\n    if (ret == 0 || ret != KRB5_KDB_NOENTRY || !allow_referral)\n        goto cleanup;\n\n    if (!is_cross_tgs_principal(req->server)) {\n        ret = find_referral_tgs(realm, req, &reftgs);\n        if (ret != 0)\n            goto cleanup;\n        ret = db_get_svc_princ(context, reftgs, flags, server, status);\n        if (ret == 0 || ret != KRB5_KDB_NOENTRY)\n            goto cleanup;\n\n        princ = reftgs;\n    }\n    ret = find_alternate_tgs(context, princ, server, status);\n\ncleanup:\n    if (ret != 0 && ret != KRB5KDC_ERR_SVC_UNAVAILABLE) {\n        ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n        if (*status == NULL)\n            *status = \"LOOKING_UP_SERVER\";\n    }\n    krb5_free_principal(context, reftgs);\n    return ret;\n}\n\n/*\n * Transfer ownership of *reqptr to *t and fill *t with information about the\n * request.  Decode the PA-TGS-REQ header ticket and the second ticket if\n * applicable, and decode and verify their PACs if present.  Decode and verify\n * the S4U2Self request pa-data if present.  Extract authentication indicators\n * from the subject ticket.  Construct the transited list implied by the\n * request.\n */\nstatic krb5_error_code\ngather_tgs_req_info(kdc_realm_t *realm, krb5_kdc_req **reqptr, krb5_data *pkt,\n                    const krb5_fulladdr *from,\n                    struct kdc_request_state *fast_state,\n                    krb5_audit_state *au_state, struct tgs_req_info *t,\n                    const char **status)\n{\n    krb5_context context = realm->realm_context;\n    krb5_error_code ret;\n    krb5_pa_data *pa_tgs_req;\n    unsigned int s_flags;\n    krb5_enc_tkt_part *header_enc;\n    krb5_data d;\n\n    /* Transfer ownership of *reqptr to *t. */\n    t->req = *reqptr;\n    *reqptr = NULL;\n\n    if (t->req->msg_type != KRB5_TGS_REQ)\n        return KRB5_BADMSGTYPE;\n\n    /* Initially set t->sprinc to the outer request server, for logging of\n     * early failures. */\n    t->sprinc = t->req->server;\n\n    /* Read the PA-TGS-REQ authenticator and decrypt the header ticket. */\n    ret = kdc_process_tgs_req(realm, t->req, from, pkt, &t->header_tkt,\n                              &t->header_server, &t->header_key, &t->subkey,\n                              &pa_tgs_req);\n    if (t->header_tkt != NULL && t->header_tkt->enc_part2 != NULL)\n        t->cprinc = t->header_tkt->enc_part2->client;\n    if (ret) {\n        *status = \"PROCESS_TGS\";\n        return ret;\n    }\n    ret = kau_make_tkt_id(context, t->header_tkt, &au_state->tkt_in_id);\n    if (ret)\n        return ret;\n    header_enc = t->header_tkt->enc_part2;\n\n    /* If PA-FX-FAST-REQUEST padata is present, replace t->req with the inner\n     * request body. */\n    d = make_data(pa_tgs_req->contents, pa_tgs_req->length);\n    ret = kdc_find_fast(&t->req, &d, t->subkey, header_enc->session,\n                        fast_state, NULL);\n    if (ret) {\n        *status = \"FIND_FAST\";\n        return ret;\n    }\n    /* Reset t->sprinc for the inner body and check it. */\n    t->sprinc = t->req->server;\n    if (t->sprinc == NULL) {\n        *status = \"NULL_SERVER\";\n        return KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n    }\n\n    /* The header ticket server is usually a TGT, but if it is not, fetch the\n     * local TGT for the realm.  Get the decrypted first local TGT key. */\n    ret = get_local_tgt(context, &t->sprinc->realm, t->header_server,\n                        &t->local_tgt, &t->local_tgt_storage,\n                        &t->local_tgt_key);\n    if (ret) {\n        *status = \"GET_LOCAL_TGT\";\n        return ret;\n    }\n\n    /* Decode and verify the header ticket PAC. */\n    ret = get_verified_pac(context, header_enc, t->header_server,\n                           t->header_key, t->local_tgt, &t->local_tgt_key,\n                           &t->header_pac);\n    if (ret) {\n        *status = \"HEADER_PAC\";\n        return ret;\n    }\n\n    au_state->request = t->req;\n    au_state->stage = SRVC_PRINC;\n\n    /* Look up the server principal entry, or a referral/alternate TGT.  Reset\n     * t->sprinc to the canonical server name (its final value). */\n    s_flags = (t->req->kdc_options & KDC_OPT_CANONICALIZE) ?\n        KRB5_KDB_FLAG_REFERRAL_OK : 0;\n    ret = search_sprinc(realm, t->req, s_flags, &t->server, status);\n    if (ret)\n        return ret;\n    t->sprinc = t->server->princ;\n\n    /* If we got a cross-realm TGS which is not the requested server, we are\n     * issuing a referral (or alternate TGT, which we treat similarly). */\n    if (is_cross_tgs_principal(t->server->princ) &&\n        !krb5_principal_compare(context, t->req->server, t->server->princ))\n        t->flags |= KRB5_KDB_FLAG_ISSUING_REFERRAL;\n\n    /* Mark the request as cross-realm if the header ticket server is not from\n     * this realm. */\n    if (!data_eq(t->header_server->princ->realm, t->sprinc->realm))\n        t->flags |= KRB5_KDB_FLAG_CROSS_REALM;\n\n    t->is_referral = (t->flags & KRB5_KDB_FLAG_ISSUING_REFERRAL);\n    t->is_crossrealm = (t->flags & KRB5_KDB_FLAG_CROSS_REALM);\n\n    /* If S4U2Self padata is present, read it to get the requested principal\n     * name.  Look up the requested client if it is in this realm. */\n    ret = kdc_process_s4u2self_req(context, t->req, t->server, t->subkey,\n                                   header_enc->session, &t->s4u2self,\n                                   &t->client, status);\n    if (t->s4u2self != NULL || ret) {\n        if (t->s4u2self != NULL)\n            au_state->s4u2self_user = t->s4u2self->user_id.user;\n        au_state->status = *status;\n        kau_s4u2self(context, !ret, au_state);\n        au_state->s4u2self_user = NULL;\n    }\n    if (ret)\n        return ret;\n    if (t->s4u2self != NULL) {\n        t->flags |= KRB5_KDB_FLAG_PROTOCOL_TRANSITION;\n        t->s4u_cprinc = t->s4u2self->user_id.user;\n\n        /*\n         * For consistency with Active Directory, don't allow authorization\n         * data to be disabled if S4U2Self is requested.  The requesting\n         * service likely needs a PAC for an S4U2Proxy operation, even if it\n         * doesn't need authorization data in tickets received from clients.\n         */\n        t->server->attributes &= ~KRB5_KDB_NO_AUTH_DATA_REQUIRED;\n    }\n\n    /* For U2U or S4U2Proxy requests, decrypt the second ticket and read its\n     * PAC. */\n    ret = decrypt_2ndtkt(context, t->req, t->flags, t->local_tgt,\n                         &t->local_tgt_key, &t->stkt, &t->stkt_pac,\n                         &t->stkt_server, &t->stkt_server_key, status);\n    if (ret)\n        return ret;\n\n    /* Determine the subject ticket and set the authtime for logging.  For\n     * S4U2Proxy requests determine the requested client principal. */\n    if (t->req->kdc_options & KDC_OPT_CNAME_IN_ADDL_TKT) {\n        t->flags |= KRB5_KDB_FLAG_CONSTRAINED_DELEGATION;\n        ret = kau_make_tkt_id(context, t->stkt, &au_state->evid_tkt_id);\n        if (ret)\n            return ret;\n        if (t->is_crossrealm) {\n            /* For cross-realm S4U2PROXY requests, the second ticket is a\n             * cross TGT with the requested client principal in its PAC. */\n            if (t->stkt_pac == NULL ||\n                get_pac_princ_with_realm(context, t->stkt_pac,\n                                         &t->stkt_pac_client, NULL) != 0) {\n                au_state->status = *status = \"RBCD_PAC_PRINC\";\n                au_state->violation = PROT_CONSTRAINT;\n                kau_s4u2proxy(context, FALSE, au_state);\n                return KRB5KDC_ERR_BADOPTION;\n            }\n            t->s4u_cprinc = t->stkt_pac_client;\n        } else {\n            /* Otherwise the requested client is the evidence ticket client. */\n            t->s4u_cprinc = t->stkt->enc_part2->client;\n        }\n        t->subject_tkt = t->stkt->enc_part2;\n    } else {\n        t->subject_tkt = header_enc;\n    }\n    t->authtime = t->subject_tkt->times.authtime;\n\n    /* For final S4U requests (either type) the issued ticket will be for the\n     * requested name; otherwise it will be for the header ticket client. */\n    t->tkt_client = ((t->flags & KRB5_KDB_FLAGS_S4U) && !t->is_referral) ?\n        t->s4u_cprinc : header_enc->client;\n\n    if (t->s4u2self == NULL) {\n        /* Extract auth indicators from the subject ticket.  Skip this for\n         * S4U2Self requests as the subject didn't authenticate. */\n        ret = get_auth_indicators(context, t->subject_tkt, t->local_tgt,\n                                  &t->local_tgt_key, &t->auth_indicators);\n        if (ret) {\n            *status = \"GET_AUTH_INDICATORS\";\n            return ret;\n        }\n\n        if (!(t->server->attributes & KRB5_KDB_NO_AUTH_DATA_REQUIRED)) {\n            /* Try to look up the subject principal so that KDB modules can add\n             * additional authdata.  Ask the KDB to map foreign principals. */\n            assert(t->client == NULL);\n            (void)krb5_db_get_principal(context, t->subject_tkt->client,\n                                        t->flags | KRB5_KDB_FLAG_CLIENT |\n                                        KRB5_KDB_FLAG_MAP_PRINCIPALS,\n                                        &t->client);\n        }\n    }\n\n    /*\n     * Compute the transited list implied by the request.  Use the existing\n     * transited list if the realm of the header ticket server is the same as\n     * the subject or server realm.\n     */\n    if (!t->is_crossrealm ||\n        data_eq(t->header_tkt->server->realm, t->tkt_client->realm)) {\n        t->transited = header_enc->transited;\n    } else {\n        if (header_enc->transited.tr_type != KRB5_DOMAIN_X500_COMPRESS) {\n            *status = \"VALIDATE_TRANSIT_TYPE\";\n            return KRB5KDC_ERR_TRTYPE_NOSUPP;\n        }\n        ret = add_to_transited(&header_enc->transited.tr_contents,\n                               &t->new_transited, t->header_tkt->server,\n                               t->tkt_client, t->req->server);\n        if (ret) {\n            *status = \"ADD_TO_TRANSITED_LIST\";\n            return ret;\n        }\n        t->transited.tr_type = KRB5_DOMAIN_X500_COMPRESS;\n        t->transited.tr_contents = t->new_transited;\n    }\n\n    return 0;\n}\n\n/* Fill in *times_out with the times of the ticket to be issued.  Set the\n * TKT_FLG_RENEWABLE bit in *tktflags if the ticket will be renewable. */\nstatic void\ncompute_ticket_times(kdc_realm_t *realm, struct tgs_req_info *t,\n                     krb5_timestamp kdc_time, krb5_flags *tktflags,\n                     krb5_ticket_times *times)\n{\n    krb5_timestamp hstarttime;\n    krb5_deltat hlife;\n    krb5_ticket_times *htimes = &t->header_tkt->enc_part2->times;\n\n    if (t->req->kdc_options & KDC_OPT_VALIDATE) {\n        /* Validation requests preserve the header ticket times. */\n        *times = *htimes;\n        return;\n    }\n\n    /* Preserve the authtime from the subject ticket. */\n    times->authtime = t->authtime;\n\n    times->starttime = (t->req->kdc_options & KDC_OPT_POSTDATED) ?\n        t->req->from : kdc_time;\n\n    if (t->req->kdc_options & KDC_OPT_RENEW) {\n        /* Give the new ticket the same lifetime as the header ticket, but no\n         * later than the renewable end time. */\n        hstarttime = htimes->starttime ? htimes->starttime : htimes->authtime;\n        hlife = ts_delta(htimes->endtime, hstarttime);\n        times->endtime = ts_min(htimes->renew_till,\n                                ts_incr(times->starttime, hlife));\n    } else {\n        kdc_get_ticket_endtime(realm, times->starttime, htimes->endtime,\n                               t->req->till, t->client, t->server,\n                               &times->endtime);\n    }\n\n    kdc_get_ticket_renewtime(realm, t->req, t->header_tkt->enc_part2,\n                             t->client, t->server, tktflags, times);\n\n    /* starttime is optional, and treated as authtime if not present.\n     * so we can omit it if it matches. */\n    if (times->starttime == times->authtime)\n        times->starttime = 0;\n}\n\n/* Check the request in *t against semantic protocol constraints and local\n * policy.  Determine flags and times for the ticket to be issued. */\nstatic krb5_error_code\ncheck_tgs_req(kdc_realm_t *realm, struct tgs_req_info *t,\n              krb5_audit_state *au_state, krb5_flags *tktflags,\n              krb5_ticket_times *times, const char **status,\n              krb5_pa_data ***e_data)\n{\n    krb5_context context = realm->realm_context;\n    krb5_error_code ret;\n    krb5_timestamp kdc_time;\n\n    au_state->stage = VALIDATE_POL;\n\n    ret = krb5_timeofday(context, &kdc_time);\n    if (ret)\n        return ret;\n\n    ret = check_tgs_constraints(realm, t->req, t->server, t->header_tkt,\n                                t->header_pac, t->stkt, t->stkt_pac,\n                                t->stkt_server, kdc_time, t->s4u2self,\n                                t->client, t->is_crossrealm, t->is_referral,\n                                status, e_data);\n    if (ret) {\n        au_state->violation = PROT_CONSTRAINT;\n        return ret;\n    }\n\n    ret = check_tgs_policy(realm, t->req, t->server, t->header_tkt,\n                           t->header_pac, t->stkt, t->stkt_pac,\n                           t->stkt_pac_client, t->stkt_server, kdc_time,\n                           t->is_crossrealm, t->is_referral, status, e_data);\n    if (ret) {\n        au_state->violation = LOCAL_POLICY;\n        if (t->flags & KRB5_KDB_FLAG_CONSTRAINED_DELEGATION) {\n            au_state->status = *status;\n            kau_s4u2proxy(context, FALSE, au_state);\n        }\n        return ret;\n    }\n\n    /* Check auth indicators from the subject ticket, except for S4U2Self\n     * requests (where the client didn't authenticate). */\n    if (t->s4u2self == NULL) {\n        ret = check_indicators(context, t->server, t->auth_indicators);\n        if (ret) {\n            *status = \"HIGHER_AUTHENTICATION_REQUIRED\";\n            return ret;\n        }\n    }\n\n    *tktflags = get_ticket_flags(t->req->kdc_options, t->client, t->server,\n                                 t->header_tkt->enc_part2);\n    compute_ticket_times(realm, t, kdc_time, tktflags, times);\n\n    /* For S4U2Self requests, check if we need to suppress the forwardable\n     * ticket flag. */\n    if (t->s4u2self != NULL && !t->is_referral) {\n        ret = s4u2self_forwardable(context, t->server, tktflags);\n        if (ret)\n            return ret;\n    }\n\n    /* Consult kdcpolicy modules, giving them a chance to modify the times of\n     * the issued ticket. */\n    ret = check_kdcpolicy_tgs(context, t->req, t->server, t->header_tkt,\n                              t->auth_indicators, kdc_time, times, status);\n    if (ret)\n        return ret;\n\n    if (!(t->req->kdc_options & KDC_OPT_DISABLE_TRANSITED_CHECK)) {\n        /* Check the transited path for the issued ticket and set the\n         * transited-policy-checked flag if successful. */\n        ret = kdc_check_transited_list(context, &t->transited.tr_contents,\n                                       &t->subject_tkt->client->realm,\n                                       &t->req->server->realm);\n        if (ret) {\n            /* Log the transited-check failure and continue. */\n            log_tgs_badtrans(context, t->cprinc, t->sprinc,\n                             &t->transited.tr_contents, ret);\n        } else {\n            *tktflags |= TKT_FLG_TRANSIT_POLICY_CHECKED;\n        }\n    } else {\n        krb5_klog_syslog(LOG_INFO, _(\"not checking transit path\"));\n    }\n\n    /* By default, reject the request if the transited path was not checked\n     * successfully. */\n    if (realm->realm_reject_bad_transit &&\n        !(*tktflags & TKT_FLG_TRANSIT_POLICY_CHECKED)) {\n        *status = \"BAD_TRANSIT\";\n        au_state->violation = LOCAL_POLICY;\n        return KRB5KDC_ERR_POLICY;\n    }\n\n    return 0;\n}\n\n/* Construct a response issuing a ticket for the request in *t, using tktflags\n * and *times for the ticket flags and times. */\nstatic krb5_error_code\ntgs_issue_ticket(kdc_realm_t *realm, struct tgs_req_info *t,\n                 krb5_flags tktflags, krb5_ticket_times *times, krb5_data *pkt,\n                 const krb5_fulladdr *from,\n                 struct kdc_request_state *fast_state,\n                 krb5_audit_state *au_state, const char **status,\n                 krb5_data **response)\n{\n    krb5_context context = realm->realm_context;\n    krb5_error_code ret;\n    krb5_keyblock session_key = { 0 }, server_key = { 0 };\n    krb5_keyblock *ticket_encrypting_key, *subject_key;\n    krb5_keyblock *initial_reply_key, *fast_reply_key = NULL;\n    krb5_enc_tkt_part enc_tkt_reply = { 0 };\n    krb5_ticket ticket_reply = { 0 };\n    krb5_enc_kdc_rep_part reply_encpart = { 0 };\n    krb5_kdc_rep reply = { 0 };\n    krb5_pac subject_pac;\n    krb5_db_entry *subject_server;\n    krb5_enc_tkt_part *header_enc_tkt = t->header_tkt->enc_part2;\n    krb5_last_req_entry nolrentry = { KV5M_LAST_REQ_ENTRY, KRB5_LRQ_NONE, 0 };\n    krb5_last_req_entry *nolrarray[2] = { &nolrentry, NULL };\n\n    au_state->stage = ISSUE_TKT;\n\n    ret = gen_session_key(context, t->req, t->server, &session_key, status);\n    if (ret)\n        goto cleanup;\n\n    if (t->flags & KRB5_KDB_FLAG_CONSTRAINED_DELEGATION) {\n        subject_pac = t->stkt_pac;\n        subject_server = t->stkt_server;\n        subject_key = t->stkt_server_key;\n    } else {\n        subject_pac = t->header_pac;\n        subject_server = t->header_server;\n        subject_key = t->header_key;\n    }\n\n    initial_reply_key = (t->subkey != NULL) ? t->subkey :\n        t->header_tkt->enc_part2->session;\n\n    if (t->req->kdc_options & KDC_OPT_ENC_TKT_IN_SKEY) {\n        /* For user-to-user, encrypt the ticket with the second ticket's\n         * session key. */\n        ticket_encrypting_key = t->stkt->enc_part2->session;\n    } else {\n        /* Otherwise encrypt the ticket with the server entry's first long-term\n         * key. */\n        ret = get_first_current_key(context, t->server, &server_key);\n        if (ret) {\n            *status = \"FINDING_SERVER_KEY\";\n            goto cleanup;\n        }\n        ticket_encrypting_key = &server_key;\n    }\n\n    if (t->req->kdc_options & (KDC_OPT_VALIDATE | KDC_OPT_RENEW)) {\n        /* Copy the header ticket server and all enc-part fields except for\n         * authorization data. */\n        ticket_reply.server = t->header_tkt->server;\n        enc_tkt_reply = *t->header_tkt->enc_part2;\n        enc_tkt_reply.authorization_data = NULL;\n    } else {\n        if (t->req->kdc_options & (KDC_OPT_FORWARDED | KDC_OPT_PROXY)) {\n            /* Include the requested addresses in the ticket and reply. */\n            enc_tkt_reply.caddrs = t->req->addresses;\n            reply_encpart.caddrs = t->req->addresses;\n        } else {\n            /* Use the header ticket addresses and omit them from the reply. */\n            enc_tkt_reply.caddrs = header_enc_tkt->caddrs;\n            reply_encpart.caddrs = NULL;\n        }\n\n        ticket_reply.server = t->is_referral ? t->sprinc : t->req->server;\n    }\n\n    enc_tkt_reply.flags = tktflags;\n    enc_tkt_reply.times = *times;\n    enc_tkt_reply.client = t->tkt_client;\n    enc_tkt_reply.session = &session_key;\n    enc_tkt_reply.transited = t->transited;\n\n    ret = handle_authdata(realm, t->flags, t->client, t->server,\n                          subject_server, t->local_tgt, &t->local_tgt_key,\n                          initial_reply_key, ticket_encrypting_key,\n                          subject_key, NULL, pkt, t->req, t->s4u_cprinc,\n                          subject_pac, t->subject_tkt, &t->auth_indicators,\n                          &enc_tkt_reply);\n    if (ret) {\n        krb5_klog_syslog(LOG_INFO, _(\"TGS_REQ : handle_authdata (%d)\"), ret);\n        *status = \"HANDLE_AUTHDATA\";\n        goto cleanup;\n    }\n\n    ticket_reply.enc_part2 = &enc_tkt_reply;\n\n    ret = krb5_encrypt_tkt_part(context, ticket_encrypting_key, &ticket_reply);\n    if (ret)\n        goto cleanup;\n\n    if (t->req->kdc_options & KDC_OPT_ENC_TKT_IN_SKEY) {\n        ticket_reply.enc_part.kvno = 0;\n        kau_u2u(context, TRUE, au_state);\n    } else {\n        ticket_reply.enc_part.kvno = current_kvno(t->server);\n    }\n\n    au_state->stage = ENCR_REP;\n\n    if (t->s4u2self != NULL &&\n        krb5int_find_pa_data(context, t->req->padata,\n                             KRB5_PADATA_S4U_X509_USER) != NULL) {\n        /* Add an S4U2Self response to the encrypted padata (skipped if the\n         * request only included PA-FOR-USER padata). */\n        ret = kdc_make_s4u2self_rep(context, t->subkey,\n                                    t->header_tkt->enc_part2->session,\n                                    t->s4u2self, &reply, &reply_encpart);\n        if (ret)\n            goto cleanup;\n    }\n\n    reply_encpart.session = &session_key;\n    reply_encpart.nonce = t->req->nonce;\n    reply_encpart.times = enc_tkt_reply.times;\n    reply_encpart.last_req = nolrarray;\n    reply_encpart.key_exp = 0;\n    reply_encpart.flags = enc_tkt_reply.flags;\n    reply_encpart.server = ticket_reply.server;\n\n    reply.msg_type = KRB5_TGS_REP;\n    reply.client = enc_tkt_reply.client;\n    reply.ticket = &ticket_reply;\n    reply.enc_part.kvno = 0;\n    reply.enc_part.enctype = initial_reply_key->enctype;\n    ret = kdc_fast_response_handle_padata(fast_state, t->req, &reply,\n                                          initial_reply_key->enctype);\n    if (ret)\n        goto cleanup;\n    ret = kdc_fast_handle_reply_key(fast_state, initial_reply_key,\n                                    &fast_reply_key);\n    if (ret)\n        goto cleanup;\n    ret = return_enc_padata(context, pkt, t->req, fast_reply_key, t->server,\n                            &reply_encpart,\n                            t->is_referral &&\n                            (t->req->kdc_options & KDC_OPT_CANONICALIZE));\n    if (ret) {\n        *status = \"KDC_RETURN_ENC_PADATA\";\n        goto cleanup;\n    }\n\n    ret = kau_make_tkt_id(context, &ticket_reply, &au_state->tkt_out_id);\n    if (ret)\n        goto cleanup;\n\n    if (kdc_fast_hide_client(fast_state))\n        reply.client = (krb5_principal)krb5_anonymous_principal();\n    ret = krb5_encode_kdc_rep(context, KRB5_TGS_REP, &reply_encpart,\n                              t->subkey != NULL, fast_reply_key, &reply,\n                              response);\n    if (ret)\n        goto cleanup;\n\n    log_tgs_req(context, from, t->req, &reply, t->cprinc, t->sprinc,\n                t->s4u_cprinc, t->authtime, t->flags, \"ISSUE\", 0, NULL);\n    au_state->status = \"ISSUE\";\n    au_state->reply = &reply;\n    if (t->flags & KRB5_KDB_FLAG_CONSTRAINED_DELEGATION)\n        kau_s4u2proxy(context, TRUE, au_state);\n    kau_tgs_req(context, TRUE, au_state);\n    au_state->reply = NULL;\n\ncleanup:\n    zapfree(ticket_reply.enc_part.ciphertext.data,\n            ticket_reply.enc_part.ciphertext.length);\n    zapfree(reply.enc_part.ciphertext.data, reply.enc_part.ciphertext.length);\n    krb5_free_pa_data(context, reply.padata);\n    krb5_free_pa_data(context, reply_encpart.enc_padata);\n    krb5_free_authdata(context, enc_tkt_reply.authorization_data);\n    krb5_free_keyblock_contents(context, &session_key);\n    krb5_free_keyblock_contents(context, &server_key);\n    krb5_free_keyblock(context, fast_reply_key);\n    return ret;\n}\n\nstatic void\nfree_req_info(krb5_context context, struct tgs_req_info *t)\n{\n    krb5_free_kdc_req(context, t->req);\n    krb5_free_ticket(context, t->header_tkt);\n    krb5_db_free_principal(context, t->header_server);\n    krb5_free_keyblock(context, t->header_key);\n    krb5_free_keyblock(context, t->subkey);\n    krb5_pac_free(context, t->header_pac);\n    krb5_pac_free(context, t->stkt_pac);\n    krb5_db_free_principal(context, t->stkt_server);\n    krb5_free_keyblock(context, t->stkt_server_key);\n    krb5_db_free_principal(context, t->local_tgt_storage);\n    krb5_free_keyblock_contents(context, &t->local_tgt_key);\n    krb5_db_free_principal(context, t->server);\n    krb5_db_free_principal(context, t->client);\n    krb5_free_pa_s4u_x509_user(context, t->s4u2self);\n    krb5_free_principal(context, t->stkt_pac_client);\n    k5_free_data_ptr_list(t->auth_indicators);\n    krb5_free_data_contents(context, &t->new_transited);\n}\n\nkrb5_error_code\nprocess_tgs_req(krb5_kdc_req *request, krb5_data *pkt,\n                const krb5_fulladdr *from, kdc_realm_t *realm,\n                krb5_data **response)\n{\n    krb5_context context = realm->realm_context;\n    krb5_error_code ret;\n    struct tgs_req_info t = { 0 };\n    struct kdc_request_state *fast_state = NULL;\n    krb5_audit_state *au_state = NULL;\n    krb5_pa_data **e_data = NULL;\n    krb5_flags tktflags;\n    krb5_ticket_times times = { 0 };\n    const char *emsg = NULL, *status = NULL;\n\n    ret = kdc_make_rstate(realm, &fast_state);\n    if (ret)\n        goto cleanup;\n    ret = kau_init_kdc_req(context, request, from, &au_state);\n    if (ret)\n        goto cleanup;\n    kau_tgs_req(context, TRUE, au_state);\n\n    ret = gather_tgs_req_info(realm, &request, pkt, from, fast_state, au_state,\n                              &t, &status);\n    if (ret)\n        goto cleanup;\n\n    ret = check_tgs_req(realm, &t, au_state, &tktflags, &times, &status,\n                        &e_data);\n    if (ret)\n        goto cleanup;\n\n    ret = tgs_issue_ticket(realm, &t, tktflags, &times, pkt, from, fast_state,\n                           au_state, &status, response);\n    if (ret)\n        goto cleanup;\n\ncleanup:\n    if (status == NULL)\n        status = \"UNKNOWN_REASON\";\n\n    if (ret) {\n        emsg = krb5_get_error_message(context, ret);\n        log_tgs_req(context, from, t.req, NULL, t.cprinc, t.sprinc,\n                    t.s4u_cprinc, t.authtime, t.flags, status, ret, emsg);\n        krb5_free_error_message(context, emsg);\n\n        if (au_state != NULL) {\n            au_state->status = status;\n            kau_tgs_req(context, FALSE, au_state);\n        }\n    }\n\n    if (ret && fast_state != NULL) {\n        ret = prepare_error_tgs(fast_state, t.req, t.header_tkt, ret,\n                                (t.server != NULL) ? t.server->princ : NULL,\n                                response, status, e_data);\n    }\n\n    krb5_free_kdc_req(context, request);\n    kdc_free_rstate(fast_state);\n    kau_free_kdc_req(au_state);\n    free_req_info(context, &t);\n    krb5_free_pa_data(context, e_data);\n    return ret;\n}\n"], "filenames": ["src/kdc/do_tgs_req.c"], "buggy_code_start_loc": [1013], "buggy_code_end_loc": [1015], "fixing_code_start_loc": [1013], "fixing_code_end_loc": [1016], "type": "CWE-415", "message": "kdc/do_tgs_req.c in MIT Kerberos 5 (aka krb5) 1.21 before 1.21.2 has a double free that is reachable if an authenticated user can trigger an authorization-data handling failure. Incorrect data is copied from one ticket to another.", "other": {"cve": {"id": "CVE-2023-39975", "sourceIdentifier": "cve@mitre.org", "published": "2023-08-16T15:15:11.277", "lastModified": "2024-02-01T17:15:08.610", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "kdc/do_tgs_req.c in MIT Kerberos 5 (aka krb5) 1.21 before 1.21.2 has a double free that is reachable if an authenticated user can trigger an authorization-data handling failure. Incorrect data is copied from one ticket to another."}, {"lang": "es", "value": "kdc/do_tgs_req.c en MIT Kerberos 5 (tambi\u00e9n conocido como krb5) 1.21 antes de 1.21.2 tiene un double free que es accesible si un usuario autenticado puede desencadenar un error de gesti\u00f3n de datos de autorizaci\u00f3n. Los datos incorrectos se copian de un ticket a otro."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-415"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.21", "versionEndExcluding": "1.21.2", "matchCriteriaId": "BA50866D-BAAB-46DD-A6AC-8F8539414285"}]}]}], "references": [{"url": "https://github.com/krb5/krb5/commit/88a1701b423c13991a8064feeb26952d3641d840", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/krb5/krb5/compare/krb5-1.21.1-final...krb5-1.21.2-final", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://security.netapp.com/advisory/ntap-20230915-0014/", "source": "cve@mitre.org"}, {"url": "https://security.netapp.com/advisory/ntap-20240201-0005/", "source": "cve@mitre.org"}, {"url": "https://security.netapp.com/advisory/ntap-20240201-0008/", "source": "cve@mitre.org"}, {"url": "https://web.mit.edu/kerberos/www/advisories/", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/krb5/krb5/commit/88a1701b423c13991a8064feeb26952d3641d840"}}